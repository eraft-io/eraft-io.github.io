1
00:00:01,300 --> 00:00:05,129
[音乐]

2
00:00:05,200 --> 00:00:05,930
[掌声]

3
00:00:05,930 --> 00:00:08,630
[音乐]

4
00:00:08,630 --> 00:00:10,020
[掌声]

5
00:00:10,020 --> 00:00:11,960
[音乐]

6
00:00:11,960 --> 00:00:15,240
所以今天实际上有我

7
00:00:15,240 --> 00:00:16,650
最喜欢的讲座之一 我们再次谈论戴维斯

8
00:00:16,650 --> 00:00:19,410
压缩 这里的高级想法

9
00:00:19,410 --> 00:00:20,910
是我们将能够

10
00:00:20,910 --> 00:00:23,580
压缩 我们数据库中数据的大小

11
00:00:23,580 --> 00:00:26,460
，你知道节省内存节省

12
00:00:26,460 --> 00:00:28,289
存储，但在某些情况下，实际上我们

13
00:00:28,289 --> 00:00:29,400
也将能够更快地执行查询

14
00:00:29,400 --> 00:00:31,890
，因为我们将

15
00:00:31,890 --> 00:00:33,510
压缩事物的方式我们可以

16
00:00:33,510 --> 00:00:35,640
知道如何 事情已经安排好，并且

17
00:00:35,640 --> 00:00:38,160
更高效地做事在我们

18
00:00:38,160 --> 00:00:40,320
开始之前只是提醒一下，

19
00:00:40,320 --> 00:00:44,160
今天 4:30 在这里有一个技术演讲，

20
00:00:44,160 --> 00:00:47,460
来自甲骨文的 Neil Simon

21
00:00:47,460 --> 00:00:48,379
是内存

22
00:00:48,379 --> 00:00:50,910
数据库团队的一名工作人员，所以 他回答说

23
00:00:50,910 --> 00:00:52,949
来看看我也想谈论的另一件事

24
00:00:52,949 --> 00:00:55,530
是上一堂课我们正在

25
00:00:55,530 --> 00:00:59,789
看 mem 续集，我们有这个

26
00:00:59,789 --> 00:01:01,920
位类型，我们就像哦，

27
00:01:01,920 --> 00:01:06,840
位类型怎么能是一个字节，我阅读了

28
00:01:06,840 --> 00:01:08,460
文档 在续集标准

29
00:01:08,460 --> 00:01:11,070
和其他系统中，它是实际的 盟友一个

30
00:01:11,070 --> 00:01:13,380
位串而不是一个位，所以你可以

31
00:01:13,380 --> 00:01:16,830
指定你想要多少位，但

32
00:01:16,830 --> 00:01:18,299
我昨晚给 mem sequel 人发了电子邮件

33
00:01:18,299 --> 00:01:19,409
说这个文档有点

34
00:01:19,409 --> 00:01:21,600
令人困惑，因为你可以

35
00:01:21,600 --> 00:01:23,790
为此设置任意大小，但

36
00:01:23,790 --> 00:01:26,310
不清楚为什么是 它是 8 个字节，就像我

37
00:01:26,310 --> 00:01:28,829
将它设置为一个位一样，它只是驱动了一个

38
00:01:28,829 --> 00:01:30,390
位，我真的要把它存储为

39
00:01:30,390 --> 00:01:34,500
8 个字节，他说他们正在尝试这

40
00:01:34,500 --> 00:01:36,360
是我的续集的某种兼容性，

41
00:01:36,360 --> 00:01:37,770
他们正在尝试遵循和 然后

42
00:01:37,770 --> 00:01:39,270
实际上在他们称为单一存储的新列存储

43
00:01:39,270 --> 00:01:41,340
系统中，他们

44
00:01:41,340 --> 00:01:42,750
实际上可以压缩这个

45
00:01:42,750 --> 00:01:44,790
位图我不知道他们是如何做到这一点的

46
00:01:44,790 --> 00:01:46,320
，但我们将

47
00:01:46,320 --> 00:01:48,600
在前面的讲座中再次看到如何在此剪辑中进行位图压缩

48
00:01:48,600 --> 00:01:50,340
向你展示

49
00:01:50,340 --> 00:01:51,990
它的样子 所以这实际上是

50
00:01:51,990 --> 00:01:55,860
Postgres 所以我可以声明一个

51
00:01:55,860 --> 00:02:00,060
具有正确位类型的表，你可以指定

52
00:02:00,060 --> 00:02:01,799
你想要的位数，然后

53
00:02:01,799 --> 00:02:03,149
在这里你可以指定

54
00:02:03,149 --> 00:02:05,520
它是一个口头位数 所以 - 我

55
00:02:05,520 --> 00:02:08,128
不 不喜欢

56
00:02:08,128 --> 00:02:10,258
这个来自帖子文档的小变化，所以

57
00:02:10,258 --> 00:02:12,660
你们

58
00:02:12,660 --> 00:02:18,960
用倒钩替换它，就像那样，

59
00:02:18,960 --> 00:02:21,450
然后现在如果我确定表格，我可以

60
00:02:21,450 --> 00:02:23,340
指定我想要一个像

61
00:02:23,340 --> 00:02:25,200
这样的字符串，然后继续 存储它

62
00:02:25,200 --> 00:02:27,540
，然后当我选择时，我会取回

63
00:02:27,540 --> 00:02:30,690
Fitch 饮料，在 Postgres 的情况下

64
00:02:30,690 --> 00:02:32,940
，有两个 bar 位和常规位

65
00:02:32,940 --> 00:02:35,100
是如果我现在尝试

66
00:02:35,100 --> 00:02:36,810
在第一个中插入一些东西，因为我说

67
00:02:36,810 --> 00:02:38,790
必须有 三位，如果我尝试

68
00:02:38,790 --> 00:02:41,920
搜索只有两位

69
00:02:41,920 --> 00:02:43,100
[音乐]

70
00:02:43,100 --> 00:02:46,590
这样的东西，它会抛出一个很好的错误，

71
00:02:46,590 --> 00:02:48,060
因为它说位串

72
00:02:48,060 --> 00:02:52,320
必须是三，就是它 - 为什么我们需要

73
00:02:52,320 --> 00:02:55,140
什么，为什么你会想要 需要

74
00:02:55,140 --> 00:02:56,400
一个位图用位图本地存储在您的

75
00:02:56,400 --> 00:03:03,990
数据库中，因为

76
00:03:03,990 --> 00:03:05,910
您知道作为条形图的语句会很

77
00:03:05,910 --> 00:03:08,340
浪费所以他们真正做的是

78
00:03:08,340 --> 00:03:09,810
这些 Postgres 我不

79
00:03:09,810 --> 00:03:11,550
知道他们的海鸥会像 Postgres 一样做什么

80
00:03:11,550 --> 00:03:13,140
说好吧你是说这

81
00:03:13,140 --> 00:03:15,600
件事有 可以是两位我可以将

82
00:03:15,600 --> 00:03:17,580
其存储为单个字节，因为我只

83
00:03:17,580 --> 00:03:18,150
写了八位

84
00:03:18,150 --> 00:03:30,840
是的，我

85
00:03:30,840 --> 00:03:32,520
可以存储的 Mac 大小似乎是五位，所以我尝试正确地执行此操作

86
00:03:32,520 --> 00:03:34,890
它不会很好地存储

87
00:03:34,890 --> 00:03:36,120
它实际上不喜欢 第一个，

88
00:03:36,120 --> 00:03:40,080
但就像如果我把这个做对了，

89
00:03:40,080 --> 00:03:44,160
它对于酒吧位来说太大了，但

90
00:03:44,160 --> 00:03:45,090
我试图提出的观点就像

91
00:03:45,090 --> 00:03:47,010
是酒吧位我可以存储这

92
00:03:47,010 --> 00:03:51,680
一点，它会让 我这样做是因为

93
00:03:56,209 --> 00:03:58,410
这个故事 常规坑和

94
00:03:58,410 --> 00:04:00,830
酒吧

95
00:04:08,290 --> 00:04:10,910
位将存储在这种情况下他们将

96
00:04:10,910 --> 00:04:13,280
存储大小加上位 母狗

97
00:04:13,280 --> 00:04:18,290
屏幕本身 是的 好吧 你在这里

98
00:04:18,290 --> 00:04:20,450
看起来有点字符串 发表草人

99
00:04:20,450 --> 00:04:21,620
这不是本次讲座的重点 我

100
00:04:21,620 --> 00:04:23,060
只是想澄清一下，因为我们

101
00:04:23,060 --> 00:04:24,640
上次我不知道答案

102
00:04:24,640 --> 00:04:26,630
好吧，所以我们今天要讨论的

103
00:04:26,630 --> 00:04:29,510
是压缩方案，因此我们将强制

104
00:04:29,510 --> 00:04:31,310
提供一些

105
00:04:31,310 --> 00:04:33,530
明显的背景 但是为什么你想要进行

106
00:04:33,530 --> 00:04:35,000
压缩

107
00:04:35,000 --> 00:04:36,290
实际上在基于磁盘的系统中更明显，但我们会

108
00:04:36,290 --> 00:04:37,700
看到 为什么我们仍然想在内存系统中做它

109
00:04:37,700 --> 00:04:39,530
然后我们将讨论如何做一个

110
00:04:39,530 --> 00:04:42,200
基本的朴素压缩方案，其中

111
00:04:42,200 --> 00:04:43,400
数据库系统不

112
00:04:43,400 --> 00:04:44,720
知道它们实际上是如何被

113
00:04:44,720 --> 00:04:47,600
压缩的然后我们将看看更

114
00:04:47,600 --> 00:04:49,150
复杂的 进

115
00:04:49,150 --> 00:04:52,490
行列式列存储压缩的技术，

116
00:04:52,490 --> 00:04:54,440
其中数据库系统本身

117
00:04:54,440 --> 00:04:55,670
负责运行压缩

118
00:04:55,670 --> 00:04:57,860
相册，然后它知道

119
00:04:57,860 --> 00:04:59,630
本机存储了此压缩数据，并且

120
00:04:59,630 --> 00:05:00,860
它们可以在它们之上操作查询

121
00:05:00,860 --> 00:05:02,450
，然后我们有时间在最后我们 将

122
00:05:02,450 --> 00:05:03,740
结束讨论

123
00:05:03,740 --> 00:05:05,450
我们在这里所做的关于压缩

124
00:05:05,450 --> 00:05:10,340
旧项目的一些研究好吧好吧所以我们没有讨论

125
00:05:10,340 --> 00:05:12,110
磁盘中的压缩，

126
00:05:12,110 --> 00:05:13,430
当我们谈论

127
00:05:13,430 --> 00:05:16,430
磁盘或任何数据库时，我们没有谈论磁盘中的压缩，但很

128
00:05:16,430 --> 00:05:18,200
明显 如果您假设您的

129
00:05:18,200 --> 00:05:19,400
数据库在磁盘上，并且您

130
00:05:19,400 --> 00:05:21,350
从磁盘获取大量页面到进程

131
00:05:21,350 --> 00:05:23,360
查询，那么

132
00:05:23,360 --> 00:05:24,650
在该环境中压缩将是毫无意义的，

133
00:05:24,650 --> 00:05:27,740
因为磁盘 i/o 如此昂贵 因此，当数据进入内存时，支付一些

134
00:05:27,740 --> 00:05:30,500
额外的 CPU 开销来压缩

135
00:05:30,500 --> 00:05:33,110
数据

136
00:05:33,110 --> 00:05:34,960
对我们来说将是一个很好的权衡，

137
00:05:34,960 --> 00:05:37,850
因为磁盘并没有

138
00:05:37,850 --> 00:05:40,640
变得那么快，

139
00:05:40,640 --> 00:05:44,030
但我们有更多内核可以做到这一点 Xu 有

140
00:05:44,030 --> 00:05:45,530
更多的计算能力可供我们使用，而

141
00:05:45,530 --> 00:05:47,630
不是我们

142
00:05:47,630 --> 00:05:50,390
从磁盘中获取数据的能力，但现在对于内存

143
00:05:50,390 --> 00:05:52,360
数据库来说，这种权衡并不是那么明显，

144
00:05:52,360 --> 00:05:54,530
因为现在一切都在

145
00:05:54,530 --> 00:05:58,669
内存中，我没有付钱 这么大的

146
00:05:58,669 --> 00:06:02,090
IO 损失，我还允许进行

147
00:06:02,090 --> 00:06:04,669
字节级访问以跳转到您知道

148
00:06:04,669 --> 00:06:06,020
不同的偏移量和我的通信或我的

149
00:06:06,020 --> 00:06:07,700
数据和访问单个实际上非常

150
00:06:07,700 --> 00:06:09,530
有效，而在基于磁盘的

151
00:06:09,530 --> 00:06:11,330
系统中我带来了 4 KB

152
00:06:11,330 --> 00:06:14,570
一次一个页面，所以我

153
00:06:14,570 --> 00:06:18,020
可以压缩的范围略有不同，所以

154
00:06:18,020 --> 00:06:18,830
对于它的

155
00:06:18,830 --> 00:06:20,150
数据库，我们将

156
00:06:20,150 --> 00:06:21,920
在速度和压缩率之间进行权衡

157
00:06:21,920 --> 00:06:24,770
，据我所知，在

158
00:06:24,770 --> 00:06:27,200
大多数情况下，来自正在运行的 mme

159
00:06:27,200 --> 00:06:29,600
数据库 支持com 按数据 他们

160
00:06:29,600 --> 00:06:31,100
会选择速度而不是压缩

161
00:06:31,100 --> 00:06:32,990
比 这意味着会有

162
00:06:32,990 --> 00:06:34,370
一些压缩算法

163
00:06:34,370 --> 00:06:37,340
会得到惊人的压缩比

164
00:06:37,340 --> 00:06:38,720
你可以把原始数据

165
00:06:38,720 --> 00:06:39,890
压缩成更小的

166
00:06:39,890 --> 00:06:41,900
尺寸 但它的计算

167
00:06:41,900 --> 00:06:44,210
成本非常高 所以 他们不会那样

168
00:06:44,210 --> 00:06:45,620
做 他们会选择一种

169
00:06:45,620 --> 00:06:47,630
压缩方案 压缩协议

170
00:06:47,630 --> 00:06:52,430
可能不会产生

171
00:06:52,430 --> 00:06:55,700
那么好的压缩率 但它

172
00:06:55,700 --> 00:06:56,900
可以运行得很快 是的

173
00:06:56,900 --> 00:06:58,730
很快 然后还有

174
00:06:58,730 --> 00:06:59,600
直 可怕的是你想要

175
00:06:59,600 --> 00:07:01,160
非常快地压缩或非常快地解压

176
00:07:01,160 --> 00:07:02,780
，在大多数情况下，我们会

177
00:07:02,780 --> 00:07:05,330
关心快速解压，所以我会

178
00:07:05,330 --> 00:07:07,690
因为大多数时候这是一个新的，

179
00:07:07,690 --> 00:07:11,110
所以我们为什么要做好这件事

180
00:07:11,110 --> 00:07:13,460
DRAM 不是 便宜我必须支付

181
00:07:13,460 --> 00:07:14,600
购买该硬件的费用，并且实际上支付了

182
00:07:14,600 --> 00:07:16,190
不断刷新它以保持该成本能量的费用，

183
00:07:16,190 --> 00:07:18,260
因此如果我可以将我的

184
00:07:18,260 --> 00:07:21,350
数据库存储在内存较少的较小机器上，

185
00:07:21,350 --> 00:07:24,020
那就是 对我们来说会是一个很好的胜利

186
00:07:24,020 --> 00:07:26,240
，在某些情况下，当我们

187
00:07:26,240 --> 00:07:27,290
压缩数据时，我们实际上也会

188
00:07:27,290 --> 00:07:28,880
获得更好的性能，因为

189
00:07:28,880 --> 00:07:30,350
现在事情能够适合我的 CPU 缓存，

190
00:07:30,350 --> 00:07:33,950
或者为了查看

191
00:07:33,950 --> 00:07:35,930
较小的部分 我们仍然可以

192
00:07:35,930 --> 00:07:38,960
计算出相同的查询结果 所以

193
00:07:38,960 --> 00:07:40,220
这几乎是双赢

194
00:07:40,220 --> 00:07:43,610
的所以为了理解为什么我们可以

195
00:07:43,610 --> 00:07:44,690
压缩数据 我们将开始

196
00:07:44,690 --> 00:07:46,160
了解真正的

197
00:07:46,160 --> 00:07:48,890
数据库实际上是什么样子的

198
00:07:48,890 --> 00:07:51,020
所以第一件事是，真实的数据

199
00:07:51,020 --> 00:07:53,270
集将非常偏右

200
00:07:53,270 --> 00:07:54,650
，这意味着就像

201
00:07:54,650 --> 00:07:56,750
给定列的值

202
00:07:56,750 --> 00:07:59,660
分布不会统一一样

203
00:07:59,660 --> 00:08:01,550
，以邮政编码为例，有

204
00:08:01,550 --> 00:08:03,140
更多的人住在 纽约市

205
00:08:03,140 --> 00:08:05,630
然后住在蒙大拿州，所以当我查看

206
00:08:05,630 --> 00:08:07,100
我是否有一份所有你认识的人的名单

207
00:08:07,100 --> 00:08:09,170
并且我正在存储他们的邮政编码时，

208
00:08:09,170 --> 00:08:10,820
住在纽约的人比住

209
00:08:10,820 --> 00:08:13,070
在蒙大拿州的人多得多，我可以利用

210
00:08:13,070 --> 00:08:15,410
这一点在我的 压缩压缩 n

211
00:08:15,410 --> 00:08:18,770
协议另一个很好的例子是

212
00:08:18,770 --> 00:08:22,130
还有棕色语料库，它展示了

213
00:08:22,130 --> 00:08:23,120
这种称为压缩

214
00:08:23,120 --> 00:08:25,190
分布的属性，所以棕色语料库

215
00:08:25,190 --> 00:08:28,280
是 1960 年代布朗

216
00:08:28,280 --> 00:08:31,520
大学的这个项目，他们基本上采用了

217
00:08:31,520 --> 00:08:32,630
他们认为是

218
00:08:32,630 --> 00:08:35,179
世界上最具象征意义的书籍

219
00:08:35,179 --> 00:08:37,340
英语语言，他们只是计算

220
00:08:37,340 --> 00:08:38,539
了这些书中的单词数量

221
00:08:38,539 --> 00:08:41,000
，我们建议让我们猜猜

222
00:08:41,000 --> 00:08:44,420
最常见的单词是什么，是的，

223
00:08:44,420 --> 00:08:46,730
没错，但是接下来会发生什么是穆斯坎语的

224
00:08:46,730 --> 00:08:49,550
下一个单词是单词 a 和

225
00:08:49,550 --> 00:08:52,880
the 单词 a 左右单词 the 出现

226
00:08:52,880 --> 00:08:55,520
次数是单词 a 的两倍，而 a

227
00:08:55,520 --> 00:08:57,320
出现次数是第三个

228
00:08:57,320 --> 00:08:58,610
单词的两倍等等，所以你有

229
00:08:58,610 --> 00:09:00,920
这种幂律曲线，所以很多实际

230
00:09:00,920 --> 00:09:02,330
工作量看起来像这样，

231
00:09:02,330 --> 00:09:03,650
这些是我们可以利用的东西

232
00:09:03,650 --> 00:09:04,820
哦，你认为你喜欢

233
00:09:04,820 --> 00:09:06,920
reddit 或黑客新闻 有

234
00:09:06,920 --> 00:09:08,630
少数文章实际上得到了

235
00:09:08,630 --> 00:09:10,550
很多评论 大多数人提交了废话

236
00:09:10,550 --> 00:09:14,930
，没有人看到 是对的，所以如果

237
00:09:14,930 --> 00:09:16,280
我们知道这一点，那么有很多

238
00:09:16,280 --> 00:09:17,990
事情你知道长尾的东西，我们

239
00:09:17,990 --> 00:09:19,160
可以用不同的

240
00:09:19,160 --> 00:09:23,210
方式压缩或获得良好的压缩率，

241
00:09:23,210 --> 00:09:24,740
在我们的数据集中另一件事也是

242
00:09:24,740 --> 00:09:25,960
将高度

243
00:09:25,960 --> 00:09:28,670
相关，这意味着

244
00:09:28,670 --> 00:09:30,560
同一元组中不同属性的值

245
00:09:30,560 --> 00:09:32,900
或通常会相互关联或

246
00:09:32,900 --> 00:09:35,390
相关，就像

247
00:09:35,390 --> 00:09:37,460
我地址的邮政编码可以

248
00:09:37,460 --> 00:09:40,310
与我的城市相关联，所以我知道

249
00:09:40,310 --> 00:09:42,020
城市名称和州 我知道我所在的邮政编码

250
00:09:42,020 --> 00:09:44,920
或者如果我在亚马逊上买

251
00:09:44,920 --> 00:09:47,450
东西 通常

252
00:09:47,450 --> 00:09:48,950
是发货日期或开始日期

253
00:09:48,950 --> 00:09:51,050
有人下订单的日期

254
00:09:51,050 --> 00:09:54,110
只有几天 这只是几天后

255
00:09:54,110 --> 00:09:55,370
实际上会发货，所以我

256
00:09:55,370 --> 00:09:56,240
今天买东西

257
00:09:56,240 --> 00:09:57,830
亚马逊发货并在同

258
00:09:57,830 --> 00:09:59,750
一天发货就像我今天买的东西

259
00:09:59,750 --> 00:10:01,250
明天会发货所以也许

260
00:10:01,250 --> 00:10:04,820
不是为订单日期和发货日期存储完整的 64 位日期

261
00:10:04,820 --> 00:10:06,860
和时间戳，

262
00:10:06,860 --> 00:10:09,020
如果 一世  只需存储这个，我

263
00:10:09,020 --> 00:10:11,090
现在也许可以存储 Delta 就像

264
00:10:11,090 --> 00:10:13,370
你知道几个小时之后，然后

265
00:10:13,370 --> 00:10:16,490
我可以说空间，所以这些是

266
00:10:16,490 --> 00:10:19,160
关于真实数据集这些方面的很多技术，这

267
00:10:19,160 --> 00:10:21,530
就是为什么我们

268
00:10:21,530 --> 00:10:23,900
能够 为了获得良好的压缩率并

269
00:10:23,900 --> 00:10:25,760
使用这些技术而不

270
00:10:25,760 --> 00:10:29,270
完全降低系统的速度，所以我们

271
00:10:29,270 --> 00:10:31,910
在压缩方案中最想要的

272
00:10:31,910 --> 00:10:34,670
是我们需要这些压缩

273
00:10:34,670 --> 00:10:36,320
方案来产生固定长度的值，

274
00:10:36,320 --> 00:10:38,510
因为再次记住我们有这个固定

275
00:10:38,510 --> 00:10:39,980
长度的数据池 这

276
00:10:39,980 --> 00:10:43,640
就是你知道

277
00:10:43,640 --> 00:10:46,230
的元组的主要主要位置，

278
00:10:46,230 --> 00:10:47,430
所以为了让我跳到

279
00:10:47,430 --> 00:10:49,410


280
00:10:49,410 --> 00:10:51,510
固定长度数据池中的不同偏移量，我所有的

281
00:10:51,510 --> 00:10:53,970
值都需要固定长度，所以如果 我

282
00:10:53,970 --> 00:10:56,100
开始压缩你

283
00:10:56,100 --> 00:10:58,139
从两个随机大小知道的字符串，这

284
00:10:58,139 --> 00:10:59,750
对我们不起作用，所以一切都必须是

285
00:10:59,750 --> 00:11:01,950
固定长度的数据，另一个

286
00:11:01,950 --> 00:11:03,449
例外是当我们把

287
00:11:03,449 --> 00:11:05,279
条形长度数据推出时 pool 因为那是

288
00:11:05,279 --> 00:11:08,459
在

289
00:11:08,459 --> 00:11:10,529
很长的 de poule 中记录数据的大小，所以它

290
00:11:10,529 --> 00:11:13,050
可以是可变大小的，但是大部分

291
00:11:13,050 --> 00:11:15,420
数据需要固定长度，

292
00:11:15,420 --> 00:11:18,360
我们希望能够做的另一件事是推迟数据

293
00:11:18,360 --> 00:11:21,720


294
00:11:21,720 --> 00:11:23,850


295
00:11:23,850 --> 00:11:27,089
在

296
00:11:27,089 --> 00:11:29,610
查询生命周期的生命周期中实际必须解压缩数据之前，尽可能长时间地测量一些权重，所以我的

297
00:11:29,610 --> 00:11:31,139
意思是如果我有一堆

298
00:11:31,139 --> 00:11:33,570
压缩数据，我想尝试执行我的

299
00:11:33,570 --> 00:11:35,639
查询 X 你 可能和我的查询一样多，我

300
00:11:35,639 --> 00:11:38,760
可以全部放入压缩数据中，

301
00:11:38,760 --> 00:11:40,500
直到我必须

302
00:11:40,500 --> 00:11:41,730
向人类或数据库 ISM 的外部世界生成结果，

303
00:11:41,730 --> 00:11:43,500
然后我继续

304
00:11:43,500 --> 00:11:46,139
解压缩它，这将是

305
00:11:46,139 --> 00:11:47,190
一个大问题 这就是所谓的后期

306
00:11:47,190 --> 00:11:48,930
实现，这就是为什么我们

307
00:11:48,930 --> 00:11:50,339
要

308
00:11:50,339 --> 00:11:52,079
在我们的数据库系统内部进行本地压缩，而

309
00:11:52,079 --> 00:11:53,459
不是查看通用的 Alvin

310
00:11:53,459 --> 00:11:54,990
我们所做的事情对

311
00:11:54,990 --> 00:11:57,720
实际存储的内容和

312
00:11:57,720 --> 00:12:00,089
最后一个内容一无所知 有点明显 同样，但

313
00:12:00,089 --> 00:12:01,230
我们应该提出它，

314
00:12:01,230 --> 00:12:02,490
因为有不同类型的

315
00:12:02,490 --> 00:12:03,449
压缩算法，我们

316
00:12:03,449 --> 00:12:05,519
确保我们只选择我们真正

317
00:12:05,519 --> 00:12:07,290
想要使用的算法，因此

318
00:12:07,290 --> 00:12:10,529
您想要使用的任何压缩方案都必须是无损的

319
00:12:10,529 --> 00:12:13,350
，这意味着什么？

320
00:12:13,350 --> 00:12:14,430
是的，你不太好，是的，你不会丢失

321
00:12:14,430 --> 00:12:16,529
数据，但就像我获取一些原始

322
00:12:16,529 --> 00:12:18,449
数据并压缩它然后

323
00:12:18,449 --> 00:12:19,920
解压缩它我应该能够

324
00:12:19,920 --> 00:12:21,000
取回原始

325
00:12:21,000 --> 00:12:22,740
数据保存的是一个有损压缩的球

326
00:12:22,740 --> 00:12:26,579
压缩算法和 b3

327
00:12:26,579 --> 00:12:27,360


328
00:12:27,360 --> 00:12:30,060
在我们的数据库中完全是这样，我们必须

329
00:12:30,060 --> 00:12:33,240
几乎总是无损的，因为

330
00:12:33,240 --> 00:12:35,339
当您丢失数据时人们不喜欢它，

331
00:12:35,339 --> 00:12:37,140
但是如果是您的银行帐户，您将

332
00:12:37,140 --> 00:12:38,699
100 美元存入，他们回来说不，您

333
00:12:38,699 --> 00:12:40,529
有 你有 80 美元你会

334
00:12:40,529 --> 00:12:42,750
生气所以

335
00:12:42,750 --> 00:12:46,019
我们想要使用的任何压缩方案都不能这样做，如果我们

336
00:12:46,019 --> 00:12:48,709
确实想做一个有损压缩方案，

337
00:12:48,709 --> 00:12:51,000
那么这必须在

338
00:12:51,000 --> 00:12:53,339
应用程序级别完成，这意味着某些人已经

339
00:12:53,339 --> 00:12:54,990
创造价值 判断

340
00:12:54,990 --> 00:12:56,579
我们的数据库中的数据丢失是可以的

341
00:12:56,579 --> 00:12:58,800
数据库系统 我们

342
00:12:58,800 --> 00:12:59,760
不会自己计算，

343
00:12:59,760 --> 00:13:02,050
因为最好的压缩方案

344
00:13:02,050 --> 00:13:03,400
是编写开发人员知道的

345
00:13:03,400 --> 00:13:05,800
所有内容并丢失所有内容 它会有一个

346
00:13:05,800 --> 00:13:07,060
惊人的压缩率 这将是

347
00:13:07,060 --> 00:13:08,590
真的 很快，但当然你没有

348
00:13:08,590 --> 00:13:10,630
任何数据，所以在那种极端的

349
00:13:10,630 --> 00:13:12,520
例子中，但这是基本思想，

350
00:13:12,520 --> 00:13:13,750
数据茎不知道你真正

351
00:13:13,750 --> 00:13:16,600
关心的是什么，所以它不会做任何

352
00:13:16,600 --> 00:13:21,370
会丢失的事情，我们不会去

353
00:13:21,370 --> 00:13:22,780
谈论这个，但有一些

354
00:13:22,780 --> 00:13:24,400
技术称之为近似查询

355
00:13:24,400 --> 00:13:26,340
，看起来像有损压缩，

356
00:13:26,340 --> 00:13:31,390
所以如果我有一列人

357
00:13:31,390 --> 00:13:33,310
访问我的网站，我想计算

358
00:13:33,310 --> 00:13:35,920


359
00:13:35,920 --> 00:13:38,980
上个月访问该网站的人数我 你能知道

360
00:13:38,980 --> 00:13:40,720
查看每一个元组并可以

361
00:13:40,720 --> 00:13:43,060
将所有这些相加并计算它，或者我

362
00:13:43,060 --> 00:13:45,340
可以对其进行采样，或者只是你知道

363
00:13:45,340 --> 00:13:47,050
跳过其中的一部分，然后尝试

364
00:13:47,050 --> 00:13:50,110
近似该计数和 id

365
00:13:50,110 --> 00:13:52,300
ea 就像你知道谁在乎我

366
00:13:52,300 --> 00:13:53,800
是否有一个你知道我有 100 万用户访问

367
00:13:53,800 --> 00:13:55,810
我的网站 但是然后我的近似计数

368
00:13:55,810 --> 00:13:58,060
回来了你知道 980000

369
00:13:58,060 --> 00:13:59,560
或类似的数字就像它足够接近

370
00:13:59,560 --> 00:14:02,290
所以我们不会再 像这样，

371
00:14:02,290 --> 00:14:03,430
但这些被称为近似查询

372
00:14:03,430 --> 00:14:05,670
这实际上现在出现

373
00:14:05,670 --> 00:14:08,320
在他们今天将支持的商业系统中，

374
00:14:08,320 --> 00:14:09,880


375
00:14:09,880 --> 00:14:11,490
就像显式的习惯一样，例如

376
00:14:11,490 --> 00:14:13,990


377
00:14:13,990 --> 00:14:16,150
Oracle 和续集服务器中的近似计数操作或聚合聚合函数，

378
00:14:16,150 --> 00:14:18,220
我认为 TB 2 可能有 所以我们

379
00:14:18,220 --> 00:14:20,080
不打算讨论这个，但是，好吧，

380
00:14:20,080 --> 00:14:20,860
这是下一张幻灯片，

381
00:14:20,860 --> 00:14:25,330
抱歉，这是我的意思，所以这种技术

382
00:14:25,330 --> 00:14:28,570
确实存在，然后续集

383
00:14:28,570 --> 00:14:29,980
服务器我认为刚刚

384
00:14:29,980 --> 00:14:31,720
在去年再次添加了这个想法是你

385
00:14:31,720 --> 00:14:33,190
只是对数据进行采样并产生

386
00:14:33,190 --> 00:14:36,160
计数相当隔离 另一种

387
00:14:36,160 --> 00:14:38,710
类型的技术是做区域地图，

388
00:14:38,710 --> 00:14:40,780
所以我将这两个人归类

389
00:14:40,780 --> 00:14:42,580
为数据跳过意味着我们

390
00:14:42,580 --> 00:14:44,860
试图避免查看 在

391
00:14:44,860 --> 00:14:46,540
一堆数据中 我们

392
00:14:46,540 --> 00:14:47,620
今天要讨论的压缩方案 我们停下来

393
00:14:47,620 --> 00:14:49,270
查看所有内容 但我们

394
00:14:49,270 --> 00:14:50,770
正在查看的内容是压缩的

395
00:14:50,770 --> 00:14:52,240


396
00:14:52,240 --> 00:14:54,850


397
00:14:54,850 --> 00:14:56,080
认为我们在

398
00:14:56,080 --> 00:14:57,700
介绍类中介绍了它并不是真正的

399
00:14:57,700 --> 00:14:59,140
压缩方案，它只是一种

400
00:14:59,140 --> 00:15:01,450
用于跳过数据的技术 想法

401
00:15:01,450 --> 00:15:03,310
是您预先计算一些

402
00:15:03,310 --> 00:15:05,710
列上的聚合，然后当

403
00:15:05,710 --> 00:15:07,300
您开始执行查询时，您可以

404
00:15:07,300 --> 00:15:08,950
查看那些预先计算的聚合

405
00:15:08,950 --> 00:15:10,510
并决定是否有任何

406
00:15:10,510 --> 00:15:12,070
您想要查看的内容并提供

407
00:15:12,070 --> 00:15:15,519
Wacka 数据，

408
00:15:15,519 --> 00:15:17,829
因此它们被 Oracle 称为

409
00:15:17,829 --> 00:15:20,380


410
00:15:20,380 --> 00:15:22,060


411
00:15:22,060 --> 00:15:24,220
区域图 映射，

412
00:15:24,220 --> 00:15:25,300
即使你不是在谈论 Oracle

413
00:15:25,300 --> 00:15:26,380
系统，人们知道你在谈论什么

414
00:15:26,380 --> 00:15:28,180
，你谈论过这件事吗，

415
00:15:28,180 --> 00:15:29,740
假设我在这里有一列，它有

416
00:15:29,740 --> 00:15:32,649
五个值，所以我可以计算 区域

417
00:15:32,649 --> 00:15:34,630
地图的 e，我将在其中拥有

418
00:15:34,630 --> 00:15:36,880
我可能想要运行的所有聚合函数

419
00:15:36,880 --> 00:15:39,430
，为此列计算它，因此主要的

420
00:15:39,430 --> 00:15:42,339
最大平均总和和计数，然后现在

421
00:15:42,339 --> 00:15:44,079
如果查询出现，例如

422
00:15:44,079 --> 00:15:45,810
从表中选择星，其中值大于 600

423
00:15:45,810 --> 00:15:48,160
而不是扫描列

424
00:15:48,160 --> 00:15:50,019
假设这是一个数据块，

425
00:15:50,019 --> 00:15:51,970
说必须扫描它并

426
00:15:51,970 --> 00:15:53,680
找到值

427
00:15:53,680 --> 00:15:56,170
大于 600 我可以使用的所有记录，而不是

428
00:15:56,170 --> 00:15:59,440
查看我的最大值的区域地图并

429
00:15:59,440 --> 00:16:01,540
查看它 这个块的 VAX 值是

430
00:16:01,540 --> 00:16:03,790
400，所以我

431
00:16:03,790 --> 00:16:06,670
知道这里不可能有任何

432
00:16:06,670 --> 00:16:08,800
600 或更大的元组，所以我什至不费心

433
00:16:08,800 --> 00:16:10,360
看这个，我只是看看区域

434
00:16:10,360 --> 00:16:11,920
地图，看到那个东西没有' 不满足我的

435
00:16:11,920 --> 00:16:18,420
谓词，我可以忽略这一点，所以是的，

436
00:16:21,449 --> 00:16:23,740
所以这个问题是，如果您正在运行

437
00:16:23,740 --> 00:16:27,660
BTC，那么您何时会更新区域地图，

438
00:16:27,660 --> 00:16:30,760
所以对于这个和压缩的

439
00:16:30,760 --> 00:16:32,769
东西，今天您通常

440
00:16:32,769 --> 00:16:34,660
只对冷数据执行此操作，而不是

441
00:16:34,660 --> 00:16:36,430
一直被修改所以你

442
00:16:36,430 --> 00:16:38,500
让它不压缩不计算

443
00:16:38,500 --> 00:16:40,690
区域地图，只有当你认识到它

444
00:16:40,690 --> 00:16:41,769
知道我们什么时候来更新这个

445
00:16:41,769 --> 00:16:43,240
块一段时间让我继续

446
00:16:43,240 --> 00:16:47,980
计算这些东西就像我

447
00:16:47,980 --> 00:16:50,139
说的那样这只会出现在

448
00:16:50,139 --> 00:16:53,139
更高的位置 - 回到

449
00:16:53,139 --> 00:16:56,230
这里的终端商业系统 Oracle 有这个 Vertica mem 续集

450
00:16:56,230 --> 00:16:59,079
mateesah 是一个 fpga 加速数据库

451
00:16:59,079 --> 00:17:00,760
，IBM paulette 他们在

452
00:17:00,760 --> 00:17:03,370
去年杀死了他们，但我认为

453
00:17:03,370 --> 00:17:04,869
缩放地图最初起源于

454
00:17:04,869 --> 00:17:05,919
这些人，然后其他人都

455
00:17:05,919 --> 00:17:08,079
采用了相同的想法，但是 只有 Oracle

456
00:17:08,079 --> 00:17:09,970
将它们称为区域映射，因为

457
00:17:09,970 --> 00:17:11,619
那是 Oracle 术语，其他所有人都会

458
00:17:11,619 --> 00:17:13,209
导致计算机前聚合或

459
00:17:13,209 --> 00:17:16,619
其他事情，或者好吧

460
00:17:16,619 --> 00:17:18,699
好吧好吧让我们专注于

461
00:17:18,699 --> 00:17:20,020
压缩的东西，这是

462
00:17:20,020 --> 00:17:22,150
我们不会谈论的主要内容 大约在今天，所以

463
00:17:22,150 --> 00:17:24,309
如果你想向我们的数据库系统添加压缩，

464
00:17:24,309 --> 00:17:25,440


465
00:17:25,440 --> 00:17:26,490
我们必须考虑的第一个

466
00:17:26,490 --> 00:17:28,890
问题，从某种意义上说，实际上

467
00:17:28,890 --> 00:17:31,080
构建系统的奇怪问题正是我们

468
00:17:31,080 --> 00:17:33,780
想要解决的问题 压缩并基于该

469
00:17:33,780 --> 00:17:36,390
决定会告诉我们

470
00:17:36,390 --> 00:17:38,510
我们可能会采用哪种压缩方案，

471
00:17:38,510 --> 00:17:41,940
因此第一种方法是在

472
00:17:41,940 --> 00:17:44,070
块上执行它可能是一个

473
00:17:44,070 --> 00:17:46,140
列块，也可能是一个行存储它

474
00:17:46,140 --> 00:17:47,190
没有 很重要，但它是

475
00:17:47,190 --> 00:17:49,530
同一个表中的两个浮点数的块

476
00:17:49,530 --> 00:17:51,060
，

477
00:17:51,060 --> 00:17:52,380
您甚至可以做得比另一个元组级别更细粒度，因此

478
00:17:52,380 --> 00:17:54,420
在单个元组中，您

479
00:17:54,420 --> 00:17:57,270
可以更细粒度地压缩所有值，因为您

480
00:17:57,270 --> 00:18:00,180
只有一个属性 在一个元组中

481
00:18:00,180 --> 00:18:02,670
，你想压缩它，

482
00:18:02,670 --> 00:18:03,990
这听起来很疯狂，但如果你有一个

483
00:18:03,990 --> 00:18:05,580
大文本字段，这可能

484
00:18:05,580 --> 00:18:07,380
像维基百科那样有意义，所有这些

485
00:18:07,380 --> 00:18:10,050
文章都是

486
00:18:10,050 --> 00:18:12,330
维基百科文章的每个修订版都是元组中它自己的准确

487
00:18:12,330 --> 00:18:14,880
值 并且你想

488
00:18:14,880 --> 00:18:17,490
压缩它，或者我们可以

489
00:18:17,490 --> 00:18:19,470
在整个列上压缩它，所以我们在

490
00:18:19,470 --> 00:18:21,450


491
00:18:21,450 --> 00:18:22,950
多个元组和表中获取单个属性的所有值，然后

492
00:18:22,950 --> 00:18:24,720
我们将继续压缩这个，

493
00:18:24,720 --> 00:18:26,940
这个主要我们只想要 t  o

494
00:18:26,940 --> 00:18:31,950
如果它是一个专栏故事，请这样做，因此大多数系统，

495
00:18:31,950 --> 00:18:34,020
大多数 OLAP 系统都将这样做，

496
00:18:34,020 --> 00:18:36,420
而任何其他进行

497
00:18:36,420 --> 00:18:38,370
压缩的系统可能

498
00:18:38,370 --> 00:18:39,810
就像对我的 Segal 进行天真的压缩一样，我们将

499
00:18:39,810 --> 00:18:41,570
在更多幻灯片中看到他们' 我会这样做

500
00:18:41,570 --> 00:18:44,100
有一些系统可以支持

501
00:18:44,100 --> 00:18:45,650
这一点，例如续集服务器可以做到这一点

502
00:18:45,650 --> 00:18:48,030


503
00:18:48,030 --> 00:18:50,070
在中国有一种叫做 Terra 的摇滚 DVD 变体，他们可以这样做

504
00:18:50,070 --> 00:18:52,470


505
00:18:52,470 --> 00:18:54,720
如果我有一个大的 blob 大文本

506
00:18:54,720 --> 00:18:56,760
字段，那么这只会出现在可变长度的字段中 我可以压缩它，但同样

507
00:18:56,760 --> 00:18:58,020
，您

508
00:18:58,020 --> 00:19:00,150
要用于所有这些的压缩方案会有

509
00:19:00,150 --> 00:19:02,580
很大不同，但为此我可以进行简单的

510
00:19:02,580 --> 00:19:04,470
压缩，例如 gzip 或 snappy，

511
00:19:04,470 --> 00:19:06,660
但对于这一点，我们将使用

512
00:19:06,660 --> 00:19:07,530
字典编码或 其他

513
00:19:07,530 --> 00:19:11,100
技术好吧，让我们

514
00:19:11,100 --> 00:19:13,080
首先关注朴素压缩，因为

515
00:19:13,080 --> 00:19:15,540
这就像如果你来自

516
00:19:15,540 --> 00:19:16,800
你知道你是否

517
00:19:16,800 --> 00:19:19,200
对压缩有一些粗略的了解，而

518
00:19:19,200 --> 00:19:20,250
我在说哦，我们要压缩数据

519
00:19:20,250 --> 00:19:21,510
这可能是 你想到的第一件事

520
00:19:21,510 --> 00:19:23,970
所以这里使用天真的压缩的想法

521
00:19:23,970 --> 00:19:26,040
是我们将采用

522
00:19:26,040 --> 00:19:27,090
现成的通用

523
00:19:27,090 --> 00:19:28,740
压缩算法，我们的人

524
00:19:28,740 --> 00:19:30,930
已经使用了我们

525
00:19:30,930 --> 00:19:33,030
数据库中的其他东西，我们将采用

526
00:19:33,030 --> 00:19:35,940
我们尝试压缩的任何数据中的字节序列

527
00:19:35,940 --> 00:19:37,770
是否是

528
00:19:37,770 --> 00:19:38,880
元组，无论这个东西将

529
00:19:38,880 --> 00:19:39,030


530
00:19:39,030 --> 00:19:41,520
添加它的列还是块，我们将

531
00:19:41,520 --> 00:19:42,900
通过这些算法运行它，

532
00:19:42,900 --> 00:19:45,600
它们将产生一个但希望是一个

533
00:19:45,600 --> 00:19:47,670
数据块比我给它的要小

534
00:19:47,670 --> 00:19:52,200
，所以

535
00:19:52,200 --> 00:19:54,540
人们想要使用那种假名算法

536
00:19:54,540 --> 00:19:56,310
我说 gzip 但这通常不是

537
00:19:56,310 --> 00:19:57,570
你想要使用的，因为 gzip 是

538
00:19:57,570 --> 00:19:58,920
重量级压缩算法的一个例子

539
00:19:58,920 --> 00:20:01,080
，它会得到 比这些其他的更好的

540
00:20:01,080 --> 00:20:02,730
压缩压缩比

541
00:20:02,730 --> 00:20:04,350
，但它会

542
00:20:04,350 --> 00:20:07,350
像 L 0 或 LZ 4 那样做的更慢，这些是

543
00:20:07,350 --> 00:20:08,910
人们开发的第一批协议中的一些，

544
00:20:08,910 --> 00:20:11,730
你不知道

545
00:20:11,730 --> 00:20:12,660
这是一个很好的压缩 按比例，但

546
00:20:12,660 --> 00:20:14,370
它们快得多

547
00:20:14,370 --> 00:20:16,620
snappy 来自 Google 这是另一个

548
00:20:16,620 --> 00:20:17,540
在数据库系统中非常常见的系统，

549
00:20:17,540 --> 00:20:20,160
广泛来自 Facebook 这通常不

550
00:20:20,160 --> 00:20:22,290
使用数据库，因为这

551
00:20:22,290 --> 00:20:24,840
是为压缩网页而设计的，

552
00:20:24,840 --> 00:20:26,610
或者有一些

553
00:20:26,610 --> 00:20:27,750
在这里有一些魔法，你知道 如果你

554
00:20:27,750 --> 00:20:29,550
有很多 HTML 标签并且你一遍

555
00:20:29,550 --> 00:20:31,410
又一遍地看到它们可以使

556
00:20:31,410 --> 00:20:33,390
它们更好地压缩 Oracle 有

557
00:20:33,390 --> 00:20:34,830
一个叫做 zip 的东西，它是他们自己的

558
00:20:34,830 --> 00:20:36,450
专利压缩

559
00:20:36,450 --> 00:20:39,060
算法，你知道它是这些的

560
00:20:39,060 --> 00:20:42,600
变体，比如

561
00:20:42,600 --> 00:20:44,100
基于字典的 LZ 压缩方案，但

562
00:20:44,100 --> 00:20:46,950
它的迷人之处 Oracle 购买了 Sun

563
00:20:46,950 --> 00:20:49,050
一些制造火花芯片，所以有一段

564
00:20:49,050 --> 00:20:51,090
时间我不认为我认为他们

565
00:20:51,090 --> 00:20:52,950
停止了火花我忘记了但有一段

566
00:20:52,950 --> 00:20:55,260
时间他们实际上

567
00:20:55,260 --> 00:20:57,180
将 zip 解压缩和压缩

568
00:20:57,180 --> 00:20:59,370
算法存储在硬件上 是的，因此您

569
00:20:59,370 --> 00:21:01,110
实际上可以在加速时执行此操作，

570
00:21:01,110 --> 00:21:03,480
但是如果您购买了火花芯片并

571
00:21:03,480 --> 00:21:05,550
在其上运行 Oracle Z 标准是

572
00:21:05,550 --> 00:21:06,720
考虑 已

573
00:21:06,720 --> 00:21:09,540
成为当今最先进的一种，它为

574
00:21:09,540 --> 00:21:12,900
您提供与 snappy 相同的速度，但具有

575
00:21:12,900 --> 00:21:15,690
更好的压缩率，因此

576
00:21:15,690 --> 00:21:17,100
很多时候您会看到 snappy 但较新的

577
00:21:17,100 --> 00:21:19,250
系统开始采用 Z 标准

578
00:21:19,250 --> 00:21:21,450
所以我们已经再次讨论过这个

579
00:21:21,450 --> 00:21:23,090
问题，

580
00:21:23,090 --> 00:21:25,050
压缩数据和解压缩数据会产生计算开销

581
00:21:25,050 --> 00:21:28,110
，所以我们需要注意这一点，

582
00:21:28,110 --> 00:21:29,190
我们总是会尝试选择

583
00:21:29,190 --> 00:21:31,310
一些东西比 D kress 更快，

584
00:21:31,310 --> 00:21:33,270
即使它是教学大纲 佛罗里达州要

585
00:21:33,270 --> 00:21:34,590
压缩，因为大部分时间我

586
00:21:34,590 --> 00:21:38,850
只是要做减压，所以让我们

587
00:21:38,850 --> 00:21:40,320
看看我的秘密是如何做到这一点的，这是我

588
00:21:40,320 --> 00:21:43,350
在数据库中的续集，所以你可以做什么，以及

589
00:21:43,350 --> 00:21:44,490
当你调用 create table 时你可以做饭时的续集，

590
00:21:44,490 --> 00:21:46,380
你可以 传入一个标志并

591
00:21:46,380 --> 00:21:48,540
说我想存储它，因为我想将它

592
00:21:48,540 --> 00:21:50,580
存储为压缩块

593
00:21:50,580 --> 00:21:53,700
，所以接下来会发生什么

594
00:21:53,700 --> 00:21:55,260
我的续集不是内存

595
00:21:55,260 --> 00:21:56,550
系统所以这是一个磁盘系统但我

596
00:21:56,550 --> 00:21:58,050
只是告诉你 这意味着

597
00:21:58,050 --> 00:21:59,580
什么，这是明确的 rs 解释我

598
00:21:59,580 --> 00:22:02,880
发现你是如何进行原始压缩的，所以

599
00:22:02,880 --> 00:22:04,680
他们将在磁盘上

600
00:22:04,680 --> 00:22:05,820
拥有这些压缩

601
00:22:05,820 --> 00:22:08,430
块，这些块将具有四种

602
00:22:08,430 --> 00:22:10,770
不同的大小，所有功率都是二

603
00:22:10,770 --> 00:22:12,960
一二四八千字节，这里的想法

604
00:22:12,960 --> 00:22:14,370
是什么时候 你有一个未压缩的

605
00:22:14,370 --> 00:22:16,830
块，然后你把它压缩

606
00:22:16,830 --> 00:22:19,020
到

607
00:22:19,020 --> 00:22:20,790
下一个边界，你把它拍出来，

608
00:22:20,790 --> 00:22:23,790
所以如果我有一个五千字节的块，

609
00:22:23,790 --> 00:22:26,010
我会把它拍出来，所以它是

610
00:22:26,010 --> 00:22:27,630
两千字节， 他们这样做或者

611
00:22:27,630 --> 00:22:29,850
他们可以打包东西并

612
00:22:29,850 --> 00:22:32,250
在磁盘上很好地对齐它们，这样你就会

613
00:22:32,250 --> 00:22:34,020
有压缩页面，但你

614
00:22:34,020 --> 00:22:35,730
也会有这个位于它前面的未压缩的mod日志

615
00:22:35,730 --> 00:22:37,440
，想想

616
00:22:37,440 --> 00:22:39,420
这就像 一个增量存储，表示

617
00:22:39,420 --> 00:22:41,070
我对在这个块中表示的元组所做的更改，所以

618
00:22:41,070 --> 00:22:44,010


619
00:22:44,010 --> 00:22:45,600
现在如果我有一个查询出现并

620
00:22:45,600 --> 00:22:49,200
想要访问一些数据，那么

621
00:22:49,200 --> 00:22:50,490
我将它带到我的缓冲池并保持

622
00:22:50,490 --> 00:22:53,400
未压缩，如果 查询是一个

623
00:22:53,400 --> 00:22:56,370
u  pdate 那么所有需要做的就是

624
00:22:56,370 --> 00:22:59,280
修改 mod 日志中的内容，这样我就可以

625
00:22:59,280 --> 00:23:00,990
对 Penda 条目进行排序，说我

626
00:23:00,990 --> 00:23:03,060
对这里的某些内容进行了更改到这里

627
00:23:03,060 --> 00:23:04,830
我知道您喜欢的数据，因此您必须在

628
00:23:04,830 --> 00:23:07,020
上面有一个索引 说哦，我在

629
00:23:07,020 --> 00:23:08,970
这里是包含您正在寻找的元组的页面，

630
00:23:08,970 --> 00:23:10,680
所以假设我

631
00:23:10,680 --> 00:23:12,660
做了一个设置值，您知道更新到两个

632
00:23:12,660 --> 00:23:15,210
设置值等于 ABC 然后他们

633
00:23:15,210 --> 00:23:16,410
不需要查看原始值

634
00:23:16,410 --> 00:23:19,140
我是否只需要放置我的模组日志并

635
00:23:19,140 --> 00:23:20,580
说这个属性的新值

636
00:23:20,580 --> 00:23:23,100
现在是 ABC，所以如果有人来

637
00:23:23,100 --> 00:23:25,350
尝试阅读您检查模组日志，

638
00:23:25,350 --> 00:23:26,790
就像您选择我时在 BW 树中所做的那样

639
00:23:26,790 --> 00:23:28,590
去 原始链，

640
00:23:28,590 --> 00:23:30,240
你说哦，这是

641
00:23:30,240 --> 00:23:31,980
这个特定元组的最新值，这就是

642
00:23:31,980 --> 00:23:34,170
我正在寻找的，但如果你

643
00:23:34,170 --> 00:23:36,270
想要的东西不在 mod 日志中，那么你得到

644
00:23:36,270 --> 00:23:38,640
了减压，所以他们

645
00:23:38,640 --> 00:23:40,200
实际上做的是当他们 解压缩

646
00:23:40,200 --> 00:23:42,240
它们都将压缩

647
00:23:42,240 --> 00:23:44,190
版本和解压缩版本保存在

648
00:23:44,190 --> 00:23:47,220
内存中 或者解压后的版本

649
00:23:47,220 --> 00:23:50,130
总是 16 KB，

650
00:23:50,130 --> 00:23:51,750
因为他们这样做是为了

651
00:23:51,750 --> 00:23:53,160
再次对齐缓冲池中的内容，所以他们会让

652
00:23:53,160 --> 00:23:55,020
我们知道我有 4 个 16

653
00:23:55,020 --> 00:23:56,760
KB 的页面，然后是所有

654
00:23:56,760 --> 00:23:58,470
不同的压缩页面 大小它们

655
00:23:58,470 --> 00:24:00,320
有一个特定的单独区域，

656
00:24:00,320 --> 00:24:03,960
所以现在如果我进行任何更改并且如果我修改此页面我

657
00:24:03,960 --> 00:24:06,450
想将它们写回

658
00:24:06,450 --> 00:24:08,580
那么我必须

659
00:24:08,580 --> 00:24:11,460
在读取之前替换这个东西

660
00:24:11,460 --> 00:24:12,900
否则如果我不修改 然后我

661
00:24:12,900 --> 00:24:14,700
可以把这个东西吹走，然后如果

662
00:24:14,700 --> 00:24:16,020
我修改了这个东西，我可以吹掉它

663
00:24:16,020 --> 00:24:17,250
，因为它没有

664
00:24:17,250 --> 00:24:29,340
从缓冲池中支付，所以是的，这些

665
00:24:29,340 --> 00:24:30,780
问题可以添加到除此之外的暴民

666
00:24:30,780 --> 00:24:32,940
日志中，就像这样 是一个固定的

667
00:24:32,940 --> 00:24:34,890
大小 我要固定大小 所以你

668
00:24:34,890 --> 00:24:36,630
在这里的空间用完了 然后你必须

669
00:24:36,630 --> 00:24:38,910
解压它 然后你知道

670
00:24:38,910 --> 00:24:40,310
压缩器代码 我应用了所有的变化

671
00:24:40,310 --> 00:24:44,940
是的，它就像珠子的 Delta 商店

672
00:24:44,940 --> 00:24:46,500
部分一样 我们拥有的树是

673
00:24:46,500 --> 00:24:49,380
一个固定的数字是的 oka 所以

674
00:24:49,380 --> 00:24:50,490
我想指出的主要事情是

675
00:24:50,490 --> 00:24:55,320
，正如我所说，如果我需要访问

676
00:24:55,320 --> 00:24:58,470
压缩数据中的某些内容，

677
00:24:58,470 --> 00:25:03,240
我必须解压缩它，因为再次

678
00:25:03,240 --> 00:25:06,030
假设我通过 snappy 或 gzip

679
00:25:06,030 --> 00:25:07,260
或任何你想要的任何专辑运行它

680
00:25:07,260 --> 00:25:09,030
你想使用数据库不

681
00:25:09,030 --> 00:25:10,290
知道封面下页面的那些字节里面有什么

682
00:25:10,290 --> 00:25:13,710


683
00:25:13,710 --> 00:25:15,420
这些算法实际上

684
00:25:15,420 --> 00:25:17,730
经常使用字典压缩

685
00:25:17,730 --> 00:25:20,070
但你不知道你在数据库系统中看不到，

686
00:25:20,070 --> 00:25:21,390
除非你知道 如何

687
00:25:21,390 --> 00:25:24,570
解释这些不同算法的压缩格式，

688
00:25:24,570 --> 00:25:27,150
但我

689
00:25:27,150 --> 00:25:29,640
认为实际上没有任何系统这样做，

690
00:25:29,640 --> 00:25:31,710
所以现在这意味着这将限制

691
00:25:31,710 --> 00:25:33,000
我们实际可以压缩的范围，

692
00:25:33,000 --> 00:25:35,700
因为如果我尝试压缩

693
00:25:35,700 --> 00:25:37,980
整个列并且我 需要

694
00:25:37,980 --> 00:25:40,350
在该列中获得一个元组，现在我必须正确地

695
00:25:40,350 --> 00:25:46,050
解压缩整个内容，因此

696
00:25:46,050 --> 00:25:47,900
主要的收获是因为

697
00:25:47,900 --> 00:25:50,370
我们使用的是 IE 压缩方案

698
00:25:50,370 --> 00:25:51,390
，它不知道 w 正在发生的

699
00:25:51,390 --> 00:25:53,610
事情我们正在失去

700
00:25:53,610 --> 00:25:54,840


701
00:25:54,840 --> 00:25:56,400
对我们正在压缩的内容中

702
00:25:56,400 --> 00:25:58,140
的内容以及该数据的语义是什么的所有高级理解，因此我们不能

703
00:25:58,140 --> 00:26:00,990
做任何事情我们不能做任何事情，

704
00:26:00,990 --> 00:26:02,580
除了只是 每次都对其进行解压缩，

705
00:26:02,580 --> 00:26:05,310
所以现在我们

706
00:26:05,310 --> 00:26:06,510
将讨论这些更好的

707
00:26:06,510 --> 00:26:08,760
压缩方案，其中数据

708
00:26:08,760 --> 00:26:10,170
系统本身会再次执行此操作，因为

709
00:26:10,170 --> 00:26:11,400
它会知道如何

710
00:26:11,400 --> 00:26:14,310
压缩它压缩的内容，然后

711
00:26:14,310 --> 00:26:16,530
在某些情况下当它看到时 查询它

712
00:26:16,530 --> 00:26:18,000
可能只是压缩

713
00:26:18,000 --> 00:26:19,140
查询看起来像的东西看起来

714
00:26:19,140 --> 00:26:20,400
他们试图查找

715
00:26:20,400 --> 00:26:22,050
实际上查询的谓词

716
00:26:22,050 --> 00:26:23,970
并对其进行匹配并且您

717
00:26:23,970 --> 00:26:26,280
永远不必解压缩

718
00:26:26,280 --> 00:26:29,309
原始数据以倒出原始数据 他们说

719
00:26:29,309 --> 00:26:31,890
这是我的用户表，我有

720
00:26:31,890 --> 00:26:33,030
他们的薪水，我只有两个元组

721
00:26:33,030 --> 00:26:34,710
Andy 和 Matt，我们有我们的假

722
00:26:34,710 --> 00:26:38,220
薪水，所以如果我压缩它，我不是

723
00:26:38,220 --> 00:26:39,809
说我如何压缩这个假设我

724
00:26:39,809 --> 00:26:43,710
可以并且为每个 罪 我的

725
00:26:43,710 --> 00:26:45,809
表中的 gle 值我可能会用

726
00:26:45,809 --> 00:26:47,190
比

727
00:26:47,190 --> 00:26:50,100
原始大小小的东西来压缩它，所以现在如果我

728
00:26:50,100 --> 00:26:51,720
想说找到所有用户都被命名为

729
00:26:51,720 --> 00:26:54,630
等于 Andy 你知道不要假设我

730
00:26:54,630 --> 00:26:56,940
有一个索引假设我 '我要好好做一个

731
00:26:56,940 --> 00:26:59,730
中央扫描为了让我做

732
00:26:59,730 --> 00:27:01,580
那个匹配我必须解压缩这个

733
00:27:01,580 --> 00:27:03,890
但是如果我实际上只是

734
00:27:03,890 --> 00:27:05,910
对我正在查找的东西编码了

735
00:27:05,910 --> 00:27:07,980
一个相同的压缩算法现在我

736
00:27:07,980 --> 00:27:11,030
直接做我的匹配怎么办 压缩数据没问题

737
00:27:11,030 --> 00:27:13,290
这就是为什么我们

738
00:27:13,290 --> 00:27:14,580
希望数据系统自己完成所有

739
00:27:14,580 --> 00:27:15,600
压缩工作 我们现在

740
00:27:15,600 --> 00:27:18,360
不想依赖外部算法

741
00:27:18,360 --> 00:27:19,650
来获取范围谓词 这将

742
00:27:19,650 --> 00:27:22,350
更加棘手 找到所有

743
00:27:22,350 --> 00:27:24,870
名称大于 Andy 的用户 这是你知道的，

744
00:27:24,870 --> 00:27:26,160
这取决于我们如何压缩它，它可能

745
00:27:26,160 --> 00:27:27,690
不起作用，但我们将看到如何

746
00:27:27,690 --> 00:27:31,559
在字典编码器中处理它，好吧，

747
00:27:31,559 --> 00:27:33,870
所以我们今天要讨论七种

748
00:27:33,870 --> 00:27:35,880
不同的问题方案，

749
00:27:35,880 --> 00:27:38,370
这将再次用于柱状

750
00:27:38,370 --> 00:27:40,950
压缩 在 ole ETP 系统中，

751
00:27:40,950 --> 00:27:43,020
当数据在内存中时，您通常不会压缩数据，

752
00:27:43,020 --> 00:27:45,420
因为正如我所说，

753
00:27:45,420 --> 00:27:47,910


754
00:27:47,910 --> 00:27:49,320
在我开始进行更改时不再进行解压缩和重新压缩会太昂贵，

755
00:27:49,320 --> 00:27:53,070
因此这仅适用

756
00:27:53,070 --> 00:27:55,500
于不会修改的冷数据

757
00:27:55,500 --> 00:27:56,880
我们已经知道我们可以将它存储

758
00:27:56,880 --> 00:27:59,850
为列存储，所以我们有点像

759
00:27:59,850 --> 00:28:02,250
空抑制运行解码和位图

760
00:28:02,250 --> 00:28:04,050
编码进行编码，所有这些其他

761
00:28:04,050 --> 00:28:05,880
的都再次出现

762
00:28:05,880 --> 00:28:06,990
在你们阅读的论文中，但这些

763
00:28:06,990 --> 00:28:07,980
是 我认为还有很多其他事情

764
00:28:07,980 --> 00:28:09,780
很有趣，但字典

765
00:28:09,780 --> 00:28:11,309
编码将是最常见的编码，

766
00:28:11,309 --> 00:28:13,140
但它并不总是

767
00:28:13,140 --> 00:28:14,640
最好的，在某些

768
00:28:14,640 --> 00:28:15,929
特殊情况下，这些其他编码可以

769
00:28:15,929 --> 00:28:20,100
做得更好，好吧好吧

770
00:28:20,100 --> 00:28:21,780
第一个最简单的称为空

771
00:28:21,780 --> 00:28:23,580
抑制，这是 run run 的一种变体，

772
00:28:23,580 --> 00:28:25,410
用于编码基本思想是

773
00:28:25,410 --> 00:28:28,920
，如果我们有一个

774
00:28:28,920 --> 00:28:31,530
具有稀疏填充的属性或列的表，则

775
00:28:31,530 --> 00:28:34,170
意味着 g

776
00:28:34,170 --> 00:28:37,230
大多数值都是空然后而不是

777
00:28:37,230 --> 00:28:38,820


778
00:28:38,820 --> 00:28:40,440
为元组的每个单个实例一遍又一遍地存储空值，

779
00:28:40,440 --> 00:28:42,720
我们可以改为可能只是

780
00:28:42,720 --> 00:28:44,940
记录某个地方说嘿我

781
00:28:44,940 --> 00:28:46,830
在这个位置有这么多 Noel

782
00:28:46,830 --> 00:28:51,060
然后我只记录确切的

783
00:28:51,060 --> 00:28:54,950
表中或列中的非空值

784
00:28:54,950 --> 00:28:57,650
现在我们如何实际可以做到这一点可以改变

785
00:28:57,650 --> 00:29:01,350
一个例子是这个oral-b BBC

786
00:29:01,350 --> 00:29:03,870
self 我们将在更多的幻灯片中看到但

787
00:29:03,870 --> 00:29:05,610
就像我说的这就像这很

788
00:29:05,610 --> 00:29:06,990
漂亮 当你知道事情会发生时很常见

789
00:29:06,990 --> 00:29:08,580
如果你知道你有很多

790
00:29:08,580 --> 00:29:10,530
稀疏数据 很多时候 JSON

791
00:29:10,530 --> 00:29:12,060
数据库可以做这种事情

792
00:29:12,060 --> 00:29:14,220
因为如果他们把它组织成一个列

793
00:29:14,220 --> 00:29:15,960
存储 因为大多数时候你不

794
00:29:15,960 --> 00:29:17,340
想要 可能具有其他文档所具有的所有属性，

795
00:29:17,340 --> 00:29:20,910
但这些属性

796
00:29:20,910 --> 00:29:22,110
会再次运行，再次运行链接解码

797
00:29:22,110 --> 00:29:24,120
是

798
00:29:24,120 --> 00:29:26,130
更高级别的想法，即 nil 抑制

799
00:29:26,130 --> 00:29:27,690
是，而 null 抑制是一种

800
00:29:27,690 --> 00:29:30,360
针对空值的优化版本，因此 一世

801
00:29:30,360 --> 00:29:33,420
这里的 dea 是像解码一样运行，正如我

802
00:29:33,420 --> 00:29:35,880
所说，我们的值和我们的列

803
00:29:35,880 --> 00:29:37,860
经常会出现偏差，所以我们

804
00:29:37,860 --> 00:29:39,780
一遍又一遍地有一堆重复的值，

805
00:29:39,780 --> 00:29:41,850
所以如果我们知道

806
00:29:41,850 --> 00:29:44,400
我们的列中有一系列值

807
00:29:44,400 --> 00:29:46,950
相同然后它再次而不是

808
00:29:46,950 --> 00:29:48,630


809
00:29:48,630 --> 00:29:50,160
为每个元组一遍又一遍地存储该唯一值我可以

810
00:29:50,160 --> 00:29:52,410
存储一个三元组说嘿

811
00:29:52,410 --> 00:29:54,990
这里是这个值我在列中遇到了所有设置

812
00:29:54,990 --> 00:29:56,490
这里

813
00:29:56,490 --> 00:29:59,160
是重复的次数然后 一旦你

814
00:29:59,160 --> 00:30:00,690
知道我将如何获得一个与

815
00:30:00,690 --> 00:30:02,370
运行中不同的值，那么

816
00:30:02,370 --> 00:30:03,840
你就有另一个三元组来

817
00:30:03,840 --> 00:30:07,740
正确记录该信息，所以我们将

818
00:30:07,740 --> 00:30:09,840
在下一张幻灯片中看到这一点，但我们上次讨论了

819
00:30:09,840 --> 00:30:12,870
存储排序列列存储上次

820
00:30:12,870 --> 00:30:16,110


821
00:30:16,110 --> 00:30:17,760


822
00:30:17,760 --> 00:30:19,650


823
00:30:19,650 --> 00:30:21,690
如果您能够

824
00:30:21,690 --> 00:30:22,980
以这样一种方式对列进行预排序，

825
00:30:22,980 --> 00:30:25,500
从而使这些长时间重复运行，那么 Vertica 隆隆声编码的好处或您可以通过运行编码获得的压缩率将是惊人的

826
00:30:25,500 --> 00:30:28,440
值 所以让我们看一个非常简单的

827
00:30:28,440 --> 00:30:30,570
例子 所以我们在这里有一张表格，里面

828
00:30:30,570 --> 00:30:34,050
有他们的 ID 和他们的性别，

829
00:30:34,050 --> 00:30:36,570
所以我们想要对性别列进行运行长度编码，

830
00:30:36,570 --> 00:30:39,180
因为假设

831
00:30:39,180 --> 00:30:41,330
只有两个性别 男性 女性

832
00:30:41,330 --> 00:30:43,650
只有两个值 我们可能曾经

833
00:30:43,650 --> 00:30:45,300
有过，所以我们知道我们

834
00:30:45,300 --> 00:30:46,740
一遍又一遍地重复了很多，

835
00:30:46,740 --> 00:30:47,490


836
00:30:47,490 --> 00:30:48,929
所以如果你现在想运行长度编码，

837
00:30:48,929 --> 00:30:51,090
我们可以将它存储为一堆

838
00:30:51,090 --> 00:30:53,220
三元组，其中每个三元组

839
00:30:53,220 --> 00:30:55,409
都有原始的 值

840
00:30:55,409 --> 00:30:57,659
是所有设置在列中然后

841
00:30:57,659 --> 00:31:01,169
重复了多少个值所以在

842
00:31:01,169 --> 00:31:03,330
这种情况下你知道

843
00:31:03,330 --> 00:31:05,820
第一个我有三个 M 一

844
00:31:05,820 --> 00:31:09,059
二三 所以在这个三元组中我有 M

845
00:31:09,059 --> 00:31:11,850
从位置零三开始 现在，如果我

846
00:31:11,850 --> 00:31:13,260
想做一个查找并说好吧

847
00:31:13,260 --> 00:31:16,470
，偏移量三处的元组的性别是什么，

848
00:31:16,470 --> 00:31:19,049
那么我会扫描

849
00:31:19,049 --> 00:31:20,370
这个并说好吧，

850
00:31:20,370 --> 00:31:21,720
我正在寻找的边界可以

851
00:31:21,720 --> 00:31:23,490
在 这个三胞胎 所以我

852
00:31:23,490 --> 00:31:26,399
知道值是什么，你也知道其他

853
00:31:26,399 --> 00:31:28,080
明显的优化，现在如果

854
00:31:28,080 --> 00:31:29,929
你像按计数分组那样做，

855
00:31:29,929 --> 00:31:32,100
而不是再次查看

856
00:31:32,100 --> 00:31:34,649
整列中的每一个值，我

857
00:31:34,649 --> 00:31:37,200
Ignace 翻阅，只看

858
00:31:37,200 --> 00:31:40,770
计数和 和值并以

859
00:31:40,770 --> 00:31:43,080


860
00:31:43,080 --> 00:31:46,620
这种方式在我的聚合之间非常有效地填充我的哈希表所以有

861
00:31:46,620 --> 00:31:48,000
什么问题尽管在这个

862
00:31:48,000 --> 00:31:50,580
例子中还有一个问题这个

863
00:31:50,580 --> 00:31:52,770
例子是它实际上不是我们

864
00:31:52,770 --> 00:31:54,059
实际上没有得到一个很好的压缩

865
00:31:54,059 --> 00:31:55,830
比适合这个小 例如，但

866
00:31:55,830 --> 00:31:57,659
您可以想象一下，如果表格是您

867
00:31:57,659 --> 00:32:00,630
认识数十亿人，那么

868
00:32:00,630 --> 00:32:02,610
这可能会有问题，因为

869
00:32:02,610 --> 00:32:04,289
我们喜欢反复交替的男女模式，

870
00:32:04,289 --> 00:32:06,380


871
00:32:06,380 --> 00:32:10,710
因此将一个元组存储在一个

872
00:32:10,710 --> 00:32:12,149
实例中 这个值在这里

873
00:32:12,149 --> 00:32:14,309
女性我必须存储一个完整的三元组，

874
00:32:14,309 --> 00:32:17,370
因为运行只是运行

875
00:32:17,370 --> 00:32:20,370
长度是一个所以我引用的内容存储

876
00:32:20,370 --> 00:32:22,590
在这里可能只有八位现在

877
00:32:22,590 --> 00:32:25,380
我存储为假设这个 就像你

878
00:32:25,380 --> 00:32:27,659
知道每个 64 位有点

879
00:32:27,659 --> 00:32:30,059
小，但你知道它需要更多的

880
00:32:30,059 --> 00:32:31,860
空间来存储三元组比

881
00:32:31,860 --> 00:32:35,760
我原来的值所以但如果我现在对它进行排序

882
00:32:35,760 --> 00:32:38,190
，现在我先是所有的男性，

883
00:32:38,190 --> 00:32:40,320
然后是所有的 现在的女性，当我

884
00:32:40,320 --> 00:32:41,640
进行运行长度编码时，

885
00:32:41,640 --> 00:32:42,960
我得到了惊人的抑郁率，

886
00:32:42,960 --> 00:32:45,149
因为我只有一个三胞胎，然后说

887
00:32:45,149 --> 00:32:47,220
这是所有长度为 6 的男性

888
00:32:47,220 --> 00:32:48,929
这里是所有长度为 2 的女性，

889
00:32:48,929 --> 00:32:52,529
然后再重复一次 现在你想象在一个

890
00:32:52,529 --> 00:32:55,529
有 100 万人的大专栏中，

891
00:32:55,529 --> 00:32:56,850
如果我这样做的话，它会很

892
00:32:56,850 --> 00:32:57,200
惊人，

893
00:32:57,200 --> 00:32:59,110
是的，

894
00:32:59,110 --> 00:33:01,750
通常当它未压缩时

895
00:33:01,750 --> 00:33:05,640
就像一对一映射一样，哦，

896
00:33:10,230 --> 00:33:11,500
是的，

897
00:33:11,500 --> 00:33:13,539
这个问题是当它未压缩时，

898
00:33:13,539 --> 00:33:16,450
如果我 如果我在 6 点遇到这样的偏移

899
00:33:16,450 --> 00:33:18,370
，我想知道

900
00:33:18,370 --> 00:33:20,110
这个人的性别是什么我知道如何

901
00:33:20,110 --> 00:33:21,850
跳到这个偏移并看到它但

902
00:33:21,850 --> 00:33:24,549
在这个世界上我如果我在这里 然后

903
00:33:24,549 --> 00:33:26,080
从一开始就开始骗局 弄清楚

904
00:33:26,080 --> 00:33:29,260
我属于哪里 我在什么地方 ffset 我的

905
00:33:29,260 --> 00:33:32,559
边界可以被正确地建立，所以

906
00:33:32,559 --> 00:33:34,630
人们认为这就像我正在做的

907
00:33:34,630 --> 00:33:36,399
那样我正在对每个块进行编码，所以这

908
00:33:36,399 --> 00:33:38,260
不像我正在正确扫描整个元组

909
00:33:38,260 --> 00:33:40,750
，另一件事就像 OLAP

910
00:33:40,750 --> 00:33:43,299
查询知道 你真的不在乎

911
00:33:43,299 --> 00:33:44,710
这个单元组的价值是

912
00:33:44,710 --> 00:33:46,779
什么 我不在乎一个多么好的 X 我关心的是

913
00:33:46,779 --> 00:33:47,980
知道

914
00:33:47,980 --> 00:33:49,299
整个大学或

915
00:33:49,299 --> 00:33:50,679
班级或类似的东西的性别分布是什么，所以

916
00:33:50,679 --> 00:33:52,090
你是 进行全面扫描并且在那个

917
00:33:52,090 --> 00:33:54,960
世界中它很快

918
00:33:57,610 --> 00:33:59,799
我说总体上弥补了这意味着

919
00:33:59,799 --> 00:34:01,149
对于我们试图瞄准的工作负载，

920
00:34:01,149 --> 00:34:03,669
例如分析操作这

921
00:34:03,669 --> 00:34:06,010
将是 OLTP 的一大胜利，当我

922
00:34:06,010 --> 00:34:07,899
说去获取这个记录时 这

923
00:34:07,899 --> 00:34:12,690
会是这样 这可能会回来 是的

924
00:34:13,260 --> 00:34:15,820
这个问题是我们的压缩

925
00:34:15,820 --> 00:34:17,649
方案是使用 HTF 系统 是的 所以

926
00:34:17,649 --> 00:34:19,629
这就像如果你执行

927
00:34:19,629 --> 00:34:21,580
我们上次告诉它的分数镜像推送就像 Olga 这样

928
00:34:21,580 --> 00:34:22,929
做 他们压缩了列存储

929
00:34:22,929 --> 00:34:24,969
因为你 '几乎从不

930
00:34:24,969 --> 00:34:27,489
更新那个然后你h

931
00:34:27,489 --> 00:34:30,609
保留烤肉或未压缩的权利，因此在

932
00:34:30,609 --> 00:34:32,230
聊天系统中，您可以在

933
00:34:32,230 --> 00:34:36,639


934
00:34:36,639 --> 00:34:39,699


935
00:34:39,699 --> 00:34:41,949
我们的系统中执行此操作

936
00:34:41,949 --> 00:34:43,330


937
00:34:43,330 --> 00:34:46,889
没有被修改

938
00:34:54,899 --> 00:34:57,160
改变按钮价值世界，如果你

939
00:34:57,160 --> 00:34:59,440
认为你必须改变 ATM 一

940
00:34:59,440 --> 00:35:02,380
小部分镜子是的，所以不是

941
00:35:02,380 --> 00:35:03,670
每个人都参加了介绍班，但

942
00:35:03,670 --> 00:35:05,380
他们今天谈论了最后一个片段

943
00:35:05,380 --> 00:35:06,730
，今天他们谈论金钱，他们

944
00:35:06,730 --> 00:35:07,840
谈论如何像我 稍微

945
00:35:07,840 --> 00:35:10,060
在分数镜像侧放一个小标记，

946
00:35:10,060 --> 00:35:11,260
并且列排序说这东西

947
00:35:11,260 --> 00:35:13,450
被修改了不要去这里寻找这个

948
00:35:13,450 --> 00:35:16,210
确切的值去看看行商店是的，

949
00:35:16,210 --> 00:35:20,860
如果他们在大部队中处理，

950
00:35:20,860 --> 00:35:23,110
一切都是这样

951
00:35:23,110 --> 00:35:24,970
在当前系统中，所有内容始终是

952
00:35:24,970 --> 00:35:28,690
一个单一的存储库，只是

953
00:35:28,690 --> 00:35:30,220
数据的布局可能会

954
00:35:30,220 --> 00:35:31,930
发生变化，这在布局视频上

955
00:35:31,930 --> 00:35:34,570
可能会发生变化，如果它是烤肉或列

956
00:35:34,570 --> 00:35:36,790
存储，如果它是 无论热还是冷，我们

957
00:35:36,790 --> 00:35:39,580
只做笔 MPC C 所以如果你修改

958
00:35:39,580 --> 00:35:42,850
列存储中的某些内容，那么该

959
00:35:42,850 --> 00:35:45,280
版本链将被更新，

960
00:35:45,280 --> 00:35:48,760
现在指向我们当前系统中的行存储

961
00:35:48,760 --> 00:35:50,200
，分离我们做

962
00:35:50,200 --> 00:35:51,760
同样的事情 右边我们有一个压缩的数据块，

963
00:35:51,760 --> 00:35:53,470
它不能被

964
00:35:53,470 --> 00:35:55,270
修改，它很漂亮，所以如果你

965
00:35:55,270 --> 00:35:58,660
修改一个元组，我们而不是

966
00:35:58,660 --> 00:35:59,800
将原始链准确地附加到它所在的位置

967
00:35:59,800 --> 00:36:01,720
，现在被移动到我们处理的一些结果上，

968
00:36:01,720 --> 00:36:02,770
然后是删除

969
00:36:02,770 --> 00:36:07,930
插入好的，所以关于我们的

970
00:36:07,930 --> 00:36:11,200
运行长度编码或 le 的很酷的事情我想我也

971
00:36:11,200 --> 00:36:14,050
做了 Vertigo 可能是

972
00:36:14,050 --> 00:36:15,280
所有列中最多的系统，

973
00:36:15,280 --> 00:36:16,750
它们是最大的

974
00:36:16,750 --> 00:36:18,100
重度用户之一，或者是这种

975
00:36:18,100 --> 00:36:19,870
方法的支持者。 我们将

976
00:36:19,870 --> 00:36:22,300
要进行字典编码，但 RLE 很酷的

977
00:36:22,300 --> 00:36:24,550
事情是我们实际上可以

978
00:36:24,550 --> 00:36:26,410
将它与其他

979
00:36:26,410 --> 00:36:28,420
压缩方案结合使用，我们得到了

980
00:36:28,420 --> 00:36:30,490
很好的乘法效果，我们就像我们

981
00:36:30,490 --> 00:36:31,950
可以然后 对压缩数据进行压缩

982
00:36:31,950 --> 00:36:33,690
，这有点酷，

983
00:36:33,690 --> 00:36:37,060
所以使用位图和编码的想法

984
00:36:37,060 --> 00:36:39,970
是它有点所以我们不是我们将

985
00:36:39,970 --> 00:36:41,620
展示如何在一秒钟内对位图进行口头处理，

986
00:36:41,620 --> 00:36:43,180
但就像这是另

987
00:36:43,180 --> 00:36:44,620
一种你可以做的压力方案 那么你

988
00:36:44,620 --> 00:36:46,060
也可以应用 r-la 但你也可以

989
00:36:46,060 --> 00:36:48,730
口头申请增量编码，所以使用位图

990
00:36:48,730 --> 00:36:50,920
解码的想法是它是一种

991
00:36:50,920 --> 00:36:52,660
不同的组织数据的方式

992
00:36:52,660 --> 00:36:55,930
，而不是为每一

993
00:36:55,930 --> 00:36:59,110
列存储

994
00:36:59,110 --> 00:37:01,180
单个数据 在属性中，对于列可能具有

995
00:37:01,180 --> 00:37:03,370
的每个唯一值，您将拥有一个单独的位图

996
00:37:03,370 --> 00:37:05,290


997
00:37:05,290 --> 00:37:07,300
，

998
00:37:07,300 --> 00:37:09,340
然后如果我想查看此

999
00:37:09,340 --> 00:37:11,530
属性，则此偏移量具有此值，我

1000
00:37:11,530 --> 00:37:13,360
查看相应的位图，然后

1001
00:37:13,360 --> 00:37:15,490
检查以查看 无论是在那个位置是 0 还是 1，

1002
00:37:15,490 --> 00:37:18,940
所以这只有

1003
00:37:18,940 --> 00:37:21,730


1004
00:37:21,730 --> 00:37:23,430
在我试图压缩的东西的值基数很低时才会起作用，

1005
00:37:23,430 --> 00:37:25,930
所以如果我有少量可能的

1006
00:37:25,930 --> 00:37:27,790
属性，我可能是因为我需要

1007
00:37:27,790 --> 00:37:29,320
有一个 位图 r 每一个然后

1008
00:37:29,320 --> 00:37:31,180
这可能是一个巨大的胜利但是如果我有

1009
00:37:31,180 --> 00:37:32,470
很多不同的可能电池或者

1010
00:37:32,470 --> 00:37:34,840
每个值都是独一无二的那么这

1011
00:37:34,840 --> 00:37:36,160
将是一个糟糕的主意因为我

1012
00:37:36,160 --> 00:37:38,080
要负压缩因为我的

1013
00:37:38,080 --> 00:37:39,790
压缩数据将是

1014
00:37:39,790 --> 00:37:42,010
比未压缩的数据大，这

1015
00:37:42,010 --> 00:37:45,820
显然是不好的，所以正如我之前所说的，

1016
00:37:45,820 --> 00:37:47,830
我们将把戴维斯的东西分成

1017
00:37:47,830 --> 00:37:50,080
块或块，这样我们就

1018
00:37:50,080 --> 00:37:51,670
不会分配这些超大的位

1019
00:37:51,670 --> 00:37:53,800
图，我们有一个 每个

1020
00:37:53,800 --> 00:37:55,990
块的位图 所以回到我们这里的例子，

1021
00:37:55,990 --> 00:37:58,750
我们想要一个位图压缩

1022
00:37:58,750 --> 00:38:01,390
性别填充，所以我们只有两个

1023
00:38:01,390 --> 00:38:03,040
值男性或女性

1024
00:38:03,040 --> 00:38:04,900
所以在我们的压缩版本中，我们将

1025
00:38:04,900 --> 00:38:07,150
有一个男性位图 a 值和一个

1026
00:38:07,150 --> 00:38:09,070
坑图 女性值，

1027
00:38:09,070 --> 00:38:10,810
如果我想知道这个偏移量的值是多少，

1028
00:38:10,810 --> 00:38:13,240
我只需

1029
00:38:13,240 --> 00:38:15,580
在位图中查看这个偏移量的位图，然后

1030
00:38:15,580 --> 00:38:20,770
检查 0 1 是否正确，所以这

1031
00:38:20,770 --> 00:38:23,530
开始是一个很大的胜利，所以在我的

1032
00:38:23,530 --> 00:38:25,180
这里的小玩具示例我有 9 个值

1033
00:38:25,180 --> 00:38:27,880
屁股 嗯，我可以将男性女性存储

1034
00:38:27,880 --> 00:38:30,580
为单个字节或 8 位，所以这

1035
00:38:30,580 --> 00:38:33,100
将是 72 位，但

1036
00:38:33,100 --> 00:38:35,320
对于压缩版本中的这个，我有两个

1037
00:38:35,320 --> 00:38:35,980
位图，

1038
00:38:35,980 --> 00:38:39,250
因此每个位图都是

1039
00:38:39,250 --> 00:38:41,740
我拥有的每个值的一位 9 乘以 2 所以

1040
00:38:41,740 --> 00:38:43,750
这是我 18 位然后我需要

1041
00:38:43,750 --> 00:38:45,730
存储原始值但我只存储

1042
00:38:45,730 --> 00:38:47,590
它们一次没问题所以这将是

1043
00:38:47,590 --> 00:38:51,280
8 位的 2 倍所以 16 字节加 18 字节

1044
00:38:51,280 --> 00:38:54,670
是 34 字节所以我可以存储我的

1045
00:38:54,670 --> 00:38:56,950
原始日期 使用 72 位，我可以再次将其

1046
00:38:56,950 --> 00:39:00,520
降低到 34 位，现在可以

1047
00:39:00,520 --> 00:39:02,080
在数百万用户之间进行推断，

1048
00:39:02,080 --> 00:39:15,070
这必须是一个大问题，是的，您的

1049
00:39:15,070 --> 00:39:19,120
问题是为什么不存储哦，我想

1050
00:39:19,120 --> 00:39:21,400
您说的是这是二元

1051
00:39:21,400 --> 00:39:23,470
男性女性，而不是 存储

1052
00:39:23,470 --> 00:39:31,870
单独的 pitmaster 1 就像是的，哦，他的

1053
00:39:31,870 --> 00:39:37,810
大卫是，如果您使用矢量化

1054
00:39:37,810 --> 00:39:40,450
指令而不是将其存储

1055
00:39:40,450 --> 00:39:41,950
为每个单独的位图，

1056
00:39:41,950 --> 00:39:44,950
我不能只是或本质上做

1057
00:39:44,950 --> 00:39:49,810
字典编码存储一个

1058
00:39:49,810 --> 00:39:52,930
可能更大的大小值并

1059
00:39:52,930 --> 00:39:54,730
压缩 它归结为 maller

1060
00:39:54,730 --> 00:39:57,340
编码连续存储这些，

1061
00:39:57,340 --> 00:39:59,740
然后在上面运行 sim D，这太荒谬

1062
00:39:59,740 --> 00:40:04,860
了，这是另一种选择，是

1063
00:40:05,310 --> 00:40:07,420
的，你实际上可以做的另一件很酷的事情

1064
00:40:07,420 --> 00:40:11,830
我认为你不能在字典编码中做到这一点，

1065
00:40:11,830 --> 00:40:12,970
你说的

1066
00:40:12,970 --> 00:40:15,570
是 可以做的就像我们

1067
00:40:15,570 --> 00:40:17,530
已经知道在查询优化器

1068
00:40:17,530 --> 00:40:19,300
中我们将

1069
00:40:19,300 --> 00:40:20,980
评估谓词 s' 而不是在我们的 where

1070
00:40:20,980 --> 00:40:23,050
子句中，以便我们首先尝试更具选择性的

1071
00:40:23,050 --> 00:40:24,400
那些，然后我们开始

1072
00:40:24,400 --> 00:40:26,500
以最快的速度丢弃数据 可能但这

1073
00:40:26,500 --> 00:40:27,760
实际上有点不同现在我们

1074
00:40:27,760 --> 00:40:31,960
可以实际订购

1075
00:40:31,960 --> 00:40:33,760
我们检查位图的方式所以我们知道

1076
00:40:33,760 --> 00:40:36,640
一个位图在单个属性中是超级选择性的

1077
00:40:36,640 --> 00:40:38,500
我们实际上可以

1078
00:40:38,500 --> 00:40:40,780
在第一时间检查那个带来拥抱的

1079
00:40:40,780 --> 00:40:43,030
完全不同的优化级别，这

1080
00:40:43,030 --> 00:40:44,440
与我们讨论的完全不同

1081
00:40:44,440 --> 00:40:46,210
，因为我认为我们不会讨论

1082
00:40:46,210 --> 00:40:48,580
其他位图编码方案，但这

1083
00:40:48,580 --> 00:40:50,320
是您可以执行的其他技术，如果您愿意

1084
00:40:50,320 --> 00:40:53,200
，这些技术真的很酷 您

1085
00:40:53,200 --> 00:40:54,670
开始将您的值编码为位图

1086
00:40:54,670 --> 00:40:57,130
，我们在这里编写的方式并非完全如此

1087
00:40:57,130 --> 00:40:58,780
，但就像您知道我是否

1088
00:40:58,780 --> 00:41:02,320
正在寻找大于某些

1089
00:41:02,320 --> 00:41:03,550
值的值一样，如果这些值已排序，则您正在寻找

1090
00:41:03,550 --> 00:41:06,100
大于某个给定值的值

1091
00:41:06,100 --> 00:41:07,870
以这样的方式，我

1092
00:41:07,870 --> 00:41:09,040
知道你知道我可以先查看

1093
00:41:09,040 --> 00:41:11,290
第一个位图，我可以

1094
00:41:11,290 --> 00:41:12,400
通过查看它来丢弃更多数据，

1095
00:41:12,400 --> 00:41:15,100
因为这更具选择性我会

1096
00:41:15,100 --> 00:41:15,940
尝试在

1097
00:41:15,940 --> 00:41:19,060
稍后讨论矢量化时覆盖它，好吧，所以这个

1098
00:41:19,060 --> 00:41:20,260
这是一个很好的好处

1099
00:41:20,260 --> 00:41:22,359
这是一个明显的胜利我们都知道

1100
00:41:22,359 --> 00:41:24,550
如果是男性/女性他们我们将

1101
00:41:24,550 --> 00:41:26,619
能够将其压低很多让

1102
00:41:26,619 --> 00:41:28,180
我们举个例子我们的位图编码可能是一个

1103
00:41:28,180 --> 00:41:30,609
坏主意所以让我们现在说 我有一张

1104
00:41:30,609 --> 00:41:32,859
客户表，我在这里有邮政编码

1105
00:41:32,859 --> 00:41:34,270
字段 我想尝试对此进行位图

1106
00:41:34,270 --> 00:41:36,609
编码，因此假设在我的表中我

1107
00:41:36,609 --> 00:41:38,770
有 1000 万人，而在

1108
00:41:38,770 --> 00:41:40,869
美国大约有 43,000 个

1109
00:41:40,869 --> 00:41:43,350
邮政编码，我认为它真的像 41,000

1110
00:41:43,350 --> 00:41:46,660
但假设是这样 因此，如果我的

1111
00:41:46,660 --> 00:41:48,760
未压缩数据有 1000 万人，

1112
00:41:48,760 --> 00:41:50,950
并且假设我可以存储已存储的

1113
00:41:50,950 --> 00:41:53,500
邮政编码仅为 32 位，那么

1114
00:41:53,500 --> 00:41:54,490
我为此列存储的总空间

1115
00:41:54,490 --> 00:41:56,980
量仅为 40 兆字节，但现在如果我

1116
00:41:56,980 --> 00:41:58,930
进行位图编码，我需要

1117
00:41:58,930 --> 00:42:02,320
为每个场景在美国有一个唯一的邮政编码的位图，

1118
00:42:02,320 --> 00:42:04,030
并且该

1119
00:42:04,030 --> 00:42:06,040
位图需要 1000 万位长，

1120
00:42:06,040 --> 00:42:07,540
因为我需要代表每

1121
00:42:07,540 --> 00:42:09,310
一个要吹到我的桌子上，所以现在

1122
00:42:09,310 --> 00:42:12,820
总大小将是 53 GB，

1123
00:42:12,820 --> 00:42:14,320
所以再次 这样做显然是非常愚蠢的

1124
00:42:14,320 --> 00:42:17,260
，因此位图和 Cody 可以获得很好的

1125
00:42:17,260 --> 00:42:18,970
压缩率，但这

1126
00:42:18,970 --> 00:42:21,280
是人类必须决定的事情，我是否是

1127
00:42:21,280 --> 00:42:22,840
实际进行编码的正确方法，

1128
00:42:22,840 --> 00:42:26,440
因此出于这个原因，我不

1129
00:42:26,440 --> 00:42:28,210
认为位图编码 是常用的

1130
00:42:28,210 --> 00:42:30,310
它只是你真的只真正看到

1131
00:42:30,310 --> 00:42:31,840
了高端商业 OLAP

1132
00:42:31,840 --> 00:42:34,420
系统的险恶 这不是一个真正的问题 我们

1133
00:42:34,420 --> 00:42:35,650
组织的事情 我们可以想象

1134
00:42:35,650 --> 00:42:38,340
如果现在我开始

1135
00:42:38,340 --> 00:42:41,369
在我的位图中提供两个不同偏移量的元组我得到了

1136
00:42:41,369 --> 00:42:43,240
其他一切并将它们移到

1137
00:42:43,240 --> 00:42:44,560
我们上次看到的相同问题上，

1138
00:42:44,560 --> 00:42:45,760
如果我有

1139
00:42:45,760 --> 00:42:49,320
43,000 个位图仅来自一个属性，

1140
00:42:49,320 --> 00:42:54,100
那么我们可以做一件事，尽管

1141
00:42:54,100 --> 00:42:56,230
除了这样做我正在编码

1142
00:42:56,230 --> 00:42:58,990
这些位图只是战斗

1143
00:42:58,990 --> 00:43:01,030
序列有 1 和 0 像

1144
00:43:01,030 --> 00:43:03,340
完成或像所有数据我们

1145
00:43:03,340 --> 00:43:04,660
实际上可以对

1146
00:43:04,660 --> 00:43:06,700
位图本身进行压缩以获得更好的

1147
00:43:06,700 --> 00:43:11,619
压缩所以最简单的

1148
00:43:11,619 --> 00:43:13,660
方法就是运行

1149
00:43:13,660 --> 00:43:16,660
我们讨论过的相同的 snappy 或 lz4 或 gzip 算法

1150
00:43:16,660 --> 00:43:18,760
在获取我们正在

1151
00:43:18,760 --> 00:43:20,859
存储的位图并且没有通过我们的

1152
00:43:20,859 --> 00:43:22,420
压缩方案运行它然后

1153
00:43:22,420 --> 00:43:23,710
我们实际上可以得到非常好的结果

1154
00:43:23,710 --> 00:43:25,300
因为大多数时候它

1155
00:43:25,300 --> 00:43:27,280
会是一堆零并且这些

1156
00:43:27,280 --> 00:43:29,770
算法是你知道的 这是再次

1157
00:43:29,770 --> 00:43:32,380
压缩位序列的理想情况，

1158
00:43:32,380 --> 00:43:33,800


1159
00:43:33,800 --> 00:43:35,060
我们不会对敌方数据库执行此操作，

1160
00:43:35,060 --> 00:43:36,500
因为这会很

1161
00:43:36,500 --> 00:43:37,640
昂贵，因为现在我只有一次

1162
00:43:37,640 --> 00:43:38,540
要做 当这些

1163
00:43:38,540 --> 00:43:40,100
位图解压缩时，

1164
00:43:40,100 --> 00:43:41,990
这会很慢，这会很慢，你可以说

1165
00:43:41,990 --> 00:43:43,460
让我

1166
00:43:43,460 --> 00:43:45,740
在我的邮政编码示例中将一堆位图

1167
00:43:45,740 --> 00:43:47,240


1168
00:43:47,240 --> 00:43:50,240
组合

1169
00:43:50,240 --> 00:43:51,470
在一起 大多数时候他们不需要去

1170
00:43:51,470 --> 00:43:52,820
查看那些但是当我这样做时我必须

1171
00:43:52,820 --> 00:43:54,920
解压缩它们是的你可以这样做

1172
00:43:54,920 --> 00:43:56,990
但据我所知这是很多

1173
00:43:56,990 --> 00:43:58,340
工程开销并且没有系统

1174
00:43:58,340 --> 00:44:00,980
实际上会这样做

1175
00:44:00,980 --> 00:44:03,950
相反，请参阅对位图代码再次进行

1176
00:44:03,950 --> 00:44:06,380
原生数据库压缩，在

1177
00:44:06,380 --> 00:44:08,870
那里你知道你

1178
00:44:08,870 --> 00:44:10,250
会有一堆零，你可以尝试

1179
00:44:10,250 --> 00:44:11,690
利用它，我们使用

1180
00:44:11,690 --> 00:44:16,760
运行长度编码的变体，所以我

1181
00:44:16,760 --> 00:44:18,560
我现在要描述一种

1182
00:44:18,560 --> 00:44:20,450
Oracle 曾经做过的称为卵黄

1183
00:44:20,450 --> 00:44:24,380
位图代码或 BBC 的剧透

1184
00:44:24,380 --> 00:44:25,640
的技术，他们实际上不再使用它

1185
00:44:25,640 --> 00:44:28,070
并在最后解释为什么

1186
00:44:28,070 --> 00:44:31,460
但这是我认为这种低的一个很好的例子-

1187
00:44:31,460 --> 00:44:34,490
水平位它的亲属 如果你知道你会有很多零，

1188
00:44:34,490 --> 00:44:35,600
你知道位级压缩你可以在位

1189
00:44:35,600 --> 00:44:37,520
图上做

1190
00:44:37,520 --> 00:44:39,440
所以我喜欢这个

1191
00:44:39,440 --> 00:44:40,460
因为他们在我看来

1192
00:44:40,460 --> 00:44:42,560
这很容易理解，然后你

1193
00:44:42,560 --> 00:44:44,000
可以建立在这个基础上 并做更

1194
00:44:44,000 --> 00:44:45,620
复杂的事情或

1195
00:44:45,620 --> 00:44:49,340
对今天的硬件更好的事情，所以再次

1196
00:44:49,340 --> 00:44:50,810
假设我们正在做位图编码，所以我们

1197
00:44:50,810 --> 00:44:52,400
有这些长位图用于我们的

1198
00:44:52,400 --> 00:44:55,310
列，我们想把它压缩

1199
00:44:55,310 --> 00:44:57,470
到 B，这样占用更少的空间，而且

1200
00:44:57,470 --> 00:44:59,150
大部分 这些位将是零，

1201
00:44:59,150 --> 00:45:01,640
所以我们将把它组织成这些

1202
00:45:01,640 --> 00:45:04,730
块，在那里我们有

1203
00:45:04,730 --> 00:45:07,040
一堆字节是否全零后面跟着

1204
00:45:07,040 --> 00:45:08,870
一些字节是否有一些

1205
00:45:08,870 --> 00:45:11,750
字节所以他们将指定任何

1206
00:45:11,750 --> 00:45:14,270
具有 全零作为间隙字节，然后

1207
00:45:14,270 --> 00:45:16,910
在任何位置有 1 的任何字节

1208
00:45:16,910 --> 00:45:19,610
都称为尾字节，

1209
00:45:19,610 --> 00:45:21,110
因此我们正在做的我们将对一个块进行编码

1210
00:45:21,110 --> 00:45:23,480
，其中我们有一堆间隙字节

1211
00:45:23,480 --> 00:45:26,260
通过一定数量的尾

1212
00:45:26,260 --> 00:45:29,510
字节 我们要把它分解 以

1213
00:45:29,510 --> 00:45:30,230
这种方式压缩它，

1214
00:45:30,230 --> 00:45:32,090
以便间隙字节将使用运行

1215
00:45:32,090 --> 00:45:33,890
长度编码进行压缩，然后对于

1216
00:45:33,890 --> 00:45:35,780
其中有 1 的尾字节，

1217
00:45:35,780 --> 00:45:39,470
它将跟踪该字节所在的位置，

1218
00:45:39,470 --> 00:45:41,390
如果是特殊情况，我们

1219
00:45:41,390 --> 00:45:43,780
只有一口或 最奇怪的或者它们

1220
00:45:43,780 --> 00:45:46,190
未压缩或按他们所说的逐字逐字

1221
00:45:46,190 --> 00:45:47,180


1222
00:45:47,180 --> 00:45:49,400
所以让我们看一下视觉示例所以说

1223
00:45:49,400 --> 00:45:52,160
这是我的位图在这里我们可以

1224
00:45:52,160 --> 00:45:54,050
看到我们都是零除了

1225
00:45:54,050 --> 00:45:56,480
这里的这个字节我们有一个一然后

1226
00:45:56,480 --> 00:45:58,160
这个字节在这里这些 这里有两个字节 这里有一个 这里有两个字节

1227
00:45:58,160 --> 00:45:59,660


1228
00:45:59,660 --> 00:46:02,060
所以他们要做什么 他们要把

1229
00:46:02,060 --> 00:46:03,800


1230
00:46:03,800 --> 00:46:07,100
位图分解成段或块，我们

1231
00:46:07,100 --> 00:46:08,810
有一堆间隙字节，它们都在那里

1232
00:46:08,810 --> 00:46:10,880
零后跟一些字节，其中

1233
00:46:10,880 --> 00:46:13,010
至少有一个，所以

1234
00:46:13,010 --> 00:46:15,080
这里的第一个字节再次是我们的间隙

1235
00:46:15,080 --> 00:46:16,910
字节，它们都是零，然后这是

1236
00:46:16,910 --> 00:46:18,350
我们的尾字节，其中有一个 1

1237
00:46:18,350 --> 00:46:20,720
所以我们要对它进行编码的方式在

1238
00:46:20,720 --> 00:46:22,550
这里 另一个是正确的，

1239
00:46:22,550 --> 00:46:24,770
因为我们有 在这里，

1240
00:46:24,770 --> 00:46:26,300
我们要覆盖第一个是

1241
00:46:26,300 --> 00:46:28,880
我们总是必须有一个标题字节

1242
00:46:28,880 --> 00:46:30,410
，标题字节会告诉

1243
00:46:30,410 --> 00:46:34,430
我们我们的块中有什么，所以前 3 位

1244
00:46:34,430 --> 00:46:35,900
将被组织起来告诉我们

1245
00:46:35,900 --> 00:46:39,050
我们有多少个间隙字节，最多变成 7 个，这样

1246
00:46:39,050 --> 00:46:41,150
我们就可以开始代码，并移植这个

1247
00:46:41,150 --> 00:46:42,680
标头的这一部分，但是你说我们

1248
00:46:42,680 --> 00:46:45,230
的块中最多有七个间隙字节

1249
00:46:45,230 --> 00:46:46,910
，我们有更多的

1250
00:46:46,910 --> 00:46:48,770
东西要做其他事情，所以在 在这种情况下，

1251
00:46:48,770 --> 00:46:51,440
我们有两个一两个间隙字节，所以我们说

1252
00:46:51,440 --> 00:46:52,880
记录我们只有数字

1253
00:46:52,880 --> 00:46:56,690
2，然后在下一位这是一个

1254
00:46:56,690 --> 00:46:58,730
特殊标志，表示如果这

1255
00:46:58,730 --> 00:47:00,500
件事设置为真，那么我们知道我们知道

1256
00:47:00,500 --> 00:47:02,030
什么尾字节' 再看看

1257
00:47:02,030 --> 00:47:04,250
我们的块中只有一个，而且它

1258
00:47:04,250 --> 00:47:08,120
只有一个，所以这是说

1259
00:47:08,120 --> 00:47:09,710
如果它被设置为一个，所以我们知道

1260
00:47:09,710 --> 00:47:11,480
这是一个特殊情况，那么接下来的

1261
00:47:11,480 --> 00:47:13,940
四个字节告诉我们在我们的哪个位置

1262
00:47:13,940 --> 00:47:17,120
一个字节所在的字节所以在

1263
00:47:17,120 --> 00:47:19,310
这个字节中我们正在编码所以在我们的

1264
00:47:19,310 --> 00:47:21,920
尾字节中我们有 一二三四，

1265
00:47:21,920 --> 00:47:23,840
这就是一个所在的位置，

1266
00:47:23,840 --> 00:47:25,790
所以我们可以

1267
00:47:25,790 --> 00:47:28,550
在我们的位图中取三个字节并将其编码为

1268
00:47:28,550 --> 00:47:32,270
一个字节，这样很好让我们

1269
00:47:32,270 --> 00:47:34,460
看看下一个块，所以现在又一次

1270
00:47:34,460 --> 00:47:36,650
我们有十三 gap 字节后跟

1271
00:47:36,650 --> 00:47:38,870
两个尾字节，所以当我们写出我们的

1272
00:47:38,870 --> 00:47:40,700
头时，我们不能记录我们有

1273
00:47:40,700 --> 00:47:44,720
13 个间隙字节，因为我们

1274
00:47:44,720 --> 00:47:46,790
只能在这三位中存储多达 8 或 7

1275
00:47:46,790 --> 00:47:49,400
个字节，所以我们将其全部设置为

1276
00:47:49,400 --> 00:47:51,770
1 是的，这会告诉我们

1277
00:47:51,770 --> 00:47:53,390
这是一个特殊情况，

1278
00:47:53,390 --> 00:47:55,700
我们需要查看标头之后的第一个字节

1279
00:47:55,700 --> 00:47:57,500
，这会告诉

1280
00:47:57,500 --> 00:47:58,910
我们帽子的长度，所以我们在法庭上的第

1281
00:47:58,910 --> 00:48:00,740
13 个

1282
00:48:00,740 --> 00:48:03,110
代表我们的 13 个帽子灯 没错，

1283
00:48:03,110 --> 00:48:04,340
这就是编码部分的运行时间，

1284
00:48:04,340 --> 00:48:07,220
然后我们再次查看这个

1285
00:48:07,220 --> 00:48:09,200
特殊标志，它告诉

1286
00:48:09,200 --> 00:48:10,850
我们是否只有一个字节，其中有一个

1287
00:48:10,850 --> 00:48:11,510
1，

1288
00:48:11,510 --> 00:48:14,270
这被设置为零，这意味着

1289
00:48:14,270 --> 00:48:16,400
在接下来的四位中，我们 将记录

1290
00:48:16,400 --> 00:48:19,070
我们逐字记录的字节数 是的

1291
00:48:19,070 --> 00:48:20,900
，这就是我们准确编码的地方，

1292
00:48:20,900 --> 00:48:22,730
无论这些位是如何在这里找到的，

1293
00:48:22,730 --> 00:48:26,119
或者只是直接

1294
00:48:26,119 --> 00:48:40,300
复制它们是的，是的，我知道性别是的，

1295
00:48:40,300 --> 00:48:42,770
但高级我只是看到了同样的，

1296
00:48:42,770 --> 00:48:44,990
所以在这个例子中我 能够

1297
00:48:44,990 --> 00:48:46,940
获取一个 18 字节的位图并将其

1298
00:48:46,940 --> 00:48:49,940
压缩到 5 字节，这是

1299
00:48:49,940 --> 00:48:52,820
非常令人印象深刻的，所以再次我是我

1300
00:48:52,820 --> 00:48:55,310
而不是现在存储如果我正在

1301
00:48:55,310 --> 00:48:57,020
执行位图编码而不是

1302
00:48:57,020 --> 00:48:58,910
存储每个位图

1303
00:48:58,910 --> 00:49:00,980
未压缩形式的单个值 我可以使用该

1304
00:49:00,980 --> 00:49:04,180
位图并分别压缩每个值

1305
00:49:04,180 --> 00:49:07,180
是的

1306
00:49:15,470 --> 00:49:18,620
[音乐]

1307
00:49:23,220 --> 00:49:26,090
和一种理解让你知道

1308
00:49:26,090 --> 00:49:28,680
叹气所以你就是这样所以你

1309
00:49:28,680 --> 00:49:29,970
说而不是把这四个

1310
00:49:29,970 --> 00:49:37,220
位扔在这里对不起做 我所

1311
00:49:40,040 --> 00:49:44,990
连接的意思是，

1312
00:49:49,400 --> 00:49:52,500
逻辑上说谎以具有更大的差距大小的立场

1313
00:49:52,500 --> 00:49:55,740
是的，我认为这可能会

1314
00:49:55,740 --> 00:49:59,000
起作用是的，

1315
00:49:59,300 --> 00:50:05,070
他们没有那样做，好吧，是的，

1316
00:50:05,070 --> 00:50:09,780
我再次喜欢我 Isis 我怀疑媒体是

1317
00:50:09,780 --> 00:50:10,950
有原因的 而是他们看着他们

1318
00:50:10,950 --> 00:50:12,570
确定他们的数据库位图，

1319
00:50:12,570 --> 00:50:14,010
这是 Oracle 对的，所以他们有真实的

1320
00:50:14,010 --> 00:50:16,530
客户，他们有真实的数据，他们

1321
00:50:16,530 --> 00:50:18,210
决定在

1322
00:50:18,210 --> 00:50:19,590
大多数情况下这是正确的方法，

1323
00:50:19,590 --> 00:50:23,880
我认为这是正确的，

1324
00:50:23,880 --> 00:50:26,280
所以我说 Oracle 不再这样做

1325
00:50:26,280 --> 00:50:27,780
了，这被认为是一种过时的

1326
00:50:27,780 --> 00:50:30,720
格式，所以原因是虽然

1327
00:50:30,720 --> 00:50:31,589
我们将获得很高的压缩

1328
00:50:31,589 --> 00:50:35,070
比，但它实际上

1329
00:50:35,070 --> 00:50:37,619
对现代 CPU 来说会很糟糕，因为在我正在经历的过程中，

1330
00:50:37,619 --> 00:50:40,020
所有这些分支都是正确

1331
00:50:40,020 --> 00:50:42,030
的 为了让我

1332
00:50:42,030 --> 00:50:44,099
弄清楚，就像你知道我正在

1333
00:50:44,099 --> 00:50:46,859
对这些压缩字节进行操作一样，我不得不

1334
00:50:46,859 --> 00:50:48,570
四处走动，就像哦

1335
00:50:48,570 --> 00:50:50,760
，如果这样跳过这里，或者这

1336
00:50:50,760 --> 00:50:53,040
东西比那个小，那么我不需要

1337
00:50:53,040 --> 00:50:54,690
看 在这一点，但

1338
00:50:54,690 --> 00:50:56,580
如果为零，这是一个跳跃 做其他正确

1339
00:50:56,580 --> 00:50:58,470
的事情，这对现代 CPU 来说很糟糕，因为 CPU

1340
00:50:58,470 --> 00:51:00,330


1341
00:51:00,330 --> 00:51:01,980
上的分支预测器将

1342
00:51:01,980 --> 00:51:03,450
很难预测所有这些条件，因为它会有所不同

1343
00:51:03,450 --> 00:51:04,619
为每一个你知道的

1344
00:51:04,619 --> 00:51:07,589
块序列租用，我们会有

1345
00:51:07,589 --> 00:51:08,640
很多错误预测，这将

1346
00:51:08,640 --> 00:51:10,260
不得不导致我们刷新我们的

1347
00:51:10,260 --> 00:51:12,420
提取管道，这将导致

1348
00:51:12,420 --> 00:51:15,270
CPU 停顿，因此出于这个原因，他们

1349
00:51:15,270 --> 00:51:17,430
想出了另一个版本的 一个

1350
00:51:17,430 --> 00:51:18,660
称为右对齐

1351
00:51:18,660 --> 00:51:21,480
混合位图编码的改进版本，专

1352
00:51:21,480 --> 00:51:24,690
为现代 CPU 设计 BBC 的东西已

1353
00:51:24,690 --> 00:51:26,580
获得专利，但它就像 90 年代 -

1354
00:51:26,580 --> 00:51:28,320
它可能已经消失了，现在可能专利已过期，

1355
00:51:28,320 --> 00:51:30,210
我认为这东西仍然是

1356
00:51:30,210 --> 00:51:33,570
专利的，我从未读过 它的

1357
00:51:33,570 --> 00:51:35,940
数据库专利和 II 不混合，所以

1358
00:51:35,940 --> 00:51:36,930


1359
00:51:36,930 --> 00:51:38,820
我们不会读到类似的东西，但

1360
00:51:38,820 --> 00:51:40,230
他们确实有一些东西可以

1361
00:51:40,230 --> 00:51:42,690
再次做到这一点 另外要指出的另一件事

1362
00:51:42,690 --> 00:51:45,290
是，在所有这些情况下，

1363
00:51:45,290 --> 00:51:47,640
这种位图编码方案 它不

1364
00:51:47,640 --> 00:51:49,530
支持随机访问，如果

1365
00:51:49,530 --> 00:51:51,660
我们正在做 OLAP 查询，那没关系，因为我们

1366
00:51:51,660 --> 00:51:52,890
要从头到尾扫描，但是如果

1367
00:51:52,890 --> 00:51:54,540
我们有我们想说在这个

1368
00:51:54,540 --> 00:51:56,550
位置查找位图是设置为 1

1369
00:51:56,550 --> 00:51:58,650
还是 0 我们必须 从 th 开始 开始

1370
00:51:58,650 --> 00:52:02,310
并解压缩所有内容，因此这

1371
00:52:02,310 --> 00:52:04,200
对于用于 OLAP 的 OLTP 来说效果不佳，

1372
00:52:04,200 --> 00:52:07,530
这很好，所以让我们使用

1373
00:52:07,530 --> 00:52:09,480
其他一些粉碎方案，以便 Delta 编码

1374
00:52:09,480 --> 00:52:11,880
这里的想法是，如果我们知道

1375
00:52:11,880 --> 00:52:15,930
同一列中的值

1376
00:52:15,930 --> 00:52:17,880
将是 在它们之间有一个小的

1377
00:52:17,880 --> 00:52:20,010
差异然后而不是为每个元组再次存储

1378
00:52:20,010 --> 00:52:22,110
该值的完整副本，

1379
00:52:22,110 --> 00:52:23,970
我们将

1380
00:52:23,970 --> 00:52:27,210
在连续值之间恢复一个增量，

1381
00:52:27,210 --> 00:52:31,170
所以这里的想法说这

1382
00:52:31,170 --> 00:52:33,360
是我的表，我正在记录

1383
00:52:33,360 --> 00:52:35,400
这个房间的温度是 99 度

1384
00:52:35,400 --> 00:52:37,110
，非常热，但我

1385
00:52:37,110 --> 00:52:38,580
每分钟都在我的传感器中进行测量

1386
00:52:38,580 --> 00:52:40,590
，然后

1387
00:52:40,590 --> 00:52:41,700
这些温度之间的差异不会那么

1388
00:52:41,700 --> 00:52:43,860
大，因为你知道如果它

1389
00:52:43,860 --> 00:52:44,640
考虑物理世界

1390
00:52:44,640 --> 00:52:47,160
这个房间不是 将在一分钟内从 99 度

1391
00:52:47,160 --> 00:52:49,110
变为 0 度，

1392
00:52:49,110 --> 00:52:51,090
因此大多数情况下这些

1393
00:52:51,090 --> 00:52:52,230
增量将是过小的

1394
00:52:52,230 --> 00:52:54,150
增量，所以我要做的是

1395
00:52:54,150 --> 00:52:57,810
在我的 t 中取第一个值 wo 列，我

1396
00:52:57,810 --> 00:53:00,990
会完整地记录它们，但是

1397
00:53:00,990 --> 00:53:02,370
之后的所有内容都

1398
00:53:02,370 --> 00:53:04,680
只是前一个之间的差值

1399
00:53:04,680 --> 00:53:06,810


1400
00:53:06,810 --> 00:53:08,640


1401
00:53:08,640 --> 00:53:11,930


1402
00:53:11,930 --> 00:53:13,680
什么是另一种技术方法来

1403
00:53:13,680 --> 00:53:18,540
进一步压缩这个 RLE

1404
00:53:18,540 --> 00:53:21,900
正是它所说的那个人所以在这里

1405
00:53:21,900 --> 00:53:23,820
我再次引用它正在测量

1406
00:53:23,820 --> 00:53:25,500
每分钟我会

1407
00:53:25,500 --> 00:53:26,940
一遍又一遍地得到一堆加号 再次这样我

1408
00:53:26,940 --> 00:53:29,760
现在可以采取这个并口头运行然后

1409
00:53:29,760 --> 00:53:31,680
现在将它存储为一个你知道的

1410
00:53:31,680 --> 00:53:34,410
单双在这里加上一个然后

1411
00:53:34,410 --> 00:53:38,640
是岩石的大小所以在这个

1412
00:53:38,640 --> 00:53:40,680
看我的玩具示例这里的

1413
00:53:40,680 --> 00:53:42,120
原始数据假设我们

1414
00:53:42,120 --> 00:53:43,260
将时间戳和

1415
00:53:43,260 --> 00:53:48,150
温度重新存储为 32 位这是错误的它被

1416
00:53:48,150 --> 00:53:51,240
读取了 5 次 2 或者你只是取了

1417
00:53:51,240 --> 00:53:53,070
所以我们有五个值每个 30

1418
00:53:53,070 --> 00:53:55,440
位在这种情况下是 160 位

1419
00:53:55,440 --> 00:53:56,640
假设我们可以然后将其存储

1420
00:53:56,640 --> 00:53:59,400
为 16 位 deltas 所以现在我会

1421
00:53:59,400 --> 00:54:01,890
降到 96 位，但如果我可以在

1422
00:54:01,890 --> 00:54:04,230
这方面做 RLE 说我存储原始的 32 位，

1423
00:54:04,230 --> 00:54:07,830
然后是两个 16 位的字段，

1424
00:54:07,830 --> 00:54:10,109
比如 Delta，然后长度

1425
00:54:10,109 --> 00:54:13,100
是错误的，我可以把它降到 64

1426
00:54:13,100 --> 00:54:15,150
位，就是这样 非常好，

1427
00:54:15,150 --> 00:54:16,950
但与

1428
00:54:16,950 --> 00:54:18,990
我之前所说的所有其他接缝一样，如果我想

1429
00:54:18,990 --> 00:54:20,910
知道确切的值是为了这个，

1430
00:54:20,910 --> 00:54:23,119
除非我正在存储运行长度编码我

1431
00:54:23,119 --> 00:54:25,710
基本上在重新计算这个东西以

1432
00:54:25,710 --> 00:54:28,800
得到什么 正确的时间，所以

1433
00:54:28,800 --> 00:54:30,330
这是我们的 le 实际上可以让

1434
00:54:30,330 --> 00:54:33,000
我们更好的计算和性能

1435
00:54:33,000 --> 00:54:35,130
改进的地方，因为我不必

1436
00:54:35,130 --> 00:54:36,420
重新应用它

1437
00:54:36,420 --> 00:54:37,920


1438
00:54:37,920 --> 00:54:43,140


1439
00:54:43,140 --> 00:54:44,760
Delta 编码的变体称为

1440
00:54:44,760 --> 00:54:47,369
增量编码，这里的想法

1441
00:54:47,369 --> 00:54:49,260
是，对于字符串，如果我们认识到

1442
00:54:49,260 --> 00:54:52,040
我们有重复的前缀和后缀，

1443
00:54:52,040 --> 00:54:54,210
我们只是存储

1444
00:54:54,210 --> 00:54:57,270
了连续值之间的差异，所以说这

1445
00:54:57,270 --> 00:54:58,890
是我的原始数据，我有四个字符串

1446
00:54:58,890 --> 00:55:02,340
Rob Rob 抢劫和机器人，所以

1447
00:55:02,340 --> 00:55:03,450
我需要做的第一件事是弄清楚

1448
00:55:03,450 --> 00:55:04,770
连续值之间的公共前缀是什么，

1449
00:55:04,770 --> 00:55:07,320
所以在第一个的情况下，

1450
00:55:07,320 --> 00:55:10,050
Rob 好吧，在它之前没有任何东西

1451
00:55:10,050 --> 00:55:11,700
，所以我们必须将其全部存储在

1452
00:55:11,700 --> 00:55:13,680
那里 不是通用前缀，但是

1453
00:55:13,680 --> 00:55:15,359
当我们在这里查看下一个时，这

1454
00:55:15,359 --> 00:55:17,130
很好地共享了这个出现的前三个三个

1455
00:55:17,130 --> 00:55:19,109
字符，所以我们

1456
00:55:19,109 --> 00:55:21,180
知道这是从这个

1457
00:55:21,180 --> 00:55:23,250
属性到下一个属性

1458
00:55:23,250 --> 00:55:24,240
的公共前缀，这个包到下一次 我们对这里

1459
00:55:24,240 --> 00:55:25,500
的所有其他人做同样的事情，

1460
00:55:25,500 --> 00:55:27,930
所以现在一旦我们有了这个共同的

1461
00:55:27,930 --> 00:55:30,510
前缀，压缩版本就可以只

1462
00:55:30,510 --> 00:55:34,650
存储我们共享的前缀的长度

1463
00:55:34,650 --> 00:55:36,150
，然后剩下

1464
00:55:36,150 --> 00:55:39,119
的实际上不同的后缀，

1465
00:55:39,119 --> 00:55:40,350
所以这只是不存在 如果

1466
00:55:40,350 --> 00:55:44,550
事情按顺序排序，它实际上

1467
00:55:44,550 --> 00:55:46,109
也可以在 B 加树内部工作，

1468
00:55:46,109 --> 00:55:47,700
我们稍后

1469
00:55:47,700 --> 00:55:49,590


1470
00:55:49,590 --> 00:55:52,050


1471
00:55:52,050 --> 00:55:54,240
见 这里数据集的一部分是

1472
00:55:54,240 --> 00:55:57,030
168 位，然后是 88

1473
00:55:57,030 --> 00:55:59,190
位来存储后缀，然后说

1474
00:55:59,190 --> 00:56:01,500
4 乘以 8 位来存储

1475
00:56:01,500 --> 00:56:03,690
前缀的长度，

1476
00:56:03,690 --> 00:56:08,720
所以总共这就是 100 和 120

1477
00:56:08,720 --> 00:56:11,160
好吧，我也是 不存储

1478
00:56:11,160 --> 00:56:13,170
字符串的长度我也必须

1479
00:56:13,170 --> 00:56:15,390
这样做，然后对后缀做同样的事情，

1480
00:56:15,390 --> 00:56:16,740
就像我需要后缀的长度一样

1481
00:56:16,740 --> 00:56:23,700
是的，这个问题是这样的，如果

1482
00:56:23,700 --> 00:56:25,049
它以图形方式排序，我的

1483
00:56:25,049 --> 00:56:27,630
意思是说让我们 算盘定义

1484
00:56:27,630 --> 00:56:28,890
了排序顺序的排序方式是什么，

1485
00:56:28,890 --> 00:56:30,809
在我的示例中是它的

1486
00:56:30,809 --> 00:56:33,089
ASCII 排序，所以是的，按字母顺序

1487
00:56:33,089 --> 00:56:33,960
排序通过这个很好地解决

1488
00:56:33,960 --> 00:56:39,599
了这个问题，所以接下来的

1489
00:56:39,599 --> 00:56:42,089
方案是 Myrtle 并不是真正的

1490
00:56:42,089 --> 00:56:45,000
压缩方案，但它是一个

1491
00:56:45,000 --> 00:56:48,329
以这样一种方式对数据进行编码的方式，你会减少

1492
00:56:48,329 --> 00:56:50,430
空间，据他们所知

1493
00:56:50,430 --> 00:56:51,930
，她这样做的唯一系统是亚马逊的

1494
00:56:51,930 --> 00:56:54,150
红移，所以他们主要在编码中调用它，

1495
00:56:54,150 --> 00:56:55,530
所以这个想法是，如果你有

1496
00:56:55,530 --> 00:56:58,230
一个属性 当时它

1497
00:56:58,230 --> 00:56:59,880
不会是您为属性定义的完整大小，

1498
00:56:59,880 --> 00:57:02,430
然后不是

1499
00:57:02,430 --> 00:57:03,900
存储该属性的所有位，

1500
00:57:03,900 --> 00:57:05,549
而是将其存储为较小的数据类型，

1501
00:57:05,549 --> 00:57:08,520
因此这通常很常见，

1502
00:57:08,520 --> 00:57:10,470
您在认识的应用程序

1503
00:57:10,470 --> 00:57:12,390
开发人员中看到这种情况 他们定义了他们的模式，

1504
00:57:12,390 --> 00:57:13,559
他们只是说哦，我希望所有内容都

1505
00:57:13,559 --> 00:57:15,809
在 64 位，但大多数时候你只

1506
00:57:15,809 --> 00:57:17,130
存储你知道它可以

1507
00:57:17,130 --> 00:57:19,589
存储在 8 位的东西，所以如果你知道你

1508
00:57:19,589 --> 00:57:21,000
可以告诉它不是我想要做的 法院

1509
00:57:21,000 --> 00:57:22,349
打电话给你，你知道主要的编码方式，

1510
00:57:22,349 --> 00:57:24,990
现在我可以说过去是 64 位列，

1511
00:57:24,990 --> 00:57:26,849
大多数时候它会是

1512
00:57:26,849 --> 00:57:30,210
8 位，但是任何时候我有

1513
00:57:30,210 --> 00:57:32,880
一个不适合 8 位的值，

1514
00:57:32,880 --> 00:57:36,809
那么我只是 有一个特殊的标志来

1515
00:57:36,809 --> 00:57:38,970
说明原始向量寻找它的完整值

1516
00:57:38,970 --> 00:57:40,920
这个偏移量在这个

1517
00:57:40,920 --> 00:57:43,770
查找表中，所以现在如果我正在扫描

1518
00:57:43,770 --> 00:57:45,119
并试图找到所有

1519
00:57:45,119 --> 00:57:47,819
大于你知道的大于 10 的值或

1520
00:57:47,819 --> 00:57:49,260
类似的东西，如果我 遇到

1521
00:57:49,260 --> 00:57:51,029
这个我必须知道 j 在

1522
00:57:51,029 --> 00:57:55,680
这里，所以在这个例子中，

1523
00:57:55,680 --> 00:57:57,420
原始大小将是 5 倍 64 位

1524
00:57:57,420 --> 00:58:00,180
将是 33 位和 20 位假设我再次

1525
00:58:00,180 --> 00:58:02,700
可以将这个查找内容存储

1526
00:58:02,700 --> 00:58:05,970
为 16 位加上一个 64 位值然后我

1527
00:58:05,970 --> 00:58:08,180
把它归结为 是 100 20 位，

1528
00:58:08,180 --> 00:58:13,950
好吧，所以我总是用完

1529
00:58:13,950 --> 00:58:15,809
压缩时间，但我

1530
00:58:15,809 --> 00:58:17,609
想花时间完成的

1531
00:58:17,609 --> 00:58:19,980
是字典压缩，

1532
00:58:19,980 --> 00:58:22,819
这里的想法是我们将

1533
00:58:22,819 --> 00:58:28,200
在 在

1534
00:58:28,200 --> 00:58:30,900
属性的值中，而不是

1535
00:58:30,900 --> 00:58:32,460
一遍又一遍地将它们完整地存储起来，

1536
00:58:32,460 --> 00:58:34,019
我们只是

1537
00:58:34,019 --> 00:58:36,779
用某种较小的代码替换它们，并且

1538
00:58:36,779 --> 00:58:40,230
随时可以查看

1539
00:58:40,230 --> 00:58:41,460
我们的原始值是什么”  d 在

1540
00:58:41,460 --> 00:58:43,289
这本字典中查看它可以是一个哈希

1541
00:58:43,289 --> 00:58:44,640
表 B 加树可以是一个数组

1542
00:58:44,640 --> 00:58:46,529
不同的组织方式 然后我们可以

1543
00:58:46,529 --> 00:58:48,509
将该编码值转换

1544
00:58:48,509 --> 00:58:51,690
回原始值所以我们显然

1545
00:58:51,690 --> 00:58:53,249
希望支持快速编码和解码，如果

1546
00:58:53,249 --> 00:58:55,380
它真的是真的 昂贵的 对

1547
00:58:55,380 --> 00:58:57,569
我们的数据块进行编码，那么这将是

1548
00:58:57,569 --> 00:59:00,239
一个糟糕的权衡解码可能

1549
00:59:00,239 --> 00:59:01,470
会你知道它实际上会

1550
00:59:01,470 --> 00:59:02,700
更重要，

1551
00:59:02,700 --> 00:59:04,410
但是当我也会快速告诉我的坏 V

1552
00:59:04,410 --> 00:59:06,150
并且他们也是我们中的一个支持

1553
00:59:06,150 --> 00:59:08,430
范围查询时 这样我们就可以知道

1554
00:59:08,430 --> 00:59:09,749
找到所有

1555
00:59:09,749 --> 00:59:11,789
大于 sum 的属性，或者 sums 跟随

1556
00:59:11,789 --> 00:59:13,049
那些值很大的元组和一些给定的

1557
00:59:13,049 --> 00:59:15,239
值，我不想被压缩

1558
00:59:15,239 --> 00:59:16,559
以进行评估，所以如果我的

1559
00:59:16,559 --> 00:59:18,390
字典编码遵循相同的

1560
00:59:18,390 --> 00:59:21,749
原始值的顺序然后我

1561
00:59:21,749 --> 00:59:24,930
可以直接对压缩数据进行操作，因此

1562
00:59:24,930 --> 00:59:26,220
我们要为

1563
00:59:26,220 --> 00:59:27,779
字典压缩做出的决定是何时

1564
00:59:27,779 --> 00:59:29,220
构建字典应该

1565
00:59:29,220 --> 00:59:30,989
是字典的范围，就像

1566
00:59:30,989 --> 00:59:32,789
您知道我们正在查看数据的哪一部分一样

1567
00:59:32,789 --> 00:59:34,739
我们想要使用什么数据结构

1568
00:59:34,739 --> 00:59:35,970
，然后字典的编码方案应该是什么

1569
00:59:35,970 --> 00:59:38,190
，所以

1570
00:59:38,190 --> 00:59:41,099
对于我让你们阅读的论文，他们

1571
00:59:41,099 --> 00:59:42,960
谈论你可以使用霍夫曼

1572
00:59:42,960 --> 00:59:45,359
编码或谁更难编码谁

1573
00:59:45,359 --> 00:59:46,890
代码实际上会想要使用，

1574
00:59:46,890 --> 00:59:48,450
因为他们或他们的订单保留

1575
00:59:48,450 --> 00:59:50,099
我们不会谈论那些

1576
00:59:50,099 --> 00:59:51,539
专辑实际上是什么，因为我们并不

1577
00:59:51,539 --> 00:59:53,160
真正关心我们只是使用你

1578
00:59:53,160 --> 00:59:54,029
知道的我们数据库人们会使用

1579
00:59:54,029 --> 00:59:57,539
任何有效但 一般来说，

1580
00:59:57,539 --> 00:59:59,339
大多数人的字典都会

1581
00:59:59,339 --> 01:00:01,559
使用 who tucker 代码，所以我们

1582
01:00:01,559 --> 01:00:04,099
将专注于这里的其他代码，

1583
01:00:04,099 --> 01:00:06,450
所以第一个是我们什么时候

1584
01:00:06,450 --> 01:00:08,609
真正构建字典，这样我们

1585
01:00:08,609 --> 01:00:10,799
就可以一次完成所有这些 我们有

1586
01:00:10,799 --> 01:00:14,849
一些一些数据，我们

1587
01:00:14,849 --> 01:00:15,930
知道没有其他东西

1588
01:00:15,930 --> 01:00:17,849
会添加到其中或从中删除，所以

1589
01:00:17,849 --> 01:00:19,470
当你把这些数据和

1590
01:00:19,470 --> 01:00:21,989
电脑拿给他们时，这一次你

1591
01:00:21,989 --> 01:00:23,400
知道我们实际上可能会

1592
01:00:23,400 --> 01:00:25,049
获得最佳压缩比，因为我们

1593
01:00:25,049 --> 01:00:26,759
可以假设您所知道的一切我们都

1594
01:00:26,759 --> 01:00:28,319
知道如何将

1595
01:00:28,319 --> 01:00:29,730
所需的最小数量的自行车装入字典代码中，

1596
01:00:29,730 --> 01:00:31,200


1597
01:00:31,200 --> 01:00:33,150
而现在 feminie 出现并

1598
01:00:33,150 --> 01:00:35,760
想要修改它 我们可能不得不

1599
01:00:35,760 --> 01:00:37,470
改变依赖或添加东西或

1600
01:00:37,470 --> 01:00:38,609
删除东西我们可能不得不重新

1601
01:00:38,609 --> 01:00:40,559
计算字典但如果数据很冷

1602
01:00:40,559 --> 01:00:43,130
并且这不会发生通常

1603
01:00:43,130 --> 01:00:45,500
增量编码是

1604
01:00:45,500 --> 01:00:48,329
我们会在字典中添加

1605
01:00:48,329 --> 01:00:50,940
一些额外的占位符的地方 我们

1606
01:00:50,940 --> 01:00:52,950
知道值可能出现的地方我们不

1607
01:00:52,950 --> 01:00:54,390
知道它们是什么但我们知道在我们的和我们

1608
01:00:54,390 --> 01:00:56,309
的顺序保存或他们的字典的顺序

1609
01:00:56,309 --> 01:00:57,869
去某些东西可以去那里

1610
01:00:57,869 --> 01:00:59,760
所以黄鼠狼留下一些额外的空间

1611
01:00:59,760 --> 01:01:01,410
当这些东西出现时我们可以

1612
01:01:01,410 --> 01:01:03,089
容纳 他们，在某些时候我们

1613
01:01:03,089 --> 01:01:04,559
仍然会满，然后在这种情况下，我们

1614
01:01:04,559 --> 01:01:06,119
必须

1615
01:01:06,119 --> 01:01:09,750
为字典范围再次重新计算字典

1616
01:01:09,750 --> 01:01:11,130
，我们之前讨论过这个问题

1617
01:01:11,130 --> 01:01:13,079
，但我们只是在块级别

1618
01:01:13,079 --> 01:01:14,730
上 取相同值的所有元组

1619
01:01:14,730 --> 01:01:17,880
并压缩它们，这

1620
01:01:17,880 --> 01:01:19,619
可能会降低压缩率

1621
01:01:19,619 --> 01:01:20,940
，然后是其他压缩率，因为

1622
01:01:20,940 --> 01:01:22,920
越独特，我们看到的重复值越多，压缩率

1623
01:01:22,920 --> 01:01:24,270
就越好

1624
01:01:24,270 --> 01:01:26,670
我们将得到的 ession ratio 和

1625
01:01:26,670 --> 01:01:28,109
同一个字典的副本越少，

1626
01:01:28,109 --> 01:01:30,450
我们一次又一次地得到风暴表级别

1627
01:01:30,450 --> 01:01:32,099
，我们将讨论

1628
01:01:32,099 --> 01:01:33,690
整个表的字典 这将是惊人的

1629
01:01:33,690 --> 01:01:35,220
压缩比，但这当然

1630
01:01:35,220 --> 01:01:36,390
会 更新很昂贵，因为

1631
01:01:36,390 --> 01:01:38,490
我需要插入很多东西

1632
01:01:38,490 --> 01:01:39,450
，我可能不得不重新计算

1633
01:01:39,450 --> 01:01:40,710
压缩率或压缩

1634
01:01:40,710 --> 01:01:42,420
字典，然后

1635
01:01:42,420 --> 01:01:44,880
多个表我们可以记录或

1636
01:01:44,880 --> 01:01:46,530
维护一个可以跨越

1637
01:01:46,530 --> 01:01:49,619
多个多个的字典 表，

1638
01:01:49,619 --> 01:01:51,150
如果你有喜欢的外键

1639
01:01:51,150 --> 01:01:52,829
，你就会这样做

1640
01:01:52,829 --> 01:01:54,990


1641
01:01:54,990 --> 01:01:56,369


1642
01:01:56,369 --> 01:01:58,140


1643
01:01:58,140 --> 01:01:59,160


1644
01:01:59,160 --> 01:02:00,210
相同的代码，你不必

1645
01:02:00,210 --> 01:02:01,680
解压缩它们来进行

1646
01:02:01,680 --> 01:02:04,650
比较，所以为了时间的缘故，让我跳过多 I 树

1647
01:02:04,650 --> 01:02:06,240
编码，但让我们

1648
01:02:06,240 --> 01:02:10,290
专注于顺序保存的东西，所以

1649
01:02:10,290 --> 01:02:11,579
我们已经讨论过了 通过这个我们

1650
01:02:11,579 --> 01:02:13,319
想要我们需要一个可以支持

1651
01:02:13,319 --> 01:02:16,049
编码和解码的字典正确的编码基本上

1652
01:02:16,049 --> 01:02:19,140
说对于给定的给定键，它的

1653
01:02:19,140 --> 01:02:20,730
未压缩将它转换为它的

1654
01:02:20,730 --> 01:02:22,530
压缩形式，然后

1655
01:02:22,530 --> 01:02:24,990
这正好相反，所以

1656
01:02:24,990 --> 01:02:26,190
要指出的主要事情 是没有

1657
01:02:26,190 --> 01:02:27,750
任何神奇的哈希函数我们可以

1658
01:02:27,750 --> 01:02:29,160
用来为我们做这件事我们

1659
01:02:29,160 --> 01:02:30,869
没有额外的数据结构

1660
01:02:30,869 --> 01:02:32,730
我们必须在我们的数据中计算

1661
01:02:32,730 --> 01:02:35,819
才能为我们做这件事，如果你有一个

1662
01:02:35,819 --> 01:02:37,440
哈希 可以使用它并且

1663
01:02:37,440 --> 01:02:39,990
仍然在幕后保持顺序

1664
01:02:39,990 --> 01:02:41,280
的函数实际上可以

1665
01:02:41,280 --> 01:02:43,650
正确实现的方式可能是一个

1666
01:02:43,650 --> 01:02:44,760
哈希表

1667
01:02:44,760 --> 01:02:47,490
只是一个字典所以我们避免所有

1668
01:02:47,490 --> 01:02:49,140
这些并自己构建字典

1669
01:02:49,140 --> 01:02:51,810
所以我们会这样做'

1670
01:02:51,810 --> 01:02:54,240
就像我已经说过的那样，如果

1671
01:02:54,240 --> 01:02:56,580
现在我有一个查询出现，就像查找

1672
01:02:56,580 --> 01:02:58,320
名称类似于 nd 的所有用户，

1673
01:02:58,320 --> 01:03:01,860
那么应用程序就可以执行此查询，

1674
01:03:01,860 --> 01:03:03,960
而不必扫描并

1675
01:03:03,960 --> 01:03:05,580
解压缩数据 d 应用这个

1676
01:03:05,580 --> 01:03:08,630
谓词

1677
01:03:08,630 --> 01:03:11,040
如果我

1678
01:03:11,040 --> 01:03:13,530
可以在 10 到 20 之间进行 Rhian 编码，我可以直接扫描字典 我可以

1679
01:03:13,530 --> 01:03:17,400
扫描压缩数据然后我可以

1680
01:03:17,400 --> 01:03:18,570
找出我真正想要查看的内容

1681
01:03:18,570 --> 01:03:19,620
，以便您实际保留的方式 你在

1682
01:03:19,620 --> 01:03:22,470
这个你做你喜欢在字典上的一个和 D

1683
01:03:22,470 --> 01:03:24,000
你首先

1684
01:03:24,000 --> 01:03:26,790
弄清楚之间的范围是什么，然后你

1685
01:03:26,790 --> 01:03:29,100
在这个上运行扫描，这样这个字典

1686
01:03:29,100 --> 01:03:31,050
就会公开或由数据系统本身维护，

1687
01:03:31,050 --> 01:03:33,120
这样它就可以运行 就像

1688
01:03:33,120 --> 01:03:35,100
对此进行初步查询以

1689
01:03:35,100 --> 01:03:37,530
找出压缩数据中实际可用的

1690
01:03:37,530 --> 01:03:40,740
内容

1691
01:03:40,740 --> 01:03:42,000
一样，您还可以做

1692
01:03:42,000 --> 01:03:44,490


1693
01:03:44,490 --> 01:03:47,130


1694
01:03:47,130 --> 01:03:49,440
其他事情 只需去字典

1695
01:03:49,440 --> 01:03:51,360
翻阅这部分 计算所有

1696
01:03:51,360 --> 01:03:53,220
这些或实际上知道有多少

1697
01:03:53,220 --> 01:03:54,390
字典条目

1698
01:03:54,390 --> 01:03:55,290
实际上已经足够好 因为

1699
01:03:55,290 --> 01:04:01,110
这些保证是唯一的

1700
01:04:01,110 --> 01:04:02,760
所以现在让我们看看我们是否有

1701
01:04:02,760 --> 01:04:04,230
像这样的查询我们已经可以

1702
01:04:04,230 --> 01:04:05,820
谈论这个问题是

1703
01:04:05,820 --> 01:04:07,500
在这种情况下我们是否有性能控制扫描

1704
01:04:07,500 --> 01:04:11,550
是因为我将匹配

1705
01:04:11,550 --> 01:04:13,770
字典但我需要找到

1706
01:04:13,770 --> 01:04:16,800
实际的元组是什么但在这个其他

1707
01:04:16,800 --> 01:04:18,240
示例中我 只是想获得

1708
01:04:18,240 --> 01:04:19,890
不同的名称 我不想要

1709
01:04:19,890 --> 01:04:21,450
解压器 我只需要访问

1710
01:04:21,450 --> 01:04:26,820
字典 是的，很好，你不断提出

1711
01:04:26,820 --> 01:04:28,470
这个问题，有些人可能会被删除

1712
01:04:28,470 --> 01:04:33,030
是的，所以如果我的字典在一个数据块上

1713
01:04:33,030 --> 01:04:34,890
，我说那个块 是不可变的，

1714
01:04:34,890 --> 01:04:43,350
那么有时也不能正确发生，

1715
01:04:43,350 --> 01:04:45,390
实际上也是除了代码之外，

1716
01:04:45,390 --> 01:04:49,050
您还可以使用此权限存储计数，

1717
01:04:49,050 --> 01:04:50,850
并且

1718
01:04:50,850 --> 01:04:52,860
每次我插入正确时维护起来都很便宜，是的，这样

1719
01:04:52,860 --> 01:04:54,360
您就可以做更多类似的事情

1720
01:04:54,360 --> 01:04:55,740
这有点像我们在开始时谈到的计算机前

1721
01:04:55,740 --> 01:04:57,120
聚合

1722
01:04:57,120 --> 01:04:58,040
的东西，所以我

1723
01:04:58,040 --> 01:05:00,200
对于这个值，这里

1724
01:05:00,200 --> 01:05:02,390
是我对某些查询的另一种情况，

1725
01:05:02,390 --> 01:05:05,840
我只是对字典进行操作，

1726
01:05:05,840 --> 01:05:06,920
所以 您可以为此使用不同的数据结构

1727
01:05:06,920 --> 01:05:10,130
，最简单

1728
01:05:10,130 --> 01:05:12,410
的只是一个数组，因此您拥有

1729
01:05:12,410 --> 01:05:14,030
所有这些非常构建的字符串，然后将

1730
01:05:14,030 --> 01:05:16,820
它们排序在一个数组中，字典

1731
01:05:16,820 --> 01:05:19,270
代码只是该数组的偏移量，

1732
01:05:19,270 --> 01:05:21,590
如果数据正常，这将再次起作用 不会

1733
01:05:21,590 --> 01:05:23,210


1734
01:05:23,210 --> 01:05:25,040
像他要问的那样一遍又一遍地修改，因为如果

1735
01:05:25,040 --> 01:05:26,540
我修改内容并添加一个新字符串，

1736
01:05:26,540 --> 01:05:28,640
那么现在所有设置都更改了，我

1737
01:05:28,640 --> 01:05:31,610
必须重新编码所有内容，所以这

1738
01:05:31,610 --> 01:05:33,710
实际上是我们今天在系统中所做

1739
01:05:33,710 --> 01:05:35,330
的 我们遵循 Apache 箭头

1740
01:05:35,330 --> 01:05:37,060
格式和 Apache 箭头

1741
01:05:37,060 --> 01:05:39,320
规范 Apache 箭头就像

1742
01:05:39,320 --> 01:05:42,710


1743
01:05:42,710 --> 01:05:45,380
内存中列存储 x' 的开源通用文件格式，我们的数据

1744
01:05:45,380 --> 01:05:48,020
基本上遵循此格式，因此我们以

1745
01:05:48,020 --> 01:05:49,460
这种方式进行字典编码，

1746
01:05:49,460 --> 01:05:50,660
即使其他编码方案可能

1747
01:05:50,660 --> 01:05:52,520
更好 Aero 只做字典

1748
01:05:52,520 --> 01:05:55,040
编码另一种方法你是否使用了

1749
01:05:55,040 --> 01:05:58,070
哈希表，所以这将是快速和

1750
01:05:58,070 --> 01:05:59,990
紧凑的查找

1751
01:05:59,990 --> 01:06:00,980
问题虽然你不是 goi  ng

1752
01:06:00,980 --> 01:06:02,210
支持范围查询或前缀查询，

1753
01:06:02,210 --> 01:06:03,830
因为您不会

1754
01:06:03,830 --> 01:06:05,330
轻易地轻松扫描所有值，

1755
01:06:05,330 --> 01:06:06,710
因为一切都

1756
01:06:06,710 --> 01:06:09,650
将被散列，然后另一种

1757
01:06:09,650 --> 01:06:11,990
方法是使用 B+ 树，因此这

1758
01:06:11,990 --> 01:06:13,340
将比哈希表慢 在数组中

1759
01:06:13,340 --> 01:06:15,170
并可能占用更多内存，

1760
01:06:15,170 --> 01:06:17,030
但这将支持

1761
01:06:17,030 --> 01:06:20,120
您可能想要做的前缀查询范围，

1762
01:06:20,120 --> 01:06:23,110
据我所知，大多数系统都

1763
01:06:23,110 --> 01:06:28,000
在这里做第一个我只知道

1764
01:06:28,000 --> 01:06:30,500
有一个专利 特别的想法，

1765
01:06:30,500 --> 01:06:31,670
所以我不知道还有谁真正使用了

1766
01:06:31,670 --> 01:06:34,340
这种方法，是的，大多数

1767
01:06:34,340 --> 01:06:36,140
时候你都在压缩冷数据，所以

1768
01:06:36,140 --> 01:06:38,840
这个已经足够了，让我们看看

1769
01:06:38,840 --> 01:06:40,730
你到底想如何做到这一点，所以这个

1770
01:06:40,730 --> 01:06:43,250
想法基本上是你必须要做的 加上

1771
01:06:43,250 --> 01:06:45,890
树，你有 1/2 编码，它是

1772
01:06:45,890 --> 01:06:47,330
正面朝上的，然后你有 1 个进行

1773
01:06:47,330 --> 01:06:50,000
解码，这是颠倒的，所以你

1774
01:06:50,000 --> 01:06:51,410
可以在两个方向上前进，然后

1775
01:06:51,410 --> 01:06:53,570
在中间它们会共享

1776
01:06:53,570 --> 01:06:56,060
要映射的叶子 代码的值或

1777
01:06:56,060 --> 01:06:57,770
他们可以使用它来对值进行反向映射代码

1778
01:06:57,770 --> 01:07:00,290
，所以这是我

1779
01:07:00,290 --> 01:07:01,970
最短的共享叶子，如果我有一个

1780
01:07:01,970 --> 01:07:03,680
像土著字符串这样的值版本我

1781
01:07:03,680 --> 01:07:05,300
想要我想对它进行编码然后我通过

1782
01:07:05,300 --> 01:07:08,720
这个索引我在我的 叶节点

1783
01:07:08,720 --> 01:07:10,820
找到我想要的条目，然后我

1784
01:07:10,820 --> 01:07:11,609
会产生

1785
01:07:11,609 --> 01:07:13,589
值，但是如果我有一个编码

1786
01:07:13,589 --> 01:07:15,660
值，我使用底部的值做同样的

1787
01:07:15,660 --> 01:07:16,650
事情，但在反向中

1788
01:07:16,650 --> 01:07:17,729
，然后我可以吐出

1789
01:07:17,729 --> 01:07:20,640
原始值是什么以及在内部它们是什么

1790
01:07:20,640 --> 01:07:21,630
' 重新要做的是他们将使用

1791
01:07:21,630 --> 01:07:22,739
我们之前讨论过的增量编码，

1792
01:07:22,739 --> 01:07:25,079
因为在节点内再次

1793
01:07:25,079 --> 01:07:26,729
会有排序值，并且

1794
01:07:26,729 --> 01:07:28,499
他们经常会

1795
01:07:28,499 --> 01:07:30,239
一遍又一遍地重复相同的前缀，所以我

1796
01:07:30,239 --> 01:07:33,119
甚至可以将它们压缩 此外

1797
01:07:33,119 --> 01:07:34,709
，在我的示例中，他们还将做的另一件事是

1798
01:07:34,709 --> 01:07:36,539
，代码是 10 20 30

1799
01:07:36,539 --> 01:07:38,930
40，因此他们将

1800
01:07:38,930 --> 01:07:41,400
在代码范围之间留下间隙，以便如果

1801
01:07:41,400 --> 01:07:43,529
出现新元组或新条目，则

1802
01:07:43,529 --> 01:07:46,979
介于 aaaaa 之间 B 和 ae 我可以插入

1803
01:07:46,979 --> 01:07:49,259
一个 ne 这里的那个家伙给它代码 11，而

1804
01:07:49,259 --> 01:07:51,809
不必在我

1805
01:07:51,809 --> 01:07:53,999
用完它们之间的空间后立即重新编码所有内容，然后

1806
01:07:53,999 --> 01:07:56,989
我游戏就结束了，我的每一个开始都

1807
01:07:56,989 --> 01:07:59,729
很好，所以关于字典

1808
01:07:59,729 --> 01:08:13,680
编码的任何问题都有点快是的，是的，

1809
01:08:13,680 --> 01:08:17,189
是的 这个例子是，

1810
01:08:17,189 --> 01:08:20,250
这里的这个我有一个 AE 所以我知道

1811
01:08:20,250 --> 01:08:22,770
这些键之间可能存在键的数量，

1812
01:08:22,770 --> 01:08:24,420
因此我可以用

1813
01:08:24,420 --> 01:08:26,939
这种方式把它拍出来，你可以这样做我不认为

1814
01:08:26,939 --> 01:08:31,109
他们会这样做，虽然是的，就像如果 你

1815
01:08:31,109 --> 01:08:32,549
知道它只能是三个字符

1816
01:08:32,549 --> 01:08:35,790
那么没关系如果你有如果

1817
01:08:35,790 --> 01:08:37,529
它长于三个那么我

1818
01:08:37,529 --> 01:08:43,710
喜欢它可以无限好所以很快

1819
01:08:43,710 --> 01:08:45,060
我将谈论如何进行索引

1820
01:08:45,060 --> 01:08:49,198
压缩所以我说了我们的一切

1821
01:08:49,198 --> 01:08:50,429
今天在这里讨论的是

1822
01:08:50,429 --> 01:08:52,290
你所见过的 OLAP 常见表达式

1823
01:08:52,290 --> 01:08:53,790
，大多数情况下，这是

1824
01:08:53,790 --> 01:08:56,609
最常见的事情，但对于 OHP 工作

1825
01:08:56,609 --> 01:08:58,738
负载，索引本身实际上也可以

1826
01:08:58,738 --> 01:09:01,439
占用大量空间，所以

1827
01:09:01,439 --> 01:09:03,540
这是我们所做的一项研究 我们

1828
01:09:03,540 --> 01:09:05,069
写了一篇论文 几年前，我们采用了一些

1829
01:09:05,069 --> 01:09:07,679
开源基准测试 TPCC 文章

1830
01:09:07,679 --> 01:09:08,819
认为这就像黑客新闻或

1831
01:09:08,819 --> 01:09:10,529
Reddit 就像人们推送文章

1832
01:09:10,529 --> 01:09:12,750
然后人们写评论

1833
01:09:12,750 --> 01:09:15,149
然后投票者它来自两个数据库 这

1834
01:09:15,149 --> 01:09:18,599
是说日本版的美国

1835
01:09:18,599 --> 01:09:19,889
偶像它是 就像当人们打电话给他们

1836
01:09:19,889 --> 01:09:21,540
进行投票时，当有人喜欢

1837
01:09:21,540 --> 01:09:23,939
执行此基准测试时会模仿

1838
01:09:23,939 --> 01:09:25,380
您窃笑，但他们将

1839
01:09:25,380 --> 01:09:27,750
两者都卖了很多，就像它

1840
01:09:27,750 --> 01:09:29,460
运行日本版美国

1841
01:09:29,460 --> 01:09:30,960
偶像它运行加拿大版

1842
01:09:30,960 --> 01:09:33,479
美国偶像我一样 认为在马来西亚没有人

1843
01:09:33,479 --> 01:09:36,510
它运行起来就像它被

1844
01:09:36,510 --> 01:09:39,689
使用了很多 嗯我是基于这个权利被聘用的

1845
01:09:39,689 --> 01:09:43,710
所以呃所以

1846
01:09:43,710 --> 01:09:46,529
这些基准的原始大号我所有

1847
01:09:46,529 --> 01:09:48,330
这些指数本身都在

1848
01:09:48,330 --> 01:09:51,810
上涨 数据，所以我们

1849
01:09:51,810 --> 01:09:53,609
不能使用我们目前讨论的数据库压缩的东西，

1850
01:09:53,609 --> 01:09:54,780
我们

1851
01:09:54,780 --> 01:09:57,300
不能压缩元组，因为它是 OTP，我们可以

1852
01:09:57,300 --> 01:09:59,640
随时修改任何东西，所以我们

1853
01:09:59,640 --> 01:10:01,380
不能压缩这部分，但这里是 al  l

1854
01:10:01,380 --> 01:10:02,760
我们也可以潜在地

1855
01:10:02,760 --> 01:10:06,690
压缩的其他数据，因此

1856
01:10:06,690 --> 01:10:09,720
在 X 压缩中最常用的两种技术是

1857
01:10:09,720 --> 01:10:11,160
进行前缀压缩和后缀

1858
01:10:11,160 --> 01:10:13,620
截断，这看起来很像

1859
01:10:13,620 --> 01:10:14,550
我们在进行大量排序之前已经讨论过的东西

1860
01:10:14,550 --> 01:10:16,290
数据

1861
01:10:16,290 --> 01:10:19,650
和我们的节点中，然后我们

1862
01:10:19,650 --> 01:10:20,880
一遍又一遍地重复值，所以我们不是

1863
01:10:20,880 --> 01:10:23,670
重复存储整个值，而是

1864
01:10:23,670 --> 01:10:25,920
销毁一次前缀，然后只销毁

1865
01:10:25,920 --> 01:10:27,060
实际上不同的后缀部分，

1866
01:10:27,060 --> 01:10:30,930
这实际上是

1867
01:10:30,930 --> 01:10:32,340
最多的评论，你 将

1868
01:10:32,340 --> 01:10:33,600
一直在支持 PBX 压缩的 B 加树中看到这

1869
01:10:33,600 --> 01:10:35,250


1870
01:10:35,250 --> 01:10:37,170
一点，无论

1871
01:10:37,170 --> 01:10:39,300
叶节点是否被压缩，或者

1872
01:10:39,300 --> 01:10:40,980
只是节点间，或者取决于

1873
01:10:40,980 --> 01:10:42,180
特尼认为的工作负载类型，他们现在都会做这样

1874
01:10:42,180 --> 01:10:44,310
的事情。 很多时候你知道大部分

1875
01:10:44,310 --> 01:10:45,750
更新都是对 B+ 树做的，

1876
01:10:45,750 --> 01:10:47,370
你总是会成为叶节点，所以

1877
01:10:47,370 --> 01:10:48,450
也许你不压缩那部分，

1878
01:10:48,450 --> 01:10:49,440
因为这件事会一直

1879
01:10:49,440 --> 01:10:51,150
改变，但是 对于内部节点和

1880
01:10:51,150 --> 01:10:52,530
上面的节点，您可以

1881
01:10:52,530 --> 01:10:57,570
压制那些是的，这个问题是

1882
01:10:57,570 --> 01:10:59,610
基数树的 B+ 树近似值

1883
01:10:59,610 --> 01:11:05,550
是的，这是考虑它的一种方式，

1884
01:11:05,550 --> 01:11:08,280
但同样不同的是

1885
01:11:08,280 --> 01:11:11,340
，这些关键在于 这如果

1886
01:11:11,340 --> 01:11:12,450
这是人们树中的内部节点，

1887
01:11:12,450 --> 01:11:13,890
这些键实际上可能不存在

1888
01:11:13,890 --> 01:11:18,570
右后缀截断，这里的想法

1889
01:11:18,570 --> 01:11:20,610
是对于节点间我们

1890
01:11:20,610 --> 01:11:23,730
可能不正确存储整个键我们

1891
01:11:23,730 --> 01:11:25,650
只是存储我们只是扔掉的

1892
01:11:25,650 --> 01:11:27,630
后缀词对我们没有帮助，

1893
01:11:27,630 --> 01:11:29,760
只在这种情况下存储前缀，

1894
01:11:29,760 --> 01:11:33,450
这两个键需要这

1895
01:11:33,450 --> 01:11:35,520
两个键，它们

1896
01:11:35,520 --> 01:11:37,170
在第一个字符 a 和 B 之后是唯一的，所以我

1897
01:11:37,170 --> 01:11:38,580
正在寻找

1898
01:11:38,580 --> 01:11:40,680
更大的东西 比 a 然后我知道我想去

1899
01:11:40,680 --> 01:11:41,820
一侧 我正在寻找

1900
01:11:41,820 --> 01:11:43,410
小于 a 的东西 或者我去另一

1901
01:11:43,410 --> 01:11:46,620
侧 好吧，这样我就可以摧毁 abc

1902
01:11:46,620 --> 01:11:48,930
和 l MN，这足以让我

1903
01:11:48,930 --> 01:11:50,730
区分我想走哪条路 下来

1904
01:11:50,730 --> 01:11:54,950
，这可以减少 t 他的空间

1905
01:11:54,950 --> 01:11:57,420
可以很快回到这个空间我正在

1906
01:11:57,420 --> 01:11:58,950
缩短压缩键，

1907
01:11:58,950 --> 01:12:01,020


1908
01:12:01,020 --> 01:12:02,250
如果您知道两个

1909
01:12:02,250 --> 01:12:03,960
弓是同一个块，那么您还

1910
01:12:03,960 --> 01:12:05,250
可以压缩指向元组的指针的值，而不是对块 ID 进行排序

1911
01:12:05,250 --> 01:12:07,500
破坏这样的偏移量 那个

1912
01:12:07,500 --> 01:12:08,700
在被置换的主义中更常见的我

1913
01:12:08,700 --> 01:12:09,900
不知道任何内存

1914
01:12:09,900 --> 01:12:12,000
系统会这样做而且我不知道任何 MIDI

1915
01:12:12,000 --> 01:12:13,500
Mr Justice 一个好的前缀压缩

1916
01:12:13,500 --> 01:12:16,890
是更常见的一个，好吧最后

1917
01:12:16,890 --> 01:12:18,300
我们将讨论的是我们

1918
01:12:18,300 --> 01:12:20,430
为混合索引写的一篇论文，

1919
01:12:20,430 --> 01:12:23,040
这里的想法只是让您

1920
01:12:23,040 --> 01:12:24,960
了解我们可以压缩的其他内容的其他技术，

1921
01:12:24,960 --> 01:12:27,870
而不仅仅是数据，以便我们可以

1922
01:12:27,870 --> 01:12:29,670
压缩索引中的键，我们可以

1923
01:12:29,670 --> 01:12:31,710
按下 索引中的值但是

1924
01:12:31,710 --> 01:12:32,940
如果我们实际上也可以压缩

1925
01:12:32,940 --> 01:12:35,730
数据结构本身但是

1926
01:12:35,730 --> 01:12:38,940
我们维护的内部元数据表明这

1927
01:12:38,940 --> 01:12:43,050
实际上是一个 B+ 流 那么我们

1928
01:12:43,050 --> 01:12:44,700
现在要做的是它会称之为混合

1929
01:12:44,700 --> 01:12:47,100
索引 会有一个unco

1930
01:12:47,100 --> 01:12:48,690
再次压缩索引和压缩索引 这

1931
01:12:48,690 --> 01:12:49,860
看起来很像

1932
01:12:49,860 --> 01:12:50,820
我们为

1933
01:12:50,820 --> 01:12:54,000
列存储上一课讨论的分数镜像内容，因此

1934
01:12:54,000 --> 01:12:55,560
我们快速更新的动态索引是未压缩的

1935
01:12:55,560 --> 01:12:58,350
，然后随着数据变旧我们将其

1936
01:12:58,350 --> 01:13:00,360
转换为压缩 索引将

1937
01:13:00,360 --> 01:13:02,250
是只读的，然后每隔一段时间

1938
01:13:02,250 --> 01:13:04,500
我们就会通过

1939
01:13:04,500 --> 01:13:06,660
合并

1940
01:13:06,660 --> 01:13:08,730
从前端到前端索引到

1941
01:13:08,730 --> 01:13:11,250
后端的更改来刷新静态阶段，所以它看起来像这样，所以我们所有

1942
01:13:11,250 --> 01:13:13,170
的插入更新 泄漏转到动态

1943
01:13:13,170 --> 01:13:15,930
动态索引，然后随着时间的推移将

1944
01:13:15,930 --> 01:13:17,730
与压缩的静态索引合并，

1945
01:13:17,730 --> 01:13:20,040
但随后我们还将维护

1946
01:13:20,040 --> 01:13:21,450
此布隆过滤器，以便在进行

1947
01:13:21,450 --> 01:13:23,610
查找时检查布隆过滤器以查看

1948
01:13:23,610 --> 01:13:25,170
它是否是我们的东西 重新寻找

1949
01:13:25,170 --> 01:13:27,870
它可能在我们的动态索引中，如果是，

1950
01:13:27,870 --> 01:13:30,060
那么我们去检查一下，如果不是蓝色

1951
01:13:30,060 --> 01:13:32,880
过滤器返回告诉我们错误，那么我们

1952
01:13:32,880 --> 01:13:34,320
总是去检查静态索引，并且

1953
01:13:34,320 --> 01:13:36,300
有一种声音可以原谅

1954
01:13:36,300 --> 01:13:38,490
我任何假阴性，所以每个人都 应该

1955
01:13:38,490 --> 01:13:41,310
把布隆放在那里 谁不

1956
01:13:41,310 --> 01:13:44,180
知道布隆过滤器是什么

1957
01:13:45,250 --> 01:13:50,260
是的 肯定是这样做的 是的 你不

1958
01:13:50,260 --> 01:13:53,080
知道其他人是什么 好吧 我会

1959
01:13:53,080 --> 01:13:59,770
在 30 秒内给你一个速成课程 好吧 所以布隆

1960
01:13:59,770 --> 01:14:01,120
过滤器是一个近似值

1961
01:14:01,120 --> 01:14:03,220
回答集合成员资格查询的数据结构

1962
01:14:03,220 --> 01:14:04,810
它会告诉你

1963
01:14:04,810 --> 01:14:07,570
我的集合中是否存在一个键，但它可能会给你

1964
01:14:07,570 --> 01:14:09,340
误报它永远不会告诉你某些东西

1965
01:14:09,340 --> 01:14:11,260
不存在但它

1966
01:14:11,260 --> 01:14:13,150
可能会告诉你某些东西确实存在 当

1967
01:14:13,150 --> 01:14:15,580
它实际上不存在时，认为

1968
01:14:15,580 --> 01:14:18,190
它只是一个位图，我们将不得不

1969
01:14:18,190 --> 01:14:20,890
在我们的键上获取一个散列函数，或者

1970
01:14:20,890 --> 01:14:22,690
多次对它进行散列并

1971
01:14:22,690 --> 01:14:24,220
更新不同的位，这就是我们

1972
01:14:24,220 --> 01:14:26,800
记录某些东西是否存在正确的方式

1973
01:14:26,800 --> 01:14:28,510
我们唯一能做的就是插入和

1974
01:14:28,510 --> 01:14:29,800
查找我们实际上不能删除

1975
01:14:29,800 --> 01:14:31,600
我们不能做任何范围查询的东西所以这是

1976
01:14:31,600 --> 01:14:34,210
我的超级简单的布隆过滤器所以说我

1977
01:14:34,210 --> 01:14:36,190
想插入来自木桐家族的 RZA

1978
01:14:36,190 --> 01:14:38,650
我有两个哈希函数我

1979
01:14:38,650 --> 01:14:40,360
拿钥匙我散列它我被修改的数量

1980
01:14:40,360 --> 01:14:41,920
我拥有的位然后我将这些

1981
01:14:41,920 --> 01:14:44,290
位翻转为 1 现在我为 GZA 执行此操作

1982
01:14:44,290 --> 01:14:47,320


1983
01:14:47,320 --> 01:14:49,330


1984
01:14:49,330 --> 01:14:51,100


1985
01:14:51,100 --> 01:14:54,160
做同样的

1986
01:14:54,160 --> 01:14:56,770
事情拿钥匙传递然后我做我的查找

1987
01:14:56,770 --> 01:14:59,530
如果这些位置中的所有位置

1988
01:14:59,530 --> 01:15:01,120
所有位置这些位都设置为

1989
01:15:01,120 --> 01:15:03,990
1 然后我知道这件事可能存在

1990
01:15:03,990 --> 01:15:07,750
正确和正确的情况下 Raekwon

1991
01:15:07,750 --> 01:15:11,290
现在散列他一个 的位设置为 0，所以

1992
01:15:11,290 --> 01:15:12,700
我知道这件事不可能绝对

1993
01:15:12,700 --> 01:15:14,710
不存在，但是

1994
01:15:14,710 --> 01:15:16,000
如果我使用 ODB 进行查找，您可能会再次得到假阴性，

1995
01:15:16,000 --> 01:15:19,060
然后散列会将我带到

1996
01:15:19,060 --> 01:15:20,410
值得设置的位，但我从未真正

1997
01:15:20,410 --> 01:15:22,510
插入过这个 所以它告诉我这个

1998
01:15:22,510 --> 01:15:24,790
密钥存在时它实际上并不存在所以

1999
01:15:24,790 --> 01:15:26,920
在我回到我的例子中

2000
01:15:26,920 --> 01:15:29,980
你现在可以了所以回到我

2001
01:15:29,980 --> 01:15:33,160
之前的例子如果我使用这个布隆

2002
01:15:33,160 --> 01:15:36,130
过滤器它可以告诉我

2003
01:15:36,130 --> 01:15:37,570
这个动态中存在某些东西 索引但它

2004
01:15:37,570 --> 01:15:38,620
实际上并不存在，因为我已经有了

2005
01:15:38,620 --> 01:15:40,540
我 把它恢复到静态阶段，

2006
01:15:40,540 --> 01:15:42,370
但这没关系，因为你知道我也许我

2007
01:15:42,370 --> 01:15:44,290
在这里查了一下，但它被浪费了，但我永远

2008
01:15:44,290 --> 01:15:46,060
不会说这东西不存在我去

2009
01:15:46,060 --> 01:15:48,070
这里看看，但我看不到它

2010
01:15:48,070 --> 01:15:50,440
实际上存在于那里，所以

2011
01:15:50,440 --> 01:15:52,030
除了很好地压缩密钥之外，你怎么能压缩 B+ 树呢？

2012
01:15:52,030 --> 01:15:54,040
第一

2013
01:15:54,040 --> 01:15:56,410
件事是因为我们

2014
01:15:56,410 --> 01:15:57,580
对 B 加树有这个规则，他们说它们

2015
01:15:57,580 --> 01:15:59,020
必须至少是半满的，我们

2016
01:15:59,020 --> 01:16:00,040
不，我们要 有一堆空

2017
01:16:00,040 --> 01:16:03,070
槽，所以如果我们的索引永远不会被

2018
01:16:03,070 --> 01:16:03,670
更新，

2019
01:16:03,670 --> 01:16:05,050
我们实际上永远不需要这些空

2020
01:16:05,050 --> 01:16:07,030
槽，所以我们现在我们可以压缩每个

2021
01:16:07,030 --> 01:16:08,860
节点以只存储存在的

2022
01:16:08,860 --> 01:16:11,560
键，但接下来的事情

2023
01:16:11,560 --> 01:16:12,850
是 我们现在有了这些指针，

2024
01:16:12,850 --> 01:16:14,350
因为它们只是

2025
01:16:14,350 --> 01:16:16,300
堆中的随机节点，所以这些可能是

2026
01:16:16,300 --> 01:16:18,010
指向内存中某个位置的 64 位指针，

2027
01:16:18,010 --> 01:16:20,140


2028
01:16:20,140 --> 01:16:21,820


2029
01:16:21,820 --> 01:16:25,450
如果我们只是对某个起始点有一个偏移量，那么就不会将这些指针全部存储

2030
01:16:25,450 --> 01:16:28,000
在一个数组中的位置然后我们可以

2031
01:16:28,000 --> 01:16:29,560


2032
01:16:29,560 --> 01:16:31,270
如果这些是单独的节点，则跳到我们应该在的位置，

2033
01:16:31,270 --> 01:16:31,930


2034
01:16:31,930 --> 01:16:33,580
即使它是一个可以检查您是否知道

2035
01:16:33,580 --> 01:16:37,360
容器的内存块，这样

2036
01:16:37,360 --> 01:16:38,860
您就可以压缩 B+ 树，您可以

2037
01:16:38,860 --> 01:16:41,080
对跳过列表

2038
01:16:41,080 --> 01:16:43,390
执行相同的操作 Mew 相同 艺术索引的事情

2039
01:16:43,390 --> 01:16:45,520
再次认识到我们永远

2040
01:16:45,520 --> 01:16:46,960
不会更新索引我们系统或索引中的所有这些额外的

2041
01:16:46,960 --> 01:16:48,640
东西，

2042
01:16:48,640 --> 01:16:50,740
以便我们可以容纳更新

2043
01:16:50,740 --> 01:16:52,600
是不必要的，我们可以将它们

2044
01:16:52,600 --> 01:16:55,690
全部丢弃并压缩它 因此，

2045
01:16:55,690 --> 01:16:58,780
就其大小而言，您可以

2046
01:16:58,780 --> 01:17:00,640
使用混合索引获得此吞吐量成员共振峰，结果

2047
01:17:00,640 --> 01:17:02,440
实际上更快，因为

2048
01:17:02,440 --> 01:17:03,970
有一个产品更小，

2049
01:17:03,970 --> 01:17:05,400
因此您的缓存未命中更少

2050
01:17:05,400 --> 01:17:08,200
，然后整体大小也减少了

2051
01:17:08,200 --> 01:17:11,380
很多，所以再次 这是

2052
01:17:11,380 --> 01:17:13,420
一篇我们几年前写的发布 sigmod 的论文，

2053
01:17:13,420 --> 01:17:15,400
实际上没有系统

2054
01:17:15,400 --> 01:17:17,590
会这样做，但我认为

2055
01:17:17,590 --> 01:17:20,620


2056
01:17:20,620 --> 01:17:22,390
当您知道元组 ar 时，这些技术可以再次应用于列存储系统中

2057
01:17:22,390 --> 01:17:26,830
不会被修改是的问题

2058
01:17:26,830 --> 01:17:28,000


2059
01:17:28,000 --> 01:17:31,360
如果你有多个阶段，

2060
01:17:31,360 --> 01:17:33,100
你是否为每个阶段有一个单独的

2061
01:17:33,100 --> 01:17:35,830
布隆过滤器

2062
01:17:35,830 --> 01:17:37,510


2063
01:17:37,510 --> 01:17:39,910
每个那里你都不

2064
01:17:39,910 --> 01:17:41,620
需要静态的，因为

2065
01:17:41,620 --> 01:17:43,270
这是说这是一个查询显示

2066
01:17:43,270 --> 01:17:46,360
我是否需要阅读这个是或否，

2067
01:17:46,360 --> 01:17:47,560
蓝色仪表告诉我是否需要这样做

2068
01:17:47,560 --> 01:17:49,480
，这个想法是 那是因为我说

2069
01:17:49,480 --> 01:17:51,370


2070
01:17:51,370 --> 01:17:53,320
随着时间的推移我做了很多插入到我的动态索引中 我想然后将它合并所有

2071
01:17:53,320 --> 01:17:55,270
那些现在存在于静态方面的键

2072
01:17:55,270 --> 01:17:56,470
他们不再存在在这里 这东西

2073
01:17:56,470 --> 01:17:58,950
变成了空洞的

2074
01:17:58,950 --> 01:18:00,790
问题 为什么我们不只是内部

2075
01:18:00,790 --> 01:18:06,370
因为 我们还有其他问题是的，我

2076
01:18:06,370 --> 01:18:10,780
也说我们

2077
01:18:10,780 --> 01:18:13,390
没有多线程线程安全

2078
01:18:13,390 --> 01:18:16,180
合并算法我们在 HD 或 HD

2079
01:18:16,180 --> 01:18:18,190
或单线程引擎中执行此操作，因此

2080
01:18:18,190 --> 01:18:19,930
我们会停止所有 我们

2081
01:18:19,930 --> 01:18:22,060
合并时的交易因为否则你必须喜欢

2082
01:18:22,060 --> 01:18:23,410
合并这个 并担心人们

2083
01:18:23,410 --> 01:18:25,180
同时阅读或让我制作

2084
01:18:25,180 --> 01:18:26,800
两份副本，这会变得昂贵，

2085
01:18:26,800 --> 01:18:28,560
因为他们可以得到很大的

2086
01:18:28,560 --> 01:18:31,270
好的，所以匆忙结束我

2087
01:18:31,270 --> 01:18:33,730
道歉，但开始希望

2088
01:18:33,730 --> 01:18:35,520
你从中得到的主要收获是

2089
01:18:35,520 --> 01:18:37,870
嘿，数据库系统知道数据是什么

2090
01:18:37,870 --> 01:18:39,100
样子 它知道类型

2091
01:18:39,100 --> 01:18:40,780
是什么 它知道查询将如何

2092
01:18:40,780 --> 01:18:42,490
访问它们 现在可以

2093
01:18:42,490 --> 01:18:43,930
就如何压缩数据做出更好的决定，

2094
01:18:43,930 --> 01:18:45,700
超出我的能力，即压缩

2095
01:18:45,700 --> 01:18:47,950
方案可以做的正确，我们 展示了我们

2096
01:18:47,950 --> 01:18:50,830
可以做什么我们可以应用我们可以

2097
01:18:50,830 --> 01:18:52,750
对已经压缩的数据应用压缩，

2098
01:18:52,750 --> 01:18:55,720
就像对增量编码进行 RLE 并获得

2099
01:18:55,720 --> 01:18:57,730
更好的压缩率

2100
01:18:57,730 --> 01:19:00,730
，然后我们讨论了如何

2101
01:19:00,730 --> 01:19:02,110
在查询执行期间尽可能长时间等待，

2102
01:19:02,110 --> 01:19:03,760
然后我们必须

2103
01:19:03,760 --> 01:19:05,290
仅当我们告诉

2104
01:19:05,290 --> 01:19:07,060
外界这里是查询的答案时才解压缩数据，然后

2105
01:19:07,060 --> 01:19:09,250
理想情况下，我们必须将其解压缩以进行

2106
01:19:09,250 --> 01:19:12,460
连接，如果

2107
01:19:12,460 --> 01:19:13,510
您要连接两件事，我们将在本学期晚些时候看到 被

2108
01:19:13,510 --> 01:19:14,890
压缩并且他们自己的一本不同的

2109
01:19:14,890 --> 01:19:16,510
字典你必须压缩

2110
01:19:16,510 --> 01:19:17,740
一个并可能重新编码另一个

2111
01:19:17,740 --> 01:19:19,180
这会变得昂贵但这是

2112
01:19:19,180 --> 01:19:22,660
不可避免的好吧所以下周

2113
01:19:22,660 --> 01:19:24,580
我们将讨论我们开始的一个

2114
01:19:24,580 --> 01:19:27,970
星期三今天的星期三谢谢你

2115
01:19:27,970 --> 01:19:32,280
是的好吧 这很艰难

2116
01:19:32,280 --> 01:19:34,510
好吧好吧宝贝

2117
01:19:34,510 --> 01:19:36,550
所以周一谢谢你周一我们将

2118
01:19:36,550 --> 01:19:37,930
讨论记录检查点所以现在

2119
01:19:37,930 --> 01:19:39,070
即使我们在内存数据库中我们仍然

2120
01:19:39,070 --> 01:19:40,360
需要能够在崩溃后恢复

2121
01:19:40,360 --> 01:19:42,430
所以我不得不将内容写到磁盘

2122
01:19:42,430 --> 01:19:43,840
并尽快通过检查站

2123
01:19:43,840 --> 01:19:44,850


2124
01:19:44,850 --> 01:19:48,250
好吧 周末愉快 再见

2125
01:19:48,250 --> 01:19:50,440
把它存到边上的公园 这是什么

2126
01:19:50,440 --> 01:19:53,280
一些

2127
01:19:53,280 --> 01:19:55,949


2128
01:19:55,949 --> 01:19:58,829


2129
01:19:58,829 --> 01:20:02,159
傻瓜 嗨，你看，它是去

2130
01:20:02,159 --> 01:20:04,949
给我拿 40 只为了得到我的嗡嗡声因为我

2131
01:20:04,949 --> 01:20:07,199
只需要像鱼一样多踢一点，

2132
01:20:07,199 --> 01:20:09,750
然后把它放在我的

2133
01:20:09,750 --> 01:20:12,510
嘴唇上，然后把卡车的顶部从卡车上撕下来，

2134
01:20:12,510 --> 01:20:15,690
就像热的一样，我的 引擎盖要我 s 是的，

2135
01:20:15,690 --> 01:20:20,389
我很高兴坐下来祈祷

