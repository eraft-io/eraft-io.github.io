1
00:00:01,300 --> 00:00:05,129
[音乐]

2
00:00:05,200 --> 00:00:05,930
[掌声]

3
00:00:05,930 --> 00:00:08,630
[音乐]

4
00:00:08,630 --> 00:00:10,020
[掌声]

5
00:00:10,020 --> 00:00:12,170
[音乐

6
00:00:12,170 --> 00:00:18,330
] 是的，好的，所以今天我们谈论的

7
00:00:18,330 --> 00:00:21,449
是 MVCC 多版本控制，所以

8
00:00:21,449 --> 00:00:23,130
这实际上是

9
00:00:23,130 --> 00:00:25,500
三部分讲座或三部分系列的第一部分

10
00:00:25,500 --> 00:00:27,750
，我们在这里

11
00:00:27,750 --> 00:00:29,130
将比我们在中断课程中更详细地

12
00:00:29,130 --> 00:00:30,390


13
00:00:30,390 --> 00:00:31,430
讨论您如何

14
00:00:31,430 --> 00:00:34,290
在现代系统上实现 MVC

15
00:00:34,290 --> 00:00:36,030
我们只是在高层次上反对同一页面上的每个人

16
00:00:36,030 --> 00:00:38,579
什么多

17
00:00:38,579 --> 00:00:42,540
版本控制 是不是

18
00:00:42,540 --> 00:00:44,730
协议的特定招致，但它是

19
00:00:44,730 --> 00:00:48,030
一种设计数据库系统的方式，

20
00:00:48,030 --> 00:00:49,860
您将在其中维护数据库

21
00:00:49,860 --> 00:00:53,670
中单个逻辑对象的多个物理版本

22
00:00:53,670 --> 00:00:56,190
，因此通过对象，我在

23
00:00:56,190 --> 00:00:58,050
这里含糊其辞

24
00:00:58,050 --> 00:01:00,750
可以是表 可以是元组块

25
00:01:00,750 --> 00:01:02,730
单个元组 甚至可以是元组中的单个

26
00:01:02,730 --> 00:01:04,979
属性 并且实践中

27
00:01:04,979 --> 00:01:07,260
大多数人只是在每个表的基础上执行此操作，

28
00:01:07,260 --> 00:01:09,360
但同样的想法是

29
00:01:09,360 --> 00:01:11,010
对于单个元组 我们从中看到的逻辑对象

30
00:01:11,010 --> 00:01:13,549
从应用程序的角度来看，

31
00:01:13,549 --> 00:01:16,140
我们将在幕后拥有多个物理

32
00:01:16,140 --> 00:01:18,450
版本，因此

33
00:01:18,450 --> 00:01:19,830
当事务

34
00:01:19,830 --> 00:01:21,570
写入对象或不

35
00:01:21,570 --> 00:01:24,330
更新对象时会发生什么，而不是覆盖

36
00:01:24,330 --> 00:01:27,270
现有值的原始值。

37
00:01:27,270 --> 00:01:29,009
创建一个新

38
00:01:29,009 --> 00:01:31,049
版本，这个新版本将进行

39
00:01:31,049 --> 00:01:33,659
我们刚刚再次进行的更改，我们

40
00:01:33,659 --> 00:01:35,159
的想法是我们必须跟踪

41
00:01:35,159 --> 00:01:38,990
是的，请原谅，

42
00:01:40,040 --> 00:01:42,750
我们稍后会修复该修复的内容

43
00:01:42,750 --> 00:01:45,240
，下一次修复到最后 这个

44
00:01:45,240 --> 00:01:47,820
想法是，当我们进行插入时，

45
00:01:47,820 --> 00:01:49,409
显然只是版本不存在，

46
00:01:49,409 --> 00:01:50,880
我们只是在删除或更新时将其放入数据库中，

47
00:01:50,880 --> 00:01:52,500
我们需要

48
00:01:52,500 --> 00:01:54,840
跟踪我们有以前的

49
00:01:54,840 --> 00:01:56,100
版本并且我们正在创建 一个新

50
00:01:56,100 --> 00:01:58,229
版本，然后当我们尝试在幕后

51
00:01:58,229 --> 00:02:00,440
的逻辑级别再次读取该对象时，

52
00:02:00,440 --> 00:02:02,520
数据库

53
00:02:02,520 --> 00:02:04,409
系统必须弄清楚

54
00:02:04,409 --> 00:02:06,119
我们需要读取的正确版本是什么，

55
00:02:06,119 --> 00:02:08,818
并且它将是

56
00:02:08,818 --> 00:02:10,949
那个 在它交易开始时就已经存在，

57
00:02:10,949 --> 00:02:14,940
所以 MVCC 并不是一个新想法，它

58
00:02:14,940 --> 00:02:17,340
可以追溯到 1970 年代末

59
00:02:17,340 --> 00:02:18,540
它是

60
00:02:18,540 --> 00:02:21,530
由麻省理工学院的 Reed 在这篇论文中首次提出的

61
00:02:21,530 --> 00:02:23,519
，这是对 MVCC 如何工作的第一个

62
00:02:23,519 --> 00:02:26,239
类似描述

63
00:02:26,239 --> 00:02:29,459
据我们所知，第一个真正的实现

64
00:02:29,459 --> 00:02:31,019
是在这个称为内

65
00:02:31,019 --> 00:02:35,580
基础的系统中，在甲板内基础上实际上

66
00:02:35,580 --> 00:02:37,680
仍然存在，它被

67
00:02:37,680 --> 00:02:39,090
转手了几次，它被

68
00:02:39,090 --> 00:02:41,069
Borland 和 ole 编译器

69
00:02:41,069 --> 00:02:43,380
公司收购，现在它被一些人收购 移动电话

70
00:02:43,380 --> 00:02:45,060
公司左右现在已经

71
00:02:45,060 --> 00:02:46,220
像在全球数据库中那样重新命名，

72
00:02:46,220 --> 00:02:48,720
但是当 Borland 拥有它时，

73
00:02:48,720 --> 00:02:50,280
他们确实分叉了源代码

74
00:02:50,280 --> 00:02:53,310
并将其作为 Firebird 开源 我

75
00:02:53,310 --> 00:02:55,470
说过今天确实存在我

76
00:02:55,470 --> 00:02:57,420
不知道 知道我从来没有真正遇到过

77
00:02:57,420 --> 00:02:58,950
任何人使用它，但他们

78
00:02:58,950 --> 00:03:00,540
仍在维护它，如果

79
00:03:00,540 --> 00:03:02,160
你想知道为什么 Firefox 被称为

80
00:03:02,160 --> 00:03:04,470
Firefox，因为当 Mozilla 倒闭时

81
00:03:04,470 --> 00:03:07,260
，他们采取了 netscape 浏览器，

82
00:03:07,260 --> 00:03:08,880
他们最初将其命名为 Firebird，

83
00:03:08,880 --> 00:03:10,980
但您知道它

84
00:03:10,980 --> 00:03:12,690
与该系统发生冲突，因此他们不得不

85
00:03:12,690 --> 00:03:16,440
将其重命名为 Firefox，这

86
00:03:16,440 --> 00:03:19,109
很有趣，NBCC

87
00:03:19,109 --> 00:03:20,910
几乎是

88
00:03:20,910 --> 00:03:22,680
所有已开发或发布的数据库系统

89
00:03:22,680 --> 00:03:25,290
过去十年，包括

90
00:03:25,290 --> 00:03:26,780
我们在 CMU 一直在研究的两个，

91
00:03:26,780 --> 00:03:30,269
他们都一直在使用 MVCC，这是

92
00:03:30,269 --> 00:03:31,769
非常普遍的，所以

93
00:03:31,769 --> 00:03:33,150
对我们来说弄清楚你知道我们

94
00:03:33,150 --> 00:03:35,489
实际上想要如何构建抗性是很重要的，

95
00:03:35,489 --> 00:03:37,440
让我们应该 尽可能把它像罐子一样保存

96
00:03:37,440 --> 00:03:40,200
是的，对不起，我会弄清楚

97
00:03:40,200 --> 00:03:42,690
我们如何获得这一切的钥匙，所以

98
00:03:42,690 --> 00:03:43,890
mzc 的主要思想

99
00:03:43,890 --> 00:03:45,720
我们将得到的好处是

100
00:03:45,720 --> 00:03:47,400
，作家不会阻止

101
00:03:47,400 --> 00:03:48,959
读者和 读者不会

102
00:03:48,959 --> 00:03:50,879
阻塞作者，所以这意味着

103
00:03:50,879 --> 00:03:53,610
当我们去更新一个元组

104
00:03:53,610 --> 00:03:54,930
写入事务时，写入

105
00:03:54,930 --> 00:03:57,810
线程将更新元组，这与两

106
00:03:57,810 --> 00:03:59,640
阶段锁定不同，你必须

107
00:03:59,640 --> 00:04:01,200
知道采取排他性 锁定元组

108
00:04:01,200 --> 00:04:02,850
并阻止任何人做任何事情，

109
00:04:02,850 --> 00:04:05,940
即使在 MVCC 下读取它我们

110
00:04:05,940 --> 00:04:06,810
没有这个问题

111
00:04:06,810 --> 00:04:08,640
我们不正确我们可以如何

112
00:04:08,640 --> 00:04:10,770
创建新版本，其他事务

113
00:04:10,770 --> 00:04:12,960
可以在没有它们的情况下读取旧版本

114
00:04:12,960 --> 00:04:15,720
现在

115
00:04:15,720 --> 00:04:17,399
写写冲突的任何冲突都有一个简单的规则

116
00:04:17,399 --> 00:04:19,410
说第一个作家总是赢这是

117
00:04:19,410 --> 00:04:20,970
最简单的方法来做到这一点

118
00:04:20,970 --> 00:04:22,230
你知道你显然不想要那个

119
00:04:22,230 --> 00:04:23,790
或者你不能写写复杂

120
00:04:23,790 --> 00:04:26,070
但这会是 允许我们做

121
00:04:26,070 --> 00:04:27,510
一些我们通常无法在

122
00:04:27,510 --> 00:04:29,400
单一版本系统上做的事情，比如

123
00:04:29,400 --> 00:04:31,200
在后台运行长时间运行的分析查询

124
00:04:31,200 --> 00:04:33,180
，我们告诉版本，而

125
00:04:33,180 --> 00:04:36,030
新的事务正在更新更新

126
00:04:36,030 --> 00:04:40,110
数据库，因此对于只读事务

127
00:04:40,110 --> 00:04:43,860
我们什么 重新获得的是它

128
00:04:43,860 --> 00:04:45,060
也将能够读取一致的

129
00:04:45,060 --> 00:04:46,950
快照数据库每个人都会

130
00:04:46,950 --> 00:04:48,180
有一致的快照

131
00:04:48,180 --> 00:04:49,500
我将在下一张幻灯片中定义

132
00:04:49,500 --> 00:04:51,780
它的主要优点是如果

133
00:04:51,780 --> 00:04:53,280
我们在一开始就声明我们的事务是

134
00:04:53,280 --> 00:04:56,070
只读的，然后我们

135
00:04:56,070 --> 00:04:57,570
实际上不需要获取任何锁

136
00:04:57,570 --> 00:04:59,700
来读取任何东西，因为我们知道我们

137
00:04:59,700 --> 00:05:01,080
总是可以在某些系统中读取一致的快照，

138
00:05:01,080 --> 00:05:03,120
比如我的 C 代码，你甚至不需要

139
00:05:03,120 --> 00:05:05,340
交易 ID 因为

140
00:05:05,340 --> 00:05:06,900
这对他们来说是

141
00:05:06,900 --> 00:05:09,060
分发这些交易 ID 的集中瓶颈，

142
00:05:09,060 --> 00:05:10,919
所以你只需完全跳过它，

143
00:05:10,919 --> 00:05:12,660
所以我们将用来确定

144
00:05:12,660 --> 00:05:14,550
对我们可见的内容的方式是通过

145
00:05:14,550 --> 00:05:16,770
时间戳再次我们将详细讨论这个

146
00:05:16,770 --> 00:05:20,160
更详细地说，课程的其余部分，

147
00:05:20,160 --> 00:05:21,180
但我们现在也将能够

148
00:05:21,180 --> 00:05:22,860
支持 MVC 或将其称为时间旅行

149
00:05:22,860 --> 00:05:24,960
查询，因此在单版本

150
00:05:24,960 --> 00:05:27,270
系统中再次发生了什么我更新了一个元组，

151
00:05:27,270 --> 00:05:29,850
旧版本消失了旧字段

152
00:05:29,850 --> 00:05:31,620
值 它在日志中，以防我需要

153
00:05:31,620 --> 00:05:33,750
撤消它，但是当查询运行时，他们不是

154
00:05:33,750 --> 00:05:35,340
在查看日志，

155
00:05:35,340 --> 00:05:38,250
而是在查看元组，而是使用 MVC 查看我们是否不

156
00:05:38,250 --> 00:05:39,750
进行任何垃圾收集并保留

157
00:05:39,750 --> 00:05:42,300
所有旧版本 然后一些

158
00:05:42,300 --> 00:05:43,590
系统 会对你的时间旅行查询撒谎，

159
00:05:43,590 --> 00:05:45,870
说你知道在两年前或三年前

160
00:05:45,870 --> 00:05:47,430
就存在的数据库快照上运行这个查询，

161
00:05:47,430 --> 00:05:49,290


162
00:05:49,290 --> 00:05:52,800
所以这一系列

163
00:05:52,800 --> 00:05:54,330
系统声称他们支持这一点，这

164
00:05:54,330 --> 00:05:55,620
不是

165
00:05:55,620 --> 00:05:58,140
像 Postgres 这样的新想法 在 1980 年代有了这个，您

166
00:05:58,140 --> 00:05:59,250
基本上只是不进行垃圾

167
00:05:59,250 --> 00:06:00,690
收集，并且您做了一些额外的

168
00:06:00,690 --> 00:06:02,190
工作，以允许查询指定

169
00:06:02,190 --> 00:06:04,289
他们再次查看 Postgres 的快照

170
00:06:04,289 --> 00:06:05,760
Postgres 推断您提出了

171
00:06:05,760 --> 00:06:07,560
这不是

172
00:06:07,560 --> 00:06:09,120
我实际上开始在外面使用

173
00:06:09,120 --> 00:06:10,500
在 199990 年代末期的学术界

174
00:06:10,500 --> 00:06:12,330
，他们

175
00:06:12,330 --> 00:06:13,860
意识到这是没有人想要的功能

176
00:06:13,860 --> 00:06:15,240
，你很快就会用完它的磁盘空间

177
00:06:15,240 --> 00:06:17,280
，所以这是

178
00:06:17,280 --> 00:06:18,630
他们做的第一件事，当他们

179
00:06:18,630 --> 00:06:21,150
让 Postgres 在外面真正可用时

180
00:06:21,150 --> 00:06:22,919
伯克利是你知道摆脱这种

181
00:06:22,919 --> 00:06:25,110
支持把一个萌芽得到一堆

182
00:06:25,110 --> 00:06:26,280
新系统声称他们今天支持时间

183
00:06:26,280 --> 00:06:28,440
旅行查询我还没有看到

184
00:06:28,440 --> 00:06:30,750
任何真正的用例

185
00:06:30,750 --> 00:06:34,860
没关系所以我们需要

186
00:06:34,860 --> 00:06:36,660
找出快照隔离或快照的

187
00:06:36,660 --> 00:06:39,389
含义所以在介绍中断课程中

188
00:06:39,389 --> 00:06:41,160
我们讨论了隔离级别我们

189
00:06:41,160 --> 00:06:42,450
实际上从未真正讨论过这个

190
00:06:42,450 --> 00:06:43,830
因为这实际上

191
00:06:43,830 --> 00:06:46,290
在续集标准中没有完全定义

192
00:06:46,290 --> 00:06:48,200
但这是一些东西

193
00:06:48,200 --> 00:06:52,229
当您使用 MPC C 时，您会进入某些系统，因此

194
00:06:52,229 --> 00:06:53,520
它的工作方式是，

195
00:06:53,520 --> 00:06:56,010
当事务开始时，它会看到该事务开始

196
00:06:56,010 --> 00:06:58,380
时存在的数据库的一致快照，

197
00:06:58,380 --> 00:06:59,940


198
00:06:59,940 --> 00:07:02,400
所以这

199
00:07:02,400 --> 00:07:05,820
意味着您只能看到 存在的元组版本

200
00:07:05,820 --> 00:07:09,360
是由

201
00:07:09,360 --> 00:07:10,950
在您开始之前提交的事务创建的，

202
00:07:10,950 --> 00:07:14,400
因此如果我的事务开始

203
00:07:14,400 --> 00:07:15,810
并且有另一个事务

204
00:07:15,810 --> 00:07:16,919
在我之前开始但他们

205
00:07:16,919 --> 00:07:18,840
尚未提交并说他们更新

206
00:07:18,840 --> 00:07:20,490
倾向于池或他们在我开始之前更新了五个

207
00:07:20,490 --> 00:07:22,979
在我开始五个之后，我不会

208
00:07:22,979 --> 00:07:24,600
看到他们的任何更改，因为那是

209
00:07:24,600 --> 00:07:25,830
因为这些版本实际上

210
00:07:25,830 --> 00:07:28,320
都没有提交 b 在我的第一

211
00:07:28,320 --> 00:07:30,450
笔交易开始之前，这

212
00:07:30,450 --> 00:07:31,560
就是我的意思 迈克助手 你

213
00:07:31,560 --> 00:07:32,850
不会看到任何撕裂 这么多实际

214
00:07:32,850 --> 00:07:34,740
交易 你只能看到

215
00:07:34,740 --> 00:07:35,789
你知道在你开始之前已经提交的事情

216
00:07:35,789 --> 00:07:39,210
所以也正如我之前所说，如果

217
00:07:39,210 --> 00:07:40,440
我们有 两个事务同时运行，

218
00:07:40,440 --> 00:07:41,850
并且它们试图

219
00:07:41,850 --> 00:07:43,800
从同一个对象更新，那么我们将使用

220
00:07:43,800 --> 00:07:45,690
一个简单的规则，即当您进行死锁预防或死锁检测时，第一个写入器

221
00:07:45,690 --> 00:07:47,970
就像两阶段锁定一样获胜，

222
00:07:47,970 --> 00:07:49,560


223
00:07:49,560 --> 00:07:50,910
所有

224
00:07:50,910 --> 00:07:52,530
这些 不同的规则来说明谁比这更老

225
00:07:52,530 --> 00:07:54,060
我应该何时等待 我应该

226
00:07:54,060 --> 00:07:56,190
放弃谁持有最多的锁 也许我

227
00:07:56,190 --> 00:07:58,350
在另一个人离开之前让他们离开 我们

228
00:07:58,350 --> 00:07:59,520
不做任何那样的事情 所以这

229
00:07:59,520 --> 00:08:01,500
对我们来说太复杂了，只是有点跑进来

230
00:08:01,500 --> 00:08:03,389
在海洋环境中，我们只是

231
00:08:03,389 --> 00:08:05,430
说谁先写了谁赢了第二个家伙

232
00:08:05,430 --> 00:08:06,810
试图很好地编写相同的对象我们

233
00:08:06,810 --> 00:08:08,160
需要一些我们试图

234
00:08:08,160 --> 00:08:10,620
写入同一个对象的技术，如果是这样，那么

235
00:08:10,620 --> 00:08:13,979
我们就干掉我们的 精灵并中止，所以你

236
00:08:13,979 --> 00:08:17,159
可能会想得很好，这

237
00:08:17,159 --> 00:08:19,229
似乎你知道令人敬畏的突触隔离

238
00:08:19,229 --> 00:08:21,090
给了我们你想要的东西是的，

239
00:08:21,090 --> 00:08:23,130
我们当然能够实现一个问题

240
00:08:23,130 --> 00:08:30,630
是的，所以这个问题就是我的

241
00:08:30,630 --> 00:08:32,159
意思，第一个骑手获胜是

242
00:08:32,159 --> 00:08:33,690
基于 他们开始的时间还是

243
00:08:33,690 --> 00:08:35,190
基于他们写

244
00:08:35,190 --> 00:08:37,169
的时间？基于他们写的时间，所以你

245
00:08:37,169 --> 00:08:38,640
实际上可以在我之前开始，但是如果我

246
00:08:38,640 --> 00:08:39,990
写这个元组然后你尝试

247
00:08:39,990 --> 00:08:42,240
像你一样写这个元组但是 你

248
00:08:42,240 --> 00:08:44,400
必须向右走 没想到

249
00:08:44,400 --> 00:08:46,290
它是你做的最简单的事情

250
00:08:46,290 --> 00:08:48,630
因为我就像我看着管子

251
00:08:48,630 --> 00:08:49,860
一样试图写它 我会看到哦

252
00:08:49,860 --> 00:08:51,600
有人在我做之前找到了我

253
00:08:51,600 --> 00:08:53,550
你只是继续自杀

254
00:08:53,550 --> 00:08:55,410
我不知道你是否会

255
00:08:55,410 --> 00:08:57,510
写同样的东西所以

256
00:08:57,510 --> 00:09:01,110
在你写之前我怎么会中止这是

257
00:09:01,110 --> 00:09:03,060
重要的问题Rico问题好吧

258
00:09:03,060 --> 00:09:05,339
所以快照隔离不能

259
00:09:05,339 --> 00:09:10,230
序列化对II和我' 会告诉你

260
00:09:10,230 --> 00:09:11,520
为什么，因为它是苏 对

261
00:09:11,520 --> 00:09:13,020
所谓的正确偏斜异常很敏感，但

262
00:09:13,020 --> 00:09:15,210
它确实具有不同的

263
00:09:15,210 --> 00:09:17,160
异常，例如可重复读取

264
00:09:17,160 --> 00:09:20,670
和读取已提交，并且对此也有点

265
00:09:20,670 --> 00:09:21,810
令人困惑，就像

266
00:09:21,810 --> 00:09:23,850
如果您声明要使用 Oracle 以 Oracle 为例

267
00:09:23,850 --> 00:09:25,830
您的

268
00:09:25,830 --> 00:09:28,110
可序列化隔离

269
00:09:28,110 --> 00:09:29,790
级别实际上是

270
00:09:29,790 --> 00:09:31,560
快照隔离，但

271
00:09:31,560 --> 00:09:32,310
除非您阅读文档，否则他们不会告诉您这一点，

272
00:09:32,310 --> 00:09:35,250
因此

273
00:09:35,250 --> 00:09:36,420
了解区别是什么很重要，

274
00:09:36,420 --> 00:09:38,190
您会明白为什么这不会 是可

275
00:09:38,190 --> 00:09:40,110
序列化的，下一个课程我们

276
00:09:40,110 --> 00:09:42,270
将看到实际添加的方法添加

277
00:09:42,270 --> 00:09:44,490
添加戴维斯

278
00:09:44,490 --> 00:09:46,110
不会使快照隔离可消毒的其他东西

279
00:09:46,110 --> 00:09:49,890
是的问题

280
00:09:49,890 --> 00:09:52,140
在此是的情况下尽可能微弱，但特别

281
00:09:52,140 --> 00:09:53,730
容易受到这种右偏异常

282
00:09:53,730 --> 00:09:56,520
的影响 可重复读取并不完全

283
00:09:56,520 --> 00:09:58,350
正确，因此是再次理解正确偏斜异常的最简单方法，

284
00:09:58,350 --> 00:09:59,820
因此请

285
00:09:59,820 --> 00:10:01,260
记住中断类 w 我们

286
00:10:01,260 --> 00:10:04,529
谈到了脏读、不可重复读

287
00:10:04,529 --> 00:10:07,040
和其他可能发生的冲突，你可能有

288
00:10:07,040 --> 00:10:08,970
正确的偏斜实际上是

289
00:10:08,970 --> 00:10:11,010
非常特定于快照的东西，而不是

290
00:10:11,010 --> 00:10:12,300
你在多版本系统中获得的隔离，

291
00:10:12,300 --> 00:10:14,279
所以理解这一点的最简单方法

292
00:10:14,279 --> 00:10:15,660
是这个简单的

293
00:10:15,660 --> 00:10:18,900
可视化，据说 是

294
00:10:18,900 --> 00:10:21,000
由 Jim Gray 创建的，

295
00:10:21,000 --> 00:10:23,160
然后是两阶段锁定，所以假设我

296
00:10:23,160 --> 00:10:25,770
有一个弹珠数据库，弹珠

297
00:10:25,770 --> 00:10:26,940
有两种颜色，可以是

298
00:10:26,940 --> 00:10:29,730
黑色或白色，所以我有一个

299
00:10:29,730 --> 00:10:31,380
交易，两个交易

300
00:10:31,380 --> 00:10:32,640
想要改变所有 白色弹珠

301
00:10:32,640 --> 00:10:35,010
黑色和所有要擦除的黑色弹珠

302
00:10:35,010 --> 00:10:36,570
假设这两个事务

303
00:10:36,570 --> 00:10:39,029
在完全相同的时间开始，

304
00:10:39,029 --> 00:10:41,670
因此它们将在 nbcc

305
00:10:41,670 --> 00:10:43,139
下进行快照或在快照

306
00:10:43,139 --> 00:10:44,250
隔离下它们将具有一致的

307
00:10:44,250 --> 00:10:46,980
快照

308
00:10:46,980 --> 00:10:48,630
他们刚开始时就存在的数据库，所以他们每个

309
00:10:48,630 --> 00:10:50,250
人都有两个黑色弹珠和两个

310
00:10:50,250 --> 00:10:53,490
白色弹珠，所以这里的第一个人他

311
00:10:53,490 --> 00:10:54,540
要切换所有的白色弹珠 rble 到

312
00:10:54,540 --> 00:10:56,220
黑色，这里的底层人想要

313
00:10:56,220 --> 00:10:58,019
切换白色的所有黑色弹珠，所以

314
00:10:58,019 --> 00:11:00,329
他们继续这样做，没有

315
00:11:00,329 --> 00:11:01,440
正确的冲突，因为他们

316
00:11:01,440 --> 00:11:03,750
更新了不同的东西，然后现在

317
00:11:03,750 --> 00:11:06,600
他们提交了，但是现在发生了什么，我们有

318
00:11:06,600 --> 00:11:07,860
两个白色弹珠变成了两个 黑曼巴，

319
00:11:07,860 --> 00:11:09,620
他们基本上刚刚被颠倒是

320
00:11:09,620 --> 00:11:13,920
可以消毒的 你摇头 注意

321
00:11:13,920 --> 00:11:18,800
为什么你只是喝你的

322
00:11:18,800 --> 00:11:30,660
饮料所以他说如果它真的是先生躺着的

323
00:11:30,660 --> 00:11:33,300
碗那么它必须

324
00:11:33,300 --> 00:11:35,610
相当于交易的谷物订购

325
00:11:35,610 --> 00:11:38,010
所以那要么是全

326
00:11:38,010 --> 00:11:40,110
黑要么全白，但在我的例子中

327
00:11:40,110 --> 00:11:43,139
，我们最终得到了两个白色

328
00:11:43,139 --> 00:11:45,420
和两个黑色，所以在可消毒的隔离下，

329
00:11:45,420 --> 00:11:51,829
这不可能发生，是的，

330
00:12:02,329 --> 00:12:05,399
你的问题，你的问题很抱歉，

331
00:12:05,399 --> 00:12:06,810
你说的像我

332
00:12:06,810 --> 00:12:07,829
正在假设我只需要

333
00:12:07,829 --> 00:12:11,850
更新，但就像这里的这两个一样，是的，

334
00:12:11,850 --> 00:12:13,620
II 查询是更新所有

335
00:12:13,620 --> 00:12:15,420
内容，找到所有白色的

336
00:12:15,420 --> 00:12:16,410
内容，尝试所有黑色的内容并制作它

337
00:12:16,410 --> 00:12:17,699
白色 找到所有白色的都

338
00:12:17,699 --> 00:12:21,990
变成黑色 所以当我看到这个的

339
00:12:21,990 --> 00:12:24,149
时候 当这个人运行它时 他看

340
00:12:24,149 --> 00:12:27,120
快照 他没有看到 你知道他

341
00:12:27,120 --> 00:12:29,130
看到这些人是白人 所以鼻子知道

342
00:12:29,130 --> 00:12:31,560
它不需要更新 但是

343
00:12:31,560 --> 00:12:33,569
，当我提交它们时，我最终

344
00:12:33,569 --> 00:12:37,699
得到的是，您知道异常是

345
00:12:38,270 --> 00:12:39,800
本质上读取

346
00:12:39,800 --> 00:12:42,170
乌龟弹珠的所有元组是的，并且

347
00:12:42,170 --> 00:12:44,210
只写入黑色或白色的元组

348
00:12:44,210 --> 00:12:46,490
是有效地赢得了这个问题，

349
00:12:46,490 --> 00:12:48,440
如果他们得到解决 只是盲目地闯入每个

350
00:12:48,440 --> 00:12:50,090
元组，然后在快照隔离下，

351
00:12:50,090 --> 00:12:51,410
您将获得等效于可

352
00:12:51,410 --> 00:12:55,250
序列化的内容，因为 david 正在保存在

353
00:12:55,250 --> 00:12:57,110
这种情况下，我们将读取所有内容，

354
00:12:57,110 --> 00:12:58,910
找到我们确实需要更新的内容，

355
00:12:58,910 --> 00:13:00,260
这是我们的正确设置，然后我们

356
00:13:00,260 --> 00:13:02,900
编写 你是说，如果我们

357
00:13:02,900 --> 00:13:04,820
只是盲目地写下所有东西，那么这个

358
00:13:04,820 --> 00:13:06,860
人已经是白人了，让它变成白人，这个

359
00:13:06,860 --> 00:13:08,420
人已经是黑人，让它变成黑色，

360
00:13:08,420 --> 00:13:10,900
然后尝试将其视为我们的正确设置，

361
00:13:10,900 --> 00:13:13,910
在这种情况下，这将是其中之一 他们

362
00:13:13,910 --> 00:13:16,970
在广告牌上说

363
00:13:16,970 --> 00:13:19,910
是的 所以是的 所以是的 这是一个会中止

364
00:13:19,910 --> 00:13:22,280
重试 但然后你然后你 然后你的

365
00:13:22,280 --> 00:13:35,120
这个是的 我想所以

366
00:13:35,120 --> 00:13:38,030
这里的问题是我的这是用英文写的

367
00:13:38,030 --> 00:13:40,910
将黑色弹珠改为白色所以

368
00:13:40,910 --> 00:13:43,190
这可能意味着 就像我的意思是你可以

369
00:13:43,190 --> 00:13:44,840
推断出找到黑色大理石

370
00:13:44,840 --> 00:13:47,450
并将它们变成白色你理论上也可以

371
00:13:47,450 --> 00:13:50,000
说我只是把所有东西都变成白色因为

372
00:13:50,000 --> 00:13:51,470
这就是我想要的假设我只有

373
00:13:51,470 --> 00:13:53,120
两种颜色并不重要现在什么是白色

374
00:13:53,120 --> 00:13:54,890
让它变成白色你知道白色

375
00:13:54,890 --> 00:13:58,460
确保它是白色的，没有戴维森

376
00:13:58,460 --> 00:14:00,740
实际上会这样做，因为对于这个查询试图做的事情可能

377
00:14:00,740 --> 00:14:03,020
有更高级别的语义

378
00:14:03,020 --> 00:14:04,580
，就像我的情况

379
00:14:04,580 --> 00:14:06,140
一样非常简单，所以就像你可以说

380
00:14:06,140 --> 00:14:07,280
哦，当然，如果有办法让它变成

381
00:14:07,280 --> 00:14:10,640
白色 这很好，但是在一个真正的

382
00:14:10,640 --> 00:14:12,140
数据库中，这可能太难

383
00:14:12,140 --> 00:14:14,750
了，而且

384
00:14:14,750 --> 00:14:16,820
如果我的数据库是十亿或弹珠，你也总是处于极端状态我

385
00:14:16,820 --> 00:14:20,000


386
00:14:20,000 --> 00:14:21,650
不想写出他们不需要的东西我需要

387
00:14:21,650 --> 00:14:23,780
写 因为 否则他们可能

388
00:14:23,780 --> 00:14:25,670
只是我最好只是将它

389
00:14:25,670 --> 00:14:28,640
作为一个又一个线程执行，

390
00:14:28,640 --> 00:14:29,960
好吧，主要的收获是，

391
00:14:29,960 --> 00:14:30,920
我想再次在这里指出，

392
00:14:30,920 --> 00:14:33,560
在快照隔离下，这种异常可能

393
00:14:33,560 --> 00:14:36,500
会发生，最终结果

394
00:14:36,500 --> 00:14:38,330
来自 从更高层次的角度来看，

395
00:14:38,330 --> 00:14:39,590
我们如何理解数据应该

396
00:14:39,590 --> 00:14:42,680
是什么样子是错误的，并且它不

397
00:14:42,680 --> 00:14:44,300
等同于在串行水中执行它们

398
00:14:44,300 --> 00:14:47,500
是

399
00:14:53,380 --> 00:14:56,330
否 可消毒意味着这

400
00:14:56,330 --> 00:14:57,700
又在中断类中涵盖 可

401
00:14:57,700 --> 00:15:00,040
消毒意味着您

402
00:15:00,040 --> 00:15:02,420
生成最终状态 数据库的数据

403
00:15:02,420 --> 00:15:04,670
等同于事务的任何串行排序，

404
00:15:04,670 --> 00:15:07,670
所以在这种情况下，

405
00:15:07,670 --> 00:15:10,420
我首先通过 t2 执行 t1，

406
00:15:10,420 --> 00:15:12,800
但我可以首先通过 t1 反转 t2 Google

407
00:15:12,800 --> 00:15:14,089
，并且两者都会考虑

408
00:15:14,089 --> 00:15:20,690
正确的问题，这种异常

409
00:15:20,690 --> 00:15:24,250
也可能发生 在重新提交是但不是我

410
00:15:24,250 --> 00:15:26,899
不认为可重复阅读有这个

411
00:15:26,899 --> 00:15:37,610
问题是的所以这是这张图片在这里

412
00:15:37,610 --> 00:15:41,870
正确所以在像像在

413
00:15:41,870 --> 00:15:43,160
像教科书定义一样

414
00:15:43,160 --> 00:15:44,690
隔离级别和 ANSI 标准的

415
00:15:44,690 --> 00:15:47,360
最低设置我认为现在仍然像你

416
00:15:47,360 --> 00:15:48,470
一样有这条路径可以将

417
00:15:48,470 --> 00:15:50,060
读取未提交提交的

418
00:15:50,060 --> 00:15:51,560
重复读取序列化为可消毒但

419
00:15:51,560 --> 00:15:52,820
快照隔离是另一

420
00:15:52,820 --> 00:15:55,130
件事，它的正确偏斜异常不会

421
00:15:55,130 --> 00:15:57,500
为此发生 然后这是重复

422
00:15:57,500 --> 00:16:01,970
读取很容易受到我的意思是脏

423
00:16:01,970 --> 00:16:03,709
读我忘记是

424
00:16:03,709 --> 00:16:05,959
的因此这不会发生在这种情况下

425
00:16:05,959 --> 00:16:07,610
您无法读取您可以进行脏读

426
00:16:07,610 --> 00:16:08,839
并进行隔离因为您只看到

427
00:16:08,839 --> 00:16:11,300
在您知道时提交的事情

428
00:16:11,300 --> 00:16:13,459
您只能看到

429
00:16:13,459 --> 00:16:15,170
由在您开始之前提交的事务创建的元组版本，

430
00:16:15,170 --> 00:16:16,610
您不能

431
00:16:16,610 --> 00:16:22,459
进行脏读，但这又是

432
00:16:22,459 --> 00:16:23,660
重点，我只想说明

433
00:16:23,660 --> 00:16:26,350
这就像快照一样，隔离是

434
00:16:26,350 --> 00:16:29,709
您没有得到的 它默认使用

435
00:16:29,709 --> 00:16:32,420
MVCC，就像 Postgres 使用 MCC 一样，但

436
00:16:32,420 --> 00:16:33,980
默认情况下你会得到我认为已提交

437
00:16:33,980 --> 00:16:37,100
我认为我的续集也是如此，但

438
00:16:37,100 --> 00:16:38,600
就像你遵循严格的

439
00:16:38,600 --> 00:16:40,570
定义一样 o

440
00:16:40,570 --> 00:16:42,920
通行费和确定

441
00:16:42,920 --> 00:16:44,269
版本 确定

442
00:16:44,269 --> 00:16:46,040
当我们的交易运行时我们可以看到哪些版本

443
00:16:46,040 --> 00:16:48,050
据我所知你最终会

444
00:16:48,050 --> 00:16:50,089
得到隔离，然后我们

445
00:16:50,089 --> 00:16:52,760
周一的下一堂课我们会看到一堆

446
00:16:52,760 --> 00:16:54,380
额外的东西你 可以在数据库

447
00:16:54,380 --> 00:16:55,970
系统中做到这一点，使其在

448
00:16:55,970 --> 00:16:59,820
某个时候实际上可序列化，

449
00:16:59,820 --> 00:17:05,390
所以你们阅读的论文

450
00:17:05,390 --> 00:17:08,880
是对

451
00:17:08,880 --> 00:17:10,619


452
00:17:10,619 --> 00:17:15,240
构建现代 MVCC 系统时必须做出的不同设计决策的一种概述，因此

453
00:17:15,240 --> 00:17:17,670
尽管有名称墨盒

454
00:17:17,670 --> 00:17:20,040
孔 知道这些词会伤害它，这

455
00:17:20,040 --> 00:17:23,280
一切都是以 MVCC 的名义，它

456
00:17:23,280 --> 00:17:25,829
不仅仅是并发控制

457
00:17:25,829 --> 00:17:27,690
，多边缘的想法实际上渗透

458
00:17:27,690 --> 00:17:28,980
到我们在

459
00:17:28,980 --> 00:17:32,400
整个系统架构中的所有内容中，所以

460
00:17:32,400 --> 00:17:33,540
这不是说我要

461
00:17:33,540 --> 00:17:35,280
选择两个的问题 锁相，然后

462
00:17:35,280 --> 00:17:36,600
你就完成了还有所有这些

463
00:17:36,600 --> 00:17:37,860
你必须担心的其他事情，

464
00:17:37,860 --> 00:17:41,640
并且这些设计决策的影响

465
00:17:41,640 --> 00:17:43,530
可能非常重要，

466
00:17:43,530 --> 00:17:45,300
基于 o  n 你的申请是基于

467
00:17:45,300 --> 00:17:46,710


468
00:17:46,710 --> 00:17:49,290
你试图支持的工作量，所以我

469
00:17:49,290 --> 00:17:50,790
让你们读的论文实际上来自

470
00:17:50,790 --> 00:17:52,560
这门课，所以当我

471
00:17:52,560 --> 00:17:56,100
在 2016 年第一次教这门课时，我们就像

472
00:17:56,100 --> 00:17:57,300
你知道我想要的 涵盖

473
00:17:57,300 --> 00:17:59,820
MVCC 或现代 MVCC，实际上我们在

474
00:17:59,820 --> 00:18:01,440
这里构建了自己的数据库系统，

475
00:18:01,440 --> 00:18:03,510
该系统将是多版本的，还有

476
00:18:03,510 --> 00:18:05,520
一堆你知道的问题

477
00:18:05,520 --> 00:18:06,720
，比如我们应该如何进行原始

478
00:18:06,720 --> 00:18:08,040
存储 hashmi 新垃圾收集

479
00:18:08,040 --> 00:18:09,990
以及何时阅读

480
00:18:09,990 --> 00:18:12,330
文献并阅读所有

481
00:18:12,330 --> 00:18:14,490
这些正在执行 MVCC 的其他系统的文档 他们

482
00:18:14,490 --> 00:18:17,040
通常只是说这是我们所做的

483
00:18:17,040 --> 00:18:19,080
他们没有证明为什么他们会做

484
00:18:19,080 --> 00:18:21,150
某些事情并且所有这些不同的

485
00:18:21,150 --> 00:18:22,560
系统都在做一些你知道

486
00:18:22,560 --> 00:18:25,020
略有不同的事情所以 这篇论文的想法

487
00:18:25,020 --> 00:18:26,940
是通过并实际

488
00:18:26,940 --> 00:18:28,770


489
00:18:28,770 --> 00:18:30,720
了解这些不同设计站的所有不同权衡，

490
00:18:30,720 --> 00:18:33,450
然后最终进行烘焙，

491
00:18:33,450 --> 00:18:34,770
然后无论结果如何 成为

492
00:18:34,770 --> 00:18:36,120
我们想要放入我们的

493
00:18:36,120 --> 00:18:40,620
系统中最好

494
00:18:40,620 --> 00:18:43,320
的一篇所以我让你们阅读的

495
00:18:43,320 --> 00:18:45,060
论文的原始名称实际上是有史以来最好的

496
00:18:45,060 --> 00:18:47,150
关于内存多元宇宙内核的论文，所以

497
00:18:47,150 --> 00:18:49,320
论文有点像你的孩子

498
00:18:49,320 --> 00:18:50,610
你不只是挑选你最喜欢的，

499
00:18:50,610 --> 00:18:52,470
这实际上是我最喜欢

500
00:18:52,470 --> 00:18:54,600
的之一 我写这篇文章很有趣，我

501
00:18:54,600 --> 00:18:56,250
和我认为结果非常

502
00:18:56,250 --> 00:18:59,040
有趣，所以我们真的提交

503
00:18:59,040 --> 00:19:00,870
了这个标题的论文，

504
00:19:00,870 --> 00:19:02,700
评论非常好 积极但

505
00:19:02,700 --> 00:19:04,770
他们说的第一件事就被删除了这是

506
00:19:04,770 --> 00:19:06,750
有史以来最好的论文

507
00:19:06,750 --> 00:19:09,360
他们对此非常坚定所以

508
00:19:09,360 --> 00:19:11,400
我很好，你知道

509
00:19:11,400 --> 00:19:13,470
我明白我们

510
00:19:13,470 --> 00:19:16,200
不想成为某种翻转或 你

511
00:19:16,200 --> 00:19:18,690
知道在我们的论文中主观性

512
00:19:18,690 --> 00:19:20,370
你知道我仍然认为它是最好的

513
00:19:20,370 --> 00:19:22,500
论文但你知道永远是我

514
00:19:22,500 --> 00:19:22,919
不知道

515
00:19:22,919 --> 00:19:25,740
所以然后我们将标题更改为如果你

516
00:19:25,740 --> 00:19:27,299
只阅读一份

517
00:19:27,299 --> 00:19:28,830
关于备忘录转移环礁的实证评估论文 这是

518
00:19:28,830 --> 00:19:32,909
一个感叹号 他们

519
00:19:32,909 --> 00:19:34,350
不喜欢他们又回来了 他们

520
00:19:34,350 --> 00:19:36,299
说这是主观的 这是你的

521
00:19:36,299 --> 00:19:38,220
意见 你必须使标题

522
00:19:38,220 --> 00:19:41,159
更科学 或者你知道更多 你

523
00:19:41,159 --> 00:19:44,100
知道的更精确 所以

524
00:19:44,100 --> 00:19:45,360
我们认为论文的第三个名字 你真的很

525
00:19:45,360 --> 00:19:48,929
喜欢这个，这是真的，因为这是

526
00:19:48,929 --> 00:19:51,690
真的，我确实认为他们会喜欢

527
00:19:51,690 --> 00:19:53,880
这是一个事实陈述，所以

528
00:19:53,880 --> 00:19:56,549
在这一点上，论文被接受了，但

529
00:19:56,549 --> 00:19:57,929
他们开始生气，

530
00:19:57,929 --> 00:19:59,280
如果你不这样做，他们就像' 不改变

531
00:19:59,280 --> 00:20:01,980
标题，我们会毫不犹豫地拒绝它，

532
00:20:01,980 --> 00:20:03,809
所以我没有终身教职，我仍然没有，

533
00:20:03,809 --> 00:20:05,039
但就像我没有终身教职一样，

534
00:20:05,039 --> 00:20:06,419
学生需要论文才能毕业

535
00:20:06,419 --> 00:20:08,610
，而且你知道找到工作，所以我们

536
00:20:08,610 --> 00:20:10,289
投降了 所以这就是为什么

537
00:20:10,289 --> 00:20:12,450
这篇论文的标题是你们读的，

538
00:20:12,450 --> 00:20:14,250
这就是为什么我们不得不让它变得真正

539
00:20:14,250 --> 00:20:17,010
枯燥乏味的原因我觉得我本可以

540
00:20:17,010 --> 00:20:19,409
多打点仗来得到这个，但

541
00:20:19,409 --> 00:20:22,429
我屈服了，这是

542
00:20:22,429 --> 00:20:25,080
没关系 忘记我们要讨论的四个设计阶段

543
00:20:25,080 --> 00:20:26,370
是并发重

544
00:20:26,370 --> 00:20:27,780
传版本存储垃圾

545
00:20:27,780 --> 00:20:29,909
收集和索引管理，所以让

546
00:20:29,909 --> 00:20:33,299
我们一一介绍，因此对于

547
00:20:33,299 --> 00:20:35,309
并发巨魔协议，

548
00:20:35,309 --> 00:20:37,380
里面的方法与你们我

549
00:20:37,380 --> 00:20:39,059
上节课读到的或我们

550
00:20:39,059 --> 00:20:41,280
在上一堂课中讨论过的方法相同

551
00:20:41,280 --> 00:20:42,809
没有什么特别的你做的

552
00:20:42,809 --> 00:20:44,789
不同，因为你使用的是多

553
00:20:44,789 --> 00:20:46,559
版本系统，但这些只是

554
00:20:46,559 --> 00:20:49,200
对你如何使用这些

555
00:20:49,200 --> 00:20:51,179
经典协议使它们在

556
00:20:51,179 --> 00:20:53,370
多版本系统中工作的改编，特别是

557
00:20:53,370 --> 00:20:54,510
我们要讨论的是 你

558
00:20:54,510 --> 00:20:57,150
真的想在内存

559
00:20:57,150 --> 00:20:59,340
数据库系统中这样做吗？再次记住，

560
00:20:59,340 --> 00:21:01,740
对于 Discordian 系统，我们

561
00:21:01,740 --> 00:21:04,080
会将锁和锁定

562
00:21:04,080 --> 00:21:05,700
信息与实际元组

563
00:21:05,700 --> 00:21:07,799
本身分开，额外的存储，因为我们

564
00:21:07,799 --> 00:21:09,179
想将锁信息保存在

565
00:21:09,179 --> 00:21:11,700
内存中，所以 如果两个引导被

566
00:21:11,700 --> 00:21:13,350
换出磁盘，我们仍然可以

567
00:21:13,350 --> 00:21:15,510
知道谁持有什么锁，但现在

568
00:21:15,510 --> 00:21:17,940
一切都在内存中，所以我们不想

569
00:21:17,940 --> 00:21:19,169
分开 数据结构，所以我们要

570
00:21:19,169 --> 00:21:20,850
尽量聪明，实际上将

571
00:21:20,850 --> 00:21:23,309
我们需要的

572
00:21:23,309 --> 00:21:24,780
关于 Akko 新协议中正在发生的事情的所有信息存储在元组

573
00:21:24,780 --> 00:21:27,090
中，此外

574
00:21:27,090 --> 00:21:29,280
我们需要知道

575
00:21:29,280 --> 00:21:31,620
我们的元组的版本控制，所以我们想要存储 任何东西都是

576
00:21:31,620 --> 00:21:34,380
分开的，所以时间滑板 OCC

577
00:21:34,380 --> 00:21:38,220
和 2pl 所以我们将讨论

578
00:21:38,220 --> 00:21:39,540
第一个和最后一个

579
00:21:39,540 --> 00:21:42,540
OCC，正如我所说的只是时间戳排序的一种变体

580
00:21:42,540 --> 00:21:44,580
，您只需将

581
00:21:44,580 --> 00:21:47,400
所有内容放入您的所有权利中，最终

582
00:21:47,400 --> 00:21:49,440
进入这个私有 工作区

583
00:21:49,440 --> 00:21:50,730
不是立即可见的，

584
00:21:50,730 --> 00:21:52,560
而在时间戳排序中它

585
00:21:52,560 --> 00:21:54,930
会立即可见，但我们使用一些

586
00:21:54,930 --> 00:21:56,520
额外的元数据来确保

587
00:21:56,520 --> 00:21:57,630
人们不会阅读他们不应该阅读的东西，

588
00:21:57,630 --> 00:22:00,090
他们也会考虑，

589
00:22:00,090 --> 00:22:02,850
但我对此深表歉意 上

590
00:22:02,850 --> 00:22:04,830
一堂课的论文，在我们写这篇论文之前，我们写

591
00:22:04,830 --> 00:22:07,380
了一篇关于

592
00:22:07,380 --> 00:22:11,130
千核的论文，我们将 MVCC 描述为一种

593
00:22:11,130 --> 00:22:12,870


594
00:22:12,870 --> 00:22:13,980
使用时间戳登机的单一商业协议，

595
00:22:13,980 --> 00:22:15,750
因为那是 它是

596
00:22:15,750 --> 00:22:18,120
在最初的 MIT 论文中定义的，但

597
00:22:18,120 --> 00:22:20,280
实际上在 MVCC 下你可以使用

598
00:22:20,280 --> 00:22:22,830
所有这些不同的方法，所以

599
00:22:22,830 --> 00:22:25,140
时间戳排序 mvto 是我们

600
00:22:25,140 --> 00:22:27,030
在千核论文中使用的，但你

601
00:22:27,030 --> 00:22:31,320
仍然可以使用 GPL，所以第一

602
00:22:31,320 --> 00:22:32,460
件事 我们需要嘲笑的是水

603
00:22:32,460 --> 00:22:33,450
反应 我们实际上将如何

604
00:22:33,450 --> 00:22:34,920
维护有关我们

605
00:22:34,920 --> 00:22:38,990
在我们和我们的元组中存储的信息的信息，因此

606
00:22:38,990 --> 00:22:42,030
每个元组都会有一个标题，您可以在其中

607
00:22:42,030 --> 00:22:44,400
再次存储额外的元数据，为

608
00:22:44,400 --> 00:22:46,290
简单起见，假设它是一行

609
00:22:46,290 --> 00:22:47,970
存储，但如果它是一个列存储，你

610
00:22:47,970 --> 00:22:49,290
只有一个单独的列和这个

611
00:22:49,290 --> 00:22:52,380
元数据，所以

612
00:22:52,380 --> 00:22:54,690
固定长度数据池有一些偏移

613
00:22:54,690 --> 00:22:56,670
，前几个字节

614
00:22:56,670 --> 00:22:59,520
将是这个元数据，所以我们要做的第一件事

615
00:22:59,520 --> 00:23:00,600
将有一个唯一的

616
00:23:00,600 --> 00:23:02,730
事务和标识符，这

617
00:23:02,730 --> 00:23:04,320


618
00:23:04,320 --> 00:23:06,120
就是创建此

619
00:23:06,120 --> 00:23:08,250
版本或当前正在

620
00:23:08,250 --> 00:23:10,890
主机上操作的事务的 ID 是什么？ 我们必须

621
00:23:10,890 --> 00:23:12,750
开始和时间戳，这些可

622
00:23:12,750 --> 00:23:14,760
用于确定

623
00:23:14,760 --> 00:23:16,830
此特定版本的可见性的生命周期

624
00:23:16,830 --> 00:23:20,280
，这些时间戳可以是逻辑

625
00:23:20,280 --> 00:23:22,200
计数器，例如单个计数器，也

626
00:23:22,200 --> 00:23:25,860
可以是非常高精度的

627
00:23:25,860 --> 00:23:28,080
硬件时钟，例如纳秒

628
00:23:28,080 --> 00:23:32,700
通常人们使用人们人们使用

629
00:23:32,700 --> 00:23:33,900
计数器，因为它需要

630
00:23:33,900 --> 00:23:35,310
在与事务 ID 相同的域下进行排序，

631
00:23:35,310 --> 00:23:38,190
然后我们现在

632
00:23:38,190 --> 00:23:39,780
还将为我们的元组提供指向

633
00:23:39,780 --> 00:23:40,340


634
00:23:40,340 --> 00:23:41,929
版本链中下一个或上一个版本的指针

635
00:23:41,929 --> 00:23:46,400
因此，当我们再次

636
00:23:46,400 --> 00:23:48,770
进行查找以查找元组时，例如

637
00:23:48,770 --> 00:23:50,720
通过索引，我们将

638
00:23:50,720 --> 00:23:52,220
位于此版本链版本的

639
00:23:52,220 --> 00:23:54,230
链表的头部，然后我们可以遍历

640
00:23:54,230 --> 00:23:56,539
以及时返回或向前

641
00:23:56,539 --> 00:23:58,070
找到正确的版本

642
00:23:58,070 --> 00:23:59,809
对我们可见的元组，所以我们需要

643
00:23:59,809 --> 00:24:02,299
在我们的头中维护一个 64 位指针，在

644
00:24:02,299 --> 00:24:04,549
这里说你知道这是下一个

645
00:24:04,549 --> 00:24:05,809
管或听到前两个球，

646
00:24:05,809 --> 00:24:07,010
这是她看的下一个我 在

647
00:24:07,010 --> 00:24:09,260
Virgin 链中，然后一些其他

648
00:24:09,260 --> 00:24:10,850
约束协议可能会有一些

649
00:24:10,850 --> 00:24:12,500
额外的元数据，然后

650
00:24:12,500 --> 00:24:16,159
是实际的元组元组数据，所以

651
00:24:16,159 --> 00:24:17,870
我首先要指出的是，这些

652
00:24:17,870 --> 00:24:19,460
都是 64 位整数，

653
00:24:19,460 --> 00:24:23,240
所以 8 个字节 在这个例子中

654
00:24:23,240 --> 00:24:25,039
，如果你只是忽略

655
00:24:25,039 --> 00:24:25,730
额外的元数据，

656
00:24:25,730 --> 00:24:29,899
我有 460 个 64 位 64 位值或

657
00:24:29,899 --> 00:24:31,190
能量，我在这里存储，所以我有四个

658
00:24:31,190 --> 00:24:33,500
8 字节的骰子，所以这是 32 字节，我

659
00:24:33,500 --> 00:24:36,770
为它没有的每个元组

660
00:24:36,770 --> 00:24:38,149
存储' 看起来很多，但如果我有

661
00:24:38,149 --> 00:24:39,559
很多元组，

662
00:24:39,559 --> 00:24:42,740
如果我有 10 亿个元组，这可以开始加起来，那么

663
00:24:42,740 --> 00:24:44,240
这四个字段将存储

664
00:24:44,240 --> 00:24:47,539
在 32 GB 以下，然后有

665
00:24:47,539 --> 00:24:50,000
一天会发布很多，但这是

666
00:24:50,000 --> 00:24:51,440
不可避免的，因为 这只是

667
00:24:51,440 --> 00:24:53,799
计算和存储之间的这种权衡

668
00:24:53,799 --> 00:24:55,730
它有点经典，计算机

669
00:24:55,730 --> 00:24:57,380
科学在本学期已经很受欢迎，

670
00:24:57,380 --> 00:24:59,840
所以我可以更聪明一点，也许可以

671
00:24:59,840 --> 00:25:02,390
将这些开始和时间戳存储

672
00:25:02,390 --> 00:25:04,580
在块级别，这样我就有了一批

673
00:25:04,580 --> 00:25:06,470
元组 可以有开始结束时间戳，但

674
00:25:06,470 --> 00:25:07,730
现在这意味着当我开始

675
00:25:07,730 --> 00:25:08,270
查找时，

676
00:25:08,270 --> 00:25:10,549
我会花费更多的 CPU 资源来

677
00:25:10,549 --> 00:25:11,779
查找实际版本，因此我正在寻找，

678
00:25:11,779 --> 00:25:14,899
因此几乎

679
00:25:14,899 --> 00:25:16,159
每个人都总是为每个元组存储它，

680
00:25:16,159 --> 00:25:17,690
并且 这已经足够了，

681
00:25:17,690 --> 00:25:19,159
因为它为您提供了

682
00:25:19,159 --> 00:25:22,070
实现

683
00:25:22,070 --> 00:25:23,980
高并发或高并行所需的精细粒度，

684
00:25:23,980 --> 00:25:34,130
对不起，嗯，这很奇怪哦，

685
00:25:34,130 --> 00:25:36,520
好吧，对不起，

686
00:25:42,010 --> 00:25:47,169
我们会删掉它，对不起，这

687
00:25:47,169 --> 00:25:49,380
将永远持续下去，

688
00:25:51,990 --> 00:25:56,760
对不起，好吧，是的，你 有很棒的纸

689
00:25:56,760 --> 00:25:58,420
两碗

690
00:25:58,420 --> 00:26:03,580
好泰森给他好所以

691
00:26:03,580 --> 00:26:04,960
我们指出的第一件事是说我们要把它

692
00:26:04,960 --> 00:26:06,610
存储在我们的桌子上

693
00:26:06,610 --> 00:26:07,840
首先要指出的是我

694
00:26:07,840 --> 00:26:09,850
在这里有这样的列，就像版本

695
00:26:09,850 --> 00:26:11,650
ID 这仅用于

696
00:26:11,650 --> 00:26:14,080
说明目的，我们实际上

697
00:26:14,080 --> 00:26:15,250
不会将其存储在我们的真实系统中，

698
00:26:15,250 --> 00:26:16,870
因为我们使用开始和结束

699
00:26:16,870 --> 00:26:17,980
时间戳来确定

700
00:26:17,980 --> 00:26:20,020
这只是让我们

701
00:26:20,020 --> 00:26:26,320
了解的实际版本 nd 这在视觉上所以不，

702
00:26:26,320 --> 00:26:27,640
我们去好了是的，是的

703
00:26:27,640 --> 00:26:30,580
，所以交易 ID

704
00:26:30,580 --> 00:26:32,170
又是一个 64 位整数，我们将

705
00:26:32,170 --> 00:26:33,310
使用它来跟踪

706
00:26:33,310 --> 00:26:36,100
是否有人持有这个元组的锁，

707
00:26:36,100 --> 00:26:38,380
所以在 一开始

708
00:26:38,380 --> 00:26:40,960
它将是 0 然后我们有我们的开始

709
00:26:40,960 --> 00:26:43,270
和时间戳 所以

710
00:26:43,270 --> 00:26:46,120
这又将终止我们的每个

711
00:26:46,120 --> 00:26:48,070
版本 所以在这种情况下这里有

712
00:26:48,070 --> 00:26:49,330
一些事务

713
00:26:49,330 --> 00:26:51,880
在时间戳 1 创建了这个版本 因为这

714
00:26:51,880 --> 00:26:54,310
是 这是我们元组的最新版本，

715
00:26:54,310 --> 00:26:56,230
我们将结束时间戳设置为

716
00:26:56,230 --> 00:26:58,180
无穷大，因为它对

717
00:26:58,180 --> 00:27:01,020
时间戳 1 之后的任何人

718
00:27:01,020 --> 00:27:04,870
都是可见的，然后对于 FP 2 哦，我们还需要正确

719
00:27:04,870 --> 00:27:06,060
地包含读取

720
00:27:06,060 --> 00:27:09,040
时间戳，这 是我的时间戳

721
00:27:09,040 --> 00:27:11,770
将跟踪读取此版本的最后一个事务

722
00:27:11,770 --> 00:27:14,410
，因为如果重新时间戳大于我们的时间戳，我们

723
00:27:14,410 --> 00:27:15,820
必须使用它来确定我们是否

724
00:27:15,820 --> 00:27:18,070
尝试为此元组编写新版本

725
00:27:18,070 --> 00:27:21,220


726
00:27:21,220 --> 00:27:23,110
我们我们的文书 一个时间戳，

727
00:27:23,110 --> 00:27:25,210
那么我们知道将来有人

728
00:27:25,210 --> 00:27:27,130
阅读是沸腾，什么错过了我们的

729
00:27:27,130 --> 00:27:28,960
新版本，所以我们不得不

730
00:27:28,960 --> 00:27:31,930
中止，这

731
00:27:31,930 --> 00:27:34,930
是另一个总体主题的一个很好的例子，如果我们

732
00:27:34,930 --> 00:27:36,010
在整个学期

733
00:27:36,010 --> 00:27:38,890
都有 想要最小化

734
00:27:38,890 --> 00:27:40,600
我们必须

735
00:27:40,600 --> 00:27:43,030
在不同事务之间协调的全局数据结构的数量，因此

736
00:27:43,030 --> 00:27:45,040
通过在

737
00:27:45,040 --> 00:27:47,710
元组本身中记录 V 时间戳，我不必

738
00:27:47,710 --> 00:27:48,970
查找一些你知道会发生什么

739
00:27:48,970 --> 00:27:50,620
并说你知道的 什么

740
00:27:50,620 --> 00:27:52,210
交易容量我读过这个

741
00:27:52,210 --> 00:27:53,860
元组我看着元组我只

742
00:27:53,860 --> 00:27:57,060
知道你知道发生了什么

743
00:27:57,060 --> 00:27:58,810
好所以现在我们有一个交易

744
00:27:58,810 --> 00:28:01,060
出现并说它的给定

745
00:28:01,060 --> 00:28:03,520
时间戳10并且让我们阅读aa

746
00:28:03,520 --> 00:28:05,440
通过在梁上的右侧，

747
00:28:05,440 --> 00:28:07,690
所以芦苇很容易，您去

748
00:28:07,690 --> 00:28:11,680
检查

749
00:28:11,680 --> 00:28:13,810
事务 ID 是否为零，这意味着您知道

750
00:28:13,810 --> 00:28:15,640
实际上没有人写入此

751
00:28:15,640 --> 00:28:17,860
事务或此元组，

752
00:28:17,860 --> 00:28:19,830
然后检查 s  ee 可见

753
00:28:19,830 --> 00:28:23,320
性是否在您的时间戳范围内，

754
00:28:23,320 --> 00:28:25,990
因此我们的时间戳为 10 10

755
00:28:25,990 --> 00:28:27,760
介于 1 和亲和性之间，因此我们知道

756
00:28:27,760 --> 00:28:30,850
此版本对我们不可见，

757
00:28:30,850 --> 00:28:32,650
因此我们现在需要做的就是比较和

758
00:28:32,650 --> 00:28:35,590
交换 在重新时间戳上

759
00:28:35,590 --> 00:28:38,440
使用我们的时间戳正确更新它并且比较

760
00:28:38,440 --> 00:28:41,290
和交换失败谁在乎，因为那

761
00:28:41,290 --> 00:28:43,120
只是意味着你认识

762
00:28:43,120 --> 00:28:45,370
的某个人在未来

763
00:28:45,370 --> 00:28:47,650
或过去的某个人之后我也读过这个所以我们

764
00:28:47,650 --> 00:28:49,450
只是 再次检查并尝试

765
00:28:49,450 --> 00:28:51,190
更新它，如果它不太

766
00:28:51,190 --> 00:28:53,830
好，那么如果我们尝试

767
00:28:53,830 --> 00:28:56,500
阅读它并说有人带着

768
00:28:56,500 --> 00:28:58,720
时间戳 11 来并且我们进行比较和交换

769
00:28:58,720 --> 00:29:00,340
并且它失败了，我们又回来了。

770
00:29:00,340 --> 00:29:02,830
时间戳 10 小于 11 很好，我们

771
00:29:02,830 --> 00:29:04,540
不必像谁在乎另一个线程那样更新它

772
00:29:04,540 --> 00:29:05,860
阅读此内容 阅读

773
00:29:05,860 --> 00:29:08,530
与我们阅读相同的内容 所以现在

774
00:29:08,530 --> 00:29:11,050
我们要做正确的事情 所以

775
00:29:11,050 --> 00:29:12,490
我们要正确 在 B 上做对，

776
00:29:12,490 --> 00:29:13,990
所以我们需要做的第一件事就是

777
00:29:13,990 --> 00:29:16,300
做一个比较和 交换事务

778
00:29:16,300 --> 00:29:19,780
ID，以便我们可以锁定它，

779
00:29:19,780 --> 00:29:21,310
以便我们可以防止任何人

780
00:29:21,310 --> 00:29:23,770
在我们创建新版本时长期创建新版本，因此

781
00:29:23,770 --> 00:29:25,840
我们进行比较并将其交换设置为我们的

782
00:29:25,840 --> 00:29:26,500


783
00:29:26,500 --> 00:29:28,300
时间戳，因为简单性意味着我们

784
00:29:28,300 --> 00:29:30,490
持有 锁定这个元组，然后我们可以

785
00:29:30,490 --> 00:29:32,110
继续创建一个新版本，

786
00:29:32,110 --> 00:29:34,150
这也隐含地意味着我们也

787
00:29:34,150 --> 00:29:35,980
锁定了它，因为假设

788
00:29:35,980 --> 00:29:37,750
有一个从 this 到 this 的指针，

789
00:29:37,750 --> 00:29:39,760
没有人可以在不经过 b1 的情况下到达 B 2

790
00:29:39,760 --> 00:29:42,370
但是 我持有 b1 的锁，所以

791
00:29:42,370 --> 00:29:44,440
没有人可以跟进，所以我可以

792
00:29:44,440 --> 00:29:46,570
在这里做我需要的任何更新，然后现在

793
00:29:46,570 --> 00:29:49,450
我只是将这个结束时间戳翻转为 10

794
00:29:49,450 --> 00:29:51,910
，这将这个交易的可见性设置为

795
00:29:51,910 --> 00:29:55,630
正确，当我完成时我

796
00:29:55,630 --> 00:29:58,030
真的很好地进行比较和交换 这

797
00:29:58,030 --> 00:29:59,110
不需要我进行比较和交换 但是

798
00:29:59,110 --> 00:30:00,880
我不需要这样做

799
00:30:00,880 --> 00:30:02,950
你只需将它设置为 0 就完成了

800
00:30:02,950 --> 00:30:05,500
现在这个新版本已经安装 如果

801
00:30:05,500 --> 00:30:07,330
有人来 时间戳

802
00:30:07,330 --> 00:30:09,790
说大于 10 他们将

803
00:30:09,790 --> 00:30:12,940
能够英尺 你知道这个版本是

804
00:30:12,940 --> 00:30:16,830
清楚的 是的 是的

805
00:30:25,330 --> 00:30:37,970
，现在使用 ARB 好的 是的，所以读取

806
00:30:37,970 --> 00:30:39,140
时间戳总是及时向前推进，

807
00:30:39,140 --> 00:30:41,000
所以是时候因为你回到

808
00:30:41,000 --> 00:30:43,220
这里到达时间戳是一个说我

809
00:30:43,220 --> 00:30:45,409
做一个比较和交换正确的比较 交换

810
00:30:45,409 --> 00:30:46,909
说你必须先读取值

811
00:30:46,909 --> 00:30:48,830
然后你做比较和交换并说我

812
00:30:48,830 --> 00:30:50,360
认为值应该是一，如果它是

813
00:30:50,360 --> 00:30:51,529
一个将它设置为十

814
00:30:51,529 --> 00:30:53,690
所以如果我这样做并且它失败了，因为

815
00:30:53,690 --> 00:30:55,669
十五来了那么我会循环

816
00:30:55,669 --> 00:30:58,340
回来看看 现在的值是

817
00:30:58,340 --> 00:31:01,429
15，然后 15

818
00:31:01,429 --> 00:31:03,260
大于 10，所以如果它是 8，我不会尝试更新它

819
00:31:03,260 --> 00:31:05,630
10 大于 8

820
00:31:05,630 --> 00:31:22,159
所以是的，整行的新值

821
00:31:22,159 --> 00:31:23,929
回到我想我只是善良

822
00:31:23,929 --> 00:31:25,309
混淆就像厕所你

823
00:31:25,309 --> 00:31:26,510
实际上通过这个链接想象一个

824
00:31:26,510 --> 00:31:27,799
情况，如果你喜欢

825
00:31:27,799 --> 00:31:29,480
阅读这些内存位置，然后

826
00:31:29,480 --> 00:31:31,220
不知何故其他一些线程出现

827
00:31:31,220 --> 00:31:32,929
并且像以完全正确的顺序在你周围跳跃，

828
00:31:32,929 --> 00:31:34,539
所以你阅读正确的东西

829
00:31:34,539 --> 00:31:38,059
好的，所以这些问题是我怎么样 我

830
00:31:38,059 --> 00:31:41,029
实际上在原子上做这件事是正确的，

831
00:31:41,029 --> 00:31:42,350
它真的从这个

832
00:31:42,350 --> 00:31:45,559
交易 ID 开始，所以如果我在这个交易 ID 上进行比较和

833
00:31:45,559 --> 00:31:48,529
交换，我对我的交易 ID 说，

834
00:31:48,529 --> 00:31:51,440
那么没有其他人可以

835
00:31:51,440 --> 00:31:53,480
在我做正确的同时做正确的我

836
00:31:53,480 --> 00:31:55,429
持有锁 整个事情所以我

837
00:31:55,429 --> 00:31:57,649
不认为这是 64 位所以我只是你

838
00:31:57,649 --> 00:32:00,529
比较和交换 64 位我认为

839
00:32:00,529 --> 00:32:01,669
你的提议

840
00:32:01,669 --> 00:32:04,760
是锁定

841
00:32:04,760 --> 00:32:07,549
这个元组和那个元组的整个内存

842
00:32:07,549 --> 00:32:08,809
你会发生，这基本上

843
00:32:08,809 --> 00:32:11,899
就是这样做的权利，你不能

844
00:32:11,899 --> 00:32:14,510
在英特尔上进行比较和交换超过 128 位，

845
00:32:14,510 --> 00:32:17,120
所以这个事情要大得多

846
00:32:17,120 --> 00:32:18,770
，所以你不能在那个粒度上做一个 Tomic 的东西

847
00:32:18,770 --> 00:32:22,039
，所以通过设置这个 现在

848
00:32:22,039 --> 00:32:23,299
这将阻止其他任何人

849
00:32:23,299 --> 00:32:25,880
在我完成之前知道你知道的新版本时，

850
00:32:25,880 --> 00:32:28,429
所以现在你说得好，如果

851
00:32:28,429 --> 00:32:29,389
有人出现

852
00:32:29,389 --> 00:32:30,979
并试图阅读这篇文章

853
00:32:30,979 --> 00:32:32,989
，读者会做的第一件事就是看到

854
00:32:32,989 --> 00:32:34,700
这件事不是零，并且 退后，

855
00:32:34,700 --> 00:32:37,399
因为它的这件事是在没有

856
00:32:37,399 --> 00:32:39,379
它 正在写到现在，我不

857
00:32:39,379 --> 00:32:41,690
知道结束时间会是什么，

858
00:32:41,690 --> 00:32:43,219
所以我不知道我是应该

859
00:32:43,219 --> 00:32:44,749
阅读这个版本还是他即将创建的下一个版本

860
00:32:44,749 --> 00:32:46,879
，所以现在你说

861
00:32:46,879 --> 00:32:48,079
好吧，如果 读者来了

862
00:32:48,079 --> 00:32:52,609
，正确地看到零，然后开始

863
00:32:52,609 --> 00:32:55,129
阅读，然后这件事做了十次

864
00:32:55,129 --> 00:32:57,979
，而其他人仍在阅读

865
00:32:57,979 --> 00:33:00,320
发生的事情，谁在乎谁是对的，

866
00:33:00,320 --> 00:33:03,079
因为这个版本这个人

867
00:33:03,079 --> 00:33:03,619
不会离开

868
00:33:03,619 --> 00:33:05,959
那个在我之前得到他的读者，

869
00:33:05,959 --> 00:33:08,479
他们可以 仍然正确阅读，我们

870
00:33:08,479 --> 00:33:10,070
很好，因为这不会破坏

871
00:33:10,070 --> 00:33:11,209
该数据或做任何奇怪的事情，

872
00:33:11,209 --> 00:33:13,639
它可能会错过这个新

873
00:33:13,639 --> 00:33:16,899
版本，但随后遇到了我的下一个问题

874
00:33:16,899 --> 00:33:19,879
，我们如何真正知道这一点，我

875
00:33:19,879 --> 00:33:20,869
实际上是如何跟踪的 这件事

876
00:33:20,869 --> 00:33:22,879
实际上是正确提交的，因为我

877
00:33:22,879 --> 00:33:25,309
应该做的是，当我更新

878
00:33:25,309 --> 00:33:26,779
处女时，我将事务 ID 翻转

879
00:33:26,779 --> 00:33:30,169
为零，这意味着我释放了锁，但

880
00:33:30,169 --> 00:33:32,690
现在我怎么知道我

881
00:33:32,690 --> 00:33:34,159
是否应该提交此事务

882
00:33:34,159 --> 00:33:36,559
因此我应该

883
00:33:36,559 --> 00:33:42,019
正确地阅读这个版本，所以

884
00:33:42,019 --> 00:33:44,029
这里缺少的是一个辅助数据

885
00:33:44,029 --> 00:33:46,339
结构，它基本上必须

886
00:33:46,339 --> 00:33:48,859
跟踪事务的状态，

887
00:33:48,859 --> 00:33:51,679
这样当我去读的时候我说我

888
00:33:51,679 --> 00:33:55,879
在这种情况下读了我会很好

889
00:33:55,879 --> 00:33:57,289
跟踪它 我在这里阅读了这个版本

890
00:33:57,289 --> 00:34:00,950
你需要一种方法来

891
00:34:00,950 --> 00:34:02,570
知道创建那个版本的事务

892
00:34:02,570 --> 00:34:05,149
他们是否真的提交了

893
00:34:05,149 --> 00:34:06,950
因为你的开始时间戳

894
00:34:06,950 --> 00:34:08,839
与我在这里设置的事务 ID 相同

895
00:34:08,839 --> 00:34:10,039
所以我知道 在

896
00:34:10,039 --> 00:34:13,219
时间戳 10 的事务在我提交时创建此版本

897
00:34:13,219 --> 00:34:14,839
我需要知道

898
00:34:14,839 --> 00:34:16,309
他们是否也提交了因为如果他们

899
00:34:16,309 --> 00:34:17,960
没有提交他们还没有提交我读了

900
00:34:17,960 --> 00:34:19,069
一些我不应该读的东西我需要

901
00:34:19,069 --> 00:34:21,980
中止所以这里缺少什么和

902
00:34:21,980 --> 00:34:24,349
我们将在下周一的 hackathon 中看到

903
00:34:24,349 --> 00:34:26,089
微软在他们的

904
00:34:26,089 --> 00:34:28,489
MVCC 版本中有一个单独的数据

905
00:34:28,489 --> 00:34:29,569
结构，你有一个单独的数据结构，

906
00:34:29,569 --> 00:34:31,399
你有一个巨大的哈希表，我们只是

907
00:34:31,399 --> 00:34:32,960
跟踪它们都是什么

908
00:34:32,960 --> 00:34:35,239
正在运行的不同事务

909
00:34:35,239 --> 00:34:38,348
以及它们是否已提交

910
00:34:41,960 --> 00:34:46,020
这个问题是，如果我这样做，如果我只是将其

911
00:34:46,020 --> 00:34:48,869
保留为 10 个，那么有人会不会

912
00:34:48,869 --> 00:34:53,489
喜欢这样，但是因为基本上

913
00:34:53,489 --> 00:34:55,199
永远保持对这个版本的锁定，

914
00:34:55,199 --> 00:34:58,680
直到我提交 通过现在发布它，

915
00:34:58,680 --> 00:34:59,910
任何人都会过来阅读内容，

916
00:34:59,910 --> 00:35:02,760
因为您假设

917
00:35:02,760 --> 00:35:06,900
事务不会发生冲突或

918
00:35:06,900 --> 00:35:08,130
不会中止，因此您不会

919
00:35:08,130 --> 00:35:16,770
想要使用推测性读取是的所以

920
00:35:16,770 --> 00:35:18,240
这个问题是为什么不嵌入另一个

921
00:35:18,240 --> 00:35:21,390
提交 ID 所以这就是微软

922
00:35:21,390 --> 00:35:23,220
要做的事情有两种方法来做到这一点所以

923
00:35:23,220 --> 00:35:24,810
你只需要另一个提交 IDE

924
00:35:24,810 --> 00:35:27,000
但那是另一个 64 位字段 现在

925
00:35:27,000 --> 00:35:29,070
你正在添加更多空间

926
00:35:29,070 --> 00:35:30,810
Microsoft 要做的事情我们下

927
00:35:30,810 --> 00:35:33,630
节课见 是他们会捎带

928
00:35:33,630 --> 00:35:36,210
在我想我认为结束时间该死的

929
00:35:36,210 --> 00:35:38,369
虽然实际上使用

930
00:35:38,369 --> 00:35:39,660
时间戳中的一位来说明此交易

931
00:35:39,660 --> 00:35:42,150
实际上是否已提交，这

932
00:35:42,150 --> 00:35:44,400
就是他们的方式，这就是他们避免的方式，您

933
00:35:44,400 --> 00:35:45,650
应该返回 并更新内容，

934
00:35:45,650 --> 00:35:48,950
但这避免了有一个单独的列，

935
00:35:48,950 --> 00:35:51,240
所以我想跳到两

936
00:35:51,240 --> 00:35:52,380
阶段锁定还有很多要

937
00:35:52,380 --> 00:35:57,480
涵盖的，所以在 MP 2 PL 中我们摆脱了

938
00:35:57,480 --> 00:35:58,859
三个时间戳，但现在我们要添加

939
00:35:58,859 --> 00:36:01,290
这个重新计数和重新计数 本质

940
00:36:01,290 --> 00:36:04,470
上将充当元组上的共享锁，

941
00:36:04,470 --> 00:36:06,990
因此我的事务

942
00:36:06,990 --> 00:36:10,230
出现并且它想要读取我将

943
00:36:10,230 --> 00:36:12,630
同时对这两个字段进行比较和交换，

944
00:36:12,630 --> 00:36:14,520
所以这些都是

945
00:36:14,520 --> 00:36:17,310
64- 位字段 x86 允许您

946
00:36:17,310 --> 00:36:20,550
进行 128 位比较和交换，因此我

947
00:36:20,550 --> 00:36:22,560
会检查事务 ID 是否为 0

948
00:36:22,560 --> 00:36:24,900
，然后我还会自动将其

949
00:36:24,900 --> 00:36:27,270
更新为 1，这样您

950
00:36:27,270 --> 00:36:29,790
就可以设置 这也是 0，

951
00:36:29,790 --> 00:36:31,830
然后你将它加 1 作为

952
00:36:31,830 --> 00:36:35,820
结果，所以如果我这样做，那么这

953
00:36:35,820 --> 00:36:38,310
意味着我在这个元组上有一个共享锁

954
00:36:38,310 --> 00:36:41,369
，我可以

955
00:36:41,369 --> 00:36:43,020
和其他读者一起阅读它

956
00:36:43,020 --> 00:36:45,300
同时但现在当我

957
00:36:45,300 --> 00:36:47,970
做同样的事情时，我会做一个原子的 120

958
00:36:47,970 --> 00:36:50,220
位比较和 swa  p

959
00:36:50,220 --> 00:36:52,080
将事务 ID 和重新计数设置

960
00:36:52,080 --> 00:36:53,760
为 1 我实际上认为您

961
00:36:53,760 --> 00:36:56,640
不需要设置重新计数，但您绝对

962
00:36:56,640 --> 00:36:58,800
应该设置事务 ID，所以现在我

963
00:36:58,800 --> 00:37:00,870
对这个元组有了排他锁，我

964
00:37:00,870 --> 00:37:03,060
可以继续创建一个新的 版本我

965
00:37:03,060 --> 00:37:04,830
用我的时间戳更新结束

966
00:37:04,830 --> 00:37:06,480
时间戳然后一个新的

967
00:37:06,480 --> 00:37:08,850
比较和交换将其恢复

968
00:37:08,850 --> 00:37:29,280
为零并解锁它是的我认为

969
00:37:29,280 --> 00:37:34,860
开始你在说什么抱歉

970
00:37:34,860 --> 00:37:37,290
不不不不今天的锁根据

971
00:37:37,290 --> 00:37:41,340
需要获取锁 他们在成长

972
00:37:41,340 --> 00:37:43,530
阶段，但这并不一定意味着

973
00:37:43,530 --> 00:37:45,030
你会在交易开始时准确地获得它们

974
00:37:45,030 --> 00:37:54,570
，最后一位

975
00:37:54,570 --> 00:37:58,380
作家如何获胜，第一位作家获胜，

976
00:37:58,380 --> 00:38:00,500
总是第一位作家获胜，是的

977
00:38:00,500 --> 00:38:04,110
，这家伙怎么会赢，他

978
00:38:04,110 --> 00:38:05,940
写信给他 在这种情况下，其他任何人都会出现

979
00:38:05,940 --> 00:38:10,320
在这里，如果

980
00:38:10,320 --> 00:38:12,030
另一个交易出现并说

981
00:38:12,030 --> 00:38:14,190
他们有五个时间戳，他们

982
00:38:14,190 --> 00:38:17,280
会看到这个版本的

983
00:38:17,280 --> 00:38:19,710
可见性是一到十，五是

984
00:38:19,710 --> 00:38:22,560
在一到十之间，以便它知道 s

985
00:38:22,560 --> 00:38:24,630
有一些其他

986
00:38:24,630 --> 00:38:27,480
版本出现在时间戳 10 之后，

987
00:38:27,480 --> 00:38:29,910
在我之前物理上写出来，

988
00:38:29,910 --> 00:38:32,190
虽然逻辑上逻辑上它是在

989
00:38:32,190 --> 00:38:34,800
未来，但实际上它

990
00:38:34,800 --> 00:38:39,330
是物理时间的过去，所以我可能会

991
00:38:39,330 --> 00:38:41,580
与这个范围相交，因此

992
00:38:41,580 --> 00:38:42,840
之前还有另一位作家 它在我做之前到达这里

993
00:38:42,840 --> 00:38:44,790
，我必须中止第一个作者

994
00:38:44,790 --> 00:38:50,060
赢得这些时间戳告诉我们一切

995
00:38:51,490 --> 00:38:54,820
正常所以在前面的论文中你们阅读

996
00:38:54,820 --> 00:38:57,790
然后当我们最初编写它时

997
00:38:57,790 --> 00:38:59,350
重新计数中的事务ID我们

998
00:38:59,350 --> 00:39:01,780
实际上设置为32位 整数是对的，

999
00:39:01,780 --> 00:39:03,460
因为在我们编写它的时候，

1000
00:39:03,460 --> 00:39:05,410
我没有列出我们正在研究的 x86

1001
00:39:05,410 --> 00:39:07,800
不支持 128 位比较和交换，

1002
00:39:07,800 --> 00:39:11,230
所以我们把这两个放在一起，如果

1003
00:39:11,230 --> 00:39:12,190
你考虑一下，可能

1004
00:39:12,190 --> 00:39:14,170
不会 2 到 32 减一个

1005
00:39:14,170 --> 00:39:16,180
线程读取

1006
00:39:16,180 --> 00:39:18,400
相同的时间以完全相同的时间登上，因此将其设置为 32

1007
00:39:18,400 --> 00:39:21,640
位有点矫枉过正，但我们

1008
00:39:21,640 --> 00:39:23,020
仍然希望这件事

1009
00:39:23,020 --> 00:39:24,220
尽可能大，因此我们

1010
00:39:24,220 --> 00:39:27,610
必须 这件事你知道至少 32

1011
00:39:27,610 --> 00:39:30,910
位，也许 48 位，但即便

1012
00:39:30,910 --> 00:39:33,130
如此，如果你的系统

1013
00:39:33,130 --> 00:39:34,600
运行很长时间，你可以

1014
00:39:34,600 --> 00:39:35,980
很快烧掉这些事务 ID

1015
00:39:35,980 --> 00:39:36,480


1016
00:39:36,480 --> 00:39:39,670


1017
00:39:39,670 --> 00:39:42,580
，如果你得到了会发生什么 到交易 ID 的末尾，

1018
00:39:42,580 --> 00:39:45,820
您可以正确环绕，然后您

1019
00:39:45,820 --> 00:39:47,530
开始遇到问题，所以

1020
00:39:47,530 --> 00:39:50,440
假设我们有一个

1021
00:39:50,440 --> 00:39:53,530
带有一个元组的简单表，我们有这个

1022
00:39:53,530 --> 00:39:56,200
这个版本，所以我们有一些

1023
00:39:56,200 --> 00:39:57,370
交易 ID 会得到

1024
00:39:57,370 --> 00:39:58,840
交易 保险实际上是

1025
00:39:58,840 --> 00:40:02,050
2 - 31 - 1 所以它在

1026
00:40:02,050 --> 00:40:03,730
休息时做对了，做你所知道的设置

1027
00:40:03,730 --> 00:40:05,110
事务 ID 做

1028
00:40:05,110 --> 00:40:07,390
我们刚刚谈到的所有锁定的东西，然后它

1029
00:40:07,390 --> 00:40:09,070
在这里创建一个新版本，

1030
00:40:09,070 --> 00:40:11,740
并设置 现在的范围是

1031
00:40:11,740 --> 00:40:15,340
232 到 31 减 1，除了它是 0

1032
00:40:15,340 --> 00:40:17,500
但现在另一个交易出现

1033
00:40:17,500 --> 00:40:20,140
，现在它有时间戳 1，因为它

1034
00:40:20,140 --> 00:40:22,480
环绕，现在我创建了一个新

1035
00:40:22,480 --> 00:40:25,510
版本，但现在范围

1036
00:40:25,510 --> 00:40:27,820
都搞砸了，因为 这在 1

1037
00:40:27,820 --> 00:40:30,460
和无穷大之间，物理上是

1038
00:40:30,460 --> 00:40:32,560
在未来，但基于这些时间戳，

1039
00:40:32,560 --> 00:40:35,020
它在过去是不合逻辑的，所以现在

1040
00:40:35,020 --> 00:40:37,240
有人可能会过来尝试寻找

1041
00:40:37,240 --> 00:40:39,460
想要寻找此版本的人，但

1042
00:40:39,460 --> 00:40:41,070
最终可能会无处可去，

1043
00:40:41,070 --> 00:40:44,010
因为 这个东西在一个

1044
00:40:44,010 --> 00:40:49,960
不相交的范围内，所以这是

1045
00:40:49,960 --> 00:40:52,210
有问题的，所以如果你有一个 32 位

1046
00:40:52,210 --> 00:40:54,250
整数作为 Postgres 所做的事务 ID，

1047
00:40:54,250 --> 00:40:57,010
你

1048
00:40:57,010 --> 00:40:58,090
可以很快地完成它，即使它

1049
00:40:58,090 --> 00:40:59,680
在某些时候是一个 64 位整数，你 会

1050
00:40:59,680 --> 00:41:01,690
用完，你需要环绕并

1051
00:41:01,690 --> 00:41:04,480
处理它，所以有几种

1052
00:41:04,480 --> 00:41:05,520
不同的方法可以做

1053
00:41:05,520 --> 00:41:08,410


1054
00:41:08,410 --> 00:41:09,790


1055
00:41:09,790 --> 00:41:11,850


1056
00:41:11,850 --> 00:41:15,070
做

1057
00:41:15,070 --> 00:41:17,080
的是他们会

1058
00:41:17,080 --> 00:41:19,120
在每个小管的标题中添加一个额外的位，

1059
00:41:19,120 --> 00:41:21,250
通常是四个元组标题，他们

1060
00:41:21,250 --> 00:41:23,080
总是把它作为对称位空间拍出来，

1061
00:41:23,080 --> 00:41:25,000
就像将来如果你决定

1062
00:41:25,000 --> 00:41:26,350
哦，我们需要跟踪

1063
00:41:26,350 --> 00:41:27,790
关于每个元组的一些附加信息，

1064
00:41:27,790 --> 00:41:29,590
我们只是在那里添加了一个额外的位，我们

1065
00:41:29,590 --> 00:41:31,630
有空间，所以他们会添加

1066
00:41:31,630 --> 00:41:34,150
额外的位，表示特定

1067
00:41:34,150 --> 00:41:35,950
版本或 Pickler 元组不是

1068
00:41:35,950 --> 00:41:39,850
冻结的，任何

1069
00:41:39,850 --> 00:41:42,610
被认为是冻结的版本都意味着 它总是

1070
00:41:42,610 --> 00:41:44,680
会被视为过去，无论

1071
00:41:44,680 --> 00:41:47,230
您将时间戳与哪个交易 ID

1072
00:41:47,230 --> 00:41:49,480
进行比较，即使在这种

1073
00:41:49,480 --> 00:41:52,300
情况下，即使这个

1074
00:41:52,300 --> 00:41:54,010
时间戳可能大于您的 2

1075
00:41:54,010 --> 00:41:57,070
- 31 - 1 大于 1 如果我 设置

1076
00:41:57,070 --> 00:42:00,310
冻结位然后这将始终被

1077
00:42:00,310 --> 00:42:04,210
视为比这更旧，因此他们

1078
00:42:04,210 --> 00:42:07,000
这样做的方式是，如果他们系统

1079
00:42:07,000 --> 00:42:08,920
识别出您要进行

1080
00:42:08,920 --> 00:42:11,770
环绕，他们将运行他们的

1081
00:42:11,770 --> 00:42:14,140
垃圾收集器扫描的真空，并且 找到

1082
00:42:14,140 --> 00:42:16,900
旧版本并设置这个位标志，所以

1083
00:42:16,900 --> 00:42:19,810
有很多没有很多

1084
00:42:19,810 --> 00:42:21,850
在互联网上有几个帖子

1085
00:42:21,850 --> 00:42:23,110
你四处寻找，比如 Postgres

1086
00:42:23,110 --> 00:42:25,090
trent transaction rep 事务 ID

1087
00:42:25,090 --> 00:42:26,950
环绕问题有 ab 在很多

1088
00:42:26,950 --> 00:42:28,750
情况下，人们实际上会在白天

1089
00:42:28,750 --> 00:42:30,220
关闭 Postgres 上的垃圾收集器，

1090
00:42:30,220 --> 00:42:31,810
因为它会增加一些

1091
00:42:31,810 --> 00:42:33,520
开销，因此您试图让系统

1092
00:42:33,520 --> 00:42:34,960
在白天尽可能快地运行，

1093
00:42:34,960 --> 00:42:35,980
因为那时您的

1094
00:42:35,980 --> 00:42:37,120
大多数客户都在使用您的网站

1095
00:42:37,120 --> 00:42:39,700
和 然后突然之间你开始遇到

1096
00:42:39,700 --> 00:42:41,230
这个环绕问题，系统

1097
00:42:41,230 --> 00:42:42,940
吓坏了，因为它必须停止

1098
00:42:42,940 --> 00:42:44,200
让你知道接受新

1099
00:42:44,200 --> 00:42:45,700
连接检查新事务，

1100
00:42:45,700 --> 00:42:47,620
因为它不必环绕

1101
00:42:47,620 --> 00:42:50,890
但你不能运行的真空，因为

1102
00:42:50,890 --> 00:42:53,410
你 已经关闭它，然后你

1103
00:42:53,410 --> 00:42:54,430
基本上必须手动运行真空

1104
00:42:54,430 --> 00:42:56,020
，这可以做一个你知道的

1105
00:42:56,020 --> 00:42:59,110
完全压实或完全真空通过，

1106
00:42:59,110 --> 00:43:00,910
这可能需要几个小时，几个小时

1107
00:43:00,910 --> 00:43:05,590
甚至几天，所以这个帖子

1108
00:43:05,590 --> 00:43:07,330
很简单，就像 vac，

1109
00:43:07,330 --> 00:43:08,650
你会做你想做的事，

1110
00:43:08,650 --> 00:43:14,130
除非你把它关掉，所以这很清楚，

1111
00:43:14,130 --> 00:43:15,310


1112
00:43:15,310 --> 00:43:17,650
所以当你阅读

1113
00:43:17,650 --> 00:43:18,850
关于并发显示

1114
00:43:18,850 --> 00:43:21,280
或事务数据库系统的学术文献时 ms

1115
00:43:21,280 --> 00:43:23,260
重点总是放在这些

1116
00:43:23,260 --> 00:43:25,150
并发协议上，它

1117
00:43:25,150 --> 00:43:27,070
比 OCC II 或

1118
00:43:27,070 --> 00:43:29,800
时间戳排序更好，但我们

1119
00:43:29,800 --> 00:43:32,500
在他的论文中实际发现的是，

1120
00:43:32,500 --> 00:43:33,700
实际上其他事情实际上

1121
00:43:33,700 --> 00:43:36,700
更重要，特别是

1122
00:43:36,700 --> 00:43:39,450
重要的事情 很多是 Virgen 存储

1123
00:43:39,450 --> 00:43:41,770
机制或体系结构 系统的

1124
00:43:41,770 --> 00:43:43,950
虚拟存储组件

1125
00:43:43,950 --> 00:43:46,510
因此，正如他所说，我们将搜索

1126
00:43:46,510 --> 00:43:47,740
每个物理版本

1127
00:43:47,740 --> 00:43:48,790
，每个逻辑

1128
00:43:48,790 --> 00:43:50,680
对象都有多个物理

1129
00:43:50,680 --> 00:43:52,750
版本，因此有不同的方法 我们

1130
00:43:52,750 --> 00:43:55,540
实际上也存储了这些版本，但

1131
00:43:55,540 --> 00:43:56,770
在高层次上，它们将被

1132
00:43:56,770 --> 00:43:59,560
组织成一个无闩锁的链接，没有

1133
00:43:59,560 --> 00:44:02,050
单一的方向，并且

1134
00:44:02,050 --> 00:44:03,430
链接列表的头部

1135
00:44:03,430 --> 00:44:04,870
总是索引指向的内容或

1136
00:44:04,870 --> 00:44:06,640
某种情况 我正在查找一个元组，

1137
00:44:06,640 --> 00:44:08,530
我总是会落在头上，

1138
00:44:08,530 --> 00:44:09,610
然后你可以沿着

1139
00:44:09,610 --> 00:44:11,350
版本链遍历，尝试找到

1140
00:44:11,350 --> 00:44:13,210
正确的版本 t

1141
00:44:13,210 --> 00:44:17,170
对我来说是可见的，所以索引总是

1142
00:44:17,170 --> 00:44:18,130
指向头部，但头部

1143
00:44:18,130 --> 00:44:19,390
可能是最旧的到最新的，

1144
00:44:19,390 --> 00:44:21,610
这取决于使用什么方法，

1145
00:44:21,610 --> 00:44:25,330
所以这里讨论的不同方案

1146
00:44:25,330 --> 00:44:27,760
将决定

1147
00:44:27,760 --> 00:44:29,530
我们实际上要去哪里 存储以及

1148
00:44:29,530 --> 00:44:30,610
您要为

1149
00:44:30,610 --> 00:44:32,680
我们创建的每个版本存储的 Rex 有时会

1150
00:44:32,680 --> 00:44:34,090
存储 Delta 有时我们会存储

1151
00:44:34,090 --> 00:44:37,690
实际的整个元组，因此这三种

1152
00:44:37,690 --> 00:44:39,160
方法仅附加时间旅行

1153
00:44:39,160 --> 00:44:41,050
存储和不死存储，剧

1154
00:44:41,050 --> 00:44:43,390
透就是这样 Delta

1155
00:44:43,390 --> 00:44:45,970
存储是最好的方法，但

1156
00:44:45,970 --> 00:44:46,900
仍然有很多系统

1157
00:44:46,900 --> 00:44:49,090
，特别是 Postgres，只会追加，

1158
00:44:49,090 --> 00:44:52,390
所以这里会发生什么，因为

1159
00:44:52,390 --> 00:44:54,490
我们再次处于内存系统中，我们

1160
00:44:54,490 --> 00:44:56,050
希望避免使用全局数据

1161
00:44:56,050 --> 00:44:58,570
结构，所以 我们希望避免

1162
00:44:58,570 --> 00:45:01,750


1163
00:45:01,750 --> 00:45:03,910
在全局内存块的全局空间中为某些您知道的新版本分配空间，

1164
00:45:03,910 --> 00:45:05,770
因此我们要做的是

1165
00:45:05,770 --> 00:45:08,110
当线程创建新版本时，它们将

1166
00:45:08,110 --> 00:45:09,970
创建版本 像

1167
00:45:09,970 --> 00:45:11,740
线程本地存储或

1168
00:45:11,740 --> 00:45:14,050
只为该线程分配的内存中的 sions，您知道

1169
00:45:14,050 --> 00:45:15,460
这意味着 Virgin 链可以

1170
00:45:15,460 --> 00:45:17,050
跨多个线程遍历存储，

1171
00:45:17,050 --> 00:45:18,730
但这没关系，因为

1172
00:45:18,730 --> 00:45:20,110
一切总是只在

1173
00:45:20,110 --> 00:45:22,720
内存中，所以我们还需要考虑另一件事

1174
00:45:22,720 --> 00:45:24,850
当我们描述这些

1175
00:45:24,850 --> 00:45:27,460
不同的方法时，您不仅

1176
00:45:27,460 --> 00:45:30,250
知道它们有多快，而且知道

1177
00:45:30,250 --> 00:45:31,570
它们需要多少存储空间来

1178
00:45:31,570 --> 00:45:32,440
存储这些版本

1179
00:45:32,440 --> 00:45:34,119
以及实际实施它的工程工作

1180
00:45:34,119 --> 00:45:35,800
是什么，因为有些

1181
00:45:35,800 --> 00:45:38,260
显然比其他方法更容易，我们

1182
00:45:38,260 --> 00:45:39,550
需要考虑它的两个

1183
00:45:39,550 --> 00:45:42,069
方面是

1184
00:45:42,069 --> 00:45:43,450
找到我们查询所需的正确版本

1185
00:45:43,450 --> 00:45:45,400
的开销是多少，以及

1186
00:45:45,400 --> 00:45:48,069
随着时间的推移实际清理旧版本的开销，因为

1187
00:45:48,069 --> 00:45:49,660
它们像垃圾收集器一样累积，

1188
00:45:49,660 --> 00:45:52,780
所以去 每个都是一个

1189
00:45:52,780 --> 00:45:55,089
接一个所以仅附加存储的想法

1190
00:45:55,089 --> 00:45:57,520
是我们有一个表，就像

1191
00:45:57,520 --> 00:45:59,079
我们在其中

1192
00:45:59,079 --> 00:46:01,480
存储 ro tuples 的单个物理空间 并且每当

1193
00:46:01,480 --> 00:46:06,160
事务更新元组时，什么会

1194
00:46:06,160 --> 00:46:09,250
在同一个表空间中创建新的物理元组，

1195
00:46:09,250 --> 00:46:11,920
所以说我们的

1196
00:46:11,920 --> 00:46:14,290
事务可以更新 1 权，我们

1197
00:46:14,290 --> 00:46:16,900
只需将 a1 的副本附加到表中的某个

1198
00:46:16,900 --> 00:46:19,000
新空间或空闲槽中

1199
00:46:19,000 --> 00:46:21,520
然后我们现在只是更新

1200
00:46:21,520 --> 00:46:22,869
指向我们版本链的指针，说你知道

1201
00:46:22,869 --> 00:46:26,829
这是新版本，所以这

1202
00:46:26,829 --> 00:46:28,930
很简单，这就是

1203
00:46:28,930 --> 00:46:30,730
Postgres 在 1980 年代最初设计它的方式

1204
00:46:30,730 --> 00:46:33,490
，认为 interbase 做了同样的

1205
00:46:33,490 --> 00:46:34,660


1206
00:46:34,660 --> 00:46:37,930
事情，缺点显然是 你知道

1207
00:46:37,930 --> 00:46:40,119
我正在制作很多副本，

1208
00:46:40,119 --> 00:46:41,760
你知道我正在复制整个元组，

1209
00:46:41,760 --> 00:46:44,230
即使它可能只更新一个

1210
00:46:44,230 --> 00:46:46,990
字段，所以另一件重要的

1211
00:46:46,990 --> 00:46:49,660
事情也是指出

1212
00:46:49,660 --> 00:46:52,079
的是遍历原始链的顺序

1213
00:46:52,079 --> 00:46:54,670
对于我们的元组，所以在这个例子中，

1214
00:46:54,670 --> 00:46:57,160
我将从最旧到最新，所以我

1215
00:46:57,160 --> 00:46:59,619
开始这样我有一个 0 一个 1

1216
00:46:59,619 --> 00:47:01,359
然后一个 0 是链的头，

1217
00:47:01,359 --> 00:47:03,010
它指向一个 1 然后当我

1218
00:47:03,010 --> 00:47:05,980
创建一个 2 a 1 现在指向那个 但

1219
00:47:05,980 --> 00:47:07,390
我仍然会让我的索引仍然

1220
00:47:07,390 --> 00:47:09,730
指向 0 所以他们想要找到一个 2 我

1221
00:47:09,730 --> 00:47:12,430
必须跳到 0 检查是否有

1222
00:47:12,430 --> 00:47:14,050
开始 n 时间站，看看它是否

1223
00:47:14,050 --> 00:47:16,150
对我可见，如果没有，那么我跳到 1

1224
00:47:16,150 --> 00:47:18,420
做同样的事情 事情，他们跳到 2，

1225
00:47:18,420 --> 00:47:21,010
所以这可能不是最好的方法，

1226
00:47:21,010 --> 00:47:24,670
具体取决于您的应用程序，所以

1227
00:47:24,670 --> 00:47:26,170
再次从最旧到最新，您

1228
00:47:26,170 --> 00:47:27,910
总是遍历链以

1229
00:47:27,910 --> 00:47:30,339
找到最新版本，您也

1230
00:47:30,339 --> 00:47:33,490
可以从最新到最旧的位置

1231
00:47:33,490 --> 00:47:35,109
版本链始终

1232
00:47:35,109 --> 00:47:37,930
是刚创建的最新版本，因此

1233
00:47:37,930 --> 00:47:39,339
您知道不需要更新任何

1234
00:47:39,339 --> 00:47:41,380
以前的版本，只需添加新

1235
00:47:41,380 --> 00:47:43,630
版本，然后将其指针

1236
00:47:43,630 --> 00:47:44,859
指向旧版本版本链的头部，这

1237
00:47:44,859 --> 00:47:46,270


1238
00:47:46,270 --> 00:47:49,670
是显而易见的 有问题，所以

1239
00:47:49,670 --> 00:47:50,930
它更快地进行查找显然是

1240
00:47:50,930 --> 00:47:53,750
正确的，因为你是你想要

1241
00:47:53,750 --> 00:47:55,280
最新版本我会和她的

1242
00:47:55,280 --> 00:48:01,430
G 链的头部我完成了是的不是的我会

1243
00:48:01,430 --> 00:48:04,790
承担正确的索引是的所以

1244
00:48:04,790 --> 00:48:06,410
我们会再次 如果你有更多的幻灯片，但喜欢

1245
00:48:06,410 --> 00:48:07,970
所有的索引都指向

1246
00:48:07,970 --> 00:48:09,920
处女 Jane 的头部，如果每次

1247
00:48:09,920 --> 00:48:11,119
更新版本的头部都发生

1248
00:48:11,119 --> 00:48:12,710
变化，因为它是从最新到最旧的，

1249
00:48:12,710 --> 00:48:14,720
那么我现在必须更新所有索引

1250
00:48:14,720 --> 00:48:17,560
以正确地指向新的处女

1251
00:48:17,560 --> 00:48:20,240
Jane，实际上这就是

1252
00:48:20,240 --> 00:48:23,000
目的 与我的 Siegel 相比，这是

1253
00:48:23,000 --> 00:48:26,570
有问题的，所以我不是说一个

1254
00:48:26,570 --> 00:48:28,280
比另一个更好，在大多数情况下，

1255
00:48:28,280 --> 00:48:29,810
最新到最旧的 poly 是更好的方法

1256
00:48:29,810 --> 00:48:31,790
，因为大多数情况下，大多数

1257
00:48:31,790 --> 00:48:33,589
事务大多数查询都需要

1258
00:48:33,589 --> 00:48:38,140
最新版本，如果你关心的话

1259
00:48:38,140 --> 00:48:39,710
取决于您如何进行垃圾

1260
00:48:39,710 --> 00:48:41,900
收集或取决于您如何

1261
00:48:41,900 --> 00:48:43,250
查看是否有查看

1262
00:48:43,250 --> 00:48:45,349
旧数据的查询，这实际上使我可能会

1263
00:48:45,349 --> 00:49:05,900
更好，是的，因此这是一种

1264
00:49:05,900 --> 00:49:07,849
避免这种开销的方法，必须

1265
00:49:07,849 --> 00:49:10,130
每次都更新每个索引

1266
00:49:10,130 --> 00:49:13,700
最近不这样做，因为这可能会给

1267
00:49:13,700 --> 00:49:15,890
您带来误报，然后另一

1268
00:49:15,890 --> 00:49:17,869
张图片是如果您有一个

1269
00:49:17,869 --> 00:49:19,160
间接层，我们将在一秒钟内

1270
00:49:19,160 --> 00:49:21,050
看到可以避免该问题的情况，但是您

1271
00:49:21,050 --> 00:49:22,160
必须保持那是额外的，

1272
00:49:22,160 --> 00:49:24,260
你再次知道额外的存储

1273
00:49:24,260 --> 00:49:27,400
开销，它再次使间接访问

1274
00:49:27,400 --> 00:49:31,250
正常，所以在实践中我

1275
00:49:31,250 --> 00:49:33,800
认为这是更好的方法，如果

1276
00:49:33,800 --> 00:49:35,780
你只做一支笔，但这确实

1277
00:49:35,780 --> 00:49:37,609
有一些好处，你

1278
00:49:37,609 --> 00:49:41,150
不必更新索引，

1279
00:49:41,150 --> 00:49:43,190
所以另一种方法是

1280
00:49:43,190 --> 00:49:45,830
进行时间旅行存储，这里的想法

1281
00:49:45,830 --> 00:49:47,089
是当我们创建新版本

1282
00:49:47,089 --> 00:49:49,130
而不是将新版本附加

1283
00:49:49,130 --> 00:49:51,710
到我们的主表空间时，我们将

1284
00:49:51,710 --> 00:49:54,260
拥有另一个表 这看起来

1285
00:49:54,260 --> 00:49:55,820
与第一个完全相同，但它在

1286
00:49:55,820 --> 00:49:57,710
相同的列和行分配上具有相同的方案，

1287
00:49:57,710 --> 00:49:59,360


1288
00:49:59,360 --> 00:50:01,570
但那是我们将在

1289
00:50:01,570 --> 00:50:04,580
创建它们时放置处女所以在这种

1290
00:50:04,580 --> 00:50:07,490
情况下，我们正在做最新到最旧的

1291
00:50:07,490 --> 00:50:09,680
a2 在主表空间中，它

1292
00:50:09,680 --> 00:50:12,230
有一个指向时间旅行空间中的一个的指针，

1293
00:50:12,230 --> 00:50:14,000
所以现在如果我要

1294
00:50:14,000 --> 00:50:16,340
更新这个家伙，我首先要把它复制

1295
00:50:16,340 --> 00:50:18,710
到时间旅行空间，让

1296
00:50:18,710 --> 00:50:22,370
指针指向 a1 和 现在

1297
00:50:22,370 --> 00:50:23,990
覆盖 带有

1298
00:50:23,990 --> 00:50:26,690
我想要创建的新版本的主版本 我是

1299
00:50:26,690 --> 00:50:29,480
并且再次第一个作家获胜 我不

1300
00:50:29,480 --> 00:50:31,640
担心尝试

1301
00:50:31,640 --> 00:50:33,380
在同一时间更新此主版本的两个事务

1302
00:50:33,380 --> 00:50:35,570
我在这里做，然后任何人

1303
00:50:35,570 --> 00:50:37,070
尝试更新相同的东西都会

1304
00:50:37,070 --> 00:50:38,450
必须中止，因为它们会

1305
00:50:38,450 --> 00:50:42,560
与我发生冲突，所以现在如果我拥有权利

1306
00:50:42,560 --> 00:50:44,030
，然后将版本指针更新为

1307
00:50:44,030 --> 00:50:47,300
现在指向 a2 所以这

1308
00:50:47,300 --> 00:50:49,160
实际上是 Hana 所做的，这

1309
00:50:49,160 --> 00:50:50,570
实际上是续集服务器所做的很好，所以

1310
00:50:50,570 --> 00:50:52,850
我们会 看看续集服务器他们是如何

1311
00:50:52,850 --> 00:50:56,900
用 NPC 登录的，几周后我

1312
00:50:56,900 --> 00:50:59,120
认为他们这样做是因为它

1313
00:50:59,120 --> 00:51:01,910
是系统的副产品，最初并不是

1314
00:51:01,910 --> 00:51:03,200
为多版本设计的

1315
00:51:03,200 --> 00:51:05,660
，因此通过添加它，它

1316
00:51:05,660 --> 00:51:07,730
需要最少的更改

1317
00:51:07,730 --> 00:51:10,370
整体架构

1318
00:51:10,370 --> 00:51:11,750
你可以做的另一件事是

1319
00:51:11,750 --> 00:51:14,510
你可以让

1320
00:51:14,510 --> 00:51:18,620
主表实际上是一个不同的坦克，使用

1321
00:51:18,620 --> 00:51:20,570
与时间旅行表不同的存储模型，

1322
00:51:20,570 --> 00:51:21,980
因为你正在做

1323
00:51:21,980 --> 00:51:24,020
对此进行了大量更新，您可以

1324
00:51:24,020 --> 00:51:26,330
将其设置为烤肉或三角洲

1325
00:51:26,330 --> 00:51:29,780
商店烤肉或时间旅行

1326
00:51:29,780 --> 00:51:31,280
磁带，因为这些就像旧

1327
00:51:31,280 --> 00:51:33,080
版本一样，随着时间的流逝，您可以将

1328
00:51:33,080 --> 00:51:34,940
它们转换为列存储，如果您需要，可以这样

1329
00:51:34,940 --> 00:51:36,860
要正确读取旧数据，

1330
00:51:36,860 --> 00:51:38,810
您可以通过柱状布局访问它，该

1331
00:51:38,810 --> 00:51:42,650
布局速度更快，

1332
00:51:42,650 --> 00:51:44,300
一次又一次，所以最后一个将是我

1333
00:51:44,300 --> 00:51:45,970
认为更好的方法是做

1334
00:51:45,970 --> 00:51:48,950
Delta 存储，这里的想法是，

1335
00:51:48,950 --> 00:51:52,040
而不是 每次都复制原始

1336
00:51:52,040 --> 00:51:54,020
版本然后对其

1337
00:51:54,020 --> 00:51:56,510
进行更改，我们只需要记录

1338
00:51:56,510 --> 00:51:58,460
我们所做的更改并

1339
00:51:58,460 --> 00:52:00,950
正确销毁该信息，因此如果

1340
00:52:00,950 --> 00:52:03,440
我要更新一个并在其中设置一个副本，

1341
00:52:03,440 --> 00:52:04,040


1342
00:52:04,040 --> 00:52:06,520
我会 在内存中的某个空间有一个 Delta 记录，

1343
00:52:06,520 --> 00:52:09,770
它说这

1344
00:52:09,770 --> 00:52:11,150
是我所做的更改，所以这里是此表

1345
00:52:11,150 --> 00:52:13,110
的旧值

1346
00:52:13,110 --> 00:52:15,210
并更新它

1347
00:52:15,210 --> 00:52:17,430
，现在指针

1348
00:52:17,430 --> 00:52:19,950
再次指向该 Delta 信息我

1349
00:52:19,950 --> 00:52:21,450
要 保持不变 开始和

1350
00:52:21,450 --> 00:52:22,920
时间戳就像我以前和

1351
00:52:22,920 --> 00:52:25,530
一个普通的元组一样，但我开始的唯一

1352
00:52:25,530 --> 00:52:27,330
事情是这个 Delta 信息

1353
00:52:27,330 --> 00:52:30,990
就像一个 DIF，你现在明白了，如果

1354
00:52:30,990 --> 00:52:32,610
我想做一个查找并说找到一个

1355
00:52:32,610 --> 00:52:34,740
旧版本 我只是遵循

1356
00:52:34,740 --> 00:52:37,230
Virgin 链并重放所有日志

1357
00:52:37,230 --> 00:52:39,840
条目或 Delta 记录，让我

1358
00:52:39,840 --> 00:52:41,340
回到我应该为那个版本所做的状态，

1359
00:52:41,340 --> 00:52:43,710
如果我

1360
00:52:43,710 --> 00:52:45,960
有一千个发言权或水手

1361
00:52:45,960 --> 00:52:48,720
在我的表中有一千个列， 我只更新

1362
00:52:48,720 --> 00:52:51,270
其中一个然后而不是

1363
00:52:51,270 --> 00:52:53,220
每次都复制所有一千列

1364
00:52:53,220 --> 00:52:56,130
我可以只存储

1365
00:52:56,130 --> 00:52:58,340
被更改的一列属性

1366
00:52:58,340 --> 00:53:01,200
所以这就是 Oracle 所做的就是我的

1367
00:53:01,200 --> 00:53:03,450
Siegel 所做的我认为这是和是

1368
00:53:03,450 --> 00:53:04,950
什么 我们现在在我们的系统中这样做这

1369
00:53:04,950 --> 00:53:07,400
是更好的方法对这些再次

1370
00:53:07,400 --> 00:53:09,090
计算它更昂贵

1371
00:53:09,090 --> 00:53:11,910
因为我必须基本上

1372
00:53:11,910 --> 00:53:14,400
重播日志或增量以使我

1373
00:53:14,400 --> 00:53:15,420
回到正确的状态我应该

1374
00:53:15,420 --> 00:53:18,150
在我想要做的时候为我的元组做 查找 m

1375
00:53:18,150 --> 00:53:19,470
大多数时候，虽然您只需要

1376
00:53:19,470 --> 00:53:21,420
阅读最新版本，那只是您

1377
00:53:21,420 --> 00:53:22,710
知道所有数据就在那里，您已经

1378
00:53:22,710 --> 00:53:25,020
完成了，但您最终也存储了更少的

1379
00:53:25,020 --> 00:53:26,490
空间，这也可以改善您的现金

1380
00:53:26,490 --> 00:53:28,920
现金位置或减少

1381
00:53:28,920 --> 00:53:30,990
压力 缓存尽可能将大量数据保存在内存中，

1382
00:53:30,990 --> 00:53:33,390
因此有一个很大的好处

1383
00:53:33,390 --> 00:53:39,960
是，问题是如果

1384
00:53:39,960 --> 00:53:41,430
我的很多事务都在进行扫描并且

1385
00:53:41,430 --> 00:53:45,870
其中一些正在更新为什么它

1386
00:53:45,870 --> 00:53:56,940
会非常慢，就像在真实的

1387
00:53:56,940 --> 00:54:01,100
数据库系统中一样 大多数时候，

1388
00:54:01,100 --> 00:54:03,360
你不会更新每一个元组，

1389
00:54:03,360 --> 00:54:05,460
所以说我大部分时间都在对整个表进行特殊扫描，

1390
00:54:05,460 --> 00:54:08,340
我只是

1391
00:54:08,340 --> 00:54:10,050
要遍历主表空间，

1392
00:54:10,050 --> 00:54:11,820
而不必遵循 Virgin

1393
00:54:11,820 --> 00:54:14,010
如果我必须跟随

1394
00:54:14,010 --> 00:54:16,410
Virgin 是的，那么你知道

1395
00:54:16,410 --> 00:54:18,750
计算惩罚，现在跟随这个

1396
00:54:18,750 --> 00:54:21,270
指针并重播增量以使我

1397
00:54:21,270 --> 00:54:23,220
回到正确的状态，大多数时候

1398
00:54:23,220 --> 00:54:24,550
我不这样做

1399
00:54:24,550 --> 00:54:27,440
我会说 还有两个我

1400
00:54:27,440 --> 00:54:31,100
认为取决于 ng 在任何架构师

1401
00:54:31,100 --> 00:54:34,580
系统上，但就像你去进行更新一样

1402
00:54:34,580 --> 00:54:35,780
，你已经开始生成

1403
00:54:35,780 --> 00:54:37,880
这个增量，实际上这就是

1404
00:54:37,880 --> 00:54:39,680
你无论如何都要注销磁盘的东西，所以

1405
00:54:39,680 --> 00:54:41,210
你最好只

1406
00:54:41,210 --> 00:54:44,840
在内存中记录你知道的 作为 Delta 记录，因此

1407
00:54:44,840 --> 00:54:46,400


1408
00:54:46,400 --> 00:54:48,950
当您知道何时创建版本时，您无需做任何额外的工作来制作副本，

1409
00:54:48,950 --> 00:54:50,630
因此这种权衡

1410
00:54:50,630 --> 00:54:52,520
绝对正确，就像资源一样

1411
00:54:52,520 --> 00:54:53,840
，您想要帮助哪些资源我

1412
00:54:53,840 --> 00:54:56,060
认为科学证明

1413
00:54:56,060 --> 00:54:59,180
这种方法实际上会使

1414
00:54:59,180 --> 00:55:00,800
米饭走得更快，而笔或您

1415
00:55:00,800 --> 00:55:03,230
为读取付费并不

1416
00:55:03,230 --> 00:55:04,580
重要，那么获得正确的好处是不值得的，而且

1417
00:55:04,580 --> 00:55:06,470
您的

1418
00:55:06,470 --> 00:55:09,110
存储空间更少，垃圾收集

1419
00:55:09,110 --> 00:55:10,880
在此也更容易 世界也是如此，因为我只

1420
00:55:10,880 --> 00:55:12,560
需要通过这件事来清理它

1421
00:55:12,560 --> 00:55:14,000
我从未接触过主表，

1422
00:55:14,000 --> 00:55:16,780
因为那总是最新版本

1423
00:55:16,780 --> 00:55:37,190
是的所以这是一个很好的观点

1424
00:55:37,190 --> 00:55:42,260
所以如果说我有一千个元组并且我

1425
00:55:42,260 --> 00:55:45,050
有一堆Delta的每个 更新

1426
00:55:45,050 --> 00:55:47,420
一个 separ 属性，我是否需要

1427
00:55:47,420 --> 00:55:49,070
回到过去很远才能找到正确的

1428
00:55:49,070 --> 00:55:52,970
版本，以便您处理

1429
00:55:52,970 --> 00:55:54,770
垃圾收集的方式，您尝试

1430
00:55:54,770 --> 00:55:58,040
欺骗或压缩甚至

1431
00:55:58,040 --> 00:55:59,740
Delta Virgin Jane

1432
00:55:59,740 --> 00:56:05,530
我们会尽快 覆盖下周是的 是的

1433
00:56:07,590 --> 00:56:09,060
问题是如果你正在训练多个

1434
00:56:09,060 --> 00:56:10,230
熟练的飞碟 确定它是一个 Delta

1435
00:56:10,230 --> 00:56:11,940
是的 所以我实际上只有一个我们

1436
00:56:11,940 --> 00:56:13,860
会重视但是是的，对于

1437
00:56:13,860 --> 00:56:16,110
我修改的每个属性，它都会在一个范围内

1438
00:56:16,110 --> 00:56:27,900
做一个记录 是的，所以这可能

1439
00:56:27,900 --> 00:56:30,090
是未提交的，这也

1440
00:56:30,090 --> 00:56:32,550
可以在未来写出来，这不是

1441
00:56:32,550 --> 00:56:34,140
我没有，但我不应该看到因为这

1442
00:56:34,140 --> 00:56:35,670
不是我的快照，所以

1443
00:56:35,670 --> 00:56:37,110
如果我是什么，我必须回到过去

1444
00:56:37,110 --> 00:56:43,620
实际上对我来说很酷

1445
00:56:43,620 --> 00:56:48,260
所以嗯所以还有一个额外的问题，尽管

1446
00:56:48,260 --> 00:56:51,840
如果你只做一支笔，这就是

1447
00:56:51,840 --> 00:56:53,040
为什么我认为 Delta 故事更好的是

1448
00:56:53,040 --> 00:56:58,380
，如果现在你有字符串

1449
00:56:58,380 --> 00:57:00,600
值存储在口头

1450
00:57:00,600 --> 00:57:03,870
每次我创建一个墨水数据池

1451
00:57:03,870 --> 00:57:08,190
新版本 II 必须复制

1452
00:57:08,190 --> 00:57:12,060
这个元组或那种非常

1453
00:57:12,060 --> 00:57:16,020
长的数据，以便我的下一个

1454
00:57:16,020 --> 00:57:20,010
版本可以有自己的指针，因为

1455
00:57:20,010 --> 00:57:22,680
如果我开始进行垃圾

1456
00:57:22,680 --> 00:57:24,690
收集并清理一个，因为我

1457
00:57:24,690 --> 00:57:26,730
金枪鱼现在是最新版本，如果这个

1458
00:57:26,730 --> 00:57:29,070
东西指向这个，我去

1459
00:57:29,070 --> 00:57:31,680
清理它然后现在我的指针指向

1460
00:57:31,680 --> 00:57:34,140
任何东西，这很糟糕，所以这很

1461
00:57:34,140 --> 00:57:35,100
糟糕，所以这意味着

1462
00:57:35,100 --> 00:57:36,990
每次即使我不更新这个

1463
00:57:36,990 --> 00:57:39,900
我 根本不要使用这个字符串我

1464
00:57:39,900 --> 00:57:41,580
仍在制作所有字符串值的副本，

1465
00:57:41,580 --> 00:57:44,760
所以显然处理这个问题的一种方法

1466
00:57:44,760 --> 00:57:46,500
是

1467
00:57:46,500 --> 00:57:48,870
在口头链接数据中添加一个引用计数器，以便

1468
00:57:48,870 --> 00:57:51,660
当我知道有多少个指针有

1469
00:57:51,660 --> 00:57:52,860
多少个版本时 实际上指向这个

1470
00:57:52,860 --> 00:57:56,130
所以如果我去清理这个第一个

1471
00:57:56,130 --> 00:57:58,260
版本并且我减少计数器并且

1472
00:57:58,260 --> 00:57:59,550
仍然大于零我知道

1473
00:57:59,550 --> 00:58:01,620
那里有人指向

1474
00:58:01,620 --> 00:58:03,840
这个字符串我非常不同的数据池，

1475
00:58:03,840 --> 00:58:08,310
我不应该继续 并清理它的

1476
00:58:08,310 --> 00:58:10,080
缺点 呃，这实际上

1477
00:58:10,080 --> 00:58:12,630
是我们在旧的 Peloton 系统中尝试过的，

1478
00:58:12,630 --> 00:58:15,630
缺点是因为现在

1479
00:58:15,630 --> 00:58:18,900
我会跟踪是否有多个

1480
00:58:18,900 --> 00:58:21,070
版本指向这个

1481
00:58:21,070 --> 00:58:22,830
我实际上不知道它们在哪里所以

1482
00:58:22,830 --> 00:58:25,660
如果我需要移动 这块

1483
00:58:25,660 --> 00:58:27,250
内存中的数据就像我开始

1484
00:58:27,250 --> 00:58:30,130
压缩我喜欢的长度数据池

1485
00:58:30,130 --> 00:58:32,260
然后我必须进行顺序扫描并

1486
00:58:32,260 --> 00:58:34,330
尝试找到元组的一个版本

1487
00:58:34,330 --> 00:58:35,950
或两者的书籍版本

1488
00:58:35,950 --> 00:58:38,350
实际上指向这个所以这个

1489
00:58:38,350 --> 00:58:39,820
事实证明这是一个坏主意，这

1490
00:58:39,820 --> 00:58:41,460
是我们很快放弃

1491
00:58:41,460 --> 00:58:43,450
的东西，这是字典压缩的一种协同作用，

1492
00:58:43,450 --> 00:58:44,800


1493
00:58:44,800 --> 00:58:46,300
因为不是将指向某些内容的指针存储

1494
00:58:46,300 --> 00:58:48,400
在非常类似的数据池中，

1495
00:58:48,400 --> 00:58:50,710
我将拥有一个字典代码，

1496
00:58:50,710 --> 00:58:51,970
然后我可以 再次查找并

1497
00:58:51,970 --> 00:58:56,200
找到实际值是什么，但

1498
00:58:56,200 --> 00:58:59,500
至少在这种情况下，您知道如果您正在

1499
00:58:59,500 --> 00:59:01,660
压缩数据，那么它

1500
00:59:01,660 --> 00:59:04,570
通常是冷数据，因此

1501
00:59:04,570 --> 00:59:05,950
您不必清理数据

1502
00:59:05,950 --> 00:59:06,520
很多时候

1503
00:59:06,520 --> 00:59:22,900
是 不 所以再次成员上一堂课 我

1504
00:59:22,900 --> 00:59:26,350
谈到了如何有固定

1505
00:59:26,350 --> 00:59:27,850
长度的数据池和口头日期的

1506
00:59:27,850 --> 00:59:29,050
池 所以我们所有的元组

1507
00:59:29,050 --> 00:59:30,670
好吧 我要尝试驻留在

1508
00:59:30,670 --> 00:59:32,080
修复链接中 好吧 我必须驻留固定

1509
00:59:32,080 --> 00:59:33,310
长度的数据池 这就像

1510
00:59:33,310 --> 00:59:36,100
它们的位置，但是因为我们希望

1511
00:59:36,100 --> 00:59:37,630
每个元组的所有大小都是

1512
00:59:37,630 --> 00:59:39,640
固定长度，任何可能是

1513
00:59:39,640 --> 00:59:41,200
可变长度的东西都必须存储在

1514
00:59:41,200 --> 00:59:43,840
单独的数据池中，所以在我的固定

1515
00:59:43,840 --> 00:59:44,980
长度数据中，而不是实际存储

1516
00:59:44,980 --> 00:59:48,420
我存储的字符串 一个指向右边字符串的指针

1517
00:59:48,420 --> 00:59:50,410
，这是另一块

1518
00:59:50,410 --> 00:59:52,210
单独管理的内存，

1519
00:59:52,210 --> 00:59:54,190
我在这里想说明的是，

1520
00:59:54,190 --> 00:59:56,710
一方面我们可以

1521
00:59:56,710 --> 00:59:58,150
一遍又一遍地复制字符串，每个精子

1522
00:59:58,150 --> 00:59:59,380
都是单音符版本，因为每个

1523
00:59:59,380 --> 01:00:00,810
这些家伙需要有一个唯一的指针，

1524
01:00:00,810 --> 01:00:02,950
但这显然会很浪费，

1525
01:00:02,950 --> 01:00:04,150
因为如果我不更新

1526
01:00:04,150 --> 01:00:05,920
我无缘无故复制的字符串，并且如果我的

1527
01:00:05,920 --> 01:00:07,990
字符串很大，那么这将变得

1528
01:00:07,990 --> 01:00:10,390
昂贵 y 很快，因此您可以尝试

1529
01:00:10,390 --> 01:00:12,670
通过

1530
01:00:12,670 --> 01:00:14,260
将引用计数器添加到对您存储

1531
01:00:14,260 --> 01:00:15,880
的每一件事的票价空白数据池的引用中来共享指针，

1532
01:00:15,880 --> 01:00:18,130
但现在的

1533
01:00:18,130 --> 01:00:19,600
问题是，如果我曾经尝试移动这些

1534
01:00:19,600 --> 01:00:21,400
数据，我不会” 不知道还有什么

1535
01:00:21,400 --> 01:00:23,320
指向它，我可以让你知道

1536
01:00:23,320 --> 01:00:27,390
损坏的指针是的，

1537
01:00:27,960 --> 01:00:29,800
尤其是不能使用逻辑

1538
01:00:29,800 --> 01:00:30,700
保证，这就是字典

1539
01:00:30,700 --> 01:00:32,050
压缩本质上所做的，我们将

1540
01:00:32,050 --> 01:00:35,140
在几周内介绍它，

1541
01:00:35,140 --> 01:00:36,790
我很难像这样平衡 当你们

1542
01:00:36,790 --> 01:00:38,680
现在需要知道未来会发生什么的时候，

1543
01:00:38,680 --> 01:00:39,280


1544
01:00:39,280 --> 01:00:41,050
你解决这个问题的字典承认

1545
01:00:41,050 --> 01:00:47,140
可能需要得到两个

1546
01:00:47,140 --> 01:00:50,530
碳运动所以碳吸力的想法

1547
01:00:50,530 --> 01:00:52,510
再次就像 GCE

1548
01:00:52,510 --> 01:00:55,560
下的 JVM 我们需要找到

1549
01:00:55,560 --> 01:00:57,370
回收的

1550
01:00:57,370 --> 01:00:59,320
物理版本粗体和物理版本是

1551
01:00:59,320 --> 01:01:01,150
我们知道没有活动事务

1552
01:01:01,150 --> 01:01:03,880
正在运行可以看到该版本正确的版本，

1553
01:01:03,880 --> 01:01:05,860
因为它是过去的并且所有新的

1554
01:01:05,860 --> 01:01:07,060
时间都会污染所有新事务 ha

1555
01:01:07,060 --> 01:01:08,590
Sam 将来有一段时间，他们

1556
01:01:08,590 --> 01:01:10,780
无法访问它，或者版本是由

1557
01:01:10,780 --> 01:01:12,250
后来被中止的事务创建的，

1558
01:01:12,250 --> 01:01:14,440
我们知道并且没有人会阅读它，我们

1559
01:01:14,440 --> 01:01:16,420
必须继续进行清理，因此

1560
01:01:16,420 --> 01:01:18,400
我们在不同的设计阶段 需要

1561
01:01:18,400 --> 01:01:20,590
注意如何找到过期

1562
01:01:20,590 --> 01:01:22,360
版本 如何确定

1563
01:01:22,360 --> 01:01:23,830
回收一段内存是否安全

1564
01:01:23,830 --> 01:01:25,720
以及在哪里实际查找

1565
01:01:25,720 --> 01:01:27,910
它们 所以我们将重点关注

1566
01:01:27,910 --> 01:01:30,700
如何查找它们 我们将介绍 这

1567
01:01:30,700 --> 01:01:32,380
一点，但我们将

1568
01:01:32,380 --> 01:01:34,870
在下周三 下周三 下周三我们

1569
01:01:34,870 --> 01:01:36,280
将在整个讲座中讨论

1570
01:01:36,280 --> 01:01:37,570
我们如何在 MVCC 中实际进行垃圾收集，

1571
01:01:37,570 --> 01:01:39,990
并详细了解这一点，

1572
01:01:39,990 --> 01:01:42,730
因此有两种方法可以做到这一点

1573
01:01:42,730 --> 01:01:43,990
元组级别或事务级别，

1574
01:01:43,990 --> 01:01:46,170
因此元组级别的想法是，

1575
01:01:46,170 --> 01:01:48,280
不会有任何中心

1576
01:01:48,280 --> 01:01:49,780
位置说这里

1577
01:01:49,780 --> 01:01:51,190
是我们可以清理的所有元组版本，

1578
01:01:51,190 --> 01:01:53,500
而是我们将

1579
01:01:53,500 --> 01:01:56,290
运行线程并且 做扫描，当

1580
01:01:56,290 --> 01:01:57,820
他们 遇到数据或遇到

1581
01:01:57,820 --> 01:01:59,140
我们声称的版本，

1582
01:01:59,140 --> 01:02:01,720
他们继续我们清理它们

1583
01:02:01,720 --> 01:02:03,040
我们可以使用单独的线程

1584
01:02:03,040 --> 01:02:04,780
或协作线程作为运行

1585
01:02:04,780 --> 01:02:06,790
查询然后事务级别的

1586
01:02:06,790 --> 01:02:09,340
想法是每个事务都会

1587
01:02:09,340 --> 01:02:11,260
跟踪

1588
01:02:11,260 --> 01:02:13,420
他们使他们无效并因此

1589
01:02:13,420 --> 01:02:15,520
可以回收的每个版本中，当

1590
01:02:15,520 --> 01:02:18,550
他们提交时，他们交出的是一组

1591
01:02:18,550 --> 01:02:21,400
指向这个垃圾桶的指针，

1592
01:02:21,400 --> 01:02:22,930
顺便说一下，这里有一些我

1593
01:02:22,930 --> 01:02:24,340
无效的东西，你应该继续

1594
01:02:24,340 --> 01:02:27,130
清理 它们是一个声音，

1595
01:02:27,130 --> 01:02:29,620
必须执行顺序扫描，所以让我们

1596
01:02:29,620 --> 01:02:30,760
先通过元组级别

1597
01:02:30,760 --> 01:02:33,040
，然后我再次吸尘，这个

1598
01:02:33,040 --> 01:02:34,180
想法是有单独的线程

1599
01:02:34,180 --> 01:02:37,000
将要运行，这些线程将进行

1600
01:02:37,000 --> 01:02:38,440
特殊扫描并尝试找到 旧

1601
01:02:38,440 --> 01:02:40,690
版本，所以当真空开始时，

1602
01:02:40,690 --> 01:02:41,710
我们必须仔细查看并说清楚

1603
01:02:41,710 --> 01:02:43,390
实际交易是什么，它们的时间戳是什么

1604
01:02:43,390 --> 01:02:46,380
，然后现在当我们扫描时，

1605
01:02:46,380 --> 01:02:48,400
我们将进行比较 e 我们看到

1606
01:02:48,400 --> 01:02:49,780
的所有版本的开始和时间立场，

1607
01:02:49,780 --> 01:02:52,180
并查看

1608
01:02:52,180 --> 01:02:55,030
是否指定了范围，它们不

1609
01:02:55,030 --> 01:02:58,240
与任何活动事务相交，因此

1610
01:02:58,240 --> 01:03:00,069
在这种情况下，我们

1611
01:03:00,069 --> 01:03:03,099
在 25 有 12 次时间戳的事务，因此我们

1612
01:03:03,099 --> 01:03:06,280
知道对于 范围 1 到 9 这两个

1613
01:03:06,280 --> 01:03:08,410
事务无法看到，因此

1614
01:03:08,410 --> 01:03:10,359
没有人可以看到这一点，因此

1615
01:03:10,359 --> 01:03:12,339
我们可以安全地继续回收此

1616
01:03:12,339 --> 01:03:16,750
内存，因此这可能会很昂贵，

1617
01:03:16,750 --> 01:03:18,430
例如对整个系统进行 winchell 扫描，

1618
01:03:18,430 --> 01:03:19,660
尤其是如果您 希望

1619
01:03:19,660 --> 01:03:22,810
这个东西一直运行，所以一个

1620
01:03:22,810 --> 01:03:25,210
简单的技巧就是跟踪一个

1621
01:03:25,210 --> 01:03:28,240
位图，上面写着

1622
01:03:28,240 --> 01:03:31,359
自上次运行以来所有逻辑修改的块，

1623
01:03:31,359 --> 01:03:34,180
因此当我只

1624
01:03:34,180 --> 01:03:35,650
需要扫描它时，我可以跳过

1625
01:03:35,650 --> 01:03:38,710
任何没有修改的东西，所以我的意思

1626
01:03:38,710 --> 01:03:40,869
是逻辑上是根据

1627
01:03:40,869 --> 01:03:42,609
我正在做的最旧的更新到最旧的

1628
01:03:42,609 --> 01:03:46,180
我可能会更新说我在

1629
01:03:46,180 --> 01:03:49,720
两个不同的块中有两个版本，它几乎是

1630
01:03:49,720 --> 01:03:52,210
最新的，我添加了一个新版本 ion

1631
01:03:52,210 --> 01:03:54,400
位于第二个块中，但现在我可以回收

1632
01:03:54,400 --> 01:03:56,710
第一个块中的旧版本，

1633
01:03:56,710 --> 01:03:59,319
所以我需要从逻辑上知道

1634
01:03:59,319 --> 01:04:01,780
回到版本更改中

1635
01:04:01,780 --> 01:04:03,280
的块，这里有我

1636
01:04:03,280 --> 01:04:07,240
应该检查的东西，而最新

1637
01:04:07,240 --> 01:04:10,150
到最老的你 会知道我添加了

1638
01:04:10,150 --> 01:04:11,680
我知道的新版本，但我需要

1639
01:04:11,680 --> 01:04:13,119
指向以前的头部，所以我知道那个

1640
01:04:13,119 --> 01:04:15,130
东西的位置，我可以

1641
01:04:15,130 --> 01:04:19,329
很容易地更新它，所以合作清理的

1642
01:04:19,329 --> 01:04:20,740
想法是我们不会有任何

1643
01:04:20,740 --> 01:04:22,420
单独的线程 可能如果我们

1644
01:04:22,420 --> 01:04:24,280
重新开始召唤它就在

1645
01:04:24,280 --> 01:04:26,440
我们的事务或查询开始运行

1646
01:04:26,440 --> 01:04:28,630
如果他们遇到所有版本我们

1647
01:04:28,630 --> 01:04:30,760
继续清理它们所以说

1648
01:04:30,760 --> 01:04:32,589
这个人运行他会做一个查找

1649
01:04:32,589 --> 01:04:36,190
和索引以找到键a 我们将

1650
01:04:36,190 --> 01:04:38,079
到达原始链的头部，

1651
01:04:38,079 --> 01:04:39,970
所以现在当我正在扫描以找到

1652
01:04:39,970 --> 01:04:41,349
我想要的正确版本时，我检查

1653
01:04:41,349 --> 01:04:42,970
了我正在做的时间戳，

1654
01:04:42,970 --> 01:04:44,980
看看它是否对我可见，但我

1655
01:04:44,980 --> 01:04:46,450
也知道这是怎么回事 任何活动事务的最旧时间戳的

1656
01:04:46,450 --> 01:04:50,020
高水位标记或低水位

1657
01:04:50,020 --> 01:04:52,150
标记的 rt

1658
01:04:52,150 --> 01:04:54,250
，如果我知道

1659
01:04:54,250 --> 01:04:56,890
该事物不可见，则该元组

1660
01:04:56,890 --> 01:04:58,480
对那个最旧的事务不可见，我

1661
01:04:58,480 --> 01:05:00,400
可以继续并 Garba 收集它 就

1662
01:05:00,400 --> 01:05:02,530
在那里，我继续扫描并可以

1663
01:05:02,530 --> 01:05:04,630
打印出任何内容，然后我还

1664
01:05:04,630 --> 01:05:06,130
必须更新索引现在指向我的

1665
01:05:06,130 --> 01:05:09,250
新版本链，因此这种方法的好处

1666
01:05:09,250 --> 01:05:10,960
是您不必

1667
01:05:10,960 --> 01:05:11,950
维护这些单独的后台

1668
01:05:11,950 --> 01:05:13,990
线程，但现在 您的查询

1669
01:05:13,990 --> 01:05:15,850
可能会运行得更慢，因为它们可能

1670
01:05:15,850 --> 01:05:18,370
会遇到一个长版本链，并且

1671
01:05:18,370 --> 01:05:19,720
您必须在

1672
01:05:19,720 --> 01:05:21,130
实际完成操作之前进行清理您的

1673
01:05:21,130 --> 01:05:24,250
查询合作清理的另一个问题

1674
01:05:24,250 --> 01:05:28,840
是什么是正确的，

1675
01:05:28,840 --> 01:05:30,520
它说只有

1676
01:05:30,520 --> 01:05:33,520
商店 在我们附近，但即便如此，宾果游戏也可能

1677
01:05:33,520 --> 01:05:35,430
会出现另一个问题，

1678
01:05:35,430 --> 01:05:38,200
是的，所以假设我创建了一个新

1679
01:05:38,200 --> 01:05:40,030
版本，然后没有人会再次返回

1680
01:05:40,030 --> 01:05:42,310
并读取该逻辑元组，但

1681
01:05:42,310 --> 01:05:43,780
现在我已经结束了 并坐在

1682
01:05:43,780 --> 01:05:46,150
那里没有人会得到所以

1683
01:05:46,150 --> 01:05:48,240
微软称这些尘土飞扬的角落和

1684
01:05:48,240 --> 01:05:50,140
基本上处理的方式是你

1685
01:05:50,140 --> 01:05:51,940
看看如果他也有东西运行

1686
01:05:51,940 --> 01:05:53,710
后台线程就去寻找

1687
01:05:53,710 --> 01:05:58,650
可能仍然坐在那里的东西是的，

1688
01:06:10,200 --> 01:06:13,300
是的，夸大其词是

1689
01:06:13,300 --> 01:06:15,760
我们的系统中是否有清洁度的概念，它可以

1690
01:06:15,760 --> 01:06:18,700
量化它，所以我之前说的例子

1691
01:06:18,700 --> 01:06:20,620
就像垃圾

1692
01:06:20,620 --> 01:06:23,620
抽吸需要时间一样，所以微软

1693
01:06:23,620 --> 01:06:25,900
在他们的论文中粗略估计

1694
01:06:25,900 --> 01:06:27,640
垃圾抽吸增加了

1695
01:06:27,640 --> 01:06:30,760
15% 的开销，如果在

1696
01:06:30,760 --> 01:06:32,350
白天我 希望 Mitra 实际上运行得尽可能快

1697
01:06:32,350 --> 01:06:33,610
我可能可能会

1698
01:06:33,610 --> 01:06:35,950
禁用垃圾收集系统

1699
01:06:35,950 --> 01:06:38,740
变得更脏然后当我想让

1700
01:06:38,740 --> 01:06:41,260
你知道也许在当天然后我运行

1701
01:06:41,260 --> 01:06:43,180
垃圾切割和燃烧更多的周期

1702
01:06:43,180 --> 01:06:44,500
但我有备用的你知道我

1703
01:06:44,500 --> 01:06:47,320
可以 用来清理东西通常

1704
01:06:47,320 --> 01:06:48,910
是人们关心的存储开销

1705
01:06:48,910 --> 01:06:50,050
，

1706
01:06:50,050 --> 01:06:51,910
如果你的 t 中有很多处女，你的空间很快就会用完

1707
01:06:51,910 --> 01:06:54,970
通过它们，我总是说，

1708
01:06:54,970 --> 01:06:56,620
就像清洁的概念一样

1709
01:06:56,620 --> 01:06:58,510
，必须是人类才能找到的更好的东西，

1710
01:06:58,510 --> 01:07:03,070
就像我通常

1711
01:07:03,070 --> 01:07:04,600
从垃圾问题中使用更少的线程一样，因为我

1712
01:07:04,600 --> 01:07:06,850
希望查询运行得更快，但随后又

1713
01:07:06,850 --> 01:07:07,660
有些推

1714
01:07:07,660 --> 01:07:08,500
后说 当我的空间不足时，

1715
01:07:08,500 --> 01:07:10,660
尤其是当我运行内存时，所以我

1716
01:07:10,660 --> 01:07:11,740
想要更加积极地清理事情

1717
01:07:11,740 --> 01:07:24,369
，所以像这样的开销有 15

1718
01:07:24,369 --> 01:07:27,490
% 是这样的，

1719
01:07:27,490 --> 01:07:29,349
因为想想我的职业生涯

1720
01:07:29,349 --> 01:07:31,630
现在运行速度较慢，因为 这家伙

1721
01:07:31,630 --> 01:07:33,010
本来可以说得好我不在乎

1722
01:07:33,010 --> 01:07:34,780
这些版本不是或回收

1723
01:07:34,780 --> 01:07:36,339
一点让我去得到我想要的东西

1724
01:07:36,339 --> 01:07:38,230
但它的实施是这样你

1725
01:07:38,230 --> 01:07:44,410
在你发现它们没问题时清理东西

1726
01:07:44,410 --> 01:07:46,420
另一个是交易 再次级别

1727
01:07:46,420 --> 01:07:48,130
我们将在

1728
01:07:48,130 --> 01:07:49,809
下周周三再次讨论这个想法是我的

1729
01:07:49,809 --> 01:07:51,700
事务运行我正在创建

1730
01:07:51,700 --> 01:07:53,859
版本因为我认为元组所以我

1731
01:07:53,859 --> 01:07:55,900
知道之前的旧版本是什么

1732
01:07:55,900 --> 01:07:58,030
所以我只是记录到 s 嘿嘿，顺便说一句，

1733
01:07:58,030 --> 01:07:59,619
这是这个事务，或者这是

1734
01:07:59,619 --> 01:08:01,569
这个版本，

1735
01:08:01,569 --> 01:08:02,859
这是我知道的开始结束时间戳，因为我必须

1736
01:08:02,859 --> 01:08:05,799
阅读它，如果我提交并

1737
01:08:05,799 --> 01:08:08,530
回收它，然后我们将它放入

1738
01:08:08,530 --> 01:08:09,910
队列中，然后垃圾收集器

1739
01:08:09,910 --> 01:08:12,190
将 在一些启动和一些

1740
01:08:12,190 --> 01:08:14,170
后台线程随着时间的推移进行清理，

1741
01:08:14,170 --> 01:08:19,179
因此对于这个垃圾

1742
01:08:19,179 --> 01:08:20,350
地牢不再像在协作清理中那样位于查询的关键路径上，

1743
01:08:20,350 --> 01:08:21,399


1744
01:08:21,399 --> 01:08:23,500
这意味着我们的查询

1745
01:08:23,500 --> 01:08:24,819
会运行得更快它可能最终会结束

1746
01:08:24,819 --> 01:08:26,410
创建订单的速度比

1747
01:08:26,410 --> 01:08:28,270
以前更快，因此我们实际上可能需要使用

1748
01:08:28,270 --> 01:08:29,620
多个线程并确保

1749
01:08:29,620 --> 01:08:32,410
及时清理内容，因此在

1750
01:08:32,410 --> 01:08:36,250
我们当前的系统中，我们今天这样做，但

1751
01:08:36,250 --> 01:08:37,899
我们只能进行单线程垃圾

1752
01:08:37,899 --> 01:08:39,460
收集，并且在某些情况下

1753
01:08:39,460 --> 01:08:41,439
人类所做的实验我们可以

1754
01:08:41,439 --> 01:08:43,689
很快地完成事务

1755
01:08:43,689 --> 01:08:45,339
，我们开始耗尽空间

1756
01:08:45,339 --> 01:08:47,279
，单线程实际上无法跟上，

1757
01:08:47,279 --> 01:08:50,290
所以我们将在接下来讨论更多关于这个的内容

1758
01:08:50,290 --> 01:08:52,810
好吧，最后一个非常

1759
01:08:52,810 --> 01:08:54,640
重要的是索引管理，我们

1760
01:08:54,640 --> 01:08:56,290
对我们的谈话进行了一些整理，但

1761
01:08:56,290 --> 01:08:58,060
基本上我们如何找到正确的

1762
01:08:58,060 --> 01:09:00,189
版本，这取决于

1763
01:09:00,189 --> 01:09:01,988
版本方案是什么以及我们

1764
01:09:01,988 --> 01:09:04,390
必须为宝贝做多少工作 重播增量或

1765
01:09:04,390 --> 01:09:06,520
版本链的顺序是什么，

1766
01:09:06,520 --> 01:09:08,589
所以主键索引总是

1767
01:09:08,589 --> 01:09:09,698
指向原始链的头部，

1768
01:09:09,698 --> 01:09:11,198
无论它是从最旧到

1769
01:09:11,198 --> 01:09:12,939
最新还是最新最旧，还是时间旅行

1770
01:09:12,939 --> 01:09:15,630
或 Delta 存储，它始终是头部

1771
01:09:15,630 --> 01:09:19,089
对，所以这只是意味着，

1772
01:09:19,089 --> 01:09:20,738
根据您所知道的内容，无论

1773
01:09:20,738 --> 01:09:21,640
我们做什么，

1774
01:09:21,640 --> 01:09:23,200
它们都会立即

1775
01:09:23,200 --> 01:09:24,939
得到我们想要的第一个版本，

1776
01:09:24,939 --> 01:09:26,170
或者可能必须遍历整个

1777
01:09:26,170 --> 01:09:28,960
事物，因此现在如果任何事务尝试

1778
01:09:28,960 --> 01:09:31,450
更新 以及元

1779
01:09:31,450 --> 01:09:34,120
组中主键中的属性，而不是

1780
01:09:34,120 --> 01:09:35,229
试图变得聪明并试图

1781
01:09:35,229 --> 01:09:38,350
维护不同的版本，或者您

1782
01:09:38,350 --> 01:09:40,569
知道

1783
01:09:40,569 --> 01:09:43,240
索引中相同逻辑条目的不同版本链，我们

1784
01:09:43,240 --> 01:09:44,859
只是要 将其视为

1785
01:09:44,859 --> 01:09:47,050
删除后插入，因此

1786
01:09:47,050 --> 01:09:48,520
即使从数据库系统的角度来看，它在概念上是相同的

1787
01:09:48,520 --> 01:09:51,550
元组，但

1788
01:09:51,550 --> 01:09:53,590
它现在是两个离散的

1789
01:09:53,590 --> 01:09:57,580
逻辑元组二级索引更

1790
01:09:57,580 --> 01:09:59,380
复杂，因为正如我

1791
01:09:59,380 --> 01:10:01,780
之前所说的那样，取决于是否

1792
01:10:01,780 --> 01:10:03,820
报告 是否

1793
01:10:03,820 --> 01:10:05,080
每次我们创建一个新版本时

1794
01:10:05,080 --> 01:10:07,570
都会变得非常昂贵，所以

1795
01:10:07,570 --> 01:10:09,760
有一篇很棒的博客文章

1796
01:10:09,760 --> 01:10:11,200
实际上正是在我们

1797
01:10:11,200 --> 01:10:12,850
从 uber 写这篇论文时发表的，它

1798
01:10:12,850 --> 01:10:14,500
谈到了他们

1799
01:10:14,500 --> 01:10:16,960
从 Postgres 到我的续集的旅程 真实的

1800
01:10:16,960 --> 01:10:19,570
故事是他们最初是从我的

1801
01:10:19,570 --> 01:10:21,220
续集开始 他们雇佣了一个真正

1802
01:10:21,220 --> 01:10:22,660
喜欢 Postgres 的人 所以他换了一个 Postgres

1803
01:10:22,660 --> 01:10:24,340
然后他们意识到这是一个错误

1804
01:10:24,340 --> 01:10:26,260
并切换回我的续集所以那

1805
01:10:26,260 --> 01:10:28,390
是非常昂贵的 他们只参加了这

1806
01:10:28,390 --> 01:10:30,100
门课程 他们得救了 很多钱，

1807
01:10:30,100 --> 01:10:32,380
所以他们谈论了很多

1808
01:10:32,380 --> 01:10:33,730
关于 Postgres 如何做

1809
01:10:33,730 --> 01:10:35,470
与我的续集不同的事情

1810
01:10:35,470 --> 01:10:36,970
但他们强调的主要事情之一是他们如何

1811
01:10:36,970 --> 01:10:38,980
实际管理

1812
01:10:38,980 --> 01:10:42,130
多版本系统中的二级索引，因为

1813
01:10:42,130 --> 01:10:43,990
Postgres 实际上会指向

1814
01:10:43,990 --> 01:10:45,760
原始链的头部，而我的

1815
01:10:45,760 --> 01:10:49,150
续集使用的是逻辑指针，所以

1816
01:10:49,150 --> 01:10:50,290
这是两个区别，所以逻辑

1817
01:10:50,290 --> 01:10:51,850
指针会 是某种

1818
01:10:51,850 --> 01:10:56,140
为元组固定的标识符，

1819
01:10:56,140 --> 01:10:58,030
然后我们就不必

1820
01:10:58,030 --> 01:11:00,640


1821
01:11:00,640 --> 01:11:02,890
在版本更改的物理位置发生

1822
01:11:02,890 --> 01:11:05,800
变化时在二级索引中更新，您可以是主

1823
01:11:05,800 --> 01:11:08,760
键或某种合成元组 ID，

1824
01:11:08,760 --> 01:11:11,020
例如 万一主键是

1825
01:11:11,020 --> 01:11:12,790
我的续集所做的但如果你不

1826
01:11:12,790 --> 01:11:15,550
声明主键我的续集他们

1827
01:11:15,550 --> 01:11:17,050
实际上会为你生成一个称为

1828
01:11:17,050 --> 01:11:19,270
行 ID 或者我们只是有某种

1829
01:11:19,270 --> 01:11:20,770
全局计数器说你知道这个元组

1830
01:11:20,770 --> 01:11:22,270
一二 三四五六然后

1831
01:11:22,270 --> 01:11:23,680
有一个间接层做

1832
01:11:23,680 --> 01:11:26,500
查找得到物理地址写

1833
01:11:26,500 --> 01:11:28,300
物理点就是我说的总是

1834
01:11:28,300 --> 01:11:30,310
指向原始链的头部所以

1835
01:11:30,310 --> 01:11:33,340
让我们看看t 他在视觉上所以假设

1836
01:11:33,340 --> 01:11:35,530
我们有一个我们正在使用最旧的惩罚存储

1837
01:11:35,530 --> 01:11:39,250
我们不会再次查找键 a 和

1838
01:11:39,250 --> 01:11:41,050
主索引主索引

1839
01:11:41,050 --> 01:11:42,970
总是指向物理版本没

1840
01:11:42,970 --> 01:11:44,620
问题只是跳到这里然后

1841
01:11:44,620 --> 01:11:46,060
扫描尝试 找到我们正在

1842
01:11:46,060 --> 01:11:49,420
寻找的版本，如果它

1843
01:11:49,420 --> 01:11:51,700
使用物理指针，如果它使用物理指针，

1844
01:11:51,700 --> 01:11:54,400
那么你在这里登陆并扫描如果我

1845
01:11:54,400 --> 01:11:56,500
只有一个索引，那么

1846
01:11:56,500 --> 01:11:58,660
每次这件事发生变化都没什么大不了的，

1847
01:11:58,660 --> 01:12:01,060
因为我只是 去更新

1848
01:12:01,060 --> 01:12:03,730
那个索引，但是如果我有很多索引

1849
01:12:03,730 --> 01:12:05,710
并且它们都指向物理

1850
01:12:05,710 --> 01:12:07,660
地址，每当我创建一个新版本

1851
01:12:07,660 --> 01:12:10,060
并且从最新到最旧时，我

1852
01:12:10,060 --> 01:12:12,070
必须更新所有这些，这就是

1853
01:12:12,070 --> 01:12:13,990
Postgres 所做的 在这种情况下，

1854
01:12:13,990 --> 01:12:16,030
使用 uber 的示例他们的应用程序

1855
01:12:16,030 --> 01:12:18,250
有很多二级索引，

1856
01:12:18,250 --> 01:12:20,530


1857
01:12:20,530 --> 01:12:21,760
每次

1858
01:12:21,760 --> 01:12:25,210
创建元组的新版本时更新 Virgin 链都非常昂贵，所以

1859
01:12:25,210 --> 01:12:26,380
如果你有一个间接层，你怎么能很好地处理这个问题

1860
01:12:26,380 --> 01:12:28,120
er 要么通过绘制

1861
01:12:28,120 --> 01:12:30,220
主键，然后现在只需

1862
01:12:30,220 --> 01:12:31,690
在主键索引中进行第二次查找，

1863
01:12:31,690 --> 01:12:33,850
如果我

1864
01:12:33,850 --> 01:12:36,010
更新物理地址，我只

1865
01:12:36,010 --> 01:12:37,240
需要更新该索引而无需

1866
01:12:37,240 --> 01:12:40,240
其他任何内容，因此如果您的主键是

1867
01:12:40,240 --> 01:12:42,550
如果它像一个 64 位整数，则不是那么大没什么

1868
01:12:42,550 --> 01:12:43,930
大不了的，但如果它是一个大文本字段，

1869
01:12:43,930 --> 01:12:46,450
您将它

1870
01:12:46,450 --> 01:12:48,490
一遍又一遍地存储为您和您的索引中的值，

1871
01:12:48,490 --> 01:12:49,380
这可能很

1872
01:12:49,380 --> 01:12:51,580
昂贵，另一种选择是使用

1873
01:12:51,580 --> 01:12:53,980
合成元组 IDE，但现在您需要

1874
01:12:53,980 --> 01:12:55,420
某种哈希表或

1875
01:12:55,420 --> 01:12:57,940
某种其他查找表来将该元组

1876
01:12:57,940 --> 01:12:59,740
ID 映射到物理地址，因此现在

1877
01:12:59,740 --> 01:13:01,330
只要物理地址发生变化，您只需

1878
01:13:01,330 --> 01:13:03,610
更新此映射，而您知道不会

1879
01:13:03,610 --> 01:13:07,690
更新 符号本身

1880
01:13:07,690 --> 01:13:11,430
就像是的

1881
01:13:31,880 --> 01:13:34,410
这个问题是为了做时间旅行

1882
01:13:34,410 --> 01:13:38,910
存储让我认为接下来的几张

1883
01:13:38,910 --> 01:13:40,410
幻灯片实际上是一个问题，例如有

1884
01:13:40,410 --> 01:13:42,660
没有办法避免必须更新

1885
01:13:42,660 --> 01:13:43,980
这是有什么你要

1886
01:13:43,980 --> 01:13:46,010
问

1887
01:13:46,010 --> 01:13:48,450
的 时间会把它带出去

1888
01:13:48,450 --> 01:13:50,730
好吧

1889
01:13:50,730 --> 01:13:52,770
所以另一个新的讨厌的事情这

1890
01:13:52,770 --> 01:13:53,970
实际上不在你读的论文中，

1891
01:13:53,970 --> 01:13:54,810
但这是我们在

1892
01:13:54,810 --> 01:13:57,560
实际构建我们自己的系统时遇到的事情

1893
01:13:57,560 --> 01:13:59,520
是 NDB 它将支持

1894
01:13:59,520 --> 01:14:02,970
重复的键，可以 只存在于

1895
01:14:02,970 --> 01:14:08,160
不相交的快照中，所以问题

1896
01:14:08,160 --> 01:14:09,870
是在我们的索引中，我们实际上并没有

1897
01:14:09,870 --> 01:14:11,790


1898
01:14:11,790 --> 01:14:14,580
正确地恢复关于元组的版本信息，所以对于我们的 B+

1899
01:14:14,580 --> 01:14:16,110
树，我们不想存储像这里

1900
01:14:16,110 --> 01:14:17,460
是 Virgin one 的键，这里是 keeper

1901
01:14:17,460 --> 01:14:19,230
版本二，因为

1902
01:14:19,230 --> 01:14:21,450
每次更新版本时维护成本都非常高

1903
01:14:21,450 --> 01:14:23,220
我必须

1904
01:14:23,220 --> 01:14:24,450
更新索引并且我有存储

1905
01:14:24,450 --> 01:14:27,210
Nishal 元数据所以

1906
01:14:27,210 --> 01:14:28,920
如果您使用索引，大多数系统实际上不会这样做

1907
01:14:28,920 --> 01:14:30,810
像我在 ODB 中的续集一样有组织的表

1908
01:14:30,810 --> 01:14:33,180
，他们将元组存储在

1909
01:14:33,180 --> 01:14:34,710
索引的叶节点中，

1910
01:14:34,710 --> 01:14:37,170
然后你可以免费获得它，但

1911
01:14:37,170 --> 01:14:40,980
大多数系统不这样做，所以

1912
01:14:40,980 --> 01:14:43,500
现在问题将是我可以有一个

1913
01:14:43,500 --> 01:14:45,600
同科 y 可能存在于不同的

1914
01:14:45,600 --> 01:14:48,270
不同快照中，因此在我的

1915
01:14:48,270 --> 01:14:50,130
索引中，我需要多次存储相同的键

1916
01:14:50,130 --> 01:14:51,660
，并且有

1917
01:14:51,660 --> 01:14:54,900
指向不同版本链的指针，

1918
01:14:54,900 --> 01:14:56,280
所以中间的某个例子所以我说

1919
01:14:56,280 --> 01:14:59,130
每个简单的元组都有一个

1920
01:14:59,130 --> 01:15:01,140
版本我的第一次交易

1921
01:15:01,140 --> 01:15:03,540
过来读一读，我们将在下一堂课上一秒内介绍

1922
01:15:03,540 --> 01:15:05,430
开始结束时间戳的含义，

1923
01:15:05,430 --> 01:15:07,170
但假设

1924
01:15:07,170 --> 01:15:08,610
现在是时候说它让一个

1925
01:15:08,610 --> 01:15:11,340
人开始他，所以这个人读了

1926
01:15:11,340 --> 01:15:13,470
一个没什么大不了的 交易我跟着那个家伙可能

1927
01:15:13,470 --> 01:15:15,900
我的指针在我的索引中我降落

1928
01:15:15,900 --> 01:15:18,780
在这里这个家伙对同一件事进行更新

1929
01:15:18,780 --> 01:15:20,850
我按照指针创建

1930
01:15:20,850 --> 01:15:22,200
新版本并正确更新原始链

1931
01:15:22,200 --> 01:15:23,610
所以很好

1932
01:15:23,610 --> 01:15:26,300
但是现在我删除 净

1933
01:15:26,300 --> 01:15:28,430
，所以需要发生的事情我

1934
01:15:28,430 --> 01:15:30,500
要标记这个东西被删除

1935
01:15:30,500 --> 01:15:32,420
了，你也可以在

1936
01:15:32,420 --> 01:15:35,390
标题中设置一点，西藏所以这很好，

1937
01:15:35,390 --> 01:15:37,790
这个人继续并承诺我们

1938
01:15:37,790 --> 01:15:41,960
更新我们的时间戳说

1939
01:15:41,960 --> 01:15:43,370
你懂 这是这件事

1940
01:15:43,370 --> 01:15:45,140
实际完成的时间 所以这是设置

1941
01:15:45,140 --> 01:15:47,570
开始时间参加时间是 25 他们

1942
01:15:47,570 --> 01:15:48,860
是一样的 所以这是说这件事

1943
01:15:48,860 --> 01:15:52,670
已被删除 所以现在另一个

1944
01:15:52,670 --> 01:15:54,860
交易出现了 他

1945
01:15:54,860 --> 01:15:57,740
在时间戳 30 上插入 我必须

1946
01:15:57,740 --> 01:16:00,800
在我的索引中创建一个新条目

1947
01:16:00,800 --> 01:16:02,870
，现在指向另一个

1948
01:16:02,870 --> 01:16:05,390
这个新版本链，因为我

1949
01:16:05,390 --> 01:16:07,310
不能把它给旧的，因为

1950
01:16:07,310 --> 01:16:09,050
这个人仍在运行时间戳 10

1951
01:16:09,050 --> 01:16:11,300
所以现在当我做一个 在索引上阅读

1952
01:16:11,300 --> 01:16:12,650
我必须确保我得到

1953
01:16:12,650 --> 01:16:15,560
这个而不是这个，即使

1954
01:16:15,560 --> 01:16:17,570
键末尾的值

1955
01:16:17,570 --> 01:16:19,760
完全相同，这被允许

1956
01:16:19,760 --> 01:16:22,580
发生，因为这个人承诺了，

1957
01:16:22,580 --> 01:16:25,520
所以他走了 他在这个人提交之后开始，

1958
01:16:25,520 --> 01:16:27,590
所以他可以

1959
01:16:27,590 --> 01:16:30,350
在概念上写下这不是

1960
01:16:30,350 --> 01:16:32,390
冲突，因为这个快照的 a 在这一点上已经消失了

1961
01:16:32,390 --> 01:16:35,630
所以我

1962
01:16:35,630 --> 01:16:40,040
在同一个索引中为 a 创建两个条目所以

1963
01:16:40,040 --> 01:16:41,360
这有点奇怪 没错，

1964
01:16:41,360 --> 01:16:43,100
就是同一个键 c

1965
01:16:43,100 --> 01:16:45,080
即使它与您的唯一索引一起存在多次，

1966
01:16:45,080 --> 01:16:46,400
因为它是主

1967
01:16:46,400 --> 01:16:50,560
键索引，但在不同的快照中，

1968
01:16:50,560 --> 01:16:53,120
因此处理此问题的一种方法您

1969
01:16:53,120 --> 01:16:58,010
只是保留您可以维护您

1970
01:16:58,010 --> 01:17:01,520
可以维护一些类似的，实际上

1971
01:17:01,520 --> 01:17:06,140
我们如何做到这一点，但是 我们如何

1972
01:17:06,140 --> 01:17:09,710
为同一个密钥提供两个条目 我不这么

1973
01:17:09,710 --> 01:17:10,010


1974
01:17:10,010 --> 01:17:13,370
认为 但它有两个不同的处女

1975
01:17:13,370 --> 01:17:17,120
Jane 我认为我们在密钥中存储了一些额外的

1976
01:17:17,120 --> 01:17:18,500
元数据 正确地说

1977
01:17:18,500 --> 01:17:19,190
这是独一无二的

1978
01:17:19,190 --> 01:17:25,550
我们不可以 是的 我们该怎么办 这样做

1979
01:17:25,550 --> 01:17:29,260
是问题，然后他们

1980
01:17:29,260 --> 01:17:32,600
下次回来讨论这个问题，或者我们不

1981
01:17:32,600 --> 01:17:35,770
知道他知道我们坏了

1982
01:17:35,770 --> 01:17:37,940
我们在旧系统中有这个不同的热门部门大

1983
01:17:37,940 --> 01:17:39,590
集团我认为

1984
01:17:39,590 --> 01:17:40,910
我们解决它的方式是我们将

1985
01:17:40,910 --> 01:17:44,780
存储 我们是从最老到最新的，

1986
01:17:44,780 --> 01:17:48,230
所以他可以存储你必须

1987
01:17:48,230 --> 01:17:53,120
存储的我知道我知道我们是如何做到这一点的，

1988
01:17:53,120 --> 01:17:56,000
所以即使

1989
01:17:56,000 --> 01:17:57,470
它是一个唯一的索引，也可以产生相同的键，所以唯一的索引你

1990
01:17:57,470 --> 01:17:58,760
会认为对单个键来说没问题

1991
01:17:58,760 --> 01:18:00,980
有一个价值，你会得到一个

1992
01:18:00,980 --> 01:18:02,450
值列表和值列表 我们

1993
01:18:02,450 --> 01:18:03,680
不同的指针指向不同的原始

1994
01:18:03,680 --> 01:18:05,260
链 然后您必须遍历

1995
01:18:05,260 --> 01:18:08,570
每个原始链以找到

1996
01:18:08,570 --> 01:18:10,060
您实际可见的版本

1997
01:18:10,060 --> 01:18:13,780
好吧 这就是我们这样做的方式 所以它

1998
01:18:13,780 --> 01:18:16,250
不应该是 H

1999
01:18:16,250 --> 01:18:17,540
彼此重叠，所以如果我们是单键，你

2000
01:18:17,540 --> 01:18:19,970
会得到一个指针列表，然后你

2001
01:18:19,970 --> 01:18:21,140
必须遍历这些指针中的每一个

2002
01:18:21,140 --> 01:18:22,340


2003
01:18:22,340 --> 01:18:31,940


2004
01:18:31,940 --> 01:18:34,250
让这个

2005
01:18:34,250 --> 01:18:36,140
东西指向这个东西，我可以

2006
01:18:36,140 --> 01:18:46,370
遍历它，因为你需要一个

2007
01:18:46,370 --> 01:18:48,770
正确的哨兵值，它说不

2008
01:18:48,770 --> 01:18:50,420
喜欢你需要一种方法来说明

2009
01:18:50,420 --> 01:18:51,770
这条原始链之后没有其他东西，

2010
01:18:51,770 --> 01:18:53,270
你不需要再剥皮，

2011
01:18:53,270 --> 01:18:55,220
但我猜 如果这不是不，你

2012
01:18:55,220 --> 01:19:02,440
仍然会这样做，是的，你可能会工作 -

2013
01:19:02,440 --> 01:19:07,250
我必须考虑这一点，尽管这

2014
01:19:07,250 --> 01:19:17,090
就是你实际上可能是的，他是

2015
01:19:17,090 --> 01:19:18,320
对的，你可能实际上要么认为

2016
01:19:18,320 --> 01:19:19,520
某个市长应该

2017
01:19:19,520 --> 01:19:21,830
需要 这样做 s 我认为我们所做的是我们给

2018
01:19:21,830 --> 01:19:26,960
你多个指针我们一点也不

2019
01:19:26,960 --> 01:19:29,470
奇怪，

2020
01:19:32,250 --> 01:19:34,420
但你不是你没有更新

2021
01:19:34,420 --> 01:19:42,670
你删除条目的属性像我

2022
01:19:42,670 --> 01:19:43,960
一样不支付工资行为我们没有更新

2023
01:19:43,960 --> 01:19:46,060
密钥 我们没有在某处更新元组

2024
01:19:46,060 --> 01:19:49,540
然后你删除它它会得到

2025
01:19:49,540 --> 01:19:50,590
标记让我们删除它然后这个人

2026
01:19:50,590 --> 01:19:51,280
插入

2027
01:19:51,280 --> 01:19:53,320
我以为我们添加了我们添加了一个新添加

2028
01:19:53,320 --> 01:19:56,710
另一个条目细节并不重要

2029
01:19:56,710 --> 01:19:58,120
你只是明白这个问题可能

2030
01:19:58,120 --> 01:20:00,130
会发生是因为 这家伙

2031
01:20:00,130 --> 01:20:01,330
想要重做的行为确保我们

2032
01:20:01,330 --> 01:20:03,100
随时随地都能获得正确的版本 所以

2033
01:20:03,100 --> 01:20:06,370
我要跳过所有这些只是

2034
01:20:06,370 --> 01:20:08,410
快速进行评估 所以这

2035
01:20:08,410 --> 01:20:11,110
又是从他的纸友镇

2036
01:20:11,110 --> 01:20:12,400
出来了 因为它有一个 一堆其他

2037
01:20:12,400 --> 01:20:15,430
问题，本学期多次涉及，

2038
01:20:15,430 --> 01:20:17,680
但主要实验

2039
01:20:17,680 --> 01:20:18,730
基本上只是试图烤掉

2040
01:20:18,730 --> 01:20:19,930
不同的联盟亚洲人，然后

2041
01:20:19,930 --> 01:20:21,610
目标是无论哪个是最好的，

2042
01:20:21,610 --> 01:20:24,400
我们都会将其保留在大部队中，这

2043
01:20:24,400 --> 01:20:25,660
让我很生气，因为我们没有 做 

2044
01:20:25,660 --> 01:20:27,970
就像你在这里看这张图一样

2045
01:20:27,970 --> 01:20:30,700
我会回到这个正确的 这

2046
01:20:30,700 --> 01:20:31,990
是这是不明白的主图

2047
01:20:31,990 --> 01:20:35,260
所以这是扩大

2048
01:20:35,260 --> 01:20:38,130
运行 TPCC 的线程数量

2049
01:20:38,130 --> 01:20:42,910
我们所做的我们基于

2050
01:20:42,910 --> 01:20:44,500
此实现 对于 u21 的所有这些

2051
01:20:44,500 --> 01:20:46,420
不同系统，我们

2052
01:20:46,420 --> 01:20:48,400
将系统配置为与实际

2053
01:20:48,400 --> 01:20:51,400
系统实际执行的操作相匹配，因此 Oracle neo DP

2054
01:20:51,400 --> 01:20:52,950
和 hyper 实际上以最好的方式做到了

2055
01:20:52,950 --> 01:20:55,270
Postgres 实际上以最糟糕的方式做到了

2056
01:20:55,270 --> 01:20:58,450
，这不仅仅是您知道进步和

2057
01:20:58,450 --> 01:21:00,490
新 DB 正在执行相同

2058
01:21:00,490 --> 01:21:02,350
的 comércio 协议 存储和

2059
01:21:02,350 --> 01:21:03,280
垃圾收集的边缘以及索引

2060
01:21:03,280 --> 01:21:04,510
管理是不同的，其他

2061
01:21:04,510 --> 01:21:06,940
事情实际上更重要，所以我

2062
01:21:06,940 --> 01:21:09,250
就像梦幻般的 Oracle new DB 一个超级

2063
01:21:09,250 --> 01:21:10,600
最好的让我们按照他们的方式

2064
01:21:10,600 --> 01:21:11,950
去做 正在写论文的学生

2065
01:21:11,950 --> 01:21:15,220
就给我们留下了这个，他

2066
01:21:15,220 --> 01:21:16,300
回到新加坡并没有真正完成

2067
01:21:16,300 --> 01:21:18,250
它，所以他结束了所有这些我们

2068
01:21:18,250 --> 01:21:19,690
最终与朋友合作的工作是最糟糕的

2069
01:21:19,690 --> 01:21:22,120
方式而不是 最好的方式 新系统

2070
01:21:22,120 --> 01:21:26,080
是最好的方式 所以让我们

2071
01:21:26,080 --> 01:21:27,490
回到这个真正的快速游戏 这是

2072
01:21:27,490 --> 01:21:29,080
在论文中 这只是向您展示

2073
01:21:29,080 --> 01:21:30,460
所有这些不同的系统正在以不同的方式做

2074
01:21:30,460 --> 01:21:33,700
所有这些事情，

2075
01:21:33,700 --> 01:21:35,560
我认为主要的收获是那一天 原始

2076
01:21:35,560 --> 01:21:38,380
存储和索引被证明

2077
01:21:38,380 --> 01:21:41,010
是最重要的，当前的重组不是那么

2078
01:21:41,010 --> 01:21:44,250
好所以

2079
01:21:44,250 --> 01:21:46,860
不是因为我们的论文我认为

2080
01:21:46,860 --> 01:21:48,570
Postgres 意识到他们有一些

2081
01:21:48,570 --> 01:21:51,090
问题但是有一篇博客文章

2082
01:21:51,090 --> 01:21:54,540
在 2018 年发表，我认为我认为这个

2083
01:21:54,540 --> 01:21:57,000
链接 是我们的论文，但他们基本上

2084
01:21:57,000 --> 01:21:58,980
说，哦，这就是我们做

2085
01:21:58,980 --> 01:22:00,330
笔的方式 Nolan 有点糟糕，因为你有

2086
01:22:00,330 --> 01:22:01,710
这种真空，而且开销很大，

2087
01:22:01,710 --> 01:22:03,870
而且这个人现在是

2088
01:22:03,870 --> 01:22:05,400
反对我们的主要开发人员之一，所以他们

2089
01:22:05,400 --> 01:22:06,480
谈到 他们是如何听说他们将

2090
01:22:06,480 --> 01:22:08,640
在

2091
01:22:08,640 --> 01:22:10,680
较新版本中切换到牙科存储的我不知道它是

2092
01:22:10,680 --> 01:22:12,360
在第 13 版还是第 14 版中推出，

2093
01:22:12,360 --> 01:22:14,760
它们被称为 Z heaps，这

2094
01:22:14,760 --> 01:22:16,500
是他们想让你知道的东西

2095
01:22:16,500 --> 01:22:20,780
很好 随着时间的推移，我

2096
01:22:20,780 --> 01:22:23,130
可以在你们运行之前简要谈谈项目 1

2097
01:22:23,130 --> 01:22:26,070
，现在就做，然后

2098
01:22:26,070 --> 01:22:28,530
我们将在今天晚些时候发布这个

2099
01:22:28,530 --> 01:22:32,400
好的目标 1 这个想法是为了让你

2100
01:22:32,400 --> 01:22:33,480
对系统感到舒服所以我们' 重新

2101
01:22:33,480 --> 01:22:35,219
要求您欢迎某个非常

2102
01:22:35,219 --> 01:22:37,020
具体的部分，那就是进行

2103
01:22:37,020 --> 01:22:39,630
顺序扫描或并行或当前

2104
01:22:39,630 --> 01:22:42,930
顺序扫描，这样任务本身就

2105
01:22:42,930 --> 01:22:45,060
不会太难，我们会有

2106
01:22:45,060 --> 01:22:46,440
不同级别的复杂性

2107
01:22:46,440 --> 01:22:49,770
，您可以尝试实现它主要是

2108
01:22:49,770 --> 01:22:50,820
教 你如何在系统中实际工作

2109
01:22:50,820 --> 01:22:52,949
并实际在系统中进行分析和

2110
01:22:52,949 --> 01:22:54,360
性能测量，

2111
01:22:54,360 --> 01:22:57,540
好吧，所以马特昨天介绍了这一点，

2112
01:22:57,540 --> 01:22:59,310
这是我们的系统对 Beauvoir 所做的事情，

2113
01:22:59,310 --> 01:23:01,770
所以我们将把你与

2114
01:23:01,770 --> 01:23:03,330
一堆用 G 基准编写的超级接近基准绑定在一起

2115
01:23:03,330 --> 01:23:05,280
谷歌，但有

2116
01:23:05,280 --> 01:23:06,660
一个特别称为并发槽

2117
01:23:06,660 --> 01:23:08,910
迭代器微基准测试，这

2118
01:23:08,910 --> 01:23:10,290
是瓶颈，或者当我们处理 aa 扫描时，你

2119
01:23:10,290 --> 01:23:12,000
将基本上调查

2120
01:23:12,000 --> 01:23:13,739


2121
01:23:13,739 --> 01:23:16,199
系统你得到这个迭代器，它有

2122
01:23:16,199 --> 01:23:18,030
一个闩锁，所以如果你开始

2123
01:23:18,030 --> 01:23:19,620
扩展并添加更多线程，

2124
01:23:19,620 --> 01:23:20,850
它们都试图获得相同的闩锁

2125
01:23:20,850 --> 01:23:23,219
，这成为一个瓶颈，所以

2126
01:23:23,219 --> 01:23:25,500
我们的想法是我们将发布我们将学习

2127
01:23:25,500 --> 01:23:27,090
如何 使用 perf 并调用grind 来

2128
01:23:27,090 --> 01:23:28,739
了解系统中的主要冲突

2129
01:23:28,739 --> 01:23:30,630
点，然后您

2130
01:23:30,630 --> 01:23:32,760
尝试尝试修复它，因此这是一个单一的

2131
01:23:32,760 --> 01:23:34,739
项目系统，但它向您展示了您

2132
01:23:34,739 --> 01:23:36,660
知道为您提供想要

2133
01:23:36,660 --> 01:23:38,100
尝试不同工作负载的完整系统 以及线程

2134
01:23:38,100 --> 01:23:39,960
和访问模式超出

2135
01:23:39,960 --> 01:23:42,060
了我们为您提供的微基准测试的内容，

2136
01:23:42,060 --> 01:23:45,000
所以我们

2137
01:23:45,000 --> 01:23:47,940
要进行评分的方式是您的成绩将

2138
01:23:47,940 --> 01:23:50,460
是诱饵，您的分数将基于

2139
01:23:50,460 --> 01:23:52,199
比您快多少然后我们

2140
01:23:52,199 --> 01:23:54,960
实现所以我们将有一个

2141
01:23:54,960 --> 01:23:56,310
基本的实现来尝试

2142
01:23:56,310 --> 01:23:57,330
改进这

2143
01:23:57,330 --> 01:23:58,530
一切我们将拥有之前和

2144
01:23:58,530 --> 01:24:00,240
之后所以你的分数读取基于

2145
01:24:00,240 --> 01:24:01,800
你能以多快的速度完成马特

2146
01:24:01,800 --> 01:24:06,300
写的东西马特昨天谈到的

2147
01:24:06,300 --> 01:24:07,860
- 我们要么 呃，在 clang 共振峰 Clank tidy

2148
01:24:07,860 --> 01:24:09,240
你确保你的代码都是

2149
01:24:09,240 --> 01:24:10,830
干净的 你想尽可能多地使用 Google

2150
01:24:10,830 --> 01:24:12,660
sanitizer 的东西，因为你会

2151
01:24:12,660 --> 01:24:13,590
自动获得它并确保你

2152
01:24:13,590 --> 01:24:15,300
没有你没有我们谈到的任何内存泄漏

2153
01:24:15,300 --> 01:24:17,310
在它

2154
01:24:17,310 --> 01:24:19,770
在 OS X 中的任何大于 1804 的 Ubuntu 上运行之前，

2155
01:24:19,770 --> 01:24:22,350
你也可以在 docker 上做一个 vm，这

2156
01:24:22,350 --> 01:24:24,210
是 CMU 我假设我想

2157
01:24:24,210 --> 01:24:25,800
访问一台机器本地的新开发

2158
01:24:25,800 --> 01:24:27,930
，如果不给我发电子邮件，我们可以解决

2159
01:24:27,930 --> 01:24:30,360
这个问题 最重要的一点是

2160
01:24:30,360 --> 01:24:32,640
，我们的新评分方式

2161
01:24:32,640 --> 01:24:34,140
不会像您的套件升级范围那样，

2162
01:24:34,140 --> 01:24:35,550
它会像冒烟测试一样进行，以查看

2163
01:24:35,550 --> 01:24:38,220
您的东西是否真正编译，但

2164
01:24:38,220 --> 01:24:39,420
如果您尝试，您将无法识别此

2165
01:24:39,420 --> 01:24:40,980
瓶颈 要在少于八核的机器上运行它，

2166
01:24:40,980 --> 01:24:42,960


2167
01:24:42,960 --> 01:24:45,240
您的大多数笔记本电脑都知道四核或

2168
01:24:45,240 --> 01:24:48,150
八核或更少，所以我们

2169
01:24:48,150 --> 01:24:51,390
要给你的是亚马逊上的 50 美元，你

2170
01:24:51,390 --> 01:24:54,000
可以去买一台 c59 x-large it

2171
01:24:54,000 --> 01:24:58,230
我认为 32 核或 36 核，你可以

2172
01:24:58,230 --> 01:25:00,540
做你的肛门 在那台机器上，

2173
01:25:00,540 --> 01:25:02,640
因为这就是你能够

2174
01:25:02,640 --> 01:25:05,010
识别瓶颈的方式，所以

2175
01:25:05,010 --> 01:25:06,990
如果你去获得这个按需实例，每个人都会得到 50 美元，

2176
01:25:06,990 --> 01:25:08,850


2177
01:25:08,850 --> 01:25:10,770
如果你得到现场实例，它会说每小时 50 美元，这

2178
01:25:10,770 --> 01:25:12,080
意味着就像你一样” 再说，嘿，这些

2179
01:25:12,080 --> 01:25:14,850
机器闲置了，我会用它们，它们

2180
01:25:14,850 --> 01:25:15,870
可以随时从你身边拿走，

2181
01:25:15,870 --> 01:25:16,410


2182
01:25:16,410 --> 01:25:18,990
但你只付一小部分价格，所以我

2183
01:25:18,990 --> 01:25:20,400
鼓励你使用它，因为如果

2184
01:25:20,400 --> 01:25:23,280
你花光了 50 美元，我不能 我

2185
01:25:23,280 --> 01:25:24,840
无法报销，

2186
01:25:24,840 --> 01:25:26,640
所以我会向所有参加课程的人发送一封电子邮件，

2187
01:25:26,640 --> 01:25:28,800
例如这是

2188
01:25:28,800 --> 01:25:30,420
您的亚马逊代码，您需要有

2189
01:25:30,420 --> 01:25:32,130
信用卡才能注册亚马逊的

2190
01:25:32,130 --> 01:25:34,560
ec2 或 AWS，如果这是一个问题，让 我

2191
01:25:34,560 --> 01:25:35,850
知道我们会弄清楚如何伪造一个或

2192
01:25:35,850 --> 01:25:37,950
类似的东西，但

2193
01:25:37,950 --> 01:25:40,320
无论如何都可以，所以我们在第 16 次做这个，

2194
01:25:40,320 --> 01:25:43,080
我们将在今天晚些时候发布这个，然后

2195
01:25:43,080 --> 01:25:45,090
下一节课我们将讨论更多和简单的

2196
01:25:45,090 --> 01:25:48,320
实现，再见，伙计们看到 你

2197
01:25:48,320 --> 01:25:50,520
在旁边的公园里抽它

2198
01:25:50,520 --> 01:25:51,260
这是什么

2199
01:25:51,260 --> 01:26:13,529
[音乐]

2200
01:26:14,359 --> 01:26:18,329
而我的引擎盖不会 说我认为它

2201
01:26:18,329 --> 01:26:21,439
是猎物

