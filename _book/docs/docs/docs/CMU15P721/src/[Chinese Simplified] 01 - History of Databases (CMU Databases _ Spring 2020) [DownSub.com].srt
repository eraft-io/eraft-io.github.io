1
00:00:01,300 --> 00:00:05,129
[音乐]

2
00:00:05,200 --> 00:00:05,930
[掌声]

3
00:00:05,930 --> 00:00:08,630
[音乐]

4
00:00:08,630 --> 00:00:10,020
[掌声]

5
00:00:10,020 --> 00:00:11,330
[音乐]

6
00:00:11,330 --> 00:00:14,599
欢迎来到 57:21

7
00:00:14,599 --> 00:00:16,890
我是这门课程的讲师 Indy

8
00:00:16,890 --> 00:00:21,510
Pablo 因为我现在在匹兹堡的 Piazza I 上发帖

9
00:00:21,510 --> 00:00:23,460
我实际上

10
00:00:23,460 --> 00:00:27,300
和我的朋友 187 在阿姆斯特丹 欧文的

11
00:00:27,300 --> 00:00:31,009
问题是 187 给我们订了一家酒店，

12
00:00:31,009 --> 00:00:33,660
但实际上这不是

13
00:00:33,660 --> 00:00:36,450
我们想要住的那种酒店，所以现在我们

14
00:00:36,450 --> 00:00:37,950
只是在红灯区闲逛，

15
00:00:37,950 --> 00:00:39,870
试图

16
00:00:39,870 --> 00:00:42,059
弄清楚我们要做什么 需要做下一步，但欧文

17
00:00:42,059 --> 00:00:44,489
把他所有的钱都弄丢了，我现在没有

18
00:00:44,489 --> 00:00:46,410
信用卡，所以我们有点

19
00:00:46,410 --> 00:00:47,520
无家可归，所以我想现在是

20
00:00:47,520 --> 00:00:49,590
坐下来

21
00:00:49,590 --> 00:00:51,780
为大家讲第一堂课的好时机，所以 在我们开始之前，

22
00:00:51,780 --> 00:00:53,100
我只想

23
00:00:53,100 --> 00:00:55,320
向所有从一开始就对我们失望的人大声疾呼

24
00:00:55,320 --> 00:00:57,750


25
00:00:57,750 --> 00:01:02,250
，加利福尼亚州西雅图的 Jael 和布鲁克林的 Eazy E

26
00:01:02,250 --> 00:01:03,840
这些人

27
00:01:03,840 --> 00:01:06,659
从一开始就对我们了解真相，我也

28
00:01:06,659 --> 00:01:08,700
想承认这一点 这个学期我们

29
00:01:08,700 --> 00:01:10,380
得到了两个基金会或

30
00:01:10,380 --> 00:01:13,170
两个团体的赞助 首先是亚马逊

31
00:01:13,170 --> 00:01:15,689
数据库集团亚马逊

32
00:01:15,689 --> 00:01:16,799
实际上是最大的数据库

33
00:01:16,799 --> 00:01:20,040
供应商之一他们所做的一切都是在

34
00:01:20,040 --> 00:01:22,110
云上，我们将讨论的许多主题

35
00:01:22,110 --> 00:01:23,850
和本学期都

36
00:01:23,850 --> 00:01:25,409
与他们正在构建的系统类型相关

37
00:01:25,409 --> 00:01:27,390
，并且 所以他们正在

38
00:01:27,390 --> 00:01:28,590
帮助课程开发

39
00:01:28,590 --> 00:01:32,460
我们也得到了一个名为 Steve Moya 基金会的非营利组织的资助，

40
00:01:32,460 --> 00:01:33,960
以

41
00:01:33,960 --> 00:01:35,430
保持它的真实性，他们再次

42
00:01:35,430 --> 00:01:37,530
帮助支付 TAS 和

43
00:01:37,530 --> 00:01:38,610
讲义以及其他事情，所以我们

44
00:01:38,610 --> 00:01:40,590
感谢他们的帮助 我们

45
00:01:40,590 --> 00:01:41,939
出去和亚马逊他们将

46
00:01:41,939 --> 00:01:43,829
在学期晚些时候做客座讲座

47
00:01:43,829 --> 00:01:46,860
对不起 - 今天的

48
00:01:46,860 --> 00:01:48,689
议程我们想要讨论的首先

49
00:01:48,689 --> 00:01:50,820
是课程和

50
00:01:50,820 --> 00:01:51,960
学期的概述，如果你是

51
00:01:51,960 --> 00:01:54,450
卡内基梅隆大学的学生和 那么我

52
00:01:54,450 --> 00:01:56,130
只想做一个

53
00:01:56,130 --> 00:01:58,799
关于数据库历史的有趣讲座，只是为了

54
00:01:58,799 --> 00:02:01,469
提供一些关于你所

55
00:02:01,469 --> 00:02:02,729
知道的我们今天谈论的现代系统类型的背景

56
00:02:02,729 --> 00:02:04,680
如果你

57
00:02:04,680 --> 00:02:05,939
知道人们过去尝试过什么，

58
00:02:05,939 --> 00:02:08,520
所以如果你没有参加

59
00:02:08,520 --> 00:02:09,628
课程并且你想跳到

60
00:02:09,628 --> 00:02:11,550
这个视频你应该跳到

61
00:02:11,550 --> 00:02:12,720
你的数据库其他一切

62
00:02:12,720 --> 00:02:13,590


63
00:02:13,590 --> 00:02:17,310
都只是在 CMU 的人 所以

64
00:02:17,310 --> 00:02:19,920
我想讨论的第一件事是

65
00:02:19,920 --> 00:02:21,840
你为什么要参加 15 7:21 为什么要参加

66
00:02:21,840 --> 00:02:23,910
这门课程 所以我每个学期

67
00:02:23,910 --> 00:02:26,010
和每个学期都这么说 我现在仍然

68
00:02:26,010 --> 00:02:28,349
如此，现在数据库系统

69
00:02:28,349 --> 00:02:30,420
开发人员的需求量很大，而不仅仅是

70
00:02:30,420 --> 00:02:32,310
在 硅谷不只是在

71
00:02:32,310 --> 00:02:35,280
美国，遍布世界各地，因为

72
00:02:35,280 --> 00:02:36,989


73
00:02:36,989 --> 00:02:39,450
在数据库数据管理处理方面有很多未解决的问题，

74
00:02:39,450 --> 00:02:42,239
而且这些公司

75
00:02:42,239 --> 00:02:44,819
招聘人员的速度不够快，所以你知道如果

76
00:02:44,819 --> 00:02:47,250
你参加了这门课程，你就会成为你 知道

77
00:02:47,250 --> 00:02:49,170
任何在这方面做得好的你会立即被

78
00:02:49,170 --> 00:02:50,819
雇用或立即被雇用，

79
00:02:50,819 --> 00:02:53,730
这是一件

80
00:02:53,730 --> 00:02:55,080
好事，我还要说的另一件事是，如果

81
00:02:55,080 --> 00:02:57,840
你即使你不离开并最终

82
00:02:57,840 --> 00:02:59,280
结束你的职业生涯 编写数据库

83
00:02:59,280 --> 00:03:01,380
系统或构建数据库系统

84
00:03:01,380 --> 00:03:03,349
你整个学期会遇到或学习

85
00:03:03,349 --> 00:03:06,360
的东西

86
00:03:06,360 --> 00:03:08,010
将适用于

87
00:03:08,010 --> 00:03:10,170
计算机科学或

88
00:03:10,170 --> 00:03:12,690
信息技术的几乎所有其他方面

89
00:03:12,690 --> 00:03:15,080
，你会看到

90
00:03:15,080 --> 00:03:17,970


91
00:03:17,970 --> 00:03:19,980


92
00:03:19,980 --> 00:03:21,900
除了操作系统或嵌入式系统之外，您认识的那些足以为数据库价值系统编写代码的人

93
00:03:21,900 --> 00:03:23,850


94
00:03:23,850 --> 00:03:25,320


95
00:03:25,320 --> 00:03:29,790
您知道，如果

96
00:03:29,790 --> 00:03:30,780
您的数据库不编程并且您知道，您几乎可以在任何其他应用程序领域找到工作

97
00:03:30,780 --> 00:03:32,010
想要编写 JavaScript 代码，人们会

98
00:03:32,010 --> 00:03:33,569
雇用你，但如果你的 JavaScript

99
00:03:33,569 --> 00:03:34,829
程序员和你想花一天时间编写一个

100
00:03:34,829 --> 00:03:36,930
数据库系统，你知道这可能会

101
00:03:36,930 --> 00:03:39,209
更难卖，所以

102
00:03:39,209 --> 00:03:40,709
你会

103
00:03:40,709 --> 00:03:43,709
从这门课程中学到的系统背景是你知道的 不仅仅是

104
00:03:43,709 --> 00:03:44,790
数据库系统，但我们将

105
00:03:44,790 --> 00:03:46,200
在数据库的上下文中讨论这些事情，

106
00:03:46,200 --> 00:03:47,190
因为这是我真正关心的所有

107
00:03:47,190 --> 00:03:50,639
我可以给你

108
00:03:50,639 --> 00:03:53,609
一些简短的

109
00:03:53,609 --> 00:03:54,930
我上过这门课的学生的 lumni 角色以及他们

110
00:03:54,930 --> 00:03:58,049
去了哪里，但这只是

111
00:03:58,049 --> 00:04:00,900
那些上过 7:21 然后

112
00:04:00,900 --> 00:04:02,310
和我们一起出去玩并在 CMU 进一步研究我们的系统的学生的一个子集

113
00:04:02,310 --> 00:04:04,500
，他们”

114
00:04:04,500 --> 00:04:06,269
所有人都去读研究生了，

115
00:04:06,269 --> 00:04:08,850
或者现在正在构建数据库

116
00:04:08,850 --> 00:04:10,769
系统，你

117
00:04:10,769 --> 00:04:12,840
知道构建数据库的公司，或者你

118
00:04:12,840 --> 00:04:13,950
知道实际上只是

119
00:04:13,950 --> 00:04:16,350
构建数据库系统的初创公司，所以我很

120
00:04:16,350 --> 00:04:17,789
高兴，然后公司

121
00:04:17,789 --> 00:04:20,470
不能雇用 我们的学生足够快，

122
00:04:20,470 --> 00:04:23,680
所以这门课程的目标是

123
00:04:23,680 --> 00:04:27,770
让你知道给你背景知识，

124
00:04:27,770 --> 00:04:29,390
了解绑定实践

125
00:04:29,390 --> 00:04:32,240
和构建数据库系统，

126
00:04:32,240 --> 00:04:34,670
作为其中的一部分，你会变得更

127
00:04:34,670 --> 00:04:36,980
擅长做一些低级的 系统

128
00:04:36,980 --> 00:04:40,280
编程，所以目标

129
00:04:40,280 --> 00:04:42,050
是在学期结束时，您将了解在数据库上下文

130
00:04:42,050 --> 00:04:44,120
中编写正确且性能良好的

131
00:04:44,120 --> 00:04:46,190
系统代码意味着什么，

132
00:04:46,190 --> 00:04:49,820
我们不能，我们都需要，您

133
00:04:49,820 --> 00:04:51,350
不想丢失数据 秒 o 你希望你的

134
00:04:51,350 --> 00:04:52,940
系统是正确的，我会告诉你

135
00:04:52,940 --> 00:04:54,800
如何尽可能快地处理数据

136
00:04:54,800 --> 00:04:56,780
奇怪的速度尽可能快 所以你

137
00:04:56,780 --> 00:04:59,240
想成为你知道支持

138
00:04:59,240 --> 00:05:02,630
高性能 所以我有点像

139
00:05:02,630 --> 00:05:04,700
学术界的象牙塔 我喜欢说

140
00:05:04,700 --> 00:05:07,160
哦，正确性很重要，

141
00:05:07,160 --> 00:05:08,720
性能第二，这就是我将如何

142
00:05:08,720 --> 00:05:11,270
在现实世界中在实践中教授一些

143
00:05:11,270 --> 00:05:13,250
并不总是遵循的东西 你

144
00:05:13,250 --> 00:05:14,720
肯定会看看像

145
00:05:14,720 --> 00:05:17,180
MongoDB 或 bi sequel 这样的例子 你知道非常

146
00:05:17,180 --> 00:05:19,760
成功的数据库系统

147
00:05:19,760 --> 00:05:22,850
在世界各地使用，他们

148
00:05:22,850 --> 00:05:24,590
开始首先追求性能，

149
00:05:24,590 --> 00:05:27,740
然后在一秒钟内进行纠正，因此

150
00:05:27,740 --> 00:05:28,520
您将在本课程中学到的另一件事

151
00:05:28,520 --> 00:05:29,810
是，将教您正确

152
00:05:29,810 --> 00:05:31,310
的数据库系统文档和测试，

153
00:05:31,310 --> 00:05:33,410
您还将学习如何

154
00:05:33,410 --> 00:05:35,900
滥用代码，你在一个更大的代码

155
00:05:35,900 --> 00:05:37,310
库中工作，所以

156
00:05:37,310 --> 00:05:39,320
这些都是大学以外的事情，这些是

157
00:05:39,320 --> 00:05:41,960
你知道的，

158
00:05:41,960 --> 00:05:43,220
无论你去哪里，都会帮助你的职业

159
00:05:43,220 --> 00:05:45,560
生涯 一家大型科技公司是，当我

160
00:05:45,560 --> 00:05:46,790
问他们对我的

161
00:05:46,790 --> 00:05:48,800
学生参加这门课程有什么兴趣时，

162
00:05:48,800 --> 00:05:50,540
你知道做什么他们希望他们学习

163
00:05:50,540 --> 00:05:53,180
B 加树或锁定代码，他们总是

164
00:05:53,180 --> 00:05:54,320
告诉我他们希望学生

165
00:05:54,320 --> 00:05:55,610
能够独立工作 在大型代码

166
00:05:55,610 --> 00:05:57,500
库上，所以这不是我会

167
00:05:57,500 --> 00:05:58,970
掉以轻心的事情，我

168
00:05:58,970 --> 00:06:00,920
认为这对很多人来说并不容易，

169
00:06:00,920 --> 00:06:02,960
尤其是我，这是

170
00:06:02,960 --> 00:06:05,690
你在学期中会接触到的东西

171
00:06:05,690 --> 00:06:10,900


172
00:06:10,900 --> 00:06:13,390
本学期的主题将

173
00:06:13,390 --> 00:06:15,800
是内存数据库系统中的单节点

174
00:06:15,800 --> 00:06:18,020
，因此这意味着我们将

175
00:06:18,020 --> 00:06:21,260
忽略大部分将

176
00:06:21,260 --> 00:06:23,750
数据写入磁盘作为磁盘

177
00:06:23,750 --> 00:06:25,450
或 dida 基础系统的一部分，它现在是流动的，

178
00:06:25,450 --> 00:06:28,669
稍后 当你拥有分布式数据库系统时，我们也将

179
00:06:28,669 --> 00:06:30,440
解决问题和挑战，

180
00:06:30,440 --> 00:06:32,360
所以

181
00:06:32,360 --> 00:06:33,770
并不是说分布式

182
00:06:33,770 --> 00:06:36,379
数据库不重要，只是说

183
00:06:36,379 --> 00:06:38,210
对于本课程，我们将专注于

184
00:06:38,210 --> 00:06:40,160
获得 s 单节点系统

185
00:06:40,160 --> 00:06:41,930
尽可能快地工作，它是正确和

186
00:06:41,930 --> 00:06:44,990
正确的，我们不

187
00:06:44,990 --> 00:06:46,759
担心将其剥离，

188
00:06:46,759 --> 00:06:50,620
在我看来最好有一个

189
00:06:50,620 --> 00:06:52,909
在单个节点上运行良好的数据库系统

190
00:06:52,909 --> 00:06:54,169
并尝试扩展它

191
00:06:54,169 --> 00:06:56,599
在你进入分布式

192
00:06:56,599 --> 00:06:57,830
环境并尝试水平扩展之前垂直扩展，

193
00:06:57,830 --> 00:06:59,240
因为这会带来

194
00:06:59,240 --> 00:07:00,860
一大堆其他挑战，所以这

195
00:07:00,860 --> 00:07:01,909
意味着我们不会大规模

196
00:07:01,909 --> 00:07:04,849
涵盖人口普查协议或容错等

197
00:07:04,849 --> 00:07:08,000
我们关心

198
00:07:08,000 --> 00:07:11,150
的问题 事情，但不只是在这里，所以本

199
00:07:11,150 --> 00:07:13,669
课程也不会涉及经典的

200
00:07:13,669 --> 00:07:15,650
数据库分钟系统，这

201
00:07:15,650 --> 00:07:17,870
意味着我们不会

202
00:07:17,870 --> 00:07:19,729
像我们在介绍课中所做的那样介绍

203
00:07:19,729 --> 00:07:22,970
有关两阶段锁定或 B 加

204
00:07:22,970 --> 00:07:24,289
树的基础知识 以及诸如此类的事情 我

205
00:07:24,289 --> 00:07:26,150
假设你知道这些事情 而不是

206
00:07:26,150 --> 00:07:27,370
我们将涵盖我们

207
00:07:27,370 --> 00:07:29,750
最先进的实现和

208
00:07:29,750 --> 00:07:32,509
现代系统

209
00:07:32,509 --> 00:07:34,190
今天没有使用的其他主题 我说这是 g

210
00:07:34,190 --> 00:07:36,560
除了我们在印度表演

211
00:07:36,560 --> 00:07:39,590
课程中涵盖的内容之外，我们将

212
00:07:39,590 --> 00:07:40,940
在本学期讨论的事情是

213
00:07:40,940 --> 00:07:43,370
并发控制索引数据

214
00:07:43,370 --> 00:07:45,530
结构存储模型数据库

215
00:07:45,530 --> 00:07:48,469
压缩垫实际上

216
00:07:48,469 --> 00:07:50,120
并行连接或 VanFleet 向量化

217
00:07:50,120 --> 00:07:52,430
执行模型网络协议

218
00:07:52,430 --> 00:07:54,979
日志记录恢复然后 我们将

219
00:07:54,979 --> 00:07:56,240
在学期末花大量时间

220
00:07:56,240 --> 00:07:59,389
讨论查询

221
00:07:59,389 --> 00:08:00,919
优化中的查询编译，这些都是

222
00:08:00,919 --> 00:08:03,020
一些更现代的东西，你

223
00:08:03,020 --> 00:08:04,610
不知道我们真的没有机会

224
00:08:04,610 --> 00:08:08,979
在里面介绍 介绍

225
00:08:08,979 --> 00:08:11,479
课，正如我已经说过的，我会假设如果

226
00:08:11,479 --> 00:08:12,560
你正在学习这门课程，你

227
00:08:12,560 --> 00:08:15,199
已经学习了另一门数据库

228
00:08:15,199 --> 00:08:17,449
课程，无论是 45 645 卡内基梅隆大学的 15 门课程，

229
00:08:17,449 --> 00:08:19,669
还是在你的本科

230
00:08:19,669 --> 00:08:21,740
院校，对

231
00:08:21,740 --> 00:08:24,380
数据库的某种介绍等等 我之所以

232
00:08:24,380 --> 00:08:26,479
要这样假设是因为我们要

233
00:08:26,479 --> 00:08:28,370
讨论经典算法的现代变体，这些变

234
00:08:28,370 --> 00:08:30,440
体是

235
00:08:30,440 --> 00:08:32,779
为今天的样子而设计的

236
00:08:32,779 --> 00:08:34,250
所以我不会教你

237
00:08:34,250 --> 00:08:36,020
如何进行散列连接 我将教你

238
00:08:36,020 --> 00:08:37,399
如何进行矢量化并行散列

239
00:08:37,399 --> 00:08:39,078
连接 我认为并使用

240
00:08:39,078 --> 00:08:40,760
简单的指令运行多个内核 我说这是

241
00:08:40,760 --> 00:08:42,500
更短的你需要理解

242
00:08:42,500 --> 00:08:43,820
哈希联合工作的基本方式，所以为了

243
00:08:43,820 --> 00:08:45,760
了解如何

244
00:08:45,760 --> 00:08:48,730
通过它的现代实现来做，

245
00:08:48,730 --> 00:08:51,350
所以我假设

246
00:08:51,350 --> 00:08:52,940
你已经拥有的核心背景显然是

247
00:08:52,940 --> 00:08:54,410
续集，因为我们将专注于

248
00:08:54,410 --> 00:08:57,200
关系数据库的并发串行化理论

249
00:08:57,200 --> 00:08:58,880
控制理论关系

250
00:08:58,880 --> 00:09:00,560
奇数，然后是经典数据库的基本算法和

251
00:09:00,560 --> 00:09:02,450
数据结构

252
00:09:02,450 --> 00:09:07,280
P 加树 Ares 两

253
00:09:07,280 --> 00:09:08,420
阶段锁定它等等诸如此类的

254
00:09:08,420 --> 00:09:13,730
事情 所以课程政策

255
00:09:13,730 --> 00:09:15,740
和时间表都可以在

256
00:09:15,740 --> 00:09:17,540
课程网页上找到 教学大纲

257
00:09:17,540 --> 00:09:18,530
有一个时间表，我将

258
00:09:18,530 --> 00:09:20,060
在更多的幻灯片中介绍时间表的含义，

259
00:09:20,060 --> 00:09:22,550
但您对

260
00:09:22,550 --> 00:09:24,920
将举办什么课程

261
00:09:24,920 --> 00:09:27,140
以及如何评分有任何疑问 你

262
00:09:27,140 --> 00:09:29,630
现在总是在学术诚实方面参考课程网页

263
00:09:29,630 --> 00:09:32,390
我鼓励你去

264
00:09:32,390 --> 00:09:34,670
看看他们网页上的政策是

265
00:09:34,670 --> 00:09:37,490
什么，关于什么是抄袭和

266
00:09:37,490 --> 00:09:39,290
什么是作弊，如果你正在做

267
00:09:39,290 --> 00:09:41,180
一些事情，比如复制一段代码

268
00:09:41,180 --> 00:09:42,890
，你 不确定这是否可以

269
00:09:42,890 --> 00:09:45,890
我鼓励你问我

270
00:09:45,890 --> 00:09:48,380
我宁愿你问我我们和

271
00:09:48,380 --> 00:09:49,430
你我讨论它，看看

272
00:09:49,430 --> 00:09:50,450
你是否在做正确的事情，

273
00:09:50,450 --> 00:09:51,350
你在做什么是好的

274
00:09:51,350 --> 00:09:53,720
而不是我发现你作弊，我

275
00:09:53,720 --> 00:09:55,550
必须去你知道拉你

276
00:09:55,550 --> 00:09:58,670
点好所以你知道让我们不要

277
00:09:58,670 --> 00:10:00,170
抄袭让我们不要傻如果你

278
00:10:00,170 --> 00:10:03,200
有问题就问我好所以

279
00:10:03,200 --> 00:10:04,760
我在周一和周三办公

280
00:10:04,760 --> 00:10:07,580
在 1:30 2:30

281
00:10:07,580 --> 00:10:10,270
在我的办公室和大门这节课结束后

282
00:10:10,270 --> 00:10:12,590
，时间不适合你，然后

283
00:10:12,590 --> 00:10:14,870
请给我发电子邮件，我们可以

284
00:10:14,870 --> 00:10:16,430
安排另一个时间，所以如果你

285
00:10:16,430 --> 00:10:17,660
来办公时间，我们可以谈谈什么？

286
00:10:17,660 --> 00:10:19,670
很多时候学生

287
00:10:19,670 --> 00:10:21,380
想来 谈论实施他们的

288
00:10:21,380 --> 00:10:23,180
项目，或者他们是否阅读了论文并且

289
00:10:23,180 --> 00:10:25,580
不确定您是否

290
00:10:25,580 --> 00:10:27,440
完全理解它，但

291
00:10:27,440 --> 00:10:28,910
您还想谈论其他生活中的事情

292
00:10:28,910 --> 00:10:31,400
我很高兴这样做以及

293
00:10:31,400 --> 00:10:32,660
如何找到工作 作为数据库

294
00:10:32,660 --> 00:10:34,280
工程师 数据库开发人员

295
00:10:34,280 --> 00:10:35,660
如果您想介绍

296
00:10:35,660 --> 00:10:37,190
某个州或地区的数据库公司

297
00:10:37,190 --> 00:10:38,510
我绝对可以为您做

298
00:10:38,510 --> 00:10:42,020
然后由于我的背景 我

299
00:10:42,020 --> 00:10:44,480
认为我有资格谈论

300
00:10:44,480 --> 00:10:47,030
如何处理警察 你知道如果你处于这样的

301
00:10:47,030 --> 00:10:50,420
情况，你知道因为你做

302
00:10:50,420 --> 00:10:52,370
数据库，你可能会在一个糟糕的地方结束

303
00:10:52,370 --> 00:10:54,020
，你知道你需要一些帮助

304
00:10:54,020 --> 00:10:56,060
来摆脱它所以无论如何来和

305
00:10:56,060 --> 00:10:57,949
我谈谈我很乐意做 所以

306
00:10:57,949 --> 00:11:01,110
我们有 1ta 他最颤抖的学期

307
00:11:01,110 --> 00:11:03,630
Matt boo trovich 是

308
00:11:03,630 --> 00:11:06,779
第二年的桃色或第二年

309
00:11:06,779 --> 00:11:08,009
半 不清楚他实际上是什么

310
00:11:08,009 --> 00:11:10,410
PC 学生和我在 CS 系

311
00:11:10,410 --> 00:11:12,769
他实际上是一个学生，他被 721

312
00:11:12,769 --> 00:11:15,389
打败了，我鼓励他 出去玩

313
00:11:15,389 --> 00:11:16,740
成为一名 PG 学生，现在他在

314
00:11:16,740 --> 00:11:19,620
这里，所以他目前是首席

315
00:11:19,620 --> 00:11:21,959
架构师或开发人员，帮助在 CMU 构建我们的

316
00:11:21,959 --> 00:11:24,690
数据库系统，这就是

317
00:11:24,690 --> 00:11:26,899
您在真正来到 CMU 之前将用于所有项目的内容

318
00:11:26,899 --> 00:11:30,540


319
00:11:30,540 --> 00:11:32,279
他来自洛杉矶，所以他是 就像你知道的前帮派

320
00:11:32,279 --> 00:11:36,470
成员，所以他很

321
00:11:36,470 --> 00:11:39,630
荒谬，但实际上现在因为

322
00:11:39,630 --> 00:11:40,560
我已经让他走上了正确的道路

323
00:11:40,560 --> 00:11:44,250
，因为我是一名 PG 学生，他现在是我正在

324
00:11:44,250 --> 00:11:45,750
训练他成为一名有执照的拳击

325
00:11:45,750 --> 00:11:48,300
经理，所以他会 成为一名笼式战士，

326
00:11:48,300 --> 00:11:50,940
他目前不败，你知道

327
00:11:50,940 --> 00:11:52,500
通过我们的训练，我们希望这

328
00:11:52,500 --> 00:11:54,569
将继续成为他的方式，所以

329
00:11:54,569 --> 00:11:56,130
任何我无法回答的发展问题

330
00:11:56,130 --> 00:11:58,290
我鼓励你去问马特，

331
00:11:58,290 --> 00:12:00,269
因为他会知道更多

332
00:12:00,269 --> 00:12:01,529
关于内部的事情 今晚我们的数据库系统

333
00:12:01,529 --> 00:12:06,149
很好 所以

334
00:12:06,149 --> 00:12:07,680
本学期对你的预期细分

335
00:12:07,680 --> 00:12:09,720
如下 所以有阅读

336
00:12:09,720 --> 00:12:11,040
作业 编程项目 期末

337
00:12:11,040 --> 00:12:13,290
考试和额外的学分 所以今年我们比往年做的一个改变

338
00:12:13,290 --> 00:12:14,610


339
00:12:14,610 --> 00:12:18,889
是我 取消了期中考试，

340
00:12:18,889 --> 00:12:21,449
并带回了第二个

341
00:12:21,449 --> 00:12:22,709
编程项目，因为我认为

342
00:12:22,709 --> 00:12:24,300
去年学生从其中获得的

343
00:12:24,300 --> 00:12:26,730
比期中考试更多，所以我将

344
00:12:26,730 --> 00:12:28,139
解释这是什么，并且

345
00:12:28,139 --> 00:12:29,250


346
00:12:29,250 --> 00:12:32,880
比以前多了两个阅读作业 年所以

347
00:12:32,880 --> 00:12:35,100
如果你去网页上安排的课程，

348
00:12:35,100 --> 00:12:37,290
你会看到每

349
00:12:37,290 --> 00:12:39,600
一天都有一个广泛的主题

350
00:12:39,600 --> 00:12:40,980
，该讲座将讨论什么，

351
00:12:40,980 --> 00:12:43,470
然后有一个阅读清单，其中

352
00:12:43,470 --> 00:12:45,360
一个阅读会有这个橙色 或

353
00:12:45,360 --> 00:12:48,029
旁边的黄色星星，这

354
00:12:48,029 --> 00:12:49,170
是该课程的必读内容，我

355
00:12:49,170 --> 00:12:51,480
应该是

356
00:12:51,480 --> 00:12:53,850
我们将在讲座中介绍的主要论文，因此在

357
00:12:53,850 --> 00:12:56,660
每节课之前，您都需要提交

358
00:12:56,660 --> 00:13:01,579
对我们刚刚讨论的这篇论文的概要的评论

359
00:13:01,579 --> 00:13:04,259
就像概述

360
00:13:04,259 --> 00:13:05,730
或分钟一样，主要带走了

361
00:13:05,730 --> 00:13:09,899
每个系统实际所做的事情，并且您

362
00:13:09,899 --> 00:13:11,250
必须将其吐到这个表单上

363
00:13:11,250 --> 00:13:13,529
，这只是一个谷歌表单，因此

364
00:13:13,529 --> 00:13:15,569
在概要中 是否还包括

365
00:13:15,569 --> 00:13:17,339
你知道他们使用什么系统进行

366
00:13:17,339 --> 00:13:19,170
评估，他们是否修改它

367
00:13:19,170 --> 00:13:21,240
以及他们如何修改他，

368
00:13:21,240 --> 00:13:23,189
然后他们做了什么工作来评估他们

369
00:13:23,189 --> 00:13:24,809
提出的方法，最后一个

370
00:13:24,809 --> 00:13:25,889
实际上非常重要，因为当

371
00:13:25,889 --> 00:13:28,620
你做最后的 项目，你想

372
00:13:28,620 --> 00:13:30,839
衡量你的系统如何，或者系统是否

373
00:13:30,839 --> 00:13:32,339
真正改进或变得更快

374
00:13:32,339 --> 00:13:35,160
，或者无论你正在修改

375
00:13:35,160 --> 00:13:36,360
什么，你想看看人们在这些其他论文中使用的工作负载是什么

376
00:13:36,360 --> 00:13:38,850


377
00:13:38,850 --> 00:13:42,389
，你知道应用相同并应用

378
00:13:42,389 --> 00:13:44,160
对您自己的实施进行相同的实验，

379
00:13:44,160 --> 00:13:47,699
因此评论是在

380
00:13:47,699 --> 00:13:53,069
上午 11 点 59 分到期的概要类型，就

381
00:13:53,069 --> 00:14:03,829
在上课之前发臭，很刺耳

382
00:14:03,829 --> 00:14:10,199
，很粘，评论是

383
00:14:10,199 --> 00:14:11,970
在课前进行的，没有迟到，

384
00:14:11,970 --> 00:14:13,709
但您可以跳过

385
00:14:13,709 --> 00:14:14,899
整个学期有四次阅读

386
00:14:14,899 --> 00:14:16,740
，然后你的最终成绩将

387
00:14:16,740 --> 00:14:19,790
基于你知道你提交的那些，

388
00:14:19,790 --> 00:14:21,839
所以再次请不要

389
00:14:21,839 --> 00:14:23,550
抄袭我认为的这些作品 她的

390
00:14:23,550 --> 00:14:26,699
人在 YouTube 上的课程中很

391
00:14:26,699 --> 00:14:28,829
受欢迎，或者我查看了前

392
00:14:28,829 --> 00:14:30,959
几年，有时您可以

393
00:14:30,959 --> 00:14:34,110
在 github 上找到概要

394
00:14:34,110 --> 00:14:35,550
不要抄袭 不要互相复制

395
00:14:35,550 --> 00:14:37,230
我已经运行了所有苔藓 如果我们

396
00:14:37,230 --> 00:14:38,309
抓住了你 我们必须再次向您报告

397
00:14:38,309 --> 00:14:42,480
我再说一遍，

398
00:14:42,480 --> 00:14:43,829
别傻了，所以现在球 kaduk 真的很看重

399
00:14:43,829 --> 00:14:46,230
项目项目，所以

400
00:14:46,230 --> 00:14:48,540
我们正在卡内基梅隆大学建立一个新的数据库

401
00:14:48,540 --> 00:14:49,680
测量系统

402
00:14:49,680 --> 00:14:52,170
它没有名字但它

403
00:14:52,170 --> 00:14:54,000
没有 '还没有一个公共名称，

404
00:14:54,000 --> 00:14:55,980
该存储库目前是

405
00:14:55,980 --> 00:14:59,550
为我的狗命名的，它只是 Terrier，它

406
00:14:59,550 --> 00:15:00,660
不会成为系统的名称，

407
00:15:00,660 --> 00:15:01,620
因为这对数据库系统来说不是一个好名字，

408
00:15:01,620 --> 00:15:04,019
所以我们都

409
00:15:04,019 --> 00:15:06,809
在本学期晚些时候宣布了这个名字，

410
00:15:06,809 --> 00:15:09,000
一旦我们

411
00:15:09,000 --> 00:15:11,490
得到第一个版本，就发布网站发布网站 你

412
00:15:11,490 --> 00:15:12,540
关心的事情是它会是一个

413
00:15:12,540 --> 00:15:14,339
现代代码库，每站用 C++ 11

414
00:15:14,339 --> 00:15:17,850
加上 17 它是多线程的，

415
00:15:17,850 --> 00:15:19,589
我们使用 LLVM 再次进行查询编译

416
00:15:19,589 --> 00:15:21,780
我将解释那是什么

417
00:15:21,780 --> 00:15:24,460
，整个学期所有的东西都是

418
00:15:24,460 --> 00:15:25,840
开源的，它被设计为与 Postgres

419
00:15:25,840 --> 00:15:28,090
兼容，所以你更容易

420
00:15:28,090 --> 00:15:29,350
实际进入，你知道

421
00:15:29,350 --> 00:15:32,320
使用终端与这个东西交互，所以

422
00:15:32,320 --> 00:15:34,030
所有的程序项目都基于

423
00:15:34,030 --> 00:15:35,650
这个，我们' 将使用 github 来

424
00:15:35,650 --> 00:15:38,470
管理所有内容，以便我们将在

425
00:15:38,470 --> 00:15:42,310
下周早些时候进行朗诵

426
00:15:42,310 --> 00:15:44,920
，向您概述

427
00:15:44,920 --> 00:15:47,980
系统源代码的布局方式，并提供

428
00:15:47,980 --> 00:15:48,970
有关如何

429
00:15:48,970 --> 00:15:50,680
开始第一个项目的指示 我们将

430
00:15:50,680 --> 00:15:52,440
在本周晚些时候宣布它将在 Piazza 上的位置所以

431
00:15:52,440 --> 00:15:56,680


432
00:15:56,680 --> 00:15:58,000
你要做的所有开发都是在你的本地机器

433
00:15:58,000 --> 00:15:59,920
上进行的

434
00:15:59,920 --> 00:16:02,380


435
00:16:02,380 --> 00:16:05,280


436
00:16:05,280 --> 00:16:08,950
我还没有尝试过这个我

437
00:16:08,950 --> 00:16:11,230
不知道它是否有效但我们

438
00:16:11,230 --> 00:16:14,620
还为您提供了一个刚刚下载的流浪 PM

439
00:16:14,620 --> 00:16:15,850
文件您想

440
00:16:15,850 --> 00:16:17,320
在您的手机上的 Linux VM 中运行它

441
00:16:17,320 --> 00:16:19,180
您的 Windows 机器所以哟

442
00:16:19,180 --> 00:16:20,590
您在本地机器上完成所有开发工作，但

443
00:16:20,590 --> 00:16:22,630
对于第一个和第二个项目

444
00:16:22,630 --> 00:16:24,340
以及可能的第三个项目，

445
00:16:24,340 --> 00:16:26,140
您需要进行所有基准测试，请

446
00:16:26,140 --> 00:16:28,470
考虑使用 Amazon 进行性能测试，

447
00:16:28,470 --> 00:16:31,090
因为它们将在 ECG 机器上进行，

448
00:16:31,090 --> 00:16:32,410
因为您可以获得 拥有

449
00:16:32,410 --> 00:16:33,910
比本地笔记本电脑更多内核的机器，

450
00:16:33,910 --> 00:16:38,710
因此将为每个人提供

451
00:16:38,710 --> 00:16:40,870
您可以在亚马逊上使用的优惠券或信用代码，

452
00:16:40,870 --> 00:16:43,930
让您了解几美元即可购买这些

453
00:16:43,930 --> 00:16:44,860
机器，这样您就不会

454
00:16:44,860 --> 00:16:46,210
自掏腰包，所以我们会发送 该

455
00:16:46,210 --> 00:16:48,490
信息

456
00:16:48,490 --> 00:16:52,600
稍后会在本学期晚些时候发布，因此前

457
00:16:52,600 --> 00:16:54,820
两个项目将为您提供

458
00:16:54,820 --> 00:16:56,110
测试用例和脚本，并为

459
00:16:56,110 --> 00:16:58,000
您提供有关

460
00:16:58,000 --> 00:16:59,650
周一需要为您的项目在系统中修改的内容的明确说明

461
00:16:59,650 --> 00:17:01,300
教

462
00:17:01,300 --> 00:17:03,160
你如何使用

463
00:17:03,160 --> 00:17:04,750
完美的调用盐水来描述系统，但这

464
00:17:04,750 --> 00:17:06,250
可能不是

465
00:17:06,250 --> 00:17:10,270
大多数学生有经验的东西，

466
00:17:10,270 --> 00:17:11,709
所以第一个项目将单独完成

467
00:17:11,709 --> 00:17:14,500
第二个项目是我们

468
00:17:14,500 --> 00:17:16,390
三人一组完成的，所以

469
00:17:16,390 --> 00:17:18,520
目前班级大约有 36 人，

470
00:17:18,520 --> 00:17:19,930
大约有 12 或 13 人，每组

471
00:17:19,930 --> 00:17:21,760
三人 我喜欢保留三个人，

472
00:17:21,760 --> 00:17:23,530
因为这样不算

473
00:17:23,530 --> 00:17:27,790
太少也不算太少 除了一些

474
00:17:27,790 --> 00:17:29,410
例外，或者根据具体情况，

475
00:17:29,410 --> 00:17:31,120
如果我们有实际人员，我们可以做一个

476
00:17:31,120 --> 00:17:34,150
四人或三人或四人或两人的

477
00:17:34,150 --> 00:17:35,120
小组，

478
00:17:35,120 --> 00:17:37,730
但同样，大多数其他人都

479
00:17:37,730 --> 00:17:39,470
应该在一个

480
00:17:39,470 --> 00:17:40,460
三人组中 你开始考虑

481
00:17:40,460 --> 00:17:42,610
你现在想加入哪个小组

482
00:17:42,610 --> 00:17:46,549
第三个项目将是

483
00:17:46,549 --> 00:17:47,840
小组项目，这将

484
00:17:47,840 --> 00:17:49,340
是你可以选择在我们的系统中构建的

485
00:17:49,340 --> 00:17:51,019
东西，所以它必须

486
00:17:51,019 --> 00:17:52,429
是与

487
00:17:52,429 --> 00:17:54,679
我们在课堂上讨论的主题材料

488
00:17:54,679 --> 00:17:56,899
必须需要

489
00:17:56,899 --> 00:17:59,509
团队中每个人的大量计划努力，并且

490
00:17:59,509 --> 00:18:01,580
必须是独一无二的 您不能让两个

491
00:18:01,580 --> 00:18:02,990
小组在同一个项目上工作，而且

492
00:18:02,990 --> 00:18:04,759
显然要得到我的批准，所以

493
00:18:04,759 --> 00:18:06,649
不要 不要害怕 现在你

494
00:18:06,649 --> 00:18:09,080
不必选择一个项目，直到我们

495
00:18:09,080 --> 00:18:11,330
在春假之后再来，然后我

496
00:18:11,330 --> 00:18:13,159
还将提供一些示例

497
00:18:13,159 --> 00:18:14,769
项目主题，您可以从中选择

498
00:18:14,769 --> 00:18:20,509
以在我们的系统中构建，因此再次用于

499
00:18:20,509 --> 00:18:22,820
第一个和第二个项目 请

500
00:18:22,820 --> 00:18:24,649
不要抄袭请不要互相抄袭

501
00:18:24,649 --> 00:18:28,700
如果你为项目二借一个图书馆，

502
00:18:28,700 --> 00:18:30,230
这可能

503
00:18:30,230 --> 00:18:32,210
不一定是项目三再次

504
00:18:32,210 --> 00:18:33,529
来找我但再一次不要愚蠢

505
00:18:33,529 --> 00:18:35,840
不要复制，没有人会 任何

506
00:18:35,840 --> 00:18:39,740
问题都可以，所以期末考试

507
00:18:39,740 --> 00:18:41,870
将是一次带回家的考试，这将是

508
00:18:41,870 --> 00:18:43,340
基于菜单的长式问题，

509
00:18:43,340 --> 00:18:44,299
其中任何阅读停止似乎

510
00:18:44,299 --> 00:18:45,710


511
00:18:45,710 --> 00:18:47,899
都在课堂上进行测试我将在 4 月 22 日的课堂上给出它

512
00:18:47,899 --> 00:18:49,100
是冬天 如果在同

513
00:18:49,100 --> 00:18:51,320
一天演讲嘉宾也会来

514
00:18:51,320 --> 00:18:54,250
演讲，然后可能会在

515
00:18:54,250 --> 00:18:56,360
一周后的最后一天上课，

516
00:18:56,360 --> 00:18:58,220
或者当我们做最后的项目

517
00:18:58,220 --> 00:19:01,419
演示时，我还没有决定

518
00:19:01,419 --> 00:19:03,559
好， 这

519
00:19:03,559 --> 00:19:05,210
学期的额外学分是 就像我们在介绍课上所做的一样，

520
00:19:05,210 --> 00:19:07,460
所以我们正在编写卡内基梅隆大学

521
00:19:07,460 --> 00:19:09,559
的数据库系统百科全书

522
00:19:09,559 --> 00:19:12,830
我目前知道我

523
00:19:12,830 --> 00:19:14,000
认为现在我们知道的数字是

524
00:19:14,000 --> 00:19:15,320
683 个数据库系统

525
00:19:15,320 --> 00:19:17,629
，所以你可以获得额外的

526
00:19:17,629 --> 00:19:20,120
学分 如果你写了

527
00:19:20,120 --> 00:19:22,580
一篇关于一个特定数据库系统的维基百科风格的文章，

528
00:19:22,580 --> 00:19:24,440
那么里面有很多

529
00:19:24,440 --> 00:19:26,000
我选择一个，那么你知道你觉得

530
00:19:26,000 --> 00:19:28,009
很有趣，你

531
00:19:28,009 --> 00:19:30,230
对它的实际实现方式是正确的，并且你已经

532
00:19:30,230 --> 00:19:32,029
在

533
00:19:32,029 --> 00:19:35,450
你的数据库中提供了引用和归属 归因于您找到

534
00:19:35,450 --> 00:19:36,620
此信息的位置 这不仅仅是说

535
00:19:36,620 --> 00:19:37,879
这是它的作用 因为我读过 我

536
00:19:37,879 --> 00:19:39,620
看过一个视频 您必须实际拥有

537
00:19:39,620 --> 00:19:41,059
引文 因为您正在尝试

538
00:19:41,059 --> 00:19:42,080
为此尝试使这件事具有

539
00:19:42,080 --> 00:19:44,019
科学性 所以这完全是可选的

540
00:19:44,019 --> 00:19:47,149
不必这样做，但如果

541
00:19:47,149 --> 00:19:49,690
你不这样做，

542
00:19:49,690 --> 00:19:52,910
那么对于额外的信用

543
00:19:52,910 --> 00:19:56,419
文章，每年都会发生这种情况，这

544
00:19:56,419 --> 00:19:59,540
让我发疯，不要抄袭，不

545
00:19:59,540 --> 00:20:01,580
要这样做 你知道即使是那些额外的信用你

546
00:20:01,580 --> 00:20:02,450
仍然会遇到麻烦

547
00:20:02,450 --> 00:20:05,390
我们仍然向华纳音乐厅

548
00:20:05,390 --> 00:20:07,850
报告人们那些剽窃额外

549
00:20:07,850 --> 00:20:10,880
信用的权利就像我

550
00:20:10,880 --> 00:20:12,169
在这些视频中一遍又一遍地说这个的原因

551
00:20:12,169 --> 00:20:14,660
是因为我告诉 你不

552
00:20:14,660 --> 00:20:16,520
抄袭，所以如果你真的抄袭，

553
00:20:16,520 --> 00:20:18,350
我去华纳音乐厅坐下来给

554
00:20:18,350 --> 00:20:19,970
他们看这个视频，然后说看这里

555
00:20:19,970 --> 00:20:21,320
我告诉全班不要抄袭，

556
00:20:21,320 --> 00:20:24,140
他们抄袭，所以不要这样做

557
00:20:24,140 --> 00:20:27,500
，要么分解为 今年的成绩

558
00:20:27,500 --> 00:20:29,600
是阅读视图

559
00:20:29,600 --> 00:20:32,990
值 15% 项目 1 值再次值 10%

560
00:20:32,990 --> 00:20:34,280
这主要是为了让你

561
00:20:34,280 --> 00:20:36,400
熟悉代码库

562
00:20:36,400 --> 00:20:38,960
项目你是 20% 项目 3 是 45%

563
00:20:38,960 --> 00:20:41,299
期末考试是 10% 然后你 可以订购

564
00:20:41,299 --> 00:20:44,210
您可以为您的额外学分赚取额外的 10%

565
00:20:44,210 --> 00:20:48,799
所以

566
00:20:48,799 --> 00:20:50,179
整个课程中的所有讨论我们都不是广场

567
00:20:50,179 --> 00:20:51,679
，这是每个人都应该已经注册的链接，

568
00:20:51,679 --> 00:20:53,240


569
00:20:53,240 --> 00:20:55,580
如果没有发生，必须在此之前注册

570
00:20:55,580 --> 00:20:57,140
请给我发电子邮件

571
00:20:57,140 --> 00:20:59,419
如果你有一个关于项目的技术问题，我们可以解决这个

572
00:20:59,419 --> 00:21:01,370
问题，比如我尝试

573
00:21:01,370 --> 00:21:02,900
在 VM 中运行它但它没有用

574
00:21:02,900 --> 00:21:04,460
我尝试编译它没有用或者

575
00:21:04,460 --> 00:21:06,080
这段代码是什么请

576
00:21:06,080 --> 00:21:08,750
不要发送电子邮件 我或马特直接请

577
00:21:08,750 --> 00:21:10,250
在 Piazza 上发帖，因为

578
00:21:10,250 --> 00:21:12,380
如果您

579
00:21:12,380 --> 00:21:14,140
有其他人有类似问题的问题，这又是一次小组讨论，

580
00:21:14,140 --> 00:21:16,190
所以 Piazza 是做

581
00:21:16,190 --> 00:21:18,799
任何与项目、

582
00:21:18,799 --> 00:21:20,030
家庭作业、作业或其他事情无关的事情的正确地方，

583
00:21:20,030 --> 00:21:22,460
请您通过电子邮件发送您知道的 直接就像

584
00:21:22,460 --> 00:21:25,669
你生病了或你的狗死了给我发电子邮件

585
00:21:25,669 --> 00:21:27,790


586
00:21:27,790 --> 00:21:31,120
好吧，这就是你

587
00:21:31,120 --> 00:21:32,380
在背景之前知道

588
00:21:32,380 --> 00:21:35,920
课程将是关于物流的所以现在我

589
00:21:35,920 --> 00:21:38,440
想做一些足够有趣的

590
00:21:38,440 --> 00:21:40,140
关于历史的迷你讲座 数据库

591
00:21:40,140 --> 00:21:43,630
所以这个讲座实际上是

592
00:21:43,630 --> 00:21:46,510
基于两篇论文，一篇是由 Mike Stormbreaker 写的，

593
00:21:46,510 --> 00:21:47,890
叫做什么

594
00:21:47,890 --> 00:21:49,990
来了，那是

595
00:21:49,990 --> 00:21:51,490
在 2006 年发表的，有点像

596
00:21:51,490 --> 00:21:53,470
你知道历史的回顾

597
00:21:53,470 --> 00:21:55,990
到目前为止的数据库理论，

598
00:21:55,990 --> 00:21:58,090
然后第二篇论文是我

599
00:21:58,090 --> 00:22:01,420
和伦敦的一位行业分析师一起写

600
00:22:01,420 --> 00:22:04,270
的一篇新

601
00:22:04,270 --> 00:22:07,000
的续集，从迈克在 2006 年停止的地方

602
00:22:07,000 --> 00:22:09,880
开始，讨论了 新的

603
00:22:09,880 --> 00:22:11,740
续集系统以及它们如何

604
00:22:11,740 --> 00:22:15,910
适应数据库的历史，

605
00:22:15,910 --> 00:22:20,160
所以数据库是一个非常古老的话题

606
00:22:20,160 --> 00:22:23,140
，而且它今天仍然很热门

607
00:22:23,140 --> 00:22:23,500
，

608
00:22:23,500 --> 00:22:26,770
我喜欢数据库，所以很高兴

609
00:22:26,770 --> 00:22:28,570
了解你知道我们如何

610
00:22:28,570 --> 00:22:32,320
到达我们的重点” 现在，所以

611
00:22:32,320 --> 00:22:35,080
从这两篇论文

612
00:22:35,080 --> 00:22:39,070
中得出的主要结论是，在

613
00:22:39,070 --> 00:22:41,080
早期的数据库系统中

614
00:22:41,080 --> 00:22:42,730
，从 1960 年代和 1970 年代一直在电子邮件中

615
00:22:42,730 --> 00:22:45,780
面临的许多问题实际上仍然相关，

616
00:22:45,780 --> 00:22:47,800
你知道你是如何运行的 交易

617
00:22:47,800 --> 00:22:49,510
正确帕蒂如何维护

618
00:22:49,510 --> 00:22:51,460
索引所有这些

619
00:22:51,460 --> 00:22:53,260
事情仍然很重要只是不同的是

620
00:22:53,260 --> 00:22:56,950
硬件环境不同所以

621
00:22:56,950 --> 00:22:58,660
特别是一

622
00:22:58,660 --> 00:23:00,250
件事真的很吸引人 s

623
00:23:00,250 --> 00:23:01,630
这就是历史

624
00:23:01,630 --> 00:23:05,290
重演的方式，你知道现在已经

625
00:23:05,290 --> 00:23:07,150
过去十年了，但这种续集

626
00:23:07,150 --> 00:23:09,340
与没有续集的想法你知道哪一个

627
00:23:09,340 --> 00:23:10,780
更适合你知道不同的

628
00:23:10,780 --> 00:23:11,470
工作量

629
00:23:11,470 --> 00:23:14,650
，那场

630
00:23:14,650 --> 00:23:16,570
辩论基本上与他们曾经的辩论相同 在 1970 年代，

631
00:23:16,570 --> 00:23:18,520
关于关系模型与

632
00:23:18,520 --> 00:23:21,430
codasyl 或网络数据模型，如果

633
00:23:21,430 --> 00:23:23,800
您从未听说过 codasyl，这

634
00:23:23,800 --> 00:23:25,510
并不奇怪，因为它失去了

635
00:23:25,510 --> 00:23:26,830
关系模型，这就是为什么我们

636
00:23:26,830 --> 00:23:29,170
在关系数据库上开设了整个课程，以便

637
00:23:29,170 --> 00:23:32,470
您了解关系 数据模型

638
00:23:32,470 --> 00:23:35,110
已被证明具有弹性和健壮性

639
00:23:35,110 --> 00:23:36,010
，

640
00:23:36,010 --> 00:23:37,600
您知道对几乎所有

641
00:23:37,600 --> 00:23:40,780
可能的数据库工作负载都有用，

642
00:23:40,780 --> 00:23:42,250
我想说的唯一例外是潜在的

643
00:23:42,250 --> 00:23:43,570
机器学习，因为它们是

644
00:23:43,570 --> 00:23:45,340
数组，尽管您可以

645
00:23:45,340 --> 00:23:47,470
在关系数据库中对它们进行建模，但您

646
00:23:47,470 --> 00:23:51,310
不知道 以这种糟糕的方式

647
00:23:51,310 --> 00:23:52,450
，整个学期讨论的许多想法都不是

648
00:23:52,450 --> 00:23:53,890


649
00:23:53,890 --> 00:23:55,990
新的了，我们只是在讨论

650
00:23:55,990 --> 00:23:57,640
现代工具 心理

651
00:23:57,640 --> 00:23:59,500
是它们的化身，在整个学期中，你总是听到我

652
00:23:59,500 --> 00:24:00,940
说，或者

653
00:24:00,940 --> 00:24:02,740
当我们谈论特定主题时你知道

654
00:24:02,740 --> 00:24:04,780
我会说哦，实际上

655
00:24:04,780 --> 00:24:06,910
IBM 在 1970 年代用 system 或 ingress 做了同样的事情

656
00:24:06,910 --> 00:24:08,500


657
00:24:08,500 --> 00:24:12,310
1970 年代伯克利的情况也是如此

658
00:24:12,310 --> 00:24:14,470
，这些技术中的很多都不是新

659
00:24:14,470 --> 00:24:16,030
的，现在它们中的一些又重新

660
00:24:16,030 --> 00:24:18,190
流行起来，因为港口

661
00:24:18,190 --> 00:24:20,500
实际上可以支持这一点，所以我认为

662
00:24:20,500 --> 00:24:22,510
这非常有趣，这

663
00:24:22,510 --> 00:24:24,130
也是原因之一 为什么你知道数据库

664
00:24:24,130 --> 00:24:27,070
仍然相关仍然是热门话题并且

665
00:24:27,070 --> 00:24:30,580
今天仍然需要所以让我们回到

666
00:24:30,580 --> 00:24:33,220
一开始第一个

667
00:24:33,220 --> 00:24:35,920
数据库系统是在 1960 年代开发的，

668
00:24:35,920 --> 00:24:38,110
称为 ID 集成数据

669
00:24:38,110 --> 00:24:42,940
存储，因此它是在 GE

670
00:24:42,940 --> 00:24:46,450
通用电气开发的 在内部为一些

671
00:24:46,450 --> 00:24:50,260
客户我认为它正在做一个像西雅图这样的木材

672
00:24:50,260 --> 00:24:51,910
服务或木材公司

673
00:24:51,910 --> 00:24:55,000
所以他们建立了这个数据库

674
00:24:55,000 --> 00:24:57,760
系统并为这个客户和它

675
00:24:57,760 --> 00:25:00,820
帮助了他们 你知道控制

676
00:25:00,820 --> 00:25:04,630
他们的大型组织，所以你可能会

677
00:25:04,630 --> 00:25:06,730
很好地思考安迪 我听说过 GE

678
00:25:06,730 --> 00:25:08,650
销售计算机或销售数据库

679
00:25:08,650 --> 00:25:10,510
GE 如何负责

680
00:25:10,510 --> 00:25:11,650
构建第一个数据库系统 发生在他们身上的事情

681
00:25:11,650 --> 00:25:14,590
很好 事实证明，GE 在

682
00:25:14,590 --> 00:25:18,160
当时有这种商业理念

683
00:25:18,160 --> 00:25:20,140
，他们说如果他们不能成为市场特定领域的

684
00:25:20,140 --> 00:25:22,660
第一大公司，

685
00:25:22,660 --> 00:25:24,850
那么他们

686
00:25:24,850 --> 00:25:25,990
根本不想进入那个市场，

687
00:25:25,990 --> 00:25:28,540
所以他们说我们不是数字 一个

688
00:25:28,540 --> 00:25:30,850
计算让我们把它全部卖掉我们

689
00:25:30,850 --> 00:25:32,080
不想参与其中所以

690
00:25:32,080 --> 00:25:33,520
他们在 1969 年将整个计算部门卖给了

691
00:25:33,520 --> 00:25:36,100
霍尼韦尔，作为其中的一部分，

692
00:25:36,100 --> 00:25:40,030
他们还出售了 ID，我实际上不知道

693
00:25:40,030 --> 00:25:42,480
ID 是否仍然存在 今天

694
00:25:42,480 --> 00:25:47,080
我的意思是它可能是的，但这

695
00:25:47,080 --> 00:25:48,580
通常

696
00:25:48,580 --> 00:25:50,770
是系统的第一个日期之一，因此

697
00:25:50,770 --> 00:25:53,260
与我们相关的 ID 的两个关键事项

698
00:25:53,260 --> 00:25:55,000
是他们将使用所谓

699
00:25:55,000 --> 00:25:56,950
的网络数据建模，我'

700
00:25:56,950 --> 00:25:59,560
将在 几张幻灯片，当

701
00:25:59,560 --> 00:26:00,880
您执行查询时，您

702
00:26:00,880 --> 00:26:02,470
基本上会编写一堆 for

703
00:26:02,470 --> 00:26:05,890
循环，一次对单个元组

704
00:26:05,890 --> 00:26:09,400
进行操作，我们将与

705
00:26:09,400 --> 00:26:10,480
它们的关系模型进行对比，这些模型可以

706
00:26:10,480 --> 00:26:15,010
对包或集合进行操作，因此

707
00:26:15,010 --> 00:26:18,940
真正帮助建立 ID 的人是查尔斯·巴赫曼 (Charles Bachman) 的

708
00:26:18,940 --> 00:26:20,560
一位名叫查理·巴金 (Charlie Barkin) 的早期计算机科学家

709
00:26:20,560 --> 00:26:22,450


710
00:26:22,450 --> 00:26:25,510
，他今天实际上还活着，他最终

711
00:26:25,510 --> 00:26:28,120
在 1970 年代初离开了霍尼韦尔，

712
00:26:28,120 --> 00:26:30,790
去了另一家

713
00:26:30,790 --> 00:26:32,470
名为 Cool Lane 数据库系统的计算机公司。

714
00:26:32,470 --> 00:26:34,660
今天仍然存在，他帮助建立了一个

715
00:26:34,660 --> 00:26:36,370
新的网络数据模型系统，称为 ID

716
00:26:36,370 --> 00:26:39,580
8i DMS 或一个集成管理

717
00:26:39,580 --> 00:26:41,770
系统集成数据管理系统

718
00:26:41,770 --> 00:26:43,890
，实际上今天仍然存在，

719
00:26:43,890 --> 00:26:48,250
所以 Bachman 和其他

720
00:26:48,250 --> 00:26:52,600
一些参与 COBOL 编程的

721
00:26:52,600 --> 00:26:55,630
人聚在一起 1960 年代后期，并

722
00:26:55,630 --> 00:26:59,470
提出了一个名为 codasyl 的标准

723
00:26:59,470 --> 00:27:01,570
，关于用 COBOL 编写的程序应该如何

724
00:27:01,570 --> 00:27:03,250
访问数据库 想想我们他们

725
00:27:03,250 --> 00:27:04,330
正在尝试 o 定义一个标准 API

726
00:27:04,330 --> 00:27:07,540
，每个用 COBOL 编写的数据库系统

727
00:27:07,540 --> 00:27:10,440
都可以

728
00:27:10,440 --> 00:27:13,150
支持，根据他在

729
00:27:13,150 --> 00:27:15,340
霍尼韦尔的经验，这个 codasyl 基于

730
00:27:15,340 --> 00:27:16,660
never 数据模型，因此它

731
00:27:16,660 --> 00:27:20,110
在查询执行期间一次对一个元组进行操作，

732
00:27:20,110 --> 00:27:25,000
因此 Bachman 他是

733
00:27:25,000 --> 00:27:26,620
早期的数据库先驱吗？

734
00:27:26,620 --> 00:27:28,600
他赢得了 19 世纪 70 年代初他因为这项工作获得了图灵奖

735
00:27:28,600 --> 00:27:29,710
他

736
00:27:29,710 --> 00:27:30,640
说第一个真正

737
00:27:30,640 --> 00:27:34,090
获得数据库图灵奖的人 所以

738
00:27:34,090 --> 00:27:35,350
这就是网络数据模型的

739
00:27:35,350 --> 00:27:37,470
样子 因为这是示例应用程序

740
00:27:37,470 --> 00:27:40,630
假设我们就像一家大型工程

741
00:27:40,630 --> 00:27:43,480
公司 我们正在尝试模拟

742
00:27:43,480 --> 00:27:45,370
如何跟踪

743
00:27:45,370 --> 00:27:46,720
我们必须从不同供应商那里购买的所有不同部件

744
00:27:46,720 --> 00:27:49,390
来制造一些你知道的大型

745
00:27:49,390 --> 00:27:52,270
火箭 这实际上是一个真实的例子

746
00:27:52,270 --> 00:27:54,010
我们将在更多的幻灯片中看到，但

747
00:27:54,010 --> 00:27:55,600
我的数据库中有我想

748
00:27:55,600 --> 00:27:58,120
跟踪供应商零件以及

749
00:27:58,120 --> 00:28:01,550
哪个供应商供应每个零件，

750
00:28:01,550 --> 00:28:03,170
以便网络数据模型设置 最重要的是

751
00:28:03,170 --> 00:28:04,550
，您拥有这些数据集合，

752
00:28:04,550 --> 00:28:07,400
例如供应商、零件和供应，但

753
00:28:07,400 --> 00:28:08,630
随后您还必须定义

754
00:28:08,630 --> 00:28:11,780
这些成员资格集，以说明

755
00:28:11,780 --> 00:28:16,220
您知道 a 和一组中的记录是否

756
00:28:16,220 --> 00:28:19,520
是您的成员 知道

757
00:28:19,520 --> 00:28:22,700
由另一组拥有，以便显示，我可以

758
00:28:22,700 --> 00:28:24,380
举例说明这会是什么样子，所以

759
00:28:24,380 --> 00:28:25,910
说这些是我使用我的

760
00:28:25,910 --> 00:28:27,500
数据集合或我的记录供应商部分和

761
00:28:27,500 --> 00:28:29,720
供应所以我现在将拥有这些

762
00:28:29,720 --> 00:28:31,280
成员集呼叫

763
00:28:31,280 --> 00:28:34,550
供应并由其提供 指向

764
00:28:34,550 --> 00:28:37,670
说 4 8 4 的指针你知道对于

765
00:28:37,670 --> 00:28:40,790
父和子之间的给定成员资格，

766
00:28:40,790 --> 00:28:42,950
这里是指向父记录的所有父指针

767
00:28:42,950 --> 00:28:44,510
，这里是

768
00:28:44,510 --> 00:28:46,610
指向子记录的所有子指针，所以现在

769
00:28:46,610 --> 00:28:48,080
假设我去查询并说找到

770
00:28:48,080 --> 00:28:50,060
我 由特定供应商提供的所有部件

771
00:28:50,060 --> 00:28:52,010
我必须编写

772
00:28:52,010 --> 00:28:53,980
这些嵌套的 for 循环来

773
00:28:53,980 --> 00:28:56,210
找到我想要的供应商

774
00:28:56,210 --> 00:28:59,030
迭代供应集然后

775
00:28:59,030 --> 00:29:00,950
用供应集迭代她然后

776
00:29:00,950 --> 00:29:02,570
用 s 迭代你知道 到

777
00:29:02,570 --> 00:29:05,630
那时我提供然后我到达我的我的部分

778
00:29:05,630 --> 00:29:07,790
记录我们的部分数据收集我

779
00:29:07,790 --> 00:29:08,870
可以找到我正在寻找的东西

780
00:29:08,870 --> 00:29:12,680
所以在这里要指出的第一件事

781
00:29:12,680 --> 00:29:14,990
是网络数据模型

782
00:29:14,990 --> 00:29:16,250
要求您必须 编写复杂的

783
00:29:16,250 --> 00:29:18,260
查询，您实际上是在编写低

784
00:29:18,260 --> 00:29:22,580
级别的 for 循环来遍历这个，而

785
00:29:22,580 --> 00:29:23,810
不是永远不必找到您正在

786
00:29:23,810 --> 00:29:26,960
寻找的数据 另一个问题更多的是

787
00:29:26,960 --> 00:29:31,280
一个实现方面，但

788
00:29:31,280 --> 00:29:33,260
这些这些数据库变得

789
00:29:33,260 --> 00:29:36,530
很容易 容易损坏，因为 AB

790
00:29:36,530 --> 00:29:39,530
在 1916 年 70 年代看到磁盘很贵，

791
00:29:39,530 --> 00:29:41,030
它们不像今天那么可靠

792
00:29:41,030 --> 00:29:43,670
，人们不知道

793
00:29:43,670 --> 00:29:46,790
维护多个数据副本，所以

794
00:29:46,790 --> 00:29:48,260
如果

795
00:29:48,260 --> 00:29:51,020
这些成员集之一被损坏会发生什么，你

796
00:29:51,020 --> 00:29:52,400
说 你丢失了整个数据库，因为

797
00:29:52,400 --> 00:29:54,170
现在你无法知道事情

798
00:29:54,170 --> 00:29:57,100
是如何联系在一起的，

799
00:29:57,520 --> 00:30:02,140
所以网络数据模型和

800
00:30:02,140 --> 00:30:04,940
ID 首先出现，但另一个数据库

801
00:30:04,940 --> 00:30:06,350
是在

802
00:30:06,350 --> 00:30:09,020
同一时间构建的 在 1960 年代后期

803
00:30:09,020 --> 00:30:10,370


804
00:30:10,370 --> 00:30:12,440
，IBM 在信息管理系统中称为 IMS 的东西是什么，

805
00:30:12,440 --> 00:30:14,870
所以 IMS 非常有名，

806
00:30:14,870 --> 00:30:17,240


807
00:30:17,240 --> 00:30:19,659
如果您曾经在 atm 上使用过，那么它在今天仍然被广泛使用

808
00:30:19,659 --> 00:30:21,710


809
00:30:21,710 --> 00:30:23,360
它仍然

810
00:30:23,360 --> 00:30:27,320
存在，所以 IMS 实际上是一个数据库

811
00:30:27,320 --> 00:30:29,840
，IBM 建立的 IBM 用于跟踪

812
00:30:29,840 --> 00:30:31,190
零件供应的采购订单

813
00:30:31,190 --> 00:30:33,620
以及为 NASA 的阿波罗登月任务提供的信息，

814
00:30:33,620 --> 00:30:35,600
之前被

815
00:30:35,600 --> 00:30:38,990
称为 NASA 但与 codasyl 不同的是，它不

816
00:30:38,990 --> 00:30:41,390
使用网络数据 模型他们使用

817
00:30:41,390 --> 00:30:43,789
所谓的分层数据模型

818
00:30:43,789 --> 00:30:46,190
关于 IMS 的另一个有趣的方面

819
00:30:46,190 --> 00:30:48,169
是他们让程序员定义了

820
00:30:48,169 --> 00:30:51,110
物理存储格式，所以当你

821
00:30:51,110 --> 00:30:53,149
声明你知道我有一个

822
00:30:53,149 --> 00:30:55,789
像表一样的数据集合时，你还必须定义

823
00:30:55,789 --> 00:30:57,169
什么是底层

824
00:30:57,169 --> 00:30:58,490


825
00:30:58,490 --> 00:31:00,500
无论您想要

826
00:31:00,500 --> 00:31:01,820
哈希表还是其他东西来订购

827
00:31:01,820 --> 00:31:04,549
保留树，您都可以用来将数据物理存储在磁盘上的数据结构，因此它也像

828
00:31:04,549 --> 00:31:07,220
网络一样 ata 模型虽然你会

829
00:31:07,220 --> 00:31:08,799
尝试这四个循环来遍历

830
00:31:08,799 --> 00:31:11,510
层次结构并执行查询，你

831
00:31:11,510 --> 00:31:12,740
知道编写查询并一次对

832
00:31:12,740 --> 00:31:16,640
单个元组进行操作，所以现在再次

833
00:31:16,640 --> 00:31:18,860
插入简单的供应商信息一个

834
00:31:18,860 --> 00:31:21,020
例子，现在我们只有两种

835
00:31:21,020 --> 00:31:22,640
集合 有供应商和零件，

836
00:31:22,640 --> 00:31:25,940
但在这种情况下，我们实际上看到

837
00:31:25,940 --> 00:31:26,929
了大量冗余信息的问题，

838
00:31:26,929 --> 00:31:27,440


839
00:31:27,440 --> 00:31:29,539
因此我们将这个供应商

840
00:31:29,539 --> 00:31:31,460
数据与我们的记录一起收集，然后

841
00:31:31,460 --> 00:31:34,460
这些记录中的每一个现在都会有一个

842
00:31:34,460 --> 00:31:36,409
指向其他数据结构的指针 会有

843
00:31:36,409 --> 00:31:39,860
他们所有的零件信息，所以

844
00:31:39,860 --> 00:31:41,960
我们在这里遇到的明显问题

845
00:31:41,960 --> 00:31:44,120
是重复数据，因为如果

846
00:31:44,120 --> 00:31:47,480
多个供应商提供相同的零件，

847
00:31:47,480 --> 00:31:50,090
我必须有不同的实例

848
00:31:50,090 --> 00:31:52,370
，你知道在这种情况下，

849
00:31:52,370 --> 00:31:54,200
大电池一遍又一

850
00:31:54,200 --> 00:31:55,909
遍地记录 每个

851
00:31:55,909 --> 00:31:58,010
销售该零件的供应商，这意味着现在

852
00:31:58,010 --> 00:32:00,230
如果零件的名称发生变化，我

853
00:32:00,230 --> 00:32:02,059
必须编写额外的代码才能找到所有

854
00:32:02,059 --> 00:32:04,730
实例 电池大

855
00:32:04,730 --> 00:32:07,309
电池并确保它们的名称

856
00:32:07,309 --> 00:32:08,870
同时更改在一起

857
00:32:08,870 --> 00:32:09,800
并且

858
00:32:09,800 --> 00:32:13,610
它们在那里同步

859
00:32:13,610 --> 00:32:15,230
除了一次查询元组之外的另一个大问题是

860
00:32:15,230 --> 00:32:17,900


861
00:32:17,900 --> 00:32:19,430
之间没有独立性

862
00:32:19,430 --> 00:32:22,130
数据库的

863
00:32:22,130 --> 00:32:24,080
数据库的物理数据结构以及

864
00:32:24,080 --> 00:32:26,990
程序员与之交互

865
00:32:26,990 --> 00:32:29,180
的逻辑抽象

866
00:32:29,180 --> 00:32:31,310


867
00:32:31,310 --> 00:32:32,720


868
00:32:32,720 --> 00:32:35,300


869
00:32:35,300 --> 00:32:37,700
意识到哦，我现在想要真正执行

870
00:32:37,700 --> 00:32:40,640
范围查询，现在我必须转储

871
00:32:40,640 --> 00:32:42,680
表并将其作为 B+ 树加载回来

872
00:32:42,680 --> 00:32:44,780
，然后现在我

873
00:32:44,780 --> 00:32:46,580
为该表更改方法所接触的 API

874
00:32:46,580 --> 00:32:49,160
重写了我的所有应用程序代码，这样就

875
00:32:49,160 --> 00:32:53,440
可以了 太浪费了，太痛苦了

876
00:32:54,250 --> 00:32:58,930
所以现在在 1960 年代末 1970 年代初

877
00:32:58,930 --> 00:33:01,220
有一位名叫 Ted

878
00:33:01,220 --> 00:33:03,770
Cod 的数学家，他在纽约的 IBM 研究院工作

879
00:33:03,770 --> 00:33:06,170
，他看到了所有这些

880
00:33:06,170 --> 00:33:09,530
程序员 在 IBM

881
00:33:09,530 --> 00:33:12,350
，

882
00:33:12,350 --> 00:33:13,880
每次数据库模式更改或布局

883
00:33:13,880 --> 00:33:15,890
更改时都会重写他们的 IMS 和 codasyl 程序，他认为这是

884
00:33:15,890 --> 00:33:17,870
浪费，因为

885
00:33:17,870 --> 00:33:20,870
每次模式更改时，您都知道

886
00:33:20,870 --> 00:33:22,760
现在必须重写应用程序代码

887
00:33:22,760 --> 00:33:25,730


888
00:33:25,730 --> 00:33:27,590
比人类贵得多，所以他

889
00:33:27,590 --> 00:33:30,410
在消除这种负担的目标上有先见之明，

890
00:33:30,410 --> 00:33:32,240
因为现在

891
00:33:32,240 --> 00:33:33,410
人类比机器贵两倍，

892
00:33:33,410 --> 00:33:37,160
机器便宜，所以当时

893
00:33:37,160 --> 00:33:38,990
这不是你知道的

894
00:33:38,990 --> 00:33:40,370
大问题 很难找到

895
00:33:40,370 --> 00:33:42,560
程序员，但意大利现在可能是一个很大的

896
00:33:42,560 --> 00:33:45,890
成本问题，所以他

897
00:33:45,890 --> 00:33:48,200
在关系模型中提出的是这种

898
00:33:48,200 --> 00:33:50,570
高度抽象的数据库，

899
00:33:50,570 --> 00:33:53,210
以避免

900
00:33:53,210 --> 00:33:57,050
对人类的所有此类维护负担，因此关系模型

901
00:33:57,050 --> 00:34:00,560
是 具有

902
00:34:00,560 --> 00:34:04,430
当今在数据库中广泛

903
00:34:04,430 --> 00:34:06,710
使用的三个关键思想，因此第一个是它不会存储

904
00:34:06,710 --> 00:34:08,929
数据库层次结构或

905
00:34:08,929 --> 00:34:11,270
带有图像的网络 我们

906
00:34:11,270 --> 00:34:13,399
存储数据库的 sh 结构只是这些

907
00:34:13,399 --> 00:34:15,560
简单的数据结构作为关系或

908
00:34:15,560 --> 00:34:18,830
表，现在我们将

909
00:34:18,830 --> 00:34:20,330
在 TOR 中编写我们的程序，以

910
00:34:20,330 --> 00:34:23,040
通过

911
00:34:23,040 --> 00:34:24,899
一些可以对这些关系进行操作的高级语言访问数据

912
00:34:24,899 --> 00:34:30,080
在第一篇论文的时候

913
00:34:30,409 --> 00:34:33,710
你知道他实际上并没有提出

914
00:34:33,710 --> 00:34:35,909
语言 我说这是

915
00:34:35,909 --> 00:34:37,918
他在 69 年写的第一篇论文 但这是

916
00:34:37,918 --> 00:34:39,389
每个人都引用的更常见的一篇论文

917
00:34:39,389 --> 00:34:42,300


918
00:34:42,300 --> 00:34:44,460
大型共享

919
00:34:44,460 --> 00:34:48,449
数据库 所以 MB 在这些开创性的论文中

920
00:34:48,449 --> 00:34:49,949
他实际上没有找到这种

921
00:34:49,949 --> 00:34:51,929
高级语言当然

922
00:34:51,929 --> 00:34:54,540
现在我们知道这是续集在当时

923
00:34:54,540 --> 00:34:56,520
续集并不存在所以

924
00:34:56,520 --> 00:34:58,830
你完全期望这篇论文

925
00:34:58,830 --> 00:35:00,210


926
00:35:00,210 --> 00:35:03,690
从数学角度严格描述关系模型

927
00:35:03,690 --> 00:35:05,430
quele 实际上是人们为 ingress 提出的第一种编程

928
00:35:05,430 --> 00:35:07,950
语言查询语言，

929
00:35:07,950 --> 00:35:10,500
它遵循

930
00:35:10,500 --> 00:35:13,140
IBM 后来推出的关系模型

931
00:35:13,140 --> 00:35:14,670
sequ  el 这是镇压文字的续集

932
00:35:14,670 --> 00:35:15,980


933
00:35:15,980 --> 00:35:18,000
Ted Cod 实际上

934
00:35:18,000 --> 00:35:19,920
在我认为在 1975 年的一篇论文中提出了他自己的语言 alpha，

935
00:35:19,920 --> 00:35:22,860
但没有人

936
00:35:22,860 --> 00:35:25,530
真正使用过他提出的另一个关键的

937
00:35:25,530 --> 00:35:26,910


938
00:35:26,910 --> 00:35:29,760
东西 ims 所做的

939
00:35:29,760 --> 00:35:32,310
是每个关系的物理存储表示

940
00:35:32,310 --> 00:35:33,780
实际上留给

941
00:35:33,780 --> 00:35:34,980
了数据库

942
00:35:34,980 --> 00:35:37,530
管理系统的实现所以这

943
00:35:37,530 --> 00:35:39,720
意味着我只是声明我想要一个表

944
00:35:39,720 --> 00:35:40,920
我想要一个具有这些属性的关系

945
00:35:40,920 --> 00:35:43,230
我没有说 我实际上

946
00:35:43,230 --> 00:35:45,450
希望它如何物理存储，现在

947
00:35:45,450 --> 00:35:47,070
数据库系统可以自行决定

948
00:35:47,070 --> 00:35:48,990
它实际想要如何正确存储内容

949
00:35:48,990 --> 00:35:50,220
如果它想使用哈希表

950
00:35:50,220 --> 00:35:51,840
想要使用 B+ 树 它可以立即执行

951
00:35:51,840 --> 00:35:54,030
任何操作

952
00:35:54,030 --> 00:35:55,740
理论上，如果我正确地执行此操作，数据会在物理上发生变化

953
00:35:55,740 --> 00:35:58,410


954
00:35:58,410 --> 00:35:58,890
，

955
00:35:58,890 --> 00:36:00,540
我不应该更改我的

956
00:36:00,540 --> 00:36:02,730
任何查询，我的

957
00:36:02,730 --> 00:36:03,840
应用程序中的任何查询，因为它们只是

958
00:36:03,840 --> 00:36:05,250
在 lo 上对数据库进行操作

959
00:36:05,250 --> 00:36:07,950
所以这些想法在今天似乎

960
00:36:07,950 --> 00:36:10,050
很明显，但在当时这

961
00:36:10,050 --> 00:36:12,660
实际上是有争议的

962
00:36:12,660 --> 00:36:15,270
，因为拥有一个

963
00:36:15,270 --> 00:36:17,250
能够支持高级语言

964
00:36:17,250 --> 00:36:19,380
的数据库系统的想法可以

965
00:36:19,380 --> 00:36:21,270
像人类可以编写的那样有效地生成查询

966
00:36:21,270 --> 00:36:25,920
计划 一个牵强的想法 它有点像

967
00:36:25,920 --> 00:36:27,330
后面板 你是否明白

968
00:36:27,330 --> 00:36:28,650
人们不认为像 C 这样的高级

969
00:36:28,650 --> 00:36:31,020
语言并且拥有

970
00:36:31,020 --> 00:36:33,750
C 的编译器可以产生你知道的机器

971
00:36:33,750 --> 00:36:35,470
代码和

972
00:36:35,470 --> 00:36:36,910
编写汇编一样有效，当然现在

973
00:36:36,910 --> 00:36:38,650
没有人你认识 实际上很少有人

974
00:36:38,650 --> 00:36:40,420
不编写我们用更高级别的语言编写的程序集，

975
00:36:40,420 --> 00:36:42,190
这又是

976
00:36:42,190 --> 00:36:44,470
在我们的现代世界中，这些似乎

977
00:36:44,470 --> 00:36:46,180
不是有争议的想法，但在

978
00:36:46,180 --> 00:36:50,830
那时，只是

979
00:36:50,830 --> 00:36:52,030
回到我们之前的简单示例中

980
00:36:52,030 --> 00:36:55,330
关系模型现在我们有三个

981
00:36:55,330 --> 00:36:57,700
关系供应商部分和供应，

982
00:36:57,700 --> 00:36:59,290
这些之间会有外键

983
00:36:59,290 --> 00:37:01,359
关系，

984
00:37:01,359 --> 00:37:03,880
所以现在在我的安装或实例中

985
00:37:03,880 --> 00:37:05,920
这个数据库的 ce 爱沙尼亚我

986
00:37:05,920 --> 00:37:07,810
现在可以在供应商编号

987
00:37:07,810 --> 00:37:11,680
或零件编号之间进行连接，以找到

988
00:37:11,680 --> 00:37:15,130
我的供应商记录的父记录的父记录，

989
00:37:15,130 --> 00:37:18,280
因此现在进行查找以

990
00:37:18,280 --> 00:37:19,810
查找通过给供应商我应用的所有零件

991
00:37:19,810 --> 00:37:22,060
可以在

992
00:37:22,060 --> 00:37:24,730
这三个表之间进行连接并准确找到

993
00:37:24,730 --> 00:37:27,070
我想要的内容，这也意味着在

994
00:37:27,070 --> 00:37:28,990
高级语言中我正在对

995
00:37:28,990 --> 00:37:31,630
数据库进行操作，就像通过集合一样我只是

996
00:37:31,630 --> 00:37:32,890
说这就是我希望你为我找到的

997
00:37:32,890 --> 00:37:35,170
我没有具体说明你知道如何

998
00:37:35,170 --> 00:37:37,210
迭代你知道如何构成时刻

999
00:37:37,210 --> 00:37:38,470
形式我想再次找到你正在寻找的东西

1000
00:37:38,470 --> 00:37:40,990
这是一个非常强大的

1001
00:37:40,990 --> 00:37:44,770
结构，它是我们

1002
00:37:44,770 --> 00:37:47,430
整个学期讨论的基础，

1003
00:37:47,430 --> 00:37:50,230
好吧 现在是这样，关系

1004
00:37:50,230 --> 00:37:53,080
模型在 1970 年代出现时有点

1005
00:37:53,080 --> 00:37:53,890
像我说的那样

1006
00:37:53,890 --> 00:37:56,170
有争议所以它会立即

1007
00:37:56,170 --> 00:37:57,190
调解这是构建数据库系统的正确方法

1008
00:37:57,190 --> 00:38:01,720
所以还有

1009
00:38:01,720 --> 00:38:03,339
其他几个关系数据库系统

1010
00:38:03,339 --> 00:38:04,900
当时构建，但

1011
00:38:04,900 --> 00:38:06,940
大多数人谈论的三个所以今天我们的

1012
00:38:06,940 --> 00:38:09,640
系统在伯克利的 IBM ingress

1013
00:38:09,640 --> 00:38:13,740
和 oracle by oracle 所以系统是

1014
00:38:13,740 --> 00:38:17,950
在 IBM 在圣何塞的研究中，

1015
00:38:17,950 --> 00:38:19,599
它不是由 jim Gray 领导，但他

1016
00:38:19,599 --> 00:38:20,800
可能是其中之一 那些

1017
00:38:20,800 --> 00:38:24,030
出自该组 ingress 的名人是

1018
00:38:24,030 --> 00:38:27,010
由我的一位顾问 Mike snowbreaker 开发的，

1019
00:38:27,010 --> 00:38:29,710
如果您在听说过 Postgres 之前从未听说过

1020
00:38:29,710 --> 00:38:32,080
ingress，对

1021
00:38:32,080 --> 00:38:34,150
吧，所以 snowbreaker 是在

1022
00:38:34,150 --> 00:38:35,890
ingress 之后构建的，然后他在 ingress 之后构建了 Postgres

1023
00:38:35,890 --> 00:38:37,660
就像 Postgres 代表 post

1024
00:38:37,660 --> 00:38:40,750
ingress 一样，所以我们将

1025
00:38:40,750 --> 00:38:42,010
在整个学期再次讨论这两个系统的自身

1026
00:38:42,010 --> 00:38:45,430
，然后 oracle 是一个

1027
00:38:45,430 --> 00:38:46,450
商业系统，Larry

1028
00:38:46,450 --> 00:38:48,340
Ellison 和现在他都像是

1029
00:38:48,340 --> 00:38:50,350
世界上最富有的人，所以

1030
00:38:50,350 --> 00:38:52,540
这个列表是 你

1031
00:38:52,540 --> 00:38:53,590
看看 Jim Gray 你看看 Mike

1032
00:38:53,590 --> 00:38:55,210
Stonebraker 这两个人都获得

1033
00:38:55,210 --> 00:38:57,100
了数据库巡回奖 Larry

1034
00:38:57,100 --> 00:38:58,810
Ellison 正如我所说他就像世界上第七

1035
00:38:58,810 --> 00:38:59,980
或第八大

1036
00:38:59,980 --> 00:39:01,540
富豪 我因为这样的数据库

1037
00:39:01,540 --> 00:39:04,980
很疯狂 这太棒了 所以

1038
00:39:04,980 --> 00:39:08,140
这就是为什么我就是为什么我喜欢数据库

1039
00:39:08,140 --> 00:39:10,000
因为你知道现在只有你

1040
00:39:10,000 --> 00:39:12,220
才能做一些已经产生影响的研究

1041
00:39:12,220 --> 00:39:14,230
你可以让你知道你现在赚了一些

1042
00:39:14,230 --> 00:39:15,580
不错的钱 可以购买你自己的

1043
00:39:15,580 --> 00:39:18,580
夏威夷岛，这很棒

1044
00:39:18,580 --> 00:39:21,850


1045
00:39:21,850 --> 00:39:23,770
，所以在 1970 年代，关系模型和 Kota 之间一直在争论，

1046
00:39:23,770 --> 00:39:25,690
但最终关系

1047
00:39:25,690 --> 00:39:27,010
模型的一种算法明确指出这是

1048
00:39:27,010 --> 00:39:28,330
构建数据库系统的正确方法，

1049
00:39:28,330 --> 00:39:31,360
因此 Ingress 和 Oracle 已

1050
00:39:31,360 --> 00:39:34,270
商业化，但是 IBM 实际上从未

1051
00:39:34,270 --> 00:39:36,370
发布过的系统就像一个

1052
00:39:36,370 --> 00:39:38,680
商业产品 他们最终

1053
00:39:38,680 --> 00:39:41,830
发布了他们在他们的第一个关系

1054
00:39:41,830 --> 00:39:43,270
戴维森他们发布的东西

1055
00:39:43,270 --> 00:39:44,620
叫做 db2 它今天仍然存在

1056
00:39:44,620 --> 00:39:47,770
并且它于 1983 年问世 所以有

1057
00:39:47,770 --> 00:39:49,300
一些零碎的系统 是

1058
00:39:49,300 --> 00:39:52,050
它成为 db2 的第一个实现，

1059
00:39:52,050 --> 00:39:55,240
但我不知道

1060
00:39:55,240 --> 00:39:58,870
今天还有多少代码仍然存在，所以因为

1061
00:39:58,870 --> 00:40:01,320
对于系统，他们正在使用续集

1062
00:40:01,320 --> 00:40:05,170
IBM 在 db2 中使用了续集，因为 IBM

1063
00:40:05,170 --> 00:40:06,610
当时有点像计算机巨头，

1064
00:40:06,610 --> 00:40:08,290
这基本上成为了

1065
00:40:08,290 --> 00:40:10,450
标准，他们不得不更改名称，

1066
00:40:10,450 --> 00:40:12,520
尽管如此拼写的 seq 你

1067
00:40:12,520 --> 00:40:14,740
大喊它只是被缩短成为

1068
00:40:14,740 --> 00:40:16,450
续集，我认为那是因为

1069
00:40:16,450 --> 00:40:18,130
有 有人因为

1070
00:40:18,130 --> 00:40:22,450
命名问题起诉他们，所以续集成为用于数据库的

1071
00:40:22,450 --> 00:40:24,850
占主导地位的编程语言

1072
00:40:24,850 --> 00:40:26,890
ingress

1073
00:40:26,890 --> 00:40:28,210
在他们

1074
00:40:28,210 --> 00:40:29,350
最终有体育续集的时候支持 Quell 把

1075
00:40:29,350 --> 00:40:30,730
Oracle 从一开始就支持续集，

1076
00:40:30,730 --> 00:40:32,140
因为他们复制了 IBM 的

1077
00:40:32,140 --> 00:40:34,780
做法，你知道什么时候

1078
00:40:34,780 --> 00:40:35,830
如果我们有续集数据库，我并没有让我置身事外

1079
00:40:35,830 --> 00:40:37,360
Oracle 就像哦，看，我们也已经

1080
00:40:37,360 --> 00:40:39,100
有了，然后他们基本上赢得

1081
00:40:39,100 --> 00:40:42,640
了市场，所以

1082
00:40:42,640 --> 00:40:45,010
1980 年发生的另一件事是除了

1083
00:40:45,010 --> 00:40:45,940
IBM 安装了第一个数据库

1084
00:40:45,940 --> 00:40:47,710
之外 实际上，当时出现的许多其他初创公司

1085
00:40:47,710 --> 00:40:50,140
也

1086
00:40:50,140 --> 00:40:51,970
为企业

1087
00:40:51,970 --> 00:40:54,490
市场或商业市场构建了关系数据库

1088
00:40:54,490 --> 00:40:57,099
Infor 混合 Sybase 串联不间断续集

1089
00:40:57,099 --> 00:41:00,220
Teradata 是 70 年代后期的

1090
00:41:00,220 --> 00:41:01,720
另一个著名的

1091
00:41:01,720 --> 00:41:02,920
数据库系统，但所有这些数据库系统今天仍然存在，

1092
00:41:02,920 --> 00:41:05,849
而不是它们在 1980 年代存在的确切形式，

1093
00:41:05,849 --> 00:41:08,980
但这些

1094
00:41:08,980 --> 00:41:10,569
仍然是价值 10 亿美元的

1095
00:41:10,569 --> 00:41:12,339
产品

1096
00:41:12,339 --> 00:41:13,410
为这些公司赚

1097
00:41:13,410 --> 00:41:16,540
了很多钱 另一件很酷的事情是 Stonebraker

1098
00:41:16,540 --> 00:41:19,630
在经营 ingress 公司一段

1099
00:41:19,630 --> 00:41:21,849
时间后回到伯克利，他

1100
00:41:21,849 --> 00:41:24,010
开始了一个新的数据库系统，建立

1101
00:41:24,010 --> 00:41:25,630
在你知道他

1102
00:41:25,630 --> 00:41:28,450
从经营 ingress 和 他把

1103
00:41:28,450 --> 00:41:29,770
它放到一个叫做 Postgres 的新系统中

1104
00:41:29,770 --> 00:41:33,220
，这实际上我不知道如何

1105
00:41:33,220 --> 00:41:34,839
并且显然没有多少相同的代码

1106
00:41:34,839 --> 00:41:36,760
仍然存在，但这是

1107
00:41:36,760 --> 00:41:38,680
今天使用的同一个人，它是直接

1108
00:41:38,680 --> 00:41:40,540
指向这个完全相同的 Postgres 代码

1109
00:41:40,540 --> 00:41:45,520
或者menina源自

1110
00:41:45,520 --> 00:41:47,859
迈克在1980年代与他的学生在伯克利开发的明信片代码，

1111
00:41:47,859 --> 00:41:52,900
所以现在我们进入

1112
00:41:52,900 --> 00:41:56,260
了1980年代后期，现在我们开始看到

1113
00:41:56,260 --> 00:41:59,380
人们重复这个想法 或者

1114
00:41:59,380 --> 00:42:01,630
不是同样的错误，而是试图让你

1115
00:42:01,630 --> 00:42:03,430
知道与

1116
00:42:03,430 --> 00:42:06,730
他们在 1970 年代的人们进行同样的战斗，所以

1117
00:42:06,730 --> 00:42:08,410
在 1980 年代对象或新的编程

1118
00:42:08,410 --> 00:42:11,819
语言变得更加普遍，

1119
00:42:11,819 --> 00:42:15,700
如果我正在编写我的所有应用程序，人们就会很好地认识到这一点

1120
00:42:15,700 --> 00:42:17,200


1121
00:42:17,200 --> 00:42:18,190
在对象或编程语言（

1122
00:42:18,190 --> 00:42:22,089
如闲聊或 C++）中编写代码，但现在我习惯于

1123
00:42:22,089 --> 00:42:23,680
将事物存储在我的数据库模式中，我的

1124
00:42:23,680 --> 00:42:25,390
数据库将事物存储为关系，

1125
00:42:25,390 --> 00:42:27,460
因此我必须使用可能

1126
00:42:27,460 --> 00:42:30,460
包含嵌套数组和其他对象的对象

1127
00:42:30,460 --> 00:42:32,170
我 必须将它们分解

1128
00:42:32,170 --> 00:42:33,520
，然后将它们放入关系或

1129
00:42:33,520 --> 00:42:34,930
单个记录或元组中，然后将它们放入

1130
00:42:34,930 --> 00:42:38,520
我的数据库中，因此人们

1131
00:42:38,520 --> 00:42:40,599
认识到这是一个潜在的

1132
00:42:40,599 --> 00:42:42,819
瓶颈，这称为关系

1133
00:42:42,819 --> 00:42:46,960
对象阻抗不匹配，因此很多

1134
00:42:46,960 --> 00:42:48,819
人说 与其

1135
00:42:48,819 --> 00:42:51,040
用我的探索语言获取我的对象，

1136
00:42:51,040 --> 00:42:52,359
然后将它们

1137
00:42:52,359 --> 00:42:54,040
从我们的关系数据库中分成两个极点，

1138
00:42:54,040 --> 00:42:55,240
如果我可以拥有一个数据库系统会怎样

1139
00:42:55,240 --> 00:42:57,819
可以直接存储对象，这样我

1140
00:42:57,819 --> 00:42:59,960
就不必进行翻译了

1141
00:42:59,960 --> 00:43:02,720
，你知道 Eli 或 DC

1142
00:43:02,720 --> 00:43:03,710


1143
00:43:03,710 --> 00:43:06,080
Eliza 是否会在我需要访问它们时将它们分解并重新组合在一起，所以这

1144
00:43:06,080 --> 00:43:08,660
对数据库公司提出

1145
00:43:08,660 --> 00:43:10,040
了所谓的 对象或任何

1146
00:43:10,040 --> 00:43:12,920
数据库强制对象存储

1147
00:43:12,920 --> 00:43:15,020
可能有两个最著名的它们

1148
00:43:15,020 --> 00:43:16,640
今天仍然存在，但它们基本上处于

1149
00:43:16,640 --> 00:43:19,780
维护模式这种

1150
00:43:19,780 --> 00:43:21,740
类别数据库从未起飞，

1151
00:43:21,740 --> 00:43:23,840
因为没有一种标准的

1152
00:43:23,840 --> 00:43:25,340
方式与您交互，知道

1153
00:43:25,340 --> 00:43:29,720
对这些系统进行编程，只有你知道，

1154
00:43:29,720 --> 00:43:31,520
因为你必须使用一种专有的

1155
00:43:31,520 --> 00:43:33,200
编程语言，这使你

1156
00:43:33,200 --> 00:43:35,180
知道与

1157
00:43:35,180 --> 00:43:37,550
续集可能存在的数据库紧密耦合你

1158
00:43:37,550 --> 00:43:39,680
知道一个任何人都可以实现的开放标准

1159
00:43:39,680 --> 00:43:42,320
你知道这些是

1160
00:43:42,320 --> 00:43:46,720
其他数据库的程序 专有的

1161
00:43:46,720 --> 00:43:48,890
市场逻辑是一个

1162
00:43:48,890 --> 00:43:51,230
1990 年代后期出现的 XML 数据库，但

1163
00:43:51,230 --> 00:43:52,550
它与这些东西类似，有

1164
00:43:52,550 --> 00:43:55,340
一种 XML 数据库 因此，尽管

1165
00:43:55,340 --> 00:43:57,740
这些系统今天并不真正存在

1166
00:43:57,740 --> 00:43:59,450
，人们也没有广泛使用他们开发的

1167
00:43:59,450 --> 00:44:01,040
许多技术

1168
00:44:01,040 --> 00:44:03,440
来将数据存储在

1169
00:44:03,440 --> 00:44:04,880
这些对象中，但今天确实存在数据库

1170
00:44:04,880 --> 00:44:06,620
以及商业关系

1171
00:44:06,620 --> 00:44:08,330
数据库或开源数据库

1172
00:44:08,330 --> 00:44:11,450
任何时候您将数据存储为 JSON 文件或

1173
00:44:11,450 --> 00:44:13,400
XML 字段，这基本上

1174
00:44:13,400 --> 00:44:14,480
与对象或任何

1175
00:44:14,480 --> 00:44:17,180
davises 人在 1980

1176
00:44:17,180 --> 00:44:18,800


1177
00:44:18,800 --> 00:44:21,860
年代所做的相同

1178
00:44:21,860 --> 00:44:23,510
假设我有一个

1179
00:44:23,510 --> 00:44:25,190
应用程序，我想存储学生

1180
00:44:25,190 --> 00:44:27,260
信息，因此每个学生都有一个 ID、

1181
00:44:27,260 --> 00:44:29,240
姓名和电子邮件地址，然后是一

1182
00:44:29,240 --> 00:44:31,820
组电话号码，因此如果我想将其存储

1183
00:44:31,820 --> 00:44:33,740
在关系数据库中，因为学生

1184
00:44:33,740 --> 00:44:35,030
可能有多个我需要的电话号码

1185
00:44:35,030 --> 00:44:36,590


1186
00:44:36,590 --> 00:44:38,540
在学生电话关系和

1187
00:44:38,540 --> 00:44:40,880
学生表之间建立外键关系，所以现在当我想

1188
00:44:40,880 --> 00:44:43,070
进行查找以

1189
00:44:43,070 --> 00:44:44,900
获取给定学生所需的所有信息时，我要么哈

1190
00:44:44,900 --> 00:44:46,790
必须对这两个关系进行两次查询

1191
00:44:46,790 --> 00:44:49,100
或在它们之间进行连接以获得

1192
00:44:49,100 --> 00:44:50,840


1193
00:44:50,840 --> 00:44:52,430


1194
00:44:52,430 --> 00:44:55,490


1195
00:44:55,490 --> 00:44:57,440


1196
00:44:57,440 --> 00:44:59,420
我需要的数据 而不是将其存储为

1197
00:44:59,420 --> 00:45:00,380
两个

1198
00:45:00,380 --> 00:45:02,420
模拟，如果我

1199
00:45:02,420 --> 00:45:05,120
将单个学生的所有信息存储在

1200
00:45:05,120 --> 00:45:07,490
一个 JSON 字段中，并且在其中我可以

1201
00:45:07,490 --> 00:45:09,290
拥有我的嵌套数组，那么现在

1202
00:45:09,290 --> 00:45:11,090
获取所有信息以在我的实例中实例化

1203
00:45:11,090 --> 00:45:13,790
该对象 应用程序代码

1204
00:45:13,790 --> 00:45:16,730
作为一次提取到数据库中，所以这

1205
00:45:16,730 --> 00:45:17,420
看起来不错，

1206
00:45:17,420 --> 00:45:19,400
但现在这会导致

1207
00:45:19,400 --> 00:45:21,590
问题，因为对于一个简单的例子，

1208
00:45:21,590 --> 00:45:23,270
比如 go get one student 这很容易

1209
00:45:23,270 --> 00:45:24,470
做，但是现在如果我想开始

1210
00:45:24,470 --> 00:45:26,570
跨多个学生进行聚合

1211
00:45:26,570 --> 00:45:28,130
并开始调整事情 在一起

1212
00:45:28,130 --> 00:45:30,200
不仅必须遍历查询

1213
00:45:30,200 --> 00:45:33,980
中每条记录的层次结构，

1214
00:45:33,980 --> 00:45:35,810
而且现在我需要确保我可以

1215
00:45:35,810 --> 00:45:38,090
连接这些多条记录，

1216
00:45:38,090 --> 00:45:39,620
以便完成复杂事情的查询结束

1217
00:45:39,620 --> 00:45:42,470
比您

1218
00:45:42,470 --> 00:45:45,350
使用续集编写的内容更困难 另一个

1219
00:45:45,350 --> 00:45:46,910
问题是，正如我之前所说，

1220
00:45:46,910 --> 00:45:49,670
即使在今天，JSON

1221
00:45:49,670 --> 00:45:51,080
数据库也没有标准 API

1222
00:45:51,080 --> 00:45:52,580
，人们用来

1223
00:45:52,580 --> 00:45:53,600
与数据库 MongoDB 或 Redis 上的这些对象进行交互没有标准的编程语言

1224
00:45:53,600 --> 00:45:55,990


1225
00:45:55,990 --> 00:45:58,490
有点成为事实上的标准，

1226
00:45:58,490 --> 00:46:00,530
但有足够多的

1227
00:46:00,530 --> 00:46:02,420
文档数据库或对象

1228
00:46:02,420 --> 00:46:03,740
数据库可以做一些完全

1229
00:46:03,740 --> 00:46:06,110
不同的事情，而续集的

1230
00:46:06,110 --> 00:46:07,400
方言略有不同，但

1231
00:46:07,400 --> 00:46:09,230
它们仍然相似与否，你

1232
00:46:09,230 --> 00:46:12,700
知道你可以理解它 很容易，

1233
00:46:12,700 --> 00:46:15,190
所以现在我们到了 1990 年代，我

1234
00:46:15,190 --> 00:46:17,660
通常称其为无聊的

1235
00:46:17,660 --> 00:46:19,760
数据库时代，并不是说

1236
00:46:19,760 --> 00:46:20,840
人们没有推出新的数据库

1237
00:46:20,840 --> 00:46:23,060
系统，只是没有任何

1238
00:46:23,060 --> 00:46:26,210
重大进步 重大变化以及如何

1239
00:46:26,210 --> 00:46:27,290
人们将设计数据库

1240
00:46:27,290 --> 00:46:28,460
系统来帮助人们

1241
00:46:28,460 --> 00:46:30,560
使用人们在互联网上受到限制的应用

1242
00:46:30,560 --> 00:46:32,450
程序 s 来了，

1243
00:46:32,450 --> 00:46:34,220
但你知道在早期，

1244
00:46:34,220 --> 00:46:35,720
互联网上的人并不多

1245
00:46:35,720 --> 00:46:37,970


1246
00:46:37,970 --> 00:46:40,130
，人们通过网络构建和公开的应用程序很复杂，

1247
00:46:40,130 --> 00:46:41,870
或者

1248
00:46:41,870 --> 00:46:44,570
不像现在那么复杂，所以现有的数据库

1249
00:46:44,570 --> 00:46:47,540
就足够了 在此期间

1250
00:46:47,540 --> 00:46:48,740
，我想说的四大事件

1251
00:46:48,740 --> 00:46:50,870
是，微软

1252
00:46:50,870 --> 00:46:52,520
购买了 Sybase 源代码的许可证，

1253
00:46:52,520 --> 00:46:54,470
他们将其分叉并将其移植到

1254
00:46:54,470 --> 00:46:56,980
Windows NT 并成为续集服务器

1255
00:46:56,980 --> 00:46:58,910
秘密服务器今天仍然是

1256
00:46:58,910 --> 00:47:01,340
最先进的 -art 数据库系统，你

1257
00:47:01,340 --> 00:47:02,480
知道我知道多少我不认为

1258
00:47:02,480 --> 00:47:03,590
这个代码仍然存在的网站的那么多，

1259
00:47:03,590 --> 00:47:05,240
但那是他们的起点，

1260
00:47:05,240 --> 00:47:07,430
而 Sybase 现在处于维护

1261
00:47:07,430 --> 00:47:09,080
模式，现在仍然可以赚很多

1262
00:47:09,080 --> 00:47:10,820
钱 我认为是

1263
00:47:10,820 --> 00:47:12,290
最先进系统

1264
00:47:12,290 --> 00:47:14,870
的单个服务器 下一个主要趋势是续集

1265
00:47:14,870 --> 00:47:16,880
服务器，所以我的续集

1266
00:47:16,880 --> 00:47:18,860
是在 1990 年代出现的，作为 M 续集的替代品

1267
00:47:18,860 --> 00:47:21,760
，这就是他们今天使用 Postgres 的原因

1268
00:47:21,760 --> 00:47:25,740
增加了对续集的支持

1269
00:47:25,740 --> 00:47:29,700
，这是基于 1980 年代

1270
00:47:29,700 --> 00:47:31,410
在伯克利开发的学术代码，

1271
00:47:31,410 --> 00:47:34,170
我们大多数人实际上得到了

1272
00:47:34,170 --> 00:47:36,180
分叉，然后有一个

1273
00:47:36,180 --> 00:47:37,940
名为 lustrum 的商业版本

1274
00:47:37,940 --> 00:47:40,859
，我认为支持的续集

1275
00:47:40,859 --> 00:47:42,869
最终被 Informix 购买并排序

1276
00:47:42,869 --> 00:47:45,240


1277
00:47:45,240 --> 00:47:46,980
1990 年代伯克利分校的两名研究生采用

1278
00:47:46,980 --> 00:47:48,930
了仅

1279
00:47:48,930 --> 00:47:50,220
支持 quell 和 add 作为卟啉

1280
00:47:50,220 --> 00:47:52,049
续集的 Postgres 学术版本，这就是

1281
00:47:52,049 --> 00:47:54,930
post-arrest 的正式名称是 PostgreSQL 的原因，因为您

1282
00:47:54,930 --> 00:47:57,000
知道它是在

1283
00:47:57,000 --> 00:47:59,099
最初的 Postgres 代码是写出来的，

1284
00:47:59,099 --> 00:48:00,210
然后 sequel light 是由北卡罗来纳州的一个家伙开始的

1285
00:48:00,210 --> 00:48:02,549
，它是使用

1286
00:48:02,549 --> 00:48:03,660
最广泛的

1287
00:48:03,660 --> 00:48:05,579
noxee 这就是为什么他们使用嵌入式

1288
00:48:05,579 --> 00:48:07,740
数据库并且广泛使用的是数据

1289
00:48:07,740 --> 00:48:12,000
，因为它无处不在，

1290
00:48:12,000 --> 00:48:13,589
所以现在对 发生

1291
00:48:13,589 --> 00:48:17,880
在 2000 年代就像互联网一样，所以

1292
00:48:17,880 --> 00:48:20,010
在线用户的数量

1293
00:48:20,010 --> 00:48:22,410
显着增长，数据库的大小

1294
00:48:22,410 --> 00:48:24,690
和并发操作的数量

1295
00:48:24,690 --> 00:48:26,130
这些系统需要

1296
00:48:26,130 --> 00:48:29,400
支持的口粮比你

1297
00:48:29,400 --> 00:48:31,200
知道的以前存在的要大得多，

1298
00:48:31,200 --> 00:48:33,990
所以问题是所有

1299
00:48:33,990 --> 00:48:35,849
主要的企业数据库

1300
00:48:35,849 --> 00:48:38,270
系统、Oracles、SCI 基础、db2

1301
00:48:38,270 --> 00:48:42,450
这些都是非常重量级的，而且它们

1302
00:48:42,450 --> 00:48:45,599
很昂贵，而且

1303
00:48:45,599 --> 00:48:47,579
当时像我的续集 Postgres 这样的开源系统

1304
00:48:47,579 --> 00:48:49,920
有点缺少

1305
00:48:49,920 --> 00:48:52,079
你想要的重要功能和

1306
00:48:52,079 --> 00:48:53,760
你不能在生产中安全使用它们的数据库

1307
00:48:53,760 --> 00:48:55,470
你知道所以

1308
00:48:55,470 --> 00:48:57,270
例如我的续集没有

1309
00:48:57,270 --> 00:48:59,789
正确支持事务，直到你知道

1310
00:48:59,789 --> 00:49:01,880
输入 DB 出现在 2000 年代初，

1311
00:49:01,880 --> 00:49:04,140
所以任何发生的事情都是为了

1312
00:49:04,140 --> 00:49:05,900
支持这些更大的医生工作

1313
00:49:05,900 --> 00:49:09,140
负载，像 Facebook、谷歌

1314
00:49:09,140 --> 00:49:13,319
、eBay 和亚马逊这样的公司，他们最终编写

1315
00:49:13,319 --> 00:49:15,420
了自己的自定义中间件，这些中间件将

1316
00:49:15,420 --> 00:49:16,890
位于多个单节点

1317
00:49:16,890 --> 00:49:18,990
数据库实例之前 大声他们以

1318
00:49:18,990 --> 00:49:22,980
分割规模，这样他们就可以

1319
00:49:22,980 --> 00:49:24,690
支持更多的并发

1320
00:49:24,690 --> 00:49:27,390
用户并更快地摄取数据，但是

1321
00:49:27,390 --> 00:49:29,039
现在如果你有更多的数据，任何人都会对其

1322
00:49:29,039 --> 00:49:30,930
进行分析，你需要一个

1323
00:49:30,930 --> 00:49:32,309
专门的数据库系统来实际

1324
00:49:32,309 --> 00:49:34,799
支持这些类型的工作负载，所以这

1325
00:49:34,799 --> 00:49:37,740
是数据仓库的兴起，所以这些

1326
00:49:37,740 --> 00:49:39,599
是

1327
00:49:39,599 --> 00:49:41,789
在 2000 年代中期构建的专用数据系统

1328
00:49:41,789 --> 00:49:43,289
那些专为这些大型过敏

1329
00:49:43,289 --> 00:49:47,099
数据集设计的，并不是说

1330
00:49:47,099 --> 00:49:49,140
当时现有的大卫无法进行

1331
00:49:49,140 --> 00:49:51,210
分析，他们是你知道的，他们是

1332
00:49:51,210 --> 00:49:52,319
万事通，并不是

1333
00:49:52,319 --> 00:49:55,020
专门为他设计的，而

1334
00:49:55,020 --> 00:49:57,029
这些较新的 系统的设计只是

1335
00:49:57,029 --> 00:50:02,190
为了有效地进行分析，所以

1336
00:50:02,190 --> 00:50:03,720
当时在这些 mateesah 公园 L Vertica 和 Green Pond

1337
00:50:03,720 --> 00:50:06,299
的预告片 Park Salomone DB Green Pond 8

1338
00:50:06,299 --> 00:50:09,660
Allegro Vertica 中的六个最著名的

1339
00:50:09,660 --> 00:50:11,730
都是 Forks

1340
00:50:11,730 --> 00:50:12,750
和 Postgres，就像他们采用了

1341
00:50:12,750 --> 00:50:14,490
Foursquare 源一样 代码对其进行了修改以

1342
00:50:14,490 --> 00:50:15,839
使运动分析 Morton 更

1343
00:50:15,839 --> 00:50:18,930
有效 我认为

1344
00:50:18,930 --> 00:50:19,829
这些系统与现有系统的不同

1345
00:50:19,829 --> 00:50:22,170
之处在于它们

1346
00:50:22,170 --> 00:50:24,359
主要是分布式的 什么都不共享，

1347
00:50:24,359 --> 00:50:25,349
因为那是您希望能够

1348
00:50:25,349 --> 00:50:27,890
扩展以进行大规模分析

1349
00:50:27,890 --> 00:50:29,760
，不幸的是，它们中的大多数

1350
00:50:29,760 --> 00:50:33,420
也是闭源的，因此

1351
00:50:33,420 --> 00:50:34,470
使它们与以前不同的关键在于它们

1352
00:50:34,470 --> 00:50:36,720


1353
00:50:36,720 --> 00:50:39,180
都是列存储数据库

1354
00:50:39,180 --> 00:50:40,589
好吧，自 1970 年代以来就存在的逗号存储，

1355
00:50:40,589 --> 00:50:42,599
但直到这个

1356
00:50:42,599 --> 00:50:44,520
时候，人们才认识到这些特殊用途的数据

1357
00:50:44,520 --> 00:50:45,809
仓库，

1358
00:50:45,809 --> 00:50:47,069


1359
00:50:47,069 --> 00:50:49,319
你知道的殖民地，列存储的分解模型

1360
00:50:49,319 --> 00:50:52,380


1361
00:50:52,380 --> 00:50:55,789
在进行高性能分析方面是优越的，

1362
00:50:56,110 --> 00:50:59,350
所以 现在我们进入了 2000 年代后期

1363
00:50:59,350 --> 00:51:04,580
和没有续集的运动，所以这一切

1364
00:51:04,580 --> 00:51:06,260
是如何开始的，我的看法

1365
00:51:06,260 --> 00:51:10,270
是，像谷歌这样的公司

1366
00:51:10,270 --> 00:51:12,110
认识到，对于

1367
00:51:12,110 --> 00:51:13,850
他们想要在网络上支持的应用程序，

1368
00:51:13,850 --> 00:51:17,540
他们更关心

1369
00:51:17,540 --> 00:51:18,800
确保数据系统始终

1370
00:51:18,800 --> 00:51:22,670
可用，并且它们可以扩展

1371
00:51:22,670 --> 00:51:24,830
以移植大量用户，因此他们

1372
00:51:24,830 --> 00:51:26,720
最终放弃了诸如此类的传统事物

1373
00:51:26,720 --> 00:51:28,670
戴维斯提供诸如交易和

1374
00:51:28,670 --> 00:51:32,240
关节以及seco支持以换取

1375
00:51:32,240 --> 00:51:34,790
此类其他数据模型或

1376
00:51:34,790 --> 00:51:36,530
专有语言编程

1377
00:51:36,530 --> 00:51:40,880
语言访问api，因此有

1378
00:51:40,880 --> 00:51:43,040
一堆这些系统是

1379
00:51:43,040 --> 00:51:45,380
基于亚马逊所做的或

1380
00:51:45,380 --> 00:51:47,750
谷歌所做的克隆的 但其他

1381
00:51:47,750 --> 00:51:50,330
人总是从某人

1382
00:51:50,330 --> 00:51:51,380
将数据系统放入公司并

1383
00:51:51,380 --> 00:51:53,120
认识到你知道它解决了一个

1384
00:51:53,120 --> 00:51:54,290
特定的问题对其

1385
00:51:54,290 --> 00:51:56,750
他人有用所以很明显最著名

1386
00:51:56,750 --> 00:51:59,380
的可能是 MongoDB Cassandra 和

1387
00:51:59,380 --> 00:52:02,950
dynamodb 大部分这些都是开放的 来源

1388
00:52:02,950 --> 00:52:07,870
除了 Dino DB Oracle 没有续集

1389
00:52:07,870 --> 00:52:12,410
和 BigTable 但同样重要的是

1390
00:52:12,410 --> 00:52:14,450
，他们被称为没有续集，因为

1391
00:52:14,450 --> 00:52:15,740
他们当时不支持续集，

1392
00:52:15,740 --> 00:52:17,480
尽管今天很多犹太人现在这样做

1393
00:52:17,480 --> 00:52:20,780
，因为他们更关注高

1394
00:52:20,780 --> 00:52:24,100
可用性 比和正确性，

1395
00:52:24,100 --> 00:52:27,290
以便响应没有续集的

1396
00:52:27,290 --> 00:52:29,300
运动，还有一个其他的 -

1397
00:52:29,300 --> 00:52:30,830
数据库也许我参与了

1398
00:52:30,830 --> 00:52:33,380
称为新续集，这是

1399
00:52:33,380 --> 00:52:35,090
我们尝试为

1400
00:52:35,090 --> 00:52:37,880
事务性工作负载构建数据库的地方，这些数据库可以

1401
00:52:37,880 --> 00:52:40,040
具有与无续集系统相同的可扩展性性能，

1402
00:52:40,040 --> 00:52:42,380
但不必

1403
00:52:42,380 --> 00:52:43,970
放弃事务而不

1404
00:52:43,970 --> 00:52:45,590
放弃关系模型或续集，因为

1405
00:52:45,590 --> 00:52:47,000
这些都是有用的东西 有

1406
00:52:47,000 --> 00:52:51,830
数据库和数据库所以不幸

1407
00:52:51,830 --> 00:52:53,960
的是，至少在新的

1408
00:52:53,960 --> 00:52:55,310
续集系统最初开始时，其中

1409
00:52:55,310 --> 00:52:57,590
大部分都是封闭源临床的

1410
00:52:57,590 --> 00:52:59,390
东西，现在是近年来像

1411
00:52:59,390 --> 00:53:02,000
铜 cbt-i DB 和你gabite

1412
00:53:02,000 --> 00:53:04,040
一些较新的更新 新的单一

1413
00:53:04,040 --> 00:53:05,300
系统实际上是开源的，

1414
00:53:05,300 --> 00:53:07,100
因此非常令人兴奋的扳手

1415
00:53:07,100 --> 00:53:08,980
可能

1416
00:53:08,980 --> 00:53:11,349
是所有这些中最有名的扳手，它们

1417
00:53:11,349 --> 00:53:12,760
使用特殊的适当

1418
00:53:12,760 --> 00:53:13,780
时钟进行交易，我们不会在

1419
00:53:13,780 --> 00:53:18,400
本学期指定，所以现在 2010

1420
00:53:18,400 --> 00:53:23,710
和 2014 所以这些是现在而

1421
00:53:23,710 --> 00:53:26,500
不是这个建筑到一个单一的目的

1422
00:53:26,500 --> 00:53:27,520
每天坐着可以尝试做

1423
00:53:27,520 --> 00:53:30,369
你试图建造这些你知道的

1424
00:53:30,369 --> 00:53:31,780
一切 w 一项新交易或

1425
00:53:31,780 --> 00:53:33,309
一项可以有效进行分析但不能有效进行分析的交易，

1426
00:53:33,309 --> 00:53:35,680
但在后来的

1427
00:53:35,680 --> 00:53:39,400
mm mm mm 十是这些 H 选项卡系统或

1428
00:53:39,400 --> 00:53:41,680
混合系统，它试图

1429
00:53:41,680 --> 00:53:43,720
获得两全其美的效果

1430
00:53:43,720 --> 00:53:45,220
， 它试图成为一个新的单一

1431
00:53:45,220 --> 00:53:46,359
学生系统，在那里他可以

1432
00:53:46,359 --> 00:53:48,730
非常快速地进行交易，但您还

1433
00:53:48,730 --> 00:53:50,410
希望支持一些分析

1434
00:53:50,410 --> 00:53:52,510
，您只能

1435
00:53:52,510 --> 00:53:55,119
在数据仓库上运行，而这里的想法

1436
00:53:55,119 --> 00:53:57,339
是，而不是它 可以

1437
00:53:57,339 --> 00:53:59,380
维护两个服务器数据库，一个用于

1438
00:53:59,380 --> 00:54:01,089
事务，用于分析，您可以

1439
00:54:01,089 --> 00:54:02,619
将其中一些分析操作

1440
00:54:02,619 --> 00:54:05,950
直接推送到前端系统，并且您

1441
00:54:05,950 --> 00:54:07,329
知道在数据到达数据库系统时推断新知识中的

1442
00:54:07,329 --> 00:54:09,309
所有新信息，

1443
00:54:09,309 --> 00:54:12,220
因此

1444
00:54:12,220 --> 00:54:14,530
这些 HANA 拼接 machine 和 MC co-op

1445
00:54:14,530 --> 00:54:16,359
可能是最著名的两个

1446
00:54:16,359 --> 00:54:18,069
hyper 最初是作为一个学术系统开始的，

1447
00:54:18,069 --> 00:54:21,520
但几年前它被 tableau 收购

1448
00:54:21,520 --> 00:54:23,380
，现在是一个商业

1449
00:54:23,380 --> 00:54:24,849
系统 ith tableau software

1450
00:54:24,849 --> 00:54:27,849
hyper 实际上是一个了不起的系统 我们

1451
00:54:27,849 --> 00:54:29,559
实际上将

1452
00:54:29,559 --> 00:54:31,410
在整个学期和

1453
00:54:31,410 --> 00:54:34,180
下节课或本周晚些时候讨论它 我

1454
00:54:34,180 --> 00:54:36,130
实际上要去超级

1455
00:54:36,130 --> 00:54:38,530
总部试图让你知道

1456
00:54:38,530 --> 00:54:40,030
像德国人一样经历 降神会或

1457
00:54:40,030 --> 00:54:42,460
在我的生活中获得一些德国的影响来帮助我

1458
00:54:42,460 --> 00:54:45,069
建立一个更好的数据库系统 所以

1459
00:54:45,069 --> 00:54:47,770
期待在下一堂课中 所以

1460
00:54:47,770 --> 00:54:49,299
其中一些是开源的 一些

1461
00:54:49,299 --> 00:54:51,280
又是闭源 但所有

1462
00:54:51,280 --> 00:54:52,119
这些都将支持

1463
00:54:52,119 --> 00:54:53,559
关系模型 和续集是人们

1464
00:54:53,559 --> 00:54:55,930


1465
00:54:55,930 --> 00:54:58,190
特别想要分析

1466
00:54:58,190 --> 00:55:00,869
的主要事情 2010 年发生的另一件大事

1467
00:55:00,869 --> 00:55:04,200
是云系统的出现，所以这些

1468
00:55:04,200 --> 00:55:05,339
现在是

1469
00:55:05,339 --> 00:55:07,320
专门为在

1470
00:55:07,320 --> 00:55:10,260
云环境中运行而设计的数据库系统，所以这些首先如何

1471
00:55:10,260 --> 00:55:11,580
开始就像主要的云

1472
00:55:11,580 --> 00:55:14,070
供应商会向您出售数据库即

1473
00:55:14,070 --> 00:55:16,170
服务，而这些数据库只是采用

1474
00:55:16,170 --> 00:55:18,089
现有的数据库系统，例如 Oracle 或

1475
00:55:18,089 --> 00:55:20,220
我的续集或 Postgres 和 r

1476
00:55:20,220 --> 00:55:23,369
为您解开容器或 VM 内的带，但

1477
00:55:23,369 --> 00:55:24,839
从那时起，出现了

1478
00:55:24,839 --> 00:55:26,130
专

1479
00:55:26,130 --> 00:55:28,230
为在云环境或

1480
00:55:28,230 --> 00:55:29,790
共享磁盘组合中运行而设计的新数据库系统，我将

1481
00:55:29,790 --> 00:55:31,760
在下一张幻灯片中展示这些系统，这些都是

1482
00:55:31,760 --> 00:55:33,869
数据 I/O 系统 并且不一定

1483
00:55:33,869 --> 00:55:35,400
管理地面，但它们是

1484
00:55:35,400 --> 00:55:37,230
系统的假设，它在

1485
00:55:37,230 --> 00:55:39,780
云环境中运行，因此它

1486
00:55:39,780 --> 00:55:42,300
考虑了访问磁盘的延迟，这些

1487
00:55:42,300 --> 00:55:43,710
磁盘可能不是

1488
00:55:43,710 --> 00:55:45,690
我计算的机器本地的实际

1489
00:55:45,690 --> 00:55:49,680
运行的这些雪花红移

1490
00:55:49,680 --> 00:55:52,580
咆哮着，亚马逊的一切或

1491
00:55:52,580 --> 00:55:55,349
BigTable 和 Kosmos DVR Poly 最著名

1492
00:55:55,349 --> 00:55:58,619
的 ziran 是我续集中的云版本，

1493
00:55:58,619 --> 00:56:00,960
它基于

1494
00:56:00,960 --> 00:56:03,359
以色列，几年前他们失败了 动物

1495
00:56:03,359 --> 00:56:08,520
数据库是一个无服务器 OTP 系统，

1496
00:56:08,520 --> 00:56:10,830
切片是一个 我认为

1497
00:56:10,830 --> 00:56:12,990
我的续集中的云服务来自

1498
00:56:12,990 --> 00:56:15,810
南美，所以还有很多

1499
00:56:15,810 --> 00:56:17,190
其他的，但这些

1500
00:56:17,190 --> 00:56:20,640
是我展示的主要服务之一，作为

1501
00:56:20,640 --> 00:56:23,670
它的一部分 云数据库，你有这些新

1502
00:56:23,670 --> 00:56:25,109
架构，假设一个共享

1503
00:56:25,109 --> 00:56:29,130
磁盘共享磁盘环境，这

1504
00:56:29,130 --> 00:56:30,750
意味着你不必

1505
00:56:30,750 --> 00:56:32,880
在你的数据库系统中编写自定义存储管理器，

1506
00:56:32,880 --> 00:56:35,130
像本地磁盘一样访问，

1507
00:56:35,130 --> 00:56:38,390
你可以使用现有的

1508
00:56:38,390 --> 00:56:40,830
你知道的接口或 API

1509
00:56:40,830 --> 00:56:42,570
云供应商为您提供或

1510
00:56:42,570 --> 00:56:43,980
分布式文件系统将为您提供

1511
00:56:43,980 --> 00:56:46,170
并使用它作为底层数据存储

1512
00:56:46,170 --> 00:56:47,970
我说想这而不是

1513
00:56:47,970 --> 00:56:51,990
写给你知道一个专有的你知道一个

1514
00:56:51,990 --> 00:56:54,210
你知道在磁盘上管理的本地文件

1515
00:56:54,210 --> 00:56:56,339
我会写我的数据 到 HDFS

1516
00:56:56,339 --> 00:57:00,150
或亚马逊说要重新读取 EBS，因此在这些

1517
00:57:00,150 --> 00:57:03,150
环境中，存储层通常是

1518
00:57:03,150 --> 00:57:05,609
仅附加的，因此这些

1519
00:57:05,609 --> 00:57:07,500
将受到青睐，或者您通常会

1520
00:57:07,500 --> 00:57:10,150
使用日志结构化方法，因为

1521
00:57:10,150 --> 00:57:11,620
您只需要继续遵守

1522
00:57:11,620 --> 00:57:14,080
法律，所以 这就是大多数人

1523
00:57:14,080 --> 00:57:15,730
在谈论构建

1524
00:57:15,730 --> 00:57:17,050
数据湖时所想到的通常是这样的

1525
00:57:17,050 --> 00:57:18,040
，他们

1526
00:57:18,040 --> 00:57:19,780
在你下面有一堆文件应该是一个文件系统 或

1527
00:57:19,780 --> 00:57:21,520
分布式对象存储，

1528
00:57:21,520 --> 00:57:22,990
您只需构建它，您将

1529
00:57:22,990 --> 00:57:24,670
数据系统指向它，然后吸收

1530
00:57:24,670 --> 00:57:26,410
数据并租用您

1531
00:57:26,410 --> 00:57:29,290
再次对其进行查询，尽管我们

1532
00:57:29,290 --> 00:57:30,610
不会谈论共享磁盘系统

1533
00:57:30,610 --> 00:57:32,740
或 致敬数据库，你知道你

1534
00:57:32,740 --> 00:57:34,240
必须将共享磁盘中的数据

1535
00:57:34,240 --> 00:57:37,000
带到计算节点，然后

1536
00:57:37,000 --> 00:57:39,070
它在内存中，所以你会做

1537
00:57:39,070 --> 00:57:40,210


1538
00:57:40,210 --> 00:57:42,010
整个学期讨论的所有事情，所以

1539
00:57:42,010 --> 00:57:42,840
即使我们 不谈论

1540
00:57:42,840 --> 00:57:45,730
明确反对数据库

1541
00:57:45,730 --> 00:57:46,870
我们将在这里讨论的技术

1542
00:57:46,870 --> 00:57:49,840
仍然在它们中使用

1543
00:57:49,840 --> 00:57:51,010
关于共享磁盘系统的另一个很酷的事情是，

1544
00:57:51,010 --> 00:57:52,750
因为现在我们将计算

1545
00:57:52,750 --> 00:57:55,630
层与存储层分开，我可以

1546
00:57:55,630 --> 00:57:57,490
独立扩展它们，因为

1547
00:57:57,490 --> 00:57:58,810
执行层本质上是无

1548
00:57:58,810 --> 00:58:01,210
状态的，因为数据库的最终状态

1549
00:58:01,210 --> 00:58:03,700
总是在共享磁盘上，所以如果现在我

1550
00:58:03,700 --> 00:58:05,830
不能足够快地处理查询，那么我

1551
00:58:05,830 --> 00:58:08,230
可以继续在你的计算中添加新的你知道的

1552
00:58:08,230 --> 00:58:09,940
odes 并开始你知道

1553
00:58:09,940 --> 00:58:11,260
并行运行更多查询

1554
00:58:11,260 --> 00:58:13,570
同样如果我需要开始扩展

1555
00:58:13,570 --> 00:58:15,730
更多机器我可以添加

1556
00:58:15,730 --> 00:58:20,170
共享共享磁盘层的新磁盘

1557
00:58:20,170 --> 00:58:22,060
好吧所以我想简单地谈谈

1558
00:58:22,060 --> 00:58:24,520
图形数据库虽然

1559
00:58:24,520 --> 00:58:28,900
这里开始下雨 每年都有人

1560
00:58:28,900 --> 00:58:30,610
问我为什么我不在课堂上介绍工艺数据库

1561
00:58:30,610 --> 00:58:34,000
，答案是我

1562
00:58:34,000 --> 00:58:37,030
没有真正从低级

1563
00:58:37,030 --> 00:58:38,440
系统的角度看到我关心的

1564
00:58:38,440 --> 00:58:41,710
我没有看到一个令人信服的论点来

1565
00:58:41,710 --> 00:58:45,670
解释为什么你 想要使用图形数据库

1566
00:58:45,670 --> 00:58:47,020
，他们对现有系统的唯一真正主要的形象是他们

1567
00:58:47,020 --> 00:58:48,790


1568
00:58:48,790 --> 00:58:50,200
会为你提供一个图形查询

1569
00:58:50,200 --> 00:58:52,330
API，这意味着如果我

1570
00:58:52,330 --> 00:58:54,520
想做一个图形遍历而不是你

1571
00:58:54,520 --> 00:58:55,990
在我走的时候知道 图

1572
00:58:55,990 --> 00:58:58,360
在执行应用程序之前返回，并且

1573
00:58:58,360 --> 00:59:00,130
这个和数据库来回

1574
00:59:00,130 --> 00:59:02,260
执行该遍历我有一个

1575
00:59:02,260 --> 00:59:03,670
执行两次遍历的命令，然后

1576
00:59:03,670 --> 00:59:06,580
它都在服务器端运行，所以

1577
00:59:06,580 --> 00:59:07,870
没有什么具体的

1578
00:59:07,870 --> 00:59:09,310
这使您

1579
00:59:09,310 --> 00:59:10,630
知道在存储图形的关系数据库中无法做到这一点

1580
00:59:10,630 --> 00:59:12,790
，事实上，

1581
00:59:12,790 --> 00:59:15,040
最近的一项研究是几年前的

1582
00:59:15,040 --> 00:59:17,800
2015 年内部人士表明，

1583
00:59:17,800 --> 00:59:19,390
实际上并不清楚使用图形

1584
00:59:19,390 --> 00:59:21,280
中心专用图形中心

1585
00:59:21,280 --> 00:59:22,570
数据库系统 它将

1586
00:59:22,570 --> 00:59:25,120
比现有的

1587
00:59:25,120 --> 00:59:28,450
带有图形 API 的关系数据库系统做得更好

1588
00:59:28,450 --> 00:59:30,160
，因此，我们不会在

1589
00:59:30,160 --> 00:59:33,460
整个学期内使用图形数据库

1590
00:59:33,460 --> 00:59:37,620
另一个主要趋势

1591
00:59:37,620 --> 00:59:42,010
是 2010 年代这十年的出现 这些时间

1592
00:59:42,010 --> 00:59:43,300
序列数据库所以这些是更

1593
00:59:43,300 --> 00:59:44,590
专业的数据库系统，这些

1594
00:59:44,590 --> 00:59:47,020
系统旨在存储时间序列

1595
00:59:47,020 --> 00:59:48,400
事件数据，就像现代

1596
00:59:48,400 --> 00:59:50,470
服务一样，您可以

1597
00:59:50,470 --> 00:59:53,080
每秒收集一次数据中心内每台机器的 CPU 利用率，

1598
00:59:53,080 --> 00:59:55,810
所以

1599
00:59:55,810 --> 00:59:58,390
所有这些事件都被吸收到时间

1600
00:59:58,390 --> 01:00:00,520
序列数据库中，它们可以让您了解

1601
01:00:00,520 --> 01:00:02,500
分析或对它们进行分析以找出

1602
01:00:02,500 --> 01:00:03,960
您是否知道存在任何问题，

1603
01:00:03,960 --> 01:00:05,950
因此 我提出时间

1604
01:00:05,950 --> 01:00:08,560
序列数据库的原因是，这

1605
01:00:08,560 --> 01:00:11,740
实际上是一个很好的例子，说明如果您

1606
01:00:11,740 --> 01:00:14,200
对数据的

1607
01:00:14,200 --> 01:00:15,520
外观和

1608
01:00:15,520 --> 01:00:17,890
您尝试执行的工作集模式做出假设，那么您

1609
01:00:17,890 --> 01:00:19,630
实际上

1610
01:00:19,630 --> 01:00:21,370
可以在 存储层

1611
01:00:21,370 --> 01:00:26,800
和它们的执行层，因此

1612
01:00:26,800 --> 01:00:29,380
您可以对图形数据库提出相同的论点，

1613
01:00:29,380 --> 01:00:32,950
我只是在 X 您

1614
01:00:32,950 --> 01:00:35,200
可能会有或计划级别，但

1615
01:00:35,200 --> 01:00:37,870
在低级别存储级别，

1616
01:00:37,870 --> 01:00:39,670
关系模型仍然可以做到这一点

1617
01:00:39,670 --> 01:00:40,990
所以时间序列数据库他们仍然是

1618
01:00:40,990 --> 01:00:45,730
关系型的，只是他们

1619
01:00:45,730 --> 01:00:46,960
知道模式将是什么样子的查询

1620
01:00:46,960 --> 01:00:48,340
，所以他们可以

1621
01:00:48,340 --> 01:00:50,800
优化这些查询，这可能是

1622
01:00:50,800 --> 01:00:52,690
我们本学期最感兴趣的那些

1623
01:00:52,690 --> 01:00:54,970
是clique house at  a 俄罗斯 我会花

1624
01:00:54,970 --> 01:00:55,870
一点时间谈谈他们是如何

1625
01:00:55,870 --> 01:00:58,240
做事的，因为它实际上是一个超级

1626
01:00:58,240 --> 01:00:59,710
稳定的系统，它完成了

1627
01:00:59,710 --> 01:01:00,520
我们整个学期要讨论的很多事情

1628
01:01:00,520 --> 01:01:02,260
，我 它是

1629
01:01:02,260 --> 01:01:06,520
开源的，非常酷，

1630
01:01:06,520 --> 01:01:10,090
所以我

1631
01:01:10,090 --> 01:01:13,270
想说的是过去十年的主要趋势是这些

1632
01:01:13,270 --> 01:01:15,070
专用系统的兴起不再是

1633
01:01:15,070 --> 01:01:16,870
你知道 Oracle 或续集服务器

1634
01:01:16,870 --> 01:01:18,130
db2 试图为每个人做一切

1635
01:01:18,130 --> 01:01:19,960
有足够的 Daly 系统

1636
01:01:19,960 --> 01:01:22,270
那里可以更好地处理不同

1637
01:01:22,270 --> 01:01:24,460
类别的工作负载，其中

1638
01:01:24,460 --> 01:01:25,600
很多仍然是相关的，

1639
01:01:25,600 --> 01:01:27,250
这只是它们实际放置我的

1640
01:01:27,250 --> 01:01:29,140
东西的方式，并且可以针对

1641
01:01:29,140 --> 01:01:32,200
特定的应用程序环境

1642
01:01:32,200 --> 01:01:34,570
域进行定制，因此有一堆

1643
01:01:34,570 --> 01:01:35,620
有趣的嵌入式数据库

1644
01:01:35,620 --> 01:01:36,160
我们 “不会

1645
01:01:36,160 --> 01:01:38,410
谈论多模式数据库，或者

1646
01:01:38,410 --> 01:01:39,880
主要是模型数据库是系统，

1647
01:01:39,880 --> 01:01:42,640
你知道图形和文档

1648
01:01:42,640 --> 01:01:45,730
以及键值存储都在一个单一的

1649
01:01:45,730 --> 01:01:49,240
数据库中区块链数据库显然又是一件事情

1650
01:01:49,240 --> 01:01:52,180
我不觉得它们很

1651
01:01:52,180 --> 01:01:54,430
有趣或引人注目这些 可能是我

1652
01:01:54,430 --> 01:01:55,569
只是不明白

1653
01:01:55,569 --> 01:01:57,849
说他们是他们的好理由所以

1654
01:01:57,849 --> 01:01:59,140
我们不谈论他们

1655
01:01:59,140 --> 01:02:00,400
也是硬件加速的基础，我们将

1656
01:02:00,400 --> 01:02:01,210
在学期结束时讨论一些

1657
01:02:01,210 --> 01:02:03,549
基础数据库，这些数据库不仅

1658
01:02:03,549 --> 01:02:04,839
在 CPU 上运行，还可以在

1659
01:02:04,839 --> 01:02:09,339
FPGA、GPU 或新的非易失性存储器上运行，

1660
01:02:09,339 --> 01:02:11,440
因此一旦您从

1661
01:02:11,440 --> 01:02:13,059
所有这一切都是因为有大量的

1662
01:02:13,059 --> 01:02:15,250
数据库系统都以

1663
01:02:15,250 --> 01:02:18,640
不同的方式做事，有时他们会

1664
01:02:18,640 --> 01:02:19,900
做出决定，有时

1665
01:02:19,900 --> 01:02:21,760
他们不会做出正确的决定，

1666
01:02:21,760 --> 01:02:23,319
因此本学期的目标是

1667
01:02:23,319 --> 01:02:25,690
了解这些交易- 关闭构建数据库系统的所有

1668
01:02:25,690 --> 01:02:27,670
不同设计点，

1669
01:02:27,670 --> 01:02:29,890
以便您知道当

1670
01:02:29,890 --> 01:02:31,089
您在现实世界中外出时

1671
01:02:31,089 --> 01:02:32,349
有人走过来说，嘿，我有这个很棒的

1672
01:02:32,349 --> 01:02:33,700
新数据库，您应该给我

1673
01:02:33,700 --> 01:02:35,289
钱，因为您应该开始使用

1674
01:02:35,289 --> 01:02:37,930
您 现在可以

1675
01:02:37,930 --> 01:02:39,730
对这是否真的是

1676
01:02:39,730 --> 01:02:44,740
一个好主意进行未经教育的评估 所以这

1677
01:02:44,740 --> 01:02:45,579
是我认为将来会发生的事情

1678
01:02:45,579 --> 01:02:49,150
我认为

1679
01:02:49,150 --> 01:02:50,529


1680
01:02:50,529 --> 01:02:53,440
随着时间的推移开始非常专业的专业数据库 获得更多

1681
01:02:53,440 --> 01:02:55,869
用户并看到采用他们将

1682
01:02:55,869 --> 01:02:58,569
扩大范围以及

1683
01:02:58,569 --> 01:03:00,940
标签支持的问题类型，因此时间

1684
01:03:00,940 --> 01:03:02,440
序列数据库可能无法很好地

1685
01:03:02,440 --> 01:03:03,970
处理事务，但最终

1686
01:03:03,970 --> 01:03:05,230
他们可能

1687
01:03:05,230 --> 01:03:07,900
不进行分析 很好，

1688
01:03:07,900 --> 01:03:09,369
文档需要基础，但最终他们会进行

1689
01:03:09,369 --> 01:03:11,740
分析，最终有些

1690
01:03:11,740 --> 01:03:13,210
数据库会停止使用

1691
01:03:13,210 --> 01:03:14,559
并进入维护模式，然后

1692
01:03:14,559 --> 01:03:16,900
消失，但我认为那些让您

1693
01:03:16,900 --> 01:03:18,819
茁壮成长的数据库会开始

1694
01:03:18,819 --> 01:03:22,089
变得更好 时间也是我的

1695
01:03:22,089 --> 01:03:24,700
观点，关系模型和

1696
01:03:24,700 --> 01:03:27,220
声明式编程语言

1697
01:03:27,220 --> 01:03:31,589
对于在组织中进行高质量的工程

1698
01:03:31,589 --> 01:03:34,380
数据工程是一个福音，

1699
01:03:34,380 --> 01:03:36,309
所以如果你有办法的话，而不是拥有一堆

1700
01:03:36,309 --> 01:03:39,250
正在破解数据的 Python 脚本

1701
01:03:39,250 --> 01:03:42,700
以

1702
01:03:42,700 --> 01:03:44,500
编程方式定义数据的

1703
01:03:44,500 --> 01:03:46,860
外观

1704
01:03:46,860 --> 01:03:49,170
并以某种

1705
01:03:49,170 --> 01:03:51,600
结构化的方式操作毒液，然后让您

1706
01:03:51,600 --> 01:03:53,010
更容易知道其他人可以

1707
01:03:53,010 --> 01:03:54,810
重用 你正在做的事情可能不是

1708
01:03:54,810 --> 01:03:57,180
你在引擎方面做的最快的方式

1709
01:03:57,180 --> 01:03:58,500
你知道你实际上在

1710
01:03:58,500 --> 01:04:00,420
编写软件但是对于一个

1711
01:04:00,420 --> 01:04:01,800
有很多人

1712
01:04:01,800 --> 01:04:03,630
接触数据的组织我认为这实际上

1713
01:04:03,630 --> 01:04:06,180
是更好的方法 有点

1714
01:04:06,180 --> 01:04:09,300
只是我的意见，所以下节课

1715
01:04:09,300 --> 01:04:11,520
我们将介绍内存

1716
01:04:11,520 --> 01:04:14,100
数据库 我只是将

1717
01:04:14,100 --> 01:04:15,360
它们与不同的数据库进行对比，并尝试

1718
01:04:15,360 --> 01:04:16,740
了解它们为何不同

1719
01:04:16,740 --> 01:04:19,620
它们如何不同 你知道这会

1720
01:04:19,620 --> 01:04:20,700
是我们整个学期所做的基本假设

1721
01:04:20,700 --> 01:04:23,640
，对于

1722
01:04:23,640 --> 01:04:25,140
周三的课程，您还必须

1723
01:04:25,140 --> 01:04:26,940
与您一起提交您的第一次阅读，因此请

1724
01:04:26,940 --> 01:04:28,200
查看本课程表，看看

1725
01:04:28,200 --> 01:04:29,760
您必须阅读哪些论文，然后

1726
01:04:29,760 --> 01:04:33,320
使用下面的链接提交，可以，例如

1727
01:04:33,320 --> 01:04:36,470
10  :30 晚上这里开始冒烟了

1728
01:04:36,470 --> 01:04:40,560
让我去弄清楚 701 在哪里或什么时候

1729
01:04:40,560 --> 01:04:43,110
忘记我们要住 然后

1730
01:04:43,110 --> 01:04:44,430
希望我可以

1731
01:04:44,430 --> 01:04:46,830
在德国超级

1732
01:04:46,830 --> 01:04:48,660
总部录制下一堂课 好吧伙计们 放轻松 把

1733
01:04:48,660 --> 01:04:51,600
它放在侧面 什么是

1734
01:04:51,600 --> 01:04:57,000
[音乐]

1735
01:04:57,000 --> 01:05:00,000
叫做好的因为我很高兴你

1736
01:05:00,000 --> 01:05:02,700
的脾气暴躁 嗨，你看起来，它是去

1737
01:05:02,700 --> 01:05:05,700
给我拿四十只是为了得到我的老板歌

1738
01:05:05,700 --> 01:05:15,720
因为我只需要一个 多一点踢和

1739
01:05:15,720 --> 01:05:20,810
我的狩猎是说很高兴坐下

