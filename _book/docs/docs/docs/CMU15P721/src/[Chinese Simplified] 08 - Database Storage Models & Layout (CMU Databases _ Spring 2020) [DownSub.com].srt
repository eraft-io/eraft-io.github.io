1
00:00:01,300 --> 00:00:05,129
[音乐]

2
00:00:05,200 --> 00:00:05,930
[掌声]

3
00:00:05,930 --> 00:00:08,630
[音乐]

4
00:00:08,630 --> 00:00:10,020
[掌声]

5
00:00:10,020 --> 00:00:14,000
[音乐]

6
00:00:14,000 --> 00:00:16,289
其他狡猾的公司仍然会来，

7
00:00:16,289 --> 00:00:20,279
所以甲骨文

8
00:00:20,279 --> 00:00:23,880
本周

9
00:00:23,880 --> 00:00:25,260
三将在

10
00:00:25,260 --> 00:00:27,840
校园进行技术演讲

11
00:00:27,840 --> 00:00:30,630
参加比赛的肖邦他是

12
00:00:30,630 --> 00:00:31,859
上学期介绍课的客座讲师，

13
00:00:31,859 --> 00:00:33,899
所以他会来

14
00:00:33,899 --> 00:00:36,059
谈论我怀疑这

15
00:00:36,059 --> 00:00:38,460
与我们上学期得到的谈话非常相似，

16
00:00:38,460 --> 00:00:41,010
但那是在 4:30 在这里他们的新

17
00:00:41,010 --> 00:00:44,969
作业 可能会是披萨

18
00:00:44,969 --> 00:00:46,289
，因为如果是在 4:30

19
00:00:46,289 --> 00:00:47,940
那么通常 12 点钟的披萨是正确的

20
00:00:47,940 --> 00:00:49,579
，除非是在

21
00:00:49,579 --> 00:00:52,680
星期四通常没有食物，

22
00:00:52,680 --> 00:00:54,300
所以在我们开始之前

23
00:00:54,300 --> 00:00:58,230
马特昨晚在广场上发布了

24
00:00:58,230 --> 00:01:01,500
你需要瞄准的演讲或项目

25
00:01:01,500 --> 00:01:03,120
，然后他今天会设置

26
00:01:03,120 --> 00:01:04,438
很大的范围，所以你可以吐槽，

27
00:01:04,438 --> 00:01:05,369
所以会发生的事情是你会

28
00:01:05,369 --> 00:01:08,780
在很大范围内提交你的项目，

29
00:01:08,780 --> 00:01:11,850
更好地证明实际

30
00:01:11,850 --> 00:01:13,350
构建和 那我们就得跑 这些

31
00:01:13,350 --> 00:01:16,580
离线在同一个 ec2 实例上

32
00:01:16,580 --> 00:01:19,890
，它告诉您我们

33
00:01:19,890 --> 00:01:21,930
昨晚在 Piazza 上对 sony 帖子进行了分级，

34
00:01:21,930 --> 00:01:24,960
就像他使用了

35
00:01:24,960 --> 00:01:26,909
我们提供给您的实例类型的实例存储，然后

36
00:01:26,909 --> 00:01:28,200
空间不足是因为我们在其中进行静态

37
00:01:28,200 --> 00:01:29,729
链接 我们的系统，所以当你构建

38
00:01:29,729 --> 00:01:31,560
所有东西时，每个测试用例都

39
00:01:31,560 --> 00:01:34,070
像是一场演出，所以你已经运行了那个空间

40
00:01:34,070 --> 00:01:36,689
，没有构建测试就无法构建基准

41
00:01:36,689 --> 00:01:40,740
测试，但

42
00:01:40,740 --> 00:01:42,299
如果你只是

43
00:01:42,299 --> 00:01:44,159
瞄准构建槽迭代器，那可能是这样 它

44
00:01:44,159 --> 00:01:45,659
实际上可能不会构建所有单元测试，

45
00:01:45,659 --> 00:01:46,860
可能只是在晚上构建一个，所以你

46
00:01:46,860 --> 00:01:48,720
应该还可以，但是没有办法

47
00:01:48,720 --> 00:01:50,610
像你可以越过标志说并

48
00:01:50,610 --> 00:01:52,890
看到 make 关闭构建基准

49
00:01:52,890 --> 00:01:54,600
你也可以关闭构建测试

50
00:01:54,600 --> 00:01:56,189
但是您目前的问题目前已损坏，

51
00:01:56,189 --> 00:01:57,689
因为

52
00:01:57,689 --> 00:01:59,490
他们两个之间存在

53
00:01:59,490 --> 00:02:02,969


54
00:02:02,969 --> 00:02:04,439


55
00:02:04,439 --> 00:02:09,288
某种依赖性 o

56
00:02:09,288 --> 00:02:11,280
过去几周我们一直在

57
00:02:11,280 --> 00:02:13,410
讨论

58
00:02:13,410 --> 00:02:16,770
数据库系统的更多 OLTP 方面，

59
00:02:16,770 --> 00:02:17,910
所以我们讨论了如何做好

60
00:02:17,910 --> 00:02:18,750
事务

61
00:02:18,750 --> 00:02:21,450
以及如何进行索引，

62
00:02:21,450 --> 00:02:23,580
现在我们将进入

63
00:02:23,580 --> 00:02:25,170
数据库系统的底层 现在谈论

64
00:02:25,170 --> 00:02:27,240
存储，然后从

65
00:02:27,240 --> 00:02:28,920
那个学期开始，我们将开始在此基础上构建

66
00:02:28,920 --> 00:02:30,540
新层，因此我们将进行

67
00:02:30,540 --> 00:02:32,970
数据库存储，然后我们将

68
00:02:32,970 --> 00:02:35,840
在查询优化中进行执行等等

69
00:02:35,840 --> 00:02:40,350
等等 我首先从

70
00:02:40,350 --> 00:02:42,300
事务和索引开始，因为

71
00:02:42,300 --> 00:02:44,730


72
00:02:44,730 --> 00:02:46,710
在我们继续讨论

73
00:02:46,710 --> 00:02:47,940
数据库系统的其他方面时，您应该

74
00:02:47,940 --> 00:02:49,380
在 MVC 系统的上下文中考虑这一点

75
00:02:49,380 --> 00:02:51,600
，然后考虑

76
00:02:51,600 --> 00:02:53,850
您是否知道任何技术 或

77
00:02:53,850 --> 00:02:55,380
我们正在讨论的方法

78
00:02:55,380 --> 00:02:57,300
如果你在做 nbcc

79
00:02:57,300 --> 00:02:59,040
并且有些东西很好用

80
00:02:59,040 --> 00:03:00,390
有一个单一版本 有些东西

81
00:03:00,390 --> 00:03:02,760
在多版本时不太好 所以

82
00:03:02,760 --> 00:03:04,860
这就是为什么我 f 一开始就加载

83
00:03:04,860 --> 00:03:06,170
了事务性的东西，

84
00:03:06,170 --> 00:03:08,100
所以这是我

85
00:03:08,100 --> 00:03:10,230
在一个学期开始时展示的图表，说明

86
00:03:10,230 --> 00:03:12,330
内存数据库

87
00:03:12,330 --> 00:03:14,130
实际上是什么样子的，所以说我们现在有了

88
00:03:14,130 --> 00:03:16,230
我们的索引，我们的索引没有'

89
00:03:16,230 --> 00:03:19,710
没关系，我们进行查找以找到给定的

90
00:03:19,710 --> 00:03:21,600
元组，然后这件事会

91
00:03:21,600 --> 00:03:25,410
吐出块 ID 和偏移量，因此

92
00:03:25,410 --> 00:03:27,660
块 ID 可以是指向

93
00:03:27,660 --> 00:03:28,770
块开头的指针，而偏移量

94
00:03:28,770 --> 00:03:31,710
可以在该块内，但是

95
00:03:31,710 --> 00:03:32,700
有点浪费，

96
00:03:32,700 --> 00:03:34,410
这个东西可能只是一个

97
00:03:34,410 --> 00:03:37,860
指向元组本身的直接指针，但现在你

98
00:03:37,860 --> 00:03:39,240
会遇到任何问题，你开始移动

99
00:03:39,240 --> 00:03:41,850
东西，所以在我们的系统中我们

100
00:03:41,850 --> 00:03:43,320
实际做了什么，一个学生提出了这个

101
00:03:43,320 --> 00:03:45,230
并且很漂亮 聪明的是，我们使用了

102
00:03:45,230 --> 00:03:48,390
来自 super plus 11 的一个技巧，称为 line as

103
00:03:48,390 --> 00:03:51,150
基本上这告诉

104
00:03:51,150 --> 00:03:53,580
系统中的编译器将

105
00:03:53,580 --> 00:03:55,290
内存块的起始地址对齐到某个

106
00:03:55,290 --> 00:03:58,320
集合中，因此我们这样做，我们所有的

107
00:03:58,320 --> 00:04:00,270
块都为一兆字节，并且 我们用 la

108
00:04:00,270 --> 00:04:02,610
l 为了强制执行，现在

109
00:04:02,610 --> 00:04:06,990
我们得到的块 ID 偏移量是一个 44 位的指针，指向

110
00:04:06,990 --> 00:04:10,260
某个 1 兆字节的块，然后我们

111
00:04:10,260 --> 00:04:13,650
现在有 20 位可以跳转到某个区域，

112
00:04:13,650 --> 00:04:14,850
而不是有一个额外的间接

113
00:04:14,850 --> 00:04:17,279
层来说明我如何得到我的 块 ID

114
00:04:17,279 --> 00:04:19,470
到块地址正确我们可以将

115
00:04:19,470 --> 00:04:21,570
所有这些打包成一个东西我提出这个的唯一原因

116
00:04:21,570 --> 00:04:22,500
它在 OL

117
00:04:22,500 --> 00:04:23,970
评估大部队中说这是火车失事

118
00:04:23,970 --> 00:04:26,040
这东西实际上是一个指向

119
00:04:26,040 --> 00:04:27,060
指针的指针

120
00:04:27,060 --> 00:04:28,350
所以他有一个东西 将元组点称为

121
00:04:28,350 --> 00:04:29,940
指针，这变成了一场

122
00:04:29,940 --> 00:04:31,080
噩梦，我们有很多

123
00:04:31,080 --> 00:04:32,550
间接层，现在这个只是

124
00:04:32,550 --> 00:04:34,440
告诉你如何去块

125
00:04:34,440 --> 00:04:37,380
ID，然后或块块位置

126
00:04:37,380 --> 00:04:39,320
，然后这只是偏移量

127
00:04:39,320 --> 00:04:41,400
再次要指出的主要

128
00:04:41,400 --> 00:04:43,680
事情是，我们所有的元组都

129
00:04:43,680 --> 00:04:45,360
将尝试存储这些固定

130
00:04:45,360 --> 00:04:48,090
长度的连续内存片，

131
00:04:48,090 --> 00:04:49,710
无论它是我们行存储的列

132
00:04:49,710 --> 00:04:51,990
都没有关系，这些值需要

133
00:04:51,990 --> 00:04:53,639
固定长度，因为那样 我们可以做到这

134
00:04:53,639 --> 00:04:55,919
一点 算术很容易说哦，我

135
00:04:55,919 --> 00:04:57,810
想要第五个元组我知道

136
00:04:57,810 --> 00:04:59,340
每个元组的大小我的块我知道如何跳转

137
00:04:59,340 --> 00:05:01,430
到该元组的起始位置

138
00:05:01,430 --> 00:05:03,389
任何可能是可变长度的东西

139
00:05:03,389 --> 00:05:05,460
都会改为将它存储在

140
00:05:05,460 --> 00:05:07,770
我们拥有的单独数据池中 可变

141
00:05:07,770 --> 00:05:09,120
长度的数据块，这种

142
00:05:09,120 --> 00:05:10,350
看起来像 malloc 不需要

143
00:05:10,350 --> 00:05:11,850
像 bin 打包问题那样的封面

144
00:05:11,850 --> 00:05:16,350
试图坚持你知道

145
00:05:16,350 --> 00:05:17,550
不同大小的内存的不同区域，

146
00:05:17,550 --> 00:05:19,889
所以这只是现在一个

147
00:05:19,889 --> 00:05:22,710
指向该位置的 64 位指针 所以这就是

148
00:05:22,710 --> 00:05:23,490
我们今天要讨论的内容 我们要

149
00:05:23,490 --> 00:05:25,080
讨论的是我们实际上

150
00:05:25,080 --> 00:05:27,090
将如何在此处表示内容，然后在此处表示内容

151
00:05:27,090 --> 00:05:31,320
所以在高层次上，

152
00:05:31,320 --> 00:05:32,910
您在内存数据库中的想法

153
00:05:32,910 --> 00:05:35,789
只是这只是一个 大字节数组我们

154
00:05:35,789 --> 00:05:37,710
分配了一堆内存块，

155
00:05:37,710 --> 00:05:39,960
然后我们需要一种方法来解释

156
00:05:39,960 --> 00:05:42,330
这些内存块或这些内存

157
00:05:42,330 --> 00:05:45,210
块的区域以推断模式实际上是什么，

158
00:05:45,210 --> 00:05:47,690
因为我们是关系数据库，

159
00:05:47,690 --> 00:05:50,700
我们被告知 提前化学 JSON

160
00:05:50,700 --> 00:05:52,110
内容通常仅被视为

161
00:05:52,110 --> 00:05:54,510
每个长度数据的变量，但

162
00:05:54,510 --> 00:05:56,160
我们知道我的列

163
00:05:56,160 --> 00:05:57,720
中有这些可以具有这些类型和这些

164
00:05:57,720 --> 00:06:00,570
大小的数据，所以现在当我们跳转到

165
00:06:00,570 --> 00:06:03,660
该固定长度数据池中的偏移量时 我们

166
00:06:03,660 --> 00:06:05,100
知道这是一个元组的起始位置

167
00:06:05,100 --> 00:06:07,200
，我们知道如何

168
00:06:07,200 --> 00:06:08,490
解释我们正在查看的航班我们知道

169
00:06:08,490 --> 00:06:10,320
是将其解释为整数

170
00:06:10,320 --> 00:06:15,389
还是浮点数，或者您

171
00:06:15,389 --> 00:06:16,770
知道时间戳 两

172
00:06:16,770 --> 00:06:17,910
本书可以以结束元数据的标题作为前缀，

173
00:06:17,910 --> 00:06:19,560
例如

174
00:06:19,560 --> 00:06:21,479
可见性将谈论空值并将其

175
00:06:21,479 --> 00:06:23,190
粘贴在那里，但基本上

176
00:06:23,190 --> 00:06:24,930
当我跳到一个偏移量时说这

177
00:06:24,930 --> 00:06:26,220
是元组的起始位置我

178
00:06:26,220 --> 00:06:27,870
真的跳进了 标头，我可以

179
00:06:27,870 --> 00:06:28,830
查看该标头并尝试

180
00:06:28,830 --> 00:06:30,840
弄清楚您知道接下来会发生什么

181
00:06:30,840 --> 00:06:32,610
，我们不会

182
00:06:32,610 --> 00:06:34,410
在标头中存储任何模式信息，

183
00:06:34,410 --> 00:06:35,669
因为对于每个元组都这样做会很浪费

184
00:06:35,669 --> 00:06:38,159
我们的

185
00:06:38,159 --> 00:06:40,409
模式列表必须这样做的 JSON 数据库，但在我们的

186
00:06:40,409 --> 00:06:40,920
世界中，

187
00:06:40,920 --> 00:06:42,090
您知道每个元组都必须具有

188
00:06:42,090 --> 00:06:44,520
相同的相同结构和相同的布局

189
00:06:44,520 --> 00:06:46,410
，因此我们不需要

190
00:06:46,410 --> 00:06:49,950
在标题中重复存储它，所以今天

191
00:06:49,950 --> 00:06:50,790
我们要 讨论做类型

192
00:06:50,790 --> 00:06:51,960
表示我们如何实际

193
00:06:51,960 --> 00:06:54,300
表示单个元素或

194
00:06:54,300 --> 00:06:56,730
属性和一个元组然后我们将在讨论的基础

195
00:06:56,730 --> 00:06:58,080
上构建我们

196
00:06:58,080 --> 00:07:00,660
现在如何为单个元组布局这些属性

197
00:07:00,660 --> 00:07:02,430
然后我们将讨论不同的

198
00:07:02,430 --> 00:07:03,630
存储模型然后 我们有时间

199
00:07:03,630 --> 00:07:05,370
结束并讨论系统

200
00:07:05,370 --> 00:07:08,640
目录，因为这

201
00:07:08,640 --> 00:07:10,410
有点像我希望你们知道的附加内容，

202
00:07:10,410 --> 00:07:11,820


203
00:07:11,820 --> 00:07:13,110
这实际上是你可以做的很酷的事情，

204
00:07:13,110 --> 00:07:15,840
因为你有 一个具有模式的关系

205
00:07:15,840 --> 00:07:17,070
目录关系数据库，

206
00:07:17,070 --> 00:07:19,710
但那些所以大部分

207
00:07:19,710 --> 00:07:21,030
主要材料想要关注的是

208
00:07:21,030 --> 00:07:22,080
存储模型和 Panta bhaat

209
00:07:22,080 --> 00:07:28,950
好吧，所以这与

210
00:07:28,950 --> 00:07:30,660
我之前在介绍类中展示过的相同，但

211
00:07:30,660 --> 00:07:33,240
基础 我们知道我们的

212
00:07:33,240 --> 00:07:35,040
数据库系统可以支持的所有类型 续集

213
00:07:35,040 --> 00:07:37,140
标准指定了基本类型

214
00:07:37,140 --> 00:07:40,320
是什么，然后我们知道这

215
00:07:40,320 --> 00:07:44,250
实际上代表了将每个位报告

216
00:07:44,250 --> 00:07:46,680
为属性值的位，因此对于

217
00:07:46,680 --> 00:07:49,230
整数大小瞬间我们

218
00:07:49,230 --> 00:07:50,850


219
00:07:50,850 --> 00:07:52,740
当我们说

220
00:07:52,740 --> 00:07:55,980
像 int 32 或 64 或小租金一样分配时，将使用 C 或 supercells 为我们提供

221
00:07:55,980 --> 00:07:57,450
的东西 我没有什么特别的，我们将

222
00:07:57,450 --> 00:07:58,650
在分配时采用我们所拥有的任何位

223
00:07:58,650 --> 00:08:00,090
，您知道这样的变量

224
00:08:00,090 --> 00:08:01,890
，那就是 我们

225
00:08:01,890 --> 00:08:04,860
为浮点数存储在我们的数据库中

226
00:08:04,860 --> 00:08:05,820
我们将

227
00:08:05,820 --> 00:08:08,400
区分浮点数和实数

228
00:08:08,400 --> 00:08:10,320


229
00:08:10,320 --> 00:08:12,360


230
00:08:12,360 --> 00:08:13,470


231
00:08:13,470 --> 00:08:15,360
浮点数，但这

232
00:08:15,360 --> 00:08:17,460
会有四舍五入和准确性问题，

233
00:08:17,460 --> 00:08:19,650
然后是定点

234
00:08:19,650 --> 00:08:21,480
小数，续集标准中指定的数字和小数类型

235
00:08:21,480 --> 00:08:23,400
每个

236
00:08:23,400 --> 00:08:24,870
数据库系统都是 f  ree 以

237
00:08:24,870 --> 00:08:27,270
他们希望的任何方式实现这一点 一些

238
00:08:27,270 --> 00:08:28,620
比其他的更有效 Oracle

239
00:08:28,620 --> 00:08:30,930
一个比 Postgres 更好，但

240
00:08:30,930 --> 00:08:32,400
主要思想是这与浮点数时间戳中

241
00:08:32,400 --> 00:08:33,720
的舍入误差不同

242
00:08:33,720 --> 00:08:36,390


243
00:08:36,390 --> 00:08:39,750
日期和时间类型也

244
00:08:39,750 --> 00:08:41,610
因实现而异，续集

245
00:08:41,610 --> 00:08:43,320
标准没有指定您

246
00:08:43,320 --> 00:08:45,780
实际如何表示这些类型的

247
00:08:45,780 --> 00:08:47,700
属性，但它们确实指定了

248
00:08:47,700 --> 00:08:49,050
您知道可以执行的操作类型，

249
00:08:49,050 --> 00:08:50,790
但是我可以将两次加在一起还是

250
00:08:50,790 --> 00:08:53,130
可以减去它们 诸如此类的一种

251
00:08:53,130 --> 00:08:54,329
常见方法

252
00:08:54,329 --> 00:08:57,239
就是 UNIX 纪元，因此它是

253
00:08:57,239 --> 00:08:59,360
自

254
00:08:59,360 --> 00:09:02,699
1970 年 1 月 1 日以来的秒数或毫秒数，您可以使用它来

255
00:09:02,699 --> 00:09:04,139
计算水域板的当前日期

256
00:09:04,139 --> 00:09:06,899
和 C++ 时间，有

257
00:09:06,899 --> 00:09:10,230
一个叫做时间规范的东西，它为您提供 时间

258
00:09:10,230 --> 00:09:12,299
偏移，然后是纳秒偏移，

259
00:09:12,299 --> 00:09:14,429


260
00:09:14,429 --> 00:09:16,769
在我们当前的系统中实际上比这大 16 个字节我认为我们

261
00:09:16,769 --> 00:09:20,459
使用的是 64 位和 64 位整数，这

262
00:09:20,459 --> 00:09:21,689
是秒的中间 从 UNIX

263
00:09:21,689 --> 00:09:23,279
时代开始，但又是从座位开始，但

264
00:09:23,279 --> 00:09:24,629
你不知道的续集级别，你不

265
00:09:24,629 --> 00:09:25,829
关心你只知道你有时间戳，

266
00:09:25,829 --> 00:09:27,629
你可以把东西放进去，你可以

267
00:09:27,629 --> 00:09:30,360
对它们进行比较，以获取

268
00:09:30,360 --> 00:09:32,009
我们二进制文本的 VAR 费用 如果我们尝试存储的值小于 64 大于 64 位

269
00:09:32,009 --> 00:09:34,589


270
00:09:34,589 --> 00:09:36,410
，则元组的固定长度部分中的可变长度字段将存储指向

271
00:09:36,410 --> 00:09:39,139
语言长度池中某个数据块的指针，

272
00:09:39,139 --> 00:09:42,629


273
00:09:42,629 --> 00:09:45,059


274
00:09:45,059 --> 00:09:47,790
如果大小正确

275
00:09:47,790 --> 00:09:49,709
我们存储的数据小于

276
00:09:49,709 --> 00:09:51,989
指针 他们无意识地存储数据

277
00:09:51,989 --> 00:09:53,279
而不是拥有指向该数据的指针

278
00:09:53,279 --> 00:09:55,290
比这更大的数据 然后我们将

279
00:09:55,290 --> 00:09:56,879
它存储在一个非常类似的数据池中

280
00:09:56,879 --> 00:09:58,170
我们将保留一些额外的元数据

281
00:09:58,170 --> 00:09:59,579
跟踪我们在看什么，

282
00:09:59,579 --> 00:10:01,589
如果它溢出到另一个数据池，我们

283
00:10:01,589 --> 00:10:03,089
也有这些指针，所以我会

284
00:10:03,089 --> 00:10:06,989
在我们继续的过程中介绍它，所以

285
00:10:06,989 --> 00:10:07,889
很快我将讨论

286
00:10:07,889 --> 00:10:09,149
可变精度和

287
00:10:09,149 --> 00:10:11,100
浮动的区别 点精度小数点 数字

288
00:10:11,100 --> 00:10:14,249
所以如果你选择一个实数或双精度浮点数，

289
00:10:14,249 --> 00:10:16,410
你会得到

290
00:10:16,410 --> 00:10:17,999
十进制或浮点数的硬件表示

291
00:10:17,999 --> 00:10:18,689


292
00:10:18,689 --> 00:10:21,029
正确，这是由

293
00:10:21,029 --> 00:10:22,829
我们的标准 72 指定的，每个 PCE 每个

294
00:10:22,829 --> 00:10:25,350
单个 CPU 都必须遵循所以 如果您

295
00:10:25,350 --> 00:10:27,989
在强大的 CPU 上存储浮点数，

296
00:10:27,989 --> 00:10:30,509
并且我们在 x86 中以相同的方式表示，

297
00:10:30,509 --> 00:10:32,489
那么 E&S 可能会像可能会切换位

298
00:10:32,489 --> 00:10:34,709
顺序一样切换，但在那种情况

299
00:10:34,709 --> 00:10:36,089
下，您知道如何跟踪

300
00:10:36,089 --> 00:10:37,230
小数点以及什么是 在它之前和

301
00:10:37,230 --> 00:10:40,439
之后它都由这个指定所以

302
00:10:40,439 --> 00:10:43,230
这将非常快因为

303
00:10:43,230 --> 00:10:44,879
港口实际上会让你知道

304
00:10:44,879 --> 00:10:46,919
低级指令支持让

305
00:10:46,919 --> 00:10:48,269
你知道浮点数并

306
00:10:48,269 --> 00:10:49,529
比较它们或原子将它们加在一起

307
00:10:49,529 --> 00:10:51,809
它不会 可能与

308
00:10:51,809 --> 00:10:55,499
对整数进行加法一样快，但它

309
00:10:55,499 --> 00:10:57,360
肯定

310
00:10:57,360 --> 00:10:58,649
比我们可以在数据库系统中管理自己的任何事情都快，

311
00:10:58,649 --> 00:11:00,929
但缺点

312
00:11:00,929 --> 00:11:02,160
是你会遇到舍入错误，

313
00:11:02,160 --> 00:11:03,869
所以如果你写 ar 像这样的非常简单的 C

314
00:11:03,869 --> 00:11:05,009
程序，你把两个

315
00:11:05,009 --> 00:11:09,000
数字变成 32 位浮点数

316
00:11:09,000 --> 00:11:11,430
零点一和零点二，如果我

317
00:11:11,430 --> 00:11:13,260
把它们加在一起，你认为

318
00:11:13,260 --> 00:11:15,240
答案是零点三，但

319
00:11:15,240 --> 00:11:16,260
问题是当你真正开始看你是

320
00:11:16,260 --> 00:11:19,280
什么时 知道

321
00:11:19,280 --> 00:11:22,170
小数点的位置，你会看到你最终得到

322
00:11:22,170 --> 00:11:23,820
了各种奇怪的东西，因为

323
00:11:23,820 --> 00:11:26,190
港口又不能精确地

324
00:11:26,190 --> 00:11:29,790
存储零点三，所以即使你

325
00:11:29,790 --> 00:11:32,070
知道打印零点三，你也会得到

326
00:11:32,070 --> 00:11:35,880
一堆一堆 东西所以

327
00:11:35,880 --> 00:11:39,810
这对于应用程序中的某些方面来说

328
00:11:39,810 --> 00:11:42,090
这很好也许这

329
00:11:42,090 --> 00:11:43,920
没问题就像如果我存储你知道

330
00:11:43,920 --> 00:11:47,130
这个房间的温度我

331
00:11:47,130 --> 00:11:48,990
不需要让你知道一个超级准确的

332
00:11:48,990 --> 00:11:51,600
测量对九十八点

333
00:11:51,600 --> 00:11:53,430
六分 或九十点零就

334
00:11:53,430 --> 00:11:55,350
足够了，但如果我处理像

335
00:11:55,350 --> 00:11:56,880
金钱或任何类似科学

336
00:11:56,880 --> 00:11:58,260
测量的东西，我不想要这些

337
00:11:58,260 --> 00:12:00,660
浮点舍入误差，那么我想使用

338
00:12:00,660 --> 00:12:03,000
定点十进制数，这里的想法

339
00:12:03,000 --> 00:12:04,530
是 数据库系统

340
00:12:04,530 --> 00:12:06,270
本身会跟踪

341
00:12:06,270 --> 00:12:08,460
我们试图存储的确切值是什么

342
00:12:08,460 --> 00:12:11,100
，它会处理所有的舍入错误

343
00:12:11,100 --> 00:12:13,230
或在您开始进行乘法和操作时可能出现的其他问题，

344
00:12:13,230 --> 00:12:14,250


345
00:12:14,250 --> 00:12:20,339
所以这实际上是我 '我

346
00:12:20,339 --> 00:12:22,020
说这里不准确所以这

347
00:12:22,020 --> 00:12:23,670
实际上是 Postgres 所做的

348
00:12:23,670 --> 00:12:26,220
Postgres 所做的将

349
00:12:26,220 --> 00:12:27,720
小数点数字本质上存储为 varchar'

350
00:12:27,720 --> 00:12:29,760
就像一个字符串，然后他们有一些

351
00:12:29,760 --> 00:12:31,140
额外的元数据来跟踪

352
00:12:31,140 --> 00:12:32,730
小数点在哪里 它是

353
00:12:32,730 --> 00:12:34,530
负面的还是正面的一些

354
00:12:34,530 --> 00:12:36,300
舍入问题，所以他们有像 switch 这样的巨型

355
00:12:36,300 --> 00:12:38,250
语句来处理

356
00:12:38,250 --> 00:12:39,510


357
00:12:39,510 --> 00:12:41,610
你想要做的操作类型的所有这些不同的变化，它的运行

358
00:12:41,610 --> 00:12:43,430
速度大约

359
00:12:43,430 --> 00:12:47,130
是超级家伙拥有的浮点数的两倍

360
00:12:47,130 --> 00:12:50,010
一种

361
00:12:50,010 --> 00:12:52,890
用于扭曲定点死亡痣的低级位操作方法，

362
00:12:52,890 --> 00:12:54,120
这种方法非常

363
00:12:54,120 --> 00:12:55,800
有效，实际上某些情况可以

364
00:12:55,800 --> 00:12:57,270
比浮点数运行得更快

365
00:12:57,270 --> 00:12:58,440
我不知道这怎么

366
00:12:58,440 --> 00:12:59,910
可能，但这是他们向我们展示的内容，

367
00:12:59,910 --> 00:13:02,760
所以我没有时间教导我

368
00:13:02,760 --> 00:13:03,900
还没有完全理解他们在

369
00:13:03,900 --> 00:13:05,640
做什么 德国人

370
00:13:05,640 --> 00:13:06,690
推荐了这本书叫黑客

371
00:13:06,690 --> 00:13:09,420
高兴 向您展示如何进行所有

372
00:13:09,420 --> 00:13:11,339
这些一点点操作，但这

373
00:13:11,339 --> 00:13:12,839
是您想要为项目三追求的东西，

374
00:13:12,839 --> 00:13:16,649
那么我们应该说是的

375
00:13:16,649 --> 00:13:18,300
银行他们使用四位，然后

376
00:13:18,300 --> 00:13:21,480
只是缺少十进制播放所以

377
00:13:21,480 --> 00:13:25,439
即使这是像信号十进制这样的随机

378
00:13:25,439 --> 00:13:28,819
位置只有四位

379
00:13:28,819 --> 00:13:41,009
哦，是的，所以我不知道想想

380
00:13:41,009 --> 00:13:44,220
我知道，就像银行一样，他们

381
00:13:44,220 --> 00:13:47,189
从不覆盖数据，所以如果

382
00:13:47,189 --> 00:13:49,499
可能会发生舍入问题，

383
00:13:49,499 --> 00:13:50,670
因为他们的应用程序的

384
00:13:50,670 --> 00:13:52,529
编写方式，当你的计算机喜欢利息

385
00:13:52,529 --> 00:13:54,149
或 像抓取这样的东西，你可以随时

386
00:13:54,149 --> 00:13:55,829
返回并修复它，因为你知道再次重新运行

387
00:13:55,829 --> 00:13:57,119
计算，

388
00:13:57,119 --> 00:13:58,740
这样你就不会丢失任何数据——

389
00:13:58,740 --> 00:14:00,899
因为精度不精确我不

390
00:14:00,899 --> 00:14:02,699
知道我不知道这是什么 ng我

391
00:14:02,699 --> 00:14:04,589
真的很感兴趣，但我

392
00:14:04,589 --> 00:14:06,209
对它的了解还不够

393
00:14:06,209 --> 00:14:07,439


394
00:14:07,439 --> 00:14:09,269
多，除了我知道德国人已经解决了它之外，你是否知道人们实际上在做什么，

395
00:14:09,269 --> 00:14:11,699
但我还不

396
00:14:11,699 --> 00:14:12,569
知道他们在做什么 我还没有完全

397
00:14:12,569 --> 00:14:14,639
理解，这是

398
00:14:14,639 --> 00:14:15,540
你想要为第三个项目做的事情

399
00:14:15,540 --> 00:14:17,339
我很乐意尝试帮助解决

400
00:14:17,339 --> 00:14:18,990
这个问题，我会告诉你

401
00:14:18,990 --> 00:14:21,410
指出他推荐的书中的章节，

402
00:14:21,410 --> 00:14:29,249
所以就像我一样 再说一遍，

403
00:14:29,249 --> 00:14:30,420
数据库本质上只是一个字节

404
00:14:30,420 --> 00:14:34,709
数组，你知道一个字符数组或

405
00:14:34,709 --> 00:14:37,079
字节数组，然后现在我们需要

406
00:14:37,079 --> 00:14:39,600
开始把意义

407
00:14:39,600 --> 00:14:41,639
放在这些字节中存储的位上，所以说

408
00:14:41,639 --> 00:14:43,709
我有一个简单的表 这里有两个

409
00:14:43,709 --> 00:14:46,769
字段 ID 作为一个 32 位整数，它是

410
00:14:46,769 --> 00:14:48,720
主键，然后值是一个 64 位

411
00:14:48,720 --> 00:14:51,449
整数，所以元组的布局

412
00:14:51,449 --> 00:14:53,879
看起来像这样，我有

413
00:14:53,879 --> 00:14:56,370
一些大小的标题，我正在存储你知道的

414
00:14:56,370 --> 00:14:57,600
时间戳以及我们

415
00:14:57,600 --> 00:14:59,730
之前和之后谈论的所有内容

416
00:14:59,730 --> 00:15:02,639
标题现在结束我有 ID 字段，

417
00:15:02,639 --> 00:15:04,319
当它结束时我现在有值

418
00:15:04,319 --> 00:15:08,879
字段所以如果我现在需要我在我的

419
00:15:08,879 --> 00:15:10,620
数据库系统中我想了解

420
00:15:10,620 --> 00:15:13,220
就像我需要阅读你知道这个

421
00:15:13,220 --> 00:15:15,959
字段我知道如何找到

422
00:15:15,959 --> 00:15:18,899
这个元组的位置是正确的，因为索引

423
00:15:18,899 --> 00:15:21,059
让我在那里所有的标题

424
00:15:21,059 --> 00:15:23,279
都是相同的大小所以我知道如何

425
00:15:23,279 --> 00:15:25,649
然后跳过那个位置然后在

426
00:15:25,649 --> 00:15:27,569
这里的这个位置然后我之后阅读的所有内容

427
00:15:27,569 --> 00:15:30,570
高达 32 位将是眼睛

428
00:15:30,570 --> 00:15:34,290
Liefeld 那么

429
00:15:34,290 --> 00:15:35,940
当您在我们的 C 代码或梅毒代码中知道这些数据时，我们如何实际访问这些数据，

430
00:15:35,940 --> 00:15:37,410
您会

431
00:15:37,410 --> 00:15:39,120
看到一堆字节数组吗？我们需要一种方法

432
00:15:39,120 --> 00:15:40,800
将其转换为

433
00:15:40,800 --> 00:15:43,790
我们可以将其解释为 30 位整数的内容

434
00:15:43,790 --> 00:15:48,380
让我来告诉我们你是如何做到这一点的，C++

435
00:15:48,920 --> 00:15:51,840
重新解释转换，所以

436
00:15:51,840 --> 00:15:53,760
现在在这个编译器

437
00:15:53,760 --> 00:15:55,650
构造中要说的就是这一切，

438
00:15:55,650 --> 00:15:57,030
当我读取这个内存地址时，

439
00:15:57,030 --> 00:15:59,220
将你正在读取的任何内容视为不是

440
00:15:59,220 --> 00:16:03,600
字节数组，但是 一个 32 位整数，所以

441
00:16:03,600 --> 00:16:05,400
现在在 编译器知道当

442
00:16:05,400 --> 00:16:06,870
访问时它只会访问

443
00:16:06,870 --> 00:16:11,700
那些 32 位，所以现在对于

444
00:16:11,700 --> 00:16:14,400
可变长度数据说我有一个

445
00:16:14,400 --> 00:16:18,390
条形图 1024 所以在固定长度

446
00:16:18,390 --> 00:16:20,760
数据数组中我会有我的标题然后

447
00:16:20,760 --> 00:16:23,820
我有 64 位指针，

448
00:16:23,820 --> 00:16:25,620
现在将指向

449
00:16:25,620 --> 00:16:28,200
变体中的某个内存区域，

450
00:16:28,200 --> 00:16:29,880
例如数据池 起始位置

451
00:16:29,880 --> 00:16:31,560
将告诉我您知道找到

452
00:16:31,560 --> 00:16:33,300
我想要的实际值，因此在这种情况下，

453
00:16:33,300 --> 00:16:35,310
此处为每个条目

454
00:16:35,310 --> 00:16:37,350
非常链接的数据池它将有自己的

455
00:16:37,350 --> 00:16:39,300
标头，用于跟踪我们为这个块连续

456
00:16:39,300 --> 00:16:40,500
存储的数据的长度是多少

457
00:16:40,500 --> 00:16:43,260
，然后如果

458
00:16:43,260 --> 00:16:45,180
它溢出这个块，就会有一个

459
00:16:45,180 --> 00:16:46,980
下一个指针向下跳到一些

460
00:16:46,980 --> 00:16:49,260
我们正确读取其余数据的其他内存位置，

461
00:16:49,260 --> 00:16:52,050
因此这不是

462
00:16:52,050 --> 00:16:54,420
美国基地独有的，

463
00:16:54,420 --> 00:16:55,830


464
00:16:55,830 --> 00:16:57,900
如果您是 varchar

465
00:16:57,900 --> 00:16:58,680
或文本字段

466
00:16:58,680 --> 00:17:01,020
在不同页面之间溢出，则基于磁盘的数据库会做同样的事情

467
00:17:01,020 --> 00:17:02,100
你需要 你需要一种方法来如何

468
00:17:02,100 --> 00:17:04,859
将所有这些连接在一起

469
00:17:04,859 --> 00:17:06,209
我不想过多谈论的另一件事

470
00:17:06,209 --> 00:17:09,780
是这将是这

471
00:17:09,780 --> 00:17:11,150
通常不会以空终止，

472
00:17:11,150 --> 00:17:13,050
因为否则你的体重

473
00:17:13,050 --> 00:17:14,160
你知道你正在浪费一个字节 对于那些

474
00:17:14,160 --> 00:17:17,250
你无缘无故知道的人，所以在我们的代码中，我们

475
00:17:17,250 --> 00:17:18,630
不能像你知道的那样直接调用它

476
00:17:18,630 --> 00:17:21,089
字符串比较我们在我们的字符串长度

477
00:17:21,089 --> 00:17:23,280
中添加了一个 see 库来比较这个

478
00:17:23,280 --> 00:17:25,349
东西，因为它不会有一个你

479
00:17:25,349 --> 00:17:27,209
知道 null 在 结束所以它不是真正的

480
00:17:27,209 --> 00:17:28,530
C 字符串所以我们必须写一些

481
00:17:28,530 --> 00:17:31,080
额外的我们必须编写我们自己的

482
00:17:31,080 --> 00:17:32,490
字符串函数我们不解释这个

483
00:17:32,490 --> 00:17:36,870
东西并且理解它没关系

484
00:17:36,870 --> 00:17:40,380
我们可以在这里做的其他优化是说

485
00:17:40,380 --> 00:17:42,270
你知道说我 时间查找你

486
00:17:42,270 --> 00:17:44,910
终于知道所有的

487
00:17:44,910 --> 00:17:46,500
字符串值 值

488
00:17:46,500 --> 00:17:48,240
是字符串的开头以一个

489
00:17:48,240 --> 00:17:50,670
单词和 II 开头的地方，所以我必须怎么

490
00:17:50,670 --> 00:17:52,410
做，有了这个设置，我必须

491
00:17:52,410 --> 00:17:54,990
扫描我的表，然后 对于每

492
00:17:54,990 --> 00:17:57,330
一个元组，按照这个指针指向

493
00:17:57,330 --> 00:17:59,220
某处某个随机位置，然后

494
00:17:59,220 --> 00:18:01,020
跳转你知道你知道你知道将它跳转到

495
00:18:01,020 --> 00:18:02,430
第一个你知道一些字节并查看

496
00:18:02,430 --> 00:18:04,320
它是否以 D 开头，所以

497
00:18:04,320 --> 00:18:05,790
这样做真的很昂贵，因为

498
00:18:05,790 --> 00:18:08,220
它会很多很多很多的间接

499
00:18:08,220 --> 00:18:10,430
分支错误预测，因为

500
00:18:10,430 --> 00:18:13,260
没有条件，但基本上

501
00:18:13,260 --> 00:18:15,030
我会扫描内存的一部分，然后

502
00:18:15,030 --> 00:18:16,050
跳转到另一部分，然后

503
00:18:16,050 --> 00:18:17,790
再回来询问，

504
00:18:17,790 --> 00:18:19,890
因为我会有 bat 缓存位置，

505
00:18:19,890 --> 00:18:20,910
因为它不像我可以继续

506
00:18:20,910 --> 00:18:22,800
扫描 同样你

507
00:18:22,800 --> 00:18:24,300
知道我一次性带进我的缓存的一堆东西

508
00:18:24,300 --> 00:18:25,740
我必须一遍

509
00:18:25,740 --> 00:18:27,720
又一遍地跳过所以一个非常简单的

510
00:18:27,720 --> 00:18:30,620
优化实际上是填充

511
00:18:30,620 --> 00:18:32,940
你存储

512
00:18:32,940 --> 00:18:34,710
在固定长度数据中的指针部分 在下面包含

513
00:18:34,710 --> 00:18:38,730
字符串的前缀，所以现在

514
00:18:38,730 --> 00:18:40,230
当我扫描并尝试查找

515
00:18:40,230 --> 00:18:41,910
以 DI 开头的内容时，可以只

516
00:18:41,910 --> 00:18:43,290
查看此内容并查看它

517
00:18:43,290 --> 00:18:44,520
是否匹配，而且我从未让团队

518
00:18:44,520 --> 00:18:47,010
接触任何这些内容，因此我们交流 所以

519
00:18:47,010 --> 00:18:48,390
这个 hyper 这样做，我们实际上

520
00:18:48,390 --> 00:18:51,240
在我们自己的系统中这样做，所以

521
00:18:51,240 --> 00:18:53,400
厚

522
00:18:53,400 --> 00:18:56,040
固定长度数据池中 varlyn 字段的指针部分将是 16

523
00:18:56,040 --> 00:18:58,770
字节或 128 位，所以我们存储

524
00:18:58,770 --> 00:19:00,780
64 位指向实际数据的指针

525
00:19:00,780 --> 00:19:02,760
然后我们使用剩余的 64 位来

526
00:19:02,760 --> 00:19:06,510
存储前缀 你也可以存储

527
00:19:06,510 --> 00:19:08,880
整个字符串的散列 有

528
00:19:08,880 --> 00:19:11,030
不同的方法你可以使用

529
00:19:11,030 --> 00:19:15,420
好吧 现在好吧 现在我们

530
00:19:15,420 --> 00:19:17,640
知道如何存储基本标量或

531
00:19:17,640 --> 00:19:19,110
固定长度的标量值 值整数

532
00:19:19,110 --> 00:19:21,780
浮点数和时间戳现在我们知道如何

533
00:19:21,780 --> 00:19:25,500
存储非常长的数据现在

534
00:19:25,500 --> 00:19:27,050
我们要处理的最后一件事是空值

535
00:19:27,050 --> 00:19:29,310
所以至少据我所知有三种方法可以做空值

536
00:19:29,310 --> 00:19:32,130
第

537
00:19:32,130 --> 00:19:34,590
一种方法是只指定一个特殊

538
00:19:34,590 --> 00:19:38,850
值 在数据库中的一个类型的域中

539
00:19:38,850 --> 00:19:43,470
表示 null 所以

540
00:19:43,470 --> 00:19:45,120
你可以做的一件事是说在 Lib C 中定义的最小的 30 立方

541
00:19:45,120 --> 00:19:46,380
整数

542
00:19:46,380 --> 00:19:48,690
是在 32 分钟内，就像这个

543
00:19:48,690 --> 00:19:51,690
磅定义将是 null 所以如果我

544
00:19:51,690 --> 00:19:53,610
曾经 看到这个 当我查看

545
00:19:53,610 --> 00:19:56,010
一个元组时，我会把它当作一个

546
00:19:56,010 --> 00:19:58,070
空值，而不是在 32 分钟内，

547
00:19:58,070 --> 00:20:01,160
所以现在在上面，你

548
00:20:01,160 --> 00:20:02,450
在数据库系统的存储层上面，你

549
00:20:02,450 --> 00:20:03,560
必须考虑这个，就像有人

550
00:20:03,560 --> 00:20:06,530
尝试一样 要插入这个值，你必须

551
00:20:06,530 --> 00:20:08,000
抛出你知道抛出异常抛出

552
00:20:08,000 --> 00:20:09,890
一个错误，因为他们是你知道他们

553
00:20:09,890 --> 00:20:11,690
试图存储这个值，然后你已经

554
00:20:11,690 --> 00:20:13,280
读回它并说你知道它是

555
00:20:13,280 --> 00:20:15,050
空的，那会有点

556
00:20:15,050 --> 00:20:16,760
混乱 你之前基本上有一堆

557
00:20:16,760 --> 00:20:18,470
额外的边界代码，以

558
00:20:18,470 --> 00:20:20,270
确保这被认为是超出

559
00:20:20,270 --> 00:20:25,370
范围的，所以我们在商店和

560
00:20:25,370 --> 00:20:28,850
volte B 我们这样做了 Mon Ami Mon 一个 DB

561
00:20:28,850 --> 00:20:29,930
做同样的事情，然后我们

562
00:20:29,930 --> 00:20:32,420
最初正在做 这是

563
00:20:32,420 --> 00:20:34,870
在 CMU 旧单元电影大楼中的 Peloton，

564
00:20:34,870 --> 00:20:36,980
但据他们所知，除了

565
00:20:36,980 --> 00:20:38,450
Moe 之外，这两个都是

566
00:20:38,450 --> 00:20:40,400
我所知道的唯一这样做的，更

567
00:20:40,400 --> 00:20:42,980
常见的方法是使用空列位

568
00:20:42,980 --> 00:20:45,440
图，所以我们 '现在要

569
00:20:45,440 --> 00:20:48,020
在我们的元组标题中存储 我们有

570
00:20:48,020 --> 00:20:49,610
这个位图字段，它会为

571
00:20:49,610 --> 00:20:51,110
我在我的池中拥有的每一个属性说

572
00:20:51,110 --> 00:20:53,480
如果

573
00:20:53,480 --> 00:20:57,020
该属性是已知的，那么如果我有

574
00:20:57,020 --> 00:21:00,560
一千个属性或每个元组，那么我

575
00:21:00,560 --> 00:21:02,420
有我的位图你有 一千

576
00:21:02,420 --> 00:21:04,910
个条目，所以现在当我扫描

577
00:21:04,910 --> 00:21:07,220
两点并应用谓词时，我会

578
00:21:07,220 --> 00:21:09,590
在这件事中进行查找，以查看

579
00:21:09,590 --> 00:21:11,540
我正在查看的准确信息是否是您知道的

580
00:21:11,540 --> 00:21:13,310
那个位设置为 true，如果是，则它为

581
00:21:13,310 --> 00:21:16,790
空 是更常见的方式，但是对于

582
00:21:16,790 --> 00:21:18,680
像我的续集 Postgres 续集服务器 oracle 这样的 dis 数据库中的内存数据库，

583
00:21:18,680 --> 00:21:20,450


584
00:21:20,450 --> 00:21:22,340
每个人都是这样做的，这就是

585
00:21:22,340 --> 00:21:24,920
我们现在在我们自己的系统中所做的，因为现在

586
00:21:24,920 --> 00:21:27,650
我们也是一个列存储，这只是

587
00:21:27,650 --> 00:21:30,320
现在不是 Murat 存储 每个

588
00:21:30,320 --> 00:21:32,840
元组的这个位图我们只是为你知道

589
00:21:32,840 --> 00:21:34,250
单列这里是

590
00:21:34,250 --> 00:21:38,020
每个元组的整个位图它在一个

591
00:21:38,020 --> 00:21:42,560
块中最后一个是安全

592
00:21:42,560 --> 00:21:45,560
的我认为这个很愚蠢只有一个

593
00:21:45,560 --> 00:21:47,270
数据库说我知道这样做

594
00:21:47,270 --> 00:21:49,190
那是 mem 的续集 d 这是

595
00:21:49,190 --> 00:21:50,390
你要为

596
00:21:50,390 --> 00:21:52,400
元组中的每一个准确存储的地方你

597
00:21:52,400 --> 00:21:54,440
会有一个单独的标志来说明

598
00:21:54,440 --> 00:21:56,540
它是否不是我不是所以如果我有一个

599
00:21:56,540 --> 00:21:58,700
可能为空的 32 位整数那么我

600
00:21:58,700 --> 00:22:00,050
需要在它前面放一个小标志，

601
00:22:00,050 --> 00:22:02,990
说是的，你知道这东西是不是小丘

602
00:22:02,990 --> 00:22:09,159
，所以为什么这个愚蠢的是，是的

603
00:22:09,159 --> 00:22:11,509
，它说它布鲁因斯让我们失望了 不可能每个人

604
00:22:11,509 --> 00:22:14,929
都有相同的标志然后他们都设置

605
00:22:14,929 --> 00:22:26,449
好了 好吧 没有它在问题上

606
00:22:26,449 --> 00:22:29,359
而不是如果我有四个

607
00:22:29,359 --> 00:22:32,509
属性并且每个人都是 32 位加

608
00:22:32,509 --> 00:22:34,669
一位标志然后如果我想要

609
00:22:34,669 --> 00:22:36,589
第三个属性我拿 33 乘以三

610
00:22:36,589 --> 00:22:40,940
然后我跳到我需要去宾果游戏

611
00:22:40,940 --> 00:22:42,559
的地方 她说你没有 一个位

612
00:22:42,559 --> 00:22:45,049
可寻址内存，所以你不能得到我的

613
00:22:45,049 --> 00:22:46,549
32 位整数，不能使它成为

614
00:22:46,549 --> 00:22:48,769
33 位，因为这会使

615
00:22:48,769 --> 00:22:51,619
所有东西都未对齐，你不能

616
00:22:51,619 --> 00:22:55,639
以位偏移访问内存，你可以

617
00:22:55,639 --> 00:22:58,759
做字节偏移，所以如果你现在去

618
00:22:58,759 --> 00:23:01,099
查看 mem 续集文档，他们

619
00:23:01,099 --> 00:23:02,599
说所有不同的大小是多少

620
00:23:02,599 --> 00:23:04,309
他们支持的数据类型所以这是来自

621
00:23:04,309 --> 00:23:07,609
MC 等于六我最近看过

622
00:23:07,609 --> 00:23:09,529
你知道这是这个

623
00:23:09,529 --> 00:23:10,819
来自文档的图表可能已经两年了

624
00:23:10,819 --> 00:23:12,259
但最近加载了

625
00:23:12,259 --> 00:23:14,749
他们仍然为

626
00:23:14,749 --> 00:23:16,399
每个整数或七个这样做 每一种数据

627
00:23:16,399 --> 00:23:18,409
类型都是固定大小的数据类型，

628
00:23:18,409 --> 00:23:20,569
它们将有两个

629
00:23:20,569 --> 00:23:23,239
潜在的大小，如果它可以

630
00:23:23,239 --> 00:23:25,549
为空，那么它的大小和它的大小不为空，所以

631
00:23:25,549 --> 00:23:27,289
如果我们只是采取欺凌正确的布尔值

632
00:23:27,289 --> 00:23:28,549
是真还是假

633
00:23:28,549 --> 00:23:30,709
所以 这就是你看到的一辆自行车，

634
00:23:30,709 --> 00:23:32,869
因为我们不能存储单个位，所以如果

635
00:23:32,869 --> 00:23:35,089
它可以为空，那么我必须

636
00:23:35,089 --> 00:23:37,549
为另一个站点存储两个相同的字节

637
00:23:37,549 --> 00:23:40,279
，就像 Prytania 英寸

638
00:23:40,279 --> 00:23:42,559
双倍大小，他们得到的这个大小翻倍

639
00:23:42,559 --> 00:23:45,769
vibed 正在添加一个字节来

640
00:23:45,769 --> 00:23:47,959
使某些东西实际上没有采用该

641
00:23:47,959 --> 00:23:50,929
媒体媒体抱歉媒体它是

642
00:23:50,929 --> 00:23:52,249
三个字节所以他们

643
00:23:52,249 --> 00:23:55,190
为 int 和 big int 添加一个字节他们必须有

644
00:23:55,190 --> 00:23:57,049
四个字节因为那是 - 你兑现

645
00:23:57,049 --> 00:24:00,979
他们在中进行字对齐 x86 再次如此喜欢

646
00:24:00,979 --> 00:24:05,479
如果我现在存储如果您认为它

647
00:24:05,479 --> 00:24:07,940
像位图案例或

648
00:24:07,940 --> 00:24:10,249
返回这里这是最小的

649
00:24:10,249 --> 00:24:11,839
存储空间因为您不需要任何额外的

650
00:24:11,839 --> 00:24:13,609
空间实际上无论如何您必须存储它

651
00:24:13,609 --> 00:24:15,109
并且只是使用这个实际上

652
00:24:15,109 --> 00:24:17,690
一个说 哦，这是空的，这会变

653
00:24:17,690 --> 00:24:18,979
大一点，因为现在我必须为

654
00:24:18,979 --> 00:24:21,620


655
00:24:21,620 --> 00:24:24,140
我的元组警察中的每一个

656
00:24:24,140 --> 00:24:26,300


657
00:24:26,300 --> 00:24:27,770
致敬都有一点

658
00:24:27,770 --> 00:24:30,590
有点正确，这个是针对每

659
00:24:30,590 --> 00:24:32,390
一个属性我必须把它拍

660
00:24:32,390 --> 00:24:45,770
出来是的，这一切都被用来表示不，

661
00:24:45,770 --> 00:24:46,220
我的意思是，

662
00:24:46,220 --> 00:24:48,350
所以在续集中你可以拥有一个三

663
00:24:48,350 --> 00:24:49,730
类型的价值系统，所以我可以有一个值

664
00:24:49,730 --> 00:24:51,800
，我可以设置 它就像 true false 或

665
00:24:51,800 --> 00:24:54,050
null 和 null 表示未知我不

666
00:24:54,050 --> 00:24:59,270
知道值是什么因为他们

667
00:24:59,270 --> 00:25:05,679
告诉你叹气是的所以他的观点

668
00:25:05,679 --> 00:25:09,020
没问题所以他的观点是正确的我应该

669
00:25:09,020 --> 00:25:11,480
我是的我同意你知道他的

670
00:25:11,480 --> 00:25:14,510
陈述是什么 哦，我只是看着

671
00:25:14,510 --> 00:25:16,220
这个说哦，哇，你正在使用

672
00:25:16,220 --> 00:25:17,870
这个额外的 t  wo 字节只是为了存储空值，

673
00:25:17,870 --> 00:25:19,940
或者他们是否在执行我们的条形图技巧

674
00:25:19,940 --> 00:25:21,710
并在其中存储一些额外的废话，但是

675
00:25:21,710 --> 00:25:22,730
您到底要为一个属性存储什么，

676
00:25:22,730 --> 00:25:27,230
就像正确

677
00:25:27,230 --> 00:25:29,929
一样，对于这些酸洗，

678
00:25:29,929 --> 00:25:32,809
我可以想象像 在一个条形图中，

679
00:25:32,809 --> 00:25:36,380
就像我的例子一样，我

680
00:25:36,380 --> 00:25:38,150
把它拍得很好，就像我展示了前缀

681
00:25:38,150 --> 00:25:40,070
一样确定我可以存储的哈希值可能

682
00:25:40,070 --> 00:25:41,600
在那里，所以我正在寻找

683
00:25:41,600 --> 00:25:43,370
特定大小的东西是的，

684
00:25:43,370 --> 00:25:45,190
我存储的东西 你想要

685
00:25:45,190 --> 00:25:47,750
击败的你可能会实现

686
00:25:47,750 --> 00:25:49,820
昂贵的物化条形字符

687
00:25:49,820 --> 00:25:52,100
我可以对这些东西做的任何操作都

688
00:25:52,100 --> 00:25:54,800
需要你的超快的单一属性，

689
00:25:54,800 --> 00:25:57,110
就像你说的

690
00:25:57,110 --> 00:25:58,400
好，也许它们也是钉子

691
00:25:58,400 --> 00:26:01,309
储存得很好我 意思是，如果

692
00:26:01,309 --> 00:26:02,960


693
00:26:02,960 --> 00:26:05,750
你需要那一点来存储一些

694
00:26:05,750 --> 00:26:09,710
可能为空的东西，比如说我有点

695
00:26:09,710 --> 00:26:11,929
像这样愚蠢，就像

696
00:26:11,929 --> 00:26:13,610
否定

697
00:26:13,610 --> 00:26:15,800
某些东西的绝对值一样愚蠢 那' 计算成本很便宜，

698
00:26:15,800 --> 00:26:18,140
这是一些指令，但

699
00:26:18,140 --> 00:26:19,460
无论如何我都可以将其存储在其中，

700
00:26:19,460 --> 00:26:20,570
因为我仍然需要将其存储在

701
00:26:20,570 --> 00:26:22,700
所有标志中，所以我不知道它们可以

702
00:26:22,700 --> 00:26:26,750
进行哪些预计算，并且

703
00:26:26,750 --> 00:26:29,780
现在一切都已对齐 我说过 MEMC 推出

704
00:26:29,780 --> 00:26:31,700
他们的专栏存储的新版本我

705
00:26:31,700 --> 00:26:32,900
应该仔细检查一下，看看他们是否

706
00:26:32,900 --> 00:26:35,450
像去年年底

707
00:26:35,450 --> 00:26:37,040
那样修复了这个问题，但我

708
00:26:37,040 --> 00:26:38,930
不知道他们是我知道的唯一一个

709
00:26:38,930 --> 00:26:40,730
它这样做或这样做 是的

710
00:26:40,730 --> 00:26:41,300


711
00:26:41,300 --> 00:26:46,040
哦，这些问题 什么是更好的

712
00:26:46,040 --> 00:26:49,640
类型以及为什么它是

713
00:26:49,640 --> 00:26:55,730
一个好

714
00:26:55,730 --> 00:26:58,250


715
00:26:58,250 --> 00:27:05,840
问题的 8 个字节 填充或

716
00:27:05,840 --> 00:27:15,860
可能是位图位续集类型位

717
00:27:15,860 --> 00:27:17,660
数据类型是整数数据类型，

718
00:27:17,660 --> 00:27:23,090
可以取值 0 1 或 null 看看

719
00:27:23,090 --> 00:27:26,890
进来的服务是一个字节，好吧 我

720
00:27:28,630 --> 00:27:32,150
不知道这是个好问题是因为

721
00:27:32,150 --> 00:27:34,700
Siebel 服务器得到 正如预期的那样扭曲

722
00:27:34,700 --> 00:27:37,510
好的让我们

723
00:27:37,510 --> 00:27:41,390
稍后再看 s 是最常见的，

724
00:27:41,390 --> 00:27:42,890
这就是我们现在所做的，

725
00:27:42,890 --> 00:27:45,110
我们现在可以在位图上做一些其他优化，

726
00:27:45,110 --> 00:27:48,260
因为一切都是连续的，

727
00:27:48,260 --> 00:27:50,630
就像我说的是试图找到我所有

728
00:27:50,630 --> 00:27:53,600
的 Fahmy 所有元组，其中该

729
00:27:53,600 --> 00:27:55,940
值为空然后

730
00:27:55,940 --> 00:27:58,550
如果它存储为列存储，我可以只使用这个位图，

731
00:27:58,550 --> 00:28:00,440
所以所有用于单个属性我

732
00:28:00,440 --> 00:28:02,150
有一个位图并且所有连续

733
00:28:02,150 --> 00:28:04,100
，现在你喜欢 Simbi 操作或

734
00:28:04,100 --> 00:28:05,510
矢量化操作来更快地进行计数和

735
00:28:05,510 --> 00:28:06,980
其他事情

736
00:28:06,980 --> 00:28:08,330
这两个家伙你必须

737
00:28:08,330 --> 00:28:09,820
仍然看的一切 看看属性

738
00:28:09,820 --> 00:28:10,970
ok

739
00:28:10,970 --> 00:28:13,760
所以现在让我们了解

740
00:28:13,760 --> 00:28:15,590
为什么他们必须正确填充的更深层次原因

741
00:28:15,590 --> 00:28:17,720
，他已经有点设置

742
00:28:17,720 --> 00:28:19,430
正确，因为它是因为对齐

743
00:28:19,430 --> 00:28:20,780
问题，因为你可以'  t 访问

744
00:28:20,780 --> 00:28:22,880
像你知道时髦的东西你知道 33 位

745
00:28:22,880 --> 00:28:26,360
偏移，所以我现在要

746
00:28:26,360 --> 00:28:29,990
描述的是我

747
00:28:29,990 --> 00:28:32,210
在我们的数据库中为我们的元组做缓存行字对齐，

748
00:28:32,210 --> 00:28:34,010
但我实际上要告诉你

749
00:28:34,010 --> 00:28:37,220
这个 ar 使用 64 位

750
00:28:37,220 --> 00:28:40,400
作品或 64 位缓存线和真正的

751
00:28:40,400 --> 00:28:44,570
x86 的示例，缓存线是 64 字节，但为了

752
00:28:44,570 --> 00:28:46,040
简单起见，使所有内容都适合

753
00:28:46,040 --> 00:28:48,080
幻灯片，我将使用 64 位作为

754
00:28:48,080 --> 00:28:48,870
示例，

755
00:28:48,870 --> 00:28:50,789
只需了解高级警察

756
00:28:50,789 --> 00:28:53,429
是一样的

757
00:28:53,429 --> 00:28:55,010
，缓存行的长度会有所不同，

758
00:28:55,010 --> 00:28:57,720
假设现在我在这里有一个表，

759
00:28:57,720 --> 00:29:00,059
我有四个属性，一个时间戳，一个

760
00:29:00,059 --> 00:29:03,539
字符二和一个，以及一个邮政编码，在

761
00:29:03,539 --> 00:29:05,549
char 与 varchar 的情况下 '有些

762
00:29:05,549 --> 00:29:07,320
系统实际上会存储 varchar'

763
00:29:07,320 --> 00:29:09,330
，其中一些系统会将图表存储

764
00:29:09,330 --> 00:29:11,669
为常规条形字符，但实际上，

765
00:29:11,669 --> 00:29:13,470
如果您说得好，我知道只能是

766
00:29:13,470 --> 00:29:16,770
两个字节，那么您将其完全存储

767
00:29:16,770 --> 00:29:18,600
在固定长度的数据池中 固定

768
00:29:18,600 --> 00:29:21,210
长度的元组插槽，所以这里是

769
00:29:21,210 --> 00:29:23,070
我们的对齐方式，我们假设我们有 64 个

770
00:29:23,070 --> 00:29:26,159
64 位的字，所以现在当我开始

771
00:29:26,159 --> 00:29:30,480
将这些数据写入我们的元组时，

772
00:29:30,480 --> 00:29:34,980
将 IDS 32 位写入时间戳为 64 位，

773
00:29:34,980 --> 00:29:37,919
则此颜色为 2 字节或 16 位

774
00:29:37,919 --> 00:29:41,640
然后我现在邮政编码

775
00:29:41,640 --> 00:29:43,260
假设我做了一个查询 我想

776
00:29:43,260 --> 00:29:46,409
再次查找日期字段 我做我的

777
00:29:46,409 --> 00:29:48,450
算术 我知道架构是

778
00:29:48,450 --> 00:29:49,710
什么 所以我知道这些

779
00:29:49,710 --> 00:29:51,210
属性的大小 我知道如何做

780
00:29:51,210 --> 00:29:53,429
简单的数学来跳转到我的 偏移量，现在

781
00:29:53,429 --> 00:29:56,779
读取这个但是这里

782
00:29:56,779 --> 00:29:59,370
会发生什么如果我的处理器读取的

783
00:29:59,370 --> 00:30:04,559
东西不是字对齐的会发生

784
00:30:04,559 --> 00:30:06,120
什么他说他说将整个

785
00:30:06,120 --> 00:30:09,870
缓存行带到缓存读取那是 1

786
00:30:09,870 --> 00:30:16,830
它还能做什么所以他说是的所以

787
00:30:16,830 --> 00:30:18,390
这是 还有一个我们不打算

788
00:30:18,390 --> 00:30:19,559
讨论的问题，他说其他人

789
00:30:19,559 --> 00:30:22,950
可以进来写信给另一

790
00:30:22,950 --> 00:30:26,159
半，我只看到前半部分让我们

791
00:30:26,159 --> 00:30:28,020
假设我们有

792
00:30:28,020 --> 00:30:29,760
高于此的交易保护，否则

793
00:30:29,760 --> 00:30:30,120
不会有问题

794
00:30:30,120 --> 00:30:34,080
对作家不，不，所以

795
00:30:34,080 --> 00:30:35,130
实际上可能会发生三件事，

796
00:30:35,130 --> 00:30:38,100
所以他们把第一个做对了，

797
00:30:38,100 --> 00:30:39,539
这实际上是 x86 将要做的，而

798
00:30:39,539 --> 00:30:42,330
新版本的武装将这样做，因此

799
00:30:42,330 --> 00:30:44,429
在他们的世界中，他们使用 x86

800
00:30:44,429 --> 00:30:46,110
试图让您成为 程序员的生活一样

801
00:30:46,110 --> 00:30:49,169
简单 可能所以如果您尝试读取

802
00:30:49,169 --> 00:30:50,220
未对齐的内容，

803
00:30:50,220 --> 00:30:52,799
他们会为您进行多次读取

804
00:30:52,799 --> 00:30:55,559
，然后将值重新

805
00:30:55,559 --> 00:30:56,580
拼接在一起，然后将其交还给我们的

806
00:30:56,580 --> 00:30:58,350
程序，正如我们所说的那样，这

807
00:30:58,350 --> 00:30:59,549
会很慢，因为应该怎么做

808
00:30:59,549 --> 00:31:02,150
已经只是一次读入内存，

809
00:31:02,150 --> 00:31:04,250
或者你知道我们的 CPU 缓存

810
00:31:04,250 --> 00:31:06,860
现在将是两次读取，所以我们将

811
00:31:06,860 --> 00:31:08,030
带来一个我们

812
00:31:08,030 --> 00:31:09,020
实际上不需要的有机包装，就像我们只

813
00:31:09,020 --> 00:31:12,020
需要获取这个日期字段一样 租金

814
00:31:12,020 --> 00:31:13,370
我们将不得不引入这个 ID

815
00:31:13,370 --> 00:31:16,730
字段和你知道的

816
00:31:16,730 --> 00:31:19,130
邮政编码部分和这个字符数组，

817
00:31:19,130 --> 00:31:21,800
即使我们只想要那些 32

818
00:31:21,800 --> 00:31:24,680
位，所以我们将读取 128 位只是

819
00:31:24,680 --> 00:31:27,380
为了正确读取 32 位 这很糟糕，我们

820
00:31:27,380 --> 00:31:30,230
不想这样做，所以对于这个

821
00:31:30,230 --> 00:31:33,500
你表现不佳的人，你可以告诉它

822
00:31:33,500 --> 00:31:36,230
一个事件，你可以记录我们的未对齐

823
00:31:36,230 --> 00:31:38,780
访问，实际上我们

824
00:31:38,780 --> 00:31:40,790
在运行我们的测试时使用来自 Google 的 ACN 内容

825
00:31:40,790 --> 00:31:43,100
运行 在这种情况下，如果您执行

826
00:31:43,100 --> 00:31:45,830
未对齐的内存访问，就像它会

827
00:31:45,830 --> 00:31:47,030
通过 w 一个错误并说你不能这样做，

828
00:31:47,030 --> 00:31:48,530
但你也使用 perf 来获取一个二进制文件

829
00:31:48,530 --> 00:31:49,730
并运行它并计算

830
00:31:49,730 --> 00:31:51,710
你拥有的在线访问次数，这

831
00:31:51,710 --> 00:31:52,970
可以帮助解释为什么你的程序

832
00:31:52,970 --> 00:31:54,800
运行缓慢 Colegrinds 不会给

833
00:31:54,800 --> 00:31:56,090
你 因为 Paul Ryan 只看到

834
00:31:56,090 --> 00:31:57,950
你

835
00:31:57,950 --> 00:31:59,780
正确执行的指令和哪些代码行

836
00:31:59,780 --> 00:32:01,670
不会告诉你像哈佛

837
00:32:01,670 --> 00:32:05,030
实际上做了什么，另一种方法

838
00:32:05,030 --> 00:32:08,360
是做随机珠子基本上你

839
00:32:08,360 --> 00:32:10,210
会得到一些随机组合

840
00:32:10,210 --> 00:32:14,510
数据，你在程序中

841
00:32:14,510 --> 00:32:15,980
自己解决这个问题，

842
00:32:15,980 --> 00:32:17,480
这显然比这更快，

843
00:32:17,480 --> 00:32:19,100
这也更容易在实际芯片上进行设计，

844
00:32:19,100 --> 00:32:20,060
因为你没有做

845
00:32:20,060 --> 00:32:22,370
额外的事情来重新组装

846
00:32:22,370 --> 00:32:24,470
东西 arm 过去常常这样做

847
00:32:24,470 --> 00:32:27,050
他们现在这样做是对的

848
00:32:27,050 --> 00:32:28,370
当然这是有问题的 现在

849
00:32:28,370 --> 00:32:29,420
你读了一遍 你认为你得到了

850
00:32:29,420 --> 00:32:31,790
一些你认为你得到的东西 你

851
00:32:31,790 --> 00:32:32,990
得到了一个你得到的领域

852
00:32:32,990 --> 00:32:34,420
一堆其他克拉

853
00:32:34,420 --> 00:32:37,910
p 另一种选择是实际上

854
00:32:37,910 --> 00:32:43,010
只是拒绝请求，就像您

855
00:32:43,010 --> 00:32:44,060
尝试阅读不是字

856
00:32:44,060 --> 00:32:46,130
对齐的内容一样，我们实际上拒绝加载

857
00:32:46,130 --> 00:32:49,930
操作，并且我们返回错误如此

858
00:32:49,930 --> 00:32:53,480
正确，所以再次现代现代 CPU 或非现代 CPU

859
00:32:53,480 --> 00:32:55,130
更常见

860
00:32:55,130 --> 00:32:56,240
你将在野外遇到的 CPU

861
00:32:56,240 --> 00:33:00,530
会这样做 我不知道实际上是谁在这样做 这

862
00:33:00,530 --> 00:33:02,690


863
00:33:02,690 --> 00:33:04,880
主要是像一个超小型嵌入式

864
00:33:04,880 --> 00:33:07,570
设备，比如低功耗的东西，

865
00:33:07,570 --> 00:33:11,180
这又像你可能不会构建

866
00:33:11,180 --> 00:33:12,500
一个完整的 - 成熟的数据库不

867
00:33:12,500 --> 00:33:13,970
会这样做，你实际上是续集 lightwood perp

868
00:33:13,970 --> 00:33:15,389
我已经运行了所有这些家伙

869
00:33:15,389 --> 00:33:16,739
，当然他们已经

870
00:33:16,739 --> 00:33:18,929
检查过我这些东西，所以这是

871
00:33:18,929 --> 00:33:20,999
我们在我们的世界中关心的，所以我们

872
00:33:20,999 --> 00:33:22,169
显然没有 想要做对，

873
00:33:22,169 --> 00:33:23,369
因为这会很慢，所以我们需要一种

874
00:33:23,369 --> 00:33:25,889
方法来解决这个问题，所以我们怎样才能让

875
00:33:25,889 --> 00:33:29,579
我们的东西字对齐，什么是简单的

876
00:33:29,579 --> 00:33:31,009
修复

877
00:33:31,009 --> 00:33:34,019
Patti 是的，所以我们将在这里做的

878
00:33:34,019 --> 00:33:36,269
是我们很快就会在我们的数据中知道 我们

879
00:33:36,269 --> 00:33:37,950
知道alignme这个词 nt 用于

880
00:33:37,950 --> 00:33:39,599
我们正在运行的港口，所以当我们

881
00:33:39,599 --> 00:33:41,519
现在开始为我们的元组布置数据时，

882
00:33:41,519 --> 00:33:44,729
我们会识别哦，好吧，我可以

883
00:33:44,729 --> 00:33:46,919
存储它 64 位字 这个人是 32

884
00:33:46,919 --> 00:33:48,809
位 这个下一个是 64 位

885
00:33:48,809 --> 00:33:50,159
所以而不是 跨越单词

886
00:33:50,159 --> 00:33:52,499
边界 我只需要

887
00:33:52,499 --> 00:33:54,629
为这 32 位输入一堆零以将其取出，

888
00:33:54,629 --> 00:33:56,549
以便下一个属性

889
00:33:56,549 --> 00:33:58,289
正好在下一个单词的开头开始

890
00:33:58,289 --> 00:34:02,969
，所以现在在

891
00:34:02,969 --> 00:34:05,070
系统的上层 取决于

892
00:34:05,070 --> 00:34:06,899
您如何将数据返回给执行

893
00:34:06,899 --> 00:34:09,719
引擎，您可以存储管理器

894
00:34:09,719 --> 00:34:11,668
可以说好吧，您需要这些

895
00:34:11,668 --> 00:34:13,018
字段

896
00:34:13,018 --> 00:34:14,849


897
00:34:14,849 --> 00:34:16,168


898
00:34:16,168 --> 00:34:19,829
它返回给您，或者您

899
00:34:19,829 --> 00:34:21,029
现在必须在执行中

900
00:34:21,029 --> 00:34:23,190
了解正在发生的填充和您的

901
00:34:23,190 --> 00:34:25,168
存储管理器，以便您知道

902
00:34:25,168 --> 00:34:27,329
何时需要跳转到客户日期

903
00:34:27,329 --> 00:34:29,279
字段，您必须跳过

904
00:34:29,279 --> 00:34:32,599
这 32 位 只是填充

905
00:34:32,599 --> 00:34:37,710
我们的另一件事是什么 可以做完美的

906
00:34:37,710 --> 00:34:38,879
重新排序，这是另一个是的，

907
00:34:38,879 --> 00:34:43,168
所以我们基本上也可以

908
00:34:43,168 --> 00:34:44,339
在打包问题中运行与出租车相同的事情

909
00:34:44,339 --> 00:34:49,049
，我们说我有 32 位我可以

910
00:34:49,049 --> 00:34:51,149
在这里存储来填写我的词，而不是

911
00:34:51,149 --> 00:34:52,440
实际上只是将东西存储在

912
00:34:52,440 --> 00:34:53,759
在我创建表时定义它们的顺序是否

913
00:34:53,759 --> 00:34:55,980
可以找到

914
00:34:55,980 --> 00:34:58,140
另一个 32 位的东西或 32 位属性

915
00:34:58,140 --> 00:35:01,049
并将其粘贴在那里，然后现在我

916
00:35:01,049 --> 00:35:03,000
可以打包其余的东西，只有在这里我

917
00:35:03,000 --> 00:35:04,650
必须把它拍出来以确保

918
00:35:04,650 --> 00:35:06,420
我身后的下一个人遵循

919
00:35:06,420 --> 00:35:10,559
单词的右边界，所以

920
00:35:10,559 --> 00:35:12,059
再次系统的上层

921
00:35:12,059 --> 00:35:14,490
需要意识到这个填充

922
00:35:14,490 --> 00:35:17,099
正在进行，或者你需要做一些复制

923
00:35:17,099 --> 00:35:19,980
来隐藏它，所以我们

924
00:35:19,980 --> 00:35:21,839
实际上 今天在我们当前的系统中做这两件事

925
00:35:21,839 --> 00:35:24,420
，所以只是给你一个想法

926
00:35:24,420 --> 00:35:26,279
并证明你可以得到所以这是一个

927
00:35:26,279 --> 00:35:27,960
微基准，

928
00:35:27,960 --> 00:35:29,190


929
00:35:29,190 --> 00:35:32,069
两个夏天前帮助完成新版本系统的学生之一

930
00:35:32,069 --> 00:35:34,109
这是第一个含义 我们

931
00:35:34,109 --> 00:35:35,849
曾经做过 没有任何对齐，所以

932
00:35:35,849 --> 00:35:38,339
这只是做

933
00:35:38,339 --> 00:35:39,750
一个尝试尽可能快地插入的微基准测试

934
00:35:39,750 --> 00:35:41,970
，所以如果你不做任何

935
00:35:41,970 --> 00:35:44,430
对齐，那么你可以

936
00:35:44,430 --> 00:35:45,810
每秒运行四百兆字节，你

937
00:35:45,810 --> 00:35:47,940
插入四百兆字节的 数据，或者

938
00:35:47,940 --> 00:35:49,710
如果我想每秒生成大约两个数据

939
00:35:49,710 --> 00:35:53,220
不抱歉，不要后悔 500

940
00:35:53,220 --> 00:35:56,069
KB 是的，但是如果您进行

941
00:35:56,069 --> 00:35:58,470
填充，则每秒会增加 11

942
00:35:58,470 --> 00:36:00,210
兆字节，但是如果您

943
00:36:00,210 --> 00:36:03,300
现在填充和排序，一切都很好地

944
00:36:03,300 --> 00:36:05,460
缓存对齐，您 甚至可以

945
00:36:05,460 --> 00:36:07,260
以非常高的速度插入，所以

946
00:36:07,260 --> 00:36:09,270
我们将东西插入内存的速度有多快还

947
00:36:09,270 --> 00:36:10,920
没有准备好，而任何日志都

948
00:36:10,920 --> 00:36:12,839
像这样记录了磁盘，只是表明你

949
00:36:12,839 --> 00:36:13,980
知道性能本优势

950
00:36:13,980 --> 00:36:15,599
你从中得到了什么我不知道 认为我们有

951
00:36:15,599 --> 00:36:17,849
数字表明您很清楚

952
00:36:17,849 --> 00:36:20,069
哪种排序为您提供我们只有

953
00:36:20,069 --> 00:36:22,650
填充加排序所以在

954
00:36:22,650 --> 00:36:23,819
我们当前的系统中发生的事情是当您

955
00:36:23,819 --> 00:36:25,410
再次创建表时我们运行了这个

956
00:36:25,410 --> 00:36:26,609
小算法 es 基本上

957
00:36:26,609 --> 00:36:30,690
试图找出

958
00:36:30,690 --> 00:36:33,839
系统中列的最佳排序执行

959
00:36:33,839 --> 00:36:36,000
引擎知道这些这个排序

960
00:36:36,000 --> 00:36:37,200
这是投影列的东西

961
00:36:37,200 --> 00:36:39,180
给你的但是然后在我们

962
00:36:39,180 --> 00:36:42,060
将结果返回给应用程序之前我们

963
00:36:42,060 --> 00:36:43,619
确保我们把 它

964
00:36:43,619 --> 00:36:46,079
按照这个

965
00:36:46,079 --> 00:36:48,750
伟大的表格语句指定的正确顺序返回我认为续集

966
00:36:48,750 --> 00:36:49,980
标准指定你必须这样

967
00:36:49,980 --> 00:36:51,990
做我现在说如果有人调用 select

968
00:36:51,990 --> 00:36:54,480
star 他们将获得元组

969
00:36:54,480 --> 00:36:56,040
每个元组的属性按照

970
00:36:56,040 --> 00:36:59,190
他们在此处定义的顺序排序 因为当人们知道他们拥有这些精选的明星球员时，

971
00:36:59,190 --> 00:37:00,359
会发生很多次人们编写

972
00:37:00,359 --> 00:37:02,460
他们的应用程序

973
00:37:02,460 --> 00:37:03,750
，

974
00:37:03,750 --> 00:37:06,030
然后当他们访问属性时，

975
00:37:06,030 --> 00:37:07,829
他们会根据偏移量访问它们，例如给

976
00:37:07,829 --> 00:37:08,910
我第一个，第二个，

977
00:37:08,910 --> 00:37:10,740
第三个，所以如果我现在开始 洗牌

978
00:37:10,740 --> 00:37:12,390
订购这些东西因为我运行了一些

979
00:37:12,390 --> 00:37:14,220
装箱算法然后这会

980
00:37:14,220 --> 00:37:16,829
破坏程序所以我们做了一个额外的步骤来

981
00:37:16,829 --> 00:37:20,400
让最终用户的生活更轻松所以

982
00:37:20,400 --> 00:37:25,349
关于这个的任何问题现在

983
00:37:25,349 --> 00:37:28,819
让我们谈谈存储模型，因此

984
00:37:28,819 --> 00:37:32,520
存储模型指定

985
00:37:32,520 --> 00:37:33,660
数据库分钟系统将如何

986
00:37:33,660 --> 00:37:37,220


987
00:37:37,220 --> 00:37:40,560
在存储内部组织元组及其属性，因此有

988
00:37:40,560 --> 00:37:42,530
两种主要方法

989
00:37:42,530 --> 00:37:45,170
是能量存储模型 和

990
00:37:45,170 --> 00:37:47,240
分解模型 所以这是行

991
00:37:47,240 --> 00:37:50,090
存储 这是列存储 然后

992
00:37:50,090 --> 00:37:51,050
有一种混合方法，我们将

993
00:37:51,050 --> 00:37:52,310
稍微讨论一下，您

994
00:37:52,310 --> 00:37:53,360
试图

995
00:37:53,360 --> 00:37:57,100
在一个统一的系统中获得两全其美

996
00:37:57,100 --> 00:37:59,630
当我们谈论数据库或关系数据库

997
00:37:59,630 --> 00:38:01,220
时，人们通常会想到行存储和 saml 方法，

998
00:38:01,220 --> 00:38:03,650


999
00:38:03,650 --> 00:38:06,050


1000
00:38:06,050 --> 00:38:07,760
这里的想法就像我在

1001
00:38:07,760 --> 00:38:10,250
迄今为止展示的所有示例中所做的那样，但

1002
00:38:10,250 --> 00:38:13,210
单个元组的所有属性都将是

1003
00:38:13,210 --> 00:38:16,220
连续存储在内存的某个区域中

1004
00:38:16,220 --> 00:38:18,200
，然后只有当我们到达

1005
00:38:18,200 --> 00:38:20,030
最后一个属性时，然后下一个

1006
00:38:20,030 --> 00:38:23,300
三元组才会开始，如果我

1007
00:38:23,300 --> 00:38:25,850
想访问第三个属性，现在再次开始 对于

1008
00:38:25,850 --> 00:38:28,180
第五个元组，我知道如何进行

1009
00:38:28,180 --> 00:38:30,830
地址算术以跳转到

1010
00:38:30,830 --> 00:38:32,330
该元组起始点的偏移量，

1011
00:38:32,330 --> 00:38:36,650
然后跳转到该属性，因此该

1012
00:38:36,650 --> 00:38:40,310
存储模型非常适合事务性

1013
00:38:40,310 --> 00:38:41,570
工作负载，它们都是 XP 工作负载，

1014
00:38:41,570 --> 00:38:44,600
因为在这些中 在环境中，

1015
00:38:44,600 --> 00:38:47,870
事务或查询仅

1016
00:38:47,870 --> 00:38:50,090
涉及少量元组，它们

1017
00:38:50,090 --> 00:38:51,590
通常还会涉及

1018
00:38:51,590 --> 00:38:53,780
元组的所有属性，有很多

1019
00:38:53,780 --> 00:38:55,580
选择星查询，其中帐户名

1020
00:38:55,580 --> 00:38:57,830
Eagles Andy 和我想要所有

1021
00:38:57,830 --> 00:38:59,510
属性，因此如果它被存储

1022
00:38:59,510 --> 00:39:01,640
作为烤肉，或者我可以跳到

1023
00:39:01,640 --> 00:39:03,830
那个区域或内存扫描并获得

1024
00:39:03,830 --> 00:39:05,060
我需要的所有答案，然后

1025
00:39:05,060 --> 00:39:07,190
将其交还给执行或任何

1026
00:39:07,190 --> 00:39:09,590
其他需要它的人，这也是您

1027
00:39:09,590 --> 00:39:10,820
通常要使用的地方 一次元组

1028
00:39:10,820 --> 00:39:13,100
迭代器模型，我们将

1029
00:39:13,100 --> 00:39:14,300
在几周内对此进行更多讨论，但

1030
00:39:14,300 --> 00:39:15,800
基本上我们将如何让

1031
00:39:15,800 --> 00:39:18,860
执行引擎访问池，这种

1032
00:39:18,860 --> 00:39:20,660
方法是理想的，因为我再次

1033
00:39:20,660 --> 00:39:22,520
跳入 g 到每个元组的起始位置

1034
00:39:22,520 --> 00:39:24,140
并将

1035
00:39:24,140 --> 00:39:26,840
那块内存交还给任何操作执行或

1036
00:39:26,840 --> 00:39:29,360
整洁需要它，这也

1037
00:39:29,360 --> 00:39:30,380
可能非常适合插入繁重的

1038
00:39:30,380 --> 00:39:32,480
工作负载，这是更多的公司，

1039
00:39:32,480 --> 00:39:33,890
你知道你看到了很多

1040
00:39:33,890 --> 00:39:35,450
事务性工作负载，例如

1041
00:39:35,450 --> 00:39:36,950
每次登录时我都插入一条新

1042
00:39:36,950 --> 00:39:38,210
记录来说明这是

1043
00:39:38,210 --> 00:39:40,010
每次我在 Amazon 下新订单时此人登录的时间

1044
00:39:40,010 --> 00:39:42,260
我插入新订单记录 我

1045
00:39:42,260 --> 00:39:44,840
将我购买的所有商品插入

1046
00:39:44,840 --> 00:39:46,820
到 行存储这是

1047
00:39:46,820 --> 00:39:48,620
超快的，因为我可以跳转到某个

1048
00:39:48,620 --> 00:39:50,030
内存位置

1049
00:39:50,030 --> 00:39:51,710
，我的表中有一些空闲插槽，并且

1050
00:39:51,710 --> 00:39:55,060
所有属性都是连续的，

1051
00:39:55,160 --> 00:39:57,250
所以我在复仇开始之前已经说过的所有内容都可以

1052
00:39:57,250 --> 00:39:59,450
快速插入和

1053
00:39:59,450 --> 00:40:00,590
更新删除 对于查询，他们

1054
00:40:00,590 --> 00:40:03,650
需要整个表，我们现在可以忽略这个表

1055
00:40:03,650 --> 00:40:06,200
，但是

1056
00:40:06,200 --> 00:40:07,490
当您执行

1057
00:40:07,490 --> 00:40:09,290
分析工作负载时要

1058
00:40:09,290 --> 00:40:12,440
扫描表的大段时，这会出现问题 并且您

1059
00:40:12,440 --> 00:40:14,350
只需要属性的一个子集，

1060
00:40:14,350 --> 00:40:16,580
例如如果我想计算从匹兹堡市的任何人那里购买

1061
00:40:16,580 --> 00:40:20,000
的物品的最高平均价格是多少

1062
00:40:20,000 --> 00:40:21,830


1063
00:40:21,830 --> 00:40:23,750
我只需要

1064
00:40:23,750 --> 00:40:25,580
访问您就知道城市字段和

1065
00:40:25,580 --> 00:40:28,550
价格 他们买了一些东西，因为

1066
00:40:28,550 --> 00:40:30,020
我不需要

1067
00:40:30,020 --> 00:40:32,600
那个元组的所有其他属性，所以如果我正在

1068
00:40:32,600 --> 00:40:35,060
做烤肉或者那是我的浪费，

1069
00:40:35,060 --> 00:40:36,350
因为我反应

1070
00:40:36,350 --> 00:40:37,730
了我实际上不需要的内存块 我

1071
00:40:37,730 --> 00:40:38,930
必须一遍又一遍地跳来跳去

1072
00:40:38,930 --> 00:40:41,090
为每个元组找到我想要的萎缩的正确偏移量，

1073
00:40:41,090 --> 00:40:43,520
所以这是

1074
00:40:43,520 --> 00:40:45,020
使用列存储或 DSM

1075
00:40:45,020 --> 00:40:47,420
方法解决的想法是，

1076
00:40:47,420 --> 00:40:49,940
对于元组中的单个属性和

1077
00:40:49,940 --> 00:40:53,690
我们将

1078
00:40:53,690 --> 00:40:55,760
在内存中连续存储每个单个元组的所有值，

1079
00:40:55,760 --> 00:40:59,210
现在我可能不是因为你

1080
00:40:59,210 --> 00:41:00,710
知道整个数据块它可能

1081
00:41:00,710 --> 00:41:03,740
没有所有

1082
00:41:03,740 --> 00:41:04,970
的那个单一属性的 B 值我们可以拥有

1083
00:41:04,970 --> 00:41:06,860
所有 atras 在一起，但相互 最后

1084
00:41:06,860 --> 00:41:08,360
但总是当我们将它存储为列

1085
00:41:08,360 --> 00:41:08,890
存储时，

1086
00:41:08,890 --> 00:41:11,180
这对于只读查询非常有用，

1087
00:41:11,180 --> 00:41:12,800
因为您可以一次扫描

1088
00:41:12,800 --> 00:41:15,890
表的大部分，但只能

1089
00:41:15,890 --> 00:41:17,860
访问属性的子集，

1090
00:41:17,860 --> 00:41:19,610
所以这就是我们的东西

1091
00:41:19,610 --> 00:41:21,230
已经涵盖了，所以我们将

1092
00:41:21,230 --> 00:41:22,670
通过

1093
00:41:22,670 --> 00:41:26,750
我们将在周三涵盖的列存储获得更好的压缩，对于四

1094
00:41:26,750 --> 00:41:28,250
点查询和更新，这

1095
00:41:28,250 --> 00:41:29,630
可能现在变得更加昂贵，因为

1096
00:41:29,630 --> 00:41:32,750
现在您必须获取需要插入的元组

1097
00:41:32,750 --> 00:41:34,550
或 更新并将

1098
00:41:34,550 --> 00:41:35,720
其分解为单独的属性，

1099
00:41:35,720 --> 00:41:38,030
并执行多个内存权限以更新

1100
00:41:38,030 --> 00:41:42,110
所有完成的操作，因此列

1101
00:41:42,110 --> 00:41:45,140
存储的历史很有趣，因此列

1102
00:41:45,140 --> 00:41:47,840
存储现在非常普遍，任何

1103
00:41:47,840 --> 00:41:48,950


1104
00:41:48,950 --> 00:41:50,810
在过去十年中开发和发布的新 OLAP 系统 在

1105
00:41:50,810 --> 00:41:53,600
过去的十年中，

1106
00:41:53,600 --> 00:41:55,820
如果他们不在那里，他们将使用专栏商店，他们不

1107
00:41:55,820 --> 00:41:56,750
知道自己在做什么，而且不

1108
00:41:56,750 --> 00:41:58,040
值得花时间与那个主要人物交谈，

1109
00:41:58,040 --> 00:42:01,100
但它知道什么看起来如此

1110
00:42:01,100 --> 00:42:03,410
现在的情况并不总是如此，

1111
00:42:03,410 --> 00:42:06,440
所以早在 1970 年代，列存储系统

1112
00:42:06,440 --> 00:42:08,180
的已知含义

1113
00:42:08,180 --> 00:42:08,940


1114
00:42:08,940 --> 00:42:10,829
是来自瑞典国防部门的名为 Kanter 的东西，

1115
00:42:10,829 --> 00:42:12,810
它

1116
00:42:12,810 --> 00:42:15,180
实际上并不是我们所知道的数据库系统

1117
00:42:15,180 --> 00:42:16,500
今天更像是这种

1118
00:42:16,500 --> 00:42:18,270
蝙蝠处理系统，但

1119
00:42:18,270 --> 00:42:21,210
在 1980 年代将数据组织成列，

1120
00:42:21,210 --> 00:42:22,349
有一篇实际的论文

1121
00:42:22,349 --> 00:42:25,109
正式确定了 comstor

1122
00:42:25,109 --> 00:42:27,119
数据库的外观，但第

1123
00:42:27,119 --> 00:42:31,859
一种已知的邀请是 sybase IQ

1124
00:42:31,859 --> 00:42:33,390
它是 Sybase 的内存加速器

1125
00:42:33,390 --> 00:42:34,980
，其想法是您拥有

1126
00:42:34,980 --> 00:42:37,650
常规大小的 ASC 数据库系统，然后

1127
00:42:37,650 --> 00:42:38,910
您购买并排队列坐在

1128
00:42:38,910 --> 00:42:39,450
它前面，

1129
00:42:39,450 --> 00:42:41,280
因此如果出现分析查询，

1130
00:42:41,280 --> 00:42:43,470
它们将运行，它们将在该副本上运行

1131
00:42:43,470 --> 00:42:45,270
数据，所以他们使用了

1132
00:42:45,270 --> 00:42:46,650
所谓的断裂镜像方法，

1133
00:42:46,650 --> 00:42:47,970
我将在更多幻灯片中介绍这种方法，但

1134
00:42:47,970 --> 00:42:49,710
基本上你仍然有烤肉，或者

1135
00:42:49,710 --> 00:42:51,030
然后放在它前面的这个东西

1136
00:42:51,030 --> 00:42:52,290
进行了分析 所有的查询都变得更快了

1137
00:42:52,290 --> 00:42:54,359
我在 1990 年代听到过一些关于这件事的恐怖故事

1138
00:42:54,359 --> 00:42:56,040
，这很难说它

1139
00:42:56,040 --> 00:42:59,520
从来没有正常工作过，但

1140
00:42:59,520 --> 00:43:01,170
今天仍然如此，这

1141
00:43:01,170 --> 00:43:02,520
就是他们正在使用的，甚至

1142
00:43:02,520 --> 00:43:05,640
与 S AP Hannam 的连接 2000 年代，

1143
00:43:05,640 --> 00:43:06,750
这个共同的故事想法

1144
00:43:06,750 --> 00:43:08,819
在

1145
00:43:08,819 --> 00:43:11,099
垂直向量明智和 Monet DB 向量

1146
00:43:11,099 --> 00:43:13,260
明智是 Monet DB 的改进内存版本的空间中真正起飞了三个主要的，

1147
00:43:13,260 --> 00:43:15,810
后来被重命名

1148
00:43:15,810 --> 00:43:18,270
或被 Acton 收购，然后重命名为

1149
00:43:18,270 --> 00:43:19,920
向量和 它今天仍然存在，

1150
00:43:19,920 --> 00:43:21,150
如果你

1151
00:43:21,150 --> 00:43:23,300
对它进行基准测试，这实际上是太好了，它仍然非常好

1152
00:43:23,300 --> 00:43:25,589
，我们将在本学期稍后介绍的向量方面的某些方面

1153
00:43:25,589 --> 00:43:26,819


1154
00:43:26,819 --> 00:43:27,839


1155
00:43:27,839 --> 00:43:30,290
Monet DB 仍然是圆形的，它们

1156
00:43:30,290 --> 00:43:33,180
也是来自 CWI

1157
00:43:33,180 --> 00:43:36,990
BB 在这个领域的早期也喜欢这些家伙的同类学校

1158
00:43:36,990 --> 00:43:38,430
，就像我现在所说的

1159
00:43:38,430 --> 00:43:41,250
每个人都认识到

1160
00:43:41,250 --> 00:43:45,569
专栏商店的优势和广泛的

1161
00:43:45,569 --> 00:43:50,819
好吧 所以这篇论文让你们阅读了

1162
00:43:50,819 --> 00:43:51,900
我选择的原因 因为它在

1163
00:43:51,900 --> 00:43:54,300
某种程度上向您展示了如何

1164
00:43:54,300 --> 00:43:57,000
在列存储上进行更新和支持混合工作负载，

1165
00:43:57,000 --> 00:44:00,900
所以在我们的系统中，我们

1166
00:44:00,900 --> 00:44:02,430
仍然支持事务，我们仍然

1167
00:44:02,430 --> 00:44:05,160
支持进行更新

1168
00:44:05,160 --> 00:44:06,869
以及分析

1169
00:44:06,869 --> 00:44:08,490
操作，但我们旨在 成为一个

1170
00:44:08,490 --> 00:44:10,560
列存储，因此这篇特定的

1171
00:44:10,560 --> 00:44:12,930
论文或助理工作 Casper

1172
00:44:12,930 --> 00:44:16,140
旨在向您展示如何

1173
00:44:16,140 --> 00:44:17,430
仍然维护一个列存储并仍然

1174
00:44:17,430 --> 00:44:21,270
获得对 otx 执行的良好支持，因此

1175
00:44:21,270 --> 00:44:22,859
该论文讨论

1176
00:44:22,859 --> 00:44:24,539
了您需要做出的一些高级设计决策

1177
00:44:24,539 --> 00:44:26,099
当您

1178
00:44:26,099 --> 00:44:27,869
为系统构建列以进行

1179
00:44:27,869 --> 00:44:29,849
识别时，请注意如何

1180
00:44:29,849 --> 00:44:31,529
在固定长度的日期数组中查找元组您好，实际上

1181
00:44:31,529 --> 00:44:34,259
您将组织

1182
00:44:34,259 --> 00:44:35,910
存储在列中的数据，然后

1183
00:44:35,910 --> 00:44:37,920
是更新策略和缓冲区

1184
00:44:37,920 --> 00:44:39,479


1185
00:44:39,479 --> 00:44:41,130
当我们谈论 nbcc 时，我们已经稍微涵盖了这些位置，

1186
00:44:41,130 --> 00:44:42,719
如果您有

1187
00:44:42,719 --> 00:44:44,039
一家 delta 商店，您实际上在哪里

1188
00:44:44,039 --> 00:44:45,779
存储这些东西，那么基本上是时候了 zh 您

1189
00:44:45,779 --> 00:44:47,549
如何稍后如何应用它们，所以我想

1190
00:44:47,549 --> 00:44:50,959
专注于前两个，这也是

1191
00:44:50,959 --> 00:44:53,999
，然后我们将讨论如何

1192
00:44:53,999 --> 00:44:55,380
构建混合存储的不同方法，

1193
00:44:55,380 --> 00:44:56,789
其中有一个行支柱

1194
00:44:56,789 --> 00:44:58,949
和一个列 store 所以 Casper 是一个

1195
00:44:58,949 --> 00:45:01,019
支持事务的纯列存储，

1196
00:45:01,019 --> 00:45:02,900
但是我们将讨论诸如

1197
00:45:02,900 --> 00:45:05,339
用于将

1198
00:45:05,339 --> 00:45:08,759
烘焙机和列存储存储在一起的工厂镜像方法之类的事情，因此

1199
00:45:08,759 --> 00:45:10,019
我们要做的第一个问题是

1200
00:45:10,019 --> 00:45:11,189
弄清楚我们实际上将如何识别我们的

1201
00:45:11,189 --> 00:45:13,679
元组 或者我们如何再次到达属性的起始

1202
00:45:13,679 --> 00:45:15,869
位置我们

1203
00:45:15,869 --> 00:45:18,929
假设所有值都是固定

1204
00:45:18,929 --> 00:45:20,640
长度的 varchar 的东西

1205
00:45:20,640 --> 00:45:22,229
在每个链接的数据池中都被缩短但

1206
00:45:22,229 --> 00:45:23,759
至少指针本身将是固定

1207
00:45:23,759 --> 00:45:27,299
长度所以如果一切都是

1208
00:45:27,299 --> 00:45:29,249
相同的长度那么您

1209
00:45:29,249 --> 00:45:30,630
实际上不需要存储任何额外的发射

1210
00:45:30,630 --> 00:45:32,279
来识别您正在查看的元组，

1211
00:45:32,279 --> 00:45:34,559
只需使用您在内存中查看的位置的隐式偏移量

1212
00:45:34,559 --> 00:45:36,719
来表示

1213
00:45:36,719 --> 00:45:39,089
这是标识 对于元组，

1214
00:45:39,089 --> 00:45:42,420
如果我想要表中的第二个元组或第二个元

1215
00:45:42,420 --> 00:45:46,229
组，我知道

1216
00:45:46,229 --> 00:45:47,999
如何进行算术运算来清楚地说明

1217
00:45:47,999 --> 00:45:49,439
这些列中的每一个的类型是什么

1218
00:45:49,439 --> 00:45:52,469
，我想要这个位置，所以我知道

1219
00:45:52,469 --> 00:45:54,239
如何 将属性的大小

1220
00:45:54,239 --> 00:45:56,579
个人乘以我想要跳转到的起始位置

1221
00:45:56,579 --> 00:45:58,920
以获得该

1222
00:45:58,920 --> 00:46:01,170
元组的值，我可以

1223
00:46:01,170 --> 00:46:04,170
对某些系统中的所有其他列执行相同的操作，

1224
00:46:04,170 --> 00:46:06,449
但是他们不能这样做，所以他们不

1225
00:46:06,449 --> 00:46:08,130
想要 要做到这一点，相反，他们

1226
00:46:08,130 --> 00:46:10,229
实际上为您存储在列存储中的每个属性存储隐式或显式

1227
00:46:10,229 --> 00:46:13,140
元组标识符，

1228
00:46:13,140 --> 00:46:14,579


1229
00:46:14,579 --> 00:46:17,880
因此对于第一个人的列权利

1230
00:46:17,880 --> 00:46:19,289
，我将存储它是两个

1231
00:46:19,289 --> 00:46:20,309
pi D 和第二个元组

1232
00:46:20,309 --> 00:46:23,130
I 存储到 PI D 等等，

1233
00:46:23,130 --> 00:46:24,689
这就像一个列存储的混蛋版本，

1234
00:46:24,689 --> 00:46:25,890
因为您没有获得

1235
00:46:25,890 --> 00:46:28,499
执行固定

1236
00:46:28,499 --> 00:46:30,359
月份算术的所有优势，您只是在浪费它

1237
00:46:30,359 --> 00:46:33,109
来存储空间，是的，

1238
00:46:33,109 --> 00:46:35,190
这个问题是 办公室还是

1239
00:46:35,190 --> 00:46:37,680
修好了

1240
00:46:37,680 --> 00:46:42,150
我认为为什么如此，我认为 Oracle 过去常常这样做，

1241
00:46:42,150 --> 00:46:45,740
因为他们将

1242
00:46:45,740 --> 00:46:48,450
穷人的列存储嫁接到系统

1243
00:46:48,450 --> 00:46:50,160


1244
00:46:50,160 --> 00:46:52,710


1245
00:46:52,710 --> 00:46:54,690


1246
00:46:54,690 --> 00:46:56,250
中 较新

1247
00:46:56,250 --> 00:46:57,240
版本的 comp 商店他们不这样做

1248
00:46:57,240 --> 00:46:59,609
每个人都这样做但有些系统

1249
00:46:59,609 --> 00:47:02,940
实际上这样做但这是个坏主意

1250
00:47:02,940 --> 00:47:04,349
如果你有

1251
00:47:04,349 --> 00:47:08,480
固定长度的所有东西那么你不需要是

1252
00:47:09,950 --> 00:47:12,210
这个问题如果 你需要对你的列进行排序

1253
00:47:12,210 --> 00:47:14,039
你仍然需要这些 ID 我们

1254
00:47:14,039 --> 00:47:16,829
会在另外两张幻灯片中得到它 但是是的

1255
00:47:16,829 --> 00:47:23,250
，如果我对列进行排序 对不起，如果

1256
00:47:23,250 --> 00:47:27,569
我在这里对列进行排序 我可以只对

1257
00:47:27,569 --> 00:47:31,380
a 进行排序而不影响 BC 和 D 假设 您

1258
00:47:31,380 --> 00:47:32,819
有一种方法可以让给定的管

1259
00:47:32,819 --> 00:47:34,589
标识符跳转到

1260
00:47:34,589 --> 00:47:36,660
每列的确切偏移量 我认为这就是

1261
00:47:36,660 --> 00:47:39,950
Oracle 这样

1262
00:47:39,950 --> 00:47:42,329


1263
00:47:42,329 --> 00:47:44,039


1264
00:47:44,039 --> 00:47:46,740
做的原因 最近

1265
00:47:46,740 --> 00:47:48,900
这个米 在我的插图中，您

1266
00:47:48,900 --> 00:47:51,029
看到的是完全相同的元组，大多数

1267
00:47:51,029 --> 00:47:52,619
系统不会进行预排序，

1268
00:47:52,619 --> 00:47:56,460
但实际上

1269
00:47:56,460 --> 00:47:59,369
这是下一个主题，所以

1270
00:47:59,369 --> 00:48:00,420
下一个问题是我们如何实际

1271
00:48:00,420 --> 00:48:03,270
组织数据 当我们必须进行

1272
00:48:03,270 --> 00:48:06,690
更改或添加新条目时，最

1273
00:48:06,690 --> 00:48:08,970
常见的方法是执行插入顺序，因此

1274
00:48:08,970 --> 00:48:10,920
我们只需在块中找到任何空闲的插槽，

1275
00:48:10,920 --> 00:48:14,279
然后将

1276
00:48:14,279 --> 00:48:15,869
元组插入其中，这样就没有位置，

1277
00:48:15,869 --> 00:48:18,170
也没有顺序 属性

1278
00:48:18,170 --> 00:48:20,670
它只是一种随机的 它

1279
00:48:20,670 --> 00:48:22,319
不是你不一定总是

1280
00:48:22,319 --> 00:48:24,900
必须像

1281
00:48:24,900 --> 00:48:28,109
在我们的系统中从头到尾一样进入我们实际上我们

1282
00:48:28,109 --> 00:48:29,520
在位图中的随机位置上进行比较和交换

1283
00:48:29,520 --> 00:48:30,900
并尝试找到 第一个空闲

1284
00:48:30,900 --> 00:48:33,089
位置可能不是第一个空闲

1285
00:48:33,089 --> 00:48:36,450
插槽，但至少在这种情况下，您知道

1286
00:48:36,450 --> 00:48:38,190
您没有所有线程都

1287
00:48:38,190 --> 00:48:39,569
试图同时插入同一位置，

1288
00:48:39,569 --> 00:48:42,390
另一种方法是

1289
00:48:42,390 --> 00:48:44,339
他所指的时间 你和你一起

1290
00:48:44,339 --> 00:48:46,080
插管

1291
00:48:46,080 --> 00:48:49,860
进入基于某些排序方案的列，

1292
00:48:49,860 --> 00:48:52,590
它再次垂直

1293
00:48:52,590 --> 00:48:54,150
是最有名的执行此操作的列，

1294
00:48:54,150 --> 00:48:55,200
但这是有问题的，我们将

1295
00:48:55,200 --> 00:48:56,910
在下一张幻灯片中看到，因为如果现在我有

1296
00:48:56,910 --> 00:48:58,710
一堆显示并且我需要

1297
00:48:58,710 --> 00:49:00,510
强制执行该排序 我不想

1298
00:49:00,510 --> 00:49:01,770
支付每次都必须重新洗牌的惩罚，

1299
00:49:01,770 --> 00:49:03,180
因为那

1300
00:49:03,180 --> 00:49:05,520
会很昂贵，然后最后

1301
00:49:05,520 --> 00:49:08,010
一种方法来自 Kasper 论文，

1302
00:49:08,010 --> 00:49:10,920
您将根据某些分区方案将块分解为

1303
00:49:10,920 --> 00:49:13,290
范围

1304
00:49:13,290 --> 00:49:16,470
然后在每个

1305
00:49:16,470 --> 00:49:18,480
块内，它不需要排序，但

1306
00:49:18,480 --> 00:49:20,310
在全局范围内，这就是他们

1307
00:49:20,310 --> 00:49:21,990
所谓的浅索引，请让我跳转

1308
00:49:21,990 --> 00:49:24,900
到

1309
00:49:24,900 --> 00:49:26,370
包含您在特定范围内查找的数据的位置，

1310
00:49:26,370 --> 00:49:28,470
让我们看看 在

1311
00:49:28,470 --> 00:49:29,940
第一个，所以这只是插入

1312
00:49:29,940 --> 00:49:32,760
顺序，所以这是我的

1313
00:49:32,760 --> 00:49:34,320


1314
00:49:34,320 --> 00:49:36,150


1315
00:49:36,150 --> 00:49:38,610


1316
00:49:38,610 --> 00:49:40,740
列存储 事情变得

1317
00:49:40,740 --> 00:49:42,000
全宽然后我创建一个新块

1318
00:49:42,000 --> 00:49:44,660
并继续插入开始，

1319
00:49:44,660 --> 00:49:47,370
所以现在如果我想对表格进行排序

1320
00:49:47,370 --> 00:49:51,060
，我说我把所有这些列

1321
00:49:51,060 --> 00:49:52,560
都按照这个方案排序，

1322
00:49:52,560 --> 00:49:56,160
所以我要去 首先

1323
00:49:56,160 --> 00:49:58,410
按升序对所有元组进行排序，然后按

1324
00:49:58,410 --> 00:50:01,650
降序排列，然后再看发送，

1325
00:50:01,650 --> 00:50:04,320
所以我们需要

1326
00:50:04,320 --> 00:50:07,320
为每个元组设置所有固定长度

1327
00:50:07,320 --> 00:50:09,300
相同，所以如果我正在查看正确的四个元组

1328
00:50:09,300 --> 00:50:12,240
我希望能够

1329
00:50:12,240 --> 00:50:14,040
在这个位置跳到 B 并且我应该看到

1330
00:50:14,040 --> 00:50:17,670
B 的属性对于同一个元组，所以

1331
00:50:17,670 --> 00:50:20,040
现在如果我排序说我想对 a 进行排序

1332
00:50:20,040 --> 00:50:22,080
，然后我必须将该排序

1333
00:50:22,080 --> 00:50:25,410
顺序传播到另一个 列是对的，

1334
00:50:25,410 --> 00:50:27,360
所以我从 a 开始，我按这个值对它们进行排序，

1335
00:50:27,360 --> 00:50:30,810
但现在在 B 内，诚实

1336
00:50:30,810 --> 00:50:33,270
到这里是所有排序的 atras

1337
00:50:33,270 --> 00:50:35,400
它开始所有的 a 鞋与一个相等

1338
00:50:35,400 --> 00:50:37,830
的，现在我根据我的

1339
00:50:37,830 --> 00:50:40,950
已售出对它们进行排序 B 代表 B 然后在

1340
00:50:40,950 --> 00:50:42,870
里面我现在有了 C 中的排序，

1341
00:50:42,870 --> 00:50:45,150
所以现在再次 这再次保证，

1342
00:50:45,150 --> 00:50:46,950
如果我在这里将其视为元组

1343
00:50:46,950 --> 00:50:49,800
，我会看到

1344
00:50:49,800 --> 00:50:52,370
我给定的元组的所有 attrex

1345
00:50:52,370 --> 00:50:54,330
让我猜猜你为什么要进行

1346
00:50:54,330 --> 00:50:56,750
这种排序

1347
00:50:56,970 --> 00:51:01,150
是的，她说的是次要和

1348
00:51:01,150 --> 00:51:12,730
索引 你的意思是所以他说如果我跳到

1349
00:51:12,730 --> 00:51:14,320
B 列的某个地方但是但是

1350
00:51:14,320 --> 00:51:17,320
在这里这个案例我在右边排序

1351
00:51:17,320 --> 00:51:19,420
所以如果我有一个谓词说找到

1352
00:51:19,420 --> 00:51:21,040
我所有的元组，其中 a 等于 a

1353
00:51:21,040 --> 00:51:24,070
等于 1 那么 我可以跳到这里

1354
00:51:24,070 --> 00:51:25,780
并向下扫描，然后一旦我看到一个 - 我

1355
00:51:25,780 --> 00:51:27,280
知道从来没有 - 再给我一个 1

1356
00:51:27,280 --> 00:51:29,950
，我就完成了，但是如果我发现

1357
00:51:29,950 --> 00:51:31,840
我所有的两个男孩，我们就是甲虫 B - 我

1358
00:51:31,840 --> 00:51:33,820
不能只看这个地区 我让你

1359
00:51:33,820 --> 00:51:41,230
必须正确地扫描整个事情 所以

1360
00:51:41,230 --> 00:51:43,150
一旦我到了她就说得很好 所以我

1361
00:51:43,150 --> 00:51:45,010
正在寻找 B - 一旦我到了现在我

1362
00:51:45,010 --> 00:51:46,870
看到一个 B 1 我知道那里不会

1363
00:51:46,870 --> 00:51:49,150
成为这个区域 a 的另一个 B 1 然后

1364
00:51:49,150 --> 00:51:50,890
现在但现在我需要知道如何

1365
00:51:50,890 --> 00:52:05,620
跳到下一个区域就像你

1366
00:52:05,620 --> 00:52:09,310
从 B 1 B 1 中获取所有那些然后你得到

1367
00:52:09,310 --> 00:52:11,260
t 他第一个去第二

1368
00:52:11,260 --> 00:52:16,870
个都是相对的，所以它并不是

1369
00:52:16,870 --> 00:52:18,160
真正的第二个索引会使

1370
00:52:18,160 --> 00:52:21,660
扫描速度更快，但可能会

1371
00:52:21,660 --> 00:52:23,620
假设这是如果你正在做

1372
00:52:23,620 --> 00:52:24,850
正确的分区，如果你知道

1373
00:52:24,850 --> 00:52:27,310
边界是什么，那么如果 如果我这是 a 的

1374
00:52:27,310 --> 00:52:30,430
边界 a 等于 a 等于 a 1

1375
00:52:30,430 --> 00:52:33,130
所以如果我扫描寻找 b-2s 如果我

1376
00:52:33,130 --> 00:52:35,110
扫描到 p2 然后我看到 B 1 我

1377
00:52:35,110 --> 00:52:36,580
知道以后永远不会有另一个 B

1378
00:52:36,580 --> 00:52:38,650
2 所以，如果我知道

1379
00:52:38,650 --> 00:52:39,970
下一个分区是什么，我可以直接跳到

1380
00:52:39,970 --> 00:52:43,720
这里，但这是一个

1381
00:52:43,720 --> 00:52:46,230
好处，是的，

1382
00:52:52,580 --> 00:52:58,110
Furby bell 表示肯定，所以我们实际上会看到这个

1383
00:52:58,110 --> 00:52:59,640
，我正在寻找的答案

1384
00:52:59,640 --> 00:53:01,260
将在上面看到 星期三，如果一切都已排序，我们

1385
00:53:01,260 --> 00:53:02,940
实际上是海狸以这种方式压缩

1386
00:53:02,940 --> 00:53:05,580
得更好，因此您所做的

1387
00:53:05,580 --> 00:53:07,530
最常见的一种常见排序

1388
00:53:07,530 --> 00:53:09,630
称为运行长度编码，所以

1389
00:53:09,630 --> 00:53:12,000
说这样只有我们只有两个

1390
00:53:12,000 --> 00:53:15,000
值 B 它是 b2 或 p1 所以我

1391
00:53:15,000 --> 00:53:16,860
说 一遍又一遍地对 b2 的副本进行排序

1392
00:53:16,860 --> 00:53:18,960
我可以说我有两次 b2

1393
00:53:18,960 --> 00:53:21,810
并且我 b1 你知道一次

1394
00:53:21,810 --> 00:53:24,060
两次三次 对这

1395
00:53:24,060 --> 00:53:25,860
就像假设

1396
00:53:25,860 --> 00:53:28,980
你只有两到两种性别每个人

1397
00:53:28,980 --> 00:53:30,900
都是一种或另一种所以如果我有

1398
00:53:30,900 --> 00:53:33,840
一百万学生并且如果我对他们进行排序

1399
00:53:33,840 --> 00:53:36,690
关于他们的性别 那么我猜

1400
00:53:36,690 --> 00:53:38,250
这里是你知道 50

1401
00:53:38,250 --> 00:53:39,870
万男性和 500 女性 我

1402
00:53:39,870 --> 00:53:41,670
只需要存储那个

1403
00:53:41,670 --> 00:53:43,800
小的编码并不是每个

1404
00:53:43,800 --> 00:53:47,970
值的实例都会看到这个下一个类所以

1405
00:53:47,970 --> 00:53:49,920
Vertica 做这个 Vertigo 的

1406
00:53:49,920 --> 00:53:53,010
进行排序的最强大的反对者他们

1407
00:53:53,010 --> 00:53:55,140
称之为这些预测的想法是

1408
00:53:55,140 --> 00:53:57,900
，我对所有内容进行排序，然后

1409
00:53:57,900 --> 00:53:59,790
在 a 的值的边界内

1410
00:53:59,790 --> 00:54:01,680
排序，然后我为下一列排序等等

1411
00:54:01,680 --> 00:54:06,930
，你正在缩小窗口，好吧 是的，

1412
00:54:06,930 --> 00:54:08,580
垂直没有任何人

1413
00:54:08,580 --> 00:54:10,140
对待索引，他们只有某种

1414
00:54:10,140 --> 00:54:13,680
预测

1415
00:54:13,680 --> 00:54:14,850


1416
00:54:14,850 --> 00:54:16,980


1417
00:54:16,980 --> 00:54:18,660
o

1418
00:54:18,660 --> 00:54:20,460
去这个新属性想要在

1419
00:54:20,460 --> 00:54:23,280
这里的这个位置，但还有一些

1420
00:54:23,280 --> 00:54:24,960
其他属性类似于

1421
00:54:24,960 --> 00:54:26,940
现在存储在那里，在我的例子中，

1422
00:54:26,940 --> 00:54:29,700
2 小于 3 但我正在排序，所以

1423
00:54:29,700 --> 00:54:31,770
我需要移动这些家伙 在我

1424
00:54:31,770 --> 00:54:35,100
可以继续并准备好插入我的人员之前，

1425
00:54:35,100 --> 00:54:36,960


1426
00:54:36,960 --> 00:54:39,180
如果我有十亿个元组

1427
00:54:39,180 --> 00:54:40,800
并且我的家伙降落在我的专栏的开头，

1428
00:54:40,800 --> 00:54:42,030
如果我必须将所有内容

1429
00:54:42,030 --> 00:54:44,490
转移甚至在一个块内移动，这显然会很昂贵 这将

1430
00:54:44,490 --> 00:54:46,590
是昂贵的，这就是

1431
00:54:46,590 --> 00:54:49,140
Casper 试图解决的问题，所以这个

1432
00:54:49,140 --> 00:54:50,250
想法是你将

1433
00:54:50,250 --> 00:54:54,960
在你的列上方有这个索引，

1434
00:54:54,960 --> 00:54:56,490
你将根据范围将事物分割成这些分区

1435
00:54:56,490 --> 00:54:58,920
，然后现在是什么 会

1436
00:54:58,920 --> 00:55:00,810
发生的是，当我进行插入时，

1437
00:55:00,810 --> 00:55:02,580
我只需要确保我的 -

1438
00:55:02,580 --> 00:55:04,320
男孩，我正在尝试将地插入

1439
00:55:04,320 --> 00:55:05,910
正确的范围

1440
00:55:05,910 --> 00:55:07,950
内，只要我有空间，就不需要在该范围内排序

1441
00:55:07,950 --> 00:55:09,090
把它放在

1442
00:55:09,090 --> 00:55:12,120
那里然后现在我可以很容易地找到所有

1443
00:55:12,120 --> 00:55:14,910
的 da

1444
00:55:14,910 --> 00:55:16,800
如果我

1445
00:55:16,800 --> 00:55:18,180
必须执行顺序扫描或

1446
00:55:18,180 --> 00:55:19,830
像 OLAP 查询这样的长扫描，我会做 10 次点查询，然后我会忽略

1447
00:55:19,830 --> 00:55:21,510
索引，

1448
00:55:21,510 --> 00:55:22,890
尽管您可以使用它们，但我只是翻阅了这些列

1449
00:55:22,890 --> 00:55:26,130
指导扫描搜索，所以这

1450
00:55:26,130 --> 00:55:28,110
是 Casper 的一个附加组件，或者

1451
00:55:28,110 --> 00:55:29,610
当他们有这个离线算法

1452
00:55:29,610 --> 00:55:31,320
但他们将检查

1453
00:55:31,320 --> 00:55:33,270
数据集中 Sam 的工作量，然后尝试

1454
00:55:33,270 --> 00:55:34,530
提出一个最佳分区

1455
00:55:34,530 --> 00:55:38,430
方案，例如

1456
00:55:38,430 --> 00:55:39,570
通过分析操作访问的四个元组

1457
00:55:39,570 --> 00:55:41,610
它们具有更大的分区，

1458
00:55:41,610 --> 00:55:42,570
因为您不太可能更新

1459
00:55:42,570 --> 00:55:44,520
它们并且必须重新洗牌，

1460
00:55:44,520 --> 00:55:48,720
然后对于热门数据，

1461
00:55:48,720 --> 00:55:50,460
它可以很快更新然后您

1462
00:55:50,460 --> 00:55:52,650
需要较小的分区，以便 您

1463
00:55:52,650 --> 00:55:53,790
可以使用 shell 索引更快地找到它们，

1464
00:55:53,790 --> 00:55:56,520
所以让

1465
00:55:56,520 --> 00:55:58,710
我们在这里查看附件表，因此我们再次拥有

1466
00:55:58,710 --> 00:56:01,050
列存储，它们具有这些逻辑，这些

1467
00:56:01,050 --> 00:56:03,030
分区标记它们不必是

1468
00:56:03,030 --> 00:56:04,560
物理上的一部分 在他们的例子中，

1469
00:56:04,560 --> 00:56:06,150
他们展示了它似乎只是我

1470
00:56:06,150 --> 00:56:07,050
并继续空间和这些

1471
00:56:07,050 --> 00:56:09,270
分界点但显然你

1472
00:56:09,270 --> 00:56:09,810
不想要它

1473
00:56:09,810 --> 00:56:11,070
你不会在

1474
00:56:11,070 --> 00:56:12,420
一些巨大的数组中分配你知道的所以这仍然是一个

1475
00:56:12,420 --> 00:56:14,430
组织块但是

1476
00:56:14,430 --> 00:56:15,630
还需要指出的重要一点是，这些是

1477
00:56:15,630 --> 00:56:17,010
非常长的分区，它们可以

1478
00:56:17,010 --> 00:56:19,380
根据元组的访问方式进行增长和缩小，

1479
00:56:19,380 --> 00:56:22,170
因此如果我想在这里开始这个

1480
00:56:22,170 --> 00:56:24,690
元组，它会进入这个

1481
00:56:24,690 --> 00:56:25,710
分区，因为我们正在尝试排序

1482
00:56:25,710 --> 00:56:27,510
在一个 - 我有空间来存储一个 -

1483
00:56:27,510 --> 00:56:28,920
就在这里很好

1484
00:56:28,920 --> 00:56:31,770
，这真的很快，我们已经完成了但是

1485
00:56:31,770 --> 00:56:33,060
现在如果我想在

1486
00:56:33,060 --> 00:56:34,560
这里开始另一个元组，当我开始另一个元组时有

1487
00:56:34,560 --> 00:56:36,810
一个 - 需要进入这个

1488
00:56:36,810 --> 00:56:39,300
位置但现在在我的分区内我

1489
00:56:39,300 --> 00:56:41,640
没有更多空间所以他们使用

1490
00:56:41,640 --> 00:56:43,140
这种称为波纹插入的技术这个

1491
00:56:43,140 --> 00:56:45,480
想法就像你我的理解

1492
00:56:45,480 --> 00:56:47,490
就像你把一块鹅卵石扔进湖里

1493
00:56:47,490 --> 00:56:49,260
所以你看到涟漪传播你

1494
00:56:49,260 --> 00:56:51,540
会 开始搬东西

1495
00:56:51,540 --> 00:56:54,060
从一个分区到下一个分区，所以

1496
00:56:54,060 --> 00:56:55,560
对于这里的这个分区，我们想将我们的

1497
00:56:55,560 --> 00:56:58,230
元组插入到这个分区中，但是

1498
00:56:58,230 --> 00:56:59,610
我们没有任何空间，所以我们需要

1499
00:56:59,610 --> 00:57:02,160
从我们下面的请愿书中窃取一些空间，

1500
00:57:02,160 --> 00:57:04,230
所以我们需要移动 这家伙到

1501
00:57:04,230 --> 00:57:06,810
它的分区的末尾，然后现在我只是

1502
00:57:06,810 --> 00:57:09,300
滑下我的分界点，

1503
00:57:09,300 --> 00:57:11,730
然后重新调整我的范围分区，就像

1504
00:57:11,730 --> 00:57:13,800
我的浅索引一样，现在我可以断言

1505
00:57:13,800 --> 00:57:14,040


1506
00:57:14,040 --> 00:57:17,040
人们现在可能是这样，当我们

1507
00:57:17,040 --> 00:57:19,950
尝试将这个元组移动到一个

1508
00:57:19,950 --> 00:57:22,620
这个分区的新位置没有更多空间，

1509
00:57:22,620 --> 00:57:24,060
因此我们现在必须

1510
00:57:24,060 --> 00:57:25,290
从下一个分区中窃取，因此

1511
00:57:25,290 --> 00:57:27,240
这是一种连锁反应，但

1512
00:57:27,240 --> 00:57:29,730
这里的想法是在最好的情况下，我可以

1513
00:57:29,730 --> 00:57:31,620
断言到我的分区和 我不会

1514
00:57:31,620 --> 00:57:34,050
在最坏的情况下移动任何东西

1515
00:57:34,050 --> 00:57:35,310
我必须重新洗牌每个

1516
00:57:35,310 --> 00:57:38,730
分区，但实际上你

1517
00:57:38,730 --> 00:57:40,050
不想说应该多久发生一次，但就像

1518
00:57:40,050 --> 00:57:42,570
在实践中一样，你不应该

1519
00:57:42,570 --> 00:57:44,520
重组整个数据库肯定

1520
00:57:44,520 --> 00:57:45,960
会少得多 吨 如果我们正在

1521
00:57:45,960 --> 00:57:47,160
做那些全局和排序的事情，我

1522
00:57:47,160 --> 00:57:52,140
不应该开始是的，这就像

1523
00:57:52,140 --> 00:57:55,260
基于一个排序 - 我们只知道你

1524
00:57:55,260 --> 00:57:56,490
仍然可以对不同的属性进行排序

1525
00:57:56,490 --> 00:58:07,830
，只是这似乎我们不是珊瑚礁

1526
00:58:07,830 --> 00:58:10,290
或 在 B 和 C 上，如果我正在对多个

1527
00:58:10,290 --> 00:58:12,210
地址进行排序，那么如果论文确实想

1528
00:58:12,210 --> 00:58:13,230
向我们解释

1529
00:58:13,230 --> 00:58:15,660
这件事，这件事可能

1530
00:58:15,660 --> 00:58:18,540
在多个属性上是多的，

1531
00:58:18,540 --> 00:58:20,070
它要说的是这是总和的范围，

1532
00:58:20,070 --> 00:58:21,930
这是范围域 它

1533
00:58:21,930 --> 00:58:23,700
由一个分区表示，

1534
00:58:23,700 --> 00:58:24,960
几乎可以肯定它可能

1535
00:58:24,960 --> 00:58:27,420
在一个分区内的单个属性中，

1536
00:58:27,420 --> 00:58:30,090
尽管我没有资源我

1537
00:58:30,090 --> 00:58:33,450
没有对这些东西进行排序这

1538
00:58:33,450 --> 00:58:34,620
只是告诉你嘿你的数据

1539
00:58:34,620 --> 00:58:36,450
寻找将在他的范围内，但是

1540
00:58:36,450 --> 00:58:37,740
当您降落在这里时，请弄清楚它在

1541
00:58:37,740 --> 00:58:41,550
哪里，如果只是 TP，那么我

1542
00:58:41,550 --> 00:58:43,080
不希望这东西太大，因为

1543
00:58:43,080 --> 00:58:44,370
然后我扫描了两列，这

1544
00:58:44,370 --> 00:58:46,590
很有趣，正是我的意思 想要，但如果我的

1545
00:58:46,590 --> 00:58:50,400
分区限制太多 但是如果

1546
00:58:50,400 --> 00:58:52,500
我的分区更小，

1547
00:58:52,500 --> 00:58:55,700
那么我找到我需要的东西的

1548
00:58:55,730 --> 00:58:57,930
可能性会更快，因为

1549
00:58:57,930 --> 00:59:00,540
再次查看的时间更少了他们有这个离线

1550
00:59:00,540 --> 00:59:01,950
算法可以根据事物的访问方式来调整这些

1551
00:59:01,950 --> 00:59:03,090
事物的大小

1552
00:59:03,090 --> 00:59:06,810


1553
00:59:06,810 --> 00:59:09,600
所以我已经说过了，但是

1554
00:59:09,600 --> 00:59:11,970


1555
00:59:11,970 --> 00:59:13,440
对于这些混合工作负载的这些 H 分接头工作负载，

1556
00:59:13,440 --> 00:59:16,410


1557
00:59:16,410 --> 00:59:18,570
在热数据和冷数据之间存在一个卑鄙的 dikötter 热

1558
00:59:18,570 --> 00:59:20,010
数据是

1559
00:59:20,010 --> 00:59:21,750
最近刚刚插入刚刚更新的

1560
00:59:21,750 --> 00:59:23,760
东西 最近刚刚通过

1561
00:59:23,760 --> 00:59:26,850
OTP 交易访问，然后我们剩下的

1562
00:59:26,850 --> 00:59:27,569
就是所有这些

1563
00:59:27,569 --> 00:59:29,729
完整的数据，这些数据是我们需要

1564
00:59:29,729 --> 00:59:31,859
它们在那里进行扫描和分析的东西，

1565
00:59:31,859 --> 00:59:33,719
但我们不太

1566
00:59:33,719 --> 00:59:36,390
可能不得不继续更新它们，所以 如果

1567
00:59:36,390 --> 00:59:38,069
我们意识到这一点并且这

1568
00:59:38,069 --> 00:59:40,219
就是 caspere 试图利用的东西

1569
00:59:40,219 --> 00:59:43,469
，那么除了调整分区大小之外，

1570
00:59:43,469 --> 00:59:46,049
我们还可以

1571
00:59:46,049 --> 00:59:47,849
以不同的方式重新组织或存储数据，

1572
00:59:47,849 --> 00:59:50,009
例如热 数据在行存储中，

1573
00:59:50,009 --> 00:59:51,509
因为这将是快速的形式 不适用于

1574
00:59:51,509 --> 00:59:53,339
事务，随着时间的推移，它会随着

1575
00:59:53,339 --> 00:59:54,989
冷却我们将其移动到列存储中，

1576
00:59:54,989 --> 00:59:55,890
因为这是我们想要存储

1577
00:59:55,890 --> 00:59:58,410
很酷的数据，所以这就是混合

1578
00:59:58,410 --> 01:00:00,449
存储 模型方法是这样的，所以我

1579
01:00:00,449 --> 01:00:02,759
想说这也是

1580
01:00:02,759 --> 01:00:04,559
我们最初做 peloton 的方式 这是

1581
01:00:04,559 --> 01:00:06,209
我认为曾经是正确的想法

1582
01:00:06,209 --> 01:00:09,809
实际上我现在认为

1583
01:00:09,809 --> 01:00:11,579
他们

1584
01:00:11,579 --> 01:00:13,799
正在使用 Casper 方法的纯列存储 或者

1585
01:00:13,799 --> 01:00:15,719
我们所做的超级清除实际上是一种

1586
01:00:15,719 --> 01:00:17,190
更好的方法 不值得花费

1587
01:00:17,190 --> 01:00:18,930
工程开销来安排所有

1588
01:00:18,930 --> 01:00:21,180
这些额外的存储管理

1589
01:00:21,180 --> 01:00:23,519
器来完成这项工作，但至少

1590
01:00:23,519 --> 01:00:24,930
知道它是如何工作的，因为很多

1591
01:00:24,930 --> 01:00:27,509
系统实际上都这样做 所以我们的想法

1592
01:00:27,509 --> 01:00:28,529
是我们将有一个单一的逻辑

1593
01:00:28,529 --> 01:00:31,289
数据库实例，在

1594
01:00:31,289 --> 01:00:32,849
封面下面是存储热和冷，你

1595
01:00:32,849 --> 01:00:34,469
知道的不同所以我会调用创建

1596
01:00:34,469 --> 01:00:37,019
表，每当我进行查找时，我都会看到

1597
01:00:37,019 --> 01:00:39,180
一个表，但在下面 封面

1598
01:00:39,180 --> 01:00:43,199
数据库系统管理不同，以不同的方式

1599
01:00:43,199 --> 01:00:46,529
管理不同的元组，

1600
01:00:46,529 --> 01:00:48,690
因此热数据将在行存储中

1601
01:00:48,690 --> 01:00:50,309
，冷数据将在列存储中，

1602
01:00:50,309 --> 01:00:52,440
因此从工程角度有两种方法可以做到这一点

1603
01:00:52,440 --> 01:00:55,140
，第

1604
01:00:55,140 --> 01:00:56,549
一种是您实际上维护两个

1605
01:00:56,549 --> 01:00:58,199
完全独立的 原谅

1606
01:00:58,199 --> 01:01:00,630
系统中存储管理器中的管理器，然后

1607
01:01:00,630 --> 01:01:01,559
你有一些东西可以

1608
01:01:01,559 --> 01:01:05,099
将上面的答案拼接在一起，

1609
01:01:05,099 --> 01:01:07,079
然后另一种方法是我们

1610
01:01:07,079 --> 01:01:08,549
在 peloton 中所做的，你有一个单一的

1611
01:01:08,549 --> 01:01:10,319
执行和一个存储管理

1612
01:01:10,319 --> 01:01:12,239
器，可以在两者上运行 同时行存储和

1613
01:01:12,239 --> 01:01:14,190
列存储数据

1614
01:01:14,190 --> 01:01:15,690
，你有这种间接

1615
01:01:15,690 --> 01:01:16,709
层，它知道如何

1616
01:01:16,709 --> 01:01:19,619
从两个不同的模型中读取数据，并且可以

1617
01:01:19,619 --> 01:01:23,579
将它们统一在一个引擎中，所以

1618
01:01:23,579 --> 01:01:24,989
单独的执行引擎是最

1619
01:01:24,989 --> 01:01:27,180
常见的，因为 这里最常发生的事情

1620
01:01:27,180 --> 01:01:29,249
是人们使用现有的

1621
01:01:29,249 --> 01:01:30,660
数据库系统，然后将它们

1622
01:01:30,660 --> 01:01:31,979
组合在一起，然后构建一个小的

1623
01:01:31,979 --> 01:01:33,779
中间件 ng 最重要的是统一

1624
01:01:33,779 --> 01:01:37,499
它们，所以有两种方法可以做到这一点

1625
01:01:37,499 --> 01:01:39,829
，即

1626
01:01:39,829 --> 01:01:41,010
Oracle

1627
01:01:41,010 --> 01:01:43,590
IBM 或正在做的破碎镜像，然后 delta 存储

1628
01:01:43,590 --> 01:01:45,900
方法是 hana 过去所做的

1629
01:01:45,900 --> 01:01:48,720
，就像我们谈论的那样

1630
01:01:48,720 --> 01:01:49,980
时间旅行表记得

1631
01:01:49,980 --> 01:01:51,660
他们有主数据表

1632
01:01:51,660 --> 01:01:52,770
和时间旅行表，主

1633
01:01:52,770 --> 01:01:55,200
数据表总是有最旧的

1634
01:01:55,200 --> 01:01:56,910
，时间旅行表有最新

1635
01:01:56,910 --> 01:01:58,740
的，因为主表

1636
01:01:58,740 --> 01:02:03,030
是列存储，然后是 时间

1637
01:02:03,030 --> 01:02:06,420
旅行表是 delta 存储，所以我

1638
01:02:06,420 --> 01:02:09,060
将通过这两个所以

1639
01:02:09,060 --> 01:02:10,560
破碎的大麻甘特图我们基本上

1640
01:02:10,560 --> 01:02:13,560
有一个完整的数据库副本，

1641
01:02:13,560 --> 01:02:16,500
但现在存储的是一个列存储，

1642
01:02:16,500 --> 01:02:18,150
所以它就像一个镜像副本，但它

1643
01:02:18,150 --> 01:02:19,380
被称为破碎的 意思就像我打破

1644
01:02:19,380 --> 01:02:21,150
了镜像，因为我

1645
01:02:21,150 --> 01:02:24,420
现在将行重新组织为列，因此行

1646
01:02:24,420 --> 01:02:26,070
存储将始终是数据库的主要存储

1647
01:02:26,070 --> 01:02:28,380
我所有的读取和写入

1648
01:02:28,380 --> 01:02:30,030
都将在此处进行所有事务

1649
01:02:30,030 --> 01:02:32,160
都将更新 这部分，然后在

1650
01:02:32,160 --> 01:02:34,200
后台通过一些过程，

1651
01:02:34,200 --> 01:02:36,960
然后我将数据复制出来，将其转换为

1652
01:02:36,960 --> 01:02:38,670
列存储并将其存储在镜像中

1653
01:02:38,670 --> 01:02:42,030
，然后现在当任何分析查询

1654
01:02:42,030 --> 01:02:43,830
出现时，如果他们只需要触摸

1655
01:02:43,830 --> 01:02:46,620
限定在其中的数据 列存储

1656
01:02:46,620 --> 01:02:48,450
然后将它路由到这里并且我

1657
01:02:48,450 --> 01:02:49,920
运行得更有效

1658
01:02:49,920 --> 01:02:55,860
是的这个问题在那里 Seema 是这些

1659
01:02:55,860 --> 01:02:58,770
数据可能有点陈旧取决于所以

1660
01:02:58,770 --> 01:03:00,380
有时你可以

1661
01:03:00,380 --> 01:03:02,250
有时你想要有时你

1662
01:03:02,250 --> 01:03:03,180
不需要你不 是不是你

1663
01:03:03,180 --> 01:03:05,340
不想这样做，所以如果你不能

1664
01:03:05,340 --> 01:03:07,470
过时，那么当他出现的分析时，

1665
01:03:07,470 --> 01:03:09,270
你需要认识到哦，你需要

1666
01:03:09,270 --> 01:03:12,150
我在逗号中没有的数据，

1667
01:03:12,150 --> 01:03:13,560
所以我也需要 需要

1668
01:03:13,560 --> 01:03:16,320
在行存储上执行该查询，然后

1669
01:03:16,320 --> 01:03:18,990
将其放回原处，因此 Oracle

1670
01:03:18,990 --> 01:03:21,260
这样

1671
01:03:26,400 --> 01:03:28,660
做更像是他们弄清楚

1672
01:03:28,660 --> 01:03:30,400
查询的

1673
01:03:30,400 --> 01:03:31,810
哪一部分需要在行存储上运行以及这些

1674
01:03:31,810 --> 01:03:33,910
在列中运行的部分 存储，他们会同时运行

1675
01:03:33,910 --> 01:03:37,060
它们，然后 pu

1676
01:03:37,060 --> 01:03:39,490
据我所知，sybase IQ 并没有这样做

1677
01:03:39,490 --> 01:03:41,170
，它与烤肉是分开的，

1678
01:03:41,170 --> 01:03:43,120
或者你不可能不知道我们

1679
01:03:43,120 --> 01:03:44,230
不知道烤肉或

1680
01:03:44,230 --> 01:03:45,790
除了从获取更新之外 所以当一个

1681
01:03:45,790 --> 01:03:46,990
环形引用如果你

1682
01:03:46,990 --> 01:03:48,940
在 sybase IQ 上运行道德查询它只会触及

1683
01:03:48,940 --> 01:03:50,170
这个我不会回去从中获取其余

1684
01:03:50,170 --> 01:03:52,090
的数据而 Orko Orko

1685
01:03:52,090 --> 01:03:59,380
结合了我的一切所以他的陈述

1686
01:03:59,380 --> 01:04:01,270
是保持诚实是好的我认为 他

1687
01:04:01,270 --> 01:04:02,980
早些时候提出了这个问题，比如在什么

1688
01:04:02,980 --> 01:04:05,470
情况下你需要像你

1689
01:04:05,470 --> 01:04:07,480
知道分析查询的可序列化执行，以及

1690
01:04:07,480 --> 01:04:09,190


1691
01:04:09,190 --> 01:04:12,310
人们想要的最新信息

1692
01:04:12,310 --> 01:04:14,290
，就是这样，人们想要的

1693
01:04:14,290 --> 01:04:16,750
不够多，Oracle 决定这样做

1694
01:04:16,750 --> 01:04:17,740
但重要的一点要指出的是，

1695
01:04:17,740 --> 01:04:20,680
如果 Oracle 在

1696
01:04:20,680 --> 01:04:24,040
内存列存储中遇到了那个家伙

1697
01:04:24,040 --> 01:04:25,930
在星期三殴打的情况，那么这件事是短暂的，

1698
01:04:25,930 --> 01:04:27,970
所以如果这件事如果你

1699
01:04:27,970 --> 01:04:30,070
卷土重来或停止，这不是把它重新

1700
01:04:30,070 --> 01:04:30,430
打开

1701
01:04:30,430 --> 01:04:34,870
就像它会传播平静的

1702
01:04:34,870 --> 01:04:37,540
圣 ore 通过从行存储中读取

1703
01:04:37,540 --> 01:04:39,370
所以再次所有更新都必须在这里

1704
01:04:39,370 --> 01:04:41,140
这是主存储这东西

1705
01:04:41,140 --> 01:04:48,190
是懒惰地传播的所以他的问题

1706
01:04:48,190 --> 01:04:50,050
是 mem Siegel 这样做知道 mem sequel

1707
01:04:50,050 --> 01:04:53,430
会这样做增量存储方法

1708
01:04:53,670 --> 01:04:57,210
等等 这个工作是

1709
01:04:57,210 --> 01:05:00,070
你再次拥有像 Delta 存储

1710
01:05:00,070 --> 01:05:01,630
行存储的东西，比如有一个

1711
01:05:01,630 --> 01:05:03,940
待处理的东西，比如更新，所以登录

1712
01:05:03,940 --> 01:05:08,350
然后转到实际上新版本

1713
01:05:08,350 --> 01:05:09,820
的 M 续集可能会这样做，

1714
01:05:09,820 --> 01:05:11,530
进入新版本会这样做 Overtoun

1715
01:05:11,530 --> 01:05:13,840
旧版本是你调用

1716
01:05:13,840 --> 01:05:15,220
板条箱表，你会说我想

1717
01:05:15,220 --> 01:05:17,290
成为一个行存储或列存储，

1718
01:05:17,290 --> 01:05:18,430
但是如果你说好的，我想让

1719
01:05:18,430 --> 01:05:20,170
这个表现在成为一个行存储，或者

1720
01:05:20,170 --> 01:05:21,850
如果它开始时很抱歉 烘焙机啊现在我

1721
01:05:21,850 --> 01:05:23,560
就像在一个列商店我要把它倾倒

1722
01:05:23,560 --> 01:05:28,150
出来然后重新加载它就像我

1723
01:05:28,150 --> 01:05:29,860
无法从烤肉或

1724
01:05:29,860 --> 01:05:32,800
桌子上获取数据并将其无缝转换

1725
01:05:32,800 --> 01:05:34,870
为列存储 Ida 有 两个独立的

1726
01:05:34,870 --> 01:05:37,000
逻辑表 较新版本

1727
01:05:37,000 --> 01:05:38,170
实际上是这样做的，您将

1728
01:05:38,170 --> 01:05:40,120
更新应用到这个 Delta 存储并

1729
01:05:40,120 --> 01:05:47,190
倾向于列存储，所以

1730
01:05:47,190 --> 01:05:50,170


1731
01:05:50,170 --> 01:05:52,300
如果现在我

1732
01:05:52,300 --> 01:05:53,710
有一个需要在两侧都需要触摸数据的查询，那么您又遇到了我们在折射镜上遇到的相同问题，

1733
01:05:53,710 --> 01:05:56,530
那么我需要一个

1734
01:05:56,530 --> 01:06:00,120
在 rostral plus 每列存储上执行的方法

1735
01:06:00,120 --> 01:06:02,680
现在，如果您正在执行 BCC，

1736
01:06:02,680 --> 01:06:04,420
您有点像使用 Delta 存储，您

1737
01:06:04,420 --> 01:06:05,860
可以免费获得相同的东西，就像您

1738
01:06:05,860 --> 01:06:07,390
已经需要能够

1739
01:06:07,390 --> 01:06:08,770
在 Virgin 链中遍历一样 并找到

1740
01:06:08,770 --> 01:06:10,810
给定元组的正确版本，这

1741
01:06:10,810 --> 01:06:12,250
基本上

1742
01:06:12,250 --> 01:06:14,260
与 Delta

1743
01:06:14,260 --> 01:06:15,850


1744
01:06:15,850 --> 01:06:17,710


1745
01:06:17,710 --> 01:06:18,880
商店一样 一如既往的

1746
01:06:18,880 --> 01:06:20,380
最新版本，但我们仍然有办法

1747
01:06:20,380 --> 01:06:22,000


1748
01:06:22,000 --> 01:06:23,860
通过在

1749
01:06:23,860 --> 01:06:32,680
最乏味的或 MMC 季度中重播更新来调和正确的或版本 从

1750
01:06:32,680 --> 01:06:36,010
mem 续集中声明是在 M 续集中

1751
01:06:36,010 --> 01:06:37,420
这些东西是否曾经刷新过

1752
01:06:37,420 --> 01:06:40,000
磁盘 我知道 除了在日志中没有别的，

1753
01:06:40,000 --> 01:06:42,820
但这就是从

1754
01:06:42,820 --> 01:06:48,520
这里开始的，所以我提出这个的原因，

1755
01:06:48,520 --> 01:06:51,160
所以 MVCC 的东西就像在

1756
01:06:51,160 --> 01:06:52,510
这里回到这个键一样，破碎的

1757
01:06:52,510 --> 01:06:54,460
镜像，你基本上构建了两个数据库

1758
01:06:54,460 --> 01:06:55,900
系统，你需要一个运行

1759
01:06:55,900 --> 01:06:57,640
在行存储数据上，然后你需要一个

1760
01:06:57,640 --> 01:06:59,680
列存储 一个看起来很酷的执行

1761
01:06:59,680 --> 01:07:00,580
引擎，它知道如何有效地

1762
01:07:00,580 --> 01:07:03,640
操作你知道列数据

1763
01:07:03,640 --> 01:07:04,690
将与你

1764
01:07:04,690 --> 01:07:06,520
在行存储数据中做事的方式不同你

1765
01:07:06,520 --> 01:07:07,750
基本上维护了两个独立的

1766
01:07:07,750 --> 01:07:10,090
引擎这个 这里的

1767
01:07:10,090 --> 01:07:13,960
工作少了一点，因为同样如果你在做 FEC

1768
01:07:13,960 --> 01:07:15,460
你仍然需要你需要如何

1769
01:07:15,460 --> 01:07:17,400
处理这个无论如何

1770
01:07:17,400 --> 01:07:19,630
这实际上是我认为更好的

1771
01:07:19,630 --> 01:07:23,530
方法你

1772
01:07:23,530 --> 01:07:25,540
知道我们现在正在做的 MVCC 方法是否是

1773
01:07:25,540 --> 01:07:26,950
是同样的事情，但是这是否

1774
01:07:26,950 --> 01:07:29,500
是我们系统中的本构傻瓜，

1775
01:07:29,500 --> 01:07:31,060
增量变化处女构成一个

1776
01:07:31,060 --> 01:07:32,830
完整的延展性存储，这是有争议的我

1777
01:07:32,830 --> 01:07:34,690
认为这只是语义，但我认为

1778
01:07:34,690 --> 01:07:35,800
这是 更好的方法，因为现在

1779
01:07:35,800 --> 01:07:37,000
你没有这种

1780
01:07:37,000 --> 01:07:38,650
试图将两个

1781
01:07:38,650 --> 01:07:42,970
超级数据库系统维护在一起的工程怪物，所以

1782
01:07:42,970 --> 01:07:46,270
对于 Peloton，我们所做的是我们

1783
01:07:46,270 --> 01:07:48,250
试图变得聪明，我们

1784
01:07:48,250 --> 01:07:51,850
试图同时拥有行存储和列

1785
01:07:51,850 --> 01:07:53,860
存储 但是

1786
01:07:53,860 --> 01:07:55,660
然后我们有一个上面的执行引擎

1787
01:07:55,660 --> 01:07:57,610
，它知道如何对它们进行操作

1788
01:07:57,610 --> 01:07:59,470
，我们通过拥有

1789
01:07:59,470 --> 01:08:01,210
一个我们称之为瓷砖的抽象层来做到这一点，它

1790
01:08:01,210 --> 01:08:03,700
知道如何只对这些瓷砖进行操作，而在

1791
01:08:03,700 --> 01:08:04,780
幕后不

1792
01:08:04,780 --> 01:08:05,980
知道它是否 是烤肉或

1793
01:08:05,980 --> 01:08:07,960
列存储，然后访问

1794
01:08:07,960 --> 01:08:09,940
不同类型切片的访问方法

1795
01:08:09,940 --> 01:08:11,740
知道如何将事物组合在一起

1796
01:08:11,740 --> 01:08:14,470
有效地访问它们，所以我们的想法

1797
01:08:14,470 --> 01:08:18,700
是我们将查看我们的数据，

1798
01:08:18,700 --> 01:08:20,529
看看交易和小查询是如何

1799
01:08:20,529 --> 01:08:22,750
访问它们的 哪些

1800
01:08:22,750 --> 01:08:24,910
区域很热哪些区域很冷我们

1801
01:08:24,910 --> 01:08:26,890
将热数据存储作为行存储，

1802
01:08:26,890 --> 01:08:28,600
然后将冷数据存储

1803
01:08:28,600 --> 01:08:31,510
为列存储，然后现在再次 n 我

1804
01:08:31,510 --> 01:08:33,490
问你两个问题 我知道你

1805
01:08:33,490 --> 01:08:35,640
怎么知道根据需要把东西放在一起 所以

1806
01:08:35,640 --> 01:08:38,890
我确定一个工作图基本上

1807
01:08:38,890 --> 01:08:40,540
所有的东西总是从一个行存储开始，

1808
01:08:40,540 --> 01:08:42,670
所以如果你正在

1809
01:08:42,670 --> 01:08:45,939
做一堆工作，降低你的 新的扫描

1810
01:08:45,939 --> 01:08:47,470
插入 扫描插入 所以它基本上是

1811
01:08:47,470 --> 01:08:50,020
很多 o 到 Bo 那个 polo 到 B 等等所以

1812
01:08:50,020 --> 01:08:52,029
对于道路布局，扫描会

1813
01:08:52,029 --> 01:08:54,250
更慢，如果

1814
01:08:54,250 --> 01:08:58,840
你在做柱状布局，插入会更快，这些

1815
01:08:58,840 --> 01:09:00,970
是扫描 更快，但

1816
01:09:00,970 --> 01:09:02,080
插入速度较慢，因为现在我

1817
01:09:02,080 --> 01:09:03,520
将一个元组从强位置分解为

1818
01:09:03,520 --> 01:09:05,439
多个位置，并且

1819
01:09:05,439 --> 01:09:07,029
混合布局的想法是一切都

1820
01:09:07,029 --> 01:09:10,149
从行存储开始，但随着时间的推移，随着

1821
01:09:10,149 --> 01:09:11,529
您开始在数据中进行更多

1822
01:09:11,529 --> 01:09:12,729
扫描 更冷它被转换为

1823
01:09:12,729 --> 01:09:14,649
列存储，然后现在加快

1824
01:09:14,649 --> 01:09:16,540
了扫描操作，所以行

1825
01:09:16,540 --> 01:09:17,979
和行存储一样快，因为它

1826
01:09:17,979 --> 01:09:19,810
是行存储，但随后扫描变得

1827
01:09:19,810 --> 01:09:23,439
更快，所以我们放弃了这一切，因为它

1828
01:09:23,439 --> 01:09:28,120
是一个 工程噩梦

1829
01:09:28,120 --> 01:09:29,260
学生们无法理解我们到底在

1830
01:09:29,260 --> 01:09:31,510
做什么，但是

1831
01:09:31,510 --> 01:09:35,609
就像必须

1832
01:09:35,609 --> 01:09:38,290
为这个混合的事情编写测试用例和性能回归一样，这

1833
01:09:38,290 --> 01:09:42,580


1834
01:09:42,580 --> 01:09:44,260
对我们来说是一个巨大的问题，所以我们放弃了所有这些，

1835
01:09:44,260 --> 01:09:45,910
让它变得更加简单和公正 使用

1836
01:09:45,910 --> 01:09:48,430
干净的列存储，我认为这

1837
01:09:48,430 --> 01:09:49,359
实际上是更好的方法，并且

1838
01:09:49,359 --> 01:09:52,540
您是否具有

1839
01:09:52,540 --> 01:09:54,820
Casper 人员在上面所做的浅索引，这是

1840
01:09:54,820 --> 01:09:56,800
有争议的 我不喜欢

1841
01:09:56,800 --> 01:10:00,500
有额外的背景

1842
01:10:00,500 --> 01:10:01,810
[音乐]

1843
01:10:01,810 --> 01:10:03,910
背景机制的想法 尝试

1844
01:10:03,910 --> 01:10:06,130
通过查看工作量来为您重新组织数据

1845
01:10:06,130 --> 01:10:07,960
我认为这也应该是

1846
01:10:07,960 --> 01:10:10,390
集中式的，对于这个实现，

1847
01:10:10,390 --> 01:10:13,450
我们还没有做到这一点，

1848
01:10:13,450 --> 01:10:14,500
所以最后有点匆忙，

1849
01:10:14,500 --> 01:10:16,630
但就像主要的收获

1850
01:10:16,630 --> 01:10:19,570
一样 可以做很多方法来一起做行

1851
01:10:19,570 --> 01:10:20,940
源和列存储我

1852
01:10:20,940 --> 01:10:22,930
认为至少对于

1853
01:10:22,930 --> 01:10:24,310
我们正在查看的工作列表我认为纯粹的列

1854
01:10:24,310 --> 01:10:28,390
存储是 MVCC 的一种方式，但是

1855
01:10:28,390 --> 01:10:29,260
很多 有时你会遇到

1856
01:10:29,260 --> 01:10:30,580
破碎的镜像方法，这

1857
01:10:30,580 --> 01:10:32,470
对所有主要的主要

1858
01:10:32,470 --> 01:10:37,300
供应商

1859
01:10:37,300 --> 01:10:41,760


1860
01:10:41,760 --> 01:10:44,140


1861
01:10:44,140 --> 01:10:46,450
来说都很常见

1862
01:10:46,450 --> 01:10:47,650


1863
01:10:47,650 --> 01:10:49,000
一开始，我们如何确定

1864
01:10:49,000 --> 01:10:50,980
元组的布局

1865
01:10:50,980 --> 01:10:52,810
在您调用 create table 时从跳转到不同的偏移量中得到了很好的更新，

1866
01:10:52,810 --> 01:10:54,880
我们存储了

1867
01:10:54,880 --> 01:10:56,080
您在创建该

1868
01:10:56,080 --> 01:10:57,970
表和目录时指定的元数据，然后当我们去的时候

1869
01:10:57,970 --> 01:10:59,530
访问该工具将读取目录

1870
01:10:59,530 --> 01:11:00,940
并弄清楚

1871
01:11:00,940 --> 01:11:05,020
我们数据的布局是什么所以

1872
01:11:05,020 --> 01:11:07,090
关于目录的棘手之处在于我们

1873
01:11:07,090 --> 01:11:08,140
实际上想要吃自己的狗粮，

1874
01:11:08,140 --> 01:11:10,060
这意味着我们不想拥有单独的

1875
01:11:10,060 --> 01:11:13,240
数据库 主要只维护一个

1876
01:11:13,240 --> 01:11:14,980
商店一个目录我们想将

1877
01:11:14,980 --> 01:11:17,560
目录存储在我们自己的数据库中，在

1878
01:11:17,560 --> 01:11:19,300
我们自己的表中一切正常，但现在它就像

1879
01:11:19,300 --> 01:11:21,190
鸡蛋问题的鸡一样，就像我需要

1880
01:11:21,190 --> 01:11:24,310
在 c 中存储有关表的元数据

1881
01:11:24,310 --> 01:11:26,170
atalog 但我需要将我的目录正确地存储

1882
01:11:26,170 --> 01:11:29,980
在表中，所以我们必须有这个

1883
01:11:29,980 --> 01:11:31,240
专门的代码来

1884
01:11:31,240 --> 01:11:33,730
引导目录 Post 最好的一个

1885
01:11:33,730 --> 01:11:35,110
实际上很有趣他们

1886
01:11:35,110 --> 01:11:37,120
接受他们基本上有这个 DSL，

1887
01:11:37,120 --> 01:11:40,540
然后转换为 C 代码的 cuc 为了

1888
01:11:40,540 --> 01:11:41,620
做这个引导，基本上

1889
01:11:41,620 --> 01:11:42,910
插入所有你需要的东西

1890
01:11:42,910 --> 01:11:44,410
，以便打开目录

1891
01:11:44,410 --> 01:11:47,020
我不知道其他系统做了什么，

1892
01:11:47,020 --> 01:11:48,400
因为我实际上可以看到

1893
01:11:48,400 --> 01:11:51,580
Postgres 中的源代码和

1894
01:11:51,580 --> 01:11:52,870
我的续集的早期版本，比如 我的续集

1895
01:11:52,870 --> 01:11:55,570
5.7 他们只是存储目录是

1896
01:11:55,570 --> 01:11:57,190
磁盘上的平面文件，我认为

1897
01:11:57,190 --> 01:11:59,050


1898
01:11:59,050 --> 01:12:01,000
将所有内容存储在常规表中

1899
01:12:01,000 --> 01:12:02,530
是错误的，因为现在您获得了

1900
01:12:02,530 --> 01:12:04,330
对

1901
01:12:04,330 --> 01:12:08,110
常规元组期望的所有酸保证 数据表，所以让

1902
01:12:08,110 --> 01:12:09,430
我们通过一些示例来了解如何进行

1903
01:12:09,430 --> 01:12:11,590
架构更改，现在您将看到

1904
01:12:11,590 --> 01:12:12,820
如果您是

1905
01:12:12,820 --> 01:12:14,320
行存储，有些事情会更容易，而如果您的列存储和 v，有些事情会更难

1906
01:12:14,320 --> 01:12:15,579
反之亦然，

1907
01:12:15,579 --> 01:12:21,130
所以如果我添加一列，那么我基本上

1908
01:12:21,130 --> 01:12:22,960
需要扫描

1909
01:12:22,960 --> 01:12:26,349
行存储中的每一个管并将元组复制到

1910
01:12:26,349 --> 01:12:28,780
一个新位置，并在其中

1911
01:12:28,780 --> 01:12:31,059
插入新列，某些数据库

1912
01:12:31,059 --> 01:12:32,500
系统不允许您插入该列

1913
01:12:32,500 --> 01:12:34,360
到任何位置，就像你只能

1914
01:12:34,360 --> 01:12:36,040
在最后插入它 Postgres

1915
01:12:36,040 --> 01:12:38,800
这样做所以就像我的 Siebel 你

1916
01:12:38,800 --> 01:12:40,059
可以准确地指定你想要的

1917
01:12:40,059 --> 01:12:41,469
位置你想要插入它因为

1918
01:12:41,469 --> 01:12:42,309
基本上他们正在做的是他们正在

1919
01:12:42,309 --> 01:12:44,440
复制每个 从旧

1920
01:12:44,440 --> 01:12:46,960
模式到新模式的单个元组用于

1921
01:12:46,960 --> 01:12:49,619
列存储可能超级简单

1922
01:12:49,619 --> 01:12:54,550
是的问题你做了对不起哦冷静

1923
01:12:54,550 --> 01:12:55,869
排序超级容易因为我只是正确地创建了一个

1924
01:12:55,869 --> 01:12:57,969
新列我不需要

1925
01:12:57,969 --> 01:12:59,920
修改它现在克服的任何内容 这

1926
01:12:59,920 --> 01:13:01,679
取决于我的块的组织方式，

1927
01:13:01,679 --> 01:13:05,110
但总的来说，你知道这

1928
01:13:05,110 --> 01:13:07,119
比行存储更容易，因为如果我要去把列取出来，我

1929
01:13:07,119 --> 01:13:10,030
不必接触任何现有数据来删除

1930
01:13:10,030 --> 01:13:12,190
列同样的事情

1931
01:13:12,190 --> 01:13:15,070
节省

1932
01:13:15,070 --> 01:13:17,500
内存 n 我再次检查

1933
01:13:17,500 --> 01:13:18,790
所有内容并将其复制到

1934
01:13:18,790 --> 01:13:21,070
某些系统中，您可以将它们标记为

1935
01:13:21,070 --> 01:13:22,599
已弃用，例如 Postgres 如果

1936
01:13:22,599 --> 01:13:23,770
我删除一个列，它实际上并未

1937
01:13:23,770 --> 01:13:25,750
删除，只需将它们记录

1938
01:13:25,750 --> 01:13:27,940
已删除的目录即可 你知道忽略

1939
01:13:27,940 --> 01:13:29,380
它 任何出现的查询都会尝试读取

1940
01:13:29,380 --> 01:13:31,270
它，但实际上它仍然存在，

1941
01:13:31,270 --> 01:13:32,650
然后在某个时候当他们赢得

1942
01:13:32,650 --> 01:13:34,480
MVCC 的垃圾收集器时，

1943
01:13:34,480 --> 01:13:37,630


1944
01:13:37,630 --> 01:13:40,079
如果我正在存储我的列，他们会继续压缩它以再次用于列存储 作为

1945
01:13:40,079 --> 01:13:43,239
单独在内存中然后我只是

1946
01:13:43,239 --> 01:13:45,699
继续释放它，我完成了

1947
01:13:45,699 --> 01:13:47,610
我不会影响任何其他人

1948
01:13:47,610 --> 01:13:50,110
更改列，就像您更改

1949
01:13:50,110 --> 01:13:52,389
列类型或更改列中的约束一样

1950
01:13:52,389 --> 01:13:54,460
取决于更改 我正在

1951
01:13:54,460 --> 01:13:56,440
做我可能必须扫描并

1952
01:13:56,440 --> 01:13:58,480
查看每个元组，然后才能

1953
01:13:58,480 --> 01:14:00,969
再次进行更改，然后

1954
01:14:00,969 --> 01:14:02,320
等待我是否是我们的专栏商店的烘焙师

1955
01:14:02,320 --> 01:14:04,570
我可以引导数据，因为它

1956
01:14:04,570 --> 01:14:08,050
存在，或者我可以 去改变

1957
01:14:08,050 --> 01:14:10,239
一些事情，比如如果我从 32 位开始

1958
01:14:10,239 --> 01:14:13,630
将它的整数转换为 16 位整数我

1959
01:14:13,630 --> 01:14:14,949
必须扫描以确保

1960
01:14:14,949 --> 01:14:17,679
如果我进行更改不会出现越界错误

1961
01:14:17,679 --> 01:14:20,199
但现在也许我

1962
01:14:20,199 --> 01:14:21,820
不需要实际复制所有内容并

1963
01:14:21,820 --> 01:14:23,920
制作 16- 位列我可以将它保留为

1964
01:14:23,920 --> 01:14:25,659
32 位稍后我会清理它

1965
01:14:25,659 --> 01:14:29,139
但你知道转换只是

1966
01:14:29,139 --> 01:14:33,219
在逻辑级别完成索引

1967
01:14:33,219 --> 01:14:36,550
非常棘手这个我认为

1968
01:14:36,550 --> 01:14:37,869
我们没有时间讨论这个学期 这

1969
01:14:37,869 --> 01:14:39,849
是我会说这是

1970
01:14:39,849 --> 01:14:44,050
人们已经尝试过的东西 我认为

1971
01:14:44,050 --> 01:14:45,790
在这个课程中两年来我们一直试图

1972
01:14:45,790 --> 01:14:48,699
创建索引 我们

1973
01:14:48,699 --> 01:14:50,260
现在可以在我们的系统中再次创建索引 如果

1974
01:14:50,260 --> 01:14:51,699
您在加载任何表之前调用 create index

1975
01:14:51,699 --> 01:14:54,309
表中的数据很好，

1976
01:14:54,309 --> 01:14:55,630
你插入数据然后将更新

1977
01:14:55,630 --> 01:14:57,909
它正在经历

1978
01:14:57,909 --> 01:14:59,889
的索引并在已经创建的表上填充索引，这

1979
01:14:59,889 --> 01:15:01,840
时候事情变得棘手，因为如果你

1980
01:15:01,840 --> 01:15:03,219
想在不阻塞答案的情况下这样做，

1981
01:15:03,219 --> 01:15:04,780
因为II可以锁定整个

1982
01:15:04,780 --> 01:15:07,840
表 扫描那个木偶般的我的索引 但是

1983
01:15:07,840 --> 01:15:09,820
您知道这可能需要很长时间，所以

1984
01:15:09,820 --> 01:15:12,460
我希望有一些方法可以在执行此操作时进行

1985
01:15:12,460 --> 01:15:13,540
大量索引而不必阻止

1986
01:15:13,540 --> 01:15:16,059
所有内容，

1987
01:15:16,059 --> 01:15:17,349
这是人们

1988
01:15:17,349 --> 01:15:20,730
在本课程中尝试过两次并取得成功的方法，

1989
01:15:20,730 --> 01:15:23,409
我让任何人都感到有趣 在本

1990
01:15:23,409 --> 01:15:25,719
学期再次尝试删除索引非常容易，

1991
01:15:25,719 --> 01:15:27,639
您只需从目录中逻辑地删除它

1992
01:15:27,639 --> 01:15:29,380
然后在后台某个

1993
01:15:29,380 --> 01:15:30,909
时间点您知道没有其他人在

1994
01:15:30,909 --> 01:15:32,050
看它然后继续删除

1995
01:15:32,050 --> 01:15:34,059
这个我们有这个延迟事件

1996
01:15:34,059 --> 01:15:35,469
框架 我们的系统现在

1997
01:15:35,469 --> 01:15:37,090
对

1998
01:15:37,090 --> 01:15:38,679
我们在系统中分配的任何类型的内存应用程序都有垃圾收集，

1999
01:15:38,679 --> 01:15:42,869
我们已经可以处理这个问题

2000
01:15:43,030 --> 01:15:45,969
了，最后一个它将是序列，所以

2001
01:15:45,969 --> 01:15:49,119
序列是自动递增的数字或

2002
01:15:49,119 --> 01:15:51,130
像序列键一样，Postgres 认为

2003
01:15:51,130 --> 01:15:52,929
我是 就像一列，我有一个属性

2004
01:15:52,929 --> 01:15:55,090
，每次我插入一个元组时，如果我

2005
01:15:55,090 --> 01:15:56,920
没有指定一个值，就会有一些

2006
01:15:56,920 --> 01:15:58,179
计数器，他们将在其中添加

2007
01:15:58,179 --> 01:16:00,280
一个，然后如果下一个

2008
01:16:00,280 --> 01:16:02,440
元组被插入，那么就这样 ed 它会让你

2009
01:16:02,440 --> 01:16:04,989
知道计数器加一等等，

2010
01:16:04,989 --> 01:16:06,250
所以它们的超级有趣之处

2011
01:16:06,250 --> 01:16:07,659
在于它们不遵循相同的

2012
01:16:07,659 --> 01:16:09,730
事务保证或隔离

2013
01:16:09,730 --> 01:16:11,380
保护，你从常规

2014
01:16:11,380 --> 01:16:13,239
事务中获得了吗？我们将存储

2015
01:16:13,239 --> 01:16:15,429
它们 在目录中这个计数器但是如果

2016
01:16:15,429 --> 01:16:17,500
我插入一个元组计数器会

2017
01:16:17,500 --> 01:16:18,670
增加然后我回滚我的

2018
01:16:18,670 --> 01:16:20,619
事务元组将

2019
01:16:20,619 --> 01:16:22,570
回滚但是日历总是会

2020
01:16:22,570 --> 01:16:25,119
上升所以需要发生的是你

2021
01:16:25,119 --> 01:16:26,320
实际上必须将其记录到磁盘

2022
01:16:26,320 --> 01:16:28,719
因为那样的话，如果我崩溃回来，我

2023
01:16:28,719 --> 01:16:30,400
需要知道那个计数器在哪里停止，

2024
01:16:30,400 --> 01:16:31,750
即使

2025
01:16:31,750 --> 01:16:33,940
修改它的事务可能尚未

2026
01:16:33,940 --> 01:16:37,030
写入磁盘，所以这实际上

2027
01:16:37,030 --> 01:16:38,710
是学生在旧系统中所做的事情，

2028
01:16:38,710 --> 01:16:40,750
这是很多 有趣，我

2029
01:16:40,750 --> 01:16:41,080
认为这

2030
01:16:41,080 --> 01:16:42,780
在这门课上再做一次很好

2031
01:16:42,780 --> 01:16:44,110


2032
01:16:44,110 --> 01:16:45,610
，显然我们

2033
01:16:45,610 --> 01:16:47,050
可以从草后和其他

2034
01:16:47,050 --> 01:16:49,300
系统中看到优化，比如也许你永远只更新

2035
01:16:49,300 --> 01:16:52,210
磁盘上的计数器 你知道

2036
01:16:52,210 --> 01:16:54,400
一批值，比如每 10 个

2037
01:16:54,400 --> 01:16:56,470
，然后你在内存中分发新值

2038
01:16:56,470 --> 01:16:58,900
，然后只有当你

2039
01:16:58,900 --> 01:17:00,010
达到上限时，你才会

2040
01:17:00,010 --> 01:17:03,630
再次增加目录中的计数器，好吧，

2041
01:17:03,630 --> 01:17:06,010
我们没时间了 我不能做一个演示，

2042
01:17:06,010 --> 01:17:08,140
但如果你对这种东西感兴趣的话，我们会在壁橱里做，

2043
01:17:08,140 --> 01:17:09,610


2044
01:17:09,610 --> 01:17:12,370
所以只是为了完成所以我说过我们

2045
01:17:12,370 --> 01:17:14,290
放弃混合存储模型我认为

2046
01:17:14,290 --> 01:17:16,480
至少在这种情况下简单是

2047
01:17:16,480 --> 01:17:19,990
系统的这一部分是一个巨大的

2048
01:17:19,990 --> 01:17:23,970
胜利，正确的方法是

2049
01:17:23,970 --> 01:17:26,260
我们将在 MVCC 下使用的版本控制增量

2050
01:17:26,260 --> 01:17:28,990
加上列存储相当于

2051
01:17:28,990 --> 01:17:31,120


2052
01:17:31,120 --> 01:17:33,340
我们在目录之前看到的不同方法真的

2053
01:17:33,340 --> 01:17:35,080
很难，这是 实际上我们

2054
01:17:35,080 --> 01:17:36,430
现在在我们的系统中得到了正确的东西 我真的很

2055
01:17:36,430 --> 01:17:37,840
高兴地说

2056
01:17:37,840 --> 01:17:40,270
我们遵循了 Postgres 模式或

2057
01:17:40,270 --> 01:17:43,480
目录的布局并将所有

2058
01:17:43,480 --> 01:17:45,610
存储的东西放在表中，所以我们得到的东西我们得到

2059
01:17:45,610 --> 01:17:46,780
了你

2060
01:17:46,780 --> 01:17:48,730
通常会为元组得到的所有事务保证，所以

2061
01:17:48,730 --> 01:17:49,690
有很多 我们现在可以做一些很酷的事情，因为

2062
01:17:49,690 --> 01:17:52,000
我们的目录是事务性的，但是

2063
01:17:52,000 --> 01:17:52,750
当我们谈论项目 3 时，我们可以涵盖更多内容

2064
01:17:52,750 --> 01:17:56,170


2065
01:17:56,170 --> 01:17:59,850


2066
01:18:00,010 --> 01:18:03,180


2067
01:18:03,180 --> 01:18:05,700


2068
01:18:05,700 --> 01:18:08,280
和测试团队一起下来 嗨，你看，

2069
01:18:08,280 --> 01:18:11,370
它是去给我拿 40 只是为了让我的

2070
01:18:11,370 --> 01:18:13,260
嗡嗡声因为我需要

2071
01:18:13,260 --> 01:18:16,080
像鱼一样多踢一点，只要一个

2072
01:18:16,080 --> 01:18:18,480
滑倒把它放在我的嘴唇上，撕掉顶部

2073
01:18:18,480 --> 01:18:20,850
，他们拉 卡车和

2074
01:18:20,850 --> 01:18:23,760
热狗一样，我的心想让我说

2075
01:18:23,760 --> 01:18:28,070
我很高兴坐下来庆祝

