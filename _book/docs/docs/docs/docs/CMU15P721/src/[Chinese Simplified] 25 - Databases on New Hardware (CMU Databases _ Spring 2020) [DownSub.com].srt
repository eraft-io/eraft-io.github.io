1
00:00:01,300 --> 00:00:05,129
[音乐]

2
00:00:05,200 --> 00:00:05,930
[掌声]

3
00:00:05,930 --> 00:00:08,630
[音乐]

4
00:00:08,630 --> 00:00:10,020
[掌声]

5
00:00:10,020 --> 00:00:11,990
[音乐]

6
00:00:11,990 --> 00:00:15,750
上一堂课是一个艰难的

7
00:00:15,750 --> 00:00:17,789
学期，但我们终于

8
00:00:17,789 --> 00:00:21,689
熬过了这最后一次讨论，我们将

9
00:00:21,689 --> 00:00:24,330
讨论在某种新兴硬件上运行的数据库

10
00:00:24,330 --> 00:00:26,460
或某种

11
00:00:26,460 --> 00:00:27,900
非传统硬件，

12
00:00:27,900 --> 00:00:29,910
与

13
00:00:29,910 --> 00:00:31,920
我们在进入该材料之前讨论的所有内容略有不同，

14
00:00:31,920 --> 00:00:33,480
我很快就想

15
00:00:33,480 --> 00:00:36,660
回顾

16
00:00:36,660 --> 00:00:38,010
一下从现在到期末成绩学期结束的你们剩下的东西，

17
00:00:38,010 --> 00:00:40,410
所以在本周三

18
00:00:40,410 --> 00:00:42,329
本周我们将有一位来自亚马逊的客座演讲者

19
00:00:42,329 --> 00:00:46,050
来谈谈

20
00:00:46,050 --> 00:00:47,640
他在红移方面所做的工作 所以

21
00:00:47,640 --> 00:00:49,410
这将是现场直播 这将是

22
00:00:49,410 --> 00:00:51,780
变焦 不幸的是它只适用于

23
00:00:51,780 --> 00:00:53,789
高年级学生 所以我会

24
00:00:53,789 --> 00:00:57,300
在广场上发布详细信息 下周 5 月 4 日

25
00:00:57,300 --> 00:00:59,070
你将提交第二轮代码

26
00:00:59,070 --> 00:01:01,379
审查 5 月 5 日去做你的

27
00:01:01,379 --> 00:01:05,040
最终演示 也取消缩放 也只

28
00:01:05,040 --> 00:01:07,710
提供给 CMU 学生讨论 你

29
00:01:07,710 --> 00:01:10,020
知道屠夫小组已经在

30
00:01:10,020 --> 00:01:12,240
fi 我上周发出的最终考试

31
00:01:12,240 --> 00:01:15,689
将于 5 月 13 日星期三到期，

32
00:01:15,689 --> 00:01:18,060
然后这里缺少的是

33
00:01:18,060 --> 00:01:21,150
在网站上发布的代码删除中，

34
00:01:21,150 --> 00:01:22,740
所以当你得到你认识的人时，

35
00:01:22,740 --> 00:01:24,180
将所有信息提交给我说

36
00:01:24,180 --> 00:01:26,310
你是 在

37
00:01:26,310 --> 00:01:28,409
合并第二轮代码

38
00:01:28,409 --> 00:01:31,770
审查意见之后实际完成，然后在 5 月 16 日

39
00:01:31,770 --> 00:01:35,579
星期六，我们将再次举办我们的额外信用

40
00:01:35,579 --> 00:01:37,979
黑客马拉松 这是可选的 这

41
00:01:37,979 --> 00:01:39,479
对那些想要

42
00:01:39,479 --> 00:01:41,310
参与的人可用 它实际上也

43
00:01:41,310 --> 00:01:44,820
将开放并可能用于 对于非 CMU

44
00:01:44,820 --> 00:01:47,369
学生，所以我们将弄清楚如何

45
00:01:47,369 --> 00:01:49,320
再次协调这个想法是

46
00:01:49,320 --> 00:01:51,960
你不会工作，你知道只要

47
00:01:51,960 --> 00:01:53,700
继续工作你为第三个项目所做的工作，

48
00:01:53,700 --> 00:01:56,030
这将是

49
00:01:56,030 --> 00:01:58,079
新的东西或某种添加 一个新的

50
00:01:58,079 --> 00:02:01,710
续集功能或新功能来扩展

51
00:02:01,710 --> 00:02:05,430
对我们的续集系统的支持，

52
00:02:05,430 --> 00:02:07,649
再次可以 我将在 Piazza 上发布有关此的详细信息

53
00:02:07,649 --> 00:02:09,669


54
00:02:09,669 --> 00:02:12,160
还有一件事是我需要每个人

55
00:02:12,160 --> 00:02:14,349
也填写 t 的课程评估

56
00:02:14,349 --> 00:02:18,550
他的 URL 在这里，所以这

57
00:02:18,550 --> 00:02:20,560
对我非常有用，因为他们我意识到，

58
00:02:20,560 --> 00:02:23,860
你知道的最后一堂课有一半

59
00:02:23,860 --> 00:02:26,489
的课程学期只在网上，

60
00:02:26,489 --> 00:02:29,770
所以只是对项目的一般评论

61
00:02:29,770 --> 00:02:32,350
，阅读作业，

62
00:02:32,350 --> 00:02:34,540
一般节奏或节奏 课堂上

63
00:02:34,540 --> 00:02:36,250
那些东西实际上非常非常

64
00:02:36,250 --> 00:02:38,709
有用我实际上阅读了它们并且我

65
00:02:38,709 --> 00:02:39,940
实际上考虑了

66
00:02:39,940 --> 00:02:42,400
从一个学期到下一个学期调整课程的考虑

67
00:02:42,400 --> 00:02:46,690
大学和

68
00:02:46,690 --> 00:02:47,980
系实际上阅读了这些东西所以

69
00:02:47,980 --> 00:02:49,330
这是不要掉以轻心并且

70
00:02:49,330 --> 00:02:51,459
不要 不像大多数硕士生

71
00:02:51,459 --> 00:02:52,750
通常只点击五五哦

72
00:02:52,750 --> 00:02:54,160
五所有事情就像实际上你

73
00:02:54,160 --> 00:02:55,540
知道如果你想花时间给

74
00:02:55,540 --> 00:02:57,970
我真诚的反馈请

75
00:02:57,970 --> 00:03:00,160
完全匿名所以给你

76
00:03:00,160 --> 00:03:02,799
一种想法反馈 我经常可以

77
00:03:02,799 --> 00:03:05,620
得到我们每年得到一次，人们

78
00:03:05,620 --> 00:03:08,440
正确地指出我有体臭

79
00:03:08,440 --> 00:03:10,569


80
00:03:10,569 --> 00:03:14,320
问题，此后几年用

81
00:03:14,320 --> 00:03:16,359
特殊的洗发水解决了这个问题 o 希望没有人

82
00:03:16,359 --> 00:03:19,989
因我身体散发出的任何气味而受到冒犯，

83
00:03:19,989 --> 00:03:22,180
但这再次

84
00:03:22,180 --> 00:03:23,769
非常有用，直到这个人指出我才真正知道我有

85
00:03:23,769 --> 00:03:25,180
体味问题

86
00:03:25,180 --> 00:03:26,980
，然后我去看

87
00:03:26,980 --> 00:03:28,299
医生，他就像 哦，是的，你

88
00:03:28,299 --> 00:03:29,500
有这个问题，这个健康

89
00:03:29,500 --> 00:03:31,120
状况

90
00:03:31,120 --> 00:03:33,280
，这是你应该使用的这种特殊洗发水，所以这就是为什么我希望

91
00:03:33,280 --> 00:03:35,709
你坦率地公开你

92
00:03:35,709 --> 00:03:38,410
对课程的所有评论 II 确实考虑到

93
00:03:38,410 --> 00:03:42,090
它们，

94
00:03:42,090 --> 00:03:45,100
正如我所说的那样 今天你

95
00:03:45,100 --> 00:03:47,650
想谈论的地方是

96
00:03:47,650 --> 00:03:50,850
在你知道的新硬件

97
00:03:50,850 --> 00:03:52,989
硬件上运行数据库，而不仅仅是你知道 CPU

98
00:03:52,989 --> 00:03:56,590
和 SSD 以及旋转磁盘驱动器，所以

99
00:03:56,590 --> 00:03:59,319
这一直是数据库中的一个持续主题，

100
00:03:59,319 --> 00:04:01,540
几乎

101
00:04:01,540 --> 00:04:03,069
从人们开始 在 1980 年代初期，在 1970 年代后期，一直在

102
00:04:03,069 --> 00:04:06,250
寻求使用专用硬件或

103
00:04:06,250 --> 00:04:08,739
新硬件来使数据系统运行

104
00:04:08,739 --> 00:04:10,239
得更快

105
00:04:10,239 --> 00:04:13,690


106
00:04:13,690 --> 00:04:16,180
有

107
00:04:16,180 --> 00:04:18,700
一种称为数据库机器的运动，

108
00:04:18,700 --> 00:04:21,190
其想法是 您会像购买设备一样购买

109
00:04:21,190 --> 00:04:22,230


110
00:04:22,230 --> 00:04:25,740
具有定制硬件 Asics 的专用服务器

111
00:04:25,740 --> 00:04:26,760


112
00:04:26,760 --> 00:04:29,070
来进行数据库

113
00:04:29,070 --> 00:04:31,200
操作的拆分，因此常见的情况是

114
00:04:31,200 --> 00:04:32,730
您可以购买具有专用硬件的数据库机器

115
00:04:32,730 --> 00:04:35,130
来非常有效地进行哈希

116
00:04:35,130 --> 00:04:37,830
连接，因此这种

117
00:04:37,830 --> 00:04:42,750
运动在 1980 年代，

118
00:04:42,750 --> 00:04:44,760
因为摩尔定律，你知道英特尔和

119
00:04:44,760 --> 00:04:47,220
摩托罗拉，12 月我们一直在推出

120
00:04:47,220 --> 00:04:50,220
新的 CPU，所以

121
00:04:50,220 --> 00:04:51,900
如果你在去的时候是数据库机器供应

122
00:04:51,900 --> 00:04:54,210
商，你知道设计

123
00:04:54,210 --> 00:04:57,630
和制造并销售 你的专业数据

124
00:04:57,630 --> 00:04:59,610
作为硬件 Intel 推出了新

125
00:04:59,610 --> 00:05:02,340
版本的 x86，它变得更快，所以

126
00:05:02,340 --> 00:05:05,280


127
00:05:05,280 --> 00:05:06,510
你在构建这些东西时所付出的努力会得到递减的回报，

128
00:05:06,510 --> 00:05:10,500
所以在 1990 年代，

129
00:05:10,500 --> 00:05:12,380
大多数人都在运行

130
00:05:12,380 --> 00:05:14,580
商品硬件，当然

131
00:05:14,580 --> 00:05:16,950
当云在 2000 年代出现时，

132
00:05:16,950 --> 00:05:20,640
在 2000 年代更是如此，尽管

133
00:05:20,640 --> 00:05:22,890
有一些早期尝试构建

134
00:05:22,890 --> 00:05:26,100
FP FPGA 数据库的想法是你

135
00:05:26,100 --> 00:05:28,350
将让 DJ 坐在 CPU

136
00:05:28,350 --> 00:05:31,560
和磁盘控制器之间，你只需

137
00:05:31,560 --> 00:05:33,240
按下谓词，所以

138
00:05:33,240 --> 00:05:34,860
预告片是一个著名的系统，

139
00:05:34,860 --> 00:05:36,450
IBM 买了它们

140
00:05:36,450 --> 00:05:37,950
我认为他们已经在大约一年前淘汰了它们，或者杀死了

141
00:05:37,950 --> 00:05:41,220
它们，但是 他们你

142
00:05:41,220 --> 00:05:42,630
知道他们是第一个 FBI

143
00:05:42,630 --> 00:05:44,940
数据库系统，现在

144
00:05:44,940 --> 00:05:46,890
也有一堆设备数据库

145
00:05:46,890 --> 00:05:49,830
，不像数据库机器，它

146
00:05:49,830 --> 00:05:51,300
有专门用于

147
00:05:51,300 --> 00:05:53,310
数据库系统的硬件，设备的想法

148
00:05:53,310 --> 00:05:57,830
是它是商品硬件，但

149
00:05:57,830 --> 00:06:00,330
操作系统中的系统

150
00:06:00,330 --> 00:06:02,370
数据库系统

151
00:06:02,370 --> 00:06:04,710
针对正在运行的哈佛进行了明确的调整

152
00:06:04,710 --> 00:06:07,140
，所以你可以购买这个机架

153
00:06:07,140 --> 00:06:09,360
单元，它运行着

154
00:06:09,360 --> 00:06:11,190
我的续集，但我的续集已经针对那个确切的硬件进行了调整，

155
00:06:11,190 --> 00:06:12,630
所以我们有点

156
00:06:12,630 --> 00:06:15,020
使它们达到最佳性能，但再次

157
00:06:15,020 --> 00:06:17,550
因为云而

158
00:06:17,550 --> 00:06:20,220
失败，因为每个人

159
00:06:20,220 --> 00:06:22,890
都说从亚马逊购买商品更便宜

160
00:06:22,890 --> 00:06:24,950


161
00:06:24,950 --> 00:06:29,760
2010 年有一种醋，FPGA

162
00:06:29,760 --> 00:06:31,980
沙皇一直在那里，

163
00:06:31,980 --> 00:06:34,289
我认为近年来它们变得

164
00:06:34,289 --> 00:06:37,050
更加普遍，但我们

165
00:06:37,050 --> 00:06:40,439
在过去十年中在 2010 年看到的烘焙

166
00:06:40,439 --> 00:06:42,990
是 GQ 数据库的兴起，这是

167
00:06:42,990 --> 00:06:46,740
因为 对使用

168
00:06:46,740 --> 00:06:48,300
GPU 计算进行机器学习的巨大兴趣的

169
00:06:48,300 --> 00:06:50,819
人们正确地认识到，哦，我

170
00:06:50,819 --> 00:06:52,080
实际上可以在 GPU 上做一些数据库的事情，

171
00:06:52,080 --> 00:06:54,869
并利用

172
00:06:54,869 --> 00:06:55,979
机器学习

173
00:06:55,979 --> 00:06:58,289
人员正在取得的所有进步，所以我们会

174
00:06:58,289 --> 00:06:59,819
稍微讨论一下 在

175
00:06:59,819 --> 00:07:01,889
本次讲座的最后，有

176
00:07:01,889 --> 00:07:03,449
一些 GPU 数据库是什么以及它们的

177
00:07:03,449 --> 00:07:05,849
样子 所以在

178
00:07:05,849 --> 00:07:08,789
我们正在处理的当前十年中，我实际上

179
00:07:08,789 --> 00:07:11,939
非常兴奋，因为我认为我

180
00:07:11,939 --> 00:07:14,219
认为它会是 Wild 西部

181
00:07:14,219 --> 00:07:17,490
再次就每个人都会尝试的

182
00:07:17,490 --> 00:07:19,919
一切而言我认为硬件中有很多

183
00:07:19,919 --> 00:07:21,270
有趣的东西

184
00:07:21,270 --> 00:07:24,899
可能不是

185
00:07:24,899 --> 00:07:28,110
专门为数据库系统设计的，而是

186
00:07:28,110 --> 00:07:29,819
为数据密集型应用程序设计的 如果你

187
00:07:29,819 --> 00:07:31,020
想称之为包括

188
00:07:31,020 --> 00:07:32,490
机器学习或数据科学的东西，

189
00:07:32,490 --> 00:07:35,699
但数据库是那种堆栈中的关键组件

190
00:07:35,699 --> 00:07:38,399
，我

191
00:07:38,399 --> 00:07:39,509
认为我们可以

192
00:07:39,509 --> 00:07:41,069
开始将一些东西整合到数据库系统中，

193
00:07:41,069 --> 00:07:42,569
并且仍然需要考虑

194
00:07:42,569 --> 00:07:44,999
商品硬件，

195
00:07:44,999 --> 00:07:46,439
所以我们今天要讨论的主要内容是

196
00:07:46,439 --> 00:07:49,559
持久性内存，以及

197
00:07:49,559 --> 00:07:51,120
如何设计数据中心来处理这个问题

198
00:07:51,120 --> 00:07:53,399
我认为这将是这十年的重大变化

199
00:07:53,399 --> 00:07:56,639
FPGA 和 GPU 仍然

200
00:07:56,639 --> 00:08:00,209
是 我认为仍然有一些

201
00:08:00,209 --> 00:08:04,979
小众玩家我没有看到我没有看到

202
00:08:04,979 --> 00:08:07,529
他们像每个数据库系统

203
00:08:07,529 --> 00:08:10,529
都必须有一个 GPU 或 FPGA 类型

204
00:08:10,529 --> 00:08:14,689
的加速器组件因为它

205
00:08:14,689 --> 00:08:17,509
大多数数据库将在

206
00:08:17,509 --> 00:08:19,709
戴维斯主义上运行 将在它上面运行你知道

207
00:08:19,709 --> 00:08:25,169
英特尔 CPU 超越了 FPGA 是

208
00:08:25,169 --> 00:08:26,819
这些东西被称为可配置空间

209
00:08:26,819 --> 00:08:29,129
加速器 想想这就像一个

210
00:08:29,129 --> 00:08:32,578
FPGA 有一个可编程的硬件

211
00:08:32,578 --> 00:08:35,639
，而不是做那种

212
00:08:35,639 --> 00:08:38,009
逻辑 FPGA 是做它更多的是

213
00:08:38,009 --> 00:08:41,009
数据流的事情，再一次，当我说

214
00:08:41,009 --> 00:08:43,198
更多时，我的意思是它的硬颗粒

215
00:08:43,198 --> 00:08:47,399
会出现，否则我的制造成本

216
00:08:47,399 --> 00:08:48,380
应该会下降，

217
00:08:48,380 --> 00:08:52,530
特别是对于 70

218
00:08:52,530 --> 00:08:54,240
纳米之类的更大尺寸的

219
00:08:54,240 --> 00:08:58,170
晶体管，所以人们 可以

220
00:08:58,170 --> 00:09:01,200
比以前更便宜地开始增肥

221
00:09:01,200 --> 00:09:02,910
，

222
00:09:02,910 --> 00:09:04,770
因此规模经济对

223
00:09:04,770 --> 00:09:06,750
我们有很大帮助，所以

224
00:09:06,750 --> 00:09:08,250
今天我们将再次关注这一点，我们将

225
00:09:08,250 --> 00:09:12,060
谈谈 GPU，但我认为 在接下来的 10

226
00:09:12,060 --> 00:09:13,170
年里，我认为会有更多的东西

227
00:09:13,170 --> 00:09:15,170
出现，我会很酷，

228
00:09:15,170 --> 00:09:18,510
所以我说我们想

229
00:09:18,510 --> 00:09:20,090
在谈论持久内存时

230
00:09:20,090 --> 00:09:21,720
让我们旋转，我们将谈论如何

231
00:09:21,720 --> 00:09:23,790
加速事情 使用 GPU，然后

232
00:09:23,790 --> 00:09:25,860
我们将结束讨论哈佛

233
00:09:25,860 --> 00:09:27,270
事务内存，因为这个问题

234
00:09:27,270 --> 00:09:29,250
也经常被学生问

235
00:09:29,250 --> 00:09:31,410
到哦，你知道这是我

236
00:09:31,410 --> 00:09:32,910
可以使用的东西，而不是如何

237
00:09:32,910 --> 00:09:34,770
做我们讨论过的所有内核或锁存的东西

238
00:09:34,770 --> 00:09:37,620
吨 这个学期，答案

239
00:09:37,620 --> 00:09:39,510
是否定的，我们仍然需要做

240
00:09:39,510 --> 00:09:41,460
我们迄今为止讨论过的所有事情

241
00:09:41,460 --> 00:09:44,040
，这在小情况下可能会有所帮助

242
00:09:44,040 --> 00:09:45,950


243
00:09:45,950 --> 00:09:51,000


244
00:09:51,000 --> 00:09:53,100


245
00:09:53,100 --> 00:09:56,670
我们在

246
00:09:56,670 --> 00:09:59,220
介绍课上讨论

247
00:09:59,220 --> 00:10:01,920
了易失性和非易失性

248
00:10:01,920 --> 00:10:05,130
存储之间的这种二分法，以及我们如何设计或

249
00:10:05,130 --> 00:10:07,260
面向磁盘的数据库系统来

250
00:10:07,260 --> 00:10:08,790
解决这些差异，当然还有

251
00:10:08,790 --> 00:10:10,320
最后一节课，当我们讨论

252
00:10:10,320 --> 00:10:12,150
更大的内存数据库时，我们

253
00:10:12,150 --> 00:10:14,040
需要注意，我们的数据库可能

254
00:10:14,040 --> 00:10:16,950
已经将数据写入

255
00:10:16,950 --> 00:10:18,660
到一个非易失性的基于块的存储

256
00:10:18,660 --> 00:10:20,820
设备中，该设备的速度要慢得多，所以我们必须让

257
00:10:20,820 --> 00:10:22,710
您知道设计我们的算法和我们的

258
00:10:22,710 --> 00:10:24,180
层次结构以

259
00:10:24,180 --> 00:10:26,610
解决非易失性 内存或作为

260
00:10:26,610 --> 00:10:29,070
持久内存的想法是，我们

261
00:10:29,070 --> 00:10:32,340
将获得几乎 DRAM 的速度，并

262
00:10:32,340 --> 00:10:35,750
拥有一个可寻址字节地址的访问接口，

263
00:10:35,750 --> 00:10:38,060
如

264
00:10:38,060 --> 00:10:42,570
DRAM 在

265
00:10:42,570 --> 00:10:45,930
我们所有的读取和写入中，即使在

266
00:10:45,930 --> 00:10:48,780
断电之后我也明白为什么它被称为

267
00:10:48,780 --> 00:10:50,550
持久性内存，所以

268
00:10:50,550 --> 00:10:52,740
在本次讲座期间我会多次滑倒

269
00:10:52,740 --> 00:10:54,720
并继续称其为非易失性

270
00:10:54,720 --> 00:10:55,860
内存，因为这就是我们在我们之前

271
00:10:55,860 --> 00:10:57,000
所说的

272
00:10:57,000 --> 00:11:01,740
早在 2013 年就开始进行这项研究，业界

273
00:11:01,740 --> 00:11:03,930
标准化称这种持久性

274
00:11:03,930 --> 00:11:05,370
内存我实际上同意这是一个

275
00:11:05,370 --> 00:11:07,290
更好的术语

276
00:11:07,290 --> 00:11:07,710


277
00:11:07,710 --> 00:11:09,960


278
00:11:09,960 --> 00:11:11,570


279
00:11:11,570 --> 00:11:15,300


280
00:11:15,300 --> 00:11:17,070
可用的内存设备这有点

281
00:11:17,070 --> 00:11:20,310
令人困惑，因为它们就像 PCI

282
00:11:20,310 --> 00:11:21,600
Express 卡，它们是块

283
00:11:21,600 --> 00:11:24,450
可寻址的，即使其中的存储

284
00:11:24,450 --> 00:11:27,090
介质

285
00:11:27,090 --> 00:11:28,800
与精密内存中的存储介质相同，

286
00:11:28,800 --> 00:11:31,140
或者在这里谈论它只是

287
00:11:31,140 --> 00:11:35,100
通过一个 你知道 PCI 接口，但

288
00:11:35,100 --> 00:11:36,690
现在从英特尔实际可用的新接口

289
00:11:36,690 --> 00:11:39,150
将是字节可寻址的，

290
00:11:39,150 --> 00:11:41,160
所以它看起来和闻起来都是 exa 确实

291
00:11:41,160 --> 00:11:45,180
喜欢 DRAM 到您的应用程序，但是

292
00:11:45,180 --> 00:11:46,920
有一些额外的东西

293
00:11:46,920 --> 00:11:47,940
需要封面并确保

294
00:11:47,940 --> 00:11:50,730
一切都是持久的 我必须

295
00:11:50,730 --> 00:11:55,010
让梗犬进入所以让我们谈谈

296
00:11:55,010 --> 00:11:57,390
这就是为什么我们到达我们的位置

297
00:11:57,390 --> 00:11:59,370
因为山茶花的背景故事实际上

298
00:11:59,370 --> 00:12:01,050
非常有趣并且

299
00:12:01,050 --> 00:12:03,750
我让你知道的部分原因是我花了

300
00:12:03,750 --> 00:12:06,000
几年时间

301
00:12:06,000 --> 00:12:09,180
和我的第一个 PC 学生一起研究数据库中的持久内存，

302
00:12:09,180 --> 00:12:13,020
所以如果你学习，如果你的电气

303
00:12:13,020 --> 00:12:13,860
工程师和你学习，你就会了解

304
00:12:13,860 --> 00:12:16,580


305
00:12:16,580 --> 00:12:19,140
他们将描述的电路基础课程 三种类型的电路，

306
00:12:19,140 --> 00:12:21,330
我们将讨论

307
00:12:21,330 --> 00:12:24,060
1745 年发明的电容器，但这是

308
00:12:24,060 --> 00:12:26,190
像电池一样存储一些电荷的能力，

309
00:12:26,190 --> 00:12:29,430
后来发明了电阻

310
00:12:29,430 --> 00:12:32,910
器来修改电路上的电压

311
00:12:32,910 --> 00:12:35,580
，然后如果

312
00:12:35,580 --> 00:12:37,460
几年后他们开发了

313
00:12:37,460 --> 00:12:40,410
电感器，它只是

314
00:12:40,410 --> 00:12:46,890
将电压转换为热量的一种方式，所以在 1831 年之后

315
00:12:46,890 --> 00:12:49,230
，人们只是假设这些是

316
00:12:49,230 --> 00:12:51,690
三个基本的 c  ircuits

317
00:12:51,690 --> 00:12:53,610
不可能有像你

318
00:12:53,610 --> 00:12:54,720
这样的东西 思考这个问题的方式是你不能

319
00:12:54,720 --> 00:12:57,060


320
00:12:57,060 --> 00:12:59,700
使用其他构建任何其他类型的电路 抱歉这些

321
00:12:59,700 --> 00:13:01,650
元素中的任何一个使用另一种元素和

322
00:13:01,650 --> 00:13:02,790
那种东西来查看原子

323
00:13:02,790 --> 00:13:08,610
电路的元素，所以在

324
00:13:08,610 --> 00:13:10,920
1971 年，

325
00:13:10,920 --> 00:13:14,190
伯克利的 Leon Chua 教授正在研究一些

326
00:13:14,190 --> 00:13:15,240
方程

327
00:13:15,240 --> 00:13:20,339
，他做到了并

328
00:13:20,339 --> 00:13:22,200
发现似乎应该有

329
00:13:22,200 --> 00:13:25,290
第四种类型的元素，因为

330
00:13:25,290 --> 00:13:28,560
数学计算的方式 是因为方程中

331
00:13:28,560 --> 00:13:30,240
缺少这个 Kapena

332
00:13:30,240 --> 00:13:31,680
组件，你必须

333
00:13:31,680 --> 00:13:34,980
有另一个第四个元素才能

334
00:13:34,980 --> 00:13:36,690
使数学真正正确地计算出来

335
00:13:36,690 --> 00:13:39,600
，所以他假设

336
00:13:39,600 --> 00:13:41,790
有一个两端设备，该设备的

337
00:13:41,790 --> 00:13:45,450
电阻取决于 在

338
00:13:45,450 --> 00:13:48,060
施加到它的电压上，所以它

339
00:13:48,060 --> 00:13:50,339
就像一个电阻器，但不同

340
00:13:50,339 --> 00:13:52,350
的是你实际上可以改变它的

341
00:13:52,350 --> 00:13:54,300
电阻，这取决于你

342
00:13:54,300 --> 00:13:56,370
给它的电压和 当你关闭

343
00:13:56,370 --> 00:13:58,310
那个电压时，它会永久地

344
00:13:58,310 --> 00:14:01,440
记住它的最后一个电阻状态

345
00:14:01,440 --> 00:14:02,310


346
00:14:02,310 --> 00:14:05,610
，所以他假设

347
00:14:05,610 --> 00:14:07,290
有第四个元素叫做

348
00:14:07,290 --> 00:14:10,200
mem risker 所以他在 1971 年写了一篇关于这个的论文

349
00:14:10,200 --> 00:14:14,250
，它有点被时间遗忘了，

350
00:14:14,250 --> 00:14:16,020
因为它 有很多引用，它是

351
00:14:16,020 --> 00:14:18,200
非常数学化的，没有人理解它

352
00:14:18,200 --> 00:14:22,410
，它基本上被遗忘

353
00:14:22,410 --> 00:14:26,430
了现在到 2000 年代初

354
00:14:26,430 --> 00:14:29,910
，惠普实验室的这个团队正在

355
00:14:29,910 --> 00:14:33,870
尝试构建某种自我配置的

356
00:14:33,870 --> 00:14:37,620
纳米设备以及他们发现的东西

357
00:14:37,620 --> 00:14:39,660
在他们的实验中，这些纳米

358
00:14:39,660 --> 00:14:43,050
设备将具有某些

359
00:14:43,050 --> 00:14:44,579
他们所做的特性 他们无法理解

360
00:14:44,579 --> 00:14:45,870
为什么他们为什么要做

361
00:14:45,870 --> 00:14:48,149
某些事情，特别

362
00:14:48,149 --> 00:14:49,770
是当你给他们一个电压时，

363
00:14:49,770 --> 00:14:53,310
他们会改变他们会

364
00:14:53,310 --> 00:14:54,600
改变 你在他们试图建造的赛道中看到的阻力

365
00:14:54,600 --> 00:14:56,700


366
00:14:56,700 --> 00:14:59,550
，所以他们看了看，

367
00:14:59,550 --> 00:15:00,360
他们无法弄清楚它是什么，

368
00:15:00,360 --> 00:15:01,560
他们一直保持着 在

369
00:15:01,560 --> 00:15:03,060
文献中很好，然后他们偶然发现

370
00:15:03,060 --> 00:15:06,420
了 Chua 1971 年发表的论文

371
00:15:06,420 --> 00:15:10,050
，上面说哦，你知道

372
00:15:10,050 --> 00:15:11,550
还有另外四分之一有一个

373
00:15:11,550 --> 00:15:13,680
你需要的电路实际上可能存在我们只是

374
00:15:13,680 --> 00:15:15,240
不知道如何构建它然后

375
00:15:15,240 --> 00:15:16,910
他们确定实际上是

376
00:15:16,910 --> 00:15:20,490
他们在那里惠普实验室

377
00:15:20,490 --> 00:15:22,589
实际上并且喜欢意外地构建

378
00:15:22,589 --> 00:15:25,380
一个或两个非常有趣的忆阻器，

379
00:15:25,380 --> 00:15:27,150
部分原因是他们

380
00:15:27,150 --> 00:15:28,800
发现他们构建的

381
00:15:28,800 --> 00:15:32,310
东西与您

382
00:15:32,310 --> 00:15:35,339
假设的相同 像

383
00:15:35,339 --> 00:15:36,480
显示这种

384
00:15:36,480 --> 00:15:39,209
滞后回路的电路图以及他们

385
00:15:39,209 --> 00:15:41,130
测量的内容与他提出的完全匹配，

386
00:15:41,130 --> 00:15:44,190
或者在他的猜想中

387
00:15:44,190 --> 00:15:46,230
这应该是这样的，所以他们

388
00:15:46,230 --> 00:15:50,040
回去了，为此他们

389
00:15:50,040 --> 00:15:52,310
写了我们如何发现 失踪的忆阻器

390
00:15:52,310 --> 00:15:55,320
他们回去查看了

391
00:15:55,320 --> 00:15:57,510
过去 100 年的电气工程

392
00:15:57,510 --> 00:16:00,570
科学出版物，他们发现

393
00:16:00,570 --> 00:16:02,399
其他一些人报告了同样的

394
00:16:02,399 --> 00:16:04,910
问题 在他们的实验中发现了磁滞回线，

395
00:16:04,910 --> 00:16:07,140
但没有人能

396
00:16:07,140 --> 00:16:08,760
解释它发生了什么，所以人们多年来一直

397
00:16:08,760 --> 00:16:10,410
在偶然发现忆阻器，

398
00:16:10,410 --> 00:16:12,120
但实际上没有人

399
00:16:12,120 --> 00:16:14,720
知道他们实际上在制造什么，所以

400
00:16:14,720 --> 00:16:16,980
惠普发布了这个重大公告，他们

401
00:16:16,980 --> 00:16:19,170
已经有了他们 发现先生。

402
00:16:19,170 --> 00:16:21,029
这是他们

403
00:16:21,029 --> 00:16:23,220
能够在实验室中可靠地复制的

404
00:16:23,220 --> 00:16:24,630
东西，他们认为他们实际上可以

405
00:16:24,630 --> 00:16:26,339
继续下一步制造它，

406
00:16:26,339 --> 00:16:28,829
这将成为计算领域的重大游戏变革，

407
00:16:28,829 --> 00:16:33,000


408
00:16:33,000 --> 00:16:37,350
以至于就像 2008 年一样 他们有一个

409
00:16:37,350 --> 00:16:39,899
像我说的那样的大型演讲，无论在任何

410
00:16:39,899 --> 00:16:41,970
年度会议上讨论

411
00:16:41,970 --> 00:16:44,880
他们在忆阻器方面的工作，你

412
00:16:44,880 --> 00:16:46,680
都可以在这里看到，我认为这是

413
00:16:46,680 --> 00:16:49,350
在 2007 年出现的，所以他们在 2006 年发现它

414
00:16:49,350 --> 00:16:52,470
证明了 2007 年

415
00:16:52,470 --> 00:16:54,959
在这个会议上实际上是真实的 2008 年 他们

416
00:16:54,959 --> 00:16:56,490
声称忆阻器将做好开发准备

417
00:16:56,490 --> 00:16:58,980
，然后在不久的将来他们

418
00:16:58,980 --> 00:17:01,380
将声称忆阻器

419
00:17:01,380 --> 00:17:05,040
将取代所有 DRAM 和硬盘驱动器、

420
00:17:05,040 --> 00:17:06,480
SSD 和晶体管以及

421
00:17:06,480 --> 00:17:09,630
我们将要使用忆阻器的所有东西 所以

422
00:17:09,630 --> 00:17:13,410
这已经超过 10 年了 以前他没有

423
00:17:13,410 --> 00:17:16,109
消失 SSD 没有消失 因为他的

424
00:17:16,109 --> 00:17:21,078
硬盘没有消失 所以发生了什么事

425
00:17:21,890 --> 00:17:24,150
据我所知 HP 还没有

426
00:17:24,150 --> 00:17:27,240
生产或出货忆阻器

427
00:17:27,240 --> 00:17:32,790
产品 惠普最终也

428
00:17:32,790 --> 00:17:35,010
像消费者方面和企业方面一样分裂，

429
00:17:35,010 --> 00:17:37,320
他们

430
00:17:37,320 --> 00:17:38,580
有这个被称为

431
00:17:38,580 --> 00:17:40,470
机器的登月项目，据我所知，该项目将完全

432
00:17:40,470 --> 00:17:42,929
脱离忆阻器

433
00:17:42,929 --> 00:17:45,659
，在这一点上已被取消

434
00:17:45,659 --> 00:17:47,340
我不知道团队

435
00:17:47,340 --> 00:17:48,809
成员是否会最不从惠普出来，

436
00:17:48,809 --> 00:17:53,159
所以让我们谈谈其他类型的

437
00:17:53,159 --> 00:17:54,240
持久内存，或者让我们

438
00:17:54,240 --> 00:17:59,070
现在不了解

439
00:17:59,070 --> 00:18:00,690
我们今天要讨论的

440
00:18:00,690 --> 00:18:03,929
英特尔设备的忆阻器是什么

441
00:18:03,929 --> 00:18:06,749
它可能是什么以及一些

442
00:18:06,749 --> 00:18:08,039
未来的技术实际上

443
00:18:08,039 --> 00:18:10,379
会是什么样子 安全性也

444
00:18:10,379 --> 00:18:12,600
就像我喝了 HP 的 kool-aid

445
00:18:12,600 --> 00:18:14,909
虽然我与他们没有任何关系

446
00:18:14,909 --> 00:18:17,789
我认为忆阻器很重要

447
00:18:17,789 --> 00:18:20,190
我真的很兴奋 我想走

448
00:18:20,190 --> 00:18:21,690
这条路的原因是在卡内基梅隆做持久的

449
00:18:21,690 --> 00:18:23,809
记忆研究

450
00:18:23,809 --> 00:18:26,399
，我总是

451
00:18:26,399 --> 00:18:29,399
觉得忆阻器总是

452
00:18:29,399 --> 00:18:31,649
晚两年到我们两年之后

453
00:18:31,649 --> 00:18:33,869
就像每次惠普召开新闻

454
00:18:33,869 --> 00:18:35,340
发布会 每次惠普每个系统和

455
00:18:35,340 --> 00:18:35,789
公开

456
00:18:35,789 --> 00:18:37,379
展示 就像两年后

457
00:18:37,379 --> 00:18:38,879
两年后两年 然后

458
00:18:38,879 --> 00:18:40,169
你到了接下来的两年 然后

459
00:18:40,169 --> 00:18:41,279
出来说同样的话 两年后

460
00:18:41,279 --> 00:18:43,830
再过或两年之后，它

461
00:18:43,830 --> 00:18:47,369
从未发生过，嗯，但英特尔实际上

462
00:18:47,369 --> 00:18:49,980
发货了，发货了一个设备，

463
00:18:49,980 --> 00:18:51,059
这是相变内存中的第一个设备，

464
00:18:51,059 --> 00:18:53,159
这非常令人兴奋，所以让我们

465
00:18:53,159 --> 00:18:54,029
再一次逐一讨论

466
00:18:54,029 --> 00:18:56,429
这不是具体的 数据库

467
00:18:56,429 --> 00:18:57,990
只是让你了解

468
00:18:57,990 --> 00:19:00,299


469
00:19:00,299 --> 00:19:03,509
这项技术背后发生了什么，所以

470
00:19:03,509 --> 00:19:06,269
相变存储器的想法是你

471
00:19:06,269 --> 00:19:10,440
有一个有两个金属电极的存储单元，

472
00:19:10,440 --> 00:19:13,559


473
00:19:13,559 --> 00:19:17,450
然后你把 充电

474
00:19:17,840 --> 00:19:20,539
到这种相变材料

475
00:19:20,539 --> 00:19:22,759
中，它是煅烧 ID 并且

476
00:19:22,759 --> 00:19:28,619
基本上烘烤或烹饪材料

477
00:19:28,619 --> 00:19:31,440
，以便能够正确地改变电路的电阻，

478
00:19:31,440 --> 00:19:34,080
所以如果你给它一个

479
00:19:34,080 --> 00:19:36,119
短脉冲 然后将单元格

480
00:19:36,119 --> 00:19:37,200
更改为零，因为

481
00:19:37,200 --> 00:19:38,340
如果我们将其更改

482
00:19:38,340 --> 00:19:41,009
为长渐进脉冲，则会为您提供不同的电阻，然后将其

483
00:19:41,009 --> 00:19:43,710
更改为 1，我再次在这里展示这个

484
00:19:43,710 --> 00:19:45,419
加热器，实际上你知道

485
00:19:45,419 --> 00:19:47,220
它不是一个 它下面的小火柴，

486
00:19:47,220 --> 00:19:48,720
但在盖子下面，你给

487
00:19:48,720 --> 00:19:50,340
它短充电或更快

488
00:19:50,340 --> 00:19:54,419
充电，然后变成 1 1 0 1 所以

489
00:19:54,419 --> 00:19:55,480


490
00:19:55,480 --> 00:19:57,400
相变存储器的想法

491
00:19:57,400 --> 00:19:59,410
已经存在一段时间了，人们已经

492
00:19:59,410 --> 00:20:00,820
知道它们了 并说没有人

493
00:20:00,820 --> 00:20:04,330
能够大规模制造它们，

494
00:20:04,330 --> 00:20:07,810


495
00:20:07,810 --> 00:20:10,360
据我所知，我们将谈论的英特尔选择 DC 内存

496
00:20:10,360 --> 00:20:12,730
实际上是相变内存，这不是

497
00:20:12,730 --> 00:20:14,830
他们没有公开说过，至少我

498
00:20:14,830 --> 00:20:17,080
认为他们没有 有，但是当

499
00:20:17,080 --> 00:20:19,150
设备第一次出现时，韩国的某个人

500
00:20:19,150 --> 00:20:21,250
把它拿出来切割，你知道，

501
00:20:21,250 --> 00:20:23,440
但是打开设备并

502
00:20:23,440 --> 00:20:25,690
在电子显微镜下观察它，

503
00:20:25,690 --> 00:20:27,490
发现它在相

504
00:20:27,490 --> 00:20:31,000
变存储器中实际上很高，所以这有一些

505
00:20:31,000 --> 00:20:33,820
缺点 不 w 因为你

506
00:20:33,820 --> 00:20:36,040
实际上必须在这里充电，这显然

507
00:20:36,040 --> 00:20:38,770
会产生一些热量，从而

508
00:20:38,770 --> 00:20:41,170
防止你潜在地存储

509
00:20:41,170 --> 00:20:46,000
在 CPU 本身上，我

510
00:20:46,000 --> 00:20:47,140
知道你只能

511
00:20:47,140 --> 00:20:49,450
在它磨损之前写入它很多次 所以你知道

512
00:20:49,450 --> 00:20:52,270
ehh 内存在这里 它很快 它存在

513
00:20:52,270 --> 00:20:54,930
并且你可以购买大容量

514
00:20:54,930 --> 00:20:58,570
但你知道与内存商店相比我

515
00:20:58,570 --> 00:21:00,580
认为我认为这是一种劣质

516
00:21:00,580 --> 00:21:02,740
技术但当然它存在你

517
00:21:02,740 --> 00:21:04,630
今天可以购买你不能 购买内存

518
00:21:04,630 --> 00:21:05,730
很好，

519
00:21:05,730 --> 00:21:09,880
所以内存存储是

520
00:21:09,880 --> 00:21:11,650
一种令人困惑

521
00:21:11,650 --> 00:21:14,710
的电路基本电路元件的忆阻器

522
00:21:14,710 --> 00:21:17,140


523
00:21:17,140 --> 00:21:20,260
然后实际上包括

524
00:21:20,260 --> 00:21:22,630
自旋电子学的面部记忆但是然后

525
00:21:22,630 --> 00:21:24,910
就像惠普营销他们会称之为

526
00:21:24,910 --> 00:21:27,870
任何东西 他们正在出售忆阻器，

527
00:21:27,870 --> 00:21:32,260
但这些

528
00:21:32,260 --> 00:21:33,550
是他们所

529
00:21:33,550 --> 00:21:37,240
构建的这种科学定义被称为电阻 Ram

530
00:21:37,240 --> 00:21:38,860
其工作方式是你有

531
00:21:38,860 --> 00:21:45,280
两层 二

532
00:21:45,280 --> 00:21:47,440
氧化钛 上面有两个二氧化钛

533
00:21:47,440 --> 00:21:48,570


534
00:21:48,570 --> 00:21:52,060
中间的两层上面有两个二氧化钛 铂

535
00:21:52,060 --> 00:21:54,400
金 铂金会带电

536
00:21:54,400 --> 00:21:59,140
如果你

537
00:21:59,140 --> 00:22:01,600
朝一个方向运行电荷 你会

538
00:22:01,600 --> 00:22:03,400
改变电阻状态 如果你

539
00:22:03,400 --> 00:22:04,660
在另一个方向改变电荷，

540
00:22:04,660 --> 00:22:06,580
你改变你改变电阻

541
00:22:06,580 --> 00:22:08,800
日期，所以这个想法就像在

542
00:22:08,800 --> 00:22:11,950


543
00:22:11,950 --> 00:22:13,720
这两个不同层之间有浮动电子，这

544
00:22:13,720 --> 00:22:17,980
就是你所说的它是 0 或 1 所以

545
00:22:17,980 --> 00:22:20,350
关于忆阻器很酷的事情 再次为什么我

546
00:22:20,350 --> 00:22:22,270
对它们感到兴奋就像二

547
00:22:22,270 --> 00:22:24,670
氧化钛是一种非常常见的元素它

548
00:22:24,670 --> 00:22:26,530
与

549
00:22:26,530 --> 00:22:28,540
您涂在脸上的白色房屋油漆或防晒霜中的成分相同，

550
00:22:28,540 --> 00:22:32,320
所以它不像某些您知道的某些

551
00:22:32,320 --> 00:22:34,630
晦涩材料必须

552
00:22:34,630 --> 00:22:36,640
制造白金 显然

553
00:22:36,640 --> 00:22:40,240
不是很常见，但是对于微小的

554
00:22:40,240 --> 00:22:41,710
二氧化物，你知道它有

555
00:22:41,710 --> 00:22:44,110
很多，所以它会非常便宜而且

556
00:22:44,110 --> 00:22:48,760
实际上超高密度你

557
00:22:48,760 --> 00:22:50,290
知道每平方拍字节 厘米，

558
00:22:50,290 --> 00:22:52,630
因为你知道你

559
00:22:52,630 --> 00:22:54,100
通过它发送的电流比

560
00:22:54,100 --> 00:22:55,870
那时小得多 相变记得

561
00:22:55,870 --> 00:22:58,210
改变状态 另一个

562
00:22:58,210 --> 00:23:00,580
有趣的关于

563
00:23:00,580 --> 00:23:04,180
内存搅拌或电阻性的事情是，惠普

564
00:23:04,180 --> 00:23:08,260
正在谈论你如何 可以将

565
00:23:08,260 --> 00:23:11,340
存储结构或存储介质用于

566
00:23:11,340 --> 00:23:14,410
可执行逻辑，因此他们讨论了

567
00:23:14,410 --> 00:23:17,230
如何像 FPGA 一样实际更改它，

568
00:23:17,230 --> 00:23:20,560
将程序加载

569
00:23:20,560 --> 00:23:25,210
到内存上，并在

570
00:23:25,210 --> 00:23:27,940
数据从内存中流出时将其流

571
00:23:27,940 --> 00:23:29,920
过 你的逻辑门并做任何

572
00:23:29,920 --> 00:23:31,420
你想要的额外处理，

573
00:23:31,420 --> 00:23:33,130
所以你认为我

574
00:23:33,130 --> 00:23:35,350
可以像在内存计算中一样我可以

575
00:23:35,350 --> 00:23:38,050
对列进行扫描并有一些

576
00:23:38,050 --> 00:23:39,880
执行器逻辑门来应用过滤器

577
00:23:39,880 --> 00:23:44,080
，然后成本 与 FPGA 相比，

578
00:23:44,080 --> 00:23:46,870
即时更改执行的逻辑非常

579
00:23:46,870 --> 00:23:51,580
便宜，因此您喜欢

580
00:23:51,580 --> 00:23:53,680
按查询加载，因此所有

581
00:23:53,680 --> 00:23:54,670
这些都在谈论他们如何构建

582
00:23:54,670 --> 00:23:56,320
神经网络和忆阻器 他们

583
00:23:56,320 --> 00:23:59,530
可以用大约 10 年前的忆阻器对大脑进行建模

584
00:23:59,530 --> 00:24:01,270


585
00:24:01,270 --> 00:24:03,660
，从那时起

586
00:24:03,660 --> 00:24:09,430
我就再也没有听说过关于成员的逻辑的另一件事

587
00:24:09,430 --> 00:24:12,910
是它不会

588
00:24:12,910 --> 00:24:14,830
使用传统的基于 NAND 的

589
00:24:14,830 --> 00:24:18,160
逻辑我们 在我们现在拥有的 CPU 中

590
00:24:18,160 --> 00:24:19,630
使用它实际上会使用一种叫做

591
00:24:19,630 --> 00:24:22,500
物质蕴涵的东西，它是

592
00:24:22,500 --> 00:24:24,590
伟大的哲学家伯特兰

593
00:24:24,590 --> 00:24:27,450
罗素在 1910 年代发明的，所以

594
00:24:27,450 --> 00:24:28,860


595
00:24:28,860 --> 00:24:30,480
如果你在

596
00:24:30,480 --> 00:24:33,419
忆阻器上运行，它是一种完全不同的计算方式，当然你知道 它从来没有

597
00:24:33,419 --> 00:24:38,549
发生过，还没有发生，所以

598
00:24:38,549 --> 00:24:40,380
思考这三种介质的方式

599
00:24:40,380 --> 00:24:41,429
也在谈论光，

600
00:24:41,429 --> 00:24:43,110
就像现在存在相变

601
00:24:43,110 --> 00:24:45,210
存储器一样，忆阻器

602
00:24:45,210 --> 00:24:47,730
可能在不久的将来，然后再

603
00:24:47,730 --> 00:24:49,770
远一点 将是这种

604
00:24:49,770 --> 00:24:52,919
抗磁 RAM 或自旋电子学，并且对于

605
00:24:52,919 --> 00:24:55,730
这个而不是实际存储

606
00:24:55,730 --> 00:24:58,110
而不是实际存储或

607
00:24:58,110 --> 00:25:00,840
更改存储介质以记录以

608
00:25:00,840 --> 00:25:03,450
记录 ch  arge 我们要

609
00:25:03,450 --> 00:25:08,070
改变 我们要使用

610
00:25:08,070 --> 00:25:10,799
磁铁

611
00:25:10,799 --> 00:25:12,450
来移动电子

612
00:25:12,450 --> 00:25:14,340


613
00:25:14,340 --> 00:25:17,039


614
00:25:17,039 --> 00:25:20,970
位 B 0 1 然后据说这

615
00:25:20,970 --> 00:25:23,640
不仅使用更少的能量，而且具有

616
00:25:23,640 --> 00:25:25,830
更小的比例因子，因此您可以将其

617
00:25:25,830 --> 00:25:27,720
存储，就像您可以将它们

618
00:25:27,720 --> 00:25:31,530
以每位 10 纳米的速度存储一样，并且

619
00:25:31,530 --> 00:25:34,020
速度几乎等同于您的 CPU

620
00:25:34,020 --> 00:25:37,289
缓存 并且喜欢使用静态 RAM SRAM，因此

621
00:25:37,289 --> 00:25:40,289
您现在可以用自旋电子学替换您所有的 l1

622
00:25:40,289 --> 00:25:44,580
l2 l3 缓存，

623
00:25:44,580 --> 00:25:46,289
因为它具有更高的

624
00:25:46,289 --> 00:25:48,530
容量

625
00:25:48,530 --> 00:25:52,590
，在 CPU 上制造成本更低，而且您知道

626
00:25:52,590 --> 00:25:57,210
您基本上拥有持久的 l4，它是

627
00:25:57,210 --> 00:25:59,460
就像延迟小于 D Ram 所以

628
00:25:59,460 --> 00:26:01,880
这真是太神奇了，如果它存在的话，

629
00:26:01,880 --> 00:26:04,289
这将是一个巨大的游戏规则改变者

630
00:26:04,289 --> 00:26:06,840
我认为对于所有这些，实际上 Mel

631
00:26:06,840 --> 00:26:08,190
确定记忆的作用是我的第一个

632
00:26:08,190 --> 00:26:09,600
自旋电子学和第一个患者在

633
00:26:09,600 --> 00:26:12,360
他们之前的记忆中 像

634
00:26:12,360 --> 00:26:16,980
您可以购买的 DRAM 坝替代

635
00:26:16,980 --> 00:26:18,510
品一样制造就像手机之类的小规模因素

636
00:26:18,510 --> 00:26:20,100
一样

637
00:26:20,100 --> 00:26:21,780
所以你可以得到我想现在你可以

638
00:26:21,780 --> 00:26:24,690
得到自旋电子学 DRAM 或自旋电子学

639
00:26:24,690 --> 00:26:27,270
Ram 16 兆字节的容量

640
00:26:27,270 --> 00:26:29,700
肯定不足以满足我们的需求 需要

641
00:26:29,700 --> 00:26:31,200
和一个数据库系统，但就像你知道

642
00:26:31,200 --> 00:26:33,030
它确实存在，只是规模不大，

643
00:26:33,030 --> 00:26:35,240


644
00:26:35,240 --> 00:26:39,080
所以为什么这是真的

645
00:26:39,080 --> 00:26:43,440
那么四个三个三个原因为什么你

646
00:26:43,440 --> 00:26:45,300
知道持久内存实际上是一个

647
00:26:45,300 --> 00:26:46,800
我们现在需要在我们的

648
00:26:46,800 --> 00:26:48,630
数据库系统中考虑的事情 众星

649
00:26:48,630 --> 00:26:51,240
云集，以至于我们需要

650
00:26:51,240 --> 00:26:54,180
了解这项技术，并

651
00:26:54,180 --> 00:26:56,210
在我们设计新系统时实际考虑它，

652
00:26:56,210 --> 00:26:59,310
因此行业中的第一个已经

653
00:26:59,310 --> 00:27:02,570
就这些设备的标准技术

654
00:27:02,570 --> 00:27:05,880
命名法和外形因素达成一致，

655
00:27:05,880 --> 00:27:08,400
所以就有了这个东西 所谓的 j

656
00:27:08,400 --> 00:27:09,780
甲板基本上

657
00:27:09,780 --> 00:27:11,640
是一群制造商之间的联盟，他们说好的，

658
00:27:11,640 --> 00:27:13,380
如果我们制造非易失性存储器，

659
00:27:13,380 --> 00:27:15,360
这就是形状因素必须是什么

660
00:27:15,360 --> 00:27:16,530
对，

661
00:27:16,530 --> 00:27:19,440
我有点喜欢 DRAM，对，你知道

662
00:27:19,440 --> 00:27:21,120
有，你知道有 DRM

663
00:27:21,120 --> 00:27:22,740
23 和 4 就像一个财团

664
00:27:22,740 --> 00:27:24,180
决定这

665
00:27:24,180 --> 00:27:26,430
就是规格是什么，然后所有

666
00:27:26,430 --> 00:27:28,350
制造商都可以去

667
00:27:28,350 --> 00:27:31,140
制造相同的 你知道 sin 制造

668
00:27:31,140 --> 00:27:34,560
遵循该规范的设备

669
00:27:34,560 --> 00:27:38,370
2018 年 2017 年发生的下一件事

670
00:27:38,370 --> 00:27:41,730
是 Microsoft 和 Linux

671
00:27:41,730 --> 00:27:44,220
在其内核中添加了对持久内存的支持

672
00:27:44,220 --> 00:27:46,020
，这就是

673
00:27:46,020 --> 00:27:48,540
所谓的 Dax 是一种直接访问扩展，

674
00:27:48,540 --> 00:27:52,080
它允许我们编写

675
00:27:52,080 --> 00:27:55,650
那些能够使用 API 的程序，它

676
00:27:55,650 --> 00:27:57,240
知道它正在与您进行持久内存对话，

677
00:27:57,240 --> 00:28:00,690
我可以将简单的 sis 调用间隔开

678
00:28:00,690 --> 00:28:03,630
，我们可以访问它，我们和

679
00:28:03,630 --> 00:28:05,340
我们有正确的指令，我们

680
00:28:05,340 --> 00:28:07,140
需要实际确保事情是

681
00:28:07,140 --> 00:28:11,240
刷新的 是下一个，所以在

682
00:28:11,240 --> 00:28:15,270
2018 年 2017 年英特尔刷新

683
00:28:15,270 --> 00:28:17,850
了 Zeon 的指令集并添加了

684
00:28:17,850 --> 00:28:20,640
显式指令以将缓存行

685
00:28:20,640 --> 00:28:24,720
刷新到持久内存再次

686
00:28:24,720 --> 00:28:27,270
考虑 你现在如何编写程序，当

687
00:28:27,270 --> 00:28:29,520
我更新

688
00:28:29,520 --> 00:28:31,830
正在执行

689
00:28:31,830 --> 00:28:34,980
存储操作或存储指令以

690
00:28:34,980 --> 00:28:39,210
更新该内存的被盖下的一块内存时，但我认为

691
00:28:39,210 --> 00:28:41,850
我的权利将进入我的 CPU 缓存，

692
00:28:41,850 --> 00:28:44,610
除非我” 我在做流媒体权利，但

693
00:28:44,610 --> 00:28:47,430
你知道忽略我的权利

694
00:28:47,430 --> 00:28:47,789
落在 CP 中

695
00:28:47,789 --> 00:28:51,359
——但是如果我如果 CPU 缓存现在

696
00:28:51,359 --> 00:28:53,369
已经由持久内存支持

697
00:28:53,369 --> 00:28:55,009
而不是 DRAM 它的持久内存，

698
00:28:55,009 --> 00:28:57,929
但程序需要一种方法来

699
00:28:57,929 --> 00:29:00,479
知道那些 我写的那些

700
00:29:00,479 --> 00:29:04,320
位于 CPU 缓存中的内容已经实现 -

701
00:29:04,320 --> 00:29:07,019
实际上已经实现 -

702
00:29:07,019 --> 00:29:08,340
持久内存，因此我知道

703
00:29:08,340 --> 00:29:11,220
当你再次想到基于磁盘的系统时，我的权利是持久的，

704
00:29:11,220 --> 00:29:13,440
我称之为 F

705
00:29:13,440 --> 00:29:18,090
sink right 这会将它移出

706
00:29:18,090 --> 00:29:21,179
它拥有的任何缓冲区并

707
00:29:21,179 --> 00:29:22,769
实际将其保存在磁盘上，并且在我知道磁盘控制器说正确成功之前我不会

708
00:29:22,769 --> 00:29:25,649
收到对我的应用程序的返回调用，

709
00:29:25,649 --> 00:29:27,059


710
00:29:27,059 --> 00:29:29,489
所以我们需要

711
00:29:29,489 --> 00:29:31,649
同样的东西 我们的缓存行，

712
00:29:31,649 --> 00:29:33,349
那就是 这些说明给了我们什么，

713
00:29:33,349 --> 00:29:36,299
所以这有点像

714
00:29:36,299 --> 00:29:41,609
2019 年 2018 年之前的世界状况，但

715
00:29:41,609 --> 00:29:44,340
去年是这些东西真正

716
00:29:44,340 --> 00:29:46,259
可用的时候，所以这就是英特尔

717
00:29:46,259 --> 00:29:47,940
现在发货的东西，它被称为 opt Ain DC

718
00:29:47,940 --> 00:29:50,220
持久内存，正如你所看到的 它

719
00:29:50,220 --> 00:29:53,700
看起来像 DRAM，它具有 DRM 外形，

720
00:29:53,700 --> 00:29:56,009
这意味着您可以正好安装在主板中存在恶魔的位置

721
00:29:56,009 --> 00:29:58,200
，但

722
00:29:58,200 --> 00:30:01,190
不是易失性，而是非易失性存储，

723
00:30:01,190 --> 00:30:05,759
现在这实际上工作有点

724
00:30:05,759 --> 00:30:07,859
复杂，但就像在那里一样，它几乎

725
00:30:07,859 --> 00:30:09,299
就像 SSD 一样 有一个

726
00:30:09,299 --> 00:30:11,489
价格 设备上有一个 ASIC

727
00:30:11,489 --> 00:30:14,190
正在做负载平衡 或者我们正在

728
00:30:14,190 --> 00:30:15,919
调平、垃圾收集和

729
00:30:15,919 --> 00:30:17,580
加密以及一堆其他东西

730
00:30:17,580 --> 00:30:18,840
所以这不仅仅是像

731
00:30:18,840 --> 00:30:20,399
嘿我只是从所有位开始写

732
00:30:20,399 --> 00:30:22,109
这是 拦截写入并

733
00:30:22,109 --> 00:30:24,720
实际做一些事情，所以

734
00:30:24,720 --> 00:30:26,070
据您所知，您不能去亚马逊，

735
00:30:26,070 --> 00:30:28,049
因为我今天尝试过，您就是无法购买，

736
00:30:28,049 --> 00:30:29,340
这是您必须

737
00:30:29,340 --> 00:30:31,950
像制造商一样通过的东西 turer 所以它

738
00:30:31,950 --> 00:30:33,809
仍然没有广泛流行，但

739
00:30:33,809 --> 00:30:35,879
他们已经发货

740
00:30:35,879 --> 00:30:37,619
了，如果你有足够的钱，今天就可以访问这个

741
00:30:37,619 --> 00:30:38,970


742
00:30:38,970 --> 00:30:44,090
价格，这意味着我必须去看看

743
00:30:44,090 --> 00:30:45,450
我是的，实际上

744
00:30:45,450 --> 00:30:47,009
公开我不认为 我讨论了

745
00:30:47,009 --> 00:30:50,159
价格，嗯，我认为它

746
00:30:50,159 --> 00:30:51,899
是 DRM 价格的三四倍，我们

747
00:30:51,899 --> 00:30:55,159
应该查一下，但它确实存在

748
00:30:55,159 --> 00:30:57,929
，这真是太棒了，所以很明显，

749
00:30:57,929 --> 00:30:59,669
随着时间的推移，它会变得比

750
00:30:59,669 --> 00:31:01,340
其他制造商更便宜，

751
00:31:01,340 --> 00:31:05,860
所以这个技术 对我来说，这是一件大事，

752
00:31:05,860 --> 00:31:07,669
所以我们实际上将如何

753
00:31:07,669 --> 00:31:10,759
使用它，所以从数据库的

754
00:31:10,759 --> 00:31:14,240
角度来看，确实有两种方法

755
00:31:14,240 --> 00:31:18,259
，据我所知，是的，从数据的

756
00:31:18,259 --> 00:31:19,340
有效性来看，有两种方法，

757
00:31:19,340 --> 00:31:22,610
另一种方法是

758
00:31:22,610 --> 00:31:25,549
配置选择设备的配置

759
00:31:25,549 --> 00:31:27,799


760
00:31:27,799 --> 00:31:29,570
以某种方式写入，但我们可以忽略

761
00:31:29,570 --> 00:31:31,249
这是我们在数据库系统中关心的问题，

762
00:31:31,249 --> 00:31:33,769
所以首先是您只是

763
00:31:33,769 --> 00:31:39,619
将DRAM用作哈佛

764
00:31:39,619 --> 00:31:41,840
管理现金，那又如何 做 这意味着

765
00:31:41,840 --> 00:31:43,850
这是我们的持久内存，无论它

766
00:31:43,850 --> 00:31:45,409
的大小是多少，这就是

767
00:31:45,409 --> 00:31:48,470
操作系统

768
00:31:48,470 --> 00:31:49,369
认为数据库系统可用内存总量的原因，

769
00:31:49,369 --> 00:31:51,320
所以现在

770
00:31:51,320 --> 00:31:54,110
当我开始为我的数据库系统进行写入时，

771
00:31:54,110 --> 00:31:56,149
它会去 通过 VM

772
00:31:56,149 --> 00:31:59,629
子系统，权利将首先进入 DRAM，

773
00:31:59,629 --> 00:32:01,820
因为这会很快，然后我可以

774
00:32:01,820 --> 00:32:03,649
返回到我的应用程序，说是的，

775
00:32:03,649 --> 00:32:05,480
我们在内存中获得了你的权利，

776
00:32:05,480 --> 00:32:07,879
然后最终这将被推出

777
00:32:07,879 --> 00:32:12,379
以执行持久性内存或 如果我执行

778
00:32:12,379 --> 00:32:13,519
刷新，那么我确保它

779
00:32:13,519 --> 00:32:15,980
实际上保留在那里，但

780
00:32:15,980 --> 00:32:18,470
想法是，由于 DRAM 比

781
00:32:18,470 --> 00:32:20,179
持久性内存快，至少在它们今天存在时

782
00:32:20,179 --> 00:32:22,519
，我可以让它们吸收我所有成熟的

783
00:32:22,519 --> 00:32:24,440
写入，但我不这样做

784
00:32:24,440 --> 00:32:26,720
不一定会经历

785
00:32:26,720 --> 00:32:29,690
Layton 看到的持久

786
00:32:29,690 --> 00:32:32,450
内存较慢的放缓，所以在英特尔他们称之为

787
00:32:32,450 --> 00:32:35,419
内存模式，再次只是我们

788
00:32:35,419 --> 00:32:36,919
只是像使用 D Ram 一样使用它，

789
00:32:36,919 --> 00:32:38,480
实际上我们没有做任何事情

790
00:32:38,480 --> 00:32:40,519
在我们的数据库系统中，这个

791
00:32:40,519 --> 00:32:43,629
设置知道我们正在写入

792
00:32:43,629 --> 00:32:47,240
持久内存，这认为

793
00:32:47,240 --> 00:32:48,259
它只是 DRAM

794
00:32:48,259 --> 00:32:50,960
它是一个更大更便宜的潜在 DRAM

795
00:32:50,960 --> 00:32:53,570
，所以这意味着我们开始

796
00:32:53,570 --> 00:32:55,070
写一个我们说过要做的事情，但是

797
00:32:55,070 --> 00:32:57,379
一堆额外的东西来解释这一点，

798
00:32:57,379 --> 00:32:58,820
因为我们再次认为我们只是

799
00:32:58,820 --> 00:33:04,519
写到 DRM 另一种方法

800
00:33:04,519 --> 00:33:08,509
是我们将 DRAM

801
00:33:08,509 --> 00:33:11,899
与持久内存相邻，现在我们的

802
00:33:11,899 --> 00:33:13,960
数据库系统意识到这是正确的

803
00:33:13,960 --> 00:33:16,270
- 持久内存 并且它具有

804
00:33:16,270 --> 00:33:19,029
我们不想要的耐久性属性，

805
00:33:19,029 --> 00:33:21,100
所以如果我有权利，我可以再做一次，

806
00:33:21,100 --> 00:33:22,570
我可以声明我想将它写入

807
00:33:22,570 --> 00:33:24,100
某个区域的内存，我的地址

808
00:33:24,100 --> 00:33:26,799
空间由 DRAM 支持或将拥有

809
00:33:26,799 --> 00:33:28,570
权利 转到

810
00:33:28,570 --> 00:33:30,309
由持久内存支持的某个内存区域，我

811
00:33:30,309 --> 00:33:32,470
知道如果我这样做正确，

812
00:33:32,470 --> 00:33:34,630
内存过程和我进行刷新然后就像我的

813
00:33:34,630 --> 00:33:37,899
更改是持久的，所以英特尔调用此

814
00:33:37,899 --> 00:33:40,090
应用程序模式，这里的想法

815
00:33:40,090 --> 00:33:41,230
是应用程序 这意味着我们的

816
00:33:41,230 --> 00:33:43,210
数据库系统知道边界在哪里，

817
00:33:43,210 --> 00:33:44,919
或者我们已经将

818
00:33:44,919 --> 00:33:46,330
一些内存分配到我们的地址空间

819
00:33:46,330 --> 00:33:48,640
中，这些内存位于持久内存与 DRAM 中

820
00:33:48,640 --> 00:33:53,070
，并且我们可以根据需要进行刷新，

821
00:33:53,760 --> 00:33:56,950
因此正如我所说，这些设备

822
00:33:56,950 --> 00:34:00,880
首先到达 PCI Express 卡

823
00:34:00,880 --> 00:34:05,020
和它们是块可寻址的，所以

824
00:34:05,020 --> 00:34:06,429
从数据库系统的角度来看

825
00:34:06,429 --> 00:34:09,429
，这并不有趣，因为那

826
00:34:09,429 --> 00:34:11,168
只是我们只是采取

827
00:34:11,168 --> 00:34:13,060
我们上学期做出的拒绝和设计选择

828
00:34:13,060 --> 00:34:15,219
并构建一个系统来使用

829
00:34:15,219 --> 00:34:19,300
它看起来像更快更快的 SSD

830
00:34:19,300 --> 00:34:21,609
，我应该 当我们对一些高端三星设备进行基准测试时，我们

831
00:34:21,609 --> 00:34:24,760


832
00:34:24,760 --> 00:34:27,040
确实看到 PCI Express 版本的性能存在重大差异，

833
00:34:27,040 --> 00:34:29,339


834
00:34:29,339 --> 00:34:31,510
您只是看到了更稳定的

835
00:34:31,510 --> 00:34:33,010
机构，尽管如此设置的

836
00:34:33,010 --> 00:34:36,429
振荡和

837
00:34:36,429 --> 00:34:38,699
性能更小，但 我们确实关心的

838
00:34:38,699 --> 00:34:40,719
是我在上一张幻灯片中展示的第二个

839
00:34:40,719 --> 00:34:42,280
应用程序模式，我知道

840
00:34:42,280 --> 00:34:43,780
我已准备好使用 RAM 并且我知道我正在

841
00:34:43,780 --> 00:34:46,270
编写 到持久内存，我父亲

842
00:34:46,270 --> 00:34:48,879
listen 可以正确地管理它，

843
00:34:48,879 --> 00:34:51,219
因为现在我们必须去设计我们的

844
00:34:51,219 --> 00:34:53,320
系统来解决这个问题，现在我

845
00:34:53,320 --> 00:34:55,119
实际上可以

846
00:34:55,119 --> 00:34:57,129
对某些位置和内存进行字节可寻址更新某些数据

847
00:34:57,129 --> 00:34:59,440
结构或某些表堆

848
00:34:59,440 --> 00:35:01,990
保证是耐用的，然后

849
00:35:01,990 --> 00:35:03,940
英特尔的设备处理你知道

850
00:35:03,940 --> 00:35:05,980
的情况，即使我

851
00:35:05,980 --> 00:35:07,180
恢复了我的应用程序，我恢复了我的

852
00:35:07,180 --> 00:35:08,980
系统，我回来了，我可以访问

853
00:35:08,980 --> 00:35:12,010
我拥有的内存，因为它

854
00:35:12,010 --> 00:35:13,390
不会重新启动程序 为你计数器，

855
00:35:13,390 --> 00:35:14,500
所以它不像你可以手动

856
00:35:14,500 --> 00:35:16,359
拔掉插头然后回来，

857
00:35:16,359 --> 00:35:17,410
一切都和

858
00:35:17,410 --> 00:35:19,030
之前一样，我们仍然需要做

859
00:35:19,030 --> 00:35:21,010
一些可能的恢复工作，因为

860
00:35:21,010 --> 00:35:23,710
我们的处理器会重新启动，

861
00:35:23,710 --> 00:35:25,110


862
00:35:25,110 --> 00:35:28,590
所以这是 我的一个猜想 我仍然

863
00:35:28,590 --> 00:35:31,950
认为这是真的，我们将

864
00:35:31,950 --> 00:35:34,230
在未来几年看到它在市场上的表现，

865
00:35:34,230 --> 00:35:37,710
但我相信，当

866
00:35:37,710 --> 00:35:39,270
持久内存出现时，它会变得更

867
00:35:39,270 --> 00:35:41,040
广泛可用，并且 at 基本上

868
00:35:41,040 --> 00:35:42,960
意味着

869
00:35:42,960 --> 00:35:44,630


870
00:35:44,630 --> 00:35:48,450
当 Itoh ec2

871
00:35:48,450 --> 00:35:49,440
是我们本学期一直在谈论的内存数据库系统时，亚马逊将允许您访问它，

872
00:35:49,440 --> 00:35:51,720
他们将处于更好的

873
00:35:51,720 --> 00:35:54,030
位置来容纳字节

874
00:35:54,030 --> 00:35:57,450
可寻址持久内存，因为

875
00:35:57,450 --> 00:35:58,950
他们已经编写了一个 整个

876
00:35:58,950 --> 00:36:01,080
架构假设他们可以在今天早上

877
00:36:01,080 --> 00:36:04,910
非常快速地进行随机访问以

878
00:36:04,910 --> 00:36:07,350
存储图像以执行系统

879
00:36:07,350 --> 00:36:10,200
可能最终会从

880
00:36:10,200 --> 00:36:11,400
我之前展示的第二种方法开始

881
00:36:11,400 --> 00:36:14,250
，您只需将 DRAM 放在

882
00:36:14,250 --> 00:36:17,010
前面，而 Pasiphae 更便宜 更

883
00:36:17,010 --> 00:36:19,290
高效的内存池或更大的容量，

884
00:36:19,290 --> 00:36:21,990
你知道内存地址空间，所以你

885
00:36:21,990 --> 00:36:23,520
不需要重写和你的应用程序，

886
00:36:23,520 --> 00:36:25,440
你只是使用更多的 D Ram

887
00:36:25,440 --> 00:36:27,750
但是如果你开始

888
00:36:27,750 --> 00:36:29,670
想要利用 DRAM 的持久

889
00:36:29,670 --> 00:36:32,400
特性 一个持久内存

890
00:36:32,400 --> 00:36:34,650
然后你必须去重新连接

891
00:36:34,650 --> 00:36:36,690
你的系统以潜在地使用一个字节

892
00:36:36,690 --> 00:36:38,880
可寻址的 API 基本上

893
00:36:38,880 --> 00:36:40,320
我们讨论过的所有

894
00:36:40,320 --> 00:36:44,400
事情 好的，所以我想首先

895
00:36:44,400 --> 00:36:47,490
谈谈

896
00:36:47,490 --> 00:36:50,550
持久内存的一些存储恢复方法，这

897
00:36:50,550 --> 00:36:53,160
只是让您思考

898
00:36:53,160 --> 00:36:55,830
如果您设计系统以

899
00:36:55,830 --> 00:36:57,780
考虑到要注意您正在

900
00:36:57,780 --> 00:37:01,230
写入字节时会发生什么变化 解决持久

901
00:37:01,230 --> 00:37:04,200
内存问题 所以这是我的 PC

902
00:37:04,200 --> 00:37:04,680
很快

903
00:37:04,680 --> 00:37:07,340
就实现的论文，我几年前写的

904
00:37:07,340 --> 00:37:10,410
关于皮肤的论文可以考虑查看

905
00:37:10,410 --> 00:37:12,210
数据库

906
00:37:12,210 --> 00:37:15,180
系统存储架构的所有基本设计

907
00:37:15,180 --> 00:37:17,670
以及持久内存可以改变

908
00:37:17,670 --> 00:37:21,540
的内容 早在 2015 年，我们实际上并

909
00:37:21,540 --> 00:37:24,000
没有该设备，当时我们唯一

910
00:37:24,000 --> 00:37:27,480
使用的是

911
00:37:27,480 --> 00:37:29,880
英特尔在俄勒冈州希尔斯伯勒为我们提供的港口模拟器，在

912
00:37:29,880 --> 00:37:34,290
那里他们为系统修改

913
00:37:34,290 --> 00:37:37,350
了这些设备的主板

914
00:37:37,350 --> 00:37:41,280
以引入一些

915
00:37:41,280 --> 00:37:43,410
额外的微码 就像

916
00:37:43,410 --> 00:37:46,020
Zeon 的调试钩子一样，所以每当我

917
00:37:46,020 --> 00:37:48,060
在商店里加载时，基本上就是

918
00:37:48,060 --> 00:37:50,730
这个复杂的繁忙循环，它会

919
00:37:50,730 --> 00:37:52,710
找出如何减慢那里的时间

920
00:37:52,710 --> 00:37:55,170
e 在 store

921
00:37:55,170 --> 00:37:59,420
操作中加载以模拟

922
00:37:59,540 --> 00:38:01,950
持久内存的行为，当

923
00:38:01,950 --> 00:38:05,700
它最终出现时，所以这项工作

924
00:38:05,700 --> 00:38:08,010
全部在我们正在构建的原型数据系统中完成，

925
00:38:08,010 --> 00:38:09,990
称为 n store 这是

926
00:38:09,990 --> 00:38:11,460
我们构建的第一天系统中的第一个

927
00:38:11,460 --> 00:38:13,020
Carnegie Mellon 当我

928
00:38:13,020 --> 00:38:17,100
开始时，这实际上是

929
00:38:17,100 --> 00:38:18,780
Peloton 项目的起源，所以我们

930
00:38:18,780 --> 00:38:20,250
开始为这篇论文做准备，

931
00:38:20,250 --> 00:38:22,859
这个项目越来越大，

932
00:38:22,859 --> 00:38:25,530
我们将它重命名为 Peloton，然后

933
00:38:25,530 --> 00:38:27,150
我们最终杀死了所有 Peloton，

934
00:38:27,150 --> 00:38:29,280
这成为了 materia 数据库

935
00:38:29,280 --> 00:38:30,660
你们今天正在研究的系统我们

936
00:38:30,660 --> 00:38:31,920
扔掉了所有的 Peloton 代码并重新

937
00:38:31,920 --> 00:38:34,560
开始 所以这是你知道从 n

938
00:38:34,560 --> 00:38:36,180
商店到 Peloton 材料这就是我们如何

939
00:38:36,180 --> 00:38:37,590
结束这个但是

940
00:38:37,590 --> 00:38:40,290
我们当前的系统中没有任何东西使用我们的

941
00:38:40,290 --> 00:38:42,359
任何代码 使用我们生成和存储，

942
00:38:42,359 --> 00:38:43,890
因为它很多是

943
00:38:43,890 --> 00:38:46,920
特定于英特尔模拟器设备

944
00:38:46,920 --> 00:38:49,770
的，也是在英特尔

945
00:38:49,770 --> 00:38:51,990
推出一堆库来做内存

946
00:38:51,990 --> 00:38:53,280
之前 位置 现在编写持久内存程序所需的其他东西

947
00:38:53,280 --> 00:38:55,430


948
00:38:55,430 --> 00:39:00,590
所有这些东西都存在

949
00:39:00,590 --> 00:39:03,510
于英特尔的 PMD K 中，就像它们为您

950
00:39:03,510 --> 00:39:05,010
提供了所有重要的结构

951
00:39:05,010 --> 00:39:06,810
，我们必须自己卷起背包

952
00:39:06,810 --> 00:39:10,590
，好吧，让我们了解

953
00:39:10,590 --> 00:39:13,460
我们如何减少 与

954
00:39:13,460 --> 00:39:16,890
持久内存同步 所以再次像我们

955
00:39:16,890 --> 00:39:18,960
现在编写程序的方式，当您分配

956
00:39:18,960 --> 00:39:21,210
malloc 一堆内存时，您

957
00:39:21,210 --> 00:39:23,070
会对其进行大量处理，您假设它是

958
00:39:23,070 --> 00:39:25,590
易失性的，并且您还假设

959
00:39:25,590 --> 00:39:27,750
如果程序使您崩溃，它会借给您的 CPU 缓存

960
00:39:27,750 --> 00:39:30,270
失去一切，但

961
00:39:30,270 --> 00:39:32,940
现在因为我们希望能够

962
00:39:32,940 --> 00:39:36,090
可爱地写入数据

963
00:39:36,090 --> 00:39:38,520
并由持久内存支持它我们需要知道

964
00:39:38,520 --> 00:39:41,210
它实际上是如何在高层次上工作的所以

965
00:39:41,210 --> 00:39:43,740
再次说我们的管道看起来像这样

966
00:39:43,740 --> 00:39:45,450
这是我们正在运行的进程

967
00:39:45,450 --> 00:39:48,050
CPU 他们执行存储操作

968
00:39:48,050 --> 00:39:50,810
来更新内存中的某个位置，但

969
00:39:50,810 --> 00:39:52,190
该存储操作总是会

970
00:39:52,190 --> 00:39:54,620
再次进入我们的 CPU 缓存，

971
00:39:54,620 --> 00:39:56,660
好吧，这就是 f  astest 存储

972
00:39:56,660 --> 00:39:57,920
介质，它可用于 CPU

973
00:39:57,920 --> 00:40:01,990
但现在如果我想确保

974
00:40:01,990 --> 00:40:06,740
我的数据我的更改使其成为

975
00:40:06,740 --> 00:40:11,030
持久性内存，我可以等待并

976
00:40:11,030 --> 00:40:12,680
希望最终它能够成功，

977
00:40:12,680 --> 00:40:15,740
因为我将要发生的事情

978
00:40:15,740 --> 00:40:19,370
是 如果我的缓存已满，则 CPU

979
00:40:19,370 --> 00:40:20,780
会将其写回正确的位置以将

980
00:40:20,780 --> 00:40:22,280
您实际制作的内存更改为

981
00:40:22,280 --> 00:40:24,410
正确的内存，然后您

982
00:40:24,410 --> 00:40:25,970
将实际需要的下一块提取到

983
00:40:25,970 --> 00:40:28,910
CPU 缓存中以腾出空间，但 II 但我

984
00:40:28,910 --> 00:40:31,820
不能 我需要你确切地知道什么时候

985
00:40:31,820 --> 00:40:33,860
发生，但没有回调方法

986
00:40:33,860 --> 00:40:35,660
，什么时候发生，

987
00:40:35,660 --> 00:40:37,700
但这太慢了所以我想告诉它

988
00:40:37,700 --> 00:40:40,220
我不会告诉 CPU 嘿写这个

989
00:40:40,220 --> 00:40:42,350
alpha me 所以我们可以使用缓存 行

990
00:40:42,350 --> 00:40:45,350
右后指令，然后

991
00:40:45,350 --> 00:40:47,540
将更改推送到内存控制器

992
00:40:47,540 --> 00:40:49,610
，这是位于

993
00:40:49,610 --> 00:40:51,380
具有小电容器的主板上以保持它，

994
00:40:51,380 --> 00:40:54,830
特别是他的电池供电，因此

995
00:40:54,830 --> 00:40:57,050
电容器的大小使我失去电源

996
00:40:57,050 --> 00:40:58,730
，这里有足够的能量 o

997
00:40:58,730 --> 00:40:59,840
确保所有内容都

998
00:40:59,840 --> 00:41:03,710
真正进入我的持久内存，然后

999
00:41:03,710 --> 00:41:06,290
在这一点上，我将控制权返回

1000
00:41:06,290 --> 00:41:08,180
给程序，因为我的权利将

1001
00:41:08,180 --> 00:41:09,320
其传给了内存控制器，并且它

1002
00:41:09,320 --> 00:41:10,790
负责确保它

1003
00:41:10,790 --> 00:41:12,920
在另一个 然后这个

1004
00:41:12,920 --> 00:41:14,600
东西执行所谓的异步数据

1005
00:41:14,600 --> 00:41:15,080
刷新，

1006
00:41:15,080 --> 00:41:17,570
这是一个特殊的指令，我

1007
00:41:17,570 --> 00:41:20,540
对英特尔说过，支持更改

1008
00:41:20,540 --> 00:41:23,870
为非易失性存储器

1009
00:41:23,870 --> 00:41:27,200
或 TM 设备，因此从我们的数据库

1010
00:41:27,200 --> 00:41:28,910
系统的角度来看，我们只需要 要

1011
00:41:28,910 --> 00:41:31,460
知道哪些缓存行或

1012
00:41:31,460 --> 00:41:33,050
说我们修改了哪些内存位置，

1013
00:41:33,050 --> 00:41:34,430
然后我们想要使其持久化，并且我们使用

1014
00:41:34,430 --> 00:41:36,410
缓存行 flostor 缓存行右后

1015
00:41:36,410 --> 00:41:38,920
指令来确保

1016
00:41:38,920 --> 00:41:41,240
发生接下来我们必须处理的事情

1017
00:41:41,240 --> 00:41:45,470
是我们的数据库 系统重新启动，

1018
00:41:45,470 --> 00:41:47,690
我们重新上线，我们现在有一堆

1019
00:41:47,690 --> 00:41:50,480
指向元组或

1020
00:41:50,480 --> 00:41:52,420
其他内存数据结构的指针，

1021
00:41:52,420 --> 00:41:54,470
但我们如何真正确保

1022
00:41:54,470 --> 00:41:56,840
这些指针仍然有效？ 他

1023
00:41:56,840 --> 00:41:59,260
第二次来，因为我

1024
00:41:59,260 --> 00:42:01,880
不能保证，当我开始

1025
00:42:01,880 --> 00:42:06,410
第一次

1026
00:42:06,410 --> 00:42:08,120
分配给秘书的内存时，我的程序

1027
00:42:08,120 --> 00:42:10,070
开始时我将获得与之前相同的虚拟

1028
00:42:10,070 --> 00:42:12,850
内存地址，

1029
00:42:12,850 --> 00:42:15,110
所以问题是 这个我有一个

1030
00:42:15,110 --> 00:42:17,090
索引，它有一堆指向一些

1031
00:42:17,090 --> 00:42:20,180
元组的指针，然后假设我

1032
00:42:20,180 --> 00:42:24,110
只做笔，我在做多版本控制，

1033
00:42:24,110 --> 00:42:25,910
所以我有多个版本的元组

1034
00:42:25,910 --> 00:42:27,560
，就像在我的版本链中一样

1035
00:42:27,560 --> 00:42:29,750
这里有一个指向另一个元组的指针，但

1036
00:42:29,750 --> 00:42:32,030
现在我的系统崩溃了，这被

1037
00:42:32,030 --> 00:42:35,450
吹走了，我的索引被

1038
00:42:35,450 --> 00:42:37,070
吹走了所有的指针现在都无效

1039
00:42:37,070 --> 00:42:38,750
了我想要做的是

1040
00:42:38,750 --> 00:42:41,780
重新上线并让我的所有指针

1041
00:42:41,780 --> 00:42:44,270
仍然有效 因此，如果我使用

1042
00:42:44,270 --> 00:42:45,830
您知道虚拟内存地址，

1043
00:42:45,830 --> 00:42:50,150
则无法保证这样做，所以

1044
00:42:50,150 --> 00:42:52,370
您说您需要的是一个内存分配器

1045
00:42:52,370 --> 00:42:55,910
，它了解这两个问题

1046
00:42:55,910 --> 00:42:57,080
，您需要能够将

1047
00:42:57,080 --> 00:42:59,150
数据同步出磁盘 或者试试

1048
00:42:59,150 --> 00:43:00,830
persis 当你调用

1049
00:43:00,830 --> 00:43:03,770
正确的指令，然后当我

1050
00:43:03,770 --> 00:43:05,750
第二次回来时，我的所有

1051
00:43:05,750 --> 00:43:08,510
地址窃取指向

1052
00:43:08,510 --> 00:43:10,790
正确的内存检查

1053
00:43:10,790 --> 00:43:13,520
虚拟内存中的位置，所以第一个

1054
00:43:13,520 --> 00:43:15,530
你只是在执行缓存行

1055
00:43:15,530 --> 00:43:17,570
刷新，但是 那么你有一个 S 栅栏

1056
00:43:17,570 --> 00:43:20,510
辩论要等到基本上是一个

1057
00:43:20,510 --> 00:43:22,160
屏障和连接管道，以确保

1058
00:43:22,160 --> 00:43:23,540


1059
00:43:23,540 --> 00:43:25,280
在我们开始执行下一条指令之前这些更改被刷新，这样的

1060
00:43:25,280 --> 00:43:27,290
操作

1061
00:43:27,290 --> 00:43:30,700
与 sink 进入操作系统并

1062
00:43:30,700 --> 00:43:33,230
在直到 磁盘

1063
00:43:33,230 --> 00:43:35,780
控制器确认用于

1064
00:43:35,780 --> 00:43:37,340
命名想法的刷新是内存

1065
00:43:37,340 --> 00:43:39,650
分配器您可以声明

1066
00:43:39,650 --> 00:43:41,810


1067
00:43:41,810 --> 00:43:43,550
通过内存分配器获得的专用指针，这些指针由

1068
00:43:43,550 --> 00:43:45,710
持久内存支持，并且您知道

1069
00:43:45,710 --> 00:43:47,150
任何时候您都有指向该

1070
00:43:47,150 --> 00:43:49,250
内存位置的指针 当您第二次重新启动程序时返回您的应用程序

1071
00:43:49,250 --> 00:43:51,080
时，

1072
00:43:51,080 --> 00:43:53,300
这些

1073
00:43:53,300 --> 00:43:54,980
指针对您的

1074
00:43:54,980 --> 00:43:58,190
应用程序仍然有效，因此 你不想自己

1075
00:43:58,190 --> 00:44:00,110
写所有的东西你想

1076
00:44:00,110 --> 00:44:01,940
使用来自智能的 PMD K 他们

1077
00:44:01,940 --> 00:44:04,010
为你提供了低级原语来

1078
00:44:04,010 --> 00:44:08,240
做到这一点所以现在让我们看看

1079
00:44:08,240 --> 00:44:10,910
我们如何再次使用这些原语来

1080
00:44:10,910 --> 00:44:14,150
构建数据库系统 对于

1081
00:44:14,150 --> 00:44:15,650
本文，我们所做的是

1082
00:44:15,650 --> 00:44:18,470
研究了数据库系统中

1083
00:44:18,470 --> 00:44:20,660
存储管理器可以拥有的三种基本设计架构，

1084
00:44:20,660 --> 00:44:23,060
并

1085
00:44:23,060 --> 00:44:26,210
确定了瓶颈在哪里或

1086
00:44:26,210 --> 00:44:27,650


1087
00:44:27,650 --> 00:44:29,810
在持久内存上运行时存在哪些问题，以及

1088
00:44:29,810 --> 00:44:32,060
我们如何才能 重新设计它们以了解我

1089
00:44:32,060 --> 00:44:34,720
现在可以编写持久的更改，

1090
00:44:34,720 --> 00:44:37,870
因此对于此更改，我们将假设

1091
00:44:37,870 --> 00:44:41,510
为简单起见，没有 DRAM，

1092
00:44:41,510 --> 00:44:43,310
所有内容都在持久内存中，

1093
00:44:43,310 --> 00:44:46,490
因此如果我执行刷新，那么

1094
00:44:46,490 --> 00:44:48,230
我可以保证我的 变化是

1095
00:44:48,230 --> 00:44:51,500
持久的，所以这样想，

1096
00:44:51,500 --> 00:44:53,750
这就像你知道未来十五

1097
00:44:53,750 --> 00:44:55,240
年二十年，

1098
00:44:55,240 --> 00:44:57,620
DRAM消失并做所有事情

1099
00:44:57,620 --> 00:45:00,290
只是持久的所以首选

1100
00:45:00,290 --> 00:45:01,340
就地做 更新所以这是你

1101
00:45:01,340 --> 00:45:02,570
有一个表热加上一个红发日志

1102
00:45:02,570 --> 00:45:05,750
快照的地方，对于我们的例子，我们

1103
00:45:05,750 --> 00:45:08,060
将把我们的设计基于 volte

1104
00:45:08,060 --> 00:45:10,970
梁 下一个方法是

1105
00:45:10,970 --> 00:45:12,070
进行写时复制

1106
00:45:12,070 --> 00:45:14,750
更新，这就像影子

1107
00:45:14,750 --> 00:45:17,720
复制或影子分页，

1108
00:45:17,720 --> 00:45:19,190
每次我要更新一个页面时，我

1109
00:45:19,190 --> 00:45:21,170
都会复制它和一个侧面

1110
00:45:21,170 --> 00:45:23,330
位置，然后当我的事务

1111
00:45:23,330 --> 00:45:25,370
提交时，我只是翻转一个指针说

1112
00:45:25,370 --> 00:45:27,920
这里是这里是这里是这里是

1113
00:45:27,920 --> 00:45:31,010
最新版本的 数据库，所以对于

1114
00:45:31,010 --> 00:45:32,840
这个，你要制作额外的表副本，

1115
00:45:32,840 --> 00:45:34,310
但它不需要你

1116
00:45:34,310 --> 00:45:37,070
有一个直接的日志来保证

1117
00:45:37,070 --> 00:45:39,830
持久性，所以我们这里的设计

1118
00:45:39,830 --> 00:45:41,930
将代表像

1119
00:45:41,930 --> 00:45:45,020
最后一个使用这种方法的 LM DB

1120
00:45:45,020 --> 00:45:47,810
是一个日志结构系统，其中

1121
00:45:47,810 --> 00:45:49,670
没有表堆，日志是

1122
00:45:49,670 --> 00:45:51,800
数据库，我们只是不断追加

1123
00:45:51,800 --> 00:45:54,020
到日志中以进行快速写入，因此这

1124
00:45:54,020 --> 00:45:57,130
将类似于级别 DB 或 Rocks dB，

1125
00:45:57,130 --> 00:45:58,880
因此我们将通过

1126
00:45:58,880 --> 00:46:00,770
这些设计中的每一个 e 再一次的

1127
00:46:00,770 --> 00:46:02,600
想法是，采用

1128
00:46:02,600 --> 00:46:04,280
这些架构的教科书实现，

1129
00:46:04,280 --> 00:46:06,800
在持久内存上运行它，确定

1130
00:46:06,800 --> 00:46:09,160
瓶颈在哪里或

1131
00:46:09,160 --> 00:46:12,470
冗余更新在哪里，然后

1132
00:46:12,470 --> 00:46:15,050
重新设计架构以

1133
00:46:15,050 --> 00:46:18,380
考虑持久内存

1134
00:46:18,380 --> 00:46:19,970
，如果 我们有一个就地引擎

1135
00:46:19,970 --> 00:46:22,880
，我们写的方式是我们遵循

1136
00:46:22,880 --> 00:46:24,950
一个索引，该索引指向这个元组

1137
00:46:24,950 --> 00:46:28,020
，然后我们继续更新它

1138
00:46:28,020 --> 00:46:29,730
以确保当事务提交

1139
00:46:29,730 --> 00:46:31,320
时一切都是持久的，我们将

1140
00:46:31,320 --> 00:46:33,869
写出一个 更改的 Delta 记录

1141
00:46:33,869 --> 00:46:37,200
写入头部日志，

1142
00:46:37,200 --> 00:46:40,980
然后在此处应用我们的更改，然后在

1143
00:46:40,980 --> 00:46:43,560
稍后的某个时间点，当我们拍摄

1144
00:46:43,560 --> 00:46:45,090
快照时，我们确保我们的

1145
00:46:45,090 --> 00:46:47,930
更改保留在那里，

1146
00:46:47,930 --> 00:46:50,850
因此对于这个我们“ 重新更新

1147
00:46:50,850 --> 00:46:54,000
元组，一旦它就像

1148
00:46:54,000 --> 00:46:55,980
一个更新查询，我们正在为这个元组申请一个更新查询，

1149
00:46:55,980 --> 00:46:57,990
但我们最终将它写了

1150
00:46:57,990 --> 00:46:59,850
三遍，因为我们必须

1151
00:46:59,850 --> 00:47:01,650
写出元组 Delta 到那里你 p

1152
00:47:01,650 --> 00:47:03,600
是的，堆中的两个点，然后

1153
00:47:03,600 --> 00:47:04,440
我们将它

1154
00:47:04,440 --> 00:47:07,800
写到我们再次拍摄的任何其他快照中哦，这

1155
00:47:07,800 --> 00:47:10,710
是在持久内存中运行，所以

1156
00:47:10,710 --> 00:47:12,830
这里的一切都被认为是持久的

1157
00:47:12,830 --> 00:47:15,300
，所以我们在这里有一堆重复的数据

1158
00:47:15,300 --> 00:47:17,730
，因为 再次对于相同的更新，

1159
00:47:17,730 --> 00:47:20,280
我们已经阅读了三遍，这现在也会

1160
00:47:20,280 --> 00:47:22,860
有很慢的延迟，因为我

1161
00:47:22,860 --> 00:47:26,130
必须在我的数据库系统中执行传统的 Ares，在

1162
00:47:26,130 --> 00:47:28,440
那里我加载最后一个

1163
00:47:28,440 --> 00:47:30,630
成功的快照或检查点，

1164
00:47:30,630 --> 00:47:34,320
然后使用 你

1165
00:47:34,320 --> 00:47:38,310
知道分析重做和撤消阶段，但

1166
00:47:38,310 --> 00:47:39,840
同样一切都是持久的，

1167
00:47:39,840 --> 00:47:41,460
无论如何一切都已经是持久的，所以

1168
00:47:41,460 --> 00:47:43,650
它可能不一定需要

1169
00:47:43,650 --> 00:47:47,010
做所有这些，所以我们可以看到我们

1170
00:47:47,010 --> 00:47:49,730
实际上想要设计一个系统来

1171
00:47:49,730 --> 00:47:52,369
说明我们有

1172
00:47:52,369 --> 00:47:56,369
持久内存并使用这样一个事实，

1173
00:47:56,369 --> 00:47:58,560
即我们只有指针，我们

1174
00:47:58,560 --> 00:47:59,910
可以保证在

1175
00:47:59,910 --> 00:48:02,220
您第二次运行我们的系统时是正确的指针，

1176
00:48:02,220 --> 00:48:05,880
现在只记录

1177
00:48:05,880 --> 00:48:08,840
更改的内容而不是更改的方式

1178
00:48:08,840 --> 00:48:11,220
为了做到这一点，我们将不得不

1179
00:48:11,220 --> 00:48:13,710
维护一个临时撤消日志，以防

1180
00:48:13,710 --> 00:48:15,240
我们的事务在

1181
00:48:15,240 --> 00:48:17,010
系统在线时中止并且我们必须

1182
00:48:17,010 --> 00:48:19,890
回滚事情，我们只需要确保

1183
00:48:19,890 --> 00:48:23,609
我们所做的任何更改我们有

1184
00:48:23,609 --> 00:48:25,560
信心，因为有任何

1185
00:48:25,560 --> 00:48:28,530
我们不能改变的我们不能

1186
00:48:28,530 --> 00:48:31,800
保证 CPU

1187
00:48:31,800 --> 00:48:33,840
会将位于 CPU 缓存中的元组的任何脏更改

1188
00:48:33,840 --> 00:48:37,710
清除到内存中，因为这是

1189
00:48:37,710 --> 00:48:39,150
我们无法控制

1190
00:48:39,150 --> 00:48:41,170
的事情 CPU 不这样做，它是

1191
00:48:41,170 --> 00:48:43,150
自己做的，所以我们需要

1192
00:48:43,150 --> 00:48:45,849
考虑到这一点，但我们知道，一旦我们的数据

1193
00:48:45,849 --> 00:48:50,049
在元组中是持久的，那么我们就

1194
00:48:50,049 --> 00:48:51,339
不需要保持我们为此做的很长时间

1195
00:48:51,339 --> 00:48:53,049
，所以这两座建筑物都是持久的

1196
00:48:53,049 --> 00:48:56,260
欠债或在表中堆入

1197
00:48:56,260 --> 00:48:57,940
持久内存我们不需要重做

1198
00:48:57,940 --> 00:49:06,190
任何看起来像这样的事情所以

1199
00:49:06,190 --> 00:49:08,530
我们遵循索引所有的东西都在

1200
00:49:08,530 --> 00:49:10,329
持久内存中我们在这里得到这个元组

1201
00:49:10,329 --> 00:49:12,760
我们在应用更新之前应用

1202
00:49:12,760 --> 00:49:16,329
我们现在可以在我们的

1203
00:49:16,329 --> 00:49:19,480
l 中添加一个条目 og 说这是指向

1204
00:49:19,480 --> 00:49:21,549
被修改的元组的指针，但这就是

1205
00:49:21,549 --> 00:49:23,940
你需要知道的所有信息，

1206
00:49:23,940 --> 00:49:26,349
然后我现在可以实际应用我的更改

1207
00:49:26,349 --> 00:49:31,109
，然后如果我现在你知道刷新这个，

1208
00:49:31,109 --> 00:49:35,020
那么我知道这个交易的更改

1209
00:49:35,020 --> 00:49:37,869
是持久的，这

1210
00:49:37,869 --> 00:49:39,130
只是帮助我说哦，顺便说一下，

1211
00:49:39,130 --> 00:49:40,869
这里是实际更改的内容，

1212
00:49:40,869 --> 00:49:42,640
以防我需要遵循指针并撤消

1213
00:49:42,640 --> 00:49:45,280
操作，但是一旦此更改

1214
00:49:45,280 --> 00:49:47,349
与任何其他更改一起刷新，因为它已

1215
00:49:47,349 --> 00:49:49,390
刷新我的交易被考虑

1216
00:49:49,390 --> 00:49:53,440
持久的好吧，让我们看看我们如何

1217
00:49:53,440 --> 00:49:57,640
再次为此做一个复制和写入引擎，

1218
00:49:57,640 --> 00:49:59,799
这是影子分页的分层版本

1219
00:49:59,799 --> 00:50:02,170
我只是使用加流，

1220
00:50:02,170 --> 00:50:04,270
考虑的方式是我们仍然

1221
00:50:04,270 --> 00:50:07,089
拥有指向的主记录

1222
00:50:07,089 --> 00:50:09,520
影子副本的主副本我们进行

1223
00:50:09,520 --> 00:50:11,589
比较和交换来翻转它，但

1224
00:50:11,589 --> 00:50:14,230
我们的页面只是

1225
00:50:14,230 --> 00:50:17,650
在树中的层次结构中布局，所以假设我想

1226
00:50:17,650 --> 00:50:20,020
在这里更新这个元组，所以我会

1227
00:50:20,020 --> 00:50:24,339
首先制作一个副本 那个页面

1228
00:50:24,339 --> 00:50:27,309
的 然后是这里的条目和

1229
00:50:27,309 --> 00:50:30,819
树然后更新我的

1230
00:50:30,819 --> 00:50:33,880
目录，现在指向

1231
00:50:33,880 --> 00:50:34,960
第二页的两个你仍然指向

1232
00:50:34,960 --> 00:50:36,430
新页面的原始页面在这里

1233
00:50:36,430 --> 00:50:38,559
我指向新的，所以这是另一个

1234
00:50:38,559 --> 00:50:40,950
写操作 我进入我的

1235
00:50:40,950 --> 00:50:44,020
结构然后我现在做第三次

1236
00:50:44,020 --> 00:50:48,339
将主记录翻转到

1237
00:50:48,339 --> 00:50:50,980
脏记录所以第一个

1238
00:50:50,980 --> 00:50:53,530
问题是这些副本很昂贵

1239
00:50:53,530 --> 00:50:54,170
因为

1240
00:50:54,170 --> 00:50:56,720
我们再次使用整个页面

1241
00:50:56,720 --> 00:50:59,780
即使我们只 更新你知道

1242
00:50:59,780 --> 00:51:01,760
它里面的一个元组 我们必须制作一个完整的

1243
00:51:01,760 --> 00:51:03,470
副本 我们必须更新叶子

1244
00:51:03,470 --> 00:51:05,000
信息 更新污垢目录

1245
00:51:05,000 --> 00:51:08,420
只是为了保留它并说明我们可以

1246
00:51:08,420 --> 00:51:11,240
做什么 因为持久内存可以被

1247
00:51:11,240 --> 00:51:13,190
视为 DRAM 而不是有一个

1248
00:51:13,190 --> 00:51:15,170
页面 面向架构，你可以是一个

1249
00:51:15,170 --> 00:51:16,849
字节可寻址架构，就像

1250
00:51:16,849 --> 00:51:19,520
我们现在只有指向

1251
00:51:19,520 --> 00:51:23,180
元组的指针，然后现在当我进行更新时，

1252
00:51:23,180 --> 00:51:28,819
我只需要在这里复制指针

1253
00:51:28,819 --> 00:51:32,210
并应用更改，然后

1254
00:51:32,210 --> 00:51:34,730
我更新 t 他是脏目录

1255
00:51:34,730 --> 00:51:36,680
和主记录，所以这里的关键

1256
00:51:36,680 --> 00:51:37,750
区别在于

1257
00:51:37,750 --> 00:51:39,829
我们所做的更改的粒度，

1258
00:51:39,829 --> 00:51:43,760
因为我们可以在内存中读写两个字节的

1259
00:51:43,760 --> 00:51:45,829
可寻址位置，

1260
00:51:45,829 --> 00:51:50,329
所以最后一个是一个

1261
00:51:50,329 --> 00:51:52,670
日志结构 Artic 架构和

1262
00:51:52,670 --> 00:51:55,010
这里的想法是那种经典

1263
00:51:55,010 --> 00:51:56,510
架构应该是你有

1264
00:51:56,510 --> 00:51:58,160
一个内存中的 mem 表，上面有日志

1265
00:51:58,160 --> 00:52:00,950
和一个跳过列表或某种小

1266
00:52:00,950 --> 00:52:02,630
数据结构来跟踪

1267
00:52:02,630 --> 00:52:05,660
日志条目的内容 内存，然后

1268
00:52:05,660 --> 00:52:07,549
你在磁盘上你有一堆 SS

1269
00:52:07,549 --> 00:52:09,380
表，它们前面总是有一个布隆

1270
00:52:09,380 --> 00:52:11,240
页脚，然后索引

1271
00:52:11,240 --> 00:52:15,890
指向日志中的位置，所以当我

1272
00:52:15,890 --> 00:52:17,869
想更新时，我首先将它应用到我的

1273
00:52:17,869 --> 00:52:19,940
Delta 中 我对正确的磁头日志进行了更改

1274
00:52:19,940 --> 00:52:21,680
，然后在稍后的某个时间点将其

1275
00:52:21,680 --> 00:52:24,650
刷新到磁盘中，因为

1276
00:52:24,650 --> 00:52:26,180
我现在正在进行压缩，因此我将保持

1277
00:52:26,180 --> 00:52:28,160
正确的放大，我

1278
00:52:28,160 --> 00:52:30,920
将继续应用更改或 反复组合日志

1279
00:52:30,920 --> 00:52:32,420
记录 再次，如果

1280
00:52:32,420 --> 00:52:35,990
必须保留它们，那么问题

1281
00:52:35,990 --> 00:52:37,940
在于我们必须提取数据，并且因为

1282
00:52:37,940 --> 00:52:39,200
如果我们使用级别架构，

1283
00:52:39,200 --> 00:52:41,240
我们将进行昂贵的

1284
00:52:41,240 --> 00:52:43,190
压缩，因此如果您想将其切换

1285
00:52:43,190 --> 00:52:45,920
到持久内存，那么我们 可以

1286
00:52:45,920 --> 00:52:50,559
完全摆脱 ESS 表，

1287
00:52:50,559 --> 00:52:53,630
因为现在所有这些都是持久的

1288
00:52:53,630 --> 00:52:56,059
，因此我们可以拥有正确的

1289
00:52:56,059 --> 00:52:59,240
日志和我们的数据，我们

1290
00:52:59,240 --> 00:53:01,700
不需要做任何这些我们

1291
00:53:01,700 --> 00:53:03,770
仍然需要进行压缩

1292
00:53:03,770 --> 00:53:06,690
我认为这不会消失，但

1293
00:53:06,690 --> 00:53:09,119
我们不必拥有这个你知道

1294
00:53:09,119 --> 00:53:10,890
mem 表和 SS 表的概念，

1295
00:53:10,890 --> 00:53:12,000
它们是我们刚刚看到

1296
00:53:12,000 --> 00:53:14,849
的所有示例中不同类型的数据布局，

1297
00:53:14,849 --> 00:53:18,030
正如我所说 那些

1298
00:53:18,030 --> 00:53:20,579
假设我们

1299
00:53:20,579 --> 00:53:22,589
运行的计算机只有持久内存

1300
00:53:22,589 --> 00:53:25,109
而没有 DRAM 但我想这

1301
00:53:25,109 --> 00:53:26,760
在一段

1302
00:53:26,760 --> 00:53:29,069
时间内不太现实所以让我们考虑一下我们

1303
00:53:29,069 --> 00:53:31,890
今天的行为我们使用英特尔现在可用的东西设计一个系统

1304
00:53:31,890 --> 00:53:34,140


1305
00:53:34,140 --> 00:53:38,099
所以让我们瞄准 一种提高

1306
00:53:38,099 --> 00:53:40,650
性能和利用

1307
00:53:40,650 --> 00:53:45,810
持久内存的方法，专注于

1308
00:53:45,810 --> 00:53:47,790
如何对标准表进行排序，

1309
00:53:47,790 --> 00:53:49,440
并编写一个 hello 实现

1310
00:53:49,440 --> 00:53:53,040
并加快速度

1311
00:53:53,040 --> 00:53:55,800


1312
00:53:55,800 --> 00:53:58,020
内存系统或dis坐标

1313
00:53:58,020 --> 00:54:00,270
系统的想法是，我们试图

1314
00:54:00,270 --> 00:54:03,450
通过将

1315
00:54:03,450 --> 00:54:06,000
它们替换为敌方数据库的顺序日志写入来避免随机写入磁盘

1316
00:54:06,000 --> 00:54:08,400
我们只进行特殊的日志

1317
00:54:08,400 --> 00:54:09,960
写入，因为我们正在写入

1318
00:54:09,960 --> 00:54:11,579
内存中的表堆 一个磁盘

1319
00:54:11,579 --> 00:54:14,010
坐标系统，我们

1320
00:54:14,010 --> 00:54:15,750
按顺序写入日志，然后

1321
00:54:15,750 --> 00:54:16,950
在后台发明将

1322
00:54:16,950 --> 00:54:21,119
刷新脏页，这是一个优势，

1323
00:54:21,119 --> 00:54:22,650
我们将获得其他也将

1324
00:54:22,650 --> 00:54:26,910
获得事务功能的优势，因为现在

1325
00:54:26,910 --> 00:54:29,819
如果有更改

1326
00:54:29,819 --> 00:54:32,609
挂起 在系统关闭之前发生崩溃之前尚未提交的事务的一个磁盘中，

1327
00:54:32,609 --> 00:54:35,190


1328
00:54:35,190 --> 00:54:36,450


1329
00:54:36,450 --> 00:54:39,390
我们可以使用日志作为回滚它们

1330
00:54:39,390 --> 00:54:42,150
并撤消任何其他更改的一种方式

1331
00:54:42,150 --> 00:54:44,730
再次，这个设计编号在我们写入元组之前

1332
00:54:44,730 --> 00:54:47,010
先记录一些写入元组然后

1333
00:54:47,010 --> 00:54:50,940
写入开始写入

1334
00:54:50,940 --> 00:54:54,569
日志

1335
00:54:54,569 --> 00:54:57,300
是有道理的，因为再次日志

1336
00:54:57,300 --> 00:55:00,930
正确它会在

1337
00:55:00,930 --> 00:55:03,690
持久内存世界中进行调度，尽管我们 '

1338
00:55:03,690 --> 00:55:06,030
将会有快速的随机写入好吧，

1339
00:55:06,030 --> 00:55:08,010
我们邀请了dress 意味着我们

1340
00:55:08,010 --> 00:55:09,480
可以跳到内存空间队列中的任何位置

1341
00:55:09,480 --> 00:55:12,390
，这将

1342
00:55:12,390 --> 00:55:15,480
具有几乎

1343
00:55:15,480 --> 00:55:17,730
相当于进行烤饼访问的访问速度，因此

1344
00:55:17,730 --> 00:55:19,680
它们是巨大的二分法或

1345
00:55:19,680 --> 00:55:21,480
我们在顺序光中的性能差异

1346
00:55:21,480 --> 00:55:22,830
与弹簧中的随机光

1347
00:55:22,830 --> 00:55:25,170
在此硬盘驱动器甚至 SSD 中的性能差异

1348
00:55:25,170 --> 00:55:27,900
这在

1349
00:55:27,900 --> 00:55:31,050
持久性内存系统中会小得多，因此您

1350
00:55:31,050 --> 00:55:32,430
现在想找到一种可能可以利用的日志记录协议

1351
00:55:32,430 --> 00:55:34,230


1352
00:55:34,230 --> 00:55:35,850
这和我们要做的方式

1353
00:55:35,850 --> 00:55:40,020
是，我们要做的方式的权重

1354
00:55:40,020 --> 00:55:41,670
是维护一个多版本

1355
00:55:41,670 --> 00:55:46,320
数据库并在写入时进行复制或

1356
00:55:46,320 --> 00:55:47,450
确保我们不会覆盖存在 ng

1357
00:55:47,450 --> 00:55:51,480
版本，然后我们将在我们的日志中

1358
00:55:51,480 --> 00:55:54,240
只包含关于提交内容的元数据，

1359
00:55:54,240 --> 00:55:56,910
而不是

1360
00:55:56,910 --> 00:55:59,820
所做更改的实际副本，所以这是

1361
00:55:59,820 --> 00:56:02,010
我在卡内基梅隆大学的博士生开发的技术，

1362
00:56:02,010 --> 00:56:03,660


1363
00:56:03,660 --> 00:56:06,000
称为日志记录和想法

1364
00:56:06,000 --> 00:56:08,040
这是一个日志记录协议，

1365
00:56:08,040 --> 00:56:09,780
专为持久

1366
00:56:09,780 --> 00:56:11,640
内存而设计，但在一个仍然具有

1367
00:56:11,640 --> 00:56:15,660
用于表的 DRAM 的世界中，其想法是

1368
00:56:15,660 --> 00:56:18,390
我们可以

1369
00:56:18,390 --> 00:56:21,210
在崩溃后立即恢复数据库，同时将

1370
00:56:21,210 --> 00:56:23,250
最少的冗余信息

1371
00:56:23,250 --> 00:56:25,830
存储在 日志，所以我们要这样做的方式

1372
00:56:25,830 --> 00:56:29,240
是，我们只有在持久内存中

1373
00:56:29,240 --> 00:56:32,190
有数据库的副本，

1374
00:56:32,190 --> 00:56:33,960
我们确保将

1375
00:56:33,960 --> 00:56:36,000
更改刷新到该数据库，

1376
00:56:36,000 --> 00:56:37,950
现在我们的日志将只更改

1377
00:56:37,950 --> 00:56:41,100
包含指针 更改记录

1378
00:56:41,100 --> 00:56:43,860
，然后在崩溃或

1379
00:56:43,860 --> 00:56:45,480
我们需要做的任何事情之后，只需

1380
00:56:45,480 --> 00:56:47,610
查看日志以找出订单

1381
00:56:47,610 --> 00:56:49,920
崩溃时正在运行的事务

1382
00:56:49,920 --> 00:56:52,650
或 关闭，我们

1383
00:56:52,650 --> 00:56:53,970
会有指向他们修改的元组的指针

1384
00:56:53,970 --> 00:56:57,230
，我们会跟踪

1385
00:56:57,230 --> 00:56:59,610
这些

1386
00:56:59,610 --> 00:57:01,650
事务所做的更新没有提交的事实，

1387
00:57:01,650 --> 00:57:03,600
因此我们知道指向这些

1388
00:57:03,600 --> 00:57:05,670
元组的指针，因此我们想要

1389
00:57:05,670 --> 00:57:07,740
反转它们 如果有人试图访问

1390
00:57:07,740 --> 00:57:10,920
它们，那么换一种方式思考这

1391
00:57:10,920 --> 00:57:14,370
是什么样的，我们不像已经有日志，我们

1392
00:57:14,370 --> 00:57:16,710
不需要任何重做信息，

1393
00:57:16,710 --> 00:57:19,500
因为我们的事务所做

1394
00:57:19,500 --> 00:57:21,480
的更改会立即持久化到持久内存中

1395
00:57:21,480 --> 00:57:24,000
，我们永远不必担心

1396
00:57:24,000 --> 00:57:26,000
关于从日志中重新应用它们，

1397
00:57:26,000 --> 00:57:31,560
所以现在在持久内存的上下文中，

1398
00:57:31,560 --> 00:57:33,270
这个协议是新的

1399
00:57:33,270 --> 00:57:35,610
，我们知道有另一个系统

1400
00:57:35,610 --> 00:57:38,040
做了

1401
00:57:38,040 --> 00:57:40,650
类似的事情

1402
00:57:40,650 --> 00:57:42,240
，伟大的 Phil 引起了我的注意 伯恩斯坦

1403
00:57:42,240 --> 00:57:45,060
有点像现代

1404
00:57:45,060 --> 00:57:49,010
并发重组的教父，他告诉我们一个

1405
00:57:49,010 --> 00:57:52,770
数据库，我认为它是 1970

1406
00:57:52,770 --> 00:57:55,290
年代的一家波多黎各电话公司，

1407
00:57:55,290 --> 00:57:58,200
所以在 ti 我波多黎各的

1408
00:57:58,200 --> 00:58:00,690
电力基础设施很差，他们

1409
00:58:00,690 --> 00:58:02,490
白天会断电好几次，

1410
00:58:02,490 --> 00:58:03,780
所以他们必须有一个

1411
00:58:03,780 --> 00:58:05,750
可以运行的数据库，可以随时立即恢复

1412
00:58:05,750 --> 00:58:08,250
，

1413
00:58:08,250 --> 00:58:10,770
断电了，因为如果你把

1414
00:58:10,770 --> 00:58:12,510
他关在我面前 书

1415
00:58:12,510 --> 00:58:14,640
在白天关闭多次，如果

1416
00:58:14,640 --> 00:58:16,730
你是一个恢复时间超长

1417
00:58:16,730 --> 00:58:21,330
那么你知道当你花时间

1418
00:58:21,330 --> 00:58:23,070
去覆盖数据库时，电源

1419
00:58:23,070 --> 00:58:25,020
可能会再次关闭，你只是

1420
00:58:25,020 --> 00:58:26,580
永远不会 能够跟上，所以他们有

1421
00:58:26,580 --> 00:58:29,160
一个类似这样的数据库，

1422
00:58:29,160 --> 00:58:30,900
显然它不是使用持久的

1423
00:58:30,900 --> 00:58:33,420
监视器系统内存，但它正在制作

1424
00:58:33,420 --> 00:58:35,730
数据库的副本，他们正在支付

1425
00:58:35,730 --> 00:58:37,500
随机随机

1426
00:58:37,500 --> 00:58:41,040
写入磁盘以换取的惩罚 是更快的

1427
00:58:41,040 --> 00:58:43,590
恢复时间 大多数现代系统

1428
00:58:43,590 --> 00:58:45,960
都不会做出这样的选择，在我们的

1429
00:58:45,960 --> 00:58:47,220
案例中，在日志记录之后，

1430
00:58:47,220 --> 00:58:48,870
我们将能够在运行时获得良好的

1431
00:58:48,870 --> 00:58:50,040
性能和良好的

1432
00:58:50,040 --> 00:58:53,520
恢复时间，因为测试

1433
00:58:53,520 --> 00:58:55,170
反应器设置 就像这样我们有一个

1434
00:58:55,170 --> 00:58:56,580
表堆所以你想运行这个查询

1435
00:58:56,580 --> 00:58:58,680
有一个更新一个元组所以表

1436
00:58:58,680 --> 00:59:01,980
堆将挂在内存和 DRAM 中

1437
00:59:01,980 --> 00:59:04,290
，然后在持久内存上会有第二个副本

1438
00:59:04,290 --> 00:59:06,510
，然后我们将有

1439
00:59:06,510 --> 00:59:08,700
我们的登录持久内存也是如此，所以

1440
00:59:08,700 --> 00:59:11,160
现在当我们更新表时，我们首先

1441
00:59:11,160 --> 00:59:13,740
更新表堆中的元组，然后

1442
00:59:13,740 --> 00:59:16,830
将更改写入内存中的开始，然后

1443
00:59:16,830 --> 00:59:19,620
我们将更改写入 nvm，然后

1444
00:59:19,620 --> 00:59:21,330
我们还将一些元数据

1445
00:59:21,330 --> 00:59:24,060
写入日志中 顺便说一句，这是

1446
00:59:24,060 --> 00:59:25,530
指向持久内存中元组的指针，

1447
00:59:25,530 --> 00:59:27,510
它发生了变化，这样我们就知道是否

1448
00:59:27,510 --> 00:59:29,670
在事务提交之前崩溃了，我们可以

1449
00:59:29,670 --> 00:59:31,530
使用它来确定我们需要

1450
00:59:31,530 --> 00:59:33,300
去哪里，并确保这些

1451
00:59:33,300 --> 00:59:34,650
更改不会被持久化和 当系统

1452
00:59:34,650 --> 00:59:37,380
重新启动时，这一切如何

1453
00:59:37,380 --> 00:59:39,780
运作是我们将依赖

1454
00:59:39,780 --> 00:59:42,030
多版本控制，我们将

1455
00:59:42,030 --> 00:59:43,920
像往常一样分配事务时间戳

1456
00:59:43,920 --> 00:59:46,680
，当我们清除

1457
00:59:46,680 --> 00:59:46,950


1458
00:59:46,950 --> 00:59:49,560
事务的更改时，我们将 会

1459
00:59:49,560 --> 00:59:51,660
想出w  hat 是当前正在运行的

1460
00:59:51,660 --> 00:59:54,060
飞行事务中的事务范围，

1461
00:59:54,060 --> 00:59:56,490
并记录

1462
00:59:56,490 --> 00:59:59,430
在我们的编辑器日志中，日志后面带有红色，

1463
00:59:59,430 --> 01:00:01,140
以及指向他们正在修改的两个帖子的指针

1464
01:00:01,140 --> 01:00:03,030
，这告诉

1465
01:00:03,030 --> 01:00:04,500
我们潜在的范围是什么

1466
01:00:04,500 --> 01:00:07,380
元组租用了崩溃后不应该保留的事务范围，

1467
01:00:07,380 --> 01:00:10,260
所以

1468
01:00:10,260 --> 01:00:11,730
现在当崩溃后

1469
01:00:11,730 --> 01:00:15,320
再次返回时，我们使用此失败组提交雨

1470
01:00:15,320 --> 01:00:18,390
来识别哪些元组无效，因此

1471
01:00:18,390 --> 01:00:20,220
我们不必查看单个

1472
01:00:20,220 --> 01:00:22,320
时间戳我们只是 看看是

1473
01:00:22,320 --> 01:00:23,940
不是我正在查看的元组有一个

1474
01:00:23,940 --> 01:00:25,859
落在这个范围内的时间戳，

1475
01:00:25,859 --> 01:00:27,630
因此我知道来自失败的

1476
01:00:27,630 --> 01:00:30,180
交易，我可以忽略它，所以

1477
01:00:30,180 --> 01:00:31,589
你基本上得到的

1478
01:00:31,589 --> 01:00:34,950
就像你得到的一样 撤消操作

1479
01:00:34,950 --> 01:00:37,380
是免费的，因为您通常

1480
01:00:37,380 --> 01:00:39,089
对多版本并发角色进行可见性检查，

1481
01:00:39,089 --> 01:00:42,420
因此它

1482
01:00:42,420 --> 01:00:45,329
在 Excel 幻灯片中更有意义，因此当

1483
01:00:45,329 --> 01:00:47,400
我恢复时，我只有一个分析

1484
01:00:47,400 --> 01:00:49,020
阶段，分析阶段看起来 通过

1485
01:00:49,020 --> 01:00:51,480
后面的日志并说这里是所有

1486
01:00:51,480 --> 01:00:52,410


1487
01:00:52,410 --> 01:00:54,569
可能没有

1488
01:00:54,569 --> 01:00:57,240
成功提交的事务的时间戳，然后我 Amelie 开始

1489
01:00:57,240 --> 01:00:58,770
处理事务，但现在我已经

1490
01:00:58,770 --> 01:01:00,420
计算了这个全局范围，它说

1491
01:01:00,420 --> 01:01:03,150
这是这里的事务范围

1492
01:01:03,150 --> 01:01:04,440
如果你遇到一个

1493
01:01:04,440 --> 01:01:06,900
由 BAM 修改或创建的元组，

1494
01:01:06,900 --> 01:01:08,220
我们的版本是由他们创建的，

1495
01:01:08,220 --> 01:01:09,990
你知道我们应该忽略它

1496
01:01:09,990 --> 01:01:11,760
，然后回收空间，这样你

1497
01:01:11,760 --> 01:01:13,500
就像在进行协作垃圾

1498
01:01:13,500 --> 01:01:15,930
收集一样 沿着并

1499
01:01:15,930 --> 01:01:17,760
识别不应该存在的元组，

1500
01:01:17,760 --> 01:01:20,369
所以让我们看一个例子，所以

1501
01:01:20,369 --> 01:01:22,410
在这里说这是我们的时间表，

1502
01:01:22,410 --> 01:01:24,540
以便在

1503
01:01:24,540 --> 01:01:26,670
事务开始时及时跟踪，让我

1504
01:01:26,670 --> 01:01:30,359
提交，所以 t1 从这里开始

1505
01:01:30,359 --> 01:01:32,190
当前的活动交易范围我们

1506
01:01:32,190 --> 01:01:34,710
知道它在 t1 和 t2 之间

1507
01:01:34,710 --> 01:01:35,849
，没有失败的交易，

1508
01:01:35,849 --> 01:01:37,349
因为这是我们第一次

1509
01:01:37,349 --> 01:01:39,480
在系统上打开它，所以现在让我们

1510
01:01:39,480 --> 01:01:43,740
在这里说 在 t1 提交之前，我们崩溃了，

1511
01:01:43,740 --> 01:01:46,319
然后当我们回来 T 说下一个

1512
01:01:46,319 --> 01:01:48,720
开始 t2 的事务，所以崩溃

1513
01:01:48,720 --> 01:01:50,160
后我们唯一需要做的事情

1514
01:01:50,160 --> 01:01:52,319
就是当我们扫描日志时，我们会

1515
01:01:52,319 --> 01:01:54,119
在这里找到一个条目来说明小麦的最后一个

1516
01:01:54,119 --> 01:01:55,380
范围 我们知道从上一次

1517
01:01:55,380 --> 01:01:59,040
组提交是在 t1 和 t2 之间，所以

1518
01:01:59,040 --> 01:02:00,190
现在将

1519
01:02:00,190 --> 01:02:02,470
这个因素的范围从 t2 到 t3，

1520
01:02:02,470 --> 01:02:06,520
所以现在当 T 2 运行并访问

1521
01:02:06,520 --> 01:02:08,800
数据库时，如果它遇到

1522
01:02:08,800 --> 01:02:11,770
由 t1 创建的任何东西，它知道它

1523
01:02:11,770 --> 01:02:12,900
应该是 垃圾收集和清理，

1524
01:02:12,900 --> 01:02:16,839
所以它必须开始清理它们，

1525
01:02:16,839 --> 01:02:20,349
删除那些说 t2 提交的东西，但

1526
01:02:20,349 --> 01:02:22,390
随后 t3 开始同样的事情，我们的活动

1527
01:02:22,390 --> 01:02:25,630
事务是 t3 t4，因为我们

1528
01:02:25,630 --> 01:02:28,300
知道 t1 修改的元组的指针，

1529
01:02:28,300 --> 01:02:30,609
我们将知道我们是否' 已经

1530
01:02:30,609 --> 01:02:33,849
清理了 t1 已经触及的所有东西

1531
01:02:33,849 --> 01:02:35,710
，假设在这种情况下，我们

1532
01:02:35,710 --> 01:02:36,730
没有一个事务，

1533
01:02:36,730 --> 01:02:39,190
你想要 t2 t2 t 它做什么，所以我们

1534
01:02:39,190 --> 01:02:40,930
可以在

1535
01:02:40,930 --> 01:02:42,760
单独的线程中运行后台真空只是为了扫描 并

1536
01:02:42,760 --> 01:02:44,260
找到所有 t 软管的东西来扭转它们

1537
01:02:44,260 --> 01:02:45,880
，这样我们就不会被

1538
01:02:45,880 --> 01:02:47,349
那些没有人破坏

1539
01:02:47,349 --> 01:02:49,900
它浪费空间的版本所困扰，然后 t4

1540
01:02:49,900 --> 01:02:52,480
开始，此时我们

1541
01:02:52,480 --> 01:02:56,380
知道我们已经得到了 t1 t1 修改的所有内容，

1542
01:02:56,380 --> 01:02:58,119
所以我们可以 将它从

1543
01:02:58,119 --> 01:03:01,569
我们的失败范围列表中删除，所以我

1544
01:03:01,569 --> 01:03:03,160
现在将向您展示

1545
01:03:03,160 --> 01:03:05,170
日志记录背后的红色表现可以做什么，但我

1546
01:03:05,170 --> 01:03:06,430
要做的事情与我们通常

1547
01:03:06,430 --> 01:03:08,050
刚刚了解的我们几乎讨论

1548
01:03:08,050 --> 01:03:09,880
事务的方式相反我' 我要先向你展示

1549
01:03:09,880 --> 01:03:12,430
恢复时间 我没有多少你

1550
01:03:12,430 --> 01:03:14,369
在恢复之前先展示性能

1551
01:03:14,369 --> 01:03:17,980
所以这个它正在运行，

1552
01:03:17,980 --> 01:03:19,930
在日志后面和

1553
01:03:19,930 --> 01:03:22,510
前面的 100 万个 TPCC 事务的日志后面重播

1554
01:03:22,510 --> 01:03:25,119
，这是在

1555
01:03:25,119 --> 01:03:26,859
我提到的英特尔模拟器上运行的 在这里你

1556
01:03:26,859 --> 01:03:30,460
可以了解

1557
01:03:30,460 --> 01:03:33,310
相对于 2d Ram 的持久内存的延迟，因此在这种

1558
01:03:33,310 --> 01:03:35,109
情况下，我们将这种情况保留在这里，我们

1559
01:03:35,109 --> 01:03:39,069
将速度提高 2 倍，

1560
01:03:39,069 --> 01:03:41,079
因此这里的延迟是

1561
01:03:41,079 --> 01:03:43,150
对称的，因此读取 并且写入成本

1562
01:03:43,150 --> 01:03:45,160
是相同的，顺序和

1563
01:03:45,160 --> 01:03:48,160
随机写入是这样顺序的，

1564
01:03:48,160 --> 01:03:50,230
顺序和随机访问这些

1565
01:03:50,230 --> 01:03:52,030
是相同的成本，然后它们以

1566
01:03:52,030 --> 01:03:53,410
正确的成本读取也是相同的，

1567
01:03:53,410 --> 01:03:55,540
但是真正的硬件读取会

1568
01:03:55,540 --> 01:03:58,240
比读取速度快 写入所以我们

1569
01:03:58,240 --> 01:04:01,990
要配对重新

1570
01:04:01,990 --> 01:04:03,670
启动系统和恢复日志所需的时间 将

1571
01:04:03,670 --> 01:04:05,530
debisch 恢复到正确的状态，用于

1572
01:04:05,530 --> 01:04:07,780
spankers 硬盘 固态闪存

1573
01:04:07,780 --> 01:04:09,960
驱动器和持久内存模拟器

1574
01:04:09,960 --> 01:04:13,060
所以你看到的是 直接

1575
01:04:13,060 --> 01:04:14,109
记录

1576
01:04:14,109 --> 01:04:15,910
不同

1577
01:04:15,910 --> 01:04:18,460
方法的性能大致相同，

1578
01:04:18,460 --> 01:04:19,960
因为这可能是成本或这些

1579
01:04:19,960 --> 01:04:21,700
也解锁规模，但这是一对夫妇，您

1580
01:04:21,700 --> 01:04:23,619
知道这是访问磁盘然后重播日志的成本，

1581
01:04:23,619 --> 01:04:26,019


1582
01:04:26,019 --> 01:04:28,239
两者的组合是 大致相同，

1583
01:04:28,239 --> 01:04:29,739
但现在已经成熟，但

1584
01:04:29,739 --> 01:04:33,549
希望恢复时间快一

1585
01:04:33,549 --> 01:04:36,549
千倍，因为当你打开系统时，你所做的

1586
01:04:36,549 --> 01:04:38,950
就是检查

1587
01:04:38,950 --> 01:04:40,930
是否正确

1588
01:04:40,930 --> 01:04:42,910
来自日志右侧的失败时间戳，

1589
01:04:42,910 --> 01:04:45,339
这就是你需要做的所有事情，我现在

1590
01:04:45,339 --> 01:04:47,529
我的数据库至少在逻辑级别已经完全恢复，

1591
01:04:47,529 --> 01:04:50,049
所以这

1592
01:04:50,049 --> 01:04:52,029
刚刚向你展示的是性能

1593
01:04:52,029 --> 01:04:54,180
优势就在日志记录之后

1594
01:04:54,180 --> 01:04:56,619
持久内存和较旧的

1595
01:04:56,619 --> 01:04:58,239
存储设备大致相同，

1596
01:04:58,239 --> 01:05:00,400
大约有一千个脖子，所以现在你

1597
01:05:00,400 --> 01:05:02,559
看看这个，然后肯定地说，日志后面的

1598
01:05:02,559 --> 01:05:03,670
日志比提前写日志要快，

1599
01:05:03,670 --> 01:05:05,739
但为什么我必须在

1600
01:05:05,739 --> 01:05:07,720
持久内存中这样做，因为我

1601
01:05:07,720 --> 01:05:09,999


1602
01:05:09,999 --> 01:05:11,980


1603
01:05:11,980 --> 01:05:15,099


1604
01:05:15,099 --> 01:05:17,170


1605
01:05:17,170 --> 01:05:19,029


1606
01:05:19,029 --> 01:05:21,549


1607
01:05:21,549 --> 01:05:24,099
“M获得惊人的表现对不起惊人的恢复时间，这些其他存储设备以及现在好了，如果我们在运行时的性能去看看现在你看到一个很大的区别，从而为的运行时性能正前方记录你看到的，当然当你添加 当您

1608
01:05:24,099 --> 01:05:26,680
拥有更快的存储设备时，您

1609
01:05:26,680 --> 01:05:27,730
将获得更好的性能，因此

1610
01:05:27,730 --> 01:05:29,200
持久内存比

1611
01:05:29,200 --> 01:05:30,700
带有旋转硬盘的固态驱动器更快

1612
01:05:30,700 --> 01:05:32,589
，这就是您的瓶颈

1613
01:05:32,589 --> 01:05:33,970


1614
01:05:33,970 --> 01:05:35,289
在这种情况下，您显然要为 TPCC 提交事务，

1615
01:05:35,289 --> 01:05:39,009
这就是为什么在那里持久性的原因，持久

1616
01:05:39,009 --> 01:05:40,029
性内存

1617
01:05:40,029 --> 01:05:42,220
为直接记录获得了最佳性能，但是

1618
01:05:42,220 --> 01:05:44,289
现在如果您在记录后立即执行，

1619
01:05:44,289 --> 01:05:46,390
您就会明白为什么需要持久性内存，

1620
01:05:46,390 --> 01:05:47,950
因为在旋转磁盘的情况下

1621
01:05:47,950 --> 01:05:49,839
固态驱动器中的硬盘驱动器，

1622
01:05:49,839 --> 01:05:52,299


1623
01:05:52,299 --> 01:05:53,769
当您在 log 后面使用时，运行时性能会降低 10 倍，

1624
01:05:53,769 --> 01:05:55,869
但只有在使用

1625
01:05:55,869 --> 01:05:56,950
持久内存时，

1626
01:05:56,950 --> 01:05:59,410
您才能获得 1 点 2 倍

1627
01:05:59,410 --> 01:06:01,539
的性能加速，这是因为在

1628
01:06:01,539 --> 01:06:04,450


1629
01:06:04,450 --> 01:06:06,369
使用持久性内存进行日志记录的持久性，因为您

1630
01:06:06,369 --> 01:06:09,880


1631
01:06:09,880 --> 01:06:12,609
对持久性内存上的表堆进行平坦的快速随机写入，您知道

1632
01:06:12,609 --> 01:06:14,650
这是随机 I/O，这

1633
01:06:14,650 --> 01:06:17,589
在这些平板电脑较慢的设备上会很糟糕，

1634
01:06:17,589 --> 01:06:19,900
因此这是

1635
01:06:19,900 --> 01:06:23,049
日志记录的组合 和持久

1636
01:06:23,049 --> 01:06:24,420
内存是正确的

1637
01:06:24,420 --> 01:06:25,740
组合是

1638
01:06:25,740 --> 01:06:29,940
在这种情况下在这里获得最佳性能 好的

1639
01:06:29,940 --> 01:06:31,020
所以只是总结我们所谈论的

1640
01:06:31,020 --> 01:06:34,200
嗯 我们讨论了

1641
01:06:34,200 --> 01:06:36,240
如果你知道你有

1642
01:06:36,240 --> 01:06:38,070
字节可寻址的持久内存，你可以

1643
01:06:38,070 --> 01:06:41,160
重新组织你的存储架构以

1644
01:06:41,160 --> 01:06:42,900
利用它并

1645
01:06:42,900 --> 01:06:44,880
减少更新事务期间的数据重复和数据冗余副本的数量，

1646
01:06:44,880 --> 01:06:48,210


1647
01:06:48,210 --> 01:06:50,460
然后我们看到了这种情况

1648
01:06:50,460 --> 01:06:55,950
紧随其后的球赛是一种

1649
01:06:55,950 --> 01:06:57,180
技术，可以让您获得更好的

1650
01:06:57,180 --> 01:07:00,390
恢复时间，因为您正在

1651
01:07:00,390 --> 01:07:01,800
利用这样一个事实，即您知道

1652
01:07:01,800 --> 01:07:03,720
自己有一个写入

1653
01:07:03,720 --> 01:07:05,250
持久内存的协议，因此您可以

1654
01:07:05,250 --> 01:07:06,960
设置自己的系统，以便

1655
01:07:06,960 --> 01:07:09,240
在恢复时 你必须做

1656
01:07:09,240 --> 01:07:10,470
最少的工作才能将数据库恢复

1657
01:07:10,470 --> 01:07:13,200
到正确的状态，所以正如我所说，我

1658
01:07:13,200 --> 01:07:19,680
认为这种硬件现在可以用于精确内存

1659
01:07:19,680 --> 01:07:24,060
，我知道一旦

1660
01:07:24,060 --> 01:07:25,320
变得更加普遍和更加

1661
01:07:25,320 --> 01:07:28,170
商品化，你会看到很多

1662
01:07:28,170 --> 01:07:30,150
数据库系统 出来带你

1663
01:07:30,150 --> 01:07:31,920
在一开始就利用优势

1664
01:07:31,920 --> 01:07:34,320
他们都只是将它用作更大

1665
01:07:34,320 --> 01:07:35,490
更便宜的内存，但

1666
01:07:35,490 --> 01:07:39,180
速度稍慢 以及哪些系统

1667
01:07:39,180 --> 01:07:41,160
会比这更敏感的一些症状但是

1668
01:07:41,160 --> 01:07:43,860
如果你知道但你知道

1669
01:07:43,860 --> 01:07:47,060
关于扩展 DRAM 限制

1670
01:07:47,060 --> 01:07:49,590
的预测结果是真的

1671
01:07:49,590 --> 01:07:51,930
那么每个人都可以切换

1672
01:07:51,930 --> 01:07:53,840
到看起来像选择加入的东西

1673
01:07:53,840 --> 01:07:58,800
好的，所以现在我想

1674
01:07:58,800 --> 01:08:03,080
结束讨论

1675
01:08:03,080 --> 01:08:05,700
我们可以在我们的数据库中进行的一些计算加速，

1676
01:08:05,700 --> 01:08:08,540
并且明确地我想讨论 GPU，

1677
01:08:08,540 --> 01:08:11,490
正如我所说的 FPGA，

1678
01:08:11,490 --> 01:08:16,380
它们用于它们

1679
01:08:16,380 --> 01:08:20,310
现在变得越来越普遍 排序

1680
01:08:20,310 --> 01:08:22,290
是因为你可以在亚马逊上获得它们，

1681
01:08:22,290 --> 01:08:24,810
你可以获得 ec2 实例，

1682
01:08:24,810 --> 01:08:26,819
但据我所知，今天的 GPU

1683
01:08:26,819 --> 01:08:29,100
数据库比

1684
01:08:29,100 --> 01:08:31,920
FPGA 数据库多，我认为部分原因是

1685
01:08:31,920 --> 01:08:35,130
因为开销或

1686
01:08:35,130 --> 01:08:37,580
工程成本 编写 FPGA

1687
01:08:37,580 --> 01:08:39,770
代码与编写 GPU 代码，或者只是

1688
01:08:39,770 --> 01:08:42,410
使用 GPU 和库（例如

1689
01:08:42,410 --> 01:08:44,920
NVIDIA 提供的东西），这是

1690
01:08:44,920 --> 01:08:47,810
获得新硬件或非传统硬件优势的重要入口

1691
01:08:47,810 --> 01:08:50,569


1692
01:08:50,569 --> 01:08:51,830
硬件和您的数据库系统的

1693
01:08:51,830 --> 01:08:56,689
GPU 比 PJ 的低，所以如果您

1694
01:08:56,689 --> 01:08:58,729
想使用 GPU 或在我们的数据库中

1695
01:08:58,729 --> 01:09:01,250
，我们需要

1696
01:09:01,250 --> 01:09:02,450
了解哪些方面我们需要了解哪些 GPU 对哪些方面

1697
01:09:02,450 --> 01:09:04,899
有好处 GPU 将包含

1698
01:09:04,899 --> 01:09:10,310
数千个 核心，但这些核心可以执行

1699
01:09:10,310 --> 01:09:12,339
的计算类型或程序

1700
01:09:12,339 --> 01:09:17,450


1701
01:09:17,450 --> 01:09:19,279
必须

1702
01:09:19,279 --> 01:09:20,990
比我们通常在成熟的至强核心上运行的更复杂和更简单，

1703
01:09:20,990 --> 01:09:23,630
这是因为

1704
01:09:23,630 --> 01:09:26,060
这些核心旨在执行

1705
01:09:26,060 --> 01:09:28,760
相对于至强可以支持的相对简单的操作可以

1706
01:09:28,760 --> 01:09:32,630


1707
01:09:32,630 --> 01:09:35,960
在大量数据数据流上重复，

1708
01:09:35,960 --> 01:09:38,330
所以您希望

1709
01:09:38,330 --> 01:09:40,220
能够说最好的情况就像

1710
01:09:40,220 --> 01:09:41,630


1711
01:09:41,630 --> 01:09:44,630
在一堆列上进行家具扫描一样 或将单个

1712
01:09:44,630 --> 01:09:46,189
列分解为不同的块，

1713
01:09:46,189 --> 01:09:47,660
您可以将其发送到所有

1714
01:09:47,660 --> 01:09:49,130
内核，并且所有内核都在做

1715
01:09:49,130 --> 01:09:53,200
同样的事情，并且没有

1716
01:09:53,200 --> 01:09:54,530
间接性

1717
01:09:54,530 --> 01:09:57,500
没有条件分支它只是

1718
01:09:57,500 --> 01:09:59,030
说我是 从头开始，

1719
01:09:59,030 --> 01:10:00,530
我将一遍又一遍地应用相同的过滤器，

1720
01:10:00,530 --> 01:10:04,040
所以这基本上就是

1721
01:10:04,040 --> 01:10:06,500
我所说的，但就像我们

1722
01:10:06,500 --> 01:10:08,390
想要下推到 GPU 或

1723
01:10:08,390 --> 01:10:12,620
任何不需要额外输入的

1724
01:10:12,620 --> 01:10:14,270
东西一样 决定下一步做什么或

1725
01:10:14,270 --> 01:10:17,810
要求程序执行

1726
01:10:17,810 --> 01:10:19,250
分支，例如 if 原因和诸如此类的

1727
01:10:19,250 --> 01:10:21,770
事情，因此对它真正有益的是

1728
01:10:21,770 --> 01:10:24,050
顺序扫描对 B 加树真正不利的是什么，

1729
01:10:24,050 --> 01:10:25,610
因为这就像

1730
01:10:25,610 --> 01:10:28,550
查看人的内容

1731
01:10:28,550 --> 01:10:30,470
误入歧途的节点并做出决定或

1732
01:10:30,470 --> 01:10:34,760
去哪里 现在在

1733
01:10:34,760 --> 01:10:36,410
研究文献中有建议构建像 B 加

1734
01:10:36,410 --> 01:10:37,670
树或其他基于树的数据

1735
01:10:37,670 --> 01:10:39,860
结构，您可以在 GPU 上运行这些数据结构以

1736
01:10:39,860 --> 01:10:41,780
尽我所知 没有人实际

1737
01:10:41,780 --> 01:10:44,380
使用它们

1738
01:10:44,380 --> 01:10:45,820
一次又一次 这不是 我的

1739
01:10:45,820 --> 01:10:47,200
研究领域，我不知道

1740
01:10:47,200 --> 01:10:49,210
它们的局限性是什么，但在大多数

1741
01:10:49,210 --> 01:10:51,270
情况下，人们不会在

1742
01:10:51,270 --> 01:10:53,500
人们身上进行交易 人们不会在 GPU 上进行交易

1743
01:10:53,500 --> 01:10:56,170
他们主要用于

1744
01:10:56,170 --> 01:10:58,900
OLAP 工作 加载我们

1745
01:10:58,900 --> 01:11:00,460
需要注意的另一点是，

1746
01:11:00,460 --> 01:11:02,260
尽管 GPU 现在将拥有大量

1747
01:11:02,260 --> 01:11:05,800
内存，但它不会

1748
01:11:05,800 --> 01:11:09,040
与 CPU 缓存一致，这意味着

1749
01:11:09,040 --> 01:11:12,760
如果您想这样做，如果您的

1750
01:11:12,760 --> 01:11:15,610
数据库可以更新并且 它

1751
01:11:15,610 --> 01:11:18,400
存在于 DRAM 甚至 SSD 中，您要么

1752
01:11:18,400 --> 01:11:20,650
需要将整个内容

1753
01:11:20,650 --> 01:11:23,050
连同所有更新一起复制到 GPU 中，要么像

1754
01:11:23,050 --> 01:11:24,610
合并操作一样逐步应用这些更改，

1755
01:11:24,610 --> 01:11:26,560
但这不像我

1756
01:11:26,560 --> 01:11:30,310
让你知道我有我的数据 DRAM

1757
01:11:30,310 --> 01:11:32,800
和我在那里进行更新 GPU

1758
01:11:32,800 --> 01:11:34,930
不会神奇地看到我们

1759
01:11:34,930 --> 01:11:36,700
必须明确发送消息并

1760
01:11:36,700 --> 01:11:40,060
说这是新数据的更改所以

1761
01:11:40,060 --> 01:11:41,440
这里的想法是我们想

1762
01:11:41,440 --> 01:11:43,000
弄清楚我们可以卸载到哪些计算

1763
01:11:43,000 --> 01:11:45,310
GPU，它将主要是

1764
01:11:45,310 --> 01:11:48,670
中央扫描，几乎有

1765
01:11:48,670 --> 01:11:52,030
实现

1766
01:11:52,030 --> 01:11:54,220


1767
01:11:54,220 --> 01:11:56,980


1768
01:11:56,980 --> 01:12:00,880


1769
01:12:00,880 --> 01:12:01,810


1770
01:12:01,810 --> 01:12:03,010
他们正在排序

1771
01:12:03,010 --> 01:12:05,950
算法的实现显然是

1772
01:12:05,950 --> 01:12:07,300
为了避免这些条件和

1773
01:12:07,300 --> 01:12:09,880
分支，所以高级

1774
01:12:09,880 --> 01:12:12,430
架构看起来像这样，所以说

1775
01:12:12,430 --> 01:12:13,480
这是我们整个学期要讨论的内容

1776
01:12:13,480 --> 01:12:15,340
，然后我们有

1777
01:12:15,340 --> 01:12:17,830
一个 CPU 或 所有多插槽系统，

1778
01:12:17,830 --> 01:12:19,990
然后我们将我们的数据库挂在

1779
01:12:19,990 --> 01:12:22,510
DRAM 中，我们可以了解 Numa

1780
01:12:22,510 --> 01:12:24,460
区域，以识别您知道

1781
01:12:24,460 --> 01:12:26,590
什么亮度更接近给定

1782
01:12:26,590 --> 01:12:30,160
核心，因此现在 PCI

1783
01:12:30,160 --> 01:12:33,240
Express 总线正在运行 成为我们的

1784
01:12:33,240 --> 01:12:35,290
GPU，我们需要将它们视为

1785
01:12:35,290 --> 01:12:39,220
另一个插槽，它拥有更多

1786
01:12:39,220 --> 01:12:41,740
看起来非常不同的内核，而且

1787
01:12:41,740 --> 01:12:43,840
他们拥有自己的 D Ram

1788
01:12:43,840 --> 01:12:46,720
并且他们不会

1789
01:12:46,720 --> 01:12:49,230
同步 所以我认为对于 GPU 和

1790
01:12:49,230 --> 01:12:52,540
2020 我认为你只能获得一次高达 100

1791
01:12:52,540 --> 01:12:54,400
gigs 的 DRAM

1792
01:12:54,400 --> 01:12:56,560
我可能在高端的，而

1793
01:12:56,560 --> 01:12:58,120
像在 CPU 上我们可以获得

1794
01:12:58,120 --> 01:13:01,240
并且他高达 48 TB 的 DRAM 如果我们

1795
01:13:01,240 --> 01:13:04,150
有很多 钱所以另一件事

1796
01:13:04,150 --> 01:13:06,280
我们 请注意

1797
01:13:06,280 --> 01:13:10,540
我们的计算和存储之间的带宽，因此要

1798
01:13:10,540 --> 01:13:14,650
在 DRAM 和 CPU 内核之间使用 ddr4，

1799
01:13:14,650 --> 01:13:16,860
我们可以

1800
01:13:16,860 --> 01:13:23,050
通过 pci-x PCIe 总线每秒处理大约 40 GB 的带宽，我认为

1801
01:13:23,050 --> 01:13:25,810
我们现在可以做的最好的是 16 GB

1802
01:13:25,810 --> 01:13:28,570
每秒所以它不是那么远

1803
01:13:28,570 --> 01:13:30,400
它不是一个数量级但

1804
01:13:30,400 --> 01:13:32,260
它仍然比

1805
01:13:32,260 --> 01:13:35,170
我们在这里可以做的要慢得多所以这

1806
01:13:35,170 --> 01:13:38,080
意味着这是

1807
01:13:38,080 --> 01:13:39,880
我们将面临的挑战之一是你必须

1808
01:13:39,880 --> 01:13:41,590
运行 查询我们必须在这里发送一堆数据

1809
01:13:41,590 --> 01:13:43,480
，然后能够处理

1810
01:13:43,480 --> 01:13:45,790
并取回它，这

1811
01:13:45,790 --> 01:13:47,680
将使它变得更快，只是在这里运行它

1812
01:13:47,680 --> 01:13:51,730
我用 CPU 我

1813
01:13:51,730 --> 01:13:52,930
不会有 尽可能多的核心，但这个

1814
01:13:52,930 --> 01:13:54,970
带宽将成为我们的瓶颈，

1815
01:13:54,970 --> 01:13:55,800


1816
01:13:55,800 --> 01:13:58,690
所以现在 NVIDIA 有一个叫做 MV

1817
01:13:58,690 --> 01:14:01,090
链接的东西，它在两个不同的 GPU 之间为您提供每秒 25 GB 的数据，

1818
01:14:01,090 --> 01:14:04,240


1819
01:14:04,240 --> 01:14:06,460
你知道你

1820
01:14:06,460 --> 01:14:09,190
在它们之间传递的消息你

1821
01:14:09,190 --> 01:14:12,280
也可以得到 从 DRAM 存储器向上走的 MV 链接

1822
01:14:12,280 --> 01:14:16,270
以

1823
01:14:16,270 --> 01:14:19,930
每秒 25 GB 的速度进入 CPU 内存，尽管

1824
01:14:19,930 --> 01:14:22,420
据我所知，这种 MV 链接技术

1825
01:14:22,420 --> 01:14:24,490
仅适用于 PowerPC 机器，但我

1826
01:14:24,490 --> 01:14:27,070
不认为它仅适用于 x86，因此您必须

1827
01:14:27,070 --> 01:14:29,290
在 IBM 电源上运行才能获得

1828
01:14:29,290 --> 01:14:30,250
优势

1829
01:14:30,250 --> 01:14:33,340
我认为英特尔有自己的结构，但我

1830
01:14:33,340 --> 01:14:35,680
忘记了它所谓的 a 和 B 可能

1831
01:14:35,680 --> 01:14:40,360
也有一些东西，所以

1832
01:14:40,360 --> 01:14:43,840
你组织我们的系统有多好，所以

1833
01:14:43,840 --> 01:14:45,130
我们可以采取三种不同的方法来解决

1834
01:14:45,130 --> 01:14:47,260
我们想要如何在我们的 GPU 中使用

1835
01:14:47,260 --> 01:14:49,780
数据库系统所以第一个是

1836
01:14:49,780 --> 01:14:52,300
最简单的方法就是把我们的整个

1837
01:14:52,300 --> 01:14:54,910
数据库放下或复制

1838
01:14:54,910 --> 01:14:58,360
到 PCIe 总线上把它放在 GPU 上

1839
01:14:58,360 --> 01:15:00,340
，现在所有的查询都是自己的，如果它有

1840
01:15:00,340 --> 01:15:04,090
数据在 GPU 上，这

1841
01:15:04,090 --> 01:15:07,150
很明显 仅限

1842
01:15:07,150 --> 01:15:08,800
于 GPU 中可用的 VRAM 数量，如果您的

1843
01:15:08,800 --> 01:15:11,000
数据库超过该大小，那么这项

1844
01:15:11,000 --> 01:15:13,670
工作也许您可以将一堆 GPU 菊花链

1845
01:15:13,670 --> 01:15:15,470
在一起，并让棕褐色

1846
01:15:15,470 --> 01:15:16,940
协调谁拥有哪些数据

1847
01:15:16,940 --> 01:15:18,680
并将结果组合在 cpu 中

1848
01:15:18,680 --> 01:15:23,960
丙烯酸酯 使用不同的 GPU，但据

1849
01:15:23,960 --> 01:15:25,580
我所知，我认为

1850
01:15:25,580 --> 01:15:27,080
任何主要供应商都不再这样做了，所以

1851
01:15:27,080 --> 01:15:29,720


1852
01:15:29,720 --> 01:15:31,400
当它被称为 map D 时，这实际上是我过去常做的平静而美好的事情，

1853
01:15:31,400 --> 01:15:33,940
他们已经明智地将它构建为

1854
01:15:33,940 --> 01:15:38,510
这里是第三个，所以第二种

1855
01:15:38,510 --> 01:15:40,660
方法是你认识到你

1856
01:15:40,660 --> 01:15:43,430
对于某些查询或某些数据库，

1857
01:15:43,430 --> 01:15:45,230
你可能不需要

1858
01:15:45,230 --> 01:15:49,730
GPU 中的表的所有列，所以

1859
01:15:49,730 --> 01:15:52,120
你只复制它们的一部分我

1860
01:15:52,120 --> 01:15:54,560
现在你的查询规划器可以识别

1861
01:15:54,560 --> 01:15:56,570
出这部分查询我可以

1862
01:15:56,570 --> 01:15:57,860
在 GPU 上运行，因为这些列

1863
01:15:57,860 --> 01:16:00,500
向下到 GPU 但是

1864
01:16:00,500 --> 01:16:04,010
然后我会取回一些偏移量，你知道吗？

1865
01:16:04,010 --> 01:16:07,820
元组

1866
01:16:07,820 --> 01:16:08,810


1867
01:16:08,810 --> 01:16:10,400
根据

1868
01:16:10,400 --> 01:16:11,840
打开我的记忆的其他列的偏移量稍微覆盖了这两次打击所需的电池，

1869
01:16:11,840 --> 01:16:13,580
然后我只制作了其中的两个结果

1870
01:16:13,580 --> 01:16:15,550
并将它们返回到应用程序，

1871
01:16:15,550 --> 01:16:19,160
因此对于我看到的这个 这样

1872
01:16:19,160 --> 01:16:20,750
做通常需要

1873
01:16:20,750 --> 01:16:22,760
管理员我 确定这些

1874
01:16:22,760 --> 01:16:24,530
应该是 GPU 常驻列，

1875
01:16:24,530 --> 01:16:27,230
这些应该在 CPU 中，你

1876
01:16:27,230 --> 01:16:28,940
知道这有局限性，因为人们

1877
01:16:28,940 --> 01:16:31,190
可能并不总是知道如何选择

1878
01:16:31,190 --> 01:16:33,290
正确的方法，可能有一些

1879
01:16:33,290 --> 01:16:34,970
其他系统可以

1880
01:16:34,970 --> 01:16:38,710
在你之前进行配置 自动知道

1881
01:16:38,710 --> 01:16:42,560
最好的方法虽然是支持

1882
01:16:42,560 --> 01:16:46,400
流算法，我可以

1883
01:16:46,400 --> 01:16:49,370
让数据即时移动数据

1884
01:16:49,370 --> 01:16:51,500
从 CPU 内存向下移动到 GPU

1885
01:16:51,500 --> 01:16:55,340
内存并逐步处理它，

1886
01:16:55,340 --> 01:16:57,200
同时我继续发送

1887
01:16:57,200 --> 01:16:58,820
比你知道的更多 为什么要发送给他们发送

1888
01:16:58,820 --> 01:17:00,860
GPU 触发的第一批数据

1889
01:17:00,860 --> 01:17:02,780
开始处理它然后

1890
01:17:02,780 --> 01:17:04,550
背景我现在开始向下传输

1891
01:17:04,550 --> 01:17:07,310


1892
01:17:07,310 --> 01:17:09,320
我将需要的下一波数据，所以当

1893
01:17:09,320 --> 01:17:11,030
他们完成时 GP 完成

1894
01:17:11,030 --> 01:17:13,160
了第一批的处理，第二批就

1895
01:17:13,160 --> 01:17:14,510
准备好了，它一直在

1896
01:17:14,510 --> 01:17:16,700
继续，就像 GPU 总是被

1897
01:17:16,700 --> 01:17:19,040
充分利用一样，有散列连接，

1898
01:17:19,040 --> 01:17:20,519
有排序合并连接，有

1899
01:17:20,519 --> 01:17:24,090
b 专辑的预算可以他们

1900
01:17:24,090 --> 01:17:25,710
的专辑的实现

1901
01:17:25,710 --> 01:17:30,119
可以为你做到如此努力卖家

1902
01:17:30,119 --> 01:17:31,469
数据库

1903
01:17:31,469 --> 01:17:33,809
是几年前我非常感兴趣的东西我们最终

1904
01:17:33,809 --> 01:17:38,699
在CMU举办了一个关于

1905
01:17:38,699 --> 01:17:41,010
这个主题的系列研讨会所以 我邀请了

1906
01:17:41,010 --> 01:17:42,719
这些供应商中的大多数在这里 啊哈见面 我

1907
01:17:42,719 --> 01:17:44,070
去了俱乐部地图执事添加了一对

1908
01:17:44,070 --> 01:17:46,889


1909
01:17:46,889 --> 01:17:49,409
来自 uber 的 DB 尖叫明亮通风的茶蜜蜂 那是在

1910
01:17:49,409 --> 01:17:51,659
我们参加系列研讨会后出现的，但重点

1911
01:17:51,659 --> 01:17:52,650
是我 尝试制作的是，如果您真的

1912
01:17:52,650 --> 01:17:53,789
对这个主题感兴趣并想

1913
01:17:53,789 --> 01:17:56,460
了解更多信息，您可以在此处访问此 URL

1914
01:17:56,460 --> 01:17:58,499
，我有一个整体 我认为有来自所有这些主要数据库供应商的八种

1915
01:17:58,499 --> 01:18:00,570
不同的八种或七种或八种

1916
01:18:00,570 --> 01:18:02,489
不同的讲座或演讲

1917
01:18:02,489 --> 01:18:03,960
那些正在

1918
01:18:03,960 --> 01:18:05,880
构建 GPU 数据库的人，他们会告诉

1919
01:18:05,880 --> 01:18:07,320
你，你知道是什么让它们变得有趣

1920
01:18:07,320 --> 01:18:10,889
以及它们是如何工作的，但我想谈论的最后一件事

1921
01:18:10,889 --> 01:18:13,110
是哈佛

1922
01:18:13,110 --> 01:18:17,099
的内存交易，所以每年我都会争论是否

1923
01:18:17,099 --> 01:18:21,570
要提出这个问题，因为它一直

1924
01:18:21,570 --> 01:18:23,730
由于安全漏洞而被英特尔关闭，

1925
01:18:23,730 --> 01:18:27,059
所以等待超过

1926
01:18:27,059 --> 01:18:28,440
事务内存是因为

1927
01:18:28,440 --> 01:18:30,719
你的代码中有一个关键部分

1928
01:18:30,719 --> 01:18:33,210
，现在我可以有一个心脏我们的

1929
01:18:33,210 --> 01:18:35,280
事务由 CPU 管理，它

1930
01:18:35,280 --> 01:18:37,469
跟踪加载和存储

1931
01:18:37,469 --> 01:18:39,840
操作 到我的

1932
01:18:39,840 --> 01:18:42,539
事务的内存中，然后如果我现在

1933
01:18:42,539 --> 01:18:44,940
确定有

1934
01:18:44,940 --> 01:18:46,739
另一个线程也在运行一个

1935
01:18:46,739 --> 01:18:48,300
事务，该事务可能会被读取或修改

1936
01:18:48,300 --> 01:18:49,949


1937
01:18:49,949 --> 01:18:52,650
我触及的相同内容，那么它可以继续并中止我并

1938
01:18:52,650 --> 01:18:54,840
重新启动 所以它的工作方式

1939
01:18:54,840 --> 01:18:57,570
基本上像 OCC 一样运行，它将

1940
01:18:57,570 --> 01:18:59,610
在

1941
01:18:59,610 --> 01:19:02,159
您的事务的私人工作区中维护读取权限，然后

1942
01:19:02,159 --> 01:19:04,050
当您继续并提交时，他们会

1943
01:19:04,050 --> 01:19:05,519
检查是否进行

1944
01:19:05,519 --> 01:19:07,050
验证以查看其他人是否

1945
01:19:07,050 --> 01:19:08,699
已修改 与我

1946
01:19:08,699 --> 01:19:13,230
读或写的位置相同，这有点酷，

1947
01:19:13,230 --> 01:19:14,340
因为基本上有效的方法是

1948
01:19:14,340 --> 01:19:17,340
它们只是捎带

1949
01:19:17,340 --> 01:19:18,869
它使用的任何方式的缓存一致性协议

1950
01:19:18,869 --> 01:19:20,760
跟踪对 Corazon Singh 的加热

1951
01:19:20,760 --> 01:19:22,559
，他们正在使用它来找出

1952
01:19:22,559 --> 01:19:24,019


1953
01:19:24,019 --> 01:19:25,980
在不同内核上运行的日常事务发生冲突

1954
01:19:25,980 --> 01:19:31,380
的时间，所以这正是

1955
01:19:31,380 --> 01:19:32,999
由 Maurice Herlihy 发明的

1956
01:19:32,999 --> 01:19:33,630


1957
01:19:33,630 --> 01:19:36,300
，他发明了线性化能力，他

1958
01:19:36,300 --> 01:19:38,400
曾经是一个 CMU 教授，但

1959
01:19:38,400 --> 01:19:40,410
现在他是布朗大学的教授，

1960
01:19:40,410 --> 01:19:42,690
我认为在 1990 年代初期他对此进行了修改，

1961
01:19:42,690 --> 01:19:44,910
实际上英特尔将其放入他们的硬件中，

1962
01:19:44,910 --> 01:19:47,340
我认为从现在开始，他们现在站在

1963
01:19:47,340 --> 01:19:50,700
2012 年，然后在 2013 年出现，但

1964
01:19:50,700 --> 01:19:53,490
后来他们发现了一个错误 在 2014 年，

1965
01:19:53,490 --> 01:19:55,740
然后他们禁用了它，然后我想

1966
01:19:55,740 --> 01:19:57,360
我就像 2017 年一样，

1967
01:19:57,360 --> 01:19:58,890
这是新的 CPU，因为错误已修复，

1968
01:19:58,890 --> 01:20:01,350
继续重命名 bêlit 然后是 2000

1969
01:20:01,350 --> 01:20:03,000
万青少年我认为还有另一个我

1970
01:20:03,000 --> 01:20:04,530
认为它被称为 vom b-bomb 或

1971
01:20:04,530 --> 01:20:06,090
诸如兔子之类的东西，所以

1972
01:20:06,090 --> 01:20:08,370
当你使用它时，另一个可能会导致安全漏洞的错误

1973
01:20:08,370 --> 01:20:10,110
所以这就是我所说的，所以

1974
01:20:10,110 --> 01:20:11,610
我希望你有点想教

1975
01:20:11,610 --> 01:20:12,870
我们并展示这个并让你们使用

1976
01:20:12,870 --> 01:20:16,560
这个但是喜欢 我是叔叔 你是否

1977
01:20:16,560 --> 01:20:18,900
知道这实际上就像

1978
01:20:18,900 --> 01:20:20,190
你今天可以

1979
01:20:20,190 --> 01:20:24,120
在现代现代英特尔 CPU 上安全地使用它我

1980
01:20:24,120 --> 01:20:26,510
不知道 AMD 是否有类似的问题

1981
01:20:26,510 --> 01:20:30,000
所以我已经说过的一切

1982
01:20:30,000 --> 01:20:31,320
就像它的工作方式一样 你

1983
01:20:31,320 --> 01:20:32,910
跟踪每一个写，哦，读写

1984
01:20:32,910 --> 01:20:34,680
集必须适合你的 l1 缓存，所以你

1985
01:20:34,680 --> 01:20:39,450
不能用它来拥抱我，伙计们

1986
01:20:39,450 --> 01:20:40,650
，就像你知道的那样替换

1987
01:20:40,650 --> 01:20:41,940
我们为并发仪式谈论的事务性的东西，

1988
01:20:41,940 --> 01:20:44,040
因为一个

1989
01:20:44,040 --> 01:20:45,450
很多时候你的事务和

1990
01:20:45,450 --> 01:20:48,270
重写设置当我们用 l1 变大时，

1991
01:20:48,270 --> 01:20:49,500
当然如果你有多个线程

1992
01:20:49,500 --> 01:20:51,060
同时运行，你会

1993
01:20:51,060 --> 01:20:53,160
搞砸一个，你会

1994
01:20:53,160 --> 01:21:01,710
遇到问题，所以我们

1995
01:21:01,710 --> 01:21:03,140
可能想要使用它的原因 也是

1996
01:21:03,140 --> 01:21:08,300
这样，这不仅是为了提高性能，

1997
01:21:08,300 --> 01:21:10,470
从软件工程的角度来看这也很有用，

1998
01:21:10,470 --> 01:21:12,420
因为现在

1999
01:21:12,420 --> 01:21:14,310
不用做

2000
01:21:14,310 --> 01:21:16,110
我们之前讨论过的所有闩锁和捕获的东西，您

2001
01:21:16,110 --> 01:21:18,720
可以将其用作替代方案，

2002
01:21:18,720 --> 01:21:19,920
也许是 以较低的工程开销获得

2003
01:21:19,920 --> 01:21:21,900
与软件管理锁存器或

2004
01:21:21,900 --> 01:21:24,540
软件管理事务相同的性能，

2005
01:21:24,540 --> 01:21:26,820
这纯粹是

2006
01:21:26,820 --> 01:21:28,140
猜测我不

2007
01:21:28,140 --> 01:21:29,490
知道实际情况如何，但这

2008
01:21:29,490 --> 01:21:31,620
正是这种技术的支持者

2009
01:21:31,620 --> 01:21:35,310
所争论的，所以让我们看看如何

2010
01:21:35,310 --> 01:21:36,510
您实际上想要使用它，因此

2011
01:21:36,510 --> 01:21:38,400
对于事务性内存

2012
01:21:38,400 --> 01:21:41,100
，您可以使用两种编程模型，

2013
01:21:41,100 --> 01:21:43,710
第一个称为悬停锁 elysian

2014
01:21:43,710 --> 01:21:47,180
，其工作方式是启动我的

2015
01:21:47,180 --> 01:21:50,930
事务，并且

2016
01:21:50,930 --> 01:21:52,970
在我的事务期间任何时候写我都不会 真的

2017
01:21:52,970 --> 01:21:55,730
这样做我只是你知道有点像

2018
01:21:55,730 --> 01:21:58,430
做绝地思维技巧我有点欺骗

2019
01:21:58,430 --> 01:21:59,960
自己认为我做了

2020
01:21:59,960 --> 01:22:05,150
它的那个晚上发生的事情也是如此如果我

2021
01:22:05,150 --> 01:22:07,190
写到一个记忆位置它挂

2022
01:22:07,190 --> 01:22:08,960
在我的私人工作区如果 我的

2023
01:22:08,960 --> 01:22:12,830
线程尝试读取离开该内存

2024
01:22:12,830 --> 01:22:14,270
位置，他们不会看到我的权利，

2025
01:22:14,270 --> 01:22:18,380
然后当我进行提交时，

2026
01:22:18,380 --> 01:22:19,880
港口将检查是否

2027
01:22:19,880 --> 01:22:22,010
与其他人发生冲突 事务或

2028
01:22:22,010 --> 01:22:25,430
其他线程，如果没有，那么我可以

2029
01:22:25,430 --> 01:22:26,630
继续将我的更改从

2030
01:22:26,630 --> 01:22:28,280
私有工作区应用到某种全局

2031
01:22:28,280 --> 01:22:32,900
内存中，如果发生冲突，

2032
01:22:32,900 --> 01:22:35,480
那么港口将回滚

2033
01:22:35,480 --> 01:22:37,310
到我的事务的起点

2034
01:22:37,310 --> 01:22:39,110
几乎就像一个草莓老师，你

2035
01:22:39,110 --> 01:22:40,970
回滚到它的开头，然后重新

2036
01:22:40,970 --> 01:22:43,340
执行它，但是现在当

2037
01:22:43,340 --> 01:22:44,570
第二次退出时，我实际上要使用

2038
01:22:44,570 --> 01:22:47,000
显式锁来保护

2039
01:22:47,000 --> 01:22:49,340
我写给他们的内存区域

2040
01:22:49,340 --> 01:22:51,080
，这样我 意思是你知道我

2041
01:22:51,080 --> 01:22:54,290
保证我可以在没有冲突的情况下运行它，

2042
01:22:54,290 --> 01:22:56,630
所以它再次是

2043
01:22:56,630 --> 01:22:58,960
乐观的，然后如果我得到它，

2044
01:22:58,960 --> 01:23:02,240
如果我与其他人发生冲突，

2045
01:23:02,240 --> 01:23:03,950
那么它会通过悲观锁定重新启动

2046
01:23:03,950 --> 01:23:06,620
另一个更复杂的

2047
01:23:06,620 --> 01:23:08,840
方法是 使用 rtmp 受限

2048
01:23:08,840 --> 01:23:10,940
事务内存，有了这个，

2049
01:23:10,940 --> 01:23:12,860
它就像硬件锁 elysian 一样

2050
01:23:12,860 --> 01:23:15,020
，我将第一次运行

2051
01:23:15,020 --> 01:23:18,740
而不使用锁，但是如果

2052
01:23:18,740 --> 01:23:21,230
发生冲突而不是返回并

2053
01:23:21,230 --> 01:23:24,020
运行 th 再次

2054
01:23:24,020 --> 01:23:26,540
使用显式锁定事务，您可以

2055
01:23:26,540 --> 01:23:28,910
为它提供指向

2056
01:23:28,910 --> 01:23:31,580
代码中另一个位置的指针以跳转到该位置，

2057
01:23:31,580 --> 01:23:34,220
这将执行

2058
01:23:34,220 --> 01:23:35,870
与常规代码不同的操作，因此您仍然会中止

2059
01:23:35,870 --> 01:23:37,730
事务并回滚它，但您

2060
01:23:37,730 --> 01:23:39,230
没有 t 跳回到

2061
01:23:39,230 --> 01:23:41,420
事务的起点并再次运行它 你

2062
01:23:41,420 --> 01:23:43,850
跳到程序的其他内存位置，

2063
01:23:43,850 --> 01:23:45,500
它可以做一些

2064
01:23:45,500 --> 01:23:47,900
稍微不同的事情，所以这需要

2065
01:23:47,900 --> 01:23:49,880
在他们自己的外部进行更多的工程工作，

2066
01:23:49,880 --> 01:23:52,310
因为数据系统开发人员要

2067
01:23:52,310 --> 01:23:53,510
注意我们 '正在跳转到另一个

2068
01:23:53,510 --> 01:23:57,320
位置，你知道并且有

2069
01:23:57,320 --> 01:23:59,150


2070
01:23:59,150 --> 01:24:00,260
一种我们试图保护的临界区的替代实现，

2071
01:24:00,260 --> 01:24:01,510


2072
01:24:01,510 --> 01:24:04,369
所以让我们看一个例子，我们如何

2073
01:24:04,369 --> 01:24:06,530
使用它，所以说我们想做我们有

2074
01:24:06,530 --> 01:24:08,389
一个 B 加 树，我们学习什么时候你

2075
01:24:08,389 --> 01:24:11,090
想插入键 25 所以如果

2076
01:24:11,090 --> 01:24:12,590
我们只是做

2077
01:24:12,590 --> 01:24:14,539
我们在乐观闩锁之前谈到的

2078
01:24:14,539 --> 01:24:16,070
闩锁螃蟹我会真正的一个 ch

2079
01:24:16,070 --> 01:24:18,860
直到我得到 d 拥有这里并认识

2080
01:24:18,860 --> 01:24:20,119
到这是我想要修改的东西，

2081
01:24:20,119 --> 01:24:22,579
所以我选择了一个正确的闩锁或一个 X

2082
01:24:22,579 --> 01:24:23,570
代表排他性，这应该是正确的

2083
01:24:23,570 --> 01:24:26,119
，然后当我拥有它并

2084
01:24:26,119 --> 01:24:28,429
继续计划我的更改但现在如果我'

2085
01:24:28,429 --> 01:24:30,860
我用霍华德事务内存做这个我的

2086
01:24:30,860 --> 01:24:32,989
程序看起来像这样我

2087
01:24:32,989 --> 01:24:34,520
会有我的事务开始的边界和我提交时的边界

2088
01:24:34,520 --> 01:24:36,020


2089
01:24:36,020 --> 01:24:38,480
，对于

2090
01:24:38,480 --> 01:24:40,550
这里的这个关键部分，这只是

2091
01:24:40,550 --> 01:24:44,889
我向下遍历到

2092
01:24:44,889 --> 01:24:47,989
遍历的螃蟹部分 向下进入树，直到我

2093
01:24:47,989 --> 01:24:49,849
到达这个 F 节点，然后你

2094
01:24:49,849 --> 01:24:51,679
只在我身上使用独占闩锁或在 F 上使用正确的

2095
01:24:51,679 --> 01:24:55,429
闩锁，所以从外面

2096
01:24:55,429 --> 01:24:57,380
看，我已经神奇地

2097
01:24:57,380 --> 01:25:00,289
通过事务处理了它，这将

2098
01:25:00,289 --> 01:25:01,610
自动检测 如果

2099
01:25:01,610 --> 01:25:03,289
其他人同时使用闩锁，我

2100
01:25:03,289 --> 01:25:05,780
是否会这样做，因此从外面

2101
01:25:05,780 --> 01:25:07,730
看，我在这里神奇地扭曲了我一直

2102
01:25:07,730 --> 01:25:09,679
使用正确的闩锁，因此

2103
01:25:09,679 --> 01:25:12,020
我保证

2104
01:25:12,020 --> 01:25:13,909
了数据结构的完整性 就

2105
01:25:13,909 --> 01:25:15,679
他们的指针而言，指针指向的是什么

2106
01:25:15,679 --> 01:25:18,500
，但我没有，我

2107
01:25:18,500 --> 01:25:22,280
不必让你知道实际上

2108
01:25:22,280 --> 01:25:26,659
将这些权利应用于你知道的

2109
01:25:26,659 --> 01:25:29,630
内存中所有被点燃的东西，我

2110
01:25:29,630 --> 01:25:31,309
跳到这里 并得到它，做，得到

2111
01:25:31,309 --> 01:25:35,679
我想要的，好吧，所以

2112
01:25:35,679 --> 01:25:39,110
结束正如我所说的，我们今天大部分时间都

2113
01:25:39,110 --> 01:25:40,250
在谈论持久性

2114
01:25:40,250 --> 01:25:43,250
内存，因为这是我的观点，现在已经

2115
01:25:43,250 --> 01:25:45,590
过时了，当它变得更加

2116
01:25:45,590 --> 01:25:47,420
普遍时，这是 将是一个

2117
01:25:47,420 --> 01:25:49,460
重大变化，以及我们如何构建软件

2118
01:25:49,460 --> 01:25:51,889
，尤其是数据库系统，就像我

2119
01:25:51,889 --> 01:25:53,980
可以预见的那样，如果持久

2120
01:25:53,980 --> 01:25:56,480
内存像我认为的那样起飞

2121
01:25:56,480 --> 01:26:01,420
，那么它可能是我们

2122
01:26:01,420 --> 01:26:04,340
在介绍中不知道的情况 戴维斯

2123
01:26:04,340 --> 01:26:05,690
课上，我们不会花时间讨论

2124
01:26:05,690 --> 01:26:08,780
缓冲池之类的事情，而且

2125
01:26:08,780 --> 01:26:10,429
您知道如何正确地使用 scrunch 进行日志记录

2126
01:26:10,429 --> 01:26:12,289
为什么您知道最大限度地利用

2127
01:26:12,289 --> 01:26:15,710
水泥 依赖这样的孩子 认为您

2128
01:26:15,710 --> 01:26:17,539
现在知道记忆只是持久的，

2129
01:26:17,539 --> 01:26:19,190
我说得对 我做 我把它刷新我

2130
01:26:19,190 --> 01:26:20,780
必须稍微订购我的权利，但

2131
01:26:20,780 --> 01:26:23,239
就像我不必做所有的页面

2132
01:26:23,239 --> 01:26:25,159
锁定和我们在

2133
01:26:25,159 --> 01:26:28,400
介绍课上做的所有废话，所以这也是我的猜想，

2134
01:26:28,400 --> 01:26:30,380
正如我之前所说的，我认为

2135
01:26:30,380 --> 01:26:31,909
在 -memory 数据库可以更好

2136
01:26:31,909 --> 01:26:33,650
地利用持久

2137
01:26:33,650 --> 01:26:34,579
内存，因为它们已经被编写

2138
01:26:34,579 --> 01:26:37,329
为假设它们可以与

2139
01:26:37,329 --> 01:26:40,789
字节可寻址内存交谈而不是

2140
01:26:40,789 --> 01:26:42,710
处理页面，所以我认为

2141
01:26:42,710 --> 01:26:45,170
从 dram 或 in 的转换 对于内存数据库来说，内存

2142
01:26:45,170 --> 01:26:46,849
系统到持久内存系统的

2143
01:26:46,849 --> 01:26:51,130
成本会更低 我

2144
01:26:51,130 --> 01:26:55,880
还认为你知道 GPU

2145
01:26:55,880 --> 01:26:57,530
已经存在了一段时间 FPGA 已经

2146
01:26:57,530 --> 01:26:59,510
存在了一段时间，但你知道，就像我

2147
01:26:59,510 --> 01:27:01,789
说的，并不是大多数数据库都不是

2148
01:27:01,789 --> 01:27:03,469
数据库系统 不是

2149
01:27:03,469 --> 01:27:06,170
假设你有那个硬件它

2150
01:27:06,170 --> 01:27:08,929
仍然在我看来它是一个利基你

2151
01:27:08,929 --> 01:27:13,940
知道利基市场可能发生的

2152
01:27:13,940 --> 01:27:18,530
事情是除了 GPU 和 FPGA，你

2153
01:27:18,530 --> 01:27:19,820
可能会开始看到额外的

2154
01:27:19,820 --> 01:27:22,579
计算设备，比如配置我们的

2155
01:27:22,579 --> 01:27:24,710
特殊加速器

2156
01:27:24,710 --> 01:27:28,400
看起来像 TPU 的东西 或者你知道

2157
01:27:28,400 --> 01:27:31,909
某种定制 ASIC 可以让你

2158
01:27:31,909 --> 01:27:32,809
知道数据库性能的巨大差异

2159
01:27:32,809 --> 01:27:34,909
唯一必须

2160
01:27:34,909 --> 01:27:36,619


2161
01:27:36,619 --> 01:27:38,420
与潜在的机器学习或

2162
01:27:38,420 --> 01:27:40,099
数据科学有很大重叠的东西 这些应用程序

2163
01:27:40,099 --> 01:27:41,599
不仅仅是你知道进行顺序扫描

2164
01:27:41,599 --> 01:27:43,219
，数据科学机器学习

2165
01:27:43,219 --> 01:27:44,929
做了很多，但是有一种方法可以让数据

2166
01:27:44,929 --> 01:27:46,940
集利用它们我认为

2167
01:27:46,940 --> 01:27:50,030
这会很有趣，因为

2168
01:27:50,030 --> 01:27:51,590


2169
01:27:51,590 --> 01:27:56,300
我认为矩阵的另一面也很有趣 数据库

2170
01:27:56,300 --> 01:27:57,559
在接下来的十年中可能会变得更加重要

2171
01:27:57,559 --> 01:28:00,199
，在这种情况下，您

2172
01:28:00,199 --> 01:28:03,230
知道一些

2173
01:28:03,230 --> 01:28:04,550
正在对矩阵进行计算或

2174
01:28:04,550 --> 01:28:07,039
机器学习的加速器，您知道

2175
01:28:07,039 --> 01:28:08,630
这些数据库可以轻松

2176
01:28:08,630 --> 01:28:11,239
利用这些东西，但核心

2177
01:28:11,239 --> 01:28:13,340
这就像

2178
01:28:13,340 --> 01:28:14,750
我们本学期讨论的事情的核心思想

2179
01:28:14,750 --> 01:28:16,639
，当然还有

2180
01:28:16,639 --> 01:28:17,780
许多算法的核心思想 仍然是

2181
01:28:17,780 --> 01:28:18,019
相同的

2182
01:28:18,019 --> 01:28:20,329
quanto 扫描顺序扫描

2183
01:28:20,329 --> 01:28:22,250
正确评估一个你知道编码的谓词

2184
01:28:22,250 --> 01:28:24,710
，或者你知道遍历

2185
01:28:24,710 --> 01:28:26,780
树 几乎仍然

2186
01:28:26,780 --> 01:28:28,460
是一样的，所以我们确实看到了如何

2187
01:28:28,460 --> 01:28:29,869
思考我们如何获取我们知道的知识

2188
01:28:29,869 --> 01:28:31,699
关于如何咬一点，他做了

2189
01:28:31,699 --> 01:28:33,260
一些在这门课上讨论的方式，

2190
01:28:33,260 --> 01:28:35,980
并将其应用到这个新硬件

2191
01:28:35,980 --> 01:28:37,849
，所以我认为你现在已经具备

2192
01:28:37,849 --> 01:28:43,010
了做这件事的背景，所以这是周三的最后一

2193
01:28:43,010 --> 01:28:45,500
堂课，我们再次举行

2194
01:28:45,500 --> 01:28:47,059
来自亚马逊的演讲嘉宾，但

2195
01:28:47,059 --> 01:28:51,619
我们只对 CMU 学生关闭，所以如果

2196
01:28:51,619 --> 01:28:53,449
你在 CMU 之外看这个，

2197
01:28:53,449 --> 01:28:55,940
我希望你是安全的我希望一切都

2198
01:28:55,940 --> 01:28:57,469
很好，你知道希望

2199
01:28:57,469 --> 01:28:58,219


2200
01:28:58,219 --> 01:29:01,489
我们通过后你能很好地看这个 大流行，如果

2201
01:29:01,489 --> 01:29:03,290
你通过整个学期

2202
01:29:03,290 --> 01:29:04,960
观看了祝贺你的 YouTube 视频 那么

2203
01:29:04,960 --> 01:29:09,050


2204
01:29:09,050 --> 01:29:12,860
在经历了 25 26 个

2205
01:29:12,860 --> 01:29:14,860
讲座之后，你现在应该能够很好地做些什么，你现在应该能够

2206
01:29:14,860 --> 01:29:17,449
理解、理解和

2207
01:29:17,449 --> 01:29:20,449
推理 ma 我们讨论的主要

2208
01:29:20,449 --> 01:29:22,750
话题以及如何构建现代

2209
01:29:22,750 --> 01:29:25,130
单节点数据库面板系统，

2210
01:29:25,130 --> 01:29:27,020
当我说我的单节点时，我有资格，

2211
01:29:27,020 --> 01:29:29,090
因为分布式会

2212
01:29:29,090 --> 01:29:32,000
带来其他一系列我们没有的

2213
01:29:32,000 --> 01:29:34,309
网络和分布式

2214
01:29:34,309 --> 01:29:36,530
事务问题 没有谈过，但在

2215
01:29:36,530 --> 01:29:38,929
高层次上，有许多与

2216
01:29:38,929 --> 01:29:40,280
我们在这里谈到的相同的问题，

2217
01:29:40,280 --> 01:29:41,750
我们关心放置我们

2218
01:29:41,750 --> 01:29:43,520
关心分区我们关心绘图

2219
01:29:43,520 --> 01:29:45,079
算法我们关心

2220
01:29:45,079 --> 01:29:47,030
所有在那个环境中的事务，这

2221
01:29:47,030 --> 01:29:49,340
只是通信是 更慢、更

2222
01:29:49,340 --> 01:29:50,659
不可靠，所以我们必须

2223
01:29:50,659 --> 01:29:54,170
考虑到这一点 我也希望你

2224
01:29:54,170 --> 01:29:56,480
现在

2225
01:29:56,480 --> 01:29:59,210
有理由知道基金会有能力了解

2226
01:29:59,210 --> 01:30:01,280
人们对他们的数据库管理系统提出的主张的原因

2227
01:30:01,280 --> 01:30:02,599


2228
01:30:02,599 --> 01:30:04,849
，你将能够 弄清楚

2229
01:30:04,849 --> 01:30:07,400
这些说法是真实的，或者它们是否

2230
01:30:07,400 --> 01:30:09,710
真的不可信，或者这是否

2231
01:30:09,710 --> 01:30:12,260
只是一堆营销炒作，因为

2232
01:30:12,260 --> 01:30:14,510
戴维斯市场上的数据库很多

2233
01:30:14,510 --> 01:30:17,630
钱 有很多初创公司

2234
01:30:17,630 --> 01:30:19,699
有很多大公司都想

2235
01:30:19,699 --> 01:30:22,070
赚钱 有时他们会说一些

2236
01:30:22,070 --> 01:30:25,369
你知道的事情，除非你有点

2237
01:30:25,369 --> 01:30:26,840
注意 看起来

2238
01:30:26,840 --> 01:30:30,320
很酷但如果你现在使用这些

2239
01:30:30,320 --> 01:30:31,550
知识 游戏正确的

2240
01:30:31,550 --> 01:30:32,750
课程现在应该能够喜欢看看

2241
01:30:32,750 --> 01:30:33,449


2242
01:30:33,449 --> 01:30:36,660
这是真的还是不正确所以我不是

2243
01:30:36,660 --> 01:30:38,550
要挑这些人但是让我

2244
01:30:38,550 --> 01:30:39,870
举一个上周出现的例子

2245
01:30:39,870 --> 01:30:42,239
所以有这个新的创业公司 称为

2246
01:30:42,239 --> 01:30:45,420
terminus DB，他们发布在 Hacker

2247
01:30:45,420 --> 01:30:47,730
News 上，嘿，我们已经出来了，我们在你身边，你

2248
01:30:47,730 --> 01:30:50,550
知道这就是我们所做的，所以它是一个图形

2249
01:30:50,550 --> 01:30:51,719
数据库，所以他们将

2250
01:30:51,719 --> 01:30:54,410
自己与

2251
01:30:54,410 --> 01:30:58,380
同一空间中的一堆其他系统进行比较， 他们

2252
01:30:58,380 --> 01:30:59,760
在这里有一个小插曲，尽管

2253
01:30:59,760 --> 01:31:01,650
他们谈论了他们所做的功能，

2254
01:31:01,650 --> 01:31:04,760
他们做人工智能热电联产，这是

2255
01:31:04,760 --> 01:31:07,530
理所当然的，所以你看到了这一点，就像

2256
01:31:07,530 --> 01:31:09,840
这意味着什么，当然有人

2257
01:31:09,840 --> 01:31:12,300
在黑客新闻上发帖说嘿，看看人工智能

2258
01:31:12,300 --> 01:31:15,239
热电联产，那是什么，你是什么

2259
01:31:15,239 --> 01:31:17,070
交流电 最终声称，然后这些

2260
01:31:17,070 --> 01:31:19,230
是他们的一些开发人员，

2261
01:31:19,230 --> 01:31:20,969
比如哦，是的，这是不正确的，

2262
01:31:20,969 --> 01:31:23,429
这是营销出了问题，所以如果

2263
01:31:23,429 --> 01:31:24,989
你只是一个休闲的人，看看这个

2264
01:31:24,989 --> 01:31:27,300
并且没问题，我的热电联产很好，

2265
01:31:27,300 --> 01:31:28,590
听起来很酷什么可以

2266
01:31:28,590 --> 01:31:30,810
但是对于在这门课程中失败的你们来说，

2267
01:31:30,810 --> 01:31:33,210
你知道什么是热电联产，你

2268
01:31:33,210 --> 01:31:35,340
知道它没有真正的 AI 方面，

2269
01:31:35,340 --> 01:31:37,380
因为你正在制定

2270
01:31:37,380 --> 01:31:40,050
一个优化器吐出的查询计划，你

2271
01:31:40,050 --> 01:31:42,030
知道只有我们会有一个

2272
01:31:42,030 --> 01:31:44,820
根据你将如何

2273
01:31:44,820 --> 01:31:47,850
为它生成代码来执行它的方式，所以没有

2274
01:31:47,850 --> 01:31:51,060
任何人工智能，所以这也是

2275
01:31:51,060 --> 01:31:53,100
我希望你们现在

2276
01:31:53,100 --> 01:31:55,980
可以自己做的事情，看看人们

2277
01:31:55,980 --> 01:31:57,810
在说什么和 使用你

2278
01:31:57,810 --> 01:31:59,010
从这门课程中获得的背景来决定

2279
01:31:59,010 --> 01:32:00,270
他们是否在

2280
01:32:00,270 --> 01:32:03,449
说一些看似合理的事情，所以下一

2281
01:32:03,449 --> 01:32:05,250
节课我们将有一位来自

2282
01:32:05,250 --> 01:32:08,179
亚马逊的演讲嘉宾，然后让其他人

2283
01:32:08,179 --> 01:32:11,400
照顾好把它存到旁边的公园里这

2284
01:32:11,400 --> 01:32:14,170
是什么 一些 foo 我说你

2285
01:32:14,170 --> 01:32:15,469
[音乐]

2286
01:32:15,469 --> 01:32:17,989
特别是当他们被称为 Hokey

2287
01:32:17,989 --> 01:32:21,290
因为我 og Ice Cube down 与暴躁的

2288
01:32:21,290 --> 01:32:24,739
你看起来，它是给我一个 40

2289
01:32:24,739 --> 01:32:27,080
只是为了得到我的流行歌曲因为我

2290
01:32:27,080 --> 01:32:29,360
需要更多的踢 就像一条鱼

2291
01:32:29,360 --> 01:32:32,739
，只要一个鱼滑到我的唇边

2292
01:32:32,739 --> 01:32:37,219
，说好听的话，我的兜帽不会

2293
01:32:37,219 --> 01:32:39,830
说我已经切碎了，你说吧，我说的是

2294
01:32:39,830 --> 01:32:42,130
祈祷

