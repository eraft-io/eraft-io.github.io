1
00:00:01,300 --> 00:00:05,129
[音乐]

2
00:00:05,200 --> 00:00:05,930
[鼓掌]

3
00:00:05,930 --> 00:00:08,630
[音乐]

4
00:00:08,630 --> 00:00:10,020
[鼓掌]

5
00:00:10,020 --> 00:00:11,900
[音乐

6
00:00:11,900 --> 00:00:14,700
]今天的课我来来

7
00:00:14,700 --> 00:00:16,079
回回三四次了，我

8
00:00:16,079 --> 00:00:18,180
想把这堂课叫做原来的样子，

9
00:00:18,180 --> 00:00:19,529
我觉得我已经老了，没有

10
00:00:19,529 --> 00:00:21,720
索引 数据结构然后我

11
00:00:21,720 --> 00:00:22,800
将它切换为加树数据

12
00:00:22,800 --> 00:00:24,570
结构然后从昨晚我

13
00:00:24,570 --> 00:00:26,039
说让我们称之为完整的关键数据

14
00:00:26,039 --> 00:00:27,720
结构然后我会让更多设置

15
00:00:27,720 --> 00:00:30,990
更有意义和更多幻灯片但

16
00:00:30,990 --> 00:00:32,610
这里的主要思想就像 我们只是

17
00:00:32,610 --> 00:00:34,200
在谈论意味着

18
00:00:34,200 --> 00:00:36,030
我们可以

19
00:00:36,030 --> 00:00:40,620
为所有 GP 工作负载构建或使用什么样的索引或数据结构 另一

20
00:00:40,620 --> 00:00:41,700
件事我忘了在 Piazza 时提及，

21
00:00:41,700 --> 00:00:44,460
因为他们后来给了

22
00:00:44,460 --> 00:00:46,700
我信息，实际上今天有一位

23
00:00:46,700 --> 00:00:49,379
访客来自 雪花将

24
00:00:49,379 --> 00:00:52,739
在 4:30 发表关于

25
00:00:52,739 --> 00:00:54,980
雪花中的查询优化器的演讲 雪花是

26
00:00:54,980 --> 00:00:58,399
最大的 OLAP 云

27
00:00:58,399 --> 00:01:00,989
数据库供应商之一 davis 是一项服务，我的

28
00:01:00,989 --> 00:01:02,609
竞争对手是像 google 的

29
00:01:02,609 --> 00:01:06,570
bigquery 或亚马逊的 redshift 之类的东西，所以

30
00:01:06,570 --> 00:01:09,060
beau way 是实际的 我曾经是 CMU 的一名学生，

31
00:01:09,060 --> 00:01:09,930


32
00:01:09,930 --> 00:01:12,720
他拿了 721，就像你们

33
00:01:12,720 --> 00:01:14,340
开始在查询优化器中工作一样，

34
00:01:14,340 --> 00:01:16,920
人们雇用他的速度不够快，所以他

35
00:01:16,920 --> 00:01:18,509
已经成为雪花两年了，

36
00:01:18,509 --> 00:01:20,220
他喜欢它，所以今天他们将

37
00:01:20,220 --> 00:01:21,720
谈论 他们

38
00:01:21,720 --> 00:01:23,729
在 4 点 30 分在查询优化器中做的那种事情，

39
00:01:23,729 --> 00:01:25,229
所以请务必来这里，我会

40
00:01:25,229 --> 00:01:27,780
在广场上发送提醒，好的，每个人都被

41
00:01:27,780 --> 00:01:28,520
邀请了，

42
00:01:28,520 --> 00:01:31,530
但等等我想有一个夏季

43
00:01:31,530 --> 00:01:33,479
招聘活动和校园 这周

44
00:01:33,479 --> 00:01:35,670
我忘记了他为什么在这里

45
00:01:35,670 --> 00:01:39,720
明天是什么 好所以他在

46
00:01:39,720 --> 00:01:43,079
这里但是就像我说的 如果你以多种方式参加这门

47
00:01:43,079 --> 00:01:45,390
课程 你

48
00:01:45,390 --> 00:01:47,100
将从中学到的东西将帮助你

49
00:01:47,100 --> 00:01:48,869
通过面试了解各种数据到

50
00:01:48,869 --> 00:01:51,270
公司 所以男孩我可以告诉你这

51
00:01:51,270 --> 00:01:52,380
是否是真的因为他

52
00:01:52,380 --> 00:01:53,369
就是这样你知道他已经

53
00:01:53,369 --> 00:01:57,420
有一段时间了，好吧，正如我在开头所说的，

54
00:01:57,420 --> 00:01:59,399
我来回辩论

55
00:01:59,399 --> 00:02:02,159
我想称这个讲座和

56
00:02:02,159 --> 00:02:05,250
整个 关键有点不完全正确，

57
00:02:05,250 --> 00:02:07,049
但是 我想尝试

58
00:02:07,049 --> 00:02:09,598
区分的主要事情是我们

59
00:02:09,598 --> 00:02:10,770
今天要讨论的内容与我们将

60
00:02:10,770 --> 00:02:13,770
在周三课上讨论的内容

61
00:02:13,770 --> 00:02:16,050
所以这也是引号 因为这

62
00:02:16,050 --> 00:02:17,520
是我的术语 我认为这

63
00:02:17,520 --> 00:02:19,380
实际上不是 这不是标准的

64
00:02:19,380 --> 00:02:21,870
标准白话我不知道

65
00:02:21,870 --> 00:02:23,970
他们说的

66
00:02:23,970 --> 00:02:25,400
是什么信息理论但这就是我使用的只是为了

67
00:02:25,400 --> 00:02:28,110
通过整个关键对比两者我的意思

68
00:02:28,110 --> 00:02:30,120
是我们有一个数据结构

69
00:02:30,120 --> 00:02:32,310
有序保留，因此我们

70
00:02:32,310 --> 00:02:33,810
希望确保我们可以跟踪

71
00:02:33,810 --> 00:02:35,130
您知道一个键是否小于

72
00:02:35,130 --> 00:02:36,780
另一个键，并且我们将把

73
00:02:36,780 --> 00:02:38,850
该键的所有数字

74
00:02:38,850 --> 00:02:41,850
一起存储在数据内部表示的各个部分中

75
00:02:41,850 --> 00:02:44,010


76
00:02:44,010 --> 00:02:46,260
结构所以我的意思是，如果我

77
00:02:46,260 --> 00:02:49,170
有一个密钥 ABC 我可以在我的

78
00:02:49,170 --> 00:02:51,510
叶节点中拥有我可以将 Kiki ABC 放在一起

79
00:02:51,510 --> 00:02:53,460
，现在如果我想进行比较，看看

80
00:02:53,460 --> 00:02:55,110
我的密钥在

81
00:02:55,110 --> 00:02:57,600
哪里 给定的密钥 II 在

82
00:02:57,600 --> 00:02:59,280
那里拥有密钥的所有

83
00:02:59,280 --> 00:03:01,710
内容 当您开始使用一些压缩技术时并不完全正确，

84
00:03:01,710 --> 00:03:04,170
但

85
00:03:04,170 --> 00:03:05,640
就我们今天的目的而言，我们可以

86
00:03:05,640 --> 00:03:10,020
假设情况确实如此，然后在

87
00:03:10,020 --> 00:03:11,400
周三的课程中我们将讨论

88
00:03:11,400 --> 00:03:12,840
我称之为部分关键数据结构的内容或

89
00:03:12,840 --> 00:03:15,600
尝试您实际使用的地方 分解

90
00:03:15,600 --> 00:03:17,760
键的数字并将它们

91
00:03:17,760 --> 00:03:19,170
分别存储在数据结构内的节点中，

92
00:03:19,170 --> 00:03:21,360
所以

93
00:03:21,360 --> 00:03:27,000
考虑这个的一种方法是使用这种方法，因此

94
00:03:27,000 --> 00:03:28,980
使用这种方法，

95
00:03:28,980 --> 00:03:31,050
您可能需要做更少的工作来

96
00:03:31,050 --> 00:03:32,220
确定部分键是否 你匹配的东西

97
00:03:32,220 --> 00:03:33,840
amantha 可能存储更少的数据

98
00:03:33,840 --> 00:03:37,080
来表示

99
00:03:37,080 --> 00:03:40,470
你的数据结构中的所有键，但你

100
00:03:40,470 --> 00:03:42,150
可能仍然需要出去查看原始

101
00:03:42,150 --> 00:03:44,430
元组或原始记录，看看

102
00:03:44,430 --> 00:03:46,080
你的原始键是什么“ 重新做

103
00:03:46,080 --> 00:03:47,490
独木舟并查找很长时间，因为它可能

104
00:03:47,490 --> 00:03:49,650
不会全部包含在树中，而

105
00:03:49,650 --> 00:03:52,350
在整个键中，您知道键 ABC

106
00:03:52,350 --> 00:03:54,780
存在于元组键中 ABC 将存在

107
00:03:54,780 --> 00:03:56,520
于数据结构中，

108
00:03:56,520 --> 00:03:58,710
所以再次 t

109
00:03:58,710 --> 00:04:01,170
随着我们的进展，他会更有意义 我想我将它

110
00:04:01,170 --> 00:04:03,600
与周三的讲座

111
00:04:03,600 --> 00:04:04,710
进行了对比，但就我们今天的目的而言，我们只是

112
00:04:04,710 --> 00:04:07,460
假设我们正在处理 B 加树，所以

113
00:04:07,460 --> 00:04:09,810
今天我明白大部分时间

114
00:04:09,810 --> 00:04:11,670
在谈论 BW 树，因为 那

115
00:04:11,670 --> 00:04:12,900
是分配的读数，这就是

116
00:04:12,900 --> 00:04:15,150
我们

117
00:04:15,150 --> 00:04:18,060
今天在我们的数据库系统中使用的当前数据结构，

118
00:04:18,060 --> 00:04:19,470
我想让你们阅读的部分

119
00:04:19,470 --> 00:04:23,669
原因是因为它暴露了

120
00:04:23,669 --> 00:04:25,590
您实际上想要构建纬度树

121
00:04:25,590 --> 00:04:27,230
数据结构的方式

122
00:04:27,230 --> 00:04:29,000
如果您在

123
00:04:29,000 --> 00:04:30,950
Hacker News 上阅读或我们不拥有互联网，

124
00:04:30,950 --> 00:04:32,270
您可能会认为缺少 flash B+ 树，您可能会认为人们会说，哦，

125
00:04:32,270 --> 00:04:33,680
这些 lats 读取数据结构放松

126
00:04:33,680 --> 00:04:35,750
一下，树算法

127
00:04:35,750 --> 00:04:37,280
优于使用闩锁的算法，而您总是

128
00:04:37,280 --> 00:04:38,600
想 使用后一种 II 数据结构

129
00:04:38,600 --> 00:04:40,850
，我当然认为

130
00:04:40,850 --> 00:04:42,200
我们第一次开始构建我们

131
00:04:42,200 --> 00:04:44,420
自己的 BW 树时就是这种情况，但是你们阅读的论文

132
00:04:44,420 --> 00:04:47,390
基本上表明，在我们到达那里之前你没有这样做

133
00:04:47,390 --> 00:04:49,100
，尽管我想 t 提供

134
00:04:49,100 --> 00:04:50,660
一些关于

135
00:04:50,660 --> 00:04:51,980
人们

136
00:04:51,980 --> 00:04:54,320
最初为内存

137
00:04:54,320 --> 00:04:56,420
数据库特别是茶树构建什么样的数据结构的历史背景

138
00:04:56,420 --> 00:04:58,340
，然后我们还将完成

139
00:04:58,340 --> 00:05:00,290
如何实际然后采用

140
00:05:00,290 --> 00:05:01,970
我们在介绍中描述的常规 P Plus 树

141
00:05:01,970 --> 00:05:04,400
班级，也许做一些

142
00:05:04,400 --> 00:05:06,830
更聪明的事情，以及我们如何正确锁定，

143
00:05:06,830 --> 00:05:08,780
这就是当您看到 B+ 树击败 BW 条约时阅读该论文时的方式

144
00:05:08,780 --> 00:05:10,400


145
00:05:10,400 --> 00:05:11,990
所以每个人都在这里使用最后一个

146
00:05:11,990 --> 00:05:16,370
技术 好吧 回到

147
00:05:16,370 --> 00:05:19,570
1970 年代的那一天 在我们出生之前，

148
00:05:19,570 --> 00:05:22,670
他们提到了 B+ 树

149
00:05:22,670 --> 00:05:25,010
，当时因为他们正在处理

150
00:05:25,010 --> 00:05:27,290
去往数据库的磁盘

151
00:05:27,290 --> 00:05:30,740
，而且磁盘非常慢，B+ 树结果证明

152
00:05:30,740 --> 00:05:33,350
是一种设计良好的数据结构，

153
00:05:33,350 --> 00:05:36,260
可以让您大步有效地访问

154
00:05:36,260 --> 00:05:38,900
顺序序列数据，所以

155
00:05:38,900 --> 00:05:41,840
我相信这棵树在 log n 时间内死亡，我

156
00:05:41,840 --> 00:05:44,510
降落在我的叶子节点上，我

157
00:05:44,510 --> 00:05:46,610
沿着叶子节点扫描，直到我找到

158
00:05:46,610 --> 00:05:48,740
寻找一切的关键，这

159
00:05:48,740 --> 00:05:50,330
太棒了 再次，如果这是缓慢的

160
00:05:50,330 --> 00:05:53,060
scruncher杂草比随机读取速度更快，

161
00:05:53,060 --> 00:05:55,400
这种方法

162
00:05:55,400 --> 00:05:59,320
非常适合它，因此在1980

163
00:05:59,320 --> 00:06:02,140
年代，在设计第一个Mme数据库方面做了一些早期工作

164
00:06:02,140 --> 00:06:05,120
，在

165
00:06:05,120 --> 00:06:06,830
那个世界中，您没有慢速

166
00:06:06,830 --> 00:06:10,340
磁盘 内存中具有快速随机 I/O，所以

167
00:06:10,340 --> 00:06:12,200
他们正在研究的想法是

168
00:06:12,200 --> 00:06:15,500
我们可以构建一个你知道是否有

169
00:06:15,500 --> 00:06:16,940
我们想要使用的替代数据结构

170
00:06:16,940 --> 00:06:19,190
而不是 B+ 树，这

171
00:06:19,190 --> 00:06:22,700
对于内存中的 a 来说更可取且更高效

172
00:06:22,700 --> 00:06:25,850
数据库，因此

173
00:06:25,850 --> 00:06:27,260
这项工作中最有名的一个

174
00:06:27,260 --> 00:06:30,620
被称为茶树，所以茶树

175
00:06:30,620 --> 00:06:32,330
看起来像一棵 AVL 树基本上

176
00:06:32,330 --> 00:06:34,610
只是意味着而不是让你

177
00:06:34,610 --> 00:06:36,950
看到 B+ 树，那里的键

178
00:06:36,950 --> 00:06:39,560
总是存在 叶节点

179
00:06:39,560 --> 00:06:40,760
和内部节点刚刚消失

180
00:06:40,760 --> 00:06:41,990
posta 告诉我告诉你是否

181
00:06:41,990 --> 00:06:44,120
在客栈和

182
00:06:44,120 --> 00:06:46,490
茶树中从左到右 键将

183
00:06:46,490 --> 00:06:47,630
散布在不同的音符中，

184
00:06:47,630 --> 00:06:50,000
叶节点和中间音符但是 th

185
00:06:50,000 --> 00:06:52,040
我们处理和茶树之间的最大区别

186
00:06:52,040 --> 00:06:53,990
在于，

187
00:06:53,990 --> 00:06:56,840
不是像所有节点中的密钥副本那样将所有节点中的密钥扔到

188
00:06:56,840 --> 00:06:58,940


189
00:06:58,940 --> 00:07:02,540
那里，而是

190
00:07:02,540 --> 00:07:04,250
让原始破坏者的记者厌恶两个 Plzen

191
00:07:04,250 --> 00:07:07,310
细胞，这里的想法是 回到

192
00:07:07,310 --> 00:07:08,990
1980 年代，当时内存非常有限，

193
00:07:08,990 --> 00:07:11,210
而不是

194
00:07:11,210 --> 00:07:13,040
像在整个密钥 B 加树中那样存储密钥的冗余副本，

195
00:07:13,040 --> 00:07:15,710
如果我们销毁指针，那么

196
00:07:15,710 --> 00:07:18,650
在内存方面效率更高，所以

197
00:07:18,650 --> 00:07:20,000
是的，我们为此付出了代价

198
00:07:20,000 --> 00:07:22,070
假设我们知道这个指针

199
00:07:22,070 --> 00:07:23,330
对应于那个元组的实际键是什么

200
00:07:23,330 --> 00:07:25,610
，但同样

201
00:07:25,610 --> 00:07:29,330
减少了索引的总大小，所以

202
00:07:29,330 --> 00:07:32,690
茶树最初是在 1986 年

203
00:07:32,690 --> 00:07:35,870
由宇宙大学威斯康星大学提出的，我是

204
00:07:35,870 --> 00:07:37,250
Mike Carey 在他的团队中 1980 年代和 1990 年代

205
00:07:37,250 --> 00:07:38,870
在内存数据库方面的许多早期工作，

206
00:07:38,870 --> 00:07:42,830
当时人们

207
00:07:42,830 --> 00:07:44,540
开始构建第一个内存

208
00:07:44,540 --> 00:07:47,120
数据库，商业数据库如

209
00:07:47,120 --> 00:07:49,340
HP 的 small base 成为时间

210
00:07:49,340 --> 00:07:51,020
Oracle 购买的 s 10，今天仍然存在

211
00:07:51,020 --> 00:07:54,860
，你知道这些早期的

212
00:07:54,860 --> 00:07:56,120
内存数据企业实际上使用

213
00:07:56,120 --> 00:07:59,900
T 来设计，所以当时茶树实际上工作的一个关键方面是

214
00:07:59,900 --> 00:08:02,120


215
00:08:02,120 --> 00:08:05,150
CPU 缓存和 DRAM 之间的速度差异

216
00:08:05,150 --> 00:08:08,720
没有

217
00:08:08,720 --> 00:08:11,120
现在那么重要，所以

218
00:08:11,120 --> 00:08:12,440
如果我在缓存未

219
00:08:12,440 --> 00:08:13,550
命中并且不得不在

220
00:08:13,550 --> 00:08:15,860
内存中读取一些你知道

221
00:08:15,860 --> 00:08:16,850
在 19 世纪 80 年代担任教学角色的东西时，

222
00:08:16,850 --> 00:08:18,920
那没什么大不了的 所以可以

223
00:08:18,920 --> 00:08:20,570
正确地遵循那个指针，因为你

224
00:08:20,570 --> 00:08:22,580
知道这不是一个很大的性能损失，

225
00:08:22,580 --> 00:08:25,270
而且你在数据结构本身中节省了很多空间，

226
00:08:25,270 --> 00:08:29,600


227
00:08:29,600 --> 00:08:33,140
所以我一直在教茶树，因为

228
00:08:33,140 --> 00:08:34,099
我认为它们' 令人着迷，关于它们

229
00:08:34,099 --> 00:08:35,419
的维基百科文章并不多

230
00:08:35,419 --> 00:08:37,760
，正如我所说，时间

231
00:08:37,760 --> 00:08:40,099
站今天仍在使用它们，但默认情况下，

232
00:08:40,099 --> 00:08:41,539
如果您

233
00:08:41,539 --> 00:08:43,909
在 10 次创建表或索引，您会得到一个 B+

234
00:08:43,909 --> 00:08:45,680
树，您可以通过一个 强制到达的标志

235
00:08:45,680 --> 00:08:47,270
一棵树，但

236
00:08:47,270 --> 00:08:48,620
今天仍然使用茶树的数据库很少，

237
00:08:48,620 --> 00:08:50,270
它们主要用于

238
00:08:50,270 --> 00:08:52,510
像运行在极低内存

239
00:08:52,510 --> 00:08:55,150
环境中的嵌入式设备，所以

240
00:08:55,150 --> 00:08:56,920
关于它们的信息真的没有那么多，所以我总是

241
00:08:56,920 --> 00:08:58,090
喜欢谈论它们，因为我认为

242
00:08:58,090 --> 00:08:59,950
我 认为它们有点迷人

243
00:08:59,950 --> 00:09:01,900
，结果发现实际上

244
00:09:01,900 --> 00:09:03,550
发明它的人上个月给我发了一封电子邮件

245
00:09:03,550 --> 00:09:05,020
，只是说嘿，看，我看到你在

246
00:09:05,020 --> 00:09:07,960
谈论茶树，而

247
00:09:07,960 --> 00:09:09,850
我总是犯的错误是我说哦 它被

248
00:09:09,850 --> 00:09:11,770
称为茶，因为纸条看起来像

249
00:09:11,770 --> 00:09:14,650
茶，但他告诉我我错了，所以这个

250
00:09:14,650 --> 00:09:16,270
人的名字是托比雷曼，他

251
00:09:16,270 --> 00:09:19,120
在威斯康星大学获得博士学位，他以

252
00:09:19,120 --> 00:09:21,610
自己的名字命名，所以茶和茶树是

253
00:09:21,610 --> 00:09:24,220
托比 我认为这很棒，所以现在

254
00:09:24,220 --> 00:09:27,370
对于 B+ 树我们总是说哦，

255
00:09:27,370 --> 00:09:29,920
B 意味着平衡 他说这

256
00:09:29,920 --> 00:09:31,270
实际上只是意味着它以

257
00:09:31,270 --> 00:09:33,100
自己的名字命名

258
00:09:33,100 --> 00:09:34,810


259
00:09:34,810 --> 00:09:36,460
不知道这是

260
00:09:36,460 --> 00:09:38,830
不是真的 但茶茶和茶树的意思是托比

261
00:09:38,830 --> 00:09:40,390
，这太棒了，他指出了一些

262
00:09:40,390 --> 00:09:41,620
其他组织，我稍后会谈到

263
00:09:41,620 --> 00:09:44,050
，这就是我

264
00:09:44,050 --> 00:09:45,790
喜欢互联网的原因，因为我从未见过这个

265
00:09:45,790 --> 00:09:47,530
人，我实际上知道他是谁 他刚刚

266
00:09:47,530 --> 00:09:48,970
找到了 YouTube 视频，他给我发

267
00:09:48,970 --> 00:09:49,990
了一封电子邮件，嘿，你错了

268
00:09:49,990 --> 00:09:51,910
一些很棒的事情，所以

269
00:09:51,910 --> 00:09:53,410
这里是数据卡车的

270
00:09:53,410 --> 00:09:55,210
样子，我一直认为，因为

271
00:09:55,210 --> 00:09:57,580
它的鼻子看起来像

272
00:09:57,580 --> 00:10:00,070
t 这就是为什么他们称我的茶树但

273
00:10:00,070 --> 00:10:02,770
事实并非如此 那么

274
00:10:02,770 --> 00:10:04,900
节点实际上是什么样子 所以节点我

275
00:10:04,900 --> 00:10:07,330
是指针的组合 然后只有

276
00:10:07,330 --> 00:10:10,000
两个键 所以我们在这里的第一件事

277
00:10:10,000 --> 00:10:11,590
是数据指针

278
00:10:11,590 --> 00:10:13,870
这些是 现在要指出

279
00:10:13,870 --> 00:10:16,570
实际的表，并对应于

280
00:10:16,570 --> 00:10:18,160
它们代表的元组，

281
00:10:18,160 --> 00:10:19,600
所以这是我们的数据表，这些是

282
00:10:19,600 --> 00:10:21,610
键，所以这些只是指向两个

283
00:10:21,610 --> 00:10:23,650
不同键的指针，或者指向要发布的原始键

284
00:10:23,650 --> 00:10:26,320
，所以这些 指针将 按照

285
00:10:26,320 --> 00:10:28,150
存储在数据表中的键的顺序进行排序，

286
00:10:28,150 --> 00:10:30,520
所以现在我

287
00:10:30,520 --> 00:10:32,560
再次保留我可以进行二分搜索，

288
00:10:32,560 --> 00:10:34,780
我通常会在 B+ 树中进行

289
00:10:34,780 --> 00:10:36,670
跳转以找到我正在寻找的条目

290
00:10:36,670 --> 00:10:38,050
但任何时候我需要

291
00:10:38,050 --> 00:10:39,940
你进行比较，比如我的密钥

292
00:10:39,940 --> 00:10:41,050
等于这个密钥还是小于一个大于

293
00:10:41,050 --> 00:10:43,690
我必须跟随指针到达

294
00:10:43,690 --> 00:10:44,890
原始元组以找出

295
00:10:44,890 --> 00:10:48,520
原始密钥在

296
00:10:48,520 --> 00:10:51,820
现代系统中是否正常我 我们的指针是 64 位

297
00:10:51,820 --> 00:10:54,250
，实际上它们是 48 位，但是

298
00:10:54,250 --> 00:10:56,410
你必须分配一个 64 位的 64 位

299
00:10:56,410 --> 00:10:59,200
指针空间，然后你知道这些

300
00:10:59,200 --> 00:11:01,540
东西我认为可能是 16 位，

301
00:11:01,540 --> 00:11:04,030
而值是 16 位的，所以

302
00:11:04,030 --> 00:11:06,100
没有存储 键加上

303
00:11:06,100 --> 00:11:07,900
返回键的指针，我可以

304
00:11:07,900 --> 00:11:08,980
减少

305
00:11:08,980 --> 00:11:12,670
状态数量的大小，如果故事已经

306
00:11:12,670 --> 00:11:15,940
知道一半了，另一

307
00:11:15,940 --> 00:11:17,620
件事现在也是这些数据

308
00:11:17,620 --> 00:11:20,410
指针，所以不像在 B+ 树中，

309
00:11:20,410 --> 00:11:22,300
你通常只有 将指针

310
00:11:22,300 --> 00:11:24,850
指向您的孩子 或者任何兄弟，如果

311
00:11:24,850 --> 00:11:28,060
你是茶树中的叶节点，你

312
00:11:28,060 --> 00:11:29,520
必须有指向父

313
00:11:29,520 --> 00:11:31,750
节点的指针，因为叶节点不会

314
00:11:31,750 --> 00:11:33,220
是我们可能需要反向备份的键的最终位置，

315
00:11:33,220 --> 00:11:34,720
我们需要有一个

316
00:11:34,720 --> 00:11:37,360
指针指向 回到那里，然后我们

317
00:11:37,360 --> 00:11:38,380
有指向左右

318
00:11:38,380 --> 00:11:41,410
孩子的指针，然后我们有我们的节点边界

319
00:11:41,410 --> 00:11:43,690
键，这将是由该节点

320
00:11:43,690 --> 00:11:46,870
表示的键的最小值

321
00:11:46,870 --> 00:11:50,110
和最大值，因此任何

322
00:11:50,110 --> 00:11:52,630
小于该键的值都会

323
00:11:52,630 --> 00:11:54,070
在树的这一侧找到任何在该键中很棒的东西都

324
00:11:54,070 --> 00:11:55,150
将在另一侧找到，

325
00:11:55,150 --> 00:11:57,730
所以这不像

326
00:11:57,730 --> 00:12:01,240
他的方式 它不像在 a 和 B 加

327
00:12:01,240 --> 00:12:03,310
树中，根节点会让你

328
00:12:03,310 --> 00:12:04,660
知道 左右边界将

329
00:12:04,660 --> 00:12:07,300


330
00:12:07,300 --> 00:12:09,220
在关键空间中包含您下方的大部分空间，右侧这

331
00:12:09,220 --> 00:12:12,970
只是关键空间的一部分，所有权利

332
00:12:12,970 --> 00:12:16,180
，然后现在让我们看看它说

333
00:12:16,180 --> 00:12:17,560
实际上想要查找所以我们有一个

334
00:12:17,560 --> 00:12:19,660
三节点茶树，我们试图

335
00:12:19,660 --> 00:12:22,660
找到密钥 k2 所以 ag  ain 我从根开始，

336
00:12:22,660 --> 00:12:25,120
这些只是指向

337
00:12:25,120 --> 00:12:27,400
原始键的指针，所以我在这里的

338
00:12:27,400 --> 00:12:29,290
这个节点的键空间包含一些 Kum

339
00:12:29,290 --> 00:12:31,630
Kee 两个键 6 在内，所以现在我

340
00:12:31,630 --> 00:12:33,430
有按键顺序排序的指针

341
00:12:33,430 --> 00:12:36,070
指向什么 被

342
00:12:36,070 --> 00:12:39,640
存储在数据表中，所以现在我

343
00:12:39,640 --> 00:12:42,040
将我的指针放在此处，这

344
00:12:42,040 --> 00:12:43,720
允许我进行遍历，因此一

345
00:12:43,720 --> 00:12:44,860
开始我就在根目录中

346
00:12:44,860 --> 00:12:48,250
寻找一个关键的键，因此我只需要

347
00:12:48,250 --> 00:12:52,150
进行一次比较 每个

348
00:12:52,150 --> 00:12:53,740
键找出一个烫发节点来

349
00:12:53,740 --> 00:12:55,420
找出我需要去的地方，所以我

350
00:12:55,420 --> 00:12:57,250
在这里有一个这个键的副本，因为这样我

351
00:12:57,250 --> 00:12:58,690
可以有效地做到这一点，而不必

352
00:12:58,690 --> 00:13:01,810
去原始表，但我

353
00:13:01,810 --> 00:13:03,490
只是做一个快速比较 它是 K 2

354
00:13:03,490 --> 00:13:06,910
小于 k 4，如果是，那么我知道我想

355
00:13:06,910 --> 00:13:10,060
在这里跟随那个指针，

356
00:13:10,060 --> 00:13:11,500
所以即使我说大多数时候

357
00:13:11,500 --> 00:13:13,060
必须执行这些指针查找是低效的，

358
00:13:13,060 --> 00:13:15,010
你不必

359
00:13:15,010 --> 00:13:16,180
这样做 只有当你登陆

360
00:13:16,180 --> 00:13:17,290
节点才能找到 你正在寻找

361
00:13:17,290 --> 00:13:19,180
的你认为关键应该

362
00:13:19,180 --> 00:13:21,610
是你必须按照这个做

363
00:13:21,610 --> 00:13:22,870
的所以然后我们降落在这里

364
00:13:22,870 --> 00:13:24,790
然后现在我们检查K 2

365
00:13:24,790 --> 00:13:27,910
是否大于K 1 它也是我们

366
00:13:27,910 --> 00:13:29,320
想要检查 K 2 小于 K 3 的位置

367
00:13:29,320 --> 00:13:32,560
，所以我们知道我们的密钥将存在，

368
00:13:32,560 --> 00:13:34,750
因为我们知道或者它应该

369
00:13:34,750 --> 00:13:36,490
可能存在，因为它在

370
00:13:36,490 --> 00:13:39,060
我们这里的边界内，

371
00:13:39,060 --> 00:13:42,580
所以现在我们再次这样做，保持

372
00:13:42,580 --> 00:13:44,490
简单 因为我们不是

373
00:13:44,490 --> 00:13:47,080
每个节点只有三个键，但我们习惯于

374
00:13:47,080 --> 00:13:48,910
线性扫描并

375
00:13:48,910 --> 00:13:51,550
按照指针查看每条记录，

376
00:13:51,550 --> 00:13:52,630
然后在那里准备一些键

377
00:13:52,630 --> 00:13:56,620
是的问题是你什么时候

378
00:13:56,620 --> 00:13:58,870
回去我 没有这方面的幻灯片，

379
00:13:58,870 --> 00:14:00,760
但是当您进行范围扫描时，例如

380
00:14:00,760 --> 00:14:04,780
大于 k2 的最终键，我会

381
00:14:04,780 --> 00:14:06,310
来到这里扫描查找

382
00:14:06,310 --> 00:14:08,170
所有内容，然后跳回并

383
00:14:08,170 --> 00:14:08,620
继续前进，

384
00:14:08,620 --> 00:14:11,020
因此基本上在您尝试的初始搜索中

385
00:14:11,020 --> 00:14:13,450
从你身边找到

386
00:14:13,450 --> 00:14:16,180
最左边的起点，然后 你

387
00:14:16,180 --> 00:14:17,680
扫视一下，当你意识到

388
00:14:17,680 --> 00:14:19,480
我下面没有任何东西时，我认为

389
00:14:19,480 --> 00:14:24,400
上面有一些东西我

390
00:14:24,400 --> 00:14:25,510


391
00:14:25,510 --> 00:14:27,190


392
00:14:27,190 --> 00:14:30,370


393
00:14:30,370 --> 00:14:37,270
回家了 例如，因为它

394
00:14:37,270 --> 00:14:45,790
适合幻灯片，所以再次就像

395
00:14:45,790 --> 00:14:46,720
原始规格中没有任何内容

396
00:14:46,720 --> 00:14:48,550
茶树的关键

397
00:14:48,550 --> 00:14:50,050
是说你必须再次拥有三个

398
00:14:50,050 --> 00:14:52,060
才能使它适合我放三个你可以

399
00:14:52,060 --> 00:14:53,470
有五个得到 20 在任何它没有的情况下

400
00:14:53,470 --> 00:14:54,420


401
00:14:54,420 --> 00:15:04,780
是的，所以她的问题是

402
00:15:04,780 --> 00:15:06,550
，pin 中的这个范围

403
00:15:06,550 --> 00:15:08,140
是孩子之间的父级

404
00:15:08,140 --> 00:15:17,350
，所以再次如此，在 B+

405
00:15:17,350 --> 00:15:19,050
树中，所有的键都在底部

406
00:15:19,050 --> 00:15:22,600
，在 ABL 树中，您

407
00:15:22,600 --> 00:15:24,910
实际上可以常规 B 树 可以在

408
00:15:24,910 --> 00:15:27,250
任何地方都有键或键和

409
00:15:27,250 --> 00:15:28,540
值指针指向树

410
00:15:28,540 --> 00:15:30,280
中数据结构中任何位置的实际元组，

411
00:15:30,280 --> 00:15:33,970
所以在 B+ 树中，如果

412
00:15:33,970 --> 00:15:36,760
叶节点中

413
00:15:36,760 --> 00:15:38,350
只有几个键，然后是 th 的值 e

414
00:15:38,350 --> 00:15:40,210
点是叶节点然后我在上面

415
00:15:40,210 --> 00:15:41,860
我浪费空间因为现在我正在

416
00:15:41,860 --> 00:15:43,720
存储这些路标键所以他们

417
00:15:43,720 --> 00:15:45,550
试图使用

418
00:15:45,550 --> 00:15:48,220
每个节点的最大使用率所以他们存储

419
00:15:48,220 --> 00:15:50,140
键值指针任何人包括

420
00:15:50,140 --> 00:15:53,310
此处父节点中的根节点

421
00:15:54,420 --> 00:15:57,760
，这些是路标，但如果我

422
00:15:57,760 --> 00:16:00,040
正在寻找 Keith 的关键 5，

423
00:16:00,040 --> 00:16:03,160
例如我在这里，那么我会说

424
00:16:03,160 --> 00:16:05,140
关键 4 关键 5 更大

425
00:16:05,140 --> 00:16:07,390
，关键 5 是更少 比关键六，所以我知道

426
00:16:07,390 --> 00:16:11,020
我要找的东西在这里，所以

427
00:16:11,020 --> 00:16:13,020
我不需要再次查看叶节点

428
00:16:13,020 --> 00:16:15,460
和 B+ 树，它们将

429
00:16:15,460 --> 00:16:17,680
所有东西都推到了底部，因为现在如果

430
00:16:17,680 --> 00:16:19,120
我想做那个皮肤，我不需要 不回溯

431
00:16:19,120 --> 00:16:21,040
我只是按顺序扫描叶节点，

432
00:16:21,040 --> 00:16:23,410
然后找到我想要的

433
00:16:23,410 --> 00:16:40,540


434
00:16:40,540 --> 00:16:42,040


435
00:16:42,040 --> 00:16:44,230


436
00:16:44,230 --> 00:16:47,050


437
00:16:47,050 --> 00:16:48,250
东西 这被

438
00:16:48,250 --> 00:16:50,620
分散在任何地方，用于四个 in meri

439
00:16:50,620 --> 00:16:53,790
系统，所以如果 我正在尝试

440
00:16:53,790 --> 00:16:57,460
找到一个正确的值范围，它是一个

441
00:16:57,460 --> 00:16:59,290
顺序保留树，因此如果它是 B+

442
00:16:59,290 --> 00:17:02,050
树，则所有叶节点都按

443
00:17:02,050 --> 00:17:04,180
该顺序存储，我只是尝试找到最左边的

444
00:17:04,180 --> 00:17:05,470
节点开始，然后我

445
00:17:05,470 --> 00:17:08,050
按顺序 在磁盘上扫描速度更快

446
00:17:08,050 --> 00:17:09,760
Orion 系统至少在旋转

447
00:17:09,760 --> 00:17:11,349
我们的情况下即使在今天

448
00:17:11,349 --> 00:17:12,790
他们仍然更快但就像我刚刚

449
00:17:12,790 --> 00:17:13,900
沿着底部进行顺序扫描

450
00:17:13,900 --> 00:17:15,880
并找到我想要的我永远不会

451
00:17:15,880 --> 00:17:18,069
回到我们 重新尝试在这个世界上避免随机 i/o

452
00:17:18,069 --> 00:17:20,530
随机 i/o 没什么大不了的，

453
00:17:20,530 --> 00:17:22,720
因为它在内存中谁在乎，所以我

454
00:17:22,720 --> 00:17:24,579
可以跳来跳去并遍历备份，

455
00:17:24,579 --> 00:17:27,280
我不会为此付出很大的代价，对

456
00:17:27,280 --> 00:17:29,260
吧

457
00:17:29,260 --> 00:17:32,440
通过使用

458
00:17:32,440 --> 00:17:33,820
所有高音或

459
00:17:33,820 --> 00:17:35,350
数据结构的内部节点来存储

460
00:17:35,350 --> 00:17:38,890
我关心的键和值，我坚持她的观点，

461
00:17:38,890 --> 00:17:41,200
因为我在 B+ 树中购买了浪费更少的空间，因为

462
00:17:41,200 --> 00:17:43,390
我可以 可以删除

463
00:17:43,390 --> 00:17:46,450
叶节点中的一个密钥，我可以在互联网上扩展它，

464
00:17:46,450 --> 00:17:49,590
因为 t 这是我的路标

465
00:17:50,610 --> 00:17:53,610
好吧

466
00:17:53,760 --> 00:17:57,310
它已经到了 看看它 好吧 所以我想

467
00:17:57,310 --> 00:17:58,750
我已经说了很多这

468
00:17:58,750 --> 00:18:01,180
就像我

469
00:18:01,180 --> 00:18:02,950
教茶树的部分原因是因为它只是在

470
00:18:02,950 --> 00:18:04,510
思考如何做一个不同的方式

471
00:18:04,510 --> 00:18:06,340
内存数据库，然后是

472
00:18:06,340 --> 00:18:09,850
索引，你可能会遇到一些，或者

473
00:18:09,850 --> 00:18:11,140
你可能会遇到有人说哦，

474
00:18:11,140 --> 00:18:13,270
为什么我们在内存数据库中使用 B+ 树，

475
00:18:13,270 --> 00:18:16,390
我们不应该使用你

476
00:18:16,390 --> 00:18:17,890
知道的更优化他们的数据

477
00:18:17,890 --> 00:18:19,750
结构，就像茶一样 树答案是

478
00:18:19,750 --> 00:18:21,700
否定的，因为我将

479
00:18:21,700 --> 00:18:23,260
在下一张幻灯片中介绍防御者，但只是一个

480
00:18:23,260 --> 00:18:25,120
小姐，主要是为了您的背景

481
00:18:25,120 --> 00:18:27,040
信息，所以我们已经说过，

482
00:18:27,040 --> 00:18:28,660
我们存储索引使用的内存较少，

483
00:18:28,660 --> 00:18:30,220
因为我们不存储复制键

484
00:18:30,220 --> 00:18:31,780
每一个节点，然后每一个

485
00:18:31,780 --> 00:18:33,790
键也总是被用于

486
00:18:33,790 --> 00:18:35,590
存储键值对，而不仅仅是

487
00:18:35,590 --> 00:18:37,570


488
00:18:37,570 --> 00:18:39,610
指导你老师的发明者指出的另一件有趣的事情

489
00:18:39,610 --> 00:18:40,660
，我认为有些

490
00:18:40,660 --> 00:18:41,950
事情我没有想到 t

491
00:18:41,950 --> 00:18:46,540
是在茶树中 因为现在当

492
00:18:46,540 --> 00:18:49,900
你评估说是我的键

493
00:18:49,900 --> 00:18:52,030
等于这个键还是我的搜索

494
00:18:52,030 --> 00:18:54,220
键等于两个加号我正在

495
00:18:54,220 --> 00:18:55,780
下降指针我正在查看整个

496
00:18:55,780 --> 00:18:58,510
记录所以一旦你 这样做你

497
00:18:58,510 --> 00:19:00,160
已经付出了

498
00:19:00,160 --> 00:19:01,480
下降指针的代价，现在

499
00:19:01,480 --> 00:19:03,700
查看记录而不是仅仅比较你

500
00:19:03,700 --> 00:19:05,110
看搜索键是否

501
00:19:05,110 --> 00:19:08,020
与该元组的索引键匹配，

502
00:19:08,020 --> 00:19:10,210
你也可以评估所有

503
00:19:10,210 --> 00:19:11,740
其他谓词

504
00:19:11,740 --> 00:19:14,170
如果我有一个 where

505
00:19:14,170 --> 00:19:16,060
子句，其中 a 等于 1 且 B 等于

506
00:19:16,060 --> 00:19:19,300
2 并且我的索引仅在 a 和 B

507
00:19:19,300 --> 00:19:21,310
加树上，那么您的 where 子句就正确

508
00:19:21,310 --> 00:19:22,930


509
00:19:22,930 --> 00:19:24,130
可以看到

510
00:19:24,130 --> 00:19:26,290
我的索引内部然后我必须

511
00:19:26,290 --> 00:19:28,690
在索引或元组上进行查找然后评估

512
00:19:28,690 --> 00:19:31,660
B 但在茶树中你可以

513
00:19:31,660 --> 00:19:33,130
在我查看元组时立即完成所有操作以

514
00:19:33,130 --> 00:19:35,890
查看 B 所以你

515
00:19:35,890 --> 00:19:37,420
可能最终会扔掉

516
00:19:37,420 --> 00:19:40,210
或扔掉 比你更快地找出元组，

517
00:19:40,210 --> 00:19:41,820
否则

518
00:19:41,820 --> 00:19:51,760
是的 david 一直是关键表

519
00:19:51,760 --> 00:19:54,390
你喜欢什么关键表

520
00:19:56,380 --> 00:19:59,530
这是整个但是是的这个

521
00:19:59,530 --> 00:20:01,210
列数据这就像一堆

522
00:20:01,210 --> 00:20:02,530
其他属性这是这是

523
00:20:02,530 --> 00:20:05,309
我的属性 m Keith 我是下一个

524
00:20:05,309 --> 00:20:07,360
没有单独的键表

525
00:20:07,360 --> 00:20:10,090
会浪费空间为什么因为我的意思是

526
00:20:10,090 --> 00:20:11,950
索引本身是一个键表可以考虑

527
00:20:11,950 --> 00:20:19,120
所以对于这里的这个表有

528
00:20:19,120 --> 00:20:22,059
现代系统中的技术

529
00:20:22,059 --> 00:20:24,490
可以得到 这也有好处，所以你可以

530
00:20:24,490 --> 00:20:26,410
像部分索引一样做，你可以

531
00:20:26,410 --> 00:20:28,750
定义一个 where 子句来定义索引中

532
00:20:28,750 --> 00:20:32,350
可能包含的键，比如构建索引

533
00:20:32,350 --> 00:20:35,470
，只有

534
00:20:35,470 --> 00:20:37,900
在 15 7 21 岁就注册的学生，

535
00:20:37,900 --> 00:20:39,159
所以所有其他学生都没有 't in

536
00:20:39,159 --> 00:20:41,140
the class 不在索引内，所以

537
00:20:41,140 --> 00:20:42,360
这种方式有点像

538
00:20:42,360 --> 00:20:44,470
提前预过滤 where 子句

539
00:20:44,470 --> 00:20:46,450
而无需存储额外

540
00:20:46,450 --> 00:20:48,520
信息，或者在其他系统中您

541
00:20:48,520 --> 00:20:50,650
可以包含列，这样您就可以说我

542
00:20:50,650 --> 00:20:52,870
想要 被索引

543
00:20:52,870 --> 00:20:56,289
顺便说一下，将 B 存储在叶节点中，

544
00:20:56,289 --> 00:20:57,520
这样我就不必去

545
00:20:57,520 --> 00:20:58,809
查找索引而是查找管或

546
00:20:58,809 --> 00:20:59,980
弄清楚如何评估

547
00:20:59,980 --> 00:21:02,140
B 上的谓词 做这个

548
00:21:02,140 --> 00:21:03,100
续集服务器可以做到这一点 这

549
00:21:03,100 --> 00:21:05,799
实际上在今天更常见一点，

550
00:21:05,799 --> 00:21:07,390
它并不像实际上

551
00:21:07,390 --> 00:21:10,030
在整个索引中到处都有一个存储 B

552
00:21:10,030 --> 00:21:11,890
你只存储它并且只让

553
00:21:11,890 --> 00:21:14,140
叶节点这样你会得到好处

554
00:21:14,140 --> 00:21:17,080
从这一点来看，我认为

555
00:21:17,080 --> 00:21:18,250
这不像在

556
00:21:18,250 --> 00:21:21,130
他们评估这一切正常的那一天那么重要，所以

557
00:21:21,130 --> 00:21:23,500
为什么没有人很好地使用它们我没有

558
00:21:23,500 --> 00:21:24,610
谈论如何实际如何

559
00:21:24,610 --> 00:21:25,960
维护这个东西并保持平衡，

560
00:21:25,960 --> 00:21:27,490
如果 黄树有点棘手，

561
00:21:27,490 --> 00:21:28,570
因为你并没有真正拆分一些

562
00:21:28,570 --> 00:21:30,669
合并，你必须进行轮换

563
00:21:30,669 --> 00:21:31,780


564
00:21:31,780 --> 00:21:34,150


565
00:21:34,150 --> 00:21:36,429


566
00:21:36,429 --> 00:21:37,809
就像

567
00:21:37,809 --> 00:21:40,320
很难确保我保证

568
00:21:40,320 --> 00:21:43,900
我在线程安全中的所有操作然后

569
00:21:43,900 --> 00:21:46,090
正如我所说，一旦 CPU 缓存

570
00:21:46,090 --> 00:21:49,870
变得更快，追逐

571
00:21:49,870 --> 00:21:51,549
那些指针的成本我正在查看

572
00:21:51,549 --> 00:21:53,320
实际上变得非常重要的元组，

573
00:21:53,320 --> 00:21:55,929
因此实际上最好是“是”或“

574
00:21:55,929 --> 00:21:57,909
冗余” 数据结构中的键的副本，

575
00:21:57,909 --> 00:22:00,429
但避免了这种

576
00:22:00,429 --> 00:22:01,870
惩罚，在这里你付出了一点

577
00:22:01,870 --> 00:22:03,549
额外的存储开销来获得一个相当重要的

578
00:22:03,549 --> 00:22:06,370
性能效率游戏，

579
00:22:06,370 --> 00:22:09,850
所以有一篇论文是由哥伦比亚的肯罗斯在 1999 年完成的

580
00:22:09,850 --> 00:22:13,179
，基本上

581
00:22:13,179 --> 00:22:15,130
说教师 对 M 索引来说是个坏主意

582
00:22:15,130 --> 00:22:17,200
，实际上 B+ 树或

583
00:22:17,200 --> 00:22:18,520
看起来像 B+ 树的异常是

584
00:22:18,520 --> 00:22:20,320
更好的方法，所以这就是为什么我说

585
00:22:20,320 --> 00:22:24,190
今天没有人真正

586
00:22:24,190 --> 00:22:26,799
真正使用它，除非你

587
00:22:26,799 --> 00:22:28,150
知道嵌入式设备，因为

588
00:22:28,150 --> 00:22:29,679
游戏被称为extreme DB，它只是一个

589
00:22:29,679 --> 00:22:31,690
运行，就像你知道很少的IOT设备一样

590
00:22:31,690 --> 00:22:34,030
，这个世界肯定是对的，我认为

591
00:22:34,030 --> 00:22:35,890
这是有道理的，但对于你知道的

592
00:22:35,890 --> 00:22:37,780
大的你知道至强服务器

593
00:22:37,780 --> 00:22:40,030
教师是 可能不是正确的

594
00:22:40,030 --> 00:22:49,360
选择是的，这个问题是

595
00:22:49,360 --> 00:22:51,490
二分搜索如何在这里再次正常工作

596
00:22:51,490 --> 00:22:53,799
所以这是线性搜索所以说我

597
00:22:53,799 --> 00:22:56,320
进行了二分搜索并且我降落在这里所以

598
00:22:56,320 --> 00:22:58,030
我要去做什么我要去

599
00:22:58,030 --> 00:23:00,909
查找密钥 在数据表中，我

600
00:23:00,909 --> 00:23:03,070
现在得到密钥，然后我将它与

601
00:23:03,070 --> 00:23:05,860
我正在寻找的密钥进行比较，如果我的密钥

602
00:23:05,860 --> 00:23:06,669
大于那个 Keeney

603
00:23:06,669 --> 00:23:08,350
那么我知道我想走这条路，如果

604
00:23:08,350 --> 00:23:09,220
它小于那我走另一

605
00:23:09,220 --> 00:23:13,299
条路 这些是按键和

606
00:23:13,299 --> 00:23:15,880
键排序的 Kings 的值 数据

607
00:23:15,880 --> 00:23:17,140
表可以立即以任何方式排序

608
00:23:17,140 --> 00:23:20,409
这是一个关系数据库包

609
00:23:20,409 --> 00:23:24,730
代数 这些是未排序的所以

610
00:23:24,730 --> 00:23:26,380
我提出的所有要点都是

611
00:23:26,380 --> 00:23:29,290
我们将在一个 B+ 树，像

612
00:23:29,290 --> 00:23:30,790
二分搜索或

613
00:23:30,790 --> 00:23:32,649
灾难搜索的线性搜索我们仍然可以做所有

614
00:23:32,649 --> 00:23:34,179
这些事情，只是我们必须支付

615
00:23:34,179 --> 00:23:36,100
额外的惩罚，在那里的某个地方额外跳转

616
00:23:36,100 --> 00:23:39,299
，看看实际的 Milky 是什么，但

617
00:23:39,480 --> 00:23:41,049
我们认为我们实际上会很

618
00:23:41,049 --> 00:23:43,030
有趣 现在我想了想

619
00:23:43,030 --> 00:23:47,440
我知道这是 为第二个项目做这件事太晚了，

620
00:23:47,440 --> 00:23:52,059
但正如我之前所说，

621
00:23:52,059 --> 00:23:54,490
当你在 x86 上得到一个指针时，

622
00:23:54,490 --> 00:23:57,370
就像你必须正确分配 64 位，

623
00:23:57,370 --> 00:24:00,549
但在硬件中，它们实际上只

624
00:24:00,549 --> 00:24:03,669
存储 48 位，所以你有 16

625
00:24:03,669 --> 00:24:04,659
位 你实际上可以存储

626
00:24:04,659 --> 00:24:07,059
你想要的任何东西，当你这样做时，

627
00:24:07,059 --> 00:24:08,289
当你引用

628
00:24:08,289 --> 00:24:09,970
那个取消引用该内存地址的指针时，

629
00:24:09,970 --> 00:24:12,090
港口只是忽略了 16 位，

630
00:24:12,090 --> 00:24:14,290
所以你可以做一些像 64 位这样的事情，

631
00:24:14,290 --> 00:24:17,380
我仍然有 48 位

632
00:24:17,380 --> 00:24:18,820
指向我需要进入数据表的任何地方的指针，

633
00:24:18,820 --> 00:24:20,320
但我

634
00:24:20,320 --> 00:24:23,169
将部分密钥存储在这里，所以

635
00:24:23,169 --> 00:24:24,460
有时我必须去查找有时

636
00:24:24,460 --> 00:24:29,860
我不这样是的，这可能有效，

637
00:24:29,860 --> 00:24:32,980
但问题是 一个英特尔

638
00:24:32,980 --> 00:24:34,570
可以在任何时候拿走它并

639
00:24:34,570 --> 00:24:37,269
开始使用完整的 64 位 II 是

640
00:24:37,269 --> 00:24:40,389
在我们的技术研讨会上，

641
00:24:40,389 --> 00:24:42,190
但几年前这个英特尔家伙

642
00:24:42,190 --> 00:24:43,870
说他们有一个内存数据库

643
00:24:43,870 --> 00:24:45,970
，可以最大化 你知道的 48 个

644
00:24:45,970 --> 00:24:48,159
减去一个地址 并且

645
00:24:48,159 --> 00:24:49,600
最终英特尔将

646
00:24:49,600 --> 00:24:51,429
使用 64 位，所以不要在那些

647
00:24:51,429 --> 00:24:53,200
额外的 16 位中存储任何内容，但这就像三

648
00:24:53,200 --> 00:24:54,970
年前一样，还没有发生过，

649
00:24:54,970 --> 00:24:58,720
所以我不知道我不知道我

650
00:24:58,720 --> 00:25:00,279
不认为这是一个好主意，至少是

651
00:25:00,279 --> 00:25:02,169
面向未来的系统，我们将看到这种

652
00:25:02,169 --> 00:25:03,789
技术用于

653
00:25:03,789 --> 00:25:05,590
来自 hyper 的哈希传递连接，但他们使用链哈希

654
00:25:05,590 --> 00:25:07,059
表，因为他们存储了一些螃蟹

655
00:25:07,059 --> 00:25:08,919
网，他们在 16 位中对布隆过滤器进行了排序

656
00:25:08,919 --> 00:25:12,549
有点酷 好吧 我不会

657
00:25:12,549 --> 00:25:13,990
纠缠于老师 他太像这样

658
00:25:13,990 --> 00:25:16,929


659
00:25:16,929 --> 00:25:19,149
了 在 B+ 树或更现代的情况下，

660
00:25:19,149 --> 00:25:20,799
我们应该关注这一点

661
00:25:20,799 --> 00:25:24,059


662
00:25:24,059 --> 00:25:28,179


663
00:25:28,179 --> 00:25:32,320
很难让茶树高效运行

664
00:25:32,320 --> 00:25:33,940
或使其无闩锁

665
00:25:33,940 --> 00:25:37,000
的原因是我们到处都有指针，

666
00:25:37,000 --> 00:25:38,830
我们知道每个父

667
00:25:38,830 --> 00:25:40,210
指针都有一个指向孩子的指针，

668
00:25:40,210 --> 00:25:42,159
而孩子有一个指向孩子的指针 父母

669
00:25:42,159 --> 00:25:45,600
所以现在如果我需要移动一个 其中我

670
00:25:45,600 --> 00:25:47,500
更改了一个内存地址我必须

671
00:25:47,500 --> 00:25:49,539
更改一堆内存，就像所有

672
00:25:49,539 --> 00:25:50,440
指向该父级的孩子一样

673
00:25:50,440 --> 00:25:53,200
，但我无法使用原子比较和交换指令来做到这一点，

674
00:25:53,200 --> 00:25:55,019
因为

675
00:25:55,019 --> 00:25:57,370
您无法更新多个内存

676
00:25:57,370 --> 00:25:59,190
地址 这就像一个 64 位和一个

677
00:25:59,190 --> 00:26:01,960
128 位的位置我不能说

678
00:26:01,960 --> 00:26:05,590
这两个事情本周相关联的原子更新

679
00:26:05,590 --> 00:26:07,120
这也是我们不能

680
00:26:07,120 --> 00:26:09,340
为你构建一个闩锁

681
00:26:09,340 --> 00:26:10,360
的原因你知道，出于同样的原因我们' 将

682
00:26:10,360 --> 00:26:11,710
有指向乘法中的事物的指针以

683
00:26:11,710 --> 00:26:13,149


684
00:26:13,149 --> 00:26:15,850
原子方式更新它们只是不可能所以

685
00:26:15,850 --> 00:26:18,789
有点激发我们

686
00:26:18,789 --> 00:26:21,250
可能想要构建aa lat

687
00:26:21,250 --> 00:26:24,039
树B加树的设计

688
00:26:24,039 --> 00:26:26,169
解决这个多地址问题的方法

689
00:26:26,169 --> 00:26:28,659
是 如果我们有一个间接层或

690
00:26:28,659 --> 00:26:32,139
一些集中式数据结构，我们

691
00:26:32,139 --> 00:26:34,020
可以

692
00:26:34,020 --> 00:26:39,440
记录这些地址，然后

693
00:26:39,440 --> 00:26:41,730
我们的数据结构中的多个多个元素或注释

694
00:26:41,730 --> 00:26:43,260
可以知道如何

695
00:26:43,260 --> 00:26:44,850
在该映射的间接层中进行

696
00:26:44,850 --> 00:26:47,220
查找 ble 然后现在我只需要

697
00:26:47,220 --> 00:26:48,510
在该映射表中进行比较和交换，

698
00:26:48,510 --> 00:26:49,740
更改一个地址，并

699
00:26:49,740 --> 00:26:51,840
自动将更改传播

700
00:26:51,840 --> 00:26:54,600
到整个数据

701
00:26:54,600 --> 00:26:56,220
结构中，然后我可以制作一个闩锁

702
00:26:56,220 --> 00:26:59,760
环，这就是 BW

703
00:26:59,760 --> 00:27:02,220
树的本质 B  Dimitri 是一种闩锁树 B

704
00:27:02,220 --> 00:27:04,230
加树，它是从黑客马拉松

705
00:27:04,230 --> 00:27:06,360
项目中产生的，正如我所说的，我认为两个班级

706
00:27:06,360 --> 00:27:08,940
以前微软的那些很棒的人，

707
00:27:08,940 --> 00:27:10,590
当他们第一次设计建筑

708
00:27:10,590 --> 00:27:12,270
黑客马拉松时，他们最初

709
00:27:12,270 --> 00:27:13,890
用跳过列表来构建它，因为跳过列表或闩锁

710
00:27:13,890 --> 00:27:15,750
树 然后他们意识到跳过列表是一个

711
00:27:15,750 --> 00:27:18,360
坏主意，图表将显示

712
00:27:18,360 --> 00:27:20,670
它表现不佳 ed 然后他们

713
00:27:20,670 --> 00:27:23,100
想出的是 BW 树 我

714
00:27:23,100 --> 00:27:25,560
还应该评论说他们击败了

715
00:27:25,560 --> 00:27:27,120
每一棵树，尽管它

716
00:27:27,120 --> 00:27:30,360
在我们的论文中有所描述并且有

717
00:27:30,360 --> 00:27:32,130
大多数论文至少

718
00:27:32,130 --> 00:27:33,450
讨论了来自 Microsoft 的原始 BW 论文，

719
00:27:33,450 --> 00:27:35,040
在

720
00:27:35,040 --> 00:27:37,950
上下文中作为 Emory 系统黑客马拉松中的内存系统进行了讨论

721
00:27:37,950 --> 00:27:39,330
。

722
00:27:39,330 --> 00:27:40,380
他们

723
00:27:40,380 --> 00:27:43,500
在 Microsoft 构建的名为 Deuteronomy 的项目实际上

724
00:27:43,500 --> 00:27:46,410
将内容存储在闪存上，因此

725
00:27:46,410 --> 00:27:49,140
VW 树中的 Delta 记录方法您知道

726
00:27:49,140 --> 00:27:50,910
对节点的挂起更改，这些更改

727
00:27:50,910 --> 00:27:52,110
实际上对于 Flash 环境非常有效，

728
00:27:52,110 --> 00:27:53,610
我们只是将其附加到日志中，

729
00:27:53,610 --> 00:27:56,790
但对于输入 - 内存数据库 p30

730
00:27:56,790 --> 00:27:59,130
将是一个坏主意，所以我向前跳了一步，

731
00:27:59,130 --> 00:28:01,590
但在我们深入了解细节之前，谁在这里

732
00:28:01,590 --> 00:28:02,700
阅读了论文并觉得他们

733
00:28:02,700 --> 00:28:06,030
了解 BW 树，好吧我每年都会问这个问题

734
00:28:06,030 --> 00:28:07,650
，很多人举手

735
00:28:07,650 --> 00:28:09,000
看 很难理解的硬数据结构

736
00:28:09,000 --> 00:28:10,710
有

737
00:28:10,710 --> 00:28:12,690
很多事情正在发生，这并不是

738
00:28:12,690 --> 00:28:16,110
对 BW 树复杂性的评论，

739
00:28:16,110 --> 00:28:18,690
它只是任何

740
00:28:18,690 --> 00:28:20,400
lat 树数据结构的复杂性 任何横向

741
00:28:20,400 --> 00:28:21,930
算法实际上都非常

742
00:28:21,930 --> 00:28:27,330
正确，所以 很多时候，即使

743
00:28:27,330 --> 00:28:29,550
您使用锁存器，数据结构

744
00:28:29,550 --> 00:28:32,070
的工程复杂性也可能会变慢，

745
00:28:32,070 --> 00:28:34,440
或者您

746
00:28:34,440 --> 00:28:36,300
尝试做的是我们显着减少，

747
00:28:36,300 --> 00:28:37,470
因此 你是你

748
00:28:37,470 --> 00:28:39,300
犯错误的可能性较小而且你更容易让

749
00:28:39,300 --> 00:28:41,160
其他人处理它所以现在

750
00:28:41,160 --> 00:28:43,530
对于我们系统中的 BW 我认为这就像

751
00:28:43,530 --> 00:28:45,660
五千八千行

752
00:28:45,660 --> 00:28:47,520
代码

753
00:28:47,520 --> 00:28:49,230
很少有人和我们的团队

754
00:28:49,230 --> 00:28:51,030
实际上可以 触摸它 写

755
00:28:51,030 --> 00:28:53,400
它的人就像他不像疯子一样，但

756
00:28:53,400 --> 00:28:55,980
他有点古怪，所以他写

757
00:28:55,980 --> 00:28:57,210
了每棵树的节拍传闻是他

758
00:28:57,210 --> 00:28:58,980
写信给我为我们的团队撤退他花

759
00:28:58,980 --> 00:29:02,430
了一年半的时间他写的

760
00:29:02,430 --> 00:29:06,330
在 Windows 笔记本电脑上的记事本中

761
00:29:06,330 --> 00:29:08,220
有很多是 Windows 10，但他

762
00:29:08,220 --> 00:29:10,320
修改了他的 Windows 10 使其看起来

763
00:29:10,320 --> 00:29:12,570
像 Windows 95，然后他将

764
00:29:12,570 --> 00:29:14,730
默认字体设置为 Comic Sans 并且他

765
00:29:14,730 --> 00:29:15,990
用最难的数据结构之一编写

766
00:29:15,990 --> 00:29:17,010
他在那种环境中写作，

767
00:29:17,010 --> 00:29:21,180
所以好像有很多事情发生，嗯，

768
00:29:21,180 --> 00:29:22,950
所以让我回顾

769
00:29:22,950 --> 00:29:25,050
一下主要思想的实际关键思想，然后

770
00:29:25,050 --> 00:29:26,400
我们会增加其他事情的复杂性，

771
00:29:26,400 --> 00:29:28,530
你知道我们需要做

772
00:29:28,530 --> 00:29:29,610
我们的数据 结构实际上支持真实的

773
00:29:29,610 --> 00:29:32,910
东西是的任务 ion 是为什么被称为

774
00:29:32,910 --> 00:29:35,400
BWT 让我猜猜它是在

775
00:29:35,400 --> 00:29:39,660
论文的热门词的标题中，所以

776
00:29:39,660 --> 00:29:44,400
我喜欢它是所有的热门

777
00:29:44,400 --> 00:29:45,540
词，当论文被

778
00:29:45,540 --> 00:29:48,230
写成内存 LSM 中的 lat 树时

779
00:29:48,230 --> 00:29:51,960
长结构 低声树 获取

780
00:29:51,960 --> 00:29:53,160
所有这些流行语 并将它们放入

781
00:29:53,160 --> 00:29:56,270
单个索引中 它被称为树

782
00:29:56,270 --> 00:30:01,860
你的脸真的很失望 它的

783
00:30:01,860 --> 00:30:07,080
邻居 真的很奇怪 是的

784
00:30:07,080 --> 00:30:11,040
好吧 好吧 所以两个关键想法 deltas 和

785
00:30:11,040 --> 00:30:13,680
映射表 所以他们会争辩

786
00:30:13,680 --> 00:30:17,220
说 您想再次避免缓存

787
00:30:17,220 --> 00:30:19,980
失效，就像一个

788
00:30:19,980 --> 00:30:21,210
多插槽系统，其中您有

789
00:30:21,210 --> 00:30:24,210
一堆 Numa 节点，并且 CPU 正在

790
00:30:24,210 --> 00:30:25,470
尝试更新相同的数据结构，

791
00:30:25,470 --> 00:30:29,250
以减少

792
00:30:29,250 --> 00:30:32,340
必须对它们所在的节点进行适当更改而导致的失效

793
00:30:32,340 --> 00:30:34,890
会做 Delta 记录，所以

794
00:30:34,890 --> 00:30:37,560
你在修改它们时将 Delta 记录挂起到节点

795
00:30:37,560 --> 00:30:38,640
，稍后你将

796
00:30:38,640 --> 00:30:42,720
合并它们，现在这不

797
00:30:42,720 --> 00:30:43,470
完全正确，

798
00:30:43,470 --> 00:30:44,760
因为它不会像我们实际实现它的方式那样工作

799
00:30:44,760 --> 00:30:45,870
因为我们

800
00:30:45,870 --> 00:30:47,070
实际上将 Delta 记录存储在

801
00:30:47,070 --> 00:30:48,780
笔记中，所以你仍然有缓存

802
00:30:48,780 --> 00:30:51,570
失效，但这是他们

803
00:30:51,570 --> 00:30:53,820
声称的，我们没有看到这一点，我们

804
00:30:53,820 --> 00:30:55,860
没有看到这个好处，

805
00:30:55,860 --> 00:30:57,390
另一件事是映射表和

806
00:30:57,390 --> 00:30:58,950
再次这是一个中心位置，

807
00:30:58,950 --> 00:31:01,320
您存储

808
00:31:01,320 --> 00:31:03,360
物理节点的所有地址，然后现在如果我需要

809
00:31:03,360 --> 00:31:06,150
更改逻辑地址，

810
00:31:06,150 --> 00:31:07,230
需要更改逻辑节点的物理地址，

811
00:31:07,230 --> 00:31:09,840
我只需转到我的映射

812
00:31:09,840 --> 00:31:13,110
表并更新它就可以了 所以让我们看

813
00:31:13,110 --> 00:31:14,190
一下非常简单的表 所以这里有一个

814
00:31:14,190 --> 00:31:17,400
三节点的 BW 树 所以首先要

815
00:31:17,400 --> 00:31:18,600
指出的是，我们有我们的

816
00:31:18,600 --> 00:31:20,610
映射表，每个节点都将

817
00:31:20,610 --> 00:31:22,740
被分配一个页面 ID 或我们的笔记 我

818
00:31:22,740 --> 00:31:26,520
做得很好所以页面 101 1 2 - 104 然后

819
00:31:26,520 --> 00:31:28,650
现在在我们的映射表中，我们将有

820
00:31:28,650 --> 00:31:30,900
物理指针告诉我们这些节点中

821
00:31:30,900 --> 00:31:32,730
的每一个的地址和起始地址，

822
00:31:32,730 --> 00:31:35,700
所以我将在所有这些图中用 in in 表示这一点，

823
00:31:35,700 --> 00:31:39,750


824
00:31:39,750 --> 00:31:41,790
黑色实线将 代表物理 ical

825
00:31:41,790 --> 00:31:44,280
address 和红色虚线将

826
00:31:44,280 --> 00:31:46,650
代表逻辑地址，因此在

827
00:31:46,650 --> 00:31:49,470
这种情况下，我们有根节点，

828
00:31:49,470 --> 00:31:51,960
它有两个指向其子节点的指针，

829
00:31:51,960 --> 00:31:53,640
因此我们现在唯一需要在

830
00:31:53,640 --> 00:31:56,340
该节点中存储的只是子节点的页面 ID

831
00:31:56,340 --> 00:32:00,480
102 和 104 所以现在如果任何时候我

832
00:32:00,480 --> 00:32:02,400
需要去说好吧 我正在遍历

833
00:32:02,400 --> 00:32:04,680
我的树 我在第 101 页 现在我

834
00:32:04,680 --> 00:32:06,780
需要保持到第 102 页 这

835
00:32:06,780 --> 00:32:08,430
不是我可以实际遵循的指针 我

836
00:32:08,430 --> 00:32:10,650
必须做 在我的映射表中查找

837
00:32:10,650 --> 00:32:13,260
并说哦，我想要第 102 页告诉我它的

838
00:32:13,260 --> 00:32:14,940
物理地址，然后现在我

839
00:32:14,940 --> 00:32:17,910
可以进入这个权利，你将

840
00:32:17,910 --> 00:32:19,290
拥有这个间接层，它允许

841
00:32:19,290 --> 00:32:22,890
我获取任何逻辑页面 ID 并将其

842
00:32:22,890 --> 00:32:25,920
映射到 物理地址没问题

843
00:32:25,920 --> 00:32:29,430
所以现在让我们看看当我们进行更新时

844
00:32:29,430 --> 00:32:31,530
假设我在第 102 页有一个

845
00:32:31,530 --> 00:32:34,890
页面，现在每次我

846
00:32:34,890 --> 00:32:37,020
要对页面进行更新 就像插入

847
00:32:37,020 --> 00:32:39,600
一个键 删除一个键 我们 ' 不

848
00:32:39,600 --> 00:32:41,010
担心更新密钥，

849
00:32:41,010 --> 00:32:42,690
因为那只是一个删除后跟 插入

850
00:32:42,690 --> 00:32:45,510
一切正常，所以它是领导者 再次插入，

851
00:32:45,510 --> 00:32:47,400
而不是直接在页面本身上进行更改，

852
00:32:47,400 --> 00:32:49,920
所以这只是

853
00:32:49,920 --> 00:32:51,870
另一个 这只是一个节点，就像 B 加树中的一个节点

854
00:32:51,870 --> 00:32:52,440


855
00:32:52,440 --> 00:32:54,870
我有一个键数组 一个

856
00:32:54,870 --> 00:32:57,840
值数组 它是相同的 相同的物理

857
00:32:57,840 --> 00:32:59,430
布局，但现在不是

858
00:32:59,430 --> 00:33:01,410
对这些数组进行更新，而是创建

859
00:33:01,410 --> 00:33:03,150
一个 Delta 记录，该记录说明

860
00:33:03,150 --> 00:33:05,730
我想对

861
00:33:05,730 --> 00:33:07,980
102 中表示的 quines 进行哪些更改，所以

862
00:33:07,980 --> 00:33:11,400
现在假设我想对 key key 0 进行排序，所以这个

863
00:33:11,400 --> 00:33:13,890
记录将有一个指向基页的物理指针，

864
00:33:13,890 --> 00:33:15,000


865
00:33:15,000 --> 00:33:17,730
所以我如何在

866
00:33:17,730 --> 00:33:20,070
查找和映射表时获得它，我会说

867
00:33:20,070 --> 00:33:21,390
我知道这件物理衣服将

868
00:33:21,390 --> 00:33:25,470
是 1 或 2，所以现在

869
00:33:25,470 --> 00:33:27,630
没有人可以 查看我的更改，因为如果

870
00:33:27,630 --> 00:33:29,730
有人正在查找第 102 页，他们

871
00:33:29,730 --> 00:33:31,230
会查看映射表并查看

872
00:33:31,230 --> 00:33:33,299
此指针并完全绕过我的 Delta 记录，

873
00:33:33,299 --> 00:33:35,909
所以我现在需要

874
00:33:35,909 --> 00:33:38,700
做的是安装它我要进行

875
00:33:38,700 --> 00:33:41,820
比较和交换 在映射表中

876
00:33:41,820 --> 00:33:44,700
替换 ph 它

877
00:33:44,700 --> 00:33:46,890
曾经指向现在我的实际

878
00:33:46,890 --> 00:33:49,200
地址的实际地址，现在任何人都去查看

879
00:33:49,200 --> 00:33:51,539
102 他们不会降落在这里 他们

880
00:33:51,539 --> 00:33:53,640
会降落在这里 认识到他们

881
00:33:53,640 --> 00:33:56,970
正在查看 Delta 记录并相应地对其进行评估

882
00:33:56,970 --> 00:33:58,590
，所以如果我' 我正在寻找一个

883
00:33:58,590 --> 00:34:00,780
键 0 我在这里找到了这个 Delta 记录我

884
00:34:00,780 --> 00:34:02,730
说哦插入键 0 瞧

885
00:34:02,730 --> 00:34:04,110
我完成了我找到了我正在

886
00:34:04,110 --> 00:34:05,940
寻找的东西如果我不寻找一个键

887
00:34:05,940 --> 00:34:08,250
0 那么我现在就在这里跟随

888
00:34:08,250 --> 00:34:11,219
那么现在我可以

889
00:34:11,219 --> 00:34:15,480
在基本页面的基本节点中查看我，所以这

890
00:34:15,480 --> 00:34:17,250
很清楚这就像

891
00:34:17,250 --> 00:34:18,409
他们在做什么的核心思想

892
00:34:18,409 --> 00:34:21,409
是的

893
00:34:34,980 --> 00:34:38,409
你的问题是我的问题

894
00:34:38,409 --> 00:34:40,690
就像我是否将它与这个一起存储 我打架

895
00:34:40,690 --> 00:34:52,510
是因为我没有存储它

896
00:34:52,510 --> 00:34:54,789
就像这总是最新版本

897
00:34:54,789 --> 00:34:59,260
然后如果我想说

898
00:34:59,260 --> 00:35:00,970
在此之前的版本是什么然后我

899
00:35:00,970 --> 00:35:03,490
以某种方式选择然后这

900
00:35:03,490 --> 00:35:07,839
就像 Versa insert k0 一样

901
00:35:07,839 --> 00:35:09,280
你说这就像

902
00:35:09,280 --> 00:35:10,750
你在这里所做的改变的反面 所以我的反面是什么

903
00:35:10,750 --> 00:35:14,410
nsert KZ 行它并不是真的

904
00:35:14,410 --> 00:35:17,520
删除 k0 因为它以前不存在

905
00:35:17,520 --> 00:35:19,750
然后现在会发生什么，至少

906
00:35:19,750 --> 00:35:21,640
在那种情况下，对于你的例子，我已经

907
00:35:21,640 --> 00:35:23,619
修改了这个页面，使其处于缓存

908
00:35:23,619 --> 00:35:25,329
失效状态，其他

909
00:35:25,329 --> 00:35:27,579
足以查看套接字 但也是

910
00:35:27,579 --> 00:35:28,660
另一个缓存失效，因为我

911
00:35:28,660 --> 00:35:30,549
更新了另一个内存区域，

912
00:35:30,549 --> 00:35:33,160
至少在这种情况下，我只是创建了

913
00:35:33,160 --> 00:35:35,529
这个 Delta 记录，这一天没有修改，

914
00:35:35,529 --> 00:35:38,410
所以我需要更新的唯一一种缓存引用

915
00:35:38,410 --> 00:35:42,119
就是这里的这个东西

916
00:35:45,210 --> 00:35:48,250
是的，他们是 打包在一起 是的

917
00:35:48,250 --> 00:35:58,270
，出于效率原因，我们这样做是因为您的缓存

918
00:35:58,270 --> 00:36:06,190
行是 64，但缓存行是

919
00:36:06,190 --> 00:36:07,990
64 字节，只要您更新

920
00:36:07,990 --> 00:36:10,000
的内容少于 64

921
00:36:10,000 --> 00:36:14,770
字节以上的内容就可以了，我不得不这样想

922
00:36:14,770 --> 00:36:18,599
，但我认为 这有点奇怪，

923
00:36:18,599 --> 00:36:20,859
因为你正在创造一个

924
00:36:20,859 --> 00:36:22,270
不存在的个人东西，你

925
00:36:22,270 --> 00:36:26,020
需要知道，即使在你的例子中，你也

926
00:36:26,020 --> 00:36:30,400
需要知道我正在寻找 k0 我不

927
00:36:30,400 --> 00:36:34,809
我在这里看到它我完成了 但他有什么

928
00:36:34,809 --> 00:36:37,059
没有逆转 f 或者删除

929
00:36:37,059 --> 00:36:38,619
也许你可以说好吧我

930
00:36:38,619 --> 00:36:39,490
在这里看到一些东西

931
00:36:39,490 --> 00:36:41,589
我没有看到一些东西但是它曾经

932
00:36:41,589 --> 00:36:44,020
存在过是的我

933
00:36:44,020 --> 00:36:46,119
不得不想你会不会说他很奇怪对不起

934
00:36:46,119 --> 00:36:52,059
是的所以问题是我什么时候会

935
00:36:52,059 --> 00:36:53,440
真正遵循这个 指针正确，所以

936
00:36:53,440 --> 00:36:55,869
在这一点上我已经创建了

937
00:36:55,869 --> 00:36:58,089
我创建了这个 Delta 记录，它有一个

938
00:36:58,089 --> 00:37:00,549
指向页面的物理指针，但其他人

939
00:37:00,549 --> 00:37:01,839
无法看到它，因为

940
00:37:01,839 --> 00:37:03,130
其他人都在遵循映射表，

941
00:37:03,130 --> 00:37:04,420
将您带到基页

942
00:37:04,420 --> 00:37:06,910
我做的 对此进行比较和交换，

943
00:37:06,910 --> 00:37:09,190
现在任何正在寻找第一页或第二页的人都

944
00:37:09,190 --> 00:37:11,680
在这里并不重要，

945
00:37:11,680 --> 00:37:12,789
如果您正在

946
00:37:12,789 --> 00:37:14,049
寻找第一页或第二页

947
00:37:14,049 --> 00:37:16,180
，那么您是否在寻找 k0 就在这里，然后您必须 评估

948
00:37:16,180 --> 00:37:18,609
您本质上是在重播，就像

949
00:37:18,609 --> 00:37:21,099
内存中的日志一样好说

950
00:37:21,099 --> 00:37:26,200
一两个问题中实际存储的内容是

951
00:37:26,200 --> 00:37:28,089
您拥有的记录越多实际上花费的时间越长，

952
00:37:28,089 --> 00:37:30,220
如果

953
00:37:30,220 --> 00:37:31,690
您查看基本页面，那么关键是我们” 我

954
00:37:31,690 --> 00:37:37,119
会在一秒钟内解决这个问题，是的，所以

955
00:37:37,119 --> 00:37:38,020
问题是，如果有

956
00:37:38,020 --> 00:37:40,450
并发增量更新，下一张幻灯片将如何

957
00:37:40,450 --> 00:37:44,020
处理，所以现在如果我这样做，

958
00:37:44,020 --> 00:37:45,220
让我们再做一个，如果我在这个右边做一个删除

959
00:37:45,220 --> 00:37:47,349
八个相同的东西比较和交换

960
00:37:47,349 --> 00:37:49,089
，现在这个点所以

961
00:37:49,089 --> 00:37:50,609
现在任何人来一两个

962
00:37:50,609 --> 00:37:53,230
正确的他们将不得不评估删除

963
00:37:53,230 --> 00:37:55,059
k0k日期这不是我想要的

964
00:37:55,059 --> 00:37:57,099
删除键零这不是我想要

965
00:37:57,099 --> 00:37:59,049
的然后在

966
00:37:59,049 --> 00:38:02,430
基本注释中进行搜索是的

967
00:38:02,920 --> 00:38:06,099
所以我们已经涵盖了这一点 这

968
00:38:06,099 --> 00:38:07,799
只是像 B+ 树一样进行搜索，

969
00:38:07,799 --> 00:38:11,170
如果您在 Delta 链中找到您要查找的东西，

970
00:38:11,170 --> 00:38:14,680
您就完成了，

971
00:38:14,680 --> 00:38:16,599
否则您只需

972
00:38:16,599 --> 00:38:20,500
搜索 BOP 我很好，所以让我们处理他的

973
00:38:20,500 --> 00:38:23,200
问题，现在我们 回到这里，我们已经

974
00:38:23,200 --> 00:38:25,450
安装了一个用于插入键 0 的 delta 记录

975
00:38:25,450 --> 00:38:28,510
，然后现在我有两个线程，

976
00:38:28,510 --> 00:38:29,829
他们将尝试同时停止

977
00:38:29,829 --> 00:38:32,049
Delta 记录，所以两个

978
00:38:32,049 --> 00:38:34,089
线程在索引内，

979
00:38:34,089 --> 00:38:35,500
他们说哦，我 需要执行一个

980
00:38:35,500 --> 00:38:37,180
操作，这是我想要的注释

981
00:38:37,180 --> 00:38:38,740
倒这是我想要

982
00:38:38,740 --> 00:38:41,140
执行我的操作的基本页面 所以第一个人

983
00:38:41,140 --> 00:38:43,900
想要泄漏 88 第二个我想

984
00:38:43,900 --> 00:38:47,170
泄漏密钥 6 那么这里会发生

985
00:38:47,170 --> 00:38:51,180
什么我们如何安装这些更新

986
00:38:51,599 --> 00:38:53,609
就像是的它实际上只

987
00:38:53,609 --> 00:38:55,859
在你更新时才应用是的 正确，所以他的

988
00:38:55,859 --> 00:38:58,019
说法是更新仅

989
00:38:58,019 --> 00:39:01,410
适用，并且

990
00:39:01,410 --> 00:39:04,289
只有在您知道何时更新此内容时对其他人可见，

991
00:39:04,289 --> 00:39:06,420
因此这些人现在将在映射表中的此内存位置

992
00:39:06,420 --> 00:39:08,699
上同时进行比较和交换，

993
00:39:08,699 --> 00:39:10,619


994
00:39:10,619 --> 00:39:13,349
但只有一个 可以成功，所以你

995
00:39:13,349 --> 00:39:14,670
基本上知道你在做什么，

996
00:39:14,670 --> 00:39:16,859
当你回到这里时，你知道你

997
00:39:16,859 --> 00:39:19,019
注意到物理地址是

998
00:39:19,019 --> 00:39:21,569
头部的没有记录这个节点的增量链，

999
00:39:21,569 --> 00:39:23,160
好吧，这就是这些

1000
00:39:23,160 --> 00:39:24,809
家伙的方式 这些人得到了

1001
00:39:24,809 --> 00:39:27,119
这些实体衣服，所以现在当我

1002
00:39:27,119 --> 00:39:29,009
进行比较和交换时，你说

1003
00:39:29,009 --> 00:39:31,259
这里地址的当前值是否

1004
00:39:31,259 --> 00:39:34,199
是我认为应该的值，然后

1005
00:39:34,199 --> 00:39:37,049
继续交换它并正确安装我的新更新

1006
00:39:37,049 --> 00:39:39,869
，让我们说 第一个人能够

1007
00:39:39,869 --> 00:39:43,079
正确地做到这一点，这很好，所以现在

1008
00:39:43,079 --> 00:39:45,479
他处于 Delta 向量 Delta 链的头部，

1009
00:39:45,479 --> 00:39:48,719
并且他的更新安装

1010
00:39:48,719 --> 00:39:51,150
了第二个人进行比较和

1011
00:39:51,150 --> 00:39:53,190
交换操作将失败，因为我们

1012
00:39:53,190 --> 00:39:55,380
将对映射

1013
00:39:55,380 --> 00:39:58,049
表进行评估 看到地址不是

1014
00:39:58,049 --> 00:39:59,699
它认为它要指向的地址

1015
00:39:59,699 --> 00:40:01,380
在这里记录它现在

1016
00:40:01,380 --> 00:40:03,150
指向这个地址所以它知道

1017
00:40:03,150 --> 00:40:06,479
其他人在他这样做之前进入并更新了

1018
00:40:06,479 --> 00:40:10,529
这个所以我的更新现在将失败然后

1019
00:40:10,529 --> 00:40:12,059
取决于实施 我可以

1020
00:40:12,059 --> 00:40:14,849
尝试另一个比较和交换并

1021
00:40:14,849 --> 00:40:17,729
尝试更新它，或者我可以重复

1022
00:40:17,729 --> 00:40:19,349
并执行整个操作向下遍历

1023
00:40:19,349 --> 00:40:38,729
并再次尝试你说如果我

1024
00:40:38,729 --> 00:40:49,219
现在尝试比较和交换是的是的

1025
00:40:52,190 --> 00:40:56,579
所以我可以做什么 我是不是接受了这个

1026
00:40:56,579 --> 00:41:00,380
现在就在这里可见的指向

1027
00:41:01,450 --> 00:41:04,900
这个所以他们所以如果你在这里

1028
00:41:04,900 --> 00:41:07,750
比较和交换成功案例比较

1029
00:41:07,750 --> 00:41:10,270
看到它感觉所以现在我可以回到

1030
00:41:10,270 --> 00:41:11,710
墙内只是失败现在那里的东西

1031
00:41:11,710 --> 00:41:21,970
没有 号码副本 但就像这件事

1032
00:41:21,970 --> 00:41:23,440
总是会指向

1033
00:41:23,440 --> 00:41:24,490
任何没有记录天才正确的维珍链的头部

1034
00:41:24,490 --> 00:41:34,359
我只是去看看

1035
00:41:34,359 --> 00:41:35,950
再看看你可以这样

1036
00:41:35,950 --> 00:41:37,089
做我认为我们不会那样实施

1037
00:41:37,089 --> 00:41:38,530
因为出于安全原因 因为

1038
00:41:38,530 --> 00:41:41,680
就像你现在不知道这个东西

1039
00:41:41,680 --> 00:41:42,940
可能会进行拆分一样你正在

1040
00:41:42,940 --> 00:41:43,900
寻找的东西可能不再

1041
00:41:43,900 --> 00:41:46,450
封装在这个索引或这里的注释中

1042
00:41:46,450 --> 00:41:48,490
我可能已经进行了拆分

1043
00:41:48,490 --> 00:41:51,369
，现在我们是 k-  6 不

1044
00:41:51,369 --> 00:41:53,079
应该是第一页或第二页 H 现在意味着另一

1045
00:41:53,079 --> 00:42:23,290
页，当是

1046
00:42:23,290 --> 00:42:25,420


1047
00:42:25,420 --> 00:42:27,760


1048
00:42:27,760 --> 00:42:30,490


1049
00:42:30,490 --> 00:42:32,020
时 结构我们不必

1050
00:42:32,020 --> 00:42:34,180
担心事务的更高级别的一致性

1051
00:42:34,180 --> 00:42:36,910
问题，就像我

1052
00:42:36,910 --> 00:42:38,859
想也许我们可能会说

1053
00:42:38,859 --> 00:42:40,869
如果一个事务删除 k-8 并且

1054
00:42:40,869 --> 00:42:42,609
我尝试插入它或者我会 有点

1055
00:42:42,609 --> 00:42:44,619
阅读它，它已被删除所有

1056
00:42:44,619 --> 00:42:47,170
在上面处理的 我想要么

1057
00:42:47,170 --> 00:42:49,030
这样做 重新运行扫描 正在

1058
00:42:49,030 --> 00:42:50,650
做所有在我们上面处理的验证工作

1059
00:42:50,650 --> 00:42:52,079
我们只关心数据结构的

1060
00:42:52,079 --> 00:42:54,579
低级别线性化能力

1061
00:42:54,579 --> 00:42:56,230
正确性，这件事

1062
00:42:56,230 --> 00:42:59,670
会为我们处理 是的，

1063
00:43:03,010 --> 00:43:04,780
您目前正在访问该

1064
00:43:04,780 --> 00:43:06,820
案例 与你不同 再次了解每项

1065
00:43:06,820 --> 00:43:09,400
研究 我的意思是我真的不

1066
00:43:09,400 --> 00:43:11,050
明白你为什么

1067
00:43:11,050 --> 00:43:14,250
担心它的重点 众所周知，第 102 页

1068
00:43:14,250 --> 00:43:16,210
就像我们必须从头

1069
00:43:16,210 --> 00:43:18,490
开始那样，如何

1070
00:43:18,490 --> 00:43:26,890
传播才能确保 嗯，当我说 Inc

1071
00:43:26,890 --> 00:43:30,970
使用 Cu 时，它

1072
00:43:30,970 --> 00:43:32,530
与我正在尝试插入

1073
00:43:32,530 --> 00:43:34,690
某些内容并尝试启动一个

1074
00:43:34,690 --> 00:43:37,240
未

1075
00:43:37,240 --> 00:43:39,070
表示或不应存储在

1076
00:43:39,070 --> 00:43:42,970
此的逻辑键有关 这个位置在这里所以如果现在

1077
00:43:42,970 --> 00:43:44,800
关键六不应该在第一页或第二

1078
00:43:44,800 --> 00:43:46,540
页应该是第103页如果我尝试

1079
00:43:46,540 --> 00:43:47,590
立即回来并在这里做平等的

1080
00:43:47,590 --> 00:43:49,390
父母WAP我现在开始

1081
00:43:49,390 --> 00:43:52,090
进入这个页面的关键六但是其他任何

1082
00:43:52,090 --> 00:43:53,440
寻找关键的人 六个它' 不会躺在

1083
00:43:53,440 --> 00:43:54,820
这里，他们会遵循指南

1084
00:43:54,820 --> 00:43:56,770
和 lanú 的母节点，他们

1085
00:43:56,770 --> 00:43:59,940
会有一个假的假阴性

1086
00:44:01,000 --> 00:44:04,119
[音乐]

1087
00:44:08,100 --> 00:44:10,119
我如何确保我降落在

1088
00:44:10,119 --> 00:44:11,109
这里我应该是对的，是的，因为

1089
00:44:11,109 --> 00:44:13,330
那只是 我的意思是因为

1090
00:44:13,330 --> 00:44:16,630
我们正在使用键强制执行

1091
00:44:16,630 --> 00:44:18,340


1092
00:44:18,340 --> 00:44:19,600
从左到右从一个节点到下一个

1093
00:44:19,600 --> 00:44:22,150
右侧的方向的顺序，因此我们

1094
00:44:22,150 --> 00:44:23,619
保证我们正在

1095
00:44:23,619 --> 00:44:26,140
传播来自 从底部到顶部，这样

1096
00:44:26,140 --> 00:44:27,700
你就不会处于这种奇怪的状态，

1097
00:44:27,700 --> 00:44:28,840
就像有东西指向

1098
00:44:28,840 --> 00:44:30,369
你不应该存在的东西，或者某些

1099
00:44:30,369 --> 00:44:31,119
东西被存储在

1100
00:44:31,119 --> 00:44:32,740
不应该存在的地方，但总是从顶部重新启动

1101
00:44:32,740 --> 00:44:34,810
它是低效的，这是排序

1102
00:44:34,810 --> 00:44:36,730
这是横向数据结构的缺点，

1103
00:44:36,730 --> 00:44:38,320
但我们保证数据结构在物理层面上

1104
00:44:38,320 --> 00:44:40,359
的孩子辅助 II 的正确性，

1105
00:44:40,359 --> 00:44:43,180


1106
00:44:43,180 --> 00:44:49,570
所以现在到他之前的

1107
00:44:49,570 --> 00:44:51,190
问题，并且希望这个

1108
00:44:51,190 --> 00:44:54,130
Delta 链不能变得很长 是的，它会

1109
00:44:54,130 --> 00:44:56,530
并且 所以我们想要进行整合 所以

1110
00:44:56,530 --> 00:44:59,260
基本上会发生的事情是一个

1111
00:44:59,260 --> 00:45:01,150
线程会认识到它

1112
00:45:01,150 --> 00:45:02,680
沿着这条 Delta 链走得太长了

1113
00:45:02,680 --> 00:45:04,480
这可能就像一个

1114
00:45:04,480 --> 00:45:05,800
阈值 你说如果 Delta 链

1115
00:45:05,800 --> 00:45:08,260
比这些数字

1116
00:45:08,260 --> 00:45:09,730
记录更多 我想要一个可靠的

1117
00:45:09,730 --> 00:45:11,410
ation 所以你要做的就是

1118
00:45:11,410 --> 00:45:14,380
首先制作一个基本页面的副本

1119
00:45:14,380 --> 00:45:14,970


1120
00:45:14,970 --> 00:45:17,339
，然后现在你要以

1121
00:45:17,339 --> 00:45:21,240


1122
00:45:21,240 --> 00:45:23,760
我们带我们的 Delta 链的相反顺序应用更改 为什么你

1123
00:45:23,760 --> 00:45:27,990
做相反的顺序，

1124
00:45:27,990 --> 00:45:31,740
就像这样的顺序就像在物理时间

1125
00:45:31,740 --> 00:45:33,630
要进行的更改就像这是

1126
00:45:33,630 --> 00:45:35,430
最旧的更改，这将

1127
00:45:35,430 --> 00:45:37,799
是最新的更改，所以如果我说

1128
00:45:37,799 --> 00:45:42,809
如果我要删除 k-8 在这里，我在这里插入

1129
00:45:42,809 --> 00:45:45,270
k-8 然后

1130
00:45:45,270 --> 00:45:46,380
如果我朝这个方向前进，它是否有意义或尝试删除某些东西，

1131
00:45:46,380 --> 00:45:47,609
所以我们总是以相反的顺序前进，

1132
00:45:47,609 --> 00:45:49,980
所以基本上它会在

1133
00:45:49,980 --> 00:45:52,049
我扫描并识别这个深度时

1134
00:45:52,049 --> 00:45:53,579
变化太久了我有

1135
00:45:53,579 --> 00:45:55,680
所有这些的副本 现在我可以

1136
00:45:55,680 --> 00:45:57,450
以相反的顺序一一重放它们，

1137
00:45:57,450 --> 00:46:01,109
所以现在在我重放所有

1138
00:46:01,109 --> 00:46:04,760
更改之后，这个节点的新副本

1139
00:46:04,760 --> 00:46:06,990


1140
00:46:06,990 --> 00:46:09,390
代表了这个基页代表的所有相同的东西，它

1141
00:46:09,390 --> 00:46:12,150
在他的牙科记录中，所以怎么做 我

1142
00:46:12,150 --> 00:46:16,230
现在安装它命令交换很简单，

1143
00:46:16,230 --> 00:46:18,089
我现在需要返回的只是比较

1144
00:46:18,089 --> 00:46:21,779
并交换到这个这里作为记录

1145
00:46:21,779 --> 00:46:24,809
这里的条目这里是 102 现在

1146
00:46:24,809 --> 00:46:26,640


1147
00:46:26,640 --> 00:46:28,890
如果我失败了，其他任何人都可以看到我然后我浪费了我的工作 已经完成了

1148
00:46:28,890 --> 00:46:30,180
我的合并，其他人做了

1149
00:46:30,180 --> 00:46:31,260
一些改变，比如

1150
00:46:31,260 --> 00:46:33,839
在我得到我的比较和交换之前，如果其他人附加了一个新的 Delta 记录，

1151
00:46:33,839 --> 00:46:36,690


1152
00:46:36,690 --> 00:46:38,010
那么这就解决了

1153
00:46:38,010 --> 00:46:39,779
看不到你知道可能会丢失

1154
00:46:39,779 --> 00:46:42,329
一个不记录更新的问题，因为 现在这

1155
00:46:42,329 --> 00:46:43,440
件事会指向一个

1156
00:46:43,440 --> 00:46:45,119
我没有看到的新 Delta 记录，因此我

1157
00:46:45,119 --> 00:46:48,680
扔掉了我的工作并开始了是的

1158
00:46:49,490 --> 00:46:52,690
[音乐]

1159
00:46:53,920 --> 00:46:58,280
它称之为虚拟月亮是的它

1160
00:46:58,280 --> 00:47:00,800
只是在高温它就像一首

1161
00:47:00,800 --> 00:47:03,170
没有人的颂歌 否则ca  n 看到了它

1162
00:47:03,170 --> 00:47:05,210
就像只有我的线程在做

1163
00:47:05,210 --> 00:47:17,630
整合可以看到它是的这个

1164
00:47:17,630 --> 00:47:19,670
问题是为什么我不

1165
00:47:19,670 --> 00:47:21,230
这样做而不是比较解决这个

1166
00:47:21,230 --> 00:47:22,790
为什么我不把所有这些东西

1167
00:47:22,790 --> 00:47:31,760
应用到这个你 想想你

1168
00:47:31,760 --> 00:47:33,140
为什么没有这些 Delta 记录

1169
00:47:33,140 --> 00:47:35,869
想要再次在此处应用此更改，

1170
00:47:35,869 --> 00:47:40,670
他们是在争辩说，

1171
00:47:40,670 --> 00:47:44,359
如果我

1172
00:47:44,359 --> 00:47:45,890
不允许任何人在此处进行任何更改，

1173
00:47:45,890 --> 00:47:50,440
您仍然需要正确的闩锁以使其自由锁定

1174
00:47:50,440 --> 00:47:52,580
因为这些东西必须

1175
00:47:52,580 --> 00:47:53,900
被排序，你必须部署闩锁

1176
00:47:53,900 --> 00:47:55,339
来尝试像你知道的那样强制

1177
00:47:55,339 --> 00:47:57,349
对它们进行排序，所以他们试图

1178
00:47:57,349 --> 00:48:05,089
完全是拉里，是的这个问题

1179
00:48:05,089 --> 00:48:06,560
是你的闩锁中的比较，我们将在

1180
00:48:06,560 --> 00:48:07,580
接下来讨论这个 你

1181
00:48:07,580 --> 00:48:10,790
能用clear和swap来实现闩锁吗，

1182
00:48:10,790 --> 00:48:13,820
就像我持有的那样，我

1183
00:48:13,820 --> 00:48:16,310
在某个关键部分持有闩锁

1184
00:48:16,310 --> 00:48:21,260
，我做了很多事情，所以这

1185
00:48:21,260 --> 00:48:23,960
就像我现在申请的一个更新一样

1186
00:48:23,960 --> 00:48:26,510
' 如果它是一个自旋闩锁 wh 就对了

1187
00:48:26,510 --> 00:48:33,890
你在旋转所以我可以

1188
00:48:33,890 --> 00:48:38,380
不 是的

1189
00:48:55,490 --> 00:48:59,270
不 你让它自由闩锁 是的 如果你

1190
00:48:59,270 --> 00:49:01,070
不想让闩锁自由 那么就像

1191
00:49:01,070 --> 00:49:03,589
你拿闩锁一样 做更新 是的 然后

1192
00:49:03,589 --> 00:49:04,500
你有一个 B+ 树

1193
00:49:04,500 --> 00:49:08,340
是的，就像 如果你每次尝试

1194
00:49:08,340 --> 00:49:10,290
重新计算这个像合并的笔记

1195
00:49:10,290 --> 00:49:12,030
是的祈祷，让我们看看回去

1196
00:49:12,030 --> 00:49:14,010
比较和交换你失败了我

1197
00:49:14,010 --> 00:49:15,330
不一定认为你真的

1198
00:49:15,330 --> 00:49:16,410
把所有的工作都扔掉了，因为

1199
00:49:16,410 --> 00:49:17,580
你基本上可以阅读所有这些新

1200
00:49:17,580 --> 00:49:19,349
链 然后看看你

1201
00:49:19,349 --> 00:49:20,760
在最后一句话中的变化，然后

1202
00:49:20,760 --> 00:49:22,380
更新比较这一点我

1203
00:49:22,380 --> 00:49:24,330
准备交换自己，如果你是

1204
00:49:24,330 --> 00:49:26,070
对的，如果这只是一个插入，你

1205
00:49:26,070 --> 00:49:28,170
可以说好吧，我错过了它，只是把

1206
00:49:28,170 --> 00:49:30,450
它放进去然后尝试 再说一次 我不

1207
00:49:30,450 --> 00:49:31,910
认为我们这样做 我认为我们会谨慎行事

1208
00:49:31,910 --> 00:49:33,869
因为如果您进行拆分或

1209
00:49:33,869 --> 00:49:35,849
合并 这就是为什么这就是

1210
00:49:35,849 --> 00:49:41,970
事情变得糟糕时

1211
00:49:41,970 --> 00:49:43,980


1212
00:49:43,980 --> 00:49:45,330
的原因 坐在一起我们需要

1213
00:49:45,330 --> 00:49:47,520
做什么，你不会吗？ 显然

1214
00:49:47,520 --> 00:49:48,780
想在某个时候把它清理干净，

1215
00:49:48,780 --> 00:49:50,700
这样这些东西就可以被标记为垃圾

1216
00:49:50,700 --> 00:49:52,260
，在某个时候我们需要清理它们

1217
00:49:52,260 --> 00:49:54,060
，这

1218
00:49:54,060 --> 00:49:55,650
看起来像什么 一旦我们

1219
00:49:55,650 --> 00:49:56,790
意识到某些东西不再

1220
00:49:56,790 --> 00:49:58,830
可见

1221
00:49:58,830 --> 00:50:01,500
MVCC 世界中的一堆线程或事务然后我们想

1222
00:50:01,500 --> 00:50:02,790
继续清理它并重

1223
00:50:02,790 --> 00:50:06,359
用内存所以现在看起来

1224
00:50:06,359 --> 00:50:09,450
有点不同虽然

1225
00:50:09,450 --> 00:50:10,260
与我们之前讨论的略有不同

1226
00:50:10,260 --> 00:50:12,000
但是高/低的想法正在发生

1227
00:50:12,000 --> 00:50:14,730
是一样的好吧那么

1228
00:50:14,730 --> 00:50:15,900
对于这些内存

1229
00:50:15,900 --> 00:50:17,310
数据结构的垃圾收集是什么我们是

1230
00:50:17,310 --> 00:50:19,380
什么问题很好我们不想

1231
00:50:19,380 --> 00:50:21,990
扔掉某些人可能正在

1232
00:50:21,990 --> 00:50:23,700
阅读的东西因为那样他们就会

1233
00:50:23,700 --> 00:50:25,349
有一个段 错误，因为读取你

1234
00:50:25,349 --> 00:50:27,660
知道未分配的内存，所以说我

1235
00:50:27,660 --> 00:50:29,670
想在这里删除 k2，这是一个

1236
00:50:29,670 --> 00:50:31,020
简单的单方向链表，

1237
00:50:31,020 --> 00:50:33,720
我的线程在这里，它是关键，

1238
00:50:33,720 --> 00:50:35,520
它现在看到物理指针

1239
00:50:35,520 --> 00:50:37,650
指向 下一个键然后垃圾捕获

1240
00:50:37,650 --> 00:50:40,020
进来清理这个东西但是现在我

1241
00:50:40,020 --> 00:50:41,700
按照这个指针只是一些随机

1242
00:50:41,700 --> 00:50:44,040
无效你知道你的会员

1243
00:50:44,040 --> 00:50:46,550
礼服不再意味着任何东西

1244
00:50:46,550 --> 00:50:48,780
你知道最坏的情况我说秋天

1245
00:50:48,780 --> 00:50:50,280
实际上值得追逐他们 也喜欢

1246
00:50:50,280 --> 00:50:51,540
我可以阅读垃圾并认为它

1247
00:50:51,540 --> 00:50:54,030
是正确的所以我们想避免

1248
00:50:54,030 --> 00:50:56,730
这种情况所以我们将

1249
00:50:56,730 --> 00:50:58,080
讨论我们的引用计数的两种方法

1250
00:50:58,080 --> 00:50:59,940
基于时代的回收 还有很多

1251
00:50:59,940 --> 00:51:03,500
其他技术可以使用危险

1252
00:51:03,500 --> 00:51:06,060
指针 另一个我忘记了

1253
00:51:06,060 --> 00:51:07,320
忘记它们的名字确实很重要，就像

1254
00:51:07,320 --> 00:51:09,210
还有其他事情一样，这两个

1255
00:51:09,210 --> 00:51:11,099


1256
00:51:11,099 --> 00:51:15,300
是内存数据库中最突出最常见的，因此引用

1257
00:51:15,300 --> 00:51:16,349
计数本质上是您在标准模板

1258
00:51:16,349 --> 00:51:17,670
上使用 Unruh Steven Plus 上的共享指针所获得的

1259
00:51:17,670 --> 00:51:17,940


1260
00:51:17,940 --> 00:51:19,829
库，

1261
00:51:19,829 --> 00:51:22,920
所以现在只是

1262
00:51:22,920 --> 00:51:24,450
在数据结构中的每个节点内部或在

1263
00:51:24,450 --> 00:51:25,710
SharePoint 内部

1264
00:51:25,710 --> 00:51:27,810
指向指针数据结构本身，我们只是

1265
00:51:27,810 --> 00:51:29,910
要 m  aintain 一个计数器来跟踪

1266
00:51:29,910 --> 00:51:32,130


1267
00:51:32,130 --> 00:51:34,230
可以访问

1268
00:51:34,230 --> 00:51:36,750
我在访问之前插入的内存位置的线程数

1269
00:51:36,750 --> 00:51:38,760
我增加了

1270
00:51:38,760 --> 00:51:40,530
原子添加权限的计数器，这就是该部分的

1271
00:51:40,530 --> 00:51:42,510
效率，但是当我完成后

1272
00:51:42,510 --> 00:51:44,579
你知道 访问它然后我

1273
00:51:44,579 --> 00:51:46,440
将该计数器减一，

1274
00:51:46,440 --> 00:51:48,839
这样垃圾收集器就会知道当我们知道

1275
00:51:48,839 --> 00:51:51,450
我们的计数器为零时释放某些内存区域是安全的，

1276
00:51:51,450 --> 00:51:53,730


1277
00:51:53,730 --> 00:51:55,290
因为我们知道

1278
00:51:55,290 --> 00:51:56,940
只要每个人都更新，就没有线程可以查看它

1279
00:51:56,940 --> 00:51:58,500
那个 Conn 在他们

1280
00:51:58,500 --> 00:52:00,810
跳转到下一个位置之前，我们不会

1281
00:52:00,810 --> 00:52:03,300
有问题，虽然

1282
00:52:03,300 --> 00:52:04,650
这实际上对性能来说真的很糟糕，

1283
00:52:04,650 --> 00:52:07,920
因为现在我可能

1284
00:52:07,920 --> 00:52:09,329
每次跳转到一个新

1285
00:52:09,329 --> 00:52:11,160
位置时我都会增加这个计数器

1286
00:52:11,160 --> 00:52:12,960
这是一个全局计数器，

1287
00:52:12,960 --> 00:52:14,010
每个人都需要能够

1288
00:52:14,010 --> 00:52:15,569
读写所以如果我有很多当然有

1289
00:52:15,569 --> 00:52:17,220
很多套接字这是一个缓存失效

1290
00:52:17,220 --> 00:52:19,109
消息给每个人只是为了去阅读

1291
00:52:19,109 --> 00:52:26,010
一些东西是的 e 特别是这个

1292
00:52:26,010 --> 00:52:27,359
失效也适用于

1293
00:52:27,359 --> 00:52:33,480
更新地图时一般是的，但我可以

1294
00:52:33,480 --> 00:52:34,680
读取映射表而无需

1295
00:52:34,680 --> 00:52:37,079
更新这将每次读取都变为

1296
00:52:37,079 --> 00:52:43,050
写入这是错误的，所以这又

1297
00:52:43,050 --> 00:52:46,740
是您获得并共享的指针，这是

1298
00:52:46,740 --> 00:52:48,510
您知道的 这显然会很慢

1299
00:52:48,510 --> 00:52:51,119
所以要指出的一件显而易见的事情

1300
00:52:51,119 --> 00:52:54,780
是我们实际上并不关心那个

1301
00:52:54,780 --> 00:52:57,200
计数器实际上是什么值

1302
00:52:57,200 --> 00:52:59,700
实际上我们真正关心的是它是否是

1303
00:52:59,700 --> 00:53:03,990
非零对所以它是否是 1 2 4

1304
00:53:03,990 --> 00:53:05,730
不管谁在乎我们知道某人的

1305
00:53:05,730 --> 00:53:07,319
阅读它我们不能装东西它

1306
00:53:07,319 --> 00:53:09,990
只有当它是 0 我们真的

1307
00:53:09,990 --> 00:53:11,849
关心所以也许不是

1308
00:53:11,849 --> 00:53:15,540
在我们的数据结构中每个节点存储这个细粒度计数器，

1309
00:53:15,540 --> 00:53:17,790
我们可以尝试

1310
00:53:17,790 --> 00:53:19,800
跟踪更高级别的合同更

1311
00:53:19,800 --> 00:53:22,200
粗略 -粒度计数器并且只

1312
00:53:22,200 --> 00:53:24,540
知道当

1313
00:53:24,540 --> 00:53:27,390
在某个时间范围内任何人都看不到任何东西时，

1314
00:53:27,390 --> 00:53:29,250
就像 MVC 看到的那样，我们可以安全地

1315
00:53:29,250 --> 00:53:30,430
继续进行推广，

1316
00:53:30,430 --> 00:53:33,640
所以这就是 EPA epoch base

1317
00:53:33,640 --> 00:53:35,770
gr  abber 选择是，我们简要

1318
00:53:35,770 --> 00:53:38,710
提到了最后一堂课，我说

1319
00:53:38,710 --> 00:53:40,150
我将花比今天更多的时间，

1320
00:53:40,150 --> 00:53:42,430
但我们再次

1321
00:53:42,430 --> 00:53:44,020
为 epoch base Copper collection 所做的 msec 的高级想法在

1322
00:53:44,020 --> 00:53:45,849
这里是相同的，

1323
00:53:45,849 --> 00:53:48,339
所以我就是这个 全局计数器，我

1324
00:53:48,339 --> 00:53:50,500
定期更新，就像你可以让一个

1325
00:53:50,500 --> 00:53:52,349
线程

1326
00:53:52,349 --> 00:53:54,970
每 10 毫秒执行一次或合作协作

1327
00:53:54,970 --> 00:53:57,010


1328
00:53:57,010 --> 00:53:59,680
，我们现在唯一需要在我们的索引中跟踪的是

1329
00:53:59,680 --> 00:54:02,619
在给定的 POC 中存在哪些线程我

1330
00:54:02,619 --> 00:54:04,329
什么时候去 他们有没有出现你流行的东西

1331
00:54:04,329 --> 00:54:06,160
他们出现然后他们什么时候

1332
00:54:06,160 --> 00:54:10,240
离开 我不在乎你口袋

1333
00:54:10,240 --> 00:54:11,829
里他们留下了什么 我关心

1334
00:54:11,829 --> 00:54:14,349
的是他们确实离开了所以我可以

1335
00:54:14,349 --> 00:54:17,170
出现一个时代然后我 离开时代 -

1336
00:54:17,170 --> 00:54:18,609
这很好，但我仍然只

1337
00:54:18,609 --> 00:54:22,240
被认为是一个时代，然后

1338
00:54:22,240 --> 00:54:24,130
现在会发生的是，当我们进行

1339
00:54:24,130 --> 00:54:26,500
整合时，我们会说

1340
00:54:26,500 --> 00:54:31,119
这个节点

1341
00:54:31,119 --> 00:54:32,980
的当前时代是什么，或者当前的时代是什么 B but B

1342
00:54:32,980 --> 00:54:33,730
EE

1343
00:54:33,730 --> 00:54:35,980
我标记那个垃圾 那个时代，

1344
00:54:35,980 --> 00:54:37,809
然后一旦我知道没有威胁

1345
00:54:37,809 --> 00:54:40,690
，我们可能会看到那个节点，因为

1346
00:54:40,690 --> 00:54:42,640
它们不再在那个时代，然后

1347
00:54:42,640 --> 00:54:45,220
我可以安全地继续删除它，将

1348
00:54:45,220 --> 00:54:48,790
其删除，因此在 Linux 中，这称为

1349
00:54:48,790 --> 00:54:50,890
我们的 Cu 重新复制更新 这在内核内部的

1350
00:54:50,890 --> 00:54:52,480
各种不同的数据结构中使用，

1351
00:54:52,480 --> 00:54:55,240
以

1352
00:54:55,240 --> 00:54:56,799
阅读系统论文，他们将

1353
00:54:56,799 --> 00:54:58,329
其称为我们在数据库论文中的 Cu 我们已经

1354
00:54:58,329 --> 00:54:59,980
听说过这个基于 epoch 的垃圾

1355
00:54:59,980 --> 00:55:03,190
收集，所以现在再次执行此操作

1356
00:55:03,190 --> 00:55:04,540
，然后执行此操作 只是重复我

1357
00:55:04,540 --> 00:55:06,880
说的话 但每棵树我们再次标记

1358
00:55:06,880 --> 00:55:08,589
了我们要做的所有搜索

1359
00:55:08,589 --> 00:55:10,750
插入或删除都标记了我

1360
00:55:10,750 --> 00:55:13,780
当前的时代

1361
00:55:13,780 --> 00:55:15,490
当一个线程出现时我们向垃圾收集器注册

1362
00:55:15,490 --> 00:55:17,559
说你知道我正在出现并且 然后做

1363
00:55:17,559 --> 00:55:19,690
一些我在这个时代的事情然后

1364
00:55:19,690 --> 00:55:21,490
当你离开你注册

1365
00:55:21,490 --> 00:55:22,750
然后垃圾收集可以说我

1366
00:55:22,750 --> 00:55:24,400
知道没有其他人在这个时代这是

1367
00:55:24,400 --> 00:55:26,319
那个时代的一堆垃圾让我

1368
00:55:26,319 --> 00:55:29,290
继续删除它所以让我们 看 在

1369
00:55:29,290 --> 00:55:30,339
此示例中，这

1370
00:55:30,339 --> 00:55:32,140
与我们在获得切割之前的情况相同，我们

1371
00:55:32,140 --> 00:55:35,440
将在 102 上进行合并，因此

1372
00:55:35,440 --> 00:55:38,020
CPU 1 线程 1 将执行此

1373
00:55:38,020 --> 00:55:41,200
合并，因此当它

1374
00:55:41,200 --> 00:55:42,670
一开始出现时它刚刚注册

1375
00:55:42,670 --> 00:55:43,809
有了这个纪元表，垃圾

1376
00:55:43,809 --> 00:55:44,290
收集器

1377
00:55:44,290 --> 00:55:46,060
就可以了，现在还有一些其他

1378
00:55:46,060 --> 00:55:48,310
线程线程 - 好吧，它会

1379
00:55:48,310 --> 00:55:51,550
同时扫描它，所以我们

1380
00:55:51,550 --> 00:55:52,630
注册了纪元表，所以现在

1381
00:55:52,630 --> 00:55:54,250
我们现在进行比较和交换

1382
00:55:54,250 --> 00:55:58,780
以更新 102 现在

1383
00:55:58,780 --> 00:56:02,260
，在这一点之后进来的其他人将永远不会看到

1384
00:56:02,260 --> 00:56:04,870
这个原始的东西，但是这里的这个线程

1385
00:56:04,870 --> 00:56:07,210
仍然悬而未决我们实际上不

1386
00:56:07,210 --> 00:56:08,670
知道它在哪里它可能

1387
00:56:08,670 --> 00:56:10,570
在数据结构内的任何地方寻找任何

1388
00:56:10,570 --> 00:56:13,540
节点，但它可能在 在这里

1389
00:56:13,540 --> 00:56:15,490
，而不是准确地跟踪你知道

1390
00:56:15,490 --> 00:56:17,140
我在看什么，或者

1391
00:56:17,140 --> 00:56:18,460
Delta 而不是

1392
00:56:18,460 --> 00:56:20,080
每次我们只是说嘿

1393
00:56:20,080 --> 00:56:23,560
，在这段时间内你知道周围有人，所以

1394
00:56:23,560 --> 00:56:26,140
现在我们用它注册了这些垃圾

1395
00:56:26,140 --> 00:56:29,350
nd 但是然后在第一个纪元这个

1396
00:56:29,350 --> 00:56:32,110
人消失了，我们 D 注册这个

1397
00:56:32,110 --> 00:56:33,880
人的扫描，然后当他

1398
00:56:33,880 --> 00:56:35,190
在第 102 页找到他正在寻找的任何东西

1399
00:56:35,190 --> 00:56:37,630
时，然后当他完成后

1400
00:56:37,630 --> 00:56:40,780
，我们可以安全地继续删除这个权利，

1401
00:56:40,780 --> 00:56:42,730
所以相反 实际上给每个节点

1402
00:56:42,730 --> 00:56:44,080
一个时间戳或时间戳上的每个 Delta 记录

1403
00:56:44,080 --> 00:56:46,300
就像 MVC 看到我们只有

1404
00:56:46,300 --> 00:56:55,270
这个合唱奶奶盒是的时代

1405
00:56:55,270 --> 00:56:57,040
给了我们意味着

1406
00:56:57,040 --> 00:57:01,060
数据结构的整个实例它只是

1407
00:57:01,060 --> 00:57:03,850
它只是一个指向

1408
00:57:03,850 --> 00:57:07,120
这个节点的物理地址在这里所以这

1409
00:57:07,120 --> 00:57:10,450
说好如果我在这里注册这个

1410
00:57:10,450 --> 00:57:12,820
垃圾我实际上并没有

1411
00:57:12,820 --> 00:57:14,020
复制这个我们正在存储

1412
00:57:14,020 --> 00:57:15,820
指向它的头部的指针有记录

1413
00:57:15,820 --> 00:57:18,370
链所以然后我知道 有任何

1414
00:57:18,370 --> 00:57:20,200
疑问 记录和基表基

1415
00:57:20,200 --> 00:57:23,670
页本身可以再次被垃圾收集

1416
00:57:24,150 --> 00:57:26,740
没有人永远不能跳到

1417
00:57:26,740 --> 00:57:27,790
这里，因为我们在这里进行了比较和交换

1418
00:57:27,790 --> 00:57:29,650
，我们能够让您知道，现在

1419
00:57:29,650 --> 00:57:34,630
指向新页面是的，您的 问题 n

1420
00:57:34,630 --> 00:57:36,310
是边缘线程的数据结构是什么，

1421
00:57:36,310 --> 00:57:40,080
它只是一个提示

1422
00:57:40,950 --> 00:57:43,450
数组，就像它可能是指向提示的数组一样，

1423
00:57:43,450 --> 00:57:44,650
因为您可以在

1424
00:57:44,650 --> 00:57:47,950
各个时期中循环，是的，这可能是一个瓶颈，

1425
00:57:47,950 --> 00:57:50,860
但遍历索引本身

1426
00:57:50,860 --> 00:57:54,030
比这更昂贵 是的，

1427
00:57:59,270 --> 00:58:06,660
所以我们回到了这里，我们在这里，所以如果

1428
00:58:06,660 --> 00:58:08,700
其他人在我们进行压缩时在这里创建了一个新的 Delta 记录

1429
00:58:08,700 --> 00:58:10,500


1430
00:58:10,500 --> 00:58:11,520
怎么办 当我进行比较和交换时会发生什么

1431
00:58:11,520 --> 00:58:14,430
我会失败，因为它现在

1432
00:58:14,430 --> 00:58:16,049
指向现在一些处理

1433
00:58:16,049 --> 00:58:17,819
在上面记录我没有看到的，这

1434
00:58:17,819 --> 00:58:19,460
就是我对他说的，就像你可能

1435
00:58:19,460 --> 00:58:21,930
很聪明地说哦，好吧，这只是

1436
00:58:21,930 --> 00:58:25,380
另一个插入，让我重新应用它，

1437
00:58:25,380 --> 00:58:28,710
然后进行比较并交换

1438
00:58:28,710 --> 00:58:30,030
那个你基本上会添加的，如果你 '正在

1439
00:58:30,030 --> 00:58:31,170
努力弄清楚我

1440
00:58:31,170 --> 00:58:32,160
有什么以及我错过了什么

1441
00:58:32,160 --> 00:58:33,660
所以这只是一个也许这不是什么

1442
00:58:33,660 --> 00:58:34,950
大不了的事但它是一堆

1443
00:58:34,950 --> 00:58:36,270
你可能只是

1444
00:58:36,270 --> 00:58:38,609
重新启动但再次比较和

1445
00:58:38,609 --> 00:58:40,049
交换因为 这个映射表

1446
00:58:40,049 --> 00:58:41,819
保证 这件事总是

1447
00:58:41,819 --> 00:58:44,309
会像正确的指针应该是什么的基本事实一样，

1448
00:58:44,309 --> 00:58:45,839


1449
00:58:45,839 --> 00:58:47,790
所以这不是我们认为的那样，这

1450
00:58:47,790 --> 00:58:49,410
是其他人在我们做得还不错之前已经进入的事情

1451
00:58:49,410 --> 00:58:58,349
到目前为止这么好对吧让

1452
00:58:58,349 --> 00:59:00,240
我们努力让我们做 splits 出现了，

1453
00:59:00,240 --> 00:59:01,680
虽然这本书只关注

1454
00:59:01,680 --> 00:59:04,200
splits 以相反的顺序合并本质上相同的东西

1455
00:59:04,200 --> 00:59:05,940
，所以现在我们将

1456
00:59:05,940 --> 00:59:09,299
介绍两种新类型的

1457
00:59:09,299 --> 00:59:10,770
原型，split delta 记录和分隔符，

1458
00:59:10,770 --> 00:59:13,079
所以 split 将是一个 delta

1459
00:59:13,079 --> 00:59:16,500
记录，上面写着 节点支付了

1460
00:59:16,500 --> 00:59:18,359
我们下面的基页，

1461
00:59:18,359 --> 00:59:20,220
我们的增量链中的基页已经被拆分，

1462
00:59:20,220 --> 00:59:22,829
这里是找到两个新

1463
00:59:22,829 --> 00:59:24,809
的键边界的地方，所以我们将有一个

1464
00:59:24,809 --> 00:59:27,089
指向下一个

1465
00:59:27,089 --> 00:59:29,130
增量记录的物理指针，然后是一个 指向

1466
00:59:29,130 --> 00:59:31,589
他们得到的页面的逻辑指针，我们从中分离

1467
00:59:31,589 --> 00:59:35,400
出来，然后是分隔符 Delta 记录，

1468
00:59:35,400 --> 00:59:36,990
这不是正确性所必需的，

1469
00:59:36,990 --> 00:59:40,049
但这只是一个快捷方式，

1470
00:59:40,049 --> 00:59:42,000
在较高的部分学生可以树状

1471
00:59:42,000 --> 00:59:44,400
说哦，在你下面的路上 这里有一个

1472
00:59:44,400 --> 00:59:46,230
分裂是去哪里找到

1473
00:59:46,230 --> 00:59:48,420
你要找的东西所以让我们看看

1474
00:59:48,420 --> 00:59:50,599
这里的例子所以现在你有四

1475
00:59:50,599 --> 00:59:53,190
页我们想要做的是

1476
00:59:53,190 --> 00:59:54,540
然后键像这样组织起来

1477
00:59:54,540 --> 00:59:58,200
，我们想要 对一个 103 进行拆分 所以

1478
00:59:58,200 --> 01:00:01,260
说我们实际上要插入 让

1479
01:00:01,260 --> 01:00:04,020
我们进行拆分 我们不插入任何内容 所以

1480
01:00:04,020 --> 01:00:07,440
我要做的第一件事是

1481
01:00:07,440 --> 01:00:08,190
拆分 你

1482
01:00:08,190 --> 01:00:10,410
从我的线程中知道你知道的

1483
01:00:10,410 --> 01:00:11,760
虚拟笔记 厚厚的没人能

1484
01:00:11,760 --> 01:00:13,319
真正看到，然后他刚刚

1485
01:00:13,319 --> 01:00:16,859
指向下一个兄弟姐妹 104 所以现在

1486
01:00:16,859 --> 01:00:20,099
我要在这里进行比较和交换

1487
01:00:20,099 --> 01:00:22,230
在我这样做之前没有其他人可以进入它

1488
01:00:22,230 --> 01:00:23,819
所以这没什么大不了但我想

1489
01:00:23,819 --> 01:00:27,720
更新 现在 Delta 链的 Delta 记录

1490
01:00:27,720 --> 01:00:29,670
从 103 开始，这里有这个新的分割

1491
01:00:29,670 --> 01:00:33,030
记录，

1492
01:00:33,030 --> 01:00:34,380
分割汉堡要存储的方式是

1493
01:00:34,380 --> 01:00:35,970
有指向基页的物理指针

1494
01:00:35,970 --> 01:00:38,130
，它只是说键三个键

1495
01:00:38,130 --> 01:00:40,740
三个键保持三到五个是 这里

1496
01:00:40,740 --> 01:00:43,349
和然后五这个关键七或在

1497
01:00:43,349 --> 01:00:45,200
这里，这是ju  st 一个逻辑指针，

1498
01:00:45,200 --> 01:00:49,170
所以现在我做我的比较和交换，现在

1499
01:00:49,170 --> 01:00:52,770
更新 103 现在指向我的脑海，

1500
01:00:52,770 --> 01:00:54,750
你分割记录，所以现在任何人

1501
01:00:54,750 --> 01:00:57,420
都在寻找关键 5，

1502
01:00:57,420 --> 01:01:00,270
例如将沿着这个

1503
01:01:00,270 --> 01:01:01,430
维珍链在这里，

1504
01:01:01,430 --> 01:01:03,390
好的，这些 全部都自动更新，

1505
01:01:03,390 --> 01:01:04,589
因为我有

1506
01:01:04,589 --> 01:01:06,210
映射表，好吧，这些人有

1507
01:01:06,210 --> 01:01:08,010
逻辑指针，它变成了那里

1508
01:01:08,010 --> 01:01:09,540
，现在每个人都自动

1509
01:01:09,540 --> 01:01:11,190
指向一个分割记录，所以任何人

1510
01:01:11,190 --> 01:01:13,710
都来自装瓶

1511
01:01:13,710 --> 01:01:15,569
指针或顶部，让我们看看

1512
01:01:15,569 --> 01:01:17,460
分割记录并识别哦，如果

1513
01:01:17,460 --> 01:01:19,050
我正在寻找键 5 我想在

1514
01:01:19,050 --> 01:01:20,940
这里跟随一个逻辑指针，否则

1515
01:01:20,940 --> 01:01:22,560
在这里跟随物理指针

1516
01:01:22,560 --> 01:01:24,660
现在这里我们实际上已经

1517
01:01:24,660 --> 01:01:26,369
完成了键 5 和键 6 的两个副本，

1518
01:01:26,369 --> 01:01:28,680
他们仍然 存储在 103 中，

1519
01:01:28,680 --> 01:01:31,589
因为我们无法进行就地更新，

1520
01:01:31,589 --> 01:01:33,960
所以当您现在像

1521
01:01:33,960 --> 01:01:35,400
往下一样遍历并说我正在尝试找到

1522
01:01:35,400 --> 01:01:37,859
大于 4 的键时，例如

1523
01:01:37,859 --> 01:01:39,990
我必须记住 呃，我在上面看到了一条

1524
01:01:39,990 --> 01:01:42,630
分割记录，上面说好的

1525
01:01:42,630 --> 01:01:44,190
，如果您要查找

1526
01:01:44,190 --> 01:01:45,800
大于 C 5 或更大的任何内容，则此处的注释

1527
01:01:45,800 --> 01:01:48,119
不应该缺少一或三，

1528
01:01:48,119 --> 01:01:49,619
即使您可能会在此一或

1529
01:01:49,619 --> 01:01:51,630
此一或三中看到它，您知道 你需要

1530
01:01:51,630 --> 01:01:53,720
在这里找到它，然后找到 105

1531
01:01:53,720 --> 01:02:00,690
好吧，那么现在我需要将

1532
01:02:00,690 --> 01:02:02,940
这个键空间向上传播或向上传播，

1533
01:02:02,940 --> 01:02:06,240
或者在上面分裂，所以

1534
01:02:06,240 --> 01:02:09,540
此时根表仍然具有

1535
01:02:09,540 --> 01:02:11,490
原始分裂或

1536
01:02:11,490 --> 01:02:14,670
分界 在我下面，所以如果我从

1537
01:02:14,670 --> 01:02:16,079
正确的角度来看，如果我在这里遵循它

1538
01:02:16,079 --> 01:02:17,609
并且我正在寻找关键

1539
01:02:17,609 --> 01:02:21,450
五的东西我会说关键三保持我

1540
01:02:21,450 --> 01:02:21,990
在案例

1541
01:02:21,990 --> 01:02:24,090
和 k7 并且仍然遵循该逻辑

1542
01:02:24,090 --> 01:02:26,280
指针向下分割一个然后 我

1543
01:02:26,280 --> 01:02:27,690
会认识到我现在真的需要

1544
01:02:27,690 --> 01:02:28,920
走到另一边，现在另一边，

1545
01:02:28,920 --> 01:02:32,640
但为了避免你知道这样做

1546
01:02:32,640 --> 01:02:35,190
，必要时查找我可以插入一个

1547
01:02:35,190 --> 01:02:39,270
分隔符记录，它只是说

1548
01:02:39,270 --> 01:02:42,290
好的，关键 5k7 现在在这个新的

1549
01:02:42,290 --> 01:02:44,250
这里 一个逻辑组件 新

1550
01:02:44,250 --> 01:02:46,320
节点在这里

1551
01:02:46,320 --> 01:02:48,750
同样的事情在这个被安装的 gal 上进行比较和交换，

1552
01:02:48,750 --> 01:02:50,760
其他人也

1553
01:02:50,760 --> 01:02:52,830
随之而来，但看到这没关系，

1554
01:02:52,830 --> 01:02:53,760
你不需要为了正确性而将它分开，

1555
01:02:53,760 --> 01:02:55,170
这只是出于

1556
01:02:55,170 --> 01:02:57,990
效率原因，然后当我进行

1557
01:02:57,990 --> 01:02:59,850
整合时，显然是紧凑的 它并

1558
01:02:59,850 --> 01:03:12,150
正确更新任何问题

1559
01:03:12,150 --> 01:03:14,160
逻辑点是什么是很多

1560
01:03:14,160 --> 01:03:17,869
指针我们实际存储的

1561
01:03:17,869 --> 01:03:22,020
是什么嘿准备好所以如果我

1562
01:03:22,020 --> 01:03:23,610
像最终键一样扫描

1563
01:03:23,610 --> 01:03:24,780
大于等于好的

1564
01:03:24,780 --> 01:03:27,150
k2我会在这里我说 好吧，我

1565
01:03:27,150 --> 01:03:28,680
看到 k2，但我想继续前进，所以我在

1566
01:03:28,680 --> 01:03:30,630
寻找他比 k2 大哦，我

1567
01:03:30,630 --> 01:03:32,280
需要跟随我的兄弟指针，我的

1568
01:03:32,280 --> 01:03:35,609
兄弟指针是第 103 页，这

1569
01:03:35,609 --> 01:03:37,050
就是你所知道的，这就是这种

1570
01:03:37,050 --> 01:03:39,359
东西，但我' 我只是把你知道

1571
01:03:39,359 --> 01:03:40,830
的 ID 一二三存储在这里，这是

1572
01:03:40,830 --> 01:03:42,330
为了到达那里

1573
01:03:42,330 --> 01:03:44,790


1574
01:03:44,790 --> 01:03:47,430


1575
01:03:47,430 --> 01:03:49,140


1576
01:03:49,140 --> 01:03:53,540
t侧 o 另一个根据需要是的

1577
01:04:01,070 --> 01:04:04,020
问题是当我在这里进行拆分

1578
01:04:04,020 --> 01:04:06,330
时 105 1 3 显示相同不会

1579
01:04:06,330 --> 01:04:06,600
改变

1580
01:04:06,600 --> 01:04:13,710
现在拆分是 103 的 Delta 链

1581
01:04:13,710 --> 01:04:16,430
因为那是我们回到这里的原因

1582
01:04:16,430 --> 01:04:20,490
所以我再次复制了

1583
01:04:20,490 --> 01:04:23,580
我现在需要 105 的键，我在这里有一个拆分

1584
01:04:23,580 --> 01:04:25,859
记录，我想让任何

1585
01:04:25,859 --> 01:04:28,140
103 的幽灵都知道我是

1586
01:04:28,140 --> 01:04:31,950
正确拆分的，所以我的比较和交换

1587
01:04:31,950 --> 01:04:34,980
需要在这个人的 delta 链上，这个人

1588
01:04:34,980 --> 01:04:35,910
有他自己的不”

1589
01:04:35,910 --> 01:04:38,470
再次，如果我现在开始

1590
01:04:38,470 --> 01:04:39,670
对第 105 页进行更改，

1591
01:04:39,670 --> 01:04:41,320
那将有自己的 Delta

1592
01:04:41,320 --> 01:04:44,230
Delta 链，但指向它的逻辑指针

1593
01:04:44,230 --> 01:04:46,420
仍将指向该双链的头部，

1594
01:04:46,420 --> 01:04:58,660
如果任何内容转到

1595
01:04:58,660 --> 01:05:00,880
103，那么您应该会转到 104

1596
01:05:00,880 --> 01:05:03,130
像分隔符，所以现在分隔符

1597
01:05:03,130 --> 01:05:04,540
只是让你避免不得不

1598
01:05:04,540 --> 01:05:06,730
像往下一样进行额外的实际

1599
01:05:06,730 --> 01:05:09,370
查找，这样你就可以保存为

1600
01:05:09,370 --> 01:05:10,840
应该在 105 中的东西

1601
01:05:10,840 --> 01:05:13,120
永远不会以 1 或 3 结束是的，因为我们

1602
01:05:13,120 --> 01:05:15,010
不能 因为就像我已经显示记录

1603
01:05:15,010 --> 01:05:16,930
说好如果我想插入说 一个关键的

1604
01:05:16,930 --> 01:05:20,140
5.5 这应该在 5 5 & 5 &

1605
01:05:20,140 --> 01:05:23,350
6 之间 我会到这里 5.5 大于

1606
01:05:23,350 --> 01:05:26,170
或等于 5 所以它必须到

1607
01:05:26,170 --> 01:05:30,760
这里 我不能我永远不能到那里

1608
01:05:30,760 --> 01:05:35,650
如果你为什么不去' 在这里是的，当

1609
01:05:35,650 --> 01:05:38,230
你在这里时不是是的，所以如果

1610
01:05:38,230 --> 01:05:40,090
这里有很多行如此混乱抱歉

1611
01:05:40,090 --> 01:05:43,240
所以根注释仍然认为如果

1612
01:05:43,240 --> 01:05:45,490
我正在寻找键范围 k3 到 k7 我

1613
01:05:45,490 --> 01:05:49,050
应该查看逻辑指针

1614
01:05:49,050 --> 01:05:55,240
103 是的，所以这个箭头应该真的在

1615
01:05:55,240 --> 01:05:58,240
这里，但是当我进行查找时，我将在物理

1616
01:05:58,240 --> 01:05:59,890
上找到这个拆分，所以我正在

1617
01:05:59,890 --> 01:06:02,710
寻找关键 5 我做我的我认为它应该

1618
01:06:02,710 --> 01:06:04,660
在第 1 2 3 页中我找到了一个增量记录

1619
01:06:04,660 --> 01:06:06,430
，那是 拆分，我

1620
01:06:06,430 --> 01:06:08,200
会认出哦拆分，因此我需要

1621
01:06:08,200 --> 01:06:09,760
查看拆分中的边界，

1622
01:06:09,760 --> 01:06:23,680
然后将我向左或向右移到这里，

1623
01:06:23,680 --> 01:06:25,210
因此这是分隔符键，基本上是在

1624
01:06:25,210 --> 01:06:28,800
更新此信息，是的，

1625
01:06:28,800 --> 01:06:31,300
所以一旦安装了这个东西，我就会

1626
01:06:31,300 --> 01:06:34,120
我正在寻找关键 5 我现在可能会

1627
01:06:34,120 --> 01:06:36,670
再次回到这里这就像说我

1628
01:06:36,670 --> 01:06:38,500
可以在这个节点中存储四件事 而且

1629
01:06:38,500 --> 01:06:40,180
我不需要拆分它，而

1630
01:06:40,180 --> 01:06:42,520
不必进行就地更新以在这件事中添加

1631
01:06:42,520 --> 01:06:44,260
第四个条目或路标

1632
01:06:44,260 --> 01:06:46,270
，这个分隔

1633
01:06:46,270 --> 01:06:49,000
符对我来说是这样的，是的，

1634
01:06:49,000 --> 01:06:50,380
所以我要回到之前的

1635
01:06:50,380 --> 01:06:52,300
问题，如果 你确实说服水

1636
01:06:52,300 --> 01:06:54,340
失败了，你基本上会看到这是

1637
01:06:54,340 --> 01:06:56,920
相当低的，所以如果比较

1638
01:06:56,920 --> 01:06:59,560
Vic 的父母操作失败，

1639
01:06:59,560 --> 01:07:02,400
那么当你尝试更新时，

1640
01:07:02,400 --> 01:07:03,790
就像这里

1641
01:07:03,790 --> 01:07:06,760
一样，是的，所以在实施中，

1642
01:07:06,760 --> 01:07:08,230
你们这样做了，你必须继续关注

1643
01:07:08,230 --> 01:07:10,270
新闻，因为你可能不会

1644
01:07:10,270 --> 01:07:11,680
去同一页正确的

1645
01:07:11,680 --> 01:07:13,570
1:03 就像剃光一样你去老兄 105

1646
01:07:13,570 --> 01:07:16,540
是的，但我但失败的是

1647
01:07:16,540 --> 01:07:19,360
我们实际上看到了这只婚前猫，所以

1648
01:07:19,360 --> 01:07:21,310
如果那是瑞安现在它可能只是

1649
01:07:21,310 --> 01:07:23,890
实际上遵循逻辑 0.02 到 105

1650
01:07:23,890 --> 01:07:26,770
，如果在 103 时失败，则不会发生

1651
01:07:26,770 --> 01:07:35,080
，就像他们说的那样插入 k72 103

1652
01:07:35,080 --> 01:07:39,420
保持 5.5 我正在尝试 Kay 先生 5.5

1653
01:07:39,420 --> 01:07:43,630
是的，所以在您在这里的座位上，这

1654
01:07:43,630 --> 01:07:47,130
已更新，并且 你会在

1655
01:07:48,180 --> 01:07:50,380
那里看到正确的我认为有 一些

1656
01:07:50,380 --> 01:07:51,790
优化我不知道我们是否都做了

1657
01:07:51,790 --> 01:07:54,010
它们我们就像五次比较交换

1658
01:07:54,010 --> 01:07:55,990
失败，我认识到哦，如果我

1659
01:07:55,990 --> 01:07:57,430
回来阅读我看到的内容，

1660
01:07:57,430 --> 01:07:59,830
我可以用它作为跳转

1661
01:07:59,830 --> 01:08:01,810
到我的内容的一种方式 寻找 我认为我们

1662
01:08:01,810 --> 01:08:03,370
非常保守，我们并不

1663
01:08:03,370 --> 01:08:11,470
总是在实施中

1664
01:08:11,470 --> 01:08:13,900


1665
01:08:13,900 --> 01:08:17,380


1666
01:08:17,380 --> 01:08:20,140


1667
01:08:20,140 --> 01:08:22,420
这样做 你正在分裂，所以如果它

1668
01:08:22,420 --> 01:08:24,700
像删除 k4 我忽略它，因为我

1669
01:08:24,700 --> 01:08:26,799
不是那不是我的但它就像

1670
01:08:26,799 --> 01:08:29,920
插入 k 5.5 应该在我的然后

1671
01:08:29,920 --> 01:08:30,609
我应用它

1672
01:08:30,609 --> 01:08:38,229
是的问题是分裂和

1673
01:08:38,229 --> 01:08:40,210
分隔符再次原子地 我只能

1674
01:08:40,210 --> 01:08:41,710
以原子方式做一件事 我只能以原子方式

1675
01:08:41,710 --> 01:08:43,180
更新映射表中的一个地址

1676
01:08:43,180 --> 01:08:45,040
这是因为它的闩锁

1677
01:08:45,040 --> 01:08:47,460


1678
01:08:55,779 --> 01:08:57,399
Slattery 我们必须永远阅读它们

1679
01:08:57,399 --> 01:08:59,130
才能找到这个地方

1680
01:08:59,130 --> 01:09:02,500
福特这个页面在这里 是的

1681
01:09:02,500 --> 01:09:11,439
上面可能有东西 就像有可能

1682
01:09:11,439 --> 01:09:18,970
就好 可能就像删除 它

1683
01:09:18,970 --> 01:09:22,089
可能 b 如果有插入

1684
01:09:22,089 --> 01:09:28,210
五点五我认为我们插入你

1685
01:09:28,210 --> 01:09:29,920
总是必须去辩论页面

1686
01:09:29,920 --> 01:09:32,670
所以你总是会看到这个分裂

1687
01:09:32,670 --> 01:09:34,390
实际上认为你总是

1688
01:09:34,390 --> 01:09:36,580
必须去基页是

1689
01:09:36,580 --> 01:09:38,920
删除和插入的所有内容 是的，所以我不是

1690
01:09:38,920 --> 01:09:41,020
像我会盲目地附加这个东西

1691
01:09:41,020 --> 01:09:44,920
好吧 不会缩短时间 嗯我

1692
01:09:44,920 --> 01:09:46,630
有点匆忙但我可以在

1693
01:09:46,630 --> 01:09:48,220
之后回答问题所以我会

1694
01:09:48,220 --> 01:09:50,500
很快开始谈论我们的优化

1695
01:09:50,500 --> 01:09:53,170
所以再次论文如何 你们有没有读过

1696
01:09:53,170 --> 01:09:57,790
这是我们试图写的那种

1697
01:09:57,790 --> 01:09:59,170
关于如何构建 opw 树的缺失指南，

1698
01:09:59,170 --> 01:10:00,100


1699
01:10:00,100 --> 01:10:01,300
所以微软的原始双树

1700
01:10:01,300 --> 01:10:03,010
论文并没有解释

1701
01:10:03,010 --> 01:10:03,760
你实际需要的很多核心内容，

1702
01:10:03,760 --> 01:10:05,530
实际上构建一个真正的 真正的 P Double Tree

1703
01:10:05,530 --> 01:10:07,150


1704
01:10:07,150 --> 01:10:09,550
他们在原始论文之后写了很多其他论文，这些论文涉及我们

1705
01:10:09,550 --> 01:10:11,710
论文中的一些

1706
01:10:11,710 --> 01:10:13,210
内容，并要求

1707
01:10:13,210 --> 01:10:14,440
我们的论文旨在整合

1708
01:10:14,440 --> 01:10:16,870
指南，了解如何构建真实的 BW

1709
01:10:16,870 --> 01:10:18,970
树，所以当我第一次在 CMU 开始时，

1710
01:10:18,970 --> 01:10:19,870
我说好吧，我们将构建一个新的

1711
01:10:19,870 --> 01:10:21,280
数据库系统，并且非常

1712
01:10:21,280 --> 01:10:23,080
喜欢 BW 团队，就像我们

1713
01:10:23,080 --> 01:10:24,280
曾经构建过一个新系统一样，我们

1714
01:10:24,280 --> 01:10:26,710
将第一次使用 BW 树 我教这

1715
01:10:26,710 --> 01:10:29,170
门课的第二个项目是实施

1716
01:10:29,170 --> 01:10:32,050
BW 树，这是一场噩梦，

1717
01:10:32,050 --> 01:10:33,370
但就像我说的一个学生，

1718
01:10:33,370 --> 01:10:35,080
桃子学生，非常棒，

1719
01:10:35,080 --> 01:10:36,610
我们拿走了他的破旧树，他继续

1720
01:10:36,610 --> 01:10:37,690
工作了两年，这

1721
01:10:37,690 --> 01:10:39,460
就是 论文是，但他的论文并不

1722
01:10:39,460 --> 01:10:41,650
意味着像哦，看 bbw

1723
01:10:41,650 --> 01:10:43,570
树是多么蹩脚，就像你知道我们

1724
01:10:43,570 --> 01:10:44,560
实际上是基准之一，

1725
01:10:44,560 --> 01:10:45,910
看看我实际上是如何做饭的，

1726
01:10:45,910 --> 01:10:48,460
结果证明它很糟糕，所以这就是

1727
01:10:48,460 --> 01:10:49,840
原因 这有点像裂脑，

1728
01:10:49,840 --> 01:10:51,520
一半的论文说这里是如何构建

1729
01:10:51,520 --> 01:10:52,960
它，然后第二篇论文说

1730
01:10:52,960 --> 01:10:54,970
为什么它很糟糕，

1731
01:10:54,970 --> 01:10:57,220
因为 RISM 不应该是那样的，

1732
01:10:57,220 --> 01:10:58,090
所以杏仁很快谈论

1733
01:10:58,090 --> 01:11:00,100
我们所做的一些优化 我们的

1734
01:11:00,100 --> 01:11:01,960
版本 据我所知，我们的每棵树都被称为公开测试版，

1735
01:11:01,960 --> 01:11:05,260
这是最好

1736
01:11:05,260 --> 01:11:07,000


1737
01:11:07,000 --> 01:11:08,650
的节拍每棵树的开源实现

1738
01:11:08,650 --> 01:11:10,150
，还有其他一些树，但它们

1739
01:11:10,150 --> 01:11:11,260
并不能完成我们所做的所有事情，

1740
01:11:11,260 --> 01:11:13,420
只有一个系统 在德国以外的地方叫做

1741
01:11:13,420 --> 01:11:15,940
sled，它就像一个

1742
01:11:15,940 --> 01:11:17,800
用 rust 编写的嵌入式系统，据说他们正在

1743
01:11:17,800 --> 01:11:19,120
使用一个破旧的撤退我不知道

1744
01:11:19,120 --> 01:11:20,740
他们是否达到了极端程度

1745
01:11:20,740 --> 01:11:23,740
，即安装 be dimitri 出现在

1746
01:11:23,740 --> 01:11:25,750
微软如此宇宙的其他系统中

1747
01:11:25,750 --> 01:11:27,880
DP 或曾经记录 DBS 他们

1748
01:11:27,880 --> 01:11:30,160
的 MongoDB 版本或他们的云

1749
01:11:30,160 --> 01:11:31,810
数据库 他们在某些情况下使用它击败每棵树

1750
01:11:31,810 --> 01:11:34,360
，但我们是最好的

1751
01:11:34,360 --> 01:11:35,110
开放排序，

1752
01:11:35,110 --> 01:11:37,540
所以我什至谈论这

1753
01:11:37,540 --> 01:11:38,680
两个帮助我们实际存储这些

1754
01:11:38,680 --> 01:11:40,600
Delta 像你知道

1755
01:11:40,600 --> 01:11:42,610
微软最初讨论的原始记录，

1756
01:11:42,610 --> 01:11:44,320
他们说哦，有空间，他们并没有

1757
01:11:44,320 --> 01:11:45,700
真正说明他们在哪里，所以你

1758
01:11:45,700 --> 01:11:46,900
可以分配一堆小

1759
01:11:46,900 --> 01:11:48,370
鸭子不记录在堆上，

1760
01:11:48,370 --> 01:11:49,540
但是' 一个坏主意，因为你会有

1761
01:11:49,540 --> 01:11:51,340
碎片和内存，所以我们要做的

1762
01:11:51,340 --> 01:11:53,020
是，当我们分配一个基页时，我们在基页

1763
01:11:53,020 --> 01:11:54,670
的标题中有一点额外的空间

1764
01:11:54,670 --> 01:11:56,440
，我们可以用来

1765
01:11:56,440 --> 01:12:00,250
存储增量记录，所以现在我

1766
01:12:00,250 --> 01:12:04,780
需要做的就是 现在是如果我要更新所以

1767
01:12:04,780 --> 01:12:06,220
我要添加一个新的 Delta 记录我

1768
01:12:06,220 --> 01:12:08,650
只是在这个东西上做一个比较和交换在

1769
01:12:08,650 --> 01:12:10,990
这里得到一个新的偏移量 现在我可以

1770
01:12:10,990 --> 01:12:13,180
在这里插入我的 Delta 记录然后我

1771
01:12:13,180 --> 01:12:15,070
回到这里 并进行比较和

1772
01:12:15,070 --> 01:12:16,330
交换以使其正确地指向我的

1773
01:12:16,330 --> 01:12:19,150
Delta 记录的头部，因此我再次

1774
01:12:19,150 --> 01:12:20,470
不需要使用闩锁来获取空间

1775
01:12:20,470 --> 01:12:22,240
，然后当这件事变满时，

1776
01:12:22,240 --> 01:12:25,300
我会做另一

1777
01:12:25,300 --> 01:12:27,430
件事 这会不会太重要了，

1778
01:12:27,430 --> 01:12:29,170
我真的

1779
01:12:29,170 --> 01:12:31,540
在黑白论文的原始版本中描述了映射表是什么

1780
01:12:31,540 --> 01:12:35,820
它似乎是一个哈希表一个

1781
01:12:35,820 --> 01:12:38,710
应用程序它只是一个数组，所以

1782
01:12:38,710 --> 01:12:40,600
你想分配一个可以

1783
01:12:40,600 --> 01:12:42,790
存储任何的数组 可能，你知道你注意到

1784
01:12:42,790 --> 01:12:45,340
了一些限制，

1785
01:12:45,340 --> 01:12:48,700
所以 但问题是，如果你

1786
01:12:48,700 --> 01:12:49,930
在一

1787
01:12:49,930 --> 01:12:51,160
开始就为每一个可能没有的

1788
01:12:51,160 --> 01:12:52,240
数据分配了完整的数组，

1789
01:12:52,240 --> 01:12:54,130
那么你最终会浪费大量空间，

1790
01:12:54,130 --> 01:12:55,300
因为你正在分配

1791
01:12:55,300 --> 01:12:58,270
你可能不需要的内存，所以我认为

1792
01:12:58,270 --> 01:13:01,990
在当前版本

1793
01:13:01,990 --> 01:13:03,220
的珠子中，我们

1794
01:13:03,220 --> 01:13:06,780
系统中的每棵树映射表的最大大小为

1795
01:13:06,780 --> 01:13:10,030
100 万，因此我的系统中可以有 100 万个节点

1796
01:13:10,030 --> 01:13:12,400
ID，因此如果我们

1797
01:13:12,400 --> 01:13:16,390
为每个节点存储 128 个键 我最多可以有 128

1798
01:13:16,390 --> 01:13:18,580
个潜在的 180 个键，它

1799
01:13:18,580 --> 01:13:19,840
少于这个数量，因为我们只是

1800
01:13:19,840 --> 01:13:20,800
从它们中开始

1801
01:13:20,800 --> 01:13:22,930
我会在叶笔记中吃东西，但大致

1802
01:13:22,930 --> 01:13:24,580
就是这样分配一个

1803
01:13:24,580 --> 01:13:26,680
带有 1 的 64 位指针的数组

1804
01:13:26,680 --> 01:13:30,250
1 个主要条目是 8 兆字节，所以

1805
01:13:30,250 --> 01:13:31,660
它看起来并不多，但是如果您

1806
01:13:31,660 --> 01:13:34,630
喜欢加载 TVC 数据库，如果每个

1807
01:13:34,630 --> 01:13:36,340
表都有两个或三个索引，那么对于

1808
01:13:36,340 --> 01:13:38,920
每个表，我正在创建三个索引 8

1809
01:13:38,920 --> 01:13:40,450
兆字节开始从

1810
01:13:40,450 --> 01:13:42,880
自然不会在

1811
01:13:42,880 --> 01:13:44,350
滚动版本中存储任何东西 当您第一次

1812
01:13:44,350 --> 01:13:46,330
加载 TPCC 时，数据库会增长

1813
01:13:46,330 --> 01:13:49,990
到 256 Meg，其中没有数据，

1814
01:13:49,990 --> 01:13:52,600
所以我们解决这个问题的方法是

1815
01:13:52,600 --> 01:13:54,750
我们只使用我们分配虚拟内存

1816
01:13:54,750 --> 01:13:57,130
，这不使用任何特殊的东西，

1817
01:13:57,130 --> 01:13:59,080
只是使用您的构造

1818
01:13:59,080 --> 01:14:01,300
我们从操作系统分配了一块内存，

1819
01:14:01,300 --> 01:14:03,130
并确保我们只

1820
01:14:03,130 --> 01:14:05,470
在索引很小时才使用映射表的上部，

1821
01:14:05,470 --> 01:14:07,150
因此它实际上并没有

1822
01:14:07,150 --> 01:14:08,350
得到物理内存的支持，因此尽管

1823
01:14:08,350 --> 01:14:10,420
虚拟大小可能会变大驻留

1824
01:14:10,420 --> 01:14:13,120
集 大小非常小对，

1825
01:14:13,120 --> 01:14:14,800
因为只有当您触摸

1826
01:14:14,800 --> 01:14:16,630
内存中的页面时，操作系统才会真正

1827
01:14:16,630 --> 01:14:19,180
使用物理内存支持它，

1828
01:14:19,180 --> 01:14:21,400
以便快速完成因此

1829
01:14:21,400 --> 01:14:23,410
这是原始珠子中的结果

1830
01:14:23,410 --> 01:14:24,670


1831
01:14:24,670 --> 01:14:27,070
微软与贾斯汀和

1832
01:14:27,070 --> 01:14:28,540
那里的其他人一起发表的撤退论文，这是当

1833
01:14:28,540 --> 01:14:29,830
我看到这个的时候，我就像哦，这太棒了，

1834
01:14:29,830 --> 01:14:31,270
我们完全想在 CMU 建立一个奢侈品

1835
01:14:31,270 --> 01:14:32,920
指数，所以他们在比较什么

1836
01:14:32,920 --> 01:14:34,120
是的 他们的版本

1837
01:14:34,120 --> 01:14:37,270
击败了跳过列表的每棵树，然后是

1838
01:14:37,270 --> 01:14:39,640
B+ 树，但这个 B+ 树实际上

1839
01:14:39,640 --> 01:14:42,310
来自伯克利 DB Berkeley DB 来自

1840
01:14:42,310 --> 01:14:45,640
加州大学伯克利分校，它是一个嵌入式

1841
01:14:45,640 --> 01:14:48,130
数据库，你知道它基本上就像

1842
01:14:48,130 --> 01:14:49,750
DB 级和 Roxie B 一样

1843
01:14:49,750 --> 01:14:51,010
最早这样做的人之一是 Oracle 购买了

1844
01:14:51,010 --> 01:14:53,350
它，就像 2006 年一样，因此他们

1845
01:14:53,350 --> 01:14:55,300
从 Berkeley DB 中提取了 d-bus 树的源代码并对其进行了

1846
01:14:55,300 --> 01:14:57,820
修改，因此

1847
01:14:57,820 --> 01:14:59,500
它实际上并未在磁盘上存储任何内容，

1848
01:14:59,500 --> 01:15:02,500
因此这显示 树的一点点

1849
01:15:02,500 --> 01:15:04,720
正确地粉碎了一切 所以当我

1850
01:15:04,720 --> 01:15:05,980
看到这真是太神奇了 我们应该

1851
01:15:05,980 --> 01:15:07,900
完全这样做 但是当你

1852
01:15:07,900 --> 01:15:08,980
真正实现它 所以这些是我们的

1853
01:15:08,980 --> 01:15:12,820
结果 这是最好的我们最好

1854
01:15:12,820 --> 01:15:15,310
的开放 BW 树版本 这

1855
01:15:15,310 --> 01:15:16,270
实际上是

1856
01:15:16,270 --> 01:15:18,130
跳过列表的最先进实现

1857
01:15:18,130 --> 01:15:20,680
它来自

1858
01:15:20,680 --> 01:15:22,600
澳大利亚的 alan techies group，而不是使用塔，它

1859
01:15:22,600 --> 01:15:24,940
使用轮子，这是一些小的变化，

1860
01:15:24,940 --> 01:15:27,340
无论如何，这是

1861
01:15:27,340 --> 01:15:28,930
由其中一位作者编写的 B+ 树 m

1862
01:15:28,930 --> 01:15:30,430
hyper 来拜访我们

1863
01:15:30,430 --> 01:15:32,440
几个月了，这就像他一样，这是

1864
01:15:32,440 --> 01:15:33,949
他们

1865
01:15:33,949 --> 01:15:36,139
在 hyper 中进行比较的数据结构之一，因此您

1866
01:15:36,139 --> 01:15:38,630
可以看到深深的呃连续冲刺，除了

1867
01:15:38,630 --> 01:15:39,889
这里的这个，这不会使 我

1868
01:15:39,889 --> 01:15:41,959
错了，我得到了有丝分裂，但是 V Plus V

1869
01:15:41,959 --> 01:15:44,079
几乎粉碎了

1870
01:15:44,079 --> 01:15:46,280


1871
01:15:46,280 --> 01:15:47,719


1872
01:15:47,719 --> 01:15:49,280


1873
01:15:49,280 --> 01:15:51,380


1874
01:15:51,380 --> 01:15:54,050
一切 我现在要引入 mash 树

1875
01:15:54,050 --> 01:15:55,969
和艺术索引 art index 是你

1876
01:15:55,969 --> 01:15:58,159
在周三的课上读到的它是来自 Piper 的基数树

1877
01:15:58,159 --> 01:16:01,880
或三叉树 然后 mash

1878
01:16:01,880 --> 01:16:04,130
树在哈佛 这是一棵尝试树

1879
01:16:04,130 --> 01:16:05,959
我们将在下节课介绍 再次在

1880
01:16:05,959 --> 01:16:07,820
这种环境中，可击败的树只是

1881
01:16:07,820 --> 01:16:10,400
输给了一切所以这就是为什么我们

1882
01:16:10,400 --> 01:16:11,840
需要摆脱它但我们只是

1883
01:16:11,840 --> 01:16:14,630
我们还没有开始它还好吧好吧

1884
01:16:14,630 --> 01:16:15,829
那就像最后超级匆忙我

1885
01:16:15,829 --> 01:16:16,780
道歉

1886
01:16:16,780 --> 01:16:21,289
所有问题所以 下节课

1887
01:16:21,289 --> 01:16:22,760
我会花更多的时间说话

1888
01:16:22,760 --> 01:16:24,650
关于 B 的闩锁 把 B 加上树 然后

1889
01:16:24,650 --> 01:16:25,820
我们将讨论基数树的内容

1890
01:16:25,820 --> 01:16:27,309
然后我们将讨论

1891
01:16:27,309 --> 01:16:30,920
您可以为项目一做些什么 好的，

1892
01:16:30,920 --> 01:16:36,190
伙计们，看看你这是什么

1893
01:16:36,350 --> 01:16:46,280
[音乐]

1894
01:16:46,280 --> 01:16:48,950
Mia 40 只是为了 得到我的嗡嗡声因为我

1895
01:16:48,950 --> 01:16:51,170
需要更多的踢腿看起来像

1896
01:16:51,170 --> 01:16:53,600
一条鱼，只要一个失误就把它放在

1897
01:16:53,600 --> 01:16:55,670
我的嘴唇上，撕掉八个球的顶部，然后

1898
01:16:55,670 --> 01:16:58,460
把它们放下，说好

1899
01:16:58,460 --> 01:17:01,100
不会一样，我已经切成丁了 你

1900
01:17:01,100 --> 01:17:04,390
向玩家请酒

