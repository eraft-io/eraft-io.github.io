1
00:00:01,300 --> 00:00:05,129
[音乐]

2
00:00:05,200 --> 00:00:05,930
[鼓掌]

3
00:00:05,930 --> 00:00:08,630
[音乐]

4
00:00:08,630 --> 00:00:10,020
[鼓掌]

5
00:00:10,020 --> 00:00:11,870
[音乐]

6
00:00:11,870 --> 00:00:16,520
所以今天我想谈的

7
00:00:16,520 --> 00:00:19,770
是开始，把上次我们没有讨论的东西捡起来，

8
00:00:19,770 --> 00:00:21,600
所以我

9
00:00:21,600 --> 00:00:23,279
认为我认为我做错了这个

10
00:00:23,279 --> 00:00:25,439
学期是我试图把

11
00:00:25,439 --> 00:00:27,320
现在的三堂课塞进两堂课，

12
00:00:27,320 --> 00:00:30,029
所以通常我们会分别讨论 B 树 B

13
00:00:30,029 --> 00:00:31,769
加上树和睫毛，但现在

14
00:00:31,769 --> 00:00:33,480
我试图将它们包括在

15
00:00:33,480 --> 00:00:34,950
这里的讨论中，

16
00:00:34,950 --> 00:00:37,170
所以首先我们将讨论 如何实际

17
00:00:37,170 --> 00:00:38,550
实现闩锁或

18
00:00:38,550 --> 00:00:39,809
我们可以使用我们的数据系统进行什么样的讲座，

19
00:00:39,809 --> 00:00:41,010
然后我在谈论如何

20
00:00:41,010 --> 00:00:43,530
在 B+ 树中进行闩锁，当然这

21
00:00:43,530 --> 00:00:45,420
将与 BW 树形成对比，BW

22
00:00:45,420 --> 00:00:47,129
树旨在成为一

23
00:00:47,129 --> 00:00:48,629
棵树 你知道人们问你你必须

24
00:00:48,629 --> 00:00:50,820
有闩锁 然后我们将专注于

25
00:00:50,820 --> 00:00:52,739
你们阅读的内容 今天

26
00:00:52,739 --> 00:00:55,410
分配的关于 Judy ray 的阅读被

27
00:00:55,410 --> 00:00:57,149
索引在掌握中或者它们都是

28
00:00:57,149 --> 00:01:01,940
尝试的变体 好吧，所以

29
00:01:01,940 --> 00:01:04,979
再次回忆 来自

30
00:01:04,979 --> 00:01:06,450
我们讨论 t 时的介绍课 不同的锁

31
00:01:06,450 --> 00:01:09,720
和闩锁 锁是

32
00:01:09,720 --> 00:01:11,430
数据库系统中的这个逻辑概念，旨在

33
00:01:11,430 --> 00:01:14,369
保护数据库本身内的实体，

34
00:01:14,369 --> 00:01:16,740
就像我们对表

35
00:01:16,740 --> 00:01:18,960
加锁对元组加锁对

36
00:01:18,960 --> 00:01:21,600
我们在整个数据库中的元组块

37
00:01:21,600 --> 00:01:24,210
然后是闩锁 我们将成为这些

38
00:01:24,210 --> 00:01:26,909
低级原语，您将使用它们来

39
00:01:26,909 --> 00:01:29,159
保护任何

40
00:01:29,159 --> 00:01:30,810
类型的当前数据结构的关键部分以及

41
00:01:30,810 --> 00:01:32,040
需要多个

42
00:01:32,040 --> 00:01:34,110
线程同时访问或修改的任何内容

43
00:01:34,110 --> 00:01:36,270
，因此如果您这样做，这可能会让人感到困惑

44
00:01:36,270 --> 00:01:38,400
来自操作系统世界，

45
00:01:38,400 --> 00:01:41,400
那里没有闩锁的概念，

46
00:01:41,400 --> 00:01:43,110
现在 C++ 中存在，但这

47
00:01:43,110 --> 00:01:43,799


48
00:01:43,799 --> 00:01:46,409
在操作系统世界中意味着完全不同的东西，他们将这些

49
00:01:46,409 --> 00:01:49,770
东西称为锁，因此对于今天的讲座，

50
00:01:49,770 --> 00:01:52,860
我们主要只讨论闩锁

51
00:01:52,860 --> 00:01:55,110
，这有点令人困惑 因为

52
00:01:55,110 --> 00:01:56,189
你实现闩锁的方式是

53
00:01:56,189 --> 00:02:00,060
自旋锁所以每次我

54
00:02:00,060 --> 00:02:02,070
在本课中说锁定时我真正的意思是闩锁但

55
00:02:02,070 --> 00:02:04,110
让我去读出你知道阅读

56
00:02:04,110 --> 00:02:05,340
不是的东西 在数据库

57
00:02:05,340 --> 00:02:07,500
文献社区中，他们将

58
00:02:07,500 --> 00:02:09,090
事物称为锁，

59
00:02:09,090 --> 00:02:10,258
但当您在两个数据库中时，它们实际上是指闩锁，

60
00:02:10,258 --> 00:02:12,790
这开始令人困惑抱歉，

61
00:02:12,790 --> 00:02:14,620
所以如果您想

62
00:02:14,620 --> 00:02:17,319
再次在我们的系统中使用闩锁，我们就是

63
00:02:17,319 --> 00:02:18,849
数据库 系统开发人员我们是

64
00:02:18,849 --> 00:02:20,109
实际构建系统的人，所以

65
00:02:20,109 --> 00:02:22,480
我们需要决定

66
00:02:22,480 --> 00:02:25,569
你想使用什么样的闩锁 我

67
00:02:25,569 --> 00:02:26,890
想说我们不是

68
00:02:26,890 --> 00:02:28,599
自己编写闩锁的业务，我不鼓励

69
00:02:28,599 --> 00:02:30,519
你这样做，尽管 您可以

70
00:02:30,519 --> 00:02:32,079
像在多张幻灯片中展示的那样简单地构建它们，

71
00:02:32,079 --> 00:02:36,280
但一般的传统

72
00:02:36,280 --> 00:02:38,109
智慧是不要编写自己的闩锁

73
00:02:38,109 --> 00:02:39,639
库，那里已经有大量的闩锁库

74
00:02:39,639 --> 00:02:42,939
，只需选择其中一个即可，因此

75
00:02:42,939 --> 00:02:44,889
我们想谈谈我们的想法 '

76
00:02:44,889 --> 00:02:47,019
我们想要在我们的锁存器中拥有我们可以

77
00:02:47,019 --> 00:02:49,870
应用于我们的数据库系统的

78
00:02:49,870 --> 00:02:51,220
获取必须在存储容量方面最有效，

79
00:02:51,220 --> 00:02:54,340


80
00:02:54,340 --> 00:02:56,019
即占用内存中的锁存器需要多少空间

81
00:02:56,019 --> 00:02:58,840
以及效率 某种

82
00:02:58,840 --> 00:03:01,269
闩锁机制本身，所以很明显

83
00:03:01,269 --> 00:03:02,439
我们想要我们想要一个小的内存

84
00:03:02,439 --> 00:03:04,840
占用，现在考虑在你的

85
00:03:04,840 --> 00:03:06,879
B+ 树或你自己的基数树

86
00:03:06,879 --> 00:03:08,799
中，今天将讨论的就像每个

87
00:03:08,799 --> 00:03:11,049
节点都会有一个闩锁，所以如果你的

88
00:03:11,049 --> 00:03:13,209
闩锁是 就像你知道几百

89
00:03:13,209 --> 00:03:15,489
KB 那是愚蠢的那是错误的但

90
00:03:15,489 --> 00:03:17,729
即使如此，如果它是

91
00:03:17,729 --> 00:03:20,769
几个字节可以开始加起来，

92
00:03:20,769 --> 00:03:21,940
因为你没有一个用于

93
00:03:21,940 --> 00:03:23,739
每个数据结构或每个

94
00:03:23,739 --> 00:03:28,269
节点，就像在 pthread 互斥锁中一样

95
00:03:28,269 --> 00:03:30,849
它们将是 64 字节，这

96
00:03:30,849 --> 00:03:33,159
实际上非常正确，之所以如此之

97
00:03:33,159 --> 00:03:34,870
大，是因为出于

98
00:03:34,870 --> 00:03:36,639
历史原因，它们必须向后

99
00:03:36,639 --> 00:03:38,889
兼容某些

100
00:03:38,889 --> 00:03:40,269
需要锁存

101
00:03:40,269 --> 00:03:42,639
器为 64 字节的旧 CPU 架构，但我们还有其他

102
00:03:42,639 --> 00:03:43,900
实现 可以使用

103
00:03:43,900 --> 00:03:46,750
它会更小，我们显然

104
00:03:46,750 --> 00:03:48,280
希望在最好的情况下，当

105
00:03:48,280 --> 00:03:49,750


106
00:03:49,750 --> 00:03:51,970
我们尝试访问的任何东西都没有争用时，我们

107
00:03:51,970 --> 00:03:53,799
可以获得非常有效的闩锁 显然，

108
00:03:53,799 --> 00:03:55,659
这是正确的，我们想要一个快速的执行

109
00:03:55,659 --> 00:03:57,549
路径，当没有争用时，我们只需

110
00:03:57,549 --> 00:03:59,349
继续并合唱闩锁，并且

111
00:03:59,349 --> 00:04:00,669
不需要大量的工作大量的

112
00:04:00,669 --> 00:04:02,979
指令让我们这样做，然后

113
00:04:02,979 --> 00:04:05,790
当我们可以时 t 获取闩锁，

114
00:04:05,790 --> 00:04:08,109
然后我们希望能够

115
00:04:08,109 --> 00:04:10,959
使用操作系统安排我们的线程，

116
00:04:10,959 --> 00:04:12,430
这样我们就不会只是

117
00:04:12,430 --> 00:04:13,959
在自旋闩锁中旋转它们的燃烧周期，

118
00:04:13,959 --> 00:04:16,089
我将在下一张幻灯片中展示，

119
00:04:16,089 --> 00:04:17,649
因为这只是燃烧周期 并且

120
00:04:17,649 --> 00:04:20,529
浪费 CPU 和操作系统会在

121
00:04:20,529 --> 00:04:21,639
安排你时遇到麻烦，因为他们

122
00:04:21,639 --> 00:04:22,770
会认为你实际上在做工作，

123
00:04:22,770 --> 00:04:25,090
而绵羊会继续尝试安排在

124
00:04:25,090 --> 00:04:26,320
你真正离开时执行你，

125
00:04:26,320 --> 00:04:29,980
如果现在我们也必须维护任何

126
00:04:29,980 --> 00:04:32,170
元数据 - 关于 哪些线程在

127
00:04:32,170 --> 00:04:33,580
等待我们或哪些线程在

128
00:04:33,580 --> 00:04:35,650
等待获取闩锁，

129
00:04:35,650 --> 00:04:36,850
我们不想让每个闩锁

130
00:04:36,850 --> 00:04:39,880
实例分配并维护

131
00:04:39,880 --> 00:04:41,920
自己的队列数据结构以

132
00:04:41,920 --> 00:04:44,110
跟踪哪些线程正在等待，因此如果我们使用

133
00:04:44,110 --> 00:04:45,910
较少的阻塞 穆特 例如，操作系统为我们做这

134
00:04:45,910 --> 00:04:46,180


135
00:04:46,180 --> 00:04:47,170
件事，但是如果我们在

136
00:04:47,170 --> 00:04:49,990
内核正上方的用户空间中使用某些东西，那么我们

137
00:04:49,990 --> 00:04:50,920
不想让

138
00:04:50,920 --> 00:04:52,960
您知道的每个锁存器都维护自己的队列，

139
00:04:52,960 --> 00:04:54,070
因为这会炸毁东西的大小，

140
00:04:54,070 --> 00:05:00,640
所以这个 问题是要

141
00:05:00,640 --> 00:05:02,290
问我们，说我不能再跑了

142
00:05:02,290 --> 00:05:05,050
，不要，我在这里，这是

143
00:05:05,050 --> 00:05:07,090
哦，我正在等待收到通知，

144
00:05:07,090 --> 00:05:13,620
以便我可以正确运行，所以很抱歉，

145
00:05:15,060 --> 00:05:17,320
我们会得到 他的问题是这

146
00:05:17,320 --> 00:05:19,300
是否意味着每个闩锁

147
00:05:19,300 --> 00:05:23,580
含义都必须将其包裹或锁定否，

148
00:05:23,580 --> 00:05:25,780
但实际上您的问题

149
00:05:25,780 --> 00:05:27,700
实际上非常尖锐，因为

150
00:05:27,700 --> 00:05:30,730
如果您

151
00:05:30,730 --> 00:05:32,020
想像黑客新闻一样称呼它，这实际上已经出现在新闻

152
00:05:32,020 --> 00:05:35,170
中 限制邮件列表，因为一些

153
00:05:35,170 --> 00:05:37,420
在谷歌工作的人在他们的

154
00:05:37,420 --> 00:05:39,610
新游戏机上工作 巨大的 attea 事情

155
00:05:39,610 --> 00:05:40,780
就像是流媒体

156
00:05:40,780 --> 00:05:43,060
游戏机他们有一篇

157
00:05:43,060 --> 00:05:46,540
关于操作系统内核锁是如何

158
00:05:46,540 --> 00:05:47,770
错误的长博文，你真的不会

159
00:05:47,770 --> 00:05:49,780
正在使用自旋锁所以然后你 rse

160
00:05:49,780 --> 00:05:52,500
Linus 不喜欢那样，他有一个很长的

161
00:05:52,500 --> 00:05:55,510
帖子，他说

162
00:05:55,510 --> 00:05:58,030
这有什么错，他们知道为什么

163
00:05:58,030 --> 00:06:00,570
用户土地自旋锁是个坏主意，

164
00:06:00,570 --> 00:06:02,500
所以我想我要阅读整篇文章

165
00:06:02,500 --> 00:06:05,410
不过我要指出的

166
00:06:05,410 --> 00:06:07,270
是，他在这里有一个评论

167
00:06:07,270 --> 00:06:10,210
，我将重点强调他说不要

168
00:06:10,210 --> 00:06:12,550
在用户空间中使用旋转盒和外部旋转锁存器的

169
00:06:12,550 --> 00:06:14,200
地方，除非你真的知道

170
00:06:14,200 --> 00:06:15,520
你在做什么以及你知道的可能性

171
00:06:15,520 --> 00:06:16,780
你在做什么是非常非常低的，

172
00:06:16,780 --> 00:06:21,730
所以在这之前每

173
00:06:21,730 --> 00:06:23,950
学期我教我教闩锁时我

174
00:06:23,950 --> 00:06:26,980
总是说哦，是的，从来没有使用过操作系统

175
00:06:26,980 --> 00:06:28,920
闩锁 一些 pthread 互斥锁的文本，

176
00:06:28,920 --> 00:06:32,950
因为进入

177
00:06:32,950 --> 00:06:34,540
内核总是

178
00:06:34,540 --> 00:06:37,210
告诉操作系统真的很昂贵，嘿，我不能再运行了

179
00:06:37,210 --> 00:06:39,820
，现在

180
00:06:39,820 --> 00:06:42,160
进入操作系统，您必须更新

181
00:06:42,160 --> 00:06:43,270
调度程序正在维护的数据结构，

182
00:06:43,270 --> 00:06:44,260
以跟踪

183
00:06:44,260 --> 00:06:45,250
正在运行的线程正在等待

184
00:06:45,250 --> 00:06:46,270
的内容

185
00:06:46,270 --> 00:06:48,940
我一直认为好的，是的，有

186
00:06:48,940 --> 00:06:50,050
更好的 在用户空间做所有事情，

187
00:06:50,050 --> 00:06:52,870
所以他声称你知道他的

188
00:06:52,870 --> 00:06:54,700
想法操作系统总是

189
00:06:54,700 --> 00:06:56,710
比其他任何事情都做得更好，

190
00:06:56,710 --> 00:06:58,750
因为它对正在发生的一切都有最少的全局

191
00:06:58,750 --> 00:07:00,010
视图，并且

192
00:07:00,010 --> 00:07:01,510
可以决定

193
00:07:01,510 --> 00:07:03,430
是否调度程序

194
00:07:03,430 --> 00:07:06,580
是的，如果

195
00:07:06,580 --> 00:07:08,110
我们执行绿色线程并在上面管理我们自己的

196
00:07:08,110 --> 00:07:09,550
线程，那么我们无法完全控制我们的数据库系统中的内容，我们可以做到

197
00:07:09,550 --> 00:07:12,340
这一点，但这通常对这些系统来说是一种矫枉过正，

198
00:07:12,340 --> 00:07:15,910
所以

199
00:07:15,910 --> 00:07:17,290
我再次谈论的重点是 make

200
00:07:17,290 --> 00:07:20,920
在这篇博文之前，

201
00:07:20,920 --> 00:07:24,460
我总是会说使用测试自旋锁存器

202
00:07:24,460 --> 00:07:27,190
，我认为目前

203
00:07:27,190 --> 00:07:28,360
最先进的理解是你

204
00:07:28,360 --> 00:07:30,340
不想这样做，所以让我们

205
00:07:30,340 --> 00:07:31,960
谈谈我们如何与

206
00:07:31,960 --> 00:07:33,670
我们可以实现闩锁的不同端，因此

207
00:07:33,670 --> 00:07:35,350
测试和自旋锁或自旋闩锁

208
00:07:35,350 --> 00:07:36,670
是最基本的，这是

209
00:07:36,670 --> 00:07:37,630
您可以自己实现的，而

210
00:07:37,630 --> 00:07:39,610
不必返回并

211
00:07:39,610 --> 00:07:41,860
屈服于操作系统然后有一个块 国王操作系统互斥锁

212
00:07:41,860 --> 00:07:43,660
，这是 Linus 所指的，

213
00:07:43,660 --> 00:07:45,850
然后我认为正确的选择

214
00:07:45,850 --> 00:07:47,680
实际上是自适应自旋

215
00:07:47,680 --> 00:07:49,960
锁，它是这两者的组合，

216
00:07:49,960 --> 00:07:51,610
比

217
00:07:51,610 --> 00:07:53,440
阻塞操作系统可以做的更聪明一点，然后

218
00:07:53,440 --> 00:07:54,640
我们 将查看更复杂的

219
00:07:54,640 --> 00:07:56,530
实现，cubase one 和

220
00:07:56,530 --> 00:07:58,240
读写器锁，但是您可以

221
00:07:58,240 --> 00:07:59,770
在这些其他实现之上构建这些实现，

222
00:07:59,770 --> 00:08:01,060
这些就像基本原语

223
00:08:01,060 --> 00:08:01,750
，然后您可以在此基础上做更复杂的

224
00:08:01,750 --> 00:08:05,440
事情，所以最

225
00:08:05,440 --> 00:08:07,840
实现锁存器的最简单方法是

226
00:08:07,840 --> 00:08:09,430
测试并设置自旋锁存器测试集

227
00:08:09,430 --> 00:08:11,500
自旋锁存器一切正常，

228
00:08:11,500 --> 00:08:14,050
只是我们只有一些内存块

229
00:08:14,050 --> 00:08:16,120
看起来像一个字节或者有 64

230
00:08:16,120 --> 00:08:18,820
位我们只是要测试 查看

231
00:08:18,820 --> 00:08:21,160
它是否设置为零，如果

232
00:08:21,160 --> 00:08:22,510
它在单个比较和交换

233
00:08:22,510 --> 00:08:24,370
指令中，我们将把它设置为一个，意味着

234
00:08:24,370 --> 00:08:26,830
我们已经获得了锁存器，所以你可以

235
00:08:26,830 --> 00:08:28,840
在 C++ 中得到它，他们现在在

236
00:08:28,840 --> 00:08:30,220
他们为你提供的 STL 标准中 有了这个

237
00:08:30,220 --> 00:08:33,039
原子 模板类型然后你可以

238
00:08:33,039 --> 00:08:34,840
把任何你知道的原语你

239
00:08:34,840 --> 00:08:36,429
想要布尔整数和它的东西

240
00:08:36,429 --> 00:08:38,530
放在它们里面这么晚你基本上像这样使用它

241
00:08:38,530 --> 00:08:41,830
所以我定义了我的闩锁

242
00:08:41,830 --> 00:08:44,680
，这只是一个语法糖来

243
00:08:44,680 --> 00:08:47,350
声明一个原子 布尔值，然后我在

244
00:08:47,350 --> 00:08:49,600
这个 while 循环中尝试设置

245
00:08:49,600 --> 00:08:52,690
闩锁，如果它为零，我的单

246
00:08:52,690 --> 00:08:53,769
父交换指令

247
00:08:53,769 --> 00:08:56,350
设置我持有闩锁的那个，如果不是，那么我

248
00:08:56,350 --> 00:08:58,480
陷入这个疯狂的循环，

249
00:08:58,480 --> 00:09:00,819
决定要做什么和 然后

250
00:09:00,819 --> 00:09:02,920
回来再试一次，从旋转和

251
00:09:02,920 --> 00:09:05,290
燃烧执行燃烧循环，

252
00:09:05,290 --> 00:09:06,569
试图一遍又一遍地得到这个东西，

253
00:09:06,569 --> 00:09:08,769
所以棘手的部分显然在

254
00:09:08,769 --> 00:09:10,389
中间，这就是 Linus 的

255
00:09:10,389 --> 00:09:12,730
立场，决定在

256
00:09:12,730 --> 00:09:15,819
这里做什么是 很重要，你

257
00:09:15,819 --> 00:09:17,470
最终可能会做错事，这可能

258
00:09:17,470 --> 00:09:19,389
会导致操作系统做出重大的糟糕的骨架

259
00:09:19,389 --> 00:09:21,279
决定，就像你可能会立即产生那样

260
00:09:21,279 --> 00:09:23,470
，但那是你

261
00:09:23,470 --> 00:09:26,819
知道的，现在正在下降到西方，

262
00:09:26,819 --> 00:09:30,040
更多的系统调用和 ge 在

263
00:09:30,040 --> 00:09:32,879
数据库系统中速度较慢，就像

264
00:09:32,879 --> 00:09:36,129
他问的 BtoB 树中的

265
00:09:36,129 --> 00:09:37,480
类似情况一样，映射表 caprile

266
00:09:37,480 --> 00:09:38,769
交换操作与

267
00:09:38,769 --> 00:09:40,600
闩锁不是一回事，因为如果

268
00:09:40,600 --> 00:09:43,869
我试图 更新位置

269
00:09:43,869 --> 00:09:45,129
映射表没有得到它然后

270
00:09:45,129 --> 00:09:46,569
全部中止操作并重新启动

271
00:09:46,569 --> 00:09:48,730
或者我可以重试并

272
00:09:48,730 --> 00:09:51,220
重新开始，所以再次这是最

273
00:09:51,220 --> 00:09:55,360
简单的方法来做到这一点我们

274
00:09:55,360 --> 00:09:57,639
现在在我们的系统中使用a 我们实际上使用了一个自旋

275
00:09:57,639 --> 00:10:00,189
锁存器，它基本上

276
00:10:00,189 --> 00:10:00,910


277
00:10:00,910 --> 00:10:04,839
与英特尔编写的

278
00:10:04,839 --> 00:10:05,980
线程构建块

279
00:10:05,980 --> 00:10:08,470


280
00:10:08,470 --> 00:10:09,970


281
00:10:09,970 --> 00:10:12,399


282
00:10:12,399 --> 00:10:15,279
相同 它对现金不太友好，所以

283
00:10:15,279 --> 00:10:17,160
我的意思是说我有

284
00:10:17,160 --> 00:10:19,720
两个线程在不同的套接字上运行，

285
00:10:19,720 --> 00:10:21,759
并且他们都想在这里获取一些闩锁，

286
00:10:21,759 --> 00:10:23,589
所以会

287
00:10:23,589 --> 00:10:25,449
发生的事情是说这个东西被

288
00:10:25,449 --> 00:10:27,160
另一个甚至另一个线程持有 en 这些

289
00:10:27,160 --> 00:10:28,569
人只是要旋转并继续

290
00:10:28,569 --> 00:10:30,610
尝试调用 test 并

291
00:10:30,610 --> 00:10:32,350
再次打开尝试为这个人获取

292
00:10:32,350 --> 00:10:32,949


293
00:10:32,949 --> 00:10:34,720
这个内存对他来说是本地的我们将

294
00:10:34,720 --> 00:10:36,129
讨论新的 marva 纹理让它稍后

295
00:10:36,129 --> 00:10:37,779
但像这样的事情 暗淡的是

296
00:10:37,779 --> 00:10:39,879
它离这个插座更近，它可以

297
00:10:39,879 --> 00:10:41,110
比这里的另一个人更快地访问它

298
00:10:41,110 --> 00:10:42,759
，所以他可以有效地做到这一点，

299
00:10:42,759 --> 00:10:44,559
但是这里的这个人现在必须

300
00:10:44,559 --> 00:10:45,999
检查互连并说你

301
00:10:45,999 --> 00:10:47,379
一遍又一遍地知道这个东西已经设置好了

302
00:10:47,379 --> 00:10:48,790
设置好这个东西，然后每当

303
00:10:48,790 --> 00:10:50,290
其他人需要锁存器时，我们

304
00:10:50,290 --> 00:10:51,489
就必须执行缓存失效消息，

305
00:10:51,489 --> 00:10:52,540
因为我们知道这个人正在尝试

306
00:10:52,540 --> 00:10:55,839
读取它，所以从 cpu 的角度来看，最

307
00:10:55,839 --> 00:10:57,939
简单的自旋锁存器效率不高

308
00:10:57,939 --> 00:10:59,319
不可

309
00:10:59,319 --> 00:11:00,999
扩展，操作系统不会是

310
00:11:00,999 --> 00:11:02,470
不知道我们正在做的任何事情，

311
00:11:02,470 --> 00:11:07,149
所以他当时指的是什么

312
00:11:07,149 --> 00:11:07,610


313
00:11:07,610 --> 00:11:10,670
关于操作系统锁的权利，这

314
00:11:10,670 --> 00:11:13,390
有时被称为基本的操作系统互斥锁

315
00:11:13,390 --> 00:11:15,860
，基本思想在这里是 那我德 clare

316
00:11:15,860 --> 00:11:19,399
在 ela 下加上一个标准的互斥锁，

317
00:11:19,399 --> 00:11:21,500
然后它就像我之前的其他代码

318
00:11:21,500 --> 00:11:23,149
一样，但不是使用

319
00:11:23,149 --> 00:11:25,430
显式的自旋 while 循环，我正在

320
00:11:25,430 --> 00:11:27,050
旋转试图合唱锁，我只是

321
00:11:27,050 --> 00:11:29,240
说嘿，尝试锁定它，然后 在

322
00:11:29,240 --> 00:11:30,500
这种情况下，

323
00:11:30,500 --> 00:11:33,890
如果我不能得到它，我的线程将被阻塞，否则

324
00:11:33,890 --> 00:11:35,240
我会陷入临界区

325
00:11:35,240 --> 00:11:38,000
做我需要做的任何事情然后任何人都知道

326
00:11:38,000 --> 00:11:39,800
当你

327
00:11:39,800 --> 00:11:43,790
声明标准模板互斥锁时你必须得到

328
00:11:43,790 --> 00:11:46,910
什么你有什么 之前在一些文本下面，

329
00:11:46,910 --> 00:11:49,850
就像在你之前一样 - 是的，但就像

330
00:11:49,850 --> 00:11:52,720
前面有一个别名 -

331
00:11:52,720 --> 00:11:56,390
Peter mutex 对，PAF

332
00:11:56,390 --> 00:11:58,339
mutex 只是一些文本，

333
00:11:58,339 --> 00:12:01,730
除了处理一些 Tex 代表快速

334
00:12:01,730 --> 00:12:04,970
快速的用户空间互斥，那又怎样 它

335
00:12:04,970 --> 00:12:07,010
基本上是一个自旋锁和一个操作系统锁

336
00:12:07,010 --> 00:12:09,620
组合在一起，所以会发生什么是

337
00:12:09,620 --> 00:12:11,959
我开始用户空间锁存

338
00:12:11,959 --> 00:12:14,540
自旋锁然后操作系统锁

339
00:12:14,540 --> 00:12:16,339
在内核中所以如果我有两个线程

340
00:12:16,339 --> 00:12:18,890
出现并且他们都想要 访问 这

341
00:12:18,890 --> 00:12:20,750
是他们的人不会获得这个锁的

342
00:12:20,750 --> 00:12:22,100
权利说这整个事情代表一个

343
00:12:22,100 --> 00:12:25,339
单一的锁这个第一个人得到

344
00:12:25,339 --> 00:12:27,589
它第二个人没有所以然后他

345
00:12:27,589 --> 00:12:31,399
现在下降并等待

346
00:12:31,399 --> 00:12:33,290
内核锁存器的内核锁

347
00:12:33,290 --> 00:12:35,060
现在他得到了 D 时间表，时间表

348
00:12:35,060 --> 00:12:36,680
知道他正在等待这

349
00:12:36,680 --> 00:12:38,990
件事被发布，一旦发生，

350
00:12:38,990 --> 00:12:42,730
他就可以再次开始运行，

351
00:12:42,940 --> 00:12:49,040
所以这对，所以这部分很便宜，

352
00:12:49,040 --> 00:12:50,930
因为这只是一个测试和设置，

353
00:12:50,930 --> 00:12:53,630
然后和 再次在没有

354
00:12:53,630 --> 00:12:54,980
争用的情况下，这非常快，因为

355
00:12:54,980 --> 00:12:57,050
这只是在用户空间

356
00:12:57,050 --> 00:12:58,790
内存中

357
00:12:58,790 --> 00:12:59,959


358
00:12:59,959 --> 00:13:02,300


359
00:13:02,300 --> 00:13:04,339
闲逛 在这个很昂贵的东西上，

360
00:13:04,339 --> 00:13:06,320
因为这是一个 cisco get，在

361
00:13:06,320 --> 00:13:07,760
某些测量中，我们大约需要

362
00:13:07,760 --> 00:13:12,320
95 纳秒，这是非常

363
00:13:12,320 --> 00:13:14,839
正确的，就像在测试集案例中一样，

364
00:13:14,839 --> 00:13:17,120
这是一个单一的指令，

365
00:13:17,120 --> 00:13:18,470
可能取决于它是现金

366
00:13:18,470 --> 00:13:20,950
还是没有

367
00:13:20,950 --> 00:13:23,650
在这种情况下，它可能是获取该补丁的一个循环工具，

368
00:13:23,650 --> 00:13:25,060
因为我们正在深入内核，

369
00:13:25,060 --> 00:13:26,650
内核有自己的保护原语，

370
00:13:26,650 --> 00:13:31,510
然后这会变得昂贵，所以有

371
00:13:31,510 --> 00:13:33,580
什么更好的方法可以将这

372
00:13:33,580 --> 00:13:34,750
两者结合起来，但它仍然看起来 像

373
00:13:34,750 --> 00:13:35,830
一些文本一样，因为仍然有

374
00:13:35,830 --> 00:13:37,990
快速用户用户部分被称为

375
00:13:37,990 --> 00:13:41,170
自适应自旋锁，这里的想法

376
00:13:41,170 --> 00:13:44,890
是与自旋锁不同，我们旋转

377
00:13:44,890 --> 00:13:46,210
和用户空间永远不会再次

378
00:13:46,210 --> 00:13:51,610
尝试获取，也不同于快速用户

379
00:13:51,610 --> 00:13:54,310
互斥锁 我们立即尝试获取

380
00:13:54,310 --> 00:13:56,620
我们无法获取的闩锁，然后我们

381
00:13:56,620 --> 00:13:58,570
回到操作系统内核，您

382
00:13:58,570 --> 00:14:01,810
实际上可以做的是允许线程

383
00:14:01,810 --> 00:14:04,360
在用户空间锁上旋转

384
00:14:04,360 --> 00:14:06,280
一点，然后在某个时候 你放弃

385
00:14:06,280 --> 00:14:09,370
然后你回到操作系统

386
00:14:09,370 --> 00:14:11,410
内核 好吧 并尝试锁定那个

387
00:14:11,410 --> 00:14:13,300
东西 我们将称之为

388
00:14:13,300 --> 00:14:15,940
现在是用户空间 是这个

389
00:14:15,940 --> 00:14:17,800
停车场 你可以在用户空间中

390
00:14:17,800 --> 00:14:19,060
跟踪所有内容

391
00:14:19,060 --> 00:14:19,840
等待 t 的线程 你正在

392
00:14:19,840 --> 00:14:21,940
复制操作系统正在做的事情，但是

393
00:14:21,940 --> 00:14:23,200
因为它在用户空间中而不是

394
00:14:23,200 --> 00:14:25,330
辅助调用，你可能会

395
00:14:25,330 --> 00:14:28,690
在某些方面更快，然后

396
00:14:28,690 --> 00:14:30,820
会发生什么是如果一个新线程

397
00:14:30,820 --> 00:14:32,920
出现试图获取一个 闩锁 我们

398
00:14:32,920 --> 00:14:34,710
看到用户空间闩锁已经

399
00:14:34,710 --> 00:14:37,180
被持有，我们看到我们停车场的人

400
00:14:37,180 --> 00:14:38,830
正在或他们被

401
00:14:38,830 --> 00:14:41,890
阻止然后我们遇到李的去停车

402
00:14:41,890 --> 00:14:43,480
并说我们也在等待

403
00:14:43,480 --> 00:14:45,490
这个，我们没有 必须

404
00:14:45,490 --> 00:14:48,790
在停车场很好地关闭并阻止操作系统内核

405
00:14:48,790 --> 00:14:50,110
有很多

406
00:14:50,110 --> 00:14:52,450
事情会让我们按计划执行所以

407
00:14:52,450 --> 00:14:54,520
Apple有这个叫做WTF

408
00:14:54,520 --> 00:14:56,140
停车场锁或它代表的副锁的

409
00:14:56,140 --> 00:14:57,970
东西 像 WebKit 模板

410
00:14:57,970 --> 00:15:00,550
框架或其他东西，但这

411
00:15:00,550 --> 00:15:04,420
似乎是如果你不打算使用你知道你不使用

412
00:15:04,420 --> 00:15:06,250
的盲自旋锁

413
00:15:06,250 --> 00:15:08,110
哦，它会阻塞互斥锁，这可能

414
00:15:08,110 --> 00:15:10,750
是更好的方法，据说

415
00:15:10,750 --> 00:15:14,590
更好 使用尽管 Linus 不同意，所以这

416
00:15:14,590 --> 00:15:15,820
正是 超级家伙

417
00:15:15,820 --> 00:15:19,510
正在德国使用我们的 Umbra，

418
00:15:19,510 --> 00:15:21,070
其他人正在使用它，但这个名字请原谅

419
00:15:21,070 --> 00:15:22,270
我现在还有另一个数据系统

420
00:15:22,270 --> 00:15:23,800
也在考虑使用它，他们

421
00:15:23,800 --> 00:15:25,150
声称它比操作系统

422
00:15:25,150 --> 00:15:27,380
阻塞互斥锁好得多，是的，

423
00:15:27,380 --> 00:15:32,660
我想我认为 它应该适应

424
00:15:32,660 --> 00:15:40,210
自己，这是一个好的想法，所以好吧，

425
00:15:41,230 --> 00:15:43,970
实际上要快速返回另一

426
00:15:43,970 --> 00:15:45,110
件事要指出的另一件事就像在

427
00:15:45,110 --> 00:15:46,370
分配锁时操作系统阻止您的文本，

428
00:15:46,370 --> 00:15:48,170
就像分配

429
00:15:48,170 --> 00:15:50,540
互斥锁时分配用户空间一样

430
00:15:50,540 --> 00:15:53,810
一个和在这种情况下的 LS 锁在这里

431
00:15:53,810 --> 00:15:55,910
你实际上并没有分配操作系统锁，

432
00:15:55,910 --> 00:15:57,200
直到你真正需要阻止它

433
00:15:57,200 --> 00:15:59,000
直到你进入停车场

434
00:15:59,000 --> 00:16:02,090
，在苹果的 Warford WebKit 中，他们

435
00:16:02,090 --> 00:16:03,710
想要这个，因为我认为他们

436
00:16:03,710 --> 00:16:05,090
需要 每个 JavaScript 对象的锁存器都

437
00:16:05,090 --> 00:16:06,320
可以

438
00:16:06,320 --> 00:16:08,540
在 Java 运行时实例化或启动

439
00:16:08,540 --> 00:16:10,100
JavaScript 运行时，所以在那里

440
00:16:10,100 --> 00:16:12,170
他们在数据库系统中有很多锁存器

441
00:16:12,170 --> 00:16:13,700
是的，我们有很多节点 和

442
00:16:13,700 --> 00:16:16,190
RB 加 G 可能但不是那样的

443
00:16:16,190 --> 00:16:19,480
水平，也许他们正面临着问题，

444
00:16:19,480 --> 00:16:22,190
所以现在让我们谈谈

445
00:16:22,190 --> 00:16:23,600
一些更好的实现，我们可以

446
00:16:23,600 --> 00:16:27,080
在我们的基本闩锁

447
00:16:27,080 --> 00:16:29,720
原语之上构建这些实现，所以我用

448
00:16:29,720 --> 00:16:31,220
自旋盒展示的考试有 这个缓存

449
00:16:31,220 --> 00:16:33,440
一致性问题，如果两个套接字

450
00:16:33,440 --> 00:16:34,700
试图访问同一个锁存器，我们有

451
00:16:34,700 --> 00:16:36,530
流量转移到

452
00:16:36,530 --> 00:16:37,490
互连，一个人试图让

453
00:16:37,490 --> 00:16:39,020
每个人都试图在这个位置上旋转

454
00:16:39,020 --> 00:16:40,370
，我们必须向

455
00:16:40,370 --> 00:16:42,050


456
00:16:42,050 --> 00:16:44,900
你的每个线程发送失效消息 可以做一个多维数据集一个自旋锁

457
00:16:44,900 --> 00:16:47,780
，而不是让每个线程都

458
00:16:47,780 --> 00:16:50,630
阻塞在同一个内存位置，你

459
00:16:50,630 --> 00:16:52,340
可以将它们菊花链在一起，

460
00:16:52,340 --> 00:16:54,920
这样一个线程在一个位置

461
00:16:54,920 --> 00:16:56,450
阻塞，下一个线程在下一个

462
00:16:56,450 --> 00:16:57,590
位置阻塞，然后当你开始

463
00:16:57,590 --> 00:16:59,690
释放它们时 正确的方式

464
00:16:59,690 --> 00:17:02,810
通过队列传播，因此当您真正

465
00:17:02,810 --> 00:17:04,369
启动其中至少一个时，它只是

466
00:17:04,369 --> 00:17:05,480
一种缓存失效消息，

467
00:17:05,480 --> 00:17:06,770
因为只有一个线程是actua

468
00:17:06,770 --> 00:17:09,200
lly 一次在一个位置被阻止 所以让

469
00:17:09,200 --> 00:17:10,640
我说明一下我的意思吧

470
00:17:10,640 --> 00:17:12,589
所以这有时被称为 MCS 所以

471
00:17:12,589 --> 00:17:13,910
Linux 内核实际上将它用于

472
00:17:13,910 --> 00:17:16,369
内部其他

473
00:17:16,369 --> 00:17:18,470
系统的其他方面 Melora crumby 和 scott 是这个人的

474
00:17:18,470 --> 00:17:19,760
名字 这意味着这个所以如果

475
00:17:19,760 --> 00:17:22,040
你谷歌最好的googoo谁MCS自旋

476
00:17:22,040 --> 00:17:24,859
锁你会找到关于它的信息所以

477
00:17:24,859 --> 00:17:27,800
我们再次拥有他的基本闩锁这

478
00:17:27,800 --> 00:17:30,050
可能是他们总是阻止互斥

479
00:17:30,050 --> 00:17:31,700
停车场一个没关系

480
00:17:31,700 --> 00:17:34,700
然后我们现在有 我们的 CPU 运行

481
00:17:34,700 --> 00:17:36,590
正常，然后当他们想要

482
00:17:36,590 --> 00:17:38,270
获取这个锁存器时假设这个

483
00:17:38,270 --> 00:17:41,270
东西已经被其他人持有，

484
00:17:41,270 --> 00:17:43,370
我们现在要继续更新我们的

485
00:17:43,370 --> 00:17:45,440
指针以跟踪这是

486
00:17:45,440 --> 00:17:47,179
我们想要的下一个这是 下

487
00:17:47,179 --> 00:17:50,000
一个释放正确 好吧 抱歉

488
00:17:50,000 --> 00:17:51,830
犯了错误 让我有点这个人想要让

489
00:17:51,830 --> 00:17:53,779
这个闩锁安静 它没有被

490
00:17:53,779 --> 00:17:55,610
正确握住所以他会站着 她吃

491
00:17:55,610 --> 00:17:58,850
了这个提示中的这个新闩锁占位符

492
00:17:58,850 --> 00:18:01,549
现在继续并通过设置获得睫毛

493
00:18:01,549 --> 00:18:03,559
指向现在这个新位置的指针就

494
00:18:03,559 --> 00:18:06,320
在这里，一旦完成，

495
00:18:06,320 --> 00:18:07,940
我将进行比较和交换，我们持有我们

496
00:18:07,940 --> 00:18:10,340
现在持有这个闩锁，当另一个威胁

497
00:18:10,340 --> 00:18:12,200
出现时，他们将尝试获取

498
00:18:12,200 --> 00:18:14,450
此闩锁，看到此指针已设置并

499
00:18:14,450 --> 00:18:15,890
意识到他们可以 't send 他们无法

500
00:18:15,890 --> 00:18:18,200
获取它所以而不是在

501
00:18:18,200 --> 00:18:19,640
此旋转并尝试进行测试并设置以

502
00:18:19,640 --> 00:18:21,620
查看我是否可以正确获取它

503
00:18:21,620 --> 00:18:23,179
然后他们将按照此处的指针

504
00:18:23,179 --> 00:18:25,960
查看此内容现在未设置

505
00:18:25,960 --> 00:18:28,070
更新其指针 准备好并

506
00:18:28,070 --> 00:18:30,350
交换它现在它有点声称

507
00:18:30,350 --> 00:18:33,049
在队列中的这个位置

508
00:18:33,049 --> 00:18:36,770
然后它在这个正确的相同的东西上旋转

509
00:18:36,770 --> 00:18:39,440
等等，好吧那么

510
00:18:39,440 --> 00:18:41,539
现在会发生什么是如果这个人

511
00:18:41,539 --> 00:18:43,880
最终释放闩锁正确它

512
00:18:43,880 --> 00:18:45,470
然后会得到通知，这东西被

513
00:18:45,470 --> 00:18:47,029
释放了，然后这个人会让

514
00:18:47,029 --> 00:18:49,600
你知道接下来拿闩锁

515
00:18:49,600 --> 00:18:52,850
，这很好，因为再次像这样

516
00:18:52,850 --> 00:18:54,350
可以在一个看到我，

517
00:18:54,350 --> 00:18:56,240
这可能是一个插槽上的一个内存区域，

518
00:18:56,240 --> 00:18:57,289
这可能 在 另一个

519
00:18:57,289 --> 00:18:59,299
区域，它们只是可能

520
00:18:59,299 --> 00:19:01,490
在本地旋转 不会转到某个

521
00:19:01,490 --> 00:19:13,370
远程内存位置 是的，如果我发布了

522
00:19:13,370 --> 00:19:16,730
这个，我和四个出现了他们

523
00:19:16,730 --> 00:19:19,760
跟随的地方 是的，我认为线路有点

524
00:19:19,760 --> 00:19:21,200
糟糕 这东西实际上正在旋转

525
00:19:21,200 --> 00:19:22,520
，因为它 等待这个东西

526
00:19:22,520 --> 00:19:24,409
在那里被释放，这个

527
00:19:24,409 --> 00:19:26,750
指针被设置回零所以这

528
00:19:26,750 --> 00:19:27,980
是每个人总是必须从这里开始

529
00:19:27,980 --> 00:19:30,950
遍历，是的，现在棘手的

530
00:19:30,950 --> 00:19:34,610
事情也就像在我的例子中说的一样，

531
00:19:34,610 --> 00:19:35,809
每个人都在等待获取

532
00:19:35,809 --> 00:19:37,370
锁上的你总是想

533
00:19:37,370 --> 00:19:40,039
这样做，但如果我喜欢我买了我的

534
00:19:40,039 --> 00:19:42,169
手术，如果我尝试旋转太

535
00:19:42,169 --> 00:19:44,120
多次，喜欢这个家伙

536
00:19:44,120 --> 00:19:46,039
现在消失了，我需要重新连接

537
00:19:46,039 --> 00:19:48,649
它们，因为我有这个洞和那个

538
00:19:48,649 --> 00:19:50,899
如果你

539
00:19:50,899 --> 00:19:52,279
总是知道我会永远阻止

540
00:19:52,279 --> 00:19:53,899
并且在 David ISM 的某些部分你

541
00:19:53,899 --> 00:19:54,210
将

542
00:19:54,210 --> 00:19:55,740
永远阻止 - 电视让你做

543
00:19:55,740 --> 00:19:57,330
一些事情那么这很好但是如果你

544
00:19:57,330 --> 00:19:59,490
需要在不同的地方拉出来 t

545
00:19:59,490 --> 00:20:02,570
位置然后它变得更难

546
00:20:02,570 --> 00:20:17,400
是的，就像

547
00:20:17,400 --> 00:20:18,450
我在这里实际做的事情一样，我正在

548
00:20:18,450 --> 00:20:25,740
等待我实际在做的事情可能会

549
00:20:25,740 --> 00:20:28,200
旋转或 - 可能会被

550
00:20:28,200 --> 00:20:34,140
换掉，你是否为此发出信号 可能

551
00:20:34,140 --> 00:20:36,150
这取决于位置我实际上我

552
00:20:36,150 --> 00:20:39,530
不知道对你可以只是

553
00:20:39,530 --> 00:20:41,190
增加你

554
00:20:41,190 --> 00:20:42,570
让你等待的时间因为它需要

555
00:20:42,570 --> 00:20:48,960
更长的时间你可以做一个信号是的我

556
00:20:48,960 --> 00:20:50,340
认为它在四月版结束我不

557
00:20:50,340 --> 00:20:51,210
不知道你会做什么 我不

558
00:20:51,210 --> 00:20:54,690
知道上校做什么好了 所以

559
00:20:54,690 --> 00:20:56,310
最后一个可能

560
00:20:56,310 --> 00:20:57,570
对数据库以及

561
00:20:57,570 --> 00:20:59,910
读写器锁存器非常重要，这里的基本思想

562
00:20:59,910 --> 00:21:02,010
就像我们想要的

563
00:21:02,010 --> 00:21:03,510
在两相锁定下，我们有多个

564
00:21:03,510 --> 00:21:05,790
读取器，一个元组和一个写入器，

565
00:21:05,790 --> 00:21:08,640
我们希望斜杠中的内容相同，

566
00:21:08,640 --> 00:21:10,500
因此基本上您

567
00:21:10,500 --> 00:21:12,870
现在需要维护两个锁存器，然后

568
00:21:12,870 --> 00:21:16,980
提示哪些线程正在等待

569
00:21:16,980 --> 00:21:18,900
获取 闩锁然后我们现在就可以

570
00:21:18,900 --> 00:21:21,090
做出决定了

571
00:21:21,090 --> 00:21:22,530
如果我们在双方都有线索，那么谁应该实际获得闩锁

572
00:21:22,530 --> 00:21:24,960
所以说线程

573
00:21:24,960 --> 00:21:27,000
出现他想要读取闩锁

574
00:21:27,000 --> 00:21:30,930
写入器线程的数量为零

575
00:21:30,930 --> 00:21:32,820
阅读器的数量为零所以这

576
00:21:32,820 --> 00:21:34,020
意味着我们能够获取闩锁

577
00:21:34,020 --> 00:21:35,340
我们只是做一个比较和交换来使

578
00:21:35,340 --> 00:21:37,860
这个计数器增加一个下一个人

579
00:21:37,860 --> 00:21:39,150
出现同样的事情想要一个读

580
00:21:39,150 --> 00:21:41,310
锁存器我们已经有一个线程他们

581
00:21:41,310 --> 00:21:43,110
将持有读锁存器所以这

582
00:21:43,110 --> 00:21:44,580
可以共享所以我们允许他

583
00:21:44,580 --> 00:21:46,650
继续 并且和并且获得了他

584
00:21:46,650 --> 00:21:48,660
现在更新计数器现在我们的写入

585
00:21:48,660 --> 00:21:50,340
线程出现尝试获取

586
00:21:50,340 --> 00:21:52,680
正确的闩锁不能这样做因为

587
00:21:52,680 --> 00:21:54,240
读取闩锁当前由

588
00:21:54,240 --> 00:21:56,610
两个线程持有所以我们继续将自己

589
00:21:56,610 --> 00:21:59,790
排队等待另一个线程

590
00:21:59,790 --> 00:22:01,170
随之而来的事情是进行读取，

591
00:22:01,170 --> 00:22:03,290
我们可以让它立即获取读取

592
00:22:03,290 --> 00:22:05,610
闩锁并让它运行，但

593
00:22:05,610 --> 00:22:07,440
当然这可能会使写入器挨饿，因此

594
00:22:07,440 --> 00:22:08,220
我们将阻止

595
00:22:08,220 --> 00:22:10,980
天空更新其计数器为一个，

596
00:22:10,980 --> 00:22:13,140
一旦这些人离开 走那么这个顾 你

597
00:22:13,140 --> 00:22:16,230
可以得到规律 锁存器 我

598
00:22:16,230 --> 00:22:18,270
只是对数据系统的所有不同部分有用

599
00:22:18,270 --> 00:22:27,929
所以今天的问题

600
00:22:27,929 --> 00:22:29,820
是使用自旋锁存器

601
00:22:29,820 --> 00:22:31,320
在那里

602
00:22:31,320 --> 00:22:34,530
像纳米睡眠或其他使之类的睡眠有意义

603
00:22:34,530 --> 00:22:37,830
吗？ 我不是在燃烧周期，这

604
00:22:37,830 --> 00:22:38,820
可能会让他们总是做其他

605
00:22:38,820 --> 00:22:42,179
事情的潜力是的，但是有这种权衡，

606
00:22:42,179 --> 00:22:45,929
就像我是否

607
00:22:45,929 --> 00:22:48,720
在那里睡了一些时间一样，事实上你

608
00:22:48,720 --> 00:22:49,860
在这一点上到达线很难

609
00:22:49,860 --> 00:22:51,240
如果我在那里睡一觉，

610
00:22:51,240 --> 00:22:53,880
那就对了，然后是的，我可以释放 CPU

611
00:22:53,880 --> 00:22:55,770
来做其他事情，但是现在

612
00:22:55,770 --> 00:22:57,360
这意味着当

613
00:22:57,360 --> 00:22:58,950
我真正可以使用它们时，

614
00:22:58,950 --> 00:23:00,809
我可能会等待更长时间

615
00:23:00,809 --> 00:23:02,460
才能继续 并拿起它并运行但是

616
00:23:02,460 --> 00:23:03,870
现在如果我走另一个方向我会让

617
00:23:03,870 --> 00:23:05,400
我的睡眠时间变得非常小现在我正在

618
00:23:05,400 --> 00:23:07,380
燃烧周期并且 CPU 看起来很忙

619
00:23:07,380 --> 00:23:10,080
但它没有做任何有用的事情所以

620
00:23:10,080 --> 00:23:12,330
我再次考虑项目一个 CPU 时

621
00:23:12,330 --> 00:23:13,770
你用完了很多，我们做一个

622
00:23:13,770 --> 00:23:15,690
基准测试 给你们这些内核的

623
00:23:15,690 --> 00:23:18,150
峰值为 100% 为什么因为它们都在

624
00:23:18,150 --> 00:23:19,620
旋转或试图合唱那个闩锁

625
00:23:19,620 --> 00:23:22,850
因为英特尔的一个偶像事情产生

626
00:23:22,850 --> 00:23:24,990
了我们正在使用的英特尔闩锁没有

627
00:23:24,990 --> 00:23:31,590
产生好所以现在我想

628
00:23:31,590 --> 00:23:32,730
简单谈谈 关于如何

629
00:23:32,730 --> 00:23:35,039
在 B+ 树中进行闩锁旅行和耦合，所以

630
00:23:35,039 --> 00:23:36,510
在介绍类中，我们描述了

631
00:23:36,510 --> 00:23:38,460
B+ 树是同一件事，在内存

632
00:23:38,460 --> 00:23:40,919
数据库

633
00:23:40,919 --> 00:23:43,289
中，我们的节点中有键值数组，只有叶节点

634
00:23:43,289 --> 00:23:44,700
包含指向元组的实际指针

635
00:23:44,700 --> 00:23:46,049
然后上面的所有其他内容都

636
00:23:46,049 --> 00:23:48,780
只是指南，所以为什么

637
00:23:48,780 --> 00:23:51,000
要使用 B+ 树，这与

638
00:23:51,000 --> 00:23:52,289
我们希望您成为双树

639
00:23:52,289 --> 00:23:53,789
或任何其他保留顺序的数据

640
00:23:53,789 --> 00:23:55,470
结构的原因相同，因为现在我们

641
00:23:55,470 --> 00:24:00,539
在 log n 中进行查找 所以我们

642
00:24:00,539 --> 00:24:02,520
上学期讨论了闩锁螃蟹耦合，

643
00:24:02,520 --> 00:24:03,750
但现在我想更详细地讨论

644
00:24:03,750 --> 00:24:06,120
一下，因为我们了解功率实际上可以

645
00:24:06,120 --> 00:24:08,370
潜在地实现闩锁或我们的

646
00:24:08,370 --> 00:24:10,080
闩锁，然后我们将讨论

647
00:24:10,080 --> 00:24:12,630
来自超级的闩锁的变体

648
00:24:12,630 --> 00:24:16,169
对于不一定特定

649
00:24:16,169 --> 00:24:18,240
于 B+ 树的艺术，他们实际上确实

650
00:24:18,240 --> 00:24:19,590
在艺术中使用了相同的技术，但我将在人们的树

651
00:24:19,590 --> 00:24:21,350
的 a 的上下文中展示它，

652
00:24:21,350 --> 00:24:25,940
所以这里的想法

653
00:24:25,940 --> 00:24:26,960
是因为每个人都允许

654
00:24:26,960 --> 00:24:28,660
并发 访问我们的数据结构，

655
00:24:28,660 --> 00:24:31,430
我们必须保护它，

656
00:24:31,430 --> 00:24:32,540
显然要做的是

657
00:24:32,540 --> 00:24:34,190
用整个树的单个闩锁来保护它，

658
00:24:34,190 --> 00:24:35,420
当然这很愚蠢，因为现在

659
00:24:35,420 --> 00:24:37,160
变成了单线程，所以我们

660
00:24:37,160 --> 00:24:39,320
要做的就像线程一样 开始

661
00:24:39,320 --> 00:24:41,330
遍历我们想要

662
00:24:41,330 --> 00:24:43,280
获取闩锁的树，当我们下降时，我们

663
00:24:43,280 --> 00:24:46,370
只想

664
00:24:46,370 --> 00:24:48,890
在我们知道

665
00:24:48,890 --> 00:24:51,140
我们所在的节点是安全的并且我们正在

666
00:24:51,140 --> 00:24:52,970
根据操作定义安全含义时释放我们上方的闩锁

667
00:24:52,970 --> 00:24:54,800
我们正在做，我们知道在我们

668
00:24:54,800 --> 00:24:57,530
下方或我们所在的节点不会有任何拆分或合并

669
00:24:57,530 --> 00:24:59,870
，这将导致

670
00:24:59,870 --> 00:25:01,310
我们必须在

671
00:25:01,310 --> 00:25:03,860
树中的我们上方进行更改，因此一旦我们知道我们处于

672
00:25:03,860 --> 00:25:05,660
到处说我知道这是安全的我们

673
00:25:05,660 --> 00:25:07,610
释放我们的任何闩锁 已经

674
00:25:07,610 --> 00:25:09,200
在下降的过程中需要，然后现在虽然

675
00:25:09,200 --> 00:25:10,580
威胁可能会在我们身后并开始

676
00:25:10,580 --> 00:25:12,620
进行查找或修改，

677
00:25:12,620 --> 00:25:14,000
因为它们可能会沿着

678
00:25:14,000 --> 00:25:17,300
树中的不同路径前进，所以

679
00:25:17,300 --> 00:25:19,760
首先是最基本的搜索协议，

680
00:25:19,760 --> 00:25:21,320
因为我们不是 修改

681
00:25:21,320 --> 00:25:23,840
数据库我们只需要一个一个

682
00:25:23,840 --> 00:25:25,610
地关闭闩锁，然后一旦我们到达一个节点，

683
00:25:25,610 --> 00:25:27,800
我们就可以释放父节点上引脚上的闩锁

684
00:25:27,800 --> 00:25:28,820


685
00:25:28,820 --> 00:25:31,340
，因为一旦

686
00:25:31,340 --> 00:25:32,930
我们知道一个 锁存器被

687
00:25:32,930 --> 00:25:35,000
认为是安全的我们可以释放

688
00:25:35,000 --> 00:25:36,320
我们在下降过程中获得的所有正确的锁存器

689
00:25:36,320 --> 00:25:40,640
所以再次搜索的基本基本

690
00:25:40,640 --> 00:25:42,860
操作是我想在这里查找键

691
00:25:42,860 --> 00:25:45,410
23所以在这个第一个节点

692
00:25:45,410 --> 00:25:47,480
获取读取锁存器 然后我

693
00:25:47,480 --> 00:25:49,910
向下遍历到这个节点这里和

694
00:25:49,910 --> 00:25:51,800
此时这里 因为我正在做并且

695
00:25:51,800 --> 00:25:54,200
只是查找我永远不会

696
00:25:54,200 --> 00:25:56,600
回到根节点 a 所以

697
00:25:56,600 --> 00:25:58,640
我可以安全地释放那个闩锁，这是

698
00:25:58,640 --> 00:25:59,900
为什么它被称为某种螃蟹 b

699
00:25:59,900 --> 00:26:01,190
因为它就像一只螃蟹走路

700
00:26:01,190 --> 00:26:03,500
一样，一条腿向前，然后另一条腿，然后

701
00:26:03,500 --> 00:26:06,650


702
00:26:06,650 --> 00:26:08,660


703
00:26:08,660 --> 00:26:10,100


704
00:26:10,100 --> 00:26:11,450
来回走 然后

705
00:26:11,450 --> 00:26:13,570
我们到这里去 FM 在 23 上做我们的读取

706
00:26:13,570 --> 00:26:16,970
读取现在我没有做删除

707
00:26:16,970 --> 00:26:18,890
开始从开始我们

708
00:26:18,890 --> 00:26:21,020
采取写锁存下来这里

709
00:26:21,020 --> 00:26:23,270
在 C 上进行写锁存现在在这一点上 在这里，

710
00:26:23,270 --> 00:26:25,490
因为我们要进行删除，我们不

711
00:26:25,490 --> 00:26:28,550
知道树中我们下面是什么，所以如果

712
00:26:28,550 --> 00:26:31,160
我们在这里删除导致

713
00:26:31,160 --> 00:26:33,350
我们必须进行合并，我们最终可能会

714
00:26:33,350 --> 00:26:35,090
在这里丢失我们的密钥

715
00:26:35,090 --> 00:26:37,010
，现在这个注释会 是空的但是

716
00:26:37,010 --> 00:26:39,050
因为它是一个 P plus 树必须

717
00:26:39,050 --> 00:26:41,630
至少是半满所以我们下面可能有一个变化

718
00:26:41,630 --> 00:26:43,310
导致这个东西被

719
00:26:43,310 --> 00:26:44,690
合并，这意味着这里的更新指针是什么

720
00:26:44,690 --> 00:26:47,120
所以

721
00:26:47,120 --> 00:26:49,280
我们释放它是不安全的

722
00:26:49,280 --> 00:26:54,110
在这一点上的闩锁所以然后我们

723
00:26:54,110 --> 00:26:56,480
归结到 W 我们开始到 G 我们

724
00:26:56,480 --> 00:26:58,640
在这个 po 上删除 44 在这里我们知道

725
00:26:58,640 --> 00:27:00,320
我们不需要合并，

726
00:27:00,320 --> 00:27:03,140
因为如果我们删除 44 那么我们的笔记仍然是

727
00:27:03,140 --> 00:27:05,210
半满所以我们上面的一切

728
00:27:05,210 --> 00:27:06,980
都是安全的，我们继续释放

729
00:27:06,980 --> 00:27:09,440
那些闩锁，然后现在

730
00:27:09,440 --> 00:27:11,900
我们可以走了 提前删除我们的钥匙 看到

731
00:27:11,900 --> 00:27:13,580
这个想法是

732
00:27:13,580 --> 00:27:15,530
当我们知道我们

733
00:27:15,530 --> 00:27:17,450
不需要去的时候我们会尽快释放我们的睫毛 我们永远不会

734
00:27:17,450 --> 00:27:21,200
在我们上面做任何改变所以我们想

735
00:27:21,200 --> 00:27:22,490
在我们实际之前释放闩锁

736
00:27:22,490 --> 00:27:24,650
做我们的删除一切正常，因为

737
00:27:24,650 --> 00:27:26,090
我要尽早释放闩锁，

738
00:27:26,090 --> 00:27:27,890
以便其他线程可以正常

739
00:27:27,890 --> 00:27:31,760
前进，所以插入 40

740
00:27:31,760 --> 00:27:34,490
正确地采取正确的闩锁，采取

741
00:27:34,490 --> 00:27:36,710
正确的襟翼 Chauncey 现在在这种情况下，

742
00:27:36,710 --> 00:27:39,260
我们知道如果我们必须这样做

743
00:27:39,260 --> 00:27:41,900
我们下面的一个分裂看到有一个额外的空间可以放

744
00:27:41,900 --> 00:27:44,030
另一个键所以我们不必

745
00:27:44,030 --> 00:27:46,100
我们不必分裂这个人所以

746
00:27:46,100 --> 00:27:48,380
我们可以安全地释放闩锁或名字然后我们

747
00:27:48,380 --> 00:27:51,410
在这种情况下来到这里没有G 在

748
00:27:51,410 --> 00:27:53,270
这里我们想开始一个关键我们

749
00:27:53,270 --> 00:27:55,220
没有更多的空间我们' 将不得不

750
00:27:55,220 --> 00:27:56,750
拆分它，因此我们必须

751
00:27:56,750 --> 00:27:59,270
保持正确的闩锁，不会

752
00:27:59,270 --> 00:28:01,610
在其上方看到它，以便我们可以

753
00:28:01,610 --> 00:28:04,070
在此处使用我们的新指针或他们的新指针更新它

754
00:28:04,070 --> 00:28:05,960
，然后

755
00:28:05,960 --> 00:28:07,640
在完成后释放

756
00:28:07,640 --> 00:28:10,010
锁上 C 然后释放 G 上的锁

757
00:28:10,010 --> 00:28:11,450
好吧 我们最近总是从上到下释放锁

758
00:28:11,450 --> 00:28:16,940


759
00:28:16,940 --> 00:28:18,800


760
00:28:18,800 --> 00:28:20,710


761
00:28:20,710 --> 00:28:23,600


762
00:28:23,600 --> 00:28:25,820


763
00:28:25,820 --> 00:28:27,620
我做的第一件事是在根上获取一个正确的闩锁

764
00:28:27,620 --> 00:28:29,720
，然后转到下一个

765
00:28:29,720 --> 00:28:31,640
孩子，这意味着每个

766
00:28:31,640 --> 00:28:32,870
线程都试图更新数据的 F

767
00:28:32,870 --> 00:28:35,300
更新索引实际上任何威胁也

768
00:28:35,300 --> 00:28:36,890
试图读取索引将被

769
00:28:36,890 --> 00:28:38,930
阻止 任何时候我有一个作家，因为

770
00:28:38,930 --> 00:28:40,820
他们总是在根上采取正确的闩锁，

771
00:28:40,820 --> 00:28:43,730
所以更好的方法是保持

772
00:28:43,730 --> 00:28:46,700
乐观并假设当我到达

773
00:28:46,700 --> 00:28:47,890
我的叶节点时

774
00:28:47,890 --> 00:28:49,060
它不会通过分裂或

775
00:28:49,060 --> 00:28:51,280
合并，因此我 可以一直向下走真正的

776
00:28:51,280 --> 00:28:52,930
ch 然后就

777
00:28:52,930 --> 00:28:55,000
在我到达我的叶节点之前或在

778
00:28:55,000 --> 00:28:57,070
叶节点我进行右闩锁检查以

779
00:28:57,070 --> 00:28:59,110
查看我的假设是否

780
00:28:59,110 --> 00:29:03,790


781
00:29:03,790 --> 00:29:05,200
不正确 我不会做一个

782
00:29:05,200 --> 00:29:07,120
拆分器合并是正确的然后我用

783
00:29:07,120 --> 00:29:08,650
正确的闩锁来做我的更改

784
00:29:08,650 --> 00:29:11,050
如果我不正确那么我可以再

785
00:29:11,050 --> 00:29:12,400
回来现在把更

786
00:29:12,400 --> 00:29:13,840
重量级的正确闩锁一直

787
00:29:13,840 --> 00:29:16,870
向下 所以让我们看看我们的两个

788
00:29:16,870 --> 00:29:20,440
例子 44 后期然后插入 所以

789
00:29:20,440 --> 00:29:22,360
我将在乐观的方法下再次删除 44

790
00:29:22,360 --> 00:29:24,430
我

791
00:29:24,430 --> 00:29:27,070
采取读锁存器 在这一点上再次使用读锁存器

792
00:29:27,070 --> 00:29:28,450
我不会回到根

793
00:29:28,450 --> 00:29:29,740
所以它 好的，现在释放闩锁，

794
00:29:29,740 --> 00:29:33,760
我到了这里，然后我可以释放

795
00:29:33,760 --> 00:29:35,350
闩锁，看看这是我的假设，

796
00:29:35,350 --> 00:29:37,870
当我删除是正确的时，我不必进行合并，

797
00:29:37,870 --> 00:29:39,640
所以我

798
00:29:39,640 --> 00:29:41,350
现在可以继续执行此操作 飞跃，

799
00:29:41,350 --> 00:29:42,490
而不是一直向下的 hagun 右侧闩锁

800
00:29:42,490 --> 00:29:45,790
，我向右读取闩锁，

801
00:29:45,790 --> 00:29:48,100
然后 y 你对插入做同样的事情，

802
00:29:48,100 --> 00:29:52,060
所以这很清楚，所以有

803
00:29:52,060 --> 00:29:56,890
更好的方法，我们

804
00:29:56,890 --> 00:30:00,340
可以避免阻塞读者的读者

805
00:30:00,340 --> 00:30:01,960
或抱歉

806
00:30:01,960 --> 00:30:06,190
阻止读者的作者，因为根本没有

807
00:30:06,190 --> 00:30:07,030
正确的闩锁

808
00:30:07,030 --> 00:30:10,540
抱歉闩锁，这里的想法

809
00:30:10,540 --> 00:30:15,130
是允许线程在

810
00:30:15,130 --> 00:30:17,980
它们下降时读取它们想要的任何东西，但是

811
00:30:17,980 --> 00:30:20,020
在它们完成对节点的访问之后，

812
00:30:20,020 --> 00:30:22,180
您检查它是否

813
00:30:22,180 --> 00:30:25,090
从您开始读取它时起被修改

814
00:30:25,090 --> 00:30:28,510
，如果没有然后 你知道没有作者

815
00:30:28,510 --> 00:30:29,710
进来修改它，

816
00:30:29,710 --> 00:30:31,870
如果你确实看到修改，你就沿着树往下走，

817
00:30:31,870 --> 00:30:33,430
然后你意识到

818
00:30:33,430 --> 00:30:34,840
在你假释之前有其他人进来了你

819
00:30:34,840 --> 00:30:37,660
完成了然后你就重新启动这样

820
00:30:37,660 --> 00:30:39,340
就没有

821
00:30:39,340 --> 00:30:41,380
了，不再有读锁存器了 存在写锁存器

822
00:30:41,380 --> 00:30:43,510
以防止写锁存器

823
00:30:43,510 --> 00:30:45,330
同时修改同一个音符，

824
00:30:45,330 --> 00:30:47,710
但任何正在阅读整个

825
00:30:47,710 --> 00:30:49,390
内容的人都不会阻止任何正确的

826
00:30:49,390 --> 00:30:51,700
任何正确的锁存器

827
00:30:51,700 --> 00:30:56,740
等等 他因为现在我们

828
00:30:56,740 --> 00:30:58,360
有我们可以

829
00:30:58,360 --> 00:31:00,610
做的拆分和合并的问题 现在

830
00:31:00,610 --> 00:31:01,660
因为没有真正的

831
00:31:01,660 --> 00:31:02,590
我们不知道

832
00:31:02,590 --> 00:31:04,960
当我们开始删除东西时是否有人正在阅读某些

833
00:31:04,960 --> 00:31:07,780
东西我们在那个场景中执行相同的时代

834
00:31:07,780 --> 00:31:09,220
垃圾收集 我们上次

835
00:31:09,220 --> 00:31:11,290
在 BW 树中做了，所以我们知道

836
00:31:11,290 --> 00:31:12,970


837
00:31:12,970 --> 00:31:14,320
当我们不知道它们

838
00:31:14,320 --> 00:31:14,500


839
00:31:14,500 --> 00:31:17,080
在我们的时代中的位置时，我们的索引中可能有一个线程挂起，所以

840
00:31:17,080 --> 00:31:18,850
继续清理节点是不安全的 然而

841
00:31:18,850 --> 00:31:20,440
，一旦每个人都离开了这个时代，

842
00:31:20,440 --> 00:31:23,050
我们就可以继续清理它，所以让我们

843
00:31:23,050 --> 00:31:25,750
在这里看一个例子，所以现在每个

844
00:31:25,750 --> 00:31:27,430
节点都会有这个原始计数器

845
00:31:27,430 --> 00:31:30,070
在标头中只有 16 位或 32 位

846
00:31:30,070 --> 00:31:32,560
，表示这是版本

847
00:31:32,560 --> 00:31:35,560
这个节点的任何时候，只要你修改它

848
00:31:35,560 --> 00:31:38,070
只会增加一个反向计数器，

849
00:31:38,070 --> 00:31:41,590
所以说我们想在 44 上进行搜索，

850
00:31:41,590 --> 00:31:45,280
所以我们从节点 a 开始，

851
00:31:45,280 --> 00:31:46,630
我们要做的第一件事

852
00:31:46,630 --> 00:31:48,220
就是版本号是什么 对于这个

853
00:31:48,220 --> 00:31:50,190
节点，我们可以保持 tra  ck 我们

854
00:31:50,190 --> 00:31:54,250
在版本 3 中读取节点 a 然后我们

855
00:31:54,250 --> 00:31:56,020
检查节点在这种情况下做我们需要做的任何事情在

856
00:31:56,020 --> 00:31:57,400
这里我们搜索 44

857
00:31:57,400 --> 00:31:59,710
所以 44 大于 20 所以我们会

858
00:31:59,710 --> 00:32:01,360
知道我们会在这一边走下去

859
00:32:01,360 --> 00:32:03,370
所以我们继续这样做，

860
00:32:03,370 --> 00:32:07,030
现在我们在节点哔声，我们

861
00:32:07,030 --> 00:32:10,660
需要做的是在这里阅读我们

862
00:32:10,660 --> 00:32:13,270
的版本，然后返回并阅读

863
00:32:13,270 --> 00:32:16,140
我们知道的我们刚刚来自的节点的版本我

864
00:32:16,140 --> 00:32:18,700
维护

865
00:32:18,700 --> 00:32:20,980
当我们向下遍历时，一堆节点的指针，所以我们

866
00:32:20,980 --> 00:32:22,330
回过头看看我们从哪里来，

867
00:32:22,330 --> 00:32:24,130
然后我们检查这个

868
00:32:24,130 --> 00:32:27,550
版本自

869
00:32:27,550 --> 00:32:30,520
我们最初开始阅读以来是否已经改变，如果没有，

870
00:32:30,520 --> 00:32:32,530
那么我们知道 没有人修改它，如果

871
00:32:32,530 --> 00:32:35,320
它被改变了，那么我们必须进行边界

872
00:32:35,320 --> 00:32:36,850
操作，因为有人在这里做了一些

873
00:32:36,850 --> 00:32:38,620
我们错过的事情，我们应该

874
00:32:38,620 --> 00:32:40,630
看到并想回去重新开始，

875
00:32:40,630 --> 00:32:43,840
因为有人可以

876
00:32:43,840 --> 00:32:46,570
在这里修改这个节点的索引

877
00:32:46,570 --> 00:32:50,200
和正确的 指向

878
00:32:50,200 --> 00:32:51,760
此键右侧的指针是 现在这里有一些其他的

879
00:32:51,760 --> 00:32:54,580
内存位置，我们沿着

880
00:32:54,580 --> 00:32:57,550
旧路径沿着旧路径走，我们下面可能有

881
00:32:57,550 --> 00:33:00,100
垃圾，所以什么会中止

882
00:33:00,100 --> 00:33:04,080
我们自己并重新启动是的

883
00:33:06,740 --> 00:33:08,520
问题为什么不一直走

884
00:33:08,520 --> 00:33:14,460
叶子，确实很抱歉他的问题

885
00:33:14,460 --> 00:33:15,800
是为什么 不要一路走，叶子

886
00:33:15,800 --> 00:33:18,270
基本上不要在这里重新检查

887
00:33:18,270 --> 00:33:20,640
，一直走到底部，

888
00:33:20,640 --> 00:33:22,980
指针将是民谣我认为他

889
00:33:22,980 --> 00:33:25,890
是真的，是的，指针是有效的，因为

890
00:33:25,890 --> 00:33:28,740
那里你不能清理 在你切换时代之前有什么事情

891
00:33:28,740 --> 00:33:31,020
所以我到了

892
00:33:31,020 --> 00:33:33,090
底部，现在我说好吧，

893
00:33:33,090 --> 00:33:35,820
我读了所有的处女或任何

894
00:33:35,820 --> 00:33:38,820
转移的变化，如果知道我很好，

895
00:33:38,820 --> 00:33:42,840
如果是，然后重新启动，那么在这种情况下，我的

896
00:33:42,840 --> 00:33:44,790
意思是它的排序 就像我们谈论蝉一样的 OCC

897
00:33:44,790 --> 00:33:46,710
如果你是如果

898
00:33:46,710 --> 00:33:48,390
有冲突并且你

899
00:33:48,390 --> 00:33:50,490
很无聊也许你想早点中止，

900
00:33:50,490 --> 00:33:51,660
这样你就不会

901
00:33:51,660 --> 00:33:53,010
做很多最终被浪费的工作，

902
00:33:53,010 --> 00:33:55,680
但是 做这个重新检查很便宜，

903
00:33:55,680 --> 00:33:56,880
它只是读取那个内存位置

904
00:33:56,880 --> 00:33:58,410
看看它是否改变了它不像

905
00:33:58,410 --> 00:33:59,940
我在内存中，而不是像我在获取

906
00:33:59,940 --> 00:34:03,560
一个页面并将其带回来是的

907
00:34:13,219 --> 00:34:33,149
有人修改了 C 或者说是，所以我

908
00:34:33,149 --> 00:34:35,690
想你是说如果有人注意到

909
00:34:35,690 --> 00:34:37,560
让我们去举个例子 我们会

910
00:34:37,560 --> 00:34:40,050
回到右边 我想你是

911
00:34:40,050 --> 00:34:42,149
我不是 你不需要修改 如果

912
00:34:42,149 --> 00:34:43,409
你修改这个人 你不要

913
00:34:43,409 --> 00:34:45,600
修改这个人 除非你做了一个

914
00:34:45,600 --> 00:34:46,949
导致这个事情的拆分合并 得到

915
00:34:46,949 --> 00:34:51,210
改变所以现在我在

916
00:34:51,210 --> 00:34:53,280
我的节点上做我的考试找到 Phi McHugh 我正在寻找

917
00:34:53,280 --> 00:34:56,668
说他们现在我来到这里 C 阅读

918
00:34:56,668 --> 00:35:00,300
良性检查 v5 仍然有效如果是的

919
00:35:00,300 --> 00:35:02,430
话如果是的话那么我很好然后做

920
00:35:02,430 --> 00:35:04,020
任何事情 需要做，我已经完成了所以

921
00:35:04,020 --> 00:35:06,960
让我们倒带并让线程

922
00:35:06,960 --> 00:35:09,300
回来，因为我们刚刚完成检查我们的

923
00:35:09,300 --> 00:35:12,690
阅读节点，看到我们向下遍历抱歉

924
00:35:12,690 --> 00:35:15,780
逆转到 GI 赌注应该是这

925
00:35:15,780 --> 00:35:18,050
应该是

926
00:35:18,050 --> 00:35:21,890
在 CES 上，对不起，所以说 现在另一个

927
00:35:21,890 --> 00:35:23,450
线程作者出现了，他

928
00:35:23,450 --> 00:35:27,860
在这里修改了这个注释，所以他

929
00:35:27,860 --> 00:35:29,180
在上面合唱了正确的闩锁，这

930
00:35:29,180 --> 00:35:30,470
意味着 icitly 获得了正确的闩锁

931
00:35:30,470 --> 00:35:32,540
，然后当他们完成他们的

932
00:35:32,540 --> 00:35:35,420
修改权时，他们

933
00:35:35,420 --> 00:35:38,660
将版本计数器的增量修改为 1，所以

934
00:35:38,660 --> 00:35:40,460
现在当这个人在这里并且他

935
00:35:40,460 --> 00:35:41,210
重新检查

936
00:35:41,210 --> 00:35:45,830
时，注意 C 是否仍然设置为 v5 如果没有，那么

937
00:35:45,830 --> 00:35:47,660
他知道其他人 已经来

938
00:35:47,660 --> 00:35:49,520
修改这个，因此他不

939
00:35:49,520 --> 00:35:51,230
应该在这里离开，他只是

940
00:35:51,230 --> 00:35:54,230
重新启动所以在这种情况下，

941
00:35:54,230 --> 00:35:56,270
我做了什么我做了删除我没有说

942
00:35:56,270 --> 00:35:58,430
对我在这里做了一些修改但

943
00:35:58,430 --> 00:36:00,020
它没有 传播

944
00:36:00,020 --> 00:36:16,460
到问题中说这个人修改了它

945
00:36:16,460 --> 00:36:18,680
但是当我在这里时

946
00:36:18,680 --> 00:36:20,780
我去检查了仍然是 b5 并且我完成了

947
00:36:20,780 --> 00:36:22,670
然后我回到这里然后

948
00:36:22,670 --> 00:36:27,020
像连接完整是正确是

949
00:36:27,020 --> 00:36:38,390
是 好吧，关于这一点，

950
00:36:38,390 --> 00:36:40,610
这个潜在的问题是，如果你

951
00:36:40,610 --> 00:36:42,380
有非常大的节点，比如如果你

952
00:36:42,380 --> 00:36:44,210
在单个节点中有很多键，那么

953
00:36:44,210 --> 00:36:46,130
这些版本是非常粗粒度的，

954
00:36:46,130 --> 00:36:47,660
他们对整个节点

955
00:36:47,660 --> 00:36:50,960
说，比如 我修改了一些东西 s

956
00:36:50,960 --> 00:36:52,490
树的这一侧，并且这个

957
00:36:52,490 --> 00:36:53,720
指针仍然有效，

958
00:36:53,720 --> 00:36:56,630
这里的一切仍然很好，那么

959
00:36:56,630 --> 00:36:57,950
我将无法捕捉到我在说

960
00:36:57,950 --> 00:36:59,990
哦，整个节点都改变了测量，

961
00:36:59,990 --> 00:37:02,090
继续重新启动，然后就这样了

962
00:37:02,090 --> 00:37:03,110
再次进行这种权衡，您

963
00:37:03,110 --> 00:37:04,430
可以

964
00:37:04,430 --> 00:37:08,600
对节点中的元素的每个键进行更细粒度的版本控制，

965
00:37:08,600 --> 00:37:10,070
但是它们在超级中所做的方式

966
00:37:10,070 --> 00:37:14,920
对于单个节点本身来说是的，

967
00:37:15,310 --> 00:37:18,200
尤其是从 C 重新启动，所以它

968
00:37:18,200 --> 00:37:19,550
就像 B 到 B 树我认为你总是

969
00:37:19,550 --> 00:37:26,200
从根重新开始 是的

970
00:37:30,110 --> 00:37:33,560
插入 40 英里并有一天阅读它

971
00:37:33,560 --> 00:37:37,040
我们不会读起来像有人

972
00:37:37,040 --> 00:37:39,100
插入像移动 44

973
00:37:39,100 --> 00:37:42,740
先生有人插入什么对不起

974
00:37:42,740 --> 00:38:10,880
好吧 那么什么被撕裂了

975
00:38:10,880 --> 00:38:15,190
对不起 就像我在这里插入 40 一样，

976
00:38:15,190 --> 00:38:33,350
因为就像因为读取器

977
00:38:33,350 --> 00:38:36,560
可以下来并且他们不会

978
00:38:36,560 --> 00:38:40,400
在右侧闩锁上被阻止可能是

979
00:38:40,400 --> 00:38:41,720
这种情况，就像在节点的内存

980
00:38:41,720 --> 00:38:45,650
表示中

981
00:38:45,650 --> 00:38:49,250
一样，我可能是这种情况 你知道我更新

982
00:38:49,250 --> 00:38:51,850
了 t 他是关键列表但不是

983
00:38:51,850 --> 00:38:54,230
毫无意义的实际上我认为读者

984
00:38:54,230 --> 00:38:55,790
阻止了读者确实

985
00:38:55,790 --> 00:38:56,960
在正确的闩锁上被阻止了我收回他们

986
00:38:56,960 --> 00:38:58,820
必须在否则有这个

987
00:38:58,820 --> 00:39:01,400
问题是的但我喜欢作家

988
00:39:01,400 --> 00:39:02,960
不要阻止读者

989
00:39:02,960 --> 00:39:14,810
区别 是的 粗粒度问题

990
00:39:14,810 --> 00:39:20,450
是的，就像您的整个笔记失效一样，

991
00:39:20,450 --> 00:39:23,060
它会被删除或

992
00:39:23,060 --> 00:39:24,680
带回整个笔记中

993
00:39:24,680 --> 00:39:25,720


994
00:39:25,720 --> 00:39:31,790
实际上是的 是的，我说过如果

995
00:39:31,790 --> 00:39:34,250
您的笔记太长，那么您就有

996
00:39:34,250 --> 00:39:35,930
这些课程评级块 但是如果你

997
00:39:35,930 --> 00:39:38,359
让它成为一个 64 字节的缓存行大小，

998
00:39:38,359 --> 00:39:42,080
那么你不能自动更新

999
00:39:42,080 --> 00:39:43,550
它，但至少它被

1000
00:39:43,550 --> 00:39:49,070
原子地移入和移出内存，这

1001
00:39:49,070 --> 00:39:50,930
取决于它的内存模型它的操作系统

1002
00:39:50,930 --> 00:39:52,520
以及 CPU 和什么 它

1003
00:39:52,520 --> 00:39:55,210
保证像管风琴这样的

1004
00:39:55,210 --> 00:39:57,109
写入会使其更有效率，但我

1005
00:39:57,109 --> 00:39:58,460
仍然认为你需要闩锁来

1006
00:39:58,460 --> 00:40:04,700
保护东西是的是的，我们是 45

1007
00:40:04,700 --> 00:40:06,440
分钟，让我们把这个离线，

1008
00:40:06,440 --> 00:40:08,060
因为我刚刚意识到我们 已经 45

1009
00:40:08,060 --> 00:40:09,410
分钟了，我们还没有尝试，

1010
00:40:09,410 --> 00:40:11,630
但你有一个快速的问题顺序 好吧

1011
00:40:11,630 --> 00:40:16,160
抱歉 是的 数据库 好吧

1012
00:40:16,160 --> 00:40:18,020
，让我们看看你们

1013
00:40:18,020 --> 00:40:20,270
实际阅读的内容，所以如果

1014
00:40:20,270 --> 00:40:21,950
你想我讨论过，我们会覆盖 bi  P 加树，

1015
00:40:21,950 --> 00:40:23,660
当我们刚刚谈到

1016
00:40:23,660 --> 00:40:26,810
项目二时，当我们发布它时，我多一点，

1017
00:40:26,810 --> 00:40:30,950
所以在 B 加树中，

1018
00:40:30,950 --> 00:40:33,109
就像 B 每棵树，我称它们为完整的键

1019
00:40:33,109 --> 00:40:35,599
索引，这个想法又一次，你有这个

1020
00:40:35,599 --> 00:40:38,119
完整的键 在树中的所有各个节点上表示，

1021
00:40:38,119 --> 00:40:40,700
您可以

1022
00:40:40,700 --> 00:40:42,589
进行前缀或后缀压缩，但我们

1023
00:40:42,589 --> 00:40:44,359
现在可以忽略它，但在

1024
00:40:44,359 --> 00:40:46,849
B 加树的情况下，因为

1025
00:40:46,849 --> 00:40:48,950
如果我想

1026
00:40:48,950 --> 00:40:51,920
知道密钥是否存在，内部节点仅包含路标 在我的

1027
00:40:51,920 --> 00:40:54,380
表中，我总是必须到

1028
00:40:54,380 --> 00:40:56,839
叶节点的底部，然后查看

1029
00:40:56,839 --> 00:40:58,520
该键是否存在，如果我

1030
00:40:58,520 --> 00:41:00,859
在内部节点中看到该键，它

1031
00:41:00,859 --> 00:41:03,650
实际上可能不在表中，

1032
00:41:03,650 --> 00:41:05,210
因为如果我删除一个 关键我

1033
00:41:05,210 --> 00:41:06,560
不一定要从所有

1034
00:41:06,560 --> 00:41:08,359
互联网上删除它 因为只有通过拆分和

1035
00:41:08,359 --> 00:41:10,730
合并过程，它可以立即被

1036
00:41:10,730 --> 00:41:14,599
修剪，所以现在如果我有他的

1037
00:41:14,599 --> 00:41:17,089
评论，如果我让我的节点

1038
00:41:17,089 --> 00:41:20,450
成为单个缓存行的大小然后

1039
00:41:20,450 --> 00:41:22,130
在最坏的情况下为了我

1040
00:41:22,130 --> 00:41:23,960
要弄清楚我的表中是否存在键，

1041
00:41:23,960 --> 00:41:26,599
我必须为树的每一层都支付一次缓存缓存未命中

1042
00:41:26,599 --> 00:41:29,920
，

1043
00:41:29,920 --> 00:41:33,290
只是为了查看是否存在某些东西，所以

1044
00:41:33,290 --> 00:41:34,820
这是选择的动机，

1045
00:41:34,820 --> 00:41:36,980
这个想法是，而不是

1046
00:41:36,980 --> 00:41:38,779
存储

1047
00:41:38,779 --> 00:41:40,759
在每个节点的整体我们可以

1048
00:41:40,759 --> 00:41:44,269
在一个节点上存储一个密钥的数字，这样

1049
00:41:44,269 --> 00:41:45,619
如果我们确定我们

1050
00:41:45,619 --> 00:41:47,749
可以更快地确定

1051
00:41:47,749 --> 00:41:49,429
我们正在寻找的东西是否不存在

1052
00:41:49,429 --> 00:41:52,729
，所以尝试真的很老我 认为

1053
00:41:52,729 --> 00:41:55,249
他们来自 1950 年代，就像一些

1054
00:41:55,249 --> 00:41:57,439
法国人修改它然后他

1055
00:41:57,439 --> 00:41:59,059
没有名字然后还有

1056
00:41:59,059 --> 00:42:01,309
另一个人 Edward Franken，

1057
00:42:01,309 --> 00:42:04,999
据说他在 CMU 他想出了右岸部落的名字以

1058
00:42:04,999 --> 00:42:07,999
供检索 树，

1059
00:42:07,999 --> 00:42:09,829
但又是基本思想 对于

1060
00:42:09,829 --> 00:42:10,999
我们所有的密钥，我们会将它们分解成

1061
00:42:10,999 --> 00:42:14,449
数字，然后将它们存储下来，你一次知道

1062
00:42:14,449 --> 00:42:16,369
一个数字，所以在

1063
00:42:16,369 --> 00:42:18,109
这个数据集的情况下，我有你好帽子，

1064
00:42:18,109 --> 00:42:20,299
并且在第一级

1065
00:42:20,299 --> 00:42:21,739
我有 会有 H 因为它

1066
00:42:21,739 --> 00:42:23,959
被所有的键共享 然后我有我可以

1067
00:42:23,959 --> 00:42:27,079
有一个路径只是为了你好

1068
00:42:27,079 --> 00:42:30,199
然后就像在底部下面的 B+ 树

1069
00:42:30,199 --> 00:42:32,929
中将是

1070
00:42:32,929 --> 00:42:35,630
指向你知道的实际元组的指针

1071
00:42:35,630 --> 00:42:38,179
由这个键表示，所以

1072
00:42:38,179 --> 00:42:39,169
有时你会看到这些被

1073
00:42:39,169 --> 00:42:41,029
称为数字搜索树或前缀树，

1074
00:42:41,029 --> 00:42:43,579
它们也是基数树和 Patricia

1075
00:42:43,579 --> 00:42:47,779
树，它们是

1076
00:42:47,779 --> 00:42:49,880
try 的压缩版本，原始 try 数据

1077
00:42:49,880 --> 00:42:51,829
结构具有完整的 P 表示

1078
00:42:51,829 --> 00:42:52,509
像这样

1079
00:42:52,509 --> 00:42:55,640
所以尝试实际上真的很有趣，

1080
00:42:55,640 --> 00:42:58,900
因为与 B+ 树词不同

1081
00:42:58,900 --> 00:43:01,969
，在尝试中平均搜索时间登录就可以了，

1082
00:43:01,969 --> 00:43:07,009
其中 K

1083
00:43:07,009 --> 00:43:09,259
是树的长度或密钥的很多抱歉的

1084
00:43:09,259 --> 00:43:11,719
长度长度，例如 if 我有

1085
00:43:11,719 --> 00:43:15,890
一个 ABC 的钥匙然后去做 如果我不进行

1086
00:43:15,890 --> 00:43:17,829
任何压缩以查看

1087
00:43:17,829 --> 00:43:20,989
ABC 是否存在，并且我尝试假设我

1088
00:43:20,989 --> 00:43:22,849
在每个级别存储一个字符，那么

1089
00:43:22,849 --> 00:43:25,489
它正好是三个我们在 B+ 树中

1090
00:43:25,489 --> 00:43:26,869
我可以与一堆其他

1091
00:43:26,869 --> 00:43:28,929
东西混合 并且可能会更长

1092
00:43:28,929 --> 00:43:31,640
，您认为它们的全部内容

1093
00:43:31,640 --> 00:43:33,529
是数据结构是确定性的，

1094
00:43:33,529 --> 00:43:36,199
如果我们有相同的一组键，

1095
00:43:36,199 --> 00:43:38,599
并且我们可以以任何顺序对它们进行洗牌并

1096
00:43:38,599 --> 00:43:40,849
以任何顺序插入它们，我们将始终以任何顺序

1097
00:43:40,849 --> 00:43:43,039
结束 使用相同的 try 数据结构，

1098
00:43:43,039 --> 00:43:45,049
我可以了解我们如何

1099
00:43:45,049 --> 00:43:48,140


1100
00:43:48,140 --> 00:43:51,679
在 B+ 树中组合重叠数字的性质，

1101
00:43:51,679 --> 00:43:52,940


1102
00:43:52,940 --> 00:43:56,359
如果我以随机顺序对密钥进行洗牌，则完全不是这种情况，

1103
00:43:56,359 --> 00:43:56,810


1104
00:43:56,810 --> 00:43:58,220
我最终可能会完全 不同的

1105
00:43:58,220 --> 00:43:59,750
数据结构从一次到下一次，

1106
00:43:59,750 --> 00:44:01,329


1107
00:44:01,329 --> 00:44:04,640
因此密钥永远不会真正

1108
00:44:04,640 --> 00:44:06,619
完整地存储，因此我们必须

1109
00:44:06,619 --> 00:44:08,900
通过沿着到达底部的路径重新创建它们，

1110
00:44:08,900 --> 00:44:10,790
并

1111
00:44:10,790 --> 00:44:12,380
跟踪沿途看到的每个数字

1112
00:44:12,380 --> 00:44:14,390
那么我们就可以 p 将密钥恢复

1113
00:44:14,390 --> 00:44:17,869
到其原始形式，因此

1114
00:44:17,869 --> 00:44:19,520
我们将使用这种语言来描述

1115
00:44:19,520 --> 00:44:21,890
密钥的属性，尝试密钥的

1116
00:44:21,890 --> 00:44:24,319
概念称为跨度，这

1117
00:44:24,319 --> 00:44:27,650
只是我们可以

1118
00:44:27,650 --> 00:44:31,760
从给定节点出来的可能路径的数量

1119
00:44:31,760 --> 00:44:33,349
本质上它是

1120
00:44:33,349 --> 00:44:36,560
可能存在的数字，所以会发生的情况是，

1121
00:44:36,560 --> 00:44:38,420
如果

1122
00:44:38,420 --> 00:44:40,940
我们试图在我们的节点上表示的一个键中存在一个数字，

1123
00:44:40,940 --> 00:44:42,740
那么我们现在将有一个指向

1124
00:44:42,740 --> 00:44:45,260
我们尝试中的下一个节点的指针

1125
00:44:45,260 --> 00:44:47,720
否则你存储 null 你需要一种方法

1126
00:44:47,720 --> 00:44:49,940
来表示它所以

1127
00:44:49,940 --> 00:44:51,950
代表扇出的跨度也

1128
00:44:51,950 --> 00:44:53,510
代表树的物理高度

1129
00:44:53,510 --> 00:44:55,579
所以无论如何尝试会说我们有一个

1130
00:44:55,579 --> 00:44:58,609
n 的扇出所以让我们看看实际的

1131
00:44:58,609 --> 00:45:01,099
例子 我实际上不知道你如何

1132
00:45:01,099 --> 00:45:02,720
在内存中表示真正的尝试，

1133
00:45:02,720 --> 00:45:04,760
所以假设我们将

1134
00:45:04,760 --> 00:45:07,790
最简单的尝试作为 1 位尝试

1135
00:45:07,790 --> 00:45:08,960
，这意味着在每个节点上

1136
00:45:08,960 --> 00:45:11,690
我们将代表一个 位数字

1137
00:45:11,690 --> 00:45:14,270
它是 0 或 1 所以说我们想要

1138
00:45:14,270 --> 00:45:18,050
sto 关于密钥 1025 和 31，所以我们将

1139
00:45:18,050 --> 00:45:20,119
表示它们并绑定这样的二进制形式，

1140
00:45:20,119 --> 00:45:21,920
因此实际上它们

1141
00:45:21,920 --> 00:45:24,140
可能是 32 位 Kesey 或 64 位密钥，

1142
00:45:24,140 --> 00:45:25,940
我们会保持简单，我们会说它是

1143
00:45:25,940 --> 00:45:29,839
16 位 所以我们有 2 2 个字节代表

1144
00:45:29,839 --> 00:45:33,980
每个键 所以我们的轨道看起来像

1145
00:45:33,980 --> 00:45:36,800
这样所以在第一级这里

1146
00:45:36,800 --> 00:45:40,040
它代表

1147
00:45:40,040 --> 00:45:43,190
第一个数字位置的值是什么所以在

1148
00:45:43,190 --> 00:45:46,339
这种情况下这里全是 0

1149
00:45:46,339 --> 00:45:50,300
所以在我们的 对于数字

1150
00:45:50,300 --> 00:45:52,220
0，我们有一个指向

1151
00:45:52,220 --> 00:45:54,890
下一个级别的指针，然后对于数字 1，

1152
00:45:54,890 --> 00:45:56,869
我们有一个空指针

1153
00:45:56,869 --> 00:45:58,369


1154
00:45:58,369 --> 00:46:00,800
数字是

1155
00:46:00,800 --> 00:46:02,960
1 我们会查看第一个节点

1156
00:46:02,960 --> 00:46:04,250
看到这个东西是空的 我知道

1157
00:46:04,250 --> 00:46:06,660


1158
00:46:06,660 --> 00:46:10,420
现在下一个的密钥不存在这里我它

1159
00:46:10,420 --> 00:46:12,430
与上面的那个相同它零有一个

1160
00:46:12,430 --> 00:46:15,010
指针一个是空的 我只是要

1161
00:46:15,010 --> 00:46:16,960
重复它重复十次，

1162
00:46:16,960 --> 00:46:18,760
因为接下来的十位数字都是一样

1163
00:46:18,760 --> 00:46:20,850
的，否则 w 空间用完了，

1164
00:46:20,850 --> 00:46:23,650
现在我们到了这个位置，现在我们

1165
00:46:23,650 --> 00:46:25,090
看到键之间实际上存在

1166
00:46:25,090 --> 00:46:27,940
差异，第一个

1167
00:46:27,940 --> 00:46:30,250
这里的数字是 0，数字的第二个

1168
00:46:30,250 --> 00:46:33,490
是 1，所以我现在在这里有一个指针

1169
00:46:33,490 --> 00:46:35,560
0 路径和一个指向

1170
00:46:35,560 --> 00:46:38,440
1 路径的指针，然后在这里向下

1171
00:46:38,440 --> 00:46:40,780
找到这个键，

1172
00:46:40,780 --> 00:46:42,610
实际上没有什么 Reg 实际上没有我的意思

1173
00:46:42,610 --> 00:46:46,180
是我的语料库中只有一个键在这个位置有一个 0

1174
00:46:46,180 --> 00:46:48,250
所以这里只有

1175
00:46:48,250 --> 00:46:51,130
一个 对于其他两个键，向下指向一个级别到下一个级别，

1176
00:46:51,130 --> 00:46:53,350


1177
00:46:53,350 --> 00:46:55,270
它们在这里相同，但是然后

1178
00:46:55,270 --> 00:46:57,640
他们像那样拆分 0 1 然后我们

1179
00:46:57,640 --> 00:47:02,110
向下遍历它们两个，所以

1180
00:47:02,110 --> 00:47:04,690
我们可以做的一个简单的优化

1181
00:47:04,690 --> 00:47:07,900
是什么 压缩一个节点的大小

1182
00:47:07,900 --> 00:47:10,270
好吧，让我们沸腾吧

1183
00:47:10,270 --> 00:47:12,360


1184
00:47:12,360 --> 00:47:14,230


1185
00:47:14,230 --> 00:47:19,620


1186
00:47:22,440 --> 00:47:24,400


1187
00:47:24,400 --> 00:47:25,900
任何我们不做的

1188
00:47:25,900 --> 00:47:27,910
事，无论如何我们都不做 是的，那是

1189
00:47:27,910 --> 00:47:34,150
空的，我们不存储任何，但这

1190
00:47:34,150 --> 00:47:35,260
不会压缩节点的大小，

1191
00:47:35,260 --> 00:47:36,850
这就是如何减小单个节点的大小，

1192
00:47:36,850 --> 00:47:40,630
是的，

1193
00:47:40,630 --> 00:47:42,070
是的，所以他说取出零，这样

1194
00:47:42,070 --> 00:47:45,400
我就不需要存储 0 然后

1195
00:47:45,400 --> 00:47:46,780
指针，然后是一个，然后是

1196
00:47:46,780 --> 00:47:50,770
指针，如果我

1197
00:47:50,770 --> 00:47:52,660
想知道是否有

1198
00:47:52,660 --> 00:47:54,280
一个指向

1199
00:47:54,280 --> 00:47:56,920
我的数组中位置零数字零的指针，一个指针，所以说

1200
00:47:56,920 --> 00:47:58,240
好吧这里是你知道这里是一个

1201
00:47:58,240 --> 00:47:59,980
指针和 如果它为空那么我

1202
00:47:59,980 --> 00:48:02,440
知道数字 1 的值不

1203
00:48:02,440 --> 00:48:04,660
存在所以这是水平

1204
00:48:04,660 --> 00:48:06,580
压缩这是压缩

1205
00:48:06,580 --> 00:48:09,370
节点的大小你所指的是

1206
00:48:09,370 --> 00:48:11,890
垂直压缩如果我现在

1207
00:48:11,890 --> 00:48:15,850
在这种情况下在这里和 在这里，一旦

1208
00:48:15,850 --> 00:48:18,760
我走上这条路，就

1209
00:48:18,760 --> 00:48:20,079
没有其他选择，它总是

1210
00:48:20,079 --> 00:48:21,459
从一个级别开始，下一个级别没有

1211
00:48:21,459 --> 00:48:23,890
分支，所以不是存储

1212
00:48:23,890 --> 00:48:26,619
每个级别，而且你

1213
00:48:26,619 --> 00:48:27,939
知道这些指针基本上总是

1214
00:48:27,939 --> 00:48:30,249
带你到 bo  ttom 然后我可以

1215
00:48:30,249 --> 00:48:33,369
把它压缩到只存储太短的

1216
00:48:33,369 --> 00:48:35,979
东西，在这种情况下，这里的

1217
00:48:35,979 --> 00:48:38,289
路径没有其他任何东西，所以

1218
00:48:38,289 --> 00:48:40,029
我现在只替换一个指向

1219
00:48:40,029 --> 00:48:42,009
实际元组的指针，然后对于这个

1220
00:48:42,009 --> 00:48:43,929
在这里同样的事情 这里的级别我只有

1221
00:48:43,929 --> 00:48:45,329
指向实际元组本身的元组指针

1222
00:48:45,329 --> 00:48:49,529
是的

1223
00:48:50,759 --> 00:48:52,269
挤压你如何

1224
00:48:52,269 --> 00:48:53,709
区分一个点或另一个节点并

1225
00:48:53,709 --> 00:48:56,489
倒入两个额外的元组排序有点

1226
00:48:56,489 --> 00:49:04,089
是的是的哦是的那

1227
00:49:04,089 --> 00:49:09,279
将是可以的 你这样做你

1228
00:49:09,279 --> 00:49:10,900
需要一种方法来记录这件事被

1229
00:49:10,900 --> 00:49:13,559
重复了十次

1230
00:49:19,229 --> 00:49:23,799
是的是的是的是的是的，所以

1231
00:49:23,799 --> 00:49:25,299
有另一种方法来做垂直

1232
00:49:25,299 --> 00:49:30,309
压力是的所以

1233
00:49:30,309 --> 00:49:31,509
这里要指出的一件事是，

1234
00:49:31,509 --> 00:49:35,289
如果我这样做 再次在 B+ 树中进行这种压缩

1235
00:49:35,289 --> 00:49:37,269
我在叶节点中有整个键，

1236
00:49:37,269 --> 00:49:38,949
所以如果我想查看

1237
00:49:38,949 --> 00:49:42,219
该键是否存在，我知道我

1238
00:49:42,219 --> 00:49:43,749
保证

1239
00:49:43,749 --> 00:49:45,189
从 B+ 树中得到答案，因为

1240
00:49:45,189 --> 00:49:47,499
要么在那里 o 在这种情况下，这里不存在

1241
00:49:47,499 --> 00:49:50,529
我可以有一个具有 0 0 0

1242
00:49:50,529 --> 00:49:55,479
然后在这里有一个 1

1243
00:49:55,479 --> 00:49:56,439
的密钥

1244
00:49:56,439 --> 00:49:59,199


1245
00:49:59,199 --> 00:50:00,699
所以我知道我必须按照这个

1246
00:50:00,699 --> 00:50:02,769
指针去实际查看

1247
00:50:02,769 --> 00:50:05,259
元组，就像我在茶树中所做的那样，看看

1248
00:50:05,259 --> 00:50:06,429
这个东西是否真的

1249
00:50:06,429 --> 00:50:09,489
与我匹配，所以尽管我可以

1250
00:50:09,489 --> 00:50:11,439
像这样压缩大小降低

1251
00:50:11,439 --> 00:50:13,900
高度我仍然可以 必须

1252
00:50:13,900 --> 00:50:16,869
查看元组中的实际

1253
00:50:16,869 --> 00:50:19,509
获取原始键，这也阻止了

1254
00:50:19,509 --> 00:50:21,339
您像覆盖索引

1255
00:50:21,339 --> 00:50:23,170
覆盖查询一样，您希望

1256
00:50:23,170 --> 00:50:24,759
能够完全

1257
00:50:24,759 --> 00:50:27,099
基于索引权和 B+ 回答查询 树你可以

1258
00:50:27,099 --> 00:50:29,019
这样做，如果你如果我的索引在 a 上

1259
00:50:29,019 --> 00:50:30,789
并且我进行查找，它看起来你知道

1260
00:50:30,789 --> 00:50:33,519
从表中选择 a，其中 a

1261
00:50:33,519 --> 00:50:34,390
等于

1262
00:50:34,390 --> 00:50:36,580
我只需要访问索引

1263
00:50:36,580 --> 00:50:38,560
即可在这种情况下回答该查询我在这里

1264
00:50:38,560 --> 00:50:39,760
仍然必须按照指针

1265
00:50:39,760 --> 00:50:44,020
到达原始元组，所以这是

1266
00:50:44,020 --> 00:50:45,340
排序 o  f 速成课程或尝试，因为我们

1267
00:50:45,340 --> 00:50:47,290
在介绍类中介绍了这一点，但现在

1268
00:50:47,290 --> 00:50:48,280
我想谈谈人们实际使用

1269
00:50:48,280 --> 00:50:51,150
的尝试的更复杂的变体实现，

1270
00:50:51,150 --> 00:50:53,200


1271
00:50:53,200 --> 00:50:55,960
因此 Judy 数组首先出现，

1272
00:50:55,960 --> 00:50:57,760
它们由 HP 开发，艺术索引

1273
00:50:57,760 --> 00:50:59,140
是 在论文中，你们

1274
00:50:59,140 --> 00:51:01,420
直接从超级家伙那里读到了，

1275
00:51:01,420 --> 00:51:04,570
精通是一种尝试的变体，

1276
00:51:04,570 --> 00:51:08,500
它是一种树的尝试，每个节点都

1277
00:51:08,500 --> 00:51:10,660
将是 B+ 树，因此通过

1278
00:51:10,660 --> 00:51:12,520
理解他们为什么在这里做什么，他们会看到什么 为什么

1279
00:51:12,520 --> 00:51:13,870
他们必须按照他们掌握的方式来做，

1280
00:51:13,870 --> 00:51:14,380


1281
00:51:14,380 --> 00:51:17,830
所以 Judy 数组和你的

1282
00:51:17,830 --> 00:51:20,800
索引都将是 62-56 等待上升，

1283
00:51:20,800 --> 00:51:22,630
这意味着

1284
00:51:22,630 --> 00:51:24,580
他们每个节点存储的跨度或位数将是

1285
00:51:24,580 --> 00:51:27,610
256 但 现在的目标是以压缩方式存储它们，

1286
00:51:27,610 --> 00:51:28,780
所以我们不必

1287
00:51:28,780 --> 00:51:31,960
分配所有内存来存储

1288
00:51:31,960 --> 00:52:45,730
巡回赛 206-999-9251 生病让我们张贴

1289
00:52:45,730 --> 00:52:47,350
Judy

1290
00:52:47,350 --> 00:52:50,080
Race like 和 8hp 的作者不关心这个的地方

1291
00:52:50,080 --> 00:52:51,340
继续 并以任何你想要的方式使用它，

1292
00:52:51,340 --> 00:52:54,220
但就你而言 你知道，虽然喜欢它，但

1293
00:52:54,220 --> 00:52:56,430
你知道它确实解决了很多问题

1294
00:52:56,430 --> 00:52:58,870
，你能知道大键集的非常简洁的表示吗？据

1295
00:52:58,870 --> 00:53:02,170


1296
00:53:02,170 --> 00:53:03,460
我所知，没有人真正

1297
00:53:03,460 --> 00:53:05,050
正确地使用它们，因为无论是否

1298
00:53:05,050 --> 00:53:07,210
因为专利，我不知道好吧

1299
00:53:07,210 --> 00:53:12,310


1300
00:53:12,310 --> 00:53:14,230
Judy right 中将发生的重要事情可能

1301
00:53:14,230 --> 00:53:15,490
与 b-plus 梦想和

1302
00:53:15,490 --> 00:53:18,580
BJP 条约不同的是，他们不会

1303
00:53:18,580 --> 00:53:21,130
在节点本身中存储有关节点的任何元数据，

1304
00:53:21,130 --> 00:53:23,500
我再次想到像

1305
00:53:23,500 --> 00:53:25,030
MVCC 和 我们

1306
00:53:25,030 --> 00:53:26,500
将像 B+ 树中的时间戳一样存储元组的标头，

1307
00:53:26,500 --> 00:53:28,090
您可以恢复有关

1308
00:53:28,090 --> 00:53:29,950
哪些键是 haslet 的偏移量的信息 我

1309
00:53:29,950 --> 00:53:32,020
不会做任何这些

1310
00:53:32,020 --> 00:53:33,610
我们只会

1311
00:53:33,610 --> 00:53:37,710
在指针中存储有关节点的信息 到那个节点，

1312
00:53:37,710 --> 00:53:41,170
所以在一个红色的 X 树中

1313
00:53:41,170 --> 00:53:42,610
，你不会有 B+ 树中的任何兄弟指针，

1314
00:53:42,610 --> 00:53:44,290
但你不能沿着

1315
00:53:44,290 --> 00:53:45,580
叶节点扫描你总是有可能

1316
00:53:45,580 --> 00:53:47,470
回溯，这意味着对于任何

1317
00:53:47,470 --> 00:53:49,270
给定的节点，因为 我们知道 只有

1318
00:53:49,270 --> 00:53:51,850
一个指向它的指针，所以

1319
00:53:51,850 --> 00:53:54,580


1320
00:53:54,580 --> 00:53:56,110
如果我们

1321
00:53:56,110 --> 00:54:01,110
修改该节点的布局，我们不必担心保持同步一堆指针同步，所以

1322
00:54:01,110 --> 00:54:03,820
会发生的是他们必须

1323
00:54:03,820 --> 00:54:05,170
存储一个指针，一个内存指针，

1324
00:54:05,170 --> 00:54:06,970
有 正如我们通常会到达

1325
00:54:06,970 --> 00:54:09,640
节点的位置，但它们

1326
00:54:09,640 --> 00:54:11,230
实际上存储的指针大小的两倍，

1327
00:54:11,230 --> 00:54:13,420
以实际打包所有这些

1328
00:54:13,420 --> 00:54:14,800
额外的元数据，例如节点

1329
00:54:14,800 --> 00:54:16,990
类型、节点处人口的键数是

1330
00:54:16,990 --> 00:54:19,810
什么 前缀值可能

1331
00:54:19,810 --> 00:54:21,460
是，如果下面只有一个孩子，

1332
00:54:21,460 --> 00:54:23,890
然后是秘密尝试指针，所以如果我

1333
00:54:23,890 --> 00:54:25,300
有一个 64 位的孩子指针，

1334
00:54:25,300 --> 00:54:27,850
我需要另外 64 位来存储所有这些

1335
00:54:27,850 --> 00:54:30,070
额外的元数据在原始任务

1336
00:54:30,070 --> 00:54:32,350
数组实现中，他们回来了，你

1337
00:54:32,350 --> 00:54:35,350
知道 在 x86 32 位上，所以他们有 32

1338
00:54:35,350 --> 00:54:37,540
位子指针，然后是 32 位元数据，

1339
00:54:37,540 --> 00:54:40,870
但现在在现代系统中，它

1340
00:54:40,870 --> 00:54:42,520
必须是 64 位角，所以它需要

1341
00:54:42,520 --> 00:54:44,260
120 个 8 位指针，所以他们

1342
00:54:44,260 --> 00:54:45,520
要 将这些 Judy 阵列或

1343
00:54:45,520 --> 00:54:47,440
Judique 称为 你们阅读的论文中的 Judy 指针是

1344
00:54:47,440 --> 00:54:49,480


1345
00:54:49,480 --> 00:54:51,160
根据基数树对它们进行评估的，我认为他们称

1346
00:54:51,160 --> 00:54:54,480
它们为胖指针，这是相同的想法，

1347
00:54:54,480 --> 00:54:58,480
因此它们将再次具有三种节点

1348
00:54:58,480 --> 00:55:01,430
类型，因此这是 256 种方式

1349
00:55:01,430 --> 00:55:02,750
尝试，这意味着您可以

1350
00:55:02,750 --> 00:55:05,960
每个节点最多存储 260 个喷气机 这个想法是不是

1351
00:55:05,960 --> 00:55:07,549
每个节点都恰好有 206

1352
00:55:07,549 --> 00:55:08,480
位数字，

1353
00:55:08,480 --> 00:55:10,819
所以与其存储你知道的

1354
00:55:10,819 --> 00:55:12,410
206 个指针，不如

1355
00:55:12,410 --> 00:55:14,569
用更压缩的形式来表示

1356
00:55:14,569 --> 00:55:16,250
这些东西，所以我们要开始了

1357
00:55:16,250 --> 00:55:18,349
谈论线性节点和位图

1358
00:55:18,349 --> 00:55:21,319
节点 未压缩节点

1359
00:55:21,319 --> 00:55:23,619
将与他们所做的相同

1360
00:55:23,619 --> 00:55:25,430
抱歉 我收回所

1361
00:55:25,430 --> 00:55:27,019
谈论的关于 Lina 节点和

1362
00:55:27,019 --> 00:55:28,700
位图节点 未压缩节点

1363
00:55:28,700 --> 00:55:31,789
将类似于什么 hyper 有，但 hyper

1364
00:55:31,789 --> 00:55:33,259
也有线性节点，它是

1365
00:55:33,259 --> 00:55:34,609
位图节点，它们

1366
00:55:34,609 --> 00:55:37,309
是不同的，这里的想法就像说，

1367
00:55:37,309 --> 00:55:40,640
如果你有一个，你知道你是否

1368
00:55:40,640 --> 00:55:42,619
像字符串一样存储并且你正在存储

1369
00:55:42,619 --> 00:55:44,839
URL 很多UR  Ls 将以

1370
00:55:44,839 --> 00:55:46,309
dub dub dub dot 开头，然后无论

1371
00:55:46,309 --> 00:55:49,759
域名是什么，这样我就可以在那个上层

1372
00:55:49,759 --> 00:55:51,410
节点中，这些数字总是相同的，

1373
00:55:51,410 --> 00:55:53,720
这样我就可以将它们打包成一个线性

1374
00:55:53,720 --> 00:55:55,910
节点，这样我就可以表示一个大的，你知道

1375
00:55:55,910 --> 00:55:57,890
一个大的 数字键在我下方的一小

1376
00:55:57,890 --> 00:55:59,269
部分空间中，在那个新的

1377
00:55:59,269 --> 00:56:02,329
级别上，这个想法

1378
00:56:02,329 --> 00:56:04,099
就像从上到下，这是

1379
00:56:04,099 --> 00:56:05,299
当你有少量数字时，当你有

1380
00:56:05,299 --> 00:56:06,859
少量数字时，

1381
00:56:06,859 --> 00:56:10,160
这是当 你最多或

1382
00:56:10,160 --> 00:56:11,660
超过你可以排序的但你知道

1383
00:56:11,660 --> 00:56:14,980
大多数 206 因为它是 256 尝试

1384
00:56:14,980 --> 00:56:16,730
好吧所以让我们再次看看线性

1385
00:56:16,730 --> 00:56:18,890
线性节点它

1386
00:56:18,890 --> 00:56:19,789
被称为线性节点的原因因为你只是

1387
00:56:19,789 --> 00:56:21,559
要线性扫描到 找到键并

1388
00:56:21,559 --> 00:56:23,299
找到您要查找的数字，因此您

1389
00:56:23,299 --> 00:56:25,519
只有两个数组，因此第一个数组

1390
00:56:25,519 --> 00:56:27,619
是数字类型，然后

1391
00:56:27,619 --> 00:56:29,299
第二个数组是子指针，

1392
00:56:29,299 --> 00:56:31,700
因此无论您在扫描以查找数字时的偏移量是多少

1393
00:56:31,700 --> 00:56:33,349
你在

1394
00:56:33,349 --> 00:56:35,240
找你可 ep 跟踪你走了多远

1395
00:56:35,240 --> 00:56:37,339
，然后你可以跳转到子指针中的偏移量，

1396
00:56:37,339 --> 00:56:41,539
所以在

1397
00:56:41,539 --> 00:56:45,079


1398
00:56:45,079 --> 00:56:45,710
judy 数组的原始实现中，

1399
00:56:45,710 --> 00:56:47,420
这个东西的大小

1400
00:56:47,420 --> 00:56:50,750
现在是 64 位中的单个缓存行

1401
00:56:50,750 --> 00:56:52,549
这将用于

1402
00:56:52,549 --> 00:56:55,130
缓存行，所以总大小是 Nell 的

1403
00:56:55,130 --> 00:56:56,900
，因为这些东西

1404
00:56:56,900 --> 00:57:01,150
每个字节都是正确的，因为它是一个

1405
00:57:01,150 --> 00:57:05,990
但是你存储了其中的六个源，

1406
00:57:05,990 --> 00:57:07,819
然后每个然后那个 总共是

1407
00:57:07,819 --> 00:57:10,450
六个字节，然后这些将是

1408
00:57:10,450 --> 00:57:13,490
128 个指针，所以 16 位，因为

1409
00:57:13,490 --> 00:57:14,960
再次 Judy 指针

1410
00:57:14,960 --> 00:57:16,430
是常规指针的大小，所以我有

1411
00:57:16,430 --> 00:57:18,680
六个这样的，所以这些将是 96 字节，

1412
00:57:18,680 --> 00:57:21,800
所以总共一个节点将是 102

1413
00:57:21,800 --> 00:57:24,020
字节，但现在 我们需要

1414
00:57:24,020 --> 00:57:26,390
与我们的 cap 缓存行字对齐，所以我们将把

1415
00:57:26,390 --> 00:57:28,670
它拍出来并制作这个 128 字节，所以现在再次需要

1416
00:57:28,670 --> 00:57:31,040
2 个缓存行来

1417
00:57:31,040 --> 00:57:35,900
获取这件事，所以

1418
00:57:35,900 --> 00:57:37,700
下一个节点类型是位图节点

1419
00:57:37,700 --> 00:57:39,800
这个有点棘手，所以

1420
00:57:39,800 --> 00:57:42,109
这里的想法是 我们将把

1421
00:57:42,109 --> 00:57:45,710
我们的数字分解成我们

1422
00:57:45,710 --> 00:57:49,369
在这个节点中表示的 8 位

1423
00:57:49,369 --> 00:57:52,520
块，所以想想这就像

1424
00:57:52,520 --> 00:57:55,480
这里的这些部分是我们所有的偏移量

1425
00:57:55,480 --> 00:57:59,720
中的所有偏移量

1426
00:57:59,720 --> 00:58:01,790
代表你知道特定的

1427
00:58:01,790 --> 00:58:06,920
这个节点的数字值是正确的，所以

1428
00:58:06,920 --> 00:58:09,260
在偏移零处向下移动，当你

1429
00:58:09,260 --> 00:58:11,000
只有零时，偏移

1430
00:58:11,000 --> 00:58:12,770
一是当你在这个位置有 1

1431
00:58:12,770 --> 00:58:14,570
2 是当你在

1432
00:58:14,570 --> 00:58:17,030
列出的位置有一个 1 等等，我

1433
00:58:17,030 --> 00:58:21,349
只是 一直这样做到 256 所以

1434
00:58:21,349 --> 00:58:23,420
现在会发生什么是当我想在

1435
00:58:23,420 --> 00:58:25,849
这里查找时我有这些子数组

1436
00:58:25,849 --> 00:58:27,109
指针实际上是

1437
00:58:27,109 --> 00:58:29,450
向下指向一个数组的不同指针，它告诉我

1438
00:58:29,450 --> 00:58:31,820
这是我的子指针 我

1439
00:58:31,820 --> 00:58:35,270
想在这种情况下进行查找，在

1440
00:58:35,270 --> 00:58:37,430
这里说我想

1441
00:58:37,430 --> 00:58:41,330
查找数字 1，以便七个零

1442
00:58:41,330 --> 00:58:44,210
后跟一个零，所以我知道这

1443
00:58:44,210 --> 00:58:46,700
将在此处的第一个位置，因此我

1444
00:58:46,700 --> 00:58:49,099
会看到一个 1 意思是我知道

1445
00:58:49,099 --> 00:58:51,109
我下面有一个孩子，我需要

1446
00:58:51,109 --> 00:58:52,430
跟随指向那个的指针，所以我然后

1447
00:58:52,430 --> 00:58:56,060
跟随这个块子你知道子

1448
00:58:56,060 --> 00:58:58,550
数组指针向下到这里然后现在

1449
00:58:58,550 --> 00:59:00,710
我计算

1450
00:59:00,710 --> 00:59:02,630
在我的块图中我的位置之前的数量，

1451
00:59:02,630 --> 00:59:04,760
这会告诉我在什么偏移量我

1452
00:59:04,760 --> 00:59:07,339
想要在 surrett 所以在这种

1453
00:59:07,339 --> 00:59:08,930
情况下，对于这个位置，

1454
00:59:08,930 --> 00:59:11,480


1455
00:59:11,480 --> 00:59:13,250
它的左侧没有其他位置，所以我知道当我

1456
00:59:13,250 --> 00:59:15,890
来到这里时，我遇到了位置 0，而这个位置

1457
00:59:15,890 --> 00:59:19,280
就在他那里 他的左边

1458
00:59:19,280 --> 00:59:21,890
有一个，所以当我按照我的

1459
00:59:21,890 --> 00:59:25,520
指针向下时，我想跳过 1

1460
00:59:25,520 --> 00:59:28,150
是现在清楚是的

1461
00:59:29,260 --> 00:59:31,849
所以问题是面试 8 到 15

1462
00:59:31,849 --> 00:59:33,050
范围我是否需要来不但是

1463
00:59:33,050 --> 00:59:35,510
在你知道之前来，因为指针在这里

1464
00:59:35,510 --> 00:59:37,190
仅适用于这个块，所以如果我

1465
00:59:37,190 --> 00:59:39,859
在这里查看，我会按照这个指针向下，

1466
00:59:39,859 --> 00:59:42,830
现在它被数字元素抵消了，

1467
00:59:42,830 --> 00:59:51,080
问题是我可以将它

1468
00:59:51,080 --> 00:59:55,670
插入到这里，所以

1469
00:59:55,670 --> 00:59:59,690
问题是，我可以在这里插入吗？

1470
00:59:59,690 --> 01:00:02,810
不要乱用这些指针，不，

1471
01:00:02,810 --> 01:00:05,390
因为在那里，因为现在我 必须调整

1472
01:00:05,390 --> 01:00:12,650
内存中连续的这个数组的大小，所以

1473
01:00:12,650 --> 01:00:14,420
像这样的 Chuck 认为这就像

1474
01:00:14,420 --> 01:00:16,340


1475
01:00:16,340 --> 01:00:19,940
在节点内的 B teamers 内存区域的节拍，所以这

1476
01:00:19,940 --> 01:00:21,560
就是说你取 8 位

1477
01:00:21,560 --> 01:00:23,990
代表位置偏移量 0 到 7

1478
01:00:23,990 --> 01:00:26,210
然后之后 你现在在子

1479
01:00:26,210 --> 01:00:27,920
数组指针中有一个子数组指针，我

1480
01:00:27,920 --> 01:00:31,400
认为就像你只是跳转到

1481
01:00:31,400 --> 01:00:33,859
同一个节点中的一个偏移量，所以它插入了 B

1482
01:00:33,859 --> 01:00:36,890
16 位，然后现在

1483
01:00:36,890 --> 01:00:39,380
你有接下来的 8 位用于下一个

1484
01:00:39,380 --> 01:00:41,060
下一个偏移区域，然后它有一个

1485
01:00:41,060 --> 01:00:43,160
子数组指针，所以你

1486
01:00:43,160 --> 01:00:44,960
现在得到的油箱插入到

1487
01:00:44,960 --> 01:00:47,300
这个位置，

1488
01:00:47,300 --> 01:00:49,040
其他人都搞砸了偏移量，我必须调整

1489
01:00:49,040 --> 01:01:14,240
它的大小，所以在我的例子中插入它很昂贵，

1490
01:01:14,240 --> 01:01:17,990
我在这里使用 3 但就像我可以

1491
01:01:17,990 --> 01:01:22,000
插入所有的，然后前 8

1492
01:01:22,000 --> 01:01:24,980
个子指针将代表

1493
01:01:24,980 --> 01:01:28,570
那里的键 这里的键 这里的数字是

1494
01:01:29,589 --> 01:01:32,330
对的，但这个想法是，

1495
01:01:32,330 --> 01:01:34,490
如果你有一个

1496
01:01:34,490 --> 01:01:36,410
稀疏的 dig 人口，它并不总是我所有的 它在这个

1497
01:01:36,410 --> 01:01:39,290
节点上

1498
01:01:39,290 --> 01:01:41,960
，如果你要去，

1499
01:01:41,960 --> 01:01:44,510
你可以拥有这些指针，我可以

1500
01:01:44,510 --> 01:01:53,060
看什么是的，一个

1501
01:01:53,060 --> 01:01:55,670
问题是声明是如果我只是

1502
01:01:55,670 --> 01:01:57,050
要计算在我之前出现的一堆指针，

1503
01:01:57,050 --> 01:01:59,870
那么为什么 甚至打扰

1504
01:01:59,870 --> 01:02:02,660
这些正确的因为它可以在晚上因为这些

1505
01:02:02,660 --> 01:02:03,890
东西总是相同的大小我

1506
01:02:03,890 --> 01:02:05,180
可以数数出现在我面前的那些并

1507
01:02:05,180 --> 01:02:13,880
跳到我需要去的地方我我们

1508
01:02:13,880 --> 01:02:16,100
不会太多但就像因为

1509
01:02:16,100 --> 01:02:19,310
这就像 一个固定的大小我可以像

1510
01:02:19,310 --> 01:02:20,810
Cindy 指令那样非常有效地完成它

1511
01:02:20,810 --> 01:02:22,160
并计算我面前的数字，

1512
01:02:22,160 --> 01:02:24,050
不要认为

1513
01:02:24,050 --> 01:02:26,060
这是一个 for 循环计数

1514
01:02:26,060 --> 01:02:27,770
我可以像一个人一样实现，

1515
01:02:27,770 --> 01:02:29,390
很好地看到指令，我的指令在哪里

1516
01:02:29,390 --> 01:02:31,520
我左边有多少个

1517
01:02:31,520 --> 01:02:33,410
然后偏移量可能是那个偏移量

1518
01:02:33,410 --> 01:02:36,320
很快你仍然可以这样做是的

1519
01:02:36,320 --> 01:02:39,110
是的是的是的我不知道答案

1520
01:02:39,110 --> 01:02:59,180
是的是的好吧是的如果你散列如果你

1521
01:02:59,180 --> 01:03:01,790
散列或数字然后你跳 就像

1522
01:03:01,790 --> 01:03:03,260
那样你基本上是在治疗 这

1523
01:03:03,260 --> 01:03:16,220
就像一个哈希表是的，我

1524
01:03:16,220 --> 01:03:17,360
认为散列会太昂贵，像

1525
01:03:17,360 --> 01:03:18,940
这样可能不喜欢位翻转

1526
01:03:18,940 --> 01:03:21,080
和跳转非常有效我们已经

1527
01:03:21,080 --> 01:03:22,190
很快完成了你需要去的地方我

1528
01:03:22,190 --> 01:03:23,930
认为哈希表不是'  t

1529
01:03:23,930 --> 01:03:26,500
overkill this 是的，

1530
01:03:26,500 --> 01:03:32,240
你不能 Craig 是的，你可以

1531
01:03:32,240 --> 01:03:33,650
知道你可以恨你 哈希可以是

1532
01:03:33,650 --> 01:03:38,240
一些珠子但是是的，正确取决于

1533
01:03:38,240 --> 01:03:43,670
哈希，你可以 是的，你的 innachi 将是

1534
01:03:43,670 --> 01:03:45,500
一种矫枉过正，尽管他们是 B+ 树

1535
01:03:45,500 --> 01:03:48,230
在基数

1536
01:03:48,230 --> 01:03:51,080
树中使用它很抱歉在掌握中使用它

1537
01:03:51,080 --> 01:03:52,190
是同一件事，但他们正在

1538
01:03:52,190 --> 01:03:52,510
尝试

1539
01:03:52,510 --> 01:03:54,520
将尽可能多的数据打包在

1540
01:03:54,520 --> 01:03:56,140
一个音符中我认为散列这将是一种

1541
01:03:56,140 --> 01:03:59,950
矫枉过正的想法

1542
01:03:59,950 --> 01:04:04,360
就像当你考虑像

1543
01:04:04,360 --> 01:04:06,610
在基数树中的 a 一样，取决于

1544
01:04:06,610 --> 01:04:08,920
你的键基于什么

1545
01:04:08,920 --> 01:04:10,650
上层节点可能不会经常改变，

1546
01:04:10,650 --> 01:04:13,120
这是我下面的那些可能

1547
01:04:13,120 --> 01:04:14,860
会改变，因为事情变得越来越

1548
01:04:14,860 --> 01:04:16,360
肯定删除它就像再次

1549
01:04:16,360 --> 01:04:17,680
回到我的你是例子 如果我有一堆

1550
01:04:17,680 --> 01:04:20,080
以 dub dub dub 开头的 URL，

1551
01:04:20,080 --> 01:04:22,270
那么上鼻子和树可以

1552
01:04:22,270 --> 01:04:23,740
像这样紧紧地打包

1553
01:04:23,740 --> 01:04:25,990
在一起，我几乎根本不需要修改它们，

1554
01:04:25,990 --> 01:04:29,350
因此哈希表的间接性

1555
01:04:29,350 --> 01:04:31,360
将是 浪费，

1556
01:04:31,360 --> 01:04:33,220
这可能只是一些操作

1557
01:04:33,220 --> 01:04:35,140
，有点转移到我需要

1558
01:04:35,140 --> 01:04:37,300
去的地方，但他的问题在他的观点中我

1559
01:04:37,300 --> 01:04:38,350
不知道答案是为什么要

1560
01:04:38,350 --> 01:04:39,850
麻烦这个为什么你不能只

1561
01:04:39,850 --> 01:04:41,500
计算所有的 在你下方并

1562
01:04:41,500 --> 01:04:45,420
跳到你需要去的地方我不回答是

1563
01:04:55,410 --> 01:04:58,630
是是他的陈述是我认为出于

1564
01:04:58,630 --> 01:05:00,370
效率原因如果我知道我

1565
01:05:00,370 --> 01:05:03,310
正在寻找位置 248 我可以

1566
01:05:03,310 --> 01:05:05,080
跳到这里我认为这就是答案如果我

1567
01:05:05,080 --> 01:05:08,170
知道 数字位置 248 我只是跳到

1568
01:05:08,170 --> 01:05:11,290
这里，我不必扫描

1569
01:05:11,290 --> 01:05:13,120
我面前的所有其他东西来弄清楚

1570
01:05:13,120 --> 01:05:16,450
有多少，但我认为

1571
01:05:16,450 --> 01:05:18,610
那里我认为有

1572
01:05:18,610 --> 01:05:20,380
Cindi 操作可以非常有效地计算数字，

1573
01:05:20,380 --> 01:05:23,200
所以你 可以做到，

1574
01:05:23,200 --> 01:05:27,550
婴儿不会那样做 是的 oka

1575
01:05:27,550 --> 01:05:29,380
是的，所以我们涵盖了三种已知

1576
01:05:29,380 --> 01:05:32,140
类型，我们涵盖了线性节点

1577
01:05:32,140 --> 01:05:33,970
和位图节点，然后

1578
01:05:33,970 --> 01:05:35,140
未压缩的节点将

1579
01:05:35,140 --> 01:05:39,490
在 hyper 中看到相同的东西，不仅仅是

1580
01:05:39,490 --> 01:05:41,860
存储指向所有内容的指针，

1581
01:05:41,860 --> 01:05:45,540
所以 hyper 现在是或对不起艺术 是

1582
01:05:45,540 --> 01:05:49,450
基数树的变体，您

1583
01:05:49,450 --> 01:05:50,410
将进行与 Judy 相同的改编

1584
01:05:50,410 --> 01:05:53,890
，但它是

1585
01:05:53,890 --> 01:05:55,570
专门为数据库系统设计的，

1586
01:05:55,570 --> 01:05:58,000
这意味着它应该是

1587
01:05:58,000 --> 01:05:59,890
指向元组的索引，而 judy 数组

1588
01:05:59,890 --> 01:06:01,420
则是 就像一个通用

1589
01:06:01,420 --> 01:06:03,520
数组，它是最终的休息

1590
01:06:03,520 --> 01:06:05,710
空间或类似的数据，

1591
01:06:05,710 --> 01:06:08,830
所以它没有指向元组的指针，

1592
01:06:08,830 --> 01:06:12,010
它在元组本身之后，所以

1593
01:06:12,010 --> 01:06:13,090
我们将再次对 Judy Ray 做同样的事情，

1594
01:06:13,090 --> 01:06:14,680
我们存储元数据 关于每个

1595
01:06:14,680 --> 01:06:18,130
节点和指针，然后

1596
01:06:18,130 --> 01:06:20,020
实际上根本无法轻松

1597
01:06:20,020 --> 01:06:23,080
执行 lat 树右 X 树或艺术索引

1598
01:06:23,080 --> 01:06:24,010
他们将执行

1599
01:06:24,010 --> 01:06:26,920
我今天早些时候提到的那个版本闩锁，

1600
01:06:26,920 --> 01:06:30,250
因此主要区别 e

1601
01:06:30,250 --> 01:06:33,190
是 judy ray 将有三种

1602
01:06:33,190 --> 01:06:34,260
节点类型或不同的组织

1603
01:06:34,260 --> 01:06:36,550
艺术可以有四种节点类型，这些节点类型

1604
01:06:36,550 --> 01:06:38,710
主要会因元素数量而异，

1605
01:06:38,710 --> 01:06:41,050


1606
01:06:41,050 --> 01:06:43,420
您可以存储每个节点可以存储的数字，然后正如我

1607
01:06:43,420 --> 01:06:44,890
所说的 judy  array 是

1608
01:06:44,890 --> 01:06:46,360
这个通用的关联数组，

1609
01:06:46,360 --> 01:06:49,870
而 art 是一个表索引，

1610
01:06:49,870 --> 01:06:52,630
所以第一个节点类型将与

1611
01:06:52,630 --> 01:06:54,310
Judea ray 中的线性节点相同，

1612
01:06:54,310 --> 01:06:56,560
只是它们有两种不同的大小

1613
01:06:56,560 --> 01:06:59,740
，你所拥有的只是 一个

1614
01:06:59,740 --> 01:07:01,870
剑数字列表，然后

1615
01:07:01,870 --> 01:07:04,780
跟随一个子指针列表，你

1616
01:07:04,780 --> 01:07:06,700
可以有一个存储

1617
01:07:06,700 --> 01:07:12,160
键或十六个键的东西，

1618
01:07:12,160 --> 01:07:16,300
那么现在对于节点 48

1619
01:07:16,300 --> 01:07:18,820
而不是我们看到的位图节点

1620
01:07:18,820 --> 01:07:21,640
在 Judy ray 中，他们

1621
01:07:21,640 --> 01:07:25,750
实际上现在只存储

1622
01:07:25,750 --> 01:07:28,570
具有指针的键的数组，但

1623
01:07:28,570 --> 01:07:31,900
指针将指向所有集合，指向

1624
01:07:31,900 --> 01:07:34,620
另一个子指针数组

1625
01:07:34,620 --> 01:07:38,050
，因此在这种情况下，它只是

1626
01:07:38,050 --> 01:07:40,570
指向正确的指针  在这种情况下

1627
01:07:40,570 --> 01:07:44,080
，它的大小将是每

1628
01:07:44,080 --> 01:07:45,970
一个都是指向某个偏移量的一个字节指针

1629
01:07:45,970 --> 01:07:49,090
，然后我有 206 个修复，

1630
01:07:49,090 --> 01:07:51,550
所以这是 256 个字节，然后

1631
01:07:51,550 --> 01:07:55,000
这些将是多达 48 个指针，

1632
01:07:55,000 --> 01:07:58,420
那些将是 8 个字节，好吧

1633
01:07:58,420 --> 01:07:59,350
因为他们不是他们没有

1634
01:07:59,350 --> 01:08:00,970
像你在工作中那样做胖指针的事情

1635
01:08:00,970 --> 01:08:04,060
然后是 384 字节所以把

1636
01:08:04,060 --> 01:08:06,250
它放在一起这个节点总共是 640

1637
01:08:06,250 --> 01:08:08,440
所以没有 48 意味着我最多可以

1638
01:08:08,440 --> 01:08:10,780
有 48 个子指针 所以一堆

1639
01:08:10,780 --> 01:08:12,730
这些将是空的 我把所有

1640
01:08:12,730 --> 01:08:17,250
至少 48 位数字放在这个数组

1641
01:08:17,630 --> 01:08:20,219
中最后一个是未压缩的，

1642
01:08:20,219 --> 01:08:21,630
这又是与 Judy ray 相同的东西

1643
01:08:21,630 --> 01:08:24,479
这只是一个巨大的数组

1644
01:08:24,479 --> 01:08:27,389
，其中的位置在

1645
01:08:27,389 --> 01:08:30,118
子指针的这个数组表示它是否为

1646
01:08:30,118 --> 01:08:31,799
空那么它不

1647
01:08:31,799 --> 01:08:33,359
存在如果它是一个指向子

1648
01:08:33,359 --> 01:08:35,460
指针的指针或者它是一个子指针而不

1649
01:08:35,460 --> 01:08:37,529
存在那么它的总大小

1650
01:08:37,529 --> 01:08:41,029
将是 206 乘以 8 所以 248 字节

1651
01:08:41,029 --> 01:08:44,309
的想法是，当你插入

1652
01:08:44,309 --> 01:08:47,399
东西 并修改索引，

1653
01:08:47,399 --> 01:08:50,219
系统会跟踪容量

1654
01:08:50,219 --> 01:08:51,960
是多少或每个节点的元素数量是多少

1655
01:08:51,960 --> 01:08:54,359
，然后如果你

1656
01:08:54,359 --> 01:08:57,089
超过了你正在查看的节点的最大大小

1657
01:08:57,089 --> 01:08:59,729
，没有 48 和我

1658
01:08:59,729 --> 01:09:02,549
插入第 49 位数字，然后我必须

1659
01:09:02,549 --> 01:09:04,799
在该节点上取一个锁存器并将其转换

1660
01:09:04,799 --> 01:09:10,019
为这个，好吧，所以

1661
01:09:10,019 --> 01:09:13,920
我将再次跳过二进制兼容的关键

1662
01:09:13,920 --> 01:09:16,799
内容，我们在介绍类中介绍了这一点，

1663
01:09:16,799 --> 01:09:18,448
基本上只是说如果

1664
01:09:18,448 --> 01:09:21,179
您像在 x86 中那样以小端存储方式存储东西，

1665
01:09:21,179 --> 01:09:26,130
就像从

1666
01:09:26,130 --> 01:09:27,809
这边到这边存储方式一样向下存储

1667
01:09:27,809 --> 01:09:29,849
您的值会有错误的比较，

1668
01:09:29,849 --> 01:09:31,979
因此他们将所有内容都转换

1669
01:09:31,979 --> 01:09:33,689
为大端方式，并且它们有一个

1670
01:09:33,689 --> 01:09:35,339
关于如何对任何可能的数据类型执行此操作的食谱书

1671
01:09:35,339 --> 01:09:37,859


1672
01:09:37,859 --> 01:09:40,589
我想提的最后一件事是筒仓，因此在

1673
01:09:40,589 --> 01:09:42,710
艺术和朱迪数组的情况下，

1674
01:09:42,710 --> 01:09:44,609
他们将根据人口拥有不同大小的

1675
01:09:44,609 --> 01:09:46,889
节点，

1676
01:09:46,889 --> 01:09:49,139
然后作为 我说一旦你超过

1677
01:09:49,139 --> 01:09:50,698
阈值哦，但是节点可以保持然后

1678
01:09:50,698 --> 01:09:52,469
你必须切换到下一个节点

1679
01:09:52,469 --> 01:09:55,230
类型，他们正在这样做，

1680
01:09:55,230 --> 01:09:57,599
因为他们不支持动态节点没有

1681
01:09:57,599 --> 01:10:00,480
大小所以支持动态酱没有

1682
01:10:00,480 --> 01:10:03,269
大小你可以使用另一种数据

1683
01:10:03,269 --> 01:10:05,219
结构，如 一个哈希表或一个 B+ 树，

1684
01:10:05,219 --> 01:10:06,929
所以这就是筒仓所做的，或者抱歉，这

1685
01:10:06,929 --> 01:10:08,820
是主人所做的，所以精通是

1686
01:10:08,820 --> 01:10:12,150
一棵尝试树，现在尝试树，抱歉

1687
01:10:12,150 --> 01:10:15,059
，而是每个节点再次

1688
01:10:15,059 --> 01:10:16,949
而不是将那个位打包成

1689
01:10:16,949 --> 01:10:19,460
o 型 将有一个 B+ 树，

1690
01:10:19,460 --> 01:10:22,170
在该 B+ 树中，您可以

1691
01:10:22,170 --> 01:10:24,599
在叶节点中包含指向

1692
01:10:24,599 --> 01:10:27,059
Tri 中下一级的指针，或者实际上

1693
01:10:27,059 --> 01:10:30,750
指向一个元组，因此就像

1694
01:10:30,750 --> 01:10:32,100
在尝试中一样，您不必一直

1695
01:10:32,100 --> 01:10:35,400
走下去 在底部获取指向元组的指针，

1696
01:10:35,400 --> 01:10:37,230
如果你知道有你知道

1697
01:10:37,230 --> 01:10:39,600
的宠物，那么右下方没有路径，

1698
01:10:39,600 --> 01:10:41,520
但是在每个节点的 B+ 树中，

1699
01:10:41,520 --> 01:10:43,320
指向元组的指针

1700
01:10:43,320 --> 01:10:46,770
总是在叶节点，

1701
01:10:46,770 --> 01:10:49,620
所以掌握 是为这个筒仓项目建造的，

1702
01:10:49,620 --> 01:10:52,680
这是一个 在学术界，这

1703
01:10:52,680 --> 01:10:54,270
是一个非常有影响力的系统，

1704
01:10:54,270 --> 01:10:56,760
许多其他系统都基于它

1705
01:10:56,760 --> 01:10:58,350
编写的，你曾经用

1706
01:10:58,350 --> 01:11:00,930
热话来提交论文和

1707
01:11:00,930 --> 01:11:02,550
会议的那个人写的，

1708
01:11:02,550 --> 01:11:05,190
Eddie Koehler 疯了，他太棒了，所以

1709
01:11:05,190 --> 01:11:06,810
这个 是一个非常有趣的数据

1710
01:11:06,810 --> 01:11:08,010
结构我不知道有任何其他

1711
01:11:08,010 --> 01:11:09,840
系统可以做到这一点，但它

1712
01:11:09,840 --> 01:11:12,240
在学术评估中使用了很多，

1713
01:11:12,240 --> 01:11:13,230
所以现在我只想展示一下，

1714
01:11:13,230 --> 01:11:15,330
把它带回我

1715
01:11:15,330 --> 01:11:17,340
在最后展示的同一张图 最后一堂课，我们

1716
01:11:17,340 --> 01:11:18,990
在最后匆匆忙忙，但现在你

1717
01:11:18,990 --> 01:11:20,760
必须了解这些艺术

1718
01:11:20,760 --> 01:11:22,110
索引你实际上在做什么，

1719
01:11:22,110 --> 01:11:24,150
然后再次向你展示

1720
01:11:24,150 --> 01:11:25,680
我们为我们的系统构建的 B 双树的艺术

1721
01:11:25,680 --> 01:11:27,420


1722
01:11:27,420 --> 01:11:30,750
因为你知道 B+

1723
01:11:30,750 --> 01:11:33,240
树和艺术索引而被吹走，但

1724
01:11:33,240 --> 01:11:34,710
你可以在这里看到艺术索引

1725
01:11:34,710 --> 01:11:37,890
插入非常快，因为

1726
01:11:37,890 --> 01:11:39,360
一旦我插入一些东西，我意识到

1727
01:11:39,360 --> 01:11:40,860
我的 p 中没有任何东西低于我 我

1728
01:11:40,860 --> 01:11:42,510
不必继续插入更多的数字

1729
01:11:42,510 --> 01:11:45,600
我可以停止但你可以看到

1730
01:11:45,600 --> 01:11:48,360
扫描对它来说真的很糟糕，因为

1731
01:11:48,360 --> 01:11:50,400
你不能沿着你可以扫描的叶节点

1732
01:11:50,400 --> 01:11:52,470
和你必须遍历的 B+ 树

1733
01:11:52,470 --> 01:11:54,450
备份并返回，

1734
01:11:54,450 --> 01:11:56,540


1735
01:11:57,800 --> 01:12:03,440
所以是的，我完全承认

1736
01:12:03,440 --> 01:12:05,360
我对否决树的看法是错误的 我对

1737
01:12:05,360 --> 01:12:09,380
lat 树索引的看法错了 我错的是从不

1738
01:12:09,380 --> 01:12:12,170
使用操作系统互斥锁并且总是

1739
01:12:12,170 --> 01:12:14,030
在用户空间中使用自旋闩锁 所以我 错

1740
01:12:14,030 --> 01:12:16,670
对了 我知道没关系

1741
01:12:16,670 --> 01:12:18,830
然后无基数的东西 我想

1742
01:12:18,830 --> 01:12:20,000
我之所以让你们关注这个

1743
01:12:20,000 --> 01:12:23,450
是因为你知道 B 加树

1744
01:12:23,450 --> 01:12:25,490
仍然是

1745
01:12:25,490 --> 01:12:27,560
人们构建新系统时的首选

1746
01:12:27,560 --> 01:12:29,360
现在尝试越来越

1747
01:12:29,360 --> 01:12:31,580
流行让我部分原因是 mash 树

1748
01:12:31,580 --> 01:12:33,920
和基数树，我知道有几个

1749
01:12:33,920 --> 01:12:35,510
系统对合并它非常感兴趣，

1750
01:12:35,510 --> 01:12:37,340
并且在不同的方面，

1751
01:12:37,340 --> 01:12:39,410
比如数据存储人员，

1752
01:12:39,410 --> 01:12:40,430
你知道吗？ 在 Cassandra 上工作，

1753
01:12:40,430 --> 01:12:42,680
因此 Cassandra 他们 想

1754
01:12:42,680 --> 01:12:44,590


1755
01:12:44,590 --> 01:12:47,870
用尝试或基数树替换他们数据系统中的许多

1756
01:12:47,870 --> 01:12:50,120
内部数据结构艺术索引出现

1757
01:12:50,120 --> 01:12:51,500
在许多其他地方所以我认为

1758
01:12:51,500 --> 01:12:53,630
有进展我认为像艺术这样的东西

1759
01:12:53,630 --> 01:12:55,780
会更常见然后

1760
01:12:55,780 --> 01:12:58,820
好吧 所以下一堂课我们将

1761
01:12:58,820 --> 01:13:00,620
讨论更多的其他

1762
01:13:00,620 --> 01:13:02,480
事情，所以这一切都是关于系统目录

1763
01:13:02,480 --> 01:13:04,250
数据布局，然后是存储模型，我

1764
01:13:04,250 --> 01:13:07,370
应该知道现在我们知道如何最少

1765
01:13:07,370 --> 01:13:09,890
索引一些数据库索引一些表

1766
01:13:09,890 --> 01:13:12,770
并在它们上运行事务

1767
01:13:12,770 --> 01:13:14,240
建立系统的存储层

1768
01:13:14,240 --> 01:13:15,620
并实际开始存储数据

1769
01:13:15,620 --> 01:13:16,790
并跟踪我们实际

1770
01:13:16,790 --> 01:13:19,700
存储的内容好吧然后我

1771
01:13:19,700 --> 01:13:21,590
将尝试更新项目

1772
01:13:21,590 --> 01:13:24,650
网页以提供有关

1773
01:13:24,650 --> 01:13:25,880
如何完成的更多信息你知道是什么

1774
01:13:25,880 --> 01:13:26,930
你可以选择实施的不同选项

1775
01:13:26,930 --> 01:13:29,210
好吧，伙计们享受

1776
01:13:29,210 --> 01:13:30,950
你的周末，见你 把它存到边上的

1777
01:13:30,950 --> 01:13:34,270
公园里 这是什么

1778
01:13:34,420 --> 01:13:35,730
[音乐]

1779
01:13:35,730 --> 01:13:38,070
婊子们不是用那个叫做

1780
01:13:38,070 --> 01:13:41,070
Hokey c 的装备 uz I mochi 用 STI 冰冻你，

1781
01:13:41,070 --> 01:13:45,000
你看起来，它是去给我拿 40

1782
01:13:45,000 --> 01:13:47,340
只是为了让我的嗡嗡声 哦，因为我需要它

1783
01:13:47,340 --> 01:13:55,290
只是多一点踢卡车一个不错的

1784
01:13:55,290 --> 01:13:57,750
热狗，我的心不会说

1785
01:13:57,750 --> 01:14:00,090
我' 非常可爱，他们可以说我做了一个

1786
01:14:00,090 --> 01:14:02,450
祈祷

