1
00:00:03,640 --> 00:00:18,609
[Music]

2
00:00:18,609 --> 00:00:21,619
so as hopefully you've noticed I'm not

3
00:00:21,619 --> 00:00:26,720
Andy Andy and KB welcomed their first

4
00:00:26,720 --> 00:00:28,279
child last week everyone's doing well

5
00:00:28,279 --> 00:00:31,579
and we're just we're extremely thrilled

6
00:00:31,579 --> 00:00:33,260
to see the Andy Pablo parenting

7
00:00:33,260 --> 00:00:41,149
experiment so the clicker stopped

8
00:00:41,149 --> 00:00:47,989
working so last class Andy talked a lot

9
00:00:47,989 --> 00:00:50,390
about acid properties of transactions

10
00:00:50,390 --> 00:00:53,420
focusing a lot on isolation in

11
00:00:53,420 --> 00:00:57,199
particular reasoning about whether

12
00:00:57,199 --> 00:00:58,910
schedules are serializable and we talked

13
00:00:58,910 --> 00:01:00,980
about conflict serializability and view

14
00:01:00,980 --> 00:01:04,670
serializability and with conflict

15
00:01:04,670 --> 00:01:07,430
serializability we were able to to

16
00:01:07,430 --> 00:01:09,020
verify whether whether a schedule was

17
00:01:09,020 --> 00:01:11,600
serializable based on being able to swap

18
00:01:11,600 --> 00:01:12,920
operations around or looking at the

19
00:01:12,920 --> 00:01:14,720
dependency graph and being able to say

20
00:01:14,720 --> 00:01:17,680
yes this this schedule is serializable

21
00:01:17,680 --> 00:01:20,329
or whether whether it would violate the

22
00:01:20,329 --> 00:01:22,939
serializability guaranteed and then

23
00:01:22,939 --> 00:01:24,049
there was this other notion of view

24
00:01:24,049 --> 00:01:26,810
serializability which most applications

25
00:01:26,810 --> 00:01:28,909
are actually no systems really support

26
00:01:28,909 --> 00:01:31,670
because it's this this concept of being

27
00:01:31,670 --> 00:01:33,619
able to produce results to the

28
00:01:33,619 --> 00:01:34,820
application that look right to the

29
00:01:34,820 --> 00:01:36,430
application but actually aren't

30
00:01:36,430 --> 00:01:38,509
serializable as we've defined them it

31
00:01:38,509 --> 00:01:40,159
wouldn't be conflict serializable so i

32
00:01:40,159 --> 00:01:42,259
think he gave a couple examples one

33
00:01:42,259 --> 00:01:45,950
would be like counting all the number of

34
00:01:45,950 --> 00:01:47,060
accounts that had a positive balance

35
00:01:47,060 --> 00:01:48,710
while he was shuffling money around

36
00:01:48,710 --> 00:01:50,689
between the accounts and because the

37
00:01:50,689 --> 00:01:52,039
accounts never dropped negative we got

38
00:01:52,039 --> 00:01:54,140
the correct result but it wouldn't

39
00:01:54,140 --> 00:01:55,340
technically be a conflict serializable

40
00:01:55,340 --> 00:01:58,579
schedule I think another one was just

41
00:01:58,579 --> 00:02:00,229
doing blind writes in two accounts and

42
00:02:00,229 --> 00:02:02,210
because the last write that we cared

43
00:02:02,210 --> 00:02:04,340
about was the one that got executed it

44
00:02:04,340 --> 00:02:05,990
counts as view serializable but it's not

45
00:02:05,990 --> 00:02:11,120
actually conflict serializable so there

46
00:02:11,120 --> 00:02:12,380
was a lot of time spent on like how do

47
00:02:12,380 --> 00:02:14,959
you verify these schedules but now we

48
00:02:14,959 --> 00:02:17,330
want to care about is how do you do this

49
00:02:17,330 --> 00:02:20,409
stuff in real time because

50
00:02:20,409 --> 00:02:23,200
he's got an example here so an example

51
00:02:23,200 --> 00:02:26,739
of this is not conflict serializable

52
00:02:26,739 --> 00:02:29,470
because of we have this right on a and

53
00:02:29,470 --> 00:02:32,530
then another read on a unrepeatable read

54
00:02:32,530 --> 00:02:35,319
this is not conflict serializable so

55
00:02:35,319 --> 00:02:37,239
that's basically what Andy talked about

56
00:02:37,239 --> 00:02:40,629
in the last lecture I'm gonna try to

57
00:02:40,629 --> 00:02:41,950
make up for time here because we're

58
00:02:41,950 --> 00:02:45,640
starting a little late so as I was

59
00:02:45,640 --> 00:02:47,560
saying we need a way to do this on the

60
00:02:47,560 --> 00:02:49,180
fly in a real system we don't get the

61
00:02:49,180 --> 00:02:50,680
full schedules of transactions when

62
00:02:50,680 --> 00:02:52,900
they're submitted when clients connect

63
00:02:52,900 --> 00:02:54,190
to the database and they start a

64
00:02:54,190 --> 00:02:55,930
transaction we don't know what the

65
00:02:55,930 --> 00:02:58,690
queries are going to be aa priori so we

66
00:02:58,690 --> 00:03:01,030
can't look at what the clients going to

67
00:03:01,030 --> 00:03:02,620
do and predict whether their operations

68
00:03:02,620 --> 00:03:04,030
are going to be serializable or not so

69
00:03:04,030 --> 00:03:06,540
we need a protocol we need a we need a

70
00:03:06,540 --> 00:03:08,829
system that's going to allow us to

71
00:03:08,829 --> 00:03:11,230
execute these transactions in parallel

72
00:03:11,230 --> 00:03:12,489
because we want parallelism in the

73
00:03:12,489 --> 00:03:14,099
system but we still need to guarantee

74
00:03:14,099 --> 00:03:19,150
isolation between these transactions so

75
00:03:19,150 --> 00:03:23,379
I think Andy briefly mentioned this idea

76
00:03:23,379 --> 00:03:24,880
there are pessimistic approaches and

77
00:03:24,880 --> 00:03:26,620
optimistic approaches today we're going

78
00:03:26,620 --> 00:03:28,209
to look at two phase locking we're going

79
00:03:28,209 --> 00:03:30,579
to use locks in the system this is a

80
00:03:30,579 --> 00:03:31,870
pessimistic approach because basically

81
00:03:31,870 --> 00:03:35,560
you're gonna have to ask for permission

82
00:03:35,560 --> 00:03:38,980
from the system before every operation

83
00:03:38,980 --> 00:03:42,099
so before you can do a read or a write

84
00:03:42,099 --> 00:03:44,139
on a tuple you're gonna have to ask for

85
00:03:44,139 --> 00:03:48,669
a lock on that object optimistic will

86
00:03:48,669 --> 00:03:49,870
get too optimistic stuff in the next

87
00:03:49,870 --> 00:03:51,190
couple lectures but today it's all about

88
00:03:51,190 --> 00:03:57,810
pessimism with locks so this is just a

89
00:03:57,810 --> 00:04:00,190
kind of just a high-level what I was

90
00:04:00,190 --> 00:04:05,560
just describing an example of before we

91
00:04:05,560 --> 00:04:07,930
can do a read on a we're gonna go to a

92
00:04:07,930 --> 00:04:10,319
lock manager and say I want to lock on a

93
00:04:10,319 --> 00:04:13,120
this lock managers sort of your central

94
00:04:13,120 --> 00:04:14,290
authority on on whether you're allowed

95
00:04:14,290 --> 00:04:16,779
to access a tuple or not it maintains

96
00:04:16,779 --> 00:04:19,750
metadata about who holds locks and and

97
00:04:19,750 --> 00:04:22,419
enforces the the lock protocol in the

98
00:04:22,419 --> 00:04:25,810
system so tyonne's gonna begin it's

99
00:04:25,810 --> 00:04:27,669
going to request a lock from the lock

100
00:04:27,669 --> 00:04:30,700
manager on a it gets the lock as no one

101
00:04:30,700 --> 00:04:33,130
else holds it t2 begins let's imagine

102
00:04:33,130 --> 00:04:34,060
we're in a

103
00:04:34,060 --> 00:04:35,580
Oh threaded environments so we're only

104
00:04:35,580 --> 00:04:38,080
executing one of these transactions

105
00:04:38,080 --> 00:04:39,220
we're only making progress on one of

106
00:04:39,220 --> 00:04:41,320
these transactions at a time so t1

107
00:04:41,320 --> 00:04:43,840
begins gets the lock on a we switch to

108
00:04:43,840 --> 00:04:45,790
t2 it begins it wants the lock on a

109
00:04:45,790 --> 00:04:47,110
because it's eventually going to do a

110
00:04:47,110 --> 00:04:50,380
read and a write down here and it's

111
00:04:50,380 --> 00:04:52,030
denied by the lock manager because t1

112
00:04:52,030 --> 00:04:54,810
already holds that lock

113
00:04:54,930 --> 00:04:58,590
the only thing t2 can do here is stall

114
00:04:58,590 --> 00:05:01,360
what the behavior is is is kind of up to

115
00:05:01,360 --> 00:05:03,910
the implementation but there's there's

116
00:05:03,910 --> 00:05:05,080
gonna have to be some sort of stall

117
00:05:05,080 --> 00:05:06,400
because you can't get the lock that you

118
00:05:06,400 --> 00:05:10,180
want t1 proceeds does its write does its

119
00:05:10,180 --> 00:05:12,760
read releases its lock the lock managers

120
00:05:12,760 --> 00:05:15,610
now going to basically tell t2 you can

121
00:05:15,610 --> 00:05:17,290
get the lock that you want on a it's

122
00:05:17,290 --> 00:05:19,210
gonna grant it t2 is going to do it he

123
00:05:19,210 --> 00:05:21,970
it needs to do and then it's gonna it's

124
00:05:21,970 --> 00:05:22,840
going to release the lock so

125
00:05:22,840 --> 00:05:25,479
conceptually that's how we're gonna use

126
00:05:25,479 --> 00:05:27,130
locking in the system there's a there's

127
00:05:27,130 --> 00:05:28,240
a little bit more nuance to it than that

128
00:05:28,240 --> 00:05:30,280
and we'll go through that through the

129
00:05:30,280 --> 00:05:34,690
rest of the lecture make sense we're

130
00:05:34,690 --> 00:05:39,160
good so today we're gonna we're gonna

131
00:05:39,160 --> 00:05:40,510
look at the lock types first we're gonna

132
00:05:40,510 --> 00:05:43,240
start with two basic lock types and then

133
00:05:43,240 --> 00:05:46,260
we're gonna get into our first proper

134
00:05:46,260 --> 00:05:48,400
concurrency control protocol two-phase

135
00:05:48,400 --> 00:05:48,970
locking

136
00:05:48,970 --> 00:05:52,180
we're going to talk about how we reason

137
00:05:52,180 --> 00:05:53,680
about deadlocks and how we're gonna

138
00:05:53,680 --> 00:05:57,010
solve that problem and then we're gonna

139
00:05:57,010 --> 00:05:59,289
introduce the notion of hierarchical

140
00:05:59,289 --> 00:06:00,700
locking which is going to allow us to

141
00:06:00,700 --> 00:06:02,140
take fewer locks in the system to be a

142
00:06:02,140 --> 00:06:03,280
little bit more efficient about how we

143
00:06:03,280 --> 00:06:06,750
use locks and then the last thing that

144
00:06:06,750 --> 00:06:08,830
actually is a mistake we're not gonna

145
00:06:08,830 --> 00:06:10,539
get to isolation levels today he didn't

146
00:06:10,539 --> 00:06:13,600
make it last year and they're not in

147
00:06:13,600 --> 00:06:15,130
these slides anymore so we'll get to

148
00:06:15,130 --> 00:06:16,660
isolation levels I think we'll handle

149
00:06:16,660 --> 00:06:21,250
them in the next lecture so I think

150
00:06:21,250 --> 00:06:23,050
you've seen this slide before and II

151
00:06:23,050 --> 00:06:26,470
presented this this is from work by Gus

152
00:06:26,470 --> 00:06:29,229
grapha he showed it when you were

153
00:06:29,229 --> 00:06:31,600
talking about protecting concurrent data

154
00:06:31,600 --> 00:06:33,280
structures with latches so I think

155
00:06:33,280 --> 00:06:35,080
concurrent B plus tree indexes hash

156
00:06:35,080 --> 00:06:39,130
indexes things like that and I'm pretty

157
00:06:39,130 --> 00:06:40,660
sure this slide exists just to get Dave

158
00:06:40,660 --> 00:06:41,950
Anderson to stop making fun of us

159
00:06:41,950 --> 00:06:43,720
because he says database people are

160
00:06:43,720 --> 00:06:46,210
weird for calling locks latches and but

161
00:06:46,210 --> 00:06:47,889
they are distinct terms in our

162
00:06:47,889 --> 00:06:51,490
world before he was talking about and he

163
00:06:51,490 --> 00:06:52,240
was talking about

164
00:06:52,240 --> 00:06:55,870
like I said laches to protect threads

165
00:06:55,870 --> 00:06:57,849
from kind of trashing the the memory of

166
00:06:57,849 --> 00:07:00,249
your concurrent data structures today

167
00:07:00,249 --> 00:07:02,199
we're talking about locks which are

168
00:07:02,199 --> 00:07:04,240
protecting logical constructs in the

169
00:07:04,240 --> 00:07:06,249
database so things like databases tables

170
00:07:06,249 --> 00:07:09,840
tuples they're designed to protect

171
00:07:09,840 --> 00:07:11,590
transactions from conflicting with each

172
00:07:11,590 --> 00:07:13,990
other and probably the the key

173
00:07:13,990 --> 00:07:17,770
distinguishing part is that in with

174
00:07:17,770 --> 00:07:19,770
latches we avoided dead locks with

175
00:07:19,770 --> 00:07:22,360
programming discipline we were writing

176
00:07:22,360 --> 00:07:24,250
the logic on how these latches were

177
00:07:24,250 --> 00:07:26,229
acquired with with things like latch

178
00:07:26,229 --> 00:07:29,830
grabbing in the B+ tree how we could

179
00:07:29,830 --> 00:07:31,509
reason about what the operations were

180
00:07:31,509 --> 00:07:33,460
doing so we knew how to safely acquire

181
00:07:33,460 --> 00:07:36,039
latches in one order and then make sure

182
00:07:36,039 --> 00:07:37,840
we respected that order and release them

183
00:07:37,840 --> 00:07:38,979
in the correct order as well to avoid

184
00:07:38,979 --> 00:07:42,099
deadlocks with locks we can't do that

185
00:07:42,099 --> 00:07:43,750
because we don't know what the what the

186
00:07:43,750 --> 00:07:45,310
transactions are gonna do what queries

187
00:07:45,310 --> 00:07:48,339
they're gonna run so we need to be able

188
00:07:48,339 --> 00:07:52,060
to handle the clients issuing queries to

189
00:07:52,060 --> 00:07:53,680
the system that would result in a

190
00:07:53,680 --> 00:07:55,210
deadlock and and we need to talk about

191
00:07:55,210 --> 00:07:57,610
like what are we gonna do then because

192
00:07:57,610 --> 00:08:00,129
it's it's pretty simple to as well shown

193
00:08:00,129 --> 00:08:01,060
a demo a little bit later in the lecture

194
00:08:01,060 --> 00:08:02,889
it's pretty easy to put the system into

195
00:08:02,889 --> 00:08:10,960
a deadlock yeah so like I said we'll

196
00:08:10,960 --> 00:08:13,539
start with two basic lock types we have

197
00:08:13,539 --> 00:08:15,789
shared locks and exclusive locks shared

198
00:08:15,789 --> 00:08:18,250
locks are used for reads exclusive locks

199
00:08:18,250 --> 00:08:19,960
are used for writes these are kind of

200
00:08:19,960 --> 00:08:22,629
similar to the readwrite latches I think

201
00:08:22,629 --> 00:08:23,860
that we're talked about in the

202
00:08:23,860 --> 00:08:26,649
concurrent data structures the

203
00:08:26,649 --> 00:08:28,599
compatibility matrix kind of represents

204
00:08:28,599 --> 00:08:30,639
if you already have a shared latch can

205
00:08:30,639 --> 00:08:32,469
you hand out more shared latches to that

206
00:08:32,469 --> 00:08:36,250
yes exclusive latches are more or less

207
00:08:36,250 --> 00:08:37,929
incompatible with any other latch types

208
00:08:37,929 --> 00:08:40,029
you can't hand out multiple exclusive

209
00:08:40,029 --> 00:08:41,620
latches you can't hand out an exclusive

210
00:08:41,620 --> 00:08:42,940
latch to something that already has a

211
00:08:42,940 --> 00:08:48,029
shared latch and that's that's the basic

212
00:08:48,029 --> 00:08:52,199
compatibility of the of these latches

213
00:08:54,300 --> 00:08:55,830
or excuse me these these locks I

214
00:08:55,830 --> 00:08:58,170
shouldn't call them latches because Andy

215
00:08:58,170 --> 00:09:00,560
will get mad at me

216
00:09:00,560 --> 00:09:03,960
so the basic semantics of how we're

217
00:09:03,960 --> 00:09:05,460
going to work with locks is as I was

218
00:09:05,460 --> 00:09:06,720
describing for with that example you're

219
00:09:06,720 --> 00:09:07,800
gonna go to a lock manager and you're

220
00:09:07,800 --> 00:09:09,330
gonna say hey can I get a lock on this

221
00:09:09,330 --> 00:09:12,630
object the lock manager is gonna decide

222
00:09:12,630 --> 00:09:14,310
based on its internal metadata whether

223
00:09:14,310 --> 00:09:15,960
you're allowed to have that lock or not

224
00:09:15,960 --> 00:09:18,420
and then it's up to the transaction to

225
00:09:18,420 --> 00:09:20,130
release the lock when it's done the

226
00:09:20,130 --> 00:09:22,500
transaction managers or excuse me the

227
00:09:22,500 --> 00:09:25,590
lock managers not necessarily putting

228
00:09:25,590 --> 00:09:29,120
any sort of constraints on how long

229
00:09:29,120 --> 00:09:32,430
necessarily you have that lock for so

230
00:09:32,430 --> 00:09:33,810
it's up to the transaction to make sure

231
00:09:33,810 --> 00:09:35,550
they come back release the locks when

232
00:09:35,550 --> 00:09:38,040
they're done with it and then it updates

233
00:09:38,040 --> 00:09:40,200
an internal metadata I don't think

234
00:09:40,200 --> 00:09:42,570
there's a there's a Andy's not doing a

235
00:09:42,570 --> 00:09:44,220
walk manager project this semester we've

236
00:09:44,220 --> 00:09:45,870
done one in the past but like the basic

237
00:09:45,870 --> 00:09:48,480
implementation is there's an internal

238
00:09:48,480 --> 00:09:51,630
table probably a hash table that keeps

239
00:09:51,630 --> 00:09:54,300
track of all the possible locks and that

240
00:09:54,300 --> 00:09:56,340
are taken in the system and then as

241
00:09:56,340 --> 00:09:57,750
requests come in you put them into a

242
00:09:57,750 --> 00:09:59,730
queue you process them off the queue and

243
00:09:59,730 --> 00:10:04,770
you go forward from there so it's a cool

244
00:10:04,770 --> 00:10:05,760
project but I don't think you're doing

245
00:10:05,760 --> 00:10:10,620
one this year so let's look at an

246
00:10:10,620 --> 00:10:15,510
example with these shared exclusive

247
00:10:15,510 --> 00:10:18,480
locks that we defined before so t1

248
00:10:18,480 --> 00:10:20,460
begins it wants to do both a read and a

249
00:10:20,460 --> 00:10:21,570
write on a so it's going to go straight

250
00:10:21,570 --> 00:10:23,760
for the exclusive lock so it's going to

251
00:10:23,760 --> 00:10:26,790
go to the lock manager give me the

252
00:10:26,790 --> 00:10:28,440
exclusive lock lock managers like sure

253
00:10:28,440 --> 00:10:31,440
no one else has a lock on a it's all

254
00:10:31,440 --> 00:10:32,810
yours

255
00:10:32,810 --> 00:10:35,490
t1 completes the operations it needs to

256
00:10:35,490 --> 00:10:39,750
do on on tuple a releases the lock

257
00:10:39,750 --> 00:10:42,030
because it's done t2 comes along and

258
00:10:42,030 --> 00:10:44,190
says I want to do a write on a so it

259
00:10:44,190 --> 00:10:46,290
wants the exclusive lock now lock

260
00:10:46,290 --> 00:10:47,520
managers like sure no one's got that

261
00:10:47,520 --> 00:10:48,630
lock it's all yours

262
00:10:48,630 --> 00:10:51,120
do whatever you want it does it's right

263
00:10:51,120 --> 00:10:54,540
it unlocks a and then t1 wants to come

264
00:10:54,540 --> 00:10:56,340
back and just do a read so we only need

265
00:10:56,340 --> 00:10:58,980
a shared lock once again ask the lock

266
00:10:58,980 --> 00:11:01,500
manager give me the law does its

267
00:11:01,500 --> 00:11:03,840
operation releases the lock so as we

268
00:11:03,840 --> 00:11:05,700
described in the last slide transactions

269
00:11:05,700 --> 00:11:07,290
are responsible for for locking and

270
00:11:07,290 --> 00:11:08,010
unlocking

271
00:11:08,010 --> 00:11:09,750
the walk managers just kind of here to

272
00:11:09,750 --> 00:11:11,460
kind of direct traffic and make sure

273
00:11:11,460 --> 00:11:12,540
everyone's doing what they're supposed

274
00:11:12,540 --> 00:11:17,130
to be doing does anything jump out as a

275
00:11:17,130 --> 00:11:21,500
problem with this schedule what's up

276
00:11:21,500 --> 00:11:24,780
right it's not isolated so in particular

277
00:11:24,780 --> 00:11:26,850
when t1 at the end does it does another

278
00:11:26,850 --> 00:11:29,280
read it's it's getting an unrepeatable

279
00:11:29,280 --> 00:11:32,390
read it read tuple a it did a write on a

280
00:11:32,390 --> 00:11:34,770
but then it goes back and it reads a and

281
00:11:34,770 --> 00:11:36,390
it's actually seeing the the the value

282
00:11:36,390 --> 00:11:39,030
that t2 wrote so we have an unrepeatable

283
00:11:39,030 --> 00:11:41,490
read anomaly we can't have that so we're

284
00:11:41,490 --> 00:11:42,540
gonna need to be a little bit smarter

285
00:11:42,540 --> 00:11:44,730
with with with what we do with our locks

286
00:11:44,730 --> 00:11:46,010
we're going to need a little bit more

287
00:11:46,010 --> 00:11:49,800
discipline and an NA and a protocol

288
00:11:49,800 --> 00:11:53,000
applied to to what we're doing here

289
00:11:53,330 --> 00:11:56,160
right so Andy added one more cool

290
00:11:56,160 --> 00:11:58,050
animation to show this is a problem this

291
00:11:58,050 --> 00:11:59,490
is here's your here's your unrepeatable

292
00:11:59,490 --> 00:12:03,450
read so we're going to use is is a

293
00:12:03,450 --> 00:12:05,690
protocol called two-phase locking and

294
00:12:05,690 --> 00:12:09,230
it's gonna allow the database system to

295
00:12:09,230 --> 00:12:12,180
hand out locks in a manner that always

296
00:12:12,180 --> 00:12:13,470
guarantees conflict serializable

297
00:12:13,470 --> 00:12:16,080
schedules this is a big deal because now

298
00:12:16,080 --> 00:12:19,260
we don't have to try to limit the

299
00:12:19,260 --> 00:12:20,880
parallelism in the system we can try to

300
00:12:20,880 --> 00:12:22,350
run multiple transactions at the same

301
00:12:22,350 --> 00:12:26,010
time and we don't need to know what the

302
00:12:26,010 --> 00:12:27,510
transactions are gonna do ahead of time

303
00:12:27,510 --> 00:12:29,310
to be able to decide if they're conflict

304
00:12:29,310 --> 00:12:30,900
serializable where the system can run we

305
00:12:30,900 --> 00:12:32,730
can do operations and we can hopefully

306
00:12:32,730 --> 00:12:34,530
get high throughput on transactions

307
00:12:34,530 --> 00:12:38,310
without generating unci realisable

308
00:12:38,310 --> 00:12:40,410
schedules or violating our isolation

309
00:12:40,410 --> 00:12:43,560
requirements this is all work that came

310
00:12:43,560 --> 00:12:48,420
out of IBM in mid 70s for the system our

311
00:12:48,420 --> 00:12:50,520
project it was led by Jim Gray who later

312
00:12:50,520 --> 00:12:53,910
went on to win a Turing Award so this is

313
00:12:53,910 --> 00:12:55,260
pretty groundbreaking stuff this is at

314
00:12:55,260 --> 00:12:57,600
the time they were building one of the

315
00:12:57,600 --> 00:12:59,070
first relational database management

316
00:12:59,070 --> 00:13:01,380
systems so there was no textbook on how

317
00:13:01,380 --> 00:13:03,540
to do this stuff two-phase locking is

318
00:13:03,540 --> 00:13:04,440
what they came up with

319
00:13:04,440 --> 00:13:06,060
turns out it's a pretty good idea most

320
00:13:06,060 --> 00:13:09,530
systems use two phase locking now

321
00:13:11,440 --> 00:13:14,780
so you're probably not surprised to see

322
00:13:14,780 --> 00:13:17,540
that two phase locking has two phases

323
00:13:17,540 --> 00:13:19,280
there's the growing phase and then

324
00:13:19,280 --> 00:13:20,930
there's the shrinking phase so in the

325
00:13:20,930 --> 00:13:22,670
growing phase of a transaction it's

326
00:13:22,670 --> 00:13:24,470
allowed to acquire whatever Locke said

327
00:13:24,470 --> 00:13:27,380
it needs it goes to Locke manager gets

328
00:13:27,380 --> 00:13:29,630
everything that it needs and then it

329
00:13:29,630 --> 00:13:31,700
performs all of its operations and then

330
00:13:31,700 --> 00:13:33,710
the second it releases a lock tells the

331
00:13:33,710 --> 00:13:35,210
Locke manager I'm done with this lock

332
00:13:35,210 --> 00:13:37,370
the transaction is now in a shrinking

333
00:13:37,370 --> 00:13:39,320
phase it is no longer allowed to acquire

334
00:13:39,320 --> 00:13:42,440
anymore locks so in an example we'll see

335
00:13:42,440 --> 00:13:44,450
how this how this helped us out how this

336
00:13:44,450 --> 00:13:47,240
prevents the anomalies we're concerned

337
00:13:47,240 --> 00:13:53,630
about and I think yeah so get another

338
00:13:53,630 --> 00:13:55,010
way to think about it is this this

339
00:13:55,010 --> 00:13:57,710
visualization x-axis is time this is the

340
00:13:57,710 --> 00:13:59,870
lifetime of a single transaction y-axis

341
00:13:59,870 --> 00:14:01,040
is the number of locks held by that

342
00:14:01,040 --> 00:14:03,110
transaction so in the growing phase it

343
00:14:03,110 --> 00:14:04,730
can continue to accumulate as many locks

344
00:14:04,730 --> 00:14:06,650
as it needs the second it releases a

345
00:14:06,650 --> 00:14:07,940
lock it's gonna go into the shrinking

346
00:14:07,940 --> 00:14:14,000
phase you get no more locks so this is

347
00:14:14,000 --> 00:14:17,330
this is an example of a violation of

348
00:14:17,330 --> 00:14:19,400
two-phase locking because the

349
00:14:19,400 --> 00:14:20,600
transaction released some locks and I

350
00:14:20,600 --> 00:14:22,460
went back and acquired some more we

351
00:14:22,460 --> 00:14:27,140
can't have that yeah it it would cause

352
00:14:27,140 --> 00:14:28,580
the same sort of problems we saw in the

353
00:14:28,580 --> 00:14:29,720
previous example where we had an

354
00:14:29,720 --> 00:14:31,100
unrepeatable read where you release the

355
00:14:31,100 --> 00:14:32,570
lock when they went back acquired a lock

356
00:14:32,570 --> 00:14:36,080
and and you get anomalies because of

357
00:14:36,080 --> 00:14:40,940
that so here's an example with with two

358
00:14:40,940 --> 00:14:43,730
phase locking transaction one's gonna

359
00:14:43,730 --> 00:14:46,010
begin like before it needs an exclusive

360
00:14:46,010 --> 00:14:47,090
lock because it wants to do both a read

361
00:14:47,090 --> 00:14:50,420
and a write on the tuple it could start

362
00:14:50,420 --> 00:14:51,770
with a shared lock and upgrade it there

363
00:14:51,770 --> 00:14:53,210
was a notion on an earlier slide of

364
00:14:53,210 --> 00:14:54,860
upgrading we'll talk about upgrading a

365
00:14:54,860 --> 00:14:57,350
little bit more later in the lecture but

366
00:14:57,350 --> 00:14:58,610
we're gonna start for now with an

367
00:14:58,610 --> 00:15:01,460
exclusive law goes the lock manager gets

368
00:15:01,460 --> 00:15:07,400
the lock t2 wants the exclusive lock it

369
00:15:07,400 --> 00:15:09,530
can't have it because t1 still holds it

370
00:15:09,530 --> 00:15:10,550
so we're gonna keep holding onto that

371
00:15:10,550 --> 00:15:11,780
lock till we're done with all of our

372
00:15:11,780 --> 00:15:14,360
operations we're gonna do the extra read

373
00:15:14,360 --> 00:15:16,280
that we wanted in t1 then we're gonna

374
00:15:16,280 --> 00:15:18,920
release the lock t2 has been stalled

375
00:15:18,920 --> 00:15:20,330
this whole time not able to make any

376
00:15:20,330 --> 00:15:22,070
progress because it didn't get the lock

377
00:15:22,070 --> 00:15:23,360
on on

378
00:15:23,360 --> 00:15:26,390
a lakh managers gonna say ok t2 you get

379
00:15:26,390 --> 00:15:29,420
what you want do you're right and then

380
00:15:29,420 --> 00:15:40,399
t2 is gonna unlock and then commit so

381
00:15:40,399 --> 00:15:41,180
the great thing about two-phase locking

382
00:15:41,180 --> 00:15:44,060
is if you follow this protocol you will

383
00:15:44,060 --> 00:15:47,360
get conflict serializable schedules the

384
00:15:47,360 --> 00:15:49,220
there get the dependency graphs are

385
00:15:49,220 --> 00:15:51,260
guaranteed to be a cyclic this is great

386
00:15:51,260 --> 00:15:53,600
this is exactly what we want it does

387
00:15:53,600 --> 00:15:56,450
have a slight problem though and that is

388
00:15:56,450 --> 00:15:59,060
cascading abort so we'll give an example

389
00:15:59,060 --> 00:16:02,540
on the next slide but the idea is it can

390
00:16:02,540 --> 00:16:05,240
because two phase locking alone does not

391
00:16:05,240 --> 00:16:07,100
guarantee that you don't get dirty reads

392
00:16:07,100 --> 00:16:12,010
you can you can lead to cascading aborts

393
00:16:15,279 --> 00:16:19,839
so this is the same schedule as before

394
00:16:19,839 --> 00:16:26,060
we're going to access to different

395
00:16:26,060 --> 00:16:28,490
tuples we're gonna get the exclusive

396
00:16:28,490 --> 00:16:29,810
lock on a and the exclusive lock at B

397
00:16:29,810 --> 00:16:31,160
that's because all the way down here

398
00:16:31,160 --> 00:16:32,990
we're gonna do operations on B and we

399
00:16:32,990 --> 00:16:34,279
have to get all of our locks before we

400
00:16:34,279 --> 00:16:35,810
start unlocking anything because we're

401
00:16:35,810 --> 00:16:39,110
in two-phase locking so t1 does the

402
00:16:39,110 --> 00:16:41,449
operations it needs releases lock on a

403
00:16:41,449 --> 00:16:45,050
t2 gets the lock on a does a read and

404
00:16:45,050 --> 00:16:50,800
then also does a write and then t1 abort

405
00:16:50,800 --> 00:16:54,550
but there's this problem now that t2

406
00:16:54,550 --> 00:16:58,670
read a value that from t1 that is now

407
00:16:58,670 --> 00:17:00,529
not actually in the system because the

408
00:17:00,529 --> 00:17:03,800
transaction aborted it didn't commit so

409
00:17:03,800 --> 00:17:06,049
we have this dependency now that because

410
00:17:06,049 --> 00:17:08,540
t1 aborted you now have to abort t2 as

411
00:17:08,540 --> 00:17:10,339
well because it read a value that isn't

412
00:17:10,339 --> 00:17:12,049
valid anymore so that's what we mean by

413
00:17:12,049 --> 00:17:14,569
by saying two-phase locking is

414
00:17:14,569 --> 00:17:19,669
susceptible to cascading aborts and this

415
00:17:19,669 --> 00:17:21,420
is this is

416
00:17:21,420 --> 00:17:23,010
the reason this is a problem is because

417
00:17:23,010 --> 00:17:26,069
you could be wasting a lot of work so t2

418
00:17:26,069 --> 00:17:28,170
could have you know because it read a

419
00:17:28,170 --> 00:17:30,000
value in t1 it could have done a bunch

420
00:17:30,000 --> 00:17:31,860
of operations on the system and now

421
00:17:31,860 --> 00:17:33,960
because t2 has to has to abort as well

422
00:17:33,960 --> 00:17:36,000
you're increasing the complexity of your

423
00:17:36,000 --> 00:17:37,770
rollback logic more and more stuff needs

424
00:17:37,770 --> 00:17:39,000
to be rolled back in the system just

425
00:17:39,000 --> 00:17:41,430
because one transaction aborted it leads

426
00:17:41,430 --> 00:17:42,510
to another transaction board you can

427
00:17:42,510 --> 00:17:43,560
kind of see how this could Domino

428
00:17:43,560 --> 00:17:44,730
through the system if you have a bunch

429
00:17:44,730 --> 00:17:46,380
of transactions running that are

430
00:17:46,380 --> 00:17:48,570
simultaneously reading values from each

431
00:17:48,570 --> 00:17:54,630
other and then one of boards so another

432
00:17:54,630 --> 00:17:56,190
thing worth pointing out is this is a

433
00:17:56,190 --> 00:17:58,620
valid schedule under under two-phase

434
00:17:58,620 --> 00:18:00,380
locking

435
00:18:00,380 --> 00:18:06,270
it's yeah it's basically kind of what I

436
00:18:06,270 --> 00:18:08,760
stated already you can't let information

437
00:18:08,760 --> 00:18:10,410
from t1 leak to the outside world

438
00:18:10,410 --> 00:18:12,060
because it aborted but it would be a

439
00:18:12,060 --> 00:18:13,380
permissible schedule under two-phase

440
00:18:13,380 --> 00:18:14,400
locking so we're gonna have to solve

441
00:18:14,400 --> 00:18:20,010
this somehow and yeah like I said this

442
00:18:20,010 --> 00:18:21,570
is all wasted work t2 could have done a

443
00:18:21,570 --> 00:18:23,280
bunch of complicated logic and a bunch

444
00:18:23,280 --> 00:18:24,960
of more writes into the system and

445
00:18:24,960 --> 00:18:26,880
because we have to abort it we wasted a

446
00:18:26,880 --> 00:18:34,290
bunch of time so a couple other a couple

447
00:18:34,290 --> 00:18:35,370
other things about about two-phase

448
00:18:35,370 --> 00:18:37,410
locking that we want to point out there

449
00:18:37,410 --> 00:18:40,110
are schedules that are serializable that

450
00:18:40,110 --> 00:18:41,760
two phase locking actually won't allow

451
00:18:41,760 --> 00:18:44,360
two phase locking is a little bit more I

452
00:18:44,360 --> 00:18:50,970
guess I'll say conservative or yeah

453
00:18:50,970 --> 00:18:53,760
we'll use that word because there are

454
00:18:53,760 --> 00:18:55,140
serializable schedules that two phase

455
00:18:55,140 --> 00:18:58,170
locking will try to will we would not be

456
00:18:58,170 --> 00:18:59,910
allowed and because of the locking we're

457
00:18:59,910 --> 00:19:01,200
gonna limit the concurrency the system

458
00:19:01,200 --> 00:19:04,530
slightly as I mentioned we have this

459
00:19:04,530 --> 00:19:06,840
problem with with dirty dirty reads that

460
00:19:06,840 --> 00:19:08,580
can lead to cascading aborts we're gonna

461
00:19:08,580 --> 00:19:12,360
solve that with a modification to two

462
00:19:12,360 --> 00:19:13,830
phase locking called strong strict two

463
00:19:13,830 --> 00:19:15,300
phase locking it's also called rigorous

464
00:19:15,300 --> 00:19:17,040
two phase locking

465
00:19:17,040 --> 00:19:18,360
the terms are kind of used

466
00:19:18,360 --> 00:19:19,950
interchangeably I think the textbook

467
00:19:19,950 --> 00:19:23,040
refers to both and we have this other

468
00:19:23,040 --> 00:19:25,230
problem which is common with a lot of

469
00:19:25,230 --> 00:19:27,900
locking protocols that we can lead to

470
00:19:27,900 --> 00:19:29,670
dead locks so we're gonna need to solve

471
00:19:29,670 --> 00:19:32,490
that problem with either a detection

472
00:19:32,490 --> 00:19:34,140
mechanism where we can detect when we

473
00:19:34,140 --> 00:19:35,340
enter into a deadlock State

474
00:19:35,340 --> 00:19:37,230
or some sort of extension of the

475
00:19:37,230 --> 00:19:40,020
protocol where we prevent ourselves from

476
00:19:40,020 --> 00:19:41,670
ever being able to go into a deadlock

477
00:19:41,670 --> 00:19:44,490
state so again going back to kind of

478
00:19:44,490 --> 00:19:46,020
what we did with laches with concurrent

479
00:19:46,020 --> 00:19:48,180
data structures we make sure we acquire

480
00:19:48,180 --> 00:19:50,520
the locks in a very specific way that

481
00:19:50,520 --> 00:19:52,650
makes it so that we can guarantee we're

482
00:19:52,650 --> 00:19:54,450
never going to enter into a deadlock

483
00:19:54,450 --> 00:20:06,930
scenario so we're going to tackle the

484
00:20:06,930 --> 00:20:07,980
first one first we're going to talk

485
00:20:07,980 --> 00:20:11,780
about strong fake two-phase locking

486
00:20:12,140 --> 00:20:14,850
it's sort of a misnomer because the

487
00:20:14,850 --> 00:20:17,070
second phase doesn't really exist

488
00:20:17,070 --> 00:20:19,140
anymore all strong strict two phase

489
00:20:19,140 --> 00:20:21,900
locking says is you don't release any of

490
00:20:21,900 --> 00:20:23,040
your locks until the end of the

491
00:20:23,040 --> 00:20:24,710
transaction when you're going to commit

492
00:20:24,710 --> 00:20:27,000
the growing phase is exactly the same

493
00:20:27,000 --> 00:20:28,530
you keep acquiring locks as you need

494
00:20:28,530 --> 00:20:32,670
them but you don't release any locks

495
00:20:32,670 --> 00:20:35,460
until commit time and this is going to

496
00:20:35,460 --> 00:20:38,040
allow us to prevent any unrepeatable or

497
00:20:38,040 --> 00:20:39,960
excuse me any dirty reads from

498
00:20:39,960 --> 00:20:41,850
propagating across transactions which is

499
00:20:41,850 --> 00:20:43,500
also going to solve the cascading aborts

500
00:20:43,500 --> 00:20:49,140
problem for us so yeah the figure is

501
00:20:49,140 --> 00:20:50,340
kind of updated but as you can see like

502
00:20:50,340 --> 00:20:53,730
the shrinking phase it wherever you want

503
00:20:53,730 --> 00:20:55,590
to define it as like the last the last

504
00:20:55,590 --> 00:20:57,120
lock you acquired is the start of the

505
00:20:57,120 --> 00:20:58,650
shrinking phase but basically there is

506
00:20:58,650 --> 00:21:00,240
no shrinking phase everything gets

507
00:21:00,240 --> 00:21:01,890
released at once at the end of the

508
00:21:01,890 --> 00:21:08,970
transaction yeah and the the word

509
00:21:08,970 --> 00:21:10,530
strictness does have a specific meaning

510
00:21:10,530 --> 00:21:12,570
in when we're talking about concurrency

511
00:21:12,570 --> 00:21:17,310
control it basically means anything that

512
00:21:17,310 --> 00:21:18,840
you wrote none of your rights are going

513
00:21:18,840 --> 00:21:21,000
to be visible to to any other asset any

514
00:21:21,000 --> 00:21:22,620
other area of the system any other

515
00:21:22,620 --> 00:21:26,280
transactions things like that until you

516
00:21:26,280 --> 00:21:29,400
commit so so in this context strict has

517
00:21:29,400 --> 00:21:32,340
a very specific meaning and like I said

518
00:21:32,340 --> 00:21:34,110
that solves our cascade cascading aborts

519
00:21:34,110 --> 00:21:35,850
problem because no other transactions

520
00:21:35,850 --> 00:21:37,080
are gonna see values that aren't

521
00:21:37,080 --> 00:21:39,240
committed to the system yet so they're

522
00:21:39,240 --> 00:21:40,820
only looking at committed data

523
00:21:40,820 --> 00:21:45,630
everyone's happy and and like I

524
00:21:45,630 --> 00:21:47,550
mentioned before this simplifies your

525
00:21:47,550 --> 00:21:49,170
abort logic because

526
00:21:49,170 --> 00:21:50,820
abortive transactions only have to put

527
00:21:50,820 --> 00:21:53,640
back their values you don't need to

528
00:21:53,640 --> 00:21:55,500
worry about all these transactions in

529
00:21:55,500 --> 00:21:57,060
the system potentially reading

530
00:21:57,060 --> 00:21:59,550
uncommitted data and then they each kind

531
00:21:59,550 --> 00:22:03,120
of have to store their own metadata

532
00:22:03,120 --> 00:22:05,760
almost or methods to be able to roll

533
00:22:05,760 --> 00:22:07,950
back the the work that they've done the

534
00:22:07,950 --> 00:22:09,690
simplifies things a lot by not having to

535
00:22:09,690 --> 00:22:11,220
reason about multiple versions in the

536
00:22:11,220 --> 00:22:11,670
system

537
00:22:11,670 --> 00:22:13,770
you only have one undo to do if you if

538
00:22:13,770 --> 00:22:19,590
you wrote a value so we're gonna look at

539
00:22:19,590 --> 00:22:24,120
a simple example andy owes his bookie

540
00:22:24,120 --> 00:22:26,610
money I guess so he's gonna move a

541
00:22:26,610 --> 00:22:28,140
hundred dollars to is to his bookies

542
00:22:28,140 --> 00:22:29,640
account and then the second transaction

543
00:22:29,640 --> 00:22:32,310
is just gonna gonna compute the sum this

544
00:22:32,310 --> 00:22:34,860
echo command is is made up it's not a

545
00:22:34,860 --> 00:22:36,720
real statement he just wants to

546
00:22:36,720 --> 00:22:38,460
demonstrate that you're reading these

547
00:22:38,460 --> 00:22:41,400
values out we could have done something

548
00:22:41,400 --> 00:22:43,230
more complicated but we want to keep the

549
00:22:43,230 --> 00:22:45,360
example fairly simple first we're gonna

550
00:22:45,360 --> 00:22:47,490
look at it with I think just basic

551
00:22:47,490 --> 00:22:49,230
walking then two-phase locking and then

552
00:22:49,230 --> 00:22:52,350
strong strict tooth days locking so with

553
00:22:52,350 --> 00:22:53,790
the two locks that we defined at the

554
00:22:53,790 --> 00:22:55,020
beginning and we're not if we're not

555
00:22:55,020 --> 00:22:58,580
using two phase locking we can see

556
00:22:58,580 --> 00:23:00,600
spoiler alert you're gonna get a you're

557
00:23:00,600 --> 00:23:03,180
gonna get a wrong output from this so

558
00:23:03,180 --> 00:23:04,710
we're start with a thousand dollars in

559
00:23:04,710 --> 00:23:09,120
each account t1 already gets the

560
00:23:09,120 --> 00:23:10,590
exclusive lock does a read because it

561
00:23:10,590 --> 00:23:13,260
needs to decrement his his balance by a

562
00:23:13,260 --> 00:23:17,370
hundred bucks t2 wants to get the shared

563
00:23:17,370 --> 00:23:18,750
lock because it's trying to compute the

564
00:23:18,750 --> 00:23:20,520
sum it can't get it so it just starts

565
00:23:20,520 --> 00:23:24,060
waiting t1 finishes his operation to

566
00:23:24,060 --> 00:23:28,590
decrement unlocks a at that time t2 gets

567
00:23:28,590 --> 00:23:30,720
the lock on a and performs its read and

568
00:23:30,720 --> 00:23:32,550
then unlocks it because again we're not

569
00:23:32,550 --> 00:23:33,990
in two phase locking here so you're free

570
00:23:33,990 --> 00:23:36,180
to acquire and release locks as you need

571
00:23:36,180 --> 00:23:41,280
them it also t2 also gets the shared

572
00:23:41,280 --> 00:23:42,570
lock on B because it needs to do a write

573
00:23:42,570 --> 00:23:44,820
on that which leads t1 to stall because

574
00:23:44,820 --> 00:23:46,920
it can't do the operation or it can't

575
00:23:46,920 --> 00:23:50,720
access that tuple yet eventually t2

576
00:23:50,720 --> 00:23:54,590
releases the lock t1 gets the lock on B

577
00:23:54,590 --> 00:23:56,400
finishes moving the money over to the

578
00:23:56,400 --> 00:24:01,140
bookies account unlocks commits and t2

579
00:24:01,140 --> 00:24:02,670
gives us a wrong output because

580
00:24:02,670 --> 00:24:05,190
did it read an inconsistent state it

581
00:24:05,190 --> 00:24:08,970
read harsh part of the work that t1 had

582
00:24:08,970 --> 00:24:11,400
done and t1 leaked that information to

583
00:24:11,400 --> 00:24:12,390
the rest of the system and said okay

584
00:24:12,390 --> 00:24:14,730
this bank account balances 900 bucks but

585
00:24:14,730 --> 00:24:16,470
it that hundred dollars was missing at

586
00:24:16,470 --> 00:24:18,720
that point when t2 came along and got

587
00:24:18,720 --> 00:24:21,560
the locks that it needed

588
00:24:21,770 --> 00:24:27,570
so with two-phase locking the key the

589
00:24:27,570 --> 00:24:31,260
key thing to notice here is it starts

590
00:24:31,260 --> 00:24:33,540
the same t1 gets its exclusive walk on a

591
00:24:33,540 --> 00:24:35,310
performs the operation it needs but

592
00:24:35,310 --> 00:24:37,860
before it unlocks a which would put it

593
00:24:37,860 --> 00:24:40,020
into the shrinking phase it acquires the

594
00:24:40,020 --> 00:24:42,050
lock it needs on B all the way down here

595
00:24:42,050 --> 00:24:46,440
so it gets the exclusive lock on b t2

596
00:24:46,440 --> 00:24:47,940
stuck waiting around waiting for the

597
00:24:47,940 --> 00:24:50,940
locks that it needs because this isn't

598
00:24:50,940 --> 00:24:52,710
strong strict two-phase locking

599
00:24:52,710 --> 00:24:59,460
t1 actually unlocks it well yeah if this

600
00:24:59,460 --> 00:25:00,570
were strong strict it would it would be

601
00:25:00,570 --> 00:25:03,600
down here at commit time so it unlocks a

602
00:25:03,600 --> 00:25:06,330
finishes this operation on on object B

603
00:25:06,330 --> 00:25:09,750
and then releases the locks and this

604
00:25:09,750 --> 00:25:13,650
actually gives us a correct output same

605
00:25:13,650 --> 00:25:14,910
example with strong trick two-phase

606
00:25:14,910 --> 00:25:17,610
walking like I said the unlocking

607
00:25:17,610 --> 00:25:19,650
happens at the end right before commit

608
00:25:19,650 --> 00:25:22,020
so yeah t1 gets its lock t2 has to wait

609
00:25:22,020 --> 00:25:25,850
the entire time you can sort of see how

610
00:25:25,850 --> 00:25:27,840
strong strict two-phase locking is

611
00:25:27,840 --> 00:25:30,660
effectively forcing a serial ordering

612
00:25:30,660 --> 00:25:34,020
for these transactions by basically

613
00:25:34,020 --> 00:25:35,820
acquiring all your locks holding on to

614
00:25:35,820 --> 00:25:38,040
them until you get to commit time you're

615
00:25:38,040 --> 00:25:39,390
guaranteeing that that any of the

616
00:25:39,390 --> 00:25:41,250
operations that that t2 would have that

617
00:25:41,250 --> 00:25:43,410
would conflict are going to be forced in

618
00:25:43,410 --> 00:25:51,600
a serial ordering make sense I'll go

619
00:25:51,600 --> 00:25:52,800
with yes

620
00:25:52,800 --> 00:25:56,700
and then the correct output again as

621
00:25:56,700 --> 00:25:59,610
well so I think I think Andy showed this

622
00:25:59,610 --> 00:26:02,220
slide before in the universe of

623
00:26:02,220 --> 00:26:03,030
schedules

624
00:26:03,030 --> 00:26:06,060
he showed cereal schedules conflict

625
00:26:06,060 --> 00:26:08,070
serializable schedules you serializable

626
00:26:08,070 --> 00:26:09,930
and then I don't know if he had

627
00:26:09,930 --> 00:26:12,360
cascading aborts in there so this slide

628
00:26:12,360 --> 00:26:14,520
actually I think is he mentions it last

629
00:26:14,520 --> 00:26:16,050
year is actually incomplete what he

630
00:26:16,050 --> 00:26:18,120
meant to show is where two-phase walking

631
00:26:18,120 --> 00:26:19,860
and strong strict two phase locking live

632
00:26:19,860 --> 00:26:25,500
in this hierarchy and I'll see if I can

633
00:26:25,500 --> 00:26:27,270
at least use the laser pointer because a

634
00:26:27,270 --> 00:26:29,100
clicker doesn't seem to be doing

635
00:26:29,100 --> 00:26:31,950
anything nope

636
00:26:31,950 --> 00:26:35,630
so two-phase locking is gonna live in

637
00:26:35,630 --> 00:26:38,970
kind of this area right here it's

638
00:26:38,970 --> 00:26:40,200
guaranteed to generate conflict

639
00:26:40,200 --> 00:26:43,110
serializable schedules but it's going to

640
00:26:43,110 --> 00:26:47,340
be susceptible to cascading aborts I'll

641
00:26:47,340 --> 00:26:49,110
see if we can get this slide updated for

642
00:26:49,110 --> 00:26:50,430
the ones that actually get published on

643
00:26:50,430 --> 00:26:52,350
the site so we actually see better than

644
00:26:52,350 --> 00:26:54,270
just a laser pointer on the video but

645
00:26:54,270 --> 00:26:55,890
yeah two phase locking would be here and

646
00:26:55,890 --> 00:26:59,580
then inside of this box and a round

647
00:26:59,580 --> 00:27:01,080
serial you would have strong trick

648
00:27:01,080 --> 00:27:02,700
two-phase locking because it's

649
00:27:02,700 --> 00:27:04,230
guaranteed not to have cascading aborts

650
00:27:04,230 --> 00:27:06,200
we get conflict serializable schedules

651
00:27:06,200 --> 00:27:14,010
we're happy makes sense so now let's

652
00:27:14,010 --> 00:27:15,990
talk about the other problem with

653
00:27:15,990 --> 00:27:18,300
two-phase locking which is that it leads

654
00:27:18,300 --> 00:27:19,920
to dead locks and like I mentioned

655
00:27:19,920 --> 00:27:21,480
before there's a couple different ways

656
00:27:21,480 --> 00:27:23,160
we can try to solve this problem we can

657
00:27:23,160 --> 00:27:27,960
be kind of lazy about it and wait use a

658
00:27:27,960 --> 00:27:30,390
detection algorithm to to find a

659
00:27:30,390 --> 00:27:32,070
deadlock or we can kind of be a little

660
00:27:32,070 --> 00:27:33,990
bit more proactive about things and try

661
00:27:33,990 --> 00:27:35,130
to prevent them from ever happening in

662
00:27:35,130 --> 00:27:43,710
the first place so you've probably seen

663
00:27:43,710 --> 00:27:46,770
dead locks before it's a it's a fairly

664
00:27:46,770 --> 00:27:50,580
common concept in computer systems but

665
00:27:50,580 --> 00:27:53,610
we'll give a basic example anyway so t1

666
00:27:53,610 --> 00:27:55,710
wants an exclusive lock on a block

667
00:27:55,710 --> 00:27:57,150
managers like sure you can have that no

668
00:27:57,150 --> 00:28:00,330
one else has that lock t2 gets the lock

669
00:28:00,330 --> 00:28:01,860
on B because no one else has that lock

670
00:28:01,860 --> 00:28:05,310
now t2 says I want the lock on a block

671
00:28:05,310 --> 00:28:06,570
managers like no

672
00:28:06,570 --> 00:28:08,610
you don't get that but t2 is gonna sit

673
00:28:08,610 --> 00:28:11,730
around and wait for that lock and t1 now

674
00:28:11,730 --> 00:28:14,910
wants the exclusive lock on B and it's

675
00:28:14,910 --> 00:28:16,620
gonna wait as well we have a problem now

676
00:28:16,620 --> 00:28:18,800
both these transactions are waiting for

677
00:28:18,800 --> 00:28:21,750
locks that the other transaction holds

678
00:28:21,750 --> 00:28:27,470
so we need to break this somehow yeah

679
00:28:27,470 --> 00:28:38,130
nice animation we have a problem yeah so

680
00:28:38,130 --> 00:28:42,840
like I said deadlocks are a when you

681
00:28:42,840 --> 00:28:47,160
have a dependency cycle between between

682
00:28:47,160 --> 00:28:48,420
transactions with where they're holding

683
00:28:48,420 --> 00:28:51,450
locks and and we have a couple ways of

684
00:28:51,450 --> 00:28:52,920
dealing with them detection and

685
00:28:52,920 --> 00:28:59,460
prevention here so with deadlock

686
00:28:59,460 --> 00:29:01,260
detection with the systems gonna do with

687
00:29:01,260 --> 00:29:02,520
like a background thread is you're

688
00:29:02,520 --> 00:29:03,960
basically gonna look at the lock

689
00:29:03,960 --> 00:29:06,180
managers metadata and you're gonna build

690
00:29:06,180 --> 00:29:09,480
a waits for graph so ideas every node is

691
00:29:09,480 --> 00:29:11,580
it is a transaction and every edge is a

692
00:29:11,580 --> 00:29:14,340
is pointing to another node that that

693
00:29:14,340 --> 00:29:18,380
holds a lock that that transaction wants

694
00:29:18,380 --> 00:29:20,160
this is all going to be done in the

695
00:29:20,160 --> 00:29:22,440
background you can balance out how

696
00:29:22,440 --> 00:29:23,790
frequently this gets done we'll talk

697
00:29:23,790 --> 00:29:25,860
about that in a minute but the idea is

698
00:29:25,860 --> 00:29:28,860
it's a background task that inspects the

699
00:29:28,860 --> 00:29:30,300
state of the lock manager and says hey

700
00:29:30,300 --> 00:29:33,570
are there any deadlocks use your

701
00:29:33,570 --> 00:29:36,470
favorite cycle detection algorithm and

702
00:29:36,470 --> 00:29:38,550
you have to decide what you're then

703
00:29:38,550 --> 00:29:42,720
gonna do with that deadlock so let's

704
00:29:42,720 --> 00:29:44,310
look at a simple example of what these

705
00:29:44,310 --> 00:29:47,870
with these waits for graphs look like

706
00:29:48,470 --> 00:29:54,900
we'll start with T one wants a shared

707
00:29:54,900 --> 00:29:57,180
lock that T two already holds on holds

708
00:29:57,180 --> 00:29:59,940
an exclusive lock for so T one gets an

709
00:29:59,940 --> 00:30:03,930
edge pointing to T 2 T 2 is going to end

710
00:30:03,930 --> 00:30:05,400
up with an edge pointing to t 3 because

711
00:30:05,400 --> 00:30:07,260
as you can see here it wants an

712
00:30:07,260 --> 00:30:09,000
exclusive lock that T 3 already holds a

713
00:30:09,000 --> 00:30:11,430
shared lock on those are incompatible so

714
00:30:11,430 --> 00:30:13,770
we're just stuck waiting and then lastly

715
00:30:13,770 --> 00:30:14,850
T 3 is gonna end up with an edge

716
00:30:14,850 --> 00:30:16,500
pointing to T 1 because it wants an

717
00:30:16,500 --> 00:30:18,240
exclusive lock that T 1 has a shared

718
00:30:18,240 --> 00:30:20,730
lock on we have

719
00:30:20,730 --> 00:30:24,180
a deadlock so we have to do something

720
00:30:24,180 --> 00:30:32,810
about this questions what's that

721
00:30:34,850 --> 00:30:40,860
so deadlock handling is kind of simple

722
00:30:40,860 --> 00:30:44,790
pick a victim kill it you choose a

723
00:30:44,790 --> 00:30:47,520
transaction and you roll it back how far

724
00:30:47,520 --> 00:30:49,860
you roll that back is a kind of

725
00:30:49,860 --> 00:30:51,510
implementation to find it's possible you

726
00:30:51,510 --> 00:30:53,430
don't and I think this is this is a

727
00:30:53,430 --> 00:30:56,820
later slide but you may not have to to

728
00:30:56,820 --> 00:30:58,200
abort the entire transaction may not

729
00:30:58,200 --> 00:30:59,490
have to undo all the queries that it did

730
00:30:59,490 --> 00:31:00,900
you maybe only you may only need to

731
00:31:00,900 --> 00:31:02,340
partially rollback some of the queries

732
00:31:02,340 --> 00:31:04,110
to release the locks that you need to

733
00:31:04,110 --> 00:31:06,780
relate to to remove the deadlock and

734
00:31:06,780 --> 00:31:11,610
make forward progress in the system the

735
00:31:11,610 --> 00:31:13,710
the last point here is basically saying

736
00:31:13,710 --> 00:31:15,540
that you have a trade-off in the system

737
00:31:15,540 --> 00:31:17,000
with how frequently you're gonna build

738
00:31:17,000 --> 00:31:19,650
these weights for graphs if you're if

739
00:31:19,650 --> 00:31:21,540
the way you're dealing with deadlocks

740
00:31:21,540 --> 00:31:24,150
is detection you have this background

741
00:31:24,150 --> 00:31:25,920
task it's building these graphs checking

742
00:31:25,920 --> 00:31:28,560
for deadlocks it's up to you how

743
00:31:28,560 --> 00:31:30,150
frequently you want that task done you

744
00:31:30,150 --> 00:31:31,650
could do it every microsecond if you

745
00:31:31,650 --> 00:31:33,870
want but you're gonna burn a bunch of

746
00:31:33,870 --> 00:31:36,000
CPU cycles constantly building these

747
00:31:36,000 --> 00:31:37,800
graphs and potentially not finding any

748
00:31:37,800 --> 00:31:40,050
any deadlocks so what you may want to

749
00:31:40,050 --> 00:31:42,450
reason about is okay maybe I want to

750
00:31:42,450 --> 00:31:44,250
check for deadlocks less frequently and

751
00:31:44,250 --> 00:31:45,750
if I do enter in a deadlock state you

752
00:31:45,750 --> 00:31:49,230
know how long do I want to make those

753
00:31:49,230 --> 00:31:50,870
transactions wait what's an acceptable

754
00:31:50,870 --> 00:31:53,130
time out that I could sit in a deadlock

755
00:31:53,130 --> 00:31:56,730
state without detecting it right away

756
00:31:56,730 --> 00:31:58,200
so these are these are always going to

757
00:31:58,200 --> 00:31:59,550
be tunable parameters in your database

758
00:31:59,550 --> 00:32:01,740
system because different workloads are

759
00:32:01,740 --> 00:32:03,780
gonna manifest different deadlock

760
00:32:03,780 --> 00:32:05,610
behaviors so we want to make sure we're

761
00:32:05,610 --> 00:32:08,160
not being too aggressive it may be fine

762
00:32:08,160 --> 00:32:09,450
just to leave the system in a deadlock

763
00:32:09,450 --> 00:32:12,300
state for for ten seconds even but it

764
00:32:12,300 --> 00:32:14,100
depends on on what the responsiveness of

765
00:32:14,100 --> 00:32:17,030
the system needs to be

766
00:32:21,020 --> 00:32:26,250
so victim selection there's a lot of

767
00:32:26,250 --> 00:32:27,330
different things you can look at here

768
00:32:27,330 --> 00:32:30,090
and and certain systems get get very

769
00:32:30,090 --> 00:32:31,620
elaborate with with what they do but

770
00:32:31,620 --> 00:32:32,220
there's all sorts of different

771
00:32:32,220 --> 00:32:34,860
heuristics you can look at the first is

772
00:32:34,860 --> 00:32:35,850
look at look at the age of the

773
00:32:35,850 --> 00:32:37,860
transaction when you're trying to find a

774
00:32:37,860 --> 00:32:39,390
victim that you're going to kill because

775
00:32:39,390 --> 00:32:40,260
at the end of the day you have this

776
00:32:40,260 --> 00:32:43,409
cycle you got to pick one you can start

777
00:32:43,409 --> 00:32:45,750
with the timestamp you can look about

778
00:32:45,750 --> 00:32:47,280
how much work it's done how many how

779
00:32:47,280 --> 00:32:48,919
many queries has it executed how big

780
00:32:48,919 --> 00:32:53,190
progress is a you don't know how close

781
00:32:53,190 --> 00:32:54,600
it is being done but you can least

782
00:32:54,600 --> 00:32:58,380
reason about how much work it's done how

783
00:32:58,380 --> 00:33:05,220
many locks it already holds that's it's

784
00:33:05,220 --> 00:33:06,750
possible that you would have to look at

785
00:33:06,750 --> 00:33:07,980
the number of transactions you have to

786
00:33:07,980 --> 00:33:09,480
roll back that would be in the case of

787
00:33:09,480 --> 00:33:11,700
if you have cascading abort

788
00:33:11,700 --> 00:33:15,179
I don't think I mentioned before you

789
00:33:15,179 --> 00:33:16,679
don't have to do strong strict two-phase

790
00:33:16,679 --> 00:33:17,100
locking

791
00:33:17,100 --> 00:33:19,230
some systems may just do two-phase

792
00:33:19,230 --> 00:33:22,590
locking and live with the possibility of

793
00:33:22,590 --> 00:33:24,090
a cascading abort again it's gonna be

794
00:33:24,090 --> 00:33:30,120
workload dependant you can decide if the

795
00:33:30,120 --> 00:33:32,690
workload is not very susceptible to

796
00:33:32,690 --> 00:33:35,850
cascading aborts or dirty reads you can

797
00:33:35,850 --> 00:33:37,380
just say two-phase locking is fine I can

798
00:33:37,380 --> 00:33:38,970
release my lock sooner that may result

799
00:33:38,970 --> 00:33:40,860
in higher throughput in the system again

800
00:33:40,860 --> 00:33:41,970
that's often gonna be something that

801
00:33:41,970 --> 00:33:55,919
that's configurable yeah so we'll talk

802
00:33:55,919 --> 00:33:59,880
about a couple different ways to decide

803
00:33:59,880 --> 00:34:01,559
a little bit later on about about which

804
00:34:01,559 --> 00:34:03,570
transaction gets killed there there are

805
00:34:03,570 --> 00:34:07,669
a couple different solutions but but but

806
00:34:07,669 --> 00:34:14,849
the other one is is the yeah this is

807
00:34:14,849 --> 00:34:16,080
typically going to be a combination of

808
00:34:16,080 --> 00:34:17,460
things it's not necessarily always going

809
00:34:17,460 --> 00:34:18,960
to be just the age of the transaction is

810
00:34:18,960 --> 00:34:20,040
going to be what determines whether you

811
00:34:20,040 --> 00:34:21,989
get killed or not often one of the one

812
00:34:21,989 --> 00:34:23,369
of the biggest things is going to be the

813
00:34:23,369 --> 00:34:24,629
number of times you've already been

814
00:34:24,629 --> 00:34:27,599
killed which is yeah then the last one

815
00:34:27,599 --> 00:34:29,250
says there because you do want to make

816
00:34:29,250 --> 00:34:30,540
sure you make progress in the system you

817
00:34:30,540 --> 00:34:31,859
need to prevent starvation for these

818
00:34:31,859 --> 00:34:33,330
transactions

819
00:34:33,330 --> 00:34:36,389
and I'm not saying like any one of these

820
00:34:36,389 --> 00:34:38,010
is exactly what you're going to use to

821
00:34:38,010 --> 00:34:40,500
kill a transaction the the commercial

822
00:34:40,500 --> 00:34:42,869
systems get rather elaborate and can

823
00:34:42,869 --> 00:34:45,089
build predictive models even to try to

824
00:34:45,089 --> 00:34:47,040
figure out like which transaction they

825
00:34:47,040 --> 00:34:48,300
should try to kill and answer a deadlock

826
00:34:48,300 --> 00:34:50,369
scenario based on all these different

827
00:34:50,369 --> 00:34:53,879
heuristics so it's typically a

828
00:34:53,879 --> 00:34:55,409
combination it's not it's not just the

829
00:34:55,409 --> 00:34:56,760
timestamp I guess is a long way of

830
00:34:56,760 --> 00:35:22,830
answering hopefully your question okay

831
00:35:22,830 --> 00:35:25,470
so your question is why would you sorry

832
00:35:25,470 --> 00:35:26,580
I want to make sure I repeat back for

833
00:35:26,580 --> 00:35:27,990
the video your question is why would you

834
00:35:27,990 --> 00:35:29,730
always want to kill in what scenarios

835
00:35:29,730 --> 00:35:30,930
would you want to kill the transaction

836
00:35:30,930 --> 00:35:39,240
with the lowest timestamp always yeah I

837
00:35:39,240 --> 00:35:41,580
suspect it's it's still always going to

838
00:35:41,580 --> 00:35:47,339
depend on the workload depending on

839
00:35:47,339 --> 00:35:49,280
what's causing the deadlock what sort of

840
00:35:49,280 --> 00:35:53,820
a situation is causing it but yeah we'll

841
00:35:53,820 --> 00:35:55,950
formalize a little bit like in a few

842
00:35:55,950 --> 00:35:58,500
slides on what gets killed and and why

843
00:35:58,500 --> 00:36:04,530
but I think in the case of Postgres in

844
00:36:04,530 --> 00:36:06,210
the example we'll see the highest time

845
00:36:06,210 --> 00:36:08,880
stamp gets killed I think I think it's

846
00:36:08,880 --> 00:36:09,900
just it's just an example I'm just

847
00:36:09,900 --> 00:36:12,750
saying like one you're a stick you could

848
00:36:12,750 --> 00:36:15,020
look at

849
00:36:18,330 --> 00:36:20,190
like I mentioned before it's possible

850
00:36:20,190 --> 00:36:21,690
you don't need to abort the entire

851
00:36:21,690 --> 00:36:23,580
transaction you could completely abort

852
00:36:23,580 --> 00:36:25,230
it or you could do some sort of minimal

853
00:36:25,230 --> 00:36:27,540
abort where you only rollback the number

854
00:36:27,540 --> 00:36:29,130
of queries in that transaction that will

855
00:36:29,130 --> 00:36:30,480
allow you to release the deadlock and

856
00:36:30,480 --> 00:36:32,390
make forward progress in the system

857
00:36:32,390 --> 00:36:34,320
again this is something that's going to

858
00:36:34,320 --> 00:36:35,640
depend on the workload how much work

859
00:36:35,640 --> 00:36:39,120
you're throwing away and whether it just

860
00:36:39,120 --> 00:36:40,920
makes sense to have transactions

861
00:36:40,920 --> 00:36:44,330
resubmit all their queries or if you can

862
00:36:44,330 --> 00:36:47,660
slowly unwind parts of it in order to to

863
00:36:47,660 --> 00:36:49,710
free the system up in the deadlock and

864
00:36:49,710 --> 00:36:56,760
make forward progress let's see if we

865
00:36:56,760 --> 00:37:16,770
can get a demo working pardon my typing

866
00:37:16,770 --> 00:37:33,660
on this surface keyboard cool looks like

867
00:37:33,660 --> 00:37:37,740
it's working so we'll start with my

868
00:37:37,740 --> 00:37:43,260
sequel we'll have two terminals open we

869
00:37:43,260 --> 00:37:46,980
have a pretty basic table set up called

870
00:37:46,980 --> 00:37:49,800
transaction demo that's horrible you

871
00:37:49,800 --> 00:37:51,090
can't see what's happening there but

872
00:37:51,090 --> 00:37:53,240
basically we have two tuples in it

873
00:37:53,240 --> 00:37:55,740
primary key ID one and two and the

874
00:37:55,740 --> 00:37:59,550
values 100 and 200 pretty simple we have

875
00:37:59,550 --> 00:38:01,320
two tuples this should be really easy to

876
00:38:01,320 --> 00:38:05,760
put to put us into a deadlock State so I

877
00:38:05,760 --> 00:38:13,470
have no idea which ones those are if you

878
00:38:13,470 --> 00:38:15,860
press all the buttons

879
00:38:15,860 --> 00:38:18,120
I'm glad I was standing next to you we

880
00:38:18,120 --> 00:38:30,170
got that on tape producer Juan everyone

881
00:38:34,790 --> 00:38:37,440
so we've got these these two tuples in

882
00:38:37,440 --> 00:38:39,720
our table transaction demo first thing

883
00:38:39,720 --> 00:38:45,860
we're gonna do is set our time out here

884
00:38:47,210 --> 00:38:49,230
so like I was saying before you can

885
00:38:49,230 --> 00:38:51,030
adjust things like like how frequently

886
00:38:51,030 --> 00:38:52,650
you're gonna detect for deadlocks so in

887
00:38:52,650 --> 00:38:56,610
this case we're gonna try to change the

888
00:38:56,610 --> 00:39:00,060
the lock wait time out here you know DB

889
00:39:00,060 --> 00:39:03,710
is the storage engine for my sequel as

890
00:39:03,710 --> 00:39:06,960
of I don't know my sequel five I think

891
00:39:06,960 --> 00:39:07,890
or something like that

892
00:39:07,890 --> 00:39:10,410
so the first terminal will begin a

893
00:39:10,410 --> 00:39:13,170
transaction the first thing we're gonna

894
00:39:13,170 --> 00:39:17,520
do is try to update the value of tuple

895
00:39:17,520 --> 00:39:23,660
one oh actually I missed a step

896
00:39:23,660 --> 00:39:27,750
we need to explicitly tell my sequel we

897
00:39:27,750 --> 00:39:28,920
want to run in the serializable

898
00:39:28,920 --> 00:39:30,270
isolation level so that's going to give

899
00:39:30,270 --> 00:39:33,060
us conflict serializable schedules we

900
00:39:33,060 --> 00:39:34,260
haven't talked about isolation levels

901
00:39:34,260 --> 00:39:35,310
yet like I said I think that's going to

902
00:39:35,310 --> 00:39:38,790
be in the next lecture but we need to we

903
00:39:38,790 --> 00:39:41,490
need to tell the system we want

904
00:39:41,490 --> 00:39:50,360
serializable isolation level go back

905
00:39:50,360 --> 00:39:54,450
begin our transaction and we're gonna

906
00:39:54,450 --> 00:39:59,430
like I said update the value on tuple

907
00:39:59,430 --> 00:40:04,350
one switch to our other terminal we're

908
00:40:04,350 --> 00:40:05,880
going to start a transaction we're going

909
00:40:05,880 --> 00:40:09,080
to update the value on tuple two

910
00:40:15,050 --> 00:40:17,990
so so far no conflicts yet t1 holds a

911
00:40:17,990 --> 00:40:21,080
walk-on tuple 1 t2 holds a lock on tuple

912
00:40:21,080 --> 00:40:23,030
two we're gonna go back to two

913
00:40:23,030 --> 00:40:24,890
transaction 1 here and we're gonna say

914
00:40:24,890 --> 00:40:28,040
okay I want to update the value on where

915
00:40:28,040 --> 00:40:30,620
IDs 2 and it just waits all I can do is

916
00:40:30,620 --> 00:40:34,400
stall it's waiting for the lock and then

917
00:40:34,400 --> 00:40:36,680
we can go back to t2 and say I want

918
00:40:36,680 --> 00:40:38,450
update the value on one t1 holds that

919
00:40:38,450 --> 00:40:40,250
walk already we should get a deadlock

920
00:40:40,250 --> 00:40:43,610
and sure enough we get a deadlock my

921
00:40:43,610 --> 00:40:46,750
sequel yelled at us rather quickly

922
00:40:46,810 --> 00:40:50,110
not a ton of debugging information but

923
00:40:50,110 --> 00:40:51,830
deadlock sound while trying to get the

924
00:40:51,830 --> 00:40:53,570
lock try restarting the application and

925
00:40:53,570 --> 00:40:57,890
you'll notice that t1 which was waiting

926
00:40:57,890 --> 00:41:01,730
for the lock on on value 2 as soon as it

927
00:41:01,730 --> 00:41:04,280
does the system detected a deadlock with

928
00:41:04,280 --> 00:41:07,400
t2 it killed that transaction t1 got the

929
00:41:07,400 --> 00:41:11,050
lock and made the progress that it need

930
00:41:20,590 --> 00:41:22,520
what do you mean why there was no I

931
00:41:22,520 --> 00:41:29,930
there was no isolation we can check so

932
00:41:29,930 --> 00:41:31,610
I'm just gonna kill but I'm gonna roll

933
00:41:31,610 --> 00:41:38,530
both of these back and we'll begin and

934
00:41:38,530 --> 00:41:40,330
[Music]

935
00:41:40,330 --> 00:41:44,350
we're gonna update the value in ID 1

936
00:41:44,350 --> 00:41:48,580
we'll go down to t2 begin a transaction

937
00:41:48,580 --> 00:41:53,180
update the value or ID is 2 and then

938
00:41:53,180 --> 00:41:57,130
we're gonna just do a select star from

939
00:41:57,130 --> 00:42:02,360
transaction demo in t1 ah so it can't

940
00:42:02,360 --> 00:42:06,820
get the latch or excuse me the lock and

941
00:42:06,820 --> 00:42:09,440
it's just gonna it's just gonna hang

942
00:42:09,440 --> 00:42:11,620
there

943
00:42:13,860 --> 00:42:18,340
if we do a rollback we see that the

944
00:42:18,340 --> 00:42:20,620
value t2 was never written to the table

945
00:42:20,620 --> 00:42:23,530
because it didn't commit and t1 was able

946
00:42:23,530 --> 00:42:24,670
to make its forward progress by getting

947
00:42:24,670 --> 00:42:33,990
the shared lock cool good question yeah

948
00:42:33,990 --> 00:42:38,470
yeah I mean in practice you're probably

949
00:42:38,470 --> 00:42:40,360
gonna see strong strict two-phase

950
00:42:40,360 --> 00:42:42,190
walking because the system can't reason

951
00:42:42,190 --> 00:42:44,770
about whether it should sort of eagerly

952
00:42:44,770 --> 00:42:46,510
start releasing laws because it doesn't

953
00:42:46,510 --> 00:42:47,980
know what what the client's gonna do

954
00:42:47,980 --> 00:42:51,160
next so you could but I don't think any

955
00:42:51,160 --> 00:42:53,140
systems do this you could speculate

956
00:42:53,140 --> 00:42:55,660
about starting to release locks early

957
00:42:55,660 --> 00:42:59,260
but you might get it wrong and we we

958
00:42:59,260 --> 00:43:02,320
can't be wrong like we have to make sure

959
00:43:02,320 --> 00:43:04,720
we guarantee these these isolation

960
00:43:04,720 --> 00:43:12,820
guarantees sure well that's that's not

961
00:43:12,820 --> 00:43:15,580
actually true so like like I said we'll

962
00:43:15,580 --> 00:43:17,410
talk about isolation levels in the next

963
00:43:17,410 --> 00:43:19,900
lecture too there are scenarios where

964
00:43:19,900 --> 00:43:21,190
you may be willing to run with with

965
00:43:21,190 --> 00:43:23,170
lower isolation guarantees and you can

966
00:43:23,170 --> 00:43:25,000
start to introduce certain anomalies

967
00:43:25,000 --> 00:43:27,790
back into the system if you are

968
00:43:27,790 --> 00:43:28,930
comfortable with them or if at the

969
00:43:28,930 --> 00:43:30,310
application layer you have your own

970
00:43:30,310 --> 00:43:31,630
logic to reason about that sort of stuff

971
00:43:31,630 --> 00:43:35,740
you can lower isolation guarantees if it

972
00:43:35,740 --> 00:43:38,910
improves the performance of your system

973
00:43:45,750 --> 00:43:48,250
yeah strong so strong trick strong

974
00:43:48,250 --> 00:43:49,930
strict two-phase locking or rigorous

975
00:43:49,930 --> 00:43:51,790
two-phase locking is one we need to use

976
00:43:51,790 --> 00:43:53,110
if we want to guarantee we don't get any

977
00:43:53,110 --> 00:43:54,910
dirty reads that could result in

978
00:43:54,910 --> 00:43:58,050
cascading aborts as well

979
00:44:02,720 --> 00:44:04,460
so that's my sequel we can take a look

980
00:44:04,460 --> 00:44:12,579
at Postgres real fast and we'll do a

981
00:44:12,819 --> 00:44:16,550
similar demo Postgres there is one other

982
00:44:16,550 --> 00:44:17,839
cool thing we can do here so we're going

983
00:44:17,839 --> 00:44:19,010
to set the deadlock timeout to 10

984
00:44:19,010 --> 00:44:25,730
seconds the demo itself is is let me

985
00:44:25,730 --> 00:44:35,569
just make sure I created this table cool

986
00:44:35,569 --> 00:44:42,260
same table exists two values with

987
00:44:42,260 --> 00:44:45,369
Postgres we can actually we're going to

988
00:44:45,369 --> 00:44:48,170
begin each transaction by saying we want

989
00:44:48,170 --> 00:44:50,030
isolation level serializable as you can

990
00:44:50,030 --> 00:44:51,710
actually it's not not necessarily a

991
00:44:51,710 --> 00:44:52,970
session wide setting you can actually

992
00:44:52,970 --> 00:44:55,940
add a transaction granularity define

993
00:44:55,940 --> 00:44:57,349
which isolation level you want to run at

994
00:44:57,349 --> 00:45:00,470
and again I keep saying isolation levels

995
00:45:00,470 --> 00:45:01,940
we'll talk about that in a future

996
00:45:01,940 --> 00:45:11,060
lecture t1 is going to begin Oh already

997
00:45:11,060 --> 00:45:13,369
begin that's right we're just gonna do

998
00:45:13,369 --> 00:45:16,690
the same operation we're gonna update

999
00:45:16,690 --> 00:45:19,790
value or ID is 1 we're gonna go down

1000
00:45:19,790 --> 00:45:22,220
here do the same thing where value

1001
00:45:22,220 --> 00:45:27,020
equals 2 go back to t1 try to update 2

1002
00:45:27,020 --> 00:45:29,839
we wait looking for the lock that we

1003
00:45:29,839 --> 00:45:32,210
don't have yet and then we're gonna

1004
00:45:32,210 --> 00:45:34,130
force a deadlock by asking t2 to update

1005
00:45:34,130 --> 00:45:39,380
the value related to 1 and there was a

1006
00:45:39,380 --> 00:45:40,849
slight lag there I don't know if you saw

1007
00:45:40,849 --> 00:45:42,530
it but it compared to my sequel which

1008
00:45:42,530 --> 00:45:45,430
instantly it was like this is a deadlock

1009
00:45:45,430 --> 00:45:47,569
Postgres kind of waited a little bit

1010
00:45:47,569 --> 00:45:49,010
before it was it yelled at us and said

1011
00:45:49,010 --> 00:45:50,960
hey you have a deadlock in the system so

1012
00:45:50,960 --> 00:45:52,069
like I said these are tunable parameters

1013
00:45:52,069 --> 00:45:54,140
you can you can adjust how aggressive

1014
00:45:54,140 --> 00:45:56,240
the database systems gonna be with with

1015
00:45:56,240 --> 00:45:57,130
looking for dead logs

1016
00:45:57,130 --> 00:45:59,859
Postgres gives us a lot more information

1017
00:45:59,859 --> 00:46:02,599
it tells us exactly which process was

1018
00:46:02,599 --> 00:46:04,130
waiting for what kind of lock held by

1019
00:46:04,130 --> 00:46:06,170
another transaction which is another

1020
00:46:06,170 --> 00:46:08,770
process

1021
00:46:09,579 --> 00:46:12,410
Postgres I think this is this is a big

1022
00:46:12,410 --> 00:46:14,390
reason and he loves referring to

1023
00:46:14,390 --> 00:46:15,770
Postgres because it's basically a text

1024
00:46:15,770 --> 00:46:16,520
book in

1025
00:46:16,520 --> 00:46:18,830
the wording you get back out of the

1026
00:46:18,830 --> 00:46:22,190
system is exactly what you would see out

1027
00:46:22,190 --> 00:46:23,810
of a database textbook and kind of the

1028
00:46:23,810 --> 00:46:25,790
behavior that would help us kind of

1029
00:46:25,790 --> 00:46:30,290
understand what's going on here there's

1030
00:46:30,290 --> 00:46:34,010
one more thing we can try and getting

1031
00:46:34,010 --> 00:46:38,620
low on time but I will do one more thing

1032
00:46:38,620 --> 00:46:43,000
so I'm going to roll both of these back

1033
00:46:48,280 --> 00:46:50,600
I'm going to set the timeout to 20

1034
00:46:50,600 --> 00:46:52,010
seconds because there's one more thing

1035
00:46:52,010 --> 00:47:08,540
we want to try to see let's see if I can

1036
00:47:08,540 --> 00:47:16,190
get one more terminal cool hopefully

1037
00:47:16,190 --> 00:47:27,800
this still plays it may be tough the

1038
00:47:27,800 --> 00:47:31,820
deadlock timeout do the same thing begin

1039
00:47:31,820 --> 00:47:35,120
transaction and serializable on to the

1040
00:47:35,120 --> 00:47:39,830
terminals this is going to be slight

1041
00:47:39,830 --> 00:47:41,530
race against the deadlock detection

1042
00:47:41,530 --> 00:47:45,680
algorithm so what I try to do here is is

1043
00:47:45,680 --> 00:47:51,530
demonstrate some of the internal

1044
00:47:51,530 --> 00:47:55,510
metadata that Postgres presents to you

1045
00:47:55,990 --> 00:47:59,420
and how it's tracking these sorts of

1046
00:47:59,420 --> 00:48:07,580
things do that and did my team accession

1047
00:48:07,580 --> 00:48:10,030
just died

1048
00:48:13,220 --> 00:48:18,920
it died cool

1049
00:48:19,520 --> 00:48:23,840
this still have a connection no

1050
00:48:23,840 --> 00:48:27,480
interesting well that's that demo cool

1051
00:48:27,480 --> 00:48:30,750
we're a long time anyway but the idea is

1052
00:48:30,750 --> 00:48:31,890
if we'd been able to put the system into

1053
00:48:31,890 --> 00:48:34,109
a deadlock state I was going to query

1054
00:48:34,109 --> 00:48:35,670
the catalog and it was gonna be able to

1055
00:48:35,670 --> 00:48:38,940
show which transactions were holding

1056
00:48:38,940 --> 00:48:40,740
locks which locks they're waiting on

1057
00:48:40,740 --> 00:48:42,300
which transactions and processes those

1058
00:48:42,300 --> 00:48:43,369
belong to

1059
00:48:43,369 --> 00:48:50,609
Postgres is great let's go back to this

1060
00:48:50,609 --> 00:49:00,990
stuff so like we talked about before the

1061
00:49:00,990 --> 00:49:02,640
alternative to doing a detection

1062
00:49:02,640 --> 00:49:04,920
algorithm is to prevent yourself from

1063
00:49:04,920 --> 00:49:06,270
other going ever going into a deadlock

1064
00:49:06,270 --> 00:49:07,680
State in the first place if we can come

1065
00:49:07,680 --> 00:49:08,670
up with some sort of system that

1066
00:49:08,670 --> 00:49:11,550
prevents this from happening we don't

1067
00:49:11,550 --> 00:49:12,900
never need to build weights for graphs

1068
00:49:12,900 --> 00:49:14,550
we don't need this background task that

1069
00:49:14,550 --> 00:49:16,109
that then needs to make decisions about

1070
00:49:16,109 --> 00:49:18,900
which process we're gonna kill and or

1071
00:49:18,900 --> 00:49:23,450
which transaction we're gonna kill and I

1072
00:49:23,450 --> 00:49:26,790
suspect this is probably what my sequel

1073
00:49:26,790 --> 00:49:29,040
was doing because my sequel immediately

1074
00:49:29,040 --> 00:49:31,430
yelled at us that we had a deadlock or

1075
00:49:31,430 --> 00:49:33,510
immediately detected it didn't prevent

1076
00:49:33,510 --> 00:49:34,890
the deadlock but it immediately detected

1077
00:49:34,890 --> 00:49:37,440
it as opposed to the Postgres which kind

1078
00:49:37,440 --> 00:49:39,030
of had a bit of a lag to it with with

1079
00:49:39,030 --> 00:49:45,600
the detection so a very simple way to do

1080
00:49:45,600 --> 00:49:47,609
this is to assign priorities based on

1081
00:49:47,609 --> 00:49:49,710
timestamp so older transactions are

1082
00:49:49,710 --> 00:49:52,109
considered higher priority and then you

1083
00:49:52,109 --> 00:49:53,460
kind of have two different protocols you

1084
00:49:53,460 --> 00:49:55,890
can follow you have this wait die system

1085
00:49:55,890 --> 00:49:58,080
which basically just means old

1086
00:49:58,080 --> 00:50:00,420
transactions wait for young transactions

1087
00:50:00,420 --> 00:50:02,550
so if the requesting transaction has a

1088
00:50:02,550 --> 00:50:06,540
higher priority it's gonna for a been a

1089
00:50:06,540 --> 00:50:07,950
holding transaction so holding

1090
00:50:07,950 --> 00:50:10,710
transaction is younger than it but the

1091
00:50:10,710 --> 00:50:13,020
older transaction wants its lock then

1092
00:50:13,020 --> 00:50:14,790
the requesting transaction is just gonna

1093
00:50:14,790 --> 00:50:18,990
sit around and wait otherwise the the

1094
00:50:18,990 --> 00:50:20,190
requesting transaction is going to abort

1095
00:50:20,190 --> 00:50:22,290
the other system is called wound weight

1096
00:50:22,290 --> 00:50:23,760
you can think of it as young waits for

1097
00:50:23,760 --> 00:50:25,910
the old requesting transactions

1098
00:50:25,910 --> 00:50:28,069
they have a higher priority than the

1099
00:50:28,069 --> 00:50:30,589
holding transaction the holding

1100
00:50:30,589 --> 00:50:32,420
transaction of boards so basically the

1101
00:50:32,420 --> 00:50:34,220
requesting transaction comes in steals

1102
00:50:34,220 --> 00:50:36,099
your lock and makes forward progress

1103
00:50:36,099 --> 00:50:38,180
alternatively the requesting transaction

1104
00:50:38,180 --> 00:50:40,700
just wait so this is probably confusing

1105
00:50:40,700 --> 00:50:42,589
it's it's a little bit clearer I think

1106
00:50:42,589 --> 00:50:46,220
on an example on the next slide so we

1107
00:50:46,220 --> 00:50:48,829
have these two scenarios these two

1108
00:50:48,829 --> 00:50:50,869
schedules we want to look at we'll look

1109
00:50:50,869 --> 00:50:53,539
at the first one first t1 and t2 t1

1110
00:50:53,539 --> 00:50:55,309
begins first so t1 is gonna have the

1111
00:50:55,309 --> 00:50:58,970
higher priority than t2 the t2 gets the

1112
00:50:58,970 --> 00:51:02,930
lock first so t2 gets an exclusive lock

1113
00:51:02,930 --> 00:51:05,690
on a t1 wants the exclusive lock on a

1114
00:51:05,690 --> 00:51:08,000
it's the older transaction it has higher

1115
00:51:08,000 --> 00:51:11,000
priority so underweight die T one's

1116
00:51:11,000 --> 00:51:14,119
gonna wait for that lock and under wound

1117
00:51:14,119 --> 00:51:17,420
weight T t1 is basically going to come

1118
00:51:17,420 --> 00:51:19,630
in kill T to steal it's lunch money and

1119
00:51:19,630 --> 00:51:24,650
t2 has to restart or whatever it needs

1120
00:51:24,650 --> 00:51:26,930
to do whatever the application needs to

1121
00:51:26,930 --> 00:51:30,069
do with that applicate transaction in

1122
00:51:30,069 --> 00:51:35,539
the second schedule t1 once again begins

1123
00:51:35,539 --> 00:51:37,490
before t2 so it has an older timestamp

1124
00:51:37,490 --> 00:51:39,380
it's higher priority but it got the lock

1125
00:51:39,380 --> 00:51:43,099
first t2 wants that lock under weight

1126
00:51:43,099 --> 00:51:48,859
die t2 is gonna abort and under wound

1127
00:51:48,859 --> 00:51:52,190
weight t2 is just gonna wait so what

1128
00:51:52,190 --> 00:51:53,480
these two policies are doing is they're

1129
00:51:53,480 --> 00:51:59,529
basically defining the same sort of

1130
00:51:59,529 --> 00:52:02,480
logic that we used for latching and

1131
00:52:02,480 --> 00:52:03,650
concurrent data structures where this

1132
00:52:03,650 --> 00:52:05,359
concept of we only take latches in one

1133
00:52:05,359 --> 00:52:08,089
direction and we release them in in in a

1134
00:52:08,089 --> 00:52:09,319
discipline manner as well like if you

1135
00:52:09,319 --> 00:52:13,430
can apply some sort of ordering to how

1136
00:52:13,430 --> 00:52:14,779
you acquire your locks which is

1137
00:52:14,779 --> 00:52:17,359
effectively what this is doing you you

1138
00:52:17,359 --> 00:52:20,770
can avoid deadlocks entirely so one's

1139
00:52:20,770 --> 00:52:23,119
weight dies basically saying okay we're

1140
00:52:23,119 --> 00:52:26,299
gonna we're gonna order our timestamps

1141
00:52:26,299 --> 00:52:27,500
in one direction and how we hand out

1142
00:52:27,500 --> 00:52:29,000
locks and then in moon weight it's

1143
00:52:29,000 --> 00:52:30,890
basically just the opposite as long as

1144
00:52:30,890 --> 00:52:32,299
we're consistent you can't mix these

1145
00:52:32,299 --> 00:52:33,980
things if you start mixing them you're

1146
00:52:33,980 --> 00:52:36,020
gonna get dead locks in why you're even

1147
00:52:36,020 --> 00:52:37,039
doing this because then you would need a

1148
00:52:37,039 --> 00:52:38,940
deadlock detection algorithm and

1149
00:52:38,940 --> 00:52:49,210
you you you didn't solve any problems so

1150
00:52:49,210 --> 00:52:50,769
the question is why is this called wound

1151
00:52:50,769 --> 00:52:52,829
weight as opposed to some sort of

1152
00:52:52,829 --> 00:52:55,569
opposite of weight die I have no idea I

1153
00:52:55,569 --> 00:52:57,130
really don't like the naming of this I

1154
00:52:57,130 --> 00:53:01,329
find it very confusing yeah if you're

1155
00:53:01,329 --> 00:53:02,710
confusing but if yeah if you're confused

1156
00:53:02,710 --> 00:53:07,420
by the naming I I'm with you I think

1157
00:53:07,420 --> 00:53:10,089
that's why Andy kind of adds this just

1158
00:53:10,089 --> 00:53:12,010
sort of simplification of like old

1159
00:53:12,010 --> 00:53:13,720
weights for young or young weights for

1160
00:53:13,720 --> 00:53:16,690
old because yeah wait die wound wait

1161
00:53:16,690 --> 00:53:21,309
it's it's a weird nomenclature any other

1162
00:53:21,309 --> 00:53:28,059
questions so this was sort of what I was

1163
00:53:28,059 --> 00:53:30,880
talking about before these schemes

1164
00:53:30,880 --> 00:53:31,990
guarantee no deadlocks cuz you're

1165
00:53:31,990 --> 00:53:35,529
basically enforcing walks being handed

1166
00:53:35,529 --> 00:53:37,599
out in a single direction or locks even

1167
00:53:37,599 --> 00:53:39,400
being able to be stolen in a single

1168
00:53:39,400 --> 00:53:45,309
direction so if yeah we've talked about

1169
00:53:45,309 --> 00:53:46,930
this already so when a transaction

1170
00:53:46,930 --> 00:53:51,539
restarts what would its new priority be

1171
00:53:51,539 --> 00:53:58,440
my guess is what would its timestamp be

1172
00:54:04,170 --> 00:54:07,029
it's got to be the original any guesses

1173
00:54:07,029 --> 00:54:16,210
why if you have a transaction you start

1174
00:54:16,210 --> 00:54:17,740
and then it gets killed by another

1175
00:54:17,740 --> 00:54:19,839
transaction coming in let's say because

1176
00:54:19,839 --> 00:54:22,000
it's priority will increase the older it

1177
00:54:22,000 --> 00:54:24,190
is you want to maintain its age yeah

1178
00:54:24,190 --> 00:54:26,019
sure as opposed to just resetting of age

1179
00:54:26,019 --> 00:54:30,130
right so in that's right

1180
00:54:30,130 --> 00:54:32,950
in one word starvation we can't have we

1181
00:54:32,950 --> 00:54:34,960
can't have transactions being starved so

1182
00:54:34,960 --> 00:54:36,730
when you restart the transaction we want

1183
00:54:36,730 --> 00:54:37,599
to make sure it's still used with the

1184
00:54:37,599 --> 00:54:39,849
same timestamp so that eventually with

1185
00:54:39,849 --> 00:54:41,920
with which it which Eve which ever

1186
00:54:41,920 --> 00:54:43,779
deadlock prevention ordering we're going

1187
00:54:43,779 --> 00:54:45,339
with we want to make sure progress gets

1188
00:54:45,339 --> 00:54:48,839
made at one point another the other

1189
00:54:50,640 --> 00:54:57,100
so we have ten minutes so this is we'll

1190
00:54:57,100 --> 00:55:00,850
see how far we get like so far this

1191
00:55:00,850 --> 00:55:02,410
doesn't seem very efficient like what if

1192
00:55:02,410 --> 00:55:03,490
we have a transaction that needs to

1193
00:55:03,490 --> 00:55:06,130
update a billion tuples we're gonna lock

1194
00:55:06,130 --> 00:55:07,660
manager a billion times like going to

1195
00:55:07,660 --> 00:55:09,310
the lock manager is not cheap you're not

1196
00:55:09,310 --> 00:55:11,350
implementing one this semester but you

1197
00:55:11,350 --> 00:55:12,550
can envision if you had to implement

1198
00:55:12,550 --> 00:55:14,410
this in a system you're going to need

1199
00:55:14,410 --> 00:55:16,000
data structures that are protected by

1200
00:55:16,000 --> 00:55:19,330
latches it has to be concurrent it's on

1201
00:55:19,330 --> 00:55:20,740
the critical path of what every

1202
00:55:20,740 --> 00:55:23,860
transaction is doing we can't make all

1203
00:55:23,860 --> 00:55:27,010
these trips to the lock manager so what

1204
00:55:27,010 --> 00:55:28,810
we're going to try to do is introduce

1205
00:55:28,810 --> 00:55:30,970
some some sort of hierarchy or grant or

1206
00:55:30,970 --> 00:55:32,470
change the granularity or allow

1207
00:55:32,470 --> 00:55:33,940
different granularity of locks in the

1208
00:55:33,940 --> 00:55:39,610
system so we can apply locks - tuples

1209
00:55:39,610 --> 00:55:45,460
pages tables you if you if you knew you

1210
00:55:45,460 --> 00:55:47,110
needed to do a billion updates on a

1211
00:55:47,110 --> 00:55:49,060
single table maybe it makes sense to

1212
00:55:49,060 --> 00:55:50,860
just ask for the single exclusive lock

1213
00:55:50,860 --> 00:55:52,930
on the entire table you are going to

1214
00:55:52,930 --> 00:55:54,010
prevent other transactions from

1215
00:55:54,010 --> 00:55:56,140
accessing it but maybe that's what you

1216
00:55:56,140 --> 00:55:58,600
want to do the goal is to reduce the

1217
00:55:58,600 --> 00:56:00,430
number of total trips to the lock

1218
00:56:00,430 --> 00:56:01,720
manager possible by using this

1219
00:56:01,720 --> 00:56:04,119
hierarchical model so to do that we're

1220
00:56:04,119 --> 00:56:06,520
gonna have to introduce a few more lock

1221
00:56:06,520 --> 00:56:08,920
types and then this notion of a

1222
00:56:08,920 --> 00:56:12,910
hierarchy so conceptually like I was

1223
00:56:12,910 --> 00:56:15,760
describing you can now take locks at

1224
00:56:15,760 --> 00:56:17,950
different levels in the system so

1225
00:56:17,950 --> 00:56:19,740
database can have multiple tables

1226
00:56:19,740 --> 00:56:21,760
different tables can have multiple

1227
00:56:21,760 --> 00:56:23,200
tuples and within different tuples you

1228
00:56:23,200 --> 00:56:24,490
can have multiple attributes so you want

1229
00:56:24,490 --> 00:56:26,020
to acquire the fewest number of locks

1230
00:56:26,020 --> 00:56:27,760
possible to do the work that you need to

1231
00:56:27,760 --> 00:56:34,230
do so if T 1 takes the lock on table 1

1232
00:56:34,230 --> 00:56:37,930
it if it if it explicitly takes a lock

1233
00:56:37,930 --> 00:56:40,869
on table 1 it now implicitly locks

1234
00:56:40,869 --> 00:56:43,630
everything below it in the in this tree

1235
00:56:43,630 --> 00:56:46,840
this trees again it's a slightly

1236
00:56:46,840 --> 00:56:48,760
abstract concept concept this isn't like

1237
00:56:48,760 --> 00:56:50,320
a B+ tree or something like that it's

1238
00:56:50,320 --> 00:56:52,869
just in the hierarchy of the database

1239
00:56:52,869 --> 00:56:54,820
system of all the tables and tuples

1240
00:56:54,820 --> 00:56:57,250
you've inserted into the system it's

1241
00:56:57,250 --> 00:57:01,090
sort of a conceptual hierarchy in the

1242
00:57:01,090 --> 00:57:03,359
system

1243
00:57:04,060 --> 00:57:06,560
so Andy's trying to get the balance of

1244
00:57:06,560 --> 00:57:10,700
his shady offshore bank account and he's

1245
00:57:10,700 --> 00:57:12,530
giving me 1% interest at the same time

1246
00:57:12,530 --> 00:57:21,170
cool this is sort of demonstrating in

1247
00:57:21,170 --> 00:57:23,119
this this conceptual tree that we have

1248
00:57:23,119 --> 00:57:25,040
what sort of locks do we need to need to

1249
00:57:25,040 --> 00:57:26,450
take we need all sorts of different

1250
00:57:26,450 --> 00:57:29,090
types of locks we need exclusive locks

1251
00:57:29,090 --> 00:57:32,810
because my bank account balance is

1252
00:57:32,810 --> 00:57:35,869
changing Andy's gonna need shared locks

1253
00:57:35,869 --> 00:57:38,600
and then there's this notion of an

1254
00:57:38,600 --> 00:57:41,480
intention lock which i think is defined

1255
00:57:41,480 --> 00:57:43,640
on the next slide you basically give

1256
00:57:43,640 --> 00:57:45,530
hints in this tree you basically take

1257
00:57:45,530 --> 00:57:48,619
intention locks at higher levels to give

1258
00:57:48,619 --> 00:57:49,970
hints to other transactions about what

1259
00:57:49,970 --> 00:57:51,170
you're doing in lower levels of the

1260
00:57:51,170 --> 00:57:53,240
system that's gonna try to increase the

1261
00:57:53,240 --> 00:57:59,360
the parallelism of the system so like I

1262
00:57:59,360 --> 00:58:02,510
said an intention lock is is a is a hint

1263
00:58:02,510 --> 00:58:04,640
other transactions and and it'll get

1264
00:58:04,640 --> 00:58:06,140
clearer with it with an example but the

1265
00:58:06,140 --> 00:58:07,760
basic idea like if you have an intention

1266
00:58:07,760 --> 00:58:10,940
shared lock in this tree the subtree

1267
00:58:10,940 --> 00:58:13,130
rooted at that node there is an explicit

1268
00:58:13,130 --> 00:58:14,990
shared lock somewhere underneath that

1269
00:58:14,990 --> 00:58:17,750
same thing with with an intention

1270
00:58:17,750 --> 00:58:19,550
exclusive lock somewhere in that subtree

1271
00:58:19,550 --> 00:58:21,650
rooted at that in that node there's an

1272
00:58:21,650 --> 00:58:29,300
explicit exclusive lock we're gonna add

1273
00:58:29,300 --> 00:58:32,750
three more lock types intention shared

1274
00:58:32,750 --> 00:58:35,900
which is like I described somewhere in

1275
00:58:35,900 --> 00:58:37,580
the subtree rooted at that node there's

1276
00:58:37,580 --> 00:58:39,560
an explicit shared lock intention

1277
00:58:39,560 --> 00:58:41,630
exclusive same idea somewhere in that

1278
00:58:41,630 --> 00:58:43,460
subtree there's an explicit exclusive

1279
00:58:43,460 --> 00:58:46,220
lock and then there's one kind of tricky

1280
00:58:46,220 --> 00:58:49,100
one shared intention exclusive this is

1281
00:58:49,100 --> 00:58:52,400
an explicit shared lock on this node

1282
00:58:52,400 --> 00:58:55,280
which means that so you have shared lock

1283
00:58:55,280 --> 00:58:57,080
on everything below it in its subtree

1284
00:58:57,080 --> 00:58:59,960
and somewhere in that subtree you also

1285
00:58:59,960 --> 00:59:03,590
have an explicit exclusive lock so you

1286
00:59:03,590 --> 00:59:05,600
can imagine if you wanted to do a read

1287
00:59:05,600 --> 00:59:08,869
on an entire table and then maybe update

1288
00:59:08,869 --> 00:59:10,430
one value you would get a shared

1289
00:59:10,430 --> 00:59:12,140
intention exclusive on that table

1290
00:59:12,140 --> 00:59:13,520
because you're gonna take a shared lock

1291
00:59:13,520 --> 00:59:15,560
on the entire table and say I'm reading

1292
00:59:15,560 --> 00:59:17,119
all the values of this tuple or of this

1293
00:59:17,119 --> 00:59:17,600
tape

1294
00:59:17,600 --> 00:59:19,520
but I'm only gonna update one value so

1295
00:59:19,520 --> 00:59:22,070
you have an exclusive lock on one tuple

1296
00:59:22,070 --> 00:59:24,350
further down it'll make more sense with

1297
00:59:24,350 --> 00:59:26,030
with an actual example I think but are

1298
00:59:26,030 --> 00:59:31,130
there any questions first example our

1299
00:59:31,130 --> 00:59:33,020
compatibility matrix gets a little bit

1300
00:59:33,020 --> 00:59:38,180
more complicated not a lot to say about

1301
00:59:38,180 --> 00:59:40,040
this other than I think the tree

1302
00:59:40,040 --> 00:59:41,510
actually seeing an example is a little

1303
00:59:41,510 --> 00:59:43,820
bit more clear but basically the

1304
00:59:43,820 --> 00:59:45,620
semantics are similar to to share an

1305
00:59:45,620 --> 00:59:51,290
exclusive walk compatibility just apply

1306
00:59:51,290 --> 00:59:56,000
do it to a tree the LOC protocol is

1307
00:59:56,000 --> 00:59:57,710
basically just saying in order to get a

1308
00:59:57,710 --> 01:00:01,220
shared lock you have to hint at least in

1309
01:00:01,220 --> 01:00:03,710
the parent node that you have an

1310
01:00:03,710 --> 01:00:06,410
intention shared lock same thing with

1311
01:00:06,410 --> 01:00:08,900
exclusive to get an exclusive intention

1312
01:00:08,900 --> 01:00:11,300
exclusive shared intention exclusive you

1313
01:00:11,300 --> 01:00:13,340
have to hold an intention exclusive on

1314
01:00:13,340 --> 01:00:16,640
the parent node again let's let's do an

1315
01:00:16,640 --> 01:00:17,600
example because I think that's going to

1316
01:00:17,600 --> 01:00:19,190
make things a little bit clearer we have

1317
01:00:19,190 --> 01:00:24,470
five minutes very simple table or a very

1318
01:00:24,470 --> 01:00:25,910
simple example two levels there's a

1319
01:00:25,910 --> 01:00:31,040
table there's a bunch of tuples we want

1320
01:00:31,040 --> 01:00:33,800
to check andis bank account he wants to

1321
01:00:33,800 --> 01:00:36,970
do a read on tuple one so he he wants

1322
01:00:36,970 --> 01:00:39,680
he's gonna want just a shared lock on

1323
01:00:39,680 --> 01:00:41,660
this one to do a read but we're gonna

1324
01:00:41,660 --> 01:00:43,940
have to take an intention shared at the

1325
01:00:43,940 --> 01:00:45,680
parent node first basically as a hint to

1326
01:00:45,680 --> 01:00:48,500
say hey below this node I'm gonna take

1327
01:00:48,500 --> 01:00:55,270
an explicit shared lock t2 comes along

1328
01:00:55,270 --> 01:00:58,430
we want to update my bank balance by one

1329
01:00:58,430 --> 01:01:03,880
percent so we want an explicit exclusive

1330
01:01:03,880 --> 01:01:08,660
lock on this tuple so we're gonna try to

1331
01:01:08,660 --> 01:01:15,920
get yeah we get our intention exclusive

1332
01:01:15,920 --> 01:01:17,960
lock on the on the parent node and we

1333
01:01:17,960 --> 01:01:20,240
get our exclusive lock on the individual

1334
01:01:20,240 --> 01:01:24,260
tuple now things will get a little bit

1335
01:01:24,260 --> 01:01:25,820
more interesting I think t1 is basically

1336
01:01:25,820 --> 01:01:27,950
doing the scenario I described before

1337
01:01:27,950 --> 01:01:29,000
where you're going to do a bunch of

1338
01:01:29,000 --> 01:01:29,840
reads and then you're going to update

1339
01:01:29,840 --> 01:01:31,400
one tuple

1340
01:01:31,400 --> 01:01:32,960
t-too is gonna read a single tuple t3 is

1341
01:01:32,960 --> 01:01:35,779
going to scan all of them I apologize

1342
01:01:35,779 --> 01:01:37,700
for going a little fast I realize this

1343
01:01:37,700 --> 01:01:41,119
is probably a little confusing but we're

1344
01:01:41,119 --> 01:01:46,520
getting a long time so t1 like I said it

1345
01:01:46,520 --> 01:01:47,869
wants to read all the tuples and do an

1346
01:01:47,869 --> 01:01:49,819
update on one so it's gonna get a shared

1347
01:01:49,819 --> 01:01:52,130
intention exclusive this means I'm

1348
01:01:52,130 --> 01:01:54,859
taking a shared lock on the entire table

1349
01:01:54,859 --> 01:01:57,500
so I can read all the attributes they're

1350
01:01:57,500 --> 01:01:59,599
in all the tuples in this table and the

1351
01:01:59,599 --> 01:02:01,940
intention exclusive part means I'm gonna

1352
01:02:01,940 --> 01:02:04,099
update at least one of these tuples down

1353
01:02:04,099 --> 01:02:09,920
there in this case it's tuple n so

1354
01:02:09,920 --> 01:02:11,809
because this is shared intention

1355
01:02:11,809 --> 01:02:13,549
exclusive all these tuples are

1356
01:02:13,549 --> 01:02:15,799
implicitly locked in shared mode and

1357
01:02:15,799 --> 01:02:17,539
then this is the only one we actually

1358
01:02:17,539 --> 01:02:19,279
have to take an explicit exclusive lock

1359
01:02:19,279 --> 01:02:20,450
on because that's the only one being

1360
01:02:20,450 --> 01:02:24,200
updated t2 wants to read a single tuple

1361
01:02:24,200 --> 01:02:26,990
we're gonna need the shared shared lock

1362
01:02:26,990 --> 01:02:28,220
on this guy which means we need

1363
01:02:28,220 --> 01:02:34,339
intention shared at this level that's

1364
01:02:34,339 --> 01:02:36,770
all good we can do that the last

1365
01:02:36,770 --> 01:02:38,119
transaction is the one that's gonna have

1366
01:02:38,119 --> 01:02:41,480
problems it wants to do a read on all of

1367
01:02:41,480 --> 01:02:45,380
them it's gonna want to shared exclusive

1368
01:02:45,380 --> 01:02:47,750
shared law excuse me explicit shared

1369
01:02:47,750 --> 01:02:49,180
lock on the table

1370
01:02:49,180 --> 01:02:51,109
can't get that because it's not going to

1371
01:02:51,109 --> 01:02:53,420
be compatible with the shared intention

1372
01:02:53,420 --> 01:02:54,829
exclusive because there's a write

1373
01:02:54,829 --> 01:02:58,670
happening lower on lower in the table t3

1374
01:02:58,670 --> 01:03:01,750
has to wait so basically it wants this

1375
01:03:01,750 --> 01:03:05,029
explicit shared lock on the table can't

1376
01:03:05,029 --> 01:03:05,510
have that

1377
01:03:05,510 --> 01:03:29,569
all can do is wait so I may have gone

1378
01:03:29,569 --> 01:03:32,180
too quickly the the example operations

1379
01:03:32,180 --> 01:03:33,650
changed when I got to this one with

1380
01:03:33,650 --> 01:03:35,119
three transactions this is no longer

1381
01:03:35,119 --> 01:03:37,460
doing like the read Andy's Bakic out

1382
01:03:37,460 --> 01:03:39,890
bump my account balance by 1% tyonne's

1383
01:03:39,890 --> 01:03:42,079
reading all of the tuples and then

1384
01:03:42,079 --> 01:03:44,600
modifying one t2

1385
01:03:44,600 --> 01:03:47,180
was just doing a read on a single one

1386
01:03:47,180 --> 01:03:49,460
and then t3 is the one that's trying to

1387
01:03:49,460 --> 01:03:51,650
read the entire table so yeah it's a

1388
01:03:51,650 --> 01:03:53,000
different example I'm sorry about that

1389
01:03:53,000 --> 01:04:07,540
if I went kind of quickly so in practice

1390
01:04:07,540 --> 01:04:09,500
it seemed complicated but it's actually

1391
01:04:09,500 --> 01:04:10,760
pretty helpful because you can reduce

1392
01:04:10,760 --> 01:04:12,200
the number of locks that go or the

1393
01:04:12,200 --> 01:04:13,580
number of trips to the lock manager you

1394
01:04:13,580 --> 01:04:15,260
you reduce the number of lock requests

1395
01:04:15,260 --> 01:04:19,910
dramatically and like we mentioned

1396
01:04:19,910 --> 01:04:21,770
before there's this concept of lock

1397
01:04:21,770 --> 01:04:23,840
escalation so if you already have locks

1398
01:04:23,840 --> 01:04:25,340
and shared mode you want to bump them to

1399
01:04:25,340 --> 01:04:26,510
exclusive locks because you've decided

1400
01:04:26,510 --> 01:04:28,010
you want to do it right on the tuple you

1401
01:04:28,010 --> 01:04:30,410
can do that once again this is this is

1402
01:04:30,410 --> 01:04:31,940
designed to reduce the number of trips

1403
01:04:31,940 --> 01:04:33,410
the lock manager and also doesn't

1404
01:04:33,410 --> 01:04:34,640
violate two-phase locking because you

1405
01:04:34,640 --> 01:04:35,780
can upgrade your locks you don't

1406
01:04:35,780 --> 01:04:42,170
actually release the lock so in practice

1407
01:04:42,170 --> 01:04:44,180
in real systems you you're not sitting

1408
01:04:44,180 --> 01:04:46,330
there telling it which tuples to lock

1409
01:04:46,330 --> 01:04:48,800
you can give hints like I said if you

1410
01:04:48,800 --> 01:04:50,020
know you're gonna do a bunch of

1411
01:04:50,020 --> 01:04:53,780
operations on a on a table and you you

1412
01:04:53,780 --> 01:04:55,130
want to hold the lock the entire time

1413
01:04:55,130 --> 01:04:56,870
you you can't explicitly lock the table

1414
01:04:56,870 --> 01:04:59,540
so it's not part of the sequel standard

1415
01:04:59,540 --> 01:05:01,250
but here's examples on how to do it in

1416
01:05:01,250 --> 01:05:03,440
like Postgres Oracle db2 sequel my

1417
01:05:03,440 --> 01:05:08,180
sequel these guys all use the

1418
01:05:08,180 --> 01:05:09,620
nomenclature that we're learning about

1419
01:05:09,620 --> 01:05:11,300
now which is shared and exclusive and

1420
01:05:11,300 --> 01:05:12,710
because my sequel loves to be different

1421
01:05:12,710 --> 01:05:14,540
they call them read and write blocks

1422
01:05:14,540 --> 01:05:17,890
because they want to be different

1423
01:05:17,890 --> 01:05:20,210
there's also this notion of select for

1424
01:05:20,210 --> 01:05:21,440
updates so if you're doing a read on a

1425
01:05:21,440 --> 01:05:22,700
tuple that you eventually want to update

1426
01:05:22,700 --> 01:05:24,020
you can give a hint to the database

1427
01:05:24,020 --> 01:05:25,700
system that says look I know because

1428
01:05:25,700 --> 01:05:27,140
you're doing a read you're gonna request

1429
01:05:27,140 --> 01:05:29,870
a shared lock I'm gonna do a write later

1430
01:05:29,870 --> 01:05:32,720
on just take the exclusive lock now and

1431
01:05:32,720 --> 01:05:34,760
hold it for me so you can you can do

1432
01:05:34,760 --> 01:05:38,840
select and add this for update that

1433
01:05:38,840 --> 01:05:41,630
basically tells the system take the take

1434
01:05:41,630 --> 01:05:43,250
the right lock or excuse me take the

1435
01:05:43,250 --> 01:05:46,100
exclusive lock right now and you can

1436
01:05:46,100 --> 01:05:47,990
also tell it just to take a shared lock

1437
01:05:47,990 --> 01:05:49,400
I don't know why you would ever do that

1438
01:05:49,400 --> 01:05:50,870
because by default it probably should

1439
01:05:50,870 --> 01:05:52,220
just take a shared lock if you're doing

1440
01:05:52,220 --> 01:05:54,490
a read

1441
01:05:55,890 --> 01:05:59,800
to finish things up like the slide says

1442
01:05:59,800 --> 01:06:02,290
it's used in almost every system out

1443
01:06:02,290 --> 01:06:04,120
there at least most convert most most

1444
01:06:04,120 --> 01:06:05,590
widely deployed to commercial systems

1445
01:06:05,590 --> 01:06:08,950
sequel server my sequel Postgres to

1446
01:06:08,950 --> 01:06:11,740
phase locking is is big deal but it's

1447
01:06:11,740 --> 01:06:14,230
also not too difficult to implement and

1448
01:06:14,230 --> 01:06:15,460
it gives us exactly what we want gives

1449
01:06:15,460 --> 01:06:18,460
us our serializable schedules we just

1450
01:06:18,460 --> 01:06:20,650
have to be disciplined about whether

1451
01:06:20,650 --> 01:06:22,120
we're gonna try to detect our deadlocks

1452
01:06:22,120 --> 01:06:23,500
and handle them or we're gonna try to

1453
01:06:23,500 --> 01:06:27,120
prevent them entirely in the first place

1454
01:06:27,120 --> 01:06:29,860
next class I think it's going to be Dana

1455
01:06:29,860 --> 01:06:31,570
talking to you guys about time stamp

1456
01:06:31,570 --> 01:06:35,730
ordering which is good

1457
01:06:46,079 --> 01:06:48,479
he's wixi nights in my system cracking

1458
01:06:48,479 --> 01:06:49,349
up I'm blessed

1459
01:06:49,349 --> 01:06:50,880
let's go get the next one then get over

1460
01:06:50,880 --> 01:06:57,450
the sofa dressed now good never be son

1461
01:06:57,450 --> 01:06:59,609
ricochet jelly hit the deli for a boat

1462
01:06:59,609 --> 01:07:01,710
one naturally bless ya what rappers like

1463
01:07:01,710 --> 01:07:03,479
the laser beam the balls in the bush

1464
01:07:03,479 --> 01:07:06,210
Sena ka-ching wrap the bottle of us a

1465
01:07:06,210 --> 01:07:08,190
nice sympathy go don't feel like

1466
01:07:08,190 --> 01:07:10,170
drinking a pony - you drunk you can't

1467
01:07:10,170 --> 01:07:12,779
drop you at the stake don't know you

1468
01:07:12,779 --> 01:07:16,009
forget a pancake

