1
00:00:03,640 --> 00:00:13,140
[音乐]

2
00:00:14,410 --> 00:00:18,859
好的，让我们今天开始讨论很多

3
00:00:18,859 --> 00:00:19,340
事情

4
00:00:19,340 --> 00:00:21,910
，再次感谢 DJ 降级表

5
00:00:21,910 --> 00:00:25,249
今天让我们出去，所以你

6
00:00:25,249 --> 00:00:27,410
下课后立即飞出去

7
00:00:27,410 --> 00:00:28,310
你要去哪里，

8
00:00:28,310 --> 00:00:31,540
我的孩子黛比史蒂夫有一个对冲基金，

9
00:00:31,540 --> 00:00:38,060
你的孩子有一个对冲基金 对冲派对 是的 Jenny

10
00:00:38,060 --> 00:00:41,170
Block King

11
00:00:44,660 --> 00:00:49,090
是的，这不是粗略

12
00:00:49,090 --> 00:00:51,620


13
00:00:51,620 --> 00:00:51,789


14
00:00:51,789 --> 00:00:54,980


15
00:00:54,980 --> 00:00:59,500


16
00:00:59,500 --> 00:01:02,600


17
00:01:02,600 --> 00:01:03,350


18
00:01:03,350 --> 00:01:07,190
的 在本次讲座结束时，

19
00:01:07,190 --> 00:01:09,230
我们将回顾一下你

20
00:01:09,230 --> 00:01:11,090
知道大纲对你的期中期望是什么

21
00:01:11,090 --> 00:01:13,250
，然后项目二将

22
00:01:13,250 --> 00:01:16,210
在 10 月 20 日星期日的期中到期

23
00:01:16,210 --> 00:01:18,020
无论如何，关于这些事情的任何问题都没有问题，

24
00:01:18,020 --> 00:01:22,090


25
00:01:22,090 --> 00:01:25,640
所以让我们跳起来 所以最后一节课

26
00:01:25,640 --> 00:01:27,530
我们开始讨论查询执行

27
00:01:27,530 --> 00:01:30,079
，我们说我们将

28
00:01:30,079 --> 00:01:32,930
在查询计划中使用这些运算符

29
00:01:32,930 --> 00:01:35,090
，然后我们展示了不同的方法

30
00:01:35,090 --> 00:01:36,799
来将数据从顶部移动

31
00:01:36,799 --> 00:01:38,840
到底部 从下到上，然后我们

32
00:01:38,840 --> 00:01:40,280
还展示了有时你可以

33
00:01:40,280 --> 00:01:41,840
发送一个元组，你可以发送

34
00:01:41,840 --> 00:01:44,509
一批可爱的狼或一个歌剧的所有元组

35
00:01:44,509 --> 00:01:47,149
到下一个，所以在这个

36
00:01:47,149 --> 00:01:49,579
讨论中我们做了这个大

37
00:01:49,579 --> 00:01:52,329
假设，或者我没有 甚至不谈论

38
00:01:52,329 --> 00:01:54,799
你知道这些操作符是如何

39
00:01:54,799 --> 00:01:56,630
执行的 我们只是将它设置在一个

40
00:01:56,630 --> 00:01:57,920
较高的级别 有这些函数

41
00:01:57,920 --> 00:01:59,030
彼此相邻调用并且它们传递

42
00:01:59,030 --> 00:02:02,090
数据 所以现在我们

43
00:02:02,090 --> 00:02:05,060
今天要讨论的是 数据系统

44
00:02:05,060 --> 00:02:06,140
实际上会

45
00:02:06,140 --> 00:02:08,360
正确地执行这些事情，这些是什么你知道我们

46
00:02:08,360 --> 00:02:09,830
会有这些工人 他们可以使用

47
00:02:09,830 --> 00:02:12,140
这些操作符并执行它们并

48
00:02:12,140 --> 00:02:15,980
产生一些结果 所以

49
00:02:15,980 --> 00:02:17,660
在上一堂课的大部分时间里，我们只是你可以

50
00:02:17,660 --> 00:02:18,739
假设 我们谈论的是

51
00:02:18,739 --> 00:02:20,540
单线程执行，

52
00:02:20,540 --> 00:02:22,730
这意味着我有一个线程

53
00:02:22,730 --> 00:02:23,989
将在根部调用 next

54
00:02:23,989 --> 00:02:25,280
假设您正在执行从上到下的迭代器模型

55
00:02:25,280 --> 00:02:27,650


56
00:02:27,650 --> 00:02:29,689
，然后在下面调用 next 直到获得一些数据，然后就可以了

57
00:02:29,689 --> 00:02:32,030
你知道一个线程完成了所有事情，但是

58
00:02:32,030 --> 00:02:33,980
当我们花了很多其他讲座

59
00:02:33,980 --> 00:02:35,420
讨论我们知道如何构建

60
00:02:35,420 --> 00:02:37,940
线程保存并发数据结构时

61
00:02:37,940 --> 00:02:40,519
，我们可以让多个工作

62
00:02:40,519 --> 00:02:43,010
线程或多个线程或进程

63
00:02:43,010 --> 00:02:44,659
同时为我们操作或执行这些任务

64
00:02:44,659 --> 00:02:47,150
，然后在 最后我们

65
00:02:47,150 --> 00:02:48,530
你知道我们把它组合在一起

66
00:02:48,530 --> 00:02:52,549
把它放在一个单一的结果中，我们把它

67
00:02:52,549 --> 00:02:53,810
交给应用程序或

68
00:02:53,810 --> 00:02:55,250
终端，无论是谁调用了

69
00:02:55,250 --> 00:02:56,989
查询，这就是我们今天讨论的内容

70
00:02:56,989 --> 00:02:58,400
，讨论我们如何实际

71
00:02:58,400 --> 00:03:03,230
执行查询 并行，所以它

72
00:03:03,230 --> 00:03:05,540
向我们展示了为什么你

73
00:03:05,540 --> 00:03:06,379
会

74
00:03:06,379 --> 00:03:08,989
在现代时代关心并行执行，

75
00:03:08,989 --> 00:03:11,599
比如今天的 CPU 或 GPU 的

76
00:03:11,599 --> 00:03:13,940
样子，以及我们有更多的

77
00:03:13,940 --> 00:03:16,280
内核可供我们使用等等 我们希望

78
00:03:16,280 --> 00:03:18,319
能够利用它们，因此

79
00:03:18,319 --> 00:03:19,639


80
00:03:19,639 --> 00:03:22,430
如果我们可以支持并行

81
00:03:22,430 --> 00:03:25,160
执行，那么进入数据库系统的好处是我们确实获得了

82
00:03:25,160 --> 00:03:26,780
更好的性能，但没有 总是但

83
00:03:26,780 --> 00:03:28,400
通常是这种情况，或者您希望

84
00:03:28,400 --> 00:03:30,349
情况如此，这可能是

85
00:03:30,349 --> 00:03:32,030
在更好的吞吐量方面，这意味着我们可以

86
00:03:32,030 --> 00:03:33,650
每秒运行更多查询，每秒处理更多

87
00:03:33,650 --> 00:03:36,859
数据将获得更好的延迟，

88
00:03:36,859 --> 00:03:38,540
这意味着我们花费的时间

89
00:03:38,540 --> 00:03:40,879
执行单个查询可以

90
00:03:40,879 --> 00:03:42,980
缩短时间，因为我们

91
00:03:42,980 --> 00:03:45,650
可以并行处理一件事 另一个

92
00:03:45,650 --> 00:03:47,060
优点是我们还将获得

93
00:03:47,060 --> 00:03:49,190
更好的响应性或

94
00:03:49,190 --> 00:03:53,419
系统可用性，这意味着您知道系统

95
00:03:53,419 --> 00:03:54,680
会感觉更 活泼，什么，

96
00:03:54,680 --> 00:03:56,780
对我们的请求做出更快的

97
00:03:56,780 --> 00:03:59,090
响应 再想想还记得

98
00:03:59,090 --> 00:04:00,290
我们在谈论面向磁盘的

99
00:04:00,290 --> 00:04:02,209
数据库系统 嘿还记得我说过

100
00:04:02,209 --> 00:04:04,099
任何时候

101
00:04:04,099 --> 00:04:05,659
对于我们目前讨论过的所有这些数据结构

102
00:04:05,659 --> 00:04:08,120
或者在任何时候查询表堆

103
00:04:08,120 --> 00:04:10,220
可能正在访问不在内存中的页面，

104
00:04:10,220 --> 00:04:11,720
它不在缓冲池中，

105
00:04:11,720 --> 00:04:15,260
因此它必须停止，而您

106
00:04:15,260 --> 00:04:16,548
知道我们从磁盘中获取它并将

107
00:04:16,548 --> 00:04:18,978
其带入我们的缓冲池，因此如果我们只

108
00:04:18,978 --> 00:04:21,048
需要 每次我们不得不从磁盘接触数据时，在我们的系统中执行一个线程

109
00:04:21,048 --> 00:04:22,419
或整个系统的一个进程，

110
00:04:22,419 --> 00:04:24,530


111
00:04:24,530 --> 00:04:26,330


112
00:04:26,330 --> 00:04:28,760
当我们去获取我们需要的数据时，这将是很长时间的停顿，

113
00:04:28,760 --> 00:04:30,440
因此系统看起来

114
00:04:30,440 --> 00:04:32,360
没有响应，但是 但是允许我们进行

115
00:04:32,360 --> 00:04:33,529


116
00:04:33,529 --> 00:04:35,929
当前执行的操作，我们可以

117
00:04:35,929 --> 00:04:37,219
有一个线程块，因为它正在

118
00:04:37,219 --> 00:04:38,179
收集一些磁盘，但其他

119
00:04:38,179 --> 00:04:40,009
线程可以继续运行并希望

120
00:04:40,009 --> 00:04:41,499
对内存中已有的内容进行操作，

121
00:04:41,499 --> 00:04:45,379
并且仍然继续前进，

122
00:04:45,379 --> 00:04:47,149
在一天结束时 这一切

123
00:04:47,149 --> 00:04:48,529
都会加起来，它会

124
00:04:48,529 --> 00:04:50,419
降低我们数据库系统的总拥有成本

125
00:04:50,419 --> 00:04:53,659
或 TCO，所以 TCO

126
00:04:53,659 --> 00:04:55,429
通常是企业界的

127
00:04:55,429 --> 00:04:57,229
人们对数据库系统成本的看法，

128
00:04:57,229 --> 00:04:59,239
它不仅仅是

129
00:04:59,239 --> 00:05:00,799
购买机器或

130
00:05:00,799 --> 00:05:02,569
支付软件许可证的

131
00:05:02,569 --> 00:05:04,219
费用这是实际运行这个东西的总成本，

132
00:05:04,219 --> 00:05:05,869
因为你知道一段时间，

133
00:05:05,869 --> 00:05:07,459
所以包括软件

134
00:05:07,459 --> 00:05:09,199
许可证包括 硬件 它还

135
00:05:09,199 --> 00:05:11,089
包括实际设置软件的人工成本

136
00:05:11,089 --> 00:05:13,039
设置机器

137
00:05:13,039 --> 00:05:14,719
实际运行服务器的能源成本

138
00:05:14,719 --> 00:05:18,109
所以如果我们可以

139
00:05:18,109 --> 00:05:20,479
用更少的硬件做更多的工作 那么

140
00:05:20,479 --> 00:05:23,029
这将显着减少，所以这

141
00:05:23,029 --> 00:05:24,649
也是 对我们来说也是一个巨大的胜利，所以这

142
00:05:24,649 --> 00:05:25,879
意味着如果我们购买一台拥有更多内核的新机器，

143
00:05:25,879 --> 00:05:29,059
我们希望我们的数据被某些

144
00:05:29,059 --> 00:05:31,179
人利用，

145
00:05:31,179 --> 00:05:34,519
所以我们需要区分的东西 -

146
00:05:34,519 --> 00:05:35,659
在我们今天开始谈论并行

147
00:05:35,659 --> 00:05:37,519
情况之前 是为了

148
00:05:37,519 --> 00:05:39,649
能够区分分布式

149
00:05:39,649 --> 00:05:42,349
执行或分布式数据库，所以

150
00:05:42,349 --> 00:05:43,729
在高层次上但两者都试图做

151
00:05:43,729 --> 00:05:46,429
同样的事情，所以在并行数据库中，

152
00:05:46,429 --> 00:05:47,689
分布式 Avis 的想法是你

153
00:05:47,689 --> 00:05:49,569
有一个分布在

154
00:05:49,569 --> 00:05:53,239
多个资源上的数据库，允许你

155
00:05:53,239 --> 00:05:55,969


156
00:05:55,969 --> 00:05:58,039
在大多数成本延迟之前再次改进数据库系统的不同特性

157
00:05:58,039 --> 00:06:01,879
，所以我在

158
00:06:01,879 --> 00:06:03,409
这里强调资源这个词，

159
00:06:03,409 --> 00:06:05,119
因为我不一定说 g

160
00:06:05,119 --> 00:06:06,889
这意味着另一台机器或多

161
00:06:06,889 --> 00:06:10,309
台机器对它可能是多个 CPU

162
00:06:10,309 --> 00:06:12,169
可能是多个磁盘好吧所有

163
00:06:12,169 --> 00:06:14,239
这些都不会称我们为

164
00:06:14,239 --> 00:06:17,209
分布式并行数据库系统

165
00:06:17,209 --> 00:06:19,699
所以从应用程序的角度来看

166
00:06:19,699 --> 00:06:21,229
就像从你认识的人那里

167
00:06:21,229 --> 00:06:22,789
打开 终端并

168
00:06:22,789 --> 00:06:24,109
编写单个查询并将其发送到

169
00:06:24,109 --> 00:06:26,569
我们的数据库系统他们应该知道

170
00:06:26,569 --> 00:06:30,169
不应该关心我们是并行

171
00:06:30,169 --> 00:06:31,429
致敬数据库还是单节点

172
00:06:31,429 --> 00:06:33,499
数据库系统再次排名是续集

173
00:06:33,499 --> 00:06:34,579
声明性语言的美妙

174
00:06:34,579 --> 00:06:36,529
我写了我的选择语句

175
00:06:36,529 --> 00:06:37,969
我不在乎我的数据

176
00:06:37,969 --> 00:06:39,559
实际存储在哪里我不在乎

177
00:06:39,559 --> 00:06:41,029
它是否必须加入你知道

178
00:06:41,029 --> 00:06:42,649
通过网络移动数据还是

179
00:06:42,649 --> 00:06:45,019
再次跨不同套接字移动数据

180
00:06:45,019 --> 00:06:46,909
续集查询对这些名称是不可知的

181
00:06:46,909 --> 00:06:47,270


182
00:06:47,270 --> 00:06:49,820
所以如果我们有 一个新的数据库

183
00:06:49,820 --> 00:06:51,710
系统，然后我们开始扩展它

184
00:06:51,710 --> 00:06:53,720
以使其并行或分布式然后

185
00:06:53,720 --> 00:06:55,190
我们不应该发推文我们

186
00:06:55,190 --> 00:06:56,270
应该回去重写o 你的

187
00:06:56,270 --> 00:06:57,740
应用程序重写了所有的后续

188
00:06:57,740 --> 00:06:58,910
语句，一切都应该仍然可以

189
00:06:58,910 --> 00:07:01,460
正常工作，这就是

190
00:07:01,460 --> 00:07:02,570
我们在这里再次尝试做的最终目标，

191
00:07:02,570 --> 00:07:04,490
断开连接或

192
00:07:04,490 --> 00:07:07,040
逻辑与物理的抽象层，我们

193
00:07:07,040 --> 00:07:08,510
可以根据需要移动物理内容

194
00:07:08,510 --> 00:07:10,550
，并且 逻辑部分没有

195
00:07:10,550 --> 00:07:13,430
改变，这

196
00:07:13,430 --> 00:07:14,990
对我们来说现在似乎很明显，但就像

197
00:07:14,990 --> 00:07:17,780
那是一件大事，实际上

198
00:07:17,780 --> 00:07:18,980
几年前内部海鸥系统

199
00:07:18,980 --> 00:07:20,420
也是一件大事，但在 1970 年代这很重要，

200
00:07:20,420 --> 00:07:23,900
所以

201
00:07:23,900 --> 00:07:25,160
分布在一对

202
00:07:25,160 --> 00:07:27,140
数据库中的差异例程如下，所以这是我的

203
00:07:27,140 --> 00:07:28,310


204
00:07:28,310 --> 00:07:30,230


205
00:07:30,230 --> 00:07:31,640


206
00:07:31,640 --> 00:07:33,080


207
00:07:33,080 --> 00:07:35,930
定义 术语

208
00:07:35,930 --> 00:07:38,750
并行分布式通常是这些术语

209
00:07:38,750 --> 00:07:40,850
经常混合在一起，但在

210
00:07:40,850 --> 00:07:42,950
大多数情况下，人们的意思是大多数人都拥有

211
00:07:42,950 --> 00:07:44,120
这种系统，但

212
00:07:44,120 --> 00:07:46,610
仍然错过了很多系统如此平行 lel

213
00:07:46,610 --> 00:07:48,650
数据库是一个

214
00:07:48,650 --> 00:07:50,210
系统中可供我们使用的资源

215
00:07:50,210 --> 00:07:52,430
将在物理上彼此接近的数据库

216
00:07:52,430 --> 00:07:56,240
，就像

217
00:07:56,240 --> 00:07:59,480
具有两个 CPU 插槽的单机架单元机器一样，

218
00:07:59,480 --> 00:08:02,240
因此 CPU 插槽具有

219
00:08:02,240 --> 00:08:04,130
Corsican XE 查询 对我们来说，这些

220
00:08:04,130 --> 00:08:05,210
东西真的很接近，因为

221
00:08:05,210 --> 00:08:06,650
它们正在通过我们非常快速和

222
00:08:06,650 --> 00:08:09,680
高带宽的互连，这就是

223
00:08:09,680 --> 00:08:10,760
资源将如何

224
00:08:10,760 --> 00:08:12,470
再次相互通信，无论是 CPU，

225
00:08:12,470 --> 00:08:14,750
什么是计算或存储

226
00:08:14,750 --> 00:08:17,900
，现在不重要，然后

227
00:08:17,900 --> 00:08:19,190
对于今天的讨论，最重要的

228
00:08:19,190 --> 00:08:21,500
是我们将

229
00:08:21,500 --> 00:08:23,300
假设这些

230
00:08:23,300 --> 00:08:25,910
不同资源之间的通信不仅

231
00:08:25,910 --> 00:08:29,020
快速且便宜，而且可靠我的

232
00:08:29,020 --> 00:08:31,730
意思是如果我从一个 CPU

233
00:08:31,730 --> 00:08:33,799
插槽向另一个 CPU 发送消息 socket 它

234
00:08:33,799 --> 00:08:36,110
不会被正确丢弃，因为这

235
00:08:36,110 --> 00:08:38,539
意味着我正在丢失互连上的缓存流量，

236
00:08:38,539 --> 00:08:40,340
而且我还有

237
00:08:40,340 --> 00:08:41,419
一大堆其他问题，而不仅仅是丢失

238
00:08:41,419 --> 00:08:43,039
数据库 像整个系统

239
00:08:43,039 --> 00:08:45,890
在

240
00:08:45,890 --> 00:08:48,110
分布式数据库中分崩离析之类的消息，资源可能

241
00:08:48,110 --> 00:08:50,510
彼此远离，因此

242
00:08:50,510 --> 00:08:52,100
可能意味着

243
00:08:52,100 --> 00:08:53,390
同一机架中的不同机器在

244
00:08:53,390 --> 00:08:54,890
同一数据中心内的不同机器或

245
00:08:54,890 --> 00:08:56,210
不同部分的不同机器 世界正确的

246
00:08:56,210 --> 00:08:57,890
东海岸与美国西海岸的数据

247
00:08:57,890 --> 00:09:00,560
中心，

248
00:09:00,560 --> 00:09:01,290


249
00:09:01,290 --> 00:09:02,370
因此为了传达您对

250
00:09:02,370 --> 00:09:04,470
资源的需求，我们必须通过较慢的

251
00:09:04,470 --> 00:09:07,230
通信渠道，例如公共

252
00:09:07,230 --> 00:09:09,180
广域网，这东西在哪里

253
00:09:09,180 --> 00:09:10,440
可以像之间的互连

254
00:09:10,440 --> 00:09:12,709
CPU 套接字更快，

255
00:09:12,709 --> 00:09:15,899
因此因为我们正在检查这种

256
00:09:15,899 --> 00:09:19,620
不可靠的互连，我们不能

257
00:09:19,620 --> 00:09:21,209
假设我们的旧消息会

258
00:09:21,209 --> 00:09:22,860
很快出现并以我们期望的正确

259
00:09:22,860 --> 00:09:24,480
顺序出现，或者

260
00:09:24,480 --> 00:09:26,970
您根本不出现 所以当我们谈论分布式数据库和学期时，

261
00:09:26,970 --> 00:09:28,800
我们必须处理一大堆其他难题，

262
00:09:28,800 --> 00:09:30,630


263
00:09:30,630 --> 00:09:32,910
所以我们将

264
00:09:32,910 --> 00:09:34,800
忽略所有这些 现在我们

265
00:09:34,800 --> 00:09:37,110
将专注于并行数据库，

266
00:09:37,110 --> 00:09:39,290
为此您可以假设

267
00:09:39,290 --> 00:09:41,550
它是一台机器，它有一堆

268
00:09:41,550 --> 00:09:42,990
套接字 一堆可以同时运行的内核

269
00:09:42,990 --> 00:09:45,959
我可能

270
00:09:45,959 --> 00:09:47,610
也在谈论 与

271
00:09:47,610 --> 00:09:51,720
本地机器人相同的磁盘，它是本地的，好吧，

272
00:09:51,720 --> 00:09:54,420
所以今天我们首先

273
00:09:54,420 --> 00:09:56,910
讨论流程模型，这就是我们将

274
00:09:56,910 --> 00:09:58,470
如何组织系统以命令

275
00:09:58,470 --> 00:09:59,880
实际让工作人员执行我们的

276
00:09:59,880 --> 00:10:02,009
查询，然后我们将 讨论我们如何

277
00:10:02,009 --> 00:10:04,139
实际支持

278
00:10:04,139 --> 00:10:06,480
我们的查询计划的并行执行，然后我们将

279
00:10:06,480 --> 00:10:08,880
讨论 - 在它的观点中获得并行

280
00:10:08,880 --> 00:10:11,069
爱荷华并行我放弃了这两个人之间的

281
00:10:11,069 --> 00:10:12,510
青少年计算与存储的区别

282
00:10:12,510 --> 00:10:14,190
然后正如我所说

283
00:10:14,190 --> 00:10:16,199
我们将在 最后谈谈

284
00:10:16,199 --> 00:10:17,910
对预期的快速回顾，

285
00:10:17,910 --> 00:10:23,540
然后在中期是对的，所以

286
00:10:23,540 --> 00:10:26,970
数据库系统流程模型是

287
00:10:26,970 --> 00:10:28,709
我们将如何组织或架构

288
00:10:28,709 --> 00:10:31,800
系统以让多个工作人员运行

289
00:10:31,800 --> 00:10:34,290
并发请求以及我们这样做的

290
00:10:34,290 --> 00:10:36,209
原因 必须这样做是因为我们

291
00:10:36,209 --> 00:10:38,250
可以让应用程序发送非常

292
00:10:38,250 --> 00:10:39,569
大的请求，我们希望将其拆分

293
00:10:39,569 --> 00:10:41,610
到多个工作人员中，或者我们可以

294
00:10:41,610 --> 00:10:43,500
让地图应用程序同时发送多个

295
00:10:43,500 --> 00:10:45,240
请求，我们

296
00:10:45,240 --> 00:10:46,589
希望将游戏拆分到不同的

297
00:10:46,589 --> 00:10:49,949
工作人员，所以在 OTP 的情况下，这

298
00:10:49,949 --> 00:10:52,350
将是一堆小请求，所以我们希望

299
00:10:52,350 --> 00:10:54,569
在 OLAP 中并行运行它们

300
00:10:54,569 --> 00:10:57,120
，传统上，您知道

301
00:10:57,120 --> 00:10:58,439
少量请求，但这些请求

302
00:10:58,439 --> 00:10:59,850
然后我们希望拆分并

303
00:10:59,850 --> 00:11:01,829
并行运行 同时，所以我们稍后将

304
00:11:01,829 --> 00:11:02,759
讨论这种类型的并行性的区别 这是

305
00:11:02,759 --> 00:11:05,670


306
00:11:05,670 --> 00:11:07,410


307
00:11:07,410 --> 00:11:09,870


308
00:11:09,870 --> 00:11:13,019
今天的总体思路

309
00:11:13,019 --> 00:11:15,130


310
00:11:15,130 --> 00:11:18,190
能够执行某些

311
00:11:18,190 --> 00:11:19,600
其他部分决策要求执行的任务的系统，

312
00:11:19,600 --> 00:11:22,000
就像网络层收到一个请求，我们

313
00:11:22,000 --> 00:11:23,620
通过查询优化器运行它，

314
00:11:23,620 --> 00:11:25,420
现在我们有了一个查询计划，而查询

315
00:11:25,420 --> 00:11:27,130
计划是一项任务 我们想

316
00:11:27,130 --> 00:11:29,260
交给一个或多个工人并让他们

317
00:11:29,260 --> 00:11:31,390
执行这件事，所以我

318
00:11:31,390 --> 00:11:32,860
使用术语工人的原因是因为它可能

319
00:11:32,860 --> 00:11:35,620
是一个过程，也可能是一个线程，我们

320
00:11:35,620 --> 00:11:37,750
可以在其中之一，但我喜欢基本的

321
00:11:37,750 --> 00:11:40,330
想法仍然是相同的，

322
00:11:40,330 --> 00:11:43,060


323
00:11:43,060 --> 00:11:45,190
如果有什么东西可以

324
00:11:45,190 --> 00:11:46,390
将它交给

325
00:11:46,390 --> 00:11:47,740
应用程序并说你知道这是

326
00:11:47,740 --> 00:11:51,460
你执行的查询的结果，那么传统上工作人员负责给定的任务，

327
00:11:51,460 --> 00:11:52,840
所以我们可以拥有三个三行流程模型

328
00:11:52,840 --> 00:11:56,730
是的，

329
00:11:57,520 --> 00:11:58,780
你看到的问题是我们可以说一个工人

330
00:11:58,780 --> 00:12:01,240
是一个线程是的工人将是一个

331
00:12:01,240 --> 00:12:03,550
进程或一个线程相关的进程

332
00:12:03,550 --> 00:12:08,680
模型你使用是的这个问题到

333
00:12:08,680 --> 00:12:09,790
应用程序必然意味着你需要

334
00:12:09,790 --> 00:12:14,470
能力或没有可能是但所有的 OTP 是的，

335
00:12:14,470 --> 00:12:16,720
我想 就像我有一个网页一样，我有

336
00:12:16,720 --> 00:12:17,950
多个用户访问一个网页，

337
00:12:17,950 --> 00:12:20,140
每个页面加载都会

338
00:12:20,140 --> 00:12:22,240
在服务器端触发一堆代码，比如

339
00:12:22,240 --> 00:12:25,360
PHP JavaScript Python，并且该

340
00:12:25,360 --> 00:12:27,760
代码将执行一堆请求

341
00:12:27,760 --> 00:12:30,040
从数据库中获取数据，然后

342
00:12:30,040 --> 00:12:32,080
将 HTML 呈现给您，因此我有

343
00:12:32,080 --> 00:12:33,550
多个用户访问我的网页

344
00:12:33,550 --> 00:12:35,140
，然后每个用户都飞出此

345
00:12:35,140 --> 00:12:36,370
代码，然后触发不同的

346
00:12:36,370 --> 00:12:38,830
请求，或者它可能像单个

347
00:12:38,830 --> 00:12:40,960
仪表板或分析应用程序

348
00:12:40,960 --> 00:12:43,360
一个用户一次提交

349
00:12:43,360 --> 00:12:45,820
你知道的大部分查询，但

350
00:12:45,820 --> 00:12:48,100
随后我们希望并行运行这些查询以

351
00:12:48,100 --> 00:12:53,020
成为其中之一，因此

352
00:12:53,020 --> 00:12:54,130
我们可以在

353
00:12:54,130 --> 00:12:55,750
我们的数据库系统中拥有一个理论过程模型，第一个是

354
00:12:55,750 --> 00:12:57,370
我们将 每个工人

355
00:12:57,370 --> 00:12:59,260
有一个进程然后我们可以有一个进程池

356
00:12:59,260 --> 00:13:01,780
然后剧透是最

357
00:13:01,780 --> 00:13:03,250
常见的一个是最后一个至少

358
00:13:03,250 --> 00:13:04,990
在较新的系统中我们实际上是一个

359
00:13:04,990 --> 00:13:06,310
多线程系统我们

360
00:13:06,310 --> 00:13:08,590
每个工人有多个一个线程 所以我们

361
00:13:08,590 --> 00:13:09,760
将逐一介绍这些示例

362
00:13:09,760 --> 00:13:14,590
中的每一个，因此每个工人的进程

363
00:13:14,590 --> 00:13:17,230
是最基本的一种方法，我们

364
00:13:17,230 --> 00:13:19,660
将让单个工人

365
00:13:19,660 --> 00:13:22,900
由单个操作系统进程表示，因此

366
00:13:22,900 --> 00:13:24,280
您的应用程序会发生什么 ion 发送一个

367
00:13:24,280 --> 00:13:25,930
请求，说嘿，我想执行一个

368
00:13:25,930 --> 00:13:27,220
查询或打开与数据库系统的连接

369
00:13:27,220 --> 00:13:28,590


370
00:13:28,590 --> 00:13:29,910
某个集中式协调器一个

371
00:13:29,910 --> 00:13:31,410
调度程序，它获取该初始

372
00:13:31,410 --> 00:13:33,900
请求，然后现在可以分叉一个

373
00:13:33,900 --> 00:13:37,080
将作为单独

374
00:13:37,080 --> 00:13:39,900
进程获取的工作人员 负责

375
00:13:39,900 --> 00:13:42,060
处理这个连接，所以现在

376
00:13:42,060 --> 00:13:43,350
发生了什么，因为调度员说好的

377
00:13:43,350 --> 00:13:44,700
我给你一个工人这里是

378
00:13:44,700 --> 00:13:45,930
你可以与之通信的端口号

379
00:13:45,930 --> 00:13:48,420
，然后现在应用程序

380
00:13:48,420 --> 00:13:49,710
只直接与

381
00:13:49,710 --> 00:13:51,510
工人通信，工人负责

382
00:13:51,510 --> 00:13:53,160
做任何你知道的

383
00:13:53,160 --> 00:13:55,100
事情，执行查询想要的任何请求，

384
00:13:55,100 --> 00:14:00,780
所以问题是

385
00:14:00,780 --> 00:14:03,150
有多个工作人员在那里有

386
00:14:03,150 --> 00:14:06,630
单独的进程，现在他们再次

387
00:14:06,630 --> 00:14:08,520
假设我们现在是一个 Discordian 系统，

388
00:14:08,520 --> 00:14:09,840
现在可以在他们自己的缓冲区中

389
00:14:09,840 --> 00:14:11,700
池并从磁盘中获取页面

390
00:14:11,700 --> 00:14:14,010
并将它们带到内存中，但

391
00:14:14,010 --> 00:14:15,570
现在我们当然不想在这些页面中拥有多个

392
00:14:15,570 --> 00:14:18,090
相同页面的副本

393
00:14:18,090 --> 00:14:20,040
单独的流程，因为现在我们

394
00:14:20,040 --> 00:14:21,150
必须像八号法庭一样跨越它们，

395
00:14:21,150 --> 00:14:22,980
如果您来回发送消息，那将会很昂贵

396
00:14:22,980 --> 00:14:25,050
，这

397
00:14:25,050 --> 00:14:26,100
只是在浪费内存，因为

398
00:14:26,100 --> 00:14:26,880
我们再次上升我们已经完成了两个

399
00:14:26,880 --> 00:14:28,800
副本 所以

400
00:14:28,800 --> 00:14:30,690
解决这个问题的方法是每个人

401
00:14:30,690 --> 00:14:33,270
都可以使用共享内存，它可以

402
00:14:33,270 --> 00:14:34,410
允许这些

403
00:14:34,410 --> 00:14:35,820
通常

404
00:14:35,820 --> 00:14:37,860
在内存中拥有自己独立地址空间的不同进程，其中很多进程共享

405
00:14:37,860 --> 00:14:39,650
对这些全局数据结构的访问

406
00:14:39,650 --> 00:14:42,030
权限，而操作系统是 是什么促进了

407
00:14:42,030 --> 00:14:47,010
这一点，所以

408
00:14:47,010 --> 00:14:49,020
如果您担心系统的弹性，您还可以从这种方法中获得的一个优势

409
00:14:49,020 --> 00:14:50,970


410
00:14:50,970 --> 00:14:53,250
是，如果

411
00:14:53,250 --> 00:14:55,800
您的工作代码中有一个博客并且它崩溃了，它

412
00:14:55,800 --> 00:14:57,150
最终不会导致整个

413
00:14:57,150 --> 00:14:58,770
系统崩溃 因为只是这个进程

414
00:14:58,770 --> 00:15:01,590
崩溃了，就像操作系统知道它是

415
00:15:01,590 --> 00:15:03,720
从调度程序分叉出来的，但

416
00:15:03,720 --> 00:15:05,100
如果有一个人失败了，它不会关闭整个系统

417
00:15:05,100 --> 00:15:18,540
是的，是的，所以共享

418
00:15:18,540 --> 00:15:21,480
内存是他们覆盖的 在五个

419
00:15:21,480 --> 00:15:24,090
13 到 13 或没有 是的 好吧 所以共享

420
00:15:24,090 --> 00:15:25,200
内存是操作系统提供的契约 上面

421
00:15:25,200 --> 00:15:28,230
写着这里有一些

422
00:15:28,230 --> 00:15:30,150
内存区域 所以通常当我

423
00:15:30,150 --> 00:15:32,250
在我的进程中调用 malloc 时，这是我的

424
00:15:32,250 --> 00:15:34,080
私有地址空间，只有我可以

425
00:15:34,080 --> 00:15:35,760
靠得住 对于具有共享

426
00:15:35,760 --> 00:15:37,590
内存的内存，您告诉操作系统嘿 Malik 我有

427
00:15:37,590 --> 00:15:39,990
一堆空间，然后允许该

428
00:15:39,990 --> 00:15:41,490
共享内存组中具有权限

429
00:15:41,490 --> 00:15:42,940
的任何人也可以读写

430
00:15:42,940 --> 00:15:45,430
，通常操作系统不会

431
00:15:45,430 --> 00:15:47,260
让您这样做，就是这样

432
00:15:47,260 --> 00:15:48,880
操作系统碳化物的保护之一，

433
00:15:48,880 --> 00:15:50,230
但这允许你现在有一个

434
00:15:50,230 --> 00:15:50,890
内存块在多个进程之间共享，

435
00:15:50,890 --> 00:15:53,950
所以如果除非我有共享

436
00:15:53,950 --> 00:15:55,960
内存，那么每个工人都会

437
00:15:55,960 --> 00:15:57,370
有自己的缓冲池，它会

438
00:15:57,370 --> 00:15:59,770
带来页面 这些只是被复制

439
00:15:59,770 --> 00:16:01,690
到其他工作池或其他工作人员

440
00:16:01,690 --> 00:16:04,260
中，他们带来了相同的页面，

441
00:16:04,260 --> 00:16:07,090
因此这种方法几乎用于

442
00:16:07,090 --> 00:16:10,060
所有旧数据库系统，每个

443
00:16:10,060 --> 00:16:11,650
数据库都在 1970 年代制造

444
00:16:11,650 --> 00:16:15,280
1980 年代也许 1990 年代初正在使用这种

445
00:16:15,280 --> 00:16:20,560
方法 有人猜测为什么

446
00:16:20,560 --> 00:16:27,850
要处理这些曾经的线程 他

447
00:16:27,850 --> 00:16:29,500
说也许没有线程但非常

448
00:16:29,500 --> 00:16:32,920
接近 所以当时的线程

449
00:16:32,920 --> 00:16:34,750
不如我们现在有一个选项卡 但

450
00:16:34,750 --> 00:16:36,660
没有标准线程

451
00:16:36,660 --> 00:16:38,950
像 1980 年代

452
00:16:38,950 --> 00:16:41,920
POSIX 之前 P 线程之前的 API 规则，所以他们拥有

453
00:16:41,920 --> 00:16:43,330
所有这些不同的 UNIX 变体，所有

454
00:16:43,330 --> 00:16:44,500
这些不同的操作系统，

455
00:16:44,500 --> 00:16:46,330
所以如果我有我的数据库系统

456
00:16:46,330 --> 00:16:47,980
并且我想让它在 alt 上运行，你

457
00:16:47,980 --> 00:16:49,990
知道自己的支持和所有 这些其他操作系统

458
00:16:49,990 --> 00:16:54,160
我不得不重写我的应用程序我的数据库

459
00:16:54,160 --> 00:16:55,930
系统以将线程 API 用于所有

460
00:16:55,930 --> 00:16:57,580
这些不同的操作系统，

461
00:16:57,580 --> 00:16:59,500
现在 P 线程和某种 Linux 是

462
00:16:59,500 --> 00:17:01,180


463
00:17:01,180 --> 00:17:03,070
每个人都使用的主要 UNIX 变体，这对每个人来说都足够好了，

464
00:17:03,070 --> 00:17:04,750
所以回到今天

465
00:17:04,750 --> 00:17:06,400
不像我们现在每个人都有自己的

466
00:17:06,400 --> 00:17:07,510
线程包，它不是

467
00:17:07,510 --> 00:17:08,709
标准的 API，我们必须重写

468
00:17:08,709 --> 00:17:10,660
所有内容，所以现在每个人都有 fork

469
00:17:10,660 --> 00:17:12,790
享受是 基本的

470
00:17:12,790 --> 00:17:15,790
操作系统原语 所以如果你

471
00:17:15,790 --> 00:17:18,400
使用这个进程模型构建了一个数据库系统

472
00:17:18,400 --> 00:17:20,829
那么它几乎可以

473
00:17:20,829 --> 00:17:23,250
在任何地方工作

474
00:17:23,369 --> 00:17:25,959
所以它的扩展称为

475
00:17:25,959 --> 00:17:28,900
进程池 所以在这种情况下我们

476
00:17:28,900 --> 00:17:31,060
仍然在处理我们的进程 但想法

477
00:17:31,060 --> 00:17:32,560
是 而不是

478
00:17:32,560 --> 00:17:34,750
为每个单独的连接分叉一个进程

479
00:17:34,750 --> 00:17:37,060
，我们只是有一群

480
00:17:37,060 --> 00:17:38,560
工作人员坐在旁边，我们是

481
00:17:38,560 --> 00:17:39,970
调度员可以坐下可以选择其中一个

482
00:17:39,970 --> 00:17:40,960
说现在你负责

483
00:17:40,960 --> 00:17:44,140
执行这个查询然后

484
00:17:44,140 --> 00:17:45,550
您现在还可以做的是因为您有一个

485
00:17:45,550 --> 00:17:47,530
池，并且您知道周围还有其他

486
00:17:47,530 --> 00:17:49,060
进程可以帮助您完成

487
00:17:49,060 --> 00:17:52,750
工作，现在您实际上可以做

488
00:17:52,750 --> 00:17:54,220
一些查询并行性，因为现在您

489
00:17:54,220 --> 00:17:56,230
可以说我需要这个

490
00:17:56,230 --> 00:17:56,800
查询

491
00:17:56,800 --> 00:17:58,120
这对我来说需要太多的工作，

492
00:17:58,120 --> 00:17:59,530
所以也许我会把一半的

493
00:17:59,530 --> 00:18:01,030
工作交给另一个进程，

494
00:18:01,030 --> 00:18:03,490
让它在单个进程

495
00:18:03,490 --> 00:18:06,370
想到最后一张幻灯片中每个工人的进程模型时让它正常运行

496
00:18:06,370 --> 00:18:08,620
你不知道还有

497
00:18:08,620 --> 00:18:10,360
什么正在运行，你想

498
00:18:10,360 --> 00:18:11,590
在你运行的时候分叉你知道一个进程，

499
00:18:11,590 --> 00:18:12,960
因为这会很昂贵，

500
00:18:12,960 --> 00:18:15,190
而这个家伙有

501
00:18:15,190 --> 00:18:25,270
Niki 可靠使用的东西，所以是的，所以他的问题

502
00:18:25,270 --> 00:18:28,210
是什么 是数据库系统 数据

503
00:18:28,210 --> 00:18:30,130
系统将是

504
00:18:30,130 --> 00:18:33,820
这里的一切 我们所有人 这是应用程序

505
00:18:33,820 --> 00:18:35,470
这就像您的网站

506
00:18:35,470 --> 00:18:37,570
这是您所知道的任何东西 这不是

507
00:18:37,570 --> 00:18:38,860
与数据库对话的应用程序

508
00:18:38,860 --> 00:18:40,480
所以这是发送续集查询

509
00:18:40,480 --> 00:18:42,190
和调度员 是我们

510
00:18:42,190 --> 00:18:43,540
与 Hannum 一起处理的那个，是的，我们认为

511
00:18:43,540 --> 00:18:45,280
这里有一条分界线，说明

512
00:18:45,280 --> 00:18:46,480
了数据库系统的所有内容，

513
00:18:46,480 --> 00:18:51,220
因此重要的是，

514
00:18:51,220 --> 00:18:52,360
尽管在这张幻灯片和上一张幻灯片的情况下，

515
00:18:52,360 --> 00:18:54,160
这些

516
00:18:54,160 --> 00:18:56,860
是 完整的操作系统进程，所以我们

517
00:18:56,860 --> 00:18:58,390
没有在数据库系统中自己做任何调度

518
00:18:58,390 --> 00:18:59,740
，操作系统

519
00:18:59,740 --> 00:19:01,390
负责完成所有这些

520
00:19:01,390 --> 00:19:03,160
调度，现在我们可以给它好的标志

521
00:19:03,160 --> 00:19:04,690
两个优先级标志和 试着说

522
00:19:04,690 --> 00:19:06,550
这个应该获得更高的优先级或

523
00:19:06,550 --> 00:19:09,100
更多的运行时间这个其他进程但在

524
00:19:09,100 --> 00:19:10,600
高层次上我们无法控制什么被

525
00:19:10,600 --> 00:19:12,670
安排正确所以一旦我们交出

526
00:19:12,670 --> 00:19:17,950
工作它就会运行是的这个问题

527
00:19:17,950 --> 00:19:19,030
你知道你有更多吗 不是

528
00:19:19,030 --> 00:19:24,820
一个工人池 不，这些有一个相当多

529
00:19:24,820 --> 00:19:26,290
的问题是您

530
00:19:26,290 --> 00:19:27,430
在工作报告中修复了我们的流程 是的 所以这

531
00:19:27,430 --> 00:19:28,720
是您在打开数据集时定义的内容

532
00:19:28,720 --> 00:19:30,880
您说有多少我的

533
00:19:30,880 --> 00:19:31,150
意思是

534
00:19:31,150 --> 00:19:35,290
工作流程英里 - 一半因为

535
00:19:35,290 --> 00:19:37,030
永远有连接分叉

536
00:19:37,030 --> 00:19:39,490
然后系统变得不堪重负然后

537
00:19:39,490 --> 00:19:40,900
通常你所做的是你

538
00:19:40,900 --> 00:19:44,560
在真实系统中总是有一个你总是有一个

539
00:19:44,560 --> 00:19:47,560
工人就像特殊工人

540
00:19:47,560 --> 00:19:49,030
这样如果你得到系统被

541
00:19:49,030 --> 00:19:50,770
锁定那里 总是有一个工人可以

542
00:19:50,770 --> 00:19:52,510
接受来自管理帐户的传入请求，

543
00:19:52,510 --> 00:19:54,130
这样他们就可以开始

544
00:19:54,130 --> 00:19:58,420
杀死事物并清理事物 他

545
00:19:58,420 --> 00:19:59,710
说流程处理

546
00:19:59,710 --> 00:20:00,520
什么 M＆E 工作要做

547
00:20:00,520 --> 00:20:04,180
它坐下来等待正确和

548
00:20:04,180 --> 00:20:06,930
实际 这就是

549
00:20:07,550 --> 00:20:09,910
我们

550
00:20:09,910 --> 00:20:12,350
昨天在开发人员会议上为

551
00:20:12,350 --> 00:20:14,900
业务讨论的这个问题，我们正在我们的 ole

552
00:20:14,900 --> 00:20:17,570
中构建，因为我们在 CMU 构建我们

553
00:20:17,570 --> 00:20:19,130
在我们将所有代码扔到旧系统中之前遇到了这个问题，

554
00:20:19,130 --> 00:20:21,110
如果没有

555
00:20:21,110 --> 00:20:22,910
做我们的 CT 的工作仍然会旋转到

556
00:20:22,910 --> 00:20:24,830
60% 就像这是在做无用的

557
00:20:24,830 --> 00:20:27,440
事情它正在拉动一些理想的东西

558
00:20:27,440 --> 00:20:29,180
你想要这样如果没有工作

559
00:20:29,180 --> 00:20:31,220
你希望 CP 利用率

560
00:20:31,220 --> 00:20:35,690
像 1% 2% 和我的 我

561
00:20:35,690 --> 00:20:37,040
用于所有演示的系统 我像

562
00:20:37,040 --> 00:20:40,130
续集服务器一样运行 我正在运行 MongoDB 我

563
00:20:40,130 --> 00:20:42,200
正在按碎片运行我的续集 Maurier

564
00:20:42,200 --> 00:20:44,330
DB 你不知道其中的一些

565
00:20:44,330 --> 00:20:46,070
像 CPU 峰值是 10% 时有

566
00:20:46,070 --> 00:20:47,600
什么都不做，大多数就像

567
00:20:47,600 --> 00:20:49,610
以 1% 的速度运行，所以它仍然在做

568
00:20:49,610 --> 00:20:51,260
一些事情，只是因为它正在检查说

569
00:20:51,260 --> 00:20:52,550
嘿，我有工作要做，但你

570
00:20:52,550 --> 00:21:01,640
不想消耗运行周期是的，是的，

571
00:21:01,640 --> 00:21:03,950
有一个问题是做一些工作

572
00:21:03,950 --> 00:21:08,450
反对在高端系统中使用工作窃取

573
00:21:08,450 --> 00:21:11,750
通常是什么 发生的事情

574
00:21:11,750 --> 00:21:14,540
是我应该让我们在

575
00:21:14,540 --> 00:21:16,250
高端系统中嘲笑我们，例如调度员

576
00:21:16,250 --> 00:21:18,560
或协调员，它知道谁在做

577
00:21:18,560 --> 00:21:21,170
什么工作，所以如果它可以即时

578
00:21:21,170 --> 00:21:23,090
识别哦，这个工作人员

579
00:21:23,090 --> 00:21:25,160
可能需要很长时间才能阅读

580
00:21:25,160 --> 00:21:26,660
一堆 数据，它有一堆东西

581
00:21:26,660 --> 00:21:28,400
在队列中，他需要处理，所以

582
00:21:28,400 --> 00:21:29,510
也许我会把它拿出来解决并

583
00:21:29,510 --> 00:21:30,080
交给其他人

584
00:21:30,080 --> 00:21:33,520
是的，高端系统可以做到这一点，

585
00:21:33,970 --> 00:21:37,640
所以这是使用的方法

586
00:21:37,640 --> 00:21:40,640
使用 IBM db2 Postgres

587
00:21:40,640 --> 00:21:43,190
在 2015 年切换到此模型 再次回到上

588
00:21:43,190 --> 00:21:45,830
一张幻灯片 Postgres

589
00:21:45,830 --> 00:21:49,490
oracle 和 tv2 这些都是

590
00:21:49,490 --> 00:21:51,110
旧系统，例如 80 年代和 70 年代

591
00:21:51,110 --> 00:21:54,110
我认为 Sybase 和 Formics 也可能

592
00:21:54,110 --> 00:21:55,610
再次以这种方式工作 同样从

593
00:21:55,610 --> 00:21:59,540
1980 年代开始，大多数现代系统都采用

594
00:21:59,540 --> 00:22:01,040
最后一种方法是多线程方法

595
00:22:01,040 --> 00:22:03,680
，因此现在的基本思想是，

596
00:22:03,680 --> 00:22:05,360
我们不再拥有一堆

597
00:22:05,360 --> 00:22:07,400
都在执行不同任务的进程，

598
00:22:07,400 --> 00:22:09,350
我们只需要一个进程来执行不同的任务

599
00:22:09,350 --> 00:22:11,330
数据库系统 em 并且在它内部它

600
00:22:11,330 --> 00:22:13,400
有自己的线程，他们可以决定

601
00:22:13,400 --> 00:22:16,160
如何根据需要调度事物，

602
00:22:16,160 --> 00:22:18,590
就像再次使用 P 线程或

603
00:22:18,590 --> 00:22:20,190
任何与

604
00:22:20,190 --> 00:22:24,360
Windows 中相同的东西，所以在

605
00:22:24,360 --> 00:22:26,130
这种环境中现在会发生的事情

606
00:22:26,130 --> 00:22:28,140
是因为我们现在 我们可以完全

607
00:22:28,140 --> 00:22:30,900
控制什么 我们知道

608
00:22:30,900 --> 00:22:32,130
任务是什么 我们知道我们有什么线程

609
00:22:32,130 --> 00:22:35,490
我们现在可以做得更好，并且

610
00:22:35,490 --> 00:22:38,880
更容易理解或全局

611
00:22:38,880 --> 00:22:40,380
观 察老烦恼的不同之处或

612
00:22:40,380 --> 00:22:41,700
可用的任务

613
00:22:41,700 --> 00:22:43,440
给我们，然后我们现在

614
00:22:43,440 --> 00:22:45,870
对单个线程做出调度决定 运行

615
00:22:45,870 --> 00:22:47,940
进程模型 我们有点把

616
00:22:47,940 --> 00:22:49,710
东西交给操作系统，让我们

617
00:22:49,710 --> 00:22:54,600
解决问题 所以在我看来，

618
00:22:54,600 --> 00:22:57,270
多线程模型是唯一可行的

619
00:22:57,270 --> 00:22:59,010
方法 从工程的角度来看，这

620
00:22:59,010 --> 00:23:00,930
更容易处理，因为不是你

621
00:23:00,930 --> 00:23:02,280
没有处理

622
00:23:02,280 --> 00:23:04,050
所有这些用于共享内存的操作系统语义

623
00:23:04,050 --> 00:23:07,940
或处理进程管理

624
00:23:07,940 --> 00:23:10,290
开销我也在多线程中进行上下文切换

625
00:23:10,290 --> 00:23:11,580


626
00:23:11,580 --> 00:23:13,680
如果

627
00:23:13,680 --> 00:23:15,060
在操作系统从一个线程切换到下一个线程

628
00:23:15,060 --> 00:23:16,860
然后同一个进程时仍然要付出代价，那么附加的环境要低得多，但

629
00:23:16,860 --> 00:23:20,760


630
00:23:20,760 --> 00:23:21,780


631
00:23:21,780 --> 00:23:23,520
由于所有的安全性和

632
00:23:23,520 --> 00:23:24,900
保护，它不像从一个进程到另一个进程的枪中那样重量级 他们需要的机制

633
00:23:24,900 --> 00:23:27,020
或用于内存

634
00:23:27,020 --> 00:23:29,070
表示或进程的内存存储中的内存，

635
00:23:29,070 --> 00:23:32,040
因此我无法科学地证明这一点，

636
00:23:32,040 --> 00:23:33,990
但总的来说，

637
00:23:33,990 --> 00:23:35,790
多线程进程

638
00:23:35,790 --> 00:23:36,810
将是 davison 比

639
00:23:36,810 --> 00:23:40,560
多进程更快的地方 一个所以要

640
00:23:40,560 --> 00:23:41,880
指出的只是因为我们

641
00:23:41,880 --> 00:23:44,640
将采用多线程流程模型

642
00:23:44,640 --> 00:23:47,010
方法并不意味着我们将获得

643
00:23:47,010 --> 00:23:49,560
自动并行查询执行

644
00:23:49,560 --> 00:23:51,840
，特别是我们可能不一定获得

645
00:23:51,840 --> 00:23:53,340
我将要讨论的查询内并行性

646
00:23:53,340 --> 00:23:54,360
在多几张幻灯片中，这意味着

647
00:23:54,360 --> 00:23:57,150


648
00:23:57,150 --> 00:23:58,230
即使我们的数据系统可以在

649
00:23:58,230 --> 00:24:00,540
多个线程上运行，如果我给它一个

650
00:24:00,540 --> 00:24:02,430
查询，它也不能

651
00:24:02,430 --> 00:24:03,570
在多个线程中分解该查询 ds 并行运行所有

652
00:24:03,570 --> 00:24:06,780
这些，所以我的续集 5.7 是一个

653
00:24:06,780 --> 00:24:09,120
多线程数据库系统，但它

654
00:24:09,120 --> 00:24:11,370
不能执行引入查询并行性，这

655
00:24:11,370 --> 00:24:13,230
可能在 8 个中得到修复我

656
00:24:13,230 --> 00:24:17,760
今天之前忘记检查了，对我来说

657
00:24:17,760 --> 00:24:19,500
就像我理解

658
00:24:19,500 --> 00:24:21,450
的 数据库世界 没有

659
00:24:21,450 --> 00:24:22,740
我所知道的数据库系统

660
00:24:22,740 --> 00:24:24,450
是在过去十年中

661
00:24:24,450 --> 00:24:25,920
从学术的角度或从

662
00:24:25,920 --> 00:24:29,190
商业的角度（例如初创企业

663
00:24:29,190 --> 00:24:31,050
系统）构建的 我所知道的没有一个系统

664
00:24:31,050 --> 00:24:32,400
已经用于多 流程

665
00:24:32,400 --> 00:24:33,430
模型，

666
00:24:33,430 --> 00:24:35,560
而不是他们使用了 Postgres 的分支，

667
00:24:35,560 --> 00:24:37,060
这是一种非常普遍的

668
00:24:37,060 --> 00:24:40,210
方法，每个人都喜欢

669
00:24:40,210 --> 00:24:41,590
有很多 Devi 系统，但他们会将

670
00:24:41,590 --> 00:24:43,660
Postgres 带到 bsd 许可证，这样你就可以

671
00:24:43,660 --> 00:24:45,400
用它做任何你想做的事，它是

672
00:24:45,400 --> 00:24:47,080


673
00:24:47,080 --> 00:24:48,880
与我的续集相比，实际上写得很好，但是你可以

674
00:24:48,880 --> 00:24:50,530
重写 Postgres 中那些

675
00:24:50,530 --> 00:24:52,540
对你的特定应用程序来说很慢的部分，

676
00:24:52,540 --> 00:24:54,790
并把它作为你的新数据库

677
00:24:54,790 --> 00:24:57,100
系统，比如 Vertica greenplum 时间尺度

678
00:24:57,100 --> 00:24:59,530
所有这些 所有这些都这样做，所以

679
00:24:59,530 --> 00:25:01,230
如果你沿着这条路走下去，它们会继承

680
00:25:01,230 --> 00:25:03,400
Postgres 上的遗留过程模型架构，

681
00:25:03,400 --> 00:25:04,840
但是

682
00:25:04,840 --> 00:25:06,040
任何从头开始编写新

683
00:25:06,040 --> 00:25:08,110
代码库的人几乎总是最终

684
00:25:08,110 --> 00:25:13,540
成为多线程的，所以

685
00:25:13,540 --> 00:25:14,880
我们今天没有时间讨论的另一件事

686
00:25:14,880 --> 00:25:16,600


687
00:25:16,600 --> 00:25:19,660
是调度我们都在谈论我们已经

688
00:25:19,660 --> 00:25:21,970
告诉我们一点关于你有

689
00:25:21,970 --> 00:25:22,960
一个调度员协调员可以

690
00:25:22,960 --> 00:25:24,670
理解我需要执行的任务是什么

691
00:25:24,670 --> 00:25:26,740
我可以使用哪些资源或

692
00:25:26,740 --> 00:25:28,690
工作人员，然后它

693
00:25:28,690 --> 00:25:30,400
可以决定您知道

694
00:25:30,400 --> 00:25:32,830
将查询拆分为多少个任务，您知道

695
00:25:32,830 --> 00:25:35,170
什么 CB 课程我们 XE 执行这些任务哪个

696
00:25:35,170 --> 00:25:36,430
线程应该为另一个线程暂停

697
00:25:36,430 --> 00:25:38,500
，然后一旦它产生

698
00:25:38,500 --> 00:25:39,880
输出 如果我们想在并行数据库系统中执行所有这些我们必须担心的任务，那么输出实际上是否正常，

699
00:25:39,880 --> 00:25:41,800


700
00:25:41,800 --> 00:25:43,180


701
00:25:43,180 --> 00:25:47,770
但您

702
00:25:47,770 --> 00:25:49,150
知道通常没有一种方法

703
00:25:49,150 --> 00:25:50,890
比另一种方法更好 最终取决于

704
00:25:50,890 --> 00:25:51,880
你工作的环境

705
00:25:51,880 --> 00:25:53,890
取决于你想要支持什么样的目标工作负载

706
00:25:53,890 --> 00:25:56,530
，但正如我

707
00:25:56,530 --> 00:25:57,760
在整个学期多次说过

708
00:25:57,760 --> 00:25:59,500
的，数据库系统总是

709
00:25:59,500 --> 00:26:00,910
不比操作系统好，所以我们总是可以

710
00:26:00,910 --> 00:26:02,140
对所有这些做出更好的决定 事情

711
00:26:02,140 --> 00:26:13,870
是的，萨迪在这个问题上是

712
00:26:13,870 --> 00:26:16,870
不是对于给定的线程，

713
00:26:16,870 --> 00:26:19,330
操作系统决定运行哪个法院不，

714
00:26:19,330 --> 00:26:21,790
这在 Linux 中的箭头测试集中称为纽曼控制，

715
00:26:21,790 --> 00:26:24,220
您可以完全

716
00:26:24,220 --> 00:26:26,110
控制知道说我的线程将运行

717
00:26:26,110 --> 00:26:29,110
在这个核心或这些核心

718
00:26:29,110 --> 00:26:31,780
上，如果您不做任何事情，操作系统将不会强迫您这样做，

719
00:26:31,780 --> 00:26:34,630
然后操作系统会尝试

720
00:26:34,630 --> 00:26:36,400
弄清楚您正在访问

721
00:26:36,400 --> 00:26:38,770
内存，而您对此有所了解

722
00:26:38,770 --> 00:26:40,750
多插槽 CPU 给出 到 CPU

723
00:26:40,750 --> 00:26:42,940
插槽，在像许多系统这样的现代

724
00:26:42,940 --> 00:26:45,070
系统中，CPU 插槽具有本地内存

725
00:26:45,070 --> 00:26:47,170
，就在它附近的暗处，因此

726
00:26:47,170 --> 00:26:48,310
如果您的线程在这里运行并且

727
00:26:48,310 --> 00:26:50,170
您正在访问另一个插槽上的内存，

728
00:26:50,170 --> 00:26:52,390
操作系统或 CPU 可以

729
00:26:52,390 --> 00:26:54,850
自动 将您迁移过来，但在

730
00:26:54,850 --> 00:26:56,440
高端系统中，我们确切地知道

731
00:26:56,440 --> 00:26:57,880
要接触哪些

732
00:26:57,880 --> 00:26:59,470


733
00:26:59,470 --> 00:27:00,640


734
00:27:00,640 --> 00:27:02,200


735
00:27:02,200 --> 00:27:04,000
数据 从这个

736
00:27:04,000 --> 00:27:05,710
内存位置，所以所有触及

737
00:27:05,710 --> 00:27:08,140
该内存位置的任务都去那里，我们可以

738
00:27:08,140 --> 00:27:10,240
自己做所有这些，我们可以

739
00:27:10,240 --> 00:27:14,560
做得比操作系统做得更好，

740
00:27:14,560 --> 00:27:15,670
所以让我们谈谈快速并行

741
00:27:15,670 --> 00:27:18,310
查询，所以丘比特有两种

742
00:27:18,310 --> 00:27:19,270
并行化我们 '将

743
00:27:19,270 --> 00:27:21,010
支持内部查询并行性和

744
00:27:21,010 --> 00:27:23,470
内部查询并行性，所以我将

745
00:27:23,470 --> 00:27:24,370
介绍这两个，但我们

746
00:27:24,370 --> 00:27:25,570
今天将花费大部分时间来

747
00:27:25,570 --> 00:27:28,300
讨论这个问题，因此内部查询

748
00:27:28,300 --> 00:27:29,620
风险 ISM 是我们实际上可以进行

749
00:27:29,620 --> 00:27:31,780
多个查询 同时做不同的

750
00:27:31,780 --> 00:27:33,850
事情，

751
00:27:33,850 --> 00:27:35,110
这将提高我们系统的吞吐量

752
00:27:35,110 --> 00:27:39,910
和延迟，然后在介绍中

753
00:27:39,910 --> 00:27:41,500
携带有效载荷来执行一个查询

754
00:27:41,500 --> 00:27:44,560
并将其分解为子任务或

755
00:27:44,560 --> 00:27:46,810
片段 并同时在不同的资源上并行运行它们，

756
00:27:46,810 --> 00:27:50,170
所以再次

757
00:27:50,170 --> 00:27:51,670
内部查询有效负载是我已经

758
00:27:51,670 --> 00:27:54,220
说过的想法是我们有多个

759
00:27:54,220 --> 00:27:56,110
请求来自我们的应用程序

760
00:27:56,110 --> 00:27:58,360
，而不是

761
00:27:58,360 --> 00:28:00,010
在单个线程上一个接一个地运行它们，我们 '要让

762
00:28:00,010 --> 00:28:01,570
多个工作线程或多个线程

763
00:28:01,570 --> 00:28:05,050
同时运行它们，然后这样我们

764
00:28:05,050 --> 00:28:07,240
就可以更快地响应您

765
00:28:07,240 --> 00:28:08,650
对应用程序的了解以及

766
00:28:08,650 --> 00:28:11,500
他们正在寻找的结果，所以如果

767
00:28:11,500 --> 00:28:13,410
我们需要执行的所有查询都是只读的

768
00:28:13,410 --> 00:28:15,430
他们不做插入更新

769
00:28:15,430 --> 00:28:17,170
或删除他们只是做

770
00:28:17,170 --> 00:28:19,930
选择语句那么这很

771
00:28:19,930 --> 00:28:23,170
容易做到因为不会

772
00:28:23,170 --> 00:28:24,310
有任何冲突不会有

773
00:28:24,310 --> 00:28:26,770
任何问题你知道我正在尝试

774
00:28:26,770 --> 00:28:27,880
更新相同的哈希 当你正在

775
00:28:27,880 --> 00:28:30,730
阅读表格时，一切都

776
00:28:30,730 --> 00:28:33,850
很好，所以这非常容易，

777
00:28:33,850 --> 00:28:35,980
但这并不总是那么常见，

778
00:28:35,980 --> 00:28:37,330
对我们来说非常困难的事情是

779
00:28:37,330 --> 00:28:38,560
，如果我们有多个线程

780
00:28:38,560 --> 00:28:41,040
更新 数据库

781
00:28:41,040 --> 00:28:43,300
，现在我们不得不

782
00:28:43,300 --> 00:28:44,800
担心我们为 B+ 树和哈希表讨论的所有并发行内容，

783
00:28:44,800 --> 00:28:47,200
但

784
00:28:47,200 --> 00:28:48,550
现在我只需要

785
00:28:48,550 --> 00:28:51,430
为实际数据本身担心这个，就像你有两个

786
00:28:51,430 --> 00:28:52,960
查询一样 同时更新同一个元组

787
00:28:52,960 --> 00:28:56,470
应该发生什么所以

788
00:28:56,470 --> 00:28:57,760
他们对你们来说是个好消息我们将

789
00:28:57,760 --> 00:28:59,080
在期中考试之后继续这样做

790
00:28:59,080 --> 00:29:00,820
因为这是一个整体

791
00:29:00,820 --> 00:29:02,590
你知道我们必须处理的蜡球

792
00:29:02,590 --> 00:29:04,409
这是超级 很难而且超级棒

793
00:29:04,409 --> 00:29:07,299
，所以我们基本上要花两个

794
00:29:07,299 --> 00:29:09,700
星期的时间来讨论这个，筋疲力尽，

795
00:29:09,700 --> 00:29:10,899
这是我非常兴奋的事情，

796
00:29:10,899 --> 00:29:12,039
就像我

797
00:29:12,039 --> 00:29:13,240
最喜欢的关于数据库系统的部分

798
00:29:13,240 --> 00:29:14,830
是他们可以在以下位置执行这些并发

799
00:29:14,830 --> 00:29:17,769
操作 同时，但它

800
00:29:17,769 --> 00:29:19,840
很难做到，所以我们会

801
00:29:19,840 --> 00:29:22,240
在期中考试之后介绍这一点，所以对于这

802
00:29:22,240 --> 00:29:24,159
门课，就像我说的，我们专注于介绍

803
00:29:24,159 --> 00:29:25,990
查询并行性，所以这

804
00:29:25,990 --> 00:29:28,000
对于

805
00:29:28,000 --> 00:29:30,909
我们有多个资源的分析查询很有用 es 或多个

806
00:29:30,909 --> 00:29:33,039
工作人员可用，我们

807
00:29:33,039 --> 00:29:35,049
会将这些查询拆分为

808
00:29:35,049 --> 00:29:37,330
片段或子任务，并同时并行运行它们，

809
00:29:37,330 --> 00:29:39,700
因此对于

810
00:29:39,700 --> 00:29:41,289
此处的讨论，我们将专注于

811
00:29:41,289 --> 00:29:43,990
计算并行性，这意味着我有

812
00:29:43,990 --> 00:29:45,149
多个工作人员 有多个

813
00:29:45,149 --> 00:29:47,769
内核可供

814
00:29:47,769 --> 00:29:51,789
我使用 我打算将它们用于同一个查询

815
00:29:51,789 --> 00:29:52,870
所以考虑我们将如何

816
00:29:52,870 --> 00:29:54,940
组织的一种方法是在我们的查询

817
00:29:54,940 --> 00:29:58,120
查询计划中我们有这些运算符

818
00:29:58,120 --> 00:29:59,409
已经讨论过他们如何拥有

819
00:29:59,409 --> 00:30:01,330
下一个功能，可以移动您

820
00:30:01,330 --> 00:30:02,529
知道您接下来要问的数据，并且它会返回

821
00:30:02,529 --> 00:30:05,470
一大块数据或单个元组，因此

822
00:30:05,470 --> 00:30:06,970
我们可以根据间隙

823
00:30:06,970 --> 00:30:09,519
生产者-消费者范式来考虑每个

824
00:30:09,519 --> 00:30:13,389
操作符 不仅是数据的生产者，

825
00:30:13,389 --> 00:30:15,039
就像如果你调用 next 一样，我会

826
00:30:15,039 --> 00:30:17,019
为你生产一些数据，但它也

827
00:30:17,019 --> 00:30:19,509
可能消耗来自

828
00:30:19,509 --> 00:30:22,240
运行在它下面的某个操作员的数据，所以我们可以

829
00:30:22,240 --> 00:30:23,139
考虑我们将如何

830
00:30:23,139 --> 00:30:25,210
组织 我们在这个 prehistor 中的查询计划 y

831
00:30:25,210 --> 00:30:27,100
客户模型，然后我们看到我们如何

832
00:30:27,100 --> 00:30:29,019
以不同的方式并行运行这些东西

833
00:30:29,019 --> 00:30:32,049
所以我要说的第一件事

834
00:30:32,049 --> 00:30:34,000
- 对于我们讨论的所有算子算法

835
00:30:34,000 --> 00:30:36,190
，它们都有并行

836
00:30:36,190 --> 00:30:38,559
版本，但它们

837
00:30:38,559 --> 00:30:41,320
会有所不同 基于您是否

838
00:30:41,320 --> 00:30:43,960
有多个线程同时更新某些

839
00:30:43,960 --> 00:30:46,299
集中式数据结构，

840
00:30:46,299 --> 00:30:48,429
就像我在并行执行联合哈希

841
00:30:48,429 --> 00:30:50,200
联合一样，我可以有多个

842
00:30:50,200 --> 00:30:52,720
线程更新并构建我的哈希

843
00:30:52,720 --> 00:30:54,340
表，然后多个线程可以

844
00:30:54,340 --> 00:30:57,340
探测该哈希表 或者我可以将

845
00:30:57,340 --> 00:30:59,350
我的输入数据分割成一个分区，我

846
00:30:59,350 --> 00:31:01,419
从我下面的操作员那里消耗

847
00:31:01,419 --> 00:31:03,909
我的输入数据，让他们每个工作在

848
00:31:03,909 --> 00:31:05,620
孤立的或个性化

849
00:31:05,620 --> 00:31:07,659
的数据块或数据分区上，

850
00:31:07,659 --> 00:31:09,100
然后现在我不需要

851
00:31:09,100 --> 00:31:10,929
协调 所有这些不同的

852
00:31:10,929 --> 00:31:14,980
工作人员同时运行 所以从

853
00:31:14,980 --> 00:31:16,030
概念上讲这是很容易

854
00:31:16,030 --> 00:31:17,200
思考的，所以这

855
00:31:17,200 --> 00:31:19,090
与我们在恩典散列分区之前讨论的相同散列图是一样的

856
00:31:19,090 --> 00:31:21,160


857
00:31:21,160 --> 00:31:24,520
对他说，在我之前说的是，我们

858
00:31:24,520 --> 00:31:26,169
将

859
00:31:26,169 --> 00:31:28,750
在构建的两侧或外部表中的输入处都有这个散列函数

860
00:31:28,750 --> 00:31:30,760
，它们会

861
00:31:30,760 --> 00:31:32,830
在这些不同的级别散列到这些桶中，

862
00:31:32,830 --> 00:31:35,740
所以现在我们想做一个连接来组合

863
00:31:35,740 --> 00:31:37,330
这些 桶我们只

864
00:31:37,330 --> 00:31:39,429
需要拥有这个你知道我们只

865
00:31:39,429 --> 00:31:41,140
检查了这个级别

866
00:31:41,140 --> 00:31:42,250
的元组和另一侧的同一级别的元组

867
00:31:42,250 --> 00:31:44,290
因为我们对它进行了分区，

868
00:31:44,290 --> 00:31:46,720
所以现在以并行运行的方式

869
00:31:46,720 --> 00:31:48,940
是超级的 很简单，我们只有一个

870
00:31:48,940 --> 00:31:52,570
工人，只是采取自己的水平，现在

871
00:31:52,570 --> 00:31:55,720
做联合，我产生输出，这样你

872
00:31:55,720 --> 00:31:56,770
就可以看到我们如何为

873
00:31:56,770 --> 00:31:58,059
我们

874
00:31:58,059 --> 00:31:59,890
在排序合并之前讨论过的所有不同的事情做任何

875
00:31:59,890 --> 00:32:01,840
特殊的事情 扫描我们可以将它分解

876
00:32:01,840 --> 00:32:04,600
并划分工作并使

877
00:32:04,600 --> 00:32:07,690
它们并行运行

878
00:32:07,690 --> 00:32:09,130
虽然现在将这些数据

879
00:32:09,130 --> 00:32:10,540
重新组合在一起以及不同的方法来

880
00:32:10,540 --> 00:32:12,010
做到这一点所以这就是我们要

881
00:32:12,010 --> 00:32:14,710
关注的问题 三种类型的内部

882
00:32:14,710 --> 00:32:16,210
查询 并行性可能是

883
00:32:16,210 --> 00:32:18,160
操作符内并行性也称为

884
00:32:18,160 --> 00:32:20,770
水平并行性互

885
00:32:20,770 --> 00:32:22,210
操作性服装内我是垂直

886
00:32:22,210 --> 00:32:24,100
并行性，然后是浓密的并行性

887
00:32:24,100 --> 00:32:25,630
，我认为这在教科书中

888
00:32:25,630 --> 00:32:26,860
只是这些其他并行性的扩展，

889
00:32:26,860 --> 00:32:28,600
但我认为值得展示

890
00:32:28,600 --> 00:32:30,820
你很快就会知道它是什么，以防你

891
00:32:30,820 --> 00:32:33,100
再次看到它，我还要说的是，对于

892
00:32:33,100 --> 00:32:34,929
所有这些方法，它们并不是

893
00:32:34,929 --> 00:32:37,299
相互排斥的意思，如果你

894
00:32:37,299 --> 00:32:38,799
想并行运行查询，你知道你

895
00:32:38,799 --> 00:32:40,150
不会选择这三个中的一个

896
00:32:40,150 --> 00:32:41,470
实际上可以将所有这些组合起来

897
00:32:41,470 --> 00:32:43,419
，这就是数据学生可以

898
00:32:43,419 --> 00:32:44,919
为你弄清楚的东西 说好的 我的

899
00:32:44,919 --> 00:32:46,360
港口看起来像这样 我的数据看起来

900
00:32:46,360 --> 00:32:49,120
像这样 我的查询看起来像这样 我可以

901
00:32:49,120 --> 00:32:50,470
使用这些技术的一些不同组合

902
00:32:50,470 --> 00:32:52,380
来获得

903
00:32:52,380 --> 00:32:56,470
你知道我的工作负载的最佳性能 所以再次让我们

904
00:32:56,470 --> 00:32:57,840
一个一个地浏览每一个

905
00:32:57,840 --> 00:33:01,179
所以在操作符内并行性

906
00:33:01,179 --> 00:33:03,220
中我们

907
00:33:03,220 --> 00:33:06,540
将把操作符分解成独立的片段

908
00:33:06,540 --> 00:33:09,669
ents 并且每个片段都将执行

909
00:33:09,669 --> 00:33:11,650
操作员希望我们对

910
00:33:11,650 --> 00:33:15,730
输入数据的某些部分执行的任何操作

911
00:33:15,730 --> 00:33:18,309


912
00:33:18,309 --> 00:33:21,040


913
00:33:21,040 --> 00:33:23,200


914
00:33:23,200 --> 00:33:24,909
他们每个人都

915
00:33:24,909 --> 00:33:27,870
将扫描表格的不同部分

916
00:33:27,870 --> 00:33:29,430
，他们

917
00:33:29,430 --> 00:33:32,550
都会将数据汇集起来，所以我们现在将

918
00:33:32,550 --> 00:33:34,770
这些数据组合到所谓的

919
00:33:34,770 --> 00:33:37,410
交换运算符中，因此更改运算符

920
00:33:37,410 --> 00:33:41,370
是一个 查询计划中的位置，

921
00:33:41,370 --> 00:33:43,700
数据系统有点像人为注入，

922
00:33:43,700 --> 00:33:45,750
因为它生成的

923
00:33:45,750 --> 00:33:47,430
查询计划说好的，这里是

924
00:33:47,430 --> 00:33:49,140
我可以拥有并行支付

925
00:33:49,140 --> 00:33:50,790
法片段的点，这里是交换

926
00:33:50,790 --> 00:33:52,080
操作数，我需要能够组合

927
00:33:52,080 --> 00:33:53,550
它们的结果 因为我

928
00:33:53,550 --> 00:33:57,120
需要一个单一的流或单一的数据数据

929
00:33:57,120 --> 00:34:00,090
流到下一个操作符

930
00:34:00,090 --> 00:34:02,250
所以交换操作符实际上是

931
00:34:02,250 --> 00:34:05,880
由我们提出火山迭代器模型的同一个人发明的

932
00:34:05,880 --> 00:34:08,070


933
00:34:08,070 --> 00:34:09,659
谈到了上一堂课的石英图

934
00:34:09,659 --> 00:34:10,830
是同一个人，他做了 B 加树

935
00:34:10,830 --> 00:34:12,570
纸或 B 但 B 加树书，

936
00:34:12,570 --> 00:34:14,550
我当时正在胡言乱语，但他

937
00:34:14,550 --> 00:34:18,480
在 1889 年 8 月 1990 年发表了一篇论文，介绍了这个

938
00:34:18,480 --> 00:34:20,040
交换运营商，这

939
00:34:20,040 --> 00:34:22,110
几乎是 同样，这里的这种方法

940
00:34:22,110 --> 00:34:23,520
是每个 Davis 正在执行的

941
00:34:23,520 --> 00:34:24,960
并行执行甚至分布式

942
00:34:24,960 --> 00:34:27,060
执行都在做类似的事情，

943
00:34:27,060 --> 00:34:28,949
尽管他们可能并不总是将其

944
00:34:28,949 --> 00:34:32,790
称为交换运算符，因此让我们

945
00:34:32,790 --> 00:34:34,620
在这里看一个真正的简单示例，因此我们

946
00:34:34,620 --> 00:34:36,210
有一个选择语句 select a

947
00:34:36,210 --> 00:34:37,949
from 从 select start from a 上

948
00:34:37,949 --> 00:34:40,649
一个值大于 99 或 99

949
00:34:40,649 --> 00:34:41,699
所以查询计划是超级简单的

950
00:34:41,699 --> 00:34:44,190
顺序扫描 a 并且我们将它

951
00:34:44,190 --> 00:34:47,520
输入到我们的过滤器运算符中以便

952
00:34:47,520 --> 00:34:49,290
并行运行我们所做的就是我们将

953
00:34:49,290 --> 00:34:52,050
除以 现在是跨不同片段的查询计划

954
00:34:52,050 --> 00:34:54,149
或使用扫描进行

955
00:34:54,149 --> 00:34:56,460
扫描并结束过滤器，然后

956
00:34:56,460 --> 00:34:58,530
我们现在将拆分数据库，

957
00:34:58,530 --> 00:34:59,910
您通常已经知道它已经

958
00:34:59,910 --> 00:35:01,650
是因为它是 已经

959
00:35:01,650 --> 00:35:03,780
分成页面，所以我们

960
00:35:03,780 --> 00:35:06,540
现在可以在给定的计划片段中

961
00:35:06,540 --> 00:35:10,140
拥有什么我们可以让它在不同页面的一侧操作

962
00:35:10,140 --> 00:35:13,950
所以上面的交换操作符

963
00:35:13,950 --> 00:35:16,170
就像任何其他操作符一样有它自己的下一个功能

964
00:35:16,170 --> 00:35:19,050
所以如果我们 做

965
00:35:19,050 --> 00:35:20,550
火山模型或迭代器模型，或者我们正在

966
00:35:20,550 --> 00:35:22,770
调用 next 并关闭交换

967
00:35:22,770 --> 00:35:24,870
操作员说我在我的操作

968
00:35:24,870 --> 00:35:26,460
员上调用 next 然后在扫描时调用 next

969
00:35:26,460 --> 00:35:28,440
然后现在我要开始敲打

970
00:35:28,440 --> 00:35:30,480
我要的数据 从

971
00:35:30,480 --> 00:35:34,170
特定页面检索，我们也对所有其他片段执行此

972
00:35:34,170 --> 00:35:35,910


973
00:35:35,910 --> 00:35:37,350
操作，它将在其单独的页面上进行操作

974
00:35:37,350 --> 00:35:39,310


975
00:35:39,310 --> 00:35:41,230
，然后交换操作员

976
00:35:41,230 --> 00:35:44,050
可以合并它

977
00:35:44,050 --> 00:35:45,490
从这三个不同

978
00:35:45,490 --> 00:35:46,810
片段中获得的数据，这三个不同的工作人员

979
00:35:46,810 --> 00:35:49,000
和 然后将它们组合成一个

980
00:35:49,000 --> 00:35:50,410
结果，然后我们将其作为

981
00:35:50,410 --> 00:35:53,260
应用程序的输出吐出，因为

982
00:35:53,260 --> 00:35:55,060
查询的最终结果始终

983
00:35:55,060 --> 00:35:56,950
需要是一个您知道我们

984
00:35:56,950 --> 00:35:58,870
不能说您的数据的单一结果 在这里和

985
00:35:58,870 --> 00:35:59,650
这里，因为他们有三个不同的

986
00:35:59,650 --> 00:36:01,390
工人，我们必须始终产生

987
00:36:01,390 --> 00:36:10,110
一个结果是的，工程师的问题

988
00:36:10,110 --> 00:36:12,610
是明年交易所如何调用它

989
00:36:12,610 --> 00:36:14,230
并行调用它们它知道

990
00:36:14,230 --> 00:36:17,650
我下面有三个片段，因此我

991
00:36:17,650 --> 00:36:19,600
需要调用下一个 所有这些并且它

992
00:36:19,600 --> 00:36:25,170
在不同的工人中解雇他们是的

993
00:36:36,360 --> 00:36:38,860
是的所以他的问题是，如果我

994
00:36:38,860 --> 00:36:40,510
在这里打电话下一次，它是如何

995
00:36:40,510 --> 00:36:43,030
渗透到这些其他人的，你

996
00:36:43,030 --> 00:36:44,440
可以在上面有一个协调员

997
00:36:44,440 --> 00:36:46,780
说，就像我知道我需要获取数据一样 来自

998
00:36:46,780 --> 00:36:47,980
所有其他人并继续

999
00:36:47,980 --> 00:36:51,510
调用下一个，直到他们没有产生任何

1000
00:36:56,820 --> 00:37:02,590
正确的结果 所以认为它就像这里的片段

1001
00:37:02,590 --> 00:37:05,170
这是

1002
00:37:05,170 --> 00:37:08,350
分开运行的，就像生产者消费者 这

1003
00:37:08,350 --> 00:37:09,790
件事是秘密说嘿给我

1004
00:37:09,790 --> 00:37:11,530
一些数据然后 他们坚持点火

1005
00:37:11,530 --> 00:37:13,030
，然后产生结果，

1006
00:37:13,030 --> 00:37:14,710
然后他们必须回来做其他事情

1007
00:37:14,710 --> 00:37:21,190
我去获取更多数据是的是的，

1008
00:37:21,190 --> 00:37:22,030
想想这些就像

1009
00:37:22,030 --> 00:37:24,700
流一样 正在产生

1010
00:37:24,700 --> 00:37:26,520
结果 推给下一个人

1011
00:37:26,520 --> 00:37:28,600
取决于它的实施方式 这

1012
00:37:28,600 --> 00:37:30,190
件事不能 我会继续推

1013
00:37:30,190 --> 00:37:31,720
数据直到有人告诉我停止或者我

1014
00:37:31,720 --> 00:37:34,510
可以在我被调用时

1015
00:37:34,510 --> 00:37:39,000
这样做 不同的系统做不同的事情 是的

1016
00:37:40,500 --> 00:37:42,090
这 问题是调用

1017
00:37:42,090 --> 00:37:44,100
像这部分这样的片段是并行的

1018
00:37:44,100 --> 00:37:45,390
是的，您是否希望它们

1019
00:37:45,390 --> 00:37:54,840
像这样并行运行，所以再次

1020
00:37:54,840 --> 00:37:56,430
像这样 他们都被

1021
00:37:56,430 --> 00:37:57,690
并行解雇 他们都在做

1022
00:37:57,690 --> 00:37:59,760
工作 同时在

1023
00:37:59,760 --> 00:38:06,810
不同的内核上同时进行 哦是的 所以这个问题

1024
00:38:06,810 --> 00:38:09,330
是我如何确保他们没有

1025
00:38:09,330 --> 00:38:11,580
阅读同一个页面 所以作为

1026
00:38:11,580 --> 00:38:13,650
查询计划的一部分 在这里有两种

1027
00:38:13,650 --> 00:38:15,210
方法可以做到这一点 你可以说这

1028
00:38:15,210 --> 00:38:17,010
是一堆提示 我需要做的工作

1029
00:38:17,010 --> 00:38:20,040
让我们说，在这种情况下，

1030
00:38:20,040 --> 00:38:21,180
第一个和第二个线程完成了

1031
00:38:21,180 --> 00:38:22,320
这些页面，他们说好吧

1032
00:38:22,320 --> 00:38:23,550
，如果下一页

1033
00:38:23,550 --> 00:38:25,830
我读对了，那么让我去排队，你就继续

1034
00:38:25,830 --> 00:38:27,420
这样做，直到 你跑了 太多页了，

1035
00:38:27,420 --> 00:38:29,910
你就停下来，或者你可以实际进行

1036
00:38:29,910 --> 00:38:31,320
预分区，我们稍后会

1037
00:38:31,320 --> 00:38:34,980
讨论你可以说

1038
00:38:34,980 --> 00:38:36,600
第一个人将在 1 2 &

1039
00:38:36,600 --> 00:38:38,520
3 上操作，第二个人将在 4 5 和 6 上操作，依此

1040
00:38:38,520 --> 00:38:40,380
类推 这只是盲目地

1041
00:38:40,380 --> 00:38:42,390
抓取不同的页面，或者你可以

1042
00:38:42,390 --> 00:38:43,710
理解语义所以

1043
00:38:43,710 --> 00:38:46,890
实际上表中的内容并说好我

1044
00:38:46,890 --> 00:38:50,580
想看看这是一个小表所以说

1045
00:38:50,580 --> 00:38:52,980
我想让一个线程处理

1046
00:38:52,980 --> 00:38:55,470
值所在的所有数据

1047
00:38:55,470 --> 00:38:56,790
不到一千，然后一个人处理所有

1048
00:38:56,790 --> 00:38:58,770
的土豆或小于 2,000 的值

1049
00:38:58,770 --> 00:39:01,080
，然后他们可能会阅读

1050
00:39:01,080 --> 00:39:02,940
同一页，但现在正在处理

1051
00:39:02,940 --> 00:39:06,420
数据的不同部分，有

1052
00:39:06,420 --> 00:39:07,700
不同的方法可以完成所有这些

1053
00:39:07,700 --> 00:39:10,050
事情 可以

1054
00:39:10,050 --> 00:39:11,190
理解，这个交换

1055
00:39:11,190 --> 00:39:13,620
操作符是一种进一步合并或

1056
00:39:13,620 --> 00:39:25,530
分解数据的方法是的，

1057
00:39:25,530 --> 00:39:28,040


1058
00:39:33,930 --> 00:39:43,450
如果排序顺序很重要

1059
00:39:43,450 --> 00:39:46,270
并且您在泰勒集群表上聚集索引，则保证我们不擅长的措辞，

1060
00:39:46,270 --> 00:39:51,160
如果这样的话

1061
00:39:51,160 --> 00:39:52,600
按照处理数据的方式很

1062
00:39:52,600 --> 00:39:54,850
重要，那么你不会想要正确地做

1063
00:39:54,850 --> 00:39:57,700
这些并行的事情，因为如果我

1064
00:39:57,700 --> 00:39:59,770
不喜欢我不能处理第二页，

1065
00:39:59,770 --> 00:40:02,350
直到处理第一页处理好

1066
00:40:02,350 --> 00:40:04,600
，无论如何都是 0 线程执行，所以我

1067
00:40:04,600 --> 00:40:05,920
不要做任何这些设置所有这些

1068
00:40:05,920 --> 00:40:07,300
线程因为这是浪费时间

1069
00:40:07,300 --> 00:40:09,940
等待你知道浪费资源做

1070
00:40:09,940 --> 00:40:11,230
一些你知道我有一件事

1071
00:40:11,230 --> 00:40:16,810
阻塞在另一件事上所以交换

1072
00:40:16,810 --> 00:40:19,990
操作员做的是基本的一个叫做

1073
00:40:19,990 --> 00:40:22,930
收集和 基本思想是，我们

1074
00:40:22,930 --> 00:40:24,430
将来自

1075
00:40:24,430 --> 00:40:25,990
不同工作线程的不同

1076
00:40:25,990 --> 00:40:28,600
结果组合起来，这些操作符正在

1077
00:40:28,600 --> 00:40:29,890
生成不同的输出，然后我们将

1078
00:40:29,890 --> 00:40:31,810
产生一个单一的输出流

1079
00:40:31,810 --> 00:40:34,390
，我们汉娜在上面，所以在我的

1080
00:40:34,390 --> 00:40:36,310
最后一个例子中，像这样 是

1081
00:40:36,310 --> 00:40:38,500
我们发送给调用该查询的客户端的输出，

1082
00:40:38,500 --> 00:40:40,600
因此

1083
00:40:40,600 --> 00:40:41,860
总是需要将其组合

1084
00:40:41,860 --> 00:40:44,800
成一个输出，

1085
00:40:44,800 --> 00:40:47,340
有时您可能想要获取

1086
00:40:47,340 --> 00:40:50,170
一堆输出流，然后

1087
00:40:50,170 --> 00:40:51,670
根据数据的外观重新排列它们

1088
00:40:51,670 --> 00:40:52,930
，然后现在将它们分发给

1089
00:40:52,930 --> 00:40:56,080
其他工作线程，所以假设

1090
00:40:56,080 --> 00:40:58,000
我正在并行执行扫描，我

1091
00:40:58,000 --> 00:40:59,170
将根据

1092
00:40:59,170 --> 00:41:00,910
我可以运行的值的范围进行划分 并行扫描

1093
00:41:00,910 --> 00:41:02,380
，然后将其通过

1094
00:41:02,380 --> 00:41:04,540
重新分区交换，然后

1095
00:41:04,540 --> 00:41:06,370
根据

1096
00:41:06,370 --> 00:41:08,830
我看到的实际值进行拆分，

1097
00:41:08,830 --> 00:41:11,260
然后最后一个是

1098
00:41:11,260 --> 00:41:13,360
在我们有单个输入流的地方进行分发，

1099
00:41:13,360 --> 00:41:15,430
然后 将划分并分发两个

1100
00:41:15,430 --> 00:41:17,860
不同的输出流，这

1101
00:41:17,860 --> 00:41:19,450
可能就是我们为宽限散列连接所做的事情

1102
00:41:19,450 --> 00:41:20,890


1103
00:41:20,890 --> 00:41:22,570


1104
00:41:22,570 --> 00:41:23,980


1105
00:41:23,980 --> 00:41:26,260
将哈希

1106
00:41:26,260 --> 00:41:29,710
桶分配给两个不同的线程，

1107
00:41:29,710 --> 00:41:31,270
所以我在这里使用的说法是，

1108
00:41:31,270 --> 00:41:32,830
这个命名法实际上是

1109
00:41:32,830 --> 00:41:36,310
续集服务器使用的，因为续集服务器

1110
00:41:36,310 --> 00:41:38,200
明确地向您显示

1111
00:41:38,200 --> 00:41:39,760
查询计划中的交换运算符及其

1112
00:41:39,760 --> 00:41:41,470
文档 所以对我来说，这是

1113
00:41:41,470 --> 00:41:42,880
最简单的推理方法

1114
00:41:42,880 --> 00:41:46,720
Oracle db2 Postgres 所有你

1115
00:41:46,720 --> 00:41:47,240
知道

1116
00:41:47,240 --> 00:41:48,950
的高端支持支付执行他们

1117
00:41:48,950 --> 00:41:50,240
都有一些看起来像交换的东西

1118
00:41:50,240 --> 00:41:52,490
，只是可能不完全使用这个

1119
00:41:52,490 --> 00:41:54,830
术语，但它是另一个所有它的

1120
00:41:54,830 --> 00:41:59,690
工作原理 同样的方式是的，

1121
00:41:59,690 --> 00:42:03,470
问题是什么是重新分区，所以

1122
00:42:03,470 --> 00:42:07,790
说我在我的查询计划中有一些关于这个的事情

1123
00:42:07,790 --> 00:42:12,710
，现在想要

1124
00:42:12,710 --> 00:42:18,500
根据值进行分组，所以

1125
00:42:18,500 --> 00:42:21,320
如果我这个交换拉出一个

1126
00:42:21,320 --> 00:42:23,390
单一的流 那么我将有一个

1127
00:42:23,390 --> 00:42:25,820
工作线程来执行该组，但也许

1128
00:42:25,820 --> 00:42:27,380
我可以做的是然后我可以

1129
00:42:27,380 --> 00:42:30,200
分开并说好如果值

1130
00:42:30,200 --> 00:42:34,760
是甚至去这个方向如果

1131
00:42:34,760 --> 00:42:37,100
值是奇数去那个方向现在 我

1132
00:42:37,100 --> 00:42:38,360
有一个单独的工作线程，可以

1133
00:42:38,360 --> 00:42:40,010
对眼睛进行分组或那些我

1134
00:42:40,010 --> 00:42:41,420
不需要坐标的事情，因为我正在

1135
00:42:41,420 --> 00:42:42,950
分组，然后我

1136
00:42:42,950 --> 00:42:44,390
在它们上方进行了另一个交换，将

1137
00:42:44,390 --> 00:42:46,430
结果组合到单个输出中，这是我采用多个的一种方式

1138
00:42:46,430 --> 00:42:47,840
流和 产生一些

1139
00:42:47,840 --> 00:42:50,540
新的其他多个屏幕，但

1140
00:42:50,540 --> 00:42:52,869
以不同的方式

1141
00:42:54,820 --> 00:42:56,540
拆分，所以让我们在这里看一个稍微复杂一点的

1142
00:42:56,540 --> 00:42:57,830
例子，所以现在

1143
00:42:57,830 --> 00:43:00,320
我们在 a 和 B 之间进行双向连接

1144
00:43:00,320 --> 00:43:03,800
，所以我们要做的第一件事

1145
00:43:03,800 --> 00:43:06,710
就是这样做 a 扫描和并行，所以我们将

1146
00:43:06,710 --> 00:43:08,570
签署这两个三个不同的 Brooker

1147
00:43:08,570 --> 00:43:11,690
线程，然后在我们的计划

1148
00:43:11,690 --> 00:43:14,750
片段中实际执行您知道

1149
00:43:14,750 --> 00:43:16,609
将执行扫描执行过滤器然后

1150
00:43:16,609 --> 00:43:19,670
他们将构建哈希表，该

1151
00:43:19,670 --> 00:43:21,890
哈希表可以是一个 在这种

1152
00:43:21,890 --> 00:43:23,390
情况下，它必须是一个全局哈希

1153
00:43:23,390 --> 00:43:25,940
表，

1154
00:43:25,940 --> 00:43:28,940
因为当我扫描它们时，我不知道表中会包含哪些值，

1155
00:43:28,940 --> 00:43:32,480
所以如果我

1156
00:43:32,480 --> 00:43:33,650
为每个片段设置不同的哈希表，

1157
00:43:33,650 --> 00:43:35,750
那么 当我做一个联合时，我必须

1158
00:43:35,750 --> 00:43:38,030
检查所有的哈希表，这

1159
00:43:38,030 --> 00:43:39,200
会很昂贵，而且会很慢，

1160
00:43:39,200 --> 00:43:41,300
所以这些都在构建相同的哈希

1161
00:43:41,300 --> 00:43:42,830
表，但是我有交换操作符

1162
00:43:42,830 --> 00:43:44,750
，基本上说为什么要等到他们

1163
00:43:44,750 --> 00:43:48,320
都更新我的哈希表时我 完成然后

1164
00:43:48,320 --> 00:43:50,630
现在做t 他对 BI 的扫描可以

1165
00:43:50,630 --> 00:43:52,160
在两个核心上运行，或者使用两个工作

1166
00:43:52,160 --> 00:43:54,050
线程，他们只是做过滤器，现在

1167
00:43:54,050 --> 00:43:55,190
他们要对数据进行分区和拆分

1168
00:43:55,190 --> 00:43:56,780
，现在他们有了自己的

1169
00:43:56,780 --> 00:43:59,690
交换操作符，然后我让我

1170
00:43:59,690 --> 00:44:01,070
做 加入并且

1171
00:44:01,070 --> 00:44:02,480
可以是一个这可以是

1172
00:44:02,480 --> 00:44:04,100
单线程的，或者我可以

1173
00:44:04,100 --> 00:44:05,960
在这个他的胡萝卜中

1174
00:44:05,960 --> 00:44:07,400
进行多线程让我们让它成为多线程所以现在我可以

1175
00:44:07,400 --> 00:44:09,170
在加入后在这个内部拆分我

1176
00:44:09,170 --> 00:44:11,300
可以让他们的不同线程现在

1177
00:44:11,300 --> 00:44:13,750
做 在这里探测分区，

1178
00:44:13,750 --> 00:44:17,600
这样你就可以看到如何将

1179
00:44:17,600 --> 00:44:18,950
这些东西组合在一起，我们可以

1180
00:44:18,950 --> 00:44:21,020
让这些不同的工作人员生成

1181
00:44:21,020 --> 00:44:23,240
这些输出，然后将这些输出拆分

1182
00:44:23,240 --> 00:44:24,620
到多个线程中，然后你可以

1183
00:44:24,620 --> 00:44:25,700
找到它们并将它们拆分

1184
00:44:25,700 --> 00:44:27,770
回来，你可以 将它们组合到这个新闻

1185
00:44:27,770 --> 00:44:30,200
巨头中，你知道

1186
00:44:30,200 --> 00:44:35,810
现在可以并行运行的树结构，所以这又是

1187
00:44:35,810 --> 00:44:37,550
操作符内部的并行性

1188
00:44:37,550 --> 00:44:40,610


1189
00:44:40,610 --> 00:44:43,370


1190
00:44:43,370 --> 00:44:46,060
。

1191
00:44:46,060 --> 00:44:48,500
在旅游运营商并行的不同片段中，

1192
00:44:48,500 --> 00:44:51,430
我们将让不同的运营商

1193
00:44:51,430 --> 00:44:55,300
同时在不同的线程中运行

1194
00:44:55,300 --> 00:44:57,650
，这也被称为垂直

1195
00:44:57,650 --> 00:44:58,910
并行，因为我们的想法是我们

1196
00:44:58,910 --> 00:45:01,550
可以为每个运营商对一棵树进行排序

1197
00:45:01,550 --> 00:45:03,020
可以让他们作为一个

1198
00:45:03,020 --> 00:45:04,280
单独的工人运行并且有馈送

1199
00:45:04,280 --> 00:45:06,290
数据你知道一个的输出被馈送

1200
00:45:06,290 --> 00:45:10,370
到另一个的输入所以

1201
00:45:10,370 --> 00:45:13,700
基本上像这样工作所以对于

1202
00:45:13,700 --> 00:45:16,010
这里的加入部分我可以让一个

1203
00:45:16,010 --> 00:45:19,220
军团一个工人做 连接正确，

1204
00:45:19,220 --> 00:45:21,020
它只是

1205
00:45:21,020 --> 00:45:23,480
从它的子操作员那里获取数据，然后

1206
00:45:23,480 --> 00:45:24,620
它进行连接，然后一旦它

1207
00:45:24,620 --> 00:45:26,930
不连接，它就会将它发送到另一个

1208
00:45:26,930 --> 00:45:29,180
工作人员，该工作人员只接受这个人

1209
00:45:29,180 --> 00:45:32,180
发送的任何内容，然后执行谓词 或者

1210
00:45:32,180 --> 00:45:35,660
做投影，然后

1211
00:45:35,660 --> 00:45:37,310
在查询计划中进一步向上发送，所以

1212
00:45:37,310 --> 00:45:39,410
现在这些人只是在旋转

1213
00:45:39,410 --> 00:45:40,730
，挖掘这是生产者

1214
00:45:40,730 --> 00:45:42,050
消费者模型这家伙在输入上旋转

1215
00:45:42,050 --> 00:45:43,460
它是 g 从它下面的人

1216
00:45:43,460 --> 00:45:45,740
开始，然后它传递与这个人匹配的任何元组，

1217
00:45:45,740 --> 00:45:47,180
然后我们旋转

1218
00:45:47,180 --> 00:45:50,840
等待，所以这又

1219
00:45:50,840 --> 00:45:51,800
是协调的东西实际上很

1220
00:45:51,800 --> 00:45:56,840
重要的地方，因为如果现在如果你知道

1221
00:45:56,840 --> 00:45:58,760
元组的数量 其他东西

1222
00:45:58,760 --> 00:46:00,230
会吐出来它会非常低

1223
00:46:00,230 --> 00:46:02,360
然后这个东西基本上会

1224
00:46:02,360 --> 00:46:03,860
坐很长时间并且什么都不做所以现在

1225
00:46:03,860 --> 00:46:05,990
我已经将任务分配给一个核心它

1226
00:46:05,990 --> 00:46:07,550
不会浪费周期因为它会

1227
00:46:07,550 --> 00:46:11,120
阻止任何传入队列但是

1228
00:46:11,120 --> 00:46:13,310
不，它占用了你知道

1229
00:46:13,310 --> 00:46:14,730
的任务，如果你的资源

1230
00:46:14,730 --> 00:46:16,650
会更好，只是

1231
00:46:16,650 --> 00:46:19,050
将这两个组合在一起并再次合并到一个

1232
00:46:19,050 --> 00:46:24,150
管道中我它们不是新的鸡肉

1233
00:46:24,150 --> 00:46:25,530
串我可以一起做水平和

1234
00:46:25,530 --> 00:46:28,200
垂直我可以有 这个

1235
00:46:28,200 --> 00:46:30,839
连接与你知道

1236
00:46:30,839 --> 00:46:33,170
与垂直平行性与这里的投影相结合，

1237
00:46:33,170 --> 00:46:35,550
但我可以

1238
00:46:35,550 --> 00:46:37,650
让多个工作人员同时做这件事，

1239
00:46:37,650 --> 00:46:42,690
好吧，

1240
00:46:42,690 --> 00:46:43,589
我正在谈论的最后一个是

1241
00:46:43,589 --> 00:46:45,329
在我看来，这又是一个密集的并行性，这

1242
00:46:45,329 --> 00:46:46,770
只是操作员间并行性的扩展，

1243
00:46:46,770 --> 00:46:48,349
它不是什么不同的东西，

1244
00:46:48,349 --> 00:46:50,640
但我再次认为教科书和

1245
00:46:50,640 --> 00:46:53,880
其他在线人都在谈论这个，所以

1246
00:46:53,880 --> 00:46:55,440
基本思想是我们只是让不同的

1247
00:46:55,440 --> 00:46:57,810
工人在不同的部分

1248
00:46:57,810 --> 00:46:59,640
进行操作 查询计划，

1249
00:46:59,640 --> 00:47:01,200
我们仍在使用交换运算符

1250
00:47:01,200 --> 00:47:03,000
- 作为在它们之间移动数据的交换，

1251
00:47:03,000 --> 00:47:05,780
假设我正在

1252
00:47:05,780 --> 00:47:08,880
三个三个表上进行非常愚蠢的四向连接，所以

1253
00:47:08,880 --> 00:47:10,890
我可以拥有的是，如果我' 我像这样组成了我的

1254
00:47:10,890 --> 00:47:13,380
联合 Algrim 我可以

1255
00:47:13,380 --> 00:47:15,780
将查询计划的这一部分作为一个片段

1256
00:47:15,780 --> 00:47:18,210
X，你不想要一个工人，然后

1257
00:47:18,210 --> 00:47:19,950
这两个连接在这里

1258
00:47:19,950 --> 00:47:21,540
在另一个工人上执行，它们只是

1259
00:47:21,540 --> 00:47:23,609
并行运行，推送数据 进入

1260
00:47:23,609 --> 00:47:25,319
我们所有的交换操作符，

1261
00:47:25,319 --> 00:47:26,460
然后我们有其他工作

1262
00:47:26,460 --> 00:47:30,240
人员再次操作，这就是为什么我说这

1263
00:47:30,240 --> 00:47:32,550
对我来说这只是

1264
00:47:32,550 --> 00:47:35,430
内部操作符并行性的扩展，因为它

1265
00:47:35,430 --> 00:47:37,290
只是不同的端口

1266
00:47:37,290 --> 00:47:43,730
同时运行的查询计划的离子 是的 是的

1267
00:47:49,280 --> 00:47:51,690
问题是，您是否认为第三个和

1268
00:47:51,690 --> 00:47:53,849
第四个词在这里的所有工作人员是否

1269
00:47:53,849 --> 00:47:55,200
停止 一两个结果的权重

1270
00:47:55,200 --> 00:47:57,800
是在这种情况下是的，

1271
00:47:57,800 --> 00:48:02,099
这取决于门 好取决于

1272
00:48:02,099 --> 00:48:03,810
交换是如何正确设置的，所以在

1273
00:48:03,810 --> 00:48:05,010
你加入任何产生的任何东西

1274
00:48:05,010 --> 00:48:07,349
之后，它就会被推给

1275
00:48:07,349 --> 00:48:09,030
这个人，它可以开始

1276
00:48:09,030 --> 00:48:10,470
与人们建立哈希表，因为它

1277
00:48:10,470 --> 00:48:14,369
出来了，你可以等你不 需要

1278
00:48:14,369 --> 00:48:16,790
不必取决于它是如何设置的，

1279
00:48:16,790 --> 00:48:19,790
是的

1280
00:48:20,510 --> 00:48:27,660
，这是一个，所以这是一个，所以问题

1281
00:48:27,660 --> 00:48:28,619
是并行在哪里，这里的并行性在哪里

1282
00:48:28,619 --> 00:48:30,359
，所以我有一个

1283
00:48:30,359 --> 00:48:32,700
正在运行这个的

1284
00:48:32,700 --> 00:48:33,869
工作人员，加入有另一个正在运行投影的工作人员，

1285
00:48:33,869 --> 00:48:36,660
所以 这东西在旋转

1286
00:48:36,660 --> 00:48:38,550
并进行连接，

1287
00:48:38,550 --> 00:48:40,080
他们会发现它找到匹配项，

1288
00:48:40,080 --> 00:48:41,839
将元组交给它，因为它的输出将

1289
00:48:41,839 --> 00:48:44,099
它交给这个人，他

1290
00:48:44,099 --> 00:48:45,869
现在可以开始进行投影了，现在

1291
00:48:45,869 --> 00:48:47,400
投影就像超级简单的操作一样

1292
00:48:47,400 --> 00:48:48,660
所以它并不那么昂贵，但这个想法

1293
00:48:48,660 --> 00:48:50,849
是，与其让这件事做

1294
00:48:50,849 --> 00:48:53,490
加入然后做投影然后

1295
00:48:53,490 --> 00:48:55,290
回去做下一个加入，而这

1296
00:48:55,290 --> 00:48:57,330
件事放手在这里做投影，

1297
00:48:57,330 --> 00:49:00,680
它可以回去做下一个

1298
00:49:16,730 --> 00:49:20,460
问题就像带着

1299
00:49:20,460 --> 00:49:25,680
这个散列回到这里 他说只有一个线程

1300
00:49:25,680 --> 00:49:26,849
可以大约在同一时间更新散列

1301
00:49:26,849 --> 00:49:28,440
不对，因为他们在谈论他们正在

1302
00:49:28,440 --> 00:49:30,210
访问不同的页面 我

1303
00:49:30,210 --> 00:49:37,380
可以并行地这样做 太好了 所以你

1304
00:49:37,380 --> 00:49:39,000
可以做每一个 一个上州相同的哈希

1305
00:49:39,000 --> 00:49:41,000
表，或者你可以做一个正确的分区

1306
00:49:41,000 --> 00:49:43,560
，现在就像现在你在做

1307
00:49:43,560 --> 00:49:46,010
多个阶段，所以现在我可以

1308
00:49:46,010 --> 00:49:49,320
有第一遍我的意思是它仍然你

1309
00:49:49,320 --> 00:49:50,550
仍然访问同一个页面，尽管

1310
00:49:50,550 --> 00:49:52,320
就像第一遍一样

1311
00:49:52,320 --> 00:49:53,790
仍然可以访问相同的哈希表，但是

1312
00:49:53,790 --> 00:49:55,170
就像第一遍一样，您让

1313
00:49:55,170 --> 00:49:56,730
不同的线程正确更新不同的

1314
00:49:56,730 --> 00:49:59,849
存储桶，但是当您对其进行哈希处理时

1315
00:49:59,849 --> 00:50:01,650
，您可能最终会进行哈希处理，您知道两个

1316
00:50:01,650 --> 00:50:02,730
线程可能会哈希到同一个存储桶中，

1317
00:50:02,730 --> 00:50:04,470
然后您 必须处理那是

1318
00:50:04,470 --> 00:50:06,570
不可避免的然后下一阶段，尽管

1319
00:50:06,570 --> 00:50:08,010
您可以并行运行但不能让

1320
00:50:08,010 --> 00:50:11,010
玉米穿过它们中的任何一个，或者

1321
00:50:11,010 --> 00:50:13,200
您可以只做你知道的一个，因为我

1322
00:50:13,200 --> 00:50:15,060
可以通过构建

1323
00:50:15,060 --> 00:50:18,440
哈希桶然后你

1324
00:50:18,440 --> 00:50:22,130


1325
00:50:22,130 --> 00:50:24,680
如果您假设您的磁盘超慢

1326
00:50:24,680 --> 00:50:26,479
并且并非所有内容都适合内存，

1327
00:50:26,479 --> 00:50:29,359
那么让不同的系统做不同的事情，然后让单个线程构建

1328
00:50:29,359 --> 00:50:29,930
哈希表

1329
00:50:29,930 --> 00:50:32,029
进行第一次扫描可能是

1330
00:50:32,029 --> 00:50:33,950
更好的方法，因为那样

1331
00:50:33,950 --> 00:50:35,359
您只是在做 尽可能多的顺序 I/O

1332
00:50:35,359 --> 00:50:37,700
并且磁盘磁头没有

1333
00:50:37,700 --> 00:50:40,099
在 SSD 上跳来跳去，您可以

1334
00:50:40,099 --> 00:50:41,630
同时执行多个请求，

1335
00:50:41,630 --> 00:50:43,069
因此您是否确实想要

1336
00:50:43,069 --> 00:50:48,519
并行构建哈希表，是的，

1337
00:50:49,869 --> 00:50:51,710
所以我说有没有 原因我们没有

1338
00:50:51,710 --> 00:50:59,029
构建哈希表，并且在这里就像

1339
00:50:59,029 --> 00:51:00,979
这样的分区就像

1340
00:51:00,979 --> 00:51:02,239
分区一样将其

1341
00:51:02,239 --> 00:51:04,309
分解然后多个流

1342
00:51:04,309 --> 00:51:06,470
现在可以进行探测所以这就

1343
00:51:06,470 --> 00:51:08,329
像是 j 只是将数据分解并没有

1344
00:51:08,329 --> 00:51:10,960
什么不同，除了分区之外

1345
00:51:10,960 --> 00:51:13,130
，这就像种族散列一样，

1346
00:51:13,130 --> 00:51:14,869
但我们仍在访问单个

1347
00:51:14,869 --> 00:51:21,739
哈希表是的，这就是

1348
00:51:21,739 --> 00:51:22,880
内部运算符和您加入的灌木之间

1349
00:51:22,880 --> 00:51:25,279
的内容，这就是 我是在对我说

1350
00:51:25,279 --> 00:51:27,469
这是同一件事，

1351
00:51:27,469 --> 00:51:29,539
bushi 操作符推动并行性

1352
00:51:29,539 --> 00:51:33,259
的定义是树的一部分是从

1353
00:51:33,259 --> 00:51:35,890
变成浓密的，因为它是如此完整的树，

1354
00:51:35,890 --> 00:51:37,609
这在我们谈论加入下一堂课时会更有意义，

1355
00:51:37,609 --> 00:51:39,079
但如果有

1356
00:51:39,079 --> 00:51:41,509
右深左吃树右，

1357
00:51:41,509 --> 00:51:43,219
但这就像一棵浓密的树，因为我

1358
00:51:43,219 --> 00:51:45,049
在这里将

1359
00:51:45,049 --> 00:51:47,299
两张桌子连接起来并在这里连接两张桌子，所以我可以

1360
00:51:47,299 --> 00:51:49,969
用一根线在这里做这个关节

1361
00:51:49,969 --> 00:51:51,920
，另一个想法我在那里做这个关节

1362
00:51:51,920 --> 00:51:53,960
我现在不需要

1363
00:51:53,960 --> 00:51:55,309
他们两个之间的角落，直到

1364
00:51:55,309 --> 00:51:58,609
我们完成交换，所以对我来说

1365
00:51:58,609 --> 00:52:01,069
是的，这与我

1366
00:52:01,069 --> 00:52:03,789
在这里展示的术中平行是一样的，

1367
00:52:03,789 --> 00:52:08,589
但数字称之为浓密的 p

1368
00:52:08,890 --> 00:52:11,569
arallels 是的，是的，我们有一个

1369
00:52:11,569 --> 00:52:15,469
运营商是它自己的，而工人这种

1370
00:52:15,469 --> 00:52:17,210
方法你看到的很像这种，

1371
00:52:17,210 --> 00:52:18,739
就像每个运营商都是自己的工人一样，

1372
00:52:18,739 --> 00:52:20,479
你看到的很像 Spark 流 Apache 刀之类的流媒体

1373
00:52:20,479 --> 00:52:22,999
系统，

1374
00:52:22,999 --> 00:52:26,869
我支持 我有点或风暴或卡夫卡

1375
00:52:26,869 --> 00:52:28,519
他们有这是他们通常使用的架构，

1376
00:52:28,519 --> 00:52:30,739
但你可以在

1377
00:52:30,739 --> 00:52:32,089
数据库系统中

1378
00:52:32,089 --> 00:52:34,369
做到这一点可能会做一些更繁琐的事情，因为你

1379
00:52:34,369 --> 00:52:35,470
想要一个你知道的单一

1380
00:52:35,470 --> 00:52:36,970
任务，你不仅要和两个男孩一起工作

1381
00:52:36,970 --> 00:52:38,410
可能在星期五尽可能地上升到

1382
00:52:38,410 --> 00:52:46,690
树中是的正确

1383
00:52:46,690 --> 00:52:50,590
是这个问题在这个交换

1384
00:52:50,590 --> 00:52:53,440
操作员这里对于这个交换它

1385
00:52:53,440 --> 00:52:55,030
可以将数据推

1386
00:52:55,030 --> 00:52:56,830
入该操作员或该操作员

1387
00:52:56,830 --> 00:52:58,660
我如何决定所以这是某事 我们

1388
00:52:58,660 --> 00:53:00,450
已纳入查询计划 你会说

1389
00:53:00,450 --> 00:53:03,310
你知道这是我想

1390
00:53:03,310 --> 00:53:05,110
在这个属性上对我的数据库进行分区 只是做

1391
00:53:05,110 --> 00:53:07,120
循环 只是做散列 我们将

1392
00:53:07,120 --> 00:53:08,950
在课堂上讨论这个问题，

1393
00:53:08,950 --> 00:53:10,930
但有 这里有一些逻辑来

1394
00:53:10,930 --> 00:53:12,760
决定它们只是帮助你决定在

1395
00:53:12,760 --> 00:53:15,280
哪里包装数据 简单的事情

1396
00:53:15,280 --> 00:53:17,730
就是循环法，

1397
00:53:19,230 --> 00:53:23,070
但实际上对于这个特定的例子，

1398
00:53:24,390 --> 00:53:26,290
你不想做循环法，

1399
00:53:26,290 --> 00:53:28,540
因为你需要知道有

1400
00:53:28,540 --> 00:53:30,400
这里有一些元组，

1401
00:53:30,400 --> 00:53:32,080
如果它与这里的

1402
00:53:32,080 --> 00:53:33,580
管相匹配，你希望它们

1403
00:53:33,580 --> 00:53:36,670
进入同一个分区，不是你知道不是

1404
00:53:36,670 --> 00:53:37,840
不同的原因，否则你

1405
00:53:37,840 --> 00:53:41,860
会有假阴性是的，我应该放在

1406
00:53:41,860 --> 00:53:44,020
下一个我会 修复幻灯片以使其

1407
00:53:44,020 --> 00:53:48,400
稍后更清楚 好吧，

1408
00:53:48,400 --> 00:53:50,550
这样就可以

1409
00:53:50,550 --> 00:53:53,860
在高层次上再次计算并行

1410
00:53:53,860 --> 00:53:56,290
性 以不同方式支持查询并行性的日常系统将支持

1411
00:53:56,290 --> 00:53:57,790


1412
00:53:57,790 --> 00:54:01,300
交换运算符，并以某种形式支持交换运算

1413
00:54:01,300 --> 00:54:03,040
符 它们的复杂程度

1414
00:54:03,040 --> 00:54:07,680
取决于系统的复杂程度，

1415
00:54:07,680 --> 00:54:10,000
尽管我提到的是

1416
00:54:10,000 --> 00:54:12,520
，如果我们在慢速磁盘上运行并且

1417
00:54:12,520 --> 00:54:14,830
所有线程都被阻塞，

1418
00:54:14,830 --> 00:54:15,970
因为它们需要的东西

1419
00:54:15,970 --> 00:54:17,110
不在缓冲区 p 中 ool，我们必须去

1420
00:54:17,110 --> 00:54:19,330
磁盘并获取它们然后所有这些额外的

1421
00:54:19,330 --> 00:54:20,650
内核和我们正在做的所有这些额外的交换

1422
00:54:20,650 --> 00:54:22,270
操作符根本不会

1423
00:54:22,270 --> 00:54:22,900
帮助我们，

1424
00:54:22,900 --> 00:54:24,310
因为我们总是会成为

1425
00:54:24,310 --> 00:54:25,930
执行该

1426
00:54:25,930 --> 00:54:28,720
请求的瓶颈，并且 所以解决

1427
00:54:28,720 --> 00:54:32,620
这个问题的方法是通过 IO 并行这里的基本

1428
00:54:32,620 --> 00:54:34,660
思想是我们将

1429
00:54:34,660 --> 00:54:37,170


1430
00:54:37,170 --> 00:54:40,390
在自己的存储设备上的不同位置分解数据库系统文件

1431
00:54:40,390 --> 00:54:42,790
和数据，我们可以用

1432
00:54:42,790 --> 00:54:44,590
我们可以拥有的一系列方式来做到这一点 多个

1433
00:54:44,590 --> 00:54:47,440
不同的数据库，你可以在

1434
00:54:47,440 --> 00:54:49,030
一天内完成每个磁盘

1435
00:54:49,030 --> 00:54:51,370
我们

1436
00:54:51,370 --> 00:54:53,500
再次

1437
00:54:53,500 --> 00:54:55,360
从续集的角度从

1438
00:54:55,360 --> 00:54:57,250
应用程序的角度为跨多个磁盘的话语消融做 1-1 关系我们不知道我们

1439
00:54:57,250 --> 00:54:58,600
不关心这一切是如何设置的

1440
00:54:58,600 --> 00:55:00,520
Danny's 并没有为我们隐藏我们

1441
00:55:00,520 --> 00:55:04,630
所有人 它的讨论是这样的

1442
00:55:04,630 --> 00:55:07,810


1443
00:55:07,810 --> 00:55:10,630


1444
00:55:10,630 --> 00:55:15,910


1445
00:55:15,910 --> 00:55:16,900
我不知道

1446
00:55:16,900 --> 00:55:19,450
它叫什么 现在它是独立磁盘的冗余突袭，

1447
00:55:19,450 --> 00:55:21,550
它曾经被称为

1448
00:55:21,550 --> 00:55:23,380
我们已经完成了廉价磁盘的速率

1449
00:55:23,380 --> 00:55:25,390
，然后磁盘制造商

1450
00:55:25,390 --> 00:55:26,740
之一使用 ray 但不喜欢 Devine

1451
00:55:26,740 --> 00:55:28,060
调用昂贵的，因为他们

1452
00:55:28,060 --> 00:55:29,290
想要我认为他们的产品

1453
00:55:29,290 --> 00:55:31,150
便宜所以他们回去并进行了更改

1454
00:55:31,150 --> 00:55:34,600
以使其独立 您看到这里的想法

1455
00:55:34,600 --> 00:55:37,090
是我们可以配置系统，

1456
00:55:37,090 --> 00:55:39,130
以便多个存储设备

1457
00:55:39,130 --> 00:55:42,070
将作为单个逻辑设备

1458
00:55:42,070 --> 00:55:44,500
出现在数据库系统中，我们可以这样

1459
00:55:44,500 --> 00:55:45,730
做 通过

1460
00:55:45,730 --> 00:55:47,440
我们主板上的一个特殊的港口控制器，我们

1461
00:55:47,440 --> 00:55:49,420
可以通过软件本身来做到这一点，

1462
00:55:49,420 --> 00:55:50,500
比如 Linux 内核支持 RAID

1463
00:55:50,500 --> 00:55:53,170
配置，或者我们有一个

1464
00:55:53,170 --> 00:55:55,600
只

1465
00:55:55,600 --> 00:55:57,190
为我们提供这个功能的存储设备，我们有一个

1466
00:55:57,190 --> 00:56:00,100
直接连接到我们系统的快速互连，

1467
00:56:00,100 --> 00:56:01,390
但主要 外卖是，在大多数

1468
00:56:01,390 --> 00:56:04,510
情况下，对于raid 设置，这

1469
00:56:04,510 --> 00:56:06,040
将完全独立于

1470
00:56:06,040 --> 00:56:07,360
数据库系统，它不知道它不

1471
00:56:07,360 --> 00:56:09,490
关心距离 在这种情况下，e 分解为

1472
00:56:09,490 --> 00:56:11,890
多个设备或我的存储被

1473
00:56:11,890 --> 00:56:13,780
破坏了所有交叉的狭缝，

1474
00:56:13,780 --> 00:56:15,460
这是

1475
00:56:15,460 --> 00:56:17,770
数据库系统管理的东西，因此它

1476
00:56:17,770 --> 00:56:19,060
可以很聪明地决定

1477
00:56:19,060 --> 00:56:21,850
如何计划其查询，因为

1478
00:56:21,850 --> 00:56:23,140
它知道如何 数据实际上被

1479
00:56:23,140 --> 00:56:24,580
放置在不同的设备上，它

1480
00:56:24,580 --> 00:56:26,460
注意到这些设备的速度，所以

1481
00:56:26,460 --> 00:56:28,270
假设我们有一个非常简单的

1482
00:56:28,270 --> 00:56:31,510
例子，我们有一个有六页的数据库，

1483
00:56:31,510 --> 00:56:34,090
所以这是一个raid 零的例子，

1484
00:56:34,090 --> 00:56:36,460
它只是被称为条带化，

1485
00:56:36,460 --> 00:56:38,440
所以 发生的事情是，当数据

1486
00:56:38,440 --> 00:56:40,000
系统创建这些页面并写入

1487
00:56:40,000 --> 00:56:42,400
它们时，这里有一些 RAID 控制器

1488
00:56:42,400 --> 00:56:44,530
然后决定或者你去这里

1489
00:56:44,530 --> 00:56:46,870
你去那里我决定它们作为

1490
00:56:46,870 --> 00:56:49,090
循环方法

1491
00:56:49,090 --> 00:56:50,890
将它写入哪个设备并且它知道 在内部它

1492
00:56:50,890 --> 00:56:52,990
有它自己的元数据说哦我需要

1493
00:56:52,990 --> 00:56:55,540
第 1 页我知道它在这个磁盘上让我

1494
00:56:55,540 --> 00:56:57,660
让我去拿它

1495
00:56:57,660 --> 00:56:59,860
但是数据又在里面它不

1496
00:56:59,860 --> 00:57:01,870
知道这些东西另一个最常见的

1497
00:57:01,870 --> 00:57:02,630
方法是做

1498
00:57:02,630 --> 00:57:05,750
Mea 环，基本上现在

1499
00:57:05,750 --> 00:57:07,220
每个设备都有每个页面的完整副本

1500
00:57:07,220 --> 00:57:08,930
，您是否有一些

1501
00:57:08,930 --> 00:57:10,490
种族编码或其他方法来

1502
00:57:10,490 --> 00:57:13,700
确保您知道一个磁盘是否

1503
00:57:13,700 --> 00:57:15,769
出现故障，您可以通过它从其他页面重新创建它

1504
00:57:15,769 --> 00:57:21,890
是的，这个问题是

1505
00:57:21,890 --> 00:57:23,559
Rea 最终写入有点慢

1506
00:57:23,559 --> 00:57:26,720
是读取 没有因为读取 我

1507
00:57:26,720 --> 00:57:29,269
可以说好吧 我假设我悬停

1508
00:57:29,269 --> 00:57:31,220
没问题 所以我可以去其中任何一个

1509
00:57:31,220 --> 00:57:33,259
现在我可以有一个线程 阅读第一

1510
00:57:33,259 --> 00:57:34,849
页没有威胁在

1511
00:57:34,849 --> 00:57:37,250
单独的设备上阅读第二页这一切都

1512
00:57:37,250 --> 00:57:39,109
很好我需要确保

1513
00:57:39,109 --> 00:57:40,789
它在所有这些设备中传播，这

1514
00:57:40,789 --> 00:57:43,490
使得它变得更加昂贵还有

1515
00:57:43,490 --> 00:57:45,529
更多这就像你需要的最基本的东西

1516
00:57:45,529 --> 00:57:46,579
raid 有更

1517
00:57:46,579 --> 00:57:49,309
复杂的设置，比如raid 5 raid 1-0

1518
00:57:49,309 --> 00:57:51,500
但是他们可以知道

1519
00:57:51,500 --> 00:57:56,150
这些不同事物的组合是的

1520
00:57:56,150 --> 00:57:59,180
循环就像你在发牌一样

1521
00:57:59,180 --> 00:58:02,029
你只是每个人都得到一张然后

1522
00:58:02,029 --> 00:58:03,589
当你到达终点时你去 背部 圆，

1523
00:58:03,589 --> 00:58:06,259
然后再做一遍 对 我不

1524
00:58:06,259 --> 00:58:07,190
知道圆石是什么 我不

1525
00:58:07,190 --> 00:58:09,200
知道罗宾代表什么 就像让

1526
00:58:09,200 --> 00:58:10,849
我像孩子一样长大 我们玩

1527
00:58:10,849 --> 00:58:13,430
游戏 你轮转 只是你知道分发

1528
00:58:13,430 --> 00:58:14,680
东西 这个顺序

1529
00:58:14,680 --> 00:58:16,460
是的，我真的这是美国的

1530
00:58:16,460 --> 00:58:22,549
口语，所以我们刚刚谈到的突袭的东西

1531
00:58:22,549 --> 00:58:24,079


1532
00:58:24,079 --> 00:58:26,420
对日常系统来说都是透明的，但我们

1533
00:58:26,420 --> 00:58:28,339
可以聪明的事情是

1534
00:58:28,339 --> 00:58:29,599
我们到目前为止讨论的分区的东西所以

1535
00:58:29,599 --> 00:58:32,029


1536
00:58:32,029 --> 00:58:34,250
数据库分区的想法是我们将

1537
00:58:34,250 --> 00:58:36,529
能够将数据库分成

1538
00:58:36,529 --> 00:58:39,019
不相交的子集，然后可以

1539
00:58:39,019 --> 00:58:42,559
将这些子集分配给离散的磁盘，然后

1540
00:58:42,559 --> 00:58:43,880
现在发生的事情是数据系统缓冲

1541
00:58:43,880 --> 00:58:45,109
池管理器知道如果我需要

1542
00:58:45,109 --> 00:58:47,930
读取页面它知道 哪个分区或

1543
00:58:47,930 --> 00:58:49,849
哪个磁盘位置将拥有

1544
00:58:49,849 --> 00:58:53,660
正在寻找的数据，因此

1545
00:58:53,660 --> 00:58:54,859


1546
00:58:54,859 --> 00:58:56,240
如果您的数据库系统

1547
00:58:56,240 --> 00:58:58,970
支持，那么进行这种分区的最简单方法您知道每个数据库

1548
00:58:58,970 --> 00:59:00,529
每个文件一个数据库一个可怕

1549
00:59:00,529 --> 00:59:02,299
数据库的任务是，您将

1550
00:59:02,299 --> 00:59:04,700
在链接中进行设置以使这些不同的

1551
00:59:04,700 --> 00:59:08,390
目录指向不同的磁盘，

1552
00:59:08,390 --> 00:59:10,279
高端系统实际上可以了解

1553
00:59:10,279 --> 00:59:11,720
那些可以为您进行映射的不同设备，

1554
00:59:11,720 --> 00:59:13,940
并且您知道并

1555
00:59:13,940 --> 00:59:16,460
在其中 作为管理员的集中位置，

1556
00:59:16,460 --> 00:59:18,530
但

1557
00:59:18,530 --> 00:59:19,640
像我的 Segal 一样快速而肮脏的事情

1558
00:59:19,640 --> 00:59:21,170
只是移动数据并

1559
00:59:21,170 --> 00:59:24,140
放入链接 Get Set 设置法律

1560
00:59:24,140 --> 00:59:25,760
文件虽然是棘手的

1561
00:59:25,760 --> 00:59:26,990
部分，但稍后讨论日志文件是什么

1562
00:59:26,990 --> 00:59:28,760
，但是 这基本上是

1563
00:59:28,760 --> 00:59:29,869
我们所做的所有更改的记录

1564
00:59:29,869 --> 00:59:32,810
，通常需要存储

1565
00:59:32,810 --> 00:59:33,980
在集中位置，但

1566
00:59:33,980 --> 00:59:35,599
如果您现在有不同的设备，

1567
00:59:35,599 --> 00:59:37,670
并且需要对日志文件进行分片，

1568
00:59:37,670 --> 00:59:39,109
这是数据系统必须为您做的

1569
00:59:39,109 --> 00:59:40,520
事情 这不是你可以

1570
00:59:40,520 --> 00:59:44,300
用文件系统伪造的东西，所以让我们快速讨论

1571
00:59:44,300 --> 00:59:46,400
一下分区，这将

1572
00:59:46,400 --> 00:59:47,540
有助于理解我们如何

1573
00:59:47,540 --> 00:59:49,640
为交易所运营商划分工作，然后

1574
00:59:49,640 --> 00:59:51,050
我们会花更多的钱 我

1575
00:59:51,050 --> 00:59:52,820
在分布式数据库中谈论这个，因为这是

1576
00:59:52,820 --> 00:59:54,940
他们利用的关键思想，

1577
00:59:54,940 --> 00:59:57,320
所以分区的思想是我们

1578
00:59:57,320 --> 00:59:59,780
想要采用单个逻辑表，

1579
00:59:59,780 --> 01:00:01,940
然后拆分为不相交的子集，

1580
01:00:01,940 --> 01:00:03,740
然后可以

1581
01:00:03,740 --> 01:00:05,240
在我们的数据库上单独存储和管理 不同的存储

1582
01:00:05,240 --> 01:00:09,109
设备，理想情况下，我们希望我们的

1583
01:00:09,109 --> 01:00:10,400
分区对应用程序是透明的，

1584
01:00:10,400 --> 01:00:12,830
我们会让您

1585
01:00:12,830 --> 01:00:14,300
告诉它您希望如何分区

1586
01:00:14,300 --> 01:00:15,500
所有系统会自动为您完成

1587
01:00:15,500 --> 01:00:18,560
，我们

1588
01:00:18,560 --> 01:00:20,839
不想有人 意识到当

1589
01:00:20,839 --> 01:00:22,760
他们编写一个关于他们的数据实际所在位置的查询时，

1590
01:00:22,760 --> 01:00:25,369


1591
01:00:25,369 --> 01:00:26,750
在分布式数据库中并不总是如此，

1592
01:00:26,750 --> 01:00:28,609
因为你很好，

1593
01:00:28,609 --> 01:00:30,020
很高兴知道如果我

1594
01:00:30,020 --> 01:00:32,390
在两个表和那个表之间的连接期间运行

1595
01:00:32,390 --> 01:00:34,040
彼此的表位于

1596
01:00:34,040 --> 01:00:35,750
远程位置，也许我不想

1597
01:00:35,750 --> 01:00:36,890
编写该后续查询，因为这

1598
01:00:36,890 --> 01:00:38,150
将花费我很长时间才能获取

1599
01:00:38,150 --> 01:00:40,670
我需要处理的数据，但是在

1600
01:00:40,670 --> 01:00:43,520
一般而言，我们不希望我们的最终用户

1601
01:00:43,520 --> 01:00:44,720
必须知道

1602
01:00:44,720 --> 01:00:48,140
数据实际存储的位置，因此

1603
01:00:48,140 --> 01:00:50,119
有两种分区方法：

1604
01:00:50,119 --> 01:00:51,650
垂直分区和

1605
01:00:51,650 --> 01:00:53,690
水平分区

1606
01:00:53,690 --> 01:00:55,220
如果您了解分布式数据库，人们最熟悉的是水平分区

1607
01:00:55,220 --> 01:00:56,420
你

1608
01:00:56,420 --> 01:00:58,040
知道分片，这就是

1609
01:00:58,040 --> 01:01:00,260
水平分区，垂直

1610
01:01:00,260 --> 01:01:01,640
分区只是

1611
01:01:01,640 --> 01:01:02,540
我们之前已经讨论过的列存储的东西，

1612
01:01:02,540 --> 01:01:05,000
所以我有一个表，它有四个

1613
01:01:05,000 --> 01:01:06,770
属性，所以我可以

1614
01:01:06,770 --> 01:01:09,290
在这里获取这个属性，然后将它存储在一个

1615
01:01:09,290 --> 01:01:11,510
单独的分区中 正确和一个

1616
01:01:11,510 --> 01:01:13,190
单独的文件在一个单独的磁盘和

1617
01:01:13,190 --> 01:01:15,380
单独的存储设备上，所以

1618
01:01:15,380 --> 01:01:17,089
如果我的大多数查询只

1619
01:01:17,089 --> 01:01:18,530
需要在这里接触数据并且这

1620
01:01:18,530 --> 01:01:20,089
三个属性之间的这些事情

1621
01:01:20,089 --> 01:01:21,950
非常快，因为我只是读取

1622
01:01:21,950 --> 01:01:24,140
比我需要的准确数据，会发生什么 但是每当我

1623
01:01:24,140 --> 01:01:25,339
有一个查询想要将这

1624
01:01:25,339 --> 01:01:26,990
两个东西结合起来就像在列存储中一样我

1625
01:01:26,990 --> 01:01:29,089
必须去获取 这些单独的

1626
01:01:29,089 --> 01:01:29,960
位置

1627
01:01:29,960 --> 01:01:31,069
并将其缝合回其

1628
01:01:31,069 --> 01:01:35,270
原始形式，因此某些系统支持

1629
01:01:35,270 --> 01:01:37,520
垂直分区作为

1630
01:01:37,520 --> 01:01:39,140
一种近似列存储的方式，

1631
01:01:39,140 --> 01:01:41,510
但它并不完全相同，

1632
01:01:41,510 --> 01:01:45,410
因为执行此操作的系统没有

1633
01:01:45,410 --> 01:01:47,059
利用像 您知道这些列

1634
01:01:47,059 --> 01:01:48,109
都是相同的值并为您提供

1635
01:01:48,109 --> 01:01:50,089
压缩，并且您知道

1636
01:01:50,089 --> 01:01:52,490
查询执行方法可以

1637
01:01:52,490 --> 01:01:54,230
优化或对列进行操作，

1638
01:01:54,230 --> 01:01:56,150
但这是让

1639
01:01:56,150 --> 01:01:57,410
您获得列的一些好处的中间点

1640
01:01:57,410 --> 01:02:00,640
存储但又不是完全一样的东西

1641
01:02:00,640 --> 01:02:02,599
，因为我说过最常见的

1642
01:02:02,599 --> 01:02:04,400
方法是进行水平

1643
01:02:04,400 --> 01:02:06,800
分区，这是我们

1644
01:02:06,800 --> 01:02:09,410
将根据

1645
01:02:09,410 --> 01:02:11,930
一些准确的总和值拆分表的地方，

1646
01:02:11,930 --> 01:02:14,390
以便单个元组的所有数据 将

1647
01:02:14,390 --> 01:02:16,010
一起位于一个

1648
01:02:16,010 --> 01:02:18,950
分区中，所以现在 ff/a 查询说 go get

1649
01:02:18,950 --> 01:02:21,410
me tuple one 我只去这个分区

1650
01:02:21,410 --> 01:02:22,849
并获取它如果我有另一个查询说

1651
01:02:22,849 --> 01:02:24,740
go give me partition or tuple 3 我去

1652
01:02:24,740 --> 01:02:26,359
这个 p  artition 来获取它，现在我可以

1653
01:02:26,359 --> 01:02:28,700
让多个 worker

1654
01:02:28,700 --> 01:02:30,559
并行运行，并且同时在这些

1655
01:02:30,559 --> 01:02:33,050
不同的分区上运行，所以

1656
01:02:33,050 --> 01:02:35,180
现在你如何进行这种水平

1657
01:02:35,180 --> 01:02:36,740
分区可以再次在这些

1658
01:02:36,740 --> 01:02:38,780
不同的系统中有所不同，我们将

1659
01:02:38,780 --> 01:02:41,180
在我们讨论更多关于这个的时候 谈论它

1660
01:02:41,180 --> 01:02:45,440
应该是两个数据库，只是为了

1661
01:02:45,440 --> 01:02:46,880
快速完成所以并行执行

1662
01:02:46,880 --> 01:02:50,930
很重要它无处不在

1663
01:02:50,930 --> 01:02:52,549
每个主要系统都将支持

1664
01:02:52,549 --> 01:02:55,490
并行执行的某些变体，这

1665
01:02:55,490 --> 01:02:56,540
是否意味着同时运行多个

1666
01:02:56,540 --> 01:02:57,920
查询或进行一个

1667
01:02:57,920 --> 01:02:59,720
查询并进行划分 它以及如何

1668
01:02:59,720 --> 01:03:01,130
划分它可能是入门运算符

1669
01:03:01,130 --> 01:03:02,690
并行性互操作并行性

1670
01:03:02,690 --> 01:03:05,660
和繁琐的东西

1671
01:03:05,660 --> 01:03:07,040
非常难以正确处理的东西是

1672
01:03:07,040 --> 01:03:08,780
我们在

1673
01:03:08,780 --> 01:03:10,670
本学期迄今为止涵盖的内容，我们将涵盖更多内容

1674
01:03:10,670 --> 01:03:12,530
稍后和继续是我们如何

1675
01:03:12,530 --> 01:03:14,540
协调多个线程，你

1676
01:03:14,540 --> 01:03:15,530
知道在同一时间操作同一件事

1677
01:03:15,530 --> 01:03:17,750
而不在任何其他两个

1678
01:03:17,750 --> 01:03:20,630
再次不正确的结果

1679
01:03:20,630 --> 01:03:22,220
当我们谈论要控制的事务时，我们将更加关注这种方式

1680
01:03:22,220 --> 01:03:25,040
，但对于只读的东西，

1681
01:03:25,040 --> 01:03:28,309
这并不是什么大

1682
01:03:28,309 --> 01:03:29,960
问题，好吧，对于并行执行的任何高级问题，

1683
01:03:29,960 --> 01:03:32,470


1684
01:03:34,849 --> 01:03:36,839
这个问题是什么 在

1685
01:03:36,839 --> 01:03:39,630
平静的排序和垂直分区之间，

1686
01:03:39,630 --> 01:03:44,039
它就像是一个是的，但你仍然可以

1687
01:03:44,039 --> 01:03:46,200
在列存储中这样做它只是

1688
01:03:46,200 --> 01:03:48,630
在高级别它是相同的但

1689
01:03:48,630 --> 01:03:52,109
通常发生的是垂直

1690
01:03:52,109 --> 01:03:53,700
分区将是你可以连续执行此操作

1691
01:03:53,700 --> 01:03:57,029
存储系统，但你会这样做，

1692
01:03:57,029 --> 01:03:58,650
但就像当你实际处理

1693
01:03:58,650 --> 01:04:00,390
查询时，你没有以一种

1694
01:04:00,390 --> 01:04:02,660
对列存储有效的方式来做，

1695
01:04:02,660 --> 01:04:04,769
就像你可能仍在做迭代器

1696
01:04:04,769 --> 01:04:07,499
模型一次一个元组，或者你

1697
01:04:07,499 --> 01:04:08,759
不这样做 不要压缩这些数据，因为你

1698
01:04:08,759 --> 01:04:09,839
知道它的值都是一样的，它只是

1699
01:04:09,839 --> 01:04:11,729
说我只是撕掉我

1700
01:04:11,729 --> 01:04:14,099


1701
01:04:14,099 --> 01:04:17,089


1702
01:04:29,839 --> 01:04:47,489


1703
01:04:47,489 --> 01:04:50,339
的属性 我呢 弄清楚在哪里

1704
01:04:50,339 --> 01:04:52,349
买这个东西 你知道这个 你

1705
01:04:52,349 --> 01:04:54,450
知道你知道架构 你

1706
01:04:54,450 --> 01:04:56,369
知道哦 我想分区我三四

1707
01:04:56,369 --> 01:04:58,380
我知道每个元组这里是它的偏移

1708
01:04:58,380 --> 01:05:00,150
量 所以我确切地知道如何拆分

1709
01:05:00,150 --> 01:05:02,069
它和 把它移到那里你

1710
01:05:02,069 --> 01:05:03,710
不会意外地把这个东西分成两半

1711
01:05:03,710 --> 01:05:06,809
你是

1712
01:05:06,809 --> 01:05:07,979
在每个小管的基础上做这个你不是盲目的

1713
01:05:07,979 --> 01:05:09,989
膝盖拿一大块数据我认为

1714
01:05:09,989 --> 01:05:12,229
这是连续内存返回页面

1715
01:05:12,229 --> 01:05:15,239
所以我知道 如何跳转到

1716
01:05:15,239 --> 01:05:16,979
我们留在这里的元组的这个偏移量

1717
01:05:16,979 --> 01:05:18,710
并对所有其他元组做同样的事情

1718
01:05:18,710 --> 01:05:21,710


1719
01:05:22,399 --> 01:05:24,719
是的问题是这个用户定义还是

1720
01:05:24,719 --> 01:05:25,649
日期系统可以

1721
01:05:25,649 --> 01:05:27,419
自动执行这通常是用户

1722
01:05:27,419 --> 01:05:29,309
定义的没有理由 它不可能是

1723
01:05:29,309 --> 01:05:31,199
自动的，所以高端系统

1724
01:05:31,199 --> 01:05:33,479
有工具来帮助解决这个问题，但

1725
01:05:33,479 --> 01:05:35,399
总的来说，这是用户定义的同样的东西

1726
01:05:35,399 --> 01:05:37,349
，这里这通常是用户

1727
01:05:37,349 --> 01:05:43,079
定义的，但不一定是

1728
01:05:43,079 --> 01:05:45,239
好的，让我们谈谈中期 那很

1729
01:05:45,239 --> 01:05:49,309
有趣 嗯 那么谁需要参加你

1730
01:05:49,309 --> 01:05:51,569


1731
01:05:51,569 --> 01:05:53,759
下周三 12 点在这个

1732
01:05:53,759 --> 01:05:56,939
房间里参加的期中考试，以及为什么这个视频将回答

1733
01:05:56,939 --> 01:06:01,739
生活中的所有问题

1734
01:06:01,739 --> 01:06:03,329


1735
01:06:03,329 --> 01:06:04,319


1736
01:06:04,319 --> 01:06:06,569
今天查询执行第二部分它

1737
01:06:06,569 --> 01:06:07,709
不会包括任何关于查询

1738
01:06:07,709 --> 01:06:09,779
优化的内容，我们在周一讨论 好的，

1739
01:06:09,779 --> 01:06:11,549
如果您需要特殊调整，

1740
01:06:11,549 --> 01:06:13,469
请尽快与我联系

1741
01:06:13,469 --> 01:06:15,359
，你们中的一些人已经这样做了，什么

1742
01:06:15,359 --> 01:06:17,749
会照顾你，然后有一个

1743
01:06:17,749 --> 01:06:20,130
如果你 转到此 URL 此处将

1744
01:06:20,130 --> 01:06:22,919
带您到与

1745
01:06:22,919 --> 01:06:24,179
我在此处展示的相同信息的内容 学习

1746
01:06:24,179 --> 01:06:26,399
指南 它还包括练习考试

1747
01:06:26,399 --> 01:06:28,589
辅助工具，我将

1748
01:06:28,589 --> 01:06:31,739
在今天晚些时候上传解决方案 我还没有 完成

1749
01:06:31,739 --> 01:06:34,919
了还可以，所以你

1750
01:06:34,919 --> 01:06:37,229
需要带上你的 CMU ID 你需要

1751
01:06:37,229 --> 01:06:38,729
带一个计算器，因为如果

1752
01:06:38,729 --> 01:06:39,929
你完成了作业，那么你

1753
01:06:39,929 --> 01:06:41,819
知道你必须做一些基本的日志来

1754
01:06:41,819 --> 01:06:43,919
计算数学，然后你' 重新允许

1755
01:06:43,919 --> 01:06:46,439
d 有一个八分之一，你知道标准的

1756
01:06:46,439 --> 01:06:47,729
八分半十一

1757
01:06:47,729 --> 01:06:51,029
张纸手写笔记双面不

1758
01:06:51,029 --> 01:06:53,279
拿你

1759
01:06:53,279 --> 01:06:55,019
和艾伦一起做的幻灯片超级小一切都

1760
01:06:55,019 --> 01:06:56,189
必须手写，你可以用

1761
01:06:56,189 --> 01:06:57,630
两面放 你想要的任何东西都

1762
01:06:57,630 --> 01:07:01,019
可以，所以这个列表

1763
01:07:01,019 --> 01:07:03,659
每年都在扩大，这是第一年不带的东西

1764
01:07:03,659 --> 01:07:05,189
20 带了一只活的动物，你去年没有这样做吗？

1765
01:07:05,189 --> 01:07:07,919
有人带来了他们的

1766
01:07:07,919 --> 01:07:09,329
湿衣服，或者两年前有一个

1767
01:07:09,329 --> 01:07:11,699
湿衣服，这有点奇怪 他

1768
01:07:11,699 --> 01:07:13,619
就像哦，哦，你有洗衣服，为什么要

1769
01:07:13,619 --> 01:07:16,169
带这个哦，因为我洗衣服

1770
01:07:16,169 --> 01:07:17,939
我没有时间把烘干机放在

1771
01:07:17,939 --> 01:07:19,679
考试前我没有把它放在那里所以他

1772
01:07:19,679 --> 01:07:22,039
开始摊开他的衣服

1773
01:07:22,039 --> 01:07:23,809
不要最后这样做

1774
01:07:23,809 --> 01:07:27,269
那个孩子带来的那一年呃我知道

1775
01:07:27,269 --> 01:07:28,739
这就像一个

1776
01:07:28,739 --> 01:07:30,749
神圣的蜡烛但是它上面有詹妮弗洛佩兹

1777
01:07:30,749 --> 01:07:31,760


1778
01:07:31,760 --> 01:07:35,210
不要带来他是内在的交流就像

1779
01:07:35,210 --> 01:07:41,240
我喜欢这种气味不要那样做好

1780
01:07:41,240 --> 01:07:42,910
吧那你呢 需要知道因为

1781
01:07:42,910 --> 01:07:44,900
你需要了解 t

1782
01:07:44,900 --> 01:07:47,570
关系模型的基础 关系代数 我们

1783
01:07:47,570 --> 01:07:49,130
专注于完整性约束

1784
01:07:49,130 --> 01:07:50,630
外键对peb

1785
01:07:50,630 --> 01:07:53,359
意味着什么 拥有一个你知道的主

1786
01:07:53,359 --> 01:07:55,849
键 辅助键意味着什么 我一些

1787
01:07:55,849 --> 01:07:58,820
关于续集现实的基本事情不会要求

1788
01:07:58,820 --> 01:08:00,920
你写 考试的原始续集，

1789
01:08:00,920 --> 01:08:03,020
因为那是 paymaster 成绩，但是

1790
01:08:03,020 --> 01:08:04,880
如果我们向您展示一个续集声明，您

1791
01:08:04,880 --> 01:08:06,829
应该了解它的作用以及

1792
01:08:06,829 --> 01:08:11,359
它的正确含义，因此将要关心的更复杂的

1793
01:08:11,359 --> 01:08:12,680
操作将

1794
01:08:12,680 --> 01:08:14,630
是连接聚合和

1795
01:08:14,630 --> 01:08:16,729
公共 表表达式你

1796
01:08:16,729 --> 01:08:19,279
不需要担心窗口函数 CTE 子

1797
01:08:19,279 --> 01:08:22,580
查询和诸如此类的存储

1798
01:08:22,580 --> 01:08:23,899
我们讨论

1799
01:08:23,899 --> 01:08:25,339
了缓冲池

1800
01:08:25,339 --> 01:08:28,819
管理的不同替换策略 LRU mru 和时钟 我们讨论

1801
01:08:28,819 --> 01:08:30,319
了

1802
01:08:30,319 --> 01:08:33,830
表示堆文件的不同方式等等 这是磁盘文件

1803
01:08:33,830 --> 01:08:35,390
，您可以是表

1804
01:08:35,390 --> 01:08:38,569
堆或链表，然后

1805
01:08:38,569 --> 01:08:39,920
对于页面布局，它可以是

1806
01:08:39,920 --> 01:08:42,080
带槽的页面或日志结构

1807
01:08:42,080 --> 01:08:44,210
再一次，这就像

1808
01:08:44,210 --> 01:08:45,979
关于一个与另一个的含义的高级问题，

1809
01:08:45,979 --> 01:08:47,660
不像你知道的那样给我画

1810
01:08:47,660 --> 01:08:49,130
一张日志结构页面是什么样子的图表，

1811
01:08:49,130 --> 01:08:50,630
或者我想要一个开槽

1812
01:08:50,630 --> 01:08:53,870
页面看起来像我们讨论过的哈希演示

1813
01:08:53,870 --> 01:08:55,810
关于静态散列和

1814
01:08:55,810 --> 01:08:58,399
动态散列方案，所以我们

1815
01:08:58,399 --> 01:09:00,380
讨论了

1816
01:09:00,380 --> 01:09:01,488
使用 Robinhood 散列和布谷鸟

1817
01:09:01,488 --> 01:09:03,080
散列的线性程序散列 这些有什么

1818
01:09:03,080 --> 01:09:05,149
含义 为什么比其他更好

1819
01:09:05,149 --> 01:09:06,770
他们试图

1820
01:09:06,770 --> 01:09:10,100
解决的问题是什么 他们更适合 读取或

1821
01:09:10,100 --> 01:09:12,469
写入动态散列方案

1822
01:09:12,469 --> 01:09:13,939
可扩展散列线性散列

1823
01:09:13,939 --> 01:09:15,469
然后桶散列也应该在

1824
01:09:15,469 --> 01:09:17,660
那里我会修复这个正确的外观如果

1825
01:09:17,660 --> 01:09:18,589
你为什么要使用其中一个

1826
01:09:18,589 --> 01:09:20,299
而不是另一个什么时候你想

1827
01:09:20,299 --> 01:09:22,009
使用一个然后加入什么时候

1828
01:09:22,009 --> 01:09:23,509
你什么时候想对索引使用一个像

1829
01:09:23,509 --> 01:09:26,920
关于这些事情的高级问题

1830
01:09:26,920 --> 01:09:29,210
我们讨论了很多关于树索引，

1831
01:09:29,210 --> 01:09:31,339
特别是 B+ 树如何进行

1832
01:09:31,339 --> 01:09:32,870
插入删除 我们将拆分

1833
01:09:32,870 --> 01:09:35,750
一些合并 B+

1834
01:09:35,750 --> 01:09:38,299
树和 B 树之间的差异再次

1835
01:09:38,299 --> 01:09:39,799
在

1836
01:09:39,799 --> 01:09:41,120
磁盘或数据库系统中的性能影响是什么，其中

1837
01:09:41,120 --> 01:09:43,279
所有内容都可能不适合内存，

1838
01:09:43,279 --> 01:09:44,630
您是如何锁定捕获和耦合的以及如何

1839
01:09:44,630 --> 01:09:45,080


1840
01:09:45,080 --> 01:09:48,290
沿着叶节点进行反转或扫描正确

1841
01:09:48,290 --> 01:09:51,080
如何处理死锁，我们再次

1842
01:09:51,080 --> 01:09:52,700
讨论了基数树或后缀

1843
01:09:52,700 --> 01:09:54,380
树会问你一些高级

1844
01:09:54,380 --> 01:09:56,300
问题，不像你所知道的给我画一张

1845
01:09:56,300 --> 01:10:00,200
精确的排序图，

1846
01:10:00,200 --> 01:10:01,220
我们谈到了不同的

1847
01:10:01,220 --> 01:10:03,440
外部到外部归并排序

1848
01:10:03,440 --> 01:10:05,060
和一般归并排序的算法所以

1849
01:10:05,060 --> 01:10:06,350
理解成本如果我给你一堆缓冲

1850
01:10:06,350 --> 01:10:08,210
页，给你一堆数据

1851
01:10:08,210 --> 01:10:10,700
页，

1852
01:10:10,700 --> 01:10:14,360
为连接它们的不同

1853
01:10:14,360 --> 01:10:15,980
变体做这种排序的成本是多少 abnesti 循环

1854
01:10:15,980 --> 01:10:17,690
再次加入潜艇散列连接

1855
01:10:17,690 --> 01:10:20,090
进行这些连接的成本是多少一种

1856
01:10:20,090 --> 01:10:21,680
比另一种更好的极端情况，

1857
01:10:21,680 --> 01:10:23,720
例如如果一切都是相同的价值

1858
01:10:23,720 --> 01:10:26,320
，那一个人会下注

1859
01:10:26,320 --> 01:10:29,420
我们如何做多个键或

1860
01:10:29,420 --> 01:10:31,220
复合键以及谁加入这些

1861
01:10:31,220 --> 01:10:35,120
事情然后我们今天完成的事情

1862
01:10:35,120 --> 01:10:36,710
将是处理模型

1863
01:10:36,710 --> 01:10:37,610


1864
01:10:37,610 --> 01:10:40,400
迭代器模型

1865
01:10:40,400 --> 01:10:41,990
与中间层灯模型的优缺点是什么？

1866
01:10:41,990 --> 01:10:44,030
矢量化模型自上而下与

1867
01:10:44,030 --> 01:10:46,070
自下而上以及不同的

1868
01:10:46,070 --> 01:10:47,360
优势是什么不同的方法

1869
01:10:47,360 --> 01:10:48,650
进行并行查询执行

1870
01:10:48,650 --> 01:10:50,630
互操作或并行

1871
01:10:50,630 --> 01:10:52,580
操作间并行和推送器

1872
01:10:52,580 --> 01:10:53,590
并行

1873
01:10:53,590 --> 01:10:59,650
好的 关于中期的任何问题 是的

1874
01:11:00,310 --> 01:11:03,080
这个问题是这个问题

1875
01:11:03,080 --> 01:11:05,810
你是什么 认为这个问题是

1876
01:11:05,810 --> 01:11:07,340
我们是否负责或任何信号 C++ 代码

1877
01:11:07,340 --> 01:11:09,110
你认为答案是正确的，

1878
01:11:09,110 --> 01:11:10,220
因为我将如何

1879
01:11:10,220 --> 01:11:12,920
为它评分正确的运行，就像 90 多岁的孩子

1880
01:11:12,920 --> 01:11:14,180
通过编译器运行它一样，我

1881
01:11:14,180 --> 01:11:19,850
不是那样做的 残忍 好吧 有其他

1882
01:11:19,850 --> 01:11:26,270
问题 是的 我亲自写

1883
01:11:26,270 --> 01:11:31,750
的 妈妈们是这样读的 不 是的

1884
01:11:31,750 --> 01:11:34,160
我会尝试在今晚晚些时候放样本

1885
01:11:34,160 --> 01:11:36,650
是的

1886
01:11:36,650 --> 01:11:39,290
如果您需要它，您是否需要携带 CMU IDE 计算器

1887
01:11:39,290 --> 01:11:41,450
，而不是您的手机，例如普通的

1888
01:11:41,450 --> 01:11:44,990
独立计算器和馅饼

1889
01:11:44,990 --> 01:11:46,520
实验室中的手写笔记 mashite 您可以

1890
01:11:46,520 --> 01:11:48,980
使用两面什么 不带

1891
01:11:48,980 --> 01:11:52,370
活体动物 蜡烛 湿衣服 您可以

1892
01:11:52,370 --> 01:11:54,560
带食物 如果你愿意，我

1893
01:11:54,560 --> 01:11:56,570
不在乎下节课我们现在正在讨论

1894
01:11:56,570 --> 01:11:58,290
根据反对意见的查询计划，

1895
01:11:58,290 --> 01:12:01,880
所以我们把它们放在一起，

1896
01:12:01,880 --> 01:12:06,720
我们会看看怎么做，好吧伙计们周一见

1897
01:12:06,720 --> 01:12:09,200


1898
01:12:19,650 --> 01:12:22,729
[音乐]

1899
01:12:29,850 --> 01:12:32,100
跳弹果冻 打一个熟食店

1900
01:12:32,100 --> 01:12:40,020
自然保佑这瓶我

1901
01:12:40,020 --> 01:12:44,790
不喝它只对你不能说不

1902
01:12:44,790 --> 01:12:47,960
知道你的手机会很痛

