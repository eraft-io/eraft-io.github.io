1
00:00:03,640 --> 00:00:13,509
[Music]

2
00:00:15,270 --> 00:00:19,420
alright let's get started okay let's uh

3
00:00:19,420 --> 00:00:21,600
again give it up for DJ top tables

4
00:00:21,600 --> 00:00:25,450
thanks boys how was your weekend good

5
00:00:25,450 --> 00:00:29,560
you know I was recruiting what TLC new

6
00:00:29,560 --> 00:00:31,480
jobs that's hard right

7
00:00:31,480 --> 00:00:33,969
actually I found out Salesforce has in

8
00:00:33,969 --> 00:00:35,739
the lobby in the main building San

9
00:00:35,739 --> 00:00:37,960
Francisco they have a DJ every morning

10
00:00:37,960 --> 00:00:40,510
and it rotates oh do you want to figure

11
00:00:40,510 --> 00:00:42,719
out how to get you that job or what

12
00:00:42,719 --> 00:00:46,839
okay yeah I guess you gonna do okay so I

13
00:00:46,839 --> 00:00:48,760
think most people are at the TOC today

14
00:00:48,760 --> 00:00:50,649
so that's why it's a low turnout which

15
00:00:50,649 --> 00:00:52,629
is unfortunate because this is one of my

16
00:00:52,629 --> 00:00:54,729
favorite lectures hash tables right so

17
00:00:54,729 --> 00:00:56,379
we have a lot to discuss let's get right

18
00:00:56,379 --> 00:00:58,389
through it so real quickly and then

19
00:00:58,389 --> 00:01:00,489
reminders for what's on the docket for

20
00:01:00,489 --> 00:01:02,889
you guys what's due project one is due

21
00:01:02,889 --> 00:01:05,920
next week on Friday at 27th at midnight

22
00:01:05,920 --> 00:01:07,570
and then homework 2 which will be

23
00:01:07,570 --> 00:01:08,979
releasing later today

24
00:01:08,979 --> 00:01:12,899
that'll be due the 30th the Monday after

25
00:01:12,899 --> 00:01:15,820
the project so any quick high-level

26
00:01:15,820 --> 00:01:21,969
questions about project one setting in

27
00:01:21,969 --> 00:01:24,159
to what the question is when with the

28
00:01:24,159 --> 00:01:25,869
autograder be released I mean so it's

29
00:01:25,869 --> 00:01:27,939
live on great scope now you can submit

30
00:01:27,939 --> 00:01:30,850
things today but we're not giving you

31
00:01:30,850 --> 00:01:32,109
the source code for the test obviously

32
00:01:32,109 --> 00:01:34,359
because that's means that the great yes

33
00:01:34,359 --> 00:01:36,969
sir it should be live if you if you

34
00:01:36,969 --> 00:01:38,229
submit it doesn't work please post on

35
00:01:38,229 --> 00:01:41,409
Piazza okay and the other high level

36
00:01:41,409 --> 00:01:47,350
questions okay so we're at now for the

37
00:01:47,350 --> 00:01:49,179
course is that we've spent the first

38
00:01:49,179 --> 00:01:51,520
couple weeks again starting at the

39
00:01:51,520 --> 00:01:52,929
bottom of the stack of a data system

40
00:01:52,929 --> 00:01:55,479
architecture and working our way up so

41
00:01:55,479 --> 00:01:57,490
we've discussed how to store data on

42
00:01:57,490 --> 00:02:00,009
disk the pages on disk then we talked

43
00:02:00,009 --> 00:02:01,719
about how to bring those pages into

44
00:02:01,719 --> 00:02:03,159
memory and our buffer pool or buffer

45
00:02:03,159 --> 00:02:06,310
cache and having having a policy decide

46
00:02:06,310 --> 00:02:07,899
when it's time to evict something and

47
00:02:07,899 --> 00:02:10,150
how to pin things when I do writes so

48
00:02:10,150 --> 00:02:11,830
now we're going above the buffer pool

49
00:02:11,830 --> 00:02:13,720
manager and we start talking about

50
00:02:13,720 --> 00:02:16,240
methods so these an access method is a

51
00:02:16,240 --> 00:02:19,180
way we're going to you know get

52
00:02:19,180 --> 00:02:21,250
essentially read or write the data that

53
00:02:21,250 --> 00:02:22,810
in our database that's stored in the

54
00:02:22,810 --> 00:02:25,330
pages that are stored out on disk so

55
00:02:25,330 --> 00:02:29,500
today we're talk about today we begin of

56
00:02:29,500 --> 00:02:31,990
a of a set of lectures we're going to do

57
00:02:31,990 --> 00:02:33,970
on data structures that we're gonna

58
00:02:33,970 --> 00:02:35,440
maintain internally inside the database

59
00:02:35,440 --> 00:02:37,180
system and we're gonna split it up

60
00:02:37,180 --> 00:02:38,710
between two discussions between hash

61
00:02:38,710 --> 00:02:42,550
tables and and order preserving trees so

62
00:02:42,550 --> 00:02:43,780
each of them have different trade-offs

63
00:02:43,780 --> 00:02:44,860
if you because you've taken an

64
00:02:44,860 --> 00:02:46,480
algorithms course by now so you

65
00:02:46,480 --> 00:02:47,890
understand the implications for both of

66
00:02:47,890 --> 00:02:49,959
these but we're gonna describe what

67
00:02:49,959 --> 00:02:52,240
matters to us in the context of database

68
00:02:52,240 --> 00:02:54,250
systems because just because you have a

69
00:02:54,250 --> 00:02:55,660
tree versus a hash table maybe

70
00:02:55,660 --> 00:02:57,850
understand how to do proofs on it or

71
00:02:57,850 --> 00:02:59,980
write algorithms to it to interact with

72
00:02:59,980 --> 00:03:01,959
it now let's talk about what what

73
00:03:01,959 --> 00:03:02,890
happens when we actually put it inside a

74
00:03:02,890 --> 00:03:04,180
database system and actually try to use

75
00:03:04,180 --> 00:03:07,840
it so data structures are used all

76
00:03:07,840 --> 00:03:09,610
throughout the database measurement

77
00:03:09,610 --> 00:03:11,910
system right for a variety of purposes

78
00:03:11,910 --> 00:03:14,380
so one thing we've talked about so far

79
00:03:14,380 --> 00:03:16,980
we turn how to use data structures for

80
00:03:16,980 --> 00:03:19,180
maintaining the internal metadata about

81
00:03:19,180 --> 00:03:20,980
what's in our database when we talk

82
00:03:20,980 --> 00:03:22,480
about there being a page table or a page

83
00:03:22,480 --> 00:03:24,250
directory and that was a hash table to

84
00:03:24,250 --> 00:03:26,800
do lookups between a hash IDE or so a

85
00:03:26,800 --> 00:03:30,790
page to a page ID to a frame or a page

86
00:03:30,790 --> 00:03:35,500
ID to some location on on disk the next

87
00:03:35,500 --> 00:03:36,640
thing we can use them for is actually

88
00:03:36,640 --> 00:03:37,989
just the core data storage of the

89
00:03:37,989 --> 00:03:40,900
database itself so what I mean by bad is

90
00:03:40,900 --> 00:03:43,000
instead of as having on order to heap a

91
00:03:43,000 --> 00:03:44,470
bunch of pages we can actually organize

92
00:03:44,470 --> 00:03:47,170
them at a higher level to be a hash

93
00:03:47,170 --> 00:03:49,540
table or a B+ tree or tree data

94
00:03:49,540 --> 00:03:52,420
structure and have the the values in in

95
00:03:52,420 --> 00:03:54,100
the data structure actually be tuples

96
00:03:54,100 --> 00:03:56,709
so this is very common in a lot of

97
00:03:56,709 --> 00:03:59,080
systems like like memcache for example

98
00:03:59,080 --> 00:04:00,670
essentially a john is a giant hash table

99
00:04:00,670 --> 00:04:03,610
or my Seco in a DDS engine is just a B+

100
00:04:03,610 --> 00:04:04,810
tree where they store the tuples

101
00:04:04,810 --> 00:04:06,640
themselves inside of the side of the

102
00:04:06,640 --> 00:04:09,519
leaf nodes of the tree we can also use

103
00:04:09,519 --> 00:04:11,560
data structures to maintain temporary

104
00:04:11,560 --> 00:04:13,540
data so this would be like if we're

105
00:04:13,540 --> 00:04:15,970
running a query and we need to compute

106
00:04:15,970 --> 00:04:17,529
something very efficiently we could

107
00:04:17,529 --> 00:04:19,200
build a data structure on the fly

108
00:04:19,200 --> 00:04:21,160
populated with whatever data we need

109
00:04:21,160 --> 00:04:23,470
finished executing the query and then

110
00:04:23,470 --> 00:04:24,940
this throw away that data structure and

111
00:04:24,940 --> 00:04:27,310
be done with it and the last one that's

112
00:04:27,310 --> 00:04:27,880
why you

113
00:04:27,880 --> 00:04:29,470
you're most familiar with is using these

114
00:04:29,470 --> 00:04:32,020
data structures for table indexes right

115
00:04:32,020 --> 00:04:34,270
essentially building a glossary over

116
00:04:34,270 --> 00:04:37,000
keys inside of our tuples and allows how

117
00:04:37,000 --> 00:04:38,500
to do you know quick lookups to find

118
00:04:38,500 --> 00:04:40,690
individual elements that we want rather

119
00:04:40,690 --> 00:04:41,860
than having to do a sequential scan

120
00:04:41,860 --> 00:04:44,050
throughout the entire database so for

121
00:04:44,050 --> 00:04:46,060
all these purpose again you need good

122
00:04:46,060 --> 00:04:48,330
data structures to do all these things

123
00:04:48,330 --> 00:04:50,770
so the things we want to care about how

124
00:04:50,770 --> 00:04:53,830
we design our data structures is is the

125
00:04:53,830 --> 00:04:56,110
two following things so the first is

126
00:04:56,110 --> 00:04:57,010
were to carry out what the data

127
00:04:57,010 --> 00:04:59,230
organization is we need how are we gonna

128
00:04:59,230 --> 00:05:01,840
represent the key value pairs are the

129
00:05:01,840 --> 00:05:03,190
elements of the data that we're storing

130
00:05:03,190 --> 00:05:05,530
in either in memory or on pages that

131
00:05:05,530 --> 00:05:07,390
were storing on disk and we do this in

132
00:05:07,390 --> 00:05:09,850
an efficient way that can support fast

133
00:05:09,850 --> 00:05:12,610
reads and writes without having to your

134
00:05:12,610 --> 00:05:14,430
major overhaul or maybe maybe

135
00:05:14,430 --> 00:05:16,090
restructuring of the entire data

136
00:05:16,090 --> 00:05:19,810
structure every single time the second

137
00:05:19,810 --> 00:05:21,340
issue is that how we're going to allow

138
00:05:21,340 --> 00:05:23,260
multiple threads to access our data

139
00:05:23,260 --> 00:05:24,730
structure or multiple queries access to

140
00:05:24,730 --> 00:05:26,770
the our data structure at the same time

141
00:05:26,770 --> 00:05:29,470
without causing any physical violations

142
00:05:29,470 --> 00:05:31,000
to the eternal representation of the

143
00:05:31,000 --> 00:05:33,670
data so what I mean by that is we don't

144
00:05:33,670 --> 00:05:36,250
want to have maybe one thread update a

145
00:05:36,250 --> 00:05:37,810
memory address while another thread it's

146
00:05:37,810 --> 00:05:39,520
reading that address and then they see

147
00:05:39,520 --> 00:05:41,530
some torn white or some corrupt version

148
00:05:41,530 --> 00:05:42,940
of that address and now that points to

149
00:05:42,940 --> 00:05:45,040
some invalid page or installed invalid

150
00:05:45,040 --> 00:05:46,810
memory location where we end up

151
00:05:46,810 --> 00:05:49,780
producing incorrect results so we'll see

152
00:05:49,780 --> 00:05:52,180
how we actually handle this we'll talk a

153
00:05:52,180 --> 00:05:54,910
little bit long as we go along today but

154
00:05:54,910 --> 00:05:56,590
we'll spend a whole lecture while

155
00:05:56,590 --> 00:05:58,120
discussing how to do concurrency control

156
00:05:58,120 --> 00:06:00,550
inside of indexes inside of these data

157
00:06:00,550 --> 00:06:02,080
structures but for our purposes today

158
00:06:02,080 --> 00:06:03,130
but you sort of simplify the discussion

159
00:06:03,130 --> 00:06:04,990
just assume we only have a single thread

160
00:06:04,990 --> 00:06:06,910
and because this is going to matter

161
00:06:06,910 --> 00:06:08,020
later on also to when we talk about

162
00:06:08,020 --> 00:06:11,140
transactions because the type of things

163
00:06:11,140 --> 00:06:12,850
we'll talk about here we'll use latches

164
00:06:12,850 --> 00:06:14,140
to protect the physical data structure

165
00:06:14,140 --> 00:06:17,020
that prevents from again reading invalid

166
00:06:17,020 --> 00:06:18,190
memory addresses or invalid page

167
00:06:18,190 --> 00:06:20,050
locations there's also a higher level

168
00:06:20,050 --> 00:06:21,880
concept of what's the logical

169
00:06:21,880 --> 00:06:24,100
correctness of our data structure that

170
00:06:24,100 --> 00:06:25,360
we need to care about as well and

171
00:06:25,360 --> 00:06:27,430
that'll come later on in the semester so

172
00:06:27,430 --> 00:06:29,020
it says what I mean by bad is to say I

173
00:06:29,020 --> 00:06:31,900
have an index I delete a key if I come

174
00:06:31,900 --> 00:06:33,460
back Mike my thread comes back and tries

175
00:06:33,460 --> 00:06:35,260
to retrieve that key again I shouldn't

176
00:06:35,260 --> 00:06:36,610
get it because I know it's been deleted

177
00:06:36,610 --> 00:06:38,410
even though the physical bit still may

178
00:06:38,410 --> 00:06:40,930
be there because I I'll do some

179
00:06:40,930 --> 00:06:41,620
background garbage

180
00:06:41,620 --> 00:06:44,380
to clean up later on but logically Mikey

181
00:06:44,380 --> 00:06:45,520
should be gone even though physically

182
00:06:45,520 --> 00:06:47,620
it's not so that this topic is very

183
00:06:47,620 --> 00:06:49,389
complicated and so we'll touch on a

184
00:06:49,389 --> 00:06:50,680
little bit today but mostly care about

185
00:06:50,680 --> 00:06:53,440
the physical the physical integrity of

186
00:06:53,440 --> 00:06:54,490
the data structure rather than the

187
00:06:54,490 --> 00:06:59,470
logical one okay today again we're going

188
00:06:59,470 --> 00:07:03,160
to focus on hash tables so a hash table

189
00:07:03,160 --> 00:07:05,500
is a abstract data type that we're going

190
00:07:05,500 --> 00:07:08,260
to use to provide a unordered

191
00:07:08,260 --> 00:07:10,990
associative array implementation or API

192
00:07:10,990 --> 00:07:13,030
and all that means that we're able to

193
00:07:13,030 --> 00:07:16,770
map arbitrary keys to arbitrary values

194
00:07:16,770 --> 00:07:18,820
all right there's no ordering to this

195
00:07:18,820 --> 00:07:21,130
thing like we're gonna see in trees and

196
00:07:21,130 --> 00:07:22,419
so the way we're gonna be able to do

197
00:07:22,419 --> 00:07:23,979
this these fast look ups to find

198
00:07:23,979 --> 00:07:25,600
elements that we want is that we're

199
00:07:25,600 --> 00:07:27,760
gonna use a hash function that's gonna

200
00:07:27,760 --> 00:07:30,130
take in our key and then compute some

201
00:07:30,130 --> 00:07:34,060
offset in some way to some location in

202
00:07:34,060 --> 00:07:36,729
my array and that's gonna tell me either

203
00:07:36,729 --> 00:07:39,400
exactly the element looking for or I can

204
00:07:39,400 --> 00:07:41,320
roughly look around close to by where

205
00:07:41,320 --> 00:07:43,690
I'll and after I use my hash function to

206
00:07:43,690 --> 00:07:45,070
find the thing that I'm looking for so

207
00:07:45,070 --> 00:07:47,320
the hash function isn't always gonna get

208
00:07:47,320 --> 00:07:48,910
us exactly where we want but at least

209
00:07:48,910 --> 00:07:50,950
get us in the right location and we know

210
00:07:50,950 --> 00:07:52,330
how to then look around to find the

211
00:07:52,330 --> 00:07:54,820
thing that we are looking for so again

212
00:07:54,820 --> 00:07:56,320
so this none of this should be new you

213
00:07:56,320 --> 00:07:58,180
should all take an algorithms class so

214
00:07:58,180 --> 00:07:59,889
the space complexity in the worst case

215
00:07:59,889 --> 00:08:03,940
of a hash table is is Big O n that means

216
00:08:03,940 --> 00:08:05,680
that we for every single key we want to

217
00:08:05,680 --> 00:08:09,490
store we least have one one entry for it

218
00:08:09,490 --> 00:08:10,990
in our hash table so to allocate that

219
00:08:10,990 --> 00:08:13,570
amount of memory amount of space the

220
00:08:13,570 --> 00:08:14,979
operational complexity is interesting

221
00:08:14,979 --> 00:08:17,560
because on average we're gonna get o one

222
00:08:17,560 --> 00:08:20,710
lookups meaning we in one step in

223
00:08:20,710 --> 00:08:22,419
constant time you can find exactly the

224
00:08:22,419 --> 00:08:24,910
thing that we're looking for worst case

225
00:08:24,910 --> 00:08:26,800
scenario and we'll see why this happens

226
00:08:26,800 --> 00:08:29,169
when we in a few seconds the worst case

227
00:08:29,169 --> 00:08:32,080
scenario will get Big O n meaning we'll

228
00:08:32,080 --> 00:08:33,610
have to do a squinter scan or a linear

229
00:08:33,610 --> 00:08:35,979
search to find to look every single

230
00:08:35,979 --> 00:08:37,570
possible key to find that the key that

231
00:08:37,570 --> 00:08:39,729
we're looking for so you may be thinking

232
00:08:39,729 --> 00:08:42,130
alright this this is great any hash

233
00:08:42,130 --> 00:08:43,450
function or any hash table will do

234
00:08:43,450 --> 00:08:45,580
because I'm always gonna get o 1 for the

235
00:08:45,580 --> 00:08:47,589
most part in practice even though this

236
00:08:47,589 --> 00:08:49,900
is super fast in the real world where

237
00:08:49,900 --> 00:08:52,030
money's involved constant factors

238
00:08:52,030 --> 00:08:54,339
actually matter a lot and so we'll see

239
00:08:54,339 --> 00:08:55,450
this when we just look at

240
00:08:55,450 --> 00:08:57,790
functions right hash functions what we

241
00:08:57,790 --> 00:08:59,890
you know sometimes it'll be it would

242
00:08:59,890 --> 00:09:01,360
still be super fast but there'll be some

243
00:09:01,360 --> 00:09:02,650
hash function that'll be twice as fast

244
00:09:02,650 --> 00:09:03,970
or three times as fast as other hash

245
00:09:03,970 --> 00:09:05,860
functions so you may say all right for

246
00:09:05,860 --> 00:09:07,720
one hashing who cares but if now I'm

247
00:09:07,720 --> 00:09:09,970
hashing a billion things and my crappy

248
00:09:09,970 --> 00:09:11,920
hash function takes a second slower than

249
00:09:11,920 --> 00:09:13,030
the fastest one

250
00:09:13,030 --> 00:09:14,740
now that's I'm spending a billion

251
00:09:14,740 --> 00:09:17,020
seconds to do this lookup so when

252
00:09:17,020 --> 00:09:18,520
there's real money involved when we're

253
00:09:18,520 --> 00:09:20,410
looking at large-scale the constant

254
00:09:20,410 --> 00:09:21,880
factors actually matter when you take

255
00:09:21,880 --> 00:09:23,380
your algorithms class there's like oh

256
00:09:23,380 --> 00:09:25,060
one we don't care about anything else

257
00:09:25,060 --> 00:09:27,340
the constants don't matter in our world

258
00:09:27,340 --> 00:09:30,460
it does all right so let's look at the

259
00:09:30,460 --> 00:09:31,930
most simplest hash table you could ever

260
00:09:31,930 --> 00:09:35,320
build right and all it is is just a a

261
00:09:35,320 --> 00:09:37,270
giant array which is now like a big

262
00:09:37,270 --> 00:09:39,070
chunk of memory and then we're gonna say

263
00:09:39,070 --> 00:09:42,660
that every single offset in our array

264
00:09:42,660 --> 00:09:46,240
corresponds to a given element and so

265
00:09:46,240 --> 00:09:48,490
for this to work we're gonna assume that

266
00:09:48,490 --> 00:09:50,230
we know exactly the number of keys are

267
00:09:50,230 --> 00:09:52,120
gonna have ahead of time and we know

268
00:09:52,120 --> 00:09:54,160
exactly what what there with the reduced

269
00:09:54,160 --> 00:09:55,510
we shouldn't their values are with what

270
00:09:55,510 --> 00:09:58,660
their actual values are right so now to

271
00:09:58,660 --> 00:10:01,390
find any key in my hash table I just

272
00:10:01,390 --> 00:10:04,990
take the take a hash on the key mod it

273
00:10:04,990 --> 00:10:06,580
by the number of elements that I have

274
00:10:06,580 --> 00:10:09,040
and then that's going to get me to some

275
00:10:09,040 --> 00:10:11,080
offset and this is exactly the thing

276
00:10:11,080 --> 00:10:15,610
that I'm looking for so let's look at

277
00:10:15,610 --> 00:10:16,630
and see how this works so let's say that

278
00:10:16,630 --> 00:10:21,010
and we have three keys ABCD de F X Y Z

279
00:10:21,010 --> 00:10:23,530
so again I can just take this thing ABCD

280
00:10:23,530 --> 00:10:26,950
ABC hash it and then that'll tell me I

281
00:10:26,950 --> 00:10:29,320
know I'm at offset zero is exactly the

282
00:10:29,320 --> 00:10:32,410
thing I'm looking for so this is not

283
00:10:32,410 --> 00:10:34,270
exactly what our hash table is actually

284
00:10:34,270 --> 00:10:35,440
could look like if this is just storing

285
00:10:35,440 --> 00:10:37,690
the original keys and practice what

286
00:10:37,690 --> 00:10:38,740
we're gonna need to have is actually

287
00:10:38,740 --> 00:10:41,440
store pointers to where the original you

288
00:10:41,440 --> 00:10:42,400
know some other location where that

289
00:10:42,400 --> 00:10:44,710
original keys is located again think of

290
00:10:44,710 --> 00:10:47,020
this like a table index I don't want to

291
00:10:47,020 --> 00:10:48,550
store the keys maybe in might my hash

292
00:10:48,550 --> 00:10:50,410
table I want to store it a pointer to

293
00:10:50,410 --> 00:10:54,440
where the key is found all right

294
00:10:54,440 --> 00:10:56,329
so what are some problems to be

295
00:10:56,329 --> 00:10:59,060
sometimes we made with this kind of hash

296
00:10:59,060 --> 00:11:05,800
table yes in the back

297
00:11:05,889 --> 00:11:07,790
correctly you say that we know the

298
00:11:07,790 --> 00:11:10,040
number elements ahead of time in the

299
00:11:10,040 --> 00:11:11,000
first place that's one

300
00:11:11,000 --> 00:11:17,060
what's the second assumption because all

301
00:11:17,060 --> 00:11:18,529
the batteries are near each other in the

302
00:11:18,529 --> 00:11:20,149
cache that does for this purpose that

303
00:11:20,149 --> 00:11:24,620
doesn't matter here but he says there's

304
00:11:24,620 --> 00:11:26,360
no collision between keys so what is a

305
00:11:26,360 --> 00:11:28,209
collision

306
00:11:28,209 --> 00:11:30,079
he says the hash in the same slot

307
00:11:30,079 --> 00:11:32,509
exactly right so this really simple hash

308
00:11:32,509 --> 00:11:34,579
table this is actually the fastest hash

309
00:11:34,579 --> 00:11:36,740
table you could ever possibly build but

310
00:11:36,740 --> 00:11:38,180
you have to make these assumptions in

311
00:11:38,180 --> 00:11:39,949
order to make to work right so the first

312
00:11:39,949 --> 00:11:41,480
is that as he said we need to know

313
00:11:41,480 --> 00:11:42,920
exactly the number of elements that we

314
00:11:42,920 --> 00:11:45,050
had ahead of time so we know exactly how

315
00:11:45,050 --> 00:11:46,819
many slots we want to allocate in our

316
00:11:46,819 --> 00:11:49,550
array and in practice that's not always

317
00:11:49,550 --> 00:11:51,800
going to be the case all right if I'm

318
00:11:51,800 --> 00:11:54,139
building a I'm using my hash table as a

319
00:11:54,139 --> 00:11:56,870
hash index am I on a table when I create

320
00:11:56,870 --> 00:11:58,189
the table I don't have any I don't have

321
00:11:58,189 --> 00:11:59,569
any data in there in the first place and

322
00:11:59,569 --> 00:12:01,730
as I started inserting things then the

323
00:12:01,730 --> 00:12:04,029
number of slots I need actually grows

324
00:12:04,029 --> 00:12:06,589
the other assumption that we mixed was

325
00:12:06,589 --> 00:12:08,389
that we said every hash or every key is

326
00:12:08,389 --> 00:12:09,529
unique and that's what he that's what

327
00:12:09,529 --> 00:12:10,970
he's saying that there's no collision so

328
00:12:10,970 --> 00:12:11,959
we're assuming that every time we hash

329
00:12:11,959 --> 00:12:14,930
it it's always gonna land into a unique

330
00:12:14,930 --> 00:12:16,939
slot for that one key and only that key

331
00:12:16,939 --> 00:12:19,100
ever to be able to exactly find the

332
00:12:19,100 --> 00:12:22,100
thing that we're looking for and so

333
00:12:22,100 --> 00:12:24,380
because we know all the keys ahead of

334
00:12:24,380 --> 00:12:26,509
time and because we know that they're

335
00:12:26,509 --> 00:12:29,839
unique when we hash them this is using

336
00:12:29,839 --> 00:12:31,660
what is called a perfect hash function

337
00:12:31,660 --> 00:12:33,949
so a perfect hash function is like this

338
00:12:33,949 --> 00:12:35,779
if theoretical thing it exists in the

339
00:12:35,779 --> 00:12:37,399
research literature but in practice

340
00:12:37,399 --> 00:12:39,290
nobody actually does this because it's

341
00:12:39,290 --> 00:12:40,519
impractical you can't actually do this

342
00:12:40,519 --> 00:12:42,649
and a perfect hash function just means

343
00:12:42,649 --> 00:12:44,540
that if I have two keys that are not

344
00:12:44,540 --> 00:12:47,059
they're not equivalent then whatever

345
00:12:47,059 --> 00:12:50,360
hash I generate for them is also not

346
00:12:50,360 --> 00:12:52,519
gonna be equivalent so for every unique

347
00:12:52,519 --> 00:12:54,680
key I generate an exactly unique hash

348
00:12:54,680 --> 00:12:57,439
value and again you can't actually do

349
00:12:57,439 --> 00:12:58,939
that there's no magic hash function that

350
00:12:58,939 --> 00:13:01,309
exists today that can guarantee this the

351
00:13:01,309 --> 00:13:02,449
way you would actually implement a

352
00:13:02,449 --> 00:13:03,649
perfect hash function is actually use

353
00:13:03,649 --> 00:13:06,620
another hash table to map a key to

354
00:13:06,620 --> 00:13:07,680
another you know

355
00:13:07,680 --> 00:13:09,540
the hash value which is kind of you know

356
00:13:09,540 --> 00:13:10,860
stupid cuz now you have a hash table for

357
00:13:10,860 --> 00:13:13,110
your hash table it's so nobody actually

358
00:13:13,110 --> 00:13:16,529
does this in practice so the thing that

359
00:13:16,529 --> 00:13:17,580
we're gonna talk about today is how do

360
00:13:17,580 --> 00:13:18,810
we actually build a hash table in the

361
00:13:18,810 --> 00:13:20,490
real world to not have to make these

362
00:13:20,490 --> 00:13:23,010
assumptions and be able to use them in a

363
00:13:23,010 --> 00:13:26,550
database system so when people say I

364
00:13:26,550 --> 00:13:29,040
have a hash table they essentially mean

365
00:13:29,040 --> 00:13:31,020
it's it's a data structure comprised of

366
00:13:31,020 --> 00:13:31,820
two parts

367
00:13:31,820 --> 00:13:35,250
the first is the hash function which is

368
00:13:35,250 --> 00:13:37,320
a way to take any arbitrary key and Matt

369
00:13:37,320 --> 00:13:40,500
you know a map it to a integer value in

370
00:13:40,500 --> 00:13:43,620
a smaller domain right so I can take any

371
00:13:43,620 --> 00:13:45,240
string and the integer and you float

372
00:13:45,240 --> 00:13:47,010
doesn't matter I throw it to my hash

373
00:13:47,010 --> 00:13:48,300
function and it's gonna produce either a

374
00:13:48,300 --> 00:13:52,170
32-bit or 64-bit hash unique hash value

375
00:13:52,170 --> 00:13:54,240
integer or not unique so I hash hash

376
00:13:54,240 --> 00:13:57,360
integer so there's gonna be this big

377
00:13:57,360 --> 00:13:59,130
trade off and and what kind of hash

378
00:13:59,130 --> 00:14:01,350
function we're gonna use between how

379
00:14:01,350 --> 00:14:03,720
fast it is and the collision rate

380
00:14:03,720 --> 00:14:06,270
because again if we have different keys

381
00:14:06,270 --> 00:14:08,760
mapped to the same slot that's a

382
00:14:08,760 --> 00:14:10,110
collision and now we have to deal with

383
00:14:10,110 --> 00:14:12,870
that in our hashing scheme so what's the

384
00:14:12,870 --> 00:14:15,110
fastest hash function I could ever build

385
00:14:15,110 --> 00:14:19,290
with that is mod prime number even

386
00:14:19,290 --> 00:14:25,350
faster with that he said that value

387
00:14:25,350 --> 00:14:26,459
itself you're close but what does that

388
00:14:26,459 --> 00:14:27,720
mean if I have a string how do I return

389
00:14:27,720 --> 00:14:29,130
back that value and then put it into my

390
00:14:29,130 --> 00:14:36,270
slot even faster there's bits of memory

391
00:14:36,270 --> 00:14:40,500
to give it if it's a large string he

392
00:14:40,500 --> 00:14:42,709
said mod if there's a mod nur yes

393
00:14:42,709 --> 00:14:47,070
constant one right no matter what key

394
00:14:47,070 --> 00:14:48,630
you give me I return back the number one

395
00:14:48,630 --> 00:14:50,730
that's gonna be super fast because

396
00:14:50,730 --> 00:14:51,959
that's gonna be on the stack that's

397
00:14:51,959 --> 00:14:53,880
gonna be impossibly fast but your

398
00:14:53,880 --> 00:14:56,160
collision rate is because it always goes

399
00:14:56,160 --> 00:14:59,430
to the same slot so in the other end of

400
00:14:59,430 --> 00:15:00,660
spectrum is that perfect hash function

401
00:15:00,660 --> 00:15:01,950
but I said I need I need another hash

402
00:15:01,950 --> 00:15:03,810
table to make that work max like the

403
00:15:03,810 --> 00:15:05,010
worst case scenario so my collision rate

404
00:15:05,010 --> 00:15:08,220
is is zero but that's the slowest so we

405
00:15:08,220 --> 00:15:12,060
want something in the middle okay all

406
00:15:12,060 --> 00:15:13,440
right so the next piece is the hashing

407
00:15:13,440 --> 00:15:14,940
scheme the hashing scheme is essentially

408
00:15:14,940 --> 00:15:16,500
the the mechanism or procedure we're

409
00:15:16,500 --> 00:15:18,300
going to use when we encounter our

410
00:15:18,300 --> 00:15:20,640
collision in our hash table

411
00:15:20,640 --> 00:15:23,280
right so again there's this trade-off

412
00:15:23,280 --> 00:15:26,370
between memory and and compute which is

413
00:15:26,370 --> 00:15:27,450
the classic trade-off in computer

414
00:15:27,450 --> 00:15:30,330
science so if I allocate an impossibly

415
00:15:30,330 --> 00:15:30,840
large

416
00:15:30,840 --> 00:15:33,450
you know slot array like you know two to

417
00:15:33,450 --> 00:15:35,580
the 64 slots because that's all the

418
00:15:35,580 --> 00:15:37,650
memory you have them on my machine then

419
00:15:37,650 --> 00:15:38,850
my collision rate is gonna be

420
00:15:38,850 --> 00:15:40,860
practically zero of course now I can't

421
00:15:40,860 --> 00:15:42,600
do anything else in my database because

422
00:15:42,600 --> 00:15:43,800
I've used all my memory for my hash

423
00:15:43,800 --> 00:15:45,930
table that's barely even full but my

424
00:15:45,930 --> 00:15:48,360
collision rate is gonna be amazing if I

425
00:15:48,360 --> 00:15:50,670
have a slot array of size 1 my clear

426
00:15:50,670 --> 00:15:52,500
rates can be terrible

427
00:15:52,500 --> 00:15:54,090
and if I have to do a bunch of extra

428
00:15:54,090 --> 00:15:55,560
instructions to deal with those

429
00:15:55,560 --> 00:15:57,990
collisions but my storage overhead is is

430
00:15:57,990 --> 00:16:00,420
the minimum so again there's this we

431
00:16:00,420 --> 00:16:01,590
want to be sort of in the middle here we

432
00:16:01,590 --> 00:16:03,180
want to balance the amount of memory

433
00:16:03,180 --> 00:16:04,470
we're using or amount of storage we're

434
00:16:04,470 --> 00:16:06,990
using for a hash table with the extra

435
00:16:06,990 --> 00:16:08,370
instructions or grant code you have to

436
00:16:08,370 --> 00:16:12,810
do when we have a collision all right so

437
00:16:12,810 --> 00:16:15,180
today we're gonna focus on again the the

438
00:16:15,180 --> 00:16:16,620
the with send beginnings are still about

439
00:16:16,620 --> 00:16:19,260
hash functions just get to show you what

440
00:16:19,260 --> 00:16:20,490
what hash fronts are out there the

441
00:16:20,490 --> 00:16:22,220
modern ones that people are using and

442
00:16:22,220 --> 00:16:23,970
then we're talk about two type of

443
00:16:23,970 --> 00:16:25,230
hashing schemes the first is static

444
00:16:25,230 --> 00:16:27,180
hashing is where you you you have an

445
00:16:27,180 --> 00:16:28,980
approximation of what the size of the

446
00:16:28,980 --> 00:16:31,020
keys are trying to store the key set and

447
00:16:31,020 --> 00:16:32,400
then we'll talk about dynamic hashing

448
00:16:32,400 --> 00:16:33,930
where you can have a hash table that can

449
00:16:33,930 --> 00:16:35,640
incrementally grow without having to

450
00:16:35,640 --> 00:16:38,430
reshuffle everything again the

451
00:16:38,430 --> 00:16:39,870
combination of a hash function and

452
00:16:39,870 --> 00:16:41,670
hashing scheme is what people mean when

453
00:16:41,670 --> 00:16:45,840
they say I have a hash table alright so

454
00:16:45,840 --> 00:16:47,660
again a hash function is just this

455
00:16:47,660 --> 00:16:49,650
really fast function that we want to

456
00:16:49,650 --> 00:16:52,410
take any arbitrary byte array or any

457
00:16:52,410 --> 00:16:54,780
arbitrary key and then spit back a

458
00:16:54,780 --> 00:16:57,930
32-bit or a 64-bit integer so can

459
00:16:57,930 --> 00:17:00,030
anybody name a hash function maybe one

460
00:17:00,030 --> 00:17:01,130
they've used before

461
00:17:01,130 --> 00:17:04,800
he says sha what sha-256 that's one can

462
00:17:04,800 --> 00:17:09,089
name another one yes md5 perfect all

463
00:17:09,089 --> 00:17:10,650
right this is actually a great example

464
00:17:10,650 --> 00:17:15,690
so he said sha-256 he said md5 sha-256

465
00:17:15,690 --> 00:17:17,699
is a cryptographic hash function that's

466
00:17:17,699 --> 00:17:19,740
actually reversible right it's a public

467
00:17:19,740 --> 00:17:21,839
public/private key thing so given a key

468
00:17:21,839 --> 00:17:23,640
I can hash it and then I know how to

469
00:17:23,640 --> 00:17:25,319
take that key and reverse and get back

470
00:17:25,319 --> 00:17:26,160
the original value

471
00:17:26,160 --> 00:17:28,650
he said md5 which takes any arbitrary

472
00:17:28,650 --> 00:17:31,200
key and fist back a 32 character unique

473
00:17:31,200 --> 00:17:33,900
hash that in

474
00:17:33,900 --> 00:17:35,490
it's not supposed to be reversible it is

475
00:17:35,490 --> 00:17:37,290
now cuz people cracked it but that's

476
00:17:37,290 --> 00:17:38,660
something where it's of one way hash

477
00:17:38,660 --> 00:17:41,670
hisses hisses of reversible hash so in

478
00:17:41,670 --> 00:17:43,830
our database system we do not care about

479
00:17:43,830 --> 00:17:45,960
cryptography for when we do we're doing

480
00:17:45,960 --> 00:17:48,300
hash tables now that's you know you you

481
00:17:48,300 --> 00:17:49,620
can encrypt the data when you store it

482
00:17:49,620 --> 00:17:51,840
on on disk or on your public cloud

483
00:17:51,840 --> 00:17:53,670
infrastructure but when we're doing our

484
00:17:53,670 --> 00:17:56,040
hash join or and building our hash table

485
00:17:56,040 --> 00:17:57,630
we're not gonna care about cryptography

486
00:17:57,630 --> 00:17:59,250
we're not gonna care about

487
00:17:59,250 --> 00:18:01,290
leaking information about our keys

488
00:18:01,290 --> 00:18:03,150
because we're just trying to build this

489
00:18:03,150 --> 00:18:04,620
hash you know build our hash tip hashing

490
00:18:04,620 --> 00:18:06,540
data structure so we're not gonna use

491
00:18:06,540 --> 00:18:08,520
something like like sha-256 because one

492
00:18:08,520 --> 00:18:09,929
we don't care about the cryptographic

493
00:18:09,929 --> 00:18:12,120
guarantees it provides it's also super

494
00:18:12,120 --> 00:18:14,550
slow so we're not gonna use it at all MP

495
00:18:14,550 --> 00:18:17,670
5 is 1 is 60 a one-way hash and that's

496
00:18:17,670 --> 00:18:18,990
something we could use for a hash

497
00:18:18,990 --> 00:18:20,940
function we don't because it's super

498
00:18:20,940 --> 00:18:22,530
slow we'll see other ones that are that

499
00:18:22,530 --> 00:18:23,880
are faster and it's also sweet one way

500
00:18:23,880 --> 00:18:25,140
but people have rainbow tables to

501
00:18:25,140 --> 00:18:27,450
reverse it so that has doesn't we have

502
00:18:27,450 --> 00:18:29,790
good cryptographic guarantees all right

503
00:18:29,790 --> 00:18:31,679
so again we care about something that's

504
00:18:31,679 --> 00:18:34,620
fast we care something that has a low

505
00:18:34,620 --> 00:18:39,510
collision rate so B this is just sort of

506
00:18:39,510 --> 00:18:40,860
a list of some of the hash functions

507
00:18:40,860 --> 00:18:44,250
that are people are using today so CRC

508
00:18:44,250 --> 00:18:46,380
is used in the networking world it was

509
00:18:46,380 --> 00:18:49,380
originally you know a Menten in 1975 I

510
00:18:49,380 --> 00:18:50,730
don't remember whether it was 32 bits or

511
00:18:50,730 --> 00:18:51,870
16 bits back then

512
00:18:51,870 --> 00:18:54,090
but now if you want to use CRC there's a

513
00:18:54,090 --> 00:18:55,679
64 bit version and you would use

514
00:18:55,679 --> 00:18:57,090
something like that

515
00:18:57,090 --> 00:19:00,450
so again this will produce something

516
00:19:00,450 --> 00:19:02,490
with a reasonable collision rate and but

517
00:19:02,490 --> 00:19:04,020
it's gonna be super super slow so we

518
00:19:04,020 --> 00:19:06,630
nobody actually does this in practice so

519
00:19:06,630 --> 00:19:08,160
this is sort of murmur hash sort of

520
00:19:08,160 --> 00:19:10,320
again from a database perspective this

521
00:19:10,320 --> 00:19:12,030
enters the era of modern hashing

522
00:19:12,030 --> 00:19:13,110
functions and these are the ones that

523
00:19:13,110 --> 00:19:15,900
we're gonna care about so murmur hash

524
00:19:15,900 --> 00:19:18,059
came out in 2008 it was just some dude

525
00:19:18,059 --> 00:19:19,920
on the internet posted up his his

526
00:19:19,920 --> 00:19:21,450
general-purpose hashing code on github

527
00:19:21,450 --> 00:19:23,429
and then people picked it up and then

528
00:19:23,429 --> 00:19:27,270
started using it Google then took murmur

529
00:19:27,270 --> 00:19:31,290
hash in in the early 2010's modified it

530
00:19:31,290 --> 00:19:34,740
to be a faster on shorter keys and then

531
00:19:34,740 --> 00:19:36,059
they released something called City hash

532
00:19:36,059 --> 00:19:38,580
and then later on in 2014 they've

533
00:19:38,580 --> 00:19:40,910
modified this again to have farm hash

534
00:19:40,910 --> 00:19:43,050
that has a better collision rate than

535
00:19:43,050 --> 00:19:45,810
City hash so farm hashes City House are

536
00:19:45,810 --> 00:19:47,640
pretty common in some systems

537
00:19:47,640 --> 00:19:49,650
what is now considered to be the state

538
00:19:49,650 --> 00:19:51,059
of your art and the fastest and has the

539
00:19:51,059 --> 00:19:53,970
best collision rate in four hash punches

540
00:19:53,970 --> 00:19:56,880
today is actually Facebook's xx hash and

541
00:19:56,880 --> 00:19:59,250
not the the original one 2012 there's a

542
00:19:59,250 --> 00:20:02,580
xx - 3 that is actively under active

543
00:20:02,580 --> 00:20:05,250
under active development now I think it

544
00:20:05,250 --> 00:20:07,440
came out in 2019 so right now this is

545
00:20:07,440 --> 00:20:08,640
the fastest and has the best collision

546
00:20:08,640 --> 00:20:10,200
rate of all these hash functions so if

547
00:20:10,200 --> 00:20:11,400
you're building a database system today

548
00:20:11,400 --> 00:20:15,600
you want to be using xx hash so again we

549
00:20:15,600 --> 00:20:17,309
don't care so much how this is actually

550
00:20:17,309 --> 00:20:19,710
implemented right I don't this is not an

551
00:20:19,710 --> 00:20:20,940
algorithms class I don't care about the

552
00:20:20,940 --> 00:20:22,559
internals are again all I care about is

553
00:20:22,559 --> 00:20:24,600
how fast it is and what the collision

554
00:20:24,600 --> 00:20:25,770
rate is and there's benchmarks to

555
00:20:25,770 --> 00:20:28,500
measure and the quality of the

556
00:20:28,500 --> 00:20:29,880
collisions cousin rates all these

557
00:20:29,880 --> 00:20:32,640
algorithms so this is a benchmark

558
00:20:32,640 --> 00:20:33,960
micromanager like I've run you every

559
00:20:33,960 --> 00:20:35,309
year so this is like an open-source

560
00:20:35,309 --> 00:20:37,169
framework that I took I modified that

561
00:20:37,169 --> 00:20:39,690
just scales up the number of keys you

562
00:20:39,690 --> 00:20:41,669
throw into the hash function and see how

563
00:20:41,669 --> 00:20:43,770
fast it can actually compute hashes on

564
00:20:43,770 --> 00:20:45,660
things so this here we're looking at

565
00:20:45,660 --> 00:20:47,309
from one to eight bytes for the key

566
00:20:47,309 --> 00:20:49,650
sizes which is pretty small right when

567
00:20:49,650 --> 00:20:51,809
you think about essentially a 64-bit

568
00:20:51,809 --> 00:20:53,460
integer but you want this is beyond what

569
00:20:53,460 --> 00:20:56,790
like email keys or URLs it will be so at

570
00:20:56,790 --> 00:20:59,690
the really smallest level right the the

571
00:20:59,690 --> 00:21:02,730
CRC actually does the fastest here but

572
00:21:02,730 --> 00:21:05,250
then of course as you scale up the the

573
00:21:05,250 --> 00:21:07,080
farm hash City hash and the Facebook

574
00:21:07,080 --> 00:21:09,840
access hash do you know are getting much

575
00:21:09,840 --> 00:21:12,179
better what really matters is one wheel

576
00:21:12,179 --> 00:21:13,950
actually looking larger key sizes which

577
00:21:13,950 --> 00:21:15,809
is something like this so now you see

578
00:21:15,809 --> 00:21:17,910
the CRC hash sucks ass and no matter how

579
00:21:17,910 --> 00:21:19,679
much bigger the key is the throughput

580
00:21:19,679 --> 00:21:23,070
rate is is essentially the same but you

581
00:21:23,070 --> 00:21:25,559
see these really nice spikes here for at

582
00:21:25,559 --> 00:21:28,590
32 bytes and 64 bytes for font hash city

583
00:21:28,590 --> 00:21:31,049
hash and xxxx hash three alright and

584
00:21:31,049 --> 00:21:34,200
this is because the the the key that

585
00:21:34,200 --> 00:21:35,850
they're processing that they're

586
00:21:35,850 --> 00:21:38,220
computing on fits within a single cache

587
00:21:38,220 --> 00:21:41,850
line so as I see you a single fetch into

588
00:21:41,850 --> 00:21:44,549
memory I'm bringing in 64 bytes into my

589
00:21:44,549 --> 00:21:47,130
cache and I can operate on you know for

590
00:21:47,130 --> 00:21:49,140
that single fetch I'm operating on all

591
00:21:49,140 --> 00:21:51,480
the data within that that cash cash cash

592
00:21:51,480 --> 00:21:54,000
lookup so that's why there's sort of the

593
00:21:54,000 --> 00:21:56,040
solitude pattern here and then beyond

594
00:21:56,040 --> 00:21:58,140
this I think after 64 byte City hash on

595
00:21:58,140 --> 00:21:59,640
farm hash switch to a different

596
00:21:59,640 --> 00:22:01,030
algorithm and then it's

597
00:22:01,030 --> 00:22:03,910
be different you see different

598
00:22:03,910 --> 00:22:05,650
properties whereas xx hash still does

599
00:22:05,650 --> 00:22:08,920
quite well so again I'm not showing the

600
00:22:08,920 --> 00:22:09,850
collision right here but there's

601
00:22:09,850 --> 00:22:11,470
benchmarks online they can show you that

602
00:22:11,470 --> 00:22:13,480
even though XS hash is actually the

603
00:22:13,480 --> 00:22:16,150
fastest here it actually still gets a as

604
00:22:16,150 --> 00:22:18,310
good as a collision rate as City hash

605
00:22:18,310 --> 00:22:21,180
and farm hash so in our own system today

606
00:22:21,180 --> 00:22:23,410
we're using excess hash as much as

607
00:22:23,410 --> 00:22:25,870
possible so any questions about that

608
00:22:25,870 --> 00:22:27,630
kind of hash function just takes a

609
00:22:27,630 --> 00:22:44,020
arbitrary key spits back a value yes his

610
00:22:44,020 --> 00:22:45,400
statement which is when I'm not heard

611
00:22:45,400 --> 00:22:48,940
before is that it's possible that

612
00:22:48,940 --> 00:22:52,900
someone could give a someone could give

613
00:22:52,900 --> 00:22:57,280
a data in such a way that it they know

614
00:22:57,280 --> 00:22:59,080
the values would always hash to the same

615
00:22:59,080 --> 00:23:02,310
thing and therefore you would have a

616
00:23:02,310 --> 00:23:05,250
potential denial service attack because

617
00:23:05,250 --> 00:23:08,980
you're causing the the collision rate to

618
00:23:08,980 --> 00:23:10,840
be super large and now for it's taking

619
00:23:10,840 --> 00:23:12,730
longer to run your queries all right

620
00:23:12,730 --> 00:23:15,490
let's talk about this so one is in the

621
00:23:15,490 --> 00:23:16,900
database world at least the data stuff

622
00:23:16,900 --> 00:23:19,540
we're talk about here the users are

623
00:23:19,540 --> 00:23:22,450
trusted meaning I'm running Postgres in

624
00:23:22,450 --> 00:23:24,550
own shop or whatever system in my own

625
00:23:24,550 --> 00:23:27,190
hardware whoever is supposed to give me

626
00:23:27,190 --> 00:23:29,170
access to that has already betted me in

627
00:23:29,170 --> 00:23:30,340
trusted me so I'm not gonna be that

628
00:23:30,340 --> 00:23:33,580
malicious to you also provided a seed

629
00:23:33,580 --> 00:23:35,470
when you do these hashing so that one

630
00:23:35,470 --> 00:23:37,300
unless that's hard coded you may not

631
00:23:37,300 --> 00:23:39,430
know exactly what that is and then three

632
00:23:39,430 --> 00:23:40,990
you may say all right what if I'm in a

633
00:23:40,990 --> 00:23:45,760
cloud system and I you know someone is

634
00:23:45,760 --> 00:23:48,520
malicious that way well Google doesn't

635
00:23:48,520 --> 00:23:50,230
care or Amazon don't care because you're

636
00:23:50,230 --> 00:23:51,550
the one paying for the hardware so if

637
00:23:51,550 --> 00:23:53,560
you give me keys then then hash to the

638
00:23:53,560 --> 00:23:54,730
same thing and your collision rate is

639
00:23:54,730 --> 00:23:56,560
super long now your query takes a long

640
00:23:56,560 --> 00:23:58,900
time and they're just clocking your

641
00:23:58,900 --> 00:24:02,890
money so it's not it's not I'm sure you

642
00:24:02,890 --> 00:24:04,180
could think of a tack that does this but

643
00:24:04,180 --> 00:24:05,740
for what we're talking I'm hearing in

644
00:24:05,740 --> 00:24:07,420
terms of the system nobody cares again

645
00:24:07,420 --> 00:24:09,310
there's databases that will encrypt the

646
00:24:09,310 --> 00:24:12,850
data at rest on on s3 or EBS buckets

647
00:24:12,850 --> 00:24:16,260
that's a whole separate thing from this

648
00:24:16,260 --> 00:24:20,100
there's another question or now okay

649
00:24:20,100 --> 00:24:23,590
again I there are equipped erratic

650
00:24:23,590 --> 00:24:25,750
databases I'm people are spending a lot

651
00:24:25,750 --> 00:24:26,830
of money to worry about these things

652
00:24:26,830 --> 00:24:28,420
because data breaches are a big deal I

653
00:24:28,420 --> 00:24:30,370
don't care at this point my life

654
00:24:30,370 --> 00:24:32,440
I'll get point and then they don't care

655
00:24:32,440 --> 00:24:35,200
but now I don't care alright so again

656
00:24:35,200 --> 00:24:37,299
we're not reading hash functions we're

657
00:24:37,299 --> 00:24:38,620
just gonna take one of these three or

658
00:24:38,620 --> 00:24:40,420
what you know in general we wanna take

659
00:24:40,420 --> 00:24:44,190
xx hash and that'll be good enough okay

660
00:24:44,190 --> 00:24:45,970
don't write your own hash function it's

661
00:24:45,970 --> 00:24:48,549
not worth your time all right so let's

662
00:24:48,549 --> 00:24:50,290
talk about now how do we use our hash

663
00:24:50,290 --> 00:24:52,750
function in our and our hashing scheme

664
00:24:52,750 --> 00:24:55,330
to deal with collisions so again what

665
00:24:55,330 --> 00:24:56,410
we're talking about here it doesn't

666
00:24:56,410 --> 00:24:58,330
matter what hashing function we're using

667
00:24:58,330 --> 00:25:00,010
right could be the slowest wanted to be

668
00:25:00,010 --> 00:25:01,299
the fastball fastest one

669
00:25:01,299 --> 00:25:03,040
all these hashing schemes will still

670
00:25:03,040 --> 00:25:04,990
work the same because this is this is

671
00:25:04,990 --> 00:25:06,340
what we're doing after we'd hash it

672
00:25:06,340 --> 00:25:08,590
after we jump to some location and now

673
00:25:08,590 --> 00:25:10,660
we got to figure out how do we deal with

674
00:25:10,660 --> 00:25:11,950
collisions or how to find that thing

675
00:25:11,950 --> 00:25:13,840
that we're looking for so we're gonna

676
00:25:13,840 --> 00:25:15,520
search talk about be the most basic hash

677
00:25:15,520 --> 00:25:16,690
table you can have it called linear

678
00:25:16,690 --> 00:25:18,400
probe hashing and then we'll talk about

679
00:25:18,400 --> 00:25:19,600
some variants to improve on this

680
00:25:19,600 --> 00:25:21,730
potentially called Robinhood hashing and

681
00:25:21,730 --> 00:25:23,890
cuckoo hashing but they're all roughly

682
00:25:23,890 --> 00:25:26,140
based on on linear hashing and again

683
00:25:26,140 --> 00:25:27,669
these are all static hashing schemes

684
00:25:27,669 --> 00:25:29,679
meaning we have to be told at the

685
00:25:29,679 --> 00:25:31,210
beginning when we when we allocate

686
00:25:31,210 --> 00:25:32,980
memory here's the number keys that I

687
00:25:32,980 --> 00:25:36,429
expect a store and so that in some cases

688
00:25:36,429 --> 00:25:38,620
you actually can can guess what this is

689
00:25:38,620 --> 00:25:41,020
so when we do query processing and we're

690
00:25:41,020 --> 00:25:42,250
doing we're using the hash table to do

691
00:25:42,250 --> 00:25:46,690
joins i roughly know i hope to know that

692
00:25:46,690 --> 00:25:48,160
how many keys i'm gonna have to hash a

693
00:25:48,160 --> 00:25:49,480
my hash table and then i can allocate

694
00:25:49,480 --> 00:25:51,700
accordingly if our hash table gets too

695
00:25:51,700 --> 00:25:53,470
full and we'll see what that means

696
00:25:53,470 --> 00:25:55,299
essentially means we have an infinite

697
00:25:55,299 --> 00:25:58,090
loop or all our slots are filled then

698
00:25:58,090 --> 00:26:01,480
that means that we have to double we

699
00:26:01,480 --> 00:26:02,590
have to increase the size and

700
00:26:02,590 --> 00:26:03,970
essentially double the size of the hash

701
00:26:03,970 --> 00:26:06,040
table and then basically take all the

702
00:26:06,040 --> 00:26:08,140
keys in the first hash table and copy

703
00:26:08,140 --> 00:26:09,760
them over to the second hash table which

704
00:26:09,760 --> 00:26:12,480
is obviously super expensive to do so

705
00:26:12,480 --> 00:26:14,710
ideally we can have a good approximation

706
00:26:14,710 --> 00:26:17,440
of you know what the upper bound is for

707
00:26:17,440 --> 00:26:19,179
our keep for a hash table size so that

708
00:26:19,179 --> 00:26:21,549
we don't have to do this to do this

709
00:26:21,549 --> 00:26:25,330
regrowth or rebuilding all right

710
00:26:25,330 --> 00:26:27,280
so again linear probe hashing sometimes

711
00:26:27,280 --> 00:26:28,390
called a

712
00:26:28,390 --> 00:26:30,370
addressing this is sort of the most

713
00:26:30,370 --> 00:26:32,770
basic hash table you can have and all it

714
00:26:32,770 --> 00:26:36,430
is it's just a giant table of slots and

715
00:26:36,430 --> 00:26:38,650
we reuse our hash function to jump to

716
00:26:38,650 --> 00:26:41,080
some offset or add some slot in that

717
00:26:41,080 --> 00:26:44,050
table so if you get a if you use Python

718
00:26:44,050 --> 00:26:46,150
and you allocate a dictionary this is

719
00:26:46,150 --> 00:26:47,380
essentially the same data structure

720
00:26:47,380 --> 00:26:48,280
you're gonna get underneath the

721
00:26:48,280 --> 00:26:49,660
dictionary it's gonna be a linear probe

722
00:26:49,660 --> 00:26:52,720
hashing table so the way we're gonna

723
00:26:52,720 --> 00:26:54,580
resolve collisions is that if we hash

724
00:26:54,580 --> 00:26:56,590
into a slot and we find something that's

725
00:26:56,590 --> 00:26:59,110
already there I'm trying to insert

726
00:26:59,110 --> 00:27:01,450
something there we just keep scanning

727
00:27:01,450 --> 00:27:04,000
down to the next position and keep going

728
00:27:04,000 --> 00:27:06,100
until we find the first open slot and

729
00:27:06,100 --> 00:27:09,010
then that's where we insert our the

730
00:27:09,010 --> 00:27:11,320
entry we're trying to add so now when I

731
00:27:11,320 --> 00:27:13,720
want to do a lookup I would then land at

732
00:27:13,720 --> 00:27:15,130
the slot where I should have been and I

733
00:27:15,130 --> 00:27:16,870
keep scanning down till I either find an

734
00:27:16,870 --> 00:27:18,640
empty slot meaning the thing I'm looking

735
00:27:18,640 --> 00:27:20,710
for is not there or I find the thing

736
00:27:20,710 --> 00:27:23,380
that I was looking for right it's it's

737
00:27:23,380 --> 00:27:24,700
it's pretty basic it's pretty

738
00:27:24,700 --> 00:27:26,980
straightforward all right so again so

739
00:27:26,980 --> 00:27:28,150
let's say that these are the keys we

740
00:27:28,150 --> 00:27:29,920
want to add all right we have some

741
00:27:29,920 --> 00:27:31,690
hashing function that's gonna take these

742
00:27:31,690 --> 00:27:34,300
keys and map them to our slot to a slot

743
00:27:34,300 --> 00:27:35,980
in our hash table all right so this

744
00:27:35,980 --> 00:27:38,050
first one we hash a that it lands here

745
00:27:38,050 --> 00:27:39,820
and again inside of this thing it's a

746
00:27:39,820 --> 00:27:42,010
key value pair we have the original key

747
00:27:42,010 --> 00:27:44,560
that that we inserted plus whatever the

748
00:27:44,560 --> 00:27:45,910
value that we wanted to be so it's a

749
00:27:45,910 --> 00:27:47,080
pointer to another tuple will turn

750
00:27:47,080 --> 00:27:48,850
another page or you know some other

751
00:27:48,850 --> 00:27:51,610
arbitrary value it doesn't matter the

752
00:27:51,610 --> 00:27:53,590
reason why we have to store the key the

753
00:27:53,590 --> 00:27:55,540
original keys because when we start

754
00:27:55,540 --> 00:27:57,720
doing lookups and we have to scan down

755
00:27:57,720 --> 00:27:59,710
you know start looking at multiple

756
00:27:59,710 --> 00:28:01,450
entries we need to know whether the

757
00:28:01,450 --> 00:28:02,500
thing we're actually looking for were in

758
00:28:02,500 --> 00:28:04,120
a slot is the key that we actually want

759
00:28:04,120 --> 00:28:05,980
because it's not always guaranteed to be

760
00:28:05,980 --> 00:28:09,580
exactly where we hash into the table so

761
00:28:09,580 --> 00:28:12,460
if we hash BB lands here now we hash c

762
00:28:12,460 --> 00:28:15,550
c/e lands here but again a is occupied

763
00:28:15,550 --> 00:28:19,030
the slot where it c wants to go so all

764
00:28:19,030 --> 00:28:20,560
we do is just jump down to the next

765
00:28:20,560 --> 00:28:22,600
position and then insert our entry into

766
00:28:22,600 --> 00:28:26,530
that same thing for DD once we go over c

767
00:28:26,530 --> 00:28:28,270
is so we put it here he wants to go

768
00:28:28,270 --> 00:28:29,980
where a is it can't because a is there

769
00:28:29,980 --> 00:28:32,110
can't go over C is can't go over D is so

770
00:28:32,110 --> 00:28:35,140
it ends in here and the last one for F

771
00:28:35,140 --> 00:28:38,950
down here right pretty straight board

772
00:28:38,950 --> 00:28:41,140
and this is actually really fast to do

773
00:28:41,140 --> 00:28:42,430
I'm not showing the division between

774
00:28:42,430 --> 00:28:43,930
pages here but you just think of this is

775
00:28:43,930 --> 00:28:45,910
like I have allocated a bunch of pages

776
00:28:45,910 --> 00:28:49,450
and I know how to go from one position

777
00:28:49,450 --> 00:28:50,830
to the next I know that if I'm in the

778
00:28:50,830 --> 00:28:53,320
last slot in my page I know what the

779
00:28:53,320 --> 00:28:55,630
next page is to jump to to continue the

780
00:28:55,630 --> 00:29:07,210
search yes yes yeah so because this is a

781
00:29:07,210 --> 00:29:07,840
circularbuffer

782
00:29:07,840 --> 00:29:09,700
so if I see his question is say I want

783
00:29:09,700 --> 00:29:12,730
to search G & G one Segovia's can't so

784
00:29:12,730 --> 00:29:14,650
it goes here it can't go there it loops

785
00:29:14,650 --> 00:29:17,910
back around and continues here all right

786
00:29:17,910 --> 00:29:27,580
yes yes the question is what if I delete

787
00:29:27,580 --> 00:29:30,160
a value boom next slide excellent okay

788
00:29:30,160 --> 00:29:32,820
so let's say that we want to delete see

789
00:29:32,820 --> 00:29:36,310
what do we do again we hash it we with

790
00:29:36,310 --> 00:29:37,960
land where a is that's not what we won

791
00:29:37,960 --> 00:29:39,820
cuz again now we this is why we have the

792
00:29:39,820 --> 00:29:41,680
exact key in there so you can say a is

793
00:29:41,680 --> 00:29:43,060
not equal to see this is not what I want

794
00:29:43,060 --> 00:29:45,250
scan down ah C equals C that's the one I

795
00:29:45,250 --> 00:29:48,250
want this is what I wanted to delete so

796
00:29:48,250 --> 00:29:49,780
let's say I just do something really

797
00:29:49,780 --> 00:29:53,440
simple and just remove it what's the

798
00:29:53,440 --> 00:29:59,350
problem with this exactly I do a lookup

799
00:29:59,350 --> 00:30:02,950
on D I look in here I see empty slot and

800
00:30:02,950 --> 00:30:04,840
it's it's I think all right my search is

801
00:30:04,840 --> 00:30:05,710
done it's not what I want even though

802
00:30:05,710 --> 00:30:09,310
it's the next slot down so there's two

803
00:30:09,310 --> 00:30:12,250
ways to handle deletes so the first is

804
00:30:12,250 --> 00:30:14,650
that you just add a tombstone marker you

805
00:30:14,650 --> 00:30:16,300
basically take wherever C used to be

806
00:30:16,300 --> 00:30:17,590
just a little tombstone that says

807
00:30:17,590 --> 00:30:19,690
there's not an entry there's not a

808
00:30:19,690 --> 00:30:22,330
logical entry here but physically

809
00:30:22,330 --> 00:30:25,570
consider this off this slot occupied so

810
00:30:25,570 --> 00:30:27,670
that one I do a lookup and I land here I

811
00:30:27,670 --> 00:30:30,280
say well there's no data here but it's

812
00:30:30,280 --> 00:30:32,080
not really an empty slot let me jump

813
00:30:32,080 --> 00:30:33,430
down to the next one and that's the

814
00:30:33,430 --> 00:30:36,700
thing that I wanted of course what's the

815
00:30:36,700 --> 00:30:39,910
problem with this now we are you know

816
00:30:39,910 --> 00:30:42,310
we're wasting space you know we have to

817
00:30:42,310 --> 00:30:45,040
go clean this up later on eventually so

818
00:30:45,040 --> 00:30:46,210
this is going to contribute to our fill

819
00:30:46,210 --> 00:30:49,090
factor the other option is do data

820
00:30:49,090 --> 00:30:50,770
movement essentially recognize that I

821
00:30:50,770 --> 00:30:53,320
have an empty slot here and just move

822
00:30:53,320 --> 00:30:54,970
everybody up

823
00:30:54,970 --> 00:30:58,930
one and then that way I and exactly

824
00:30:58,930 --> 00:31:01,600
where I want to go now in this example

825
00:31:01,600 --> 00:31:04,390
this is this works fine because II maps

826
00:31:04,390 --> 00:31:06,100
exactly to where where it would be found

827
00:31:06,100 --> 00:31:07,750
F maps exactly where it would be found

828
00:31:07,750 --> 00:31:09,100
but again remember I said it's a

829
00:31:09,100 --> 00:31:13,750
circularbuffer so technically B might

830
00:31:13,750 --> 00:31:16,840
actually want to go here because it is

831
00:31:16,840 --> 00:31:19,510
it is technically comes after F even

832
00:31:19,510 --> 00:31:22,690
though physically it doesn't so in this

833
00:31:22,690 --> 00:31:24,910
case here if I end up moving B around

834
00:31:24,910 --> 00:31:26,410
this was gonna be bad this is gonna be

835
00:31:26,410 --> 00:31:30,040
incorrect because B hashes in that

836
00:31:30,040 --> 00:31:33,340
location so had I moved it here I would

837
00:31:33,340 --> 00:31:35,190
then do a lookup and B and find nothing

838
00:31:35,190 --> 00:31:37,990
because as I scan down I'm going down

839
00:31:37,990 --> 00:31:39,400
this direction I would not know to loop

840
00:31:39,400 --> 00:31:40,360
back around and look at the previous

841
00:31:40,360 --> 00:31:44,980
entry so in practice mostly we'll just

842
00:31:44,980 --> 00:31:48,220
do tombstones because it's this data

843
00:31:48,220 --> 00:31:49,420
movement thing is actually complicated

844
00:31:49,420 --> 00:31:50,890
there's another good example of why you

845
00:31:50,890 --> 00:31:52,060
want to have the original key in here

846
00:31:52,060 --> 00:31:53,950
because in order to figure out whether

847
00:31:53,950 --> 00:31:55,720
it's okay for me to move this up by one

848
00:31:55,720 --> 00:31:57,730
I need to go to a hash and decide

849
00:31:57,730 --> 00:31:59,500
whether the thing the location where it

850
00:31:59,500 --> 00:32:03,940
should be is less than or up above where

851
00:32:03,940 --> 00:32:06,340
I want to move it too because if i if I

852
00:32:06,340 --> 00:32:10,240
now go above it then I'll get false

853
00:32:10,240 --> 00:32:11,680
negatives the hat will hash the thing

854
00:32:11,680 --> 00:32:19,440
and not buy X you find it so for some

855
00:32:19,440 --> 00:32:22,150
some operations or some some instances

856
00:32:22,150 --> 00:32:23,440
of a hash table in our database system

857
00:32:23,440 --> 00:32:25,530
we don't worry about deletes at all

858
00:32:25,530 --> 00:32:27,700
again if I'm building a temporary data

859
00:32:27,700 --> 00:32:29,860
structure to do a query a query I'm not

860
00:32:29,860 --> 00:32:31,450
gonna delete so I'm just gonna scan my

861
00:32:31,450 --> 00:32:33,130
input data populate my hash table and

862
00:32:33,130 --> 00:32:35,290
then start using it if you're using as a

863
00:32:35,290 --> 00:32:37,300
hash index though then we could have

864
00:32:37,300 --> 00:32:39,310
deletes and we have to account for this

865
00:32:39,310 --> 00:32:41,230
and tombstones is probably the most

866
00:32:41,230 --> 00:32:45,480
easiest way to do this yes

867
00:32:53,580 --> 00:32:57,790
yeah so his statement is he said

868
00:32:57,790 --> 00:32:59,410
movement is probably the worst way to

869
00:32:59,410 --> 00:33:01,840
handle this because I can't say it again

870
00:33:01,840 --> 00:33:06,820
I can't move things I'm above it up why

871
00:33:06,820 --> 00:33:15,160
not but that's okay so if you go back

872
00:33:15,160 --> 00:33:18,420
here when we first start of it right

873
00:33:20,430 --> 00:33:23,440
correct so right no not necessarily

874
00:33:23,440 --> 00:33:26,590
right so so F wanted to go here but he's

875
00:33:26,590 --> 00:33:27,880
there so it's okay to move that up by

876
00:33:27,880 --> 00:33:31,840
one he wanted to go here but I can't so

877
00:33:31,840 --> 00:33:33,490
I it's okay for moving up by one and

878
00:33:33,490 --> 00:33:34,990
then D wanted to go here in a can't

879
00:33:34,990 --> 00:33:35,680
scream move like one

880
00:33:35,680 --> 00:33:37,960
so my toy example here it's it is

881
00:33:37,960 --> 00:33:39,810
perfectly safe for me to move up

882
00:33:39,810 --> 00:33:42,460
everybody up by one but the point I'm

883
00:33:42,460 --> 00:33:43,810
trying to make is we can't actually move

884
00:33:43,810 --> 00:33:46,120
B because b actually wants to hatch to

885
00:33:46,120 --> 00:33:48,220
there basically it's not contiguous

886
00:33:48,220 --> 00:33:49,900
logically it is so I should have have to

887
00:33:49,900 --> 00:33:51,760
moved it here but exactly as you said I

888
00:33:51,760 --> 00:33:53,770
had to hash it in check to see oh is it

889
00:33:53,770 --> 00:33:55,900
safe for me to move it down here in this

890
00:33:55,900 --> 00:33:57,580
case no because the hash actually wants

891
00:33:57,580 --> 00:34:00,010
to go there so as I go down one by one I

892
00:34:00,010 --> 00:34:01,450
have to say is it okay for me to move it

893
00:34:01,450 --> 00:34:22,120
up yes yes yes question is in mice

894
00:34:22,120 --> 00:34:25,600
against super similar example here it's

895
00:34:25,600 --> 00:34:27,370
sort of you know I only have six keys I

896
00:34:27,370 --> 00:34:29,020
can kind of estimate what the keys that

897
00:34:29,020 --> 00:34:31,719
slots I need in practice how do you

898
00:34:31,719 --> 00:34:33,250
actually estimate how many slots you

899
00:34:33,250 --> 00:34:36,040
need in practice its 2n you have to n

900
00:34:36,040 --> 00:34:37,420
the slots of the number of keys you

901
00:34:37,420 --> 00:34:38,590
where ends and the mark easier that you

902
00:34:38,590 --> 00:34:41,110
are not put into it all right and we'll

903
00:34:41,110 --> 00:34:44,020
see in in cuckoo hashing it's slightly

904
00:34:44,020 --> 00:34:44,889
different because they have two hash

905
00:34:44,889 --> 00:34:47,469
tables but it practices to N and then

906
00:34:47,469 --> 00:34:49,150
what happens is when you if this gets to

907
00:34:49,150 --> 00:34:51,040
four this is now that filled when you

908
00:34:51,040 --> 00:34:53,070
resize you double the number of slots

909
00:34:53,070 --> 00:34:57,369
you goes up by two yeah

910
00:34:57,369 --> 00:35:01,150
could you also like just track like the

911
00:35:01,150 --> 00:35:11,049
number of ships all right so here's

912
00:35:11,049 --> 00:35:14,079
Haman which you guys are amazing

913
00:35:14,079 --> 00:35:16,359
segments he's saying couldn't I also

914
00:35:16,359 --> 00:35:18,549
just record the position aware how many

915
00:35:18,549 --> 00:35:19,869
steps I am away from my original

916
00:35:19,869 --> 00:35:21,220
position and use that to determine

917
00:35:21,220 --> 00:35:23,980
whether say for me to move it yes this

918
00:35:23,980 --> 00:35:25,599
is called Robin Hood hashing but we'll

919
00:35:25,599 --> 00:35:28,510
get to that in a second all right the

920
00:35:28,510 --> 00:35:31,150
nice thing I want to talk about now

921
00:35:31,150 --> 00:35:32,440
unique keys as well and then we'll get

922
00:35:32,440 --> 00:35:35,740
to his point about Robin Hood hashing so

923
00:35:35,740 --> 00:35:37,569
again in your albums class you probably

924
00:35:37,569 --> 00:35:39,970
when you discuss hash tables you just

925
00:35:39,970 --> 00:35:42,190
assumed all the keys were unique for

926
00:35:42,190 --> 00:35:43,839
primary indexes this is fine but in

927
00:35:43,839 --> 00:35:46,180
practice in real real real real data

928
00:35:46,180 --> 00:35:48,220
sets we can't assume that the keys are

929
00:35:48,220 --> 00:35:49,599
unique so now we need it'll handle them

930
00:35:49,599 --> 00:35:51,609
in our hash table so there's two ways to

931
00:35:51,609 --> 00:35:53,019
do this and I'll say that the two ways

932
00:35:53,019 --> 00:35:54,609
I'm describing can be used for any of

933
00:35:54,609 --> 00:35:55,599
the hashing schemes that we're talking

934
00:35:55,599 --> 00:35:58,180
about today they're not specific to

935
00:35:58,180 --> 00:35:59,380
linear hashing you can use them for

936
00:35:59,380 --> 00:36:01,599
anything so the first approach is just

937
00:36:01,599 --> 00:36:03,220
you maintain a separate linked list with

938
00:36:03,220 --> 00:36:06,069
all the values so that you have say your

939
00:36:06,069 --> 00:36:08,950
key in whatever your hash table is in

940
00:36:08,950 --> 00:36:11,140
your slot and then set up pointing to

941
00:36:11,140 --> 00:36:13,599
the the underlying tuple whatever the

942
00:36:13,599 --> 00:36:14,589
thing that should be pointing to it

943
00:36:14,589 --> 00:36:18,130
instead points to the separate linked

944
00:36:18,130 --> 00:36:20,440
lists that have the values that of

945
00:36:20,440 --> 00:36:21,700
course put the head off I will have the

946
00:36:21,700 --> 00:36:24,640
same key so if I want to say give me all

947
00:36:24,640 --> 00:36:27,819
the give me all the key value pairs for

948
00:36:27,819 --> 00:36:30,970
the key XYZ I just jump along this that

949
00:36:30,970 --> 00:36:32,200
follow this pointer and then I know that

950
00:36:32,200 --> 00:36:35,710
everything inside there has that key the

951
00:36:35,710 --> 00:36:36,880
other approach which is probably the

952
00:36:36,880 --> 00:36:38,079
most common approach is just to store

953
00:36:38,079 --> 00:36:40,839
redundant keys so all you do now is just

954
00:36:40,839 --> 00:36:43,000
in your in your your slot array you're

955
00:36:43,000 --> 00:36:44,890
just duplicating the keys over and over

956
00:36:44,890 --> 00:36:47,980
again right so the key X Y Z ABC appears

957
00:36:47,980 --> 00:36:49,420
multiple times and each one has a unique

958
00:36:49,420 --> 00:36:50,859
value I'm just recording that multiple

959
00:36:50,859 --> 00:36:52,869
times and then que filling of probing

960
00:36:52,869 --> 00:36:54,430
everything still works that you know if

961
00:36:54,430 --> 00:36:58,329
I'm looking for something I do my lookup

962
00:36:58,329 --> 00:36:59,859
and I just keep scanning down until I

963
00:36:59,859 --> 00:37:01,859
find either empty slot or the thing that

964
00:37:01,859 --> 00:37:04,690
or yet I find em slot but I know my

965
00:37:04,690 --> 00:37:07,210
search is done so if I'm saying find me

966
00:37:07,210 --> 00:37:10,280
one key incident with Elif key value key

967
00:37:10,280 --> 00:37:12,200
equals XYZ I just could jump here and

968
00:37:12,200 --> 00:37:13,970
find exactly what I want but if I went

969
00:37:13,970 --> 00:37:15,560
all in that I got to keep scanning down

970
00:37:15,560 --> 00:37:18,860
until I hit an empty slot again in

971
00:37:18,860 --> 00:37:21,740
practice everyone does the the second

972
00:37:21,740 --> 00:37:24,130
one even though it's it's you know

973
00:37:24,130 --> 00:37:26,150
slightly wasted storage because you're

974
00:37:26,150 --> 00:37:27,560
repeating the key multiple times where

975
00:37:27,560 --> 00:37:29,150
is it that top one you only store the

976
00:37:29,150 --> 00:37:32,300
key once all right so let's talk about

977
00:37:32,300 --> 00:37:34,250
the what he was sort of proposing to do

978
00:37:34,250 --> 00:37:36,470
but we want to see this in a slightly

979
00:37:36,470 --> 00:37:38,690
different way rather than deciding when

980
00:37:38,690 --> 00:37:41,420
to shift around it's it's rather than

981
00:37:41,420 --> 00:37:43,550
deciding how to move bulk movement they

982
00:37:43,550 --> 00:37:45,800
had a bulk moving of keys through our

983
00:37:45,800 --> 00:37:47,510
hash table let's look at how to use

984
00:37:47,510 --> 00:37:50,530
these positions to move individual keys

985
00:37:50,530 --> 00:37:54,380
so Robin Hood hashing was proposed in in

986
00:37:54,380 --> 00:37:57,380
1985 it's one of those papers that came

987
00:37:57,380 --> 00:37:58,700
out that no one really paid attention to

988
00:37:58,700 --> 00:38:00,830
and then in the last decade or so it's

989
00:38:00,830 --> 00:38:02,120
showed up on Hacker News a couple times

990
00:38:02,120 --> 00:38:04,610
and now people are trying out in the

991
00:38:04,610 --> 00:38:08,630
different systems so again Robin Hood is

992
00:38:08,630 --> 00:38:10,820
this folklore tale from England about

993
00:38:10,820 --> 00:38:13,160
this this rogue who would steal from

994
00:38:13,160 --> 00:38:14,900
rich people and give it to the poor

995
00:38:14,900 --> 00:38:17,240
people in immediate medieval England so

996
00:38:17,240 --> 00:38:18,350
that's essentially what we're doing here

997
00:38:18,350 --> 00:38:19,370
in our hash table we're gonna have

998
00:38:19,370 --> 00:38:22,460
Porky's steals Lots from rich keys and

999
00:38:22,460 --> 00:38:24,770
I'm defining poor versus rich meaning

1000
00:38:24,770 --> 00:38:26,990
the number of positions you are from a

1001
00:38:26,990 --> 00:38:28,550
way from where you should have been when

1002
00:38:28,550 --> 00:38:30,830
you first hash into the hash table right

1003
00:38:30,830 --> 00:38:33,070
so to do this the basic idea is that

1004
00:38:33,070 --> 00:38:35,690
we're trying to balance out throughout

1005
00:38:35,690 --> 00:38:38,570
the entire hash table to minimize the

1006
00:38:38,570 --> 00:38:40,670
likelihood that we have one key that's

1007
00:38:40,670 --> 00:38:42,020
really far away from where it should

1008
00:38:42,020 --> 00:38:44,510
have been so that we overall were sort

1009
00:38:44,510 --> 00:38:47,600
of balanced and everybody's equal so

1010
00:38:47,600 --> 00:38:49,190
let's say this so again we want to sort

1011
00:38:49,190 --> 00:38:51,740
these same six keys a goes here

1012
00:38:51,740 --> 00:38:54,140
but now as he as he was suggesting we're

1013
00:38:54,140 --> 00:38:55,760
also Cannell store the the number of

1014
00:38:55,760 --> 00:38:57,740
jumps we are from our original position

1015
00:38:57,740 --> 00:39:00,380
when he first hashed into this so our

1016
00:39:00,380 --> 00:39:02,240
table was empty in the beginning so when

1017
00:39:02,240 --> 00:39:04,400
we hashed a it landed this position here

1018
00:39:04,400 --> 00:39:05,540
it was exactly where it should have been

1019
00:39:05,540 --> 00:39:08,210
so we said it's it's it's number jumps

1020
00:39:08,210 --> 00:39:08,960
to be zero

1021
00:39:08,960 --> 00:39:12,550
same thing with BB hashes here it lands

1022
00:39:12,550 --> 00:39:15,550
at the top so it's its position is zero

1023
00:39:15,550 --> 00:39:20,570
so now we insert C and a occupies the

1024
00:39:20,570 --> 00:39:23,360
slot where it wants to go but in the

1025
00:39:23,360 --> 00:39:24,880
very beginning

1026
00:39:24,880 --> 00:39:27,470
the number jumps a is from its from his

1027
00:39:27,470 --> 00:39:29,180
optimal position is zero and at the

1028
00:39:29,180 --> 00:39:31,310
beginning C landed here so at this point

1029
00:39:31,310 --> 00:39:33,020
C's number number of slots where C is

1030
00:39:33,020 --> 00:39:34,610
from from where it wants to go is 0

1031
00:39:34,610 --> 00:39:37,220
since 0 equals 0 we're gonna leave a

1032
00:39:37,220 --> 00:39:39,710
alone and make C go down to the next

1033
00:39:39,710 --> 00:39:41,840
slot and take that and now we see we

1034
00:39:41,840 --> 00:39:44,420
updated its position counter to be one

1035
00:39:44,420 --> 00:39:46,190
step so it's one step away from where it

1036
00:39:46,190 --> 00:39:47,570
should have been when it first hatched

1037
00:39:47,570 --> 00:39:51,410
into the table so now we do this with D

1038
00:39:51,410 --> 00:39:54,650
D lands here he wants to go in this slot

1039
00:39:54,650 --> 00:39:58,430
but C occupies that but C's counter is 1

1040
00:39:58,430 --> 00:40:02,270
and 1 is greater than 0 so a higher

1041
00:40:02,270 --> 00:40:03,560
counter means you're more poor I mean

1042
00:40:03,560 --> 00:40:04,940
you're farther away from where you want

1043
00:40:04,940 --> 00:40:07,640
to be so C would be farther away from

1044
00:40:07,640 --> 00:40:09,020
where from its where it wants to go

1045
00:40:09,020 --> 00:40:10,790
where D would go if D took this position

1046
00:40:10,790 --> 00:40:13,670
so we don't let D take this slot and we

1047
00:40:13,670 --> 00:40:17,330
make it go down here so now I look at 1

1048
00:40:17,330 --> 00:40:19,970
or e we started up once ago or a is

1049
00:40:19,970 --> 00:40:23,390
again 0 equals 0 so we leave a alone 1

1050
00:40:23,390 --> 00:40:26,180
equals 1 so we leave C alone but now

1051
00:40:26,180 --> 00:40:29,390
ease counter is 2 because this it's you

1052
00:40:29,390 --> 00:40:31,640
know 0 1 2 jumps away from where it

1053
00:40:31,640 --> 00:40:35,210
wants to go so 2 is less than Suze

1054
00:40:35,210 --> 00:40:37,940
greater than then 1 so 2 is considered

1055
00:40:37,940 --> 00:40:42,320
more poor than D so it's it shoots D in

1056
00:40:42,320 --> 00:40:44,030
the head steals its wallet steals its

1057
00:40:44,030 --> 00:40:46,850
slot inserts itself here and then now

1058
00:40:46,850 --> 00:40:48,350
the insertion continues as deed goes

1059
00:40:48,350 --> 00:40:49,700
down to here and now we update its

1060
00:40:49,700 --> 00:40:53,330
counter to be 2 so again before we had

1061
00:40:53,330 --> 00:40:57,710
it we had a c d e but now on a Robin

1062
00:40:57,710 --> 00:41:00,200
Hood hashing ease now closer where it

1063
00:41:00,200 --> 00:41:03,230
wants to be and D is is as far the way

1064
00:41:03,230 --> 00:41:04,730
than when it should have been because

1065
00:41:04,730 --> 00:41:07,960
overall now and now we're more balanced

1066
00:41:07,960 --> 00:41:12,860
same thing where f f/a go here 2 is 2 is

1067
00:41:12,860 --> 00:41:15,170
greater than 0 so D stays where it wants

1068
00:41:15,170 --> 00:41:20,140
to go and F goes down here in fact yes

1069
00:41:24,970 --> 00:41:27,800
yeah statement is on a Robin Hood

1070
00:41:27,800 --> 00:41:31,040
hatching the the the algorithm says that

1071
00:41:31,040 --> 00:41:35,090
it's better to have two keys be one

1072
00:41:35,090 --> 00:41:36,170
position away from where they should

1073
00:41:36,170 --> 00:41:38,270
have been rather than having one key be

1074
00:41:38,270 --> 00:41:39,859
two positions and one key be zero

1075
00:41:39,859 --> 00:41:42,770
positions yes I'm not saying this is the

1076
00:41:42,770 --> 00:41:43,609
right thing to do

1077
00:41:43,609 --> 00:41:44,810
I'm saying this is this is one approach

1078
00:41:44,810 --> 00:41:48,290
to handle collisions a different way the

1079
00:41:48,290 --> 00:41:51,140
the I mean you're essentially trading

1080
00:41:51,140 --> 00:41:54,050
off resore rights so now when I want to

1081
00:41:54,050 --> 00:41:55,310
do a look-up on any of these guys

1082
00:41:55,310 --> 00:41:58,849
alright any of these keys it's there's

1083
00:41:58,849 --> 00:42:00,320
nothing one key that's gonna be all the

1084
00:42:00,320 --> 00:42:01,369
way you know wrap around all the way

1085
00:42:01,369 --> 00:42:03,530
right everyone's gonna be on average the

1086
00:42:03,530 --> 00:42:07,940
same distance but in order to do that

1087
00:42:07,940 --> 00:42:10,099
that's making rights more expensive or

1088
00:42:10,099 --> 00:42:11,750
inserts more expensive cuz now I have to

1089
00:42:11,750 --> 00:42:14,180
write more things so when I did this

1090
00:42:14,180 --> 00:42:16,460
stealing here let's say that I have to

1091
00:42:16,460 --> 00:42:19,400
update this page right there's a page

1092
00:42:19,400 --> 00:42:21,680
split right here so I update this slot

1093
00:42:21,680 --> 00:42:24,590
here on the first page to install e so

1094
00:42:24,590 --> 00:42:26,450
that's one right and then now I got to

1095
00:42:26,450 --> 00:42:28,550
come down here and do another right to

1096
00:42:28,550 --> 00:42:31,280
insert D into this page had I left him

1097
00:42:31,280 --> 00:42:33,140
alone like on a regular linear probe

1098
00:42:33,140 --> 00:42:34,880
hashing I would only don't want one

1099
00:42:34,880 --> 00:42:37,520
right to the page so again this seems

1100
00:42:37,520 --> 00:42:39,619
like a really nice iya idea the the

1101
00:42:39,619 --> 00:42:40,910
research at least the modern research

1102
00:42:40,910 --> 00:42:42,920
shows that especially for in-memory data

1103
00:42:42,920 --> 00:42:44,420
structures that you you pay a big

1104
00:42:44,420 --> 00:42:45,859
penalty for a branch misprediction

1105
00:42:45,859 --> 00:42:47,570
because you have more conditionals to do

1106
00:42:47,570 --> 00:42:48,560
these checks to see whether one should

1107
00:42:48,560 --> 00:42:50,480
take it from another one and you're

1108
00:42:50,480 --> 00:42:51,619
doing more rights and that's more cache

1109
00:42:51,619 --> 00:42:53,690
invalidation so in practice linear

1110
00:42:53,690 --> 00:42:56,510
probing crushes everything still it's

1111
00:42:56,510 --> 00:42:58,880
still the fastest way to do this I think

1112
00:42:58,880 --> 00:43:04,540
we're disk it's the same thing ok

1113
00:43:04,540 --> 00:43:06,890
another approach to deal with collisions

1114
00:43:06,890 --> 00:43:09,560
is instead of doing linear probing and

1115
00:43:09,560 --> 00:43:11,000
just keep scanning down and possibly

1116
00:43:11,000 --> 00:43:13,190
swapping things as an Arab Robin Hood

1117
00:43:13,190 --> 00:43:15,920
hashing where we just have multiple hash

1118
00:43:15,920 --> 00:43:19,670
tables and then we decide where we know

1119
00:43:19,670 --> 00:43:22,250
which hash table to insert our our key

1120
00:43:22,250 --> 00:43:24,349
you know is whatever which one has a

1121
00:43:24,349 --> 00:43:26,630
free slot for us so that we don't have

1122
00:43:26,630 --> 00:43:29,540
to do these potentially long scans so

1123
00:43:29,540 --> 00:43:32,359
that's what cuckoo hashing is so I've

1124
00:43:32,359 --> 00:43:33,680
always mistakenly said cuckoo hashing

1125
00:43:33,680 --> 00:43:34,849
was named after like a cuckoo clock

1126
00:43:34,849 --> 00:43:36,440
where the the the hand goes back and

1127
00:43:36,440 --> 00:43:37,290
forth and

1128
00:43:37,290 --> 00:43:38,820
actually do with a cuckoo bird the

1129
00:43:38,820 --> 00:43:41,580
cuckoo bird is is known to to move

1130
00:43:41,580 --> 00:43:43,350
itself from one nest to another so it

1131
00:43:43,350 --> 00:43:44,610
steals another nest from another bird

1132
00:43:44,610 --> 00:43:46,140
and that bird has to then move something

1133
00:43:46,140 --> 00:43:47,880
else so we'll see how that works in a

1134
00:43:47,880 --> 00:43:48,870
hash-table so that's that's what it

1135
00:43:48,870 --> 00:43:49,260
means

1136
00:43:49,260 --> 00:43:52,110
so lookups and deletions and under

1137
00:43:52,110 --> 00:43:53,870
cuckoo hashing is always gonna be oh one

1138
00:43:53,870 --> 00:43:56,340
meaning we're always gonna jump and when

1139
00:43:56,340 --> 00:43:59,730
we do a look up we're over to jump to -

1140
00:43:59,730 --> 00:44:01,470
no - there are hash tables and find

1141
00:44:01,470 --> 00:44:02,940
exactly whether the thing we want is

1142
00:44:02,940 --> 00:44:04,500
there or not we don't have to do any

1143
00:44:04,500 --> 00:44:06,870
additional scans but the inserts could

1144
00:44:06,870 --> 00:44:08,220
be more expensive because now we may

1145
00:44:08,220 --> 00:44:10,470
have again ping-pong or move keys all

1146
00:44:10,470 --> 00:44:14,280
around so this look an extremely simple

1147
00:44:14,280 --> 00:44:16,800
example with two two hash tables again

1148
00:44:16,800 --> 00:44:19,380
in practice most people use this just

1149
00:44:19,380 --> 00:44:21,390
use - there are some people that use

1150
00:44:21,390 --> 00:44:22,890
three beyond that it's sort of

1151
00:44:22,890 --> 00:44:24,960
impractical and it's unnecessary so - is

1152
00:44:24,960 --> 00:44:27,390
always sort of the right number so let's

1153
00:44:27,390 --> 00:44:30,780
say I want to insert a so for every hash

1154
00:44:30,780 --> 00:44:32,550
table I have in my cuckoo hashing setup

1155
00:44:32,550 --> 00:44:35,790
I have to have a separate hash seed for

1156
00:44:35,790 --> 00:44:38,520
my hash function so I'm gonna take this

1157
00:44:38,520 --> 00:44:41,280
key and hash it twice it's gonna be the

1158
00:44:41,280 --> 00:44:42,960
same hash function like murmur or xx

1159
00:44:42,960 --> 00:44:44,400
hash but I'm just gonna give it a

1160
00:44:44,400 --> 00:44:46,710
different seed so that the for a given

1161
00:44:46,710 --> 00:44:49,430
key it produces a different hash value

1162
00:44:49,430 --> 00:44:52,740
so I'm gonna hash a twice my to my to CD

1163
00:44:52,740 --> 00:44:54,630
hash functions and the first one's gonna

1164
00:44:54,630 --> 00:44:56,370
land this position and the second one's

1165
00:44:56,370 --> 00:44:57,960
gonna land of this position so at this

1166
00:44:57,960 --> 00:45:00,030
point here my hash tables are empty so I

1167
00:45:00,030 --> 00:45:02,400
can insert in either one so for our

1168
00:45:02,400 --> 00:45:03,810
purposes we'll just flip a coin we'll

1169
00:45:03,810 --> 00:45:05,460
slide let's insert it in the first hash

1170
00:45:05,460 --> 00:45:08,340
table here in practice you can do more

1171
00:45:08,340 --> 00:45:09,780
complicated things you can say like

1172
00:45:09,780 --> 00:45:11,430
alright well what's the fill factor for

1173
00:45:11,430 --> 00:45:13,440
my from my hash table maybe always

1174
00:45:13,440 --> 00:45:15,510
choose the one that's less full or if

1175
00:45:15,510 --> 00:45:17,820
you have metadata about the collision

1176
00:45:17,820 --> 00:45:19,440
rate for your hash tables you can make a

1177
00:45:19,440 --> 00:45:21,270
better decision as far as you know

1178
00:45:21,270 --> 00:45:23,010
everyone just flips a coin and that's

1179
00:45:23,010 --> 00:45:24,630
good enough right random is actually

1180
00:45:24,630 --> 00:45:26,660
very very good for a lot of things

1181
00:45:26,660 --> 00:45:29,370
alright so I'll say I wanted cert B same

1182
00:45:29,370 --> 00:45:31,410
thing I'm gonna hash it twice first one

1183
00:45:31,410 --> 00:45:33,180
goes to this slot where a is already

1184
00:45:33,180 --> 00:45:35,040
stored but the second one goes to an

1185
00:45:35,040 --> 00:45:37,230
empty slot so in this case here my

1186
00:45:37,230 --> 00:45:39,000
choice is obvious right I always want to

1187
00:45:39,000 --> 00:45:41,040
go to the one that's empty because I

1188
00:45:41,040 --> 00:45:42,360
don't have to move anybody I just insert

1189
00:45:42,360 --> 00:45:45,840
it there and I'm done so that's our

1190
00:45:45,840 --> 00:45:48,540
insert C same thing I had it twice well

1191
00:45:48,540 --> 00:45:50,770
now the first hash function

1192
00:45:50,770 --> 00:45:52,480
that's to this slot where a is and

1193
00:45:52,480 --> 00:45:54,160
second hash function maps to where B s

1194
00:45:54,160 --> 00:45:56,230
so now I need to make decision which one

1195
00:45:56,230 --> 00:45:59,050
I want to kill again let's just flip a

1196
00:45:59,050 --> 00:46:01,960
coin that's gonna be good enough and to

1197
00:46:01,960 --> 00:46:03,550
make the demo work I'll pick this one

1198
00:46:03,550 --> 00:46:07,330
right so we'll go now steal that slot

1199
00:46:07,330 --> 00:46:11,890
from B and insert C so now I think B out

1200
00:46:11,890 --> 00:46:14,110
now I gotta go put it back in the other

1201
00:46:14,110 --> 00:46:16,450
hash table so I'm gonna hash it with the

1202
00:46:16,450 --> 00:46:18,250
first hash function and that's gonna

1203
00:46:18,250 --> 00:46:19,780
tell me where I go to insert it but we

1204
00:46:19,780 --> 00:46:21,010
as we saw when we try to insert it

1205
00:46:21,010 --> 00:46:23,170
before it one of the go where air a was

1206
00:46:23,170 --> 00:46:26,470
and so we have to now steal it slot put

1207
00:46:26,470 --> 00:46:29,530
B there and now put a in the other one

1208
00:46:29,530 --> 00:46:31,780
so we hate we hashed that it comes over

1209
00:46:31,780 --> 00:46:33,490
here and now we've landed to an empty

1210
00:46:33,490 --> 00:46:36,310
slot and so now our insert is to see is

1211
00:46:36,310 --> 00:46:39,130
done because everybody has landed in a

1212
00:46:39,130 --> 00:46:45,070
free slot yes his question is which is

1213
00:46:45,070 --> 00:46:47,050
absolutely the answer is yes can this

1214
00:46:47,050 --> 00:46:48,790
have cyclic behavior can you be stuck in

1215
00:46:48,790 --> 00:46:51,280
an infinite loop absolutely yes so in

1216
00:46:51,280 --> 00:46:52,990
that case you have to recognize where

1217
00:46:52,990 --> 00:46:54,580
what your starting point was so if you

1218
00:46:54,580 --> 00:46:56,110
come back around see wait a min I've

1219
00:46:56,110 --> 00:46:57,940
seen this spot before and there's

1220
00:46:57,940 --> 00:46:59,020
something there is I can't put anything

1221
00:46:59,020 --> 00:47:00,730
in there I'm stuck in an infinite loop

1222
00:47:00,730 --> 00:47:08,500
so that's when you resize okay so again

1223
00:47:08,500 --> 00:47:11,500
the in practice everyone always does

1224
00:47:11,500 --> 00:47:13,480
just two hash tables and you want to

1225
00:47:13,480 --> 00:47:16,540
allocate this in such a way that you

1226
00:47:16,540 --> 00:47:18,490
know the likelihood that you have a

1227
00:47:18,490 --> 00:47:25,090
cycle is minimized okay so now all of

1228
00:47:25,090 --> 00:47:26,290
the hash tables that we talked about so

1229
00:47:26,290 --> 00:47:29,200
far are again where static hash tables

1230
00:47:29,200 --> 00:47:31,510
meaning I need to know approximately the

1231
00:47:31,510 --> 00:47:33,610
size of the number keys I want to store

1232
00:47:33,610 --> 00:47:35,680
ahead of time so I know how to allocate

1233
00:47:35,680 --> 00:47:39,370
it you know allocate it luck to be large

1234
00:47:39,370 --> 00:47:41,500
enough today that I minimize collisions

1235
00:47:41,500 --> 00:47:44,260
and I don't have infinite loops or get

1236
00:47:44,260 --> 00:47:47,440
completely full alright so again as he's

1237
00:47:47,440 --> 00:47:49,510
pointed out before if you now have to

1238
00:47:49,510 --> 00:47:51,790
resize it need to grow larger which is

1239
00:47:51,790 --> 00:47:53,080
more common but also shrinking if you

1240
00:47:53,080 --> 00:47:55,150
want to reduce the size you essentially

1241
00:47:55,150 --> 00:47:57,150
have to rebuild the hash table entirely

1242
00:47:57,150 --> 00:47:59,140
right we'll talk about consistent

1243
00:47:59,140 --> 00:48:00,460
hashing there's there's hashing schemes

1244
00:48:00,460 --> 00:48:02,290
we are hashing functions or methods we

1245
00:48:02,290 --> 00:48:03,040
can talk about later in the semester

1246
00:48:03,040 --> 00:48:04,710
when we talk about distributed databases

1247
00:48:04,710 --> 00:48:06,420
that don't have to resize the whole

1248
00:48:06,420 --> 00:48:09,089
thing but for for a hash tables inside

1249
00:48:09,089 --> 00:48:10,589
our database system we are got to rehash

1250
00:48:10,589 --> 00:48:13,950
everything I reset rebuild our hash

1251
00:48:13,950 --> 00:48:15,630
table because now we change the number

1252
00:48:15,630 --> 00:48:17,309
of elements when we mod and the hash

1253
00:48:17,309 --> 00:48:19,530
hash value and that means things aren't

1254
00:48:19,530 --> 00:48:21,510
that you know we're in one bucket or one

1255
00:48:21,510 --> 00:48:23,520
location before one slot now could be in

1256
00:48:23,520 --> 00:48:25,559
another slot and I you know everything's

1257
00:48:25,559 --> 00:48:27,119
gonna go out of whack so in practice you

1258
00:48:27,119 --> 00:48:30,210
have to rebuild from scratch so this is

1259
00:48:30,210 --> 00:48:31,440
what dynamic hash tables are trying to

1260
00:48:31,440 --> 00:48:33,000
solve that they're gonna be able to

1261
00:48:33,000 --> 00:48:35,579
resize themselves on demand without

1262
00:48:35,579 --> 00:48:38,520
having to rebuild the entire thing most

1263
00:48:38,520 --> 00:48:40,349
basic one is a chain hash table and this

1264
00:48:40,349 --> 00:48:42,240
is what Hollywood people most think of

1265
00:48:42,240 --> 00:48:43,859
when they think of a hash table but when

1266
00:48:43,859 --> 00:48:45,300
I talk about to more complicated scenes

1267
00:48:45,300 --> 00:48:47,010
from the 1980s that are still used today

1268
00:48:47,010 --> 00:48:50,240
extendable hashing and linear hashing

1269
00:48:50,240 --> 00:48:53,520
all right so chain hashing or chain hash

1270
00:48:53,520 --> 00:48:57,150
table or bucket and hash table is it an

1271
00:48:57,150 --> 00:48:58,530
emic a hash table we're gonna maintain

1272
00:48:58,530 --> 00:49:02,099
link list of buckets for values that map

1273
00:49:02,099 --> 00:49:03,390
to the same or keys that map to the same

1274
00:49:03,390 --> 00:49:06,300
dies that are part of the same key so

1275
00:49:06,300 --> 00:49:08,550
when you allocate a hash map and Java

1276
00:49:08,550 --> 00:49:11,309
and the JVM you get one of these this is

1277
00:49:11,309 --> 00:49:12,750
the the default data structure that they

1278
00:49:12,750 --> 00:49:15,390
use so the way they're gonna deal with

1279
00:49:15,390 --> 00:49:17,549
collisions is that they're gonna just

1280
00:49:17,549 --> 00:49:20,700
keep appending to the end of this bucket

1281
00:49:20,700 --> 00:49:22,559
list so each bucket chain can grow

1282
00:49:22,559 --> 00:49:24,210
forever because you just keep adding

1283
00:49:24,210 --> 00:49:25,530
more and more buckets the linked list

1284
00:49:25,530 --> 00:49:28,290
gets even larger and of course this can

1285
00:49:28,290 --> 00:49:31,589
obviously degenerate to a essentially a

1286
00:49:31,589 --> 00:49:33,480
scrunch else can give all my keys map to

1287
00:49:33,480 --> 00:49:36,630
the same bucket a bucket chain then my

1288
00:49:36,630 --> 00:49:37,829
bucket grows forever and then I'm just

1289
00:49:37,829 --> 00:49:39,720
doing a linear search and I'm no better

1290
00:49:39,720 --> 00:49:41,630
than just you know reading from a table

1291
00:49:41,630 --> 00:49:44,190
so insertions and deletions are pretty

1292
00:49:44,190 --> 00:49:44,940
straightforward because you're just

1293
00:49:44,940 --> 00:49:46,170
modifying the buckets you're not

1294
00:49:46,170 --> 00:49:49,710
actually modifying the slot all right so

1295
00:49:49,710 --> 00:49:51,569
again it just looks like this we have

1296
00:49:51,569 --> 00:49:53,670
our slot array these map to buckets and

1297
00:49:53,670 --> 00:49:55,650
then any single time I want to do an

1298
00:49:55,650 --> 00:49:57,660
insert saying to this this bucket chain

1299
00:49:57,660 --> 00:50:00,569
here if my last bucket is full I just

1300
00:50:00,569 --> 00:50:02,069
allocate a new one and I keep appending

1301
00:50:02,069 --> 00:50:04,680
things until here until I to know till I

1302
00:50:04,680 --> 00:50:05,849
run out of space and allocate the next

1303
00:50:05,849 --> 00:50:07,530
one so you can think of these buckets

1304
00:50:07,530 --> 00:50:10,200
are just pages right in the table heap

1305
00:50:10,200 --> 00:50:12,900
or on the heap file and I was a liqu

1306
00:50:12,900 --> 00:50:14,359
eight new pages and chain them together

1307
00:50:14,359 --> 00:50:17,099
using page IDs to figure out how to you

1308
00:50:17,099 --> 00:50:18,870
know Trevor

1309
00:50:18,870 --> 00:50:20,890
yeah this is pretty straightforward this

1310
00:50:20,890 --> 00:50:23,710
is pretty easy to implement this is

1311
00:50:23,710 --> 00:50:25,630
actually pretty easy also to make Fred

1312
00:50:25,630 --> 00:50:27,340
Dave because all I do is just take a

1313
00:50:27,340 --> 00:50:30,190
latch on either the slot which is the

1314
00:50:30,190 --> 00:50:31,810
the easiest thing to do or just the

1315
00:50:31,810 --> 00:50:36,180
individual page anytime I'm modifying it

1316
00:50:36,180 --> 00:50:38,110
so let's look at more complicated

1317
00:50:38,110 --> 00:50:42,250
schemes so with extendable hashing we're

1318
00:50:42,250 --> 00:50:43,510
gonna take the chain hashing approach

1319
00:50:43,510 --> 00:50:46,690
with the buckets but instead of letting

1320
00:50:46,690 --> 00:50:49,840
the link list just grow forever we're

1321
00:50:49,840 --> 00:50:52,060
going to want to split them

1322
00:50:52,060 --> 00:50:54,400
incrementally and the key difference

1323
00:50:54,400 --> 00:50:57,040
here between rebuilding splitting and

1324
00:50:57,040 --> 00:50:58,510
rebuilding is that we're only gonna

1325
00:50:58,510 --> 00:51:01,570
split the the chain that overflowed

1326
00:51:01,570 --> 00:51:04,900
rather than the entire entire data

1327
00:51:04,900 --> 00:51:08,170
structure and it's our hash table so in

1328
00:51:08,170 --> 00:51:09,010
order to make this work we're not

1329
00:51:09,010 --> 00:51:10,720
allowed multiple slot locations in our

1330
00:51:10,720 --> 00:51:13,330
slot array to point to the same bucket

1331
00:51:13,330 --> 00:51:16,090
chain and that it'll make more sense

1332
00:51:16,090 --> 00:51:18,430
when I show that in the next slot and

1333
00:51:18,430 --> 00:51:21,400
the advantages again is that the women

1334
00:51:21,400 --> 00:51:22,930
have to move data around we're only

1335
00:51:22,930 --> 00:51:24,610
moving the the bucket that overflowed

1336
00:51:24,610 --> 00:51:27,610
and not all the other buckets all right

1337
00:51:27,610 --> 00:51:30,130
so it's gonna look like a chain hash

1338
00:51:30,130 --> 00:51:31,750
table instead I'm gonna add some

1339
00:51:31,750 --> 00:51:34,180
additional information so the first I'm

1340
00:51:34,180 --> 00:51:36,160
gonna have is this global counter that

1341
00:51:36,160 --> 00:51:38,470
corresponds to the number of bits we

1342
00:51:38,470 --> 00:51:40,270
have to consider when we want to figure

1343
00:51:40,270 --> 00:51:42,610
out what bucket to look at what slot to

1344
00:51:42,610 --> 00:51:45,550
look at in our hash function so in this

1345
00:51:45,550 --> 00:51:46,690
example here we'll start with a global

1346
00:51:46,690 --> 00:51:49,750
counter two and then three for each

1347
00:51:49,750 --> 00:51:51,730
bucket chain or each bucket we're gonna

1348
00:51:51,730 --> 00:51:53,920
have a local counter that corresponds to

1349
00:51:53,920 --> 00:51:56,440
the number of bits that we use to get to

1350
00:51:56,440 --> 00:51:59,770
that location so in this case here this

1351
00:51:59,770 --> 00:52:03,250
first bucket has a local local counter

1352
00:52:03,250 --> 00:52:05,440
of one so that means that we only need

1353
00:52:05,440 --> 00:52:07,690
to look at one bit to address into it

1354
00:52:07,690 --> 00:52:10,150
and this is why if you look at 0 0 and 0

1355
00:52:10,150 --> 00:52:13,300
1 both of these guys map to the same

1356
00:52:13,300 --> 00:52:15,820
bucket because the first bit 0 is the

1357
00:52:15,820 --> 00:52:17,590
same because this bucket has a number

1358
00:52:17,590 --> 00:52:19,090
float we haven't had a split it yep

1359
00:52:19,090 --> 00:52:21,730
whereas the the other two buckets have 1

1360
00:52:21,730 --> 00:52:23,560
0 1 1 and that because they're local

1361
00:52:23,560 --> 00:52:25,000
counters to that says we have to look at

1362
00:52:25,000 --> 00:52:27,700
two bits so the global counter you need

1363
00:52:27,700 --> 00:52:29,710
to figure out what how many bits you

1364
00:52:29,710 --> 00:52:31,030
need to look at

1365
00:52:31,030 --> 00:52:32,590
logo counter it's just for your own

1366
00:52:32,590 --> 00:52:34,450
sanity internally to understand what the

1367
00:52:34,450 --> 00:52:36,700
you know how did you get to the location

1368
00:52:36,700 --> 00:52:38,650
where you're at right but you don't

1369
00:52:38,650 --> 00:52:39,940
actually need this to figure out you

1370
00:52:39,940 --> 00:52:41,650
know how did you look up in the

1371
00:52:41,650 --> 00:52:42,520
slaughter right because obviously you

1372
00:52:42,520 --> 00:52:43,990
can't you can't know what this is until

1373
00:52:43,990 --> 00:52:45,070
you do the look up through the slaughter

1374
00:52:45,070 --> 00:52:48,010
right all right so let's say I want to

1375
00:52:48,010 --> 00:52:50,590
find egg so then again I'm gonna hash it

1376
00:52:50,590 --> 00:52:52,660
I'm gonna produce some a bit sequence

1377
00:52:52,660 --> 00:52:55,600
for my from a hash value and then I look

1378
00:52:55,600 --> 00:52:57,100
at my global counter and it says how

1379
00:52:57,100 --> 00:52:58,600
many bits do I want to examine in my

1380
00:52:58,600 --> 00:53:00,820
hash function from a hash value decide

1381
00:53:00,820 --> 00:53:03,790
where do I want to jump to so my global

1382
00:53:03,790 --> 00:53:05,950
counter is two so I only need to look at

1383
00:53:05,950 --> 00:53:08,830
the first two bits 0 1 I do my look up

1384
00:53:08,830 --> 00:53:12,070
in my slaughter a look at 0 1 I follow

1385
00:53:12,070 --> 00:53:13,360
the pointer and then I land to the

1386
00:53:13,360 --> 00:53:14,950
bucket that I want and now I just do a

1387
00:53:14,950 --> 00:53:17,170
central scan to find the entry that I'm

1388
00:53:17,170 --> 00:53:19,440
looking for

1389
00:53:19,500 --> 00:53:22,630
so now let's say I want to start B so

1390
00:53:22,630 --> 00:53:24,910
again global counter is 2 I only need to

1391
00:53:24,910 --> 00:53:26,770
look in the first 2 bits I land here

1392
00:53:26,770 --> 00:53:28,930
follow slaughter a this guy had a freed

1393
00:53:28,930 --> 00:53:30,760
for you location so it's safe for me to

1394
00:53:30,760 --> 00:53:34,750
go ahead and sort that is never flow but

1395
00:53:34,750 --> 00:53:38,230
now I want to start see first you bits

1396
00:53:38,230 --> 00:53:41,230
are 1 0 I follow this I land here but

1397
00:53:41,230 --> 00:53:42,700
now I see that I don't have any more

1398
00:53:42,700 --> 00:53:45,040
free entries in my in my bucket I'm

1399
00:53:45,040 --> 00:53:47,980
gonna overflow so now I have to split

1400
00:53:47,980 --> 00:53:50,830
this so then the splitting process is I

1401
00:53:50,830 --> 00:53:52,840
look at my global counter and it's now

1402
00:53:52,840 --> 00:53:54,340
set to 2 so I'm going to increase that

1403
00:53:54,340 --> 00:53:56,770
to 3 so that means I don't need to

1404
00:53:56,770 --> 00:53:57,970
examine three bits so now I'm gonna

1405
00:53:57,970 --> 00:54:01,030
double the size of my slot array to now

1406
00:54:01,030 --> 00:54:04,600
count for 3 bits again this operation is

1407
00:54:04,600 --> 00:54:05,980
cheap because this is just an array of

1408
00:54:05,980 --> 00:54:07,960
pointers so I take a latch on that

1409
00:54:07,960 --> 00:54:09,820
protect it resize it and then put it

1410
00:54:09,820 --> 00:54:11,860
back in so it's not like I need to move

1411
00:54:11,860 --> 00:54:13,510
around any of the data here which is the

1412
00:54:13,510 --> 00:54:16,630
more expensive part so now like a Lobel

1413
00:54:16,630 --> 00:54:20,950
counter is 3 and I'm gonna split this by

1414
00:54:20,950 --> 00:54:23,380
then now examining the 3 bits instead of

1415
00:54:23,380 --> 00:54:26,440
2 and to figure out which hash table or

1416
00:54:26,440 --> 00:54:28,990
Succot they belong to so this guy just

1417
00:54:28,990 --> 00:54:31,510
slides down I restructure this thing I

1418
00:54:31,510 --> 00:54:33,670
just split the data that that was stored

1419
00:54:33,670 --> 00:54:35,710
between that single page I remap

1420
00:54:35,710 --> 00:54:39,640
everybody based on the the local counter

1421
00:54:39,640 --> 00:54:43,030
so this guy up here and we still only

1422
00:54:43,030 --> 00:54:44,460
care about one bit so there's

1423
00:54:44,460 --> 00:54:46,530
two slots that map to it up there and

1424
00:54:46,530 --> 00:54:47,820
two slots down here that also map to

1425
00:54:47,820 --> 00:54:50,450
where again where the first bit is zero

1426
00:54:50,450 --> 00:54:52,950
and then now it's now I want to go back

1427
00:54:52,950 --> 00:54:55,320
and try to insert C so now I look at

1428
00:54:55,320 --> 00:54:57,150
three bits that tells me I want to look

1429
00:54:57,150 --> 00:54:58,950
at this position here I follow the

1430
00:54:58,950 --> 00:55:00,300
pointer and then I'm be able to insert

1431
00:55:00,300 --> 00:55:03,900
into it so again this this movement here

1432
00:55:03,900 --> 00:55:05,180
look like it was kind of expensive like

1433
00:55:05,180 --> 00:55:07,849
sliding around but all I'm doing is just

1434
00:55:07,849 --> 00:55:10,050
splitting that one page I had before to

1435
00:55:10,050 --> 00:55:12,300
make another page so it's to pay page

1436
00:55:12,300 --> 00:55:14,040
rights plus the pages you have to update

1437
00:55:14,040 --> 00:55:16,890
for the for the slot array in the back

1438
00:55:16,890 --> 00:55:24,030
yes her question is is it not considered

1439
00:55:24,030 --> 00:55:26,040
to be expensive to remap the slot array

1440
00:55:26,040 --> 00:55:29,010
to all the new pages no because all I'm

1441
00:55:29,010 --> 00:55:30,930
really doing like these are still at the

1442
00:55:30,930 --> 00:55:34,920
same page ID in the files on disk so now

1443
00:55:34,920 --> 00:55:37,470
I'm just updating this again it's a

1444
00:55:37,470 --> 00:55:40,650
single array updating the values now

1445
00:55:40,650 --> 00:55:43,560
point to you know where the data is

1446
00:55:43,560 --> 00:55:45,180
actually stored so this operation is

1447
00:55:45,180 --> 00:55:58,020
cheap moving pages is expensive yes yes

1448
00:55:58,020 --> 00:56:00,750
so her question is what if say the first

1449
00:56:00,750 --> 00:56:03,540
one fills up won't say what would happen

1450
00:56:03,540 --> 00:56:06,210
well now I would split it and again the

1451
00:56:06,210 --> 00:56:08,369
lote the local counter is one so we

1452
00:56:08,369 --> 00:56:11,940
would increment that to two now yeah so

1453
00:56:11,940 --> 00:56:13,849
now it's split on two so now it would be

1454
00:56:13,849 --> 00:56:19,619
0 0 0 1 0 0 0 1 so anybody with zeros

1455
00:56:19,619 --> 00:56:21,359
over here these two entries would point

1456
00:56:21,359 --> 00:56:23,280
to the same thing and 0 ones are one

1457
00:56:23,280 --> 00:56:28,770
point of the same thing ok humors like

1458
00:56:28,770 --> 00:56:31,020
ok we'll get to that deletes yes pleats

1459
00:56:31,020 --> 00:56:35,930
are basic reverses the back yes

1460
00:56:39,880 --> 00:56:41,930
his question is are you storing the

1461
00:56:41,930 --> 00:56:44,359
entire page ID page in the in the solana

1462
00:56:44,359 --> 00:56:46,520
right here or is it just a page ID it's

1463
00:56:46,520 --> 00:56:50,150
just a page ID in the bucket this is

1464
00:56:50,150 --> 00:56:56,140
this each bucket would be a page yes

1465
00:57:02,109 --> 00:57:04,309
this question is what is it relation to

1466
00:57:04,309 --> 00:57:06,650
be in a hash tape on a buffer pool so at

1467
00:57:06,650 --> 00:57:08,859
a high level I'm ignoring that in

1468
00:57:08,859 --> 00:57:11,990
practice depending on whether you want

1469
00:57:11,990 --> 00:57:14,240
it to be durable to disk you would

1470
00:57:14,240 --> 00:57:15,920
allocate a page just as you would for

1471
00:57:15,920 --> 00:57:19,339
for a a table right a slot a page in

1472
00:57:19,339 --> 00:57:20,780
your buffer pool and you can store a

1473
00:57:20,780 --> 00:57:23,299
bucket page in that same thing the

1474
00:57:23,299 --> 00:57:24,819
buffer pool doesn't know doesn't care

1475
00:57:24,819 --> 00:57:27,440
you just say give me a page here's the

1476
00:57:27,440 --> 00:57:29,210
page ID and hand you back something some

1477
00:57:29,210 --> 00:57:30,530
memory address and you write some data

1478
00:57:30,530 --> 00:57:32,059
in there it doesn't know whether it's

1479
00:57:32,059 --> 00:57:33,680
part of a table or a part of a hash

1480
00:57:33,680 --> 00:57:35,569
table like this like a data table or a

1481
00:57:35,569 --> 00:57:40,520
hash table so again all the same

1482
00:57:40,520 --> 00:57:41,869
addiction algorithms you would use now

1483
00:57:41,869 --> 00:57:43,760
you want to see like how we're jumping

1484
00:57:43,760 --> 00:57:45,170
around this and accessing our hash table

1485
00:57:45,170 --> 00:57:46,609
it certainly look a lot different than

1486
00:57:46,609 --> 00:57:47,720
how we jump through and do the

1487
00:57:47,720 --> 00:57:50,150
sequential scans in a data table so

1488
00:57:50,150 --> 00:57:51,020
maybe you want different caching

1489
00:57:51,020 --> 00:57:53,170
policies for them or addiction policies

1490
00:57:53,170 --> 00:58:04,160
yes the statement is and I'm using three

1491
00:58:04,160 --> 00:58:06,799
bits at this point here to map hash

1492
00:58:06,799 --> 00:58:08,030
values to

1493
00:58:08,030 --> 00:58:11,480
slots and then it tells me what offset

1494
00:58:11,480 --> 00:58:14,270
to jump into right and then within that

1495
00:58:14,270 --> 00:58:16,040
slot in this array I would have a page

1496
00:58:16,040 --> 00:58:17,690
ID that I can then follow to get to the

1497
00:58:17,690 --> 00:58:23,990
bucket how's the mapping from page IDs

1498
00:58:23,990 --> 00:58:26,329
two buckets work yeah

1499
00:58:26,329 --> 00:58:30,450
it is like there's I'm using the term

1500
00:58:30,450 --> 00:58:32,539
bucket again instead of a page because

1501
00:58:32,539 --> 00:58:34,769
it this could be in memory it could be

1502
00:58:34,769 --> 00:58:36,630
back by disk it doesn't matter but you

1503
00:58:36,630 --> 00:58:38,450
can think of if it was backed by disk

1504
00:58:38,450 --> 00:58:42,599
then this these are the page IDs and the

1505
00:58:42,599 --> 00:58:44,569
bucket is a page and they're synonymous

1506
00:58:44,569 --> 00:58:46,529
so the only thing I need to store here

1507
00:58:46,529 --> 00:58:56,759
is page IDs absolutely statement is

1508
00:58:56,759 --> 00:59:00,180
again going back up here at this year my

1509
00:59:00,180 --> 00:59:03,359
global bit counter is two but I know

1510
00:59:03,359 --> 00:59:05,220
that I haven't split this first page

1511
00:59:05,220 --> 00:59:08,670
here it's local counters one so even

1512
00:59:08,670 --> 00:59:09,869
though if I wanted to look up I can look

1513
00:59:09,869 --> 00:59:13,109
at two bits but in practice I only care

1514
00:59:13,109 --> 00:59:14,849
about the first bit for this page here

1515
00:59:14,849 --> 00:59:16,559
so that's why these guys have the same

1516
00:59:16,559 --> 00:59:18,539
eight page ID bucket id whatever you

1517
00:59:18,539 --> 00:59:21,359
want they make a mat to the same

1518
00:59:21,359 --> 00:59:24,799
location because they have not split yet

1519
00:59:25,880 --> 00:59:27,779
it's quite the statement is which is

1520
00:59:27,779 --> 00:59:31,289
correct is after we do a reach a page we

1521
00:59:31,289 --> 00:59:32,729
just do a linear scan to find the thing

1522
00:59:32,729 --> 00:59:37,229
we want absolutely yes saving this isn't

1523
00:59:37,229 --> 00:59:41,009
that expensive again if I have a billion

1524
00:59:41,009 --> 00:59:44,849
tuples then doing that lookup to scan a

1525
00:59:44,849 --> 00:59:47,400
kilobyte page is nothing and they say

1526
00:59:47,400 --> 00:59:49,140
all right I want to be a bit more crafty

1527
00:59:49,140 --> 00:59:50,719
you've got smarter well maybe I store a

1528
00:59:50,719 --> 00:59:53,910
filter or some little pre computed

1529
00:59:53,910 --> 00:59:55,950
information at the top it says the key

1530
00:59:55,950 --> 00:59:57,479
look you know here's the list of keys

1531
00:59:57,479 --> 00:59:59,489
that I have it doesn't tell you where

1532
00:59:59,489 --> 01:00:01,019
they are it says that you have them so

1533
01:00:01,019 --> 01:00:02,309
you do that quick lookup to see whether

1534
01:00:02,309 --> 01:00:04,739
it's there but like that linear scan is

1535
01:00:04,739 --> 01:00:05,849
going to be super cheap compared to

1536
01:00:05,849 --> 01:00:07,739
reading it from disk or having new 20 an

1537
01:00:07,739 --> 01:00:14,789
entire data set okay so the other

1538
01:00:14,789 --> 01:00:17,999
dynamic hashing table is called linear

1539
01:00:17,999 --> 01:00:24,299
hashing so one problem with the with the

1540
01:00:24,299 --> 01:00:25,529
extent while hashing well it's not a

1541
01:00:25,529 --> 01:00:27,960
huge problem is that we're have to

1542
01:00:27,960 --> 01:00:30,529
double the size of the slaughtering

1543
01:00:30,529 --> 01:00:33,089
again computationally it's not that

1544
01:00:33,089 --> 01:00:34,710
expensive but while I'm doing that

1545
01:00:34,710 --> 01:00:37,229
resizing I have to take a latch on it

1546
01:00:37,229 --> 01:00:38,400
prevent anybody from reading and writing

1547
01:00:38,400 --> 01:00:40,049
it until I reallocate

1548
01:00:40,049 --> 01:00:42,329
everything so that will become a

1549
01:00:42,329 --> 01:00:43,650
bottleneck of everybody's trying to go

1550
01:00:43,650 --> 01:00:45,359
into that too my hash to about the exact

1551
01:00:45,359 --> 01:00:47,939
same time so with linear hashing the

1552
01:00:47,939 --> 01:00:49,679
ideas that we're gonna localize the

1553
01:00:49,679 --> 01:00:55,079
resizing to just be whatever the the the

1554
01:00:55,079 --> 01:00:58,019
bucket are that overflowed so we don't

1555
01:00:58,019 --> 01:00:59,699
have to take a global latch that locks

1556
01:00:59,699 --> 01:01:01,679
out everybody from accessing our hash

1557
01:01:01,679 --> 01:01:04,559
table so the way this is gonna work is

1558
01:01:04,559 --> 01:01:05,400
that we're gonna maintain multiple

1559
01:01:05,400 --> 01:01:07,679
hashes hash functions the same way we

1560
01:01:07,679 --> 01:01:09,299
did in cuckoo hashing again it's the

1561
01:01:09,299 --> 01:01:11,429
same hash function algorithm just

1562
01:01:11,429 --> 01:01:13,529
different seeds that are gonna tell us

1563
01:01:13,529 --> 01:01:15,179
where to jump to the right bucket for a

1564
01:01:15,179 --> 01:01:17,429
given key and we're gonna maintain this

1565
01:01:17,429 --> 01:01:19,199
new thing called a split pointer that's

1566
01:01:19,199 --> 01:01:21,390
gonna keep track of what's the next page

1567
01:01:21,390 --> 01:01:23,069
we want to overflow or do what we want

1568
01:01:23,069 --> 01:01:24,959
to split and then we incrementally

1569
01:01:24,959 --> 01:01:28,739
increase the size of our slot array so

1570
01:01:28,739 --> 01:01:31,259
how we decide when do it my flow can

1571
01:01:31,259 --> 01:01:33,179
depend on what we want to do it could

1572
01:01:33,179 --> 01:01:35,519
just be when we run out of entries in

1573
01:01:35,519 --> 01:01:38,459
our in our and our in a bucket and then

1574
01:01:38,459 --> 01:01:40,410
we that trigger the resize it could be

1575
01:01:40,410 --> 01:01:43,259
if the size of our bucket is larger than

1576
01:01:43,259 --> 01:01:44,689
the average size of all the buckets

1577
01:01:44,689 --> 01:01:47,299
again it's left up to the implementation

1578
01:01:47,299 --> 01:01:49,640
they all have different trade-offs

1579
01:01:49,640 --> 01:01:52,229
alright so it looks like this okay we

1580
01:01:52,229 --> 01:01:53,640
have a slot array that's gonna help

1581
01:01:53,640 --> 01:01:55,559
point to buckets just like I chain

1582
01:01:55,559 --> 01:01:58,559
hashing so again we're gonna add is now

1583
01:01:58,559 --> 01:02:00,390
this this new split pointer that's gonna

1584
01:02:00,390 --> 01:02:03,269
keep track of what's the next bucket we

1585
01:02:03,269 --> 01:02:04,559
want to split whenever we have an

1586
01:02:04,559 --> 01:02:08,759
overflow anywhere in our hash table so

1587
01:02:08,759 --> 01:02:11,160
we're gonna split the the bucket point

1588
01:02:11,160 --> 01:02:14,069
to by position zero whenever any other

1589
01:02:14,069 --> 01:02:15,989
bucket not just when bucket zero gets

1590
01:02:15,989 --> 01:02:17,339
overflowed so if any of these other guys

1591
01:02:17,339 --> 01:02:21,420
overflow we won't we will split 0 even

1592
01:02:21,420 --> 01:02:23,299
even if it's not the one that overflowed

1593
01:02:23,299 --> 01:02:28,199
so at this point here our split pointer

1594
01:02:28,199 --> 01:02:29,819
is at the bit is at the beginning of our

1595
01:02:29,819 --> 01:02:32,099
slot array so we only have one hash

1596
01:02:32,099 --> 01:02:34,079
function all right I'm a member just

1597
01:02:34,079 --> 01:02:37,229
gonna modify the the number of entries

1598
01:02:37,229 --> 01:02:41,130
that we have so let's say I do I look

1599
01:02:41,130 --> 01:02:44,670
upon on six I just hash it mod by four I

1600
01:02:44,670 --> 01:02:46,949
jump to location do a linear scan so I

1601
01:02:46,949 --> 01:02:49,049
find the key that I want right that just

1602
01:02:49,049 --> 01:02:50,640
works just just like before under chain

1603
01:02:50,640 --> 01:02:52,769
hashing but now let's say I want to

1604
01:02:52,769 --> 01:02:53,649
insert seven

1605
01:02:53,649 --> 01:02:57,349
all right I hash it 17 mod for I'll and

1606
01:02:57,349 --> 01:02:59,779
to this position here but now I don't

1607
01:02:59,779 --> 01:03:02,119
have any more free slots or free entries

1608
01:03:02,119 --> 01:03:04,099
in my in my bucket so I'm gonna have to

1609
01:03:04,099 --> 01:03:06,739
create an overflow bucket right and

1610
01:03:06,739 --> 01:03:07,819
since you just create again the chain

1611
01:03:07,819 --> 01:03:09,589
link list and then that's where I insert

1612
01:03:09,589 --> 01:03:13,609
17 but because I now overflowed that's

1613
01:03:13,609 --> 01:03:15,409
gonna trigger a split

1614
01:03:15,409 --> 01:03:16,880
wherever the split pointer is pointing

1615
01:03:16,880 --> 01:03:21,139
at so even though 0 still is I can take

1616
01:03:21,139 --> 01:03:23,029
entries in it i over float once

1617
01:03:23,029 --> 01:03:25,699
somewhere that can cause me to overflow

1618
01:03:25,699 --> 01:03:28,749
so the way this is going to work is that

1619
01:03:28,749 --> 01:03:33,199
we're gonna add a 1 new entry to our

1620
01:03:33,199 --> 01:03:36,469
slot array now position 4 and then we're

1621
01:03:36,469 --> 01:03:37,909
gonna have a new hash function that now

1622
01:03:37,909 --> 01:03:42,889
mods by 2 n right the idea is that as we

1623
01:03:42,889 --> 01:03:44,059
keep splitting down and down we'll keep

1624
01:03:44,059 --> 01:03:45,889
adding new entries until we're 2 N or

1625
01:03:45,889 --> 01:03:47,209
toward twice as big as where we were

1626
01:03:47,209 --> 01:03:49,159
before we add it here before we started

1627
01:03:49,159 --> 01:03:52,369
doing splitting so the way this is gonna

1628
01:03:52,369 --> 01:03:53,959
work is that we need to keep the split

1629
01:03:53,959 --> 01:03:54,979
poner is going to keep track for us

1630
01:03:54,979 --> 01:03:56,569
whether we want to use the first hash

1631
01:03:56,569 --> 01:03:57,829
function or the second hash function

1632
01:03:57,829 --> 01:04:00,049
they tell us how far along we split in

1633
01:04:00,049 --> 01:04:02,630
our slaughtering all right so in this

1634
01:04:02,630 --> 01:04:06,229
case here we we add the new entry for

1635
01:04:06,229 --> 01:04:08,329
recreate a new bucket and then this is

1636
01:04:08,329 --> 01:04:12,109
where we insert 20 into and we move this

1637
01:04:12,109 --> 01:04:14,389
foot pointer down by one so the split

1638
01:04:14,389 --> 01:04:15,769
pointer is essentially this demarcation

1639
01:04:15,769 --> 01:04:18,199
line here so the basically says that

1640
01:04:18,199 --> 01:04:20,899
whenever I want to do a lookup I first

1641
01:04:20,899 --> 01:04:22,399
hash it the first hash function so I say

1642
01:04:22,399 --> 01:04:24,829
I wanna do a lookup on 20 I put the

1643
01:04:24,829 --> 01:04:26,239
first hash function and that's gonna

1644
01:04:26,239 --> 01:04:28,999
take me from 0 to 3 and then if the

1645
01:04:28,999 --> 01:04:31,279
thing I'm pointing to is above where

1646
01:04:31,279 --> 01:04:32,839
that demarcation line is for the split

1647
01:04:32,839 --> 01:04:36,049
pointer then I know that the the bucket

1648
01:04:36,049 --> 01:04:37,309
that I'm looking at has already been

1649
01:04:37,309 --> 01:04:39,529
split so therefore now I need to look at

1650
01:04:39,529 --> 01:04:40,759
the second hash function and decide

1651
01:04:40,759 --> 01:04:42,399
where I really want to go for the data

1652
01:04:42,399 --> 01:04:46,909
so now when I do a look about 20 I hash

1653
01:04:46,909 --> 01:04:48,529
should use the second hash function I

1654
01:04:48,529 --> 01:04:51,109
mod that number by 8 because that's to

1655
01:04:51,109 --> 01:04:53,179
end where I started wet and then that

1656
01:04:53,179 --> 01:04:57,130
tells me that I want to jump down here

1657
01:04:57,160 --> 01:05:00,190
same thing I do a final nine nine would

1658
01:05:00,190 --> 01:05:03,970
land here that's below or above the

1659
01:05:03,970 --> 01:05:05,860
split pointer basically you know

1660
01:05:05,860 --> 01:05:07,810
perceive it but it's you know it has

1661
01:05:07,810 --> 01:05:09,820
been split yet so therefore I only need

1662
01:05:09,820 --> 01:05:10,900
to look at the first hash function to

1663
01:05:10,900 --> 01:05:14,130
find the thing that I'm looking for so

1664
01:05:14,700 --> 01:05:26,590
is this sort of clear yes so question is

1665
01:05:26,590 --> 01:05:29,550
back up here when I insert a seventeen

1666
01:05:29,550 --> 01:05:32,290
isn't this is what overflowed why did I

1667
01:05:32,290 --> 01:05:33,490
split the first one and not this one

1668
01:05:33,490 --> 01:05:34,840
because that's the way leaner hashing

1669
01:05:34,840 --> 01:05:36,730
works the algorithm works that you own

1670
01:05:36,730 --> 01:05:38,260
if you split whatever the split pointer

1671
01:05:38,260 --> 01:05:40,600
works at looks at no matter whether this

1672
01:05:40,600 --> 01:05:42,220
thing whether it was one that overflowed

1673
01:05:42,220 --> 01:05:44,620
or not because eventually like if this

1674
01:05:44,620 --> 01:05:46,750
thing keeps on overflowing that'll keep

1675
01:05:46,750 --> 01:05:47,890
moving the split pointer down by one

1676
01:05:47,890 --> 01:05:50,650
eventually I will get to this I will get

1677
01:05:50,650 --> 01:05:53,050
to every one split split it and then

1678
01:05:53,050 --> 01:06:05,680
loop back around start over again so the

1679
01:06:05,680 --> 01:06:07,480
statement is if I end up splitting this

1680
01:06:07,480 --> 01:06:10,720
one here right say the slope one is down

1681
01:06:10,720 --> 01:06:13,090
now I split it I will then you know use

1682
01:06:13,090 --> 01:06:14,710
the second hash function to decide how

1683
01:06:14,710 --> 01:06:20,560
to redistribute them correct you

1684
01:06:20,560 --> 01:06:23,290
reassure all the all the values or all

1685
01:06:23,290 --> 01:06:24,700
the key instances that map to that's

1686
01:06:24,700 --> 01:06:27,790
that bucket and then delete the overflow

1687
01:06:27,790 --> 01:06:30,310
yes now may be the case that like say

1688
01:06:30,310 --> 01:06:32,350
this guy was you know this overflow

1689
01:06:32,350 --> 01:06:34,600
thing was at the bottom here so I kept

1690
01:06:34,600 --> 01:06:35,740
inserting to it I can't we're floating

1691
01:06:35,740 --> 01:06:37,840
and I kept triggering splits and then by

1692
01:06:37,840 --> 01:06:40,900
the time I get down to split it again it

1693
01:06:40,900 --> 01:06:43,780
may also overflow as well that's just

1694
01:06:43,780 --> 01:06:45,610
how the algorithm works and you loop

1695
01:06:45,610 --> 01:06:47,980
back around do it again so worst case

1696
01:06:47,980 --> 01:06:49,750
scenario the everybody's inserting to

1697
01:06:49,750 --> 01:06:51,490
the same bucket and it takes a long time

1698
01:06:51,490 --> 01:06:53,950
for it to split in practice though with

1699
01:06:53,950 --> 01:06:55,060
a good hash function in the local ocean

1700
01:06:55,060 --> 01:07:01,170
rate this shouldn't happen okay so the

1701
01:07:01,170 --> 01:07:03,190
rights against splitting the bucket just

1702
01:07:03,190 --> 01:07:06,010
basically means that although we're not

1703
01:07:06,010 --> 01:07:07,000
splitting the one that overflowed

1704
01:07:07,000 --> 01:07:08,290
eventually we will get to it eventually

1705
01:07:08,290 --> 01:07:09,700
everyone get split and then everything

1706
01:07:09,700 --> 01:07:10,240
will balance

1707
01:07:10,240 --> 01:07:13,960
so in this example I only showed inserts

1708
01:07:13,960 --> 01:07:16,359
the pointer can also move backwards if

1709
01:07:16,359 --> 01:07:18,970
you start doing deletes and same weekend

1710
01:07:18,970 --> 01:07:20,140
you can reverse the extendable hash

1711
01:07:20,140 --> 01:07:20,980
engine if you wanna start deleting

1712
01:07:20,980 --> 01:07:24,369
things to start coalescing coalescing

1713
01:07:24,369 --> 01:07:26,589
buckets but in practice though this is

1714
01:07:26,589 --> 01:07:29,890
quite tricky so let's go back to where

1715
01:07:29,890 --> 01:07:31,390
we were before right

1716
01:07:31,390 --> 01:07:33,760
split pointer was pointing here and

1717
01:07:33,760 --> 01:07:35,560
we've almost put it we only split the

1718
01:07:35,560 --> 01:07:37,990
the the first entry position 0 in a slot

1719
01:07:37,990 --> 01:07:42,670
array so now if I want to delete 20 so I

1720
01:07:42,670 --> 01:07:44,770
hash the first one that takes me to 0

1721
01:07:44,770 --> 01:07:48,730
but this position here is is you know

1722
01:07:48,730 --> 01:07:50,770
above our demarcation line for the split

1723
01:07:50,770 --> 01:07:52,900
pointer so I need a hash it again and I

1724
01:07:52,900 --> 01:07:54,460
land here now I could find the entry

1725
01:07:54,460 --> 01:07:56,650
that I want so now I'm going to delete

1726
01:07:56,650 --> 01:08:00,180
this guy and now the page is entry empty

1727
01:08:00,180 --> 01:08:04,150
so I could just leave it alone and does

1728
01:08:04,150 --> 01:08:06,490
assume that's later on I'll go ahead and

1729
01:08:06,490 --> 01:08:08,619
fill it up again but if I wanted to

1730
01:08:08,619 --> 01:08:10,180
start doing compacting I want to start

1731
01:08:10,180 --> 01:08:12,730
reclaiming memory then I just do all the

1732
01:08:12,730 --> 01:08:14,140
same steps that I did before and reverse

1733
01:08:14,140 --> 01:08:17,080
it all right so I blow away the bucket

1734
01:08:17,080 --> 01:08:20,140
blow away this pointer moved the slip

1735
01:08:20,140 --> 01:08:22,299
pointer back up by 1 and now this thing

1736
01:08:22,299 --> 01:08:24,100
goes away my hash function goes away and

1737
01:08:24,100 --> 01:08:28,450
I've reclaimed the memory right just

1738
01:08:28,450 --> 01:08:29,560
getting just doing all the steps in

1739
01:08:29,560 --> 01:08:38,380
reverse order yes his question is do I

1740
01:08:38,380 --> 01:08:39,790
eventually remove hash functions after

1741
01:08:39,790 --> 01:08:42,580
you remove all the tables yes I think

1742
01:08:42,580 --> 01:08:44,439
after you get down to the bottom I think

1743
01:08:44,439 --> 01:08:47,488
at most you have two hash functions

1744
01:08:50,609 --> 01:08:53,200
statement is instead of having 20 if I

1745
01:08:53,200 --> 01:08:55,000
also delete 11 what the same thing

1746
01:08:55,000 --> 01:09:03,600
happen missing what you're saying sorry

1747
01:09:03,600 --> 01:09:05,439
yeah you can't read you should because

1748
01:09:05,439 --> 01:09:08,500
it because then the hash function is it

1749
01:09:08,500 --> 01:09:10,330
has to be terminus ik same key should

1750
01:09:10,330 --> 01:09:11,500
always produce the same hash value so we

1751
01:09:11,500 --> 01:09:13,390
know exactly where to find it in the

1752
01:09:13,390 --> 01:09:15,509
back

1753
01:09:20,830 --> 01:09:23,899
yeah so her say that is if I go back

1754
01:09:23,899 --> 01:09:26,450
here if I was here and I did leave his

1755
01:09:26,450 --> 01:09:29,770
six six I would have to leave there

1756
01:09:29,770 --> 01:09:31,670
correct there's only one hash function

1757
01:09:31,670 --> 01:09:33,380
so if I try to remove this I can't

1758
01:09:33,380 --> 01:09:35,540
resize this one down here so I just

1759
01:09:35,540 --> 01:09:41,270
leave that empty yes so anything I surf

1760
01:09:41,270 --> 01:09:42,770
flash it already but what's the what's

1761
01:09:42,770 --> 01:09:44,710
that obvious prom why this would be

1762
01:09:44,710 --> 01:09:47,149
problematic if I if I do actually

1763
01:09:47,149 --> 01:09:49,670
you know deleted the page and removed it

1764
01:09:49,670 --> 01:09:51,560
and then put the slim pointer back up by

1765
01:09:51,560 --> 01:09:55,940
one exactly where the very next thing I

1766
01:09:55,940 --> 01:09:59,150
do is insert 21 now I overflow now I

1767
01:09:59,150 --> 01:10:00,110
gotta split what everything's pointing

1768
01:10:00,110 --> 01:10:01,580
at and I just do all the same crap over

1769
01:10:01,580 --> 01:10:06,530
again right so again the this is what I

1770
01:10:06,530 --> 01:10:08,150
was saying that leggy when you decide to

1771
01:10:08,150 --> 01:10:10,340
do an overflow maybe don't do exactly at

1772
01:10:10,340 --> 01:10:12,620
the moment you know you insert something

1773
01:10:12,620 --> 01:10:14,210
into an overload chain so maybe wait

1774
01:10:14,210 --> 01:10:15,590
till this thing overflows again and then

1775
01:10:15,590 --> 01:10:19,310
then you split or two pages become

1776
01:10:19,310 --> 01:10:20,540
buckets kind of empty man you shut

1777
01:10:20,540 --> 01:10:25,190
reversing so people that have spent a

1778
01:10:25,190 --> 01:10:26,950
lot of time making the inserts go fast

1779
01:10:26,950 --> 01:10:28,970
deletes are harder to do because in

1780
01:10:28,970 --> 01:10:31,700
practice and maybe defeat some cases

1781
01:10:31,700 --> 01:10:32,900
might be better to rebuild the entire

1782
01:10:32,900 --> 01:10:35,000
index but you can do incremental deletes

1783
01:10:35,000 --> 01:10:41,510
with these data structures okay all

1784
01:10:41,510 --> 01:10:45,710
right so the we spent today talking

1785
01:10:45,710 --> 01:10:48,620
about hash tables again these are fast

1786
01:10:48,620 --> 01:10:50,330
data structures that that on average

1787
01:10:50,330 --> 01:10:54,230
will do oh one book ups for for you know

1788
01:10:54,230 --> 01:10:56,330
fine keys and we're gonna use this all

1789
01:10:56,330 --> 01:10:58,250
throughout the internals of the database

1790
01:10:58,250 --> 01:11:00,650
system for as we execute queries for

1791
01:11:00,650 --> 01:11:01,850
page tables and immediate data

1792
01:11:01,850 --> 01:11:05,780
structures in practice though and for at

1793
01:11:05,780 --> 01:11:08,300
the application level a hash table is

1794
01:11:08,300 --> 01:11:09,530
usually not what you're gonna want to

1795
01:11:09,530 --> 01:11:12,830
use for a table index database desin

1796
01:11:12,830 --> 01:11:14,240
will let you do this some systems will

1797
01:11:14,240 --> 01:11:15,950
say when I call create index I want to

1798
01:11:15,950 --> 01:11:18,230
use a hash table but when I call create

1799
01:11:18,230 --> 01:11:20,170
index in most systems without any

1800
01:11:20,170 --> 01:11:22,040
specification what data structure to use

1801
01:11:22,040 --> 01:11:24,380
I'm not gonna get a hash table I'm still

1802
01:11:24,380 --> 01:11:26,510
going to be getting an order preserving

1803
01:11:26,510 --> 01:11:28,850
index and this is because the hash table

1804
01:11:28,850 --> 01:11:31,460
can only do exact key equality

1805
01:11:31,460 --> 01:11:32,550
predicates quality look

1806
01:11:32,550 --> 01:11:34,170
meaning if I want to see whether key

1807
01:11:34,170 --> 01:11:37,080
exists I have to have the entire key to

1808
01:11:37,080 --> 01:11:38,580
do a lookup but I can't do a partial key

1809
01:11:38,580 --> 01:11:40,890
look up and I can't say find me all the

1810
01:11:40,890 --> 01:11:43,710
key is less than my given key because

1811
01:11:43,710 --> 01:11:45,030
again the hash function can't do that

1812
01:11:45,030 --> 01:11:48,990
for you so in practice this is not what

1813
01:11:48,990 --> 01:11:51,090
you want to use and we'll do demos next

1814
01:11:51,090 --> 01:11:52,770
time with my sequin Postgres and we'll

1815
01:11:52,770 --> 01:11:53,910
show that performance implications of

1816
01:11:53,910 --> 01:11:54,240
this

1817
01:11:54,240 --> 01:11:57,030
so instead but you mostly get when you

1818
01:11:57,030 --> 01:12:00,680
call create index is the beloved B+ tree

1819
01:12:00,680 --> 01:12:03,300
it was called the ubiquitous B+ tree of

1820
01:12:03,300 --> 01:12:06,450
ubiquitous data structure in 1979 and

1821
01:12:06,450 --> 01:12:09,120
4050 years later it's still the best

1822
01:12:09,120 --> 01:12:10,710
data structure out there my opinion and

1823
01:12:10,710 --> 01:12:12,360
pretty much every single database system

1824
01:12:12,360 --> 01:12:13,740
it's going to have some kind of B+ tree

1825
01:12:13,740 --> 01:12:15,960
implementation except for those systems

1826
01:12:15,960 --> 01:12:17,220
that are like you know memcache that are

1827
01:12:17,220 --> 01:12:20,340
just a hash table entirely every single

1828
01:12:20,340 --> 01:12:21,540
major data system is gonna be used

1829
01:12:21,540 --> 01:12:22,860
something that looks like a P plus tree

1830
01:12:22,860 --> 01:12:26,040
or straight-up B plus tree now they're

1831
01:12:26,040 --> 01:12:27,750
gonna differ on how they actually store

1832
01:12:27,750 --> 01:12:30,360
things and do searches in some ways but

1833
01:12:30,360 --> 01:12:32,010
at a high level we'll talk about on

1834
01:12:32,010 --> 01:12:34,140
Wednesday will be the sort of the

1835
01:12:34,140 --> 01:12:37,370
canonical B+ tree again it's everywhere

1836
01:12:37,370 --> 01:12:42,410
okay so any questions

1837
01:12:51,890 --> 01:12:54,930
it's wixi nights in my system racking up

1838
01:12:54,930 --> 01:13:03,120
let's go get the next one get over there

1839
01:13:03,120 --> 01:13:03,930
with me son

1840
01:13:03,930 --> 01:13:05,940
ricochet jelly hit the deli for the boat

1841
01:13:05,940 --> 01:13:08,010
one naturally bless ya what rappers like

1842
01:13:08,010 --> 01:13:09,990
the laser beam the pawns in the bush say

1843
01:13:09,990 --> 01:13:12,210
not even like a chain wrap the bottle of

1844
01:13:12,210 --> 01:13:15,150
us if we go don't bail out drinking that

1845
01:13:15,150 --> 01:13:17,610
boney - you talking can't cross the line

1846
01:13:17,610 --> 01:13:19,410
and if the sake don't know you

1847
01:13:19,410 --> 01:13:22,340
can't a pain pain

