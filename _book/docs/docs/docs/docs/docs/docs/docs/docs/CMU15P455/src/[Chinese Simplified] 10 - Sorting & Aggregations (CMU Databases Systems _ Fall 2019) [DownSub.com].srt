1
00:00:06,920 --> 00:00:18,140
哦，伙计们，让我们再次开始吧

2
00:00:18,140 --> 00:00:20,359
，谢谢 DJ 放下桌子，

3
00:00:20,359 --> 00:00:23,380
或者继续为我们准备好一切，

4
00:00:23,380 --> 00:00:26,779
所以在我们进入今天的

5
00:00:26,779 --> 00:00:28,699
讲座之前，请快速浏览

6
00:00:28,699 --> 00:00:30,320
一下你们接下来两周的日程安排，

7
00:00:30,320 --> 00:00:32,540
所以

8
00:00:32,540 --> 00:00:35,810
家庭作业三 今天出来了，它应该

9
00:00:35,810 --> 00:00:38,270
在网站上，我们会设置很棒的

10
00:00:38,270 --> 00:00:39,440
脚本，这样你就可以在今天晚些时候提交

11
00:00:39,440 --> 00:00:41,690
，所以这将

12
00:00:41,690 --> 00:00:45,500
在下周的第 9 日星期三到期，我们将

13
00:00:45,500 --> 00:00:48,859
有期中考试项目管

14
00:00:48,859 --> 00:00:49,879
出去

15
00:00:49,879 --> 00:00:51,260
今天我会讲一点我会

16
00:00:51,260 --> 00:00:52,789
在这次小姐讲座结束时讲到

17
00:00:52,789 --> 00:00:54,859
那将在

18
00:00:54,859 --> 00:00:56,750
期中考试之后到期 期中考试将

19
00:00:56,750 --> 00:01:00,949
在 16 日星期三在这个房间的正常

20
00:01:00,949 --> 00:01:02,870
上课时间 你知道一个小时

21
00:01:02,870 --> 00:01:04,879
20 分钟的考试，所以这将

22
00:01:04,879 --> 00:01:07,760
涵盖包括下周讲座在内的所有内容，

23
00:01:07,760 --> 00:01:10,310
所以在 9 号星期三

24
00:01:10,310 --> 00:01:12,439
，期中考试将涵盖该讲座以及

25
00:01:12,439 --> 00:01:16,490
之前的所有

26
00:01:16,490 --> 00:01:17,180
内容，关于这些期望的任何问题，

27
00:01:17,180 --> 00:01:20,900
所以家庭作业编号 t

28
00:01:20,900 --> 00:01:22,579
在期中考试之前解决

29
00:01:22,579 --> 00:01:25,100
这个问题，然后这个项目二它会

30
00:01:25,100 --> 00:01:28,040
包含我们

31
00:01:28,040 --> 00:01:29,119
讨论过的一些与中期相关的材料，

32
00:01:29,119 --> 00:01:31,159
但我们不会在期中之后正式这样做

33
00:01:31,159 --> 00:01:33,530
，所以你

34
00:01:33,530 --> 00:01:37,090
要留出空间 对你们来说，好的，

35
00:01:37,090 --> 00:01:40,520
所以我们在本

36
00:01:40,520 --> 00:01:43,909
学期的情况是，我们再次进入

37
00:01:43,909 --> 00:01:46,280
这个架构层，我们知道如何

38
00:01:46,280 --> 00:01:49,189
在磁盘上以页面的形式存储东西我们知道

39
00:01:49,189 --> 00:01:50,689
如何然后将它们复制到内存

40
00:01:50,689 --> 00:01:52,789
中 缓冲池管理器根据需要然后

41
00:01:52,789 --> 00:01:54,350
我们讨论了我们如何实际访问

42
00:01:54,350 --> 00:01:56,689
它们，以便我们可以在它们之上构建索引，

43
00:01:56,689 --> 00:01:58,549
或者我们可以进行顺序扫描，

44
00:01:58,549 --> 00:02:01,700
所以现在我们所处的位置在上面，现在我们

45
00:02:01,700 --> 00:02:03,170
实际上想要开始执行

46
00:02:03,170 --> 00:02:05,119
我们实际的查询 希望能够进行

47
00:02:05,119 --> 00:02:07,670
后续查询 为它们生成查询计划

48
00:02:07,670 --> 00:02:10,520
，然后让它们使用访问

49
00:02:10,520 --> 00:02:12,200
方法来访问我们需要的数据，

50
00:02:12,200 --> 00:02:16,040
所以在接下来的两周内，

51
00:02:16,040 --> 00:02:17,480
我们将首先讨论

52
00:02:17,480 --> 00:02:19,310
我们实际上如何 实现算法 s

53
00:02:19,310 --> 00:02:21,019
对于我们的运营商，

54
00:02:21,019 --> 00:02:22,700
然后我们将讨论

55
00:02:22,700 --> 00:02:25,040
处理查询本身的不同方法，例如

56
00:02:25,040 --> 00:02:27,500
如何将数据从一个运营商移至下一个运营商

57
00:02:27,500 --> 00:02:29,540
，然后我们还将

58
00:02:29,540 --> 00:02:32,180
讨论更多的系统架构是

59
00:02:32,180 --> 00:02:34,340
运行时架构

60
00:02:34,340 --> 00:02:35,840
线程或进程的系统以及我们如何

61
00:02:35,840 --> 00:02:37,760
组织它们以并行运行您知道的查询，

62
00:02:37,760 --> 00:02:41,480
所以我不会详细介绍

63
00:02:41,480 --> 00:02:43,970
查询计划的样子，我

64
00:02:43,970 --> 00:02:45,590
只想向您展示一个

65
00:02:45,590 --> 00:02:47,510
可能的样子，只是为了构建

66
00:02:47,510 --> 00:02:48,889
它 我们今天要去的

67
00:02:48,889 --> 00:02:51,379
地方和下一堂课的对话，然后我们

68
00:02:51,379 --> 00:02:53,329
将详细

69
00:02:53,329 --> 00:02:55,430
介绍下周查询计划和执行的情况

70
00:02:55,430 --> 00:02:56,420
，然后当我们进一步讨论查询

71
00:02:56,420 --> 00:02:59,139
优化查询计划时，

72
00:02:59,139 --> 00:03:01,510
查询星球本质上是

73
00:03:01,510 --> 00:03:03,859


74
00:03:03,859 --> 00:03:06,829
数据库系统将如何

75
00:03:06,829 --> 00:03:09,200
执行给定查询的指令或高级方向，我们将

76
00:03:09,200 --> 00:03:11,870
查询计划组织成

77
00:03:11,870 --> 00:03:14,060
树状结构或无环有

78
00:03:14,060 --> 00:03:16,730
向图，所以我们

79
00:03:16,730 --> 00:03:18,200
像这样执行续集查询或

80
00:03:18,200 --> 00:03:20,450
在表 a 和 B 上使用过滤器进行连接，我们可以将其

81
00:03:20,450 --> 00:03:22,939
表示为这样的查询计划，其中

82
00:03:22,939 --> 00:03:25,190
在叶节点处进行扫描或

83
00:03:25,190 --> 00:03:27,680
访问表，

84
00:03:27,680 --> 00:03:29,510
然后移动元组 直到下一个

85
00:03:29,510 --> 00:03:31,699
操作员做任何它想做的

86
00:03:31,699 --> 00:03:34,370
事情，在这种情况下，我们扫描 a，因为

87
00:03:34,370 --> 00:03:35,659
我们没有任何过滤器，我们只是

88
00:03:35,659 --> 00:03:37,159
将它直接输入我们的联合操作员

89
00:03:37,159 --> 00:03:39,290
，然后首先应用 B 上的扫描

90
00:03:39,290 --> 00:03:43,040
过滤器将任何

91
00:03:43,040 --> 00:03:44,989
小于 F 的值限制为 100，然后我们将其

92
00:03:44,989 --> 00:03:46,699
输入我们的连接运算符，然后现在

93
00:03:46,699 --> 00:03:48,229
产生一些输出，然后

94
00:03:48,229 --> 00:03:52,699
输入投影运算符，所以我在

95
00:03:52,699 --> 00:03:54,769
这里展示的是我们

96
00:03:54,769 --> 00:03:58,430
称之为 合乎逻辑的计划意味着我

97
00:03:58,430 --> 00:04:00,859
没有说我们将如何

98
00:04:00,859 --> 00:04:02,720
使用 albs 来实现所有这些

99
00:04:02,720 --> 00:04:04,099
不同的运算符 我只是说这

100
00:04:04,099 --> 00:04:05,720
是一个高低 我想做的

101
00:04:05,720 --> 00:04:07,340
是最像一个直接

102
00:04:07,340 --> 00:04:09,109
关系代数的翻译我想做一个

103
00:04:09,109 --> 00:04:11,000
连接我不告诉你

104
00:04:11,000 --> 00:04:12,379
我想怎么做才能加入我们 我只想

105
00:04:12,379 --> 00:04:14,479
在 a 上做一个，而 BI 想拉一些 a

106
00:04:14,479 --> 00:04:16,039
我没有告诉你是做 scruncho

107
00:04:16,039 --> 00:04:17,720
扫描还是索引扫描 我只是说

108
00:04:17,720 --> 00:04:20,509
从 a 中获取元组 所以我们

109
00:04:20,509 --> 00:04:22,699
今天关注的是现在讨论这些

110
00:04:22,699 --> 00:04:24,949
算法实际上是什么，然后

111
00:04:24,949 --> 00:04:25,909
当我们讨论

112
00:04:25,909 --> 00:04:27,530
查询计划查询优化时我们将把它们放在一起说

113
00:04:27,530 --> 00:04:29,240
现在我们需要在这里做出决定

114
00:04:29,240 --> 00:04:30,440
我

115
00:04:30,440 --> 00:04:31,700
可以使用的算法或我

116
00:04:31,700 --> 00:04:33,470
可以用于我的查询的不同访问方法，这

117
00:04:33,470 --> 00:04:35,750
对我来说是最好的，所以今天的

118
00:04:35,750 --> 00:04:36,860
讲座真正关注

119
00:04:36,860 --> 00:04:38,600
和-和-以及周三的讲座

120
00:04:38,600 --> 00:04:40,130
以及本周

121
00:04:40,130 --> 00:04:41,420
我们可以使用哪些不同的算法

122
00:04:41,420 --> 00:04:44,210
在我们的查询计划中实现物理运算符，

123
00:04:44,210 --> 00:04:46,130
但在较高的层次上，我们

124
00:04:46,130 --> 00:04:47,420
假设它在这个树结构中，

125
00:04:47,420 --> 00:04:49,580
我们将两个公牛从一个运算符

126
00:04:49,580 --> 00:04:53,720
移到另一个

127
00:04:53,720 --> 00:04:55,280


128
00:04:55,280 --> 00:04:58,220
查询引擎会做对

129
00:04:58,220 --> 00:04:59,570
它们将表示为一种

130
00:04:59,570 --> 00:05:01,790
数据流树，并且它们

131
00:05:01,790 --> 00:05:05,120
在它们之间移动元组，所以这很棘手，尽管

132
00:05:05,120 --> 00:05:08,150
现在对我们来说，当我们开始决定

133
00:05:08,150 --> 00:05:09,380
我们知道如何

134
00:05:09,380 --> 00:05:10,970
为这些

135
00:05:10,970 --> 00:05:14,750
运算符实际实现算法时，我们又是整个

136
00:05:14,750 --> 00:05:17,060
学期的重点

137
00:05:17,060 --> 00:05:19,250
是假设数据不完全适合

138
00:05:19,250 --> 00:05:22,040
内存的系统，就像在

139
00:05:22,040 --> 00:05:23,750
我们的磁盘或新数据库系统中一样，

140
00:05:23,750 --> 00:05:25,490
就像我们不能假设表

141
00:05:25,490 --> 00:05:27,470
完全适合内存，而索引不能完全适合

142
00:05:27,470 --> 00:05:29,990
我们现在需要的内存 担心

143
00:05:29,990 --> 00:05:31,940


144
00:05:31,940 --> 00:05:34,370
这些运算符之间的中间结果实际上不能

145
00:05:34,370 --> 00:05:37,160
完全适合主内存，因此

146
00:05:37,160 --> 00:05:38,870
当我们设计将用于执行的算法时

147
00:05:38,870 --> 00:05:42,110
，您知道

148
00:05:42,110 --> 00:05:44,570
我们需要的运算符，我们需要选择

149
00:05:44,570 --> 00:05:46,580
那些真正知道如何编写的运算符

150
00:05:46,580 --> 00:05:47,990
磁盘上的数据，并注意我们可能必须

151
00:05:47,990 --> 00:05:49,190
从磁盘读取和写入数据，

152
00:05:49,190 --> 00:05:50,720
因此我们将

153
00:05:50,720 --> 00:05:52,790
在这些算法中做出某些设计决策以

154
00:05:52,790 --> 00:05:55,430
正确地适应它们，所以 j 举个

155
00:05:55,430 --> 00:05:57,440
简单的例子，我

156
00:05:57,440 --> 00:06:00,830
在哈希表的 a 和 B 上做一个联合，或者取决于

157
00:06:00,830 --> 00:06:02,210
你知道我将使用什么联合专辑

158
00:06:02,210 --> 00:06:04,610
我可能不得不像

159
00:06:04,610 --> 00:06:06,650
a 不适合内存 B 一样溢出磁盘 不适合

160
00:06:06,650 --> 00:06:08,150
内存所以我需要加入

161
00:06:08,150 --> 00:06:10,790
可以处理你知道输入的算法，其中

162
00:06:10,790 --> 00:06:11,990
整个数据集可能不适合内存，

163
00:06:11,990 --> 00:06:14,150
而且输出也可能不适合

164
00:06:14,150 --> 00:06:16,430
完全主内存，所以我们将再次

165
00:06:16,430 --> 00:06:17,990
使用我们的缓冲池管理器

166
00:06:17,990 --> 00:06:20,270
我们在之前讨论过的第一个项目中构建了这

167
00:06:20,270 --> 00:06:22,400
就是我们如何

168
00:06:22,400 --> 00:06:24,590
能够适应需要

169
00:06:24,590 --> 00:06:26,890
比实际可用内存更多的内存的算法，

170
00:06:26,890 --> 00:06:29,360
所以我们不用于表而不是

171
00:06:29,360 --> 00:06:32,750
用于索引我们可以将它用于

172
00:06:32,750 --> 00:06:34,610
中间 结果，这又

173
00:06:34,610 --> 00:06:36,680
回到了我之前说的

174
00:06:36,680 --> 00:06:38,720
原因，这就是为什么你知道数据库系统是否

175
00:06:38,720 --> 00:06:40,400
结束只是一个内存而不是

176
00:06:40,400 --> 00:06:42,770
让操作系统来做，操作系统可以哦哦，这个页面

177
00:06:42,770 --> 00:06:45,140
是一个临时数据结构来做

178
00:06:45,140 --> 00:06:46,880
我的任何事情 查询是，我会

179
00:06:46,880 --> 00:06:48,740
立即抛出 在查询结束之后，

180
00:06:48,740 --> 00:06:50,570
也许我想做不同的事情，或者

181
00:06:50,570 --> 00:06:51,860


182
00:06:51,860 --> 00:06:54,050
对那些类型的

183
00:06:54,050 --> 00:06:56,330
页面和那些类型的数据与

184
00:06:56,330 --> 00:06:58,640
来自底层

185
00:06:58,640 --> 00:07:00,890
表的数据有不同的替换策略或不同的策略，而操作系统并不认为

186
00:07:00,890 --> 00:07:01,940
它总是 对

187
00:07:01,940 --> 00:07:03,500
这些页面中的内容或它们

188
00:07:03,500 --> 00:07:07,160
的使用方式一无所知，因此我们将再次使用我们的

189
00:07:07,160 --> 00:07:08,810
puffle 管理器范围岛局一个

190
00:07:08,810 --> 00:07:10,550
磁盘，因此我们将设计

191
00:07:10,550 --> 00:07:12,710
更喜欢的算法的算法，他们

192
00:07:12,710 --> 00:07:14,960
将最大化数量

193
00:07:14,960 --> 00:07:17,330
我们可以做的顺序 i/o 的数量，这将

194
00:07:17,330 --> 00:07:18,680
与

195
00:07:18,680 --> 00:07:20,780
您之前可能参加的任何算法课程不同，在那里

196
00:07:20,780 --> 00:07:22,190
您假设您只是在读取

197
00:07:22,190 --> 00:07:23,600
写入内存并且所有内容都具有

198
00:07:23,600 --> 00:07:26,420
统一访问权限，现在我们需要

199
00:07:26,420 --> 00:07:28,040
注意什么是 实际上在

200
00:07:28,040 --> 00:07:32,450
我们设计这些方法时在内存中，所以我们

201
00:07:32,450 --> 00:07:33,590
将首先开始讨论

202
00:07:33,590 --> 00:07:37,370
外部归并排序算法，以及

203
00:07:37,370 --> 00:07:38,720
从这次讨论中得出的结果，你

204
00:07:38,720 --> 00:07:40,550
会看到一些重要的 -

205
00:07:40,550 --> 00:07:42,530
本质上进行分而治之的策略

206
00:07:42,530 --> 00:07:45,350
，使我们能够将其应用于

207
00:07:45,350 --> 00:07:47,120
我们想要实现的其他方法或其他运算符

208
00:07:47,120 --> 00:07:48,800
，然后我们将

209
00:07:48,800 --> 00:07:50,920
完成讨论如何

210
00:07:50,920 --> 00:07:53,990
进行依赖排序算法的聚合，

211
00:07:53,990 --> 00:07:57,170
然后它 还有一些 Segway 和

212
00:07:57,170 --> 00:07:58,430
我们下周讨论的关于哈希连接的联合专辑内容，

213
00:07:58,430 --> 00:08:00,590
因此

214
00:08:00,590 --> 00:08:02,180
排序与哈希之间存在某种权衡，

215
00:08:02,180 --> 00:08:03,710
因为您可以使用两种不同的方法

216
00:08:03,710 --> 00:08:05,840
在

217
00:08:05,840 --> 00:08:07,400
数据库系统中散发算法我们将要使用 首先

218
00:08:07,400 --> 00:08:10,460
讨论排序，然后我们将在最后添加

219
00:08:10,460 --> 00:08:14,870


220
00:08:14,870 --> 00:08:18,140


221
00:08:18,140 --> 00:08:19,850


222
00:08:19,850 --> 00:08:21,440


223
00:08:21,440 --> 00:08:25,130


224
00:08:25,130 --> 00:08:27,380
散列 我们的关系本质上是

225
00:08:27,380 --> 00:08:30,710
未排序的，它是设置代数的，

226
00:08:30,710 --> 00:08:32,500
没有排序顺序，所以我们不能假设

227
00:08:32,500 --> 00:08:35,419
我们读取它们时的数据会按

228
00:08:35,419 --> 00:08:36,919
任何特定顺序排列，现在有

229
00:08:36,919 --> 00:08:38,150
聚集索引 在我们讨论

230
00:08:38,150 --> 00:08:40,039
之前，今天再次讨论

231
00:08:40,039 --> 00:08:44,470
它然后你知道为你提供

232
00:08:44,470 --> 00:08:46,460
基于某个索引的排序顺序的强制执行，

233
00:08:46,460 --> 00:08:48,590
但一般来说我们不能

234
00:08:48,590 --> 00:08:49,640
假设情况总是如此，

235
00:08:49,640 --> 00:08:52,370
而且我们可以有一个索引我们的

236
00:08:52,370 --> 00:08:53,510
表可以 被聚集在一个

237
00:08:53,510 --> 00:08:54,800
特定的键上，但现在我们

238
00:08:54,800 --> 00:08:57,290
需要在另一个键上对其进行排序，以便您知道

239
00:08:57,290 --> 00:08:58,610
在这种情况下进行预排序实际上并没有帮助我们

240
00:08:58,610 --> 00:09:00,180
，

241
00:09:00,180 --> 00:09:03,930
因此除了现在

242
00:09:03,930 --> 00:09:05,700
您还能够知道有人通过以下方式调用订单

243
00:09:05,700 --> 00:09:08,190
如果我们的数据已排序，我们想对输出进行排序，

244
00:09:08,190 --> 00:09:10,020


245
00:09:10,020 --> 00:09:11,430
我们可以为其他

246
00:09:11,430 --> 00:09:13,380
实用程序做一些其他优化，或者

247
00:09:13,380 --> 00:09:14,430
我们想要在我们的数据库系统中执行的查询，

248
00:09:14,430 --> 00:09:18,240
所以如果我们的表已排序或

249
00:09:18,240 --> 00:09:20,490
输出或键是 排序然后

250
00:09:20,490 --> 00:09:23,370
进行重复消除真的很容易，

251
00:09:23,370 --> 00:09:25,290
因为现在我只扫描

252
00:09:25,290 --> 00:09:26,610
表格一次，如果我看到那是

253
00:09:26,610 --> 00:09:28,050
我正在看的东西，就像我

254
00:09:28,050 --> 00:09:29,970
看到的最后一样东西我知道

255
00:09:29,970 --> 00:09:31,170
是重复的，并且 我只是扔

256
00:09:31,170 --> 00:09:34,290


257
00:09:34,290 --> 00:09:36,240
如果一切都预先排序，我

258
00:09:36,240 --> 00:09:37,890
可以这样做，然后我可以

259
00:09:37,890 --> 00:09:38,940
通过扫描表一次并

260
00:09:38,940 --> 00:09:41,070
根据需要计算运行总数来生成聚合

261
00:09:41,070 --> 00:09:43,260
，然后我们讨论了优化

262
00:09:43,260 --> 00:09:45,240
批量加载的方法 在 P 加

263
00:09:45,240 --> 00:09:47,820
树中，您沿叶节点预先对所有数据进行排序

264
00:09:47,820 --> 00:09:49,380
，然后

265
00:09:49,380 --> 00:09:51,030
从自下而上

266
00:09:51,030 --> 00:09:53,400
而不是自上而下构建索引，这样

267
00:09:53,400 --> 00:09:57,570
效率更高，因此再次排序是

268
00:09:57,570 --> 00:09:59,220
一个有用的实用程序操作网格 需要在

269
00:09:59,220 --> 00:10:00,600
我们的数据库系统中，但我们需要

270
00:10:00,600 --> 00:10:02,010
能够容纳一个我们不

271
00:10:02,010 --> 00:10:04,680
完全适合内存的地方，因为它

272
00:10:04,680 --> 00:10:06,750
适合内存然后我们只需从介绍类

273
00:10:06,750 --> 00:10:08,400
中选择您知道和喜爱的任何您喜欢的排序算法

274
00:10:08,400 --> 00:10:09,960


275
00:10:09,960 --> 00:10:12,320
并且有效

276
00:10:12,320 --> 00:10:13,950


277
00:10:13,950 --> 00:10:16,800
如果你疯狂的冒泡排序对我们来说很好，但是我们

278
00:10:16,800 --> 00:10:18,960
不在乎它是否在内存中，

279
00:10:18,960 --> 00:10:21,060
所以我们之前在

280
00:10:21,060 --> 00:10:24,360
专辑课程介绍中学到的所有东西都很好，但是

281
00:10:24,360 --> 00:10:25,890
现在的问题 如果它不适合

282
00:10:25,890 --> 00:10:27,840
内存，快速排序对我们来说可能很糟糕，

283
00:10:27,840 --> 00:10:29,640
因为快速排序做

284
00:10:29,640 --> 00:10:30,870
快速排序是做一堆随机

285
00:10:30,870 --> 00:10:32,730
枢轴跳转到

286
00:10:32,730 --> 00:10:34,860
不同位置的内存，这是随机 I/O

287
00:10:34,860 --> 00:10:37,080
和我们的角色，因为我们正在

288
00:10:37,080 --> 00:10:39,270
跳转到那些页面 可能实际上并不适合

289
00:10:39,270 --> 00:10:41,430
内存，在最坏的情况下

290
00:10:41,430 --> 00:10:44,400
，每次更改数据集都会产生一个 IO 成本，

291
00:10:44,400 --> 00:10:49,830
因此我们

292
00:10:49,830 --> 00:10:53,190
需要一种算法，该算法注意

293
00:10:53,190 --> 00:10:54,750
读取写日期磁盘的潜在成本

294
00:10:54,750 --> 00:10:57,660
，因此可以确定 即使在速度更快的 SSD 上

295
00:10:57,660 --> 00:10:59,820
，尝试

296
00:10:59,820 --> 00:11:01,530
最大化收缩 IO 顺序 i/o 的数量的设计决策

297
00:11:01,530 --> 00:11:04,230


298
00:11:04,230 --> 00:11:07,680
比随机 i/o 更有效，因为

299
00:11:07,680 --> 00:11:09,090
您可以通过单个输入更多数据，

300
00:11:09,090 --> 00:11:12,120
并且在 SSD 中没有搜索 但是

301
00:11:12,120 --> 00:11:13,980
在一个你知道

302
00:11:13,980 --> 00:11:15,779
的单个读操作或写

303
00:11:15,779 --> 00:11:17,910
操作到设备中，你

304
00:11:17,910 --> 00:11:21,990
可以获得更多的数据，所以

305
00:11:21,990 --> 00:11:25,170
我将使用，并且在高层次上，

306
00:11:25,170 --> 00:11:27,899
这就是每个

307
00:11:27,899 --> 00:11:30,449
数据的内容 支持原子内存排序的基础和支持原子

308
00:11:30,449 --> 00:11:32,279
内存排序的方法称为外部

309
00:11:32,279 --> 00:11:34,949
合并排序，有时它是您

310
00:11:34,949 --> 00:11:37,170
寻求外部排序合并，这

311
00:11:37,170 --> 00:11:38,279
真的很令人困惑，因为它们将

312
00:11:38,279 --> 00:11:39,779
存在外部合并排序

313
00:11:39,779 --> 00:11:42,089
算法，然后我们将看到排序

314
00:11:42,089 --> 00:11:43,740
合并连接 这可以正确地使用合并

315
00:11:43,740 --> 00:11:46,769
排序算法，但是

316
00:11:46,769 --> 00:11:47,910
当我们谈论连接时，我会尽量说得更

317
00:11:47,910 --> 00:11:50,250
清楚我们实际上在做什么，因为我

318
00:11:50,250 --> 00:11:51,630
说过这是一种分而治之的

319
00:11:51,630 --> 00:11:52,620
方法，我们将基本上

320
00:11:52,620 --> 00:11:54,899
拆分数据集 我们想要

321
00:11:54,899 --> 00:11:57,990
将这些称为运行的较小块排序

322
00:11:57,990 --> 00:12:00,570
，然后我们将对这些运行进行

323
00:12:00,570 --> 00:12:03,720
单独排序 在

324
00:12:03,720 --> 00:12:06,870
给定运行中写入所有键或进行排序，并且这些

325
00:12:06,870 --> 00:12:09,360
运行是我们想要排序的整个键的不相交子集

326
00:12:09,360 --> 00:12:11,820
然后

327
00:12:11,820 --> 00:12:13,019
我们将对这些

328
00:12:13,019 --> 00:12:16,019
小的运行进行排序 然后我们将开始

329
00:12:16,019 --> 00:12:18,060
将它们组合在一起以创建

330
00:12:18,060 --> 00:12:21,209
更大的排序运行 我们继续

331
00:12:21,209 --> 00:12:22,529
这样做直到我们获得

332
00:12:22,529 --> 00:12:24,660
完整的数据集完整的密钥集 在我们

333
00:12:24,660 --> 00:12:27,660
想要排序所以有两个阶段

334
00:12:27,660 --> 00:12:29,399
所以第一阶段再次

335
00:12:29,399 --> 00:12:31,170
我们将尽可能多

336
00:12:31,170 --> 00:12:33,360
地获取内存中可以容纳的块对它们进行排序然后将它们写

337
00:12:33,360 --> 00:12:35,970
回磁盘然后在第二

338
00:12:35,970 --> 00:12:37,350
阶段再次进行合并

339
00:12:37,350 --> 00:12:40,560
这些子排序运行到更大

340
00:12:40,560 --> 00:12:41,910
的运行中，然后将它们写出来，

341
00:12:41,910 --> 00:12:43,440
你一遍又一遍地这样做，直到

342
00:12:43,440 --> 00:12:45,810
你把所有的东西都排序好，所以

343
00:12:45,810 --> 00:12:47,220
这最终

344
00:12:47,220 --> 00:12:49,920
可能会多次遍历

345
00:12:49,920 --> 00:12:52,410
我们正在处理的数据集 尝试排序，

346
00:12:52,410 --> 00:12:53,940
但最后我们得到了一个完整的

347
00:12:53,940 --> 00:12:57,300
排序，所以让我们从一个简单的例子开始，

348
00:12:57,300 --> 00:13:00,180
称为 2-way 归并排序，它是一个

349
00:13:00,180 --> 00:13:02,160
2-way 意味着

350
00:13:02,160 --> 00:13:03,480
第二个是排序的数量

351
00:13:03,480 --> 00:13:05,310
运行我们将在

352
00:13:05,310 --> 00:13:08,010
每一次通过时合并在一起 所以在一次

353
00:13:08,010 --> 00:13:10,860
传递中我们要抓住两次运行 将

354
00:13:10,860 --> 00:13:13,470
它们合并在一起并产生一条新路径 一个

355
00:13:13,470 --> 00:13:15,480
新的运行

356
00:13:15,480 --> 00:13:17,720
它是我们输入的两个较小的组合的组合

357
00:13:17,720 --> 00:13:20,069
数据集会被破坏你 p

358
00:13:20,069 --> 00:13:22,589
进入 n 页 然后

359
00:13:22,589 --> 00:13:24,269
当我们考虑算法将如何工作时对我们来说现在重要的

360
00:13:24,269 --> 00:13:25,860
是我们

361
00:13:25,860 --> 00:13:27,449
需要知道有多少内存

362
00:13:27,449 --> 00:13:28,140


363
00:13:28,140 --> 00:13:32,070
可供我们缓冲内存中的内容以

364
00:13:32,070 --> 00:13:34,110
进行排序，因为如果一切都

365
00:13:34,110 --> 00:13:36,030
适合内存然后 我们不需要做

366
00:13:36,030 --> 00:13:38,220
任何这些，我们只做快速排序，但我们

367
00:13:38,220 --> 00:13:40,500
需要提前被告知

368
00:13:40,500 --> 00:13:42,240
允许我们使用多少内存进行排序

369
00:13:42,240 --> 00:13:44,310
，这实际上是您可以

370
00:13:44,310 --> 00:13:46,020
在数据库系统中配置的东西，所以在

371
00:13:46,020 --> 00:13:47,460
Postgres 中它被称为 工作内存

372
00:13:47,460 --> 00:13:50,300
您基本上是说

373
00:13:50,300 --> 00:13:53,610
允许将多少内存用于

374
00:13:53,610 --> 00:13:55,260
任何类型的中间操作

375
00:13:55,260 --> 00:13:57,510
想要构建哈希表进行

376
00:13:57,510 --> 00:13:59,760
排序和其他类似的事情所以

377
00:13:59,760 --> 00:14:01,350
我们被告知这一点我们总是被告知这

378
00:14:01,350 --> 00:14:05,250
要提前 是时候让我们看

379
00:14:05,250 --> 00:14:08,070
一些视觉示例，因此在过去的 0 中，您

380
00:14:08,070 --> 00:14:09,990
将从表中读取每个 B 页

381
00:14:09,990 --> 00:14:11,880
到内存中，然后将

382
00:14:11,880 --> 00:14:14,610
它们在内存中的适当位置进行排序，然后将

383
00:14:14,610 --> 00:14:17,580
它们写出来，所以让我们真正举例说 e

384
00:14:17,580 --> 00:14:19,830
我在磁盘上有一个磁盘 我有我的数据集

385
00:14:19,830 --> 00:14:22,380
我有两页 所以让我们在这里说这个案例

386
00:14:22,380 --> 00:14:25,470
我只能有 我可以 我可以

387
00:14:25,470 --> 00:14:27,780
将第一页排序到位

388
00:14:27,780 --> 00:14:29,850
现在这是一种运行 然后我

389
00:14:29,850 --> 00:14:31,980
写 那种用完磁盘，

390
00:14:31,980 --> 00:14:33,870
假设

391
00:14:33,870 --> 00:14:35,730
我必须有一个线程，我将一次执行

392
00:14:35,730 --> 00:14:36,900
此操作，我将一次为所有其他页面执行此操作，

393
00:14:36,900 --> 00:14:40,980
所以现在这是

394
00:14:40,980 --> 00:14:42,780
第一步 然后现在我们在这里 我正在

395
00:14:42,780 --> 00:14:44,490
阅读另一页 我把它带入

396
00:14:44,490 --> 00:14:47,510
记忆 排序然后我写出来

397
00:14:47,510 --> 00:14:50,460
所以现在这是过去零的结束

398
00:14:50,460 --> 00:14:52,410
我已经采取了所有我的那种跑步

399
00:14:52,410 --> 00:14:56,550
对不起我所有的 我抓取了一个

400
00:14:56,550 --> 00:14:59,490
B 页面大小的运行，我在内存中对其进行排序，

401
00:14:59,490 --> 00:15:00,870
因为 IB 页面我被允许使用

402
00:15:00,870 --> 00:15:02,430
内存，所以我将它排序到位，

403
00:15:02,430 --> 00:15:04,080
然后我将它写回，然后我

404
00:15:04,080 --> 00:15:06,240
去 下一次运行完成后，

405
00:15:06,240 --> 00:15:10,320
现在在随后的通道中，

406
00:15:10,320 --> 00:15:13,560
我们将重复

407
00:15:13,560 --> 00:15:15,690
到目前为止我们排序的所有运行的淹没，我们

408
00:15:15,690 --> 00:15:16,920
将它们组合在一起以产生

409
00:15:16,920 --> 00:15:18,570
运行是我的输入大小的两倍

410
00:15:18,570 --> 00:15:21,570
，所以对于这种方法，

411
00:15:21,570 --> 00:15:25,160
我需要至少三个缓冲页，

412
00:15:25,160 --> 00:15:29,280
因为我需要有一个缓冲

413
00:15:29,280 --> 00:15:30,900
页面来缓冲我要带入内存的两次运行中的每一个

414
00:15:30,900 --> 00:15:32,940
，然后是另一个

415
00:15:32,940 --> 00:15:35,160
缓冲区 我正在写出的输出页面，

416
00:15:35,160 --> 00:15:38,820
所以在这种情况下，我可以

417
00:15:38,820 --> 00:15:41,279
说我想对这些进行排序，你们排序，

418
00:15:41,279 --> 00:15:43,290
所以我把它们放在记忆中

419
00:15:43,290 --> 00:15:45,569
，现在我有另一个页面，我

420
00:15:45,569 --> 00:15:47,490
可以写出组合

421
00:15:47,490 --> 00:15:50,279
这两个家伙，但我你知道这是

422
00:15:50,279 --> 00:15:51,959
两页长，但我只有一页，

423
00:15:51,959 --> 00:15:54,329
所以我只是要扫描其中的每

424
00:15:54,329 --> 00:15:56,670
一个并逐一比较它们，看看

425
00:15:56,670 --> 00:15:58,319
哪个比另一个大，

426
00:15:58,319 --> 00:15:59,519
抱歉，哪个小于 其他

427
00:15:59,519 --> 00:16:00,899
取决于你要去的顺序，

428
00:16:00,899 --> 00:16:03,600
然后我只是把它写成这样一个排序的

429
00:16:03,600 --> 00:16:05,939
页面，然后一旦它写满了

430
00:16:05,939 --> 00:16:09,509
然后我把它写出磁盘然后

431
00:16:09,509 --> 00:16:12,089
我的合并继续在我继续

432
00:16:12,089 --> 00:16:13,589
往下的地方想到联赛 - 光标正在

433
00:16:13,589 --> 00:16:14,819
扫描 通过这些人比较

434
00:16:14,819 --> 00:16:16,589
他们一个 然后我继续向下

435
00:16:16,589 --> 00:16:17,939
处理另一个数据集，然后我

436
00:16:17,939 --> 00:16:20,879
写下那个页面，然后一旦我

437
00:16:20,879 --> 00:16:22,769
到了最后，然后我就

438
00:16:22,769 --> 00:16:37,499
完成了这是这个剪辑是的所以她的

439
00:16:37,499 --> 00:16:39,480
问题是如果内存在 这种

440
00:16:39,480 --> 00:16:40,620
情况下内存可以容纳三页

441
00:16:40,620 --> 00:16:42,600
为什么不完全按照我刚刚在这里做的

442
00:16:42,600 --> 00:16:44,899
事情首先

443
00:16:44,899 --> 00:16:47,910
是的你可以想到喜欢然后

444
00:16:47,910 --> 00:16:49,139
这是一个简单的例子你可以

445
00:16:49,139 --> 00:16:51,750
想到我可以带来我可以

446
00:16:51,750 --> 00:16:53,879
将两种页面未分类

447
00:16:53,879 --> 00:16:57,329
内存中的页面对它们进行排序然后

448
00:16:57,329 --> 00:16:58,800
进行组合而不必将

449
00:16:58,800 --> 00:17:01,110
它们从磁盘中写回是的

450
00:17:01,110 --> 00:17:02,339
但总的来说这就像

451
00:17:02,339 --> 00:17:03,660
这是一个三部曲一般

452
00:17:03,660 --> 00:17:09,569
不是你不能这样做这也是

453
00:17:09,569 --> 00:17:13,079
一种过度简化因为

454
00:17:13,079 --> 00:17:15,209
想想这些就像元组的数据页

455
00:17:15,209 --> 00:17:17,309
或表中的这些向上的

456
00:17:17,309 --> 00:17:19,349
元组你实际上真的

457
00:17:19,349 --> 00:17:21,780
不能这样做像这样的就地

458
00:17:21,780 --> 00:17:23,220
排序因为那会

459
00:17:23,220 --> 00:17:24,809
修改实际的表本身

460
00:17:24,809 --> 00:17:27,569
你不想这样做 所以一般来说，

461
00:17:27,569 --> 00:17:29,610
通常你不会在这里做这

462
00:17:29,610 --> 00:17:31,620
一步，我将它们分类

463
00:17:31,620 --> 00:17:32,309
到位，

464
00:17:32,309 --> 00:17:33,870
你会制作另一个副本，然后把它写出来

465
00:17:33,870 --> 00:17:35,940
，这样在那种情况下就

466
00:17:35,940 --> 00:17:38,159
行不通了，因为你会需要你

467
00:17:38,159 --> 00:17:45,520
内存中最多需要四页，

468
00:17:45,520 --> 00:17:48,520
所以这又是排序，这

469
00:17:48,520 --> 00:17:50,410
是一种简化，但看起来你

470
00:17:50,410 --> 00:17:51,429
已经完成了数学运算，现在看看

471
00:17:51,429 --> 00:17:52,390
实际发生了什么，所以让我们

472
00:17:52,390 --> 00:17:55,570
通过一个更细粒度的例子

473
00:17:55,570 --> 00:17:58,750
在这里 数学计算的方式是

474
00:17:58,750 --> 00:18:00,190
我们需要为这种

475
00:18:00,190 --> 00:18:02,890
双向合并排序的次数是 1 加上

476
00:18:02,890 --> 00:18:06,790
log 2n right 的上限，这里

477
00:18:06,790 --> 00:18:08,320
的第一个是 4

478
00:18:08,320 --> 00:18:11,140
是第一次通过，然后

479
00:18:11,140 --> 00:18:15,340
log 2n 是 当您

480
00:18:15,340 --> 00:18:19,630
在每次通过时不断划分数据时，您会

481
00:18:19,630 --> 00:18:21,309
获得越来越大的运行，直到

482
00:18:21,309 --> 00:18:23,410
您达到数据集的总大小，

483
00:18:23,410 --> 00:18:27,790
最后一次通过

484
00:18:27,790 --> 00:18:31,179
您正在排序的两次运行将是您最多知道的

485
00:18:31,179 --> 00:18:33,370
总数据数据集大小的一半，

486
00:18:33,370 --> 00:18:37,300
因此总 ioio 调用

487
00:18:37,300 --> 00:18:39,429
joini  ng 确定数字剑是

488
00:18:39,429 --> 00:18:41,260
传球次数的 2m 倍，这是 2n，

489
00:18:41,260 --> 00:18:43,000
因为我总是必须在

490
00:18:43,000 --> 00:18:45,850
每次传球时

491
00:18:45,850 --> 00:18:48,700
读入并正确写出它是一个读入然后一个正确的所以这

492
00:18:48,700 --> 00:18:50,830
意味着也最多在每次传球中我 正在

493
00:18:50,830 --> 00:18:53,350
阅读我正在阅读和写入每条

494
00:18:53,350 --> 00:18:55,179
记录每一个键，我试图对

495
00:18:55,179 --> 00:18:58,890
一次进一次出进行排序，

496
00:18:58,890 --> 00:19:01,120
所以让我们看一个这样的例子

497
00:19:01,120 --> 00:19:03,580
好吧，所以我们有一堆页面，

498
00:19:03,580 --> 00:19:06,220
每页我们有两个 输入它们中的键，

499
00:19:06,220 --> 00:19:07,960
所以是的，然后这个小标记表示

500
00:19:07,960 --> 00:19:11,110
这是文件的结尾，所以在

501
00:19:11,110 --> 00:19:14,490
第一遍中，我们只是要在每个页面中读取

502
00:19:14,490 --> 00:19:17,980
并对其进行排序，然后将其写回，这样

503
00:19:17,980 --> 00:19:19,390
我们就不会检查

504
00:19:19,390 --> 00:19:21,309
不同页面的数据或 这些实际上是

505
00:19:21,309 --> 00:19:24,400
运行，但它是一页运行，然后

506
00:19:24,400 --> 00:19:26,940
在下一次通过时，我要去抓取两

507
00:19:26,940 --> 00:19:29,320
到两种彼此相邻的运行，

508
00:19:29,320 --> 00:19:32,380
将它们带入内存

509
00:19:32,380 --> 00:19:34,750
在两页内对它们进行全局排序

510
00:19:34,750 --> 00:19:36,730
，然后写下那些 伙计们，所以

511
00:19:36,730 --> 00:19:38,140
在这种情况下，

512
00:19:38,140 --> 00:19:40,510
第二遍的输出将被运行 s 大小为两

513
00:19:40,510 --> 00:19:42,750
页

514
00:19:43,830 --> 00:19:46,260
，然后我这样做 继续向下翻到

515
00:19:46,260 --> 00:19:47,850
第二页，现在我有四次四

516
00:19:47,850 --> 00:19:49,740
页运行，最后一次我有

517
00:19:49,740 --> 00:19:51,510
八页运行，然后到这里我就

518
00:19:51,510 --> 00:19:54,750
完成了，因为现在我的输出运行是

519
00:19:54,750 --> 00:19:58,500
总数 键数量的大小，

520
00:19:58,500 --> 00:20:08,400
我可以，所以到目前为止我向您展示

521
00:20:08,400 --> 00:20:10,890
的两个都很好 合并排序，

522
00:20:10,890 --> 00:20:13,680
因为我说它只需要三个缓冲区

523
00:20:13,680 --> 00:20:16,110
页面，两个用于输入一个用于

524
00:20:16,110 --> 00:20:18,870
输出，所以回到这里 当

525
00:20:18,870 --> 00:20:21,780
我创建这个时，你知道现在

526
00:20:21,780 --> 00:20:24,480
创建一个两页的运行实际上

527
00:20:24,480 --> 00:20:26,190
使用这个例子所以现在我正在创建

528
00:20:26,190 --> 00:20:28,290
一个有四页的运行我只能

529
00:20:28,290 --> 00:20:30,840
在内存中只有三页所以我

530
00:20:30,840 --> 00:20:32,790
有我要一个

531
00:20:32,790 --> 00:20:34,830
右侧或左侧

532
00:20:34,830 --> 00:20:36,450
右侧 再次你认为我

533
00:20:36,450 --> 00:20:38,730
只有一个光标 我只是扫描

534
00:20:38,730 --> 00:20:41,160
两侧的每一页

535
00:20:41,160 --> 00:20:42,780
然后比较看看是否一个

536
00:20:42,780 --> 00:20:45,150
大于 另一个，如果一个

537
00:20:45,150 --> 00:20:46,410
小于另一个，那么这就是我

538
00:20:46,410 --> 00:20:48,180
写到我的输出和 向下移动

539
00:20:48,180 --> 00:20:50,070
那个光标，然后我做同样的

540
00:20:50,070 --> 00:20:52,920
比较，所以我继续

541
00:20:52,920 --> 00:20:55,710
一步一步直到我到达终点

542
00:20:55,710 --> 00:20:56,790
光标到达他们两个的末端

543
00:20:56,790 --> 00:21:01,920
是的一个问题是

544
00:21:01,920 --> 00:21:02,910
我在这里展示的是什么 数字

545
00:21:02,910 --> 00:21:04,950
考虑元组 是的，

546
00:21:04,950 --> 00:21:06,120
我正在展示它们的键的简化，

547
00:21:06,120 --> 00:21:09,390
但实际上在一个真实的系统中，

548
00:21:09,390 --> 00:21:10,740
你会喜欢你试图

549
00:21:10,740 --> 00:21:12,780
排序的键，然后记录想法

550
00:21:12,780 --> 00:21:13,760
是从哪里来的，

551
00:21:13,760 --> 00:21:20,340
在这个例子中，每个方块都是

552
00:21:20,340 --> 00:21:23,790
一个页面 是的，但

553
00:21:23,790 --> 00:21:28,970
为了简单起见，我在页面中只有两个键 是的，

554
00:21:30,070 --> 00:21:36,379
好的，所以再次对于这个例子，

555
00:21:36,379 --> 00:21:39,559
我们只需要两个页面，但

556
00:21:39,559 --> 00:21:41,389
问题是我说过我会给你更多的

557
00:21:41,389 --> 00:21:44,990
页面和我展示的内容 到目前为止，

558
00:21:44,990 --> 00:21:49,269
你实际上并没有变得更好，

559
00:21:49,269 --> 00:21:56,000
为什么他是对的，输入/输出保持不变，

560
00:21:56,000 --> 00:21:57,710
因为我在做什么我要

561
00:21:57,710 --> 00:21:59,840
获取两页，然后我有这个

562
00:21:59,840 --> 00:22:01,159
光标，它会穿过它们，

563
00:22:01,159 --> 00:22:04,850
然后是任何一个 你

564
00:22:04,850 --> 00:22:06,559
有被写到第三个的较低的键

565
00:22:06,559 --> 00:22:09,649
在内存中具有更多页面的页面

566
00:22:09,649 --> 00:22:12,049
并不能真正帮助我们，因为您知道

567
00:22:12,049 --> 00:22:13,850
最终我只能进行比较，

568
00:22:13,850 --> 00:22:18,080
您一次只知道两个页面，因此一个非常

569
00:22:18,080 --> 00:22:21,500
简单的优化可以最大程度地减少

570
00:22:21,500 --> 00:22:25,909
此 I/O 成本是进行预

571
00:22:25,909 --> 00:22:27,889
取 这种技术被称为双

572
00:22:27,889 --> 00:22:30,980
缓冲，这个想法是，当

573
00:22:30,980 --> 00:22:33,529
你开始合并其他两个页面时，

574
00:22:33,529 --> 00:22:35,509
你有一堆影子页面或

575
00:22:35,509 --> 00:22:37,610
影子缓冲区，你可以

576
00:22:37,610 --> 00:22:40,610
在下一次运行中开始获取你需要排序

577
00:22:40,610 --> 00:22:43,669
的下一页或你需要的下一页 排序所以它

578
00:22:43,669 --> 00:22:45,409
需要你有 deuce 异步

579
00:22:45,409 --> 00:22:46,820
i/o 有东西在后台

580
00:22:46,820 --> 00:22:49,279
去获取你需要的下一页

581
00:22:49,279 --> 00:22:50,899
，这样当光标

582
00:22:50,899 --> 00:22:52,039
读取到当前页面的末尾时，该

583
00:22:52,039 --> 00:22:54,740
页面正在

584
00:22:54,740 --> 00:22:57,259
下一个操作 它需要的页面在那里，如果它是

585
00:22:57,259 --> 00:22:58,669
单线程的，并且所有的一切都是

586
00:22:58,669 --> 00:23:00,289
同步的，那么你就有了这种乒乓

587
00:23:00,289 --> 00:23:02,809
效应，我将受到 CPU 限制和

588
00:23:02,809 --> 00:23:04,490
磁盘限制，CPU 限制了磁盘限制，

589
00:23:04,490 --> 00:23:06,320
因为我将把页面引入并

590
00:23:06,320 --> 00:23:08,210
等待  为此，然后进行我的排序，这就是

591
00:23:08,210 --> 00:23:10,639
所有 CPU 然后我完成了

592
00:23:10,639 --> 00:23:12,110
排序或完成了合并，

593
00:23:12,110 --> 00:23:13,669
现在我必须进入下一页，

594
00:23:13,669 --> 00:23:16,250
我在那个右边被阻止了所以非常

595
00:23:16,250 --> 00:23:18,200
简单的例子在这里我 想对一个进行排序

596
00:23:18,200 --> 00:23:20,450
，然后当我在后台这样做时，

597
00:23:20,450 --> 00:23:23,840
我去获取第二页，

598
00:23:23,840 --> 00:23:25,789
然后当我对这个进行排序

599
00:23:25,789 --> 00:23:28,669
时，然后当这完成时，当这个人

600
00:23:28,669 --> 00:23:31,389
准备好为我而去的时候，

601
00:23:33,410 --> 00:23:39,210
好吧，这就是这个 你

602
00:23:39,210 --> 00:23:41,490
知道合并排序是一种最简单

603
00:23:41,490 --> 00:23:44,370
的考虑这个的方法我们需要考虑

604
00:23:44,370 --> 00:23:46,200
它如何与一般

605
00:23:46,200 --> 00:23:49,320
你知道一般排序或k方式

606
00:23:49,320 --> 00:23:57,870
排序是的抱歉所以这个问题是

607
00:23:57,870 --> 00:24:00,330
你怎么样你怎么样

608
00:24:00,330 --> 00:24:04,340
在这里做这个优化你如何让线程

609
00:24:04,730 --> 00:24:07,380
学生排序，而在

610
00:24:07,380 --> 00:24:09,570
后台它会很好地获取数据

611
00:24:09,570 --> 00:24:10,590
这实际上是操作系统

612
00:24:10,590 --> 00:24:12,660
帮助我们正确所以我们从操作系统发出请求

613
00:24:12,660 --> 00:24:14,340
去为我们阅读这个

614
00:24:14,340 --> 00:24:16,740
然后有 另一个线程

615
00:24:16,740 --> 00:24:18,630
称为任何同步 si/o 在

616
00:24:18,630 --> 00:24:20,130
后台它去获取我们需要的数据

617
00:24:20,130 --> 00:24:22,640
我们告诉它我们要把它放在哪里

618
00:24:22,640 --> 00:24:25,140
然后这样我就可以完成所有

619
00:24:25,140 --> 00:24:26,820
的计算实际上

620
00:24:26,820 --> 00:24:27,750
数据说我们可以做得很好你

621
00:24:27,750 --> 00:24:29,550
实际上不 在真实系统中不需要操作系统，

622
00:24:29,550 --> 00:24:31,800
你会拥有一个 IO

623
00:24:31,800 --> 00:24:34,290
调度程序线程，所以你说我想要这个

624
00:24:34,290 --> 00:24:35,760
请求给我这个页面，然后给

625
00:24:35,760 --> 00:24:37,920
我你知道这里有一个电话告诉我

626
00:24:37,920 --> 00:24:39,630
它什么时候真正准备好了然后它就去做

627
00:24:39,630 --> 00:24:41,040
了 你的线程可以

628
00:24:41,040 --> 00:24:42,360
一次做任何计算，然后

629
00:24:42,360 --> 00:24:44,780
当它完成时它可供你使用

630
00:24:44,780 --> 00:24:49,340
是的，是的，他们有两个线程是的，

631
00:24:49,580 --> 00:24:52,440
好的，所以让我们快速讨论一下如何

632
00:24:52,440 --> 00:24:53,700
推广这个算法，

633
00:24:53,700 --> 00:24:57,120
而不仅仅是只做两个你知道标准的两种

634
00:24:57,120 --> 00:24:59,820
方式排序 一般K方式排序

635
00:24:59,820 --> 00:25:02,670
它仍然是相同的，我们将使用remai

636
00:25:02,670 --> 00:25:05,430
作为缓冲池，然后在

637
00:25:05,430 --> 00:25:07,320
第一遍中，我们将生成并将其划分

638
00:25:07,320 --> 00:25:09,120
为大小为B的那种运行的上限，

639
00:25:09,120 --> 00:25:11,310
因为这就是我们正在做

640
00:25:11,310 --> 00:25:13,590
的 就地排序，然后在

641
00:25:13,590 --> 00:25:15,780
随后的pa  sses 我们要做的我们

642
00:25:15,780 --> 00:25:17,760
要生成 B 减一运行

643
00:25:17,760 --> 00:25:20,100
一次，它总是减一，

644
00:25:20,100 --> 00:25:21,540
因为我们总是需要一个缓冲区

645
00:25:21,540 --> 00:25:23,280
来输出具有额外的输出

646
00:25:23,280 --> 00:25:24,990
缓冲区对我们没有帮助，因为你

647
00:25:24,990 --> 00:25:26,820
真的只写一个 一个线程，

648
00:25:26,820 --> 00:25:28,110
但一次只写入一个输出缓冲区

649
00:25:28,110 --> 00:25:31,710
，这就是为什么它是 B 减 1，所以

650
00:25:31,710 --> 00:25:33,390
数学计算的方式只是

651
00:25:33,390 --> 00:25:35,130
我们在设置之前展示的内容的扩展，

652
00:25:35,130 --> 00:25:38,100
现在说 log 2n 或 law 到它的

653
00:25:38,100 --> 00:25:40,380
log B 减一，然后你取

654
00:25:40,380 --> 00:25:43,080
n 除以 B 的上限，但

655
00:25:43,080 --> 00:25:45,420
I/O 成本仍然是数字过去的两倍，

656
00:25:45,420 --> 00:25:46,410


657
00:25:46,410 --> 00:25:48,700
所以这非常堵塞你在做功课时会

658
00:25:48,700 --> 00:25:51,130
看到这一点，

659
00:25:51,130 --> 00:25:53,440
你填写蜜蜂 填写末尾

660
00:25:53,440 --> 00:25:56,980
，数字就算出来了 所以让

661
00:25:56,980 --> 00:25:58,210


662
00:25:58,210 --> 00:26:00,820
我们在这里简单地看一个非常简单的例子 所以我们要用五个五个缓冲区页面对 108 个页面进行排序

663
00:26:00,820 --> 00:26:05,350
我们可以使用 2n

664
00:26:05,350 --> 00:26:08,260
等于 108 P 等于 5 所以在

665
00:26:08,260 --> 00:26:11,140
第一遍中写下 我们要做的 i/o 数量

666
00:26:11,140 --> 00:26:14,260
是我们试图

667
00:26:14,260 --> 00:26:15,160
计算 我们要生成多少运行，

668
00:26:15,160 --> 00:26:17,110
所以它是 108 除以 5 的上限，

669
00:26:17,110 --> 00:26:18,910
这样将生成

670
00:26:18,910 --> 00:26:22,060
两个 23 种运行，每个运行 5

671
00:26:22,060 --> 00:26:24,850
页，然后

672
00:26:24,850 --> 00:26:27,370
最后运行的最后一页只有三页，

673
00:26:27,370 --> 00:26:29,340
这就是为什么你有 正确设置上限，

674
00:26:29,340 --> 00:26:31,030
因为您不想要

675
00:26:31,030 --> 00:26:33,910
小数成本，然后

676
00:26:33,910 --> 00:26:35,200
在随后的传递中下降，现在您正在使用

677
00:26:35,200 --> 00:26:37,420
您希望

678
00:26:37,420 --> 00:26:38,890
在前一次传递中生成的运行次数并将

679
00:26:38,890 --> 00:26:42,250
其除以大小的数量

680
00:26:42,250 --> 00:26:43,270
你之前要生成的运行

681
00:26:43,270 --> 00:26:46,210
现在是两个 现在是

682
00:26:46,210 --> 00:26:48,310
四个 所以这会生成六种

683
00:26:48,310 --> 00:26:50,260
运行 20 页，其中最后一页

684
00:26:50,260 --> 00:26:51,970
是最后一次运行只有八页，

685
00:26:51,970 --> 00:26:54,610
然后只是继续

686
00:26:54,610 --> 00:26:56,290
应用 一遍又一遍，直到你

687
00:26:56,290 --> 00:26:59,250
到达最后你现在拥有

688
00:26:59,250 --> 00:27:02,440
的数据集与原始数据集的大小

689
00:27:02,440 --> 00:27:09,040
完全相同是的，这些问题

690
00:27:09,040 --> 00:27:10,660
在这里假设

691
00:27:10,660 --> 00:27:12,730
在第一次通过时已经完成，

692
00:27:12,730 --> 00:27:16,090
现在对随后的通过来说是这样，但是 仿佛 这

693
00:27:16,090 --> 00:27:18,190
是教科书在真实系统中

694
00:27:18,190 --> 00:27:19,930
所做的，您不会这样做，因为如果数据直接来自表本身，

695
00:27:19,930 --> 00:27:22,870
则取决于您

696
00:27:22,870 --> 00:27:24,670
从何处读取数据的方式，如果是

697
00:27:24,670 --> 00:27:26,170
，

698
00:27:26,170 --> 00:27:29,380
则无法修改它

699
00:27:29,380 --> 00:27:31,930
来自另一个操作员然后你

700
00:27:31,930 --> 00:27:38,620
可以这样做是的 -1 关闭它，

701
00:27:38,620 --> 00:27:39,670
因为你总是有一个

702
00:27:39,670 --> 00:27:46,180
缓冲页面用于输出是的 所以是的

703
00:27:46,180 --> 00:27:51,540
，在一般情况下它是三个

704
00:27:51,540 --> 00:27:54,760
正确的一个，无论

705
00:27:54,760 --> 00:27:58,860
输入一个是两个 上传是的，

706
00:28:04,100 --> 00:28:06,389
这个问题就是为什么我

707
00:28:06,389 --> 00:28:14,129
在这里使用五个所以你正在排序是的抱歉它

708
00:28:14,129 --> 00:28:18,720
使它这样在我一次排序两次

709
00:28:18,720 --> 00:28:21,779
运行之前现在一次排序

710
00:28:21,779 --> 00:28:24,620
多次运行所以我

711
00:28:24,620 --> 00:28:27,570
对 B 这么说 等于五 我买了五个

712
00:28:27,570 --> 00:28:30,269
缓冲页，所以对于每

713
00:28:30,269 --> 00:28:32,549
一种运行，我将进行五种运行

714
00:28:32,549 --> 00:28:33,840
我将尝试同时合并，

715
00:28:33,840 --> 00:28:35,309
而且我需要做的只是

716
00:28:35,309 --> 00:28:37,919
在每个运行中放置一个光标 并逐一浏览

717
00:28:37,919 --> 00:28:39,570
它们，然后

718
00:28:39,570 --> 00:28:41,690
对所有这些进行比较 说哪个是

719
00:28:41,690 --> 00:28:44,340
哪个是最小的写出来

720
00:28:44,340 --> 00:28:47,159
然后现在我们有四个游标和

721
00:28:47,159 --> 00:28:50,129
一个小程序是的我应该

722
00:28:50,129 --> 00:28:53,940
再次想象对不起这个妻子记录 Excel

723
00:28:53,940 --> 00:28:58,769
记得明年这样做 或者这

724
00:28:58,769 --> 00:29:04,679
很清楚所以这是外部合并

725
00:29:04,679 --> 00:29:07,350
他们说这是

726
00:29:07,350 --> 00:29:08,970
你如何实际实现的确切细节，

727
00:29:08,970 --> 00:29:10,759
这将因系统而异

728
00:29:10,759 --> 00:29:12,330
，显然

729
00:29:12,330 --> 00:29:14,639
我们可以考虑一些其他优化，

730
00:29:14,639 --> 00:29:17,100
比如一些提示，哦，我知道

731
00:29:17,100 --> 00:29:18,690
最大值的最小值，如果我的排序 运行

732
00:29:18,690 --> 00:29:21,269
是这样的，我的

733
00:29:21,269 --> 00:29:22,409
其他类型的运行的最小最大值是这样，

734
00:29:22,409 --> 00:29:25,110
因此如果我知道

735
00:29:25,110 --> 00:29:27,929
最小值大于

736
00:29:27,929 --> 00:29:29,610
其他类型的运行的最大值，我不需要

737
00:29:29,610 --> 00:29:31,919
进行合并 我在 Java 之上消失了，

738
00:29:31,919 --> 00:29:34,350
所以你

739
00:29:34,350 --> 00:29:38,460
可以做一些优化，但总的来说，

740
00:29:38,460 --> 00:29:41,639
我今天在这里展示的是你知道

741
00:29:41,639 --> 00:29:44,850
适用于大多数数据集的工作，

742
00:29:44,850 --> 00:29:46,259
假设

743
00:29:46,259 --> 00:29:49,649
值的均匀分布没有任何种类的 没有

744
00:29:49,649 --> 00:29:51,059
地方可以输入数据，它只是

745
00:29:51,059 --> 00:29:54,240
完全随机的，如果您

746
00:29:54,240 --> 00:29:55,620
知道更多关于我的

747
00:29:55,620 --> 00:29:57,059
数据的信息，例如它以某种方式倾斜，

748
00:29:57,059 --> 00:29:59,370
那么您可以应用一些简单的

749
00:29:59,370 --> 00:30:01,259
技术来加快速度，

750
00:30:01,259 --> 00:30:02,850
但这就是我所展示的 今天

751
00:30:02,850 --> 00:30:04,350
就像它的皮卡车版本一样，它是一个

752
00:30:04,350 --> 00:30:09,440
通用版本，

753
00:30:09,789 --> 00:30:11,320
而不是实际上只是做我在这里展示的

754
00:30:11,320 --> 00:30:13,559
那种蛮力优先合并排序，

755
00:30:13,559 --> 00:30:15,850
现在肯定

756
00:30:15,850 --> 00:30:18,129
在某些情况下我们可以

757
00:30:18,129 --> 00:30:20,830
实际使用 B plus 树来加速

758
00:30:20,830 --> 00:30:24,429
我们的排序操作，所以一般来说，

759
00:30:24,429 --> 00:30:26,739
排序和联合算法

760
00:30:26,739 --> 00:30:28,239
实际上是最昂贵的事情

761
00:30:28,239 --> 00:30:31,119
哦，所以如果有任何方法可以

762
00:30:31,119 --> 00:30:32,859
加快这些事情的速度，这

763
00:30:32,859 --> 00:30:36,789
对我们来说总是一个不错的选择，那么 B

764
00:30:36,789 --> 00:30:38,769
plus 树本质上做得很好，它

765
00:30:38,769 --> 00:30:42,190
维护了数据结构中键的排序顺序，

766
00:30:42,190 --> 00:30:43,989
所以我们付钱给

767
00:30:43,989 --> 00:30:46,509
你知道维护更新的惩罚

768
00:30:46,509 --> 00:30:48,940
do 分裂在我们的 B

769
00:30:48,940 --> 00:30:52,599
plus 树上根据需要出现，如表 g  ets 修改但

770
00:30:52,599 --> 00:30:54,399
现在我们可以

771
00:30:54,399 --> 00:30:56,590
利用我们已经完成的工作来

772
00:30:56,590 --> 00:30:58,269
加速排序但根本不必进行

773
00:30:58,269 --> 00:31:00,999
排序所以如果

774
00:31:00,999 --> 00:31:03,099
我们需要的排序操作如果我们

775
00:31:03,099 --> 00:31:05,049
想要排序的键是相同的

776
00:31:05,049 --> 00:31:07,570
B 加树的键被索引然后我们

777
00:31:07,570 --> 00:31:09,249
可以潜在地只重用 B 加

778
00:31:09,249 --> 00:31:10,899
树，而不是

779
00:31:10,899 --> 00:31:12,489
通过合并排序和

780
00:31:12,489 --> 00:31:16,379
我刚刚展示的多次传递来完成整个查找，但它仅在

781
00:31:16,379 --> 00:31:20,259
我们再次拥有集群 B 加树时才有效 我们

782
00:31:20,259 --> 00:31:22,090
展示了一个例子，我认为是两个

783
00:31:22,090 --> 00:31:24,909
班级之前，但现在我们向它展示了更多的

784
00:31:24,909 --> 00:31:27,340
可视化电缆实际发生的事情

785
00:31:27,340 --> 00:31:28,779
，你会明白为什么这对排序有意义，

786
00:31:28,779 --> 00:31:31,529
但对整洁的没有意义，

787
00:31:31,529 --> 00:31:34,029
所以聚集的 B 加树是聚集

788
00:31:34,029 --> 00:31:37,389
索引 只是意味着我们页面上元组的排序顺序

789
00:31:37,389 --> 00:31:41,529
或物理位置

790
00:31:41,529 --> 00:31:45,519
将匹配

791
00:31:45,519 --> 00:31:49,869
索引中定义的排序顺序，所以如果我

792
00:31:49,869 --> 00:31:53,859
在键 foo 上有一个索引，那么沿着我的页面

793
00:31:53,859 --> 00:31:57,059
将是我们在页面中排序的元组

794
00:31:57,059 --> 00:32:00,929
基于 基于此或 der of foo

795
00:32:00,929 --> 00:32:04,840
所以现在如果我想对该键进行排序，

796
00:32:04,840 --> 00:32:07,389
我不需要进行外部合并

797
00:32:07,389 --> 00:32:09,220
排序，因为我需要做的就是

798
00:32:09,220 --> 00:32:11,379
深入到我的叶子页面和 IB 加树，

799
00:32:11,379 --> 00:32:14,440
因为现在的排序顺序是

800
00:32:14,440 --> 00:32:17,349
键将匹配查找数据的排序顺序，

801
00:32:17,349 --> 00:32:20,730


802
00:32:20,730 --> 00:32:21,870
因此我不需要您进行任何额外的

803
00:32:21,870 --> 00:32:25,590
计算来对其进行排序它

804
00:32:25,590 --> 00:32:27,140
已经为我排序了

805
00:32:27,140 --> 00:32:29,160
所以这又是另一个示例

806
00:32:29,160 --> 00:32:30,780
，其中数据库系统查询

807
00:32:30,780 --> 00:32:32,370
我们将在

808
00:32:32,370 --> 00:32:34,860
期中考试之后或期中之前的课程中讨论的计划器

809
00:32:34,860 --> 00:32:37,050
查询优化器可以弄清楚

810
00:32:37,050 --> 00:32:39,240
哦你想对这个键进行排序我

811
00:32:39,240 --> 00:32:40,800
已经在那个键上有一个聚集索引

812
00:32:40,800 --> 00:32:43,170
让我去用它来生成

813
00:32:43,170 --> 00:32:45,000
更正整个顺序，甚至不费心

814
00:32:45,000 --> 00:32:49,680
运行外部合并排序，但正如我们

815
00:32:49,680 --> 00:32:51,300
在 Postgres 的情况下看到的那样，

816
00:32:51,300 --> 00:32:52,740
他们不能强制执行此操作，您告诉我我

817
00:32:52,740 --> 00:32:54,870
想要在给定键上的索引上的完整集群，

818
00:32:54,870 --> 00:32:56,400
他们不会 保持

819
00:32:56,400 --> 00:32:57,870
这就是订购其他系统

820
00:32:57,870 --> 00:33:00,810
会这样做，所以现在如果你有一个

821
00:33:00,810 --> 00:33:02,940
联合国 自定义 P plus 交易上的杂乱索引

822
00:33:02,940 --> 00:33:04,680
这实际上是

823
00:33:04,680 --> 00:33:07,620
用于尝试

824
00:33:07,620 --> 00:33:10,230
生成排序顺序的最糟糕的事情，我们认为我

825
00:33:10,230 --> 00:33:14,130
猜为什么应该很明显

826
00:33:14,130 --> 00:33:15,950


827
00:33:15,950 --> 00:33:18,240
你有一个睁开眼睛的记录有什么了不起，所以

828
00:33:18,240 --> 00:33:20,670
我再次遍历索引 轻轻地

829
00:33:20,670 --> 00:33:22,290
到树的左侧，我想

830
00:33:22,290 --> 00:33:24,600
扫描，因为我的

831
00:33:24,600 --> 00:33:27,470
键是这样排序的，但是数据

832
00:33:27,470 --> 00:33:30,330
与它在索引中的排序方式没有联系，

833
00:33:30,330 --> 00:33:33,720
所以对于每条记录，我

834
00:33:33,720 --> 00:33:35,700
都必须去获取并生成作为我的 输出

835
00:33:35,700 --> 00:33:37,950
我可能正在做另一个磁盘 i/o 因为

836
00:33:37,950 --> 00:33:40,650
我需要的页面不在内存中 我去

837
00:33:40,650 --> 00:33:42,360
迪斯科舞厅拿它带来我兄弟的民意调查

838
00:33:42,360 --> 00:33:43,920
然后现在我看到的下一个键

839
00:33:43,920 --> 00:33:45,600
在另一个页面中并且它是我的受害者

840
00:33:45,600 --> 00:33:47,550
刚带进来给他带来下

841
00:33:47,550 --> 00:33:58,290
一个是的问题

842
00:33:58,290 --> 00:34:01,920
是树是什么意思你不会说它

843
00:34:01,920 --> 00:34:04,500
是你不会说树木

844
00:34:04,500 --> 00:34:07,500
聚集桌子再次聚集我不会

845
00:34:07,500 --> 00:34:09,060
这样称呼它 我在写你

846
00:34:09,060 --> 00:34:10,050
知道我会用这些术语

847
00:34:10,050 --> 00:34:12,060
哦，这是一个排序表，

848
00:34:12,060 --> 00:34:13,020
无论出于何种原因，他们都称其为集群

849
00:34:13,020 --> 00:34:14,219
表，因为它

850
00:34:14,219 --> 00:34:15,989
基本上是彼此相似的元组

851
00:34:15,989 --> 00:34:16,679


852
00:34:16,679 --> 00:34:18,600
在页面上聚集在一起，

853
00:34:18,600 --> 00:34:21,900
所以再次回到这里，这是两者的排序

854
00:34:21,900 --> 00:34:23,520
顺序 实际上被

855
00:34:23,520 --> 00:34:26,760
存储的排序顺序与键匹配所以

856
00:34:26,760 --> 00:34:28,260
这将是一个聚集索引，

857
00:34:28,260 --> 00:34:29,449
好吧，

858
00:34:29,449 --> 00:34:31,710
在这种情况下，我们只是称之为创建

859
00:34:31,710 --> 00:34:34,110
索引，这是你通常得到的，

860
00:34:34,110 --> 00:34:35,850
或者只是你知道实际

861
00:34:35,850 --> 00:34:37,830
记录的实际位置 Sword

862
00:34:37,830 --> 00:34:41,510
与它们的排序方式无关

863
00:34:42,800 --> 00:34:44,580
问题树中的信息是什么

864
00:34:44,580 --> 00:34:45,810
这只是我们之前讨论过的 B+ 树

865
00:34:45,810 --> 00:34:48,179
，所以

866
00:34:48,179 --> 00:34:51,510
在键 foo 上创建索引以便构建该索引我正在

867
00:34:51,510 --> 00:34:53,280
做特殊扫描查看

868
00:34:53,280 --> 00:34:55,020
每个元组都获得了 foo 的值，

869
00:34:55,020 --> 00:34:57,450
将其插入到我的树中，

870
00:34:57,450 --> 00:35:00,240
键值对是 foo 的费用值

871
00:35:00,240 --> 00:35:03,330
，然后该值是记录我

872
00:35:03,330 --> 00:35:06,420
需要一个指向元组的指针，

873
00:35:06,420 --> 00:35:07,500
这是不同的 不是索引

874
00:35:07,500 --> 00:35:10,710
组织的索引或我们讨论的任何索引组织的

875
00:35:10,710 --> 00:35:12,540
表，在这种情况下，

876
00:35:12,540 --> 00:35:13,530
两个页面实际上位于叶

877
00:35:13,530 --> 00:35:15,990
节点本身中，在这种情况下，这是一个

878
00:35:15,990 --> 00:35:18,390
聚集索引，但它也在其

879
00:35:18,390 --> 00:35:21,300
组织的表中，这就像

880
00:35:21,300 --> 00:35:22,380
他们不是你 '如果它断开连接，则不会将数据存储

881
00:35:22,380 --> 00:35:24,600
在叶节点本身中，

882
00:35:24,600 --> 00:35:28,700
那么它要么是集群，

883
00:35:47,030 --> 00:35:50,910
是的，所以 David 而不是实际上

884
00:35:50,910 --> 00:35:53,550
每次我遇到一个键时

885
00:35:53,550 --> 00:35:56,160
立即去获取它，如果我获得

886
00:35:56,160 --> 00:35:59,070
了我需要的所有键和它们的

887
00:35:59,070 --> 00:36:02,040
记录 ID 会怎样 然后现在结合

888
00:36:02,040 --> 00:36:03,750
查找，以便我首先从第 101 页获取所有内容，然后从

889
00:36:03,750 --> 00:36:05,580
第一

890
00:36:05,580 --> 00:36:08,250
页或第二页获取所有内容 是的，我们将讨论

891
00:36:08,250 --> 00:36:11,190
两周或下周正确的

892
00:36:11,190 --> 00:36:14,480
四次扫描，这是一种常见的优化，

893
00:36:14,480 --> 00:36:17,040
但假设 你可以像

894
00:36:17,040 --> 00:36:23,250
关键集一样适合并且有一些

895
00:36:23,250 --> 00:36:24,570
算法你实际上可以在其中

896
00:36:24,570 --> 00:36:26,040
早晚开始产生输出

897
00:36:26,040 --> 00:36:27,780


898
00:36:27,780 --> 00:36:29,520
这就像一个全有或全无 这

899
00:36:29,520 --> 00:36:31,740
就像我到目前为止所展示的那样

900
00:36:31,740 --> 00:36:33,570
尽你所知 该运营商要求我

901
00:36:33,570 --> 00:36:35,790
按某种顺序获取这些数据，所以我

902
00:36:35,790 --> 00:36:37,890
现在会全部获取，然后

903
00:36:37,890 --> 00:36:39,990
在我得到所有信息之前我不会转向下一个运营商

904
00:36:39,990 --> 00:36:41,700
有一些流媒体

905
00:36:41,700 --> 00:36:42,930
运营商，你可以说 好的

906
00:36:42,930 --> 00:36:45,120
，当你得到它时开始流式传输数据

907
00:36:45,120 --> 00:36:47,520
，因为我宁愿早点得到它，

908
00:36:47,520 --> 00:36:48,010
而不是

909
00:36:48,010 --> 00:36:49,450
像我可以在树中做的其他优化那样，

910
00:36:49,450 --> 00:36:51,250
所以在这种情况下

911
00:36:51,250 --> 00:36:52,900
，你知道你的最佳方法将

912
00:36:52,900 --> 00:36:55,390
不起作用赢得 在那种环境中不起作用，但这

913
00:36:55,390 --> 00:36:56,920
是一个常见的反对意见，我们将

914
00:36:56,920 --> 00:37:05,200
在下周看到这一点，好吧，

915
00:37:05,200 --> 00:37:07,330
那么主要的结论

916
00:37:07,330 --> 00:37:10,140
是，如果它是一个集群索引，并且

917
00:37:10,140 --> 00:37:12,970
查询需要它在键上进行排序

918
00:37:12,970 --> 00:37:14,800
索引基于那么你只是

919
00:37:14,800 --> 00:37:16,870
你只使用聚集索引如果它

920
00:37:16,870 --> 00:37:19,270
不是聚集索引那么你

921
00:37:19,270 --> 00:37:23,380
几乎不想使用它所以

922
00:37:23,380 --> 00:37:25,000
这基本上是讨论

923
00:37:25,000 --> 00:37:27,610
排序所以让我们谈谈做一些

924
00:37:27,610 --> 00:37:31,870
其他操作所以模仿我们 '现在

925
00:37:31,870 --> 00:37:34,000
将专注于聚合 ns 因为

926
00:37:34,000 --> 00:37:35,650
对于聚合是另一个很好的

927
00:37:35,650 --> 00:37:38,800
例子或者它

928
00:37:38,800 --> 00:37:41,710
是一种运算符类型的例子，我们

929
00:37:41,710 --> 00:37:44,500
可以让你在排序和散列之间做出选择

930
00:37:44,500 --> 00:37:47,140
作为我们的算法

931
00:37:47,140 --> 00:37:49,000
，然后有不同的权衡

932
00:37:49,000 --> 00:37:49,930
和不同的性能

933
00:37:49,930 --> 00:37:52,900
特征 因为

934
00:37:52,900 --> 00:37:54,370
本质上你知道尝试做

935
00:37:54,370 --> 00:37:55,690
很多切换会访问某人

936
00:37:55,690 --> 00:37:57,610
试图进行随机访问所以也许在某些

937
00:37:57,610 --> 00:37:59,230
情况下，一个人可能比

938
00:37:59,230 --> 00:38:02,140
另一个人更好作为剧透

939
00:38:02,140 --> 00:38:04,270
我要说的是，没有人总是

940
00:38:04,270 --> 00:38:07,600
在 在这种情况下，无论磁盘有多快，

941
00:38:07,600 --> 00:38:10,300
散列方法通常

942
00:38:10,300 --> 00:38:12,190
会更好地工作，我们将看到一个

943
00:38:12,190 --> 00:38:14,940
示例，说明我们如何实际使

944
00:38:14,940 --> 00:38:17,620
散列聚合执行更多的顺序

945
00:38:17,620 --> 00:38:21,190
i/o 而不是随机 i/o，所以

946
00:38:21,190 --> 00:38:22,630
如果你 在春季参加高级课程，

947
00:38:22,630 --> 00:38:24,520
这也是另一件大事，

948
00:38:24,520 --> 00:38:27,100
就像散列总是超快地工作，

949
00:38:27,100 --> 00:38:29,380
因为一切都在内存中，

950
00:38:29,380 --> 00:38:31,420
所以您将如何使用排序进行

951
00:38:31,420 --> 00:38:32,920
聚合？ 在

952
00:38:32,920 --> 00:38:34,000
聚合做什么时，您基本上是在

953
00:38:34,000 --> 00:38:36,010
获取一堆值，然后将

954
00:38:36,010 --> 00:38:37,660
它们合并以生成单个

955
00:38:37,660 --> 00:38:41,710
标量值，因此排序的好处

956
00:38:41,710 --> 00:38:43,090
在于，因为数据

957
00:38:43,090 --> 00:38:45,070
已按照我在传递时所说的进行排序

958
00:38:45,070 --> 00:38:47,770
现在通过排序的输出，我们

959
00:38:47,770 --> 00:38:49,480
不必回溯到计算机

960
00:38:49,480 --> 00:38:51,190
聚合，我们只需执行一次即可

961
00:38:51,190 --> 00:38:52,900
找到计算

962
00:38:52,900 --> 00:38:55,750
我们想要的任何答案，所以让我们在这里看看一个真正

963
00:38:55,750 --> 00:38:58,090
简单的查询，我们想要做我们正在

964
00:38:58,090 --> 00:39:00,490
做的 我们正在对注册表进行扫描，

965
00:39:00,490 --> 00:39:01,780
所有正确的学生都参加

966
00:39:01,780 --> 00:39:03,310


967
00:39:03,310 --> 00:39:05,740
了 CMU 的数据库课程，我们

968
00:39:05,740 --> 00:39:08,290
总是希望

969
00:39:08,290 --> 00:39:10,000
从

970
00:39:10,000 --> 00:39:12,640
学生获得 B 或 C 的任何课程中获取所有不同的课程 ID 我们

971
00:39:12,640 --> 00:39:13,930
希望根据课程 ID 对输出进行排序，

972
00:39:13,930 --> 00:39:16,990
因此

973
00:39:16,990 --> 00:39:18,370
我们在查询计划树中要做的第一件事就是进行

974
00:39:18,370 --> 00:39:20,860
过滤，因此我们将首先

975
00:39:20,860 --> 00:39:23,800
过滤掉

976
00:39:23,800 --> 00:39:26,950
成绩不是 B 的所有元组 或 C 然后

977
00:39:26,950 --> 00:39:28,600
我们要做的下一步是删除所有

978
00:39:28,600 --> 00:39:30,480
我们在输出中不需要的列

979
00:39:30,480 --> 00:39:33,190
我们只需要课程 ID 我们只

980
00:39:33,190 --> 00:39:35,350
需要课程 ID 来执行 order by

981
00:39:35,350 --> 00:39:37,660
和 stink 子句，因为对于我们的

982
00:39:37,660 --> 00:39:40,420
过滤器，它会

983
00:39:40,420 --> 00:39:41,860
在我们在查询中知道的那一点访问成绩表 计划我们不再

984
00:39:41,860 --> 00:39:43,720
需要查看伟大的伟大

985
00:39:43,720 --> 00:39:45,460
专栏我们不再需要

986
00:39:45,460 --> 00:39:47,200
查找学生 ID 所以如果我们可以

987
00:39:47,200 --> 00:39:49,030
在我们继续

988
00:39:49,030 --> 00:39:52,510
下一个操作员之前删除所有这些然后我们现在完成

989
00:39:52,510 --> 00:39:56,320
通过在此处对示例列进行排序，并且

990
00:39:56,320 --> 00:39:58,170
因为我们正在执行不同的

991
00:39:58,170 --> 00:40:01,420
聚合或不同的子句，所以我们

992
00:40:01,420 --> 00:40:03,880
想要删除任何重复的值，所以我们

993
00:40:03,880 --> 00:40:05,590
需要做的就是让我们的游标

994
00:40:05,590 --> 00:40:07,600
扫描它，并在任何时候

995
00:40:07,600 --> 00:40:10,210
找到相同的值 和

996
00:40:10,210 --> 00:40:12,280
我刚刚看到的那个一样，它知道它可以

997
00:40:12,280 --> 00:40:15,190
扔掉它并把它去掉，

998
00:40:15,190 --> 00:40:19,690
这是我们的最终输出，所以我们将

999
00:40:19,690 --> 00:40:23,560
在下周讨论查询计划时更多地讨论

1000
00:40:23,560 --> 00:40:25,960


1001
00:40:25,960 --> 00:40:27,430
这个问题，但在这个管道中这只是一件显而易见的事情 我们

1002
00:40:27,430 --> 00:40:29,860
让学生质疑我所做的是我尝试

1003
00:40:29,860 --> 00:40:32,020


1004
00:40:32,020 --> 00:40:34,570
在我的管道中尽早剔除尽可能

1005
00:40:34,570 --> 00:40:37,150
多的无用数据所以

1006
00:40:37,150 --> 00:40:38,800
我做的第一件事就是过滤器所以说你

1007
00:40:38,800 --> 00:40:41,020
知道说这个表中有十亿

1008
00:40:41,020 --> 00:40:44,440
条记录但只有五个

1009
00:40:44,440 --> 00:40:46,920
匹配或适合他们 匹配我的

1010
00:40:46,920 --> 00:40:49,690
谓词，而不是我先对 10 亿

1011
00:40:49,690 --> 00:40:51,520
条记录进行排序然后返回并

1012
00:40:51,520 --> 00:40:53,470
过滤它，对我来说

1013
00:40:53,470 --> 00:40:55,990
最好先过滤它然后移动那部电影以

1014
00:40:55,990 --> 00:40:57,630
将数据移动到下一个操作符

1015
00:40:57,630 --> 00:41:00,430
与投影相同的事情这

1016
00:41:00,430 --> 00:41:01,990
是一个 行存储

1017
00:41:01,990 --> 00:41:04,510
在我的例子中它不是列存储所以为了让我去

1018
00:41:04,510 --> 00:41:06,820
获取数据我需要做你知道

1019
00:41:06,820 --> 00:41:08,050
我想做的任何排序我

1020
00:41:08,050 --> 00:41:10,090
必须去获取整个我的意思是

1021
00:41:10,090 --> 00:41:11,170
整个记录，因为它会被

1022
00:41:11,170 --> 00:41:13,240
打包在一起 在单个页面中，但如果

1023
00:41:13,240 --> 00:41:14,740
我可以进行投影，

1024
00:41:14,740 --> 00:41:16,270
您将删除我不需要的所有列

1025
00:41:16,270 --> 00:41:17,440
或他们不需要的属性

1026
00:41:17,440 --> 00:41:19,869
，然后现在当我进行排序时，

1027
00:41:19,869 --> 00:41:21,849
我不会复制一堆额外的内容

1028
00:41:21,849 --> 00:41:24,130
数据所以我的那种简单的

1029
00:41:24,130 --> 00:41:26,290
例子 d 与她的问题

1030
00:41:26,290 --> 00:41:29,740
有关，你知道 a 可能实际上

1031
00:41:29,740 --> 00:41:31,420
传递什么，它可能是记录 ID，

1032
00:41:31,420 --> 00:41:33,070
它实际上可能是整个元组

1033
00:41:33,070 --> 00:41:35,800
本身，这取决于我想如何

1034
00:41:35,800 --> 00:41:38,109
实现事物，因此这里的投影

1035
00:41:38,109 --> 00:41:39,490
允许我扔掉我

1036
00:41:39,490 --> 00:41:41,140
不知道的 com 现在不需要，当

1037
00:41:41,140 --> 00:41:44,200
我在进行排序时，我只是你知道

1038
00:41:44,200 --> 00:41:46,330
我正在复制与

1039
00:41:46,330 --> 00:41:47,560
查询计划的其余部分所需的内容相关的东西

1040
00:41:47,560 --> 00:42:15,910
是的，所以他的问题是我的意思

1041
00:42:15,910 --> 00:42:17,050
你说的这个查询并不是真正

1042
00:42:17,050 --> 00:42:19,530
的计数查询，所以这个问题

1043
00:42:19,530 --> 00:42:23,589
是灰色列有一个固定的

1044
00:42:23,589 --> 00:42:27,099
域，这意味着它是一个 BCD 或 EI 不要

1045
00:42:27,099 --> 00:42:29,320
认为把我看成是它你有一个

1046
00:42:29,320 --> 00:42:31,240
完整的权利，但它是固定的 哦，

1047
00:42:31,240 --> 00:42:34,510
还有另一个，不管汤姆

1048
00:42:34,510 --> 00:42:36,070
是什么，当我给你评分时，我

1049
00:42:36,070 --> 00:42:37,950
分不清你是本科生还是

1050
00:42:37,950 --> 00:42:40,480
研究生，所以我想哦，这个

1051
00:42:40,480 --> 00:42:41,859
学生让你知道，获得 a-plus 真是太棒了，

1052
00:42:41,859 --> 00:42:43,359
但后来就这样了 抛出一个错误，

1053
00:42:43,359 --> 00:42:44,500
因为他们是本科生，

1054
00:42:44,500 --> 00:42:46,540
除非你是 ECE，

1055
00:42:46,540 --> 00:42:47,349
我认为你可以

1056
00:42:47,349 --> 00:42:51,099
这是一场噩梦，但无论如何，所以他的

1057
00:42:51,099 --> 00:42:53,320
问题是对的，所以我不能

1058
00:42:53,320 --> 00:42:56,770
有某种边桌，它有一个记录

1059
00:42:56,770 --> 00:42:58,570
每次我

1060
00:42:58,570 --> 00:43:00,130
插入一个具有这些值之一的元组

1061
00:43:00,130 --> 00:43:02,380
和我 '我正在努力维护一个

1062
00:43:02,380 --> 00:43:03,820
会计师 我在一个页面内将那个计数器增加

1063
00:43:03,820 --> 00:43:06,030
一个

1064
00:43:09,870 --> 00:43:13,020
[音乐]

1065
00:43:14,020 --> 00:43:27,530
所以他

1066
00:43:27,530 --> 00:43:32,200
说的是这被存储在一个页面

1067
00:43:32,200 --> 00:43:35,120
这个这个小例子这里是一个

1068
00:43:35,120 --> 00:43:37,610
页面然后对于成绩列我

1069
00:43:37,610 --> 00:43:38,930
可以 跟踪最小值和最大值，

1070
00:43:38,930 --> 00:43:42,530
所以这个案例 B 或 C 所以现在如果我

1071
00:43:42,530 --> 00:43:44,030
说我正在寻找所有

1072
00:43:44,030 --> 00:43:47,390
具有 A 级的人，如果我到达那个页面，我

1073
00:43:47,390 --> 00:43:49,580
看起来说哦，为什么它只在 B 和

1074
00:43:49,580 --> 00:43:52,250
C 因为在那个页面上没有人有 A

1075
00:43:52,250 --> 00:43:53,570
我不是说甚至费心

1076
00:43:53,570 --> 00:43:55,990
看你说的那一栏

1077
00:43:55,990 --> 00:43:58,820
好吧 我认为我们是 - 我想要

1078
00:43:58,820 --> 00:44:01,460
你所描述的同样的东西 称为区域

1079
00:44:01,460 --> 00:44:04,310
地图，我们会的 谈论这个

1080
00:44:04,310 --> 00:44:07,850
我想下周或本周我忘了

1081
00:44:07,850 --> 00:44:09,830
什么时候但基本上有办法

1082
00:44:09,830 --> 00:44:11,990


1083
00:44:11,990 --> 00:44:13,820
在他首先查看的那一侧跟踪辅助数据结构

1084
00:44:13,820 --> 00:44:16,280
，然后您

1085
00:44:16,280 --> 00:44:19,100
检查页面是的，所以这是一个区域地图，

1086
00:44:19,100 --> 00:44:20,570
您可以或不能在

1087
00:44:20,570 --> 00:44:21,890
同一页面中，您可以有一个单独的页面，

1088
00:44:21,890 --> 00:44:24,290
但是 在页面内，但它基本上是一个

1089
00:44:24,290 --> 00:44:26,390
预先计算的信息，说明

1090
00:44:26,390 --> 00:44:28,010
您在此处的数据是

1091
00:44:28,010 --> 00:44:29,690
每个属性可能存在的数据范围，

1092
00:44:29,690 --> 00:44:31,250
您首先参考该范围并做出

1093
00:44:31,250 --> 00:44:32,540
决定是否甚至不

1094
00:44:32,540 --> 00:44:32,930
进一步

1095
00:44:32,930 --> 00:44:35,120
是的，因此这些称为区域地图

1096
00:44:35,120 --> 00:44:37,760
它们被称为 pre oracles 和 zone maps

1097
00:44:37,760 --> 00:44:40,780
巨大的一个调用一个预先计算的

1098
00:44:40,780 --> 00:44:43,430
pre-computer 物化聚合

1099
00:44:43,430 --> 00:44:45,350
有时不同的系统做不同的

1100
00:44:45,350 --> 00:44:45,770
事情

1101
00:44:45,770 --> 00:44:47,330
但确实存在我们稍后会介绍

1102
00:44:47,330 --> 00:44:57,410
是的那是一个索引，这

1103
00:44:57,410 --> 00:44:59,000
就是它索引的作用这里是我的

1104
00:44:59,000 --> 00:45:01,280
东西 更像不像

1105
00:45:01,280 --> 00:45:03,620
Excel 中的那样，我认为是的，

1106
00:45:03,620 --> 00:45:06,820
当你在索引中归因时，这是一个区域地图，

1107
00:45:07,060 --> 00:45:11,480
而且

1108
00:45:11,480 --> 00:45:13,580
续集这样的声明性语言的美妙之处在于

1109
00:45:13,580 --> 00:45:15,500
我写的 我的续集查询是这样的 我

1110
00:45:15,500 --> 00:45:17,570
不知道我是否在使用区域地图 我

1111
00:45:17,570 --> 00:45:19,760
不知道我是否在使用索引 我

1112
00:45:19,760 --> 00:45:21,800
不在乎 数据库不会

1113
00:45:21,800 --> 00:45:22,910
弄清楚我去寻找的最佳策略是什么

1114
00:45:22,910 --> 00:45:24,380
我想要的数据是正确的所以

1115
00:45:24,380 --> 00:45:26,540
只是尝试尝试永不移动

1116
00:45:26,540 --> 00:45:29,990
是尽可能快的废话这

1117
00:45:29,990 --> 00:45:34,220
是所有这一切的全部目标所以这

1118
00:45:34,220 --> 00:45:36,830
是对区域地图的更改我们稍后将

1119
00:45:36,830 --> 00:45:40,520
介绍我想要的

1120
00:45:40,520 --> 00:45:42,290
主要内容 这是如果我被

1121
00:45:42,290 --> 00:45:44,750
排序了，我做一次传递，我可以

1122
00:45:44,750 --> 00:45:47,480
在这个例子中完全消除重复项，这

1123
00:45:47,480 --> 00:45:48,890
对我们来说非常有用，

1124
00:45:48,890 --> 00:45:51,560
因为输出需要

1125
00:45:51,560 --> 00:45:54,530
按课程 ID 排序，所以我是一对一的

1126
00:45:54,530 --> 00:45:56,210
我的排序，因为那是

1127
00:45:56,210 --> 00:45:58,040
我需要的输出，但是我也按照我的输出所需的

1128
00:45:58,040 --> 00:46:01,880
排序顺序，所以

1129
00:46:01,880 --> 00:46:03,590
在这种情况下，在这里进行基于排序的

1130
00:46:03,590 --> 00:46:06,980
聚合对我们来说是一个明确的胜利，但

1131
00:46:06,980 --> 00:46:08,810
在许多情况下我们实际上并不需要

1132
00:46:08,810 --> 00:46:12,680
输出要正确排序，所以你

1133
00:46:12,680 --> 00:46:14,870
仍然可以像你

1134
00:46:14,870 --> 00:46:17,330
可以做的那样使用排序 撕裂眼睛和和做

1135
00:46:17,330 --> 00:46:19,550
不同的事情但是如果你不需要

1136
00:46:19,550 --> 00:46:20,840
被排序那么这实际上可能会

1137
00:46:20,840 --> 00:46:23,000
更昂贵因为排序

1138
00:46:23,000 --> 00:46:26,420
过程本身并不便宜所以这

1139
00:46:26,420 --> 00:46:30,290
是散列可以帮助我们的地方所以散列

1140
00:46:30,290 --> 00:46:35,090
是我们的一种方式 能够再次采用

1141
00:46:35,090 --> 00:46:36,140
另一种分而治之的方法

1142
00:46:36,140 --> 00:46:38,950
，我们可以拆分数据集并

1143
00:46:38,950 --> 00:46:42,500
引导我们检查特定页面的元组或键

1144
00:46:42,500 --> 00:46:44,750


1145
00:46:44,750 --> 00:46:47,480
，然后在这些页面上进行处理和内存，

1146
00:46:47,480 --> 00:46:51,050
但再次散列删除

1147
00:46:51,050 --> 00:46:54,860
所有 locality 所有任何排序顺序，

1148
00:46:54,860 --> 00:46:57,350
因为它采用任何键，你

1149
00:46:57,350 --> 00:46:58,880
知道在它上面做一些散列函数吗，

1150
00:46:58,880 --> 00:47:00,050
现在它会跳到某个随机

1151
00:47:00,050 --> 00:47:02,960
位置，所以如果我们不需要排序，我们认为这很好用，我们

1152
00:47:02,960 --> 00:47:04,940
认为不需要

1153
00:47:04,940 --> 00:47:08,330
需要对事物进行排序，

1154
00:47:08,330 --> 00:47:10,220
以便我们进行散列聚合的方式是我们

1155
00:47:10,220 --> 00:47:12,410
将在股骨散列表中填充

1156
00:47:12,410 --> 00:47:14,840
一些扫描表或

1157
00:47:14,840 --> 00:47:18,440
扫描我们输入的任何内容的日期嘿然后

1158
00:47:18,440 --> 00:47:22,190
说我们你知道什么时候我们做我们 查找

1159
00:47:22,190 --> 00:47:24,020
取决于 o  n

1160
00:47:24,020 --> 00:47:26,750
如果我们进行插入并且

1161
00:47:26,750 --> 00:47:28,430
键不存在，我们正在做什么样的聚合然后我们填充它，如果

1162
00:47:28,430 --> 00:47:30,410
它存在那么我们可能想要修改

1163
00:47:30,410 --> 00:47:33,170
它或修改它的值来计算

1164
00:47:33,170 --> 00:47:34,820


1165
00:47:34,820 --> 00:47:37,820
我们想要的任何聚合 对于不同的它只是一个

1166
00:47:37,820 --> 00:47:40,040
散列，看看它是否在那里，如果

1167
00:47:40,040 --> 00:47:41,930
是，那么我知道它已经是我它是一个

1168
00:47:41,930 --> 00:47:44,270
重复的所以我不打扰

1169
00:47:44,270 --> 00:47:46,100
为组插入它，就像对

1170
00:47:46,100 --> 00:47:48,410
其他聚合的查询一样，您可能

1171
00:47:48,410 --> 00:47:49,940
需要更新运行总数 我们将

1172
00:47:49,940 --> 00:47:53,180
看到一个这样的例子

1173
00:47:53,180 --> 00:47:55,940
如果所有内容都适合

1174
00:47:55,940 --> 00:47:59,570
内存，那么这种方法非常棒 所以我上面说的关键是

1175
00:47:59,570 --> 00:48:01,160
我说的是临时哈希

1176
00:48:01,160 --> 00:48:03,350
表而不是金刚砂哈希表 所以

1177
00:48:03,350 --> 00:48:05,690
临时或瞬态意味着 这

1178
00:48:05,690 --> 00:48:07,250
是一个哈希表，我将通过

1179
00:48:07,250 --> 00:48:10,010
我的一个查询构建，然后当该查询完成时，

1180
00:48:10,010 --> 00:48:11,900
我将其全部丢弃

1181
00:48:11,900 --> 00:48:14,840


1182
00:48:14,840 --> 00:48:16,400


1183
00:48:16,400 --> 00:48:17,840


1184
00:48:17,840 --> 00:48:19,040
数据库系统的不同方式所以 这

1185
00:48:19,040 --> 00:48:20,540
是一个传输数据结构的例子我只

1186
00:48:20,540 --> 00:48:21,830
需要它来进行我的一个查询我做

1187
00:48:21,830 --> 00:48:24,500
任何我想做的然后我把它扔掉所以

1188
00:48:24,500 --> 00:48:25,850
如果一切都在内存中哈希

1189
00:48:25,850 --> 00:48:28,040
表太棒了因为在这种情况下它是一

1190
00:48:28,040 --> 00:48:31,940
本书 UPS 去更新东西

1191
00:48:31,940 --> 00:48:33,380
你也没有做

1192
00:48:33,380 --> 00:48:35,270
正确的删除它只是插入东西或

1193
00:48:35,270 --> 00:48:38,870
更新东西如果我们需要溢出

1194
00:48:38,870 --> 00:48:41,120
磁盘虽然现在我们搞砸了因为

1195
00:48:41,120 --> 00:48:43,250
现在这种随机性会

1196
00:48:43,250 --> 00:48:45,200
伤害我们因为现在我

1197
00:48:45,200 --> 00:48:46,970
跳到不同的不同页面或

1198
00:48:46,970 --> 00:48:49,070
我的哈希表中的块，每个块都可能

1199
00:48:49,070 --> 00:48:52,160
导致 I/O，因此我们希望

1200
00:48:52,160 --> 00:48:53,930
对此更加聪明，并尝试

1201
00:48:53,930 --> 00:48:56,360
最大限度地增加我们可以

1202
00:48:56,360 --> 00:48:57,620
为我们带入

1203
00:48:57,620 --> 00:49:01,550
内存的每一页所做的工作量，这就是外部哈希 我

1204
00:49:01,550 --> 00:49:03,800
聚合了，这又是高

1205
00:49:03,800 --> 00:49:06,020
层次的方式，与

1206
00:49:06,020 --> 00:49:07,850
我们为外部合并排序所做的技术相同，

1207
00:49:07,850 --> 00:49:10,270
这是一种分而治之的方法，

1208
00:49:10,270 --> 00:49:12,320
所以我们首先

1209
00:49:12,320 --> 00:49:13,610
要通过我们的数据，然后

1210
00:49:13,610 --> 00:49:15,620
我们” 重新拆分它 将分区

1211
00:49:15,620 --> 00:49:18,170
划分为桶，以便所有相同的

1212
00:49:18,170 --> 00:49:22,250
元组或者所有相同的

1213
00:49:22,250 --> 00:49:23,780
管具有相同的键

1214
00:49:23,780 --> 00:49:28,070
都将落在同一个分区中，

1215
00:49:28,070 --> 00:49:29,930
然后我们在第二

1216
00:49:29,930 --> 00:49:32,270
阶段返回，现在对于每个分区 我们

1217
00:49:32,270 --> 00:49:34,120
将建立一个内存哈希表，

1218
00:49:34,120 --> 00:49:36,560
然后我们可以做任何

1219
00:49:36,560 --> 00:49:38,450
我们想做的聚合，然后

1220
00:49:38,450 --> 00:49:40,670
我们产生最终的输出，

1221
00:49:40,670 --> 00:49:42,800
以内存哈希表的方式抛出，然后移动

1222
00:49:42,800 --> 00:49:46,310
到下一个分区 我们正在

1223
00:49:46,310 --> 00:49:47,660
最大化我们正在做的顺序 i/o 的数量

1224
00:49:47,660 --> 00:49:49,640
，对于每一

1225
00:49:49,640 --> 00:49:51,620
页，我们每一个 i/o 我们必须做

1226
00:49:51,620 --> 00:49:53,390
的把一些东西带进内存，然后我们

1227
00:49:53,390 --> 00:49:54,050


1228
00:49:54,050 --> 00:49:55,550
在那个页面上做我们需要做的所有工作

1229
00:49:55,550 --> 00:49:57,560
在我们进入下

1230
00:49:57,560 --> 00:49:59,780
一个之前所以我们永远不会再永远我们永远

1231
00:49:59,780 --> 00:50:02,870
不必回溯所以让我们经历

1232
00:50:02,870 --> 00:50:04,910
这两个阶段所以在第一阶段

1233
00:50:04,910 --> 00:50:06,080
我们再次尝试做的是我们

1234
00:50:06,080 --> 00:50:07,160
将把元组分开 到

1235
00:50:07,160 --> 00:50:09,020
分区，然后我们可以

1236
00:50:09,020 --> 00:50:11,720
根据需要写出磁盘 o 我们将使用

1237
00:50:11,720 --> 00:50:13,010
我们的第一个散列函数，它只是

1238
00:50:13,010 --> 00:50:15,050
将事物分开，然后我们再次使用成员

1239
00:50:15,050 --> 00:50:18,050
散列 city hash xx - 3 任何

1240
00:50:18,050 --> 00:50:20,540
无关紧要的，所以

1241
00:50:20,540 --> 00:50:23,240
我们这样做的原因是因为我们的

1242
00:50:23,240 --> 00:50:24,470
散列表散列 函数是

1243
00:50:24,470 --> 00:50:26,750
确定性的，这意味着相同的键将

1244
00:50:26,750 --> 00:50:28,550
始终被赋予相同的散列值

1245
00:50:28,550 --> 00:50:31,220
输出，这意味着

1246
00:50:31,220 --> 00:50:33,200
具有相同键的元组将位于同一个

1247
00:50:33,200 --> 00:50:35,330
分区中，我们不需要

1248
00:50:35,330 --> 00:50:37,280


1249
00:50:37,280 --> 00:50:39,560
在表中寻找表空间的其他部分 为了找到相同的

1250
00:50:39,560 --> 00:50:41,150
键，它们总是会在我们的一个

1251
00:50:41,150 --> 00:50:44,270
分区中，我们的分区可以在它们变满

1252
00:50:44,270 --> 00:50:46,550
时使用缓冲区管理器构建一个磁盘

1253
00:50:46,550 --> 00:50:48,800
，因此我们有一个

1254
00:50:48,800 --> 00:50:51,530
页面来存储当前

1255
00:50:51,530 --> 00:50:53,330
分区数据以及何时 当它变满时，

1256
00:50:53,330 --> 00:50:54,890
我们只需将其写入磁盘并开始

1257
00:50:54,890 --> 00:50:57,800
填充下一页，因此在这种情况下

1258
00:50:57,800 --> 00:50:59,390
，我们将假设我们有 B 个

1259
00:50:59,390 --> 00:51:01,600
缓冲区，我们将使用 B -

1260
00:51:01,600 --> 00:51:04,400
分区缓冲区和至少一个

1261
00:51:04,400 --> 00:51:07,460
缓冲区用于分区 输入所以我要

1262
00:51:07,460 --> 00:51:09,890
带来一页 从我的表中，我

1263
00:51:09,890 --> 00:51:11,420
将要求该页面上的 winchell 扫描

1264
00:51:11,420 --> 00:51:12,800
查看每个元组，然后它会将

1265
00:51:12,800 --> 00:51:14,780
其写出为负 1 个

1266
00:51:14,780 --> 00:51:18,800
分区，因为您需要

1267
00:51:18,800 --> 00:51:20,090
在内存中为每个分区至少有一个缓冲区，

1268
00:51:20,090 --> 00:51:29,960
是的，所以如此 如果说我在

1269
00:51:29,960 --> 00:51:31,580
做，我将

1270
00:51:31,580 --> 00:51:35,750
在接下来的课程 ID 上做一个

1271
00:51:35,750 --> 00:51:38,270
小组，就像我在

1272
00:51:38,270 --> 00:51:41,120


1273
00:51:41,120 --> 00:51:44,300
课程 ID 上做一个小组一样 元组，如果我

1274
00:51:44,300 --> 00:51:45,740
有相同的课程 ID，它会

1275
00:51:45,740 --> 00:51:47,090
在同一个分区中，所以它会

1276
00:51:47,090 --> 00:51:50,840
住在那里，并实时存储，

1277
00:51:50,840 --> 00:51:52,790
然后当我想去的时候这样做

1278
00:51:52,790 --> 00:51:54,230
，在这种情况下，

1279
00:51:54,230 --> 00:51:56,330
当我第二次回来时消除重复

1280
00:51:56,330 --> 00:51:59,690
我知道

1281
00:51:59,690 --> 00:52:01,730
具有相同键的元组必须在同一个

1282
00:52:01,730 --> 00:52:03,200
分区中不会有

1283
00:52:03,200 --> 00:52:05,839
其他随机位置

1284
00:52:05,839 --> 00:52:07,729
这个问题它的分区到页面没有

1285
00:52:07,729 --> 00:52:10,400
分区就像一个有点

1286
00:52:10,400 --> 00:52:14,089
合乎逻辑的事情取散列值 Matta

1287
00:52:14,089 --> 00:52:15,769
by 分区数

1288
00:52:15,769 --> 00:52:17,239
和你写的 into 并且这些分区

1289
00:52:17,239 --> 00:52:21,349
可以有多个页面，所以

1290
00:52:21,349 --> 00:52:24,170
我们再次执行过滤器操作，就像我们删除投影列之前所做的那样

1291
00:52:24,170 --> 00:52:26,059
，然后

1292
00:52:26,059 --> 00:52:29,059
现在我们获取此处的所有输出，

1293
00:52:29,059 --> 00:52:30,469
我们将通过哈希函数运行它

1294
00:52:30,469 --> 00:52:34,009
并编写它 到

1295
00:52:34,009 --> 00:52:36,079
分区页面所以在这种情况下我会

1296
00:52:36,079 --> 00:52:38,420
是 -1 所以说有四个或五个

1297
00:52:38,420 --> 00:52:40,910
我在这里展示三个所以所有 15 个用于

1298
00:52:40,910 --> 00:52:44,809
45 个键的键都在这里 所有 1588 26

1299
00:52:44,809 --> 00:52:48,469
在这里 15 7 21 镜头在这里 所以你

1300
00:52:48,469 --> 00:52:50,509
可以再聪明一点，说

1301
00:52:50,509 --> 00:52:51,890
好吧，我知道我

1302
00:52:51,890 --> 00:52:54,979
在我的页面上做的很不同，如果我看到

1303
00:52:54,979 --> 00:52:57,529
同样的东西，那么不要费心把

1304
00:52:57,529 --> 00:52:59,359
它放进去，但为了简单起见，我们

1305
00:52:59,359 --> 00:53:01,039
只是我们 只是我们盲目地

1306
00:53:01,039 --> 00:53:06,769
把它放在 yes 问题

1307
00:53:06,769 --> 00:53:08,599
是它是什么你可以

1308
00:53:08,599 --> 00:53:11,329
像分区一样认为它是什么分区

1309
00:53:11,329 --> 00:53:14,119
就像你在链中拥有的桶链和链

1310
00:53:14,119 --> 00:53:17,269
哈希表一样，

1311
00:53:17,269 --> 00:53:18,709
你可以 有多个页面，

1312
00:53:18,709 --> 00:53:21,140
但我在内存中只有一页，因为

1313
00:53:21,140 --> 00:53:23,689
我正在填充它 因为

1314
00:53:23,689 --> 00:53:25,489
每次我要

1315
00:53:25,489 --> 00:53:27,229
捕捉一些东西并将其

1316
00:53:27,229 --> 00:53:29,359
插入其中时，我只插入一页，

1317
00:53:29,359 --> 00:53:30,650
当它变满时，我想再次

1318
00:53:30,650 --> 00:53:33,259
写到磁盘上，现在我分配

1319
00:53:33,259 --> 00:53:35,569
另一个我开始填满 所以

1320
00:53:35,569 --> 00:53:37,009
在内存中为什么我第一天做这件事

1321
00:53:37,009 --> 00:53:39,380
我只需要 B 减 1 页，因为

1322
00:53:39,380 --> 00:53:42,519
我会减 1 个分区

1323
00:53:51,280 --> 00:53:52,900
所以这个问题是如果

1324
00:53:52,900 --> 00:54:00,550
你做的不同课程 ID 的数量，因为

1325
00:54:00,550 --> 00:54:02,800
你正确地散列它你是 约会 -

1326
00:54:02,800 --> 00:54:06,130
mod 将这个哈希值 mont by b

1327
00:54:06,130 --> 00:54:09,490
减 1 所以在这个例子中，我只

1328
00:54:09,490 --> 00:54:11,530
显示三个不同的键，但就像我

1329
00:54:11,530 --> 00:54:14,470
在陆地上有另一个 15 for 10 回到

1330
00:54:14,470 --> 00:54:17,670
陆地，与 15 for 45 我

1331
00:54:17,670 --> 00:54:20,200
没有 需要为每个刺痛一个分区

1332
00:54:20,200 --> 00:54:23,800
每个臭味散列允许

1333
00:54:23,800 --> 00:54:27,400
它们进入相同的事物 你的脸

1334
00:54:27,400 --> 00:54:29,290
看起来像你想再次被这个混淆

1335
00:54:29,290 --> 00:54:35,590
所以我有 15 对 10 我

1336
00:54:35,590 --> 00:54:38,380
要散列它我在 它由 B 减 1 它

1337
00:54:38,380 --> 00:54:41,950
落在分区 0 中，所以我只是

1338
00:54:41,950 --> 00:54:45,700
将它附加到此页面装备中 ht

1339
00:54:45,700 --> 00:54:48,070
然后主要的是 15 for 10

1340
00:54:48,070 --> 00:54:50,560
不能存在于任何其他页面中，

1341
00:54:50,560 --> 00:54:52,150
因为哈希函数总是保证

1342
00:54:52,150 --> 00:54:57,580
它总是会指向这个，如果

1343
00:54:57,580 --> 00:54:59,860
当前页面与这个

1344
00:54:59,860 --> 00:55:01,720
分区的分区溢出我将它写出

1345
00:55:01,720 --> 00:55:03,790
磁盘和 我分配一个新页面并开始

1346
00:55:03,790 --> 00:55:11,950
填充是的，你首先加上

1347
00:55:11,950 --> 00:55:15,340
页面分配一个新的页面是的，

1348
00:55:15,340 --> 00:55:18,100
就像在这个阶段一样，我们所做的只是

1349
00:55:18,100 --> 00:55:21,100
这个分区，所以我不在乎我

1350
00:55:21,100 --> 00:55:22,450
可以聪明地说哦，我 正在做

1351
00:55:22,450 --> 00:55:24,280
重复消除 我知道我

1352
00:55:24,280 --> 00:55:25,800
这里已经有 1545 我没有把它放在

1353
00:55:25,800 --> 00:55:28,150
忽略现在

1354
00:55:28,150 --> 00:55:30,370
正确的只是我盲目地把东西

1355
00:55:30,370 --> 00:55:32,890
放到页面上然后把它们写

1356
00:55:32,890 --> 00:55:45,190
出来是的所以这个问题是

1357
00:55:45,190 --> 00:55:47,380
写出磁盘，我在哪里

1358
00:55:47,380 --> 00:55:48,730
存储元数据，说哦，

1359
00:55:48,730 --> 00:55:51,280
分区 0 有这些页面，您

1360
00:55:51,280 --> 00:55:53,920
在内存数据结构中拥有这些页面，您可以

1361
00:55:53,920 --> 00:55:56,110
跟踪类似分区 0 的页面，

1362
00:55:56,110 --> 00:55:57,460
这是我们分区 1 的页面，这是它的页面，

1363
00:55:57,460 --> 00:55:59,500
但它很小，就是这样

1364
00:55:59,500 --> 00:56:02,490
好像没有

1365
00:56:02,520 --> 00:56:04,570
这个问题是我们不考虑

1366
00:56:04,570 --> 00:56:08,640
碰撞我们现在不关心

1367
00:56:08,670 --> 00:56:09,910


1368
00:56:09,910 --> 00:56:12,880
它实际上可能使用另一个表而

1369
00:56:12,880 --> 00:56:13,960
不是模糊可能是跟随

1370
00:56:13,960 --> 00:56:16,300
人但是如果我在做一个你知道

1371
00:56:16,300 --> 00:56:20,380
再次计数你可以更有效地做到这一点

1372
00:56:20,380 --> 00:56:21,760
好吧，但就像我

1373
00:56:21,760 --> 00:56:24,070
不在乎把它放在里面一样，我

1374
00:56:24,070 --> 00:56:25,240
不在乎这个碰撞范围，因为

1375
00:56:25,240 --> 00:56:27,160
我将在第二阶段解决这个问题，

1376
00:56:27,160 --> 00:56:36,310
当我重新讨论你的问题

1377
00:56:36,310 --> 00:56:39,070
时，这个数字是从哪里来的 B

1378
00:56:39,070 --> 00:56:41,320
减一所以 那是数据库系统

1379
00:56:41,320 --> 00:56:43,360
告诉这个查询 退出这些查询的任何

1380
00:56:43,360 --> 00:56:44,740
线程或工作线程

1381
00:56:44,740 --> 00:56:46,390
你有这么多

1382
00:56:46,390 --> 00:56:58,000
内存用于查询处理

1383
00:56:58,000 --> 00:56:59,470


1384
00:56:59,470 --> 00:57:02,680


1385
00:57:02,680 --> 00:57:04,420
在查询旁边

1386
00:57:04,420 --> 00:57:07,630
执行此算法我将使用 B

1387
00:57:07,630 --> 00:57:10,390
减 1 来存储我的部分我将是减 1

1388
00:57:10,390 --> 00:57:11,530
分区因为这些分区将

1389
00:57:11,530 --> 00:57:15,970
有一页是的它很糟糕是的你的

1390
00:57:15,970 --> 00:57:17,950
问题是 B 是否真的很小 我

1391
00:57:17,950 --> 00:57:22,150
是的，你是对的，你

1392
00:57:22,150 --> 00:57:23,619
无能为力，这不是你可能

1393
00:57:23,619 --> 00:57:25,690
知道的，你不能神奇地添加更多

1394
00:57:25,690 --> 00:57:27,160
内存，正确地证明

1395
00:57:27,160 --> 00:57:30,760
你所知道的数据库系统

1396
00:57:30,760 --> 00:57:32,200
正在执行资源管理，它正在

1397
00:57:32,200 --> 00:57:34,030
决定哦，我有 许多查询

1398
00:57:34,030 --> 00:57:36,040
需要同时执行，

1399
00:57:36,040 --> 00:57:37,060
因此我不能让它们都拥有

1400
00:57:37,060 --> 00:57:38,800
大量内存，因此这进入

1401
00:57:38,800 --> 00:57:40,330
了事情的调整方面，这实际上也

1402
00:57:40,330 --> 00:57:53,230
非常困难，是的，所以他说

1403
00:57:53,230 --> 00:57:54,369
，我不这样做 没有幻灯片，我们

1404
00:57:54,369 --> 00:57:59,440
会在下节课上做他说你被

1405
00:57:59,440 --> 00:58:01,680
搞砸了让我改写你说

1406
00:58:01,680 --> 00:58:04,720
你被搞砸的

1407
00:58:04,720 --> 00:58:07,720
东西如果所有东西都是这个桶，你会更好所以说

1408
00:58:07,720 --> 00:58:09,220
这是最受欢迎的课程

1409
00:58:09,220 --> 00:58:12,940
McAmis 每个人 就拿 1545

1410
00:58:12,940 --> 00:58:14,030
当我散列

1411
00:58:14,030 --> 00:58:15,830
每个人都在那里然后我搞砸

1412
00:58:15,830 --> 00:58:18,380
了但是这又进入

1413
00:58:18,380 --> 00:58:19,640
了数据库

1414
00:58:19,640 --> 00:58:22,040
系统可以查看的查询计划方面并说哦我知道

1415
00:58:22,040 --> 00:58:23,900


1416
00:58:23,900 --> 00:58:26,450
这个列和每个人的值分布是什么 被采取 1  5

1417
00:58:26,450 --> 00:58:28,940
40 45 因此，如果我使用这种

1418
00:58:28,940 --> 00:58:32,480
技术，那么我将不会获得

1419
00:58:32,480 --> 00:58:33,650
任何好处，因为一切都会

1420
00:58:33,650 --> 00:58:35,210
随之而来，而且它总是有效的，我

1421
00:58:35,210 --> 00:58:38,650
不妨问问温切尔扫描

1422
00:58:39,550 --> 00:58:41,810
这个问题，你总是不

1423
00:58:41,810 --> 00:58:44,570
知道 像你知道一个好的决定的数据

1424
00:58:44,570 --> 00:58:47,150
会知道一些它不会

1425
00:58:47,150 --> 00:58:49,130
完全准确但它会知道

1426
00:58:49,130 --> 00:59:05,840
一些所以这个表就像

1427
00:59:05,840 --> 00:59:06,830
完整的数据集

1428
00:59:06,830 --> 00:59:08,780
这些可能是不熟练的但是然后

1429
00:59:08,780 --> 00:59:11,210
这又是倾斜的这是这是

1430
00:59:11,210 --> 00:59:15,440
下周或两周，每日 ISM 可以

1431
00:59:15,440 --> 00:59:17,450
维护关于每个

1432
00:59:17,450 --> 00:59:21,170
单列直方图草图的元数据 对于偏斜的工作负载，我会再次

1433
00:59:21,170 --> 00:59:22,310
近似计算出这道菜

1434
00:59:22,310 --> 00:59:25,970
的样子

1435
00:59:25,970 --> 00:59:28,250
你更难接到电话，

1436
00:59:28,250 --> 00:59:30,770
好吧，他有电话，好吧，

1437
00:59:30,770 --> 00:59:31,940
对不起，

1438
00:59:31,940 --> 00:59:33,920
他是 假释出狱后说他接到的

1439
00:59:33,920 --> 00:59:36,980
电话他的假释官没问题，所以为了

1440
00:59:36,980 --> 00:59:39,020
简单起见，我只是说假设

1441
00:59:39,020 --> 00:59:42,470
均匀分布可以再次用于歪曲的

1442
00:59:42,470 --> 00:59:44,330
工作，他们会断言到

1443
00:59:44,330 --> 00:59:45,920
某种程度，这种技术

1444
00:59:45,920 --> 00:59:47,750
不会 斜视骗局中的 ork 将是

1445
00:59:47,750 --> 00:59:54,140
更好的方法是的，这个问题

1446
00:59:54,140 --> 00:59:56,230
是删除列的开销是什么，

1447
00:59:56,230 --> 01:00:03,410
所以在这个例子中，我把它

1448
01:00:03,410 --> 01:00:06,770
显示为像过滤器这样的离散步骤

1449
01:00:06,770 --> 01:00:09,170
，然后删除你可以内联将

1450
01:00:09,170 --> 01:00:11,870
它们组合在一起，但再次 这是另一个

1451
01:00:11,870 --> 01:00:14,300
很好的例子，有一个权衡，所以如果

1452
01:00:14,300 --> 01:00:18,380
我的桌子很大，而且我知道我

1453
01:00:18,380 --> 01:00:21,440
不需要所有的列都在

1454
01:00:21,440 --> 01:00:24,050
一个条目之上，那么对

1455
01:00:24,050 --> 01:00:25,730
我来说支付罚款来做这个

1456
01:00:25,730 --> 01:00:26,920
预测是完全值得的，因为有

1457
01:00:26,920 --> 01:00:29,049
copping 数据，但如果我只有一个

1458
01:00:29,049 --> 01:00:33,099
元组，那么我会

1459
01:00:33,099 --> 01:00:34,210
尽可能晚地推迟这可能是投影，

1460
01:00:34,210 --> 01:00:36,430
因为那会是

1461
01:00:36,430 --> 01:00:38,619
在最后做的更便宜，好吧

1462
01:00:38,619 --> 01:00:41,650
，桌子有多宽和多高

1463
01:00:41,650 --> 01:00:43,750
再次，数据系统可以解决

1464
01:00:43,750 --> 01:00:44,640
这个问题

1465
01:00:44,640 --> 01:00:50,440
，所以我们

1466
01:00:50,440 --> 01:00:52,059
在第一阶段所做的就是

1467
01:00:52,059 --> 01:00:53,950
获取课程 ID 我们正在对它进行散列 我们

1468
01:00:53,950 --> 01:00:55,839
将这些页面放入这些

1469
01:00:55,839 --> 01:00:59,109
分区的这些页面中 我们重新讨论的第二

1470
01:00:59,109 --> 01:01:03,280
阶段 现在每个分区

1471
01:01:03,280 --> 01:01:04,780
我们都要把它们

1472
01:01:04,780 --> 01:01:08,020
带入正确的页面然后我们要

1473
01:01:08,020 --> 01:01:11,770
建立一个命名的内存哈希表

1474
01:01:11,770 --> 01:01:15,180
然后我们可以用它来找到相同的键

1475
01:01:15,180 --> 01:01:17,230
所以我们不必这样做我们 可以

1476
01:01:17,230 --> 01:01:18,579
只引入每个单独的分区

1477
01:01:18,579 --> 01:01:21,190
并对它们进行刮擦或扫描，但是因为

1478
01:01:21,190 --> 01:01:23,200
我们正在进行聚合，所以我们知道我们

1479
01:01:23,200 --> 01:01:26,470
不需要我们不需要

1480
01:01:26,470 --> 01:01:30,250
同时在内存中拥有所有重复的键，

1481
01:01:30,250 --> 01:01:32,680
所以我们 重新使用哈希表对其进行

1482
01:01:32,680 --> 01:01:35,530
汇总，并可以将其压缩

1483
01:01:35,530 --> 01:01:37,390
为

1484
01:01:37,390 --> 01:01:39,690
我们计算结果所需的最少信息，

1485
01:01:39,690 --> 01:01:41,770
再次说明，我们首先进行分区的原因

1486
01:01:41,770 --> 01:01:43,599
是当

1487
01:01:43,599 --> 01:01:45,069
我们回到第二阶段并

1488
01:01:45,069 --> 01:01:47,290
重新进行哈希处理时 我们知道所有相同的键

1489
01:01:47,290 --> 01:01:49,359
都将存在于同一个

1490
01:01:49,359 --> 01:01:52,660
分区中，所以一旦我们浏览了

1491
01:01:52,660 --> 01:01:55,180
该分区中的所有页面，我们就可以计算

1492
01:01:55,180 --> 01:01:56,410
出我们想要的任何答案，

1493
01:01:56,410 --> 01:01:58,720
我们可以将它

1494
01:01:58,720 --> 01:02:00,790
扔到那个哈希表中，因为 我们

1495
01:02:00,790 --> 01:02:02,049
知道有或在 le  ast 将它作为输出生成，

1496
01:02:02,049 --> 01:02:04,420
没有它

1497
01:02:04,420 --> 01:02:06,250
是我们到目前为止更新的键，

1498
01:02:06,250 --> 01:02:07,599
一个分区将永远不会

1499
01:02:07,599 --> 01:02:11,140
从任何其他分区再次更新，

1500
01:02:11,140 --> 01:02:13,829
因为散列保证了我们的局部性，

1501
01:02:13,829 --> 01:02:16,599
所以回到这里，这些是

1502
01:02:16,599 --> 01:02:17,740
所有的桶 我们在

1503
01:02:17,740 --> 01:02:20,290
第一阶段生成，所以现在假设我们可以

1504
01:02:20,290 --> 01:02:23,020
引入你知道我们可以引入你

1505
01:02:23,020 --> 01:02:24,520
知道这两个页面或所有

1506
01:02:24,520 --> 01:02:27,250
分区我们可以

1507
01:02:27,250 --> 01:02:29,260
同时在内存中处理这两个分区

1508
01:02:29,260 --> 01:02:31,660
所以我们要 做的只是有

1509
01:02:31,660 --> 01:02:34,240
一个可以扫描它们的游标

1510
01:02:34,240 --> 01:02:36,339
和你要散列的每个键

1511
01:02:36,339 --> 01:02:39,079
并填充散列表，

1512
01:02:39,079 --> 01:02:40,910
然后我继续扫描并对

1513
01:02:40,910 --> 01:02:43,489
其他所有内容执行相同的操作，然后

1514
01:02:43,489 --> 01:02:46,029
现在我将其作为我的最终结果 结果

1515
01:02:46,029 --> 01:02:48,799
再次让一些人意识到这可能会

1516
01:02:48,799 --> 01:02:50,599
混淆这个哈希表的最终结果，

1517
01:02:50,599 --> 01:02:53,150
或者与这个相同，但

1518
01:02:53,150 --> 01:02:55,130
你知道，主要的收获是

1519
01:02:55,130 --> 01:02:57,049
当我们进入下一个分区时，我们将把它扔掉

1520
01:02:57,049 --> 01:02:59,420


1521
01:02:59,420 --> 01:03:03,410
是的，我们保持不同

1522
01:03:03,410 --> 01:03:05,150
的这个有点太简单了，但就像

1523
01:03:05,150 --> 01:03:06,499
我试图选择一些东西一样，我只是

1524
01:03:06,499 --> 01:03:08,930
提炼出核心思想，好吧，所以

1525
01:03:08,930 --> 01:03:10,789
现在我们在这里得到了另一个分区，所以

1526
01:03:10,789 --> 01:03:12,349
我们再次吹散了哈希

1527
01:03:12,349 --> 01:03:14,630
表 首先，第一组

1528
01:03:14,630 --> 01:03:16,369
分区我们做同样的事情，

1529
01:03:16,369 --> 01:03:18,380
为这个人建立一个 Ameri 哈希表，然后

1530
01:03:18,380 --> 01:03:19,729
我们就在用几分钟完成时

1531
01:03:19,729 --> 01:03:28,549
填充这个东西是的一个问题，她的

1532
01:03:28,549 --> 01:03:29,930
陈述假设我们不会

1533
01:03:29,930 --> 01:03:31,219
在第二个哈希

1534
01:03:31,219 --> 01:03:45,319
函数中发生冲突 你是的，我们可以给她写信，

1535
01:03:45,319 --> 01:03:47,420
所以她的陈述是问题是

1536
01:03:47,420 --> 01:03:50,890
什么意味着你要覆盖这个，

1537
01:03:52,180 --> 01:03:55,130
但是这样

1538
01:03:55,130 --> 01:03:56,390
我们讨论的冲突处理方案我们

1539
01:03:56,390 --> 01:03:57,890
讨论了哈希表，所以它要么是

1540
01:03:57,890 --> 01:04:00,920
线性探测布谷鸟哈希，无论

1541
01:04:00,920 --> 01:04:03,440
罗宾 胡说八道，这就是哈希表的所有

1542
01:04:03,440 --> 01:04:05,809
内部内容，我们在

1543
01:04:05,809 --> 01:04:07,489
它之上，现在我们说的是你的哈希

1544
01:04:07,489 --> 01:04:09,170
表，我可以将东西写入键值

1545
01:04:09,170 --> 01:04:11,349
对，它会为我存储它们，

1546
01:04:11,349 --> 01:04:14,779
我不 不知道，我现在并不真正关心

1547
01:04:14,779 --> 01:04:16,359
它如何处理碰撞，

1548
01:04:16,359 --> 01:04:21,410
好吧，再次与众不同，这是一个非常

1549
01:04:21,410 --> 01:04:23,599
愚蠢的简单示例，但您知道

1550
01:04:23,599 --> 01:04:26,119
经历这些过程是主要的

1551
01:04:26,119 --> 01:04:30,739
事情，我你们都

1552
01:04:30,739 --> 01:04:32,539
没事了，问题是 这

1553
01:04:32,539 --> 01:04:36,319
比对这个特定查询进行排序要快得多，这

1554
01:04:36,319 --> 01:04:43,819
可能不

1555
01:04:43,819 --> 01:04:49,869
取决于数据大小的变化，

1556
01:04:51,940 --> 01:04:54,740
我将介绍这些，让我

1557
01:04:54,740 --> 01:04:56,720
在下周之前真正解决这个问题

1558
01:04:56,720 --> 01:04:58,250
，当你开始看到

1559
01:04:58,250 --> 01:05:02,350
像 不同的联合算法 是的

1560
01:05:03,760 --> 01:05:06,980
是的 再次因为这是这些

1561
01:05:06,980 --> 01:05:08,330
问题 就是为什么我们需要

1562
01:05:08,330 --> 01:05:09,860
这个 就在这个

1563
01:05:09,860 --> 01:05:12,590
和那个例子中 是的 但就像我

1564
01:05:12,590 --> 01:05:14,360
试图表明你看起来你有一个

1565
01:05:14,360 --> 01:05:15,710
临时哈希表 账单 并

1566
01:05:15,710 --> 01:05:17,150
填充，然后当你完成后，

1567
01:05:17,150 --> 01:05:18,830
你把它推到这个东西中 四个

1568
01:05:18,830 --> 01:05:20,630
不同 它是愚蠢的

1569
01:05:20,630 --> 01:05:23,840
对聚合没有意义 欺诈聚合 你

1570
01:05:23,840 --> 01:05:26,200
可能也可以这样做，

1571
01:05:26,200 --> 01:05:29,480
因为再次像这样 可能不

1572
01:05:29,480 --> 01:05:39,620
适合记忆 是的 哦 所以是的 所以我应该

1573
01:05:39,620 --> 01:05:41,780
清楚这是一个不同的种子

1574
01:05:41,780 --> 01:05:43,700
相同所以你知道记住一半的

1575
01:05:43,700 --> 01:05:54,830
差异席位这个问题就像

1576
01:05:54,830 --> 01:05:57,920
说我建立了第一个哈希表并且我

1577
01:05:57,920 --> 01:06:00,800
使用那个 C 作为 散列函数现在

1578
01:06:00,800 --> 01:06:03,470
在这里我需要使用我可以使用

1579
01:06:03,470 --> 01:06:05,200
不同的种子我认为

1580
01:06:05,200 --> 01:06:06,530


1581
01:06:06,530 --> 01:06:08,690
如果你写入这个并不重要如果你

1582
01:06:08,690 --> 01:06:09,920
写入同一个哈希表你

1583
01:06:09,920 --> 01:06:11,240
必须使用相同的 种子，如果

1584
01:06:11,240 --> 01:06:13,040
你以后只是要合并

1585
01:06:13,040 --> 01:06:15,950
它现在没关系 现在

1586
01:06:15,950 --> 01:06:25,280
是的 是的 是的 数据库上的最终结果农民

1587
01:06:25,280 --> 01:06:26,780


1588
01:06:26,780 --> 01:06:28,610
我发送的操作员的最终结果

1589
01:06:28,610 --> 01:06:33,590
总是会是一个关系 所以

1590
01:06:33,590 --> 01:06:35,720
这可能是 一个哈希表它可能

1591
01:06:35,720 --> 01:06:38,270
只是一个页面缓冲区取决于

1592
01:06:38,270 --> 01:06:41,270
实现我意识到就像它

1593
01:06:41,270 --> 01:06:46,150
是相同的形状是的对不起

1594
01:06:46,150 --> 01:06:49,400
好吧所以完成

1595
01:06:49,400 --> 01:06:50,300
让我们谈谈它做一些更

1596
01:06:50,300 --> 01:06:53,000
复杂的事情实际上必须做你

1597
01:06:53,000 --> 01:06:55,940
知道 grens 你知道实际

1598
01:06:55,940 --> 01:06:58,670
产生一个真正的结果所以对于这个

1599
01:06:58,670 --> 01:07:01,310
他们我

1600
01:07:01,310 --> 01:07:04,340
在第二阶段使用过中间哈希表之后，

1601
01:07:04,340 --> 01:07:06,200
我们实际上将使用它来

1602
01:07:06,200 --> 01:07:09,020
维护

1603
01:07:09,020 --> 01:07:10,640
我们试图

1604
01:07:10,640 --> 01:07:12,400
从聚合函数

1605
01:07:12,400 --> 01:07:15,350
正确的聚合中进行的任何竞争的运行总数，因此该运行值将

1606
01:07:15,350 --> 01:07:18,290
取决于你

1607
01:07:18,290 --> 01:07:21,200
实际尝试做的聚合，所以它会回到

1608
01:07:21,200 --> 01:07:24,050
这里所以现在说所有这些人我正在

1609
01:07:24,050 --> 01:07:25,970
做一个我正在获取课程ID

1610
01:07:25,970 --> 01:07:29,450
并且我正在做平均GPA所以在

1611
01:07:29,450 --> 01:07:30,890
哈希表中 我可以

1612
01:07:30,890 --> 01:07:33,860
为所有这些生成我将拥有

1613
01:07:33,860 --> 01:07:36,650
指向此的键映射，例如推翻值

1614
01:07:36,650 --> 01:07:38,330
，它将保持

1615
01:07:38,330 --> 01:07:41,420
我见过的键数的运行计数，

1616
01:07:41,420 --> 01:07:42,740
抱歉，我见过第二个 使用

1617
01:07:42,740 --> 01:07:45,470
相同的密钥，然后只是

1618
01:07:45,470 --> 01:07:50,390
他们 GPA 的总和，然后我就拿

1619
01:07:50,390 --> 01:07:52,820
这个东西，然后当我去

1620
01:07:52,820 --> 01:07:54,200
计算它产生的最终输出时，我

1621
01:07:54,200 --> 01:07:56,000
把运行

1622
01:07:56,000 --> 01:07:57,710
总数除以元组的数量，这就是我如何得到我的

1623
01:07:57,710 --> 01:08:00,320
平均所以对于所有不同的哈希值不同

1624
01:08:00,320 --> 01:08:02,030
nt 聚合函数，

1625
01:08:02,030 --> 01:08:04,780
通常只是跟踪你知道一个

1626
01:08:04,780 --> 01:08:07,430
单一的标量值帐户，

1627
01:08:07,430 --> 01:08:08,660
每次

1628
01:08:08,660 --> 01:08:11,420
看到新键或具有相同值的键时，您只需添加一个

1629
01:08:11,420 --> 01:08:13,220
，然后对于某些值，您只需将

1630
01:08:13,220 --> 01:08:14,990
值加在一起以获得平均值 您

1631
01:08:14,990 --> 01:08:18,380
可以使用

1632
01:08:18,380 --> 01:08:20,210
计数加上标准

1633
01:08:20,210 --> 01:08:22,279
差总和或其他聚合

1634
01:08:22,279 --> 01:08:24,500
函数来计算，您可以维护更多

1635
01:08:24,500 --> 01:08:26,000
信息，所以现在基本上我们

1636
01:08:26,000 --> 01:08:27,740
想要更新哈希表时我们的哈希表中会发生

1637
01:08:27,740 --> 01:08:30,859


1638
01:08:30,859 --> 01:08:32,359
什么 一个插入，如果它不存在，我们就

1639
01:08:32,359 --> 01:08:34,550
添加它，如果它存在，那么我们需要

1640
01:08:34,550 --> 01:08:37,760
能够就地修改它，或者进行

1641
01:08:37,760 --> 01:08:39,620
删除，然后插入以更新

1642
01:08:39,620 --> 01:08:46,189
它，所以如果你在

1643
01:08:46,189 --> 01:08:47,540
排序时这样做一次又一次，你可以 做

1644
01:08:47,540 --> 01:08:48,710
同样的事情，你会把它放在

1645
01:08:48,710 --> 01:08:51,740
一边，然后作为你的扫描

1646
01:08:51,740 --> 01:08:53,870
和最终的输出，

1647
01:08:53,870 --> 01:08:55,250
你不会更新这些总数并

1648
01:08:55,250 --> 01:08:57,970
产生最终输出，

1649
01:08:59,309 --> 01:09:04,099
所以我要跳过这个 r 现在

1650
01:09:04,099 --> 01:09:06,299
这对下周会更有意义

1651
01:09:06,299 --> 01:09:08,309
我们做散列趋势 本质

1652
01:09:08,309 --> 01:09:09,389
上 散列连接本质上

1653
01:09:09,389 --> 01:09:11,368
与我们要构建这个临时散列表 做同样的事情 我们要

1654
01:09:11,368 --> 01:09:14,609
在键

1655
01:09:14,609 --> 01:09:16,500
上进行连接和 然后我们

1656
01:09:16,500 --> 01:09:17,729
调查一下，看看我们是否有

1657
01:09:17,729 --> 01:09:19,589
匹配项，我们是否会产生我们的最终输出

1658
01:09:19,589 --> 01:09:23,250
或操作员，所以让我们得到

1659
01:09:23,250 --> 01:09:26,158
这个，然后我们会集中注意力，我们将

1660
01:09:26,158 --> 01:09:28,288
在下周或下周三再次讨论这个问题

1661
01:09:28,288 --> 01:09:29,609
做散列行

1662
01:09:29,609 --> 01:09:32,460


1663
01:09:32,460 --> 01:09:36,259
好吧，总而言之，所以我今天展示的

1664
01:09:36,259 --> 01:09:39,000
是排序和散列之间的这种权衡，

1665
01:09:39,000 --> 01:09:41,038
我们将在下周讨论连接时

1666
01:09:41,038 --> 01:09:42,569
再次详细介绍哪个

1667
01:09:42,569 --> 01:09:44,368
比另一个更好

1668
01:09:44,368 --> 01:09:49,259


1669
01:09:49,259 --> 01:09:50,520
我们在这里讨论的高级技术

1670
01:09:50,520 --> 01:09:51,658
适用于

1671
01:09:51,658 --> 01:09:53,719
数据库系统的所有部分 所以这种分区

1672
01:09:53,719 --> 01:09:55,559
方法 这种分而治之的

1673
01:09:55,559 --> 01:09:57,630
方法 所有对其他算法有用

1674
01:09:57,630 --> 01:09:59,309
我们

1675
01:09:59,309 --> 01:10:01,110
在我们的系统中关心的其他方法 所以我们 将

1676
01:10:01,110 --> 01:10:02,520
在整个学期剩下的时间里看到这个反复出现的主题

1677
01:10:02,520 --> 01:10:04,349
，将事情

1678
01:10:04,349 --> 01:10:06,329
分成更小的工作单元并尝试

1679
01:10:06,329 --> 01:10:08,130
对那一小块

1680
01:10:08,130 --> 01:10:10,349
数据或小问题进行操作将是非常

1681
01:10:10,349 --> 01:10:14,489
非常有用的技术，好吧，

1682
01:10:14,489 --> 01:10:17,699
让我们知道什么项目二 所以项目

1683
01:10:17,699 --> 01:10:19,440
二你将构建一个

1684
01:10:19,440 --> 01:10:22,530
线程安全的线性探测哈希表，所以

1685
01:10:22,530 --> 01:10:24,420
这是我

1686
01:10:24,420 --> 01:10:26,309
建立在你在第一个项目中构建的缓冲池之上，所以它

1687
01:10:26,309 --> 01:10:27,690
不是内存中的哈希表，它有我们

1688
01:10:27,690 --> 01:10:30,630
支持的磁盘页面所以 我们不会

1689
01:10:30,630 --> 01:10:32,849
做我们在这堂课上讨论过的任何事情

1690
01:10:32,849 --> 01:10:34,110
我们正在做的事情是

1691
01:10:34,110 --> 01:10:36,030
尽量提高紧缩性

1692
01:10:36,030 --> 01:10:38,250


1693
01:10:38,250 --> 01:10:40,380


1694
01:10:40,380 --> 01:10:43,739
插入和删除，因此

1695
01:10:43,739 --> 01:10:45,480
您将支持调整大小，因此再次

1696
01:10:45,480 --> 01:10:47,670
线性探测哈希表假定它是一个

1697
01:10:47,670 --> 01:10:49,679
静态哈希表，但是当它变满时，

1698
01:10:49,679 --> 01:10:51,480
您需要锁定它，

1699
01:10:51,480 --> 01:10:53,429
然后调整整个事物的大小，因此您

1700
01:10:53,429 --> 01:10:55,440
需要支持调整大小 l 并且

1701
01:10:55,440 --> 01:10:57,449
当多个线程可以同时访问哈希表时，您需要支持执行此调整大小，

1702
01:10:57,449 --> 01:10:59,520


1703
01:10:59,520 --> 01:11:02,219


1704
01:11:02,219 --> 01:11:05,190
因此网站已启动，

1705
01:11:05,190 --> 01:11:05,880
尚未在广场上宣布

1706
01:11:05,880 --> 01:11:09,420
将保留什么

1707
01:11:09,420 --> 01:11:10,769
我们正在为源做一些最终调整

1708
01:11:10,769 --> 01:11:12,449
在发布给你们之前的代码但我们

1709
01:11:12,449 --> 01:11:12,800
希望

1710
01:11:12,800 --> 01:11:16,850
这将在今天晚些时候我不知道

1711
01:11:16,850 --> 01:11:18,650
让我们的动画好所以有

1712
01:11:18,650 --> 01:11:20,720
四个测试你必须做的

1713
01:11:20,720 --> 01:11:22,010
第一件事是你负责

1714
01:11:22,010 --> 01:11:24,500
设计

1715
01:11:24,500 --> 01:11:27,380
哈希表块，因此这是标题

1716
01:11:27,380 --> 01:11:29,480
页，然后实际块页

1717
01:11:29,480 --> 01:11:30,730
是存储实际键值的位置，

1718
01:11:30,730 --> 01:11:33,050
因此这是一个有用的练习，可让

1719
01:11:33,050 --> 01:11:36,040
您了解

1720
01:11:36,040 --> 01:11:38,510
从缓冲池管理器中获取您知道的页面意味着什么

1721
01:11:38,510 --> 01:11:40,910
然后能够

1722
01:11:40,910 --> 01:11:41,960
以这样一种方式来解释它，

1723
01:11:41,960 --> 01:11:44,150
准确地存储你想要的数据，这不是

1724
01:11:44,150 --> 01:11:45,470
你在某个空间中的 malloc 你

1725
01:11:45,470 --> 01:11:46,940
会撞到 Amanda 他说给我一个

1726
01:11:46,940 --> 01:11:48,950
页面，你说哦，这是一个这个 是一个

1727
01:11:48,950 --> 01:11:51,320
哈希表 b 锁定页面这里是

1728
01:11:51,320 --> 01:11:52,400
找到我正在寻找的数据的偏移量

1729
01:11:52,400 --> 01:11:54,770
你如何对该数据进行重新解释转换，

1730
01:11:54,770 --> 01:11:55,100


1731
01:11:55,100 --> 01:11:56,930
以便你首先实现这两个

1732
01:11:56,930 --> 01:11:58,670
类，它们执行标题页面，然后

1733
01:11:58,670 --> 01:12:00,470
是块页面，然后你想要

1734
01:12:00,470 --> 01:12:02,620
实现基本哈希 表本身

1735
01:12:02,620 --> 01:12:06,800
有权进行插入和删除，

1736
01:12:06,800 --> 01:12:08,840
它们还支持

1737
01:12:08,840 --> 01:12:11,390
使用我们为您提供的读写器闩锁的并发操作

1738
01:12:11,390 --> 01:12:13,190
，然后还支持

1739
01:12:13,190 --> 01:12:15,680
调整大小，您将整个表中的闩锁

1740
01:12:15,680 --> 01:12:17,630
加倍，然后重新

1741
01:12:17,630 --> 01:12:19,550
散列所有内容，以便您需要 需要

1742
01:12:19,550 --> 01:12:23,360
能够支持这一点，所以你应该

1743
01:12:23,360 --> 01:12:26,360
遵循教科书的语义和

1744
01:12:26,360 --> 01:12:29,210
算法，了解他们如何知道

1745
01:12:29,210 --> 01:12:31,070
如何进行各种操作

1746
01:12:31,070 --> 01:12:33,800
我认为我在 milena 哈希表上的讲座

1747
01:12:33,800 --> 01:12:35,360
非常

1748
01:12:35,360 --> 01:12:37,070
接近教科书，而后来的哈希表没有

1749
01:12:37,070 --> 01:12:38,870
有很多你知道不同的设计

1750
01:12:38,870 --> 01:12:40,040
决定你必须做出它

1751
01:12:40,040 --> 01:12:43,300
只是通过这些 X 步骤我

1752
01:12:43,300 --> 01:12:45,680
建议你首先明显地在页面布局上工作，

1753
01:12:45,680 --> 01:12:47,000
因为你了解你

1754
01:12:47,000 --> 01:12:47,900


1755
01:12:47,900 --> 01:12:49,700
无论如何都不能有一个可以存储在页面中的哈希表，但是

1756
01:12:49,700 --> 01:12:51,650


1757
01:12:51,650 --> 01:12:54,110
在继续实际构建哈希表本身之前，您应该确保您的页面运行良好，

1758
01:12:54,110 --> 01:12:56,150
因此我们将

1759
01:12:56,150 --> 01:12:59,210
再次为您提供一些基本的测试用例

1760
01:12:59,210 --> 01:13:00,710
来做一些 对您的页面布局进行基本检查，

1761
01:13:00,710 --> 01:13:02,510
但由你们来

1762
01:13:02,510 --> 01:13:04,160
确保它实际上是您知道的，

1763
01:13:04,160 --> 01:13:05,840
您是否更严格，因为如果您的

1764
01:13:05,840 --> 01:13:08,300
页面布局被搞砸了，然后现在

1765
01:13:08,300 --> 01:13:09,500
您开始在上面做哈希表

1766
01:13:09,500 --> 01:13:10,820
就像盖房子一样 在沙子上，

1767
01:13:10,820 --> 01:13:12,410
因为现在你就像我的哈希表

1768
01:13:12,410 --> 01:13:14,120
不工作，这可能是

1769
01:13:14,120 --> 01:13:15,800
因为你的页面不能正常工作

1770
01:13:15,800 --> 01:13:18,500
所以在移动到下一件事之前把它固定下来，

1771
01:13:18,500 --> 01:13:22,220
然后

1772
01:13:22,220 --> 01:13:23,900
当你真正构建哈希表

1773
01:13:23,900 --> 01:13:25,970
本身时 不要担心使其

1774
01:13:25,970 --> 01:13:26,570
线程安全首先

1775
01:13:26,570 --> 01:13:30,170
专注于诚实的单线程

1776
01:13:30,170 --> 01:13:32,780
支持这

1777
01:13:32,780 --> 01:13:34,520
是数据库系统中的常见设计方法这是

1778
01:13:34,520 --> 01:13:35,989
我在自己的研究

1779
01:13:35,989 --> 01:13:39,110
中采用的方法，在实践中我认为这是我 不是每个

1780
01:13:39,110 --> 01:13:40,730
公司都遵循这一点 他

1781
01:13:40,730 --> 01:13:41,900
为那些不

1782
01:13:41,900 --> 01:13:47,030
遵循这一点的公司穿着衬衫 首先关注正确性

1783
01:13:47,030 --> 01:13:50,480
不要担心它会变慢 所以

1784
01:13:50,480 --> 01:13:51,860
让它你知道确保它

1785
01:13:51,860 --> 01:13:53,090
完全按照你认为它应该工作

1786
01:13:53,090 --> 01:13:55,280
然后去 回来现在开始做

1787
01:13:55,280 --> 01:13:56,449
一些优化，他

1788
01:13:56,449 --> 01:13:57,590
建议的一些事情我们在课堂上讨论过的一些事情

1789
01:13:57,590 --> 01:14:00,949
是你知道做乐观

1790
01:14:00,949 --> 01:14:02,929
闩锁更狡猾关于你如何

1791
01:14:02,929 --> 01:14:05,510
正确释放闩锁确保它

1792
01:14:05,510 --> 01:14:07,010
正确工作强制有测试用例

1793
01:14:07,010 --> 01:14:08,599
证明它对你来说是正确的，然后

1794
01:14:08,599 --> 01:14:09,710
当你开始尝试让它运行

1795
01:14:09,710 --> 01:14:11,239
得更快时，因为我们将有一个排行榜

1796
01:14:11,239 --> 01:14:12,790
来查看谁拥有最快的哈希表

1797
01:14:12,790 --> 01:14:15,770
然后你知道然后你知道你

1798
01:14:15,770 --> 01:14:17,329
正在使用一个又一个可靠的

1799
01:14:17,329 --> 01:14:23,570
实施没问题，所以

1800
01:14:23,570 --> 01:14:25,099
就像以前一样，

1801
01:14:25,099 --> 01:14:27,079
除了

1802
01:14:27,079 --> 01:14:28,250
必须在很大范围内吐出的文件之外，您不需要更改系统中的任何其他文件，

1803
01:14:28,250 --> 01:14:30,469
这就是我们现在正在做的事情，

1804
01:14:30,469 --> 01:14:32,599
所以威尔逊在广场上宣布 如果您

1805
01:14:32,599 --> 01:14:34,909
想在最新的 master 之上重新调整现有代码，

1806
01:14:34,909 --> 01:14:36,139
因为在您提供说明之前，我将

1807
01:14:36,139 --> 01:14:38,719
引入新的示例头文件

1808
01:14:38,719 --> 01:14:41,020
和示例测试用例，然后

1809
01:14:41,020 --> 01:14:43,670
您将准确

1810
01:14:43,670 --> 01:14:44,900
地提供执行 rebase 所需的

1811
01:14:44,900 --> 01:14:46,820
操作 知道因为你可以

1812
01:14:46,820 --> 01:14:48,909


1813
01:14:48,909 --> 01:14:53,020
用保时捷的推动力很容易地吹走你在 github 上的源代码

1814
01:14:53,020 --> 01:14:55,219
确保你备份

1815
01:14:55,219 --> 01:14:57,710
你的副本，但首先在你开始

1816
01:14:57,710 --> 01:15:00,560
做 rebase 之前，然后像往常一样

1817
01:15:00,560 --> 01:15:03,889
在 Piazza 上发布你的问题，然后来到

1818
01:15:03,889 --> 01:15:14,239
来到办公时间 是的，这个问题

1819
01:15:14,239 --> 01:15:15,829
是如果我们假设你

1820
01:15:15,829 --> 01:15:17,510
在第一个项目上获得了 100 分的分数，并且你

1821
01:15:17,510 --> 01:15:19,699
假设你的 buff 消除

1822
01:15:19,699 --> 01:15:24,500
是可靠的支持 hashable 是的，我可能

1823
01:15:24,500 --> 01:15:28,480
是错的，但我们认为我们测试是

1824
01:15:29,440 --> 01:15:33,590
正确的，但是 我想说就像去年有一个

1825
01:15:33,590 --> 01:15:35,690
博客一样，那个确切的问题

1826
01:15:35,690 --> 01:15:38,000
出现了所有未解决的问题所以我

1827
01:15:38,000 --> 01:15:39,500
认为如果你通过了我们的测试它

1828
01:15:39,500 --> 01:15:44,450
应该是可靠的这个问题现在即将

1829
01:15:44,450 --> 01:15:45,680
发布一条裙子我不能这样做

1830
01:15:45,680 --> 01:15:47,060
b 因为还有一些人

1831
01:15:47,060 --> 01:15:54,260
还没有提交，让我们把

1832
01:15:54,260 --> 01:16:03,170
一切都放在后面，是的，

1833
01:16:03,170 --> 01:16:05,180
对于第一个项目很抱歉，你可以

1834
01:16:05,180 --> 01:16:06,020
随心所欲地提交，

1835
01:16:06,020 --> 01:16:08,420
是的，

1836
01:16:08,420 --> 01:16:10,160
无论你从什么时候获得最高分

1837
01:16:10,160 --> 01:16:12,410
最后我看到了很大的范围让你

1838
01:16:12,410 --> 01:16:13,880
激活你想要的得分你想试试

1839
01:16:13,880 --> 01:16:15,530
我认为但它

1840
01:16:15,530 --> 01:16:18,200
是截止日期前的最高分我们将

1841
01:16:18,200 --> 01:16:18,620
使用

1842
01:16:18,620 --> 01:16:22,280
是的你提交的就是你想要的

1843
01:16:22,280 --> 01:16:23,930
如果你得到的话 之前有一个 80

1844
01:16:23,930 --> 01:16:25,100
并且在截止日期之后有一个猎人

1845
01:16:25,100 --> 01:16:27,590
你有一个 80 你

1846
01:16:27,590 --> 01:16:29,170
像晚年一样玩游戏

1847
01:16:29,170 --> 01:16:40,820
但是你知道是的 你的

1848
01:16:40,820 --> 01:16:41,990
问题是如果你在项目一之后改变你的邀请怎么办

1849
01:16:41,990 --> 01:16:44,360


1850
01:16:44,360 --> 01:16:47,210
仍然会是你这样的

1851
01:16:47,210 --> 01:16:48,860
人 Schmitt 在很大范围

1852
01:16:48,860 --> 01:16:53,210
内 项目一的旧项目 我们也可以

1853
01:16:53,210 --> 01:16:54,890
将它放入第一个测试中，

1854
01:16:54,890 --> 01:16:56,810
如果你愿意的话，让它更容易，就像

1855
01:16:56,810 --> 01:16:58,580
它会运行你赢得的第一个

1856
01:16:58,580 --> 01:17:00,620
项目的所有测试 不哥 为那个得分

1857
01:17:00,620 --> 01:17:02,570
但确实在那里我们可以做得

1858
01:17:02,570 --> 01:17:07,490
很好解决这个问题好吧你知道

1859
01:17:07,490 --> 01:17:09,100
让它变慢这是唯一的事情

1860
01:17:09,100 --> 01:17:11,659
[音乐]

1861
01:17:11,659 --> 01:17:14,429
是的但是你仍然可以

1862
01:17:14,429 --> 01:17:19,369
提交第一个好吧不要剽窃

1863
01:17:19,369 --> 01:17:21,659
我们赢了 我们要运行这个浮雕

1864
01:17:21,659 --> 01:17:23,489
这是我们这周为

1865
01:17:23,489 --> 01:17:24,839
你的第一个项目做这个 如果你

1866
01:17:24,839 --> 01:17:26,849
抄袭他妈的曾经穿过一个洞你会被

1867
01:17:26,849 --> 01:17:27,749
踢出去好吧

1868
01:17:27,749 --> 01:17:30,239
下一节课我们正在做

1869
01:17:30,239 --> 01:17:31,800
关节 现场加入合作伙伴

1870
01:17:31,800 --> 01:17:34,979
加入哈希币 好吧，他

1871
01:17:34,979 --> 01:18:00,659
接到了一个电话，伙计们，跳弹果冻

1872
01:18:00,659 --> 01:18:03,659
打熟食店，自然而然地说唱

1873
01:18:03,659 --> 01:18:11,069
就像瓶子不填，只

1874
01:18:11,069 --> 01:18:14,639
给你喝不能，如果水槽不认识

1875
01:18:14,639 --> 01:18:17,569
你 因为付不起

1876
01:18:17,600 --> 01:18:20,649
[音乐]

