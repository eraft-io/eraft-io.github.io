1
00:00:01,300 --> 00:00:05,129
[Music]

2
00:00:05,200 --> 00:00:05,930
[Applause]

3
00:00:05,930 --> 00:00:08,630
[Music]

4
00:00:08,630 --> 00:00:10,020
[Applause]

5
00:00:10,020 --> 00:00:11,480
[Music]

6
00:00:11,480 --> 00:00:13,530
for today's class we're going to

7
00:00:13,530 --> 00:00:15,960
continue our discussion on multi-version

8
00:00:15,960 --> 00:00:18,810
cooker treat all and so last class we

9
00:00:18,810 --> 00:00:20,730
spent time talking about the four major

10
00:00:20,730 --> 00:00:22,710
design decisions when you build an NBC

11
00:00:22,710 --> 00:00:24,660
database system right Kurt's your

12
00:00:24,660 --> 00:00:26,789
protocol even though control is in the

13
00:00:26,789 --> 00:00:29,070
name over designing again this is how

14
00:00:29,070 --> 00:00:30,779
we're gonna create transactions the

15
00:00:30,779 --> 00:00:32,880
Virgen storage basically every time we

16
00:00:32,880 --> 00:00:34,469
update a tuple where do we actually

17
00:00:34,469 --> 00:00:36,140
store that fit new physical version

18
00:00:36,140 --> 00:00:37,980
garbage collection cleaning up all

19
00:00:37,980 --> 00:00:39,450
versions and then index management

20
00:00:39,450 --> 00:00:42,750
basically how do we keep track of what

21
00:00:42,750 --> 00:00:44,160
are the secondary indexes point to

22
00:00:44,160 --> 00:00:45,570
really either point to the actual

23
00:00:45,570 --> 00:00:46,950
physical version the head of the version

24
00:00:46,950 --> 00:00:48,870
chain or D pointing to some some logic

25
00:00:48,870 --> 00:00:51,750
identifier so for today's class we're

26
00:00:51,750 --> 00:00:53,340
now going to go into more detail and

27
00:00:53,340 --> 00:00:55,800
look at real world implementations of

28
00:00:55,800 --> 00:00:59,010
modern nbcc systems and what will happen

29
00:00:59,010 --> 00:01:00,570
is we'll do this in the context of the

30
00:01:00,570 --> 00:01:01,800
four design decisions that we talked

31
00:01:01,800 --> 00:01:04,559
about last class but we'll spend a

32
00:01:04,559 --> 00:01:05,790
little more time talking about how

33
00:01:05,790 --> 00:01:07,260
they're actually going to do the first

34
00:01:07,260 --> 00:01:08,670
one they actually concur to a protocol

35
00:01:08,670 --> 00:01:09,780
itself all right how they're going to

36
00:01:09,780 --> 00:01:12,360
coordinate transactions but then as we

37
00:01:12,360 --> 00:01:14,340
go along they'll also be other aspects

38
00:01:14,340 --> 00:01:15,600
of these database systems that we'll

39
00:01:15,600 --> 00:01:19,200
cover that are good ideas potentially

40
00:01:19,200 --> 00:01:21,180
for having a high performance MVCC

41
00:01:21,180 --> 00:01:23,820
system that doesn't fit exactly into the

42
00:01:23,820 --> 00:01:25,470
the four design decisions that we talked

43
00:01:25,470 --> 00:01:28,560
about before and so the way we'll go

44
00:01:28,560 --> 00:01:29,729
through and perceive the discussion will

45
00:01:29,729 --> 00:01:31,170
first talk start with Microsoft

46
00:01:31,170 --> 00:01:32,820
hackathon because that was sort of the

47
00:01:32,820 --> 00:01:35,460
first implementation of a modern

48
00:01:35,460 --> 00:01:39,420
in-memory MVCC system in 2011 2012 and

49
00:01:39,420 --> 00:01:41,579
that'll serve as the baseline for us

50
00:01:41,579 --> 00:01:43,649
understanding how these other systems

51
00:01:43,649 --> 00:01:45,060
implement MVCC all right so if you

52
00:01:45,060 --> 00:01:46,380
understand this they're gonna say are

53
00:01:46,380 --> 00:01:48,030
how can we tweak tweak it or do

54
00:01:48,030 --> 00:01:50,399
different things are add add additional

55
00:01:50,399 --> 00:01:52,049
things through that nbcc implementation

56
00:01:52,049 --> 00:01:55,530
that can improve what hackathon original

57
00:01:55,530 --> 00:01:58,770
opposed okay again so hackathons we

58
00:01:58,770 --> 00:02:01,320
focused on OLTP these two here hyper and

59
00:02:01,320 --> 00:02:03,630
hana we focus on old TV was OLAP and

60
00:02:03,630 --> 00:02:05,250
then we'll come back with cicada to

61
00:02:05,250 --> 00:02:08,429
discuss how we do or how to do old to be

62
00:02:08,429 --> 00:02:12,720
again all right all right so who here

63
00:02:12,720 --> 00:02:13,890
has actually ever heard a heck of tom

64
00:02:13,890 --> 00:02:16,830
for that hasn't hung around me right

65
00:02:16,830 --> 00:02:20,700
that's nice okay so like it is it

66
00:02:20,700 --> 00:02:22,470
started off as a research project at

67
00:02:22,470 --> 00:02:25,400
Microsoft and then now action ships in

68
00:02:25,400 --> 00:02:28,080
sequel server today but like when you

69
00:02:28,080 --> 00:02:29,310
read the documentation they don't call

70
00:02:29,310 --> 00:02:30,959
it hackathon I think it just called a

71
00:02:30,959 --> 00:02:33,090
memory storage but if you if you look at

72
00:02:33,090 --> 00:02:35,910
the papers I refer to everything as you

73
00:02:35,910 --> 00:02:37,730
know this project has hackathon so

74
00:02:37,730 --> 00:02:41,010
hecatomb project started in 2008 at

75
00:02:41,010 --> 00:02:44,840
Microsoft as a way to extend the the

76
00:02:44,840 --> 00:02:47,730
lifetime of of sequel server so at this

77
00:02:47,730 --> 00:02:49,650
point 2008 sequel server was 20 years

78
00:02:49,650 --> 00:02:51,510
old and so they started the project to

79
00:02:51,510 --> 00:02:54,090
say well what cleaning what can we do to

80
00:02:54,090 --> 00:02:55,769
improve the performance and modernize

81
00:02:55,769 --> 00:02:58,650
the system such that Mikus our sequel

82
00:02:58,650 --> 00:03:00,300
server is still relevant you know 20

83
00:03:00,300 --> 00:03:02,340
years from now my sequel server it makes

84
00:03:02,340 --> 00:03:04,500
it mix Microsoft bit of money so they

85
00:03:04,500 --> 00:03:05,850
said you know how do we keep that gravy

86
00:03:05,850 --> 00:03:09,390
train going 20 years in the future so

87
00:03:09,390 --> 00:03:10,800
they decided to work on how do you

88
00:03:10,800 --> 00:03:12,530
actually build a new OTP engine

89
00:03:12,530 --> 00:03:14,790
specifically for you know for the CI

90
00:03:14,790 --> 00:03:17,220
server ecosystem so if you don't know

91
00:03:17,220 --> 00:03:21,480
the history of sequel server in 1919 93

92
00:03:21,480 --> 00:03:25,049
92 they actually bought a license to

93
00:03:25,049 --> 00:03:27,600
Sybase and then they support it to

94
00:03:27,600 --> 00:03:29,579
Windows NT and then a little bit after

95
00:03:29,579 --> 00:03:30,720
that then they bought the source code

96
00:03:30,720 --> 00:03:32,190
license from Sybase they end up working

97
00:03:32,190 --> 00:03:34,320
it and at this point they've rewritten

98
00:03:34,320 --> 00:03:36,510
everything from scratch I'm sure all

99
00:03:36,510 --> 00:03:38,549
over again but there are still remnants

100
00:03:38,549 --> 00:03:41,989
of sequels or sigh basis influence in

101
00:03:41,989 --> 00:03:44,280
sequel server today like sequel server

102
00:03:44,280 --> 00:03:45,989
uses T sequel which is a variant of

103
00:03:45,989 --> 00:03:49,140
sequel that's what Sybase used and

104
00:03:49,140 --> 00:03:50,400
certainly now today sequel server is

105
00:03:50,400 --> 00:03:51,930
still considered a this is considered a

106
00:03:51,930 --> 00:03:53,160
state of the art system whereas sigh

107
00:03:53,160 --> 00:03:55,320
basis is more or less in in maintenance

108
00:03:55,320 --> 00:03:57,930
mode ASAP bought Sybase they still make

109
00:03:57,930 --> 00:04:00,690
a shitload of money on it because we had

110
00:04:00,690 --> 00:04:02,579
the the guy that sort of leads the

111
00:04:02,579 --> 00:04:04,110
Sybase project give a guest lecture in

112
00:04:04,110 --> 00:04:07,590
this class last year but you know it's

113
00:04:07,590 --> 00:04:09,900
there no star was saying like oh I'm

114
00:04:09,900 --> 00:04:11,160
gonna build my new system based on

115
00:04:11,160 --> 00:04:12,709
Sybase right nobody does that

116
00:04:12,709 --> 00:04:16,529
all right so they took to start this

117
00:04:16,529 --> 00:04:19,410
project Microsoft got to very family's

118
00:04:19,410 --> 00:04:21,660
database people at Microsoft Paul Larsen

119
00:04:21,660 --> 00:04:23,130
was an MSR he's sort of a famous

120
00:04:23,130 --> 00:04:24,300
database person who's been around for a

121
00:04:24,300 --> 00:04:26,220
while like he invented linear hashing in

122
00:04:26,220 --> 00:04:27,540
the 1980s

123
00:04:27,540 --> 00:04:29,640
and much indeed much work a deck Mike

124
00:04:29,640 --> 00:04:30,930
Zwilling was actually one of the main

125
00:04:30,930 --> 00:04:32,340
people they hired at the very beginning

126
00:04:32,340 --> 00:04:33,960
when they started sequence over to help

127
00:04:33,960 --> 00:04:36,090
them port the Sybase code over to

128
00:04:36,090 --> 00:04:38,910
Windows NT and he worked at unity of his

129
00:04:38,910 --> 00:04:40,110
content on a very influential

130
00:04:40,110 --> 00:04:42,480
influential system called sure

131
00:04:42,480 --> 00:04:44,160
so they got basically the two best

132
00:04:44,160 --> 00:04:47,550
people to lead this project so unlike

133
00:04:47,550 --> 00:04:50,310
Hana Hecate on cicada and a bunch of

134
00:04:50,310 --> 00:04:51,240
other systems we'll talk about this

135
00:04:51,240 --> 00:04:53,460
semester instead of building a brand-new

136
00:04:53,460 --> 00:04:55,980
databases from scratch for the hackathon

137
00:04:55,980 --> 00:04:57,420
project they had to make sure that it

138
00:04:57,420 --> 00:04:59,760
could integrate with the existing sequel

139
00:04:59,760 --> 00:05:02,400
server ecosystem this is sort of more of

140
00:05:02,400 --> 00:05:05,610
a business decision right you have you

141
00:05:05,610 --> 00:05:06,960
know millions millions of people are

142
00:05:06,960 --> 00:05:08,490
running sequel server today there's all

143
00:05:08,490 --> 00:05:10,230
those tools and all these visualization

144
00:05:10,230 --> 00:05:11,400
frameworks and things built on top of

145
00:05:11,400 --> 00:05:13,170
Siebel server that you want to keep

146
00:05:13,170 --> 00:05:15,000
around because that sort of helped you

147
00:05:15,000 --> 00:05:18,060
know help sell the product so if you

148
00:05:18,060 --> 00:05:19,350
threw it all the way from scratch and

149
00:05:19,350 --> 00:05:20,790
build hackathons as a new standalone

150
00:05:20,790 --> 00:05:22,710
system you basically have to re-implant

151
00:05:22,710 --> 00:05:25,230
all that ecosystem so for this reason

152
00:05:25,230 --> 00:05:27,510
they had to make it run aside as an

153
00:05:27,510 --> 00:05:30,180
engine in in in single server the way it

154
00:05:30,180 --> 00:05:31,560
works today is like when you call create

155
00:05:31,560 --> 00:05:33,390
table you can pass a flag at the end

156
00:05:33,390 --> 00:05:35,700
that says in memory and that then ends

157
00:05:35,700 --> 00:05:38,000
up using the the hackathon engine

158
00:05:38,000 --> 00:05:39,990
another interesting thing about their

159
00:05:39,990 --> 00:05:41,070
design decisions they're going to make

160
00:05:41,070 --> 00:05:42,960
is that part of the reason they chose

161
00:05:42,960 --> 00:05:44,760
MVCC and the approach that they're going

162
00:05:44,760 --> 00:05:47,310
to they're pursuing is that they want to

163
00:05:47,310 --> 00:05:49,380
be able to support all all to be all

164
00:05:49,380 --> 00:05:51,750
possible o2b workloads with the same

165
00:05:51,750 --> 00:05:55,290
predictable performance so we didn't

166
00:05:55,290 --> 00:05:56,760
talk about I don't think we talked about

167
00:05:56,760 --> 00:05:58,650
each door of volte be in the intro class

168
00:05:58,650 --> 00:05:59,910
but this is a system that I helped build

169
00:05:59,910 --> 00:06:02,190
when I was in grad school and the way

170
00:06:02,190 --> 00:06:03,810
this works is that you have a single

171
00:06:03,810 --> 00:06:06,000
threaded execution engine that can

172
00:06:06,000 --> 00:06:07,920
actually one transaction at a time of

173
00:06:07,920 --> 00:06:09,270
course you paralyze this across multiple

174
00:06:09,270 --> 00:06:11,940
cores but now that one transaction is

175
00:06:11,940 --> 00:06:13,890
super fast because there's no contention

176
00:06:13,890 --> 00:06:15,300
you don't require locks or latches

177
00:06:15,300 --> 00:06:16,350
because nobody else is running at the

178
00:06:16,350 --> 00:06:18,330
same time I can run almost at bare metal

179
00:06:18,330 --> 00:06:20,490
speed but the problem as soon as I touch

180
00:06:20,490 --> 00:06:22,050
multiple cores our data across multiple

181
00:06:22,050 --> 00:06:24,060
cores then at the hold locks and then

182
00:06:24,060 --> 00:06:25,560
things slow down so some of your

183
00:06:25,560 --> 00:06:27,660
transactions will be insanely fast other

184
00:06:27,660 --> 00:06:30,840
transactions will be super slow and in

185
00:06:30,840 --> 00:06:32,880
the Microsoft world that's a hard

186
00:06:32,880 --> 00:06:35,400
product to sell because basically you're

187
00:06:35,400 --> 00:06:37,470
saying hey go buy our new product give

188
00:06:37,470 --> 00:06:39,630
us a lot of money for some of your

189
00:06:39,630 --> 00:06:41,190
transactions it'll go really great

190
00:06:41,190 --> 00:06:43,050
90% your transactions one run really

191
00:06:43,050 --> 00:06:44,490
fast Kember sending your transactions

192
00:06:44,490 --> 00:06:46,650
will run really slow like you can't sell

193
00:06:46,650 --> 00:06:47,910
that but no one would buy that

194
00:06:47,910 --> 00:06:50,130
hey example I like users like you try to

195
00:06:50,130 --> 00:06:51,660
sell a car say hey this is the fastest

196
00:06:51,660 --> 00:06:52,650
car it's gonna have great fuel economy

197
00:06:52,650 --> 00:06:54,720
it's gonna be it's me you know you

198
00:06:54,720 --> 00:06:57,060
should buy this but oh by the way 10%

199
00:06:57,060 --> 00:06:58,050
are you over to get cancer when you

200
00:06:58,050 --> 00:07:00,150
drive it no one would buy that car right

201
00:07:00,150 --> 00:07:02,310
so for this reasons they they're not

202
00:07:02,310 --> 00:07:03,840
gonna get the sort of moves optimal

203
00:07:03,840 --> 00:07:05,370
performance relative to something like a

204
00:07:05,370 --> 00:07:07,320
shoe or volte be but it'll least be

205
00:07:07,320 --> 00:07:09,630
predictable and this is over at what

206
00:07:09,630 --> 00:07:13,530
mvcc's can provide us so at its core

207
00:07:13,530 --> 00:07:16,140
again it's gonna be doing its can use

208
00:07:16,140 --> 00:07:18,230
time stamps to determine the ordering of

209
00:07:18,230 --> 00:07:20,340
transactions and what virgins are

210
00:07:20,340 --> 00:07:22,740
visible to it but unlike in last class

211
00:07:22,740 --> 00:07:24,360
when we talked about times kept ordering

212
00:07:24,360 --> 00:07:27,780
and and so base MVCC transactions are

213
00:07:27,780 --> 00:07:30,330
now going to have to time stamps so when

214
00:07:30,330 --> 00:07:31,680
we talk about time same ordering again

215
00:07:31,680 --> 00:07:32,670
the transaction gets assigned a

216
00:07:32,670 --> 00:07:35,160
timestamp when it shows up and OCC you

217
00:07:35,160 --> 00:07:36,680
get a timestamp when you validate and

218
00:07:36,680 --> 00:07:39,060
and so in this world you're gonna have

219
00:07:39,060 --> 00:07:40,500
both you're gonna get assigned a

220
00:07:40,500 --> 00:07:42,810
timestamp when you start and then you'll

221
00:07:42,810 --> 00:07:44,400
get another commit timestamp when you

222
00:07:44,400 --> 00:07:46,950
have to pass validation and then we have

223
00:07:46,950 --> 00:07:48,690
to use that again you're using the

224
00:07:48,690 --> 00:07:50,490
information to figure out what is actual

225
00:07:50,490 --> 00:07:53,790
what is actually visible to us all the

226
00:07:53,790 --> 00:07:54,990
two posts are also going to contain two

227
00:07:54,990 --> 00:07:58,110
timestamps we have to begin in the end

228
00:07:58,110 --> 00:08:00,390
and so the begin timestamp is just like

229
00:08:00,390 --> 00:08:02,280
as it was before where it's gonna

230
00:08:02,280 --> 00:08:04,590
represent the begin timestamp of the

231
00:08:04,590 --> 00:08:06,690
actor transaction that created it or the

232
00:08:06,690 --> 00:08:08,550
commit times commit time stamp of the

233
00:08:08,550 --> 00:08:10,020
transaction that committed that

234
00:08:10,020 --> 00:08:13,470
committed that created it and then

235
00:08:13,470 --> 00:08:14,520
what's gonna happen as well see in the

236
00:08:14,520 --> 00:08:16,560
next slide this thing will have to go

237
00:08:16,560 --> 00:08:18,060
back and change because we'll start with

238
00:08:18,060 --> 00:08:19,770
this we create a new version we can

239
00:08:19,770 --> 00:08:21,180
populate it with our begin timestamp for

240
00:08:21,180 --> 00:08:23,070
our transaction but then when we commit

241
00:08:23,070 --> 00:08:24,780
now we have the commit timestamp and now

242
00:08:24,780 --> 00:08:26,910
we gotta go back and update all our

243
00:08:26,910 --> 00:08:29,010
versions and replace the timestamp and

244
00:08:29,010 --> 00:08:31,320
I'll show you how the everything still

245
00:08:31,320 --> 00:08:33,630
works out and we you know there's no

246
00:08:33,630 --> 00:08:35,039
phantoms and there's no issues even

247
00:08:35,039 --> 00:08:36,650
though we're changing timestamps

248
00:08:36,650 --> 00:08:39,089
the end timestamp for a tuple is little

249
00:08:39,089 --> 00:08:41,309
tricky so this is going to be begin

250
00:08:41,309 --> 00:08:43,789
timestamp of the after transaction that

251
00:08:43,789 --> 00:08:46,980
create it created the next version in

252
00:08:46,980 --> 00:08:49,710
the Virgin chain affinity meaning that

253
00:08:49,710 --> 00:08:51,750
it's the latest version and that you

254
00:08:51,750 --> 00:08:53,010
know there's nothing else comes after it

255
00:08:53,010 --> 00:08:54,960
or the commit time Stan

256
00:08:54,960 --> 00:08:56,610
of the committed transaction that

257
00:08:56,610 --> 00:08:59,730
created the next version right then that

258
00:08:59,730 --> 00:09:01,620
invalidated the current one and then it

259
00:09:01,620 --> 00:09:03,720
points to the next one so big and this

260
00:09:03,720 --> 00:09:04,830
one's a bit more confusing but I make

261
00:09:04,830 --> 00:09:06,480
more sense when we when we show an

262
00:09:06,480 --> 00:09:10,170
example okay all right so say we have a

263
00:09:10,170 --> 00:09:12,390
simple table again so Hecate on is doing

264
00:09:12,390 --> 00:09:15,120
a pen only storage oldest to newest and

265
00:09:15,120 --> 00:09:18,060
the Virgin chain and say for this one we

266
00:09:18,060 --> 00:09:20,010
have we have just you know single with

267
00:09:20,010 --> 00:09:22,520
logical tuple for two virgins a1 and a2

268
00:09:22,520 --> 00:09:25,800
so our transaction comes along all right

269
00:09:25,800 --> 00:09:27,089
and at at very beginning we have to give

270
00:09:27,089 --> 00:09:29,459
it a timestamp so it's begin timestamp

271
00:09:29,459 --> 00:09:33,120
in this example here is 25 so now we're

272
00:09:33,120 --> 00:09:35,520
going to do a read on a so we'll land

273
00:09:35,520 --> 00:09:37,260
somehow at this at the head of the

274
00:09:37,260 --> 00:09:39,870
Virgin chain at a1 here how we got there

275
00:09:39,870 --> 00:09:41,070
it doesn't matter whether it's an index

276
00:09:41,070 --> 00:09:42,870
or a sequential scan for our purposes

277
00:09:42,870 --> 00:09:45,570
here we don't care so now we're going to

278
00:09:45,570 --> 00:09:46,980
see whether this version is visible to

279
00:09:46,980 --> 00:09:48,779
us so again we have to go look at the

280
00:09:48,779 --> 00:09:50,250
begin and the end timestamp that tells

281
00:09:50,250 --> 00:09:52,620
us the visibility of our tuple in this

282
00:09:52,620 --> 00:09:55,470
case here 25 is greater than 20 so we

283
00:09:55,470 --> 00:09:57,720
know that this this thing was comes

284
00:09:57,720 --> 00:10:00,150
before us or comes before our our

285
00:10:00,150 --> 00:10:02,279
snapshot for our transaction so then now

286
00:10:02,279 --> 00:10:03,959
we followed the version change pointer

287
00:10:03,959 --> 00:10:06,180
and now we land here in this case here

288
00:10:06,180 --> 00:10:09,480
20 25 is in between 20 and affinity so

289
00:10:09,480 --> 00:10:10,709
we know that this is the version that's

290
00:10:10,709 --> 00:10:11,790
visible to us and this is what we'll

291
00:10:11,790 --> 00:10:14,430
read so that's the same as before as

292
00:10:14,430 --> 00:10:17,490
last class okay all right let's see now

293
00:10:17,490 --> 00:10:19,890
we won't do a write or name so same

294
00:10:19,890 --> 00:10:21,390
thing somehow we land at the head of the

295
00:10:21,390 --> 00:10:22,650
virgin chain we know that this is the

296
00:10:22,650 --> 00:10:24,750
this is the logical we want to update so

297
00:10:24,750 --> 00:10:26,490
we want to find where should we install

298
00:10:26,490 --> 00:10:29,580
our version so in this case here again

299
00:10:29,580 --> 00:10:32,370
25 is greater than 20 so we know we

300
00:10:32,370 --> 00:10:33,510
don't want it this is not the head of

301
00:10:33,510 --> 00:10:35,250
the bird this is not the version we want

302
00:10:35,250 --> 00:10:37,800
to pen afterwards come down here 20 to

303
00:10:37,800 --> 00:10:39,750
infinity so we know at this point here

304
00:10:39,750 --> 00:10:41,760
that this is this is the most recent

305
00:10:41,760 --> 00:10:43,740
committed version and then because this

306
00:10:43,740 --> 00:10:46,589
is infinity and our pointer is null we

307
00:10:46,589 --> 00:10:47,850
know that nobody else is trying to

308
00:10:47,850 --> 00:10:49,279
create a new version after us right now

309
00:10:49,279 --> 00:10:53,100
all right so now we need to install our

310
00:10:53,100 --> 00:10:55,680
new version so for this one we need

311
00:10:55,680 --> 00:10:56,850
careful how we're gonna do ordering

312
00:10:56,850 --> 00:10:58,740
because unlike last class where we had

313
00:10:58,740 --> 00:11:00,630
this sort of take a lock on the whole

314
00:11:00,630 --> 00:11:04,170
tuple and and then do our updates for

315
00:11:04,170 --> 00:11:06,120
this one we want to do everything as

316
00:11:06,120 --> 00:11:07,740
compare and swap so we want to avoid

317
00:11:07,740 --> 00:11:08,579
having to lock this

318
00:11:08,579 --> 00:11:10,889
thing what will they make a change so

319
00:11:10,889 --> 00:11:12,389
the first thing we need to do is append

320
00:11:12,389 --> 00:11:14,819
our new version right it's a pen only

321
00:11:14,819 --> 00:11:16,980
storage we just find a free slot in our

322
00:11:16,980 --> 00:11:19,920
table space and then we claim it and

323
00:11:19,920 --> 00:11:21,829
then we can now install our new version

324
00:11:21,829 --> 00:11:24,239
but now you'll see with that for our

325
00:11:24,239 --> 00:11:25,860
begin timestamp we're doing something

326
00:11:25,860 --> 00:11:28,439
special here so I'm having this little

327
00:11:28,439 --> 00:11:31,470
marker here say transaction at 25 so

328
00:11:31,470 --> 00:11:34,319
what does that mean so the hackathon is

329
00:11:34,319 --> 00:11:37,499
going instead of having a instead of

330
00:11:37,499 --> 00:11:40,319
having us sort of special transaction ID

331
00:11:40,319 --> 00:11:42,179
to say this is this represents the

332
00:11:42,179 --> 00:11:43,799
timestamp of an uncommitted transaction

333
00:11:43,799 --> 00:11:45,720
they're just going to use the begin

334
00:11:45,720 --> 00:11:49,559
timestamp to record that the that this

335
00:11:49,559 --> 00:11:51,360
is the version that was created by this

336
00:11:51,360 --> 00:11:53,399
transaction for both committed and

337
00:11:53,399 --> 00:11:55,439
uncommitted and so what they're going to

338
00:11:55,439 --> 00:11:56,879
do is they're gonna use the most

339
00:11:56,879 --> 00:12:00,179
significant bit and set that to 1 to

340
00:12:00,179 --> 00:12:02,189
mean that the transaction at this time

341
00:12:02,189 --> 00:12:04,980
stamp is uncommitted so I'm representing

342
00:12:04,980 --> 00:12:07,230
that by having the prefix transaction in

343
00:12:07,230 --> 00:12:08,220
front of it right this is just for

344
00:12:08,220 --> 00:12:09,959
illustration purposes but underneath the

345
00:12:09,959 --> 00:12:11,429
cover is what they're really doing it's

346
00:12:11,429 --> 00:12:14,429
just flipping this one bit let me take I

347
00:12:14,429 --> 00:12:17,419
guess why you want to do this

348
00:12:30,130 --> 00:12:32,259
ah so she's saying because this thinks

349
00:12:32,259 --> 00:12:33,519
that the one we know that nobody else

350
00:12:33,519 --> 00:12:35,050
can ever have every time to him that

351
00:12:35,050 --> 00:12:37,300
bigger than us no all right so when we

352
00:12:37,300 --> 00:12:38,199
do the comparison were actually gonna

353
00:12:38,199 --> 00:12:44,290
ignore that one yes help me avoid a

354
00:12:44,290 --> 00:12:47,680
cascading abort no Pakistan's gonna

355
00:12:47,680 --> 00:12:49,060
support spectra to read so we still have

356
00:12:49,060 --> 00:12:59,860
cascading boards so he says this you

357
00:12:59,860 --> 00:13:00,790
could use this to prevent you from

358
00:13:00,790 --> 00:13:01,990
reading something that's not committed

359
00:13:01,990 --> 00:13:07,300
yet by by checking this and they say I

360
00:13:07,300 --> 00:13:09,699
don't want to read this so again their

361
00:13:09,699 --> 00:13:11,740
respective the reads so you want to be

362
00:13:11,740 --> 00:13:12,940
able to read things that are uncommitted

363
00:13:12,940 --> 00:13:13,990
because you're going to assume they

364
00:13:13,990 --> 00:13:15,310
transaction that you read from that

365
00:13:15,310 --> 00:13:17,500
modified this thing is not gonna abort

366
00:13:17,500 --> 00:13:19,060
so you what you want to go ahead and

367
00:13:19,060 --> 00:13:24,160
allow us she says you can read your

368
00:13:24,160 --> 00:13:25,449
other things you updated yeah but I

369
00:13:25,449 --> 00:13:26,850
don't need the bit to figure that out

370
00:13:26,850 --> 00:13:29,170
these are all she good this is actually

371
00:13:29,170 --> 00:13:38,860
very interesting yes go so you're saying

372
00:13:38,860 --> 00:13:40,689
if you if you read this and you see the

373
00:13:40,689 --> 00:13:41,860
one then you know that you read

374
00:13:41,860 --> 00:13:55,089
something that was uncommitted Yama Sara

375
00:13:55,089 --> 00:13:55,509
yes

376
00:13:55,509 --> 00:14:04,600
that's very close yes he says they go

377
00:14:04,600 --> 00:14:06,040
through the constructor and recognize

378
00:14:06,040 --> 00:14:07,630
the other thing this thing is unused and

379
00:14:07,630 --> 00:14:09,610
go ahead and clean it up but not unused

380
00:14:09,610 --> 00:14:14,350
we put something in there he's not

381
00:14:14,350 --> 00:14:17,279
committed yes

382
00:14:19,200 --> 00:14:21,420
yeah but why well what is the one

383
00:14:21,420 --> 00:14:23,850
actually do for us you guys are very

384
00:14:23,850 --> 00:14:28,200
close he says make a light screen now no

385
00:14:28,200 --> 00:14:31,560
she said recovery now all right so well

386
00:14:31,560 --> 00:14:33,240
this is Oliver this is good because this

387
00:14:33,240 --> 00:14:34,620
is like I've eaten paper

388
00:14:34,620 --> 00:14:35,850
oh of course yeah do it this way and

389
00:14:35,850 --> 00:14:38,670
then you guys are coming it from not

390
00:14:38,670 --> 00:14:39,870
having all this prior knowledge so it's

391
00:14:39,870 --> 00:14:40,920
interesting to see you like what you

392
00:14:40,920 --> 00:14:41,940
guys think actually matter

393
00:14:41,940 --> 00:14:44,040
so what we're actually gonna do with

394
00:14:44,040 --> 00:14:47,160
this is that we need at some point we

395
00:14:47,160 --> 00:14:49,350
need to figure out because he was very

396
00:14:49,350 --> 00:14:50,850
close this somewhat we need to figure

397
00:14:50,850 --> 00:14:52,560
out did we read something that was not

398
00:14:52,560 --> 00:14:55,200
committed and if yes we need to know

399
00:14:55,200 --> 00:14:57,810
what happened to that transaction so by

400
00:14:57,810 --> 00:15:00,540
setting this bit 1 Wow while our

401
00:15:00,540 --> 00:15:01,860
transaction another transaction is

402
00:15:01,860 --> 00:15:03,390
reading this it'll say oh I see this

403
00:15:03,390 --> 00:15:05,370
bits at the 1 that means that this thing

404
00:15:05,370 --> 00:15:07,470
is potentially uncommitted it actually

405
00:15:07,470 --> 00:15:09,120
may be committed we just don't know it

406
00:15:09,120 --> 00:15:10,320
yet because they haven't come an updated

407
00:15:10,320 --> 00:15:13,650
this this this this this timestamp to

408
00:15:13,650 --> 00:15:16,260
you know to remove the 1 so we'll see in

409
00:15:16,260 --> 00:15:17,490
a few more slides but there's actually

410
00:15:17,490 --> 00:15:19,620
gonna be this global state map that

411
00:15:19,620 --> 00:15:21,540
keeps track of the the current state of

412
00:15:21,540 --> 00:15:22,980
every single transaction that's running

413
00:15:22,980 --> 00:15:24,930
in the system so if I'm looking out for

414
00:15:24,930 --> 00:15:26,640
specular reads I need a way to figure

415
00:15:26,640 --> 00:15:28,860
out later on did the thing I read

416
00:15:28,860 --> 00:15:31,770
actually get committed or not and so by

417
00:15:31,770 --> 00:15:33,600
setting this to 1 I don't have to go

418
00:15:33,600 --> 00:15:35,220
check to see whether a might actually

419
00:15:35,220 --> 00:15:36,720
allowed to read this I make a make a

420
00:15:36,720 --> 00:15:39,150
little mark in my local metadata like in

421
00:15:39,150 --> 00:15:41,100
my thread that says by the way I read

422
00:15:41,100 --> 00:15:42,720
this a 3 figure out what happened to it

423
00:15:42,720 --> 00:15:44,040
later on because it may and may have not

424
00:15:44,040 --> 00:15:50,160
committed yes so he says what happens if

425
00:15:50,160 --> 00:15:52,350
I go on check when my transaction

426
00:15:52,350 --> 00:15:54,720
commits that they go ahead and read this

427
00:15:54,720 --> 00:15:56,490
what if it's still uncommitted I have to

428
00:15:56,490 --> 00:16:00,770
wait let's do that a few more slides yes

429
00:16:01,620 --> 00:16:03,610
we're not there yet yes he's the

430
00:16:03,610 --> 00:16:05,290
question is to update the original yes

431
00:16:05,290 --> 00:16:13,960
right so did yes yeah yes so at this

432
00:16:13,960 --> 00:16:16,260
point here no one can see this right

433
00:16:16,260 --> 00:16:18,520
because all I've done is I just the

434
00:16:18,520 --> 00:16:21,250
first transaction installed this right

435
00:16:21,250 --> 00:16:23,290
instead of taking a lock on e to I just

436
00:16:23,290 --> 00:16:24,310
said let me go ahead and create this

437
00:16:24,310 --> 00:16:26,860
then now I'll do the compare and swap

438
00:16:26,860 --> 00:16:29,830
here and if that succeeds then I know

439
00:16:29,830 --> 00:16:31,570
that I was successfully able to install

440
00:16:31,570 --> 00:16:33,760
this new version but at this point here

441
00:16:33,760 --> 00:16:35,410
can anybody see this can everybody see

442
00:16:35,410 --> 00:16:37,960
my new version yet why not

443
00:16:37,960 --> 00:16:41,050
I mean fini right so now I need to go

444
00:16:41,050 --> 00:16:43,420
back here and flip that to be my my

445
00:16:43,420 --> 00:16:45,520
timestamp and now my version is

446
00:16:45,520 --> 00:16:47,410
installed it's still uncommitted my bit

447
00:16:47,410 --> 00:16:49,540
is still set to true or so the bits set

448
00:16:49,540 --> 00:16:51,160
the one to denote that this is

449
00:16:51,160 --> 00:16:52,060
potentially from an uncommitted

450
00:16:52,060 --> 00:16:53,980
transaction but at this point here

451
00:16:53,980 --> 00:16:55,840
anybody that comes along that wants to

452
00:16:55,840 --> 00:16:58,630
read data after timestamp 25 should be

453
00:16:58,630 --> 00:17:00,100
able to will be able to see my my new

454
00:17:00,100 --> 00:17:08,740
version yes your question is why keep

455
00:17:08,740 --> 00:17:10,329
track of the begin timestamp and

456
00:17:10,329 --> 00:17:12,160
timestamp here yes like I can track up

457
00:17:12,160 --> 00:17:13,240
like the end timestamp and let's say

458
00:17:13,240 --> 00:17:16,380
like a 1 when you begin timestamp in a 2

459
00:17:16,380 --> 00:17:19,510
right so his question is why do I need

460
00:17:19,510 --> 00:17:21,369
to keep track of this end timestamp here

461
00:17:21,369 --> 00:17:22,839
couldn't I just follow the Virgin chain

462
00:17:22,839 --> 00:17:25,420
and say oh well I know that the the

463
00:17:25,420 --> 00:17:28,270
visibility of this tuple is 20 to 25 cuz

464
00:17:28,270 --> 00:17:30,100
I have it here but now when I do garbage

465
00:17:30,100 --> 00:17:31,330
collection I always got to keep the last

466
00:17:31,330 --> 00:17:35,140
one around Yeah right so if my two boys

467
00:17:35,140 --> 00:17:37,630
super big like super what has a lot of

468
00:17:37,630 --> 00:17:41,250
columns and I'm I'm not actually say

469
00:17:46,830 --> 00:17:49,660
misses point is if you know right so

470
00:17:49,660 --> 00:17:51,070
he's saying if you know this pointer is

471
00:17:51,070 --> 00:17:53,530
null then that should not just be read

472
00:17:53,530 --> 00:18:00,510
as this is infinity yeah maybe

473
00:18:21,100 --> 00:18:23,870
so you're saying so you said that if

474
00:18:23,870 --> 00:18:26,170
there's transaction at time-stamped 24

475
00:18:26,170 --> 00:18:28,790
they should read this what he's saying

476
00:18:28,790 --> 00:18:32,150
that you could infer I think it you want

477
00:18:32,150 --> 00:18:33,380
to reduce in my pointer chasing I think

478
00:18:33,380 --> 00:18:35,300
it's compute versus storage costs so if

479
00:18:35,300 --> 00:18:37,040
I'm scanning along I'm oldest to newest

480
00:18:37,040 --> 00:18:39,080
I see this I don't know the end

481
00:18:39,080 --> 00:18:41,600
timestamp my pointer is not null

482
00:18:41,600 --> 00:18:43,730
I got again follow the pointer now to go

483
00:18:43,730 --> 00:18:45,290
figure out well what is there what

484
00:18:45,290 --> 00:18:47,600
should this actually be and anything

485
00:18:47,600 --> 00:18:48,800
that that's a waste of waste of time

486
00:18:48,800 --> 00:18:52,090
it's not worth it so for safety for bits

487
00:18:52,090 --> 00:18:54,470
it's you avoid that extra extra

488
00:18:54,470 --> 00:19:16,090
computation so his point is back here

489
00:19:16,090 --> 00:19:18,680
this thing set at the one so therefore

490
00:19:18,680 --> 00:19:20,060
the number super high when you do the

491
00:19:20,060 --> 00:19:21,590
comparison you own looking 63 the bits

492
00:19:21,590 --> 00:19:35,980
you ignored us why not change what's

493
00:19:41,710 --> 00:19:46,190
that it still stays like this is our

494
00:19:46,190 --> 00:19:48,890
begin timestamp we only flip that one to

495
00:19:48,890 --> 00:19:51,410
a zero when we get a commute time stamp

496
00:19:51,410 --> 00:19:55,010
which is I'll show next okay okay this

497
00:19:55,010 --> 00:19:56,630
is just mean that'll tell us hey where

498
00:19:56,630 --> 00:19:57,710
we have something that's not committed

499
00:19:57,710 --> 00:20:00,050
you need to figure out later on whether

500
00:20:00,050 --> 00:20:01,990
it actually was committed at all

501
00:20:01,990 --> 00:20:05,570
all right so now our guy commits again

502
00:20:05,570 --> 00:20:07,070
so we're gonna do it's never CC so we're

503
00:20:07,070 --> 00:20:08,810
doing we're doing validation so we need

504
00:20:08,810 --> 00:20:11,030
to go you know go check see we're

505
00:20:11,030 --> 00:20:12,410
allowed to commit in this case here yes

506
00:20:12,410 --> 00:20:14,030
we are so we get our commit time stay

507
00:20:14,030 --> 00:20:15,470
about 35 and so

508
00:20:15,470 --> 00:20:17,659
all we need to do now is just go back at

509
00:20:17,659 --> 00:20:20,720
some later point and flip this to be now

510
00:20:20,720 --> 00:20:22,789
thirty five doesn't need to happen

511
00:20:22,789 --> 00:20:25,460
immediately because again this is saying

512
00:20:25,460 --> 00:20:27,409
that if anybody reads this go figure out

513
00:20:27,409 --> 00:20:29,059
let you know later on in my my global

514
00:20:29,059 --> 00:20:30,320
map whether I actually committed or not

515
00:20:30,320 --> 00:20:32,809
but now if I install thirty five the bit

516
00:20:32,809 --> 00:20:34,490
is set to zero so I know that I'm

517
00:20:34,490 --> 00:20:35,900
reading something that I definitely

518
00:20:35,900 --> 00:20:37,580
definitely was committed and I don't

519
00:20:37,580 --> 00:20:49,460
need to check that map yes boom okay so

520
00:20:49,460 --> 00:20:51,500
let's this question is exactly that's

521
00:20:51,500 --> 00:20:53,900
right so let's rewind now let's go

522
00:20:53,900 --> 00:20:55,610
remove the commit we're back of this D

523
00:20:55,610 --> 00:20:57,500
here let's now bring another transaction

524
00:20:57,500 --> 00:20:58,520
okay

525
00:20:58,520 --> 00:21:01,190
this one is your question so our

526
00:21:01,190 --> 00:21:03,020
transaction begins at timestamp 30 and

527
00:21:03,020 --> 00:21:05,780
it was do a read on a so again follow

528
00:21:05,780 --> 00:21:08,059
the Virgin chain 30 is greater than 20

529
00:21:08,059 --> 00:21:10,809
we don't want this 30 is is greater than

530
00:21:10,809 --> 00:21:14,120
25 we don't want this so then we land

531
00:21:14,120 --> 00:21:15,260
here and this is the version that we

532
00:21:15,260 --> 00:21:17,210
actually want to read again we're doing

533
00:21:17,210 --> 00:21:19,429
specular reads in Hecate on instead of

534
00:21:19,429 --> 00:21:20,900
taking a write latch or right lock on

535
00:21:20,900 --> 00:21:22,250
this tuple I'm allowed to read something

536
00:21:22,250 --> 00:21:24,200
that's uncommitted oscillate later on

537
00:21:24,200 --> 00:21:25,850
make sure I was you know the transaction

538
00:21:25,850 --> 00:21:26,840
that created this version that I've read

539
00:21:26,840 --> 00:21:28,640
whether it actually committed or not but

540
00:21:28,640 --> 00:21:31,220
I'm allowed to do this but now this guy

541
00:21:31,220 --> 00:21:33,260
wants to a right or neck so in this case

542
00:21:33,260 --> 00:21:33,770
here

543
00:21:33,770 --> 00:21:36,950
my timestamp is 30 that's after 25 but

544
00:21:36,950 --> 00:21:38,720
this again first writer wins so this guy

545
00:21:38,720 --> 00:21:40,429
is going to get come down here and

546
00:21:40,429 --> 00:21:44,270
recognize that the the there's another

547
00:21:44,270 --> 00:21:46,280
transaction that's uncommitted here that

548
00:21:46,280 --> 00:21:49,039
created a new version that that I cannot

549
00:21:49,039 --> 00:21:50,390
create a new version after this and

550
00:21:50,390 --> 00:21:52,450
therefore I have to abort my transaction

551
00:21:52,450 --> 00:21:55,130
so again by seeing this thing here I

552
00:21:55,130 --> 00:21:57,740
know it's uncommitted actual in this

553
00:21:57,740 --> 00:21:59,600
case here you you would want to go check

554
00:21:59,600 --> 00:22:01,909
but I think yeah if you go check you

555
00:22:01,909 --> 00:22:03,230
could go see oh it is actually committed

556
00:22:03,230 --> 00:22:04,480
therefore I can't install the version

557
00:22:04,480 --> 00:22:07,309
for this example here 2025 is not

558
00:22:07,309 --> 00:22:09,260
committed yet so this thing would is a

559
00:22:09,260 --> 00:22:10,610
write write conflict so we go ahead and

560
00:22:10,610 --> 00:22:15,260
the board is your question okay yes

561
00:22:15,260 --> 00:22:18,349
[Music]

562
00:22:19,840 --> 00:22:24,130
sorry so what thread cannot read

563
00:22:24,799 --> 00:22:26,659
their threat to is dead at this point

564
00:22:26,659 --> 00:22:30,159
here when he tries to try to write on a

565
00:22:30,159 --> 00:22:36,789
so you pretend you're back here okay yes

566
00:22:37,720 --> 00:22:46,460
yes so this okay to commit time stamp

567
00:22:46,460 --> 00:22:50,690
after ste ste gets 35 again then when

568
00:22:50,690 --> 00:23:04,399
this guy does right just to read this

569
00:23:04,399 --> 00:23:11,419
guy so this guy commits guess this guy

570
00:23:11,419 --> 00:23:19,970
then reads yes question is in my less at

571
00:23:19,970 --> 00:23:21,169
the Apple here this guy got a commit

572
00:23:21,169 --> 00:23:23,630
time set by 35 but if now if I come back

573
00:23:23,630 --> 00:23:27,200
and do this read but I have timestamp 30

574
00:23:27,200 --> 00:23:31,130
what I see no because under snapshot

575
00:23:31,130 --> 00:23:35,080
isolation I should only see things that

576
00:23:35,860 --> 00:23:42,399
before I started in this case here

577
00:23:53,080 --> 00:24:15,320
that's okay yes questions how do I make

578
00:24:15,320 --> 00:24:17,720
sure if I need to go flip these so what

579
00:24:17,720 --> 00:24:20,120
happen is if I go to a look up and I see

580
00:24:20,120 --> 00:24:22,610
this things committed right the one says

581
00:24:22,610 --> 00:24:24,289
I go figure out what what is actually

582
00:24:24,289 --> 00:24:26,210
going on so if it's set them one I go

583
00:24:26,210 --> 00:24:27,409
look my map and I would say oh it's

584
00:24:27,409 --> 00:24:29,149
committed the real commit timestamp is

585
00:24:29,149 --> 00:24:30,889
35 so I guess I was tough to do that in

586
00:24:30,889 --> 00:24:33,440
my local view of this and then when you

587
00:24:33,440 --> 00:24:35,240
do the update you go from all you go

588
00:24:35,240 --> 00:24:36,950
from the newest to oldest because people

589
00:24:36,950 --> 00:24:38,249
are going in the other direction

590
00:24:38,249 --> 00:24:41,090
so you wouldn't have that that issue

591
00:24:41,090 --> 00:24:42,799
okay

592
00:24:42,799 --> 00:24:45,509
so let's jump now and talk about how

593
00:24:45,509 --> 00:24:47,159
we're actually gonna the state map here

594
00:24:47,159 --> 00:24:48,720
again so this is a global hash map

595
00:24:48,720 --> 00:24:51,389
they're going to maintain throughout the

596
00:24:51,389 --> 00:24:53,279
entire database system that just keeps

597
00:24:53,279 --> 00:24:54,239
track of what's the state of every

598
00:24:54,239 --> 00:24:56,940
single transaction running so active

599
00:24:56,940 --> 00:24:58,080
transactions are just one transaction

600
00:24:58,080 --> 00:24:59,820
shows up it's done a bunch of reads and

601
00:24:59,820 --> 00:25:01,679
writes it has begin timestamp you can

602
00:25:01,679 --> 00:25:03,149
still do more reads and writes we just

603
00:25:03,149 --> 00:25:04,580
don't know the outcome just yet

604
00:25:04,580 --> 00:25:06,450
validating is when the application says

605
00:25:06,450 --> 00:25:08,220
I want to commit my transaction and now

606
00:25:08,220 --> 00:25:09,450
we begin the process of figuring out

607
00:25:09,450 --> 00:25:10,859
whether it is actually a lot of commit

608
00:25:10,859 --> 00:25:12,659
right like we have to go check the

609
00:25:12,659 --> 00:25:14,220
rewrite sets and see whether there's any

610
00:25:14,220 --> 00:25:16,739
conflicts committed transaction is that

611
00:25:16,739 --> 00:25:20,749
we pass the validating phase we have a

612
00:25:20,749 --> 00:25:24,299
community who goes reads our data has

613
00:25:24,299 --> 00:25:25,679
well know that it's actually been

614
00:25:25,679 --> 00:25:27,389
committed but we just haven't gone back

615
00:25:27,389 --> 00:25:29,609
yet and flipped those begin time stamps

616
00:25:29,609 --> 00:25:31,590
and end time stamps to being our what

617
00:25:31,590 --> 00:25:33,809
our commit time stamp is and then

618
00:25:33,809 --> 00:25:35,309
terminated is when we updated all the

619
00:25:35,309 --> 00:25:36,749
time stamps for our versions that we

620
00:25:36,749 --> 00:25:38,879
created and then at some point what

621
00:25:38,879 --> 00:25:40,590
we'll get will get pruned away will get

622
00:25:40,590 --> 00:25:43,460
thrown away out of the out of the map so

623
00:25:43,460 --> 00:25:46,289
let's go through now the lifetime more

624
00:25:46,289 --> 00:25:48,720
details so it began transaction gets the

625
00:25:48,720 --> 00:25:50,609
begin timestamp we said it said it in

626
00:25:50,609 --> 00:25:52,559
the map to be active then we do our

627
00:25:52,559 --> 00:25:54,539
normal processing again under OCC they

628
00:25:54,539 --> 00:25:56,309
would call this the read phase for doing

629
00:25:56,309 --> 00:25:58,950
reads and writes on on the datum but as

630
00:25:58,950 --> 00:26:00,929
we run maratha me keep track of the read

631
00:26:00,929 --> 00:26:02,940
set the scan set and the right set of a

632
00:26:02,940 --> 00:26:04,950
transaction so for the read set in the

633
00:26:04,950 --> 00:26:06,480
right set these are just going to

634
00:26:06,480 --> 00:26:09,119
physical pointers to the versions that

635
00:26:09,119 --> 00:26:11,460
we read and wrote right but they're

636
00:26:11,460 --> 00:26:13,080
actually gonna be like in case a read

637
00:26:13,080 --> 00:26:15,690
set it's going to be the version that's

638
00:26:15,690 --> 00:26:19,109
produced to the access method of the

639
00:26:19,109 --> 00:26:21,119
transaction I'm sorry of the query

640
00:26:21,119 --> 00:26:22,980
executors I'll explain that in the next

641
00:26:22,980 --> 00:26:25,710
slide and the scan set will be the

642
00:26:25,710 --> 00:26:28,139
actual where clause that we use to do a

643
00:26:28,139 --> 00:26:30,989
scan on on a table because we need that

644
00:26:30,989 --> 00:26:32,789
for to do phantom checks for

645
00:26:32,789 --> 00:26:35,220
serializability then we hit pre-commit

646
00:26:35,220 --> 00:26:36,570
this is when the application tells us we

647
00:26:36,570 --> 00:26:38,159
want to commit we now get our commit

648
00:26:38,159 --> 00:26:40,919
commit time stamp we do a validation to

649
00:26:40,919 --> 00:26:42,269
figure out whether we're actually there

650
00:26:42,269 --> 00:26:44,820
any conflicts and then right and then

651
00:26:44,820 --> 00:26:46,169
validation again we just check

652
00:26:46,169 --> 00:26:48,869
everything to see whether whether we're

653
00:26:48,869 --> 00:26:51,359
not violating serializable order but why

654
00:26:51,359 --> 00:26:52,140
don't you think is here

655
00:26:52,140 --> 00:26:53,280
this is when they're gonna write now the

656
00:26:53,280 --> 00:26:56,220
new versions to the redhead log out on

657
00:26:56,220 --> 00:26:58,230
disk so this is different than a

658
00:26:58,230 --> 00:26:59,820
Discordian system in a Discordian system

659
00:26:59,820 --> 00:27:01,020
remember you're just appending to the

660
00:27:01,020 --> 00:27:02,790
right head log buffer and some point the

661
00:27:02,790 --> 00:27:04,740
buffer gets full or there's a timeout

662
00:27:04,740 --> 00:27:06,240
when you do in crew commit and then all

663
00:27:06,240 --> 00:27:07,830
your log records get flushed to disk

664
00:27:07,830 --> 00:27:09,330
even though that transaction may have

665
00:27:09,330 --> 00:27:11,730
not committed yet in the case of Hecate

666
00:27:11,730 --> 00:27:13,740
on they're gonna buffer all the log

667
00:27:13,740 --> 00:27:15,840
rights in memory and only flush them out

668
00:27:15,840 --> 00:27:17,760
when the transaction actually is

669
00:27:17,760 --> 00:27:19,470
committed so that means that there's a

670
00:27:19,470 --> 00:27:21,300
crash you come back you're not gonna see

671
00:27:21,300 --> 00:27:22,920
any log records from transactions that

672
00:27:22,920 --> 00:27:24,870
did come and they did not commit you'll

673
00:27:24,870 --> 00:27:25,920
see everything you'll see all the

674
00:27:25,920 --> 00:27:29,160
overall records also you see all of our

675
00:27:29,160 --> 00:27:30,120
guests were all in only committed

676
00:27:30,120 --> 00:27:32,550
transactions then we do the commit we

677
00:27:32,550 --> 00:27:33,720
set our transaction state to committed

678
00:27:33,720 --> 00:27:36,030
we go through now and update our version

679
00:27:36,030 --> 00:27:38,280
time stamps to flip the begin time

680
00:27:38,280 --> 00:27:40,380
stamps and end time stands to now be the

681
00:27:40,380 --> 00:27:42,840
transactions commit time stamp then at

682
00:27:42,840 --> 00:27:44,280
point we're done we set us off the

683
00:27:44,280 --> 00:27:45,570
terminated and we'll get cleaned up

684
00:27:45,570 --> 00:27:49,200
later on all right so let's talk about

685
00:27:49,200 --> 00:27:51,660
this this is metadata for tracking here

686
00:27:51,660 --> 00:27:52,890
because this is important to understand

687
00:27:52,890 --> 00:27:54,210
how we actually maintain sterilized

688
00:27:54,210 --> 00:27:56,550
ability so for the read set and the

689
00:27:56,550 --> 00:27:57,900
right set these again these are me the

690
00:27:57,900 --> 00:27:59,760
physical vert pointed to the physical

691
00:27:59,760 --> 00:28:03,210
virgins in memory that I access or

692
00:28:03,210 --> 00:28:05,430
created and for the access one it's

693
00:28:05,430 --> 00:28:06,720
going to physical versions that I've

694
00:28:06,720 --> 00:28:09,240
produced back to the access method that

695
00:28:09,240 --> 00:28:12,300
that that I used to execute the query so

696
00:28:12,300 --> 00:28:14,850
the thing of this is like say I have a

697
00:28:14,850 --> 00:28:17,160
virgin chain and I have you know three

698
00:28:17,160 --> 00:28:19,110
versions in it the access method does

699
00:28:19,110 --> 00:28:20,760
the scan once the wants to get back a

700
00:28:20,760 --> 00:28:22,320
tuple it's only going to get back one

701
00:28:22,320 --> 00:28:24,750
version so my reset doesn't contain the

702
00:28:24,750 --> 00:28:26,220
first two versions I looked at that

703
00:28:26,220 --> 00:28:27,540
weren't visible to me I don't care about

704
00:28:27,540 --> 00:28:29,670
those it's the one I then returned back

705
00:28:29,670 --> 00:28:32,970
to the query executors now up in my

706
00:28:32,970 --> 00:28:35,130
query plan that one version may get

707
00:28:35,130 --> 00:28:36,360
pruned out like if it gets fed into a

708
00:28:36,360 --> 00:28:38,040
joint operator and the join operator

709
00:28:38,040 --> 00:28:39,330
says I don't need this to bone it throws

710
00:28:39,330 --> 00:28:41,340
it away I still need to know about it

711
00:28:41,340 --> 00:28:43,110
right I even though it's not produced

712
00:28:43,110 --> 00:28:44,580
the final result of the tube or the

713
00:28:44,580 --> 00:28:46,770
query because I gave it to my access

714
00:28:46,770 --> 00:28:49,370
method I have I have to return it and

715
00:28:49,370 --> 00:28:53,550
then the scan set is gonna be the thing

716
00:28:53,550 --> 00:28:55,170
this is like it's the bare minimum the

717
00:28:55,170 --> 00:28:57,360
information we need in order to re

718
00:28:57,360 --> 00:29:00,090
execute a scan operation so things like

719
00:29:00,090 --> 00:29:01,920
it's just the where clause of of a query

720
00:29:01,920 --> 00:29:04,620
and what's going to happen is in our

721
00:29:04,620 --> 00:29:05,770
validation we're going to

722
00:29:05,770 --> 00:29:07,810
basically just re-execute the scan all

723
00:29:07,810 --> 00:29:10,120
over again and see whether we get back

724
00:29:10,120 --> 00:29:12,460
the same result because if we don't get

725
00:29:12,460 --> 00:29:13,750
the same result then we know there was a

726
00:29:13,750 --> 00:29:15,130
phantom somebody inserted or deleted

727
00:29:15,130 --> 00:29:17,560
something since since you know since we

728
00:29:17,560 --> 00:29:19,600
started and therefore we have the you

729
00:29:19,600 --> 00:29:21,040
know giving back a different result and

730
00:29:21,040 --> 00:29:22,270
therefore we have the border transaction

731
00:29:22,270 --> 00:29:24,010
because that would violate serializable

732
00:29:24,010 --> 00:29:25,270
orders now if we're running at a lower

733
00:29:25,270 --> 00:29:26,770
isolation level we don't care about this

734
00:29:26,770 --> 00:29:31,180
but first utilizability we do yes where

735
00:29:31,180 --> 00:29:35,200
when and doing the validation pays right

736
00:29:35,200 --> 00:29:38,710
so I'm checking the check my read set to

737
00:29:38,710 --> 00:29:42,360
see whether I've access anything that is

738
00:29:42,360 --> 00:29:44,560
from uncommitted transaction and you

739
00:29:44,560 --> 00:29:46,420
know whether they commit or not and then

740
00:29:46,420 --> 00:29:48,220
I run my scans again to figure out if

741
00:29:48,220 --> 00:29:49,930
I'd run this a second time do I get the

742
00:29:49,930 --> 00:29:51,400
same result if I don't then I know

743
00:29:51,400 --> 00:29:55,900
there's a fan and I abort so you may

744
00:29:55,900 --> 00:29:57,160
think this is kind of heavy-handed right

745
00:29:57,160 --> 00:29:59,140
like if my scan reads a billion to polls

746
00:29:59,140 --> 00:30:01,360
when I when I do validation I'm gonna

747
00:30:01,360 --> 00:30:07,390
read a billion tuples again yes so this

748
00:30:07,390 --> 00:30:10,390
is this is just the metadata this is the

749
00:30:10,390 --> 00:30:11,680
metadata at the track in order to do

750
00:30:11,680 --> 00:30:14,800
this so board would happen here or

751
00:30:14,800 --> 00:30:16,120
actually here if I have a write write

752
00:30:16,120 --> 00:30:16,510
conflict

753
00:30:16,510 --> 00:30:18,310
I gotta bore myself right away if under

754
00:30:18,310 --> 00:30:20,170
validation like if I scan again I get a

755
00:30:20,170 --> 00:30:26,050
different result then I kill myself well

756
00:30:26,050 --> 00:30:28,780
you sort of skip down and and well yeah

757
00:30:28,780 --> 00:30:30,070
you just kept down and terminate and say

758
00:30:30,070 --> 00:30:31,780
I'm not I'm I'm not gonna commit and

759
00:30:31,780 --> 00:30:33,130
then the garbage cracker will come

760
00:30:33,130 --> 00:30:34,150
through and clean up any versions

761
00:30:34,150 --> 00:30:39,400
shouldn't shouldn't be okay to that yeah

762
00:30:39,400 --> 00:30:42,660
probably no question or not

763
00:30:46,200 --> 00:30:50,679
is the queer call sponsor yeah so the

764
00:30:50,679 --> 00:30:52,120
where clause contains predicates a

765
00:30:52,120 --> 00:30:54,100
predicate would be like a equals one and

766
00:30:54,100 --> 00:30:56,440
B equals to each of those eight one

767
00:30:56,440 --> 00:30:59,700
that's I call that a predicate it's just

768
00:30:59,700 --> 00:31:05,049
the set of predicates okay all right and

769
00:31:05,049 --> 00:31:06,340
then commit to and see what he was

770
00:31:06,340 --> 00:31:08,679
asking here is like this is basically a

771
00:31:08,679 --> 00:31:10,900
list of all the transactions are waiting

772
00:31:10,900 --> 00:31:12,490
for my transaction to commit because

773
00:31:12,490 --> 00:31:13,870
they read something that I wrote before

774
00:31:13,870 --> 00:31:15,940
I committed so think of this is like a

775
00:31:15,940 --> 00:31:18,850
pub/sub system like transaction reads my

776
00:31:18,850 --> 00:31:21,190
uncommitted data they then subscribe to

777
00:31:21,190 --> 00:31:23,919
my you know commit notification whether

778
00:31:23,919 --> 00:31:26,020
I'm gonna finish or not and then if I

779
00:31:26,020 --> 00:31:27,820
commit and I and I read something that

780
00:31:27,820 --> 00:31:29,080
you wrote and you have committed yet but

781
00:31:29,080 --> 00:31:30,400
I need to wait to see whether you commit

782
00:31:30,400 --> 00:31:37,270
for I can commit yes yes the question is

783
00:31:37,270 --> 00:31:38,350
would I use the commit timestamp to

784
00:31:38,350 --> 00:31:40,299
react so you can yes you have to because

785
00:31:40,299 --> 00:31:41,590
that's like that's when I'm installing

786
00:31:41,590 --> 00:31:56,919
everything all right can you have a

787
00:31:56,919 --> 00:31:58,030
circle in dependency in the commit

788
00:31:58,030 --> 00:32:04,720
commit commit timestamps no because

789
00:32:04,720 --> 00:32:06,040
because when you whenever in the first

790
00:32:06,040 --> 00:32:08,830
time I can read a bunch of stuff

791
00:32:08,830 --> 00:32:11,320
I mean I'm before you but I haven't

792
00:32:11,320 --> 00:32:13,870
committed yet so you can't see any

793
00:32:13,870 --> 00:32:17,320
myself yeah if your timestamp is greater

794
00:32:17,320 --> 00:32:18,850
than mine then I won't then and you

795
00:32:18,850 --> 00:32:20,650
write some table I won't read it yeah so

796
00:32:20,650 --> 00:32:24,640
it's always one direction all right so

797
00:32:24,640 --> 00:32:27,400
in the heck of time paper

798
00:32:27,400 --> 00:32:30,100
they proposed actually and evaluate both

799
00:32:30,100 --> 00:32:31,690
the optimistic and pessimistic version

800
00:32:31,690 --> 00:32:33,040
of what I've just described so

801
00:32:33,040 --> 00:32:34,059
optimistic is what we've already talked

802
00:32:34,059 --> 00:32:35,559
about again the key thing is here in

803
00:32:35,559 --> 00:32:37,630
order to ensure serialize ability I have

804
00:32:37,630 --> 00:32:39,460
to check for phantoms by rerunning my

805
00:32:39,460 --> 00:32:42,460
scans on commit and so when you download

806
00:32:42,460 --> 00:32:44,679
sequel server and you run it and you you

807
00:32:44,679 --> 00:32:46,030
run it in every table this is actually

808
00:32:46,030 --> 00:32:47,530
what you get but they also implemented a

809
00:32:47,530 --> 00:32:48,880
pessimistic version based on two-phase

810
00:32:48,880 --> 00:32:52,000
locking and the the main thing this to

811
00:32:52,000 --> 00:32:53,500
understand is that they don't have a

812
00:32:53,500 --> 00:32:55,059
validation phase because they're going

813
00:32:55,059 --> 00:32:58,059
to do index locks and and you know share

814
00:32:58,059 --> 00:32:58,940
locks an exclusive locks

815
00:32:58,940 --> 00:33:00,830
to avoid any phantoms and they have a

816
00:33:00,830 --> 00:33:03,080
background thread to do deadlock

817
00:33:03,080 --> 00:33:05,539
detection all right so this is the only

818
00:33:05,539 --> 00:33:06,830
graph I want to show you from the paper

819
00:33:06,830 --> 00:33:10,849
again the papers from 2012 so relative

820
00:33:10,849 --> 00:33:12,049
to the other systems we're talking about

821
00:33:12,049 --> 00:33:15,919
this is pretty old and the horror that

822
00:33:15,919 --> 00:33:18,379
running on is a bit dated the main

823
00:33:18,379 --> 00:33:20,029
takeaway from here is again as you scale

824
00:33:20,029 --> 00:33:21,979
up the number of threads for this sort

825
00:33:21,979 --> 00:33:23,210
of high contingent workload with only a

826
00:33:23,210 --> 00:33:25,429
thousand tuples the the pessimistic

827
00:33:25,429 --> 00:33:28,489
version it's worse than the optimistic

828
00:33:28,489 --> 00:33:30,799
one and there's gap mate may not seem

829
00:33:30,799 --> 00:33:32,090
like a lot but if you look at the

830
00:33:32,090 --> 00:33:35,629
numbers here it's this the the

831
00:33:35,629 --> 00:33:38,269
optimistic version is doing at most 1.5

832
00:33:38,269 --> 00:33:40,129
million transactions a second and then

833
00:33:40,129 --> 00:33:42,019
the pessimistic one is doing 1.2 million

834
00:33:42,019 --> 00:33:43,970
so the difference is 300,000

835
00:33:43,970 --> 00:33:45,950
transactions per second that's actually

836
00:33:45,950 --> 00:33:48,529
a lot so like running this particular

837
00:33:48,529 --> 00:33:49,639
workload I don't know the exact details

838
00:33:49,639 --> 00:33:52,129
on the hardware but my sequin po stuff

839
00:33:52,129 --> 00:33:54,139
can maybe do it most a hundred thousand

840
00:33:54,139 --> 00:33:56,869
transactions a second I don't know what

841
00:33:56,869 --> 00:33:58,309
you know if you disable logging maybe a

842
00:33:58,309 --> 00:34:00,440
little faster but you know this is

843
00:34:00,440 --> 00:34:02,210
pretty so this is a law even though

844
00:34:02,210 --> 00:34:03,710
relatively between the two of them it

845
00:34:03,710 --> 00:34:07,129
doesn't seem like much right no so this

846
00:34:07,129 --> 00:34:08,418
paper basically said like Oh an

847
00:34:08,418 --> 00:34:10,129
optimistic approach for an in-memory and

848
00:34:10,129 --> 00:34:11,809
multi version system is the way to go

849
00:34:11,809 --> 00:34:16,909
and not the pessimistic one okay all

850
00:34:16,909 --> 00:34:18,500
right so where does someone takeaways we

851
00:34:18,500 --> 00:34:20,629
can have from Hecate on so from a design

852
00:34:20,629 --> 00:34:22,719
standpoint they talked about having this

853
00:34:22,719 --> 00:34:24,859
this global map to keep track of the

854
00:34:24,859 --> 00:34:26,179
state of everything they're gonna laughs

855
00:34:26,179 --> 00:34:27,739
respective reads and of course

856
00:34:27,739 --> 00:34:29,109
everyone's gonna do first writer wins

857
00:34:29,109 --> 00:34:31,429
but some of the things that came out of

858
00:34:31,429 --> 00:34:32,869
the paper that they discussed it says

859
00:34:32,869 --> 00:34:34,879
like your design in memory system that

860
00:34:34,879 --> 00:34:36,260
there were sort of tenants you should

861
00:34:36,260 --> 00:34:38,029
follow the first is that they said that

862
00:34:38,029 --> 00:34:40,159
you only want to use lock for your lat

863
00:34:40,159 --> 00:34:42,049
tree data structures so that means no

864
00:34:42,049 --> 00:34:43,879
latch instead of spin locks no critical

865
00:34:43,879 --> 00:34:45,230
sections everything should always be

866
00:34:45,230 --> 00:34:47,839
written and on a lock free approach and

867
00:34:47,839 --> 00:34:48,949
this would be free indexes your

868
00:34:48,949 --> 00:34:50,418
transaction map the memory allocator the

869
00:34:50,418 --> 00:34:52,789
garbage collector so I just I agree with

870
00:34:52,789 --> 00:34:54,918
everything except for this one here for

871
00:34:54,918 --> 00:34:58,130
indexes so next week you guys will read

872
00:34:58,130 --> 00:35:00,200
about the BW tree which is a lot free

873
00:35:00,200 --> 00:35:02,000
index that they built and part of the

874
00:35:02,000 --> 00:35:04,220
hackathon project we and them

875
00:35:04,220 --> 00:35:07,609
implementing the same thing and it gets

876
00:35:07,609 --> 00:35:11,300
it it's not crap like but it new

877
00:35:11,300 --> 00:35:13,610
two indexes that still use sort of

878
00:35:13,610 --> 00:35:16,760
traditional locking techniques right the

879
00:35:16,760 --> 00:35:18,380
way Hecate inversion started was they

880
00:35:18,380 --> 00:35:20,180
went all-in with skip list skip list as

881
00:35:20,180 --> 00:35:21,920
a walk free data structure that sort of

882
00:35:21,920 --> 00:35:24,620
looks at the Kabbalistic B+ stream that

883
00:35:24,620 --> 00:35:26,090
you can make a lock free so in the

884
00:35:26,090 --> 00:35:27,320
original versions the Hecate on they

885
00:35:27,320 --> 00:35:28,580
were like skip list of the way to go

886
00:35:28,580 --> 00:35:30,800
this is how they design the system then

887
00:35:30,800 --> 00:35:32,600
they said actually skip list or crap you

888
00:35:32,600 --> 00:35:35,270
actually want to use a BW tree but even

889
00:35:35,270 --> 00:35:36,710
then the B Double Tree is gonna lose to

890
00:35:36,710 --> 00:35:38,840
you know regular P plus tree this this

891
00:35:38,840 --> 00:35:40,160
is what you end up guys building for the

892
00:35:40,160 --> 00:35:42,140
second project so it's also interesting

893
00:35:42,140 --> 00:35:43,730
about this the one database system

894
00:35:43,730 --> 00:35:45,170
that's out there that is very big on

895
00:35:45,170 --> 00:35:48,020
skip lists his mem sequel right and the

896
00:35:48,020 --> 00:35:49,220
reason is because the one the

897
00:35:49,220 --> 00:35:51,050
co-founders and then sequel was at

898
00:35:51,050 --> 00:35:52,850
Microsoft at the time working on sequel

899
00:35:52,850 --> 00:35:54,110
server when the hecatomb project was

900
00:35:54,110 --> 00:35:55,940
going on and he saw about to these

901
00:35:55,940 --> 00:35:57,590
internal talks from Paul Larsen and

902
00:35:57,590 --> 00:35:59,000
Mike's willing the two guys leading the

903
00:35:59,000 --> 00:36:00,980
hackathon project and the very beginning

904
00:36:00,980 --> 00:36:02,630
of the project they were like skip list

905
00:36:02,630 --> 00:36:04,100
of the way to go this is what you should

906
00:36:04,100 --> 00:36:06,440
be using so the mem Siegel guys saw that

907
00:36:06,440 --> 00:36:08,450
and then you know to borrow those ideas

908
00:36:08,450 --> 00:36:10,100
when he went off and done em sequel but

909
00:36:10,100 --> 00:36:11,540
he then he missed the second half of the

910
00:36:11,540 --> 00:36:13,490
talk the basic said skip lists are crap

911
00:36:13,490 --> 00:36:16,310
and that you want to use a BW but I

912
00:36:16,310 --> 00:36:18,200
think still today like MEMC go still

913
00:36:18,200 --> 00:36:21,440
very big on skip list but again the

914
00:36:21,440 --> 00:36:23,210
research shows that that is garbage

915
00:36:23,210 --> 00:36:27,860
so I would say like house is you almost

916
00:36:27,860 --> 00:36:30,320
make with very rare exception you never

917
00:36:30,320 --> 00:36:31,640
want to use a skip list like there are

918
00:36:31,640 --> 00:36:33,020
some cases weren't like for in memory

919
00:36:33,020 --> 00:36:35,360
stuff that small skip list might be okay

920
00:36:35,360 --> 00:36:37,670
I just have some nice properties for

921
00:36:37,670 --> 00:36:39,560
memory fragmentation but in general for

922
00:36:39,560 --> 00:36:41,840
index will cover this you know all next

923
00:36:41,840 --> 00:36:42,170
week

924
00:36:42,170 --> 00:36:43,640
skip lists are a bad idea don't go don't

925
00:36:43,640 --> 00:36:45,200
use that and don't use the P Double Tree

926
00:36:45,200 --> 00:36:47,120
either even though we still use we still

927
00:36:47,120 --> 00:36:48,860
use it all right

928
00:36:48,860 --> 00:36:50,120
the other interesting thing they talk

929
00:36:50,120 --> 00:36:53,060
about is that and I agree with this is

930
00:36:53,060 --> 00:36:55,430
that you should only really you know you

931
00:36:55,430 --> 00:36:56,600
want to minimize the number of

932
00:36:56,600 --> 00:36:57,800
civilization' points or bottleneck

933
00:36:57,800 --> 00:36:59,720
points in the system and the only place

934
00:36:59,720 --> 00:37:01,310
you need to do that in the case of

935
00:37:01,310 --> 00:37:03,290
hackathon is when you hand out the

936
00:37:03,290 --> 00:37:04,880
beginning began to commit timestamps

937
00:37:04,880 --> 00:37:06,380
because these always need to be

938
00:37:06,380 --> 00:37:07,820
monotonically increasing and you can't

939
00:37:07,820 --> 00:37:10,040
you can't give out to placate timestamps

940
00:37:10,040 --> 00:37:12,260
so the way they do this is through a

941
00:37:12,260 --> 00:37:13,790
compare and swap for atomic addition

942
00:37:13,790 --> 00:37:15,500
right single instruction to add one to

943
00:37:15,500 --> 00:37:18,200
the counter in the paper you guys let

944
00:37:18,200 --> 00:37:22,190
read last class we showed that if this

945
00:37:22,190 --> 00:37:24,050
approach can you know really high core

946
00:37:24,050 --> 00:37:25,100
count can get max

947
00:37:25,100 --> 00:37:27,320
maybe like you know hundred million time

948
00:37:27,320 --> 00:37:28,820
tens for a second so you could try to

949
00:37:28,820 --> 00:37:31,250
batch these things in our current system

950
00:37:31,250 --> 00:37:34,850
we we we actually don't do this we do

951
00:37:34,850 --> 00:37:36,560
what heck we hyper does and in that case

952
00:37:36,560 --> 00:37:38,780
there is actually a spin lock around a

953
00:37:38,780 --> 00:37:40,490
sort of a critical section so in case

954
00:37:40,490 --> 00:37:41,600
the hackathon they don't have that issue

955
00:37:41,600 --> 00:37:42,620
they just hand out these time stamps

956
00:37:42,620 --> 00:37:48,800
array efficient okay all right so okay

957
00:37:48,800 --> 00:37:51,140
Hecate on i spent you know the first

958
00:37:51,140 --> 00:37:52,490
forty minutes about talking about it

959
00:37:52,490 --> 00:37:53,780
because that's what about it's a

960
00:37:53,780 --> 00:37:55,940
baseline to now understand all those

961
00:37:55,940 --> 00:37:57,410
sort of modern implementations or

962
00:37:57,410 --> 00:38:00,770
variants of a multi version control so

963
00:38:00,770 --> 00:38:01,970
that we can make some observations and

964
00:38:01,970 --> 00:38:03,640
now about what the Hecate on

965
00:38:03,640 --> 00:38:05,780
architecture looks like and what are

966
00:38:05,780 --> 00:38:06,650
some challenges are what some

967
00:38:06,650 --> 00:38:08,210
bottlenecks they're going to face when

968
00:38:08,210 --> 00:38:09,500
we look at other workloads other than

969
00:38:09,500 --> 00:38:12,290
OTP so the first thing is going to be

970
00:38:12,290 --> 00:38:13,460
what i talked already mentioned is that

971
00:38:13,460 --> 00:38:16,790
the reset and thus can set validation is

972
00:38:16,790 --> 00:38:18,410
going to be really expensive if our

973
00:38:18,410 --> 00:38:20,470
transactions to access a lot of data so

974
00:38:20,470 --> 00:38:22,580
typically under oil to be workloads

975
00:38:22,580 --> 00:38:24,710
transactions you know update maybe a

976
00:38:24,710 --> 00:38:27,080
couple dozen tuples or acts as a couple

977
00:38:27,080 --> 00:38:28,490
delves into bowls so in that case

978
00:38:28,490 --> 00:38:29,960
they're the scan side or the reset is

979
00:38:29,960 --> 00:38:31,280
gonna be quite small so we can do that

980
00:38:31,280 --> 00:38:33,500
validation very quickly but now if I'm

981
00:38:33,500 --> 00:38:35,180
running on analytical query where I scan

982
00:38:35,180 --> 00:38:37,130
the entire table my table has a billion

983
00:38:37,130 --> 00:38:39,950
tuples now when I do that validation I

984
00:38:39,950 --> 00:38:41,540
got to go read one building two polls

985
00:38:41,540 --> 00:38:42,080
all over again

986
00:38:42,080 --> 00:38:43,730
right and that's gonna take a long long

987
00:38:43,730 --> 00:38:47,090
time the next issue is that the append

988
00:38:47,090 --> 00:38:48,560
only version that they're that they're

989
00:38:48,560 --> 00:38:51,590
using going oldest and newest is me bad

990
00:38:51,590 --> 00:38:53,780
for OLAP scans because now as I'm

991
00:38:53,780 --> 00:38:55,820
scanning along the version chain I'm

992
00:38:55,820 --> 00:38:57,530
reading a bunch of stuff that I probably

993
00:38:57,530 --> 00:38:58,790
don't need just to get to the version

994
00:38:58,790 --> 00:39:00,710
that I actually want you know depending

995
00:39:00,710 --> 00:39:01,850
on how fast I do garbage collection the

996
00:39:01,850 --> 00:39:04,430
version change can get quite long and

997
00:39:04,430 --> 00:39:05,870
all this pointer chaining chasing and

998
00:39:05,870 --> 00:39:07,940
branching is going to be bad on a modern

999
00:39:07,940 --> 00:39:09,980
CPU architecture because they're gonna

1000
00:39:09,980 --> 00:39:11,690
have these long instruction pipelines so

1001
00:39:11,690 --> 00:39:13,280
now if I miss predict on a branch

1002
00:39:13,280 --> 00:39:15,020
I gotta flush my pipeline and fetch

1003
00:39:15,020 --> 00:39:16,490
everything back in and I'll have long

1004
00:39:16,490 --> 00:39:20,140
stalls the last issue is going to be

1005
00:39:20,140 --> 00:39:22,430
with Hecate on that they were doing a

1006
00:39:22,430 --> 00:39:25,010
coarse-grained conflict detection and

1007
00:39:25,010 --> 00:39:27,050
determine whether you had a complex

1008
00:39:27,050 --> 00:39:29,540
routine to transactions so what I mean

1009
00:39:29,540 --> 00:39:31,400
by that is all they were doing to

1010
00:39:31,400 --> 00:39:33,140
determine whether there was a conflict

1011
00:39:33,140 --> 00:39:36,620
is just does the pointer exist you know

1012
00:39:36,620 --> 00:39:38,540
does did I reckon you know is there vert

1013
00:39:38,540 --> 00:39:38,960
another

1014
00:39:38,960 --> 00:39:41,630
after the version I'm trying to read so

1015
00:39:41,630 --> 00:39:44,270
let's say now though I have a table that

1016
00:39:44,270 --> 00:39:46,700
has a thousand tuples and my transaction

1017
00:39:46,700 --> 00:39:49,010
reads reads one of them I'm sorry my

1018
00:39:49,010 --> 00:39:51,020
transaction rights one of them your

1019
00:39:51,020 --> 00:39:53,299
transaction reads the other 999 of em

1020
00:39:53,299 --> 00:39:55,670
you don't read the one that I wrote but

1021
00:39:55,670 --> 00:39:57,200
now that's me consider it as a spec of

1022
00:39:57,200 --> 00:39:59,510
read because you read a version that I

1023
00:39:59,510 --> 00:40:01,910
created but you didn't actually read the

1024
00:40:01,910 --> 00:40:03,799
part that the data that I modified

1025
00:40:03,799 --> 00:40:06,380
so now if I abort you have to work too

1026
00:40:06,380 --> 00:40:08,029
because the database sim doesn't know

1027
00:40:08,029 --> 00:40:10,250
anything about what you read it just

1028
00:40:10,250 --> 00:40:11,630
knows that you read a version that was

1029
00:40:11,630 --> 00:40:12,740
created by this other transaction that

1030
00:40:12,740 --> 00:40:14,450
transaction aborted it so therefore you

1031
00:40:14,450 --> 00:40:18,289
have to work too so right so that's so

1032
00:40:18,289 --> 00:40:19,520
again and we're doing this visit we're

1033
00:40:19,520 --> 00:40:21,500
just the mere existence the pointer it's

1034
00:40:21,500 --> 00:40:22,700
enough to say that you read something

1035
00:40:22,700 --> 00:40:24,680
that I that I wrote but nothing

1036
00:40:24,680 --> 00:40:28,400
internally no nothing more fine-grain so

1037
00:40:28,400 --> 00:40:30,980
the hyper system again this is out of

1038
00:40:30,980 --> 00:40:33,260
the EU Munich right this is the Germans

1039
00:40:33,260 --> 00:40:34,730
anytime I refer to oh the Germans are

1040
00:40:34,730 --> 00:40:35,779
beating us that we have to work harder

1041
00:40:35,779 --> 00:40:37,490
cuz of the Germans it's these Germans

1042
00:40:37,490 --> 00:40:39,410
they're very good so hyper was the first

1043
00:40:39,410 --> 00:40:42,920
data submit they built its an in-memory

1044
00:40:42,920 --> 00:40:44,630
columnstore using Delta record

1045
00:40:44,630 --> 00:40:46,609
versioning going from newest to oldest

1046
00:40:46,609 --> 00:40:49,930
and what they're gonna do is that

1047
00:40:49,930 --> 00:40:52,880
they're gonna support more fine-grain

1048
00:40:52,880 --> 00:40:55,520
conflict detection then what Hecate on

1049
00:40:55,520 --> 00:40:57,920
can do and we'll see how we do that in a

1050
00:40:57,920 --> 00:41:00,319
second they're also going to do avoid

1051
00:41:00,319 --> 00:41:01,579
write write complex by saying the first

1052
00:41:01,579 --> 00:41:04,609
writer wins and then the others do you

1053
00:41:04,609 --> 00:41:06,109
think thing that we talked about the end

1054
00:41:06,109 --> 00:41:07,369
of last classes the way they're gonna

1055
00:41:07,369 --> 00:41:10,130
handle indexes in a multi version system

1056
00:41:10,130 --> 00:41:12,980
that anytime you have an update on a

1057
00:41:12,980 --> 00:41:13,579
tuple

1058
00:41:13,579 --> 00:41:16,670
if the attributes you're updating are

1059
00:41:16,670 --> 00:41:18,619
our index but you know in some some

1060
00:41:18,619 --> 00:41:21,410
index then you have to do a delete in

1061
00:41:21,410 --> 00:41:24,200
the index followed by the insert right

1062
00:41:24,200 --> 00:41:25,940
because otherwise you have to maintain

1063
00:41:25,940 --> 00:41:27,529
these different versioning information

1064
00:41:27,529 --> 00:41:29,420
inside the in the index to point to both

1065
00:41:29,420 --> 00:41:32,630
of these I and it becomes a big pain so

1066
00:41:32,630 --> 00:41:34,099
you treat it as a delete by answer and

1067
00:41:34,099 --> 00:41:35,770
that that solves that problem

1068
00:41:35,770 --> 00:41:38,839
so let's look an example here so again

1069
00:41:38,839 --> 00:41:41,270
they're doing deltal storage and it's a

1070
00:41:41,270 --> 00:41:44,420
column storm so they're inside of every

1071
00:41:44,420 --> 00:41:45,980
block of tuples they're going to

1072
00:41:45,980 --> 00:41:47,270
maintain a special column called the

1073
00:41:47,270 --> 00:41:49,579
Virgen vector and this version vector is

1074
00:41:49,579 --> 00:41:52,820
going to point to now a delta store

1075
00:41:52,820 --> 00:41:54,800
that's allocated per thread or per

1076
00:41:54,800 --> 00:41:56,960
transaction that we're gonna maintain

1077
00:41:56,960 --> 00:41:59,090
all the updates that we have for you

1078
00:41:59,090 --> 00:42:01,190
know for this particular tuple so if the

1079
00:42:01,190 --> 00:42:02,930
pointer is null that we know that this

1080
00:42:02,930 --> 00:42:04,550
is the the master version in the latest

1081
00:42:04,550 --> 00:42:05,300
version of this tuple

1082
00:42:05,300 --> 00:42:08,720
and there is no you know there is no

1083
00:42:08,720 --> 00:42:10,100
other version we need to check if the

1084
00:42:10,100 --> 00:42:12,320
pointer is not null then if we need to

1085
00:42:12,320 --> 00:42:13,640
go back and try to find an early version

1086
00:42:13,640 --> 00:42:14,900
we just follow along this pointer and we

1087
00:42:14,900 --> 00:42:17,210
look inside of our our transact red

1088
00:42:17,210 --> 00:42:19,730
space so sort of related to what Hector

1089
00:42:19,730 --> 00:42:21,020
tom was saying that you don't want any

1090
00:42:21,020 --> 00:42:22,220
global data structures you don't want

1091
00:42:22,220 --> 00:42:24,770
any global memory space the this Delta

1092
00:42:24,770 --> 00:42:26,000
storage is gonna be on a per thread

1093
00:42:26,000 --> 00:42:28,700
basis so when I allocate a bunch of

1094
00:42:28,700 --> 00:42:30,470
space for my thread and thread local

1095
00:42:30,470 --> 00:42:32,600
storage I don't worry about contending

1096
00:42:32,600 --> 00:42:34,220
on into the memory allocator for other

1097
00:42:34,220 --> 00:42:35,480
threads because that space is allocated

1098
00:42:35,480 --> 00:42:36,340
from me

1099
00:42:36,340 --> 00:42:38,480
although threads can read my memory

1100
00:42:38,480 --> 00:42:40,190
that's fine but nobody else can write

1101
00:42:40,190 --> 00:42:41,870
into it but me and that voice haven't

1102
00:42:41,870 --> 00:42:43,460
take any latches on any internal data

1103
00:42:43,460 --> 00:42:46,670
structures we have in here so now if I

1104
00:42:46,670 --> 00:42:48,080
have another transaction it comes along

1105
00:42:48,080 --> 00:42:50,720
that wants to do an update right so say

1106
00:42:50,720 --> 00:42:52,580
it wants to update the Tupac tuple so

1107
00:42:52,580 --> 00:42:53,990
the first thing we're gonna do is copy

1108
00:42:53,990 --> 00:42:56,720
out the the attribute that we're gonna

1109
00:42:56,720 --> 00:42:58,280
modify so we're gonna modify attribute

1110
00:42:58,280 --> 00:43:00,410
two so he put the old value over here

1111
00:43:00,410 --> 00:43:02,360
and then we update our pointer to now

1112
00:43:02,360 --> 00:43:04,310
point to what the the previous version

1113
00:43:04,310 --> 00:43:06,620
was and then we can go ahead and do

1114
00:43:06,620 --> 00:43:08,420
compare and swap install our version

1115
00:43:08,420 --> 00:43:12,890
vector and update our value right same

1116
00:43:12,890 --> 00:43:14,360
thing for the next guy right we update

1117
00:43:14,360 --> 00:43:16,520
this table there is no older version so

1118
00:43:16,520 --> 00:43:18,290
our pointer doesn't point to anything we

1119
00:43:18,290 --> 00:43:20,540
copied the old value here and it's

1120
00:43:20,540 --> 00:43:23,270
updated version pointer there so in our

1121
00:43:23,270 --> 00:43:25,520
current system we do it the same way all

1122
00:43:25,520 --> 00:43:27,970
right but we actually do this all in a

1123
00:43:27,970 --> 00:43:30,410
latch free manner which gets a little

1124
00:43:30,410 --> 00:43:33,170
tricky in order to make sure you get

1125
00:43:33,170 --> 00:43:34,100
things in the right version when you

1126
00:43:34,100 --> 00:43:35,990
have two leads we can ignore that for

1127
00:43:35,990 --> 00:43:38,540
now in Hecate on the way they actually

1128
00:43:38,540 --> 00:43:40,670
did it was have a latch on the entire

1129
00:43:40,670 --> 00:43:42,950
block of tuples they each block is going

1130
00:43:42,950 --> 00:43:45,710
it's like 1024 tuples so in that case

1131
00:43:45,710 --> 00:43:47,450
here I take I take the right latch and

1132
00:43:47,450 --> 00:43:48,950
the whole thing and I don't worry about

1133
00:43:48,950 --> 00:43:50,930
someone else coming along and reading

1134
00:43:50,930 --> 00:43:53,150
something while I'm an intermediate

1135
00:43:53,150 --> 00:43:55,940
state in our system because deletes are

1136
00:43:55,940 --> 00:43:58,550
tricky we do you know we do some extra

1137
00:43:58,550 --> 00:44:01,370
stuff to make this all be less free but

1138
00:44:01,370 --> 00:44:04,360
you don't worry about that for now

1139
00:44:04,360 --> 00:44:06,070
all right the thing that is really cool

1140
00:44:06,070 --> 00:44:07,540
about hyper is again how they're gonna

1141
00:44:07,540 --> 00:44:08,980
do validation to ensure serialize a

1142
00:44:08,980 --> 00:44:11,260
building so again first writer wins

1143
00:44:11,260 --> 00:44:13,120
that's easy right if I if I have two

1144
00:44:13,120 --> 00:44:14,410
transactions that try to update the same

1145
00:44:14,410 --> 00:44:16,630
thing whoever got there first succeeds

1146
00:44:16,630 --> 00:44:19,420
and the other guy aborts so the paper

1147
00:44:19,420 --> 00:44:21,070
that you guys are trying to read

1148
00:44:21,070 --> 00:44:22,840
describes how to handle this in

1149
00:44:22,840 --> 00:44:24,850
actuality which is not discussed in the

1150
00:44:24,850 --> 00:44:27,190
paper and it's not really public but

1151
00:44:27,190 --> 00:44:28,930
they don't really have write write

1152
00:44:28,930 --> 00:44:30,700
conflicts because they actually only

1153
00:44:30,700 --> 00:44:33,730
have one writer thread so only one

1154
00:44:33,730 --> 00:44:35,740
thread can update transaction or update

1155
00:44:35,740 --> 00:44:36,940
the Davis at a time there's much a

1156
00:44:36,940 --> 00:44:38,830
reader thread to do analytics but

1157
00:44:38,830 --> 00:44:40,660
there's no write write conflicts because

1158
00:44:40,660 --> 00:44:41,830
there's only one guy could be updating

1159
00:44:41,830 --> 00:44:45,880
the data at the time same same time but

1160
00:44:45,880 --> 00:44:47,200
the protocol you guys read about would

1161
00:44:47,200 --> 00:44:50,770
actually handle multiple threads so now

1162
00:44:50,770 --> 00:44:54,040
the way they're gonna do validation said

1163
00:44:54,040 --> 00:44:55,870
are you react seeding the scan set is

1164
00:44:55,870 --> 00:44:57,640
that they're gonna use a technique

1165
00:44:57,640 --> 00:45:00,070
called precision blocking so this is

1166
00:45:00,070 --> 00:45:03,430
really cool because this precision

1167
00:45:03,430 --> 00:45:05,170
locking paper came out before I was born

1168
00:45:05,170 --> 00:45:07,900
in 1980 and a time before these Germans

1169
00:45:07,900 --> 00:45:09,970
picked up picked it up it had like 40

1170
00:45:09,970 --> 00:45:13,930
citations so a 30 40 year old paper with

1171
00:45:13,930 --> 00:45:15,760
40 citations is essentially forgotten

1172
00:45:15,760 --> 00:45:17,200
right no-one's citing it no one's

1173
00:45:17,200 --> 00:45:19,000
reading it right and somehow the Germans

1174
00:45:19,000 --> 00:45:21,640
dug this thing out and what its gonna do

1175
00:45:21,640 --> 00:45:22,990
it's gonna be like an approximate

1176
00:45:22,990 --> 00:45:25,060
predicate locking so I don't remember

1177
00:45:25,060 --> 00:45:26,800
whether we discuss predicate locking in

1178
00:45:26,800 --> 00:45:28,930
the intro class but basically predicate

1179
00:45:28,930 --> 00:45:30,520
locking is a way to look at to where

1180
00:45:30,520 --> 00:45:32,410
clauses and queries and figure out

1181
00:45:32,410 --> 00:45:35,590
whether they intercept all right and for

1182
00:45:35,590 --> 00:45:37,360
simple cases like a egos 1 and B equals

1183
00:45:37,360 --> 00:45:39,640
2 like those don't intersect that's not

1184
00:45:39,640 --> 00:45:42,370
a problem but for more complex things it

1185
00:45:42,370 --> 00:45:44,290
becomes very very difficult I think it's

1186
00:45:44,290 --> 00:45:45,000
np-complete

1187
00:45:45,000 --> 00:45:47,950
so precision locking is like an

1188
00:45:47,950 --> 00:45:50,140
approximation of that where I only need

1189
00:45:50,140 --> 00:45:52,240
to look at just what I actually modified

1190
00:45:52,240 --> 00:45:54,280
whether the tuple that I modify it

1191
00:45:54,280 --> 00:45:56,350
overlap with what my queries are trying

1192
00:45:56,350 --> 00:45:59,470
to do and so rather than having execute

1193
00:45:59,470 --> 00:46:01,600
the scan you just sort of re execute the

1194
00:46:01,600 --> 00:46:04,330
query based on the the Delta records

1195
00:46:04,330 --> 00:46:07,480
that are generated by transactions it'll

1196
00:46:07,480 --> 00:46:08,770
make more sense the next slide but

1197
00:46:08,770 --> 00:46:10,570
basically when my transaction commits to

1198
00:46:10,570 --> 00:46:12,340
do validation I look at all the

1199
00:46:12,340 --> 00:46:14,770
transactions that have committed after I

1200
00:46:14,770 --> 00:46:17,040
started me

1201
00:46:17,040 --> 00:46:18,840
I did not see their updates when when I

1202
00:46:18,840 --> 00:46:20,850
ran because they not they did not commit

1203
00:46:20,850 --> 00:46:22,740
before I started so I'm going to see

1204
00:46:22,740 --> 00:46:24,690
whether they then created new versions

1205
00:46:24,690 --> 00:46:27,450
that I should have ran read when I ran

1206
00:46:27,450 --> 00:46:30,870
the first time all right so let's look

1207
00:46:30,870 --> 00:46:32,310
an example here so say this is the

1208
00:46:32,310 --> 00:46:33,780
transaction we want to validate it has

1209
00:46:33,780 --> 00:46:35,520
three queries and then there's three

1210
00:46:35,520 --> 00:46:36,870
transactions that have already committed

1211
00:46:36,870 --> 00:46:38,850
so they're in the past right they're

1212
00:46:38,850 --> 00:46:42,900
gone and we have their their their redo

1213
00:46:42,900 --> 00:46:44,670
records so these are the same video

1214
00:46:44,670 --> 00:46:45,690
records we would write out the disk

1215
00:46:45,690 --> 00:46:47,430
anyway so it's not like we're generating

1216
00:46:47,430 --> 00:46:49,800
these to do just this validation we have

1217
00:46:49,800 --> 00:46:51,840
to log them out to disk so we keep

1218
00:46:51,840 --> 00:46:54,840
around a memory to do our check and so

1219
00:46:54,840 --> 00:46:56,430
that so the idea is that we're gonna

1220
00:46:56,430 --> 00:46:57,720
look at the where clause for every

1221
00:46:57,720 --> 00:47:00,230
single query and check to see whether

1222
00:47:00,230 --> 00:47:02,550
there is an overlap with what we're

1223
00:47:02,550 --> 00:47:04,440
looking up here with what they actually

1224
00:47:04,440 --> 00:47:06,600
modified and if so then we know with it

1225
00:47:06,600 --> 00:47:07,800
we should have read what they wrote but

1226
00:47:07,800 --> 00:47:10,710
we didn't so therefore we have to abort

1227
00:47:10,710 --> 00:47:13,320
so the way you take about this easily is

1228
00:47:13,320 --> 00:47:14,550
that we look and see what attribute are

1229
00:47:14,550 --> 00:47:15,900
we accessing in our where clause for

1230
00:47:15,900 --> 00:47:18,120
each predicate and then we look at see

1231
00:47:18,120 --> 00:47:19,890
whether they modify that attribute in

1232
00:47:19,890 --> 00:47:21,780
any log record and then we just

1233
00:47:21,780 --> 00:47:24,420
substitute that value in here alright so

1234
00:47:24,420 --> 00:47:26,790
for this first one attribute ask me to

1235
00:47:26,790 --> 00:47:29,100
it's greater than 20 this guy modified

1236
00:47:29,100 --> 00:47:32,250
attribute to is 799 so he placed 99 here

1237
00:47:32,250 --> 00:47:35,430
so 99 is not greater than 30 or greater

1238
00:47:35,430 --> 00:47:38,520
than 20 and less than 30 so we know that

1239
00:47:38,520 --> 00:47:39,810
this thing would not evaluates it for

1240
00:47:39,810 --> 00:47:41,460
our query here we wouldn't have read

1241
00:47:41,460 --> 00:47:48,900
this yes no no they committed it after

1242
00:47:48,900 --> 00:47:54,680
we started no not necessarily

1243
00:47:54,680 --> 00:47:57,510
again snapshot isolation says I can only

1244
00:47:57,510 --> 00:47:59,130
read things I only see things that are

1245
00:47:59,130 --> 00:48:01,590
visible to me if they were created by a

1246
00:48:01,590 --> 00:48:03,090
transaction that committed before I

1247
00:48:03,090 --> 00:48:05,280
started so I've started and there's a

1248
00:48:05,280 --> 00:48:06,150
bunch of transactions that have already

1249
00:48:06,150 --> 00:48:07,380
started in there making some stuff and

1250
00:48:07,380 --> 00:48:08,700
the current transaction that started

1251
00:48:08,700 --> 00:48:10,140
after I started that wrote some stuff

1252
00:48:10,140 --> 00:48:14,520
then committed as well so in this case

1253
00:48:14,520 --> 00:48:16,260
here for both these predicates alright

1254
00:48:16,260 --> 00:48:17,850
for this transaction it evaluates to

1255
00:48:17,850 --> 00:48:19,710
false so we know again that this

1256
00:48:19,710 --> 00:48:21,420
transaction did not create anything that

1257
00:48:21,420 --> 00:48:24,960
I would have read if I was if it was

1258
00:48:24,960 --> 00:48:26,700
installed before you know when I

1259
00:48:26,700 --> 00:48:28,110
actually had to read the first time so I

1260
00:48:28,110 --> 00:48:29,490
didn't miss anything so there's no

1261
00:48:29,490 --> 00:48:30,580
phantom here I could

1262
00:48:30,580 --> 00:48:32,890
that same thing with an ex guy here

1263
00:48:32,890 --> 00:48:35,710
right after two is in ten twenty or

1264
00:48:35,710 --> 00:48:38,740
thirty this guy created ninety nine and

1265
00:48:38,740 --> 00:48:40,330
thirty three and so for both these

1266
00:48:40,330 --> 00:48:41,980
predicates evaluates to false three

1267
00:48:41,980 --> 00:48:43,180
threes not ten twenty or thirty

1268
00:48:43,180 --> 00:48:45,160
ninety-nine not ten twenty or thirty so

1269
00:48:45,160 --> 00:48:47,140
therefore and I didn't read any I didn't

1270
00:48:47,140 --> 00:48:49,720
miss anything so that's false so we we

1271
00:48:49,720 --> 00:48:52,840
can skip that in this case here I I'm

1272
00:48:52,840 --> 00:48:55,510
doing a lookup on attribute one this guy

1273
00:48:55,510 --> 00:48:59,080
only modified attribute to so there's

1274
00:48:59,080 --> 00:49:00,550
nothing that this guy would have modify

1275
00:49:00,550 --> 00:49:02,110
that it read so I'd replaced that with a

1276
00:49:02,110 --> 00:49:05,140
null null like any wild card what would

1277
00:49:05,140 --> 00:49:07,750
it actually evaluate to null so long as

1278
00:49:07,750 --> 00:49:11,230
it's not true then we're fine and I

1279
00:49:11,230 --> 00:49:13,690
didn't miss anything so I'm gonna do

1280
00:49:13,690 --> 00:49:15,190
this down the line for all these guys

1281
00:49:15,190 --> 00:49:18,070
alright one by one but now we get to

1282
00:49:18,070 --> 00:49:21,700
this guy here accurate one like ice wild

1283
00:49:21,700 --> 00:49:23,920
card ice wild card and in this case here

1284
00:49:23,920 --> 00:49:27,370
somebody installed the you know the

1285
00:49:27,370 --> 00:49:29,950
string Ice Cube so now in this case here

1286
00:49:29,950 --> 00:49:32,260
my predicate would evaluate to true so

1287
00:49:32,260 --> 00:49:33,850
therefore again that means that this

1288
00:49:33,850 --> 00:49:36,370
transaction did an update that was

1289
00:49:36,370 --> 00:49:38,710
committed after I started but because I

1290
00:49:38,710 --> 00:49:40,870
was looking at a previous snapshot I

1291
00:49:40,870 --> 00:49:41,880
missed it

1292
00:49:41,880 --> 00:49:43,840
right this is the right skew anomaly

1293
00:49:43,840 --> 00:49:47,560
because I missed it then I have to then

1294
00:49:47,560 --> 00:49:49,990
then you know I have to abort because

1295
00:49:49,990 --> 00:49:51,430
it's something that I should have read

1296
00:49:51,430 --> 00:49:52,750
but I didn't read and I would've violate

1297
00:49:52,750 --> 00:50:21,910
sterilizable ordering okay yes yes yes

1298
00:50:21,910 --> 00:50:25,630
question is this question is what if

1299
00:50:25,630 --> 00:50:28,750
like what if like here this evaluated

1300
00:50:28,750 --> 00:50:31,360
true and then say this is this is going

1301
00:50:31,360 --> 00:50:32,860
forward in time so transaction one zero

1302
00:50:32,860 --> 00:50:34,420
one is older than ones there's are three

1303
00:50:34,420 --> 00:50:37,360
so this evaluates to true but then this

1304
00:50:37,360 --> 00:50:40,750
evaluates to false what should happen in

1305
00:50:40,750 --> 00:50:41,980
that case

1306
00:50:41,980 --> 00:50:44,119
let's go question

1307
00:50:44,119 --> 00:50:46,890
right there's a brief period where it

1308
00:50:46,890 --> 00:50:49,109
was true but the am result would be

1309
00:50:49,109 --> 00:50:56,300
false I think the last writer would win

1310
00:50:56,300 --> 00:50:58,260
yeah I think the last writer would win

1311
00:50:58,260 --> 00:51:00,540
so you you could in theory and this guy

1312
00:51:00,540 --> 00:51:04,520
updated actually won on the same to poll

1313
00:51:06,470 --> 00:51:08,160
would you actually have that information

1314
00:51:08,160 --> 00:51:10,349
though I don't think you would you

1315
00:51:10,349 --> 00:51:14,280
wouldn't know that so this is again this

1316
00:51:14,280 --> 00:51:17,460
is an approximation of a phantom

1317
00:51:17,460 --> 00:51:21,359
checking so false positives are okay

1318
00:51:21,359 --> 00:51:23,369
because we abort when we didn't have two

1319
00:51:23,369 --> 00:51:26,339
false negatives are bad we don't want to

1320
00:51:26,339 --> 00:51:29,670
abort we don't we don't want to not

1321
00:51:29,670 --> 00:51:32,099
abort when we showed up so in that case

1322
00:51:32,099 --> 00:51:33,809
here I think the safe thing to do is

1323
00:51:33,809 --> 00:51:36,119
like even though there is a window where

1324
00:51:36,119 --> 00:51:39,210
like like we're like or after this guy

1325
00:51:39,210 --> 00:51:41,250
then everything will been okay because I

1326
00:51:41,250 --> 00:51:42,329
conflict it at least once

1327
00:51:42,329 --> 00:51:43,740
I'll play it save it and a board

1328
00:51:43,740 --> 00:51:47,040
immediately again it's not predicate

1329
00:51:47,040 --> 00:51:49,799
locking would be an exact measurement or

1330
00:51:49,799 --> 00:51:51,000
determination of whether there was a

1331
00:51:51,000 --> 00:51:53,280
conflict precision locking despite the

1332
00:51:53,280 --> 00:51:55,920
name is a little less precise and is

1333
00:51:55,920 --> 00:51:58,589
it's okay to have false negatives or

1334
00:51:58,589 --> 00:52:02,900
false positives okay

1335
00:52:02,900 --> 00:52:05,040
the other cool thing about hyper that

1336
00:52:05,040 --> 00:52:09,359
they do is these Virgin synopsis so

1337
00:52:09,359 --> 00:52:11,400
again the issue is that under Hecate on

1338
00:52:11,400 --> 00:52:13,109
is that we have these long version

1339
00:52:13,109 --> 00:52:15,299
chains and then as we're scanning along

1340
00:52:15,299 --> 00:52:17,910
we basically have to traverse them all

1341
00:52:17,910 --> 00:52:19,140
the time to figure out to find the right

1342
00:52:19,140 --> 00:52:22,410
version that we actually want so if

1343
00:52:22,410 --> 00:52:24,450
you're doing a TV queries where you're

1344
00:52:24,450 --> 00:52:25,829
doing lookups on single attributes

1345
00:52:25,829 --> 00:52:27,510
through an index and I land at the head

1346
00:52:27,510 --> 00:52:29,970
of verges a mattress that yeah who cares

1347
00:52:29,970 --> 00:52:32,940
because I I just follow a virgin chain I

1348
00:52:32,940 --> 00:52:34,799
find what I want but now if I'm doing

1349
00:52:34,799 --> 00:52:36,270
analytical queries when I basically want

1350
00:52:36,270 --> 00:52:39,960
to do entire table scans I don't want to

1351
00:52:39,960 --> 00:52:41,579
have to go check that virgin vector and

1352
00:52:41,579 --> 00:52:43,829
go follow some JSON pointer over there

1353
00:52:43,829 --> 00:52:45,210
because that's gonna ruin my cache

1354
00:52:45,210 --> 00:52:46,619
locality because I want to be able to

1355
00:52:46,619 --> 00:52:48,240
rip through these columns very

1356
00:52:48,240 --> 00:52:49,980
efficiently that's the whole point of

1357
00:52:49,980 --> 00:52:51,599
having a column store but having these

1358
00:52:51,599 --> 00:52:53,250
pointers causes them you have

1359
00:52:53,250 --> 00:52:55,799
indirection so what they're going to do

1360
00:52:55,799 --> 00:52:57,210
on a per block basis they're going to

1361
00:52:57,210 --> 00:52:57,540
maintain

1362
00:52:57,540 --> 00:52:59,820
Virgen synopsis and this is just gonna

1363
00:52:59,820 --> 00:53:03,450
keep track of what range of the of the

1364
00:53:03,450 --> 00:53:06,030
tuples here if they might block don't

1365
00:53:06,030 --> 00:53:07,980
have a virgin' vector don't have older

1366
00:53:07,980 --> 00:53:10,590
versions that I need to go check so in

1367
00:53:10,590 --> 00:53:12,980
this case here it's between two to five

1368
00:53:12,980 --> 00:53:15,390
inclusive exclusive so way think about

1369
00:53:15,390 --> 00:53:17,490
this these offsets are number from 0 0

1370
00:53:17,490 --> 00:53:20,790
to 6 so this is gonna say between 0 & 5

1371
00:53:20,790 --> 00:53:26,100
so zero inclusive five inclusive that I

1372
00:53:26,100 --> 00:53:27,630
don't need to look at anything else so

1373
00:53:27,630 --> 00:53:29,970
in this case here when I do my scan I

1374
00:53:29,970 --> 00:53:31,800
look at my virgin schnapps it would say

1375
00:53:31,800 --> 00:53:34,680
oh I'm at offset zero offset 1 that does

1376
00:53:34,680 --> 00:53:36,780
not intersect with my virgin synopsis so

1377
00:53:36,780 --> 00:53:38,790
I know I can ignore this thing entirely

1378
00:53:38,790 --> 00:53:41,910
but now for this range here I got to go

1379
00:53:41,910 --> 00:53:43,830
check sometimes there'd be no that's

1380
00:53:43,830 --> 00:53:46,530
fine but as I'm doing the scan I don't

1381
00:53:46,530 --> 00:53:47,880
have to even look at this for these

1382
00:53:47,880 --> 00:53:50,370
other parts here and now I can rip

1383
00:53:50,370 --> 00:53:51,690
through these columns as fast as

1384
00:53:51,690 --> 00:53:53,550
possible you could even do something

1385
00:53:53,550 --> 00:53:56,760
like because sequel or relational

1386
00:53:56,760 --> 00:53:58,770
algebra is unordered I could then maybe

1387
00:53:58,770 --> 00:54:02,160
do fast scan on these two guys and then

1388
00:54:02,160 --> 00:54:03,840
at the end then go check this one I

1389
00:54:03,840 --> 00:54:05,610
don't actually know how that's actually

1390
00:54:05,610 --> 00:54:07,110
implemented you probably don't want to

1391
00:54:07,110 --> 00:54:08,370
do that for a really large columns or

1392
00:54:08,370 --> 00:54:10,710
large blocks because this will be you

1393
00:54:10,710 --> 00:54:13,200
know within you'll have a stride you

1394
00:54:13,200 --> 00:54:15,600
know in in your cache and jump me to

1395
00:54:15,600 --> 00:54:16,830
another part could invalidate your cache

1396
00:54:16,830 --> 00:54:17,940
so it's better off to maybe just rip

1397
00:54:17,940 --> 00:54:20,790
through sequentially so this is sort of

1398
00:54:20,790 --> 00:54:22,710
like a zone map but for the physical

1399
00:54:22,710 --> 00:54:24,000
versions because zone map is a little

1400
00:54:24,000 --> 00:54:25,590
thing of the header of the block says

1401
00:54:25,590 --> 00:54:27,360
you know here's the values that are in

1402
00:54:27,360 --> 00:54:28,740
my block and use that to figure out

1403
00:54:28,740 --> 00:54:29,670
whether you actually need to read it

1404
00:54:29,670 --> 00:54:31,290
this is like a way to say like alright

1405
00:54:31,290 --> 00:54:32,910
here's the here's the versions that you

1406
00:54:32,910 --> 00:54:34,680
may here's the tuples that you know you

1407
00:54:34,680 --> 00:54:36,620
don't the check the versions all right

1408
00:54:36,620 --> 00:54:39,870
the idea is that as data gets cold over

1409
00:54:39,870 --> 00:54:42,210
time you can have progressively larger

1410
00:54:42,210 --> 00:54:43,800
and larger ranges when you don't have

1411
00:54:43,800 --> 00:54:45,660
older versions and that makes your scans

1412
00:54:45,660 --> 00:54:48,330
go faster right under hackaton it's just

1413
00:54:48,330 --> 00:54:50,100
you had no notion of this well it's also

1414
00:54:50,100 --> 00:54:52,530
a penalty but without any notion of this

1415
00:54:52,530 --> 00:54:54,050
do you have to scan through everything

1416
00:54:54,050 --> 00:54:59,490
yes Birju schnapps it was in a block so

1417
00:54:59,490 --> 00:55:00,990
this block has ten twenty four tuples

1418
00:55:00,990 --> 00:55:02,910
and this just saying like here's a range

1419
00:55:02,910 --> 00:55:06,240
where here's I actually don't know where

1420
00:55:06,240 --> 00:55:07,500
you can have more than one I suppose you

1421
00:55:07,500 --> 00:55:09,300
could but here's the range where you you

1422
00:55:09,300 --> 00:55:10,410
have to check the versions anything

1423
00:55:10,410 --> 00:55:11,250
that's not in this range you

1424
00:55:11,250 --> 00:55:19,170
don't yes question why not use the rain

1425
00:55:19,170 --> 00:55:26,420
versus the bitmap yeah

1426
00:55:27,950 --> 00:55:34,320
yeah I mean like yeah especially so

1427
00:55:34,320 --> 00:55:35,490
actually this would be a great project

1428
00:55:35,490 --> 00:55:37,590
for project three tribe maybe the bitmap

1429
00:55:37,590 --> 00:55:38,790
and try this one and see what's once is

1430
00:55:38,790 --> 00:55:40,590
faster and I imagine the larger the

1431
00:55:40,590 --> 00:55:42,120
blocks are the bitmap the more tuples

1432
00:55:42,120 --> 00:55:43,530
you have in a block the bitmap gets

1433
00:55:43,530 --> 00:55:47,880
larger but if doing 1024 that's not a

1434
00:55:47,880 --> 00:55:53,040
larger bitmap you know actually probably

1435
00:55:53,040 --> 00:55:54,300
what you do is just take this and

1436
00:55:54,300 --> 00:55:56,760
convert it to a bitmap and use that for

1437
00:55:56,760 --> 00:55:58,680
the scan and manage just keep it around

1438
00:55:58,680 --> 00:56:00,000
yeah this is something we should explore

1439
00:56:00,000 --> 00:56:06,480
about your you cool project okay all

1440
00:56:06,480 --> 00:56:09,540
right so another system we want to talk

1441
00:56:09,540 --> 00:56:11,970
about now that does that sort of NBCC

1442
00:56:11,970 --> 00:56:13,680
but with a focus on doing transactions

1443
00:56:13,680 --> 00:56:18,690
and analytics is si P Hannam so Hana was

1444
00:56:18,690 --> 00:56:21,060
a it's in every dating system that was

1445
00:56:21,060 --> 00:56:25,410
built by SI p that was meant to be you

1446
00:56:25,410 --> 00:56:27,420
know mostly designed to power their

1447
00:56:27,420 --> 00:56:29,250
their big you know enterprise resource

1448
00:56:29,250 --> 00:56:31,590
whether a RP application writes the

1449
00:56:31,590 --> 00:56:32,700
things that use to keep track like

1450
00:56:32,700 --> 00:56:34,440
payrolls and stuff like that to get off

1451
00:56:34,440 --> 00:56:36,660
Oracle but it is actually a standalone

1452
00:56:36,660 --> 00:56:38,490
data system subject you could use for

1453
00:56:38,490 --> 00:56:40,920
other applications so they're gonna be

1454
00:56:40,920 --> 00:56:43,140
doing time travel storage with newest to

1455
00:56:43,140 --> 00:56:46,170
oldest and like Hecate on their support

1456
00:56:46,170 --> 00:56:47,790
both optimistic and pessimistic i

1457
00:56:47,790 --> 00:56:49,260
actually don't know what you get by

1458
00:56:49,260 --> 00:56:52,260
default I don't know I assume Utley this

1459
00:56:52,260 --> 00:56:56,010
is tunable and so they're gonna have a

1460
00:56:56,010 --> 00:56:57,480
hybrid storage layout then have rows and

1461
00:56:57,480 --> 00:57:00,120
columns and so some versions are gonna

1462
00:57:00,120 --> 00:57:01,740
be in the row store and then some

1463
00:57:01,740 --> 00:57:02,730
versions are gonna be in the column

1464
00:57:02,730 --> 00:57:04,350
store and the idea is that you want to

1465
00:57:04,350 --> 00:57:06,000
have the latest version I'm sorry you

1466
00:57:06,000 --> 00:57:07,710
won't have the oldest version in the

1467
00:57:07,710 --> 00:57:09,330
column store because most your your

1468
00:57:09,330 --> 00:57:10,740
analytical queries can just rip through

1469
00:57:10,740 --> 00:57:14,100
that and then you have the roast or it

1470
00:57:14,100 --> 00:57:15,720
was where you append the new the new and

1471
00:57:15,720 --> 00:57:17,370
the track time travel space you can pen

1472
00:57:17,370 --> 00:57:19,140
them very quickly because there's

1473
00:57:19,140 --> 00:57:21,420
they're just gonna be sort of you know

1474
00:57:21,420 --> 00:57:24,580
deltas you're adding so they

1475
00:57:24,580 --> 00:57:25,870
shuri of hana is actually kind of

1476
00:57:25,870 --> 00:57:27,550
interesting it originally started off as

1477
00:57:27,550 --> 00:57:29,200
this Frankenstein Frankenstein system

1478
00:57:29,200 --> 00:57:30,580
where they bought a bunch of database

1479
00:57:30,580 --> 00:57:32,440
companies mash this thing together and

1480
00:57:32,440 --> 00:57:35,740
called it Hana so this P time was an

1481
00:57:35,740 --> 00:57:37,000
in-memory day system that came out of

1482
00:57:37,000 --> 00:57:41,050
out of South Korea the South Korean for

1483
00:57:41,050 --> 00:57:42,520
whatever reason there's a lot of Awesome

1484
00:57:42,520 --> 00:57:44,770
enemy databases in South Korea alta base

1485
00:57:44,770 --> 00:57:47,800
is another one so they bought these guys

1486
00:57:47,800 --> 00:57:49,660
they had this thing t-rex it was like a

1487
00:57:49,660 --> 00:57:51,340
like a search system and then a maxtv

1488
00:57:51,340 --> 00:57:53,590
was an embedded Rho star system they

1489
00:57:53,590 --> 00:57:55,240
mash these things all together they call

1490
00:57:55,240 --> 00:57:57,190
it Hana turns out that was a

1491
00:57:57,190 --> 00:58:00,010
and then they've since as of last year

1492
00:58:00,010 --> 00:58:01,180
sort of released a new version where

1493
00:58:01,180 --> 00:58:02,260
they've actually rewritten everything to

1494
00:58:02,260 --> 00:58:04,270
be a clean code base I don't know how

1495
00:58:04,270 --> 00:58:05,590
much Appy time is still there but like

1496
00:58:05,590 --> 00:58:08,590
it's it's much better now it's actually

1497
00:58:08,590 --> 00:58:09,190
pretty interesting

1498
00:58:09,190 --> 00:58:11,950
the name Hana doesn't they told me

1499
00:58:11,950 --> 00:58:13,300
doesn't mean anything for large

1500
00:58:13,300 --> 00:58:15,220
corporations name is a big deal like

1501
00:58:15,220 --> 00:58:17,320
they're paranoid of getting sued right

1502
00:58:17,320 --> 00:58:19,660
that's why all the the Intel CPUs the

1503
00:58:19,660 --> 00:58:22,210
Zeon's like KB Lake skylake those are

1504
00:58:22,210 --> 00:58:24,040
actually named at for real lakes and

1505
00:58:24,040 --> 00:58:25,780
they do that because no one can sue them

1506
00:58:25,780 --> 00:58:26,770
and say they stole their name because

1507
00:58:26,770 --> 00:58:28,120
it's like it's a geographical region

1508
00:58:28,120 --> 00:58:30,280
right so I'm making a name like Hana it

1509
00:58:30,280 --> 00:58:31,990
doesn't mean anything that avoids them

1510
00:58:31,990 --> 00:58:33,880
getting you know getting sued I've heard

1511
00:58:33,880 --> 00:58:35,650
that this mean has no planners new

1512
00:58:35,650 --> 00:58:38,110
architecture has no planner is the one

1513
00:58:38,110 --> 00:58:40,120
of the founders of sa P like he's the P

1514
00:58:40,120 --> 00:58:43,690
and s AP but I I don't think that's true

1515
00:58:43,690 --> 00:58:44,650
I think this someone added that

1516
00:58:44,650 --> 00:58:47,800
afterwards okay so let's talk White

1517
00:58:47,800 --> 00:58:48,850
House authority virgin stories so this

1518
00:58:48,850 --> 00:58:49,600
is kind of interesting

1519
00:58:49,600 --> 00:58:51,970
so the oldest virgin it's always giving

1520
00:58:51,970 --> 00:58:53,920
the main data table and that's gonna be

1521
00:58:53,920 --> 00:58:56,200
a column store and then the hub this

1522
00:58:56,200 --> 00:58:58,990
little flag this and say hey there's

1523
00:58:58,990 --> 00:59:00,580
actually there might be a newer version

1524
00:59:00,580 --> 00:59:02,590
in the time travel space that you need

1525
00:59:02,590 --> 00:59:04,060
to go check and see whether that's

1526
00:59:04,060 --> 00:59:05,200
actually the version that you're looking

1527
00:59:05,200 --> 00:59:09,400
for right and so for some queries like

1528
00:59:09,400 --> 00:59:10,960
for analytical queries

1529
00:59:10,960 --> 00:59:12,820
I don't maybe need to run and have the

1530
00:59:12,820 --> 00:59:15,850
exact latest version of of a tuple like

1531
00:59:15,850 --> 00:59:17,530
who cares if I'm trying to compute the

1532
00:59:17,530 --> 00:59:19,960
number of you know open orders that I

1533
00:59:19,960 --> 00:59:21,970
need to go check who cares if I'm 10

1534
00:59:21,970 --> 00:59:25,030
milliseconds behind right so I'll just

1535
00:59:25,030 --> 00:59:26,950
scan through the column store in in the

1536
00:59:26,950 --> 00:59:27,430
main Dave

1537
00:59:27,430 --> 00:59:29,140
tablespace it may not be the newest

1538
00:59:29,140 --> 00:59:30,760
version but that's good enough for my

1539
00:59:30,760 --> 00:59:33,760
query and so now when you land in the

1540
00:59:33,760 --> 00:59:35,920
time travel space they're gonna have a

1541
00:59:35,920 --> 00:59:38,470
hash table to like dual lookup

1542
00:59:38,470 --> 00:59:40,900
find the head of the Virgin chain for a

1543
00:59:40,900 --> 00:59:47,260
particular tuple yes what did I say it's

1544
00:59:47,260 --> 00:59:49,420
all done ooh yeah sorry yes here okay

1545
00:59:49,420 --> 00:59:52,690
all right so every tuple in the main

1546
00:59:52,690 --> 00:59:53,890
data table is gonna have a record ID

1547
00:59:53,890 --> 00:59:55,869
right that's a immutable identifier to

1548
00:59:55,869 --> 00:59:57,609
say that this is this represents a

1549
00:59:57,609 --> 00:59:59,680
logical tuple and then then there's our

1550
00:59:59,680 --> 01:00:01,119
version flag which could just be a

1551
01:00:01,119 --> 01:00:03,550
bitmap that says for each version

1552
01:00:03,550 --> 01:00:06,460
whether there's a newer version that we

1553
01:00:06,460 --> 01:00:08,020
need go check in the time travel space

1554
01:00:08,020 --> 01:00:11,710
right so so if I'm doing a lookup on a1

1555
01:00:11,710 --> 01:00:13,119
I would say all right well this thing

1556
01:00:13,119 --> 01:00:15,300
set to true so now I use my record ID a

1557
01:00:15,300 --> 01:00:17,890
land here and then now I can traverse my

1558
01:00:17,890 --> 01:00:22,869
virgin chain so yeah so it's oldest to

1559
01:00:22,869 --> 01:00:24,790
newest globally and then when you land

1560
01:00:24,790 --> 01:00:26,650
in this hash table here this is also

1561
01:00:26,650 --> 01:00:28,210
older or this is actually newest to

1562
01:00:28,210 --> 01:00:29,230
oldest that's what I was confused about

1563
01:00:29,230 --> 01:00:31,660
so globally its oldest to newest I'm

1564
01:00:31,660 --> 01:00:33,760
look at the oldest version here but then

1565
01:00:33,760 --> 01:00:35,380
if I want to find a newest version I

1566
01:00:35,380 --> 01:00:37,840
land here and then the head of the

1567
01:00:37,840 --> 01:00:40,840
virtual chain is newest please again if

1568
01:00:40,840 --> 01:00:42,760
I'm doing updates I care about mostly in

1569
01:00:42,760 --> 01:00:44,830
validating the latest one this is my

1570
01:00:44,830 --> 01:00:46,420
hash map if I need to go install a new

1571
01:00:46,420 --> 01:00:48,790
version I can do that very efficient all

1572
01:00:48,790 --> 01:00:51,130
right and again I think this

1573
01:00:51,130 --> 01:00:52,570
architecture bore out from the fact that

1574
01:00:52,570 --> 01:00:53,650
they were trying to match these

1575
01:00:53,650 --> 01:00:56,800
different systems together you know this

1576
01:00:56,800 --> 01:00:58,119
could be like the t-rex side and this

1577
01:00:58,119 --> 01:01:02,040
could be like the in memory P times side

1578
01:01:02,040 --> 01:01:05,380
all right so now unlike also in

1579
01:01:05,380 --> 01:01:07,359
hackathon and hyper where we're going to

1580
01:01:07,359 --> 01:01:10,180
keep track of the of the timestamps in

1581
01:01:10,180 --> 01:01:11,920
the in the in the header of every single

1582
01:01:11,920 --> 01:01:14,440
tuple they're actually gonna embed a

1583
01:01:14,440 --> 01:01:18,460
pointer for every tuple to some auxilary

1584
01:01:18,460 --> 01:01:20,770
metadata object and that's gonna have

1585
01:01:20,770 --> 01:01:22,540
all your timestamp information for every

1586
01:01:22,540 --> 01:01:26,700
single tuple and the idea here is that

1587
01:01:26,700 --> 01:01:28,720
we're doing this to reduce storage

1588
01:01:28,720 --> 01:01:30,580
because instead of having this repeated

1589
01:01:30,580 --> 01:01:31,839
timestamp over never again for every

1590
01:01:31,839 --> 01:01:33,910
single update I make to every single

1591
01:01:33,910 --> 01:01:35,460
version I create for a given transaction

1592
01:01:35,460 --> 01:01:38,170
that they all now have a 64-bit pointer

1593
01:01:38,170 --> 01:01:40,810
to some metadata object that has all the

1594
01:01:40,810 --> 01:01:42,150
information they need to know about that

1595
01:01:42,150 --> 01:01:45,430
that that tuple I cut down the amount of

1596
01:01:45,430 --> 01:01:46,869
meta head or space I'm storing for every

1597
01:01:46,869 --> 01:01:48,580
single tuple and now when I need to

1598
01:01:48,580 --> 01:01:49,960
update timestamps like we did in

1599
01:01:49,960 --> 01:01:52,180
hackathon I did go to that one location

1600
01:01:52,180 --> 01:01:54,609
update that one made metadata object and

1601
01:01:54,609 --> 01:01:57,029
that updates all my versions immediately

1602
01:01:57,029 --> 01:01:59,140
against sort of this trade-off between

1603
01:01:59,140 --> 01:02:03,250
the the the slower bees or as faster

1604
01:02:03,250 --> 01:02:04,690
updates or large you know for big

1605
01:02:04,690 --> 01:02:06,490
updates because I can go update a one

1606
01:02:06,490 --> 01:02:07,510
single thing in the updates everything

1607
01:02:07,510 --> 01:02:10,210
all at once right so it looks like this

1608
01:02:10,210 --> 01:02:13,240
so down here in I this transaction

1609
01:02:13,240 --> 01:02:16,630
metadata space and for every single

1610
01:02:16,630 --> 01:02:19,210
transaction I'm a maintain sir for a

1611
01:02:19,210 --> 01:02:20,529
group of tunes actually I'm going to

1612
01:02:20,529 --> 01:02:22,539
keep track of like here's all the things

1613
01:02:22,539 --> 01:02:25,299
that they've been modifying so now when

1614
01:02:25,299 --> 01:02:26,619
my transaction comes along once in an

1615
01:02:26,619 --> 01:02:29,500
updates guy write to C and D these guys

1616
01:02:29,500 --> 01:02:31,180
as I create these new versions now point

1617
01:02:31,180 --> 01:02:33,430
down to this this the single object for

1618
01:02:33,430 --> 01:02:35,470
my from my transaction that says here's

1619
01:02:35,470 --> 01:02:37,119
my current status so I don't have that

1620
01:02:37,119 --> 01:02:39,400
global map I don't really maintain all

1621
01:02:39,400 --> 01:02:40,799
the version information and every single

1622
01:02:40,799 --> 01:02:43,270
tuple I can go down here and figure out

1623
01:02:43,270 --> 01:02:45,069
what you know what am i you know what am

1624
01:02:45,069 --> 01:02:46,089
I actually looking at when I look at a

1625
01:02:46,089 --> 01:02:48,520
version and they have another layer of

1626
01:02:48,520 --> 01:02:50,589
indirection that then combines together

1627
01:02:50,589 --> 01:02:52,569
a bunch of these transaction con taxes

1628
01:02:52,569 --> 01:02:55,390
when it does group commit and adds them

1629
01:02:55,390 --> 01:02:56,289
together into this group of commit

1630
01:02:56,289 --> 01:02:57,549
contacts and then that flushes

1631
01:02:57,549 --> 01:02:59,710
everything out so now if the upper parts

1632
01:02:59,710 --> 01:03:01,869
of the system want to say hey did my

1633
01:03:01,869 --> 01:03:04,299
transaction at ID 3 did that actually

1634
01:03:04,299 --> 01:03:05,829
commit instead of maintaining that

1635
01:03:05,829 --> 01:03:07,359
information for every single transaction

1636
01:03:07,359 --> 01:03:09,220
I could look across all these in this

1637
01:03:09,220 --> 01:03:10,750
group contact and know yes everything

1638
01:03:10,750 --> 01:03:13,960
got flushed out to disk I think this is

1639
01:03:13,960 --> 01:03:15,430
a bit wonky I think this is a bit over

1640
01:03:15,430 --> 01:03:18,520
engineered but I do see why they do this

1641
01:03:18,520 --> 01:03:19,779
if you're doing a large updates which

1642
01:03:19,779 --> 01:03:21,369
I'm sure they're doing in their workload

1643
01:03:21,369 --> 01:03:23,020
or infer therefore their target

1644
01:03:23,020 --> 01:03:25,180
application this approach it wouldn't

1645
01:03:25,180 --> 01:03:26,829
make sense I think there is somebody say

1646
01:03:26,829 --> 01:03:28,660
about like I do like this sort idea that

1647
01:03:28,660 --> 01:03:30,339
you have this global thing to keep track

1648
01:03:30,339 --> 01:03:31,720
of everything so you can do quick

1649
01:03:31,720 --> 01:03:34,660
updates this one I think is I don't see

1650
01:03:34,660 --> 01:03:40,150
the real reason to have this ok hi so

1651
01:03:40,150 --> 01:03:41,109
let's finish up real quickly you talk

1652
01:03:41,109 --> 01:03:42,910
about circuito so let's not with some

1653
01:03:42,910 --> 01:03:44,230
limitations about the approaches we

1654
01:03:44,230 --> 01:03:46,720
talked about so far for the nbcc and

1655
01:03:46,720 --> 01:03:48,190
sort of optimistic and hurt retool and

1656
01:03:48,190 --> 01:03:50,260
then we'll see a system that

1657
01:03:50,260 --> 01:03:52,049
specifically designed to overcome these

1658
01:03:52,049 --> 01:03:55,660
so one is that we've talked about so far

1659
01:03:55,660 --> 01:03:57,250
is that there's this there's this all

1660
01:03:57,250 --> 01:03:59,289
this in direction for because of this

1661
01:03:59,289 --> 01:04:00,670
version chain to be they have to go look

1662
01:04:00,670 --> 01:04:01,660
up all the time to figure out what the

1663
01:04:01,660 --> 01:04:05,650
right version is for us in the case of

1664
01:04:05,650 --> 01:04:06,430
Hana we

1665
01:04:06,430 --> 01:04:08,530
saw right they have this global context

1666
01:04:08,530 --> 01:04:12,099
object hyper try to reduce this by

1667
01:04:12,099 --> 01:04:13,450
having the version synopsis to avoid

1668
01:04:13,450 --> 01:04:15,069
having check the version change but in

1669
01:04:15,069 --> 01:04:16,990
general we have to you know if we're

1670
01:04:16,990 --> 01:04:18,220
updating to post we have to maintain

1671
01:04:18,220 --> 01:04:20,770
these version pointers so we got to now

1672
01:04:20,770 --> 01:04:22,089
do garbage collection to go through and

1673
01:04:22,089 --> 01:04:23,619
try to clean things out so if we don't

1674
01:04:23,619 --> 01:04:25,210
run out of space and it produces the

1675
01:04:25,210 --> 01:04:27,550
size of the Virgin chain that reduces

1676
01:04:27,550 --> 01:04:28,480
the number of things to have to look at

1677
01:04:28,480 --> 01:04:31,869
when we do scans all the other purchase

1678
01:04:31,869 --> 01:04:32,829
most approaches we talked about so far

1679
01:04:32,829 --> 01:04:34,660
are also maintaining a bunch of stuff in

1680
01:04:34,660 --> 01:04:36,490
global memory right there's the global

1681
01:04:36,490 --> 01:04:39,970
map for hackaton for Hyper there's the

1682
01:04:39,970 --> 01:04:42,010
sort of a global space of the blocks of

1683
01:04:42,010 --> 01:04:45,579
tuples and so in this case here because

1684
01:04:45,579 --> 01:04:47,230
we're reading writing to enter any

1685
01:04:47,230 --> 01:04:49,510
address space in memory our threads

1686
01:04:49,510 --> 01:04:52,780
aren't entirely cognizant about where

1687
01:04:52,780 --> 01:04:54,339
the data they're reading is and what

1688
01:04:54,339 --> 01:04:55,990
that where the data is located that

1689
01:04:55,990 --> 01:04:57,579
they're reading writing to and how

1690
01:04:57,579 --> 01:04:58,980
that's gonna affect their cache locality

1691
01:04:58,980 --> 01:05:02,410
so we'll discuss Numa stuff in for the

1692
01:05:02,410 --> 01:05:05,079
detail in the semester but in modern

1693
01:05:05,079 --> 01:05:06,430
architecture if you have multiple CPU

1694
01:05:06,430 --> 01:05:09,790
sockets the the memory access speed for

1695
01:05:09,790 --> 01:05:11,440
you know one memory location mean on one

1696
01:05:11,440 --> 01:05:12,609
sock it may not be the same on another

1697
01:05:12,609 --> 01:05:14,440
socket so if I don't know where my

1698
01:05:14,440 --> 01:05:15,910
memory is actually located I may end up

1699
01:05:15,910 --> 01:05:17,650
reading on another socket and that could

1700
01:05:17,650 --> 01:05:20,319
be really slow and then for all these

1701
01:05:20,319 --> 01:05:21,880
approaches as well we also talked about

1702
01:05:21,880 --> 01:05:24,400
how there there's a single counter to

1703
01:05:24,400 --> 01:05:26,200
you time stamp allocation and that could

1704
01:05:26,200 --> 01:05:28,540
become a bottleneck and really high core

1705
01:05:28,540 --> 01:05:32,109
counts of thread counts so for OCC some

1706
01:05:32,109 --> 01:05:33,040
of the limitations that we talked about

1707
01:05:33,040 --> 01:05:34,720
and these aren't specific to multi

1708
01:05:34,720 --> 01:05:36,280
version this is this is certain general

1709
01:05:36,280 --> 01:05:40,329
for OCC protocols but if there's high

1710
01:05:40,329 --> 01:05:41,740
contention then we're gonna have a lot

1711
01:05:41,740 --> 01:05:43,599
of aborts and we saw that 1,000 core

1712
01:05:43,599 --> 01:05:44,859
paper when we show her everything

1713
01:05:44,859 --> 01:05:47,170
cratered at a thousand cores all the

1714
01:05:47,170 --> 01:05:48,369
time we were spending executing

1715
01:05:48,369 --> 01:05:49,420
transactions were basically just

1716
01:05:49,420 --> 01:05:50,470
aborting them because there was a

1717
01:05:50,470 --> 01:05:53,109
conflict immediately Brett and it had to

1718
01:05:53,109 --> 01:05:54,520
do a metric actually reads and writes if

1719
01:05:54,520 --> 01:05:56,530
we implement the private workspace for

1720
01:05:56,530 --> 01:06:00,970
OCC and this is additional copying in

1721
01:06:00,970 --> 01:06:02,829
memory and that that's that's gonna add

1722
01:06:02,829 --> 01:06:04,270
it's gonna slow us down because that

1723
01:06:04,270 --> 01:06:08,309
sector work and then now when we do

1724
01:06:08,309 --> 01:06:10,299
we'll talk about more this next class

1725
01:06:10,299 --> 01:06:12,990
but in some protocols the way to handle

1726
01:06:12,990 --> 01:06:15,460
updates to indexes before I actually

1727
01:06:15,460 --> 01:06:17,799
commit my transaction is I have to

1728
01:06:17,799 --> 01:06:18,849
install what are called virtual index

1729
01:06:18,849 --> 01:06:19,790
nodes

1730
01:06:19,790 --> 01:06:21,470
basically a placeholder to say like I'm

1731
01:06:21,470 --> 01:06:23,990
gonna start this key into this index I

1732
01:06:23,990 --> 01:06:25,970
don't know exactly what my commit

1733
01:06:25,970 --> 01:06:26,990
timestamp man is yeah because I haven't

1734
01:06:26,990 --> 01:06:28,550
committed yet but this is just a way to

1735
01:06:28,550 --> 01:06:29,570
prevent somebody else when trying to

1736
01:06:29,570 --> 01:06:31,040
start this the same key at the same time

1737
01:06:31,040 --> 01:06:33,859
it's another way to do first writer wins

1738
01:06:33,859 --> 01:06:37,460
but for indexes so Sakina was the engine

1739
01:06:37,460 --> 01:06:40,130
built here at CMU by healing tech limb

1740
01:06:40,130 --> 01:06:41,750
so he was a peachy student of Dave

1741
01:06:41,750 --> 01:06:43,910
Anderson stuck around at a postdoc and

1742
01:06:43,910 --> 01:06:45,890
dabbled in databases end up building

1743
01:06:45,890 --> 01:06:48,020
this system so there's a bunch of

1744
01:06:48,020 --> 01:06:49,670
optimizations that were interesting to

1745
01:06:49,670 --> 01:06:53,540
us that cicada proposed that I want to

1746
01:06:53,540 --> 01:06:56,150
sort of go through will do best effort

1747
01:06:56,150 --> 01:06:56,780
in lining

1748
01:06:56,780 --> 01:06:58,490
Lucey synchronized clock which is we're

1749
01:06:58,490 --> 01:07:00,170
not going to cover too much but

1750
01:07:00,170 --> 01:07:01,640
contention where validation index notes

1751
01:07:01,640 --> 01:07:03,500
so the first one in the second two are

1752
01:07:03,500 --> 01:07:05,060
things that weeks we could consider in

1753
01:07:05,060 --> 01:07:07,100
our own system this one I have not

1754
01:07:07,100 --> 01:07:08,180
thought through more carefully to see

1755
01:07:08,180 --> 01:07:09,560
whether this actually makes sense this

1756
01:07:09,560 --> 01:07:10,940
is actually borrowing techniques from a

1757
01:07:10,940 --> 01:07:12,710
distributed database world which makes

1758
01:07:12,710 --> 01:07:13,940
sense if you're saying if I have a lot

1759
01:07:13,940 --> 01:07:15,740
of cores have a lot of sockets it's

1760
01:07:15,740 --> 01:07:17,300
essentially like a distributed database

1761
01:07:17,300 --> 01:07:19,609
which is on a single machine but I want

1762
01:07:19,609 --> 01:07:21,590
to focus on the you know these three

1763
01:07:21,590 --> 01:07:23,300
because this make more sense before we

1764
01:07:23,300 --> 01:07:26,930
talk about so far so best effort in

1765
01:07:26,930 --> 01:07:28,310
lining the basic idea here is that

1766
01:07:28,310 --> 01:07:30,109
instead of having this version chain

1767
01:07:30,109 --> 01:07:32,930
that could just point to anywhere what

1768
01:07:32,930 --> 01:07:34,780
if I allocate some fixed amount of space

1769
01:07:34,780 --> 01:07:38,330
along with the version pointer and that

1770
01:07:38,330 --> 01:07:39,680
way when I want to do a lookup and say

1771
01:07:39,680 --> 01:07:41,720
what's the latest version well I can

1772
01:07:41,720 --> 01:07:42,710
maybe just go find the latest version

1773
01:07:42,710 --> 01:07:46,190
right here right and so the idea here is

1774
01:07:46,190 --> 01:07:49,150
that as of now I'm scanning along

1775
01:07:49,150 --> 01:07:51,410
instead of jumping followings pointer to

1776
01:07:51,410 --> 01:07:53,960
some other location you know there's a

1777
01:07:53,960 --> 01:07:55,040
small matter space right here that has

1778
01:07:55,040 --> 01:07:57,140
the latest data that I need and mirth of

1779
01:07:57,140 --> 01:07:59,230
the time that will be good enough for me

1780
01:07:59,230 --> 01:08:03,109
right so this one's okay I mean I think

1781
01:08:03,109 --> 01:08:05,030
the the paper shows that this actually

1782
01:08:05,030 --> 01:08:07,310
for sort of old healed workloads this

1783
01:08:07,310 --> 01:08:08,359
makes a big difference but I think this

1784
01:08:08,359 --> 01:08:10,580
is tricky to do when you have variable

1785
01:08:10,580 --> 01:08:11,960
length data because if these are strings

1786
01:08:11,960 --> 01:08:13,520
are different sizes then this is hard to

1787
01:08:13,520 --> 01:08:16,819
do and for analytical queries

1788
01:08:16,819 --> 01:08:18,770
I think the columnstore approach is

1789
01:08:18,770 --> 01:08:21,399
actually is obviously gonna be better

1790
01:08:21,399 --> 01:08:23,180
all right but let's talk about how we

1791
01:08:23,180 --> 01:08:25,460
can do fast validation right so again

1792
01:08:25,460 --> 01:08:29,120
the scan stat approach is well guarantee

1793
01:08:29,120 --> 01:08:31,069
sterilized ability under Hecate on the

1794
01:08:31,069 --> 01:08:32,479
precision locking approach would

1795
01:08:32,479 --> 01:08:33,529
guarantee sterilized body

1796
01:08:33,529 --> 01:08:36,080
Piper for this paper here I think he's

1797
01:08:36,080 --> 01:08:39,229
mostly retorting the the the scan setup

1798
01:08:39,229 --> 01:08:42,109
wrote that used in in hackathon he

1799
01:08:42,109 --> 01:08:43,670
didn't actually evaluate the precision

1800
01:08:43,670 --> 01:08:45,170
locking because I don't think he was

1801
01:08:45,170 --> 01:08:46,670
aware of the paper when he wrote it and

1802
01:08:46,670 --> 01:08:48,620
he wasn't sitting he took targeting MVCC

1803
01:08:48,620 --> 01:08:50,750
systems but it basically has three

1804
01:08:50,750 --> 01:08:52,670
approaches here to kind of speed things

1805
01:08:52,670 --> 01:08:53,120
up

1806
01:08:53,120 --> 01:08:56,210
alright to do validation the first is

1807
01:08:56,210 --> 01:08:58,340
that instead of treating every

1808
01:08:58,340 --> 01:09:00,620
transaction blindly or do validation

1809
01:09:00,620 --> 01:09:03,080
blindly you actually can maintain a

1810
01:09:03,080 --> 01:09:05,000
little information on what happened with

1811
01:09:05,000 --> 01:09:06,560
the last transaction you validated and

1812
01:09:06,560 --> 01:09:09,430
so if you can identify if there are

1813
01:09:09,430 --> 01:09:11,510
records that are highly contended like

1814
01:09:11,510 --> 01:09:12,859
everybody trying to update this one

1815
01:09:12,859 --> 01:09:15,290
tuple instead of having checking that

1816
01:09:15,290 --> 01:09:17,689
maybe at the end or at random I'll check

1817
01:09:17,689 --> 01:09:19,370
that at the very beginning of validation

1818
01:09:19,370 --> 01:09:21,800
and that way if I'm going to abort I

1819
01:09:21,800 --> 01:09:23,149
abort right away without having to check

1820
01:09:23,149 --> 01:09:25,609
everything else so all you basically do

1821
01:09:25,609 --> 01:09:28,100
is keep a counter for like the most

1822
01:09:28,100 --> 01:09:30,319
content of tuples that I keep a boarding

1823
01:09:30,319 --> 01:09:32,720
transactions on so now if I go see if

1824
01:09:32,720 --> 01:09:34,670
that when I do my validation if that

1825
01:09:34,670 --> 01:09:36,859
tuple ever I've read that tuple and that

1826
01:09:36,859 --> 01:09:38,660
that everyone keeps a boarding on all to

1827
01:09:38,660 --> 01:09:40,490
make sure I check that one first and

1828
01:09:40,490 --> 01:09:44,029
that'll boys doing wasted work another

1829
01:09:44,029 --> 01:09:45,470
technique we're gonna do is early

1830
01:09:45,470 --> 01:09:46,760
consistency check and this is actually

1831
01:09:46,760 --> 01:09:48,710
barred from a paper that we wrote after

1832
01:09:48,710 --> 01:09:51,229
the DB X 1000 approach we had another

1833
01:09:51,229 --> 01:09:54,350
protocol code tik-tok and what this one

1834
01:09:54,350 --> 01:09:56,540
is that again just like before if I keep

1835
01:09:56,540 --> 01:09:58,870
track of what things I'm contending on

1836
01:09:58,870 --> 01:10:01,940
in my validation phase if I can then

1837
01:10:01,940 --> 01:10:03,650
push that information up to now actually

1838
01:10:03,650 --> 01:10:06,200
why I'm running the transaction so now

1839
01:10:06,200 --> 01:10:08,120
if I transaction read something that I

1840
01:10:08,120 --> 01:10:10,550
could that I could conflict on instead

1841
01:10:10,550 --> 01:10:11,780
of waiting for validation to go do the

1842
01:10:11,780 --> 01:10:15,080
validation I'll check immediately after

1843
01:10:15,080 --> 01:10:16,250
I do the read or even before I do the

1844
01:10:16,250 --> 01:10:17,570
read to see whether if I read this now

1845
01:10:17,570 --> 01:10:19,820
what I abort and the idea here is

1846
01:10:19,820 --> 01:10:21,680
instead of waiting for the entire

1847
01:10:21,680 --> 01:10:23,270
lifetime of the transaction just to see

1848
01:10:23,270 --> 01:10:26,000
I'm gonna abort and not a bitl finish I

1849
01:10:26,000 --> 01:10:27,920
can do some early checks and avoid all

1850
01:10:27,920 --> 01:10:30,530
that the last one is through incremental

1851
01:10:30,530 --> 01:10:32,890
version search and the idea here is that

1852
01:10:32,890 --> 01:10:35,030
since they're doing newest to oldest if

1853
01:10:35,030 --> 01:10:38,060
I know that I keep reading some older

1854
01:10:38,060 --> 01:10:40,100
version then rather than having to

1855
01:10:40,100 --> 01:10:41,270
follow that very chain I could maintain

1856
01:10:41,270 --> 01:10:45,770
a little memory address in the

1857
01:10:45,770 --> 01:10:48,080
but the master version that says that

1858
01:10:48,080 --> 01:10:49,460
the version you're probably looking for

1859
01:10:49,460 --> 01:10:51,110
is here here's how to go jump into it

1860
01:10:51,110 --> 01:10:53,330
and if I land into a version that it's

1861
01:10:53,330 --> 01:10:55,280
exactly what I wanted I'm done if it's

1862
01:10:55,280 --> 01:10:56,780
not what I want then I just go repeat

1863
01:10:56,780 --> 01:10:59,540
the search as I normally would it's

1864
01:10:59,540 --> 01:11:01,430
taking a little extra memory space and

1865
01:11:01,430 --> 01:11:03,530
to avoid having to do the full version

1866
01:11:03,530 --> 01:11:08,270
change search so for these first two you

1867
01:11:08,270 --> 01:11:10,100
want to skip these if your transactions

1868
01:11:10,100 --> 01:11:12,680
are mostly committing successfully but

1869
01:11:12,680 --> 01:11:14,300
it's only when you have high contention

1870
01:11:14,300 --> 01:11:15,350
what these things actually make sense

1871
01:11:15,350 --> 01:11:17,420
and so it's sort of you sort of need to

1872
01:11:17,420 --> 01:11:18,980
be adaptive and have a way to determine

1873
01:11:18,980 --> 01:11:20,960
oh well I keep a boarding because I have

1874
01:11:20,960 --> 01:11:22,580
conflicts then you switch these things

1875
01:11:22,580 --> 01:11:24,290
on and maybe that can produce reduced

1876
01:11:24,290 --> 01:11:27,110
amount of work good because again OCC we

1877
01:11:27,110 --> 01:11:28,790
only do validation if there's a

1878
01:11:28,790 --> 01:11:30,650
transaction committed so if I'm doing a

1879
01:11:30,650 --> 01:11:33,680
thousand updates and it's the the first

1880
01:11:33,680 --> 01:11:35,180
one is what I'm gonna conflict on and

1881
01:11:35,180 --> 01:11:36,980
that's gonna cause me to abort if I

1882
01:11:36,980 --> 01:11:38,090
don't check to see whether there was an

1883
01:11:38,090 --> 01:11:39,050
abort

1884
01:11:39,050 --> 01:11:40,870
operation until I do the other 999

1885
01:11:40,870 --> 01:11:44,360
updates then that's all wasted work so a

1886
01:11:44,360 --> 01:11:46,160
technic technique like this kind of try

1887
01:11:46,160 --> 01:11:49,460
to avoid all this alright so the other

1888
01:11:49,460 --> 01:11:51,530
interesting thing about cicada that I

1889
01:11:51,530 --> 01:11:53,120
find extremely fascinating this is the

1890
01:11:53,120 --> 01:11:54,890
third year where I say this is something

1891
01:11:54,890 --> 01:11:57,020
we should we should look into and

1892
01:11:57,020 --> 01:11:59,030
hopefully I have a PhD student that's

1893
01:11:59,030 --> 01:12:02,120
gonna start looking to this is instead

1894
01:12:02,120 --> 01:12:04,250
of storing the index nodes for the B+

1895
01:12:04,250 --> 01:12:07,460
tree just in the heap they're actually

1896
01:12:07,460 --> 01:12:09,350
going to store it as tuples themselves

1897
01:12:09,350 --> 01:12:12,740
as blobs in a table and the idea here is

1898
01:12:12,740 --> 01:12:14,930
that instead of having to do the scan

1899
01:12:14,930 --> 01:12:16,100
checks instead of having to do with

1900
01:12:16,100 --> 01:12:18,500
precision locking if the if the index

1901
01:12:18,500 --> 01:12:21,440
nodes are just tuples themselves and I

1902
01:12:21,440 --> 01:12:22,940
can do validation to see whether I'm

1903
01:12:22,940 --> 01:12:24,590
allowed to read something or not doing

1904
01:12:24,590 --> 01:12:26,810
something then I potentially get

1905
01:12:26,810 --> 01:12:28,400
sterilized ability and phantom checks

1906
01:12:28,400 --> 01:12:32,360
for free if everything is a table so

1907
01:12:32,360 --> 01:12:34,100
again normally and you'll see this in

1908
01:12:34,100 --> 01:12:36,470
the the B+ tree you'll build or the BW

1909
01:12:36,470 --> 01:12:38,210
tree that we already have the nodes are

1910
01:12:38,210 --> 01:12:40,550
just sitting out in the heat right but

1911
01:12:40,550 --> 01:12:41,780
instead we're actually stored these now

1912
01:12:41,780 --> 01:12:44,480
as blobs inside of a table like this

1913
01:12:44,480 --> 01:12:45,800
we're just serializing the keys and

1914
01:12:45,800 --> 01:12:47,570
sterilizing the the pointers to the next

1915
01:12:47,570 --> 01:12:50,840
version so now when I do a scam from you

1916
01:12:50,840 --> 01:12:53,600
know to get down to G I'll do my lookup

1917
01:12:53,600 --> 01:12:55,490
an a I basically know how to interpret

1918
01:12:55,490 --> 01:12:56,660
these bytes and that's going to tell me

1919
01:12:56,660 --> 01:12:59,030
oh the thing I you know for the Kievan

1920
01:12:59,030 --> 01:12:59,719
key I'm looking for

1921
01:12:59,719 --> 01:13:03,709
I want to jump into two B or C and then

1922
01:13:03,709 --> 01:13:05,209
I know how to do then do a lookup and

1923
01:13:05,209 --> 01:13:09,409
find the the node that represents C of

1924
01:13:09,409 --> 01:13:11,689
course now the issue is that if I do an

1925
01:13:11,689 --> 01:13:15,679
update for a single key in my in my node

1926
01:13:15,679 --> 01:13:18,619
that's gonna invalidate the this entire

1927
01:13:18,619 --> 01:13:19,519
version because either create a new

1928
01:13:19,519 --> 01:13:21,409
version and that could be a excessive

1929
01:13:21,409 --> 01:13:22,669
copying so I think it's just trade-off

1930
01:13:22,669 --> 01:13:25,189
of like how much churn there is an index

1931
01:13:25,189 --> 01:13:27,260
to how much benefit you're gonna get to

1932
01:13:27,260 --> 01:13:29,449
this but again I think that the paper is

1933
01:13:29,449 --> 01:13:31,070
correct that this will give you

1934
01:13:31,070 --> 01:13:32,869
sterilized body checks for free but I

1935
01:13:32,869 --> 01:13:35,090
don't know this and then he claimed that

1936
01:13:35,090 --> 01:13:37,189
Segel light actually does this so as far

1937
01:13:37,189 --> 01:13:39,320
as I know no buzzes okay no real system

1938
01:13:39,320 --> 01:13:41,269
actually does this I checked with a

1939
01:13:41,269 --> 01:13:43,340
single light guy last night the the

1940
01:13:43,340 --> 01:13:45,409
creator and he told me they don't do

1941
01:13:45,409 --> 01:13:46,999
this for B plus trees but they do it for

1942
01:13:46,999 --> 01:13:49,189
like full table indexes like inverted

1943
01:13:49,189 --> 01:13:51,979
indexes because there's no notion of

1944
01:13:51,979 --> 01:13:53,510
those things at the first class object

1945
01:13:53,510 --> 01:13:55,459
or entity within the database system so

1946
01:13:55,459 --> 01:13:56,869
you store them as blobs and that could

1947
01:13:56,869 --> 01:13:59,090
shoot the stored for free right the B+

1948
01:13:59,090 --> 01:14:01,010
treats are stored separately as you know

1949
01:14:01,010 --> 01:14:03,229
separate pages in the heat again I think

1950
01:14:03,229 --> 01:14:04,340
this is super interesting and this is

1951
01:14:04,340 --> 01:14:06,349
something that if we want to get up we

1952
01:14:06,349 --> 01:14:08,269
want to actually get off the BW tree and

1953
01:14:08,269 --> 01:14:09,709
in our system we might want to pursue

1954
01:14:09,709 --> 01:14:13,039
this but we'll see all right so two

1955
01:14:13,039 --> 01:14:15,739
quick rafts for cicada so this is the

1956
01:14:15,739 --> 01:14:16,699
first workload we're gonna have low

1957
01:14:16,699 --> 01:14:19,249
contention right and they're gonna

1958
01:14:19,249 --> 01:14:20,449
compare against a bunch of different

1959
01:14:20,449 --> 01:14:22,489
systems so two-phase locking is sort of

1960
01:14:22,489 --> 01:14:25,219
standard approach silo is it is a system

1961
01:14:25,219 --> 01:14:26,570
out of Harvard that will talk a little

1962
01:14:26,570 --> 01:14:27,979
bit about later in the semester they

1963
01:14:27,979 --> 01:14:29,209
have a data structure called the mash

1964
01:14:29,209 --> 01:14:30,559
tree which what we'll cover

1965
01:14:30,559 --> 01:14:33,619
tick-tock is the the protocol that I

1966
01:14:33,619 --> 01:14:35,989
helped work on for OCC and then all

1967
01:14:35,989 --> 01:14:37,639
these other ones are sort of variants of

1968
01:14:37,639 --> 01:14:39,949
silos hermia is a better version of silo

1969
01:14:39,949 --> 01:14:41,630
foetus is a better version of silo and

1970
01:14:41,630 --> 01:14:44,900
they have cicada so under low contention

1971
01:14:44,900 --> 01:14:46,760
you see that a Hecate on is actually

1972
01:14:46,760 --> 01:14:49,869
doing the worst here and these sort of

1973
01:14:49,869 --> 01:14:52,459
variants of silo are all doing all about

1974
01:14:52,459 --> 01:14:54,739
the same but when you have high

1975
01:14:54,739 --> 01:14:58,699
contention because cicada has all that

1976
01:14:58,699 --> 01:15:00,469
extra stuff that I talked about like the

1977
01:15:00,469 --> 01:15:02,749
early kisses new check the the jumping

1978
01:15:02,749 --> 01:15:04,849
to the right version that I needed are

1979
01:15:04,849 --> 01:15:06,919
checking on validation to see whether

1980
01:15:06,919 --> 01:15:10,579
you know what's with what what tube or

1981
01:15:10,579 --> 01:15:12,050
my most likely to be oh I have to abort

1982
01:15:12,050 --> 01:15:13,660
on so I make sure I check that first

1983
01:15:13,660 --> 01:15:16,100
because of that that's why they're able

1984
01:15:16,100 --> 01:15:19,070
to do better than these other ones so

1985
01:15:19,070 --> 01:15:21,230
the overall architecture of cicada is

1986
01:15:21,230 --> 01:15:22,220
interesting but it's all those little

1987
01:15:22,220 --> 01:15:24,050
one-off optimizations I think that are

1988
01:15:24,050 --> 01:15:25,730
that are super interesting that are

1989
01:15:25,730 --> 01:15:27,590
worth pursuing as well so this might

1990
01:15:27,590 --> 01:15:29,150
also might be another project resuit so

1991
01:15:29,150 --> 01:15:32,510
in addition to the to the the cicada

1992
01:15:32,510 --> 01:15:34,520
style B+ tree we could also look at

1993
01:15:34,520 --> 01:15:36,200
adding into our own system all these

1994
01:15:36,200 --> 01:15:39,050
early validation checks because we're

1995
01:15:39,050 --> 01:15:42,650
doing the same thing okay I thought I've

1996
01:15:42,650 --> 01:15:43,760
rushed through that last part very

1997
01:15:43,760 --> 01:15:45,290
quickly but the main idea is that just

1998
01:15:45,290 --> 01:15:46,880
showing that like instead of treating

1999
01:15:46,880 --> 01:15:48,590
every transaction you know we're

2000
01:15:48,590 --> 01:15:49,820
learning from scratch whether I'm gonna

2001
01:15:49,820 --> 01:15:50,510
abort or not

2002
01:15:50,510 --> 01:15:52,190
we could maintain some information for

2003
01:15:52,190 --> 01:15:54,140
one transaction the next and make better

2004
01:15:54,140 --> 01:15:58,010
decisions when we do validation all

2005
01:15:58,010 --> 01:16:02,270
right so the the other main takeaway

2006
01:16:02,270 --> 01:16:04,070
once you get from this lecture is that

2007
01:16:04,070 --> 01:16:05,660
there's a bunch of other design

2008
01:16:05,660 --> 01:16:07,160
decisions we talked about that don't

2009
01:16:07,160 --> 01:16:09,650
follow exactly into the forward things

2010
01:16:09,650 --> 01:16:10,580
we talked about last month the last

2011
01:16:10,580 --> 01:16:13,940
class that can affect the performance of

2012
01:16:13,940 --> 01:16:15,470
the system depending on whether you're

2013
01:16:15,470 --> 01:16:16,910
targeting o2b workloads or OLAP

2014
01:16:16,910 --> 01:16:18,980
workloads so like if you're doing long

2015
01:16:18,980 --> 01:16:21,830
scans for OLAP queries then the global

2016
01:16:21,830 --> 01:16:23,300
hash map and the and the virgin chain

2017
01:16:23,300 --> 01:16:24,500
for pen only is probably a bad idea

2018
01:16:24,500 --> 01:16:25,760
under heck atomic

2019
01:16:25,760 --> 01:16:28,310
right but the hyper way is that might be

2020
01:16:28,310 --> 01:16:30,680
better and so there's this classic

2021
01:16:30,680 --> 01:16:32,270
trade-off again between having these

2022
01:16:32,270 --> 01:16:33,770
different interaction layers to maybe

2023
01:16:33,770 --> 01:16:35,900
store stuff off separately or have

2024
01:16:35,900 --> 01:16:37,430
redundant information stored in one

2025
01:16:37,430 --> 01:16:39,350
location to reduce our storage overhead

2026
01:16:39,350 --> 01:16:40,940
but then that could affect performance

2027
01:16:40,940 --> 01:16:42,950
and some systems like Hana they decided

2028
01:16:42,950 --> 01:16:46,010
to make that choice okay all right so

2029
01:16:46,010 --> 01:16:47,420
next class will be the last lecture we

2030
01:16:47,420 --> 01:16:49,430
do on garbage collection so yenna be

2031
01:16:49,430 --> 01:16:51,050
reading another paper from hyper this

2032
01:16:51,050 --> 01:16:53,120
came out in VO to be or just just came

2033
01:16:53,120 --> 01:16:55,760
out less last year on how they do

2034
01:16:55,760 --> 01:16:58,310
garbage collection and then we'll spend

2035
01:16:58,310 --> 01:17:00,530
time at the end doing a sort of demo how

2036
01:17:00,530 --> 01:17:03,050
to do run perf for project number one

2037
01:17:03,050 --> 01:17:06,770
okay any questions bank it in the side

2038
01:17:06,770 --> 01:17:10,060
park what is this

2039
01:17:11,220 --> 01:17:14,070
 ain't dead here called the okay

2040
01:17:14,070 --> 01:17:17,340
cuz i mochi ice cube down with the testy

2041
01:17:17,340 --> 01:17:20,310
hi you look and it was go grab me a

2042
01:17:20,310 --> 01:17:22,830
forty just to get my buzz song cuz i

2043
01:17:22,830 --> 01:17:25,080
needed just a little more kick like a

2044
01:17:25,080 --> 01:17:30,840
fish just once if my lips and just say

2045
01:17:30,840 --> 01:17:33,960
nice and my hood won't be to say i've

2046
01:17:33,960 --> 01:17:38,240
nice to take a say to the prey

