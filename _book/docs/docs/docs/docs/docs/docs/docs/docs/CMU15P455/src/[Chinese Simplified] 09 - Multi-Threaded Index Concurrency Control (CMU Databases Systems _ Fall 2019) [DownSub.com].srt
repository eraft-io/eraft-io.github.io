1
00:00:03,640 --> 00:00:13,140
[音乐]

2
00:00:15,000 --> 00:00:19,869
好吧，伙计们，让我们重新开始吧

3
00:00:19,869 --> 00:00:22,630
谢谢 DJ drop table 总是

4
00:00:22,630 --> 00:00:24,720
保持低调

5
00:00:24,720 --> 00:00:28,140
你的 mixtape 进展得怎么样了哦，

6
00:00:28,140 --> 00:00:31,660
我们会在好的结束时发布它，

7
00:00:31,660 --> 00:00:33,160
这一切就像 DJ drop table

8
00:00:33,160 --> 00:00:33,579
beats

9
00:00:33,579 --> 00:00:35,710
哦什么都没有 你喜欢你自己的

10
00:00:35,710 --> 00:00:41,980
东西好吧，让我们开始

11
00:00:41,980 --> 00:00:43,120
吧，这是美好的一天，我想

12
00:00:43,120 --> 00:00:47,080
这就是为什么这里的投票率如此之低，这很

13
00:00:47,080 --> 00:00:48,940
糟糕，因为我的每场讲座

14
00:00:48,940 --> 00:00:51,150
都在这里举行，但

15
00:00:51,150 --> 00:00:54,790
在我们开始之前我很喜欢这个讲座 进入课程

16
00:00:54,790 --> 00:00:56,470
材料只是为了快速讨论

17
00:00:56,470 --> 00:00:58,900
你们的日程安排

18
00:00:58,900 --> 00:01:02,079
项目一个是本周五午夜到期

19
00:01:02,079 --> 00:01:03,880
，你应该再次

20
00:01:03,880 --> 00:01:06,430
提交大范围作业 2 是在

21
00:01:06,430 --> 00:01:08,770
周一午夜到期，

22
00:01:08,770 --> 00:01:10,840
因此我们将发送 在 Piazza 上发布了一个公告，

23
00:01:10,840 --> 00:01:14,289
但我们已经更新了 PDF，

24
00:01:14,289 --> 00:01:16,030
这样您就可以将图片

25
00:01:16,030 --> 00:01:18,249
直接放入 PDF 中，这样您

26
00:01:18,249 --> 00:01:20,439
就知道了，所以我们为您提供了一个用于绘制 IO 的模板，

27
00:01:20,439 --> 00:01:23,020
因此它是一个可以

28
00:01:23,020 --> 00:01:25,149
快速编辑和修改的在线工具 项目

29
00:01:25,149 --> 00:01:25,899
为您提供答案的板块，

30
00:01:25,899 --> 00:01:27,639
所以我们应该知道手写图纸

31
00:01:27,639 --> 00:01:29,109
而不是类似图纸的照片，

32
00:01:29,109 --> 00:01:30,819
一切都应该以数字方式完成，

33
00:01:30,819 --> 00:01:34,149
然后我们也将在本周一发布第二个项目

34
00:01:34,149 --> 00:01:36,219
，我会

35
00:01:36,219 --> 00:01:39,810
在 10 月考虑两到三个星期

36
00:01:39,810 --> 00:01:41,829
好的，关于

37
00:01:41,829 --> 00:01:49,119
项目或作业的任何高级问题 - 好的，让我们

38
00:01:49,119 --> 00:01:53,139
开始吧，所以我们现在需要讨论的事情

39
00:01:53,139 --> 00:01:54,700
是，我们花了最后三

40
00:01:54,700 --> 00:01:56,170
节课讨论数据结构，

41
00:01:56,170 --> 00:01:58,270
我们将花费在哈希表上并花

42
00:01:58,270 --> 00:02:01,209
了两天时间 在 B 加树基数树和

43
00:02:01,209 --> 00:02:03,459
其他树数据结构上，所以

44
00:02:03,459 --> 00:02:04,779
在整个对话中的大部分时间，

45
00:02:04,779 --> 00:02:06,909
当我们谈论这些

46
00:02:06,909 --> 00:02:09,940
数据结构时，我们

47
00:02:09,940 --> 00:02:12,400
假设它们只能被单个线程访问，

48
00:02:12,400 --> 00:02:14,530
但只有一个

49
00:02:14,530 --> 00:02:15,730
线程可以 可以一次读取和写入

50
00:02:15,730 --> 00:02:17,590
数据到数据结构，

51
00:02:17,590 --> 00:02:19,570
这简化了

52
00:02:19,570 --> 00:02:20,890
讨论的这一部分，因此您只需

53
00:02:20,890 --> 00:02:22,450
了解这些数据结构如何工作的核心本质，

54
00:02:22,450 --> 00:02:25,000
但是 在实际

55
00:02:25,000 --> 00:02:27,220
系统中，我们显然不想

56
00:02:27,220 --> 00:02:29,260
只有一个线程，因为您知道一次只能

57
00:02:29,260 --> 00:02:30,640
访问数据结构，

58
00:02:30,640 --> 00:02:33,100
我们将允许多个线程，

59
00:02:33,100 --> 00:02:35,260
因为现代 CPU 有很多 CPU 内核

60
00:02:35,260 --> 00:02:37,000
，因此我们可以运行多个

61
00:02:37,000 --> 00:02:38,590
线程 查询和所有更新

62
00:02:38,590 --> 00:02:40,780
我们的数据结构，但也不允许

63
00:02:40,780 --> 00:02:43,360
由于您知道的高磁盘

64
00:02:43,360 --> 00:02:44,950
停顿或由于必须

65
00:02:44,950 --> 00:02:47,470
从磁盘读取内容而停顿，因为现在如果一个

66
00:02:47,470 --> 00:02:49,270
线程正在做某事并且它读取的

67
00:02:49,270 --> 00:02:51,340
页面不在 内存必须

68
00:02:51,340 --> 00:02:52,420
在缓冲池管理器

69
00:02:52,420 --> 00:02:54,250
引入时停止，然后我们可以让其他

70
00:02:54,250 --> 00:02:56,730
线程同时运行，所以

71
00:02:56,730 --> 00:02:58,750
我们的系统中有很多线程在运行

72
00:02:58,750 --> 00:03:00,459
，我们这样做是因为这可以

73
00:03:00,459 --> 00:03:02,500
最大化并行性或最大化 这

74
00:03:02,500 --> 00:03:04,870
减少了您想要执行的查询的延迟，

75
00:03:04,870 --> 00:03:07,239
所以今天我们现在

76
00:03:07,239 --> 00:03:08,410
谈论的是现在我们带回

77
00:03:08,410 --> 00:03:10,120
多个线程并想要更新和

78
00:03:10,120 --> 00:03:12,280
访问我们的数据结构我们

79
00:03:12,280 --> 00:03:14,410
需要做什么来保护我们的 精灵所以让我们

80
00:03:14,410 --> 00:03:16,120
说它是一个快速的旁白

81
00:03:16,120 --> 00:03:18,160
所以我们今天要讨论的一切都是

82
00:03:18,160 --> 00:03:20,440
大多数数据库系统实际上是如何工作的大多数

83
00:03:20,440 --> 00:03:21,580
支持多

84
00:03:21,580 --> 00:03:23,620
线程的数据库系统将做我们

85
00:03:23,620 --> 00:03:25,390
今天谈论的事情做这些闩锁的

86
00:03:25,390 --> 00:03:27,430
东西有 一些特定的

87
00:03:27,430 --> 00:03:30,250
系统实际上不执行任何这些操作，

88
00:03:30,250 --> 00:03:31,780
只有 owl 单线程必须

89
00:03:31,780 --> 00:03:33,070
访问数据结构，并且它们

90
00:03:33,070 --> 00:03:34,840
仍然获得了非常好的性能，因此

91
00:03:34,840 --> 00:03:37,120
volte B 和 Redis 应用了两个不法分子的

92
00:03:37,120 --> 00:03:39,220
一组下降，以防 Redis Redis

93
00:03:39,220 --> 00:03:41,170
只运行 在一个线程中，它

94
00:03:41,170 --> 00:03:42,970
是两个数据库中的单线程引擎，它是一个

95
00:03:42,970 --> 00:03:44,920
多线程引擎，但它们

96
00:03:44,920 --> 00:03:47,230
以这样一种方式对数据库进行分区，即每个 B+

97
00:03:47,230 --> 00:03:48,700
树只能由一个线程访问，

98
00:03:48,700 --> 00:03:50,950
因此您

99
00:03:50,950 --> 00:03:52,660
可以避免我们今天讨论的所有这些闩锁问题 并且您

100
00:03:52,660 --> 00:03:53,920
获得了非常出色的性能，但

101
00:03:53,920 --> 00:03:55,680
显然这意味着它会使

102
00:03:55,680 --> 00:03:58,120
扩展到多核或多台

103
00:03:58,120 --> 00:04:00,160
机器变得复杂，但我们将再次讨论我稍后将

104
00:04:00,160 --> 00:04:02,799
讨论这些事情 在这个

105
00:04:02,799 --> 00:04:04,930
学期，但现在的主要想法是

106
00:04:04,930 --> 00:04:06,190
每个人都在做

107
00:04:06,190 --> 00:04:09,430
我们正在谈论的事情，所以

108
00:04:09,430 --> 00:04:10,750
我们保护数据

109
00:04:10,750 --> 00:04:12,970
结构的方式是通过控制

110
00:04:12,970 --> 00:04:15,760
协议和控制方案，这

111
00:04:15,760 --> 00:04:18,180
只是方法 其中数据库系统

112
00:04:18,180 --> 00:04:21,640


113
00:04:21,640 --> 00:04:23,740
通过强制所有

114
00:04:23,740 --> 00:04:25,300
线程访问数据结构

115
00:04:25,300 --> 00:04:27,160
并使用某种协议或

116
00:04:27,160 --> 00:04:30,130
某种方式来保证数据结构的正确性，所以我将

117
00:04:30,130 --> 00:04:32,620
正确的词放在引号中，因为这可能

118
00:04:32,620 --> 00:04:34,420
意味着 关于意味着不同

119
00:04:34,420 --> 00:04:35,620
的事物以及他们正在访问的事物类型，

120
00:04:35,620 --> 00:04:36,880
尽管我们

121
00:04:36,880 --> 00:04:38,500
一直专注于数据结构，但它

122
00:04:38,500 --> 00:04:39,850
确实可能适用

123
00:04:39,850 --> 00:04:41,650
于系统中的任何加糖共享对象，它可能

124
00:04:41,650 --> 00:04:43,330
适用于两个极点可能适用于一个 索引可能

125
00:04:43,330 --> 00:04:45,730
是针对页表的，在缓冲

126
00:04:45,730 --> 00:04:49,510
池中没有关系，所以

127
00:04:49,510 --> 00:04:51,430
我们在收敛孔中关心的两种正确性

128
00:04:51,430 --> 00:04:53,440
是逻辑正确性和

129
00:04:53,440 --> 00:04:56,110
物理正确性，所以逻辑

130
00:04:56,110 --> 00:04:57,430
正确性 s 就像一个高级的

131
00:04:57,430 --> 00:05:00,250
东西，它说如果我正在访问

132
00:05:00,250 --> 00:05:02,950
数据结构，我是看到值还是

133
00:05:02,950 --> 00:05:04,660
看到我期望看到的东西，

134
00:05:04,660 --> 00:05:07,960
所以如果我有一个 B+ 树索引，我

135
00:05:07,960 --> 00:05:10,240
插入键 5 我的线程

136
00:05:10,240 --> 00:05:11,770
线程返回并立即读取关键

137
00:05:11,770 --> 00:05:13,780
5 它应该在我

138
00:05:13,780 --> 00:05:15,430
不应该得到的地方看到它不应该得到假

139
00:05:15,430 --> 00:05:17,140
阴性但这是合乎逻辑的

140
00:05:17,140 --> 00:05:18,400
正确性我正在

141
00:05:18,400 --> 00:05:21,160
看到我希望看到的东西

142
00:05:21,160 --> 00:05:22,540
会关心这个类

143
00:05:22,540 --> 00:05:25,090
是物理正确性，但是我们如何

144
00:05:25,090 --> 00:05:27,370
保护

145
00:05:27,370 --> 00:05:28,960
数据结构的内部表示，它如何维护

146
00:05:28,960 --> 00:05:30,910
对其他页面

147
00:05:30,910 --> 00:05:33,400
和键和值的指针和引用，我们如何

148
00:05:33,400 --> 00:05:35,320
确保当线程正在读取写入这些

149
00:05:35,320 --> 00:05:37,810
数据时，完整性 数据

150
00:05:37,810 --> 00:05:40,900
结构是合理的，所以我们

151
00:05:40,900 --> 00:05:42,460
不希望出现这样的情况：我们

152
00:05:42,460 --> 00:05:44,320
跌倒遍历 B+ 树，

153
00:05:44,320 --> 00:05:46,330
当我们跳转到下一个节点时，我们有一个指向该节点的

154
00:05:46,330 --> 00:05:48,190
指针，然后在我们

155
00:05:48,190 --> 00:05:49,660
阅读时 指针算出来 我们

156
00:05:49,660 --> 00:05:51,190
需要去的地方然后尝试跳到

157
00:05:51,190 --> 00:05:53,020
那里其他人很好地修改了数据

158
00:05:53,020 --> 00:05:54,760
结构现在指针

159
00:05:54,760 --> 00:05:58,170
指向一个无效的内存

160
00:05:58,170 --> 00:06:01,600
位置我们会得到一个段错误所以这

161
00:06:01,600 --> 00:06:02,530
就是我们今天要做的 重新

162
00:06:02,530 --> 00:06:03,760
尝试保护内部数据

163
00:06:03,760 --> 00:06:05,170
结构以允许多个线程对其进行读取

164
00:06:05,170 --> 00:06:07,870
和写入，并且他们仍然

165
00:06:07,870 --> 00:06:10,060
认为数据结构

166
00:06:10,060 --> 00:06:12,430
在逻辑正确性方面表现正确，

167
00:06:12,430 --> 00:06:13,930
当我们谈论事务和当前到达时，我们会更担心这

168
00:06:13,930 --> 00:06:16,000


169
00:06:16,000 --> 00:06:17,440
一点 这是另一个引擎

170
00:06:17,440 --> 00:06:19,180
非常有趣的话题，但今天我们

171
00:06:19,180 --> 00:06:20,730
说你很高兴确保

172
00:06:20,730 --> 00:06:24,700
数据结构是线程安全的，所以我们将

173
00:06:24,700 --> 00:06:26,500
首先讨论什么

174
00:06:26,500 --> 00:06:27,700
是闩锁，它们比我们更详细一些

175
00:06:27,700 --> 00:06:29,560
到目前为止讨论了

176
00:06:29,560 --> 00:06:31,450
它是如何实际实现的，然后我们将从

177
00:06:31,450 --> 00:06:32,890
一个简单的例子开始，实际

178
00:06:32,890 --> 00:06:35,860
使用锁存器来做线程安全的哈希表

179
00:06:35,860 --> 00:06:37,900
，因为它们

180
00:06:37,900 --> 00:06:39,790
实际上很容易做，但是 然后

181
00:06:39,790 --> 00:06:41,020
我们将花大部分时间讨论

182
00:06:41,020 --> 00:06:43,270
如何处理 sin B 和树，以及

183
00:06:43,270 --> 00:06:44,980


184
00:06:44,980 --> 00:06:46,570
当我们有

185
00:06:46,570 --> 00:06:48,040
多个线程同时访问

186
00:06:48,040 --> 00:06:52,120
事物时如何再次进行叶节点扫描和其他优化

187
00:06:52,120 --> 00:06:55,150
不要以为

188
00:06:55,150 --> 00:06:56,920
你认识的每个人我们都只谈过

189
00:06:56,920 --> 00:06:58,120
很简短，我不认为每个人都

190
00:06:58,120 --> 00:06:59,260
专注于此我想花更多

191
00:06:59,260 --> 00:07:00,850
时间谈论

192
00:07:00,850 --> 00:07:04,120
锁和闩锁之间的区别，所以在

193
00:07:04,120 --> 00:07:08,800
我居住的数据库世界中，锁

194
00:07:08,800 --> 00:07:11,560
更高 保护

195
00:07:11,560 --> 00:07:14,650
数据库逻辑内容的级别概念，因此

196
00:07:14,650 --> 00:07:16,960
逻辑内容就像一个元组或

197
00:07:16,960 --> 00:07:19,540
一组元组或一个数据库表

198
00:07:19,540 --> 00:07:22,450
，我们正在使用这些锁来

199
00:07:22,450 --> 00:07:25,210
保护这些逻辑对象免受

200
00:07:25,210 --> 00:07:26,710
正在运行的其他事务的影响

201
00:07:26,710 --> 00:07:29,140
同时，如果我正在修改

202
00:07:29,140 --> 00:07:32,110
事务中的某些内容，因此我

203
00:07:32,110 --> 00:07:33,580
不希望其他人同时修改

204
00:07:33,580 --> 00:07:34,930
该元组，因为我是

205
00:07:34,930 --> 00:07:37,720
对的，您可能出于其他原因，但出于

206
00:07:37,720 --> 00:07:39,910
我们的目的，假设您 我们不希望

207
00:07:39,910 --> 00:07:42,370
这种情况发生，所以对于这些锁，我们将

208
00:07:42,370 --> 00:07:44,950
在整个事务期间再次持有它们，

209
00:07:44,950 --> 00:07:46,570
这并不

210
00:07:46,570 --> 00:07:48,130
完全正确，但同样出于我们的

211
00:07:48,130 --> 00:07:50,500
目的，假设情况确实如此，然后我们

212
00:07:50,500 --> 00:07:52,180
需要能够滚动

213
00:07:52,180 --> 00:07:55,300


214
00:07:55,300 --> 00:07:57,760
如果我们为它们持有锁，则返回我们对我们修改的对象所做的任何更改，所以如果我

215
00:07:57,760 --> 00:07:59,020
试图将钱从我的帐户转移

216
00:07:59,020 --> 00:08:01,420
到她的帐户，如果我从

217
00:08:01,420 --> 00:08:04,600
我的帐户中取出钱，然后在我投入之前崩溃

218
00:08:04,600 --> 00:08:05,860
当我回来时她帐户中的钱

219
00:08:05,860 --> 00:08:07,360
我想撤销我

220
00:08:07,360 --> 00:08:10,360
对我的元组所做的更改所以这些

221
00:08:10,360 --> 00:08:11,650
意味着日常系统

222
00:08:11,650 --> 00:08:12,880
负责知道如何回滚这些

223
00:08:12,880 --> 00:08:15,460
更改所以请注意这里我没有说

224
00:08:15,460 --> 00:08:17,530
任何关于 线程，或者我在谈论我的

225
00:08:17,530 --> 00:08:20,320
事务，因此单个事务

226
00:08:20,320 --> 00:08:22,540
可能会被多个线程破坏，

227
00:08:22,540 --> 00:08:24,670
并且它们都可以

228
00:08:24,670 --> 00:08:27,100
更新相同的元组，这是

229
00:08:27,100 --> 00:08:28,660
允许的，因为事务

230
00:08:28,660 --> 00:08:29,800
持有锁

231
00:08:29,800 --> 00:08:30,850
，实际上在执行哪个线程并不重要 g

232
00:08:30,850 --> 00:08:33,849
在我们深入

233
00:08:33,849 --> 00:08:35,309
到我们关心

234
00:08:35,309 --> 00:08:37,960
保护物理

235
00:08:37,960 --> 00:08:39,940
数据结构的物理完整性或对象的物理完整性的低级构造的修改中，

236
00:08:39,940 --> 00:08:43,179
因此在

237
00:08:43,179 --> 00:08:45,280
操作系统世界中，这就是他们所谓

238
00:08:45,280 --> 00:08:47,650
的互斥锁在我们的世界中有

239
00:08:47,650 --> 00:08:48,820
闩锁，因为我们需要将

240
00:08:48,820 --> 00:08:51,640
它们与锁区分开来，因此闩锁将

241
00:08:51,640 --> 00:08:52,810
保护

242
00:08:52,810 --> 00:08:53,860
数据库系统内部数据

243
00:08:53,860 --> 00:08:55,960
结构的关键部分免受其他线程同时

244
00:08:55,960 --> 00:08:57,250
读取该数据结构

245
00:08:57,250 --> 00:09:00,760
或该对象的影响，因此我们

246
00:09:00,760 --> 00:09:01,600
只是孔

247
00:09:01,600 --> 00:09:03,459
闩锁

248
00:09:03,459 --> 00:09:04,750
只是在关键

249
00:09:04,750 --> 00:09:06,730
部分的短时间内执行我们需要做的任何操作

250
00:09:06,730 --> 00:09:08,920
我想更新一个页面我

251
00:09:08,920 --> 00:09:10,389
在该页面上保持闩锁进行

252
00:09:10,389 --> 00:09:13,959
更改然后释放我们不需要的闩锁

253
00:09:13,959 --> 00:09:15,279
能够回滚

254
00:09:15,279 --> 00:09:18,550
这里的任何更改，因为

255
00:09:18,550 --> 00:09:19,569
我们正在尝试做的操作的相反

256
00:09:19,569 --> 00:09:21,759
本质上是原子的，所以我希望

257
00:09:21,759 --> 00:09:23,170
我从我所做的事情中抓住了一个闩锁

258
00:09:23,170 --> 00:09:25,630
每次我想要更改，

259
00:09:25,630 --> 00:09:28,480
然后当我释放闩锁时，

260
00:09:28,480 --> 00:09:30,160
操作被认为已完成，因此

261
00:09:30,160 --> 00:09:32,769
如果我无法获取闩锁，所有更改都在那里，

262
00:09:32,769 --> 00:09:34,329
那么无论如何我都不会执行该

263
00:09:34,329 --> 00:09:35,529
操作，因此没有什么可以

264
00:09:35,529 --> 00:09:39,970
回滚，所以另一种方式 想想

265
00:09:39,970 --> 00:09:43,000
这是一张很棒的表格，来自

266
00:09:43,000 --> 00:09:44,920
我在几堂课前从 Gert scrappy 推荐的 B+ tree book

267
00:09:44,920 --> 00:09:46,899


268
00:09:46,899 --> 00:09:48,160


269
00:09:48,160 --> 00:09:51,040


270
00:09:51,040 --> 00:09:52,750


271
00:09:52,750 --> 00:09:54,850
彼此之间，他们

272
00:09:54,850 --> 00:09:56,920
将保护坐浴盆内容

273
00:09:56,920 --> 00:09:59,680
元组表之类的东西，我们将

274
00:09:59,680 --> 00:10:00,730
在整个交易期间持有它们 会有

275
00:10:00,730 --> 00:10:02,589


276
00:10:02,589 --> 00:10:04,240
一堆不同的锁类型，我们

277
00:10:04,240 --> 00:10:04,690
可以帮助

278
00:10:04,690 --> 00:10:06,970
再次持有这些对象我们 将

279
00:10:06,970 --> 00:10:10,089
在更多讲座中介绍这一点，然后

280
00:10:10,089 --> 00:10:11,470
当需要实际

281
00:10:11,470 --> 00:10:12,220
处理死锁时，

282
00:10:12,220 --> 00:10:14,730
我们将依靠一些外部

283
00:10:14,730 --> 00:10:17,139
协调器、锁管理器或

284
00:10:17,139 --> 00:10:20,050
事务管理器来解决任何无用的问题

285
00:10:20,050 --> 00:10:22,480
可能发生的锁以及

286
00:10:22,480 --> 00:10:24,279
我们可以使用的方法是等待超时

287
00:10:24,279 --> 00:10:25,720
子或其他一些事情，我们稍后将

288
00:10:25,720 --> 00:10:27,550
关注这些我们关心

289
00:10:27,550 --> 00:10:30,100
的在这里我们有这些闩锁，

290
00:10:30,100 --> 00:10:31,180
它们将保护线程

291
00:10:31,180 --> 00:10:34,199
彼此 我们的内存数据结构

292
00:10:34,199 --> 00:10:35,980
我们将保护

293
00:10:35,980 --> 00:10:37,149
这些数据结构

294
00:10:37,149 --> 00:10:38,980
中的关键部分 只有两种锁定模式

295
00:10:38,980 --> 00:10:42,220
读取和写入 我们

296
00:10:42,220 --> 00:10:44,589
将避免死锁的方法是我们成为

297
00:10:44,589 --> 00:10:47,560
优秀的程序员

298
00:10:47,560 --> 00:10:50,019
数据库好等于昂贵，

299
00:10:50,019 --> 00:10:51,550
所以我们要确保

300
00:10:51,550 --> 00:10:53,319
在我们的数据结构中编写高质量的代码

301
00:10:53,319 --> 00:10:55,269
以避免死锁，因为

302
00:10:55,269 --> 00:10:57,250


303
00:10:57,250 --> 00:10:58,750


304
00:10:58,750 --> 00:11:00,430
如果我们遇到死锁，没有像事务管理器或锁管理器这样的外部事物来拯救我们

305
00:11:00,430 --> 00:11:03,850
我们以一种不会发生死锁的方式来设计和

306
00:11:03,850 --> 00:11:05,079
实现我们的数据结构，

307
00:11:05,079 --> 00:11:08,290


308
00:11:08,290 --> 00:11:09,480
我们稍后会看到它的样子，

309
00:11:09,480 --> 00:11:12,670
所以我们的重点再次集中在这里，我们将

310
00:11:12,670 --> 00:11:15,340
讨论所有这些锁的东西 在

311
00:11:15,340 --> 00:11:19,420
期中考试后的第 7 课中，我再次找到了所有

312
00:11:19,420 --> 00:11:20,650
超级合格的人，但这是这样的，

313
00:11:20,650 --> 00:11:23,680
就像是这样，但是

314
00:11:23,680 --> 00:11:25,540
数据库系统的黑魔法，如果你知道的话，你真的可以

315
00:11:25,540 --> 00:11:28,300
让这些东西正常工作，

316
00:11:28,300 --> 00:11:29,080
那么让我们来谈谈 锁存

317
00:11:29,080 --> 00:11:32,230
模式适用于我们可以再次

318
00:11:32,230 --> 00:11:34,630
只有两种模式读和写

319
00:11:34,630 --> 00:11:36,940
所以锁存器被保持在读

320
00:11:36,940 --> 00:11:39,910
模式然后允许多个线程

321
00:11:39,910 --> 00:11:42,940
正确共享该读锁存器因为

322
00:11:42,940 --> 00:11:44,680
它再次是只读操作所以我

323
00:11:44,680 --> 00:11:45,970
可以有 多个线程同时读取数据

324
00:11:45,970 --> 00:11:48,070
结构 没有

325
00:11:48,070 --> 00:11:49,810
冲突 没有

326
00:11:49,810 --> 00:11:51,820
可能发生的完整性问题，因此它们都可以共享

327
00:11:51,820 --> 00:11:54,670
共享，如果我取消闩锁和

328
00:11:54,670 --> 00:11:57,460
写入模式，那么我只能这是一个

329
00:11:57,460 --> 00:11:59,320
独占闩锁 只有一个线程可以持有

330
00:11:59,320 --> 00:12:01,780
那个 一次锁定在该模式中，所以如果

331
00:12:01,780 --> 00:12:03,610
我正确地锁定它，我将进行更改

332
00:12:03,610 --> 00:12:05,680


333
00:12:05,680 --> 00:12:10,030
在我完全完成之前，没有其他人可以读取我正在保护的那个对象

334
00:12:10,030 --> 00:12:11,980
我们关心的唯一两种模式

335
00:12:11,980 --> 00:12:13,330
再次想到这就像 m 多种威胁，

336
00:12:13,330 --> 00:12:15,160
我们分享这个 这是一个

337
00:12:15,160 --> 00:12:18,400
专有的闩锁，好吧，让我们

338
00:12:18,400 --> 00:12:20,290
实际谈谈如何在盲文系统中实现闩锁，

339
00:12:20,290 --> 00:12:22,570
因此第一种方法是

340
00:12:22,570 --> 00:12:25,690
PI，您最熟悉的方法，

341
00:12:25,690 --> 00:12:26,890
当您采取任何一种方式时 系统

342
00:12:26,890 --> 00:12:28,900
课程或操作系统课程是一个

343
00:12:28,900 --> 00:12:30,370
阻塞操作系统互斥锁和

344
00:12:30,370 --> 00:12:32,740
阻塞操作系统互斥锁，所以这是

345
00:12:32,740 --> 00:12:34,510
最简单的使用方法，因为它就像

346
00:12:34,510 --> 00:12:35,980


347
00:12:35,980 --> 00:12:38,140
在 C++ 中一样内置于语言中，标准模板库有

348
00:12:38,140 --> 00:12:40,330
这个东西 STD 互斥锁，它真的很

349
00:12:40,330 --> 00:12:42,130
简单 使用你只需声明它然后

350
00:12:42,130 --> 00:12:43,720
你调用 lock

351
00:12:43,720 --> 00:12:45,430
在你用它保护的对象上做你知道的事情

352
00:12:45,430 --> 00:12:47,290
然后你调用 unlock 并且

353
00:12:47,290 --> 00:12:52,690
你做对了所以有人

354
00:12:52,690 --> 00:12:54,010
知道这至少在操作系统中是如何工作的

355
00:12:54,010 --> 00:12:55,990
一些 Linux

356
00:12:55,990 --> 00:12:57,940
像这样的互斥锁是如何工作的 是的，

357
00:12:57,940 --> 00:13:01,470
他说的文本很少 什么是一些文本

358
00:13:01,470 --> 00:13:07,630
他说得好 所以他说的

359
00:13:07,630 --> 00:13:09,580
文本很少 他在 Linux 中是正确的 很少有技术

360
00:13:09,580 --> 00:13:12,460
代表像我这样的快速用户空间互斥锁

361
00:13:12,460 --> 00:13:14,620
t 的工作是在用户

362
00:13:14,620 --> 00:13:16,180
空间中意味着在您的进程的地址空间中

363
00:13:16,180 --> 00:13:17,740
会有一个内存

364
00:13:17,740 --> 00:13:20,860
位置，您知道它

365
00:13:20,860 --> 00:13:23,350
通常是一个字节左右，但我将有一个

366
00:13:23,350 --> 00:13:25,510
内存位置，然后您可以 尝试

367
00:13:25,510 --> 00:13:28,060
进行比较并交换以获取

368
00:13:28,060 --> 00:13:28,990
该

369
00:13:28,990 --> 00:13:31,420
锁存器，但是如果您

370
00:13:31,420 --> 00:13:33,730
没有获取它，那么您会退回

371
00:13:33,730 --> 00:13:36,339
到较慢的默认互斥锁，

372
00:13:36,339 --> 00:13:38,290
然后进入操作系统，因此

373
00:13:38,290 --> 00:13:40,480
您的想法是 快速比较和

374
00:13:40,480 --> 00:13:41,860
交换，在用户空间，

375
00:13:41,860 --> 00:13:43,540
如果你获得它，你就完成了，如果你

376
00:13:43,540 --> 00:13:44,860
没有获得它，那么你会下降到

377
00:13:44,860 --> 00:13:45,430
vos

378
00:13:45,430 --> 00:13:47,529
，这会更慢，因为

379
00:13:47,529 --> 00:13:50,110
如果你下降 vos 并坐在

380
00:13:50,110 --> 00:13:52,720
内部的互斥锁上会发生什么 内核然后是

381
00:13:52,720 --> 00:13:55,029
OSS 啊哈，我知道你在这个互斥锁上被阻塞了

382
00:13:55,029 --> 00:13:56,950
，你不能得到它，所以让

383
00:13:56,950 --> 00:13:58,899
我告诉调度程序到 D 调度，这样

384
00:13:58,899 --> 00:14:01,089
你就不会真正运行，

385
00:14:01,089 --> 00:14:03,940
这是昂贵的原因，因为现在操作系统

386
00:14:03,940 --> 00:14:05,200
有自己的内部数据结构

387
00:14:05,200 --> 00:14:06,880
，用锁存器保护，所以

388
00:14:06,880 --> 00:14:07,810
你必须 现在去更新

389
00:14:07,810 --> 00:14:09,490
讨论表，说

390
00:14:09,490 --> 00:14:12,190
这个线程的这个过程还不能运行，所以

391
00:14:12,190 --> 00:14:14,320
他是正确的快速用户空间互斥量

392
00:14:14,320 --> 00:14:16,270
会很快因为这只是一个自旋-自旋

393
00:14:16,270 --> 00:14:17,350
锁存器我们将在下一张幻灯片中讨论

394
00:14:17,350 --> 00:14:20,440
但他摔倒了 归结于我们，然后

395
00:14:20,440 --> 00:14:22,510
你就搞砸了，所以这是另一个很好的

396
00:14:22,510 --> 00:14:23,589
例子，就像我们试图

397
00:14:23,589 --> 00:14:25,089
在第一个项目中尽可能避免使用操作系统，

398
00:14:25,089 --> 00:14:26,980
你们使用它，因为

399
00:14:26,980 --> 00:14:28,899
它很好，但如果你有一个高

400
00:14:28,899 --> 00:14:30,160
竞争的系统，那么每个人都是

401
00:14:30,160 --> 00:14:31,390
深入到操作系统，这

402
00:14:31,390 --> 00:14:34,899
将是一个问题，所以

403
00:14:34,899 --> 00:14:37,000
替代方案是

404
00:14:37,000 --> 00:14:38,529
使用自旋锁存器或测试并设置自旋

405
00:14:38,529 --> 00:14:41,320
锁存器来实现我们自己，所以这是非常

406
00:14:41,320 --> 00:14:44,079
高效的它超级快，因为在

407
00:14:44,079 --> 00:14:46,300
现代 CPU 上有一条指令

408
00:14:46,300 --> 00:14:47,860
有一条指令

409
00:14:47,860 --> 00:14:49,839
在内存上做一个比较和交换 我

410
00:14:49,839 --> 00:14:51,310
认为这就像我检查

411
00:14:51,310 --> 00:14:52,779
这个内存地址的值

412
00:14:52,779 --> 00:14:54,940
是否是我认为的那样，如果是，那么

413
00:14:54,940 --> 00:14:57,130
我可以将它更改为我的新

414
00:14:57,130 --> 00:14:59,440
值 思考 就像锁存器设置为 0 我

415
00:14:59,440 --> 00:15:01,029
检查它是否为 0，如果是，

416
00:15:01,029 --> 00:15:02,560
那么我在 1 上说，这意味着我已经

417
00:15:02,560 --> 00:15:05,290
获得了一个锁存器，您可以使用

418
00:15:05,290 --> 00:15:07,209
现代 CPU 和有趣的单

419
00:15:07,209 --> 00:15:09,670
指令来做到这一点。 不必让

420
00:15:09,670 --> 00:15:11,079
您编写 C 代码，如果这样，

421
00:15:11,079 --> 00:15:15,220
那么它会为您完成所有工作，

422
00:15:15,220 --> 00:15:17,649
因此甚至在 C++ 中实现它的方式

423
00:15:17,649 --> 00:15:19,690
是您拥有这个原子关键字，它

424
00:15:19,690 --> 00:15:20,800
是模板化的，您可以将任何您

425
00:15:20,800 --> 00:15:22,870
想要的放在那里，但是 他们有一个快捷

426
00:15:22,870 --> 00:15:24,940
方式叫做原子标志，它只是

427
00:15:24,940 --> 00:15:28,240
原子池的别名，所以现在在这个内部

428
00:15:28,240 --> 00:15:29,920
，当我们想要获取这个

429
00:15:29,920 --> 00:15:32,040
锁存器时，我们必须有这个 while 循环

430
00:15:32,040 --> 00:15:35,470
，它说测试并设置锁存器，如果我

431
00:15:35,470 --> 00:15:37,900
获取它然后 我跳出

432
00:15:37,900 --> 00:15:39,100
他们要的狂野 因为

433
00:15:39,100 --> 00:15:41,949
如果我不陷入狂野的循环，我会抓住闩锁

434
00:15:41,949 --> 00:15:42,579
现在

435
00:15:42,579 --> 00:15:44,230
它有一些逻辑来弄清楚

436
00:15:44,230 --> 00:15:47,259
我们应该做什么 最简单的事情

437
00:15:47,259 --> 00:15:48,699
就是说好吧 让我只是 再次重试

438
00:15:48,699 --> 00:15:50,459
循环并继续尝试

439
00:15:50,459 --> 00:15:52,449
它的问题是虽然

440
00:15:52,449 --> 00:15:53,920
那只是我烧掉你的座位

441
00:15:53,920 --> 00:15:55,720
你不是真的烧坏你

442
00:15:55,720 --> 00:15:57,579
只是烧掉周期和你的 CPU 因为

443
00:15:57,579 --> 00:15:58,899
你只是不断尝试测试

444
00:15:58,899 --> 00:16:00,220
那个集合测试并设置测试它

445
00:16:00,220 --> 00:16:01,959
总是会失败并且你一直在

446
00:16:01,959 --> 00:16:04,509
旋转和在这个 无限循环，所以这

447
00:16:04,509 --> 00:16:06,009
对操作系统来说认为你实际上在做

448
00:16:06,009 --> 00:16:07,209
有用的工作，因为它不知道

449
00:16:07,209 --> 00:16:08,949
你正在执行什么指令，所以它说

450
00:16:08,949 --> 00:16:10,299
你继续执行指令让我

451
00:16:10,299 --> 00:16:12,279
继续调度你，你要

452
00:16:12,279 --> 00:16:15,429
秒杀 CPU 所以这个 测试和设置

453
00:16:15,429 --> 00:16:16,600
与他之前所说的

454
00:16:16,600 --> 00:16:18,069
关于快速用户互斥锁的内容

455
00:16:18,069 --> 00:16:20,110
相同 这与操作系统

456
00:16:20,110 --> 00:16:24,069
在 Linux 标准或 Linux 上的 STD 互斥锁中为您提供的内容相同，但

457
00:16:24,069 --> 00:16:26,499
也许我不想烧掉我的周期，但

458
00:16:26,499 --> 00:16:28,179
他让我 尝试也许我想

459
00:16:28,179 --> 00:16:30,549
屈服于操作系统获取 D 计划并

460
00:16:30,549 --> 00:16:32,559
让它安排一些其他线程，

461
00:16:32,559 --> 00:16:34,360
或者我尝试了一千次，我

462
00:16:34,360 --> 00:16:35,649
说我不会得到这个，我只是

463
00:16:35,649 --> 00:16:38,499
开始工作，所以这是一个很好的例子

464
00:16:38,499 --> 00:16:40,389
我们作为数据库系统

465
00:16:40,389 --> 00:16:44,139
开发的地方 lopers 我们可以很聪明，或者我们

466
00:16:44,139 --> 00:16:48,939
可以进入我们的实现，但是

467
00:16:48,939 --> 00:16:50,679
使用锁存器和我们的数据结构

468
00:16:50,679 --> 00:16:53,110
要注意或尝试适应我们

469
00:16:53,110 --> 00:16:55,419
认为工作负载会是什么样子，如果我

470
00:16:55,419 --> 00:16:57,369
认为这个锁存器必须像

471
00:16:57,369 --> 00:16:58,480
我的任何操作一样 正在

472
00:16:58,480 --> 00:17:00,519
做的闩锁要超级快，那么

473
00:17:00,519 --> 00:17:01,720
我继续重试会更快，

474
00:17:01,720 --> 00:17:02,980
因为无论谁持有闩锁都会

475
00:17:02,980 --> 00:17:04,869
很快放弃它，但是如果我

476
00:17:04,869 --> 00:17:06,130
认为操作将是超长的

477
00:17:06,130 --> 00:17:09,519
那么也许我想屈服或为了 一些

478
00:17:09,519 --> 00:17:11,919
时间或最终中止我们

479
00:17:11,919 --> 00:17:13,569
不能在阻止我们互斥锁中这样做，

480
00:17:13,569 --> 00:17:14,980
因为我们试图获得它我们无法获得

481
00:17:14,980 --> 00:17:20,309
它操作系统接管并且我们被阻止是

482
00:17:20,760 --> 00:17:27,849
的问题这是什么，哦，这

483
00:17:27,849 --> 00:17:30,340
是是的 就像引物就像它是

484
00:17:30,340 --> 00:17:32,590
比较和交换它说在这个内存

485
00:17:32,590 --> 00:17:34,179
地址检查值是否

486
00:17:34,179 --> 00:17:37,600
是这样的，如果它

487
00:17:37,600 --> 00:17:40,419
等于零，则传递一个零，然后将其设置为一个正确的

488
00:17:40,419 --> 00:17:42,010
然后有不同的有时有不同的

489
00:17:42,010 --> 00:17:43,570
API 你会找回o  ld

490
00:17:43,570 --> 00:17:44,889
值你会得到一个真实的

491
00:17:44,889 --> 00:17:46,480
是否超过有很多不同的

492
00:17:46,480 --> 00:17:47,830
东西然后他们已经

493
00:17:47,830 --> 00:17:49,389
测试了你知道

494
00:17:49,389 --> 00:17:51,940
你可以基于的所有不同类型

495
00:17:51,940 --> 00:17:54,270


496
00:17:54,270 --> 00:17:56,290
所以这里的主要内容是

497
00:17:56,290 --> 00:17:58,240
我们再次 我们在数据系统中可以

498
00:17:58,240 --> 00:18:00,430
比操作系统做得更好，因为

499
00:18:00,430 --> 00:18:02,230
我们会知道我们在什么情况下使用这个

500
00:18:02,230 --> 00:18:07,390
锁存器所以对于这两个例子，

501
00:18:07,390 --> 00:18:09,850
尽管锁存器刚刚被你知道我

502
00:18:09,850 --> 00:18:13,030
是否持有它，就像我之前说的那样

503
00:18:13,030 --> 00:18:15,670
我们有不同的模式，所以我们需要一个

504
00:18:15,670 --> 00:18:19,300
读写锁存器来支持我们

505
00:18:19,300 --> 00:18:20,500
有这些不同的笔记，我们

506
00:18:20,500 --> 00:18:21,760
基本上是这样做的，我们建立在

507
00:18:21,760 --> 00:18:23,680
我们的基本锁存原语之上，我们

508
00:18:23,680 --> 00:18:26,620
有自旋锁存器或 POS

509
00:18:26,620 --> 00:18:29,260
互斥锁，然后我们管理 不同的

510
00:18:29,260 --> 00:18:30,850
队列来跟踪有多少线程

511
00:18:30,850 --> 00:18:32,860
正在等待获取到不同类型

512
00:18:32,860 --> 00:18:35,590
的锁存器，所以可能只是

513
00:18:35,590 --> 00:18:36,790
提到了一些计数器来说明这里

514
00:18:36,790 --> 00:18:37,930
是帮助

515
00:18:37,930 --> 00:18:40,000
在这种模式下保持锁存器的线程数这里是 num

516
00:18:40,000 --> 00:18:42,880
正在等待它的线程数，所以如果出现重新线程

517
00:18:42,880 --> 00:18:44,650
并说我想

518
00:18:44,650 --> 00:18:46,450
很好地获得读取闩锁，我看这里并

519
00:18:46,450 --> 00:18:48,040
说没有人持有正确的闩锁

520
00:18:48,040 --> 00:18:50,290
，也没有人在等待它，所以我

521
00:18:50,290 --> 00:18:52,720
继续并递给它 出来，我更新

522
00:18:52,720 --> 00:18:55,150
我的计数器说我有一个线程

523
00:18:55,150 --> 00:18:58,050
，那就是持有这个闩锁的

524
00:18:58,050 --> 00:19:00,520
另一个威胁出现了，曾经也是

525
00:19:00,520 --> 00:19:02,650
一个非常真实的 CH 再次 Reed 闩锁

526
00:19:02,650 --> 00:19:04,990
兼容或让我共享，所以我们

527
00:19:04,990 --> 00:19:06,610
只知道这个人已经

528
00:19:06,610 --> 00:19:07,840
持有 reed 锁存器，所以这个人

529
00:19:07,840 --> 00:19:09,490
也可以获取它，我们只需更新我们的

530
00:19:09,490 --> 00:19:12,880
计数器，所以现在写入器写入器线程

531
00:19:12,880 --> 00:19:14,560
出现正确的锁存器它

532
00:19:14,560 --> 00:19:17,050
必须停止，因为因为

533
00:19:17,050 --> 00:19:19,060
读取锁存器被其他

534
00:19:19,060 --> 00:19:21,040
线程持有，所以我们只需添加我们的

535
00:19:21,040 --> 00:19:22,860
在这里反对说我们正在等待这个，

536
00:19:22,860 --> 00:19:26,020
所以现在如果一个读取线程出现并

537
00:19:26,020 --> 00:19:30,090
希望读取锁存器应该发生什么，

538
00:19:34,260 --> 00:19:36,250
所以你们取决于

539
00:19:36,250 --> 00:19:38,830
正在使用的策略我们可以立即

540
00:19:38,830 --> 00:19:41,140
让说呃已经读取锁存器

541
00:19:41,140 --> 00:19:42,760
已经被持有继续并

542
00:19:42,760 --> 00:19:44,170
获得它，但这可能导致

543
00:19:44,170 --> 00:19:45,940
饥饿，因为正确线程上的

544
00:19:45,940 --> 00:19:47,620
权利永远不会得到它，所以在

545
00:19:47,620 --> 00:19:49,450
这个例子中，我们可以停止它，

546
00:19:49,450 --> 00:19:52,030
将它添加到计数器，说我们正在

547
00:19:52,030 --> 00:19:54,160
等待这个 然后最终

548
00:19:54,160 --> 00:19:56,380
当前两个人至少闩锁时，编写

549
00:19:56,380 --> 00:19:58,810
器线程将再次获得闩锁，

550
00:19:58,810 --> 00:20:01,540
这取决于我们想要使用的策略

551
00:20:01,540 --> 00:20:04,300
取决于我们在什么上下文中

552
00:20:04,300 --> 00:20:06,670
正确使用闩锁是否是

553
00:20:06,670 --> 00:20:08,680
如果是如果是如果是 一个

554
00:20:08,680 --> 00:20:10,000
没有很多权限

555
00:20:10,000 --> 00:20:11,710
但权限非常重要的数据结构，那么

556
00:20:11,710 --> 00:20:14,110
我们想给线程的权限赋予更高的优先级

557
00:20:14,110 --> 00:20:18,790


558
00:20:18,790 --> 00:20:21,400


559
00:20:21,400 --> 00:20:23,230


560
00:20:23,230 --> 00:20:24,730
实现

561
00:20:24,730 --> 00:20:27,880
这样的东西，你仍然可以做到

562
00:20:27,880 --> 00:20:29,500
这一点，你仍然取决于你如何

563
00:20:29,500 --> 00:20:30,640
组织内存你仍然可以

564
00:20:30,640 --> 00:20:30,970


565
00:20:30,970 --> 00:20:32,740
在这个原子上执行大多数操作，

566
00:20:32,740 --> 00:20:38,140
好吧，现在让

567
00:20:38,140 --> 00:20:39,640
我们看看我们如何处理这些 闩锁并

568
00:20:39,640 --> 00:20:42,040
实际对它们做一些事情所以

569
00:20:42,040 --> 00:20:43,390
第一件事就像我说的那样首先

570
00:20:43,390 --> 00:20:44,710
谈论做哈希表因为这

571
00:20:44,710 --> 00:20:47,890
实际上非常容易做到，而且

572
00:20:47,890 --> 00:20:50,350
之所以超级容易做到是因为

573
00:20:50,350 --> 00:20:52,540
线程可以与

574
00:20:52,540 --> 00:20:56,170
我们的交互的方式 哈希表是有限的，这意味着我们

575
00:20:56,170 --> 00:20:59,050
对此进行了探索，假设我们

576
00:20:59,050 --> 00:21:00,760
像静态哈希表一样做

577
00:21:00,760 --> 00:21:02,200
可扩展的线性内容，而动态

578
00:21:02,200 --> 00:21:03,670
的则更复杂一些，

579
00:21:03,670 --> 00:21:06,900
但相同的原则适用于这里，但

580
00:21:06,900 --> 00:21:09,160
今天在线性探测中

581
00:21:09,160 --> 00:21:11,410
散列表 Mikey 出现了 我只是散列它 我跳到

582
00:21:11,410 --> 00:21:14,370
某个槽然后我只是

583
00:21:14,370 --> 00:21:16,810
在散列表上按顺序向下扫描 尝试

584
00:21:16,810 --> 00:21:18,640
找到我正在寻找的东西 我正在

585
00:21:18,640 --> 00:21:21,250
寻找的东西 每个其他

586
00:21:21,250 --> 00:21:22,570
线程都在做同样的事情 他们

587
00:21:22,570 --> 00:21:26,350
总是从上到下扫描，最终

588
00:21:26,350 --> 00:21:27,520
到达底部并循环返回，

589
00:21:27,520 --> 00:21:29,410
但您认为这只是一个循环

590
00:21:29,410 --> 00:21:30,490
缓冲区，您基本上总是

591
00:21:30,490 --> 00:21:33,280
向下扫描，因此在这种情况

592
00:21:33,280 --> 00:21:34,690
下不会出现死锁 因为

593
00:21:34,690 --> 00:21:36,000
每个人都朝着同一个方向前进

594
00:21:36,000 --> 00:21:38,050
没有人会以另一种方式出现

595
00:21:38,050 --> 00:21:39,880
他们拿着我想要

596
00:21:39,880 --> 00:21:41,800
的闩锁 它拿着我想要的闩锁 就像你

597
00:21:41,800 --> 00:21:45,160
不能 你不能陷入僵局 所以这

598
00:21:45,160 --> 00:21:48,160
使得它 超级超级简单，所以对于

599
00:21:48,160 --> 00:21:50,140
一个调整大小的表格，

600
00:21:50,140 --> 00:21:52,600
我们只是在通常在标题页面上的全局闩锁，

601
00:21:52,600 --> 00:21:55,930
这只会

602
00:21:55,930 --> 00:21:58,090
阻止其他人读取

603
00:21:58,090 --> 00:22:00,520
和写入表格，直到我

604
00:22:00,520 --> 00:22:03,820
完成调整大小，但又是这样 如果

605
00:22:03,820 --> 00:22:05,530
我们在一开始就将表的大小设置得足够大，这样在

606
00:22:05,530 --> 00:22:07,300


607
00:22:07,300 --> 00:22:09,370
大多数情况下很少发生，我们正在做的大多数情况下，

608
00:22:09,370 --> 00:22:11,410
您都知道探针或插入，

609
00:22:11,410 --> 00:22:14,020
如果您想进行压缩，那么快速删除也

610
00:22:14,020 --> 00:22:15,400
会使情况变得复杂

611
00:22:15,400 --> 00:22:17,770
移动数据，但

612
00:22:17,770 --> 00:22:19,370
为此我们可以忽略，

613
00:22:19,370 --> 00:22:22,670
所以这两种方法

614
00:22:22,670 --> 00:22:25,750
在锁存器的粒度上会有所不同，

615
00:22:25,750 --> 00:22:28,820
所以第一种方法

616
00:22:28,820 --> 00:22:31,370
在每个页面上只有一个

617
00:22:31,370 --> 00:22:34,010
读取器/写入器锁存器，所以当 a 线程

618
00:22:34,010 --> 00:22:35,960
想要做 你知道的东西

619
00:22:35,960 --> 00:22:38,030
在它可以读取页面或访问它之前进行查找它必须为该页面

620
00:22:38,030 --> 00:22:40,040
获取正确的

621
00:22:40,040 --> 00:22:43,730
闩锁 另一种方法

622
00:22:43,730 --> 00:22:45,230
是更细粒度的闩锁，其中

623
00:22:45,230 --> 00:22:49,040
每个插槽都有一个闩锁，

624
00:22:49,040 --> 00:22:50,540
这意味着你 重新向下扫描，

625
00:22:50,540 --> 00:22:52,760
您可以获得下一个插槽闩锁，

626
00:22:52,760 --> 00:22:54,320
然后进入它，然后查找

627
00:22:54,320 --> 00:22:55,520
您要查找的任何内容，

628
00:22:55,520 --> 00:22:57,470
因此在计算之间存在这种权衡

629
00:22:57,470 --> 00:22:58,940


630
00:22:58,940 --> 00:23:00,920
这两种方法之间的存储开销 因为

631
00:23:00,920 --> 00:23:02,990
页面 锁存器我们必须存储更少的锁存器

632
00:23:02,990 --> 00:23:05,330
每页只有一个锁存器但是现在这

633
00:23:05,330 --> 00:23:06,920
可能会减少我们的并行性

634
00:23:06,920 --> 00:23:10,670
因为我不能有两个你知道

635
00:23:10,670 --> 00:23:12,200
即使两个线程可能在

636
00:23:12,200 --> 00:23:14,060
不同的插槽上运行因为它在同一

637
00:23:14,060 --> 00:23:16,610
页面中它们无法运行 同时，

638
00:23:16,610 --> 00:23:19,700
在每个插槽都有一个闩锁的情况下，它

639
00:23:19,700 --> 00:23:21,050
会为更多的并行性而吊打，

640
00:23:21,050 --> 00:23:23,600
因为闩锁的粒度更细，但现在

641
00:23:23,600 --> 00:23:25,010
我在每个插槽中存储了更多的闩锁

642
00:23:25,010 --> 00:23:27,590
，现在它也更贵了

643
00:23:27,590 --> 00:23:30,710
哦，你知道 - 在我扫描时保持安静的轻松闩锁，

644
00:23:30,710 --> 00:23:31,880
因为我

645
00:23:31,880 --> 00:23:33,050
正在为我正在查看的每个插槽都这样做

646
00:23:33,050 --> 00:23:35,540
，所以让我们看一些

647
00:23:35,540 --> 00:23:37,280
高级示例，所以第一个将是

648
00:23:37,280 --> 00:23:39,020
页面闩锁，所以再说一遍 我们有一个

649
00:23:39,020 --> 00:23:41,870
简单的三到三页表，

650
00:23:41,870 --> 00:23:44,720
每页有两个槽，所以第一个

651
00:23:44,720 --> 00:23:47,420
线程想要找到 D 并说 D 散列

652
00:23:47,420 --> 00:23:50,300
到这个位置这里这个槽所以

653
00:23:50,300 --> 00:23:52,160
在我可以去看看它里面

654
00:23:52,160 --> 00:23:53,420
是否有我 想要在那里我

655
00:23:53,420 --> 00:23:55,460
首先必须获得读取闩锁

656
00:23:55,460 --> 00:23:57,800
，然后一旦我有了它，现在我的光标

657
00:23:57,800 --> 00:24:00,560
可以开始查看它，现在假设

658
00:24:00,560 --> 00:24:01,910
另一个线程出现并且他们

659
00:24:01,910 --> 00:24:04,580
想要插入 E 并且 E 想要散列到

660
00:24:04,580 --> 00:24:07,490
C 可以的位置 它这样做实际上可以开始

661
00:24:07,490 --> 00:24:10,010
查看它，因为

662
00:24:10,010 --> 00:24:13,250
它想在此页面上获取写锁存器

663
00:24:13,250 --> 00:24:16,190
因为它不知道 C

664
00:24:16,190 --> 00:24:17,720
已满 它不知道它

665
00:24:17,720 --> 00:24:19,070
必须扫描 但因此在他们甚至可以之前 看看

666
00:24:19,070 --> 00:24:19,490


667
00:24:19,490 --> 00:24:20,900
它需要正确的闩锁 正确的闩锁

668
00:24:20,900 --> 00:24:22,820
不兼容读取 l  atch 所以它

669
00:24:22,820 --> 00:24:26,360
必须停止并等待所以第一个人

670
00:24:26,360 --> 00:24:28,340
向下扫描他看着 C 现在他

671
00:24:28,340 --> 00:24:29,900
需要在这里查看下一页

672
00:24:29,900 --> 00:24:31,760
，然后我们再次确定

673
00:24:31,760 --> 00:24:32,570
您查看的页面的方式

674
00:24:32,570 --> 00:24:35,500
是我们只是看看你知道我们在看 在我们

675
00:24:35,500 --> 00:24:37,790
的哈希表的

676
00:24:37,790 --> 00:24:38,930
标题中，标题会说这

677
00:24:38,930 --> 00:24:40,580
是您要查找的所有页面，但从逻辑上讲，

678
00:24:40,580 --> 00:24:42,590
它们按顺序正确排列，例如

679
00:24:42,590 --> 00:24:44,990
第 0 页第 1 页第 2 页，因此您

680
00:24:44,990 --> 00:24:47,000
查看标题并说我在哪里

681
00:24:47,000 --> 00:24:51,050
为我的哈希表找到第 2 页，因此

682
00:24:51,050 --> 00:24:52,940
当我想

683
00:24:52,940 --> 00:24:55,580
从第 1 页转到第 2 页时，为了执行此遍历，我实际上

684
00:24:55,580 --> 00:24:58,640
不需要将闩锁放在一个上

685
00:24:58,640 --> 00:25:01,490
以便我跳到第 2 页，因为我的 哈希

686
00:25:01,490 --> 00:25:04,670
表是静态的，我不会调整大小，所以这个

687
00:25:04,670 --> 00:25:08,270
位置总是一样的，所以我可以

688
00:25:08,270 --> 00:25:09,860


689
00:25:09,860 --> 00:25:11,510
在跳到这里之前立即释放闩锁，并允许

690
00:25:11,510 --> 00:25:13,400
其他人继续运行，然后我可以

691
00:25:13,400 --> 00:25:16,130
继续并为此获取闩锁，这

692
00:25:16,130 --> 00:25:17,060
是 当我们谈论

693
00:25:17,060 --> 00:25:18,650
B 加树 B 加树你必须

694
00:25:18,650 --> 00:25:20,690
持有一个 在

695
00:25:20,690 --> 00:25:22,400
跳转到下一个节点之前锁定你来自的任何

696
00:25:22,400 --> 00:25:24,200
节点，只有当你到达

697
00:25:24,200 --> 00:25:25,670
下一行时，你才会释放

698
00:25:25,670 --> 00:25:37,820
你身后的节点是的，所以他

699
00:25:37,820 --> 00:25:40,160
提出了一个优化，在这种

700
00:25:40,160 --> 00:25:43,310
情况下这里是线程 线程 2 而不是

701
00:25:43,310 --> 00:25:45,320
尝试获取需要一个写锁存

702
00:25:45,320 --> 00:25:47,450
器我是否只需要一个读锁存器

703
00:25:47,450 --> 00:25:48,560
弄清楚我真正想要的东西

704
00:25:48,560 --> 00:25:50,960
是否在那里，然后如果是，

705
00:25:50,960 --> 00:25:52,310
那么我回去尝试获取

706
00:25:52,310 --> 00:25:54,680
写锁存器，或者我只是 跳下

707
00:25:54,680 --> 00:25:57,290
来说你知道做同样的事情 因为我

708
00:25:57,290 --> 00:25:58,250
知道这是我要找的东西 不在

709
00:25:58,250 --> 00:25:59,870
这里 如果没有删除就知道

710
00:25:59,870 --> 00:26:03,920
移动 是的 我们会

711
00:26:03,920 --> 00:26:05,270
在申请 B 加树时谈论相同的技术

712
00:26:05,270 --> 00:26:07,610
我是 这样做是一种天真的

713
00:26:07,610 --> 00:26:09,080
方式，但是是的，您实际上可以这样做，

714
00:26:09,080 --> 00:26:11,360
一般来说，您不会这样做，您并没有

715
00:26:11,360 --> 00:26:13,040
真正进行闩锁升级，您不能说

716
00:26:13,040 --> 00:26:14,390
我处于读取模式现在让我进入写入

717
00:26:14,390 --> 00:26:16,370
模式 释放闩锁，然后在

718
00:26:16,370 --> 00:26:17,960
一种模式下放置并再次获得

719
00:26:17,960 --> 00:26:21,440
另一种模式 其他模式好吧，

720
00:26:21,440 --> 00:26:23,390
所以她的这个人 Gavriel 现在可以开始

721
00:26:23,390 --> 00:26:25,400
阅读这个这个人得到了正确的

722
00:26:25,400 --> 00:26:28,400
闩锁，它看到了它看到的不是曾经

723
00:26:28,400 --> 00:26:30,050
所以想在这里扫描，这次

724
00:26:30,050 --> 00:26:32,240
t1 已经消失，所以可以继续前进并

725
00:26:32,240 --> 00:26:33,920
成为正确的 闩锁看到

726
00:26:33,920 --> 00:26:35,780
有这个插槽被占用的东西来到

727
00:26:35,780 --> 00:26:38,420
这里并再次插入它更

728
00:26:38,420 --> 00:26:40,130
粗粒度，因为

729
00:26:40,130 --> 00:26:43,310


730
00:26:43,310 --> 00:26:45,320
如果闩锁模式冲突

731
00:26:45,320 --> 00:26:46,279
一次只有一个线程在

732
00:26:46,279 --> 00:26:50,119
旁边，那么只有一个线程可以在里面 表，但它

733
00:26:50,119 --> 00:26:51,440
使实际合唱这些闩锁变得更简单我

734
00:26:51,440 --> 00:26:52,909
不会每一个都获得闩锁

735
00:26:52,909 --> 00:26:55,330
所以让我们看看如何在

736
00:26:55,330 --> 00:26:59,479
哪个插槽闩锁中做到这一点，所以再次 t1 开始它

737
00:26:59,479 --> 00:27:02,119
想要找到 D 它散列到哪里 a

738
00:27:02,119 --> 00:27:04,849
是这样它获取 a 上的读锁存器

739
00:27:04,849 --> 00:27:08,869
然后 t t2 开始它想要做一个

740
00:27:08,869 --> 00:27:11,509
正确的所以获取 C 上的正确锁存器

741
00:27:11,509 --> 00:27:14,389
，此时当 t1

742
00:27:14,389 --> 00:27:16,190
再次启动并试图查看它时它无法

743
00:27:16,190 --> 00:27:17,710
运行，因为你 无法获得那个闩锁，

744
00:27:17,710 --> 00:27:21,529
而因此他必须停下来，而

745
00:27:21,529 --> 00:27:22,729
另一个线程可以在这里继续下去

746
00:27:22,729 --> 00:27:24,589
，然后现在这个人可以接住

747
00:27:24,589 --> 00:27:26,659
我并继续在它后面继续前进，

748
00:27:26,659 --> 00:27:27,979
所以最终它也必须停止，

749
00:27:27,979 --> 00:27:29,599
因为他们不能去这里这个人

750
00:27:29,599 --> 00:27:31,909
继续他的插入然后这个

751
00:27:31,909 --> 00:27:34,369
人 然后可以继续进行，这样我们就可以进行

752
00:27:34,369 --> 00:27:35,749
他所说的完全相同的优化

753
00:27:35,749 --> 00:27:37,339
，我们将在内容 sippy + tree 中看到这一点

754
00:27:37,339 --> 00:27:40,039
我可以逃脱 T 键真正的机会

755
00:27:40,039 --> 00:27:42,049
尝试找到我想要的位置然后我

756
00:27:42,049 --> 00:27:43,279
尝试获取真正的 s 我想要什么，

757
00:27:43,279 --> 00:27:45,559
但我必须处理这个案子，或者我确实

758
00:27:45,559 --> 00:27:47,450
拿了读闩锁，看看这是

759
00:27:47,450 --> 00:27:49,849
我想去的地方，然后我释放真正的

760
00:27:49,849 --> 00:27:51,229
CH 然后回来尝试拿

761
00:27:51,229 --> 00:27:52,639
正确的闩锁，在那之间

762
00:27:52,639 --> 00:27:54,049
有人 可能

763
00:27:54,049 --> 00:27:56,119
在我的插槽中插入了一些东西然后我需要然后我需要

764
00:27:56,119 --> 00:27:56,989
能够处理它并继续

765
00:27:56,989 --> 00:28:00,200
向下扫描所以只有该

766
00:28:00,200 --> 00:28:01,429
技术适用于蓝色扇区的东西

767
00:28:01,429 --> 00:28:05,389
你必须再次这样做

768
00:28:05,389 --> 00:28:06,499
我想从这一切中获得的主要收获

769
00:28:06,499 --> 00:28:09,229
不可能有僵局，因为

770
00:28:09,229 --> 00:28:10,969
每个人都在扫描 从顶部

771
00:28:10,969 --> 00:28:12,979
到底部，让我们的生活更轻松

772
00:28:12,979 --> 00:28:14,119
，没有其他人从另一个方向进入，

773
00:28:14,119 --> 00:28:16,940
所以这也是原因 - 我们可以

774
00:28:16,940 --> 00:28:18,259
在跳到下一个之前释放闩锁，

775
00:28:18,259 --> 00:28:19,849
因为我们不

776
00:28:19,849 --> 00:28:21,710
担心页面的位置

777
00:28:21,710 --> 00:28:27,889
我们 'W 正在改变好吗所以让我们

778
00:28:27,889 --> 00:28:28,879
谈谈更复杂的事情让我们

779
00:28:28,879 --> 00:28:31,460
谈谈我们必须在 B+ 树中这样做 所以

780
00:28:31,460 --> 00:28:33,139
我们再次希望有多个线程

781
00:28:33,139 --> 00:28:35,809
同时运行 然后我们

782
00:28:35,809 --> 00:28:37,509
允许它们重做读取和写入

783
00:28:37,509 --> 00:28:39,799
而不必 锁定或闩锁

784
00:28:39,799 --> 00:28:41,899
整个树或在操作的持续时间内

785
00:28:41,899 --> 00:28:44,119
，因此我们需要

786
00:28:44,119 --> 00:28:45,889
在 B+ 树中处理两件事以使其

787
00:28:45,889 --> 00:28:47,989
线程安全，我们需要处理

788
00:28:47,989 --> 00:28:49,460
两个线程试图

789
00:28:49,460 --> 00:28:52,059
修改同一节点的情况 同时

790
00:28:52,059 --> 00:28:54,320
，然后我们需要处理这样

791
00:28:54,320 --> 00:28:56,089
一种情况，即一个线程可能正在遍历

792
00:28:56,089 --> 00:28:58,729
树，然后在它到达叶节点之前向下向下，

793
00:28:58,729 --> 00:28:59,990


794
00:28:59,990 --> 00:29:02,179
另一个线程进行修改，

795
00:29:02,179 --> 00:29:04,340
导致分裂和出现，现在是

796
00:29:04,340 --> 00:29:07,700
位置 一个页面可能会结束一个节点可能

797
00:29:07,700 --> 00:29:10,070
最终会四处移动并且

798
00:29:10,070 --> 00:29:11,450
我正在寻找的数据不存在或者在最坏的

799
00:29:11,450 --> 00:29:13,100
情况下我有一个指向现在的指针

800
00:29:13,100 --> 00:29:16,390
并且在内存中是一个无效的内存位置

801
00:29:16,390 --> 00:29:18,440
所以让我们看看高级 这里的例子

802
00:29:18,440 --> 00:29:20,660
所以我们将专注于

803
00:29:20,660 --> 00:29:22,760
树的这一侧我只是在 ABCDE 中标记，然后

804
00:29:22,760 --> 00:29:25,429
在叶节点上依此类推，所以说我们

805
00:29:25,429 --> 00:29:29,330
想要在 44 上进行删除

806
00:29:29,330 --> 00:29:31,280
到底部，因此第一个线程将

807
00:29:31,280 --> 00:29:32,809
再次从顶部开始 我们只是进行

808
00:29:32,809 --> 00:29:34,370
到目前为止我们讨论过的遍历 我们

809
00:29:34,370 --> 00:29:36,110
查看分隔键 我们确定

810
00:29:36,110 --> 00:29:37,250
是否要向左和向右

811
00:29:37,250 --> 00:29:39,170
移动 然后我们根据它向下移动到子

812
00:29:39,170 --> 00:29:41,660
节点，然后我们可能会向下移动 到这里的

813
00:29:41,660 --> 00:29:44,030
叶节点，我们可以继续

814
00:29:44,030 --> 00:29:46,850
删除我们的条目，但现在我们看到我们的

815
00:29:46,850 --> 00:29:48,890
节点不到半满，在这种情况下

816
00:29:48,890 --> 00:29:51,380
它完全是空的，所以我们必须

817
00:29:51,380 --> 00:29:54,320
重新平衡，所以我们会想要

818
00:29:54,320 --> 00:29:55,970
在这种情况下 在这里，

819
00:29:55,970 --> 00:29:59,420
我们不进行合并，而是从我们的兄弟姐妹之一复制一个键，

820
00:29:59,420 --> 00:30:01,640
但让我们 在

821
00:30:01,640 --> 00:30:05,450
我们可以做到重新平衡之前，操作系统会换

822
00:30:05,450 --> 00:30:08,270
出我们的线程 I，我们让它停顿，

823
00:30:08,270 --> 00:30:10,880
现在另一个线程开始运行

824
00:30:10,880 --> 00:30:12,860
，另一个线程想要进行查找

825
00:30:12,860 --> 00:30:15,740
以尝试在底部找到键 41，

826
00:30:15,740 --> 00:30:17,480
这样就可以了 同样的事情

827
00:30:17,480 --> 00:30:19,610
它开始遍历树，然后

828
00:30:19,610 --> 00:30:22,580
它到这里的这一点，它

829
00:30:22,580 --> 00:30:24,260
查看分隔键并计算

830
00:30:24,260 --> 00:30:26,450
出哦，我想去这个节点，

831
00:30:26,450 --> 00:30:29,150
但它得到它 Bo 停止这切换

832
00:30:29,150 --> 00:30:33,050
回我们的第一个线程和 首先

833
00:30:33,050 --> 00:30:36,110
rad 移动了 41，然后现在当我的

834
00:30:36,110 --> 00:30:37,400
另一个线程再次开始运行时，我

835
00:30:37,400 --> 00:30:38,750
来到这里，我

836
00:30:38,750 --> 00:30:41,740
认为那里不再

837
00:30:41,740 --> 00:30:45,860
存在，所以最好的情况

838
00:30:45,860 --> 00:30:47,360
就是你知道我们得到了假阴性

839
00:30:47,360 --> 00:30:50,000
在这里，我们认为键 41 确实存在，

840
00:30:50,000 --> 00:30:51,490
但索引告诉我们

841
00:30:51,490 --> 00:30:53,570


842
00:30:53,570 --> 00:30:54,440
，在最好的情况下，今天讨论的所有异常或问题并不存在，

843
00:30:54,440 --> 00:30:57,140
最坏的情况是该节点

844
00:30:57,140 --> 00:30:58,610
移动了，然后现在该指针

845
00:30:58,610 --> 00:31:01,010
指向 什么都没有，我们去了 我们

846
00:31:01,010 --> 00:31:02,270
会在程序中遇到段错误

847
00:31:02,270 --> 00:31:05,480
崩溃 所以我们要处理的方式

848
00:31:05,480 --> 00:31:07,790
是经典的技术，称为闩锁

849
00:31:07,790 --> 00:31:10,190
螃蟹或闩锁耦合

850
00:31:10,190 --> 00:31:11,780
当我还是个小伙子时，当我

851
00:31:11,780 --> 00:31:13,220
学习数据库时，

852
00:31:13,220 --> 00:31:15,800
我会成为游戏 有人告诉我这个术语被

853
00:31:15,800 --> 00:31:16,730
称为 latrabbing

854
00:31:16,730 --> 00:31:18,170
我不知道教科书实际使用的是什么，

855
00:31:18,170 --> 00:31:19,880
但我认为维基百科称

856
00:31:19,880 --> 00:31:22,340
很多闩锁耦合它都是相同的

857
00:31:22,340 --> 00:31:25,670
概念相同的东西所以 latscrabing 是

858
00:31:25,670 --> 00:31:27,140
一种允许多个

859
00:31:27,140 --> 00:31:30,140
线程访问的技术 B 加树

860
00:31:30,140 --> 00:31:31,310
同时，我们要

861
00:31:31,310 --> 00:31:33,680
使用闩锁保护事物，因此其工作方式的基本思想

862
00:31:33,680 --> 00:31:35,840
是，无论何时我们在一个

863
00:31:35,840 --> 00:31:37,280
节点上，我们都必须在该节点上有一个闩锁

864
00:31:37,280 --> 00:31:39,800
处于正确模式或读取模式，

865
00:31:39,800 --> 00:31:42,920
并且 然后在我们可以跳转到我们的孩子之前，

866
00:31:42,920 --> 00:31:45,230
我们必须在下一个我们要去的下一个节点上锁定我们的孩子

867
00:31:45,230 --> 00:31:46,460


868
00:31:46,460 --> 00:31:49,460
，然后当我们

869
00:31:49,460 --> 00:31:51,350
在那个孩子上登陆时，我们可以检查

870
00:31:51,350 --> 00:31:53,060
它的内容，如果 我们确定

871
00:31:53,060 --> 00:31:56,890
我们刚刚移动到的子节点是安全的

872
00:31:56,890 --> 00:31:59,360
那么我们可以释放

873
00:31:59,360 --> 00:32:02,150
我们父母的闩锁，所以这个术语让

874
00:32:02,150 --> 00:32:03,470
螃蟹与螃蟹走路的方式有关，

875
00:32:03,470 --> 00:32:05,720
就像一只腿从另一只腿上移开一样

876
00:32:05,720 --> 00:32:07,070
，这就是我们在

877
00:32:07,070 --> 00:32:10,190
下降时获得闩锁的方式，所以我们的

878
00:32:10,190 --> 00:32:13,100
安全的定义是这样的，如果我们

879
00:32:13,100 --> 00:32:16,610
正在进行修改，无论树中的节点下方发生什么，我们所在的节点

880
00:32:16,610 --> 00:32:18,770
都不必进行拆分

881
00:32:18,770 --> 00:32:21,170
或合并

882
00:32:21,170 --> 00:32:24,530
，这意味着

883
00:32:24,530 --> 00:32:26,510
如果我们 '正在

884
00:32:26,510 --> 00:32:27,920
尝试插入我们有空间

885
00:32:27,920 --> 00:32:29,630
容纳可能出现的

886
00:32:29,630 --> 00:32:31,400
任何键或我们正在插入的任何键

887
00:32:31,400 --> 00:32:33,320
然后如果我们正在执行删除我们

888
00:32:33,320 --> 00:32:34,720
知道它更多它超过一半

889
00:32:34,720 --> 00:32:37,610
意味着我们必须删除 一个关键，我们

890
00:32:37,610 --> 00:32:41,720
不必进行合并，

891
00:32:41,720 --> 00:32:43,040
所以基本

892
00:32:43,040 --> 00:32:44,930
协议在根上

893
00:32:44,930 --> 00:32:46,640


894
00:32:46,640 --> 00:32:48,200
是这样工作的

895
00:32:48,200 --> 00:32:50,060
每次

896
00:32:50,060 --> 00:32:52,880
我们到达下一个节点时都会再次关闭我们

897
00:32:52,880 --> 00:32:54,080
释放闩锁 在我们

898
00:32:54,080 --> 00:32:56,120
再次出现的那个父引擎上我们没有做

899
00:32:56,120 --> 00:32:57,740
任何修改所以每个节点都

900
00:32:57,740 --> 00:33:00,560
被认为可以安全地插入和删除

901
00:33:00,560 --> 00:33:02,060


902
00:33:02,060 --> 00:33:04,220


903
00:33:04,220 --> 00:33:05,600
在被

904
00:33:05,600 --> 00:33:07,790
认为是安全的我们可以释放

905
00:33:07,790 --> 00:33:09,590
我们在树上面的任何正确的闩锁，

906
00:33:09,590 --> 00:33:11,720
因为无论我们下面的东西

907
00:33:11,720 --> 00:33:13,640
都不会受到影响，他们

908
00:33:13,640 --> 00:33:16,880
不必改变所以让我们看看

909
00:33:16,880 --> 00:33:19,040
一些信号所以再次找到是超级

910
00:33:19,040 --> 00:33:21,140
简单的我 想在底部找到键 38

911
00:33:21,140 --> 00:33:23,000
所以我的线程从头

912
00:33:23,000 --> 00:33:25,430
开始我得到了真正的 a

913
00:33:25,430 --> 00:33:26,929
我回到现在 B 现在

914
00:33:26,929 --> 00:33:30,950
又回到这里因为它是只读

915
00:33:30,950 --> 00:33:33,710
操作它很好它对我来说是安全的

916
00:33:33,710 --> 00:33:36,320
释放 锁定一个，所以一旦

917
00:33:36,320 --> 00:33:38,029
我开始 BI 就可以释放闩锁

918
00:33:38,029 --> 00:33:40,129
na，我很高兴去，现在我继续

919
00:33:40,129 --> 00:33:42,049
向下扫描并做同样的事情

920
00:33:42,049 --> 00:33:45,169
在 B 上释放 D 在 D 上释放 H

921
00:33:45,169 --> 00:33:47,919
现在我 做我的阅读，我

922
00:33:47,919 --> 00:33:52,429
做得很简单，所以让

923
00:33:52,429 --> 00:33:56,149
现在看看我们是否要进行删除，所以我

924
00:33:56,149 --> 00:33:57,259
从根上的正确闩锁开始

925
00:33:57,259 --> 00:33:59,869
我在

926
00:33:59,869 --> 00:34:02,089
获得正确的闩锁后回到 B 现在这

927
00:34:02,089 --> 00:34:04,159
一点是我释放 a

928
00:34:04,159 --> 00:34:06,229
上的闩锁是否安全 不

929
00:34:06,229 --> 00:34:08,210
为什么 因为我只有一个键和

930
00:34:08,210 --> 00:34:10,579
B 所以我不知道我下面是什么

931
00:34:10,579 --> 00:34:12,589
我要走下去 我正在做 38 所以

932
00:34:12,589 --> 00:34:14,418
我要走下来 我不知道

933
00:34:14,418 --> 00:34:16,879
这些其他音符长什么样 就像这样，如果我

934
00:34:16,879 --> 00:34:19,399
进行删除并且我必须合并并且我

935
00:34:19,399 --> 00:34:21,469
现在必须删除此键我确实喜欢

936
00:34:21,469 --> 00:34:23,809
它们你知道对egg进行更改所以

937
00:34:23,809 --> 00:34:25,549
在这种情况下我们必须保持

938
00:34:25,549 --> 00:34:27,589
B上的闩锁我很抱歉 我握住鸡蛋的闩锁，

939
00:34:27,589 --> 00:34:29,960
然后我们得到 D 的闩锁

940
00:34:29,960 --> 00:34:33,199
下来，现在我们认识到，

941
00:34:33,199 --> 00:34:35,599
无论 D 下面发生什么，

942
00:34:35,599 --> 00:34:37,969
我们都知道我们有空间容纳，或者我们可以

943
00:34:37,969 --> 00:34:39,199
租用一把钥匙，我将不得不

944
00:34:39,199 --> 00:34:41,270
合并所以我们可以在这一点上我们

945
00:34:41,270 --> 00:34:43,760
可以释放 a 和 B 上的闩锁 所以

946
00:34:43,760 --> 00:34:44,779
本质上，线程有点

947
00:34:44,779 --> 00:34:46,099
保持堆栈，就像

948
00:34:46,099 --> 00:34:48,139
我持有的所有闩锁一样 我下去所以

949
00:34:48,139 --> 00:34:49,940
它知道在某个时候当我

950
00:34:49,940 --> 00:34:51,230
处于安全节点时我只是将所有东西

951
00:34:51,230 --> 00:34:54,710
向上颠簸一下，所以现在我下降

952
00:34:54,710 --> 00:34:57,049
到 HI 可以释放 D 上的闩锁，

953
00:34:57,049 --> 00:35:00,049
因为 H 是一个 Humberts，

954
00:35:00,049 --> 00:35:02,270
然后我就走了 提前做我的删除

955
00:35:02,270 --> 00:35:03,829
然后当我完成然后我释放

956
00:35:03,829 --> 00:35:07,970
闩锁然后回家让我们现在看看

957
00:35:07,970 --> 00:35:09,020
插入相同的东西

958
00:35:09,020 --> 00:35:10,549
从a上的正确闩锁开始并且

959
00:35:10,549 --> 00:35:12,710
屋顶下降到此时这里我

960
00:35:12,710 --> 00:35:14,900
认识到B可以 容纳任何新的

961
00:35:14,900 --> 00:35:17,150
插入，所以我可以安全地

962
00:35:17,150 --> 00:35:19,069
释放闩锁，所以我会继续这样做

963
00:35:19,069 --> 00:35:21,770
，然后我去到 DD 被

964
00:35:21,770 --> 00:35:23,809
认为是满的，所以我不知道

965
00:35:23,809 --> 00:35:25,490
我下面会发生什么，所以我不得不

966
00:35:25,490 --> 00:35:28,849
按住 B 上的闩锁，然后我开始

967
00:35:28,849 --> 00:35:30,859
考虑 I，现在我意识到我

968
00:35:30,859 --> 00:35:32,329
永远不能分开，因为有足够的空间，所以

969
00:35:32,329 --> 00:35:34,339
在我进行更新之前，我释放了

970
00:35:34,339 --> 00:35:37,549
B 和 B 和 D 上的闩锁，然后晚上

971
00:35:37,549 --> 00:35:39,660
我可以做我的插入

972
00:35:39,660 --> 00:35:43,780
所以为此，从正确性的角度来看，您

973
00:35:43,780 --> 00:35:46,270
释放闩锁的顺序并不重要。

974
00:35:46,270 --> 00:35:49,180


975
00:35:49,180 --> 00:35:51,790
回到这里

976
00:35:51,790 --> 00:35:54,550
，如果我在珠子之前松开 D 上的闩锁，那我必须松开 D 和 B 上的闩锁

977
00:35:54,550 --> 00:35:56,920
，这无关紧要，因为

978
00:35:56,920 --> 00:35:58,240
无论如何没人会到达 D 因为

979
00:35:58,240 --> 00:36:00,670
他们无法到达 B 所以从

980
00:36:00,670 --> 00:36:01,960
正确性的角度来看它不会 没关系，

981
00:36:01,960 --> 00:36:03,730
但从我的角度来看，我们

982
00:36:03,730 --> 00:36:05,220
显然想先释放这个，

983
00:36:05,220 --> 00:36:08,980
因为这不再覆盖更多的

984
00:36:08,980 --> 00:36:11,200
叶节点，所以你想尽快释放

985
00:36:11,200 --> 00:36:15,780
更高的闩锁，

986
00:36:16,410 --> 00:36:20,410
好吧，让我们再看一个例子

987
00:36:20,410 --> 00:36:22,960
，其中可能有一个 分裂，所以我

988
00:36:22,960 --> 00:36:25,330
想证明 25 件同样的事情正确地锁定

989
00:36:25,330 --> 00:36:28,960
在一个正确的闩锁上是不会

990
00:36:28,960 --> 00:36:30,550
完全克服的我可以释放闩锁

991
00:36:30,550 --> 00:36:33,340
我下来看看他

992
00:36:33,340 --> 00:36:35,140
不会去克服一个傻瓜所以 我至少可以

993
00:36:35,140 --> 00:36:37,180
锁定 B，然后现在

994
00:36:37,180 --> 00:36:39,610
我回到 F，现在我看到我需要

995
00:36:39,610 --> 00:36:42,670
进行拆分，因此在这种情况下，我

996
00:36:42,670 --> 00:36:44,500
需要在进行更改时将锁定保持在 C 上的父节点

997
00:36:44,500 --> 00:36:49,540
上 所以我首先

998
00:36:49,540 --> 00:36:53,290
从这里开始 25 把溢出页面

999
00:36:53,290 --> 00:36:55,390
放在那里把 31 放在那里然后更新

1000
00:36:55,390 --> 00:36:59,830
我的父母 节点我需要

1001
00:36:59,830 --> 00:37:04,030
在这个新人上有一个闩锁吗

1002
00:37:04,030 --> 00:37:12,040
？为什么他说不，我们可以

1003
00:37:12,040 --> 00:37:13,210
访问它，因为你可以让你

1004
00:37:13,210 --> 00:37:17,050
在父级上有一个闩锁，

1005
00:37:17,050 --> 00:37:19,060
假设没有

1006
00:37:19,060 --> 00:37:20,590
我们将要讨论的兄弟指针 等一下，所以在这个

1007
00:37:20,590 --> 00:37:22,690
例子中，为了简单起见，我

1008
00:37:22,690 --> 00:37:23,710
不会获取闩锁，因为

1009
00:37:23,710 --> 00:37:25,480
如果我沿着叶节点扫描，每个人都会从底部进入顶部，

1010
00:37:25,480 --> 00:37:27,520
然后

1011
00:37:27,520 --> 00:37:28,900
是的，有人可以到达这里，我

1012
00:37:28,900 --> 00:37:32,280
必须保护它，但是 我们会得到那个好的

1013
00:37:32,280 --> 00:37:34,280
是的

1014
00:37:34,280 --> 00:37:37,349
[音乐]

1015
00:37:39,870 --> 00:37:42,250
是的 Damon 是我说过线程

1016
00:37:42,250 --> 00:37:44,920
有一堆

1017
00:37:44,920 --> 00:37:45,700
他们正在获取我们去的锁存器

1018
00:37:45,700 --> 00:37:50,140
不应该是一个队列 是

1019
00:37:50,140 --> 00:37:52,230
的先进先出

1020
00:37:53,040 --> 00:38:25,030
好的 是的 是的说 - 我说回到

1021
00:38:25,030 --> 00:38:27,130
这张桌子这里我说你想

1022
00:38:27,130 --> 00:38:30,310
从顶部到底部释放闩锁

1023
00:38:30,310 --> 00:38:32,260
，你

1024
00:38:32,260 --> 00:38:35,140
在操作系统世界中说它你 - 你 - 你

1025
00:38:35,140 --> 00:38:38,260
再次以相反的顺序释放它们 想一想此时此刻

1026
00:38:38,260 --> 00:38:40,200
我们在数据结构中所做的事情

1027
00:38:40,200 --> 00:38:43,510
就像没有人可以

1028
00:38:43,510 --> 00:38:46,360
到达 D 除非他们通过 B 所以我

1029
00:38:46,360 --> 00:38:48,400
释放 D 上的闩锁不会做

1030
00:38:48,400 --> 00:38:50,770
任何事情，因为没有人在等待

1031
00:38:50,770 --> 00:38:53,680
闩锁上面的某个人可能正在

1032
00:38:53,680 --> 00:38:55,510
等待获得所需的 B 所以我想

1033
00:38:55,510 --> 00:38:57,480
尽快释放那个闩锁

1034
00:38:57,480 --> 00:38:59,950
所以这是因为我们 知道什么数据

1035
00:38:59,950 --> 00:39:01,600
结构它是如何被使用的 我们

1036
00:39:01,600 --> 00:39:02,740
了解你的

1037
00:39:02,740 --> 00:39:04,360
锁存器是如何被使用的上下文 你想

1038
00:39:04,360 --> 00:39:11,850
先释放这个 好的

1039
00:39:13,030 --> 00:39:16,300
所以现在我想问你们

1040
00:39:16,300 --> 00:39:17,920
我为所有这些修改所做的第一步是什么

1041
00:39:17,920 --> 00:39:19,420
以及

1042
00:39:19,420 --> 00:39:20,770
插入和删除的例子，

1043
00:39:20,770 --> 00:39:25,930
你做的第一步是什么，你

1044
00:39:25,930 --> 00:39:27,430
在独占模式或右-右

1045
00:39:27,430 --> 00:39:30,250
模式下锁存根，这是有问题的，因为

1046
00:39:30,250 --> 00:39:32,320
再次正确的法律右锁是

1047
00:39:32,320 --> 00:39:34,930
独占的，在此期间没有其他线程可以

1048
00:39:34,930 --> 00:39:35,890
获取任何其他

1049
00:39:35,890 --> 00:39:38,080
拉萨 在那个节点上，所以这变成

1050
00:39:38,080 --> 00:39:39,430
了一个单一的争用点，一个单一的

1051
00:39:39,430 --> 00:39:41,650
瓶颈，为了进入数据

1052
00:39:41,650 --> 00:39:42,040
结构，

1053
00:39:42,040 --> 00:39:43,780
每个人都获得了这个正确的闩锁

1054
00:39:43,780 --> 00:39:45,640
，只有一个线程可以持有那个正确的

1055
00:39:45,640 --> 00:39:48,700
l 一次匹配，所以这是一个大问题，

1056
00:39:48,700 --> 00:39:50,530
这将防止我们获得

1057
00:39:50,530 --> 00:39:51,810
过高的并行度以实现高并发性，

1058
00:39:51,810 --> 00:39:54,940
因此我们需要更好的东西，而不仅仅是

1059
00:39:54,940 --> 00:39:56,650
每个人都拒绝正确的闩锁，然后

1060
00:39:56,650 --> 00:39:58,690
他们一进入，我们

1061
00:39:58,690 --> 00:39:59,800
将实际提供 他们要做的

1062
00:39:59,800 --> 00:40:01,810
正是他之前从

1063
00:40:01,810 --> 00:40:04,330
哈希表中提出的，这是一个乐观的

1064
00:40:04,330 --> 00:40:08,110
假设，即大多数线程

1065
00:40:08,110 --> 00:40:10,150
不需要在叶节点上进行拆分或合并，

1066
00:40:10,150 --> 00:40:12,880
因此与其一直使用正确的锁存器，不如

1067
00:40:12,880 --> 00:40:14,050


1068
00:40:14,050 --> 00:40:16,530
我一直使用读锁存器 一路下来，

1069
00:40:16,530 --> 00:40:19,000
然后我在叶节点上取一个正确的闩锁，

1070
00:40:19,000 --> 00:40:21,940
如果我确定我不必

1071
00:40:21,940 --> 00:40:24,100
分裂，那么很好，我只用读闩锁就下来了，

1072
00:40:24,100 --> 00:40:25,930


1073
00:40:25,930 --> 00:40:28,510
如果我弄错了，我可以做任何我想做的改变，

1074
00:40:28,510 --> 00:40:30,550
我 做分裂或合并然后

1075
00:40:30,550 --> 00:40:32,380
我只是在开始时中止重新启动操作

1076
00:40:32,380 --> 00:40:33,580
并关闭正确的闩锁

1077
00:40:33,580 --> 00:40:37,360
所以这是

1078
00:40:37,360 --> 00:40:38,820
我们在

1079
00:40:38,820 --> 00:40:40,840
乐观与悲观的系统中所做的标准技术我

1080
00:40:40,840 --> 00:40:42,730
乐观地假设我是 

1081
00:40:42,730 --> 00:40:45,160
不必进行拆分，因此我

1082
00:40:45,160 --> 00:40:47,230
采用了快速路径，并且确实会

1083
00:40:47,230 --> 00:40:49,570
在其他事物的上下文中看到这一点，

1084
00:40:49,570 --> 00:40:50,830
例如稍后的事务

1085
00:40:50,830 --> 00:40:54,490
以及现实世界中远程 B 和树的大多数数据结构

1086
00:40:54,490 --> 00:40:56,740
，这

1087
00:40:56,740 --> 00:40:59,230
实际上是一个很好的选择 安全假设

1088
00:40:59,230 --> 00:41:00,850
在我的例子中，一些显示的节点

1089
00:41:00,850 --> 00:41:02,950
在真实的数据库系统中会有两个键，

1090
00:41:02,950 --> 00:41:04,630
你的节点将会是你知道

1091
00:41:04,630 --> 00:41:06,550
8 KB 或 16 KB

1092
00:41:06,550 --> 00:41:07,960
会有很多键，所以

1093
00:41:07,960 --> 00:41:09,610
你正在做的大部分操作都不是 将

1094
00:41:09,610 --> 00:41:11,380
不得不在合并中进行拆分，在

1095
00:41:11,380 --> 00:41:12,820
极少数情况下，您必须进行拆分

1096
00:41:12,820 --> 00:41:13,990
合并，然后又

1097
00:41:13,990 --> 00:41:16,150
回到我之前展示的标准闩锁捕获技术

1098
00:41:16,150 --> 00:41:19,330
，因此这是

1099
00:41:19,330 --> 00:41:22,630
来自这些德国人 1977 年的一篇论文 伙计们

1100
00:41:22,630 --> 00:41:24,790
Baron schlock Nick 这个所以没有

1101
00:41:24,790 --> 00:41:26,050
人们通常提到的算法的名称

1102
00:41:26,050 --> 00:41:26,770


1103
00:41:26,770 --> 00:41:28,780
- 作为看跌逻辑算法，我们

1104
00:41:28,780 --> 00:41:31,360
非常乐观/抓住一切，所以

1105
00:41:31,360 --> 00:41:33,280
假设我们想在 38 上进行删除，

1106
00:41:33,280 --> 00:41:35,290
所以我再次不接受 根中的一个右闩锁

1107
00:41:35,290 --> 00:41:37,600
我一直向下取一个读闩锁

1108
00:41:37,600 --> 00:41:41,020
，然后当我在这里降到 2D 时

1109
00:41:41,020 --> 00:41:43,390
，我在 HI 上的右侧闩锁处获取实数

1110
00:41:43,390 --> 00:41:46,810
认识到我正在

1111
00:41:46,810 --> 00:41:48,520
执行删除，因此我不是 将

1112
00:41:48,520 --> 00:41:51,040
进行拆分和合并，因此我的

1113
00:41:51,040 --> 00:41:51,760
赌注得到了回报

1114
00:41:51,760 --> 00:41:55,030
，我不需要重新启动正确的

1115
00:41:55,030 --> 00:41:57,880
我可以删除而不必采取

1116
00:41:57,880 --> 00:42:00,690
正确的闩锁插入正确的

1117
00:42:02,010 --> 00:42:05,080
相同的事情因此插入 25 我

1118
00:42:05,080 --> 00:42:07,180
在下降的过程中复发

1119
00:42:07,180 --> 00:42:07,630
对不起，

1120
00:42:07,630 --> 00:42:11,020
我用了一个真正的 CH 并一直向下做螃蟹

1121
00:42:11,020 --> 00:42:12,820
，然后我

1122
00:42:12,820 --> 00:42:15,610
最终看到这里我在 F 上正确闩锁

1123
00:42:15,610 --> 00:42:18,250
，我意识到我

1124
00:42:18,250 --> 00:42:22,570
将不得不进行拆分，所以我中止了

1125
00:42:22,570 --> 00:42:25,630
操作并重新启动它从头

1126
00:42:25,630 --> 00:42:27,310
开始并一直向下取正确的闩锁

1127
00:42:27,310 --> 00:42:35,380
所以他说

1128
00:42:35,380 --> 00:42:36,580
你不应该从你最后一次

1129
00:42:36,580 --> 00:42:38,830
释放闩锁的点开始向下

1130
00:42:38,830 --> 00:42:40,600
这样在这种情况下是在 C

1131
00:42:40,600 --> 00:42:54,520
右边 所以问题是 -

1132
00:42:54,520 --> 00:42:56,920
抱歉，我们需要我的两个节点，例如 -

1133
00:42:56,920 --> 00:43:05,080
兄弟 - 键是正确

1134
00:43:05,080 --> 00:43:13,810
是 b  ut 你怎么得到 你怎么

1135
00:43:13,810 --> 00:43:22,750
又得到 CNF 你不能他说我说你

1136
00:43:22,750 --> 00:43:24,250
可以保持一堆下注者

1137
00:43:24,250 --> 00:43:26,110
这样你下来我不能这样做

1138
00:43:26,110 --> 00:43:30,520
因为我不能再说页面 ID 这些

1139
00:43:30,520 --> 00:43:32,860
ABCDE 这些是这些节点的逻辑标识符

1140
00:43:32,860 --> 00:43:34,720
，但它们最终可能会

1141
00:43:34,720 --> 00:43:36,580
被放入不同的页面，

1142
00:43:36,580 --> 00:43:38,260
因为我没有

1143
00:43:38,260 --> 00:43:40,390
对这些东西持有任何闩锁，任何人都可以做

1144
00:43:40,390 --> 00:43:40,820
任何事情

1145
00:43:40,820 --> 00:43:43,610
，因此

1146
00:43:43,610 --> 00:43:45,800
这些节点的页面 ID 的位置 现在可能

1147
00:43:45,800 --> 00:43:48,140
有所不同，所以现在你

1148
00:43:48,140 --> 00:43:50,690
在我的堆栈中看到第 1 2 3 页公告 4 5 6 我去

1149
00:43:50,690 --> 00:43:51,980
寻找第 1 2 3 页，现在它

1150
00:43:51,980 --> 00:43:54,260
完全不同，因为我

1151
00:43:54,260 --> 00:43:56,510
不能我们不能假设

1152
00:43:56,510 --> 00:43:57,770
这些图片的位置 节点将始终

1153
00:43:57,770 --> 00:44:00,590
相同，除非我对它们进行

1154
00:44:00,590 --> 00:44:02,000
闩锁 读取闩锁可防止任何人写入

1155
00:44:02,000 --> 00:44:03,530
它们并进行拆分 正确的

1156
00:44:03,530 --> 00:44:05,270
闩锁可防止任何人 ah 否则我

1157
00:44:05,270 --> 00:44:07,400
也修改它们 你总是必须

1158
00:44:07,400 --> 00:44:29,990
重新启动 是的 谢谢你 抱歉你的

1159
00:44:29,990 --> 00:44:33,230
陈述是 说忘记所以如果我

1160
00:44:33,230 --> 00:44:42,520
认为那是 重新开始抱歉是的

1161
00:44:50,410 --> 00:44:53,960
所以你的问题是如果我们有如果说

1162
00:44:53,960 --> 00:44:59,120
我们就像也许像这里所以我持有

1163
00:44:59,120 --> 00:45:02,060
读闩锁在这个上我持有正确的

1164
00:45:02,060 --> 00:45:04,700
闩锁然后因为我在这

1165
00:45:04,700 --> 00:45:07,250
一点上我需要修改它 但我

1166
00:45:07,250 --> 00:45:08,660
也不知道是否有人会

1167
00:45:08,660 --> 00:45:10,490
改变一些会

1168
00:45:10,490 --> 00:45:11,920
导致这个东西也被修改的东西，

1169
00:45:11,920 --> 00:45:13,970
但是每个人都朝着同一个

1170
00:45:13,970 --> 00:45:15,680
方向前进，所以他们不能那样做，就像

1171
00:45:15,680 --> 00:45:17,540
他们不能达到一样

1172
00:45:17,540 --> 00:45:19,670
在这里进行任何更改，因为我持有真正的

1173
00:45:19,670 --> 00:45:23,200
灰烬，因此他们无法正确修改此节点

1174
00:45:23,200 --> 00:45:26,200


1175
00:45:26,880 --> 00:45:49,200


1176
00:45:49,200 --> 00:45:50,760


1177
00:45:50,760 --> 00:45:52,590


1178
00:45:52,590 --> 00:45:54,660
认识到哦，我

1179
00:45:54,660 --> 00:45:56,040
分裂了，因此我需要正确的闩锁

1180
00:45:56,040 --> 00:45:57,750
，但我没有，所以

1181
00:45:57,750 --> 00:45:58,500
在重新启动

1182
00:45:58,500 --> 00:46:02,570
时你是否一直拿着它不是

1183
00:46:05,090 --> 00:46:51,350
是是是是是

1184
00:46:51,350 --> 00:46:53,700
她说所以说我有这个

1185
00:46:53,700 --> 00:46:56,520
此处的示例我去了证书 25 我到了叶

1186
00:46:56,520 --> 00:46:58,800
节点并认出了哦我有一个分裂让

1187
00:46:58,800 --> 00:47:01,230
我重新启动 t 并取下正确的闩锁，

1188
00:47:01,230 --> 00:47:03,120
但在我重新启动期间，他需要

1189
00:47:03,120 --> 00:47:05,400
其他人出现并

1190
00:47:05,400 --> 00:47:07,200
想要插入 24，他们会

1191
00:47:07,200 --> 00:47:08,700
遇到同样的问题，他们也必须将其

1192
00:47:08,700 --> 00:47:11,190
拆分，因此他们也回来并

1193
00:47:11,190 --> 00:47:12,870
取下正确的闩锁 一路下来，

1194
00:47:12,870 --> 00:47:14,730
但现在因为他们两个都在

1195
00:47:14,730 --> 00:47:16,260
正确的闩锁中只有一个会

1196
00:47:16,260 --> 00:47:19,380
一次进行所以现在 25

1197
00:47:19,380 --> 00:47:21,420
说想要她的人 25 他首先到达那里

1198
00:47:21,420 --> 00:47:24,240
他插入这个并分裂然后 24 被

1199
00:47:24,240 --> 00:47:26,790
允许运行它得到 在这里

1200
00:47:26,790 --> 00:47:28,620
它不在乎它是否已经

1201
00:47:28,620 --> 00:47:31,200
再次分裂 这是

1202
00:47:31,200 --> 00:47:32,970
逻辑正确性和

1203
00:47:32,970 --> 00:47:34,860
逻辑视图和物理视图之间的一个很好

1204
00:47:34,860 --> 00:47:37,770


1205
00:47:37,770 --> 00:47:39,750


1206
00:47:39,750 --> 00:47:40,920
的例子 哦，我试着把它放在这里，

1207
00:47:40,920 --> 00:47:42,240
所以确保下次我把它放在这里，

1208
00:47:42,240 --> 00:47:43,200
因为我

1209
00:47:43,200 --> 00:47:44,610
第一次听不到我想要准确地进入这个

1210
00:47:44,610 --> 00:47:47,250
页面你不关心每次

1211
00:47:47,250 --> 00:47:48,420
你进入它你是

1212
00:47:48,420 --> 00:47:50,160
从头开始做这个遍历，你

1213
00:47:50,160 --> 00:47:52,380
不在乎你是怎么得到的 e 之前，所以

1214
00:47:52,380 --> 00:47:55,170
在分裂时插入 25 次或 24 次插入并不重要，

1215
00:47:55,170 --> 00:47:56,640
然后分裂也

1216
00:47:56,640 --> 00:47:58,770
没关系它仍然是平衡的并且

1217
00:47:58,770 --> 00:48:06,060
仍然正确是正确的所以他说

1218
00:48:06,060 --> 00:48:07,500
24 的第二次反转

1219
00:48:07,500 --> 00:48:09,990
不需要正确的闩锁 因为 25

1220
00:48:09,990 --> 00:48:12,450
已经把它分开了，所以

1221
00:48:12,450 --> 00:48:13,860
这更昂贵，但

1222
00:48:13,860 --> 00:48:16,620
替代方案是什么，替代方案是

1223
00:48:16,620 --> 00:48:17,940
每次都采用正确的垃圾锁存器，

1224
00:48:17,940 --> 00:48:20,580
所以乐观并不完美，我们

1225
00:48:20,580 --> 00:48:22,440
不能保证总是做

1226
00:48:22,440 --> 00:48:24,000
我们需要做的最少的工作 因为

1227
00:48:24,000 --> 00:48:26,370
当然如果我在这种情况下再次在这里

1228
00:48:26,370 --> 00:48:27,540
我的节点真的很小所以

1229
00:48:27,540 --> 00:48:29,520
如果我插入很多

1230
00:48:29,520 --> 00:48:32,940
我会分裂很多所以我会浪费很多很多周期

1231
00:48:32,940 --> 00:48:35,070
做很多浪费的工作应该

1232
00:48:35,070 --> 00:48:36,630
逆转 找出我需要回来并

1233
00:48:36,630 --> 00:48:39,810
采取正确的闩锁，所以在实践中，如果

1234
00:48:39,810 --> 00:48:41,070
争用率很高，

1235
00:48:41,070 --> 00:48:43,170
因此乐观的假设是不正确的，

1236
00:48:43,170 --> 00:48:45,030
你实际上会

1237
00:48:45,030 --> 00:48:47,280
比做悲观的事情慢，但对于

1238
00:48:47,280 --> 00:48:49,190
这些数据结构一般来说

1239
00:48:49,190 --> 00:48:50,880
可能在这里谈论

1240
00:48:50,880 --> 00:48:52,520
乐观的人实际上是

1241
00:48:52,520 --> 00:48:56,370
最好的哈希表的东西我

1242
00:48:56,370 --> 00:48:58,410
实际上没有看到数字在这种

1243
00:48:58,410 --> 00:49:03,420
情况下通常

1244
00:49:03,420 --> 00:49:05,520


1245
00:49:05,520 --> 00:49:08,610
是在页面上使用闩锁的悲观方法这实际上非常

1246
00:49:08,610 --> 00:49:10,920
好 因为这很简单，因为这不会

1247
00:49:10,920 --> 00:49:12,810
使粒度更细，而且我们

1248
00:49:12,810 --> 00:49:14,970
会咧嘴笑，但这取决于很多

1249
00:49:14,970 --> 00:49:16,260
事情，这取决于工作量是多少

1250
00:49:16,260 --> 00:49:18,210
我们插入大量查找大量

1251
00:49:18,210 --> 00:49:21,180
删除大量取决于你知道

1252
00:49:21,180 --> 00:49:23,310
分布我们的价值取决于

1253
00:49:23,310 --> 00:49:26,580
我们拥有多少核心它

1254
00:49:26,580 --> 00:49:28,980
在实践中变化很大，尽管大多数数据系统

1255
00:49:28,980 --> 00:49:30,360
只是选择一种方法，他们不会

1256
00:49:30,360 --> 00:49:32,370
尝试自适应，因为从

1257
00:49:32,370 --> 00:49:33,450
工程的角度来看，这是一种更复杂的方式

1258
00:49:33,450 --> 00:49:37,850
是的，

1259
00:49:42,730 --> 00:49:45,280
所以他对人们说 她知道

1260
00:49:45,280 --> 00:49:47,490


1261
00:49:47,490 --> 00:49:55,990
你不能像在页表中那样使用低级插槽闩锁，因为

1262
00:49:55,990 --> 00:50:00,280
你可以修改你可以

1263
00:50:00,280 --> 00:50:02,980
修改

1264
00:50:02,980 --> 00:50:05,349
索引本身的物理结构所以所以我

1265
00:50:05,349 --> 00:50:09,030
起来了 约会指针就像如果我

1266
00:50:09,030 --> 00:50:11,200
喜欢如果我需要拆分合并并且我

1267
00:50:11,200 --> 00:50:13,630
需要在这个节点中为所有键提供闩锁

1268
00:50:13,630 --> 00:50:16,599
以便移动

1269
00:50:16,599 --> 00:50:18,910
它们所以一般你只需要一个

1270
00:50:18,910 --> 00:50:21,369
闩锁整个页面我认为 是的，我

1271
00:50:21,369 --> 00:50:25,420
可以仔细检查一下，虽然它使

1272
00:50:25,420 --> 00:50:31,900
事情变得更复杂，好吧，所以

1273
00:50:31,900 --> 00:50:33,609
再次重申我们正在尝试

1274
00:50:33,609 --> 00:50:36,790
再次讨论的内容，以便

1275
00:50:36,790 --> 00:50:38,050
搜索更好的锁

1276
00:50:38,050 --> 00:50:39,910
闩锁算法与

1277
00:50:39,910 --> 00:50:43,000
插入删除之前相同

1278
00:50:43,000 --> 00:50:45,130
如果它失败，它会让你一直复发，

1279
00:50:45,130 --> 00:50:46,119
然后你回来并

1280
00:50:46,119 --> 00:50:50,260
重新开始，所以这就是我

1281
00:50:50,260 --> 00:50:52,300
之前所说的关于我们如何

1282
00:50:52,300 --> 00:50:54,280
假设大部分时间在下降的过程中真正的

1283
00:50:54,280 --> 00:50:55,510
优势正在发生

1284
00:50:55,510 --> 00:50:56,770
足够好，但我们不必

1285
00:50:56,770 --> 00:51:00,280
重新开始，因此，

1286
00:51:00,280 --> 00:51:02,369
如果我们正确选择并错误预测，

1287
00:51:02,369 --> 00:51:05,980
那么您需要第

1288
00:51:05,980 --> 00:51:07,450
一次我们失败只是浪费工作，

1289
00:51:07,450 --> 00:51:09,369
我们只是在燃烧周期，所以我们”

1290
00:51:09,369 --> 00:51:10,599
不克 将获得我们可能真正想要的更好的可扩展性

1291
00:51:10,599 --> 00:51:13,329
或并发性，但

1292
00:51:13,329 --> 00:51:14,560
我会在实践中说这是

1293
00:51:14,560 --> 00:51:17,970
这通常很好，

1294
00:51:17,970 --> 00:51:20,440
所以接下来要讨论的是

1295
00:51:20,440 --> 00:51:23,829
我们如何实际支持叶无扫描，所以在

1296
00:51:23,829 --> 00:51:25,869
我的例子中 到目前为止，我已经用

1297
00:51:25,869 --> 00:51:28,030
B+ 树显示，就像在哈希表中一样，所有

1298
00:51:28,030 --> 00:51:29,800
的遍历都在一个方向上，

1299
00:51:29,800 --> 00:51:32,140
它们总是从上到下，所以

1300
00:51:32,140 --> 00:51:34,240
永远不会有任何死锁，因为我

1301
00:51:34,240 --> 00:51:36,010
从来没有尝试

1302
00:51:36,010 --> 00:51:38,200
从底部到最后的线程 top 在相反的

1303
00:51:38,200 --> 00:51:39,670
方向并尝试保持闩锁，

1304
00:51:39,670 --> 00:51:41,260
该闩锁保持另一个线程一次正确的闩锁，

1305
00:51:41,260 --> 00:51:42,690


1306
00:51:42,690 --> 00:51:45,910
所以如果现在我们想开始

1307
00:51:45,910 --> 00:51:47,890
扫描叶节点，事情变得

1308
00:51:47,890 --> 00:51:49,060
更加复杂，因为现在我们有

1309
00:51:49,060 --> 00:51:50,920
东西从上到下，

1310
00:51:50,920 --> 00:51:53,650
也从左到右 所以在这种情况下

1311
00:51:53,650 --> 00:51:55,200
可能会发生死锁

1312
00:51:55,200 --> 00:51:57,630
所以让我们看看我们如何处理这个所以

1313
00:51:57,630 --> 00:51:59,130
我要说的第一件事是原始的

1314
00:51:59,130 --> 00:52:01,500
这是在原始 B+ 树

1315
00:52:01,500 --> 00:52:03,059
在叶节点上没有这些兄弟指针之前

1316
00:52:03,059 --> 00:52:05,220
现在大多数人的

1317
00:52:05,220 --> 00:52:06,569
街道都有这个，这

1318
00:52:06,569 --> 00:52:08,460
来自于 CMU 发明的 be 链接树，

1319
00:52:08,460 --> 00:52:11,549
所以假设我有这样一个

1320
00:52:11,549 --> 00:52:13,619
非常简单的树，我有

1321
00:52:13,619 --> 00:52:15,270
一个线程想要找到所有

1322
00:52:15,270 --> 00:52:18,030
小于 4 的键，所以我们拿一根芦苇 锁定

1323
00:52:18,030 --> 00:52:20,460
根在这里我忘记

1324
00:52:20,460 --> 00:52:23,040
了 C 上的关系我们可以在 a 上释放实数

1325
00:52:23,040 --> 00:52:25,049
a 现在我们想开始

1326
00:52:25,049 --> 00:52:27,240
扫描，所以说我们

1327
00:52:27,240 --> 00:52:29,220
颠倒了这个节点中所有键的顺序，

1328
00:52:29,220 --> 00:52:30,990
但现在我们认识到我们 必须

1329
00:52:30,990 --> 00:52:34,619
继续在这里，所以就像

1330
00:52:34,619 --> 00:52:36,569
以前一样，当我们

1331
00:52:36,569 --> 00:52:39,660
想要水平移动时，我们不会释放

1332
00:52:39,660 --> 00:52:41,309
我们持有的闩锁，直到我们获得

1333
00:52:41,309 --> 00:52:44,190
了我们想要的闩锁，所以在这种情况下

1334
00:52:44,190 --> 00:52:47,160
，为了获得闩锁 在 BI

1335
00:52:47,160 --> 00:52:49,890
上，一旦我获得 C 上的闩锁，我

1336
00:52:49,890 --> 00:52:51,240
就可以左右摆动，然后释放

1337
00:52:51,240 --> 00:52:56,790
C 上的闩锁，因此在这种情况下，所有

1338
00:52:56,790 --> 00:52:58,339
小于四个的键基本上

1339
00:52:58,339 --> 00:53:00,329
是从小于向前到负

1340
00:53:00,329 --> 00:53:02,010
无穷大的键，所以我们知道我们 '''s going

1341
00:53:02,010 --> 00:53:04,260
to have to hit the we want to ge 到树的这一

1342
00:53:04,260 --> 00:53:07,140
端，

1343
00:53:07,140 --> 00:53:08,790
您还可以使用其他技巧，例如使用栅栏

1344
00:53:08,790 --> 00:53:11,309
键或提示键，基本上可以告诉

1345
00:53:11,309 --> 00:53:13,920
您此处此节点的此侧的键是什么

1346
00:53:13,920 --> 00:53:15,059
，并告诉您

1347
00:53:15,059 --> 00:53:16,799
是否甚至需要跳跃 有

1348
00:53:16,799 --> 00:53:18,990
或没有，但对于这个例子，我们不

1349
00:53:18,990 --> 00:53:21,930
担心，所以让我们

1350
00:53:21,930 --> 00:53:23,280
让它更复杂，说现在我们有

1351
00:53:23,280 --> 00:53:25,290
另一个线程想要

1352
00:53:25,290 --> 00:53:27,630
找到大于一个的所有键很好，

1353
00:53:27,630 --> 00:53:28,920
没关系，所以他们两个都开始

1354
00:53:28,920 --> 00:53:30,630
他们 两个人都想获得可能发生的 Reed 闩锁，

1355
00:53:30,630 --> 00:53:32,460
因为这可以

1356
00:53:32,460 --> 00:53:34,650
在他们之间共享，然后他们这个

1357
00:53:34,650 --> 00:53:36,599
人在 B 上复发 这个人

1358
00:53:36,599 --> 00:53:38,760
在看到这很好然后他们

1359
00:53:38,760 --> 00:53:41,339
扫描所有 raqi 并且他们开始

1360
00:53:41,339 --> 00:53:45,660
穿越并为 这里 B

1361
00:53:45,660 --> 00:53:48,119
想要锁定 CC 想要锁定

1362
00:53:48,119 --> 00:53:49,410
可以正确共享的 B，因为 Reed

1363
00:53:49,410 --> 00:53:51,900
锁定，所以在这一点上，他们都

1364
00:53:51,900 --> 00:53:54,180
获得了交替的一个，所以不同

1365
00:53:54,180 --> 00:53:56,309
的那个很好，然后他们滑过

1366
00:53:56,309 --> 00:53:58,260
，现在他们释放 t 他锁住它它

1367
00:53:58,260 --> 00:54:00,809
只是来自所以因为 Reed 锁

1368
00:54:00,809 --> 00:54:01,619
可以共享

1369
00:54:01,619 --> 00:54:04,319
所以没有死锁所以这

1370
00:54:04,319 --> 00:54:06,799
很好

1371
00:54:06,990 --> 00:54:09,160
所以让我们现在谈谈当我们没有

1372
00:54:09,160 --> 00:54:11,800
我们的权利所以弗雷德一个

1373
00:54:11,800 --> 00:54:14,290
飞跃和威胁是什么 想要找到所有

1374
00:54:14,290 --> 00:54:17,080
大于 1 的键，所以在

1375
00:54:17,080 --> 00:54:20,290
他们开始时，他们都

1376
00:54:20,290 --> 00:54:22,000
可以将簧片闩锁放在一个上，因为我们正在

1377
00:54:22,000 --> 00:54:24,460
做最后一次螃蟹的乐观闩锁耦合

1378
00:54:24,460 --> 00:54:27,340
技术，在我的

1379
00:54:27,340 --> 00:54:29,230
根上，我总是唱簧闩锁 并且

1380
00:54:29,230 --> 00:54:32,620
只在子节点上获得正确的闩锁，

1381
00:54:32,620 --> 00:54:34,300
所以一开始他们

1382
00:54:34,300 --> 00:54:36,160
都有一个很好的簧片闩锁，

1383
00:54:36,160 --> 00:54:38,470
然后他们都在这里得到

1384
00:54:38,470 --> 00:54:40,570
真正的 a on on sorry thread one

1385
00:54:40,570 --> 00:54:42,610
get thread two 得到真正的 Jumby thread

1386
00:54:42,610 --> 00:54:45,010
one 获得正确的闩锁，因为

1387
00:54:45,010 --> 00:54:47,040
那是它想要删除的条目，

1388
00:54:47,040 --> 00:54:52,330
所以现在假设 t2 想要

1389
00:54:52,330 --> 00:54:53,590
扫描，因为它飞行的所有奶油

1390
00:54:53,590 --> 00:54:56,590
奶酪都大于 1，所以在它可以

1391
00:54:56,590 --> 00:54:59,860
跳入 C 之前，它必须获得正确的

1392
00:54:59,860 --> 00:55:01,890
闩锁 C 我们很抱歉 读 lachen C

1393
00:55:01,890 --> 00:55:05,620
但它不能那样做，因为第一个

1394
00:55:05,620 --> 00:55:08,490
线程在这个节点上有正确的闩锁

1395
00:55:08,490 --> 00:55:15,610
所以应该发生什么 他

1396
00:55:15,610 --> 00:55:20,160
说确定 等等 我们还能做什么

1397
00:55:20,160 --> 00:55:23,220
有三个选择对 我们可以

1398
00:55:23,220 --> 00:55:25,270
再次等待 考虑一下

1399
00:55:25,270 --> 00:55:29,260
我们只是说我们可以杀死

1400
00:55:29,260 --> 00:55:31,030
自己然后重新开始行动

1401
00:55:31,030 --> 00:55:33,760
或者它可能像一个歹徒并

1402
00:55:33,760 --> 00:55:35,550
试图偷它 你知道 拿过来

1403
00:55:35,550 --> 00:55:37,720
朝它头部开枪 拿走他的钱包

1404
00:55:37,720 --> 00:55:41,070
拿开它的闩锁 然后接管

1405
00:55:41,250 --> 00:55:43,300
好吧 如果您认为

1406
00:55:43,300 --> 00:55:48,250
我们应该等待，请举手 如果

1407
00:55:48,250 --> 00:55:51,030
您认为我们应该自杀，请举手 25% 如果您认为我们应该自杀，

1408
00:55:51,270 --> 00:55:53,860
请举手 更不要举手，如果您认为

1409
00:55:53,860 --> 00:55:56,550
我们应该成为歹徒并偷走它

1410
00:55:56,550 --> 00:56:02,470
没人知道这里有什么问题

1411
00:56:02,470 --> 00:56:03,910
关于这个

1412
00:56:03,910 --> 00:56:06,210
线程，

1413
00:56:07,290 --> 00:56:11,530
没什么不对的，因为所有的锁存器

1414
00:56:11,530 --> 00:56:12,820
只是数据结构中的一些位

1415
00:56:12,820 --> 00:56:13,780
，然后

1416
00:56:13,780 --> 00:56:15,550
有人需要它，无论是读模式

1417
00:56:15,550 --> 00:56:18,370
还是写模式，所以系统中没有全局视图

1418
00:56:18,370 --> 00:56:20,290
来告诉你这是什么

1419
00:56:20,290 --> 00:56:22,960
另一个线程正在处理数据库

1420
00:56:22,960 --> 00:56:25,270
处于高级别确保它

1421
00:56:25,270 --> 00:56:27,790


1422
00:56:27,790 --> 00:56:29,710


1423
00:56:29,710 --> 00:56:31,270


1424
00:56:31,270 --> 00:56:32,260
说不 信息，

1425
00:56:32,260 --> 00:56:34,300
因为这对我们来说太昂贵了，

1426
00:56:34,300 --> 00:56:37,150
无法再次查找我们希望这些

1427
00:56:37,150 --> 00:56:38,500
操作非常快，因为

1428
00:56:38,500 --> 00:56:39,880
我们在这个人身上持有这个闩锁，

1429
00:56:39,880 --> 00:56:42,040
你知道，当我们试图

1430
00:56:42,040 --> 00:56:46,650
获得另一个闩锁时，我们可以等待

1431
00:56:46,650 --> 00:56:49,750
这也可能是一个坏主意，因为我们

1432
00:56:49,750 --> 00:56:52,000
不知道这个人在做什么

1433
00:56:52,000 --> 00:56:53,980
我们不知道你是否知道

1434
00:56:53,980 --> 00:56:55,180
在我们的例子中在这种情况下它只是

1435
00:56:55,180 --> 00:56:56,740
删除了这个记录有一个

1436
00:56:56,740 --> 00:57:00,130
键这意味着它已经完成但我们 不

1437
00:57:00,130 --> 00:57:01,750
知道它也可能试图

1438
00:57:01,750 --> 00:57:04,330
获取 B 上的闩锁，因此

1439
00:57:04,330 --> 00:57:07,510
我陷入了僵局，所以最简单的事情

1440
00:57:07,510 --> 00:57:08,920
结果是最好的事情是

1441
00:57:08,920 --> 00:57:10,510
我们说我们不想再活了，

1442
00:57:10,510 --> 00:57:13,330
我们使用 abort 和 杀死我们自己，然后

1443
00:57:13,330 --> 00:57:18,040
重新开始操作吧，这就是

1444
00:57:18,040 --> 00:57:19,210
做最快的事情，

1445
00:57:19,210 --> 00:57:21,340
因为这些闩锁又是超级愚蠢的，就像

1446
00:57:21,340 --> 00:57:22,660
没有关于谁

1447
00:57:22,660 --> 00:57:24,490
拿着它们以及它们在做什么的信息，

1448
00:57:24,490 --> 00:57:25,990
而不是试图推理任何

1449
00:57:25,990 --> 00:57:27,730
我们只想中途停止

1450
00:57:27,730 --> 00:57:31,930
我们正在做的事情并重新启动并假设它们

1451
00:57:31,930 --> 00:57:33,190
有时间回来然后我们想要的最后一个

1452
00:57:33,190 --> 00:57:36,880
现在在那里是的因为它

1453
00:57:36,880 --> 00:57:38,500
比等待更好所以是的你可以

1454
00:57:38,500 --> 00:57:40,870
等待一点超时然后

1455
00:57:40,870 --> 00:57:42,970
最终你想要的闩锁

1456
00:57:42,970 --> 00:57:43,990
不可用然后你就杀了

1457
00:57:43,990 --> 00:57:45,940
自己这是一个 你也可以这样做

1458
00:57:45,940 --> 00:57:47,710
，但就像我说的，也许

1459
00:57:47,710 --> 00:58:00,070
等几微秒，所以他的声明又

1460
00:58:00,070 --> 00:58:03,340
回到了这里 他说如果我们

1461
00:58:03,340 --> 00:58:08,020
在 c4 线程上，一个线程没有

1462
00:58:08,020 --> 00:58:11,670
一个正确的闩锁

1463
00:58:14,770 --> 00:58:18,410
人们他就是那样

1464
00:58:18,410 --> 00:58:31,700
桌上的人很酷，所以他的说法

1465
00:58:31,700 --> 00:58:36,770
是，如果 C 真的想朝

1466
00:58:36,770 --> 00:58:38,540
这个方向前进并进行一些修改

1467
00:58:38,540 --> 00:58:40,490
，则不必正确闩锁

1468
00:58:40,490 --> 00:58:44,780
AB，因此我

1469
00:58:44,780 --> 00:58:46,130
无法消除这种威胁 这里 

1470
00:58:46,130 --> 00:58:49,490
穿过众所周知的权利，所以说蓝色

1471
00:58:49,490 --> 00:58:51,320
线程首先开始它得到真正的一个

1472
00:58:51,320 --> 00:58:52,700
CH 来到这里并得到

1473
00:58:52,700 --> 00:58:55,490
它想要在 B 上的红色闩锁然后 t1 开始

1474
00:58:55,490 --> 00:58:58,550
得到正确的闩锁在右边

1475
00:58:58,550 --> 00:59:02,330
任何人得到正确的闩锁 在这个上所以

1476
00:59:02,330 --> 00:59:05,360
它不知道你不知道它就像

1477
00:59:05,360 --> 00:59:19,400
它可以以任何顺序出现是的所以这

1478
00:59:19,400 --> 00:59:20,900
该死的这是真的我们可以在

1479
00:59:20,900 --> 00:59:23,090
这里饿死它在这里它

1480
00:59:23,090 --> 00:59:24,290
说我不知道我可以 没有得到我

1481
00:59:24,290 --> 00:59:25,310
想要的 我要

1482
00:59:25,310 --> 00:59:28,870
自杀 和你一样再试一次 是的

1483
00:59:28,870 --> 00:59:30,650
有不同的方法来处理

1484
00:59:30,650 --> 00:59:35,680
这会在实践中增加额外的开销

1485
00:59:35,680 --> 00:59:41,840
我认为我的后续发布人员

1486
00:59:41,840 --> 00:59:42,980
不会做任何事情 我不知道

1487
00:59:42,980 --> 00:59:45,350
商业广告是什么 伙计们，但你可以做到，你

1488
00:59:45,350 --> 00:59:46,760
可以想象如何去做这只是

1489
00:59:46,760 --> 00:59:48,560
额外的工作，它可能不值得

1490
00:59:48,560 --> 00:59:49,790
这样做简单的事情可能是做最好的

1491
00:59:49,790 --> 00:59:56,420
事情是的你喜欢整个

1492
00:59:56,420 --> 01:00:02,210
程序我认为这个过程哦不不不

1493
01:00:02,210 --> 01:00:05,990
不 像这样像这样像一个

1494
01:00:05,990 --> 01:00:09,170
操作所以这就像找到所有

1495
01:00:09,170 --> 01:00:11,260
大于一个的键我们重新统计 rt，

1496
01:00:11,260 --> 01:00:15,620
实际上在下一张幻灯片下实际上是完美的

1497
01:00:15,620 --> 01:00:18,620
所以考虑这个的

1498
01:00:18,620 --> 01:00:19,970
方式是我们有这个数据库

1499
01:00:19,970 --> 01:00:21,200
系统我们有

1500
01:00:21,200 --> 01:00:23,090
这个调用查询的执行引擎它说

1501
01:00:23,090 --> 01:00:25,190
哦为了让我需要

1502
01:00:25,190 --> 01:00:27,650
这个查询的两个男孩回答 此查询我必须

1503
01:00:27,650 --> 01:00:28,069


1504
01:00:28,069 --> 01:00:30,109
转到索引并执行

1505
01:00:30,109 --> 01:00:32,539
大于 1 的最终键，然后它会在索引上调用它，

1506
01:00:32,539 --> 01:00:34,670
并且基本上有一个重试

1507
01:00:34,670 --> 01:00:37,279
循环位于索引内，我不断

1508
01:00:37,279 --> 01:00:40,400
重试该循环以对该索引执行该操作

1509
01:00:40,400 --> 01:00:45,079
，直到它成功四个

1510
01:00:45,079 --> 01:00:46,670
插入或可能

1511
01:00:46,670 --> 01:00:48,979
违反完整性约束的东西是的，你

1512
01:00:48,979 --> 01:00:50,779
有一张支票说你知道我试图

1513
01:00:50,779 --> 01:00:52,519
插入但我不能因为它会

1514
01:00:52,519 --> 01:00:53,989
违反完整性压力而不是因为

1515
01:00:53,989 --> 01:00:55,789
我无法获得我想要的闩锁，在

1516
01:00:55,789 --> 01:00:57,589
这种情况下 你中止了你

1517
01:00:57,589 --> 01:00:59,599
的行动，但总的来说，你

1518
01:00:59,599 --> 01:01:00,890
只是让你继续尝试这种不敬的行为，因为

1519
01:01:00,890 --> 01:01:02,959
最终它会通过，但就他

1520
01:01:02,959 --> 01:01:04,249
而言，你可能会导致饥饿或

1521
01:01:04,249 --> 01:01:06,199
只是燃烧很多周期 试图让

1522
01:01:06,199 --> 01:01:07,489
你知道火炬底部，然后尝试

1523
01:01:07,489 --> 01:01:08,779
获得你永远无法获得的闩锁，

1524
01:01:08,779 --> 01:01:11,749


1525
01:01:11,749 --> 01:01:13,249
但当你摆脱这个时，我主要的主要收获

1526
01:01:13,249 --> 01:01:16,729
是因为这里有可能

1527
01:01:16,729 --> 01:01:18,410
陷入僵局，但我们不知道那里

1528
01:01:18,410 --> 01:01:21,380
另一个线程在做什么 老鼠 我们

1529
01:01:21,380 --> 01:01:22,519
不会非常保守 只是

1530
01:01:22,519 --> 01:01:23,719
立即杀死自己 我们可以稍等

1531
01:01:23,719 --> 01:01:25,579
一下 但我们不想

1532
01:01:25,579 --> 01:01:26,839
推理他们正在尝试做什么

1533
01:01:26,839 --> 01:01:28,099
我们只是说我们无法得到 在那些闩锁中

1534
01:01:28,099 --> 01:01:31,069
并真正重试，因为上面没有

1535
01:01:31,069 --> 01:01:32,390
其他任何东西会说哦

1536
01:01:32,390 --> 01:01:33,829
，当我们

1537
01:01:33,829 --> 01:01:40,699
通过杀死你们中的一个人来打破它时会出现僵局

1538
01:01:40,699 --> 01:01:42,319


1539
01:01:42,319 --> 01:01:44,479


1540
01:01:44,479 --> 01:01:46,940
是的，在这种情况下，这是这个人有

1541
01:01:46,940 --> 01:01:48,319
一个正确的闩锁，我不能，我无法得到

1542
01:01:48,319 --> 01:01:58,369
真正的失败，

1543
01:01:58,369 --> 01:01:59,690
所以那是黑帮一个正确的，所以

1544
01:01:59,690 --> 01:02:01,910
说这个人有真正的闩锁，也许我

1545
01:02:01,910 --> 01:02:03,829
更喜欢阅读阅读 或写作，

1546
01:02:03,829 --> 01:02:06,019
因此我想杀死这个人 当然

1547
01:02:06,019 --> 01:02:07,249
你可以做到，但是你如何

1548
01:02:07,249 --> 01:02:08,569
在你的代码中实际实现它，

1549
01:02:08,569 --> 01:02:10,369
现在你需要打断这个

1550
01:02:10,369 --> 01:02:13,549
人所做的任何事情，然后去

1551
01:02:13,549 --> 01:02:16,039
窃取非常困难的闩锁，

1552
01:02:16,039 --> 01:02:17,599
因为我们再次这样做这些

1553
01:02:17,599 --> 01:02:19,489
小关键部分我不知道 不想

1554
01:02:19,489 --> 01:02:20,690
检查一个全局变量说

1555
01:02:20,690 --> 01:02:22,989
有人讨厌我，我和我应该死了

1556
01:02:22,989 --> 01:02:25,470


1557
01:02:25,470 --> 01:02:28,140
所以这有点陈词滥调，只是

1558
01:02:28,140 --> 01:02:51,450
它在后面不值得

1559
01:02:51,450 --> 01:02:53,760


1560
01:02:53,760 --> 01:02:55,680
做删除我有

1561
01:02:55,680 --> 01:02:57,780
我淹没在欺诈中修改

1562
01:02:57,780 --> 01:03:01,080
路线如何再次运作良好，

1563
01:03:01,080 --> 01:03:02,940
就像我必须正确对待

1564
01:03:02,940 --> 01:03:05,220
所以当我使用乐观的睫毛螃蟹降落在这里时

1565
01:03:05,220 --> 01:03:07,140
我会认识到哦，

1566
01:03:07,140 --> 01:03:09,330
我将不得不合并 并修改我的

1567
01:03:09,330 --> 01:03:11,280
父母 我得回去拿它的

1568
01:03:11,280 --> 01:03:12,540
线索 所以黑人一直在排除

1569
01:03:12,540 --> 01:03:14,790
闩锁 所以贝克特

1570
01:03:14,790 --> 01:03:30,540
是的 我说如果我们在这里处于这种情况

1571
01:03:30,540 --> 01:03:40,050
是的 我们将做一些

1572
01:03:40,050 --> 01:03:42,090
需要的操作 修改一个头部，所以我们刚刚

1573
01:03:42,090 --> 01:03:44,210
获得了blo  cks 在所有孩子身上，

1574
01:03:44,210 --> 01:03:47,700
我们知道，作为父母离开，然后

1575
01:03:47,700 --> 01:03:49,380
我们从未真正开始阅读

1576
01:03:49,380 --> 01:03:56,790
操作开始，因为我们不得不

1577
01:03:56,790 --> 01:03:58,920
担心这一点是的，他实际上已经

1578
01:03:58,920 --> 01:04:17,090
破解了，所以这就是正确的，所以

1579
01:04:17,480 --> 01:04:21,660
你说的是 所以如果我知道

1580
01:04:21,660 --> 01:04:23,250
这里有任何视图按钮，因此我可能

1581
01:04:23,250 --> 01:04:24,360
不得不在这里溢出

1582
01:04:24,360 --> 01:04:26,190
我想获得一个正确的闩锁

1583
01:04:26,190 --> 01:04:28,530
，然后我是，然后从

1584
01:04:28,530 --> 01:04:31,590
我所有的孩子那里获得一个正确的闩锁，然后这

1585
01:04:31,590 --> 01:04:32,940
将允许我 做

1586
01:04:32,940 --> 01:04:34,830
我想做的任何修改，包括

1587
01:04:34,830 --> 01:04:36,300
更新兄弟指针，这很

1588
01:04:36,300 --> 01:04:37,859
棘手

1589
01:04:37,859 --> 01:04:39,849
，然后你说这可能会

1590
01:04:39,849 --> 01:04:41,230
导致僵局，因为有人可能

1591
01:04:41,230 --> 01:04:44,130
会朝着不同的方向前进，

1592
01:04:50,789 --> 01:05:08,289
是的，是的，所以你自杀了，

1593
01:05:08,289 --> 01:05:10,799
没有获得步行的意义

1594
01:05:10,799 --> 01:05:14,710
是的，所以如果这个人有分裂，我也

1595
01:05:14,710 --> 01:05:16,569
必须更新这个兄弟指针，所以

1596
01:05:16,569 --> 01:05:18,190
你也需要获得这个人的闩锁，

1597
01:05:18,190 --> 01:05:20,140
但同样最简单的

1598
01:05:20,140 --> 01:05:23,289
事情就像我可以做的另一件事 -

1599
01:05:23,289 --> 01:05:25,029
比如说两个线程完全相同

1600
01:05:25,029 --> 01:05:26,789
到 企业在实践中完全相同的闩锁

1601
01:05:26,789 --> 01:05:28,539
你知道没有

1602
01:05:28,539 --> 01:05:31,299
什么不是我的绝对

1603
01:05:31,299 --> 01:05:33,339
锁步意思就像如果你同时购买

1604
01:05:33,339 --> 01:05:34,599
它们真的回来并

1605
01:05:34,599 --> 01:05:36,039
遇到相同的冲突它们

1606
01:05:36,039 --> 01:05:37,630
彼此会略有不同但即使

1607
01:05:37,630 --> 01:05:38,829
如此你也可以说 哦，我以前试过这个

1608
01:05:38,829 --> 01:05:40,660
，但我没能做到让我

1609
01:05:40,660 --> 01:05:42,640
退缩一点，这样

1610
01:05:42,640 --> 01:05:44,589
至少会交错出现然后我

1611
01:05:44,589 --> 01:05:46,150
再次避免这个问题最简单的

1612
01:05:46,150 --> 01:05:47,470
说法是我没有得到最后一个我 想

1613
01:05:47,470 --> 01:05:49,299
立即杀死自己，避免

1614
01:05:49,299 --> 01:05:53,140
所有死锁，

1615
01:05:53,140 --> 01:05:54,519
当我们稍后讨论今天的事务锁定时，情况会有所不同，

1616
01:05:54,519 --> 01:05:56,160


1617
01:05:56,160 --> 01:05:59,799
因为我们将有其他东西可以

1618
01:05:59,799 --> 01:06:01,539
为我们解决死锁，但我们

1619
01:06:01,539 --> 01:06:03,839
这里没有，

1620
01:06:03,839 --> 01:06:07,119
所以最后 我想

1621
01:06:07,119 --> 01:06:11,380
结束讨论的事情

1622
01:06:11,380 --> 01:06:14,559
是处理溢出的额外优化，

1623
01:06:14,559 --> 01:06:16,930
这再次来自 B 链接

1624
01:06:16,930 --> 01:06:19,180
，剥离树想要首先

1625
01:06:19,180 --> 01:06:20,829
发明兄弟指针的东西，

1626
01:06:20,829 --> 01:06:22,809
然后 现在每个人都在 B+

1627
01:06:22,809 --> 01:06:24,489
树中至少在一个

1628
01:06:24,489 --> 01:06:28,299
方向上这样做，所以通常每次

1629
01:06:28,299 --> 01:06:29,589
必须进行溢出时，您都必须

1630
01:06:29,589 --> 01:06:32,440
在节点中进行拆分 我们必须更新三个

1631
01:06:32,440 --> 01:06:34,630
音符 我们必须更新

1632
01:06:34,630 --> 01:06:36,339
节点 split 我们必须创建一个新节点

1633
01:06:36,339 --> 01:06:38,650
以使其溢出，然后我们必须

1634
01:06:38,650 --> 01:06:41,259
更新至少一个父节点或一个我们的

1635
01:06:41,259 --> 01:06:43,359
祖先 - 现在

1636
01:06:43,359 --> 01:06:45,130
为我们添加的新节点容纳新的分隔符键，

1637
01:06:45,130 --> 01:06:48,489
因此 B 链接树家伙进行了

1638
01:06:48,489 --> 01:06:50,680
优化 一次流的

1639
01:06:50,680 --> 01:06:51,170
叶

1640
01:06:51,170 --> 01:06:54,470
节点，你实际上推迟

1641
01:06:54,470 --> 01:06:56,780
更新父节点，这样你

1642
01:06:56,780 --> 01:07:00,020
就不想重新启动，这会重新

1643
01:07:00,020 --> 01:07:02,210
启动遍历，并一直执行悲观的

1644
01:07:02,210 --> 01:07:04,819
右锁存器，你只需要

1645
01:07:04,819 --> 01:07:07,420
更新一点全局信息

1646
01:07:07,420 --> 01:07:10,309
全局信息 用于

1647
01:07:10,309 --> 01:07:12,950
树的表并说任何时候有人

1648
01:07:12,950 --> 01:07:14,000
再次通过树的那部分时

1649
01:07:14,000 --> 01:07:16,880
这里是它希望你更新它的方式所以

1650
01:07:16,880 --> 01:07:18,410
让我们看看例子所以说我想

1651
01:07:18,410 --> 01:07:21,109
再次搜索键 25 我做乐观

1652
01:07:21,109 --> 01:07:22,549
闩锁crabbi  ng在下降的路上我得到了

1653
01:07:22,549 --> 01:07:27,609
真正的一个ch's我再次到达这里

1654
01:07:27,609 --> 01:07:31,430
当我在FI上获得正确的闩锁时

1655
01:07:31,430 --> 01:07:33,260
听到我会意识到

1656
01:07:33,260 --> 01:07:36,559
我将不得不分开但然后而不是

1657
01:07:36,559 --> 01:07:38,569
重新开始并采取正确的措施 闩锁我

1658
01:07:38,569 --> 01:07:42,200
只是放弃了读拉康看到我仍然

1659
01:07:42,200 --> 01:07:46,220
做我的插入并添加新的

1660
01:07:46,220 --> 01:07:49,220
新节点但是

1661
01:07:49,220 --> 01:07:51,880
我不必更新这个东西我只是有一个小的

1662
01:07:51,880 --> 01:07:54,770
全局全局表树

1663
01:07:54,770 --> 01:07:57,109
说如果你有的话 在这个节点上使用正确的

1664
01:07:57,109 --> 01:07:59,240
闩锁 看看这里的更改

1665
01:07:59,240 --> 01:08:01,369
我想要你 我希望你正确添加

1666
01:08:01,369 --> 01:08:05,089
这样下次

1667
01:08:05,089 --> 01:08:06,079
有人通过并使用正确的闩锁时，

1668
01:08:06,079 --> 01:08:08,390
他们会做一些额外的工作并完成

1669
01:08:08,390 --> 01:08:10,430
我们想要的更新和这个 仍然是

1670
01:08:10,430 --> 01:08:11,720
正确的，这仍然有效，

1671
01:08:11,720 --> 01:08:14,059
因为如果我出现并且现在

1672
01:08:14,059 --> 01:08:18,259
在 31 上进行查找，我会按照

1673
01:08:18,259 --> 01:08:21,170
向下的指针进行操作，并且所有

1674
01:08:21,170 --> 01:08:23,689
大于 23 的键的指针会将我放在此处

1675
01:08:23,689 --> 01:08:25,549
，现在我必须知道所有 好吧，

1676
01:08:25,549 --> 01:08:27,080
如果我正在寻找 31 扫描 o，我应该有这个溢出的东西

1677
01:08:27,080 --> 01:08:29,540
n longleaf note

1678
01:08:29,540 --> 01:08:34,299
这实际上是我正在寻找的内容 是

1679
01:08:39,609 --> 01:08:42,080
的 所以基本上 所以

1680
01:08:42,080 --> 01:08:44,359
现在在这个全球性的事情中有一个

1681
01:08:44,359 --> 01:08:45,500
任何人在他们第一次开始时都可以看到

1682
01:08:45,500 --> 01:08:48,109
的东西 顺便说一句，如果你正在做

1683
01:08:48,109 --> 01:08:50,330
修改然后你去 嗯，我看到采取

1684
01:08:50,330 --> 01:08:52,429
正确的闩锁工作，所以这家伙

1685
01:08:52,429 --> 01:08:55,040
现在想插入 33 我可以真正做到

1686
01:08:55,040 --> 01:08:57,290
一路向下到达 B 然后但是

1687
01:08:57,290 --> 01:08:59,630
现在 CI 会知道哦，为什么我被

1688
01:08:59,630 --> 01:09:00,830
告知我应该采取正确的闩锁 在这一点上，

1689
01:09:00,830 --> 01:09:03,920
让我继续这样做，现在

1690
01:09:03,920 --> 01:09:04,939
我完成了在

1691
01:09:04,939 --> 01:09:07,279
那里应用该更改的属性，然后

1692
01:09:07,279 --> 01:09:08,930
现在树被认为是有效的，

1693
01:09:08,930 --> 01:09:10,310
我采取正确的闩锁并

1694
01:09:10,310 --> 01:09:12,979
完成我的操作，因此它

1695
01:09:12,979 --> 01:09:14,600
就像而不是必须这样做

1696
01:09:14,600 --> 01:09:17,029
重新启动你更新这件事，

1697
01:09:17,029 --> 01:09:17,660
下次你经过

1698
01:09:17,660 --> 01:09:18,979
别人会为我照顾它

1699
01:09:18,979 --> 01:09:24,680
是的你会如何识别看到和 -

1700
01:09:24,680 --> 01:09:28,219
你的意思就像它是一个页面

1701
01:09:28,219 --> 01:09:30,979
ID 正确的逻辑裸体如果你要去

1702
01:09:30,979 --> 01:09:33,529
看你知道第 1 2 3 页由 w 是否

1703
01:09:33,529 --> 01:09:42,620
为我应用此更改 是的，您

1704
01:09:42,620 --> 01:09:48,790
是否感到抱歉，所以回到这里

1705
01:09:48,790 --> 01:09:52,670


1706
01:09:52,670 --> 01:09:54,469


1707
01:09:54,469 --> 01:09:56,150


1708
01:09:56,150 --> 01:09:59,210


1709
01:09:59,210 --> 01:10:01,810
往相反的方向走，

1710
01:10:01,810 --> 01:10:04,130
有不同的实现，但是如果

1711
01:10:04,130 --> 01:10:05,840
你想要双向兄弟

1712
01:10:05,840 --> 01:10:06,920
指针，是的，所以你必须更新

1713
01:10:06,920 --> 01:10:09,380
它，这会让事情变得更加

1714
01:10:09,380 --> 01:10:11,210
复杂，那么我可以在

1715
01:10:11,210 --> 01:10:24,080
课堂上展示的东西只是

1716
01:10:24,080 --> 01:10:27,590
一个 兄弟指针哦，是的，您

1717
01:10:27,590 --> 01:10:29,330
需要更新并说是的 7

1718
01:10:29,330 --> 01:10:31,390
角溢出的东西不再存在，

1719
01:10:31,390 --> 01:10:33,530
但实际上不再重要了，

1720
01:10:33,530 --> 01:10:34,070
实际上

1721
01:10:34,070 --> 01:10:35,480
您实际上可以保持正确，

1722
01:10:35,480 --> 01:10:37,610
因为如果我正在寻找更好的东西，则在上面

1723
01:10:37,610 --> 01:10:41,120
不等于 31 我

1724
01:10:41,120 --> 01:10:43,070
永远不会知道这个无论如何我

1725
01:10:43,070 --> 01:10:45,080
总是会得到这个所以你不需要你

1726
01:10:45,080 --> 01:10:49,630
实际上不必更新它是的

1727
01:10:59,810 --> 01:11:01,630
[音乐]

1728
01:11:01,630 --> 01:11:03,920
纠正他的大卫是这个的第一人

1729
01:11:03,920 --> 01:11:05,570
定位 fi 第

1730
01:11:05,570 --> 01:11:08,180
一个更新 see 的人应用了这个

1731
01:11:08,180 --> 01:11:09,770
更改，因为他们持有正确的

1732
01:11:09,770 --> 01:11:12,940
闩锁，这是一个原子操作

1733
01:11:14,059 --> 01:11:16,110
是正确的，否则可能会被更改

1734
01:11:16,110 --> 01:11:20,809


1735
01:11:20,809 --> 01:11:24,270


1736
01:11:24,270 --> 01:11:27,449


1737
01:11:27,449 --> 01:11:29,510
想做锁存的东西，

1738
01:11:29,510 --> 01:11:34,050
但半人马座很难做对我迷失

1739
01:11:34,050 --> 01:11:35,820
在兄弟指针上如何

1740
01:11:35,820 --> 01:11:39,929
保持同步这是另一包

1741
01:11:39,929 --> 01:11:42,139
我们不谈论这非常棘手

1742
01:11:42,139 --> 01:11:44,400
但再次正如我所说的好消息

1743
01:11:44,400 --> 01:11:46,590
是 因为这太难了，如果你

1744
01:11:46,590 --> 01:11:48,329
能做到这一点，人们会付给你很多

1745
01:11:48,329 --> 01:11:51,480
钱来在实践中做到这

1746
01:11:51,480 --> 01:11:54,270


1747
01:11:54,270 --> 01:11:55,829


1748
01:11:55,829 --> 01:11:57,119


1749
01:11:57,119 --> 01:11:58,739


1750
01:11:58,739 --> 01:12:00,960
一点 英特尔线程构建块

1751
01:12:00,960 --> 01:12:04,290
是 Facebook 的愚蠢行为之一，因此一般来说，

1752
01:12:04,290 --> 01:12:07,949
对于诸如您知道

1753
01:12:07,949 --> 01:12:09,090
内部哈希表之类的低级事物，以及

1754
01:12:09,090 --> 01:12:11,219


1755
01:12:11,219 --> 01:12:12,510
在查询处理和 st 中未用作您的一部分的事物 将数据

1756
01:12:12,510 --> 01:12:15,570
作为索引现成的东西

1757
01:12:15,570 --> 01:12:17,579
可能已经足够了所有商业

1758
01:12:17,579 --> 01:12:20,040
系统都推出所有高端系统

1759
01:12:20,040 --> 01:12:21,179
为这些东西推出自己的数据结构

1760
01:12:21,179 --> 01:12:22,920
但对于表索引我

1761
01:12:22,920 --> 01:12:24,480
认为必须构建特定的数据

1762
01:12:24,480 --> 01:12:25,409
结构 对你的

1763
01:12:25,409 --> 01:12:27,150
数据库系统来说是非常重要的，

1764
01:12:27,150 --> 01:12:28,260
因为这样你就可以根据

1765
01:12:28,260 --> 01:12:29,909
你的目标操作

1766
01:12:29,909 --> 01:12:32,699
环境来定制它，所以我要

1767
01:12:32,699 --> 01:12:33,630
指出的另一件事就是我们谈论最多的

1768
01:12:33,630 --> 01:12:35,400
哈希表

1769
01:12:35,400 --> 01:12:36,389
或谈论的时间 关于 B 加

1770
01:12:36,389 --> 01:12:38,369
树，但我谈到的核心思想是确保

1771
01:12:38,369 --> 01:12:40,530


1772
01:12:40,530 --> 01:12:41,760
线程始终朝着一个方向前进以

1773
01:12:41,760 --> 01:12:43,559
避免死锁

1774
01:12:43,559 --> 01:12:45,619
，如果您确实遇到死锁

1775
01:12:45,619 --> 01:12:48,510
可能会乐观地假设

1776
01:12:48,510 --> 01:12:50,099
您不必必须这样做

1777
01:12:50,099 --> 01:12:52,710
对结构进行修改，

1778
01:12:52,710 --> 01:12:54,239
因此首先采取快速路径

1779
01:12:54,239 --> 01:12:56,219
所有这些技术在

1780
01:12:56,219 --> 01:12:57,840
整个计算机科学和

1781
01:12:57,840 --> 01:12:59,760
一般系统中都被重用，所以它不是 只是 B

1782
01:12:59,760 --> 01:13:01,290
加树 Abad 这些技术

1783
01:13:01,290 --> 01:13:02,909
适用于任何地方

1784
01:13:02,909 --> 01:13:07,260
好吧

1785
01:13:07,260 --> 01:13:11,100
所以关于我们今天讨论的 Moke 的任何问题

1786
01:13:11,100 --> 01:13:12,960
好吧 所以好消息是下一

1787
01:13:12,960 --> 01:13:15,000
堂课我们终于可以开始学习

1788
01:13:15,000 --> 01:13:17,010
如何实际查询 我们知道如何存储

1789
01:13:17,010 --> 01:13:19,440
它们 我们现在对它们进行索引，现在让

1790
01:13:19,440 --> 01:13:20,760
我们谈谈你怎么知道

1791
01:13:20,760 --> 01:13:23,160
在它们之上运行查询并

1792
01:13:23,160 --> 01:13:27,770
产生结果好的伙计们

1793
01:13:38,900 --> 01:13:41,979
[音乐]

1794
01:13:48,680 --> 01:14:01,700
跳弹果冻击中了熟食店瓶子我

1795
01:14:03,020 --> 01:14:07,190
不知道你的手机可以点击

