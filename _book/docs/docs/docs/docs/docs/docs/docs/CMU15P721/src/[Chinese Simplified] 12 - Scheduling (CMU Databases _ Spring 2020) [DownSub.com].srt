1
00:00:01,300 --> 00:00:05,129
[音乐]

2
00:00:05,200 --> 00:00:05,930
[掌声]

3
00:00:05,930 --> 00:00:08,630
[音乐]

4
00:00:08,630 --> 00:00:10,020
[掌声]

5
00:00:10,020 --> 00:00:11,780
[音乐]

6
00:00:11,780 --> 00:00:14,820
好吧，让我们快速开始

7
00:00:14,820 --> 00:00:17,580
项目 2 如果你还

8
00:00:17,580 --> 00:00:19,080
没有注册一个小组，请去做

9
00:00:19,080 --> 00:00:20,970
，我们要改变的另一件事

10
00:00:20,970 --> 00:00:25,320
是 我们觉得在最后

11
00:00:25,320 --> 00:00:27,720
提交他们的项目的人的提交

12
00:00:27,720 --> 00:00:30,599
数量

13
00:00:30,599 --> 00:00:32,880
比我想要的要多，这在一定程度上是我的

14
00:00:32,880 --> 00:00:34,170
错，因为没有提前警告你们，

15
00:00:34,170 --> 00:00:35,579
嘿不要等到最后一分钟，

16
00:00:35,579 --> 00:00:38,730
所以为了避免这种情况 项目

17
00:00:38,730 --> 00:00:40,620
二的相同问题是我们将在中途设置

18
00:00:40,620 --> 00:00:42,960
一个检查点，您只需在其中

19
00:00:42,960 --> 00:00:45,360
进行插入和读取，因此如果他们

20
00:00:45,360 --> 00:00:49,050
进行拆分，那么这将

21
00:00:49,050 --> 00:00:50,910
是成绩的 25% 或 30% 然后

22
00:00:50,910 --> 00:00:52,230
我们将有常规提交

23
00:00:52,230 --> 00:00:53,460
截止日期仍然是相同的我

24
00:00:53,460 --> 00:00:55,649
认为支持傻瓜

25
00:00:55,649 --> 00:00:57,180
完整的测试套件

26
00:00:57,180 --> 00:00:58,859
再次它只是一个 14 功能对于

27
00:00:58,859 --> 00:01:01,800
你们来说，尽早开始考虑这个问题，

28
00:01:01,800 --> 00:01:03,570
而不是像 尝试

29
00:01:03,570 --> 00:01:06,960
在内存索引中写入一个线程安全的

30
00:01:06,960 --> 00:01:08,610
前一天' 因为这将是一个

31
00:01:08,610 --> 00:01:13,020
坏主意 好吧所以今天我们

32
00:01:13,020 --> 00:01:15,780
将讨论调度 所以最后一

33
00:01:15,780 --> 00:01:19,110
节课是关于如何

34
00:01:19,110 --> 00:01:20,820
从客户端获取查询请求放入我们的

35
00:01:20,820 --> 00:01:23,070
系统以某种方式运行它我们没有说

36
00:01:23,070 --> 00:01:25,380
所有如何获得 然后我们

37
00:01:25,380 --> 00:01:27,390
将从查询的结果中获取响应

38
00:01:27,390 --> 00:01:29,130
并将其通过线路推

39
00:01:29,130 --> 00:01:32,009
送回客户端 所以今天的课程我们

40
00:01:32,009 --> 00:01:33,780
开始下一章我们将如何实际

41
00:01:33,780 --> 00:01:35,430
执行这些查询，所以

42
00:01:35,430 --> 00:01:37,799
我们要 专注于调度，所以我们

43
00:01:37,799 --> 00:01:39,630
仍然没有真正执行

44
00:01:39,630 --> 00:01:42,360
扫描和读取我们的索引，但

45
00:01:42,360 --> 00:01:44,040
我们越来越

46
00:01:44,040 --> 00:01:46,829
接近那个，所以我们只

47
00:01:46,829 --> 00:01:48,439
需要定义一些我们将要使用的术语

48
00:01:48,439 --> 00:01:49,920


49
00:01:49,920 --> 00:01:51,869
描述查询执行的样子，

50
00:01:51,869 --> 00:01:54,750
因此查询计划

51
00:01:54,750 --> 00:01:58,170
将由运算符组成，您可以将它们

52
00:01:58,170 --> 00:01:59,159
视为某种关系代数

53
00:01:59,159 --> 00:02:02,549
运算符，因此我们将讨论我们

54
00:02:02,549 --> 00:02:04,530
如何进行查询计划，如果您更多地

55
00:02:04,530 --> 00:02:06,180
讲授基本的 我们得到

56
00:02:06,180 --> 00:02:07,740
续集q的想法 就像这样，我们将

57
00:02:07,740 --> 00:02:10,530
a 表示为

58
00:02:10,530 --> 00:02:13,650
运算符的有向树结构，

59
00:02:13,650 --> 00:02:14,939
我们拥有这些访问方法的最低级别

60
00:02:14,939 --> 00:02:16,409
是它们将扫描

61
00:02:16,409 --> 00:02:18,269
元组或扫描以索引并将它们提供

62
00:02:18,269 --> 00:02:20,340
给下一个运算符，然后

63
00:02:20,340 --> 00:02:23,579
结果渗透 到顶部，所以我们

64
00:02:23,579 --> 00:02:27,000
现在要

65
00:02:27,000 --> 00:02:29,700
在我们的查询计划

66
00:02:29,700 --> 00:02:31,439
中定义一个运算符的调用，它的特定调用将被定义为一个

67
00:02:31,439 --> 00:02:33,540
运算符实例，因此对于

68
00:02:33,540 --> 00:02:35,760
我们查询计划中的给定运算符（如扫描

69
00:02:35,760 --> 00:02:38,069
表），我们可以有多个实例

70
00:02:38,069 --> 00:02:40,620
这个操作符允许我们

71
00:02:40,620 --> 00:02:43,590
并行执行这个扫描，现在

72
00:02:43,590 --> 00:02:45,030
的想法是我们将

73
00:02:45,030 --> 00:02:47,989
分组分组在一起的

74
00:02:47,989 --> 00:02:50,159
方式我们将

75
00:02:50,159 --> 00:02:52,200
在我们的系统中执行的操作符实例好吧是

76
00:02:52,200 --> 00:02:55,980
调用这些组 作为正确的任务，这个

77
00:02:55,980 --> 00:02:57,420
想法有点像在

78
00:02:57,420 --> 00:02:59,250
管道模型中，我们希望在单个任务或管道

79
00:02:59,250 --> 00:03:00,829
中将尽可能多的测试串在一起，

80
00:03:00,829 --> 00:03:03,629
所以

81
00:03:03,629 --> 00:03:04,980
虽然我们没有上下文切换

82
00:03:04,980 --> 00:03:07,319
，但你知道 f 将一项任务转移到另一项任务，

83
00:03:07,319 --> 00:03:09,239
以便对一个任务进行扫描，然后我可以执行

84
00:03:09,239 --> 00:03:10,829
过滤器，然后根据

85
00:03:10,829 --> 00:03:12,180
我正在做的连接算法，如果我正在执行

86
00:03:12,180 --> 00:03:14,040
哈希连接，那么我可以让管道

87
00:03:14,040 --> 00:03:16,079
也为我构建哈希表 我

88
00:03:16,079 --> 00:03:17,639
只是将

89
00:03:17,639 --> 00:03:19,549
一个操作员实例的中间结果传递给下一个操作员实例，

90
00:03:19,549 --> 00:03:23,250
所以在高层次上，我们今天的工作

91
00:03:23,250 --> 00:03:24,629
是弄清楚我们将如何

92
00:03:24,629 --> 00:03:28,169
正确安排这些任务以及

93
00:03:28,169 --> 00:03:29,040
它们将在哪里执行以及它们将执行什么

94
00:03:29,040 --> 00:03:31,409
'实际上会为

95
00:03:31,409 --> 00:03:33,120
每一个出现的查询计划这样做，我们

96
00:03:33,120 --> 00:03:35,220
现在有一个方面，何时以及如何

97
00:03:35,220 --> 00:03:38,760
执行它，所以在这种情况下，这些

98
00:03:38,760 --> 00:03:40,290
决定之一将有任何任务，所以我们

99
00:03:40,290 --> 00:03:43,349
实际上用于我们的查询计划，就像

100
00:03:43,349 --> 00:03:45,690
我们一样 假设我们有这个数量的内核，当

101
00:03:45,690 --> 00:03:50,250
我们有我们可以为每个内核分配一个任务时，我们可以

102
00:03:50,250 --> 00:03:52,319
为每个内核分配一个任务，当它超额订阅时，

103
00:03:52,319 --> 00:03:53,699
有更多的测试，我们

104
00:03:53,699 --> 00:03:55,049
有内核，这样我们就可以有更

105
00:03:55,049 --> 00:03:57,569
灵活的调度，然后这个问题

106
00:03:57,569 --> 00:03:58,739
有多少内核 我们实际上想

107
00:03:58,739 --> 00:04:00,599
使用 right 所以我们可以有一个 X n

108
00:04:00,599 --> 00:04:02,970
任务数和线程数和/或

109
00:04:02,970 --> 00:04:04,530
内核数，我们可以决定要使用多少个内核

110
00:04:04,530 --> 00:04:07,199
，然后

111
00:04:07,199 --> 00:04:10,590
我们必须确定任务

112
00:04:10,590 --> 00:04:13,440
实际执行的过程，然后当该

113
00:04:13,440 --> 00:04:14,849
任务完成时，它会产生一些

114
00:04:14,849 --> 00:04:16,529
我们需要的输出 决定

115
00:04:16,529 --> 00:04:19,260
输出会去哪里，即使是

116
00:04:19,260 --> 00:04:20,488
Bay 到目前为止我们是说我们

117
00:04:20,488 --> 00:04:22,289
实际上是这个查询，我们得到了结果，

118
00:04:22,289 --> 00:04:24,479
但是现在当我们开始执行

119
00:04:24,479 --> 00:04:26,639
包含在该查询中的任务时，

120
00:04:26,639 --> 00:04:28,319
我们必须决定在哪里 我们

121
00:04:28,319 --> 00:04:31,439
应该对输出进行票证，并且正如我们所看到的，

122
00:04:31,439 --> 00:04:33,060
当我们谈论不同类型的

123
00:04:33,060 --> 00:04:35,520
内存架构时，我们需要

124
00:04:35,520 --> 00:04:37,139
知道该内存实际位于

125
00:04:37,139 --> 00:04:38,729
何处我们正在读取写入的内容，以便我们

126
00:04:38,729 --> 00:04:42,060
获得最佳性能，这

127
00:04:42,060 --> 00:04:43,439
就是为什么我们 '要做的所有这一切

128
00:04:43,439 --> 00:04:45,629
是数据库系统

129
00:04:45,629 --> 00:04:47,849
确切地知道查询是什么，确切地

130
00:04:47,849 --> 00:04:50,219
知道任务是什么，它知道什么

131
00:04:50,219 --> 00:04:51,659
威胁可用，并且

132
00:04:51,659 --> 00:04:53,189
知道内存或数据实际

133
00:04:53,189 --> 00:04:55,229
位于何处 ed 所以我们能够

134
00:04:55,229 --> 00:04:57,120
就如何有效地执行

135
00:04:57,120 --> 00:04:59,520
此查询计划做出最佳决定操作系统

136
00:04:59,520 --> 00:05:06,479
不知道这个问题这个问题

137
00:05:06,479 --> 00:05:07,560
是我们

138
00:05:07,560 --> 00:05:09,360
如何找到下一个课程将要使用的管道，但

139
00:05:09,360 --> 00:05:12,029
基本方法 考虑一下，

140
00:05:12,029 --> 00:05:14,340
我可以在多远的地方使用单个元组或一批

141
00:05:14,340 --> 00:05:16,259
元组并

142
00:05:16,259 --> 00:05:19,229
在我到达无法走得更远的点之前将其写出查询计划，

143
00:05:19,229 --> 00:05:21,719
因此在这种情况下

144
00:05:21,719 --> 00:05:24,120
，请扫描过滤器和 确实说你正在

145
00:05:24,120 --> 00:05:26,460
做一个散列连接我可以

146
00:05:26,460 --> 00:05:29,009
在连接的这一侧构建散列表，但我

147
00:05:29,009 --> 00:05:30,839
实际上无法产生任何结果来

148
00:05:30,839 --> 00:05:33,930
进行投影，因为我需要做

149
00:05:33,930 --> 00:05:35,939
探针侧所以这被称为管道

150
00:05:35,939 --> 00:05:48,419
断路器是的 所以问题

151
00:05:48,419 --> 00:05:50,099
是这真的是一个管道断路器，因为

152
00:05:50,099 --> 00:05:54,839
如果我有管道断路器在

153
00:05:54,839 --> 00:05:58,610
这里，我可能会意识到这

154
00:05:58,610 --> 00:06:01,589
两个家伙的输出然后将它推到

155
00:06:01,589 --> 00:06:04,289
我的哈希表中，就像

156
00:06:04,289 --> 00:06:05,879
我不能做的基本事情一样 走得更高并进行治疗，

157
00:06:05,879 --> 00:06:08,539
直到我从一侧钻机获得所有数据

158
00:06:08,539 --> 00:06:10,919
所以这边有一条管道，

159
00:06:10,919 --> 00:06:13,289
但是 B 的管道可以

160
00:06:13,289 --> 00:06:16,889
一直向上走，

161
00:06:16,889 --> 00:06:19,740
下节课没有什么意义，但

162
00:06:19,740 --> 00:06:21,360
我关心的主要思想就像你理解的

163
00:06:21,360 --> 00:06:23,460
那样，哦，任务就是我们

164
00:06:23,460 --> 00:06:24,930


165
00:06:24,930 --> 00:06:26,639


166
00:06:26,639 --> 00:06:32,039


167
00:06:32,039 --> 00:06:33,719


168
00:06:33,719 --> 00:06:36,419


169
00:06:36,419 --> 00:06:38,759
在任务“再会的时间表和多个运营商说明B呼声和我们大概要去它的基础管线和的主要来自这一切再次外卖的是，我们不会依赖于OS为做任何这 我们是 Network the

170
00:06:38,759 --> 00:06:40,139
Davis 它总是会更好地了解

171
00:06:40,139 --> 00:06:40,630
它所以它

172
00:06:40,630 --> 00:06:44,650
可以做出最好的决定所以开始我

173
00:06:44,650 --> 00:06:45,610
想首先谈谈

174
00:06:45,610 --> 00:06:46,810
我们可以在我们

175
00:06:46,810 --> 00:06:50,080
的架构数据库中拥有的不同流程模型它基本上

176
00:06:50,080 --> 00:06:52,390
告诉我们你知道它是什么 会

177
00:06:52,390 --> 00:06:54,550
找到一个工人实际上是什么 它是一个

178
00:06:54,550 --> 00:06:56,560
线程 它是一个进程 然后我们将

179
00:06:56,560 --> 00:06:58,060
讨论数据

180
00:06:58,060 --> 00:06:59,680
放置在内存数据库中的问题 我们需要

181
00:06:59,680 --> 00:07:01,300
了解内存的布局或

182
00:07:01,300 --> 00:07:02,920
内存中地址的物理位置

183
00:07:02,920 --> 00:07:05,590
我们可以让我们的线程尝试

184
00:07:05,590 --> 00:07:07,300
或 工作人员尝试对

185
00:07:07,300 --> 00:07:10,030
本地数据进行操作，然后我们将讨论

186
00:07:10,030 --> 00:07:11,830


187
00:07:11,830 --> 00:07:16,030
在数据库系统中

188
00:07:16,030 --> 00:07:18,970


189
00:07:18,970 --> 00:07:20,800


190
00:07:20,800 --> 00:07:23,020
进行 AI Namek 调度的不同技术 我们将把

191
00:07:23,020 --> 00:07:24,880
它与 Hana 之类的东西进行对比

192
00:07:24,880 --> 00:07:27,580
，你知道有

193
00:07:27,580 --> 00:07:28,840
不同类型的工作池

194
00:07:28,840 --> 00:07:30,130
不同类型的窃取与不

195
00:07:30,130 --> 00:07:32,200
窃取策略，这

196
00:07:32,200 --> 00:07:34,330
就是我们今天的重点

197
00:07:34,330 --> 00:07:36,880


198
00:07:36,880 --> 00:07:38,020
关于我们将如何设计我们的

199
00:07:38,020 --> 00:07:39,640
数据库和你在这里的调度的决定 我们

200
00:07:39,640 --> 00:07:41,980
需要知道我们是如何

201
00:07:41,980 --> 00:07:45,640
在这里构建系统的 好吧 所以

202
00:07:45,640 --> 00:07:46,810
让我们首先谈谈我们将

203
00:07:46,810 --> 00:07:50,500
如何分配工作人员进行计算

204
00:07:50,500 --> 00:07:52,930
我们的数据库系统中的单元，

205
00:07:52,930 --> 00:07:54,550
所以进程模型会发现

206
00:07:54,550 --> 00:07:55,960
系统是否是 sip 将如何

207
00:07:55,960 --> 00:07:58,180
支持来自

208
00:07:58,180 --> 00:08:00,100
多用户应用程序的并发请求，这意味着我们的

209
00:08:00,100 --> 00:08:01,810
应用程序可以发送多个 le 查询

210
00:08:01,810 --> 00:08:03,880
或同时多个事务

211
00:08:03,880 --> 00:08:05,620
调用，我们

212
00:08:05,620 --> 00:08:07,210
需要一种方法来决定我们将

213
00:08:07,210 --> 00:08:09,910
如何在

214
00:08:09,910 --> 00:08:12,370
低级硬件级别交错它们，所以

215
00:08:12,370 --> 00:08:13,630
我们不是在谈论我们如何 决定

216
00:08:13,630 --> 00:08:17,740
一个逻辑级别，例如什么

217
00:08:17,740 --> 00:08:19,690
交易彩票什么数据片段

218
00:08:19,690 --> 00:08:22,150
这就像我们如何处理任务并将其

219
00:08:22,150 --> 00:08:24,160
实际分配给某个工作人员以及

220
00:08:24,160 --> 00:08:27,310
该工作人员是什么所以我使用

221
00:08:27,310 --> 00:08:27,910
术语工作人员

222
00:08:27,910 --> 00:08:30,070
我会滑倒和 说线程

223
00:08:30,070 --> 00:08:33,070
但是对于我们正在谈论的系统

224
00:08:33,070 --> 00:08:34,360
它将是一个线程

225
00:08:34,360 --> 00:08:35,979
但是考虑这个的方式就像

226
00:08:35,979 --> 00:08:38,460
它不是数据说不知道

227
00:08:38,460 --> 00:08:40,750
技术上不需要知道

228
00:08:40,750 --> 00:08:42,789
它是否是一个线程 它不需要

229
00:08:42,789 --> 00:08:45,640
知道它是一种高级术语，

230
00:08:45,640 --> 00:08:49,990
可以再次描述

231
00:08:49,990 --> 00:08:52,300
系统中可以执行任务的组件，这

232
00:08:52,300 --> 00:08:54,329
可能是一个过程，也可能是

233
00:08:54,329 --> 00:08:56,100
阅读我说我收回的原因

234
00:08:56,100 --> 00:08:57,329
我所说的腺苷

235
00:08:57,329 --> 00:08:58,920
不需要知道，但肯定的是，如果

236
00:08:58,920 --> 00:09:00,720
我 这是一个我需要知道如何

237
00:09:00,720 --> 00:09:01,739
与其他进程通信的进程，

238
00:09:01,739 --> 00:09:02,939
因为它们在技术上

239
00:09:02,939 --> 00:09:05,459
不会在我的同一个地址空间中，所以它

240
00:09:05,459 --> 00:09:07,259
基本上只是我们执行任务

241
00:09:07,259 --> 00:09:09,269
然后将结果返回给

242
00:09:09,269 --> 00:09:12,439
应用程序的一种方式，所以有一个很好的

243
00:09:12,439 --> 00:09:16,799
十多年前由

244
00:09:16,799 --> 00:09:19,410
伯克利的 Mike Stonebraker Joe

245
00:09:19,410 --> 00:09:21,449
Hellerstein 和运行大多数 AWS 的人 James

246
00:09:21,449 --> 00:09:23,189
Hamilton 写的书，我称之为

247
00:09:23,189 --> 00:09:24,629
数据库系统的架构，所以这是在

248
00:09:24,629 --> 00:09:26,730
一个坐标系的上下文中，

249
00:09:26,730 --> 00:09:29,040
但这本书确实在一个 很好的

250
00:09:29,040 --> 00:09:31,170
一种干净的抽象，你知道

251
00:09:31,170 --> 00:09:33,059
你是如何在

252
00:09:33,059 --> 00:09:34,470
这种低水平的教育

253
00:09:34,470 --> 00:09:37,230
水平上实际设计系统的，所以

254
00:09:37,230 --> 00:09:38,279
我们讨论的三种方法是每个

255
00:09:38,279 --> 00:09:40,439
数据库工作进程池一个进程和

256
00:09:40,439 --> 00:09:42,149
每个 Davis 工作线程一个线程，我们再次讨论 已经

257
00:09:42,149 --> 00:09:43,499
在介绍课中介绍了这一点，

258
00:09:43,499 --> 00:09:44,549
但我只想

259
00:09:44,549 --> 00:09:47,459
再讲一遍，剧透将是

260
00:09:47,459 --> 00:09:49,589
我们今天要讨论的所有系统，

261
00:09:49,589 --> 00:09:50,759
并继续呼吸 o 如果本

262
00:09:50,759 --> 00:09:52,350
学期将是这里的最后一个，因为

263
00:09:52,350 --> 00:09:54,269
这是现代系统中最常见的一个，

264
00:09:54,269 --> 00:09:57,929
因此每个工人的进程是

265
00:09:57,929 --> 00:09:59,519
我们系统中的每个工人

266
00:09:59,519 --> 00:10:02,759
都将成为一个单独的操作系统进程的地方，

267
00:10:02,759 --> 00:10:04,499
这意味着当请求显示时 up

268
00:10:04,499 --> 00:10:07,009
说通过某种调度程序

269
00:10:07,009 --> 00:10:10,230
，然后它可以将连接移交给

270
00:10:10,230 --> 00:10:12,509
另一个工作程序，然后该工作程序将

271
00:10:12,509 --> 00:10:14,369
读取套接字并允许并接受

272
00:10:14,369 --> 00:10:16,230
它

273
00:10:16,230 --> 00:10:18,089
从客户端获取并在

274
00:10:18,089 --> 00:10:21,509
数据库系统上执行的所有请求

275
00:10:21,509 --> 00:10:23,910
这里正在进行的调度是

276
00:10:23,910 --> 00:10:26,489
由操作系统管理的，因为

277
00:10:26,489 --> 00:10:29,189
我们只是调用 fork 来启动一个

278
00:10:29,189 --> 00:10:31,709
新进程，我们无法直接

279
00:10:31,709 --> 00:10:33,540
控制说你是否知道它

280
00:10:33,540 --> 00:10:34,799
应该在它不

281
00:10:34,799 --> 00:10:37,649
应该运行的时候它应该运行 有时棘手的事情

282
00:10:37,649 --> 00:10:39,059
通常是这是什么

283
00:10:39,059 --> 00:10:42,419
样的我可能不知道我的调度员

284
00:10:42,419 --> 00:10:44,910
到底你知道这些

285
00:10:44,910 --> 00:10:46,589
工人正在做多少工作，我不得不

286
00:10:46,589 --> 00:10:48,899
依赖操作系统来做一些节流

287
00:10:48,899 --> 00:10:51,869
和流量 控制因为这些人

288
00:10:51,869 --> 00:10:53,999
可以做任何他们想做的事或

289
00:10:53,999 --> 00:10:55,649
需要编写额外的代码，他们让

290
00:10:55,649 --> 00:10:56,999
他们以某种方式与

291
00:10:56,999 --> 00:10:58,679
调度员进行交流，以集中

292
00:10:58,679 --> 00:11:00,569
查看正在发生的事情，但

293
00:11:00,569 --> 00:11:02,730
据我所知，在像 Postgres 这样的系统中他们

294
00:11:02,730 --> 00:11:04,589
没有 这样做所有采用这种方法的系统

295
00:11:04,589 --> 00:11:07,169
都是 db2，而 Oracle db2 是

296
00:11:07,169 --> 00:11:08,400
一个奇怪的系统，

297
00:11:08,400 --> 00:11:11,100
因为当人们

298
00:11:11,100 --> 00:11:13,350
说哦，我正在运行 db2 时，实际上有

299
00:11:13,350 --> 00:11:15,720
四个版本的 db2 是完全

300
00:11:15,720 --> 00:11:18,390
独立的代码库，例如一个 for z  /os

301
00:11:18,390 --> 00:11:20,610
用于其他大型机系统，

302
00:11:20,610 --> 00:11:22,200
然后是 Linux UNIX windows

303
00:11:22,200 --> 00:11:24,180
一个，还有第四个我忘记

304
00:11:24,180 --> 00:11:25,290
了，它们都是完全

305
00:11:25,290 --> 00:11:29,040
独立的，所以我们将在接下来的两张

306
00:11:29,040 --> 00:11:30,840
幻灯片中看到 db2 将支持所有这些

307
00:11:30,840 --> 00:11:32,730
方法，因为 它们必须在

308
00:11:32,730 --> 00:11:33,870
所有这些不同的环境中运行，但它

309
00:11:33,870 --> 00:11:35,490
可能不会每次都使用完全相同的代码库

310
00:11:35,490 --> 00:11:39,780


311
00:11:39,780 --> 00:11:42,030


312
00:11:42,030 --> 00:11:43,440


313
00:11:43,440 --> 00:11:45,840
worker 崩溃，您不会关闭

314
00:11:45,840 --> 00:11:48,030
整个系统，因为 worker 死了，

315
00:11:48,030 --> 00:11:50,070
然后您可以创建一个新的并将其

316
00:11:50,070 --> 00:11:51,540
重新启动，因此这使系统

317
00:11:51,540 --> 00:11:52,920
比

318
00:11:52,920 --> 00:11:55,470
基于线程的模型更具弹性，

319
00:11:55,470 --> 00:11:56,880
因为如果一个线程 有一个 seg 错误，

320
00:11:56,880 --> 00:12:00,720
那么整个过程就会终止，下

321
00:12:00,720 --> 00:12:02,460
一篇文章只是工作人员的一个扩展，

322
00:12:02,460 --> 00:12:04,380
每个工作人员

323
00:12:04,380 --> 00:12:07,290
都有一个进程，我们有一个进程池，而不是

324
00:12:07,290 --> 00:12:08,940
分叉调度器，

325
00:12:08,940 --> 00:12:10,680
为

326
00:12:10,680 --> 00:12:13,020
每个出现它的请求分叉一个新进程 知道

327
00:12:13,020 --> 00:12:15,270
它有一堆可用的工作人员

328
00:12:15,270 --> 00:12:17,220
可以传递请求

329
00:12:17,220 --> 00:12:19,380
，并且您知道为我们运行查询

330
00:12:19,380 --> 00:12:22,290
，在某些情况下，如果我想

331
00:12:22,290 --> 00:12:24,780
支持引入查询并行性，我

332
00:12:24,780 --> 00:12:26,100
可以进行单个查询并运行 在

333
00:12:26,100 --> 00:12:28,770
金属工人的多个进程中，

334
00:12:28,770 --> 00:12:31,080
这个工人可以识别出

335
00:12:31,080 --> 00:12:32,400


336
00:12:32,400 --> 00:12:34,200
同一池中还有其他空闲的工人可用，并开始

337
00:12:34,200 --> 00:12:37,920
将工作移交给正确的工作

338
00:12:37,920 --> 00:12:39,600
这种方法的坏处是 t

339
00:12:39,600 --> 00:12:41,700
它会破坏我们的位置，除非我们

340
00:12:41,700 --> 00:12:44,850
在调度程序中有额外的逻辑来

341
00:12:44,850 --> 00:12:47,550
注意上次执行我们

342
00:12:47,550 --> 00:12:50,340
查询的工作人员是正确的，因为说

343
00:12:50,340 --> 00:12:51,690
这些人都在单独的套接字上运行

344
00:12:51,690 --> 00:12:55,710
，如果对于这个请求，

345
00:12:55,710 --> 00:12:57,030
第一个查询出现我运行 在这个

346
00:12:57,030 --> 00:12:59,400
工作人员上，下一个查询显示

347
00:12:59,400 --> 00:13:01,080
相同的连接，但它运行一个名词或

348
00:13:01,080 --> 00:13:02,700
另一个在另一个套接字上运行的工作人员

349
00:13:02,700 --> 00:13:05,340
我用于

350
00:13:05,340 --> 00:13:07,020
将数据引入内存的所有缓存位置，或者

351
00:13:07,020 --> 00:13:09,000
该工作人员的本地缓存现在已经消失，

352
00:13:09,000 --> 00:13:10,380
因为现在我 '不是在一个

353
00:13:10,380 --> 00:13:14,550
完全不同的套接字上运行，所以这

354
00:13:14,550 --> 00:13:16,230
通常对内存系统不利是

355
00:13:16,230 --> 00:13:19,140
因为跟踪

356
00:13:19,140 --> 00:13:22,050
我上次运行的工作的开销，

357
00:13:22,050 --> 00:13:24,420


358
00:13:24,420 --> 00:13:25,470
如果在连接你之前运行另一个查询，则暂停直到工作人员释放

359
00:13:25,470 --> 00:13:26,759
我的下一个查询

360
00:13:26,759 --> 00:13:30,329
或者你知道基本上保持它

361
00:13:30,329 --> 00:13:31,379
直到下一个查询出现这

362
00:13:31,379 --> 00:13:33,540
与上一张幻灯片完全一样

363
00:13:33,540 --> 00:13:36,540
，所有这些编排都会减慢速度

364
00:13:36,540 --> 00:13:39,540
并且 Postgres 添加 在 2015 年编辑了这个，

365
00:13:39,540 --> 00:13:41,639
他们可以有介绍查询

366
00:13:41,639 --> 00:13:43,529
并行性，正如我所说的 db2 试图

367
00:13:43,529 --> 00:13:45,749
支持一切最

368
00:13:45,749 --> 00:13:47,970
常见的一个是每个工人的线程

369
00:13:47,970 --> 00:13:49,499
权利一个多线程应用程序

370
00:13:49,499 --> 00:14:00,480
问题假设你正在运行一个

371
00:14:00,480 --> 00:14:02,459
东西为此假设 本

372
00:14:02,459 --> 00:14:13,829
学期都是单机套接字

373
00:14:13,829 --> 00:14:15,540
如果它们

374
00:14:15,540 --> 00:14:17,249
在同一个套接字上你有本地缓存

375
00:14:17,249 --> 00:14:22,110
并且 l1 l2 不共享但 l3 共享所以

376
00:14:22,110 --> 00:14:24,089
如果你在同一个套接字上运行

377
00:14:24,089 --> 00:14:27,420
缓存未命中的惩罚取决于

378
00:14:27,420 --> 00:14:28,619
缓存未命中

379
00:14:28,619 --> 00:14:31,139
的可能性与我需要的数据的可能性相同，

380
00:14:31,139 --> 00:14:32,579
例如如果我有一个查询，它们会执行一些

381
00:14:32,579 --> 00:14:34,079
最近的数据，下一个漂亮的显示

382
00:14:34,079 --> 00:14:35,910
想要读取相同的

383
00:14:35,910 --> 00:14:37,049
数据，就像我在阅读之后一直使用的一样

384
00:14:37,049 --> 00:14:40,679
写入或读取修改写入然后如果我

385
00:14:40,679 --> 00:14:42,480
在同一个套接字上运行那么

386
00:14:42,480 --> 00:14:44,610
读取的数据可能会挂在 l3 缓存上

387
00:14:44,610 --> 00:14:46,860
，如果我知道另一个

388
00:14:46,860 --> 00:14:48,329
不必共享该

389
00:14:48,329 --> 00:14:54,449
l3 缓存的套接字我会很快 支付另一个缓存未命中

390
00:14:54,449 --> 00:14:56,850
前一个就像这个连接，

391
00:14:56,850 --> 00:14:59,670
这个工作人员现在专用

392
00:14:59,670 --> 00:15:01,589
于连接到这个客户端，所以出现的任何

393
00:15:01,589 --> 00:15:03,059
查询总是会

394
00:15:03,059 --> 00:15:04,799
转到这个工作人员，因为它

395
00:15:04,799 --> 00:15:05,910
基本上接管了监听，就像

396
00:15:05,910 --> 00:15:08,699
基本上发生的事情是 bluee

397
00:15:08,699 --> 00:15:09,839
Postgres 工作 如果这被称为

398
00:15:09,839 --> 00:15:11,999
postmaster 连接

399
00:15:11,999 --> 00:15:14,129
显示 postmaster 说很好 我可以把

400
00:15:14,129 --> 00:15:16,649
你交给工作人员 现在直接到这个

401
00:15:16,649 --> 00:15:18,929
套接字或这里的端口号，所以

402
00:15:18,929 --> 00:15:20,369
现在又回来了，这个东西正在

403
00:15:20,369 --> 00:15:21,749
监听这个端口，现在有

404
00:15:21,749 --> 00:15:24,919
直接访问在这里写 10 个查询

405
00:15:24,919 --> 00:15:27,899
是的，你绕过了调度员

406
00:15:27,899 --> 00:15:29,309
这个就像我总是去这个新的

407
00:15:29,309 --> 00:15:30,209
调度员我认为这是一个

408
00:15:30,209 --> 00:15:31,919
分段的调度程序，它现在

409
00:15:31,919 --> 00:15:33,209
让这个厨房如何

410
00:15:33,209 --> 00:15:35,850
在不同的过程中处理事情

411
00:15:35,850 --> 00:15:39,240
威胁可怜的工人是它是一个单一的

412
00:15:39,240 --> 00:15:41,459
进程，我们在该进程内部

413
00:15:41,459 --> 00:15:43,440
有多个线程，您可能有也可能

414
00:15:43,440 --> 00:15:45,060
没有调度员一个线程您仍然

415
00:15:45,060 --> 00:15:46,709
可以执行相同的操作 您有

416
00:15:46,709 --> 00:15:49,680
一个线程在一个套接字上侦听所有

417
00:15:49,680 --> 00:15:51,000
增量任务都必须转到的套接字，

418
00:15:51,000 --> 00:15:52,500
然后将其传递给

419
00:15:52,500 --> 00:15:55,199
另一个线程上的另一个套接字，以便它可以

420
00:15:55,199 --> 00:15:57,740
处理事物，或者您可以为

421
00:15:57,740 --> 00:15:59,880
每个连接拥有一个专用线程，或者

422
00:15:59,880 --> 00:16:01,649
您只是 有一种

423
00:16:01,649 --> 00:16:03,420
通用网络层，

424
00:16:03,420 --> 00:16:06,000
他可以将工作交给任何

425
00:16:06,000 --> 00:16:09,269
有空闲周期的人，正如我所说

426
00:16:09,269 --> 00:16:10,980
，过去 10 年中编写的每个数据库系统

427
00:16:10,980 --> 00:16:14,670
都遵循这种方法，所以您

428
00:16:14,670 --> 00:16:15,779
可能会很好地思考这显然

429
00:16:15,779 --> 00:16:18,509
更好 知道你知道为

430
00:16:18,509 --> 00:16:20,519
上下文切换支付一分钱所有的东西都在

431
00:16:20,519 --> 00:16:22,170
同一个地址库中，所以任何线程都可以读取

432
00:16:22,170 --> 00:16:24,360
任何你知道的

433
00:16:24,360 --> 00:16:26,130
另一个线程的内存位置是的，你必须

434
00:16:26,130 --> 00:16:27,420
做当前的一套东西，以确保

435
00:16:27,420 --> 00:16:28,980
你没有任何问题 或或

436
00:16:28,980 --> 00:16:30,209
闩锁以确保

437
00:16:30,209 --> 00:16:31,649
您在访问关键部分时不会相互破坏，

438
00:16:31,649 --> 00:16:35,370
因此，这显然

439
00:16:35,370 --> 00:16:38,040
比

440
00:16:38,040 --> 00:16:40,319
进程处理方法的开销要低，我们

441
00:16:40,319 --> 00:16:42,480
猜测为什么 nob  ody

442
00:16:42,480 --> 00:16:46,980
在 1980 年代以这种方式构建数据库 1990 年代正确地说

443
00:16:46,980 --> 00:16:48,509
POSIX 线程或 P 线程没有

444
00:16:48,509 --> 00:16:50,220
标准化，因此

445
00:16:50,220 --> 00:16:52,230
您所知道的所有不同的操作系统或

446
00:16:52,230 --> 00:16:56,519
用于 Linux 的 Solaris H 公园甚至都

447
00:16:56,519 --> 00:16:57,750
出现了，但限制在

448
00:16:57,750 --> 00:16:59,639
90 年代初出现了 一个 POSIX

449
00:16:59,639 --> 00:17:01,439
标准说这是一个线程 API 每个人

450
00:17:01,439 --> 00:17:03,660
都有自己的 API 并且他们有

451
00:17:03,660 --> 00:17:05,520
关于他们如何产生线程的语义

452
00:17:05,520 --> 00:17:08,699
并且你知道从他们加入是

453
00:17:08,699 --> 00:17:11,039
略有不同并没有显着

454
00:17:11,039 --> 00:17:12,780
不同但就像 API 肯定

455
00:17:12,780 --> 00:17:14,609
不同所以 如果我想

456
00:17:14,609 --> 00:17:15,929
为我的数据库 ism 支持一堆操作系统，

457
00:17:15,929 --> 00:17:18,299
那么我将不得不有

458
00:17:18,299 --> 00:17:19,740
一种包装层来

459
00:17:19,740 --> 00:17:23,490
确保我拥有它

460
00:17:23,490 --> 00:17:24,780
是线程

461
00:17:24,780 --> 00:17:26,939
API 的最低公分母，所以它做到了 现在更可移植

462
00:17:26,939 --> 00:17:28,590
的 P 线程，这不是问题，

463
00:17:28,590 --> 00:17:31,919
所以有一件事也很好，

464
00:17:31,919 --> 00:17:33,990
当我们服务第一次开始构建 peloton 时，我们所做的一件事

465
00:17:33,990 --> 00:17:35,940
是我们将

466
00:17:35,940 --> 00:17:37,380
Postgres 源代码分叉了它喜欢

467
00:17:37,380 --> 00:17:41,460


468
00:17:41,460 --> 00:17:43,470
如果你去谷歌

469
00:17:43,470 --> 00:17:45,659
Postgres 多线程，你会看到一个

470
00:17:45,659 --> 00:17:47,549
邮件列表帖子，我是前

471
00:17:47,549 --> 00:17:50,120
博士生说嘿，看，我们确实

472
00:17:50,120 --> 00:17:52,770
害怕为什么我们这样做是一件坏事

473
00:17:52,770 --> 00:17:54,780
啊，但事实证明，我们实际使用

474
00:17:54,780 --> 00:17:56,490
它进行转换的方式

475
00:17:56,490 --> 00:17:59,580
与我们在 Postgres 源

476
00:17:59,580 --> 00:18:01,050
代码中采用的方式不同，它是一个单一的代码库，但他们

477
00:18:01,050 --> 00:18:02,370
有所有这些罚款，说

478
00:18:02,370 --> 00:18:05,430
如果你知道 Linux 是否这样做 如果在 32 时

479
00:18:05,430 --> 00:18:07,530
这样做，如果您使用 Windows 代码，

480
00:18:07,530 --> 00:18:08,640
您实际上可以更轻松地将其转换为

481
00:18:08,640 --> 00:18:09,990
pthreads，那么无论如何您都可以

482
00:18:09,990 --> 00:18:14,460
转换 Linux 代码，我们

483
00:18:14,460 --> 00:18:15,840
还转换了这个tipo plus 11

484
00:18:15,840 --> 00:18:18,240
，由于历史原因，我不

485
00:18:18,240 --> 00:18:20,100
记得了 但在我们的新系统中，我们把

486
00:18:20,100 --> 00:18:21,390
所有这些都扔掉了，我们没有任何东西，我们

487
00:18:21,390 --> 00:18:23,760
不再继承任何 Postgres 代码，

488
00:18:23,760 --> 00:18:25,830
因此多线程方法

489
00:18:25,830 --> 00:18:27,750
更好，您的上下文切换开销较低

490
00:18:27,750 --> 00:18:29,700
，然后您不必管理

491
00:18:29,700 --> 00:18:31,650
共享内存 在多进程情况下，

492
00:18:31,650 --> 00:18:34,650
你 要么互相发送我的个人电脑，

493
00:18:34,650 --> 00:18:37,140
要么你有共享内存，

494
00:18:37,140 --> 00:18:38,550
以便每个人都可以读取和

495
00:18:38,550 --> 00:18:41,490
写入同一位置，

496
00:18:41,490 --> 00:18:43,170
另外要指出的重要事情也只是因为我们

497
00:18:43,170 --> 00:18:45,660
可能使用多线程进程

498
00:18:45,660 --> 00:18:47,550
模型并不一定 意味着我们将

499
00:18:47,550 --> 00:18:48,870
在我们的

500
00:18:48,870 --> 00:18:51,360
数据库系统中引入查询并行性，所以 Maltin 我的续集是一个

501
00:18:51,360 --> 00:18:53,790
多线程数据库系统，但

502
00:18:53,790 --> 00:18:56,640
每个查询请求只有一个线程，他们

503
00:18:56,640 --> 00:18:57,930
无法将任务分配给

504
00:18:57,930 --> 00:18:59,850
多个工作人员并在他们的

505
00:18:59,850 --> 00:19:01,740
环境中执行 OTP 就是这样，

506
00:19:01,740 --> 00:19:04,290
这很好，正如我所说，我不

507
00:19:04,290 --> 00:19:06,510
知道任何其他系统

508
00:19:06,510 --> 00:19:08,070
在过去十年中构建的最后一个系统以及最后一个

509
00:19:08,070 --> 00:19:10,650
从 post graphs 派生出来的系统，这

510
00:19:10,650 --> 00:19:13,380
是一种进程池模型方法，

511
00:19:13,380 --> 00:19:15,300
让我们它们基于 postgrass 每个

512
00:19:15,300 --> 00:19:16,980
新系统都将同时使用多

513
00:19:16,980 --> 00:19:19,830
线程，好吧，这

514
00:19:19,830 --> 00:19:23,010
就是我们在系统中使用的内容，

515
00:19:23,010 --> 00:19:24,690
所以现在让我们来回答他的

516
00:19:24,690 --> 00:19:27,870
问题是关于这个

517
00:19:27,870 --> 00:19:29,730
内核是否运行 sa 的问题 我使用相同的套接字或

518
00:19:29,730 --> 00:19:32,970
不同的套接字，所以无论

519
00:19:32,970 --> 00:19:36,360
我们将如何在我们的系统中进行我们的工作分配或

520
00:19:36,360 --> 00:19:39,090
任务分配策略，我们都

521
00:19:39,090 --> 00:19:40,680
希望确保所有工作人员

522
00:19:40,680 --> 00:19:43,590
都将操作本地数据，因此

523
00:19:43,590 --> 00:19:44,910
在分布式系统中这是

524
00:19:44,910 --> 00:19:47,640
如果我有两台机器并且我的

525
00:19:47,640 --> 00:19:49,920
数据是你知道我的机器在

526
00:19:49,920 --> 00:19:51,150
西海岸 一台机器是东海岸 我的

527
00:19:51,150 --> 00:19:53,100
查询出现并想接触

528
00:19:53,100 --> 00:19:55,320
西海岸的数据 我将查询发送

529
00:19:55,320 --> 00:19:56,820
到西海岸 以这种方式处理它，

530
00:19:56,820 --> 00:19:59,220
它对本地数据的操作以及

531
00:19:59,220 --> 00:20:01,560
多套接字多核数据

532
00:20:01,560 --> 00:20:04,320
或套接字多核系统，即使

533
00:20:04,320 --> 00:20:06,870
它在一个盒子中运行仍然

534
00:20:06,870 --> 00:20:08,610
有点像分销商数据库

535
00:20:08,610 --> 00:20:10,800
系统，因此相同的规则相同 相同的

536
00:20:10,800 --> 00:20:13,230
概念在这里适用，所以我们要

537
00:20:13,230 --> 00:20:14,940
确保我们的任务总是

538
00:20:14,940 --> 00:20:18,150
在本地数据上操作

539
00:20:18,150 --> 00:20:20,550
工作线程实际运行的线程所以

540
00:20:20,550 --> 00:20:22,560
这意味着现在我们的调度程序需要

541
00:20:22,560 --> 00:20:24,930
我知道我们底层的内存

542
00:20:24,930 --> 00:20:28,440
布局 硬件和在

543
00:20:28,440 --> 00:20:30,450
高层次上有两种方法 这

544
00:20:30,450 --> 00:20:31,890
是统一的，然后

545
00:20:31,890 --> 00:20:33,870
是非统一的内存访问 所以这

546
00:20:33,870 --> 00:20:37,020
也是首字母缩略词是Numa 所以你在这里

547
00:20:37,020 --> 00:20:38,400
遇到多次数字区域

548
00:20:38,400 --> 00:20:40,140
Numa 今天中午与那就是

549
00:20:40,140 --> 00:20:41,610
这个 这是我们

550
00:20:41,610 --> 00:20:45,210
今天在大多数 eSATA 系统中最常见的一个

551
00:20:45,210 --> 00:20:46,320
，在我们拥有所谓的

552
00:20:46,320 --> 00:20:48,330
统一内存访问的那一天，这有时

553
00:20:48,330 --> 00:20:51,390
被称为对称多处理器 SMP，

554
00:20:51,390 --> 00:20:53,760
它基本上是一样的，这个

555
00:20:53,760 --> 00:20:56,610
想法是工作人员的任务

556
00:20:56,610 --> 00:20:57,630
在内核中运行

557
00:20:57,630 --> 00:21:00,510
它们确实有一些本地 CPU 缓存

558
00:21:00,510 --> 00:21:04,560
l1 l2 l3 但所有内存都是

559
00:21:04,560 --> 00:21:06,780
通过这个系统总线管理的，所以对于

560
00:21:06,780 --> 00:21:09,270
在任何套接字上运行的任何任务，无论我在哪里，

561
00:21:09,270 --> 00:21:12,030
访问一块内存的成本都是一样

562
00:21:12,030 --> 00:21:14,010
的 我正在运行，所以

563
00:21:14,010 --> 00:21:15,570
如果我在这里并且我想访问

564
00:21:15,570 --> 00:21:18,000
这个该死的内存中的内存，

565
00:21:18,000 --> 00:21:19,860


566
00:21:19,860 --> 00:21:21,440
如果我在这里或其他地方运行，检索成本是相同的，

567
00:21:21,440 --> 00:21:24,420
因为那里有

568
00:21:24,420 --> 00:21:27,060
开销 这个系统总线所以我们仍然需要

569
00:21:27,060 --> 00:21:28,590
在这个世界上做缓存失效，

570
00:21:28,590 --> 00:21:31,110
硬件

571
00:21:31,110 --> 00:21:33,870
知道我读取了这个内存区域，现在

572
00:21:33,870 --> 00:21:35,940
它在我的 CPU 缓存中，其他人

573
00:21:35,940 --> 00:21:37,560
读取相同的内容和权限，

574
00:21:37,560 --> 00:21:39,450
系统老板 必须采取可以处理

575
00:21:39,450 --> 00:21:40,980
使我们的缓存无效的每个你知道

576
00:21:40,980 --> 00:21:43,350
我们的缓存条目在这里所有那种

577
00:21:43,350 --> 00:21:46,140
句柄给你所以他们说这就是

578
00:21:46,140 --> 00:21:49,950
他们的构建方式，直到可能像 2005

579
00:21:49,950 --> 00:21:53,310
年和 2006 年，这就是英特尔和 AMD 我们正在

580
00:21:53,310 --> 00:21:56,400
设计他们的方式 多插槽 CPU 系统，

581
00:21:56,400 --> 00:21:59,640
但现在我们有了 Numa 的东西，

582
00:21:59,640 --> 00:22:01,020
在这个世界上，

583
00:22:01,020 --> 00:22:02,660
从数据库系统的角度来看，

584
00:22:02,660 --> 00:22:06,330
实际上没有任何智能智能我们

585
00:22:06,330 --> 00:22:08,370
需要嵌入到我们的调度程序中，因为我

586
00:22:08,370 --> 00:22:10,500
说它确实我们不知道我们不知道 关心

587
00:22:10,500 --> 00:22:11,970
这看起来像一个约翰地址基

588
00:22:11,970 --> 00:22:15,299
并且访问成本是相同的

589
00:22:15,299 --> 00:22:18,519
现代系统在新模型中的样子

590
00:22:18,519 --> 00:22:22,029
是你现在仍然拥有

591
00:22:22,029 --> 00:22:24,340
每个套接字本地的内存所以

592
00:22:24,340 --> 00:22:25,600
你总是有你的

593
00:22:25,600 --> 00:22:27,399
本地CPU 缓存，然后

594
00:22:27,399 --> 00:22:28,600
你会在

595
00:22:28,600 --> 00:22:30,700
物理上更靠近你的插座的地方有一些暗淡，并且

596
00:22:30,700 --> 00:22:32,499
有直接的路径来读取和

597
00:22:32,499 --> 00:22:36,639
写入它等等在英特尔芯片

598
00:22:36,639 --> 00:22:39,570
上每个核心的 CPU 缓存 l1 l2 将

599
00:22:39,570 --> 00:22:42,009
特定于此 核心但随后他们

600
00:22:42,009 --> 00:22:44,259
也共享共享 l3 然后显然

601
00:22:44,259 --> 00:22:47,379
他们在这里共享昏暗然后现在如果

602
00:22:47,379 --> 00:22:50,049
我需要让我的任务在这里运行

603
00:22:50,049 --> 00:22:51,940
如果它需要访问

604
00:22:51,940 --> 00:22:53,619
不在我本地昏暗中的内存我必须转到

605
00:22:53,619 --> 00:22:55,570
这里的另一个 CPU 我将通过

606
00:22:55,570 --> 00:22:58,149
这个互连在硬件中发送我的消息

607
00:22:58,149 --> 00:22:59,679
说嘿去

608
00:22:59,679 --> 00:23:01,779
为我读这个东西然后 CPU 知道如何

609
00:23:01,779 --> 00:23:03,100
去昏暗然后把它

610
00:23:03,100 --> 00:23:04,090
带回我

611
00:23:04,090 --> 00:23:07,720
所以 这里的性能差异

612
00:23:07,720 --> 00:23:09,850
对于纯粹的读/写速度

613
00:23:09,850 --> 00:23:12,159
大约慢 50%，所以如果我必须

614
00:23:12,159 --> 00:23:13,809
在这里粗略地读取数据，它

615
00:23:13,809 --> 00:23:15,309
可能比我在

616
00:23:15,309 --> 00:23:22,210
本地读取数据慢 50% 是的，就像从

617
00:23:22,210 --> 00:23:24,519
这里到这里没有看 巴士

618
00:23:24,519 --> 00:23:27,399
基本上就像这辆巴士基本上在

619
00:23:27,399 --> 00:23:28,809
说 l 好吧，我想要访问内存

620
00:23:28,809 --> 00:23:30,519
地址，你基本上把它

621
00:23:30,519 --> 00:23:35,110
转换成一些暗槽，对吧，

622
00:23:35,110 --> 00:23:37,059
在本地看是的，所以如果我必须在

623
00:23:37,059 --> 00:23:39,039
这里阅读比在这里阅读本地慢 50%

624
00:23:39,039 --> 00:23:40,779
，就像把它想象成

625
00:23:40,779 --> 00:23:45,850
快速路径一样，是的，再次 这意味着

626
00:23:45,850 --> 00:23:48,700
现在在我们的数据库系统中，当我们开始

627
00:23:48,700 --> 00:23:50,820
加载我们的数据时，我们想要知道

628
00:23:50,820 --> 00:23:53,529
我们实际上会放置它然后当

629
00:23:53,529 --> 00:23:54,879
查询出现并且他们想要开始

630
00:23:54,879 --> 00:23:56,799
执行时我们需要知道

631
00:23:56,799 --> 00:23:58,960
他们想要接触的数据 就在我们的

632
00:23:58,960 --> 00:24:00,850
任务中并确保我们的任务在这里

633
00:24:00,850 --> 00:24:03,490
然后操作系统不知道什么是正确的

634
00:24:03,490 --> 00:24:06,190
操作系统看到一堆想要

635
00:24:06,190 --> 00:24:08,409
做某种工作的线程但它不知道

636
00:24:08,409 --> 00:24:09,549
你知道不知道你的比特币

637
00:24:09,549 --> 00:24:11,049
挖掘 线程从你的数据库到某个

638
00:24:11,049 --> 00:24:14,200
线程所以我们必须告诉它嘿我们

639
00:24:14,200 --> 00:24:15,519
想确保我们在这里本地运行东西

640
00:24:15,519 --> 00:24:21,249
所以这个互连

641
00:24:21,249 --> 00:24:23,230
如果你知道它是一个高速高速

642
00:24:23,230 --> 00:24:24,340


643
00:24:24,340 --> 00:24:25,659
不是真的我不认为虽然我

644
00:24:25,659 --> 00:24:27,460
会 不称它为公共汽车，但他们说这是

645
00:24:27,460 --> 00:24:28,519
一辆

646
00:24:28,519 --> 00:24:30,139
这些不同插槽之间的高速连接是

647
00:24:30,139 --> 00:24:31,700
多路复用的 你可以双向连接并

648
00:24:31,700 --> 00:24:34,070
与电视中的任何人交谈 我们

649
00:24:34,070 --> 00:24:35,570
称之为 qpi 的快速通道互连

650
00:24:35,570 --> 00:24:37,969
那时还不够好所以现在

651
00:24:37,969 --> 00:24:39,549
他们称之为 2017 年的超通道互连

652
00:24:39,549 --> 00:24:41,509


653
00:24:41,509 --> 00:24:43,219
AMD 有他们的 自己的版本，它现在

654
00:24:43,219 --> 00:24:45,049
被称为无限织物力量有

655
00:24:45,049 --> 00:24:46,820
自己的东西，

656
00:24:46,820 --> 00:24:48,440
我认为手臂也有自己的东西，

657
00:24:48,440 --> 00:24:50,479
但在高层次上，他们

658
00:24:50,479 --> 00:24:53,349
都在做同样的事情，

659
00:24:53,349 --> 00:24:59,659
好吧，所以现在如果我打电话给 Malick 问题

660
00:24:59,659 --> 00:25:01,009
是哪里 我的记忆会正常显示，

661
00:25:01,009 --> 00:25:05,359
所以考虑这个的方法

662
00:25:05,359 --> 00:25:07,339
是我们将获取

663
00:25:07,339 --> 00:25:09,349
内存中的表，我们

664
00:25:09,349 --> 00:25:10,820
将对它们进行分区或将它们分解

665
00:25:10,820 --> 00:25:14,389
为两个数据块块，然后 那么

666
00:25:14,389 --> 00:25:16,609
现在我们想要将这些

667
00:25:16,609 --> 00:25:20,179
块中的每一个分配给特定的 CPU 内核，并且

668
00:25:20,179 --> 00:25:23,109
在更高的 CPU 插槽或 Numa 区域中，

669
00:25:23,109 --> 00:25:26,149
因此如果我们知道在查询时

670
00:25:26,149 --> 00:25:28,099
将数据放在

671
00:25:28,099 --> 00:25:30,559
哪里 出现一个 d 我们

672
00:25:30,559 --> 00:25:31,999
决定如何将其分解

673
00:25:31,999 --> 00:25:33,889
为任务以及这些任务是什么 任务对哪些

674
00:25:33,889 --> 00:25:35,299
数据进行

675
00:25:35,299 --> 00:25:37,669
操作 我们可以确保我们安排我们的

676
00:25:37,669 --> 00:25:39,799
操作员在其本地数据上执行

677
00:25:39,799 --> 00:25:42,709
所以这是一个老问题

678
00:25:42,709 --> 00:25:43,879
分发数据，这称为数据

679
00:25:43,879 --> 00:25:45,589
放置，因此考虑分区是

680
00:25:45,589 --> 00:25:47,149
决定如何分解它

681
00:25:47,149 --> 00:25:48,589
以及边界，然后数据放置

682
00:25:48,589 --> 00:25:50,479
是说我将生成的那些实际分区放在哪里

683
00:25:50,479 --> 00:25:52,669
，因此在

684
00:25:52,669 --> 00:25:54,649
Linux 中，您可以通过

685
00:25:54,649 --> 00:25:56,869
移动页面系统调用或 noumic

686
00:25:56,869 --> 00:25:58,669
控制命令行选项或命令

687
00:25:58,669 --> 00:26:00,379
行工具，所以基本上 new 会发生什么，

688
00:26:00,379 --> 00:26:03,469
它会移动页面，如果你只是

689
00:26:03,469 --> 00:26:04,940
用内存地址调用它，它会

690
00:26:04,940 --> 00:26:06,349
回来告诉你什么数字

691
00:26:06,349 --> 00:26:08,479
，它是 如果您使用

692
00:26:08,479 --> 00:26:12,349
内存地址、大小和编号调用

693
00:26:12,349 --> 00:26:15,109
它，它将将该数据移动到该

694
00:26:15,109 --> 00:26:16,849
位置，我认为这是一个阻塞

695
00:26:16,849 --> 00:26:19,879
系统调用，所以如果您考虑这一点，如果我

696
00:26:19,879 --> 00:26:22,399
有一个 1 TB 的数据库，我可以 将

697
00:26:22,399 --> 00:26:24,049
它加载到内存中，然后

698
00:26:24,049 --> 00:26:25,669
随机分散在不同的

699
00:26:25,669 --> 00:26:28,579
套接字中然后我可以返回并

700
00:26:28,579 --> 00:26:31,159
调用移动页面并开始将东西

701
00:26:31,159 --> 00:26:32,509
放入以及你知道我想要它们

702
00:26:32,509 --> 00:26:37,489
的位置所以现在让我们谈谈

703
00:26:37,489 --> 00:26:39,679
当你调用时会发生什么 malloc 所以

704
00:26:39,679 --> 00:26:40,969
假设我们的数据系统调用 malloc 因为

705
00:26:40,969 --> 00:26:42,019
我们要加载到一个 TB 的

706
00:26:42,019 --> 00:26:42,830
数据库

707
00:26:42,830 --> 00:26:45,140
中 我对你们的问题是

708
00:26:45,140 --> 00:26:47,450
会发生什么 思科

709
00:26:47,450 --> 00:26:49,970
假设我的分配器已经

710
00:26:49,970 --> 00:26:52,370
分发了我

711
00:26:52,370 --> 00:26:54,620
拥有的所有页面 那已经预先分配了

712
00:26:54,620 --> 00:26:59,410
它实际上做了什么是的

713
00:26:59,410 --> 00:27:03,110
他说调用 s break 是的有点好

714
00:27:03,110 --> 00:27:05,030
是的，这是正确的，因为 break 将

715
00:27:05,030 --> 00:27:07,040
扩展流程数据段，

716
00:27:07,040 --> 00:27:08,060
但这只是将其移动得

717
00:27:08,060 --> 00:27:11,240
更大，但在那之后它实际上没有

718
00:27:11,240 --> 00:27:12,860
做任何事情它是 就像一整天都在

719
00:27:12,860 --> 00:27:15,260
更新

720
00:27:15,260 --> 00:27:17,000
它为此边界所具有的内部簿记数据结构，

721
00:27:17,000 --> 00:27:18,800
但是刚刚

722
00:27:18,800 --> 00:27:20,780
分配给 S 中断的所有虚拟内存

723
00:27:20,780 --> 00:27:23,090
实际上并不是物理分配的 在内存中编辑，

724
00:27:23,090 --> 00:27:26,030
因为没有人能够获得债务

725
00:27:26,030 --> 00:27:27,770
只有当我们接触数据时，

726
00:27:27,770 --> 00:27:29,870
他们才会得到补偿，然后操作系统说

727
00:27:29,870 --> 00:27:30,860
哦，看起来你真的要

728
00:27:30,860 --> 00:27:32,810
使用这个内存让我走可能有并

729
00:27:32,810 --> 00:27:37,040
得到物理支持 内存

730
00:27:37,040 --> 00:27:38,660
现在虽然让我们说在页面

731
00:27:38,660 --> 00:27:40,640
错误之后所以在调用中断之后

732
00:27:40,640 --> 00:27:42,430
有人试图访问这个

733
00:27:42,430 --> 00:27:44,480
内存我们实际上要把

734
00:27:44,480 --> 00:27:48,250
这个我们刚刚分配的这个内存周

735
00:27:48,490 --> 00:27:52,910
放让我猜猜是它

736
00:27:52,910 --> 00:27:54,050
分配的线程 它或者是

737
00:27:54,050 --> 00:27:57,650
接触它的线程 接触它

738
00:27:57,650 --> 00:28:01,220
为什么这就是论文所说的 是的 好的

739
00:28:01,220 --> 00:28:01,580
好极了

740
00:28:01,580 --> 00:28:05,390
好的 是的 所以有一个策略

741
00:28:05,390 --> 00:28:08,630
告诉操作系统，任何线程

742
00:28:08,630 --> 00:28:10,130
接触到我

743
00:28:10,130 --> 00:28:11,270
想要分配的内存，所以当有这样的时候

744
00:28:11,270 --> 00:28:13,790
我 可以分配它成人调用 s

745
00:28:13,790 --> 00:28:15,800
break 为我的进程从光扩展虚拟内存

746
00:28:15,800 --> 00:28:17,600
但只有一个没有威胁

747
00:28:17,600 --> 00:28:18,830
触及它然后有页面错误

748
00:28:18,830 --> 00:28:20,480
然后我们把它放在那个物理

749
00:28:20,480 --> 00:28:27,530
位置是的这个问题是操作系统

750
00:28:27,530 --> 00:28:29,960
不能保证 virt  ual内存，除非它

751
00:28:29,960 --> 00:28:31,370
有物理内存你有什么我

752
00:28:31,370 --> 00:28:33,850
保证

753
00:28:37,610 --> 00:28:41,070
认为大我想要1TB

754
00:28:41,070 --> 00:28:53,520
的内存会发生什么哦，你不能，你

755
00:28:53,520 --> 00:29:03,620
不能是的，是的，这很糟糕，但它是错的，

756
00:29:05,900 --> 00:29:08,760
是的，磷酸盐是的，所以实际上就是这样

757
00:29:08,760 --> 00:29:10,560
如果您使用我们数据库系统中的 SAN 运行一些测试，您现在可以看到这一点，

758
00:29:10,560 --> 00:29:12,690


759
00:29:12,690 --> 00:29:15,000
它会说

760
00:29:15,000 --> 00:29:16,590
数据库进程的虚拟内存大小为

761
00:29:16,590 --> 00:29:19,860
12 TB，我们显然

762
00:29:19,860 --> 00:29:23,750
在任何机器上都没有 12 TB，

763
00:29:23,750 --> 00:29:26,700
所以操作系统 在这里做出决定，

764
00:29:26,700 --> 00:29:29,250
就像大多数人会分配

765
00:29:29,250 --> 00:29:30,630
比他们实际需要的更多的内存，所以我

766
00:29:30,630 --> 00:29:33,120
会让你拥有它，如果你

767
00:29:33,120 --> 00:29:34,680
最终需要它，那么你是的，你

768
00:29:34,680 --> 00:29:36,990
必须开始将页面交换

769
00:29:36,990 --> 00:29:39,150
到交换 磁盘上的空间，这让它

770
00:29:39,150 --> 00:29:40,290
看起来是虚拟内存，它

771
00:29:40,290 --> 00:29:41,370
看起来像你拥有的内存比你

772
00:29:41,370 --> 00:29:42,090
实际拥有

773
00:29:42,090 --> 00:29:46,590


774
00:29:46,590 --> 00:29:48,300


775
00:29:48,300 --> 00:29:50,100


776
00:29:50,100 --> 00:29:52,040
的多 将工具放在桌子上 自己

777
00:29:52,040 --> 00:29:56,370
我们会使用那个空间所以看到

778
00:29:56,370 --> 00:29:58,710
这个就好了我

779
00:29:58,710 --> 00:30:00,240
不会分配我不会转向

780
00:30:00,240 --> 00:30:01,830
任何人说哀悼并预先分配

781
00:30:01,830 --> 00:30:04,230
你知道1GB的内存

782
00:30:04,230 --> 00:30:06,300
只有当我开始插入时 我已经

783
00:30:06,300 --> 00:30:07,920
识别的数据哦

784
00:30:07,920 --> 00:30:09,360
，我的预分配内存空间不足，

785
00:30:09,360 --> 00:30:11,760
我现在让我去抢另一个你知道

786
00:30:11,760 --> 00:30:14,370
100 兆字节将它分解以阻止开始

787
00:30:14,370 --> 00:30:16,800
填充数据 所以问题是我们正在

788
00:30:16,800 --> 00:30:18,270
尝试 到这里就像当我这样做

789
00:30:18,270 --> 00:30:20,760
时，默认情况下实际上存储的 M 内存在哪里，

790
00:30:20,760 --> 00:30:22,860
您可以在

791
00:30:22,860 --> 00:30:25,290
操作系统执行循环的地方开始只

792
00:30:25,290 --> 00:30:28,110
写出页面以一次靠在一个套接字

793
00:30:28,110 --> 00:30:29,820
中，然后一遍又一

794
00:30:29,820 --> 00:30:32,370
遍地重复什么 他在指出

795
00:30:32,370 --> 00:30:34,230
论文时说，您可以告诉操作系统我想

796
00:30:34,230 --> 00:30:36,330
使用第一个触摸策略，以便我

797
00:30:36,330 --> 00:30:38,700
分配内存，然后当

798
00:30:38,700 --> 00:30:41,330
任务实际开始将其

799
00:30:41,330 --> 00:30:44,460
插入该块时，就会出现页面

800
00:30:44,460 --> 00:30:46,410
错误 然后就是

801
00:30:46,410 --> 00:30:47,910
更新虚拟内存表的时候 现在

802
00:30:47,910 --> 00:30:49,639
回到物理内存，然后我可以

803
00:30:49,639 --> 00:30:53,269
将数据放入表中，

804
00:30:53,269 --> 00:30:54,649
物理内存将在我的

805
00:30:54,649 --> 00:30:59,239
威胁实际再次运行的任何地方

806
00:30:59,239 --> 00:31:00,979
你可以这样做你可以

807
00:31:00,979 --> 00:31:02,629
在你可以调用移动之后修改位置

808
00:31:02,629 --> 00:31:05,899
pages sis 打电话说

809
00:31:05,899 --> 00:31:07,729
好吧我已经加载了我的桌子并让我

810
00:31:07,729 --> 00:31:09,019
开始相应地移动东西

811
00:31:09,019 --> 00:31:10,309
但这实际上显然很愚蠢

812
00:31:10,309 --> 00:31:12,440
因为如果我加载一个 1

813
00:31:12,440 --> 00:31:13,759
TB 的数据是我不想首先加载它

814
00:31:13,759 --> 00:31:15,259
只是让它

815
00:31:15,259 --> 00:31:16,999
随机分散然后返回

816
00:31:16,999 --> 00:31:18,769
并进行顺序扫描然后实际

817
00:31:18,769 --> 00:31:19,940
开始你知道将事情移动到

818
00:31:19,940 --> 00:31:22,190
正确的位置我想提前使用此策略请

819
00:31:22,190 --> 00:31:23,839
注意

820
00:31:23,839 --> 00:31:27,499
我安排的日程安排可能是我的

821
00:31:27,499 --> 00:31:29,989
任务 这样我就可以

822
00:31:29,989 --> 00:31:31,759
在所有

823
00:31:31,759 --> 00:31:36,200
线程中均匀分布数据或关闭所有套接字，

824
00:31:36,200 --> 00:31:38,509
让我们看看当我们对数据的放置位置进行细粒度控制时会产生什么影响，

825
00:31:38,509 --> 00:31:39,799


826
00:31:39,799 --> 00:31:41,509
所以我

827
00:31:41,509 --> 00:31:42,889
将首先在此处展示幻灯片 将是 LTP 和第一个

828
00:31:42,889 --> 00:31:44,839
OLAP 所以这是

829
00:31:44,839 --> 00:31:47,299
几年前来自 EPFL 的 natasa Telemachus

830
00:31:47,299 --> 00:31:49,639
小组的一篇论文，所以这是

831
00:31:49,639 --> 00:31:51,919
在四插槽机器上运行内存数据库，

832
00:31:51,919 --> 00:31:54,559
每插槽 6 核，每插槽 6 核

833
00:31:54,559 --> 00:31:56,539
，它们 '只是要运行

834
00:31:56,539 --> 00:31:59,599
TPCC 支付交易，

835
00:31:59,599 --> 00:32:01,639
他们要做的是

836
00:32:01,639 --> 00:32:04,759
将不同的仓库或

837
00:32:04,759 --> 00:32:07,279
数据库的数据块

838
00:32:07,279 --> 00:32:09,829
放在不同的套接字配置上，

839
00:32:09,829 --> 00:32:11,929
因此每个

840
00:32:11,929 --> 00:32:15,799
每个套接字都有你知道

841
00:32:15,799 --> 00:32:17,029
总表组的四分之一的相等部分

842
00:32:17,029 --> 00:32:18,979
是你将

843
00:32:18,979 --> 00:32:20,690
所有东西推到单个套接字混合

844
00:32:20,690 --> 00:32:22,639
的地方你将它分成 50/50 并且操作系统

845
00:32:22,639 --> 00:32:24,109
只是让操作系统做任何事情

846
00:32:24,109 --> 00:32:25,909
一次，我在

847
00:32:25,909 --> 00:32:27,979
这里打了问号，因为就像我们不知道所以

848
00:32:27,979 --> 00:32:29,450
无论操作系统

849
00:32:29,450 --> 00:32:31,849
决定做什么策略都是它得到的所以你

850
00:32:31,849 --> 00:32:34,929
可以在这里很明显地看到我们的

851
00:32:34,929 --> 00:32:37,159
线程是否可以访问所有

852
00:32:37,159 --> 00:32:39,079
正在运行的数据 在同一个插座上，你会

853
00:32:39,079 --> 00:32:40,759
比操作系统的功能提高大约 30%，

854
00:32:40,759 --> 00:32:42,499
因为操作系统会做

855
00:32:42,499 --> 00:32:44,119


856
00:32:44,119 --> 00:32:45,289
一些看起来比传播更聪明的事情，

857
00:32:45,289 --> 00:32:47,479
但并不是说你

858
00:32:47,479 --> 00:32:50,539
比混合或分组更聪明，所以我们这

859
00:32:50,539 --> 00:32:51,829
只是向你展示，如果你 让

860
00:32:51,829 --> 00:32:53,749
操作系统负责决定

861
00:32:53,749 --> 00:32:55,309
他们将在哪里放置数据以及

862
00:32:55,309 --> 00:32:58,729
将在哪里安排我们的线程是你

863
00:32:58,729 --> 00:33:00,319
有一个糟糕的时间，如果你

864
00:33:00,319 --> 00:33:01,790
自己做

865
00:33:01,790 --> 00:33:05,000
对了，当我想到学生时，你会得到 30% 的

866
00:33:05,000 --> 00:33:05,960
好 所有的联邦调查局都在某个 Woonsocket 上运行，

867
00:33:05,960 --> 00:33:08,360
所以你可能会想

868
00:33:08,360 --> 00:33:10,280
，如果我

869
00:33:10,280 --> 00:33:12,200
分散在多个套接字上，这样

870
00:33:12,200 --> 00:33:15,710
我们的线程让你知道

871
00:33:15,710 --> 00:33:17,150
CPU 缓存的更大部分对自己

872
00:33:17,150 --> 00:33:18,800
来说不是更好的，因为没有，因为要过一遍

873
00:33:18,800 --> 00:33:20,570
互连以将数据从一个

874
00:33:20,570 --> 00:33:22,910
线程传输到下一个线程会出现

875
00:33:22,910 --> 00:33:24,290
问题，因为此支付

876
00:33:24,290 --> 00:33:26,060
交易将更新

877
00:33:26,060 --> 00:33:27,890
不同分区的数据，因此您可能

878
00:33:27,890 --> 00:33:31,550
必须爬上套接字，我想展示的下一张幻灯片

879
00:33:31,550 --> 00:33:34,040
是微型本 我的

880
00:33:34,040 --> 00:33:35,840
一些以前的学生

881
00:33:35,840 --> 00:33:38,630
几年前运行的 chmark 实验 所以这是运行一种

882
00:33:38,630 --> 00:33:41,030
他们为 618 编写的简单执行引擎

883
00:33:41,030 --> 00:33:44,360
我认为

884
00:33:44,360 --> 00:33:45,830
它要做的只是顺序

885
00:33:45,830 --> 00:33:48,410
扫描超过 1000 万个元组，他们 将

886
00:33:48,410 --> 00:33:50,300
要在我们在 PTL 或 PDL 中使用的野兽机器上运行它 在

887
00:33:50,300 --> 00:33:53,450


888
00:33:53,450 --> 00:33:56,840
2008 年之前的机器上有八个插槽，

889
00:33:56,840 --> 00:33:58,400
它有点旧，但就像

890
00:33:58,400 --> 00:34:00,640
我们可以访问的唯一一个插槽机器一样，

891
00:34:00,640 --> 00:34:03,020
每个插槽都有 10 个内核加上

892
00:34:03,020 --> 00:34:05,690
超线程，所以

893
00:34:05,690 --> 00:34:07,130
你可以看到沿 x 轴的内容是他们将

894
00:34:07,130 --> 00:34:09,080
添加更多线程来并行执行顺序

895
00:34:09,080 --> 00:34:11,418
扫描，因此

896
00:34:11,418 --> 00:34:13,040
表的大小始终相同，现在

897
00:34:13,040 --> 00:34:14,360
我们只是添加更多线程 这样

898
00:34:14,360 --> 00:34:17,000
我们就可以知道确实确实

899
00:34:17,000 --> 00:34:19,929
并行执行扫描，所以您看到的是，

900
00:34:19,929 --> 00:34:22,969
在较低的核心计数或线程

901
00:34:22,969 --> 00:34:24,440
计数下，两者

902
00:34:24,440 --> 00:34:27,290
之间的性能差异因此raina

903
00:34:27,290 --> 00:34:28,850
分区就像您只是让操作系统决定

904
00:34:28,850 --> 00:34:29,480
要放置的位置 它

905
00:34:29,480 --> 00:34:31,070
是当地的标准 tition 是您

906
00:34:31,070 --> 00:34:33,320
分配线程

907
00:34:33,320 --> 00:34:35,810
以对其编号本地的数据执行扫描的地方，

908
00:34:35,810 --> 00:34:38,449
因此在较低的线程计数处，因为

909
00:34:38,449 --> 00:34:40,820
该表分布在多个

910
00:34:40,820 --> 00:34:45,230
套接字上，线程

911
00:34:45,230 --> 00:34:46,730
将不得不访问远程

912
00:34:46,730 --> 00:34:48,830
套接字上的数据的概率 并通过互连

913
00:34:48,830 --> 00:34:51,800
更高，因此，

914
00:34:51,800 --> 00:34:53,110
如果您

915
00:34:53,110 --> 00:34:55,580
是否智能划分并不重要，但是随着我们现在

916
00:34:55,580 --> 00:34:58,220
增加线程

917
00:34:58,220 --> 00:35:00,470
数量，我们扫描线程的交叉套接字流量

918
00:35:00,470 --> 00:35:03,110


919
00:35:03,110 --> 00:35:05,180
显着下降 因为当我们进行

920
00:35:05,180 --> 00:35:07,070
本地分区本地分区时，

921
00:35:07,070 --> 00:35:08,240
这就是为什么你会获得更好的性能

922
00:35:08,240 --> 00:35:10,820
，然后这个划分点是

923
00:35:10,820 --> 00:35:12,980
当超线程进入

924
00:35:12,980 --> 00:35:14,090
80 个内核

925
00:35:14,090 --> 00:35:15,650
时，你只知道

926
00:35:15,650 --> 00:35:16,880
Harbour chorus 但在

927
00:35:16,880 --> 00:35:18,290
超线程中你得到了虚拟

928
00:35:18,290 --> 00:35:21,230
当然，在这一点上，我们

929
00:35:21,230 --> 00:35:23,420
受到内存带宽的限制，所以向

930
00:35:23,420 --> 00:35:25,160
我们扔更多的内核和更多的线程对

931
00:35:25,160 --> 00:35:26,660
我们没有任何帮助，因为它

932
00:35:26,660 --> 00:35:28,130
不像你知道的那样 读取被盗

933
00:35:28,130 --> 00:35:29,570
等待像磁盘 i/o 另一个线程

934
00:35:29,570 --> 00:35:31,400
它可以运行每个人只是等待

935
00:35:31,400 --> 00:35:32,840
从内存

936
00:35:32,840 --> 00:35:34,220
控制器中获取东西所以这就是性能稳定的原因

937
00:35:34,220 --> 00:35:37,730
所以这里的这种情况我忘记了

938
00:35:37,730 --> 00:35:39,680
确切的数字，但它几乎是 2 倍的

939
00:35:39,680 --> 00:35:41,420
性能差异

940
00:35:41,420 --> 00:35:43,190


941
00:35:43,190 --> 00:35:44,630
在我们如何做或你知道

942
00:35:44,630 --> 00:35:45,800
将我们的数据放在我们的

943
00:35:45,800 --> 00:35:49,250
运营商的运行时与让我们的操作系统和

944
00:35:49,250 --> 00:35:53,930
硬件管理器对我们的工作保持智能之间的性能差异之间或超过 2 倍的性能差异，正如我

945
00:35:53,930 --> 00:35:57,170
简单地说的，这就是

946
00:35:57,170 --> 00:35:58,520
分区和数据放置的概念 我们

947
00:35:58,520 --> 00:36:01,270
不会在这里讨论分区，

948
00:36:01,270 --> 00:36:03,530
但考虑一下分区方案

949
00:36:03,530 --> 00:36:06,650
，这是我们用来

950
00:36:06,650 --> 00:36:08,690
决定如何将数据分成

951
00:36:08,690 --> 00:36:11,000
块的一些策略，位置决定了

952
00:36:11,000 --> 00:36:12,530
放置策略决定了我们

953
00:36:12,530 --> 00:36:14,840
将这些分区放在哪里 所以

954
00:36:14,840 --> 00:36:18,560
放置策略

955
00:36:18,560 --> 00:36:20,180
与我们分区中的实际内容无关，

956
00:36:20,180 --> 00:36:21,890
你在 morsel paper 中看到了这一点，就

957
00:36:21,890 --> 00:36:23,780
在 morsel paper 中，说所有的

958
00:36:23,780 --> 00:36:24,800
威胁 c 是关于他们

959
00:36:24,800 --> 00:36:26,270
正在对本地数据进行操作，

960
00:36:26,270 --> 00:36:27,770
他们只是将其从队列中拉出，

961
00:36:27,770 --> 00:36:30,110
然后在分区方案中对其进行处理，您

962
00:36:30,110 --> 00:36:32,890
可以对如何划分数据具有一些更高级别的逻辑

963
00:36:32,890 --> 00:36:35,120
含义或语义

964
00:36:35,120 --> 00:36:36,830
然后您可以

965
00:36:36,830 --> 00:36:40,460
在查询执行中利用它，这

966
00:36:40,460 --> 00:36:42,110
就是我们将在以后的

967
00:36:42,110 --> 00:36:45,920
讲座中介绍的内容，例如如果我知道我的快速

968
00:36:45,920 --> 00:36:47,210
可能的工作负载总是

969
00:36:47,210 --> 00:36:51,080
在给定的分区上进行哈希连接或

970
00:36:51,080 --> 00:36:52,190
开始我想给出一个 属性

971
00:36:52,190 --> 00:36:54,140
然后我可以决定散列分区

972
00:36:54,140 --> 00:36:56,150
我的数据都在那个联合属性中，

973
00:36:56,150 --> 00:36:58,160
这样现在当我运行联合算法

974
00:36:58,160 --> 00:37:00,920
时，每个操作员

975
00:37:00,920 --> 00:37:03,370
需要操作来进行连接的所有数据都是它的

976
00:37:03,370 --> 00:37:06,470
本地数据，并且查询优化器

977
00:37:06,470 --> 00:37:08,750
知道

978
00:37:08,750 --> 00:37:11,270
当我们

979
00:37:11,270 --> 00:37:15,590
在这里进行数据放置调度时，这个分区方案所有这些都

980
00:37:15,590 --> 00:37:17,090


981
00:37:17,090 --> 00:37:19,100
在我们之上

982
00:37:19,100 --> 00:37:20,960


983
00:37:20,960 --> 00:37:23,660


984
00:37:23,660 --> 00:37:25,850
测试应该在哪里实际运行它的

985
00:37:25,850 --> 00:37:28,220
内存是本地的，我们决定了

986
00:37:28,220 --> 00:37:29,359
我们将如何看待它你知道

987
00:37:29,359 --> 00:37:32,660
我们将使用什么机制将

988
00:37:32,660 --> 00:37:36,200
内存块或数据块固定

989
00:37:36,200 --> 00:37:39,049
到内存位置所以现在 我们

990
00:37:39,049 --> 00:37:39,950
需要讨论我们实际上如何

991
00:37:39,950 --> 00:37:41,869
创建一堆我们想要

992
00:37:41,869 --> 00:37:44,660
为我们的逻辑

993
00:37:44,660 --> 00:37:47,420
查询计划执行的任务，然后一旦我们有了这些任务，

994
00:37:47,420 --> 00:37:48,470
我们就可以撇开我们实际上

995
00:37:48,470 --> 00:37:51,470
要如何安排 他们所以

996
00:37:51,470 --> 00:37:53,660
402 B 查询这非常简单，

997
00:37:53,660 --> 00:37:55,999
因为大多数时候在单个旧查询中

998
00:37:55,999 --> 00:37:57,589
实际上没有任何并行性的机会

999
00:37:57,589 --> 00:38:00,259
我可以

1000
00:38:00,259 --> 00:38:01,700


1001
00:38:01,700 --> 00:38:03,289
在不同的事务中同时运行多个 OTP 查询，

1002
00:38:03,289 --> 00:38:04,880
当然我想让它们运行 在

1003
00:38:04,880 --> 00:38:06,079
单独的线程上，他们想

1004
00:38:06,079 --> 00:38:09,109
在你知道的具有本地内存的套接字上运行，

1005
00:38:09,109 --> 00:38:11,450
但是

1006
00:38:11,450 --> 00:38:13,519
对于他们想要访问但在

1007
00:38:13,519 --> 00:38:15,380
单个或要查询的数据中，我无法真正

1008
00:38:15,380 --> 00:38:17,390
将其划分为子 大块

1009
00:38:17,390 --> 00:38:20,660
就像去获取 andis 帐户记录一样，这

1010
00:38:20,660 --> 00:38:22,369
就像一个单一的和下一个探针去获取

1011
00:38:22,369 --> 00:38:23,210
我的一个记录

1012
00:38:23,210 --> 00:38:25,819
我不能瘫痪，所以

1013
00:38:25,819 --> 00:38:27,440
这就是我们关心的，这是

1014
00:38:27,440 --> 00:38:30,200
针对 OLAP 查询的，然后我们

1015
00:38:30,200 --> 00:38:31,640
现在仍然可以申请 我们将要使用相同的技术

1016
00:38:31,640 --> 00:38:32,839
来调度 OLAP

1017
00:38:32,839 --> 00:38:35,210
查询以同时调度多个最终查询

1018
00:38:35,210 --> 00:38:36,920
，这些查询

1019
00:38:36,920 --> 00:38:37,970
代表不同的事务运行，

1020
00:38:37,970 --> 00:38:42,200
因此最简单的

1021
00:38:42,200 --> 00:38:44,359
调度方法称为静态段，

1022
00:38:44,359 --> 00:38:45,769
这就是数据不存在的地方

1023
00:38:45,769 --> 00:38:47,029
在它甚至开始超过查询之前就决定

1024
00:38:47,029 --> 00:38:48,920
我

1025
00:38:48,920 --> 00:38:52,549
知道我拥有的线程数当然我

1026
00:38:52,549 --> 00:38:54,950
可以决定就像我只会说我

1027
00:38:54,950 --> 00:38:56,779
对每个核心都有一个任务然后将它们推

1028
00:38:56,779 --> 00:38:59,410
到硬件上并让它们 正确执行，

1029
00:38:59,410 --> 00:39:02,269
所以这是最简单的事情，

1030
00:39:02,269 --> 00:39:04,309
因为我不担心

1031
00:39:04,309 --> 00:39:06,200
在任务运行时监控任务的行为

1032
00:39:06,200 --> 00:39:08,480
我只是说这是我的计划我

1033
00:39:08,480 --> 00:39:10,460
坚持它，我不关心

1034
00:39:10,460 --> 00:39:13,339
替代方案 这是第 e 如果您

1035
00:39:13,339 --> 00:39:14,390
是第一次构建数据系统，

1036
00:39:14,390 --> 00:39:15,799
这可能就是您最终

1037
00:39:15,799 --> 00:39:16,910
构建的内容，因为

1038
00:39:16,910 --> 00:39:19,970
再次这样做是最简单的事情，这

1039
00:39:19,970 --> 00:39:22,099
与安置政策的内容不同，

1040
00:39:22,099 --> 00:39:24,109
我们在政策中占有一席之地 进入

1041
00:39:24,109 --> 00:39:27,140
我们，我们用来将

1042
00:39:27,140 --> 00:39:28,220
任务分配给线程 基本上数据

1043
00:39:28,220 --> 00:39:29,989
位置 这只是说

1044
00:39:29,989 --> 00:39:33,140
我们如何划分我们的任务以及在

1045
00:39:33,140 --> 00:39:35,440
运行时我们如何实际安排它们

1046
00:39:35,440 --> 00:39:39,259
所以我让你们的方法是

1047
00:39:39,259 --> 00:39:40,730
原因 为什么我是 Paulo Matic 用于

1048
00:39:40,730 --> 00:39:43,069
OLAP 查询，特别是

1049
00:39:43,069 --> 00:39:46,849
它没有考虑到你

1050
00:39:46,849 --> 00:39:48,769
知道这些单独任务的运行时间

1051
00:39:48,769 --> 00:39:50,779
只有不同的法庭，所以如果我有

1052
00:39:50,779 --> 00:39:53,029
那个 1 TB 的数据库并且我有一个

1053
00:39:53,029 --> 00:39:54,499
我正在做的 sim 使用谓词对其进行扫描

1054
00:39:54,499 --> 00:39:56,660
，无论出于何种原因，在一个

1055
00:39:56,660 --> 00:40:00,589
套接字上，该谓词在该套接字上的数据

1056
00:40:00,589 --> 00:40:02,359
对于更多元组评估为真，

1057
00:40:02,359 --> 00:40:04,309
其中

1058
00:40:04,309 --> 00:40:05,569
谓词非常有选择性的每个其他套接字都非常有选择性，所以我

1059
00:40:05,569 --> 00:40:06,680
最终应该丢弃大部分数据

1060
00:40:06,680 --> 00:40:09,739
所以这意味着现在我的任务

1061
00:40:09,739 --> 00:40:11,599
在我的一个套接字上运行它会

1062
00:40:11,599 --> 00:40:14,420
比另一个袜子花费更长的时间来完成

1063
00:40:14,420 --> 00:40:16,819
那个任务，因为更多的元组

1064
00:40:16,819 --> 00:40:18,709
被放入它的输出缓冲区，因为

1065
00:40:18,709 --> 00:40:21,109
它正在做更多的内存复制，如果我是

1066
00:40:21,109 --> 00:40:22,579
静态调度方法 我无法

1067
00:40:22,579 --> 00:40:24,289
动态调整系统，然后说

1068
00:40:24,289 --> 00:40:25,759
好吧，我看到这家伙的速度很

1069
00:40:25,759 --> 00:40:28,099
慢，而且有更多的数据

1070
00:40:28,099 --> 00:40:30,229
可能会执行

1071
00:40:30,229 --> 00:40:32,509
我们正在等待的该死的赌注让我去引入

1072
00:40:32,509 --> 00:40:34,249
其他线程来帮助它加快速度

1073
00:40:34,249 --> 00:40:36,920
事情变得如此静态 - 你不能那样做，

1074
00:40:36,920 --> 00:40:38,989
但这是动态调度

1075
00:40:38,989 --> 00:40:40,789
可以处理的问题，这

1076
00:40:40,789 --> 00:40:42,079
是超级家伙试图解决

1077
00:40:42,079 --> 00:40:44,719
他们的方法的问题，所以更受驱动的

1078
00:40:44,719 --> 00:40:46,969
调度是我们的想法

1079
00:40:46,969 --> 00:40:48,729
将在这些他们称为 morsels 的水平分区上并行处理我们的任务，

1080
00:40:48,729 --> 00:40:50,959


1081
00:40:50,959 --> 00:40:53,479
因此 morsel 是一个超级

1082
00:40:53,479 --> 00:40:55,130
术语，它不像数据库系统中的标准术语，

1083
00:40:55,130 --> 00:40:57,529
我认为他们选择它

1084
00:40:57,529 --> 00:40:59,269
是因为他们不想使用

1085
00:40:59,269 --> 00:41:00,499
术语 bloc  k 因为那使用了

1086
00:41:00,499 --> 00:41:01,880
很多地方 他们没有使用术语

1087
00:41:01,880 --> 00:41:02,900
分区 因为那已经是

1088
00:41:02,900 --> 00:41:05,229
一堆你可以使用尽可能多的地方 像一

1089
00:41:05,229 --> 00:41:07,579
点点比一个块大但

1090
00:41:07,579 --> 00:41:09,380
比一个分区小 这是一种

1091
00:41:09,380 --> 00:41:11,150
考虑它的方式 你知道

1092
00:41:11,150 --> 00:41:12,410
在这个术语中没有其他系统实际使用

1093
00:41:12,410 --> 00:41:15,049
这是特定于 hyper 的，所以他们

1094
00:41:15,049 --> 00:41:17,959
每个核心会有一个工作人员，所以

1095
00:41:17,959 --> 00:41:19,789
你有一个多核套接字你可以

1096
00:41:19,789 --> 00:41:21,619
有多个内核，每个支持该

1097
00:41:21,619 --> 00:41:23,959
套接字可以有一个基于池的 任务

1098
00:41:23,959 --> 00:41:26,509
einman 意味着工作人员将

1099
00:41:26,509 --> 00:41:27,920
要运行他们将检查一些集中的

1100
00:41:27,920 --> 00:41:29,329
数据结构并说明哪些工作

1101
00:41:29,329 --> 00:41:31,699
可供我使用，然后当

1102
00:41:31,699 --> 00:41:33,259
他们加载数据时，他们将

1103
00:41:33,259 --> 00:41:35,299
进行循环数据放置，因此他们将

1104
00:41:35,299 --> 00:41:36,859
拥有 你知道说我正在做一个批量

1105
00:41:36,859 --> 00:41:39,739
插入，我会说

1106
00:41:39,739 --> 00:41:41,180
这个球的一部分进入这个插座，另一

1107
00:41:41,180 --> 00:41:43,009
部分进入这个办公室我得到了

1108
00:41:43,009 --> 00:41:46,009
一些东西，所以他们的方法会很有趣

1109
00:41:46,009 --> 00:41:47,839
的是

1110
00:41:47,839 --> 00:41:50,089
数据库 ase

1111
00:41:50,089 --> 00:41:52,309
系统将完全了解 Numa，

1112
00:41:52,309 --> 00:41:54,289
这意味着他们将拥有

1113
00:41:54,289 --> 00:41:56,630
运算符的实现，以

1114
00:41:56,630 --> 00:41:58,250
识别他们是在访问

1115
00:41:58,250 --> 00:42:00,830
本地数字区域还是远程 Numa 区域上的数据，

1116
00:42:00,830 --> 00:42:03,200
并且他们将执行

1117
00:42:03,200 --> 00:42:04,520
不同的策略来放置位置

1118
00:42:04,520 --> 00:42:06,560
他们把输出数据或

1119
00:42:06,560 --> 00:42:08,110
他们实际想要使用的专辑放在

1120
00:42:08,110 --> 00:42:10,790
正确的位置，当他们

1121
00:42:10,790 --> 00:42:12,050
决定如何

1122
00:42:12,050 --> 00:42:16,820
从任务任务队列中拉出东西时，他们会使用它，就像我说的那样，

1123
00:42:16,820 --> 00:42:18,470
他们正在使用拉模型，以便

1124
00:42:18,470 --> 00:42:19,610
意味着没有单独的调度程序

1125
00:42:19,610 --> 00:42:21,440
线程，没有单个线程

1126
00:42:21,440 --> 00:42:22,910
负责对整个系统中发生的事情有全局视图，

1127
00:42:22,910 --> 00:42:25,700
并且

1128
00:42:25,700 --> 00:42:27,440
线程正在做工人争论

1129
00:42:27,440 --> 00:42:28,510
合作调度，因为

1130
00:42:28,510 --> 00:42:31,370
每个人都在看同一个队列，所以

1131
00:42:31,370 --> 00:42:32,810
会发生的是，当 他们

1132
00:42:32,810 --> 00:42:35,300
从这个队列中拉出任务，每个工作

1133
00:42:35,300 --> 00:42:37,510
线程将更喜欢

1134
00:42:37,510 --> 00:42:39,650
不会操作本地数据的任务的威胁，

1135
00:42:39,650 --> 00:42:42,680
但它也可以

1136
00:42:42,680 --> 00:42:44,720
识别出没有

1137
00:42:44,720 --> 00:42:46,070
对它可用的 ests

1138
00:42:46,070 --> 00:42:48,650
正在使用本地数据进行操作，然后尝试

1139
00:42:48,650 --> 00:42:51,500
从另一个工作线程窃取工作或窃取任务，这些工作

1140
00:42:51,500 --> 00:42:54,110
线程可能正在操作

1141
00:42:54,110 --> 00:42:55,820
对我的工作线程来说远程的数据，

1142
00:42:55,820 --> 00:42:57,620
但是因为这个其他工作

1143
00:42:57,620 --> 00:43:00,590
线程由于某种原因运行缓慢 我们将

1144
00:43:00,590 --> 00:43:02,350
填补空缺并采取他们的一些工作

1145
00:43:02,350 --> 00:43:05,210
，然后他们的方法也 - 我

1146
00:43:05,210 --> 00:43:06,800
实际上并不是我的幻灯片，但在

1147
00:43:06,800 --> 00:43:09,380
他们的模型中，他们一次只执行一个查询

1148
00:43:09,380 --> 00:43:12,650
，因此查询显示他们' 重新

1149
00:43:12,650 --> 00:43:13,790
将其分解为一堆任务，

1150
00:43:13,790 --> 00:43:15,680
并且在该查询的

1151
00:43:15,680 --> 00:43:17,960
所有任务完成之前您不会继续进行下

1152
00:43:17,960 --> 00:43:19,010
一个查询，

1153
00:43:19,010 --> 00:43:21,560
因此要么查询已

1154
00:43:21,560 --> 00:43:22,550
完全完成并且没有更多

1155
00:43:22,550 --> 00:43:23,780
可用任务 我继续

1156
00:43:23,780 --> 00:43:26,060
下一个，或者一个工作线程可以去窃取

1157
00:43:26,060 --> 00:43:28,940
那些落后的工作人员无法

1158
00:43:28,940 --> 00:43:39,370


1159
00:43:39,690 --> 00:43:42,130


1160
00:43:42,130 --> 00:43:43,810


1161
00:43:43,810 --> 00:43:45,670
跟上的任务 会

1162
00:43:45,670 --> 00:43:47,230
称之为di  spatcher

1163
00:43:47,230 --> 00:43:49,300
有点像查询显示的前端层

1164
00:43:49,300 --> 00:43:51,640
你解析它你

1165
00:43:51,640 --> 00:43:52,840
知道查询优化器的续集前端

1166
00:43:52,840 --> 00:43:54,550
然后你

1167
00:43:54,550 --> 00:43:56,140
有一个你将它们分成任务

1168
00:43:56,140 --> 00:43:58,150
然后确定 队列以及它是否

1169
00:43:58,150 --> 00:44:00,070
是

1170
00:44:00,070 --> 00:44:01,630
与网络线程

1171
00:44:01,630 --> 00:44:03,070
或网络线程本身分开的专用线程，

1172
00:44:03,070 --> 00:44:04,859
这无关紧要此时我

1173
00:44:04,859 --> 00:44:06,880
实际上不知道它们在我们

1174
00:44:06,880 --> 00:44:09,730
当前的系统中做什么，我们使用相同的

1175
00:44:09,730 --> 00:44:12,340
线程 网络套接字的续集查询

1176
00:44:12,340 --> 00:44:14,470
解析它绑定它不能

1177
00:44:14,470 --> 00:44:16,630
很好地购买它然后将它分开但是

1178
00:44:16,630 --> 00:44:18,630
你可以将它交给另一个队列

1179
00:44:18,630 --> 00:44:23,140
是的这个问题是如何工作的你

1180
00:44:23,140 --> 00:44:23,530
只工作

1181
00:44:23,530 --> 00:44:26,530
给我两张幻灯片我们会得到所有

1182
00:44:26,530 --> 00:44:27,460
是的，我们需要做的第一件事就是

1183
00:44:27,460 --> 00:44:29,410
将我们的数据分成小块 所以

1184
00:44:29,410 --> 00:44:31,060
说这是我们的数据表 我们有四

1185
00:44:31,060 --> 00:44:33,940
列 所以小块只是水平

1186
00:44:33,940 --> 00:44:35,680
分区 我们会

1187
00:44:35,680 --> 00:44:38,950
在一些努力中说这

1188
00:44:38,950 --> 00:44:42,820
就是这 在他们谈论的论文中几乎没有任何一点

1189
00:44:42,820 --> 00:44:44,290
他们

1190
00:44:44,290 --> 00:44:45,580
每个人使用十万两个池

1191
00:44:45,580 --> 00:44:47,859
他们说他们选择这个

1192
00:44:47,859 --> 00:44:49,930
数字是因为它提供了

1193
00:44:49,930 --> 00:44:51,250
适量的并行性而不是

1194
00:44:51,250 --> 00:44:53,890
将东西放入队列的开销，因此

1195
00:44:53,890 --> 00:44:56,260
对于每个任务 我退出

1196
00:44:56,260 --> 00:44:59,710
队列 我至少要

1197
00:44:59,710 --> 00:45:04,119
对 100,000 个元组进行操作，我们的块

1198
00:45:04,119 --> 00:45:06,760
大小是一千个元组，按老化

1199
00:45:06,760 --> 00:45:08,470
顺序排列 在我来见他之前我帮助建立的系统

1200
00:45:08,470 --> 00:45:10,690
我们做了十兆

1201
00:45:10,690 --> 00:45:12,460
字节 我记得从

1202
00:45:12,460 --> 00:45:13,900
这些系统的讨论中，我们只是

1203
00:45:13,900 --> 00:45:15,160
从她的屁股中挑选了这些数字，

1204
00:45:15,160 --> 00:45:16,510
就像它没有任何魔法一样

1205
00:45:16,510 --> 00:45:19,089
我认为在 hyper 的情况下，他们说

1206
00:45:19,089 --> 00:45:20,800
他们实际上做了一些你知道的一些

1207
00:45:20,800 --> 00:45:22,450
内部微基准来

1208
00:45:22,450 --> 00:45:23,619
确定一个 十万一实际上

1209
00:45:23,619 --> 00:45:25,869
在我们的新系统中实际上是合理的，正如

1210
00:45:25,869 --> 00:45:29,550
我在几堂课前所说的，我们的

1211
00:45:29,550 --> 00:45:32,680
块大小是 1 兆字节，因为这

1212
00:45:32,680 --> 00:45:34,770
允许

1213
00:45:34,770 --> 00:45:37,810
我们使用该行作为命令 i 的 20 位偏移量 nc + 11 我

1214
00:45:37,810 --> 00:45:39,520
不想在内存中一次又一次地对齐我们的 1

1215
00:45:39,520 --> 00:45:42,700
兆字节块，

1216
00:45:42,700 --> 00:45:44,410
所以对于这些肌肉中的每一个，我们

1217
00:45:44,410 --> 00:45:45,400
只需将它们分配到不同的

1218
00:45:45,400 --> 00:45:48,430
CPU 插槽，现在开始他的

1219
00:45:48,430 --> 00:45:50,410
问题我们如何 实际上要

1220
00:45:50,410 --> 00:45:52,330
进行工作窃取，所以说现在我们采用我们的

1221
00:45:52,330 --> 00:45:53,019
查询计划

1222
00:45:53,019 --> 00:45:54,969
，然后我们将把它分解成

1223
00:45:54,969 --> 00:45:57,189
不同的任务，然后我们将放入

1224
00:45:57,189 --> 00:45:59,289
这个全局队列，然后现在在这里

1225
00:45:59,289 --> 00:46:00,909
为它要拥有的每个套接字

1226
00:46:00,909 --> 00:46:02,919
本地内存，然后它会有一个

1227
00:46:02,919 --> 00:46:04,509
缓冲区，控制结果，但它

1228
00:46:04,509 --> 00:46:06,069
也有它

1229
00:46:06,069 --> 00:46:09,880
知道的所有部分是本地的，因此

1230
00:46:09,880 --> 00:46:12,729
缓冲区将在您处理我们

1231
00:46:12,729 --> 00:46:14,589
想要将数据写入本地缓冲区的任务时

1232
00:46:14,589 --> 00:46:16,059
这有点类似于我们

1233
00:46:16,059 --> 00:46:18,069
在超级方法中谈论做 Delta 存储的

1234
00:46:18,069 --> 00:46:21,429
方式，当我生成新

1235
00:46:21,429 --> 00:46:22,239
版本时，

1236
00:46:22,239 --> 00:46:24,459
我将旧版本放在线程本地

1237
00:46:24,459 --> 00:46:26,140
内存中，这意味着我不必

1238
00:46:26,140 --> 00:46:28,689
对全局共享进行加冕

1239
00:46:28,689 --> 00:46:30,729
多个线程被重新分配的内存空间

1240
00:46:30,729 --> 00:46:32,229
准备好了，同时我

1241
00:46:32,229 --> 00:46:34,089
知道此时没有威胁写入我的

1242
00:46:34,089 --> 00:46:35,289
缓冲区，所以我不会

1243
00:46:35,289 --> 00:46:38,229
锁定它，所以现在所有线程都

1244
00:46:38,229 --> 00:46:41,529
将查看队列并

1245
00:46:41,529 --> 00:46:43,089
拉下第一组 测试它必须

1246
00:46:43,089 --> 00:46:45,489
执行，因此在此任务中，您维护

1247
00:46:45,489 --> 00:46:46,749
有关任务之间这些之间的依赖关系的信息，

1248
00:46:46,749 --> 00:46:52,089
因此

1249
00:46:52,089 --> 00:46:53,619
它会知道我实际上无法

1250
00:46:53,619 --> 00:46:56,199
执行探测，直到我

1251
00:46:56,199 --> 00:46:58,019
构建哈希表并对其进行

1252
00:46:58,019 --> 00:47:00,519
分区 另一边，所以它知道

1253
00:47:00,519 --> 00:47:01,899
这些是我可以先执行的任务

1254
00:47:01,899 --> 00:47:05,679
，所以当每个线程

1255
00:47:05,679 --> 00:47:07,839
运行一个工作程序

1256
00:47:07,839 --> 00:47:09,639
时，它会从本地内存中提取数据，这

1257
00:47:09,639 --> 00:47:12,159
会很快，然后你知道实际上

1258
00:47:12,159 --> 00:47:14,019
X 使用运算符并产生一些

1259
00:47:14,019 --> 00:47:15,939
输出结果它现在将其写入其

1260
00:47:15,939 --> 00:47:21,689
本地缓冲区是的问题

1261
00:47:21,689 --> 00:47:24,639
是某种套接字中的全局任务队列

1262
00:47:24,639 --> 00:47:26,499
还是分布式我认为他们

1263
00:47:26,499 --> 00:47:28,119
让操作系统管理这个，因为

1264
00:47:28,119 --> 00:47:30,849
如果每个人都没有任何

1265
00:47:30,849 --> 00:47:31,779
东西 ne 必须读取和写入它

1266
00:47:31,779 --> 00:47:35,349
没有任何魔法你可以做并

1267
00:47:35,349 --> 00:47:38,789
考虑它 -

1268
00:47:44,340 --> 00:47:46,890
就像是的所以他的观点很好

1269
00:47:46,890 --> 00:47:49,620
我们会在 Hana 中看到这个等等他妈的这

1270
00:47:49,620 --> 00:47:51,930
是这个全局任务队列是

1271
00:47:51,930 --> 00:47:53,760
共享的 内存空间对，所以我需要，所以

1272
00:47:53,760 --> 00:47:55,650
他们将使用很多空闲的 lat

1273
00:47:55,650 --> 00:47:57,750
树哈希表，以避免

1274
00:47:57,750 --> 00:47:59,340
在此上同步或有大量

1275
00:47:59,340 --> 00:48:00,540
同步同步

1276
00:48:00,540 --> 00:48:03,810
原语，但您可以分区

1277
00:48:03,810 --> 00:48:05,430
此全局任务队列的内存，

1278
00:48:05,430 --> 00:48:07,530
以便这些 伙计们在他们的本地

1279
00:48:07,530 --> 00:48:08,970
记忆中首先找到

1280
00:48:08,970 --> 00:48:10,350
特定于他的任务，如果不去看看

1281
00:48:10,350 --> 00:48:11,850
其他的任务 Hana 会这样做 据

1282
00:48:11,850 --> 00:48:31,110
我所知超级 Hana 这样做这被看到了

1283
00:48:31,110 --> 00:48:35,270
几次 是的，有这句话我

1284
00:48:35,270 --> 00:48:42,990
认为是的 他们

1285
00:48:42,990 --> 00:48:45,090
没有这样做的一切，但

1286
00:48:45,090 --> 00:48:47,370
计划要做出的重点是一点点大小是

1287
00:48:47,370 --> 00:48:50,250
100 100 千元组，

1288
00:48:50,250 --> 00:48:52,260
如果我

1289
00:48:52,260 --> 00:48:53,940
要通过互连连接到远程

1290
00:48:53,940 --> 00:48:55,710
套接字，这就是瓶颈所在 瓶颈是阅读

1291
00:48:55,710 --> 00:48:58,290
这将要提取一个

1292
00:48:58,290 --> 00:49:02,100
可能是 1 千字节大小的任务，

1293
00:49:02,100 --> 00:49:04,770
我不是那么大，所以

1294
00:49:04,770 --> 00:49:06,900
要从内存区域提取一个东西，

1295
00:49:06,900 --> 00:49:09,180
这没什么大不了的，这不是

1296
00:49:09,180 --> 00:49:11,340
瓶颈所在，所以你想再次补充的

1297
00:49:11,340 --> 00:49:12,630
是，我是 知道法律我们想要

1298
00:49:12,630 --> 00:49:15,030
优化大开销的地方，或者把

1299
00:49:15,030 --> 00:49:16,560
我们所有的时间都花在这个上面，这

1300
00:49:16,560 --> 00:49:20,850
就是 Optima 好的，所以现在说

1301
00:49:20,850 --> 00:49:24,780
前两个线程确保

1302
00:49:24,780 --> 00:49:26,280
姐妹不会好前两个

1303
00:49:26,280 --> 00:49:28,830
线程完成了 前三个工作人员

1304
00:49:28,830 --> 00:49:30,420
完成了他们的任务，但第三个工作

1305
00:49:30,420 --> 00:49:32,460
人员运行得比我说的慢，所以也许

1306
00:49:32,460 --> 00:49:35,730
这个过滤器是非选择性的，所以我们正在

1307
00:49:35,730 --> 00:49:37,140
生成大量输出并运行

1308
00:49:37,140 --> 00:49:38,400
到我们的缓冲区中，这意味着我们

1309
00:49:38,400 --> 00:49:41,340
正在复制和错误更慢所以

1310
00:49:41,340 --> 00:49:44,370
现在其他两个工作人员可以去抓取

1311
00:49:44,370 --> 00:49:45,780
接下来的两个任务或执行

1312
00:49:45,780 --> 00:49:47,430
相同的事情，但是现在说第一个

1313
00:49:47,430 --> 00:49:49,050
虽然完成了这个任务

1314
00:49:49,050 --> 00:49:51,300
更快，然后它可以认识到

1315
00:49:51,300 --> 00:49:55,670
哦，b3 正在等待

1316
00:49:55,670 --> 00:49:56,930
也需要在我们退出之前执行

1317
00:49:56,930 --> 00:49:59,540
我们的管道或查询计划中的下一个任务，

1318
00:49:59,540 --> 00:50:01,790
所以让我

1319
00:50:01,790 --> 00:50:03,680
继续窃取这个家伙，将其关闭

1320
00:50:03,680 --> 00:50:06,590
并对其进行操作，这意味着

1321
00:50:06,590 --> 00:50:09,770
现在我在复制数据或移动数据，

1322
00:50:09,770 --> 00:50:11,480
我们不在 移动数据 你

1323
00:50:11,480 --> 00:50:13,940
从这里的套接字的内存中复制数据

1324
00:50:13,940 --> 00:50:15,860
你在这里放入

1325
00:50:15,860 --> 00:50:17,390
你的 CPU 缓存，以便

1326
00:50:17,390 --> 00:50:18,950
通过互连但是当我产生

1327
00:50:18,950 --> 00:50:20,720
输出然后我将把它写在我的

1328
00:50:20,720 --> 00:50:22,820
本地缓冲区和 有一些元数据

1329
00:50:22,820 --> 00:50:24,950
可以为这个任务

1330
00:50:24,950 --> 00:50:28,730


1331
00:50:28,730 --> 00:50:30,920
说明下一个操作员在我们的任务

1332
00:50:30,920 --> 00:50:33,140
队列中需要的敌人结果的位置，所以有一些

1333
00:50:33,140 --> 00:50:34,700
内部簿记

1334
00:50:34,700 --> 00:50:36,470
他们正在跟踪的第三个 Natur 知道这个

1335
00:50:36,470 --> 00:50:38,860
任务输出被写入 到这个位置

1336
00:50:38,860 --> 00:51:05,990
是的，我认为他们的意思

1337
00:51:05,990 --> 00:51:09,530
是他们不是因为

1338
00:51:09,530 --> 00:51:12,110
一切都在记忆中

1339
00:51:12,110 --> 00:51:14,510
就像在这里说的时间一样，当

1340
00:51:14,510 --> 00:51:17,060
他们都是A时，因为一切都

1341
00:51:17,060 --> 00:51:19,600
在记忆中他们会足够接近

1342
00:51:19,600 --> 00:51:21,770
不是这样的 事情会

1343
00:51:21,770 --> 00:51:24,110
在磁盘上等待，因此会

1344
00:51:24,110 --> 00:51:27,830
慢几分钟，就像这个想法又是一样

1345
00:51:27,830 --> 00:51:29,150
，因为他们一次只执行一个查询

1346
00:51:29,150 --> 00:51:31,460
，而不是让这个人

1347
00:51:31,460 --> 00:51:34,670
空闲等待 b2 完成然后 a3

1348
00:51:34,670 --> 00:51:35,810
必须完成然后必须 实际上

1349
00:51:35,810 --> 00:51:37,160
是三个，然后再连接到下一个

1350
00:51:37,160 --> 00:51:38,960
任务，然后继续并

1351
00:51:38,960 --> 00:51:46,070
窃取它

1352
00:51:46,070 --> 00:51:47,660


1353
00:51:47,660 --> 00:51:50,600


1354
00:51:50,600 --> 00:51:54,830
身体上你

1355
00:51:54,830 --> 00:51:56,510
知道永久地把它移到这里是

1356
00:51:56,510 --> 00:52:00,260
不对的，因为你可能会再次出现净得分

1357
00:52:00,260 --> 00:52:02,210
，现在也许这个

1358
00:52:02,210 --> 00:52:04,880
插座是慢的，

1359
00:52:04,880 --> 00:52:06,380
然后这个人可能会

1360
00:52:06,380 --> 00:52:06,830
从我这里偷回来，

1361
00:52:06,830 --> 00:52:09,470
通常你不会移动 内存

1362
00:52:09,470 --> 00:52:09,750


1363
00:52:09,750 --> 00:52:11,730
一旦一切就绪 一旦它已经

1364
00:52:11,730 --> 00:52:13,890
放置在您可能想要

1365
00:52:13,890 --> 00:52:17,400
报告的位置 重新分区 它可能会被拆分为

1366
00:52:17,400 --> 00:52:19,230
不同的属性 但这似乎

1367
00:52:19,230 --> 00:52:21,180
很少见，许多人说在这些系统

1368
00:52:21,180 --> 00:52:26,150
中也可以

1369
00:52:26,150 --> 00:52:28,740
，因为它们只 有一项工作

1370
00:52:28,740 --> 00:52:30,960
呃 procore hyper 已经使用了窃取工作，

1371
00:52:30,960 --> 00:52:32,610
因为否则

1372
00:52:32,610 --> 00:52:34,530
他们将会有线程等待落后

1373
00:52:34,530 --> 00:52:36,660
者，正如我们已经说过的那样，他们

1374
00:52:36,660 --> 00:52:37,830
使用了很多能够维持

1375
00:52:37,830 --> 00:52:39,690
全局工作使用的免费哈希，因此这意味着

1376
00:52:39,690 --> 00:52:41,910
去的开销

1377
00:52:41,910 --> 00:52:43,530
从工作队列中抓取东西

1378
00:52:43,530 --> 00:52:46,470
相对于处理这些食物的实际成本来说并不是那么重要，

1379
00:52:46,470 --> 00:52:50,040
所以现在让我们

1380
00:52:50,040 --> 00:52:52,650
谈谈 Hannam 的另一种方法，

1381
00:52:52,650 --> 00:52:53,790
它有点进入他所说的

1382
00:52:53,790 --> 00:52:57,360
关于你想要如何组织队列的内容，

1383
00:52:57,360 --> 00:53:00,600
所以 Hana 是 我应该

1384
00:53:00,600 --> 00:53:02,070
很清楚这是来自

1385
00:53:02,070 --> 00:53:04,650
博士生在 sa P 工作时写的一篇研究论文，

1386
00:53:04,650 --> 00:53:07,710
所以在德国他们有

1387
00:53:07,710 --> 00:53:10,860
一个博士模型，学生

1388
00:53:10,860 --> 00:53:13,080
可以在他们的公司全职工作

1389
00:53:13,080 --> 00:53:14,280
仍然做研究 他们仍然写

1390
00:53:14,280 --> 00:53:16,560
论文 他们从那家公司获得报酬 你

1391
00:53:16,560 --> 00:53:18,660
喜欢固定薪水 就像我

1392
00:53:18,660 --> 00:53:21,000
不像博士津贴 但然后他们

1393
00:53:21,000 --> 00:53:23,670
从一个机构获得学位，

1394
00:53:23,670 --> 00:53:24,960
据你所知 我在这里描述的

1395
00:53:24,960 --> 00:53:26,640
从未真正进入真正的

1396
00:53:26,640 --> 00:53:28,800
Hana 系统，尽管学生在实现这一点时实际上是在

1397
00:53:28,800 --> 00:53:30,810
实际处理真正的

1398
00:53:30,810 --> 00:53:32,580
Hana 源代码，

1399
00:53:32,580 --> 00:53:36,000
但这与 Hana 实际上是一种

1400
00:53:36,000 --> 00:53:38,100
不同的调度方法

1401
00:53:38,100 --> 00:53:43,620
这样做

1402
00:53:43,620 --> 00:53:45,270
他的陈述是不是意味着

1403
00:53:45,270 --> 00:53:46,560
他们在这里描述的任何内容都没有奏效，

1404
00:53:46,560 --> 00:53:47,700
因此他们不想把它

1405
00:53:47,700 --> 00:53:49,860
放在真正的 Hana 系统中，就像是的，

1406
00:53:49,860 --> 00:53:51,240
这是一个好主意，我们应该这样做，

1407
00:53:51,240 --> 00:53:52,530
然后就像工程

1408
00:53:52,530 --> 00:53:53,880
开销 把这个研究

1409
00:53:53,880 --> 00:53:56,160
代码放到真实的系统中，这就是

1410
00:53:56,160 --> 00:53:57,690
为什么这些东西

1411
00:53:57,690 --> 00:54:01,260
不能正确实现的原因，但这并不是

1412
00:54:01,260 --> 00:54:03,000
说它浪费了工作，就像

1413
00:54:03,000 --> 00:54:05,220
现在 ACP 决定建立一个新系统

1414
00:54:05,220 --> 00:54:06,630
，他们实际上最终重写了

1415
00:54:06,630 --> 00:54:08,640
很多 Hana 你知道他们现在

1416
00:54:08,640 --> 00:54:12,210
对你有所了解 你知道一些

1417
00:54:12,210 --> 00:54:13,560
不同的替代方式来组织

1418
00:54:13,560 --> 00:54:15,300
这是日程安排机制 所以他们

1419
00:54:15,300 --> 00:54:15,930
可以

1420
00:54:15,930 --> 00:54:17,820
这样做 你不知道自从去年发布的 2019 年

1421
00:54:17,820 --> 00:54:19,440
重写 Hana

1422
00:54:19,440 --> 00:54:21,090
我不知道他们是否这样做了我

1423
00:54:21,090 --> 00:54:24,019
怀疑不是，但我只是不

1424
00:54:24,019 --> 00:54:27,539
知道好不好所以他们要做的是

1425
00:54:27,539 --> 00:54:29,579
他们会这样做 一个基于池的提示，但

1426
00:54:29,579 --> 00:54:30,690
他们每个插槽将有多个工作人员

1427
00:54:30,690 --> 00:54:32,880
，因此

1428
00:54:32,880 --> 00:54:35,160
在 Hana 中，您有

1429
00:54:35,160 --> 00:54:37,079
一个核心工作人员，每个核心可能有

1430
00:54:37,079 --> 00:54:38,339
多个工作人员，并且有

1431
00:54:38,339 --> 00:54:41,119
不同的不同，他们会有

1432
00:54:41,119 --> 00:54:45,539
不同的事情。 状态，所以每个组

1433
00:54:45,539 --> 00:54:48,959
现在也将有一个软

1434
00:54:48,959 --> 00:54:51,359
优先级队列和一个硬优先级队列，这就是他

1435
00:54:51,359 --> 00:54:52,979
所说的，所以我不能有一个提示，我

1436
00:54:52,979 --> 00:54:54,509
知道这是我本地的，我先去检查

1437
00:54:54,509 --> 00:54:56,400
一下，如果没有，那么我

1438
00:54:56,400 --> 00:54:57,719
去检查另一个提示，它是全局提示，

1439
00:54:57,719 --> 00:55:00,420
就是这样，这样软键将是

1440
00:55:00,420 --> 00:55:03,509
我的组本地的，它将是

1441
00:55:03,509 --> 00:55:04,559
在同一个套接字上运行的一些工作人员，

1442
00:55:04,559 --> 00:55:08,190
对不起，收回它，这是

1443
00:55:08,190 --> 00:55:09,809
硬提示，硬提示对我的组来说是本地的，

1444
00:55:09,809 --> 00:55:11,940
并且 hard 意味着没有人可以

1445
00:55:11,940 --> 00:55:14,549
为我偷窃和 soft on  e 意味着

1446
00:55:14,549 --> 00:55:16,019
有人可以继续窃取

1447
00:55:16,019 --> 00:55:17,279
这个所以我仍然想执行这两个

1448
00:55:17,279 --> 00:55:19,859
任务 这只是说这个东西

1449
00:55:19,859 --> 00:55:21,749
必须在我的套接字或我的组中运行 没有人

1450
00:55:21,749 --> 00:55:23,069
可以接受它并且这些是

1451
00:55:23,069 --> 00:55:24,930
有资格被盗的东西 从

1452
00:55:24,930 --> 00:55:27,630
其他方面来看，现在他们将

1453
00:55:27,630 --> 00:55:30,719
拥有一个单独的看门狗线程，该线程将对每个套接字上每个组

1454
00:55:30,719 --> 00:55:32,339
发生的情况有一个全局视图

1455
00:55:32,339 --> 00:55:34,199


1456
00:55:34,199 --> 00:55:36,239
，然后他们可以决定

1457
00:55:36,239 --> 00:55:39,479
某个组是否被

1458
00:55:39,479 --> 00:55:41,699
超额订阅并拥有更多

1459
00:55:41,699 --> 00:55:43,859
他们可以实际处理的任务，然后它

1460
00:55:43,859 --> 00:55:46,979
可以从一个组中取出线程，

1461
00:55:46,979 --> 00:55:49,140
然后分配额外的线程或

1462
00:55:49,140 --> 00:55:50,670
允许额外的线程在

1463
00:55:50,670 --> 00:55:53,849
另一组中运行，所以这真的是你

1464
00:55:53,849 --> 00:55:56,219
正在生育减少平衡你

1465
00:55:56,219 --> 00:55:57,479
正在窃取工作 你

1466
00:55:57,479 --> 00:55:59,459
有超级，但你也有

1467
00:55:59,459 --> 00:56:01,650
能力增加你想要执行任务的线程数量，

1468
00:56:01,650 --> 00:56:03,779


1469
00:56:03,779 --> 00:56:05,459
所以你有点明白你正在使用

1470
00:56:05,459 --> 00:56:08,549
这两种方法，所以我说我们有一个

1471
00:56:08,549 --> 00:56:11,099
软 t 队列和硬队列，因此

1472
00:56:11,099 --> 00:56:12,329
fred 可以从其他

1473
00:56:12,329 --> 00:56:15,390
软线索中窃取任务，然后知道如何做到

1474
00:56:15,390 --> 00:56:17,329
这一点，然后

1475
00:56:17,329 --> 00:56:19,349
对于组内的不同池将有四个

1476
00:56:19,349 --> 00:56:20,519
不同的池，这些池将跟踪

1477
00:56:20,519 --> 00:56:23,249
什么类型的线程 我们已经运行，所以

1478
00:56:23,249 --> 00:56:24,599
工作线程是当我们有

1479
00:56:24,599 --> 00:56:26,160
一个实际上正在运行它

1480
00:56:26,160 --> 00:56:27,930
从某个队列中提取的任务时，它

1481
00:56:27,930 --> 00:56:29,459
来自哪个队列并不重要，因为我们

1482
00:56:29,459 --> 00:56:31,469
知道它正在处理我们有

1483
00:56:31,469 --> 00:56:33,180
一个不活动的线程，我们知道我们被

1484
00:56:33,180 --> 00:56:35,160
阻塞了 在内核中给你一些

1485
00:56:35,160 --> 00:56:37,140
闩锁，

1486
00:56:37,140 --> 00:56:39,390
稍后它会被唤醒

1487
00:56:39,390 --> 00:56:42,930
一个空闲线程是一个它会

1488
00:56:42,930 --> 00:56:45,539
休眠一点的线程唤醒检查它的队列

1489
00:56:45,539 --> 00:56:47,190
，看看是否有任何要

1490
00:56:47,190 --> 00:56:48,630
在软件中执行的其他或硬

1491
00:56:48,630 --> 00:56:51,210
队列 如果是，则它是本地的，如果是，则

1492
00:56:51,210 --> 00:56:52,349
继续执行它，现在成为一个

1493
00:56:52,349 --> 00:56:54,059
工作线程，如果不是，则它

1494
00:56:54,059 --> 00:56:56,700
返回休眠状态，然后我们有部分线程

1495
00:56:56,700 --> 00:57:00,599
，线程在其中休眠，

1496
00:57:00,599 --> 00:57:02,039
直到洗狗时它才会被唤醒

1497
00:57:02,039 --> 00:57:03,569
线程com  es 出现说，嘿，我们

1498
00:57:03,569 --> 00:57:05,460
需要你，你知道醒来并实际

1499
00:57:05,460 --> 00:57:08,640
开始做事，所以这

1500
00:57:08,640 --> 00:57:10,799
又不允许我们做的是我们现在可以

1501
00:57:10,799 --> 00:57:14,190
扩大我们

1502
00:57:14,190 --> 00:57:16,140
在公园线程队列案例中拥有的线程数量，因为就像

1503
00:57:16,140 --> 00:57:18,089
或池案例，因为如果我认识到我的

1504
00:57:18,089 --> 00:57:20,309
组不能我的所有线程都在工作，

1505
00:57:20,309 --> 00:57:21,990
或者它们处于非活动状态，则没有空闲

1506
00:57:21,990 --> 00:57:23,099
线程，因为

1507
00:57:23,099 --> 00:57:24,900
如果我没有足够的

1508
00:57:24,900 --> 00:57:26,579
资源来处理工作，它们就是全部它们都在处理工作 我需要

1509
00:57:26,579 --> 00:57:28,890
为我的小组拥有我现在可以释放

1510
00:57:28,890 --> 00:57:30,569
这些 Park 线程或取消它们并

1511
00:57:30,569 --> 00:57:32,160
让他们也开始处理

1512
00:57:32,160 --> 00:57:34,349
事情然后也许在另一个组中

1513
00:57:34,349 --> 00:57:39,000
我会停放他们的线程所以有

1514
00:57:39,000 --> 00:57:40,740
很多工作对这听起来

1515
00:57:40,740 --> 00:57:42,420
像 操作系统，因为它有点

1516
00:57:42,420 --> 00:57:44,009
是，我们将从

1517
00:57:44,009 --> 00:57:45,509
续集服务器和更多幻灯片中看到这一点，但

1518
00:57:45,509 --> 00:57:46,950
他们实际上确实构建了一个

1519
00:57:46,950 --> 00:57:48,269
在数据库系统内部运行的操作系统，

1520
00:57:48,269 --> 00:57:50,069
他们甚至称之为它，

1521
00:57:50,069 --> 00:57:52,440
所以他们会

1522
00:57:52,440 --> 00:57:54,119
他们又要走了 na

1523
00:57:54,119 --> 00:57:56,549


1524
00:57:56,549 --> 00:57:58,400
根据

1525
00:57:58,400 --> 00:58:00,900
任务是受 CPU 限制还是受内存

1526
00:58:00,900 --> 00:58:06,269
限制，从线程实际运行的线程的固定中调整线程

1527
00:58:06,269 --> 00:58:08,970


1528
00:58:08,970 --> 00:58:10,559
的任务，我

1529
00:58:10,559 --> 00:58:11,519
不能以足够快的速度处理

1530
00:58:11,519 --> 00:58:16,319
我可以允许线程很好

1531
00:58:16,319 --> 00:58:18,779
如果我必须没有足够的工作

1532
00:58:18,779 --> 00:58:20,460
我不能分开它们如果我可以解开 bam 如果我有两个

1533
00:58:20,460 --> 00:58:22,380
超过实际需要我必须做

1534
00:58:22,380 --> 00:58:23,549
对于其他套接字，因为我

1535
00:58:23,549 --> 00:58:24,920
不想使整个系统的内存带宽饱和，

1536
00:58:24,920 --> 00:58:26,910
因为也许

1537
00:58:26,910 --> 00:58:28,680
这些任务正在通过互连提取数据，

1538
00:58:28,680 --> 00:58:31,109
有趣

1539
00:58:31,109 --> 00:58:34,349
的是，他们发现当

1540
00:58:34,349 --> 00:58:36,720
他们查看真正大型的套接字

1541
00:58:36,720 --> 00:58:38,910
机器时 khana 可以运行他们

1542
00:58:38,910 --> 00:58:40,470
发现长期窃取工作的超级方法

1543
00:58:40,470 --> 00:58:41,970
实际上是一个坏

1544
00:58:41,970 --> 00:58:44,279
主意所以在他们正在看的超级论文中

1545
00:58:44,279 --> 00:58:45,690
我认为在两到四个插槽的

1546
00:58:45,690 --> 00:58:47,970
机器上，Hana 人正在寻找

1547
00:58:47,970 --> 00:58:49,829
像 64 个插槽的 r128 插槽

1548
00:58:49,829 --> 00:58:50,460
机器

1549
00:58:50,460 --> 00:58:52,470
所以在那个环境中你想要

1550
00:58:52,470 --> 00:58:56,099
做的是你没有任何软提示你

1551
00:58:56,099 --> 00:58:59,190
把所有东西都放在硬队列中，然后你

1552
00:58:59,190 --> 00:59:00,780
可以扩展

1553
00:59:00,780 --> 00:59:03,720
你

1554
00:59:03,720 --> 00:59:05,700
在每个套接字上每个组上的每个单个上运行的线程数 但是

1555
00:59:05,700 --> 00:59:08,490
你不允许线程

1556
00:59:08,490 --> 00:59:10,109
从另一个套接字接受工作并通过

1557
00:59:10,109 --> 00:59:11,880
互连每个人总是

1558
00:59:11,880 --> 00:59:19,260
在本地正确处理事情是的

1559
00:59:19,260 --> 00:59:20,250
，Softee 在心脏中的任务就像

1560
00:59:20,250 --> 00:59:26,790
一个例子所以问题

1561
00:59:26,790 --> 00:59:28,380
是怎么做 我知道

1562
00:59:28,380 --> 00:59:34,230
在硬幽默中放什么 软屁股可能

1563
00:59:34,230 --> 00:59:36,510
就像我们将在下一张幻灯片中看到的那样 所以在

1564
00:59:36,510 --> 00:59:40,140
这个例子中，他们有

1565
00:59:40,140 --> 00:59:42,270
整个系统架构在这些漩涡上运行，

1566
00:59:42,270 --> 00:59:44,579
所以这

1567
00:59:44,579 --> 00:59:46,020
意味着永远不会运行请求

1568
00:59:46,020 --> 00:59:49,829
在漩涡上，所以如果我有一个任务，如果我有一个

1569
00:59:49,829 --> 00:59:51,270
任务说你知道

1570
00:59:51,270 --> 00:59:53,520
从这个套接字读取下一个数据包

1571
00:59:53,520 --> 00:59:56,369
我想运行你知道

1572
00:59:56,369 --> 00:59:58,740
在线程或

1573
00:59:58,740 --> 01:00:00,599
套接字位于网络上的 CPU 套接字 发誓

1574
01:00:00,599 --> 01:00:02,670
从来没有找到袜子，我不希望

1575
01:00:02,670 --> 01:00:05,750
其他人从我这里拿走它

1576
01:00:05,750 --> 01:00:08,339
是的，我的意思是这是下一张幻灯片，所以

1577
01:00:08,339 --> 01:00:10,920
再次像线程组正在

1578
01:00:10,920 --> 01:00:12,299
运行所有内容一样，所以在超级情况

1579
01:00:12,299 --> 01:00:15,660
下，池只

1580
01:00:15,660 --> 01:00:17,940
处理查询 他们把

1581
01:00:17,940 --> 01:00:19,559
所有东西都放在系统里，所以现在你可以

1582
01:00:19,559 --> 01:00:23,819
做一些事情，比如如果我有

1583
01:00:23,819 --> 01:00:26,790
我正在执行的查询数量过度订阅

1584
01:00:26,790 --> 01:00:28,859
而不是接受新的

1585
01:00:28,859 --> 01:00:30,900
从不请求我

1586
01:00:30,900 --> 01:00:32,819
将从他们的池中获取一些网络线程 并

1587
01:00:32,819 --> 01:00:34,530
在我的执行池中启动新线程或取消停放线程

1588
01:00:34,530 --> 01:00:37,109
，这样就

1589
01:00:37,109 --> 01:00:39,510
可以获得自然的流程控制，而

1590
01:00:39,510 --> 01:00:40,470
不是你知道执行比实际执行更多的查询，

1591
01:00:40,470 --> 01:00:43,380
所以这里是我们

1592
01:00:43,380 --> 01:00:46,230
之前有过的相同查询，所以把这些任务保存

1593
01:00:46,230 --> 01:00:48,210
在这里我们 可以放入软队列，

1594
01:00:48,210 --> 01:00:49,890
然后无论出于何种原因，我们将这些

1595
01:00:49,890 --> 01:00:52,500
其他任务放入硬队列中以达到

1596
01:00:52,500 --> 01:00:54,030
我的目的，这实际上并不

1597
01:00:54,030 --> 01:00:55,589
重要并显示此注册

1598
01:00:55,589 --> 01:00:58,859
目的，因此现在所有工作人员再次

1599
01:00:58,859 --> 01:01:01,319
排队 worker 工作线程

1600
01:01:01,319 --> 01:01:03,510
被非活动线程从软队列中拉出来，

1601
01:01:03,510 --> 01:01:04,110


1602
01:01:04,110 --> 01:01:06,210
只是在等待操作系统中的某些东西，

1603
01:01:06,210 --> 01:01:08,850
空闲线程只是

1604
01:01:08,850 --> 01:01:10,440
在软 Q 或 Q 的核心上旋转，寻找

1605
01:01:10,440 --> 01:01:11,940
工作要做，而公园线程只是

1606
01:01:11,940 --> 01:01:14,520
被 看门狗线程所以我

1607
01:01:14,520 --> 01:01:16,200
不能在这里说我认识到我

1608
01:01:16,200 --> 01:01:19,620
无法满足我的要求所以说现在

1609
01:01:19,620 --> 01:01:21,180
我的空闲线程从心脏中提取了一些东西

1610
01:01:21,180 --> 01:01:23,220
Q 然后它现在被迁移

1611
01:01:23,220 --> 01:01:24,750
，现在它被认为是一个工作

1612
01:01:24,750 --> 01:01:27,330
线程 以及上面的看门狗线程

1613
01:01:27,330 --> 01:01:28,650
，所有这些都知道有多少

1614
01:01:28,650 --> 01:01:30,360
线程实际在每个组上运行，

1615
01:01:30,360 --> 01:01:32,190
并且可以

1616
01:01:32,190 --> 01:01:33,600
就我们的资源分配

1617
01:01:33,600 --> 01:01:38,360
决策做出调度决策，上面

1618
01:01:38,360 --> 01:01:40,530
是像保留线程

1619
01:01:40,530 --> 01:01:42,900
这样的部分，而不是调用 spawn 我刚刚

1620
01:01:42,900 --> 01:01:47,720
没有' 是的，所以他们是我

1621
01:01:47,720 --> 01:01:49,620
实际上不知道

1622
01:01:49,620 --> 01:01:50,940
我认为在实际线程中真正的区别是什么

1623
01:01:50,940 --> 01:01:52,650
就像我被阻塞等待

1624
01:01:52,650 --> 01:01:53,970
到达闩锁或互斥锁

1625
01:01:53,970 --> 01:01:55,440
和操作系统但如果我回来然后我

1626
01:01:55,440 --> 01:01:58,050
会 我开始工作这就像我

1627
01:01:58,050 --> 01:02:00,510
认为你停在操作系统中你

1628
01:02:00,510 --> 01:02:02,580
在一些互斥锁上阻止了我 West

1629
01:02:02,580 --> 01:02:03,960
就像它是条件变量

1630
01:02:03,960 --> 01:02:05,010
一样，就像其他一些威胁一样必须出现并

1631
01:02:05,010 --> 01:02:06,390
说现在你被允许醒来并且

1632
01:02:06,390 --> 01:02:08,610
这个想法是我可以动态地让

1633
01:02:08,610 --> 01:02:09,840
这些家伙被释放和执行

1634
01:02:09,840 --> 01:02:11,370
而不必调用调用 spawn

1635
01:02:11,370 --> 01:02:13,800
因为那是一个联系人切换或一个 sis

1636
01:02:13,800 --> 01:02:19,500
调用并且上下文切换没问题所以

1637
01:02:19,500 --> 01:02:21,270
我要谈论的最后一个调度事情

1638
01:02:21,270 --> 01:02:22,980
是我认为是

1639
01:02:22,980 --> 01:02:25,140
所有这些中最令人着迷的

1640
01:02:25,140 --> 01:02:28,020
不是内存系统，而是

1641
01:02:28,020 --> 01:02:29,880
它与我们迄今为止讨论的其他所有东西都如此不同，

1642
01:02:29,880 --> 01:02:30,900


1643
01:02:30,900 --> 01:02:32,850
但我认为我认为这很神奇，

1644
01:02:32,850 --> 01:02:35,700
所以在 2005 年他们

1645
01:02:35,700 --> 01:02:37,680
发布的续集服务器中 他们现在发布的新版本的续集

1646
01:02:37,680 --> 01:02:40,680
服务器捆绑

1647
01:02:40,680 --> 01:02:43,050
在过时的系统中，这基本上是一个

1648
01:02:43,050 --> 01:02:45,060
称为续集操作系统的用户模式

1649
01:02:45,060 --> 01:02:48,330
操作系统，其想法是这是

1650
01:02:48,330 --> 01:02:50,280
一个位于带有 Windows ke 的真实操作系统之上的层

1651
01:02:50,280 --> 01:02:52,920
rnel 和

1652
01:02:52,920 --> 01:02:54,540
实际

1653
01:02:54,540 --> 01:02:57,510
管理和提供硬件

1654
01:02:57,510 --> 01:03:00,090
资源的数据库系统引擎本身，其最初的

1655
01:03:00,090 --> 01:03:03,750
动机是，而不是你所

1656
01:03:03,750 --> 01:03:05,430
知道的新月变得更加

1657
01:03:05,430 --> 01:03:07,380
普遍，因为硬件发生了变化，

1658
01:03:07,380 --> 01:03:09,090
而不是拥有所有不同的

1659
01:03:09,090 --> 01:03:11,340
实现或

1660
01:03:11,340 --> 01:03:13,410
数据库系统执行引擎中的不同操作符，

1661
01:03:13,410 --> 01:03:15,390
而不是必须

1662
01:03:15,390 --> 01:03:17,790
都知道 Numa

1663
01:03:17,790 --> 01:03:19,440
和内存查看内存布局之类的

1664
01:03:19,440 --> 01:03:21,540
东西，他们将

1665
01:03:21,540 --> 01:03:23,490
通过续集 West 层抽象所有这些，

1666
01:03:23,490 --> 01:03:25,590
并让它

1667
01:03:25,590 --> 01:03:28,110
做出关于你知道在哪里的决定

1668
01:03:28,110 --> 01:03:29,760
实际运行任务以及如何实际

1669
01:03:29,760 --> 01:03:33,960
并行运行事情，这

1670
01:03:33,960 --> 01:03:35,520
真是太神奇了，因为它不仅仅是像

1671
01:03:35,520 --> 01:03:36,960
调度线程一样，他们还做一堆

1672
01:03:36,960 --> 01:03:39,390
其他的事情，比如 IO 调度，他们

1673
01:03:39,390 --> 01:03:40,770
实际上管理

1674
01:03:40,770 --> 01:03:44,250
内部的缓冲池，因为他们做锁

1675
01:03:44,250 --> 01:03:46,830
调度和 再次解锁内部管理

1676
01:03:46,830 --> 01:03:48,870
，这里的想法是，

1677
01:03:48,870 --> 01:03:52,650
而不是我们必须拥有

1678
01:03:52,650 --> 01:03:54,870
这些 专门的 Lodge 的 hoc 邀请

1679
01:03:54,870 --> 01:03:56,430
来处理像哦这个线程准备

1680
01:03:56,430 --> 01:03:58,020
好这个锁，因此我的

1681
01:03:58,020 --> 01:03:59,460
加入 Alvin 可能会以这种方式运行，或者

1682
01:03:59,460 --> 01:04:01,680
像续集 West 层中处理的所有事情一样

1683
01:04:01,680 --> 01:04:03,360
，你只需

1684
01:04:03,360 --> 01:04:05,220
在上面实现你的基本操作符

1685
01:04:05,220 --> 01:04:07,110


1686
01:04:07,110 --> 01:04:08,730
当你想到如果你参加

1687
01:04:08,730 --> 01:04:09,900
了我们谈到的介绍课程时，这件事会再次为你处理所有这些，我们谈到了

1688
01:04:09,900 --> 01:04:12,000
disscourn和数据库系统，我们

1689
01:04:12,000 --> 01:04:13,500
谈到了缓冲池管理器，

1690
01:04:13,500 --> 01:04:14,970
角色管理器基本上复制

1691
01:04:14,970 --> 01:04:16,500
了操作系统所做的相同逻辑

1692
01:04:16,500 --> 01:04:18,540
虚拟内存分配一些页面或

1693
01:04:18,540 --> 01:04:20,820
III 可以分配

1694
01:04:20,820 --> 01:04:22,590
比我实际可用的内存更多的内存，我知道如何

1695
01:04:22,590 --> 01:04:24,600
在磁盘上交换东西，所以

1696
01:04:24,600 --> 01:04:26,370
微软基本上全力以赴，所以让我们

1697
01:04:26,370 --> 01:04:28,650
做操作系统正在做的一切并将其

1698
01:04:28,650 --> 01:04:30,180
放入我们的数据库系统中

1699
01:04:30,180 --> 01:04:33,180
这真是太神奇了，但是对于本次

1700
01:04:33,180 --> 01:04:35,160
讲座，我们谈论的是

1701
01:04:35,160 --> 01:04:37,260
他们正在为线程调度做些什么，他们将

1702
01:04:37,260 --> 01:04:38,430


1703
01:04:38,430 --> 01:04:42,330
通过修改线程来进行非抢占式线程调度 数据库

1704
01:04:42,330 --> 01:04:45,030
系统代码本身能够

1705
01:04:45,030 --> 01:04:48,480
让步给调度程序，所以在

1706
01:04:48,480 --> 01:04:50,040
我们开始之前，我还说

1707
01:04:50,040 --> 01:04:52,080
这个续集操作系统层是

1708
01:04:52,080 --> 01:04:53,940
微软能够将

1709
01:04:53,940 --> 01:04:56,760
续集服务器移植到 Linux 的部分原因，所以

1710
01:04:56,760 --> 01:05:00,570
有一个公告是在 2017 年，

1711
01:05:00,570 --> 01:05:02,400
这篇 TechCrunch 文章他们

1712
01:05:02,400 --> 01:05:04,410
谈到了他们何时不得不采用 C Co OS

1713
01:05:04,410 --> 01:05:07,500
而不是与 win32 交谈，他们现在

1714
01:05:07,500 --> 01:05:09,570
与 Linux 内核交谈，这

1715
01:05:09,570 --> 01:05:11,280
对他们来说不是一个重大变化，我的意思是

1716
01:05:11,280 --> 01:05:12,840
不是 不是微不足道的，但并不是

1717
01:05:12,840 --> 01:05:14,430
我们需要更改

1718
01:05:14,430 --> 01:05:16,050
数据库系统的所有其他方面，因为所有这些

1719
01:05:16,050 --> 01:05:17,660


1720
01:05:17,660 --> 01:05:20,730
对操作系统资源和硬件

1721
01:05:20,730 --> 01:05:22,560
资源的低级管理都是由这些操作系统层完成的，

1722
01:05:22,560 --> 01:05:24,300
因此您只需更改续集的最后一部分

1723
01:05:24,300 --> 01:05:26,700
即可进行讨论 到 Linux 并且不接触

1724
01:05:26,700 --> 01:05:27,420
任何其他东西，

1725
01:05:27,420 --> 01:05:29,730
因此相同的代码库用于执行其他

1726
01:05:29,730 --> 01:05:31,109
联合算法，执行所有 X

1727
01:05:31,109 --> 01:05:33,839
shishun 流控制或控制或

1728
01:05:33,839 --> 01:05:36,239
所有位于 C 之上的索引 go s，

1729
01:05:36,239 --> 01:05:38,789
然后必须修改任何

1730
01:05:38,789 --> 01:05:41,309
返回到我的 e 在 db2 之前的 db2 示例

1731
01:05:41,309 --> 01:05:42,569
没有那个抽象层，所以

1732
01:05:42,569 --> 01:05:43,470
这就是为什么他们有四种不同的

1733
01:05:43,470 --> 01:05:45,450
不同代码库，他们已经

1734
01:05:45,450 --> 01:05:47,009
尝试过我想尝试拥有一个

1735
01:05:47,009 --> 01:05:48,749
统一的代码库，但你永远不知道

1736
01:05:48,749 --> 01:05:50,789
它从来没有发生过它永远不会

1737
01:05:50,789 --> 01:05:52,039
发生

1738
01:05:52,039 --> 01:05:53,819
微软是 能够通过续集操作系统做到这一点，

1739
01:05:53,819 --> 01:05:55,259
所以我认为这真的很

1740
01:05:55,259 --> 01:06:00,170
有趣，所以

1741
01:06:00,170 --> 01:06:02,009
在他们的世界中先发制人的线程刮擦是什么样的，

1742
01:06:02,009 --> 01:06:02,309


1743
01:06:02,309 --> 01:06:06,359
所以在 CIO 中，

1744
01:06:06,359 --> 01:06:07,799
每个线程的量子将是

1745
01:06:07,799 --> 01:06:10,920
毫秒，我知道量子是什么

1746
01:06:10,920 --> 01:06:15,809
大小在默认 Linux 中这些问题

1747
01:06:15,809 --> 01:06:19,619
量子量子是什么样的，所以

1748
01:06:19,619 --> 01:06:21,930
你没有，所以你有一个线程，它被

1749
01:06:21,930 --> 01:06:23,730
安排在操作系统上 安排它

1750
01:06:23,730 --> 01:06:26,579
执行 它会运行

1751
01:06:26,579 --> 01:06:27,749
一段时间，称为量子，

1752
01:06:27,749 --> 01:06:28,980
然后它是某个点 当量程

1753
01:06:28,980 --> 01:06:29,940
上升时有中断，

1754
01:06:29,940 --> 01:06:31,890
他们将您的线程带走并处理它

1755
01:06:31,890 --> 01:06:33,269
，我有一个上下文或另一个线程

1756
01:06:33,269 --> 01:06:36,269
正确的时间片将是另一个术语，

1757
01:06:36,269 --> 01:06:40,440
所以您已经采取的运费

1758
01:06:40,440 --> 01:06:43,200
操作系统或操作系统类是什么 什么

1759
01:06:43,200 --> 01:06:48,329
是量子大小和 Linux 没人知道

1760
01:06:48,329 --> 01:06:49,710
去模糊的答案 因为它

1761
01:06:49,710 --> 01:06:51,690
实际上是动态的 它可以

1762
01:06:51,690 --> 01:06:53,609
变化 我你知道这取决于时钟

1763
01:06:53,609 --> 01:06:55,049
速度 取决于其他正在运行的东西

1764
01:06:55,049 --> 01:06:57,180
如果它知道的话 没有其他

1765
01:06:57,180 --> 01:06:59,069
线程正在运行，你知道

1766
01:06:59,069 --> 01:07:01,259
从 CPU 中获取需求，然后它可以

1767
01:07:01,259 --> 01:07:02,789
让你的量子稍微大一点，

1768
01:07:02,789 --> 01:07:04,890
以避免上下文切换到

1769
01:07:04,890 --> 01:07:06,119
其他一些不需要的任务，

1770
01:07:06,119 --> 01:07:09,180
如果你切换到

1771
01:07:09,180 --> 01:07:11,819
Linux 的实时模式 然后量子被固定

1772
01:07:11,819 --> 01:07:14,160
为我认为一百毫秒现在

1773
01:07:14,160 --> 01:07:15,690
的想法是再次上下文

1774
01:07:15,690 --> 01:07:16,739
切换并不便宜，因为

1775
01:07:16,739 --> 01:07:18,450
您将所有寄存器

1776
01:07:18,450 --> 01:07:22,170
放入GPU缓存中更改

1777
01:07:22,170 --> 01:07:23,309
程序计数器就像所有这些都不

1778
01:07:23,309 --> 01:07:25,680
便宜 所以在实时中，

1779
01:07:25,680 --> 01:07:27,089
他们最终让你的量子更长的

1780
01:07:27,089 --> 01:07:30,690
时间，所以在 cos 中，量子时间

1781
01:07:30,690 --> 01:07:32,460
将是四毫秒，但他们

1782
01:07:32,460 --> 01:07:34,230
无法强制执行，因为这是

1783
01:07:34,230 --> 01:07:36,049
所有在用户模式下的用户级别完成

1784
01:07:36,049 --> 01:07:40,019
意味着我们将任务交给

1785
01:07:40,019 --> 01:07:44,039
它运行的线程在我们内部没有办法因为我们

1786
01:07:44,039 --> 01:07:44,790


1787
01:07:44,790 --> 01:07:46,260
是同一个进程而且我们不是操作系统

1788
01:07:46,260 --> 01:07:47,850
我们无法说线程

1789
01:07:47,850 --> 01:07:49,740
你 完成后让我们重新

1790
01:07:49,740 --> 01:07:52,530
控制核心，你不能这样做，

1791
01:07:52,530 --> 01:07:53,910
因为这就是操作系统所做的，因为

1792
01:07:53,910 --> 01:07:56,100
他们可以通过硬件来完成，所以

1793
01:07:56,100 --> 01:07:58,470
他们现在要做的是修改他们

1794
01:07:58,470 --> 01:08:01,350
修改了源代码 续集

1795
01:08:01,350 --> 01:08:03,930
服务器本身引入让步调用

1796
01:08:03,930 --> 01:08:07,680
导致线程返回，并且您

1797
01:08:07,680 --> 01:08:08,790
知道将控制权返回给

1798
01:08:08,790 --> 01:08:11,010
计划所以假设这是一个简单的

1799
01:08:11,010 --> 01:08:12,420
查询，从一个值等于某个参数的位置选择星，

1800
01:08:12,420 --> 01:08:16,319
所以一个非常

1801
01:08:16,319 --> 01:08:18,060
简单的实现 这将是一个

1802
01:08:18,060 --> 01:08:20,100
for 循环，我们得到一堆元组来

1803
01:08:20,100 --> 01:08:21,720
评估一个谓词，然后如果它们

1804
01:08:21,720 --> 01:08:23,100
匹配我们的谓词，我们就承认它，

1805
01:08:23,100 --> 01:08:25,890
所以基本上微软必须

1806
01:08:25,890 --> 01:08:28,140
做的是返回并修改源

1807
01:08:28,140 --> 01:08:30,299
代码以跟踪时间量

1808
01:08:30,299 --> 01:08:33,210
他们花在每个不同的地方 进入部分

1809
01:08:33,210 --> 01:08:35,700
并认识到如果

1810
01:08:35,700 --> 01:08:37,140
我最后一次调用

1811
01:08:37,140 --> 01:08:39,870
yield给调度程序的时间是男孩你知道

1812
01:08:39,870 --> 01:08:42,270
超过四毫秒那么我

1813
01:08:42,270 --> 01:08:44,399
继续并且yield back现在将控制权交

1814
01:08:44,399 --> 01:08:46,410
还给调度程序人员你可以

1815
01:08:46,410 --> 01:08:47,880
决定是否 再次运行你的任务，

1816
01:08:47,880 --> 01:08:49,290
或者他们是否将它交给另一个

1817
01:08:49,290 --> 01:08:53,399
任务，这太神奇了，这就像

1818
01:08:53,399 --> 01:08:55,410
伪代码，他们显然没有打电话给

1819
01:08:55,410 --> 01:08:57,240
你知道

1820
01:08:57,240 --> 01:08:58,229
，对于每一个愚蠢的元组，永远不会再次获得当前

1821
01:08:58,229 --> 01:08:58,770


1822
01:08:58,770 --> 01:09:02,279
时间戳我认为他们的方式 是不是他们

1823
01:09:02,279 --> 01:09:04,830
有点知道代码本身

1824
01:09:04,830 --> 01:09:07,799
就像我在做一个 for 循环一样，你知道

1825
01:09:07,799 --> 01:09:09,359
他们知道去和

1826
01:09:09,359 --> 01:09:10,950
检索元组的成本，以及它是在

1827
01:09:10,950 --> 01:09:12,750
磁盘中还是在内存中，值得花

1828
01:09:12,750 --> 01:09:14,970
时间和 然后他们可以使用一些

1829
01:09:14,970 --> 01:09:16,979
内置计算来非常

1830
01:09:16,979 --> 01:09:19,620
便宜地确定我的表格是否增加了四毫秒

1831
01:09:19,620 --> 01:09:27,240
所以他的问题是我如何

1832
01:09:27,240 --> 01:09:28,770
控制操作系统将安排的下一个线程

1833
01:09:28,770 --> 01:09:35,069
你不能阻止

1834
01:09:35,069 --> 01:09:39,060
产量或序列 el 或 yield 太晕了 这

1835
01:09:39,060 --> 01:09:40,859
不是对抗模式 这是

1836
01:09:40,859 --> 01:09:44,270
Seco OS 你

1837
01:09:50,660 --> 01:09:52,830
他们可以控制正在运行的秘密夏季任务

1838
01:09:52,830 --> 01:09:57,000
是的，因为

1839
01:09:57,000 --> 01:09:58,710
一堆横幅这样做所以一个是你的

1840
01:09:58,710 --> 01:10:01,680
右眼就像我无法阻止 操作系统

1841
01:10:01,680 --> 01:10:04,590
从交换调度程序正确所以

1842
01:10:04,590 --> 01:10:06,900
我们设置任何数据库系统的最佳实践是

1843
01:10:06,900 --> 01:10:08,760


1844
01:10:08,760 --> 01:10:11,340
在机器上运行数据系统本身，所以你

1845
01:10:11,340 --> 01:10:13,230
知道你不是在进行比特币挖掘，或者

1846
01:10:13,230 --> 01:10:15,720
你知道编码视频或观看

1847
01:10:15,720 --> 01:10:16,860
YouTube 同时您正在尝试

1848
01:10:16,860 --> 01:10:19,310
正确运行事务，因此

1849
01:10:19,310 --> 01:10:21,960
CPU 的争用将降低，并且

1850
01:10:21,960 --> 01:10:24,050


1851
01:10:24,050 --> 01:10:26,970
如果我

1852
01:10:26,970 --> 01:10:28,530
知道线程正在尝试访问

1853
01:10:28,530 --> 01:10:30,600
您知道尝试执行的协作调度或 Linux 中的公平调度方法 东西我会

1854
01:10:30,600 --> 01:10:31,950
马上回到 Mike 线程所以

1855
01:10:31,950 --> 01:10:34,980
是的我可能在这中间

1856
01:10:34,980 --> 01:10:37,940
操作系统可能会换掉我

1857
01:10:38,420 --> 01:10:41,190
正确所以这个量子

1858
01:10:41,190 --> 01:10:47,510
时间是一个用户模式概念是什么

1859
01:10:48,920 --> 01:10:51,320
是的是的

1860
01:10:51,320 --> 01:10:53,220
另一个有趣的优势你会得到

1861
01:10:53,220 --> 01:10:55,530
来回 就像现在一样，我可以在同一个数据库上相同资金的不同租户之间进行

1862
01:10:55,530 --> 01:10:57,390
某种公平的调度和

1863
01:10:57,390 --> 01:11:01,080
配置，

1864
01:11:01,080 --> 01:11:03,150
因此我

1865
01:11:03,150 --> 01:11:04,320
有两个客户运行我的同一个

1866
01:11:04,320 --> 01:11:06,180
续集服务器实例，一个是我

1867
01:11:06,180 --> 01:11:07,350
可以将它们分开运行 在不同的

1868
01:11:07,350 --> 01:11:10,470
套接字上，但我现在也可以只使用

1869
01:11:10,470 --> 01:11:12,180
这些 Quantum 来强制它们

1870
01:11:12,180 --> 01:11:15,600
都可以相等的时间，或者如果我现在

1871
01:11:15,600 --> 01:11:17,100
有预算

1872
01:11:17,100 --> 01:11:18,150
从一个租户与另一个租户获得多少 Quantum

1873
01:11:18,150 --> 01:11:20,190
量子时间仍然会是

1874
01:11:20,190 --> 01:11:21,810
4 毫秒，但是 也许我

1875
01:11:21,810 --> 01:11:23,580
给另一个人更多的 Quantum 是因为

1876
01:11:23,580 --> 01:11:25,530
他们给了我比第一个租户更多的钱

1877
01:11:25,530 --> 01:11:27,660
所以这让你可以

1878
01:11:27,660 --> 01:11:29,040
搜索各种

1879
01:11:29,040 --> 01:11:31,140
用超级方法

1880
01:11:31,140 --> 01:11:34,800
或 Haan 方法无法轻松完成的令人惊奇的事情，因为

1881
01:11:34,800 --> 01:11:36,930
他们不知道实际

1882
01:11:36,930 --> 01:11:40,340
任务实际上想要做什么，所以

1883
01:11:40,340 --> 01:11:44,220
我不知道据你所知，

1884
01:11:44,220 --> 01:11:47,580
没有其他人用这个续集 West 层做到这一点，

1885
01:11:47,580 --> 01:11:49,410
这是我

1886
01:11:49,410 --> 01:11:50,550
想在 ou 中做的事情 r 系统，因为我认为它会

1887
01:11:50,550 --> 01:11:52,640
有益于自动驾驶的东西

1888
01:11:52,640 --> 01:11:55,110
，我知道的唯一其他

1889
01:11:55,110 --> 01:11:56,910
类似的系统是动物群数据库，

1890
01:11:56,910 --> 01:11:59,310
所以他们没有做同样的事情，

1891
01:11:59,310 --> 01:12:02,040
比如固定的量子大小，或者不是再次

1892
01:12:02,040 --> 01:12:02,970
它不是固定

1893
01:12:02,970 --> 01:12:04,890
的 让它始终保持几毫秒

1894
01:12:04,890 --> 01:12:07,050
，但是 Hana 这样做的方式是，

1895
01:12:07,050 --> 01:12:10,470
它们只

1896
01:12:10,470 --> 01:12:14,280
在你这样做时才回馈给数据库调度程序，所以在

1897
01:12:14,280 --> 01:12:16,320
cos 中，我可以在内存中完成所有这些操作，并且

1898
01:12:16,320 --> 01:12:18,120
我仍然会在我之后回馈

1899
01:12:18,120 --> 01:12:20,550
量子是它大致在动物

1900
01:12:20,550 --> 01:12:22,170
数据库中，他们基本上说哦，我

1901
01:12:22,170 --> 01:12:24,480
要从磁盘或网络上读取一些东西

1902
01:12:24,480 --> 01:12:25,920
让我回到我的日程安排并说

1903
01:12:25,920 --> 01:12:27,390
嘿，

1904
01:12:27,390 --> 01:12:30,240
如果可以的话，我要暂停一下其他人的日程安排 如果

1905
01:12:30,240 --> 01:12:32,190
这个人说哦，你很好，那么

1906
01:12:32,190 --> 01:12:33,570
你会重新获得控制权，否则

1907
01:12:33,570 --> 01:12:38,370
安排其他事情是的，这是一个很好的

1908
01:12:38,370 --> 01:12:40,290
项目，阅读是的，我们可以谈论这个

1909
01:12:40,290 --> 01:12:43,680
是的，现在我们真的没有

1910
01:12:43,680 --> 01:12:45,210
任何我没有的东西 与我们一起滑动我们

1911
01:12:45,210 --> 01:12:47,670
用于查询执行我们使用英特尔的

1912
01:12:47,670 --> 01:12:49,620
线程构建 我不喜欢的 ding 块，

1913
01:12:49,620 --> 01:12:52,530
因为它基本上

1914
01:12:52,530 --> 01:12:54,510
就像一个黑匣子 你基本上基本上是

1915
01:12:54,510 --> 01:12:55,770
为了查询计划 你把它分成

1916
01:12:55,770 --> 01:12:59,450
一个 dag 你把它交给线程

1917
01:12:59,450 --> 01:13:02,880
到 TVB 图书馆 它是调度程序它

1918
01:13:02,880 --> 01:13:04,260
做它的事情 和更好的你得到

1919
01:13:04,260 --> 01:13:06,240
回复但你不能同时发送或

1920
01:13:06,240 --> 01:13:07,920
其他东西至少

1921
01:13:07,920 --> 01:13:13,050
我认为不好所以

1922
01:13:13,050 --> 01:13:15,000
我要谈论的最后一件事是如何进行

1923
01:13:15,000 --> 01:13:17,400
流量控制我有点简短

1924
01:13:17,400 --> 01:13:18,870
用硬队列和软队列方法讨论过这个问题，

1925
01:13:18,870 --> 01:13:20,990
比如如果我意识到

1926
01:13:20,990 --> 01:13:23,820
我不能足够快地处理查询，那么

1927
01:13:23,820 --> 01:13:25,140
我可以拿走网络线程并

1928
01:13:25,140 --> 01:13:27,750
分配 unpark 查询处理线程，

1929
01:13:27,750 --> 01:13:31,980
但基本上就像如果查询共享

1930
01:13:31,980 --> 01:13:33,270
显示得比我们处理得快

1931
01:13:33,270 --> 01:13:34,710
他们然后我们将变得

1932
01:13:34,710 --> 01:13:37,710
超载所以操作系统

1933
01:13:37,710 --> 01:13:39,750
不会再帮助我们因为如果对于 cpu 绑定

1934
01:13:39,750 --> 01:13:43,350
那么它对内存绑定没有任何作用

1935
01:13:43,350 --> 01:13:44,670
，实际上他的

1936
01:13:44,670 --> 01:13:47,520
问题是什么，如果我分配 1

1937
01:13:47,520 --> 01:13:48,780
TB 的内存和 一世 没有 1

1938
01:13:48,780 --> 01:13:50,400
TB 的内存，我也没有 1

1939
01:13:50,400 --> 01:13:52,380
TB 的交换空间会发生什么

1940
01:13:52,380 --> 01:13:52,950


1941
01:13:52,950 --> 01:13:54,780
事情被称为操作系统有一个特殊的

1942
01:13:54,780 --> 01:13:56,580
东西叫做内存不足

1943
01:13:56,580 --> 01:13:59,730
杀手 om 基本上说哦，我

1944
01:13:59,730 --> 01:14:00,810
的内存用完了 我的

1945
01:14:00,810 --> 01:14:02,220
交换天数快用完了 让我选择一个随机进程

1946
01:14:02,220 --> 01:14:04,920
并正确杀死它 你会得到一个信号

1947
01:14:04,920 --> 01:14:07,320
术语它你知道它只会杀死

1948
01:14:07,320 --> 01:14:11,420
你是

1949
01:14:12,610 --> 01:14:24,280
什么先生什么是 cowlick 对不起 Oh

1950
01:14:24,280 --> 01:14:30,530
cowlick 对不起是的 嗯 什么会说什么

1951
01:14:30,530 --> 01:14:32,600
我会不会觉得如果我尝试

1952
01:14:32,600 --> 01:14:34,520
malloc 并初始化 1 TB 的

1953
01:14:34,520 --> 01:14:36,680
内存，它会开始运行

1954
01:14:36,680 --> 01:14:39,320
交换空间，如果我没有看到

1955
01:14:39,320 --> 01:14:42,800
空间，我认为该策略适用于 om 我

1956
01:14:42,800 --> 01:14:44,240
认为它会选择任何有的

1957
01:14:44,240 --> 01:14:46,370
最大的内存，因为再次从

1958
01:14:46,370 --> 01:14:49,340
操作系统世界，如 Linux 工作是

1959
01:14:49,340 --> 01:14:52,820
不会死的，如果是这样，它也不会

1960
01:14:52,820 --> 01:14:54,620
幸存下来，它必须杀死你的数据库

1961
01:14:54,620 --> 01:15:00,170
系统，它会做对的，所以你

1962
01:15:00,170 --> 01:15:02,480
知道从明显的

1963
01:15:02,480 --> 01:15:04,100
角度来看这个 是正确的

1964
01:15:04,100 --> 01:15:05,990
做法而不是我 c 机架

1965
01:15:05,990 --> 01:15:08,270
停下来，从不做任何正确的事情我会

1966
01:15:08,270 --> 01:15:10,400
我会杀死数据系统然后

1967
01:15:10,400 --> 01:15:13,660
这样你仍然可以知道YouTube是的

1968
01:15:13,660 --> 01:15:17,060
所以从戴维斯的一次再次

1969
01:15:17,060 --> 01:15:18,680
在这次崩溃中不是同一件事但是

1970
01:15:18,680 --> 01:15:20,720
我们 知道一些更聪明的东西，

1971
01:15:20,720 --> 01:15:22,630
它们在这里基本上是两个概念

1972
01:15:22,630 --> 01:15:24,560
排放控制和节流

1973
01:15:24,560 --> 01:15:25,880
基本上这个想法是我们

1974
01:15:25,880 --> 01:15:27,500
在哪里认识到我们的瓶颈是

1975
01:15:27,500 --> 01:15:28,730
我们无法处理事情，

1976
01:15:28,730 --> 01:15:31,480
然后我们如何将其暴露

1977
01:15:31,480 --> 01:15:35,450
给 外部世界，所以新

1978
01:15:35,450 --> 01:15:36,740
查询不会出现，我们会

1979
01:15:36,740 --> 01:15:38,780
不知所措，所以任务控制基本上是

1980
01:15:38,780 --> 01:15:41,540
我们认识到查询

1981
01:15:41,540 --> 01:15:43,790
出现，然后我们实际上没有足够的

1982
01:15:43,790 --> 01:15:44,930
资源 - 现在

1983
01:15:44,930 --> 01:15:48,380
因为我们受 CPU 限制，或者我们

1984
01:15:48,380 --> 01:15:51,260
内存不足，我们继续说我们

1985
01:15:51,260 --> 01:15:54,560
拒绝请求，我认为在

1986
01:15:54,560 --> 01:15:56,570
post ghost 协议 II 中认为您

1987
01:15:56,570 --> 01:15:59,270
不能发回这是拒绝请求，

1988
01:15:59,270 --> 01:16:01,100
但您可以发回类似的查询失败

1989
01:16:01,100 --> 01:16:04,880
或关闭连接 节流

1990
01:16:04,880 --> 01:16:07,100
将 b 你刚刚

1991
01:16:07,100 --> 01:16:09,950
在查询出现时引入了一些人为的延迟，

1992
01:16:09,950 --> 01:16:12,770
所以这个想法是我

1993
01:16:12,770 --> 01:16:13,760
为我们睡了一点，也许开始

1994
01:16:13,760 --> 01:16:15,320
处理查询，或者当我

1995
01:16:15,320 --> 01:16:16,790
运行查询时，也许也睡了一点

1996
01:16:16,790 --> 01:16:21,050
，这样 for 整个系统，

1997
01:16:21,050 --> 01:16:22,460
因为现在查询并没有尝试

1998
01:16:22,460 --> 01:16:25,300
所有你知道的同时工作吗

1999
01:16:25,300 --> 01:16:27,920
这是一种顺利的事情，我

2000
01:16:27,920 --> 01:16:30,199
可以我你知道我实际上可以

2001
01:16:30,199 --> 01:16:31,070
处理

2002
01:16:31,070 --> 01:16:34,070
取得进展的事情所以我不是说一个

2003
01:16:34,070 --> 01:16:35,570
比其他不同的系统更好 做

2004
01:16:35,570 --> 01:16:37,640
不同的事情 这一个可能

2005
01:16:37,640 --> 01:16:39,620
是最常见的一个 但同样这

2006
01:16:39,620 --> 01:16:41,449
需要你现在需要知道

2007
01:16:41,449 --> 01:16:43,880
在实际

2008
01:16:43,880 --> 01:16:45,320
工作池中发生了什么 我们实际上超过了

2009
01:16:45,320 --> 01:16:46,820
查询 为了做出这个决定

2010
01:16:46,820 --> 01:16:48,530
，你不需要任何

2011
01:16:48,530 --> 01:16:50,480
集中控制，你只是说你

2012
01:16:50,480 --> 01:16:52,190
很清楚，除了我需要

2013
01:16:52,190 --> 01:16:54,440
认识到我的速度变慢了或者我的

2014
01:16:54,440 --> 01:16:56,449
队列越来越确定我

2015
01:16:56,449 --> 01:16:58,130
不能得到 大比

2016
01:16:58,130 --> 01:17:00,530
小 呃，当我处理事情时，我只是

2017
01:17:00,530 --> 01:17:01,580
介绍了这些事情，但我并没有

2018
01:17:01,580 --> 01:17:03,140
真正做出全局决定每个

2019
01:17:03,140 --> 01:17:04,250
威胁都可以自己决定

2020
01:17:04,250 --> 01:17:08,660
是否引入睡眠，所以

2021
01:17:08,660 --> 01:17:10,580
高端系统可以做到这一点，这

2022
01:17:10,580 --> 01:17:13,219
有点像一种方法

2023
01:17:13,219 --> 01:17:15,110
抱歉，这是一种倒退的方法，但就像这是

2024
01:17:15,110 --> 01:17:16,460
最简单的方法，高端

2025
01:17:16,460 --> 01:17:18,230
系统可以做到这一点，因为您可以做

2026
01:17:18,230 --> 01:17:20,870
其他事情，例如我可以做的事情，我可以有

2027
01:17:20,870 --> 01:17:22,969
优先队列说，如果有人

2028
01:17:22,969 --> 01:17:24,590
使用此用户名进行连接，让 他们的

2029
01:17:24,590 --> 01:17:25,910
查询总是运行，即使我已经过

2030
01:17:25,910 --> 01:17:27,680
饱和，而如果其他

2031
01:17:27,680 --> 01:17:29,239
人就像一个低收入客户，

2032
01:17:29,239 --> 01:17:31,250
他们可以运行得更慢，当然如果我

2033
01:17:31,250 --> 01:17:34,010
是管理员，就像很多这些系统

2034
01:17:34,010 --> 01:17:36,410
总是为管理员维护一个开放端口

2035
01:17:36,410 --> 01:17:37,430
查看它将连接到

2036
01:17:37,430 --> 01:17:38,870
系统并实际查询开始

2037
01:17:38,870 --> 01:17:42,290
杀死事物，并且您知道释放

2038
01:17:42,290 --> 01:17:44,239
资源，因此在这种情况下，

2039
01:17:44,239 --> 01:17:47,810
您知道这是非常常见的，所以

2040
01:17:47,810 --> 01:17:49,780
我们今天涵盖了很多内容

2041
01:17:49,780 --> 01:17:52,070


2042
01:17:52,070 --> 01:17:53,570
整个学期，尤其是今天

2043
01:17:53,570 --> 01:17:55,520
，什么是数据库系统，它是

2044
01:17:55,520 --> 01:17:57,230
一个漂亮的软件，我们

2045
01:17:57,230 --> 01:17:59,150
不希望操作系统毁了我们，所以

2046
01:17:59,150 --> 01:18:00,890
我们正在努力做尽可能多的事情。

2047
01:18:00,890 --> 01:18:02,780
一个

2048
01:18:02,780 --> 01:18:04,880
极端，但至少我们

2049
01:18:04,880 --> 01:18:07,430
需要知道线程正在运行的内存布局，

2050
01:18:07,430 --> 01:18:08,960
以便我们

2051
01:18:08,960 --> 01:18:11,210
最大限度地减少

2052
01:18:11,210 --> 01:18:15,410
连接正确的流量和

2053
01:18:15,410 --> 01:18:17,360
元数据的数量意味着您维护一

2054
01:18:17,360 --> 01:18:18,860
点点定位器的位置 日期

2055
01:18:18,860 --> 01:18:22,070
块位于相当低的位置，这并不

2056
01:18:22,070 --> 01:18:23,719
像我们需要你知道里面的任何东西，

2057
01:18:23,719 --> 01:18:24,949
这是需要

2058
01:18:24,949 --> 01:18:27,350


2059
01:18:27,350 --> 01:18:29,210


2060
01:18:29,210 --> 01:18:31,160
知道的

2061
01:18:31,160 --> 01:18:32,840
在这里找到它所在的诺依曼区域

2062
01:18:32,840 --> 01:18:34,910
，然后在此之后为其分配任务

2063
01:18:34,910 --> 01:18:36,920
，但通常那是您

2064
01:18:36,920 --> 01:18:38,840
不想这样做，因为这是一个系统调用

2065
01:18:38,840 --> 01:18:40,760
，因此我们不会自己跟踪所有内容

2066
01:18:40,760 --> 01:18:42,860
，而操作系统又是

2067
01:18:42,860 --> 01:18:45,199
敌人  我们需要它来生存，但我们

2068
01:18:45,199 --> 01:18:46,460
不想实际上必须尽可能多

2069
01:18:46,460 --> 01:18:47,810
地与之交谈我们不希望它做

2070
01:18:47,810 --> 01:18:52,969
任何事情都可以，任何问题都可以，所以

2071
01:18:52,969 --> 01:18:54,739
下节课我们将

2072
01:18:54,739 --> 01:18:57,230
详细了解这些是什么 任务

2073
01:18:57,230 --> 01:18:58,190
实际上可能看起来像以及我们将如何

2074
01:18:58,190 --> 01:19:00,190
实际执行它们，

2075
01:19:00,190 --> 01:19:03,170
然后我们将在 Piazza

2076
01:19:03,170 --> 01:19:05,000
上发布项目二的检查点更新

2077
01:19:05,000 --> 01:19:06,889
，如果您没有小组，我

2078
01:19:06,889 --> 01:19:09,020
今天将给您发送电子邮件并强制 你结交

2079
01:19:09,020 --> 01:19:10,750
朋友并选择一个小组好吧

2080
01:19:10,750 --> 01:19:16,780
伙计们这是什么

2081
01:19:16,970 --> 01:19:37,079
[音乐

2082
01:19:38,820 --> 01:19:41,070
]我的引擎盖将不一样我已经切碎了

2083
01:19:41,070 --> 01:19:44,930
你说我说了一个祈祷

