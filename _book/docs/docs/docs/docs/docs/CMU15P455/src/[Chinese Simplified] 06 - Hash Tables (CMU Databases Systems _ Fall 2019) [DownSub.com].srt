1
00:00:03,640 --> 00:00:13,509
[音乐]

2
00:00:15,270 --> 00:00:19,420
好吧，让我们开始吧，好吧，让我们

3
00:00:19,420 --> 00:00:21,600
再次放弃 DJ 顶级桌，

4
00:00:21,600 --> 00:00:25,450
谢谢孩子们，你周末过得好

5
00:00:25,450 --> 00:00:29,560
吗，你知道我正在招聘 TLC 的新

6
00:00:29,560 --> 00:00:31,480
工作，这很困难，

7
00:00:31,480 --> 00:00:33,969
实际上我发现 Salesforce

8
00:00:33,969 --> 00:00:35,739
在主楼的大厅里有

9
00:00:35,739 --> 00:00:37,960
旧金山他们每天早上都有一个 DJ

10
00:00:37,960 --> 00:00:40,510
轮流转哦，你想

11
00:00:40,510 --> 00:00:42,719
知道如何让你得到那份工作

12
00:00:42,719 --> 00:00:46,839
吗？ 是的，我猜你会做得很好，所以我

13
00:00:46,839 --> 00:00:48,760
认为今天大多数人都在 TOC

14
00:00:48,760 --> 00:00:50,649
所以这就是为什么它是一个低 投票率

15
00:00:50,649 --> 00:00:52,629
很不幸，因为这是我

16
00:00:52,629 --> 00:00:54,729
最喜欢的讲座哈希表之一，所以

17
00:00:54,729 --> 00:00:56,379
我们有很多要讨论的内容，让

18
00:00:56,379 --> 00:00:58,389
我们如此快速地完成它，然后

19
00:00:58,389 --> 00:01:00,489
提醒

20
00:01:00,489 --> 00:01:02,889
你们注意事项中的内容 下周到期的项目是什么

21
00:01:02,889 --> 00:01:05,920
周五午夜 27 日

22
00:01:05,920 --> 00:01:07,570
，然后是今天晚些时候发布的作业 2，该作业

23
00:01:07,570 --> 00:01:08,979


24
00:01:08,979 --> 00:01:12,899
将在项目结束后的周一 30 日到期，

25
00:01:12,899 --> 00:01:15,820
因此

26
00:01:15,820 --> 00:01:21,969
有关项目一的任何快速高级问题都将设置

27
00:01:21,969 --> 00:01:24,159
为问题是什么时候与 th

28
00:01:24,159 --> 00:01:25,869
我的意思是自动分级器已发布 我的意思是它

29
00:01:25,869 --> 00:01:27,939
现在可以在很大范围内使用，您今天可以提交

30
00:01:27,939 --> 00:01:30,850
内容，但我们显然不会向您

31
00:01:30,850 --> 00:01:32,109
提供测试的源代码，

32
00:01:32,109 --> 00:01:34,359
因为这意味着伟大的

33
00:01:34,359 --> 00:01:36,969
先生，如果您提交它，它应该是可用的

34
00:01:36,969 --> 00:01:38,229
不起作用，请在

35
00:01:38,229 --> 00:01:41,409
Piazza 上发帖 好吧，其他高级

36
00:01:41,409 --> 00:01:47,350
问题还可以 所以我们现在的

37
00:01:47,350 --> 00:01:49,179
课程是我们已经花了

38
00:01:49,179 --> 00:01:51,520
前几周再次从

39
00:01:51,520 --> 00:01:52,929
数据系统架构的堆栈底部开始

40
00:01:52,929 --> 00:01:55,479
并工作

41
00:01:55,479 --> 00:01:57,490
我们讨论了如何将数据存储在

42
00:01:57,490 --> 00:02:00,009
磁盘上 磁盘上的页面 然后我们讨论

43
00:02:00,009 --> 00:02:01,719
了如何将这些页面带入

44
00:02:01,719 --> 00:02:03,159
内存和我们的缓冲池或缓冲区

45
00:02:03,159 --> 00:02:06,310
缓存 并让策略决定

46
00:02:06,310 --> 00:02:07,899
何时驱逐某些东西以及

47
00:02:07,899 --> 00:02:10,150
如何驱逐 在我写的时候固定东西，所以

48
00:02:10,150 --> 00:02:11,830
现在我们在缓冲池

49
00:02:11,830 --> 00:02:13,720
管理器之上，我们开始讨论

50
00:02:13,720 --> 00:02:16,240
方法，所以这些访问方法是

51
00:02:16,240 --> 00:02:19,180
我们要知道的一种方式，你知道从

52
00:02:19,180 --> 00:02:21,250
本质上读取或写入

53
00:02:21,250 --> 00:02:22,810
我们数据库中的数据 存储在

54
00:02:22,810 --> 00:02:25,330
存储在磁盘上的页面 所以

55
00:02:25,330 --> 00:02:29,500
今天我们要讨论的内容 今天我们将开始

56
00:02:29,500 --> 00:02:31,990
一系列讲座 我们将针对

57
00:02:31,990 --> 00:02:33,970
我们将

58
00:02:33,970 --> 00:02:35,440
在数据库系统内部维护的数据结构进行一系列讲座

59
00:02:35,440 --> 00:02:37,180
将它分成

60
00:02:37,180 --> 00:02:38,710
哈希

61
00:02:38,710 --> 00:02:42,550
表和顺序保留树之间的两个讨论，因此

62
00:02:42,550 --> 00:02:43,780


63
00:02:43,780 --> 00:02:44,860
如果您因为您现在已经参加了

64
00:02:44,860 --> 00:02:46,480
算法课程，那么他们每个人都有不同的权衡，所以您

65
00:02:46,480 --> 00:02:47,890
了解这两个的含义，

66
00:02:47,890 --> 00:02:49,959
但我们将描述

67
00:02:49,959 --> 00:02:52,240
在数据库系统的上下文中什么对我们很重要

68
00:02:52,240 --> 00:02:54,250
因为仅仅因为你有一个

69
00:02:54,250 --> 00:02:55,660
树而不是一个哈希表也许就

70
00:02:55,660 --> 00:02:57,850
知道如何在它上面做证明或

71
00:02:57,850 --> 00:02:59,980
编写算法来与之交互

72
00:02:59,980 --> 00:03:01,959
现在让我们谈谈

73
00:03:01,959 --> 00:03:02,890
当我们实际放置它时会发生什么 在

74
00:03:02,890 --> 00:03:04,180
数据库系统内部并实际尝试使用

75
00:03:04,180 --> 00:03:07,840
它，因此数据结构在

76
00:03:07,840 --> 00:03:09,610
整个数据库测量

77
00:03:09,610 --> 00:03:11,910
系统中都用于各种目的

78
00:03:11,910 --> 00:03:14,380
所以到目前为止我们已经讨论过的一件事

79
00:03:14,380 --> 00:03:16,980
我们转向如何使用数据结构

80
00:03:16,980 --> 00:03:19,180


81
00:03:19,180 --> 00:03:20,980
当我们

82
00:03:20,980 --> 00:03:22,480
谈论存在页表或页

83
00:03:22,480 --> 00:03:24,250
目录时，用于维护关于我们数据库中内容的内部元数据，这是一个哈希表，用于

84
00:03:24,250 --> 00:03:26,800
在哈希 IDE 之间进行查找，或者从一个

85
00:03:26,800 --> 00:03:30,790
页面到一个页面 ID 到一个框架或一个 页面

86
00:03:30,790 --> 00:03:35,500
ID 到磁盘上的某个位置

87
00:03:35,500 --> 00:03:36,640
我们可以使用它们的下一件事情实际上

88
00:03:36,640 --> 00:03:37,989
只是数据库本身的核心数据存储，

89
00:03:37,989 --> 00:03:40,900
所以我的意思是不好

90
00:03:40,900 --> 00:03:43,000
而不是为了堆

91
00:03:43,000 --> 00:03:44,470
一堆我们可以实际组织的页面

92
00:03:44,470 --> 00:03:47,170
它们在更高级别上是哈希

93
00:03:47,170 --> 00:03:49,540
表或 B+ 树或树数据

94
00:03:49,540 --> 00:03:52,420
结构，并且数据结构中的值

95
00:03:52,420 --> 00:03:54,100
实际上是元组，

96
00:03:54,100 --> 00:03:56,709
因此这在许多系统中非常常见，

97
00:03:56,709 --> 00:03:59,080
例如 memcache，例如

98
00:03:59,080 --> 00:04:00,670
基本上是一个 john 一个巨大的哈希表

99
00:04:00,670 --> 00:04:03,610
或我在 DDS 引擎中的 Seco 只是一个 B+

100
00:04:03,610 --> 00:04:04,810
树，它们将元组本身存储在树

101
00:04:04,810 --> 00:04:06,640
的

102
00:04:06,640 --> 00:04:09,519
叶节点的一侧，我们也可以使用

103
00:04:09,519 --> 00:04:11,560
数据结构来维护临时

104
00:04:11,560 --> 00:04:13,540
数据，所以这就像我们 '

105
00:04:13,540 --> 00:04:15,970
正在运行查询 我们需要

106
00:04:15,970 --> 00:04:17,529
非常有效地计算一些东西 我们可以动态

107
00:04:17,529 --> 00:04:19,200
构建一个数据结构

108
00:04:19,200 --> 00:04:21,160
填充我们需要的任何数据

109
00:04:21,160 --> 00:04:23,470
完成执行查询

110
00:04:23,470 --> 00:04:24,940
然后丢弃该数据结构

111
00:04:24,940 --> 00:04:27,310
并完成它和最后一个这

112
00:04:27,310 --> 00:04:27,880
就是你的原因

113
00:04:27,880 --> 00:04:29,470
最熟悉的是将这些

114
00:04:29,470 --> 00:04:32,020
数据结构用于表索引

115
00:04:32,020 --> 00:04:34,270
基本上是

116
00:04:34,270 --> 00:04:37,000
在我们的元组内的键上建立一个词汇表，并允许

117
00:04:37,000 --> 00:04:38,500
您知道如何快速查找以找到

118
00:04:38,500 --> 00:04:40,690
我们想要的单个元素，而

119
00:04:40,690 --> 00:04:41,860
不必

120
00:04:41,860 --> 00:04:44,050
在整个数据库中进行顺序扫描 所以为了

121
00:04:44,050 --> 00:04:46,060
所有这些目的，你需要好的

122
00:04:46,060 --> 00:04:48,330
数据结构来做所有这些

123
00:04:48,330 --> 00:04:50,770
事情所以我们想要关心我们如何

124
00:04:50,770 --> 00:04:53,830
设计我们的数据结构是

125
00:04:53,830 --> 00:04:56,110
以下两件事所以第一件事

126
00:04:56,110 --> 00:04:57,010
是执行我们的数据

127
00:04:57,010 --> 00:04:59,230
组织 需要我们如何

128
00:04:59,230 --> 00:05:01,840
表示键值对

129
00:05:01,840 --> 00:05:03,190
是我们存储

130
00:05:03,190 --> 00:05:05,530
在内存中或

131
00:05:05,530 --> 00:05:07,390
存储在磁盘上的页面上的数据元素 我们以

132
00:05:07,390 --> 00:05:09,850
一种有效的方式做到这一点，它可以支持快速

133
00:05:09,850 --> 00:05:12,610
读取和写入，而无需进行

134
00:05:12,610 --> 00:05:14,430
大修，或者可能

135
00:05:14,430 --> 00:05:16,090


136
00:05:16,090 --> 00:05:19,810
每次都重新构建整个数据结构 第二个

137
00:05:19,810 --> 00:05:21,340
问题是我们将如何允许

138
00:05:21,340 --> 00:05:23,260
多个线程访问我们的数据

139
00:05:23,260 --> 00:05:24,730
结构或多个查询

140
00:05:24,730 --> 00:05:26,770
同时访问我们的数据结构，

141
00:05:26,770 --> 00:05:29,470
而不会对数据

142
00:05:29,470 --> 00:05:31,000
的永恒表示造成任何物理冲突，

143
00:05:31,000 --> 00:05:33,670
所以我的意思是我们不

144
00:05:33,670 --> 00:05:36,250
希望一个线程更新

145
00:05:36,250 --> 00:05:37,810
内存地址而另一个线程 它正在

146
00:05:37,810 --> 00:05:39,520
读取该地址，然后他们看到该地址的

147
00:05:39,520 --> 00:05:41,530
一些撕裂的白色或一些损坏的

148
00:05:41,530 --> 00:05:42,940
版本，现在它指向

149
00:05:42,940 --> 00:05:45,040
某个无效页面或安装了无效的

150
00:05:45,040 --> 00:05:46,810
内存位置，我们最终会

151
00:05:46,810 --> 00:05:49,780
产生不正确的结果，所以我们将

152
00:05:49,780 --> 00:05:52,180
看看我们如何实际处理这个我们'

153
00:05:52,180 --> 00:05:54,910
今天我们会讲的有点长，但

154
00:05:54,910 --> 00:05:56,590
我们会花一整堂课，同时

155
00:05:56,590 --> 00:05:58,120
讨论如何

156
00:05:58,120 --> 00:06:00,550
在这些数据内部的索引内部进行并发控制

157
00:06:00,550 --> 00:06:02,080
结构，但就我们今天的目的而言，

158
00:06:02,080 --> 00:06:03,130
但您在某种程度上简化了讨论，

159
00:06:03,130 --> 00:06:04,990
只是假设我们只有一个线程

160
00:06:04,990 --> 00:06:06,910
，因为这在

161
00:06:06,910 --> 00:06:08,020
稍后我们谈论交易时也会很重要，

162
00:06:08,020 --> 00:06:11,140
因为

163
00:06:11,140 --> 00:06:12,850
我们将在这里谈论的事情类型我们 将使用锁存器

164
00:06:12,850 --> 00:06:14,140
来保护物理数据结构

165
00:06:14,140 --> 00:06:17,020
，防止再次读取无效的

166
00:06:17,020 --> 00:06:18,190
内存地址或无效的页面

167
00:06:18,190 --> 00:06:20,050
位置 还有一个更高层次的

168
00:06:20,050 --> 00:06:21,880
概念，

169
00:06:21,880 --> 00:06:24,100
即我们需要关心的数据结构的逻辑正确性是什么

170
00:06:24,100 --> 00:06:25,360


171
00:06:25,360 --> 00:06:27,430
，稍后会提到 在学期中，所以

172
00:06:27,430 --> 00:06:29,020
它说我的意思是说我

173
00:06:29,020 --> 00:06:31,900
有一个索引 如果我回来，我会删除一个键

174
00:06:31,900 --> 00:06:33,460
Mike 我的线程回来并尝试

175
00:06:33,460 --> 00:06:35,260
再次检索该键 我不应该

176
00:06:35,260 --> 00:06:36,610
得到它，因为我知道它已经

177
00:06:36,610 --> 00:06:38,410
尽管物理位仍然

178
00:06:38,410 --> 00:06:40,930
可能存在，但已删除，因为我稍后会做一些

179
00:06:40,930 --> 00:06:41,620
后台

180
00:06:41,620 --> 00:06:44,380
垃圾清理，但从逻辑上讲，米奇

181
00:06:44,380 --> 00:06:45,520
应该消失，即使

182
00:06:45,520 --> 00:06:47,620
物理上不是这样，所以这个主题非常

183
00:06:47,620 --> 00:06:49,389
复杂 所以我们今天会稍微接触

184
00:06:49,389 --> 00:06:50,680
一下，但主要关心

185
00:06:50,680 --> 00:06:53,440


186
00:06:53,440 --> 00:06:54,490
数据结构的物理完整性而不是逻辑结构，

187
00:06:54,490 --> 00:06:59,470
今天再次我们

188
00:06:59,470 --> 00:07:03,160
将专注于哈希表，因此哈希表

189
00:07:03,160 --> 00:07:05,500
是一个抽象数据 我们将

190
00:07:05,500 --> 00:07:08,260
用来提供无序

191
00:07:08,260 --> 00:07:10,990
关联数组实现或 API 的类型

192
00:07:10,990 --> 00:07:13,030
，所有这一切都意味着我们能够将

193
00:07:13,030 --> 00:07:16,770
任意键映射到任意

194
00:07:16,770 --> 00:07:18,820
值，没有任何顺序，

195
00:07:18,820 --> 00:07:21,130
就像我们将在树中看到的那样

196
00:07:21,130 --> 00:07:22,419
所以我们能够通过

197
00:07:22,419 --> 00:07:23,979
这些快速查找来

198
00:07:23,979 --> 00:07:25,600
找到我们想要的元素的方式是我们

199
00:07:25,600 --> 00:07:27,760
将使用一个散列函数，该函数

200
00:07:27,760 --> 00:07:30,130
将接收我们的密钥，然后

201
00:07:30,130 --> 00:07:34,060
以某种方式计算一些偏移量到某个位置

202
00:07:34,060 --> 00:07:36,729
我的数组，这会告诉我

203
00:07:36,729 --> 00:07:39,400
究竟是要寻找的元素，或者我可以

204
00:07:39,400 --> 00:07:41,320
粗略地环顾四周

205
00:07:41,320 --> 00:07:43,690
，在我使用散列函数

206
00:07:43,690 --> 00:07:45,070
找到我正在寻找的东西之后，

207
00:07:45,070 --> 00:07:47,320
散列函数不是 总是会让

208
00:07:47,320 --> 00:07:48,910
我们准确地到达我们所在的地方 nt 但至少

209
00:07:48,910 --> 00:07:50,950
让我们找到正确的位置，然后我们知道

210
00:07:50,950 --> 00:07:52,330
如何环顾四周以找到

211
00:07:52,330 --> 00:07:54,820
我们正在寻找的东西，

212
00:07:54,820 --> 00:07:56,320
所以这一切都不应该是新的，你

213
00:07:56,320 --> 00:07:58,180
应该都参加一个算法课程，

214
00:07:58,180 --> 00:07:59,889
所以空间复杂度

215
00:07:59,889 --> 00:08:03,940
哈希表的最坏情况是 Big On 这

216
00:08:03,940 --> 00:08:05,680
意味着我们对于我们想要存储的每个键，

217
00:08:05,680 --> 00:08:09,490
我们在哈希表中至少有一个条目，

218
00:08:09,490 --> 00:08:10,990
因此分配该

219
00:08:10,990 --> 00:08:13,570
内存量的空间量的

220
00:08:13,570 --> 00:08:14,979
操作复杂性很有趣

221
00:08:14,979 --> 00:08:17,560
因为平均而言，我们将进行一次

222
00:08:17,560 --> 00:08:20,710
查找，这意味着我们在恒定时间内的一个步骤中，

223
00:08:20,710 --> 00:08:22,419
您可以准确地找到

224
00:08:22,419 --> 00:08:24,910
我们正在寻找的最坏

225
00:08:24,910 --> 00:08:26,800
情况，我们将在几秒钟内看到为什么会发生这种

226
00:08:26,800 --> 00:08:29,169
情况，最坏情况

227
00:08:29,169 --> 00:08:32,080
case 场景会变得很大，这意味着我们

228
00:08:32,080 --> 00:08:33,610
必须进行斜视扫描或线性

229
00:08:33,610 --> 00:08:35,979
搜索以查找每个

230
00:08:35,979 --> 00:08:37,570
可能的键以找到

231
00:08:37,570 --> 00:08:39,729
我们正在寻找的键，因此您可能会想，

232
00:08:39,729 --> 00:08:42,130
这很棒 任何散列

233
00:08:42,130 --> 00:08:43,450
函数或任何散列表 会这样做，

234
00:08:43,450 --> 00:08:45,580
因为我在实践中的大部分时间总是会得到 o 1，

235
00:08:45,580 --> 00:08:47,589
即使这

236
00:08:47,589 --> 00:08:49,900
在现实世界中速度非常快，其中

237
00:08:49,900 --> 00:08:52,030
涉及金钱的常数因素

238
00:08:52,030 --> 00:08:54,339
实际上很重要，所以

239
00:08:54,339 --> 00:08:55,450
当我们正确地查看函数时我们会看到这一点

240
00:08:55,450 --> 00:08:57,790
散列函数

241
00:08:57,790 --> 00:08:59,890
你所知道的有时它

242
00:08:59,890 --> 00:09:01,360
仍然会非常快但是会有一些

243
00:09:01,360 --> 00:09:02,650
散列函数的

244
00:09:02,650 --> 00:09:03,970
速度是其他散列函数的两倍或三倍

245
00:09:03,970 --> 00:09:05,860
所以你可能会说

246
00:09:05,860 --> 00:09:07,720
一次散列没问题 谁在乎，但如果现在我正在

247
00:09:07,720 --> 00:09:09,970
对 10 亿个东西进行哈希处理，而我糟糕的

248
00:09:09,970 --> 00:09:11,920
哈希函数比现在最快的哈希函数慢一秒

249
00:09:11,920 --> 00:09:13,030


250
00:09:13,030 --> 00:09:14,740
，那就是我要花费 10 亿

251
00:09:14,740 --> 00:09:17,020
秒来进行查找，所以

252
00:09:17,020 --> 00:09:18,520
当我们正在查看涉及真钱

253
00:09:18,520 --> 00:09:20,410
大规模的常数

254
00:09:20,410 --> 00:09:21,880
因素实际上很重要，当

255
00:09:21,880 --> 00:09:23,380
您上算法课时，就像哦，

256
00:09:23,380 --> 00:09:25,060
我们不关心其他任何

257
00:09:25,060 --> 00:09:27,340
事情常数在我们的世界中无关紧要

258
00:09:27,340 --> 00:09:30,460
它做得很好所以让我们看一下

259
00:09:30,460 --> 00:09:31,930
您可以使用的最简单的哈希表 曾经

260
00:09:31,930 --> 00:09:35,320
建立 是的，它只是一个

261
00:09:35,320 --> 00:09:37,270
巨大的数组，现在就像一

262
00:09:37,270 --> 00:09:39,070
大块内存，然后我们会

263
00:09:39,070 --> 00:09:42,660
说数组中的每个偏移量都

264
00:09:42,660 --> 00:09:46,240
对应于给定的元素，因此

265
00:09:46,240 --> 00:09:48,490
为了使其工作，我们将假设

266
00:09:48,490 --> 00:09:50,230
我们确切地知道键的数量

267
00:09:50,230 --> 00:09:52,120
会提前，并且我们

268
00:09:52,120 --> 00:09:54,160
确切地知道减少了什么

269
00:09:54,160 --> 00:09:55,510
我们不应该他们的值与

270
00:09:55,510 --> 00:09:58,660
他们的实际值是什么所以现在

271
00:09:58,660 --> 00:10:01,390
在我的哈希表中找到任何键我只

272
00:10:01,390 --> 00:10:04,990
需要 根据我拥有的元素数量对 key mod 进行散列

273
00:10:04,990 --> 00:10:06,580


274
00:10:06,580 --> 00:10:09,040
，然后这将使我得到一些

275
00:10:09,040 --> 00:10:11,080
偏移，这

276
00:10:11,080 --> 00:10:15,610
正是我正在寻找的东西，所以让我们看看它是

277
00:10:15,610 --> 00:10:16,630
如何工作的，让我们 这么说

278
00:10:16,630 --> 00:10:21,010
，我们有三个键 ABCD de FXYZ

279
00:10:21,010 --> 00:10:23,530
所以我再次可以把这个东西 ABCD

280
00:10:23,530 --> 00:10:26,950
ABC 散列它然后告诉我我

281
00:10:26,950 --> 00:10:29,320
知道我在零偏移量正是

282
00:10:29,320 --> 00:10:32,410
我正在寻找的东西所以这不是

283
00:10:32,410 --> 00:10:34,270


284
00:10:34,270 --> 00:10:35,440
如果这只是存储 ori，我们的哈希表实际上可能看起来像什么

285
00:10:35,440 --> 00:10:37,690
ginal 键并练习

286
00:10:37,690 --> 00:10:38,740
我们实际上需要的是

287
00:10:38,740 --> 00:10:41,440
存储指向原始键位置的指针，您知道原始键

288
00:10:41,440 --> 00:10:42,400
所在的其他

289
00:10:42,400 --> 00:10:44,710
位置再次将

290
00:10:44,710 --> 00:10:47,020
其视为表索引，我不想

291
00:10:47,020 --> 00:10:48,550
将键存储在其中 也许我的哈希

292
00:10:48,550 --> 00:10:50,410
表我想将它存储一个指向可以

293
00:10:50,410 --> 00:10:54,440
找到键的位置的指针，

294
00:10:54,440 --> 00:10:56,329
所以

295
00:10:56,329 --> 00:10:59,060
有时我们使用这种哈希

296
00:10:59,060 --> 00:11:05,800
表会遇到什么问题，是的，

297
00:11:05,889 --> 00:11:07,790
正确地在后面，您说我们知道

298
00:11:07,790 --> 00:11:10,040
前面的数字元素 首先是时间，

299
00:11:10,040 --> 00:11:11,000


300
00:11:11,000 --> 00:11:17,060
第二个假设是什么，因为

301
00:11:17,060 --> 00:11:18,529
所有电池在

302
00:11:18,529 --> 00:11:20,149
缓存中彼此靠近，为此目的，

303
00:11:20,149 --> 00:11:24,620
这并不重要，但他说

304
00:11:24,620 --> 00:11:26,360
键之间没有冲突，所以什么是

305
00:11:26,360 --> 00:11:28,209
冲突，

306
00:11:28,209 --> 00:11:30,079
他说哈希 在同一个插槽中

307
00:11:30,079 --> 00:11:32,509
完全正确 所以这个非常简单的哈希

308
00:11:32,509 --> 00:11:34,579
表 这实际上是

309
00:11:34,579 --> 00:11:36,740
您可能构建的最快的哈希表 但是

310
00:11:36,740 --> 00:11:38,180
您必须做出这些假设

311
00:11:38,180 --> 00:11:39,949
才能使其正常工作 所以第一个

312
00:11:39,949 --> 00:11:41,480
是 正如他所说，我们需要提前

313
00:11:41,480 --> 00:11:42,920
确切地知道我们拥有的元素数量，

314
00:11:42,920 --> 00:11:45,050
因此我们确切地知道

315
00:11:45,050 --> 00:11:46,819
要在数组中分配多少个插槽，

316
00:11:46,819 --> 00:11:49,550
并且在实践中，

317
00:11:49,550 --> 00:11:51,800
如果我正在构建，情况并非总是如此

318
00:11:51,800 --> 00:11:54,139
a 我正在使用我的哈希表作为

319
00:11:54,139 --> 00:11:56,870
哈希索引 我在创建表时是否

320
00:11:56,870 --> 00:11:58,189
在表上 我没有

321
00:11:58,189 --> 00:11:59,569
任何数据 我一开始没有任何数据，

322
00:11:59,569 --> 00:12:01,730
当我开始插入东西时，然后是

323
00:12:01,730 --> 00:12:04,029
数字 我需要的插槽实际上增长

324
00:12:04,029 --> 00:12:06,589
了我们混合的另一个假设是

325
00:12:06,589 --> 00:12:08,389
我们说每个散列或每个键都是

326
00:12:08,389 --> 00:12:09,529
唯一的，这就是

327
00:12:09,529 --> 00:12:10,970
他所说的没有冲突所以

328
00:12:10,970 --> 00:12:11,959
我们假设每次我们散列

329
00:12:11,959 --> 00:12:14,930
它总是会着陆 进入一个唯一的

330
00:12:14,930 --> 00:12:16,939
槽，用于那个键，只有那个

331
00:12:16,939 --> 00:12:19,100
键才能准确地找到

332
00:12:19,100 --> 00:12:22,100
我们正在寻找的东西，

333
00:12:22,100 --> 00:12:24,380
因为我们提前知道所有的键

334
00:12:24,380 --> 00:12:26,509
，因为我们知道它们

335
00:12:26,509 --> 00:12:29,839
在我们散列时是唯一的 他们这是使用

336
00:12:29,839 --> 00:12:31,660
所谓的完美散列函数

337
00:12:31,660 --> 00:12:33,949
所以完美 ct 哈希函数就像这样，

338
00:12:33,949 --> 00:12:35,779
如果它存在于研究文献中的理论事物，

339
00:12:35,779 --> 00:12:37,399
但

340
00:12:37,399 --> 00:12:39,290
实际上没有人真正这样做，因为这是

341
00:12:39,290 --> 00:12:40,519
不切实际的，您实际上无法做到这一点，

342
00:12:40,519 --> 00:12:42,649
而完美的哈希函数仅

343
00:12:42,649 --> 00:12:44,540
意味着如果我有两个不是

344
00:12:44,540 --> 00:12:47,059
它们的键' 不等价，那么

345
00:12:47,059 --> 00:12:50,360
我为它们生成的任何散列也

346
00:12:50,360 --> 00:12:52,519
不会等价，因此对于每个唯一

347
00:12:52,519 --> 00:12:54,680
键，我生成一个完全唯一的散列

348
00:12:54,680 --> 00:12:57,439
值，而且您实际上无法做到

349
00:12:57,439 --> 00:12:58,939
这一点，今天没有魔术散列

350
00:12:58,939 --> 00:13:01,309
函数可以保证这一点

351
00:13:01,309 --> 00:13:02,449
你实际上实现一个

352
00:13:02,449 --> 00:13:03,649
完美的散列函数的方式实际上是使用

353
00:13:03,649 --> 00:13:06,620
另一个散列表将一个键映射到

354
00:13:06,620 --> 00:13:07,680
另一个你

355
00:13:07,680 --> 00:13:09,540
知道散列值你知道这有点

356
00:13:09,540 --> 00:13:10,860
愚蠢因为现在你有一个散列表用于

357
00:13:10,860 --> 00:13:13,110
你的散列表所以实际上没有人

358
00:13:13,110 --> 00:13:16,529
这样做 在实践中，所以

359
00:13:16,529 --> 00:13:17,580
我们今天要讨论的事情是我们如何

360
00:13:17,580 --> 00:13:18,810
在现实世界中实际构建哈希表，

361
00:13:18,810 --> 00:13:20,490
而不必做出这些

362
00:13:20,490 --> 00:13:23,010
假设并能够在 da 中使用它们

363
00:13:23,010 --> 00:13:26,550
Tabase 系统，所以当人们说我

364
00:13:26,550 --> 00:13:29,040
有一个哈希表时，他们本质上的意思

365
00:13:29,040 --> 00:13:31,020
是它是一个由

366
00:13:31,020 --> 00:13:31,820
两部分组成

367
00:13:31,820 --> 00:13:35,250
的数据结构，第一个是哈希函数，它是

368
00:13:35,250 --> 00:13:37,320
一种获取任意键的方法，而 Matt

369
00:13:37,320 --> 00:13:40,500
你知道将它映射到一个整数值

370
00:13:40,500 --> 00:13:43,620
一个较小的域，这样我就可以接受任何

371
00:13:43,620 --> 00:13:45,240
字符串和整数，你浮动

372
00:13:45,240 --> 00:13:47,010
无关紧要我把它扔给我的哈希

373
00:13:47,010 --> 00:13:48,300
函数，它会产生一个

374
00:13:48,300 --> 00:13:52,170
32 位或 64 位哈希唯一哈希值

375
00:13:52,170 --> 00:13:54,240
整数或不唯一，所以我 hash 散列

376
00:13:54,240 --> 00:13:57,360
整数 所以会有这么大的

377
00:13:57,360 --> 00:13:59,130
权衡，以及

378
00:13:59,130 --> 00:14:01,350
我们将在

379
00:14:01,350 --> 00:14:03,720
它的速度和碰撞率之间使用什么样的散列函数，

380
00:14:03,720 --> 00:14:06,270
因为如果我们将不同的键

381
00:14:06,270 --> 00:14:08,760
映射到同一个插槽，那么就会

382
00:14:08,760 --> 00:14:10,110
发生碰撞，现在我们 必须

383
00:14:10,110 --> 00:14:12,870
在我们的散列方案中处理这个问题，所以

384
00:14:12,870 --> 00:14:15,110
我能用它构建的最快的散列函数是什么

385
00:14:15,110 --> 00:14:19,290
，它是 mod 素数甚至

386
00:14:19,290 --> 00:14:25,350
更快，他说值

387
00:14:25,350 --> 00:14:26,459
本身你很接近，但是

388
00:14:26,459 --> 00:14:27,720
如果我有一个字符串，这意味着什么？ 我

389
00:14:27,720 --> 00:14:29,130
回来了 值，然后将它放入我

390
00:14:29,130 --> 00:14:36,270
的插槽中，速度甚至更快

391
00:14:36,270 --> 00:14:40,500
如果它是一个大字符串，他

392
00:14:40,500 --> 00:14:42,709
说 mod 如果有一个 mod nur yes

393
00:14:42,709 --> 00:14:47,070
常量 一个正确的无论

394
00:14:47,070 --> 00:14:48,630
你给我什么键 我都返回第一个

395
00:14:48,630 --> 00:14:50,730
那会 超级快，因为

396
00:14:50,730 --> 00:14:51,959
它会在堆栈上，这

397
00:14:51,959 --> 00:14:53,880
将是不可能的快，但你的

398
00:14:53,880 --> 00:14:56,160
冲突率是因为它总是

399
00:14:56,160 --> 00:14:59,430
进入同一个插槽，所以在频谱的另一端

400
00:14:59,430 --> 00:15:00,660
是完美的哈希函数，

401
00:15:00,660 --> 00:15:01,950
但我说我需要我需要另一个哈希

402
00:15:01,950 --> 00:15:03,810
表 为了使

403
00:15:03,810 --> 00:15:05,010
最坏的情况下工作最大，所以我的碰撞率

404
00:15:05,010 --> 00:15:08,220
是零，但这是最慢的，所以我们

405
00:15:08,220 --> 00:15:12,060
想要中间的东西好吧，

406
00:15:12,060 --> 00:15:13,440
所以下一部分是散列

407
00:15:13,440 --> 00:15:14,940
方案，散列方案本质

408
00:15:14,940 --> 00:15:16,500
上是我们的机制或程序 '

409
00:15:16,500 --> 00:15:18,300
当我们在哈希表中遇到冲突时将使用，

410
00:15:18,300 --> 00:15:20,640


411
00:15:20,640 --> 00:15:23,280
所以再次存在

412
00:15:23,280 --> 00:15:26,370
内存和计算之间的权衡，这

413
00:15:26,370 --> 00:15:27,450
是计算机科学中的经典权衡，

414
00:15:27,450 --> 00:15:30,330
所以如果我分配一个不可能的

415
00:15:30,330 --> 00:15:30,840
l

416
00:15:30,840 --> 00:15:33,450
你知道插槽数组就像你知道 2

417
00:15:33,450 --> 00:15:35,580
到 64 个插槽一样，因为这就是

418
00:15:35,580 --> 00:15:37,650
你在我的机器上拥有它们的所有内存然后

419
00:15:37,650 --> 00:15:38,850
我的碰撞率

420
00:15:38,850 --> 00:15:40,860
几乎为零当然现在我不能

421
00:15:40,860 --> 00:15:42,600
在我的数据库中做任何其他事情，因为

422
00:15:42,600 --> 00:15:43,800
我已经 将我所有的内存都用于我的哈希

423
00:15:43,800 --> 00:15:45,930
表，它几乎没有满，但

424
00:15:45,930 --> 00:15:48,360
如果我

425
00:15:48,360 --> 00:15:50,670
有一个大小为 1 的插槽数组，我的碰撞率会非常惊人，我的清除

426
00:15:50,670 --> 00:15:52,500
率可能会很糟糕

427
00:15:52,500 --> 00:15:54,090
，如果我必须做一堆额外的

428
00:15:54,090 --> 00:15:55,560
指令来处理这些

429
00:15:55,560 --> 00:15:57,990
冲突，但我的存储开销

430
00:15:57,990 --> 00:16:00,420
是最小的，所以我们又

431
00:16:00,420 --> 00:16:01,590
想把它放在中间，我们

432
00:16:01,590 --> 00:16:03,180
想平衡

433
00:16:03,180 --> 00:16:04,470
我们正在使用的内存量或我们

434
00:16:04,470 --> 00:16:06,990
用于哈希表的存储量与额外的

435
00:16:06,990 --> 00:16:08,370


436
00:16:08,370 --> 00:16:12,810
当我们发生冲突时你必须做的指令或授权代码所以

437
00:16:12,810 --> 00:16:15,180
今天我们将再次关注

438
00:16:15,180 --> 00:16:16,620
与发送开始仍然是关于

439
00:16:16,620 --> 00:16:19,260
散列函数只是向你展示

440
00:16:19,260 --> 00:16:20,490
什么是

441
00:16:20,490 --> 00:16:22,220
现代散列前沿 人们是我们

442
00:16:22,220 --> 00:16:23,970
然后我们讨论两种类型的

443
00:16:23,970 --> 00:16:25,230
散列方案，第一种是静态

444
00:16:25,230 --> 00:16:27,180
散列，您可以

445
00:16:27,180 --> 00:16:28,980
估算出

446
00:16:28,980 --> 00:16:31,020
尝试存储密钥集的键的大小，

447
00:16:31,020 --> 00:16:32,400
然后我们将讨论动态散列

448
00:16:32,400 --> 00:16:33,930
在哪里 你可以拥有一个可以增量增长的哈希表，

449
00:16:33,930 --> 00:16:35,640
而不必

450
00:16:35,640 --> 00:16:38,430
再次重新调整所有内容

451
00:16:38,430 --> 00:16:39,870


452
00:16:39,870 --> 00:16:41,670
当人们说我有一个哈希表时，哈希函数和哈希方案的组合是什么意思，

453
00:16:41,670 --> 00:16:45,840
所以

454
00:16:45,840 --> 00:16:47,660
再次哈希函数就是这个

455
00:16:47,660 --> 00:16:49,650
非常快速的函数 我们想要

456
00:16:49,650 --> 00:16:52,410
获取任何任意字节数组或

457
00:16:52,410 --> 00:16:54,780
任意键，然后返回一个

458
00:16:54,780 --> 00:16:57,930
32 位或 64 位整数，所以

459
00:16:57,930 --> 00:17:00,030
任何人都可以命名一个哈希函数，也许

460
00:17:00,030 --> 00:17:01,130
他们在

461
00:17:01,130 --> 00:17:04,800
他说 sha what sha-256 那是一个可以之前使用过

462
00:17:04,800 --> 00:17:09,089
命名另一个 是的 md5 完美

463
00:17:09,089 --> 00:17:10,650
好吧 这实际上是一个很好的例子

464
00:17:10,650 --> 00:17:15,690
所以他说 sha-256 他说 md5 sha-256

465
00:17:15,690 --> 00:17:17,699
是一个加密散列函数，

466
00:17:17,699 --> 00:17:19,740
实际上是可逆的，它是一个公共

467
00:17:19,740 --> 00:17:21,839
公钥/私钥，所以给定一个密钥，

468
00:17:21,839 --> 00:17:23,640
我可以 对它进行散列，然后我知道如何

469
00:17:23,640 --> 00:17:25,319
获取该密钥并反转并

470
00:17:25,319 --> 00:17:26,160
取回原始值，

471
00:17:26,160 --> 00:17:28,650
他说 md5 需要任何任意

472
00:17:28,650 --> 00:17:31,200
键并回退一个 32 个字符的唯一

473
00:17:31,200 --> 00:17:33,900
散列，

474
00:17:33,900 --> 00:17:35,490
它不应该是可逆的，现在是

475
00:17:35,490 --> 00:17:37,290
因为人们破解了它

476
00:17:37,290 --> 00:17:38,660
但这是一种方式 散列

477
00:17:38,660 --> 00:17:41,670
嘶嘶声 可逆散列的嘶嘶声 所以在

478
00:17:41,670 --> 00:17:43,830
我们的数据库系统中，我们不关心

479
00:17:43,830 --> 00:17:45,960
密码学，因为我们正在做

480
00:17:45,960 --> 00:17:48,300
散列表，因为你知道

481
00:17:48,300 --> 00:17:49,620
你可以在存储数据时加密数据

482
00:17:49,620 --> 00:17:51,840
在磁盘或公共云

483
00:17:51,840 --> 00:17:53,670
基础设施上，但是当我们进行

484
00:17:53,670 --> 00:17:56,040
哈希连接或构建哈希表时，

485
00:17:56,040 --> 00:17:57,630
我们不会关心密码学，

486
00:17:57,630 --> 00:17:59,250
我们不会关心

487
00:17:59,250 --> 00:18:01,290
泄漏有关我们密钥的信息，

488
00:18:01,290 --> 00:18:03,150
因为我们只是想 构建这个

489
00:18:03,150 --> 00:18:04,620
你知道的哈希构建我们的哈希提示哈希

490
00:18:04,620 --> 00:18:06,540
数据结构所以我们不会使用

491
00:18:06,540 --> 00:18:08,520
像 sha-256 这样的东西，因为

492
00:18:08,520 --> 00:18:09,929
我们不关心

493
00:18:09,929 --> 00:18:12,120
它提供的密码保证它也非常

494
00:18:12,120 --> 00:18:14,550
慢，所以我们不会我们 它根本 MP

495
00:18:14,550 --> 00:18:17,670
5 是 1 是 60 一个单向散列，这

496
00:18:17,670 --> 00:18:18,990
是我们可以用于散列函数的东西，我们不使用

497
00:18:18,990 --> 00:18:20,940
它，因为它非常

498
00:18:20,940 --> 00:18:22,530
慢，我们会看到

499
00:18:22,530 --> 00:18:23,880
其他更快的，而且它也是一种甜蜜的方式

500
00:18:23,880 --> 00:18:25,140
但是人们有彩虹表来

501
00:18:25,140 --> 00:18:27,450
反转它，所以我们没有

502
00:18:27,450 --> 00:18:29,790
很好的加密保证，

503
00:18:29,790 --> 00:18:31,679
所以我们再次关心

504
00:18:31,679 --> 00:18:34,620
速度快的东西我们关心低

505
00:18:34,620 --> 00:18:39,510
冲突率的东西所以 B 这只是

506
00:18:39,510 --> 00:18:40,860
一些的列表

507
00:18:40,860 --> 00:18:44,250
人们今天使用的散列函数所以

508
00:18:44,250 --> 00:18:46,380
CRC 用于网络世界它

509
00:18:46,380 --> 00:18:49,380
最初是你在 1975 年知道的 Menten 我

510
00:18:49,380 --> 00:18:50,730
不记得当时是 32 位还是

511
00:18:50,730 --> 00:18:51,870
16 位

512
00:18:51,870 --> 00:18:54,090
但现在如果你想使用 CRC 有 一个

513
00:18:54,090 --> 00:18:55,679
64 位版本，你会使用

514
00:18:55,679 --> 00:18:57,090
类似的东西，

515
00:18:57,090 --> 00:19:00,450
所以这将再次产生

516
00:19:00,450 --> 00:19:02,490
具有合理碰撞率的东西，但

517
00:19:02,490 --> 00:19:04,020
它会超级慢，所以我们

518
00:19:04,020 --> 00:19:06,630
实际上没有人这样做，所以

519
00:19:06,630 --> 00:19:08,160
这又是一种杂音哈希。

520
00:19:08,160 --> 00:19:10,320
数据库透视这个

521
00:19:10,320 --> 00:19:12,030
进入现代散列函数的时代

522
00:19:12,030 --> 00:19:13,110
，这些是

523
00:19:13,110 --> 00:19:15,900
我们要关心的，所以杂音散列

524
00:19:15,900 --> 00:19:18,059
在 2008 年问世，只是

525
00:19:18,059 --> 00:19:19,920
互联网上的某个人在 github 上发布了他

526
00:19:19,920 --> 00:19:21,450
的通用散列代码

527
00:19:21,450 --> 00:19:23,429
，然后人们选择了它 然后

528
00:19:23,429 --> 00:19:27,270
开始使用它谷歌然后

529
00:19:27,270 --> 00:19:31,290
在 2010 年初将 murmur hash 修改

530
00:19:31,290 --> 00:19:34,740
为在较短的键上更快，然后

531
00:19:34,740 --> 00:19:36,059
他们发布了一个叫做 City hash 的东西

532
00:19:36,059 --> 00:19:38,580
，然后在 2014 年晚些时候他们

533
00:19:38,580 --> 00:19:40,910
再次修改了这个以拥有农场

534
00:19:40,910 --> 00:19:43,050
哈希 具有比 City 哈希更好的碰撞率，

535
00:19:43,050 --> 00:19:45,810
因此农场哈希 City House

536
00:19:45,810 --> 00:19:47,640
在某些系统中非常普遍，

537
00:19:47,640 --> 00:19:49,650
现在被认为是最

538
00:19:49,650 --> 00:19:51,059
先进的，最快的，并且在今天的

539
00:19:51,059 --> 00:19:53,970
四次哈希冲中具有最佳碰撞

540
00:19:53,970 --> 00:19:56,880
率实际上是 Facebook 的 xx 哈希和

541
00:19:56,880 --> 00:19:59,250
不是原来的 2012 年有一个

542
00:19:59,250 --> 00:20:02,580
xx - 3

543
00:20:02,580 --> 00:20:05,250
现在正在积极开发中，我认为它

544
00:20:05,250 --> 00:20:07,440
是在 2019 年问世的，所以现在这

545
00:20:07,440 --> 00:20:08,640


546
00:20:08,640 --> 00:20:10,200
是所有这些中最快且碰撞率最高的 散列函数，所以如果

547
00:20:10,200 --> 00:20:11,400
你今天正在构建一个数据库系统，

548
00:20:11,400 --> 00:20:15,600
你想使用 xx 散列，所以我们再一次

549
00:20:15,600 --> 00:20:17,309
不太关心它是如何

550
00:20:17,309 --> 00:20:19,710
实现的，我不，这不是一个

551
00:20:19,710 --> 00:20:20,940
我不关心的算法类

552
00:20:20,940 --> 00:20:22,559
内部结构再次是我关心的全部是

553
00:20:22,559 --> 00:20:24,600
它的速度和碰撞

554
00:20:24,600 --> 00:20:25,770
率是多少，有衡量的基准

555
00:20:25,770 --> 00:20:28,500
和碰撞表亲的质量对

556
00:20:28,500 --> 00:20:29,880
所有这些

557
00:20:29,880 --> 00:20:32,640
算法进行评分，所以这是一个基准

558
00:20:32,640 --> 00:20:33,960
微观管理器，就像我每年都运行你

559
00:20:33,960 --> 00:20:35,309
一样 这就像一个

560
00:20:35,309 --> 00:20:37,169
我修改过的开源框架，它

561
00:20:37,169 --> 00:20:39,690
只是增加了你投入散列函数的键的数量

562
00:20:39,690 --> 00:20:41,669
，看看

563
00:20:41,669 --> 00:20:43,770
它实际计算事物的散列的速度有多快，

564
00:20:43,770 --> 00:20:45,660
所以这里我们正在研究

565
00:20:45,660 --> 00:20:47,309
从 1 到 8 密钥大小的字节数，

566
00:20:47,309 --> 00:20:49,650
当

567
00:20:49,650 --> 00:20:51,809
您考虑本质上是 64 位

568
00:20:51,809 --> 00:20:53,460
整数时，它非常小，但您希望这超出

569
00:20:53,460 --> 00:20:56,790
了电子邮件密钥或 URL 的范围，因此

570
00:20:56,790 --> 00:20:59,690
在真正最小的级别上，

571
00:20:59,690 --> 00:21:02,730
CRC 在这里实际上是最快的

572
00:21:02,730 --> 00:21:05,250
但是 当然，当您扩大

573
00:21:05,250 --> 00:21:07,080
农场哈希 City 哈希和 Facebook

574
00:21:07,080 --> 00:21:09,840
访问哈希时，您是否知道变得越来越

575
00:21:09,840 --> 00:21:12,179
好，真正重要的是一个轮子

576
00:21:12,179 --> 00:21:13,950
实际上看起来更大的密钥大小

577
00:21:13,950 --> 00:21:15,809
，就像这样，所以现在您

578
00:21:15,809 --> 00:21:17,910
看到 CRC 哈希糟透了 并且无论

579
00:21:17,910 --> 00:21:19,679
密钥有多大，

580
00:21:19,679 --> 00:21:23,070
吞吐率基本上是相同的，但是您

581
00:21:23,070 --> 00:21:25,559
在这里看到了这些非常好的峰值，分别为

582
00:21:25,559 --> 00:21:28,590
32 字节和 64 字节的字体哈希城市

583
00:21:28,590 --> 00:21:31,049
哈希和 xxxx 哈希三个，

584
00:21:31,049 --> 00:21:34,200
这是因为密钥

585
00:21:34,200 --> 00:21:35,850
他们正在处理他们正在

586
00:21:35,850 --> 00:21:38,220
计算的单个缓存

587
00:21:38,220 --> 00:21:41,850
行中的拟合，所以当我看到您将单次提取到

588
00:21:41,850 --> 00:21:44,549
内存中时，我将 64 字节带入我的

589
00:21:44,549 --> 00:21:47,130
缓存中，我可以对您进行操作，

590
00:21:47,130 --> 00:21:49,140
了解单次提取我' 我对

591
00:21:49,140 --> 00:21:51,480
那个现金现金现金查找中的所有数据进行操作，

592
00:21:51,480 --> 00:21:54,000
所以这就是为什么这里有某种

593
00:21:54,000 --> 00:21:56,040
孤独模式，然后

594
00:21:56,040 --> 00:21:58,140
除此之外我认为在农场哈希上的 64 字节城市

595
00:21:58,140 --> 00:21:59,640
哈希切换到不同的

596
00:21:59,640 --> 00:22:01,030
算法之后，

597
00:22:01,030 --> 00:22:03,910
你就不同了 ee 不同的

598
00:22:03,910 --> 00:22:05,650
属性，而 xx hash 仍然做得

599
00:22:05,650 --> 00:22:08,920
很好，所以我没有在

600
00:22:08,920 --> 00:22:09,850
这里展示碰撞，但是

601
00:22:09,850 --> 00:22:11,470
网上有基准他们可以告诉你，

602
00:22:11,470 --> 00:22:13,480
即使 XS 散列实际上是

603
00:22:13,480 --> 00:22:16,150
这里最快的，它实际上仍然

604
00:22:16,150 --> 00:22:18,310
与碰撞率一样好 作为城市散列

605
00:22:18,310 --> 00:22:21,180
和农场散列，所以在我们自己的系统中，今天

606
00:22:21,180 --> 00:22:23,410
我们尽可能多地使用多余的散列，

607
00:22:23,410 --> 00:22:25,870
所以关于

608
00:22:25,870 --> 00:22:27,630
这种散列函数的任何问题都需要一个

609
00:22:27,630 --> 00:22:44,020
任意的键来回吐一个值是的，他的

610
00:22:44,020 --> 00:22:45,400
陈述是当我不在的时候

611
00:22:45,400 --> 00:22:48,940
之前听说

612
00:22:48,940 --> 00:22:52,900
有人可以给某人提供

613
00:22:52,900 --> 00:22:57,280
数据的方式可能是他们知道

614
00:22:57,280 --> 00:22:59,080
这些值总是会散列到相同的

615
00:22:59,080 --> 00:23:02,310
东西，因此您可能会遇到

616
00:23:02,310 --> 00:23:05,250
潜在的拒绝服务攻击，因为

617
00:23:05,250 --> 00:23:08,980
您正在导致 碰撞

618
00:23:08,980 --> 00:23:10,840
率非常大，

619
00:23:10,840 --> 00:23:12,730
现在运行查询需要更长的时间，

620
00:23:12,730 --> 00:23:15,490
让我们来谈谈这个，所以

621
00:23:15,490 --> 00:23:16,900
至少在数据库世界中，

622
00:23:16,900 --> 00:23:19,540
我们在这里谈论的数据内容是用户

623
00:23:19,540 --> 00:23:22,450
信任的 ed 的意思是我在

624
00:23:22,450 --> 00:23:24,550
自己的商店或我自己的

625
00:23:24,550 --> 00:23:27,190
硬件中运行 Postgres 任何应该让我

626
00:23:27,190 --> 00:23:29,170
访问的人已经打赌我

627
00:23:29,170 --> 00:23:30,340
信任我所以我不会

628
00:23:30,340 --> 00:23:33,580
对你那么恶意也提供了一个种子

629
00:23:33,580 --> 00:23:35,470
当你 做这些散列，这样一个

630
00:23:35,470 --> 00:23:37,300
除非是硬编码的，否则你可能不

631
00:23:37,300 --> 00:23:39,430
知道那是什么，然后

632
00:23:39,430 --> 00:23:40,990
三个你可能会说，如果我在

633
00:23:40,990 --> 00:23:45,760
云系统中怎么办，我知道有人是

634
00:23:45,760 --> 00:23:48,520
恶意的，谷歌

635
00:23:48,520 --> 00:23:50,230
不在乎 或者亚马逊不在乎，因为

636
00:23:50,230 --> 00:23:51,550
你是为硬件买单的人，所以如果

637
00:23:51,550 --> 00:23:53,560
你给我钥匙，然后散列到

638
00:23:53,560 --> 00:23:54,730
同样的东西，你的碰撞率

639
00:23:54,730 --> 00:23:56,560
非常长，现在你的查询需要很

640
00:23:56,560 --> 00:23:58,900
长时间，他们只是在计时

641
00:23:58,900 --> 00:24:02,890
钱所以它不是它不是我确定你

642
00:24:02,890 --> 00:24:04,180
能想到一个方法来做到这一点，但

643
00:24:04,180 --> 00:24:05,740
就我们所说的

644
00:24:05,740 --> 00:24:07,420
而言，我听到的系统方面没有人再次关心

645
00:24:07,420 --> 00:24:09,310
有数据库可以加密

646
00:24:09,310 --> 00:24:12,850
s3 上的静态数据 或 EBS 存储桶

647
00:24:12,850 --> 00:24:16,260
与此完全不同，

648
00:24:16,260 --> 00:24:20,100
有一个 另一个问题，或者现在又好

649
00:24:20,100 --> 00:24:23,590
了 我有配备不稳定的

650
00:24:23,590 --> 00:24:25,750
数据库 我是人们花了

651
00:24:25,750 --> 00:24:26,830
很多钱来担心这些事情

652
00:24:26,830 --> 00:24:28,420
因为数据泄露是一件大事 我

653
00:24:28,420 --> 00:24:30,370
现在不在乎 我的生活

654
00:24:30,370 --> 00:24:32,440
我会明白的 然后他们不在乎，

655
00:24:32,440 --> 00:24:35,200
但现在我不在乎，所以

656
00:24:35,200 --> 00:24:37,299
我们又不是在读散列函数，我们

657
00:24:37,299 --> 00:24:38,620
只需要这三个中的一个，或者

658
00:24:38,620 --> 00:24:40,420
你所知道的一般我们想要

659
00:24:40,420 --> 00:24:44,190
xx 散列，那会很好 够了 好吧

660
00:24:44,190 --> 00:24:45,970
不要写你自己的散列函数 这

661
00:24:45,970 --> 00:24:48,549
不值得你花时间 所以现在让我们

662
00:24:48,549 --> 00:24:50,290
谈谈我们如何

663
00:24:50,290 --> 00:24:52,750
在我们的散列方案中使用我们的散列函数和我们的散列方案

664
00:24:52,750 --> 00:24:55,330
来处理冲突 那么

665
00:24:55,330 --> 00:24:56,410
我们在这里讨论的内容又没有

666
00:24:56,410 --> 00:24:58,330
不管我们使用什么散列函数，

667
00:24:58,330 --> 00:25:00,010
正确的可能是最慢的，想要

668
00:25:00,010 --> 00:25:01,299
成为最快的，

669
00:25:01,299 --> 00:25:03,040
所有这些散列方案仍然可以

670
00:25:03,040 --> 00:25:04,990
正常工作，因为这

671
00:25:04,990 --> 00:25:06,340
就是我们在跳跃后对其进行散列之后要做的事情

672
00:25:06,340 --> 00:25:08,590
到某个位置，现在

673
00:25:08,590 --> 00:25:10,660
我们必须弄清楚如何处理

674
00:25:10,660 --> 00:25:11,950
c  ollisions 或如何找到

675
00:25:11,950 --> 00:25:13,840
我们正在寻找的东西，所以我们要

676
00:25:13,840 --> 00:25:15,520
搜索谈论的是最基本的哈希

677
00:25:15,520 --> 00:25:16,690
表，你可以把它称为线性

678
00:25:16,690 --> 00:25:18,400
探针哈希，然后我们将讨论

679
00:25:18,400 --> 00:25:19,600
一些变体来改进这个

680
00:25:19,600 --> 00:25:21,730
可能被称为 Robinhood 散列和

681
00:25:21,730 --> 00:25:23,890
布谷鸟散列，但它们都大致

682
00:25:23,890 --> 00:25:26,140
基于线性散列，而且

683
00:25:26,140 --> 00:25:27,669
这些都是静态散列方案，

684
00:25:27,669 --> 00:25:29,679
这意味着

685
00:25:29,679 --> 00:25:31,210
当我们分配内存时必须在开始时告诉我们

686
00:25:31,210 --> 00:25:32,980
这里是我期望存储的数字键

687
00:25:32,980 --> 00:25:36,429
，所以 在某些情况下，

688
00:25:36,429 --> 00:25:38,620
您实际上可以猜到这是什么，

689
00:25:38,620 --> 00:25:41,020
所以当我们进行查询处理时，

690
00:25:41,020 --> 00:25:42,250
我们正在使用哈希表进行

691
00:25:42,250 --> 00:25:46,690
连接，我大致知道我希望知道

692
00:25:46,690 --> 00:25:48,160
我将需要多少个键 散列一个

693
00:25:48,160 --> 00:25:49,480
我的哈希表，然后

694
00:25:49,480 --> 00:25:51,700
如果我们的哈希表太

695
00:25:51,700 --> 00:25:53,470
满，我可以相应地分配，我们将看到这意味着什么

696
00:25:53,470 --> 00:25:55,299
本质上意味着我们有一个无限

697
00:25:55,299 --> 00:25:58,090
循环或我们所有的插槽都被填满了那么

698
00:25:58,090 --> 00:26:01,480
这意味着我们必须加倍我们

699
00:26:01,480 --> 00:26:02,590
必须 增加尺寸 并且

700
00:26:02,590 --> 00:26:03,970
基本上将哈希表的大小加倍

701
00:26:03,970 --> 00:26:06,040
，然后基本上

702
00:26:06,040 --> 00:26:08,140
将第一个哈希表中的所有键

703
00:26:08,140 --> 00:26:09,760
复制到第二个哈希表中，这

704
00:26:09,760 --> 00:26:12,480
显然是非常昂贵的，

705
00:26:12,480 --> 00:26:14,710
理想情况下我们可以很好地

706
00:26:14,710 --> 00:26:17,440
近似你知道什么 上限是

707
00:26:17,440 --> 00:26:19,179
我们保持哈希表大小的上限，

708
00:26:19,179 --> 00:26:21,549
这样我们就不必这样做来进行

709
00:26:21,549 --> 00:26:25,330
重新生长或重建，

710
00:26:25,330 --> 00:26:27,280
所以再次线性探针哈希有时

711
00:26:27,280 --> 00:26:28,390
称为

712
00:26:28,390 --> 00:26:30,370
寻址，这是

713
00:26:30,370 --> 00:26:32,770
您可以拥有的最基本的哈希表

714
00:26:32,770 --> 00:26:36,430
它只是一个巨大的插槽表，

715
00:26:36,430 --> 00:26:38,650
我们重用我们的哈希函数来跳转到

716
00:26:38,650 --> 00:26:41,080
某个偏移量或在该表中添加一些插槽，

717
00:26:41,080 --> 00:26:44,050
所以如果你使用 Python

718
00:26:44,050 --> 00:26:46,150
并分配一个字典，这

719
00:26:46,150 --> 00:26:47,380
本质上是相同的数据结构

720
00:26:47,380 --> 00:26:48,280
你会在

721
00:26:48,280 --> 00:26:49,660
字典下面它会是一个线性探针

722
00:26:49,660 --> 00:26:52,720


723
00:26:52,720 --> 00:26:54,580
散列表所以我们解决冲突的方式是如果我们散列

724
00:26:54,580 --> 00:26:56,590
到一个插槽中并且我们找到

725
00:26:56,590 --> 00:26:59,110
已经存在的东西我试图插入一些

726
00:26:59,110 --> 00:27:01,450
东西 在那里，我们只是继续

727
00:27:01,450 --> 00:27:04,000
向下扫描到下一个位置并继续前进，

728
00:27:04,000 --> 00:27:06,100
直到找到第一个打开的插槽，

729
00:27:06,100 --> 00:27:09,010
然后在那里插入

730
00:27:09,010 --> 00:27:11,320
我们要添加的条目，所以现在当我

731
00:27:11,320 --> 00:27:13,720
想要进行查找时，我会登陆

732
00:27:13,720 --> 00:27:15,130
我应该在的插槽，我

733
00:27:15,130 --> 00:27:16,870
一直向下扫描，直到我找到一个

734
00:27:16,870 --> 00:27:18,640
空插槽，这意味着

735
00:27:18,640 --> 00:27:20,710
我要找的东西不存在，或者我找到了

736
00:27:20,710 --> 00:27:23,380
我正在寻找的东西，

737
00:27:23,380 --> 00:27:24,700
这是非常基本的，非常

738
00:27:24,700 --> 00:27:26,980
简单。 对了，所以

739
00:27:26,980 --> 00:27:28,150
让我们说这些是我们

740
00:27:28,150 --> 00:27:29,920
想要添加的键，好吧，我们有一些

741
00:27:29,920 --> 00:27:31,690
散列函数，它将获取这些

742
00:27:31,690 --> 00:27:34,300
键并将它们映射到我们的插槽

743
00:27:34,300 --> 00:27:35,980
到我们散列表中的插槽，所以这

744
00:27:35,980 --> 00:27:38,050
第一个我们散列一个那个 它在这里

745
00:27:38,050 --> 00:27:39,820
又一次落在这个东西里面它是一个

746
00:27:39,820 --> 00:27:42,010
键值对我们有我们插入的原始键

747
00:27:42,010 --> 00:27:44,560
加上

748
00:27:44,560 --> 00:27:45,910
我们想要的任何值所以它是一个

749
00:27:45,910 --> 00:27:47,080
指向另一个元组的指针将翻

750
00:27:47,080 --> 00:27:48,850
另一页或者你知道一些其他的

751
00:27:48,850 --> 00:27:51,610
任意值 它没有 重要的

752
00:27:51,610 --> 00:27:53,590
是我们必须存储

753
00:27:53,590 --> 00:27:55,540
原始键的原因，因为当我们开始

754
00:27:55,540 --> 00:27:57,720
查找并且必须向下扫描时，

755
00:27:57,720 --> 00:27:59,710
您知道开始查看多个

756
00:27:59,710 --> 00:28:01,450
条目我们需要知道

757
00:28:01,450 --> 00:28:02,500
我们实际要查找的内容是否

758
00:28:02,500 --> 00:28:04,120
在插槽中 我们真正想要的密钥，

759
00:28:04,120 --> 00:28:05,980
因为它并不总是保证

760
00:28:05,980 --> 00:28:09,580
正好是我们散列到表中的位置，所以

761
00:28:09,580 --> 00:28:12,460
如果我们现在散列 BB 土地，我们散列

762
00:28:12,460 --> 00:28:15,550
cc/e 土地，但是 a 再次占据

763
00:28:15,550 --> 00:28:19,030
了它想要去的位置，所以所有

764
00:28:19,030 --> 00:28:20,560
我们所做的就是跳到下一个

765
00:28:20,560 --> 00:28:22,600
位置，然后

766
00:28:22,600 --> 00:28:26,530
一旦我们越过 c 就将我们的条目插入到同样的东西

767
00:28:26,530 --> 00:28:28,270


768
00:28:28,270 --> 00:28:29,980


769
00:28:29,980 --> 00:28:32,110
中 翻过 C 不能翻过 D 所以

770
00:28:32,110 --> 00:28:35,140
它在这里结束，最后一个 F

771
00:28:35,140 --> 00:28:38,950
在这里非常直板

772
00:28:38,950 --> 00:28:41,140
，这实际上做起来真的很快

773
00:28:41,140 --> 00:28:42,430
我没有在这里显示页面之间的划分，

774
00:28:42,430 --> 00:28:43,930
但你只是认为 这

775
00:28:43,930 --> 00:28:45,910
就像我分配了一堆页面

776
00:28:45,910 --> 00:28:49,450
，我知道如何从一个位置开始

777
00:28:49,450 --> 00:28:50,830
我知道如果我

778
00:28:50,830 --> 00:28:53,320
在我的页面的最后一个插槽中，我知道

779
00:28:53,320 --> 00:28:55,630
下一页将跳转到什么以继续

780
00:28:55,630 --> 00:29:07,210
搜索是是是是因为这是一个

781
00:29:07,210 --> 00:29:07,840
循环缓冲区

782
00:29:07,840 --> 00:29:09,700
所以如果我看到他的问题是说我

783
00:29:09,700 --> 00:29:12,730
想要搜索 G & G 一个塞哥维亚的不能 所以

784
00:29:12,730 --> 00:29:14,650
它去这里 它不能去那里 它

785
00:29:14,650 --> 00:29:17,910
循环并继续在这里

786
00:29:17,910 --> 00:29:27,580
是的 是的 问题是如果我删除

787
00:29:27,580 --> 00:29:30,160
下一张幻灯片的价值繁荣会怎么样 很好

788
00:29:30,160 --> 00:29:32,820
所以让我们说 我们想删除，看看

789
00:29:32,820 --> 00:29:36,310
我们再次做什么我们用土地散列它，

790
00:29:36,310 --> 00:29:37,960
其中 a 不是我们再次赢得的，

791
00:29:37,960 --> 00:29:39,820
因为现在我们这就是为什么我们

792
00:29:39,820 --> 00:29:41,680
在那里有确切的键，所以你可以说 a

793
00:29:41,680 --> 00:29:43,060
不等于看到这是 不是我想要的

794
00:29:43,060 --> 00:29:45,250
扫描啊 C 等于 C 那是我

795
00:29:45,250 --> 00:29:48,250
想要的这是我想要删除的所以

796
00:29:48,250 --> 00:29:49,780
假设我只是做一些非常

797
00:29:49,780 --> 00:29:53,440
简单的事情然后删除它到底

798
00:29:53,440 --> 00:29:59,350
有什么问题我

799
00:29:59,350 --> 00:30:02,950
在此处查找 DI 查看 我看到空槽，

800
00:30:02,950 --> 00:30:04,840
这是我认为好的，我的搜索已经

801
00:30:04,840 --> 00:30:05,710
完成，这不是我想要的，即使

802
00:30:05,710 --> 00:30:09,310
它是 下一个槽向下，所以有两种

803
00:30:09,310 --> 00:30:12,250
方法来处理删除，所以第一种

804
00:30:12,250 --> 00:30:14,650
是你只需添加一个墓碑标记，你

805
00:30:14,650 --> 00:30:16,300
基本上可以在 C 过去

806
00:30:16,300 --> 00:30:17,590
只是一个小墓碑，上面写着

807
00:30:17,590 --> 00:30:19,690
没有条目 这里没有

808
00:30:19,690 --> 00:30:22,330
逻辑条目，但实际

809
00:30:22,330 --> 00:30:25,570
考虑这一点 离开这个插槽被占用，所以

810
00:30:25,570 --> 00:30:27,670
我做一个查找，然后我降落在这里我

811
00:30:27,670 --> 00:30:30,280
说这里没有数据，但它

812
00:30:30,280 --> 00:30:32,080
不是真正的空插槽让我

813
00:30:32,080 --> 00:30:33,430
跳到下一个，这

814
00:30:33,430 --> 00:30:36,700
就是我想要的东西当然有什么

815
00:30:36,700 --> 00:30:39,910
问题 现在我们是你知道

816
00:30:39,910 --> 00:30:42,310
我们正在浪费空间你知道我们

817
00:30:42,310 --> 00:30:45,040
最终必须清理它所以

818
00:30:45,040 --> 00:30:46,210
这将有助于我们的填充

819
00:30:46,210 --> 00:30:49,090
因子另一个选项是进行数据

820
00:30:49,090 --> 00:30:50,770
移动本质上认识到我

821
00:30:50,770 --> 00:30:53,320
在这里有一个空槽并且 把

822
00:30:53,320 --> 00:30:54,970
每个人都往上移

823
00:30:54,970 --> 00:30:58,930
一个然后那样我和

824
00:30:58,930 --> 00:31:01,600
我现在想要去的地方在这个例子中

825
00:31:01,600 --> 00:31:04,390
这是很好的因为 II

826
00:31:04,390 --> 00:31:06,100
精确地映射到它可以找到的位置

827
00:31:06,100 --> 00:31:07,750
F 映射到它可以找到的位置

828
00:31:07,750 --> 00:31:09,100
但是再次 记得我说过它是一个

829
00:31:09,100 --> 00:31:13,750
循环缓冲区，所以技术上 B 可能

830
00:31:13,750 --> 00:31:16,840
真的想去这里，因为

831
00:31:16,840 --> 00:31:19,510
它在技术上是在 F 之后，

832
00:31:19,510 --> 00:31:22,690
即使物理上不是，所以在这种

833
00:31:22,690 --> 00:31:24,910
情况下，如果我最终移动 B，

834
00:31:24,910 --> 00:31:26,410
这会很糟糕 会是

835
00:31:26,410 --> 00:31:30,040
不正确的，因为 B 在那个

836
00:31:30,040 --> 00:31:33,340
位置散列所以如果我把它移到这里我

837
00:31:33,340 --> 00:31:35,190
会做一个查找和 B 并没有找到

838
00:31:35,190 --> 00:31:37,990
因为当我向下扫描时我沿着

839
00:31:37,990 --> 00:31:39,400
这个方向我不知道

840
00:31:39,400 --> 00:31:40,360
回过头来看看 上一个

841
00:31:40,360 --> 00:31:44,980
条目，所以在实践中，我们大多

842
00:31:44,980 --> 00:31:48,220
只做墓碑，因为这个数据

843
00:31:48,220 --> 00:31:49,420
移动的事情实际上很复杂

844
00:31:49,420 --> 00:31:50,890
还有另一个很好的例子，说明为什么你

845
00:31:50,890 --> 00:31:52,060
想要在这里拥有原始密钥，

846
00:31:52,060 --> 00:31:53,950
因为为了弄清楚

847
00:31:53,950 --> 00:31:55,720
我是否可以移动 这一点

848
00:31:55,720 --> 00:31:57,730
我需要去散列并决定

849
00:31:57,730 --> 00:31:59,500
它应该位于的位置

850
00:31:59,500 --> 00:32:03,940
是否小于或高于

851
00:32:03,940 --> 00:32:06,340
我想要移动它的位置，因为如果我

852
00:32:06,340 --> 00:32:10,240
现在超过它，那么我会得到错误

853
00:32:10,240 --> 00:32:11,680
帽子会有负面影响 如果

854
00:32:11,680 --> 00:32:19,440
我正在构建一个临时数据结构来进行查询，那么对于

855
00:32:19,440 --> 00:32:22,150
某些操作或

856
00:32:22,150 --> 00:32:23,440
我们数据库系统中哈希表的某些实例，

857
00:32:23,440 --> 00:32:25,530
我们根本不必再担心删除

858
00:32:25,530 --> 00:32:27,700


859
00:32:27,700 --> 00:32:29,860
一个我不会删除的查询，

860
00:32:29,860 --> 00:32:31,450
所以我只是要扫描我的

861
00:32:31,450 --> 00:32:33,130
输入数据填充我的哈希表，

862
00:32:33,130 --> 00:32:35,290
然后开始使用它，如果您将其用作

863
00:32:35,290 --> 00:32:37,300
哈希索引，那么我们可能会

864
00:32:37,300 --> 00:32:39,310
删除，我们必须考虑到这一点

865
00:32:39,310 --> 00:32:41,230
和 墓碑可能是最

866
00:32:41,230 --> 00:32:45,480
简单的方法，是的，

867
00:32:53,580 --> 00:32:57,790
是的，所以他的声明是他说

868
00:32:57,790 --> 00:32:59,410
移动可能是处理这个问题的最糟糕的方法，

869
00:32:59,410 --> 00:33:01,840
因为我不能再说一遍

870
00:33:01,840 --> 00:33:06,820
我不能移动东西我在上面为什么

871
00:33:06,820 --> 00:33:15,160
不但是 没关系所以如果你

872
00:33:15,160 --> 00:33:18,420
在我们第一次开始时回到这里是

873
00:33:20,430 --> 00:33:23,440
正确的所以正确不一定

874
00:33:23,440 --> 00:33:26,590
正确所以所以F想去这里但他在

875
00:33:26,590 --> 00:33:27,880
那里所以可以将其向上移动

876
00:33:27,880 --> 00:33:31,840
一个他想要去这里但我可以'  t 所以

877
00:33:31,840 --> 00:33:33,490
我可以向上移动一个

878
00:33:33,490 --> 00:33:34,990
然后 D 想要

879
00:33:34,990 --> 00:33:35,680
像 o 一样不能尖叫移动到这里

880
00:33:35,680 --> 00:33:37,960
所以我的玩具示例在这里

881
00:33:37,960 --> 00:33:39,810
对我来说将每个人向上移动一个是完全安全的，

882
00:33:39,810 --> 00:33:42,460
但我要说明的

883
00:33:42,460 --> 00:33:43,810
一点是我们实际上不能移动

884
00:33:43,810 --> 00:33:46,120
B 因为 b 实际上想要孵化到

885
00:33:46,120 --> 00:33:48,220
那里基本上它在逻辑上不是连续的

886
00:33:48,220 --> 00:33:49,900
所以我应该不得不

887
00:33:49,900 --> 00:33:51,760
把它移到这里，但正如你所说的，我

888
00:33:51,760 --> 00:33:53,770
必须把它散列检查一下，哦，

889
00:33:53,770 --> 00:33:55,900
在这种情况下，我把它移到这里是否安全，

890
00:33:55,900 --> 00:33:57,580
不，因为散列实际上想要

891
00:33:57,580 --> 00:34:00,010
去那里 我一个一个地往下

892
00:34:00,010 --> 00:34:01,450
我不得不说我可以把它

893
00:34:01,450 --> 00:34:22,120
向上移动是的 是的 是的 问题是

894
00:34:22,120 --> 00:34:25,600
针对超级相似的例子这里的鼠标

895
00:34:25,600 --> 00:34:27,370
有点你知道我只有六个键 我

896
00:34:27,370 --> 00:34:29,020
可以估计是什么键

897
00:34:29,020 --> 00:34:31,719
插槽我在实践中需要你如何

898
00:34:31,719 --> 00:34:33,250
实际估计你

899
00:34:33,250 --> 00:34:36,040
在实践中需要多少个插槽它的 2n 你必须 n

900
00:34:36,040 --> 00:34:37,420
你结束的键数量的插槽

901
00:34:37,420 --> 00:34:38,590
和标记更容易

902
00:34:38,590 --> 00:34:41,110
你没有放入它好吧，我们会

903
00:34:41,110 --> 00:34:44,020
在布谷鸟散列中看到它略有

904
00:34:44,020 --> 00:34:44,889
不同，因为它们有两个散

905
00:34:44,889 --> 00:34:47,469
列表 b  ut 它练习到 N 然后

906
00:34:47,469 --> 00:34:49,150
发生的事情是当你达到

907
00:34:49,150 --> 00:34:51,040
四个时，现在当你调整大小时填充你

908
00:34:51,040 --> 00:34:53,070
的插槽数量

909
00:34:53,070 --> 00:34:57,369
你增加了两个是

910
00:34:57,369 --> 00:35:01,150
的你也可以像跟踪

911
00:35:01,150 --> 00:35:11,049
船只的数量一样好吗 所以这是

912
00:35:11,049 --> 00:35:14,079
哈曼，你们是惊人的

913
00:35:14,079 --> 00:35:16,359
片段，他说不能我也

914
00:35:16,359 --> 00:35:18,549
只记录位置，知道

915
00:35:18,549 --> 00:35:19,869
我离我原来的

916
00:35:19,869 --> 00:35:21,220
位置有多少步，并用它来确定

917
00:35:21,220 --> 00:35:23,980
是否让我移动它是的，

918
00:35:23,980 --> 00:35:25,599
这称为罗宾汉哈希 但是我们稍后

919
00:35:25,599 --> 00:35:28,510


920
00:35:28,510 --> 00:35:31,150
会谈到这个好东西我现在也想谈论

921
00:35:31,150 --> 00:35:32,440
唯一键然后我们将

922
00:35:32,440 --> 00:35:35,740
讨论他关于罗宾汉散列的观点

923
00:35:35,740 --> 00:35:37,569
所以在你的专辑课上你可能会

924
00:35:37,569 --> 00:35:39,970
在你讨论散列时 你只是

925
00:35:39,970 --> 00:35:42,190
假设所有的键对于主索引都是唯一的，

926
00:35:42,190 --> 00:35:43,839
这很好，但

927
00:35:43,839 --> 00:35:46,180
在实际真实真实的真实数据

928
00:35:46,180 --> 00:35:48,220
集中，我们不能假设键是

929
00:35:48,220 --> 00:35:49,599
唯一的，所以现在我们需要它会

930
00:35:49,599 --> 00:35:51,609
在我们的哈希表中处理它们，所以有 有两种方法可以

931
00:35:51,609 --> 00:35:53,019
做到这一点 我要说的是，我所描述的两种方法

932
00:35:53,019 --> 00:35:54,609
可用于

933
00:35:54,609 --> 00:35:55,599
我们今天讨论的任何散列方案，

934
00:35:55,599 --> 00:35:58,180
它们并不特定于

935
00:35:58,180 --> 00:35:59,380
线性散列，您可以将它们用于

936
00:35:59,380 --> 00:36:01,599
任何事情，因此第一种方法就是

937
00:36:01,599 --> 00:36:03,220
您 维护一个包含所有值的单独链表，

938
00:36:03,220 --> 00:36:06,069
这样您就

939
00:36:06,069 --> 00:36:08,950
可以在您的插槽中的任何哈希表中说出您的键

940
00:36:08,950 --> 00:36:11,140
，然后设置

941
00:36:11,140 --> 00:36:13,599
指向底层元组，无论

942
00:36:13,599 --> 00:36:14,589
应该指向它的东西，

943
00:36:14,589 --> 00:36:18,130
而不是指向单独的链接

944
00:36:18,130 --> 00:36:20,440
列表中的值

945
00:36:20,440 --> 00:36:21,700
当然会让人头晕目眩 我将拥有

946
00:36:21,700 --> 00:36:24,640
相同的键，所以如果我想说给我

947
00:36:24,640 --> 00:36:27,819
所有给我所有的键值对给我 XYZ 键的所有键值对，

948
00:36:27,819 --> 00:36:30,970
我只是

949
00:36:30,970 --> 00:36:32,200
沿着这个指针跳转，然后 我知道

950
00:36:32,200 --> 00:36:35,710
里面的所有东西都有那个键，

951
00:36:35,710 --> 00:36:36,880
另一种方法可能是

952
00:36:36,880 --> 00:36:38,079
最常见的方法就是存储

953
00:36:38,079 --> 00:36:40,839
冗余键，所以你现在所做的只是

954
00:36:40,839 --> 00:36:43,000
在你的插槽阵列中，你

955
00:36:43,000 --> 00:36:44,890
只是一遍又一遍地复制键

956
00:36:44,890 --> 00:36:47,980
没错 键 XYZ ABC 出现

957
00:36:47,980 --> 00:36:49,420
多次，每个都有一个独特的

958
00:36:49,420 --> 00:36:50,859
值，我只是多次记录

959
00:36:50,859 --> 00:36:52,869
，然后填充探测

960
00:36:52,869 --> 00:36:54,430
一切仍然有效，你知道

961
00:36:54,430 --> 00:36:58,329
我是否在寻找某些东西，我进行查找

962
00:36:58,329 --> 00:36:59,859
，我只是继续扫描 直到我

963
00:36:59,859 --> 00:37:01,859
找到空插槽或那个东西，

964
00:37:01,859 --> 00:37:04,690
或者我找到了 em 插槽，但我知道我的

965
00:37:04,690 --> 00:37:07,210
搜索已经完成，所以如果我说找到我

966
00:37:07,210 --> 00:37:10,280
一个键事件与 Elif 键值键

967
00:37:10,280 --> 00:37:12,200
等于 XYZ 我可以跳到这里并

968
00:37:12,200 --> 00:37:13,970
准确地找到 我想要什么，但如果我

969
00:37:13,970 --> 00:37:15,560
全力以赴，我必须继续向下扫描，

970
00:37:15,560 --> 00:37:18,860
直到我在实践中再次碰到一个空插槽

971
00:37:18,860 --> 00:37:21,740
每个人都做第二

972
00:37:21,740 --> 00:37:24,130
个，即使它是你知道

973
00:37:24,130 --> 00:37:26,150
稍微浪费存储因为你

974
00:37:26,150 --> 00:37:27,560
多次重复密钥在哪里

975
00:37:27,560 --> 00:37:29,150
是不是最重要的，你只存储

976
00:37:29,150 --> 00:37:32,300
一次密钥，所以让我们

977
00:37:32,300 --> 00:37:34,250
谈谈他打算做什么，

978
00:37:34,250 --> 00:37:36,470
但我们希望以稍微不同的方式看待这一点，

979
00:37:36,470 --> 00:37:38,690
而不是决定

980
00:37:38,690 --> 00:37:41,420
何时转移它，而不是

981
00:37:41,420 --> 00:37:43,550
决定如何 到米 ove 批量移动

982
00:37:43,550 --> 00:37:45,800
他们通过我们的哈希表批量移动密钥

983
00:37:45,800 --> 00:37:47,510
让我们看看如何使用

984
00:37:47,510 --> 00:37:50,530
这些位置来移动单个密钥

985
00:37:50,530 --> 00:37:54,380
所以 Robin Hood 哈希是在 1985 年提出的，

986
00:37:54,380 --> 00:37:57,380
它是那些发表的论文

987
00:37:57,380 --> 00:37:58,700
之一，没有人真正关注

988
00:37:58,700 --> 00:38:00,830
然后在过去十年左右的时间里，它

989
00:38:00,830 --> 00:38:02,120
在黑客新闻上出现了几次

990
00:38:02,120 --> 00:38:04,610
，现在人们正在尝试

991
00:38:04,610 --> 00:38:08,630
不同的系统，所以罗宾汉又是

992
00:38:08,630 --> 00:38:10,820
这个来自英格兰的民间传说，关于

993
00:38:10,820 --> 00:38:13,160
这个流氓，他会从富人那里窃取

994
00:38:13,160 --> 00:38:14,900
并提供它

995
00:38:14,900 --> 00:38:17,240
对中世纪英格兰的穷人来说，

996
00:38:17,240 --> 00:38:18,350
这基本上就是

997
00:38:18,350 --> 00:38:19,370
我们在哈希表中

998
00:38:19,370 --> 00:38:22,460
所做的

999
00:38:22,460 --> 00:38:24,770


1000
00:38:24,770 --> 00:38:26,990


1001
00:38:26,990 --> 00:38:28,550
事情 从

1002
00:38:28,550 --> 00:38:30,830
你第一次散列到散列表时你应该

1003
00:38:30,830 --> 00:38:33,070
去的地方做这个基本的想法是

1004
00:38:33,070 --> 00:38:35,690
我们试图平衡

1005
00:38:35,690 --> 00:38:38,570
整个散列表以最小

1006
00:38:38,570 --> 00:38:40,670
化我们h的可能性 有一个键

1007
00:38:40,670 --> 00:38:42,020
离它应该在的位置真的很远，

1008
00:38:42,020 --> 00:38:44,510
所以我们总体上

1009
00:38:44,510 --> 00:38:47,600
是平衡的，每个人都是平等的，

1010
00:38:47,600 --> 00:38:49,190
所以让我们再说一遍，我们想

1011
00:38:49,190 --> 00:38:51,740
对这六个键进行排序，

1012
00:38:51,740 --> 00:38:54,140
但现在正如他建议我们的那样

1013
00:38:54,140 --> 00:38:55,760
Cannell 还存储了

1014
00:38:55,760 --> 00:38:57,740


1015
00:38:57,740 --> 00:39:00,380
他第一次散列到这个位置时我们从原始位置跳的次数，所以我们的

1016
00:39:00,380 --> 00:39:02,240
表一开始是空的，所以当

1017
00:39:02,240 --> 00:39:04,400
我们散列 a 时，它到达这个位置，

1018
00:39:04,400 --> 00:39:05,540
它正是应该在的位置，

1019
00:39:05,540 --> 00:39:08,210
所以我们 说这是它的数字

1020
00:39:08,210 --> 00:39:08,960
跳跃为零

1021
00:39:08,960 --> 00:39:12,550
与 BB 哈希相同的事情它落在

1022
00:39:12,550 --> 00:39:15,550
顶部 所以它的位置为零

1023
00:39:15,550 --> 00:39:20,570
所以现在我们插入 C 并且 a 占据了

1024
00:39:20,570 --> 00:39:23,360
它想要去的位置 但

1025
00:39:23,360 --> 00:39:24,880
一

1026
00:39:24,880 --> 00:39:27,470
开始数字跳跃 a 从它的

1027
00:39:27,470 --> 00:39:29,180
最佳位置开始是 0 并且在

1028
00:39:29,180 --> 00:39:31,310
开始时 C 降落在这里所以此时

1029
00:39:31,310 --> 00:39:33,020
C 的插槽数量 C

1030
00:39:33,020 --> 00:39:34,610
来自它想要去的地方的数量是 0

1031
00:39:34,610 --> 00:39:37,220
因为 0 等于 0 我们要留下一个

1032
00:39:37,220 --> 00:39:39,710
C 下到下一个

1033
00:39:39,710 --> 00:39:41,840
槽 现在我们看到我们

1034
00:39:41,840 --> 00:39:44,420
将它的位置计数器更新为

1035
00:39:44,420 --> 00:39:46,190
一步，所以它离它第一次孵化到桌子时应该在的位置只有一步，

1036
00:39:46,190 --> 00:39:47,570


1037
00:39:47,570 --> 00:39:51,410
所以现在我们用 DD 土地来做这个，

1038
00:39:51,410 --> 00:39:54,650
他想进入这个位置

1039
00:39:54,650 --> 00:39:58,430
但是 C 占据了它，但是 C 的计数器是 1

1040
00:39:58,430 --> 00:40:02,270
并且 1 大于 0 所以更高的

1041
00:40:02,270 --> 00:40:03,560
计数器意味着你更穷我的意思是

1042
00:40:03,560 --> 00:40:04,940
你离你想去的地方更远，

1043
00:40:04,940 --> 00:40:07,640
所以 C 会

1044
00:40:07,640 --> 00:40:09,020
离它的位置更远

1045
00:40:09,020 --> 00:40:10,790
想去 D 会去的地方，如果 D 占据这个位置，

1046
00:40:10,790 --> 00:40:13,670
所以我们不让 D 占据这个位置，我们

1047
00:40:13,670 --> 00:40:17,330
让它下降到这里，所以现在我看 1

1048
00:40:17,330 --> 00:40:19,970
或 e 我们以前开始过一次，或者 a 又是

1049
00:40:19,970 --> 00:40:23,390
0 等于 0 所以 我们留下一个 1

1050
00:40:23,390 --> 00:40:26,180
等于 1 所以我们留下 C 但现在

1051
00:40:26,180 --> 00:40:29,390
缓和计数器是 2 因为这是你

1052
00:40:29,390 --> 00:40:31,640
知道的 0 1 2 跳离它

1053
00:40:31,640 --> 00:40:35,210
想去的地方所以 2 小于 Suze

1054
00:40:35,210 --> 00:40:37,940
大于然后 1 所以 2 被认为

1055
00:40:37,940 --> 00:40:42,320
更差 比 D 所以它在头部射击 D

1056
00:40:42,320 --> 00:40:44,030
偷它的钱包 偷它的

1057
00:40:44,030 --> 00:40:46,850
插槽 在这里插入自己 然后

1058
00:40:46,850 --> 00:40:48,350
现在插入 c 继续

1059
00:40:48,350 --> 00:40:49,700
到这里，现在我们将它的

1060
00:40:49,700 --> 00:40:53,330
计数器更新为 2，所以在我们拥有它之前，我们已经

1061
00:40:53,330 --> 00:40:57,710
有了 acde 但现在在 Robin

1062
00:40:57,710 --> 00:41:00,200
Hood 散列上，现在更接近它

1063
00:41:00,200 --> 00:41:03,230
想要的位置，而 D 是最远的

1064
00:41:03,230 --> 00:41:04,730
方式 应该是因为

1065
00:41:04,730 --> 00:41:07,960
现在和现在总体上我们更加平衡了

1066
00:41:07,960 --> 00:41:12,860
同样的事情，其中 ff/a 在这里 2 是 2

1067
00:41:12,860 --> 00:41:15,170
大于 0 所以 D 停留在它

1068
00:41:15,170 --> 00:41:20,140
想要去的地方而 F 在这里下降实际上是的，

1069
00:41:24,970 --> 00:41:27,800
声明在一个 罗宾汉

1070
00:41:27,800 --> 00:41:31,040
孵化算法说，

1071
00:41:31,040 --> 00:41:35,090
最好让两个键

1072
00:41:35,090 --> 00:41:36,170
与它们应该在的位置相距一个位置，

1073
00:41:36,170 --> 00:41:38,270
而不是让一个键在

1074
00:41:38,270 --> 00:41:39,859
两个位置，一个键在零

1075
00:41:39,859 --> 00:41:42,770
位置是的，我不是说这是

1076
00:41:42,770 --> 00:41:43,609
正确的

1077
00:41:43,609 --> 00:41:44,810
我是说这是

1078
00:41:44,810 --> 00:41:48,290
一种以不同方式处理冲突的方法，

1079
00:41:48,290 --> 00:41:51,140
我的意思是你本质上是在

1080
00:41:51,140 --> 00:41:54,050
权衡资源权，所以现在当我想对这些人中的

1081
00:41:54,050 --> 00:41:55,310
任何一个进行查找时，

1082
00:41:55,310 --> 00:41:58,849
好的任何这些 钥匙它

1083
00:41:58,849 --> 00:42:00,320
没有什么 一把钥匙会一直

1084
00:42:00,320 --> 00:42:01,369
是你知道的 一路环绕，

1085
00:42:01,369 --> 00:42:03,530
每个人平均都会有

1086
00:42:03,530 --> 00:42:07,940
相同的距离，但为了做到这一点，

1087
00:42:07,940 --> 00:42:10,099
这会使版权变得更加昂贵或

1088
00:42:10,099 --> 00:42:11,750
插入更加昂贵，因为现在我必须

1089
00:42:11,750 --> 00:42:14,180
写更多的东西，所以当我在这里偷东西时

1090
00:42:14,180 --> 00:42:16,460
，让我们说我必须

1091
00:42:16,460 --> 00:42:19,400
正确更新此页面，这里有一个页面

1092
00:42:19,400 --> 00:42:21,680
拆分，因此我

1093
00:42:21,680 --> 00:42:24,590
在第一页上更新此插槽以安装 e，

1094
00:42:24,590 --> 00:42:26,450
这是正确的，然后现在我必须

1095
00:42:26,450 --> 00:42:28,550
到这里并执行另一个正确的操作以

1096
00:42:28,550 --> 00:42:31,280
将 D 插入此页面，如果我离开了他

1097
00:42:31,280 --> 00:42:33,140
单独像在常规线性探针

1098
00:42:33,140 --> 00:42:34,880
散列中一样，我只是不想要一个

1099
00:42:34,880 --> 00:42:37,520
页面的权利，所以这

1100
00:42:37,520 --> 00:42:39,619
似乎是一个非常好的想法

1101
00:42:39,619 --> 00:42:40,910
至少现代研究

1102
00:42:40,910 --> 00:42:42,920
表明，特别是对于内存数据

1103
00:42:42,920 --> 00:42:44,420
结构，你

1104
00:42:44,420 --> 00:42:45,859
为分支错误预测支付巨额罚款，

1105
00:42:45,859 --> 00:42:47,570
因为您有更多条件来进行

1106
00:42:47,570 --> 00:42:48,560
这些检查，以查看是否

1107
00:42:48,560 --> 00:42:50,480
应该从另一个检查中获取它，并且您正在

1108
00:42:50,480 --> 00:42:51,619
做更多的权利，这更多的是缓存

1109
00:42:51,619 --> 00:42:53,690
失效，所以在实践中 lin 耳朵

1110
00:42:53,690 --> 00:42:56,510
探测压碎了一切仍然它

1111
00:42:56,510 --> 00:42:58,880
仍然是最快的方法我认为

1112
00:42:58,880 --> 00:43:04,540
我们是磁盘它是同一件事

1113
00:43:04,540 --> 00:43:06,890
处理碰撞的另一种方法

1114
00:43:06,890 --> 00:43:09,560
是而不是进行线性探测

1115
00:43:09,560 --> 00:43:11,000
并继续向下扫描并可能

1116
00:43:11,000 --> 00:43:13,190
像阿拉伯罗宾汉一样交换事物

1117
00:43:13,190 --> 00:43:15,920
在我们只有多个哈希

1118
00:43:15,920 --> 00:43:19,670
表的情况下进行哈希处理，然后我们决定在何处

1119
00:43:19,670 --> 00:43:22,250
插入我们的密钥的哈希表，

1120
00:43:22,250 --> 00:43:24,349
您知道的是哪个有

1121
00:43:24,349 --> 00:43:26,630
空闲插槽供我们使用，这样我们就

1122
00:43:26,630 --> 00:43:29,540
不必进行这些可能很长的扫描，

1123
00:43:29,540 --> 00:43:32,359
因此 布谷鸟散列是什么所以我

1124
00:43:32,359 --> 00:43:33,680
总是错误地说布谷鸟散列

1125
00:43:33,680 --> 00:43:34,849
的命名就像一个布谷鸟钟

1126
00:43:34,849 --> 00:43:36,440
，手

1127
00:43:36,440 --> 00:43:37,290
来回走动，

1128
00:43:37,290 --> 00:43:38,820
实际上是与一只布谷鸟一起做的，

1129
00:43:38,820 --> 00:43:41,580
众所周知，布谷鸟

1130
00:43:41,580 --> 00:43:43,350
会从一个巢穴移动自己 另一个所以它

1131
00:43:43,350 --> 00:43:44,610
从另一只鸟那里偷了另一个巢

1132
00:43:44,610 --> 00:43:46,140
，然后那只鸟必须移动其他

1133
00:43:46,140 --> 00:43:47,880
东西，所以我们将看到它在哈希表中是如何工作

1134
00:43:47,880 --> 00:43:48,870
的，这就是它的

1135
00:43:48,870 --> 00:43:49,260
含义，

1136
00:43:49,260 --> 00:43:52,110
因此查找和删除以及在

1137
00:43:52,110 --> 00:43:53,870
布谷鸟下 o 散列总是会是哦，

1138
00:43:53,870 --> 00:43:56,340
意思是我们总是会跳，当

1139
00:43:56,340 --> 00:43:59,730
我们进行查找时，我们会跳到 -

1140
00:43:59,730 --> 00:44:01,470
不 - 有散列表，可以

1141
00:44:01,470 --> 00:44:02,940
准确地找到我们想要的东西是否在

1142
00:44:02,940 --> 00:44:04,500
那里，我们没有 不必做任何

1143
00:44:04,500 --> 00:44:06,870
额外的扫描，但插入可能

1144
00:44:06,870 --> 00:44:08,220
会更昂贵，因为现在我们可能

1145
00:44:08,220 --> 00:44:10,470
会再次进行乒乓或移动

1146
00:44:10,470 --> 00:44:14,280
键，所以这看起来是一个非常简单的

1147
00:44:14,280 --> 00:44:16,800
例子，再次使用两个两个哈希表

1148
00:44:16,800 --> 00:44:19,380
在实践中大多数人使用它只是

1149
00:44:19,380 --> 00:44:21,390
使用 - 有一些人使用

1150
00:44:21,390 --> 00:44:22,890
3 之外，这有点

1151
00:44:22,890 --> 00:44:24,960
不切实际，也没有必要，所以 -

1152
00:44:24,960 --> 00:44:27,390
总是正确的数字，所以

1153
00:44:27,390 --> 00:44:30,780
假设我想为

1154
00:44:30,780 --> 00:44:32,550
我的布谷鸟散列设置中的每个散列表插入一个 so

1155
00:44:32,550 --> 00:44:35,790
我必须拥有 一个单独的散列种子用于

1156
00:44:35,790 --> 00:44:38,520
我的散列函数，所以我要拿这个

1157
00:44:38,520 --> 00:44:41,280
键并散列两次它会是

1158
00:44:41,280 --> 00:44:42,960
相同的散列函数，如 murmur 或 xx

1159
00:44:42,960 --> 00:44:44,400
散列，但我只是给它一个

1160
00:44:44,400 --> 00:44:46,710
不同的种子，以便给定的

1161
00:44:46,710 --> 00:44:49,430
键 它产生不同的散列值，

1162
00:44:49,430 --> 00:44:52,740
所以我要散列 我的 CD

1163
00:44:52,740 --> 00:44:54,630
散列函数的两倍，第一个将

1164
00:44:54,630 --> 00:44:56,370
登陆这个位置，第二个

1165
00:44:56,370 --> 00:44:57,960
将登陆这个位置，所以

1166
00:44:57,960 --> 00:45:00,030
此时我的哈希表是空的，所以我

1167
00:45:00,030 --> 00:45:02,400
可以插入任何一个，所以为了我们的

1168
00:45:02,400 --> 00:45:03,810
目的，我们将 只需抛一枚硬币，我们将

1169
00:45:03,810 --> 00:45:05,460
滑动 让我们将其插入此处的第一个哈希

1170
00:45:05,460 --> 00:45:08,340
表 实践中 你可以做更

1171
00:45:08,340 --> 00:45:09,780
复杂的事情 你可以说

1172
00:45:09,780 --> 00:45:11,430
好吧

1173
00:45:11,430 --> 00:45:13,440
从我的哈希表中我的填充因子是多少 也许总是

1174
00:45:13,440 --> 00:45:15,510
选择一个不太完整的或 如果

1175
00:45:15,510 --> 00:45:17,820
你有关于

1176
00:45:17,820 --> 00:45:19,440
哈希表冲突率的元数据，你可以做出

1177
00:45:19,440 --> 00:45:21,270
更好的决定，因为你知道

1178
00:45:21,270 --> 00:45:23,010
每个人都只是抛硬币，这已经

1179
00:45:23,010 --> 00:45:24,630
足够了 正确随机实际上

1180
00:45:24,630 --> 00:45:26,660
对很多事情都非常好，

1181
00:45:26,660 --> 00:45:29,370
所以我会说 我想要 cert B 同样的

1182
00:45:29,370 --> 00:45:31,410
事情我要散列两次，第一个

1183
00:45:31,410 --> 00:45:33,180
进入已经存储 a 的插槽，

1184
00:45:33,180 --> 00:45:35,040
但第二个进入

1185
00:45:35,040 --> 00:45:37,230
空插槽，所以在这种情况下，我的

1186
00:45:37,230 --> 00:45:39,000
选择很明显，我总是

1187
00:45:39,000 --> 00:45:41,040
想去 一个是空的，因为 e 我

1188
00:45:41,040 --> 00:45:42,360
不必移动任何人我只是将

1189
00:45:42,360 --> 00:45:45,840
它插入那里我就完成了所以这就是我们的

1190
00:45:45,840 --> 00:45:48,540
插入 C 同样的事情我现在已经两次成功

1191
00:45:48,540 --> 00:45:50,770
第一个哈希函数

1192
00:45:50,770 --> 00:45:52,480
到这个插槽，其中 a 和

1193
00:45:52,480 --> 00:45:54,160
第二个哈希函数映射到哪里 B

1194
00:45:54,160 --> 00:45:56,230
所以现在我需要决定

1195
00:45:56,230 --> 00:45:59,050
我想再次杀死哪一个让我们

1196
00:45:59,050 --> 00:46:01,960
掷一枚足够好的硬币

1197
00:46:01,960 --> 00:46:03,550
让演示工作我会选择这个

1198
00:46:03,550 --> 00:46:07,330
正确的所以我们现在从 B 那里偷那个插槽

1199
00:46:07,330 --> 00:46:11,890
并插入 C 所以现在我想 B

1200
00:46:11,890 --> 00:46:14,110
现在我必须把它放回另一个

1201
00:46:14,110 --> 00:46:16,450
哈希表所以我要用

1202
00:46:16,450 --> 00:46:18,250
第一个哈希函数对它进行哈希它会

1203
00:46:18,250 --> 00:46:19,780
告诉我我要去哪里插入它但是我们

1204
00:46:19,780 --> 00:46:21,010
正如我们看到的那样 我们尝试在它之前插入它

1205
00:46:21,010 --> 00:46:23,170
，因为它是空气 a 所在的位置

1206
00:46:23,170 --> 00:46:26,470
，所以我们现在必须偷它插槽，把

1207
00:46:26,470 --> 00:46:29,530
B 放在那里，现在把它放在另一个插槽中，

1208
00:46:29,530 --> 00:46:31,780
所以我们讨厌我们散列它来到

1209
00:46:31,780 --> 00:46:33,490
这里，现在我们已经 降落到一个空

1210
00:46:33,490 --> 00:46:36,310
插槽，所以现在我们的插入

1211
00:46:36,310 --> 00:46:39,130
完成了，因为每个人都降落在一个

1212
00:46:39,130 --> 00:46:45,070
空闲插槽中，是的，他的问题是哪个是

1213
00:46:45,070 --> 00:46:47,050
绝对的 答案是肯定的，这会

1214
00:46:47,050 --> 00:46:48,790
不会有循环行为，你会陷入

1215
00:46:48,790 --> 00:46:51,280
无限循环，绝对是的，所以在

1216
00:46:51,280 --> 00:46:52,990
这种情况下，你必须认识

1217
00:46:52,990 --> 00:46:54,580
到你的起点在哪里，所以如果你

1218
00:46:54,580 --> 00:46:56,110
回来看看等一下，我

1219
00:46:56,110 --> 00:46:57,940
见过这个地方 之前和

1220
00:46:57,940 --> 00:46:59,020
那里有一些东西 我不能在那里放任何东西

1221
00:46:59,020 --> 00:47:00,730
我陷入了一个无限

1222
00:47:00,730 --> 00:47:08,500
循环 所以当你调整大小的时候 再

1223
00:47:08,500 --> 00:47:11,500
一次在实践中每个人总是

1224
00:47:11,500 --> 00:47:13,480
只做两个哈希表 你想

1225
00:47:13,480 --> 00:47:16,540
以这种方式分配它 你

1226
00:47:16,540 --> 00:47:18,490
知道你有一个循环的可能性

1227
00:47:18,490 --> 00:47:25,090
被最小化了，所以

1228
00:47:25,090 --> 00:47:26,290
现在我们到目前为止讨论的所有哈希表

1229
00:47:26,290 --> 00:47:29,200
都是静态哈希表，

1230
00:47:29,200 --> 00:47:31,510
这意味着我需要知道

1231
00:47:31,510 --> 00:47:33,610
我想提前存储的数字键的大致大小

1232
00:47:33,610 --> 00:47:35,680
时间，所以我知道如何分配

1233
00:47:35,680 --> 00:47:39,370
它你知道今天分配它的运气足够大

1234
00:47:39,370 --> 00:47:41,500
，我可以最大限度地减少冲突，

1235
00:47:41,500 --> 00:47:44,260
而且我没有无限循环或

1236
00:47:44,260 --> 00:47:47,440
完全充满，所以正如他

1237
00:47:47,440 --> 00:47:49,510
之前指出的那样，如果你现在必须

1238
00:47:49,510 --> 00:47:51,790
调整它的大小需要 变大这

1239
00:47:51,790 --> 00:47:53,080
更常见，但如果你

1240
00:47:53,080 --> 00:47:55,150
想减小大小，你基本上

1241
00:47:55,150 --> 00:47:57,150
必须完全正确地重建哈希表，

1242
00:47:57,150 --> 00:47:59,140
我们将讨论一致性

1243
00:47:59,140 --> 00:48:00,460
哈希，那里有哈希方案，

1244
00:48:00,460 --> 00:48:02,290
我们正在哈希函数或方法，我们

1245
00:48:02,290 --> 00:48:03,040
可以稍后讨论

1246
00:48:03,040 --> 00:48:04,710
当我们谈论

1247
00:48:04,710 --> 00:48:06,420
不必调整整个

1248
00:48:06,420 --> 00:48:09,089
事物的分布式数据库的学期，但是对于我们数据库系统内的哈希表，

1249
00:48:09,089 --> 00:48:10,589
我们必须

1250
00:48:10,589 --> 00:48:13,950
重新哈希所有我重置的哈希

1251
00:48:13,950 --> 00:48:15,630
表，因为现在我们更改

1252
00:48:15,630 --> 00:48:17,309
元素数量 mod 和

1253
00:48:17,309 --> 00:48:19,530
哈希哈希值，这意味着事情

1254
00:48:19,530 --> 00:48:21,510
并不是你知道我们在一个桶或一个

1255
00:48:21,510 --> 00:48:23,520
位置之前一个插槽现在可能在

1256
00:48:23,520 --> 00:48:25,559
另一个插槽中，我你知道一切

1257
00:48:25,559 --> 00:48:27,119
都会失控，所以在实践中你

1258
00:48:27,119 --> 00:48:30,210
必须 从头开始重建，所以这

1259
00:48:30,210 --> 00:48:31,440
就是动态哈希表试图

1260
00:48:31,440 --> 00:48:33,000
解决的问题，他们将能够

1261
00:48:33,000 --> 00:48:35,579
按需调整自己的大小，而

1262
00:48:35,579 --> 00:48:38,520
无需重建整个事物

1263
00:48:38,520 --> 00:48:40,349
最基本的一个是 cha 在哈希表中，这

1264
00:48:40,349 --> 00:48:42,240
是好莱坞人

1265
00:48:42,240 --> 00:48:43,859
在想到哈希表时最常想到的，但是当

1266
00:48:43,859 --> 00:48:45,300
我谈到

1267
00:48:45,300 --> 00:48:47,010
1980 年代至今仍在使用的更复杂的场景时，可以

1268
00:48:47,010 --> 00:48:50,240
扩展哈希和线性哈希，

1269
00:48:50,240 --> 00:48:53,520
所以链哈希或链哈希

1270
00:48:53,520 --> 00:48:57,150
表 或存储桶和哈希表是

1271
00:48:57,150 --> 00:48:58,530
emic 哈希表我们将维护

1272
00:48:58,530 --> 00:49:02,099
存储桶的链接列表，用于映射

1273
00:49:02,099 --> 00:49:03,390
到相同的值或映射到属于同一键的相同

1274
00:49:03,390 --> 00:49:06,300
芯片的键，因此

1275
00:49:06,300 --> 00:49:08,550
当您分配哈希映射时 和 Java

1276
00:49:08,550 --> 00:49:11,309
和 JVM 你得到其中之一 这

1277
00:49:11,309 --> 00:49:12,750
是他们使用的默认数据结构

1278
00:49:12,750 --> 00:49:15,390
所以他们处理

1279
00:49:15,390 --> 00:49:17,549
冲突的方式是他们将

1280
00:49:17,549 --> 00:49:20,700
继续追加到这个桶列表的末尾

1281
00:49:20,700 --> 00:49:22,559
所以每个桶链 可以永远增长，

1282
00:49:22,559 --> 00:49:24,210
因为您只是不断添加

1283
00:49:24,210 --> 00:49:25,530
越来越多的存储桶，链表

1284
00:49:25,530 --> 00:49:28,290
变得更大，当然这

1285
00:49:28,290 --> 00:49:31,589
显然会退化为本质上的

1286
00:49:31,589 --> 00:49:33,480
紧缩，否则可以将我的所有键映射

1287
00:49:33,480 --> 00:49:36,630
到同一个存储桶，然后是我的存储桶链

1288
00:49:36,630 --> 00:49:37,829
t 永远增长然后我只是

1289
00:49:37,829 --> 00:49:39,720
在做一个线性搜索，我并不

1290
00:49:39,720 --> 00:49:41,630
比你知道从表中读取更好，

1291
00:49:41,630 --> 00:49:44,190
所以插入和删除非常

1292
00:49:44,190 --> 00:49:44,940
简单，因为你只是在

1293
00:49:44,940 --> 00:49:46,170
修改桶你

1294
00:49:46,170 --> 00:49:49,710
实际上并没有修改插槽 好吧，

1295
00:49:49,710 --> 00:49:51,569
再一次看起来像这样我们有

1296
00:49:51,569 --> 00:49:53,670
我们的槽数组，这些映射到桶，

1297
00:49:53,670 --> 00:49:55,650
然后任何时候我想做一个

1298
00:49:55,650 --> 00:49:57,660
插入，说这个桶链

1299
00:49:57,660 --> 00:50:00,569
在这里，如果我的最后一个桶满了，我只

1300
00:50:00,569 --> 00:50:02,069
分配一个新的，我 一直

1301
00:50:02,069 --> 00:50:04,680
追加到这里，直到我知道，直到我

1302
00:50:04,680 --> 00:50:05,849
用完空间并分配下

1303
00:50:05,849 --> 00:50:07,530
一个，这样你就可以认为这些桶

1304
00:50:07,530 --> 00:50:10,200
只是表堆

1305
00:50:10,200 --> 00:50:12,900
或堆文件中的页面，而我是一个 liqu

1306
00:50:12,900 --> 00:50:14,359
八个新页面和链 他们一起

1307
00:50:14,359 --> 00:50:17,099
使用页面 ID 找出如何

1308
00:50:17,099 --> 00:50:18,870
知道 Trevor

1309
00:50:18,870 --> 00:50:20,890
是的 这很简单 这

1310
00:50:20,890 --> 00:50:23,710
很容易实现 这

1311
00:50:23,710 --> 00:50:25,630
实际上也很容易制作 Fred

1312
00:50:25,630 --> 00:50:27,340
Dave 因为我所做的只是

1313
00:50:27,340 --> 00:50:30,190
在任一插槽上闩锁

1314
00:50:30,190 --> 00:50:31,810
吨 他是最容易做的事情，或者

1315
00:50:31,810 --> 00:50:36,180
我修改它的时候只是单个页面，

1316
00:50:36,180 --> 00:50:38,110
所以让我们看看更复杂的

1317
00:50:38,110 --> 00:50:42,250
方案，所以对于可扩展的散列，我们

1318
00:50:42,250 --> 00:50:43,510
将采用带桶的链散列方法

1319
00:50:43,510 --> 00:50:46,690
，而不是

1320
00:50:46,690 --> 00:50:49,840
让链接列表永远增长我们 '

1321
00:50:49,840 --> 00:50:52,060
将要逐步拆分它们

1322
00:50:52,060 --> 00:50:54,400


1323
00:50:54,400 --> 00:50:57,040
，重建拆分和重建之间的主要区别

1324
00:50:57,040 --> 00:50:58,510
在于，我们只会

1325
00:50:58,510 --> 00:51:01,570
拆分溢出的链

1326
00:51:01,570 --> 00:51:04,900
而不是整个数据

1327
00:51:04,900 --> 00:51:08,170
结构，这是我们的哈希表，因此

1328
00:51:08,170 --> 00:51:09,010
为了使这个 工作我们不允许

1329
00:51:09,010 --> 00:51:10,720


1330
00:51:10,720 --> 00:51:13,330
插槽数组中的多个插槽位置指向同一个桶

1331
00:51:13,330 --> 00:51:16,090
链，

1332
00:51:16,090 --> 00:51:18,430
当我在下一个插槽中展示这一点时会更有意义

1333
00:51:18,430 --> 00:51:21,400
，优点是女性

1334
00:51:21,400 --> 00:51:22,930
必须在我们周围移动数据 '只是

1335
00:51:22,930 --> 00:51:24,610
移动溢出的桶，

1336
00:51:24,610 --> 00:51:27,610
而不是所有其他桶，

1337
00:51:27,610 --> 00:51:30,130
所以它看起来像一个链式哈希

1338
00:51:30,130 --> 00:51:31,750
表，而不是我要添加一些

1339
00:51:31,750 --> 00:51:34,180
额外的信息，所以第一个我

1340
00:51:34,180 --> 00:51:36,160
要h  ave 是这个全局计数器，它

1341
00:51:36,160 --> 00:51:38,470
对应于我们

1342
00:51:38,470 --> 00:51:40,270
必须考虑的位数，当我们想弄清楚

1343
00:51:40,270 --> 00:51:42,610


1344
00:51:42,610 --> 00:51:45,550
在我们的散列函数中要查看哪个桶要查看哪个槽时，所以在这个

1345
00:51:45,550 --> 00:51:46,690
例子中，我们将从一个全局

1346
00:51:46,690 --> 00:51:49,750
计数器 2 开始 然后每个

1347
00:51:49,750 --> 00:51:51,730
桶链或每个桶的三个我们将

1348
00:51:51,730 --> 00:51:53,920
有一个本地计数器，该计数器对应于

1349
00:51:53,920 --> 00:51:56,440
我们用来到达该位置的位数，

1350
00:51:56,440 --> 00:51:59,770
因此在这种情况下，

1351
00:51:59,770 --> 00:52:03,250
第一个桶的本地本地计数器

1352
00:52:03,250 --> 00:52:05,440
为 1，以便 意味着我们只

1353
00:52:05,440 --> 00:52:07,690
需要查看一个位来寻址它

1354
00:52:07,690 --> 00:52:10,150
，这就是为什么如果你查看 0 0 和 0

1355
00:52:10,150 --> 00:52:13,300
1 这两个家伙都映射到同一个

1356
00:52:13,300 --> 00:52:15,820
桶，因为第一位 0 是

1357
00:52:15,820 --> 00:52:17,590
相同的，因为这个桶有一个数字

1358
00:52:17,590 --> 00:52:19,090
浮点数我们没有拆分它是的，

1359
00:52:19,090 --> 00:52:21,730
而其他两个桶有 1

1360
00:52:21,730 --> 00:52:23,560
0 1 1 并且因为它们是本地

1361
00:52:23,560 --> 00:52:25,000
计数器，所以我们必须查看

1362
00:52:25,000 --> 00:52:27,700
两个位，因此全局计数器

1363
00:52:27,700 --> 00:52:29,710
需要弄清楚如何 您

1364
00:52:29,710 --> 00:52:31,030
需要查看

1365
00:52:31,030 --> 00:52:32,590
徽标计数器的许多位，它只适合您 在

1366
00:52:32,590 --> 00:52:34,450
内部保持理智，以

1367
00:52:34,450 --> 00:52:36,700
了解您是如何到达正确位置的

1368
00:52:36,700 --> 00:52:38,650
，但您

1369
00:52:38,650 --> 00:52:39,940
实际上并不需要它来

1370
00:52:39,940 --> 00:52:41,650
弄清楚您是如何在

1371
00:52:41,650 --> 00:52:42,520
屠宰场中正确查找的，因为显然您

1372
00:52:42,520 --> 00:52:43,990
不能 你不知道这是什么，直到

1373
00:52:43,990 --> 00:52:45,070
你通过屠宰进行查找，

1374
00:52:45,070 --> 00:52:48,010
好吧，假设我想

1375
00:52:48,010 --> 00:52:50,590
找到鸡蛋，然后我再把它散列

1376
00:52:50,590 --> 00:52:52,660
我要为我的从一个位序列产生一些序列

1377
00:52:52,660 --> 00:52:55,600
散列值，然后我

1378
00:52:55,600 --> 00:52:57,100
查看我的全局计数器，它说

1379
00:52:57,100 --> 00:52:58,600
我想

1380
00:52:58,600 --> 00:53:00,820
从散列值检查散列函数中的多少位决定

1381
00:53:00,820 --> 00:53:03,790
我想跳到哪里，所以我的全局

1382
00:53:03,790 --> 00:53:05,950
计数器是两个，所以我只需要看看

1383
00:53:05,950 --> 00:53:08,830
前两位 0 1 我

1384
00:53:08,830 --> 00:53:12,070
在我的屠宰场中查找 0 1 我

1385
00:53:12,070 --> 00:53:13,360
跟随指针然后降落到

1386
00:53:13,360 --> 00:53:14,950
我想要的桶，现在我只是进行

1387
00:53:14,950 --> 00:53:17,170
中央扫描以找到我正在寻找的条目

1388
00:53:17,170 --> 00:53:19,440


1389
00:53:19,500 --> 00:53:22,630
所以现在假设我想启动 B

1390
00:53:22,630 --> 00:53:24,910
所以全局计数器是 2 我只需要

1391
00:53:24,910 --> 00:53:26,770
查看前 2 位我 在这里着陆

1392
00:53:26,770 --> 00:53:28,930
跟随屠宰这个家伙有一个释放

1393
00:53:28,930 --> 00:53:30,760
给你的位置所以我可以安全地

1394
00:53:30,760 --> 00:53:34,750
继续排序永远不会流动但

1395
00:53:34,750 --> 00:53:38,230
现在我想先开始看看你的位

1396
00:53:38,230 --> 00:53:41,230
是1 0我跟着这个我降落在这里但

1397
00:53:41,230 --> 00:53:42,700
现在我明白了

1398
00:53:42,700 --> 00:53:45,040
我的存储桶中没有更多免费条目我

1399
00:53:45,040 --> 00:53:47,980
会溢出所以现在我必须拆分

1400
00:53:47,980 --> 00:53:50,830
它所以拆分过程是我

1401
00:53:50,830 --> 00:53:52,840
查看我的全局计数器它现在

1402
00:53:52,840 --> 00:53:54,340
设置为 2 所以我要去 将其

1403
00:53:54,340 --> 00:53:56,770
增加到 3，这意味着我不需要

1404
00:53:56,770 --> 00:53:57,970
检查三个位，所以现在

1405
00:53:57,970 --> 00:54:01,030
我要将插槽数组的大小加倍，现在

1406
00:54:01,030 --> 00:54:04,600
再次计数为 3 位，这个操作很

1407
00:54:04,600 --> 00:54:05,980
便宜，因为这只是一个指针数组，

1408
00:54:05,980 --> 00:54:07,960
所以 我拿了一个闩锁

1409
00:54:07,960 --> 00:54:09,820
保护它调整它的大小然后把它放

1410
00:54:09,820 --> 00:54:11,860
回去所以我不需要

1411
00:54:11,860 --> 00:54:13,510
在这里移动任何数据，这是

1412
00:54:13,510 --> 00:54:16,630
更昂贵的部分，所以现在像 Lobel

1413
00:54:16,630 --> 00:54:20,950
计数器是 3，我要分裂 到

1414
00:54:20,950 --> 00:54:23,380
那时，现在检查 3 位而不是

1415
00:54:23,380 --> 00:54:26,440
2 并找出它们属于哪个哈希表或

1416
00:54:26,440 --> 00:54:28,990
Succot 所以这个 gu 你只是

1417
00:54:28,990 --> 00:54:31,510
滑下来我重组这个东西我

1418
00:54:31,510 --> 00:54:33,670
只是分割存储

1419
00:54:33,670 --> 00:54:35,710
在那个页面之间的数据我

1420
00:54:35,710 --> 00:54:39,640
根据本地计数器重新映射每个人

1421
00:54:39,640 --> 00:54:43,030
所以这个家伙在这里我们仍然只

1422
00:54:43,030 --> 00:54:44,460
关心一点所以有

1423
00:54:44,460 --> 00:54:46,530
两个插槽映射到 它在上面和下面的

1424
00:54:46,530 --> 00:54:47,820
两个插槽也映射

1425
00:54:47,820 --> 00:54:50,450
到第一个位为零的位置

1426
00:54:50,450 --> 00:54:52,950
然后现在我想

1427
00:54:52,950 --> 00:54:55,320
回去尝试插入 C 所以现在我

1428
00:54:55,320 --> 00:54:57,150
看三位告诉我我想看

1429
00:54:57,150 --> 00:54:58,950
这里的这个位置我跟随

1430
00:54:58,950 --> 00:55:00,300
指针然后我可以

1431
00:55:00,300 --> 00:55:03,900
插入它所以这里的这个移动

1432
00:55:03,900 --> 00:55:05,180
看起来有点像

1433
00:55:05,180 --> 00:55:07,849
滑动一样昂贵但我所做的只是

1434
00:55:07,849 --> 00:55:10,050
拆分我以前拥有的一页

1435
00:55:10,050 --> 00:55:12,300
制作另一个页面，以便支付

1436
00:55:12,300 --> 00:55:14,040
页面权限以及您必须

1437
00:55:14,040 --> 00:55:16,890
为后面的插槽

1438
00:55:16,890 --> 00:55:24,030


1439
00:55:24,030 --> 00:55:26,040


1440
00:55:26,040 --> 00:55:29,010
阵列更新的页面 我

1441
00:55:29,010 --> 00:55:30,930
真的像这些仍然在

1442
00:55:30,930 --> 00:55:34,920
磁盘上文件中的相同页面 ID 所以现在

1443
00:55:34,920 --> 00:55:37,470
我只是再次更新它它是一个

1444
00:55:37,470 --> 00:55:40,650
单一的数组更新值现在

1445
00:55:40,650 --> 00:55:43,560
指向你知道数据

1446
00:55:43,560 --> 00:55:45,180
实际存储的位置所以这个操作很

1447
00:55:45,180 --> 00:55:58,020
便宜移动页面很昂贵是的

1448
00:55:58,020 --> 00:56:00,750
所以她的问题 是如果说第

1449
00:56:00,750 --> 00:56:03,540
一个填满不会说现在会发生什么

1450
00:56:03,540 --> 00:56:06,210
我会拆分它，然后再次

1451
00:56:06,210 --> 00:56:08,369
将本地柜台的 Lote 拆分为一个所以我们

1452
00:56:08,369 --> 00:56:11,940
现在将其增加到两个是的所以

1453
00:56:11,940 --> 00:56:13,849
现在它拆分为两个所以现在它会 是

1454
00:56:13,849 --> 00:56:19,619
0 0 0 1 0 0 0 1 所以这里有零的任何人

1455
00:56:19,619 --> 00:56:21,359
这两个条目

1456
00:56:21,359 --> 00:56:23,280
都指向同一件事，0 是

1457
00:56:23,280 --> 00:56:28,770
同一

1458
00:56:28,770 --> 00:56:31,020


1459
00:56:31,020 --> 00:56:35,930
件事的一点 后面是的，

1460
00:56:39,880 --> 00:56:41,930
他的问题是您是否将

1461
00:56:41,930 --> 00:56:44,359
整个页面 ID 页面存储在此处的 solana 中

1462
00:56:44,359 --> 00:56:46,520
，或者它只是一个页面 ID，它

1463
00:56:46,520 --> 00:56:50,150
只是存储桶中的页面 ID，这是

1464
00:56:50,150 --> 00:56:56,140
每个存储桶将是一个页面是的，

1465
00:57:02,109 --> 00:57:04,309
这个问题是什么

1466
00:57:04,309 --> 00:57:06,650
在缓冲池上的散列磁带中是否有关系，所以

1467
00:57:06,650 --> 00:57:08,859
在高 l 我在实践中忽略了这一点，

1468
00:57:08,859 --> 00:57:11,990
具体取决于您是否希望

1469
00:57:11,990 --> 00:57:14,240
它对磁盘具有持久性，

1470
00:57:14,240 --> 00:57:15,920
您会像为表分配一个页面一样，

1471
00:57:15,920 --> 00:57:19,339
在缓冲池中的一个插槽中放置一个页面，

1472
00:57:19,339 --> 00:57:20,780
并且您可以

1473
00:57:20,780 --> 00:57:23,299
在其中存储一个存储桶页面 同样的事情

1474
00:57:23,299 --> 00:57:24,819
缓冲池不知道也不在乎

1475
00:57:24,819 --> 00:57:27,440
你只是说给我一个页面，这里是

1476
00:57:27,440 --> 00:57:29,210
页面 ID，然后给你一些

1477
00:57:29,210 --> 00:57:30,530
内存地址，然后你在那里写一些数据

1478
00:57:30,530 --> 00:57:32,059
，它不知道它是否

1479
00:57:32,059 --> 00:57:33,680
是表的一部分 或者像这样的哈希表的一部分，

1480
00:57:33,680 --> 00:57:35,569
比如数据表或

1481
00:57:35,569 --> 00:57:40,520
哈希表 所以

1482
00:57:40,520 --> 00:57:41,869
你现在使用的所有相同的成瘾算法

1483
00:57:41,869 --> 00:57:43,760
你想看看我们如何

1484
00:57:43,760 --> 00:57:45,170
绕过这个并访问我们的哈希表

1485
00:57:45,170 --> 00:57:46,609
它肯定看起来很多 不同于

1486
00:57:46,609 --> 00:57:47,720
我们如何跳过并

1487
00:57:47,720 --> 00:57:50,150
在数据表中进行顺序扫描，所以

1488
00:57:50,150 --> 00:57:51,020
也许你想要不同的缓存

1489
00:57:51,020 --> 00:57:53,170
策略或成瘾策略

1490
00:57:53,170 --> 00:58:04,160
是的，语句是，我在这里使用三位

1491
00:58:04,160 --> 00:58:06,799
将哈希

1492
00:58:06,799 --> 00:58:08,030
值映射到

1493
00:58:08,030 --> 00:58:11,480
槽然后 它告诉我什么抵消

1494
00:58:11,480 --> 00:58:14,270
跳到右边，然后

1495
00:58:14,270 --> 00:58:16,040
在这个数组的那个槽内，我会有一个页面

1496
00:58:16,040 --> 00:58:17,690
ID，然后我可以跟随它到达

1497
00:58:17,690 --> 00:58:23,990
存储桶 页面 ID 的映射如何

1498
00:58:23,990 --> 00:58:26,329
工作，两个存储桶是的

1499
00:58:26,329 --> 00:58:30,450
，就像我再次使用术语

1500
00:58:30,450 --> 00:58:32,539
存储桶一样 而不是页面，因为

1501
00:58:32,539 --> 00:58:34,769
它可能在内存中，它

1502
00:58:34,769 --> 00:58:36,630
可以由磁盘返回，这无关紧要，但您

1503
00:58:36,630 --> 00:58:38,450
可以考虑它是否由磁盘支持，

1504
00:58:38,450 --> 00:58:42,599
那么这些是页面 ID，

1505
00:58:42,599 --> 00:58:44,569
存储桶是一个页面，它们是 同义词

1506
00:58:44,569 --> 00:58:46,529
所以我唯一需要在这里存储的

1507
00:58:46,529 --> 00:58:56,759
是页面 ID 绝对声明

1508
00:58:56,759 --> 00:59:00,180
今年再次回到这里我的

1509
00:59:00,180 --> 00:59:03,359
全局位计数器是两个但我

1510
00:59:03,359 --> 00:59:05,220
知道我没有在这里拆分第一页

1511
00:59:05,220 --> 00:59:08,670
它是本地计数器一个所以

1512
00:59:08,670 --> 00:59:09,869
即使 如果我想查找，我可以

1513
00:59:09,869 --> 00:59:13,109
查看两位，但实际上我只

1514
00:59:13,109 --> 00:59:14,849
关心此页面的第一位，

1515
00:59:14,849 --> 00:59:16,559
所以这就是为什么这些人具有相同的

1516
00:59:16,559 --> 00:59:18,539
八页 ID 桶 ID，无论您想要什么，

1517
00:59:18,539 --> 00:59:21,359
他们都将垫子放在相同的

1518
00:59:21,359 --> 00:59:24,799
位置 因为他们还没有分裂，

1519
00:59:25,880 --> 00:59:27,779
这是相当的政治家 这是

1520
00:59:27,779 --> 00:59:31,289
正确的，在我们到达一个页面后，我们

1521
00:59:31,289 --> 00:59:32,729
只进行线性扫描以找到

1522
00:59:32,729 --> 00:59:37,229
我们想要的东西绝对是的

1523
00:59:37,229 --> 00:59:41,009
，如果我有十亿个

1524
00:59:41,009 --> 00:59:44,849
元组，那么保存这不再那么昂贵，然后进行查找以扫描

1525
00:59:44,849 --> 00:59:47,400
千字节页面 没什么，他们

1526
00:59:47,400 --> 00:59:49,140
说没关系 我想要更狡猾一点

1527
00:59:49,140 --> 00:59:50,719
你已经变得更聪明了 也许我在顶部存储了一个

1528
00:59:50,719 --> 00:59:53,910
过滤器或一些预先计算的小

1529
00:59:53,910 --> 00:59:55,950
信息 它说

1530
00:59:55,950 --> 00:59:57,479
你知道的关键外观

1531
00:59:57,479 --> 00:59:59,489
这是我拥有的关键列表 它没有告诉你

1532
00:59:59,489 --> 01:00:01,019
它们在哪里，它说你有它们，所以

1533
01:00:01,019 --> 01:00:02,309
你可以快速查找

1534
01:00:02,309 --> 01:00:04,739
它是否在那里，但与

1535
01:00:04,739 --> 01:00:05,849


1536
01:00:05,849 --> 01:00:07,739
从磁盘读取或拥有新的 20 个

1537
01:00:07,739 --> 01:00:14,789
完整数据相比，线性扫描将非常便宜 设置好所以另一个

1538
01:00:14,789 --> 01:00:17,999
动态散列表被称为线性

1539
01:00:17,999 --> 01:00:24,299
散列所以一个问题与

1540
01:00:24,299 --> 01:00:25,529
范围同时散列很好这不是一个

1541
01:00:25,529 --> 01:00:27,960
大问题是我们必须在

1542
01:00:27,960 --> 01:00:30,529


1543
01:00:30,529 --> 01:00:33,089
计算上再次将屠宰的大小加倍它不是那么

1544
01:00:33,089 --> 01:00:34,710
昂贵但是虽然我 正在这样做

1545
01:00:34,710 --> 01:00:37,229
调整大小我必须锁定它以

1546
01:00:37,229 --> 01:00:38,400
防止任何人读取和写入

1547
01:00:38,400 --> 01:00:40,049
它，直到我重新分配

1548
01:00:40,049 --> 01:00:42,329
所有内容，因此这将

1549
01:00:42,329 --> 01:00:43,650
成为每个人都试图进入的瓶颈

1550
01:00:43,650 --> 01:00:45,359
，我的哈希也几乎在

1551
01:00:45,359 --> 01:00:47,939
同一时间，因此通过线性哈希

1552
01:00:47,939 --> 01:00:49,679
我们的想法 '将

1553
01:00:49,679 --> 01:00:55,079
调整大小本地化为无论

1554
01:00:55,079 --> 01:00:58,019
桶溢出的任何内容，因此我们

1555
01:00:58,019 --> 01:00:59,699
不必采取全局锁存器来

1556
01:00:59,699 --> 01:01:01,679
锁定每个人无法访问我们的哈希

1557
01:01:01,679 --> 01:01:04,559
表，因此这将起作用的方式

1558
01:01:04,559 --> 01:01:05,400
是我们要 维护多个

1559
01:01:05,400 --> 01:01:07,679
散列 散列函数就像

1560
01:01:07,679 --> 01:01:09,299
我们在布谷鸟散列中所做的一样 这是

1561
01:01:09,299 --> 01:01:11,429
相同的散列函数算法 只是

1562
01:01:11,429 --> 01:01:13,529
不同的种子会告诉我们从

1563
01:01:13,529 --> 01:01:15,179
哪里跳转到给定键的正确存储桶

1564
01:01:15,179 --> 01:01:17,429
我们将维护这个

1565
01:01:17,429 --> 01:01:19,199
称为 a 的新事物 拆分指针

1566
01:01:19,199 --> 01:01:21,390
将跟踪

1567
01:01:21,390 --> 01:01:23,069
我们想要溢出的下一页是什么或执行我们

1568
01:01:23,069 --> 01:01:24,959
想要拆分的操作，然后我们逐步

1569
01:01:24,959 --> 01:01:28,739
增加槽数组的大小，以便

1570
01:01:28,739 --> 01:01:31,259
我们如何决定何时执行我的流程 c

1571
01:01:31,259 --> 01:01:33,179
取决于我们想要做什么，它可能

1572
01:01:33,179 --> 01:01:35,519
只是当我们的桶中的条目用完时

1573
01:01:35,519 --> 01:01:38,459
，然后

1574
01:01:38,459 --> 01:01:40,410
我们触发调整

1575
01:01:40,410 --> 01:01:43,259
大小，如果我们的桶的大小

1576
01:01:43,259 --> 01:01:44,689
大于平均大小 再次所有的存储桶都由

1577
01:01:44,689 --> 01:01:47,299
实现决定了

1578
01:01:47,299 --> 01:01:49,640
它们都有不同的权衡，

1579
01:01:49,640 --> 01:01:52,229
所以看起来不错，我们

1580
01:01:52,229 --> 01:01:53,640
有一个槽数组，可以帮助

1581
01:01:53,640 --> 01:01:55,559
指向存储桶，就像我链

1582
01:01:55,559 --> 01:01:58,559
散列一样，所以我们要再次添加现在

1583
01:01:58,559 --> 01:02:00,390
这个 这个新的拆分指针

1584
01:02:00,390 --> 01:02:03,269
将跟踪我们想要拆分的下一个桶是什么

1585
01:02:03,269 --> 01:02:04,559
，每当

1586
01:02:04,559 --> 01:02:08,759
我们的哈希表中的任何地方出现溢出时，

1587
01:02:08,759 --> 01:02:11,160
我们都会将桶点拆分

1588
01:02:11,160 --> 01:02:14,069
为位置零，

1589
01:02:14,069 --> 01:02:15,989
而不仅仅是当桶为零时 被

1590
01:02:15,989 --> 01:02:17,339
溢出所以如果这些其他人中的任何一个

1591
01:02:17,339 --> 01:02:21,420
溢出，我们也不会拆分 0，

1592
01:02:21,420 --> 01:02:23,299
即使它不是溢出的那个，

1593
01:02:23,299 --> 01:02:28,199
所以在这一点上，我们的拆分指针

1594
01:02:28,199 --> 01:02:29,819
位于我们的插槽数组的开头，

1595
01:02:29,819 --> 01:02:32,099
所以我们只 有一个

1596
01:02:32,099 --> 01:02:34,079
哈希函数 好吧，我是会员，只是

1597
01:02:34,079 --> 01:02:37,229
要修改我们拥有的条目数量，

1598
01:02:37,229 --> 01:02:41,130
所以假设我查看

1599
01:02:41,130 --> 01:02:44,670
了六个，我只是将其散列四，我

1600
01:02:44,670 --> 01:02:46,949
跳转到位置进行线性扫描，所以我

1601
01:02:46,949 --> 01:02:49,049
找到了关键 我想要正确的，

1602
01:02:49,049 --> 01:02:50,640
就像以前在链式散列下一样工作，

1603
01:02:50,640 --> 01:02:52,769
但现在假设我想

1604
01:02:52,769 --> 01:02:53,649
插入 7

1605
01:02:53,649 --> 01:02:57,349
个，我将它散列 17 mod for I'll and

1606
01:02:57,349 --> 01:02:59,779
to this position here but now I don't

1607
01:02:59,779 --> 01:03:02,119
have any more free slot or

1608
01:03:02,119 --> 01:03:04,099
在我的存储桶中的免费条目，所以我将不得不

1609
01:03:04,099 --> 01:03:06,739
创建一个溢出存储桶，

1610
01:03:06,739 --> 01:03:07,819
因为您刚刚再次创建

1611
01:03:07,819 --> 01:03:09,589
链表，然后我插入

1612
01:03:09,589 --> 01:03:13,609
17 但因为我现在溢出了，

1613
01:03:13,609 --> 01:03:15,409
这将

1614
01:03:15,409 --> 01:03:16,880
在拆分指针的任何地方触发拆分

1615
01:03:16,880 --> 01:03:21,139
指向所以即使 0 仍然是我可以在其中

1616
01:03:21,139 --> 01:03:23,029
输入条目我在

1617
01:03:23,029 --> 01:03:25,699
某个地方浮动一次可能导致我溢出

1618
01:03:25,699 --> 01:03:28,749
所以这将起作用的方式是

1619
01:03:28,749 --> 01:03:33,199
我们现在要向我们的插槽数组添加一个新条目

1620
01:03:33,199 --> 01:03:36,469
位置 4 然后我们

1621
01:03:36,469 --> 01:03:37,909
将有一个新的哈希函数，现在

1622
01:03:37,909 --> 01:03:42,889
修改为 2 n 正确的想法是，随着我们

1623
01:03:42,889 --> 01:03:44,059
不断向下拆分，我们将不断

1624
01:03:44,059 --> 01:03:45,889
添加新条目，直到达到 2 N 或

1625
01:03:45,889 --> 01:03:47,209
比

1626
01:03:47,209 --> 01:03:49,159
我们在开始拆分之前将其添加到此处之前

1627
01:03:49,159 --> 01:03:52,369
的两倍大

1628
01:03:52,369 --> 01:03:53,959
工作是我们需要保持拆分

1629
01:03:53,959 --> 01:03:54,979
poner 将跟踪

1630
01:03:54,979 --> 01:03:56,569
我们是否要使用第一个散列

1631
01:03:56,569 --> 01:03:57,829
函数或第二个散列函数

1632
01:03:57,829 --> 01:04:00,049
他们告诉我们我们在

1633
01:04:00,049 --> 01:04:02,630
屠宰中拆分了多远所以在这种

1634
01:04:02,630 --> 01:04:06,229
情况下我们 我们添加新条目以

1635
01:04:06,229 --> 01:04:08,329
重新创建一个新的存储桶，然后这

1636
01:04:08,329 --> 01:04:12,109
是我们插入 20 的位置，我们将这个

1637
01:04:12,109 --> 01:04:14,389
脚指针向下移动一个，所以分割

1638
01:04:14,389 --> 01:04:15,769
指针本质上就是

1639
01:04:15,769 --> 01:04:18,199
这里的这条分界线，所以基本上说，

1640
01:04:18,199 --> 01:04:20,899
每当我想做一个查找时 我

1641
01:04:20,899 --> 01:04:22,399
首先对第一个散列函数进行散列，所以我说

1642
01:04:22,399 --> 01:04:24,829
我想在 20 上进行查找我放置了

1643
01:04:24,829 --> 01:04:26,239
第一个散列函数，这

1644
01:04:26,239 --> 01:04:28,999
将使我从 0 到 3，然后如果

1645
01:04:28,999 --> 01:04:31,279
我指向的东西高于分界线所在的位置

1646
01:04:31,279 --> 01:04:32,839
对于分割

1647
01:04:32,839 --> 01:04:36,049
指针，我知道 我正在查看的存储桶

1648
01:04:36,049 --> 01:04:37,309
已经被

1649
01:04:37,309 --> 01:04:39,529
拆分，因此现在我需要

1650
01:04:39,529 --> 01:04:40,759
查看第二个散列函数并决定

1651
01:04:40,759 --> 01:04:42,399
我真正想要去哪里获取数据，

1652
01:04:42,399 --> 01:04:46,909
所以现在当我查看大约 20 个时，我

1653
01:04:46,909 --> 01:04:48,529
应该使用散列函数 第二个哈希函数我

1654
01:04:48,529 --> 01:04:51,109
把这个数字乘以 8 因为那是

1655
01:04:51,109 --> 01:04:53,179
我开始湿的地方然后这

1656
01:04:53,179 --> 01:04:57,130
告诉我我想跳到这里

1657
01:04:57,160 --> 01:05:00,190
同样的事情我做最后九个九会

1658
01:05:00,190 --> 01:05:03,970
降落在这里低于或高于

1659
01:05:03,970 --> 01:05:05,860
拆分指针基本上你知道

1660
01:05:05,860 --> 01:05:07,810
感知它，但你知道它已经

1661
01:05:07,810 --> 01:05:09,820
被拆分了，所以我只

1662
01:05:09,820 --> 01:05:10,900
需要查看第一个哈希函数来

1663
01:05:10,900 --> 01:05:14,130
找到我正在寻找的东西，

1664
01:05:14,700 --> 01:05:26,590
所以这种明确是的，所以

1665
01:05:26,590 --> 01:05:29,550
当我插入一个问题时，问题又回到了这里 十七

1666
01:05:29,550 --> 01:05:32,290
不是这就是溢出的原因 为什么我

1667
01:05:32,290 --> 01:05:33,490
拆分第一个而不是这个

1668
01:05:33,490 --> 01:05:34,840
因为这是精简散列的工作方式

1669
01:05:34,840 --> 01:05:36,730


1670
01:05:36,730 --> 01:05:38,260
如果你拆分拆分指针的任何

1671
01:05:38,260 --> 01:05:40,600
工作，你拥有的算法就会工作 无论这个

1672
01:05:40,600 --> 01:05:42,220
东西是否它 是一个结束 是否流动

1673
01:05:42,220 --> 01:05:44,620
，因为最终就像如果这个

1674
01:05:44,620 --> 01:05:46,750
东西继续溢出一样，它将继续

1675
01:05:46,750 --> 01:05:47,890
将拆分指针向下移动一个

1676
01:05:47,890 --> 01:05:50,650
最终我会到达这个我将

1677
01:05:50,650 --> 01:05:53,050
获得每个拆分拆分它然后

1678
01:05:53,050 --> 01:06:05,680
再循环回来重新开始所以

1679
01:06:05,680 --> 01:06:07,480
语句是 如果我最终

1680
01:06:07,480 --> 01:06:10,720
在这里拆分这个，就说斜率下降了，

1681
01:06:10,720 --> 01:06:13,090
现在我拆分它，然后你知道

1682
01:06:13,090 --> 01:06:14,710
使用第二个哈希函数来决定如何

1683
01:06:14,710 --> 01:06:20,560
重新分配它们正确你

1684
01:06:20,560 --> 01:06:23,290
保证所有的所有值或

1685
01:06:23,290 --> 01:06:24,700
所有映射的关键实例 到

1686
01:06:24,700 --> 01:06:27,790
那个桶然后删除溢出

1687
01:06:27,790 --> 01:06:30,310
是的现在可能是这样说

1688
01:06:30,310 --> 01:06:32,350
这个人是你知道这个溢出的

1689
01:06:32,350 --> 01:06:34,600
东西在这里的底部所以我一直

1690
01:06:34,600 --> 01:06:35,740
插入它我不能我们漂浮

1691
01:06:35,740 --> 01:06:37,840
并且我一直在触发分裂

1692
01:06:37,840 --> 01:06:40,900
然后当我开始再次拆分它时，它

1693
01:06:40,900 --> 01:06:43,780
也可能溢出，这

1694
01:06:43,780 --> 01:06:45,610
就是算法的工作方式，然后您循环

1695
01:06:45,610 --> 01:06:47,980
返回再次执行此操作，因此最坏的

1696
01:06:47,980 --> 01:06:49,750
情况是每个人都插入

1697
01:06:49,750 --> 01:06:51,490
到同一个存储桶中，并且需要很长时间

1698
01:06:51,490 --> 01:06:53,950
我希望它在实践中拆分，尽管

1699
01:06:53,950 --> 01:06:55,060
在本地海洋速率中具有良好的散列函数，

1700
01:06:55,060 --> 01:07:01,170
但这不应该发生，因此

1701
01:07:01,170 --> 01:07:03,190
反对拆分桶的权利

1702
01:07:03,190 --> 01:07:06,010
基本上意味着尽管我们不会

1703
01:07:06,010 --> 01:07:07,000
拆分最终溢出的桶，但

1704
01:07:07,000 --> 01:07:08,290
我们将得到 最终

1705
01:07:08,290 --> 01:07:09,700
每个人都会分裂，然后一切

1706
01:07:09,700 --> 01:07:10,240
都会平衡，

1707
01:07:10,240 --> 01:07:13,960
所以在这个例子中，我只展示了

1708
01:07:13,960 --> 01:07:16,359
插入，如果你开始删除，指针也可以向后移动，如果

1709
01:07:16,359 --> 01:07:18,970
你想开始删除东西来开始合并合并桶，那么在同一周末

1710
01:07:18,970 --> 01:07:20,140
你可以反转可扩展的哈希

1711
01:07:20,140 --> 01:07:20,980
引擎

1712
01:07:20,980 --> 01:07:24,369


1713
01:07:24,369 --> 01:07:26,589
但在实践中，虽然这

1714
01:07:26,589 --> 01:07:29,890
很棘手，所以让我们回到

1715
01:07:29,890 --> 01:07:31,390
右

1716
01:07:31,390 --> 01:07:33,760
拆分指针指向这里之前的位置，

1717
01:07:33,760 --> 01:07:35,560
我们几乎已经把它分开了，我们只拆分

1718
01:07:35,560 --> 01:07:37,990
了插槽数组中的第一个条目位置 0

1719
01:07:37,990 --> 01:07:42,670
所以现在如果我想 删除 20，所以我

1720
01:07:42,670 --> 01:07:44,770
散列第一个将我带到 0 的

1721
01:07:44,770 --> 01:07:48,730
位置，但这里的位置是你知道

1722
01:07:48,730 --> 01:07:50,770
我们分割指针的分界线上方，

1723
01:07:50,770 --> 01:07:52,900
所以我需要再次散列它，我

1724
01:07:52,900 --> 01:07:54,460
拉 现在在这里我可以找到

1725
01:07:54,460 --> 01:07:56,650
我想要的条目，所以现在我要删除

1726
01:07:56,650 --> 01:08:00,180
这个人，现在页面条目是空的，

1727
01:08:00,180 --> 01:08:04,150
所以我可以不理会它，并

1728
01:08:04,150 --> 01:08:06,490
假设稍后我会继续

1729
01:08:06,490 --> 01:08:08,619
填写它 再一次，但如果我想

1730
01:08:08,619 --> 01:08:10,180
开始进行压缩，我想开始

1731
01:08:10,180 --> 01:08:12,730
回收内存，那么我只需执行我之前所做的所有

1732
01:08:12,730 --> 01:08:14,140
相同步骤并将其反转

1733
01:08:14,140 --> 01:08:17,080
就可以了，所以我吹掉了桶

1734
01:08:17,080 --> 01:08:20,140
吹掉了这个指针将滑动

1735
01:08:20,140 --> 01:08:22,299
指针移回了 1 现在这件事

1736
01:08:22,299 --> 01:08:24,100
消失了 我的哈希函数消失了

1737
01:08:24,100 --> 01:08:28,450
我已经收回了内存

1738
01:08:28,450 --> 01:08:29,560
只是按照

1739
01:08:29,560 --> 01:08:38,380
相反的顺序执行所有步骤 是的 他的问题是我

1740
01:08:38,380 --> 01:08:39,790
在删除所有表后最终删除哈希函数

1741
01:08:39,790 --> 01:08:42,580
是的，我想

1742
01:08:42,580 --> 01:08:44,439
在你之后 归根结底我

1743
01:08:44,439 --> 01:08:47,488
认为你最多有两个哈希函数

1744
01:08:50,609 --> 01:08:53,200
语句而不是 20 如果我

1745
01:08:53,200 --> 01:08:55,000
也删除 11 同样的事情

1746
01:08:55,000 --> 01:09:03,600
会发生丢失你所说的对不起

1747
01:09:03,600 --> 01:09:05,439
是的你不能阅读你应该因为

1748
01:09:05,439 --> 01:09:08,500
它因为然后 哈希函数是它

1749
01:09:08,500 --> 01:09:10,330
有 t  o 是终点站 ik 相同的密钥应

1750
01:09:10,330 --> 01:09:11,500
始终产生相同的哈希值，因此我们

1751
01:09:11,500 --> 01:09:13,390
确切地知道在

1752
01:09:13,390 --> 01:09:15,509
后面的

1753
01:09:20,830 --> 01:09:23,899


1754
01:09:23,899 --> 01:09:26,450


1755
01:09:26,450 --> 01:09:29,770
何处找到它 离开

1756
01:09:29,770 --> 01:09:31,670
那里正确，只有一个哈希函数，

1757
01:09:31,670 --> 01:09:33,380
所以如果我尝试删除它，我无法

1758
01:09:33,380 --> 01:09:35,540
在此处调整它的大小，所以我只是

1759
01:09:35,540 --> 01:09:41,270
将其留空，是的，所以我

1760
01:09:41,270 --> 01:09:42,770
已经浏览了任何内容，但是什么

1761
01:09:42,770 --> 01:09:44,710
是明显的舞会，为什么这会出现

1762
01:09:44,710 --> 01:09:47,149
问题 如果我真的这样做了，

1763
01:09:47,149 --> 01:09:49,670
你知道删除了页面并删除了它

1764
01:09:49,670 --> 01:09:51,560
，然后将细长的指针

1765
01:09:51,560 --> 01:09:55,940
准确地放回一个位置，我接下来

1766
01:09:55,940 --> 01:09:59,150
要做的就是插入 21 现在我溢出了我现在

1767
01:09:59,150 --> 01:10:00,110
必须拆分所有内容指向

1768
01:10:00,110 --> 01:10:01,580
的内容，我只是这样做 所有同样的废话

1769
01:10:01,580 --> 01:10:06,530
再次正确，这就是

1770
01:10:06,530 --> 01:10:08,150
我所说的，当你决定

1771
01:10:08,150 --> 01:10:10,340
进行溢出时可能不会在

1772
01:10:10,340 --> 01:10:12,620
你知道你将某些东西插入过载链的那一刻那么长，

1773
01:10:12,620 --> 01:10:14,210
所以也许

1774
01:10:14,210 --> 01:10:15,590
等到这个东西溢出 再

1775
01:10:15,590 --> 01:10:19,310
然后你 拆分或两页变成

1776
01:10:19,310 --> 01:10:20,540
桶，你关闭反向这样的空

1777
01:10:20,540 --> 01:10:25,190
人，所以花了

1778
01:10:25,190 --> 01:10:26,950
很多时间使插入快速

1779
01:10:26,950 --> 01:10:28,970
删除的人更难做，因为在

1780
01:10:28,970 --> 01:10:31,700
实践中，也许击败某些情况

1781
01:10:31,700 --> 01:10:32,900
可能会更好地重建整个

1782
01:10:32,900 --> 01:10:35,000
索引，但你 可以

1783
01:10:35,000 --> 01:10:41,510
用这些数据结构进行增量删除

1784
01:10:41,510 --> 01:10:45,710
好吧 所以我们今天又在

1785
01:10:45,710 --> 01:10:48,620
讨论哈希表 这些是快速的

1786
01:10:48,620 --> 01:10:50,330
数据结构，平均

1787
01:10:50,330 --> 01:10:54,230
来说可以做到哦 一本书你知道

1788
01:10:54,230 --> 01:10:56,330
好键，我们将使用这一切

1789
01:10:56,330 --> 01:10:58,250
在整个数据库系统的内部，

1790
01:10:58,250 --> 01:11:00,650
因为我们在实践中执行

1791
01:11:00,650 --> 01:11:01,850
页表和直接数据

1792
01:11:01,850 --> 01:11:05,780
结构的查询，但

1793
01:11:05,780 --> 01:11:08,300
在应用程序级别，哈希表

1794
01:11:08,300 --> 01:11:09,530
通常不是您想要

1795
01:11:09,530 --> 01:11:12,830
用于表索引数据库 desin 的

1796
01:11:12,830 --> 01:11:14,240
内容 你这样做了一些系统会

1797
01:11:14,240 --> 01:11:15,950
说当我调用 create index 我想

1798
01:11:15,950 --> 01:11:18,230
使用一个哈希表但是当我

1799
01:11:18,230 --> 01:11:20,170
在大多数系统中调用 create index 时没有任何

1800
01:11:20,170 --> 01:11:22,040
指定使用什么数据结构

1801
01:11:22,040 --> 01:11:24,380
我不会得到一个哈希表我仍然

1802
01:11:24,380 --> 01:11:26,510
会得到一个保留顺序的

1803
01:11:26,510 --> 01:11:28,850
索引，这是因为哈希表

1804
01:11:28,850 --> 01:11:31,460
只能做精确的键相等

1805
01:11:31,460 --> 01:11:32,550
谓词质量看起来

1806
01:11:32,550 --> 01:11:34,170
意味着如果我想查看键是否

1807
01:11:34,170 --> 01:11:37,080
存在我必须拥有 进行查找的整个密钥，

1808
01:11:37,080 --> 01:11:38,580
但我不能进行部分密钥

1809
01:11:38,580 --> 01:11:40,890
查找，我不能说找到我所有的

1810
01:11:40,890 --> 01:11:43,710
密钥都小于我给定的密钥，因为

1811
01:11:43,710 --> 01:11:45,030
哈希函数再次无法为您执行此操作

1812
01:11:45,030 --> 01:11:48,990
，因此在实践中 这不是

1813
01:11:48,990 --> 01:11:51,090
你想要使用的，下次我们会

1814
01:11:51,090 --> 01:11:52,770
用我的亮片 Postgres 做演示，我们将

1815
01:11:52,770 --> 01:11:53,910
展示它对性能的影响

1816
01:11:53,910 --> 01:11:54,240


1817
01:11:54,240 --> 01:11:57,030
，但是当你调用 create index 时，你通常会得到

1818
01:11:57,030 --> 01:12:00,680
心爱的 B+ 树，

1819
01:12:00,680 --> 01:12:03,300
它被称为

1820
01:12:03,300 --> 01:12:06,450
1979 年和 4050 年后无处不在的数据结构的无处不在的 B+ 树，

1821
01:12:06,450 --> 01:12:09,120


1822
01:12:09,120 --> 01:12:10,710
我认为它仍然是目前最好的数据结构，

1823
01:12:10,710 --> 01:12:12,360
几乎每个数据库

1824
01:12:12,360 --> 01:12:13,740
系统都会有某种 B+ 树

1825
01:12:13,740 --> 01:12:15,960
实现，除了

1826
01:12:15,960 --> 01:12:17,220
那些像你知道的 memcache 的系统 那是

1827
01:12:17,220 --> 01:12:20,340
绝对 完全哈希表 每个

1828
01:12:20,340 --> 01:12:21,540
主要数据系统都将

1829
01:12:21,540 --> 01:12:22,860
使用看起来像 P 加树

1830
01:12:22,860 --> 01:12:26,040
或直接 B 加树的东西，

1831
01:12:26,040 --> 01:12:27,750
现在它们将在实际存储

1832
01:12:27,750 --> 01:12:30,360
事物的方式和以某些方式进行搜索方面有所不同，但

1833
01:12:30,360 --> 01:12:32,010
在高度上 我们将在周三讨论的级别将

1834
01:12:32,010 --> 01:12:34,140


1835
01:12:34,140 --> 01:12:37,370
再次成为规范的 B+ 树，它无处不在，

1836
01:12:37,370 --> 01:12:42,410
所以任何问题都是

1837
01:12:51,890 --> 01:12:54,930
我系统中的 wixi 晚上堆积如山，

1838
01:12:54,930 --> 01:13:03,120
让我们去下一个

1839
01:13:03,120 --> 01:13:03,930
和我一起去那里儿子

1840
01:13:03,930 --> 01:13:05,940
ricochet jelly 打熟食店 船上的

1841
01:13:05,940 --> 01:13:08,010
人自然会祝福你什么说唱歌手

1842
01:13:08,010 --> 01:13:09,990
喜欢激光束丛林中的小卒说

1843
01:13:09,990 --> 01:13:12,210
甚至不像链条一样包裹我们的瓶子

1844
01:13:12,210 --> 01:13:15,150
如果我们去的话不要保释喝那些

1845
01:13:15,150 --> 01:13:17,610
骨头 - 你说话不能越界

1846
01:13:17,610 --> 01:13:19,410
，如果 为了不知道你他妈的

1847
01:13:19,410 --> 01:13:22,340
不能痛苦

