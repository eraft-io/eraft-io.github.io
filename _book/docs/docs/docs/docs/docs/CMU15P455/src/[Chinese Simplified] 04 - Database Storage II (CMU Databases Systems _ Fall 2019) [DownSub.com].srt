1
00:00:01,280 --> 00:00:04,460
[音乐]

2
00:00:05,980 --> 00:00:21,400
哦，伙计们，让我们再次

3
00:00:21,400 --> 00:00:23,060
开始为 DJ 砍表

4
00:00:23,060 --> 00:00:25,919


5
00:00:25,919 --> 00:00:33,579


6
00:00:33,579 --> 00:00:42,970
敲响警钟 [掌声] 周末，有鞭子的人怎么会不这样做，好吧，所以

7
00:00:42,970 --> 00:00:44,920
除了吹鞭子之外的其他公告

8
00:00:44,920 --> 00:00:49,120
是，家庭作业将于

9
00:00:49,120 --> 00:00:51,670
周一在 午夜它应该有点

10
00:00:51,670 --> 00:00:53,170
旋转哦很棒的脚本你们中的一些人

11
00:00:53,170 --> 00:00:53,920
已经完成了它

12
00:00:53,920 --> 00:00:59,020
谁还没有开始星期三

13
00:00:59,020 --> 00:01:00,310
我说什么星期一是的这是星期一

14
00:01:00,310 --> 00:01:04,720
星期三只要 11 号是正确的

15
00:01:04,720 --> 00:01:09,820
谁没有开始就确保

16
00:01:09,820 --> 00:01:10,469
没问题

17
00:01:10,469 --> 00:01:12,869
和 另一件事我们将

18
00:01:12,869 --> 00:01:16,899
在周三发布第一个项目，

19
00:01:16,899 --> 00:01:19,539
周三的讲座将

20
00:01:19,539 --> 00:01:21,880
是关于你

21
00:01:21,880 --> 00:01:23,770
在项目一中要实施的内容，然后最后

22
00:01:23,770 --> 00:01:25,420
我们将讨论

23
00:01:25,420 --> 00:01:26,770
你如何进行后勤工作 将继续

24
00:01:26,770 --> 00:01:30,369
在源代码中执行此操作，然后

25
00:01:30,369 --> 00:01:31,990
又将花费在很大的范围内

26
00:01:31,990 --> 00:01:34,990


27
00:01:34,990 --> 00:01:36,579


28
00:01:36,579 --> 00:01:38,529


29
00:01:38,529 --> 00:01:39,999
与我们

30
00:01:39,999 --> 00:01:42,999
本周五在 CIC 大楼的课程中讨论的内容有些相关，

31
00:01:42,999 --> 00:01:45,549
我们将有

32
00:01:45,549 --> 00:01:48,630
来自 Salesforce 的人员的谈话

33
00:01:48,630 --> 00:01:51,340
这是公开的 Salesforce 正在构建一个

34
00:01:51,340 --> 00:01:53,409
全新的数据库管理器系统，以

35
00:01:53,409 --> 00:01:54,429
基于 Postgres 拍摄数据库系统

36
00:01:54,429 --> 00:01:56,920
a 我以前

37
00:01:56,920 --> 00:01:58,840
上过这门课的很多学生现在都

38
00:01:58,840 --> 00:01:59,799


39
00:01:59,799 --> 00:02:02,109
在旧金山的全新

40
00:02:02,109 --> 00:02:04,389
建筑里研究它，这很棒，然后

41
00:02:04,389 --> 00:02:06,819
下周在周一的数据库小组会议

42
00:02:06,819 --> 00:02:09,788
上，我们将有我们的果阿，

43
00:02:09,788 --> 00:02:12,459
他是高级校友 mem sequel 的前工程副总裁，

44
00:02:12,459 --> 00:02:13,989
这是一个

45
00:02:13,989 --> 00:02:15,760
我们可以稍后讨论的内存数据库

46
00:02:15,760 --> 00:02:17,860
，学期她有一个新的

47
00:02:17,860 --> 00:02:19,180
初创公司在做

48
00:02:19,180 --> 00:02:21,519
分析数据库的事情，他

49
00:02:21,519 --> 00:02:23,739
将在下周周一和下周一进行讨论，

50
00:02:23,739 --> 00:02:25,030
所以两个 几周

51
00:02:25,030 --> 00:02:28,030
后我们将有来自 Vertica 的人

52
00:02:28,030 --> 00:02:29,980
来谈谈 Vertica 是一个列

53
00:02:29,980 --> 00:02:31,510
存储数据库系统，其中

54
00:02:31,510 --> 00:02:34,659
一个最著名的系统是由我的研究生导师发明的，并被

55
00:02:34,659 --> 00:02:36,760


56
00:02:36,760 --> 00:02:39,400
HP 和 几年前他们被卖给了一家控股

57
00:02:39,400 --> 00:02:41,260
公司，但请

58
00:02:41,260 --> 00:02:42,310
相信他们实际上在匹兹堡设有办事处

59
00:02:42,310 --> 00:02:44,469
，所以他会

60
00:02:44,469 --> 00:02:45,879
来谈谈你所知道

61
00:02:45,879 --> 00:02:47,560
的他们在这里做的事情，

62
00:02:47,560 --> 00:02:49,060
当我们在一起时 Vertica 正在做的更新的事情中

63
00:02:49,060 --> 00:02:51,400
，如果我已经声明了工作

64
00:02:51,400 --> 00:02:52,480
列存储，那么它现在没有意义

65
00:02:52,480 --> 00:02:54,069
它应该在本讲座结束时有意义，

66
00:02:54,069 --> 00:02:55,659
因为什么将

67
00:02:55,659 --> 00:02:57,730
描述那是什么并且实际上

68
00:02:57,730 --> 00:02:58,930
尝试放弃它并运行 给出一个演示，

69
00:02:58,930 --> 00:03:01,299
比如安装错误太多，我

70
00:03:01,299 --> 00:03:01,989
放弃了，好吧，

71
00:03:01,989 --> 00:03:03,700
所以这些都是免费向

72
00:03:03,700 --> 00:03:05,109
公众开放的，这里有披萨，

73
00:03:05,109 --> 00:03:07,480
还有水果之类的，所以你可以相应地计划你的

74
00:03:07,480 --> 00:03:11,769
饭菜，所以最后一

75
00:03:11,769 --> 00:03:15,010
节课我们开始讨论我们如何

76
00:03:15,010 --> 00:03:17,349
想要设计一个椎间盘角膜

77
00:03:17,349 --> 00:03:19,209
数据库系统，我再次说过一个椎间盘

78
00:03:19,209 --> 00:03:20,709
坐标系是一种数据

79
00:03:20,709 --> 00:03:22,780
系统假设数据库的主要搜索

80
00:03:22,780 --> 00:03:25,060
位置在磁盘上的系统，

81
00:03:25,060 --> 00:03:26,409
所以我们花时间讨论我们

82
00:03:26,409 --> 00:03:28,479
实际上是如何进行的 在页面内的文件中组织

83
00:03:28,479 --> 00:03:30,099
不同级别的数据库

84
00:03:30,099 --> 00:03:32,199
，然后在元组内的这些

85
00:03:32,199 --> 00:03:34,689
页面内组织数据库，

86
00:03:34,689 --> 00:03:36,489
所以我们想要做这一切的原因是因为我们

87
00:03:36,489 --> 00:03:38,139
希望能够支持

88
00:03:38,139 --> 00:03:39,669
大于

89
00:03:39,669 --> 00:03:41,530
内存量的数据库。 我们可以在一

90
00:03:41,530 --> 00:03:43,449
台机器上使用，是的，我知道

91
00:03:43,449 --> 00:03:44,889
你可以分发它，现在可以跨越多个

92
00:03:44,889 --> 00:03:46,989
节点，我们可以忽略所有这些，

93
00:03:46,989 --> 00:03:48,970
只是说你只有一个盒子

94
00:03:48,970 --> 00:03:51,280
，当我们无法容纳所有数据时，我们如何将数据引入

95
00:03:51,280 --> 00:03:53,739
在 d trance 中，所以我们结束

96
00:03:53,739 --> 00:03:56,949
了很多页面的讨论，这只是一个

97
00:03:56,949 --> 00:03:59,500
快速的复习，所以一个带槽的页面是

98
00:03:59,500 --> 00:04:01,569
我们如何在页面内组织元组的方式

99
00:04:01,569 --> 00:04:04,900
，这样我们就可以四处移动

100
00:04:04,900 --> 00:04:06,459
，然后我们开始打包尽可能多的东西

101
00:04:06,459 --> 00:04:08,709
元组尽可能多，所以我们的槽

102
00:04:08,709 --> 00:04:10,720
率在顶部是固定的，而

103
00:04:10,720 --> 00:04:12,370
在底部有很窄的位置，我们只是

104
00:04:12,370 --> 00:04:15,159
从 Gynt

105
00:04:15,159 --> 00:04:16,238
的末尾到开头，

106
00:04:16,238 --> 00:04:17,769
从头到尾不断添加东西，直到我们到达

107
00:04:17,769 --> 00:04:20,349
中间 我们没有 更多的空间，

108
00:04:20,349 --> 00:04:22,509
所以我说这是大多数

109
00:04:22,509 --> 00:04:24,789
数据库分钟系统的主要方式，

110
00:04:24,789 --> 00:04:27,130
它们是烘焙或系统，我将再次

111
00:04:27,130 --> 00:04:28,630
解释它的位置，

112
00:04:28,630 --> 00:04:30,430
这是大多数

113
00:04:30,430 --> 00:04:32,299
数据库系统实际执行的主要方式，

114
00:04:32,299 --> 00:04:35,339
但它不是 唯一的方法，我们

115
00:04:35,339 --> 00:04:37,049
没时间了，我们没有讨论其他的方法

116
00:04:37,049 --> 00:04:38,549
，所以我要简要地谈谈这个，

117
00:04:38,549 --> 00:04:40,709
所以再一次把它放在上下文

118
00:04:40,709 --> 00:04:42,149
中我们本学期将讨论的大部分内容

119
00:04:42,149 --> 00:04:44,189
将是这个组织数据库

120
00:04:44,189 --> 00:04:45,269
您将为您的项目工作的系统

121
00:04:45,269 --> 00:04:46,439
将使用这种类型的

122
00:04:46,439 --> 00:04:48,599
组织，但同样，这不是唯一

123
00:04:48,599 --> 00:04:51,599
的另一种方法称为日志

124
00:04:51,599 --> 00:04:54,839
结构化文件组织，因此

125
00:04:54,839 --> 00:04:56,459
这种工作方式是，而不是

126
00:04:56,459 --> 00:05:00,889
存储完整的元组内部人员和设置 我们的页面

127
00:05:00,889 --> 00:05:03,449
我们只是要

128
00:05:03,449 --> 00:05:06,149
存储有关如何创建或修改该元组的信息，

129
00:05:06,149 --> 00:05:10,860
所以我

130
00:05:10,860 --> 00:05:12,839
所说的坏是什么意思，所以让我们在我们的页面中说，

131
00:05:12,839 --> 00:05:14,819
我们将开始附加这些日志

132
00:05:14,819 --> 00:05:16,469
记录，我会想 它喜欢 商场

133
00:05:16,469 --> 00:05:18,089
记录就像人类读取的文本文件一样

134
00:05:18,089 --> 00:05:19,889
认为 whistle 是一个日志记录

135
00:05:19,889 --> 00:05:22,469
，它是更改内容的二进制表示，

136
00:05:22,469 --> 00:05:25,289
所以我们记录就像我

137
00:05:25,289 --> 00:05:26,909
插入了这个元组我更新了这个管

138
00:05:26,909 --> 00:05:30,089
我删除了这个元组，我们

139
00:05:30,089 --> 00:05:31,559
只是我们所拥有的 要做的就是在

140
00:05:31,559 --> 00:05:33,239
每次翻页时继续添加你知道的每一个

141
00:05:33,239 --> 00:05:35,099
我们可以去创建一个新的并

142
00:05:35,099 --> 00:05:37,339
开始等待更多的杠杆给

143
00:05:37,339 --> 00:05:39,269
任何人我猜你为什么想做这样的

144
00:05:39,269 --> 00:05:46,619
事情是的很容易

145
00:05:46,619 --> 00:05:51,739
他说很容易

146
00:05:53,329 --> 00:05:56,249
可能回滚 是的 是的 就像我有

147
00:05:56,249 --> 00:05:58,529
一千列 如果我有一千

148
00:05:58,529 --> 00:06:00,929
列 如果我需要回滚 我更新一个

149
00:06:00,929 --> 00:06:02,099
我没有吹走单个更新

150
00:06:02,099 --> 00:06:05,329
记录是的 那是一个是的

151
00:06:05,329 --> 00:06:08,159
她说得很快 对 绝对是 所以

152
00:06:08,159 --> 00:06:10,979
记忆 说在特别旋转的

153
00:06:10,979 --> 00:06:12,569
磁盘硬盘驱动器中，但即使是现代 SSD

154
00:06:12,569 --> 00:06:15,089
，执行顺序正确的速度要快得多，

155
00:06:15,089 --> 00:06:16,349
因为我们希望通过访问然后随机访问来读取源淬火，

156
00:06:16,349 --> 00:06:19,589
所以如果我

157
00:06:19,589 --> 00:06:22,469
回到这种模式，假设我更新了你

158
00:06:22,469 --> 00:06:24,089
知道 十个两个池，但它们现在都在

159
00:06:24,089 --> 00:06:25,949
不同的页面

160
00:06:25,949 --> 00:06:28,229


161
00:06:28,229 --> 00:06:30,360


162
00:06:30,360 --> 00:06:32,879


163
00:06:32,879 --> 00:06:34,829


164
00:06:34,829 --> 00:06:38,369
中 一口气写出来，这样你就会

165
00:06:38,369 --> 00:06:40,349
明白，这个想法并不像

166
00:06:40,349 --> 00:06:42,269
1980 年代末 1990 年代初期出现的那样

167
00:06:42,269 --> 00:06:43,739


168
00:06:43,739 --> 00:06:45,509
新鲜

169
00:06:45,509 --> 00:06:46,010


170
00:06:46,010 --> 00:06:49,430


171
00:06:49,430 --> 00:06:53,030


172
00:06:53,030 --> 00:06:56,330
像 HDFS 或 s3 之类的东西，所有

173
00:06:56,330 --> 00:06:58,010
这些 - 分布式文件系统，其中

174
00:06:58,010 --> 00:07:00,350
只有挂起，您不能进行随机

175
00:07:00,350 --> 00:07:01,760
更新，您只能保留附加

176
00:07:01,760 --> 00:07:04,490
记录，因此这种存储

177
00:07:04,490 --> 00:07:07,610
元组的方式非常适合这种情况，所以有

178
00:07:07,610 --> 00:07:11,260
什么明显的缺点 这个

179
00:07:11,260 --> 00:07:14,090
她说绝对是的，所以如果我

180
00:07:14,090 --> 00:07:16,610
现在必须阅读一个元组，我必须

181
00:07:16,610 --> 00:07:18,380
回到过去并查看日志并尝试

182
00:07:18,380 --> 00:07:20,570
弄清楚如果人们

183
00:07:20,570 --> 00:07:23,150
看起来像什么等等元组的最终

184
00:07:23,150 --> 00:07:25,700
结果是什么  是的，所以如果我

185
00:07:25,700 --> 00:07:27,440
看到我在这里更新元组并且我

186
00:07:27,440 --> 00:07:28,520
有一千列但我没有

187
00:07:28,520 --> 00:07:30,320
更新其中一个我必须回去

188
00:07:30,320 --> 00:07:32,720
尝试找到它插入的位置更新

189
00:07:32,720 --> 00:07:34,220
了其他一千列以将其

190
00:07:34,220 --> 00:07:37,130
放回 你想要的形式，

191
00:07:37,130 --> 00:07:39,380
所以有一些方法可以加快它的速度

192
00:07:39,380 --> 00:07:41,240
，你可以建立索引，

193
00:07:41,240 --> 00:07:42,140
如果我正在寻找一个特定的

194
00:07:42,140 --> 00:07:44,810
元组，这里是如何跳转到

195
00:07:44,810 --> 00:07:46,160
日志中的特定偏移量

196
00:07:46,160 --> 00:07:48,920
的方法 想要或

197
00:07:48,920 --> 00:07:50,900
你可以做的另一件事是说只是去实际

198
00:07:50,900 --> 00:07:54,290
重播日志并将其压缩

199
00:07:54,290 --> 00:07:57,590
，只是你知道

200
00:07:57,590 --> 00:07:59,840
每个元组只有一条记录，所以我可以把

201
00:07:59,840 --> 00:08:01,970
所有这些人都拿走，然后把它转换

202
00:08:01,970 --> 00:08:04,250
回你知道的 是否有元组

203
00:08:04,250 --> 00:08:07,250
形式，所以正如我所说，这在

204
00:08:07,250 --> 00:08:08,420
最近的系统中更为常见，其中一些您

205
00:08:08,420 --> 00:08:10,670
可能听说过 HBase Cassandra

206
00:08:10,670 --> 00:08:12,410
有很多分布式

207
00:08:12,410 --> 00:08:13,370
系统是我

208
00:08:13,370 --> 00:08:14,180
编写的，并且

209
00:08:14,180 --> 00:08:15,800
像 cockroach DB 这样的东西在那里

210
00:08:15,800 --> 00:08:18,500
所有使用rocks DB作为th 底层

211
00:08:18,500 --> 00:08:19,490
存储管理器

212
00:08:19,490 --> 00:08:20,510
好吧，所以分布式执行

213
00:08:20,510 --> 00:08:22,880
层是全部和去，但然后在

214
00:08:22,880 --> 00:08:25,220
幕后岩石 DBS 和 C++ 等等，

215
00:08:25,220 --> 00:08:26,240
而不是编写他们自己的存储

216
00:08:26,240 --> 00:08:27,920
管理器，它依赖于它就像

217
00:08:27,920 --> 00:08:31,010
一个嵌入式系统，所以岩石 DB

218
00:08:31,010 --> 00:08:32,870
来自来自 Facebook  Facebook 实际上

219
00:08:32,870 --> 00:08:34,460
生锈的 B 严格基于级别 DB

220
00:08:34,460 --> 00:08:36,830
级别 DB 是由谷歌编写的，然后

221
00:08:36,830 --> 00:08:38,630
Facebook 采取的第一件事

222
00:08:38,630 --> 00:08:41,450
就是删除 M 地图，然后他们

223
00:08:41,450 --> 00:08:43,970
真的发布了它，因为 Roxy 级别

224
00:08:43,970 --> 00:08:45,110
DB 仍然存在，但几乎

225
00:08:45,110 --> 00:08:48,380
每个人都使用岩石 DB 所以

226
00:08:48,380 --> 00:08:49,760
我们不会

227
00:08:49,760 --> 00:08:52,040
在本学期剩下的时间里真正讨论这个，它会在

228
00:08:52,040 --> 00:08:53,120
我们稍后讨论分布式数据库

229
00:08:53,120 --> 00:08:55,790
时出现，但出于我们的目的，

230
00:08:55,790 --> 00:08:56,930
我们只是假设我们正在

231
00:08:56,930 --> 00:08:59,480
处理 疲倦的分页系统

232
00:08:59,480 --> 00:09:03,800
好吧 所以今天的课程我们

233
00:09:03,800 --> 00:09:05,300
现在想更深入地

234
00:09:05,300 --> 00:09:07,639
讨论我们实际上将如何

235
00:09:07,639 --> 00:09:10,130
表示元组中的数据 所以

236
00:09:10,130 --> 00:09:11,329
我们再次说数据库是

237
00:09:11,329 --> 00:09:13,610
重新 由一堆页面呈现，然后

238
00:09:13,610 --> 00:09:14,899
我们讨论了如何将

239
00:09:14,899 --> 00:09:16,970
堆文件分解为页面，然后当这些

240
00:09:16,970 --> 00:09:17,959
页面我们讨论如何

241
00:09:17,959 --> 00:09:20,540
表示带槽的数组，然后我们

242
00:09:20,540 --> 00:09:22,040
粗略地说在数组的每个槽内

243
00:09:22,040 --> 00:09:23,630
你有这些槽 然后

244
00:09:23,630 --> 00:09:25,550
你的元组有一个标题，现在

245
00:09:25,550 --> 00:09:27,019
在元组中，我们想说明

246
00:09:27,019 --> 00:09:28,579
单个属性或列的数据实际上是什么样子的，

247
00:09:28,579 --> 00:09:30,529
我们

248
00:09:30,529 --> 00:09:32,899
实际上将如何表示，然后我们将

249
00:09:32,899 --> 00:09:34,579
继续讨论我们如何实际

250
00:09:34,579 --> 00:09:36,800
存储 关于我们的表是什么样子的元数据

251
00:09:36,800 --> 00:09:38,930
然后我们将

252
00:09:38,930 --> 00:09:40,130
讨论行存储

253
00:09:40,130 --> 00:09:43,970
与列存储

254
00:09:43,970 --> 00:09:47,240


255
00:09:47,240 --> 00:09:50,720


256
00:09:50,720 --> 00:09:52,130
的存储模型 到数据库管理

257
00:09:52,130 --> 00:09:53,630
系统，以便能够解释该字节

258
00:09:53,630 --> 00:09:55,160
数组并理解它并说哦，

259
00:09:55,160 --> 00:09:56,930
是的，如果这是一个整数，

260
00:09:56,930 --> 00:09:58,850
这是一个浮点数，这是一个字符串，

261
00:09:58,850 --> 00:10:01,459
你知道属性，所以这基本上是

262
00:10:01,459 --> 00:10:02,810
l 我们在这里所做的我们只是

263
00:10:02,810 --> 00:10:04,639
像组织这些字节数组一样组织我们的元组

264
00:10:04,639 --> 00:10:06,769
，然后当

265
00:10:06,769 --> 00:10:08,060
需要执行查询时，我们需要解释

266
00:10:08,060 --> 00:10:09,740
这些字节数组中的实际内容以

267
00:10:09,740 --> 00:10:10,790
产生我们正在寻找的答案

268
00:10:10,790 --> 00:10:13,370
和 所以如果这是目录的

269
00:10:13,370 --> 00:10:14,480
内容将在下一秒讨论的内容，这

270
00:10:14,480 --> 00:10:15,680
就是他们将如何弄清楚哦，我

271
00:10:15,680 --> 00:10:17,779
有 10 列，第一个是

272
00:10:17,779 --> 00:10:19,459
32 位整数，下一个是 64 位

273
00:10:19,459 --> 00:10:21,740
浮点数，它使用该信息决定

274
00:10:21,740 --> 00:10:23,600
如何解释和解密这些

275
00:10:23,600 --> 00:10:29,750
字节，所以我们将用于

276
00:10:29,750 --> 00:10:30,980
大多数数据库系统的方式我们将

277
00:10:30,980 --> 00:10:33,889
用于表示数据的方式是固定长度的

278
00:10:33,889 --> 00:10:36,260
东西，例如整数和浮点数，

279
00:10:36,260 --> 00:10:38,000
通常与

280
00:10:38,000 --> 00:10:41,480
我们在 C 或 C++ 这

281
00:10:41,480 --> 00:10:43,160
通常是由所谓的 I

282
00:10:43,160 --> 00:10:45,920
Triple E 754 标准定义

283
00:10:45,920 --> 00:10:46,610


284
00:10:46,610 --> 00:10:49,490
的

285
00:10:49,490 --> 00:10:52,190


286
00:10:52,190 --> 00:10:55,430


287
00:10:55,430 --> 00:10:57,829


288
00:10:57,829 --> 00:11:01,370
代表nu  mbers 和 CPU 之类的

289
00:11:01,370 --> 00:11:02,779
整数和浮点数之类的东西

290
00:11:02,779 --> 00:11:05,269
你知道的有多少位 你知道的

291
00:11:05,269 --> 00:11:07,730
地方是大端小端 你知道

292
00:11:07,730 --> 00:11:09,019
前面有二进制补码

293
00:11:09,019 --> 00:11:11,540
所有在那个标准中表示的都是

294
00:11:11,540 --> 00:11:12,880


295
00:11:12,880 --> 00:11:14,740
固定的 - 长度类型和整数

296
00:11:14,740 --> 00:11:16,240
大、小和小末端，然后是

297
00:11:16,240 --> 00:11:19,330
浮动卷轴 我们将只遵循 754

298
00:11:19,330 --> 00:11:21,340
标准 我们将在稍后

299
00:11:21,340 --> 00:11:23,260
讨论定点小数但基本上

300
00:11:23,260 --> 00:11:24,940
这些是浮点 然后这些

301
00:11:24,940 --> 00:11:26,380
是定点 这是一些东西 我们

302
00:11:26,380 --> 00:11:27,460
和数据系统将不得不

303
00:11:27,460 --> 00:11:30,400


304
00:11:30,400 --> 00:11:32,670
为我们的二进制技术和 blob 的非常长的东西实现 varchars

305
00:11:32,670 --> 00:11:36,160
通常有一个标题说你

306
00:11:36,160 --> 00:11:38,590
知道你知道这里是

307
00:11:38,590 --> 00:11:40,570
我正在存储的 blob 的长度或

308
00:11:40,570 --> 00:11:42,580
非常长的 odom 的栏

309
00:11:42,580 --> 00:11:44,380
如果它是一个非常大的大

310
00:11:44,380 --> 00:11:46,750
值，则存储可能是一个校验和，然后您拥有

311
00:11:46,750 --> 00:11:48,580
字节序列，因此这与

312
00:11:48,580 --> 00:11:50,320
表示字符串不同，并查看您

313
00:11:50,320 --> 00:11:52,120
在何处拥有空终止符，

314
00:11:52,120 --> 00:11:53,380
而不是我们 c 应该有一个前缀来告诉

315
00:11:53,380 --> 00:11:55,500


316
00:11:55,500 --> 00:11:59,020
我们日期和时间戳的实际大小这

317
00:11:59,020 --> 00:12:00,820
在不同的数据库系统之间差异很大，

318
00:12:00,820 --> 00:12:02,200
没有一种方法可以实际执行

319
00:12:02,200 --> 00:12:02,560
此操作，

320
00:12:02,560 --> 00:12:05,020
大多数系统通常只

321
00:12:05,020 --> 00:12:08,770
存储您知道的秒数 或

322
00:12:08,770 --> 00:12:10,930
自 UNIX 时代以来的微秒或毫秒

323
00:12:10,930 --> 00:12:12,970
，

324
00:12:12,970 --> 00:12:15,970
例如 Windows 的 1970 年 1 月

325
00:12:15,970 --> 00:12:18,010


326
00:12:18,010 --> 00:12:19,780
1 日

327
00:12:19,780 --> 00:12:21,250


328
00:12:21,250 --> 00:12:23,560
封面下的日期仍然

329
00:12:23,560 --> 00:12:26,560
会存储完整的时间戳，它

330
00:12:26,560 --> 00:12:28,930
只是您用来访问该数据的 API

331
00:12:28,930 --> 00:12:30,910
知道删除

332
00:12:30,910 --> 00:12:32,920
您不需要的任何部分，所以有些系统

333
00:12:32,920 --> 00:12:34,090
实际上只会打包日期

334
00:12:34,090 --> 00:12:35,350
，我们 将其存储为较小的较小

335
00:12:35,350 --> 00:12:37,270
值 一堆系统实际上

336
00:12:37,270 --> 00:12:41,530
不做任何事情所以这又是

337
00:12:41,530 --> 00:12:43,270
我们在我们的数据库系统中拥有的东西 这是

338
00:12:43,270 --> 00:12:44,170
我们实现我们的数据库

339
00:12:44,170 --> 00:12:45,910
系统的东西但是对于

340
00:12:45,910 --> 00:12:48,160
定点值 这将仅取决于您是否知道

341
00:12:48,160 --> 00:12:49,810
c++ 给我们的任何内容都应该是

342
00:12:49,810 --> 00:12:52,810
底层硬件

343
00:12:52,810 --> 00:12:54,490


344
00:12:54,490 --> 00:12:55,840


345
00:12:55,840 --> 00:12:57,790


346
00:12:57,790 --> 00:12:59,730


347
00:12:59,730 --> 00:13:01,870
如果你想浮动我的小数

348
00:13:01,870 --> 00:13:04,390
或非常精确的数字，我这些是

349
00:13:04,390 --> 00:13:07,810
CPU 给我们的精确数字，或者

350
00:13:07,810 --> 00:13:10,240
像你的 C++ 给我们的，因为我你

351
00:13:10,240 --> 00:13:11,710
有 ac 程序，我称你知道一个

352
00:13:11,710 --> 00:13:13,360
声明的变量 float 什么，并

353
00:13:13,360 --> 00:13:15,550
给它一个口头

354
00:13:15,550 --> 00:13:18,040
当我们

355
00:13:18,040 --> 00:13:20,350
在我们的数据库系统中将一个实数或双精度数或浮点数

356
00:13:20,350 --> 00:13:22,930
用作续集类型时，这就是我们得到的口头名称，这是

357
00:13:22,930 --> 00:13:24,460
指定的实际表示方式，

358
00:13:24,460 --> 00:13:26,290
如小数点和

359
00:13:26,290 --> 00:13:27,970
精度

360
00:13:27,970 --> 00:13:32,380
范围 754 标准，所以这些

361
00:13:32,380 --> 00:13:34,930
对于执行者来说操作会比

362
00:13:34,930 --> 00:13:37,389


363
00:13:37,389 --> 00:13:40,750
马铃薯系统提供的定点小数快得多，因为

364
00:13:40,750 --> 00:13:42,759
CPU 有指令可以非常有效地操作这些

365
00:13:42,759 --> 00:13:45,490
tly 写了一条指令

366
00:13:45,490 --> 00:13:46,870
来获取浮点数并将它们加

367
00:13:46,870 --> 00:13:49,959
在一起或减去它们但是当我们

368
00:13:49,959 --> 00:13:52,389
谈论处理定点的时候

369
00:13:52,389 --> 00:13:53,680
，我们

370
00:13:53,680 --> 00:13:54,790
必须写一大堆东西，这意味着更多的

371
00:13:54,790 --> 00:13:58,329
指令，所以这听起来像

372
00:13:58,329 --> 00:13:59,829
我们' 我想正确使用，因为它

373
00:13:59,829 --> 00:14:01,779
很快，尽管手掌会出现

374
00:14:01,779 --> 00:14:05,139
四舍五入错误，因为 74 标准

375
00:14:05,139 --> 00:14:07,149
就像没有办法

376
00:14:07,149 --> 00:14:10,149
在硬件中准确存储小数，所以他们必须

377
00:14:10,149 --> 00:14:12,850
正确地近似，所以这是一个

378
00:14:12,850 --> 00:14:14,829
非常简单的 C 程序，我通常不会

379
00:14:14,829 --> 00:14:16,300
除了续集，我不喜欢课堂上的节目代码，

380
00:14:16,300 --> 00:14:18,310
但这很简单，我想

381
00:14:18,310 --> 00:14:19,800
你知道你应该能够

382
00:14:19,800 --> 00:14:22,089
从座位上理解它，所以

383
00:14:22,089 --> 00:14:23,980
我们要做的就是我们有两个浮点数 x

384
00:14:23,980 --> 00:14:26,259
和 y 然后我们要 打印

385
00:14:26,259 --> 00:14:28,300
出 X 加 y 的值，然后我们

386
00:14:28,300 --> 00:14:31,420
将打印出常量 0.3，所以你

387
00:14:31,420 --> 00:14:33,459
选择你最喜欢的编译器我使用 GCC

388
00:14:33,459 --> 00:14:35,199
，当你编译它时，你会

389
00:14:35,199 --> 00:14:37,690
在这里得到这个答案，看起来你知道

390
00:14:37,690 --> 00:14:39,010
这是正确的

391
00:14:39,010 --> 00:14:43,930
我会期待，但我所做的只是做

392
00:14:43,930 --> 00:14:45,579
你的百分比时间应用程序我只是

393
00:14:45,579 --> 00:14:47,560
要求语言打印出

394
00:14:47,560 --> 00:14:49,300
浮点数，并让它做任何

395
00:14:49,300 --> 00:14:52,510
它想做的四舍五入，当你指定

396
00:14:52,510 --> 00:14:55,269
你真正想要的精度时

397
00:14:55,269 --> 00:14:57,730
我将进入 20 个小数点然后你会

398
00:14:57,730 --> 00:14:58,810
看到你得到一个完全不同的

399
00:14:58,810 --> 00:15:02,800
数字 相同的精确代码 相同的精确

400
00:15:02,800 --> 00:15:05,350
值 只是当我以人类

401
00:15:05,350 --> 00:15:07,540
可读的形式表示它 现在我看到我已经偏离了

402
00:15:07,540 --> 00:15:12,160
正确的我可以 甚至不能得到 0.3 正确我能

403
00:15:12,160 --> 00:15:14,490
这是因为港口也不能完全

404
00:15:14,490 --> 00:15:17,680
表示浮点数你

405
00:15:17,680 --> 00:15:22,389
知道的完全正确所以这

406
00:15:22,389 --> 00:15:23,740
对我们来说执行起来会更快但是我们

407
00:15:23,740 --> 00:15:26,139
会有舍入错误所以现在你

408
00:15:26,139 --> 00:15:27,130
知道这意味着 你可能认为没问题

409
00:15:27,130 --> 00:15:28,839
0.3 我这里的小例子谁关心

410
00:15:28,839 --> 00:15:30,639
哪里有四舍五入错误，但

411
00:15:30,639 --> 00:15:32,949
如果是你的银行账户，那么你开始

412
00:15:32,949 --> 00:15:34,770
关心，

413
00:15:34,770 --> 00:15:36,630
或者如果它是一个科学的你知道的

414
00:15:36,630 --> 00:15:38,430
仪器，你试图将

415
00:15:38,430 --> 00:15:40,529
一些东西送入太空，这些圆毛

416
00:15:40,529 --> 00:15:43,680
会导致真实 问题 ems 所以为了避免这种情况你

417
00:15:43,680 --> 00:15:45,420
使用所谓的固定精度

418
00:15:45,420 --> 00:15:48,020
数字或选择点十进制数字

419
00:15:48,020 --> 00:15:50,339
所以这些是

420
00:15:50,339 --> 00:15:51,690
ATM 系统必须实现的东西来表示

421
00:15:51,690 --> 00:15:53,670
这些值它是一堆额外的代码

422
00:15:53,670 --> 00:15:56,430
，可以处理所有你知道的

423
00:15:56,430 --> 00:15:58,980
算术

424
00:15:58,980 --> 00:16:00,750
您通常不想对任何

425
00:16:00,750 --> 00:16:04,920
类型的数字进行操作或聚合，因此您所知道的方式

426
00:16:04,920 --> 00:16:06,810
显示了 Postgres 将如何在一秒钟内执行此操作，

427
00:16:06,810 --> 00:16:08,370
但考虑这一点的基本思想

428
00:16:08,370 --> 00:16:11,550
是您将像这样存储该值

429
00:16:11,550 --> 00:16:14,010
varchar' 值的实际类似人类

430
00:16:14,010 --> 00:16:16,950
可读的表示，

431
00:16:16,950 --> 00:16:19,020
然后是一些额外的元数据来说明

432
00:16:19,020 --> 00:16:20,310
这里的小数点是

433
00:16:20,310 --> 00:16:21,810
什么范围是这里的四舍五入

434
00:16:21,810 --> 00:16:23,880
信息正确并且所有这些

435
00:16:23,880 --> 00:16:26,580
都与元组本身打包在一起，作为其中的

436
00:16:26,580 --> 00:16:29,790
一部分 那个字节数组，所以我

437
00:16:29,790 --> 00:16:31,440
每年都会在 Postgres 和

438
00:16:31,440 --> 00:16:33,690
续集服务器上做这个演示，通常我没有人

439
00:16:33,690 --> 00:16:35,630
给过 Postgres，

440
00:16:35,630 --> 00:16:37,920
但我们也会尝试使用 Oracle 和单

441
00:16:37,920 --> 00:16:39,810
服务器，所以让我们看看

442
00:16:39,810 --> 00:16:40,890
p 性能差异来自

443
00:16:40,890 --> 00:16:46,040
这些不同类型的不同

444
00:16:46,040 --> 00:16:50,040
关闭 为什么可读性

445
00:16:50,040 --> 00:16:53,399
很好 所以我所做的是我创建了一个我

446
00:16:53,399 --> 00:16:56,520
编写了一个简单的 Python 脚本 它

447
00:16:56,520 --> 00:17:02,310
所做的只是创建了一个巨大的 CSV 文件，其中包含

448
00:17:02,310 --> 00:17:04,500
一千万个 行到浮点数就行了

449
00:17:04,500 --> 00:17:06,449
，就是这样，

450
00:17:06,449 --> 00:17:09,150
您只需输入随机数，这样我就可以

451
00:17:09,150 --> 00:17:11,069
加载它了 我将在 Postgres 中创建两个表

452
00:17:11,069 --> 00:17:15,000
我将创建一个使用

453
00:17:15,000 --> 00:17:18,000
实数和一个使用

454
00:17:18,000 --> 00:17:21,300
定点小数 所以有一个

455
00:17:21,300 --> 00:17:24,209
用于实数，一个用于小数，

456
00:17:24,209 --> 00:17:27,809
然后 Postgres 有一个很好的命令，称为

457
00:17:27,809 --> 00:17:32,010
copy，它将获取本地磁盘上的文件

458
00:17:32,010 --> 00:17:34,140
，然后获取输出并将

459
00:17:34,140 --> 00:17:38,370
其写入表中 各种数据库

460
00:17:38,370 --> 00:17:40,590
系统有各种命令和

461
00:17:40,590 --> 00:17:43,559
称为批量输入的秘密服务器 在我的续集中，它

462
00:17:43,559 --> 00:17:46,830
被称为加载到任何 Oracle 是

463
00:17:46,830 --> 00:17:48,450
一个痛苦的设置，但我让它工作，

464
00:17:48,450 --> 00:17:51,179
所以现在我们要做的是我们将

465
00:17:51,179 --> 00:17:55,230
运行一个查询，只获取两个

466
00:17:55,230 --> 00:17:56,700
数字并将它们加在一起，所以让我

467
00:17:56,700 --> 00:17:59,789
关闭 n 时间也是如此，然后因为

468
00:17:59,789 --> 00:18:02,399
这是 Postgres 10 Postgres 10 添加

469
00:18:02,399 --> 00:18:05,190
了对并行查询的支持，所以就像您

470
00:18:05,190 --> 00:18:06,419
知道将单个查询

471
00:18:06,419 --> 00:18:07,889
拆分到多个 CPU 并

472
00:18:07,889 --> 00:18:09,629
并行运行它们，所以我也将关闭它

473
00:18:09,629 --> 00:18:11,730
我们看到

474
00:18:11,730 --> 00:18:13,169
像一行的性能你知道一个

475
00:18:13,169 --> 00:18:15,450
CPU 我也会为所有其他

476
00:18:15,450 --> 00:18:18,389
系统这样做所以让

477
00:18:18,389 --> 00:18:24,899
我们看看如果我用真实的东西做需要多长时间所以

478
00:18:24,899 --> 00:18:26,489
如果你从来没有见过这个让我

479
00:18:26,489 --> 00:18:30,779
回到语法抱歉所以填充说

480
00:18:30,779 --> 00:18:32,850
解释分析所以如果你从未见过

481
00:18:32,850 --> 00:18:35,159
解释解释的作用并将其放在

482
00:18:35,159 --> 00:18:37,049
任何续集查询的前面，而不是

483
00:18:37,049 --> 00:18:38,340
实际运行续集查询，

484
00:18:38,340 --> 00:18:40,109
它会告诉你它将使用什么查询计划

485
00:18:40,109 --> 00:18:42,629
来执行此查询 好吧，实际上并没有

486
00:18:42,629 --> 00:18:43,590
运行 它说

487
00:18:43,590 --> 00:18:45,989
如果我运行它，这就是我要做的事情 不同的数据

488
00:18:45,989 --> 00:18:47,399
系统具有不同的语法 这

489
00:18:47,399 --> 00:18:49,590
就是 Postgres 和我的续集所做的正确

490
00:18:49,590 --> 00:18:51,239
我们将解释什么是查询计划

491
00:18:51,239 --> 00:18:52,950
我要优化它 迷宫优化

492
00:18:52,950 --> 00:18:55,350
器优化器迟到了 在这个学期，但

493
00:18:55,350 --> 00:18:56,850
基本上发生了什么，你知道只是

494
00:18:56,850 --> 00:18:57,720
说你想在这里运行这个查询，

495
00:18:57,720 --> 00:18:59,879
这就是我们要这样做的方式，但如果我

496
00:18:59,879 --> 00:19:02,239
在它前面添加分析调用，

497
00:19:02,239 --> 00:19:04,499
那么这实际上会给你

498
00:19:04,499 --> 00:19:09,389
查询计划并运行 它是真实的，所以

499
00:19:09,389 --> 00:19:11,429
你看到它基本上花了

500
00:19:11,429 --> 00:19:13,379
122200 毫秒，所以

501
00:19:13,379 --> 00:19:15,509
1.2 秒来运行它然后向

502
00:19:15,509 --> 00:19:17,220
你展示它是否不是缓存效果我

503
00:19:17,220 --> 00:19:18,539
可以一遍又一遍地继续执行

504
00:19:18,539 --> 00:19:21,149
，性能我得到了一点点，

505
00:19:21,149 --> 00:19:22,950
因为它 进入缓存，但它

506
00:19:22,950 --> 00:19:24,539
应该稳定 是的，大约 800

507
00:19:24,539 --> 00:19:27,359
毫秒，所以让我们

508
00:19:27,359 --> 00:19:31,100
现在对十进制数做同样的事情，

509
00:19:34,670 --> 00:19:36,950
所以 2.4 秒我再次运行它，我们应该

510
00:19:36,950 --> 00:19:39,560
会快一点，因为它是现金，

511
00:19:39,560 --> 00:19:43,700
不太正确，所以再次使用相同的值 相同的

512
00:19:43,700 --> 00:19:45,350
数据集将其加载为不同的数据

513
00:19:45,350 --> 00:19:48,940
类型，但尽管一个查询的

514
00:19:48,940 --> 00:19:52,310
速度慢了两倍，因为我们正在做所有

515
00:19:52,310 --> 00:19:53,630
这些额外的事情来处理

516
00:19:53,630 --> 00:19:56,050
舍入和其他事情，

517
00:19:56,050 --> 00:19:58,220
你看，让我看看我是否尝试 r  un

518
00:19:58,220 --> 00:20:01,370
skin 获得相同的值，

519
00:20:01,370 --> 00:20:02,450
他们在这里获得给定的值是

520
00:20:02,450 --> 00:20:03,680
正确的，因为这是因为存在一些

521
00:20:03,680 --> 00:20:05,690
四舍五入的问题，所以我们可以尝试将其

522
00:20:05,690 --> 00:20:11,030
投射到桌面鼹鼠，然后

523
00:20:11,030 --> 00:20:16,730
它将是人类可读的，

524
00:20:16,730 --> 00:20:19,220
这就是 与

525
00:20:19,220 --> 00:20:22,100
这里的这个有很大不同，这是你知道的

526
00:20:22,100 --> 00:20:25,430
，它以 9 开头，所以

527
00:20:25,430 --> 00:20:29,120
真正的有舍入问题，所以

528
00:20:29,120 --> 00:20:31,580
让我们在续集服务器中尝试同样的事情，

529
00:20:31,580 --> 00:20:33,650
数据已经加载，所以

530
00:20:33,650 --> 00:20:35,480
我们不 不需要再次加载它

531
00:20:35,480 --> 00:20:41,240
，所以让我运行它，这将

532
00:20:41,240 --> 00:20:46,670
与结果产生的实数有关，并

533
00:20:46,670 --> 00:20:49,610
告诉我它花了 1.5 秒再试

534
00:20:49,610 --> 00:20:50,030


535
00:20:50,030 --> 00:20:54,100
一次，看看它是否变得更快

536
00:20:54,100 --> 00:20:57,680
，然后我将运行 现在

537
00:20:57,680 --> 00:21:01,970
与小数点相同，它应该

538
00:21:01,970 --> 00:21:07,700
更慢是的两倍，我们再次运行

539
00:21:07,700 --> 00:21:12,020
不赞成，并且有这个小的

540
00:21:12,020 --> 00:21:14,690
最大 dop 它是并行度

541
00:21:14,690 --> 00:21:16,070
它基本上告诉续集银

542
00:21:16,070 --> 00:21:19,070
再次运行它与一个线程

543
00:21:19,070 --> 00:21:21,830
最后一个在我的 显示是 Ora  cle 和我

544
00:21:21,830 --> 00:21:23,030
本周末取得了突破，我想出

545
00:21:23,030 --> 00:21:25,690
了如何在工作中启动键，所以

546
00:21:25,690 --> 00:21:29,420
默认情况下它不是

547
00:21:29,420 --> 00:21:31,700
很好，所以它已经加载了我会

548
00:21:31,700 --> 00:21:35,870
做同样的事情它在哪里 Oracle 所以

549
00:21:35,870 --> 00:21:39,070
我们将在

550
00:21:39,800 --> 00:21:46,180
运行时打开计时 它与卷轴，你得到

551
00:21:46,180 --> 00:21:56,090
0.53 小数点同样略

552
00:21:56,090 --> 00:22:01,040
快，即使如此，这里发生的事情

553
00:22:01,040 --> 00:22:02,540
是 Oracle 实际上给

554
00:22:02,540 --> 00:22:04,340
你定点小数点，无论

555
00:22:04,340 --> 00:22:06,830
你需要用实数还是小数点问你，

556
00:22:06,830 --> 00:22:08,870
它总是只给你

557
00:22:08,870 --> 00:22:12,320
小数点右边，在你说哦之前，看看

558
00:22:12,320 --> 00:22:13,760
Oracle 比其他任何一个快多少

559
00:22:13,760 --> 00:22:16,130
，就像我没有

560
00:22:16,130 --> 00:22:18,980
关闭多线程一样，但

561
00:22:18,980 --> 00:22:21,380
看起来四舍五入很多，这

562
00:22:21,380 --> 00:22:22,790
看起来比我们的要快 d 期望来自

563
00:22:22,790 --> 00:22:24,500
Postgres 和 seagull 服务器，那是

564
00:22:24,500 --> 00:22:26,510
因为 Oracle 有这样的东西，如果

565
00:22:26,510 --> 00:22:30,680
输出的大小不

566
00:22:30,680 --> 00:22:32,990
适合您指定的任何字符，

567
00:22:32,990 --> 00:22:34,340
但是没有东西，那么它

568
00:22:34,340 --> 00:22:36,320
会自动为您舍入它，我花了

569
00:22:36,320 --> 00:22:37,340
一段时间才弄清楚  那个，但

570
00:22:37,340 --> 00:22:38,360
这里实际上是当你

571
00:22:38,360 --> 00:22:39,650
有实数时你得到的，所以它看起来像

572
00:22:39,650 --> 00:22:41,540
我们所期望的，所以再次

573
00:22:41,540 --> 00:22:43,970
提醒你，你

574
00:22:43,970 --> 00:22:45,560
知道这是我们必须在我们的数据库系统中实现的，

575
00:22:45,560 --> 00:22:47,030
这不是

576
00:22:47,030 --> 00:22:51,020
你想要的 知道魔法会走得更快这

577
00:22:51,020 --> 00:22:52,070
不是我们可以依靠的东西很难

578
00:22:52,070 --> 00:22:59,150
为我们提供是的问题是它

579
00:22:59,150 --> 00:23:00,620
在此过程中进行四舍五入是仅

580
00:23:00,620 --> 00:23:02,750
在最后这里作为注释但是

581
00:23:02,750 --> 00:23:04,820
这个愚蠢的麻木嘴唇它

582
00:23:04,820 --> 00:23:06,770
在客户端上四舍五入 一边所以服务器

583
00:23:06,770 --> 00:23:09,380
给你这个，然后当

584
00:23:09,380 --> 00:23:11,960
它落在客户端上时它

585
00:23:11,960 --> 00:23:14,840


586
00:23:14,840 --> 00:23:16,460


587
00:23:16,460 --> 00:23:17,930
会

588
00:23:17,930 --> 00:23:19,700
回合

589
00:23:19,700 --> 00:23:24,050
我们可以在服务器端执行round函数，

590
00:23:24,050 --> 00:23:25,010
所以我认为我们可以做类似这

591
00:23:25,010 --> 00:23:28,490
一轮的事情，然后你说 -

592
00:23:28,490 --> 00:23:35,380
你想要什么样的精度 - 不，

593
00:23:35,380 --> 00:23:37,040
区别不是不同的事情

594
00:23:37,040 --> 00:23:38,570
是我认为这是我的续集语法我

595
00:23:38,570 --> 00:23:39,500
不知道 ' 不知道我不知道什么 Postgres

596
00:23:39,500 --> 00:23:43,820
好吧所以你做 neut 但在你的

597
00:23:43,820 --> 00:23:44,780
应用程序中你想在

598
00:23:44,780 --> 00:23:46,460
客户端或服务器端做它你

599
00:23:46,460 --> 00:23:47,510
想让服务器为你做你

600
00:23:47,510 --> 00:23:48,590
不想假设客户端会

601
00:23:48,590 --> 00:23:51,400
格式化 不管对你来说是的

602
00:23:51,400 --> 00:23:53,680
所以在 Oracle 中

603
00:23:53,680 --> 00:23:57,870
看起来小数在这里给出了相同的值

604
00:23:58,230 --> 00:24:00,550
所以他的问题是它看起来像

605
00:24:00,550 --> 00:24:02,860
Oracle 给了我们

606
00:24:02,860 --> 00:24:06,580
实数而不是浮动框的值 是的

607
00:24:06,580 --> 00:24:10,480
，让我们看看这三个 那是

608
00:24:10,480 --> 00:24:15,870
甲骨文，

609
00:24:16,410 --> 00:24:29,710
让我们试试续集服务器 sis 这就是

610
00:24:29,710 --> 00:24:31,450
我们认为是正确的，因为它是

611
00:24:31,450 --> 00:24:33,640
续集服务器，但那是九个

612
00:24:33,640 --> 00:24:35,410
东西，让我们看看这给了

613
00:24:35,410 --> 00:24:39,580
我们九个东西它

614
00:24:39,580 --> 00:24:46,030
看起来一样对是的，

615
00:24:46,030 --> 00:24:47,980
这与真实的不同 给了我们，

616
00:24:47,980 --> 00:24:50,440
我认为 Reals 给了我们

617
00:24:50,440 --> 00:24:53,910
七点七分，这是七点五分，

618
00:24:53,910 --> 00:25:03,100
所以回到甲骨文说这是

619
00:25:03,100 --> 00:25:13,090
按太多终端是的，但

620
00:25:13,090 --> 00:25:20,830
它是一样的嗯，我不，我不只是

621
00:25:20,830 --> 00:25:25,860
输入它作为现场 但链接到

622
00:25:25,860 --> 00:25:27,870
所以也许这就是它总是一个

623
00:25:27,870 --> 00:25:29,880
小数抱歉它总是一个真实的不是

624
00:25:29,880 --> 00:25:33,029
固定点好吧

625
00:25:33,029 --> 00:25:36,779
我会仔细检查我声明它是的

626
00:25:36,779 --> 00:25:39,720
我绝对声明它为十进制

627
00:25:39,720 --> 00:25:41,159
好吧让我弄清楚发生了什么我会

628
00:25:41,159 --> 00:25:45,390
玩 一些广场 好的 任何问题都

629
00:25:45,390 --> 00:25:46,610
很好 很酷

630
00:25:46,610 --> 00:25:49,019
所以让我们看看如果海报

631
00:25:49,019 --> 00:25:50,850
实际上在做什么 Postgres 续集

632
00:25:50,850 --> 00:25:52,110
是否可以为 Oracle 提供服务器 源

633
00:25:52,110 --> 00:25:53,760
Postgres 是如果我们看不到它 所以

634
00:25:53,760 --> 00:25:54,960
这实际上来自 post go 源

635
00:25:54,960 --> 00:25:57,360
代码版本 9.6 我认为

636
00:25:57,360 --> 00:26:00,330
，所以当你声明一个定点

637
00:26:00,330 --> 00:26:02,309
小数时，这就是它存储它存储

638
00:26:02,309 --> 00:26:04,710
这个结构的内容，所以你再次拥有所有

639
00:26:04,710 --> 00:26:07,590
这些额外的元数据，关于

640
00:26:07,590 --> 00:26:09,269
小数点是什么符号是什么

641
00:26:09,269 --> 00:26:11,549
等等，然后这部分在这里作为 我说

642
00:26:11,549 --> 00:26:14,000
这只是实际值的字符串表示

643
00:26:14,000 --> 00:26:18,000
，然后

644
00:26:18,000 --> 00:26:19,679
在运行时他们知道如何获取它

645
00:26:19,679 --> 00:26:21,750
并根据这些

646
00:26:21,750 --> 00:26:24,779
值的设置来解密它以确保您

647
00:26:24,779 --> 00:26:28,860
有正确的换向所以现在

648
00:26:28,860 --> 00:26:30,600
为什么它正在运行 两倍 慢，所以我们

649
00:26:30,600 --> 00:26:31,649
要再次 yak 并查看源

650
00:26:31,649 --> 00:26:33,090
代码来说明实际如何进行

651
00:26:33,090 --> 00:26:35,460
加法 你看这不仅仅是你知道

652
00:26:35,460 --> 00:26:37,169
一条指令 你知道数字加

653
00:26:37,169 --> 00:26:39,510
数字 它只是巨大地切换了

654
00:26:39,510 --> 00:26:41,010
一堆东西来试图弄清楚你知道

655
00:26:41,010 --> 00:26:42,720
如果它是负数或非负数，则

656
00:26:42,720 --> 00:26:44,010
为零或者它们彼此相等，

657
00:26:44,010 --> 00:26:46,409
因此

658
00:26:46,409 --> 00:26:47,940
我们每次计算您知道的

659
00:26:47,940 --> 00:26:50,220
数字加数字时都会执行此操作，而如果它是实数，则

660
00:26:50,220 --> 00:26:51,630
是

661
00:26:51,630 --> 00:26:56,220
浮点数 一条指令比 CPU，所以你

662
00:26:56,220 --> 00:26:57,389
知道我们没有

663
00:26:57,389 --> 00:26:58,470
续集服务器和 Oracle 的源代码，但我保证

664
00:26:58,470 --> 00:26:59,760
他们正在做一些类似的事情，

665
00:26:59,760 --> 00:27:00,590


666
00:27:00,590 --> 00:27:05,940
大致可以，所以这很清楚，所以如果

667
00:27:05,940 --> 00:27:08,429
我们不想因为以下原因丢失数据

668
00:27:08,429 --> 00:27:10,350
不精确，我们使用定点小数，

669
00:27:10,350 --> 00:27:11,580
但这是我们

670
00:27:11,580 --> 00:27:14,450
必须在我们的数据库系统中为我们实现的

671
00:27:14,450 --> 00:27:15,630
东西，

672
00:27:15,630 --> 00:27:17,940
所以现在我们将讨论

673
00:27:17,940 --> 00:27:20,399
当尝试存储的值

674
00:27:20,399 --> 00:27:22,260
太大并且不适合单个

675
00:27:22,260 --> 00:27:25,380
页面时会发生什么 有两种方式 o 通常这样做

676
00:27:25,380 --> 00:27:28,080
，正如我上次所说的，

677
00:27:28,080 --> 00:27:29,669
页面的大小将

678
00:27:29,669 --> 00:27:31,260
在整个表中大部分在

679
00:27:31,260 --> 00:27:32,639
整个数据库中固定 这是

680
00:27:32,639 --> 00:27:33,929
您在打开系统时设置的内容，并且您

681
00:27:33,929 --> 00:27:36,090
说我想让您知道 4qi 页面或

682
00:27:36,090 --> 00:27:38,309
8 KB 页面 db2 允许您在

683
00:27:38,309 --> 00:27:39,510


684
00:27:39,510 --> 00:27:41,940
每个缓冲池中使用页面锯，但总的来说，让我们

685
00:27:41,940 --> 00:27:44,010
假设情况是这样，所以现在

686
00:27:44,010 --> 00:27:46,140
如果我们尝试存储的内容

687
00:27:46,140 --> 00:27:49,530
不适合单个，我们该怎么办

688
00:27:49,530 --> 00:27:50,790
一个很明显的事情就是有一个

689
00:27:50,790 --> 00:27:53,040
所谓的溢出页面所以基本上在

690
00:27:53,040 --> 00:27:54,270
我们的管子里让我们说这个值这个

691
00:27:54,270 --> 00:27:56,670
属性 C 不适合页面

692
00:27:56,670 --> 00:28:00,510
所以我们现在只有一个指向

693
00:28:00,510 --> 00:28:02,610
其他溢出页面的指针 '将拥有

694
00:28:02,610 --> 00:28:05,190
我们想要的数据，所以这可能只是

695
00:28:05,190 --> 00:28:07,830
另一个记录 ID，如页码

696
00:28:07,830 --> 00:28:09,960
和偏移量，告诉我们在哪里可以找到

697
00:28:09,960 --> 00:28:13,050
我们需要的特定数据，如果

698
00:28:13,050 --> 00:28:15,780
我们现在有一个查询，我们需要这个

699
00:28:15,780 --> 00:28:17,940
属性或值 作为输出的一部分，

700
00:28:17,940 --> 00:28:19,320
我们必须遵循这一点 指针然后去

701
00:28:19,320 --> 00:28:20,790
把那个页面复制出来

702
00:28:20,790 --> 00:28:23,610
并产生一个输出现在这个数据

703
00:28:23,610 --> 00:28:27,210
本身不适合这个页面-你

704
00:28:27,210 --> 00:28:28,590
可以有另一个你知道溢出页面

705
00:28:28,590 --> 00:28:30,330
指向其他东西的指针你知道

706
00:28:30,330 --> 00:28:31,950
其他页面，我们只是 你知道将

707
00:28:31,950 --> 00:28:33,330
它们链接在一起以

708
00:28:33,330 --> 00:28:35,850
产生我们正在寻找的输出，因此

709
00:28:35,850 --> 00:28:36,810
不同的数据库系统

710
00:28:36,810 --> 00:28:38,400
在 Postgres 中具有不同的名称，

711
00:28:38,400 --> 00:28:40,770
在续集服务器中称为 toast，而我的

712
00:28:40,770 --> 00:28:43,320
Siegel 则称为卡片溢出页面，它们

713
00:28:43,320 --> 00:28:44,700
具有不同的规格，当

714
00:28:44,700 --> 00:28:46,380
它们实际使用时

715
00:28:46,380 --> 00:28:50,130
在 Postgres 中使用类似这样的东西，如果

716
00:28:50,130 --> 00:28:51,240
尝试存储的值大于两千

717
00:28:51,240 --> 00:28:53,490
字节，那么它总是转到

718
00:28:53,490 --> 00:28:56,280
续集服务器中的另一个东西它只有

719
00:28:56,280 --> 00:28:58,380
两个不适合页面，它把

720
00:28:58,380 --> 00:29:00,500
它拉出来并把它们放到 另一个页面，

721
00:29:00,500 --> 00:29:06,210
我的 Siegel 是页面的一半，所以

722
00:29:06,210 --> 00:29:07,560
你想要做这样的事情的原因

723
00:29:07,560 --> 00:29:10,620
是因为

724
00:29:10,620 --> 00:29:12,330
当这些带有常规数据的溢出页面时，你得到了通常会得到的所有保护

725
00:29:12,330 --> 00:29:13,940


726
00:29:13,940 --> 00:29:16,080
如果我正在写这个溢出

727
00:29:16,080 --> 00:29:17,970
页面并且我崩溃然后回来我

728
00:29:17,970 --> 00:29:20,550
不想丢失任何

729
00:29:20,550 --> 00:29:22,020
东西你可以对溢出页面进行所有优化，这些优化

730
00:29:22,020 --> 00:29:23,670


731
00:29:23,670 --> 00:29:25,710
在常规中并不容易 很多页面

732
00:29:25,710 --> 00:29:28,080
以及例如 Postgres 中的页面，因为

733
00:29:28,080 --> 00:29:29,730
大多数时候这些溢出页面

734
00:29:29,730 --> 00:29:32,850
是只读的，或者像你所

735
00:29:32,850 --> 00:29:34,590
知道的那样阅读 像维基百科一样，你

736
00:29:34,590 --> 00:29:36,540
更新你知道一篇文章或更新

737
00:29:36,540 --> 00:29:38,070
一个条目，但大多数时候人们 只是

738
00:29:38,070 --> 00:29:40,740
阅读它，所以

739
00:29:40,740 --> 00:29:42,180
当我

740
00:29:42,180 --> 00:29:44,400
把磁盘放在内存

741
00:29:44,400 --> 00:29:45,540
中时我可以压缩它，因为大多数时候我永远不必

742
00:29:45,540 --> 00:29:48,240
解压缩它来更新它所以

743
00:29:48,240 --> 00:29:49,410
像这样的优化月，它们

744
00:29:49,410 --> 00:29:51,060
都得到了 与您

745
00:29:51,060 --> 00:29:53,290
通常使用常规数据页面

746
00:29:53,290 --> 00:29:56,230
或常规元组页面相同的保护另一种

747
00:29:56,230 --> 00:29:57,490
替代方法而不是将其

748
00:29:57,490 --> 00:29:59,470
直接存储在数据库中是使用

749
00:29:59,470 --> 00:30:02,080
所谓的外部存储，

750
00:30:02,080 --> 00:30:04,240
这里的基本思想是我们

751
00:30:04,240 --> 00:30:05,890
实际上不会存储 t

752
00:30:05,890 --> 00:30:08,020
元组本身中这个特定属性的数据，

753
00:30:08,020 --> 00:30:10,480
我们只是将一个指针或

754
00:30:10,480 --> 00:30:12,640
文件路径存储到本地

755
00:30:12,640 --> 00:30:14,770
磁盘或网络存储或某些

756
00:30:14,770 --> 00:30:17,680
外部存储设备中的某个位置，这些

757
00:30:17,680 --> 00:30:20,980
数据可以在这种情况下正确找到

758
00:30:20,980 --> 00:30:23,350
这里从 C 开始，这可能是

759
00:30:23,350 --> 00:30:25,330
本地磁盘上的文件路径，所以说你知道

760
00:30:25,330 --> 00:30:27,040
在这里可以找到这个特定的

761
00:30:27,040 --> 00:30:28,450
属性，如果你需要的

762
00:30:28,450 --> 00:30:31,540
话，那么在

763
00:30:31,540 --> 00:30:34,330
像 Oracle、db2 和 Microsoft 这样支持它的系统中，

764
00:30:34,330 --> 00:30:37,900
你可以 '实际上并没有修改

765
00:30:37,900 --> 00:30:40,960
这个文件中的内容，你可以阅读

766
00:30:40,960 --> 00:30:47,280
它，但你不能正确操作它是的

767
00:30:56,370 --> 00:30:58,960
所以他的好问题是或声明

768
00:30:58,960 --> 00:31:00,850
是将超低页面磁盘

769
00:31:00,850 --> 00:31:03,010
带入内存就像一个常规元组

770
00:31:03,010 --> 00:31:05,440
在 在这些

771
00:31:05,440 --> 00:31:07,420
外部文件的情况下，这些东西

772
00:31:07,420 --> 00:31:11,440
驻留在音乐中，所以如果您运行

773
00:31:11,440 --> 00:31:13,330
像 select star 这样的查询，请在此处运行此元组

774
00:31:13,330 --> 00:31:15,820
，并在此外部文件中查看是否

775
00:31:15,820 --> 00:31:17,500
需要将其作为输出生成，我必须

776
00:31:17,500 --> 00:31:20,380
去阅读它 可以翻页

777
00:31:20,380 --> 00:31:22,540
就像另一个元组或其他

778
00:31:22,540 --> 00:31:23,230
元组页面一样，

779
00:31:23,230 --> 00:31:25,360
它可能是短暂的意思，就像我

780
00:31:25,360 --> 00:31:26,260
要阅读它然后立即

781
00:31:26,260 --> 00:31:28,530
丢弃它而不是污染我的现金

782
00:31:28,530 --> 00:31:30,430
有很多不同的方法可以做到

783
00:31:30,430 --> 00:31:32,740
这一点但要考虑的关键

784
00:31:32,740 --> 00:31:35,890
是如果 现在在

785
00:31:35,890 --> 00:31:39,130
数据库外部修改这个文件的人会

786
00:31:39,130 --> 00:31:40,630
在我们阅读它的任何时候看到我们数据库内部的变化

787
00:31:40,630 --> 00:31:42,190
，因为我们的数据库系统没有

788
00:31:42,190 --> 00:31:43,690
控制或

789
00:31:43,690 --> 00:31:49,200
保护，所以

790
00:31:49,200 --> 00:31:51,190
一切我猜你为什么想要

791
00:31:51,190 --> 00:31:53,620
做类似的事情 这

792
00:31:53,620 --> 00:31:54,880
是一个文件的例子，也许不想

793
00:31:54,880 --> 00:31:59,590
存储在数据库系统中，说你正在

794
00:31:59,590 --> 00:32:00,880
正确地构建网站，并且你

795
00:32:00,880 --> 00:32:03,400
有一堆你想知道的视频文件

796
00:32:03,400 --> 00:32:04,840
，你有一个表示你知道的元组

797
00:32:04,840 --> 00:32:06,280
这个人上传了这个视频，

798
00:32:06,280 --> 00:32:07,180
你没有

799
00:32:07,180 --> 00:32:08,590
将视频存储在数据库本身中，

800
00:32:08,590 --> 00:32:09,760
因为那可能是你知道千兆字节

801
00:32:09,760 --> 00:32:12,370
我说过在应用程序框架中看到那个和那些东西是很常见的

802
00:32:12,370 --> 00:32:15,670


803
00:32:15,670 --> 00:32:16,740
像 Django

804
00:32:16,740 --> 00:32:18,910
nodejs 之类的东西，

805
00:32:18,910 --> 00:32:21,480
他们有你知道

806
00:32:21,480 --> 00:32:23,640
在数据库系统之外存储

807
00:32:23,640 --> 00:32:27,520
图像和其他东西的数据的内置方法，

808
00:32:27,520 --> 00:32:30,730
所以没有固定的

809
00:32:30,730 --> 00:32:34,720
规则来说明文件应该

810
00:32:34,720 --> 00:32:37,300
有多大 但是当您知道将其作为

811
00:32:37,300 --> 00:32:38,650
外部文件发布而不是将其保留为

812
00:32:38,650 --> 00:32:41,050
溢出页面时，我也会说对于

813
00:32:41,050 --> 00:32:43,030
重载页面，这对

814
00:32:43,030 --> 00:32:44,620
您作为应用程序来说是透明的，因此您不

815
00:32:44,620 --> 00:32:45,850
知道自己已经进入了溢出页面

816
00:32:45,850 --> 00:32:48,280
像您一样的页面可以做我们之前做的事情，

817
00:32:48,280 --> 00:32:51,280
并查看

818
00:32:51,280 --> 00:32:54,370
有关我们的数据实际存储位置的低级信息的实际布局，

819
00:32:54,370 --> 00:32:55,510
就像我们

820
00:32:55,510 --> 00:32:57,430
对 CT ID 和 Postgres 以及其他

821
00:32:57,430 --> 00:33:00,340
系统所做的那样，但大多数应用程序不

822
00:33:00,340 --> 00:33:01,480
知道 不在乎存储在溢出

823
00:33:01,480 --> 00:33:03,720
页面中，就像我想再次为这件事获取我的数据

824
00:33:03,720 --> 00:33:06,880
一样，您

825
00:33:06,880 --> 00:33:08,230
取决于您实际实际

826
00:33:08,230 --> 00:33:10,180
实施的方式，您可以通过

827
00:33:10,180 --> 00:33:11,380
戴维森，或者您可以直接跳转到

828
00:33:11,380 --> 00:33:13,330
文件并直接获取它，如果 你

829
00:33:13,330 --> 00:33:18,670
想 所以

830
00:33:18,670 --> 00:33:21,970
大约 10

831
00:33:21,970 --> 00:33:24,460
年前，微软的一些著名大卫

832
00:33:24,460 --> 00:33:27,640
人写了一篇论文 错过了

833
00:33:27,640 --> 00:33:29,080
这篇文章的名字是 blob 与否 blob 或

834
00:33:29,080 --> 00:33:31,540
blob 是一个二进制大对象 我只是

835
00:33:31,540 --> 00:33:33,930
它是一个可变长度的二进制文件 数据，

836
00:33:33,930 --> 00:33:36,790
他们基本上在 2000 年代

837
00:33:36,790 --> 00:33:40,240
发现，任何小于 256 KB 的内容您

838
00:33:40,240 --> 00:33:41,710
都想存储为溢出页面

839
00:33:41,710 --> 00:33:43,780
任何大于您想

840
00:33:43,780 --> 00:33:47,200
存储在外部文件

841
00:33:47,200 --> 00:33:47,640
存储中的内容

842
00:33:47,640 --> 00:33:50,650
我们让指导续集 Lite 的人

843
00:33:50,650 --> 00:33:53,080
来到 CMU 几年前来

844
00:33:53,080 --> 00:33:56,230
这里发表演讲，他说对于很多

845
00:33:56,230 --> 00:33:57,550
手机应用程序来说，实际上

846
00:33:57,550 --> 00:33:59,620
最好将图像的缩略图存储

847
00:33:59,620 --> 00:34:02,430


848
00:34:02,430 --> 00:34:05,050
在数据库系统中，甚至高达 1 兆字节，因为

849
00:34:05,050 --> 00:34:06,970
这样读取那些会快得多

850
00:34:06,970 --> 00:34:08,469
来自数据库系统的记录，

851
00:34:08,469 --> 00:34:09,880
因为它们已经打开了文件，

852
00:34:09,880 --> 00:34:11,770
而不必跟随这个

853
00:34:11,770 --> 00:34:14,170
指向文件系统的指针，然后

854
00:34:14,170 --> 00:34:16,500
执行 F 打开以获取数据，

855
00:34:16,500 --> 00:34:19,330
因此再次没有 ha

856
00:34:19,330 --> 00:34:20,650


857
00:34:20,650 --> 00:34:23,260
当

858
00:34:23,260 --> 00:34:24,850
您知道数据库存储

859
00:34:24,850 --> 00:34:26,860
非常昂贵时，如果您真的

860
00:34:26,860 --> 00:34:28,870
关心您的数据或您的数据库，您的

861
00:34:28,870 --> 00:34:29,800
视图将在高端硬件上耗尽，那么执行此操作的快速规则也更为常见

862
00:34:29,800 --> 00:34:32,739
因此

863
00:34:32,739 --> 00:34:34,840
，在一些真正

864
00:34:34,840 --> 00:34:36,730
高端的企业中像一堆视频文件一样存储这可能

865
00:34:36,730 --> 00:34:38,560
不是很好地利用你的钱，所以你可以把它拿走，

866
00:34:38,560 --> 00:34:40,659
你知道这些文件把它

867
00:34:40,659 --> 00:34:42,610
扔到 HDFS 或更便宜的商店我猜是三个，

868
00:34:42,610 --> 00:34:44,860
然后现在日子已经过去了 't 并没有

869
00:34:44,860 --> 00:34:46,300
因为试图维护你的文件而负担过重，

870
00:34:46,300 --> 00:34:50,290
所以再次说明，这

871
00:34:50,290 --> 00:34:51,760
不仅仅是性能原因，还有其他

872
00:34:51,760 --> 00:34:53,380
经济原因，为什么你想做这样的

873
00:34:53,380 --> 00:34:55,120
事情，但我认为这篇论文

874
00:34:55,120 --> 00:34:56,590
总结了一堆问题

875
00:34:56,590 --> 00:34:57,640
，这就是我喜欢它的原因

876
00:34:57,640 --> 00:34:59,890
所以再一次，任何问题都有一个很好的

877
00:34:59,890 --> 00:35:02,530
代表数据，大多数时候你

878
00:35:02,530 --> 00:35:03,880
知道固定长度数据它只是

879
00:35:03,880 --> 00:35:05,650
编程环境

880
00:35:05,650 --> 00:35:08,350
为我们提供的任何可变

881
00:35:08,350 --> 00:35:11,680
长度的东西，或者如果我们想要定点

882
00:35:11,680 --> 00:35:13,420
精度 ff 将有助于实现

883
00:35:13,420 --> 00:35:19,840
我们自己，所以现在让我们谈谈

884
00:35:19,840 --> 00:35:22,750
我们如何实际找出

885
00:35:22,750 --> 00:35:24,790
我们的元组是什么样子的，这又

886
00:35:24,790 --> 00:35:26,980
是系统目录的用途，它是

887
00:35:26,980 --> 00:35:29,440
关于数据库的数据元数据的元数据

888
00:35:29,440 --> 00:35:31,570
我

889
00:35:31,570 --> 00:35:33,220
有表名 或我拥有的索引

890
00:35:33,220 --> 00:35:34,810
等等以及其他一些

891
00:35:34,810 --> 00:35:37,510
事情，例如您知道

892
00:35:37,510 --> 00:35:38,860
我不关心的用户权限和安全性内容，

893
00:35:38,860 --> 00:35:41,320
然后

894
00:35:41,320 --> 00:35:42,400
在我们讨论查询

895
00:35:42,400 --> 00:35:44,590
优化以及有关您的数据的内部统计信息时会出现这些内容

896
00:35:44,590 --> 00:35:46,810
看起来你知道

897
00:35:46,810 --> 00:35:48,610
多少个唯一值 我有多少个唯一值 我有

898
00:35:48,610 --> 00:35:49,660
这些值的分布是

899
00:35:49,660 --> 00:35:53,290
什么样的 所以几乎每个

900
00:35:53,290 --> 00:35:55,680
数据库系统都会将它们的

901
00:35:55,680 --> 00:35:59,740
目录存储在自己内部，就像

902
00:35:59,740 --> 00:36:02,080
另一个表一样，就像吃自己的

903
00:36:02,080 --> 00:36:03,820
狗粮一样 我会把

904
00:36:03,820 --> 00:36:06,340
关于我的表的所有元数据都存储在表

905
00:36:06,340 --> 00:36:10,150
本身中，所以在

906
00:36:10,150 --> 00:36:11,800
源代码中你显然不想

907
00:36:11,800 --> 00:36:13,090
写续集查询来说你知道

908
00:36:13,090 --> 00:36:14,230
这张表的名称是什么，因为

909
00:36:14,230 --> 00:36:15,820
它是鸡蛋

910
00:36:15,820 --> 00:36:17,770


911
00:36:17,770 --> 00:36:19,210


912
00:36:19,210 --> 00:36:21,700


913
00:36:21,700 --> 00:36:24,340
问题的鸡 sepals

914
00:36:24,340 --> 00:36:26,110
编码任何你的剧院系统被

915
00:36:26,110 --> 00:36:28,270
编程来环绕

916
00:36:28,270 --> 00:36:30,160
低级访问方法来

917
00:36:30,160 --> 00:36:32,700
访问目录，

918
00:36:32,700 --> 00:36:37,720
所以大多数大卫助手将

919
00:36:37,720 --> 00:36:39,910
通过标准

920
00:36:39,910 --> 00:36:43,780
信息模式 API 公开目录，所以在 1980 年代，

921
00:36:43,780 --> 00:36:45,339
所有这些不同的数据库系统

922
00:36:45,339 --> 00:36:46,569
都有自己的 用自己的方式说这是我的

923
00:36:46,569 --> 00:36:48,130
目录，所以这里是如何访问它

924
00:36:48,130 --> 00:36:49,569
，

925
00:36:49,569 --> 00:36:50,710
如果您想将应用程序

926
00:36:50,710 --> 00:36:52,480
从一个数据库系统移植到另一个数据库

927
00:36:52,480 --> 00:36:54,250
系统，这现在变得非常痛苦，因为现在所有

928
00:36:54,250 --> 00:36:56,200
目录内容都不同 你必须

929
00:36:56,200 --> 00:36:58,359
再次重写所有代码，所以在

930
00:36:58,359 --> 00:37:00,220
ANSI 标准中，我认为

931
00:37:00,220 --> 00:37:02,230
现在在续集标准中，他们会指定每个数据系统都必须使用

932
00:37:02,230 --> 00:37:03,849
的称为信息模式的东西

933
00:37:03,849 --> 00:37:06,069


934
00:37:06,069 --> 00:37:08,410
支持说这

935
00:37:08,410 --> 00:37:11,319
是关于我的表的元数据，但我们将在

936
00:37:11,319 --> 00:37:12,880
第二次保释中看到这些表中总是暴露相同的

937
00:37:12,880 --> 00:37:16,150
信息，所有

938
00:37:16,150 --> 00:37:17,260
戴维斯都会有自己的

939
00:37:17,260 --> 00:37:20,109
什么样的快捷方式来获取

940
00:37:20,109 --> 00:37:23,829
这些信息 例如，

941
00:37:23,829 --> 00:37:26,170
如果您想获取

942
00:37:26,170 --> 00:37:28,359
我们拥有的所有表，那么续集标准

943
00:37:28,359 --> 00:37:29,980
会说您使用

944
00:37:29,980 --> 00:37:31,839
有关表的这些信息来编写它，这只是

945
00:37:31,839 --> 00:37:34,270
真实目录顶部的视图，并且您

946
00:37:34,270 --> 00:37:36,190
给它正确的目录名称或

947
00:37:36,190 --> 00:37:39,099
Postgres 中的数据库名称你使用 /d 和

948
00:37:39,099 --> 00:37:40,750
我的续集你拍摄表格续集编辑

949
00:37:40,750 --> 00:37:43,150
点表然后所有的数据

950
00:37:43,150 --> 00:37:44,619
系统都有自己的快捷方式，

951
00:37:44,619 --> 00:37:46,089
基本上他们在幕后所做的事情

952
00:37:46,089 --> 00:37:47,890
是将这个

953
00:37:47,890 --> 00:37:52,630
命令转换成类似的

954
00:37:52,630 --> 00:37:53,770
东西 现在，如果我想为一个表获取这个模式

955
00:37:53,770 --> 00:37:56,859
，那么这就是

956
00:37:56,859 --> 00:37:58,510
我们在 ANSI 标准中的做法，然后

957
00:37:58,510 --> 00:38:01,630
各种系统都有自己的

958
00:38:01,630 --> 00:38:03,760
方法，所以我想

959
00:38:03,760 --> 00:38:08,250
快速演示 Pos  tgres 和我的续集

960
00:38:08,250 --> 00:38:10,359
再次只是为了向您展示实际

961
00:38:10,359 --> 00:38:12,869
发生的事情

962
00:38:20,300 --> 00:38:23,349
[音乐]

963
00:38:27,460 --> 00:38:32,270
好吧所以它又是 Postgres 如果我做

964
00:38:32,270 --> 00:38:34,910
dash DI 获取我所有表的列表我

965
00:38:34,910 --> 00:38:37,520
可以做 dash D plus 并获得更多

966
00:38:37,520 --> 00:38:40,240
信息然后如果我选择一个 表

967
00:38:40,240 --> 00:38:42,770
它会告诉我你知道

968
00:38:42,770 --> 00:38:44,990
元数据是什么样子 所以

969
00:38:44,990 --> 00:38:46,640
这里是我拥有的所有列 这

970
00:38:46,640 --> 00:38:48,710
是我现在运行查询时拥有的类型 我

971
00:38:48,710 --> 00:38:50,210
查看了这些信息 说

972
00:38:50,210 --> 00:38:52,400
在第一个属性是一个整数我

973
00:38:52,400 --> 00:38:54,170
问我 32 位，下一个属性

974
00:38:54,170 --> 00:38:55,940
也是一个整数，它将是 32 位

975
00:38:55,940 --> 00:38:58,880
，然后我在里面有代码可以

976
00:38:58,880 --> 00:39:00,109
说如果我正在操作元组，

977
00:39:00,109 --> 00:39:01,910
那么架构是什么我知道如何再次执行

978
00:39:01,910 --> 00:39:04,609
原始数据的转换

979
00:39:04,609 --> 00:39:06,800
元组的字节数组的字节，并将

980
00:39:06,800 --> 00:39:09,730
其放入它期望的形式，

981
00:39:09,730 --> 00:39:12,619
所以让我看看我是否可以为我的续集做这个

982
00:39:12,619 --> 00:39:14,240
我想我刚刚破坏了我的

983
00:39:14,240 --> 00:39:23,480
续集让我在另一台机器上做这个，

984
00:39:23,480 --> 00:39:33,410
所以我可以说 显示表并

985
00:39:33,410 --> 00:39:36,260
告诉我我有的表 我可以说显示

986
00:39:36,260 --> 00:39:41,150
数据库 sa 我的事情是

987
00:39:41,150 --> 00:39:42,369
他们拥有的所有不同的不同数据库

988
00:39:42,369 --> 00:39:46,670
然后对于给定的表我可以说

989
00:39:46,670 --> 00:39:51,080
正确描述旋钮我会再说

990
00:39:51,080 --> 00:39:52,790
一遍相同的信息这里是字段的名称

991
00:39:52,790 --> 00:39:54,589
这里是类型然后是

992
00:39:54,589 --> 00:39:58,150
一些额外的元数据所以这是我的续集

993
00:39:58,150 --> 00:40:02,300
5.7 较新的版本实际上

994
00:40:02,300 --> 00:40:04,369
将表存储在目录本身中，或者他们

995
00:40:04,369 --> 00:40:05,869


996
00:40:05,869 --> 00:40:08,330
在此版本中开始为目录和表本身提供服务，他们没有

997
00:40:08,330 --> 00:40:10,760
这样做，他们为 cowell 所做

998
00:40:10,760 --> 00:40:13,700
的只是读取

999
00:40:13,700 --> 00:40:16,070
数据库所在的目录 存储并使用它来

1000
00:40:16,070 --> 00:40:18,740
确定那里有哪些数据库以及那里

1001
00:40:18,740 --> 00:40:20,960
有哪些表，因此我们

1002
00:40:20,960 --> 00:40:22,369
实际上可以通过

1003
00:40:22,369 --> 00:40:24,859
将不应该存在的东西

1004
00:40:24,859 --> 00:40:27,140
放在该目录中来破坏它或伪造它，所以如果你

1005
00:40:27,140 --> 00:40:31,150
回到这里让我们拆分它

1006
00:40:31,610 --> 00:40:36,480
所以一定要显示数据库，它认为我

1007
00:40:36,480 --> 00:40:37,470
认为我在这里有一堆这样的，

1008
00:40:37,470 --> 00:40:39,870
所以现在如果我回到这

1009
00:40:39,870 --> 00:40:48,570
台机器以 root 登录进入我的

1010
00:40:48,570 --> 00:40:51,350
续集存储数据的地方我的续集是

1011
00:40:51,350 --> 00:40:53,520
正确的，大致你会看到

1012
00:40:53,520 --> 00:40:54,990
你们中的很多人都知道这里有一堆它

1013
00:40:54,990 --> 00:40:58,140
知道的数据库目录，

1014
00:40:58,140 --> 00:40:59,640
但数据称为

1015
00:40:59,640 --> 00:41:01,950
测试，有一个名为 test 的目录，

1016
00:41:01,950 --> 00:41:03,300
所以如果我现在调用 make

1017
00:41:03,300 --> 00:41:07,080
directory xxx 会发生什么我想回到

1018
00:41:07,080 --> 00:41:08,790
这里我的续集 认为有一个

1019
00:41:08,790 --> 00:41:13,170
名为 xxx 的目录，所以这是一个

1020
00:41:13,170 --> 00:41:15,600
很好的例子，说明如果我们

1021
00:41:15,600 --> 00:41:17,280
依赖数据库系统的 X 项，我们

1022
00:41:17,280 --> 00:41:20,940
无法完全控制它，因此我的 Siegel

1023
00:41:20,940 --> 00:41:22,560
无法阻止任何人进入该

1024
00:41:22,560 --> 00:41:24,300
目录并在 一旦在

1025
00:41:24,300 --> 00:41:27,060
那里但如果它依赖

1026
00:41:27,060 --> 00:41:29,450
它来找出我的数据库中的内容

1027
00:41:29,450 --> 00:41:32,400
所以从实现的角度来看它

1028
00:41:32,400 --> 00:41:34,320
可能更容易但从正确性的

1029
00:41:34,320 --> 00:41:36,390
角度来看这是有问题的

1030
00:41:36,390 --> 00:41:37,620
他们可能会说谁会

1031
00:41:37,620 --> 00:41:39,420
愚蠢到去创建目录来

1032
00:41:39,420 --> 00:41:41,160
搞砸 我的续集那么

1033
00:41:41,160 --> 00:41:42,440
其他事情呢，比如我在写文件

1034
00:41:42,440 --> 00:41:45,810
然后你知道

1035
00:41:45,810 --> 00:41:46,890
我没有对我的常规数据进行常规保护，

1036
00:41:46,890 --> 00:41:48,030
因为我没有

1037
00:41:48,030 --> 00:41:50,670
正确地记录事情 我想把

1038
00:41:50,670 --> 00:41:51,750
尽可能多的东西放在数据库

1039
00:41:51,750 --> 00:41:54,090
系统中，因为这样我们就可以依靠它

1040
00:41:54,090 --> 00:41:58,710
来为我们正确执行，

1041
00:41:58,710 --> 00:42:00,830


1042
00:42:02,250 --> 00:42:05,340
好吧，这就是我们

1043
00:42:05,340 --> 00:42:07,950
本学期真正需要的目录封面只是

1044
00:42:07,950 --> 00:42:09,540
开玩笑只是要知道有

1045
00:42:09,540 --> 00:42:12,000
一些东西 在约会系统中，

1046
00:42:12,000 --> 00:42:14,550
无论我们的模式是什么样

1047
00:42:14,550 --> 00:42:16,440
的，当我们询问您时，我们都会使用它

1048
00:42:16,440 --> 00:42:17,760
查询时使用它，当我们构建

1049
00:42:17,760 --> 00:42:20,160
索引以确定您知道

1050
00:42:20,160 --> 00:42:22,920
我们实际上应该做什么以及

1051
00:42:22,920 --> 00:42:24,690
思考这个不同类型的方式时

1052
00:42:24,690 --> 00:42:29,790
是在 并且有最简单的方法

1053
00:42:29,790 --> 00:42:31,260
来实现这个，你会在

1054
00:42:31,260 --> 00:42:32,760
你们工作的总线集线器代码中看到这一点，

1055
00:42:32,760 --> 00:42:34,590
当你查看类型系统时，我

1056
00:42:34,590 --> 00:42:37,170
是一个巨大的 switch 语句，如果

1057
00:42:37,170 --> 00:42:38,670
类型是整数，请执行此操作，如果 type

1058
00:42:38,670 --> 00:42:41,250
是浮动的，所以

1059
00:42:41,250 --> 00:42:42,720
你对每一个元组都这样做，这

1060
00:42:42,720 --> 00:42:43,710
实际上会很慢，因为

1061
00:42:43,710 --> 00:42:45,660
它们实际上是在解释你

1062
00:42:45,660 --> 00:42:48,390
知道布局应该是什么，并且在

1063
00:42:48,390 --> 00:42:49,950
更高级的系统中 您实际上可以

1064
00:42:49,950 --> 00:42:51,840
编译或执行代码生成以

1065
00:42:51,840 --> 00:42:53,970
像 JVM 中的即时编译一样即时编译

1066
00:42:53,970 --> 00:42:56,010
以实际编译这些

1067
00:42:56,010 --> 00:42:57,480
操作，这样您就不必

1068
00:42:57,480 --> 00:42:59,790
每次我的

1069
00:42:59,790 --> 00:43:01,050
C 代码不这样做时都进行这种解释 新版本

1070
00:43:01,050 --> 00:43:03,810
Postgres 这样做，但 Oracle 和续集

1071
00:43:03,810 --> 00:43:05,160
服务器也应该这样做，所有

1072
00:43:05,160 --> 00:43:06,869
主要的商业系统都这样做，这

1073
00:43:06,869 --> 00:43:07,650
不是我们在本课程中要介绍的内容，

1074
00:43:07,650 --> 00:43:09,450
但是当我们介绍查询

1075
00:43:09,450 --> 00:43:11,339
执行时，我会提到这

1076
00:43:11,339 --> 00:43:12,359
是 一种使这个运行

1077
00:43:12,359 --> 00:43:18,930
得更快的编写方法，所以接下来我们要

1078
00:43:18,930 --> 00:43:20,609
讨论的是存储模型

1079
00:43:20,609 --> 00:43:22,170
的第一件事，如果他们意识到

1080
00:43:22,170 --> 00:43:23,880
我们在第一讲中

1081
00:43:23,880 --> 00:43:28,050
介绍的是关系模型没有

1082
00:43:28,050 --> 00:43:30,270
谈论我们实际上想要

1083
00:43:30,270 --> 00:43:32,520
如何存储数据不知道类型

1084
00:43:32,520 --> 00:43:34,859
不知道你知道字节向上字节

1085
00:43:34,859 --> 00:43:37,950
数组等等，

1086
00:43:37,950 --> 00:43:39,660
甚至不一定说我们必须将

1087
00:43:39,660 --> 00:43:42,390
元组的所有属性存储

1088
00:43:42,390 --> 00:43:45,390
在一起 在内存或磁盘中

1089
00:43:45,390 --> 00:43:49,800


1090
00:43:49,800 --> 00:43:51,300
当我们现在可视化数据库时，无论何时我们在课堂上到目前为止都知道，

1091
00:43:51,300 --> 00:43:53,369
我是说这里的行

1092
00:43:53,369 --> 00:43:55,140
这里是它的所有属性对于元组来说是正确的

1093
00:43:55,140 --> 00:43:57,930
，但这

1094
00:43:57,930 --> 00:43:59,040
对某些人来说可能不是最好的方法

1095
00:43:59,040 --> 00:44:01,710
工作负载 所以让我们看一个非常

1096
00:44:01,710 --> 00:44:03,540
简单的数据库示例吧

1097
00:44:03,540 --> 00:44:05,609
这实际上是从

1098
00:44:05,609 --> 00:44:07,530
运行维基

1099
00:44:07,530 --> 00:44:08,670


1100
00:44:08,670 --> 00:44:11,190


1101
00:44:11,190 --> 00:44:13,380
百科的 MediaWiki 软件派生出来的 大致看起来

1102
00:44:13,380 --> 00:44:15,210
像这样，所以我们有三个

1103
00:44:15,210 --> 00:44:15,810
表，

1104
00:44:15,810 --> 00:44:17,490
我们有用户帐户页面和修订

1105
00:44:17,490 --> 00:44:20,340
，因此修订表是

1106
00:44:20,340 --> 00:44:21,960
我们将存储每篇文章的所有新更新的地方

1107
00:44:21,960 --> 00:44:24,120
，因此它是

1108
00:44:24,120 --> 00:44:25,410
一种外键引用

1109
00:44:25,410 --> 00:44:27,240
创建的用户进行了更改，

1110
00:44:27,240 --> 00:44:29,280
然后是与文章或页面相对应的页面 ID，

1111
00:44:29,280 --> 00:44:32,010
然后这个人

1112
00:44:32,010 --> 00:44:33,900
还有一个外键首选项，可以说

1113
00:44:33,900 --> 00:44:36,510
这是此特定页面的最新修订版，

1114
00:44:36,510 --> 00:44:38,130
因此您无需执行

1115
00:44:38,130 --> 00:44:39,750
扫描一下，你就可以直接跳到它

1116
00:44:39,750 --> 00:44:41,730
了，这是

1117
00:44:41,730 --> 00:44:43,020
维基百科

1118
00:44:43,020 --> 00:44:45,480
实际工作的一个近似版本，但就我们在

1119
00:44:45,480 --> 00:44:50,550
本次讲座中的目的而言，这很好，所以有

1120
00:44:50,550 --> 00:44:52,680
两种一般类别的工作负载

1121
00:44:52,680 --> 00:44:53,790
我们会关心 数据库

1122
00:44:53,790 --> 00:44:55,110
系统，你知道它们肯定

1123
00:44:55,110 --> 00:44:56,910
不是唯一的机器学习和

1124
00:44:56,910 --> 00:44:59,370
流媒体的东西，但现在

1125
00:44:59,370 --> 00:45:02,520
只关注两个，所以第一个被称为

1126
00:45:02,520 --> 00:45:04,680
在线事务处理或 OLTP

1127
00:45:04,680 --> 00:45:06,600
，在 OLTP 之前曾听说过这个词，

1128
00:45:06,600 --> 00:45:11,970
好吧，好吧 这通常

1129
00:45:11,970 --> 00:45:13,590
是你在

1130
00:45:13,590 --> 00:45:15,120
任何时候

1131
00:45:15,120 --> 00:45:16,560
构建你知道构建一个

1132
00:45:16,560 --> 00:45:18,930
新应用程序时都会得到这种类型的应用程序的结果 如果我正在构建一个

1133
00:45:18,930 --> 00:45:20,640
新网站 我正在构建一个新的 iPhone

1134
00:45:20,640 --> 00:45:22,710
应用程序或其他任何东西 您通常会

1135
00:45:22,710 --> 00:45:25,230
构建其中之一，因此对于

1136
00:45:25,230 --> 00:45:27,630
事务 OLTP 在线事务

1137
00:45:27,630 --> 00:45:29,340
处理的想法是，这

1138
00:45:29,340 --> 00:45:30,210
是我们获取新信息的地方，

1139
00:45:30,210 --> 00:45:32,100
我们从外部世界摄取新数据

1140
00:45:32,100 --> 00:45:33,600
并推杆 把它放到我们的

1141
00:45:33,600 --> 00:45:36,300
数据库系统中，这样这些查询

1142
00:45:36,300 --> 00:45:38,070
就可以非常简单，它们每次只会

1143
00:45:38,070 --> 00:45:40,290
读取少量数据或更新

1144
00:45:40,290 --> 00:45:42,690
少量数据——一定要

1145
00:45:42,690 --> 00:45:44,100
一遍又一遍地做同样的操作，

1146
00:45:44,100 --> 00:45:46,350
所以我总是喜欢这个例子

1147
00:45:46,350 --> 00:45:48,840
给予就像亚马逊店面

1148
00:45:48,840 --> 00:45:50,400
一样，当您

1149
00:45:50,400 --> 00:45:52,650
购买被认为是对应用程序的颂歌时所访问的网站，

1150
00:45:52,650 --> 00:45:54,690
因为我正在向

1151
00:45:54,690 --> 00:45:56,850
购物车中添加东西我正在购买我正在

1152
00:45:56,850 --> 00:45:59,520
更新我的帐户信息我是 你

1153
00:45:59,520 --> 00:46:00,930
知道对于每一个单一的操作，

1154
00:46:00,930 --> 00:46:02,220
他们做了很多，因为我

1155
00:46:02,220 --> 00:46:03,990
有很多人在买东西，但

1156
00:46:03,990 --> 00:46:05,790
对你来说，作为一个客户，

1157
00:46:05,790 --> 00:46:07,710
你没有更新很多数据你

1158
00:46:07,710 --> 00:46:08,700
知道你正在更新你的

1159
00:46:08,700 --> 00:46:10,020
您正在更新的帐户信息是

1160
00:46:10,020 --> 00:46:12,180
您的购物车，因此

1161
00:46:12,180 --> 00:46:14,370
正在运行的查询只做一小部分，

1162
00:46:14,370 --> 00:46:15,750
您只知道访问数据库的一

1163
00:46:15,750 --> 00:46:20,040
小部分，然后我

1164
00:46:20,040 --> 00:46:21,120
说您将再次看到的查询类型

1165
00:46:21,120 --> 00:46:23,730
返回 BPD 示例 所以

1166
00:46:23,730 --> 00:46:26,970
这里是去获取这里之前获取

1167
00:46:26,970 --> 00:46:29,519
当前版本原谅页面这里

1168
00:46:29,519 --> 00:46:31,649
更新我的用户帐户说当

1169
00:46:31,649 --> 00:46:33,599
我登录时这里是一个你知道

1170
00:46:33,599 --> 00:46:34,799
简单的插入查询以插入新

1171
00:46:34,799 --> 00:46:37,109
版本写入每个这些

1172
00:46:37,109 --> 00:46:39,349
东西正在访问 小数字

1173
00:46:39,349 --> 00:46:41,489
小数字 2 一次，

1174
00:46:41,489 --> 00:46:43,169
我们是，但我们正在一遍又一遍地做这些事情，

1175
00:46:43,169 --> 00:46:46,289
所以现在另一种类型的

1176
00:46:46,289 --> 00:46:47,599
工作负载称为 OLAP 或在线

1177
00:46:47,599 --> 00:46:50,429
分析处理，这是当

1178
00:46:50,429 --> 00:46:51,659
您已经收集了一堆

1179
00:46:51,659 --> 00:46:54,149
来自您的 OTP 应用程序的数据，现在您

1180
00:46:54,149 --> 00:46:56,669
想对其进行分析并从中推断出新

1181
00:46:56,669 --> 00:46:57,719
信息，

1182
00:46:57,719 --> 00:47:02,159
这有时被称为您知道的

1183
00:47:02,159 --> 00:47:04,859
不仅是数据科学，而且

1184
00:47:04,859 --> 00:47:06,419
是像获取一堆数据

1185
00:47:06,419 --> 00:47:08,549
并试图从中获取新信息的领域

1186
00:47:08,549 --> 00:47:15,630
是的，我的意思是它

1187
00:47:15,630 --> 00:47:17,039
的名称是在线处理

1188
00:47:17,039 --> 00:47:19,349
商业智能

1189
00:47:19,349 --> 00:47:21,509
，此决策支持的另一个短语是

1190
00:47:21,509 --> 00:47:24,059
另一个大数据，如果您想再次称呼

1191
00:47:24,059 --> 00:47:27,989
它，我已经在

1192
00:47:27,989 --> 00:47:29,789
这种环境中的工作负载并没有

1193
00:47:29,789 --> 00:47:32,759
更新数据，整棵树

1194
00:47:32,759 --> 00:47:34,199
看到它正在为我们获取新信息

1195
00:47:34,199 --> 00:47:35,729
，现在我们正在尝试

1196
00:47:35,729 --> 00:47:39,329
理解它，因此查询可能在

1197
00:47:39,329 --> 00:47:41,699
维基百科示例中说你想计算

1198
00:47:41,699 --> 00:47:43,619


1199
00:47:43,619 --> 00:47:46,559
每月登录的人，他们的主机名

1200
00:47:46,559 --> 00:47:48,839
和以 dot-gov 结尾的

1201
00:47:48,839 --> 00:47:51,659
地方几年前发生了一起丑闻，他们发现

1202
00:47:51,659 --> 00:47:52,859
国会议员正在绘画或

1203
00:47:52,859 --> 00:47:55,049
让他们的员工去维基百科

1204
00:47:55,049 --> 00:47:56,669
把它们擦洗干净以删除所有像

1205
00:47:56,669 --> 00:47:57,959
你知道

1206
00:47:57,959 --> 00:48:00,929
国会议员卷入的丑闻是对的，所以你

1207
00:48:00,929 --> 00:48:01,829
想找出所有

1208
00:48:01,829 --> 00:48:03,689
在政府办公室登录的人

1209
00:48:03,689 --> 00:48:07,380
这样做，所以这些

1210
00:48:07,380 --> 00:48:09,589
类型的查询将是只读的，

1211
00:48:09,589 --> 00:48:12,089
他们将阅读 很多数据，比如

1212
00:48:12,089 --> 00:48:14,729
我要扫描整个表，

1213
00:48:14,729 --> 00:48:16,409
而不是 OLTP，在那里我要更新一

1214
00:48:16,409 --> 00:48:18,989
件事我要做很多连接，

1215
00:48:18,989 --> 00:48:21,419
我知道是我你你你你

1216
00:48:21,419 --> 00:48:26,880
通常看不到很多 的加入所以一个

1217
00:48:26,880 --> 00:48:28,679
粗略地描述这些

1218
00:48:28,679 --> 00:48:30,929
工作负载的方法是，一方面，我们知道

1219
00:48:30,929 --> 00:48:33,209
一个行为就像你说的房子

1220
00:48:33,209 --> 00:48:33,989
查询有多复杂，它们真的很

1221
00:48:33,989 --> 00:48:35,909
简单，就像你知道你只

1222
00:48:35,909 --> 00:48:37,859
访问一个表一样，或者他们是

1223
00:48:37,859 --> 00:48:39,959
做复杂的连接，然后什么是

1224
00:48:39,959 --> 00:48:42,059
他们正确的重读或重读，所以所有

1225
00:48:42,059 --> 00:48:43,380
的 TP 都会在

1226
00:48:43,380 --> 00:48:45,600
这个和频谱上他们是非常

1227
00:48:45,600 --> 00:48:47,160
简单的查询，但是他们做了

1228
00:48:47,160 --> 00:48:49,650
很多权利哦，那会做

1229
00:48:49,650 --> 00:48:50,970
很多 读取，但它们更复杂

1230
00:48:50,970 --> 00:48:52,650
，然后这种

1231
00:48:52,650 --> 00:48:54,240
称为 H 选项卡或超

1232
00:48:54,240 --> 00:48:56,100
事务分析处理的新工作负载

1233
00:48:56,100 --> 00:48:58,020
类别正在尝试正确执行这两种操作

1234
00:48:58,020 --> 00:49:00,000
您仍然想摄取新数据，

1235
00:49:00,000 --> 00:49:01,470
但您想将其分析为

1236
00:49:01,470 --> 00:49:05,370
现在你会看到很多人

1237
00:49:05,370 --> 00:49:07,320
都想在飞行中做出决策

1238
00:49:07,320 --> 00:49:09,120
你知道当人们浏览网站时

1239
00:49:09,120 --> 00:49:10,470
你会看到很多像互联网

1240
00:49:10,470 --> 00:49:16,080
广告公司 所以现在

1241
00:49:16,080 --> 00:49:17,160
鉴于我们现在了解这些不同的

1242
00:49:17,160 --> 00:49:19,200
工作负载 可以谈谈 什么是

1243
00:49:19,200 --> 00:49:22,980


1244
00:49:22,980 --> 00:49:25,800
更有效地支持这些工作负载的正确存储模型，所以

1245
00:49:25,800 --> 00:49:27,240
关系模型没有说明任何

1246
00:49:27,240 --> 00:49:31,380
关于布局的信息，但是

1247
00:49:31,380 --> 00:49:32,610
当我们决定如何构建我们的数据系统时，我们可以注意这一点

1248
00:49:32,610 --> 00:49:46,350
是的，所以这个

1249
00:49:46,350 --> 00:49:48,330
问题是 OLAP

1250
00:49:48,330 --> 00:49:52,650
与无续集或新续集系统的关系是什么所以我

1251
00:49:52,650 --> 00:49:54,830
会这么说

1252
00:49:54,830 --> 00:49:58,200
然后想知道没有续集是什么人

1253
00:49:58,200 --> 00:50:01,740
不知道什么是无序所以

1254
00:50:01,740 --> 00:50:03,630
我们大多数人还没有听说没有续集或

1255
00:50:03,630 --> 00:50:07,190
新续集所以这些 工作负载类型

1256
00:50:07,190 --> 00:50:10,140
如此，您所描述的新

1257
00:50:10,140 --> 00:50:12,990
续集与没有续集的内容

1258
00:50:12,990 --> 00:50:16,500
是系统类别，所以另一个

1259
00:50:16,500 --> 00:50:18,300
问题是我们知道什么是 MongoDB，因为

1260
00:50:18,300 --> 00:50:20,190
您知道什么是已知的

1261
00:50:20,190 --> 00:50:22,170
，以便传统的无续集

1262
00:50:22,170 --> 00:50:25,170
系统 MongoDB Cassandra Redis 他们

1263
00:50:25,170 --> 00:50:26,520
将处于这个范围的末端，

1264
00:50:26,520 --> 00:50:30,290
他们正在摄取新数据，正确

1265
00:50:30,290 --> 00:50:33,000
Mongo 有一些支持来做一些

1266
00:50:33,000 --> 00:50:36,590
分析，但是当我们谈论

1267
00:50:36,590 --> 00:50:39,060
列存储的东西时，

1268
00:50:39,060 --> 00:50:41,370
他们不会得到列存储

1269
00:50:41,370 --> 00:50:42,810
任何你知道的列存储数据库都被它赶了

1270
00:50:42,810 --> 00:50:44,100
你不想在 MongoDB 上做硬核分析

1271
00:50:44,100 --> 00:50:46,290
你可以支持一些

1272
00:50:46,290 --> 00:50:48,000
查询来做到这一点我的续集发布

1273
00:50:48,000 --> 00:50:49,680
个人支持一些

1274
00:50:49,680 --> 00:50:51,300
将属于 OLAP 类别的查询，

1275
00:50:51,300 --> 00:50:53,040
但他们 不会

1276
00:50:53,040 --> 00:50:54,950
像在列存储系统上运行那样高效，

1277
00:50:54,950 --> 00:50:57,210
所以基本上没有续集

1278
00:50:57,210 --> 00:50:59,960


1279
00:50:59,960 --> 00:51:04,800
在 2000 年代后期有这种运动，所有

1280
00:51:04,800 --> 00:51:07,530
这些所有这些公司基本上

1281
00:51:07,530 --> 00:51:09,089
都说谷歌制造的外观正在

1282
00:51:09,089 --> 00:51:11,280
制造大量 钱，他们推出了

1283
00:51:11,280 --> 00:51:12,780
这个叫做 HBase 的系统，或者一些

1284
00:51:12,780 --> 00:51:15,569
关于 BigTable 的知识，这个

1285
00:51:15,569 --> 00:51:17,190
叫做 Hadoop 的东西，

1286
00:51:17,190 --> 00:51:18,599
他们不做续集，不做交易

1287
00:51:18,599 --> 00:51:20,609
，不做连接，这

1288
00:51:20,609 --> 00:51:22,290
就是能够扩展的方式，所以所有这些人都

1289
00:51:22,290 --> 00:51:23,880
结束了 建立

1290
00:51:23,880 --> 00:51:25,920
像 Mongo 和 Cassandra 这样的没有续集的系统，

1291
00:51:25,920 --> 00:51:27,690
你知道尝试

1292
00:51:27,690 --> 00:51:29,609
遵循那些 EDX 或设计模式

1293
00:51:29,609 --> 00:51:33,690
并支持你知道的现代

1294
00:51:33,690 --> 00:51:35,400
软件 2.0 或 web 2。  0

1295
00:51:35,400 --> 00:51:37,380
应用程序是对的，但他们

1296
00:51:37,380 --> 00:51:41,069
会在这个 Hadoop 下继续使用 OLAP 但

1297
00:51:41,069 --> 00:51:43,950
就像 BigTable saundra MongoDB 和那些

1298
00:51:43,950 --> 00:51:47,190
家伙在这里然后发生的事情是

1299
00:51:47,190 --> 00:51:49,200
人们意识到哦，好吧，我确实

1300
00:51:49,200 --> 00:51:51,930
想要交易，我确实想要续集，我确实

1301
00:51:51,930 --> 00:51:54,150
想做一些连接和 这

1302
00:51:54,150 --> 00:51:55,650
就是新续集运动出现的地方，

1303
00:51:55,650 --> 00:51:57,059
这就是我在读研究生时所做的工作

1304
00:51:57,059 --> 00:51:58,950
，实际上如果你去

1305
00:51:58,950 --> 00:52:00,240
阅读维基百科的新续集文章，

1306
00:52:00,240 --> 00:52:02,520
他谈到我的系统

1307
00:52:02,520 --> 00:52:03,809
是第一个 新的

1308
00:52:03,809 --> 00:52:05,730
续集系统是对的，这是因为

1309
00:52:05,730 --> 00:52:07,440
我写了新的续集文章维基百科，

1310
00:52:07,440 --> 00:52:10,270
所以我可以说任何我想说的，

1311
00:52:10,270 --> 00:52:13,330
但这个想法是他们试图做

1312
00:52:13,330 --> 00:52:14,950
你知道他们正在尝试做快速

1313
00:52:14,950 --> 00:52:18,070
事务处理和 OLTP 而不

1314
00:52:18,070 --> 00:52:19,510
放弃事务或给予 up

1315
00:52:19,510 --> 00:52:21,420
加入了没有续集的人

1316
00:52:21,420 --> 00:52:23,650
现在所做的其他没有续集的系统你

1317
00:52:23,650 --> 00:52:26,010
可以说或者就像你再次知道

1318
00:52:26,010 --> 00:52:27,670
那里有一堆系统

1319
00:52:27,670 --> 00:52:30,910
不做你

1320
00:52:30,910 --> 00:52:32,530
想要的关系模型 做分析等等，但主要是

1321
00:52:32,530 --> 00:52:33,850
大多数人想到这里的

1322
00:52:33,850 --> 00:52:39,720
这些人我会

1323
00:52:39,720 --> 00:52:42,520
说他们首先知道他们没有续集

1324
00:52:42,520 --> 00:52:43,270
他们就像哦我们不会做

1325
00:52:43,270 --> 00:52:44,980
续集续集然后它

1326
00:52:44,980 --> 00:52:47,110
出来了每个人但是 Mongo 现在支持

1327
00:52:47,110 --> 00:52:49,000
续集的某些变体，所以他们说

1328
00:52:49,000 --> 00:52:52,110
哦，不要过度寻求我不仅是续集

1329
00:52:52,110 --> 00:52:53,369
[音乐]，

1330
00:52:53,369 --> 00:52:55,990
而且其中一些实际上是

1331
00:52:55,990 --> 00:52:57,460
从事务开始的，例如

1332
00:52:57,460 --> 00:52:59,440
MongoDB 支持完整的分发

1333
00:52:59,440 --> 00:53:01,330
事务，所以他们

1334
00:53:01,330 --> 00:53:03,369
声称的所有事情 你知道十年前是个坏主意

1335
00:53:03,369 --> 00:53:05,680
事实证明这是个好

1336
00:53:05,680 --> 00:53:06,130
主意

1337
00:53:06,130 --> 00:53:08,380
Siegel 不会很快死

1338
00:53:08,380 --> 00:53:10,500
人们已经尝试更换它是对的

1339
00:53:10,500 --> 00:53:12,520
他们一直认为

1340
00:53:12,520 --> 00:53:14,830
人们在 1970 年代 80 年代 90 年代和 2000 年代有一个坏主意

1341
00:53:14,830 --> 00:53:17,650
它总是会出现 右后，这是

1342
00:53:17,650 --> 00:53:20,920
人们想要的，这不是我喜欢的冷酷，

1343
00:53:20,920 --> 00:53:22,060
因为你知道这是我

1344
00:53:22,060 --> 00:53:24,160
长大后的样子，但肯定有改进的方法

1345
00:53:24,160 --> 00:53:25,630
人们尝试这样做，

1346
00:53:25,630 --> 00:53:28,480
但这是 t 上声明性语言的核心思想

1347
00:53:28,480 --> 00:53:30,640
你的数据是我认为

1348
00:53:30,640 --> 00:53:32,320
这甚至

1349
00:53:32,320 --> 00:53:34,810
是 1970 年代 Ted Cod 工作的主要贡献之一

1350
00:53:34,810 --> 00:53:38,980
是的，我做到了，有很长的

1351
00:53:38,980 --> 00:53:40,390
独白可以回答你的问题，

1352
00:53:40,390 --> 00:53:43,750
好吧，如果你

1353
00:53:43,750 --> 00:53:46,560
想要我对其他系统的看法，我们可以离线讨论

1354
00:53:46,560 --> 00:53:47,740
好的

1355
00:53:47,740 --> 00:53:50,080
，到目前为止，

1356
00:53:50,080 --> 00:53:51,790
当我们显示行和元组

1357
00:53:51,790 --> 00:53:53,500
排序的元组时，我们讨论的所有内容都是这样的，这就是为什么我

1358
00:53:53,500 --> 00:53:54,910
想使用转行，因为当我们

1359
00:53:54,910 --> 00:53:56,170
谈论列存储时，它没有任何

1360
00:53:56,170 --> 00:53:56,560
意义，

1361
00:53:56,560 --> 00:53:58,960
但每次我 显示了一个元组我把

1362
00:53:58,960 --> 00:54:01,390
它显示为一行右边，这被称为

1363
00:54:01,390 --> 00:54:04,960
n Airy 存储模型，所以

1364
00:54:04,960 --> 00:54:06,520
这里的基本想法是我们运行

1365
00:54:06,520 --> 00:54:08,530
获取单个元组的所有属性，

1366
00:54:08,530 --> 00:54:10,240
然后在我们的页面中连续恢复它们

1367
00:54:10,240 --> 00:54:12,550
现在我们可以再次拥有 溢出页面

1368
00:54:12,550 --> 00:54:15,609
- 你知道大型对象，

1369
00:54:15,609 --> 00:54:18,040
但一般来说，它们都会对齐

1370
00:54:18,040 --> 00:54:21,190
在一起，所以这将是一个

1371
00:54:21,190 --> 00:54:23,770
想法 400 TP 因为

1372
00:54:23,770 --> 00:54:25,720
开始我们将要访问的数据量

1373
00:54:25,720 --> 00:54:28,690
在这些旧

1374
00:54:28,690 --> 00:54:29,740
速度下会很小 查询，它是 将

1375
00:54:29,740 --> 00:54:32,260
访问单个实体 获取我的

1376
00:54:32,260 --> 00:54:34,750
帐户信息 获取我的订单

1377
00:54:34,750 --> 00:54:37,119
我想要所有数据，你知道

1378
00:54:37,119 --> 00:54:39,490
你知道我的帐户 我不

1379
00:54:39,490 --> 00:54:40,570
关心所有其他你认识的数百万

1380
00:54:40,570 --> 00:54:42,730
客户 我确实想要我的信息

1381
00:54:42,730 --> 00:54:44,170
如果烤肉或那实际上非常

1382
00:54:44,170 --> 00:54:46,000
有效，因为我只是跳转到

1383
00:54:46,000 --> 00:54:48,220
包含我的数据的一页我得到它并且我已经

1384
00:54:48,220 --> 00:54:50,560
完成了所以让我们

1385
00:54:50,560 --> 00:54:52,480
再次使用维基百科

1386
00:54:52,480 --> 00:54:55,750
示例看看它是什么样子所以说这是一个单页 所以

1387
00:54:55,750 --> 00:54:58,060
我们有一个标题我可以假设这是

1388
00:54:58,060 --> 00:55:00,910
在槽分槽页面格式我们有

1389
00:55:00,910 --> 00:55:02,710
我们的标题然后我们有用户 ID

1390
00:55:02,710 --> 00:55:04,780
username user 过去的主机名它

1391
00:55:04,780 --> 00:55:07,270
再次 Lazlo 所以当我们只在之后添加

1392
00:55:07,270 --> 00:55:10,480
我们的最后一个属性时 元组

1393
00:55:10,480 --> 00:55:12,670
然后我们拥有所有其他元组元组

1394
00:55:12,670 --> 00:55:15,670
数据正确的一切都是彼此连续的

1395
00:55:15,670 --> 00:55:17,950
所以现在如果我将

1396
00:55:17,950 --> 00:55:19,660
它存储在我的数据库中我可以

1397
00:55:19,660 --> 00:55:22,240
在单个页面中表示它所以现在如果我有一个

1398
00:55:22,240 --> 00:55:23,980
查询说获取所有帐户

1399
00:55:23,980 --> 00:55:25,450
信息 对于给定的 用户名和

1400
00:55:25,450 --> 00:55:28,480
密码 我可以做一个查找和一个索引

1401
00:55:28,480 --> 00:55:30,609
，我们将在第七讲中介绍，

1402
00:55:30,609 --> 00:55:32,349
但基本上他们告诉我嘿，

1403
00:55:32,349 --> 00:55:34,540
这是页面 ID 和槽号，里面

1404
00:55:34,540 --> 00:55:36,760
有你想要的元组 我做一个

1405
00:55:36,760 --> 00:55:38,680
搜索 我做一个阅读 获取该页面

1406
00:55:38,680 --> 00:55:40,599
将他带到内存中，我可以再次准确跳转到

1407
00:55:40,599 --> 00:55:41,890


1408
00:55:41,890 --> 00:55:45,609
包含我想要的数据的位置，尽管

1409
00:55:45,609 --> 00:55:46,750
我们的工作负载看起来

1410
00:55:46,750 --> 00:55:48,940
很像这样去获取单个

1411
00:55:48,940 --> 00:55:50,950
实体或少量实体的数据，所以

1412
00:55:50,950 --> 00:55:54,460
有 一个元组的所有数据

1413
00:55:54,460 --> 00:55:56,290
相互连续是最

1414
00:55:56,290 --> 00:55:59,349
有效的方法来做同样的

1415
00:55:59,349 --> 00:56:01,900
事情，关于一个插入我的插入

1416
00:56:01,900 --> 00:56:02,920
查询无论如何都会有所有的数据

1417
00:56:02,920 --> 00:56:05,050
连续所以我只是找到一个空闲的

1418
00:56:05,050 --> 00:56:06,970
插槽并且完全正确

1419
00:56:06,970 --> 00:56:09,670
立即将其刷新出来，

1420
00:56:09,670 --> 00:56:10,660
它是一个磁盘，

1421
00:56:10,660 --> 00:56:18,760
忽略日志是的，所以这个问题

1422
00:56:18,760 --> 00:56:20,440
是出于什么目的

1423
00:56:20,440 --> 00:56:23,820
将数据分离到页面中有用，所以

1424
00:56:23,820 --> 00:56:26,200
让我们看看为什么这对某些查询来说是个坏主意

1425
00:56:26,200 --> 00:56:27,400
，然后我们

1426
00:56:27,400 --> 00:56:29,170


1427
00:56:29,170 --> 00:56:30,220
当我们讨论

1428
00:56:30,220 --> 00:56:31,660
列中的分解存储模型时，会明白为什么将它隔离是一个

1429
00:56:31,660 --> 00:56:34,810
好主意，所以让我们看看

1430
00:56:34,810 --> 00:56:35,890
行存储是一个坏主意的例子，

1431
00:56:35,890 --> 00:56:37,119
所以让我们

1432
00:56:37,119 --> 00:56:37,900
采用我在开头展示的那个查询

1433
00:56:37,900 --> 00:56:39,190
我们想要让所有

1434
00:56:39,190 --> 00:56:41,519
政府人员

1435
00:56:41,519 --> 00:56:43,599
在不应该修改维基百科页面的情况下，

1436
00:56:43,599 --> 00:56:45,730
所以我们分解这个查询，

1437
00:56:45,730 --> 00:56:48,759
我们查看它，我们意识到我们

1438
00:56:48,759 --> 00:56:49,839
实际上需要正确地接触所有

1439
00:56:49,839 --> 00:56:51,160
数据，因为有一个

1440
00:56:51,160 --> 00:56:53,980
整个用户帐户

1441
00:56:53,980 --> 00:56:57,460
表的完整顺序扫描以查找所有您认识的人

1442
00:56:57,460 --> 00:56:58,869
查看所有用户帐户

1443
00:56:58,869 --> 00:57:00,190
查看他们的主机名 我假设我们

1444
00:57:00,190 --> 00:57:02,170
没有 OLAP 索引，您通常

1445
00:57:02,170 --> 00:57:05,650
没有这些类型的索引

1446
00:57:05,650 --> 00:57:08,769
查询没问题，所以现在如果我去读

1447
00:57:08,769 --> 00:57:10,720
说我读的第一页又是这个

1448
00:57:10,720 --> 00:57:13,630
我们在这里的行存储所以我

1449
00:57:13,630 --> 00:57:15,759
看看我的查询我想先做一个

1450
00:57:15,759 --> 00:57:17,470
where 子句是查找主机名

1451
00:57:17,470 --> 00:57:19,480
并尝试 匹配我的模式，如果它

1452
00:57:19,480 --> 00:57:21,849
以 gov 所以这意味着我基本上

1453
00:57:21,849 --> 00:57:24,609
只是想让你知道这里的这些值，所以

1454
00:57:24,609 --> 00:57:26,710
当我扫描时，我查看我的

1455
00:57:26,710 --> 00:57:28,930
目录并说我知道我有

1456
00:57:28,930 --> 00:57:31,749
这张表我有五个属性，

1457
00:57:31,749 --> 00:57:33,369
你想要主机名，

1458
00:57:33,369 --> 00:57:34,660
这就是全部 设置所以我去阅读它们但我

1459
00:57:34,660 --> 00:57:37,059
想要然后我到最后我会

1460
00:57:37,059 --> 00:57:39,730
跳到下一个等等

1461
00:57:39,730 --> 00:57:40,960
我的查询的另一部分是我有

1462
00:57:40,960 --> 00:57:42,880
这个组我想将

1463
00:57:42,880 --> 00:57:45,309
它们聚合在一起 登录，因为

1464
00:57:45,309 --> 00:57:49,930
我想每个月都得到它，然后

1465
00:57:49,930 --> 00:57:51,009
好吧，然后将其作为我的最终

1466
00:57:51,009 --> 00:57:52,390
输出，它是每个月登录的政府雇员的计数，

1467
00:57:52,390 --> 00:57:53,529


1468
00:57:53,529 --> 00:57:56,380
因此满足

1469
00:57:56,380 --> 00:57:58,539
查询的这一部分我只需要此列

1470
00:57:58,539 --> 00:58:01,259
属性只是最后一个登录字段

1471
00:58:01,259 --> 00:58:10,049
所以有什么问题 那到底是

1472
00:58:10,680 --> 00:58:12,789
什么 所以我不得不再次阅读

1473
00:58:12,789 --> 00:58:15,910
整个页面 我不能在内存中

1474
00:58:15,910 --> 00:58:18,069
我在非易失性存储设备中

1475
00:58:18,069 --> 00:58:21,130
说它是一个基于块的 API 所以我不能只是

1476
00:58:21,130 --> 00:58:24,099
说只是给我这些这些数据

1477
00:58:24,099 --> 00:58:26,859
我得去带来 在整个页面中，所以

1478
00:58:26,859 --> 00:58:29,109
现在您在这里拥有所有这些列

1479
00:58:29,109 --> 00:58:30,910
，我什至根本不会访问

1480
00:58:30,910 --> 00:58:32,470
以退出此查询，但我必须

1481
00:58:32,470 --> 00:58:35,739
将其从磁盘带入内存

1482
00:58:35,739 --> 00:58:37,450
以获取

1483
00:58:37,450 --> 00:58:41,769
我 实际上需要，所以如果你有很多数据，那么

1484
00:58:41,769 --> 00:58:44,440
对行存储进行分析会很痛苦

1485
00:58:44,440 --> 00:58:46,599
，我

1486
00:58:46,599 --> 00:58:49,509
这里的例子我有六页，但如果我

1487
00:58:49,509 --> 00:58:50,560
有你知道 PB

1488
00:58:50,560 --> 00:58:53,590
，在这种情况下，

1489
00:58:53,590 --> 00:58:55,120
五列中的三列是 我正在引入或

1490
00:58:55,120 --> 00:58:56,650
atrás 我引入的对于特定查询是无用的，

1491
00:58:56,650 --> 00:58:58,810
那么这是一个坏主意

1492
00:58:58,810 --> 00:59:01,690
，这是硬件的低效使用，

1493
00:59:01,690 --> 00:59:05,020
因此再次 NRI 存储

1494
00:59:05,020 --> 00:59:08,710
模型 rostral 行存储模型是我们

1495
00:59:08,710 --> 00:59:10,840
非常快或任何插入或更新 或

1496
00:59:10,840 --> 00:59:12,850
删除当我们访问整个

1497
00:59:12,850 --> 00:59:15,310
元组时，我们想要

1498
00:59:15,310 --> 00:59:16,660
单个元组的所有速率，通常一次只有

1499
00:59:16,660 --> 00:59:19,090
少量元组，但如果

1500
00:59:19,090 --> 00:59:20,710
您必须进行分析查询和

1501
00:59:20,710 --> 00:59:22,360
我们想要扫描的 OLAP 工作负载

1502
00:59:22,360 --> 00:59:24,310
餐桌上的大部分然后 会很

1503
00:59:24,310 --> 00:59:25,990
糟糕，因为我们将带来

1504
00:59:25,990 --> 00:59:27,250
一堆数据，因为我们可能

1505
00:59:27,250 --> 00:59:30,910
实际上并不需要我们的查询，所以

1506
00:59:30,910 --> 00:59:32,320
现在应该很明显，这

1507
00:59:32,320 --> 00:59:33,610
是合成或东西出现的

1508
00:59:33,610 --> 00:59:37,540
地方而不是 将

1509
00:59:37,540 --> 00:59:39,220
单个元组的所有属性一起存储

1510
00:59:39,220 --> 00:59:41,320
在单个页面中 我们实际上将

1511
00:59:41,320 --> 00:59:43,840


1512
00:59:43,840 --> 00:59:45,970
跨单个页面中的所有元组存储单个属性的所有值

1513
00:59:45,970 --> 00:59:48,670
我对其进行排序 这是

1514
00:59:48,670 --> 00:59:50,020
列名称所在的位置 我们只是 将

1515
00:59:50,020 --> 00:59:52,240
所有列连续存储在一起 连续对

1516
00:59:52,240 --> 00:59:53,860
单个列中的所有值感到抱歉，

1517
00:59:53,860 --> 00:59:57,100
所以这

1518
00:59:57,100 --> 00:59:59,200
对于我们只读的 OLAP 工作负载来说太棒了

1519
00:59:59,200 --> 01:00:01,510
，我们只想读取

1520
01:00:01,510 --> 01:00:05,290
给定表的戏剧的一个子集

1521
01:00:05,290 --> 01:00:08,830
是的，再次回到我们

1522
01:00:08,830 --> 01:00:10,330
这里的例子，这就是它看起来

1523
01:00:10,330 --> 01:00:12,970
像一个行存储，但现在我们

1524
01:00:12,970 --> 01:00:15,700
只需要每一列，我们

1525
01:00:15,700 --> 01:00:16,960
将把它分开，然后

1526
01:00:16,960 --> 01:00:19,690
在一个页面中我们只有

1527
01:00:19,690 --> 01:00:21,520
该列的数据，所以这里是所有的

1528
01:00:21,520 --> 01:00:23,680
h  ost 名称在一起，我们有同样的

1529
01:00:23,680 --> 01:00:25,210
事情，用户 ID 上次登录，

1530
01:00:25,210 --> 01:00:26,580
这个表的其他属性在这里

1531
01:00:26,580 --> 01:00:30,580
好吧等等，所以现在我

1532
01:00:30,580 --> 01:00:32,980
回到我们之前的这个查询，所以

1533
01:00:32,980 --> 01:00:34,720
我需要做的第一件事就是做我的

1534
01:00:34,720 --> 01:00:37,000
关于主机名的条款，所以现在我只需要

1535
01:00:37,000 --> 01:00:38,710
知道我所要做的就是引入

1536
01:00:38,710 --> 01:00:42,040
错误颜色的主机名页面但

1537
01:00:42,040 --> 01:00:44,770
忽略我只是引入主机名页面

1538
01:00:44,770 --> 01:00:46,780
然后我可以快速翻阅，说

1539
01:00:46,780 --> 01:00:48,910
查看每个主机名并执行我的

1540
01:00:48,910 --> 01:00:51,630
我的谓词现在有一堆

1541
01:00:51,630 --> 01:00:54,310
匹配的元组，然后我返回

1542
01:00:54,310 --> 01:00:57,430
并引入所有游戏页面的最后一个，

1543
01:00:57,430 --> 01:00:59,620
然后跳转

1544
01:00:59,620 --> 01:01:01,210
到我需要的位置并

1545
01:01:01,210 --> 01:01:02,770
获取我想要的最后登录信息

1546
01:01:02,770 --> 01:01:03,369


1547
01:01:03,369 --> 01:01:06,430
给出我的答案，所以在一个

1548
01:01:06,430 --> 01:01:07,960
真正简单的情况下说，最后

1549
01:01:07,960 --> 01:01:09,880
登录页面是一个最后登录数据是一个

1550
01:01:09,880 --> 01:01:12,640
页面，主机名是另一个页面，所以

1551
01:01:12,640 --> 01:01:14,680
在我不得不扫描所有页面之前，我不仅必须扫描所有页面

1552
01:01:14,680 --> 01:01:16,180


1553
01:01:16,180 --> 01:01:18,249
如果我是 ta，我无法在极端情况下思考

1554
01:01:18,249 --> 01:01:21,039
大约有数十亿页我那么

1555
01:01:21,039 --> 01:01:22,210
这是一个很大的区别

1556
01:01:22,210 --> 01:01:27,730
是的所以这个问题是我们是否

1557
01:01:27,730 --> 01:01:29,380
将主键与每一列一起存储

1558
01:01:29,380 --> 01:01:31,269
你真正的问题是我

1559
01:01:31,269 --> 01:01:33,430
如何确定我有匹配的主机名

1560
01:01:33,430 --> 01:01:35,230
然后我如何查找 在最后一个登录

1561
01:01:35,230 --> 01:01:36,730
列中，找出它们如何与

1562
01:01:36,730 --> 01:01:37,869
下一张幻灯片

1563
01:01:37,869 --> 01:01:43,569
完美匹配，你有问题所以

1564
01:01:43,569 --> 01:01:44,589
打击是我们可以做的其他

1565
01:01:44,589 --> 01:01:45,940
事情，我们不会在本

1566
01:01:45,940 --> 01:01:47,529
课程中介绍，但

1567
01:01:47,529 --> 01:01:49,240
实际上你可以获得的大多数其他优势 如果你

1568
01:01:49,240 --> 01:01:51,099
在两周后参加垂直谈话，Vertica

1569
01:01:51,099 --> 01:01:55,119
非常有名，所以使用

1570
01:01:55,119 --> 01:01:59,650
行存储模型

1571
01:01:59,650 --> 01:02:01,240
，元组中的所有值或属性

1572
01:02:01,240 --> 01:02:03,279
都是你所知道的大致不同的

1573
01:02:03,279 --> 01:02:05,230
域，这将是一个

1574
01:02:05,230 --> 01:02:06,910
用户名 将是主机名

1575
01:02:06,910 --> 01:02:08,410
这是我上次登录 我们只是要看看

1576
01:02:08,410 --> 01:02:10,869
一个时间戳 一切都

1577
01:02:10,869 --> 01:02:14,289
混杂在一起 所以如果我可以将

1578
01:02:14,289 --> 01:02:16,480
所有这些数据打包

1579
01:02:16,480 --> 01:02:18,609
在一起 现在是

1580
01:02:18,609 --> 01:02:21,579
压缩技术之一 我可以这样做，因为

1581
01:02:21,579 --> 01:02:23,440
我知道它们都是相同的

1582
01:02:23,440 --> 01:02:28,539
类型，所以让我们说假设

1583
01:02:28,539 --> 01:02:30,309
我正在存储房间的温度，

1584
01:02:30,309 --> 01:02:32,920
你知道现在是 70 度，也许

1585
01:02:32,920 --> 01:02:34,630
70 点一七八七十点

1586
01:02:34,630 --> 01:02:36,339
二像 它不会波动那么

1587
01:02:36,339 --> 01:02:38,410
大，而不是

1588
01:02:38,410 --> 01:02:40,450
每次都存储全温度，

1589
01:02:40,450 --> 01:02:43,089
正确的是更短的

1590
01:02:43,089 --> 01:02:44,470
是我们

1591
01:02:44,470 --> 01:02:45,759
第一次开始测量时基本温度的小增量，

1592
01:02:45,759 --> 01:02:47,470
现在我不需要存储整个

1593
01:02:47,470 --> 01:02:49,239
值 再一次，我只是存储你

1594
01:02:49,239 --> 01:02:51,299
知道这是较小的表示我

1595
01:02:51,299 --> 01:02:53,739
想我的意思是想想你是否知道

1596
01:02:53,739 --> 01:02:55,960
你是否像 gzip 或 snappy 或任何

1597
01:02:55,960 --> 01:02:57,069
你最喜欢的压缩算法一样

1598
01:02:57,069 --> 01:02:59,710
你不能很好地压缩 mp3，

1599
01:02:59,710 --> 01:03:00,579
因为已经有一些

1600
01:03:00,579 --> 01:03:02,829
压缩，但是如果 这是一个文本文件，

1601
01:03:02,829 --> 01:03:04,329
你可以压缩它，

1602
01:03:04,329 --> 01:03:05,410
因为会有一堆

1603
01:03:05,410 --> 01:03:06,609
字符一遍又一遍地重复，

1604
01:03:06,609 --> 01:03:10,299
所以如果你的属性中有重复的值，

1605
01:03:10,299 --> 01:03:12,640
那么你 可以

1606
01:03:12,640 --> 01:03:13,720
压缩它并获得

1607
01:03:13,720 --> 01:03:15,579
更好的性能所以现在当我

1608
01:03:15,579 --> 01:03:17,190
想要再次

1609
01:03:17,190 --> 01:03:19,259
阅读每个页面获取而不是可能

1610
01:03:19,259 --> 01:03:20,549
获得一千个元组时，我

1611
01:03:20,549 --> 01:03:22,319
可以获得一万两本书，因为在

1612
01:03:22,319 --> 01:03:24,509
压缩形式和某些系统中

1613
01:03:24,509 --> 01:03:25,529
实际上可以在

1614
01:03:25,529 --> 01:03:26,670
没有你的情况下直接对压缩数据进行操作而无需

1615
01:03:26,670 --> 01:03:29,670
挂起压缩器 这是一个巨大的

1616
01:03:29,670 --> 01:03:33,420
胜利 好吧我们不讲 我们不会

1617
01:03:33,420 --> 01:03:35,670
在这门课中讲压缩 我们

1618
01:03:35,670 --> 01:03:36,690
在高级课上花了整整一

1619
01:03:36,690 --> 01:03:37,859
堂课 但我很高兴

1620
01:03:37,859 --> 01:03:41,460
如果你想多谈谈，那么现在他的

1621
01:03:41,460 --> 01:03:44,549
问题是我如何弄清楚我

1622
01:03:44,549 --> 01:03:46,380
在一个页面中有一个匹配我如何在另一个页面中找到一个匹配

1623
01:03:46,380 --> 01:03:48,630
所以通常有

1624
01:03:48,630 --> 01:03:51,000
两种方法，但每个人几乎都是

1625
01:03:51,000 --> 01:03:54,000
第一种 一个所以第一个选择

1626
01:03:54,000 --> 01:03:56,400
是固定长度的所有集合，这

1627
01:03:56,400 --> 01:04:00,240
意味着对于列中的每个值，

1628
01:04:00,240 --> 01:04:02,549
它始终是固定

1629
01:04:02,549 --> 01:04:06,210
长度，因此再次考虑简单的 32 位

1630
01:04:06,210 --> 01:04:07,890
整数，因此所有这些都将是这些中的

1631
01:04:07,890 --> 01:04:10,019
每一个 VA  lues 是 32 位，所以

1632
01:04:10,019 --> 01:04:12,859
现在如果我在此列

1633
01:04:12,859 --> 01:04:16,170
中的偏移量 1 处有一个匹配，我再次需要

1634
01:04:16,170 --> 01:04:18,390
在此列中找到相应的元组，

1635
01:04:18,390 --> 01:04:20,490
我知道这也是

1636
01:04:20,490 --> 01:04:22,289
32 位，我可以做一个简单的

1637
01:04:22,289 --> 01:04:25,769
算术并说我想要偏移量

1638
01:04:25,769 --> 01:04:27,509
是每个属性大小的 1 倍，然后我

1639
01:04:27,509 --> 01:04:29,400
确切地知道我需要跳转到的位置或

1640
01:04:29,400 --> 01:04:31,950
将其转换为行 ID 或

1641
01:04:31,950 --> 01:04:33,569
具有我正在寻找的数据的页码和槽号

1642
01:04:33,569 --> 01:04:36,059


1643
01:04:36,059 --> 01:04:37,200
这当然可能是最标准的

1644
01:04:37,200 --> 01:04:38,759
方法，现在棘手的事情是

1645
01:04:38,759 --> 01:04:40,019
说如果我有一堆

1646
01:04:40,019 --> 01:04:42,089
像旧的一样变化的字符串怎么办然后你

1647
01:04:42,089 --> 01:04:43,589
就可以了，我可以将它压缩

1648
01:04:43,589 --> 01:04:45,240
到固定长度的字段或填充它的类型

1649
01:04:45,240 --> 01:04:46,799


1650
01:04:46,799 --> 01:04:49,349
无论最大大小如何，outs 总是适合不同的数据系统

1651
01:04:49,349 --> 01:04:50,970
做不同的事情，但总的来说

1652
01:04:50,970 --> 01:04:52,859
这是最常见

1653
01:04:52,859 --> 01:04:56,339
的商业方法另一种方法我

1654
01:04:56,339 --> 01:04:58,140
忘记了有一个系统这样做

1655
01:04:58,140 --> 01:04:59,400
我认为这是一个坏主意

1656
01:04:59,400 --> 01:05:00,450
他们可能有 摆脱了它 但我

1657
01:05:00,450 --> 01:05:02,730
忘记了你实际

1658
01:05:02,730 --> 01:05:05,640
存储在每个列中的每个值的位置

1659
01:05:05,640 --> 01:05:09,089
你存储主键或

1660
01:05:09,089 --> 01:05:11,160
它的标识符所以然后你说

1661
01:05:11,160 --> 01:05:13,079
好的我在它的第一列我

1662
01:05:13,079 --> 01:05:15,089
正在查看元组 1 我想访问

1663
01:05:15,089 --> 01:05:17,220
元组 1 并且列 BI 有另一个映射，

1664
01:05:17,220 --> 01:05:18,960
或者进行查找并说明

1665
01:05:18,960 --> 01:05:21,990
如何找到

1666
01:05:21,990 --> 01:05:25,319
该列中特定元组的偏移位置，

1667
01:05:25,319 --> 01:05:26,819
当然这显然具有巨大的存储

1668
01:05:26,819 --> 01:05:28,049
开销，因为您是 存储这个，

1669
01:05:28,049 --> 01:05:30,789
因为你知道这个额外的 32 位或 64 位

1670
01:05:30,789 --> 01:05:34,509
值或我们每个

1671
01:05:34,509 --> 01:05:40,539
值的 ID，这很浪费，

1672
01:05:40,539 --> 01:05:43,029
好吧，所以列存储的

1673
01:05:43,029 --> 01:05:45,699
优点是我们可以减少

1674
01:05:45,699 --> 01:05:47,140
我欠这些 OLAP 查询的浪费量，

1675
01:05:47,140 --> 01:05:49,089
因为我们 '只读取

1676
01:05:49,089 --> 01:05:50,529
我们实际需要的承载数据量

1677
01:05:50,529 --> 01:05:51,759
我们不会引入我们永远

1678
01:05:51,759 --> 01:05:54,219
不会需要的东西 所有这些都会得到更好的

1679
01:05:54,219 --> 01:05:56,199
压缩 将给它一个更好的

1680
01:05:56,199 --> 01:05:57,969
查询处理

1681
01:05:57,969 --> 01:06:00,130
我们知道

1682
01:06:00,130 --> 01:06:03,359
我们知道 现在我们正在对列

1683
01:06:03,359 --> 01:06:06,849
数据进行操作，缺点显然是对于

1684
01:06:06,849 --> 01:06:08,439
任何需要访问单个

1685
01:06:08,439 --> 01:06:11,079
元组的东西，它变得更加昂贵，因为

1686
01:06:11,079 --> 01:06:12,789
现在您基本上需要将

1687
01:06:12,789 --> 01:06:15,910
来自不同列的元组

1688
01:06:15,910 --> 01:06:17,469
重新组合在一起，而在行存储中

1689
01:06:17,469 --> 01:06:19,119
这一切 只在一个位置为您服务

1690
01:06:19,119 --> 01:06:21,609
，无论何时更新或以某种方式

1691
01:06:21,609 --> 01:06:22,599
删除，这都会变得更加昂贵，

1692
01:06:22,599 --> 01:06:23,859
因为再次因为您可以

1693
01:06:23,859 --> 01:06:26,919
将其全部拆分，所以我想说

1694
01:06:26,919 --> 01:06:30,279
列存储并不是一个新想法，它们可以

1695
01:06:30,279 --> 01:06:32,559
追溯到 1970 年代有 就像

1696
01:06:32,559 --> 01:06:35,829
瑞典军事部门建立了

1697
01:06:35,829 --> 01:06:37,299
一个叫做 Cantor 的东西，本质

1698
01:06:37,299 --> 01:06:38,679
上他们没有称它为数据库

1699
01:06:38,679 --> 01:06:39,579
系统，因为他们在 1970 年代使用了不同的

1700
01:06:39,579 --> 01:06:41,890
语言，但是如果你

1701
01:06:41,890 --> 01:06:43,959
在字里行间阅读它的

1702
01:06:43,959 --> 01:06:45,579
本质，它是一个列存储数据库

1703
01:06:45,579 --> 01:06:48,279
系统 它从未发布 从未

1704
01:06:48,279 --> 01:06:50,259
公开过流行 这是唯一

1705
01:06:50,259 --> 01:06:51,400
的内部项目 但这是

1706
01:06:51,400 --> 01:06:53,469
第一个已知的列

1707
01:06:53,469 --> 01:06:56,769
存储 1980 年代有一个

1708
01:06:56,769 --> 01:06:58,299
描述分解存储

1709
01:06:58,299 --> 01:07:00,099
模型的论文以及更多详细信息，说明

1710
01:07:00,099 --> 01:07:01,659
您知道

1711
01:07:01,659 --> 01:07:03,009
什么是短格式是什么样的

1712
01:07:03,009 --> 01:07:04,749


1713
01:07:04,749 --> 01:07:07,150


1714
01:07:07,150 --> 01:07:08,890


1715
01:07:08,890 --> 01:07:10,659


1716
01:07:10,659 --> 01:07:13,150
这个叫做 sybase IQ 的东西是

1717
01:07:13,150 --> 01:07:14,709
一个内存中的列存储，它是 Sybase

1718
01:07:14,709 --> 01:07:16,390
作为他们

1719
01:07:16,390 --> 01:07:19,299
常规行存储数据库系统的加速器发布的

1720
01:07:19,299 --> 01:07:20,979


1721
01:07:20,979 --> 01:07:23,979


1722
01:07:23,979 --> 01:07:25,539


1723
01:07:25,539 --> 01:07:28,029
作为行存储数据库的附加组件出售，

1724
01:07:28,029 --> 01:07:29,619
而不是独立的东西，

1725
01:07:29,619 --> 01:07:32,049
但在 2000 年代，列

1726
01:07:32,049 --> 01:07:34,029
存储的东西真正起飞了 Vertica

1727
01:07:34,029 --> 01:07:35,769
是由 Mike Stormbreaker 创立

1728
01:07:35,769 --> 01:07:37,539
的，他承认 Postgres 和 Ingress

1729
01:07:37,539 --> 01:07:40,089
是他的公司被收购

1730
01:07:40,089 --> 01:07:43,419
HP vector wise 是 mo'ne 的内存版本，

1731
01:07:43,419 --> 01:07:44,530
如果

1732
01:07:44,530 --> 01:07:46,900
他们离开欧洲，它是学术项目，

1733
01:07:46,900 --> 01:07:48,760
但今天仍然存在 ee 他

1734
01:07:48,760 --> 01:07:50,140
断言我们系统的第一种列

1735
01:07:50,140 --> 01:07:51,700
是在

1736
01:07:51,700 --> 01:07:54,610
2000 年代制造的，但很快

1737
01:07:54,610 --> 01:07:55,750
就发现这是

1738
01:07:55,750 --> 01:07:58,570
构建数据系统以进行分析的正确方法，所以

1739
01:07:58,570 --> 01:08:00,660
现在几乎每个人都有自己的

1740
01:08:00,660 --> 01:08:03,460
列存储系统，实际上我

1741
01:08:03,460 --> 01:08:05,410
今天想演示 Vertica 我

1742
01:08:05,410 --> 01:08:07,210
无法运行它我确实让

1743
01:08:07,210 --> 01:08:09,580
Maria DB 列存储工作，而

1744
01:08:09,580 --> 01:08:11,200
stephannie 列存储并不意味着

1745
01:08:11,200 --> 01:08:13,810
它实际上很好所以

1746
01:08:13,810 --> 01:08:15,220
我们将在继续进行时介绍很多东西

1747
01:08:15,220 --> 01:08:16,689
韩国执行中的查询优化

1748
01:08:16,689 --> 01:08:18,549
仅仅因为我切断了你的通讯或者并不

1749
01:08:18,549 --> 01:08:20,740
意味着你会神奇地走得更快

1750
01:08:20,740 --> 01:08:22,630
我实际上能够让 Postgres

1751
01:08:22,630 --> 01:08:24,250
击败列存储进行分析

1752
01:08:24,250 --> 01:08:27,640
查询，因为你知道你

1753
01:08:27,640 --> 01:08:29,649
实际上如何查询你的实际外观

1754
01:08:29,649 --> 01:08:31,750
在数据和查询计划

1755
01:08:31,750 --> 01:08:33,580
看起来像什么 所以我们必须做的一堆

1756
01:08:33,580 --> 01:08:34,630
事情 我们将在整个

1757
01:08:34,630 --> 01:08:36,520
学期涵盖

1758
01:08:36,520 --> 01:08:37,600
如果你知道污垢 如果你是一个

1759
01:08:37,600 --> 01:08:41,609
列存储 不是每个人都做得很好，

1760
01:08:41,609 --> 01:08:43,930
所以任何关于专栏商店的问题，所以

1761
01:08:43,930 --> 01:08:45,819
如果你离开，我从 CMU 毕业

1762
01:08:45,819 --> 01:08:48,130
，你想做分析，有些

1763
01:08:48,130 --> 01:08:49,390
人就像让我们在草地上做，但

1764
01:08:49,390 --> 01:08:51,939
它是烤的，或者不这样做，

1765
01:08:51,939 --> 01:08:53,529
有足够的专栏 对于

1766
01:08:53,529 --> 01:08:56,439
那些在那里的系统，你

1767
01:08:56,439 --> 01:08:58,120
想看看它们并不便宜，但

1768
01:08:58,120 --> 01:08:59,560
至少对于商业系统来说，但

1769
01:08:59,560 --> 01:09:01,140
有一些不错的开源系统，

1770
01:09:01,140 --> 01:09:06,370
好吧，很酷，所以主要的

1771
01:09:06,370 --> 01:09:08,290
收获是，正如我们 显示

1772
01:09:08,290 --> 01:09:12,850


1773
01:09:12,850 --> 01:09:14,819
数据库存储的底层表示

1774
01:09:14,819 --> 01:09:17,109
不是我们可以放在我们的

1775
01:09:17,109 --> 01:09:19,390
存储管理器中的东西，而不是在本学期剩下的时间里暴露给系统的任何

1776
01:09:19,390 --> 01:09:21,430
其他部分，

1777
01:09:21,430 --> 01:09:22,839
你会看到

1778
01:09:22,839 --> 01:09:24,850
很多时候我会说，好吧

1779
01:09:24,850 --> 01:09:25,839
，如果您是行

1780
01:09:25,839 --> 01:09:27,250
存储，这就是这样做的方法，如果您是列存储，则这是这样做的方法

1781
01:09:27,250 --> 01:09:29,799
，那是因为

1782
01:09:29,799 --> 01:09:31,870
我们再次知道，如果我们知道数据系统知道 更多

1783
01:09:31,870 --> 01:09:33,220
关于它实际上在做

1784
01:09:33,220 --> 01:09:35,080
什么 数据看起来如何 li  ke 它会做出

1785
01:09:35,080 --> 01:09:36,370
更好的决定和更好的设计

1786
01:09:36,370 --> 01:09:38,710
选择，为了让你知道

1787
01:09:38,710 --> 01:09:41,589
更有效的执行，另一件事

1788
01:09:41,589 --> 01:09:43,510
也要记住，基本上对于 osep，

1789
01:09:43,510 --> 01:09:45,460
你想对 OLAP 使用行存储，你

1790
01:09:45,460 --> 01:09:46,990
想使用列存储，

1791
01:09:46,990 --> 01:09:49,750
但这很简单 规则将带

1792
01:09:49,750 --> 01:09:52,180
你度过余生，让

1793
01:09:52,180 --> 01:09:56,080
你的生活更轻松，所以现在最后

1794
01:09:56,080 --> 01:09:58,449
两节课我们在

1795
01:09:58,449 --> 01:09:59,949
这里讨论了这个问题如何实际

1796
01:09:59,949 --> 01:10:01,719
表示数据库中的数据所以

1797
01:10:01,719 --> 01:10:04,869
现在从周三开始我们将

1798
01:10:04,869 --> 01:10:06,100
讨论什么 我们是否添加我们实际上

1799
01:10:06,100 --> 01:10:08,980
将数据引入并将它们带入内存并

1800
01:10:08,980 --> 01:10:13,960
管理是的这个问题是否

1801
01:10:13,960 --> 01:10:15,070
有充分的理由将两者混合，

1802
01:10:15,070 --> 01:10:17,739
所以我们实际上构建了我们的戴维森，它

1803
01:10:17,739 --> 01:10:21,250
确实混合了两者，我们把它

1804
01:10:21,250 --> 01:10:22,719
扔掉了 并重新开始，因为这是一个坏

1805
01:10:22,719 --> 01:10:23,889
主意，它的工程

1806
01:10:23,889 --> 01:10:26,080
开销太大，有一些数据库系统

1807
01:10:26,080 --> 01:10:28,300
会给你两者，它们会像

1808
01:10:28,300 --> 01:10:30,070
一些 M 续集一样公开，例如你可以说

1809
01:10:30,070 --> 01:10:31,389
在其中创建这个表，这是一个烤肉

1810
01:10:31,389 --> 01:10:32,860
或者在它的列存储上创建另一个表

1811
01:10:32,860 --> 01:10:35,440
，它们本质上有

1812
01:10:35,440 --> 01:10:36,790
两个独立的存储管理器和两个

1813
01:10:36,790 --> 01:10:38,679
独立的执行引擎来操作

1814
01:10:38,679 --> 01:10:42,429
它们，所以这些被称为混合

1815
01:10:42,429 --> 01:10:45,280
存储系统混合数据系统我们

1816
01:10:45,280 --> 01:10:46,690
都在我认为这是一个好

1817
01:10:46,690 --> 01:10:51,280
主意我 认为这是一个坏主意，现在我对于 n

1818
01:10:51,280 --> 01:10:53,409
内存我们实际上可以做到我们认为我们

1819
01:10:53,409 --> 01:10:55,150
可以在磁盘的列存储上进行足够快的事务

1820
01:10:55,150 --> 01:10:57,219
它有点

1821
01:10:57,219 --> 01:11:00,639
复杂所以有些系统可以

1822
01:11:00,639 --> 01:11:05,199
同时执行它们并不是他们并没有真正采取

1823
01:11:05,199 --> 01:11:07,239
关闭尽可能多，所以通常

1824
01:11:07,239 --> 01:11:09,639
你会看到类似的东西，你可以有一个

1825
01:11:09,639 --> 01:11:12,969
界面，他们让你写一个

1826
01:11:12,969 --> 01:11:14,500
查询，然后在它下面覆盖它

1827
01:11:14,500 --> 01:11:15,760
找出你想要去的行

1828
01:11:15,760 --> 01:11:17,590
存储 comscore 有一些方法可以做到

1829
01:11:17,590 --> 01:11:21,070
这一点，但是 拥有一个

1830
01:11:21,070 --> 01:11:22,150
用于架构的单个单元，可以同时管理

1831
01:11:22,150 --> 01:11:27,850
两者 我认为这很粗糙 他说为什么

1832
01:11:27,850 --> 01:11:28,840
我们不存储相同数据的两个副本

1833
01:11:28,840 --> 01:11:29,260


1834
01:11:29,260 --> 01:11:30,699
很好 想想它极端 我的数据库

1835
01:11:30,699 --> 01:11:36,520
是 1 PB 这么好 我滑 准备好了，

1836
01:11:36,520 --> 01:11:40,570
但我很容易找到，但我可以

1837
01:11:40,570 --> 01:11:42,010
涵盖下一节课，但基本上

1838
01:11:42,010 --> 01:11:44,199
人们所做的是你有你的

1839
01:11:44,199 --> 01:11:47,020
前端 OTP 系统，它正在运行我的

1840
01:11:47,020 --> 01:11:48,820
续集 Mongo 或任何你想要的，

1841
01:11:48,820 --> 01:11:51,880
然后你随着时间的推移将数据流式传输

1842
01:11:51,880 --> 01:11:53,920
到 后端数据仓库然后

1843
01:11:53,920 --> 01:11:56,320
你基本上可以在你不知道你不再需要它的时候修剪掉

1844
01:11:56,320 --> 01:11:58,119
HP端的旧数据或旧数据的最新数据

1845
01:11:58,119 --> 01:12:00,070


1846
01:12:00,070 --> 01:12:02,409
，所以你看到这个就像

1847
01:12:02,409 --> 01:12:05,650
eBay eBay只保留了

1848
01:12:05,650 --> 01:12:08,260
拍卖的最后 90 天，然后他们将其打印

1849
01:12:08,260 --> 01:12:09,760
出来，那是因为他们希望

1850
01:12:09,760 --> 01:12:12,070
保持 OTP 方面的美观、修剪和快速，

1851
01:12:12,070 --> 01:12:13,329
但随后他们仍将

1852
01:12:13,329 --> 01:12:14,650
其他所有内容保留在后端数据仓库中，

1853
01:12:14,650 --> 01:12:15,940
他们是否会进行所有分析以

1854
01:12:15,940 --> 01:12:17,050
找出人们 正在购买

1855
01:12:17,050 --> 01:12:19,000
他们正在做的事情 这是

1856
01:12:19,000 --> 01:12:21,550
标准设置 每个人都做对了

1857
01:12:21,550 --> 01:12:23,530
无论这是否像 montant 你

1858
01:12:23,530 --> 01:12:25,869
知道我的 Segal plus plus 垂直像

1859
01:12:25,869 --> 01:12:27,550
两个独立的数据库安装

1860
01:12:27,550 --> 01:12:29,260
还是单个混合数据库

1861
01:12:29,260 --> 01:12:31,480
像拼接机可以做到这一点，或者 mem

1862
01:12:31,480 --> 01:12:35,320
Siegel 可以做到这一点取决于你

1863
01:12:35,320 --> 01:12:36,280
想要什么你知道你有多少钱

1864
01:12:36,280 --> 01:12:39,190
你愿意做什么我认为

1865
01:12:39,190 --> 01:12:40,810
我们为我们自己的系统找到的是

1866
01:12:40,810 --> 01:12:44,739
建立一个超级单一的存储

1867
01:12:44,739 --> 01:12:46,449
经理尝试处理这两件事

1868
01:12:46,449 --> 01:12:51,880
是一个坏主意，除此之外

1869
01:12:51,880 --> 01:12:54,040
，上次有人提出测试，

1870
01:12:54,040 --> 01:12:55,420
我真的很想花时间

1871
01:12:55,420 --> 01:12:57,670
谈论这个，但我今天没有时间

1872
01:12:57,670 --> 01:12:59,710
，但下节课我们将再次开始

1873
01:12:59,710 --> 01:13:00,670
谈论缓冲池，希望

1874
01:13:00,670 --> 01:13:01,780
我们在最后讨论一下测试，

1875
01:13:01,780 --> 01:13:05,980
好吧，其他问题也很好，

1876
01:13:05,980 --> 01:13:06,219


1877
01:13:06,219 --> 01:13:12,190
很酷的米歇尔混合着破碎的

1878
01:13:12,190 --> 01:13:14,139
瓶子和压碎的孩子让奶牛

1879
01:13:14,139 --> 01:13:16,099
在

1880
01:13:16,099 --> 01:13:19,019
他机智的夜晚在我的系统中

1881
01:13:19,019 --> 01:13:19,889
堆积如山 我很幸运

1882
01:13:19,889 --> 01:13:21,419
让我们去拿下一个然后随着

1883
01:13:21,419 --> 01:13:27,630
时间的推移我会打扮好网

1884
01:13:27,630 --> 01:13:29,909
将儿子弹跳果冻击中熟食店照片

1885
01:13:29,909 --> 01:13:32,010
放一张自然祝福你我的说唱

1886
01:13:32,010 --> 01:13:33,479
就像激光束丛林中的傻瓜

1887
01:13:33,479 --> 01:13:35,969
什么也不说 就像一只鸡包裹着

1888
01:13:35,969 --> 01:13:38,280
我们一瓶不错的蒂芙尼去你

1889
01:13:38,280 --> 01:13:40,349
不想喝它只是为了你说话

1890
01:13:40,349 --> 01:13:42,719
你不能尝试使用生活如果

1891
01:13:42,719 --> 01:13:46,189
不知道你的手机可以点击

