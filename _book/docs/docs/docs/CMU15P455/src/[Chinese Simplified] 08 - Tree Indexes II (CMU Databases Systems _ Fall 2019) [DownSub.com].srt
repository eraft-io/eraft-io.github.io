1
00:00:03,640 --> 00:00:17,790
[音乐]

2
00:00:17,790 --> 00:00:19,740
倾斜我喜欢它

3
00:00:19,740 --> 00:00:24,820
好吧让我们开始吧好吧让我们

4
00:00:24,820 --> 00:00:26,349
谈谈让我们再次进入它

5
00:00:26,349 --> 00:00:26,860


6
00:00:26,860 --> 00:00:28,869
感谢DG掉落表按住

7
00:00:28,869 --> 00:00:37,059
它太棒了佩吉你还好吗

8
00:00:37,059 --> 00:00:38,110
你仍然有警察问题或

9
00:00:38,110 --> 00:00:42,040
你需要的一切 镇上一位优秀的

10
00:00:42,040 --> 00:00:46,270
律师，因为我有一口井

11
00:00:46,270 --> 00:00:47,710
我的 pc 学生在腿上遇到了麻烦，无论是小腿，

12
00:00:47,710 --> 00:00:50,290
所以我们有人

13
00:00:50,290 --> 00:00:53,770
可以帮助你 好吧 从来没有

14
00:00:53,770 --> 00:00:56,590
好吧

15
00:00:56,590 --> 00:01:00,910


16
00:01:00,910 --> 00:01:03,839
今天的谈话于 5 月 4 日下午 4:30 进行

17
00:01:03,839 --> 00:01:06,820
所以这

18
00:01:06,820 --> 00:01:08,950
是来自 Vertica 的一位首席工程师来做一个垂直的演讲

19
00:01:08,950 --> 00:01:10,450
我相信它在匹兹堡没有一个小的

20
00:01:10,450 --> 00:01:12,579
开发分支

21
00:01:12,579 --> 00:01:14,499
所以史蒂夫会来

22
00:01:14,499 --> 00:01:15,340
谈论他们

23
00:01:15,340 --> 00:01:18,340
一直在工作的一些事情 在 Vertica 上，是一个基于磁盘的

24
00:01:18,340 --> 00:01:20,530
分布式列存储数据库，您

25
00:01:20,530 --> 00:01:21,670


26
00:01:21,670 --> 00:01:22,630
在整个学期都遇到了一堆词，

27
00:01:22,630 --> 00:01:24,999
但这意味着它运行多个节点，它是

28
00:01:24,999 --> 00:01:27,219
一个列存储，并且一旦

29
00:01:27,219 --> 00:01:28,600
数据库的主要搜索位置

30
00:01:28,600 --> 00:01:30,759
打开 磁盘，所以这是其中之一，

31
00:01:30,759 --> 00:01:32,889
它不是

32
00:01:32,889 --> 00:01:34,420
2000 年代中期出现的第一批列存储

33
00:01:34,420 --> 00:01:38,020
之一，它开始了

34
00:01:38,020 --> 00:01:40,240
列存储死业务的浪潮，因此 comstor

35
00:01:40,240 --> 00:01:41,880
数据库现在并不是那么罕见，

36
00:01:41,880 --> 00:01:44,139
但又回来了 回到伯杰在 2006 年问世的时候，

37
00:01:44,139 --> 00:01:47,770
那被认为

38
00:01:47,770 --> 00:01:48,819
是一种重大技术而非

39
00:01:48,819 --> 00:01:51,909
技术突破，所以斯蒂芬斯的

40
00:01:51,909 --> 00:01:54,609
好人，如果你想

41
00:01:54,609 --> 00:01:55,420
谈论他们正在做的事情，以及他们正在

42
00:01:55,420 --> 00:01:56,829
做的事情，“ 将是水果，

43
00:01:56,829 --> 00:01:58,029
它们不是披萨

44
00:01:58,029 --> 00:02:01,179
所以再次相应地计划好 所以

45
00:02:01,179 --> 00:02:04,119
今天我们想继续

46
00:02:04,119 --> 00:02:06,700
讨论树索引 所以我想

47
00:02:06,700 --> 00:02:07,630
在开始时花一点时间

48
00:02:07,630 --> 00:02:09,910
做一些演示并

49
00:02:09,910 --> 00:02:11,830
讨论更多关于 B 加树的信息

50
00:02:11,830 --> 00:02:14,080
完成我们上节课遗漏的事情

51
00:02:14,080 --> 00:02:15,880
，然后我们将讨论

52
00:02:15,880 --> 00:02:17,860
不同的方法 我们将讨论更多

53
00:02:17,860 --> 00:02:20,560
使用索引的方法 除了

54
00:02:20,560 --> 00:02:23,350
您知道的直接键映射到

55
00:02:23,350 --> 00:02:24,310
我们一直在讨论的数据结构之外

56
00:02:24,310 --> 00:02:26,650
然后我们将讨论

57
00:02:26,650 --> 00:02:30,040
B 加树尝试或

58
00:02:30,040 --> 00:02:32,350
基数树的替代方案 我们将讨论是

59
00:02:32,350 --> 00:02:34,090
什么让这些独特 什么

60
00:02:34,090 --> 00:02:35,260
使它们与众不同 以及它们如何

61
00:02:35,260 --> 00:02:37,209
比 B 加树更好或更差

62
00:02:37,209 --> 00:02:39,010
然后我们 会很快

63
00:02:39,010 --> 00:02:42,130
完成倒排索引的大脑转储

64
00:02:42,130 --> 00:02:43,810
我不会教你

65
00:02:43,810 --> 00:02:46,000
它们是如何工作的 我们在 CMU 有课程，如果

66
00:02:46,000 --> 00:02:47,620
我能做到的话，这只是为了让你

67
00:02:47,620 --> 00:02:49,480
知道这些东西确实存在所以 当

68
00:02:49,480 --> 00:02:50,740
你在现实世界中外出时 你

69
00:02:50,740 --> 00:02:52,000
意识到你想要索引的东西

70
00:02:52,000 --> 00:02:54,340
不能在 B+ 树中建立索引 你

71
00:02:54,340 --> 00:02:57,160
想使用这些倒排索引

72
00:02:57,160 --> 00:03:01,330
之一 所以最后一节课我们有

73
00:03:01,330 --> 00:03:02,709
几个关于我们如何

74
00:03:02,709 --> 00:03:04,870
实际处理重复键的问题

75
00:03:04,870 --> 00:03:07,270
在我们的 B+ 树索引中，我向您展示了

76
00:03:07,270 --> 00:03:09,190
我们如何处理节点内部的重复键，

77
00:03:09,190 --> 00:03:11,680
我们可以让我们可以

78
00:03:11,680 --> 00:03:13,209
复制节点中的值，

79
00:03:13,209 --> 00:03:15,970
然后或者只是

80
00:03:15,970 --> 00:03:18,430
在节点内部进行从键到无值的映射，所以现在我

81
00:03:18,430 --> 00:03:20,110
想谈谈我

82
00:03:20,110 --> 00:03:22,180
意识到我错过的数据

83
00:03:22,180 --> 00:03:24,580
实际上是在树本身内部的更高级别讨论

84
00:03:24,580 --> 00:03:27,040
我们如何实际维护

85
00:03:27,040 --> 00:03:28,600
这些重复索引或重复

86
00:03:28,600 --> 00:03:30,850
键所以有两种方法可以做到

87
00:03:30,850 --> 00:03:35,140
这一点所以第一个是我们

88
00:03:35,140 --> 00:03:38,410
通过

89
00:03:38,410 --> 00:03:42,070
将相应的元组

90
00:03:42,070 --> 00:03:44,200
记录 ID 附加到我们

91
00:03:44,200 --> 00:03:47,140
插入索引中的键，将自动使每个键都是唯一的，而不是

92
00:03:47,140 --> 00:03:48,459
破坏

93
00:03:48,459 --> 00:03:50,590
表中属性副本的保留，我

94
00:03:50,590 --> 00:03:52,600
也去 nnna 前缀或抱歉把

95
00:03:52,600 --> 00:03:55,510
那个元组的记录 ID 作为后缀放在最后，

96
00:03:55,510 --> 00:03:59,170
所以现在这使得每个键

97
00:03:59,170 --> 00:04:02,739
自动唯一，所以

98
00:04:02,739 --> 00:04:04,180
我们可以这样做的原因仍然有效是

99
00:04:04,180 --> 00:04:07,000
因为我们使用的是 B+ 树 memorize

100
00:04:07,000 --> 00:04:08,440
说 将是加号树，我们可以进行

101
00:04:08,440 --> 00:04:11,380
部分键查找，并且仍然可以找到

102
00:04:11,380 --> 00:04:13,209
我们想要的东西，所以如果我

103
00:04:13,209 --> 00:04:14,799
有一个属性，一个索引，一个

104
00:04:14,799 --> 00:04:16,720
属性 a 和 B，如果我想

105
00:04:16,720 --> 00:04:18,488
查看 a，我仍然可以这样做而

106
00:04:18,488 --> 00:04:21,820
无需 B 所以在我们的情况下，在 B 加

107
00:04:21,820 --> 00:04:22,960
树中，因为我们没有

108
00:04:22,960 --> 00:04:25,720
记录 ID，

109
00:04:25,720 --> 00:04:27,460
我们可以像使用键一样使用它进行常规查找，

110
00:04:27,460 --> 00:04:29,380
但我们只是沿着叶节点扫描

111
00:04:29,380 --> 00:04:31,870
我们是否找到所有匹配项 对于给定的

112
00:04:31,870 --> 00:04:33,340
键，您可以

113
00:04:33,340 --> 00:04:34,900
在哈希表中为哈希表执行此操作，

114
00:04:34,900 --> 00:04:36,190
您必须拥有整个

115
00:04:36,190 --> 00:04:39,940
键，因此为了执行此方法，

116
00:04:39,940 --> 00:04:42,250
您必须在查找

117
00:04:42,250 --> 00:04:44,020
所需的键时使用，然后记录一个

118
00:04:44,020 --> 00:04:46,840
是它们对应的记录 ID，但这

119
00:04:46,840 --> 00:04:48,130
似乎很愚蠢，因为如果您有

120
00:04:48,130 --> 00:04:49,540
记录 rd ID 为什么要使用索引

121
00:04:49,540 --> 00:04:58,060
查找记录 ID 是的 所以这些

122
00:04:58,060 --> 00:04:59,979
问题是什么这个记录 ID

123
00:04:59,979 --> 00:05:02,530
它是页面 ID 以及我们

124
00:05:02,530 --> 00:05:04,870
在开始时谈到的所有集合 现在是元组

125
00:05:04,870 --> 00:05:06,520
的每个物理位置的唯一标识符

126
00:05:06,520 --> 00:05:08,740
它可能会改变

127
00:05:08,740 --> 00:05:10,479
，因此我们必须处理它

128
00:05:10,479 --> 00:05:14,290
，而 Postgres 是最著名的

129
00:05:14,290 --> 00:05:15,700
那个，它不会起作用，因为

130
00:05:15,700 --> 00:05:18,160
它们可以移动东西，但是当

131
00:05:18,160 --> 00:05:20,139
我们谈论多版本时，我们会看到

132
00:05:20,139 --> 00:05:21,490
不同的例子来说明为什么它

133
00:05:21,490 --> 00:05:22,720
起作用 发布但它不起作用

134
00:05:22,720 --> 00:05:24,400
用弧或其他系统替换图形

135
00:05:24,400 --> 00:05:25,960
但这假设它是第 18 页的偏移量或

136
00:05:25,960 --> 00:05:27,520
指示续集服务器 Oracle

137
00:05:27,520 --> 00:05:29,320
它就像文件号对象编号的

138
00:05:29,320 --> 00:05:30,820
页面 ID 并且所有设置都像另一种方法一样更复杂

139
00:05:30,820 --> 00:05:35,320


140
00:05:35,320 --> 00:05:39,280
如果您愿意

141
00:05:39,280 --> 00:05:42,780
B+ 树的设计并且实际上

142
00:05:42,780 --> 00:05:45,550
将重复的键存储为溢出叶

143
00:05:45,550 --> 00:05:48,280
节点，而不是水平扩展叶

144
00:05:48,280 --> 00:05:50,380
节点以适应我们的新

145
00:05:50,380 --> 00:05:52,360
条目，那么这在某种程度上违反了神圣性 我实际上会垂直禁止它们，

146
00:05:52,360 --> 00:05:54,310
否则给定的

147
00:05:54,310 --> 00:05:56,050
叶子节点会添加这些溢出页面，

148
00:05:56,050 --> 00:05:57,789
就像我们之前讨论的链哈希表一样，

149
00:05:57,789 --> 00:05:59,380
并添加

150
00:05:59,380 --> 00:06:02,349
他在那里的所有trippity，以便

151
00:06:02,349 --> 00:06:04,000
稍后我会再次看到 提供过度使用

152
00:06:04,000 --> 00:06:04,780
这看起来像

153
00:06:04,780 --> 00:06:07,090
这种方法会更复杂，

154
00:06:07,090 --> 00:06:09,970
因为现在我们必须处理

155
00:06:09,970 --> 00:06:11,080
我沿着叶节点剥皮的情况

156
00:06:11,080 --> 00:06:12,570
我必须知道如何跟随那些

157
00:06:12,570 --> 00:06:15,190
你知道的跟随溢出页面

158
00:06:15,190 --> 00:06:17,139
如果我'  m 反向剥皮 你

159
00:06:17,139 --> 00:06:19,419
知道当我跳回另一个方向时我从哪里开始扫描

160
00:06:19,419 --> 00:06:20,620


161
00:06:20,620 --> 00:06:25,270
所以大多数人都实现了这个 这样

162
00:06:25,270 --> 00:06:26,500
做的好处是我们

163
00:06:26,500 --> 00:06:28,030
不想对我们的数据结构进行任何重大更改，

164
00:06:28,030 --> 00:06:29,440
无论它是一个 唯一

165
00:06:29,440 --> 00:06:31,450
索引与非唯一索引 一切

166
00:06:31,450 --> 00:06:32,410
仍然

167
00:06:32,410 --> 00:06:34,210
一样 缺点是现在我们实际上

168
00:06:34,210 --> 00:06:35,590
将记录 ID 存储

169
00:06:35,590 --> 00:06:37,570
为我们键的附加键元素，

170
00:06:37,570 --> 00:06:40,270
这增加了我们索引的大小，

171
00:06:40,270 --> 00:06:42,310
您知道 o

172
00:06:42,310 --> 00:06:43,870
在这种情况下实际存储索引所需的数据

173
00:06:43,870 --> 00:06:45,640
我们不会在早期存储任何

174
00:06:45,640 --> 00:06:47,110
不必要的冗余信息

175
00:06:47,110 --> 00:06:49,960
来使事情变得独特但现在我们

176
00:06:49,960 --> 00:06:52,480
遇到了这个管理问题所以让我们来看看

177
00:06:52,480 --> 00:06:54,870
它们所以这是我们讨论过的简单

178
00:06:54,870 --> 00:06:56,950
B+ 树 大约在之前，

179
00:06:56,950 --> 00:06:59,410
所以第一种方法再次

180
00:06:59,410 --> 00:07:01,330
取决于记录 ID，所以要么我

181
00:07:01,330 --> 00:07:02,800
像键值一样显示，假设有一个

182
00:07:02,800 --> 00:07:04,540
辅助 a，这里是它们的所有值

183
00:07:04,540 --> 00:07:04,870


184
00:07:04,870 --> 00:07:06,910
，实际上数据库系统

185
00:07:06,910 --> 00:07:09,610
实际存储的是

186
00:07:09,610 --> 00:07:14,290
键，然后是那个记录 ID，所以现在当

187
00:07:14,290 --> 00:07:15,880
我进行查找并说我想证明

188
00:07:15,880 --> 00:07:18,820
密钥 6 时，我会在这里我可以

189
00:07:18,820 --> 00:07:22,060
在我的 B+ 树中进行前缀搜索，

190
00:07:22,060 --> 00:07:24,160
因为我没有记录 ID 作为 我正在

191
00:07:24,160 --> 00:07:25,600
插入这个为什么我要收回它

192
00:07:25,600 --> 00:07:27,220
你确实有一个记录 ID 但我

193
00:07:27,220 --> 00:07:29,290
不会找到一个完全匹配的所以我

194
00:07:29,290 --> 00:07:30,790
会在这里遍历我会

195
00:07:30,790 --> 00:07:33,760
在这个页面上真正的我的意思是我的意思

196
00:07:33,760 --> 00:07:35,830
我开始是第 18 页的翻页，

197
00:07:35,830 --> 00:07:36,940
但我让她失望了

198
00:07:36,940 --> 00:07:39,430
e 现在我知道我想进入这个

199
00:07:39,430 --> 00:07:43,360
页面，所以因为现在我没有

200
00:07:43,360 --> 00:07:45,460
溢出页面我必须完全

201
00:07:45,460 --> 00:07:46,780
按照排序顺序所以假设这个

202
00:07:46,780 --> 00:07:49,510
原始的六个是它的记录 ID

203
00:07:49,510 --> 00:07:51,400
小于我插入的那个 它

204
00:07:51,400 --> 00:07:53,140
需要在 6 和 7 之间移动，所以我

205
00:07:53,140 --> 00:07:54,880
只是执行我们

206
00:07:54,880 --> 00:07:56,590
在将每个人

207
00:07:56,590 --> 00:07:58,870
滑过 7 和 8 之前讨论过的正常拆分过程，现在

208
00:07:58,870 --> 00:08:01,450
我可以更新指针，然后房子 6

209
00:08:01,450 --> 00:08:04,150
进入这里，它只是正常

210
00:08:04,150 --> 00:08:05,500
工作 和我们之前讨论过的一样，

211
00:08:05,500 --> 00:08:07,690
所以我要再次单独查找

212
00:08:07,690 --> 00:08:09,690
6 我只进行前缀搜索

213
00:08:09,690 --> 00:08:12,310
我只查看键的第一个

214
00:08:12,310 --> 00:08:14,290
元素 只是 6 我现在可以在

215
00:08:14,290 --> 00:08:15,970
这里找到我沿着我的 叶鼻子我

216
00:08:15,970 --> 00:08:20,590
找到了他们我想要的另一种方法

217
00:08:20,590 --> 00:08:23,350
是溢出页面所以现在我

218
00:08:23,350 --> 00:08:25,330
想再次开始六个我知道我想

219
00:08:25,330 --> 00:08:27,310
进入这个人我不能我不想

220
00:08:27,310 --> 00:08:29,800
分开我想要

221
00:08:29,800 --> 00:08:30,880
在我有七八步之前我不会做我所做

222
00:08:30,880 --> 00:08:32,950
的我想进入这个页面这里

223
00:08:32,950 --> 00:08:35,830
但我不能，因为它已满，所以我

224
00:08:35,830 --> 00:08:38,320
现在只添加一个溢出页面，在其中插入

225
00:08:38,320 --> 00:08:41,020
我的新六个，现在我将

226
00:08:41,020 --> 00:08:43,809
指针指向它现在记得我之前

227
00:08:43,809 --> 00:08:46,030
说过，在大多数

228
00:08:46,030 --> 00:08:49,600
B+ 树的教科书定义中，你假设

229
00:08:49,600 --> 00:08:51,190
在这种情况下，键总是会

230
00:08:51,190 --> 00:08:53,350
在节点内排序，在这里我们

231
00:08:53,350 --> 00:08:56,280
可以这样做，我们可以对它们进行排序，但

232
00:08:56,280 --> 00:08:58,780
实际上并没有错，只是让它不

233
00:08:58,780 --> 00:09:01,000
排序我们只需要知道单词何时

234
00:09:01,000 --> 00:09:01,840
寻找我们正在寻找的元素

235
00:09:01,840 --> 00:09:03,250
不能使用二分搜索来

236
00:09:03,250 --> 00:09:04,960
跳转我们必须做线性搜索

237
00:09:04,960 --> 00:09:07,870
来找到我们想要的所以现在假设我

238
00:09:07,870 --> 00:09:09,760
想搜索七个相同的东西七个

239
00:09:09,760 --> 00:09:10,540
在那里

240
00:09:10,540 --> 00:09:12,670
我插入六个相同的东西六个去这里

241
00:09:12,670 --> 00:09:14,310
它是按顺序的就是这样

242
00:09:14,310 --> 00:09:16,540
好的，现在这是需要发生的事情

243
00:09:16,540 --> 00:09:18,220


244
00:09:18,220 --> 00:09:20,590
所以从索引的

245
00:09:20,590 --> 00:09:22,690
角度来看，这在物理上存储在多个页面上，这看起来就像一个

246
00:09:22,690 --> 00:09:24,510
巨大的叶子笔记，里面有月份，

247
00:09:24,510 --> 00:09:27,370
所以现在如果我正在扫描，我会做

248
00:09:27,370 --> 00:09:28,840
同样的事情我遵循 这个指针我着陆

249
00:09:28,840 --> 00:09:30,370
h 现在，如果我正在扫描

250
00:09:30,370 --> 00:09:32,050
而不是跳转到这个节点，我

251
00:09:32,050 --> 00:09:33,760
不需要跟随我的溢出页面，你会

252
00:09:33,760 --> 00:09:35,770
一直在那里寻找，最终如果我

253
00:09:35,770 --> 00:09:37,090
找到了我要找的东西，我就完成了，如果

254
00:09:37,090 --> 00:09:38,800
没有，我需要去 下一页然后我

255
00:09:38,800 --> 00:09:41,560
只是按照那个指针在那里所以

256
00:09:41,560 --> 00:09:42,790
现在我可能在想为什么不让

257
00:09:42,790 --> 00:09:44,560
这个人应该'这个人真的

258
00:09:44,560 --> 00:09:46,750
指向那个人因为

259
00:09:46,750 --> 00:09:48,700
那实际上是正确的但现在

260
00:09:48,700 --> 00:09:50,140
问题是每次我添加 一个新的

261
00:09:50,140 --> 00:09:52,060
溢出页面现在我只需要

262
00:09:52,060 --> 00:09:54,310
更新你知道我的内部指针

263
00:09:54,310 --> 00:09:56,290
对于这两个注意这里的这些节点

264
00:09:56,290 --> 00:09:58,350
我现在也需要更新这个

265
00:09:58,350 --> 00:10:00,670
但是如果我只留下那个指针

266
00:10:00,670 --> 00:10:02,500
并让它指向的开始 我的

267
00:10:02,500 --> 00:10:04,930
页面是这个垂直塔中最顶层的叶节点

268
00:10:04,930 --> 00:10:07,450
然后我会降落

269
00:10:07,450 --> 00:10:08,860
在那里然后说哦，好吧我正在

270
00:10:08,860 --> 00:10:10,300
搜索我真的需要跳到

271
00:10:10,300 --> 00:10:12,750
我的溢出页面的末尾并向后工作

272
00:10:12,750 --> 00:10:15,460
有很多额外的逻辑我们必须

273
00:10:15,460 --> 00:10:17,790
做 适应这个是的

274
00:10:17,790 --> 00:10:21,370
所以我说对不起你哈 没有审查过

275
00:10:21,370 --> 00:10:41,470
什么抱歉哦，每个疑问都可以，所以这个

276
00:10:41,470 --> 00:10:44,380
问题是，如果有人

277
00:10:44,380 --> 00:10:46,870
使用索引的数据系统，我们正在

278
00:10:46,870 --> 00:10:48,850
尝试找到具有

279
00:10:48,850 --> 00:10:51,970
该特定键值为 6 的元组，那么

280
00:10:51,970 --> 00:10:54,520
如果我们返回良好的索引是什么？ 转动

281
00:10:54,520 --> 00:10:57,670
记录 ID，所以你会说你

282
00:10:57,670 --> 00:10:59,530
基本上有一个迭代器，我

283
00:10:59,530 --> 00:11:01,000
向下遍历并到达我的叶节点，现在我正在

284
00:11:01,000 --> 00:11:02,140
寻找这个

285
00:11:02,140 --> 00:11:03,580
迭代器的 next next next 并且我正在查看每个

286
00:11:03,580 --> 00:11:05,140
元素，直到我找到那些 我

287
00:11:05,140 --> 00:11:06,850
想要，我的新迭代器知道停止

288
00:11:06,850 --> 00:11:08,440
说我正在寻找

289
00:11:08,440 --> 00:11:11,320
所有键等于 6 的所有内容，所以当我

290
00:11:11,320 --> 00:11:12,850
在这里看到可能是 9 时，我需要

291
00:11:12,850 --> 00:11:14,010
停止，

292
00:11:14,010 --> 00:11:15,870
但如果您知道

293
00:11:15,870 --> 00:11:17,910
这是否未排序，我就说这句话 然后我知道我需要

294
00:11:17,910 --> 00:11:19,680
扫描到所有溢出页面的末尾，

295
00:11:19,680 --> 00:11:21,570
因为如果最后六个可能在

296
00:11:21,570 --> 00:11:24,810
这里如果我想让它们排序那么

297
00:11:24,810 --> 00:11:26,760
你现在知道我确定这六个在这里

298
00:11:26,760 --> 00:11:28,890
现在我要去更新这个 家伙和这个

299
00:11:28,890 --> 00:11:30,900
家伙，而之前如果我消失，

300
00:11:30,900 --> 00:11:35,550
它只会更新一页 所以这是一个

301
00:11:35,550 --> 00:11:39,570
很好的例子，说明为什么你知道为什么

302
00:11:39,570 --> 00:11:40,830


303
00:11:40,830 --> 00:11:42,480
在真正的完整系统的上下文中尝试理解这些数据结构

304
00:11:42,480 --> 00:11:44,160
很重要你参加

305
00:11:44,160 --> 00:11:45,360
算法课程，算法课程

306
00:11:45,360 --> 00:11:46,650
会教你是的，这是

307
00:11:46,650 --> 00:11:49,170
开始 B+ 树的方式，但是 现在因为我们

308
00:11:49,170 --> 00:11:50,940
在一个数据库系统中，我们知道我们

309
00:11:50,940 --> 00:11:52,410
有这些叫做记录 ID 的东西，

310
00:11:52,410 --> 00:11:54,780
我们可以利用它们来

311
00:11:54,780 --> 00:11:56,190
促进不同的方面或

312
00:11:56,190 --> 00:11:57,450
不同的操作，如果这个东西溢出，我们就不会那么

313
00:11:57,450 --> 00:12:03,860
容易做是正确的

314
00:12:03,860 --> 00:12:05,910


315
00:12:05,910 --> 00:12:10,860
继续是正确的我认为它

316
00:12:10,860 --> 00:12:12,090
说到了某个点你实际上想要

317
00:12:12,090 --> 00:12:15,330
重新平衡所以是的所以这可能是一个

318
00:12:15,330 --> 00:12:16,890
标准它说得很好如果我

319
00:12:16,890 --> 00:12:18,360
超过这个溢出页面的数量

320
00:12:18,360 --> 00:12:20,610
然后进行拆分但如果这些都是

321
00:12:20,610 --> 00:12:23,280
正确的 单页然后你

322
00:12:23,280 --> 00:12:24,720
不能你不能很容易

323
00:12:24,720 --> 00:12:31,140
做到不依赖于记录 ID

324
00:12:31,140 --> 00:12:33,840
很好很酷所以让我们做一个演示因为我们

325
00:12:33,840 --> 00:12:35,610
上次没有这样做所以我们

326
00:12:35,610 --> 00:12:38,250
要做 Postgres 和 th  ese 想要显示

327
00:12:38,250 --> 00:12:41,640
B+ 树和哈希索引之间的区别

328
00:12:41,640 --> 00:12:51,480
好吧 把它关掉

329
00:12:51,480 --> 00:12:53,180
好吧 很酷 你在这里登录

330
00:12:53,180 --> 00:12:57,810
所以我会有一张现场直播 是的

331
00:12:57,810 --> 00:12:59,910
好的 所以这是休息后我会 有

332
00:12:59,910 --> 00:13:03,540
一个电子邮件地址表，所以它会

333
00:13:03,540 --> 00:13:07,110
是一个简单的表，

334
00:13:07,110 --> 00:13:08,880
带有一个带有自动递增键的 ID，然后是

335
00:13:08,880 --> 00:13:10,740
一堆电子邮件地址 所以这是一个

336
00:13:10,740 --> 00:13:14,070
您可以在 Internet 上找到的文件

337
00:13:14,070 --> 00:13:16,680
这是一个包含 2700 万封电子邮件的列表

338
00:13:16,680 --> 00:13:19,290
来自如果你不知道那是什么的地址 在

339
00:13:19,290 --> 00:13:23,610


340
00:13:23,610 --> 00:13:25,410
tinder 之前想到它是加拿大的一个成人联播

341
00:13:25,410 --> 00:13:27,360
网站，他们被黑了

342
00:13:27,360 --> 00:13:29,360
，然后最终人们发布了

343
00:13:29,360 --> 00:13:33,180
电子邮件地址，所以这是真实的，它

344
00:13:33,180 --> 00:13:35,250
不应该 需要那么长时间来加载但我

345
00:13:35,250 --> 00:13:36,630
现在应该这样做但是

346
00:13:36,630 --> 00:13:39,209
没关系所以我们要做的是我们

347
00:13:39,209 --> 00:13:40,589
要创建两个索引我们要

348
00:13:40,589 --> 00:13:42,839
创建一个哈希索引所以在Postgres中你

349
00:13:42,839 --> 00:13:44,100
实际上可以说我想要

350
00:13:44,100 --> 00:13:45,839
创建索引我希望它是一个哈希

351
00:13:45,839 --> 00:13:49,320
索引然后你可以说我想要

352
00:13:49,320 --> 00:13:50,850
o 创建索引，我当然希望成为 B+

353
00:13:50,850 --> 00:13:52,890
树索引

354
00:13:52,890 --> 00:13:55,250


355
00:13:55,250 --> 00:13:58,140


356
00:13:58,140 --> 00:14:03,149


357
00:14:03,149 --> 00:14:04,760


358
00:14:04,760 --> 00:14:10,760
秘书从电子邮件中选择计数明星

359
00:14:14,930 --> 00:14:18,360
好吧 Postgres 完成了实际上让我们

360
00:14:18,360 --> 00:14:19,649
回到新闻发布 因为它已经完成

361
00:14:19,649 --> 00:14:22,290
我花了一分钟 所以我告诉你我插入了

362
00:14:22,290 --> 00:14:25,680
27 个电子邮件地址 所以我首先

363
00:14:25,680 --> 00:14:28,170
要做的是我要创建一个哈希索引

364
00:14:28,170 --> 00:14:30,630
默认情况下，在续集和大多数

365
00:14:30,630 --> 00:14:32,970
系统中，如果你只创建一个索引，

366
00:14:32,970 --> 00:14:35,279
你就会得到一个你知道的 B+ 树或

367
00:14:35,279 --> 00:14:37,230
Postgres 中的一些树数据结构我

368
00:14:37,230 --> 00:14:39,149
可以说使用哈希我强迫它

369
00:14:39,149 --> 00:14:42,120
使用哈希索引等等 现在我们可以看到

370
00:14:42,120 --> 00:14:43,709
当然不会加载

371
00:14:43,709 --> 00:14:45,360
这样的东西我应该警告它对不起

372
00:14:45,360 --> 00:14:50,329
这不应该花太长时间但是

373
00:14:50,329 --> 00:14:53,850
我们可以看到如果我们尝试执行某些

374
00:14:53,850 --> 00:14:56,850
查询我们将无法找到那些

375
00:14:56,850 --> 00:14:59,279
东西 我们想让我

376
00:14:59,279 --> 00:15:02,930
在抱歉的

377
00:15:03,110 --> 00:15:08,100
PG 中看看这一切，所以这是我使用的相同功能

378
00:15:08,100 --> 00:15:10,019
d 上次只是为了预热缓存

379
00:15:10,019 --> 00:15:12,839
，然后现在当我在理论上调用 create index 时，

380
00:15:12,839 --> 00:15:14,339
这应该更快，因为

381
00:15:14,339 --> 00:15:16,800
一切都刚刚加载，但我们

382
00:15:16,800 --> 00:15:18,240
将运行查询，我们将

383
00:15:18,240 --> 00:15:20,190
看到查询计划器将如何

384
00:15:20,190 --> 00:15:21,930
能够为某些查询

385
00:15:21,930 --> 00:15:23,820
选择索引，但它能够为其他查询选择索引，

386
00:15:23,820 --> 00:15:25,860
因为哈希索引

387
00:15:25,860 --> 00:15:28,769
再次你必须拥有整个

388
00:15:28,769 --> 00:15:30,630
整个键或键的塔元素，

389
00:15:30,630 --> 00:15:32,550
你不能进行部分查找，你

390
00:15:32,550 --> 00:15:38,930
可以 不进行范围扫描，嗯，抱歉，

391
00:15:40,640 --> 00:15:43,709
这很糟糕，为什么

392
00:15:43,709 --> 00:15:46,019
会这样 - 然后我将

393
00:15:46,019 --> 00:15:49,250
在后台创建 Depot Street 索引我

394
00:15:59,420 --> 00:16:01,170
让一切正常，然后我

395
00:16:01,170 --> 00:16:02,730
在上课前掉到桌子上

396
00:16:02,730 --> 00:16:04,589
，我忘了重建 好吧，

397
00:16:04,589 --> 00:16:06,420
我们回来了，所以它花了 50 秒，

398
00:16:06,420 --> 00:16:08,459
所以现在我可以说像 select star 这样的查询，

399
00:16:08,459 --> 00:16:10,620
让我们先找到一个用户，然后

400
00:16:10,620 --> 00:16:13,740
从中选择一个 star，让我们

401
00:16:13,740 --> 00:16:23,910
从电子邮件中找到最少使用的电子邮件地址是的，

402
00:16:23,910 --> 00:16:24,980
我们去

403
00:16:24,980 --> 00:16:27,390
任何人 正确

404
00:16:27,390 --> 00:16:29,100
使用假货 电子邮件地址，所以如果我想

405
00:16:29,100 --> 00:16:33,630
从电子邮件中选择明星，其中电子邮件

406
00:16:33,630 --> 00:16:38,070
再次等于这个东西，如果我添加

407
00:16:38,070 --> 00:16:40,200
解释的关键字钱包会告诉

408
00:16:40,200 --> 00:16:42,029
我它会做什么，所以 Postgres 会

409
00:16:42,029 --> 00:16:44,250
告诉我，嘿，我有一个

410
00:16:44,250 --> 00:16:47,370
叫做哈希索引的帽子 我可以做并做

411
00:16:47,370 --> 00:16:48,750
一个查找 因为我知道我可以做

412
00:16:48,750 --> 00:16:50,579
我期待的事情 邪恶的

413
00:16:50,579 --> 00:16:52,860
文本 很好地忽略位图

414
00:16:52,860 --> 00:16:54,600
扫描仪堆可以是什么 稍后会

415
00:16:54,600 --> 00:16:56,310
出现 但在但我们知道这会

416
00:16:56,310 --> 00:16:58,890
快点，它会

417
00:16:58,890 --> 00:17:00,990
准确地找到我们正在寻找的那个，但

418
00:17:00,990 --> 00:17:03,230
现在说如果我想做一些

419
00:17:03,230 --> 00:17:07,679
像电子邮件一样的东西然后这个东西并

420
00:17:07,679 --> 00:17:10,199
在最后放一个通配符你可以

421
00:17:10,199 --> 00:17:13,770
使用这个 哈希索引不正确，因为您

422
00:17:13,770 --> 00:17:15,480
必须拥有整个密钥我

423
00:17:15,480 --> 00:17:16,740
不会运行它因为我可能会花

424
00:17:16,740 --> 00:17:20,040
所有时间但是但是当您询问解释时您可以告诉您

425
00:17:20,040 --> 00:17:22,049
它告诉您它

426
00:17:22,049 --> 00:17:23,579
默认为顺序扫描

427
00:17:23,579 --> 00:17:24,660
问题顺序扫描 始终是 th 的

428
00:17:24,660 --> 00:17:26,459
默认操作或访问方法

429
00:17:26,459 --> 00:17:28,260
数据库系统 他们无法

430
00:17:28,260 --> 00:17:30,270
使用索引找到它想要的东西 它总是默认

431
00:17:30,270 --> 00:17:33,270
为中央扫描 所以在这个过程

432
00:17:33,270 --> 00:17:39,360
中让我们建立树索引 但

433
00:17:39,360 --> 00:17:40,440
我们可以看到一些其他的东西

434
00:17:40,440 --> 00:17:42,270
所以假设我们想找到我们 想要

435
00:17:42,270 --> 00:17:45,960
计算所有电子邮件地址，其中

436
00:17:45,960 --> 00:17:49,710
比这个权利更好的

437
00:17:49,710 --> 00:17:52,770
我可以再做一次吗，因为我们

438
00:17:52,770 --> 00:17:54,150
必须拥有部分密钥，我们不能做

439
00:17:54,150 --> 00:17:55,410
任何不在质量谓词中的事情，

440
00:17:55,410 --> 00:17:57,570
它总是必须完全

441
00:17:57,570 --> 00:18:01,650
匹配所有 是的，它可以做一些事情，

442
00:18:01,650 --> 00:18:04,280
虽然是对的，所以假设我们发现

443
00:18:04,280 --> 00:18:06,960
有人说其他人也做过这

444
00:18:06,960 --> 00:18:08,730
件事，是不是因为我

445
00:18:08,730 --> 00:18:10,500
没有发现

446
00:18:10,500 --> 00:18:12,630
对于特殊扫描来说非常快的实际情况，不要等待抱歉

447
00:18:12,630 --> 00:18:14,730
，这是一个 index in 让我们再找

448
00:18:14,730 --> 00:18:16,200
一个 让我们再找一个 让我们

449
00:18:16,200 --> 00:18:18,840
找到那些

450
00:18:18,840 --> 00:18:24,300
以 a 开头的人，就像星星一样，

451
00:18:24,300 --> 00:18:25,770
然后我们将限制一个

452
00:18:25,770 --> 00:18:28,260


453
00:18:28,260 --> 00:18:33,930
所以有

454
00:18:33,930 --> 00:18:35,760
一些 ebody 的电子邮件地址让那些书，

455
00:18:35,760 --> 00:18:38,820
但没关系，但如果我们可以做其他

456
00:18:38,820 --> 00:18:44,610
类似的事情，或者电子邮件也可以做类似的事情

457
00:18:44,610 --> 00:18:46,460
，

458
00:18:46,460 --> 00:18:50,310
并且它实际上能够进行两次

459
00:18:50,310 --> 00:18:52,890
索引扫描，所以通知有一个 or 子句

460
00:18:52,890 --> 00:18:55,380
，你可以看到我会做一个探测 在

461
00:18:55,380 --> 00:18:57,390
索引中尝试找到我想要做的另一个

462
00:18:57,390 --> 00:18:58,770
程序索引并尝试找到我

463
00:18:58,770 --> 00:19:00,300
想要的然后将它们组合

464
00:19:00,300 --> 00:19:01,890
在一起这就是位图或

465
00:19:01,890 --> 00:19:03,690
意味着他们认为它发生在这里

466
00:19:03,690 --> 00:19:05,700
是位图索引意味着它正在

467
00:19:05,700 --> 00:19:07,950
尝试找到所有 匹配，然后

468
00:19:07,950 --> 00:19:09,900
存储记录 ID 的集合维护一个

469
00:19:09,900 --> 00:19:12,740
巨大的位图，修补程序

470
00:19:12,740 --> 00:19:15,330
存储你知道它设置该偏移量的那个位，

471
00:19:15,330 --> 00:19:17,070
表示该记录匹配

472
00:19:17,070 --> 00:19:18,810
，然后将它们组合在一起，

473
00:19:18,810 --> 00:19:21,210
然后产生输出

474
00:19:21,210 --> 00:19:22,950
为什么它必须这样做，然后

475
00:19:22,950 --> 00:19:25,350
在这里再次查找，所以现在我们的 B+

476
00:19:25,350 --> 00:19:27,750
树已经完成，所以现在我们回到我们

477
00:19:27,750 --> 00:19:38,610
原来的查询这里是的，你的陈述

478
00:19:38,610 --> 00:19:40,470
不是我说的最后一堂课，它会

479
00:19:40,470 --> 00:19:43,910
做一次搜索和 然后器官 ize

480
00:19:43,910 --> 00:19:46,020
这是一个散列索引 这是一个节拍

481
00:19:46,020 --> 00:19:47,520
这不是这是 B+

482
00:19:47,520 --> 00:19:49,140
右边是散列表 这不是 B+

483
00:19:49,140 --> 00:19:55,410
树 可以像回到现在一样好

484
00:19:55,410 --> 00:19:58,320
我刚刚添加了 B+ 树但是就

485
00:19:58,320 --> 00:19:58,740
在那里

486
00:19:58,740 --> 00:20:00,720
所以这是解释解释 正在告诉

487
00:20:00,720 --> 00:20:01,980
您查询计划将是什么，

488
00:20:01,980 --> 00:20:03,510
所以它告诉您我将

489
00:20:03,510 --> 00:20:05,820
使用 idx 电子邮件哈希进行扫描，这是

490
00:20:05,820 --> 00:20:08,270
我创建的哈希表索引的名称，

491
00:20:08,270 --> 00:20:13,800
所以现在我的帽子我的我有我的我有

492
00:20:13,800 --> 00:20:18,960
我的 B+ 树 索引所以如果我做这样的事情

493
00:20:18,960 --> 00:20:21,930
就做这个查找我们

494
00:20:21,930 --> 00:20:24,510
在这封假电子邮件之前它会告诉我

495
00:20:24,510 --> 00:20:26,190
一旦你使用哈希索引散列散列

496
00:20:26,190 --> 00:20:28,440
但是一旦我添加这个

497
00:20:28,440 --> 00:20:33,750
我在这里添加范围谓词将

498
00:20:33,750 --> 00:20:37,400
使用哈希表 不，它会使用

499
00:20:37,400 --> 00:20:39,750
一个实际进行顺序扫描的

500
00:20:39,750 --> 00:20:43,170
好例子，所以这个家伙是

501
00:20:43,170 --> 00:20:46,710
我们索引中最小的键，所以它

502
00:20:46,710 --> 00:20:48,180
知道如果我想使用索引

503
00:20:48,180 --> 00:20:49,860
，我真正要做的就是

504
00:20:49,860 --> 00:20:52,020
跳到更远的地方 左点和

505
00:20:52,020 --> 00:20:53,580
沿叶节点的扫描，

506
00:20:53,580 --> 00:20:55,290
因此遍历器 索引的萨尔是

507
00:20:55,290 --> 00:20:56,940
浪费时间空军对我来说更好

508
00:20:56,940 --> 00:20:59,040
地进行扫描扫描但是

509
00:20:59,040 --> 00:21:06,090
假设我将其更改为 Z 一堆

510
00:21:06,090 --> 00:21:09,900
Z 现在它说好的我

511
00:21:09,900 --> 00:21:11,700
知道如果我使用我的索引 我要

512
00:21:11,700 --> 00:21:13,740
扔掉很多数据，所以现在我可以

513
00:21:13,740 --> 00:21:15,480
使用它们处理的跳到

514
00:21:15,480 --> 00:21:17,100
树的右侧得到一个

515
00:21:17,100 --> 00:21:18,120
起点，然后沿着叶节点进行扫描，

516
00:21:18,120 --> 00:21:20,730
所以这是一个永恒的成本

517
00:21:20,730 --> 00:21:22,020
模型 在 Postgres 中进行，

518
00:21:22,020 --> 00:21:24,450
所以我们稍后会讨论它允许它

519
00:21:24,450 --> 00:21:26,010
决定何时是做这些事情的合适时间

520
00:21:26,010 --> 00:21:28,800
所以这很清楚

521
00:21:28,800 --> 00:21:30,690
所以对于质量谓词，哈希

522
00:21:30,690 --> 00:21:33,630
索引是我非常好的但是对于

523
00:21:33,630 --> 00:21:36,330
这些范围谓词，如果它是 再次正确的

524
00:21:36,330 --> 00:21:37,710
位置我们知道一些

525
00:21:37,710 --> 00:21:39,720
关于值的划分然后它会

526
00:21:39,720 --> 00:21:43,650
选择做一个索引叶扫描所以现在

527
00:21:43,650 --> 00:21:45,210
再次回到这里这个人正在做

528
00:21:45,210 --> 00:21:47,910
索引扫描做精确点很好的

529
00:21:47,910 --> 00:21:52,740
查找如果我删除索引删除索引

530
00:21:52,740 --> 00:21:56,370
电子邮件哈希回来 马上，

531
00:21:56,370 --> 00:21:58,530
现在我做那个谓词 n 现在它

532
00:21:58,530 --> 00:22:00,030
足够聪明知道哦，我不再拥有那个

533
00:22:00,030 --> 00:22:02,310
哈希索引，但我确实有这个

534
00:22:02,310 --> 00:22:03,960
树索引，所以我可以将它用于这个

535
00:22:03,960 --> 00:22:09,450
质量谓词，所以这很清楚，

536
00:22:09,450 --> 00:22:10,560
我们上一堂课简要讨论的另一件事

537
00:22:10,560 --> 00:22:12,390
是表

538
00:22:12,390 --> 00:22:16,650
聚类所以表聚类

539
00:22:16,650 --> 00:22:17,549
是我们将

540
00:22:17,549 --> 00:22:20,249
使用索引来强制执行

541
00:22:20,249 --> 00:22:24,509
表

542
00:22:24,509 --> 00:22:26,399
本身的排序顺序 摆出自己的姿势 Samara

543
00:22:26,399 --> 00:22:28,889
postgrass 未排序或启动的

544
00:22:28,889 --> 00:22:30,869
关系模型未排序 所以我们

545
00:22:30,869 --> 00:22:33,149
将东西插入 postgrass 它只是

546
00:22:33,149 --> 00:22:34,739
把它们和基本上

547
00:22:34,739 --> 00:22:36,330
是在我们做插入时被告知把他放进去的顺序

548
00:22:36,330 --> 00:22:38,850
，我们看到了

549
00:22:38,850 --> 00:22:39,929
一些例子，我可以更新东西

550
00:22:39,929 --> 00:22:41,309
删除东西并且可以重新洗牌，

551
00:22:41,309 --> 00:22:43,679
这取决于我如何知道你

552
00:22:43,679 --> 00:22:45,059
知道什么空闲插槽 在一个页面中可用，

553
00:22:45,059 --> 00:22:48,389
所以如果我说

554
00:22:48,389 --> 00:22:51,029
在这里做一个选择查询，从电子邮件中选择一个星，我

555
00:22:51,029 --> 00:22:53,820
只是说给我第一个，好吧，

556
00:22:53,820 --> 00:22:56,879
我们得到一些随机的 Gmail 帐户，但现在

557
00:22:56,879 --> 00:23:01,259
如果我说我是否称之为集群

558
00:23:01,259 --> 00:23:04,320
命令这将需要大约一分钟，

559
00:23:04,320 --> 00:23:06,029
但这样做的目的是该

560
00:23:06,029 --> 00:23:08,419
命令迫使 Postgres

561
00:23:08,419 --> 00:23:12,539
可能根据该索引定义的排序顺序对整个表进行重新排序，

562
00:23:12,539 --> 00:23:15,989


563
00:23:15,989 --> 00:23:18,509
但这是一次性

564
00:23:18,509 --> 00:23:21,809
操作，因此我在修改时 表

565
00:23:21,809 --> 00:23:23,519
，也许事情变得乱序了

566
00:23:23,519 --> 00:23:25,289
你不知道它不会与

567
00:23:25,289 --> 00:23:27,299
我第一次在这里设置时的情况相匹配一些

568
00:23:27,299 --> 00:23:29,519
系统，例如在我的续集和续集

569
00:23:29,519 --> 00:23:31,320
服务器和 oracle 中你可以说我想要一个

570
00:23:31,320 --> 00:23:32,879
索引聚簇表或一个可起诉的

571
00:23:32,879 --> 00:23:35,340
在索引上进行聚类，因此它

572
00:23:35,340 --> 00:23:37,440
确保无论

573
00:23:37,440 --> 00:23:39,929
您以何种顺序将值插入表中

574
00:23:39,929 --> 00:23:42,299
，底层物理

575
00:23:42,299 --> 00:23:45,450
存储都将被排序，因此在某些情况下，

576
00:23:45,450 --> 00:23:47,389
这允许我们直接对表本身进行二分搜索

577
00:23:47,389 --> 00:23:49,769
，这

578
00:23:49,769 --> 00:23:51,600
仍然是 登录而不必

579
00:23:51,600 --> 00:23:54,179
通过索引本身所以这是如果

580
00:23:54,179 --> 00:23:55,590
你花很长时间那么什么让它

581
00:23:55,590 --> 00:23:58,889
过去但我很快想

582
00:23:58,889 --> 00:24:01,320
跳回我的续集所以再次相同的电子邮件

583
00:24:01,320 --> 00:24:03,269
地址将其加载到 m  y sequel 我可以

584
00:24:03,269 --> 00:24:04,859
做同样类型的查询 select star

585
00:24:04,859 --> 00:24:11,850
from emails where

586
00:24:11,850 --> 00:24:18,210
the fake one is email equals that so the my

587
00:24:18,210 --> 00:24:22,049
sequel解释的不是那么好但

588
00:24:22,049 --> 00:24:23,999
基本上它不是一个树结构

589
00:24:23,999 --> 00:24:25,259
有点在阅读这里它说这是

590
00:24:25,259 --> 00:24:27,450
这是我可能使用的索引，所以请

591
00:24:27,450 --> 00:24:29,399
注意我有一个哈希索引，我可以使用

592
00:24:29,399 --> 00:24:30,410
它

593
00:24:30,410 --> 00:24:32,390
，然后如果我确实将它更改为

594
00:24:32,390 --> 00:24:40,310
大于这个仍然使用它，但

595
00:24:40,310 --> 00:24:43,340
它在这里说很难看到

596
00:24:43,340 --> 00:24:47,240
它很小它滚动 在这里但是

597
00:24:47,240 --> 00:24:50,090
看到这里有一列叫做 Rose

598
00:24:50,090 --> 00:24:51,770
这是我的续集告诉你有多少

599
00:24:51,770 --> 00:24:53,210
行我想我正在阅读

600
00:24:53,210 --> 00:24:54,860
所以这里有 2700 万个

601
00:24:54,860 --> 00:24:57,350
所以它可以使用这个

602
00:24:57,350 --> 00:24:59,240
哈希索引但是它会下降 返回并

603
00:24:59,240 --> 00:25:02,270
进行简单的 salento 扫描，

604
00:25:02,270 --> 00:25:04,520
而上面的扫描可以在 X 和 X 探针中进行，

605
00:25:04,520 --> 00:25:07,060
以准确找到它想要的内容

606
00:25:07,060 --> 00:25:10,520


607
00:25:10,520 --> 00:25:12,170


608
00:25:12,170 --> 00:25:14,780
我以前的第一个男人是

609
00:25:14,780 --> 00:25:16,610
对的 这是说它

610
00:25:16,610 --> 00:25:17,960
给了我你为此找到的第一个元组

611
00:25:17,960 --> 00:25:20,480
，这

612
00:25:20,480 --> 00:25:21,770
是我们之前找到的最小元组，因为这

613
00:25:21,770 --> 00:25:23,480
保证这是插入的顺序，

614
00:25:23,480 --> 00:25:25,880
所以如果我现在这样做，如果我说我

615
00:25:25,880 --> 00:25:31,700
删除该电子邮件地址 删除电子邮件

616
00:25:31,700 --> 00:25:38,750
，其中电子邮件等于这个东西，你

617
00:25:38,750 --> 00:25:40,220
去要求第一个，现在我得到一个

618
00:25:40,220 --> 00:25:42,320
不同的假电子邮件地址，但现在让

619
00:25:42,320 --> 00:25:44,270
我重新开始另一个插入

620
00:25:44,270 --> 00:25:48,350
电子邮件值默认值，因为它是一个

621
00:25:48,350 --> 00:25:50,900
自动递增键，将我的家伙插入

622
00:25:50,900 --> 00:25:56,440
正确的 仍然没有按顺序排序，

623
00:25:56,440 --> 00:26:00,310
因为它只在有任何问题时才执行该操作

624
00:26:00,310 --> 00:26:08,120
这个问题是

625
00:26:08,120 --> 00:26:10,640
强制执行排序顺序我必须

626
00:26:10,640 --> 00:26:12,710
一遍又一遍地为 Postgres 运行集群

627
00:26:12,710 --> 00:26:14,450
是的，对于其他系统，您不必

628
00:26:14,450 --> 00:26:15,860
这样做，您可以说我 想要全部

629
00:26:15,860 --> 00:26:19,120
通过索引自动聚类

630
00:26:20,320 --> 00:26:22,370
这个问题是

631
00:26:22,370 --> 00:26:24,590
在我们聚类之前是否需要对通信进行索引，所以我的

632
00:26:24,590 --> 00:26:30,340
续集它是按主键排序的，所以

633
00:26:30,340 --> 00:26:32,690
在我的续集中，叶节点实际上

634
00:26:32,690 --> 00:26:35,840
是元组本身 s 所以当

635
00:26:35,840 --> 00:26:37,550
我围绕分裂和合并

636
00:26:37,550 --> 00:26:39,080
叶节点移动时，总是按照这种

637
00:26:39,080 --> 00:26:40,490
顺序，所以如果我想对表进行顺序

638
00:26:40,490 --> 00:26:42,080
扫描，我基本上总是

639
00:26:42,080 --> 00:26:43,640
跟随叶节点，所以在其他

640
00:26:43,640 --> 00:26:44,210
系统中，如

641
00:26:44,210 --> 00:26:47,180
和续集 服务器 db2 你可以说创建

642
00:26:47,180 --> 00:26:49,010
这个表并按这些列排序

643
00:26:49,010 --> 00:26:53,200
，我会为你做这件事不抱歉

644
00:26:53,470 --> 00:27:07,820
是的这个问题是我说我们

645
00:27:07,820 --> 00:27:09,980
可以使用物理 ID 抱歉

646
00:27:09,980 --> 00:27:12,020
物理位置页面 ID 和

647
00:27:12,020 --> 00:27:13,970
插槽号作为 记录 ID 来

648
00:27:13,970 --> 00:27:16,660
确定使元组唯一，

649
00:27:16,660 --> 00:27:19,160
而不是为什么不使用

650
00:27:19,160 --> 00:27:25,340
插入元组时的时间戳，因为

651
00:27:25,340 --> 00:27:27,200
在 Postgres 中，这是我的

652
00:27:27,200 --> 00:27:29,240
续集中的一个问题，这不会是问题 有什么

653
00:27:29,240 --> 00:27:35,690
问题他说的时间戳是为了

654
00:27:35,690 --> 00:27:37,010
纪念设置 时间不会

655
00:27:37,010 --> 00:27:40,790
同步是的，更简单的

656
00:27:40,790 --> 00:27:45,250
是闰秒闰年的问题

657
00:27:45,250 --> 00:27:48,350
所以现在他们再次重复第二个现在

658
00:27:48,350 --> 00:27:48,980
会发生什么

659
00:27:48,980 --> 00:27:50,570
我插入一些东西现在他们有

660
00:27:50,570 --> 00:27:53,030
相同的时间戳或时钟可以随时钟漂移

661
00:27:53,030 --> 00:27:56,450
是ho 非常不准确，所以你

662
00:27:56,450 --> 00:27:59,060
知道我经常运行 NTP 现在它

663
00:27:59,060 --> 00:28:00,920
只是时钟缓慢但

664
00:28:00,920 --> 00:28:03,020
偶尔需要做大的大步你可能会重复

665
00:28:03,020 --> 00:28:12,380
一秒钟是的这个问题

666
00:28:12,380 --> 00:28:13,850
做记录与

667
00:28:13,850 --> 00:28:27,710
毫秒与统一之间有

668
00:28:27,710 --> 00:28:30,140
什么是 自从统一文件特别是啤酒以来的毫秒数

669
00:28:30,140 --> 00:28:32,270


670
00:28:32,270 --> 00:28:34,850
如果时钟必须

671
00:28:34,850 --> 00:28:38,210
退后，它不会帮助漂移 你重复秒 没有人

672
00:28:38,210 --> 00:28:39,650
以这种方式使用时间戳 你可以

673
00:28:39,650 --> 00:28:41,750
使用我们稍后将讨论的逻辑时间戳

674
00:28:41,750 --> 00:28:44,750
你总是想要 几乎

675
00:28:44,750 --> 00:28:47,060
从不想使用

676
00:28:47,060 --> 00:28:49,190
与其他事物结合使用的硬物理时钟

677
00:28:49,190 --> 00:28:52,549
是

678
00:28:52,549 --> 00:28:57,169
的，问题是

679
00:28:57,169 --> 00:28:59,299
，如果您已经有了索引，那么您什么时候想要使用集群索引，

680
00:28:59,299 --> 00:29:03,109


681
00:29:03,109 --> 00:29:04,700
就像我的续集一样，我应该在

682
00:29:04,700 --> 00:29:06,979
我的续集它总是一个集群慕尼黑

683
00:29:06,979 --> 00:29:08,539
当我调用创建表时它总是

684
00:29:08,539 --> 00:29:11,869
集群在某些情况

685
00:29:11,869 --> 00:29:18,559
下对于某些查询它对于某些

686
00:29:18,559 --> 00:29:20,149
查询你可以像

687
00:29:20,149 --> 00:29:21,950
alrigh一样聪明 好吧，如果我在

688
00:29:21,950 --> 00:29:23,809
我们中的一个人插入的唯一逻辑时间戳上进行聚类，

689
00:29:23,809 --> 00:29:24,979
就像应用程序告诉我

690
00:29:24,979 --> 00:29:29,450
的时间戳那样，那么现在也许我可以说

691
00:29:29,450 --> 00:29:31,249
很好地获取最后几天的数据

692
00:29:31,249 --> 00:29:33,769
并将其放在快速磁盘和

693
00:29:33,769 --> 00:29:36,079
较旧的东西上 放在较慢的磁盘上 有一些

694
00:29:36,079 --> 00:29:37,339
方法可以像磁盘分区那样

695
00:29:37,339 --> 00:29:39,889
做，数据说我们可以在

696
00:29:39,889 --> 00:30:06,529
幕后为我强制执行所有这些，所以你

697
00:30:06,529 --> 00:30:09,499
说如果我有如果我是如果我

698
00:30:09,499 --> 00:30:11,479
接下来在电子邮件中聚集在电子邮件上，

699
00:30:11,479 --> 00:30:15,619
那就是 我的主键，然后是主

700
00:30:15,619 --> 00:30:17,359
键 ID 所以如果你有一个主键，

701
00:30:17,359 --> 00:30:18,649
我们会在一秒钟内看到这个，你总是

702
00:30:18,649 --> 00:30:22,149
在那个 ID 上的那个上有一个索引

703
00:30:22,149 --> 00:30:27,349
，或者所有要剪切的属性，

704
00:30:27,349 --> 00:30:30,039
所以他们点击更新索引 猜测

705
00:30:30,039 --> 00:30:32,179
取决于你如何存储你的索引，我们

706
00:30:32,179 --> 00:30:32,839
稍后会谈到

707
00:30:32,839 --> 00:30:34,609
，如果我们得到那个叫做

708
00:30:34,609 --> 00:30:38,089
版本，那么你的指针可能

709
00:30:38,089 --> 00:30:40,190
是主键，也可能是

710
00:30:40,190 --> 00:30:42,799
记录位置记录 ID 你可以做

711
00:30:42,799 --> 00:30:43,509
不同的事情

712
00:30:43,509 --> 00:30:46,549
Postgres 确实记录 ID，所以我们必须

713
00:30:46,549 --> 00:30:47,749
一直更新我的续集

714
00:30:47,749 --> 00:30:52,219
主键没问题，所以我们实际上可以

715
00:30:52,219 --> 00:30:53,599
快速浏览和 Postgres 真正的

716
00:30:53,599 --> 00:30:58,159
内容，看看你知道

717
00:30:58,159 --> 00:30:59,799
什么，大致上树看起来像什么，

718
00:30:59,799 --> 00:31:02,419
所以这只是

719
00:31:02,419 --> 00:31:03,710
Postgres 的一个扩展，它允许你获取

720
00:31:03,710 --> 00:31:06,410
有关树中内容的信息

721
00:31:06,410 --> 00:31:08,000
是的，所以我可以说我

722
00:31:08,000 --> 00:31:09,830
在 unbe plus 树上有一个叫做你知道的索引

723
00:31:09,830 --> 00:31:11,300
，我可以说你知道给我

724
00:31:11,300 --> 00:31:12,530
关于它的信息告诉我

725
00:31:12,530 --> 00:31:14,480
它有多少层告诉我它存储了多少元素

726
00:31:14,480 --> 00:31:17,300
以及根块大小，

727
00:31:17,300 --> 00:31:18,710
然后 我们可以走得更远，我们

728
00:31:18,710 --> 00:31:21,140
实际上可以在

729
00:31:21,140 --> 00:31:25,460
此处使用此命令检查处理的内容，您

730
00:31:25,460 --> 00:31:27,290
知道实际细节并不重要，

731
00:31:27,290 --> 00:31:29,000
但有一堆十六进制的东西，

732
00:31:29,000 --> 00:31:32,600
所以这是根节点，所以我们可以

733
00:31:32,600 --> 00:31:35,030
去 现在更深入一点并向您展示您

734
00:31:35,030 --> 00:31:36,050
知道单个节点这里有一些

735
00:31:36,050 --> 00:31:38,330
关于它的信息但是我们

736
00:31:38,330 --> 00:31:41,660
都是十六进制但是我们可以解码它然后

737
00:31:41,660 --> 00:31:43,190
这里有一个知识证明

738
00:31:43,190 --> 00:31:44,990
它实际上存储了这些电子邮件所以

739
00:31:44,990 --> 00:31:46,730
这是说

740
00:31:46,730 --> 00:31:49,400
这是我的根节点或树中这个

741
00:31:49,400 --> 00:31:51,200
特定节点中偏移量 3 处的记录，这是

742
00:31:51,200 --> 00:31:53,270
您知道的页码和所有设置

743
00:31:53,270 --> 00:31:55,670
它所在的位置 这里

744
00:31:55,670 --> 00:31:57,350
是存储内容的十六进制形式，然后是

745
00:31:57,350 --> 00:32:01,160
实际的电子邮件地址

746
00:32:01,160 --> 00:32:02,930
戴维斯夫妇会把这些钥匙的旧副本

747
00:32:02,930 --> 00:32:05,450
放在里面，好吧，我们现在

748
00:32:05,450 --> 00:32:08,060
要停下来，继续堆

749
00:32:08,060 --> 00:32:10,670
其他我们想要通过的东西，

750
00:32:10,670 --> 00:32:11,690
但这只是向你表明

751
00:32:11,690 --> 00:32:13,820
，默认情况下你可以一直去

752
00:32:13,820 --> 00:32:18,380
获得一个大的集群 e 但你可以让一些

753
00:32:18,380 --> 00:32:19,820
系统告诉你我想要一个哈希索引

754
00:32:19,820 --> 00:32:20,600
，这样做有不同的权衡，

755
00:32:20,600 --> 00:32:22,090


756
00:32:22,090 --> 00:32:24,230
所以现在与他

757
00:32:24,230 --> 00:32:28,220
所说的关于你知道的主键

758
00:32:28,220 --> 00:32:30,470
和 vs. 的点有关 集群索引所以如果

759
00:32:30,470 --> 00:32:32,690
你创建一个主键，数据库

760
00:32:32,690 --> 00:32:34,670
系统会自动

761
00:32:34,670 --> 00:32:37,400
为你创建一个索引，实际上任何时候

762
00:32:37,400 --> 00:32:39,920
你声明一个完整性约束它

763
00:32:39,920 --> 00:32:41,690
都会自动为你创建一个索引

764
00:32:41,690 --> 00:32:43,010
，你认为它必须是

765
00:32:43,010 --> 00:32:44,930
因为 否则，强制执行的唯一方法

766
00:32:44,930 --> 00:32:48,320
是进行顺序扫描，所以

767
00:32:48,320 --> 00:32:50,510
在我的自动增量键中，如果我每次插入时

768
00:32:50,510 --> 00:32:53,030
都强制执行它的主键唯一

769
00:32:53,030 --> 00:32:55,070
性，

770
00:32:55,070 --> 00:32:57,230
你知道你需要炸毁我没有

771
00:32:57,230 --> 00:32:59,300
有一个索引，我必须扫描每一个

772
00:32:59,300 --> 00:33:00,800
元组，确保没有

773
00:33:00,800 --> 00:33:04,790
人有相同的键，所以

774
00:33:04,790 --> 00:33:05,870
每天再一次。你的系统将

775
00:33:05,870 --> 00:33:07,490
自动为主键和唯一

776
00:33:07,490 --> 00:33:09,740
约束执行此操作，因此基本上

777
00:33:09,740 --> 00:33:11,660
在我创建表时再次执行 如果我有

778
00:33:11,660 --> 00:33:13,730
唯一的主键，它

779
00:33:13,730 --> 00:33:15,290
与运行这些命令是一样的，我将

780
00:33:15,290 --> 00:33:17,060
创建表然后它开始并

781
00:33:17,060 --> 00:33:17,930


782
00:33:17,930 --> 00:33:21,080
为外键创建这些索引它实际上并没有这样做

783
00:33:21,080 --> 00:33:23,440
所以如果我在这里创建一个名为 bar 的新表

784
00:33:23,440 --> 00:33:26,210
并且有

785
00:33:26,210 --> 00:33:28,940
对这个值的外键引用在这里

786
00:33:28,940 --> 00:33:30,350
我曾经尝试过的每个数据库系统

787
00:33:30,350 --> 00:33:32,660
总是会抛出一个错误，因为它

788
00:33:32,660 --> 00:33:36,350
说我没有办法在没有索引的情况下强制执行

789
00:33:36,350 --> 00:33:38,420
这个参照完整性约束

790
00:33:38,420 --> 00:33:42,590
，你认为它可能是正确的

791
00:33:42,590 --> 00:33:43,910
ake all matically create one 但

792
00:33:43,910 --> 00:33:44,900
它不这样做，因为它不

793
00:33:44,900 --> 00:33:47,600
知道，因为这必须是唯一的，

794
00:33:47,600 --> 00:33:50,180
所以它实际上不会这样做，而您

795
00:33:50,180 --> 00:33:52,310
只需将其替换为

796
00:33:52,310 --> 00:33:54,650
在此处添加唯一调用，那是

797
00:33:54,650 --> 00:33:56,180
构建 自动为您创建一个索引

798
00:33:56,180 --> 00:33:58,010
，然后它可以用来强制执行此

799
00:33:58,010 --> 00:33:59,690
权利，因为基本上考虑

800
00:33:59,690 --> 00:34:00,860
外键的工作方式是，

801
00:34:00,860 --> 00:34:03,290
每次我将元组启动到 bar 时，我

802
00:34:03,290 --> 00:34:06,110
都必须拥有他的 ID，

803
00:34:06,110 --> 00:34:07,820
以便确保它与

804
00:34:07,820 --> 00:34:09,980
我的 biz 表中的一个元组 我可以在该

805
00:34:09,980 --> 00:34:13,040
索引中进行查找，看看是否存在您

806
00:34:13,040 --> 00:34:17,300
知道的父引用匹配，所以现在

807
00:34:17,300 --> 00:34:18,530
让我们讨论

808
00:34:18,530 --> 00:34:20,480
实际使用索引的不同方法，除了您知道

809
00:34:20,480 --> 00:34:22,489
复制我们今天在这里讨论的整个键之外

810
00:34:22,489 --> 00:34:26,300
所以我们

811
00:34:26,300 --> 00:34:29,960
可以做的第一件事叫做部分索引，所以当

812
00:34:29,960 --> 00:34:31,699
你通常在一个表上调用 create index 时，

813
00:34:31,699 --> 00:34:33,530
它会在整个表上进行顺序扫描

814
00:34:33,530 --> 00:34:35,239
并查看每

815
00:34:35,239 --> 00:34:39,440
一个元组，但在很多情况下对于

816
00:34:39,440 --> 00:34:40,760
很多应用程序来说 ybe 你不需要

817
00:34:40,760 --> 00:34:43,120
在整个表时有一个索引，

818
00:34:43,120 --> 00:34:45,139
相反，你总是希望几乎

819
00:34:45,139 --> 00:34:47,870
你知道数据的一些子集，所以这

820
00:34:47,870 --> 00:34:50,270
就是部分索引，你基本上

821
00:34:50,270 --> 00:34:53,030
修改了 create index 命令并

822
00:34:53,030 --> 00:34:55,580
添加了这个 where 子句 最后

823
00:34:55,580 --> 00:34:58,190
告诉你什么 - 胡说八道匹配 b2b

824
00:34:58,190 --> 00:35:01,250
以便放入这个索引所以现在

825
00:35:01,250 --> 00:35:02,510
如果我想做这样的查找

826
00:35:02,510 --> 00:35:04,700
select be from foo where a equals 1 2 3

827
00:35:04,700 --> 00:35:08,360
and C equals whoo tang 所以我已经建立了

828
00:35:08,360 --> 00:35:11,170
a 和 B 上的索引我 where 子句有

829
00:35:11,170 --> 00:35:14,060
引用 a 所以我仍然可以使用这个

830
00:35:14,060 --> 00:35:16,100
索引但我也可以看看这个

831
00:35:16,100 --> 00:35:18,320
东西说哦我们看到它是 wu-tang 但

832
00:35:18,320 --> 00:35:20,360
我知道这正是我想要的索引

833
00:35:20,360 --> 00:35:23,330
使用所以这让我可以做

834
00:35:23,330 --> 00:35:26,060
更多的索引更精简，因为我没有

835
00:35:26,060 --> 00:35:27,260
存储所有

836
00:35:27,260 --> 00:35:29,330
可能的元组的所有信息我只存储

837
00:35:29,330 --> 00:35:30,400
它匹配的任何内容

838
00:35:30,400 --> 00:35:33,069
我们关闭了所以但不知何故查询

839
00:35:33,069 --> 00:35:34,480
没有这个 e 等于 mu tang 我

840
00:35:34,480 --> 00:35:39,039
不能使用那个索引，所以

841
00:35:39,039 --> 00:35:40,569
当人们做这样的事情时这是很常见的 你

842
00:35:40,569 --> 00:35:42,010
想分开我

843
00:35:42,010 --> 00:35:44,619
对不同的日期范围有不同的索引，就像

844
00:35:44,619 --> 00:35:46,390
你每个月都知道的那样我会有它的索引所以

845
00:35:46,390 --> 00:35:47,950
我会快速查找我想要的所有订单

846
00:35:47,950 --> 00:35:49,440
，你知道那个

847
00:35:49,440 --> 00:35:51,849
月我再次尝试不 必须

848
00:35:51,849 --> 00:35:53,619
用一堆我不需要的数据来污染我的缓冲池缓存，

849
00:35:53,619 --> 00:35:55,390
因为

850
00:35:55,390 --> 00:35:57,069
现在高度

851
00:35:57,069 --> 00:35:58,960
会更低，我很快就找到

852
00:35:58,960 --> 00:36:01,680
了我正在寻找

853
00:36:01,680 --> 00:36:05,380


854
00:36:05,380 --> 00:36:07,990
的数据 我们正在

855
00:36:07,990 --> 00:36:11,770
使用 C 对 a 进行查找，我们想转 B

856
00:36:11,770 --> 00:36:13,089
结果实际上对于这个特定查询

857
00:36:13,089 --> 00:36:16,869
，我们需要的所有数据

858
00:36:16,869 --> 00:36:19,150
都在索引本身中

859
00:36:19,150 --> 00:36:20,950


860
00:36:20,950 --> 00:36:23,200
记录 ID，然后您

861
00:36:23,200 --> 00:36:25,450
可以在表堆中跟踪该 ID 并

862
00:36:25,450 --> 00:36:27,069
获取您正在查找的元组，但是

863
00:36:27,069 --> 00:36:28,930
对于这里的这个特定查询，我们

864
00:36:28,930 --> 00:36:30,309
实际上甚至不需要查看

865
00:36:30,309 --> 00:36:33,190
元组，因为我们需要进行

866
00:36:33,190 --> 00:36:34,900
查找 在那里，我们需要 B 在

867
00:36:34,900 --> 00:36:36,339
那里，而 C 已经在处理 由

868
00:36:36,339 --> 00:36:39,279
部分索引 where 子句编辑，所以要回答

869
00:36:39,279 --> 00:36:41,440
这个查询，我们只需要实际

870
00:36:41,440 --> 00:36:42,760
查看索引，我们实际上不需要

871
00:36:42,760 --> 00:36:44,950
查看表中的底层元组，

872
00:36:44,950 --> 00:36:47,589
所以这就是所谓的

873
00:36:47,589 --> 00:36:49,869
覆盖索引，覆盖索引

874
00:36:49,869 --> 00:36:51,730
意味着所有 生成

875
00:36:51,730 --> 00:36:54,339
了回答

876
00:36:54,339 --> 00:36:57,160
查询的要求结果所需的字段，您

877
00:36:57,160 --> 00:36:59,230
知道可以在索引本身中找到艺术，

878
00:36:59,230 --> 00:37:02,380
因此您不要将索引声明

879
00:37:02,380 --> 00:37:04,390
为覆盖索引，这

880
00:37:04,390 --> 00:37:05,650
是数据库系统自动为您计算的

881
00:37:05,650 --> 00:37:07,270
我知道你的查询，因为

882
00:37:07,270 --> 00:37:08,349
它注意到一个新的索引，它说明

883
00:37:08,349 --> 00:37:09,630
我需要的一切都在这里，

884
00:37:09,630 --> 00:37:11,859
所以再次使用这个简单的

885
00:37:11,859 --> 00:37:14,650
例子，我可以从中获取 B 字段，

886
00:37:14,650 --> 00:37:17,200
从中可以准确地从索引中找到 a 和 B 字段

887
00:37:17,200 --> 00:37:19,510
我从

888
00:37:19,510 --> 00:37:21,849
不需要查看实际的元组 我可以

889
00:37:21,849 --> 00:37:22,869
为一堆不同的

890
00:37:22,869 --> 00:37:24,789
查询执行此操作 我可以为聚合

891
00:37:24,789 --> 00:37:27,520
执行此操作 我可以为连接执行此操作，

892
00:37:27,520 --> 00:37:29,740
这里的优势是您不知道页面 ID

893
00:37:29,740 --> 00:37:31,329
查找和页面选项卡 可能还有一个

894
00:37:31,329 --> 00:37:34,779
玻璃磁盘 IO 不必

895
00:37:34,779 --> 00:37:38,799
为此查看底层元组，因此

896
00:37:38,799 --> 00:37:40,480
一堆不同的数据系统支持

897
00:37:40,480 --> 00:37:43,839
这一点所有商业人士都在做 Mongo

898
00:37:43,839 --> 00:37:44,260


899
00:37:44,260 --> 00:37:47,320
我不认为我的第二个 Postgres 可能

900
00:37:47,320 --> 00:37:49,810
是错误的 那但是这是一个巨大的

901
00:37:49,810 --> 00:37:51,700
胜利，如果你能做到这一点，这是一个

902
00:37:51,700 --> 00:37:53,650
很大的问题好吧

903
00:37:53,650 --> 00:37:55,540
我不认为 Postgres 可以做到这一点，

904
00:37:55,540 --> 00:37:58,119
原因我们稍后会讨论所以对于

905
00:37:58,119 --> 00:38:01,089
这个简单的例子，这很好，

906
00:38:01,089 --> 00:38:03,750
我需要一个和 B  A B 混淆索引

907
00:38:03,750 --> 00:38:07,930
但如果我现在有另一个我有

908
00:38:07,930 --> 00:38:09,430
另一个属性我希望能够

909
00:38:09,430 --> 00:38:12,280
对我的查询进行查找或获取

910
00:38:12,280 --> 00:38:13,900
但我实际上并不想

911
00:38:13,900 --> 00:38:17,079
在该属性上构建索引 所以我的

912
00:38:17,079 --> 00:38:19,150
桌子有 a B 和 C 列，

913
00:38:19,150 --> 00:38:21,460
也许我不想在座位上建立索引，但

914
00:38:21,460 --> 00:38:23,349
有一个覆盖索引仍然很好，

915
00:38:23,349 --> 00:38:26,050
不必去看元组，所以这

916
00:38:26,050 --> 00:38:27,430
就是包含列允许你

917
00:38:27,430 --> 00:38:30,130
基本上包括列允许

918
00:38:30,130 --> 00:38:32,710
您说出我存储

919
00:38:32,710 --> 00:38:35,530
在我的叶子页面中的所有键 我的叶节点

920
00:38:35,530 --> 00:38:38,190
还包括这些附加属性，

921
00:38:38,190 --> 00:38:40,630
所以在这种情况下，我在 a 和 B 上构建 NX，

922
00:38:40,630 --> 00:38:43,210
所有内部节点只有键 a 和

923
00:38:43,210 --> 00:38:45,849
B，当我进行查找时，我只检查 a

924
00:38:45,849 --> 00:38:47,740
和 B，但是当我进入叶

925
00:38:47,740 --> 00:38:50,859
节点时 我还可以立即获取其中

926
00:38:50,859 --> 00:38:53,160
每个条目的 C 属性值，

927
00:38:53,160 --> 00:38:56,319
因此，如果我再次返回

928
00:38:56,319 --> 00:38:58,270
此处的其他查询，请从食物中选择 B，

929
00:38:58,270 --> 00:38:59,740
其中 a 等于 1 2 3 且 C 等于 whoo

930
00:38:59,740 --> 00:39:00,160
tang

931
00:39:00,160 --> 00:39:02,710
我可能会查找以下内容

932
00:39:02,710 --> 00:39:04,599
然后当我沿着叶节点扫描时，

933
00:39:04,599 --> 00:39:08,020
我可以查看

934
00:39:08,020 --> 00:39:10,599
包含在叶节点中的 C 处的值，并

935
00:39:10,599 --> 00:39:13,140
重视我的谓词，它产生了我的输出，

936
00:39:13,140 --> 00:39:17,680
所以这个

937
00:39:17,680 --> 00:39:20,410
比覆盖索引支持更罕见，所以

938
00:39:20,410 --> 00:39:22,650
很多系统支持部分索引

939
00:39:22,650 --> 00:39:24,609
稍微少一些系统支持

940
00:39:24,609 --> 00:39:26,619
覆盖索引 这个更

941
00:39:26,619 --> 00:39:28,990
罕见 我认为这是 Postgres 11

942
00:39:28,990 --> 00:39:30,670
是的 出版后 Elevens 会添加这个

943
00:39:30,670 --> 00:39:33,550
或现在续集服务器有它但

944
00:39:33,550 --> 00:39:35,190
我的 C 代码没有 支持这个，

945
00:39:35,190 --> 00:39:38,440
Oracle 不支持

946
00:39:38,440 --> 00:39:39,339
同样如此，关键是，

947
00:39:39,339 --> 00:39:42,300
虽然我们可以查找并查看

948
00:39:42,300 --> 00:39:44,920
您有 where 子句，但它

949
00:39:44,920 --> 00:39:46,510
不在 Internet 排序中

950
00:39:46,510 --> 00:39:47,980


951
00:39:47,980 --> 00:39:52,630
的和下

952
00:39:52,630 --> 00:39:53,920
一个讨论我们的函数表达式

953
00:39:53,920 --> 00:39:56,050
索引 所以到目前为止我们已经展示的所有内容，

954
00:39:56,050 --> 00:39:57,490
无论何时

955
00:39:57,490 --> 00:39:59,020
我们声明索引我们总是创建

956
00:39:59,020 --> 00:40:00,790


957
00:40:00,790 --> 00:40:03,790
元组中键的精确副本并将其放入我们的索引中，

958
00:40:03,790 --> 00:40:05,290
但可能存在某种 一些快速的

959
00:40:05,290 --> 00:40:07,270
查询在那里我们

960
00:40:07,270 --> 00:40:09,100
实际上不想

961
00:40:09,100 --> 00:40:11,380
对键的确切值进行查找我们想要对

962
00:40:11,380 --> 00:40:13,000
我们从键中派生的某些值进行查找

963
00:40:13,000 --> 00:40:15,940
所以假设我有一个

964
00:40:15,940 --> 00:40:17,740
简单的例子 在这里，我有这个用户

965
00:40:17,740 --> 00:40:19,840
表，我想做一个查找并找到

966
00:40:19,840 --> 00:40:22,600
所有在星期二登录的用户，

967
00:40:22,600 --> 00:40:25,480
所以这个提取函数需要一个

968
00:40:25,480 --> 00:40:28,060
时间戳，然后你传入

969
00:40:28,060 --> 00:40:30,190
你想要的日期或时间戳的哪个元素，

970
00:40:30,190 --> 00:40:32,950
所以 W 意味着 每周一天，所以这是

971
00:40:32,950 --> 00:40:34,330
说每周提取一天 f  rom

972
00:40:34,330 --> 00:40:36,400
登录时间戳字段并

973
00:40:36,400 --> 00:40:38,590
找到它等于其星期二到

974
00:40:38,590 --> 00:40:42,850
星期日零星期一一个星期二两个的那些所以如果

975
00:40:42,850 --> 00:40:45,369
我创建这样的索引，正如我们

976
00:40:45,369 --> 00:40:51,180
到目前为止所显示的那样这将不起作用为什么

977
00:40:51,690 --> 00:41:02,230
是的所以这个谁说 他说你

978
00:41:02,230 --> 00:41:04,630
必须知道如何准确地提取我们的拉出

979
00:41:04,630 --> 00:41:08,890
哪些范围将对应于

980
00:41:08,890 --> 00:41:11,140
星期二，所以你可以聪明地

981
00:41:11,140 --> 00:41:12,760
说哦，我的渴望看起来像这样我

982
00:41:12,760 --> 00:41:14,380
可以说这是这里

983
00:41:14,380 --> 00:41:17,140
的时间戳范围，星期二可以

984
00:41:17,140 --> 00:41:19,390
是 找到了，但据我所知，没有系统

985
00:41:19,390 --> 00:41:22,060
真正做到这一点，所以我们

986
00:41:22,060 --> 00:41:23,500
你可以做的是不使用它并

987
00:41:23,500 --> 00:41:25,570
创建一个功能索引或表达式

988
00:41:25,570 --> 00:41:28,619
索引，其中

989
00:41:28,619 --> 00:41:31,570
你的索引的实际属性可以是

990
00:41:31,570 --> 00:41:34,240
任何你

991
00:41:34,240 --> 00:41:35,710
可以的任意表达式 在 where 子句中，你

992
00:41:35,710 --> 00:41:40,570
可以建立一个索引，所以

993
00:41:40,570 --> 00:41:43,150
现在我要做一个查找，

994
00:41:43,150 --> 00:41:44,920
对于这个谓词，我知道如何完全

995
00:41:44,920 --> 00:41:49,480
满足它，你知道吗？

996
00:41:49,480 --> 00:41:51,490
只是变得

997
00:41:51,490 --> 00:41:53,590
孤独 g 在这里找到

998
00:41:53,590 --> 00:41:56,790
与我们想要的匹配的所有两个

999
00:41:57,790 --> 00:41:59,290
我们可以用另一种方式来

1000
00:41:59,290 --> 00:42:01,060
加速这个查询，然后我们

1001
00:42:01,060 --> 00:42:05,740
已经在部分索引

1002
00:42:05,740 --> 00:42:08,080
方式之前正确地显示了所以而不是

1003
00:42:08,080 --> 00:42:10,570
完全以这种方式创建索引

1004
00:42:10,570 --> 00:42:12,550
对于每周提取的一天，我

1005
00:42:12,550 --> 00:42:16,330
只是使用它作为我的 where

1006
00:42:16,330 --> 00:42:18,280
子句，说只放置

1007
00:42:18,280 --> 00:42:21,490
提取值产生

1008
00:42:21,490 --> 00:42:27,340
两个正确的元素，所以让我们在 Postgres 中做一个演示，

1009
00:42:27,340 --> 00:42:30,190
这样 Postgres

1010
00:42:30,190 --> 00:42:34,180
有它没有的部分索引 有覆盖

1011
00:42:34,180 --> 00:42:36,100
索引，然后我这里的版本

1012
00:42:36,100 --> 00:42:37,810
是 10，所以它没有包含

1013
00:42:37,810 --> 00:42:39,910
子句，但我们可以玩部分

1014
00:42:39,910 --> 00:42:43,320
索引和功能索引，

1015
00:42:43,650 --> 00:42:45,550
所以为此我们将

1016
00:42:45,550 --> 00:42:48,130
创建一个表，确保我们关闭

1017
00:42:48,130 --> 00:42:53,680
并行 工作人员和时间安排好了，

1018
00:42:53,680 --> 00:42:57,570
所以我们要创建一个表，它有

1019
00:42:57,570 --> 00:43:00,280
一个 ID 字段和一个登录时间戳，

1020
00:43:00,280 --> 00:43:03,820
然后这将是一个简单的

1021
00:43:03,820 --> 00:43:05,680
插入查询 它只是要插入

1022
00:43:05,680 --> 00:43:09,600
一堆记录 一堆唯一的

1023
00:43:09,600 --> 00:43:13,560
时间戳 自 2015 年以来 - 现在以

1024
00:43:13,560 --> 00:43:16,720
一分钟为间隔，这

1025
00:43:16,720 --> 00:43:19,870
将生成大约 200 万

1026
00:43:19,870 --> 00:43:23,920
条记录，所以为了时间让我们走得

1027
00:43:23,920 --> 00:43:25,720
更快，所以我们将对所有内容进行 PG 预热，现在

1028
00:43:25,720 --> 00:43:27,940
一切都在我们的缓冲池中，所以说

1029
00:43:27,940 --> 00:43:30,430
这是查询 我们想要运行我们

1030
00:43:30,430 --> 00:43:32,940
想要获得用户的平均 ID，

1031
00:43:32,940 --> 00:43:36,130
他们在星期二登录的那一天，

1032
00:43:36,130 --> 00:43:39,370
所以在这种情况下，当

1033
00:43:39,370 --> 00:43:42,010
我们运行时，解释它必须进行顺序

1034
00:43:42,010 --> 00:43:46,270
扫描，没有索引，所以我们的第一个

1035
00:43:46,270 --> 00:43:51,610
索引 can build 是表达式索引，

1036
00:43:51,610 --> 00:43:54,070
这应该不会花很长时间，所以现在当我们

1037
00:43:54,070 --> 00:43:56,530
运行解释时，我们可以看到它能够

1038
00:43:56,530 --> 00:43:58,960
挑选并使用

1039
00:43:58,960 --> 00:44:02,200
我们刚刚构建的表达式索引，然后再次按照

1040
00:44:02,200 --> 00:44:03,700
它所说的方式构建权重 我

1041
00:44:03,700 --> 00:44:05,520
知道您正在尝试对此进行查找，

1042
00:44:05,520 --> 00:44:09,610
您知道提取函数

1043
00:44:09,610 --> 00:44:11,380
的输出位置和位置 - 所以

1044
00:44:11,380 --> 00:44:12,910
我只需要查找并说

1045
00:44:12,910 --> 00:44:18,100
找到它等于的所有值，

1046
00:44:18,100 --> 00:44:22,960
然后我们就可以添加 部分索引

1047
00:44:22,960 --> 00:44:24,880
再次创建一个较小的索引

1048
00:44:24,880 --> 00:44:29,410
，它只包含 在有序的 a 中，它只

1049
00:44:29,410 --> 00:44:32,020
包含

1050
00:44:32,020 --> 00:44:34,120
提取函数等于的记录，所以现在如果我

1051
00:44:34,120 --> 00:44:36,460
回到我的函数这里，我

1052
00:44:36,460 --> 00:44:38,140
现在看到它实际上想要选择那个索引，

1053
00:44:38,140 --> 00:44:40,960
因为那将是一个更小的通勤，而

1054
00:44:40,960 --> 00:44:44,500
不是树是 它

1055
00:44:44,500 --> 00:44:46,600
的高度较低，我只是

1056
00:44:46,600 --> 00:44:50,050
立即找到了我想要的东西，所以

1057
00:44:50,050 --> 00:44:51,520
数据库系统可以

1058
00:44:51,520 --> 00:44:53,530
自己找出用于所有这些不同选择的最佳访问方法，

1059
00:44:53,530 --> 00:44:57,970


1060
00:44:57,970 --> 00:45:02,220
所以关于这个的任何问题是的，

1061
00:45:09,420 --> 00:45:13,480
所以他说 所以让我们尝试一下，

1062
00:45:13,480 --> 00:45:18,160
所以删除索引所以保存它是

1063
00:45:18,160 --> 00:45:23,410
如果我的表达式是它会发生什么它是

1064
00:45:23,410 --> 00:45:27,100
基于一些差异或者使用

1065
00:45:27,100 --> 00:45:29,560
当前时间戳不是

1066
00:45:29,560 --> 00:45:33,660
每次我运行它都会改变所以

1067
00:45:33,660 --> 00:45:36,600
看看我想什么后休息 是要这样做

1068
00:45:36,600 --> 00:45:42,490
让我们做让我们做

1069
00:45:42,490 --> 00:45:44,680
表达式索引在哪里是的所以

1070
00:45:44,680 --> 00:45:48,670
他说这样做需要登录

1071
00:45:48,670 --> 00:45:50,440
然后我可以在这里放任何我想要的东西

1072
00:45:50,440 --> 00:45:52,630
只要是有效的表达式所以我

1073
00:45:52,630 --> 00:45:55,150
可以说获取我的登录名并减去 欧

1074
00:45:55,150 --> 00:46:02,350
现在当前的时间戳不允许

1075
00:46:02,350 --> 00:46:07,260
你这样做，好吧，如何做到这一点，

1076
00:46:14,530 --> 00:46:16,940
是的，忘记这一点，忘记

1077
00:46:16,940 --> 00:46:20,560
Postgres 中的亨利减法，

1078
00:46:20,920 --> 00:46:27,370
你

1079
00:46:27,370 --> 00:46:31,960
能这样做吗

1080
00:46:31,960 --> 00:46:39,470
？

1081
00:46:39,470 --> 00:46:41,810
让我们从登录名中减去

1082
00:46:41,810 --> 00:46:48,110
100 它不喜欢，也可以，

1083
00:46:48,110 --> 00:46:51,200
所以基本上当我们

1084
00:46:51,200 --> 00:46:52,700
调用 create index 时会

1085
00:46:52,700 --> 00:46:53,990
发生什么，它会运行一次故障，无论

1086
00:46:53,990 --> 00:46:57,740
现在的时间戳是什么，现在稍后

1087
00:46:57,740 --> 00:46:59,840
它都不会改变它 不是动态的

1088
00:46:59,840 --> 00:47:02,300
- 因为它构建了索引，所以现在如果我

1089
00:47:02,300 --> 00:47:05,990
在理论上再次插入一些东西，它

1090
00:47:05,990 --> 00:47:10,160
现在应该使用正确的电流，

1091
00:47:10,160 --> 00:47:12,770
如果它很聪明，它可以说

1092
00:47:12,770 --> 00:47:14,450
在我构建索引的时候不是现在

1093
00:47:14,450 --> 00:47:15,830
我没有 知道它

1094
00:47:15,830 --> 00:47:18,230
是否会这样做，但又一次，所以你不能做某些

1095
00:47:18,230 --> 00:47:22,610
愚蠢的事情，比如你不能像

1096
00:47:22,610 --> 00:47:24,620
在一个索引上建立索引那样做，但我现在应该

1097
00:47:24,620 --> 00:47:28,790
能够做 ID 加一个，等等，我是

1098
00:47:28,790 --> 00:47:36,340
什么我错过了什么 在这里哦，他就是这个，

1099
00:47:36,340 --> 00:47:38,950
是的，就是这样，把它们写成

1100
00:47:38,950 --> 00:47:42,260
双括号 sis 所以是的 所以现在我

1101
00:47:42,260 --> 00:47:45,560
不能也不会让我这样做 我不

1102
00:47:45,560 --> 00:47:53,480
知道我已经用户

1103
00:47:53,480 --> 00:47:56,900
登录 expr 让我们尝试其他

1104
00:47:56,900 --> 00:48:06,349
示例函数 表达式必须

1105
00:48:06,349 --> 00:48:09,500
标记为不可变 是的，但我

1106
00:48:09,500 --> 00:48:20,150
应该能够 做这件事就像没有

1107
00:48:20,150 --> 00:48:22,550
时间那样正确无论如何让我们明白我的

1108
00:48:22,550 --> 00:48:22,940
观点

1109
00:48:22,940 --> 00:48:26,780
是的，稍后有这种东西称为切得很好的

1110
00:48:26,780 --> 00:48:28,460
快照，但

1111
00:48:28,460 --> 00:48:30,349
就像现在查询运行时一样，

1112
00:48:30,349 --> 00:48:33,700
并且必须保证

1113
00:48:33,700 --> 00:48:38,680
快照的一致性将是索引 SL 是的

1114
00:48:44,890 --> 00:48:48,140
所以这个问题是当我们创建一个

1115
00:48:48,140 --> 00:48:49,550
索引时会创建什么样的索引

1116
00:48:49,550 --> 00:48:52,880
所以我默认情况下

1117
00:48:52,880 --> 00:48:56,480
如果我添加之前的 using 子句它会创建一个 B+ 树

1118
00:48:56,480 --> 00:48:59,869
所以这是一个

1119
00:48:59,869 --> 00:49:01,400
Postgres 成语 这不在 续集

1120
00:49:01,400 --> 00:49:01,960


1121
00:49:01,960 --> 00:49:05,930
标准，例如，如果我使用哈希添加它，这会

1122
00:49:05,930 --> 00:49:08,150
告诉研究生默认情况下让我成为哈希索引，

1123
00:49:08,150 --> 00:49:09,710
每个人都使用你会得到一个

1124
00:49:09,710 --> 00:49:24,829
B+ 树你的问题是，当你添加

1125
00:49:24,829 --> 00:49:46,400
索引时，你可以让我输入 yes 所以当

1126
00:49:46,400 --> 00:49:47,329
你说你不 是不是不用

1127
00:49:47,329 --> 00:49:54,020
看wha的叶子节点 他们索引

1128
00:49:54,020 --> 00:49:55,819
没问题，所以我认为你的问题是我

1129
00:49:55,819 --> 00:49:58,640
是否有索引，如果我查找

1130
00:49:58,640 --> 00:49:59,960
某些查询，我不必查看

1131
00:49:59,960 --> 00:50:01,190
实际的元组，我可以查看

1132
00:50:01,190 --> 00:50:03,680
索引，是的，你像元组一样调用

1133
00:50:03,680 --> 00:50:05,750
你知道在表堆中

1134
00:50:05,750 --> 00:50:07,070
是不是他们没有留下

1135
00:50:07,070 --> 00:50:09,320
叶尖在索引中所以我

1136
00:50:09,320 --> 00:50:10,790
总是我总是必须查看

1137
00:50:10,790 --> 00:50:12,650
索引因为我在 B+ 树中我总是

1138
00:50:12,650 --> 00:50:15,320
必须到底部所以

1139
00:50:15,320 --> 00:50:16,940
如果您可以进行覆盖索引查找，您可以进行某些查询

1140
00:50:16,940 --> 00:50:19,370
我永远不必查看

1141
00:50:19,370 --> 00:50:21,860
表 元组 我可以获得所有

1142
00:50:21,860 --> 00:50:24,080
信息 我需要

1143
00:50:24,080 --> 00:50:27,350
从索引本身计算答案 并非所有数据库

1144
00:50:27,350 --> 00:50:30,590
系统都支持，尽管对于

1145
00:50:30,590 --> 00:50:31,970
我们来说 到目前为止，除了

1146
00:50:31,970 --> 00:50:34,460
覆盖索引之外，我们讨论的想法是，我们可以

1147
00:50:34,460 --> 00:50:37,700
快速找到具有我们想要查找的键的元组，

1148
00:50:37,700 --> 00:50:39,260


1149
00:50:39,260 --> 00:50:41,210
而无需执行顺序扫描

1150
00:50:41,210 --> 00:50:44,960
，因此如果它是一个，则将扫描切换为 n 如果

1151
00:50:44,960 --> 00:50:47,570
它是一个 哈希索引如果它是 B+ 树，我可以做一个 1，

1152
00:50:47,570 --> 00:50:51,680
它的日志 n 是正确的，所以如果这个想法

1153
00:50:51,680 --> 00:50:53,510
正在减少尽可能多的数据

1154
00:50:53,510 --> 00:50:57,760
，以免看太多浪费的工作

1155
00:51:02,800 --> 00:51:05,420
正确保存是如果我们创建一个表

1156
00:51:05,420 --> 00:51:07,070
并且没有索引，我们总是必须

1157
00:51:07,070 --> 00:51:08,570
进行特殊扫描 是的，我们一开始就说过

1158
00:51:08,570 --> 00:51:18,620
是的 问题是我

1159
00:51:18,620 --> 00:51:21,410
创建一个索引，

1160
00:51:21,410 --> 00:51:24,800
如果它由磁盘支持，它会在那里再次正常运行，你

1161
00:51:24,800 --> 00:51:26,000
知道它会被写出，你

1162
00:51:26,000 --> 00:51:27,500
知道它是否由缓冲池支持它

1163
00:51:27,500 --> 00:51:28,820
会输出到磁盘，我想这样做，

1164
00:51:28,820 --> 00:51:30,230
因为它使我的索引可能是

1165
00:51:30,230 --> 00:51:31,460
大于我可用的内存量，

1166
00:51:31,460 --> 00:51:33,890
所以我可以再次

1167
00:51:33,890 --> 00:51:35,420
拥有一个内存中的临时数据结构

1168
00:51:35,420 --> 00:51:37,220
，我不得不

1169
00:51:37,220 --> 00:51:39,080
吹嘘我的续集为他们的

1170
00:51:39,080 --> 00:51:40,640
哈希表做这件事，因为它必须在

1171
00:51:40,640 --> 00:51:42,440
内存中，但是 B post树由磁盘支持，

1172
00:51:42,440 --> 00:51:44,660
因此它变得太大我耐心等待

1173
00:51:44,660 --> 00:51:58,580
我们可能会分开嘿它们

1174
00:51:58,580 --> 00:51:59,870
可能是相同的缓冲池它

1175
00:51:59,870 --> 00:52:01,520
可能与池实例不同它

1176
00:52:01,520 --> 00:52:04,190
再次取决于实现

1177
00:52:04,190 --> 00:52:05,780
缓冲池管理器不知道

1178
00:52:05,780 --> 00:52:07,700
里面有什么 他的页面说你想要页面 1

1179
00:52:07,700 --> 00:52:10,760
2 3 在这里，然后无论是谁

1180
00:52:10,760 --> 00:52:13,190
访问它都有责任知道

1181
00:52:13,190 --> 00:52:15,470
如何解释那些字节 buffle 分钟

1182
00:52:15,470 --> 00:52:17,360
不知道不在乎在

1183
00:52:17,360 --> 00:52:18,920
高端系统中你可以说这里是

1184
00:52:18,920 --> 00:52:20,570
索引的缓冲池管理

1185
00:52:20,570 --> 00:52:22,340
有某些替换策略，

1186
00:52:22,340 --> 00:52:23,450
这是表的一个替换策略，他们有另一个

1187
00:52:23,450 --> 00:52:26,360
替换策略建议 SMI 续集

1188
00:52:26,360 --> 00:52:33,920
，一切都一样，好吧，所以现在让我们

1189
00:52:33,920 --> 00:52:40,720
跳回去完成尝试，

1190
00:52:41,860 --> 00:52:45,740
所以在所有示例中向

1191
00:52:45,740 --> 00:52:49,760
人们展示 到目前为止，内部节点

1192
00:52:49,760 --> 00:52:53,390
和叶节点始终具有键的精确

1193
00:52:53,390 --> 00:52:55,820
副本是的，您可以

1194
00:52:55,820 --> 00:52:57,230
像我们上次讨论的那样进行前缀压缩或后缀截断，

1195
00:52:57,230 --> 00:52:59,300
但总的来说，

1196
00:52:59,300 --> 00:53:00,970
我们在整个过程中多次复制了键的整个副本

1197
00:53:00,970 --> 00:53:02,990


1198
00:53:02,990 --> 00:53:06,460
树结构

1199
00:53:06,460 --> 00:53:08,840
等其他问题也会进入

1200
00:53:08,840 --> 00:53:11,360
人们的树中，为了让

1201
00:53:11,360 --> 00:53:14,690
我确定表中是否存在键，

1202
00:53:14,690 --> 00:53:17,900
我总是必须到达叶节点，我

1203
00:53:17,900 --> 00:53:19,070
总是必须 一直遍历

1204
00:53:19,070 --> 00:53:23,330
到右下角，因为内部

1205
00:53:23,330 --> 00:53:25,580
节点可能有不再存在的键的副本，

1206
00:53:25,580 --> 00:53:27,140
因为当我

1207
00:53:27,140 --> 00:53:29,030
根据我拆分合并的方式从叶节点中删除它们时，

1208
00:53:29,030 --> 00:53:30,920
我可能已经将我的

1209
00:53:30,920 --> 00:53:33,020
路标留在了上面，所以在 为了

1210
00:53:33,020 --> 00:53:34,370
确定我是否确切地知道这个

1211
00:53:34,370 --> 00:53:35,750
密钥存在我总是必须去

1212
00:53:35,750 --> 00:53:39,830
叶节点所以你再次知道它是

1213
00:53:39,830 --> 00:53:42,230
登录而不是设置哦n你必须

1214
00:53:42,230 --> 00:53:43,460
对中央骗局做但它仍然不是

1215
00:53:43,460 --> 00:53:45,290
很好，我可能让你知道

1216
00:53:45,290 --> 00:53:47,210
取决于我有多少内存以及我如何

1217
00:53:47,210 --> 00:53:49,550
使用我的缓冲池管理器我可能有

1218
00:53:49,550 --> 00:53:51,230
一个页面未命中他们会在

1219
00:53:51,230 --> 00:53:53,390
每个单个节点的磁盘上进行查找，因为我已经

1220
00:53:53,390 --> 00:53:56,780
倒退了所以对于某些应用程序

1221
00:53:56,780 --> 00:53:58,220
，如果我们可能会很好 实际上可以

1222
00:53:58,220 --> 00:54:00,640
在树的顶部弄清楚

1223
00:54:00,640 --> 00:54:03,140
我们的密钥是否存在，而不必

1224
00:54:03,140 --> 00:54:06,080
一直走到底部，所以这

1225
00:54:06,080 --> 00:54:08,090
就是部落为我们所做的如此快速

1226
00:54:08,090 --> 00:54:09,520
的举手让她先试一试

1227
00:54:09,520 --> 00:54:11,120
好完美

1228
00:54:11,120 --> 00:54:14,810
这里有谁 听说过板蓝根

1229
00:54:14,810 --> 00:54:17,600
非常好，所以如此 基数树只是

1230
00:54:17,600 --> 00:54:20,450
尝试的一种特殊化，没有人

1231
00:54:20,450 --> 00:54:21,950
使用细香葱，每个人都使用基数治疗

1232
00:54:21,950 --> 00:54:23,180
和数据库，所以我们将经历

1233
00:54:23,180 --> 00:54:26,570
这个，所以尝试是一种树数据结构

1234
00:54:26,570 --> 00:54:28,490
，而不是将键的整个

1235
00:54:28,490 --> 00:54:31,700
副本存储在树中的节点中

1236
00:54:31,700 --> 00:54:34,370
相反，我们将存储

1237
00:54:34,370 --> 00:54:36,410
密钥的数字，并且通过数字，我不一定

1238
00:54:36,410 --> 00:54:39,800
是指阿拉伯数字，我的意思

1239
00:54:39,800 --> 00:54:42,920
是我们密钥的一些子集原子子集，例如

1240
00:54:42,920 --> 00:54:46,610
咬一口或一些单个位，所以

1241
00:54:46,610 --> 00:54:48,050
发生的情况是我们基本上是

1242
00:54:48,050 --> 00:54:50,990
将分解我们所有的密钥并将

1243
00:54:50,990 --> 00:54:53,620
它们存储在你知道

1244
00:54:53,620 --> 00:54:56,810
不同级别的数字中，然后现在

1245
00:54:56,810 --> 00:54:59,060
因为我们可以有重复的密钥或

1246
00:54:59,060 --> 00:55:01,100
重复的数字我们只需要

1247
00:55:01,100 --> 00:55:04,400
在每个级别存储一次所以这里一个非常

1248
00:55:04,400 --> 00:55:06,200
简单的例子是 像

1249
00:55:06,200 --> 00:55:08,390
这样尝试，我有三个键 hello hat

1250
00:55:08,390 --> 00:55:10,730
并且在根节点的第一级中

1251
00:55:10,730 --> 00:55:12,980
所有三个键都以

1252
00:55:12,980 --> 00:55:15,260
字母 H 开头，因此我对每个键进行一次排序，并且有

1253
00:55:15,260 --> 00:55:17,450
一条通往第二级的路径，

1254
00:55:17,450 --> 00:55:20,150
现在我看到我区分了 een hello

1255
00:55:20,150 --> 00:55:23,090
and had not have hello 有一个 e 帽子，

1256
00:55:23,090 --> 00:55:25,700
第二个数字有一个 A，所以我

1257
00:55:25,700 --> 00:55:27,470
有单独的条目，然后

1258
00:55:27,470 --> 00:55:29,600
现在我有单独的路径来

1259
00:55:29,600 --> 00:55:31,640
处理你知道密钥中的每个唯一路径

1260
00:55:31,640 --> 00:55:34,460
所以现在 如果我想抬头说

1261
00:55:34,460 --> 00:55:35,660
我想抬头你好我想把

1262
00:55:35,660 --> 00:55:37,670
它分解成它的

1263
00:55:37,670 --> 00:55:39,890
数字然后我看看 HI 在这里有一个

1264
00:55:39,890 --> 00:55:42,020
匹配 我找到了 E 然后我

1265
00:55:42,020 --> 00:55:44,930
向下旅游 hello 哦，底部

1266
00:55:44,930 --> 00:55:47,810
就像我们的 和我们的 B 加树，这

1267
00:55:47,810 --> 00:55:49,790
可能是一个记录 ID，指向

1268
00:55:49,790 --> 00:55:52,060
我们正在寻找的实际元组，所以

1269
00:55:52,060 --> 00:55:54,350
尝试是旧的尝试比 B

1270
00:55:54,350 --> 00:55:56,450
加树或嵌入的 D 加树更老，

1271
00:55:56,450 --> 00:56:00,050
或者像 1973 年在 IBM 尝试

1272
00:56:00,050 --> 00:56:02,840
实际上来自 就像 1959 年由

1273
00:56:02,840 --> 00:56:05,150
这个法国人发明的，他没有

1274
00:56:05,150 --> 00:56:06,740
名字，然后还有另一个

1275
00:56:06,740 --> 00:56:09,440
CS 研究员，这个著名的家伙曾经为

1276
00:56:09,440 --> 00:56:11,570
Caen 辩护，然后一两年后他

1277
00:56:11,570 --> 00:56:14,810
提出了名称 try，它是

1278
00:56:14,810 --> 00:56:17,210
检索树的缩写， 他用它来

1279
00:56:17,210 --> 00:56:18,680
区别于常规的树

1280
00:56:18,680 --> 00:56:20,840
数据结构 所以这就是他们被

1281
00:56:20,840 --> 00:56:22,910
称为尝试的原因，显然这个 FM can 的

1282
00:56:22,910 --> 00:56:25,040
人实际上是在看你的教员，

1283
00:56:25,040 --> 00:56:26,570
看看你知道的 CS

1284
00:56:26,570 --> 00:56:28,370
网站，他在那里列出的目录

1285
00:56:28,370 --> 00:56:31,070
他就像超级老我从来没有见过很多

1286
00:56:31,070 --> 00:56:32,420
教员的意思 我不知道他是谁 我不知道

1287
00:56:32,420 --> 00:56:33,830
他实际上还在这里

1288
00:56:33,830 --> 00:56:34,910
但那是发明这个术语的人

1289
00:56:34,910 --> 00:56:36,710
据说他实际上就在 CMU

1290
00:56:36,710 --> 00:56:39,110
所以有时你也会看到这些东西

1291
00:56:39,110 --> 00:56:40,850
被列为数字搜索树或前缀

1292
00:56:40,850 --> 00:56:42,560
树就我而言 知道

1293
00:56:42,560 --> 00:56:45,620
这些都是一样的所以尝试

1294
00:56:45,620 --> 00:56:47,180
在数据库的概念中真的很有趣

1295
00:56:47,180 --> 00:56:48,350


1296
00:56:48,350 --> 00:56:50,150
好吧你现在知道我们

1297
00:56:50,150 --> 00:56:52,340
了解人们的街道 所以关于他们的第一

1298
00:56:52,340 --> 00:56:53,210
件事是超级有趣的

1299
00:56:53,210 --> 00:56:56,510
是他们的形状只

1300
00:56:56,510 --> 00:56:59,060
取决于关键 键

1301
00:56:59,060 --> 00:57:01,670
空间的分布及其长度所以我的

1302
00:57:01,670 --> 00:57:03,320
意思是它是一个确定性的数据

1303
00:57:03,320 --> 00:57:04,940
结构所以无论我们插入键的顺序如何，我们

1304
00:57:04,940 --> 00:57:06,770


1305
00:57:06,770 --> 00:57:08,780
最终都会得到相同形状的

1306
00:57:08,780 --> 00:57:10,730
物理数据 str 好吧，

1307
00:57:10,730 --> 00:57:12,380
这与 B 加树中的结构不同，

1308
00:57:12,380 --> 00:57:13,610
因为在 B 加树中，如果我以

1309
00:57:13,610 --> 00:57:15,650
一种方式插入一个键，然后将它们混洗，然后

1310
00:57:15,650 --> 00:57:17,150


1311
00:57:17,150 --> 00:57:18,950
根据我的做法将它们排序到另一棵树，就是

1312
00:57:18,950 --> 00:57:20,930
拆分合并 我最终可能会得到

1313
00:57:20,930 --> 00:57:22,160
不同的音符布局 键

1314
00:57:22,160 --> 00:57:23,600
可能在一个节点中，而不是

1315
00:57:23,600 --> 00:57:26,240
在尝试中的另一个音符中 它总是总是

1316
00:57:26,240 --> 00:57:29,150
相同的事情 关于它们的另一件事

1317
00:57:29,150 --> 00:57:30,170
是它们实际上并不

1318
00:57:30,170 --> 00:57:32,090
像我们一样需要任何重新平衡

1319
00:57:32,090 --> 00:57:35,810
在 P 加树中，所以我们会看到你知道

1320
00:57:35,810 --> 00:57:37,880
有一些重新平衡我们可以

1321
00:57:37,880 --> 00:57:39,680
在垂直水平上做，但在

1322
00:57:39,680 --> 00:57:41,240
水平上我们实际上永远不会

1323
00:57:41,240 --> 00:57:45,470
潜在地重新平衡，所以不像在

1324
00:57:45,470 --> 00:57:47,450
所有操作都登录的 B 加树

1325
00:57:47,450 --> 00:57:50,600
中 试试操作

1326
00:57:50,600 --> 00:57:53,330
复杂度是 K 其中 K 是密钥的长度

1327
00:57:53,330 --> 00:57:56,060
好吧 这

1328
00:57:56,060 --> 00:57:57,170
与加树完全不同所以

1329
00:57:57,170 --> 00:57:59,630
回到这里所以如果我想查找

1330
00:57:59,630 --> 00:58:02,840
你好我到这里的时候我

1331
00:58:02,840 --> 00:58:04,340
知道没有 你知道我一直在

1332
00:58:04,340 --> 00:58:06,500
下降 e 底部但因此

1333
00:58:06,500 --> 00:58:07,640
我必须执行的步骤数取决于

1334
00:58:07,640 --> 00:58:09,110
我正在查找的键，但说我

1335
00:58:09,110 --> 00:58:11,870
要查找和 II am dy 第一个

1336
00:58:11,870 --> 00:58:14,090
字母是我在根节点中查找我

1337
00:58:14,090 --> 00:58:16,100
看到它 只有一个 HI 立即停止

1338
00:58:16,100 --> 00:58:17,630
，我知道我正在寻找的东西

1339
00:58:17,630 --> 00:58:19,370
不能在树的其他任何地方，我

1340
00:58:19,370 --> 00:58:20,480
不必总是在

1341
00:58:20,480 --> 00:58:27,290
底部遍历是的，你的问题是在这里的 e

1342
00:58:27,290 --> 00:58:28,940
我必须吗 遍历

1343
00:58:28,940 --> 00:58:40,310
整个块所以这个游戏是如果这个

1344
00:58:40,310 --> 00:58:43,610
东西是超宽的，这是否

1345
00:58:43,610 --> 00:58:45,470
意味着我必须在

1346
00:58:45,470 --> 00:58:48,890
你预先排序的整个东西上切换扫描，因为你

1347
00:58:48,890 --> 00:58:50,390
做二分搜索以找到你正在

1348
00:58:50,390 --> 00:58:51,830
寻找的东西，当我们看到时 实际上

1349
00:58:51,830 --> 00:58:53,510
，我们实际上是如何做到这一点的 就像

1350
00:58:53,510 --> 00:58:56,570
咬一样 你可以准确地跳到

1351
00:58:56,570 --> 00:58:58,250
你想要的位置 它要么在

1352
00:58:58,250 --> 00:58:59,309
那里要么不在

1353
00:58:59,309 --> 00:59:01,079


1354
00:59:01,079 --> 00:59:02,339


1355
00:59:02,339 --> 00:59:03,390


1356
00:59:03,390 --> 00:59:07,259
好吧，

1357
00:59:07,259 --> 00:59:08,969
这再次非常有趣，

1358
00:59:08,969 --> 00:59:11,459
因为喜欢 t 的事实 他的

1359
00:59:11,459 --> 00:59:12,809
复杂性基于

1360
00:59:12,809 --> 00:59:14,630
我们试图查找长度的密钥，

1361
00:59:14,630 --> 00:59:17,059
这也很有趣，因为

1362
00:59:17,059 --> 00:59:20,429
现在我们没有

1363
00:59:20,429 --> 00:59:22,589
在任何单个节点中存储您直接知道的密钥的确切副本，

1364
00:59:22,589 --> 00:59:24,289
它由路径隐式存储，

1365
00:59:24,289 --> 00:59:26,880
所以 如果我们想重建 hello

1366
00:59:26,880 --> 00:59:29,400
我们会向下遍历跟踪我们

1367
00:59:29,400 --> 00:59:30,900
在堆栈上的路径这就是我们

1368
00:59:30,900 --> 00:59:32,539
可以将密钥重新组合在一起的方式

1369
00:59:32,539 --> 00:59:34,529
而现在这使得顺序扫描

1370
00:59:34,529 --> 00:59:36,869
更加困难因为虽然我可以

1371
00:59:36,869 --> 00:59:37,589
按排序顺序

1372
00:59:37,589 --> 00:59:40,499
我得到了 回溯，你知道

1373
00:59:40,499 --> 00:59:42,989
向上和向下返回，不像在 B 加

1374
00:59:42,989 --> 00:59:44,130
树中我可以沿着叶节点扫描，

1375
00:59:44,130 --> 00:59:46,169
所以尝试点查询会更快，

1376
00:59:46,169 --> 00:59:48,539
然后是 B 加树，但

1377
00:59:48,539 --> 00:59:49,949
它们会比她的第一个慢

1378
00:59:49,949 --> 00:59:54,359
扫描一切正常，所以现在我们

1379
00:59:54,359 --> 00:59:56,189
对 try 的定义进行了更正式的讨论

1380
00:59:56,189 --> 00:59:59,029
，但是我们将

1381
00:59:59,029 --> 01:00:01,999
在节点的 B 加树中以相同的方式使用术语跨度，

1382
01:00:01,999 --> 01:00:04,709
只是说跨度

1383
01:00:04,709 --> 01:00:07,679
是传出分支的数量

1384
01:00:07,679 --> 01:00:09,029
本质上是数字的数量 ts 我们

1385
01:00:09,029 --> 01:00:13,169
将在你知道

1386
01:00:13,169 --> 01:00:16,559
每个级别的每个节点中表示，所以如果一个数字

1387
01:00:16,559 --> 01:00:19,349
将存在于语料库中，那么

1388
01:00:19,349 --> 01:00:20,969
在每个数字的级别，如果它不存在，我们现在必须有一个

1389
01:00:20,969 --> 01:00:22,709
指向另一个分支的指针

1390
01:00:22,709 --> 01:00:24,390
在我们的语料库中的某个级别，

1391
01:00:24,390 --> 01:00:27,029
然后我们只是或空

1392
01:00:27,029 --> 01:00:29,669
一些，所以现在这个跨度

1393
01:00:29,669 --> 01:00:31,229
将使用 B 来确定扇出

1394
01:00:31,229 --> 01:00:34,229
，就像再次在 B+ 树中一样，然后这

1395
01:00:34,229 --> 01:00:35,849
可以对应

1396
01:00:35,849 --> 01:00:38,849
于 试试你

1397
01:00:38,849 --> 01:00:40,709
会说我有一个 N 方式的说法试试你会

1398
01:00:40,709 --> 01:00:42,809
说你有一个乱序 N 的风扇，

1399
01:00:42,809 --> 01:00:44,489
这是数字传递出来的，

1400
01:00:44,489 --> 01:00:46,619
这将使 Turman 成为

1401
01:00:46,619 --> 01:00:50,179
你在每个级别存储的数字的大小

1402
01:00:50,179 --> 01:00:53,339
您可以存储的最简单的尝试

1403
01:00:53,339 --> 01:00:56,519
是一点尝试，所以他们吃每个

1404
01:00:56,519 --> 01:00:59,939
级别我要区分一位的数字

1405
01:00:59,939 --> 01:01:03,239
所以假设我

1406
01:01:03,239 --> 01:01:06,659
想启动这三个键 1025 和 31 所以

1407
01:01:06,659 --> 01:01:08,759
这是一个 1 位尝试 我的意思是在每个

1408
01:01:08,759 --> 01:01:10,140
级别我们都会研究

1409
01:01:10,140 --> 01:01:12,900
一点，所以我会在你知道的情况下展示它们

1410
01:01:12,900 --> 01:01:14,790
这两个数字或三个数字的二进制形式

1411
01:01:14,790 --> 01:01:16,590


1412
01:01:16,590 --> 01:01:19,170
通常是 32 位或 64 位，但为了

1413
01:01:19,170 --> 01:01:20,670
简单起见，我以 16 位显示它们，

1414
01:01:20,670 --> 01:01:25,020
因此在尝试时看起来像

1415
01:01:25,020 --> 01:01:27,600
这样，我将通过 它每个级别

1416
01:01:27,600 --> 01:01:29,910
所以在根节点我们将

1417
01:01:29,910 --> 01:01:32,280
检查第一个数字位置的第一位

1418
01:01:32,280 --> 01:01:35,460
，再次它是一种方式它是

1419
01:01:35,460 --> 01:01:40,170
一位所以它是 0 或 1 所以在这个

1420
01:01:40,170 --> 01:01:43,290
第一个位置所有三个键的

1421
01:01:43,290 --> 01:01:47,310
位都设置为 0 所以在第 0 位我有一条

1422
01:01:47,310 --> 01:01:49,410
在第 1 位向下的路径为空，因为

1423
01:01:49,410 --> 01:01:52,170
没有匹配的键，然后

1424
01:01:52,170 --> 01:01:54,750
我现在进入第二级，为了

1425
01:01:54,750 --> 01:01:57,000
简单起见，我们只会

1426
01:01:57,000 --> 01:01:58,470
重复这个，想想这个重复

1427
01:01:58,470 --> 01:02:00,540
10 次吧 但这将

1428
01:02:00,540 --> 01:02:02,880
是同样的事情我有一个 0 我所有的

1429
01:02:02,880 --> 01:02:05,880
元组都是键在每个位置都有一个 0

1430
01:02:05,880 --> 01:02:07,410
并且有一条向下的路径并且

1431
01:02:07,410 --> 01:02:10,290
一个没有任何东西但是现在当我

1432
01:02:10,290 --> 01:02:12,390
到达这个位置时现在我明白了

1433
01:02:12,390 --> 01:02:15,840
有区别 所以对于关键 10

1434
01:02:15,840 --> 01:02:18,870
，这个位置的这道菜是 0 所以

1435
01:02:18,870 --> 01:02:20,100


1436
01:02:20,100 --> 01:02:22,740
对于其他两个，有一条通往这一边的路径，它是一条

1437
01:02:22,740 --> 01:02:25,950
路径，因此路径在这里向下，所以现在如果我再

1438
01:02:25,950 --> 01:02:27,840
看看这个键的剩余部分，

1439
01:02:27,840 --> 01:02:29,940
它是一条向下的路径，

1440
01:02:29,940 --> 01:02:32,760
你知道它是 1 0  1 0 和同样的

1441
01:02:32,760 --> 01:02:34,410
事情，如果它为空我有

1442
01:02:34,410 --> 01:02:36,180
如果没有在那个

1443
01:02:36,180 --> 01:02:38,850
位置说它是空的，否则它是一条

1444
01:02:38,850 --> 01:02:40,890
向下的路径，然后叶节点再次

1445
01:02:40,890 --> 01:02:42,830
这只是一个记录IDE，

1446
01:02:42,830 --> 01:02:46,350
指向相应的元组相同的东西

1447
01:02:46,350 --> 01:02:48,090
另一边在这一点上

1448
01:02:48,090 --> 01:02:49,680
它们是相同的但是然后它们

1449
01:02:49,680 --> 01:02:51,390
在这里分开然后现在我对其他部分有单独的路径

1450
01:02:51,390 --> 01:02:53,640
对是这样

1451
01:02:53,640 --> 01:02:55,230
你知道你知道所以我们可以

1452
01:02:55,230 --> 01:02:57,420
在 1 位 2 位 8 位中做到这一点 16 位我们

1453
01:02:57,420 --> 01:02:58,530
可以在不同级别

1454
01:02:58,530 --> 01:03:02,730
不同的粒度上做到这一点 所以

1455
01:03:02,730 --> 01:03:06,080
我们可以为此做的一个简单的优化

1456
01:03:06,080 --> 01:03:09,390
实际上有两个优化

1457
01:03:09,390 --> 01:03:14,330
我们如何才能减少这个部落的大小 是的，

1458
01:03:14,360 --> 01:03:17,400
所以他说我们不需要

1459
01:03:17,400 --> 01:03:19,530
标记为 0 和 1 的空格 因为这是

1460
01:03:19,530 --> 01:03:21,090
什么sayi  ng对了，这就是

1461
01:03:21,090 --> 01:03:22,740
这个位置的这个数字的值

1462
01:03:22,740 --> 01:03:24,360
，然后这里是它的指针，

1463
01:03:24,360 --> 01:03:26,610
所以这是多余的，

1464
01:03:26,610 --> 01:03:29,010
所以我真正需要做的就是

1465
01:03:29,010 --> 01:03:31,710
正确存储指针，因为如果它是

1466
01:03:31,710 --> 01:03:33,300
，如果出价是 设置为零和一个

1467
01:03:33,300 --> 01:03:34,890
偏移量 0 最好设置一个我

1468
01:03:34,890 --> 01:03:37,260
去偏移一个 所以这是水平

1469
01:03:37,260 --> 01:03:39,930
压缩 这是减少部落的大小

1470
01:03:39,930 --> 01:03:42,930
每个尝试节点

1471
01:03:42,930 --> 01:03:44,430
另一个压缩权重是什么我可以

1472
01:03:44,430 --> 01:03:47,450
在后面压缩我们

1473
01:03:47,870 --> 01:03:49,860
他说重复 这个数字有

1474
01:03:49,860 --> 01:03:51,720
十次你实际上

1475
01:03:51,720 --> 01:03:58,470
必须拥有所以一旦我来到这里这些

1476
01:03:58,470 --> 01:04:00,570
部分这里没有其他键可以

1477
01:04:00,570 --> 01:04:03,510
匹配这个和他

1478
01:04:03,510 --> 01:04:05,640
所说的那种但是但是在这里

1479
01:04:05,640 --> 01:04:06,690
喘口气我们必须保持这个是因为

1480
01:04:06,690 --> 01:04:07,950
我们将在这里拆分，所以我们需要

1481
01:04:07,950 --> 01:04:10,740
知道我们是如何到达这里的，但是

1482
01:04:10,740 --> 01:04:12,030
在此之后，

1483
01:04:12,030 --> 01:04:14,100
如果

1484
01:04:14,100 --> 01:04:16,200
您在此级别的此位置下降，

1485
01:04:16,200 --> 01:04:18,480
如果出价为零，我们不需要将任何平均堆栈存储到存储中 我

1486
01:04:18,480 --> 01:04:20,040
只有一个匹配的键 所以让我

1487
01:04:20,040 --> 01:04:21,810
销毁指向那个键的元组指针

1488
01:04:21,810 --> 01:04:25,350
，然后在这里做同样的事情，所以这是

1489
01:04:25,350 --> 01:04:38,340
垂直压缩是的，你的问题

1490
01:04:38,340 --> 01:04:40,680
是激励故事城市而不是

1491
01:04:40,680 --> 01:05:01,050
存储网站是的，这就像一个

1492
01:05:01,050 --> 01:05:02,850
低分的反对，就像 CPU

1493
01:05:02,850 --> 01:05:05,340
指令来帮助你 可以在

1494
01:05:05,340 --> 01:05:07,320
单个结构中运行 for 就像一个

1495
01:05:07,320 --> 01:05:10,050
位图 一个位序列 find 要么

1496
01:05:10,050 --> 01:05:12,360
在某些指令中找到此偏移量处的值，

1497
01:05:12,360 --> 01:05:13,740
您不必

1498
01:05:13,740 --> 01:05:16,320
迭代，或者像您找到我一样，您计算

1499
01:05:16,320 --> 01:05:19,020
其中的数量 我在这个位

1500
01:05:19,020 --> 01:05:21,030
域中，有一个 CPU 指令

1501
01:05:21,030 --> 01:05:23,130
可以让这个过程变得非常快，所以它

1502
01:05:23,130 --> 01:05:24,690
不像你只是在做一个 for

1503
01:05:24,690 --> 01:05:25,920
循环淬火就像扫描这个

1504
01:05:25,920 --> 01:05:30,300
它并不像你认为的那么糟糕

1505
01:05:30,300 --> 01:05:32,010
所以再次这个 就像低级位

1506
01:05:32,010 --> 01:05:33,900
信息，但它在

1507
01:05:33,900 --> 01:05:36,960
极端情况下向你展示你不会实际

1508
01:05:36,960 --> 01:05:39,150
尝试通常你想将它们存储为

1509
01:05:39,150 --> 01:05:40,420
八位

1510
01:05:40,420 --> 01:05:43,060
或一口但对我来说这是

1511
01:05:43,060 --> 01:05:44,650
理解这一点的最简单方法，所以

1512
01:05:44,650 --> 01:05:46,630
即使现在 它是八位

1513
01:05:46,630 --> 01:05:48,370
每个位置都是一样的东西 我只是有一个

1514
01:05:48,370 --> 01:05:50,620
指针，然后快速跳转

1515
01:05:50,620 --> 01:05:54,640
到我想要的那个，所以

1516
01:05:54,640 --> 01:05:56,320
如果一切都是静态的，这很好，

1517
01:05:56,320 --> 01:05:59,800
但实际上我们如何修改

1518
01:05:59,800 --> 01:06:01,060
这个东西，每次插入和更新

1519
01:06:01,060 --> 01:06:04,510
并删除，所以没有标准的方法

1520
01:06:04,510 --> 01:06:07,630
来保持尝试的方式，

1521
01:06:07,630 --> 01:06:09,460
就像 B+ 树不同的

1522
01:06:09,460 --> 01:06:12,010
实现做不同的事情，所以

1523
01:06:12,010 --> 01:06:13,750
我将向您展示一个简短的

1524
01:06:13,750 --> 01:06:15,310
例子，我不是说这是唯一的

1525
01:06:15,310 --> 01:06:16,810
方法 这样做但是

1526
01:06:16,810 --> 01:06:18,250
如果你真的想建立一个你必须注意的一些事情

1527
01:06:18,250 --> 01:06:20,230
让我们再说

1528
01:06:20,230 --> 01:06:22,180
一遍这是你好帽子并且有

1529
01:06:22,180 --> 01:06:25,000
我们之前的钥匙组所以我再次插入头发

1530
01:06:25,000 --> 01:06:26,530
我只是倒退我会找到这个

1531
01:06:26,530 --> 01:06:28,300
在这里，现在我可以把这个放到

1532
01:06:28,300 --> 01:06:31,570
这个好了 所以现在让我们说我想

1533
01:06:31,570 --> 01:06:33,970
删除帽子 在这里我

1534
01:06:33,970 --> 01:06:36,010
继续删除那个而不是

1535
01:06:36,010 --> 01:06:37,510
重新洗牌也许

1536
01:06:37,510 --> 01:06:39,580
我可以在这里留下一个空白空间

1537
01:06:39,580 --> 01:06:41,770
因为那样我就不 不要扔帽子

1538
01:06:41,770 --> 01:06:43,540
a 动作，但现在让我们说我确实领导了

1539
01:06:43,540 --> 01:06:46,420
，现在我删除了这个，我说现在

1540
01:06:46,420 --> 01:06:49,570
我有这个笔记本身，

1541
01:06:49,570 --> 01:06:51,640
所以如果我想你知道实际上找到

1542
01:06:51,640 --> 01:06:53,710
头发，我必须让你知道做一个额外的

1543
01:06:53,710 --> 01:06:55,300
跳跃 我是，但我知道我

1544
01:06:55,300 --> 01:06:57,280
不会有任何其他比赛，所以你可以

1545
01:06:57,280 --> 01:06:59,200
决定把所有东西都卷

1546
01:06:59,200 --> 01:07:02,590
起来放在这儿，再次不同，不同的

1547
01:07:02,590 --> 01:07:04,930
实现使用不同的东西，如果

1548
01:07:04,930 --> 01:07:06,280
你参加高级课程将涵盖

1549
01:07:06,280 --> 01:07:15,670
很多这些东西 是的，是的，你的

1550
01:07:15,670 --> 01:07:18,010
意思是非常清楚，基数树是

1551
01:07:18,010 --> 01:07:21,430
一种垂直压缩的，嗯是的，

1552
01:07:21,430 --> 01:07:22,360
我应该在没有更仔细的情况下对齐

1553
01:07:22,360 --> 01:07:29,830
是的我不在幻灯片上是的

1554
01:07:29,830 --> 01:07:31,480
基数树是一个你

1555
01:07:31,480 --> 01:07:34,840
删除所有路径的一个

1556
01:07:34,840 --> 01:07:36,490
不知道我不用来做

1557
01:07:36,490 --> 01:07:37,660
幻灯片的定义是什么基数

1558
01:07:37,660 --> 01:07:42,700
条约我没有遇到它抱歉好吧

1559
01:07:42,700 --> 01:07:44,020
不这是抱歉这是半径

1560
01:07:44,020 --> 01:07:44,260
树

1561
01:07:44,260 --> 01:07:46,450
抱歉这是当您进行垂直

1562
01:07:46,450 --> 01:07:50,110
压缩以删除时 任何

1563
01:07:50,110 --> 01:07:51,300
没有其他明显

1564
01:07:51,300 --> 01:07:53,710
差异的节点 它下面的路径

1565
01:07:53,710 --> 01:07:55,030
有时称为 Patricia 树，但

1566
01:07:55,030 --> 01:07:57,880
通常称为基数树，再次

1567
01:07:57,880 --> 01:08:02,290
它是尝试的一个子集，所以他

1568
01:08:02,290 --> 01:08:03,579
涵盖了市场，我想 PP 谈论的最后一件事

1569
01:08:03,579 --> 01:08:07,720


1570
01:08:07,720 --> 01:08:09,490
实际上是为了时间我实际上如何进行比较

1571
01:08:09,490 --> 01:08:11,319
将跳过，让我们最后一个

1572
01:08:11,319 --> 01:08:14,680
横向倒排索引再次尝试

1573
01:08:14,680 --> 01:08:17,799
非常有趣

1574
01:08:17,799 --> 01:08:21,009
，据我所知，没有商业数据系统支持它们

1575
01:08:21,009 --> 01:08:26,250
开箱即用 hyper 是一个

1576
01:08:26,250 --> 01:08:29,710
从德国以外的系统，tableau 购买并

1577
01:08:29,710 --> 01:08:31,750
运行在你知道 tableaus 的帖子中 是

1578
01:08:31,750 --> 01:08:34,420
兼容的，他们都

1579
01:08:34,420 --> 01:08:36,040
在尝试我们在这里做了一些研究，

1580
01:08:36,040 --> 01:08:37,420
他们非常有趣，但

1581
01:08:37,420 --> 01:08:39,100
现在 B+ 树仍然是

1582
01:08:39,100 --> 01:08:41,020
每个人都使用的主要数据结构，但

1583
01:08:41,020 --> 01:08:44,710
对它们有很多兴趣，

1584
01:08:44,710 --> 01:08:46,719
所以一切都如此真实

1585
01:08:46,719 --> 01:08:49,479
到目前为止，我们讨论的这些索引

1586
01:08:49,479 --> 01:08:52,179
已经满足或处理索引或

1587
01:08:52,179 --> 01:08:54,339
点查询和范围查询，所以我

1588
01:08:54,339 --> 01:08:55,660
想找出你

1589
01:08:55,660 --> 01:08:57,850
知道住在邮政编码 1 的人的位置

1590
01:08:57,850 --> 01:08:58,870
一五二一七

1591
01:08:58,870 --> 01:09:00,880
好吧，这是一个平等谓词

1592
01:09:00,880 --> 01:09:01,988
，可以准确地找到我正在寻找的东西

1593
01:09:01,988 --> 01:09:04,089
，或者如果我试图

1594
01:09:04,089 --> 01:09:06,219
在日期范围内找到东西，那又是一个范围

1595
01:09:06,219 --> 01:09:08,350
扫描，我可以再次使用用户人们一条

1596
01:09:08,350 --> 01:09:11,020
街 当我们想要进行关键字搜索时，Bevo 的树

1597
01:09:11,020 --> 01:09:12,969
和哈希索引哈希表

1598
01:09:12,969 --> 01:09:15,250
对我们

1599
01:09:15,250 --> 01:09:18,160
不利，例如，假设我拥有

1600
01:09:18,160 --> 01:09:20,710
维基百科的整个语料库，我将

1601
01:09:20,710 --> 01:09:22,390
找到包含关键字 Pablo 的所有蓝色键珠维基百科

1602
01:09:22,390 --> 01:09:24,399
文章

1603
01:09:24,399 --> 01:09:27,460
我不能为此使用哈希表索引

1604
01:09:27,460 --> 01:09:29,649
，也不能为此使用 B+ 树索引

1605
01:09:29,649 --> 01:09:31,810
，因为我正在尝试

1606
01:09:31,810 --> 01:09:35,850
为属性

1607
01:09:35,850 --> 01:09:38,080
权和 B+ 树的候选者找到上述值的子元素

1608
01:09:38,080 --> 01:09:41,259
，我有 有确切的键我不能

1609
01:09:41,259 --> 01:09:43,270
做部分键你知道我可以做

1610
01:09:43,270 --> 01:09:45,310
部分键查找但是如果键

1611
01:09:45,310 --> 01:09:47,080
由多个属性组成但

1612
01:09:47,080 --> 01:09:48,759
在单个属性中我必须拥有它

1613
01:09:48,759 --> 01:09:50,770
的全部值我不能有

1614
01:09:50,770 --> 01:09:55,300
像前 16 位所以这是

1615
01:09:55,300 --> 01:09:56,530
我们正在尝试的问题 o 在这里快速解决

1616
01:09:56,530 --> 01:09:58,210
只是再次提醒大家

1617
01:09:58,210 --> 01:10:00,130
维基百科看起来像什么 我们关心的主要事情

1618
01:10:00,130 --> 01:10:01,030
是

1619
01:10:01,030 --> 01:10:03,760
有一个修订表 有一个技术

1620
01:10:03,760 --> 01:10:06,310
是我的博彩公司 抱歉，它有大文本

1621
01:10:06,310 --> 01:10:07,269


1622
01:10:07,269 --> 01:10:08,650
字段，我们想要它我们想要

1623
01:10:08,650 --> 01:10:09,999
能够为此找到 Pablo 的所有匹配项，

1624
01:10:09,999 --> 01:10:14,800
因此，如果我尝试

1625
01:10:14,800 --> 01:10:17,980
在内容字段上创建索引，这对我来说是一个非常

1626
01:10:17,980 --> 01:10:21,010
糟糕的主意，因为它再次

1627
01:10:21,010 --> 01:10:24,190
将整个键和该属性的整个内容

1628
01:10:24,190 --> 01:10:26,590
放在我们的表中并尝试

1629
01:10:26,590 --> 01:10:28,090
建立一个因为人们街就可以

1630
01:10:28,090 --> 01:10:29,980
了，如果我们保留 Peeta

1631
01:10:29,980 --> 01:10:31,269
这将是非常愚蠢的，因为有些

1632
01:10:31,269 --> 01:10:33,789
文章可能是千字节，现在我正在

1633
01:10:33,789 --> 01:10:36,429
存储整个密钥和我的

1634
01:10:36,429 --> 01:10:38,889
索引，是的，这是我唯一能做的

1635
01:10:38,889 --> 01:10:40,389
查找某人是您知道是否

1636
01:10:40,389 --> 01:10:41,679
有人将整篇文章还给我，

1637
01:10:41,679 --> 01:10:44,440
这很愚蠢，所以

1638
01:10:44,440 --> 01:10:45,579
为了进行这样的查找，我

1639
01:10:45,579 --> 01:10:49,539
想做一组你知道的

1640
01:10:49,539 --> 01:10:51,219
事情等于我想做的事情

1641
01:10:51,219 --> 01:10:53,349
关键字搜索 h 喜欢当

1642
01:10:53,349 --> 01:10:55,659
带有通配符的 like 子句并说找到我

1643
01:10:55,659 --> 01:10:56,829
所有的匹配项时，您实际上知道其中的

1644
01:10:56,829 --> 01:10:58,840
关键字 Pablo

1645
01:10:58,840 --> 01:11:00,309
并且这实际上是将权利打结，

1646
01:11:00,309 --> 01:11:01,900
无论哪种方式都是平等的，因为这

1647
01:11:01,900 --> 01:11:04,389
将匹配具有 Pablo

1648
01:11:04,389 --> 01:11:06,400
作为 像 Pavlov 这样的前缀，对于

1649
01:11:06,400 --> 01:11:08,590
著名的俄罗斯科学家，我会

1650
01:11:08,590 --> 01:11:10,659
找到我的名字被使用的确切位置

1651
01:11:10,659 --> 01:11:13,059
所以这个谓词本身

1652
01:11:13,059 --> 01:11:15,849
对我们没有用所以这就是

1653
01:11:15,849 --> 01:11:18,190
倒排索引告诉我们的所以

1654
01:11:18,190 --> 01:11:21,460
倒排索引会 映射单词，

1655
01:11:21,460 --> 01:11:23,079
他像我们在你

1656
01:11:23,079 --> 01:11:25,030
知道的英语语言或自然

1657
01:11:25,030 --> 01:11:27,849
语言中描述它们一样工作，而不是处理器中的字节序列，将

1658
01:11:27,849 --> 01:11:30,249
单词映射到

1659
01:11:30,249 --> 01:11:33,400
包含它们的记录，然后它

1660
01:11:33,400 --> 01:11:35,110
会失去它，然后在这个索引上进行查找

1661
01:11:35,110 --> 01:11:36,880
并说 为我找到

1662
01:11:36,880 --> 01:11:38,559
包含此关键字的所有记录或

1663
01:11:38,559 --> 01:11:39,730
知道此特定

1664
01:11:39,730 --> 01:11:42,099
属性的关键字的所有记录，因此这些有时称为

1665
01:11:42,099 --> 01:11:44,170
全文搜索索引，

1666
01:11:44,170 --> 01:11:47,469
就像我创建索引时一样 我告诉

1667
01:11:47,469 --> 01:11:48,730
Postgres 我想要这个东西是一个

1668
01:11:48,730 --> 01:11:50,619
哈希表索引 你可以做

1669
01:11:50,619 --> 01:11:51,880
一些与某些数据库相同的事情 你可以说我

1670
01:11:51,880 --> 01:11:53,199
想创建一个索引我想

1671
01:11:53,199 --> 01:11:55,360
成为我想成为一个倒排索引以及

1672
01:11:55,360 --> 01:11:59,710
全文搜索索引 所以有时

1673
01:11:59,710 --> 01:12:01,269
在理论文献中这些被

1674
01:12:01,269 --> 01:12:03,369
称为核心舞蹈 这是因为

1675
01:12:03,369 --> 01:12:05,139
1800 年代有一位老太太

1676
01:12:05,139 --> 01:12:07,420
坐了 16 年 建立

1677
01:12:07,420 --> 01:12:10,659
倒排索引 映射

1678
01:12:10,659 --> 01:12:12,849
莎士比亚及其

1679
01:12:12,849 --> 01:12:14,800
整个作品中使用的每个单词 但是，如果

1680
01:12:14,800 --> 01:12:16,030
没有人称他为他，那么每个人都

1681
01:12:16,030 --> 01:12:18,249
称他为第一个全文搜索索引

1682
01:12:18,249 --> 01:12:20,380
，因此所有主要

1683
01:12:20,380 --> 01:12:20,950
数据库

1684
01:12:20,950 --> 01:12:23,430
都将在内部支持某些变体，

1685
01:12:23,430 --> 01:12:25,480
正如我在调用创建索引时所说的那样，

1686
01:12:25,480 --> 01:12:26,860
您可以说我

1687
01:12:26,860 --> 01:12:28,840
想要一个 全文搜索和搜索索引

1688
01:12:28,840 --> 01:12:32,050
，它们

1689
01:12:32,050 --> 01:12:34,960
在索引的复杂程度以及

1690
01:12:34,960 --> 01:12:35,950
您可以对它们运行的查询类型方面都各不相同，

1691
01:12:35,950 --> 01:12:38,290
还有一堆专门的

1692
01:12:38,290 --> 01:12:40,150
数据库系统可以出售

1693
01:12:40,150 --> 01:12:41,770
或 作为全文搜索数据库销售，

1694
01:12:41,770 --> 01:12:44,740
所以最著名的是多

1695
01:12:44,740 --> 01:12:46,870
弹性搜索，这是建立在

1696
01:12:46,870 --> 01:12:48,880
亮氨酸之上的 亮氨酸就像一个

1697
01:12:48,880 --> 01:12:50,950
由发明 Hadoop 的人编写的库

1698
01:12:50,950 --> 01:12:53,110


1699
01:12:53,110 --> 01:12:55,180
然后

1700
01:12:55,180 --> 01:12:58,240
弹性搜索提供

1701
01:12:58,240 --> 01:13:01,420
了该索引的服务器接口，因此也

1702
01:13:01,420 --> 01:13:02,830
使用了我认为 Sphinx 也可以使用的场景

1703
01:13:02,830 --> 01:13:06,700


1704
01:13:06,700 --> 01:13:08,380


1705
01:13:08,380 --> 01:13:09,610


1706
01:13:09,610 --> 01:13:11,290
我的续集全文

1707
01:13:11,290 --> 01:13:13,690
搜索索引，但理想情况下，您知道

1708
01:13:13,690 --> 01:13:15,580
这些都是内部的或

1709
01:13:15,580 --> 01:13:17,980
外部的，就像自定义

1710
01:13:17,980 --> 01:13:20,170
续集一样，而这些其他人

1711
01:13:20,170 --> 01:13:21,370
有点像它内置于

1712
01:13:21,370 --> 01:13:25,840
系统本身，所以我们没有得到 是

1713
01:13:25,840 --> 01:13:27,850
时候讨论实现了，但基本上

1714
01:13:27,850 --> 01:13:30,340
是我们

1715
01:13:30,340 --> 01:13:32,140
到目前为止在 B 加树中讨论的所有哈希表索引内容，这

1716
01:13:32,140 --> 01:13:33,340
就是您将要用来构建

1717
01:13:33,340 --> 01:13:35,590
这些全文搜索索引的内容，因此

1718
01:13:35,590 --> 01:13:36,850
有一个查找并找到我

1719
01:13:36,850 --> 01:13:38,590
所有你知道的

1720
01:13:38,590 --> 01:13:40,510
包含容器词的记录我可以将其构建为

1721
01:13:40,510 --> 01:13:45,130
哈希表我可以将其构建为 B+

1722
01:13:45,130 --> 01:13:46,870
树但我将使用

1723
01:13:46,870 --> 01:13:48,700
额外的元数据对其进行扩充，这些元数据提供

1724
01:13:48,700 --> 01:13:50,380
有关如何使用的上下文 这个词被

1725
01:13:50,380 --> 01:13:54,460
用在元组中，所以

1726
01:13:54,460 --> 01:13:55,930
你可以做的那种查询你不能做

1727
01:13:55,930 --> 01:13:57,940
想要在全文全文

1728
01:13:57,940 --> 01:14:01,030
或倒排索引处加树你可以做短语

1729
01:14:01,030 --> 01:14:03,100
搜索所以我可以再次找到所有

1730
01:14:03,100 --> 01:14:05,410
包含 Pablo 一词的记录

1731
01:14:05,410 --> 01:14:08,050
我可以进行邻近搜索 所以找到所有包含

1732
01:14:08,050 --> 01:14:10,930
Pablo 这个词的记录

1733
01:14:10,930 --> 01:14:13,000
你知道在五个字或

1734
01:14:13,000 --> 01:14:15,100
三个字之内 你知道犯罪或

1735
01:14:15,100 --> 01:14:17,020
酒精或类似的东西

1736
01:14:17,020 --> 01:14:18,820
因为我正在维护上下文

1737
01:14:18,820 --> 01:14:20,080
关于该词如何

1738
01:14:20,080 --> 01:14:22,450
使用的信息，然后我还可以进行通配符

1739
01:14:22,450 --> 01:14:24,310
搜索，这

1740
01:14:24,310 --> 01:14:26,080
比类似的东西更复杂我可以使用正则

1741
01:14:26,080 --> 01:14:27,820
表达式或复杂的模式匹配

1742
01:14:27,820 --> 01:14:30,249
来查找我正在

1743
01:14:30,249 --> 01:14:32,769
寻找的东西，所以我们稍微关心的

1744
01:14:32,769 --> 01:14:34,090
是 我们实际上将如何构建

1745
01:14:34,090 --> 01:14:35,650
这个东西 并且不同的

1746
01:14:35,650 --> 01:14:37,659
系统都会做不同的

1747
01:14:37,659 --> 01:14:38,979
事情 他们将埋葬最多的

1748
01:14:38,979 --> 01:14:40,179
东西 是他们实际存储的东西 这

1749
01:14:40,179 --> 01:14:42,610
是关于如何在其中找到这个词的上下文信息

1750
01:14:42,610 --> 01:14:45,190
属性，所以

1751
01:14:45,190 --> 01:14:46,929
在最简单的形式中，您只需要

1752
01:14:46,929 --> 01:14:48,999
知道单词本身，然后映射到

1753
01:14:48,999 --> 01:14:50,829
记录 IDE，但我也可以包括您

1754
01:14:50,829 --> 01:14:52,179
知道它周围的

1755
01:14:52,179 --> 01:14:53,559
其他单词与其他单词相距多少步，

1756
01:14:53,559 --> 01:14:56,469
这将决定其复杂程度

1757
01:14:56,469 --> 01:14:59,170
我可以支持的查询，另一个

1758
01:14:59,170 --> 01:15:00,460
棘手的事情实际上是当你更新

1759
01:15:00,460 --> 01:15:02,800
这些东西时，所以如果它是在系统内部构建的

1760
01:15:02,800 --> 01:15:05,530
，那么理论上你可以在每次

1761
01:15:05,530 --> 01:15:07,329
更新时确保你更新你的

1762
01:15:07,329 --> 01:15:09,820
搜索索引或倒排索引，如果是一个

1763
01:15:09,820 --> 01:15:11,349
外部的拳头，你 可以将其作为

1764
01:15:11,349 --> 01:15:14,949
cron 作业运行或推送更新很多

1765
01:15:14,949 --> 01:15:17,050
次人们会

1766
01:15:17,050 --> 01:15:18,760
分批进行更新，然后每隔一段时间应用它们

1767
01:15:18,760 --> 01:15:20,530
，因为潜在地

1768
01:15:20,530 --> 01:15:22,059
更新倒排索引非常

1769
01:15:22,059 --> 01:15:24,729
昂贵 我再次意识到我会

1770
01:15:24,729 --> 01:15:26,320
超快地结束我只是想让

1771
01:15:26,320 --> 01:15:28,570
你知道，除了

1772
01:15:28,570 --> 01:15:29,559
我们在这里讨论的 B 加上树和哈希表之外

1773
01:15:29,559 --> 01:15:31,119


1774
01:15:31,119 --> 01:15:33,309
，还有一大堆其他可用的数据库索引可以做

1775
01:15:33,309 --> 01:15:34,929
一些超出点的事情

1776
01:15:34,929 --> 01:15:37,809
我们已经看过的查询和范围查询，

1777
01:15:37,809 --> 01:15:39,699
实际上

1778
01:15:39,699 --> 01:15:40,809
我们没有讨论的另一类索引是

1779
01:15:40,809 --> 01:15:42,940
索引之间的地理空间，所以

1780
01:15:42,940 --> 01:15:46,329
像我们的树四叉树 KT 树这样的东西

1781
01:15:46,329 --> 01:15:47,619
允许你做多维

1782
01:15:47,619 --> 01:15:49,659
模型，比如 你的几何空间

1783
01:15:49,659 --> 01:15:51,579
和类似的东西

1784
01:15:51,579 --> 01:15:54,550
现在在视频数据库和

1785
01:15:54,550 --> 01:15:57,239
图像数据库中非常普遍，所以有一整

1786
01:15:57,239 --> 01:15:59,650
节课克里斯托斯法卢达是另一位戴维斯

1787
01:15:59,650 --> 01:16:02,320
教授教 15 到 26 他

1788
01:16:02,320 --> 01:16:03,519
现在在秋季和春季教它所以如果你

1789
01:16:03,519 --> 01:16:04,539
对这种东西感兴趣 我会

1790
01:16:04,539 --> 01:16:07,479
在春天教它 所以

1791
01:16:07,479 --> 01:16:10,030
所有这一切的主要收获是，在

1792
01:16:10,030 --> 01:16:12,159
我们大部分时间里，B+ 树已经消失

1793
01:16:12,159 --> 01:16:14,019
了，我们想要的是

1794
01:16:14,019 --> 01:16:16,179
，这是非常有用的索引 帽子是有弹性的，可以

1795
01:16:16,179 --> 01:16:17,889
解决

1796
01:16:17,889 --> 01:16:21,099
人们在数据库倒排索引中遇到的许多问题，我们

1797
01:16:21,099 --> 01:16:22,210
可以去你想更详细地了解

1798
01:16:22,210 --> 01:16:24,039
另一个类别，我

1799
01:16:24,039 --> 01:16:28,659
认为 LTI 442 或 642 我认为它被称为

1800
01:16:28,659 --> 01:16:31,599
搜索引擎，但仅在搜索

1801
01:16:31,599 --> 01:16:33,369
引擎中 for cover 基本上是一个

1802
01:16:33,369 --> 01:16:35,409
倒排索引，所以它是相同的

1803
01:16:35,409 --> 01:16:39,570
技术，相同的方法，好吧，

1804
01:16:40,369 --> 01:16:43,739
所以下周三我们现在要去

1805
01:16:43,739 --> 01:16:45,360
看看我们实际上如何使我们的 B

1806
01:16:45,360 --> 01:16:47,280
plus 树线程安全，所以我们已经

1807
01:16:47,280 --> 01:16:49,469
把这一切都洗掉了 或者我们还没有讨论

1808
01:16:49,469 --> 01:16:50,760
过避免问题，实际上

1809
01:16:50,760 --> 01:16:52,409
我们如何允许多个线程

1810
01:16:52,409 --> 01:16:54,389
同时更新索引，所以现在我们

1811
01:16:54,389 --> 01:16:55,590
花更多的时间讨论

1812
01:16:55,590 --> 01:17:24,409
这个问题，好的，跳弹

1813
01:17:28,699 --> 01:17:37,019
果冻瓶，我不能说 不知道你的手机

1814
01:17:37,019 --> 01:17:39,590
可以点击

