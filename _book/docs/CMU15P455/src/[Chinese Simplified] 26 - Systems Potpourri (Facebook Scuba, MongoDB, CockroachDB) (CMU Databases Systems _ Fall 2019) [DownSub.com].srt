1
00:00:03,640 --> 00:00:16,690
[音乐]

2
00:00:16,690 --> 00:00:20,029
好吧，下雪

3
00:00:20,029 --> 00:00:24,560
了，你放下桌子吗谢谢你所以我

4
00:00:24,560 --> 00:00:26,210
注意到你今天没有你的甲板

5
00:00:26,210 --> 00:00:30,800
发生了什么事是的你现在必须

6
00:00:30,800 --> 00:00:35,180
给她买礼物是的所以你做了什么

7
00:00:35,180 --> 00:00:38,960
你卖掉了你的甲板是的如何 你现在

8
00:00:38,960 --> 00:00:44,989
要如何放下节拍，但这

9
00:00:44,989 --> 00:00:45,980
现在正在干扰你的专辑，

10
00:00:45,980 --> 00:00:53,019
你什么都没有，

11
00:00:55,660 --> 00:01:00,140
好吧，他有他的问题，

12
00:01:00,140 --> 00:01:02,149
我们有数据库问题，但这

13
00:01:02,149 --> 00:01:04,550
是最后一堂课，正如我所说的那样 只是

14
00:01:04,550 --> 00:01:05,840
将是最终审查，然后是

15
00:01:05,840 --> 00:01:07,430
系统顶级 Arif 你们投票

16
00:01:07,430 --> 00:01:10,430
给你想要谈论

17
00:01:10,430 --> 00:01:12,140
的东西 所以真的很快

18
00:01:12,140 --> 00:01:14,150
学期项目的剩余事项将于

19
00:01:14,150 --> 00:01:16,939
下周 10 日到期，离什么时候开始还有很长的路要走

20
00:01:16,939 --> 00:01:18,979
10 号是星期一星期三，它

21
00:01:18,979 --> 00:01:21,229
甚至还没有结束，所以 12 月 10 日星期二

22
00:01:21,229 --> 00:01:23,869
是最终项目，

23
00:01:23,869 --> 00:01:27,229
并且额外的功劳将到期我们

24
00:01:27,229 --> 00:01:30,020
向您承诺反馈我们发现有人

25
00:01:30,020 --> 00:01:32,030
抄袭所以我们必须首先处理

26
00:01:32,030 --> 00:01:34,189
那个然后我们希望 能够

27
00:01:34,189 --> 00:01:37,159


28
00:01:37,159 --> 00:01:39,229
像第二天左右一样为其他人提供反馈的评论，

29
00:01:39,229 --> 00:01:40,490


30
00:01:40,490 --> 00:01:43,040
所以请为延迟道歉总体上

31
00:01:43,040 --> 00:01:44,299
他们非常好，有些显然比其他人更好，

32
00:01:44,299 --> 00:01:46,820
但反馈将

33
00:01:46,820 --> 00:01:52,700
帮助您完成它是的，所以

34
00:01:52,700 --> 00:01:54,170
你记得如何 当你填写

35
00:01:54,170 --> 00:01:55,729
表格时，你知道点击复选框是的我

36
00:01:55,729 --> 00:01:58,219
同意我不会玩干大他们

37
00:01:58,219 --> 00:01:58,909
仍然剽窃

38
00:01:58,909 --> 00:02:05,750
是的，我

39
00:02:05,750 --> 00:02:07,820
去与普罗沃斯交谈的地方至少为零那是另一个

40
00:02:07,820 --> 00:02:08,300
故事

41
00:02:08,300 --> 00:02:12,020
是的，西玛在他们身边做的

42
00:02:12,020 --> 00:02:13,820
认真对待这一点，事实上，我让

43
00:02:13,820 --> 00:02:15,500
你检查点击那个复选框，它

44
00:02:15,500 --> 00:02:17,209
在视频上说我说不要

45
00:02:17,209 --> 00:02:19,099
剽窃你没有任何证据

46
00:02:19,099 --> 00:02:20,390
如果

47
00:02:20,390 --> 00:02:22,310
你不明白是谁做的，

48
00:02:22,310 --> 00:02:24,400
是的

49
00:02:24,400 --> 00:02:28,070
，然后期末考试到期

50
00:02:28,070 --> 00:02:30,140
12 月的一个星期一，而不是在你

51
00:02:30,140 --> 00:02:31,820
回到 X 学分之后，这就是为什么我们拥有它

52
00:02:31,820 --> 00:02:33,380
就像一个 wiki 手写笔，我们有修改，所以

53
00:02:33,380 --> 00:02:34,790
这个人可以回去尝试

54
00:02:34,790 --> 00:02:38,420
删除抄袭的电子文本，但

55
00:02:38,420 --> 00:02:39,770
它仍然在戴维斯，我们可以去看看

56
00:02:39,770 --> 00:02:41,930
不管怎样，我总是去看看它，而不是你，

57
00:02:41,930 --> 00:02:44,180
但总的来说，期末考试是

58
00:02:44,180 --> 00:02:48,440
在星期一下午 5:30。 在

59
00:02:48,440 --> 00:02:50,570
我认为在旧

60
00:02:50,570 --> 00:02:54,110
商学院的 posner 大厅里，是的，所以我们

61
00:02:54,110 --> 00:02:55,850
将首先

62
00:02:55,850 --> 00:02:57,500
讨论这个问题，所以关于额外学分或项目的任何问题

63
00:02:57,500 --> 00:03:01,550
，然后是家庭作业 5 我们将在周五之前对其

64
00:03:01,550 --> 00:03:04,130
进行评分和发布

65
00:03:04,130 --> 00:03:05,780
我想他是昨天到期的，

66
00:03:05,780 --> 00:03:07,850
在那之后的四天，除非每个人都

67
00:03:07,850 --> 00:03:09,290
已经交了，否则我们会把它寄出去，

68
00:03:09,290 --> 00:03:12,890


69
00:03:12,890 --> 00:03:15,980
好吧，期末考试好吧，所以你必须

70
00:03:15,980 --> 00:03:18,950
要，呃，或者你不必，但你

71
00:03:18,950 --> 00:03:21,709
应该这样做 还不是鲍勃，但我

72
00:03:21,709 --> 00:03:24,350
会在课后发布这基本上

73
00:03:24,350 --> 00:03:26,030
是我谈论过的所有内容的摘要

74
00:03:26,030 --> 00:03:27,950


75
00:03:27,950 --> 00:03:29,900


76
00:03:29,900 --> 00:03:30,890


77
00:03:30,890 --> 00:03:32,060


78
00:03:32,060 --> 00:03:33,980


79
00:03:33,980 --> 00:03:36,380
下午 5:30 波斯纳大厅 100 不要

80
00:03:36,380 --> 00:03:37,700
来这个房间，然后如果你

81
00:03:37,700 --> 00:03:39,530
好奇为什么

82
00:03:39,530 --> 00:03:40,910
除了想通过课程之外还应该带这个，你可以

83
00:03:40,910 --> 00:03:43,940
看那个视频，所以

84
00:03:43,940 --> 00:03:46,040
你需要带什么你应该带上你的

85
00:03:46,040 --> 00:03:48,080
CMU ID 因为它是 Class  95 人

86
00:03:48,080 --> 00:03:49,459
或 96 人 我不认识 我认识

87
00:03:49,459 --> 00:03:52,250
每个人 所以我需要

88
00:03:52,250 --> 00:03:54,170
像期中考试一样检查你的身份证 这是一页

89
00:03:54,170 --> 00:03:56,690
手写笔记 双面 没有

90
00:03:56,690 --> 00:03:58,550
缩小幻灯片 没有复制和

91
00:03:58,550 --> 00:04:00,380
粘贴攻击，如果你手写的话

92
00:04:00,380 --> 00:04:02,600
在你的 iPad 上不会打印，这

93
00:04:02,600 --> 00:04:05,360
没关系，但同样只是

94
00:04:05,360 --> 00:04:08,269
从文字处理器中知道文本文本，然后如果

95
00:04:08,269 --> 00:04:10,370
你在周一晚上上课，

96
00:04:10,370 --> 00:04:12,850
带上你的额外信用券

97
00:04:12,850 --> 00:04:15,140
，你必须在你当你的时候把它交出来

98
00:04:15,140 --> 00:04:18,019
交上你的考试，所以

99
00:04:18,019 --> 00:04:19,250
如果你想在

100
00:04:19,250 --> 00:04:20,690


101
00:04:20,690 --> 00:04:22,040
两年前有人做过

102
00:04:22,040 --> 00:04:24,979
的中途换衣服，那这件事是你可选的

103
00:04:24,979 --> 00:04:26,720


104
00:04:26,720 --> 00:04:27,979
我会努力做一些

105
00:04:27,979 --> 00:04:29,720
比那更好的事 你不知道我

106
00:04:29,720 --> 00:04:31,039
不能保证任何正确的事情

107
00:04:31,039 --> 00:04:32,210


108
00:04:32,210 --> 00:04:34,310
考试前不会是一顿完整的四道菜餐

109
00:04:34,310 --> 00:04:36,440
什么不能带我想我们

110
00:04:36,440 --> 00:04:37,520
在期中讨论了所有问题

111
00:04:37,520 --> 00:04:39,140
每个人都带来了奇怪的东西

112
00:04:39,140 --> 00:04:41,570
前几年 两年前 再次所以

113
00:04:41,570 --> 00:04:43,550
当你带室友

114
00:04:43,550 --> 00:04:47,210
出去玩的时候

115
00:04:47,210 --> 00:04:49,460
在我们进入考试的课程

116
00:04:49,460 --> 00:04:50,950
材料之前

117
00:04:50,950 --> 00:04:54,340


118
00:04:54,670 --> 00:04:57,320
不要这样做好吧 那么

119
00:04:57,320 --> 00:04:59,300
是的，我做了任何事情是的，嘿

120
00:04:59,300 --> 00:05:01,370
，波特霍尔在哪里哦，那

121
00:05:01,370 --> 00:05:03,470
是那边的那个是的，如果不是盖茨，我

122
00:05:03,470 --> 00:05:04,700
不知道它在哪里我会

123
00:05:04,700 --> 00:05:08,510
说实话，这是我的第七年，

124
00:05:08,510 --> 00:05:13,040
好吧，所以播音员一些 广场也

125
00:05:13,040 --> 00:05:15,410
一样 我需要每个人都填写

126
00:05:15,410 --> 00:05:17,390
课程评估 我不在乎

127
00:05:17,390 --> 00:05:18,980
你是说我是一个糟糕的人 我

128
00:05:18,980 --> 00:05:20,510
不卫生还是你讨厌

129
00:05:20,510 --> 00:05:23,870
对我有用的课程 我你知道我

130
00:05:23,870 --> 00:05:25,790
真的读过这些东西所以

131
00:05:25,790 --> 00:05:26,750
我在从或我那里得到反馈时提到的事情

132
00:05:26,750 --> 00:05:29,180
ike 是

133
00:05:29,180 --> 00:05:30,440
你认为不必要

134
00:05:30,440 --> 00:05:32,870
或愚蠢的特殊标记分配

135
00:05:32,870 --> 00:05:35,150
你已经看到我宣布

136
00:05:35,150 --> 00:05:35,960
Piazza 我们正在寻找人

137
00:05:35,960 --> 00:05:39,110
帮助进一步扩大 bust hub 你知道

138
00:05:39,110 --> 00:05:40,430
修复所有的事情，也许

139
00:05:40,430 --> 00:05:42,650
这学期出错了 但是，如果

140
00:05:42,650 --> 00:05:43,670
您认为该项目的某些内容

141
00:05:43,670 --> 00:05:45,110
太难了，则节奏不

142
00:05:45,110 --> 00:05:46,940
正确，您需要更多文档，减少

143
00:05:46,940 --> 00:05:48,230
文档，这太容易了，

144
00:05:48,230 --> 00:05:50,150
太难了，反馈实际上

145
00:05:50,150 --> 00:05:52,460
对我非常有用，所以

146
00:05:52,460 --> 00:05:55,370
本科生在填写方面很棒

147
00:05:55,370 --> 00:05:57,110
课程评估，比如如果你很臭，

148
00:05:57,110 --> 00:05:59,180
他们会告诉你硕士生，

149
00:05:59,180 --> 00:06:00,740
你们这些家伙

150
00:06:00,740 --> 00:06:02,450
在所有事情上点击五五五五他是伟大的

151
00:06:02,450 --> 00:06:04,130
教授我不想要任何

152
00:06:04,130 --> 00:06:06,560
正确的就像我实际上读过这所

153
00:06:06,560 --> 00:06:07,880
大学一样 读给我听 我

154
00:06:07,880 --> 00:06:09,560
不关心他们 但我实际上

155
00:06:09,560 --> 00:06:10,760
根据你的反馈使课程更好

156
00:06:10,760 --> 00:06:12,920
一年一个孩子

157
00:06:12,920 --> 00:06:14,630
用 Myer Bri 对我进行心理分析 ggs 测试

158
00:06:14,630 --> 00:06:18,200
中的反馈很有用，所以再次

159
00:06:18,200 --> 00:06:19,820
请转到单元格，我会

160
00:06:19,820 --> 00:06:22,910
在 Piazza 上发送提醒，所以我

161
00:06:22,910 --> 00:06:25,190
周一没有办公时间，但我将在

162
00:06:25,190 --> 00:06:26,720


163
00:06:26,720 --> 00:06:29,540
本周五 3 点有额外的办公时间 :30 在我的办公室，

164
00:06:29,540 --> 00:06:30,830
然后我会

165
00:06:30,830 --> 00:06:34,460
在考试当天的 1:30 有我的正常办公时间，如果你

166
00:06:34,460 --> 00:06:35,780
不能做到这些并且你

167
00:06:35,780 --> 00:06:37,310
很想和我说话，请给我

168
00:06:37,310 --> 00:06:38,660
发一封电子邮件，我 会尽量做出安排，

169
00:06:38,660 --> 00:06:40,790
我可能不得不通过 Skype 或环聊来做这

170
00:06:40,790 --> 00:06:43,310


171
00:06:43,310 --> 00:06:46,400
件事，因为婴儿和所有 TAS

172
00:06:46,400 --> 00:06:47,180
的正常

173
00:06:47,180 --> 00:06:48,949
办公时间将一直持续到

174
00:06:48,949 --> 00:06:52,009
12 月 14 日（包括 9 月 14 日），因此项目的截止

175
00:06:52,009 --> 00:06:54,979
日期 因为是在 10 号，他们

176
00:06:54,979 --> 00:06:56,840
会迟到，所以它会

177
00:06:56,840 --> 00:07:00,440
在 14 号结束

178
00:07:00,440 --> 00:07:04,250


179
00:07:04,250 --> 00:07:05,660


180
00:07:05,660 --> 00:07:08,570


181
00:07:08,570 --> 00:07:10,039
不是累积的意思，就像我

182
00:07:10,039 --> 00:07:11,300
不会问你

183
00:07:11,300 --> 00:07:13,340
关于喜欢的问题 缓冲池，你

184
00:07:13,340 --> 00:07:14,840
知道这个驱逐策略是如何工作的，

185
00:07:14,840 --> 00:07:16,910
但你显然不知道你知道

186
00:07:16,910 --> 00:07:18,680
它是我们通过完整堆栈覆盖的数据库系统的一部分

187
00:07:18,680 --> 00:07:20,000
你

188
00:07:20,000 --> 00:07:21,229
需要知道所有这些不同的部分是如何

189
00:07:21,229 --> 00:07:23,599
协同工作的 您

190
00:07:23,599 --> 00:07:24,910
必须从

191
00:07:24,910 --> 00:07:27,410
之前的术语中了解缓冲区

192
00:07:27,410 --> 00:07:28,699
管理哈希表 B 加上树

193
00:07:28,699 --> 00:07:31,070
短模型，然后输入一个查询

194
00:07:31,070 --> 00:07:32,960
并行性，它再次同时运行

195
00:07:32,960 --> 00:07:34,370
多个查询，而

196
00:07:34,370 --> 00:07:35,479
您显然不知道这是怎么回事 有效

197
00:07:35,479 --> 00:07:37,220
是因为你必须做交易 我

198
00:07:37,220 --> 00:07:38,240
可以同时更新数据库

199
00:07:38,240 --> 00:07:41,210
好吧，所以很明显我们不会

200
00:07:41,210 --> 00:07:43,070
像在期中之前的早期作业中那样问你单独的问题，

201
00:07:43,070 --> 00:07:44,419


202
00:07:44,419 --> 00:07:45,979
但这是背景知识，

203
00:07:45,979 --> 00:07:47,479
你只有你知道

204
00:07:47,479 --> 00:07:51,409
已经忘记了，您还有其他问题，好吧，

205
00:07:51,409 --> 00:07:52,820
所以我们花时间讨论的主要

206
00:07:52,820 --> 00:07:54,500
内容是正确的交易，

207
00:07:54,500 --> 00:07:56,449
您应该了解

208
00:07:56,449 --> 00:07:59,389
酸的基本概念是什么 首字母缩略词

209
00:07:59,389 --> 00:08:01,310
中组合的不同属性

210
00:08:01,310 --> 00:08:02,900
以及数据的含义

211
00:08:02,900 --> 00:08:05,900
应该提供什么然后我们做了一个我们

212
00:08:05,900 --> 00:08:06,680
讨论了冲突之间的区别

213
00:08:06,680 --> 00:08:08,389
他们的生活是和查看

214
00:08:08,389 --> 00:08:10,010
眼睛类型的能力你已消毒的

215
00:08:10,010 --> 00:08:11,479
能力实际上没有人可以这样做所以

216
00:08:11,479 --> 00:08:12,740
没有办法 实际检查

217
00:08:12,740 --> 00:08:14,840
这只是一个更高级别的概念，但对于

218
00:08:14,840 --> 00:08:16,370
冲突他们的生活能力，您

219
00:08:16,370 --> 00:08:18,110
想知道如何检查这一点以及

220
00:08:18,110 --> 00:08:19,880
数据系统如何确保它

221
00:08:19,880 --> 00:08:23,090
为您生成一个时间表，您知道这

222
00:08:23,090 --> 00:08:27,050
保证我们冲突可序列

223
00:08:27,050 --> 00:08:28,340
化意味着拥有一个 可恢复的调度

224
00:08:28,340 --> 00:08:29,840
权 惊人的基本上意味着没有

225
00:08:29,840 --> 00:08:32,570
级联中止，然后隔离

226
00:08:32,570 --> 00:08:34,760
级别和异常写脏

227
00:08:34,760 --> 00:08:39,880
读可重复读取和幻象

228
00:08:41,659 --> 00:08:44,870
然后我们谈论并发协议

229
00:08:44,870 --> 00:08:46,910
来实际

230
00:08:46,910 --> 00:08:50,450
为冲突的任意事务实时生成调度

231
00:08:50,450 --> 00:08:52,430
是可靠的，所以我们花了一个

232
00:08:52,430 --> 00:08:54,080
整体 课程中谈论

233
00:08:54,080 --> 00:08:55,940
锁定的两件事表明您知道基本

234
00:08:55,940 --> 00:08:57,530
协议是什么，但是

235
00:08:57,530 --> 00:08:59,320
非严格和严格的区别是

236
00:08:59,320 --> 00:09:01,640
什么区别 严格的

237
00:09:01,640 --> 00:09:08,080
两阶段锁定在后面是什么意思 是的，

238
00:09:08,080 --> 00:09:10,970
谢谢马特 是的 严格是你

239
00:09:10,970 --> 00:09:12,080
最后释放了所有的锁

240
00:09:12,080 --> 00:09:14,690


241
00:09:14,690 --> 00:09:15,080


242
00:09:15,080 --> 00:09:16,610
当你释放一个块然后

243
00:09:16,610 --> 00:09:17,600
你现在处于收缩阶段并且

244
00:09:17,600 --> 00:09:20,960
你不能获得任何新的锁然后我们

245
00:09:20,960 --> 00:09:22,540
讨论了多个花岗岩多个

246
00:09:22,540 --> 00:09:25,730
主要是锁定的粒度和

247
00:09:25,730 --> 00:09:26,780
最重要的事情是意图

248
00:09:26,780 --> 00:09:30,620
框正确我如何通知或 我如何在较高级别的锁层次结构的较低级别

249
00:09:30,620 --> 00:09:32,870
发布有关我将要做什么的信息，

250
00:09:32,870 --> 00:09:34,280


251
00:09:34,280 --> 00:09:36,350
这样我就

252
00:09:36,350 --> 00:09:37,750
不必在所有事情上都

253
00:09:37,750 --> 00:09:40,220
正确锁定，如果我想走就必须锁定

254
00:09:40,220 --> 00:09:42,260
并以十亿涡轮增压更新十亿个元组

255
00:09:42,260 --> 00:09:44,960
和我的表我

256
00:09:44,960 --> 00:09:46,460
最好只在表上加一个锁，

257
00:09:46,460 --> 00:09:48,530
而不是锁定每个

258
00:09:48,530 --> 00:09:51,170
单独的元组，然后重要的是要

259
00:09:51,170 --> 00:09:53,720
知道如何释放这些锁，例如

260
00:09:53,720 --> 00:09:57,280
它的顺序是什么 自己或自下而上

261
00:09:57,280 --> 00:09:59,630
然后我们花了一个讲座来讨论

262
00:09:59,630 --> 00:10:00,760
时间戳顺序和并发控制

263
00:10:00,760 --> 00:10:03,110
好吧所以你知道

264
00:10:03,110 --> 00:10:04,640
托马斯赖特规则是我们讨论的协议基础

265
00:10:04,640 --> 00:10:06,590
然后我们花时间

266
00:10:06,590 --> 00:10:08,000
谈论我的乐观国家收费

267
00:10:08,000 --> 00:10:10,040
什么是三个阶段 读取阶段

268
00:10:10,040 --> 00:10:12,740
验证阶段和写入阶段

269
00:10:12,740 --> 00:10:14,210
我们何时在基本时间戳中实际获取

270
00:10:14,210 --> 00:10:16,330
这些不同协议

271
00:10:16,330 --> 00:10:18,500
中的

272
00:10:18,500 --> 00:10:22,640


273
00:10:22,640 --> 00:10:25,040
事务

274
00:10:25,040 --> 00:10:29,420


275
00:10:29,420 --> 00:10:30,680
时间戳 当你完成

276
00:10:30,680 --> 00:10:32,840
写读阶段然后我们谈论

277
00:10:32,840 --> 00:10:34,730
多版本并发收费我不会再

278
00:10:34,730 --> 00:10:37,370


279
00:10:37,370 --> 00:10:39,470
担心你

280
00:10:39,470 --> 00:10:42,140
会在 MVCC 中使用的商业协议，比如你知道

281
00:10:42,140 --> 00:10:45,170
mb 到 PL 或 MV OCC 我 更

282
00:10:45,170 --> 00:10:47,210
关心原始存储和

283
00:10:47,210 --> 00:10:49,190
Delta 记录的排序只做笔

284
00:10:49,190 --> 00:10:50,810
或者你在做时间旅行表

285
00:10:50,810 --> 00:10:52,100
，然后你想怎么做 gar  bage

286
00:10:52,100 --> 00:10:54,400
collection

287
00:10:56,019 --> 00:10:57,829
然后我们一直在谈论

288
00:10:57,829 --> 00:11:06,649
崩溃恢复问题是的，所以

289
00:11:06,649 --> 00:11:09,769
隔离级别再次是，呃，它是

290
00:11:09,769 --> 00:11:11,599
一种最高层，您拥有可

291
00:11:11,599 --> 00:11:13,579
序列化的隔离，然后在

292
00:11:13,579 --> 00:11:15,859
下面您有可重复读取，

293
00:11:15,859 --> 00:11:17,599
您已阅读已提交和低于

294
00:11:17,599 --> 00:11:19,549
您有未提交的读取，因此

295
00:11:19,549 --> 00:11:21,499
基本上当您沿着该层次结构向下时，

296
00:11:21,499 --> 00:11:24,889
数据库系统不会强制执行

297
00:11:24,889 --> 00:11:27,079
或保护您免受不同

298
00:11:27,079 --> 00:11:28,579
实体的

299
00:11:28,579 --> 00:11:30,709
侵害，因此如果您看到可靠的

300
00:11:30,709 --> 00:11:33,199
隔离，那么您就没有您没有的幻影

301
00:11:33,199 --> 00:11:34,339
有脏读并且你没有

302
00:11:34,339 --> 00:11:36,289
不可重复的读但是如果你

303
00:11:36,289 --> 00:11:39,679
去重复读那么你

304
00:11:39,679 --> 00:11:41,509
不会做幻像检查如果你

305
00:11:41,509 --> 00:11:43,729
现在提交你现在不做

306
00:11:43,729 --> 00:11:47,419
你不做可重复

307
00:11:47,419 --> 00:11:50,629
读取然后读取未提交的读取或未提交的读取

308
00:11:50,629 --> 00:11:52,689
是没有保护

309
00:11:52,689 --> 00:11:58,819
是的所以会话实际上不是当

310
00:11:58,819 --> 00:12:00,619
我们爱我们时快照隔离是一种奇怪的隔离

311
00:12:00,619 --> 00:12:06,339
它几乎是一种throg 对于

312
00:12:06,339 --> 00:12:08,569
某些答案，不，如果您参加高级课程，则不在主要层次结构中，

313
00:12:08,569 --> 00:12:10,939


314
00:12:10,939 --> 00:12:12,139
我们将进一步讨论，但

315
00:12:12,139 --> 00:12:14,599
基本上是在 1992 年，

316
00:12:14,599 --> 00:12:16,609
当他们提出这些隔离级别的 ANSI 标准时，

317
00:12:16,609 --> 00:12:19,009


318
00:12:19,009 --> 00:12:20,869
应该仔细检查的人发明了 其他人

319
00:12:20,869 --> 00:12:22,639
没有仔细检查他们是否错过了

320
00:12:22,639 --> 00:12:24,499
快照隔离，所以

321
00:12:24,499 --> 00:12:26,689
我们的员工隔离可能会发生异常，

322
00:12:26,689 --> 00:12:29,899
其他人不会发生这种情况

323
00:12:29,899 --> 00:12:32,419
，但是 ANSI 标准不

324
00:12:32,419 --> 00:12:33,949
支持它，您不必担心。

325
00:12:33,949 --> 00:12:36,229
遵循 ANSI 标准，因此可

326
00:12:36,229 --> 00:12:38,449
序列化重复或读取已

327
00:12:38,449 --> 00:12:40,369
提交的读取未提交的读取已读取

328
00:12:40,369 --> 00:12:42,489
未提交

329
00:12:45,099 --> 00:12:50,059
是的自然隔离它不是一个

330
00:12:50,059 --> 00:12:51,979
直接的层次结构树实际上

331
00:12:51,979 --> 00:12:53,449
要复杂得多但我们将

332
00:12:53,449 --> 00:12:54,619
在高级课程中介绍如果您

333
00:12:54,619 --> 00:12:56,629
采用阿姨的

334
00:12:56,629 --> 00:12:59,479
期末考试没问题 所以我们讨论

335
00:12:59,479 --> 00:13:02,059
了碰撞恢复 我们讨论了

336
00:13:02,059 --> 00:13:03,829
不同的充气孔政策 钢

337
00:13:03,829 --> 00:13:07,959
与无钢 钢是什么意思

338
00:13:10,870 --> 00:13:17,600
是的 她是 有了这个新政策，这

339
00:13:17,600 --> 00:13:19,970
意味着数据说允许

340
00:13:19,970 --> 00:13:22,190


341
00:13:22,190 --> 00:13:23,930


342
00:13:23,930 --> 00:13:26,000
在不窃取的情况下从未提交的事务中将脏记录或脏页写出磁盘，你

343
00:13:26,000 --> 00:13:28,640
不能这样做，也不能强制

344
00:13:28,640 --> 00:13:37,580
除宝琳娜以外的其他人纠正，所以

345
00:13:37,580 --> 00:13:39,230
她说 在事务允许说它已提交之前，您必须写出所有必须

346
00:13:39,230 --> 00:13:41,740
将所有脏记录写入磁盘

347
00:13:41,740 --> 00:13:44,000


348
00:13:44,000 --> 00:13:46,130
，然后在没有

349
00:13:46,130 --> 00:13:47,630
强制力的情况下，您不必这样做，

350
00:13:47,630 --> 00:13:49,760
因此使用预写日志记录是使用

351
00:13:49,760 --> 00:13:54,590
窃取还是不窃取 只是没有

352
00:13:54,590 --> 00:13:56,390
窃取 没有它已经在使用窃取错误的

353
00:13:56,390 --> 00:13:58,610
权利，因为前面的单词

354
00:13:58,610 --> 00:14:00,620
记录我必须确保日志

355
00:14:00,620 --> 00:14:03,020
记录与数据更改相对应，

356
00:14:03,020 --> 00:14:05,300
日志记录的数据页

357
00:14:05,300 --> 00:14:07,010
必须写入磁盘，但

358
00:14:07,010 --> 00:14:08,300
对于我的事务 很多提交，但

359
00:14:08,300 --> 00:14:10,850
我被允许在稍后的某个时间

360
00:14:10,850 --> 00:14:13,250
写出你在事务已经提交后知道的脏记录

361
00:14:13,250 --> 00:14:14,570
，这

362
00:14:14,570 --> 00:14:19,880
意味着我们谈论不同的 loggi 也不是强制的

363
00:14:19,880 --> 00:14:21,530
ng 方案

364
00:14:21,530 --> 00:14:23,780
我关心的主要区别是逻辑

365
00:14:23,780 --> 00:14:26,600
与物理我的物理是

366
00:14:26,600 --> 00:14:29,120
你实际写出

367
00:14:29,120 --> 00:14:31,940
低级位或字节的地方，这些低级位或字节在日志记录中被更改

368
00:14:31,940 --> 00:14:33,140
为数据库系统

369
00:14:33,140 --> 00:14:35,330
，然后是逻辑日志，然后你

370
00:14:35,330 --> 00:14:36,920
只需编写一个高级命令来

371
00:14:36,920 --> 00:14:38,510
进行更改，就像续集查询一样

372
00:14:38,510 --> 00:14:40,130
，因此权衡这些

373
00:14:40,130 --> 00:14:41,780
事情是正确的，所以如果我的查询要

374
00:14:41,780 --> 00:14:44,270
使用逻辑日志记录更新十亿个元组，

375
00:14:44,270 --> 00:14:45,470
我所拥有的就是

376
00:14:45,470 --> 00:14:47,210
更新查询 单个日志记录，

377
00:14:47,210 --> 00:14:49,430
这足以让我记录

378
00:14:49,430 --> 00:14:51,260


379
00:14:51,260 --> 00:14:53,720
在物理日志记录下所做的更改我必须有

380
00:14:53,720 --> 00:14:55,820
十亿个日志记录来对应

381
00:14:55,820 --> 00:14:58,630
我对每个元组所做的所有更改

382
00:14:58,630 --> 00:15:00,590
然后我们讨论了如何检查

383
00:15:00,590 --> 00:15:02,360
点 所以你应该知道模糊

384
00:15:02,360 --> 00:15:04,610


385
00:15:04,610 --> 00:15:07,100
和非模糊之间的区别 右

386
00:15:07,100 --> 00:15:09,290
模糊意味着我可以在检查时将

387
00:15:09,290 --> 00:15:11,480
不一致的数据写入数据库

388
00:15:11,480 --> 00:15:13,490
系统或磁盘

389
00:15:13,490 --> 00:15:15,530
k 点，但我需要知道

390
00:15:15,530 --> 00:15:17,930
当我采取检查点时我的系统

391
00:15:17,930 --> 00:15:19,880
发生了

392
00:15:19,880 --> 00:15:22,970
什么，我可以在恢复后协调哪些

393
00:15:22,970 --> 00:15:24,500
页面可能会或可能不会

394
00:15:24,500 --> 00:15:26,389
在检查点期间写入或可能已被

395
00:15:26,389 --> 00:15:27,500
修改

396
00:15:27,500 --> 00:15:30,620
在非模糊

397
00:15:30,620 --> 00:15:31,490
检查站的情况下，我正在检查检查站，他们基本上

398
00:15:31,490 --> 00:15:33,500
是

399
00:15:33,500 --> 00:15:35,779
在你写下所有内容的同时短暂地停止世界，

400
00:15:35,779 --> 00:15:36,560
这样你就可以保证有一个

401
00:15:36,560 --> 00:15:40,009
一致的检查线，然后我们

402
00:15:40,009 --> 00:15:41,120
谈到了她的新

403
00:15:41,120 --> 00:15:43,060
讲座的区域恢复 什么是三个阶段，

404
00:15:43,060 --> 00:15:45,589
例如分析 重做和撤消

405
00:15:45,589 --> 00:15:47,959
显示您知道

406
00:15:47,959 --> 00:15:49,790
您需要在日志中查看多远的每个

407
00:15:49,790 --> 00:15:52,699
阶段 可能正确 它应该

408
00:15:52,699 --> 00:15:54,740
知道对话日志记录

409
00:15:54,740 --> 00:15:58,639


410
00:15:58,639 --> 00:16:00,889
如果我的日志中有补偿日志记录

411
00:16:00,889 --> 00:16:02,509
并且我应用了它，那么当你正确阅读它们时写它们但是然后

412
00:16:02,509 --> 00:16:04,339
我在你知道

413
00:16:04,339 --> 00:16:06,230
我第二次回来时

414
00:16:06,230 --> 00:16:07,819
完成恢复之前崩溃了我是否需要制作另一个 C  LR 对于

415
00:16:07,819 --> 00:16:12,290
第一个不正确，因为您

416
00:16:12,290 --> 00:16:13,970
已经完成了 CLR 有

417
00:16:13,970 --> 00:16:15,709
信息告诉您如何撤消

418
00:16:15,709 --> 00:16:21,800
原始更新，然后我们

419
00:16:21,800 --> 00:16:22,880
简要讨论了分布式

420
00:16:22,880 --> 00:16:26,389
数据库，您知道我们

421
00:16:26,389 --> 00:16:29,209
显然不能深入了解 这超出

422
00:16:29,209 --> 00:16:30,740
了作业 5 所涵盖的内容，

423
00:16:30,740 --> 00:16:32,240
因此您知道我们讨论的不同

424
00:16:32,240 --> 00:16:33,410
系统架构

425
00:16:33,410 --> 00:16:35,420
共享所有内容 共享磁盘 共享

426
00:16:35,420 --> 00:16:37,459
内存 共享任何内容

427
00:16:37,459 --> 00:16:39,529


428
00:16:39,529 --> 00:16:41,839


429
00:16:41,839 --> 00:16:43,100
实际上要进行复制，

430
00:16:43,100 --> 00:16:44,120
在船上的这些不同环境中，

431
00:16:44,120 --> 00:16:46,069
我们如何

432
00:16:46,069 --> 00:16:48,110
确保数据库系统具有

433
00:16:48,110 --> 00:16:49,250
容错性如何确保数据库

434
00:16:49,250 --> 00:16:50,630
系统在我们进行更新时

435
00:16:50,630 --> 00:16:52,850
在所有数据副本中保持一致

436
00:16:52,850 --> 00:16:56,329
如何 我们再次进行分区

437
00:16:56,329 --> 00:16:57,980
您知道的高级事物 我们谈论哈希

438
00:16:57,980 --> 00:16:59,630
分区 它们有什么

439
00:16:59,630 --> 00:17:01,250
好处 如何实际找到您需要的数据

440
00:17:01,250 --> 00:17:05,059
然后两阶段通信 你知道

441
00:17:05,059 --> 00:17:07,400
在什么情况下

442
00:17:07,400 --> 00:17:08,390
你知道在协议的不同阶段你会采取什么步骤

443
00:17:08,390 --> 00:17:10,819
不要担心

444
00:17:10,819 --> 00:17:13,490
Paxos 对于以同性恋为基础的期末考试来说太难了

445
00:17:13,490 --> 00:17:18,530
所以任何关于

446
00:17:18,530 --> 00:17:20,860


447
00:17:20,930 --> 00:17:22,670
火的问题我都忘记了

448
00:17:22,670 --> 00:17:24,319
如果您在交卷时参加期末考试

449
00:17:24,319 --> 00:17:26,329
，请提前宣布这一点 我会给您一张

450
00:17:26,329 --> 00:17:28,220
胸围贴纸，您可以贴在您的

451
00:17:28,220 --> 00:17:31,240
笔记本电脑上 好吧，我们有足够的人

452
00:17:31,240 --> 00:17:37,190


453
00:17:37,190 --> 00:17:39,500


454
00:17:39,500 --> 00:17:41,960
作为期中考试，但你有三个小时，

455
00:17:41,960 --> 00:17:43,730
而且总有人

456
00:17:43,730 --> 00:17:55,550
要花三个小时

457
00:17:55,550 --> 00:17:56,390


458
00:17:56,390 --> 00:17:58,610


459
00:17:58,610 --> 00:18:01,370


460
00:18:01,370 --> 00:18:04,480
考试 是的，

461
00:18:04,480 --> 00:18:07,940
这将是我自己的选择 是的

462
00:18:07,940 --> 00:18:18,890
，评分更

463
00:18:18,890 --> 00:18:20,030


464
00:18:20,030 --> 00:18:21,290


465
00:18:21,290 --> 00:18:23,030


466
00:18:23,030 --> 00:18:25,010


467
00:18:25,010 --> 00:18:30,410
容易 不想使用一个所以不我认为

468
00:18:30,410 --> 00:18:32,090
你必须成为一个你必须

469
00:18:32,090 --> 00:18:34,429
有点像钢铁没有力量或没有钢铁力量

470
00:18:34,429 --> 00:18:35,480
对我们谈到影子寻呼

471
00:18:35,480 --> 00:18:38,780
影子寻呼是没有钢铁

472
00:18:38,780 --> 00:18:41,030
力量的一个例子因为我不是 允许

473
00:18:41,030 --> 00:18:43,190
从未提交的事务中覆盖脏页，

474
00:18:43,190 --> 00:18:45,710
因为我有这个影子

475
00:18:45,710 --> 00:18:47,150
副本，我正在那里进行所有

476
00:18:47,150 --> 00:18:50,120
更新，

477
00:18:50,120 --> 00:18:52,190
这就是不窃取部分，然后

478
00:18:52,190 --> 00:18:54,140
第四部分是当我的事务

479
00:18:54,140 --> 00:18:56,000
通过影子分页转到 kokum 时 我必须

480
00:18:56,000 --> 00:18:57,440
确保所有那些脏页都

481
00:18:57,440 --> 00:18:59,630
刷新到磁盘，然后我将

482
00:18:59,630 --> 00:19:01,429
指针翻转到根指针，现在你知道

483
00:19:01,429 --> 00:19:04,070
指向旧的新的影子

484
00:19:04,070 --> 00:19:05,960
成为新的主，当我这样做时，我

485
00:19:05,960 --> 00:19:06,710
确保我必须做 确保

486
00:19:06,710 --> 00:19:08,840
一切都已经刷新，所以

487
00:19:08,840 --> 00:19:11,179
再次写入日志是钢铁无力

488
00:19:11,179 --> 00:19:14,080
阴影分页是无钢铁力

489
00:19:14,080 --> 00:19:18,500
然后主要的收获

490
00:19:18,500 --> 00:19:21,650
是红头记录它几乎

491
00:19:21,650 --> 00:19:24,590
总是我想不出也许有些情况

492
00:19:24,590 --> 00:19:25,820
我没有' 想 它几乎

493
00:19:25,820 --> 00:19:28,760
总是更好，这是每个系统

494
00:19:28,760 --> 00:19:32,830
使用大多数系统的

495
00:19:34,470 --> 00:19:41,830
任何其他问题是的，所以这个

496
00:19:41,830 --> 00:19:43,330
问题与期中考试不同，我不需要计算器吗

497
00:19:43,330 --> 00:19:44,020


498
00:19:44,020 --> 00:19:46,690
我忘了强调，是的，

499
00:19:46,690 --> 00:19:48,610
你不需要，我可以 想想

500
00:19:48,610 --> 00:19:49,960
我们在家庭作业中做了什么我们没有

501
00:19:49,960 --> 00:19:54,790
估计连接我们没有是的我不

502
00:19:54,790 --> 00:19:59,020
认为它像它现场是我们

503
00:19:59,020 --> 00:20:00,340
没有关于查询优化之类的

504
00:20:00,340 --> 00:20:02,440
东西的问题，这是我唯一能想到

505
00:20:02,440 --> 00:20:04,870
的可能需要一个 计算器对说不要

506
00:20:04,870 --> 00:20:09,429
担心你知道问题

507
00:20:09,429 --> 00:20:19,780
是像两相锁定的东西还是

508
00:20:19,780 --> 00:20:25,030
关于层次结构是的先生所以她的

509
00:20:25,030 --> 00:20:26,230
问题是有更多

510
00:20:26,230 --> 00:20:28,750
关于多粒度粒度

511
00:20:28,750 --> 00:20:33,309
锁定的问题所以在教科书

512
00:20:33,309 --> 00:20:36,040
中很奇怪 问题 解决方案

513
00:20:36,040 --> 00:20:38,080
在线 我没有看过 我没有

514
00:20:38,080 --> 00:20:39,070
看过较新的版本 但就像

515
00:20:39,070 --> 00:20:40,179
可能有一些问题

516
00:20:40,179 --> 00:20:41,710
你可以看看 然后我们做一些奇怪

517
00:20:41,710 --> 00:20:44,110
的 然后你像 DB 链接一样去数据库

518
00:20:44,110 --> 00:20:45,700
在网上课程 w  ebsites

519
00:20:45,700 --> 00:20:47,679
是 DB book 冷静他们会有

520
00:20:47,679 --> 00:20:49,120
我们问题的解决方案你可以

521
00:20:49,120 --> 00:20:53,080
按照那些我会在

522
00:20:53,080 --> 00:20:58,150
最终审查网页上放一个链接是的特别是

523
00:20:58,150 --> 00:21:01,740
你能不能带上期中笔记一个便宜的

524
00:21:01,740 --> 00:21:07,200
一份便宜的副本无论你需要什么都可以

525
00:21:12,000 --> 00:21:15,970
好吧，这是我的，这是

526
00:21:15,970 --> 00:21:17,260
我最喜欢的，最喜欢的讲座之一，

527
00:21:17,260 --> 00:21:19,720
他们都很好，但是因为

528
00:21:19,720 --> 00:21:21,130
他谈到了更多的数据库，好吧，

529
00:21:21,130 --> 00:21:23,440
所以我再次要求班上的每个人

530
00:21:23,440 --> 00:21:25,780
对他们最感兴趣的系统进行投票

531
00:21:25,780 --> 00:21:27,730
了解 所以这

532
00:21:27,730 --> 00:21:30,250
是去年排名前 10 的

533
00:21:30,250 --> 00:21:33,160
蟑螂电视扳手和漫画 DVD 的统计数据，

534
00:21:33,160 --> 00:21:34,830
这是我们今年的结果

535
00:21:34,830 --> 00:21:37,450
，这是非常令人惊讶的水肺

536
00:21:37,450 --> 00:21:39,610
首先出现，然后是漫画像蟑螂一样战斗

537
00:21:39,610 --> 00:21:42,610
，令人惊讶的是，这是我

538
00:21:42,610 --> 00:21:44,860
认为的第五 或者像这样小狗一样的六年级教学

539
00:21:44,860 --> 00:21:45,669


540
00:21:45,669 --> 00:21:47,429
扳手总是排在前

541
00:21:47,429 --> 00:21:50,529
三名所以我唯一能

542
00:21:50,529 --> 00:21:51,909
想到的人为什么人们不

543
00:21:51,909 --> 00:21:53,440
投票给这个人那么多是因为

544
00:21:53,440 --> 00:21:56,349
名字变了一个clou  d 扳手是对的

545
00:21:56,349 --> 00:21:57,639
，也许人们不认为这是

546
00:21:57,639 --> 00:21:59,499
同一件事，所以没关系，

547
00:21:59,499 --> 00:22:01,179
但水肺是一个非常有趣的系统，

548
00:22:01,179 --> 00:22:03,719
所以我们将首先开始它，好吧，

549
00:22:03,719 --> 00:22:07,209
现在 Facebook 的古巴，所以我

550
00:22:07,209 --> 00:22:08,320
也注意到人们投票支持

551
00:22:08,320 --> 00:22:09,609
一个或有，如果

552
00:22:09,609 --> 00:22:11,139
在它前面有一个公司的名字，比如亚马逊

553
00:22:11,139 --> 00:22:13,179
极光百度海洋基地，那么人们会

554
00:22:13,179 --> 00:22:17,289
更多地投票给这些东西，所以

555
00:22:17,289 --> 00:22:18,339
好吧 Facebook 的 Qi

556
00:22:18,339 --> 00:22:22,269
所以你知道

557
00:22:22,269 --> 00:22:24,099
我们在做什么 system potpourri 是为了

558
00:22:24,099 --> 00:22:26,469
向您展示我们现在可以查看现实

559
00:22:26,469 --> 00:22:29,589
世界的系统并开始使用

560
00:22:29,589 --> 00:22:31,149
我们

561
00:22:31,149 --> 00:22:33,279
整个学期讨论过的白话来

562
00:22:33,279 --> 00:22:34,599
开始了解这件事

563
00:22:34,599 --> 00:22:37,450
实际上在做什么，所以现在我可以这样

564
00:22:37,450 --> 00:22:38,679
说 事情出去分享什么都不

565
00:22:38,679 --> 00:22:39,849
拍系统，你知道这

566
00:22:39,849 --> 00:22:41,349
意味着什么你知道这意味着什么

567
00:22:41,349 --> 00:22:43,179


568
00:22:43,179 --> 00:22:44,349


569
00:22:44,349 --> 00:22:47,409
你知道你在这样的系统中会遇到什么性能特征性能挑战所以

570
00:22:47,409 --> 00:22:49,389
水肺是一个内部

571
00:22:49,389 --> 00:22:50,940
Facebook 多年未开发的数据库系统

572
00:22:50,940 --> 00:22:53,320


573
00:22:53,320 --> 00:22:56,619
于 2013 年在 vldb 中首次发布，他们

574
00:22:56,619 --> 00:22:58,089
仍在开发中，它不是

575
00:22:58,089 --> 00:23:01,059
开源的，只是直到

576
00:23:01,059 --> 00:23:03,249
最近才有一些

577
00:23:03,249 --> 00:23:04,959
关于更新的公开信息 版本，

578
00:23:04,959 --> 00:23:06,429
实际上是

579
00:23:06,429 --> 00:23:07,979
因为真正领导这个项目的人是

580
00:23:07,979 --> 00:23:10,690
CMU 数据库明矾，就像他

581
00:23:10,690 --> 00:23:12,459
在我出现之前在这里获得博士学位一样，他现在

582
00:23:12,459 --> 00:23:15,279
正在运行

583
00:23:15,279 --> 00:23:17,229
整个数据系统的开发，

584
00:23:17,229 --> 00:23:21,190
然后他的老板实际上是 他的老板

585
00:23:21,190 --> 00:23:23,950
是系里另一位计算机科学系学生的母亲，

586
00:23:23,950 --> 00:23:26,409
他实际上

587
00:23:26,409 --> 00:23:28,899
在整个夏天都在研究胸围表

588
00:23:28,899 --> 00:23:30,489


589
00:23:30,489 --> 00:23:34,179


590
00:23:34,179 --> 00:23:35,919


591
00:23:35,919 --> 00:23:38,679
查询和摄取

592
00:23:38,679 --> 00:23:40,479
从 Facebook 的不同服务生成的内部指标数据

593
00:23:40,479 --> 00:23:42,729


594
00:23:42,729 --> 00:23:44,320
没问题，所以这不是对应用程序的颂歌

595
00:23:44,320 --> 00:23:47,259
这不是在运行它不是一个好 ient

596
00:23:47,259 --> 00:23:49,089
仓库就像

597
00:23:49,089 --> 00:23:50,649
你每次在网站上点击 Facebook 上的某些东西一样，

598
00:23:50,649 --> 00:23:53,019
这会导致

599
00:23:53,019 --> 00:23:54,759
一堆函数在服务器上投票

600
00:23:54,759 --> 00:23:57,249
，你可以让他们的

601
00:23:57,249 --> 00:23:58,779
开发人员检测这些函数

602
00:23:58,779 --> 00:23:59,440
调用，

603
00:23:59,440 --> 00:24:01,500
以正确跟踪性能

604
00:24:01,500 --> 00:24:04,000
指标 在整个堆栈中，

605
00:24:04,000 --> 00:24:05,529
然后所有这些数据然后被推

606
00:24:05,529 --> 00:24:08,169
到 scuba 中，现在他们可以使用它，然后

607
00:24:08,169 --> 00:24:09,730
对该数据运行查询以试图

608
00:24:09,730 --> 00:24:10,960
弄清楚为什么这个

609
00:24:10,960 --> 00:24:12,970
函数会让你知道它运行得更慢有

610
00:24:12,970 --> 00:24:14,830
什么问题我' 我看到了我的

611
00:24:14,830 --> 00:24:18,399
庞大舰队 所以新版本的

612
00:24:18,399 --> 00:24:21,669
scuba 现在是一个列存储 它是一个

613
00:24:21,669 --> 00:24:23,409
分布式无共享系统 它

614
00:24:23,409 --> 00:24:25,049
使用分层存储只是意味着

615
00:24:25,049 --> 00:24:27,820
这只是意味着就像你可以拥有一个

616
00:24:27,820 --> 00:24:30,220
你知道你可以拥有一个内存缓存

617
00:24:30,220 --> 00:24:32,440
闪存缓存，然后可能是更慢的

618
00:24:32,440 --> 00:24:35,710
磁盘，然后它会

619
00:24:35,710 --> 00:24:37,720
使用异构分层分布式

620
00:24:37,720 --> 00:24:39,460
架构，所以一个

621
00:24:39,460 --> 00:24:41,259
关于系统的有趣之处在于，因为

622
00:24:41,259 --> 00:24:42,549
他们试图让这件事变得

623
00:24:42,549 --> 00:24:44,559
非常快，但你想

624
00:24:44,559 --> 00:24:46,240
在大量数据上非常快速地运行你的查询

625
00:24:46,240 --> 00:24:48,250
他们支持

626
00:24:48,250 --> 00:24:49,720
续集的数据不多 他们不支持

627
00:24:49,720 --> 00:24:51,820
连接 我不支持全局

628
00:24:51,820 --> 00:24:53,980
排序 所以你只能编写

629
00:24:53,980 --> 00:24:55,570
访问单个表的查询，并且你

630
00:24:55,570 --> 00:24:58,899
有一个 where 子句，你知道吗

631
00:24:58,899 --> 00:25:00,490
简单过滤 然后你可以

632
00:25:00,490 --> 00:25:02,799
聚合聚合 另一个

633
00:25:02,799 --> 00:25:04,000
有趣的关于它

634
00:25:04,000 --> 00:25:04,840
的事情将与我们之前讨论的所有内容不同

635
00:25:04,840 --> 00:25:07,360
，它们将

636
00:25:07,360 --> 00:25:09,549
必须进行复制才能部署或完成

637
00:25:09,549 --> 00:25:11,399
整个 Scooba 集群的部署，

638
00:25:11,399 --> 00:25:13,690
因此您会认为自己有

639
00:25:13,690 --> 00:25:15,399
一堆机器，我将所有数据发送到

640
00:25:15,399 --> 00:25:17,110
这个集群，但我也

641
00:25:17,110 --> 00:25:18,190
将把它发送到其他

642
00:25:18,190 --> 00:25:19,509
运行 在不同的数据中心或

643
00:25:19,509 --> 00:25:21,429
不同的地区，但他们会

644
00:25:21,429 --> 00:25:24,610
在这种环境中允许有损容错，

645
00:25:24,610 --> 00:25:26,559
因为

646
00:25:26,559 --> 00:25:28,840
他们收集的有价值的数据

647
00:25:28,840 --> 00:25:31,600
不会像银行账户一样无价

648
00:25:31,600 --> 00:25:33,460
比如说你知道你会

649
00:25:33,460 --> 00:25:34,720
在 Facebook 上点击一些东西，

650
00:25:34,720 --> 00:25:36,460


651
00:25:36,460 --> 00:25:38,710
如果这些数据丢失，它会生成一堆性能指标数据

652
00:25:38,710 --> 00:25:41,559
是的，这并不是世界末日，

653
00:25:41,559 --> 00:25:42,669
你知道实际上我想

654
00:25:42,669 --> 00:25:44,950
失去一切，但他们 '是允许

655
00:25:44,950 --> 00:25:46,899
他们将容忍查询结束一个

656
00:25:46,899 --> 00:25:49,269
你知道可能有误报

657
00:25:49,269 --> 00:25:50,080
误报因为他们最终会

658
00:25:50,080 --> 00:25:51,490
丢失数据并最终

659
00:25:51,490 --> 00:25:53,710
再次丢失所以他们

660
00:25:53,710 --> 00:25:55,480
将尝试避免这种情况的方式是 要运行

661
00:25:55,480 --> 00:25:57,039
多个点，他们将同时在

662
00:25:57,039 --> 00:25:59,049
不同区域运行查询，

663
00:25:59,049 --> 00:26:00,490
然后当他们返回结果时，他们会

664
00:26:00,490 --> 00:26:04,149
看到实际读取的查询

665
00:26:04,149 --> 00:26:05,769
数量越少

666
00:26:05,769 --> 00:26:08,590
，缺失数据的数量越少，然后他们将其

667
00:26:08,590 --> 00:26:10,720
用作 CREP 结果，但如果他们丢失了一些

668
00:26:10,720 --> 00:26:11,889
数据，这没什么大不了的

669
00:26:11,889 --> 00:26:12,759
，实际上他们会有

670
00:26:12,759 --> 00:26:13,270


671
00:26:13,270 --> 00:26:15,010
保留政策，在您知道 7 天后，您可以说

672
00:26:15,010 --> 00:26:17,230
存储在此表中的任何数据

673
00:26:17,230 --> 00:26:20,050
都被扔掉了，

674
00:26:20,050 --> 00:26:24,700
谁在乎呢 所以这里

675
00:26:24,700 --> 00:26:26,920
是他们试图做的事情的高级管道

676
00:26:26,920 --> 00:26:28,480
所以你有你不同的

677
00:26:28,480 --> 00:26:29,710
应用程序服务器，这些都

678
00:26:29,710 --> 00:26:33,160
在运行你知道运行

679
00:26:33,160 --> 00:26:34,720
网站运行

680
00:26:34,720 --> 00:26:36,640
你需要支持网站的所有后端东西所以 这些

681
00:26:36,640 --> 00:26:39,310
人可以生成结构调试

682
00:26:39,310 --> 00:26:40,960
日志，所以把它想象成一个 JSON

683
00:26:40,960 --> 00:26:43,060
文档，应用程序服务器

684
00:26:43,060 --> 00:26:44,800
吐出来说你知道这是

685
00:26:44,800 --> 00:26:46,150
我在 CPU 中花费了多少时间

686
00:26:46,150 --> 00:26:48,580
在那个函数中的这个函数，然后

687
00:26:48,580 --> 00:26:49,840
他们会加载这个 进入

688
00:26:49,840 --> 00:26:51,430
他们开发

689
00:26:51,430 --> 00:26:53,920
的这个名为 scribe 的内部工具，我认为这有点

690
00:26:53,920 --> 00:26:55,840
像 Kafka 类型的东西，我们有一堆

691
00:26:55,840 --> 00:26:57,730
日志记录进来，然后你可以

692
00:26:57,730 --> 00:27:00,850
让 pub 子系统说这是

693
00:27:00,850 --> 00:27:01,990
如何对数据进行分类我 已经

694
00:27:01,990 --> 00:27:03,730
收集并在其他系统中

695
00:27:03,730 --> 00:27:05,230
在新信息到达时收到通知

696
00:27:05,230 --> 00:27:08,020
所以这是一件比较古老的事情

697
00:27:08,020 --> 00:27:10,180
，因为十多年来

698
00:27:10,180 --> 00:27:11,410
他们在 github 上有一个开源版本，

699
00:27:11,410 --> 00:27:12,910
但这就像放弃了

700
00:27:12,910 --> 00:27:16,300
dec 很久以前，据说

701
00:27:16,300 --> 00:27:17,500
内部版本比现在在线的要好得多，

702
00:27:17,500 --> 00:27:21,040
所以

703
00:27:21,040 --> 00:27:23,800
抄写员现在要查看结构化

704
00:27:23,800 --> 00:27:25,720
日志，查看一些标签，说你知道

705
00:27:25,720 --> 00:27:28,090
它是为你生成的，因为你知道这个

706
00:27:28,090 --> 00:27:29,890
特定的应用程序类型或这个

707
00:27:29,890 --> 00:27:32,260
服务 它将根据该类别将它们组合

708
00:27:32,260 --> 00:27:34,000
起来，

709
00:27:34,000 --> 00:27:35,650
然后将它们发送到这个

710
00:27:35,650 --> 00:27:37,180
流媒体平台，或者他们将其称为

711
00:27:37,180 --> 00:27:39,010
定制服务，因为它们

712
00:27:39,010 --> 00:27:40,840
只是拖尾日志 这只是将

713
00:27:40,840 --> 00:27:42,160
一堆这些日志记录混在一起

714
00:27:42,160 --> 00:27:44,710
他们从抄写员那里得到，

715
00:27:44,710 --> 00:27:46,150
然后当他们有足够大的批次时，

716
00:27:46,150 --> 00:27:47,920
他们会将其转换为

717
00:27:47,920 --> 00:27:51,460
柱状数据文件，就像

718
00:27:51,460 --> 00:27:53,230
我们上周讨论过的 park' 或 orc 一样，

719
00:27:53,230 --> 00:27:54,790
这就像一个独立的

720
00:27:54,790 --> 00:27:57,550
文件，几乎就像一个 CSV 但它实际上是

721
00:27:57,550 --> 00:28:01,270
一个二进制列存储，所以如果他们

722
00:28:01,270 --> 00:28:02,260
有更大的批次，他们将

723
00:28:02,260 --> 00:28:03,850
生成这些列存储文件

724
00:28:03,850 --> 00:28:05,590
，然后现在他们

725
00:28:05,590 --> 00:28:08,890
将把它输入到 scu 中的叶节点

726
00:28:08,890 --> 00:28:10,510
我们正在讨论 16 个聚合注释

727
00:28:10,510 --> 00:28:12,190
和叶节点，但这基本上是

728
00:28:12,190 --> 00:28:14,290
存储节点将其

729
00:28:14,290 --> 00:28:16,660
视为共享磁盘架构，但您

730
00:28:16,660 --> 00:28:18,310
实际上可以让您知道在此处运行查询

731
00:28:18,310 --> 00:28:20,920
或 Shashank 讨论的最后一个类

732
00:28:20,920 --> 00:28:23,020
关于 Oracle Exadata 但他们

733
00:28:23,020 --> 00:28:24,640
在底部有存储节点

734
00:28:24,640 --> 00:28:25,930
实际上可以在相同的想法下进行过滤和谓词

735
00:28:25,930 --> 00:28:27,100
评估，

736
00:28:27,100 --> 00:28:30,370
所以现在

737
00:28:30,370 --> 00:28:31,570
他们要做的另一件事

738
00:28:31,570 --> 00:28:33,580
是他们要这些叶

739
00:28:33,580 --> 00:28:35,200
节点中的每一个

740
00:28:35,200 --> 00:28:37,539
使用

741
00:28:37,539 --> 00:28:39,250
有关他们为每个表插入的元组数量的信息更新此验证服务

742
00:28:39,250 --> 00:28:42,730
，我们将

743
00:28:42,730 --> 00:28:44,320
在一秒钟内看到它，这就是他们将如何

744
00:28:44,320 --> 00:28:47,980
确定当他们

745
00:28:47,980 --> 00:28:49,240
在多个部署或

746
00:28:49,240 --> 00:28:51,309
多个集群上运行查询时 会检查那

747
00:28:51,309 --> 00:28:53,139
件事，说清楚实际上丢失了多少数据，

748
00:28:53,139 --> 00:28:54,639
所以我知道我对一

749
00:28:54,639 --> 00:28:56,529
百万个元组进行了排序，但我只读取了

750
00:28:56,529 --> 00:28:58,659
500,000 个，所以我的一半数据再次丢失

751
00:28:58,659 --> 00:29:00,610
了他们不是他们不是 gon  na go

752
00:29:00,610 --> 00:29:02,710
freak out 这在他们的环境中没问题，

753
00:29:02,710 --> 00:29:04,210
但他们只是跟踪

754
00:29:04,210 --> 00:29:05,980
这一点，他们知道哪个查询

755
00:29:05,980 --> 00:29:09,100
产生了最准确的结果，所以

756
00:29:09,100 --> 00:29:10,990
现在它又是一个海鸥系统，所以

757
00:29:10,990 --> 00:29:14,889
他们有一个 vistas 续集界面或

758
00:29:14,889 --> 00:29:16,240
这些人们可以使用的仪表板

759
00:29:16,240 --> 00:29:18,279
在 Facebook 内部，将后续

760
00:29:18,279 --> 00:29:20,019
查询发送到这个执行层，

761
00:29:20,019 --> 00:29:20,980
然后将其发送到这些

762
00:29:20,980 --> 00:29:22,960
聚合器，然后聚合器将其

763
00:29:22,960 --> 00:29:24,730
向下转移到这些叶节点，所以我将讨论

764
00:29:24,730 --> 00:29:26,769
这个层次结构和更多的幻灯片，

765
00:29:26,769 --> 00:29:28,659
但这是之间的重要区别

766
00:29:28,659 --> 00:29:30,429
我们讨论的所有分布式数据库

767
00:29:30,429 --> 00:29:32,590
，因为它是一个异构

768
00:29:32,590 --> 00:29:34,330
环境，所以叶节点

769
00:29:34,330 --> 00:29:36,070


770
00:29:36,070 --> 00:29:37,799
正在做与聚合器注释

771
00:29:37,799 --> 00:29:39,639
正确的事情不同或不同的事情，你显然有更多的

772
00:29:39,639 --> 00:29:43,740
这些，因为你有更多的数据是

773
00:29:43,740 --> 00:29:45,730
的，问题是 类别名称是

774
00:29:45,730 --> 00:29:47,860
准确的，是的，可以

775
00:29:47,860 --> 00:29:51,360
认为这是 Facebook

776
00:29:51,360 --> 00:29:53,860
将其归因于特定类别的日志

777
00:29:53,860 --> 00:29:56,470
记录设备的一些内部标签 再次说，就像我

778
00:29:56,470 --> 00:29:58,990
不知道 facebook 收件箱或

779
00:29:58,990 --> 00:30:00,850
信使一样，所以你会说这将

780
00:30:00,850 --> 00:30:03,370
是一个类别，所以

781
00:30:03,370 --> 00:30:05,080
来自信使应用程序的所有日志记录都可以

782
00:30:05,080 --> 00:30:11,980
组合在一起，好吧，好吧，

783
00:30:11,980 --> 00:30:13,299
它是一个标题 果汁架构

784
00:30:13,299 --> 00:30:15,850
，我们有叶节点聚合器节点，

785
00:30:15,850 --> 00:30:18,159
所以叶节点将以

786
00:30:18,159 --> 00:30:19,690
列格式存储我们从记录批处理器中获取的数据列，

787
00:30:19,690 --> 00:30:24,340


788
00:30:24,340 --> 00:30:29,500
并且对于每个查询，

789
00:30:29,500 --> 00:30:31,029
每个查询都将转到每个

790
00:30:31,029 --> 00:30:33,039
叶 节点，因此可能不是

791
00:30:33,039 --> 00:30:35,950
该叶节点上查询所需的数据，但

792
00:30:35,950 --> 00:30:37,149
它们不会存储任何

793
00:30:37,149 --> 00:30:38,980
额外的元数据或维护

794
00:30:38,980 --> 00:30:40,580
这些叶上的任何索引，

795
00:30:40,580 --> 00:30:42,769
让我确定是否需要

796
00:30:42,769 --> 00:30:45,259
在它们上接触数据，以便它们 '正在

797
00:30:45,259 --> 00:30:46,129
尝试使这件事尽可能快

798
00:30:46,129 --> 00:30:48,110
地尝试

799
00:30:48,110 --> 00:30:49,399
在查询

800
00:30:49,399 --> 00:30:51,049
执行速度和摄取新

801
00:30:51,049 --> 00:30:53,539
数据的速度方面做到这一点，因此如果我不必维护任何

802
00:30:53,539 --> 00:30:55,340
元数据或目录信息 关于

803
00:30:55,340 --> 00:30:59,419
哪些数据是 在哪个叶节点上，我

804
00:30:59,419 --> 00:31:00,980
可以非常快速地摄取新数据，

805
00:31:00,980 --> 00:31:02,809
然后每个查询都会出现并只扫描

806
00:31:02,809 --> 00:31:05,299
所有内容，然后确定

807
00:31:05,299 --> 00:31:07,279
您是否知道您拥有

808
00:31:07,279 --> 00:31:11,389
实际需要的数据，这

809
00:31:11,389 --> 00:31:12,590
很有意义，就像我们在讨论分区

810
00:31:12,590 --> 00:31:14,480
之前一样 谈谈这是怎么回事，

811
00:31:14,480 --> 00:31:15,919
我们会在那里看到一个 Mongo 和

812
00:31:15,919 --> 00:31:18,679
蟑螂来维护这个状态表

813
00:31:18,679 --> 00:31:20,539
，上面写着如果你想要这个

814
00:31:20,539 --> 00:31:22,519
范围内的数据或这个哈希值去这些

815
00:31:22,519 --> 00:31:24,289
节点，他们不会有任何

816
00:31:24,289 --> 00:31:26,029
他们只是爆炸

817
00:31:26,029 --> 00:31:29,419
每一个查询无处不在，所以当

818
00:31:29,419 --> 00:31:30,980
聚合器节点收到查询时，

819
00:31:30,980 --> 00:31:33,350
他们会将计划片段分派

820
00:31:33,350 --> 00:31:34,610
到叶子节点中，它显示在叶子节点

821
00:31:34,610 --> 00:31:36,679
中，丹将在叶子节点上执行，

822
00:31:36,679 --> 00:31:38,659
他们将进行扫描和一些

823
00:31:38,659 --> 00:31:40,309
基本计算，但我要将

824
00:31:40,309 --> 00:31:42,110
结果发送到聚合器节点，

825
00:31:42,110 --> 00:31:44,419
然后我们将组合来自

826
00:31:44,419 --> 00:31:46,850
多个叶节点的结果以生成单个

827
00:31:46,850 --> 00:31:48,529
结果，然后将其发送到组合的

828
00:31:48,529 --> 00:31:50,090
根节点 es 结合了最终

829
00:31:50,090 --> 00:31:52,730
结果，因此这允许他们

830
00:31:52,730 --> 00:31:55,009
非常轻松地扩展系统，因为我

831
00:31:55,009 --> 00:31:57,019
知道我的聚合器是否运行缓慢，

832
00:31:57,019 --> 00:31:58,639
我可以添加这些节点，因为它们

833
00:31:58,639 --> 00:32:00,110
没有任何不是实际存储数据的状态的权利，

834
00:32:00,110 --> 00:32:01,610
或者 如果我

835
00:32:01,610 --> 00:32:03,139
需要扩展我的叶节点，我只需要添加

836
00:32:03,139 --> 00:32:04,789
更多的叶节点并保留我的 Grenadiers

837
00:32:04,789 --> 00:32:06,649
但相同但这是一个非常有趣的

838
00:32:06,649 --> 00:32:08,240
架构，它出现在许多

839
00:32:08,240 --> 00:32:12,590
其他 Facebook 系统设计中

840
00:32:12,590 --> 00:32:14,179


841
00:32:14,179 --> 00:32:15,529
续集 他们花时间

842
00:32:15,529 --> 00:32:16,970
在 Facebook 上，他们看到了这种

843
00:32:16,970 --> 00:32:19,039
架构，然后

844
00:32:19,039 --> 00:32:22,190
当他们离开时，他们有点复制它或受到它的

845
00:32:22,190 --> 00:32:23,840


846
00:32:23,840 --> 00:32:28,039


847
00:32:28,039 --> 00:32:31,700


848
00:32:31,700 --> 00:32:34,370
启发 数据，因此如果叶节点

849
00:32:34,370 --> 00:32:37,309
没有数据或关闭并且

850
00:32:37,309 --> 00:32:39,049
在超时内无法产生任何结果

851
00:32:39,049 --> 00:32:41,240
，那么他们只是忽略它，

852
00:32:41,240 --> 00:32:43,100
没关系，他们使用验证服务

853
00:32:43,100 --> 00:32:44,419
来弄清楚如何 很多数据是

854
00:32:44,419 --> 00:32:46,100
这个东西实际拥有的，这将

855
00:32:46,100 --> 00:32:47,360
决定查询的质量

856
00:32:47,360 --> 00:32:50,210
查询结果 所以让我们

857
00:32:50,210 --> 00:32:52,260
看看完整管道的末端是什么样的 所以

858
00:32:52,260 --> 00:32:54,330
这又被认为是

859
00:32:54,330 --> 00:32:55,980
一勺集群 他们将要他们

860
00:32:55,980 --> 00:32:58,140
将

861
00:32:58,140 --> 00:32:59,250
在

862
00:32:59,250 --> 00:33:00,480
不同数据中心、不同区域运行多个相同类型集群的实例，

863
00:33:00,480 --> 00:33:02,400
并且它们将对所有查询进行投票而

864
00:33:02,400 --> 00:33:04,080
不是同时进行，它们都

865
00:33:04,080 --> 00:33:05,190
返回相同的结果，您可以选择

866
00:33:05,190 --> 00:33:07,830
哪个是最好的 所以我的查询

867
00:33:07,830 --> 00:33:10,470
出现了 我想对

868
00:33:10,470 --> 00:33:12,330
坠毁的通风口数量进行汇总

869
00:33:12,330 --> 00:33:14,940
周一再次发生了崩溃，所以我

870
00:33:14,940 --> 00:33:16,710
只能进行单表查询 我可以

871
00:33:16,710 --> 00:33:18,450
进行聚合 我可以进行分组 我可以

872
00:33:18,450 --> 00:33:20,460
进行过滤 扫描但我不能对

873
00:33:20,460 --> 00:33:22,710
全局全局排序我可以做连接

874
00:33:22,710 --> 00:33:25,650
所以路由会得到查询，

875
00:33:25,650 --> 00:33:26,850
这将把它分解成查询

876
00:33:26,850 --> 00:33:27,960
计划片段，然后可以

877
00:33:27,960 --> 00:33:29,430
分发到聚合器

878
00:33:29,430 --> 00:33:31,170
，聚合器将把它们

879
00:33:31,170 --> 00:33:34,230
归还给 吨 继承人删除节点 现在所有的叶

880
00:33:34,230 --> 00:33:35,520
节点都将进行扫描，

881
00:33:35,520 --> 00:33:37,980
然后将结果发送回来，但是假设

882
00:33:37,980 --> 00:33:39,330
在我们执行此查询时，此

883
00:33:39,330 --> 00:33:41,790
节点出现故障，如果您有一个大型集群，就会发生这种情况，

884
00:33:41,790 --> 00:33:44,370
所以

885
00:33:44,370 --> 00:33:46,170
其他人我都在 仍然是错误的

886
00:33:46,170 --> 00:33:48,240
其他人仍然可以

887
00:33:48,240 --> 00:33:50,940
为这个查询做计算，然后他们

888
00:33:50,940 --> 00:33:52,680
将结果发送回

889
00:33:52,680 --> 00:33:54,390
聚合器 prepend 只是无法将

890
00:33:54,390 --> 00:33:56,490
它组合在一起，所以我正在做帐户

891
00:33:56,490 --> 00:33:57,750
我想知道事件的数量

892
00:33:57,750 --> 00:33:59,610
发生了所以这个人说我有 10 个

893
00:33:59,610 --> 00:34:02,130
事件他有 20 个事件 所以这个人只

894
00:34:02,130 --> 00:34:04,200
需要 10 加 20 并产生 30

895
00:34:04,200 --> 00:34:06,690
然后将其发送到根节点，

896
00:34:06,690 --> 00:34:08,159
根节点做同样的事情，只是将

897
00:34:08,159 --> 00:34:09,659
不同聚合器的所有结果相加，

898
00:34:09,659 --> 00:34:13,590
然后产生最终结果所以这

899
00:34:13,590 --> 00:34:34,320
很清楚是是所以这个查询是

900
00:34:34,320 --> 00:34:37,260
正确扫描所有内容所以没有

901
00:34:37,260 --> 00:34:39,000
再次没有元数据

902
00:34:39,000 --> 00:34:40,800
没有目录告诉我

903
00:34:40,800 --> 00:34:42,750
这些叶节点是否有

904
00:34:42,750 --> 00:34:45,210
我有我的数据 where 子句

905
00:34:45,210 --> 00:34:47,070
所以我不知道但我不知道

906
00:34:47,070 --> 00:34:48,270
类型在哪里我不知道时间在哪里所以我

907
00:34:48,270 --> 00:34:50,610
把它发给每个人所以每个人基本上

908
00:34:50,610 --> 00:34:51,929
他都会在这个例子中在这里

909
00:34:51,929 --> 00:34:53,639
每个人都会做完全相同的查询

910
00:34:53,639 --> 00:34:56,760
运行它 叶节点好吧，所以他正在

911
00:34:56,760 --> 00:34:58,350
做一个计数 明星工作类型 II 类型

912
00:34:58,350 --> 00:35:00,090
等于崩溃时间 他去星期一 他有

913
00:35:00,090 --> 00:35:02,070
10 个他只是把它推上去，这个人

914
00:35:02,070 --> 00:35:04,050
很清楚我在做这个计数，所以

915
00:35:04,050 --> 00:35:05,820
我只是把一些

916
00:35:05,820 --> 00:35:14,090
数字加在一起，请结果 是

917
00:35:18,020 --> 00:35:20,700
啊，对于每一个

918
00:35:20,700 --> 00:35:24,150
查询，你总是将相同的

919
00:35:24,150 --> 00:35:26,430
查询复制到叶节点是

920
00:35:26,430 --> 00:35:28,380


921
00:35:28,380 --> 00:35:29,730


922
00:35:29,730 --> 00:35:31,860
真的吗 那

923
00:35:31,860 --> 00:35:37,920
会有所不同，是的，所以

924
00:35:37,920 --> 00:35:41,520
真的没有像因为没有加入

925
00:35:41,520 --> 00:35:42,630
厨师所以这里没有真正的查询

926
00:35:42,630 --> 00:35:44,310
优化器它只是我需要

927
00:35:44,310 --> 00:35:45,900
知道我只是将 seco 转换为

928
00:35:45,900 --> 00:35:48,210
查询计划并关闭它

929
00:35:48,210 --> 00:35:49,440
还有一些 他们

930
00:35:49,440 --> 00:35:50,880
可能对 fi 做的基本启发式 像你知道

931
00:35:50,880 --> 00:35:52,770
如何真正分解它并将其发送

932
00:35:52,770 --> 00:36:03,450
到 huitnids 是的所以这个问题

933
00:36:03,450 --> 00:36:05,460
是为什么它为什么决定在这里有一个

934
00:36:05,460 --> 00:36:08,040
根节点以及所有客户端如何

935
00:36:08,040 --> 00:36:11,130
去这个而不是让每个人都可以

936
00:36:11,130 --> 00:36:13,080
受到惩罚去任何 聚合器，然后

937
00:36:13,080 --> 00:36:14,880
任何聚合器都可以与其他任何人交谈，

938
00:36:14,880 --> 00:36:20,550
所以我的理解是

939
00:36:20,550 --> 00:36:22,860
实际上在这之上还有一个层，

940
00:36:22,860 --> 00:36:24,960
根是他们正在执行

941
00:36:24,960 --> 00:36:27,540
任务控制，所以他们可以做一些

942
00:36:27,540 --> 00:36:30,330
事情，比如哦，如果查询一个节点

943
00:36:30,330 --> 00:36:32,490
发送太多查询 发送太多查询的客户端

944
00:36:32,490 --> 00:36:33,660
可能想要

945
00:36:33,660 --> 00:36:36,060
限制它们，或者如果我知道我

946
00:36:36,060 --> 00:36:38,340
从这些节点的某些集合中获取了错误数据，

947
00:36:38,340 --> 00:36:40,410
那么我可以

948
00:36:40,410 --> 00:36:42,300
让某人决定排除或

949
00:36:42,300 --> 00:36:44,280
不包括哪些内容 他们在我的查询执行中，

950
00:36:44,280 --> 00:36:46,560
所以它允许他们有一个单一的

951
00:36:46,560 --> 00:36:49,170
位置来全局查看

952
00:36:49,170 --> 00:36:51,180
集群中正在发生的事情不

953
00:36:51,180 --> 00:36:52,620
知道数据库中的内容是正确的，

954
00:36:52,620 --> 00:36:53,520
因为那将是

955
00:36:53,520 --> 00:36:55,050
广泛的维护并保持它

956
00:36:55,050 --> 00:36:56,940
fr  esh 一直都知道，

957
00:36:56,940 --> 00:36:58,800
就像这些节点正在执行一样，而且

958
00:36:58,800 --> 00:37:15,720
它们表现不佳 是的，他的问题是

959
00:37:15,720 --> 00:37:18,390
说这个节点有大量的结果 大量

960
00:37:18,390 --> 00:37:20,750
的结果与我的谓词相匹配

961
00:37:20,750 --> 00:37:23,150
我不会对我更好只是中止

962
00:37:23,150 --> 00:37:25,849
这个查询因为我是我的

963
00:37:25,849 --> 00:37:28,339
计数我很远你怎么知道

964
00:37:28,339 --> 00:37:30,349
这个节点有所有日期有很多

965
00:37:30,349 --> 00:37:33,410
数据对你的清理很重要你

966
00:37:33,410 --> 00:37:38,420
不知道是的所以再想想

967
00:37:38,420 --> 00:37:39,980
这是为此设计的 是

968
00:37:39,980 --> 00:37:42,069
为由机器生成的日志而设计的，

969
00:37:42,069 --> 00:37:44,960
它不是像嘿这是我的银行

970
00:37:44,960 --> 00:37:46,640
账户我希望你知道你

971
00:37:46,640 --> 00:37:49,839
知道你一分钱所以如果你得到

972
00:37:49,839 --> 00:37:53,599
松散的结果仍然

973
00:37:53,599 --> 00:37:56,480
可能没问题，然后他们

974
00:37:56,480 --> 00:37:57,950
有点克服的方式 再次是通过使用

975
00:37:57,950 --> 00:37:59,359
验证服务，他们可以确定

976
00:37:59,359 --> 00:38:02,230
他们实际上没有读取多少数据

977
00:38:02,230 --> 00:38:05,089
，然后又一次，然后他们有

978
00:38:05,089 --> 00:38:06,589
一堆系统的杜南副本

979
00:38:06,589 --> 00:38:08,030
同时运行，他们

980
00:38:08,030 --> 00:38:09,950
都会产生相同的查询，所以

981
00:38:09,950 --> 00:38:11,480
每个的可能性 单个

982
00:38:11,480 --> 00:38:13,819
运行 Scooba 进行

983
00:38:13,819 --> 00:38:15,020
单个查询的每个集群都会使该节点

984
00:38:15,020 --> 00:38:17,569
发生故障，您确切地知道该节点

985
00:38:17,569 --> 00:38:20,540
具有此数据故障非常低，因此

986
00:38:20,540 --> 00:38:22,490
这些集群中的至少一个将具有

987
00:38:22,490 --> 00:38:23,930
更活跃的结果，这就是

988
00:38:23,930 --> 00:38:27,740
他们将要发生的 使用那是不同的方式 我们

989
00:38:27,740 --> 00:38:28,790
谈论整个学期 这就是为什么我喜欢

990
00:38:28,790 --> 00:38:30,680
这个系统 因为这就像我们

991
00:38:30,680 --> 00:38:32,630
现在谈论永远不会丢失数据 我

992
00:38:32,630 --> 00:38:35,329
说丢失数据是可以的 因为这

993
00:38:35,329 --> 00:38:36,440
就像如果树倒在树林里

994
00:38:36,440 --> 00:38:37,730
没有人在附近 听说谁在乎

995
00:38:37,730 --> 00:38:39,349
这个节点是否宕机，不，你知道没有

996
00:38:39,349 --> 00:38:40,640
人知道，它关心

997
00:38:40,640 --> 00:38:43,670
实际上有什么数据，这很重要，

998
00:38:43,670 --> 00:38:46,520
因为它们不在你知道

999
00:38:46,520 --> 00:38:48,500
每次运行 wrap 或 patos 或者

1000
00:38:48,500 --> 00:38:50,809
它们正在更新 数据这个东西可以运行得

1001
00:38:50,809 --> 00:38:55,369
非常快，所以这是

1002
00:38:55,369 --> 00:38:56,960
总结我们之前已经说过的一切

1003
00:38:56,960 --> 00:38:59,020
，所以对于每个水肺

1004
00:38:59,020 --> 00:39:01,280
部署，我有多个

1005
00:39:01,280 --> 00:39:02,440


1006
00:39:02,440 --> 00:39:05,540
在他们的区域中运行多个水肺部署，我们运行

1007
00:39:05,540 --> 00:39:07,069
同时查询所有

1008
00:39:07,069 --> 00:39:09,109
区域，然后他们返回一个

1009
00:39:09,109 --> 00:39:11,180
结果，然后

1010
00:39:11,180 --> 00:39:12,980
用来自验证服务的信息对结果进行注释，说明

1011
00:39:12,980 --> 00:39:15,440


1012
00:39:15,440 --> 00:39:18,049
我最终没有读取多少数据我选择了

1013
00:39:18,049 --> 00:39:20,869
一个 拥有最多的

1014
00:39:20,869 --> 00:39:24,790
读取最多的数据和

1015
00:39:25,180 --> 00:39:28,430
时间，所以我们知道管理我们的人 Stavros

1016
00:39:28,430 --> 00:39:30,760
他在

1017
00:39:30,760 --> 00:39:31,960
[音乐]

1018
00:39:31,960 --> 00:39:35,630
2007-2008 年从 CMU 获得博士学位，现在他负责我们，

1019
00:39:35,630 --> 00:39:40,430
所以你好，任何问题都很好，

1020
00:39:40,430 --> 00:39:44,000
很好 排名第二的是 Mongo Mongo

1021
00:39:44,000 --> 00:39:46,849
每年总是被选中所以让

1022
00:39:46,849 --> 00:39:48,079
我问你们我每年都问这个

1023
00:39:48,079 --> 00:39:51,529
你们为什么选择 Mongo 我假设

1024
00:39:51,529 --> 00:39:52,579
你选择

1025
00:39:52,579 --> 00:39:53,900
了 Facebook 因为你们中的一些人想在 Facebook 找到工作因为你

1026
00:39:53,900 --> 00:39:55,640
认为我进去了 面试时我

1027
00:39:55,640 --> 00:39:57,910
可以聪明地谈论

1028
00:39:57,910 --> 00:39:59,869
Mongo 的潜水同样的事情 你想在 Mongo 工作

1029
00:39:59,869 --> 00:40:03,190
还是想使用 Mongo

1030
00:40:03,220 --> 00:40:05,000
有些人已经实习了

1031
00:40:05,000 --> 00:40:06,500
有些人要去那里新的实习

1032
00:40:06,500 --> 00:40:10,190
我猜他说这

1033
00:40:10,190 --> 00:40:12,049
与 wh 大不相同 在我们通常做的很好，所以

1034
00:40:12,049 --> 00:40:13,940
我认识 MongoDB 的人很

1035
00:40:13,940 --> 00:40:17,720
长时间了 联合创始人之一实际上

1036
00:40:17,720 --> 00:40:23,680
在我做他之前就变褐了，所以他就像

1037
00:40:23,680 --> 00:40:26,539
我们从 2009 年就认识 Elliot 一样，当

1038
00:40:26,539 --> 00:40:27,589
他第一次开始评估时，你能吗 来

1039
00:40:27,589 --> 00:40:29,690
今年的斯巴达演讲，他们

1040
00:40:29,690 --> 00:40:31,520
一直在那里，我实际上是八月份在那里

1041
00:40:31,520 --> 00:40:33,170
他们有一座新办公楼，

1042
00:40:33,170 --> 00:40:35,480
他们曾经就在

1043
00:40:35,480 --> 00:40:37,190
时代广场的拐角处，这太糟糕了他们

1044
00:40:37,190 --> 00:40:39,140
仍在中城，但他们有一个 漂亮的

1045
00:40:39,140 --> 00:40:40,849
办公楼，所以你知道他们很

1046
00:40:40,849 --> 00:40:42,589
重要，如果你在大楼外面有你公司的标志，

1047
00:40:42,589 --> 00:40:45,380


1048
00:40:45,380 --> 00:40:47,000
上面写着华纳音乐集团，

1049
00:40:47,000 --> 00:40:48,529
他们有钱 Mongo 做得很好，

1050
00:40:48,529 --> 00:40:50,240
这一切都是为了数据库，所以这是

1051
00:40:50,240 --> 00:40:51,500
他们的大堂 大堂不错，看起来很

1052
00:40:51,500 --> 00:40:54,230
熟悉，是的，嗯，景色

1053
00:40:54,230 --> 00:40:55,789
很棒，所以这是从厨房里看到

1054
00:40:55,789 --> 00:40:58,609


1055
00:40:58,609 --> 00:41:01,309


1056
00:41:01,309 --> 00:41:03,650


1057
00:41:03,650 --> 00:41:05,930


1058
00:41:05,930 --> 00:41:09,109
的 莫 del 数据精神系统 因此，

1059
00:41:09,109 --> 00:41:12,260
当我说文档时，将 JSON 视为

1060
00:41:12,260 --> 00:41:17,869
JSON 对象，而在 MongoDB 世界

1061
00:41:17,869 --> 00:41:19,339
中，当我们谈论

1062
00:41:19,339 --> 00:41:20,270
整个学期时所

1063
00:41:20,270 --> 00:41:21,799
用的语言略有不同，所以再说一遍，与其说

1064
00:41:21,799 --> 00:41:23,119
粗体说文档，不如说

1065
00:41:23,119 --> 00:41:25,220
他们说表 或者他们说的一种关系，

1066
00:41:25,220 --> 00:41:27,470
但高级概念

1067
00:41:27,470 --> 00:41:31,609
仍然相同，因此它

1068
00:41:31,609 --> 00:41:33,289
是我们最早的原始无续集

1069
00:41:33,289 --> 00:41:35,390
系统之一 它是开源的

1070
00:41:35,390 --> 00:41:37,640
它曾经是 GPL 但现在他们切换

1071
00:41:37,640 --> 00:41:38,630
到服务器端

1072
00:41:38,630 --> 00:41:40,099
许可证 这基本上是 为了保护

1073
00:41:40,099 --> 00:41:42,140
他们免受亚马逊的影响，就像 MongoDB 变得如此

1074
00:41:42,140 --> 00:41:44,000
受欢迎，他们担心亚马逊会

1075
00:41:44,000 --> 00:41:47,210
出现并且只是

1076
00:41:47,210 --> 00:41:48,470
在托管环境中运行 MongoDB 并以

1077
00:41:48,470 --> 00:41:50,539
比妈妈更便宜的价格出售它所以

1078
00:41:50,539 --> 00:41:53,210
他们现在更换了他们的许可证亚马逊

1079
00:41:53,210 --> 00:41:54,680
确实推出了一个系统 确实

1080
00:41:54,680 --> 00:41:57,019
克隆了称为文档电子束的木乃伊协议，

1081
00:41:57,019 --> 00:41:59,119
但我对它的

1082
00:41:59,119 --> 00:42:00,470
工作原理的理解是，覆盖范围内

1083
00:42:00,470 --> 00:42:02,660
只是 Postgres，因此有线协议的外观

1084
00:42:02,660 --> 00:42:05,240
和气味 像看起来像

1085
00:42:05,240 --> 00:42:08,779
MongoDB 但在它下面只是

1086
00:42:08,779 --> 00:42:10,609
杂货店所以它将非常

1087
00:42:10,609 --> 00:42:11,900
集中的无共享架构

1088
00:42:11,900 --> 00:42:17,559
与异构配置

1089
00:42:17,559 --> 00:42:19,549
最初他们你知道作为这个没有

1090
00:42:19,549 --> 00:42:20,569
续集的系统他们没有做

1091
00:42:20,569 --> 00:42:22,220
交易，他们需要新的

1092
00:42:22,220 --> 00:42:25,039
加入新的 续集 所以现在最新

1093
00:42:25,039 --> 00:42:26,329
版本的 Mongo 他们会做

1094
00:42:26,329 --> 00:42:27,289
交易他们带来的

1095
00:42:27,289 --> 00:42:29,240
交易他们也加入

1096
00:42:29,240 --> 00:42:30,460
他们唯一没有带来的东西是

1097
00:42:30,460 --> 00:42:35,750
续集现在有一些黑客

1098
00:42:35,750 --> 00:42:38,269
工具可以将续集转换为准妈妈

1099
00:42:38,269 --> 00:42:40,670
据我所知，我从来没有遇到

1100
00:42:40,670 --> 00:42:42,500
过任何人在生产中运行这个和那些

1101
00:42:42,500 --> 00:42:44,599
东西，所以他们

1102
00:42:44,599 --> 00:42:46,009
是敌人之一，他们将拥有自己的 API

1103
00:42:46,009 --> 00:42:47,569
，我将在一秒钟内展示，这基本上是

1104
00:42:47,569 --> 00:42:49,609
你编写 JSON 查询来阅读

1105
00:42:49,609 --> 00:42:53,599
JSON 数据 所以

1106
00:42:53,599 --> 00:42:55,309
关于文档数据模型的一个重要概念与

1107
00:42:55,309 --> 00:42:56,180
我们整个学期讨论的完全不同的

1108
00:42:56,180 --> 00:42:58,390
是非规范化的概念，

1109
00:42:58,390 --> 00:43:02,509
所以在关系

1110
00:43:02,509 --> 00:43:04,519
模型中我们 将定义我们的表或

1111
00:43:04,519 --> 00:43:06,559
定义我们的关系，我们将使用

1112
00:43:06,559 --> 00:43:08,599
外键来表示

1113
00:43:08,599 --> 00:43:10,940
从这个表到另一个表的引用，

1114
00:43:10,940 --> 00:43:13,579
所以如果我通过建模亚马逊获得收益是

1115
00:43:13,579 --> 00:43:15,410
我的商店信息，所以我有

1116
00:43:15,410 --> 00:43:16,940
客户订单和订单有订单

1117
00:43:16,940 --> 00:43:19,940
因此在关系数据库系统中，

1118
00:43:19,940 --> 00:43:20,960
我将这些项目定义为单独的

1119
00:43:20,960 --> 00:43:22,849
关系，然后如果我想为

1120
00:43:22,849 --> 00:43:24,230
给定的客户说给我

1121
00:43:24,230 --> 00:43:25,759
他们购买的所有项目，我将不得不

1122
00:43:25,759 --> 00:43:27,859
在这三个表之间进行三向连接

1123
00:43:27,859 --> 00:43:30,859
，而不是 续集的人争辩说

1124
00:43:30,859 --> 00:43:34,069
，这样做会很昂贵，

1125
00:43:34,069 --> 00:43:36,559
你知道，因为现在

1126
00:43:36,559 --> 00:43:37,670
你必须运行你的散列连接和嵌套

1127
00:43:37,670 --> 00:43:41,480
循环连接，所以他们会争辩说

1128
00:43:41,480 --> 00:43:42,829
你想要在文档数据

1129
00:43:42,829 --> 00:43:44,630
模型中做的是 denormalize 基本上

1130
00:43:44,630 --> 00:43:48,529
所说的将有关应用程序中

1131
00:43:48,529 --> 00:43:50,569
单个实体的相关信息组合

1132
00:43:50,569 --> 00:43:52,010
到

1133
00:43:52,010 --> 00:43:54,890
单个 JSON 文档中

1134
00:43:54,890 --> 00:43:55,730


1135
00:43:55,730 --> 00:43:57,140


1136
00:43:57,140 --> 00:43:59,090
表，您将有一张名为

1137
00:43:59,090 --> 00:44:01,460
customer 的表，然后在每个客户

1138
00:44:01,460 --> 00:44:03,410
记录中嵌入他们的订单，

1139
00:44:03,410 --> 00:44:05,660
然后在每个订单中吃掉哪个，您

1140
00:44:05,660 --> 00:44:08,240
将嵌入他们的订单项目，所以现在如果

1141
00:44:08,240 --> 00:44:09,800
我想去获取

1142
00:44:09,800 --> 00:44:12,230
Andy 购买的所有订单项目，我就去获取 我的客户

1143
00:44:12,230 --> 00:44:14,540
记录来自数据库系统 然后

1144
00:44:14,540 --> 00:44:16,280
我现在只是在 JSON

1145
00:44:16,280 --> 00:44:19,340
文档中反转以获得我现在想要的东西 Mongo

1146
00:44:19,340 --> 00:44:20,630
nummy 没有发明那个想法

1147
00:44:20,630 --> 00:44:23,270
那是 70 年代 XML 数据库的旧

1148
00:44:23,270 --> 00:44:25,760
想法 在 2000 年代初

1149
00:44:25,760 --> 00:44:27,530
19 世纪 90 年代末做到了对象

1150
00:44:27,530 --> 00:44:29,660
面向对象的人在 1980 年代就这样做了，所以 MongoDB

1151
00:44:29,660 --> 00:44:31,340
并没有发明 Mongi

1152
00:44:31,340 --> 00:44:33,920
的出名之处在于拥有一个你知道的快速

1153
00:44:33,920 --> 00:44:37,460
分布式 JSON 数据库系统，

1154
00:44:37,460 --> 00:44:39,230
当某种网络账单和

1155
00:44:39,230 --> 00:44:42,920
JavaScript 变得突出时，所以我们再次

1156
00:44:42,920 --> 00:44:45,470
看起来像这样 并且您的 JSON

1157
00:44:45,470 --> 00:44:46,940
文档将在其中

1158
00:44:46,940 --> 00:44:49,070
包含名为 orders 的数组，在其中

1159
00:44:49,070 --> 00:44:50,390
您为每个订单都有额外的 JSON 文档

1160
00:44:50,390 --> 00:44:51,860
并决定

1161
00:44:51,860 --> 00:44:53,690
每个订单 y 您有一个用于订购商品的数组

1162
00:44:53,690 --> 00:44:55,010
，然后是他们购买的所有商品，

1163
00:44:55,010 --> 00:44:58,340
因此我们再次与我们进行了交谈

1164
00:44:58,340 --> 00:45:00,490
，他们实际上是一流的，

1165
00:45:00,490 --> 00:45:02,870
从性能的角度来看，这是我们

1166
00:45:02,870 --> 00:45:03,470
真的很快

1167
00:45:03,470 --> 00:45:05,390
再次阅读它让您了解

1168
00:45:05,390 --> 00:45:08,600
Andy 的所有订单项目 坏事

1169
00:45:08,600 --> 00:45:09,800
显然是现在我们要

1170
00:45:09,800 --> 00:45:12,380


1171
00:45:12,380 --> 00:45:13,550
一遍又一遍地复制关于这些不同订单项目的一堆信息

1172
00:45:13,550 --> 00:45:16,010
现在我需要编写我的

1173
00:45:16,010 --> 00:45:17,960
应用程序代码以确保

1174
00:45:17,960 --> 00:45:21,680
一切都是我 保持

1175
00:45:21,680 --> 00:45:23,090
所有这些信息的完整性，所以

1176
00:45:23,090 --> 00:45:24,740
如果我更改项目的名称，我必须

1177
00:45:24,740 --> 00:45:26,510
编写代码来检查

1178
00:45:26,510 --> 00:45:27,560
我所有的内部所有客户记录，并确保我

1179
00:45:27,560 --> 00:45:31,550
更新了所有内容，

1180
00:45:31,550 --> 00:45:34,190
以便您对查询的恐慌反应方式是通过 JSON

1181
00:45:34,190 --> 00:45:40,670
只有查询 API 他们没有查询

1182
00:45:40,670 --> 00:45:43,610
优化器，至少在

1183
00:45:43,610 --> 00:45:44,750
我们之前讨论过的调用空间中没有，我

1184
00:45:44,750 --> 00:45:45,650
认为当我们

1185
00:45:45,650 --> 00:45:47,510
谈论查询优化时，他们简要地谈到了我们，所以他们

1186
00:45:47,510 --> 00:45:49,240
基本上做的是让您的查询

1187
00:45:49,240 --> 00:45:52,130
显示 d 他们

1188
00:45:52,130 --> 00:45:54,230
将为给定的查询生成各种可能的组合

1189
00:45:54,230 --> 00:45:56,810
，然后

1190
00:45:56,810 --> 00:45:58,400
用

1191
00:45:58,400 --> 00:46:00,590
该查询的不同组合炸毁每个节点，然后

1192
00:46:00,590 --> 00:46:02,270
无论哪个节点先返回，然后他们就会

1193
00:46:02,270 --> 00:46:04,040
知道这是更好的使用，

1194
00:46:04,040 --> 00:46:05,280
因为它回来了 更快，

1195
00:46:05,280 --> 00:46:06,900
所以下次您实际执行相同的

1196
00:46:06,900 --> 00:46:08,760
查询或类似的查询时，他们只会

1197
00:46:08,760 --> 00:46:10,860
重用他们之前生成的查询计划，他们

1198
00:46:10,860 --> 00:46:13,230
可能会这样做

1199
00:46:13,230 --> 00:46:14,820
一千次，然后在千次

1200
00:46:14,820 --> 00:46:16,530
查询调用之后他们

1201
00:46:16,530 --> 00:46:19,110
会这样做 有点先把

1202
00:46:19,110 --> 00:46:20,850
它们全部炸掉，或者把它们全部炸掉，然后看看哪个

1203
00:46:20,850 --> 00:46:23,850
先回来，所以你可能认为

1204
00:46:23,850 --> 00:46:25,260
这有点老套，我花了两场

1205
00:46:25,260 --> 00:46:26,790
讲座讨论了进行

1206
00:46:26,790 --> 00:46:28,230
基于查询成本的评分优化有多难

1207
00:46:28,230 --> 00:46:31,190
，以及如何进行 很难解决你阿迪的问题

1208
00:46:31,190 --> 00:46:34,230
，他们选择了这个因为在

1209
00:46:34,230 --> 00:46:35,460
他们没有联合的那天，所以你

1210
00:46:35,460 --> 00:46:36,510
不必担心联合所有者他

1211
00:46:36,510 --> 00:46:38,030
基本上只是在选择要使用的索引

1212
00:46:38,030 --> 00:46:40,410
所以随机 walk 方法

1213
00:46:40,410 --> 00:46:43,410
实际上会起作用我认为他们不会

1214
00:46:43,410 --> 00:46:44,910
为连接做任何复杂的事情，现在

1215
00:46:44,910 --> 00:46:46,860
他们可能只使用基本的启发式这个

1216
00:46:46,860 --> 00:46:48,360
表或者这个集合比这个小，

1217
00:46:48,360 --> 00:46:49,680
所以

1218
00:46:49,680 --> 00:46:52,080
一旦内部与外部它们

1219
00:46:52,080 --> 00:46:53,790
支持 JavaScript UDS，它就是一个与阿姨的对比 我们实际上

1220
00:46:53,790 --> 00:46:56,190
在本学期没有讨论 UDS

1221
00:46:56,190 --> 00:46:57,960
它基本上就像一个你可以

1222
00:46:57,960 --> 00:46:59,760
在查询中编写的函数，它

1223
00:46:59,760 --> 00:47:03,240
在数据服务器端被调用，他们现在支持

1224
00:47:03,240 --> 00:47:05,580
连接，他们现在也支持多

1225
00:47:05,580 --> 00:47:08,970
文档事务，尽管早期的

1226
00:47:08,970 --> 00:47:10,290
基准数字 对于 MongoDB 来说

1227
00:47:10,290 --> 00:47:11,640
很棒，就像您

1228
00:47:11,640 --> 00:47:13,800
可以非常快速地将数据写入其中一样，因为他们

1229
00:47:13,800 --> 00:47:14,940
所做的是他们没有进行

1230
00:47:14,940 --> 00:47:17,040
交易，并且当您得到正确成功的回复时，他们实际上并没有

1231
00:47:17,040 --> 00:47:18,660
保证任何内容实际上已

1232
00:47:18,660 --> 00:47:20,550
写入磁盘

1233
00:47:20,550 --> 00:47:23,490


1234
00:47:23,490 --> 00:47:25,260
实际上更糟糕的是，如果

1235
00:47:25,260 --> 00:47:27,000
数据库曾经为您的权利获得过数据包，

1236
00:47:27,000 --> 00:47:28,620
他们会立即

1237
00:47:28,620 --> 00:47:29,730
回来确认并说是的，我们得到了

1238
00:47:29,730 --> 00:47:31,560
它 在稍后的某个时间点会

1239
00:47:31,560 --> 00:47:33,530
采取正确的行动实际上会被执行

1240
00:47:33,530 --> 00:47:36,270
并记录到磁盘中，因此如果您想查看

1241
00:47:36,270 --> 00:47:37,950
您是否正确实际上已将其写入

1242
00:47:37,950 --> 00:47:39,960
磁盘，当您返回响应时，

1243
00:47:39,960 --> 00:47:41,250
您必须再次返回并说 嘿，

1244
00:47:41,250 --> 00:47:43,140
我做对了，没问题，她不得不做

1245
00:47:43,140 --> 00:47:44,370
两次往返，看看你的

1246
00:47:44,370 --> 00:47:46,650
权利是否真的成功

1247
00:47:46,650 --> 00:47:48,240
，这曾经是很长一段时间的默认值，

1248
00:47:48,240 --> 00:47:49,770
所以如果你看看 MongoDB 的早期基准

1249
00:47:49,770 --> 00:47:51,660
数据，

1250
00:47:51,660 --> 00:47:54,960
那么 2013 年或 2012 年他们实际上

1251
00:47:54,960 --> 00:47:57,810
关闭了它，只有默认情况下

1252
00:47:57,810 --> 00:47:58,770
才知道现在他们实际上在做正确

1253
00:47:58,770 --> 00:48:01,890
的日志，我们将讨论一秒钟

1254
00:48:01,890 --> 00:48:03,000
，他们支持

1255
00:48:03,000 --> 00:48:04,050
跨多台机器的多都柏林事务，

1256
00:48:04,050 --> 00:48:06,360
这令人印象深刻，

1257
00:48:06,360 --> 00:48:09,570
这样做并不容易，所以 系统架构我

1258
00:48:09,570 --> 00:48:10,560
想我们之前已经讨论过

1259
00:48:10,560 --> 00:48:12,240
它是一个异构分布式

1260
00:48:12,240 --> 00:48:13,500
组件共享 -

1261
00:48:13,500 --> 00:48:15,450
没有集中查询路由器他们

1262
00:48:15,450 --> 00:48:17,190
正在做主从应用程序你可以

1263
00:48:17,190 --> 00:48:18,720
从

1264
00:48:18,720 --> 00:48:20,340
什么时候开始拥有你的权利 ternode 一个主分区器分

1265
00:48:20,340 --> 00:48:23,010
片会转移到其他分片，所以

1266
00:48:23,010 --> 00:48:24,750
我认为 manga Dini

1267
00:48:24,750 --> 00:48:27,750
在早期非常成功的部分原因是

1268
00:48:27,750 --> 00:48:30,750
他们实际上支持自动分片所以

1269
00:48:30,750 --> 00:48:32,820
这里的想法就像你刚刚

1270
00:48:32,820 --> 00:48:34,580
开始将数据推入你的数据库一样

1271
00:48:34,580 --> 00:48:37,650
，你知道 它将分布在

1272
00:48:37,650 --> 00:48:39,720
多个节点上，但是如果其中一个

1273
00:48:39,720 --> 00:48:41,760
节点太满，桃花心木会

1274
00:48:41,760 --> 00:48:43,680
自动移动您的数据以

1275
00:48:43,680 --> 00:48:46,830
平衡事物，它并不总是

1276
00:48:46,830 --> 00:48:48,150
像人们认为的那样

1277
00:48:48,150 --> 00:48:52,230
工作，但您知道回来 2010 年，当

1278
00:48:52,230 --> 00:48:54,270
我去硅谷时，你会

1279
00:48:54,270 --> 00:48:56,160
问像你一样的人，哦，他们正在

1280
00:48:56,160 --> 00:48:57,359
做一家初创公司，他们基于

1281
00:48:57,359 --> 00:48:59,640
MongoDB，你问他为什么，也许会说哦，

1282
00:48:59,640 --> 00:49:01,020
因为这个自动分

1283
00:49:01,020 --> 00:49:02,760
片对他们来说很重要 因为你

1284
00:49:02,760 --> 00:49:03,900
一开始就知道大多数人

1285
00:49:03,900 --> 00:49:04,950
没有太多数据 因为你知道

1286
00:49:04,950 --> 00:49:05,970
你是初创公司 你有一个愚蠢的

1287
00:49:05,970 --> 00:49:07,619
Twitter 应用程序 没有人使用它 你可以

1288
00:49:07,619 --> 00:49:09,300
在一台机器上运行，但当然没有

1289
00:49:09,300 --> 00:49:10,410
人不使用它 开始吧

1290
00:49:10,410 --> 00:49:11,940
我不认为他们会失败每个人都

1291
00:49:11,940 --> 00:49:13,080
认为他们会变大的一切，所以当然

1292
00:49:13,080 --> 00:49:14,520
我需要你知道未来的 20 台机器，

1293
00:49:14,520 --> 00:49:16,230
所以我想确保 MongoDB

1294
00:49:16,230 --> 00:49:17,910
可以与我的

1295
00:49:17,910 --> 00:49:19,740
续集和 Postgres 一起扩展它 和其他关系

1296
00:49:19,740 --> 00:49:20,940
数据库当时你不能这样做

1297
00:49:20,940 --> 00:49:23,970
，所以我认为这是一个大问题

1298
00:49:23,970 --> 00:49:26,480
但是有一个著名的 Foursquare 中断

1299
00:49:26,480 --> 00:49:28,859
51 它是超级 Foursquare

1300
00:49:28,859 --> 00:49:31,230
想像如何描述

1301
00:49:31,230 --> 00:49:32,640
它它是应用程序，你可以在什么

1302
00:49:32,640 --> 00:49:33,930
位置检查 你在里面它仍然存在，

1303
00:49:33,930 --> 00:49:36,750
但它不是

1304
00:49:36,750 --> 00:49:38,609
每个人都使用的不是电话应用程序，但他们

1305
00:49:38,609 --> 00:49:40,470
使用的是MongoDB，并且有一个著名的

1306
00:49:40,470 --> 00:49:41,940
像你知道的多天中断，

1307
00:49:41,940 --> 00:49:44,570
因为自动分片的东西卡住了，

1308
00:49:44,570 --> 00:49:46,770
所以这里又是架构

1309
00:49:46,770 --> 00:49:48,810
我们之前讨论过这个，我们有

1310
00:49:48,810 --> 00:49:50,250
不同类型的节点类型，我们有

1311
00:49:50,250 --> 00:49:51,599
路由器，我们有配置服务器，我们

1312
00:49:51,599 --> 00:49:53,849
有一个分片，所以来自

1313
00:49:53,849 --> 00:49:55,109
应用程序的每个查询总是转到路由器

1314
00:49:55,109 --> 00:49:57,210
，路由器说哦，我知道我想

1315
00:49:57,210 --> 00:49:58,710
查找 ID 101 但我不知道它

1316
00:49:58,710 --> 00:50:00,510
在哪里的信息所以我

1317
00:50:00,510 --> 00:50:01,800
去配置服务器配置服务器

1318
00:50:01,800 --> 00:50:03,510
告诉我它在图表中查找

1319
00:50:03,510 --> 00:50:05,280
它说你想要的数据是它

1320
00:50:05,280 --> 00:50:07,230
位于它的节点所以现在路由器

1321
00:50:07,230 --> 00:50:08,609
知道了 如何将查询发送到正确的

1322
00:50:08,609 --> 00:50:11,160
位置，或者它可以将其发送给所有人

1323
00:50:11,160 --> 00:50:12,900
，所以这又是

1324
00:50:12,900 --> 00:50:14,160
水肺东西之间的重要区别，

1325
00:50:14,160 --> 00:50:15,780
我们在这里谈论的是水肺不会

1326
00:50:15,780 --> 00:50:17,130
困扰它这个分区或分片

1327
00:50:17,130 --> 00:50:19,760
表它会爆炸 查询 MongoDB 中的每个人，

1328
00:50:19,760 --> 00:50:21,000


1329
00:50:21,000 --> 00:50:22,440
因为您不想浪费资源，

1330
00:50:22,440 --> 00:50:23,460
因为您正在尝试运行您知道

1331
00:50:23,460 --> 00:50:24,930
更新您网站的查询 ISM

1332
00:50:24,930 --> 00:50:26,670
很快，您维护此

1333
00:50:26,670 --> 00:50:27,869
信息以准确

1334
00:50:27,869 --> 00:50:29,160
找出查询需要去的位置，因此您只需要 触摸

1335
00:50:29,160 --> 00:50:30,300
它们 您只触摸您可以做到

1336
00:50:30,300 --> 00:50:34,460
的数据 具有您需要的确切数据 是的

1337
00:50:35,210 --> 00:50:37,290
所以一个问题是它有点

1338
00:50:37,290 --> 00:50:38,730
被路由器捕获 是的 所以就像你不会

1339
00:50:38,730 --> 00:50:40,860
总是这样做 但这将

1340
00:50:40,860 --> 00:50:43,140
是这会考虑的 成为无国籍人，

1341
00:50:43,140 --> 00:50:45,750
所以我 如果我崩溃了我回来了我只是

1342
00:50:45,750 --> 00:50:48,690
再次从中获取我的缓存版本但是任何

1343
00:50:48,690 --> 00:50:50,400
更新都喜欢如果我说我正在做

1344
00:50:50,400 --> 00:50:51,900
自动喊叫的东西并且我添加一个新节点

1345
00:50:51,900 --> 00:50:53,880
将一些数据正确移动到另一个东西

1346
00:50:53,880 --> 00:50:56,040
我更新这个东西 这是作为交易完成的

1347
00:50:56,040 --> 00:51:03,030
是的，这是什么起源，

1348
00:51:03,030 --> 00:51:09,450
你是什么意思哦，命名哦，我

1349
00:51:09,450 --> 00:51:11,460
认为 Mongo 只是意味着 humungous 我

1350
00:51:11,460 --> 00:51:14,190
认为这是对的，所以这

1351
00:51:14,190 --> 00:51:16,470
实际上就像我不知道的那样，

1352
00:51:16,470 --> 00:51:21,080
但是就像 maith 倒退我不知道不是的

1353
00:51:21,110 --> 00:51:24,150
这是这个恶魔或数据是 PI 只是

1354
00:51:24,150 --> 00:51:26,490
恶魔和 Mongo 问我不知道

1355
00:51:26,490 --> 00:51:28,020
那是什么意思是的我不知道问的

1356
00:51:28,020 --> 00:51:34,920
意思所以我在这个学期说的另一件事

1357
00:51:34,920 --> 00:51:37,710
是永远不要使用 MF 为

1358
00:51:37,710 --> 00:51:38,280
您的 Davis

1359
00:51:38,280 --> 00:51:41,100
很好，当 MongoDB 首次

1360
00:51:41,100 --> 00:51:42,600
问世时，他们在他们的 Davis 之后使用 em

1361
00:51:42,600 --> 00:51:46,110
，我们实际上对 MF 数据库系统进行了一些研究，

1362
00:51:46,110 --> 00:51:48,960
在我看来，我们

1363
00:51:48,960 --> 00:51:50,520
还没有发布我们

1364
00:51:50,520 --> 00:51:52,470
使用 MF 的 MongoDB 实现可能是

1365
00:51:52,470 --> 00:51:54,030
我们见过的最复杂

1366
00:51:54,030 --> 00:51:56,370
的可能是 最好的，但

1367
00:51:56,370 --> 00:51:59,610
它仍然很糟糕，它仍然很糟糕，所以

1368
00:51:59,610 --> 00:52:01,530
基本上发生的事情是他们

1369
00:52:01,530 --> 00:52:04,520
使用地图的方式是

1370
00:52:04,520 --> 00:52:06,750
他们基本上会

1371
00:52:06,750 --> 00:52:10,140
在内存中维护数据库的多个副本，你

1372
00:52:10,140 --> 00:52:11,970
会像这样进行更新

1373
00:52:11,970 --> 00:52:13,890
然后将读取

1374
00:52:13,890 --> 00:52:15,330
到磁盘的私有副本，然后您必须重播

1375
00:52:15,330 --> 00:52:17,100
日志以更新主

1376
00:52:17,100 --> 00:52:19,950
副本的类型，因此操作系统可以随时交换内容，

1377
00:52:19,950 --> 00:52:22,050
这对他们来说是一个很大的

1378
00:52:22,050 --> 00:52:24,390
步伐 他们遇到的另一个大问题

1379
00:52:24,390 --> 00:52:25,860
他们是否对数据库有一个单一的锁，

1380
00:52:25,860 --> 00:52:27,240
现在有一个不及时，

1381
00:52:27,240 --> 00:52:28,530
因为他们使用 M map 但我

1382
00:52:28,530 --> 00:52:31,710
认为这可能

1383
00:52:31,710 --> 00:52:34,020
有助于使用 M map 使事情变得更容易，

1384
00:52:34,020 --> 00:52:35,550
这意味着在整个数据库

1385
00:52:35,550 --> 00:52:36,810
系统中，即使你可能

1386
00:52:36,810 --> 00:52:38,760
在早期版本中作为 MongoDB 在多台机器上拆分，

1387
00:52:38,760 --> 00:52:40,020
您一次只能

1388
00:52:40,020 --> 00:52:42,690
在整个集群中拥有一个写入器，

1389
00:52:42,690 --> 00:52:45,000
因此如果我有 20 台机器，我有

1390
00:52:45,000 --> 00:52:46,589
一个查询出现 我基本

1391
00:52:46,589 --> 00:52:48,479
锁定所有 20 台机器以进行更新 其中

1392
00:52:48,479 --> 00:52:51,269
之一，然后在

1393
00:52:51,269 --> 00:52:53,460
从第 3 版开始的较新版本的 Mongo 中，他们摆脱了

1394
00:52:53,460 --> 00:52:54,960
这一点，因此他们最终做的是

1395
00:52:54,960 --> 00:52:58,109
购买了这家

1396
00:52:58,109 --> 00:53:00,359
名为wire Tiger 的存储引擎初创公司，该公司由发明

1397
00:53:00,359 --> 00:53:02,549
伯克利的人之一创立

1398
00:53:02,549 --> 00:53:05,369
DB Berkeley DB 是一个

1399
00:53:05,369 --> 00:53:06,599
针对 Davis 的嵌入式数据库线，

1400
00:53:06,599 --> 00:53:08,339
我们将对此进行过多讨论，

1401
00:53:08,339 --> 00:53:11,609
但最好发布我的续集，这些

1402
00:53:11,609 --> 00:53:13,440
都是像独立恶魔或独立系统一样运行的数据库系统，

1403
00:53:13,440 --> 00:53:15,569


1404
00:53:15,569 --> 00:53:17,249
并且您有多个客户端连接

1405
00:53:17,249 --> 00:53:20,099
它们 Seco light 通常用作

1406
00:53:20,099 --> 00:53:21,509
嵌入式数据库，您将其嵌入到

1407
00:53:21,509 --> 00:53:23,999
您的应用程序中，它为您提供

1408
00:53:23,999 --> 00:53:25,289
数据库功能，但是当您的

1409
00:53:25,289 --> 00:53:26,849
应用程序关闭数据库时

1410
00:53:26,849 --> 00:53:29,069
，为什么 Tiger 有点像 sequel

1411
00:53:29,069 --> 00:53:31,319
light 但它不支持 sequel 它

1412
00:53:31,319 --> 00:53:34,369
像密钥一样支持 价值存储 API 所以

1413
00:53:34,369 --> 00:53:38,400
可能是长期以来最好的收购之一，

1414
00:53:38,400 --> 00:53:40,619
他们买了为什么是老虎

1415
00:53:40,619 --> 00:53:42,239
，他们用线老虎引擎替换了最终地图的东西，

1416
00:53:42,239 --> 00:53:44,400
所以当

1417
00:53:44,400 --> 00:53:46,920
你在运行 MongoDB 时运行，现在

1418
00:53:46,920 --> 00:53:48,869
默认情况下你会得到线类型引擎，这是一个

1419
00:53:48,869 --> 00:53:57,660
令人惊奇的问题，是的，这个问题

1420
00:53:57,660 --> 00:53:59,309
是，如果你认为 MF 如此复杂

1421
00:53:59,309 --> 00:54:04,319
，你为什么要再次使用它，我不能，我

1422
00:54:04,319 --> 00:54:07,049
想科学地证明它我 还

1423
00:54:07,049 --> 00:54:08,279
不能，所以只接受我所说的一切，

1424
00:54:08,279 --> 00:54:11,400
这是我的意见 M 地图就像一个

1425
00:54:11,400 --> 00:54:13,769
诱惑者，对吧，就像这是一个

1426
00:54:13,769 --> 00:54:15,180
性感的东西，它看起来像给了你

1427
00:54:15,180 --> 00:54:16,529
你想要的缓冲池管理器，

1428
00:54:16,529 --> 00:54:18,569
而不必这样做，因为它 操作系统

1429
00:54:18,569 --> 00:54:19,319
为你做这件事你

1430
00:54:19,319 --> 00:54:20,940
不需要操作系统做的驱逐策略

1431
00:54:20,940 --> 00:54:21,839
你不需要担心

1432
00:54:21,839 --> 00:54:24,059
分页你知道跟踪脏

1433
00:54:24,059 --> 00:54:25,170
页面和我认为的事情哦，不是

1434
00:54:25,170 --> 00:54:26,880
这样，所以它看起来像

1435
00:54:26,880 --> 00:54:28,079
它会给你你想要的一切

1436
00:54:28,079 --> 00:54:32,069
但它就像是你真正需要的额外 5%

1437
00:54:32,069 --> 00:54:34,019
真正使它

1438
00:54:34,019 --> 00:54:35,880
耐用和安全 当所有

1439
00:54:35,880 --> 00:54:38,819
问题出现时 所以它有点

1440
00:54:38,819 --> 00:54:39,960
像查询优化器 它是一个藏语

1441
00:54:39,960 --> 00:54:41,160
查询优化器 让我们做点什么

1442
00:54:41,160 --> 00:54:42,509
真的很简单 不要把所有的东西

1443
00:54:42,509 --> 00:54:44,819
都炸掉，看看先回来的是什么 所以设置

1444
00:54:44,819 --> 00:54:45,900
它带有一个缓冲池管理器 我将

1445
00:54:45,900 --> 00:54:46,829
只使用操作系统的

1446
00:54:46,829 --> 00:54:50,719
盈利缓存或 man 地图缓存

1447
00:54:55,110 --> 00:55:00,910
让我们把那个离线 嘿我

1448
00:55:00,910 --> 00:55:03,000
Elliot 我的意思是 L 是一个非常聪明的

1449
00:55:03,000 --> 00:55:07,000
人 联合创始人和我非常

1450
00:55:07,000 --> 00:55:09,040
成功，就像它是一家上市公司一样，

1451
00:55:09,040 --> 00:55:16,270
我想你知道使用

1452
00:55:16,270 --> 00:55:21,250
M 地图虽然它

1453
00:55:21,250 --> 00:55:22,780
会导致问题，但当你真正开始

1454
00:55:22,780 --> 00:55:24,190
尝试扩大规模和扩大规模并锤击

1455
00:55:24,190 --> 00:55:26,650
它允许的系统时可能会导致问题 你可以很快地建立一个

1456
00:55:26,650 --> 00:55:27,370
系统

1457
00:55:27,370 --> 00:55:29,350
，而不是花费六个月的时间

1458
00:55:29,350 --> 00:55:31,000
来开发一个你知道安全和事务性的缓冲区管理器，

1459
00:55:31,000 --> 00:55:32,530


1460
00:55:32,530 --> 00:55:32,950
像这样的事情

1461
00:55:32,950 --> 00:55:36,760
使用你知道的这些操作系统并映射，然后

1462
00:55:36,760 --> 00:55:38,080
当他们有足够的客户时，他们得到了

1463
00:55:38,080 --> 00:55:40,330
足够的钱，他们买了电线 老虎，

1464
00:55:40,330 --> 00:55:44,260
做对了，我的秘密是一样的，

1465
00:55:44,260 --> 00:55:46,120
对，迈克，他没有使用 em 地图，

1466
00:55:46,120 --> 00:55:49,450
请我不认为我的 Siegel 和

1467
00:55:49,450 --> 00:55:51,340
nodb 是惊人的，内部数据库很棒，

1468
00:55:51,340 --> 00:55:53,380
它是一个可靠的数据库引擎存储

1469
00:55:53,380 --> 00:55:57,580
引擎，但是 ori 他们使用的 ginal 引擎

1470
00:55:57,580 --> 00:56:00,100
是我的 ISAM 那个东西很糟糕 那个东西一直

1471
00:56:00,100 --> 00:56:01,750
丢失数据 对你它

1472
00:56:01,750 --> 00:56:04,600
会损坏所以但是它

1473
00:56:04,600 --> 00:56:05,650
让我的 C 启动并运行得非常

1474
00:56:05,650 --> 00:56:07,000
快 很多人都在使用它

1475
00:56:07,000 --> 00:56:09,190
然后最终在 DVD 中 出现了，

1476
00:56:09,190 --> 00:56:10,450
我的续集买断了它们并开始

1477
00:56:10,450 --> 00:56:13,560
使用它，这对戴维斯的业务来说并不是一个非常罕见的

1478
00:56:13,560 --> 00:56:18,910
策略，好吧，

1479
00:56:18,910 --> 00:56:23,290
让我们做一个演示，所以当我们不得不告诉

1480
00:56:23,290 --> 00:56:26,760
你是半非法的时候，

1481
00:56:26,760 --> 00:56:33,359
任何人都在谈论 Mongo 是的，这个

1482
00:56:33,359 --> 00:56:34,650
问题是为什么 您可能希望

1483
00:56:34,650 --> 00:56:39,030
将 Mongo 用于其他人，所以我认为

1484
00:56:39,030 --> 00:56:40,380
处于愚蠢的架构中

1485
00:56:40,380 --> 00:56:42,500
很重要

1486
00:56:42,500 --> 00:56:46,530
文档模型实际上

1487
00:56:46,530 --> 00:56:49,200
更适合应用程序开发 正确

1488
00:56:49,200 --> 00:56:50,609
考虑您在编写 Python

1489
00:56:50,609 --> 00:56:52,380
代码时编写 Java 代码

1490
00:56:52,380 --> 00:56:53,490
object 它是面向对象的

1491
00:56:53,490 --> 00:56:56,880
编程语言，所以

1492
00:56:56,880 --> 00:56:59,430
如果你现在可以将你的对象

1493
00:56:59,430 --> 00:57:01,500
写成一个 JSON 文档，然后

1494
00:57:01,500 --> 00:57:03,390
把 Davis 放回去，

1495
00:57:03,390 --> 00:57:04,560
然后我们在你的 a 中实例化它 应用

1496
00:57:04,560 --> 00:57:08,480
程序代码可能会更快，

1497
00:57:08,480 --> 00:57:10,470
但我要强调的是，

1498
00:57:10,470 --> 00:57:12,869
虽然 MongoDB 正在做什么，但我要强调的是

1499
00:57:12,869 --> 00:57:15,060
，因为它的文档数据库

1500
00:57:15,060 --> 00:57:16,680
系统与

1501
00:57:16,680 --> 00:57:18,839
我们整个学期讨论的任何内容都不同

1502
00:57:18,839 --> 00:57:20,160
为什么累了不知道它

1503
00:57:20,160 --> 00:57:21,960
实际上被用于 一个文档

1504
00:57:21,960 --> 00:57:23,640
数据库系统它

1505
00:57:23,640 --> 00:57:25,770


1506
00:57:25,770 --> 00:57:26,790
正在做的事情正在做日志记录它正在做我们正在做的所有崩溃恢复事情它

1507
00:57:26,790 --> 00:57:28,619
在我们的幕后做交易，

1508
00:57:28,619 --> 00:57:30,589
就像我们谈论的那样，所以

1509
00:57:30,589 --> 00:57:32,730
文档中没有任何内容

1510
00:57:32,730 --> 00:57:35,310
会使我们在这里谈论的任何内容失效或更改

1511
00:57:35,310 --> 00:57:36,990
今天，这一切都在

1512
00:57:36,990 --> 00:57:39,540
应用程序级别，嘿，退出查询的所有类型都是

1513
00:57:39,540 --> 00:57:41,310
客户端级别

1514
00:57:41,310 --> 00:57:42,359
查询实际上

1515
00:57:42,359 --> 00:57:44,280
要做的事情 下面是

1516
00:57:44,280 --> 00:57:45,150
我们整个学期讨论的所有内容

1517
00:57:45,150 --> 00:57:52,290
是的，问题是他们是否使用了

1518
00:57:52,290 --> 00:57:53,369
特殊的压缩敌人，所以 那

1519
00:57:53,369 --> 00:57:55,470
将是wire Tiger 我认为它只是

1520
00:57:55,470 --> 00:58:06,150
活泼 是的 再次是旧

1521
00:58:06,150 --> 00:58:07,650
版本的用户名 默认

1522
00:58:07,650 --> 00:58:09,270
用户名密码测试测试

1523
00:58:09,270 --> 00:58:18,329
不再那样了是的好吧好吧所以

1524
00:58:18,329 --> 00:58:20,609
我们剩下的最后一个是

1525
00:58:20,609 --> 00:58:23,190
cockroach DB 实际上我在

1526
00:58:23,190 --> 00:58:25,109
夏天也在那里所以当我去 Mongo DB

1527
00:58:25,109 --> 00:58:26,910
和 cockroach DB 时他们的总部就

1528
00:58:26,910 --> 00:58:28,859
在 纽约市，所以当我出去

1529
00:58:28,859 --> 00:58:30,839
拜访蟑螂或我同时拜访

1530
00:58:30,839 --> 00:58:32,339
他们两个时，这是

1531
00:58:32,339 --> 00:58:33,540
他们的旧办公室，他们

1532
00:58:33,540 --> 00:58:35,540
为蟑螂屋提供了精美的像素艺术小东西

1533
00:58:35,540 --> 00:58:38,069
，这是他们的新办公室，

1534
00:58:38,069 --> 00:58:39,510
尽管我实际上很惊讶如何 重要的

1535
00:58:39,510 --> 00:58:40,560
是

1536
00:58:40,560 --> 00:58:43,260
我做了一个游戏 我在那里发表了演讲 他们

1537
00:58:43,260 --> 00:58:45,840
刚刚筹集了 5500 万美元作为

1538
00:58:45,840 --> 00:58:47,910
C 轮融资 这

1539
00:58:47,910 --> 00:58:49,770
对一家数据库公司来说是一笔小钱 所以这

1540
00:58:49,770 --> 00:58:52,560
实际上非常令人印象深刻 我怎么认为

1541
00:58:52,560 --> 00:58:54,360
这意味着他们做得很好 这

1542
00:58:54,360 --> 00:58:58,410
很好，所以克拉科夫 HDB 于 2015 年

1543
00:58:58,410 --> 00:59:01,590
由一些 X kugel 员工开始，我认为他们被

1544
00:59:01,590 --> 00:59:03,750
错误地描述为

1545
00:59:03,750 --> 00:59:05,880
开源版本，一个来自

1546
00:59:05,880 --> 00:59:09,330
谷歌扳手的扳手我认为他们从来没有

1547
00:59:09,330 --> 00:59:11,100
说过人们排序 向他们致敬，

1548
00:59:11,100 --> 00:59:12,900
我不会说这是

1549
00:59:12,900 --> 00:59:15,720
真的 蟑螂电视是一种核心

1550
00:59:15,720 --> 00:59:16,890
架构

1551
00:59:16,890 --> 00:59:18,960
与扳手有着根本的不同，扳手有一个神奇的

1552
00:59:18,960 --> 00:59:20,910
部分，没有其他人拥有，

1553
00:59:20,910 --> 00:59:22,440
蟑螂没有，其他人

1554
00:59:22,440 --> 00:59:24,570
没有，所以是分散的

1555
00:59:24,570 --> 00:59:26,760
无共享的同构数据库 ISM

1556
00:59:26,760 --> 00:59:28,650
架构，他们将

1557
00:59:28,650 --> 00:59:31,860
进行范围分区

1558
00:59:31,860 --> 00:59:33,750
他们将使用的内部存储引擎是 Rox

1559
00:59:33,750 --> 00:59:35,280
TB 所以同样的问题是为什么

1560
00:59:35,280 --> 00:59:37,980
有人想要很好地使用 em map 我的

1561
00:59:37,980 --> 00:59:38,970
答案是因为你 不必

1562
00:59:38,970 --> 00:59:41,280
自己构建那部分，所以蟑螂

1563
00:59:41,280 --> 00:59:43,200
GP 他们不会花时间

1564
00:59:43,200 --> 00:59:45,690
编写存储管理器，就像

1565
00:59:45,690 --> 00:59:46,890
您了解 MongoDB 中的电线虎一样，

1566
00:59:46,890 --> 00:59:49,950
因此很多这些较新的数据库

1567
00:59:49,950 --> 00:59:51,360
系统初创公司都在使用岩石 TV

1568
00:59:51,360 --> 00:59:53,310
或 leveldb 这些嵌入式存储

1569
00:59:53,310 --> 00:59:54,810
引擎，因此他们不必

1570
00:59:54,810 --> 00:59:55,980
担心从磁盘正确读取数据

1571
00:59:55,980 --> 00:59:57,780
，他们担心

1572
00:59:57,780 --> 00:59:59,130
像您知道的那样管理

1573
00:59:59,130 --> 01:00:02,070
事务的高级部分 trivet 环境所以

1574
01:00:02,070 --> 01:00:03,780
他们会做多虚拟

1575
01:00:03,780 --> 01:00:05,360
但乐观你知道乐观的

1576
01:00:05,360 --> 01:00:08,460
商业协议我知道但这

1577
01:00:08,460 --> 01:00:09,750
仍然是真的但他们只会

1578
01:00:09,750 --> 01:00:11,540
支持可序列化的快照隔离

1579
01:00:11,540 --> 01:00:14,270
所以我不认为他们支持

1580
01:00:14,270 --> 01:00:17,670
其他助手 隔离级别 他们

1581
01:00:17,670 --> 01:00:20,040
也使用 Postgres 线路协议，

1582
01:00:20,040 --> 01:00:21,120
这意味着如果您有一个现有的

1583
01:00:21,120 --> 01:00:23,790
后测试应用程序，您可以在

1584
01:00:23,790 --> 01:00:26,970
理论上将其指向 cockroach DB，

1585
01:00:26,970 --> 01:00:28,590
现在您将

1586
01:00:28,590 --> 01:00:30,030
数据位迁移到 cockroach DB 而

1587
01:00:30,030 --> 01:00:33,000
您没有 必须潜在地改变

1588
01:00:33,000 --> 01:00:35,670
任何续集它并不完全适用于

1589
01:00:35,670 --> 01:00:36,780
所有事情，例如有一些不同的东西，

1590
01:00:36,780 --> 01:00:38,880
如自动增量键，

1591
01:00:38,880 --> 01:00:40,650
但总的来说它正在迁移到

1592
01:00:40,650 --> 01:00:43,290
蟑螂，即使 Postgres 不

1593
01:00:43,290 --> 01:00:46,980
应该成为所有者，所以它的核心

1594
01:00:46,980 --> 01:00:49,170
蟑螂 GB 是 一个分布式的键值

1595
01:00:49,170 --> 01:00:50,850
存储事务属性键值

1596
01:00:50,850 --> 01:00:52,470
存储，这意味着在rocks TB系统的下层

1597
01:00:52,470 --> 01:00:54,780
存储引擎

1598
01:00:54,780 --> 01:00:56,850
是一个键值系统但是

1599
01:00:56,850 --> 01:00:58,350
那么他们进行交易

1600
01:00:58,350 --> 01:01:00,570
的方式或者他们

1601
01:01:00,570 --> 01:01:02,010
跨多台机器管理数据库的方式

1602
01:01:02,010 --> 01:01:03,570
本质上只是一个键值

1603
01:01:03,570 --> 01:01:06,540
存储，所以现在使用它他们可以

1604
01:01:06,540 --> 01:01:09,180
在上面构建层来提供

1605
01:01:09,180 --> 01:01:10,950
完整的续集 兼容性，

1606
01:01:10,950 --> 01:01:13,080
你会想要的，所以一旦你

1607
01:01:13,080 --> 01:01:15,360
过去了，就像续集查询出现，他们

1608
01:01:15,360 --> 01:01:17,340
就可以转换续集查询，

1609
01:01:17,340 --> 01:01:18,960
查询计划本质上将是

1610
01:01:18,960 --> 01:01:22,230
一堆键值 API 调用，

1611
01:01:22,230 --> 01:01:23,850
然后可以从不同的地方读取和写入数据

1612
01:01:23,850 --> 01:01:27,720
节点，因此他们将

1613
01:01:27,720 --> 01:01:30,030
在整个系统中协调更新的

1614
01:01:30,030 --> 01:01:33,030
方式是使用 raft raft 本质

1615
01:01:33,030 --> 01:01:34,590
上处于较高级别，这与 paxos 相同，

1616
01:01:34,590 --> 01:01:37,170
它是一种共识协议，

1617
01:01:37,170 --> 01:01:38,970
允许我在进行更新时说

1618
01:01:38,970 --> 01:01:40,590
我想提交

1619
01:01:40,590 --> 01:01:42,240
跨多个 Sheen 的交易每个人都会

1620
01:01:42,240 --> 01:01:45,030
同意或法定人数必须同意

1621
01:01:45,030 --> 01:01:47,820
更新允许进行或发生

1622
01:01:47,820 --> 01:01:49,920
，以便该交易

1623
01:01:49,920 --> 01:01:53,790
能够提交，以便他们将要进行的方式 o

1624
01:01:53,790 --> 01:01:58,080
OCC 是通过使用时间戳，它

1625
01:01:58,080 --> 01:02:01,200
使用的是所谓的混合时钟，所以我

1626
01:02:01,200 --> 01:02:02,070
想我谈了一点这个，

1627
01:02:02,070 --> 01:02:04,020
或者 Prashant Agra 这个我们谈到的

1628
01:02:04,020 --> 01:02:07,170
时间不是推测我们需要一种

1629
01:02:07,170 --> 01:02:08,850
方法来拥有一个时钟，我们可以让你

1630
01:02:08,850 --> 01:02:10,710
核识别每笔交易 并且

1631
01:02:10,710 --> 01:02:12,270
该时钟需要始终

1632
01:02:12,270 --> 01:02:13,650
不断增加，因此我们知道

1633
01:02:13,650 --> 01:02:15,750
序列化中的哪些事务将作为他们的

1634
01:02:15,750 --> 01:02:16,830
颈部解决方案进行排序，哪些事务

1635
01:02:16,830 --> 01:02:19,980
在另一个事务之前出现，因此您可以

1636
01:02:19,980 --> 01:02:21,390


1637
01:02:21,390 --> 01:02:23,130
像我一样使用从实际 CPU 中知道的物理时钟 一

1638
01:02:23,130 --> 01:02:24,510
台机器本身 什么是系统时间

1639
01:02:24,510 --> 01:02:26,670
但问题在于它

1640
01:02:26,670 --> 01:02:28,230
不能保证

1641
01:02:28,230 --> 01:02:30,170
在多台机器之间高度同步

1642
01:02:30,170 --> 01:02:34,170
因为每台计算机都有一个

1643
01:02:34,170 --> 01:02:36,150
时钟 时钟不是超级精确

1644
01:02:36,150 --> 01:02:38,700
它不像原子钟，这

1645
01:02:38,700 --> 01:02:40,140
可以 意思是你知道计算

1646
01:02:40,140 --> 01:02:43,050
一个原子的电子数，它会是

1647
01:02:43,050 --> 01:02:44,520
某种石英晶体的东西，它

1648
01:02:44,520 --> 01:02:46,290
必须近似，所以现在你可以有

1649
01:02:46,290 --> 01:02:48,240
一堆歪斜的 找到你的时钟，所以

1650
01:02:48,240 --> 01:02:49,350
现在可能发生的事情是你知道

1651
01:02:49,350 --> 01:02:51,240
一个节点上的事务上升它认为

1652
01:02:51,240 --> 01:02:52,890
它是时间戳 1 另一个交易

1653
01:02:52,890 --> 01:02:54,330
上升另一个节点它认为它是

1654
01:02:54,330 --> 01:02:57,980
时间戳 1 现在我有一个冲突我有

1655
01:02:57,980 --> 01:03:00,840
一个复杂的馅饼我 已经

1656
01:03:00,840 --> 01:03:02,820
解决了，所以他们将

1657
01:03:02,820 --> 01:03:04,230
通过混合时钟来处理这个问题

1658
01:03:04,230 --> 01:03:06,090
，您仍然会使用系统时钟

1659
01:03:06,090 --> 01:03:08,250
来尝试获取当前时间，

1660
01:03:08,250 --> 01:03:09,900
但是您还使用了一个逻辑时钟

1661
01:03:09,900 --> 01:03:12,330
，允许您进行全局排序

1662
01:03:12,330 --> 01:03:13,440
交易而不必

1663
01:03:13,440 --> 01:03:15,630
每次都同步，所以

1664
01:03:15,630 --> 01:03:16,710
基本上拿了一个小日历，上面

1665
01:03:16,710 --> 01:03:18,660
写着我当前的时间戳，我

1666
01:03:18,660 --> 01:03:21,030
只是我的机器会向磁盘

1667
01:03:21,030 --> 01:03:23,420
不合逻辑的计数器添加一个以增加它，

1668
01:03:23,420 --> 01:03:26,270
所以会发生在 OCC

1669
01:03:26,270 --> 01:03:27,930
交易下所有这些

1670
01:03:27,930 --> 01:03:29,640
权利和 系统说这些是

1671
01:03:29,640 --> 01:03:30,750
我想要做的修改是的

1672
01:03:30,750 --> 01:03:37,320
问题他的问题是混合

1673
01:03:37,320 --> 01:03:38,460
时钟与谷歌消费

1674
01:03:38,460 --> 01:03:42,380
时钟有什么不同谷歌扳手时钟

1675
01:03:42,380 --> 01:03:44,840
不是谷歌时钟 处理

1676
01:03:44,840 --> 01:03:47,270
我不太了解扳手

1677
01:03:47,270 --> 01:03:52,520
Google 扳手依靠

1678
01:03:52,520 --> 01:03:55,170
港口时钟来获得

1679
01:03:55,170 --> 01:03:56,550
在所有机器上同步的超准确时间

1680
01:03:56,550 --> 01:03:59,550
，真实时间 API 为

1681
01:03:59,550 --> 01:04:02,520
您提供了我们必须等待多长时间的界限

1682
01:04:02,520 --> 01:04:03,599
对于某人以较低的

1683
01:04:03,599 --> 01:04:06,450
时间戳出现，这是一种基本上

1684
01:04:06,450 --> 01:04:09,030
就像真实时间一样但

1685
01:04:09,030 --> 01:04:12,780
仅使用软件的方法，因此如果您的时钟漂移非常糟糕，

1686
01:04:12,780 --> 01:04:14,490
例如一台机器

1687
01:04:14,490 --> 01:04:15,900
比另一台机器晚一小时，则没有

1688
01:04:15,900 --> 01:04:17,609
交易可能会

1689
01:04:17,609 --> 01:04:19,650
完整，因为 你是的，每笔

1690
01:04:19,650 --> 01:04:20,550
交易都认为他们

1691
01:04:20,550 --> 01:04:22,859
过去会在未来搞砸，所以你

1692
01:04:22,859 --> 01:04:25,230
必须确保你尝试

1693
01:04:25,230 --> 01:04:27,109
将时钟保持在接收器中，就像 NTP

1694
01:04:27,109 --> 01:04:29,130
扳手不这样做那样扳手

1695
01:04:29,130 --> 01:04:30,869
你知道 GPS 卫星

1696
01:04:30,869 --> 01:04:32,790
加上原子锁，它们具有超

1697
01:04:32,790 --> 01:04:39,089
细粒度，所以又

1698
01:04:39,089 --> 01:04:41,190
不同于水肺所有

1699
01:04:41,190 --> 01:04:42,420
关于数据存在位置的元数据

1700
01:04:42,420 --> 01:04:44,700
当Vista存在于它们的o中时事务状态是什么

1701
01:04:44,700 --> 01:04:46,020
wn 键值存储也是如此，

1702
01:04:46,020 --> 01:04:48,690
这都被认为是事务，所以

1703
01:04:48,690 --> 01:04:50,609
让我们在这里看一个简单的例子，所以

1704
01:04:50,609 --> 01:04:53,280
我们有我们的应用程序

1705
01:04:53,280 --> 01:04:54,990
，可能是更新数据和这个

1706
01:04:54,990 --> 01:04:58,380
Klosterman 再次与 scuba 不同，

1707
01:04:58,380 --> 01:04:59,790
我们维护一个分区表，

1708
01:04:59,790 --> 01:05:01,560
就像 MongoDB 一样 跟踪哪个节点

1709
01:05:01,560 --> 01:05:05,160
负责什么范围的数据，所以

1710
01:05:05,160 --> 01:05:07,109
当我的查询出现时，第一件事

1711
01:05:07,109 --> 01:05:10,619
就像咨询是我的这个分区

1712
01:05:10,619 --> 01:05:11,910
表，它实际上会

1713
01:05:11,910 --> 01:05:14,640
在每台机器上复制，并说我

1714
01:05:14,640 --> 01:05:17,970
想访问密钥或 ID 等于 50 什么

1715
01:05:17,970 --> 01:05:20,099
机器什么节点是领导者

1716
01:05:20,099 --> 01:05:21,060


1717
01:05:21,060 --> 01:05:22,860
然后在这种情况下是这个人

1718
01:05:22,860 --> 01:05:25,170
所以现在我的权利必须去这里你

1719
01:05:25,170 --> 01:05:27,660
我的更新然后更新必须

1720
01:05:27,660 --> 01:05:29,760
传播到其他节点然后

1721
01:05:29,760 --> 01:05:32,400
我们使用筏 为了让每个人都

1722
01:05:32,400 --> 01:05:33,660
同意我们将继续并提交

1723
01:05:33,660 --> 01:05:35,330
此事务，

1724
01:05:35,330 --> 01:05:39,390
所以他们只是使用 raft 而不是使用两阶段

1725
01:05:39,390 --> 01:05:41,700
提交，所以现在如果

1726
01:05:41,700 --> 01:05:43,350
我想这样做，我会读到

1727
01:05:43,350 --> 01:05:46,110
这个 ID 为 150 好吧，我总是会

1728
01:05:46,110 --> 01:05:48,450
去这个人所在的领导者那里，

1729
01:05:48,450 --> 01:05:51,150
即使我

1730
01:05:51,150 --> 01:05:52,770
在不同的笔记上有多个数据副本，

1731
01:05:52,770 --> 01:05:55,440
理论上我可以在这些

1732
01:05:55,440 --> 01:05:57,240
其他节点上阅读，但我总是想

1733
01:05:57,240 --> 01:05:59,700
在领导者身上做我的阅读 确保我

1734
01:05:59,700 --> 01:06:01,230
读的最多，你知道它的最

1735
01:06:01,230 --> 01:06:02,820
一致或最新版本，

1736
01:06:02,820 --> 01:06:04,650
因为也许这些其他节点还没有

1737
01:06:04,650 --> 01:06:06,840
看到最新的更新，因为你

1738
01:06:06,840 --> 01:06:08,490
和一个筏你只需要一个法定人数你

1739
01:06:08,490 --> 01:06:10,140
不需要 需要让每个节点都同意

1740
01:06:10,140 --> 01:06:11,550
这是不同的你知道贝叶斯

1741
01:06:11,550 --> 01:06:13,320
委员会每个人你总是

1742
01:06:13,320 --> 01:06:14,910
需要一个法定人数所以一些节点可能

1743
01:06:14,910 --> 01:06:16,560
落后但你仍然被允许

1744
01:06:16,560 --> 01:06:18,720
提交事务以便处理

1745
01:06:18,720 --> 01:06:20,160
所有读取总是会去

1746
01:06:20,160 --> 01:06:21,840
无论领导节点是用于 ID

1747
01:06:21,840 --> 01:06:25,290
还是避免让每个查询都只

1748
01:06:25,290 --> 01:06:27,420
针对一个节点，这就是为什么我们有这个

1749
01:06:27,420 --> 01:06:28,620
表来告诉我们哪个

1750
01:06:28,620 --> 01:06:30,030
是领导者，我们将把它

1751
01:06:30,030 --> 01:06:31,590
分布在多个节点上，所以来宾

1752
01:06:31,590 --> 01:06:33,840
所以 读取然后可以分散

1753
01:06:33,840 --> 01:06:39,360
再次在多台机器上重复它只是

1754
01:06:39,360 --> 01:06:41,880
在执行共识协议

1755
01:06:41,880 --> 01:06:43,860
我们

1756
01:06:43,860 --> 01:06:47,160
在学期中讨论的复制复制权限很难

1757
01:06:47,160 --> 01:06:48,990
所以核心概念没有任何错误

1758
01:06:48,990 --> 01:06:50,610
手臂不会令人兴奋

1759
01:06:50,610 --> 01:06:51,510
与我们已经说过的没有显着不同

1760
01:06:51,510 --> 01:06:53,220
谈到困难的部分是工程

1761
01:06:53,220 --> 01:06:55,710
使其真正起作用，这

1762
01:06:55,710 --> 01:06:56,700
就是你所知道的，这就是他们

1763
01:06:56,700 --> 01:06:58,290
花费所有时间来实现的，

1764
01:06:58,290 --> 01:07:00,270
这样你就不会知道失去

1765
01:07:00,270 --> 01:07:01,860
权利或缺少更新之类的

1766
01:07:01,860 --> 01:07:07,560
事情，好吧 是的，让我们结束吧

1767
01:07:07,560 --> 01:07:11,160
，希望我

1768
01:07:11,160 --> 01:07:13,320
在整个学期都传达了我喜欢

1769
01:07:13,320 --> 01:07:14,370
数据库的信息，他们很棒

1770
01:07:14,370 --> 01:07:15,900
Joran 打他你会

1771
01:07:15,900 --> 01:07:17,670
在你的余生中打他，

1772
01:07:17,670 --> 01:07:19,650
所以希望这门课程

1773
01:07:19,650 --> 01:07:23,150
为你提供的是能力 说你知道

1774
01:07:23,150 --> 01:07:25,020
我们的应用程序中的某些东西运行缓慢，

1775
01:07:25,020 --> 01:07:26,520
因为它是数据库

1776
01:07:26,520 --> 01:07:28,350
我正在运行什么样的数据库系统

1777
01:07:28,350 --> 01:07:30,000
我的数据是

1778
01:07:30,000 --> 01:07:31,800
什么样的 我的查询看起来像什么

1779
01:07:31,800 --> 01:07:33,060
您现在

1780
01:07:33,060 --> 01:07:34,590


1781
01:07:34,590 --> 01:07:36,060
是否应该就这些系统的工作方式做出明智的决定，以及

1782
01:07:36,060 --> 01:07:37,290
您是否知道您正在

1783
01:07:37,290 --> 01:07:38,820
为给定的

1784
01:07:38,820 --> 01:07:40,250
应用程序或工作负载环境选择

1785
01:07:40,250 --> 01:07:42,750
正确的数据库系统，因为不是每个人都会

1786
01:07:42,750 --> 01:07:45,540
去构建数据库系统，但我

1787
01:07:45,540 --> 01:07:46,980
保证 你不管你做什么，

1788
01:07:46,980 --> 01:07:48,990
特别是你的意思是，即使你不

1789
01:07:48,990 --> 01:07:50,100
留在技术领域，

1790
01:07:50,100 --> 01:07:51,210
你也会

1791
01:07:51,210 --> 01:07:54,390
像 Excel 一样跨数据库 chrome 是一个数据库我说我们正在

1792
01:07:54,390 --> 01:07:57,260
使用 Excel 你正在使用一个数据库

1793
01:07:57,260 --> 01:07:59,730
等等 我还要说的是

1794
01:07:59,730 --> 01:08:02,400
，这非常重要的是，我会

1795
01:08:02,400 --> 01:08:04,980
在决定使用哪个数据系统时避免过早的优化，

1796
01:08:04,980 --> 01:08:07,980
总是从

1797
01:08:07,980 --> 01:08:10,950


1798
01:08:10,950 --> 01:08:12,270
可能满足您现在需要的东西开始

1799
01:08:12,270 --> 01:08:14,220
，不要担心您知道

1800
01:08:14,220 --> 01:08:15,480
潜在的扩展 直到你知道

1801
01:08:15,480 --> 01:08:17,460
未来有数百万用户

1802
01:08:17,460 --> 01:08:18,420
好吧 那有点像我妈妈会成为

1803
01:08:18,420 --> 01:08:20,069
榜样 每个人都说 哦我的创业公司

1804
01:08:20,069 --> 01:08:21,120
会很庞大 我没有一百万

1805
01:08:21,120 --> 01:08:22,589
客户 我当然想向你

1806
01:08:22,589 --> 01:08:24,510
展示广告 可以扩展的 atabase

1807
01:08:24,510 --> 01:08:25,920
一开始就知道你可能只是

1808
01:08:25,920 --> 01:08:27,569
在一个盒子上使用 Postgres 或我的续集

1809
01:08:27,569 --> 01:08:29,850
，这会让你知道

1810
01:08:29,850 --> 01:08:31,170
也许在接下来的两年里它会足够好

1811
01:08:31,170 --> 01:08:32,460
，但也许你会买一些更好的

1812
01:08:32,460 --> 01:08:33,839
硬件 并

1813
01:08:33,839 --> 01:08:36,330
随着您的域的增加而扩大一点，但不要

1814
01:08:36,330 --> 01:08:37,560
担心引入分布式系统，

1815
01:08:37,560 --> 01:08:38,939
因为这会带来

1816
01:08:38,939 --> 01:08:40,200
您现在可能需要的更多复杂性

1817
01:08:40,200 --> 01:08:41,939
您应该关注是什么让您的

1818
01:08:41,939 --> 01:08:42,930
应用程序您知道您的

1819
01:08:42,930 --> 01:08:45,390
应用程序需要什么 成功了，所以人们经常

1820
01:08:45,390 --> 01:08:46,680
问

1821
01:08:46,680 --> 01:08:48,420
我，如果我正在构建一个

1822
01:08:48,420 --> 01:08:50,100
应用程序，我应该从什么数据库系统开始，我的兴趣进展或我的

1823
01:08:50,100 --> 01:08:53,490
续集，你知道 99% 的应用

1824
01:08:53,490 --> 01:08:55,890
程序已经足够好了，因为

1825
01:08:55,890 --> 01:08:57,630
如果你的应用程序确实

1826
01:08:57,630 --> 01:08:58,890
爆炸了，将会发生什么 你有很多

1827
01:08:58,890 --> 01:09:02,010
客户你有什么钱

1828
01:09:02,010 --> 01:09:04,620
所以现在你可以付钱给我来告诉

1829
01:09:04,620 --> 01:09:06,720
你如何扩展你的数据库，

1830
01:09:06,720 --> 01:09:09,750
或者我的一个学生，这样

1831
01:09:09,750 --> 01:09:12,089
避免你知道介绍

1832
01:09:12,089 --> 01:09:14,220
通过引入一个你知道用你不需要的数据库系统来增加新的复杂性，

1833
01:09:14,220 --> 01:09:16,380


1834
01:09:16,380 --> 01:09:18,210
比如

1835
01:09:18,210 --> 01:09:19,979
从 Amazon RDS 开始可能是一个不错的

1836
01:09:19,979 --> 01:09:21,270
选择，然后你只需扩展并

1837
01:09:21,270 --> 01:09:24,450
购买更大的即时大小，然后添加

1838
01:09:24,450 --> 01:09:26,640
Azure 作为你的 随着您的数据量

1839
01:09:26,640 --> 01:09:30,420
越来越大或您的需求增长 好吧 任何

1840
01:09:30,420 --> 01:09:32,750
问题是

1841
01:09:32,750 --> 01:09:35,788


1842
01:09:35,788 --> 01:09:43,828


1843
01:09:43,828 --> 01:09:50,689


1844
01:09:50,689 --> 01:09:58,639


1845
01:09:58,639 --> 01:10:01,889
的 我是我孩子的父亲

1846
01:10:01,889 --> 01:10:07,500
是 99.999999 8% 所以有

1847
01:10:07,500 --> 01:10:09,449
一个零零零零零到

1848
01:10:09,449 --> 01:10:10,769
百分之二的机会它不是我的，

1849
01:10:10,769 --> 01:10:12,869
但在这一点上我已经接受了我的脚

1850
01:10:12,869 --> 01:10:16,369
，这绝对是我的孩子

1851
01:10:17,960 --> 01:10:22,380
好吧，是的，这是

1852
01:10:22,380 --> 01:10:34,409
我的，好吧，伙计们，所以我

1853
01:10:34,409 --> 01:10:37,110
周一期末考试见

1854
01:10:37,110 --> 01:10:39,269


1855
01:10:39,269 --> 01:10:40,920


1856
01:10:40,920 --> 01:10:42,630


1857
01:10:42,630 --> 01:10:45,449
和他的

1858
01:10:45,449 --> 01:10:46,320
时间在一起 斯宾塞 好吧

1859
01:10:46,320 --> 01:10:49,699
好吧 伙计们

1860
01:10:58,950 --> 01:11:01,780
在我的系统中小心机智的夜晚我很

1861
01:11:01,780 --> 01:11:02,320
幸运

1862
01:11:02,320 --> 01:11:09,760
让我们去下一个到达那里

1863
01:11:09,760 --> 01:11:12,040
将会有太阳弹跳果冻撞到熟食店

1864
01:11:12,040 --> 01:11:14,440
为一艘船自然祝福你我的

1865
01:11:14,440 --> 01:11:16,000
说唱就像激光束在毛孔中

1866
01:11:16,000 --> 01:11:18,220
灌木丛说，甚至连链条都没有 把

1867
01:11:18,220 --> 01:11:20,230
我们的瓶子包裹起来 一个很好的同情去

1868
01:11:20,230 --> 01:11:22,420
不要感觉像喝醉酒一样

1869
01:11:22,420 --> 01:11:24,430
喝醉 你不能放下十字架 他还活着

1870
01:11:24,430 --> 01:11:26,050
，如果不知道你的手机

1871
01:11:26,050 --> 01:11:29,010
可以敲痛

