1
00:00:03,640 --> 00:00:13,140
[音乐]

2
00:00:13,959 --> 00:00:18,350
好吧，让我们开始吧，你

3
00:00:18,350 --> 00:00:21,580
需要放下桌子作为回，谢谢

4
00:00:21,580 --> 00:00:23,990
你解决了你所有的问题

5
00:00:23,990 --> 00:00:27,090
[掌声]

6
00:00:31,150 --> 00:00:36,170
是的，好的，你知道你不想

7
00:00:36,170 --> 00:00:38,960
在那条船上，这太糟糕了，

8
00:00:38,960 --> 00:00:41,780
其他的一切都好，我是说你还在 会有

9
00:00:41,780 --> 00:00:42,890
三个女朋友 或者你尝试

10
00:00:42,890 --> 00:00:50,870
回来一个半 什么是一半

11
00:00:50,870 --> 00:00:53,510
好吧好吧好吧

12
00:00:53,510 --> 00:00:55,640
所以我们有很多 我想

13
00:00:55,640 --> 00:00:58,129
今天有很多事情要

14
00:00:58,129 --> 00:01:00,050
在我们进入课程之前很快

15
00:01:00,050 --> 00:01:02,539
谈论 今天的讲座所以这是

16
00:01:02,539 --> 00:01:05,480
本学期每个人的最后一份摘要

17
00:01:05,480 --> 00:01:07,280
这是

18
00:01:07,280 --> 00:01:08,840
你必须完成的所有项目 3

19
00:01:08,840 --> 00:01:11,180
显然是昨晚交的作业 5

20
00:01:11,180 --> 00:01:14,030
今天应该出去，这

21
00:01:14,030 --> 00:01:17,450
将在 12 月 3 日的两周内完成，非常

22
00:01:17,450 --> 00:01:19,610
适合 这个周末会出去

23
00:01:19,610 --> 00:01:22,729
，这将在 12 月 10 日到期，

24
00:01:22,729 --> 00:01:24,229
额外的学分也将在 12 月 10 日到期

25
00:01:24,229 --> 00:01:26,329
，然后我们会有检查点

26
00:01:26,329 --> 00:01:27,530
，我将在下一张幻灯片中讨论，

27
00:01:27,530 --> 00:01:30,130
然后期末考试是在星期一

28
00:01:30,130 --> 00:01:33,560
12 月 9 日 5:3 下午 0 点 不是在这个

29
00:01:33,560 --> 00:01:34,970
房间里 我不知道他们会把我们放在哪个房间

30
00:01:34,970 --> 00:01:36,399


31
00:01:36,399 --> 00:01:41,329
但这是一个 suti 时间 所以

32
00:01:41,329 --> 00:01:43,009
也许我们会做的是新糖果 新

33
00:01:43,009 --> 00:01:44,060
披萨或类似的东西

34
00:01:44,060 --> 00:01:47,119
在

35
00:01:47,119 --> 00:01:51,320
这些事情中，

36
00:01:51,320 --> 00:01:54,950
还有其他一些漂浮的事情，我们

37
00:01:54,950 --> 00:01:57,110
还有另外三场 I'm Convio

38
00:01:57,110 --> 00:01:59,420
讲座，但就像

39
00:01:59,420 --> 00:02:03,020
本周关于材料的课程主题讲座，然后

40
00:02:03,020 --> 00:02:05,450
是下周的一节课，然后当我们

41
00:02:05,450 --> 00:02:07,579
从努力中回来时

42
00:02:07,579 --> 00:02:10,399
12 月 2 日星期一的感恩节假期，我们

43
00:02:10,399 --> 00:02:11,840
在 Oracle 的朋友将来

44
00:02:11,840 --> 00:02:15,500
谈论他们正在做的事情，

45
00:02:15,500 --> 00:02:19,700
这又

46
00:02:19,700 --> 00:02:20,810
不像一场讲座，在那里

47
00:02:20,810 --> 00:02:22,160
你知道而不是我在谈论

48
00:02:22,160 --> 00:02:23,030
材料 他们会谈论

49
00:02:23,030 --> 00:02:24,470
相同的材料 他们实际上会

50
00:02:24,470 --> 00:02:26,390
谈论他们在小组中构建的内容

51
00:02:26,390 --> 00:02:28,490
，你会看到它如何将

52
00:02:28,490 --> 00:02:30,200


53
00:02:30,200 --> 00:02:30,980
我们整个学期谈论的所有事情联系

54
00:02:30,980 --> 00:02:34,130
在一起 薄的 g

55
00:02:34,130 --> 00:02:36,560
上周的第二堂课我做了

56
00:02:36,560 --> 00:02:38,660
两件事，一是我们会做最后的系统

57
00:02:38,660 --> 00:02:41,060
审查，第二是

58
00:02:41,060 --> 00:02:44,569
我称之为系统杂烩，

59
00:02:44,569 --> 00:02:46,190
如果你想让我谈论任何系统

60
00:02:46,190 --> 00:02:48,110
，比如 10 或 15 分钟教

61
00:02:48,110 --> 00:02:49,850
你它是如何工作的以及

62
00:02:49,850 --> 00:02:51,950
它为什么有趣你知道并使用

63
00:02:51,950 --> 00:02:53,060
我们

64
00:02:53,060 --> 00:02:55,340
整个学期讨论的白话我们将

65
00:02:55,340 --> 00:02:58,010
在这个 URL 上在线投票它只是一个

66
00:02:58,010 --> 00:03:00,080
谷歌表格，你去选择

67
00:03:00,080 --> 00:03:02,390
无论你想让我介绍 10

68
00:03:02,390 --> 00:03:04,970
或 15 分钟的任何系统都可以，所以我们通常有

69
00:03:04,970 --> 00:03:07,700
时间做三到四个，

70
00:03:07,700 --> 00:03:10,340
所以我在这里展示的列表是当

71
00:03:10,340 --> 00:03:14,090
你进入谷歌表单时，它

72
00:03:14,090 --> 00:03:17,810
是系统 过去两个月观看次数最多的 DVD DVD 视频网站

73
00:03:17,810 --> 00:03:19,610
，

74
00:03:19,610 --> 00:03:23,030
因此它们按此

75
00:03:23,030 --> 00:03:24,440
顺序排列，但您不一定

76
00:03:24,440 --> 00:03:26,239
必须知道遵循该顺序，但

77
00:03:26,239 --> 00:03:27,829
DVD 上还有另一个网站，我

78
00:03:27,829 --> 00:03:29,030
哦，我们 想要涵盖

79
00:03:29,030 --> 00:03:30,709
不在该列表中的内容，只是您知道 在你

80
00:03:30,709 --> 00:03:34,130
甚至可以输入好的，你可以回到

81
00:03:34,130 --> 00:03:36,290
去年看看我涵盖的内容，但我

82
00:03:36,290 --> 00:03:37,579
鼓励你在投票之前不要这样做

83
00:03:37,579 --> 00:03:39,799
你不想让

84
00:03:39,799 --> 00:03:42,350
你的偏见对你有所帮助，无论人们做什么

85
00:03:42,350 --> 00:03:44,360
去年做的，因为我总是很

86
00:03:44,360 --> 00:03:45,500
好奇，看看你们是什么样的人，

87
00:03:45,500 --> 00:03:46,850
是的，我们已经报道了一些错过的帖子，

88
00:03:46,850 --> 00:03:48,260
我们报道了我的单一甲骨文

89
00:03:48,260 --> 00:03:50,840
和续集，更容易

90
00:03:50,840 --> 00:03:51,890
看到你们在互联网上看到的东西，

91
00:03:51,890 --> 00:03:53,359
或者 你想在

92
00:03:53,359 --> 00:03:56,840
你的工作或爱好项目中做什么，我们知道

93
00:03:56,840 --> 00:03:57,890
你一直在使用什么系统

94
00:03:57,890 --> 00:03:59,090
，我可以来教你

95
00:03:59,090 --> 00:04:03,040
它是什么以及它是如何工作的，

96
00:04:03,040 --> 00:04:05,630
好吧，然后再次获得额外的信用

97
00:04:05,630 --> 00:04:08,480
反馈 你可以

98
00:04:08,480 --> 00:04:11,540
在 11 月 24 日的这个星期天提交你的额外信用文章

99
00:04:11,540 --> 00:04:14,180
，然后我

100
00:04:14,180 --> 00:04:15,650
和 TAS 会给你反馈并说明

101
00:04:15,650 --> 00:04:16,970
你做对了什么

102
00:04:16,970 --> 00:04:19,130
你做错了，这样你就可以及时

103
00:04:19,130 --> 00:04:21,019
修复它 这个任务

104
00:04:21,019 --> 00:04:24,560
所以他们确实得到了充分的信任

105
00:04:24,560 --> 00:04:26,630
关于这些事情中的任何一个的问题，所以

106
00:04:26,630 --> 00:04:27,710
我会设定一个截止日期，

107
00:04:27,710 --> 00:04:29,599
如果你显然

108
00:04:29,599 --> 00:04:30,890
不能在讲座前一天投票，

109
00:04:30,890 --> 00:04:31,909
因为那样我没有时间让你

110
00:04:31,909 --> 00:04:33,560
肯定地准备它，或者也许

111
00:04:33,560 --> 00:04:34,689
感恩节那一周

112
00:04:34,689 --> 00:04:38,979
我们在伦敦做了这

113
00:04:38,979 --> 00:04:41,439
件事，最后一件事是，除了

114
00:04:41,439 --> 00:04:46,599
在

115
00:04:46,599 --> 00:04:49,389
12 月 3 日星期二的

116
00:04:49,389 --> 00:04:51,759
12 月 3 日进行关于 ii 的课堂讲座，12 月第三本书还将

117
00:04:51,759 --> 00:04:54,639
进行研究生水平的研究报告

118
00:04:54,639 --> 00:04:56,349
在 CIC 大楼的 PTO，我认为

119
00:04:56,349 --> 00:04:59,099
他们也在

120
00:04:59,099 --> 00:05:01,509
周一和周一下午进行本科生演讲，

121
00:05:01,509 --> 00:05:02,949
所以我在两天内进行了三场甲骨文演讲

122
00:05:02,949 --> 00:05:04,719
，你知道其中一个你

123
00:05:04,719 --> 00:05:06,339
需要来或不需要，但是

124
00:05:06,339 --> 00:05:07,869


125
00:05:07,869 --> 00:05:09,489
如果你到了，你会在期末考试中获得额外的学分，然后这些

126
00:05:09,489 --> 00:05:14,139
补习是可选的，好吧，任何

127
00:05:14,139 --> 00:05:20,159
问题，我们几乎都答对了，所以

128
00:05:20,159 --> 00:05:24,069
今天的课程现在是

129
00:05:24,069 --> 00:05:26,019
我们讨论分布式数据库的开始

130
00:05:26,019 --> 00:05:28,659
，正如我上次所说的 类 ss 我们

131
00:05:28,659 --> 00:05:30,519
实际上你不知道之前我们只是你

132
00:05:30,519 --> 00:05:31,959
知道整齐地跳入分布式

133
00:05:31,959 --> 00:05:34,149
数据库我们不得不花几个星期

134
00:05:34,149 --> 00:05:36,369
我们已经过去了这个学期到目前为止

135
00:05:36,369 --> 00:05:38,349
了解单节点数据库

136
00:05:38,349 --> 00:05:40,779
系统是如何工作的，因为现在我们

137
00:05:40,779 --> 00:05:42,789
开始 分布式你知道仅仅因为

138
00:05:42,789 --> 00:05:44,409
我们有更多的机器或更多的硬件

139
00:05:44,409 --> 00:05:46,749
并不能神奇地使我们的系统更

140
00:05:46,749 --> 00:05:49,989
容易构建或者更好吗？

141
00:05:49,989 --> 00:05:51,429


142
00:05:51,429 --> 00:05:53,079


143
00:05:53,079 --> 00:05:54,339
系统，

144
00:05:54,339 --> 00:05:55,719
实际上它们更难，因为现在

145
00:05:55,719 --> 00:05:57,879
你必须考虑网络所以

146
00:05:57,879 --> 00:05:59,619
我们之前已经讨论过这个，

147
00:05:59,619 --> 00:06:01,419
当我们谈论查询执行时

148
00:06:01,419 --> 00:06:03,309
，并行

149
00:06:03,309 --> 00:06:05,050
数据库和分布式数据库

150
00:06:05,050 --> 00:06:07,329
系统之间的对比，当我谈论并行时

151
00:06:07,329 --> 00:06:08,919
数据库系统 我们只是

152
00:06:08,919 --> 00:06:11,050
假设数据库系统运行

153
00:06:11,050 --> 00:06:13,779
在一个可能有多个

154
00:06:13,779 --> 00:06:16,449
内核和多个 CPU 的机器上，然后我们

155
00:06:16,449 --> 00:06:18,219
假设

156
00:06:18,219 --> 00:06:20,319
执行查询可以

157
00:06:20,319 --> 00:06:21,669
非常快速地相互

158
00:06:21,669 --> 00:06:23,800
通信，并且这种通信是可靠的，因为如果

159
00:06:23,800 --> 00:06:25,179
您在同一台物理机器上运行，

160
00:06:25,179 --> 00:06:27,339
您将通过

161
00:06:27,339 --> 00:06:29,319
CPU 套接字之间的互连发送数据，

162
00:06:29,319 --> 00:06:32,259
速度非常快，但现在在

163
00:06:32,259 --> 00:06:34,300
数据库系统中我们仍然处于剥离状态 你必须

164
00:06:34,300 --> 00:06:35,589
知道我们仍然

165
00:06:35,589 --> 00:06:37,119
关心如何进行并行执行，但

166
00:06:37,119 --> 00:06:39,039
现在我们可能在

167
00:06:39,039 --> 00:06:42,610
多台机器上这样做，所以现在我们实际上

168
00:06:42,610 --> 00:06:45,279
需要注意它的

169
00:06:45,279 --> 00:06:47,939
成本是多少以及

170
00:06:47,939 --> 00:06:49,949
一个工人通信的可靠性 与另一个

171
00:06:49,949 --> 00:06:51,809
工人，因为它正在通过

172
00:06:51,809 --> 00:06:53,189
网络，你知道其他工人

173
00:06:53,189 --> 00:06:54,499
可能不在同一个数据中心

174
00:06:54,499 --> 00:06:56,610
正确的采矿在同一个大陆上遇见你

175
00:06:56,610 --> 00:06:59,459
，所以现在我们不能

176
00:06:59,459 --> 00:07:01,949
假设你知道我们在断头台那里发送消息

177
00:07:01,949 --> 00:07:04,499


178
00:07:04,499 --> 00:07:05,999
当我们开始

179
00:07:05,999 --> 00:07:07,110
谈论交易和其他

180
00:07:07,110 --> 00:07:11,759
事情时，那会出现问题，所以正如我所说的 Shiva

181
00:07:11,759 --> 00:07:13,110
DNA 的东西，我们可以谈论 s

182
00:07:13,110 --> 00:07:15,569
今天开始，它建立在

183
00:07:15,569 --> 00:07:17,849
我们已经讨论过的所有事情的基础上，所以我们

184
00:07:17,849 --> 00:07:19,110
仍然需要做日志记录我们的东西来做

185
00:07:19,110 --> 00:07:21,059
一个同意 toe hoodoo 查询

186
00:07:21,059 --> 00:07:22,769
优化我们必须做查询

187
00:07:22,769 --> 00:07:25,349
执行来做潜在的连接所有

188
00:07:25,349 --> 00:07:27,869
那些我们仍然需要做的事情 在

189
00:07:27,869 --> 00:07:29,550
属性数据库中做，现在它们只是

190
00:07:29,550 --> 00:07:30,869
一切都更贵了一切

191
00:07:30,869 --> 00:07:35,789
都变得更难了所以对于今天的讲座，正如我

192
00:07:35,789 --> 00:07:37,199
所说的今天的

193
00:07:37,199 --> 00:07:40,189
分布式数据库介绍只是为了了解

194
00:07:40,189 --> 00:07:42,360
您知道它们的实际外观

195
00:07:42,360 --> 00:07:44,309
它们的不同设计

196
00:07:44,309 --> 00:07:46,699
之一 这些设计的含义，

197
00:07:46,699 --> 00:07:48,929
然后我们将讨论如何进行

198
00:07:48,929 --> 00:07:50,519
分区，这是

199
00:07:50,519 --> 00:07:53,009
我们将数据库划分为

200
00:07:53,009 --> 00:07:55,139
多个资源以获得

201
00:07:55,139 --> 00:07:56,399
我们在分布式环境中想要的并行性的关键方式

202
00:07:56,399 --> 00:07:58,499
，然后我们将

203
00:07:58,499 --> 00:08:01,769
简要地结束 谈到

204
00:08:01,769 --> 00:08:03,740
分布式并发控制有多难，

205
00:08:03,740 --> 00:08:06,300
然后将进入周三的

206
00:08:06,300 --> 00:08:07,349
课程，在那里我们将用一整天的时间

207
00:08:07,349 --> 00:08:09,180
讨论我们如何实际做到这

208
00:08:09,180 --> 00:08:11,159
一点 再次，就像我们仍然会潜在地进行

209
00:08:11,159 --> 00:08:12,360
面部阻塞一样，我们仍然

210
00:08:12,360 --> 00:08:14,039
会进行时间戳排序

211
00:08:14,039 --> 00:08:15,419
我们在单行系统上所做的所有事情

212
00:08:15,419 --> 00:08:16,949
仍然适用于现在它正在

213
00:08:16,949 --> 00:08:18,809
分发它所以它更难了

214
00:08:18,809 --> 00:08:21,869
，再次停下来提问 随着我们的

215
00:08:21,869 --> 00:08:25,499
进展，我们需要讨论的第一件事

216
00:08:25,499 --> 00:08:27,300
是数据库系统的系统架构是什么

217
00:08:27,300 --> 00:08:29,879
，

218
00:08:29,879 --> 00:08:31,889
正如我之前所说，当我们谈论

219
00:08:31,889 --> 00:08:33,360
并行系统时，我们谈到

220
00:08:33,360 --> 00:08:37,289
了这些工作人员

221
00:08:37,289 --> 00:08:39,750
通常与任一进程相关联 或者

222
00:08:39,750 --> 00:08:41,639
在 CPU 上运行的线程，

223
00:08:41,639 --> 00:08:44,519
它们将访问共享资源，

224
00:08:44,519 --> 00:08:49,290
如磁盘和内存，因此

225
00:08:49,290 --> 00:08:51,600
我们在城市环境中的数据库系统设计

226
00:08:51,600 --> 00:08:53,009
取决于我们的

227
00:08:53,009 --> 00:08:55,259
架构是正确的，

228
00:08:55,259 --> 00:08:58,139
这些架构的变化将在方式上

229
00:08:58,139 --> 00:09:00,240
有所不同 您实际上可以在并行运行查询或事务时协调

230
00:09:00,240 --> 00:09:01,680
CPU 并与每个 CPU 进行通信，

231
00:09:01,680 --> 00:09:03,360


232
00:09:03,360 --> 00:09:05,550
以及

233
00:09:05,550 --> 00:09:07,170
内存在哪里以及

234
00:09:07,170 --> 00:09:11,970
在 co 中错位的位置 与 CPU 相关联，

235
00:09:11,970 --> 00:09:13,410
所以到目前为止，我们整个

236
00:09:13,410 --> 00:09:14,820
学期所讨论的内容是所谓的共享

237
00:09:14,820 --> 00:09:17,040
一切系统，假设这是一个

238
00:09:17,040 --> 00:09:20,190
单一的盒子，一个具有 CPU 和 CPU 的单个机架单元

239
00:09:20,190 --> 00:09:22,380
具有本地内存和内存，

240
00:09:22,380 --> 00:09:24,120
并且您知道有一个本地

241
00:09:24,120 --> 00:09:26,130
您现在可以随时读写的磁盘

242
00:09:26,130 --> 00:09:27,750
我想访问

243
00:09:27,750 --> 00:09:29,399
我们基于的二项式体系结构中的某些

244
00:09:29,399 --> 00:09:30,899
内容 无论如何我将从磁盘中获取某些内容

245
00:09:30,899 --> 00:09:32,640
我必须将它带到我的缓冲池

246
00:09:32,640 --> 00:09:35,580
到内存中，然后我的 上面

247
00:09:35,580 --> 00:09:37,350
运行在我的 CPU 上的工人可以读写

248
00:09:37,350 --> 00:09:39,270
两件事 读写两页 然后

249
00:09:39,270 --> 00:09:41,339
我让你再次将它们写出磁盘

250
00:09:41,339 --> 00:09:43,950


251
00:09:43,950 --> 00:09:45,510


252
00:09:45,510 --> 00:09:47,640


253
00:09:47,640 --> 00:09:51,240


254
00:09:51,240 --> 00:09:53,070
分布式环境

255
00:09:53,070 --> 00:09:54,750
中的替代方案是一种称为共享内存的替代方案

256
00:09:54,750 --> 00:09:57,360
，这里的想法是您将拥有

257
00:09:57,360 --> 00:09:59,910
多个

258
00:09:59,910 --> 00:10:00,930
可能在不同机器上运行的 CPU 资源，

259
00:10:00,930 --> 00:10:03,589
但存在

260
00:10:03,589 --> 00:10:06,089
通信 允许他们

261
00:10:06,089 --> 00:10:08,940
在所有这些机器上有一个统一的内存视图

262
00:10:08,940 --> 00:10:11,580
假设这是

263
00:10:11,580 --> 00:10:13,170
某种高速互连，

264
00:10:13,170 --> 00:10:15,240
如 InfiniBand 或 tcp/ip

265
00:10:15,240 --> 00:10:16,320
没关系 高级架构

266
00:10:16,320 --> 00:10:18,510
仍然是相同的 然后仍然存在

267
00:10:18,510 --> 00:10:20,400
成为一些本地或启动

268
00:10:20,400 --> 00:10:21,600
一些共享磁盘，每个人都在

269
00:10:21,600 --> 00:10:25,860
阅读运行我说通常是

270
00:10:25,860 --> 00:10:27,810
剧透，实际上这实际上不是

271
00:10:27,810 --> 00:10:28,800
我不知道它们的任何数据库

272
00:10:28,800 --> 00:10:30,240
实际上是商业或

273
00:10:30,240 --> 00:10:32,310
开源的，实际上使用

274
00:10:32,310 --> 00:10:33,750
这种架构 主要出现在

275
00:10:33,750 --> 00:10:35,640
HPC 或高性能计算世界中

276
00:10:35,640 --> 00:10:36,900


277
00:10:36,900 --> 00:10:39,270
，就像在大型国家实验室中运行超级计算机的人一样，

278
00:10:39,270 --> 00:10:42,270
他们构建软件并假设

279
00:10:42,270 --> 00:10:44,370
这种数据库模型

280
00:10:44,370 --> 00:10:47,730
没有太多另一种方法是

281
00:10:47,730 --> 00:10:51,060
共享磁盘和想法 这里是

282
00:10:51,060 --> 00:10:53,579
CPU 工作人员是在 CPU 上运行的工作人员，

283
00:10:53,579 --> 00:10:57,570
他们拥有本地内存，但

284
00:10:57,570 --> 00:10:59,190
在我们维护

285
00:10:59,190 --> 00:11:01,050
数据库持久状态的磁盘上 这是

286
00:11:01,050 --> 00:11:03,870
一些 scrum 共享架构共享

287
00:11:03,870 --> 00:11:06,959
设备，所有这些 CPU 都可以读取

288
00:11:06,959 --> 00:11:09,839
和写入，如果

289
00:11:09,839 --> 00:11:11,339
您在 Amazon 上运行，很高兴想到这一点，

290
00:11:11,339 --> 00:11:15,480
这类似于 s3 或 BBS 或 HDFS 以及

291
00:11:15,480 --> 00:11:17,519
某种分布式文件系统，因此所有

292
00:11:17,519 --> 00:11:19,230
的 CPU 仍然看到

293
00:11:19,230 --> 00:11:22,680
同一个磁盘，但为了让它们

294
00:11:22,680 --> 00:11:23,820
相互通信，它们可能必须

295
00:11:23,820 --> 00:11:24,959


296
00:11:24,959 --> 00:11:27,420
在它们之间来回发送消息，因为它们你知道

297
00:11:27,420 --> 00:11:29,040
这个 CPU 无法读取这个 CPU 的内存，

298
00:11:29,040 --> 00:11:33,660
最后一个架构是什么 大多数

299
00:11:33,660 --> 00:11:34,740
人在想到数据库时会

300
00:11:34,740 --> 00:11:36,510
想到将

301
00:11:36,510 --> 00:11:39,360
要共享的东西——无意义的意思是每个

302
00:11:39,360 --> 00:11:42,449
工人都在一个孤岛上运行，

303
00:11:42,449 --> 00:11:44,850
它有自己的本地内存，

304
00:11:44,850 --> 00:11:47,670
有自己的本地磁盘，唯一

305
00:11:47,670 --> 00:11:49,800
要协调的波 在不同的工作人员之间，

306
00:11:49,800 --> 00:11:52,709
它上升到上面并在

307
00:11:52,709 --> 00:11:54,110
您认识的用户处使用

308
00:11:54,110 --> 00:11:58,110
顶部的某种消息结构进行通信，因此这里的

309
00:11:58,110 --> 00:12:00,149
CPU 工作人员再次无法从中读取内存或

310
00:12:00,149 --> 00:12:02,519
磁盘，并且任何位都无法对其

311
00:12:02,519 --> 00:12:06,870
n 进行动画处理 集群中的邻居或朋友，所以

312
00:12:06,870 --> 00:12:07,980
我们将

313
00:12:07,980 --> 00:12:11,610
再次在共享内存下逐一检查，正如我

314
00:12:11,610 --> 00:12:14,279
所说，这在数据库中并不常见

315
00:12:14,279 --> 00:12:16,290
我不知道

316
00:12:16,290 --> 00:12:18,630
人们实际使用的任何系统

317
00:12:18,630 --> 00:12:22,260
基于 这个和基本的想法是

318
00:12:22,260 --> 00:12:24,690
，数据库系统服务运行

319
00:12:24,690 --> 00:12:27,510
在这些不同的 CPU 上，它运行

320
00:12:27,510 --> 00:12:29,940
在同一个操作系统实例中，并

321
00:12:29,940 --> 00:12:33,149
假设它有一个单一的全局地址

322
00:12:33,149 --> 00:12:35,279
空间，可能只是在

323
00:12:35,279 --> 00:12:39,060
不同的机器上聚合，然后有一些

324
00:12:39,060 --> 00:12:40,260
网络层允许它们

325
00:12:40,260 --> 00:12:41,519
来回传递消息以

326
00:12:41,519 --> 00:12:43,019
使其正常工作 所以这可能

327
00:12:43,019 --> 00:12:45,630
是 InfiniBand 这可能是 tcp/ip 这

328
00:12:45,630 --> 00:12:48,209
可能是英特尔的全向路径 好吧

329
00:12:48,209 --> 00:12:51,899
它们之间的一些快速互连 所以

330
00:12:51,899 --> 00:12:54,959
在这个世界中，数据库

331
00:12:54,959 --> 00:12:56,579
实例运行在一个 CPU 上 它就像

332
00:12:56,579 --> 00:12:59,190
工人知道其他工人一样，所以

333
00:12:59,190 --> 00:13:00,510
如果他们想彼此交流，

334
00:13:00,510 --> 00:13:02,190
他们可以做你

335
00:13:02,190 --> 00:13:03,209
通常在共享一切

336
00:13:03,209 --> 00:13:05,310
系统中做的事情 m 您可以将某些内容写入

337
00:13:05,310 --> 00:13:08,190
全局数据结构或

338
00:13:08,190 --> 00:13:11,790
通过 IPC 发送消息，并且您知道在

339
00:13:11,790 --> 00:13:13,319


340
00:13:13,319 --> 00:13:14,940
另一台另一台机器上运行的其他工作人员的其他进程会

341
00:13:14,940 --> 00:13:17,819
在共享所有系统的上下文中再次看到该权限，

342
00:13:17,819 --> 00:13:19,800
当

343
00:13:19,800 --> 00:13:21,269
如果我们

344
00:13:21,269 --> 00:13:23,279
想告诉另一个工人，嘿我

345
00:13:23,279 --> 00:13:26,459
持有这个元组的锁，我们正在做基础锁定，我

346
00:13:26,459 --> 00:13:28,500
向我的锁表中添加一个条目，该条目位于

347
00:13:28,500 --> 00:13:29,190
内存中，

348
00:13:29,190 --> 00:13:31,440
所以如果我一个工人

349
00:13:31,440 --> 00:13:33,629
坐起来获取锁，这里也是一样 一个元组只是

350
00:13:33,629 --> 00:13:36,209
更新全局锁表，

351
00:13:36,209 --> 00:13:38,670
然后消息传递结构

352
00:13:38,670 --> 00:13:39,839
保证所有这些工作人员之间的一切都是一致的，

353
00:13:39,839 --> 00:13:43,949
因为我

354
00:13:43,949 --> 00:13:46,230
说这并不常见我不

355
00:13:46,230 --> 00:13:49,259
知道是否有人真的这样做了

356
00:13:49,259 --> 00:13:51,720
更常见的 是共享磁盘，

357
00:13:51,720 --> 00:13:53,189
这里的想法是我们有这些

358
00:13:53,189 --> 00:13:56,430
计算节点，它们有自己的本地

359
00:13:56,430 --> 00:13:59,129
内存，它们也可以在那里有一个磁盘，

360
00:13:59,129 --> 00:14:02,519
但这不是

361
00:14:02,519 --> 00:14:04,350
任何类型数据的最终存储位置

362
00:14:04,350 --> 00:14:05,790
您可以将数据库用于

363
00:14:05,790 --> 00:14:07,259
缓存，以防万一您需要将

364
00:14:07,259 --> 00:14:09,389
磁盘溢出到本地计算机上，但

365
00:14:09,389 --> 00:14:11,670
数据库的最终休息

366
00:14:11,670 --> 00:14:14,040
位置在此处，所以如果我说

367
00:14:14,040 --> 00:14:16,259
我将一个页面放入

368
00:14:16,259 --> 00:14:18,629
本地内存中的缓冲池中说 我修改它，然后

369
00:14:18,629 --> 00:14:19,560
我要把它写出来，因为它

370
00:14:19,560 --> 00:14:21,149
很脏我会把它写在这里到

371
00:14:21,149 --> 00:14:23,129
共享磁盘，现在可能任何

372
00:14:23,129 --> 00:14:26,399
其他工作人员都可以看到我的更改，

373
00:14:26,399 --> 00:14:28,199
你如何协调这将确保

374
00:14:28,199 --> 00:14:29,610
他们被告知 更改

375
00:14:29,610 --> 00:14:33,990
将在稍后进行，所以正如我所说，

376
00:14:33,990 --> 00:14:36,089
这就是当今云环境中的现有架构，

377
00:14:36,089 --> 00:14:38,459
因为

378
00:14:38,459 --> 00:14:40,259
磁盘将成为您知道

379
00:14:40,259 --> 00:14:43,050
Amazon 提供的东西，例如 s3 EBS，因此您可以使用

380
00:14:43,050 --> 00:14:45,420
几乎所有类型的云原生数据库

381
00:14:45,420 --> 00:14:47,519
系统

382
00:14:47,519 --> 00:14:49,370
听说将运行此环境，

383
00:14:49,370 --> 00:14:52,139
因为您可以获得的一大优势

384
00:14:52,139 --> 00:14:55,259
是您能够分别扩展计算

385
00:14:55,259 --> 00:14:57,000
资源和磁盘资源，

386
00:14:57,000 --> 00:15:00,839
因为计算资源

387
00:15:00,839 --> 00:15:02,910
是无状态的 数据库的

388
00:15:02,910 --> 00:15:05,639
大部分都在这里，所以如果这些所有这些

389
00:15:05,639 --> 00:15:08,189
计算资源都崩溃并消失了我的

390
00:15:08,189 --> 00:15:10,350
你知道假设我知道

391
00:15:10,350 --> 00:15:12,899
正确地将事情注销一切都还在

392
00:15:12,899 --> 00:15:14,579
这里然后我可以调出另一个

393
00:15:14,579 --> 00:15:17,430
实例并拿起其他

394
00:15:17,430 --> 00:15:20,370
人的地方 离开之后，我们将看到

395
00:15:20,370 --> 00:15:23,730
在无共享环境中这不是那么容易做到，

396
00:15:23,730 --> 00:15:25,649
因为每个

397
00:15:25,649 --> 00:15:29,009
节点每个节点都持有状态，所以让我们

398
00:15:29,009 --> 00:15:30,540
再次看一个像这样的高级示例，

399
00:15:30,540 --> 00:15:32,279
这样我们就有了我们的应用程序服务器，它

400
00:15:32,279 --> 00:15:34,860
会发送 对这些前端

401
00:15:34,860 --> 00:15:36,689
计算节点的请求，这就是我们

402
00:15:36,689 --> 00:15:38,699
在 CP us 和本地内存上运行工作程序

403
00:15:38,699 --> 00:15:40,410
的地方，然后我们有一些

404
00:15:40,410 --> 00:15:43,170
后端存储设备

405
00:15:43,170 --> 00:15:45,029
，每个人都可以正确读取 - 所以

406
00:15:45,029 --> 00:15:46,679
假设应用程序说我

407
00:15:46,679 --> 00:15:49,649
想要获得记录 101，它会转到这个

408
00:15:49,649 --> 00:15:51,899
节点，但是它知道

409
00:15:51,899 --> 00:15:54,329
应用程序如何知道如何转到

410
00:15:54,329 --> 00:15:56,189
这个节点将在一秒钟内覆盖，但

411
00:15:56,189 --> 00:15:58,889
假设它这样做了，那么这会说

412
00:15:58,889 --> 00:16:00,209
某种书上说好的记录

413
00:16:00,209 --> 00:16:02,579
101  如果我查看我的索引，我会看到

414
00:16:02,579 --> 00:16:04,799
它在页面 ABC 中，所以我转到我的共享

415
00:16:04,799 --> 00:16:07,259
磁盘存储，然后我说让我找到页面 ABC，

416
00:16:07,259 --> 00:16:09,059
然后我把它带到我的酒吧，

417
00:16:09,059 --> 00:16:11,069
这个家伙想要 200 他没有

418
00:16:11,069 --> 00:16:12,660
它在它的 缓冲池，所以它从

419
00:16:12,660 --> 00:16:16,769
磁盘中取出并取出它，所以现在如果我

420
00:16:16,769 --> 00:16:20,160
想扩展计算资源，

421
00:16:20,160 --> 00:16:21,869
因为数据库的状态

422
00:16:21,869 --> 00:16:25,499
总是在自己的共享磁盘上我

423
00:16:25,499 --> 00:16:27,809
可以给他带来一个我没有的新人

424
00:16:27,809 --> 00:16:29,220
立即复制任何内容，

425
00:16:29,220 --> 00:16:33,209
因为如果我现在请求说 101 相同的

426
00:16:33,209 --> 00:16:34,769
事情，我只需转到磁盘并将其

427
00:16:34,769 --> 00:16:37,619
带回我的缓冲池，我可以

428
00:16:37,619 --> 00:16:44,189
为请求提供棘手的服务，抱歉，是的，

429
00:16:44,189 --> 00:16:45,119
问题是锁定方式

430
00:16:45,119 --> 00:16:48,389
如何在这样的设置中工作，并且 然后

431
00:16:48,389 --> 00:16:49,910
我们将讨论这个是的 还

432
00:16:49,910 --> 00:16:52,019
没有减少简单性 我们正在谈论我们

433
00:16:52,019 --> 00:16:55,669
现在如何获得东西 是的

434
00:16:59,920 --> 00:17:01,369
[掌声]

435
00:17:01,369 --> 00:17:04,709
是的 所以这个问题是在共享

436
00:17:04,709 --> 00:17:06,898
内存架构中，这

437
00:17:06,898 --> 00:17:08,970
与共享多路多插槽

438
00:17:08,970 --> 00:17:11,699
多处理器有什么不同 一切系统

439
00:17:11,699 --> 00:17:14,159
他们都一样，但想想像 所以

440
00:17:14,159 --> 00:17:20,309
有一些

441
00:17:20,309 --> 00:17:23,579
分布式系统具有

442
00:17:23,579 --> 00:17:25,459
跨多个物理机器的统一内存

443
00:17:25,459 --> 00:17:27,720
所以每台机器都有自己的主板

444
00:17:27,720 --> 00:17:30,029
有它自己的物理物理

445
00:17:30,029 --> 00:17:31,950
内存 它可以是正确的 但

446
00:17:31,950 --> 00:17:33,539
有一个层可以说明

447
00:17:33,539 --> 00:17:35,850
一切 处理器认为他们有

448
00:17:35,850 --> 00:17:38,029
这个巨大的内存块

449
00:17:38,029 --> 00:17:40,110
没有人为数据库这样做，你

450
00:17:40,110 --> 00:17:41,760
看到在 HPC 世界中，就像所有这些人

451
00:17:41,760 --> 00:17:43,679
所做的核弹或粒子

452
00:17:43,679 --> 00:17:45,539
物理模拟一样，他们正在编写

453
00:17:45,539 --> 00:17:47,250
那些 Fortran 程序，假设他们

454
00:17:47,250 --> 00:17:50,340
没有 TB 级的内存 跨

455
00:17:50,340 --> 00:17:52,110
烟雾机的内存 他们可以

456
00:17:52,110 --> 00:17:55,399
对是的进行计算

457
00:17:55,490 --> 00:18:05,490
你来的意思是像这个

458
00:18:05,490 --> 00:18:07,980
问题的公司是如果你放大这样的共享磁盘

459
00:18:07,980 --> 00:18:09,870
架构 如果数据库

460
00:18:09,870 --> 00:18:12,600
供应商 davison 供应商正在使用共享

461
00:18:12,600 --> 00:18:15,960
磁盘架构，这是否意味着

462
00:18:15,960 --> 00:18:18,390
他们要么必须拥有

463
00:18:18,390 --> 00:18:22,039
数据库的所有数据都在一个位置

464
00:18:22,039 --> 00:18:28,830
不好，我们会再次

465
00:18:28,830 --> 00:18:30,120
讨论这个

466
00:18:30,120 --> 00:18:33,120
问题 zh_cn 磁盘的物理和物理

467
00:18:33,120 --> 00:18:35,309
位置以及逻辑位置

468
00:18:35,309 --> 00:18:37,320
这些人

469
00:18:37,320 --> 00:18:40,110
对这些东西的正确位置一无所知所以

470
00:18:40,110 --> 00:18:42,659
就像它只是说嘿这是这个文件我

471
00:18:42,659 --> 00:18:44,130


472
00:18:44,130 --> 00:18:46,500
可以像你一样读写 它是一个本地磁盘，

473
00:18:46,500 --> 00:18:49,860
以防万一 Amazon 或 Azure 你像

474
00:18:49,860 --> 00:18:52,440
一个基于块或基于对象的 API 给我

475
00:18:52,440 --> 00:18:54,870
这个存储桶 给我那个存储桶

476
00:18:54,870 --> 00:18:56,700
Nats 发送一个宁静的类去

477
00:18:56,700 --> 00:18:58,260
一些你不知道的后端服务

478
00:18:58,260 --> 00:19:13,350
数据实际上在哪里 是的 是的

479
00:19:13,350 --> 00:19:16,049
所以我们也会解决这个问题 所以他的

480
00:19:16,049 --> 00:19:18,570
问题在我的例子中 当我

481
00:19:18,570 --> 00:19:21,690
在这个例子中发送这个请求时

482
00:19:21,690 --> 00:19:24,090
我这个应用程序说

483
00:19:24,090 --> 00:19:25,440
我要去这个节点 拿到这张

484
00:19:25,440 --> 00:19:28,080
唱片 你可以在它

485
00:19:28,080 --> 00:19:30,539
前面放一些东西 可以隐藏它 或者这

486
00:19:30,539 --> 00:19:31,950
东西可以保持说去哪里

487
00:19:31,950 --> 00:19:34,760
得到我需要的东西 我们会来

488
00:19:34,760 --> 00:19:37,020
的 我要在这里关注的第三

489
00:19:37,020 --> 00:19:40,409
件事就像它 就像这个家伙

490
00:19:40,409 --> 00:19:42,030
除了在

491
00:19:42,030 --> 00:19:43,740
它的 buff 中之外没有数据库的状态 呃池，但这不

492
00:19:43,740 --> 00:19:46,440
被认为是好的，不要

493
00:19:46,440 --> 00:19:47,789
考虑你知道它的持久性或

494
00:19:47,789 --> 00:19:49,770
持久性是短暂的所以这家伙

495
00:19:49,770 --> 00:19:52,650
崩溃了我们在这里拥有的任何东西它会

496
00:19:52,650 --> 00:19:54,740
消失

497
00:19:56,000 --> 00:19:57,960
所以现在

498
00:19:57,960 --> 00:20:00,420
如果我正确进行更新那么棘手的事情将会是更新

499
00:20:00,420 --> 00:20:04,260
页面 101 小时先生 101 的 ID 记录我

500
00:20:04,260 --> 00:20:07,710
必须更新页面 ABC 这些人都

501
00:20:07,710 --> 00:20:10,260
读取了相同的记录，他们拥有页面 ABC

502
00:20:10,260 --> 00:20:13,080
和缓冲池，但他们

503
00:20:13,080 --> 00:20:15,540
不会知道这些链，

504
00:20:15,540 --> 00:20:16,980
因为这些共享磁盘架构

505
00:20:16,980 --> 00:20:19,680
他们不知道 提供一个通知说

506
00:20:19,680 --> 00:20:24,210
嘿，顺便说一句有人更新了这个，所以

507
00:20:24,210 --> 00:20:26,940
我必须在我的膝盖笔记中有额外的消息

508
00:20:26,940 --> 00:20:29,370
说嘿，我认为你有

509
00:20:29,370 --> 00:20:32,010
页面 EBC，我刚刚修改了它

510
00:20:32,010 --> 00:20:33,510
，这是最新版本，或者如果

511
00:20:33,510 --> 00:20:34,260
你要找到 最新

512
00:20:34,260 --> 00:20:36,440
版本是什么来问我关于

513
00:20:36,440 --> 00:20:38,790
它的所有内容，这就是我们必须

514
00:20:38,790 --> 00:20:40,980
在我们的数据库系统中构建的所有内容，这

515
00:20:40,980 --> 00:20:44,190
只是阅读写到某个桌子上，

516
00:20:44,190 --> 00:20:46,230
因此与他的问题相关，因此这一切都是

517
00:20:46,230 --> 00:20:48,300
透明的，所以现在我是 显示

518
00:20:48,300 --> 00:20:49,890
数据库，这张图中的这张

519
00:20:49,890 --> 00:20:52,650
是在两张光盘上，但我可以轻松

520
00:20:52,650 --> 00:20:56,070
添加更多数据，现在将

521
00:20:56,070 --> 00:20:57,450
数据交叉拆分得更多——我得到了更好的

522
00:20:57,450 --> 00:20:59,730
并行性更好的复制

523
00:20:59,730 --> 00:21:02,250
更好的可靠性，但这些

524
00:21:02,250 --> 00:21:04,740
人都没有 计算层

525
00:21:04,740 --> 00:21:05,640
他们对此一无所知，

526
00:21:05,640 --> 00:21:08,040
因为这一切对我来说都是隐藏的，所以你

527
00:21:08,040 --> 00:21:09,390
有这种很好的分离，你可以

528
00:21:09,390 --> 00:21:11,070
独立地扩展事物，但

529
00:21:11,070 --> 00:21:12,830
你会在访问局部性方面付出代价，

530
00:21:12,830 --> 00:21:16,740
因为我不能

531
00:21:16,740 --> 00:21:18,090
大部分我不能在这里运行查询

532
00:21:18,090 --> 00:21:18,600


533
00:21:18,600 --> 00:21:20,700
s3 允许你做一些基本的过滤，

534
00:21:20,700 --> 00:21:22,740
但是关于任何像连接我必须

535
00:21:22,740 --> 00:21:24,090
在这里做的事情，这意味着我

536
00:21:24,090 --> 00:21:35,670
将数据池开放到我的计算中是的，所以是的

537
00:21:35,670 --> 00:21:37,350
问题是不同的

538
00:21:37,350 --> 00:21:39,330
图表或分区 我们

539
00:21:39,330 --> 00:21:41,130
明确划分了谁拥有

540
00:21:41,130 --> 00:21:44,010
我们将到达那里的数据 我只是向您

541
00:21:44,010 --> 00:21:46,950
展示共享磁盘是什么以及高/低

542
00:21:46,950 --> 00:21:49,520
您仍然可以在此级别进行分区

543
00:21:49,520 --> 00:21:51,360
共享磁盘没有任何内容可以

544
00:21:51,360 --> 00:21:52,740
阻止您执行 pa

545
00:21:52,740 --> 00:22:00,390
如果您不进行分区，则在计算级别正确

546
00:22:00,390 --> 00:22:02,990
划分

547
00:22:15,500 --> 00:22:18,179
任何问题都在此示例中

548
00:22:18,179 --> 00:22:20,820


549
00:22:20,820 --> 00:22:22,529


550
00:22:22,529 --> 00:22:24,179


551
00:22:24,179 --> 00:22:26,100
它总是像这样还是

552
00:22:26,100 --> 00:22:31,590
所有其他选择是的，是的，

553
00:22:31,590 --> 00:22:33,510
所以我在这种情况下所说的在这里我

554
00:22:33,510 --> 00:22:36,600
更新了一个页面 ABC，它具有顶部的计算

555
00:22:36,600 --> 00:22:37,860
节点是将这些计算

556
00:22:37,860 --> 00:22:39,659
节点更新到底部，另

557
00:22:39,659 --> 00:22:42,090
一种方法是 做一个推送通知并

558
00:22:42,090 --> 00:22:44,789
说嘿，我刚刚通过

559
00:22:44,789 --> 00:22:46,559
每个人都需要更新和

560
00:22:46,559 --> 00:22:50,669
刷新自己的方式获得了更新 ABC 我不知道任何

561
00:22:50,669 --> 00:22:54,230
像 EBS s3 这样的共享磁盘架构，

562
00:22:54,230 --> 00:22:56,370
无论他们不这样做

563
00:22:56,370 --> 00:22:57,389
，因为那会 超级

564
00:22:57,389 --> 00:22:59,340
昂贵，因为如果你考虑

565
00:22:59,340 --> 00:23:01,649
它就像一个流行子系统我需要

566
00:23:01,649 --> 00:23:04,260
知道谁需要知道我的变化

567
00:23:04,260 --> 00:23:06,240
，否则我发送的消息

568
00:23:06,240 --> 00:23:08,700
是浪费的，据他们所知，

569
00:23:08,700 --> 00:23:10,350
实际上没有人这样做，你必须

570
00:23:10,350 --> 00:23:11,909
协调 在这 层在这里，这

571
00:23:11,909 --> 00:23:13,500
是数据库系统这样做

572
00:23:13,500 --> 00:23:15,450
分布式文件系统或对象

573
00:23:15,450 --> 00:23:16,610
存储不这样做

574
00:23:16,610 --> 00:23:24,059
是的他的问题是我们在这里

575
00:23:24,059 --> 00:23:26,100
假设通知是可靠的或

576
00:23:26,100 --> 00:23:29,309
足够快不我没有说这是什么

577
00:23:29,309 --> 00:23:30,360
我 我说我们如何做同样的

578
00:23:30,360 --> 00:23:36,510
事情你必须这样做他的问题

579
00:23:36,510 --> 00:23:37,529
是你不能运行一个问题仍然提出

580
00:23:37,529 --> 00:23:39,510
绝对是的那是并发

581
00:23:39,510 --> 00:23:47,730
工具我们会到达那里是的好吧所以

582
00:23:47,730 --> 00:23:50,399
再次成为大多数人认为的试点

583
00:23:50,399 --> 00:23:51,330
当他们考虑分布式

584
00:23:51,330 --> 00:23:53,370
数据库时是无共享

585
00:23:53,370 --> 00:23:55,470
架构，其中每个节点

586
00:23:55,470 --> 00:23:57,809
都有自己的本地磁盘和旧的本地

587
00:23:57,809 --> 00:23:59,429
内存，

588
00:23:59,429 --> 00:24:01,289
我在运行查询时进行协调的唯一方法是

589
00:24:01,289 --> 00:24:03,570
直接在我的节点之间进行通信，因此

590
00:24:03,570 --> 00:24:05,490
如果我愿意 获取数据，如果我查询

591
00:24:05,490 --> 00:24:06,750
出现并且他访问了另一台机器上的数据

592
00:24:06,750 --> 00:24:10,019
我无法转到磁盘并获取

593
00:24:10,019 --> 00:24:11,100
共享磁盘并获取它，因为它不

594
00:24:11,100 --> 00:24:12,659
存在我无法

595
00:24:12,659 --> 00:24:14,159
从另一个人那里读取内存，因为 我不能那样

596
00:24:14,159 --> 00:24:15,090
做我

597
00:24:15,090 --> 00:24:17,010
一团糟 圣人说，嘿，我认为您拥有

598
00:24:17,010 --> 00:24:19,440
这些数据，要么为我运行此查询

599
00:24:19,440 --> 00:24:21,420
并将结果返回给我，要么将数据发送给我

600
00:24:21,420 --> 00:24:23,670
，然后现在您会

601
00:24:23,670 --> 00:24:24,900
遇到这样的问题，例如谁应该拥有

602
00:24:24,900 --> 00:24:28,820
我们将获得的数据的正确副本 所以

603
00:24:28,820 --> 00:24:30,870
这将是最难

604
00:24:30,870 --> 00:24:32,760
增加容量和

605
00:24:32,760 --> 00:24:34,590
确保一致性的架构，这是他谈到的陈旧读取

606
00:24:34,590 --> 00:24:38,240
问题，因为我

607
00:24:38,240 --> 00:24:40,770
需要能够运行系统并

608
00:24:40,770 --> 00:24:43,950
以骑行的方式移动数据我

609
00:24:43,950 --> 00:24:45,450
不会丢失东西我 '

610
00:24:45,450 --> 00:24:47,280
当我执行查询时没有漏报或误报，

611
00:24:47,280 --> 00:24:51,180
否则我关闭整个

612
00:24:51,180 --> 00:24:52,680
系统然后移动数据并

613
00:24:52,680 --> 00:24:55,440
添加新容量但我不想这样做

614
00:24:55,440 --> 00:24:56,490
，因为我希望我的系统

615
00:24:56,490 --> 00:25:00,150
始终在线所以现在你 说得好，这

616
00:25:00,150 --> 00:25:01,500
听起来很难，为什么我要做得

617
00:25:01,500 --> 00:25:03,930
很好，你将获得

618
00:25:03,930 --> 00:25:05,670
超过共享磁盘系统的优势是，如果系统写入正确，

619
00:25:05,670 --> 00:25:06,840
你将获得更好的性能和更高的

620
00:25:06,840 --> 00:25:09,720
效率

621
00:25:09,720 --> 00:25:13,140
，因为我现在可以

622
00:25:13,140 --> 00:25:16,470
注意 数据的位置并尝试

623
00:25:16,470 --> 00:25:17,730
通过网络尽可能多地移动最少量的数据

624
00:25:17,730 --> 00:25:22,880
是的，

625
00:25:42,530 --> 00:25:47,250
所以是的，所以他的说法是，如果

626
00:25:47,250 --> 00:25:50,700
您假设您的 Chiba

627
00:25:50,700 --> 00:25:52,170
数据库已分区，

628
00:25:52,170 --> 00:25:55,500
如果现在我 需要添加一个

629
00:25:55,500 --> 00:25:57,990
新分区，我需要根据我进行分区的方式访问

630
00:25:57,990 --> 00:26:00,810
潜在的 Erie shuffle 数据

631
00:26:00,810 --> 00:26:03,120
我可能需要

632
00:26:03,120 --> 00:26:05,400
移动整个数据库我在

633
00:26:05,400 --> 00:26:07,440
它的一个片段中，但我又不想

634
00:26:07,440 --> 00:26:09,690
停下来 当我移动这个世界时，所以

635
00:26:09,690 --> 00:26:10,890
取决于我有多少数据，我有一个

636
00:26:10,890 --> 00:26:12,900
节点，我将通过网络连接到

637
00:26:12,900 --> 00:26:14,130
其他机器，那台机器需要

638
00:26:14,130 --> 00:26:17,580
多长时间，

639
00:26:17,580 --> 00:26:19,290
如果我不这样做的话 关心

640
00:26:19,290 --> 00:26:20,730
我们还没有讨论过的一致性，

641
00:26:20,730 --> 00:26:23,610
那么谁关心只是移动

642
00:26:23,610 --> 00:26:25,500
数据，如果你错过了

643
00:26:25,500 --> 00:26:27,870
任何阅读，因为我确实关心并且我

644
00:26:27,870 --> 00:26:28,410
正在转弯，

645
00:26:28,410 --> 00:26:30,540
那么我会非常小心我如何做到

646
00:26:30,540 --> 00:26:33,500
这一点 人们

647
00:26:33,500 --> 00:26:37,280
对此很感兴趣，所以正如我所说，这只是一小

648
00:26:37,280 --> 00:26:41,400
部分 或一些无共享分布式数据库的一个非常有限的子集

649
00:26:41,400 --> 00:26:43,320
，对于

650
00:26:43,320 --> 00:26:44,880


651
00:26:44,880 --> 00:26:48,900


652
00:26:48,900 --> 00:26:50,970
大约十年前出现的单一系统来说，

653
00:26:50,970 --> 00:26:52,650
大多数时候看起来

654
00:26:52,650 --> 00:26:56,160
更好 什么都不共享 所以让我们

655
00:26:56,160 --> 00:26:57,900
再看看它是如何工作的 所以

656
00:26:57,900 --> 00:26:59,640
我们不再在每个节点上都有一个共享磁盘

657
00:26:59,640 --> 00:27:04,080
我们有 CPU 工作线程

658
00:27:04,080 --> 00:27:05,400
我们有我们的本地内存 我们有我们的

659
00:27:05,400 --> 00:27:07,410
本地磁盘 现在我展示的

660
00:27:07,410 --> 00:27:10,350
是我们 我已经将数据库或

661
00:27:10,350 --> 00:27:14,040
数据库中的分片划分为子集，

662
00:27:14,040 --> 00:27:16,980
这样每个节点都有

663
00:27:16,980 --> 00:27:20,460
数据库的一部分，所以现在我有

664
00:27:20,460 --> 00:27:22,320
关于我有什么数据的明确信息

665
00:27:22,320 --> 00:27:24,660
每个节点都有一个习惯，所以现在应用程序

666
00:27:24,660 --> 00:27:26,880
说得很好，如果我想 让 ID 等于

667
00:27:26,880 --> 00:27:29,070
100 它必须知道这个节点

668
00:27:29,070 --> 00:27:32,700
有它需要的数据，所以

669
00:27:32,700 --> 00:27:34,890
继续获取它，现在它正在

670
00:27:34,890 --> 00:27:36,900
运行，因为同一个节点共享

671
00:27:36,900 --> 00:27:38,730
所有数据，所以我们以前有

672
00:27:38,730 --> 00:27:40,440
它不是我的缓冲池 我

673
00:27:40,440 --> 00:27:42,480
去拿吧 然后

674
00:27:42,480 --> 00:27:43,710
做任何我想做的事情来回答查询

675
00:27:43,710 --> 00:27:46,680
并返回结果，所以如果你的所有

676
00:27:46,680 --> 00:27:49,950
查询都在访问单个节点，

677
00:27:49,950 --> 00:27:52,440
这是非常快的，因为这

678
00:27:52,440 --> 00:27:54,870
只是一个单节点数据库系统，

679
00:27:54,870 --> 00:27:56,340
然后棘手的事情是 你开始

680
00:27:56,340 --> 00:27:58,020
接触不跨多

681
00:27:58,020 --> 00:28:00,330
台机器的数据，所以假设我有一个

682
00:28:00,330 --> 00:28:02,010
事务，它说一个获取 ID 你

683
00:28:02,010 --> 00:28:03,720
十个获取 ID 等于 100 就像

684
00:28:03,720 --> 00:28:05,940
一个查询想要这样做，所以现在我

685
00:28:05,940 --> 00:28:08,730
需要以某种方式获取

686
00:28:08,730 --> 00:28:11,610
另一个人的数据 在这里，但我要发送什么是

687
00:28:11,610 --> 00:28:13,530
我发送运行查询的请求

688
00:28:13,530 --> 00:28:16,830
还是我只是问这个人

689
00:28:16,830 --> 00:28:17,820
嘿我知道你有这个数据

690
00:28:17,820 --> 00:28:19,200
发送给我，我会在这里运行查询

691
00:28:19,200 --> 00:28:23,780
好回来

692
00:28:24,100 --> 00:28:26,850
现在，就共享磁盘架构上的横向扩展问题而言，

693
00:28:26,850 --> 00:28:29,590
我

694
00:28:29,590 --> 00:28:31,270
只是在每个

695
00:28:31,270 --> 00:28:34,510
计算节点都没有状态的情况下启动一个新的计算节点，因此

696
00:28:34,510 --> 00:28:36,490
它出现并开始执行

697
00:28:36,490 --> 00:28:37,990
查询并将

698
00:28:37,990 --> 00:28:39,430
后端共享磁盘中的事物带入 ab 根据

699
00:28:39,430 --> 00:28:41,380
需要提供池，但现在我没有共享任何

700
00:28:41,380 --> 00:28:43,420
架构，如果我不得不说提出一个

701
00:28:43,420 --> 00:28:46,360
新节点，它现在需要

702
00:28:46,360 --> 00:28:48,160
从这些其他节点获取数据库的一部分，

703
00:28:48,160 --> 00:28:50,580
以便我平衡事情，

704
00:28:50,580 --> 00:28:52,810
所以假设这个人是

705
00:28:52,810 --> 00:28:56,050
要发送它，你知道

706
00:28:56,050 --> 00:28:57,430
来自这个底部分区的这个人的一些数字元组，

707
00:28:57,430 --> 00:28:59,530
这里的另一个人是

708
00:28:59,530 --> 00:29:00,640
它有时与另一个分区一起发送

709
00:29:00,640 --> 00:29:03,550
，然后一旦我有了新

710
00:29:03,550 --> 00:29:05,470
的数据，我现在已经复制了数据，我将一些全局

711
00:29:05,470 --> 00:29:07,600
状态更新为 说好吧，这个节点

712
00:29:07,600 --> 00:29:09,580
现在负责范围 101 到 200

713
00:29:09,580 --> 00:29:11,920
这个人的 201 到 300 一个人大约 1

714
00:29:11,920 --> 00:29:14,590
到 100，我对他的观点

715
00:29:14,590 --> 00:29:16,930
是这样的，如果我关心交易，我将很难做到这一点

716
00:29:16,930 --> 00:29:18,670


717
00:29:18,670 --> 00:29:19,990
不想丢失任何数据，因为我

718
00:29:19,990 --> 00:29:22,480
不想显示查询，但

719
00:29:22,480 --> 00:29:27,090
也许想要访问等于 150 的 ID，

720
00:29:27,090 --> 00:29:31,480
我会在这里并且数据

721
00:29:31,480 --> 00:29:32,980
尚未传输，所以也许我可以

722
00:29:32,980 --> 00:29:34,330
回答 但也许它已经

723
00:29:34,330 --> 00:29:36,820
转移了，我去了这里，它说我没有

724
00:29:36,820 --> 00:29:38,560
不再拥有该数据，因此

725
00:29:38,560 --> 00:29:40,600
即使它存在于此节点，它也不会返回任何内容，

726
00:29:40,600 --> 00:29:43,210
因此它是如何

727
00:29:43,210 --> 00:29:44,770
以事务性的方式实际执行此操作的 e

728
00:29:44,770 --> 00:29:47,350
安全方式是棘手且不

729
00:29:47,350 --> 00:29:51,450
容易做到的，在后面

730
00:29:57,279 --> 00:30:00,889
他的问题是他的 问题是

731
00:30:00,889 --> 00:30:03,739
您必须多久扩展一次容量 我可以

732
00:30:03,739 --> 00:30:05,509
每月关闭一次数据库并

733
00:30:05,509 --> 00:30:07,820
添加新节点，但如果我不

734
00:30:07,820 --> 00:30:10,759
采取其他方式，那

735
00:30:10,759 --> 00:30:12,320


736
00:30:12,320 --> 00:30:14,149
又怎样 星期一

737
00:30:14,149 --> 00:30:15,529
是一年中的某一天，我有一个巨大的

738
00:30:15,529 --> 00:30:17,600
高峰，我可以计划我知道它

739
00:30:17,600 --> 00:30:18,649
即将到来，所以我可以提前做好准备，

740
00:30:18,649 --> 00:30:20,409
但假设我有一个快闪族，

741
00:30:20,409 --> 00:30:23,210
每个人都想要 deejay drop table

742
00:30:23,210 --> 00:30:25,100
新专辑 突然，我们

743
00:30:25,100 --> 00:30:26,059
也有一个巨大的流量高峰，这是

744
00:30:26,059 --> 00:30:29,570
出乎意料的 我希望能够扩大规模

745
00:30:29,570 --> 00:30:30,529
而不必关闭一切

746
00:30:30,529 --> 00:30:34,879
并逐渐扩大规模，旧

747
00:30:34,879 --> 00:30:36,139
系统将完全按照您所说的

748
00:30:36,139 --> 00:30:37,700
任何时候看到任何类型 金融

749
00:30:37,700 --> 00:30:40,070
网站说我们倒闭了 您知道星期天

750
00:30:40,070 --> 00:30:43,190
凌晨 3:00 可能

751
00:30:43,190 --> 00:30:44,389
没有运行三脚架系统，但

752
00:30:44,389 --> 00:30:46,129
他们正在移动数据并进行

753
00:30:46,129 --> 00:30:47,509
维护工作，但是如果您是

754
00:30:47,509 --> 00:30:52,149
在线网站，您就不能这样做，是的，

755
00:31:01,299 --> 00:31:03,710
您的问题是什么

756
00:31:03,710 --> 00:31:05,330
这样做的优势与使用单个节点相比，

757
00:31:05,330 --> 00:31:09,109
就像您知道的那样，而不是

758
00:31:09,109 --> 00:31:11,210
让两个节点运行这些来保存这

759
00:31:11,210 --> 00:31:12,739
两个分区 具有单个节点的东西

760
00:31:12,739 --> 00:31:14,779
，你说得好，这个 CPU 插槽

761
00:31:14,779 --> 00:31:16,879
在这个内存中有这个磁盘来运行这个

762
00:31:16,879 --> 00:31:18,919
分区，然后 另一个插槽

763
00:31:18,919 --> 00:31:21,440
在这张桌子上有这个内存，你

764
00:31:21,440 --> 00:31:30,559
问得很好，所以你的问题是，

765
00:31:30,559 --> 00:31:32,710
而不是拥有两台独立的机器

766
00:31:32,710 --> 00:31:35,299
，你知道磁盘内存和

767
00:31:35,299 --> 00:31:38,059
CPU，如果我有一台机器

768
00:31:38,059 --> 00:31:39,649
，它的资源量与它相同

769
00:31:39,649 --> 00:31:41,809
已经安装了两台机器，但现在

770
00:31:41,809 --> 00:31:49,759
你知道一个单元，所以质疑

771
00:31:49,759 --> 00:31:51,049
做 shiva Davis 的优势是什么，

772
00:31:51,049 --> 00:32:00,350
所以一个是如果你在垂直

773
00:32:00,350 --> 00:32:02,269
扩展硬件时得到收益递减，

774
00:32:02,269 --> 00:32:04,159
所以有

775
00:32:04,159 --> 00:32:06,679
水平 al 代表可扩展性，就像

776
00:32:06,679 --> 00:32:09,080
添加新机器垂直规模

777
00:32:09,080 --> 00:32:10,290
投票来占用我的一台机器

778
00:32:10,290 --> 00:32:11,940
并添加更多资源以使其

779
00:32:11,940 --> 00:32:15,870
更强大

780
00:32:15,870 --> 00:32:18,780
通常更昂贵并且您得到的

781
00:32:18,780 --> 00:32:20,370
收益递减并且

782
00:32:20,370 --> 00:32:22,080
显然有上限

783
00:32:22,080 --> 00:32:26,370
您可以做多大 一台机器

784
00:32:26,370 --> 00:32:28,440
，在我读研究生的早期

785
00:32:28,440 --> 00:32:31,830
，我们访问了 PayPal，因为

786
00:32:31,830 --> 00:32:34,920
PayPal 正在运行 Oracle，他们

787
00:32:34,920 --> 00:32:36,090
吓坏了，因为每年

788
00:32:36,090 --> 00:32:38,640
圣诞节他们都会

789
00:32:38,640 --> 00:32:40,590
在他们购买的一台机器上运行 Oracle

790
00:32:40,590 --> 00:32:41,610


791
00:32:41,610 --> 00:32:43,800
您可以从 IBM 购买的最昂贵的机器，

792
00:32:43,800 --> 00:32:44,790
您必须购买其中的两台，因为您

793
00:32:44,790 --> 00:32:48,210
需要一个热备份，所以

794
00:32:48,210 --> 00:32:50,700
每个假期他们都会

795
00:32:50,700 --> 00:32:52,020
吓坏了，因为那台 Oracle 机器

796
00:32:52,020 --> 00:32:54,210
正在达到

797
00:32:54,210 --> 00:32:55,590
港口的极限 可以做，但他们买不起

798
00:32:55,590 --> 00:32:57,720
更贵的机器，所以

799
00:32:57,720 --> 00:32:58,890
他们不能再垂直缩放任何人，

800
00:32:58,890 --> 00:33:00,390
所以他们主要是在

801
00:33:00,390 --> 00:33:02,100
移动 数据库的一部分，因为

802
00:33:02,100 --> 00:33:03,420
人类正在

803
00:33:03,420 --> 00:33:05,700
像 11 月那样将 Davies 的部分转移到这些单独的

804
00:33:05,700 --> 00:33:07,830
机器上，只是为了

805
00:33:07,830 --> 00:33:09,450
假期，然后他们将其全部移

806
00:33:09,450 --> 00:33:11,880
回该环境中，如果他们有一个

807
00:33:11,880 --> 00:33:14,190
更便宜的分布式数据库系统

808
00:33:14,190 --> 00:33:16,170
机器然后他们会说哦假期

809
00:33:16,170 --> 00:33:17,670
快到了我要购买或打开

810
00:33:17,670 --> 00:33:20,370
一堆新机器并让

811
00:33:20,370 --> 00:33:21,990
系统以这种方式扩展以处理我的

812
00:33:21,990 --> 00:33:24,030
高需求然后当需求

813
00:33:24,030 --> 00:33:25,860
下降时我可以开始关闭它们并且

814
00:33:25,860 --> 00:33:29,720
合并成更小的机器，

815
00:33:45,250 --> 00:33:47,560
你的问题是，所以这些

816
00:33:47,560 --> 00:33:50,140
是归因于

817
00:33:50,140 --> 00:33:51,790
横向扩展与垂直扩展

818
00:33:51,790 --> 00:33:53,620
的优势是你可以

819
00:33:53,620 --> 00:33:58,450
更便宜地横向扩展以快速

820
00:33:58,450 --> 00:34:00,490
但它是权衡，

821
00:34:00,490 --> 00:34:02,560
就像我们将看到的 我们谈论我们如何

822
00:34:02,560 --> 00:34:04,170
实际管理属性数据系统

823
00:34:04,170 --> 00:34:06,070
通信现在更昂贵

824
00:34:06,070 --> 00:34:07,990
如果我在单个节点上我肯定可以运行得更快

825
00:34:07,990 --> 00:34:09,190
因为我不需要

826
00:34:09,190 --> 00:34:10,389
在其他节点之间进行协调 r 不同的节点

827
00:34:10,389 --> 00:34:12,219
并通过网络发送消息 但

828
00:34:12,219 --> 00:34:15,550
正如我所说的 你可以开始达到

829
00:34:15,550 --> 00:34:23,770
规模 去瓶颈

830
00:34:23,770 --> 00:34:25,780
直到 90 年代数据系统

831
00:34:25,780 --> 00:34:27,730
的趋势总是垂直扩展 现在的趋势

832
00:34:27,730 --> 00:34:29,739
是水平扩展 因为

833
00:34:29,739 --> 00:34:34,330
它只是 人们认为你会获得更好的

834
00:34:34,330 --> 00:34:38,650
表现，为了获得更好的

835
00:34:38,650 --> 00:34:41,010
表现，你付出的更少，你付出的

836
00:34:41,010 --> 00:34:43,929
更少，这总是正确的，是的，我认为

837
00:34:43,929 --> 00:34:44,830
那是约定俗成的，并不

838
00:34:44,830 --> 00:34:55,770
总是正确的，是的，声明就像

839
00:34:55,770 --> 00:34:59,070
是不是更适合灾难，因为

840
00:34:59,070 --> 00:35:01,660
好吧 再说一次，如果你像 IBM 的 500

841
00:35:01,660 --> 00:35:03,550
万美元的机器一样运行，你

842
00:35:03,550 --> 00:35:05,080
没有正确地插入墙上的插座

843
00:35:05,080 --> 00:35:07,480
你有发电机你有

844
00:35:07,480 --> 00:35:11,500
备用电源但是我

845
00:35:11,500 --> 00:35:12,880
想说问题真的会永远不会被

846
00:35:12,880 --> 00:35:15,280
切断，如果 如果

847
00:35:15,280 --> 00:35:17,140
网络连接到机器，即使那样，

848
00:35:17,140 --> 00:35:19,810
你仍然会有多余的尼克斯

849
00:35:19,810 --> 00:35:22,450
进入它，但即使这样，如果你无法

850
00:35:22,450 --> 00:35:24,400
与数据库进行通信，但可能会

851
00:35:24,400 --> 00:35:25,840
影响你的设计方式 r Chuba 数据库

852
00:35:25,840 --> 00:35:27,910
系统，您可以将数据库

853
00:35:27,910 --> 00:35:30,370
分布在不同的数据中心，

854
00:35:30,370 --> 00:35:32,950
然后您仍然可以使用它

855
00:35:32,950 --> 00:35:34,630
在周三讨论更多这方面的内容

856
00:35:34,630 --> 00:35:39,280
，但这是

857
00:35:39,280 --> 00:35:40,570
您

858
00:35:40,570 --> 00:35:41,800
在没有单身人士之间进行的权衡之一 与

859
00:35:41,800 --> 00:35:44,350
传统的或新的续集或关系

860
00:35:44,350 --> 00:35:46,360
数据库系统相比，没有续集的人

861
00:35:46,360 --> 00:35:48,850
关心可用性，因此

862
00:35:48,850 --> 00:35:50,320
无论他们希望网站

863
00:35:50,320 --> 00:35:54,640
在线且可用，因此作为交换，

864
00:35:54,640 --> 00:35:56,350
他们会放弃交易

865
00:35:56,350 --> 00:35:58,050
以实现这一目标，因为

866
00:35:58,050 --> 00:35:59,240
如果您必须 有新的交易

867
00:35:59,240 --> 00:36:01,830
然后通信会更

868
00:36:01,830 --> 00:36:03,570
昂贵你确保每个人

869
00:36:03,570 --> 00:36:06,990
都准备好进行更改

870
00:36:06,990 --> 00:36:09,000
并且他们认为这

871
00:36:09,000 --> 00:36:11,880
对于某些应用程序来说不太理想我

872
00:36:11,880 --> 00:36:13,200
认为这对于任何没有财务意义的应用程序都是有意义的

873
00:36:13,200 --> 00:36:15,930
有道理 我会

874
00:36:15,930 --> 00:36:24,540
讲下一堂课 好吧 所以分布式

875
00:36:24,540 --> 00:36:28,440
别名是旧的 一些最早的别名

876
00:36:28,440 --> 00:36:32,090
是在 1970 年代后期构建的 松饼是

877
00:36:32,090 --> 00:36:34,380
由我的一个顾问创建的 迈克·雪

878
00:36:34,380 --> 00:36:35,880
断路器 建造后草地和

879
00:36:35,880 --> 00:36:38,430
入口以及垂直和伏特 EB 的人 他有

880
00:36:38,430 --> 00:36:39,120
一个名为 muffin 的系统

881
00:36:39,120 --> 00:36:41,700
，它是入口 sdd 的三元组版本，

882
00:36:41,700 --> 00:36:46,920
我实际上认为

883
00:36:46,920 --> 00:36:48,300
它实际上是一个真正的系统，结果

884
00:36:48,300 --> 00:36:49,560
它只是一个 原型 他们

885
00:36:49,560 --> 00:36:51,150
实际上从来没有真正运行过任何东西，但是

886
00:36:51,150 --> 00:36:52,770
在 70 年代后期有很多开创性的论文

887
00:36:52,770 --> 00:36:54,390
是由伟大的

888
00:36:54,390 --> 00:36:57,870
Phil Bernstein 写的，关于如何构建一个

889
00:36:57,870 --> 00:36:59,250
致敬的数据库并

890
00:36:59,250 --> 00:37:01,800
在它们之间进行交易 我们谈到了很多交易

891
00:37:01,800 --> 00:37:03,000
理论 在这

892
00:37:03,000 --> 00:37:05,460
门课上，所有早期的工作

893
00:37:05,460 --> 00:37:08,940
都是由 Phil system 完成的 R star

894
00:37:08,940 --> 00:37:10,800
是 IBM 的一个研究项目，它

895
00:37:10,800 --> 00:37:15,420
是 system 的致敬版本，或者

896
00:37:15,420 --> 00:37:16,830
从未成为产品，尽管

897
00:37:16,830 --> 00:37:19,260
今天有 db2 的发行版 gamma

898
00:37:19,260 --> 00:37:20,670
是有影响力的

899
00:37:20,670 --> 00:37:22,980
威斯康星州的 Dave DeWitt 系统

900
00:37:22,980 --> 00:37:25,320
是第一个像高性能东芝

901
00:37:25,320 --> 00:37:28,170
Devi 系统，然后所有这些的不间断续集

902
00:37:28,170 --> 00:37:29,910
是唯一的

903
00:37:29,910 --> 00:37:31,350
商业发行版 Butor 数据库系统

904
00:37:31,350 --> 00:37:34,470
，那是有人帮助构建的，或者

905
00:37:34,470 --> 00:37:35,970
Jim Gray 帮助构建了这个 Jim Gray

906
00:37:35,970 --> 00:37:39,060
是 IBM 的那个人，他发明了像

907
00:37:39,060 --> 00:37:40,380
两阶段锁定一样的

908
00:37:40,380 --> 00:37:42,090
东西，我们在系统下讨论的很多早期的东西

909
00:37:42,090 --> 00:37:44,340
都是不间断的，这很有趣

910
00:37:44,340 --> 00:37:47,310
他们最初销售

911
00:37:47,310 --> 00:37:49,260
这些像超级容错机器的公司

912
00:37:49,260 --> 00:37:50,970
，就像像航天飞机级冗余那样的冗余硬件，

913
00:37:50,970 --> 00:37:53,310
就像

914
00:37:53,310 --> 00:37:54,990
您在 CPU 运行时所拥有的一样，如果其中一个

915
00:37:54,990 --> 00:37:56,250
出现故障，其他三个您可以

916
00:37:56,250 --> 00:37:58,170
继续运行，因此他们将出售数据库

917
00:37:58,170 --> 00:38:00,000
系统 这将建立在这种

918
00:38:00,000 --> 00:38:02,430
架构上 嗯它今天仍然是圆形的

919
00:38:02,430 --> 00:38:04,350
许多金融系统实际上

920
00:38:04,350 --> 00:38:07,650
仍然在使用它并且

921
00:38:07,650 --> 00:38:08,640
它仍然运行多长时间

922
00:38:08,640 --> 00:38:10,830
我想它是不间断的

923
00:38:10,830 --> 00:38:14,530
好吧所以嗯好吧所以现在我们

924
00:38:14,530 --> 00:38:17,590
现在我们明白了 架构是什么

925
00:38:17,590 --> 00:38:20,050
样子的，你们很多人

926
00:38:20,050 --> 00:38:21,490
都有这些问题，比如嘿

927
00:38:21,490 --> 00:38:23,380
，这东西实际上是如何工作的，如何

928
00:38:23,380 --> 00:38:24,910
真正找到数据，我们实际上是如何

929
00:38:24,910 --> 00:38:26,110
制作的 确保一切都是一致的，

930
00:38:26,110 --> 00:38:28,420
所以

931
00:38:28,420 --> 00:38:30,580
我们现在在构建和塑造

932
00:38:30,580 --> 00:38:31,600
数据系统时需要注意所有这些事情，并且存在权衡，

933
00:38:31,600 --> 00:38:32,650
因为我们无法做

934
00:38:32,650 --> 00:38:34,930
所有事情，所以我们不会有一个

935
00:38:34,930 --> 00:38:36,460
系统来保证 始终在线，

936
00:38:36,460 --> 00:38:36,970


937
00:38:36,970 --> 00:38:39,460
并确保我们始终支持

938
00:38:39,460 --> 00:38:41,320
交易，并且不会丢失任何数据

939
00:38:41,320 --> 00:38:43,930
或出现不一致的结果，因此在我们继续进行

940
00:38:43,930 --> 00:38:44,670
时，

941
00:38:44,670 --> 00:38:47,110
我们将看到这些权衡是什么以及

942
00:38:47,110 --> 00:38:49,140
为什么您不能实现

943
00:38:49,140 --> 00:38:51,220
所有其他大问题 我们将要

944
00:38:51,220 --> 00:38:53,380
实际执行

945
00:38:53,380 --> 00:38:56,290
对这个分布式数据的查询，

946
00:38:56,290 --> 00:38:58,360
所以到目前为止我展示了两个示例，我展示

947
00:38:58,360 --> 00:39:00,070
了共享磁盘上的示例，其中计算节点

948
00:39:00,070 --> 00:39:02,470
将数据从共享磁盘

949
00:39:02,470 --> 00:39:05,050
系统拉入它们的本地内存并

950
00:39:05,050 --> 00:39:07,330
计算 计算结果，然后

951
00:39:07,330 --> 00:39:10,390
在无共享系统的情况下，

952
00:39:10,390 --> 00:39:12,520
我们会将查询发送到

953
00:39:12,520 --> 00:39:14,890
数据所在的位置，然后在本地运行，

954
00:39:14,890 --> 00:39:16,420
然后取回结果，

955
00:39:16,420 --> 00:39:18,340
以便在您

956
00:39:18,340 --> 00:39:19,870
实际想要更好的方式之间进行权衡 使用推送器

957
00:39:19,870 --> 00:39:23,350
或池，所以最后要讨论

958
00:39:23,350 --> 00:39:25,750
的也是架构在集群

959
00:39:25,750 --> 00:39:27,250
中节点为 Shiva 数据库执行的操作方面是什么样子的，

960
00:39:27,250 --> 00:39:29,020


961
00:39:29,020 --> 00:39:32,260
并且有基础你知道

962
00:39:32,260 --> 00:39:33,490
只有两种方法你要么

963
00:39:33,490 --> 00:39:35,140
有一个同构 集群或

964
00:39:35,140 --> 00:39:36,760
异构集群，因此在

965
00:39:36,760 --> 00:39:39,010
同构集群中

966
00:39:39,010 --> 00:39:41,710
，数据库集群中的每个节点都可以执行

967
00:39:41,710 --> 00:39:44,080
您曾经拥有的每一种任务，

968
00:39:44,080 --> 00:39:46,960
所以我的意思是您可以

969
00:39:46,960 --> 00:39:48,670
向任何单个节点发送查询，该节点

970
00:39:48,670 --> 00:39:51,580
将弄清楚如何 得到

971
00:39:51,580 --> 00:39:53,530
你正在寻找的结果，它们

972
00:39:53,530 --> 00:39:54,730
都会给我一个潜在的后台

973
00:39:54,730 --> 00:39:57,820
任务和其他东西，所以

974
00:39:57,820 --> 00:40:00,730
这种方法的优点是它

975
00:40:00,730 --> 00:40:02,620
使配置和故障转移

976
00:40:02,620 --> 00:40:05,380
可能更容易处理和支持，

977
00:40:05,380 --> 00:40:08,260
因为现在我只是添加 新节点，

978
00:40:08,260 --> 00:40:09,850
只要你知道我可以

979
00:40:09,850 --> 00:40:13,030
安全地移动数据 我可以添加新节点，

980
00:40:13,030 --> 00:40:14,740
并且你知道系统

981
00:40:14,740 --> 00:40:20,590
变得更强大它会变得

982
00:40:20,590 --> 00:40:22,240
更好，我们会看到你 下一

983
00:40:22,240 --> 00:40:24,430
节课是另一种做头

984
00:40:24,430 --> 00:40:26,590
异构集群的方法，你可以让

985
00:40:26,590 --> 00:40:29,890


986
00:40:29,890 --> 00:40:32,280
数据库系统的特定节点或成员负责

987
00:40:32,280 --> 00:40:36,820
单独的任务，所以现在我无法

988
00:40:36,820 --> 00:40:38,260
决定是否运行我的

989
00:40:38,260 --> 00:40:39,910
系统运行速度较慢我想要 添加新

990
00:40:39,910 --> 00:40:42,250
节点我必须知道我应该

991
00:40:42,250 --> 00:40:44,530
为这种类型的节点或其他类型的节点添加什么

992
00:40:44,530 --> 00:40:46,240
节点我必须

993
00:40:46,240 --> 00:40:49,570
在那个级别做出决定所以给

994
00:40:49,570 --> 00:40:52,570
我一个例子

995
00:40:52,570 --> 00:40:54,160
我总是喜欢这些架构中的一个 使用

996
00:40:54,160 --> 00:40:56,800
MongoDB 因为这是最基本

997
00:40:56,800 --> 00:40:57,790
的理解

998
00:40:57,790 --> 00:41:00,130
所以 MongoDB 使用所谓的

999
00:41:00,130 --> 00:41:01,900
异构集群架构，

1000
00:41:01,900 --> 00:41:03,700
所以你有专门的

1001
00:41:03,700 --> 00:41:05,260
节点负责或执行

1002
00:41:05,260 --> 00:41:08,770
系统中的特定任务，因此在

1003
00:41:08,770 --> 00:41:10,300
应用程序中想要发送请求 或者

1004
00:41:10,300 --> 00:41:13,060
执行一个查询，它总是转到这个

1005
00:41:13,060 --> 00:41:15,790
路由器，所以路由器

1006
00:41:15,790 --> 00:41:17,200
查看请求并说你知道我想

1007
00:41:17,200 --> 00:41:20,560
查看我想获取 PID

1008
00:41:20,560 --> 00:41:23,560
等于 101 的记录这些人是无状态的，他们

1009
00:41:23,560 --> 00:41:25,330
不知道 现在

1010
00:41:25,330 --> 00:41:28,030
关于实际分片上的任何数据，所以转到这个

1011
00:41:28,030 --> 00:41:31,150
配置服务器节点，它

1012
00:41:31,150 --> 00:41:33,400
负责发送发送

1013
00:41:33,400 --> 00:41:36,490
返回有关在哪里可以

1014
00:41:36,490 --> 00:41:39,280
找到这些不同分区或这些分片上的数据的信息，

1015
00:41:39,280 --> 00:41:41,470
这就是所有这些

1016
00:41:41,470 --> 00:41:42,640
这个东西负责它

1017
00:41:42,640 --> 00:41:45,250
就像一个全局状态，系统的配置是什么，

1018
00:41:45,250 --> 00:41:48,130
所以现在

1019
00:41:48,130 --> 00:41:49,870
使用的路由器从配置服务器获取这个路由表

1020
00:41:49,870 --> 00:41:51,520
，然后它可以

1021
00:41:51,520 --> 00:41:54,460
将请求发送到漫画 D 或分

1022
00:41:54,460 --> 00:41:56,740
片服务器，然后进行排序 实际上请

1023
00:41:56,740 --> 00:41:59,170
原谅查询并获取

1024
00:41:59,170 --> 00:42:00,330
结果，

1025
00:42:00,330 --> 00:42:03,010
因此再次在此架构下，如果我

1026
00:42:03,010 --> 00:42:05,670
注意到我的路由器

1027
00:42:05,670 --> 00:42:07,870
基础架构是我的瓶颈，我

1028
00:42:07,870 --> 00:42:09,400
可以扩展这个东西并添加更多

1029
00:42:09,400 --> 00:42:11,620
新节点而无需接触配置

1030
00:42:11,620 --> 00:42:14,770
服务器或夏洛特

1031
00:42:14,770 --> 00:42:15,540
服务器

1032
00:42:15,540 --> 00:42:18,540
是的，

1033
00:42:20,680 --> 00:42:22,030
这个问题是罪能够测试什么，

1034
00:42:22,030 --> 00:42:23,470
所以我们

1035
00:42:23,470 --> 00:42:27,580
谈论 MVCC 或构建索引或移动

1036
00:42:27,580 --> 00:42:29,320
数据的垃圾问题，因为我是我我我正在

1037
00:42:29,320 --> 00:42:34,870
扩展你 p 或者再次缩小，就像

1038
00:42:34,870 --> 00:42:36,490
你不能在这里向这个人发送查询一样，

1039
00:42:36,490 --> 00:42:38,200
他只能告诉你系统的配置是什么样的

1040
00:42:38,200 --> 00:42:39,310
，

1041
00:42:39,310 --> 00:42:42,280
而这个人不能保存任何数据，你

1042
00:42:42,280 --> 00:42:43,510
只能告诉你如何发送你知道的

1043
00:42:43,510 --> 00:42:49,960
将您的查询发送到哪里，所以

1044
00:42:49,960 --> 00:42:51,820
我们稍微涉及的另一件事是

1045
00:42:51,820 --> 00:42:53,590
关于分布式系统中数据透明度的概念

1046
00:42:53,590 --> 00:42:56,560
，这就是

1047
00:42:56,560 --> 00:42:59,380
理想情况下我们不希望应用程序

1048
00:42:59,380 --> 00:43:03,160
知道有关数据如何

1049
00:43:03,160 --> 00:43:06,040
拆分和划分的任何信息 或

1050
00:43:06,040 --> 00:43:07,840
在我们集群中的不同节点之间复制，

1051
00:43:07,840 --> 00:43:11,020
因此相同的后续查询或

1052
00:43:11,020 --> 00:43:12,700
我正在使用的任何查询语言以及

1053
00:43:12,700 --> 00:43:14,680
我的数据库系统应用程序我如果

1054
00:43:14,680 --> 00:43:16,780
我在一个节点上运行相同的查询

1055
00:43:16,780 --> 00:43:18,580
应该仍然有效并且仍然产生

1056
00:43:18,580 --> 00:43:21,400
正确的同步 同样的结果，如果现在我

1057
00:43:21,400 --> 00:43:24,940
对一千个节点感到害怕，因为

1058
00:43:24,940 --> 00:43:26,290
否则如果我有一个查询说

1059
00:43:26,290 --> 00:43:27,370
你知道一个 select star 语句

1060
00:43:27,370 --> 00:43:28,450
然后你有一些特殊的事情

1061
00:43:28,450 --> 00:43:30,520
说你知道我们是节点等于一

1062
00:43:30,520 --> 00:43:32,350
二三如果一 两吨 hree 现在被

1063
00:43:32,350 --> 00:43:33,790
分成了多个 Sheen 或者不是

1064
00:43:33,790 --> 00:43:36,070
一二三消失了我不想

1065
00:43:36,070 --> 00:43:37,510
回去重写我

1066
00:43:37,510 --> 00:43:40,270
所有的我所有的应用程序代码所以我们要

1067
00:43:40,270 --> 00:43:42,940
隐藏

1068
00:43:42,940 --> 00:43:45,040
应用程序的所有细节 数据实际上

1069
00:43:45,040 --> 00:43:47,200
正在存储，尽管我们可以

1070
00:43:47,200 --> 00:43:50,620
在驱动程序中将一些信息推送到客户端级别，

1071
00:43:50,620 --> 00:43:52,840
它允许找出

1072
00:43:52,840 --> 00:43:54,640
他想要与您交谈的节点，但是我们的

1073
00:43:54,640 --> 00:43:55,390
应用程序代码

1074
00:43:55,390 --> 00:43:57,550
您知道 Joe Schmoe 程序员

1075
00:43:57,550 --> 00:43:58,750
不应该知道

1076
00:43:58,750 --> 00:44:01,960
数据如何 理想情况下是分开

1077
00:44:01,960 --> 00:44:05,890
的 情况并非总是如此 但这就是我们想要的 所以

1078
00:44:05,890 --> 00:44:07,060
现在谈论我们将如何拆分

1079
00:44:07,060 --> 00:44:08,350
数据 我们已经稍微触及了

1080
00:44:08,350 --> 00:44:10,780
这一点 我们将要使用 我们

1081
00:44:10,780 --> 00:44:12,970
要去 使用分区为什么我们不能

1082
00:44:12,970 --> 00:44:15,690
在我们这样做的时候也讨论这个 我

1083
00:44:15,690 --> 00:44:18,430
认为这次是一种

1084
00:44:18,430 --> 00:44:19,570
登机协议类型讨论了这个

1085
00:44:19,570 --> 00:44:20,830
，我们讨论了我们与

1086
00:44:20,830 --> 00:44:23,410
并行执行 这里的想法是

1087
00:44:23,410 --> 00:44:24,880
我们要去 获取我们的数据库并将

1088
00:44:24,880 --> 00:44:28,090
其拆分为 不相交的子

1089
00:44:28,090 --> 00:44:30,400
集然后将分配给不同的

1090
00:44:30,400 --> 00:44:32,530
不同资源，如果你

1091
00:44:32,530 --> 00:44:34,360
来自没有续集的世界，它们将

1092
00:44:34,360 --> 00:44:37,150
被称为分片，但分区和分

1093
00:44:37,150 --> 00:44:40,660
片本质上是一样的，所以

1094
00:44:40,660 --> 00:44:41,920
现在戴维斯

1095
00:44:41,920 --> 00:44:44,500
系统会发生什么 一个查询，

1096
00:44:44,500 --> 00:44:47,020
它将查看

1097
00:44:47,020 --> 00:44:48,310
该查询计划的不同部分需要访问哪些数据

1098
00:44:48,310 --> 00:44:51,370
，然后它可能需要

1099
00:44:51,370 --> 00:44:54,190
将计划的片段发送到不同的节点

1100
00:44:54,190 --> 00:44:56,080
，让它们退出

1101
00:44:56,080 --> 00:44:59,110
查询的该部分，然后发回结果

1102
00:44:59,110 --> 00:45:01,150
他们生成的，我们可以使用

1103
00:45:01,150 --> 00:45:02,620
我们之前在迭代器模型下讨论过的相同交换运算符，

1104
00:45:02,620 --> 00:45:04,450
当我们进行

1105
00:45:04,450 --> 00:45:05,920
并行查询时，相同的交换

1106
00:45:05,920 --> 00:45:08,020
运算符是我们如何使

1107
00:45:08,020 --> 00:45:12,040
属性环境中的事物瘫痪 所以让我们

1108
00:45:12,040 --> 00:45:13,180
谈谈我们如何实际拆分我们的

1109
00:45:13,180 --> 00:45:17,050
表 进行表分区的最简单方法

1110
00:45:17,050 --> 00:45:19,900
是您只需要一张

1111
00:45:19,900 --> 00:45:21,790
表，并且您拥有每个节点，

1112
00:45:21,790 --> 00:45:23,650
每个节点都存储其中一个

1113
00:45:23,650 --> 00:45:26,380
表，所以我有 三个表一个 B 和 C

1114
00:45:26,380 --> 00:45:30,040
节点一个得到一个没有两个得到是没有 3 个得到

1115
00:45:30,040 --> 00:45:31,780
C 这是进行分区的最简单的方法

1116
00:45:31,780 --> 00:45:34,360
对于这个

1117
00:45:34,360 --> 00:45:35,680
显然必须假设表

1118
00:45:35,680 --> 00:45:39,040
可以放在一个节点上但是对于阀门

1119
00:45:39,040 --> 00:45:39,670
它很好

1120
00:45:39,670 --> 00:45:42,220
所以我有 两个表 一和二 我只是

1121
00:45:42,220 --> 00:45:45,280
再次将表

1122
00:45:45,280 --> 00:45:46,810
一中的所有元组转到一个分区

1123
00:45:46,810 --> 00:45:49,330
表中的所有元组转到另一个分区 所以

1124
00:45:49,330 --> 00:45:51,130
在这种环境中理想的

1125
00:45:51,130 --> 00:45:54,460
查询是任何明显涉及到一个

1126
00:45:54,460 --> 00:45:57,700
表的查询，因为现在我不 不需要

1127
00:45:57,700 --> 00:46:00,010
在这些

1128
00:46:00,010 --> 00:46:01,450
不同的节点之间进行通信我只是将我的查询发送到

1129
00:46:01,450 --> 00:46:03,130
它运行的这个节点然后我

1130
00:46:03,130 --> 00:46:06,610
再次发回结果

1131
00:46:06,610 --> 00:46:08,980
假设我的工作量很容易

1132
00:46:08,980 --> 00:46:11,500
在这两个表之间分配，我将获得并行性但

1133
00:46:11,500 --> 00:46:12,610
我们显然知道那是 情况并非总是

1134
00:46:12,610 --> 00:46:16,530
如此 不现实 所以只有

1135
00:46:16,530 --> 00:46:18,820
极少数系统会让你这样做 我

1136
00:46:18,820 --> 00:46:20,710
知道 Mongo DB 可以 Mongo DB 你可以说

1137
00:46:20,710 --> 00:46:22,510
在他们的世界里他们称之为集合

1138
00:46:22,510 --> 00:46:24,760
而不是表 你可以告诉

1139
00:46:24,760 --> 00:46:28,030
Bangi 存储一个表 你在

1140
00:46:28,030 --> 00:46:32,380
单个节点上知道这个，

1141
00:46:32,380 --> 00:46:34,090
但这是它在其他

1142
00:46:34,090 --> 00:46:40,630
系统中并不常见是的这个问题是这些分区是什么

1143
00:46:40,630 --> 00:46:44,730


1144
00:46:45,059 --> 00:46:47,640
为了简单起见并不重要假设实际上没有共享

1145
00:46:47,640 --> 00:46:50,650
实际上是的假设没有

1146
00:46:50,650 --> 00:46:52,329
共享 你没有的共享磁盘架构

1147
00:46:52,329 --> 00:46:54,999
你不一定有这样的

1148
00:46:54,999 --> 00:46:58,960
细粒度控制 你

1149
00:46:58,960 --> 00:47:00,789
可以 基本上你可以

1150
00:47:00,789 --> 00:47:02,769
像 s3 一样你只是有

1151
00:47:02,769 --> 00:47:07,180
不同的表用于不同的存储桶，但你

1152
00:47:07,180 --> 00:47:08,349
不知道任何 信息 你

1153
00:47:08,349 --> 00:47:09,309
没有任何

1154
00:47:09,309 --> 00:47:11,259
实际存储的信息 所以假设这是共享的

1155
00:47:11,259 --> 00:47:16,960
什么是更常见的我们让大多数

1156
00:47:16,960 --> 00:47:17,979
人想到分布式

1157
00:47:17,979 --> 00:47:20,039
这是再次进行水平分区

1158
00:47:20,039 --> 00:47:22,119
Frost 我们假设我们正在做

1159
00:47:22,119 --> 00:47:24,849
烤门系统，因此对于这个系统，我们将通过

1160
00:47:24,849 --> 00:47:27,630
将

1161
00:47:27,630 --> 00:47:30,700
一列或多列视为

1162
00:47:30,700 --> 00:47:34,390
分区键并检查

1163
00:47:34,390 --> 00:47:35,529
这些分区键的值，然后

1164
00:47:35,529 --> 00:47:39,390
决定哪个分区 t 来逐行拆分表 o

1165
00:47:39,390 --> 00:47:43,029
在共享磁盘系统中再次将它分配给这样，所以我

1166
00:47:43,029 --> 00:47:44,410
没有共享您进行物理

1167
00:47:44,410 --> 00:47:46,479
分区的系统，因为每个节点

1168
00:47:46,479 --> 00:47:48,430
实际上都会在

1169
00:47:48,430 --> 00:47:52,180
本地磁盘上存储其分区，然后在

1170
00:47:52,180 --> 00:47:54,359
共享磁盘系统中进行

1171
00:47:54,359 --> 00:47:56,650
逻辑分区 您适合

1172
00:47:56,650 --> 00:47:59,140
分配一个计算节点以允许

1173
00:47:59,140 --> 00:48:03,309
访问特定分区，以便

1174
00:48:03,309 --> 00:48:04,900
您知道您没有

1175
00:48:04,900 --> 00:48:07,660
跨多个节点的同一页面的副本，

1176
00:48:07,660 --> 00:48:09,039
以减少您必须这样做的协调量，

1177
00:48:09,039 --> 00:48:11,829
让我们看看

1178
00:48:11,829 --> 00:48:14,049
研讨会 假设我们选择此

1179
00:48:14,049 --> 00:48:16,960
列作为分区键，我们

1180
00:48:16,960 --> 00:48:19,420
将进行散列分区，这只是

1181
00:48:19,420 --> 00:48:21,039
我们将扫描并

1182
00:48:21,039 --> 00:48:22,539
查看此特定列的每个要沸腾的值，

1183
00:48:22,539 --> 00:48:24,880
然后将其

1184
00:48:24,880 --> 00:48:27,190
散列 mod by 我们拥有的分区数量

1185
00:48:27,190 --> 00:48:30,249
，然后这将告诉

1186
00:48:30,249 --> 00:48:31,569
我们我们实际上想要

1187
00:48:31,569 --> 00:48:35,019
发送数据的位置，所以现在如果出现查询

1188
00:48:35,019 --> 00:48:36,819
并且就像您知道从表中选择星一样

1189
00:48:36,819 --> 00:48:39,249
partiti 在键上等于某个

1190
00:48:39,249 --> 00:48:42,009
值，我们只是

1191
00:48:42,009 --> 00:48:43,450
通过我们相同的散列函数运行该值，现在

1192
00:48:43,450 --> 00:48:46,950
我们确切地知道我们的分区在哪里，

1193
00:48:47,099 --> 00:48:49,180
所以这是散列分区你也

1194
00:48:49,180 --> 00:48:52,650
可以做范围分区

1195
00:48:52,650 --> 00:48:54,670
，我之前已经展示过，你基本上

1196
00:48:54,670 --> 00:48:56,890
说你知道这一点

1197
00:48:56,890 --> 00:48:58,150
值空间

1198
00:48:58,150 --> 00:49:00,579
列的连续段进入这个分区，

1199
00:49:00,579 --> 00:49:02,380
然后我们知道 100 个键进入下一个

1200
00:49:02,380 --> 00:49:04,750
分区，然后同样的事情查询

1201
00:49:04,750 --> 00:49:06,130
显示你看看他们

1202
00:49:06,130 --> 00:49:09,130
试图做一个查找的值，我你知道

1203
00:49:09,130 --> 00:49:10,750
我 知道在哪里路由我想要的数据

1204
00:49:10,750 --> 00:49:12,369
或路由查询以

1205
00:49:12,369 --> 00:49:35,349
找到我想要的数据是的，是的，她的问题

1206
00:49:35,349 --> 00:49:39,690
只是改写您的问题，

1207
00:49:39,690 --> 00:49:41,920
选择要使用的分区键

1208
00:49:41,920 --> 00:49:43,510
实际上是一个 np-complete 问题，

1209
00:49:43,510 --> 00:49:44,529
因为有很多不同

1210
00:49:44,529 --> 00:49:46,900
我能做的组合 我怎么知道

1211
00:49:46,900 --> 00:49:51,520
该怎么做所以这是我

1212
00:49:51,520 --> 00:49:53,109
实际上已经做过研究

1213
00:49:53,109 --> 00:49:54,789
的事情 有四五十年的历史

1214
00:49:54,789 --> 00:49:56,319
，人们开发不同的方法

1215
00:49:56,319 --> 00:49:57,940
和算法来解决问题 再次确认分区

1216
00:49:57,940 --> 00:50:02,230
键 我的顾问顾问

1217
00:50:02,230 --> 00:50:04,329
在 70 年代写了一个他已经死了 我写了一个

1218
00:50:04,329 --> 00:50:07,990
正确的 它基本上就像一个搜索

1219
00:50:07,990 --> 00:50:09,099
优化问题 我看看我的

1220
00:50:09,099 --> 00:50:09,520
工作量

1221
00:50:09,520 --> 00:50:11,319
我看到我如何像

1222
00:50:11,319 --> 00:50:13,329
查询一样访问 我的查询正在访问表和

1223
00:50:13,329 --> 00:50:15,099
我看到这个东西你知道分区

1224
00:50:15,099 --> 00:50:16,539
键你知道一些东西

1225
00:50:16,539 --> 00:50:18,039
一遍又一遍地等于某事那么这

1226
00:50:18,039 --> 00:50:19,869
显然是我想为

1227
00:50:19,869 --> 00:50:22,630
所有电视应用程序选择的那个经常你可以

1228
00:50:22,630 --> 00:50:25,000
我们会谈论零食类你

1229
00:50:25,000 --> 00:50:26,589
几乎可以像树模式一样开发 并

1230
00:50:26,589 --> 00:50:29,559
确定像大脑或传递

1231
00:50:29,559 --> 00:50:31,089
给树，然后将所有内容

1232
00:50:31,089 --> 00:50:34,029
拆分，例如说亚马逊

1233
00:50:34,029 --> 00:50:38,710
根据

1234
00:50:38,710 --> 00:50:42,400
客户所在的州划分其数据库，

1235
00:50:42,400 --> 00:50:43,599
因此这是宾夕法尼亚州的所有客户

1236
00:50:43,599 --> 00:50:46,200
，然后是所有

1237
00:50:46,200 --> 00:50:48,609
订单 宾夕法尼亚州的顾客

1238
00:50:48,609 --> 00:50:50,020
这是他们在宾夕法尼亚州购买的所有物品

1239
00:50:50,020 --> 00:50:51,730
所以我可以把

1240
00:50:51,730 --> 00:50:55,299
宾夕法尼亚州的所有顾客都放在

1241
00:50:55,299 --> 00:50:58,000
一个分区中 所有玛丽

1242
00:50:58,000 --> 00:51:00,460
登陆另一个分区，所以

1243
00:51:00,460 --> 00:51:02,619
很多时候对于它

1244
00:51:02,619 --> 00:51:05,829
的所有应用程序来说，OTP 的密钥应该是什么是很明显的，

1245
00:51:05,829 --> 00:51:06,789
更棘手的是你肯定必须

1246
00:51:06,789 --> 00:51:08,140
查看查询是什么，

1247
00:51:08,140 --> 00:51:10,180
因为你想再次最小

1248
00:51:10,180 --> 00:51:11,260
化 您在 diff 分区之间发送的协调或数据

1249
00:51:11,260 --> 00:51:11,680


1250
00:51:11,680 --> 00:51:25,540
是的 问题是我们是否

1251
00:51:25,540 --> 00:51:29,319
在分区键上有索引 这

1252
00:51:29,319 --> 00:51:30,910
会对设计产生影响 我的意思

1253
00:51:30,910 --> 00:51:33,640
是分区键的选择

1254
00:51:33,640 --> 00:51:48,250
你是什么我的设计好 所以这个

1255
00:51:48,250 --> 00:51:51,190
问题会得到 这个问题

1256
00:51:51,190 --> 00:51:53,230
是我的查询 我的应用程序发送给

1257
00:51:53,230 --> 00:51:57,190
我们 我怎么知道去哪里 哪个

1258
00:51:57,190 --> 00:51:58,589
分区有我正在寻找的数据

1259
00:51:58,589 --> 00:52:00,970
就像它如何知道它使用散列

1260
00:52:00,970 --> 00:52:04,170
函数并发送查询所以如果它是一个

1261
00:52:04,170 --> 00:52:05,950
异构系统 你可以有一个

1262
00:52:05,950 --> 00:52:07,839
像 Mongo 这样的前端查询路由器，

1263
00:52:07,839 --> 00:52:10,300
它说哦，我知道分片键就是

1264
00:52:10,300 --> 00:52:12,849
这里的东西，所以让我

1265
00:52:12,849 --> 00:52:14,559
从查询哈希值中选择它，

1266
00:52:14,559 --> 00:52:15,970
然后我说如果它是我想去的地方

1267
00:52:15,970 --> 00:52:18,940
一个 sh 没有任何具有同

1268
00:52:18,940 --> 00:52:21,490
构架构的系统，你可以说我

1269
00:52:21,490 --> 00:52:24,670
登陆 p1 p1 说哦，你实际上不会

1270
00:52:24,670 --> 00:52:26,559
这个查询，但我没有这个数据 p3

1271
00:52:26,559 --> 00:52:28,390
有它，所以你的查询腐烂了你的查询，

1272
00:52:28,390 --> 00:52:30,250
或者它把你的查询发送到这里运行 它

1273
00:52:30,250 --> 00:52:31,359
然后通过 p1 发回结果

1274
00:52:31,359 --> 00:52:36,430
有不同的方法可以做到这一点，

1275
00:52:36,430 --> 00:52:40,510
所以我在这里展示了哈希

1276
00:52:40,510 --> 00:52:43,510
分区，我们只是根据我拥有

1277
00:52:43,510 --> 00:52:44,950
的分区数量取哈希值 mod

1278
00:52:44,950 --> 00:52:47,170
，这告诉我

1279
00:52:47,170 --> 00:52:49,059
我需要去哪里 问题

1280
00:52:49,059 --> 00:52:59,440
是这个冲突忽略

1281
00:52:59,440 --> 00:53:00,369
冲突假设我们有一个很好的哈希

1282
00:53:00,369 --> 00:53:02,640
值

1283
00:53:04,570 --> 00:53:10,400
所以他说是的所以如果你做哈希

1284
00:53:10,400 --> 00:53:11,870
分区如果你做它的紧缩将

1285
00:53:11,870 --> 00:53:13,730
扫描就像这是

1286
00:53:13,730 --> 00:53:15,230
一个质量谓词哈希

1287
00:53:15,230 --> 00:53:17,060
分区的范围谓词集是 一个坏主意，因为我不能

1288
00:53:17,060 --> 00:53:18,680
在哈希表的同一时间对范围进行

1289
00:53:18,680 --> 00:53:27,380
哈希处理，但不能对其他范围进行哈希处理，所以他的

1290
00:53:27,380 --> 00:53:29,360
问题是，

1291
00:53:29,360 --> 00:53:31,670
如果我在此列上说分区，我是否正确更新分区键我对这列进行了分区，

1292
00:53:31,670 --> 00:53:33,170


1293
00:53:33,170 --> 00:53:35,120
我必须移动 一切 是的，但

1294
00:53:35,120 --> 00:53:37,070
这种情况不会经常发生，

1295
00:53:37,070 --> 00:53:40,160
就像想想

1296
00:53:40,160 --> 00:53:43,130
你的亚马逊账户 ID 他们不是

1297
00:53:43,130 --> 00:53:44,690
他们不会说好吧我们

1298
00:53:44,690 --> 00:53:45,620
不会对此进行分区以及

1299
00:53:45,620 --> 00:53:46,760
在他的另一个上购买什么 比你的电子邮件

1300
00:53:46,760 --> 00:53:53,150
地址很少发生宾果游戏，

1301
00:53:53,150 --> 00:53:56,240
所以他说如果我在这里有第 5 个分区

1302
00:53:56,240 --> 00:53:58,970
，我会遇到与我们谈论哈希表时遇到的同样问题

1303
00:53:58,970 --> 00:54:00,500
，我

1304
00:54:00,500 --> 00:54:01,580
明白为什么我们必须首先谈论单

1305
00:54:01,580 --> 00:54:03,350
节点的东西 如果我现在这里有第 5 个

1306
00:54:03,350 --> 00:54:05,570
分区 如果我重新散列所有

1307
00:54:05,570 --> 00:54:07,220
值并修改 5 个它们不能

1308
00:54:07,220 --> 00:54:08,660
保证是相同的分区我

1309
00:54:08,660 --> 00:54:11,120
最终可能会移动整个数据库

1310
00:54:11,120 --> 00:54:12,830
每个人都可能会交换并

1311
00:54:12,830 --> 00:54:17,920
移动到另一个位置所以这很糟糕

1312
00:54:17,920 --> 00:54:21,500
所以我们 需要一种方法来处理这里

1313
00:54:21,500 --> 00:54:23,740
曾经听说过一致性散列的人

1314
00:54:23,740 --> 00:54:27,530
很少很好很好完美所以一致性

1315
00:54:27,530 --> 00:54:28,940
散列是在

1316
00:54:28,940 --> 00:54:31,550
2000 年代早期开发的一种技术，它基本上必须

1317
00:54:31,550 --> 00:54:32,870
这样做的方式允许进行增量

1318
00:54:32,870 --> 00:54:35,570
更新和删除部分

1319
00:54:35,570 --> 00:54:37,760
不必移动所有东西就可以在集群中使用它，

1320
00:54:37,760 --> 00:54:40,280
所以

1321
00:54:40,280 --> 00:54:42,710
考虑这个的方式是散列空间

1322
00:54:42,710 --> 00:54:47,150
只是一个从 0 到 1 的环，所以我

1323
00:54:47,150 --> 00:54:50,570
要说三个分区 a B 和 C 所以

1324
00:54:50,570 --> 00:54:51,740
思考这个的方式 就像如果我

1325
00:54:51,740 --> 00:54:54,410
现在散列键并且我不修改

1326
00:54:54,410 --> 00:54:56,030
分区的数量我只是散列它并

1327
00:54:56,030 --> 00:54:58,910
说你把它放在 0 1 Sally 和

1328
00:54:58,910 --> 00:55:01,640
环中的这一点之间，然后我

1329
00:55:01,640 --> 00:55:04,310
向前顺时针运动直到

1330
00:55:04,310 --> 00:55:07,310
找到节点 它有第一个出现的节点

1331
00:55:07,310 --> 00:55:09,290
，这就是我知道我的

1332
00:55:09,290 --> 00:55:11,960
数据将被定位的地方，所以我对它进行哈希处理，

1333
00:55:11,960 --> 00:55:14,360
我得到一个值，将它放在 0 和 1 之间，我

1334
00:55:14,360 --> 00:55:16,400
知道在这之间你

1335
00:55:16,400 --> 00:55:18,289
知道这样做，这是一个

1336
00:55:18,289 --> 00:55:21,410
我想要的数据就在同样的事情

1337
00:55:21,410 --> 00:55:23,539
上 我散列到我在这里降落 所以我们

1338
00:55:23,539 --> 00:55:25,670
在环形空间 我跳到这里

1339
00:55:25,670 --> 00:55:28,849
去出海 所以

1340
00:55:28,849 --> 00:55:32,509
对于所有这些人来说，通往关键空间的路是从

1341
00:55:32,509 --> 00:55:34,940
从 bueno punkin 开始回到

1342
00:55:34,940 --> 00:55:39,259
下一个分区，这很好，这

1343
00:55:39,259 --> 00:55:39,829
不是

1344
00:55:39,829 --> 00:55:42,170
那么重要 n 现在是当我

1345
00:55:42,170 --> 00:55:45,230
针对 AI 添加新节点时，我的干扰数据库

1346
00:55:45,230 --> 00:55:46,670
无法跟上我

1347
00:55:46,670 --> 00:55:48,499
试图支持的流量，所以我想添加新

1348
00:55:48,499 --> 00:55:50,900
机器并向外扩展，所以假设

1349
00:55:50,900 --> 00:55:53,930
我在这里有一个新分区，所以 如果我

1350
00:55:53,930 --> 00:55:55,339
正在做

1351
00:55:55,339 --> 00:55:58,099
我在上一张幻灯片中展示的静态散列技术，那么我

1352
00:55:58,099 --> 00:56:01,130
现在添加第四个第四个分区，我现在

1353
00:56:01,130 --> 00:56:03,349
得到了一个 Reno rehash 和 mod bye 现在

1354
00:56:03,349 --> 00:56:05,089
每个人，我们不得不移动可能

1355
00:56:05,089 --> 00:56:07,099
移动所有数据，但方式

1356
00:56:07,099 --> 00:56:08,690
因为 系统散列的工作原理是我

1357
00:56:08,690 --> 00:56:11,119
将我的家伙添加到这里的戒指中，

1358
00:56:11,119 --> 00:56:13,059
现在我唯一需要传输的是

1359
00:56:13,059 --> 00:56:16,880
C 过去放置奇怪电子邮件的任何东西，

1360
00:56:16,880 --> 00:56:20,269
所以它只是这个分区

1361
00:56:20,269 --> 00:56:21,829
中所有电池

1362
00:56:21,829 --> 00:56:23,059
中的这一部分 这将被

1363
00:56:23,059 --> 00:56:25,400
Ring 的这一部分覆盖，我将

1364
00:56:25,400 --> 00:56:28,670
它们发送下来，我的

1365
00:56:28,670 --> 00:56:32,900
集群中的其他所有人都留在他们所在的位置，这样我就可以

1366
00:56:32,900 --> 00:56:34,039
添加新的部分，您知道获取新

1367
00:56:34,039 --> 00:56:36,680
分区，他们只是更新 Ring

1368
00:56:36,680 --> 00:56:40,009
并在其中添加一个新空间，同样如此 如果我

1369
00:56:40,009 --> 00:56:42,710
采取一个分区 aw 那么

1370
00:56:42,710 --> 00:56:48,079
这里的任何东西都只是达到了 C 所在的位置，所以

1371
00:56:48,079 --> 00:56:49,160
这项技术真的很有趣

1372
00:56:49,160 --> 00:56:50,599
，而且复制的方法

1373
00:56:50,599 --> 00:56:52,430
还可以，我们将在下一课中介绍更多内容，

1374
00:56:52,430 --> 00:56:53,809
但假设我想要

1375
00:56:53,809 --> 00:56:56,390
复制因子为 3，因此对于

1376
00:56:56,390 --> 00:56:58,910
我插入到我的数据库中的磁带元组中的每一个

1377
00:56:58,910 --> 00:57:01,220
我希望它是我希望

1378
00:57:01,220 --> 00:57:02,779
在三个不同的节点

1379
00:57:02,779 --> 00:57:04,730
或三个不同的分区上进行复制，

1380
00:57:04,730 --> 00:57:07,160
这样如果其中一个出现故障，我还有另外两个

1381
00:57:07,160 --> 00:57:10,190
可用

1382
00:57:10,190 --> 00:57:11,509
作为备份 并且我的数据库没有

1383
00:57:11,509 --> 00:57:15,880
宕机，所以现在说我正在复制 a 并且

1384
00:57:15,880 --> 00:57:18,289
我将在三个节点上复制它所以

1385
00:57:18,289 --> 00:57:20,299
我在 a 理事会上有一个然后两个和

1386
00:57:20,299 --> 00:57:22,730
三个所以任何对 a 的任何键的任何权利

1387
00:57:22,730 --> 00:57:26,960
都是 也将在 F 和 B 上，所以

1388
00:57:26,960 --> 00:57:28,430
现在当我的查询显示

1389
00:57:28,430 --> 00:57:30,019
相同的内容时，我会在雨中散列到这一点

1390
00:57:30,019 --> 00:57:30,300


1391
00:57:30,300 --> 00:57:34,200
，我可以从 F 或 B 中获取它，

1392
00:57:34,200 --> 00:57:39,450
并且我在那里，

1393
00:57:39,450 --> 00:57:41,070
假设您在那里 做交易

1394
00:57:41,070 --> 00:57:43,380
我们将在下节课讨论，所以现在这

1395
00:57:43,380 --> 00:57:44,730
实际上进入了一致性

1396
00:57:44,730 --> 00:57:46,920
起诉我们，我们有点掩饰，

1397
00:57:46,920 --> 00:57:47,970
我们之前谈论过交易，

1398
00:57:47,970 --> 00:57:50,430
谈论过酸，如果我

1399
00:57:50,430 --> 00:57:52,830
写一篇文章，我怎么知道它已经

1400
00:57:52,830 --> 00:57:56,880
传播到 F、FFF 和 B，我

1401
00:57:56,880 --> 00:57:58,200
你必须等到他们全部

1402
00:57:58,200 --> 00:57:59,510
承认他们是正确的

1403
00:57:59,510 --> 00:58:01,620
，这可能很糟糕，因为其中一个人

1404
00:58:01,620 --> 00:58:03,720
可能会失败，我正在等待

1405
00:58:03,720 --> 00:58:06,030
确认，我正在拖延，或者我

1406
00:58:06,030 --> 00:58:08,250
说我不等待，但现在我

1407
00:58:08,250 --> 00:58:11,070
遇到了这个问题，我可能会做一个 写在 a 上，

1408
00:58:11,070 --> 00:58:12,750
然后只是尝试在 B 上阅读那件事

1409
00:58:12,750 --> 00:58:16,070
，我可能看不到我希望再次看到的内容

1410
00:58:16,070 --> 00:58:18,180
，因此我们将在下一堂课中更多地介绍这一点

1411
00:58:18,180 --> 00:58:19,260
，但这是

1412
00:58:19,260 --> 00:58:21,780
一致性，这就是我所说的 C 和酸

1413
00:58:21,780 --> 00:58:23,430
我们将掩盖

1414
00:58:23,430 --> 00:58:25,140
单节点数据库，但在

1415
00:58:25,140 --> 00:58:27,720
分布式数据库中很重要，因此一致性

1416
00:58:27,720 --> 00:58:29,970
哈希是一种非常酷的技术，

1417
00:58:29,970 --> 00:58:31,170
它实际上用于一些分布式

1418
00:58:31,170 --> 00:58:33,420
数据库，因此三个最著名的

1419
00:58:33,420 --> 00:58:37,170
是 memcache D，它是缓存

1420
00:58:37,170 --> 00:58:37,790
服务

1421
00:58:37,790 --> 00:58:41,790
Cassandra 和 dynamodb，如 Dino DD 我

1422
00:58:41,790 --> 00:58:42,870
认为是 第一篇论文

1423
00:58:42,870 --> 00:58:45,030
讨论了使用它的架构，

1424
00:58:45,030 --> 00:58:48,120
然后在 Facebook

1425
00:58:48,120 --> 00:58:50,130
，云时代的联合创始人之一，他看到了

1426
00:58:50,130 --> 00:58:51,750
DynamoDB Bieber 希望这是一个好

1427
00:58:51,750 --> 00:58:53,010
主意，但在 Facebook 的 Cassandra 中，

1428
00:58:53,010 --> 00:58:53,580


1429
00:58:53,580 --> 00:58:55,200
facebook 说我不，我们实际上没有

1430
00:58:55,200 --> 00:58:56,640
不再需要这个了，他们决定

1431
00:58:56,640 --> 00:58:58,500
不使用 Cassandra 所以他们只是

1432
00:58:58,500 --> 00:59:01,080
将它开源并放在那里

1433
00:59:01,080 --> 00:59:02,250
然后人们拿起它并

1434
00:59:02,250 --> 00:59:04,260
开始制作 Cassandra 实际上是你

1435
00:59:04,260 --> 00:59:06,840
知道的质量系统 所以这可能是

1436
00:59:06,840 --> 00:59:08,100
三个最著名的系统 使用

1437
00:59:08,100 --> 00:59:11,120
这种一致的散列技术

1438
00:59:11,120 --> 00:59:16,740
好吧，所以新的简要

1439
00:59:16,740 --> 00:59:17,610
说明了

1440
00:59:17,610 --> 00:59:18,960
逻辑分区和物理

1441
00:59:18,960 --> 00:59:20,610
分区之间的区别，所以这个想法

1442
00:59:20,610 --> 00:59:22,770
是相同的，你有这个散列

1443
00:59:22,770 --> 00:59:24,540
函数或范围范围函数，

1444
00:59:24,540 --> 00:59:25,710
允许你划分数据库

1445
00:59:25,710 --> 00:59:27,050
和两个不相交的子集，

1446
00:59:27,050 --> 00:59:29,700
但在共享要点系统下，您

1447
00:59:29,700 --> 00:59:31,620
必须进行逻辑分区，因为

1448
00:59:31,620 --> 00:59:34,800
您无法控制数据

1449
00:59:34,800 --> 00:59:36,420
的实际情况 被写入共享

1450
00:59:36,420 --> 00:59:38,340
磁盘的事情是正确的 Amazon 控制这一点，

1451
00:59:38,340 --> 00:59:39,590
你没有

1452
00:59:39,590 --> 00:59:42,120
所以它工作的基本方式是

1453
00:59:42,120 --> 00:59:43,730
你

1454
00:59:43,730 --> 00:59:46,310
有一个儿子，你将数据库的某些部分签署

1455
00:59:46,310 --> 00:59:48,530
到这些不同的计算

1456
00:59:48,530 --> 00:59:50,359
节点，这样应用程序服务器就会再次

1457
00:59:50,359 --> 00:59:52,040
知道，如果我 想要 X 你在

1458
00:59:52,040 --> 00:59:54,320
这里查询这里是机器去

1459
00:59:54,320 --> 00:59:56,770
获取你知道的去运行它

1460
00:59:56,770 --> 00:59:58,820
同样从这里开始他

1461
00:59:58,820 --> 01:00:02,150
负责三个不共享的

1462
01:00:02,150 --> 01:00:03,980
系统在你再次进行物理分区时正在运行

1463
01:00:03,980 --> 01:00:05,780
这是你

1464
01:00:05,780 --> 01:00:08,300
拥有每个的地方 每个节点都被

1465
01:00:08,300 --> 01:00:11,930
分配给分区一部分

1466
01:00:11,930 --> 01:00:13,700
由分区管理的数据，所以

1467
01:00:13,700 --> 01:00:15,140
同样的事情我知道如何

1468
01:00:15,140 --> 01:00:17,359
从这些不同的节点获取我正在寻找的数据，

1469
01:00:17,359 --> 01:00:21,740
所以我们还

1470
01:00:21,740 --> 01:00:23,000
剩下十分钟，让我们完成

1471
01:00:23,000 --> 01:00:24,859
然后这将使我们从

1472
01:00:24,859 --> 01:00:28,070
周三的课程开始，所以当我们想要

1473
01:00:28,070 --> 01:00:29,599
开始实际交易时，这就是

1474
01:00:29,599 --> 01:00:32,690
事情变得困难的时候，这件事变得

1475
01:00:32,690 --> 01:00:34,940
昂贵，这就是为什么我看到她的问题

1476
01:00:34,940 --> 01:00:37,430
是她的追求 ion 之前是 Oh 并不

1477
01:00:37,430 --> 01:00:38,540
总是有意义 也许尝试

1478
01:00:38,540 --> 01:00:40,160
垂直扩展 为什么你会想要

1479
01:00:40,160 --> 01:00:42,650
水平扩展

1480
01:00:42,650 --> 01:00:44,359
就像如果你垂直扩展会有收益递减一样

1481
01:00:44,359 --> 01:00:46,460
海港

1482
01:00:46,460 --> 01:00:48,260
实际上不会变得更好 因为你就是你

1483
01:00:48,260 --> 01:00:50,119
你买不到一台机器，你

1484
01:00:50,119 --> 01:00:51,650
知道它会立即更快，而且

1485
01:00:51,650 --> 01:00:52,970
还假设你的软件实际上可以

1486
01:00:52,970 --> 01:00:54,109
扩展并且它不会

1487
01:00:54,109 --> 01:00:56,900
受到 cerei 并发

1488
01:00:56,900 --> 01:00:59,390
瓶颈和其他事情的困扰，如果你

1489
01:00:59,390 --> 01:01:02,180
不害怕 hosana lee 那么你也是

1490
01:01:02,180 --> 01:01:03,380
将会有递减的回报和

1491
01:01:03,380 --> 01:01:05,480
性能提升，因为现在

1492
01:01:05,480 --> 01:01:06,230
你最终会得到所谓的

1493
01:01:06,230 --> 01:01:09,500
分布操作，所以如果我有

1494
01:01:09,500 --> 01:01:11,240
一些东西必须更新单个节点上的数据，

1495
01:01:11,240 --> 01:01:13,280
我们知道该怎么做，我们已经

1496
01:01:13,280 --> 01:01:14,569
整整一个学期都在讨论这个

1497
01:01:14,569 --> 01:01:15,530
这将是最快

1498
01:01:15,530 --> 01:01:17,329
的最佳情况

1499
01:01:17,329 --> 01:01:19,790
，我需要的交易意味着要接触

1500
01:01:19,790 --> 01:01:21,470
数据，这一切都在一个节点中，我可以随时运行

1501
01:01:21,470 --> 01:01:22,490
，而无需与任何人

1502
01:01:22,490 --> 01:01:24,770
相关联 否则，如果我需要

1503
01:01:24,770 --> 01:01:27,349
跨 altima 节点拥有状态，那么现在

1504
01:01:27,349 --> 01:01:29,180
我需要一种方法来确保如果我

1505
01:01:29,180 --> 01:01:30,829
在这里正确，并且

1506
01:01:30,829 --> 01:01:33,980
当我的事务说提交时我在这里正确地提交它

1507
01:01:33,980 --> 01:01:35,480
实际上确实提交了，因为我只

1508
01:01:35,480 --> 01:01:36,560
确保所有 可能会改变它们的原子性

1509
01:01:36,560 --> 01:01:38,599
和持久性，就像我不是一个

1510
01:01:38,599 --> 01:01:40,760
单节点系统一样，这会变得很

1511
01:01:40,760 --> 01:01:42,050
昂贵，因为我如何

1512
01:01:42,050 --> 01:01:45,200
确保如果我说我提交那么每个人

1513
01:01:45,200 --> 01:01:47,980
实际上都真正提交了

1514
01:01:49,110 --> 01:01:52,340
所以我们可以做到这一点的方式是通过一个

1515
01:01:52,340 --> 01:01:55,440
下水道事务协调器，所以你

1516
01:01:55,440 --> 01:01:56,880
有点认为这就像

1517
01:01:56,880 --> 01:01:59,550
整个系统的交通警察 它允许一种

1518
01:01:59,550 --> 01:02:01,410
方法来确定谁可以做

1519
01:02:01,410 --> 01:02:04,680
什么以及何时需要

1520
01:02:04,680 --> 01:02:06,810
提交 每个人都同意我们

1521
01:02:06,810 --> 01:02:09,870
实际上要继续 并提交因此

1522
01:02:09,870 --> 01:02:10,920
这两种不同的方法是

1523
01:02:10,920 --> 01:02:12,570
集中式分散式的一种集中式方法

1524
01:02:12,570 --> 01:02:13,950
是每个人都去某个

1525
01:02:13,950 --> 01:02:15,990
集中的位置，该位置可以完整地

1526
01:02:15,990 --> 01:02:18,060
了解我们内部系统内部发生的一切

1527
01:02:18,060 --> 01:02:19,980
，然后做出

1528
01:02:19,980 --> 01:02:21,060
决定 ns 关于你是否被

1529
01:02:21,060 --> 01:02:23,310
允许提交，这是一种分散的

1530
01:02:23,310 --> 01:02:24,690
方法，节点试图组织

1531
01:02:24,690 --> 01:02:26,610
自己并做出关于是的决定

1532
01:02:26,610 --> 01:02:28,260
我们这个交易做了这些

1533
01:02:28,260 --> 01:02:30,090
更改，我们被允许提交，

1534
01:02:30,090 --> 01:02:32,070
我们可以通知任何其他人

1535
01:02:32,070 --> 01:02:33,990
参与 他们成功提交的交易，所以

1536
01:02:33,990 --> 01:02:38,010


1537
01:02:38,010 --> 01:02:39,390
我们的

1538
01:02:39,390 --> 01:02:40,680
交易协调器中的一个交易的第一个版本是现在 1980

1539
01:02:40,680 --> 01:02:42,600
年代 1970 年代被称为 TP 监视器的东西，

1540
01:02:42,600 --> 01:02:43,200


1541
01:02:43,200 --> 01:02:44,970
我想如果您查看

1542
01:02:44,970 --> 01:02:47,010
维基百科文章 TP 代表

1543
01:02:47,010 --> 01:02:49,590
事务处理监视器 早

1544
01:02:49,590 --> 01:02:51,590
在 70 年代，他们称这些东西为电信

1545
01:02:51,590 --> 01:02:53,820
处理监控器，因为这些东西

1546
01:02:53,820 --> 01:02:55,350
是为早期

1547
01:02:55,350 --> 01:02:57,090
的电话公司

1548
01:02:57,090 --> 01:02:58,350


1549
01:02:58,350 --> 01:02:59,790


1550
01:02:59,790 --> 01:03:04,920
而设计的 所以

1551
01:03:04,920 --> 01:03:06,900
考虑这个 TP 监视器的方式是它

1552
01:03:06,900 --> 01:03:09,440
是一个独立的软件，

1553
01:03:09,440 --> 01:03:12,120
每个人都必须与之交谈才能

1554
01:03:12,120 --> 01:03:13,170
弄清楚是否

1555
01:03:13,170 --> 01:03:15,900
嘿嘿，在分布式数据库上做某些操作，

1556
01:03:15,900 --> 01:03:18,120
所以数据库

1557
01:03:18,120 --> 01:03:20,100
系统本身可以存储在

1558
01:03:20,100 --> 01:03:21,690
不同的节点上，如果你只是拿我的，他们真的不

1559
01:03:21,690 --> 01:03:23,340
知道他们实际上参与

1560
01:03:23,340 --> 01:03:24,600
了分布式事务或

1561
01:03:24,600 --> 01:03:26,070
分布式数据库

1562
01:03:26,070 --> 01:03:27,810
续集你

1563
01:03:27,810 --> 01:03:30,270
想要单独运行的任何单节点系统然后在

1564
01:03:30,270 --> 01:03:31,710
上面你有这个被监控

1565
01:03:31,710 --> 01:03:32,820
允许你弄清楚你是否被

1566
01:03:32,820 --> 01:03:35,670
允许做某些事情所以它看起来

1567
01:03:35,670 --> 01:03:36,960
像这样所以我们有应用程序

1568
01:03:36,960 --> 01:03:40,410
服务器我们有四个分区所以

1569
01:03:40,410 --> 01:03:42,210
使用这三个分区保存您的事务，

1570
01:03:42,210 --> 01:03:44,400
因此我们将

1571
01:03:44,400 --> 01:03:45,990
通过转到协调器来开始我们的事务

1572
01:03:45,990 --> 01:03:48,810
并说嘿我们想要修改

1573
01:03:48,810 --> 01:03:50,880
这些分区中的一些数据我们需要

1574
01:03:50,880 --> 01:03:52,680
为它们获取锁我们

1575
01:03:52,680 --> 01:03:55,050
允许这样做和 然后

1576
01:03:55,050 --> 01:03:56,250
协调员说好吧我知道

1577
01:03:56,250 --> 01:03:57,210
其他地方正在运行系统因为

1578
01:03:57,210 --> 01:03:59,550
每个人都必须通过我是的我

1579
01:03:59,550 --> 01:04:00,870
看到这些锁可用所以我

1580
01:04:00,870 --> 01:04:02,550
要签署它们

1581
01:04:02,550 --> 01:04:04,260
然后告诉你，你知道你已经

1582
01:04:04,260 --> 01:04:05,760
获得了它们，然后现在

1583
01:04:05,760 --> 01:04:07,890
应用程序服务器可以去

1584
01:04:07,890 --> 01:04:09,360
不同的分区做

1585
01:04:09,360 --> 01:04:11,580
任何想做的事情来进行更改和想要进行的更改

1586
01:04:11,580 --> 01:04:14,580
，然后当它想要去的

1587
01:04:14,580 --> 01:04:16,200
时候 提前并提交给

1588
01:04:16,200 --> 01:04:17,760
协调员并说嘿我想

1589
01:04:17,760 --> 01:04:19,380
提交我做了这些更改这些

1590
01:04:19,380 --> 01:04:21,360
分区我允许这样做

1591
01:04:21,360 --> 01:04:23,280
并且协调员负责

1592
01:04:23,280 --> 01:04:24,750
与这里的这些人沟通

1593
01:04:24,750 --> 01:04:27,270
并说嘿我想你知道

1594
01:04:27,270 --> 01:04:28,920
这件事 交易因为它告诉我

1595
01:04:28,920 --> 01:04:30,690
它会触动你实际上做了

1596
01:04:30,690 --> 01:04:32,610
任何事情然后他们回来说

1597
01:04:32,610 --> 01:04:34,950
是的你知道这些变化是

1598
01:04:34,950 --> 01:04:37,080
发生了什么而且他们可以或安全地

1599
01:04:37,080 --> 01:04:39,780
提交然后一旦我们

1600
01:04:39,780 --> 01:04:41,610
每个人都同意角膜

1601
01:04:41,610 --> 01:04:42,840
认识到每个人都同意我们

1602
01:04:42,840 --> 01:04:44,370
可以去承诺我们可以支持我们的

1603
01:04:44,370 --> 01:04:49,860
知识意味着问题问题我

1604
01:04:49,860 --> 01:04:51,420
知道什么情况下会

1605
01:04:51,420 --> 01:04:56,460
不安全所以假设我违反了你

1606
01:04:56,460 --> 01:04:58,080
知道的诚信约束 在这里，我的

1607
01:04:58,080 --> 01:05:00,390
交易中止了，我尝试插入

1608
01:05:00,390 --> 01:05:02,880
一个重复的密钥，造币者不

1609
01:05:02,880 --> 01:05:04,500
知道你做了什么，它说嘿，我想撬开

1610
01:05:04,500 --> 01:05:06,270
这些东西的锁，我想

1611
01:05:06,270 --> 01:05:07,470
我想以分布式方式提交，

1612
01:05:07,470 --> 01:05:10,170
你必须去 问他们这

1613
01:05:10,170 --> 01:05:11,250
是否很像

1614
01:05:11,250 --> 01:05:15,870
为了简单起见他们被允许这样做他的问题是

1615
01:05:15,870 --> 01:05:17,460
我们很幸运整个分区的简单性

1616
01:05:17,460 --> 01:05:21,780
是的，我认为它

1617
01:05:21,780 --> 01:05:23,010
就像 XA 如果有一个协议允许

1618
01:05:23,010 --> 01:05:24,960
你做更细粒度的锁定只是

1619
01:05:24,960 --> 01:05:28,970
愚蠢的分区 让它变得简单，好吧，

1620
01:05:31,680 --> 01:05:38,220
所以再说一次，有很多

1621
01:05:38,220 --> 01:05:40,470
企业软件供应商向你出售

1622
01:05:40,470 --> 01:05:42,450
电视监视器

1623
01:05:42,450 --> 01:05:45,150
Oracle 有一种叫做 tuxedo 的东西 IBM

1624
01:05:45,150 --> 01:05:46,650
出售一种叫做 tranzec 的东西

1625
01:05:46,650 --> 01:05:48,390
，它实际上是一个高级创业公司，就像

1626
01:05:48,390 --> 01:05:50,370
做这件事的人一样 在

1627
01:05:50,370 --> 01:05:52,230
80 年代，他们做了一家名为 tranzec 的初创公司，我

1628
01:05:52,230 --> 01:05:54,170
被 IBM 收购，IBM 仍然卖给我们

1629
01:05:54,170 --> 01:05:56,160
有一个项目你无法真正读懂

1630
01:05:56,160 --> 01:05:58,320
它的标志，它叫做 Apache Omid 它是

1631
01:05:58,320 --> 01:06:01,170
由雅虎构建的，它是它的 基本上

1632
01:06:01,170 --> 01:06:04,050
是 HBase anos 生态系统的 teepee 监视器

1633
01:06:04,050 --> 01:06:05,460
，今天实际上被其他几个系统使用，

1634
01:06:05,460 --> 01:06:08,070
因此您可以构建一个贡品

1635
01:06:08,070 --> 01:06:09,570
数据库而不必担心

1636
01:06:09,570 --> 01:06:11,310
事务，您是否可以依靠

1637
01:06:11,310 --> 01:06:12,900
这些人为您解决问题，

1638
01:06:12,900 --> 01:06:14,970
而您只需完成所有单节点的

1639
01:06:14,970 --> 01:06:17,990
工作 你打赌你是正常的，

1640
01:06:18,680 --> 01:06:21,150
但更常见的是使用

1641
01:06:21,150 --> 01:06:22,650
集中协调器作为中间件

1642
01:06:22,650 --> 01:06:24,749
，你有这个

1643
01:06:24,749 --> 01:06:26,489
软件位于应用程序服务器

1644
01:06:26,489 --> 01:06:29,009
和数据库分区之间，所有查询

1645
01:06:29,009 --> 01:06:31,709
都通过这个中间件，

1646
01:06:31,709 --> 01:06:33,180
中间件负责 弄清楚

1647
01:06:33,180 --> 01:06:34,890
哦，这个数据想要这个查询想要

1648
01:06:34,890 --> 01:06:37,289
接触这个分区的这个数据，所以它

1649
01:06:37,289 --> 01:06:39,150
会查看它，你知道它是它的

1650
01:06:39,150 --> 01:06:40,890
全局锁表或有关

1651
01:06:40,890 --> 01:06:43,170
分区的信息在那里，它会

1652
01:06:43,170 --> 01:06:46,589
根据需要为你路由查询，所以你看起来

1653
01:06:46,589 --> 01:06:48,959
像你 通过中间件与单个单

1654
01:06:48,959 --> 01:06:50,249
节点数据库系统交谈，

1655
01:06:50,249 --> 01:06:52,200
但在后端，它

1656
01:06:52,200 --> 01:06:53,579
在这些

1657
01:06:53,579 --> 01:06:56,609
不同的分区中分布和中断，因此 当提交

1658
01:06:56,609 --> 01:06:57,779
请求由应用程序

1659
01:06:57,779 --> 01:06:59,640
服务器 de moda 出现时，它与

1660
01:06:59,640 --> 01:07:01,319
TP 监视器做同样的事情，它会与

1661
01:07:01,319 --> 01:07:02,789
这些人通信并说，嘿，我们允许

1662
01:07:02,789 --> 01:07:06,450
提交，只有当每个人都同意时，

1663
01:07:06,450 --> 01:07:09,779
你才发回确认，所以

1664
01:07:09,779 --> 01:07:11,069
这个 这种方法实际上

1665
01:07:11,069 --> 01:07:13,200
非常非常普遍，就像 Facebook

1666
01:07:13,200 --> 01:07:14,549
可能是最著名的一个 Facebook 运行

1667
01:07:14,549 --> 01:07:16,759
着世界上最大的我的续集集群

1668
01:07:16,759 --> 01:07:19,289
，他们有一个中间件助手来

1669
01:07:19,289 --> 01:07:21,599
为你做所有这些路由谷歌曾经

1670
01:07:21,599 --> 01:07:24,019
为我的续集做这件事在广告中

1671
01:07:24,019 --> 01:07:26,160
有一个 来自 YouTube 的行星规模，

1672
01:07:26,160 --> 01:07:27,779
但这种方法实际上

1673
01:07:27,779 --> 01:07:29,459
非常普遍，你带我们了解

1674
01:07:29,459 --> 01:07:31,619
Postgres 我的续集，不管你知道

1675
01:07:31,619 --> 01:07:32,819
你最喜欢的单节点数据库

1676
01:07:32,819 --> 01:07:34,619
系统是什么，你

1677
01:07:34,619 --> 01:07:36,319
在它前面构建这个小包装层

1678
01:07:36,319 --> 01:07:40,499
eBay 用 Oracle 做到了这一点 这是很

1679
01:07:40,499 --> 01:07:44,729
常见的另一种方法是在

1680
01:07:44,729 --> 01:07:46,009
没有协调员的情况下进行集中

1681
01:07:46,009 --> 01:07:48,719
协调的最后一个版本，您

1682
01:07:48,719 --> 01:07:50,609
没有对 g 的集中视图

1683
01:07:50,609 --> 01:07:52,769
在系统中，应用程序

1684
01:07:52,769 --> 01:07:55,799
永远不会与某个主

1685
01:07:55,799 --> 01:07:57,930
分区或基本分区通信 某个

1686
01:07:57,930 --> 01:07:59,609
负责

1687
01:07:59,609 --> 01:08:01,619
此给定事务的

1688
01:08:01,619 --> 01:08:03,089
主节点 如果您假设

1689
01:08:03,089 --> 01:08:05,759
您是同构架构，那么他们所有的笔记都将是主节点，因此您

1690
01:08:05,759 --> 01:08:07,499
发送所有 查询请求

1691
01:08:07,499 --> 01:08:09,329
直接到主节点或

1692
01:08:09,329 --> 01:08:10,890
单个分区都没有关系，

1693
01:08:10,890 --> 01:08:13,559
但是当你想要提交时，你

1694
01:08:13,559 --> 01:08:15,690
去主节点说嘿，我做了

1695
01:08:15,690 --> 01:08:17,729
这些更改，我想在提交事务之前进行

1696
01:08:17,729 --> 01:08:19,738
，然后它是

1697
01:08:19,738 --> 01:08:21,060
负责与

1698
01:08:21,060 --> 01:08:22,290
其他分区通信并决定是否

1699
01:08:22,290 --> 01:08:24,000
允许您提交，如果是，则

1700
01:08:24,000 --> 01:08:27,049
您可以将确认发回，

1701
01:08:27,819 --> 01:08:30,549
所以我称之为

1702
01:08:30,549 --> 01:08:32,799
Stover 的事情是我们

1703
01:08:32,799 --> 01:08:34,229
如何确定提交问题是否安全的一部分

1704
01:08:34,229 --> 01:08:40,540
这个问题是你如何

1705
01:08:40,540 --> 01:08:45,640
获取锁，所以它会再次

1706
01:08:45,640 --> 01:08:47,140
假设我正在做很多项目

1707
01:08:47,140 --> 01:08:49,120
锁定整个分区，所以当查询

1708
01:08:49,120 --> 01:08:52,569
出现在你身边时 尝试

1709
01:08:52,569 --> 01:08:57,279
在那时获取锁，以便主

1710
01:08:57,279 --> 01:09:00,490
节点只知道信息，

1711
01:09:00,490 --> 01:09:01,930
并且可能知道

1712
01:09:01,930 --> 01:09:03,640
您触摸的分区的信息，不知道您对它们做了什么，

1713
01:09:03,640 --> 01:09:06,520
并且它响应负责的

1714
01:09:06,520 --> 01:09:07,630
应用程序说嘿我

1715
01:09:07,630 --> 01:09:08,859
无法获得锁 这个分区

1716
01:09:08,859 --> 01:09:10,299
我必须中止我的交易所以你

1717
01:09:10,299 --> 01:09:12,149
回到这个人嘿说我中止

1718
01:09:12,149 --> 01:09:14,020
或者你只需发送

1719
01:09:14,020 --> 01:09:15,100
这个人和他

1720
01:09:15,100 --> 01:09:16,510
负责向

1721
01:09:16,510 --> 01:09:21,700
主节点上的不同机器转出的所有请求如果你在主节点

1722
01:09:21,700 --> 01:09:23,350
上接触数据

1723
01:09:23,350 --> 01:09:29,890
当然是的，

1724
01:09:29,890 --> 01:09:34,450
所以我们将在下节课更详细地介绍这一点，

1725
01:09:34,450 --> 01:09:37,990
这给你留下了深刻的印象，然后

1726
01:09:37,990 --> 01:09:39,430
你会考虑它，并在

1727
01:09:39,430 --> 01:09:40,750
周三看到为什么你知道这

1728
01:09:40,750 --> 01:09:43,180
实际上有多难说我们正在做

1729
01:09:43,180 --> 01:09:45,189
我最后的两阶段锁定 例如，说我的

1730
01:09:45,189 --> 01:09:48,250
鼻子或白色或从来没有一个

1731
01:09:48,250 --> 01:09:49,390
音符在匹兹堡，一个节点在

1732
01:09:49,390 --> 01:09:49,990
旧金山，

1733
01:09:49,990 --> 01:09:51,970
所以同时我有两个

1734
01:09:51,970 --> 01:09:53,560
应用程序试图正确更新

1735
01:09:53,560 --> 01:09:56,290
数据库，一开始我

1736
01:09:56,290 --> 01:09:58,780
得到一个 在这里锁定我的节点，因为这个

1737
01:09:58,780 --> 01:10:01,270
人获得了 B 上的锁定，但现在我想

1738
01:10:01,270 --> 01:10:04,450
更新这个人想要更新 B

1739
01:10:04,450 --> 01:10:06,310
另一个人想要更新一个所以现在

1740
01:10:06,310 --> 01:10:08,050
我必须通过网络发送锁定

1741
01:10:08,050 --> 01:10:10,480
请求以获取

1742
01:10:10,480 --> 01:10:12,070
其他人在做同样的事情 其他人做

1743
01:10:12,070 --> 01:10:12,670
同样的事情

1744
01:10:12,670 --> 01:10:13,930
我显然以

1745
01:10:13,930 --> 01:10:16,360
僵局告终 所以我如何真正

1746
01:10:16,360 --> 01:10:18,460
弄清楚谁实际上应该

1747
01:10:18,460 --> 01:10:21,130
被允许再次提交如果我正在

1748
01:10:21,130 --> 01:10:22,660
做一个分散的架构，如果我

1749
01:10:22,660 --> 01:10:24,970
没有那个 TP 监视器，但即使

1750
01:10:24,970 --> 01:10:27,190
我有，我也没有

1751
01:10:27,190 --> 01:10:29,410
关于它

1752
01:10:29,410 --> 01:10:30,550
在每个节点上究竟做什么的细粒度信息，因为在你实际运行之前你不可能

1753
01:10:30,550 --> 01:10:31,840
总是知道查询会做什么

1754
01:10:31,840 --> 01:10:34,420
，

1755
01:10:34,420 --> 01:10:36,550
有人需要弄清楚 我有

1756
01:10:36,550 --> 01:10:37,900
一个循环图的权重 我需要

1757
01:10:37,900 --> 01:10:40,230
杀死某人

1758
01:10:40,500 --> 01:10:42,000
然后假设这个人说哦，

1759
01:10:42,000 --> 01:10:44,340
我要退缩 如果

1760
01:10:44,340 --> 01:10:45,540
我在做狗预防，我会陷入僵局 我自杀了

1761
01:10:45,540 --> 01:10:48,710
这个人可能会这样做 同样的事情

1762
01:10:48,710 --> 01:10:50,550
所以这就是我们要

1763
01:10:50,550 --> 01:10:52,680
讨论的 星期三，您实际上如何

1764
01:10:52,680 --> 01:10:54,690
进行发货控制，您如何

1765
01:10:54,690 --> 01:10:56,910
确定您采用两个相位锁定

1766
01:10:56,910 --> 01:10:59,340
时间戳排序并在属性环境中运行它，在该

1767
01:10:59,340 --> 01:11:00,330
环境中您

1768
01:11:00,330 --> 01:11:01,620
没有关于提交和的所有事情的完整全局视图

1769
01:11:01,620 --> 01:11:03,360


1770
01:11:03,360 --> 01:11:05,610
给定的时间我们也会花

1771
01:11:05,610 --> 01:11:08,010
时间在我的事务说

1772
01:11:08,010 --> 01:11:10,080
继续并提交我如何

1773
01:11:10,080 --> 01:11:14,010
保证我在任何地方提交因为

1774
01:11:14,010 --> 01:11:15,120
如果一个节点在我尝试提交时发生故障会发生

1775
01:11:15,120 --> 01:11:16,550
什么我实际上应该做什么

1776
01:11:16,550 --> 01:11:19,460
很难做到正确，

1777
01:11:19,460 --> 01:11:21,990
所以如果你在这些事情中受伤，

1778
01:11:21,990 --> 01:11:25,260
那么这个很棒的

1779
01:11:25,260 --> 01:11:27,300
网站叫做 Jepsen 项目，这个网站叫凯尔金斯伯里，

1780
01:11:27,300 --> 01:11:29,930
所以

1781
01:11:29,930 --> 01:11:32,970
他基本上就是他，他建造了这个酷刑

1782
01:11:32,970 --> 01:11:34,830
室，用于分发数据库

1783
01:11:34,830 --> 01:11:36,840
英国外壳 有点粗糙，

1784
01:11:36,840 --> 01:11:39,540
但他基本上有这个测试套件

1785
01:11:39,540 --> 01:11:40,440
，他可以让您的分布式

1786
01:11:40,440 --> 01:11:42,690
数据库通过这些奇怪的边缘情况运行，

1787
01:11:42,690 --> 01:11:45,540
并确定它并不总是

1788
01:11:45,540 --> 01:11:47,430
正确的，并且已经并且已经拥有 pr

1789
01:11:47,430 --> 01:11:50,070
在保证可靠性可用性

1790
01:11:50,070 --> 01:11:52,710
或交易正确性方面存在问题，所以

1791
01:11:52,710 --> 01:11:54,300
现在他有一家咨询公司，人们

1792
01:11:54,300 --> 01:11:56,040
付钱给他去实际运行这个 t

1793
01:11:56,040 --> 01:11:57,300
v——建立他的网站 他有

1794
01:11:57,300 --> 01:12:00,630
这些超级详细的文章

1795
01:12:00,630 --> 01:12:02,310
，需要很长时间 是时候阅读以

1796
01:12:02,310 --> 01:12:03,330
了解他实际上在说

1797
01:12:03,330 --> 01:12:04,980
什么，但他谈到了

1798
01:12:04,980 --> 01:12:06,180
这些不同的数据系统是如何针对这些不同的数据系统

1799
01:12:06,180 --> 01:12:08,250
进行的，他们声称可能存在

1800
01:12:08,250 --> 01:12:10,260
正确的事务，他们声称

1801
01:12:10,260 --> 01:12:11,340
他们始终可以支持高

1802
01:12:11,340 --> 01:12:13,740
可用性或良好的性能，他的

1803
01:12:13,740 --> 01:12:16,260
事情表明他们 不要这样，他们

1804
01:12:16,260 --> 01:12:17,940
付钱给他，让他在他们的数据库系统上运行他的东西

1805
01:12:17,940 --> 01:12:19,350
，然后如果他们

1806
01:12:19,350 --> 01:12:20,340
通过，他们就可以宣布他们已经

1807
01:12:20,340 --> 01:12:22,800
获得认证，他的

1808
01:12:22,800 --> 01:12:24,390
公司有朝一日会成为

1809
01:12:24,390 --> 01:12:26,160
他们曾经声称的分布式键值存储 在

1810
01:12:26,160 --> 01:12:27,840
他们的网站上，他们让你知道他们有

1811
01:12:27,840 --> 01:12:30,180
很强的一致性保证，他把他的

1812
01:12:30,180 --> 01:12:31,650
东西和他们的东西对着干了，这

1813
01:12:31,650 --> 01:12:32,790
表明事实并非如此，他们不得不

1814
01:12:32,790 --> 01:12:34,320
回去陈 ge所有营销废话

1815
01:12:34,320 --> 01:12:37,470
删除它因为t羞辱它说

1816
01:12:37,470 --> 01:12:39,690
网站很棒他的Twitter提要不是那么

1817
01:12:39,690 --> 01:12:42,120
多你会明白为什么去看它呃

1818
01:12:42,120 --> 01:12:45,480
这不是我的事但他是一个

1819
01:12:45,480 --> 01:12:46,920
非常敏锐的家伙我认为有一个

1820
01:12:46,920 --> 01:12:49,260
非常好的 网站 好的 下一节课

1821
01:12:49,260 --> 01:12:51,000
就罗伯托给我看 系统复制

1822
01:12:51,000 --> 01:12:53,160
猫定理 然后是真实世界的

1823
01:12:53,160 --> 01:12:54,379
例子 我们将

1824
01:12:54,379 --> 01:12:56,239
开始担心我们将如何

1825
01:12:56,239 --> 01:12:57,469
在 T 恤

1826
01:12:57,469 --> 01:12:58,579
环境中实际运行事务 将告诉他们没有

1827
01:12:58,579 --> 01:12:59,929
续集系统，然后看看 为什么他们

1828
01:12:59,929 --> 01:13:02,119
不想进行交易 因为它

1829
01:13:02,119 --> 01:13:03,349
会影响性能和

1830
01:13:03,349 --> 01:13:06,530
可用性

1831
01:13:06,530 --> 01:13:30,739


1832
01:13:30,739 --> 01:13:42,760


1833
01:13:42,969 --> 01:13:47,649
支付

