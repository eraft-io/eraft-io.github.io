1
00:00:03,640 --> 00:00:13,140
[音乐]

2
00:00:15,070 --> 00:00:19,039
所以 DJ 掉线了他的

3
00:00:19,039 --> 00:00:19,520


4
00:00:19,520 --> 00:00:21,439
第二个女朋友发现了

5
00:00:21,439 --> 00:00:24,529
他的第三个女朋友所以他去

6
00:00:24,529 --> 00:00:27,289
维加斯隐藏他必须

7
00:00:27,289 --> 00:00:30,470
处理的问题所以好吧我已经

8
00:00:30,470 --> 00:00:35,360
走了我怎么了 好吧，我的

9
00:00:35,360 --> 00:00:43,899
妻子有一个孩子，理论上是的，所以

10
00:00:43,899 --> 00:00:47,390
老实说，它看起来

11
00:00:47,390 --> 00:00:51,940
不像我，而且我不确定它是我的，

12
00:00:51,940 --> 00:00:54,260
所以我们正在等待亲子鉴定的结果，所以不要再犹豫

13
00:00:54,260 --> 00:00:56,149


14
00:00:56,149 --> 00:00:59,480
了 好吧，我想为你们更新的另一件事

15
00:00:59,480 --> 00:01:01,100
是，在

16
00:01:01,100 --> 00:01:03,730
本学期开始时，我说我

17
00:01:03,730 --> 00:01:06,140
只关心两件事，我的

18
00:01:06,140 --> 00:01:08,510
人生第一是我的妻子，第二是

19
00:01:08,510 --> 00:01:10,460
数据库，所以我

20
00:01:10,460 --> 00:01:13,700
现在为每个人提供了更新版本 版本是

21
00:01:13,700 --> 00:01:16,430
我的妻子仍然是第一数据库

22
00:01:16,430 --> 00:01:19,280
仍然是第二，这

23
00:01:19,280 --> 00:01:23,990
取决于亲子鉴定，婴儿

24
00:01:23,990 --> 00:01:27,229
只是你知道在那里好吧

25
00:01:27,229 --> 00:01:30,049
，如果没有怀孕或怀孕，我会在这里对每个人说一件事

26
00:01:30,049 --> 00:01:32,000
哥们

27
00:01:32,000 --> 00:01:33,920
在你毕业前怀孕了 学校，这

28
00:01:33,920 --> 00:01:35,960
是一场噩梦，过去两周我什么都没做，

29
00:01:35,960 --> 00:01:37,280
除了

30
00:01:37,280 --> 00:01:38,990
像便便尿布和呕吐物之

31
00:01:38,990 --> 00:01:42,290
类的清洁外，这太糟糕了，好吧

32
00:01:42,290 --> 00:01:45,110
对不起，这是我的妻子现在在家

33
00:01:45,110 --> 00:01:45,619
，

34
00:01:45,619 --> 00:01:48,770
孩子也很好，所以 对于那些

35
00:01:48,770 --> 00:01:50,390
没有任何新生儿的人来说，

36
00:01:50,390 --> 00:01:52,130
照顾好这就是你必须做的，

37
00:01:52,130 --> 00:01:54,920
这就是你

38
00:01:54,920 --> 00:01:57,710
下个月要做的事情 家庭作业 4 截止日期

39
00:01:57,710 --> 00:01:58,990
为两天后周三午夜

40
00:01:58,990 --> 00:02:01,219
项目 3 我们做什么 在本

41
00:02:01,219 --> 00:02:03,560
周末的周日午夜，然后我将

42
00:02:03,560 --> 00:02:05,270
在 Piazza 宣布这一消息并将其发布

43
00:02:05,270 --> 00:02:07,850
在网站上我们将进行第一个

44
00:02:07,850 --> 00:02:10,970
检查点以获得额外的积分

45
00:02:10,970 --> 00:02:14,360
将在一周后的 11 月 24 日周日进行

46
00:02:14,360 --> 00:02:16,310
在项目

47
00:02:16,310 --> 00:02:18,140
3 到期之后，检查点的意思

48
00:02:18,140 --> 00:02:20,660
基本上是 yo-yo

49
00:02:20,660 --> 00:02:22,190
你自己一直在研究的文章的 URL

50
00:02:22,190 --> 00:02:24,680
或者 TAS 会

51
00:02:24,680 --> 00:02:26,540
查看它给你反馈给你

52
00:02:26,540 --> 00:02:28,790
建议告诉你什么看起来是正确

53
00:02:28,790 --> 00:02:30,560
的 看起来不对，然后就会

54
00:02:30,560 --> 00:02:32,990
给 你对最终提交的指导，

55
00:02:32,990 --> 00:02:33,470


56
00:02:33,470 --> 00:02:35,180
所以我会先说你不会

57
00:02:35,180 --> 00:02:37,700
得到额外的学分，

58
00:02:37,700 --> 00:02:39,980
除非你正确地提交检查点

59
00:02:39,980 --> 00:02:41,330
如果你只是史密斯检查如果你

60
00:02:41,330 --> 00:02:42,530
在最后提交最后的东西

61
00:02:42,530 --> 00:02:43,850
没有 让你知道这会给

62
00:02:43,850 --> 00:02:45,590
你反馈，你不会得到完整的学分

63
00:02:45,590 --> 00:02:47,690
，我会更新文件，提供

64
00:02:47,690 --> 00:02:48,920
所有这些事情的信息，

65
00:02:48,920 --> 00:02:50,510
然后还有一个

66
00:02:50,510 --> 00:02:51,860
作业，将于 12 月到期

67
00:02:51,860 --> 00:02:53,150
，还有一个项目和 这也

68
00:02:53,150 --> 00:02:54,980
将在 12 月到期，

69
00:02:54,980 --> 00:03:02,620
所以 Roma 已经完成了任何问题，

70
00:03:02,620 --> 00:03:08,810
所以让我们谈谈日志记录，因此

71
00:03:08,810 --> 00:03:10,730
日志记录和恢复的想法是我们

72
00:03:10,730 --> 00:03:12,710
显然希望能够保留

73
00:03:12,710 --> 00:03:15,170
我们对数据库所做的任何更改，并且

74
00:03:15,170 --> 00:03:16,550
无论何时发生崩溃 或者失败了

75
00:03:16,550 --> 00:03:18,830
所以不明白这个问题让

76
00:03:18,830 --> 00:03:20,900
我们谈谈到目前为止我们讨论过的那种系统，

77
00:03:20,900 --> 00:03:23,630
看看是否有

78
00:03:23,630 --> 00:03:25,370
问题，然后我们现在回去添加

79
00:03:25,370 --> 00:03:26,870
maldium recovery，我们将看看如何

80
00:03:26,870 --> 00:03:28,940
处理 问题 确保

81
00:03:28,940 --> 00:03:31,130
一切都是持久和安全的 假设

82
00:03:31,130 --> 00:03:33,380
我有一个简单的事务 t1 是您

83
00:03:33,380 --> 00:03:35,720
在 AIM 上写入时读取的内容，这是一个

84
00:03:35,720 --> 00:03:37,820
非常好的开始，我们

85
00:03:37,820 --> 00:03:38,720
最好没有任何东西，例如我们没有将

86
00:03:38,720 --> 00:03:40,340
任何内容放入内存中，我们只有

87
00:03:40,340 --> 00:03:42,410
一页 将对象 a

88
00:03:42,410 --> 00:03:45,020
放在磁盘上，所以当我们的事务开始时，

89
00:03:45,020 --> 00:03:46,940
它会读取 a，然后我们

90
00:03:46,940 --> 00:03:48,560
从磁盘中获取该页面并将其

91
00:03:48,560 --> 00:03:50,540
带入我们的缓冲池，这很好，我们知道

92
00:03:50,540 --> 00:03:52,130
如何做我们已经讨论过的

93
00:03:52,130 --> 00:03:53,480
已经讨论过了，

94
00:03:53,480 --> 00:03:55,430
所以现在当我想要做正确的 o

95
00:03:55,430 --> 00:03:58,310
名称时，我修改对象，因为它存在

96
00:03:58,310 --> 00:04:01,130
于缓冲池中，我做了一个翻转，

97
00:04:01,130 --> 00:04:03,530
让我了解它并进行更改然后

98
00:04:03,530 --> 00:04:04,880
现在我的事务说我想

99
00:04:04,880 --> 00:04:10,120
提交 这里必须发生的事情它向

100
00:04:12,300 --> 00:04:14,800
我提交了什么应用程序

101
00:04:14,800 --> 00:04:17,709
告诉我们我们想要提交什么时候我们

102
00:04:17,709 --> 00:04:18,880
告诉外部世界你的节目

103
00:04:18,880 --> 00:04:24,160
行为实际上提交得很好如果我们

104
00:04:24,160 --> 00:04:25,690
立即说他们告诉我们提交我们

105
00:04:25,690 --> 00:04:26,889
立即说好你

106
00:04:26,889 --> 00:04:28,360
没有 数据包络分析 dlocks 如果我们现在只是告诉外界，您的交易没有时间戳

107
00:04:28,360 --> 00:04:30,010
违规或验证问题，

108
00:04:30,010 --> 00:04:31,870


109
00:04:31,870 --> 00:04:33,220
是的，您的交易已

110
00:04:33,220 --> 00:04:36,550
提交可能会发生的事情，我们的

111
00:04:36,550 --> 00:04:37,930
更改只是再次挂在

112
00:04:37,930 --> 00:04:39,580
内存中，我们通过了所有

113
00:04:39,580 --> 00:04:42,100
商业检查，这一切都很好，

114
00:04:42,100 --> 00:04:44,320
但是 仍然坐在记忆中，所以现在如果

115
00:04:44,320 --> 00:04:46,750
像数据库最邪恶

116
00:04:46,750 --> 00:04:48,669
的人像希特勒数据库一样

117
00:04:48,669 --> 00:04:51,310
出现，如果他来了，那只是希特勒，那就是

118
00:04:51,310 --> 00:04:51,880
我们

119
00:04:51,880 --> 00:04:54,430
窃听我们的数据中心或我们的机器，

120
00:04:54,430 --> 00:04:57,669
我们失去了电源，然后所有的变化

121
00:04:57,669 --> 00:04:59,470
都参与其中 工具

122
00:04:59,470 --> 00:05:02,770
内存没了，我们从来没有

123
00:05:02,770 --> 00:05:04,900
在磁盘上写过任何东西，所以如果我们告诉

124
00:05:04,900 --> 00:05:06,669
外面的世界，当你

125
00:05:06,669 --> 00:05:08,280
立即知道你的事情提交并且

126
00:05:08,280 --> 00:05:10,930
没有任何东西被持久化到磁盘时，我们可以

127
00:05:10,930 --> 00:05:12,520
立即知道我们可能会立即

128
00:05:12,520 --> 00:05:14,080
断电并失去我们所有的 改变，

129
00:05:14,080 --> 00:05:15,460
现在我们完全不在我们

130
00:05:15,460 --> 00:05:16,750
承诺的地方，但你回来了，

131
00:05:16,750 --> 00:05:19,050
你的改变不在那里，这很糟糕，

132
00:05:19,050 --> 00:05:21,370
所以这是一个高水平

133
00:05:21,370 --> 00:05:22,780
今天要解决的问题

134
00:05:22,780 --> 00:05:25,419
就是所谓的崩溃恢复和

135
00:05:25,419 --> 00:05:27,220
日志记录方案，这是我们

136
00:05:27,220 --> 00:05:30,669
将用来防止这些事情发生的一种机制，所以

137
00:05:30,669 --> 00:05:31,960
今天讨论

138
00:05:31,960 --> 00:05:33,910
的恢复算法是数据库

139
00:05:33,910 --> 00:05:36,010
系统将要使用的技术 确保

140
00:05:36,010 --> 00:05:38,050
所有更改都进行事务所做的更改

141
00:05:38,050 --> 00:05:40,479
将保证

142
00:05:40,479 --> 00:05:42,760
数据库一致所有更改

143
00:05:42,760 --> 00:05:44,770
都是原子性的并且所有更改都是

144
00:05:44,770 --> 00:05:47,770
持久的所以我们关心

145
00:05:47,770 --> 00:05:49,660
资产首字母缩略词中的 C 和 D 我们不关心

146
00:05:49,660 --> 00:05:51,190
隔离 今天可能会在这里进行工作讨论

147
00:05:51,190 --> 00:05:52,240
因为这有点由

148
00:05:52,240 --> 00:05:53,320
商业协议处理

149
00:05:53,320 --> 00:05:54,789
好吧 担心你知道谁

150
00:05:54,789 --> 00:05:56,979
可以重用写入 这实际上是关于

151
00:05:56,979 --> 00:05:58,720
我们如何确保我们的更改

152
00:05:58,720 --> 00:06:02,289
是原子一致且持久的 所以

153
00:06:02,289 --> 00:06:04,660
我们的机制将拥有每个恢复协议

154
00:06:04,660 --> 00:06:07,330
两部分是

155
00:06:07,330 --> 00:06:08,530
我们将在运行

156
00:06:08,530 --> 00:06:10,330
时在系统运行时执行的所有事情中的第一部分，同时我们正在

157
00:06:10,330 --> 00:06:12,760
执行事务和查询，这

158
00:06:12,760 --> 00:06:15,669
将很好地设置我们 这样，如果我们必须

159
00:06:15,669 --> 00:06:18,490
在发生故障后恢复，我们就能够

160
00:06:18,490 --> 00:06:20,460
做到这一点，而不会丢失任何信息，

161
00:06:20,460 --> 00:06:22,479
因此第一部分是

162
00:06:22,479 --> 00:06:24,449
我们在运行时所做的所有事情，

163
00:06:24,449 --> 00:06:26,699
第二部分是在重新启动后或

164
00:06:26,699 --> 00:06:29,370
崩溃后如何 当您正常运行时，我们是否使用

165
00:06:29,370 --> 00:06:30,689
从第一部分收集的信息

166
00:06:30,689 --> 00:06:31,919


167
00:06:31,919 --> 00:06:34,259
返回并将数据库恢复

168
00:06:34,259 --> 00:06:38,339
到正确状态，因此今天的讲座

169
00:06:38,339 --> 00:06:40,050
重点放在第一部分我们

170
00:06:40,050 --> 00:06:41,669
在运行时做什么以确保 我们可以

171
00:06:41,669 --> 00:06:43,050
收集正确的信息，以便我们

172
00:06:43,050 --> 00:06:45,539
可以正确地恢复数据库

173
00:06:45,539 --> 00:06:48,150
第二部分是在星期三，如果

174
00:06:48,150 --> 00:06:49,830
我们崩溃后查看这里并弄清楚

175
00:06:49,830 --> 00:06:51,180
我们到底做了什么，然后让我们

176
00:06:51,180 --> 00:06:54,839
回到正确的状态，所以今天

177
00:06:54,839 --> 00:06:56,520
有一个

178
00:06:56,520 --> 00:06:57,749
在我们真正谈论

179
00:06:57,749 --> 00:07:00,089
我们将使用的方法之前，我们需要谈论一堆东西，所以首先我们必须

180
00:07:00,089 --> 00:07:01,169
谈论

181
00:07:01,169 --> 00:07:02,849
我们的系统中可能有什么样的故障，以及我们

182
00:07:02,849 --> 00:07:04,199
如何知道哪些我们可以恢复

183
00:07:04,199 --> 00:07:06,599
而不是恢复 从那时起我们就站 rted

184
00:07:06,599 --> 00:07:08,490
谈论我们将如何实际

185
00:07:08,490 --> 00:07:11,129
管理内存和我们的缓冲池，以

186
00:07:11,129 --> 00:07:12,449
与我们迄今为止所讨论的略有不同的方式，

187
00:07:12,449 --> 00:07:15,029
以便我们可以确保

188
00:07:15,029 --> 00:07:16,949
我们可以在崩溃后再次恢复，

189
00:07:16,949 --> 00:07:18,870
然后我们将讨论两种

190
00:07:18,870 --> 00:07:20,729
技术 进行数据库恢复，

191
00:07:20,729 --> 00:07:22,499
第一个是影子分页，第二个

192
00:07:22,499 --> 00:07:24,479
是在前面记录剧透，

193
00:07:24,479 --> 00:07:27,419
在前面记录是更好的

194
00:07:27,419 --> 00:07:29,129
方式，每个数据系统实际使用的都是这种方式，

195
00:07:29,129 --> 00:07:30,930
但是

196
00:07:30,930 --> 00:07:32,789
出于坚忍的原因，知道什么是影子分页是很好的

197
00:07:32,789 --> 00:07:34,999
看看为什么这是优越的

198
00:07:34,999 --> 00:07:37,409
然后我们将讨论两种不同

199
00:07:37,409 --> 00:07:38,460
类型的日志记录和预写日志记录

200
00:07:38,460 --> 00:07:40,259
就像日志记录本身中的实际内容

201
00:07:40,259 --> 00:07:42,180
然后我们将完成

202
00:07:42,180 --> 00:07:43,770
讨论检查点什么 - 然后我们将

203
00:07:43,770 --> 00:07:45,930
继续讨论我们的内容

204
00:07:45,930 --> 00:07:51,180
周三谈到要进行恢复，

205
00:07:51,180 --> 00:07:54,089
所以数据库系统本身

206
00:07:54,089 --> 00:07:57,569
将根据

207
00:07:57,569 --> 00:07:59,310


208
00:07:59,310 --> 00:08:00,959
它们所操作的底层存储设备在概念

209
00:08:00,959 --> 00:08:03,300
上划分为不同的组件 正确的 buffle 管理器将事物保存

210
00:08:03,300 --> 00:08:05,129
在内存中 磁盘管理器将事物保存

211
00:08:05,129 --> 00:08:07,319
在磁盘

212
00:08:07,319 --> 00:08:10,199


213
00:08:10,199 --> 00:08:11,669


214
00:08:11,669 --> 00:08:14,909


215
00:08:14,909 --> 00:08:17,819


216
00:08:17,819 --> 00:08:19,560
上

217
00:08:19,560 --> 00:08:22,110


218
00:08:22,110 --> 00:08:23,459
我们在运行查询时运行事务时可能发生的不同类型的故障

219
00:08:23,459 --> 00:08:26,520
，在此基础上，我们可以

220
00:08:26,520 --> 00:08:27,449
弄清楚您知道

221
00:08:27,449 --> 00:08:28,860
我们在恢复协议中实际需要支持什么，

222
00:08:28,860 --> 00:08:32,458
因此存在三类

223
00:08:32,458 --> 00:08:34,110
故障 我们将

224
00:08:34,110 --> 00:08:35,640
逐一介绍交易失败

225
00:08:35,640 --> 00:08:36,990
系统故障和存储介质

226
00:08:36,990 --> 00:08:38,130
故障，因此

227
00:08:38,130 --> 00:08:41,280


228
00:08:41,280 --> 00:08:43,110
我正在谈论的剧透或注意事项我们关心

229
00:08:43,110 --> 00:08:45,420
前两个，第三个是不可能

230
00:08:45,420 --> 00:08:48,140
处理的， 当我们谈论货币控制时，我们将看到为什么随着我们进行

231
00:08:48,140 --> 00:08:50,460
交易

232
00:08:50,460 --> 00:08:52,500
，到目前为止我们谈论的

233
00:08:52,500 --> 00:08:54,570
所有事情都是

234
00:08:54,570 --> 00:08:57,870
如此，比如当

235
00:08:57,870 --> 00:08:59,220
交易陷入僵局或交易时 nsaction 尝试

236
00:08:59,220 --> 00:09:00,300
更新一些

237
00:09:00,300 --> 00:09:02,970
不允许更新或更新值的内容，也不是某些

238
00:09:02,970 --> 00:09:04,530
不能正确更新的方式，这些

239
00:09:04,530 --> 00:09:05,700
是我们不能允许

240
00:09:05,700 --> 00:09:07,560
事务继续的内容，因此我们

241
00:09:07,560 --> 00:09:08,580
必须中止它并在更改时回滚，

242
00:09:08,580 --> 00:09:09,120


243
00:09:09,120 --> 00:09:12,110
因此再次合乎逻辑 错误可能是

244
00:09:12,110 --> 00:09:14,340
事务试图违反某些

245
00:09:14,340 --> 00:09:15,780


246
00:09:15,780 --> 00:09:17,550
施加在数据库上的内部完整性约束或

247
00:09:17,550 --> 00:09:20,310
引用引用约束，例如，

248
00:09:20,310 --> 00:09:21,540
如果您尝试插入某些内容但这

249
00:09:21,540 --> 00:09:22,620
是外键首选项并且该

250
00:09:22,620 --> 00:09:24,810
外键不存在，那么

251
00:09:24,810 --> 00:09:26,250
数据库系统会告诉您 无法完成

252
00:09:26,250 --> 00:09:28,140
您的事务必须失败我们将

253
00:09:28,140 --> 00:09:29,580
确保您的所有更改都

254
00:09:29,580 --> 00:09:31,080
回滚并且永远不会持续，

255
00:09:31,080 --> 00:09:32,790
即使我们知道我们多次启动

256
00:09:32,790 --> 00:09:35,490
内部状态错误是

257
00:09:35,490 --> 00:09:37,230
我们在两阶段锁定下讨论的事情，

258
00:09:37,230 --> 00:09:39,780
并且 时间戳排序正确，如果

259
00:09:39,780 --> 00:09:42,030
我们有一个开发人员在两个事务之间，

260
00:09:42,030 --> 00:09:43,530
我们必须杀死其中一个

261
00:09:43,530 --> 00:09:45,750
并中止它们回滚其所有更改

262
00:09:45,750 --> 00:09:47,340
和 n 你知道确保

263
00:09:47,340 --> 00:09:48,810
它们在崩溃后不会持续存在

264
00:09:48,810 --> 00:09:51,270
所以我们的数据库记录协议

265
00:09:51,270 --> 00:09:52,590
需要处理这两个我认为

266
00:09:52,590 --> 00:09:55,740
这些很明显然后我们得到

267
00:09:55,740 --> 00:09:57,300
实际的系统故障

268
00:09:57,300 --> 00:09:59,760
我们可以计算的硬件故障

269
00:09:59,760 --> 00:10:03,150
在我们的协议中，首先

270
00:10:03,150 --> 00:10:04,500
是软件故障，这些是数据库系统本身有问题的地方，

271
00:10:04,500 --> 00:10:07,610
数据库系统

272
00:10:07,610 --> 00:10:10,050
中有一些糟糕的代码

273
00:10:10,050 --> 00:10:11,730
，就像被零除一样

274
00:10:11,730 --> 00:10:14,040
，现在软件是系统

275
00:10:14,040 --> 00:10:15,990
本身，大卫系统本身就崩溃

276
00:10:15,990 --> 00:10:19,680
了 获得六组板，因此我们

277
00:10:19,680 --> 00:10:20,670
需要能够解决

278
00:10:20,670 --> 00:10:22,260
我们数据库系统中的此类故障，

279
00:10:22,260 --> 00:10:24,000
并确保您知道任何

280
00:10:24,000 --> 00:10:25,920
事务仍在运行，它们

281
00:10:25,920 --> 00:10:27,240
正确地加载并回滚，或者她

282
00:10:27,240 --> 00:10:29,060
之前确实提交过的任何事务

283
00:10:29,060 --> 00:10:31,920
这个错误发生了所有这些变化都是

284
00:10:31,920 --> 00:10:35,640
持续的硬件故障是当

285
00:10:35,640 --> 00:10:38,010
我们的数据系统运行的实际机器

286
00:10:38,010 --> 00:10:41,010
崩溃或停止时

287
00:10:41,010 --> 00:10:43,320
停止运行或运行正常 这可能是

288
00:10:43,320 --> 00:10:44,820
有人被电源线绊倒了，

289
00:10:44,820 --> 00:10:46,920
或者就像

290
00:10:46,920 --> 00:10:50,100
插入磁盘驱动器的电线松动一样，系统

291
00:10:50,100 --> 00:10:51,720
出现故障，他们无法

292
00:10:51,720 --> 00:10:53,040
保持操作系统

293
00:10:53,040 --> 00:10:55,500
崩溃，戴维斯系统崩溃，我们需要

294
00:10:55,500 --> 00:10:57,470
回来， 恢复数据库状态，

295
00:10:57,470 --> 00:11:00,330
所以为了让我们做到这一点，你

296
00:11:00,330 --> 00:11:02,340
知道它会处理这个我们必须做出

297
00:11:02,340 --> 00:11:05,280
这个故障停止假设，因为我们

298
00:11:05,280 --> 00:11:07,620
假设

299
00:11:07,620 --> 00:11:12,990
如果我们有硬件故障，港口不会遭受不可恢复的损坏

300
00:11:12,990 --> 00:11:16,050
这意味着如果我们

301
00:11:16,050 --> 00:11:17,340
对硬盘驱动器旋转并且

302
00:11:17,340 --> 00:11:18,210
如果我们拉动电源并且针头会在盘片上写字，

303
00:11:18,210 --> 00:11:21,390
并且

304
00:11:21,390 --> 00:11:23,550
针头不会像 Kareem 那样

305
00:11:23,550 --> 00:11:25,020
进入盘片并排序你知道乱七八糟你

306
00:11:25,020 --> 00:11:27,660
知道搞乱扇区我们假设

307
00:11:27,660 --> 00:11:29,340
如果 如果我们崩溃了心脏衰竭，

308
00:11:29,340 --> 00:11:31,140
那么我们总是可以回来并

309
00:11:31,140 --> 00:11:35,310
恢复正确的状态 所以最后一

310
00:11:35,310 --> 00:11:36,660
类是我们

311
00:11:36,660 --> 00:11:38,580
在我们的数据库系统中根本无法处理的那些，

312
00:11:38,580 --> 00:11:39,870
因为数据库系统 alt

313
00:11:39,870 --> 00:11:41,880
虽然你知道它是一个伟大的软件

314
00:11:41,880 --> 00:11:44,850
，但你不可能知道

315
00:11:44,850 --> 00:11:47,460
铅笔是它自己的意志，所以

316
00:11:47,460 --> 00:11:49,440
一个不可修复的心脏事件

317
00:11:49,440 --> 00:11:51,570
就像针头

318
00:11:51,570 --> 00:11:53,790
撞到盘子或类似的例子 找到

319
00:11:53,790 --> 00:11:55,560
像着火的机器并融化我所有的

320
00:11:55,560 --> 00:11:58,200
磁盘 没有数据库系统可以从中恢复

321
00:11:58,200 --> 00:12:00,750
，所以我们不会

322
00:12:00,750 --> 00:12:02,730
设计我们的协议来解决这个问题

323
00:12:02,730 --> 00:12:05,130
我们可以做其他事情，例如

324
00:12:05,130 --> 00:12:08,130
复制数据库来克服这个问题

325
00:12:08,130 --> 00:12:10,620
或维护存档备份

326
00:12:10,620 --> 00:12:12,810
如果发生崩溃，我们可以恢复，但这

327
00:12:12,810 --> 00:12:14,850
不是真正的恢复，

328
00:12:14,850 --> 00:12:16,770
就像我们今天谈论的一样，如果我必须

329
00:12:16,770 --> 00:12:17,640
从存档版本恢复

330
00:12:17,640 --> 00:12:19,800
它只是备份和恢复那

331
00:12:19,800 --> 00:12:22,170
你注意到我从

332
00:12:22,170 --> 00:12:24,240
你知道的加载它 单独的副本没有

333
00:12:24,240 --> 00:12:26,610
做任何特别的

334
00:12:26,610 --> 00:12:27,360
事情我们今天谈论的

335
00:12:27,360 --> 00:12:29,790
恢复数据库状态的事情所以我们

336
00:12:29,790 --> 00:12:31,170
只关心前几次失败

337
00:12:31,170 --> 00:12:33,360
没有数据库系统可以解释这个

338
00:12:33,360 --> 00:12:35,250
但是通过 gh 冗余，我们将

339
00:12:35,250 --> 00:12:37,470
在分布式数据库中讨论

340
00:12:37,470 --> 00:12:39,839
我们可以尝试避免这种情况并

341
00:12:39,839 --> 00:12:46,920
减轻问题

342
00:12:46,920 --> 00:12:48,060


343
00:12:48,060 --> 00:12:50,339


344
00:12:50,339 --> 00:12:51,630


345
00:12:51,630 --> 00:12:54,000
需要再次回顾一下，看看

346
00:12:54,000 --> 00:12:55,020
当我们再次谈论日志记录和恢复时，这将如何成为一个问题

347
00:12:55,020 --> 00:12:57,750


348
00:12:57,750 --> 00:12:59,910
，这就是数据库所说的内容

349
00:12:59,910 --> 00:13:01,530
，即假设 B 主存储位置的设计系统

350
00:13:01,530 --> 00:13:03,240


351
00:13:03,240 --> 00:13:04,410
处于开启状态 磁盘，

352
00:13:04,410 --> 00:13:06,810
并且在任何时候您想要读取记录

353
00:13:06,810 --> 00:13:08,699
或操作记录，您必须首先

354
00:13:08,699 --> 00:13:10,230
将其复制到内存中到您的缓冲

355
00:13:10,230 --> 00:13:12,480
池中进行更改，然后

356
00:13:12,480 --> 00:13:14,129
最终将其写回磁盘

357
00:13:14,129 --> 00:13:16,560
以保持它这是债券

358
00:13:16,560 --> 00:13:18,600
omean Architecture from 在 1950 年代，它

359
00:13:18,600 --> 00:13:19,949
不是特定于数据库系统，而是

360
00:13:19,949 --> 00:13:22,529
我们疲倦的讨论所基于的操作假设

361
00:13:22,529 --> 00:13:24,660
，并且

362
00:13:24,660 --> 00:13:26,129
有一些特殊的较新的硬盘驱动器，

363
00:13:26,129 --> 00:13:29,160
您可以知道磁盘上有 CPU 内核

364
00:13:29,160 --> 00:13:30,689
本身，您可以尝试操作

365
00:13:30,689 --> 00:13:32,430
那里的数据，但这只是

366
00:13:32,430 --> 00:13:34,139
将问题移到其他地方，出于某种

367
00:13:34,139 --> 00:13:36,149
目的，我们可以忽略它，并说您

368
00:13:36,149 --> 00:13:37,589
知道我们想要修改的内容，我们

369
00:13:37,589 --> 00:13:38,819
将其放入内存中进行更改然后

370
00:13:38,819 --> 00:13:41,519
将其写回 到磁盘，所以

371
00:13:41,519 --> 00:13:43,680
问题是我们什么时候真正

372
00:13:43,680 --> 00:13:46,350
写出这些更改，所以当你们

373
00:13:46,350 --> 00:13:48,750
从之前构建缓冲池的东西时，

374
00:13:48,750 --> 00:13:51,060
你真正做的只是说

375
00:13:51,060 --> 00:13:52,379
好吧，这个页面应该被

376
00:13:52,379 --> 00:13:55,230
驱逐它很脏，所以我有

377
00:13:55,230 --> 00:13:57,600
将其写回磁盘，您

378
00:13:57,600 --> 00:13:59,550
不必担心是谁实际进行

379
00:13:59,550 --> 00:14:02,069
了更改，以及是否是

380
00:14:02,069 --> 00:14:03,480
将更改实际写出磁盘的正确时间，

381
00:14:03,480 --> 00:14:06,269
因此这是我们今天需要

382
00:14:06,269 --> 00:14:08,129
在日志记录协议中考虑的事情

383
00:14:08,129 --> 00:14:12,329
，因此 为了提供原子性，我们

384
00:14:12,329 --> 00:14:14,189
需要更好地确保基本保证，

385
00:14:14,189 --> 00:14:16,019


386
00:14:16,019 --> 00:14:19,139
因为持久性保证是，如果我们

387
00:14:19,139 --> 00:14:20,579
告诉外部世界他们的

388
00:14:20,579 --> 00:14:22,410
交易已提交，这意味着我们向

389
00:14:22,410 --> 00:14:23,399
他们发送一个 承认说您已经

390
00:14:23,399 --> 00:14:25,560
提交，那么所有这些更改都将

391
00:14:25,560 --> 00:14:27,720
永久持久化，有人

392
00:14:27,720 --> 00:14:29,519
可能会来覆盖这些更改并

393
00:14:29,519 --> 00:14:32,120
更新它们，这很好，但您知道

394
00:14:32,120 --> 00:14:34,649
在此之前您知道这些更改

395
00:14:34,649 --> 00:14:36,230
应该永远持续下去，

396
00:14:36,230 --> 00:14:38,699
同样，如果任何事务进行

397
00:14:38,699 --> 00:14:40,230
更改和那些 更改使其

398
00:14:40,230 --> 00:14:42,389
退出磁盘，但随后该事务

399
00:14:42,389 --> 00:14:43,829


400
00:14:43,829 --> 00:14:45,870
在崩溃之前中止或未正确完成，我们需要

401
00:14:45,870 --> 00:14:47,339
确保我们也可以撤销这些更改

402
00:14:47,339 --> 00:14:49,860
，因此这

403
00:14:49,860 --> 00:14:50,939
是我们在

404
00:14:50,939 --> 00:14:54,059
日志记录协议中需要的两个主要保证和

405
00:14:54,059 --> 00:14:55,860
我们将用于 Nord 的核心原则提供这些

406
00:14:55,860 --> 00:14:59,759
保证或撤消和重做，这

407
00:14:59,759 --> 00:15:01,220
与它们听起来完全一样，

408
00:15:01,220 --> 00:15:04,439
因此，撤消是

409
00:15:04,439 --> 00:15:06,829
我们将要维护的基本信息，以允许我们

410
00:15:06,829 --> 00:15:10,170
逆转对数据库中对象的任何更改

411
00:15:10,170 --> 00:15:12,870
交易已经完成，所以

412
00:15:12,870 --> 00:15:14,730
这就像老家伙

413
00:15:14,730 --> 00:15:16,470
曾经为这个元组的这个属性

414
00:15:16,470 --> 00:15:17,810


415
00:15:17,810 --> 00:15:19,490
所做的那样，并将其存储在某处，以便如果我

416
00:15:19,490 --> 00:15:21,259
需要反转 有人

417
00:15:21,259 --> 00:15:23,839
对它所做的更改我总是可以去

418
00:15:23,839 --> 00:15:26,629
把旧值放回去然后重做

419
00:15:26,629 --> 00:15:28,519
与重做相反的是

420
00:15:28,519 --> 00:15:30,829
重新应用

421
00:15:30,829 --> 00:15:33,079
事务对数据库中对象所做的更改所需的信息

422
00:15:33,079 --> 00:15:35,329
这是

423
00:15:35,329 --> 00:15:36,439
关于如何说你

424
00:15:36,439 --> 00:15:37,759
知道的信息 这是

425
00:15:37,759 --> 00:15:39,470
他们在给定时间所做的更改 如果我

426
00:15:39,470 --> 00:15:40,459
需要返回并再次进行更改

427
00:15:40,459 --> 00:15:42,470
我可能会重做 信息告诉我

428
00:15:42,470 --> 00:15:45,470
如何根据这两个原则执行此操作

429
00:15:45,470 --> 00:15:47,509
或者我们现在可以在此基础上构建的原语

430
00:15:47,509 --> 00:15:49,459
，我将不得不构建一些

431
00:15:49,459 --> 00:15:52,339
更复杂的日志记录协议，该协议

432
00:15:52,339 --> 00:15:54,050
允许我们

433
00:15:54,050 --> 00:15:56,290
在正确的时间以正确的方式生成此信息，

434
00:15:56,290 --> 00:15:58,220
从而允许

435
00:15:58,220 --> 00:16:01,879
我们在崩溃后恢复数据库 实际上会

436
00:16:01,879 --> 00:16:04,309
使用撤消和重做，当这个

437
00:16:04,309 --> 00:16:05,509
信息指南表被写入

438
00:16:05,509 --> 00:16:05,930
磁盘时，

439
00:16:05,930 --> 00:16:08,149
这将取决于我们将如何

440
00:16:08,149 --> 00:16:10,550
管理磁盘，如果我

441
00:16:10,550 --> 00:16:14,509
在缓冲池中管理脏页，那么让我们在这里看看更

442
00:16:14,509 --> 00:16:17,240
复杂的例子吧 ave t1 t2 t1

443
00:16:17,240 --> 00:16:19,459
在 t2 上对 a 进行

444
00:16:19,459 --> 00:16:21,800
读取，对 B 进行读取，因此在这种情况下

445
00:16:21,800 --> 00:16:23,420
，我们不担心死锁

446
00:16:23,420 --> 00:16:25,550
或同意收费，我们只是假设

447
00:16:25,550 --> 00:16:27,110
他们被允许获取这些锁

448
00:16:27,110 --> 00:16:28,610
无论他们需要做什么，我们只

449
00:16:28,610 --> 00:16:30,019
关心这一点，就像

450
00:16:30,019 --> 00:16:31,430
他们对这些对象所做的低级别更改一样，

451
00:16:31,430 --> 00:16:36,139
因此我们事务 t1 开始我们

452
00:16:36,139 --> 00:16:38,809
进行读取，或者

453
00:16:38,809 --> 00:16:40,879
我们的数据库中只有一页，因此为了执行

454
00:16:40,879 --> 00:16:42,680
读取 a 我们必须首先将其带入我们的

455
00:16:42,680 --> 00:16:44,480
缓冲池，然后

456
00:16:44,480 --> 00:16:46,490
允许事务读取它，然后它在 a 上进行

457
00:16:46,490 --> 00:16:48,019
写入，并且它已经在我们的

458
00:16:48,019 --> 00:16:49,759
缓冲池中，假设我们可以获得

459
00:16:49,759 --> 00:16:50,389
它的闩锁，

460
00:16:50,389 --> 00:16:51,620
我们可以继续进行 我们的更改

461
00:16:51,620 --> 00:16:54,079
直接就地更新 我们

462
00:16:54,079 --> 00:16:55,970


463
00:16:55,970 --> 00:16:57,529
暂时忽略了多版本控制 我们在那里进行更改 然后我们的

464
00:16:57,529 --> 00:17:00,589
操作完成 现在我们有一个上下文

465
00:17:00,589 --> 00:17:02,720
切换 t2 开始运行 它

466
00:17:02,720 --> 00:17:04,789
在 B 上读取页面已经在内存中 所以

467
00:17:04,789 --> 00:17:06,648
这很好 马上然后

468
00:17:06,648 --> 00:17:08,419
它不会写上 B 已经在

469
00:17:08,419 --> 00:17:10,280
内存中了 我们假设你得到了正确的

470
00:17:10,280 --> 00:17:12,380
闩锁 我们可以做出我们的改变，

471
00:17:12,380 --> 00:17:15,589
我们很好，所以现在我们继续前进，t2

472
00:17:15,589 --> 00:17:18,740
想要提交

473
00:17:18,740 --> 00:17:21,500
这里需要发生的事情，我们必须

474
00:17:21,500 --> 00:17:22,680


475
00:17:22,680 --> 00:17:25,630
首先做出两个决定 是为了能够

476
00:17:25,630 --> 00:17:26,920
告诉外界我们的事务

477
00:17:26,920 --> 00:17:30,910
已提交是否应该强制

478
00:17:30,910 --> 00:17:32,740
缓冲池刷新并将

479
00:17:32,740 --> 00:17:34,390
其为此页面所做的所有更改

480
00:17:34,390 --> 00:17:39,220
写出磁盘是或否是对的，

481
00:17:39,220 --> 00:17:40,270
因为您必须 否则，

482
00:17:40,270 --> 00:17:41,980
如果我崩溃，希特勒出现并且

483
00:17:41,980 --> 00:17:44,200
需要将其带走我所有的更改

484
00:17:44,200 --> 00:17:47,970
都进行得很顺利是什么问题

485
00:17:50,610 --> 00:17:51,840
正确的

486
00:17:51,840 --> 00:17:57,670
t1 在同一页面中修改了 a 所以

487
00:17:57,670 --> 00:18:00,340
我是否应该被允许写出

488
00:18:00,340 --> 00:18:02,020
已被交易修改的页面

489
00:18:02,020 --> 00:18:05,710
尚未提交的磁盘他正在

490
00:18:05,710 --> 00:18:06,910
摇头不知道有什么

491
00:18:06,910 --> 00:18:09,370
问题在这里T 2 的蜜蜂进行

492
00:18:09,370 --> 00:18:11,170
了更改但他想提交它是

493
00:18:11,170 --> 00:18:13,420
允许的但是这里还有

494
00:18:13,420 --> 00:18:16,410
一个来自未提交的事务的其他更改

495
00:18:16,410 --> 00:18:19,570
所以让我们说 好吧，

496
00:18:19,570 --> 00:18:21,400
我认为最好写出 t 选择

497
00:18:21,400 --> 00:18:23,710
更改，即使 t1 有一个

498
00:18:23,710 --> 00:18:26,640
委员会，所以我把这些写在桌子上，

499
00:18:26,640 --> 00:18:29,560
但现在我知道我告诉外面的一

500
00:18:29,560 --> 00:18:31,330
排 tteyuu 承诺我会回去

501
00:18:31,330 --> 00:18:35,440
t1 但现在 t1 中止所以

502
00:18:35,440 --> 00:18:42,700
这里需要发生什么是的，所以我需要

503
00:18:42,700 --> 00:18:43,960
回滚事务，所以我需要

504
00:18:43,960 --> 00:18:47,110
回滚它所做的更改我可以

505
00:18:47,110 --> 00:18:48,700
很快地完成那个记忆，

506
00:18:48,700 --> 00:18:51,390
这没什么大不了的，但我已经

507
00:18:51,390 --> 00:18:54,550
写出你知道存在于

508
00:18:54,550 --> 00:18:57,520
t1 对磁盘所做的更改中的第二页，所以现在

509
00:18:57,520 --> 00:18:59,410
我必须在此处进行更改，

510
00:18:59,410 --> 00:19:02,260
然后再次写出以反转

511
00:19:02,260 --> 00:19:04,480
我所做的更改，这到底是什么

512
00:19:04,480 --> 00:19:16,690
问题 他说当

513
00:19:16,690 --> 00:19:18,670
我中止时，我可能

514
00:19:18,670 --> 00:19:21,400
在覆盖我的更改之前已经撤消了这里的更改

515
00:19:21,400 --> 00:19:25,360
我现在崩溃了我回来了我

516
00:19:25,360 --> 00:19:26,920
没有任何这些我

517
00:19:26,920 --> 00:19:29,140
只有磁盘上的东西现在我有

518
00:19:29,140 --> 00:19:31,630
与 t1 相比，我不应该在那里，

519
00:19:31,630 --> 00:19:33,070
但我不知道它不应该在那里，

520
00:19:33,070 --> 00:19:34,810
因为 e 我没有额外的信息

521
00:19:34,810 --> 00:19:36,070
告诉我 T

522
00:19:36,070 --> 00:19:41,200
t-1 实际上没有提交所以

523
00:19:41,200 --> 00:19:44,259
我们在这里讨论的两件事

524
00:19:44,259 --> 00:19:45,840
我们必须做出的两个决定我们在这里

525
00:19:45,840 --> 00:19:49,299
我们是否应该要求

526
00:19:49,299 --> 00:19:50,559
强制交易并写出 它的所有

527
00:19:50,559 --> 00:19:52,450
脏页都从磁盘中取出，但第四定律

528
00:19:52,450 --> 00:19:54,820
要提交，以及是否

529
00:19:54,820 --> 00:19:58,899
允许我们从尚未提交的事务中复制出一个页面或受害者一个

530
00:19:58,899 --> 00:20:00,879
strimer 缓冲池，

531
00:20:00,879 --> 00:20:04,239
所以这两个

532
00:20:04,239 --> 00:20:07,989
策略被称为窃取和强制

533
00:20:07,989 --> 00:20:09,669
窃取策略说明

534
00:20:09,669 --> 00:20:11,139
他们的数据库

535
00:20:11,139 --> 00:20:13,049
系统的事务是否允许未提交的事务在允许提交

536
00:20:13,049 --> 00:20:15,940
之前覆盖磁盘

537
00:20:15,940 --> 00:20:18,759
上数据库广告中对象的最新提交值，

538
00:20:18,759 --> 00:20:23,619
因此如果

539
00:20:23,619 --> 00:20:25,629
您说是否窃取如果您使用窃取

540
00:20:25,629 --> 00:20:27,309
策略 那么你可以这样做，如果

541
00:20:27,309 --> 00:20:29,080
你不使用窃取那么它是

542
00:20:29,080 --> 00:20:31,269
不允许的思考方式是

543
00:20:31,269 --> 00:20:32,590
如果我的空间用完了我的缓冲

544
00:20:32,590 --> 00:20:35,679
池从一个事务中是该

545
00:20:35,679 --> 00:20:38,590
事务允许窃取页面中

546
00:20:38,590 --> 00:20:39,909
的 来自另一个尚未提交的事务的缓冲池或缓冲池中的插槽

547
00:20:39,909 --> 00:20:42,220


548
00:20:42,220 --> 00:20:45,129
正确这就是为什么它

549
00:20:45,129 --> 00:20:49,359
被称为窃取森林策略说

550
00:20:49,359 --> 00:20:52,119
我们是否

551
00:20:52,119 --> 00:20:53,769
要求事务对

552
00:20:53,769 --> 00:20:55,419
数据库中的任何对象所做的所有更新都必须先写入磁盘

553
00:20:55,419 --> 00:21:00,789
允许提交，所以

554
00:21:00,789 --> 00:21:02,169
如果你说我正在使用森林政策，

555
00:21:02,169 --> 00:21:04,659
那么如果你

556
00:21:04,659 --> 00:21:10,169
不使用武力，那么它是必需的，那么它不是必需的，所以

557
00:21:10,169 --> 00:21:12,749
强迫会让我们的生活更轻松，

558
00:21:12,749 --> 00:21:14,979
因为它会让我们恢复得

559
00:21:14,979 --> 00:21:16,330
相当快 因为我们刚刚回来

560
00:21:16,330 --> 00:21:18,299
，我们看到我们所有的更改都在那里，

561
00:21:18,299 --> 00:21:20,769
我们不需要你知道查看

562
00:21:20,769 --> 00:21:22,330
任何其他地方来尝试重做

563
00:21:22,330 --> 00:21:25,450
信息以重做更改但是

564
00:21:25,450 --> 00:21:26,590
窃取策略会出现问题，

565
00:21:26,590 --> 00:21:28,119
因为现在我们正在编写 删除

566
00:21:28,119 --> 00:21:29,559
尚未提交的更改或事务，

567
00:21:29,559 --> 00:21:33,279
所以让我们看看一种方法来做到

568
00:21:33,279 --> 00:21:34,779
这一点 让我们看看禁止窃取森林

569
00:21:34,779 --> 00:21:35,859
政策吧，因为它们有点

570
00:21:35,859 --> 00:21:39,399
他们有一个轻率的目标，你知道

571
00:21:39,399 --> 00:21:40,869
你只能 选择你知道

572
00:21:40,869 --> 00:21:43,539
这两个东西的两种组合所以没有

573
00:21:43,539 --> 00:21:46,149
偷窃力意味着没有偷窃

574
00:21:46,149 --> 00:21:49,059
说任何未提交的更改

575
00:21:49,059 --> 00:21:49,840
邓肯行动所做的任何更改

576
00:21:49,840 --> 00:21:51,820
都不能写入磁盘并且

577
00:21:51,820 --> 00:21:54,909
强制说任何更改所有更改

578
00:21:54,909 --> 00:21:56,380
实际上都可能必须

579
00:21:56,380 --> 00:21:57,610
写入 在允许提交事务之前写入磁盘，

580
00:21:57,610 --> 00:22:01,120
因此 t1 开始

581
00:22:01,120 --> 00:22:02,440
读取我们带来的缓冲池

582
00:22:02,440 --> 00:22:03,309
，

583
00:22:03,309 --> 00:22:05,860
现在我们在

584
00:22:05,860 --> 00:22:08,289
更新页面和缓冲池时进行写入，然后我们执行

585
00:22:08,289 --> 00:22:10,299
t2 的上下文切换 t2 做 读取

586
00:22:10,299 --> 00:22:12,490
然后正确我们更新缓冲

587
00:22:12,490 --> 00:22:14,650
池然后现在想要继续并

588
00:22:14,650 --> 00:22:17,620
再次提交森林策略说

589
00:22:17,620 --> 00:22:19,150
此事务的所有

590
00:22:19,150 --> 00:22:21,549
更改必须平衡磁盘但

591
00:22:21,549 --> 00:22:24,399
我们将此更改从 t1 挂

592
00:22:24,399 --> 00:22:26,440
在这里作为 好吧，所以我们需要

593
00:22:26,440 --> 00:22:30,000
摆脱它，所以我们需要做什么来正确地

594
00:22:30,000 --> 00:22:34,029
将页面复制到内存中，仅应用

595
00:22:34,029 --> 00:22:35,679
我们想要的更改或反转

596
00:22:35,679 --> 00:22:37,840
我们不想要的其他更改，然后我们

597
00:22:37,840 --> 00:22:42,309
可以继续将其写出来 秒 o 现在

598
00:22:42,309 --> 00:22:44,820
，当我们回到这里

599
00:22:44,820 --> 00:22:48,370
并中止 t1 时

600
00:22:48,370 --> 00:22:52,240
，逆转

601
00:22:52,240 --> 00:22:54,010
t1 所做的所有更改对我们来说非常微不足道，因为它只是

602
00:22:54,010 --> 00:22:56,140
在内存中更新此页面，

603
00:22:56,140 --> 00:22:57,730
我们不必出去 您知道磁盘上

604
00:22:57,730 --> 00:22:59,679
没有写出脏的脏更改

605
00:22:59,679 --> 00:23:02,950
，因此数据库系统

606
00:23:02,950 --> 00:23:04,450
将维护一些额外的元数据以

607
00:23:04,450 --> 00:23:05,710
跟踪这些不同事务的正确设置，

608
00:23:05,710 --> 00:23:07,390
你们已经

609
00:23:07,390 --> 00:23:08,950
在两阶段锁定和 OCC 下解决了这个问题。

610
00:23:08,950 --> 00:23:11,799
你的粒子，

611
00:23:11,799 --> 00:23:13,270
所以我们已经有了

612
00:23:13,270 --> 00:23:14,980
关于它们对什么物体做了什么改变的信息

613
00:23:14,980 --> 00:23:17,080
所以这不是什么大不了的事情

614
00:23:17,080 --> 00:23:18,250
或额外的工作我们必须做的事情

615
00:23:18,250 --> 00:23:19,809
，当你把那个副本做好并且它在内存中时，能够逆转这种变化

616
00:23:19,809 --> 00:23:22,570


617
00:23:22,570 --> 00:23:25,779
这应该很快，所以这

618
00:23:25,779 --> 00:23:31,750
似乎是一个好主意或一个坏主意，所以

619
00:23:31,750 --> 00:23:33,580
这是

620
00:23:33,580 --> 00:23:36,450
这种方法的优点之一我已经说过

621
00:23:36,450 --> 00:23:40,090
它就在那里检测器

622
00:23:40,090 --> 00:23:42,610
在崩溃后回滚是非常微不足道的，因为这是

623
00:23:42,610 --> 00:23:43,360
因为 se没有什么可回滚的，

624
00:23:43,360 --> 00:23:45,159
因为我

625
00:23:45,159 --> 00:23:47,289
知道添加在磁盘上的任何东西都应该在

626
00:23:47,289 --> 00:23:48,549
磁盘上，因为它们都来自已提交的

627
00:23:48,549 --> 00:23:51,000


628
00:23:53,740 --> 00:23:55,460
事务，很抱歉

629
00:23:55,460 --> 00:24:16,970
，两个事务之间存在死锁，所以他的问题

630
00:24:16,970 --> 00:24:20,030
在我的示例中又回到了这里 在这里，我

631
00:24:20,030 --> 00:24:23,120
有一个线程或一个事务

632
00:24:23,120 --> 00:24:24,350
想要写出一些它制作一个

633
00:24:24,350 --> 00:24:26,270
副本的磁盘，但随后另一个事务可能正在

634
00:24:26,270 --> 00:24:28,070
同时提交并且它

635
00:24:28,070 --> 00:24:29,270
修改了相同的页面您不应该

636
00:24:29,270 --> 00:24:31,460
制作另一个副本我们可以忽略我们

637
00:24:31,460 --> 00:24:34,850
假设我 意味着你必须有

638
00:24:34,850 --> 00:24:36,440
一个闩锁来保护这些东西

639
00:24:36,440 --> 00:24:38,600
没有办法解决这个问题但是我们

640
00:24:38,600 --> 00:24:44,210
可以忽略所有这些所以这里

641
00:24:44,210 --> 00:24:47,870
有两个问题实际上三个

642
00:24:47,870 --> 00:25:03,260
问题是的所以你关闭了前

643
00:25:03,260 --> 00:25:05,720
两个他说现在和你的处理

644
00:25:05,720 --> 00:25:07,520
页面 在这里提交这个副本需要更多的

645
00:25:07,520 --> 00:25:09,830
工作 它在关键路径上 它在

646
00:25:09,830 --> 00:25:11,390
提交的关键部分

647
00:25:11,390 --> 00:25:13,610
商业

648
00:25:13,610 --> 00:25:15,830
机制的提交协议变得更加昂贵

649
00:25:15,830 --> 00:25:20,059
是 绝对正确，是的，但

650
00:25:20,059 --> 00:25:22,820
不仅仅是 CPU 成本，它实际上是你现在

651
00:25:22,820 --> 00:25:23,870
必须多次写出这个东西，

652
00:25:23,870 --> 00:25:26,120
就像这样说如果你回去如果我们去

653
00:25:26,120 --> 00:25:29,390
这里如果 t1 没有真正中止并

654
00:25:29,390 --> 00:25:31,700
实际提交然后为了

655
00:25:31,700 --> 00:25:33,950
让它改变 我永远不会再写出磁盘

656
00:25:33,950 --> 00:25:36,440
，因此对于

657
00:25:36,440 --> 00:25:37,820
提交的每个事务，我可能

658
00:25:37,820 --> 00:25:39,440
必须一遍又一遍地写出相同的页面

659
00:25:39,440 --> 00:25:51,919
是的，

660
00:25:51,919 --> 00:25:54,320
他实际上是对的，

661
00:25:54,320 --> 00:25:56,450
所以在我的 seabone 示例中存在一个大问题，我

662
00:25:56,450 --> 00:25:59,030
有一个 页面说它

663
00:25:59,030 --> 00:26:00,890
是港口的四千字节我可以保证我可以正确地做

664
00:26:00,890 --> 00:26:03,049
一个四无声的四千字节的页面

665
00:26:03,049 --> 00:26:05,659
但是如果我更新多个页面

666
00:26:05,659 --> 00:26:06,630
港口不能

667
00:26:06,630 --> 00:26:08,880
为我保证所以我可以如果我更新四

668
00:26:08,880 --> 00:26:10,740
页我已经读出了 前两个然后我

669
00:26:10,740 --> 00:26:12,570
在我得到下两个之前崩溃了现在我

670
00:26:12,570 --> 00:26:14,310
回来了，我不知道你知道我

671
00:26:14,310 --> 00:26:18,180
有一个被撕毁的日期所以看到

672
00:26:18,180 --> 00:26:19,500
这是一个大问题还有

673
00:26:19,500 --> 00:26:24,980
另一个更微妙的大问题所以

674
00:26:24,980 --> 00:26:27,570
我再次 这是其中的一页

675
00:26:27,570 --> 00:26:31,140
有点微不足道的例子，但在这种情况下

676
00:26:31,140 --> 00:26:33,690
，对于给定的事务，因为我

677
00:26:33,690 --> 00:26:36,330
无法将

678
00:26:36,330 --> 00:26:38,970
未提交的事务中的任何脏数据写出到磁盘，这

679
00:26:38,970 --> 00:26:41,610
意味着我可以正确设置所有

680
00:26:41,610 --> 00:26:43,800
事务必须完全适合主

681
00:26:43,800 --> 00:26:46,530
内存，所以如果我有 一个表有 10

682
00:26:46,530 --> 00:26:47,880
亿个元组 我有一个

683
00:26:47,880 --> 00:26:49,320
查询想要更新所有 10 亿个

684
00:26:49,320 --> 00:26:51,630
元组，但我只能

685
00:26:51,630 --> 00:26:54,000
在我的缓冲池中存储 100 万个元组然后我不能

686
00:26:54,000 --> 00:26:55,800
在这个这个系统下运行该事务，

687
00:26:55,800 --> 00:26:58,710
因为我会 达到第一个

688
00:26:58,710 --> 00:27:00,900
100 万更新它们很好然后我

689
00:27:00,900 --> 00:27:02,910
尝试获得 100 万加一然后

690
00:27:02,910 --> 00:27:08,480
我正在运行它我用完了空间所以

691
00:27:08,600 --> 00:27:11,190
他说你不能有一个解决

692
00:27:11,190 --> 00:27:13,110
方法你可以写到一个临时位置是的

693
00:27:13,110 --> 00:27:15,180
给我两张幻灯片，这

694
00:27:15,180 --> 00:27:17,340
就是解决方案，是的，它不是一个好的，

695
00:27:17,340 --> 00:27:24,450
但它是可以的，所以没有窃取力是

696
00:27:24,450 --> 00:27:26,670
实际

697
00:27:26,670 --> 00:27:30,030
实现可恢复的正确持久的

698
00:27:30,030 --> 00:27:32,250
缓冲池管理器和拒绝

699
00:27:32,250 --> 00:27:34,470
数据库系统的最简单方法，因为我不知道 不必在

700
00:27:34,470 --> 00:27:36,360
船尾做任何重做 呃一个崩溃我刚

701
00:27:36,360 --> 00:27:38,430
回来我的数据库保证了

702
00:27:38,430 --> 00:27:43,080
正确的状态我永远不必去你

703
00:27:43,080 --> 00:27:44,850
知道在运行时从一个中止的事务中撤消任何东西

704
00:27:44,850 --> 00:27:46,050
因为我知道

705
00:27:46,050 --> 00:27:47,580
我们没有人改变过

706
00:27:47,580 --> 00:27:50,550
磁盘但正如我们已经说过的那样 您

707
00:27:50,550 --> 00:27:52,680
不能支持

708
00:27:52,680 --> 00:27:53,850
具有超过可用内存量的正确设置的事务

709
00:27:53,850 --> 00:27:56,610


710
00:27:56,610 --> 00:27:58,590
提交协议现在更加昂贵，

711
00:27:58,590 --> 00:28:00,150
因为您必须做所有这些

712
00:28:00,150 --> 00:28:01,680
额外的工作来确定

713
00:28:01,680 --> 00:28:02,790
实际应该将哪些内容写入磁盘

714
00:28:02,790 --> 00:28:06,750
它不是写入磁盘的地方，并且您

715
00:28:06,750 --> 00:28:09,390
正在将其乘以磁盘，您知道

716
00:28:09,390 --> 00:28:11,190


717
00:28:11,190 --> 00:28:13,230
现在对于每一个事务可能只是一个事务的所有内容，

718
00:28:13,230 --> 00:28:14,610
您一遍又一遍地写入同一页面

719
00:28:14,610 --> 00:28:16,740
，如果您是 SSD 这些

720
00:28:16,740 --> 00:28:18,120
东西实际上不能永远

721
00:28:18,120 --> 00:28:19,800
正确写入 你可以烧掉 SSD 上的单元

722
00:28:19,800 --> 00:28:20,420


723
00:28:20,420 --> 00:28:23,160
你知道它有成百上千的

724
00:28:23,160 --> 00:28:25,380
正确 Purcell 但最终

725
00:28:25,380 --> 00:28:26,670
要继续这样做 如果你只是

726
00:28:26,670 --> 00:28:28,260
运行很多 你会 bur 在很

727
00:28:28,260 --> 00:28:32,700
短的时间内完成，所以实际上

728
00:28:32,700 --> 00:28:35,100
没有人做我在这里描述的事情，这

729
00:28:35,100 --> 00:28:37,080
是实现它的最简单方法，但

730
00:28:37,080 --> 00:28:40,050
实际上没有人这样做

731
00:28:40,050 --> 00:28:43,950
他暗示人们以前尝试

732
00:28:43,950 --> 00:28:46,770
过的事情是基本上存储更改

733
00:28:46,770 --> 00:28:47,940
您正在

734
00:28:47,940 --> 00:28:50,750
临时空间中从未提交的事务中进行，

735
00:28:50,750 --> 00:28:53,070
然后在事务提交时的某个时刻

736
00:28:53,070 --> 00:28:55,950
以某种方式解析

737
00:28:55,950 --> 00:28:58,110
目录或页表，现在说

738
00:28:58,110 --> 00:29:00,210
这里实际上

739
00:29:00,210 --> 00:29:02,490
是我们页面的正确最新版本

740
00:29:02,490 --> 00:29:04,500
，如果 你崩溃了你只是忽略

741
00:29:04,500 --> 00:29:06,300
了在这可以

742
00:29:06,300 --> 00:29:08,610
是那些临时缓冲区中修改的任何东西所以这就是

743
00:29:08,610 --> 00:29:10,890
影子分页是

744
00:29:10,890 --> 00:29:12,480
我们在一开始

745
00:29:12,480 --> 00:29:15,270
谈论当前控制时简要介绍一下这是一种

746
00:29:15,270 --> 00:29:18,420
实现无窃取力缓冲管理

747
00:29:18,420 --> 00:29:20,490
系统的方法 这避免了

748
00:29:20,490 --> 00:29:23,580
我们之前讨论过的一些复杂性，所以

749
00:29:23,580 --> 00:29:25,230
影子分页崇拜

750
00:29:25,230 --> 00:29:28,170
就像多版本控制一样，但

751
00:29:28,170 --> 00:29:29,610
在页面级别而不是元组

752
00:29:29,610 --> 00:29:32,040
级别 el 并且

753
00:29:32,040 --> 00:29:33,840
在任何给定时间只会有两个副本，总

754
00:29:33,840 --> 00:29:36,540
有主副本是

755
00:29:36,540 --> 00:29:38,370
最新提交的

756
00:29:38,370 --> 00:29:41,250
数据库版本，然后

757
00:29:41,250 --> 00:29:43,080
是所有新

758
00:29:43,080 --> 00:29:46,080
事务最终都会修改的卷影副本，因此当

759
00:29:46,080 --> 00:29:47,940
事务发生时 提交我们想要一种方法来

760
00:29:47,940 --> 00:29:51,630
自动地切换影子

761
00:29:51,630 --> 00:29:54,660
成为新的主我的意思是我们可以这样做

762
00:29:54,660 --> 00:29:55,770
，如果我们更新多个页面，我们可以不用

763
00:29:55,770 --> 00:29:57,780
担心权利

764
00:29:57,780 --> 00:30:04,710


765
00:30:04,710 --> 00:30:06,660
受损，这与多版本控制不同 复制

766
00:30:06,660 --> 00:30:09,570
我们将要修改的每一件事情实际上

767
00:30:09,570 --> 00:30:11,400
它就像多新兴但不是

768
00:30:11,400 --> 00:30:12,750
在页面级别做你正在做的事情的元组

769
00:30:12,750 --> 00:30:15,150
你可以

770
00:30:15,150 --> 00:30:17,760
将页面目录组织为树

771
00:30:17,760 --> 00:30:19,890
结构所以现在你只需要

772
00:30:19,890 --> 00:30:22,200
对树的一部分进行 cat 复制，

773
00:30:22,200 --> 00:30:24,750
然后执行 Pat 复制以

774
00:30:24,750 --> 00:30:28,200
将它们更新到位或将它们应用到页

775
00:30:28,200 --> 00:30:30,360
表，而无需重新创建

776
00:30:30,360 --> 00:30:32,210
整个哈希表，

777
00:30:32,210 --> 00:30:35,960
因此在这棵树的根部是 g 将

778
00:30:35,960 --> 00:30:37,700
成为始终

779
00:30:37,700 --> 00:30:40,070
指向最新主主

780
00:30:40,070 --> 00:30:42,619
版本的数据库根，这意味着我们可以

781
00:30:42,619 --> 00:30:44,210
对树的低部分进行大量更改，

782
00:30:44,210 --> 00:30:46,580
但更新租约以

783
00:30:46,580 --> 00:30:48,019
指向我们刚刚创建的新页面

784
00:30:48,019 --> 00:30:50,119
，然后当我们 '准备好在

785
00:30:50,119 --> 00:30:51,769
所有这些页面上以原子方式应用更改

786
00:30:51,769 --> 00:30:53,929
我们只是摆动这个数据库根

787
00:30:53,929 --> 00:30:55,629
指针现在指向我们

788
00:30:55,629 --> 00:30:58,220
树的阴影部分然后我们所有的

789
00:30:58,220 --> 00:31:00,499
更改立即变得

790
00:31:00,499 --> 00:31:03,139
立即可见所以高级

791
00:31:03,139 --> 00:31:04,309
看起来又像这样 这个

792
00:31:04,309 --> 00:31:05,899
数据库根目录指向

793
00:31:05,899 --> 00:31:07,669
母版页表，这个母版

794
00:31:07,669 --> 00:31:10,720
页表指向我们在磁盘上的页面，所以

795
00:31:10,720 --> 00:31:13,789
我会简单地使用它，但是愚蠢

796
00:31:13,789 --> 00:31:15,889
的有点快，但让我

797
00:31:15,889 --> 00:31:19,549
得到这个例子所以说 我们有一个

798
00:31:19,549 --> 00:31:22,129
事务出现在 t1

799
00:31:22,129 --> 00:31:23,659
任何只读事务

800
00:31:23,659 --> 00:31:25,159
都可以转到此数据库根目录并

801
00:31:25,159 --> 00:31:26,929
转到主副本并查看

802
00:31:26,929 --> 00:31:28,730
一致版本但如果我们有

803
00:31:28,730 --> 00:31:30,080
更新事务我们必须cr 吃一个

804
00:31:30,080 --> 00:31:32,269
影子页表，

805
00:31:32,269 --> 00:31:34,460
事务将要修改，所以在

806
00:31:34,460 --> 00:31:36,230
影子页表的一开始，它的

807
00:31:36,230 --> 00:31:38,059
所有条目都指向

808
00:31:38,059 --> 00:31:40,009
母版页指向的相同页，

809
00:31:40,009 --> 00:31:42,259
母版页表指向它们，所以现在

810
00:31:42,259 --> 00:31:44,779
当这个事务开始修改时

811
00:31:44,779 --> 00:31:47,450
页面 我们要将该页面的副本复制

812
00:31:47,450 --> 00:31:49,850
到

813
00:31:49,850 --> 00:31:52,340
磁盘临时空间中的新位置 将所有

814
00:31:52,340 --> 00:31:54,740
更改都正确放置在那里，我们继续

815
00:31:54,740 --> 00:31:56,090
对所有其他所有其他页面执行此操作

816
00:31:56,090 --> 00:31:58,999
我们要修改的所有其他页面，然后何时

817
00:31:58,999 --> 00:32:00,529
这个事务说我想继续

818
00:32:00,529 --> 00:32:04,759
并提交我们需要做的就是更新

819
00:32:04,759 --> 00:32:06,499
这个存储在单个页面中的数据库根，

820
00:32:06,499 --> 00:32:10,360
现在指向影子页表的

821
00:32:10,360 --> 00:32:12,710
这个部分或这个病人，

822
00:32:12,710 --> 00:32:15,169
所以我们刷新了这个

823
00:32:15,169 --> 00:32:17,570
更改 磁盘，然后现在它

824
00:32:17,570 --> 00:32:19,549
真的变成了，一旦它是

825
00:32:19,549 --> 00:32:21,169
持久的，我们然后在内存中摆动那个指针

826
00:32:21,169 --> 00:32:22,610
，然后我们现在知道

827
00:32:22,610 --> 00:32:24,409
每个人都可以跟随这个指针，所以如果一个

828
00:32:24,409 --> 00:32:26,269
新事务出现并且一旦它

829
00:32:26,269 --> 00:32:27,980
想让你知道 想要阅读

830
00:32:27,980 --> 00:32:30,259
数据库的最新版本，它

831
00:32:30,259 --> 00:32:31,399
只是遵循这条路线并找到

832
00:32:31,399 --> 00:32:37,360
影子页表是

833
00:32:41,240 --> 00:32:43,500
明智的问题戴维斯根写了

834
00:32:43,500 --> 00:32:50,010
正确的桌子所以他们正确地崩溃所以我在

835
00:32:50,010 --> 00:32:52,140
这里字节驻留事务说我

836
00:32:52,140 --> 00:32:53,940
想提交我 想告诉

837
00:32:53,940 --> 00:32:59,520
外界我是正确的，所以如果我

838
00:32:59,520 --> 00:33:01,860
不更新这个数据库路由，我就会崩溃

839
00:33:01,860 --> 00:33:04,140
然后回来，现在我查看

840
00:33:04,140 --> 00:33:05,370
他路由的日期，他正在把它放到

841
00:33:05,370 --> 00:33:07,050
母版页表中，所有这些更改

842
00:33:07,050 --> 00:33:30,210
都是正确的 是的，它是阿拉玛，我

843
00:33:30,210 --> 00:33:34,010
认为它是第二页 ID

844
00:33:34,010 --> 00:33:36,540
正确的爸爸必须是耐用的，因为如果我

845
00:33:36,540 --> 00:33:38,580
崩溃回来如果我告诉菲亚特我会承诺我的

846
00:33:38,580 --> 00:33:42,270
世界但后来我崩溃了我就像

847
00:33:42,270 --> 00:33:42,930
好的墙

848
00:33:42,930 --> 00:33:44,160
我会假设 无论这件事

849
00:33:44,160 --> 00:33:45,810
指出的是

850
00:33:45,810 --> 00:33:47,580
页表的根，这意味着我告诉

851
00:33:47,580 --> 00:33:49,050
房子我不是我提交的，但现在

852
00:33:49,050 --> 00:33:50,250
我在影子图片表中所做的所有更改

853
00:33:50,250 --> 00:33:52,920
都消失了，它们仍然存在于

854
00:33:52,920 --> 00:33:55,650
磁盘上 只是没有人可以在那里看到它们，

855
00:33:55,650 --> 00:33:57,660
您在逻辑上无法看到它们 下摆 所以就

856
00:33:57,660 --> 00:34:15,570
好像它们不存在一样 你退出你的

857
00:34:15,570 --> 00:34:19,440
问题是你能不能聪明

858
00:34:19,440 --> 00:34:22,649
一点，当你写出这些页面时想出一种方法

859
00:34:22,649 --> 00:34:24,899
在这里做一个小标记说

860
00:34:24,899 --> 00:34:29,520
是的你是最新版本是的所以

861
00:34:29,520 --> 00:34:31,050
好吧 所以这个人更新了三个

862
00:34:31,050 --> 00:34:34,739
三页 所以我现在需要记录

863
00:34:34,739 --> 00:34:38,040
下你更新了 X

864
00:34:38,040 --> 00:34:40,560
页或 n 页中的三页以确保如果我

865
00:34:40,560 --> 00:34:42,469
崩溃回来我会看到所有这些变化

866
00:34:42,469 --> 00:34:44,030
是的，

867
00:34:44,030 --> 00:34:45,469
主要是因为你基本上知道

868
00:34:45,469 --> 00:34:47,810
我是光盘 现在没有

869
00:34:47,810 --> 00:34:48,800
根据数据确保你有

870
00:34:48,800 --> 00:34:50,510
一些像一些过时的

871
00:34:50,510 --> 00:34:52,580
页面那样的东西可以正确使用，除了

872
00:34:52,580 --> 00:34:54,139
跟踪数据专业告诉

873
00:34:54,139 --> 00:34:55,010
你哪些是最新的，

874
00:34:55,010 --> 00:34:56,389
本质上是的 无论

875
00:34:56,389 --> 00:34:58,160
提交什么事务，您现在都可以

876
00:34:58,160 --> 00:35:00,020
将这两个页面的一些页面带出到磁盘，

877
00:35:00,020 --> 00:35:01,670
为此您可能知道

878
00:35:01,670 --> 00:35:03,140
时间戳或事务或

879
00:35:03,140 --> 00:35:09,470
某些确定我的数据库是 100

880
00:35:09,470 --> 00:35:14,630
PB 的页面，这是一页它拥有

881
00:35:14,630 --> 00:35:17,810
我需要的一切总是可以随时

882
00:35:17,810 --> 00:35:27,080
考虑  极端是非常好，所以他

883
00:35:27,080 --> 00:35:29,570
说，在我的例子中，我有一个

884
00:35:29,570 --> 00:35:31,370
交易，如果我同时有一堆交易怎么办

885
00:35:31,370 --> 00:35:32,720
，这是如何

886
00:35:32,720 --> 00:35:33,320
工作的，

887
00:35:33,320 --> 00:35:37,280
所以你要么只有一个

888
00:35:37,280 --> 00:35:39,770
交易用完，续集之

889
00:35:39,770 --> 00:35:43,310
光会这样做，或者你 你必须

890
00:35:43,310 --> 00:35:46,820
成批提交它们，所以我说我忽略了

891
00:35:46,820 --> 00:35:48,080
两天锁定，因为所有

892
00:35:48,080 --> 00:35:50,210
与此正交的假设你

893
00:35:50,210 --> 00:35:51,290
没有办法弄清楚

894
00:35:51,290 --> 00:35:53,540
如果我在同一批次中有多个 Tunes 操作，谁可以更新什么

895
00:35:53,540 --> 00:35:55,040
更新

896
00:35:55,040 --> 00:35:57,890
东西我必须等到它们都

897
00:35:57,890 --> 00:36:00,170
完成然后它们都被提交我

898
00:36:00,170 --> 00:36:02,690
摆动我的数据库根指针正确

899
00:36:02,690 --> 00:36:04,910
然后它得到所有汤姆我可以申请所以

900
00:36:04,910 --> 00:36:06,530
这是一种方法来做到这一点，如果你假设

901
00:36:06,530 --> 00:36:07,850
所有事务都将在

902
00:36:07,850 --> 00:36:09,770
一个 如果你有一个

903
00:36:09,770 --> 00:36:11,870
需要一个小时的事务，那么

904
00:36:11,870 --> 00:36:13,190
你需要在

905
00:36:13,190 --> 00:36:14,480
一定时间内

906
00:36:14,480 --> 00:36:15,740
终止它，或者在每个人继续执行并

907
00:36:15,740 --> 00:36:20,360
提交某些系统之前

908
00:36:20,360 --> 00:36:22,490
等待一个小时 大多数系统不会以

909
00:36:22,490 --> 00:36:23,930
这种方式运行，但您最吸引人的是

910
00:36:23,930 --> 00:36:28,130
影子分页，好吧 IBM 在

911
00:36:28,130 --> 00:36:31,130
系统中或在 1970 年代

912
00:36:31,130 --> 00:36:33,350
他们在 1980 年代做 db2 时放弃了它，因为

913
00:36:33,350 --> 00:36:35,690
您现在有碎片问题所以

914
00:36:35,690 --> 00:36:37,940
现在我吹了 主页表 我

915
00:36:37,940 --> 00:36:40,190
在这里吹掉这些页面，因为它们

916
00:36:40,190 --> 00:36:42,440
不再可见，所以这就是

917
00:36:42,440 --> 00:36:44,570
我现在所拥有的，但它与

918
00:36:44,570 --> 00:36:47,840
这里的页面顺序不匹配所以现在我们进行

919
00:36:47,840 --> 00:36:49,220
顺序扫描我你知道我可能不是

920
00:36:49,220 --> 00:36:50,090
以正确的顺序阅读东西，所以我

921
00:36:50,090 --> 00:36:51,590
不能做聚集索引是

922
00:36:51,590 --> 00:36:52,670
他们在当天试图做的事情，

923
00:36:52,670 --> 00:36:55,280
所以实际上没有人这样做，但你

924
00:36:55,280 --> 00:36:56,090
必须是对的，你在那里你让

925
00:36:56,090 --> 00:36:57,050
他去击球或进行一笔

926
00:36:57,050 --> 00:36:57,710
交易

927
00:36:57,710 --> 00:37:22,550
从时间是的，你知道，所以你要

928
00:37:22,550 --> 00:37:25,609
回到上一个表单词 t1 t2

929
00:37:25,609 --> 00:37:27,980
在这种情况下会处理是的，如果你

930
00:37:27,980 --> 00:37:29,690
假设 t1 t2

931
00:37:29,690 --> 00:37:33,410
在同一批中一起提交，那么是的 q 这

932
00:37:33,410 --> 00:37:34,730
正是汉娜在这种情况下，因为 再次

933
00:37:34,730 --> 00:37:37,280
我有我需要撤销的撤消信息

934
00:37:37,280 --> 00:37:38,599
e

935
00:37:38,599 --> 00:37:43,280
事务在内存中所做的任何更改，因此只要该

936
00:37:43,280 --> 00:37:46,280
内容已写出磁盘，那么

937
00:37:46,280 --> 00:37:48,830
我就可以在此处反转它，我很好

938
00:37:48,830 --> 00:37:50,720
，如果我在翻转 Davis 记者之前崩溃，

939
00:37:50,720 --> 00:37:59,540
那么我很好 所以

940
00:37:59,540 --> 00:38:01,490
实际上没有人这样做所以让我们

941
00:38:01,490 --> 00:38:02,890
更快地跳过并获得好东西

942
00:38:02,890 --> 00:38:05,869
所以这很糟糕的原因是因为

943
00:38:05,869 --> 00:38:08,450
复制整个页表很

944
00:38:08,450 --> 00:38:10,369
昂贵即使你使用树

945
00:38:10,369 --> 00:38:12,920
结构它变得不便宜

946
00:38:12,920 --> 00:38:14,750
并且提交开销是 高，因为

947
00:38:14,750 --> 00:38:16,490
您必须更新刷新

948
00:38:16,490 --> 00:38:18,770
您修改页表的每个页面，

949
00:38:18,770 --> 00:38:20,570
并且日期变得

950
00:38:20,570 --> 00:38:22,430
碎片化的路由您需要一个后台垃圾

951
00:38:22,430 --> 00:38:23,359
收集器，就像在多版本

952
00:38:23,359 --> 00:38:25,790
墨盒孔中一样，您要么必须

953
00:38:25,790 --> 00:38:27,109
批量提交所有内容，要么只

954
00:38:27,109 --> 00:38:30,050
拥有 一位作家过时了，所以正如我所说

955
00:38:30,050 --> 00:38:31,369
的，我所知道的唯一系统

956
00:38:31,369 --> 00:38:35,420
确实做到了这一点或 couchdb，但我认为

957
00:38:35,420 --> 00:38:37,730
CouchDB 正在放弃这一点

958
00:38:37,730 --> 00:38:40,730
，并且将他们切换到

959
00:38:40,730 --> 00:38:44,510
Roxy ve l MV B 是一棵树 基于

960
00:38:44,510 --> 00:38:46,790
使用 M 地图的系统，因此对

961
00:38:46,790 --> 00:38:49,790
他们来说有点隐藏，然后

962
00:38:49,790 --> 00:38:51,980
在 1970 年代反对该系统，但他们

963
00:38:51,980 --> 00:38:55,220
表示 IBM 在 1980 年代放弃了它，

964
00:38:55,220 --> 00:38:56,330
您可能听说过一个系统

965
00:38:56,330 --> 00:38:57,680
，它的功能与

966
00:38:57,680 --> 00:38:59,480
续集 Lite 类似，但是这个 是

967
00:38:59,480 --> 00:39:02,780
我在 2010 年之前所做的续集，然后他们将其抛之脑后，

968
00:39:02,780 --> 00:39:04,070
并切换到我们接下来将要讨论

969
00:39:04,070 --> 00:39:04,730


970
00:39:04,730 --> 00:39:06,830
的预写日志记录方法，

971
00:39:06,830 --> 00:39:07,970
因此 eagle light 会做的是，

972
00:39:07,970 --> 00:39:11,540
而不是复制

973
00:39:11,540 --> 00:39:15,260
而不是复制您想要的页面

974
00:39:15,260 --> 00:39:16,580
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''要修改并

975
00:39:16,580 --> 00:39:18,350
在副本中进行修改的目的，他们有一个

976
00:39:18,350 --> 00:39:20,960
副本原始页面的副本，将其写出

977
00:39:20,960 --> 00:39:23,120
磁盘然后对

978
00:39:23,120 --> 00:39:25,760
主版本进行修改，然后如果您提交，

979
00:39:25,760 --> 00:39:28,190
您只需删除您拥有的副本，

980
00:39:28,190 --> 00:39:30,290
或者如果您之前崩溃 你提交

981
00:39:30,290 --> 00:39:32,390
然后你然后你回顾那个

982
00:39:32,390 --> 00:39:34,280
单独的副本文件并恢复

983
00:39:34,280 --> 00:39:36,770
恢复更改所以他们会

984
00:39:36,770 --> 00:39:38,540
称之为日记文件所以假设

985
00:39:38,540 --> 00:39:40,580
我的交易是一个月更新第二

986
00:39:40,580 --> 00:39:43,130
页所以bef 我修改内存中的第 2 页

987
00:39:43,130 --> 00:39:45,320
我首先复制它，将它保存在

988
00:39:45,320 --> 00:39:47,390
磁盘和日志文件中，

989
00:39:47,390 --> 00:39:48,800
然后完成

990
00:39:48,800 --> 00:39:51,050
后我可以用第 3 页修改它相同的内容，然后才能

991
00:39:51,050 --> 00:39:52,550
修改它我将副本复制到单独的

992
00:39:52,550 --> 00:39:54,860
日志文件中然后 我继续进行

993
00:39:54,860 --> 00:39:57,170
更改，假设在此

994
00:39:57,170 --> 00:39:59,240
事务实际提交之前，我们最终将

995
00:39:59,240 --> 00:40:02,120
第 2 页刷新出磁盘，但

996
00:40:02,120 --> 00:40:04,280
在我们刷新第 3 页并完成

997
00:40:04,280 --> 00:40:06,820
并实际提交此内容之前，我们崩溃了，

998
00:40:06,820 --> 00:40:08,900
所以一切都被

999
00:40:08,900 --> 00:40:11,930
吹走了 记忆，所以当我们回来时，我们

1000
00:40:11,930 --> 00:40:13,670
会说好吧，我有一个日志

1001
00:40:13,670 --> 00:40:15,800
文件，所以我需要我需要我让我

1002
00:40:15,800 --> 00:40:17,480
确保我在这个日志中所做的所有更改

1003
00:40:17,480 --> 00:40:19,010
Fog 因为这些原始

1004
00:40:19,010 --> 00:40:21,290
版本它们被写

1005
00:40:21,290 --> 00:40:26,060
回原始版本 磁盘文件，就像

1006
00:40:26,060 --> 00:40:28,460
我说的，这就是续集

1007
00:40:28,460 --> 00:40:30,770
光直到 2010 年所做的事情，然后他们

1008
00:40:30,770 --> 00:40:32,660
出于性能原因放弃了这个，

1009
00:40:32,660 --> 00:40:38,870
用来写一头雾水，所以这种

1010
00:40:38,870 --> 00:40:42,230
影子分页方法可以保证

1011
00:40:42,230 --> 00:40:43,730
正确性，但它有一些

1012
00:40:43,730 --> 00:40:44,870
性能问题和主要

1013
00:40:44,870 --> 00:40:47,480
性能问题将

1014
00:40:47,480 --> 00:40:49,700
是我们将要进行一堆随机

1015
00:40:49,700 --> 00:40:53,300
I/O，所以

1016
00:40:53,300 --> 00:40:56,480
当我不得不重播我正在更新的日志文件时，我会回到续集 Lite 示例中的这里

1017
00:40:56,480 --> 00:40:58,220


1018
00:40:58,220 --> 00:41:01,250
磁盘上的随机位置，以便

1019
00:41:01,250 --> 00:41:02,450
将数据库恢复到正确的状态

1020
00:41:02,450 --> 00:41:04,460
，当

1021
00:41:04,460 --> 00:41:06,080
我刷新所有更改并说我的

1022
00:41:06,080 --> 00:41:08,360
事务实际上再次提交时，这是一个影子分页我

1023
00:41:08,360 --> 00:41:10,160
正在对不同的位置进行随机 I/O

1024
00:41:10,160 --> 00:41:12,140
以保持所有

1025
00:41:12,140 --> 00:41:17,360
来自影子影子副本的变化，所以即使

1026
00:41:17,360 --> 00:41:20,050
有了它，我们今天的

1027
00:41:20,050 --> 00:41:22,520
顺序 i/o 的快速 SSD 总是比

1028
00:41:22,520 --> 00:41:25,160
随机 i/o 快，所以我们需要

1029
00:41:25,160 --> 00:41:27,650
方法将所有这些随机 iOS 转换为

1030
00:41:27,650 --> 00:41:29,599
快速顺序 i/o 和 仍然具有

1031
00:41:29,599 --> 00:41:31,849
我们在日志记录协议中想要的所有持久性保证，

1032
00:41:31,849 --> 00:41:35,240
因此这

1033
00:41:35,240 --> 00:41:37,309
就是提前日志记录

1034
00:41:37,309 --> 00:41:39,799
将为我们实现的目标，因此我们的想法是

1035
00:41:39,799 --> 00:41:40,970
提前记录我们

1036
00:41:40,970 --> 00:41:43,520
将在非- 易失性

1037
00:41:43,520 --> 00:41:46,670
存储以及 我们的表堆和

1038
00:41:46,670 --> 00:41:48,500
事务对数据库进行更改时，

1039
00:41:48,500 --> 00:41:51,170
我们将在

1040
00:41:51,170 --> 00:41:53,359
此日志文件中输入记录

1041
00:41:53,359 --> 00:41:56,510
所做更改的条目，然后当

1042
00:41:56,510 --> 00:41:58,400
事务立即执行时，我

1043
00:41:58,400 --> 00:41:59,349
希望继续提交，

1044
00:41:59,349 --> 00:42:01,549
我们只需要保证 我们

1045
00:42:01,549 --> 00:42:03,230
刷新了他们

1046
00:42:03,230 --> 00:42:06,099
从磁盘中生成的日志记录，而不是对缓冲池中页面

1047
00:42:06,099 --> 00:42:08,599
对象的资本更改，

1048
00:42:08,599 --> 00:42:11,420
因此

1049
00:42:11,420 --> 00:42:12,829
所有者对我们来说正确的头登录说

1050
00:42:12,829 --> 00:42:13,910
我们的事务已提交并且它是

1051
00:42:13,910 --> 00:42:16,039
持久的，我们只需要 要刷新日志，我们

1052
00:42:16,039 --> 00:42:18,829
不需要刷新任何其他内容，所以

1053
00:42:18,829 --> 00:42:20,780
现在日志文件只是切换原因哦，

1054
00:42:20,780 --> 00:42:22,640
因为不断附加

1055
00:42:22,640 --> 00:42:25,280
到此文件中，您知道吗？

1056
00:42:25,280 --> 00:42:27,349


1057
00:42:27,349 --> 00:42:28,849
比

1058
00:42:28,849 --> 00:42:31,279
写出随机页面的随机 i/o 快得多

1059
00:42:31,279 --> 00:42:33,410
，再次读取

1060
00:42:33,410 --> 00:42:34,670
它的原因是将其称为直接日志

1061
00:42:34,670 --> 00:42:38,089
是因为我们确保任何日志

1062
00:42:38,089 --> 00:42:40,849
记录对应

1063
00:42:40,849 --> 00:42:43,130
于对 th 中的对象所做的更改

1064
00:42:43,130 --> 00:42:45,140
在将对象写入磁盘之前，数据库已写入磁盘，

1065
00:42:45,140 --> 00:42:48,140
因此这是了解预写日志记录的

1066
00:42:48,140 --> 00:42:49,339
最重要最重要的事情，

1067
00:42:49,339 --> 00:42:51,890
因此

1068
00:42:51,890 --> 00:42:53,089
在他的窃取和无森林示例中预写日志记录，

1069
00:42:53,089 --> 00:42:55,069
因为我们将

1070
00:42:55,069 --> 00:42:56,480
被允许写入

1071
00:42:56,480 --> 00:42:58,609
在事务实际提交之前将脏页从磁盘中取出

1072
00:42:58,609 --> 00:43:00,650
，只要它们的日志记录已被

1073
00:43:00,650 --> 00:43:03,440
首先写出，然后就不需要了，

1074
00:43:03,440 --> 00:43:04,849
因为我们不需要

1075
00:43:04,849 --> 00:43:06,200
事务对两个对象所做的所有更改

1076
00:43:06,200 --> 00:43:08,210
我们烧毁磁盘 我们只

1077
00:43:08,210 --> 00:43:09,410
需要 记录法则被

1078
00:43:09,410 --> 00:43:14,119
写成一个磁盘，所以再次这是

1079
00:43:14,119 --> 00:43:15,170
你需要理解的最重要的事情

1080
00:43:15,170 --> 00:43:17,029
，以便理解

1081
00:43:17,029 --> 00:43:20,750
协议，所以

1082
00:43:20,750 --> 00:43:22,190
如果我有一个

1083
00:43:22,190 --> 00:43:24,740
更新一千个元组的事务，我可能

1084
00:43:24,740 --> 00:43:27,370
必须创建 一千条博客

1085
00:43:27,370 --> 00:43:29,380
记录，假设一千个块茎

1086
00:43:29,380 --> 00:43:32,260
存储在一千个页面中，我的日志

1087
00:43:32,260 --> 00:43:33,730
记录只能存储在一个

1088
00:43:33,730 --> 00:43:36,880
页面中，因此我需要

1089
00:43:36,880 --> 00:43:39,700
做 写一页来刷新

1090
00:43:39,700 --> 00:43:41,710
日志而不是它们

1091
00:43:41,710 --> 00:43:43,480
被修改的所有页面，所以我们

1092
00:43:43,480 --> 00:43:44,530


1093
00:43:44,530 --> 00:43:48,340
将从这种方法中获得一系列性能优势，因此

1094
00:43:48,340 --> 00:43:50,110
数据库将暂存

1095
00:43:50,110 --> 00:43:51,880
事务所做的所有更改 这些

1096
00:43:51,880 --> 00:43:53,710
存储在易失性存储中的日志记录

1097
00:43:53,710 --> 00:43:56,830
通常也由缓冲池支持，

1098
00:43:56,830 --> 00:43:59,380
然后我们已经讨论

1099
00:43:59,380 --> 00:44:00,610
过所有内容都被刷新了，

1100
00:44:00,610 --> 00:44:02,260
并且在

1101
00:44:02,260 --> 00:44:04,000
我们知道所有日志记录

1102
00:44:04,000 --> 00:44:07,480
都已写入磁盘之前，它们不会被视为已提交 好吧，

1103
00:44:07,480 --> 00:44:08,800
协议不能这样工作，所以当

1104
00:44:08,800 --> 00:44:11,170
我们的事务开始时，我们必须在

1105
00:44:11,170 --> 00:44:13,300
日志中写入一个开始记录，它会

1106
00:44:13,300 --> 00:44:14,380
告诉我们嘿，这个

1107
00:44:14,380 --> 00:44:16,270
事务开始了它存在

1108
00:44:16,270 --> 00:44:18,010
这里有一些关于它的元数据，就像

1109
00:44:18,010 --> 00:44:20,620
这里是图像的标识符

1110
00:44:20,620 --> 00:44:22,900
事务提交我们会将

1111
00:44:22,900 --> 00:44:25,870
提交记录写入日志，并且当

1112
00:44:25,870 --> 00:44:27,430
您确保此提交记录

1113
00:44:27,430 --> 00:44:30,850
出现在与 c 对应的任何日志记录之后的日志中时

1114
00:44:30,850 --> 00:44:32,500
赌注

1115
00:44:32,500 --> 00:44:34,720
交易的悬念使得它

1116
00:44:34,720 --> 00:44:36,100
可能会与

1117
00:44:36,100 --> 00:44:37,420
其他交易正在进行的其他更改交织在一起，

1118
00:44:37,420 --> 00:44:39,850
但是对于

1119
00:44:39,850 --> 00:44:41,770
我们此时关心的一个交易，我们的

1120
00:44:41,770 --> 00:44:44,080
提交记录需要在所有更改之后出现，

1121
00:44:44,080 --> 00:44:46,750
我认为它们是因为一旦我们

1122
00:44:46,750 --> 00:44:48,310
看到 场景成为法律 我们知道

1123
00:44:48,310 --> 00:44:49,450
交易不可能做出其他更改

1124
00:44:49,450 --> 00:44:54,240
所以现在首先在每个日志记录

1125
00:44:54,240 --> 00:44:57,070
中 你知道这是

1126
00:44:57,070 --> 00:44:58,360


1127
00:44:58,360 --> 00:45:00,970
我现在正在教授的协议的初始简单版本 我们

1128
00:45:00,970 --> 00:45:03,850
需要记录四件事 唯一的

1129
00:45:03,850 --> 00:45:06,130
事务标识符 就像

1130
00:45:06,130 --> 00:45:07,780
时间戳一样 事务 开始时的标志

1131
00:45:07,780 --> 00:45:10,360


1132
00:45:10,360 --> 00:45:12,280
实际修改的事物的对象 ID 然后

1133
00:45:12,280 --> 00:45:14,080
是前值与对应

1134
00:45:14,080 --> 00:45:15,880
于撤消，然后是

1135
00:45:15,880 --> 00:45:17,950
对应于重做的后值 所以此

1136
00:45:17,950 --> 00:45:19,660
信息本身 这足以

1137
00:45:19,660 --> 00:45:21,190
让我们能够

1138
00:45:21,190 --> 00:45:22,870
恢复数据库以及

1139
00:45:22,870 --> 00:45:24,580
我们在开始时谈到的所有可能

1140
00:45:24,580 --> 00:45:27,910
的错误 nning 所以让我们在这里看一个

1141
00:45:27,910 --> 00:45:28,390
例子，

1142
00:45:28,390 --> 00:45:30,610
所以我们只有 t1 有一个写在 Beam 上的

1143
00:45:30,610 --> 00:45:33,730
写，所以现在在内存中我们

1144
00:45:33,730 --> 00:45:35,740
有我们的右前方日志缓冲区

1145
00:45:35,740 --> 00:45:39,690
和我们的缓冲池，所以当我们做

1146
00:45:39,690 --> 00:45:41,140
事务时，星星

1147
00:45:41,140 --> 00:45:43,180
开始我们 将在

1148
00:45:43,180 --> 00:45:45,580
我们的日志记录中添加一个条目，说嘿，有一个

1149
00:45:45,580 --> 00:45:48,400
刚刚开始的事务，

1150
00:45:48,400 --> 00:45:50,200
通常不会在您调用

1151
00:45:50,200 --> 00:45:53,440
begin 时完全完成，除非您在

1152
00:45:53,440 --> 00:45:54,940
运行时启用自动提交，否则

1153
00:45:54,940 --> 00:45:57,310
通常在第一个右侧完成，但

1154
00:45:57,310 --> 00:45:58,360
不同的系统 可以做不同的

1155
00:45:58,360 --> 00:46:01,810
事情，所以现在我写了我们的名字，所以

1156
00:46:01,810 --> 00:46:02,980
我需要做的第一件事就是将我们的

1157
00:46:02,980 --> 00:46:05,470
条目添加到我的日志缓冲区，上面写着

1158
00:46:05,470 --> 00:46:07,000
我正在做的更改，

1159
00:46:07,000 --> 00:46:09,400
这里是 Bears 比之前的值

1160
00:46:09,400 --> 00:46:11,440
，这里是 在值之后，一旦

1161
00:46:11,440 --> 00:46:13,930
它在我的日志缓冲区中，现在我

1162
00:46:13,930 --> 00:46:15,850
继续在我的缓冲池中对我的页面进行更改，

1163
00:46:15,850 --> 00:46:20,080
我们将

1164
00:46:20,080 --> 00:46:21,370
在下一节课更多地讨论这个原因

1165
00:46:21,370 --> 00:46:24,040
你必须在此之前这样做，因为

1166
00:46:24,040 --> 00:46:25,270
会有 这东西卡尔 引导了一个日志

1167
00:46:25,270 --> 00:46:26,890
序列号，该序列号将

1168
00:46:26,890 --> 00:46:28,690
分配给我们必须使用的日志记录，我们

1169
00:46:28,690 --> 00:46:30,820
必须使用它来确定

1170
00:46:30,820 --> 00:46:32,320
该课程的日志条目是什么，但

1171
00:46:32,320 --> 00:46:35,080
更改了此特定页面，因此您可能会

1172
00:46:35,080 --> 00:46:36,820
认为谁关心嘟嘟嘟

1173
00:46:36,820 --> 00:46:37,870
的磁盘，我可以 只是先更新这个

1174
00:46:37,870 --> 00:46:41,650
然后在这里添加这个东西我们将

1175
00:46:41,650 --> 00:46:43,570
在下一节课看到为什么你必须

1176
00:46:43,570 --> 00:46:47,860
先做这个然后这个所以

1177
00:46:47,860 --> 00:46:49,810
现在我在B上做正确的事情我将

1178
00:46:49,810 --> 00:46:51,880
我的条目添加到我的右手一个红发女郎

1179
00:46:51,880 --> 00:46:54,190
在内存中记录缓冲区然后我继续在

1180
00:46:54,190 --> 00:46:56,620
这里进行更改所以现在当我

1181
00:46:56,620 --> 00:46:57,760
继续进行提交时

1182
00:46:57,760 --> 00:47:00,730
我将提交记录添加到我的红发日志

1183
00:47:00,730 --> 00:47:03,490
缓冲区然后在某些时候我将

1184
00:47:03,490 --> 00:47:05,320
在这种情况下将其从磁盘中刷新

1185
00:47:05,320 --> 00:47:06,730
因为我们需要告诉外部

1186
00:47:06,730 --> 00:47:08,350
世界一个事务被提交将

1187
00:47:08,350 --> 00:47:10,090
立即刷新它做一个 F 同步

1188
00:47:10,090 --> 00:47:12,370
，一旦我们知道它是持久的并且

1189
00:47:12,370 --> 00:47:14,410
从磁盘说此时事务

1190
00:47:14,410 --> 00:47:16,150
被认为是安全的，现在

1191
00:47:16,150 --> 00:47:17,950
返回应用程序并说它是

1192
00:47:17,950 --> 00:47:21,250
现在如此承诺 谁在乎希特勒

1193
00:47:21,250 --> 00:47:22,870
出现并杀死了我们的缓冲

1194
00:47:22,870 --> 00:47:25,930
池，因为我们需要做的一切

1195
00:47:25,930 --> 00:47:28,000
重播它所做的更改现在

1196
00:47:28,000 --> 00:47:31,690
在磁盘上都是安全的，所以如果这个页码被

1197
00:47:31,690 --> 00:47:33,430
写出来，我们可以查看该日志

1198
00:47:33,430 --> 00:47:37,210
并重播它以进行更新 页面

1199
00:47:37,210 --> 00:47:39,490
需要做的事情与事务第一次运行时做的完全一样，

1200
00:47:39,490 --> 00:47:40,780


1201
00:47:40,780 --> 00:47:46,180
所以再次在高级别上很

1202
00:47:46,180 --> 00:47:48,350
清楚

1203
00:47:48,350 --> 00:47:57,320
是的，我们的问题是什么而不是

1204
00:47:57,320 --> 00:47:59,420
将红头发日志缓冲区存储为

1205
00:47:59,420 --> 00:48:01,970
单独的文件，如果我存储它会怎样 在

1206
00:48:01,970 --> 00:48:02,810
页面本身

1207
00:48:02,810 --> 00:48:13,460
我说你告诉我就像

1208
00:48:13,460 --> 00:48:15,260
我们之前谈到的日志结构存储是的所以

1209
00:48:15,260 --> 00:48:18,130
在日志结构存储中你没有

1210
00:48:18,130 --> 00:48:21,050
你在磁盘上没有这个你

1211
00:48:21,050 --> 00:48:27,950
只有这个是的这是一个Volks记录但是

1212
00:48:27,950 --> 00:48:32,810
正确的

1213
00:48:32,810 --> 00:48:35,330
你因为没有这个帽子而放弃的

1214
00:48:35,330 --> 00:48:37,670
是现在读取成本更高，

1215
00:48:37,670 --> 00:48:39,350
因为你必须重放日志以

1216
00:48:39,350 --> 00:48:40,760
找出每次读取时我应该是什么样的页面，

1217
00:48:40,760 --> 00:48:44,210
但它使一些

1218
00:48:44,210 --> 00:48:45,920
写入超快因为现在 你不做

1219
00:48:45,920 --> 00:48:47,420
extr 写出脏页的写操作

1220
00:48:47,420 --> 00:48:49,370
你只会不断地将内容附加到

1221
00:48:49,370 --> 00:48:52,130
日志中，所以有一个权衡，所以

1222
00:48:52,130 --> 00:48:55,370
这就像石头一样 DB leveldb Cassandra

1223
00:48:55,370 --> 00:48:57,560
一堆系统做这些日志结构化合并

1224
00:48:57,560 --> 00:49:01,310
树日志结构存储对我们来说，

1225
00:49:01,310 --> 00:49:02,990
我们是时候了 在这里假设你有表

1226
00:49:02,990 --> 00:49:04,670
堆我们写了我们谈论的一切

1227
00:49:04,670 --> 00:49:05,540
我们有表堆我们已经

1228
00:49:05,540 --> 00:49:07,070
覆盖了一个头日志我们没有做

1229
00:49:07,070 --> 00:49:07,940
我们之前讨论过的日志结构的东西

1230
00:49:07,940 --> 00:49:10,190
但是概念仍然是一样的

1231
00:49:10,190 --> 00:49:12,320
你只是你没有 这你

1232
00:49:12,320 --> 00:49:14,220
没有表

1233
00:49:14,220 --> 00:49:17,690
[音乐]

1234
00:49:23,670 --> 00:49:25,840
所以他的问题是我是否必须进行

1235
00:49:25,840 --> 00:49:29,050
事务并且他们正在更新

1236
00:49:29,050 --> 00:49:31,210
数据库是否有日志记录并

1237
00:49:31,210 --> 00:49:32,590
混合在同一个日志缓冲区中，或者它们

1238
00:49:32,590 --> 00:49:33,880
有单独的日志缓冲区，它们

1239
00:49:33,880 --> 00:49:37,330
再次混合 这是这是这是

1240
00:49:37,330 --> 00:49:39,310
独立的正交于商业的

1241
00:49:39,310 --> 00:49:41,380
东西所以系统的一些更高级别的

1242
00:49:41,380 --> 00:49:43,150
部分说 set 确定是否

1243
00:49:43,150 --> 00:49:44,470
允许更新一个事务 你

1244
00:49:44,470 --> 00:49:46,030
知道我们在这一点上知道该对象的这个

1245
00:49:46,030 --> 00:49:49,150
对象我们假设 因为

1246
00:49:49,150 --> 00:49:51,190
他们被允许这样做，他们确实

1247
00:49:51,190 --> 00:49:52,510
这样做了，他们将这样做，

1248
00:49:52,510 --> 00:49:54,070
因此我们只是将他们的法律

1249
00:49:54,070 --> 00:49:56,890
记录添加到我们不吃的日志文件中，

1250
00:49:56,890 --> 00:49:58,270
我们不维护不同的日志文件

1251
00:49:58,270 --> 00:50:02,230
事务，因为我们有一个

1252
00:50:02,230 --> 00:50:03,520
事务 B 我们知道谁做了什么

1253
00:50:03,520 --> 00:50:08,880
是好的，

1254
00:50:08,880 --> 00:50:11,950
所以如果我们崩溃了，

1255
00:50:11,950 --> 00:50:13,990
我们需要恢复数据库的一切都

1256
00:50:13,990 --> 00:50:18,310
在日志中，所以对于实现

1257
00:50:18,310 --> 00:50:21,310
问题的排序，一个是

1258
00:50:21,310 --> 00:50:22,300
假设数据库何时应该将日志

1259
00:50:22,300 --> 00:50:23,200
条目写出到

1260
00:50:23,200 --> 00:50:25,480
正如我们所说的那样，

1261
00:50:25,480 --> 00:50:27,370
在我们

1262
00:50:27,370 --> 00:50:28,840
告诉外界我们的事务将

1263
00:50:28,840 --> 00:50:30,520
继续进行之前，只要事务提交就可以进行讨论，您知道已完全提交，

1264
00:50:30,520 --> 00:50:32,740
我们确实确保这些日志记录

1265
00:50:32,740 --> 00:50:34,810
和缓冲区现在存储在

1266
00:50:34,810 --> 00:50:36,880
磁盘上，这就是我们的全部 需要能够

1267
00:50:36,880 --> 00:50:40,420
恢复数据库，但我在这里的例子

1268
00:50:40,420 --> 00:50:43,690
我只展示了一个事务，当

1269
00:50:43,690 --> 00:50:45,280
他们说提交时，你知道我

1270
00:50:45,280 --> 00:50:47,800
的意思是同步并写出它，但

1271
00:50:47,800 --> 00:50:50,170
如果我为

1272
00:50:50,170 --> 00:50:51,700
每一个 tra  nsaction

1273
00:50:51,700 --> 00:50:53,440
当他们承诺写出时，我做了一个 F 同步，这是一个日志

1274
00:50:53,440 --> 00:50:55,960
缓冲区，这不是我想要

1275
00:50:55,960 --> 00:50:57,520
做的，因为说 F 同步

1276
00:50:57,520 --> 00:51:00,580
在较慢的磁盘上需要 5 毫秒，然后我

1277
00:51:00,580 --> 00:51:02,020
只能每 5 毫秒提交一个事务

1278
00:51:02,020 --> 00:51:05,470
，然后打赌

1279
00:51:05,470 --> 00:51:07,240
那会很糟糕 我每秒只能执行

1280
00:51:07,240 --> 00:51:09,910
2000 个事务，所以

1281
00:51:09,910 --> 00:51:12,340
每个系统实际实现的

1282
00:51:12,340 --> 00:51:14,680
是所谓的组提交，

1283
00:51:14,680 --> 00:51:16,420
您将允许多个操作

1284
00:51:16,420 --> 00:51:18,310
缓冲日志缓冲区中的一堆更改

1285
00:51:18,310 --> 00:51:20,500
，然后在 某些时候你

1286
00:51:20,500 --> 00:51:21,730
现在就可以做出决定了我会

1287
00:51:21,730 --> 00:51:22,660
继续将日志缓冲区中的任何内容

1288
00:51:22,660 --> 00:51:24,880
写出磁盘，然后可能包括

1289
00:51:24,880 --> 00:51:26,560
来自尚未提交的事务的日志记录

1290
00:51:26,560 --> 00:51:27,099


1291
00:51:27,099 --> 00:51:29,950
是的，但这很好，因为我们知道

1292
00:51:29,950 --> 00:51:31,809
如何撤消他们的撤消 他们的更改，

1293
00:51:31,809 --> 00:51:33,249
因为我们在日志记录中有撤消信息，

1294
00:51:33,249 --> 00:51:36,190
所以这就是

1295
00:51:36,190 --> 00:51:36,759
您最终

1296
00:51:36,759 --> 00:51:39,970
将在项目 4 中实现的内容，因此它的

1297
00:51:39,970 --> 00:51:41,979
基本工作方式是简单的

1298
00:51:41,979 --> 00:51:43,269
f  orm 你而不是有一个日志

1299
00:51:43,269 --> 00:51:45,579
缓冲区，你必须记录缓冲区，这

1300
00:51:45,579 --> 00:51:47,589
有点像影子分页，

1301
00:51:47,589 --> 00:51:49,059
当每个人都在

1302
00:51:49,059 --> 00:51:50,049
写时，有主有主，有

1303
00:51:50,049 --> 00:51:52,979
背景，你最终要写下一个，

1304
00:51:52,979 --> 00:51:55,599
所以当我的事务开始时 t1 在这里

1305
00:51:55,599 --> 00:51:58,479
没有 '不要写在 a 上或者你总是去

1306
00:51:58,479 --> 00:52:00,630
你去第一个首先添加

1307
00:52:00,630 --> 00:52:03,519
开始然后写在 a 上写在

1308
00:52:03,519 --> 00:52:06,700
B 现在我在这里做一个接触开关

1309
00:52:06,700 --> 00:52:06,999


1310
00:52:06,999 --> 00:52:11,200
在 t2 哨兵-去 C 但现在在

1311
00:52:11,200 --> 00:52:14,650
此时我的日志缓冲区已满，因此我

1312
00:52:14,650 --> 00:52:16,450
无法在此处添加任何内容和其他任何内容，

1313
00:52:16,450 --> 00:52:20,079
因此我将继续将其

1314
00:52:20,079 --> 00:52:23,229
写出磁盘，然后我

1315
00:52:23,229 --> 00:52:24,579
必须进行 F 同步，以便您知道这

1316
00:52:24,579 --> 00:52:26,380
需要一些时间 所以与此同时，

1317
00:52:26,380 --> 00:52:28,809
现在我切换到我的第二个日志

1318
00:52:28,809 --> 00:52:31,089
缓冲区，现在

1319
00:52:31,089 --> 00:52:32,769
交易可能会被添加到这个东西的任何其他更改

1320
00:52:32,769 --> 00:52:35,920
这里的想法是开始你的疯狂的那些

1321
00:52:35,920 --> 00:52:37,089
在磁盘中被读取，

1322
00:52:37,089 --> 00:52:39,359
当它被填满时填满下一个 然后

1323
00:52:39,359 --> 00:52:41,440
理想情况下其他的被冲洗掉

1324
00:52:41,440 --> 00:52:42,969
所以没有 然后你写出

1325
00:52:42,969 --> 00:52:44,200
第二个，然后填写

1326
00:52:44,200 --> 00:52:47,130
第一个，所以只是来回走动，

1327
00:52:47,130 --> 00:52:49,180
而那些被刷新的你

1328
00:52:49,180 --> 00:52:52,089
填写另一个，但让我们说这个

1329
00:52:52,089 --> 00:52:55,960
交易在这里它停顿了它做

1330
00:52:55,960 --> 00:52:57,849
一些正确的事情它做了额外的事情

1331
00:52:57,849 --> 00:52:59,890
计算，因此两个事务都不会

1332
00:52:59,890 --> 00:53:03,940
生成新的日志记录，因此，而不是

1333
00:53:03,940 --> 00:53:05,499
在我写出来之前等待它被填满

1334
00:53:05,499 --> 00:53:07,690
，还有第二个

1335
00:53:07,690 --> 00:53:10,509
prop 过程，如果自从我上次刷新

1336
00:53:10,509 --> 00:53:12,640
以来已经有一段时间了，你说得很好

1337
00:53:12,640 --> 00:53:14,589
这

1338
00:53:14,589 --> 00:53:18,369
件事让我继续把它冲洗掉，

1339
00:53:18,369 --> 00:53:19,660
这个想法是你应该想要调整它

1340
00:53:19,660 --> 00:53:21,400
这样的方式，如果你

1341
00:53:21,400 --> 00:53:22,930
知道 f 同步时间是什么

1342
00:53:22,930 --> 00:53:24,880
，在磁盘上写一些东西，那么你

1343
00:53:24,880 --> 00:53:27,729
可以将超时设置为 就像如果

1344
00:53:27,729 --> 00:53:29,079
我需要五毫秒来

1345
00:53:29,079 --> 00:53:30,999
写出第一页或第一个

1346
00:53:30,999 --> 00:53:32,710
博客缓冲区，那么我将等待五

1347
00:53:32,710 --> 00:53:35,109
毫秒来等待第二个，

1348
00:53:35,109 --> 00:53:36,759
如果我还没满，那么五毫秒到

1349
00:53:36,759 --> 00:53:38,289
了我 去啊 阅读并写出它，

1350
00:53:38,289 --> 00:53:40,680


1351
00:53:42,089 --> 00:53:44,260
所以再次组提交基本上说，

1352
00:53:44,260 --> 00:53:47,019
而不是一个事务 F 沉没

1353
00:53:47,019 --> 00:53:49,359
日志，当它提交你回到一堆

1354
00:53:49,359 --> 00:53:50,829
它们在一起然后你

1355
00:53:50,829 --> 00:53:51,849
分摊多个事务的基本成本

1356
00:53:51,849 --> 00:53:53,650
所以如果你是第一个

1357
00:53:53,650 --> 00:53:55,329
事务 被添加

1358
00:53:55,329 --> 00:53:57,250
到日志缓冲区然后你提交

1359
00:53:57,250 --> 00:53:59,260
你有点像你被搞砸了

1360
00:53:59,260 --> 00:54:00,369
因为你必须等待最长时间

1361
00:54:00,369 --> 00:54:01,510
才能真正写出

1362
00:54:01,510 --> 00:54:03,970
磁盘但是如果你是最后一个人那么

1363
00:54:03,970 --> 00:54:05,680
就好像 你知道你正在

1364
00:54:05,680 --> 00:54:07,000
把磁盘完全交给自己，因为

1365
00:54:07,000 --> 00:54:08,890
你不会等待任何时间，所以

1366
00:54:08,890 --> 00:54:10,660
平均而言，这

1367
00:54:10,660 --> 00:54:14,279
比其他人立即上墨要好得多，

1368
00:54:15,359 --> 00:54:19,089
所以最后一个问题

1369
00:54:19,089 --> 00:54:20,410
是她什么时候会真正出现 将

1370
00:54:20,410 --> 00:54:21,460
脏记录很好地写入磁盘，

1371
00:54:21,460 --> 00:54:28,450
这取决于现在，既然我们

1372
00:54:28,450 --> 00:54:30,099
说法律缓冲了我们

1373
00:54:30,099 --> 00:54:31,539
需要做的一切

1374
00:54:31,539 --> 00:54:34,480
我们需要能够重做

1375
00:54:34,480 --> 00:54:37,329
事务所做的更改的所有操作，我们

1376
00:54:37,329 --> 00:54:38,740
说日志 与页面更改相对应的记录

1377
00:54:38,740 --> 00:54:40,869


1378
00:54:40,869 --> 00:54:42,450
在此页面写出到磁盘之前写出到磁盘

1379
00:54:42,450 --> 00:54:45,190
实际上我们并不

1380
00:54:45,190 --> 00:54:47,680
急于在事务提交时立即刷新所有这些页面

1381
00:54:47,680 --> 00:54:48,910
，因为

1382
00:54:48,910 --> 00:54:51,460
法律工作者已被刷新，所以现在根据

1383
00:54:51,460 --> 00:54:52,660
我们的替换策略 在我们的缓冲

1384
00:54:52,660 --> 00:54:54,099
池管理器中，我们可以解释这一点，我们

1385
00:54:54,099 --> 00:54:56,289
可以说好吧，这东西

1386
00:54:56,289 --> 00:54:59,319
很脏，但我法律工作者已经被写

1387
00:54:59,319 --> 00:55:01,150
出来了，所以也许我不想立即 Vic

1388
00:55:01,150 --> 00:55:03,910
这个人 Brian 可以立即驱逐

1389
00:55:03,910 --> 00:55:05,230
它 另一个在这里，

1390
00:55:05,230 --> 00:55:06,759
虽然它可能

1391
00:55:06,759 --> 00:55:08,259
是我被删除或被驱逐的更高优先级，但

1392
00:55:08,259 --> 00:55:10,390
它的日志记录

1393
00:55:10,390 --> 00:55:12,579
还没有被刷新，所以也许我

1394
00:55:12,579 --> 00:55:13,900
不想干那个，因为我

1395
00:55:13,900 --> 00:55:15,730
在我之前先刷新了缓冲区 可以

1396
00:55:15,730 --> 00:55:20,920
写出来，所以这种日志

1397
00:55:20,920 --> 00:55:22,660
和恢复的想法渗透到

1398
00:55:22,660 --> 00:55:23,799
整个系统中，现在我们需要考虑

1399
00:55:23,799 --> 00:55:24,970
系统的其他部分，但

1400
00:55:24,970 --> 00:55:26,380
我们已经讨论过我们可以更新

1401
00:55:26,380 --> 00:55:28,329
替换 跟踪

1402
00:55:28,329 --> 00:55:43,660
这些事情的政策是好的 所以这个

1403
00:55:43,660 --> 00:55:45,759
问题在这些例子中很好所以我们

1404
00:55:45,759 --> 00:55:48,369
不会重新提交所以假设我有

1405
00:55:48,369 --> 00:55:51,009
一个承诺日志缓冲区但是在我

1406
00:55:51,009 --> 00:55:53,710
读到这个高崩溃之前谁在乎

1407
00:55:53,710 --> 00:56:00,309
啊不不 应用程序说提交我们

1408
00:56:00,309 --> 00:56:02,140
还没有告诉我你提交了但我们

1409
00:56:02,140 --> 00:56:04,299
只告诉他们他们在

1410
00:56:04,299 --> 00:56:05,920
对应

1411
00:56:05,920 --> 00:56:07,900
提交消息的日志缓冲区写入磁盘时提交

1412
00:56:07,900 --> 00:56:11,230


1413
00:56:11,230 --> 00:56:13,630
'

1414
00:56:13,630 --> 00:56:14,920
在事务提交后进行验证

1415
00:56:14,920 --> 00:56:17,259
我们仍然可能

1416
00:56:17,259 --> 00:56:20,230
最终在

1417
00:56:20,230 --> 00:56:21,940
此时在法律缓冲区中被中止我们假设所有

1418
00:56:21,940 --> 00:56:23,740
这些都已处理好所以我们在这里看到一条提交

1419
00:56:23,740 --> 00:56:26,109
消息我们不会告诉你知道

1420
00:56:26,109 --> 00:56:27,369
没有回调 说是的，你

1421
00:56:27,369 --> 00:56:29,289
很好，一切都经久耐用，直到法律

1422
00:56:29,289 --> 00:56:35,380
缓冲我们写了一个磁盘他的

1423
00:56:35,380 --> 00:56:37,240
问题是应用程序挂

1424
00:56:37,240 --> 00:56:42,789
了一段时间是正确的，但我的意思是

1425
00:56:42,789 --> 00:56:46,089
，如果你

1426
00:56:46,089 --> 00:56:47,259
不想等着看，否则你还会做什么 什么哟 你

1427
00:56:47,259 --> 00:56:48,789
提交那很好，但你可能会丢失

1428
00:56:48,789 --> 00:56:51,339
数据，所以如果我不运行它一个

1429
00:56:51,339 --> 00:56:57,730
事务那么你实际上知道

1430
00:56:57,730 --> 00:56:59,259
即使你自动提交这里是一个

1431
00:56:59,259 --> 00:57:01,960
单一的事务状态我认为它

1432
00:57:01,960 --> 00:57:03,609
仍然会写一个写日志记录

1433
00:57:03,609 --> 00:57:04,539
之前 它回来并说你的

1434
00:57:04,539 --> 00:57:09,730
事情实际上已经完成了我没有一些

1435
00:57:09,730 --> 00:57:11,109
系统彩票轮流允许你

1436
00:57:11,109 --> 00:57:12,640
关闭基于每个事务的日志记录

1437
00:57:12,640 --> 00:57:15,670
所以我可以运行一个事务，它会

1438
00:57:15,670 --> 00:57:20,079
说我做了一堆更改但是当我

1439
00:57:20,079 --> 00:57:22,470
提交时不要 在日志中写下

1440
00:57:22,470 --> 00:57:25,029
您可以做的任何

1441
00:57:25,029 --> 00:57:28,500
事情，默认情况下某些系统将适用于这样做他们

1442
00:57:28,500 --> 00:57:31,500


1443
00:57:32,280 --> 00:57:34,240
不需要我们需要提交有关

1444
00:57:34,240 --> 00:57:37,119
更新交易的条目还是我们不他的

1445
00:57:37,119 --> 00:57:39,099
问题是我们是否需要

1446
00:57:39,099 --> 00:57:40,869
为零售交易提交条目 你

1447
00:57:40,869 --> 00:57:44,880
认为什么你必须提交

1448
00:57:45,210 --> 00:57:48,839
什么日志记录会击败

1449
00:57:48,839 --> 00:57:50,680
什么没有什么没有什么可以记录

1450
00:57:50,680 --> 00:57:52,270
这就是我想说的就像回到

1451
00:57:52,270 --> 00:57:58,869
这里一样呃哦糟糕对不起泰民嗯哦

1452
00:57:58,869 --> 00:58:06,040
那不是我 PowerPoint 抱歉 y

1453
00:58:06,040 --> 00:58:15,010
所以我展示了正确的，在

1454
00:58:15,010 --> 00:58:16,599
这种情况下，我展示了当

1455
00:58:16,599 --> 00:58:18,750
事务开始时我必须开始输入，

1456
00:58:18,750 --> 00:58:21,369
你不必这样做，因为

1457
00:58:21,369 --> 00:58:22,990
如果它是一个只读事务，

1458
00:58:22,990 --> 00:58:25,869
就像这个叫做 begin 的东西 但是然后

1459
00:58:25,869 --> 00:58:28,210
做了一堆读取然后我存储

1460
00:58:28,210 --> 00:58:30,490
了我不关心的废话你可以

1461
00:58:30,490 --> 00:58:32,859
这样做你不必虽然

1462
00:58:32,859 --> 00:58:35,080
在某些系统中你实际上可以

1463
00:58:35,080 --> 00:58:36,460
在开始时声明一个实际上只读的转弯

1464
00:58:36,460 --> 00:58:38,380
你 说以

1465
00:58:38,380 --> 00:58:40,720
只读方式开始或在续集中的某些内容然后

1466
00:58:40,720 --> 00:58:42,490
您只需关闭所有日志记录和所有

1467
00:58:42,490 --> 00:58:43,750
控制，如果您正在对隔离进行快照，

1468
00:58:43,750 --> 00:58:45,400
因为您只

1469
00:58:45,400 --> 00:58:48,780
知道我将看到

1470
00:58:49,320 --> 00:58:51,430
为了简单起见我应该看到的内容我正在展示

1471
00:58:51,430 --> 00:58:57,010
是的，我的问题是，当你

1472
00:58:57,010 --> 00:58:59,980
像日志一样垃圾时，多几张幻灯片会到达

1473
00:58:59,980 --> 00:59:05,020
那里是的，实际上是剧透

1474
00:59:05,020 --> 00:59:06,760
检查点，但我们会做到这一点，

1475
00:59:06,760 --> 00:59:11,080
所以只是回顾一下

1476
00:59:11,080 --> 00:59:12,940
我们谈论的一切

1477
00:59:12,940 --> 00:59:14,920
进行

1478
00:59:14,920 --> 00:59:18,130
bustable管理的不同方法 nd recovery 是在

1479
00:59:18,130 --> 00:59:19,480
运行时性能和恢复性能的上下文中，

1480
00:59:19,480 --> 00:59:22,330
所以

1481
00:59:22,330 --> 00:59:23,890
错误的时间承诺

1482
00:59:23,890 --> 00:59:25,630
是你知道

1483
00:59:25,630 --> 00:59:28,750
在我运行事务时维护所有这些信息的速度有多快，所以

1484
00:59:28,750 --> 00:59:30,730
在没有钢的情况下，这是

1485
00:59:30,730 --> 00:59:32,470
正确的记录 这将是

1486
00:59:32,470 --> 00:59:35,020
运行时最快的，因为当我

1487
00:59:35,020 --> 00:59:36,550
提交时，我只是提交了那些日志

1488
00:59:36,550 --> 00:59:37,839
记录，我不担心那些

1489
00:59:37,839 --> 00:59:39,670
挂在我的缓冲池上的脏页我会

1490
00:59:39,670 --> 00:59:42,010
在稍后处理它们，而

1491
00:59:42,010 --> 00:59:43,359
使用影子分页 更昂贵，

1492
00:59:43,359 --> 00:59:45,369
因为我必须确保我刷新

1493
00:59:45,369 --> 00:59:45,910


1494
00:59:45,910 --> 00:59:47,890
了我修改的所有页面和我的影子页表，

1495
00:59:47,890 --> 00:59:51,039
然后

1496
00:59:51,039 --> 00:59:52,329
在我告诉外界我

1497
00:59:52,329 --> 00:59:55,299
提交他之前将数据库路由刷新到磁盘，但现在的缺点是如果我

1498
00:59:55,299 --> 00:59:56,500
必须恢复数据库

1499
00:59:56,500 --> 00:59:58,780
崩溃后影子分页是最快的，

1500
00:59:58,780 --> 01:00:00,460
因为我没有做任何额外的事情我只是

1501
01:00:00,460 --> 01:00:02,380
回来，我的戴维斯根指向我的

1502
01:00:02,380 --> 01:00:04,450
影子页面狗屎或一致的

1503
01:00:04,450 --> 01:00:06,430
主人最近提交的

1504
01:00:06,430 --> 01:00:09,220
版本，我做 ne 但是在预写

1505
01:00:09,220 --> 01:00:11,410
日志记录下实际上更慢，

1506
01:00:11,410 --> 01:00:13,900
因为我不是重播记录

1507
01:00:13,900 --> 01:00:16,869
到某个点，她在某种程度上

1508
01:00:16,869 --> 01:00:19,410
暗指垃圾收集，因此

1509
01:00:19,410 --> 01:00:21,069
由于

1510
01:00:21,069 --> 01:00:24,339
性能和恢复时间之间的这种权衡，大多数

1511
01:00:24,339 --> 01:00:26,710
数据库系统实现选择

1512
01:00:26,710 --> 01:00:28,450
正确的日志记录选择 no

1513
01:00:28,450 --> 01:00:30,309
来窃取，因为他们宁愿

1514
01:00:30,309 --> 01:00:33,400
在运行时更快，并假设失败

1515
01:00:33,400 --> 01:00:35,140
失败将是罕见的

1516
01:00:35,140 --> 01:00:36,490


1517
01:00:36,490 --> 01:00:38,859


1518
01:00:38,859 --> 01:00:40,839
有其他

1519
01:00:40,839 --> 01:00:42,849
问题，因此他们愿意以

1520
01:00:42,849 --> 01:00:44,470
更快的运行时性能来

1521
01:00:44,470 --> 01:00:48,400
换取较慢的恢复

1522
01:00:48,400 --> 01:00:52,029
，我只知道一个系统，

1523
01:00:52,029 --> 01:00:55,029
除了像旧的续集灯那样进行阴影分页

1524
01:00:55,029 --> 01:00:56,619
的

1525
01:00:56,619 --> 01:00:57,880
系统，只有一个系统我可以 以

1526
01:00:57,880 --> 01:01:01,809
更快的恢复时间

1527
01:01:01,809 --> 01:01:04,690
换取在运行时运行更慢的权衡，就是

1528
01:01:04,690 --> 01:01:05,920
这个系统我不知道它的名称

1529
01:01:05,920 --> 01:01:08,799
它是一个数据库系统 m 建于

1530
01:01:08,799 --> 01:01:10,750
1970 年代，用于波多黎各

1531
01:01:10,750 --> 01:01:12,819
电气系统，因为

1532
01:01:12,819 --> 01:01:14,589
在 1970 年代的波多黎各，他们几乎每小时都停电，

1533
01:01:14,589 --> 01:01:17,109
因此 DA 的

1534
01:01:17,109 --> 01:01:19,240
ism 几乎每小时都在崩溃，因此对他们

1535
01:01:19,240 --> 01:01:21,329
来说，最好在运行时慢一点

1536
01:01:21,329 --> 01:01:23,349
，以便 每隔一个小时，

1537
01:01:23,349 --> 01:01:25,210
当你断电时崩溃，你可以

1538
01:01:25,210 --> 01:01:28,710
恢复数据库 Amelia Edwards

1539
01:01:28,770 --> 01:01:31,180
对另一个在高层有这样的事情

1540
01:01:31,180 --> 01:01:33,010
，这

1541
01:01:33,010 --> 01:01:34,750
是没有撤消没有重做，因为没有

1542
01:01:34,750 --> 01:01:36,069
什么可以逆转，也没有什么可以

1543
01:01:36,069 --> 01:01:37,960
重新申请的 日志记录

1544
01:01:37,960 --> 01:01:44,069
你需要撤消和重做，所以我

1545
01:01:44,069 --> 01:01:46,720
在高层次上展示了

1546
01:01:46,720 --> 01:01:48,339
这些长记录是什么，有一个

1547
01:01:48,339 --> 01:01:51,760
对象 ID，然后

1548
01:01:51,760 --> 01:01:54,880
在后值中有一个 for 值，但这是如何

1549
01:01:54,880 --> 01:01:56,589
实际实现的，所以有几种

1550
01:01:56,589 --> 01:01:58,610
不同的方法

1551
01:01:58,610 --> 01:02:00,860
所以一个，但一个就是

1552
01:02:00,860 --> 01:02:01,910
所谓的物理日志记录，这

1553
01:02:01,910 --> 01:02:02,990
基本上就是我到目前为止所讨论的内容，

1554
01:02:02,990 --> 01:02:06,650
即我们正在记录

1555
01:02:06,650 --> 01:02:08,750
对特定位置的低级字节更改 n 作为

1556
01:02:08,750 --> 01:02:11,150
您创建的数据库中的某个对象 -

1557
01:02:11,150 --> 01:02:12,590
您知道并且知道如何反转它，

1558
01:02:12,590 --> 01:02:14,240
所以认为这就像如果您在

1559
01:02:14,240 --> 01:02:15,850
那里运行或获得差异，

1560
01:02:15,850 --> 01:02:18,470
它就在原处，但允许您

1561
01:02:18,470 --> 01:02:20,180
获得之前和之后的优势

1562
01:02:20,180 --> 01:02:23,120
更改但不利的一面

1563
01:02:23,120 --> 01:02:25,010
是如果我必须更新

1564
01:02:25,010 --> 01:02:27,800
我的事务中的十亿个元组我

1565
01:02:27,800 --> 01:02:30,350
必须有十亿个日志记录

1566
01:02:30,350 --> 01:02:31,640
对应于所有那些低级别的

1567
01:02:31,640 --> 01:02:35,390
物理更改另一种方法是进行

1568
01:02:35,390 --> 01:02:38,210
逻辑日志记录 您只需记录

1569
01:02:38,210 --> 01:02:40,010


1570
01:02:40,010 --> 01:02:42,040
您对数据库所做的哪些更改的高级操作，并且

1571
01:02:42,040 --> 01:02:43,820
足以让您能够

1572
01:02:43,820 --> 01:02:47,000
在运行时重新应用它，

1573
01:02:47,000 --> 01:02:49,760
如果您知道

1574
01:02:49,760 --> 01:02:52,670
基于实际情况的内容，则撤消会更加棘手 查询是，但

1575
01:02:52,670 --> 01:02:55,730
让我们暂时忽略它，所以我认为

1576
01:02:55,730 --> 01:02:57,440
这样的事情

1577
01:02:57,440 --> 01:02:59,240
就像在您所做的更改的差异中

1578
01:02:59,240 --> 01:03:01,070
存储的方式实际上是存储

1579
01:03:01,070 --> 01:03:06,110
您所做的更改的续集查询，因此

1580
01:03:06,110 --> 01:03:07,550
每个的优点或缺点

1581
01:03:07,550 --> 01:03:08,900
他们就是 逻辑博客允许

1582
01:03:08,900 --> 01:03:11,960
你用更少的数据记录更多的变化

1583
01:03:11,960 --> 01:03:14,330
我用一个更新语句更新了十亿

1584
01:03:14,330 --> 01:03:16,340
个更新我只知道

1585
01:03:16,340 --> 01:03:19,880
那个更新语句

1586
01:03:19,880 --> 01:03:22,250
逻辑日志的缺点是我很难

1587
01:03:22,250 --> 01:03:25,070


1588
01:03:25,070 --> 01:03:27,230
弄清楚是什么 我

1589
01:03:27,230 --> 01:03:29,480
可能对我在崩溃前写入磁盘的数据库进行的更改，

1590
01:03:29,480 --> 01:03:33,200
因为

1591
01:03:33,200 --> 01:03:35,120
我没有那些低级信息

1592
01:03:35,120 --> 01:03:37,340
我更新了十亿到超过

1593
01:03:37,340 --> 01:03:39,830
十亿页也许其中一半是

1594
01:03:39,830 --> 01:03:42,350
如何写出磁盘的 我知道

1595
01:03:42,350 --> 01:03:46,940
我需要更新哪些问题并重新应用

1596
01:03:46,940 --> 01:03:48,260
其他问题吗？您会看到，

1597
01:03:48,260 --> 01:03:50,240
无论

1598
01:03:50,240 --> 01:03:51,800
我第一次使用逻辑日志记录方案运行查询时更新数据库需要多长时间，

1599
01:03:51,800 --> 01:03:53,960
这

1600
01:03:53,960 --> 01:03:55,160
都需要相同数量的

1601
01:03:55,160 --> 01:03:57,560
第二次，所以我的查询

1602
01:03:57,560 --> 01:03:59,990
在恢复期间运行了一个小时，再次运行需要一个小时

1603
01:03:59,990 --> 01:04:01,610
，这没有什么神奇之处，因为

1604
01:04:01,610 --> 01:04:02,720
我处于恢复模式，这会让它运行

1605
01:04:02,720 --> 01:04:06,170
得更快，所以尽管存储的皮肤

1606
01:04:06,170 --> 01:04:07,490
我存储的更少

1607
01:04:07,490 --> 01:04:08,690
逻辑日志记录的信息会使

1608
01:04:08,690 --> 01:04:10,730
恢复成本更高，而且大多数系统

1609
01:04:10,730 --> 01:04:12,940
不会进行这种更改

1610
01:04:12,940 --> 01:04:15,110
大多数人使用的混合方法

1611
01:04:15,110 --> 01:04:18,560
称为生理登录，

1612
01:04:18,560 --> 01:04:20,240
您不会在其中存储

1613
01:04:20,240 --> 01:04:22,010
有关更改的低级字节信息

1614
01:04:22,010 --> 01:04:24,020
对数据库进行处理，

1615
01:04:24,020 --> 01:04:26,600
您仍然会觉得它的

1616
01:04:26,600 --> 01:04:28,220
级别很低，可以在此页面上说

1617
01:04:28,220 --> 01:04:30,500
我正在修改此对象，但您不是，

1618
01:04:30,500 --> 01:04:32,000
您并没有

1619
01:04:32,000 --> 01:04:34,970
像在物理日志记录下那样真正采取差异 你只是

1620
01:04:34,970 --> 01:04:36,620
说这是合乎逻辑的事情我希望

1621
01:04:36,620 --> 01:04:38,930
你做出改变所以这

1622
01:04:38,930 --> 01:04:40,900
是大多数系统实际实现的

1623
01:04:40,900 --> 01:04:42,950
所以假设我们在这里有这个更新查询

1624
01:04:42,950 --> 01:04:44,900
所以在物理日志中它

1625
01:04:44,900 --> 01:04:47,360
就像在这个页面上 偏移量这里

1626
01:04:47,360 --> 01:04:49,370
是前后图像，我们

1627
01:04:49,370 --> 01:04:50,720
还没有讨论过索引，但是

1628
01:04:50,720 --> 01:04:53,240
在您对数据库进行更改的同时在日志中对您进行了基本索引，

1629
01:04:53,240 --> 01:04:54,440


1630
01:04:54,440 --> 01:04:57,140
因为如果我的索引

1631
01:04:57,140 --> 01:04:59,060
不适合内存那么 我不想

1632
01:04:59,060 --> 01:05:00,470
必须在恢复时从头开始重建，

1633
01:05:00,470 --> 01:05:02,570
因此大多数数据系统也会

1634
01:05:02,570 --> 01:05:04,820
记录您所做的更改

1635
01:05:04,820 --> 01:05:08,300
再次索引查询的逻辑登录 您

1636
01:05:08,300 --> 01:05:10,340
只需存储 Seigle 语句 物理

1637
01:05:10,340 --> 01:05:13,100
逻辑日志 您是在此

1638
01:05:13,100 --> 01:05:16,370
页面上说的此插槽编号这里是

1639
01:05:16,370 --> 01:05:17,600
更改我希望您将这些

1640
01:05:17,600 --> 01:05:20,990
低级属性设置为这些低级属性，这使

1641
01:05:20,990 --> 01:05:24,770
您不必在这种

1642
01:05:24,770 --> 01:05:26,210
额外的间接方式中使用这些属性，就像

1643
01:05:26,210 --> 01:05:27,080
带槽的页面一样，

1644
01:05:27,080 --> 01:05:29,780
它不允许您

1645
01:05:29,780 --> 01:05:32,450
以这种方式重新排序重放操作

1646
01:05:32,450 --> 01:05:35,240


1647
01:05:35,240 --> 01:05:37,730
在崩溃之前和之后，数据并不意味着一个字节的字节复制，

1648
01:05:37,730 --> 01:05:39,620
你有一些回旋余地来

1649
01:05:39,620 --> 01:05:42,050
实际以不同的方式重新应用这些

1650
01:05:42,050 --> 01:05:44,150
并恢复仍然恢复到

1651
01:05:44,150 --> 01:05:49,430
正确的状态，所以

1652
01:05:49,430 --> 01:05:52,340
得到她的问题是

1653
01:05:52,340 --> 01:05:54,170
到目前为止，我们所讨论的任何问题都是，

1654
01:05:54,170 --> 01:05:56,000


1655
01:05:56,000 --> 01:05:58,550
如果我的数据库系统

1656
01:05:58,550 --> 01:06:00,350
运行一年，这些前面的

1657
01:06:00,350 --> 01:06:03,920
日志将永远增长 如果我

1658
01:06:03,920 --> 01:06:05,690
崩溃并返回重播此日志，

1659
01:06:05,690 --> 01:06:07,490
我可能不得不重播

1660
01:06:07,490 --> 01:06:11,060
一整年的数据，因此逻辑日志

1661
01:06:11,060 --> 01:06:13,010
记录会很糟糕，因为

1662
01:06:13,010 --> 01:06:14,600
如果查询花费的时间

1663
01:06:14,600 --> 01:06:16,250
与第一次在恢复期间花费的时间相同，那么

1664
01:06:16,250 --> 01:06:18,200
鲁莽 所以我有一年

1665
01:06:18,200 --> 01:06:20,660
的逻辑日志记录数据，如果我崩溃

1666
01:06:20,660 --> 01:06:22,520
然后回来我假装我花了一年

1667
01:06:22,520 --> 01:06:25,500
时间来恢复数据库

1668
01:06:25,500 --> 01:06:29,500
所以这很糟糕所以我们可以

1669
01:06:29,500 --> 01:06:32,650
截断日志的方式是所谓的

1670
01:06:32,650 --> 01:06:35,619
检查点和 检查点的想法

1671
01:06:35,619 --> 01:06:38,109
是我们将清除

1672
01:06:38,109 --> 01:06:40,119
缓冲区中所有脏页

1673
01:06:40,119 --> 01:06:43,150
拉出磁盘并在我们的日志记录中添加一个条目

1674
01:06:43,150 --> 01:06:45,940
说此时磁盘

1675
01:06:45,940 --> 01:06:47,500
中没有不耐用的脏页

1676
01:06:47,500 --> 01:06:49,480
所以 因此你不需要

1677
01:06:49,480 --> 01:06:52,780


1678
01:06:52,780 --> 01:06:55,180
从我的检查点重播那么远的过去，

1679
01:06:55,180 --> 01:06:57,339
因为我知道所有这些变化

1680
01:06:57,339 --> 01:06:59,950
再次持续存在

1681
01:06:59,950 --> 01:07:01,809
，因为我们正在执行窃取

1682
01:07:01,809 --> 01:07:05,349
策略或我们正在执行的无强制策略 不

1683
01:07:05,349 --> 01:07:07,150
重新 要求事务所做的脏页

1684
01:07:07,150 --> 01:07:09,160
必须在事务提交之前从磁盘中刷新，

1685
01:07:09,160 --> 01:07:10,390


1686
01:07:10,390 --> 01:07:13,450
所以如果我们崩溃，我们不知道它们

1687
01:07:13,450 --> 01:07:15,309
是否真的将其写入磁盘，

1688
01:07:15,309 --> 01:07:17,619
而当

1689
01:07:17,619 --> 01:07:19,540
我们知道检查点完成时使用检查点我们知道

1690
01:07:19,540 --> 01:07:21,700
那时一切都已

1691
01:07:21,700 --> 01:07:26,410
写入磁盘，因此请看这里的非常简单的

1692
01:07:26,410 --> 01:07:28,329
示例，因此对于这个示例，我

1693
01:07:28,329 --> 01:07:29,859
将使用一个非常简单的检查点

1694
01:07:29,859 --> 01:07:32,410
方案，该方案基本上停止世界

1695
01:07:32,410 --> 01:07:35,190
停止所有事务的运行并

1696
01:07:35,190 --> 01:07:37,839
清除所有更改

1697
01:07:37,839 --> 01:07:40,089
脏页输出到磁盘，然后一旦我

1698
01:07:40,089 --> 01:07:41,260
知道所有脏页都已写入，

1699
01:07:41,260 --> 01:07:43,740
然后我让它们再次开始运行，

1700
01:07:43,740 --> 01:07:46,150
这称为一致性

1701
01:07:46,150 --> 01:07:48,150
检查点或阻塞检查点

1702
01:07:48,150 --> 01:07:50,170
大多数系统实际上并没有以这种方式实现它，

1703
01:07:50,170 --> 01:07:51,819
我们将在周三看到如何 为了

1704
01:07:51,819 --> 01:07:53,740
做得更好，以及如何同时运行，

1705
01:07:53,740 --> 01:07:55,569
但只要理解它，

1706
01:07:55,569 --> 01:07:58,089
编辑你就知道

1707
01:07:58,089 --> 01:07:59,530
基本协议的工作原理，假设是

1708
01:07:59,530 --> 01:08:01,930
这样，所以我要去 在此处添加此检查点

1709
01:08:01,930 --> 01:08:04,180
条目，因此当我采取此检查点时会发生什么，

1710
01:08:04,180 --> 01:08:06,460
我会停止所有

1711
01:08:06,460 --> 01:08:08,170
事务的运行并清除

1712
01:08:08,170 --> 01:08:11,349
所有脏页，因此现在如果

1713
01:08:11,349 --> 01:08:14,920
我回来时发生崩溃，我知道我

1714
01:08:14,920 --> 01:08:18,100
不需要 看看 net1 t1 s 的变化，

1715
01:08:18,100 --> 01:08:21,670
因为 t1 在我的检查点之前提交，

1716
01:08:21,670 --> 01:08:23,859
所以我知道所有 t1 更改

1717
01:08:23,859 --> 01:08:25,630
都写入了一个磁盘，所以我不需要

1718
01:08:25,630 --> 01:08:27,939
重播并查看它很长它是

1719
01:08:27,939 --> 01:08:30,880
其他两个人 t2 和 t3 那些人

1720
01:08:30,880 --> 01:08:32,229
开始并且可以 可能会

1721
01:08:32,229 --> 01:08:34,149
在我的检查点之前进行更改，因此我需要

1722
01:08:34,149 --> 01:08:35,890
返回到该点之前的日志中，并

1723
01:08:35,890 --> 01:08:38,469
弄清楚他们实际上对我的戴维斯做了什么，

1724
01:08:38,469 --> 01:08:40,660
回到正确的状态，所以在

1725
01:08:40,660 --> 01:08:41,560
这种情况下

1726
01:08:41,560 --> 01:08:44,799
t2 在崩溃前提交，所以我知道

1727
01:08:44,799 --> 01:08:46,630
我想要 重新应用它的更改以重做

1728
01:08:46,630 --> 01:08:49,600
他们的交换 t3

1729
01:08:49,600 --> 01:08:51,460
在崩溃之前没有提交所以我知道我想

1730
01:08:51,460 --> 01:08:55,509
正确地撤销它的更改所以

1731
01:08:55,509 --> 01:08:56,680
检查点基本上是如果你的皮肤

1732
01:08:56,680 --> 01:08:58,299
告诉我们我们知道在这个

1733
01:08:58,299 --> 01:09:00,670
时间点所有来自任何

1734
01:09:00,670 --> 01:09:01,779
事务的脏页面 已被写入 tten 到磁盘

1735
01:09:01,779 --> 01:09:04,509
，然后由我们来弄清楚检查点

1736
01:09:04,509 --> 01:09:07,540
之前发生了

1737
01:09:07,540 --> 01:09:09,100
什么以及检查点之后发生了什么，

1738
01:09:09,100 --> 01:09:10,719
以决定允许谁

1739
01:09:10,719 --> 01:09:15,759
实际保留他们的更改，

1740
01:09:15,759 --> 01:09:17,319
所以游戏将

1741
01:09:17,319 --> 01:09:20,198
在周三更多地讨论检查点，但在我的简单

1742
01:09:20,198 --> 01:09:22,600
示例中 在这里，我停止了所有

1743
01:09:22,600 --> 01:09:24,719
交易以使我的生活更轻松，

1744
01:09:24,719 --> 01:09:27,310
因为如果我有一个正在

1745
01:09:27,310 --> 01:09:29,380
更新一堆页面的交易，我

1746
01:09:29,380 --> 01:09:32,170
不想有这种情况，或者我可能不得不

1747
01:09:32,170 --> 01:09:33,549
做一些实际工作才能弄清楚

1748
01:09:33,549 --> 01:09:35,290
我是 更新 20 个页面，我的检查点

1749
01:09:35,290 --> 01:09:36,880
刷新了事务修改的前 10 个页面，

1750
01:09:36,880 --> 01:09:39,160
但是在

1751
01:09:39,160 --> 01:09:40,238
检查点运行时它修改了

1752
01:09:40,238 --> 01:09:41,529
其他这些我没有刷新这些东西

1753
01:09:41,529 --> 01:09:43,479
，所以我不想弄清楚

1754
01:09:43,479 --> 01:09:47,710
哪些实际上应该在附近 另一个

1755
01:09:47,710 --> 01:09:49,359
棘手的事情是不清楚

1756
01:09:49,359 --> 01:09:50,890
我们应该多久执行一次检查点，

1757
01:09:50,890 --> 01:09:52,359
因为这些检查点不是免费的，

1758
01:09:52,359 --> 01:09:54,310
因为我们正在写出脏页

1759
01:09:54,310 --> 01:09:56,440
，这会减慢磁盘速度

1760
01:09:56,440 --> 01:09:58,540
现在

1761
01:09:58,540 --> 01:10:00,190
在很多系统中可能会用完日志，他们将有

1762
01:10:00,190 --> 01:10:01,989
磁盘，我们存储在单独的磁盘中的日志

1763
01:10:01,989 --> 01:10:03,910
和热球是一种单独的

1764
01:10:03,910 --> 01:10:05,560
磁盘，因此当您对它们进行网络同步时

1765
01:10:05,560 --> 01:10:06,820
，您不会 彼此放慢速度，

1766
01:10:06,820 --> 01:10:08,739
但现在我的检查点再次

1767
01:10:08,739 --> 01:10:11,170
用完脏页，而我本来可以

1768
01:10:11,170 --> 01:10:13,000
这样做的你知道驱逐磁盘页面

1769
01:10:13,000 --> 01:10:13,449


1770
01:10:13,449 --> 01:10:16,960
以在我的缓冲池中获得新空间以

1771
01:10:16,960 --> 01:10:19,530
让其他事务继续运行，

1772
01:10:19,530 --> 01:10:21,730
因此您采取检查点的频率可能

1773
01:10:21,730 --> 01:10:25,469
会有所不同 在实现上，所以

1774
01:10:25,469 --> 01:10:28,030
一种方法是说

1775
01:10:28,030 --> 01:10:30,760
每每 Sura 分钟或秒之后，

1776
01:10:30,760 --> 01:10:33,940
如果我这样做，那么我的恢复

1777
01:10:33,940 --> 01:10:36,100
时间要快得多，因为现在我

1778
01:10:36,100 --> 01:10:37,810
不需要在日志碎片中回溯那么远

1779
01:10:37,810 --> 01:10:38,560
了 实际上应该坚持什么，

1780
01:10:38,560 --> 01:10:40,239
因为我的检查点

1781
01:10:40,239 --> 01:10:42,250
发生得更频繁，因为

1782
01:10:42,250 --> 01:10:43,750
现在检查点正在减慢我的速度，所以

1783
01:10:43,750 --> 01:10:45,239
我喜欢我的运行时性能受到

1784
01:10:45,239 --> 01:10:47,080
另一种方法的影响，我实际上

1785
01:10:47,080 --> 01:10:49,719
认为更好的是检查点仅

1786
01:10:49,719 --> 01:10:51,219
occ

1787
01:10:51,219 --> 01:10:52,239


1788
01:10:52,239 --> 01:10:54,099
在我将 250

1789
01:10:54,099 --> 01:10:56,289
兆字节的数据写入日志之后，一定数量的数据超出了法律规定，然后我采取

1790
01:10:56,289 --> 01:10:59,050
了一个检查点，这限制了

1791
01:10:59,050 --> 01:11:01,599
您必须等待的时间，您

1792
01:11:01,599 --> 01:11:05,320
不必担心 你是否

1793
01:11:05,320 --> 01:11:07,869
因为它是你的而不必要地采取检查点

1794
01:11:07,869 --> 01:11:10,030
我知道我只需要看着

1795
01:11:10,030 --> 01:11:11,619
我，但我最想

1796
01:11:11,619 --> 01:11:13,420
在再次恢复我的数据库之前加入 50 兆字节的日志

1797
01:11:13,420 --> 01:11:16,119
我正在检查这个非常

1798
01:11:16,119 --> 01:11:17,739
非常非常快 因为我们 时间不多了，

1799
01:11:17,739 --> 01:11:19,780
但我们将介绍更多细节，

1800
01:11:19,780 --> 01:11:23,920
我在星期三对你进行了 Teletrac，因此

1801
01:11:23,920 --> 01:11:25,090
任何有关检查点的高级问题

1802
01:11:25,090 --> 01:11:28,179
都说检查点就像

1803
01:11:28,179 --> 01:11:29,949
是右侧日志的垃圾收集，

1804
01:11:29,949 --> 01:11:32,289
但我知道 在那个

1805
01:11:32,289 --> 01:11:33,249
检查站的那个点，

1806
01:11:33,249 --> 01:11:35,440
我可能不需要查看

1807
01:11:35,440 --> 01:11:42,219
它之前的任何东西，当然在

1808
01:11:42,219 --> 01:11:43,389
极端情况下，如果我有它，如果我

1809
01:11:43,389 --> 01:11:45,190
选择行动运行几天，

1810
01:11:45,190 --> 01:11:46,210
我每五分钟检查一次

1811
01:11:46,210 --> 01:11:48,639
我需要回到

1812
01:11:48,639 --> 01:11:49,719
交易开始的时间 ed 找出

1813
01:11:49,719 --> 01:11:55,690
所有更改实际上都没有问题，所以正如

1814
01:11:55,690 --> 01:11:57,369
我前面所说的那样，日志记录几乎

1815
01:11:57,369 --> 01:12:00,159
总是最好的方法，

1816
01:12:00,159 --> 01:12:03,340
最好的方法是处理避免数据

1817
01:12:03,340 --> 01:12:04,869
丢失或确保我们的数据库

1818
01:12:04,869 --> 01:12:07,869
ism 在磁盘上是持久的，核心思想

1819
01:12:07,869 --> 01:12:09,880
是什么 它的工作原理是

1820
01:12:09,880 --> 01:12:11,590
它将使用钢铁无强制缓冲池

1821
01:12:11,590 --> 01:12:13,989
管理策略 它

1822
01:12:13,989 --> 01:12:16,030
会将事务对其日志记录所做的所有更改刷新

1823
01:12:16,030 --> 01:12:18,369
到磁盘，然后我们告诉

1824
01:12:18,369 --> 01:12:19,539
外界事务已

1825
01:12:19,539 --> 01:12:21,369
提交，然后在

1826
01:12:21,369 --> 01:12:22,539
稍后的后台进行 我们可以

1827
01:12:22,539 --> 01:12:24,340
清除那些脏页，但是我们必须

1828
01:12:24,340 --> 01:12:25,690
先写日志记录，然后

1829
01:12:25,690 --> 01:12:27,429
才能写出它们修改的脏页

1830
01:12:27,429 --> 01:12:31,630
，等等恢复我们只需撤消

1831
01:12:31,630 --> 01:12:33,400
未提交事务的任何更改，

1832
01:12:33,400 --> 01:12:35,289
然后他们重做提交

1833
01:12:35,289 --> 01:12:37,210
更改的提交重做

1834
01:12:37,210 --> 01:12:38,650
任何已提交事务的更改以

1835
01:12:38,650 --> 01:12:45,190
确保它们得到应用是的这个

1836
01:12:45,190 --> 01:12:47,230
问题是我们必须再次撤消

1837
01:12:47,230 --> 01:12:48,610
恢复时的潜在更改我们将

1838
01:12:48,610 --> 01:12:51,460
星期三覆盖，因为来自

1839
01:12:51,460 --> 01:12:53,469
未提交事务的更改可能会使

1840
01:12:53,469 --> 01:12:55,030
那些脏页现在可以从

1841
01:12:55,030 --> 01:12:56,739
磁盘中读取，因为我们正在使用窃取

1842
01:12:56,739 --> 01:12:59,130
策略

1843
01:13:02,489 --> 01:13:04,809
我现在实际上永远不会穿它

1844
01:13:04,809 --> 01:13:05,380


1845
01:13:05,380 --> 01:13:08,559
他的问题是这个问题是

1846
01:13:08,559 --> 01:13:11,139
恢复时我们的其他情况

1847
01:13:11,139 --> 01:13:12,999
不必撤消，因为我们可以查看

1848
01:13:12,999 --> 01:13:14,919
数据艺术更改，实际上可以将其显示

1849
01:13:14,919 --> 01:13:24,939
在光盘中 知道剧透

1850
01:13:24,939 --> 01:13:28,539
将在星期三您重做您

1851
01:13:28,539 --> 01:13:29,650
可以通过多次重复的法律

1852
01:13:29,650 --> 01:13:30,039


1853
01:13:30,039 --> 01:13:32,199
重复的一切 您将重做一切，但随着

1854
01:13:32,199 --> 01:13:34,150
您 重做你说哦，我看到这个

1855
01:13:34,150 --> 01:13:35,739
事务没有提交，

1856
01:13:35,739 --> 01:13:37,389
然后你在日志上返回并撤消并撤消

1857
01:13:37,389 --> 01:13:40,929
任何正在发生的事情，所以你只是你

1858
01:13:40,929 --> 01:13:44,079
安全地玩它并且你总是撤消

1859
01:13:44,079 --> 01:13:45,309
有一些我不

1860
01:13:45,309 --> 01:13:50,459
认为的优化 大多数人都做得很好，所以

1861
01:13:50,459 --> 01:13:53,289
在周三的课上，这将是

1862
01:13:53,289 --> 01:13:54,369
我们讨论的日志恢复的第二部分是我们

1863
01:13:54,369 --> 01:13:56,110


1864
01:13:56,110 --> 01:13:58,239
在崩溃后重新启动后做的两

1865
01:13:58,239 --> 01:13:59,530
件事我们如何使用正确的 head log 如何

1866
01:13:59,530 --> 01:14:00,550
使用检查点让我们回到

1867
01:14:00,550 --> 01:14:02,889
正确的状态 所以这可能

1868
01:14:02,889 --> 01:14:05,499
是数据库系统中第三难的部分

1869
01:14:05,499 --> 01:14:07,150
所以我们谈论的是

1870
01:14:07,150 --> 01:14:10,239
Aries Aries 是

1871
01:14:10,239 --> 01:14:11,949
你如何进行数据库恢复的黄金标准我不知道 不

1872
01:14:11,949 --> 01:14:14,199
知道教科书上的 Aries 是什么，

1873
01:14:14,199 --> 01:14:16,539
但是大多数

1874
01:14:16,539 --> 01:14:18,070
在所有人之前实施的系统都不会调用，

1875
01:14:18,070 --> 01:14:20,110
但他们正在做 Aries 但每个人

1876
01:14:20,110 --> 01:14:21,639
都在做红头日志记录，这是

1877
01:14:21,639 --> 01:14:23,349
基于 1990 年代 IBM 协议的我，

1878
01:14:23,349 --> 01:14:24,969
无论他们是否 知道他们正在

1879
01:14:24,969 --> 01:14:27,219
使用他们的基本使用白羊座 我是

1880
01:14:27,219 --> 01:14:30,550
格雷厄姆 好吧 我

1881
01:14:30,550 --> 01:14:34,900
现在在 1:30 上班，周一见

1882
01:14:34,900 --> 01:14:37,019


1883
01:14:40,929 --> 01:14:42,939


1884
01:14:42,939 --> 01:14:46,329
说

1885
01:14:46,329 --> 01:14:48,459
我的系统中的刀 我很幸运

1886
01:14:48,459 --> 01:14:55,929
让我们去拿下一个 好

1887
01:14:55,929 --> 01:14:57,969
会有儿子 跳弹果冻 去

1888
01:14:57,969 --> 01:15:00,099
熟食店打船 自然祝福

1889
01:15:00,099 --> 01:15:01,809
你 说唱就像激光束

1890
01:15:01,809 --> 01:15:04,360
丛林中的傻瓜说不出什么 国王把

1891
01:15:04,360 --> 01:15:06,670
我们的瓶子包起来，一个很好的同情去 你

1892
01:15:06,670 --> 01:15:08,530
不喜欢

1893
01:15:08,530 --> 01:15:11,289
喝醉了的你不能尝试，如果

1894
01:15:11,289 --> 01:15:14,780
不知道你的手机可以点击一个东西

1895
01:15:14,780 --> 01:15:17,840
[音乐]

