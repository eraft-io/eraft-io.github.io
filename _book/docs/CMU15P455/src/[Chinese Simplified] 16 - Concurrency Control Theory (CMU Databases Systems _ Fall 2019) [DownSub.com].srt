1
00:00:03,640 --> 00:00:13,140
[音乐

2
00:00:15,789 --> 00:00:17,600
] 再次

3
00:00:17,600 --> 00:00:21,199
感谢 Gigi 轻松放下桌子，让

4
00:00:21,199 --> 00:00:22,550
一切保持新鲜，

5
00:00:22,550 --> 00:00:25,999
所以我们很乐意再次快速讨论

6
00:00:25,999 --> 00:00:27,949
分配项目的三个

7
00:00:27,949 --> 00:00:29,720
热门歌曲，这将在

8
00:00:29,720 --> 00:00:32,060
11 月 17 日星期日到期，我 将

9
00:00:32,060 --> 00:00:33,650
在这堂课结束时简要讨论一下

10
00:00:33,650 --> 00:00:37,430
，然后计划或说家庭作业 4

11
00:00:37,430 --> 00:00:39,770
应该是四个而不是三个，或者将在

12
00:00:39,770 --> 00:00:42,379
下周发布，然后

13
00:00:42,379 --> 00:00:45,379
我们会在第十三天做的更好

14
00:00:45,379 --> 00:00:48,469
，正如我所说，我的妻子是

15
00:00:48,469 --> 00:00:49,969
今晚我们要去医院 它会在

16
00:00:49,969 --> 00:00:52,250
九个小时后发生 所以

17
00:00:52,250 --> 00:00:53,629
我将离开两周 我

18
00:00:53,629 --> 00:00:54,980
下周或下周将没有办公时间

19
00:00:54,980 --> 00:00:56,929
然后下周我们仍然

20
00:00:56,929 --> 00:00:59,839
会上课我的博士 学生们

21
00:00:59,839 --> 00:01:01,699
将照管这些课程，

22
00:01:01,699 --> 00:01:02,839
然后在下周一我们将再招

23
00:01:02,839 --> 00:01:04,309
一名 PG 学生，然后我们将

24
00:01:04,309 --> 00:01:07,580
在 10 月 30 日没有课，然后

25
00:01:07,580 --> 00:01:11,060
时间表正确地反映了这一点，所以

26
00:01:11,060 --> 00:01:13,490
任何关于这方面的问题和 这

27
00:01:13,490 --> 00:01:15,680
将与 我的管理员

28
00:01:15,680 --> 00:01:18,650
关于在她的办公室进行所有期中考试

29
00:01:18,650 --> 00:01:20,119
，然后我们会想出一些

30
00:01:20,119 --> 00:01:21,770
时间你会去她的办公室

31
00:01:21,770 --> 00:01:24,049
再次检查你的期中考试只需

32
00:01:24,049 --> 00:01:25,549
带上你的学生证，这样她就知道

33
00:01:25,549 --> 00:01:29,360
你是谁，然后如果 你有，如果你

34
00:01:29,360 --> 00:01:31,250
想要一些重新评分的照片，你

35
00:01:31,250 --> 00:01:32,509
不能带着你的期中考试，只需

36
00:01:32,509 --> 00:01:33,470
在你想要我创建的页面上拍一张照片，

37
00:01:33,470 --> 00:01:36,200
然后给我发电子邮件，我们会

38
00:01:36,200 --> 00:01:40,759
处理好的，所以我们现在就

39
00:01:40,759 --> 00:01:42,770
在 当然，我们已经涵盖了

40
00:01:42,770 --> 00:01:45,200
整个堆栈 我们已经涵盖了如何

41
00:01:45,200 --> 00:01:47,270
在磁盘上存储东西 我们涵盖了如何将

42
00:01:47,270 --> 00:01:49,340
东西放入一个可能的访问方法

43
00:01:49,340 --> 00:01:51,649
扫描如何执行运算符以及

44
00:01:51,649 --> 00:01:54,110
如何进行查询计划 所以现在我们要

45
00:01:54,110 --> 00:01:55,399
实际上可以看看接下来的

46
00:01:55,399 --> 00:01:57,380
四个星期我们要回去重新

47
00:01:57,380 --> 00:01:58,640
审视整个

48
00:01:58,640 --> 00:02:02,210
架构 现在考虑两个重要的

49
00:02:02,210 --> 00:02:04,159
组件并发控制和

50
00:02:04,159 --> 00:02:06,920
恢复 这些概念实际上

51
00:02:06,920 --> 00:02:08,869
渗透到整个

52
00:02:08,869 --> 00:02:10,880
系统中 我们有点需要理解 这  

53
00:02:10,880 --> 00:02:12,170
首先是基础知识，这就是为什么我们

54
00:02:12,170 --> 00:02:13,610
在没有讨论任何这些事情的情况下进行了讨论

55
00:02:13,610 --> 00:02:15,530
，现在我们要回过头来

56
00:02:15,530 --> 00:02:17,599
看看我们如何不知道您

57
00:02:17,599 --> 00:02:18,860
是否要强制执行 concur 作弊或

58
00:02:18,860 --> 00:02:20,090
确保我们的数据库可以安全地存储在

59
00:02:20,090 --> 00:02:20,780
磁盘上

60
00:02:20,780 --> 00:02:23,180
如何 我们是否确保我们已经

61
00:02:23,180 --> 00:02:24,410
修改了我们已经讨论过的内容

62
00:02:24,410 --> 00:02:26,270
以解释这些事情并

63
00:02:26,270 --> 00:02:26,810
处理它，

64
00:02:26,810 --> 00:02:29,560
所以再次勇气呼叫和恢复

65
00:02:29,560 --> 00:02:31,730
是您所知道的一切，它们不应该是

66
00:02:31,730 --> 00:02:33,140
单独的事情，并带有

67
00:02:33,140 --> 00:02:35,750
问题管理器或索引 整个

68
00:02:35,750 --> 00:02:37,730
系统需要你知道它

69
00:02:37,730 --> 00:02:40,070
是如何持久的 事务将如何

70
00:02:40,070 --> 00:02:41,840
安全地运行，

71
00:02:41,840 --> 00:02:42,830
这就是我们要去的原因 我们将

72
00:02:42,830 --> 00:02:46,280
在下半

73
00:02:46,280 --> 00:02:48,650
学期讨论这个问题 我还要说，一旦我们

74
00:02:48,650 --> 00:02:50,480
有了这两件事，你就可以

75
00:02:50,480 --> 00:02:51,530
离开世界并建立自己的

76
00:02:51,530 --> 00:02:53,060
数据库系统，但这是

77
00:02:53,060 --> 00:02:54,860
我们实际构建一个

78
00:02:54,860 --> 00:02:56,780
可以正确运行事务的反病毒系统所需的最后两件事

79
00:02:56,780 --> 00:02:58,670
，并确保每个 事情

80
00:02:58,670 --> 00:03:02,600
是安全的，所以我们快到了，所以为了

81
00:03:02,600 --> 00:03:04,430
激发我们为什么要谈论

82
00:03:04,430 --> 00:03:06,770
关于恢复的菊池让我们看两个

83
00:03:06,770 --> 00:03:09,920
简单的场景，假设我

84
00:03:09,920 --> 00:03:12,950
有一个应用程序，我想让

85
00:03:12,950 --> 00:03:14,989
两个线程尝试更新相同的

86
00:03:14,989 --> 00:03:17,390
记录 同一张桌子在完全相同的

87
00:03:17,390 --> 00:03:20,420
时间如何做出如何

88
00:03:20,420 --> 00:03:21,530
决定你应该

89
00:03:21,530 --> 00:03:22,970
成功的决定应该是我们的最终

90
00:03:22,970 --> 00:03:24,590
更改这里有一个竞争条件

91
00:03:24,590 --> 00:03:26,390
我想在另一个之前稍微有点

92
00:03:26,390 --> 00:03:30,260
另一种情况是

93
00:03:30,260 --> 00:03:31,820
让我们 假设我有一个

94
00:03:31,820 --> 00:03:34,820
针对我的银行的申请，我

95
00:03:34,820 --> 00:03:36,470
想从我的帐户中转出一百美元

96
00:03:36,470 --> 00:03:39,170
到您的帐户中，但假设

97
00:03:39,170 --> 00:03:40,910
您知道在我

98
00:03:40,910 --> 00:03:42,560
从我的帐户中取出钱之后但在

99
00:03:42,560 --> 00:03:44,840
我将其存入之前您知道 您的帐户

100
00:03:44,840 --> 00:03:46,280
建筑物 数据中心 被

101
00:03:46,280 --> 00:03:49,100
闪电击中 失去所有电源 我们的

102
00:03:49,100 --> 00:03:50,450
机器崩溃或数据库系统

103
00:03:50,450 --> 00:03:53,450
崩溃 所以当我们回来

104
00:03:53,450 --> 00:03:55,730
时，数据库的正确状态应该是什么，但

105
00:03:55,730 --> 00:04:00,079
我们实际应该做什么 你明白了

106
00:04:00,079 --> 00:04:02,239
，我在这里谈论的第一个问题

107
00:04:02,239 --> 00:04:04,370
是更新丢失的一个例子，

108
00:04:04,370 --> 00:04:07,160
或者我有两个事务，两个

109
00:04:07,160 --> 00:04:08,570
线程试图同时更新

110
00:04:08,570 --> 00:04:10,549
同一个我

111
00:04:10,549 --> 00:04:13,100
无法结束 完全错过了如何

112
00:04:13,100 --> 00:04:14,420
确保这不会发生以及

113
00:04:14,420 --> 00:04:16,279
我们将使用的方式确保这些

114
00:04:16,279 --> 00:04:18,620
事情正确发生是通过

115
00:04:18,620 --> 00:04:21,769
concur 工具机制发生的笔画

116
00:04:21,769 --> 00:04:24,290
协议，用于第二种情况，即

117
00:04:24,290 --> 00:04:27,290
我的机器 Meador 我的数据中心赶上

118
00:04:27,290 --> 00:04:30,229
了 火灾，我你知道我断电

119
00:04:30,229 --> 00:04:32,660
，我的机器崩溃了我们将使用

120
00:04:32,660 --> 00:04:33,810


121
00:04:33,810 --> 00:04:35,040
数据库系统中的恢复机制来确保

122
00:04:35,040 --> 00:04:39,570
持久性，因此控制和持久性这两个成本

123
00:04:39,570 --> 00:04:41,580


124
00:04:41,580 --> 00:04:44,040
是数据库管理系统的主要卖点之一，

125
00:04:44,040 --> 00:04:46,230
这是 为什么如果你正在构建一个

126
00:04:46,230 --> 00:04:47,820
应用程序，无论它是在云中

127
00:04:47,820 --> 00:04:52,080
、手机上还是桌面上，你

128
00:04:52,080 --> 00:04:53,340
都不希望

129
00:04:53,340 --> 00:04:55,050
自己在应用程序中做这些事情，

130
00:04:55,050 --> 00:04:56,310
因为你可能

131
00:04:56,310 --> 00:04:57,990
会得到它 ong，您可能会

132
00:04:57,990 --> 00:05:00,210
丢失数据或拥有不正确的数据，这

133
00:05:00,210 --> 00:05:01,770
就是您想要使用数据互联网

134
00:05:01,770 --> 00:05:03,270
系统的原因，因为他们可以拥有

135
00:05:03,270 --> 00:05:04,200
非常聪明的人，他们

136
00:05:04,200 --> 00:05:05,850
花了很多时间来确保

137
00:05:05,850 --> 00:05:08,580
这些事情正确发生，如果您

138
00:05:08,580 --> 00:05:09,810
也 想一想，如果你是

139
00:05:09,810 --> 00:05:13,140
一家初创公司，你知道如果你正在发布

140
00:05:13,140 --> 00:05:15,060
一个应用程序，那

141
00:05:15,060 --> 00:05:16,470
没关系你知道一天结束的

142
00:05:16,470 --> 00:05:18,000
事情是什么不会销售你的

143
00:05:18,000 --> 00:05:20,520
产品是哦，我可以，我可以恢复

144
00:05:20,520 --> 00:05:22,650
崩溃后的数据库，您需要将

145
00:05:22,650 --> 00:05:24,210
其作为您绝对必须拥有的功能，

146
00:05:24,210 --> 00:05:26,100
但这并不是

147
00:05:26,100 --> 00:05:28,169
您的应用程序与

148
00:05:28,169 --> 00:05:30,660
竞争对手的差异化方面，所以

149
00:05:30,660 --> 00:05:32,130
如果您不想要任何

150
00:05:32,130 --> 00:05:33,570
编写数据库的业务，您就不想获得 离你自己一分钟，

151
00:05:33,570 --> 00:05:36,150
除非那是你的工作，其他

152
00:05:36,150 --> 00:05:36,450


153
00:05:36,450 --> 00:05:38,760
人应该依赖你知道

154
00:05:38,760 --> 00:05:40,229
高质量的软件大卫系统软件

155
00:05:40,229 --> 00:05:42,630
经过审查可以做这些

156
00:05:42,630 --> 00:05:46,350
事情所以我们

157
00:05:46,350 --> 00:05:48,660
将在下一个阶段使用的核心概念

158
00:05:48,660 --> 00:05:50,910
你几周讨论这些你知道

159
00:05:50,910 --> 00:05:52,979
运行我们的系统以确保事情

160
00:05:52,979 --> 00:05:54,390
以正确的顺序运行或

161
00:05:54,390 --> 00:05:56,669
运行以确保我们所有的更改都如此

162
00:05:56,669 --> 00:05:59,039
持久是交易的想法

163
00:05:59,039 --> 00:06:00,810
将与资产

164
00:06:00,810 --> 00:06:03,240
担保或资产属性一起运行所以

165
00:06:03,240 --> 00:06:04,140
有 快速举手谁在

166
00:06:04,140 --> 00:06:06,169
这里听说过首字母缩略词资产

167
00:06:06,169 --> 00:06:07,320
好吧

168
00:06:07,320 --> 00:06:10,800
大约一半 好的 所以我们将介绍这一点 所以

169
00:06:10,800 --> 00:06:12,270
在我们可以出售资产之前 让我们

170
00:06:12,270 --> 00:06:15,210
谈谈今天的交易在我们的

171
00:06:15,210 --> 00:06:17,400
世界中是什么 如果我们谈论 在本

172
00:06:17,400 --> 00:06:19,950
讲座中，事务将是

173
00:06:19,950 --> 00:06:23,460
在数据库系统上执行一系列操作

174
00:06:23,460 --> 00:06:25,229
，然后再执行一些

175
00:06:25,229 --> 00:06:27,810
更高级别的功能，因此

176
00:06:27,810 --> 00:06:29,070
您可以将这些操作

177
00:06:29,070 --> 00:06:30,630
视为后续查询或

178
00:06:30,630 --> 00:06:33,650
我们正在执行的读取和写入操作 数据库

179
00:06:33,650 --> 00:06:36,000
和更高级别的功能我的意思

180
00:06:36,000 --> 00:06:39,360
是像声誉一样的东西你知道

181
00:06:39,360 --> 00:06:41,820
一些我们希望我们的

182
00:06:41,820 --> 00:06:44,729
应用程序执行的步骤

183
00:06:44,729 --> 00:06:46,650
将资金从我的帐户转移到你的

184
00:06:46,650 --> 00:06:48,300
帐户 d 是一个高级

185
00:06:48,300 --> 00:06:50,819
函数，因为它是我们应用程序中事务中的辅助程序，

186
00:06:50,819 --> 00:06:53,129


187
00:06:53,129 --> 00:06:54,900
没有数据库系统会具有

188
00:06:54,900 --> 00:06:56,279
该功能，就像单个

189
00:06:56,279 --> 00:06:58,860
函数不能调用任何移动资金，这

190
00:06:58,860 --> 00:06:59,849
是您将在上面的应用程序中编写的内容，

191
00:06:59,849 --> 00:07:03,479
因此事务是

192
00:07:03,479 --> 00:07:05,249
将成为我们数据库管理系统中更改的基本单位，

193
00:07:05,249 --> 00:07:06,930
这意味着

194
00:07:06,930 --> 00:07:09,449
所有更改都将

195
00:07:09,449 --> 00:07:12,059
如何发生在事务的包装内，

196
00:07:12,059 --> 00:07:14,729
无论是

197
00:07:14,729 --> 00:07:16,680
多个查询还是单个查询，它

198
00:07:16,680 --> 00:07:18,710
始终将是一个 交易 我

199
00:07:18,710 --> 00:07:21,599
想你可以有一个零查询

200
00:07:21,599 --> 00:07:22,740
交易，但这并不意味着

201
00:07:22,740 --> 00:07:24,960
什么是正确的，但假设

202
00:07:24,960 --> 00:07:26,939
它是我们想要做的一个或多个操作

203
00:07:26,939 --> 00:07:29,520
，所以关于交易的关键概念

204
00:07:29,520 --> 00:07:31,289
是我们不会

205
00:07:31,289 --> 00:07:33,419
允许 部分事务，其中

206
00:07:33,419 --> 00:07:34,469
事务总是

207
00:07:34,469 --> 00:07:34,919
原子的，

208
00:07:34,919 --> 00:07:37,620
但这意味着如果我有

209
00:07:37,620 --> 00:07:39,930
五个更新的序列，我想要么所有

210
00:07:39,930 --> 00:07:43,620
五个都发生要么都不发生 发生我不能

211
00:07:43,620 --> 00:07:44,909
让你知道一些像你知道的可能

212
00:07:44,909 --> 00:07:46,379
五个中的前三个

213
00:07:46,379 --> 00:07:48,899
和另外两个失败了它要么全部

214
00:07:48,899 --> 00:07:51,360
要么没有，即使你有一个单一的

215
00:07:51,360 --> 00:07:52,800
查询事务，一个单一的操作

216
00:07:52,800 --> 00:07:54,930
事务说我有一个更新查询

217
00:07:54,930 --> 00:07:57,060
将五个更新到池中

218
00:07:57,060 --> 00:07:59,339
仍然是一个查询，但在此期间我没有

219
00:07:59,339 --> 00:08:02,069
得到五件事，所有五个都必须

220
00:08:02,069 --> 00:08:06,449
更新，而不是其中的某个子集，

221
00:08:06,449 --> 00:08:08,189
因此事务示例将

222
00:08:08,189 --> 00:08:09,990
是我在工作之前谈到的那个，我

223
00:08:09,990 --> 00:08:11,490
想移动 从我的

224
00:08:11,490 --> 00:08:13,229
银行帐户中取出一百美元到我阴暗的发起人

225
00:08:13,229 --> 00:08:15,779
帐户中，因此数据库系统

226
00:08:15,779 --> 00:08:17,309
在我的

227
00:08:17,309 --> 00:08:18,959
应用程序代码中不提供此功能我会编写

228
00:08:18,959 --> 00:08:21,389
正确执行此操作的步骤，因此在

229
00:08:21,389 --> 00:08:23,129
第一步中我会说好

230
00:08:23,129 --> 00:08:24,839
检查印度 有 100 美元，他可能

231
00:08:24,839 --> 00:08:28,229
不写，但是如果我这样做了，那么您

232
00:08:28,229 --> 00:08:29,520
可以从我的帐户中取出 100 美元

233
00:08:29,520 --> 00:08:31,770
，然后再将这 100 美元

234
00:08:31,770 --> 00:08:34,229
放入他的帐户，这些

235
00:08:34,229 --> 00:08:36,029
都是单独的步骤，没有什么神奇之处

236
00:08:36,029 --> 00:08:38,669
只是在最低级别的单个货币中实现货币的方式

237
00:08:38,669 --> 00:08:40,318
港口

238
00:08:40,318 --> 00:08:42,089
自动同时更新某事和

239
00:08:42,089 --> 00:08:44,670
另一件事

240
00:08:44,670 --> 00:08:45,600
好吧，我们必须做很多额外的事情

241
00:08:45,600 --> 00:08:46,740
来确保这

242
00:08:46,740 --> 00:08:49,019
以原子方式发生，但来自

243
00:08:49,019 --> 00:08:51,300
应用程序 从你的角度来看，你知道他们

244
00:08:51,300 --> 00:08:52,769
投票这个交易，这一切都会

245
00:08:52,769 --> 00:08:55,670
发生，或者什么都不发生，

246
00:08:55,670 --> 00:08:57,920
所以让我们谈谈

247
00:08:57,920 --> 00:08:59,450
我们可以构建的一个非常简单的数据库系统，

248
00:08:59,450 --> 00:09:02,410
它可以为我们做这件事，

249
00:09:02,410 --> 00:09:04,460
假设我们有一个数据库系统

250
00:09:04,460 --> 00:09:07,150
，它只支持 单线程

251
00:09:07,150 --> 00:09:09,530
意味着一次只能运行一个事务和

252
00:09:09,530 --> 00:09:12,160
一个查询，并且

253
00:09:12,160 --> 00:09:14,480
您知道如果多个查询是

254
00:09:14,480 --> 00:09:15,470
多个事务出现在

255
00:09:15,470 --> 00:09:17,210
系统中，它只是将它们放在一个队列中，并且

256
00:09:17,210 --> 00:09:18,860
有一个线程从

257
00:09:18,860 --> 00:09:20,560
该队列中取出事物并运行它们一个

258
00:09:20,560 --> 00:09:23,000
在事务开始

259
00:09:23,000 --> 00:09:25,250
执行之前，他们要做的是

260
00:09:25,250 --> 00:09:26,660
复制整个数据库

261
00:09:26,660 --> 00:09:29,330
文件或一组文件，但它的架构是什么

262
00:09:29,330 --> 00:09:31,490
d 它将制作数据库的第二个

263
00:09:31,490 --> 00:09:33,920
副本 对该副本进行所有

264
00:09:33,920 --> 00:09:35,600
想要进行的更改

265
00:09:35,600 --> 00:09:38,180
，然后如果它成功并且我们想要

266
00:09:38,180 --> 00:09:40,340
保存所有更改，那么我们只需翻转一个

267
00:09:40,340 --> 00:09:42,170
指针来说明现在数据库的新版本

268
00:09:42,170 --> 00:09:44,690
是 是我刚刚创建的第二个文件，

269
00:09:44,690 --> 00:09:47,420
所以这

270
00:09:47,420 --> 00:09:49,340
保证了 Adam 被

271
00:09:49,340 --> 00:09:52,070
传播，因为如果我将副本复制

272
00:09:52,070 --> 00:09:54,740
到数据库，然后我进行了五次

273
00:09:54,740 --> 00:09:56,660
写入，但是前三个发生了

274
00:09:56,660 --> 00:09:58,850
，然后我来时崩溃了 回来我

275
00:09:58,850 --> 00:10:00,290
仍然有我的

276
00:10:00,290 --> 00:10:01,730
数据库的原始副本因为我没有影响我

277
00:10:01,730 --> 00:10:03,590
说过你知道所以一切

278
00:10:03,590 --> 00:10:06,500
仍然正确那里很好的东西

279
00:10:06,500 --> 00:10:09,020
正在写入磁盘所以如果我崩溃

280
00:10:09,020 --> 00:10:10,610
我可以回来而那些我的磁盘

281
00:10:10,610 --> 00:10:14,530
没有' 我所有的数据都还在那里，所以

282
00:10:14,530 --> 00:10:18,140
这真的有效吗他说是的

283
00:10:18,140 --> 00:10:23,960
，这会很快吗说不，你

284
00:10:23,960 --> 00:10:34,670
说不，为什么如果对呃有什么事情请

285
00:10:34,670 --> 00:10:36,260


286
00:10:36,260 --> 00:10:38,510
不要紧，我正在做的事情更新的数量 在我的

287
00:10:38,510 --> 00:10:39,590
交易中这无关紧要，因为

288
00:10:39,590 --> 00:10:40,970
我每次都

289
00:10:40,970 --> 00:10:43,340
复制文件，所以我复制整个文件并进行一次

290
00:10:43,340 --> 00:10:45,140
更改，而不是一千次更改，

291
00:10:45,140 --> 00:10:47,240
例如复制成本始终相同，但

292
00:10:47,240 --> 00:10:48,680
您是对的时钟，如果复制部分

293
00:10:48,680 --> 00:10:51,050
是 1 KB 或

294
00:10:51,050 --> 00:10:53,540
开始 我的数据库需要 4 KB 的页面，

295
00:10:53,540 --> 00:10:55,370
谁在乎它是一个硬件

296
00:10:55,370 --> 00:10:56,660
读写我可以很快完成，

297
00:10:56,660 --> 00:10:58,430
但是如果我现在每笔交易都有 1 PB 的

298
00:10:58,430 --> 00:11:00,290
数据，

299
00:11:00,290 --> 00:11:02,120
我每次进行更改时都会减少 1 PB 的数据

300
00:11:02,120 --> 00:11:05,570
，然后

301
00:11:05,570 --> 00:11:09,080
更新 指针所以这是一个很好的例子

302
00:11:09,080 --> 00:11:09,500
，我们

303
00:11:09,500 --> 00:11:11,390
设计的系统具有

304
00:11:11,390 --> 00:11:12,590
我们想要的特性，特别

305
00:11:12,590 --> 00:11:14,300
是我们将要讨论的酸性特性，

306
00:11:14,300 --> 00:11:16,880
但是这样做会非常慢，

307
00:11:16,880 --> 00:11:19,130
另一个问题是我们'

308
00:11:19,130 --> 00:11:21,740
也使用单线程运行，所以我

309
00:11:21,740 --> 00:11:23,030
没有说

310
00:11:23,030 --> 00:11:24,740
数据库是否适合内存，

311
00:11:24,740 --> 00:11:26,480
所以现在如果我使用

312
00:11:26,480 --> 00:11:28,100
单线程运行并尝试触摸

313
00:11:28,100 --> 00:11:29,870
不在内存中但在磁盘中的数据 我

314
00:11:29,870 --> 00:11:32,120
必须 容忍我的线程，直到我去取

315
00:11:32,120 --> 00:11:34,280
它为止，我不能运行其他任何东西，因为

316
00:11:34,280 --> 00:11:35,300
我一次只有一个线程可以执行

317
00:11:35,300 --> 00:11:38,630
此操作，所以我们将在

318
00:11:38,630 --> 00:11:40,970
今天和接下来的

319
00:11:40,970 --> 00:11:43,970
几周内讨论可能是更好的方法

320
00:11:43,970 --> 00:11:45,410
我们将允许事务

321
00:11:45,410 --> 00:11:49,160
在同一时间同时运行

322
00:11:49,160 --> 00:11:51,020
，然后我们将想出一种方法

323
00:11:51,020 --> 00:11:52,730
来尝试以

324
00:11:52,730 --> 00:11:56,180


325
00:11:56,180 --> 00:11:58,460
最大化并行性但仍然获得

326
00:11:58,460 --> 00:12:00,410
所有 安全性保证他们想要的

327
00:12:00,410 --> 00:12:01,700
，正确性保证我们想要

328
00:12:01,700 --> 00:12:04,490
在我们的数据库系统中正确，

329
00:12:04,490 --> 00:12:06,170
而且很明显我们为什么要这样做，

330
00:12:06,170 --> 00:12:07,430
因为我们之前讨论过两个，当

331
00:12:07,430 --> 00:12:09,080
我们讨论闩锁时，我们讨论了

332
00:12:09,080 --> 00:12:12,710
查询执行，如果我们可以获得我们可以

333
00:12:12,710 --> 00:12:13,970
允许多个 同时运行的查询，

334
00:12:13,970 --> 00:12:15,620
我们将更好地

335
00:12:15,620 --> 00:12:17,089
利用我们的硬件 更好的

336
00:12:17,089 --> 00:12:18,800
吞吐量意味着我们可以

337
00:12:18,800 --> 00:12:21,560
在相同的时间内完成更多的工作，

338
00:12:21,560 --> 00:12:23,600
然后系统看起来会更加响应

339
00:12:23,600 --> 00:12:25,640
和活泼，因为 现在使用我不必

340
00:12:25,640 --> 00:12:27,740
在单个队列中等待直到我的

341
00:12:27,740 --> 00:12:29,960
快速事务到达前面

342
00:12:29,960 --> 00:12:31,970
然后我可以运行我可能会立即开始

343
00:12:31,970 --> 00:12:35,420
运行但现在克里斯汀

344
00:12:35,420 --> 00:12:37,040
棘手的事情是

345
00:12:37,040 --> 00:12:39,620
我们实际上如何 这样做交织你

346
00:12:39,620 --> 00:12:41,030
知道这样一种方式，我们不会

347
00:12:41,030 --> 00:12:42,770
违反我们系统的任何更好的正确性保证，

348
00:12:42,770 --> 00:12:44,900
并且我们不会

349
00:12:44,900 --> 00:12:48,920
因为获取所有资源而使你知道的任何一个事务饿死

350
00:12:48,920 --> 00:12:50,450
，而其他事务

351
00:12:50,450 --> 00:12:53,540
不能做任何事情，所以并发reto

352
00:12:53,540 --> 00:12:56,000
我们今天谈论的是一个

353
00:12:56,000 --> 00:12:57,800
可以追溯到 1970 年代的旧概念哦，

354
00:12:57,800 --> 00:13:00,110
当我 BM 构建系统 R 时，这是

355
00:13:00,110 --> 00:13:02,180
他们也发明的第一件事，

356
00:13:02,180 --> 00:13:06,589
所以在基于磁盘的系统中

357
00:13:06,589 --> 00:13:09,230
当然是因为内存是 有限，并且

358
00:13:09,230 --> 00:13:10,640
任何时候它实际上都可能

359
00:13:10,640 --> 00:13:12,230
触及磁盘和

360
00:13:12,230 --> 00:13:14,240
内存上的数据，因此它会停止，

361
00:13:14,240 --> 00:13:15,440
然后现在您可以让其他事务

362
00:13:15,440 --> 00:13:17,720
在今天的现代系统中同时运行，

363
00:13:17,720 --> 00:13:20,510
通常所有它都是

364
00:13:20,510 --> 00:13:22,190
应用程序 ns它们不是那么大

365
00:13:22,190 --> 00:13:23,330
数据库也不是那么大

366
00:13:23,330 --> 00:13:25,070
所以我们有足够的内存可以

367
00:13:25,070 --> 00:13:27,380
将整个数据库放在内存中进行

368
00:13:27,380 --> 00:13:29,000
分析你仍然会去磁盘但是

369
00:13:29,000 --> 00:13:31,850
我们没有在那里进行交易所以

370
00:13:31,850 --> 00:13:34,339
在现代系统中最 大多数终极

371
00:13:34,339 --> 00:13:37,250
数据库都可以容纳内存，但现在英特尔

372
00:13:37,250 --> 00:13:39,380
为我们提供了越来越多的内核，所以

373
00:13:39,380 --> 00:13:40,640
现在我们将允许同时在

374
00:13:40,640 --> 00:13:42,019
不同内核中进行交易，

375
00:13:42,019 --> 00:13:43,519
然后我们仍然需要保证所有

376
00:13:43,519 --> 00:13:46,399
这些事情，因此即使

377
00:13:46,399 --> 00:13:47,750
硬件与 当人们第一次

378
00:13:47,750 --> 00:13:48,829
发明炊具时

379
00:13:48,829 --> 00:13:50,570
，我们仍然有同样的问题，所以

380
00:13:50,570 --> 00:13:52,000
你仍然想要最大化并行性

381
00:13:52,000 --> 00:13:55,040
，正如我已经说过几次，

382
00:13:55,040 --> 00:13:56,990
这真的很难做到，

383
00:13:56,990 --> 00:13:58,880
正如我上节课所说，这可能是

384
00:13:58,880 --> 00:14:00,470
数据库系统中第二个最难做的事情是进行

385
00:14:00,470 --> 00:14:02,410
并发控制

386
00:14:02,410 --> 00:14:04,190
，这就是为什么

387
00:14:04,190 --> 00:14:05,810
nocebo 人在十年前第一次出现时

388
00:14:05,810 --> 00:14:07,730
他们就像我们不做

389
00:14:07,730 --> 00:14:09,470
交易一样，这也是原因之一 很难，

390
00:14:09,470 --> 00:14:13,100
因为他们想跑得更快，所以

391
00:14:13,100 --> 00:14:14,480
我们很难保证

392
00:14:14,480 --> 00:14:17,149
哪些交易是正确的，

393
00:14:17,149 --> 00:14:19,430
所以如果我的银行账户里有 100 美元会发生什么

394
00:14:19,430 --> 00:14:21,620
，我试图

395
00:14:21,620 --> 00:14:23,450
在完全相同的时间给人们钱

396
00:14:23,450 --> 00:14:25,579
会发生什么 因为我不想让

397
00:14:25,579 --> 00:14:27,200
你知道假设银行不会

398
00:14:27,200 --> 00:14:29,480
让我透支我你知道

399
00:14:29,480 --> 00:14:30,470
我不想发放

400
00:14:30,470 --> 00:14:32,959
我实际上没有的钱然后也

401
00:14:32,959 --> 00:14:34,160
很难非常有效地执行这个

402
00:14:34,160 --> 00:14:36,860
因为再次如果 我做

403
00:14:36,860 --> 00:14:38,000
了我

404
00:14:38,000 --> 00:14:39,350
在开始时谈到的串行执行案例然后这

405
00:14:39,350 --> 00:14:40,940
总是正确的，因为一次只有一个

406
00:14:40,940 --> 00:14:42,320
事务在运行，

407
00:14:42,320 --> 00:14:43,730
然后有多少担心任何

408
00:14:43,730 --> 00:14:45,649
交错，但现在我确实想

409
00:14:45,649 --> 00:14:47,240
交错它们，

410
00:14:47,240 --> 00:14:48,740
我想打赌 尽可能高效

411
00:14:48,740 --> 00:14:49,940
地弄清楚我

412
00:14:49,940 --> 00:14:52,399
是否仍然正确运行我只是

413
00:14:52,399 --> 00:14:53,510
有一些开销来弄清楚这些

414
00:14:53,510 --> 00:14:57,829
事情所以我们

415
00:14:57,829 --> 00:14:59,420
今天和接下来的三个基本上要做什么

416
00:14:59,420 --> 00:15:01,390
让三 一或四节课

417
00:15:01,390 --> 00:15:03,680
允许对事务的操作进行这些交织

418
00:15:03,680 --> 00:15:06,560
，

419
00:15:06,560 --> 00:15:08,180
正如我们所看到的，当我们开始进行

420
00:15:08,180 --> 00:15:09,529
这些交织时，我们最终会得到

421
00:15:09,529 --> 00:15:13,040
不一致的数据库，有时

422
00:15:13,040 --> 00:15:15,130
可以，有时不行，

423
00:15:15,130 --> 00:15:18,410
所以有些不一致是可以的，

424
00:15:18,410 --> 00:15:20,810
因为它们 是暂时的，例如，

425
00:15:20,810 --> 00:15:21,829
如果我从我的帐户中取钱，

426
00:15:21,829 --> 00:15:24,410
再次放入您的帐户，我无法

427
00:15:24,410 --> 00:15:26,029
在哈佛级别以原子

428
00:15:26,029 --> 00:15:27,470
方式执行此操作，我必须这样做，因为您知道多个

429
00:15:27,470 --> 00:15:29,720
指令或多个操作，因此

430
00:15:29,720 --> 00:15:32,120
会有

431
00:15:32,120 --> 00:15:34,070
我从我的账户中取出 100 美元的短暂时间

432
00:15:34,070 --> 00:15:36,320
，然后在我把它

433
00:15:36,320 --> 00:15:37,010
存入你的账户

434
00:15:37,010 --> 00:15:38,930
之前 100 美元它在

435
00:15:38,930 --> 00:15:42,110
任何地方都不存在，所以没关系，因为这是

436
00:15:42,110 --> 00:15:44,329
暂时的，这是不可避免的

437
00:15:44,329 --> 00:15:46,040
外界不会看到可能不会看到

438
00:15:46,040 --> 00:15:47,690
不一致，我们会做一些

439
00:15:47,690 --> 00:15:48,829
保护机制，确保

440
00:15:48,829 --> 00:15:52,370
他们看不到这个，所以

441
00:15:52,370 --> 00:15:53,870
因为我们要允许这个，这

442
00:15:53,870 --> 00:15:55,089
实际上会持续下去 让这一切都奏效，

443
00:15:55,089 --> 00:15:57,050
但我们想要避免的事情或

444
00:15:57,050 --> 00:15:59,600
永久性的不一致，如果

445
00:15:59,600 --> 00:16:00,800
我再次拿出一百美元然后

446
00:16:00,800 --> 00:16:02,630
我崩溃然后我回来那一百

447
00:16:02,630 --> 00:16:04,220
美元最好不要

448
00:16:04,220 --> 00:16:05,870
错过，最好是在其他计数

449
00:16:05,870 --> 00:16:08,620
或 玛雅县它不能就这样消失，

450
00:16:08,620 --> 00:16:11,300
所以为了让我们了解

451
00:16:11,300 --> 00:16:12,649
我们是否在做正确的事情，

452
00:16:12,649 --> 00:16:14,690
是否我们提出的

453
00:16:14,690 --> 00:16:17,240
交错交易

454
00:16:17,240 --> 00:16:19,310
实际上是正确的，我们需要更

455
00:16:19,310 --> 00:16:21,019
正式的定义实际上意味着

456
00:16:21,019 --> 00:16:23,149
什么 是正确的，因为这

457
00:16:23,149 --> 00:16:24,740
对我们来说是显而易见的，是的，如果我从

458
00:16:24,740 --> 00:16:26,269
我的帐户中取出一百美元，然后在

459
00:16:26,269 --> 00:16:28,550
我把它存入你的帐户之前，我们就会崩溃，就像

460
00:16:28,550 --> 00:16:30,110
那种明显的我们知道我们

461
00:16:30,110 --> 00:16:31,160
不想损失一百美元或

462
00:16:31,160 --> 00:16:33,589
任何 金额，但从

463
00:16:33,589 --> 00:16:34,940
数据库系统的角度来看，它不

464
00:16:34,940 --> 00:16:36,290
知道它正在运行 没有钱

465
00:16:36,290 --> 00:16:37,970
只是看到一堆字节并且它正在

466
00:16:37,970 --> 00:16:39,680
移动它们所以我们需要一种方法来

467
00:16:39,680 --> 00:16:41,060
让我们推理我们是否在

468
00:16:41,060 --> 00:16:44,750
做正确的事情 因此，我们首先

469
00:16:44,750 --> 00:16:46,370
需要找出

470
00:16:46,370 --> 00:16:48,829
我们实际执行的这些操作是什么，

471
00:16:48,829 --> 00:16:50,779
正如我所说的，已经

472
00:16:50,779 --> 00:16:56,060
是一个或多个操作的事务宏，但在较高

473
00:16:56,060 --> 00:16:57,889
级别上，应用程序可能是数据库，

474
00:16:57,889 --> 00:17:01,069
您知道更新此插入 进行

475
00:17:01,069 --> 00:17:03,050
这些更改，但从数据库

476
00:17:03,050 --> 00:17:04,490
系统的角度来看，它不

477
00:17:04,490 --> 00:17:06,589
知道那些高级查询，

478
00:17:06,589 --> 00:17:07,730
它只知道我正在执行低级

479
00:17:07,730 --> 00:17:11,299
读取和写入，

480
00:17:11,299 --> 00:17:12,589
因此我们唯一可以推理的是

481
00:17:12,589 --> 00:17:15,619
发生在我们数据库上的事情

482
00:17:15,619 --> 00:17:17,390
意味着，如果它们是我们的事务，则

483
00:17:17,390 --> 00:17:20,059
涉及额外的步骤、程序

484
00:17:20,059 --> 00:17:22,699
或操作，这些步骤或程序或操作不是

485
00:17:22,699 --> 00:17:25,189
对数据库进行读写操作，这超出

486
00:17:25,189 --> 00:17:26,630
了我们的权限，这超出了我们的控制范围

487
00:17:26,630 --> 00:17:30,799
，我们无能为力

488
00:17:30,799 --> 00:17:32,179
举个例子，假设我

489
00:17:32,179 --> 00:17:33,410
要从我的账户中取出一百美元，

490
00:17:33,410 --> 00:17:36,020
我把它存入你的账户，然后我

491
00:17:36,020 --> 00:17:38,390
给你发送一封电子邮件，说转账

492
00:17:38,390 --> 00:17:40,429
成功，我们希望这

493
00:17:40,429 --> 00:17:42,679
发生在 tr  ansaction 但是

494
00:17:42,679 --> 00:17:44,330
在我可以提交并保存我的

495
00:17:44,330 --> 00:17:48,559
更改之前发生了崩溃所以我已经发送了

496
00:17:48,559 --> 00:17:50,330
电子邮件但是然后我在

497
00:17:50,330 --> 00:17:52,520
保存所有更改之前崩溃了电子邮件

498
00:17:52,520 --> 00:17:54,440
在网络上上升它在

499
00:17:54,440 --> 00:17:55,940
数据库之外现在它在数据库中消失了 在现实

500
00:17:55,940 --> 00:17:59,360
世界中，我们无法撤回它，因此我们

501
00:17:59,360 --> 00:18:01,340
只能推理和回滚，

502
00:18:01,340 --> 00:18:03,290
并且，如果我们向您调用外部系统或其他类似的东西，那么这些

503
00:18:03,290 --> 00:18:04,340
低级读取和写入我们的

504
00:18:04,340 --> 00:18:06,470
数据库的内容就会持久化

505
00:18:06,470 --> 00:18:09,050


506
00:18:09,050 --> 00:18:11,660
这超出了我们的能力 没有系统可以

507
00:18:11,660 --> 00:18:14,450
处理至少到目前为止我们在这里讨论的问题

508
00:18:14,450 --> 00:18:19,880
好吧，所以

509
00:18:19,880 --> 00:18:21,550
今天要担心的数据库

510
00:18:21,550 --> 00:18:25,330
将被定义为一组固定的

511
00:18:25,330 --> 00:18:28,280
任意数据对象，每个对象

512
00:18:28,280 --> 00:18:30,890
都将拥有 一个标签或一个名称，所以在

513
00:18:30,890 --> 00:18:32,330
这种情况下，我们将只使用 ABCD，但

514
00:18:32,330 --> 00:18:35,930
我们将只使用字母字符，因此

515
00:18:35,930 --> 00:18:37,790
这里要指出的两个新事物是

516
00:18:37,790 --> 00:18:39,590
一个我没有定义数据库

517
00:18:39,590 --> 00:18:42,410
对象是什么，它可以是一个属性 它

518
00:18:42,410 --> 00:18:43,910
可能是一个元组可能是一个页面可能

519
00:18:43,910 --> 00:18:45,590
是一个 table 可能是一个数据库它

520
00:18:45,590 --> 00:18:47,600
并不重要

521
00:18:47,600 --> 00:18:48,890
我们今天要讨论的所有相同的事情，对于接下来的

522
00:18:48,890 --> 00:18:51,350
几个类，它们

523
00:18:51,350 --> 00:18:54,010
在实践中仍然在不同的粒度上

524
00:18:54,010 --> 00:18:56,300
工作，大多数时候它将

525
00:18:56,300 --> 00:18:59,060
基于一个 take 在元组上，但我们会看到

526
00:18:59,060 --> 00:19:00,710
在某些情况下，您可以使用锁，您可以

527
00:19:00,710 --> 00:19:02,990
尝试保护数据库和表

528
00:19:02,990 --> 00:19:05,150
没有人行使保护

529
00:19:05,150 --> 00:19:08,660
变得太昂贵的单个字段

530
00:19:08,660 --> 00:19:09,890
另外要指出的另一件事是我

531
00:19:09,890 --> 00:19:13,070
说数据库是 一个固定的大小，

532
00:19:13,070 --> 00:19:14,510
这意味着我们要做的唯一操作

533
00:19:14,510 --> 00:19:16,700
或读取和写入读取

534
00:19:16,700 --> 00:19:19,790
或更新现有的东西我们

535
00:19:19,790 --> 00:19:21,230
今天不讨论插入我们

536
00:19:21,230 --> 00:19:23,330
不讨论删除戴维斯

537
00:19:23,330 --> 00:19:24,320
总是有相同的数字

538
00:19:24,320 --> 00:19:26,710
因为这会使事情复杂化

539
00:19:26,710 --> 00:19:29,870
，我们将在下周星期一讨论，

540
00:19:29,870 --> 00:19:31,640
所以今天假设我们

541
00:19:31,640 --> 00:19:34,190
总是有相同数量的 X，

542
00:19:34,190 --> 00:19:35,810
所以现在数据库将看到的

543
00:19:35,810 --> 00:19:37,340
只是读取和写入的顺序

544
00:19:37,340 --> 00:19:39,470
操作 在上面的这些名称相反

545
00:19:39,470 --> 00:19:41,390
，所以我们说我们使用

546
00:19:41,390 --> 00:19:42,920
函数 R 进行读取，使用

547
00:19:42,920 --> 00:19:45,230
W 的函数进行读取，因此这是

548
00:19:45,230 --> 00:19:47,690
我们在我们的数据库系统中唯一可以看到的东西，

549
00:19:47,690 --> 00:19:49,190
我们看不到任何其他东西

550
00:19:49,190 --> 00:19:51,530
应用程序

551
00:19:51,530 --> 00:19:53,500
可能正在为事务运行的

552
00:19:53,500 --> 00:19:55,610
程序逻辑，这将限制并行的数量

553
00:19:55,610 --> 00:19:56,630
，我们能够得到，

554
00:19:56,630 --> 00:19:58,670
因为我们不了解主要

555
00:19:58,670 --> 00:20:00,470


556
00:20:00,470 --> 00:20:01,700
与事务实际试图

557
00:20:01,700 --> 00:20:04,070
进行的任何某种高级会议 我们会看到一种情况，如果你这样做，

558
00:20:04,070 --> 00:20:06,140
你可以获得更好的并行性，但在

559
00:20:06,140 --> 00:20:08,780
实践中没有人这样做，

560
00:20:08,780 --> 00:20:11,870
我们稍后再谈，所以现在从

561
00:20:11,870 --> 00:20:13,670
实际的角度来看，你如何实际

562
00:20:13,670 --> 00:20:15,170
实现或使用事务、

563
00:20:15,170 --> 00:20:16,540
应用程序和数据库系统

564
00:20:16,540 --> 00:20:19,970
今天，在 seco 标准中，您有这些

565
00:20:19,970 --> 00:20:21,830
额外的关键字 begin commit 和 abort

566
00:20:21,830 --> 00:20:23,750
有些系统使用回滚而不是

567
00:20:23,750 --> 00:20:24,530
abort

568
00:20:24,530 --> 00:20:26,330
我认为明信片是我的 siglo

569
00:20:26,330 --> 00:20:30,020
支持，所以我们将明确地

570
00:20:30,020 --> 00:20:31,730
使用 begin 关键字 a 开始一个新事务

571
00:20:31,730 --> 00:20:34,850
然后发生的事情是我们提出

572
00:20:34,850 --> 00:20:36,350
我们然后执行的任何查询或

573
00:20:36,350 --> 00:20:39,230
该事务的一部分，然后更好地

574
00:20:39,230 --> 00:20:42,620
调用我想提交或中止所以如果

575
00:20:42,620 --> 00:20:44,840
用户说我想提交那么两

576
00:20:44,840 --> 00:20:47,570
件事可能会发生要么事务

577
00:20:47,570 --> 00:20:49,580
确实提交 数据库保存

578
00:20:49,580 --> 00:20:51,380
您所做的所有更改并

579
00:20:51,380 --> 00:20:52,790
在确认中返回是说它们

580
00:20:52,790 --> 00:20:55,670
成功了，或者数据库系统可以

581
00:20:55,670 --> 00:20:59,030
说您实际上无法提交我

582
00:20:59,030 --> 00:21:01,220
不会让您进行这些更改，我

583
00:21:01,220 --> 00:21:02,480
会继续 射击你并中止

584
00:21:02,480 --> 00:21:03,770
你，你有回滚，你

585
00:21:03,770 --> 00:21:05,420
会收到一个通知，你的事务

586
00:21:05,420 --> 00:21:07,940
失败了，所以仅仅因为

587
00:21:07,940 --> 00:21:09,920
应用程序调用 commit 并不意味着

588
00:21:09,920 --> 00:21:12,230
你实际上会再次提交，

589
00:21:12,230 --> 00:21:13,370
这是一个非常重要的概念，我们

590
00:21:13,370 --> 00:21:16,790
以后可以依赖 如果事务

591
00:21:16,790 --> 00:21:19,010
被中止，那么

592
00:21:19,010 --> 00:21:21,230
自从我们调用 begin 以来我们所做的任何更改都将被

593
00:21:21,230 --> 00:21:23,510
回滚，并且看起来好像

594
00:21:23,510 --> 00:21:26,060
事务根本没有运行过，所以这就是

595
00:21:26,060 --> 00:21:27,500
我们如何保证我是否

596
00:21:27,500 --> 00:21:28,550
从 m 中移出 100 美元

597
00:21:28,550 --> 00:21:31,220
如果事情在我们

598
00:21:31,220 --> 00:21:32,660
将钱存入您的帐户之前失败，则将您的帐户记入您的帐户，

599
00:21:32,660 --> 00:21:34,310
交易会返回边界

600
00:21:34,310 --> 00:21:35,810
，如果我们回到开始交易之前的状态，

601
00:21:35,810 --> 00:21:38,780


602
00:21:38,780 --> 00:21:39,860
这就是我们保证没有

603
00:21:39,860 --> 00:21:45,200
部分的方式 交易是的，这个问题

604
00:21:45,200 --> 00:21:46,310
是为什么我们要告诉

605
00:21:46,310 --> 00:21:48,710
戴维斯实体一个中止，所以很多

606
00:21:48,710 --> 00:21:52,280
时候有应用程序代码，你

607
00:21:52,280 --> 00:21:55,040
说拿拿拿，例如把

608
00:21:55,040 --> 00:21:56,750
钱从我的账户中取出，或者我正在

609
00:21:56,750 --> 00:21:59,210
转账，所以我走了 首先看看我的

610
00:21:59,210 --> 00:21:59,900
账户

611
00:21:59,900 --> 00:22:02,810
我读到我有 100 美元吗 是的 现在

612
00:22:02,810 --> 00:22:04,070
去拿一百作为我的账户 但然后

613
00:22:04,070 --> 00:22:05,750
我会去读你的账户 你的

614
00:22:05,750 --> 00:22:07,670
银行是你的 你的账户 我的标志欺诈

615
00:22:07,670 --> 00:22:10,010
所以现在我想中止并回滚它

616
00:22:10,010 --> 00:22:14,380
一个简单的原因

617
00:22:14,380 --> 00:22:20,580
我不知道这种情况发生的频率我

618
00:22:21,090 --> 00:22:23,559
总是说我的意思是我想

619
00:22:23,559 --> 00:22:24,690
提交的大多数代码他们想提交正确

620
00:22:24,690 --> 00:22:29,470
但我们必须能够支持这一点所以

621
00:22:29,470 --> 00:22:30,669
再次在这里要指出的主要事情

622
00:22:30,669 --> 00:22:33,639
是这个中止 可能是

623
00:22:33,639 --> 00:22:35,139
自我影响 icted 意思是我们告诉我们是否

624
00:22:35,139 --> 00:22:37,000
要中止，或者数据系统告诉

625
00:22:37,000 --> 00:22:38,470
您必须中止，然后如果您 Tennyson 回来说您必须中止，如果您已中止，

626
00:22:38,470 --> 00:22:39,820


627
00:22:39,820 --> 00:22:43,210


628
00:22:43,210 --> 00:22:44,860
则由您在应用程序代码中

629
00:22:44,860 --> 00:22:46,929
捕获您得到的信息 返回一个异常并

630
00:22:46,929 --> 00:22:48,279
说您知道您的交易失败了

631
00:22:48,279 --> 00:22:50,799
，它会建议您重试它，

632
00:22:50,799 --> 00:22:51,940


633
00:22:51,940 --> 00:22:52,960
如果您真的关心这个，则必须返回应用程序代码，然后

634
00:22:52,960 --> 00:22:58,720
再重试一次，所以

635
00:22:58,720 --> 00:23:01,269
我们现在要使用的正确性标准 对于本次

636
00:23:01,269 --> 00:23:02,679
讲座和

637
00:23:02,679 --> 00:23:04,750
本学期的剩余时间，将

638
00:23:04,750 --> 00:23:08,169
根据这个酸性首字母缩写词进行定义，因此它

639
00:23:08,169 --> 00:23:09,190
代表原子一致性

640
00:23:09,190 --> 00:23:10,899
隔离和持久性，

641
00:23:10,899 --> 00:23:13,120
因此原子性是我们已经讨论

642
00:23:13,120 --> 00:23:14,500


643
00:23:14,500 --> 00:23:16,059
过的 事务必须

644
00:23:16,059 --> 00:23:17,919
发生，或者它们都不发生 没有

645
00:23:17,919 --> 00:23:21,279
部分事务的一致性

646
00:23:21,279 --> 00:23:23,559
有点奇怪 我将简要谈谈

647
00:23:23,559 --> 00:23:26,919
它，但它非常方便

648
00:23:26,919 --> 00:23:28,600
，至少对于一个点头来说它实际上意味着什么

649
00:23:28,600 --> 00:23:29,529
e 数据库系统，

650
00:23:29,529 --> 00:23:32,740
所以它只是说，如果

651
00:23:32,740 --> 00:23:35,200
事务像门铃一样一致，

652
00:23:35,200 --> 00:23:40,029
对不起，我忘记了如果事务

653
00:23:40,029 --> 00:23:42,100
是一致的，数据库系统是

654
00:23:42,100 --> 00:23:43,779
一致的，那么当事务

655
00:23:43,779 --> 00:23:46,659
执行时，数据库和状态

656
00:23:46,659 --> 00:23:49,149
将是一致的，所以现在你是 就像

657
00:23:49,149 --> 00:23:51,309
什么是一致的，在高层次上意味着很好，

658
00:23:51,309 --> 00:23:53,679
它意味着正确性，

659
00:23:53,679 --> 00:23:54,399
但那意味着什么，

660
00:23:54,399 --> 00:23:56,679
所以我们将再次在更多

661
00:23:56,679 --> 00:24:00,580
幻灯片中介绍这一点，因为它

662
00:24:00,580 --> 00:24:01,659
最初是由

663
00:24:01,659 --> 00:24:03,970
发明这个首字母缩略词的人定义的

664
00:24:03,970 --> 00:24:06,399
总是一个非常方便的人，有些

665
00:24:06,399 --> 00:24:07,840
人觉得他有点强迫这个

666
00:24:07,840 --> 00:24:09,340
人在这里为了让

667
00:24:09,340 --> 00:24:12,850
首字母缩略词解决另一件事

668
00:24:12,850 --> 00:24:16,149
是数据库lor是他编造

669
00:24:16,149 --> 00:24:17,889
这个东西来取笑他的

670
00:24:17,889 --> 00:24:20,259
妻子因为他的妻子不喜欢糖果

671
00:24:20,259 --> 00:24:21,610
或者她就像一个苦涩的女人或

672
00:24:21,610 --> 00:24:23,830
其他什么所以他以她的名字命名我

673
00:24:23,830 --> 00:24:25,149
不知道这是不是真的他是

674
00:24:25,149 --> 00:24:28,029
德国人也许但是还有

675
00:24:28,029 --> 00:24:28,450
一个叫做

676
00:24:28,450 --> 00:24:30,909
base 的 分布式系统或

677
00:24:30,909 --> 00:24:32,080
没有单个系统，我们将介绍它

678
00:24:32,080 --> 00:24:33,700
和更多的讲座，所以

679
00:24:33,700 --> 00:24:35,769
我们在这里关心的是酸 基础将在

680
00:24:35,769 --> 00:24:38,139
稍后介绍隔离是另一个

681
00:24:38,139 --> 00:24:40,299
重要的，这意味着当

682
00:24:40,299 --> 00:24:42,009
我们的事务执行时它应该

683
00:24:42,009 --> 00:24:44,019
有它的错觉

684
00:24:44,019 --> 00:24:45,759
即使其他事务可能

685
00:24:45,759 --> 00:24:47,409
同时运行并且数据

686
00:24:47,409 --> 00:24:50,080
不是一个井

687
00:24:50,080 --> 00:24:52,720
，它自己运行也会为它提供这种错觉，然后

688
00:24:52,720 --> 00:24:54,730
如果我们的事务提交我们的所有

689
00:24:54,730 --> 00:24:56,529
更改都被保存并且我们在

690
00:24:56,529 --> 00:24:58,210
确认时返回，那么持久性是湿的 退伍军人实际上

691
00:24:58,210 --> 00:25:00,399
承诺然后无论数据库发生什么，

692
00:25:00,399 --> 00:25:02,350
你知道它

693
00:25:02,350 --> 00:25:04,059
机器崩溃它不是哦

694
00:25:04,059 --> 00:25:07,359
，机器着火了崩溃然后我们所有的

695
00:25:07,359 --> 00:25:09,129
更改都应该是持久的也许她

696
00:25:09,129 --> 00:25:09,970
总是能够回来

697
00:25:09,970 --> 00:25:12,549
看到我们的更改我们的更改 可能会被

698
00:25:12,549 --> 00:25:15,039
覆盖，这没关系，但至少

699
00:25:15,039 --> 00:25:16,899
对于我们的交易，您知道我们

700
00:25:16,899 --> 00:25:20,320
知道所有更改都具有持久性，因此

701
00:25:20,320 --> 00:25:22,749
另一种速记方式 lo

702
00:25:22,749 --> 00:25:23,830
对这些事情你会说

703
00:25:23,830 --> 00:25:25,539
亚当不是他只是意味着全部或没有

704
00:25:25,539 --> 00:25:27,429
交易的任何部分因为因为

705
00:25:27,429 --> 00:25:29,350
他的意思是它在我看来是正确的并且

706
00:25:29,350 --> 00:25:32,109
正确的将在引号中隔离

707
00:25:32,109 --> 00:25:33,159
意味着你就像你一个人一样跑步

708
00:25:33,159 --> 00:25:34,929
然后 耐用性意味着您

709
00:25:34,929 --> 00:25:37,659
将在所有失败中幸存下来，因此在

710
00:25:37,659 --> 00:25:38,859
今天的课程中，我们将

711
00:25:38,859 --> 00:25:40,869
逐一介绍其中的每一个，并

712
00:25:40,869 --> 00:25:43,239
在高层次上描述

713
00:25:43,239 --> 00:25:46,179
确定我们是否正在

714
00:25:46,179 --> 00:25:47,889
使用给定财产实现资产担保的含义 在每个

715
00:25:47,889 --> 00:25:50,049
字母中，我们将主要关注

716
00:25:50,049 --> 00:25:52,119
原子性和隔离性 我将

717
00:25:52,119 --> 00:25:53,499
在这里简要讨论一致性

718
00:25:53,499 --> 00:25:54,879
对于单节点系统并没有多大意义，

719
00:25:54,879 --> 00:25:55,779
它对

720
00:25:55,779 --> 00:25:57,399
分布式系统更重要，然后对于

721
00:25:57,399 --> 00:25:59,080
持久性我们也不是 真的

722
00:25:59,080 --> 00:26:00,549
会谈论它太多，因为

723
00:26:00,549 --> 00:26:03,269


724
00:26:03,269 --> 00:26:06,460
在我回到检查点和音量之后，我们将花费整整两堂课，

725
00:26:06,460 --> 00:26:07,720
因为这就是他们将如何

726
00:26:07,720 --> 00:26:11,109
实现这一目标，好吧，我也会

727
00:26:11,109 --> 00:26:14,320
说酸就是你要的 如果

728
00:26:14,320 --> 00:26:17,470
一个关系数据水泥系统说

729
00:26:17,470 --> 00:26:19,749
他们支持事务，

730
00:26:19,749 --> 00:26:22,629
我的意思是没有续集的

731
00:26:22,629 --> 00:26:23,679
系统不做

732
00:26:23,679 --> 00:26:25,389
他们通常会牺牲的事务，他们通常会

733
00:26:25,389 --> 00:26:29,259
经常牺牲 Adam 是孤立的，

734
00:26:29,259 --> 00:26:30,700
实际上他们中的一些人确实得到了亲吻 摆脱

735
00:26:30,700 --> 00:26:33,749
一切，但我们将把它离线，

736
00:26:33,749 --> 00:26:36,970
好吧，让我们谈谈等待原子性，所以

737
00:26:36,970 --> 00:26:38,919
正如我所说的

738
00:26:38,919 --> 00:26:42,100
，我们的事务有两个结果，要么提交

739
00:26:42,100 --> 00:26:43,960
，我们所有的更改都得到 get % 或 get

740
00:26:43,960 --> 00:26:45,789
可以同时应用于数据库，

741
00:26:45,789 --> 00:26:49,150
或者它 被中止是因为您

742
00:26:49,150 --> 00:26:50,980
知道数据或应用程序都

743
00:26:50,980 --> 00:26:53,679
这么说 所以我们再次

744
00:26:53,679 --> 00:26:54,970
向我们的应用程序提供的保证是

745
00:26:54,970 --> 00:26:57,070


746
00:26:57,070 --> 00:26:59,890
，我们执行所有更改的任何事务都将是

747
00:26:59,890 --> 00:27:02,080
原子的，这意味着它们都会出现

748
00:27:02,080 --> 00:27:05,080
它们完全在同一时间发生，

749
00:27:05,080 --> 00:27:05,950
所以这只是意味着要么

750
00:27:05,950 --> 00:27:07,390
一切都发生，要么什么都不发生，

751
00:27:07,390 --> 00:27:08,950
所以无论发生什么，如果我说我

752
00:27:08,950 --> 00:27:11,169
承诺，那么我知道一切都得到了

753
00:27:11,169 --> 00:27:13,900
保存，所以让' 看看

754
00:27:13,900 --> 00:27:16,840
我们可能会遇到原子性问题的两种情况

755
00:27:16,840 --> 00:27:18,250
，然后我们会看到我实际上想要

756
00:27:18,250 --> 00:27:21,940
如何解决它，所以我心爱的例子

757
00:27:21,940 --> 00:27:23,020
我从我的帐户中取出一百美元

758
00:27:23,020 --> 00:27:24,280
并将其

759
00:27:24,280 --> 00:27:27,520
存入另一个帐户，但随后我们 把钱

760
00:27:27,520 --> 00:27:29,620
从我的账户中取出，然后

761
00:27:29,620 --> 00:27:31,690
交易被中止 机器

762
00:27:31,690 --> 00:27:33,100
没有崩溃 数据说 noes 崩溃了

763
00:27:33,100 --> 00:27:36,490
我们只是中止了第二种情况

764
00:27:36,490 --> 00:27:38,289
是当你可以抽出一百个

765
00:27:38,289 --> 00:27:40,860
小时但是现在出现了电源故障和

766
00:27:40,860 --> 00:27:42,669
一切 正在运行的数据系统

767
00:27:42,669 --> 00:27:45,400
丢失了，我们回来

768
00:27:45,400 --> 00:27:47,590
了，数据库的正确状态应该是什么，

769
00:27:47,590 --> 00:27:49,600
所以有两种方法

770
00:27:49,600 --> 00:27:52,659
可以处理这个问题，最常见的

771
00:27:52,659 --> 00:27:55,299
方法是进行日志记录，非常好，

772
00:27:55,299 --> 00:27:57,280
我不是说你知道

773
00:27:57,280 --> 00:27:59,350
记录您在项目中使用的调试消息是

774
00:27:59,350 --> 00:28:01,450
正确的 我的意思是像

775
00:28:01,450 --> 00:28:02,679
直接记录一样，但我们实际上是

776
00:28:02,679 --> 00:28:05,110
在磁盘上记录我们的文件 这里

777
00:28:05,110 --> 00:28:07,659
只是我们正在制作的所以

778
00:28:07,659 --> 00:28:08,890
会发生的是 David Simmons 将运行

779
00:28:08,890 --> 00:28:12,100
并且因为它每次对数据库进行的每次更改都会运行一个事务，

780
00:28:12,100 --> 00:28:13,419


781
00:28:13,419 --> 00:28:14,770
每次更新或写入

782
00:28:14,770 --> 00:28:17,590
数据库时，我都会复制

783
00:28:17,590 --> 00:28:20,490
我正在覆盖的旧值

784
00:28:20,490 --> 00:28:23,559
，然后如果我崩溃或 我的

785
00:28:23,559 --> 00:28:25,780
交易被中止 我有旧的

786
00:28:25,780 --> 00:28:28,030
价值，我可以

787
00:28:28,030 --> 00:28:31,360
回去把它放回原处，这样当我的

788
00:28:31,360 --> 00:28:33,159
交易在中止后被清理时，

789
00:28:33,159 --> 00:28:35,799
所有原始电池

790
00:28:35,799 --> 00:28:40,150
仍然存在，所以它的

791
00:28:40,150 --> 00:28:41,320
工作方式是 这将是我们将

792
00:28:41,320 --> 00:28:42,929


793
00:28:42,929 --> 00:28:46,539
在内存和磁盘上维护这些撤消记录

794
00:28:46,539 --> 00:28:48,520
，如果我们崩溃，那么如果

795
00:28:48,520 --> 00:28:51,070
事务在我们运行时中止，

796
00:28:51,070 --> 00:28:52,929
那么如果它在内存中，我们

797
00:28:52,929 --> 00:28:54,850
就会快速逆转事情 但是如果

798
00:28:54,850 --> 00:28:55,539
东西

799
00:28:55,539 --> 00:28:58,479
写了一个磁盘然后我们崩溃了那么我们

800
00:28:58,479 --> 00:29:00,549
在他们的磁盘上有我们的日志记录，

801
00:29:00,549 --> 00:29:02,109
然后我们可以在我们

802
00:29:02,109 --> 00:29:04,149
打开数据系统时重新加载并

803
00:29:04,149 --> 00:29:05,710
协调让我们回到正确的

804
00:29:05,710 --> 00:29:08,559
状态，所以在高级别你 可以

805
00:29:08,559 --> 00:29:10,629
将日志视为 黑匣子和一架

806
00:29:10,629 --> 00:29:13,570
飞机 就像

807
00:29:13,570 --> 00:29:15,279
发生重大事故 任何飞机坠毁都是重大坠机 但

808
00:29:15,279 --> 00:29:17,739
如果飞机坠毁 政府会采取什么措施

809
00:29:17,739 --> 00:29:18,970
资金会很好地查看

810
00:29:18,970 --> 00:29:20,710
黑匣子 因为这将

811
00:29:20,710 --> 00:29:22,029
记录有关实际

812
00:29:22,029 --> 00:29:23,590
情况的信息 你知道发生了什么 飞机

813
00:29:23,590 --> 00:29:27,609
坠毁的那一刻，然后

814
00:29:27,609 --> 00:29:28,989
它试图找出

815
00:29:28,989 --> 00:29:31,090
错误是什么 现在

816
00:29:31,090 --> 00:29:32,470
在飞机的情况下是什么故障 他们无法

817
00:29:32,470 --> 00:29:33,669
将飞机重新组装起来，

818
00:29:33,669 --> 00:29:35,229
数据库可以正常工作，因此我们可以将其放回原处

819
00:29:35,229 --> 00:29:35,590


820
00:29:35,590 --> 00:29:36,970
好吧，这就是我们将要

821
00:29:36,970 --> 00:29:41,070
使用该表单的内容，因此

822
00:29:41,070 --> 00:29:44,229
几乎所有

823
00:29:44,229 --> 00:29:45,429
我们将制作的数据系统都将使用高级日志记录权利，

824
00:29:45,429 --> 00:29:47,379
任何数据库系统

825
00:29:47,379 --> 00:29:50,080
都说它们对磁盘很有吸引力

826
00:29:50,080 --> 00:29:54,669
'正在使用日志，因此除了您

827
00:29:54,669 --> 00:29:56,830
知道具有回滚

828
00:29:56,830 --> 00:29:59,080
事物和保证原子性登录的能力

829
00:29:59,080 --> 00:30:01,419
之外，还会在性能和高级概念方面为我们提供额外的好处

830
00:30:01,419 --> 00:30:03,460


831
00:30:03,460 --> 00:30:05,799
我们

832
00:30:05,799 --> 00:30:08,349
可能对组织应用程序的标准，

833
00:30:08,349 --> 00:30:09,879
所以当我们

834
00:30:09,879 --> 00:30:12,369
开始谈论日志时，因为没有

835
00:30:12,369 --> 00:30:14,590
光盘是昂贵的，所以结果是正确的 - 我们可以通过日志将

836
00:30:14,590 --> 00:30:16,269
随机写入转换为顺序写入

837
00:30:16,269 --> 00:30:18,970
，这可以

838
00:30:18,970 --> 00:30:20,859
使系统运行得更快 然后对于其他

839
00:30:20,859 --> 00:30:22,090
应用程序，日志实际上

840
00:30:22,090 --> 00:30:25,179
实际上是你知道审计

841
00:30:25,179 --> 00:30:26,799
跟踪所有

842
00:30:26,799 --> 00:30:28,899
事情你的应用程序所做的每一件事然后

843
00:30:28,899 --> 00:30:31,059
你可以使用它来弄清楚发生了什么，

844
00:30:31,059 --> 00:30:32,769
如果你曾经有过审计

845
00:30:32,769 --> 00:30:34,899
或有疑问 知道我的

846
00:30:34,899 --> 00:30:36,190
应用程序在这个时候这样做是

847
00:30:36,190 --> 00:30:37,989
因为然后有一个违规行为

848
00:30:37,989 --> 00:30:39,820
我变红了哪些数据或我得到的哪些数据

849
00:30:39,820 --> 00:30:43,389
被写入了所以在很多金融

850
00:30:43,389 --> 00:30:44,950
公司他们维护我他们必须

851
00:30:44,950 --> 00:30:46,720
维护数据学生生成的日志

852
00:30:46,720 --> 00:30:47,710
在过去的七年里，

853
00:30:47,710 --> 00:30:50,080
由于政府监管，

854
00:30:50,080 --> 00:30:51,549
这是一个很好的例子，我

855
00:30:51,549 --> 00:30:53,559
可以将日志用于原子性，但也

856
00:30:53,559 --> 00:30:57,190
可以从中获得额外的好处，因此

857
00:30:57,190 --> 00:30:58,479
o 不太常见的保证原子

858
00:30:58,479 --> 00:30:59,799
性的方法称为影子

859
00:30:59,799 --> 00:31:02,470
分页，这实际上

860
00:31:02,470 --> 00:31:03,669
是我在课程开始时提到的示例，我在课堂

861
00:31:03,669 --> 00:31:04,840
上说过，

862
00:31:04,840 --> 00:31:06,249
我要

863
00:31:06,249 --> 00:31:09,099
在磁盘上制作数据库文件的副本，所有更改都转到

864
00:31:09,099 --> 00:31:09,400


865
00:31:09,400 --> 00:31:10,750
复制然后当我的事务

866
00:31:10,750 --> 00:31:12,430
提交时我只是摆动一个指针并说

867
00:31:12,430 --> 00:31:14,680
这是现在这是现在是主

868
00:31:14,680 --> 00:31:16,660
版本所以这本质上是

869
00:31:16,660 --> 00:31:18,940
影子分页但不是

870
00:31:18,940 --> 00:31:20,920
每次都复制单个文件

871
00:31:20,920 --> 00:31:22,450
他们只会复制单个

872
00:31:22,450 --> 00:31:24,610
页面 事务在

873
00:31:24,610 --> 00:31:26,710
运行时修改，然后在事务中

874
00:31:26,710 --> 00:31:28,240
再次提交时，您摆动指针并

875
00:31:28,240 --> 00:31:29,860
说所有这些影子副本

876
00:31:29,860 --> 00:31:33,160
页面现在都是主副本页面所以

877
00:31:33,160 --> 00:31:35,020
这是数据库系统中最古老的想法之一

878
00:31:35,020 --> 00:31:36,250
这是关于

879
00:31:36,250 --> 00:31:41,680
IBM 的事件 在 1970 年代和系统 R 中，这

880
00:31:41,680 --> 00:31:45,700


881
00:31:45,700 --> 00:31:48,430
在管理磁盘上的数据时变得非常缓慢且有问题，当 IBM

882
00:31:48,430 --> 00:31:50,110
开始构建 db2 时，这是

883
00:31:50,110 --> 00:31:51,460
关系数据的第二天 他们

884
00:31:51,460 --> 00:31:54,070
在系统之后构建的系统他们没有做任何

885
00:31:54,070 --> 00:31:55,500
这些他们采用了日志记录方法

886
00:31:55,500 --> 00:31:58,630
因为你最终会得到碎片

887
00:31:58,630 --> 00:32:02,680
并且它具有无序的数据集

888
00:32:02,680 --> 00:32:05,380
并且它变得越来越慢据你

889
00:32:05,380 --> 00:32:07,870
所知今天只有两个数据库

890
00:32:07,870 --> 00:32:09,520
实际执行此操作的系统是影子分页

891
00:32:09,520 --> 00:32:16,510
方法是 CouchDB 和 LM DB 他们说

892
00:32:16,510 --> 00:32:17,860
这是出于性能原因这

893
00:32:17,860 --> 00:32:19,900
并不常见其他所有人

894
00:32:19,900 --> 00:32:23,860
都会做日志记录所以这是一个问题是的

895
00:32:23,860 --> 00:32:37,180
哦是的这个继续这个一个

896
00:32:37,180 --> 00:32:39,850
所以这个一个 这是相同的

897
00:32:39,850 --> 00:32:41,200
操作 把钱存入

898
00:32:41,200 --> 00:32:43,630
你的账户 这就像我们得到一个

899
00:32:43,630 --> 00:32:45,520
Bourdon 就像用户说中止我的

900
00:32:45,520 --> 00:32:48,370
交易 一切都还在记忆中

901
00:32:48,370 --> 00:32:50,470
我如何回滚它 这就像一个

902
00:32:50,470 --> 00:32:53,320
严重的崩溃 我如何回来

903
00:32:53,320 --> 00:32:54,970
因此，我试图在这里提出的观点

904
00:32:54,970 --> 00:32:58,720
是日志信息

905
00:32:58,720 --> 00:33:00,130
将驻留在内存中，

906
00:33:00,130 --> 00:33:02,370
最终也会写出到磁盘，

907
00:33:02,370 --> 00:33:04,540
因为如果它在内存中，那么我可以

908
00:33:04,540 --> 00:33:06,220
快速获取它并执行 ip 你知道

909
00:33:06,220 --> 00:33:08,560
如果我把旧按钮倒回去，

910
00:33:08,560 --> 00:33:10,690
如果我在磁盘上发生严重崩溃，那么

911
00:33:10,690 --> 00:33:12,090


912
00:33:12,090 --> 00:33:14,470
当我不想重新加载系统时，我可以正确地反转事情

913
00:33:14,470 --> 00:33:16,000
，因为在一次

914
00:33:16,000 --> 00:33:18,130
硬崩溃之后所有的 缓冲

915
00:33:18,130 --> 00:33:20,980
池的内容消失了，我们知道我们

916
00:33:20,980 --> 00:33:22,510
需要弄清楚崩溃时系统发生了什么，

917
00:33:22,510 --> 00:33:23,170


918
00:33:23,170 --> 00:33:24,430
以便让我们回到正确的

919
00:33:24,430 --> 00:33:29,950
状态是的所以这个问题是这是否

920
00:33:29,950 --> 00:33:31,060
需要写入磁盘读取

921
00:33:31,060 --> 00:33:34,150
事务是如果 你关心这个

922
00:33:34,150 --> 00:33:36,010
没关系如果你关心不丢失数据

923
00:33:36,010 --> 00:33:39,780
是的我们稍后会讨论

924
00:33:45,660 --> 00:33:48,040
LM dB

925
00:33:48,040 --> 00:33:51,850


926
00:33:51,850 --> 00:33:58,150


927
00:33:58,150 --> 00:34:06,040


928
00:34:06,040 --> 00:34:08,770
所以几年前，我的第一个 PC

929
00:34:08,770 --> 00:34:10,090
学生，他和我开始

930
00:34:10,090 --> 00:34:13,150
使用新的英特尔

931
00:34:13,150 --> 00:34:15,130
非易失性存储设备构建一个新系统

932
00:34:15,130 --> 00:34:17,918
，当时我们认为，

933
00:34:17,918 --> 00:34:21,159
像非易失性存储器这样的快速存储，

934
00:34:21,159 --> 00:34:22,989
他几乎就像 与 DRAM 一样

935
00:34:22,989 --> 00:34:26,110
快，存储速度非常快，可以做随机数

936
00:34:26,110 --> 00:34:27,699
访问影子分页实际上

937
00:34:27,699 --> 00:34:29,440
会成为更好的方法，例如

938
00:34:29,440 --> 00:34:31,659
采用 70 年代的旧想法并

939
00:34:31,659 --> 00:34:33,730
像今天的硬件一样运行它不能

940
00:34:33,730 --> 00:34:34,810
在所有游戏之前运行总是

941
00:34:34,810 --> 00:34:36,159
更快，因为您可以执行这些

942
00:34:36,159 --> 00:34:38,530
顺序写入您知道 你可以

943
00:34:38,530 --> 00:34:39,880
把一堆东西放在一起，然后

944
00:34:39,880 --> 00:34:41,199
用影子分页一次推入所有的磁盘，

945
00:34:41,199 --> 00:34:42,159
这就是所有这些

946
00:34:42,159 --> 00:34:43,810
碎片，你每次都在复制东西，

947
00:34:43,810 --> 00:34:45,820
它变得非常

948
00:34:45,820 --> 00:34:49,239
昂贵，看看多版本

949
00:34:49,239 --> 00:34:51,460
并发巨魔，有点像

950
00:34:51,460 --> 00:34:53,469
这样，但是 你而不是

951
00:34:53,469 --> 00:34:55,270
在我进行更改之前复制整个页面，我

952
00:34:55,270 --> 00:34:57,820
可能只是复制一个元组或元组的一个子集，

953
00:34:57,820 --> 00:35:00,730
所以影子分页是

954
00:35:00,730 --> 00:35:03,550
多虚拟控制的工作方式，但

955
00:35:03,550 --> 00:35:05,320
IBM 定义的影子分页

956
00:35:05,320 --> 00:35:15,760
除了这些人之外没有人做 是的，

957
00:35:15,760 --> 00:35:18,010
他们的登录内容是的，所以我不会花

958
00:35:18,010 --> 00:35:20,080
太多时间在办公桌上，

959
00:35:20,080 --> 00:35:22,120
但问题是

960
00:35:22,120 --> 00:35:25,930
如果我做了很多更改，我会创建

961
00:35:25,930 --> 00:35:27,400
一些撤消撤消记录，这些记录是我 n

962
00:35:27,400 --> 00:35:29,560
内存，但在它写出磁盘之前我崩溃

963
00:35:29,560 --> 00:35:31,420
了这是一个问题，

964
00:35:31,420 --> 00:35:35,260
因为当我回来时，我所有的

965
00:35:35,260 --> 00:35:36,700
记忆都消失了

966
00:35:36,700 --> 00:35:39,010
，因此我将

967
00:35:39,010 --> 00:35:41,410
根据它在磁盘上的方式加载数据库

968
00:35:41,410 --> 00:35:43,869
，所以因为那些 更改永远不会

969
00:35:43,869 --> 00:35:47,349
持久化到磁盘，它们就在那里，就

970
00:35:47,349 --> 00:35:49,690
好像它们从未发生过一样，所以他的问题

971
00:35:49,690 --> 00:35:52,230
是哪个好点是

972
00:35:52,230 --> 00:35:54,550
我是否有这意味着

973
00:35:54,550 --> 00:35:56,230
如果我知道我是否想说我的交易已

974
00:35:56,230 --> 00:35:57,910
提交，我必须这样做 必须做一个 S Inc 是否

975
00:35:57,910 --> 00:35:59,770
每次我的事务提交时我都会进行一次刷新

976
00:35:59,770 --> 00:36:01,990
，我的回答是肯定的，

977
00:36:01,990 --> 00:36:03,609
但是您并没有真正在每次提交时都这样做，

978
00:36:03,609 --> 00:36:05,530
您将一堆放在一起

979
00:36:05,530 --> 00:36:06,910
，然后在刷新时进行组提交

980
00:36:06,910 --> 00:36:08,170
所有这些都在

981
00:36:08,170 --> 00:36:09,640
宣传 F 同步成本随着时间的推移，

982
00:36:09,640 --> 00:36:11,740
但是如果你敢于

983
00:36:11,740 --> 00:36:15,520
保证你的数据实际上是持久的，

984
00:36:15,520 --> 00:36:17,440
那么你必须很好地写入磁盘，

985
00:36:17,440 --> 00:36:19,210
看起来如此，但棘手的事情将

986
00:36:19,210 --> 00:36:21,339
是你写入磁盘的顺序 这

987
00:36:21,339 --> 00:36:22,690
很重要，所以你必须要我

988
00:36:22,690 --> 00:36:24,490


989
00:36:24,490 --> 00:36:26,079
在将数据页写入磁盘之前，请确保首先写入与数据页更改相对应的日志记录，

990
00:36:26,079 --> 00:36:27,400


991
00:36:27,400 --> 00:36:27,880


992
00:36:27,880 --> 00:36:29,820
我们还将介绍一整天的内容

993
00:36:29,820 --> 00:36:32,980
，并在

994
00:36:32,980 --> 00:36:34,900
检查时让我做出像哦

995
00:36:34,900 --> 00:36:36,400
好吧，没有续集的人并不总是提供

996
00:36:36,400 --> 00:36:40,000
酸，他们中的一些人实际上

997
00:36:40,000 --> 00:36:41,980
甚至不会刷新到磁盘，如果他们有

998
00:36:41,980 --> 00:36:43,660
交易，他们不会完全信任磁盘，

999
00:36:43,660 --> 00:36:45,760
当你说你知道完成

1000
00:36:45,760 --> 00:36:47,710
我的交易时，他们

1001
00:36:47,710 --> 00:36:50,290
几乎每 60 次做一次 秒，所以这意味着你

1002
00:36:50,290 --> 00:36:51,790
可能会崩溃并丢失最后 60 秒

1003
00:36:51,790 --> 00:36:54,609
的数据，有些系统甚至比这更糟糕

1004
00:36:54,609 --> 00:36:56,859
我只是直接说

1005
00:36:56,859 --> 00:36:58,780
Mongo 对早期版本的 Mongo

1006
00:36:58,780 --> 00:37:01,030
是当你做对了这意味着 Li

1007
00:37:01,030 --> 00:37:02,319
回来了 说是的，我做对了，

1008
00:37:02,319 --> 00:37:04,780
但实际上做对了，这是

1009
00:37:04,780 --> 00:37:07,000
一个网络 Lera 说是的，我明白了，如果

1010
00:37:07,000 --> 00:37:07,900
您想确保自己是

1011
00:37:07,900 --> 00:37:09,040
对的，实际上还没有

1012
00:37:09,040 --> 00:37:10,300
第二次回来并说您真的

1013
00:37:10,300 --> 00:37:12,369
这样做了 这是默认的

1014
00:37:12,369 --> 00:37:13,480
大约四五年了，他们

1015
00:37:13,480 --> 00:37:14,859
早期的基准测试时刻很棒，

1016
00:37:14,859 --> 00:37:16,390
因为他们会做这些权利

1017
00:37:16,390 --> 00:37:18,550
，当然就像是的，我明白

1018
00:37:18,550 --> 00:37:22,140
没问题，但实际上并没有这样做，

1019
00:37:23,579 --> 00:37:25,990
有一些 Mongo 修复了公司倒下的

1020
00:37:25,990 --> 00:37:28,810
问题，所以 关于原子性的任何问题，

1021
00:37:28,810 --> 00:37:30,660


1022
00:37:30,660 --> 00:37:32,920
我们将讨论我们将如何

1023
00:37:32,920 --> 00:37:37,680
真正保证这一点，所以

1024
00:37:37,680 --> 00:37:39,790
正如我之前所说的那样，一致性是

1025
00:37:39,790 --> 00:37:43,150
关于数据库正确性的模糊术语，

1026
00:37:43,150 --> 00:37:46,420
因此在高层次上

1027
00:37:46,420 --> 00:37:47,319
思考数据库

1028
00:37:47,319 --> 00:37:50,600
实际上是什么的方式 正在尝试模拟

1029
00:37:50,600 --> 00:37:53,360
现实世界的某些概念或方面，

1030
00:37:53,360 --> 00:37:55,250
例如我的银行数据库 正在尝试

1031
00:37:55,250 --> 00:37:57,350
模拟银行的旧时代，

1032
00:37:57,350 --> 00:37:58,790
有人会坐在分类帐中

1033
00:37:58,790 --> 00:38:00,200
记录您的帐户中实际有多少钱，这是

1034
00:38:00,200 --> 00:38:02,450
正确的

1035
00:38:02,450 --> 00:38:05,750
对现实世界中的一些过程进行建模，所以我们

1036
00:38:05,750 --> 00:38:09,710
会说，如果我们的数据库

1037
00:38:09,710 --> 00:38:14,060
在逻辑上是正确的，这意味着我们不

1038
00:38:14,060 --> 00:38:15,110
关心实际实际

1039
00:38:15,110 --> 00:38:16,760
存储的数据，但数据完整性是

1040
00:38:16,760 --> 00:38:18,590
指涉对象 完整性所有这些

1041
00:38:18,590 --> 00:38:22,100
都是正确的然后我们询问的任何问题

1042
00:38:22,100 --> 00:38:23,630
我们的数据库都会产生

1043
00:38:23,630 --> 00:38:27,770
正确的结果，这听起来

1044
00:38:27,770 --> 00:38:29,420
很模糊所以让我进入或详细说明

1045
00:38:29,420 --> 00:38:31,190
我们现在可能有两种类型的一致性

1046
00:38:31,190 --> 00:38:32,600
数据库

1047
00:38:32,600 --> 00:38:34,540
一致性和事务

1048
00:38:34,540 --> 00:38:36,740
一致性剧透 将是数据库

1049
00:38:36,740 --> 00:38:38,030
一致性是我们真正关心的

1050
00:38:38,030 --> 00:38:40,010
我们实际上我们不能做

1051
00:38:40,010 --> 00:38:42,400
第二个我们将在一秒钟内看到

1052
00:38:42,400 --> 00:38:46,820
为什么我们的krampus标准

1053
00:38:46,820 --> 00:38:49,070
是我们的数据库实际上反映

1054
00:38:49,070 --> 00:38:51,620
了现实世界的样子和 那么

1055
00:38:51,620 --> 00:38:53,480
我们如何真正执行得很好，我们

1056
00:38:53,480 --> 00:38:54,530
为数据系统提供了完整性

1057
00:38:54,530 --> 00:38:56,660
约束，以说

1058
00:38:56,660 --> 00:38:58,210
这就是我们拥有正确数据的意义

1059
00:38:58,210 --> 00:39:02,270
，例如，如果我有一张

1060
00:39:02,270 --> 00:39:04,340
人或学生的表格并且我正在跟踪

1061
00:39:04,340 --> 00:39:06,530
他们的年龄我可以有一个完整性

1062
00:39:06,530 --> 00:39:08,030
约束，说没有人的年龄

1063
00:39:08,030 --> 00:39:10,160
可以小于零，没有

1064
00:39:10,160 --> 00:39:13,250
负负年龄，所以数据

1065
00:39:13,250 --> 00:39:14,360
系统可以强制执行它 etimes

1066
00:39:14,360 --> 00:39:15,740
插入一些带有负年龄的东西 你

1067
00:39:15,740 --> 00:39:17,780
可以说那是你

1068
00:39:17,780 --> 00:39:19,970
在现实世界中不能拥有的 我不能让你插入

1069
00:39:19,970 --> 00:39:23,810
那个数据 换一种方式来

1070
00:39:23,810 --> 00:39:27,560
思考也是，所以现在

1071
00:39:27,560 --> 00:39:29,330
除了这些现在还有经验 作为

1072
00:39:29,330 --> 00:39:30,920
开始对数据库进行更改

1073
00:39:30,920 --> 00:39:34,160
的事务，任何

1074
00:39:34,160 --> 00:39:36,500
将来借口的事务都应该能够

1075
00:39:36,500 --> 00:39:39,830
看到正确的

1076
00:39:39,830 --> 00:39:42,290
更改过去的事务所

1077
00:39:42,290 --> 00:39:45,590
做的正确更改所以这意味着什么所以如果我的

1078
00:39:45,590 --> 00:39:47,240
事务说我想运行

1079
00:39:47,240 --> 00:39:49,160
现在交易，如果您现在在一分钟后运行交易，我会在数据库中进行一些更改，

1080
00:39:49,160 --> 00:39:50,960


1081
00:39:50,960 --> 00:39:53,510
因为没有人

1082
00:39:53,510 --> 00:39:56,330
覆盖我的更改，您应该

1083
00:39:56,330 --> 00:40:01,010
能够看到我的更新，因此在单

1084
00:40:01,010 --> 00:40:02,870
节点数据库中这不是那么大，您

1085
00:40:02,870 --> 00:40:04,460
知道这一点 没什么大不了的，

1086
00:40:04,460 --> 00:40:05,990
所以我的交易提交了，我

1087
00:40:05,990 --> 00:40:07,160
回馈我提交的确认，

1088
00:40:07,160 --> 00:40:09,680
然后你来了，现在

1089
00:40:09,680 --> 00:40:11,660
在同一台机器上做另一个交易

1090
00:40:11,660 --> 00:40:13,670
，你读一下，你应该我们

1091
00:40:13,670 --> 00:40:14,810
要去 立即阅读我的权利，

1092
00:40:14,810 --> 00:40:17,300
因此对于单个无数据库，这不是

1093
00:40:17,300 --> 00:40:18,670
那么大，这并不是真正的问题，

1094
00:40:18,670 --> 00:40:20,660
当这更重要的是

1095
00:40:20,660 --> 00:40:23,119
分布式数据库时

1096
00:40:23,119 --> 00:40:24,560


1097
00:40:24,560 --> 00:40:26,990


1098
00:40:26,990 --> 00:40:30,800
然后我更新了一些帐户，

1099
00:40:30,800 --> 00:40:33,290
然后你在一毫秒后在

1100
00:40:33,290 --> 00:40:36,140
另一台机器上访问相同的逻辑

1101
00:40:36,140 --> 00:40:37,640
数据库，但在单独的物理

1102
00:40:37,640 --> 00:40:39,550
机器上，你现在开始阅读

1103
00:40:39,550 --> 00:40:42,470
你应该能够看到我的变化，

1104
00:40:42,470 --> 00:40:44,270
如果我告诉外面 世界，我的

1105
00:40:44,270 --> 00:40:47,900
交易提交得很好，所以这

1106
00:40:47,900 --> 00:40:49,430
对 Shiva 数据库来说更重要，

1107
00:40:49,430 --> 00:40:51,410
因为没有续集的人

1108
00:40:51,410 --> 00:40:52,430
会有这个叫做冒险家

1109
00:40:52,430 --> 00:40:54,260
克里斯汀 C 的东西会说我最终会传播

1110
00:40:54,260 --> 00:40:57,109
更改，而不是

1111
00:40:57,109 --> 00:40:58,430
保证每个人都看到完全相同

1112
00:40:58,430 --> 00:41:00,740
的设备状态 同时，但

1113
00:41:00,740 --> 00:41:02,119
就我们今天的目的而言，一个新的

1114
00:41:02,119 --> 00:41:04,640
数据库并没有真正意义它

1115
00:41:04,640 --> 00:41:08,330
不会成为问题，因此另一种类型的

1116
00:41:08,330 --> 00:41:09,619
恒定性是事务一致性

1117
00:41:09,619 --> 00:41:13,220
并且这又是非常手动的，但

1118
00:41:13,220 --> 00:41:14,990
它基本上说，如果数据库

1119
00:41:14,990 --> 00:41:16,400
在事务运行之前是一致的

1120
00:41:16,400 --> 00:41:19,820
并且我们的事务是一致的，那么

1121
00:41:19,820 --> 00:41:21,950
在我们运行我们的事务之后

1122
00:41:21,950 --> 00:41:26,300
，数据库的 N 状态应该是一致的，

1123
00:41:26,300 --> 00:41:27,560
那么这是什么意思呢？ 您

1124
00:41:27,560 --> 00:41:29,750
知道一致或正确的权利，这

1125
00:41:29,750 --> 00:41:31,369
是我们无法在我们的数据库中推理的更高级别的概念，我们

1126
00:41:31,369 --> 00:41:35,810


1127
00:41:35,810 --> 00:41:37,430
可以尝试强制执行一些完整性

1128
00:41:37,430 --> 00:41:40,040
约束，我们可以防止

1129
00:41:40,040 --> 00:41:42,230
事务执行您知道进行

1130
00:41:42,230 --> 00:41:46,369
一些更改但您知道我的

1131
00:41:46,369 --> 00:41:48,589
应用程序是否 说应该没有

1132
00:41:48,589 --> 00:41:51,500
客户的帐户让您

1133
00:41:51,500 --> 00:41:55,520
知道 CMU edu 电子邮件地址，我的

1134
00:41:55,520 --> 00:41:57,230
交易继续进行，

1135
00:41:57,230 --> 00:42:00,020
实际上我尝试这样做，我无法

1136
00:42:00,020 --> 00:42:01,820
在我的数据库中阻止它，这还不错，

1137
00:42:01,820 --> 00:42:03,440
这不是一个很好的例子，因为 我你

1138
00:42:03,440 --> 00:42:06,650
知道是我改写，假设

1139
00:42:06,650 --> 00:42:08,990
有应用程序说没有人

1140
00:42:08,990 --> 00:42:11,390
可以

1141
00:42:11,390 --> 00:42:14,150
在这个系统上拥有我的帐户，但我的

1142
00:42:14,150 --> 00:42:15,800
数据库没有 可以访问您是否

1143
00:42:15,800 --> 00:42:17,660
注册了这门课程，

1144
00:42:17,660 --> 00:42:18,180
因此交易

1145
00:42:18,180 --> 00:42:19,380
允许继续进行，

1146
00:42:19,380 --> 00:42:21,300
DA 说好的，确定您想在

1147
00:42:21,300 --> 00:42:23,490
先生那里这样做，我被允许这样做，但这是

1148
00:42:23,490 --> 00:42:25,530
这个高级概念 更高

1149
00:42:25,530 --> 00:42:27,300
级别的约束，但数据内容

1150
00:42:27,300 --> 00:42:28,230
对此一无所知，

1151
00:42:28,230 --> 00:42:30,480
因此事务可以保持一致

1152
00:42:30,480 --> 00:42:35,280
，因此我们无法阻止它，所以您

1153
00:42:35,280 --> 00:42:36,930
知道这

1154
00:42:36,930 --> 00:42:37,980
是我们不能在我们的数据库中做的事情

1155
00:42:37,980 --> 00:42:39,810
系统我们可以强制执行

1156
00:42:39,810 --> 00:42:40,950
完整性约束参照

1157
00:42:40,950 --> 00:42:42,390
完整性约束我们无法负担

1158
00:42:42,390 --> 00:42:45,050
水平的事情因为我们只是不知道

1159
00:42:45,050 --> 00:42:47,550
因为这是

1160
00:42:47,550 --> 00:42:51,200
我们无法在我们的系统中编纂的人类价值判断所以

1161
00:42:51,200 --> 00:42:53,040
没有什么可说的

1162
00:42:53,040 --> 00:42:54,360
这就像如果你

1163
00:42:54,360 --> 00:42:55,740
理解我在谈论的高层，

1164
00:42:55,740 --> 00:42:59,090
那就对了，这很重要，好吧，

1165
00:42:59,090 --> 00:43:01,080
所以我们今天关心的另一个人

1166
00:43:01,080 --> 00:43:03,240
也是隔离的，所以

1167
00:43:03,240 --> 00:43:05,070
隔离再次说，如果我们的

1168
00:43:05,070 --> 00:43:07,200
交易如果 我们如果我们让我们的用户

1169
00:43:07,200 --> 00:43:09,240
提交用户更多的事务，

1170
00:43:09,240 --> 00:43:12,240
我们希望他们每个人都运行

1171
00:43:12,240 --> 00:43:14,880
假设他们自己运行，

1172
00:43:14,880 --> 00:43:16,890
我们想要提供这个

1173
00:43:16,890 --> 00:43:19,410
保证的原因是它使

1174
00:43:19,410 --> 00:43:21,090
我们的应用程序编程变得更容易

1175
00:43:21,090 --> 00:43:23,220
如果是这种

1176
00:43:23,220 --> 00:43:24,720
情况，我们假设我们

1177
00:43:24,720 --> 00:43:26,580
对数据库具有独占访问权限，我们不必

1178
00:43:26,580 --> 00:43:30,120
担心我们

1179
00:43:30,120 --> 00:43:31,560
可以从其他事务中读取任何中间数据，

1180
00:43:31,560 --> 00:43:33,600
那么您知道我们只编写

1181
00:43:33,600 --> 00:43:35,220
单线程代码，这很好

1182
00:43:35,220 --> 00:43:41,640
它使生活更轻松，因此我们可以

1183
00:43:41,640 --> 00:43:43,650
通过在开始时再次执行我的稻草人方法来实现这一点，

1184
00:43:43,650 --> 00:43:45,000


1185
00:43:45,000 --> 00:43:45,870


1186
00:43:45,870 --> 00:43:48,300
实际上我只有一个线程，但我说我们

1187
00:43:48,300 --> 00:43:49,140
希望能够交错

1188
00:43:49,140 --> 00:43:52,350
事务以实现更好的效果

1189
00:43:52,350 --> 00:43:56,730
并发的并行性，所以我们

1190
00:43:56,730 --> 00:43:57,840
看看你是否希望能够保证这种

1191
00:43:57,840 --> 00:43:59,070
错觉属性，但我们仍然希望将其

1192
00:43:59,070 --> 00:44:01,950
交错，这变得困难

1193
00:44:01,950 --> 00:44:05,730
，所以我们将提供的方式

1194
00:44:05,730 --> 00:44:06,930
这样我们将

1195
00:44:06,930 --> 00:44:09,930
通过并发滚动协议来做到这一点，所以

1196
00:44:09,930 --> 00:44:10,980
我们在讨论索引锁存时已经稍微讨论了控制

1197
00:44:10,980 --> 00:44:12,270
协议，

1198
00:44:12,270 --> 00:44:14,910
也许我们会有一个

1199
00:44:14,910 --> 00:44:16,230
单一的数据结构并允许多个

1200
00:44:16,230 --> 00:44:17,490
线程同时访问它

1201
00:44:17,490 --> 00:44:20,010
我们使用我们的闩锁来强制

1202
00:44:20,010 --> 00:44:23,070
我们的数据结构的正确性所以

1203
00:44:23,070 --> 00:44:24,480
现在我们要做同样的事情但是

1204
00:44:24,480 --> 00:44:27,240
对于我们的数据库对象这就是为什么

1205
00:44:27,240 --> 00:44:28,710
我要区分锁

1206
00:44:28,710 --> 00:44:30,210
和闩锁所以闩锁保护

1207
00:44:30,210 --> 00:44:31,980
数据的内部 结构

1208
00:44:31,980 --> 00:44:33,690
锁会保护这些数据库

1209
00:44:33,690 --> 00:44:37,620
对象，所以你认为我会像

1210
00:44:37,620 --> 00:44:39,390
数据库

1211
00:44:39,390 --> 00:44:41,750
系统的交通警察一样调用它是坐着说

1212
00:44:41,750 --> 00:44:44,850
这个我们可以让这个操作继续这个

1213
00:44:44,850 --> 00:44:46,290
操作必须等待或者这个操作

1214
00:44:46,290 --> 00:44:48,150
必须中止它是它的 试图

1215
00:44:48,150 --> 00:44:50,100
找出如何以

1216
00:44:50,100 --> 00:44:53,040
我们最终获得正确状态的方式交错事物，因此

1217
00:44:53,040 --> 00:44:54,900


1218
00:44:54,900 --> 00:44:56,790
我们将关心两类协议，然后

1219
00:44:56,790 --> 00:44:59,490
这将是一个 总是会在下周

1220
00:44:59,490 --> 00:45:02,910
对意大利进行讨论，所以第

1221
00:45:02,910 --> 00:45:05,100
一个是悲观协议，

1222
00:45:05,100 --> 00:45:06,930
我们将假设我们的交易

1223
00:45:06,930 --> 00:45:08,330
将发生冲突并导致问题，

1224
00:45:08,330 --> 00:45:12,120
因此我们要求他们

1225
00:45:12,120 --> 00:45:15,780
在允许做任何正确的事情之前获取锁

1226
00:45:15,780 --> 00:45:17,460
假设你知道你很

1227
00:45:17,460 --> 00:45:18,570
悲观我们假设有很多

1228
00:45:18,570 --> 00:45:21,270
问题所以你你你你你

1229
00:45:21,270 --> 00:45:23,700
确保你

1230
00:45:23,700 --> 00:45:25,760
通过使用锁来确保事情按正确的顺序进行

1231
00:45:25,760 --> 00:45:27,780
顽固的贴纸巨魔是你

1232
00:45:27,780 --> 00:45:30,180
认为冲突很少

1233
00:45:30,180 --> 00:45:31,440
的地方 当我的事务不会

1234
00:45:31,440 --> 00:45:33,510
发生冲突时，与其让它们

1235
00:45:33,510 --> 00:45:34,980
在一开始就停顿并获取它的锁，

1236
00:45:34,980 --> 00:45:37,980
我只是让它们运行并

1237
00:45:37,980 --> 00:45:39,420
做它们想做的任何事情，然后当

1238
00:45:39,420 --> 00:45:41,970
它们提交时返回并弄清楚

1239
00:45:41,970 --> 00:45:43,260
这是否真的 无论是否存在冲突，都应该做正确的事情，

1240
00:45:43,260 --> 00:45:46,770
所以下周星期一的

1241
00:45:46,770 --> 00:45:47,910
课程将采用两阶段

1242
00:45:47,910 --> 00:45:48,330
锁定

1243
00:45:48,330 --> 00:45:49,680
，这是一个悲观的协议

1244
00:45:49,680 --> 00:45:51,330
下周星期三的课程将采用

1245
00:45:51,330 --> 00:45:52,890
时间戳排序 g 这被认为是一种

1246
00:45:52,890 --> 00:45:54,630
乐观的协议，而乐观的

1247
00:45:54,630 --> 00:45:56,520
鼓励目标协议实际上

1248
00:45:56,520 --> 00:46:00,360
在 1980 年代在 CMU 那里更好，

1249
00:46:00,360 --> 00:46:03,240
所以现在让我们看一些

1250
00:46:03,240 --> 00:46:04,740
真实的例子，开始

1251
00:46:04,740 --> 00:46:07,470
理解复杂性的实际含义，所以

1252
00:46:07,470 --> 00:46:09,990
这又是我的银行账户示例

1253
00:46:09,990 --> 00:46:12,540
，我们 有两个账户 a 和 B，它是

1254
00:46:12,540 --> 00:46:15,390
Andy 并且是博彩公司，所以我们想

1255
00:46:15,390 --> 00:46:16,710
从我的账户中转出 100 美元

1256
00:46:16,710 --> 00:46:18,930
到我的博彩公司账户，但

1257
00:46:18,930 --> 00:46:22,110
同时银行会采取行动

1258
00:46:22,110 --> 00:46:24,090
更新

1259
00:46:24,090 --> 00:46:25,440
所有银行的每月利息 账户，所以

1260
00:46:25,440 --> 00:46:27,360
我们要更新每个账户，

1261
00:46:27,360 --> 00:46:30,450
增加 6% 的利息 我所以交易

1262
00:46:30,450 --> 00:46:32,310
一个从看跌期权中取出

1263
00:46:32,310 --> 00:46:33,870
100 美元，然后

1264
00:46:33,870 --> 00:46:35,430
交易 2 只是计算

1265
00:46:35,430 --> 00:46:37,290
你通过增加 6% 来增加两个账户

1266
00:46:37,290 --> 00:46:41,130
因此，如果我们

1267
00:46:41,130 --> 00:46:43,260
再次假设两个银行账户都有 1000

1268
00:46:43,260 --> 00:46:45,000
美元，

1269
00:46:45,000 --> 00:46:46,500
并且我们希望在这两

1270
00:46:46,500 --> 00:46:48,690
笔交易中使用 EXCI，那么

1271
00:46:48,690 --> 00:46:50,400
我们对当前状态可能产生的结果是什么？

1272
00:46:50,400 --> 00:46:52,550
数据库

1273
00:46:52,550 --> 00:46:54,540
一切正常缩放我们有任意的

1274
00:46:54,540 --> 00:47:00,119
交错很多是正确的因为我们

1275
00:47:00,119 --> 00:47:02,220
可以让 t1 在一个

1276
00:47:02,220 --> 00:47:04,170
查询中运行然后切换到 t2

1277
00:47:04,170 --> 00:47:06,720
然后来回右有一堆

1278
00:47:06,720 --> 00:47:07,920
我们可以用这些

1279
00:47:07,920 --> 00:47:10,680
交错结束但重要的方式

1280
00:47:10,680 --> 00:47:13,290
不过要指出的是，

1281
00:47:13,290 --> 00:47:15,060
在我们

1282
00:47:15,060 --> 00:47:19,290
以任何可能的顺序执行事务 t1 和 t2 之后，要

1283
00:47:19,290 --> 00:47:21,540
知道我们的数据库状态是正确的，

1284
00:47:21,540 --> 00:47:23,339
当我们将两个

1285
00:47:23,339 --> 00:47:26,670
帐户加在一起时的最终结果应该是 2120，因为

1286
00:47:26,670 --> 00:47:27,839
我有一千 美元而不是

1287
00:47:27,839 --> 00:47:29,790
1000 美元，加起来

1288
00:47:29,790 --> 00:47:31,890
就是 2000 美元，然后第二

1289
00:47:31,890 --> 00:47:33,150
笔交易要增加 6% 的

1290
00:47:33,150 --> 00:47:36,599
利息，所以我们要保证

1291
00:47:36,599 --> 00:47:38,430
无论我们如何排序或交错我们的

1292
00:47:38,430 --> 00:47:40,349
操作，我们总是在

1293
00:47:40,349 --> 00:47:44,780
执行 t1 和 t2 后最后 最终得到 2120

1294
00:47:44,780 --> 00:47:46,829
所以这是

1295
00:47:46,829 --> 00:47:48,180
关于事务和数据库

1296
00:47:48,180 --> 00:47:50,130
系统的一个非常重要的属性，它

1297
00:47:50,130 --> 00:47:52,200
可能与您所了解或有

1298
00:47:52,200 --> 00:47:54,319
经验的方式略有不同

1299
00:47:54,319 --> 00:47:58,109
之前在我们这里讨论的数据库系统中进行并行编程，

1300
00:47:58,109 --> 00:48:01,380
即使 t1 可能

1301
00:48:01,380 --> 00:48:02,839
首先提交给数据系统，

1302
00:48:02,839 --> 00:48:06,210
然后是 t2，但不能保证

1303
00:48:06,210 --> 00:48:10,190
数据库系统首先

1304
00:48:10,190 --> 00:48:12,930
正确地运行 t1 以及为什么我们要 这样

1305
00:48:12,930 --> 00:48:14,819
做是因为我们可以有任何

1306
00:48:14,819 --> 00:48:16,650
可能的交错或任何

1307
00:48:16,650 --> 00:48:18,960
可能的排序，那么这

1308
00:48:18,960 --> 00:48:20,900
将使我们有更多

1309
00:48:20,900 --> 00:48:22,859
机会进行交错以获得更好的

1310
00:48:22,859 --> 00:48:27,359
并行性，如果我关心我的应用程序

1311
00:48:27,359 --> 00:48:28,920
绝对必须关心说好 t1

1312
00:48:28,920 --> 00:48:30,720
绝对必须退出 首先，

1313
00:48:30,720 --> 00:48:32,640
然后是 t2，您编写

1314
00:48:32,640 --> 00:48:35,310
该代码的方式是承认 t1，然后只有

1315
00:48:35,310 --> 00:48:36,420
当您恢复知识时才

1316
00:48:36,420 --> 00:48:37,800
意味着 t1 已提交，然后您提交

1317
00:48:37,800 --> 00:48:42,690
T 2 因为如果您现在

1318
00:48:42,690 --> 00:48:44,550
在实践中，如果您 提交 t1，

1319
00:48:44,550 --> 00:48:46,410
如果你知道这需要一分钟，那么你

1320
00:48:46,410 --> 00:48:47,880
提交 t2 这基本上是一样

1321
00:48:47,880 --> 00:48:50,310
的，但如果我在完全相同的时间坐在副手旁边，

1322
00:48:50,310 --> 00:48:52,710
那么数据

1323
00:48:52,710 --> 00:48:53,970
可以输入离开他们，无论如何它

1324
00:48:53,970 --> 00:48:56,240
想要

1325
00:48:56,420 --> 00:48:58,190
但我们会关心

1326
00:48:58,190 --> 00:49:01,160
那些对于任何任意交错我们

1327
00:49:01,160 --> 00:49:02,869
希望数据库的结束状态

1328
00:49:02,869 --> 00:49:04,910
等同于我们实际

1329
00:49:04,910 --> 00:49:06,529
执行这些事务的情况下，我们使用单个线程按叙利亚顺序执行这些事务，

1330
00:49:06,529 --> 00:49:09,380
t1

1331
00:49:09,380 --> 00:49:12,799
后跟 t2 或 t2 后跟 t1

1332
00:49:12,799 --> 00:49:13,760
一天的结束状态这必须看起来

1333
00:49:13,760 --> 00:49:17,599
像 Val 所以现在这意味着

1334
00:49:17,599 --> 00:49:19,190
我们可能

1335
00:49:19,190 --> 00:49:22,609
拥有的状态 a 和 B 的可能结果数量可能

1336
00:49:22,609 --> 00:49:25,309
不同，所以如果我说 t1

1337
00:49:25,309 --> 00:49:26,359
首先到 t2

1338
00:49:26,359 --> 00:49:30,230
我 将有 954 美元和 11

1339
00:49:30,230 --> 00:49:33,349
美元 66 美元和 B 但我去另一个订单

1340
00:49:33,349 --> 00:49:37,010
我将有 960 和 1160 但如果我

1341
00:49:37,010 --> 00:49:38,900
将这两个加在一起我总是得到

1342
00:49:38,900 --> 00:49:41,990
2120 这又

1343
00:49:41,990 --> 00:49:45,760
相当于 xu2 在 串行顺序

1344
00:49:46,000 --> 00:49:50,990
这个剪辑没问题 所以让我们实际

1345
00:49:50,990 --> 00:49:54,140
看看数据库看到什么 所以

1346
00:49:54,140 --> 00:49:56,299
这就是这被称为

1347
00:49:56,299 --> 00:49:58,279
我们的事务的时间表 以一种方式读取

1348
00:49:58,279 --> 00:50:00,019
这是

1349
00:50:00,019 --> 00:50:03,529
从上到下的时间，然后是每

1350
00:50:03,529 --> 00:50:04,490
一个 这里的列我们有

1351
00:50:04,490 --> 00:50:05,960
transa 动作，我们有

1352
00:50:05,960 --> 00:50:08,180
他们实际在做的操作，所以我调用

1353
00:50:08,180 --> 00:50:10,160
开始于 t1 我从一个拿取一百美元

1354
00:50:10,160 --> 00:50:12,109
，然后把一百个小时和 B

1355
00:50:12,109 --> 00:50:14,210
调用，然后我调用提交，然后现在附件 -

1356
00:50:14,210 --> 00:50:16,130
一次我做上下文切换 在这里，

1357
00:50:16,130 --> 00:50:17,869
现在我称它为 t1，它计算

1358
00:50:17,869 --> 00:50:19,490
对这些人的兴趣，因此

1359
00:50:19,490 --> 00:50:21,289
假设我们只有一个

1360
00:50:21,289 --> 00:50:23,119
线程可以使用单个程序计数器，

1361
00:50:23,119 --> 00:50:25,069
而我们实际上一次只能进行一个操作

1362
00:50:25,069 --> 00:50:27,619
，就像我们可以将它们交错

1363
00:50:27,619 --> 00:50:29,059
这些不同的交易，但在任何

1364
00:50:29,059 --> 00:50:32,089
给定的时间步，我们都会做一件事，所以

1365
00:50:32,089 --> 00:50:34,730
在这种情况下，如果我们 x2 t1 然后

1366
00:50:34,730 --> 00:50:36,980
是 t2，我们最终会

1367
00:50:36,980 --> 00:50:39,410
得到 a 和 B 的这个金额，如果他先问你 t2

1368
00:50:39,410 --> 00:50:41,390
然后是 t1 我们以这些结束

1369
00:50:41,390 --> 00:50:45,529
此处的金额再次与

1370
00:50:45,529 --> 00:50:48,049
此处的 954 与此处的 960 不匹配，因此它们在

1371
00:50:48,049 --> 00:50:49,970
技术上与您从有限的确切金额中了解的内容不同，

1372
00:50:49,970 --> 00:50:52,579


1373
00:50:52,579 --> 00:50:54,289
但从数据库协助的角度来看

1374
00:50:54,289 --> 00:50:55,460
，我们关心的是

1375
00:50:55,460 --> 00:50:57,470
您的交易 把它们都加起来，

1376
00:50:57,470 --> 00:51:00,230
你总是 s 得到 2120 所以这两个

1377
00:51:00,230 --> 00:51:01,549
交错是这两个

1378
00:51:01,549 --> 00:51:03,170
顺序仍然是彼此等效的

1379
00:51:03,170 --> 00:51:06,339
他们是正确的

1380
00:51:06,670 --> 00:51:17,920
是的 抱歉你的问题 你的问题是

1381
00:51:17,920 --> 00:51:19,630
如果你知道你有你在

1382
00:51:19,630 --> 00:51:21,490
完全相同的时间进行交易

1383
00:51:21,490 --> 00:51:22,720
你能做到吗？ 就像你可以

1384
00:51:22,720 --> 00:51:32,019
将它们结合起来是的，但没有人这样

1385
00:51:32,019 --> 00:51:33,880
做，我认为现在这会使事情复杂化

1386
00:51:33,880 --> 00:51:36,130
让我们

1387
00:51:36,130 --> 00:51:37,960
假设情况也是如此

1388
00:51:37,960 --> 00:51:41,019


1389
00:51:41,019 --> 00:51:42,220
真的这样做，所以

1390
00:51:42,220 --> 00:51:43,990
当我今天要在这里谈论时，

1391
00:51:43,990 --> 00:51:46,420
就像时间表是固定的一样，这意味着

1392
00:51:46,420 --> 00:51:48,069
我提前确切地知道

1393
00:51:48,069 --> 00:51:49,480
所有事务在真实系统中实际想要做什么，而

1394
00:51:49,480 --> 00:51:51,849
在真实系统中却不是

1395
00:51:51,849 --> 00:51:53,230
那样 就像你知道

1396
00:51:53,230 --> 00:51:54,670
交易显示他们正在

1397
00:51:54,670 --> 00:51:56,650
调用你知道客户端打开

1398
00:51:56,650 --> 00:51:58,450
连接调用开始然后它

1399
00:51:58,450 --> 00:51:59,859
开始执行一堆查询

1400
00:51:59,859 --> 00:52:01,329
你不知道在这种情况下下一个查询是什么在

1401
00:52:01,329 --> 00:52:04,869
这里有点推理

1402
00:52:04,869 --> 00:52:07,210
正确性 你一下子看到了所有的一切，

1403
00:52:07,210 --> 00:52:07,650


1404
00:52:07,650 --> 00:52:10,779
所以周一当我们谈论

1405
00:52:10,779 --> 00:52:11,529
两阶段锁定时

1406
00:52:11,529 --> 00:52:13,839
，这是一个动态的征服者协议

1407
00:52:13,839 --> 00:52:15,700
，你不知道

1408
00:52:15,700 --> 00:52:17,799
查询会提前什么，现在

1409
00:52:17,799 --> 00:52:20,289
有些情况下，如果你有一些

1410
00:52:20,289 --> 00:52:21,490
内省，但是

1411
00:52:21,490 --> 00:52:22,779
实际尝试做的应用程序然后你

1412
00:52:22,779 --> 00:52:24,519
实际上可以做你建议的事情，但这

1413
00:52:24,519 --> 00:52:37,509
很难，实际上没有人会做到

1414
00:52:37,509 --> 00:52:39,700
这一点，所以案例问题是

1415
00:52:39,700 --> 00:52:41,950
我在发送的数据之前说哪个是正确的

1416
00:52:41,950 --> 00:52:44,710
，这8个读和写水

1417
00:52:44,710 --> 00:52:47,589
等于一个减号 1对是的，这将被

1418
00:52:47,589 --> 00:52:49,210
翻译成阅读，然后是对的，

1419
00:52:49,210 --> 00:53:05,740
我会在一秒钟内看到是的，是的，

1420
00:53:05,740 --> 00:53:09,539
我们会得到那个是的问题，所以

1421
00:53:09,539 --> 00:53:12,279
这个8等于负100它

1422
00:53:12,279 --> 00:53:13,390
实际上看起来像什么

1423
00:53:13,390 --> 00:53:15,220
程序逻辑我会说在

1424
00:53:15,220 --> 00:53:17,470
你正在阅读的时候做一个获取一个副本我的本地

1425
00:53:17,470 --> 00:53:20,230
变量然后我可以操作它

1426
00:53:20,230 --> 00:53:21,820
并将它写回数据库所以

1427
00:53:21,820 --> 00:53:23,410
这些事务中的每一个都有

1428
00:53:23,410 --> 00:53:24,609
自己的不共享的本地变量

1429
00:53:24,609 --> 00:53:30,250
这些 问题你能相信

1430
00:53:30,250 --> 00:53:31,390
事务之间的操作是的，

1431
00:53:31,390 --> 00:53:47,830
我们会完全到达那里 是的问题

1432
00:53:47,830 --> 00:53:50,320
是如果我有两个事务

1433
00:53:50,320 --> 00:53:51,580
接触完全不同的对象

1434
00:53:51,580 --> 00:53:56,530
而不是发布对象我是否仍然需要

1435
00:53:56,530 --> 00:54:04,840
序列化这个我的意思所以对于

1436
00:54:04,840 --> 00:54:07,030
这个我' 我只是尝试显示等效性，如果

1437
00:54:07,030 --> 00:54:09,280
它们清楚地触及三件事并且

1438
00:54:09,280 --> 00:54:10,720
没有冲突，那么你可以

1439
00:54:10,720 --> 00:54:11,410
以任何你想要的方式交错它们

1440
00:54:11,410 --> 00:54:20,050
绝对是的她的问题是我

1441
00:54:20,050 --> 00:54:21,100
怎么知道另一笔交易是否正在

1442
00:54:21,100 --> 00:54:22,230
触及我再次触及的同一件事

1443
00:54:22,230 --> 00:54:26,050
，但这是一个 高级

1444
00:54:26,050 --> 00:54:27,580
示例 数据库种子和读取和写入

1445
00:54:27,580 --> 00:54:29,859
所以我这样做 我读取一个对象 a

1446
00:54:29,859 --> 00:54:32,320
你读取一个对象 a 为了让

1447
00:54:32,320 --> 00:54:34,690
我满足您的读取请求 让我

1448
00:54:34,690 --> 00:54:37,330
为您读取它以便我看到所有内容 但

1449
00:54:37,330 --> 00:54:39,010
我看不到高级别的东西，比如我

1450
00:54:39,010 --> 00:54:41,560
看不到你的意思，你

1451
00:54:41,560 --> 00:54:43,060
将把 a 的值

1452
00:54:43,060 --> 00:54:45,900
加到它的 6% 上，

1453
00:54:46,109 --> 00:54:48,850
所以现在每个人

1454
00:54:48,850 --> 00:54:50,290
都可以 交错

1455
00:54:50,290 --> 00:54:52,780
这些交易 离子实际上是操作

1456
00:54:52,780 --> 00:54:54,340
，我们已经涵盖了这一点，我们

1457
00:54:54,340 --> 00:54:56,290
想要这样做，因为这很慢，而且我们

1458
00:54:56,290 --> 00:55:00,100
有很多 CPU 内核，所以

1459
00:55:00,100 --> 00:55:02,970
这里的想法再次是，而不是让

1460
00:55:02,970 --> 00:55:05,290
您知道我们是否必须转到磁盘以 获取

1461
00:55:05,290 --> 00:55:07,750
某些东西或等待获取某些东西的闩锁

1462
00:55:07,750 --> 00:55:09,730
我们可以让一个事务

1463
00:55:09,730 --> 00:55:11,230
停顿 另一个事务继续

1464
00:55:11,230 --> 00:55:12,180
运行并继续前进，

1465
00:55:12,180 --> 00:55:14,230
因此我们试图找出一个时间表

1466
00:55:14,230 --> 00:55:16,420
或交错，以便我们最大限度地

1467
00:55:16,420 --> 00:55:19,030
提高系统的性能，我们得到

1468
00:55:19,030 --> 00:55:21,490
最好地利用我们的硬件 所以

1469
00:55:21,490 --> 00:55:24,609
如果我们现在回到我们的例子所以

1470
00:55:24,609 --> 00:55:25,900
现在我让我们的事务保持

1471
00:55:25,900 --> 00:55:29,020
正确开始需要 200

1472
00:55:29,020 --> 00:55:31,420
然后进行上下文切换 t2

1473
00:55:31,420 --> 00:55:33,970
开始将计算 6% 放在

1474
00:55:33,970 --> 00:55:36,040
嘿然后我们回去 然后把

1475
00:55:36,040 --> 00:55:37,780
一百美元放回 B 并回到

1476
00:55:37,780 --> 00:55:39,579
这里计算三英寸

1477
00:55:39,579 --> 00:55:42,130
然后我们继续提交所以现在再次现在

1478
00:55:42,130 --> 00:55:43,869
它不是一个转弯实际上想要

1479
00:55:43,869 --> 00:55:46,390
一次完整地运行

1480
00:55:46,390 --> 00:55:47,619
我们现在能够实际运行 terleave

1481
00:55:47,619 --> 00:55:49,930
things 和这里的这个例子 这是

1482
00:55:49,930 --> 00:55:51,670
正确的 这很好 因为这

1483
00:55:51,670 --> 00:55:55,089


1484
00:55:55,089 --> 00:55:57,790
相当于我们事务的串行排序 数据库的结束状态

1485
00:55:57,790 --> 00:56:01,540
是等价

1486
00:56:01,540 --> 00:56:04,210
的 所以这里要指出的关键

1487
00:56:04,210 --> 00:56:05,950
是为什么这 结果

1488
00:56:05,950 --> 00:56:07,720
没问题，然后我们最终得到的结果是

1489
00:56:07,720 --> 00:56:10,000
，我们总是确保我们

1490
00:56:10,000 --> 00:56:13,300
先在 t1 上对给定

1491
00:56:13,300 --> 00:56:15,700
对象进行操作，然后再

1492
00:56:15,700 --> 00:56:19,030
在 t2 上对同一对象进行操作，所以我在 a 上拿了

1493
00:56:19,030 --> 00:56:21,460
100 盎司，然后 我让你

1494
00:56:21,460 --> 00:56:23,890
对 a 感兴趣，然后我把它放在一边，然后我把它放在

1495
00:56:23,890 --> 00:56:24,940
B 上，然后计算机

1496
00:56:24,940 --> 00:56:31,599
享受一些节拍，所以对于

1497
00:56:31,599 --> 00:56:33,490
这个交错，如果我们违反了

1498
00:56:33,490 --> 00:56:36,369
它，所以我从 a 中取出 1 美元，我计算出

1499
00:56:36,369 --> 00:56:38,200
有兴趣 a 然后我可以满足

1500
00:56:38,200 --> 00:56:40,740
B 的利息，然后我把 200 美元放回 B

1501
00:56:40,740 --> 00:56:44,319
所以现在在这种情况下，当我

1502
00:56:44,319 --> 00:56:46,000
将这两个值加在一起时，我没有得到

1503
00:56:46,000 --> 00:56:51,460
21 28 2014 所以银行损失了你知道 10 美元

1504
00:56:51,460 --> 00:56:57,010
或 606 美元一团 现在这是

1505
00:56:57,010 --> 00:56:58,270
数百美元，但我 这是十亿

1506
00:56:58,270 --> 00:56:59,859
美元 好吧伙计们 这是你的帐户

1507
00:56:59,859 --> 00:57:01,510
一百美元很多 但就像你

1508
00:57:01,510 --> 00:57:03,280
知道的那样 这就是为什么我们要

1509
00:57:03,280 --> 00:57:04,420
保证我们始终对交易具有正确性

1510
00:57:04,420 --> 00:57:06,310
特别是当你正在

1511
00:57:06,310 --> 00:57:09,460
做并且结束涉及金钱时 有

1512
00:57:09,460 --> 00:57:11,290
一个着名的例子 几年 以前在

1513
00:57:11,290 --> 00:57:13,089
一些比特币交易所我忘记

1514
00:57:13,089 --> 00:57:15,400
了世界上哪里运行 MongoDB MongoDB

1515
00:57:15,400 --> 00:57:16,960
当时没有支持

1516
00:57:16,960 --> 00:57:19,329
交易，所以一些黑客

1517
00:57:19,329 --> 00:57:22,599
发现你可以

1518
00:57:22,599 --> 00:57:25,510
操纵 API 并让它耗尽

1519
00:57:25,510 --> 00:57:29,400
每个人的帐户，所以 他们

1520
00:57:29,400 --> 00:57:31,990
在一天之内消灭了比特币交易所，因为

1521
00:57:31,990 --> 00:57:34,300
MongoDB 没有进行交易，这

1522
00:57:34,300 --> 00:57:38,500
是故事的一部分，但他们没有

1523
00:57:38,500 --> 00:57:39,520
交易，这是一个坏主意，

1524
00:57:39,520 --> 00:57:42,160
所以回到他的观点，

1525
00:57:42,160 --> 00:57:43,450
如果数据库系统真的再次看到

1526
00:57:43,450 --> 00:57:44,560
它会怎样 没有看到这些更高级别的

1527
00:57:44,560 --> 00:57:46,839
操作，它只是正确地看到了这些原因

1528
00:57:46,839 --> 00:57:47,529


1529
00:57:47,529 --> 00:57:49,579
，因此基本上我们要做的是

1530
00:57:49,579 --> 00:57:51,739
确保对于任何

1531
00:57:51,739 --> 00:57:54,859
进行读取或写入或读取的对象 在一个

1532
00:57:54,859 --> 00:57:56,839
对象上，如果另一个事务正在

1533
00:57:56,839 --> 00:57:58,759
做同样的事情，我们总是

1534
00:57:58,759 --> 00:58:01,999
以正确的顺序进行以确定我们的

1535
00:58:01,999 --> 00:58:05,479
时间表是否正确，因此我们

1536
00:58:05,479 --> 00:58:06,440
将弄清楚这一点

1537
00:58:06,440 --> 00:58:07,700
的方式我们将找到正确性

1538
00:58:07,700 --> 00:58:08,989
的方式 我们今天在

1539
00:58:08,989 --> 00:58:12,559
这里谈论的是，如果它等同于串行调度之一，那么任何

1540
00:58:12,559 --> 00:58:14,739
任意操作顺序的调度都是

1541
00:58:14,739 --> 00:58:19,190
正确的，

1542
00:58:19,190 --> 00:58:22,339
所以

1543
00:58:22,339 --> 00:58:23,420
我们已经讨论过的 Sira 调度 Serie

1544
00:58:23,420 --> 00:58:24,589
调度只是说我们实际上

1545
00:58:24,589 --> 00:58:26,450
是在一个之后进行交易 另一个并且没有

1546
00:58:26,450 --> 00:58:28,460
交错，然后等效的

1547
00:58:28,460 --> 00:58:31,069
睡眠策略表示，如果数据库的最终

1548
00:58:31,069 --> 00:58:37,460
状态是对象的一个，则

1549
00:58:37,460 --> 00:58:39,589
该对象是等效的，或者它

1550
00:58:39,589 --> 00:58:42,319
实际上具有另一个数据库状态的相同值，而

1551
00:58:42,319 --> 00:58:45,130
不是它们等效的，

1552
00:58:45,130 --> 00:58:51,229
因此调度的排序 好吧，它

1553
00:58:51,229 --> 00:58:52,999
可能相当于至少一个

1554
00:58:52,999 --> 00:58:55,190
完全一个串行排序

1555
00:58:55,190 --> 00:58:57,289


1556
00:58:57,289 --> 00:58:59,450
如果数据库仍然是相同的

1557
00:58:59,450 --> 00:59:01,940
语句但给定的时间表可以，我不完全是一个或多个串行排序 是

1558
00:59:01,940 --> 00:59:03,940
正确的，它仍然可以

1559
00:59:03,940 --> 00:59:06,559
通过等效于任何可能的

1560
00:59:06,559 --> 00:59:10,160
串行排序来序列化，所以这是

1561
00:59:10,160 --> 00:59:11,269
我们要关心的属性形式，用于

1562
00:59:11,269 --> 00:59:13,729
我们的日程安排可串行化好吧，它

1563
00:59:13,729 --> 00:59:15,499
只是说一个日程安排

1564
00:59:15,499 --> 00:59:16,460
相当于一些串行执行

1565
00:59:16,460 --> 00:59:18,829
不 不管它必须是哪一个，它

1566
00:59:18,829 --> 00:59:21,380
必须是其中之一，如果它

1567
00:59:21,380 --> 00:59:22,880
等同于串行排序

1568
00:59:22,880 --> 00:59:24,049
那么我们正在查看的任何时间表都

1569
00:59:24,049 --> 00:59:25,630
被认为是可序列化的，

1570
00:59:25,630 --> 00:59:27,920
这是您

1571
00:59:27,920 --> 00:59:29,390
想要获得的黄金标准 像这样的数据库网络系统，

1572
00:59:29,390 --> 00:59:31,690
这是保证

1573
00:59:31,690 --> 00:59:33,799
几乎保证所有

1574
00:59:33,799 --> 00:59:36,019
您可能想要的保护，唯一

1575
00:59:36,019 --> 00:59:37,729
不保证的是，如果您的

1576
00:59:37,729 --> 00:59:39,259
事务是 t1 首先

1577
00:59:39,259 --> 00:59:42,069
出现，然后是 t2 t1 将首先提交

1578
00:59:42,069 --> 00:59:44,299
，这称为严格序列化能力

1579
00:59:44,299 --> 00:59:46,579
或外部一致性我们不

1580
00:59:46,579 --> 00:59:47,809
关心，这里大多数

1581
00:59:47,809 --> 00:59:49,039
系统不提供我所知道的唯一提供的系统

1582
00:59:49,039 --> 00:59:50,989
是谷歌扳手

1583
00:59:50,989 --> 00:59:53,749
，他们需要它一些哟 你知道

1584
00:59:53,749 --> 00:59:56,390
一些全球广告的事情

1585
00:59:56,390 --> 00:59:58,249
，如果他们说

1586
00:59:58,249 --> 00:59:59,599
他们得到的支持消毒能力

1587
00:59:59,599 --> 00:59:59,930


1588
00:59:59,930 --> 01:00:01,750
你得到了我在这里定义的东西，

1589
01:00:01,750 --> 01:00:04,240


1590
01:00:04,240 --> 01:00:08,539
那么如果你

1591
01:00:08,539 --> 01:00:10,099
从并行编程中获得背景，那么再来一次。

1592
01:00:10,099 --> 01:00:11,930
这可能看起来有点奇怪，我

1593
01:00:11,930 --> 01:00:15,039
可以说好吧，我可以让

1594
01:00:15,039 --> 01:00:17,660
你知道数据库没有一个单一的

1595
01:00:17,660 --> 01:00:19,010
状态，我可以说这正是

1596
01:00:19,010 --> 01:00:20,480


1597
01:00:20,480 --> 01:00:21,950
确定它是否正确正确的应该是什么，它可能是

1598
01:00:21,950 --> 01:00:24,740
任何可能的事情 我们之所以

1599
01:00:24,740 --> 01:00:26,319
要这样做，是因为如果我们有

1600
01:00:26,319 --> 01:00:28,369
多种选择来

1601
01:00:28,369 --> 01:00:29,750
交织我们的操作和

1602
01:00:29,750 --> 01:00:32,059
我们

1603
01:00:32,059 --> 01:00:36,529
渴望实现的多个串行排序，那么这给了

1604
01:00:36,529 --> 01:00:38,270
我们更多的选择来决定我们想要的方式

1605
01:00:38,270 --> 01:00:39,349
为我们的交易安排我们的操作，

1606
01:00:39,349 --> 01:00:43,880
以便更好地理解这一点，

1607
01:00:43,880 --> 01:00:45,950
我们现在需要一种正式的方法

1608
01:00:45,950 --> 01:00:47,630
来确定发生冲突意味着什么，

1609
01:00:47,630 --> 01:00:49,430
这可能会违反交易的串行

1610
01:00:49,430 --> 01:00:50,690
排序或先生谎言的能力

1611
01:00:50,690 --> 01:00:53,359
ion 所以我们要说的是，如果

1612
01:00:53,359 --> 01:00:54,829
两个事务或两个操作

1613
01:00:54,829 --> 01:00:57,319


1614
01:00:57,319 --> 01:00:58,819
同时由不同的事务运行，

1615
01:00:58,819 --> 01:01:01,730
并且它们都

1616
01:01:01,730 --> 01:01:03,859
在同一个对象上运行并且至少有一个对象，那么它们就会发生冲突

1617
01:01:03,859 --> 01:01:09,890
这些操作是正确的，所以

1618
01:01:09,890 --> 01:01:11,240
我们要关心的异常有三种类型

1619
01:01:11,240 --> 01:01:14,210
我们

1620
01:01:14,210 --> 01:01:17,059
有读写读写 再次写入 你知道读读

1621
01:01:17,059 --> 01:01:21,829
冲突 是的 不管

1622
01:01:21,829 --> 01:01:23,480
谁在乎你读什么

1623
01:01:23,480 --> 01:01:25,490
我读什么 我们读到同样的事情

1624
01:01:25,490 --> 01:01:28,220
，谁在乎谁在乎我们什么时候有

1625
01:01:28,220 --> 01:01:29,359
权限，什么时候是操作之一，

1626
01:01:29,359 --> 01:01:30,890
当我们遇到问题时，我们就知道了

1627
01:01:30,890 --> 01:01:33,230
，所以让我们

1628
01:01:33,230 --> 01:01:35,599
逐个逐一讨论，所以第一个是

1629
01:01:35,599 --> 01:01:38,390
读写冲突。 对，这

1630
01:01:38,390 --> 01:01:40,339
有时也被称为可重复

1631
01:01:40,339 --> 01:01:42,170
读取，所以假设我有两个

1632
01:01:42,170 --> 01:01:44,690
事务 t1 t2 t1 屏幕到读取

1633
01:01:44,690 --> 01:01:46,940
或刀，然后只再次读取 t2

1634
01:01:46,940 --> 01:01:48,589
将通过写入或名称读取文件

1635
01:01:48,589 --> 01:01:51,829
所以假设我实际上运行这个 t1

1636
01:01:51,829 --> 01:01:54,260
开始做 rea  d 从

1637
01:01:54,260 --> 01:01:56,000
我的银行账户中取出 10 美元，然后有一个

1638
01:01:56,000 --> 01:01:59,270
上下文，我们开始运行 t2 t2

1639
01:01:59,270 --> 01:02:02,480
读取 10 美元，这很好，

1640
01:02:02,480 --> 01:02:05,450
但随后它写回 19 美元，然后它继续

1641
01:02:05,450 --> 01:02:08,299
前进并提交，我们回到

1642
01:02:08,299 --> 01:02:09,890
你的知识，但从 数据库

1643
01:02:09,890 --> 01:02:10,970
系统说我们的事务已

1644
01:02:10,970 --> 01:02:13,820
提交，但现在我们的事务

1645
01:02:13,820 --> 01:02:15,470
将联系开关

1646
01:02:15,470 --> 01:02:18,890
切换回 t1 t1 现在它读取并再次

1647
01:02:18,890 --> 01:02:23,510
返回 19 但我第一次读取

1648
01:02:23,510 --> 01:02:26,720
时得到 10 所以我试图阅读 相同的

1649
01:02:26,720 --> 01:02:28,700
对象 我没有得到相同的价值

1650
01:02:28,700 --> 01:02:31,100
所以我在重复我们试图

1651
01:02:31,100 --> 01:02:32,570
阅读的东西

1652
01:02:32,570 --> 01:02:34,550
如果

1653
01:02:34,550 --> 01:02:36,230
我们试图保证隔离

1654
01:02:36,230 --> 01:02:39,350
和我们的交易，我不会一遍又一遍地看到相同的东西 不应该

1655
01:02:39,350 --> 01:02:41,270
在这里看到这个变化，因为如果

1656
01:02:41,270 --> 01:02:43,070
我们在意甲或

1657
01:02:43,070 --> 01:02:45,950
在 t1 期间运行它应该完全运行

1658
01:02:45,950 --> 01:02:48,340
然后完成然后 t2 伊朗会

1659
01:02:48,340 --> 01:02:50,900
正确，这样就不会在

1660
01:02:50,900 --> 01:02:55,700
串行订单下发生下一个冲突是 写

1661
01:02:55,700 --> 01:02:57,700
读有时也称为 di  rty

1662
01:02:57,700 --> 01:03:00,860
这么读，所以现在 T 我们读一个文件，

1663
01:03:00,860 --> 01:03:02,510
我写了一个 A，老师

1664
01:03:02,510 --> 01:03:03,800
也会做一个读者名字，然后是

1665
01:03:03,800 --> 01:03:07,400
一个名为 T 的作者，一个读鸡蛋看到 10 美元，然后它

1666
01:03:07,400 --> 01:03:12,350
写回 12 美元，现在 t2 读 a 并且它

1667
01:03:12,350 --> 01:03:14,240
看到第一个人投入的 12 美元，

1668
01:03:14,240 --> 01:03:17,950
但现在它写回了 14 美元，

1669
01:03:17,950 --> 01:03:20,810
然后幽灵还没有提交，然后

1670
01:03:20,810 --> 01:03:22,910
你知道我们从数据库系统得到了确认，

1671
01:03:22,910 --> 01:03:23,840
说是的，你

1672
01:03:23,840 --> 01:03:24,920
承诺了，你很高兴，

1673
01:03:24,920 --> 01:03:26,990
但现在我们做了 我们

1674
01:03:26,990 --> 01:03:29,390
回到这里的上下文，现在我们的第一个人

1675
01:03:29,390 --> 01:03:32,450
中止了所以他说没有部分

1676
01:03:32,450 --> 01:03:35,360
事务所以这个人必须中止所以

1677
01:03:35,360 --> 01:03:39,110
我们需要回滚我们的更新但

1678
01:03:39,110 --> 01:03:41,360
问题是这里的另一个事务

1679
01:03:41,360 --> 01:03:44,330
已经读取了我的更新然后 一个

1680
01:03:44,330 --> 01:03:45,890
承诺并且它持有外部

1681
01:03:45,890 --> 01:03:48,050
世界但是是的，当我读到一个我卖了我

1682
01:03:48,050 --> 01:03:50,990
看到 $12 但这不应该发生，

1683
01:03:50,990 --> 01:03:53,180
因为我们不能再次这是一个

1684
01:03:53,180 --> 01:03:55,490
暂时不一致的不一致我们

1685
01:03:55,490 --> 01:03:59,570
对 a 进行了更改，这意味着我们必须

1686
01:03:59,570 --> 01:04:00,860
使 改变是为了让你

1687
01:04:00,860 --> 01:04:02,480
知道 数据库的试点更改，但

1688
01:04:02,480 --> 01:04:04,010
没有人应该能够看到该

1689
01:04:04,010 --> 01:04:05,180
更改，因为我们的事务没有

1690
01:04:05,180 --> 01:04:06,830
提交，而且因为我们

1691
01:04:06,830 --> 01:04:09,050
现在中止了，我们向外界泄漏了一些

1692
01:04:09,050 --> 01:04:10,340
不

1693
01:04:10,340 --> 01:04:15,860
应该出现的内容 最后一个冲突是写

1694
01:04:15,860 --> 01:04:17,750
权限 这是覆盖

1695
01:04:17,750 --> 01:04:20,540
未提交的数据，所以 t1

1696
01:04:20,540 --> 01:04:23,870
在 10 美元的看跌期权上做对了 t2 没有读取对

1697
01:04:23,870 --> 01:04:26,560
19 美元的看跌期权的写入而不读取它然后

1698
01:04:26,560 --> 01:04:28,840
日期 B 输入一个安迪，然后在

1699
01:04:28,840 --> 01:04:31,780
这里 t2 t1 再次开始运行

1700
01:04:31,780 --> 01:04:35,860
并写入 海狸，所以现在当

1701
01:04:35,860 --> 01:04:38,020
我们提交问题时，我

1702
01:04:38,020 --> 01:04:42,340
有两个对象 a 和 B，所以对于

1703
01:04:42,340 --> 01:04:46,000
a，我看到 T 放入其中的写入

1704
01:04:46,000 --> 01:04:47,490
它投入了 19 美元，

1705
01:04:47,490 --> 01:04:50,830
但对于对象 B，我是 看到

1706
01:04:50,830 --> 01:04:53,290
贾斯汀比伯，因为那是 t1 输入的内容，所以

1707
01:04:53,290 --> 01:04:55,390
我有一个被撕毁的日期

1708
01:04:55,390 --> 01:04:58,150
，我有我有两个对象的数据，

1709
01:04:58,150 --> 01:04:59,620
它们已经被两个不同的事务修改，

1710
01:04:59,620 --> 01:05:01,540
而它们都不应该

1711
01:05:01,540 --> 01:05:04,420
被一个事务原子修改

1712
01:05:04,420 --> 01:05:08,140
，这个 发生是因为你知道 这个

1713
01:05:08,140 --> 01:05:10,090
家伙必须去跑，而

1714
01:05:10,090 --> 01:05:12,430
这家伙还在跑步，

1715
01:05:12,430 --> 01:05:13,690
如果我们试图

1716
01:05:13,690 --> 01:05:18,070
保证你看到行排序，那不应该发生，所以现在

1717
01:05:18,070 --> 01:05:20,260
考虑到这些冲突，我们需要

1718
01:05:20,260 --> 01:05:21,850
更正式地理解你

1719
01:05:21,850 --> 01:05:22,930
知道她是如何证明是否 有些东西

1720
01:05:22,930 --> 01:05:26,200
实际上是可以消毒的，所以为了

1721
01:05:26,200 --> 01:05:28,210
时间，我要跳过复杂的可

1722
01:05:28,210 --> 01:05:31,030
实现性，或者抱歉，我们

1723
01:05:31,030 --> 01:05:31,960
确实知道冷静，让我们乌龟眼睛

1724
01:05:31,960 --> 01:05:33,280
回顾一下，我要跳过用户

1725
01:05:33,280 --> 01:05:35,980
谎言能力复杂的可用性

1726
01:05:35,980 --> 01:05:38,410
这就是你需要的 要

1727
01:05:38,410 --> 01:05:41,980
知道作业的内容 我将在 Piazza 上张贴

1728
01:05:41,980 --> 01:05:43,780
去年上一堂课的讲座链接 上面讲

1729
01:05:43,780 --> 01:05:44,920
的我们的生存能力是什么

1730
01:05:44,920 --> 01:05:46,990
我做的

1731
01:05:46,990 --> 01:05:48,190
材料与封面相同，但我们

1732
01:05:48,190 --> 01:05:51,700
在这个时间最合适 八十个

1733
01:05:51,700 --> 01:05:52,930
系统会尝试给你这个，如果

1734
01:05:52,930 --> 01:05:54,160
他们说这些支持利用

1735
01:05:54,160 --> 01:05:55,150
必须的东西或事务 可

1736
01:05:55,150 --> 01:05:56,650
序列化的可序列化隔离

1737
01:05:56,650 --> 01:05:59,020
级别 他们会给你这个 没人做

1738
01:05:59,020 --> 01:06:00,430
这个 因为这需要

1739
01:06:00,430 --> 01:06:01,900
高级信息 关于

1740
01:06:01,900 --> 01:06:03,610
应用程序试图做什么的信息，我们不能

1741
01:06:03,610 --> 01:06:07,360
自动得到它，所以现在

1742
01:06:07,360 --> 01:06:09,700
我们要找到一个新术语，并

1743
01:06:09,700 --> 01:06:11,590
说两个计划被认为

1744
01:06:11,590 --> 01:06:13,960
是冲突等价的，当且仅当

1745
01:06:13,960 --> 01:06:16,030
它们参与 同一组

1746
01:06:16,030 --> 01:06:18,340
操作和事务同时运行

1747
01:06:18,340 --> 01:06:21,460
，然后每对

1748
01:06:21,460 --> 01:06:24,160
冲突事务都

1749
01:06:24,160 --> 01:06:26,320
以相同的方式排序，因此

1750
01:06:26,320 --> 01:06:27,490
当它们实际尝试更新时，冲突事务再次

1751
01:06:27,490 --> 01:06:29,410
变为

1752
01:06:29,410 --> 01:06:30,580
以对象

1753
01:06:30,580 --> 01:06:33,400
速率进行读取或写入 事务要么读要么

1754
01:06:33,400 --> 01:06:35,260
写，要么读或写，

1755
01:06:35,260 --> 01:06:36,340
他们总是必须至少有一个

1756
01:06:36,340 --> 01:06:39,340
权利，所以我们会说调度s是

1757
01:06:39,340 --> 01:06:40,450
冲突可序列化的，

1758
01:06:40,450 --> 01:06:42,460
如果它是一些串行调度的补充，

1759
01:06:42,460 --> 01:06:47,890
那么我们要弄清楚的方式

1760
01:06:47,890 --> 01:06:49,060
如何通过交换未完成操作的顺序来确定

1761
01:06:49,060 --> 01:06:51,820
某些复杂的事情是否有责任，

1762
01:06:51,820 --> 01:06:53,770


1763
01:06:53,770 --> 01:06:55,360
这个想法是

1764
01:06:55,360 --> 01:06:57,580
我们可以对操作执行这些交换步骤

1765
01:06:57,580 --> 01:07:00,160
，这将推动

1766
01:07:00,160 --> 01:07:01,750
一堆操作 一个事务的顶部操作

1767
01:07:01,750 --> 01:07:03,370
将一系列操作放在

1768
01:07:03,370 --> 01:07:04,780
另一个事务的底部，直到

1769
01:07:04,780 --> 01:07:08,080
我们最终得到一个串行订单，

1770
01:07:08,080 --> 01:07:09,400
所以回到这个例子这里，我们

1771
01:07:09,400 --> 01:07:10,990
对文件进行读取，写入 A 并

1772
01:07:10,990 --> 01:07:13,630
读取花生 B 我在 B 上为 t1 和 t2 读取的文件，

1773
01:07:13,630 --> 01:07:16,990
所以我们在这里我们想在

1774
01:07:16,990 --> 01:07:18,820
这里开始交换，所以我们在 B 上读取并

1775
01:07:18,820 --> 01:07:22,030
在 a 上写入所以在这种情况下，他们

1776
01:07:22,030 --> 01:07:24,160
没有接触同一个对象，所以我可以

1777
01:07:24,160 --> 01:07:25,930
继续交换 他们的顺序我可以

1778
01:07:25,930 --> 01:07:27,850
在 B 上读取读取发生在

1779
01:07:27,850 --> 01:07:30,460
对同一件事的写入之前发生在下一个这里

1780
01:07:30,460 --> 01:07:32,200
B 上的读取可以在读取 A 之前

1781
01:07:32,200 --> 01:07:35,170
发生我可以交换他们的顺序现在很好

1782
01:07:35,170 --> 01:07:36,160
我可以做同样的事情还有

1783
01:07:36,160 --> 01:07:38,110
另一个 B 上的重写可能发生

1784
01:07:38,110 --> 01:07:40,540
在交换上写入的读取之前，

1785
01:07:40,540 --> 01:07:42,010
B 上的权利可能发生在可交换上的读取上，

1786
01:07:42,010 --> 01:07:45,040
所以我可以这样做，所以现在我

1787
01:07:45,040 --> 01:07:48,070
最终得到一个串行订购，它

1788
01:07:48,070 --> 01:07:51,820
在这里有设备 所以这

1789
01:07:51,820 --> 01:07:53,710
是你不能这样做的，所以在

1790
01:07:53,710 --> 01:07:55,660
这种情况下，我在一个文件上写了一个

1791
01:07:55,660 --> 01:07:57,700
写 在一个我不能交换他们的订单

1792
01:07:57,700 --> 01:08:00,310
所以因此它不等同

1793
01:08:00,310 --> 01:08:04,150
于连续订购这很

1794
01:08:04,150 --> 01:08:06,820
简单但当然现在

1795
01:08:06,820 --> 01:08:08,620
这有点像愚蠢的做正确的事情

1796
01:08:08,620 --> 01:08:10,960
就像如果我有很多交易并且

1797
01:08:10,960 --> 01:08:13,000
我有一个 很多操作这

1798
01:08:13,000 --> 01:08:15,550
对我来说会非常昂贵，所以我们

1799
01:08:15,550 --> 01:08:18,160
需要一种更好的方法来

1800
01:08:18,160 --> 01:08:19,810
确定某些东西是否

1801
01:08:19,810 --> 01:08:21,640
可以序列化，而不必这样

1802
01:08:21,640 --> 01:08:23,830
做交换的事情，

1803
01:08:23,830 --> 01:08:24,819
所以我们可以这样做 通过

1804
01:08:24,819 --> 01:08:27,700
依赖图和教科书，我

1805
01:08:27,700 --> 01:08:30,100
认为这称为优先图，因此

1806
01:08:30,100 --> 01:08:32,229
依赖图只是说我们

1807
01:08:32,229 --> 01:08:34,149
为日程表中的每个事务都有一个节点，

1808
01:08:34,149 --> 01:08:37,000


1809
01:08:37,000 --> 01:08:39,850
如果

1810
01:08:39,850 --> 01:08:41,500
在一个事务中有一些操作，那么两个事务之间就会有一个边缘

1811
01:08:41,500 --> 01:08:43,720
与另一个交易中的另一个操作发生冲突，

1812
01:08:43,720 --> 01:08:46,540
并且法院的第一个

1813
01:08:46,540 --> 01:08:48,490
操作比另一个交易权发生得更早，

1814
01:08:48,490 --> 01:08:49,750
然后安排

1815
01:08:49,750 --> 01:08:53,799
，

1816
01:08:53,799 --> 01:08:56,529
所以如果我查看我的整个时间表，我

1817
01:08:56,529 --> 01:08:59,529
会 如果我看到一个循环，请创建我的依赖关系图

1818
01:08:59,529 --> 01:09:02,319
然后我知道它

1819
01:09:02,319 --> 01:09:04,149
没有被很好地消毒，因为我将

1820
01:09:04,149 --> 01:09:06,429
无法交换它们的顺序但是如果没有

1821
01:09:06,429 --> 01:09:09,149
循环比它是可序列化的冲突

1822
01:09:09,149 --> 01:09:11,259
所以让我们看看

1823
01:09:11,259 --> 01:09:13,420
我们之前的这个例子 在这种情况下，我

1824
01:09:13,420 --> 01:09:15,939
在 a 上有权限，然后在 a 上读取，

1825
01:09:15,939 --> 01:09:18,069
因此写入

1826
01:09:18,069 --> 01:09:19,960
a 显然与读取冲突，并且写入 a

1827
01:09:19,960 --> 01:09:21,609
和 T 发生在读取 a

1828
01:09:21,609 --> 01:09:24,009
和 T 2 之前，所以我有 从 t1 到

1829
01:09:24,009 --> 01:09:27,719
t2 的一条边，我将它标记为对象蛋

1830
01:09:27,719 --> 01:09:30,210
同样的事情我在 B 上有一个权利，

1831
01:09:30,210 --> 01:09:34,000
所以我在 B 上有一个从 t2 到 t1 的边

1832
01:09:34,000 --> 01:09:37,029
，现在我有一个循环，

1833
01:09:37,029 --> 01:09:38,469
所以我知道 这个顺序

1834
01:09:38,469 --> 01:09:40,599
在高中时并不复杂，只是

1835
01:09:40,599 --> 01:09:42,069
看看代码，这是

1836
01:09:42,069 --> 01:09:44,139
我在阅读之前拥有的贾斯汀·比伯示例，

1837
01:09:44,139 --> 01:09:46,389
我在这里运行然后

1838
01:09:46,389 --> 01:09:47,979
阅读 aa 跟随在真正的

1839
01:09:47,979 --> 01:09:49,750
不要跌倒 在 b 上的那个权利，然后

1840
01:09:49,750 --> 01:09:51,698
在 B 的权利上阅读，所以我将有

1841
01:09:51,698 --> 01:09:54,610
更新是如何从 t1 和

1842
01:09:54,610 --> 01:09:56,650
对 a 的更新将在 t2 发生，这是

1843
01:09:56,650 --> 01:10:01,599
一个撕裂的更新，所以现在让我们变得更加疯狂，

1844
01:10:01,599 --> 01:10:03,460
因为我们有任意数量的

1845
01:10:03,460 --> 01:10:06,070
交易，所以在这种情况下，我

1846
01:10:06,070 --> 01:10:08,050
在 B 上阅读并在 B 上正确，所以我

1847
01:10:08,050 --> 01:10:10,780
从 t2 获得了优势 到 B 上的 t1 并

1848
01:10:10,780 --> 01:10:14,230
继续一个接一个地向右走，

1849
01:10:14,230 --> 01:10:15,760
然后我们最终得到这样的结果，

1850
01:10:15,760 --> 01:10:16,719
所以问题是这是否被

1851
01:10:16,719 --> 01:10:19,150
认为是等效的，因为我们可以

1852
01:10:19,150 --> 01:10:21,219
在 t2 t1 t3 期间进行任何任意拍摄

1853
01:10:21,219 --> 01:10:24,280
，然后 最终得到正确的

1854
01:10:24,280 --> 01:10:26,829
零阶，但我们想要它，但是如果我们

1855
01:10:26,829 --> 01:10:28,329
生成依赖图，只需

1856
01:10:28,329 --> 01:10:30,400
看看我们是否有一个循环，它会

1857
01:10:30,400 --> 01:10:31,780
告诉我们我们是否存在冲突，

1858
01:10:31,780 --> 01:10:37,820
好吧，

1859
01:10:37,820 --> 01:10:39,470
我们还有一点 时间我们继续进行下去

1860
01:10:39,470 --> 01:10:42,740
嗯让我们看看现在让我们带回

1861
01:10:42,740 --> 01:10:45,680
我们

1862
01:10:45,680 --> 01:10:46,820
在应用程序

1863
01:10:46,820 --> 01:10:48,380
可能想要这样做的这些高级事物之前的操作 现在我们仍然拥有我们的

1864
01:10:48,380 --> 01:10:49,610
Reason 权限但现在我向

1865
01:10:49,610 --> 01:10:51,440
您展示程序实际编程的内容

1866
01:10:51,440 --> 01:10:53,030
逻辑实际上是这样做的，所以

1867
01:10:53,030 --> 01:10:54,020
权利的原因是 进入数据库的方式，

1868
01:10:54,020 --> 01:10:56,000
但任何其他操作，比如

1869
01:10:56,000 --> 01:10:57,680
你知道的 B 等于 B 加 10 这些都

1870
01:10:57,680 --> 01:10:59,810
发生在应用程序的动作

1871
01:10:59,810 --> 01:11:02,090
状态中，所以我对 B 所做的任何更改都不会

1872
01:11:02,090 --> 01:11:03,380
写入数据库，我必须

1873
01:11:03,380 --> 01:11:06,470
对 B 做正确的事情 是的，所以在这种

1874
01:11:06,470 --> 01:11:09,080
情况下，我永远不会

1875
01:11:09,080 --> 01:11:10,100
指出就像我们正在做的事情一样，

1876
01:11:10,100 --> 01:11:11,540
在这里，我们在一个帐户中收取 10 美元

1877
01:11:11,540 --> 01:11:13,640
，然后将 10 美元放入

1878
01:11:13,640 --> 01:11:15,590
该帐户的第二笔交易中，我

1879
01:11:15,590 --> 01:11:17,510
只想计算

1880
01:11:17,510 --> 01:11:19,310
a 和 B 中的总金额的总和

1881
01:11:19,310 --> 01:11:21,350
，然后这就像这个假回声

1882
01:11:21,350 --> 01:11:22,490
命令 这不是真实的东西 我

1883
01:11:22,490 --> 01:11:23,450
只是为了演示

1884
01:11:23,450 --> 01:11:25,160
目的而展示这个 这只是打印出来给

1885
01:11:25,160 --> 01:11:27,020
你返回实际总和 两个

1886
01:11:27,020 --> 01:11:30,230
值，所以在这种情况下，

1887
01:11:30,230 --> 01:11:31,940
我们想要生成一个依赖

1888
01:11:31,940 --> 01:11:33,860
图，我们在 a 上写入并在 a 上读取，

1889
01:11:33,860 --> 01:11:35,900
所以我们在一个 bin 上有一条从 t1 到 t2 的边，

1890
01:11:35,900 --> 01:11:38,510
在这里我们在 B 上有一个写入读取

1891
01:11:38,510 --> 01:11:40,670
并阅读 B 以便

1892
01:11:40,670 --> 01:11:43,040
我们在 o 上有优势 B 上的方向，所以

1893
01:11:43,040 --> 01:11:44,780
我们有一个循环，因此这不是

1894
01:11:44,780 --> 01:11:49,340
冲突可消除的，但

1895
01:11:49,340 --> 01:11:52,940
实际上有一种方法，如果我们可以

1896
01:11:52,940 --> 01:11:55,040
现代化，我们可以潜在地修改这个

1897
01:11:55,040 --> 01:11:56,210
应用程序并做一些不同的事情，

1898
01:11:56,210 --> 01:11:58,060
而不仅仅是以这种方式计算总和

1899
01:11:58,060 --> 01:12:01,220
，我们最终会得到 一些

1900
01:12:01,220 --> 01:12:03,740
东西仍然会遵循与事务

1901
01:12:03,740 --> 01:12:05,210
的串行排序相同的状态，

1902
01:12:05,210 --> 01:12:07,310
但它实际上不会

1903
01:12:07,310 --> 01:12:09,470
因为这里的循环而发生冲突可串行化，

1904
01:12:09,470 --> 01:12:12,920
而不是只是我

1905
01:12:12,920 --> 01:12:15,770
去阅读 a 然后添加到我的

1906
01:12:15,770 --> 01:12:17,480
总和和阅读被添加到 我的

1907
01:12:17,480 --> 01:12:19,430
总和如果不是实际给他们

1908
01:12:19,430 --> 01:12:22,100
两个账户的确切总和

1909
01:12:22,100 --> 01:12:23,540
我只想

1910
01:12:23,540 --> 01:12:27,560
知道超过零美元的账户总数是多少

1911
01:12:27,560 --> 01:12:30,290
我正在计算一个计数器

1912
01:12:30,290 --> 01:12:31,700


1913
01:12:31,700 --> 01:12:34,430
大于零的账户数量 因此，如果我重写我的

1914
01:12:34,430 --> 01:12:36,530
应用程序以说明如果大于

1915
01:12:36,530 --> 01:12:40,070
等于零的值加一到我的计数器，那么

1916
01:12:40,070 --> 01:12:42,710
在这种情况下，

1917
01:12:42,710 --> 01:12:46,700
即使我将 my-my-my

1918
01:12:46,700 --> 01:12:48,290
在 t1 仍在运行时进行的交易

1919
01:12:48,290 --> 01:12:51,170
并且假设

1920
01:12:51,170 --> 01:12:51,800
我确实有

1921
01:12:51,800 --> 01:12:54,170
10 美元并且他们没有变成负数，

1922
01:12:54,170 --> 01:12:55,970
那么这件事实际上仍然会

1923
01:12:55,970 --> 01:12:59,840
产生正确的结果，所以这

1924
01:12:59,840 --> 01:13:01,040


1925
01:13:01,040 --> 01:13:03,410
有点奇怪，我说复杂的可实现性说 我

1926
01:13:03,410 --> 01:13:05,420
需要以相同的

1927
01:13:05,420 --> 01:13:06,770
状态结束数据库的相同状态，因此结果

1928
01:13:06,770 --> 01:13:08,150
与运行串行排序的结果相同，

1929
01:13:08,150 --> 01:13:10,820
但在这种情况下，我并不复杂

1930
01:13:10,820 --> 01:13:13,570
，下面的 Eliza

1931
01:13:13,570 --> 01:13:17,050
在相同的数据库状态下获得相同的结果

1932
01:13:17,050 --> 01:13:21,370
就像我在 Serie 中运行一样，

1933
01:13:21,370 --> 01:13:23,900
这就是可序列化 T 的视图，

1934
01:13:23,900 --> 01:13:26,180
而且剧透是没有人

1935
01:13:26,180 --> 01:13:27,830
真正这样做，因为它要求

1936
01:13:27,830 --> 01:13:29,690
我们对您正在尝试执行

1937
01:13:29,690 --> 01:13:30,890
的应用程序或事务

1938
01:13:30,890 --> 01:13:32,420
进行一些推理 在

1939
01:13:32,420 --> 01:13:33,710
这里知道我是否可以

1940
01:13:33,710 --> 01:13:34,910
通过将这些人放在

1941
01:13:34,910 --> 01:13:37,640
其他人中间来插入他们所以这

1942
01:13:37,640 --> 01:13:38,930
就是我所说的实际上没有人

1943
01:13:38,930 --> 01:13:40,010
这样做但实际上这是一个真正

1944
01:13:40,010 --> 01:13:42,080
的 有趣的概念，最终你

1945
01:13:42,080 --> 01:13:44,150
知道也许 50 年后人们会有

1946
01:13:44,150 --> 01:13:45,200
更好的编程模型和

1947
01:13:45,200 --> 01:13:46,520
编程应用程序框架，

1948
01:13:46,520 --> 01:13:47,930
我们实际上可以使用乌龟眼

1949
01:13:47,930 --> 01:13:50,330
能力，但它今天不存在

1950
01:13:50,330 --> 01:13:52,060
它只是理论上的

1951
01:13:52,060 --> 01:13:55,970
所以让我们看另一个例子，所以我们

1952
01:13:55,970 --> 01:13:57,860
有 三个运行 T

1953
01:13:57,860 --> 01:13:59,390
时刻的事务在 aa 上读取，然后我在 a 上写入

1954
01:13:59,390 --> 01:14:01,640
，然后 T 2 和 T 3 正在执行

1955
01:14:01,640 --> 01:14:03,710
我所说的对 a 的盲写，因此我们正在

1956
01:14:03,710 --> 01:14:05,270
写入 a 而不实际先读取

1957
01:14:05,270 --> 01:14:09,020
它，如果我们可以再次这样做 我

1958
01:14:09,020 --> 01:14:10,190
只是通过并生成我的

1959
01:14:10,190 --> 01:14:13,040
依赖图，我们将生成

1960
01:14:13,040 --> 01:14:15,920
一堆边，我们有一个循环，

1961
01:14:15,920 --> 01:14:17,420
因此我们知道它

1962
01:14:17,420 --> 01:14:21,050
并不复杂或可以消除，但如果

1963
01:14:21,050 --> 01:14:22,310
我实际上

1964
01:14:22,310 --> 01:14:25,790
稍微好一点地查看交易，我 假设

1965
01:14:25,790 --> 01:14:27,080
这些是目前在此运行的唯一事务，我们

1966
01:14:27,080 --> 01:14:28,610


1967
01:14:28,610 --> 01:14:32,390
说情况就是这样，T 1 不会读取

1968
01:14:32,390 --> 01:14:34,280
我写的文件 82 不会写入

1969
01:14:34,280 --> 01:14:36,260
但最终

1970
01:14:36,260 --> 01:14:38,390
数据库的答案唯一重要的

1971
01:14:38,390 --> 01:14:43,970
是最后一次写入 T 3 所以

1972
01:14:43,970 --> 01:14:46,930
这里的这个顺序实际上相当于一个视图视图

1973
01:14:46,930 --> 01:14:49,520
，我按照这样的顺序 xq 到它们，

1974
01:14:49,520 --> 01:14:53,480
只要 T 3 是最后一次

1975
01:14:53,480 --> 01:14:55,430
写入得到那个 被持久化

1976
01:14:55,430 --> 01:14:57,800
到数据是一个谁关心

1977
01:14:57,800 --> 01:15:00,920
这里的其他人如何交错，但我

1978
01:15:00,920 --> 01:15:02,570
需要知道在我的

1979
01:15:02,570 --> 01:15:04,310
应用程序中，这件事可以

1980
01:15:04,310 --> 01:15:05,490
成为最后一个作家

1981
01:15:05,490 --> 01:15:08,040
，正如我在下节课

1982
01:15:08,040 --> 01:15:08,870
谈论两个时所说的那样 锁相

1983
01:15:08,870 --> 01:15:11,070
事务在执行期间知道的不同时间以任意顺序显示，

1984
01:15:11,070 --> 01:15:13,320
并且

1985
01:15:13,320 --> 01:15:15,060


1986
01:15:15,060 --> 01:15:16,110
您不确切知道他们将

1987
01:15:16,110 --> 01:15:18,270
提前做什么，所以你不能

1988
01:15:18,270 --> 01:15:24,390
保证这一点，所以真的快速跳过

1989
01:15:24,390 --> 01:15:27,420
所有这些 考虑

1990
01:15:27,420 --> 01:15:30,240
我们讨论的这些时间表的方法是

1991
01:15:30,240 --> 01:15:32,010
，您拥有

1992
01:15:32,010 --> 01:15:33,810
所有可能的时间表排序或所有

1993
01:15:33,810 --> 01:15:34,890
可能的时间表排序，您可以

1994
01:15:34,890 --> 01:15:36,420
在您的应用程序中进行任何培训事务

1995
01:15:36,420 --> 01:15:38,730


1996
01:15:38,730 --> 01:15:40,410
这个巨大的空间在这里是任何可能

1997
01:15:40,410 --> 01:15:41,970
的排序但是你不关心

1998
01:15:41,970 --> 01:15:43,260
你甚至没有

1999
01:15:43,260 --> 01:15:46,470
考虑正确与否意味着什么然后你

2000
01:15:46,470 --> 01:15:49,160
这里有一小部分不同的排序

2001
01:15:49,160 --> 01:15:51,090
好吧这些是退出交易的地方

2002
01:15:51,090 --> 01:15:53,340
一个接一个然后

2003
01:15:53,340 --> 01:15:54,750
围绕这将是可

2004
01:15:54,750 --> 01:15:57,570
序列化的冲突，这些又是一些

2005
01:15:57,570 --> 01:15:59,430
雷曼内部的，可能不是序列，它

2006
01:15:59,430 --> 01:16:00,960
包括所有立体排序，但

2007
01:16:00,960 --> 01:16:02,940
包括那些不是的，然后

2008
01:16:02,940 --> 01:16:04,350
周围将是可消毒的视图，

2009
01:16:04,350 --> 01:16:10,530
是的，

2010
01:16:10,530 --> 01:16:21,810
回来因为 再说一遍，这就是

2011
01:16:21,810 --> 01:16:24,120
我得到的，我会说再次运行这些

2012
01:16:24,120 --> 01:16:26,370
交易 我没有

2013
01:16:26,370 --> 01:16:28,200
随意显示交易 这是

2014
01:16:28,200 --> 01:16:29,310
说这就是我所拥有的 我现在想运行

2015
01:16:29,310 --> 01:16:32,550
这个 结局是什么，

2016
01:16:32,550 --> 01:16:35,040
只有一个对象 在数据库中，所以

2017
01:16:35,040 --> 01:16:36,690
我在运行这些事务后唯一能看到

2018
01:16:36,690 --> 01:16:39,240
的是这是什么

2019
01:16:39,240 --> 01:16:44,130
a 的值是什么，所以谁在乎 t1

2020
01:16:44,130 --> 01:16:46,260
和 t2 写了 a 因为 t3 会

2021
01:16:46,260 --> 01:16:48,420
在 en 覆盖它

2022
01:16:48,420 --> 01:16:49,830
最重要的是这个人写了

2023
01:16:49,830 --> 01:16:53,450
什么谁在乎这些人实际上做了

2024
01:16:54,440 --> 01:16:56,910
什么纠正这个在第

2025
01:16:56,910 --> 01:17:00,620
一个例子中不起作用第一个例子是什么是

2026
01:17:00,620 --> 01:17:02,520
拿钱我不想计算

2027
01:17:02,520 --> 01:17:05,400
放在另一个帐户中计算

2028
01:17:05,400 --> 01:17:07,970
利息 是的，

2029
01:17:09,770 --> 01:17:11,640
这只是为了说明这个

2030
01:17:11,640 --> 01:17:16,140
概念，所以我将跳过所有这些

2031
01:17:16,140 --> 01:17:18,480
以确保交易持久性

2032
01:17:18,480 --> 01:17:20,160


2033
01:17:20,160 --> 01:17:22,830


2034
01:17:22,830 --> 01:17:24,240


2035
01:17:24,240 --> 01:17:26,520
坚持我今天杀死

2036
01:17:26,520 --> 01:17:28,410
ssin 将重点放在这两个上 我们将介绍

2037
01:17:28,410 --> 01:17:29,580
这个更分布式的数据库 我们将

2038
01:17:29,580 --> 01:17:31,170
介绍登录检查点的这一点 但

2039
01:17:31,170 --> 01:17:32,400
下周我们将

2040
01:17:32,400 --> 01:17:35,610
进一步关注这两个所以最后一件事

2041
01:17:35,610 --> 01:17:37,640
我只会 也有点说

2042
01:17:37,640 --> 01:17:39,720
商业很难 很难得到

2043
01:17:39,720 --> 01:17:41,790
正确 很难得到很好的执行 这

2044
01:17:41,790 --> 01:17:44,070
就是为什么出现了许多较新的数据库系统

2045
01:17:44,070 --> 01:17:45,300
，

2046
01:17:45,300 --> 01:17:47,880
除了最近它们最初

2047
01:17:47,880 --> 01:17:49,710
不支持事务，因为

2048
01:17:49,710 --> 01:17:50,910
它们 说他们想要获得最佳

2049
01:17:50,910 --> 01:17:53,180
性能并且他们不担心

2050
01:17:53,180 --> 01:17:55,140
您知道运行事务他们

2051
01:17:55,140 --> 01:17:56,010
想确保系统始终

2052
01:17:56,010 --> 01:17:58,710
可用并且您知道他们

2053
01:17:58,710 --> 01:18:00,420
不想给事务增加负担

2054
01:18:00,420 --> 01:18:05,400
所以我

2055
01:18:05,400 --> 01:18:07,190
一直喜欢的事情 需要指出的是

2056
01:18:07,190 --> 01:18:11,460
Google 在 19 2004 2005 他们

2057
01:18:11,460 --> 01:18:13,110
是新续集系统的先驱或先锋

2058
01:18:13,110 --> 01:18:14,880
他们推出了

2059
01:18:14,880 --> 01:18:16,620
名为 BigTable 的东西 他们说加入

2060
01:18:16,620 --> 01:18:18,240
很慢续集 交易很

2061
01:18:18,240 --> 01:18:20,060
慢 我们不会做任何事情

2062
01:18:20,060 --> 01:18:23,340
然后就像七八年后，

2063
01:18:23,340 --> 01:18:24,690
在每个人都

2064
01:18:24,690 --> 01:18:27,990
像 Sondra Mongo 一样复制了谷歌所做

2065
01:18:27,990 --> 01:18:30,750
的一些其他关键值存储 HBase 之后，

2066
01:18:30,750 --> 01:18:33,090
他们发表了这篇论文，称为

2067
01:18:33,090 --> 01:18:34,740
Spanner，这是

2068
01:18:34,740 --> 01:18:36,240
他们在内部使用的事务数据库系统，

2069
01:18:36,240 --> 01:18:38,850
并且有 论文中的这一行很重要，

2070
01:18:38,850 --> 01:18:43,230
它说对于他们的程序员来说，

2071
01:18:43,230 --> 01:18:45,120
他们认为最好提供一个使用事务的

2072
01:18:45,120 --> 01:18:46,860
抽象或编程模型，

2073
01:18:46,860 --> 01:18:50,100
因为这样更容易

2074
01:18:50,100 --> 01:18:51,090
对他们来说，关于

2075
01:18:51,090 --> 01:18:52,290
程序正确性的原因

2076
01:18:52,290 --> 01:18:55,110
是 rachie 是否以正确的顺序执行正确的操作，

2077
01:18:55,110 --> 01:18:57,330
这对你知道的孩子更好 未清洗

2078
01:18:57,330 --> 01:18:59,010
的

2079
01:18:59,010 --> 01:19:00,540
群众你平均你知道 Rando

2080
01:19:00,540 --> 01:19:02,190
javascript 程序或他们正在

2081
01:19:02,190 --> 01:19:05,010
使用的任何你读过的程序 他们都编程

2082
01:19:05,010 --> 01:19:06,330
使用事务编程模型，

2083
01:19:06,330 --> 01:19:08,070
然后你有一群非常

2084
01:19:08,070 --> 01:19:09,330
聪明的人可以

2085
01:19:09,330 --> 01:19:11,550
像杰夫·迪恩那样进行系统开发，他们的工作

2086
01:19:11,550 --> 01:19:12,480
担心如何使这些

2087
01:19:12,480 --> 01:19:15,540
事务进行得更快，因此事务

2088
01:19:15,540 --> 01:19:17,610
对每个系统都非常重要

2089
01:19:17,610 --> 01:19:19,020
他们之前没有它们现在

2090
01:19:19,020 --> 01:19:21,449
正试图开始添加它们，

2091
01:19:21,449 --> 01:19:23,640
因为它再次提供了所有这些

2092
01:19:23,640 --> 01:19:25,110
很好的保证，您希望在

2093
01:19:25,110 --> 01:19:26,840
您的系统中再次可以正常使用

2094
01:19:26,840 --> 01:19:29,100
我很着急，我道歉

2095
01:19:29,100 --> 01:19:29,850
但我不会很快 通过一个

2096
01:19:29,850 --> 01:19:31,530
项目，你真的很快，

2097
01:19:31,530 --> 01:19:33,480
所以项目会读出你的建筑物

2098
01:19:33,480 --> 01:19:35,280
是公交车的查询执行引擎，

2099
01:19:35,280 --> 01:19:37,650
所以你最终要

2100
01:19:37,650 --> 01:19:39,929
实现的是

2101
01:19:39,929 --> 01:19:43,050
实际查询计划运算符的执行程序，所以说你

2102
01:19:43,050 --> 01:19:45,449
有一个这样的查询盘，然后对于

2103
01:19:45,449 --> 01:19:46,530
这些运算符中的每一个，你将

2104
01:19:46,530 --> 01:19:48,270
生成这个执行程序，它将

2105
01:19:48,270 --> 01:19:49,650
遵循我们讨论过的迭代器模型，

2106
01:19:49,650 --> 01:19:51,150
其中它们都有一个 X

2107
01:19:51,150 --> 01:19:52,980
函数 推你知道你

2108
01:19:52,980 --> 01:19:54,660
在执行器上的 OP 上调用 next 并且

2109
01:19:54,660 --> 01:19:57,210
它给你返回它拥有的下一个元组

2110
01:19:57,210 --> 01:19:59,219
或一个空指针来

2111
01:19:59,219 --> 01:20:02,400
表示它已经完成了所以你们正在

2112
01:20:02,400 --> 01:20:03,360
做它可能是单线程

2113
01:20:03,360 --> 01:20:06,000
执行没有交换运算符 并且您

2114
01:20:06,000 --> 01:20:07,050
不必担心事务

2115
01:20:07,050 --> 01:20:09,330
您不必担心您知道

2116
01:20:09,330 --> 01:20:12,090
进行更新或删除 所以

2117
01:20:12,090 --> 01:20:14,070
您必须构建什么 所以

2118
01:20:14,070 --> 01:20:15,449
我们要求您做的第一件事就是

2119
01:20:15,449 --> 01:20:17,070
构建 那里的目录允许您

2120
01:20:17,070 --> 01:20:18,780
将安装表安装到

2121
01:20:18,780 --> 01:20:20,400
数据库中，然后返回并

2122
01:20:20,400 --> 01:20:22,290
使用名称

2123
01:20:22,290 --> 01:20:24,150
或内部开启标识 ER 从 Cal 取回这些表，

2124
01:20:24,150 --> 01:20:25,620
然后您正在构建执行程序以

2125
01:20:25,620 --> 01:20:27,120
插入中央扫描哈希关节 和

2126
01:20:27,120 --> 01:20:30,360
散列连接的散列聚合，您

2127
01:20:30,360 --> 01:20:33,210
可以首先使用您知道

2128
01:20:33,210 --> 01:20:35,160
的内存中散列表来实现它，该散列表将为

2129
01:20:35,160 --> 01:20:36,989
您提供，但最终目标是您

2130
01:20:36,989 --> 01:20:38,429
想要使用您

2131
01:20:38,429 --> 01:20:40,140
从项目二构建的线性探针散列表，因为

2132
01:20:40,140 --> 01:20:42,360
这允许您 对不适合磁盘的表进行连接，

2133
01:20:42,360 --> 01:20:44,400
这样您就可以完成

2134
01:20:44,400 --> 01:20:46,350
前两项任务，而无需执行

2135
01:20:46,350 --> 01:20:48,390
该工作线性探针哈希表，

2136
01:20:48,390 --> 01:20:49,530
最后一项将要求您让

2137
01:20:49,530 --> 01:20:54,330
该工作正常工作，以便在目录中

2138
01:20:54,330 --> 01:20:55,440
插入一个执行程序 首先是因为

2139
01:20:55,440 --> 01:20:56,940
很明显你不能做特殊扫描，

2140
01:20:56,940 --> 01:20:58,730
除非你的数据库中有数据

2141
01:20:58,730 --> 01:21:00,390
你不需要担心任何

2142
01:21:00,390 --> 01:21:02,429
交易，然后当这个发布

2143
01:21:02,429 --> 01:21:03,870
在 Piazza 上时，我会再次强调这个

2144
01:21:03,870 --> 01:21:06,060
伟大的范围并不意味着

2145
01:21:06,060 --> 01:21:09,420
调试正确，如果您提交它并且

2146
01:21:09,420 --> 01:21:10,650
需要半小时或四个开始

2147
01:21:10,650 --> 01:21:12,929
运行，我们无法解决这个问题，

2148
01:21:12,929 --> 01:21:14,040
这是一个很大的范围，

2149
01:21:14,040 --> 01:21:15,810
其他学生排在队列中，班上有 100 个单位的猎人

2150
01:21:15,810 --> 01:21:17,730
学生，他不会

2151
01:21:17,730 --> 01:21:20,640
正确运行 所以我们提供了一些基本的

2152
01:21:20,640 --> 01:21:21,900
测试作为一个框架来弄清楚

2153
01:21:21,900 --> 01:21:23,760
如何编写更多的测试，但他是你所做

2154
01:21:23,760 --> 01:21:26,130
的，因为所有的开发人员都想

2155
01:21:26,130 --> 01:21:27,239
弄清楚你的问题要

2156
01:21:27,239 --> 01:21:29,790
在本地完成，然后如果你发现这

2157
01:21:29,790 --> 01:21:31,050
件事超时，因为 它运行

2158
01:21:31,050 --> 01:21:32,880
得太慢了 你应该弄清楚为什么你的

2159
01:21:32,880 --> 01:21:34,170
系统在本地运行 flow 不要

2160
01:21:34,170 --> 01:21:35,190
让你知道一些微小的

2161
01:21:35,190 --> 01:21:36,300
变化并不断将它们提交给

2162
01:21:36,300 --> 01:21:37,410
大范围并尝试测量

2163
01:21:37,410 --> 01:21:39,210
伟大的脚本需要多长时间 你可以

2164
01:21:39,210 --> 01:21:42,270
在本地解决这些问题 我们已经

2165
01:21:42,270 --> 01:21:44,550
介绍过这个，不要拍摄任何文件，

2166
01:21:44,550 --> 01:21:46,350
然后一旦我们给你你想要重新定位

2167
01:21:46,350 --> 01:21:47,460
在公交车站主那里的

2168
01:21:47,460 --> 01:21:48,719
指令广场如何做到这一点，

2169
01:21:48,719 --> 01:21:50,880
然后如果你有

2170
01:21:50,880 --> 01:21:52,650
问题，我总是要说的

2171
01:21:52,650 --> 01:21:54,210
不要抄袭，我们会毁了你，

2172
01:21:54,210 --> 01:21:55,800
因为如果我们真的

2173
01:21:55,800 --> 01:21:57,770
抄袭其他人的新副本，会发生什么

2174
01:21:57,770 --> 01:21:59,730
大学回到我身边说，嘿，

2175
01:21:59,730 --> 01:22:01,260
你告诉你的学生不要玩

2176
01:22:01,260 --> 01:22:02,489
驱动器，我给他们看视频，我

2177
01:22:02,489 --> 01:22:03,660
猜猜这是我告诉你不要

2178
01:22:03,660 --> 01:22:05,460
抄袭不要抄袭，这是

2179
01:22:05,460 --> 01:22:06,960
对你不利的证据，你又被搞砸了，好吧，

2180
01:22:06,960 --> 01:22:10,290
下节课我会

2181
01:22:10,290 --> 01:22:15,210
走了是的，不，我们继续，这就是我们的好，

2182
01:22:15,210 --> 01:22:18,510
好吧，我们会恢复电视的锁定，

2183
01:22:18,510 --> 01:22:19,949
然后 将建立在我们今天讨论的基础上，

2184
01:22:19,949 --> 01:22:24,230
伙计们，

2185
01:22:33,660 --> 01:22:37,000
这是我系统中的星期三晚上，我很

2186
01:22:37,000 --> 01:22:37,420
幸运，

2187
01:22:37,420 --> 01:22:44,800
让我们去迎接下一个现在

2188
01:22:44,800 --> 01:22:46,930
好了，永远不要成为儿子跳弹果冻的

2189
01:22:46,930 --> 01:22:49,090
熟食店，自然会祝福你

2190
01:22:49,090 --> 01:22:50,560
，说唱歌手喜欢什么 激光束

2191
01:22:50,560 --> 01:22:53,020
丛林中的男孩们什么都不说 像国王一样

2192
01:22:53,020 --> 01:22:55,120
包裹着我们的瓶子 一个很好的同情心

2193
01:22:55,120 --> 01:22:57,520
不要想喝一匹小马 -

2194
01:22:57,520 --> 01:23:00,310
你喝醉了，你不能把我放在火刑柱上

2195
01:23:00,310 --> 01:23:04,110
不知道你忘记了煎饼

