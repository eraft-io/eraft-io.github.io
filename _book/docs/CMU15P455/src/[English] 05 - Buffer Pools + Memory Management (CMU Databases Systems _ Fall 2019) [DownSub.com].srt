1
00:00:01,280 --> 00:00:11,400
[Music]

2
00:00:15,750 --> 00:00:17,410
all right

3
00:00:17,410 --> 00:00:21,700
hey done grab your wrap you look down

4
00:00:21,700 --> 00:00:28,439
what's wrong city women woman problems

5
00:00:28,439 --> 00:00:34,690
what do you say men problems what are

6
00:00:34,690 --> 00:00:42,220
your problems they were saying your

7
00:00:42,220 --> 00:00:43,180
beats are too fresh and they can't

8
00:00:43,180 --> 00:00:47,680
handle it I'm not qualified to help I'm

9
00:00:47,680 --> 00:00:48,370
sorry okay

10
00:00:48,370 --> 00:00:49,960
all right so let's talk about databases

11
00:00:49,960 --> 00:00:54,579
then all right so a quick reminder

12
00:00:54,579 --> 00:00:59,079
homework one is due tonight and then

13
00:00:59,079 --> 00:01:02,230
project one is going out today I'll sit

14
00:01:02,230 --> 00:01:03,190
at the end of the class there's actually

15
00:01:03,190 --> 00:01:04,390
the website now the source code is

16
00:01:04,390 --> 00:01:07,600
online but I'll discuss what it is what

17
00:01:07,600 --> 00:01:09,909
you're required to do today and then

18
00:01:09,909 --> 00:01:11,229
just like before you're submitted some

19
00:01:11,229 --> 00:01:14,619
great scope and you know everything will

20
00:01:14,619 --> 00:01:17,530
be auto graded all right um I do want to

21
00:01:17,530 --> 00:01:19,030
spend some time talking whatever lab

22
00:01:19,030 --> 00:01:20,380
work loads is where after you've

23
00:01:20,380 --> 00:01:22,509
collected a bunch of data in the OLT

24
00:01:22,509 --> 00:01:24,490
side now you want to start analyzing it

25
00:01:24,490 --> 00:01:26,649
to extrapolate new information like

26
00:01:26,649 --> 00:01:28,179
people in the city of Pittsburgh are

27
00:01:28,179 --> 00:01:30,130
more likely to buy this kind of product

28
00:01:30,130 --> 00:01:31,869
I said you can use that information to

29
00:01:31,869 --> 00:01:33,729
then you know push information to the

30
00:01:33,729 --> 00:01:35,709
OTB side to get people to do things you

31
00:01:35,709 --> 00:01:37,719
want them to do and then the hybrid

32
00:01:37,719 --> 00:01:39,279
transaction analytical processing h-type

33
00:01:39,279 --> 00:01:41,109
workloads this is sort of a new buzzword

34
00:01:41,109 --> 00:01:43,810
that Gartner invented a few years ago

35
00:01:43,810 --> 00:01:45,549
basically describing these database

36
00:01:45,549 --> 00:01:47,979
systems that try to do both of them

37
00:01:47,979 --> 00:01:51,279
so a typical setup you'll see often is

38
00:01:51,279 --> 00:01:53,679
like this you'll have your front end ODB

39
00:01:53,679 --> 00:01:55,509
databases and then you have your giant

40
00:01:55,509 --> 00:01:57,819
back-end data warehouse so these are

41
00:01:57,819 --> 00:02:00,009
sometimes called data silos because you

42
00:02:00,009 --> 00:02:01,450
can do poncho updates into them sort of

43
00:02:01,450 --> 00:02:03,759
one database instance whether it's a

44
00:02:03,759 --> 00:02:05,079
single node or shivudu doesn't matter

45
00:02:05,079 --> 00:02:06,669
because it's a single logical database

46
00:02:06,669 --> 00:02:10,568
and then you apply your changes here but

47
00:02:10,568 --> 00:02:11,650
they don't really communicate with each

48
00:02:11,650 --> 00:02:13,660
other each one is sort of an island by

49
00:02:13,660 --> 00:02:15,700
itself so then you can do what's called

50
00:02:15,700 --> 00:02:17,739
extract transform and load or ETL and

51
00:02:17,739 --> 00:02:19,310
this is sort of a

52
00:02:19,310 --> 00:02:21,140
the term you use is described taking

53
00:02:21,140 --> 00:02:23,959
data out of these front ends cleaning it

54
00:02:23,959 --> 00:02:26,270
up processing it and then putting it to

55
00:02:26,270 --> 00:02:28,910
the back end data warehouse so the

56
00:02:28,910 --> 00:02:30,230
example I like to get for this is like

57
00:02:30,230 --> 00:02:32,930
Zynga the farmville people they buy a

58
00:02:32,930 --> 00:02:35,360
lot of gaming startups and then when

59
00:02:35,360 --> 00:02:36,590
they buy them they all run their own

60
00:02:36,590 --> 00:02:39,380
front end mediator basis but then when

61
00:02:39,380 --> 00:02:40,459
they want to put it in their back-end

62
00:02:40,459 --> 00:02:42,980
giant data warehouse so they can do

63
00:02:42,980 --> 00:02:44,510
analyze things to make you buy crap on

64
00:02:44,510 --> 00:02:46,970
farmville better right and so because

65
00:02:46,970 --> 00:02:49,190
say like in one database the first name

66
00:02:49,190 --> 00:02:51,110
of a customer will be F name another

67
00:02:51,110 --> 00:02:53,150
database we you know F first underscore

68
00:02:53,150 --> 00:02:55,280
name right so it's the same concept or

69
00:02:55,280 --> 00:02:56,180
same entity just with different

70
00:02:56,180 --> 00:02:58,970
different syntax and nomenclature

71
00:02:58,970 --> 00:03:01,069
so this ETL process cleans all that up

72
00:03:01,069 --> 00:03:03,080
you shove it to your data warehouse you

73
00:03:03,080 --> 00:03:05,090
do all your analytics here and then

74
00:03:05,090 --> 00:03:06,319
whatever new information you have you

75
00:03:06,319 --> 00:03:09,739
push it to the front all right and when

76
00:03:09,739 --> 00:03:10,790
you see things like people that bought

77
00:03:10,790 --> 00:03:12,319
this item also bought this item that's

78
00:03:12,319 --> 00:03:14,090
that they're doing that on the OLAP side

79
00:03:14,090 --> 00:03:15,769
and then they shove it to the front end

80
00:03:15,769 --> 00:03:17,150
to expose that through the OTP

81
00:03:17,150 --> 00:03:19,310
application so H tab basically says

82
00:03:19,310 --> 00:03:21,290
let's just also do some of the integral

83
00:03:21,290 --> 00:03:23,060
queries that we can normally only do on

84
00:03:23,060 --> 00:03:25,310
the OLAP side we can do it on the front

85
00:03:25,310 --> 00:03:28,280
end data silos you still want this giant

86
00:03:28,280 --> 00:03:30,260
thing your giant data warehouse because

87
00:03:30,260 --> 00:03:32,750
you want to be able to look at all your

88
00:03:32,750 --> 00:03:35,690
data silos put to put together but now

89
00:03:35,690 --> 00:03:36,799
instead of waiting for things to be

90
00:03:36,799 --> 00:03:38,480
propagated to the backend you can do

91
00:03:38,480 --> 00:03:40,220
some things on the front-end so that's

92
00:03:40,220 --> 00:03:42,019
basically what H type is so again this

93
00:03:42,019 --> 00:03:43,519
could be like your my sequel does your

94
00:03:43,519 --> 00:03:45,829
Postgres MongoDB whatever you want and

95
00:03:45,829 --> 00:03:47,450
then your back-end data warehouse would

96
00:03:47,450 --> 00:03:51,410
be Hadoop stuff spark greenplum Vertica

97
00:03:51,410 --> 00:03:53,239
there's there's large enterprise data

98
00:03:53,239 --> 00:03:55,400
warehouse systems redshift or snowflake

99
00:03:55,400 --> 00:03:57,380
your other cloud ones okay so this is

100
00:03:57,380 --> 00:04:01,970
clear okay so the main topic today we're

101
00:04:01,970 --> 00:04:03,889
talking about is now given that we've

102
00:04:03,889 --> 00:04:05,750
already spent two previous lectures on

103
00:04:05,750 --> 00:04:06,859
deciding how we're actually gonna

104
00:04:06,859 --> 00:04:10,100
represent the database in on disk now we

105
00:04:10,100 --> 00:04:11,750
want to talk about what we actually do

106
00:04:11,750 --> 00:04:14,329
to bring the database from those files

107
00:04:14,329 --> 00:04:16,488
on disk the pages on disk and bring them

108
00:04:16,488 --> 00:04:17,988
into memory so that we can operate on

109
00:04:17,988 --> 00:04:21,380
them right so remember that we the

110
00:04:21,380 --> 00:04:22,760
database system can't operate directly

111
00:04:22,760 --> 00:04:25,340
on disk we can't do reads and writes

112
00:04:25,340 --> 00:04:26,810
without having to bring into memory

113
00:04:26,810 --> 00:04:28,220
first that that's the von Neumann

114
00:04:28,220 --> 00:04:29,870
architecture now there are some new

115
00:04:29,870 --> 00:04:31,400
hardware coming out you can push

116
00:04:31,400 --> 00:04:32,870
execution

117
00:04:32,870 --> 00:04:35,600
logic down to the disks but we can

118
00:04:35,600 --> 00:04:38,240
ignore that for now so we're trying to

119
00:04:38,240 --> 00:04:39,650
figure out how do we want to bring back

120
00:04:39,650 --> 00:04:41,660
those pages in the disk and we want to

121
00:04:41,660 --> 00:04:42,680
do this and be able to support a

122
00:04:42,680 --> 00:04:44,000
database that exceeds the amount of

123
00:04:44,000 --> 00:04:45,530
memory that we have and we want to

124
00:04:45,530 --> 00:04:48,380
minimize the impact the slowdown or the

125
00:04:48,380 --> 00:04:51,140
problems of having queries tap that

126
00:04:51,140 --> 00:04:52,490
touch data on disk we want to make it

127
00:04:52,490 --> 00:04:55,220
appear as if everything's in memory so

128
00:04:55,220 --> 00:04:57,260
another way to think a problem is is

129
00:04:57,260 --> 00:04:59,180
also in terms of spatial versus temporal

130
00:04:59,180 --> 00:05:02,630
control so spatial control is you know

131
00:05:02,630 --> 00:05:04,490
where are we physically gonna write this

132
00:05:04,490 --> 00:05:07,160
data on disk right meaning like we want

133
00:05:07,160 --> 00:05:08,450
we know that these pages are can be used

134
00:05:08,450 --> 00:05:10,610
together often possibly one after

135
00:05:10,610 --> 00:05:12,470
another so when we write those pages out

136
00:05:12,470 --> 00:05:13,850
we want to write them sequentially so

137
00:05:13,850 --> 00:05:15,710
that when we go read them again though

138
00:05:15,710 --> 00:05:17,840
we though we you know write and

139
00:05:17,840 --> 00:05:19,850
physically close to each other and we

140
00:05:19,850 --> 00:05:21,200
don't have to do long seeks to find

141
00:05:21,200 --> 00:05:23,930
different spots on disk we also care

142
00:05:23,930 --> 00:05:25,700
about temporal control and this is where

143
00:05:25,700 --> 00:05:27,890
we make decisions about when do we read

144
00:05:27,890 --> 00:05:29,780
pages into memory what time we do this

145
00:05:29,780 --> 00:05:30,980
and then at some point we have to write

146
00:05:30,980 --> 00:05:33,320
it back out if it's been written if it's

147
00:05:33,320 --> 00:05:34,910
been modified and we don't make a

148
00:05:34,910 --> 00:05:36,170
decision of when we actually go ahead

149
00:05:36,170 --> 00:05:38,270
and do that and yeah this is the

150
00:05:38,270 --> 00:05:40,340
overarching goal of trying to minimize

151
00:05:40,340 --> 00:05:43,040
the number of stalls we have because our

152
00:05:43,040 --> 00:05:44,300
queries try to read data that we didn't

153
00:05:44,300 --> 00:05:45,920
have in memory and we had it right up

154
00:05:45,920 --> 00:05:47,480
you know that was out on disk we had to

155
00:05:47,480 --> 00:05:50,540
go fetch it so this is the overall

156
00:05:50,540 --> 00:05:52,640
architecture of the lower store manager

157
00:05:52,640 --> 00:05:54,290
but I showed in the beginning so we've

158
00:05:54,290 --> 00:05:55,820
sort of covered this part already so now

159
00:05:55,820 --> 00:05:57,860
we know how to have a database file or

160
00:05:57,860 --> 00:05:59,990
files on disk we know how to represent

161
00:05:59,990 --> 00:06:01,250
the page directory to find the data we

162
00:06:01,250 --> 00:06:03,080
need and then we have a bunch of pages a

163
00:06:03,080 --> 00:06:04,670
lot of pages log structure pages it

164
00:06:04,670 --> 00:06:06,260
doesn't matter we have a bunch of pages

165
00:06:06,260 --> 00:06:07,820
on disk and we know how to jump to them

166
00:06:07,820 --> 00:06:09,650
to find them so we now we're talking

167
00:06:09,650 --> 00:06:10,700
about this part up here at the buffer

168
00:06:10,700 --> 00:06:12,890
pool right when something else in the

169
00:06:12,890 --> 00:06:14,090
system like the execution engine the

170
00:06:14,090 --> 00:06:15,620
thing executing queries comes along says

171
00:06:15,620 --> 00:06:17,690
I want to read page two we got to know

172
00:06:17,690 --> 00:06:19,040
how to fetch the page directory into

173
00:06:19,040 --> 00:06:20,600
memory figure out what's in there and

174
00:06:20,600 --> 00:06:22,250
then go find the the page that we want

175
00:06:22,250 --> 00:06:24,800
and fetch that into memory and then the

176
00:06:24,800 --> 00:06:25,940
tricky thing is going to be if we don't

177
00:06:25,940 --> 00:06:28,070
have enough space now free memory to

178
00:06:28,070 --> 00:06:29,720
bring that page we need in we have to

179
00:06:29,720 --> 00:06:32,330
make decision what page to write out so

180
00:06:32,330 --> 00:06:34,160
that's you know this is what we're

181
00:06:34,160 --> 00:06:36,350
trying to solve today right and then the

182
00:06:36,350 --> 00:06:38,300
the other parts of the system don't need

183
00:06:38,300 --> 00:06:41,810
to know or really care about what's you

184
00:06:41,810 --> 00:06:43,190
know what's in memory with not in memory

185
00:06:43,190 --> 00:06:44,540
there's going to wait until you get the

186
00:06:44,540 --> 00:06:44,950
thing you

187
00:06:44,950 --> 00:06:46,420
and give you back a pointer to let you

188
00:06:46,420 --> 00:06:48,070
do whatever it is that you wanted to do

189
00:06:48,070 --> 00:06:51,670
okay so the things were talked about

190
00:06:51,670 --> 00:06:53,140
today is essentially just how to build

191
00:06:53,140 --> 00:06:54,760
what a buffer pool manager actually

192
00:06:54,760 --> 00:06:57,400
gonna do in some comedies the term

193
00:06:57,400 --> 00:06:59,170
buffer pool manager some systems will

194
00:06:59,170 --> 00:07:01,420
call this a buffer cache it's the same

195
00:07:01,420 --> 00:07:03,340
thing right it's memory manage by by the

196
00:07:03,340 --> 00:07:05,260
database system then we'll talk about

197
00:07:05,260 --> 00:07:07,240
how we actually can do different

198
00:07:07,240 --> 00:07:09,190
policies that decide what we know what

199
00:07:09,190 --> 00:07:10,360
pages we want to write out that that's

200
00:07:10,360 --> 00:07:12,540
what pages if you need to free up space

201
00:07:12,540 --> 00:07:14,620
additional optimizations we can do to

202
00:07:14,620 --> 00:07:16,690
minimize this impact and then we'll

203
00:07:16,690 --> 00:07:18,790
finish up talking about two other pieces

204
00:07:18,790 --> 00:07:20,830
of the data system that may need memory

205
00:07:20,830 --> 00:07:25,120
okay so again the buffer pool is

206
00:07:25,120 --> 00:07:26,950
essentially just a large memory region

207
00:07:26,950 --> 00:07:28,390
that we're gonna allocate inside our

208
00:07:28,390 --> 00:07:30,040
database system we're gonna call malloc

209
00:07:30,040 --> 00:07:31,810
I want to get some chunk chunk of memory

210
00:07:31,810 --> 00:07:33,970
and that's we're gonna put all our pages

211
00:07:33,970 --> 00:07:36,430
that we fetch from disk and so this is

212
00:07:36,430 --> 00:07:37,750
again this is all entirely managed by

213
00:07:37,750 --> 00:07:39,370
the memory by the database system other

214
00:07:39,370 --> 00:07:40,660
than having go to the operating system

215
00:07:40,660 --> 00:07:42,790
and ask for the memory right we have to

216
00:07:42,790 --> 00:07:44,740
use malloc there's we handed malloc or

217
00:07:44,740 --> 00:07:46,360
allocate memory on our own so we know s

218
00:07:46,360 --> 00:07:48,940
can provide us this but then we're gonna

219
00:07:48,940 --> 00:07:52,510
break up this memory region into fixed

220
00:07:52,510 --> 00:07:55,090
size or page size chunks called frames

221
00:07:55,090 --> 00:07:58,240
and this is you know frame seems kind of

222
00:07:58,240 --> 00:08:00,040
unusual why don't I just say page or

223
00:08:00,040 --> 00:08:01,600
block or whatever there's so many

224
00:08:01,600 --> 00:08:04,180
different terms in database systems to

225
00:08:04,180 --> 00:08:06,010
roughly describing the same thing so

226
00:08:06,010 --> 00:08:09,970
frames correspond to slots in the or see

227
00:08:09,970 --> 00:08:11,590
I use the term slot when use that frames

228
00:08:11,590 --> 00:08:13,300
correspond to regions or chunks in the

229
00:08:13,300 --> 00:08:15,130
buffer pool memory region that we can

230
00:08:15,130 --> 00:08:17,680
put pages in right and we slot is the

231
00:08:17,680 --> 00:08:19,270
thing we put things into pages within

232
00:08:19,270 --> 00:08:19,930
for tuples

233
00:08:19,930 --> 00:08:22,330
so for buffer pool it's it's frames for

234
00:08:22,330 --> 00:08:25,840
on the page it'll be slots so what

235
00:08:25,840 --> 00:08:27,580
happens is when the database system

236
00:08:27,580 --> 00:08:29,440
calls makes a request and say I want a

237
00:08:29,440 --> 00:08:31,390
page right we're gonna look to see

238
00:08:31,390 --> 00:08:32,590
whether it's already in our in our

239
00:08:32,590 --> 00:08:34,690
buffer pool if not then we go out in the

240
00:08:34,690 --> 00:08:36,940
disk make a copy of it fetch that you

241
00:08:36,940 --> 00:08:38,830
didn't put it into memory so this is a

242
00:08:38,830 --> 00:08:40,780
straight one-to-one copy we're not doing

243
00:08:40,780 --> 00:08:43,299
any D civilization all right we can

244
00:08:43,299 --> 00:08:44,830
ignore compression for now but whatever

245
00:08:44,830 --> 00:08:46,720
however it's represented on disk is

246
00:08:46,720 --> 00:08:48,640
exactly how it'll be represented in

247
00:08:48,640 --> 00:08:50,320
memory we're not doing any marshaling of

248
00:08:50,320 --> 00:08:51,640
the data we just take take it from the

249
00:08:51,640 --> 00:08:52,830
disk and put it directly in the memory

250
00:08:52,830 --> 00:08:54,970
all right we keep doing this roll all

251
00:08:54,970 --> 00:08:56,650
the other pages that that that we may

252
00:08:56,650 --> 00:08:57,740
need

253
00:08:57,740 --> 00:09:01,730
right so the in my earlier example when

254
00:09:01,730 --> 00:09:03,380
I sin I showed how the execution ender

255
00:09:03,380 --> 00:09:06,230
says hey I want a page to write it

256
00:09:06,230 --> 00:09:08,000
manually you know Buffalo manager magic

257
00:09:08,000 --> 00:09:12,020
figured out what page two is so in our

258
00:09:12,020 --> 00:09:14,060
if we're just organizing these things as

259
00:09:14,060 --> 00:09:18,110
frames pages can go in any order in the

260
00:09:18,110 --> 00:09:20,900
frames that they want right in this case

261
00:09:20,900 --> 00:09:22,880
here even though it's page one page one

262
00:09:22,880 --> 00:09:25,640
two three in my buffer pool its page one

263
00:09:25,640 --> 00:09:26,990
three that's not in the same order that

264
00:09:26,990 --> 00:09:29,300
it's out on disk so we need an extra

265
00:09:29,300 --> 00:09:31,190
indirection layer above this to figure

266
00:09:31,190 --> 00:09:33,530
out if I want a particular page what

267
00:09:33,530 --> 00:09:35,180
frame has the one I want because it's

268
00:09:35,180 --> 00:09:36,350
not going to match exactly the same

269
00:09:36,350 --> 00:09:39,080
order that it is on disk so this is what

270
00:09:39,080 --> 00:09:41,630
the page table is page table is just a

271
00:09:41,630 --> 00:09:43,730
hash table that's going to keep track of

272
00:09:43,730 --> 00:09:45,860
what pages we have in memory and if you

273
00:09:45,860 --> 00:09:47,600
ask for a particular page ID it'll tell

274
00:09:47,600 --> 00:09:50,240
you what frame that is located located

275
00:09:50,240 --> 00:09:54,080
in all right and so the database systems

276
00:09:54,080 --> 00:09:55,820
can have to maintain some additional

277
00:09:55,820 --> 00:09:59,060
metadata to keep track of what what's

278
00:09:59,060 --> 00:10:00,110
going on with the pages that it

279
00:10:00,110 --> 00:10:03,380
currently has in its buffer pool so the

280
00:10:03,380 --> 00:10:04,730
first thing we got to keep track of is

281
00:10:04,730 --> 00:10:06,770
called the dirty flag and this is just a

282
00:10:06,770 --> 00:10:08,840
flag single bit that tells us whether

283
00:10:08,840 --> 00:10:11,780
the page has been modified since it's

284
00:10:11,780 --> 00:10:14,540
been read from from disk did some query

285
00:10:14,540 --> 00:10:17,840
some transaction make a change to it the

286
00:10:17,840 --> 00:10:19,310
other thing that I keep track of also is

287
00:10:19,310 --> 00:10:21,200
called a pin count or a reference

288
00:10:21,200 --> 00:10:23,210
counter and this is just keeping track

289
00:10:23,210 --> 00:10:25,490
of the number of threads or queries that

290
00:10:25,490 --> 00:10:29,090
are currently running that want this

291
00:10:29,090 --> 00:10:31,490
page to remain in memory meaning we

292
00:10:31,490 --> 00:10:32,780
don't we don't want it written out to

293
00:10:32,780 --> 00:10:34,730
disk right it could be because I'm gonna

294
00:10:34,730 --> 00:10:36,830
update it so I do my fetch I go fetch

295
00:10:36,830 --> 00:10:38,000
the page I need bring into my buffer

296
00:10:38,000 --> 00:10:40,130
pool then I'm gonna go ahead and go

297
00:10:40,130 --> 00:10:41,690
ahead and modify I don't want that page

298
00:10:41,690 --> 00:10:43,340
to get evicted or swapped out back at

299
00:10:43,340 --> 00:10:45,290
the disk in between the time it's been

300
00:10:45,290 --> 00:10:46,760
brought in and before I can actually do

301
00:10:46,760 --> 00:10:49,370
my update to it there's also gonna

302
00:10:49,370 --> 00:10:52,850
prevent us from evicting pages that have

303
00:10:52,850 --> 00:10:55,090
not been safely written back to disk yet

304
00:10:55,090 --> 00:10:57,200
alright so again so like I get painted

305
00:10:57,200 --> 00:10:59,410
page and say I don't want this thing in

306
00:10:59,410 --> 00:11:02,330
to every ever be removed from the buffer

307
00:11:02,330 --> 00:11:04,340
pool for now and then say I'm reading a

308
00:11:04,340 --> 00:11:06,440
page here sorry I want to read a page

309
00:11:06,440 --> 00:11:08,240
that's not currently memory I want to

310
00:11:08,240 --> 00:11:10,730
put a latch on this this entry in the

311
00:11:10,730 --> 00:11:11,510
hash table

312
00:11:11,510 --> 00:11:12,920
so that I can go fetch the page and then

313
00:11:12,920 --> 00:11:14,240
update the page if I do not point to it

314
00:11:14,240 --> 00:11:16,370
right and I have to do this because

315
00:11:16,370 --> 00:11:17,630
multiple threats were running at the

316
00:11:17,630 --> 00:11:19,850
same time I can't assume that I'm the

317
00:11:19,850 --> 00:11:20,960
only person I'm looking at the page

318
00:11:20,960 --> 00:11:22,340
table so I want to rent somebody else

319
00:11:22,340 --> 00:11:24,290
from taking this this entry in my

320
00:11:24,290 --> 00:11:26,240
patient and while I'm fetching the page

321
00:11:26,240 --> 00:11:27,470
that I need they come and steal it from

322
00:11:27,470 --> 00:11:30,680
me and put something else in alright so

323
00:11:30,680 --> 00:11:32,870
again is theirs well see this as we go

324
00:11:32,870 --> 00:11:34,460
along later in the semester but there's

325
00:11:34,460 --> 00:11:35,900
a bunch of extra stuff we have to do to

326
00:11:35,900 --> 00:11:37,640
keep track of what pages have been

327
00:11:37,640 --> 00:11:39,260
modified so the dirty bit is just sort

328
00:11:39,260 --> 00:11:41,180
of one piece of it we also need keep

329
00:11:41,180 --> 00:11:43,400
track of who actually made the

330
00:11:43,400 --> 00:11:45,740
modification so because we want to write

331
00:11:45,740 --> 00:11:47,870
a log record to say here's the change

332
00:11:47,870 --> 00:11:48,830
that was made we're gonna make sure that

333
00:11:48,830 --> 00:11:50,240
log records written first before our

334
00:11:50,240 --> 00:11:52,190
page is written this is another example

335
00:11:52,190 --> 00:11:55,070
ymf is a bad idea because i can't

336
00:11:55,070 --> 00:11:56,420
guarantee the operating system is not

337
00:11:56,420 --> 00:11:57,950
gonna write my page out the disk before

338
00:11:57,950 --> 00:12:01,160
I want it to okay that's it doesn't

339
00:12:01,160 --> 00:12:03,080
doesn't prevent you from doing that at

340
00:12:03,080 --> 00:12:04,760
least on linux freebsd can let you do

341
00:12:04,760 --> 00:12:07,250
this but windows and linux don't want

342
00:12:07,250 --> 00:12:10,010
you prevent this alright so is this

343
00:12:10,010 --> 00:12:11,240
clear what we're trying to do here right

344
00:12:11,240 --> 00:12:13,250
basically managing our own memory but

345
00:12:13,250 --> 00:12:15,470
we're keeping track of how the

346
00:12:15,470 --> 00:12:17,120
transactions or queries are modifying

347
00:12:17,120 --> 00:12:19,340
the pages and we have to protect

348
00:12:19,340 --> 00:12:21,110
ourselves and the page table to prevent

349
00:12:21,110 --> 00:12:23,240
anybody else and you know addicting

350
00:12:23,240 --> 00:12:25,220
things or writing stuff before we're

351
00:12:25,220 --> 00:12:28,450
done with with what we wanted me to do

352
00:12:28,450 --> 00:12:35,000
any questions okay so I need to make a

353
00:12:35,000 --> 00:12:37,280
very important distinction now about the

354
00:12:37,280 --> 00:12:39,260
difference being locks and latches so

355
00:12:39,260 --> 00:12:40,790
this will come up later on you have to

356
00:12:40,790 --> 00:12:43,670
do this for the first project as well if

357
00:12:43,670 --> 00:12:44,870
you're coming from an operating system

358
00:12:44,870 --> 00:12:48,560
background in in there roll a lock is

359
00:12:48,560 --> 00:12:53,090
what we call a latch so in in in the let

360
00:12:53,090 --> 00:12:54,470
me try both of them in the context of

361
00:12:54,470 --> 00:12:56,000
databases and I'll see us to describe

362
00:12:56,000 --> 00:12:58,730
how they map into the OS world so a lock

363
00:12:58,730 --> 00:13:01,400
in dated in the database world is some

364
00:13:01,400 --> 00:13:03,740
higher-level logical primitive that's

365
00:13:03,740 --> 00:13:06,290
going to protect the contents of the

366
00:13:06,290 --> 00:13:07,730
database the logical contents like a

367
00:13:07,730 --> 00:13:11,420
tuple a table a database all right and

368
00:13:11,420 --> 00:13:13,970
the transaction is gonna hold this lock

369
00:13:13,970 --> 00:13:16,190
for its duration and while it's running

370
00:13:16,190 --> 00:13:17,540
which means could could be multiple

371
00:13:17,540 --> 00:13:19,520
queries this could be you know multiple

372
00:13:19,520 --> 00:13:21,410
milliseconds or multiple seconds even or

373
00:13:21,410 --> 00:13:23,390
even in minutes or hours if it's a

374
00:13:23,390 --> 00:13:24,890
really long running query

375
00:13:24,890 --> 00:13:27,170
so in that world again this is something

376
00:13:27,170 --> 00:13:28,790
that data systems can provide to us and

377
00:13:28,790 --> 00:13:32,270
expose to you as like the application

378
00:13:32,270 --> 00:13:33,830
programmer you even see what locks are

379
00:13:33,830 --> 00:13:36,130
being held for as you run queries

380
00:13:36,130 --> 00:13:38,840
latches are the low level protection

381
00:13:38,840 --> 00:13:41,480
primitives that we use for the critical

382
00:13:41,480 --> 00:13:42,740
sections of the internals of the

383
00:13:42,740 --> 00:13:45,100
database systems like perfecting

384
00:13:45,100 --> 00:13:47,240
protecting data structure perfecting

385
00:13:47,240 --> 00:13:50,330
protecting regions of memory and so for

386
00:13:50,330 --> 00:13:51,830
these these latches we're gonna hold for

387
00:13:51,830 --> 00:13:53,360
just the duration of the operation that

388
00:13:53,360 --> 00:13:55,160
we're making like if I go update my page

389
00:13:55,160 --> 00:13:58,660
table I take a latch on the entry on the

390
00:13:58,660 --> 00:14:01,100
location of that I'm gonna modify make

391
00:14:01,100 --> 00:14:03,070
the change and then I release the latch

392
00:14:03,070 --> 00:14:05,060
all right and we're not we don't need to

393
00:14:05,060 --> 00:14:06,380
worry about rolling back any changes in

394
00:14:06,380 --> 00:14:08,420
the same way we do for locks because

395
00:14:08,420 --> 00:14:11,330
it's it's an internal thing or updating

396
00:14:11,330 --> 00:14:12,650
the physical data structure of the

397
00:14:12,650 --> 00:14:14,480
database system I make the change and if

398
00:14:14,480 --> 00:14:15,950
I can't actually get the latch I want

399
00:14:15,950 --> 00:14:18,440
then I did a board and and don't worry

400
00:14:18,440 --> 00:14:23,090
about rolling back yes okay so he says

401
00:14:23,090 --> 00:14:24,470
rolling back changes this will come

402
00:14:24,470 --> 00:14:25,550
later on we talk about courtesy troll

403
00:14:25,550 --> 00:14:28,340
but basically say like I wanna take

404
00:14:28,340 --> 00:14:29,630
money out of my bank account and put it

405
00:14:29,630 --> 00:14:31,070
in your bank account so we take money

406
00:14:31,070 --> 00:14:32,840
out of my bank account but then the

407
00:14:32,840 --> 00:14:34,190
system crashes before I put the money in

408
00:14:34,190 --> 00:14:35,540
your account I want to roll back the

409
00:14:35,540 --> 00:14:36,860
change I made to my account because I

410
00:14:36,860 --> 00:14:38,240
don't to lose that money that's not to

411
00:14:38,240 --> 00:14:40,190
me like that right this will discuss a

412
00:14:40,190 --> 00:14:41,540
whole lecture on convergent roll it's

413
00:14:41,540 --> 00:14:44,390
awesome trust me but for now the main

414
00:14:44,390 --> 00:14:45,440
thing we're focused on this thing here

415
00:14:45,440 --> 00:14:48,950
right so again in the operating system

416
00:14:48,950 --> 00:14:50,480
world this would allow should be

417
00:14:50,480 --> 00:14:52,670
something like a mutex we're actually

418
00:14:52,670 --> 00:14:54,920
going to use mutexes in in our database

419
00:14:54,920 --> 00:14:56,420
system to protect the critical sections

420
00:14:56,420 --> 00:14:58,760
of things so I will try to be very

421
00:14:58,760 --> 00:15:00,350
careful and always say latch when I mean

422
00:15:00,350 --> 00:15:02,840
latch but occasionally I slip up and

423
00:15:02,840 --> 00:15:05,210
we'll use lock but I said it's an

424
00:15:05,210 --> 00:15:08,090
internal thing we mean latch it's also

425
00:15:08,090 --> 00:15:09,560
very confusing too because the mutex

426
00:15:09,560 --> 00:15:11,210
implementation you would use to protect

427
00:15:11,210 --> 00:15:13,700
you for his latch is called a spin lock

428
00:15:13,700 --> 00:15:15,650
alright but it's really you know this

429
00:15:15,650 --> 00:15:20,490
thing and not this thing ok all right

430
00:15:20,490 --> 00:15:22,320
so the other think we want to make is

431
00:15:22,320 --> 00:15:23,310
the difference between the page

432
00:15:23,310 --> 00:15:25,650
directory and the page table so remember

433
00:15:25,650 --> 00:15:29,100
the page directory is what we're going

434
00:15:29,100 --> 00:15:31,140
to use to figure out where to find pages

435
00:15:31,140 --> 00:15:34,230
in our files so we want page 1 2 3 it'll

436
00:15:34,230 --> 00:15:35,700
tell us what file at what all said or

437
00:15:35,700 --> 00:15:37,470
what's what set of files

438
00:15:37,470 --> 00:15:40,440
have-have what we're looking for so all

439
00:15:40,440 --> 00:15:42,120
the changes we're gonna make to the page

440
00:15:42,120 --> 00:15:44,100
directory have to be durable they have

441
00:15:44,100 --> 00:15:45,600
to be written about the disk because if

442
00:15:45,600 --> 00:15:48,300
we crash come back we want to know where

443
00:15:48,300 --> 00:15:51,240
to find the pages that we have the page

444
00:15:51,240 --> 00:15:54,420
table is an internal in memory map that

445
00:15:54,420 --> 00:15:56,520
just mats page IDs to where the the

446
00:15:56,520 --> 00:15:59,370
frames of a are in the buffer pool so

447
00:15:59,370 --> 00:16:00,840
this thing can be Italian ephemeral and

448
00:16:00,840 --> 00:16:02,460
we don't need to backup by disc because

449
00:16:02,460 --> 00:16:05,010
if we crash and come back our buffer

450
00:16:05,010 --> 00:16:07,010
pool is blown away anyway so who cares

451
00:16:07,010 --> 00:16:09,960
so this page directory has to be durable

452
00:16:09,960 --> 00:16:12,840
the the page table does not does not

453
00:16:12,840 --> 00:16:14,640
have to be and that means we just used

454
00:16:14,640 --> 00:16:16,440
whatever your favorite hash map or hash

455
00:16:16,440 --> 00:16:19,050
table implementation you want right for

456
00:16:19,050 --> 00:16:20,640
project 1 you're just used s to be a

457
00:16:20,640 --> 00:16:24,150
city map that's fine because again we

458
00:16:24,150 --> 00:16:25,200
don't have to worry about this thing

459
00:16:25,200 --> 00:16:27,540
being durable we have to make sure it's

460
00:16:27,540 --> 00:16:29,640
thread safe certainly but not not

461
00:16:29,640 --> 00:16:33,360
durable all right so now when we start

462
00:16:33,360 --> 00:16:34,560
talking about how we want to allocate

463
00:16:34,560 --> 00:16:37,170
memory in our database for the buffer

464
00:16:37,170 --> 00:16:39,390
pool we will we throw to think about

465
00:16:39,390 --> 00:16:41,970
this in two different ways so the first

466
00:16:41,970 --> 00:16:43,260
is that we can choose what I call a sort

467
00:16:43,260 --> 00:16:46,350
of global policies where we're trying to

468
00:16:46,350 --> 00:16:48,450
make decisions that benefit the entire

469
00:16:48,450 --> 00:16:50,130
workload that we're trying to turn

470
00:16:50,130 --> 00:16:52,680
trying to execute we look at all the

471
00:16:52,680 --> 00:16:53,910
queries all the transactions that are

472
00:16:53,910 --> 00:16:55,650
going on in the system we try to say at

473
00:16:55,650 --> 00:16:56,940
this point in time what's the right

474
00:16:56,940 --> 00:16:59,160
thing I should do for choosing what

475
00:16:59,160 --> 00:17:02,550
should be in memory versus not memory an

476
00:17:02,550 --> 00:17:05,550
alternative is to use a local policy

477
00:17:05,550 --> 00:17:08,339
we're on for each single query or each

478
00:17:08,339 --> 00:17:10,920
single transaction we're running we try

479
00:17:10,920 --> 00:17:12,599
to say what the best thing to do to make

480
00:17:12,599 --> 00:17:14,700
my one query one transaction go faster

481
00:17:14,700 --> 00:17:17,459
even though for the for the the global

482
00:17:17,459 --> 00:17:19,380
system that actually might be a bad a

483
00:17:19,380 --> 00:17:23,970
bad choice so the there's no one way

484
00:17:23,970 --> 00:17:25,349
that's better than another obviously

485
00:17:25,349 --> 00:17:27,119
there's optimization you can do if you

486
00:17:27,119 --> 00:17:28,710
have a global view versus a local view

487
00:17:28,710 --> 00:17:30,270
but then for each integer query you

488
00:17:30,270 --> 00:17:32,160
might be be more tailored to what they

489
00:17:32,160 --> 00:17:33,620
want to do to make that run fast

490
00:17:33,620 --> 00:17:35,390
so as we've seen a much of these

491
00:17:35,390 --> 00:17:36,590
examples as we go along for

492
00:17:36,590 --> 00:17:38,990
optimizations the most systems will

493
00:17:38,990 --> 00:17:40,490
probably try to do accommodation of the

494
00:17:40,490 --> 00:17:42,770
two of them what you'll be implementing

495
00:17:42,770 --> 00:17:44,570
for the first project is considered a

496
00:17:44,570 --> 00:17:45,620
global policy because there's just

497
00:17:45,620 --> 00:17:47,870
looking at you know what's the least

498
00:17:47,870 --> 00:17:49,690
recently used page and removing that

499
00:17:49,690 --> 00:17:51,830
even though that make me bad for one

500
00:17:51,830 --> 00:17:55,580
particular query all right so that

501
00:17:55,580 --> 00:17:56,960
basically all you really need to know

502
00:17:56,960 --> 00:17:59,090
about how to build a buffer pool right

503
00:17:59,090 --> 00:18:00,679
it's just you have a page table that

504
00:18:00,679 --> 00:18:03,080
map's page IDs to frames and then you

505
00:18:03,080 --> 00:18:05,120
look in the all set and you're in the

506
00:18:05,120 --> 00:18:07,220
allocated memory and that tells you

507
00:18:07,220 --> 00:18:08,330
here's the page that you were looking

508
00:18:08,330 --> 00:18:12,890
for it seems pretty simple right so now

509
00:18:12,890 --> 00:18:14,000
we want to talk about how to actually

510
00:18:14,000 --> 00:18:15,620
make this thing be super awesome or

511
00:18:15,620 --> 00:18:18,380
super tailored for the application that

512
00:18:18,380 --> 00:18:20,059
we're trying to run or the work over

513
00:18:20,059 --> 00:18:21,289
trying to run inside of our database

514
00:18:21,289 --> 00:18:23,120
system and this is gonna allow us to do

515
00:18:23,120 --> 00:18:24,470
certain things that the operating system

516
00:18:24,470 --> 00:18:26,210
can't do because it doesn't know

517
00:18:26,210 --> 00:18:27,440
anything about what kind of queries

518
00:18:27,440 --> 00:18:28,610
you're running it doesn't know what data

519
00:18:28,610 --> 00:18:29,630
they're touching what are they're gonna

520
00:18:29,630 --> 00:18:30,289
touch next

521
00:18:30,289 --> 00:18:32,029
all right so now we can talk about what

522
00:18:32,029 --> 00:18:33,770
we can do to make this thing do better

523
00:18:33,770 --> 00:18:35,659
than what sort of a naive scheme would

524
00:18:35,659 --> 00:18:37,520
do so talk about how to handle multiple

525
00:18:37,520 --> 00:18:39,140
buffer pools prefetching the scan

526
00:18:39,140 --> 00:18:41,270
sharing and then the last one be buffer

527
00:18:41,270 --> 00:18:45,799
pool bypass okay so in my example that I

528
00:18:45,799 --> 00:18:48,380
showed I referred to the buffer pool as

529
00:18:48,380 --> 00:18:51,110
a single entity and the datum has one

530
00:18:51,110 --> 00:18:54,140
buffer pool in actuality you can have

531
00:18:54,140 --> 00:18:56,179
multiple buffer pools so you have

532
00:18:56,179 --> 00:18:57,440
multiple regions of memory you've

533
00:18:57,440 --> 00:18:59,270
allocated they each have their own page

534
00:18:59,270 --> 00:19:00,380
table they each have their own been

535
00:19:00,380 --> 00:19:03,980
mapping to from page IDs to frame IDs or

536
00:19:03,980 --> 00:19:07,309
frames all right and the reason why you

537
00:19:07,309 --> 00:19:09,080
want to do this is now you can have for

538
00:19:09,080 --> 00:19:11,200
each buffer pool you can actually have

539
00:19:11,200 --> 00:19:13,880
local policy for that buffer pool that's

540
00:19:13,880 --> 00:19:15,770
tailored for whatever is the data that

541
00:19:15,770 --> 00:19:18,049
you're putting into it you know so for

542
00:19:18,049 --> 00:19:20,960
example I could have a a single buffer

543
00:19:20,960 --> 00:19:23,630
pool for each table because maybe some

544
00:19:23,630 --> 00:19:24,860
tables I'm doing a bunch of scruncho

545
00:19:24,860 --> 00:19:27,169
scans and some tables I'm doing point

546
00:19:27,169 --> 00:19:28,220
queries or I'm jumping to single pages

547
00:19:28,220 --> 00:19:30,320
at a time and I can have different

548
00:19:30,320 --> 00:19:31,669
cashman policies or different placement

549
00:19:31,669 --> 00:19:33,620
policies to decide based on the two

550
00:19:33,620 --> 00:19:35,690
workload types but I can't do that

551
00:19:35,690 --> 00:19:38,000
easily if it's a giant just a giant a

552
00:19:38,000 --> 00:19:40,130
buffer pool well let's say I have it I

553
00:19:40,130 --> 00:19:41,510
can have a buffer pool for an index and

554
00:19:41,510 --> 00:19:43,190
buffer pool for tables and then they

555
00:19:43,190 --> 00:19:44,390
have different access patterns and then

556
00:19:44,390 --> 00:19:45,919
I can have different policies for each

557
00:19:45,919 --> 00:19:46,990
of those

558
00:19:46,990 --> 00:19:49,059
the other big advantage you also get is

559
00:19:49,059 --> 00:19:50,620
that it's gonna end up reducing latch

560
00:19:50,620 --> 00:19:53,799
contention for the different threads

561
00:19:53,799 --> 00:19:55,779
that are trying to access it right so

562
00:19:55,779 --> 00:19:56,980
when I do that look up in the page table

563
00:19:56,980 --> 00:19:58,510
I have to take a latch on the entry that

564
00:19:58,510 --> 00:20:01,000
I'm looking at as I go find the frame

565
00:20:01,000 --> 00:20:02,350
that has the data that I want and I'll

566
00:20:02,350 --> 00:20:03,700
make sure that nobody else swaps that

567
00:20:03,700 --> 00:20:06,399
out what but you know from the time I do

568
00:20:06,399 --> 00:20:07,720
the lookup from the time I go get the

569
00:20:07,720 --> 00:20:10,990
page that I want and so that means that

570
00:20:10,990 --> 00:20:12,970
I could have a bunch of threads call

571
00:20:12,970 --> 00:20:14,919
contending on the same latch that could

572
00:20:14,919 --> 00:20:16,149
they're all accessing the same page

573
00:20:16,149 --> 00:20:18,340
table so no matter how many cores I have

574
00:20:18,340 --> 00:20:20,380
on my brand-new machine I'm not getting

575
00:20:20,380 --> 00:20:22,690
good scalability because everything's

576
00:20:22,690 --> 00:20:25,059
contended on these these critical

577
00:20:25,059 --> 00:20:27,279
sections but now if I just have multiple

578
00:20:27,279 --> 00:20:30,700
page tables each thread you know they

579
00:20:30,700 --> 00:20:32,020
could be accessing different pages of

580
00:20:32,020 --> 00:20:33,850
different page tables at the same time

581
00:20:33,850 --> 00:20:35,620
and therefore they're not contending on

582
00:20:35,620 --> 00:20:37,360
those latches and now I get better

583
00:20:37,360 --> 00:20:39,429
scalability now still could be still

584
00:20:39,429 --> 00:20:40,779
bottlenecks on the disk feed which is

585
00:20:40,779 --> 00:20:42,730
always a big problem at least internally

586
00:20:42,730 --> 00:20:44,860
now I'm not worried about them you know

587
00:20:44,860 --> 00:20:48,010
trying to all acquire the same latch so

588
00:20:48,010 --> 00:20:50,260
this is something you see mostly in the

589
00:20:50,260 --> 00:20:52,179
enterprise or expensive database systems

590
00:20:52,179 --> 00:20:56,679
so Oracle db2 Sybase and for max Seigle

591
00:20:56,679 --> 00:20:58,450
server all support this ability to have

592
00:20:58,450 --> 00:21:01,000
multiple purple's db2 you do all sorts

593
00:21:01,000 --> 00:21:01,990
of crazy things you can create multiple

594
00:21:01,990 --> 00:21:04,059
multiple buffer pools you can sign them

595
00:21:04,059 --> 00:21:05,169
different tables you can have different

596
00:21:05,169 --> 00:21:06,940
cashman policies for all for all them if

597
00:21:06,940 --> 00:21:08,500
you set them to be their different page

598
00:21:08,500 --> 00:21:11,710
sizes my Siegel even though it's open

599
00:21:11,710 --> 00:21:13,659
source actually has this as well it's

600
00:21:13,659 --> 00:21:15,789
it's not that as sophisticated you just

601
00:21:15,789 --> 00:21:17,230
say how many buffer pool instances you

602
00:21:17,230 --> 00:21:19,330
want and then they just do round-robin

603
00:21:19,330 --> 00:21:22,960
hashing to decide what what you know if

604
00:21:22,960 --> 00:21:24,850
you'll forgive and pagenty where's the

605
00:21:24,850 --> 00:21:25,990
data that I'm looking for what buffer

606
00:21:25,990 --> 00:21:29,770
pool has it so there's two ways to use

607
00:21:29,770 --> 00:21:31,990
these things right they've to map the

608
00:21:31,990 --> 00:21:33,159
thing that you're looking for to a

609
00:21:33,159 --> 00:21:35,440
buffer pool that has the page that that

610
00:21:35,440 --> 00:21:36,760
you want I said typically what happens

611
00:21:36,760 --> 00:21:38,710
is if you have multiple buffer pools you

612
00:21:38,710 --> 00:21:41,559
can't have a page in one you know in in

613
00:21:41,559 --> 00:21:43,270
buffer pool one this time and then when

614
00:21:43,270 --> 00:21:44,679
you fetch about the disco later on it

615
00:21:44,679 --> 00:21:46,120
comes out another one it always wants to

616
00:21:46,120 --> 00:21:47,230
be in the same location so you know how

617
00:21:47,230 --> 00:21:50,289
you know how to find it quickly so the

618
00:21:50,289 --> 00:21:51,429
first approach is that you can actually

619
00:21:51,429 --> 00:21:53,649
extend the record ID to now include

620
00:21:53,649 --> 00:21:56,409
additional metadata about what database

621
00:21:56,409 --> 00:21:59,230
object this buffer pool is managing

622
00:21:59,230 --> 00:22:01,529
so if you recall when we looked at the

623
00:22:01,529 --> 00:22:05,500
record IDs of Oracle and sequel server

624
00:22:05,500 --> 00:22:07,899
they had extra columns extra information

625
00:22:07,899 --> 00:22:09,940
that Postgres didn't have back postcode

626
00:22:09,940 --> 00:22:12,190
had the page and the slot number will

627
00:22:12,190 --> 00:22:14,470
have like the the object number page

628
00:22:14,470 --> 00:22:17,440
number and and a slot number so we could

629
00:22:17,440 --> 00:22:19,570
use that that additional object number

630
00:22:19,570 --> 00:22:21,279
they didn't have another map that says

631
00:22:21,279 --> 00:22:23,889
all right for object you know XYZ you

632
00:22:23,889 --> 00:22:25,659
can it's a Miss it's in this buffer pool

633
00:22:25,659 --> 00:22:28,750
or that buffer pool and so now the

634
00:22:28,750 --> 00:22:30,669
requests from up at level of the system

635
00:22:30,669 --> 00:22:31,750
you're saying give me you know give me a

636
00:22:31,750 --> 00:22:33,429
record one two three and I know how to

637
00:22:33,429 --> 00:22:35,769
split that up and find out what object

638
00:22:35,769 --> 00:22:37,419
it corresponds to and what buffer pool

639
00:22:37,419 --> 00:22:41,169
will maintain that data for the hashing

640
00:22:41,169 --> 00:22:42,190
approach again I think that's what my

641
00:22:42,190 --> 00:22:43,840
secret does it's pretty simple you just

642
00:22:43,840 --> 00:22:45,909
take the record ID you hash it and mod n

643
00:22:45,909 --> 00:22:47,740
by the number of buffer pools you have

644
00:22:47,740 --> 00:22:49,960
and that just tells you where to go get

645
00:22:49,960 --> 00:22:52,210
the dinner do you want and this you do

646
00:22:52,210 --> 00:22:54,250
is really quickly really fast it's not

647
00:22:54,250 --> 00:22:55,570
an expensive operation actually for

648
00:22:55,570 --> 00:22:56,679
either there's it's not an expensive

649
00:22:56,679 --> 00:22:58,950
operation

650
00:22:58,950 --> 00:23:01,029
all right the next optimization we can

651
00:23:01,029 --> 00:23:04,539
do is to do prefetching so the idea here

652
00:23:04,539 --> 00:23:06,639
is that again we want to minimize the

653
00:23:06,639 --> 00:23:09,490
stalls and the data system due to having

654
00:23:09,490 --> 00:23:12,760
to go to disk or read data so if we

655
00:23:12,760 --> 00:23:15,039
start doing like a scan and our buffer

656
00:23:15,039 --> 00:23:17,260
pool is emptying this query wants to

657
00:23:17,260 --> 00:23:20,110
read page zero page there is not in

658
00:23:20,110 --> 00:23:22,480
memory not in our buffer pool so we have

659
00:23:22,480 --> 00:23:24,519
to stall that thread until we go out the

660
00:23:24,519 --> 00:23:26,409
disk fetch it and then put it into our

661
00:23:26,409 --> 00:23:28,720
buffer pool then once it's in our proper

662
00:23:28,720 --> 00:23:30,820
pool then we hand back the pointer to

663
00:23:30,820 --> 00:23:32,409
the upper-level system say the page you

664
00:23:32,409 --> 00:23:34,450
wanted is now here in our in our memory

665
00:23:34,450 --> 00:23:37,679
go do whatever it is that you want to do

666
00:23:37,679 --> 00:23:39,970
so the way to think about this is like

667
00:23:39,970 --> 00:23:42,460
it's a you can think of this arrow is

668
00:23:42,460 --> 00:23:44,470
like a cursor so internally a database

669
00:23:44,470 --> 00:23:47,169
system is gonna keep track of this thing

670
00:23:47,169 --> 00:23:48,850
kind of cursor like as you iterate over

671
00:23:48,850 --> 00:23:50,500
every single page for that your query

672
00:23:50,500 --> 00:23:52,149
needs you just know where you left off

673
00:23:52,149 --> 00:23:53,320
the last time so when you go back and

674
00:23:53,320 --> 00:23:55,179
said give me the next page it doesn't

675
00:23:55,179 --> 00:23:56,230
start at the beginning it jumps where

676
00:23:56,230 --> 00:23:59,049
you were you left off so in this case

677
00:23:59,049 --> 00:24:01,210
here I get paid zero I'm done right now

678
00:24:01,210 --> 00:24:03,130
I start reading page one same thing I

679
00:24:03,130 --> 00:24:04,679
have to stall because it's not in memory

680
00:24:04,679 --> 00:24:06,909
the disk goes and gets it we've put in

681
00:24:06,909 --> 00:24:08,019
our tour buffer pool and then once I

682
00:24:08,019 --> 00:24:10,389
have that now I can now I can proceed

683
00:24:10,389 --> 00:24:11,530
operating their own

684
00:24:11,530 --> 00:24:13,570
so let's say this query here wants to

685
00:24:13,570 --> 00:24:15,490
scan the entire table alright these are

686
00:24:15,490 --> 00:24:17,460
for our table here here's all the pages

687
00:24:17,460 --> 00:24:20,410
so at this point the data used to

688
00:24:20,410 --> 00:24:22,300
probably recognize oh I know you're

689
00:24:22,300 --> 00:24:24,100
gonna end up scanning the entire table

690
00:24:24,100 --> 00:24:26,740
so rather than just wait with me waiting

691
00:24:26,740 --> 00:24:28,390
for you to ask each page one after

692
00:24:28,390 --> 00:24:30,490
another let me go ahead and jump ahead

693
00:24:30,490 --> 00:24:31,900
and say oh I think you're also going to

694
00:24:31,900 --> 00:24:34,330
need page two and three so let me go

695
00:24:34,330 --> 00:24:36,670
prefetch that for you put into the

696
00:24:36,670 --> 00:24:39,070
buffer pool so by the time you finished

697
00:24:39,070 --> 00:24:41,290
processing page one and now you go ask

698
00:24:41,290 --> 00:24:44,260
me for page 2 or page 3 it's already

699
00:24:44,260 --> 00:24:46,810
there now you don't have a stall and

700
00:24:46,810 --> 00:24:48,940
again based on how I laid out these

701
00:24:48,940 --> 00:24:51,190
pages on disk and that might have been a

702
00:24:51,190 --> 00:24:54,280
sequential read which is super fast so

703
00:24:54,280 --> 00:24:55,900
by preventing things ahead of time I you

704
00:24:55,900 --> 00:24:58,420
know I'm minimizing the amount of random

705
00:24:58,420 --> 00:25:02,170
i/o that I'm doing right let's keep

706
00:25:02,170 --> 00:25:03,580
going this down and and prefetch

707
00:25:03,580 --> 00:25:05,200
everything's that again that minimizes

708
00:25:05,200 --> 00:25:09,310
the impact of these distal x' so this

709
00:25:09,310 --> 00:25:13,300
example is pretty simple right the the

710
00:25:13,300 --> 00:25:14,260
operating system at you could figure

711
00:25:14,260 --> 00:25:17,140
this out too now and and nmap will

712
00:25:17,140 --> 00:25:19,570
actually do this for you right so an M

713
00:25:19,570 --> 00:25:21,430
map you can pat the flag say I'm gonna

714
00:25:21,430 --> 00:25:23,230
do a special read on these pages on disk

715
00:25:23,230 --> 00:25:25,690
and it'll go ahead and prefetch a bunch

716
00:25:25,690 --> 00:25:28,090
of them ahead of time and so again that

717
00:25:28,090 --> 00:25:30,040
will minimize the stalls having because

718
00:25:30,040 --> 00:25:30,880
because you had to read something from

719
00:25:30,880 --> 00:25:34,410
disk so M map can figure this out

720
00:25:34,410 --> 00:25:36,340
without even knowing anything out what

721
00:25:36,340 --> 00:25:37,600
the queries trying to do and the data

722
00:25:37,600 --> 00:25:38,770
system knows what the query wants to do

723
00:25:38,770 --> 00:25:41,110
and can go prefetch ahead of time but

724
00:25:41,110 --> 00:25:43,390
now there's to be some queries where the

725
00:25:43,390 --> 00:25:44,800
operating system is not going to be able

726
00:25:44,800 --> 00:25:46,570
to know what to do but we do in the

727
00:25:46,570 --> 00:25:47,920
nativist system because we know what the

728
00:25:47,920 --> 00:25:50,530
query wants so you so an example of this

729
00:25:50,530 --> 00:25:53,350
would be like an index game so let's say

730
00:25:53,350 --> 00:25:55,300
I want to do a scan on this table and I

731
00:25:55,300 --> 00:25:57,340
want to get all the values I want to

732
00:25:57,340 --> 00:25:58,570
find all the tuples with the value is

733
00:25:58,570 --> 00:26:03,130
between 100 and 250 so now let's say

734
00:26:03,130 --> 00:26:06,160
that I have an index on that value and

735
00:26:06,160 --> 00:26:07,450
I've explained what an index is just

736
00:26:07,450 --> 00:26:09,460
think of this as like a glossary in your

737
00:26:09,460 --> 00:26:10,990
textbook it allows you to jump to a

738
00:26:10,990 --> 00:26:12,280
particular page that has the data that

739
00:26:12,280 --> 00:26:14,620
you want all right so right so instead

740
00:26:14,620 --> 00:26:16,570
of spewing sequential scan I can just

741
00:26:16,570 --> 00:26:18,190
jump through the index and find exactly

742
00:26:18,190 --> 00:26:20,140
what I'm looking for so let's say that

743
00:26:20,140 --> 00:26:23,560
our in our index pages right we know

744
00:26:23,560 --> 00:26:25,619
ahead of time what the ranges are

745
00:26:25,619 --> 00:26:28,479
so when my query starts to do that scan

746
00:26:28,479 --> 00:26:30,369
I always got to read the first page for

747
00:26:30,369 --> 00:26:31,389
the index because that's the route

748
00:26:31,389 --> 00:26:33,759
alright so you know I have to jump to

749
00:26:33,759 --> 00:26:36,190
there but now I'm gonna do a lookup and

750
00:26:36,190 --> 00:26:38,289
say well I'm looking for my query was

751
00:26:38,289 --> 00:26:40,929
between 100 and 250 so I know that all

752
00:26:40,929 --> 00:26:42,879
the pages I need or the values I want

753
00:26:42,879 --> 00:26:44,889
where it's greater than equal to a

754
00:26:44,889 --> 00:26:47,079
hundred or gonna start on this side of

755
00:26:47,079 --> 00:26:49,359
the tree so now I'm gonna jump down into

756
00:26:49,359 --> 00:26:51,969
a page one and read that right that's

757
00:26:51,969 --> 00:26:53,200
still sequential at this point so again

758
00:26:53,200 --> 00:26:54,429
the operative system could Poli figure

759
00:26:54,429 --> 00:26:57,070
this out but now I'm gonna branch and go

760
00:26:57,070 --> 00:27:00,909
down here and I'm gonna scan across the

761
00:27:00,909 --> 00:27:04,029
leaf nodes but this is index page three

762
00:27:04,029 --> 00:27:06,249
index page five they're not contiguous

763
00:27:06,249 --> 00:27:09,579
with each other on on disk and so the

764
00:27:09,579 --> 00:27:10,929
operating system may try to end up

765
00:27:10,929 --> 00:27:13,299
prefetching page two and page three but

766
00:27:13,299 --> 00:27:15,159
I don't need page two that's wasted and

767
00:27:15,159 --> 00:27:16,899
I need page five and it didn't prefetch

768
00:27:16,899 --> 00:27:19,899
that so because we know what the queries

769
00:27:19,899 --> 00:27:22,119
gonna do we can go ahead and prefetch

770
00:27:22,119 --> 00:27:23,979
exactly the pages that we want and bring

771
00:27:23,979 --> 00:27:27,159
them into our buffer pool because we can

772
00:27:27,159 --> 00:27:29,169
we understand what the what's actually

773
00:27:29,169 --> 00:27:31,269
the context what are the context of the

774
00:27:31,269 --> 00:27:32,499
query and what do these pages actually

775
00:27:32,499 --> 00:27:34,570
representing because the operating

776
00:27:34,570 --> 00:27:35,889
system does these pages it doesn't know

777
00:27:35,889 --> 00:27:37,719
what's in them but we know because we

778
00:27:37,719 --> 00:27:39,639
wrote this code we know that these are

779
00:27:39,639 --> 00:27:40,899
index pages and they're connect together

780
00:27:40,899 --> 00:27:42,999
in some way so we know how to do this

781
00:27:42,999 --> 00:27:45,609
traversal so this doesn't come for free

782
00:27:45,609 --> 00:27:47,019
right there's some extra metadata we had

783
00:27:47,019 --> 00:27:48,940
to keep track of in these pages to say

784
00:27:48,940 --> 00:27:50,799
like here's the sibling here's my

785
00:27:50,799 --> 00:27:52,329
starting point or my end point here's

786
00:27:52,329 --> 00:27:54,190
his starting point so I know whether I'm

787
00:27:54,190 --> 00:27:56,229
gonna scan across over here and actually

788
00:27:56,229 --> 00:27:57,940
I can't know whether I need five before

789
00:27:57,940 --> 00:28:01,239
I look at three so you know this I'm not

790
00:28:01,239 --> 00:28:02,979
saying this is like super easy to do but

791
00:28:02,979 --> 00:28:05,379
you can kind of see again how we may not

792
00:28:05,379 --> 00:28:07,629
be jumping exactly through the pages

793
00:28:07,629 --> 00:28:09,700
sequentially in a way that the operative

794
00:28:09,700 --> 00:28:13,809
systems not be able to find again this

795
00:28:13,809 --> 00:28:15,249
this is this to me this is the classic

796
00:28:15,249 --> 00:28:16,479
example of what we can do in our

797
00:28:16,479 --> 00:28:18,190
database system that opera sim cannot do

798
00:28:18,190 --> 00:28:20,169
because it doesn't doesn't know about

799
00:28:20,169 --> 00:28:22,389
what's in the data it just sees a bunch

800
00:28:22,389 --> 00:28:26,559
of region writes all right the next

801
00:28:26,559 --> 00:28:28,089
optimization we can do is called scan

802
00:28:28,089 --> 00:28:31,989
sharing so the idea here is that we can

803
00:28:31,989 --> 00:28:34,569
have queries piggyback off each other

804
00:28:34,569 --> 00:28:38,750
and reuse the data that there that one

805
00:28:38,750 --> 00:28:40,730
query is reading from disk and use that

806
00:28:40,730 --> 00:28:43,220
for its query so this is different than

807
00:28:43,220 --> 00:28:45,679
result caching result caching is say I

808
00:28:45,679 --> 00:28:48,140
run exactly the same query and I compute

809
00:28:48,140 --> 00:28:49,940
some answer and I cache that results of

810
00:28:49,940 --> 00:28:51,740
that same query shows up again I can

811
00:28:51,740 --> 00:28:53,419
just rather rerunning the query I just

812
00:28:53,419 --> 00:28:55,610
give you the answer I had before this is

813
00:28:55,610 --> 00:28:57,230
at a lower level at the puffle manager

814
00:28:57,230 --> 00:28:59,240
in the storage layer where we're now and

815
00:28:59,240 --> 00:29:02,000
just have this cursor accessing pages we

816
00:29:02,000 --> 00:29:03,950
can then reuse the pages we're getting

817
00:29:03,950 --> 00:29:05,799
out from one thread for another thread

818
00:29:05,799 --> 00:29:08,600
so way it's gonna work is that when

819
00:29:08,600 --> 00:29:10,039
allow multiple queries to attach to a

820
00:29:10,039 --> 00:29:11,720
single cursor that's scanning through

821
00:29:11,720 --> 00:29:13,159
our pages and putting them to the buffer

822
00:29:13,159 --> 00:29:14,960
pool it's almost like a pub sub thing

823
00:29:14,960 --> 00:29:17,210
where we say I want to know whether you

824
00:29:17,210 --> 00:29:18,530
get a new page and then you can notify

825
00:29:18,530 --> 00:29:19,940
whatever thread that may be waiting for

826
00:29:19,940 --> 00:29:21,110
it even though they're not the one that

827
00:29:21,110 --> 00:29:23,900
actually did the read so depending on

828
00:29:23,900 --> 00:29:25,400
the implementation the queries do not

829
00:29:25,400 --> 00:29:26,740
need to be exactly the same

830
00:29:26,740 --> 00:29:29,330
typically in result caching they do in

831
00:29:29,330 --> 00:29:31,400
our and our world here they don't have

832
00:29:31,400 --> 00:29:32,630
to be just I need to know whether I'm

833
00:29:32,630 --> 00:29:35,179
reading the same pages and then in some

834
00:29:35,179 --> 00:29:37,840
cases to also if they're computing the

835
00:29:37,840 --> 00:29:41,000
similar result we could share those

836
00:29:41,000 --> 00:29:42,740
immediate results and across different

837
00:29:42,740 --> 00:29:45,830
threads so most like a it's called a

838
00:29:45,830 --> 00:29:47,360
materialized view we'll cover this later

839
00:29:47,360 --> 00:29:48,860
in the semester but for our purposes

840
00:29:48,860 --> 00:29:49,850
here with this game we're just looking

841
00:29:49,850 --> 00:29:53,630
at page accesses so again the way it

842
00:29:53,630 --> 00:29:55,370
works is that if a query starts a stand

843
00:29:55,370 --> 00:29:58,280
and then it recognizes that there's

844
00:29:58,280 --> 00:30:01,010
another query also doing the same scan

845
00:30:01,010 --> 00:30:03,650
it just attaches itself to the first

846
00:30:03,650 --> 00:30:07,280
guy's cursor and then as it gets pages

847
00:30:07,280 --> 00:30:09,320
we get notified that that page came in

848
00:30:09,320 --> 00:30:12,320
and we can we can access it as well so

849
00:30:12,320 --> 00:30:13,940
the important thing to know is that we

850
00:30:13,940 --> 00:30:15,500
have to keep track of where the second

851
00:30:15,500 --> 00:30:17,150
query came along sort of got on the

852
00:30:17,150 --> 00:30:19,730
train for the cursor so that we know if

853
00:30:19,730 --> 00:30:21,080
the cursor ends for the first query

854
00:30:21,080 --> 00:30:22,880
there may be other data we have to go

855
00:30:22,880 --> 00:30:25,970
back and read I said we can if we want

856
00:30:25,970 --> 00:30:27,350
to look at everything we start halfway

857
00:30:27,350 --> 00:30:29,059
we want to know where we started so we

858
00:30:29,059 --> 00:30:31,970
can come back and see the rest so as far

859
00:30:31,970 --> 00:30:34,100
as I know this technique is fully

860
00:30:34,100 --> 00:30:36,590
supported only in db2 and sequel server

861
00:30:36,590 --> 00:30:38,990
it's super hard to get correct it seems

862
00:30:38,990 --> 00:30:40,580
like kind of trivial but it can get

863
00:30:40,580 --> 00:30:42,380
pretty gnarly based on what the the

864
00:30:42,380 --> 00:30:45,110
queries doing Oracle supports has a

865
00:30:45,110 --> 00:30:48,470
basic scare chaning they call cursor

866
00:30:48,470 --> 00:30:50,600
sharing and then but it only works if

867
00:30:50,600 --> 00:30:52,370
you have two exact queries running

868
00:30:52,370 --> 00:30:55,010
exact same time whereas these guys can

869
00:30:55,010 --> 00:30:56,270
extrapolate based on the query that you

870
00:30:56,270 --> 00:30:57,530
know I need I know you're reading this

871
00:30:57,530 --> 00:30:59,570
table I need to read the same thing and

872
00:30:59,570 --> 00:31:01,220
jump on it this thing has to say I have

873
00:31:01,220 --> 00:31:02,360
two queries I'm doing the exact same

874
00:31:02,360 --> 00:31:06,110
thing so let's look an example so say we

875
00:31:06,110 --> 00:31:07,730
have our first query here it's computing

876
00:31:07,730 --> 00:31:10,850
the sum on a so the query the queries

877
00:31:10,850 --> 00:31:12,559
cursors are going to start and it's just

878
00:31:12,559 --> 00:31:15,559
gonna start scanning through the table

879
00:31:15,559 --> 00:31:18,770
looking at each page all right so now

880
00:31:18,770 --> 00:31:20,570
let's say at this point here it wants to

881
00:31:20,570 --> 00:31:23,390
read page three we don't have any a free

882
00:31:23,390 --> 00:31:25,460
frame and our buffer pool so we run our

883
00:31:25,460 --> 00:31:27,380
replacement policy algorithm to decide

884
00:31:27,380 --> 00:31:28,970
which of these pages we want to remove

885
00:31:28,970 --> 00:31:30,559
in this case here we'll do something

886
00:31:30,559 --> 00:31:32,960
simple and say well page zero was the

887
00:31:32,960 --> 00:31:35,809
last page that the the page that was the

888
00:31:35,809 --> 00:31:37,760
oldest since I've accessed it so let me

889
00:31:37,760 --> 00:31:39,290
go ahead and replace that with page

890
00:31:39,290 --> 00:31:42,280
three and then now I continue scanning

891
00:31:42,280 --> 00:31:45,050
but now let's say after this happens

892
00:31:45,050 --> 00:31:47,020
after we swap out page zero at page 3 a

893
00:31:47,020 --> 00:31:50,240
second query shows up that also wants to

894
00:31:50,240 --> 00:31:52,970
do a central scan on this table

895
00:31:52,970 --> 00:31:56,480
so without scan sharing it'll just start

896
00:31:56,480 --> 00:31:58,010
at the beginning like the first guy and

897
00:31:58,010 --> 00:32:00,530
just skin all the way down but this is

898
00:32:00,530 --> 00:32:01,790
actually the worst thing for us because

899
00:32:01,790 --> 00:32:03,860
the first thing is going to read is page

900
00:32:03,860 --> 00:32:06,080
zero but we just threw that out on disk

901
00:32:06,080 --> 00:32:08,450
so now we can end up thrashing because

902
00:32:08,450 --> 00:32:09,950
this guy can't proceed until page zeros

903
00:32:09,950 --> 00:32:12,050
is in so this is gonna you know it has

904
00:32:12,050 --> 00:32:13,760
to stolen to go fetch it back in but I I

905
00:32:13,760 --> 00:32:15,470
just had it in memory but I got rid of

906
00:32:15,470 --> 00:32:19,100
it so that's bad so with scan sharing

907
00:32:19,100 --> 00:32:20,630
this guy just hops along for the ride

908
00:32:20,630 --> 00:32:23,570
and read the same thing that q1 reads

909
00:32:23,570 --> 00:32:26,450
and you know produces you compute

910
00:32:26,450 --> 00:32:27,710
whatever enemy resulting needs for that

911
00:32:27,710 --> 00:32:28,760
part of the part of the data is looking

912
00:32:28,760 --> 00:32:32,360
at so now at this point q1 is done so

913
00:32:32,360 --> 00:32:35,059
it's cursor goes away and then q2 starts

914
00:32:35,059 --> 00:32:36,559
over at the beginning and those nodes

915
00:32:36,559 --> 00:32:38,059
that I started when you were reading

916
00:32:38,059 --> 00:32:40,790
page three so this is how long I need to

917
00:32:40,790 --> 00:32:43,780
scan down until I get my final result

918
00:32:43,780 --> 00:32:46,780
yes

919
00:32:56,330 --> 00:33:02,730
this question is each query is computing

920
00:33:02,730 --> 00:33:05,760
also intermediate results as as it reads

921
00:33:05,760 --> 00:33:08,400
this datum so they also now need a

922
00:33:08,400 --> 00:33:11,460
memory region to to put this data in

923
00:33:11,460 --> 00:33:13,370
that's separate from this buffer pool

924
00:33:13,370 --> 00:33:15,750
yes so we'll see this an exam on

925
00:33:15,750 --> 00:33:20,010
Postgres in a second but the typically

926
00:33:20,010 --> 00:33:21,659
that memory will also be backed by a

927
00:33:21,659 --> 00:33:25,650
buffer pool right and because like if I

928
00:33:25,650 --> 00:33:27,419
end up computing something you know say

929
00:33:27,419 --> 00:33:29,429
I'm computing a join and the output of

930
00:33:29,429 --> 00:33:31,919
that joint operator doesn't fit in

931
00:33:31,919 --> 00:33:32,460
memory

932
00:33:32,460 --> 00:33:34,890
I need B it started victim those pages

933
00:33:34,890 --> 00:33:37,740
out to disk so so any ephemeral memory

934
00:33:37,740 --> 00:33:38,909
like that would still be backed by a

935
00:33:38,909 --> 00:33:40,650
buffer pool but whether it's in the

936
00:33:40,650 --> 00:33:41,970
global buffer pool whether it's a

937
00:33:41,970 --> 00:33:43,799
private one for the query it depends on

938
00:33:43,799 --> 00:33:50,250
the implementation his question same it

939
00:33:50,250 --> 00:33:51,780
is I don't need I don't need to bring

940
00:33:51,780 --> 00:33:53,880
pages from disk in for that query in

941
00:33:53,880 --> 00:34:00,450
Amira's all buffer pool yeah yeah so as

942
00:34:00,450 --> 00:34:02,640
I'm writing data like so this guy and

943
00:34:02,640 --> 00:34:03,840
this is trivial table because the

944
00:34:03,840 --> 00:34:06,059
average is it's a scaler right let's say

945
00:34:06,059 --> 00:34:07,609
this is you know some really complex

946
00:34:07,609 --> 00:34:10,379
computation as I'm generating as I'm

947
00:34:10,379 --> 00:34:12,210
scanning this data I'm updating my enemy

948
00:34:12,210 --> 00:34:15,210
result I may overflow memory and those

949
00:34:15,210 --> 00:34:16,800
gets swapped out the disk so I'm writing

950
00:34:16,800 --> 00:34:18,060
to memory and then they would just get

951
00:34:18,060 --> 00:34:20,129
to get written out the disk as needed

952
00:34:20,129 --> 00:34:22,830
but it's not like I would read for my

953
00:34:22,830 --> 00:34:25,918
query yeah it doesn't make sense because

954
00:34:25,918 --> 00:34:27,300
anything you need free from like the

955
00:34:27,300 --> 00:34:29,250
low-level data is pages you're gonna put

956
00:34:29,250 --> 00:34:30,690
in the buffer pool that everyone can see

957
00:34:30,690 --> 00:34:32,280
all right so again this is another good

958
00:34:32,280 --> 00:34:33,830
point this is a shared data structure

959
00:34:33,830 --> 00:34:39,030
right so it did like q1 is was reading

960
00:34:39,030 --> 00:34:41,520
pages and putting to the buffer pool any

961
00:34:41,520 --> 00:34:43,409
other thread that need these pages is

962
00:34:43,409 --> 00:34:45,440
allowed to go go ahead and read it

963
00:34:45,440 --> 00:34:48,060
alright the pin latch the pin that just

964
00:34:48,060 --> 00:34:49,469
tells you that hey don't swap this out

965
00:34:49,469 --> 00:34:51,989
the disk the doesn't doesn't prevent

966
00:34:51,989 --> 00:34:52,889
anybody else aren't reading at the same

967
00:34:52,889 --> 00:34:55,230
time you are there's higher level things

968
00:34:55,230 --> 00:34:57,089
like the locks that keep track of what

969
00:34:57,089 --> 00:34:58,410
pages you're allowed to read and write

970
00:34:58,410 --> 00:34:59,820
from or what would you know with

971
00:34:59,820 --> 00:35:01,710
database objects this is the painted

972
00:35:01,710 --> 00:35:03,690
spacing says hey I'm operating on this

973
00:35:03,690 --> 00:35:06,150
don't swap it out so that didn't your

974
00:35:06,150 --> 00:35:07,500
question

975
00:35:07,500 --> 00:35:10,830
okay so there's another good example

976
00:35:10,830 --> 00:35:12,330
what's awesome about the relational

977
00:35:12,330 --> 00:35:14,400
model because the relational model is

978
00:35:14,400 --> 00:35:18,840
unordered meaning like it doesn't like I

979
00:35:18,840 --> 00:35:21,390
can actually have Q to start anywhere

980
00:35:21,390 --> 00:35:24,720
for some queries and the answer I'm

981
00:35:24,720 --> 00:35:26,849
gonna produce may be different from

982
00:35:26,849 --> 00:35:29,190
based on when I execute it but it still

983
00:35:29,190 --> 00:35:32,310
considered correct so if I changed this

984
00:35:32,310 --> 00:35:34,710
query to put compute the average and I

985
00:35:34,710 --> 00:35:36,780
limit it to a hundred meaning I only

986
00:35:36,780 --> 00:35:38,450
want me to be the average of 100 tuples

987
00:35:38,450 --> 00:35:41,310
it doesn't specify that I can only I

988
00:35:41,310 --> 00:35:42,390
have to look at the first one hundred

989
00:35:42,390 --> 00:35:45,480
tuples so I could start here at page

990
00:35:45,480 --> 00:35:48,060
three with my with my scan sharing on

991
00:35:48,060 --> 00:35:49,740
this cursor and see the first hundred

992
00:35:49,740 --> 00:35:51,119
tuples in these first three pages and

993
00:35:51,119 --> 00:35:52,980
then that's that's enough for me to

994
00:35:52,980 --> 00:35:56,190
compute the result if I started now at

995
00:35:56,190 --> 00:35:57,240
the beginning I may actually get a

996
00:35:57,240 --> 00:35:58,560
different result but according to the

997
00:35:58,560 --> 00:36:02,490
relational model that's still fine cuz

998
00:36:02,490 --> 00:36:10,349
the database is unordered yes yes so he

999
00:36:10,349 --> 00:36:12,240
perfect so he says would it also still

1000
00:36:12,240 --> 00:36:14,369
be valid if we rather than having the

1001
00:36:14,369 --> 00:36:15,619
cursor say all right well let's go look

1002
00:36:15,619 --> 00:36:17,910
my dispatch is start fetching them what

1003
00:36:17,910 --> 00:36:19,050
do I go check out the buffer pool and

1004
00:36:19,050 --> 00:36:20,339
figure out what's actually a memory and

1005
00:36:20,339 --> 00:36:22,080
compute the aggregation or this

1006
00:36:22,080 --> 00:36:23,790
particular query which with what's a

1007
00:36:23,790 --> 00:36:26,490
memory absolutely yes and the smartest

1008
00:36:26,490 --> 00:36:31,440
systems can do that okay it doesn't

1009
00:36:31,440 --> 00:36:31,770
matter

1010
00:36:31,770 --> 00:36:34,380
writes in memory as long as I see a

1011
00:36:34,380 --> 00:36:35,910
hundred tuples then that this query is

1012
00:36:35,910 --> 00:36:39,030
still correct now this is I don't know

1013
00:36:39,030 --> 00:36:41,990
like you wouldn't want to write this but

1014
00:36:41,990 --> 00:36:48,089
it's yeah it's still valid all right the

1015
00:36:48,089 --> 00:36:49,349
last optimization we'll talk about is

1016
00:36:49,349 --> 00:36:52,950
the buffer pool bypass so this sort of

1017
00:36:52,950 --> 00:36:54,359
related his question before about like

1018
00:36:54,359 --> 00:36:57,780
the intermediate result memory but let's

1019
00:36:57,780 --> 00:36:59,609
say that I have some queries where we're

1020
00:36:59,609 --> 00:37:03,570
doing structural scans and the I don't

1021
00:37:03,570 --> 00:37:04,980
want to pay the penalty of having to go

1022
00:37:04,980 --> 00:37:07,440
look up in the page table and look at my

1023
00:37:07,440 --> 00:37:10,020
buffer pool to go figure out whether the

1024
00:37:10,020 --> 00:37:11,099
page I'm looking for is in memory

1025
00:37:11,099 --> 00:37:12,690
furthermore I also don't want to pollute

1026
00:37:12,690 --> 00:37:14,369
the cache and it may be reading some

1027
00:37:14,369 --> 00:37:16,260
data that I'm not going to need in the

1028
00:37:16,260 --> 00:37:20,970
near future so the the buffer pool

1029
00:37:20,970 --> 00:37:21,720
bypass

1030
00:37:21,720 --> 00:37:23,640
cash bypass depending what system it is

1031
00:37:23,640 --> 00:37:26,280
the idea is that you allocate a small

1032
00:37:26,280 --> 00:37:29,280
amount of memory to the to your your

1033
00:37:29,280 --> 00:37:32,130
query a thread running it and then as it

1034
00:37:32,130 --> 00:37:34,380
reads pages from disk right if it's not

1035
00:37:34,380 --> 00:37:35,520
in the buffer pool it has to go to DISA

1036
00:37:35,520 --> 00:37:37,260
to get it rather than putting it in the

1037
00:37:37,260 --> 00:37:39,180
buffer pool it just puts it in its local

1038
00:37:39,180 --> 00:37:40,440
memory and then when the queries done

1039
00:37:40,440 --> 00:37:42,300
all that just gets dropped and thrown

1040
00:37:42,300 --> 00:37:45,750
away all right and you do this again

1041
00:37:45,750 --> 00:37:46,800
because you want to avoid the overhead

1042
00:37:46,800 --> 00:37:48,180
of going to the patient we'll just yeah

1043
00:37:48,180 --> 00:37:49,740
it's a hash table it has latches it's

1044
00:37:49,740 --> 00:37:51,510
not it's not it's not super expensive

1045
00:37:51,510 --> 00:37:54,960
but it's not free it's not cheap so in

1046
00:37:54,960 --> 00:37:56,730
for max these are called light scans but

1047
00:37:56,730 --> 00:37:58,109
pretty much every single again major

1048
00:37:58,109 --> 00:38:00,810
database system supports something like

1049
00:38:00,810 --> 00:38:01,920
this I don't know I don't know whether

1050
00:38:01,920 --> 00:38:03,510
my sequel eight does I don't think five

1051
00:38:03,510 --> 00:38:07,440
point seven does and then again if you

1052
00:38:07,440 --> 00:38:08,940
recognize that you know that you only

1053
00:38:08,940 --> 00:38:10,200
really want to do this if you know the

1054
00:38:10,200 --> 00:38:11,700
intimate result or their thing you're

1055
00:38:11,700 --> 00:38:15,390
scanning is not not huge if you're doing

1056
00:38:15,390 --> 00:38:16,470
a sort that's gonna be you know

1057
00:38:16,470 --> 00:38:18,240
terabytes of memory then you want to be

1058
00:38:18,240 --> 00:38:19,410
back by the buffer pool because that

1059
00:38:19,410 --> 00:38:23,000
thing can get paid up to disk as needed

1060
00:38:23,000 --> 00:38:24,990
all right the last thing to sort of

1061
00:38:24,990 --> 00:38:28,500
understand also too is what's actually

1062
00:38:28,500 --> 00:38:30,119
going on below the database system

1063
00:38:30,119 --> 00:38:33,570
what's happening as we read pages from

1064
00:38:33,570 --> 00:38:34,680
the obvious and what is the operation

1065
00:38:34,680 --> 00:38:37,080
actually doing so again all our disk

1066
00:38:37,080 --> 00:38:38,099
operations are gonna be going through

1067
00:38:38,099 --> 00:38:40,740
the OS API at the lowest level the F of

1068
00:38:40,740 --> 00:38:44,609
them every to fright you know we're not

1069
00:38:44,609 --> 00:38:45,930
going to access the roll all discs

1070
00:38:45,930 --> 00:38:47,609
themselves so because we're now going

1071
00:38:47,609 --> 00:38:50,010
through the operating system by default

1072
00:38:50,010 --> 00:38:51,420
the operating system is gonna maintain

1073
00:38:51,420 --> 00:38:53,160
its own separate cache for the file

1074
00:38:53,160 --> 00:38:55,470
system all right this is called the OS

1075
00:38:55,470 --> 00:38:58,500
page cache so that means again as I read

1076
00:38:58,500 --> 00:39:01,320
a page from from disk the OS is gonna

1077
00:39:01,320 --> 00:39:03,180
keep a cap copy of it in his file system

1078
00:39:03,180 --> 00:39:04,859
cache or OS page cache and then I'll

1079
00:39:04,859 --> 00:39:06,570
have another copy of it in my buffer

1080
00:39:06,570 --> 00:39:11,160
pool so most database systems do not

1081
00:39:11,160 --> 00:39:12,839
want to do want you to do this no no the

1082
00:39:12,839 --> 00:39:14,849
operating system to do this so when you

1083
00:39:14,849 --> 00:39:17,010
open a file you pass in the POSIX flag

1084
00:39:17,010 --> 00:39:20,609
Oh direct or direct IO where you have

1085
00:39:20,609 --> 00:39:23,220
the OS not do any of that caching itself

1086
00:39:23,220 --> 00:39:26,190
and you manage what's in memory on your

1087
00:39:26,190 --> 00:39:27,839
own so pretty much every single day

1088
00:39:27,839 --> 00:39:29,280
tourism when you go to read the manual

1089
00:39:29,280 --> 00:39:31,230
they would tell you that make sure you

1090
00:39:31,230 --> 00:39:34,440
can actually turn this on the only

1091
00:39:34,440 --> 00:39:35,550
database system that does

1092
00:39:35,550 --> 00:39:38,850
is its Postgres as far as you know the

1093
00:39:38,850 --> 00:39:40,230
only major data send that relies on the

1094
00:39:40,230 --> 00:39:43,650
others page cache is Postgres and so the

1095
00:39:43,650 --> 00:39:45,380
reason they said they do this because

1096
00:39:45,380 --> 00:39:48,480
they claim that from engineering

1097
00:39:48,480 --> 00:39:50,670
standpoint it's one less additional

1098
00:39:50,670 --> 00:39:53,250
catchment thing they have to manage they

1099
00:39:53,250 --> 00:39:54,480
still has their own buffer pool but it's

1100
00:39:54,480 --> 00:39:55,950
not gonna be as big it's not gonna use

1101
00:39:55,950 --> 00:39:57,990
all the memory on the system like my

1102
00:39:57,990 --> 00:40:01,710
sequel or Oracle would use but let the

1103
00:40:01,710 --> 00:40:02,730
OSD with some additional management

1104
00:40:02,730 --> 00:40:04,260
themselves so from an engineering

1105
00:40:04,260 --> 00:40:06,030
perspective it's less overhead on their

1106
00:40:06,030 --> 00:40:07,650
part from actually maintaining that that

1107
00:40:07,650 --> 00:40:09,780
piece of the system and it's a minor

1108
00:40:09,780 --> 00:40:11,670
performance penalty to rely on this

1109
00:40:11,670 --> 00:40:14,960
which we'll see in a second okay so I

1110
00:40:14,960 --> 00:40:19,170
like using Postgres for demos because

1111
00:40:19,170 --> 00:40:20,910
it's almost like a textbook imitation of

1112
00:40:20,910 --> 00:40:22,920
a database system and you actually

1113
00:40:22,920 --> 00:40:27,360
exposes a lot of the important concepts

1114
00:40:27,360 --> 00:40:28,410
that we're talking about pretty pretty

1115
00:40:28,410 --> 00:40:33,210
easily okay all right so this is running

1116
00:40:33,210 --> 00:40:37,110
again a machine back in the lab let me

1117
00:40:37,110 --> 00:40:45,930
turn on the lights and I type in those

1118
00:40:45,930 --> 00:40:47,940
laptop cuz it's a pain to type on the on

1119
00:40:47,940 --> 00:40:54,440
the surface I hate the keyboard alright

1120
00:40:54,710 --> 00:40:56,670
so this is running this is just running

1121
00:40:56,670 --> 00:40:58,280
H top it's a better version of top and

1122
00:40:58,280 --> 00:41:00,870
the thing I want to I want to focus on

1123
00:41:00,870 --> 00:41:05,070
is is the memory you should stuff up

1124
00:41:05,070 --> 00:41:07,920
here so the green bars are telling you

1125
00:41:07,920 --> 00:41:09,480
what's the resident set size of the

1126
00:41:09,480 --> 00:41:11,670
processes running on this machine right

1127
00:41:11,670 --> 00:41:14,580
it's the memory they've now looked the

1128
00:41:14,580 --> 00:41:16,620
the orange bar here

1129
00:41:16,620 --> 00:41:20,610
that's the filesystem page cache that's

1130
00:41:20,610 --> 00:41:21,780
the operative systems page cache so

1131
00:41:21,780 --> 00:41:23,220
again as whatever processes are running

1132
00:41:23,220 --> 00:41:26,760
on this machine as they go read if

1133
00:41:26,760 --> 00:41:28,560
they're not using direct i/o if they go

1134
00:41:28,560 --> 00:41:33,750
read a page from a file the OS is also

1135
00:41:33,750 --> 00:41:37,050
going to cache it as well so we can blow

1136
00:41:37,050 --> 00:41:39,360
this all away so this is running on

1137
00:41:39,360 --> 00:41:41,510
Linux so in Linux we can do a

1138
00:41:41,510 --> 00:41:44,569
[Music]

1139
00:41:45,309 --> 00:41:53,029
that's not Oh for sorry so we can run

1140
00:41:53,029 --> 00:41:59,059
this command that we basically passive

1141
00:41:59,059 --> 00:42:02,119
we we stink the OS the FASTA some cache

1142
00:42:02,119 --> 00:42:04,490
and we passed this flag three into the

1143
00:42:04,490 --> 00:42:07,009
proc file system to allow us to force

1144
00:42:07,009 --> 00:42:11,089
the opposite to flush our page cache so

1145
00:42:11,089 --> 00:42:13,609
now if we go back and look at H top now

1146
00:42:13,609 --> 00:42:15,950
we see that the total amount of memory

1147
00:42:15,950 --> 00:42:17,240
beat buying used but the machine went

1148
00:42:17,240 --> 00:42:19,730
down to three gigs right so had 32 gigs

1149
00:42:19,730 --> 00:42:21,470
before but now it's down to three gigs

1150
00:42:21,470 --> 00:42:23,210
so we blew away the file system cache

1151
00:42:23,210 --> 00:42:28,519
entirely ok so now let's go let's go

1152
00:42:28,519 --> 00:42:31,849
bring up Postgres the first thing i want

1153
00:42:31,849 --> 00:42:35,750
to do though is restart it and so by

1154
00:42:35,750 --> 00:42:36,829
restarting it we're going to blow away

1155
00:42:36,829 --> 00:42:45,980
it's it's its buffer pool all right so

1156
00:42:45,980 --> 00:42:48,890
now bring this up and then reconnect

1157
00:42:48,890 --> 00:42:51,859
we're ternal and timing and then we'll

1158
00:42:51,859 --> 00:42:56,150
turn off the parallel threads so we're

1159
00:42:56,150 --> 00:42:58,549
going to use that same table I showed

1160
00:42:58,549 --> 00:43:01,250
them last class ten million entries of a

1161
00:43:01,250 --> 00:43:04,640
bunch of decimals so we can run this

1162
00:43:04,640 --> 00:43:07,279
query and now what I'm gonna do is I'm

1163
00:43:07,279 --> 00:43:09,349
gonna use explain again but I'm gonna

1164
00:43:09,349 --> 00:43:11,480
pass and analyze two flags analyze and

1165
00:43:11,480 --> 00:43:13,910
buffers so analyze again is gonna

1166
00:43:13,910 --> 00:43:15,230
actually run the query and also show you

1167
00:43:15,230 --> 00:43:16,700
the query plan what happened this

1168
00:43:16,700 --> 00:43:19,009
buffers flag is going to tell you how

1169
00:43:19,009 --> 00:43:21,289
much data it read from disk what

1170
00:43:21,289 --> 00:43:23,210
percentage of the pages it was reading

1171
00:43:23,210 --> 00:43:25,369
rating the buffer pool verses on on disk

1172
00:43:25,369 --> 00:43:27,319
and so because we blew away the file

1173
00:43:27,319 --> 00:43:29,150
system cache we blew away the buffer

1174
00:43:29,150 --> 00:43:30,230
pool because we restarted the database

1175
00:43:30,230 --> 00:43:33,410
system it should the hit should be zero

1176
00:43:33,410 --> 00:43:36,859
right and you see that it said that for

1177
00:43:36,859 --> 00:43:38,450
the buffer pool it had to read four

1178
00:43:38,450 --> 00:43:40,759
hundred four four four four to forty

1179
00:43:40,759 --> 00:43:44,599
eight pages it had to read the table

1180
00:43:44,599 --> 00:43:47,420
from disk and it took thirteen hundred

1181
00:43:47,420 --> 00:43:49,700
milliseconds one point three seconds so

1182
00:43:49,700 --> 00:43:52,410
if I run the same query again

1183
00:43:52,410 --> 00:43:55,380
now you see it says that the hit was 32

1184
00:43:55,380 --> 00:43:59,430
so it was able to read 32 pages that

1185
00:43:59,430 --> 00:44:02,009
were already in the puffer pool and then

1186
00:44:02,009 --> 00:44:03,619
the rest it had been reaping disk

1187
00:44:03,619 --> 00:44:05,789
alright the reason why I wasn't all the

1188
00:44:05,789 --> 00:44:09,180
pages is because Postgres maintains a

1189
00:44:09,180 --> 00:44:11,549
buffer pool sort of a small buffer pool

1190
00:44:11,549 --> 00:44:15,779
ring per query that's 32 pages so for

1191
00:44:15,779 --> 00:44:17,220
this one it was allowed to read 30 pages

1192
00:44:17,220 --> 00:44:18,660
from the last time it ran I run this

1193
00:44:18,660 --> 00:44:22,710
again it should go to thank the 64 yes

1194
00:44:22,710 --> 00:44:24,329
so it keeps growing in size as I'm

1195
00:44:24,329 --> 00:44:25,589
executing queries over never again

1196
00:44:25,589 --> 00:44:28,019
because it recognizes that oh the data

1197
00:44:28,019 --> 00:44:30,960
that I need is is it's not my buffer

1198
00:44:30,960 --> 00:44:33,329
pool let me increase the size of its

1199
00:44:33,329 --> 00:44:36,799
cache alright so now what we can do is

1200
00:44:36,799 --> 00:44:40,740
we can force the database system to put

1201
00:44:40,740 --> 00:44:44,190
everything in into into memory so they

1202
00:44:44,190 --> 00:44:46,049
have this extension of Postgres comes by

1203
00:44:46,049 --> 00:44:47,730
default when you when you install it

1204
00:44:47,730 --> 00:44:50,640
called PG warm and all this does is that

1205
00:44:50,640 --> 00:44:52,740
it's a function that we invoke on the

1206
00:44:52,740 --> 00:44:55,259
data system to say hey go take all the

1207
00:44:55,259 --> 00:44:57,930
pages for this this table and bring it

1208
00:44:57,930 --> 00:45:00,930
to a buffer pool right and tells you

1209
00:45:00,930 --> 00:45:02,940
that I ran I did that and I read four

1210
00:45:02,940 --> 00:45:05,190
hundred forty four thousand two forty

1211
00:45:05,190 --> 00:45:05,849
eight pages

1212
00:45:05,849 --> 00:45:07,650
remember when I ran the query the first

1213
00:45:07,650 --> 00:45:10,349
time the it said had to read four

1214
00:45:10,349 --> 00:45:11,789
thousand four hundred twenty eight pages

1215
00:45:11,789 --> 00:45:13,710
from disk because it's getting exactly

1216
00:45:13,710 --> 00:45:15,390
you know that's the the number pages of

1217
00:45:15,390 --> 00:45:17,480
this table

1218
00:45:17,480 --> 00:45:19,380
he says there's six more pages already

1219
00:45:19,380 --> 00:45:21,089
there right so this is like forcing just

1220
00:45:21,089 --> 00:45:23,250
read everything and I think those 64

1221
00:45:23,250 --> 00:45:27,900
pages might have been yeah I think it

1222
00:45:27,900 --> 00:45:29,609
doesn't look to see what's in memory it

1223
00:45:29,609 --> 00:45:31,440
just says I'm gonna get everything cuz i

1224
00:45:31,440 --> 00:45:32,579
if I do it again it should give me the

1225
00:45:32,579 --> 00:45:35,119
same number yeah just reads everything

1226
00:45:35,119 --> 00:45:39,690
alright so now if I go and run that

1227
00:45:39,690 --> 00:45:45,690
query again I'm doing a little bit

1228
00:45:45,690 --> 00:45:49,559
better by hit a sixteen sixteen thousand

1229
00:45:49,559 --> 00:45:52,049
sixteen thousand pages I needed were in

1230
00:45:52,049 --> 00:45:54,660
memory so I hit hit had it hit in the

1231
00:45:54,660 --> 00:45:56,190
buffer pool but I started read a bunch

1232
00:45:56,190 --> 00:46:01,430
some disk and we take a guess why

1233
00:46:01,910 --> 00:46:07,140
yes he's wide still loading everything

1234
00:46:07,140 --> 00:46:13,140
into the buffer pool depends on the size

1235
00:46:13,140 --> 00:46:15,330
of the buffer pool right so we can do

1236
00:46:15,330 --> 00:46:16,950
this in Postgres so Postgres has a flag

1237
00:46:16,950 --> 00:46:22,890
called shared buffers and it tells me

1238
00:46:22,890 --> 00:46:24,660
that it's currently set to 128 megabytes

1239
00:46:24,660 --> 00:46:29,670
right but the size was about 4 for 4 to

1240
00:46:29,670 --> 00:46:33,030
8 so select you can use gimme you i'll

1241
00:46:33,030 --> 00:46:34,530
updated you can use them as a calculator

1242
00:46:34,530 --> 00:46:47,300
so for 4 to 8 times 8 divided by 1024

1243
00:46:47,300 --> 00:46:51,110
about giving megabytes so the size of my

1244
00:46:51,110 --> 00:46:54,840
table I'm reading is 345 megabytes so

1245
00:46:54,840 --> 00:46:58,020
again the shared buffer is 128 but my

1246
00:46:58,020 --> 00:47:02,340
size my table is 345 so I can go to the

1247
00:47:02,340 --> 00:47:08,270
post rest configuration in theory for

1248
00:47:09,020 --> 00:47:13,940
this is post Chris 11 and then go find

1249
00:47:13,940 --> 00:47:18,230
that particular parameter and lo behold

1250
00:47:18,230 --> 00:47:23,630
it's 128 megabytes so let me set it to

1251
00:47:23,630 --> 00:47:27,320
let's be generous let's say 360

1252
00:47:27,320 --> 00:47:30,600
megabytes right so now we will restart

1253
00:47:30,600 --> 00:47:36,150
Postgres we will blow a our file system

1254
00:47:36,150 --> 00:47:37,530
cache from the operating system because

1255
00:47:37,530 --> 00:47:39,540
again as we read that page in actually

1256
00:47:39,540 --> 00:47:43,380
we go back to H stop it got I mean it's

1257
00:47:43,380 --> 00:47:44,550
hard to see we've got a little bit

1258
00:47:44,550 --> 00:47:46,800
bigger hmm like if you see there's one

1259
00:47:46,800 --> 00:47:48,750
bar there because that's that that's

1260
00:47:48,750 --> 00:47:51,750
that's our table we were reading in so

1261
00:47:51,750 --> 00:47:53,790
let me go blow away the file system

1262
00:47:53,790 --> 00:47:58,380
cache and now go back to post grass I

1263
00:47:58,380 --> 00:48:04,800
need to reconnect turn on timing set

1264
00:48:04,800 --> 00:48:06,990
that to this to turn up parallel threads

1265
00:48:06,990 --> 00:48:11,570
check to see that shared buffers is now

1266
00:48:12,060 --> 00:48:16,430
oh I'm an idiot right sorry

1267
00:48:16,430 --> 00:48:20,850
server 10 Klein 11 too many co-stars

1268
00:48:20,850 --> 00:48:23,730
installation sorry so go back here is

1269
00:48:23,730 --> 00:48:36,230
this put about the 1:28 I said about 360

1270
00:48:37,790 --> 00:48:44,570
now we start Postgres go back here

1271
00:48:44,570 --> 00:48:48,000
reconnect 360 okay good

1272
00:48:48,000 --> 00:48:52,910
turn on timing turn on parallel threads

1273
00:48:52,910 --> 00:48:57,840
pre-warm we got it four four two eight

1274
00:48:57,840 --> 00:49:00,000
four two four eight pages and now I've

1275
00:49:00,000 --> 00:49:05,880
run that query again and now my head is

1276
00:49:05,880 --> 00:49:08,880
four four to forty so I gave it a system

1277
00:49:08,880 --> 00:49:11,010
the right amount of memory I prefetch

1278
00:49:11,010 --> 00:49:12,450
and everything and now everything is

1279
00:49:12,450 --> 00:49:14,250
hitting the buffer pool I had I didn't

1280
00:49:14,250 --> 00:49:15,270
that such a disk at all for this

1281
00:49:15,270 --> 00:49:17,310
particular query I do every lookup every

1282
00:49:17,310 --> 00:49:19,020
page and I need to access I'm going

1283
00:49:19,020 --> 00:49:20,340
looking in that but in that page table

1284
00:49:20,340 --> 00:49:22,140
and finding the pate the page reference

1285
00:49:22,140 --> 00:49:24,210
in a frame but everything is in memory

1286
00:49:24,210 --> 00:49:29,100
here so how can we prove that the that

1287
00:49:29,100 --> 00:49:30,510
the database system Postgres is using

1288
00:49:30,510 --> 00:49:32,670
relying on the file system cache so

1289
00:49:32,670 --> 00:49:34,320
let's turn off just explain everything

1290
00:49:34,320 --> 00:49:36,180
here and let's see how long it actually

1291
00:49:36,180 --> 00:49:38,730
takes right it's actually so the first

1292
00:49:38,730 --> 00:49:43,110
time was twelve fifty and they got a

1293
00:49:43,110 --> 00:49:48,240
little faster then it's 7:33 alright so

1294
00:49:48,240 --> 00:49:49,260
it takes me roughly seven hundred

1295
00:49:49,260 --> 00:49:53,390
milliseconds so what we can do is go

1296
00:49:53,390 --> 00:49:56,640
restart Postgres

1297
00:49:56,640 --> 00:49:58,510
[Music]

1298
00:49:58,510 --> 00:50:02,500
and then that blows away the buffer pool

1299
00:50:02,500 --> 00:50:07,520
and now if I come back and reconnect the

1300
00:50:07,520 --> 00:50:11,510
Postgres which I think I need to yep so

1301
00:50:11,510 --> 00:50:14,900
now I'm now I'm reconnected I slept a

1302
00:50:14,900 --> 00:50:15,890
good turn on timing

1303
00:50:15,890 --> 00:50:20,150
turn off parallel threads I run that

1304
00:50:20,150 --> 00:50:22,760
same query before when everything was

1305
00:50:22,760 --> 00:50:24,920
out on disk I think it took one point

1306
00:50:24,920 --> 00:50:27,590
three seconds so this one and then with

1307
00:50:27,590 --> 00:50:29,119
everything's in the buffer pool it took

1308
00:50:29,119 --> 00:50:30,920
seven hundred milliseconds so this one

1309
00:50:30,920 --> 00:50:34,100
should be roughly little bits where

1310
00:50:34,100 --> 00:50:35,810
timing was all sorry well that ruined

1311
00:50:35,810 --> 00:50:40,390
the demo so go back I go back this

1312
00:50:40,390 --> 00:50:47,200
restart this go back to this reconnect

1313
00:50:47,200 --> 00:50:51,830
timing is on yeah that's one yeah I got

1314
00:50:51,830 --> 00:50:52,780
it

1315
00:50:52,780 --> 00:50:56,000
parallel threads are off again so I'm

1316
00:50:56,000 --> 00:50:58,070
gonna run this query I blew I restarted

1317
00:50:58,070 --> 00:50:59,780
the database system that blows with the

1318
00:50:59,780 --> 00:51:01,520
buffer pool but the operating system

1319
00:51:01,520 --> 00:51:03,650
still has its file system cache so now

1320
00:51:03,650 --> 00:51:05,390
that I run this query we're gonna have a

1321
00:51:05,390 --> 00:51:09,140
bunch of buffer pool misses because

1322
00:51:09,140 --> 00:51:11,240
nothing is in memory but it's still not

1323
00:51:11,240 --> 00:51:15,650
going to take the full time right took

1324
00:51:15,650 --> 00:51:17,480
800 milliseconds instead instead of 1.3

1325
00:51:17,480 --> 00:51:20,240
seconds because the data that it needed

1326
00:51:20,240 --> 00:51:22,220
was in the file system cache if I run

1327
00:51:22,220 --> 00:51:24,440
this again I should get now 700

1328
00:51:24,440 --> 00:51:27,520
milliseconds no

1329
00:51:28,560 --> 00:51:33,260
there goes let's go figure what happened

1330
00:51:38,480 --> 00:51:44,660
still reading date from disk why is that

1331
00:51:46,220 --> 00:51:51,480
well it's still running fast even though

1332
00:51:51,480 --> 00:51:53,400
that time I think it's because that time

1333
00:51:53,400 --> 00:51:54,390
slower because I think it's running

1334
00:51:54,390 --> 00:51:59,760
explain analyze it'll slowly get faster

1335
00:51:59,760 --> 00:52:01,050
as it creases the cache size for that

1336
00:52:01,050 --> 00:52:03,240
for that query I think I think it's a

1337
00:52:03,240 --> 00:52:04,710
query cache thing rather than the global

1338
00:52:04,710 --> 00:52:05,940
thing but again the main takeaway we

1339
00:52:05,940 --> 00:52:06,900
showed is that we had to give it a

1340
00:52:06,900 --> 00:52:08,550
decent enough memory and put everything

1341
00:52:08,550 --> 00:52:11,040
into our buffer pool and then we were

1342
00:52:11,040 --> 00:52:13,560
able to get the full speed performance

1343
00:52:13,560 --> 00:52:22,980
are starting questions yes pre run twice

1344
00:52:22,980 --> 00:52:27,150
what I mean oh that's the file system

1345
00:52:27,150 --> 00:52:30,330
cache that's about the US cash question

1346
00:52:30,330 --> 00:52:55,620
yes yes yes so the very first time I did

1347
00:52:55,620 --> 00:52:58,500
this the the buffer pool size was 120

1348
00:52:58,500 --> 00:53:01,290
megabytes the table size is 345

1349
00:53:01,290 --> 00:53:07,230
megabytes it didn't that's why I had I

1350
00:53:07,230 --> 00:53:15,480
had to add lookups in read from disk in

1351
00:53:15,480 --> 00:53:19,590
the very beginning huh there's not we

1352
00:53:19,590 --> 00:53:21,780
spending all our time boy this is this

1353
00:53:21,780 --> 00:53:25,680
is walkthrough right so let's do this go

1354
00:53:25,680 --> 00:53:28,650
back we're going to blow away the file

1355
00:53:28,650 --> 00:53:31,440
system cache restart Postgres you know

1356
00:53:31,440 --> 00:53:36,660
now we go look and and in our I mean

1357
00:53:36,660 --> 00:53:37,830
that that bar is not a trivial

1358
00:53:37,830 --> 00:53:41,010
potentially for propose grass like

1359
00:53:41,010 --> 00:53:42,150
there's other things running on the

1360
00:53:42,150 --> 00:53:42,510
system

1361
00:53:42,510 --> 00:53:44,609
but I blew away the false ISM cash I've

1362
00:53:44,609 --> 00:53:45,990
restarted Postgres now there's nothing

1363
00:53:45,990 --> 00:53:47,760
in memory so I go back to the Postgres

1364
00:53:47,760 --> 00:53:50,850
you need to reconnect turn off pale

1365
00:53:50,850 --> 00:53:54,630
threads and so if I run the query now

1366
00:53:54,630 --> 00:54:02,550
the first time great

1367
00:54:02,550 --> 00:54:05,220
nothing's in memory I had to read 44,000

1368
00:54:05,220 --> 00:54:05,670
pages

1369
00:54:05,670 --> 00:54:12,510
okay so that's expected pre-warm tells

1370
00:54:12,510 --> 00:54:13,650
the database system to go read

1371
00:54:13,650 --> 00:54:15,119
everything that's on disk for that table

1372
00:54:15,119 --> 00:54:20,940
brain to my buffer pool all 44 thousand

1373
00:54:20,940 --> 00:54:29,520
pages yes I can do this again right it

1374
00:54:29,520 --> 00:54:31,290
read 44,000 pages now I run the same

1375
00:54:31,290 --> 00:54:36,960
query and now my hit is exactly 44,000

1376
00:54:36,960 --> 00:54:39,420
hit means like it was hit I the thing I

1377
00:54:39,420 --> 00:54:40,680
was looking for was found in the buffer

1378
00:54:40,680 --> 00:54:43,470
pool so I forced the day's doesn't bring

1379
00:54:43,470 --> 00:54:46,350
everything back in the memory and the

1380
00:54:46,350 --> 00:54:48,030
first example I only had a hundred

1381
00:54:48,030 --> 00:54:49,470
twenty megabytes so I couldn't put

1382
00:54:49,470 --> 00:55:07,380
everything on yes yes great so our

1383
00:55:07,380 --> 00:55:09,330
question is so I said in the beginning

1384
00:55:09,330 --> 00:55:11,520
that the Postgres is the only system

1385
00:55:11,520 --> 00:55:13,950
that that does you the only major system

1386
00:55:13,950 --> 00:55:16,619
that relies on the OS page cache why

1387
00:55:16,619 --> 00:55:18,990
doesn't everybody else do this well

1388
00:55:18,990 --> 00:55:21,600
because now I'm gonna have two copies or

1389
00:55:21,600 --> 00:55:24,570
every single page potentially so I could

1390
00:55:24,570 --> 00:55:27,030
have a page in the OS page cache then

1391
00:55:27,030 --> 00:55:28,320
I'm gonna have a copy of that page in my

1392
00:55:28,320 --> 00:55:30,380
my buffer pool because now if I modify

1393
00:55:30,380 --> 00:55:32,940
that page now it's not exact copy

1394
00:55:32,940 --> 00:55:35,490
anymore so the OS has the old one and I

1395
00:55:35,490 --> 00:55:37,619
have the new one so it's it's redundant

1396
00:55:37,619 --> 00:55:39,000
data so you're more efficient in terms

1397
00:55:39,000 --> 00:55:41,040
of memory usage if you manage everything

1398
00:55:41,040 --> 00:55:46,950
yourself furthermore to you know think

1399
00:55:46,950 --> 00:55:49,560
of like in a different database system I

1400
00:55:49,560 --> 00:55:51,869
mean most it isn't support Linux now

1401
00:55:51,869 --> 00:55:53,260
right

1402
00:55:53,260 --> 00:55:55,359
but like the major ones they got to

1403
00:55:55,359 --> 00:55:57,940
support Windows BSD all these different

1404
00:55:57,940 --> 00:55:59,470
operating systems where the OS page

1405
00:55:59,470 --> 00:56:00,430
cache may have different performance

1406
00:56:00,430 --> 00:56:02,109
implications or different policies and

1407
00:56:02,109 --> 00:56:04,240
so to guarantee consistent performance

1408
00:56:04,240 --> 00:56:06,430
or consistent behavior across different

1409
00:56:06,430 --> 00:56:09,840
os's you just manage everything yourself

1410
00:56:09,840 --> 00:56:15,100
it's a good question yes there's number

1411
00:56:15,100 --> 00:56:19,240
pages but again so like I post as 8

1412
00:56:19,240 --> 00:56:21,760
kilobyte pages I take this number

1413
00:56:21,760 --> 00:56:24,310
multiply 8 divided by 1024 that tells me

1414
00:56:24,310 --> 00:56:26,800
them are megabytes of mic my thing I set

1415
00:56:26,800 --> 00:56:28,359
my buffer pool size to that size and

1416
00:56:28,359 --> 00:56:32,490
that can guarantee everything fits yes

1417
00:56:33,690 --> 00:56:36,490
of course question is how does buffer

1418
00:56:36,490 --> 00:56:39,570
pool interact with the OS page cache

1419
00:56:39,570 --> 00:56:50,050
again be it's like these question is

1420
00:56:50,050 --> 00:56:51,550
like are there different options how to

1421
00:56:51,550 --> 00:56:53,400
use it

1422
00:56:53,400 --> 00:56:56,980
no like so it's transparent to the

1423
00:56:56,980 --> 00:57:00,369
program like I call read every go read a

1424
00:57:00,369 --> 00:57:03,280
page from from the from disk if the OS

1425
00:57:03,280 --> 00:57:05,020
has a page cache that serves me that

1426
00:57:05,020 --> 00:57:06,520
page otherwise it goes out and disco

1427
00:57:06,520 --> 00:57:09,220
gets it that's all transparent to me if

1428
00:57:09,220 --> 00:57:12,220
I pass that flag direct i/o that tells

1429
00:57:12,220 --> 00:57:13,930
the option system do not catch anything

1430
00:57:13,930 --> 00:57:15,580
and it's always gonna go to disk and get

1431
00:57:15,580 --> 00:57:20,740
it it's quite yes save it as the OS page

1432
00:57:20,740 --> 00:57:22,960
cache is in between the sort of the disk

1433
00:57:22,960 --> 00:57:24,130
and the data in the database

1434
00:57:24,130 --> 00:57:26,109
absolutely yes it's gonna matter also to

1435
00:57:26,109 --> 00:57:28,270
a lot when we start doing writes if you

1436
00:57:28,270 --> 00:57:29,920
call like you write a C program you call

1437
00:57:29,920 --> 00:57:32,410
F write does is the operations I'm

1438
00:57:32,410 --> 00:57:33,369
actually gonna write that right away

1439
00:57:33,369 --> 00:57:35,859
no puts it in the page cache and at some

1440
00:57:35,859 --> 00:57:37,359
later point the disk schedule says all

1441
00:57:37,359 --> 00:57:38,890
right I'm gonna go write this out it's

1442
00:57:38,890 --> 00:57:40,690
only mine I call s Inc when is when

1443
00:57:40,690 --> 00:57:42,340
actually it's written but if I want a

1444
00:57:42,340 --> 00:57:43,510
complete control of how I'm ready

1445
00:57:43,510 --> 00:57:44,770
everything out the disk I want to use

1446
00:57:44,770 --> 00:57:47,170
direct i/o and most database systems do

1447
00:57:47,170 --> 00:57:50,550
that yes

1448
00:57:51,400 --> 00:57:54,140
yes all the t-80

1449
00:57:54,140 --> 00:57:57,590
and v60 and be into the book what would

1450
00:57:57,590 --> 00:57:59,810
happen the first 1:28 and we would have

1451
00:57:59,810 --> 00:58:01,940
been overwritten how many you did sir

1452
00:58:01,940 --> 00:58:04,820
clearly you got hit but many times the

1453
00:58:04,820 --> 00:58:06,560
query you have started from the starting

1454
00:58:06,560 --> 00:58:10,190
so you should have got it because the

1455
00:58:10,190 --> 00:58:14,960
memory presence was the later 128m let's

1456
00:58:14,960 --> 00:58:16,850
I'm gonna get through the thing for the

1457
00:58:16,850 --> 00:58:18,680
project but let's let me talk about it

1458
00:58:18,680 --> 00:58:21,770
wherefore it's okay alright so the thing

1459
00:58:21,770 --> 00:58:23,240
when to talk about now quickly is the

1460
00:58:23,240 --> 00:58:26,600
buffer placement policy so again we

1461
00:58:26,600 --> 00:58:29,000
talked about how right we how to find a

1462
00:58:29,000 --> 00:58:30,530
page we want based on the page ID and

1463
00:58:30,530 --> 00:58:32,810
the page table but now you know am all

1464
00:58:32,810 --> 00:58:34,490
my examples we had enough memory mostly

1465
00:58:34,490 --> 00:58:36,320
and so now we want to talk about what

1466
00:58:36,320 --> 00:58:37,910
happens if I need to bring a page in and

1467
00:58:37,910 --> 00:58:39,710
I don't have space for it what do I do

1468
00:58:39,710 --> 00:58:41,780
so the things were to care about and a

1469
00:58:41,780 --> 00:58:43,400
replacement policy are obviously

1470
00:58:43,400 --> 00:58:45,320
correctness right we don't want to write

1471
00:58:45,320 --> 00:58:47,480
out data or a big data that that someone

1472
00:58:47,480 --> 00:58:48,770
pinned before they're actually done with

1473
00:58:48,770 --> 00:58:50,540
it we're gonna care about accuracy

1474
00:58:50,540 --> 00:58:52,010
because we're gonna make sure that we we

1475
00:58:52,010 --> 00:58:53,990
Vic pages that are very unlikely be used

1476
00:58:53,990 --> 00:58:55,520
in the future so we minimize the number

1477
00:58:55,520 --> 00:58:57,650
of disk seeks we have we want overplay

1478
00:58:57,650 --> 00:58:59,300
some policy to be fast because we don't

1479
00:58:59,300 --> 00:59:01,040
you know the as we're doing a lookup in

1480
00:59:01,040 --> 00:59:03,440
the page table or holding latches and we

1481
00:59:03,440 --> 00:59:05,060
don't want have to run some MD complete

1482
00:59:05,060 --> 00:59:06,500
algorithm to figure out what page to

1483
00:59:06,500 --> 00:59:08,600
evict right because that may take longer

1484
00:59:08,600 --> 00:59:09,830
than actually reading the page anyway

1485
00:59:09,830 --> 00:59:11,750
and of course obviously we don't want to

1486
00:59:11,750 --> 00:59:13,460
have a lot of metadata overhead of

1487
00:59:13,460 --> 00:59:14,870
keeping track and all this additional

1488
00:59:14,870 --> 00:59:16,430
data we don't want to have the metadata

1489
00:59:16,430 --> 00:59:18,920
for a page keep track of how likely it's

1490
00:59:18,920 --> 00:59:21,500
going to be used to be larger than the

1491
00:59:21,500 --> 00:59:24,440
page itself so these replacement

1492
00:59:24,440 --> 00:59:25,850
policies again as another good example

1493
00:59:25,850 --> 00:59:28,670
what distinguishes between the high end

1494
00:59:28,670 --> 00:59:30,830
very expensive enterprise databases and

1495
00:59:30,830 --> 00:59:33,380
the open-source guys because the high

1496
00:59:33,380 --> 00:59:35,650
end ones have very sophisticated

1497
00:59:35,650 --> 00:59:37,910
replacement policies they track

1498
00:59:37,910 --> 00:59:39,470
statistics of how pages were being used

1499
00:59:39,470 --> 00:59:41,090
they try to extrapolate from what the

1500
00:59:41,090 --> 00:59:43,700
queries are actually doing and to try to

1501
00:59:43,700 --> 00:59:45,980
make the best decision whereas in the

1502
00:59:45,980 --> 00:59:49,040
the open source guys and the newer

1503
00:59:49,040 --> 00:59:50,810
systems not saying they're bad but they

1504
00:59:50,810 --> 00:59:52,310
don't have you know millions of dollars

1505
00:59:52,310 --> 00:59:54,530
in decades spent trying to make this

1506
00:59:54,530 --> 00:59:56,480
thing run fast as possible and so the

1507
00:59:56,480 --> 00:59:57,740
you know they'll do something more

1508
00:59:57,740 --> 00:59:59,630
simple which is what we're gonna talk

1509
00:59:59,630 --> 01:00:02,030
about here this is like one of the

1510
01:00:02,030 --> 01:00:03,680
oldest problems in CS like everyone

1511
01:00:03,680 --> 01:00:06,950
their uncle has a paper in the over the

1512
01:00:06,950 --> 01:00:08,630
years on how to do caching and things

1513
01:00:08,630 --> 01:00:10,569
like that I have one right like this is

1514
01:00:10,569 --> 01:00:12,530
this is like one of the oldest problems

1515
01:00:12,530 --> 01:00:14,869
in computer science there's a ton a long

1516
01:00:14,869 --> 01:00:18,050
history of this all right so the easiest

1517
01:00:18,050 --> 01:00:19,339
technique the use and pretty much

1518
01:00:19,339 --> 01:00:21,170
everyone does the first time is LRU or

1519
01:00:21,170 --> 01:00:23,960
at least recently used so all we do here

1520
01:00:23,960 --> 01:00:26,109
just keep track of a timestamp of when a

1521
01:00:26,109 --> 01:00:28,700
the last time a page was accessed and

1522
01:00:28,700 --> 01:00:30,140
then we have to go figure out what page

1523
01:00:30,140 --> 01:00:32,000
you will go evict we just look to see

1524
01:00:32,000 --> 01:00:33,980
which page has that old it's timestamp

1525
01:00:33,980 --> 01:00:35,630
and that's the one we go ahead and

1526
01:00:35,630 --> 01:00:38,420
remove so way to speed this up instead

1527
01:00:38,420 --> 01:00:41,030
just keeping a track of a you know a

1528
01:00:41,030 --> 01:00:42,829
timestamp her page because then we have

1529
01:00:42,829 --> 01:00:43,970
to do a special scan across all our

1530
01:00:43,970 --> 01:00:45,170
pages in the buffer pool to figure out

1531
01:00:45,170 --> 01:00:47,000
which one has the lowest timestamp we

1532
01:00:47,000 --> 01:00:48,200
can just maintain a separate data

1533
01:00:48,200 --> 01:00:50,599
structure like a queue that there's

1534
01:00:50,599 --> 01:00:53,750
that's sorted by the their timestamps so

1535
01:00:53,750 --> 01:00:55,359
anytime somebody reads and writes a page

1536
01:00:55,359 --> 01:00:57,950
we just pull it out of the queue and put

1537
01:00:57,950 --> 01:00:59,210
it back to the end because it's a

1538
01:00:59,210 --> 01:01:02,359
first-in first-out what you guys will

1539
01:01:02,359 --> 01:01:04,280
have to implement in the project is an

1540
01:01:04,280 --> 01:01:06,319
approximation of LRU called clock

1541
01:01:06,319 --> 01:01:08,059
actually quick show of hands who who

1542
01:01:08,059 --> 01:01:11,359
here has heard a clock before nobody

1543
01:01:11,359 --> 01:01:13,099
awesome okay cool here so I mean LRU

1544
01:01:13,099 --> 01:01:13,819
Emily should know right

1545
01:01:13,819 --> 01:01:17,210
okay good so clock so LRU is an exact

1546
01:01:17,210 --> 01:01:19,579
least recently used clock is an

1547
01:01:19,579 --> 01:01:21,349
approximation of this where you don't

1548
01:01:21,349 --> 01:01:22,910
have to track the timestamp exactly

1549
01:01:22,910 --> 01:01:26,150
every for every single page so instead

1550
01:01:26,150 --> 01:01:27,589
we're all the only information we need

1551
01:01:27,589 --> 01:01:29,450
to keep track of is a single reference

1552
01:01:29,450 --> 01:01:31,970
bit per page that tells you whether that

1553
01:01:31,970 --> 01:01:34,460
page was access since the last time you

1554
01:01:34,460 --> 01:01:37,069
checked it so you're gonna organize your

1555
01:01:37,069 --> 01:01:39,020
pages in a circular buffer like a clock

1556
01:01:39,020 --> 01:01:40,730
and then you have a clock hand that goes

1557
01:01:40,730 --> 01:01:42,319
around and does sweeps and check to see

1558
01:01:42,319 --> 01:01:44,030
whether that reference bit is set to 1

1559
01:01:44,030 --> 01:01:46,099
or 0 and if it's set to 0 that you know

1560
01:01:46,099 --> 01:01:47,420
has been access since the last time you

1561
01:01:47,420 --> 01:01:48,770
checked it and therefore it can be

1562
01:01:48,770 --> 01:01:52,250
evicted all right so say I page pages 1

1563
01:01:52,250 --> 01:01:54,380
2 3 4 again each one has their own

1564
01:01:54,380 --> 01:01:56,299
reference bit in the very beginning the

1565
01:01:56,299 --> 01:01:58,849
reference bit is set to 0 so let's say

1566
01:01:58,849 --> 01:02:02,000
that some some query accesses page 1 so

1567
01:02:02,000 --> 01:02:02,930
I'm gonna go ahead and flip its

1568
01:02:02,930 --> 01:02:04,790
reference bit to 1 and no matter how

1569
01:02:04,790 --> 01:02:06,710
many times somebody accesses this this

1570
01:02:06,710 --> 01:02:09,049
page it's always set to 1 it's not a

1571
01:02:09,049 --> 01:02:12,530
counter so now now I need Invicta page

1572
01:02:12,530 --> 01:02:14,210
because I don't have any more space so

1573
01:02:14,210 --> 01:02:15,559
my clock hands gonna start this first

1574
01:02:15,559 --> 01:02:17,570
one I see that it's reference

1575
01:02:17,570 --> 01:02:19,970
set the one and therefore it's been

1576
01:02:19,970 --> 01:02:21,410
accessed and therefore I should not have

1577
01:02:21,410 --> 01:02:23,870
victim but now I reset its reference bit

1578
01:02:23,870 --> 01:02:26,600
to zero and then go on to the to the

1579
01:02:26,600 --> 01:02:28,190
next one and I'm gonna sweep around if I

1580
01:02:28,190 --> 01:02:30,110
come back around and set the zero then I

1581
01:02:30,110 --> 01:02:33,170
know I can evict it so this guy here his

1582
01:02:33,170 --> 01:02:34,940
bit is set to zero so we can go ahead

1583
01:02:34,940 --> 01:02:37,280
and vicked it remove it and replace it

1584
01:02:37,280 --> 01:02:41,150
with a new page and then we don't set

1585
01:02:41,150 --> 01:02:42,830
its reference to one we just set it zero

1586
01:02:42,830 --> 01:02:45,650
and then move on to the next one so

1587
01:02:45,650 --> 01:02:46,910
let's say now page three and four have

1588
01:02:46,910 --> 01:02:48,920
been access so we check that reset it to

1589
01:02:48,920 --> 01:02:50,900
zero check that reset to zero now we've

1590
01:02:50,900 --> 01:02:52,040
come back to the page one was the first

1591
01:02:52,040 --> 01:02:54,260
one we checked its reference it was zero

1592
01:02:54,260 --> 01:02:55,850
since the last time we checked so

1593
01:02:55,850 --> 01:02:57,130
therefore it can be evicted

1594
01:02:57,130 --> 01:02:59,060
so again reason why this is an

1595
01:02:59,060 --> 01:03:02,360
approximation is because azzaman victim

1596
01:03:02,360 --> 01:03:04,940
pages I'm not a victim exactly the one

1597
01:03:04,940 --> 01:03:06,500
that's the most least least recently

1598
01:03:06,500 --> 01:03:09,260
used it's sort of you know it's the same

1599
01:03:09,260 --> 01:03:11,570
within some time window these pages have

1600
01:03:11,570 --> 01:03:13,490
not been used and therefore it's if

1601
01:03:13,490 --> 01:03:17,180
there's I go ahead and victim and the

1602
01:03:17,180 --> 01:03:19,190
intuition here is that if the page

1603
01:03:19,190 --> 01:03:21,440
hasn't been used in a while then it's

1604
01:03:21,440 --> 01:03:22,910
probably not gonna be used again in the

1605
01:03:22,910 --> 01:03:25,280
near future so therefore it's something

1606
01:03:25,280 --> 01:03:30,470
I can go ahead in a bit right right so

1607
01:03:30,470 --> 01:03:32,900
that assumption works a lot works well

1608
01:03:32,900 --> 01:03:34,580
for simple things like doing point

1609
01:03:34,580 --> 01:03:37,760
queries to go access single things but

1610
01:03:37,760 --> 01:03:39,800
clock and LRU are susceptible to what is

1611
01:03:39,800 --> 01:03:42,740
called sequential flooding and what this

1612
01:03:42,740 --> 01:03:44,600
means is that when we have a special

1613
01:03:44,600 --> 01:03:46,160
scan that's gonna read every single page

1614
01:03:46,160 --> 01:03:48,350
that's gonna pollute our page cache and

1615
01:03:48,350 --> 01:03:50,960
that's gonna end up having we can end up

1616
01:03:50,960 --> 01:03:52,910
evicting pages that maybe we do really

1617
01:03:52,910 --> 01:03:56,930
want that argument use very right and in

1618
01:03:56,930 --> 01:03:58,790
the near future but because that scan

1619
01:03:58,790 --> 01:04:00,380
read a bunch of pages all those pages

1620
01:04:00,380 --> 01:04:04,100
are gonna have newer timestamps and then

1621
01:04:04,100 --> 01:04:06,590
the page I actually do want right in

1622
01:04:06,590 --> 01:04:08,120
this case here the most recently page

1623
01:04:08,120 --> 01:04:10,940
use page is actually the one I want to

1624
01:04:10,940 --> 01:04:14,360
evict not the least recently used so

1625
01:04:14,360 --> 01:04:15,620
there's another good example where you

1626
01:04:15,620 --> 01:04:16,880
if you could have different buffer pool

1627
01:04:16,880 --> 01:04:18,470
different buffer pools or different

1628
01:04:18,470 --> 01:04:19,880
tables based on how queries are going to

1629
01:04:19,880 --> 01:04:22,130
access them maybe one I want to use most

1630
01:04:22,130 --> 01:04:23,390
recently used in another one I want to

1631
01:04:23,390 --> 01:04:25,940
use least recently used so let's look at

1632
01:04:25,940 --> 01:04:28,490
example let's say I have one query

1633
01:04:28,490 --> 01:04:30,350
that's doing a point lookup where where

1634
01:04:30,350 --> 01:04:31,490
a equals

1635
01:04:31,490 --> 01:04:34,040
we're ID equals one and it reads page

1636
01:04:34,040 --> 01:04:36,290
zero so go ahead and fetch that into my

1637
01:04:36,290 --> 01:04:38,840
buffer pool and I'm fine so then now

1638
01:04:38,840 --> 01:04:39,980
have another query that's gonna do a

1639
01:04:39,980 --> 01:04:41,500
central scan so it's gonna rip through

1640
01:04:41,500 --> 01:04:45,200
all my all my pages and they want to

1641
01:04:45,200 --> 01:04:46,910
once and make space for page three if

1642
01:04:46,910 --> 01:04:49,930
again we're using least recently used

1643
01:04:49,930 --> 01:04:52,190
then it would figure out that Oh page

1644
01:04:52,190 --> 01:04:53,720
zero is the least recently used let me

1645
01:04:53,720 --> 01:04:55,970
go ahead and evict that and put in page

1646
01:04:55,970 --> 01:04:59,630
three but in my work load I'm executing

1647
01:04:59,630 --> 01:05:01,369
queries that look like the first one

1648
01:05:01,369 --> 01:05:03,560
over and over again so now if I execute

1649
01:05:03,560 --> 01:05:04,520
this query all over again

1650
01:05:04,520 --> 01:05:07,970
now I repaid zero I just evicted it and

1651
01:05:07,970 --> 01:05:09,260
now I'm screwed because now I got to go

1652
01:05:09,260 --> 01:05:12,530
out and disk and get it okay so what I

1653
01:05:12,530 --> 01:05:13,700
really wanna should have done is is

1654
01:05:13,700 --> 01:05:15,890
evicted one or two because this scans

1655
01:05:15,890 --> 01:05:17,510
gonna go through go through a read more

1656
01:05:17,510 --> 01:05:19,580
data and it's unlikely anybody else is

1657
01:05:19,580 --> 01:05:22,840
going to come and read this thing here

1658
01:05:23,770 --> 01:05:27,800
so the way there's three ways to get

1659
01:05:27,800 --> 01:05:30,290
around this let me sort of cover some of

1660
01:05:30,290 --> 01:05:33,740
these so far so the first is to do

1661
01:05:33,740 --> 01:05:36,590
it's called LRU K where K is just you

1662
01:05:36,590 --> 01:05:38,510
keep track of a number the the time the

1663
01:05:38,510 --> 01:05:39,950
number of times a multiple timestamps

1664
01:05:39,950 --> 01:05:41,990
every single time this the page is

1665
01:05:41,990 --> 01:05:44,060
accessed so now when you want to say

1666
01:05:44,060 --> 01:05:45,380
which which one should I remove you

1667
01:05:45,380 --> 01:05:46,280
don't look to see which one has the

1668
01:05:46,280 --> 01:05:48,380
lowest time Stan you go look at the

1669
01:05:48,380 --> 01:05:50,450
intervals between those timestamps and

1670
01:05:50,450 --> 01:05:53,180
you say which one has the Long's amount

1671
01:05:53,180 --> 01:05:54,920
of time between one access to the next

1672
01:05:54,920 --> 01:05:57,109
access and then can use that to figure

1673
01:05:57,109 --> 01:05:59,119
out which one's the least likely to be

1674
01:05:59,119 --> 01:06:03,650
used so this because we're using the

1675
01:06:03,650 --> 01:06:05,390
history to estimate when it's can be

1676
01:06:05,390 --> 01:06:06,920
accessed again to make help us make a

1677
01:06:06,920 --> 01:06:08,450
better decision about what pages should

1678
01:06:08,450 --> 01:06:08,960
be evicted

1679
01:06:08,960 --> 01:06:15,080
so LRU K is what's used in the if the

1680
01:06:15,080 --> 01:06:16,400
more sophisticated ad says we'll do

1681
01:06:16,400 --> 01:06:18,680
something like this I don't know I think

1682
01:06:18,680 --> 01:06:20,510
my sequel might use this I don't I don't

1683
01:06:20,510 --> 01:06:23,869
remember all right the next optimization

1684
01:06:23,869 --> 01:06:24,740
we can do which we sort of already

1685
01:06:24,740 --> 01:06:28,369
talked about with having multiple buffer

1686
01:06:28,369 --> 01:06:30,109
pools is to have localization and per

1687
01:06:30,109 --> 01:06:33,410
query so rather than have that you know

1688
01:06:33,410 --> 01:06:34,880
as I'm skating the table and putting it

1689
01:06:34,880 --> 01:06:36,650
into the global buffer pool if I have a

1690
01:06:36,650 --> 01:06:39,320
small little set aside some pages in the

1691
01:06:39,320 --> 01:06:40,570
buffer pool that are

1692
01:06:40,570 --> 01:06:45,019
susceptance till read them but it's it's

1693
01:06:45,019 --> 01:06:46,669
I'm keeping track of how I'm using pages

1694
01:06:46,669 --> 01:06:49,609
so then then when I want to make a

1695
01:06:49,609 --> 01:06:51,979
decision what to evict from my query I

1696
01:06:51,979 --> 01:06:54,559
evict the ones that are least recently

1697
01:06:54,559 --> 01:06:58,429
used for me not the global view so we

1698
01:06:58,429 --> 01:07:00,439
saw this in Postgres Perez had that hit

1699
01:07:00,439 --> 01:07:02,299
memory show the hit was like 32 then

1700
01:07:02,299 --> 01:07:04,309
with the 64 right that's this little

1701
01:07:04,309 --> 01:07:05,599
ring buffer that they're keeping track

1702
01:07:05,599 --> 01:07:07,609
of what pages that that queries

1703
01:07:07,609 --> 01:07:09,469
accessing they make decisions what what

1704
01:07:09,469 --> 01:07:13,159
to evict all right the last one is view

1705
01:07:13,159 --> 01:07:15,469
priority hints again this is where we

1706
01:07:15,469 --> 01:07:16,759
talked about before when we have we have

1707
01:07:16,759 --> 01:07:18,169
indexes we know how they're scanning

1708
01:07:18,169 --> 01:07:20,689
data know what pages different access so

1709
01:07:20,689 --> 01:07:22,249
we can use that information to make

1710
01:07:22,249 --> 01:07:24,619
decisions about what - a bit so let's

1711
01:07:24,619 --> 01:07:26,989
say we have our B plus tree or whatever

1712
01:07:26,989 --> 01:07:28,669
tree data structure we want and they

1713
01:07:28,669 --> 01:07:29,569
have a bunch of queries they're gonna

1714
01:07:29,569 --> 01:07:31,549
insert data where there's a global

1715
01:07:31,549 --> 01:07:32,869
counter for this table or just

1716
01:07:32,869 --> 01:07:34,609
incrementing it by one and inserting

1717
01:07:34,609 --> 01:07:36,829
over and over again like a serial key or

1718
01:07:36,829 --> 01:07:39,619
auto increment key so if we're now

1719
01:07:39,619 --> 01:07:41,929
sorted on this index is sorted on ID

1720
01:07:41,929 --> 01:07:44,509
from min to max we know that every

1721
01:07:44,509 --> 01:07:47,269
single time we do an insert the ID value

1722
01:07:47,269 --> 01:07:48,679
is always going to be one more than the

1723
01:07:48,679 --> 01:07:50,689
last one we just inserted so that means

1724
01:07:50,689 --> 01:07:52,159
we're always gonna be going down the

1725
01:07:52,159 --> 01:07:53,749
right side of the tree and touching

1726
01:07:53,749 --> 01:07:56,389
these pages so therefore we should have

1727
01:07:56,389 --> 01:07:57,619
hints up into the buffer we'll manage

1728
01:07:57,619 --> 01:07:59,509
and say these pages should try to stay

1729
01:07:59,509 --> 01:08:01,579
in memory I don't care about these so

1730
01:08:01,579 --> 01:08:04,489
much about these other ones here or

1731
01:08:04,489 --> 01:08:05,989
likewise if I have a query that does

1732
01:08:05,989 --> 01:08:09,709
lookups on on different IDs or actually

1733
01:08:09,709 --> 01:08:10,759
any query that does a lookup on this

1734
01:08:10,759 --> 01:08:12,799
index I know I'm always gonna be going

1735
01:08:12,799 --> 01:08:13,969
through the blue page because that's how

1736
01:08:13,969 --> 01:08:15,739
I enter this index I have to go through

1737
01:08:15,739 --> 01:08:17,118
that so therefore I want to make sure

1738
01:08:17,118 --> 01:08:18,710
that's always pinned in memory that

1739
01:08:18,710 --> 01:08:20,630
always stays there right because

1740
01:08:20,630 --> 01:08:22,639
otherwise if I if I get by get to the

1741
01:08:22,639 --> 01:08:24,469
bottom and I need space and I Vic this

1742
01:08:24,469 --> 01:08:26,809
thing it's a bad idea because I look and

1743
01:08:26,809 --> 01:08:28,368
that's the least recently used but I

1744
01:08:28,368 --> 01:08:29,509
know that the next queries gonna come

1745
01:08:29,509 --> 01:08:30,920
through it and go to exactly for that

1746
01:08:30,920 --> 01:08:33,649
page so again this is what the

1747
01:08:33,649 --> 01:08:35,269
commercial systems can do provide you

1748
01:08:35,269 --> 01:08:39,488
some extra information up above alright

1749
01:08:39,488 --> 01:08:42,319
the last thing to talk about is how do

1750
01:08:42,319 --> 01:08:46,399
we actually handle dirty pages so member

1751
01:08:46,399 --> 01:08:47,839
that there's a dirty bit and the page

1752
01:08:47,839 --> 01:08:50,779
that says whether a query has modified

1753
01:08:50,779 --> 01:08:52,609
the contents of that page since the last

1754
01:08:52,609 --> 01:08:55,460
time it it's in since since it was

1755
01:08:55,460 --> 01:08:57,948
brought into the buffer pool so when we

1756
01:08:57,948 --> 01:08:58,880
announced

1757
01:08:58,880 --> 01:09:00,620
what paid to evict to bring a new page

1758
01:09:00,620 --> 01:09:04,010
in the fastest thing we could do is just

1759
01:09:04,010 --> 01:09:06,170
find a page that was that's not marked

1760
01:09:06,170 --> 01:09:08,680
dirty and immediately just drop it and

1761
01:09:08,680 --> 01:09:11,300
you know use its frame for a new buffer

1762
01:09:11,300 --> 01:09:14,689
pool the slower thing we have to do is

1763
01:09:14,689 --> 01:09:16,819
if a page is dirty we have to write it

1764
01:09:16,819 --> 01:09:20,330
back out the disk safely before we can

1765
01:09:20,330 --> 01:09:22,090
reuse that space for it for our new page

1766
01:09:22,090 --> 01:09:24,410
so now there's this trade-off we have to

1767
01:09:24,410 --> 01:09:26,000
make and our replacement policy decide

1768
01:09:26,000 --> 01:09:28,220
well there's a bunch of pages that are

1769
01:09:28,220 --> 01:09:30,170
all that are all clean and I could drop

1770
01:09:30,170 --> 01:09:32,180
them super easily but they actually may

1771
01:09:32,180 --> 01:09:35,540
be needed in the near future so I don't

1772
01:09:35,540 --> 01:09:36,740
want to actually drop them instead I

1773
01:09:36,740 --> 01:09:38,060
want to pay the penalty to write out a

1774
01:09:38,060 --> 01:09:40,670
dirty page flush it remove it from my

1775
01:09:40,670 --> 01:09:43,250
bumper pool and reuse its space so how

1776
01:09:43,250 --> 01:09:45,260
you actually balance them is is super

1777
01:09:45,260 --> 01:09:48,620
hard right because again I in this case

1778
01:09:48,620 --> 01:09:50,569
here to do a disk read if I had to write

1779
01:09:50,569 --> 01:09:52,970
out a dirty page it's to disk i/os one

1780
01:09:52,970 --> 01:09:54,770
IO to write out the dirty page then

1781
01:09:54,770 --> 01:09:56,000
remove it from the buffer pool and then

1782
01:09:56,000 --> 01:09:57,560
another IO to read a page that I want in

1783
01:09:57,560 --> 01:10:00,380
this case here it's one IO to just just

1784
01:10:00,380 --> 01:10:01,670
go read the page that I want cuz I can

1785
01:10:01,670 --> 01:10:03,050
drop the the page that's already in the

1786
01:10:03,050 --> 01:10:05,360
buffer pool so how you actually figure

1787
01:10:05,360 --> 01:10:07,160
that out again it's super hard and this

1788
01:10:07,160 --> 01:10:08,480
is what the commercial systems my

1789
01:10:08,480 --> 01:10:09,890
opinion do better than the open-source

1790
01:10:09,890 --> 01:10:13,430
ones so way to get around this to avoid

1791
01:10:13,430 --> 01:10:16,280
that the problem of having to write a

1792
01:10:16,280 --> 01:10:17,750
page out as soon as I need it for free

1793
01:10:17,750 --> 01:10:19,490
space in my buffer pool I can do

1794
01:10:19,490 --> 01:10:22,310
background writing so periodically that

1795
01:10:22,310 --> 01:10:23,420
data systems gonna have a thread they're

1796
01:10:23,420 --> 01:10:25,100
gonna look through my buffer pool figure

1797
01:10:25,100 --> 01:10:27,170
out what pages are marked dirty and just

1798
01:10:27,170 --> 01:10:30,560
write them out to disk so that way I can

1799
01:10:30,560 --> 01:10:32,060
flip them to be marked it's clean and

1800
01:10:32,060 --> 01:10:34,070
now when I do from my replacement policy

1801
01:10:34,070 --> 01:10:36,260
just slide what page to remove I have a

1802
01:10:36,260 --> 01:10:38,090
bunch of clean pages I can I can drop

1803
01:10:38,090 --> 01:10:41,510
right away so you gotta be careful when

1804
01:10:41,510 --> 01:10:43,100
you do this because you don't want to

1805
01:10:43,100 --> 01:10:44,780
write out dirty pages before the law of

1806
01:10:44,780 --> 01:10:47,320
records that correspond to their to

1807
01:10:47,320 --> 01:10:49,940
modifying them to make them dirty you

1808
01:10:49,940 --> 01:10:51,020
know make sure they're the law were

1809
01:10:51,020 --> 01:10:52,220
custom written out to disk first before

1810
01:10:52,220 --> 01:10:54,230
you write out the dirty pages we'll have

1811
01:10:54,230 --> 01:10:55,490
a whole lecture on why that's the case

1812
01:10:55,490 --> 01:10:57,500
later on in the semester but just know

1813
01:10:57,500 --> 01:10:58,820
there's like it's not just like I can

1814
01:10:58,820 --> 01:11:01,010
blindly write any page I want I have to

1815
01:11:01,010 --> 01:11:02,360
do some Etra step protection to make

1816
01:11:02,360 --> 01:11:03,440
sure I'm writing things in the right

1817
01:11:03,440 --> 01:11:05,570
order this is something that n mapkit

1818
01:11:05,570 --> 01:11:09,140
cannot do all right so I'm gonna skip

1819
01:11:09,140 --> 01:11:11,510
this for the other memory post just

1820
01:11:11,510 --> 01:11:12,890
we've already sort of covered this

1821
01:11:12,890 --> 01:11:14,660
it's more than just the pages from

1822
01:11:14,660 --> 01:11:17,330
tables or indexes there's when we run

1823
01:11:17,330 --> 01:11:19,220
queries we also needed to generate some

1824
01:11:19,220 --> 01:11:22,160
some information all right

1825
01:11:22,160 --> 01:11:26,450
so the again the the whole point of this

1826
01:11:26,450 --> 01:11:27,770
lecture was to talk about how we can

1827
01:11:27,770 --> 01:11:30,110
manage memory better than the OS because

1828
01:11:30,110 --> 01:11:31,280
we know what kurz are doing we know

1829
01:11:31,280 --> 01:11:32,480
what's in the pages we know how things

1830
01:11:32,480 --> 01:11:33,920
are being accessed and we can make

1831
01:11:33,920 --> 01:11:36,080
better decisions and essentially we're

1832
01:11:36,080 --> 01:11:37,910
gonna use information on what in the

1833
01:11:37,910 --> 01:11:39,770
query to you know for all these

1834
01:11:39,770 --> 01:11:40,670
different things that we talked about

1835
01:11:40,670 --> 01:11:42,200
and a bunch of optimization we can apply

1836
01:11:42,200 --> 01:11:44,810
to help us make this work better all

1837
01:11:44,810 --> 01:11:47,950
right so any questions about buffer pool

1838
01:11:48,040 --> 01:11:49,760
all right here's what you really care

1839
01:11:49,760 --> 01:11:54,140
about project one right so the for the

1840
01:11:54,140 --> 01:11:55,670
first project you're me building your

1841
01:11:55,670 --> 01:11:57,770
own buffer pool manager and replacement

1842
01:11:57,770 --> 01:12:00,950
policy so this will all be done in our

1843
01:12:00,950 --> 01:12:03,010
new database system called bust hub

1844
01:12:03,010 --> 01:12:05,780
which is it's an open source system it's

1845
01:12:05,780 --> 01:12:08,060
disk based again it's you will see this

1846
01:12:08,060 --> 01:12:10,700
will be stub files in the code that you

1847
01:12:10,700 --> 01:12:12,230
would download from github then a

1848
01:12:12,230 --> 01:12:13,910
clearly show here's the function need to

1849
01:12:13,910 --> 01:12:15,170
write and here's here's how to actually

1850
01:12:15,170 --> 01:12:16,730
you know implement that what we're

1851
01:12:16,730 --> 01:12:19,400
asking you to do so the project is the

1852
01:12:19,400 --> 01:12:20,510
write up is available online

1853
01:12:20,510 --> 01:12:22,550
the great scope isn't been set up yet

1854
01:12:22,550 --> 01:12:23,900
we'll do that later today but if you can

1855
01:12:23,900 --> 01:12:25,850
finish this project in a single day come

1856
01:12:25,850 --> 01:12:28,220
talk to me because we wouldn't want to

1857
01:12:28,220 --> 01:12:30,409
do other things

1858
01:12:30,409 --> 01:12:32,780
so we are gonna already provide you to

1859
01:12:32,780 --> 01:12:34,580
dis manager and already the page layouts

1860
01:12:34,580 --> 01:12:36,530
so you don't worry about that you just

1861
01:12:36,530 --> 01:12:38,889
will give you a page blocka blocka pages

1862
01:12:38,889 --> 01:12:40,940
and it's up for you to decide how to

1863
01:12:40,940 --> 01:12:43,040
store them in memory and then and and

1864
01:12:43,040 --> 01:12:44,659
invoke the disk manager to write them

1865
01:12:44,659 --> 01:12:48,290
out as needed so for the first one we

1866
01:12:48,290 --> 01:12:49,760
have a separate class called clock

1867
01:12:49,760 --> 01:12:52,340
replacer and you'll be implementing the

1868
01:12:52,340 --> 01:12:53,900
clock policy that I talked about here

1869
01:12:53,900 --> 01:12:56,659
today again it's an approximation of of

1870
01:12:56,659 --> 01:12:59,300
LRU we just sweep the hand and flip

1871
01:12:59,300 --> 01:13:01,699
these reference reference bits so that

1872
01:13:01,699 --> 01:13:04,429
means you need keep track of as pages

1873
01:13:04,429 --> 01:13:05,630
are being accessed because you'll see

1874
01:13:05,630 --> 01:13:07,940
this in the buffer point API you have to

1875
01:13:07,940 --> 01:13:09,620
know that when I say read a page or

1876
01:13:09,620 --> 01:13:12,620
write a page that you go update the

1877
01:13:12,620 --> 01:13:14,330
reference bit inside of your LRU replace

1878
01:13:14,330 --> 01:13:17,840
or sorry your clock or placer so the one

1879
01:13:17,840 --> 01:13:19,730
thing to be important to know is that if

1880
01:13:19,730 --> 01:13:23,420
you do a sweep and all the pages have

1881
01:13:23,420 --> 01:13:27,590
been modified then you just pick

1882
01:13:27,590 --> 01:13:29,420
whatever one has the lowest frame ID or

1883
01:13:29,420 --> 01:13:31,159
of all the pages are pin and you can't

1884
01:13:31,159 --> 01:13:32,690
free one then you pick them on the

1885
01:13:32,690 --> 01:13:34,639
lowest page ID right cuz otherwise you

1886
01:13:34,639 --> 01:13:37,250
just spin forever and this will be in

1887
01:13:37,250 --> 01:13:40,130
the write-up the major effort will be on

1888
01:13:40,130 --> 01:13:41,719
the on the buffle manager so your

1889
01:13:41,719 --> 01:13:43,280
element the clock replace your algorithm

1890
01:13:43,280 --> 01:13:45,530
first and then you hook that into your

1891
01:13:45,530 --> 01:13:47,540
buffer pool manager and for this one

1892
01:13:47,540 --> 01:13:48,860
it's again it's up for you to decide how

1893
01:13:48,860 --> 01:13:50,150
you actually want to maintain your

1894
01:13:50,150 --> 01:13:52,219
memory how you decide what internal data

1895
01:13:52,219 --> 01:13:53,389
structures you want to keep track of

1896
01:13:53,389 --> 01:13:55,040
what pages that are available what pages

1897
01:13:55,040 --> 01:13:58,370
are are dirty what pages are being

1898
01:13:58,370 --> 01:14:00,170
pinned right you can do whatever you

1899
01:14:00,170 --> 01:14:00,530
want

1900
01:14:00,530 --> 01:14:02,150
it's just you have to implement the API

1901
01:14:02,150 --> 01:14:05,449
that we expose to you so it's means

1902
01:14:05,449 --> 01:14:06,949
super the thing that always tricks up

1903
01:14:06,949 --> 01:14:08,300
students every year is to make sure you

1904
01:14:08,300 --> 01:14:10,010
get the ordering of the operations of

1905
01:14:10,010 --> 01:14:12,860
how to pin pages correct right so we'll

1906
01:14:12,860 --> 01:14:14,929
do multi-threading graded test will try

1907
01:14:14,929 --> 01:14:16,550
to read a page and pin at the same time

1908
01:14:16,550 --> 01:14:18,350
and you'll make sure that everything

1909
01:14:18,350 --> 01:14:20,389
turns out in the right order and this

1910
01:14:20,389 --> 01:14:21,800
would be more clear when you look at the

1911
01:14:21,800 --> 01:14:22,969
write up and see what we're asking you

1912
01:14:22,969 --> 01:14:26,420
to do so how do you get started so again

1913
01:14:26,420 --> 01:14:27,949
everything is available on github you

1914
01:14:27,949 --> 01:14:29,780
want to go to your if you don't forgive

1915
01:14:29,780 --> 01:14:31,670
it a github account sign up one it's

1916
01:14:31,670 --> 01:14:33,110
free there's also I think an educational

1917
01:14:33,110 --> 01:14:36,560
one that you get extra stuff but

1918
01:14:36,560 --> 01:14:37,850
basically you'll go to the github page

1919
01:14:37,850 --> 01:14:39,980
for the for the the database system and

1920
01:14:39,980 --> 01:14:41,210
could be a little fork button and you

1921
01:14:41,210 --> 01:14:43,760
fork it into your private repo a fokin

1922
01:14:43,760 --> 01:14:44,210
is your own

1923
01:14:44,210 --> 01:14:46,270
market is private so nothing's public

1924
01:14:46,270 --> 01:14:48,830
and then just do all your changes in

1925
01:14:48,830 --> 01:14:50,360
there if you sign up for the github

1926
01:14:50,360 --> 01:14:54,080
account you can get free private forked

1927
01:14:54,080 --> 01:14:55,910
repos right because if you put

1928
01:14:55,910 --> 01:14:57,050
everything public than other students

1929
01:14:57,050 --> 01:14:58,070
can see what you're doing and then

1930
01:14:58,070 --> 01:15:02,150
potentially copy from you the very first

1931
01:15:02,150 --> 01:15:03,260
thing you should try to do today or

1932
01:15:03,260 --> 01:15:04,640
tomorrow as soon as possible be super

1933
01:15:04,640 --> 01:15:07,400
helpful try to get the software to build

1934
01:15:07,400 --> 01:15:08,930
on your whatever machine you're gonna do

1935
01:15:08,930 --> 01:15:11,330
your development on so it works on

1936
01:15:11,330 --> 01:15:14,330
Ubuntu it works on OSX it works on

1937
01:15:14,330 --> 01:15:16,070
Windows with the Windows server or

1938
01:15:16,070 --> 01:15:18,350
server like Linux whatever this package

1939
01:15:18,350 --> 01:15:21,740
you can download install the thing

1940
01:15:21,740 --> 01:15:24,110
though for OSX is not gonna support the

1941
01:15:24,110 --> 01:15:25,340
clang formatting stuff that we'll talk

1942
01:15:25,340 --> 01:15:27,950
about in a second so great skip we'll

1943
01:15:27,950 --> 01:15:30,050
run this for you you can run it in

1944
01:15:30,050 --> 01:15:31,340
docker if you this is a problem we can

1945
01:15:31,340 --> 01:15:33,350
also give you a VM image but you'll have

1946
01:15:33,350 --> 01:15:35,450
to you don't have to figure this out on

1947
01:15:35,450 --> 01:15:36,680
your own we'll have instruction to try

1948
01:15:36,680 --> 01:15:37,400
to help us out

1949
01:15:37,400 --> 01:15:39,410
it does not compile an Android machine

1950
01:15:39,410 --> 01:15:42,260
we tried it it doesn't work the software

1951
01:15:42,260 --> 01:15:44,270
they have on there is too slow if this

1952
01:15:44,270 --> 01:15:45,320
is a problem you don't have your laptop

1953
01:15:45,320 --> 01:15:46,520
please email me and we'll figure

1954
01:15:46,520 --> 01:15:50,360
something out ok so things to note

1955
01:15:50,360 --> 01:15:52,250
should not change any file that other

1956
01:15:52,250 --> 01:15:53,900
than what you must hand in because we're

1957
01:15:53,900 --> 01:15:54,980
basically to blow everything away

1958
01:15:54,980 --> 01:15:56,840
there's four files you have to turn in

1959
01:15:56,840 --> 01:15:59,240
we blow everything else away and plop

1960
01:15:59,240 --> 01:16:01,400
your code on top of the latest version

1961
01:16:01,400 --> 01:16:04,250
of the the system and run all your tests

1962
01:16:04,250 --> 01:16:06,170
the projects are cumulative meaning if

1963
01:16:06,170 --> 01:16:07,280
you bomb this one you're gonna have

1964
01:16:07,280 --> 01:16:10,220
problems later on because you know the

1965
01:16:10,220 --> 01:16:11,810
next project is actually we use the

1966
01:16:11,810 --> 01:16:13,040
buffer pool manager that you built today

1967
01:16:13,040 --> 01:16:15,290
I build now we're also not gonna be

1968
01:16:15,290 --> 01:16:18,110
providing solutions at the beginning and

1969
01:16:18,110 --> 01:16:19,490
then we're not gonna happy debug and

1970
01:16:19,490 --> 01:16:22,700
your code on Piazza another thing we're

1971
01:16:22,700 --> 01:16:23,900
doing new this year is that we're

1972
01:16:23,900 --> 01:16:25,360
requiring you to write good-looking code

1973
01:16:25,360 --> 01:16:28,460
normally people like fit code and so now

1974
01:16:28,460 --> 01:16:29,780
we all want to check to make sure it

1975
01:16:29,780 --> 01:16:32,120
actually conforms to a good style guide

1976
01:16:32,120 --> 01:16:33,980
so we followed the google sleeveless

1977
01:16:33,980 --> 01:16:35,540
style guide and we also followed the

1978
01:16:35,540 --> 01:16:38,240
docs in Java doc style guide so we have

1979
01:16:38,240 --> 01:16:39,800
checks already in place that will check

1980
01:16:39,800 --> 01:16:41,330
all these things for you like if you

1981
01:16:41,330 --> 01:16:43,130
call make format it'll make sure your

1982
01:16:43,130 --> 01:16:44,990
code looks pretty in the simplest aisle

1983
01:16:44,990 --> 01:16:46,370
guide but there's a bunch of other

1984
01:16:46,370 --> 01:16:49,370
things like how you allocate memory how

1985
01:16:49,370 --> 01:16:50,810
you set up your for loops and so forth

1986
01:16:50,810 --> 01:16:53,270
that we use clang tidy and clang format

1987
01:16:53,270 --> 01:16:56,570
to to enforce more more detail so you'll

1988
01:16:56,570 --> 01:16:57,800
run these commands like

1989
01:16:57,800 --> 01:17:00,470
clang tidy collect check censored check

1990
01:17:00,470 --> 01:17:02,210
lint it will throw errors they won't

1991
01:17:02,210 --> 01:17:03,530
correct it for you or throw errors and

1992
01:17:03,530 --> 01:17:05,330
say your code looks crappy here's how to

1993
01:17:05,330 --> 01:17:07,490
fix it ok and we're gonna run though

1994
01:17:07,490 --> 01:17:08,870
some grade scope so when you turn it in

1995
01:17:08,870 --> 01:17:11,150
if you write crappy code you'll get

1996
01:17:11,150 --> 01:17:12,950
you'll get a zero score because you'll

1997
01:17:12,950 --> 01:17:15,710
fail these tests so this what I'm saying

1998
01:17:15,710 --> 01:17:17,330
so Linux and Windows I think this works

1999
01:17:17,330 --> 01:17:19,430
for OSX I don't think this works but we

2000
01:17:19,430 --> 01:17:21,020
can we can provide you a PM you can do

2001
01:17:21,020 --> 01:17:24,530
all your development in there ok last

2002
01:17:24,530 --> 01:17:25,970
thing don't plagiarize we will run your

2003
01:17:25,970 --> 01:17:27,620
code through moss there's some some

2004
01:17:27,620 --> 01:17:28,970
people in China that take the code and

2005
01:17:28,970 --> 01:17:30,050
I've already implemented some stuff

2006
01:17:30,050 --> 01:17:31,880
there's is all crap we've run it doesn't

2007
01:17:31,880 --> 01:17:33,520
work

2008
01:17:33,520 --> 01:17:35,570
don't make your stuff again don't put

2009
01:17:35,570 --> 01:17:37,100
your stuff on the public repo because if

2010
01:17:37,100 --> 01:17:39,260
I run your stuff and someone copies from

2011
01:17:39,260 --> 01:17:40,790
you because your account was public

2012
01:17:40,790 --> 01:17:43,130
rerun the moss and you both come up as

2013
01:17:43,130 --> 01:17:44,690
being duplicates of each other I don't

2014
01:17:44,690 --> 01:17:47,030
know who stole from who all right so you

2015
01:17:47,030 --> 01:17:49,730
broke they're gonna fail ok so don't put

2016
01:17:49,730 --> 01:17:51,680
any of your code public you can do this

2017
01:17:51,680 --> 01:17:53,090
thing then this semester because I know

2018
01:17:53,090 --> 01:17:54,230
you want to go in the job market me like

2019
01:17:54,230 --> 01:17:57,080
oh here's what I did in this class truth

2020
01:17:57,080 --> 01:17:58,340
be told no one's actually gonna care

2021
01:17:58,340 --> 01:17:59,750
because everyone's implementing the same

2022
01:17:59,750 --> 01:18:00,950
thing it's not like an independent study

2023
01:18:00,950 --> 01:18:02,390
where you you make some breaks it could

2024
01:18:02,390 --> 01:18:04,970
break through so employers they don't

2025
01:18:04,970 --> 01:18:06,470
care that much that you have your

2026
01:18:06,470 --> 01:18:09,050
project online but if you want to do it

2027
01:18:09,050 --> 01:18:09,980
and the semester if we're fine with that

2028
01:18:09,980 --> 01:18:15,080
ok any questions next for hash table hit

2029
01:18:15,080 --> 01:18:19,400
it home in schools with Michelle in case

2030
01:18:19,400 --> 01:18:22,040
any same on Linda mix of broken bottles

2031
01:18:22,040 --> 01:18:25,210
and crushed up kids let

2032
01:18:25,500 --> 01:18:28,450
he's misty nights in my system cracking

2033
01:18:28,450 --> 01:18:30,370
up on blessed let's go get the next one

2034
01:18:30,370 --> 01:18:37,420
then get over the net will be son

2035
01:18:37,420 --> 01:18:39,580
ricochet jelly hit the deli for a boat

2036
01:18:39,580 --> 01:18:41,710
one naturally bless ya what rap is like

2037
01:18:41,710 --> 01:18:43,630
a laser beam the pawns in the bush say

2038
01:18:43,630 --> 01:18:45,850
not even like a chain wrap the bottle of

2039
01:18:45,850 --> 01:18:48,550
us a nice go don't feel like drinking

2040
01:18:48,550 --> 01:18:50,350
head boney to you drunk you can't try

2041
01:18:50,350 --> 01:18:52,390
cross he's alive and if the sake don't

2042
01:18:52,390 --> 01:18:55,650
know you can't a bang

