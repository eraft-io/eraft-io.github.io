1
00:00:01,300 --> 00:00:05,129
[音乐]

2
00:00:05,200 --> 00:00:05,930
[掌声]

3
00:00:05,930 --> 00:00:08,630
[音乐]

4
00:00:08,630 --> 00:00:10,020
[掌声]

5
00:00:10,020 --> 00:00:11,420
[音乐]

6
00:00:11,420 --> 00:00:14,670
今天是我们关于查询优化的第二堂课，

7
00:00:14,670 --> 00:00:18,240
所以再次高层次的

8
00:00:18,240 --> 00:00:19,350
想法或我们今天在这里尝试做的

9
00:00:19,350 --> 00:00:22,859
是给它一个我们想要生成的续集查询

10
00:00:22,859 --> 00:00:26,070


11
00:00:26,070 --> 00:00:28,380
该查询的物理执行计划既正确

12
00:00:28,380 --> 00:00:30,960
意味着它将生成

13
00:00:30,960 --> 00:00:33,480
我们期望的正确答案，并且在我们可以检查

14
00:00:33,480 --> 00:00:36,120
的所有查询计划中成本最低

15
00:00:36,120 --> 00:00:42,329


16
00:00:42,329 --> 00:00:43,860
上节课我们再次说过这非常困难 这样做

17
00:00:43,860 --> 00:00:47,010
是因为试图找到

18
00:00:47,010 --> 00:00:49,649
查询计划的问题已被证明是 np-complete

19
00:00:49,649 --> 00:00:52,559
，因此即使

20
00:00:52,559 --> 00:00:53,489
我们尝试做的事情的名称称为

21
00:00:53,489 --> 00:00:55,140
优化器，我们也不会真正

22
00:00:55,140 --> 00:00:57,000
尝试在其中找到 大多数情况下形成

23
00:00:57,000 --> 00:00:59,520
有用的复杂查询 真正的最佳

24
00:00:59,520 --> 00:01:04,049
计划 所以我们最后一课 我们看了

25
00:01:04,049 --> 00:01:07,320
一堆不同的方法来做

26
00:01:07,320 --> 00:01:10,200
这个搜索 我们首先谈到了

27
00:01:10,200 --> 00:01:13,380
如何使用启发式，

28
00:01:13,380 --> 00:01:14,610
你只有这些 if-then-else

29
00:01:14,610 --> 00:01:16,650
语句 培根源

30
00:01:16,650 --> 00:01:18,540
代码 确定某些查询模式

31
00:01:18,540 --> 00:01:20,880
并将更改应用于查询

32
00:01:20,880 --> 00:01:23,369
计划以放入不同的形式，然后

33
00:01:23,369 --> 00:01:25,320
我们讨论了如何

34
00:01:25,320 --> 00:01:26,850
将第

35
00:01:26,850 --> 00:01:30,020
一种方法的启发式方法以及

36
00:01:30,020 --> 00:01:32,250
来自系统或

37
00:01:32,250 --> 00:01:35,700
来自的基于成本的搜索方法进行组合 IBM 允许我们找到

38
00:01:35,700 --> 00:01:37,860
最佳联合排序，这里的关键思想

39
00:01:37,860 --> 00:01:39,990
使成本模型基础

40
00:01:39,990 --> 00:01:42,299
与众不同，成本模型

41
00:01:42,299 --> 00:01:43,979
指导我们的搜索，这是我们

42
00:01:43,979 --> 00:01:47,520
估算查询计划成本的一种方式，

43
00:01:47,520 --> 00:01:49,740
然后使用它 比较

44
00:01:49,740 --> 00:01:52,590
一个计划与另一个计划的近似值然后我们讨论

45
00:01:52,590 --> 00:01:55,259
了如何使用

46
00:01:55,259 --> 00:01:58,170
模拟钉钉或 Postgres 的生成器算法

47
00:01:58,170 --> 00:01:59,939
进行随机搜索，据我所知，

48
00:01:59,939 --> 00:02:02,520
Postgres 是唯一一个

49
00:02:02,520 --> 00:02:03,390
在这里使用第三种选择的方法，

50
00:02:03,390 --> 00:02:05,880
但他们只将它用于查询

51
00:02:05,880 --> 00:02:09,288
有超过 13 个表，

52
00:02:09,288 --> 00:02:12,020
否则默认情况下你会得到第二种方法

53
00:02:12,020 --> 00:02:14,610
，然后现在我们讨论

54
00:02:14,610 --> 00:02:16,340
了 1980 年代末 1990 年代初

55
00:02:16,340 --> 00:02:19,650
向这些优化器生成器的运动，其中

56
00:02:19,650 --> 00:02:22,230
而不是我们没有看到的命令式代码

57
00:02:22,230 --> 00:02:25,140
或 C++ 为查询计划执行所有这些步骤

58
00:02:25,140 --> 00:02:29,090
留置权而是

59
00:02:29,090 --> 00:02:31,410
用高级语言编写我们的优化器规则，而

60
00:02:31,410 --> 00:02:34,020
不是让编译器

61
00:02:34,020 --> 00:02:37,530
为我们生成优化器，所以

62
00:02:37,530 --> 00:02:39,000
星巴克是第一个 一个来自 IBM 的这个空间

63
00:02:39,000 --> 00:02:41,400
，它使用分层

64
00:02:41,400 --> 00:02:44,250
搜索，就像这样的启发式

65
00:02:44,250 --> 00:02:47,340
加上成本基础联合搜索，

66
00:02:47,340 --> 00:02:51,750
然后统一搜索正在做

67
00:02:51,750 --> 00:02:53,820
那种逻辑和逻辑逻辑

68
00:02:53,820 --> 00:02:55,170
不合逻辑的物理

69
00:02:55,170 --> 00:02:57,990
转换，这是 你们在

70
00:02:57,990 --> 00:03:01,320
Cascades 中使用的那些你们再次阅读的论文

71
00:03:01,320 --> 00:03:04,170
只是为了重申最后

72
00:03:04,170 --> 00:03:06,360
两点 只是重复我自己

73
00:03:06,360 --> 00:03:09,030
分层搜索是我们将

74
00:03:09,030 --> 00:03:11,400
有这些规则来做到这一点的地方 逻辑

75
00:03:11,400 --> 00:03:15,300
四边形转换和方式的

76
00:03:15,300 --> 00:03:16,770
想法 这将再次起作用

77
00:03:16,770 --> 00:03:18,930
不只是

78
00:03:18,930 --> 00:03:22,500
一个规则列表，我们一个

79
00:03:22,500 --> 00:03:25,590
接一个地应用它们 有这个规则

80
00:03:25,590 --> 00:03:27,270
引擎，它会查看查询

81
00:03:27,270 --> 00:03:29,730
计划 f

82
00:03:29,730 --> 00:03:32,880
找出与我们

83
00:03:32,880 --> 00:03:35,130
必须找到的规则相匹配的模式，然后将它们解雇

84
00:03:35,130 --> 00:03:37,260
以进行我们的更改，但在

85
00:03:37,260 --> 00:03:39,750
这第一步中，它完全

86
00:03:39,750 --> 00:03:43,800
没有咨询成本模型就完全完成了，

87
00:03:43,800 --> 00:03:46,140
因为没有成本模型 然后

88
00:03:46,140 --> 00:03:48,120
在此之后，我们进行相同的基于成本的

89
00:03:48,120 --> 00:03:49,980
搜索以将逻辑计划映射到

90
00:03:49,980 --> 00:03:52,140
物理计划，这也是 IBM 的

91
00:03:52,140 --> 00:03:55,080
技术，但你知道如果我

92
00:03:55,080 --> 00:03:57,150
再次搜索，这里的想法是，而不是

93
00:03:57,150 --> 00:03:59,310
拥有这两个单独的阶段，你

94
00:03:59,310 --> 00:04:03,030
只有 一个单一的搜索过程

95
00:04:03,030 --> 00:04:07,020
或一个单一的搜索过程，可以

96
00:04:07,020 --> 00:04:09,330
同时进行逻辑到逻辑和逻辑

97
00:04:09,330 --> 00:04:11,790
物理转换，所以你不再

98
00:04:11,790 --> 00:04:13,710
需要单独的阶段，因为

99
00:04:13,710 --> 00:04:15,080
你只是一次性完成所有事情，

100
00:04:15,080 --> 00:04:18,750
所以我们将看到 当我们

101
00:04:18,750 --> 00:04:22,200
谈论级联时，这种

102
00:04:22,200 --> 00:04:23,900
方法将产生大量

103
00:04:23,900 --> 00:04:26,960
冗余变换，

104
00:04:26,960 --> 00:04:29,310
因为再次像分层搜索一样，

105
00:04:29,310 --> 00:04:31,620
一旦我通过了第一阶段，

106
00:04:31,620 --> 00:04:33,870
我将永远不会重新考虑

107
00:04:33,870 --> 00:04:36,990
再次使用这些规则，但在统一搜索中它们全部

108
00:04:36,990 --> 00:04:39,240
组合在一起，因此您可能会

109
00:04:39,240 --> 00:04:42,150
尝试一遍又一遍地评估相同的规则

110
00:04:42,150 --> 00:04:44,160
，因此您必须使用

111
00:04:44,160 --> 00:04:47,070
记忆来识别您正在

112
00:04:47,070 --> 00:04:49,770
执行冗余计算或添加

113
00:04:49,770 --> 00:04:52,370
冗余转换和 使用缓存

114
00:04:52,370 --> 00:04:54,570
缓存结果，而不是再次应用它

115
00:04:54,570 --> 00:04:56,700
我们将在

116
00:04:56,700 --> 00:04:58,380
讨论时更详细地介绍这一点

117
00:04:58,380 --> 00:05:03,300
级联 除了您是否想要

118
00:05:03,300 --> 00:05:07,160
统一还是分层

119
00:05:07,160 --> 00:05:09,930
另一类您必须

120
00:05:09,930 --> 00:05:12,000
在查询优化器中做出的设计决策

121
00:05:12,000 --> 00:05:14,550
是你想进行自顶向下还是自

122
00:05:14,550 --> 00:05:18,120
底向上优化，所以自顶向下将

123
00:05:18,120 --> 00:05:19,260
是级联，这就是你从

124
00:05:19,260 --> 00:05:21,180
你想要的最终结果开始的地方，

125
00:05:21,180 --> 00:05:23,370
我想把这三个表

126
00:05:23,370 --> 00:05:25,920
连接在一起，然后你向下遍历

127
00:05:25,920 --> 00:05:29,330
搜索树并开始添加

128
00:05:29,330 --> 00:05:31,260
操作

129
00:05:31,260 --> 00:05:32,970
符，您需要达到

130
00:05:32,970 --> 00:05:35,430
该最终目标的物理操作符或逻辑操作符，您可以使用

131
00:05:35,430 --> 00:05:37,680
关于修剪技术的经典分支

132
00:05:37,680 --> 00:05:39,720
来识别 t 如果有一个分支

133
00:05:39,720 --> 00:05:43,169
的当前成本

134
00:05:43,169 --> 00:05:44,669
大于您

135
00:05:44,669 --> 00:05:46,260
从当前的书外当前

136
00:05:46,260 --> 00:05:47,910
最佳计划中看到的最低成本，您知道您不需要

137
00:05:47,910 --> 00:05:53,190
深入研究动态

138
00:05:53,190 --> 00:05:54,390
规划 这些从系统中落下的技术

139
00:05:54,390 --> 00:05:56,700
是自下而上优化的一个例子

140
00:05:56,700 --> 00:05:58,919


141
00:05:58,919 --> 00:06:01,590
，您从底部开始，

142
00:06:01,590 --> 00:06:05,190
然后尽早添加

143
00:06:05,190 --> 00:06:06,660
查询计划所需的组件或运算符，

144
00:06:06,660 --> 00:06:10,050
以正确实现最终目标

145
00:06:10,050 --> 00:06:12,120
这又是动态网络共晶，

146
00:06:12,120 --> 00:06:15,870
所以当前的文献

147
00:06:15,870 --> 00:06:18,270
表明动态编程自下而上的

148
00:06:18,270 --> 00:06:20,130
优化更好 今天我们将讨论

149
00:06:20,130 --> 00:06:22,230
一下为什么会

150
00:06:22,230 --> 00:06:28,050
这样 在我看来，从软件

151
00:06:28,050 --> 00:06:31,290
工程的角度来看，我觉得我 '

152
00:06:31,290 --> 00:06:33,150
能够更好地推理统一

153
00:06:33,150 --> 00:06:34,830
方法和自上而下的方法

154
00:06:34,830 --> 00:06:37,169
，这就是我们

155
00:06:37,169 --> 00:06:39,479
在我们的系统中

156
00:06:39,479 --> 00:06:41,139
再次实施的方法，就像研究

157
00:06:41,139 --> 00:06:42,130
文献一样，然后是

158
00:06:42,130 --> 00:06:43,180
实际实施的方法

159
00:06:43,180 --> 00:06:47,380
系统，因此您将

160
00:06:47,380 --> 00:06:49,780
在下周或下周下周三订购时看到该论文

161
00:06:49,780 --> 00:06:52,410
，

162
00:06:52,410 --> 00:06:54,250
续集服务器实际上拥有最好的

163
00:06:54,250 --> 00:06:55,870
查询优化器，并且他们使用

164
00:06:55,870 --> 00:06:59,229
自上而下的级联方法，但

165
00:06:59,229 --> 00:07:00,729
文献表明动态

166
00:07:00,729 --> 00:07:02,560
阅读自下而上的阅读方式

167
00:07:02,560 --> 00:07:04,180
更好，因为还有很多

168
00:07:04,180 --> 00:07:06,340
事情要做，而不仅仅是你知道

169
00:07:06,340 --> 00:07:08,320
你是否要进入。在这些方向上，

170
00:07:08,320 --> 00:07:09,910
成本模型很重要，你如何

171
00:07:09,910 --> 00:07:11,770
收集基数

172
00:07:11,770 --> 00:07:13,570
估计所有这些都将

173
00:07:13,570 --> 00:07:16,810
有助于 查询计划的整体效率和质量

174
00:07:16,810 --> 00:07:18,760
所以生成而不只是

175
00:07:18,760 --> 00:07:21,639
使用什么算法所以对于

176
00:07:21,639 --> 00:07:23,889
今天的议程我想花一些时间

177
00:07:23,889 --> 00:07:25,630
开始讨论我们将如何

178
00:07:25,630 --> 00:07:28,240
再次进行逻辑查询优化这些

179
00:07:28,240 --> 00:07:29,919
我们将在这里讨论的事情

180
00:07:29,919 --> 00:07:30,970
适用于您是在进行

181
00:07:30,970 --> 00:07:33,250
分层搜索还是统一搜索，那么我们将

182
00:07:33,250 --> 00:07:35,080
花时间讨论

183
00:07:35,080 --> 00:07:37,000
Cascades 的内容 Cascades 如何优化它

184
00:07:37,000 --> 00:07:38,740
，我们将在

185
00:07:38,740 --> 00:07:40,660
上下文中执行此操作 xt，正如你们之前阅读的论文中所描述的那样，

186
00:07:40,660 --> 00:07:42,610
其中说

187
00:07:42,610 --> 00:07:45,130
19 世纪 89 世纪

188
00:07:45,130 --> 00:07:48,520
90 年代后期关于基于级联的查询优化器的硕士论文，

189
00:07:48,520 --> 00:07:51,010
称为哥伦比亚 我

190
00:07:51,010 --> 00:07:52,270
让你们阅读那篇论文而不是

191
00:07:52,270 --> 00:07:53,650
原始 Cascades 论文的原因，因为

192
00:07:53,650 --> 00:07:55,990
原始级联论文 不是很好，

193
00:07:55,990 --> 00:07:58,000
它并没有真正描述他们

194
00:07:58,000 --> 00:07:59,409
实际在做什么 他们一直在

195
00:07:59,409 --> 00:08:00,789
谈论他们

196
00:08:00,789 --> 00:08:02,800
的面向对象有多么棒，因为它

197
00:08:02,800 --> 00:08:05,080
在 1990 年代初期很流行，

198
00:08:05,080 --> 00:08:07,240
而那篇哥伦比亚

199
00:08:07,240 --> 00:08:08,760
硕士论文

200
00:08:08,760 --> 00:08:11,190
中的那 30 页则奠定了基础 在我看来

201
00:08:11,190 --> 00:08:13,360
，关于级联如何实际

202
00:08:13,360 --> 00:08:15,159
工作以及它如何很好

203
00:08:15,159 --> 00:08:17,560
地实现的最佳描述简要讨论了为什么

204
00:08:17,560 --> 00:08:19,539
动态编程可以做的一些事情也许

205
00:08:19,539 --> 00:08:21,599
Cask 使用 Cascades

206
00:08:21,599 --> 00:08:23,800
至少在中等实现中不能很容易地完成，

207
00:08:23,800 --> 00:08:26,380
就像我一样 在德国有超级家伙

208
00:08:26,380 --> 00:08:28,210
然后我们将讨论一堆

209
00:08:28,210 --> 00:08:30,220
其他类型的优化器实现

210
00:08:30,220 --> 00:08:31,780
，这些优化器实现再次被

211
00:08:31,780 --> 00:08:33,549
归类为 无论他们是在做

212
00:08:33,549 --> 00:08:35,620
动态编程还是 Cascades

213
00:08:35,620 --> 00:08:37,208
但同样我只是希望我们

214
00:08:37,208 --> 00:08:38,620
希望你知道那里有什么

215
00:08:38,620 --> 00:08:42,520
然后我们将

216
00:08:42,520 --> 00:08:45,580
在本周周三开始快速概述

217
00:08:45,580 --> 00:08:47,890
你的项目

218
00:08:47,890 --> 00:08:49,360
三的预期 代码审查提交

219
00:08:49,360 --> 00:08:51,130
，我们将进行两轮海岸

220
00:08:51,130 --> 00:08:53,470
任务装备使用，所以我会

221
00:08:53,470 --> 00:08:55,810
在星期三将你签到另一个小组，你

222
00:08:55,810 --> 00:08:58,870
在 github doto 上扫描你的代码对你的代码进行代码审查，

223
00:08:58,870 --> 00:09:00,970
然后你对

224
00:09:00,970 --> 00:09:02,800
他们的代码进行代码审查 我想谈谈

225
00:09:02,800 --> 00:09:04,360
作为学生

226
00:09:04,360 --> 00:09:05,829
参与这个项目对这些

227
00:09:05,829 --> 00:09:10,209
东西有什么样的期望是的，好的，所以

228
00:09:10,209 --> 00:09:12,010
我们可以做两种类型的优化

229
00:09:12,010 --> 00:09:13,450
，逻辑

230
00:09:13,450 --> 00:09:15,279
优化和物理

231
00:09:15,279 --> 00:09:17,910
优化逻辑优化是

232
00:09:17,910 --> 00:09:19,990
变化 或者我们可以

233
00:09:19,990 --> 00:09:23,920
应用到我们从绑定器中获得的逻辑查询计划的转换，

234
00:09:23,920 --> 00:09:28,329


235
00:09:28,329 --> 00:09:32,769
或者在我们的前端堆栈中更上一层，我们

236
00:09:32,769 --> 00:09:34,450
可以应用基于匹配

237
00:09:34,450 --> 00:09:38,079
模式的规则或

238
00:09:38,079 --> 00:09:40,000
我们会在

239
00:09:40,000 --> 00:09:41,860
逻辑查询计划中看到某些模式，我们可以

240
00:09:41,860 --> 00:09:43,959
对查询计划进行更改，

241
00:09:43,959 --> 00:09:45,640
这样我们就可以潜在地设置自己，

242
00:09:45,640 --> 00:09:48,490
以便当我们

243
00:09:48,490 --> 00:09:51,700
在物理查询优化

244
00:09:51,700 --> 00:09:56,079
步骤中进行计划枚举时 可以

245
00:09:56,079 --> 00:10:00,070
更容易地找到专辑计划，因此并不

246
00:10:00,070 --> 00:10:01,930
总是如此，这里所做的

247
00:10:01,930 --> 00:10:03,399
更改将

248
00:10:03,399 --> 00:10:04,839
保证我们能够找到 Alcone 计划，

249
00:10:04,839 --> 00:10:06,610
但如果我们

250
00:10:06,610 --> 00:10:08,320
对优化器的工作原理有所了解，我们就会知道 我们的一点

251
00:10:08,320 --> 00:10:10,029
你知道我们的计划新版本

252
00:10:10,029 --> 00:10:13,180
专辑实际上是然后我们可以

253
00:10:13,180 --> 00:10:14,890
以这样的方式应用这些变化，我们可以

254
00:10:14,890 --> 00:10:17,260
为自己做好准备 我引用的是对的所以

255
00:10:17,260 --> 00:10:18,459
我所说的关于这一步的重要事情

256
00:10:18,459 --> 00:10:20,529
我们是如何的 将

257
00:10:20,529 --> 00:10:24,339
在我们进行物理

258
00:10:24,339 --> 00:10:26,560
查询优化的时候再进行一次，因为

259
00:10:26,560 --> 00:10:29,170
没有成本模型，我们无法

260
00:10:29,170 --> 00:10:32,320
确定一个查询计划是否

261
00:10:32,320 --> 00:10:34,060
比另一个更好，所以我们不知道

262
00:10:34,060 --> 00:10:36,160
我们是否采取拼贴 achill que  ry

263
00:10:36,160 --> 00:10:37,540
计划然后将它转换为另一个

264
00:10:37,540 --> 00:10:40,899
逻辑查询计划 优化器

265
00:10:40,899 --> 00:10:42,970
那个阶段不能说 哦是的

266
00:10:42,970 --> 00:10:45,010
转换是一件好事

267
00:10:45,010 --> 00:10:46,630
它会做 它将帮助我

268
00:10:46,630 --> 00:10:48,850
以较低的成本生成查询计划 我们不

269
00:10:48,850 --> 00:10:52,300
知道但是 我们了解系统，因为我们

270
00:10:52,300 --> 00:10:54,040
了解

271
00:10:54,040 --> 00:10:55,630
关系数据库或

272
00:10:55,630 --> 00:10:56,709
我们尝试运行的假名戴维斯以及我们的查询是什么

273
00:10:56,709 --> 00:10:58,329
样的以及我们的系统实际

274
00:10:58,329 --> 00:11:01,709
执行的方式的某些方面我们然后可以指导我们的

275
00:11:01,709 --> 00:11:03,279
转换所以

276
00:11:03,279 --> 00:11:07,079
我们希望您知道一个计划 另一个

277
00:11:07,079 --> 00:11:09,009
好的，但归根结底，

278
00:11:09,009 --> 00:11:11,170
重要的是原始

279
00:11:11,170 --> 00:11:13,329
计划或我们在这些转换后生成的新计划

280
00:11:13,329 --> 00:11:14,350


281
00:11:14,350 --> 00:11:15,999
必须与原始计划等效，因为

282
00:11:15,999 --> 00:11:17,800
它对我们没有帮助，是的，如果我们发现

283
00:11:17,800 --> 00:11:19,870
更快的查询 产生不正确的

284
00:11:19,870 --> 00:11:22,809
结果，因为人们会得到测试，

285
00:11:22,809 --> 00:11:23,860
现在你的数据库系统被认为

286
00:11:23,860 --> 00:11:24,970
不可靠或者数据有问题

287
00:11:24,970 --> 00:11:26,589
，比如很难调试

288
00:11:26,589 --> 00:11:28,209
，所以我们要确保

289
00:11:28,209 --> 00:11:29,980
我们所做的更改是为了确保该

290
00:11:29,980 --> 00:11:33,850
查询是等效的，所以我想

291
00:11:33,850 --> 00:11:37,389
通过四个不同的示例来说明

292
00:11:37,389 --> 00:11:39,579
我们可以执行的逻辑查询优化类型

293
00:11:39,579 --> 00:11:42,639
，这实际上来自

294
00:11:42,639 --> 00:11:45,220
德国的超级家伙 Tom Thomas Norman，

295
00:11:45,220 --> 00:11:47,319
他实际上教了一整节课

296
00:11:47,319 --> 00:11:48,639
协调，他

297
00:11:48,639 --> 00:11:50,620
在多次讲座中的细节比

298
00:11:50,620 --> 00:11:53,199
我在四堂课中所能做的要多得多，但其中

299
00:11:53,199 --> 00:11:54,790
一些例子

300
00:11:54,790 --> 00:11:58,420
来自他的幻灯片，所以我们将看到我们

301
00:11:58,420 --> 00:12:00,699
如何对指挥谓词进行拆分

302
00:12:00,699 --> 00:12:03,160
谓词下推替换

303
00:12:03,160 --> 00:12:04,870
带连接的笛卡尔积，因为

304
00:12:04,870 --> 00:12:06,069
一开始我们所有的都是笛卡尔

305
00:12:06,069 --> 00:12:08,170
积，然后我们可以

306
00:12:08,170 --> 00:12:11,620
在投影下推过程中完成，所以对于

307
00:12:11,620 --> 00:12:12,759
这些我们将使用与上一堂课相同的

308
00:12:12,759 --> 00:12:14,110
例子

309
00:12:14,110 --> 00:12:17,350
清楚我们想要的 在艺术家之间进行三向连接

310
00:12:17,350 --> 00:12:20,050
出现一张专辑 很

311
00:12:20,050 --> 00:12:22,089
高兴找到出现

312
00:12:22,089 --> 00:12:27,100
在我的混音磁带上的所有艺术家 所以从一开始

313
00:12:27,100 --> 00:12:28,660
我们就可以摆脱束缚 呃

314
00:12:28,660 --> 00:12:30,160
，它本质上只是

315
00:12:30,160 --> 00:12:32,879
从续集解析器出来的内容的副本，

316
00:12:32,879 --> 00:12:35,740
我们所有的谓词都将

317
00:12:35,740 --> 00:12:39,309
组合在一起成为一个过滤器

318
00:12:39,309 --> 00:12:43,089
子句，所以

319
00:12:43,089 --> 00:12:45,250
我们的 where 子句中有三个谓词表达式，所以我们

320
00:12:45,250 --> 00:12:46,899
将有一个过滤器表达式

321
00:12:46,899 --> 00:12:49,059
我们的查询计划再次有一个逻辑

322
00:12:49,059 --> 00:12:50,170
查询计划 它没有告诉我们我们

323
00:12:50,170 --> 00:12:51,850
想要如何执行我们说过的任何事情 我们

324
00:12:51,850 --> 00:12:54,670
认为这里的单个过滤器将

325
00:12:54,670 --> 00:12:57,220
所有三个谓词相互组合

326
00:12:57,220 --> 00:12:59,709
，我们在采用笛卡尔乘积后执行该过滤器

327
00:12:59,709 --> 00:13:02,920


328
00:13:02,920 --> 00:13:06,490
所有三个表中的所有三个表，所以为了

329
00:13:06,490 --> 00:13:09,009
让我们更容易开始

330
00:13:09,009 --> 00:13:10,149


331
00:13:10,149 --> 00:13:12,819
对这些单独的

332
00:13:12,819 --> 00:13:14,470
谓词表达式的其他优化进行谓词下推，我们希望

333
00:13:14,470 --> 00:13:16,430
将过滤器分解为

334
00:13:16,430 --> 00:13:20,910
多个过滤器，每个过滤器都具有

335
00:13:20,910 --> 00:13:23,399
where 的一个连词 条款，

336
00:13:23,399 --> 00:13:26,430
所以我们只是在最后分割它，我们

337
00:13:26,430 --> 00:13:29,160
得到它像四个 ORS 这

338
00:13:29,160 --> 00:13:30,389
有点棘手

339
00:13:30,389 --> 00:13:31,620
如果你有

340
00:13:31,620 --> 00:13:34,110
不同的 co，你基本上可以开始复制 ORS  njunctions 结或

341
00:13:34,110 --> 00:13:35,879
否定或有点棘手，

342
00:13:35,879 --> 00:13:37,740
但关于高级思想的一点点

343
00:13:37,740 --> 00:13:40,800
基本上是相同的，所以

344
00:13:40,800 --> 00:13:43,019
现在我们有了这些这些过滤器，

345
00:13:43,019 --> 00:13:44,970
我们可以开始以

346
00:13:44,970 --> 00:13:46,319
不同的方式移动它们，我们可以开始将它们移动

347
00:13:46,319 --> 00:13:48,990
到 分别到

348
00:13:48,990 --> 00:13:51,870
查询计划的不同部分，所以这就是

349
00:13:51,870 --> 00:13:53,459
经典谓词下推的

350
00:13:53,459 --> 00:13:56,279
工作方式，这里的想法是我们

351
00:13:56,279 --> 00:14:00,240
可以移动我们必须

352
00:14:00,240 --> 00:14:03,810
在笛卡尔积之后或

353
00:14:03,810 --> 00:14:05,279
在最低点的谓词我们可以 在查询

354
00:14:05,279 --> 00:14:07,410
计划中，我们拥有

355
00:14:07,410 --> 00:14:10,800
我们需要的所有信息或

356
00:14:10,800 --> 00:14:13,230
过滤器在树中某个点需要的所有属性

357
00:14:13,230 --> 00:14:16,019


358
00:14:16,019 --> 00:14:17,670


359
00:14:17,670 --> 00:14:19,560


360
00:14:19,560 --> 00:14:20,399
我们的决定，

361
00:14:20,399 --> 00:14:22,680
但我们不能在任何一方之前做到这一点，

362
00:14:22,680 --> 00:14:25,439
因为我们没有这两个组合

363
00:14:25,439 --> 00:14:27,779
元组这两个元组在一起

364
00:14:27,779 --> 00:14:29,220
对于这里的这个来说是一样的但是在这种

365
00:14:29,220 --> 00:14:32,040
情况下专辑名称等于 Andes 混音

366
00:14:32,040 --> 00:14:34,850
我们 可以在扫描后立即将其

367
00:14:34,850 --> 00:14:38,100
放在专辑表上，因为我们拥有所需的

368
00:14:38,100 --> 00:14:42,689
所有信息，所以

369
00:14:42,689 --> 00:14:45,089
现在我们想用内部联接替换

370
00:14:45,089 --> 00:14:46,439
查询计划中的所有笛卡尔积

371
00:14:46,439 --> 00:14:49,980
，这非常

372
00:14:49,980 --> 00:14:51,029
简单，这是 只是

373
00:14:51,029 --> 00:14:53,339
确定哦，我们

374
00:14:53,339 --> 00:14:55,230
在它上面有一个笛卡尔积，我们有一个过滤器，

375
00:14:55,230 --> 00:14:56,699
它

376
00:14:56,699 --> 00:14:59,160
从左边的表格和右边的表格中获取笛卡尔积的输出

377
00:14:59,160 --> 00:15:00,240
并将它们

378
00:15:00,240 --> 00:15:01,680
组合在一起，或者你知道我们的质量

379
00:15:01,680 --> 00:15:03,540
匹配，所以我们可以

380
00:15:03,540 --> 00:15:04,920


381
00:15:04,920 --> 00:15:08,579
当连接时，用连接运算符中的 a 替换此处和此处的那些笛卡尔积，

382
00:15:08,579 --> 00:15:09,930
或者指定

383
00:15:09,930 --> 00:15:13,620
连接子句的位置，您

384
00:15:13,620 --> 00:15:15,269
知道您应该在它的正上方的过滤器，我们

385
00:15:15,269 --> 00:15:17,519
可以执行此操作，无论

386
00:15:17,519 --> 00:15:20,160
我们是否在 使用旧的旧式续集

387
00:15:20,160 --> 00:15:21,930
，其中连接实际上在 where

388
00:15:21,930 --> 00:15:25,110
子句中，或者使用一些更现代的续集

389
00:15:25,110 --> 00:15:27,930
语法，其中你有 join one

390
00:15:27,930 --> 00:15:31,050
子句，这是相同的想法

391
00:15:31,050 --> 00:15:34,560
在任何一个然后 t 中都有效

392
00:15:34,560 --> 00:15:37,560
我们可以应用的最后一个优化是进行投影后

393
00:15:37,560 --> 00:15:43,230
下推，因此在这种情况下，您

394
00:15:43,230 --> 00:15:45,870
知道梁我们在这里学究

395
00:15:45,870 --> 00:15:50,519
，您知道

396
00:15:50,519 --> 00:15:52,440
列存储中的任何查询计划将是什么样子，

397
00:15:52,440 --> 00:15:54,269
您可以

398
00:15:54,269 --> 00:15:57,089
以某种方式隐含地假设我没有

399
00:15:57,089 --> 00:15:58,380
在扫描我需要的两列中扫描整个元组名称，

400
00:15:58,380 --> 00:15:59,820
但您仍然需要

401
00:15:59,820 --> 00:16:01,440
一些信息说明实际上这些

402
00:16:01,440 --> 00:16:02,519
列实际上需要

403
00:16:02,519 --> 00:16:04,829
传播到查询计划中，因此在这种情况下

404
00:16:04,829 --> 00:16:07,380
，我们可以 认识到

405
00:16:07,380 --> 00:16:10,019
我们在树的不同级别实际上需要哪些属性，

406
00:16:10,019 --> 00:16:12,269
然后我们引入了投影

407
00:16:12,269 --> 00:16:16,740
投影算子，然后只

408
00:16:16,740 --> 00:16:20,279
传播我们

409
00:16:20,279 --> 00:16:22,350
在每一步需要的动作，所以你

410
00:16:22,350 --> 00:16:23,760
思考这个的方式隐含地

411
00:16:23,760 --> 00:16:28,410
在这里有管道断路器，我猜

412
00:16:28,410 --> 00:16:31,020
在上面，但就像在管道

413
00:16:31,020 --> 00:16:34,110
断路器上一样，我们将

414
00:16:34,110 --> 00:16:37,410
引入投影，以确保我们

415
00:16:37,410 --> 00:16:38,700
只传播实际需要的数据

416
00:16:38,700 --> 00:16:39,899
以及我们为什么要这样做的原因 不想

417
00:16:39,899 --> 00:16:42,000
做所有不同的部分，因为在

418
00:16:42,000 --> 00:16:43,350
管道中，如果你在做一个俯卧撑的

419
00:16:43,350 --> 00:16:47,820
方法，比如在 hyper 的情况下，

420
00:16:47,820 --> 00:16:49,140
你会选择一个元组

421
00:16:49,140 --> 00:16:51,420
并尽可能多地写

422
00:16:51,420 --> 00:16:53,190
出来 查询计划，

423
00:16:53,190 --> 00:16:54,600
只有当你到达管道断路器时才实现它，

424
00:16:54,600 --> 00:16:56,670
其他系统正在做的

425
00:16:56,670 --> 00:16:59,610
火山是自上而下的，

426
00:16:59,610 --> 00:17:01,520
而且边界不

427
00:17:01,520 --> 00:17:08,120
完全相同，

428
00:17:08,510 --> 00:17:10,980
再次在这里说 在这种

429
00:17:10,980 --> 00:17:13,679
情况下，我们只需要专辑名称

430
00:17:13,679 --> 00:17:16,050
和专辑 ID，因此我们可以在

431
00:17:16,050 --> 00:17:19,410
此处进行投影，以过滤掉我的

432
00:17:19,410 --> 00:17:21,720
D 现在名称，但同样会发生的是，

433
00:17:21,720 --> 00:17:23,069
此过滤器操作将

434
00:17:23,069 --> 00:17:25,559
在此处与此访问

435
00:17:25,559 --> 00:17:26,939
方法中的任何内容相结合，但是访问 元组

436
00:17:26,939 --> 00:17:30,990
再次我们不是我们没有

437
00:17:30,990 --> 00:17:32,520
我们可以写的任何地方的预测

438
00:17:32,520 --> 00:17:33,600
但是因为现在将

439
00:17:33,600 --> 00:17:36,740


440
00:17:36,809 --> 00:17:38,340
再次以这种方式隐式表示这些都是逻辑

441
00:17:38,340 --> 00:17:41,190
优化我没有看

442
00:17:41,190 --> 00:17:43,499
成本模型我只是说我知道 我

443
00:17:43,499 --> 00:17:45,080
想做一些事情 d 我可以

444
00:17:45,080 --> 00:17:48,419
在我的优化器中烘焙转换规则来

445
00:17:48,419 --> 00:17:50,700
做到这一点，就像这是最

446
00:17:50,700 --> 00:17:52,049
明显的，如果我有笛卡尔

447
00:17:52,049 --> 00:17:53,850
积并且我有一个过滤器，

448
00:17:53,850 --> 00:17:55,919
它上面有一个连接子句，那么我可以

449
00:17:55,919 --> 00:17:57,360
轻松地编写一个规则，结合

450
00:17:57,360 --> 00:17:58,980
那我不需要咨询成本

451
00:17:58,980 --> 00:18:02,429
模型因为我在我的数据中知道内

452
00:18:02,429 --> 00:18:05,100
连接总是比

453
00:18:05,100 --> 00:18:07,289
笛卡尔积更可取你绝对不能真的

454
00:18:07,289 --> 00:18:08,460
你永远不想退出笛卡尔

455
00:18:08,460 --> 00:18:10,200
积，除非你被明确

456
00:18:10,200 --> 00:18:13,289
告知要这样做 跨连接好的 现在让我们

457
00:18:13,289 --> 00:18:16,139
谈谈如何进行物理自由

458
00:18:16,139 --> 00:18:18,749
优化 所以现在我们

459
00:18:18,749 --> 00:18:20,549
有了一个逻辑查询计划 我们有这些

460
00:18:20,549 --> 00:18:22,320
逻辑运算符 我们想

461
00:18:22,320 --> 00:18:24,629
将它们转换成物理运算

462
00:18:24,629 --> 00:18:26,639
符 如果我们正在做，我们可以要么 koujun

463
00:18:26,639 --> 00:18:28,679
编译或

464
00:18:28,679 --> 00:18:33,090
在我们的执行引擎中实际执行，所以

465
00:18:33,090 --> 00:18:34,080
我们想要做的转换类型

466
00:18:34,080 --> 00:18:35,940
是什么，最明显的

467
00:18:35,940 --> 00:18:38,129
将是指定

468
00:18:38,129 --> 00:18:40,139
我们实际将如何访问 t 能够

469
00:18:40,139 --> 00:18:42,330
或数据以及我们的目标，但

470
00:18:42,330 --> 00:18:44,100
我将使用顺序扫描但我们

471
00:18:44,100 --> 00:18:46,799
需要索引扫描，如果它是索引

472
00:18:46,799 --> 00:18:48,149
扫描那么我们将选择哪个索引

473
00:18:48,149 --> 00:18:50,220
我们可以添加

474
00:18:50,220 --> 00:18:52,950
关于我们期望的附加执行信息

475
00:18:52,950 --> 00:18:55,019
数据并被表示、排序或

476
00:18:55,019 --> 00:18:58,230
压缩 选择运营商

477
00:18:58,230 --> 00:18:59,700
邀请加入我们就像我们是联合专辑 我们

478
00:18:59,700 --> 00:19:01,019
想要使用我们如何实际进行

479
00:19:01,019 --> 00:19:03,240
聚合 然后在某些

480
00:19:03,240 --> 00:19:05,240
情况下我们今天不会谈论的是

481
00:19:05,240 --> 00:19:07,350
确定何时 您实际上

482
00:19:07,350 --> 00:19:11,129
希望潜在地具体化查询一部分的数据，

483
00:19:11,129 --> 00:19:13,889
以便

484
00:19:13,889 --> 00:19:15,509
您知道

485
00:19:15,509 --> 00:19:16,980
查询计划的另一部分可以实际访问它的另一部分我

486
00:19:16,980 --> 00:19:20,330
可以执行此子查询或视图或

487
00:19:20,330 --> 00:19:25,049
城市，因此在此阶段，我们现在需要

488
00:19:25,049 --> 00:19:26,970
确保我们或我们现在必须

489
00:19:26,970 --> 00:19:29,730
支持成本模型估计，因为现在

490
00:19:29,730 --> 00:19:31,889
我们希望能够确定一个

491
00:19:31,889 --> 00:19:33,690
物理计划是否会比另一个更好，

492
00:19:33,690 --> 00:19:35,039
并且成本模型将

493
00:19:35,039 --> 00:19:39,480
允许我们在我们开始之前这样做

494
00:19:39,480 --> 00:19:44,070
更深入地了解我

495
00:19:44,070 --> 00:19:46,350
想谈谈的 Cascades 以及我们

496
00:19:46,350 --> 00:19:49,230
实际上将如何进行

497
00:19:49,230 --> 00:19:52,769
这些物理转换

498
00:19:52,769 --> 00:19:54,389


499
00:19:54,389 --> 00:19:57,000


500
00:19:57,000 --> 00:20:00,510
总是

501
00:20:00,510 --> 00:20:03,389
在做厄瓜多尔人或内部内部内部

502
00:20:03,389 --> 00:20:07,380
内部连接的事情，

503
00:20:07,380 --> 00:20:09,480
但当你开始知道时变得更加棘手，

504
00:20:09,480 --> 00:20:11,070
因为你看到更现实的查询

505
00:20:11,070 --> 00:20:13,769
外连接半连接或安吉连接，

506
00:20:13,769 --> 00:20:15,840
因为现在我们并不总是

507
00:20:15,840 --> 00:20:18,149
能够进行对称

508
00:20:18,149 --> 00:20:20,639
转换 允许我们

509
00:20:20,639 --> 00:20:23,399
在您周围移动任何操作 轻松了解或重新排序

510
00:20:23,399 --> 00:20:26,490
我们的查询计划 因为

511
00:20:26,490 --> 00:20:30,389
在某些情况下，您

512
00:20:30,389 --> 00:20:31,409
实际上不允许这样做，因为这

513
00:20:31,409 --> 00:20:34,230
最终会导致不正确的查询或

514
00:20:34,230 --> 00:20:37,320
不正确的结果，所以让我们

515
00:20:37,320 --> 00:20:39,419
举个例子，所以再说一遍我现在正在做

516
00:20:39,419 --> 00:20:41,610
我在 B 和 C 上做三向连接，

517
00:20:41,610 --> 00:20:43,740
但我要在 a 和 B 上做一个左外连接

518
00:20:43,740 --> 00:20:47,000
，然后在 C 上做一个完整的外连接

519
00:20:47,000 --> 00:20:50,519
我们是什么 现在开始是我们如何

520
00:20:50,519 --> 00:20:51,899
实际探索查询计划中可用的不同连接

521
00:20:51,899 --> 00:20:53,909
顺序，

522
00:20:53,909 --> 00:20:56,399
以便我们可以决定是

523
00:20:56,399 --> 00:20:58,710
先连接 B 和 C 还是先连接 A 和 C

524
00:20:58,710 --> 00:21:01,590
等等，如我们所见和

525
00:21:01,590 --> 00:21:04,580
系统 R 但在 在这个特定的例子

526
00:21:04,580 --> 00:21:07,289
中，实际上我们没有实际可用的联合排序，

527
00:21:07,289 --> 00:21:08,519


528
00:21:08,519 --> 00:21:10,380
因为这最终会导致

529
00:21:10,380 --> 00:21:12,210
不正确的状态，这是因为我们

530
00:21:12,210 --> 00:21:13,669
有这些外连接，

531
00:21:13,669 --> 00:21:18,210
所以特别是 a 和

532
00:21:18,210 --> 00:21:20,610
B 上的外连接，左外连接 a 和 B 在

533
00:21:20,610 --> 00:21:22,830
没有外连接的情况下不是可交换的，

534
00:21:22,830 --> 00:21:25,200
四个外连接以及 B 和 C 因为我

535
00:21:25,200 --> 00:21:28,169
不知道从

536
00:21:28,169 --> 00:21:30,630
这个关节中出来的 B 的值对于 V 点 Val 来说是什么

537
00:21:30,630 --> 00:21:34,320
，以便将它与 C 连接，所以我必须

538
00:21:34,320 --> 00:21:36,630
执行 这首先是因为他们不

539
00:21:36,630 --> 00:21:38,039
知道它是真实值

540
00:21:38,039 --> 00:21:41,490
还是空值，因为存在左

541
00:21:41,490 --> 00:21:44,970
外连接 如果 de ID

542
00:21:44,970 --> 00:21:47,340
与 be de ID 不匹配，那么

543
00:21:47,340 --> 00:21:49,799
组合元组中的 B 部分将是

544
00:21:49,799 --> 00:21:52,679
null 和 B 点 val 可能是 此处为 null，

545
00:21:52,679 --> 00:21:55,529
但我不知道，直到我实际

546
00:21:55,529 --> 00:21:59,070
执行此连接，因此当我们

547
00:21:59,070 --> 00:22:00,629
开始执行这些连接重新

548
00:22:00,629 --> 00:22:01,889
排序行星磨损时，您需要一种方法查看

549
00:22:01,889 --> 00:22:02,559
不同的可能

550
00:22:02,559 --> 00:22:04,749
选择，以注意在

551
00:22:04,749 --> 00:22:06,759
某些情况下我可以” 不进行

552
00:22:06,759 --> 00:22:08,980
重新排序，我现在提出这个问题，

553
00:22:08,980 --> 00:22:10,539
因为我将展示一些例子

554
00:22:10,539 --> 00:22:12,909
，我们假设你一切都是

555
00:22:12,909 --> 00:22:14,049
可交换的你假设一切

556
00:22:14,049 --> 00:22:16,509
都可以翻转但只是在

557
00:22:16,509 --> 00:22:19,080
你的脑海中被认识到哦，

558
00:22:19,080 --> 00:22:21,519
有 我们需要一个额外的机制

559
00:22:21,519 --> 00:22:23,620
来确保我们不会

560
00:22:23,620 --> 00:22:25,600
错误地重新排序动态

561
00:22:25,600 --> 00:22:27,580
编程更容易做到

562
00:22:27,580 --> 00:22:29,129
这一点，因为您拥有明确的

563
00:22:29,129 --> 00:22:31,539
显式图形，您知道

564
00:22:31,539 --> 00:22:34,509
可以在以下

565
00:22:34,509 --> 00:22:36,610
情况下移动事物 级联尽我所知，

566
00:22:36,610 --> 00:22:38,019
您需要有额外的财产

567
00:22:38,019 --> 00:22:41,019
执法人员才能认识到这种

568
00:22:41,019 --> 00:22:46,299
重新排序是无效的，因此我们

569
00:22:46,299 --> 00:22:48,879
将在高层次上枚举不同计划

570
00:22:48,879 --> 00:22:50,080
的方式有两种不同的

571
00:22:50,080 --> 00:22:51,940
方法这是转换

572
00:22:51,940 --> 00:22:54,429
方法，您采用现有计划

573
00:22:54,429 --> 00:22:56,409
并开始以不同方式排列它

574
00:22:56,409 --> 00:22:58,149
以生成

575
00:22:58,149 --> 00:22:59,740
彼此等效的新计划您

576
00:22:59,740 --> 00:23:03,309
应该检查以确保您检查

577
00:23:03,309 --> 00:23:04,690
以确保

578
00:23:04,690 --> 00:23:08,019
正在执行的转换是 有效，它几乎有点

579
00:23:08,019 --> 00:23:09,970
像随机游走，除了你有

580
00:23:09,970 --> 00:23:11,950
这些规则来应用它们并改变

581
00:23:11,950 --> 00:23:16,090
事物，并且以一种有针对性的方式，

582
00:23:16,090 --> 00:23:19,320
另一种方法是在

583
00:23:19,320 --> 00:23:22,379
遗传程序方法中使用的，

584
00:23:22,379 --> 00:23:25,929
你在开始的地方进行生成枚举

585
00:23:25,929 --> 00:23:28,809
您将

586
00:23:28,809 --> 00:23:30,220
要执行的查询部分作为构建

587
00:23:30,220 --> 00:23:31,960
块，然后开始单独绘制它们

588
00:23:31,960 --> 00:23:33,820
并构建查询计划，并且

589
00:23:33,820 --> 00:23:36,730
可以注意您不想

590
00:23:36,730 --> 00:23:38,440
错误地添加内容以生成无效的

591
00:23:38,440 --> 00:23:40,119
查询计划，但您进行排序 从

592
00:23:40,119 --> 00:23:42,179
一无所有开始添加东西，

593
00:23:42,179 --> 00:23:45,070
所以不要说一种方式比另一种方式更好，

594
00:23:45,070 --> 00:23:46,480
但这些只是在

595
00:23:46,480 --> 00:23:48,279
高层次上我们可以使用的两种方法 ld

596
00:23:48,279 --> 00:23:54,399


597
00:23:54,399 --> 00:23:55,840
在学术上追求最先进的动态

598
00:23:55,840 --> 00:23:58,690
编程方法是在 hyper 中使用的方法，在

599
00:23:58,690 --> 00:24:03,840
那里你正在做某种超图

600
00:24:03,860 --> 00:24:09,270
超图生成，从你开始

601
00:24:09,270 --> 00:24:11,309
，你知道这是

602
00:24:11,309 --> 00:24:12,480
你开始添加构建块

603
00:24:12,480 --> 00:24:14,190
的一般方法 一个接一个的查询，你正在

604
00:24:14,190 --> 00:24:15,809
检查

605
00:24:15,809 --> 00:24:17,280
你想通过添加一个

606
00:24:17,280 --> 00:24:21,179
片段进行的更改是否有效，所以

607
00:24:21,179 --> 00:24:22,380
这是使用 hyper 的方法，这是

608
00:24:22,380 --> 00:24:24,150
你在鸭子 TB 中使用的方法，我

609
00:24:24,150 --> 00:24:27,500
不” 不知道使用这种方法的任何商业系统，

610
00:24:27,500 --> 00:24:30,960
超级家伙

611
00:24:30,960 --> 00:24:32,400
可能知道，但我不知道

612
00:24:32,400 --> 00:24:38,850
我们在我们的系统中的答案，尽管我们

613
00:24:38,850 --> 00:24:40,800
基于 Cascades 所以我将花

614
00:24:40,800 --> 00:24:42,809
更多的时间来讨论这个问题 我

615
00:24:42,809 --> 00:24:44,490
说有一篇 1995 年的原始级联

616
00:24:44,490 --> 00:24:47,940
论文，但我没有让你们

617
00:24:47,940 --> 00:24:49,500
阅读它，因为就像我说的，我

618
00:24:49,500 --> 00:24:51,059
认为它不是很好，并不是因为它

619
00:24:51,059 --> 00:24:53,429
在英语语法方面写得不好，

620
00:24:53,429 --> 00:24:54,300


621
00:24:54,300 --> 00:24:56,850
我只是不知道 从

622
00:24:56,850 --> 00:24:58,530
peda 开始思考 这门课程的gogical观点

623
00:24:58,530 --> 00:25:00,809
它清楚地解释了

624
00:25:00,809 --> 00:25:02,760
Cascades实际上在做什么所以这就是为什么

625
00:25:02,760 --> 00:25:04,679
我让你们阅读硕士

626
00:25:04,679 --> 00:25:06,000
论文因为我可能会得到我的意见

627
00:25:06,000 --> 00:25:08,120
这是对Cascades的最好解释

628
00:25:08,120 --> 00:25:11,370
所以什么是Cascades以及我们上一堂课

629
00:25:11,370 --> 00:25:12,929
讨论过的 火山，这是一种

630
00:25:12,929 --> 00:25:15,809
自上而下的方法，用于

631
00:25:15,809 --> 00:25:18,860
添加添加

632
00:25:18,860 --> 00:25:21,960
构建查询计划的山地搜索分支 Cascades

633
00:25:21,960 --> 00:25:25,410
是一种由 grits Grats 构建的第三代优化

634
00:25:25,410 --> 00:25:28,050
器，还有

635
00:25:28,050 --> 00:25:30,360
一种这种

636
00:25:30,360 --> 00:25:31,860
状态的 -我们

637
00:25:31,860 --> 00:25:34,410
根据我所知道的发送的艺术方法，所以

638
00:25:34,410 --> 00:25:35,490
我们将在

639
00:25:35,490 --> 00:25:38,340
Cascades 中做的与在火山中没有做的最大不同

640
00:25:38,340 --> 00:25:42,929
在于我们将优化器

641
00:25:42,929 --> 00:25:45,179
将生成转换

642
00:25:45,179 --> 00:25:48,240
当我们搜索查询计划时，它需要它们而不是

643
00:25:48,240 --> 00:25:49,710
预先计算

644
00:25:49,710 --> 00:25:51,990
我们进入的每个级别的所有可能的转换，

645
00:25:51,990 --> 00:25:54,990


646
00:25:54,990 --> 00:25:57,030
所以在火山的情况下

647
00:25:57,030 --> 00:25:59,250
发生的事情是当我从一个

648
00:25:59,250 --> 00:26:01,230


649
00:26:01,230 --> 00:26:04,500
在我对可能的转换进行任何评估之前，分组到树中的下一个级别

650
00:26:04,500 --> 00:26:05,700
我可以

651
00:26:05,700 --> 00:26:07,860
进行每个我可以应用的转换 我

652
00:26:07,860 --> 00:26:09,920
生成了所有可能的转换

653
00:26:09,920 --> 00:26:14,029
，这将正确地爆炸搜索基础

654
00:26:14,029 --> 00:26:15,979
，也许可能陷入困境

655
00:26:15,979 --> 00:26:17,719
的情况 局部最小值，并没有

656
00:26:17,719 --> 00:26:19,700
更仔细地探索树的其余部分，

657
00:26:19,700 --> 00:26:23,749
所以我们将能够在级联中做的另一件很酷的事情

658
00:26:23,749 --> 00:26:24,999
是我们将能够

659
00:26:24,999 --> 00:26:27,830


660
00:26:27,830 --> 00:26:35,149
对多个问题进行简单的重写

661
00:26:35,149 --> 00:26:36,590
或

662
00:26:36,590 --> 00:26:39,469
查询计划中的表达式，但具有这些功能

663
00:26:39,469 --> 00:26:41,179
并且能够应用它们而

664
00:26:41,179 --> 00:26:44,479
无需详尽搜索

665
00:26:44,479 --> 00:26:47,059
如何执行

666
00:26:47,059 --> 00:26:48,950
更有意义的多表达式的所有可能组合

667
00:26:48,950 --> 00:26:50,539
，如果您想要更多

668
00:26:50,539 --> 00:26:52,549
幻灯片，基本思想 这就像我可以有

669
00:26:52,549 --> 00:26:55,190
一个占位符来说明这

670
00:26:55,190 --> 00:26:57,679
是树的较低部分我不知道

671
00:26:57,679 --> 00:26:59,479
我将如何实际实现它但

672
00:26:59,479 --> 00:27:00,979
我现在不需要搜索它我可以

673
00:27:00,979 --> 00:27:03,859
搜索 树的其他方面并使用

674
00:27:03,859 --> 00:27:08,629
该放置顺序没问题，

675
00:27:08,629 --> 00:27:12,799
所以对于 Cascades

676
00:27:12,799 --> 00:27:16,609
，人们首先使用的四种主要设计思想

677
00:27:16,609 --> 00:27:19,879
是，当您包含模式时，所有所有

678
00:27:19,879 --> 00:27:21,769
优化都将是简单的

679
00:27:21,769 --> 00:27:24,710
数据结构对

680
00:27:24,710 --> 00:27:26,210
你想在

681
00:27:26,210 --> 00:27:29,210
你的查询计划中匹配，然后如果它匹配，

682
00:27:29,210 --> 00:27:32,269
就会有一个规则来进行

683
00:27:32,269 --> 00:27:34,639
某种转换，他们将此与

684
00:27:34,639 --> 00:27:36,729


685
00:27:36,729 --> 00:27:39,349
在其他系统中使用 Postgres 的基于启发式的方法进行对比，我们

686
00:27:39,349 --> 00:27:40,700
有一堆 if-then-  else

687
00:27:40,700 --> 00:27:43,639
语句总是这些规则，你知道

688
00:27:43,639 --> 00:27:45,169
有一个规则，

689
00:27:45,169 --> 00:27:47,359
然后有然后是好的，有

690
00:27:47,359 --> 00:27:48,499
模式，然后有一个规则

691
00:27:48,499 --> 00:27:50,539
进行转换，我可以

692
00:27:50,539 --> 00:27:52,639
从逻辑、逻辑、逻辑

693
00:27:52,639 --> 00:27:55,479
和逻辑物理来做到这一点。 同样

694
00:27:55,479 --> 00:27:57,889
的下一件事是，将制定规则

695
00:27:57,889 --> 00:28:01,519
来强制执行

696
00:28:01,519 --> 00:28:04,159
您对数据的属性要求，或者如果它们是

697
00:28:04,159 --> 00:28:05,929
产生的敌人结果但给

698
00:28:05,929 --> 00:28:07,609
操作员，这些是

699
00:28:07,609 --> 00:28:12,619
诸如排序顺序关心

700
00:28:12,619 --> 00:28:13,909
压缩之类的事情，

701
00:28:13,909 --> 00:28:15,889
就像我们可以负担得起这些事情一样，

702
00:28:15,889 --> 00:28:17,839
然后规则引擎知道它可以

703
00:28:17,839 --> 00:28:21,109
应用转换，如果转换

704
00:28:21,109 --> 00:28:22,759
最终会违反必须遵守的规则

705
00:28:22,759 --> 00:28:25,549
为了保持

706
00:28:25,549 --> 00:28:26,989
这一点并将其与我们的方法进行对比，在我们的

707
00:28:26,989 --> 00:28:27,810
方法中，我

708
00:28:27,810 --> 00:28:31,140
说进行枚举

709
00:28:31,140 --> 00:28:32,820
或搜索联合排序的规则

710
00:28:32,820 --> 00:28:36,030
没有数据的这些物理属性的概念，

711
00:28:36,030 --> 00:28:38,220
它必须全部

712
00:28:38,220 --> 00:28:40,050
纳入成本模型，但现在 再次在一个

713
00:28:40,050 --> 00:28:42,420
地方，我可以定义我的规则，说我的

714
00:28:42,420 --> 00:28:43,980
数据必须以这种方式排序，并

715
00:28:43,980 --> 00:28:45,480
确保您不进行

716
00:28:45,480 --> 00:28:48,960
违反下一件事的转换

717
00:28:48,960 --> 00:28:52,760
，然后我们现在还可以定义

718
00:28:52,760 --> 00:28:55,380
优先级或排序

719
00:28:55,380 --> 00:28:58,320
我们根据这些承诺应用的规则，

720
00:28:58,320 --> 00:29:00,900
所以考虑这个的方式

721
00:29:00,900 --> 00:29:04,590
是，我们可以指定我们可以指定，而不是随机

722
00:29:04,590 --> 00:29:06,180
选择我们

723
00:29:06,180 --> 00:29:08,280
想要在树中给定级别应用的传输转换

724
00:29:08,280 --> 00:29:11,310
fy an or 我们甚至

725
00:29:11,310 --> 00:29:13,830
会得到实际的动态，以便

726
00:29:13,830 --> 00:29:16,770
我们可以识别查询计划的各个方面，

727
00:29:16,770 --> 00:29:18,960
并说我们认为这些转换

728
00:29:18,960 --> 00:29:20,160
将引导我们更快地找到最佳计划，

729
00:29:20,160 --> 00:29:22,140
因此首先应用这些转换

730
00:29:22,140 --> 00:29:24,540
，如果我们只评估其他转换

731
00:29:24,540 --> 00:29:26,580
有更多时间并希望

732
00:29:26,580 --> 00:29:28,230
继续在树中的该级别进行搜索，

733
00:29:28,230 --> 00:29:31,380
最后一个重要

734
00:29:31,380 --> 00:29:32,730
的是他们将

735
00:29:32,730 --> 00:29:36,120
谓词视为系统中的一流实体，

736
00:29:36,120 --> 00:29:38,130
这将允许我们

737
00:29:38,130 --> 00:29:40,560
对它们进行转换，就像 我们

738
00:29:40,560 --> 00:29:43,320
会为操作符做这就是

739
00:29:43,320 --> 00:29:44,670
我们将如何做我

740
00:29:44,670 --> 00:29:45,960
在开始时展示的所有事情，比如谓词

741
00:29:45,960 --> 00:29:50,070
下推投影下推

742
00:29:50,070 --> 00:29:52,560
等等，因为谓词

743
00:29:52,560 --> 00:29:54,960
推一个例子，因为那些再次，

744
00:29:54,960 --> 00:29:56,640
即使它们就像谓词

745
00:29:56,640 --> 00:29:58,590
在 where 子句中，通常会

746
00:29:58,590 --> 00:30:00,690
像 select 语句

747
00:30:00,690 --> 00:30:03,510
或 sorry scan 运算符一样被烘烤，我们可以让我们

748
00:30:03,510 --> 00:30:05,970
的引擎对它们进行转换

749
00:30:05,970 --> 00:30:08,220
并进行其他优化

750
00:30:08,220 --> 00:30:10,170
它将与物理逻辑

751
00:30:10,170 --> 00:30:11,910
运算符一起使用，这实际上是

752
00:30:11,910 --> 00:30:13,380
我们现在正在尝试在我们自己的系统中构建的东西

753
00:30:13,380 --> 00:30:16,440
我们在去年 7:21 有一个项目

754
00:30:16,440 --> 00:30:18,960
，他们

755
00:30:18,960 --> 00:30:21,990
使用我们的级联引擎和

756
00:30:21,990 --> 00:30:24,030
已经工作的学生构建了一个表达式重写器

757
00:30:24,030 --> 00:30:25,140
去年现在又在今年工作，

758
00:30:25,140 --> 00:30:27,780
以帮助完成将其移植到

759
00:30:27,780 --> 00:30:29,880
新系统中，所以我们今天不会谈论

760
00:30:29,880 --> 00:30:31,200
这个，但允许做某些

761
00:30:31,200 --> 00:30:33,660
事情，例如如果我有一个 where 子句

762
00:30:33,660 --> 00:30:36,750
说明 where 1 equals  1 我们可以

763
00:30:36,750 --> 00:30:38,210
将其重写

764
00:30:38,210 --> 00:30:41,960
为 true，而不必

765
00:30:41,960 --> 00:30:45,169
评估查询树，现在我们使用 LLVM

766
00:30:45,169 --> 00:30:47,299
编译它对每个元组都很整洁，

767
00:30:47,299 --> 00:30:49,369
因此阿拉巴马州编译器可以

768
00:30:49,369 --> 00:30:52,220
通过进行常量折叠轻松地消除它，

769
00:30:52,220 --> 00:30:54,559
但这些是

770
00:30:54,559 --> 00:30:56,720
我们现在可以做的事情虽然在

771
00:30:56,720 --> 00:30:58,399
我们通常用于优化查询树的同一个级联框架中，

772
00:30:58,399 --> 00:31:03,409


773
00:31:03,409 --> 00:31:05,389
所以我们要谈论的第一件事

774
00:31:05,389 --> 00:31:08,029
是理解级联是什么是

775
00:31:08,029 --> 00:31:10,369
表达式，所以这个标准 这有点

776
00:31:10,369 --> 00:31:12,980
令人困惑，因为通常我一直

777
00:31:12,980 --> 00:31:14,929
在根据

778
00:31:14,929 --> 00:31:17,539
where

779
00:31:17,539 --> 00:31:20,360
子句或 join 子句或选择

780
00:31:20,360 --> 00:31:23,059
输出中的谓词来讨论表达式，当然在

781
00:31:23,059 --> 00:31:25,009
我们系统的代码中，我们使用表达式来表示

782
00:31:25,009 --> 00:31:27,320
没有像这样处理的表达式 one

783
00:31:27,320 --> 00:31:29,960
等于 one 之类的，但是在

784
00:31:29,960 --> 00:31:32,240
级联中，他们将

785
00:31:32,240 --> 00:31:36,950


786
00:31:36,950 --> 00:31:39,110
在我们的系统或查询计划中将表达式声明为高级操作或运算符

787
00:31:39,110 --> 00:31:42,679
，该查询计划将具有零个

788
00:31:42,679 --> 00:31:46,249
或多个或输入表达式，所以

789
00:31:46,249 --> 00:31:48,139
说我有 我的查询在这里是

790
00:31:48,139 --> 00:31:52,519
一个从 B 和 C 连接在一起的选择星，就像我

791
00:31:52,519 --> 00:31:55,009
有一个逻辑表达式，它是

792
00:31:55,009 --> 00:31:57,769
a 和 B 上的连接

793
00:31:57,769 --> 00:32:00,139
，然后是 C 上的连接，然后我可以有一个物理

794
00:32:00,139 --> 00:32:02,480
表达式，它是 scruncher

795
00:32:02,480 --> 00:32:04,850
扫描 a 在 b 上的顺序扫描上的哈希连接期间

796
00:32:04,850 --> 00:32:07,070
，然后

797
00:32:07,070 --> 00:32:11,679
在 c 上的索引扫描上执行 sa 循环连接，因此

798
00:32:11,679 --> 00:32:15,940
它的表达式将是一些

799
00:32:15,940 --> 00:32:18,549
本质上是查询的关系代数

800
00:32:18,549 --> 00:32:21,679
组件，但如果我

801
00:32:21,679 --> 00:32:23,059
注释它们 使用这些下

802
00:32:23,059 --> 00:32:24,619
标中的这些下标，我指定了

803
00:32:24,619 --> 00:32:26,600
我想

804
00:32:26,600 --> 00:32:29,240
在关系

805
00:32:29,240 --> 00:32:33,559
运算符之前使用

806
00:32:33,559 --> 00:32:37,070


807
00:32:37,070 --> 00:32:39,529


808
00:32:39,529 --> 00:32:41,210
的物理运算符来执行该操作

809
00:32:41,210 --> 00:32:42,350
这只是一个逻辑运算符，

810
00:32:42,350 --> 00:32:44,029
逻辑上它们是等价的，

811
00:32:44,029 --> 00:32:46,429
它们都在计算 ab 和 c 上的连接

812
00:32:46,429 --> 00:32:48,740
，所以现在我们将

813
00:32:48,740 --> 00:32:51,450
能够依靠这个社区属性

814
00:32:51,450 --> 00:32:52,950
来枚举所有不同的连接

815
00:32:52,950 --> 00:32:55,049
环作为转换的一部分 使用

816
00:32:55,049 --> 00:32:58,559


817
00:32:58,559 --> 00:33:00,840
此查询计划探索搜索库并尝试找到一个您

818
00:33:00,840 --> 00:33:03,000
知道的最佳搜索库，这

819
00:33:03,000 --> 00:33:04,380
就是我之前在我们

820
00:33:04,380 --> 00:33:06,389
谈论遗漏决斗 400 或示例时所说的，

821
00:33:06,389 --> 00:33:08,760
因此在这种情况下我可以移动

822
00:33:08,760 --> 00:33:11,010
无论如何，这些电影操作符都是向下的，

823
00:33:11,010 --> 00:33:13,470
因为它们是可交换的，但是如果我

824
00:33:13,470 --> 00:33:15,389
其中一个正在执行左外连接

825
00:33:15,389 --> 00:33:17,549
或执行操作，那么我将不得不

826
00:33:17,549 --> 00:33:19,350
限制转换以确保我

827
00:33:19,350 --> 00:33:22,350
d  o 事情按正确的顺序，但为了

828
00:33:22,350 --> 00:33:24,149
简单起见，在我们的例子中，我们不会

829
00:33:24,149 --> 00:33:28,769
担心，所以现在

830
00:33:28,769 --> 00:33:30,330
我们有了表达式，这

831
00:33:30,330 --> 00:33:32,820
将是一些序列或一些

832
00:33:32,820 --> 00:33:35,970
关系代数表达式，现在我们

833
00:33:35,970 --> 00:33:38,700
要定义组，所以 group

834
00:33:38,700 --> 00:33:41,399
将是一个表达式的逻辑等效

835
00:33:41,399 --> 00:33:44,789
逻辑和物理表达式的集合

836
00:33:44,789 --> 00:33:47,429
，该表达式将在

837
00:33:47,429 --> 00:33:52,110
相同的输出表达式中产生正确的所有

838
00:33:52,110 --> 00:33:54,210
逻辑形式，特别是对于

839
00:33:54,210 --> 00:33:55,710
给定的表达式将具有所有逻辑

840
00:33:55,710 --> 00:33:57,720
形式，它将

841
00:33:57,720 --> 00:34:00,110
具有我们的所有物理表达式 可以通过

842
00:34:00,110 --> 00:34:03,090
将任何逻辑运算

843
00:34:03,090 --> 00:34:05,820
符从相应的逻辑形式转换为允许的物理运算符来推导，

844
00:34:05,820 --> 00:34:09,359
所以我的

845
00:34:09,359 --> 00:34:11,429
意思是这个所以这里的整个单元

846
00:34:11,429 --> 00:34:14,339
是一个组，这个组代表连接的

847
00:34:14,339 --> 00:34:18,739
输出表达式

848
00:34:18,739 --> 00:34:21,929
，然后我们有 逻辑和

849
00:34:21,929 --> 00:34:23,460
物理表达式都

850
00:34:23,460 --> 00:34:26,310
将等同于这里的输出

851
00:34:26,310 --> 00:34:30,418
表达式，所以

852
00:34:30,418 --> 00:34:33,030
组的内容将 根据它的

853
00:34:33,030 --> 00:34:36,239
输出查找，所以我不能有另一个

854
00:34:36,239 --> 00:34:39,389
具有相同输出的组，它让

855
00:34:39,389 --> 00:34:41,940
我独一无二地执行 Mike 我的查询计划，

856
00:34:41,940 --> 00:34:44,310
所以我很重要的是要注意

857
00:34:44,310 --> 00:34:47,389
这里的这些表达式是无序的，

858
00:34:47,389 --> 00:34:50,780
这意味着

859
00:34:51,649 --> 00:34:53,460


860
00:34:53,460 --> 00:34:54,149
它们中包含什么，

861
00:34:54,149 --> 00:34:56,429
但仅仅因为这是第一个

862
00:34:56,429 --> 00:34:58,500
并不意味着我们是否

863
00:34:58,500 --> 00:35:00,089
应该首先检查这个

864
00:35:00,089 --> 00:35:02,640
隐含的或作为优先级的一部分计算出来的，

865
00:35:02,640 --> 00:35:04,470
你会得到

866
00:35:04,470 --> 00:35:07,530
你的转换

867
00:35:07,530 --> 00:35:08,730
他们还指出的另一个重要的事情是 正如我

868
00:35:08,730 --> 00:35:12,390
在此输出表达式的火山情况下所说的那样，

869
00:35:12,390 --> 00:35:14,520
他们必须

870
00:35:14,520 --> 00:35:16,920


871
00:35:16,920 --> 00:35:18,660
生成许多表达式的所有可能的所有可能的排列，并以

872
00:35:18,660 --> 00:35:20,820
所有可能的排列为特征

873
00:35:20,820 --> 00:35:23,490
级联中的过滤器表达式 这些

874
00:35:23,490 --> 00:35:25,680
有点像你知道这些是

875
00:35:25,680 --> 00:35:28,050
计算出来的 按需或及时，

876
00:35:28,050 --> 00:35:31,020
这样我就不必在特征中实现每一个

877
00:35:31,020 --> 00:35:32,580
可能的逻辑表达，

878
00:35:32,580 --> 00:35:34,230


879
00:35:34,230 --> 00:35:36,960
我可以做到的每一个可能的物理表达 是的，我可以应用我的转换

880
00:35:36,960 --> 00:35:39,869
规则，它会生成一些设备

881
00:35:39,869 --> 00:35:41,760
逻辑表达式，我可以确定

882
00:35:41,760 --> 00:35:43,320
我是否甚至将它们进一步分解并

883
00:35:43,320 --> 00:35:44,640
查看它们的物理表达式

884
00:35:44,640 --> 00:35:49,590


885
00:35:49,590 --> 00:35:52,230


886
00:35:52,230 --> 00:35:54,810
火山，因为他们同时做这一切，

887
00:35:54,810 --> 00:35:57,510
你在这里代表的状态量

888
00:35:57,510 --> 00:35:59,250
变得非常大，

889
00:35:59,250 --> 00:36:02,550
所以按需的事情是

890
00:36:02,550 --> 00:36:04,619
我们要以这种方式加快速度以

891
00:36:04,619 --> 00:36:06,480
减少该状态，但另一种

892
00:36:06,480 --> 00:36:09,270
优化 我们在 Cascades 中可以做的是

893
00:36:09,270 --> 00:36:10,710
使用所谓的多表达式

894
00:36:10,710 --> 00:36:13,230
，这里的想法是，

895
00:36:13,230 --> 00:36:16,410
不是为给定组精确实例

896
00:36:16,410 --> 00:36:19,770
化所有可能表达式的详细形式，

897
00:36:19,770 --> 00:36:22,290
而是可以

898
00:36:22,290 --> 00:36:26,550
用

899
00:36:26,550 --> 00:36:30,000
表达式作为占位符来表示 sum 子表达式 然后

900
00:36:30,000 --> 00:36:32,490
由

901
00:36:32,490 --> 00:36:36,000
查询计划中较低的某个组表示或处理，因此

902
00:36:36,000 --> 00:36:40,140
它们

903
00:36:40,140 --> 00:36:43,050
由一组中的这些占位符表示的冗余表达式

904
00:36:43,050 --> 00:36:44,640
集被称为 d 被称为

905
00:36:44,640 --> 00:36:48,000
多表达式，所以在这种情况下

906
00:36:48,000 --> 00:36:51,359
，在我说 join B join C 之前

907
00:36:51,359 --> 00:36:53,430
，它明确说嘿我要

908
00:36:53,430 --> 00:36:56,910
加入 aa 和 B 但现在在多

909
00:36:56,910 --> 00:36:58,830
表达式中我只有一个占位符

910
00:36:58,830 --> 00:37:01,800
在这里说嘿 它是 a 和 B

911
00:37:01,800 --> 00:37:03,990
它们被组合在一起我不

912
00:37:03,990 --> 00:37:05,880
知道我下面的其他人如何

913
00:37:05,880 --> 00:37:07,230
查询计划会告诉你如何做到这一点，

914
00:37:07,230 --> 00:37:08,580
但我知道我在这里只有一个

915
00:37:08,580 --> 00:37:10,440
占位符，

916
00:37:10,440 --> 00:37:14,400
在这种情况下，这里也有同样的事情 我对 C 进行了扫描，我

917
00:37:14,400 --> 00:37:17,010
不是说如何实际扫描它，

918
00:37:17,010 --> 00:37:17,720
而

919
00:37:17,720 --> 00:37:19,190
在这里我明确地说你知道

920
00:37:19,190 --> 00:37:21,020
这里有一对新闻双胞胎，我不会说

921
00:37:21,020 --> 00:37:23,210
任何正确的，所以

922
00:37:23,210 --> 00:37:24,349
当你看身体的时候更有意义

923
00:37:24,349 --> 00:37:25,310
或物理的羊肉

924
00:37:25,310 --> 00:37:27,410
我没有指定我如何加入

925
00:37:27,410 --> 00:37:29,540
a 和 B 或我如何实际访问 C

926
00:37:29,540 --> 00:37:31,640
但我指定我有一个

927
00:37:31,640 --> 00:37:33,140
物理连接运算符，它在

928
00:37:33,140 --> 00:37:37,099
这里执行证书模式，所以这个想法

929
00:37:37,099 --> 00:37:39,020
我们这样做的原因

930
00:37:39,020 --> 00:37:42,380
是在自上而下的搜索策略中

931
00:37:42,380 --> 00:37:45,109
在 Cascades 中，我们可以

932
00:37:45,109 --> 00:37:47,030
对是否要向下遍历

933
00:37:47,030 --> 00:37:49,940
到树中以了解我们

934
00:37:49,940 --> 00:37:51,050
实际上希望如何将这些东西

935
00:37:51,050 --> 00:37:53,180
正确地连接在一起进行相同的处理，而无需

936
00:37:53,180 --> 00:37:57,530
在自下而上的

937
00:37:57,530 --> 00:37:59,660
优化器中明确地将其全部删除。 一次

938
00:37:59,660 --> 00:38:02,060
从一组中枚举所有最多的表达式

939
00:38:02,060 --> 00:38:03,380
以及

940
00:38:03,380 --> 00:38:04,609
它们生成的表的顺序，因此他们将

941
00:38:04,609 --> 00:38:07,760
首先弄清楚如何

942
00:38:07,760 --> 00:38:10,099
访问它，然后找出访问

943
00:38:10,099 --> 00:38:12,140
光束以找出 X se 和 然后

944
00:38:12,140 --> 00:38:13,790
找出如何将 ami 和 组合在一起并

945
00:38:13,790 --> 00:38:14,270
继续努力

946
00:38:14,270 --> 00:38:15,740
所以这是一种不同的

947
00:38:15,740 --> 00:38:25,010
看待它的方式 所以在我们现在可以做出

948
00:38:25,010 --> 00:38:26,839
决定之前 我们将在下

949
00:38:26,839 --> 00:38:29,060
一张幻灯片或接下来的几张幻灯片中看到我们

950
00:38:29,060 --> 00:38:31,280
做出决定之前 你怎么知道

951
00:38:31,280 --> 00:38:34,010
我们实际上会怎么做 你知道

952
00:38:34,010 --> 00:38:35,869
这里的这个物理运算符 我们必须

953
00:38:35,869 --> 00:38:38,930
确保对于

954
00:38:38,930 --> 00:38:40,369
我们下面树

955
00:38:40,369 --> 00:38:42,200
中的所有占位符表达式 我们已经弄清楚我们

956
00:38:42,200 --> 00:38:44,690
实际上将如何访问它们是什么

957
00:38:44,690 --> 00:38:47,300
乙 树

958
00:38:47,300 --> 00:38:48,830
中的物理操作员的成本最低的估计物理成本或最佳计划

959
00:38:48,830 --> 00:38:50,660
蓝色，然后

960
00:38:50,660 --> 00:38:51,950
当

961
00:38:51,950 --> 00:38:54,260
我们决定要在此处再次为哪个操作员

962
00:38:54,260 --> 00:38:56,210
执行此操作时，我们可以将它们组合

963
00:38:56,210 --> 00:38:57,500
在一起 更有意义，

964
00:38:57,500 --> 00:39:00,890
所以我们在 Cascades 中需要了解的最后一件事

965
00:39:00,890 --> 00:39:04,460
是规则系统，

966
00:39:04,460 --> 00:39:06,650
因此规则将是一些转换

967
00:39:06,650 --> 00:39:08,839
，我们可以应用到一个表达式，

968
00:39:08,839 --> 00:39:11,690
将其转换为逻辑上

969
00:39:11,690 --> 00:39:13,310
等效的表达式，这意味着它将

970
00:39:13,310 --> 00:39:15,170
产生相同的逻辑结果和

971
00:39:15,170 --> 00:39:17,510
当我们实际执行它但因此我们将

972
00:39:17,510 --> 00:39:19,520
有两种类型的规则我们将有一个

973
00:39:19,520 --> 00:39:21,500
转换规则，它是一个

974
00:39:21,500 --> 00:39:23,180
逻辑逻辑运算符到物理

975
00:39:23,180 --> 00:39:26,990
运算符或一个工厂或

976
00:39:26,990 --> 00:39:29,030
工厂子集的逻辑计划到另一个逻辑计划

977
00:39:29,030 --> 00:39:30,060
子集

978
00:39:30,060 --> 00:39:31,680
，他们 将有一个实现规则

979
00:39:31,680 --> 00:39:33,810
，将一个逻辑运算符或

980
00:39:33,810 --> 00:39:36,450
一组逻辑运算符转换为物理

981
00:39:36,450 --> 00:39:39,270
运算符，正如我所说，每个规则

982
00:39:39,270 --> 00:39:42,090
由模式定义将匹配到

983
00:39:42,090 --> 00:39:44,760
iden 确定哪个子计划或

984
00:39:44,760 --> 00:39:47,160
找到具有 Civic 布局的计划的一部分

985
00:39:47,160 --> 00:39:49,590
与

986
00:39:49,590 --> 00:39:51,810
我们的规则匹配的配置，然后如果我们找到其中之一，

987
00:39:51,810 --> 00:39:53,700
则我们应用替换

988
00:39:53,700 --> 00:39:55,890
策略或我们

989
00:39:55,890 --> 00:39:58,620
想要转换查询计划

990
00:39:58,620 --> 00:40:01,170
结构的转换 进入逻辑上

991
00:40:01,170 --> 00:40:04,100
等价的更改或逻辑上等价的

992
00:40:04,100 --> 00:40:08,570
新计划，所以让我们在这里看一个例子

993
00:40:08,570 --> 00:40:11,220
，说这是我们的模式，我们的

994
00:40:11,220 --> 00:40:13,110
模式是我们想要匹配一个子计划

995
00:40:13,110 --> 00:40:15,900
，它有一个等值连接，

996
00:40:15,900 --> 00:40:18,630
然后是另一个等值连接，然后

997
00:40:18,630 --> 00:40:20,250
我们有 在这些占位符组中，

998
00:40:20,250 --> 00:40:21,810
我们只是说我们实际上并不关心

999
00:40:21,810 --> 00:40:24,450
或不关心我们不需要知道，我们也不

1000
00:40:24,450 --> 00:40:27,090
关心这些其他组

1001
00:40:27,090 --> 00:40:29,000
实际上在做什么我们只关心

1002
00:40:29,000 --> 00:40:31,500
在您有一个左撇子树的地方 go

1003
00:40:31,500 --> 00:40:34,650
join 落后于 equijoin 所以现在说

1004
00:40:34,650 --> 00:40:36,210
这是一个与此匹配的查询

1005
00:40:36,210 --> 00:40:39,270
所以我现在这里有一个

1006
00:40:39,270 --> 00:40:41,550
组合 a 和 B 并加入我们 C 的组然后

1007
00:40:41,550 --> 00:40:43,170
我在这里有另一个组在

1008
00:40:43,170 --> 00:40:46,890
a 和 B 之间加入所以

1009
00:40:46,890 --> 00:40:48,390
这些都是 equi-join 假设

1010
00:40:48,390 --> 00:40:49,770
你知道你正在做一个自然连接，

1011
00:40:49,770 --> 00:40:51,840
然后在每个连接运算符下面

1012
00:40:51,840 --> 00:40:53,970
我有这些 get 表达式，但这

1013
00:40:53,970 --> 00:40:55,170
不知何故说这就是我

1014
00:40:55,170 --> 00:40:58,080
将如何访问表 a B 和 C 但

1015
00:40:58,080 --> 00:41:00,510
我们并不关心规则中的实际内容，

1016
00:41:00,510 --> 00:41:01,920
因为我们只关心

1017
00:41:01,920 --> 00:41:03,480
有这两个匹配的连接

1018
00:41:03,480 --> 00:41:06,900
，所以我们做的第一种连接

1019
00:41:06,900 --> 00:41:10,110
是转换规则我们做的第一个更改

1020
00:41:10,110 --> 00:41:11,790
是我们想要的转换规则

1021
00:41:11,790 --> 00:41:15,270
旋转连接

1022
00:41:15,270 --> 00:41:18,660
从左到右，所以在这种情况下，

1023
00:41:18,660 --> 00:41:22,350


1024
00:41:22,350 --> 00:41:24,690
我们将把顶部连接下方的连接切换

1025
00:41:24,690 --> 00:41:25,860
到树的右侧，

1026
00:41:25,860 --> 00:41:28,290
而最初从

1027
00:41:28,290 --> 00:41:32,520
左侧开始 一方面，实现

1028
00:41:32,520 --> 00:41:36,230
规则实际上现在将

1029
00:41:36,230 --> 00:41:38,550
这些连接的逻辑运算符

1030
00:41:38,550 --> 00:41:41,520
转换为物理运算符，指定

1031
00:41:41,520 --> 00:41:42,589
如何

1032
00:41:42,589 --> 00:41:45,140
或我想使用什么算法，因此在这种情况下，我们

1033
00:41:45,140 --> 00:41:47,359
可以将这些转换为

1034
00:41:47,359 --> 00:41:49,989
无用或合并连接的乐趣，

1035
00:41:49,989 --> 00:41:53,569
所以一个 东西 在我们的

1036
00:41:53,569 --> 00:41:56,479
系统中要注意的是，或者在级联中，

1037
00:41:56,479 --> 00:41:58,249
我们要确保我们不会

1038
00:41:58,249 --> 00:42:00,859
陷入无限循环，所以

1039
00:42:00,859 --> 00:42:02,569
在这里我有一个转换

1040
00:42:02,569 --> 00:42:04,789
规则，允许我

1041
00:42:04,789 --> 00:42:07,069
旋转连接 从左到右在另一个

1042
00:42:07,069 --> 00:42:09,229
转换规则上将它

1043
00:42:09,229 --> 00:42:12,529
从右到左转换所以除非我小心

1044
00:42:12,529 --> 00:42:13,969
我可能会一直卡在

1045
00:42:13,969 --> 00:42:15,289
如果循环从左到右从左到右

1046
00:42:15,289 --> 00:42:18,680
再回到第四个永远不会再这样我们

1047
00:42:18,680 --> 00:42:20,509
需要一种方法 认识到我们

1048
00:42:20,509 --> 00:42:23,029
已经应用了一个转换，

1049
00:42:23,029 --> 00:42:24,589
因此我们不需要再次执行它，

1050
00:42:24,589 --> 00:42:26,809
并且可能搜索我们每次应用它的查询计划的

1051
00:42:26,809 --> 00:42:31,549
样子，所以这

1052
00:42:31,549 --> 00:42:32,779
就是 Cascades 中带有记忆表的备忘录表

1053
00:42:32,779 --> 00:42:35,089
将要做的 对我们

1054
00:42:35,089 --> 00:42:37,339
来说，在最初的 Cascades 论文中，我

1055
00:42:37,339 --> 00:42:38,989
认为他们使用了他们谈到

1056
00:42:38,989 --> 00:42:41,839
在我们的应用程序中使用图形数据结构

1057
00:42:41,839 --> 00:42:43,729
我们使用哈希表，据他们所知

1058
00:42:43,729 --> 00:42:46,640
在其他开源 Cascades

1059
00:42:46,640 --> 00:42:48,259
邀请中他们也使用哈希

1060
00:42:48,259 --> 00:42:51,140
表，那又怎样 如果确认 现在要做的是

1061
00:42:51,140 --> 00:42:55,219
我们可以确定我们已经

1062
00:42:55,219 --> 00:42:56,809
可以确定我们可以拥有

1063
00:42:56,809 --> 00:42:58,940
我们之前访问过的组，因此我们

1064
00:42:58,940 --> 00:43:00,469
不需要再次检查它，因为我们

1065
00:43:00,469 --> 00:43:03,049
已经知道在我们应用之后查询计划的样子

1066
00:43:03,049 --> 00:43:04,249


1067
00:43:04,249 --> 00:43:06,140
转换所以这很好 所以如果我们

1068
00:43:06,140 --> 00:43:08,509
从左到右这样做 如果我们

1069
00:43:08,509 --> 00:43:09,769
尝试应用转换规则

1070
00:43:09,769 --> 00:43:12,200
从左向右返回 我们会说我们

1071
00:43:12,200 --> 00:43:13,729
已经知道看起来像我们

1072
00:43:13,729 --> 00:43:15,319
已经到过并且我们看到了成本

1073
00:43:15,319 --> 00:43:18,289
在我们的备忘录表中，

1074
00:43:18,289 --> 00:43:21,739
因此我们不需要很好地应用它，

1075
00:43:21,739 --> 00:43:23,509
我们将如何做到这一点，因为

1076
00:43:23,509 --> 00:43:24,920
我们将拥有等效的运算符

1077
00:43:24,920 --> 00:43:26,420
树和它们相应的组

1078
00:43:26,420 --> 00:43:28,999
存储在一起或一起存储到组

1079
00:43:28,999 --> 00:43:31,219
中 它们在备忘录表中

1080
00:43:31,219 --> 00:43:34,190
，我们需要一种方法来快速散列，并且

1081
00:43:34,190 --> 00:43:35,779
在我们有重复项的

1082
00:43:35,779 --> 00:43:39,529
情况下，这个备忘录表可以

1083
00:43:39,529 --> 00:43:42,289
为我们做的事情是除了

1084
00:43:42,289 --> 00:43:46,359
能够避免重复和

1085
00:43:46,359 --> 00:43:49,460
重复查询之外 计划转型我们

1086
00:43:49,460 --> 00:43:51,619
也可以使用它来快速

1087
00:43:51,619 --> 00:43:54,710
识别我们已经下降了，现在它

1088
00:43:54,710 --> 00:43:55,950
是查询计划的一部分

1089
00:43:55,950 --> 00:43:57,210
，我们不需要你进一步遍历它，

1090
00:43:57,210 --> 00:44:01,200
所以这与现在

1091
00:44:01,200 --> 00:44:03,840
这个级联的最优性原则的想法有关

1092
00:44:03,840 --> 00:44:07,110
基于，这

1093
00:44:07,110 --> 00:44:08,670
是来自控制理论，这

1094
00:44:08,670 --> 00:44:09,870
是贝尔曼的最优原则

1095
00:44:09,870 --> 00:44:13,350
，这不是特定于保持

1096
00:44:13,350 --> 00:44:15,030
Cascades 自上而下的搜索，

1097
00:44:15,030 --> 00:44:17,190
但这就是我们将能够让您

1098
00:44:17,190 --> 00:44:19,560
最终找到一个 最佳

1099
00:44:19,560 --> 00:44:22,140
查询计划所以它真正说的是，

1100
00:44:22,140 --> 00:44:26,130
如果我有一个最佳查询计划和

1101
00:44:26,130 --> 00:44:28,620
两个组的惊喜，那么我

1102
00:44:28,620 --> 00:44:31,260


1103
00:44:31,260 --> 00:44:35,130
知道对于这些组中的一个，不可能有另一个最佳物理计划，因为如果

1104
00:44:35,130 --> 00:44:38,640
有的话，我就不会' 这不是最佳

1105
00:44:38,640 --> 00:44:40,530
计划，

1106
00:44:40,530 --> 00:44:44,430
如果我知道我知道这是

1107
00:44:44,430 --> 00:44:47,070
我见过的最好的计划，并且我有我见过的

1108
00:44:47,070 --> 00:44:48,450
最好的计划，并且我正处于

1109
00:44:48,450 --> 00:44:51,390
搜索中的某个时刻，那么这几乎就像同义反复 树，现在

1110
00:44:51,390 --> 00:44:54,270
我的成本比我见过的最好的还要高

1111
00:44:54,270 --> 00:44:56,520
er 看到了，但是如果

1112
00:44:56,520 --> 00:44:59,880
我在

1113
00:44:59,880 --> 00:45:01,890
查询计划树中向下遍历，我不会神奇地

1114
00:45:01,890 --> 00:45:04,020
找到比我见过的最好的计划更好的最佳计划，

1115
00:45:04,020 --> 00:45:08,330
因为

1116
00:45:08,330 --> 00:45:12,270
那样，因为搜索的工作方式

1117
00:45:12,270 --> 00:45:13,620
就是你' 当你下降时你会增加更多的成本

1118
00:45:13,620 --> 00:45:15,300
并且你

1119
00:45:15,300 --> 00:45:17,220
自动地会比你之前看到的更少

1120
00:45:17,220 --> 00:45:19,530
所以这只是

1121
00:45:19,530 --> 00:45:22,040
解决方案树的分支和平衡搜索方法

1122
00:45:22,040 --> 00:45:24,930
这只是说就像我们

1123
00:45:24,930 --> 00:45:26,760
知道如果我们得到 查询

1124
00:45:26,760 --> 00:45:29,610
计划中的一点是我们有一个

1125
00:45:29,610 --> 00:45:31,290
比有史以来最好的电影还要糟糕的子计划，

1126
00:45:31,290 --> 00:45:32,970
我们不需要对它做任何进一步的

1127
00:45:32,970 --> 00:45:37,200
探索，所以现在让我们看

1128
00:45:37,200 --> 00:45:40,680
一个完整的例子

1129
00:45:40,680 --> 00:45:42,750
搜索所以说我们想要

1130
00:45:42,750 --> 00:45:46,170
在 B 和 C 之间进行 3 路连接，

1131
00:45:46,170 --> 00:45:48,270
所以一开始我有这个

1132
00:45:48,270 --> 00:45:51,270
组在这里说输出

1133
00:45:51,270 --> 00:45:55,440
表达式应该是 B 和 C 所以

1134
00:45:55,440 --> 00:45:59,550
第一步我需要 做的是触发一个

1135
00:45:59,550 --> 00:46:01,410
转换规则，它将为

1136
00:46:01,410 --> 00:46:06,090
我生成一个逻辑多表达式，所以他

1137
00:46:06,090 --> 00:46:07,740
现在我们将 a 和 B 组合在一起，

1138
00:46:07,740 --> 00:46:09,780
然后我们加入了 C

1139
00:46:09,780 --> 00:46:11,340
所以现在我想做的是

1140
00:46:11,340 --> 00:46:14,280
向下遍历到树中并找出

1141
00:46:14,280 --> 00:46:19,050
执行的成本是多少你知道

1142
00:46:19,050 --> 00:46:21,480
我的表达式的这两个组成部分

1143
00:46:21,480 --> 00:46:23,280
所以我 将从这里开始我将采用 a 和

1144
00:46:23,280 --> 00:46:25,230
B 所以现在我有一个新组的

1145
00:46:25,230 --> 00:46:27,210
输出它是 a 和 B 因为这

1146
00:46:27,210 --> 00:46:29,100
与我的位置或在这里的位置相匹配

1147
00:46:29,100 --> 00:46:31,140
现在我想要进行

1148
00:46:31,140 --> 00:46:32,790
逻辑转换或 逻辑

1149
00:46:32,790 --> 00:46:35,340
表达式来表示如何

1150
00:46:35,340 --> 00:46:37,320
计算这个输出，所以现在只是

1151
00:46:37,320 --> 00:46:40,140
以某种方式访问 a 并且我

1152
00:46:40,140 --> 00:46:41,820
将通过某种方式访问

1153
00:46:41,820 --> 00:46:44,370
B 所以现在同样的事情我必须从

1154
00:46:44,370 --> 00:46:46,470
这个第一个我的表达式的第一个组件开始

1155
00:46:46,470 --> 00:46:48,900
然后去 下来并检查

1156
00:46:48,900 --> 00:46:50,880
我实际上将如何访问它，这样我的

1157
00:46:50,880 --> 00:46:53,520
逻辑运算符就会得到一个

1158
00:46:53,520 --> 00:46:55,560
我要访问一个嘿他们

1159
00:46:55,560 --> 00:46:57,630
实际上并没有说如何去做所以我可以

1160
00:46:57,630 --> 00:46:58,580
有一个逻辑到物理

1161
00:46:58,580 --> 00:47:01,350
转换然后说 哦，我可以

1162
00:47:01,350 --> 00:47:03,960
对 a 进行索引扫描，或者我可以进行

1163
00:47:03,960 --> 00:47:07,410
seq  uential scan 或 name 然后现在在

1164
00:47:07,410 --> 00:47:09,600
这一点上我们有这些物理

1165
00:47:09,600 --> 00:47:11,820
表达式 因为

1166
00:47:11,820 --> 00:47:14,400
在查询计划树中没有人低于我们 所以我们可以计算

1167
00:47:14,400 --> 00:47:16,680
将要带给 Xu 的成本

1168
00:47:16,680 --> 00:47:18,870


1169
00:47:18,870 --> 00:47:20,490
无论出于何种

1170
00:47:20,490 --> 00:47:23,580
原因进行扫描是执行此访问方法的最便宜的方式，

1171
00:47:23,580 --> 00:47:27,330
因此

1172
00:47:27,330 --> 00:47:28,800
我们将计算对此的调用

1173
00:47:28,800 --> 00:47:30,210
，然后我们更新我们的备忘录表，

1174
00:47:30,210 --> 00:47:32,970
它在此处被切断，但这只是

1175
00:47:32,970 --> 00:47:34,620
说最好的 我们曾经

1176
00:47:34,620 --> 00:47:36,810
见过的仅产生 a 的输出的表达式

1177
00:47:36,810 --> 00:47:40,140
是对 a 的顺序扫描，

1178
00:47:40,140 --> 00:47:44,040
成本为 10 所以现在我什

1179
00:47:44,040 --> 00:47:45,450
至不能做同样的事情去另一边，

1180
00:47:45,450 --> 00:47:47,910
因为我最终得到了这个逻辑表达式

1181
00:47:47,910 --> 00:47:50,520
be  get BI 计算所有不同的

1182
00:47:50,520 --> 00:47:51,570
物理表达式我可能

1183
00:47:51,570 --> 00:47:54,360
有顺序扫描索引扫描

1184
00:47:54,360 --> 00:47:55,680
顺序扫描结果是便宜

1185
00:47:55,680 --> 00:47:57,480
的最便宜的成本 20

1186
00:47:57,480 --> 00:47:59,850
我上传了 8 我的备忘录表说

1187
00:47:59,850 --> 00:48:02,100
访问顺序扫描是最快的，

1188
00:48:02,100 --> 00:48:04,590
成本为 20 但是 现在  我回到

1189
00:48:04,590 --> 00:48:07,830
这里，我可以在这里加入那个令人信服的

1190
00:48:07,830 --> 00:48:09,330
合作社，如果他们仍然开始

1191
00:48:09,330 --> 00:48:12,330
为我们生成更多的逻辑专家计算更多的逻辑表达式，

1192
00:48:12,330 --> 00:48:13,620


1193
00:48:13,620 --> 00:48:16,620
这将为我产生输出，所以

1194
00:48:16,620 --> 00:48:18,570
现在我想加入成为一个鸡蛋，因为我

1195
00:48:18,570 --> 00:48:20,500
做了

1196
00:48:20,500 --> 00:48:24,250
正确的轮换 顺序现在是一样的，我

1197
00:48:24,250 --> 00:48:26,590
需要获得访问 B 的成本，

1198
00:48:26,590 --> 00:48:28,180
然后

1199
00:48:28,180 --> 00:48:30,480
在计算将其转换为物理物理运算符的物理成本之前获得访问 a 的成本，

1200
00:48:30,480 --> 00:48:35,560


1201
00:48:35,560 --> 00:48:38,470
但在这种情况下，当我

1202
00:48:38,470 --> 00:48:40,420
下降时 说

1203
00:48:40,420 --> 00:48:42,550
访问 B 的成本是多少或访问 a 的成本是多少

1204
00:48:42,550 --> 00:48:44,859
我实际上已经做到了

1205
00:48:44,859 --> 00:48:47,050
这一点 我不需要这样做，

1206
00:48:47,050 --> 00:48:49,090
因为我的备忘录表中已经有了最好的成本，

1207
00:48:49,090 --> 00:48:51,970
所以我不需要这样做

1208
00:48:51,970 --> 00:48:54,580
在这里再次搜索或进行更多

1209
00:48:54,580 --> 00:48:57,130
转换 我已经完成，我只是

1210
00:48:57,130 --> 00:49:00,040
重复使用我在这里的成本，所以

1211
00:49:00,040 --> 00:49:01,810
我可以继续这样做，就像它

1212
00:49:01,810 --> 00:49:03,609
只是一个联合 B 或 B 联合只有

1213
00:49:03,609 --> 00:49:05,710
两个选择，但现在我可以 查看所有

1214
00:49:05,710 --> 00:49:08,590
可能的组合 物理

1215
00:49:08,590 --> 00:49:11,080
运算符我想用于计算

1216
00:49:11,080 --> 00:49:13,510
连接，在这里我只显示一个子集，

1217
00:49:13,510 --> 00:49:14,830
但现在再次如果我想获得这个

1218
00:49:14,830 --> 00:49:16,660
物理成本并且您知道

1219
00:49:16,660 --> 00:49:18,040
访问退出 B 的任何代码调用的成本，

1220
00:49:18,040 --> 00:49:20,800
但我已经有了 在我的

1221
00:49:20,800 --> 00:49:24,369
物理计划中，

1222
00:49:24,369 --> 00:49:25,540
所以在 SERP

1223
00:49:25,540 --> 00:49:27,640
合并连接中保存这个的成本是访问 a

1224
00:49:27,640 --> 00:49:29,800
的成本是 10 X 的成本在 B

1225
00:49:29,800 --> 00:49:31,839
是 20 并且服务器的成本被

1226
00:49:31,839 --> 00:49:34,359
加入假设是 50 现在我可以把

1227
00:49:34,359 --> 00:49:37,390
它写到我的备忘录表里说

1228
00:49:37,390 --> 00:49:40,780
这样做的成本是 80 所以现在在这里我

1229
00:49:40,780 --> 00:49:42,670
回到我根据这个组

1230
00:49:42,670 --> 00:49:44,200
在这里 现在我不需要

1231
00:49:44,200 --> 00:49:46,780
检查另一边访问一些 C 所以 同样的

1232
00:49:46,780 --> 00:49:48,700
事情跳到这里我可以收集进行

1233
00:49:48,700 --> 00:49:50,200
顺序扫描或索引，并且

1234
00:49:50,200 --> 00:49:51,700
无论出于何种原因索引扫描更快，

1235
00:49:51,700 --> 00:49:54,790
所以我将成本记录到此处为 5

1236
00:49:54,790 --> 00:49:57,220
，然后现在我可以做更多

1237
00:49:57,220 --> 00:49:58,720
不同联合

1238
00:49:58,720 --> 00:50:01,780
排序的排列 B 和 C 或者我可以开始

1239
00:50:01,780 --> 00:50:05,020
检查转换很多

1240
00:50:05,020 --> 00:50:06,550
表达式 s 进入物理物理

1241
00:50:06,550 --> 00:50:08,380
运算符并检查访问进行实际连接的

1242
00:50:08,380 --> 00:50:12,099
不同方法

1243
00:50:12,099 --> 00:50:16,030
，然后我可以

1244
00:50:16,030 --> 00:50:17,770
根据

1245
00:50:17,770 --> 00:50:21,940
我

1246
00:50:21,940 --> 00:50:25,510
在查询星球中所做的工作的总和来选择一种成本较低的方法

1247
00:50:25,510 --> 00:50:27,220
本质上，Cascades 是如何

1248
00:50:27,220 --> 00:50:28,869
在高层次上正确工作的，就像我们只是继续做

1249
00:50:28,869 --> 00:50:30,210
更多的排列

1250
00:50:30,210 --> 00:50:32,560
，尽可能多地使用内存表，

1251
00:50:32,560 --> 00:50:34,180
但是

1252
00:50:34,180 --> 00:50:37,030
当我们有足够的时间来估计物理成本时，我们调用成本模型

1253
00:50:37,030 --> 00:50:42,070
，现在更有

1254
00:50:42,070 --> 00:50:43,180
意义 我们上次在搜索终止时讨论过，

1255
00:50:43,180 --> 00:50:45,220
您可以看到

1256
00:50:45,220 --> 00:50:46,930
对于非常复杂的曲线，很多连接

1257
00:50:46,930 --> 00:50:49,120
我可以深入到我的

1258
00:50:49,120 --> 00:50:50,980
查询计划中，我只是一直在做这个

1259
00:50:50,980 --> 00:50:53,050
搜索，所以你需要一种方法来

1260
00:50:53,050 --> 00:50:55,870
确定什么时候应该停止 我们

1261
00:50:55,870 --> 00:50:56,770
讨论了挂钟时间如何

1262
00:50:56,770 --> 00:50:58,870
只是说当我用完一定数量的时间时我会停止

1263
00:50:58,870 --> 00:51:00,790
你知道一些可

1264
00:51:00,790 --> 00:51:03,070
配置的数量我可以有一个成本

1265
00:51:03,070 --> 00:51:06,880
阈值来说明如果我找到一个

1266
00:51:06,880 --> 00:51:08,320
看看如果我还没有找到更低的成本我

1267
00:51:08,320 --> 00:51:10,870
还没有找到

1268
00:51:10,870 --> 00:51:12,730
比我迄今为止见过的最好的计划好 10% 的更好的计划，

1269
00:51:12,730 --> 00:51:15,160
那么我应该停下来，

1270
00:51:15,160 --> 00:51:17,530
因为我有点得到

1271
00:51:17,530 --> 00:51:19,330
继续

1272
00:51:19,330 --> 00:51:21,610
搜索的收益递减然后你知道最后一个

1273
00:51:21,610 --> 00:51:23,440
是如果我因为他们也搜索所有

1274
00:51:23,440 --> 00:51:28,480
不同的选项然后我没有停止所以

1275
00:51:28,480 --> 00:51:33,850
级联就像我说的据我所知我

1276
00:51:33,850 --> 00:51:35,620
认为从来没有 独立

1277
00:51:35,620 --> 00:51:40,000
级联实现至少我不这么

1278
00:51:40,000 --> 00:51:42,490
认为，所以我认为网格图 II

1279
00:51:42,490 --> 00:51:44,290
在 90 年代与 Microsoft 合作，

1280
00:51:44,290 --> 00:51:46,510
在单个服务器中级联的标志

1281
00:51:46,510 --> 00:51:49,870
，据我所知，

1282
00:51:49,870 --> 00:51:52,450
他们仍然基于此，但它

1283
00:51:52,450 --> 00:51:54,550
一直在使用一堆 据我所知，

1284
00:51:54,550 --> 00:51:57,640
不同的系统以及大多数数据库

1285
00:51:57,640 --> 00:51:59,110
系统都在使用

1286
00:51:59,110 --> 00:52:02,290
动态编程技术方法，但是

1287
00:52:02,290 --> 00:52:04,360
过去 20 年左右的一些较新的系统

1288
00:52:04,360 --> 00:52:07,060
或使用其中的一些系统正在

1289
00:52:07,060 --> 00:52:10,030
使用级联，所以 Wisconsin ah plus

1290
00:52:10,030 --> 00:52:11,620
plus 就像 哥伦比亚在那里有点

1291
00:52:11,620 --> 00:52:14,920
独立 o  ptimizer 生成器，

1292
00:52:14,920 --> 00:52:16,270
你知道你定义规则，

1293
00:52:16,270 --> 00:52:17,590
我们计算或生成成本

1294
00:52:17,590 --> 00:52:20,100
模型或为你生成优化器

1295
00:52:20,100 --> 00:52:23,350
关键 Orica 和方解石实际上是

1296
00:52:23,350 --> 00:52:24,460
两个有趣的项目，我们将

1297
00:52:24,460 --> 00:52:26,190
在稍后讨论，但将它们视为

1298
00:52:26,190 --> 00:52:28,960
独立的服务 做查询

1299
00:52:28,960 --> 00:52:30,430
优化，这样你就可以让你的

1300
00:52:30,430 --> 00:52:32,140
数据库系统像运行一台机器一样，你的

1301
00:52:32,140 --> 00:52:33,580
查询优化服务在机器上运行

1302
00:52:33,580 --> 00:52:34,270


1303
00:52:34,270 --> 00:52:36,780
，你将查询请求发送到

1304
00:52:36,780 --> 00:52:39,340
优化器服务，它会对它们进行处理

1305
00:52:39,340 --> 00:52:41,470
，然后吐出一个医院计划

1306
00:52:41,470 --> 00:52:43,930
，然后你执行等等 这些又

1307
00:52:43,930 --> 00:52:45,400
不是这些 与任何

1308
00:52:45,400 --> 00:52:47,130
特定的数据库

1309
00:52:47,130 --> 00:52:48,539
系统无关 那些实际上

1310
00:52:48,539 --> 00:52:49,680
与 Eagle 服务器集成的系统

1311
00:52:49,680 --> 00:52:53,569
非常有名的不间断续集 是 19 世纪 80 年代初期的

1312
00:52:53,569 --> 00:52:55,170
分布式数据库或并行

1313
00:52:55,170 --> 00:52:56,989
数据库

1314
00:52:56,989 --> 00:52:59,849
，至今仍被广泛

1315
00:52:59,849 --> 00:53:01,579
使用 在很多银行和

1316
00:53:01,579 --> 00:53:04,710
金融系统中，所以他们重写

1317
00:53:04,710 --> 00:53:07,319
了 1990 年代集群的编舞，

1318
00:53:07,319 --> 00:53:11,369
暴露了一个 或者这是否存在

1319
00:53:11,369 --> 00:53:13,259
是我的续集的分布式版本，

1320
00:53:13,259 --> 00:53:17,400


1321
00:53:17,400 --> 00:53:19,619
两年前被 Morea DB 人员阻止，根据他们的

1322
00:53:19,619 --> 00:53:21,059
文档，他们使用 Cascades

1323
00:53:21,059 --> 00:53:23,009
优化器来替换原来的我的

1324
00:53:23,009 --> 00:53:24,989
续集优化器，然后

1325
00:53:24,989 --> 00:53:27,150
是我们开始使用的系统 Peloton  2000

1326
00:53:27,150 --> 00:53:29,640
两年前我们将其关闭，但

1327
00:53:29,640 --> 00:53:32,789
从那时起 7:21 学生将其移植

1328
00:53:32,789 --> 00:53:35,099
到你们今天正在开发的新系统中，

1329
00:53:35,099 --> 00:53:39,769
所以作为开源

1330
00:53:39,769 --> 00:53:42,720
好吧，让我们谈谈关键的 Orca

1331
00:53:42,720 --> 00:53:44,400
和方解石，因为我认为它们

1332
00:53:44,400 --> 00:53:47,460
就像 我说这些是独立的

1333
00:53:47,460 --> 00:53:49,259
优化器系统，不与

1334
00:53:49,259 --> 00:53:53,009
任何一个数据库系统绑定，我们

1335
00:53:53,009 --> 00:53:55,559
在 Peloton 的最初几天检查过 Orca

1336
00:53:55,559 --> 00:53:57,059
决定我们是否要使用

1337
00:53:57,059 --> 00:53:58,529
它他们没有查看

1338
00:53:58,529 --> 00:54:00,539
锁定的插补及其工作方式

1339
00:54:00,539 --> 00:54:02,549
您是否会运行该服务并

1340
00:54:02,549 --> 00:54:03,900
通过这些指定的 XML 文件发送，

1341
00:54:03,900 --> 00:54:06,210
例如查询计划和

1342
00:54:06,210 --> 00:54:08,819
规则以及

1343
00:54:08,819 --> 00:54:10,289
有关数据外观的目录统计信息，但我

1344
00:54:10,289 --> 00:54:11,729
想我会 没有详细记录它

1345
00:54:11,729 --> 00:54:13,109
变得更好，因为

1346
00:54:13,109 --> 00:54:15,690
当时我们查看它时

1347
00:54:15,690 --> 00:54:16,799
它没有启动，我可以

1348
00:54:16,799 --> 00:54:20,249
使用它所以 Orca 是一个关键的环形级联

1349
00:54:20,249 --> 00:54:21,809
实现，最初

1350
00:54:21,809 --> 00:54:24,180
是为 green plum green plum 编写的 是

1351
00:54:24,180 --> 00:54:27,269


1352
00:54:27,269 --> 00:54:30,029
2000 年代中期的原始数据仓库系统之一，它

1353
00:54:30,029 --> 00:54:33,119
带有 Vertica 和数据 Allegro 和 Astra

1354
00:54:33,119 --> 00:54:37,799
数据，所以发生的事情是 EMC 买了

1355
00:54:37,799 --> 00:54:43,529
绿梅，然后 VMware 买了 gem

1356
00:54:43,529 --> 00:54:48,509
fire single fire，EMC 不想

1357
00:54:48,509 --> 00:54:50,549
拥有数据库 部门 VMware 我

1358
00:54:50,549 --> 00:54:51,690
没有数据库愿景，所以他们都

1359
00:54:51,690 --> 00:54:55,259
剥离了他们的数据库产品，将

1360
00:54:55,259 --> 00:54:56,759
它们合并为一家名为

1361
00:54:56,759 --> 00:55:00,329
关键的公司，所以 Orca 最初是

1362
00:55:00,329 --> 00:55:01,059
为绿梅写的，

1363
00:55:01,059 --> 00:55:03,009
但后来他们打破了它，不得不成为

1364
00:55:03,009 --> 00:55:04,419
一个刺激系统，这样他们就可以 将

1365
00:55:04,419 --> 00:55:06,939
它用于他们在 Hadoop 之上的续集引擎，

1366
00:55:06,939 --> 00:55:08,859
称为 Hawk 的 Hadoop 文件系统，

1367
00:55:08,859 --> 00:55:11,739
所以它是不可知的，

1368
00:55:11,739 --> 00:55:13,599
实际数据模型是什么，或者你指定的实际

1369
00:55:13,599 --> 00:55:16,119
数据库系统是什么

1370
00:55:16,119 --> 00:55:19,359
这些 XML 文件你

1371
00:55:19,359 --> 00:55:20,559
知道什么 你有什么规则以及

1372
00:55:20,559 --> 00:55:21,849
它实际上想要如何实际

1373
00:55:21,849 --> 00:55:23,949
形成计划 然后当

1374
00:55:23,949 --> 00:55:25,479
你得到优化计划的响应时，由你的数据系统来获取这些 XML

1375
00:55:25,479 --> 00:55:26,859
文件

1376
00:55:26,859 --> 00:55:29,079
和 能够

1377
00:55:29,079 --> 00:55:31,900
执行它 所以关于 orca 的一件有趣的

1378
00:55:31,900 --> 00:55:34,239
事情我们还没有在

1379
00:55:34,239 --> 00:55:36,459
这里讨论，因为它是一个独立的

1380
00:55:36,459 --> 00:55:39,339
服务，你可以想象我有我

1381
00:55:39,339 --> 00:55:41,559
的数据库机器集群，然后我

1382
00:55:41,559 --> 00:55:43,269
有一台专门

1383
00:55:43,269 --> 00:55:45,640
用作查询优化器的机器 机器，这

1384
00:55:45,640 --> 00:55:47,559
意味着该机器可以使用

1385
00:55:47,559 --> 00:55:49,059
所有内核或所有

1386
00:55:49,059 --> 00:55:51,039
可用资源来进行查询优化，

1387
00:55:51,039 --> 00:55:53,769
因此它们实际上可以进行多线程

1388
00:55:53,769 --> 00:55:57,489
搜索，因此

1389
00:55:57,489 --> 00:55:59,439
在进行动态编程

1390
00:55:59,439 --> 00:56:01,539
或 Cascades 方法时看起来如何 你可以很

1391
00:56:01,539 --> 00:56:02,979
容易地想象

1392
00:56:02,979 --> 00:56:06,039
查询树的不同点我

1393
00:56:06,039 --> 00:56:07,509
可以调用不同的线程

1394
00:56:07,509 --> 00:56:10,839
来在它们中进行探索，但

1395
00:56:10,839 --> 00:56:12,309
它们都是 完全使用成本模型

1396
00:56:12,309 --> 00:56:13,269
检查自己的

1397
00:56:13,269 --> 00:56:15,909
转换，您仍然可能需要

1398
00:56:15,909 --> 00:56:17,559
更新全局备忘录表以避免

1399
00:56:17,559 --> 00:56:19,569
冗余计算或更新这里是

1400
00:56:19,569 --> 00:56:22,150
我见过的最佳计划，但

1401
00:56:22,150 --> 00:56:25,119
在大多数情况下，搜索本身是

1402
00:56:25,119 --> 00:56:28,089
非常独立的，因此他们 '

1403
00:56:28,089 --> 00:56:29,709
是我所知道的为数不多

1404
00:56:29,709 --> 00:56:33,039
的可以做到多线程的优化器

1405
00:56:33,039 --> 00:56:34,689
之一，我认为这很酷，

1406
00:56:34,689 --> 00:56:39,789
当然我们的优化器不感谢我们的

1407
00:56:39,789 --> 00:56:42,299
优化器现在可以运行不同的

1408
00:56:42,299 --> 00:56:44,349
查询优化不同的查询

1409
00:56:44,349 --> 00:56:46,449
，当不同的线程 但是我们

1410
00:56:46,449 --> 00:56:47,979
不能进行一个查询并在多个线程上进行搜索，

1411
00:56:47,979 --> 00:56:51,400
因此在 Oracle 论文

1412
00:56:51,400 --> 00:56:52,900
中出现了两个有趣的工程内容

1413
00:56:52,900 --> 00:56:54,609


1414
00:56:54,609 --> 00:56:56,829
，我发现它们非常吸引人，我

1415
00:56:56,829 --> 00:56:59,079
在其他优化器描述中还没有真正看到讨论过

1416
00:56:59,079 --> 00:57:02,169
首先

1417
00:57:02,169 --> 00:57:06,009
是在 Orca 中，他们已将其设置为

1418
00:57:06,009 --> 00:57:07,959
使他们能够更轻松地进行远程调试，

1419
00:57:07,959 --> 00:57:09,789
因此 greenplum

1420
00:57:09,789 --> 00:57:12,579
被设计为内部部署软件，因此

1421
00:57:12,579 --> 00:57:13,959
它不会运行 作为云中的托管服务，

1422
00:57:13,959 --> 00:57:14,420


1423
00:57:14,420 --> 00:57:16,400
就像您的公司在 Orca

1424
00:57:16,400 --> 00:57:17,750
中下载绿色拇指

1425
00:57:17,750 --> 00:57:19,760
软件并

1426
00:57:19,760 --> 00:57:22,069
在您自己的数据中心的您自己的机器上运行它

1427
00:57:22,069 --> 00:57:23,720
一样，现在的问题是，如果现在

1428
00:57:23,720 --> 00:57:25,700
优化器中断或抛出 错误

1429
00:57:25,700 --> 00:57:27,200
，它存在一些问题，

1430
00:57:27,200 --> 00:57:29,299


1431
00:57:29,299 --> 00:57:31,549
如果您现在是 Orca 开发人员回来

1432
00:57:31,549 --> 00:57:33,200
并在关键位置工作，那么您如何实际调试，因为他们

1433
00:57:33,200 --> 00:57:34,819
不会让您通过 SSH 连接到机器

1434
00:57:34,819 --> 00:57:37,609
并且您知道重新运行失败的查询

1435
00:57:37,609 --> 00:57:39,799
或者你知道获取

1436
00:57:39,799 --> 00:57:41,690
数据的转储并在本地运行它，因为它

1437
00:57:41,690 --> 00:57:44,059
会太大，所以他们所做的

1438
00:57:44,059 --> 00:57:46,250
是他们拥有它，以便在

1439
00:57:46,250 --> 00:57:49,790
出现错误时系统会

1440
00:57:49,790 --> 00:57:53,690
以这样的方式转储其状态

1441
00:57:53,690 --> 00:57:55,220
它允许开发

1442
00:57:55,220 --> 00:57:57,890
人员将该状态转储加载回

1443
00:57:57,890 --> 00:58:00,349
本地，并能够

1444
00:58:00,349 --> 00:58:03,950
准确地了解系统的状态

1445
00:58:03,950 --> 00:58:06,559
是优化器在该

1446
00:58:06,559 --> 00:58:08,780
查询出错时的状态，以便您可以轻松

1447
00:58:08,780 --> 00:58:12,950
重现问题，并且  修复它，因此

1448
00:58:12,950 --> 00:58:15,680
将其视为优化器的核心转储，

1449
00:58:15,680 --> 00:58:18,559
其中包含其他

1450
00:58:18,559 --> 00:58:22,369
信息，例如您知道什么

1451
00:58:22,369 --> 00:58:23,240
是我

1452
00:58:23,240 --> 00:58:24,740
应用了备忘录表中的内容的所有转换，

1453
00:58:24,740 --> 00:58:25,970
就像它比配额转储

1454
00:58:25,970 --> 00:58:28,760
更多 专门定制

1455
00:58:28,760 --> 00:58:30,530
进行球场优化以使他们的

1456
00:58:30,530 --> 00:58:33,589
生活更轻松，我还没有看到

1457
00:58:33,589 --> 00:58:34,819
这一点，也许商业人员有这个，

1458
00:58:34,819 --> 00:58:37,430
但我还没有看到

1459
00:58:37,430 --> 00:58:40,069
其他优化器谈到这

1460
00:58:40,069 --> 00:58:42,140
一点他们在 Oracle 中做的另一件很酷的事情我觉得

1461
00:58:42,140 --> 00:58:45,410
非常有趣 他们

1462
00:58:45,410 --> 00:58:46,640
谈论他们如何拥有这个测试

1463
00:58:46,640 --> 00:58:48,980
框架，使他们能够轻松

1464
00:58:48,980 --> 00:58:51,740
检查成本模型和

1465
00:58:51,740 --> 00:58:55,670
优化器是否真正选择了成本最低的最佳

1466
00:58:55,670 --> 00:58:57,109
查询计划，

1467
00:58:57,109 --> 00:58:59,270
因此他们有一个叫做 taco 的东西

1468
00:58:59,270 --> 00:59:01,670
，用于测试准确性 在

1469
00:59:01,670 --> 00:59:03,470
查询优化器中，他们声称它是

1470
00:59:03,470 --> 00:59:03,859
开源的，

1471
00:59:03,859 --> 00:59:06,079
我可能还没有在 github 上找到我

1472
00:59:06,079 --> 00:59:08,839
需要给他们发电子邮件，但它的工作

1473
00:59:08,839 --> 00:59:11,569
方式是我想到了像我瘦的东西 k 我

1474
00:59:11,569 --> 00:59:13,400
接受我放入优化器的查询

1475
00:59:13,400 --> 00:59:15,799
，然后它会吐出我

1476
00:59:15,799 --> 00:59:17,299
认为最好的计划，但我也可以

1477
00:59:17,299 --> 00:59:20,210
让它吐出什么是最糟糕的计划

1478
00:59:20,210 --> 00:59:23,119
，所以现在我可以采取最坏的

1479
00:59:23,119 --> 00:59:24,950
计划 最好的计划实际上在

1480
00:59:24,950 --> 00:59:27,680
我的数据库系统上执行它们，哦，是的，

1481
00:59:27,680 --> 00:59:28,250


1482
00:59:28,250 --> 00:59:30,530
实际上，最好的计划

1483
00:59:30,530 --> 00:59:32,900
实际上比最差的计划快

1484
00:59:32,900 --> 00:59:34,070


1485
00:59:34,070 --> 00:59:36,650


1486
00:59:36,650 --> 00:59:37,940
太慢以至于你不

1487
00:59:37,940 --> 00:59:38,660
想像它是一堆

1488
00:59:38,660 --> 00:59:39,980
笛卡尔积那样做它需要永远

1489
00:59:39,980 --> 00:59:41,810
运行这是显而易见的所以你应该

1490
00:59:41,810 --> 00:59:44,600
缩小最糟糕的计划

1491
00:59:44,600 --> 00:59:47,030
实际上几年的差距或不太理想的

1492
00:59:47,030 --> 00:59:49,100
计划 是离最优计划还有多少步，

1493
00:59:49,100 --> 00:59:51,110
就像你采取

1494
00:59:51,110 --> 00:59:53,690
最好的计划，第二好的计划运行

1495
00:59:53,690 --> 00:59:55,430
它们并改进最好的计划

1496
00:59:55,430 --> 00:59:57,650
实际上是更好的计划这

1497
00:59:57,650 --> 00:59:58,940
是我们想要在我们自己的

1498
00:59:58,940 --> 01:00:01,100
系统中做的事情 拥有潜在的基础设施

1499
01:00:01,100 --> 01:00:03,440
和优化器 这

1500
01:00:03,440 --> 01:00:04,640
只是我们还没有构建测试你

1501
01:00:04,640 --> 01:00:06,650
知道测试框架来实现它

1502
01:00:06,650 --> 01:00:10,580
所以 Orko 非常酷 Oracle

1503
01:00:10,580 --> 01:00:12,170
是第一个独立的查询

1504
01:00:12,170 --> 01:00:13,670
优化器框架之一，至少在现代

1505
01:00:13,670 --> 01:00:19,370
区域时代得到了 + + + + Columbia

1506
01:00:19,370 --> 01:00:21,530
的支持 90 年代，但据我在

1507
01:00:21,530 --> 01:00:23,450
网上的代码中知道，但你知道它已经

1508
01:00:23,450 --> 01:00:25,310
过时了，实际上没有人使用我

1509
01:00:25,310 --> 01:00:27,080
可能没有维护过的，而

1510
01:00:27,080 --> 01:00:29,320
orc 实际上维护了另一个

1511
01:00:29,320 --> 01:00:31,430
实际上更受欢迎的优化器框架，

1512
01:00:31,430 --> 01:00:33,950
我认为至少

1513
01:00:33,950 --> 01:00:35,120
当我在 Orca 时 我从 David 的公司说起

1514
01:00:35,120 --> 01:00:37,610
这个东西叫做 calcite 所以

1515
01:00:37,610 --> 01:00:40,000
这是另一个独立的代码

1516
01:00:40,000 --> 01:00:42,680
优化框架，你可以在其中

1517
01:00:42,680 --> 01:00:46,790
指定你知道什么数据

1518
01:00:46,790 --> 01:00:48,050
模型你想使用什么疯狂的

1519
01:00:48,050 --> 01:00:48,950
语言你支持什么成本

1520
01:00:48,950 --> 01:00:50,180
模型和所有

1521
01:00:50,180 --> 01:00:51,590
你想要的转换 再次申请它只是

1522
01:00:51,590 --> 01:00:53,570
将它们编译下来并且可以为您完成所有这一切

1523
01:00:53,570 --> 01:00:54,790


1524
01:00:54,790 --> 01:00:58,160
所以它最初来自 lucidi be

1525
01:00:58,160 --> 01:01:00,470
lucid DB 是一个基于 Java 的数据库

1526
01:01:00,470 --> 01:01:04,040
系统启动 ou 在 2000 年代后期

1527
01:01:04,040 --> 01:01:06,740
，许多不同的初创公司

1528
01:01:06,740 --> 01:01:08,900
实际上都失败了，其中很多都失败了，但是

1529
01:01:08,900 --> 01:01:10,400
从 lucidi B 的灰烬中出来的

1530
01:01:10,400 --> 01:01:12,200
是实际的查询优化器，

1531
01:01:12,200 --> 01:01:15,860
然后像 Cal 所说的那样开源，如果

1532
01:01:15,860 --> 01:01:17,810
一切都是用 Java 编写的，并且有

1533
01:01:17,810 --> 01:01:20,690
一个相当 许多数据库启动

1534
01:01:20,690 --> 01:01:22,340
项目开源和闭源

1535
01:01:22,340 --> 01:01:24,500
，有兴趣实际

1536
01:01:24,500 --> 01:01:27,500
使用 Kaltura 或者我们正在积极使用它

1537
01:01:27,500 --> 01:01:30,380
或追求采用它一些

1538
01:01:30,380 --> 01:01:32,230
例子是omnis 我听说 DB

1539
01:01:32,230 --> 01:01:34,970
在续集 Apache hive spliced

1540
01:01:34,970 --> 01:01:37,340
machine 中播放，我知道 也许另外两个

1541
01:01:37,340 --> 01:01:39,740
已经谈论过他们想要开始

1542
01:01:39,740 --> 01:01:41,990
使用它现在他们都用它

1543
01:01:41,990 --> 01:01:45,680
来做不同的层次所以这个方解石也

1544
01:01:45,680 --> 01:01:47,089
为你提供了续集解析器，

1545
01:01:47,089 --> 01:01:49,300
所以他们中的一些人使用了两个相等的部分

1546
01:01:49,300 --> 01:01:52,310
，方解石有七种方言一些

1547
01:01:52,310 --> 01:01:53,660
他们中的一些人正在使用它来激活您的

1548
01:01:53,660 --> 01:01:55,700
查询优化我还没有看到

1549
01:01:55,700 --> 01:01:59,599
关于它实际上有多好的报告，但我

1550
01:01:59,599 --> 01:02:01,160
再次认为这似乎对这个问题有很大的

1551
01:02:01,160 --> 01:02:02,990
吸引力，因为 这是

1552
01:02:02,990 --> 01:02:05,750
Apache 项目，而无论出于何种原因，Orca

1553
01:02:05,750 --> 01:02:07,640
可能是因为关键的石头拥有

1554
01:02:07,640 --> 01:02:11,450
它，据他们所知，只有

1555
01:02:11,450 --> 01:02:13,400
关键的 Xin 使用 Orca，即使

1556
01:02:13,400 --> 01:02:16,820
它是开源的，所以我认为对于这个项目，

1557
01:02:16,820 --> 01:02:18,200
您会在

1558
01:02:18,200 --> 01:02:20,900
系统中看到更多 继续我们将讨论的最后一个

1559
01:02:20,900 --> 01:02:22,460
优化器的含义

1560
01:02:22,460 --> 01:02:26,619
是他们的续集这并不是什么

1561
01:02:26,619 --> 01:02:30,530
令人兴奋的原因我提出

1562
01:02:30,530 --> 01:02:31,820
它因为他们做的一件事与

1563
01:02:31,820 --> 01:02:34,040
我们在这里讨论的其他优化器略有不同

1564
01:02:34,040 --> 01:02:37,400
，这可能是

1565
01:02:37,400 --> 01:02:39,650
因为他们的目标是

1566
01:02:39,650 --> 01:02:41,030
分布式分布式数据库系统环境

1567
01:02:41,030 --> 01:02:44,359
，我们在本学期根本没有真正关注这个环境，

1568
01:02:44,359 --> 01:02:46,670
但这只是我们

1569
01:02:46,670 --> 01:02:47,900
有点值得提出并

1570
01:02:47,900 --> 01:02:50,540
了解你知道

1571
01:02:50,540 --> 01:02:53,150
人们可以做的事情的类型 一个查询优化器，所以

1572
01:02:53,150 --> 01:02:54,980
它会有三个阶段，

1573
01:02:54,980 --> 01:02:56,540
就像分层方法一样，你会有

1574
01:02:56,540 --> 01:02:58,460
很多重写器，它有很多

1575
01:02:58,460 --> 01:03:00,920
透明的转换，但

1576
01:03:00,920 --> 01:03:02,839
这些逻辑逻辑转换

1577
01:03:02,839 --> 01:03:05,000
实际上可以使用成本模型，然后

1578
01:03:05,000 --> 01:03:06,109
他们进行逻辑物理

1579
01:03:06,109 --> 01:03:07,790
转换，这

1580
01:03:07,790 --> 01:03:10,160
主要是一种动态编程方法来

1581
01:03:10,160 --> 01:03:13,339
进行连接重新排序，但现在

1582
01:03:13,339 --> 01:03:15,560
是最后一个阶段，他们实际上将

1583
01:03:15,560 --> 01:03:17,030
采取物理计划 你

1584
01:03:17,030 --> 01:03:19,130
离开分子，然后把它转换

1585
01:03:19,130 --> 01:03:20,869
回续集，但他们会

1586
01:03:20,869 --> 01:03:22,640
用一些额外的

1587
01:03:22,640 --> 01:03:25,609
内存来注释续集，看看移动数据的命令的鬼魂

1588
01:03:25,609 --> 01:03:27,830
，续集

1589
01:03:27,830 --> 01:03:29,690
可以实际指定的方式违背

1590
01:03:29,690 --> 01:03:30,740
自我高层不” 不是说文本数据在哪里，

1591
01:03:30,740 --> 01:03:32,420
但现在我们要在这里添加命令

1592
01:03:32,420 --> 01:03:33,920
，说好运行这个查询

1593
01:03:33,920 --> 01:03:36,440
，然后将数据发送到这台这台

1594
01:03:36,440 --> 01:03:39,430
特定的机器和你的集群中，

1595
01:03:39,430 --> 01:03:41,810
所以这部分非常有趣，

1596
01:03:41,810 --> 01:03:44,089
我从来没有真正

1597
01:03:44,089 --> 01:03:46,339
从优化器的角度

1598
01:03:46,339 --> 01:03:47,630
听说这样做我听说过这个是为了测试

1599
01:03:47,630 --> 01:03:50,109
人们采取

1600
01:03:50,109 --> 01:03:52,130
由他们的优化器产生的物理计划，

1601
01:03:52,130 --> 01:03:54,540
然后将其反转回续集并

1602
01:03:54,540 --> 01:03:56,640
查看 如果你再次运行它作为优化

1603
01:03:56,640 --> 01:03:58,860
器，它会生成相同的计划器

1604
01:03:58,860 --> 01:04:01,560
或逻辑上等效的计划，但我

1605
01:04:01,560 --> 01:04:02,640
从未听说过他们将

1606
01:04:02,640 --> 01:04:03,570
其转换回续集，然后实际

1607
01:04:03,570 --> 01:04:05,310
执行它，然后再次解析它，

1608
01:04:05,310 --> 01:04:08,700
这就是 他们

1609
01:04:08,700 --> 01:04:10,200
用于查询优化器的管道，它

1610
01:04:10,200 --> 01:04:12,030
看起来很像我到目前为止所讨论的内容

1611
01:04:12,030 --> 01:04:14,130
，您解析它，然后绑定它，

1612
01:04:14,130 --> 01:04:15,900
然后进行重写或枚举阶段

1613
01:04:15,900 --> 01:04:18,930
，然后您采用物理计划，

1614
01:04:18,930 --> 01:04:21,240
然后这个计划器将其转换为

1615
01:04:21,240 --> 01:04:23,550
续集和 然后你将它发送到所有

1616
01:04:23,550 --> 01:04:25,560
间隔执行节点，然后他们将再次

1617
01:04:25,560 --> 01:04:27,720
执行所有这些相同的步骤，

1618
01:04:27,720 --> 01:04:30,750
除了最后一个这里，

1619
01:04:30,750 --> 01:04:33,150
因为现在的想法是我们

1620
01:04:33,150 --> 01:04:35,940
希望每个拥有数据的本地节点

1621
01:04:35,940 --> 01:04:38,970
做出决定 如何实际

1622
01:04:38,970 --> 01:04:42,000
进行最低级别的放置

1623
01:04:42,000 --> 01:04:43,680
优化，例如重音方法之类的

1624
01:04:43,680 --> 01:04:45,450
事情，所以思考这个问题的

1625
01:04:45,450 --> 01:04:48,480
方式就像说我想做一个连接或说我

1626
01:04:48,480 --> 01:04:51,210
想在一个表上扫描五个

1627
01:04:51,210 --> 01:04:54,090
节点和一些 e 节点可能数据

1628
01:04:54,090 --> 01:04:55,530
具有

1629
01:04:55,530 --> 01:04:57,810
与其他节点不同的某些不同分布，因此，

1630
01:04:57,810 --> 01:05:00,210
而不是我和全局

1631
01:05:00,210 --> 01:05:02,370
规划器尝试决定

1632
01:05:02,370 --> 01:05:04,110
在所有五个节点上执行此查询的最佳方式

1633
01:05:04,110 --> 01:05:07,110
我会想出一个高

1634
01:05:07,110 --> 01:05:08,940
关于我们希望如何

1635
01:05:08,940 --> 01:05:11,580
在第一阶段移动数据的全局计划，

1636
01:05:11,580 --> 01:05:13,860
然后我发送从政治计划中重新生成的后续查询 将其

1637
01:05:13,860 --> 01:05:16,530


1638
01:05:16,530 --> 01:05:19,740
发送到本地节点，

1639
01:05:19,740 --> 01:05:21,930
然后他们现在可以做出像 oh now 这样的决定

1640
01:05:21,930 --> 01:05:25,200
我知道，因为我对

1641
01:05:25,200 --> 01:05:26,820
我的数据的外观有更准确的了解，因为它对我来说是

1642
01:05:26,820 --> 01:05:27,540
本地的，

1643
01:05:27,540 --> 01:05:29,250
所以我可以更好地决定如何

1644
01:05:29,250 --> 01:05:31,400
在该节点上再次超出该计划

1645
01:05:31,400 --> 01:05:34,620
据我所知，大多数分布式数据库

1646
01:05:34,620 --> 01:05:36,330
都做不到 最后一步，

1647
01:05:36,330 --> 01:05:38,010
他们制定了一个物理计划，然后将

1648
01:05:38,010 --> 01:05:40,890
其发送到所有单个节点，我

1649
01:05:40,890 --> 01:05:45,270
认为这很有趣，

1650
01:05:45,270 --> 01:05:51,360
所以为了完成主要内容，

1651
01:05:51,360 --> 01:05:53,040
您应该完全摆脱

1652
01:05:53,040 --> 01:05:54,900
我们查看动态编程应用程序的所有

1653
01:05:54,900 --> 01:05:55,830
内容 我们看看

1654
01:05:55,830 --> 01:05:59,400
Cascades 方法，这些是寻找物理计划的两种方法的开始，

1655
01:05:59,400 --> 01:06:03,750


1656
01:06:03,750 --> 01:06:06,779


1657
01:06:06,779 --> 01:06:09,089
尽管如果您没有良好的成本，所有这些都会使我

1658
01:06:09,089 --> 01:06:11,039
高度依赖于拥有良好的

1659
01:06:11,039 --> 01:06:13,559
成本模型

1660
01:06:13,559 --> 01:06:14,669
当你做自上而下和自下而上的时候，模型并不重要，

1661
01:06:14,669 --> 01:06:16,529
你会做出

1662
01:06:16,529 --> 01:06:18,900
错误的决定，你在他们的计划

1663
01:06:18,900 --> 01:06:22,140
中会很糟糕，所以

1664
01:06:22,140 --> 01:06:26,669
我们将在下周下周三看到

1665
01:06:26,669 --> 01:06:29,429
这些成本有多糟糕 模型

1666
01:06:29,429 --> 01:06:31,619
实际上会得到特别是我们

1667
01:06:31,619 --> 01:06:33,419
使用连接进行基数估计，

1668
01:06:33,419 --> 01:06:35,519
所以没有什么神奇的方法可以让这个

1669
01:06:35,519 --> 01:06:37,829
工作，所以当我说续集服务器

1670
01:06:37,829 --> 01:06:39,749
有最好的查询优化器时，研究

1671
01:06:39,749 --> 01:06:41,400
表明它实际上选择了最好的计划

1672
01:06:41,400 --> 01:06:44,039
，这可能是因为他们有

1673
01:06:44,039 --> 01:06:46,199
最佳成本模型和成本最佳估算

1674
01:06:46,199 --> 01:06:51,449
好的，所以让我们快速回顾

1675
01:06:51,449 --> 01:06:53,099
一下您对项目的期望

1676
01:06:53,099 --> 01:06:55,079
三个代码审查 再次正如

1677
01:06:55,079 --> 01:06:57,299
我在本周三作为

1678
01:06:57,299 --> 01:06:59,359
项目演示或项目更新的一部分所说的那样 s

1679
01:06:59,359 --> 01:07:01,319
每个组都必须向

1680
01:07:01,319 --> 01:07:03,959
github 上的 master 分支发送拉取请求，

1681
01:07:03,959 --> 01:07:07,319
因此这将启动构建，

1682
01:07:07,319 --> 01:07:08,729
如果失败，Travis 可以忽略它，

1683
01:07:08,729 --> 01:07:10,380
但我将在 Jenkins 上启动构建，

1684
01:07:10,380 --> 01:07:12,179
而我们确实需要该构建 注意

1685
01:07:12,179 --> 01:07:15,349
并竞争您的代码覆盖率，因此

1686
01:07:15,349 --> 01:07:18,089
对于这一点，您的 PR 需要能够

1687
01:07:18,089 --> 01:07:19,439
干净地合并到 master 分支中，这

1688
01:07:19,439 --> 01:07:21,239
意味着您想要进行 rebase 获取

1689
01:07:21,239 --> 01:07:23,819
我们所有的最新更改，具体取决于你们何时

1690
01:07:23,819 --> 01:07:25,409
从我们那里分叉代码 这

1691
01:07:25,409 --> 01:07:28,409
不应该意味着有很多变化，所以

1692
01:07:28,409 --> 01:07:30,119
会发生什么是你去

1693
01:07:30,119 --> 01:07:30,809
谷歌电子表格

1694
01:07:30,809 --> 01:07:32,939
我现在不敬酒广场你

1695
01:07:32,939 --> 01:07:35,819
把你的拉取请求的链接放在那里然后

1696
01:07:35,819 --> 01:07:37,499
我会让你签到另一个小组你们

1697
01:07:37,499 --> 01:07:41,390
去 进入我会给你一个在

1698
01:07:41,390 --> 01:07:44,069
github 上的访问你可以评论

1699
01:07:44,069 --> 01:07:45,989
在 github 上针对其他团队的

1700
01:07:45,989 --> 01:07:48,299
拉取请求进行代码审查，我会跟踪

1701
01:07:48,299 --> 01:07:51,359
谁在参与，这个想法是

1702
01:07:51,359 --> 01:07:53,819
当拉取请求完成或

1703
01:07:53,819 --> 01:07:54,949
代码 从现在起的一周内完成审查

1704
01:07:54,949 --> 01:07:57,779
您所在的团队 eviewed 将采纳

1705
01:07:57,779 --> 01:07:59,009
您的建议 采纳您的意见

1706
01:07:59,009 --> 01:08:00,239
并实际将它们

1707
01:08:00,239 --> 01:08:02,849
合并到您的代码中，当我们接近结束在这个牧场时，我们

1708
01:08:02,849 --> 01:08:04,709
将再次进行另一轮代码

1709
01:08:04,709 --> 01:08:07,289
审查，

1710
01:08:07,289 --> 01:08:10,409
所以最

1711
01:08:10,409 --> 01:08:11,789
重要的是 否则我们应该是你希望你的

1712
01:08:11,789 --> 01:08:13,499
代码审查有帮助会

1713
01:08:13,499 --> 01:08:16,738
礼貌你不想对你的同学过度

1714
01:08:16,738 --> 01:08:18,149
贬低或严厉

1715
01:08:18,149 --> 01:08:21,479
所以不要

1716
01:08:21,479 --> 01:08:22,799
说这是最糟糕的曲线见过我的

1717
01:08:22,799 --> 01:08:24,960
妻子没有 如果你

1718
01:08:24,960 --> 01:08:27,000
想对他们的项目提出建设性的批评，请帮助任何人，

1719
01:08:27,000 --> 01:08:31,408
所以这些

1720
01:08:31,408 --> 01:08:32,759
只是关于

1721
01:08:32,759 --> 01:08:34,529
如何实际进行代码

1722
01:08:34,529 --> 01:08:37,439
审查的一些一般提示，所以对于小组来说，史密斯是

1723
01:08:37,439 --> 01:08:38,460
代码审查或史密斯是你想要包括的拉取请求

1724
01:08:38,460 --> 01:08:40,738


1725
01:08:40,738 --> 01:08:42,689
关于您希望审查团队查看哪些文件、

1726
01:08:42,689 --> 01:08:44,969
功能和方法的摘要和信息，

1727
01:08:44,969 --> 01:08:46,859


1728
01:08:46,859 --> 01:08:48,299
如果您有

1729
01:08:48,299 --> 01:08:50,399
包含所有这些更改和其中一些更改的巨大拉取请求，则对我们没有帮助

1730
01:08:50,399 --> 01:08:51,479
es 是一项正在进行的工作

1731
01:08:51,479 --> 01:08:52,890
，您实际上并不需要对

1732
01:08:52,890 --> 01:08:55,049
它们的反馈，因此您想在

1733
01:08:55,049 --> 01:08:56,040
您的摘要中输入您应该提供

1734
01:08:56,040 --> 01:08:58,109
信息，例如这里是文件列表

1735
01:08:58,109 --> 01:08:59,790
或这里是您

1736
01:08:59,790 --> 01:09:01,549
希望其他团队提供的功能列表 现在为您审查

1737
01:09:01,549 --> 01:09:04,890
当您进行审查时，您想

1738
01:09:04,890 --> 01:09:06,569
尝试限制自己一次只能查看

1739
01:09:06,569 --> 01:09:08,549
400 行代码

1740
01:09:08,549 --> 01:09:11,158
，并为

1741
01:09:11,158 --> 01:09:12,658
您坐下来进行审查的任何时间

1742
01:09:12,658 --> 01:09:14,670
设置最大限制 60 分钟，因为

1743
01:09:14,670 --> 01:09:17,580
60 分钟后一切都变得模糊，

1744
01:09:17,580 --> 01:09:19,229
你只是留下愚蠢的评论，

1745
01:09:19,229 --> 01:09:21,330
你错过了明显的错误，所以

1746
01:09:21,330 --> 01:09:22,589
我们有点限制自己一次

1747
01:09:22,589 --> 01:09:23,729
查看这么多代码

1748
01:09:23,729 --> 01:09:26,069
，然后什么时候 你进入执行

1749
01:09:26,069 --> 01:09:27,179
拉取请求你想要有一个

1750
01:09:27,179 --> 01:09:29,908
清单左右当你进入

1751
01:09:29,908 --> 01:09:31,290
代码视图时你想要

1752
01:09:31,290 --> 01:09:33,540
在旁边设置一个清单来

1753
01:09:33,540 --> 01:09:34,770
说明你实际上在寻找什么，你怎么

1754
01:09:34,770 --> 01:09:37,589
能 实际上提供帮助，所以这些

1755
01:09:37,589 --> 01:09:40,380
是一些事情 我

1756
01:09:40,380 --> 01:09:42,689
建议您应该

1757
01:09:42,689 --> 01:09:44,969
在代码视图中查看或注意何时执行此操作，因此

1758
01:09:44,969 --> 01:09:46,679
最重要的是代码是否

1759
01:09:46,679 --> 01:09:48,000
正确工作，您应该知道

1760
01:09:48,000 --> 01:09:50,100
应该编译以通过您

1761
01:09:50,100 --> 01:09:52,290
拥有的任何测试 因为他们

1762
01:09:52,290 --> 01:09:54,840
在池类中的代码都是很容易理解的代码，

1763
01:09:54,840 --> 01:09:57,060
就像它

1764
01:09:57,060 --> 01:09:59,730
不是你知道的神秘的汇编代码

1765
01:09:59,730 --> 01:10:02,760
或不明显的奇怪的内在代码，

1766
01:10:02,760 --> 01:10:04,830
并确保

1767
01:10:04,830 --> 01:10:06,390
代码让你知道人们没有这些

1768
01:10:06,390 --> 01:10:07,920
巨大的功能 做很多事情

1769
01:10:07,920 --> 01:10:11,699
确保事情被分解成你

1770
01:10:11,699 --> 01:10:14,640
知道好的可组合块我们避免任何

1771
01:10:14,640 --> 01:10:16,350
重复的代码并再次避免任何注释掉的

1772
01:10:16,350 --> 01:10:18,960
代码是代码模块化

1773
01:10:18,960 --> 01:10:21,510
尽可能的我们知道全局变量我们

1774
01:10:21,510 --> 01:10:23,159
不能我不认为我们 检查这一点，

1775
01:10:23,159 --> 01:10:24,760


1776
01:10:24,760 --> 01:10:26,469
但我认为作为一个人

1777
01:10:26,469 --> 01:10:30,010
，如果他们有任何调试输出，你必须检查这一点

1778
01:10:30,010 --> 01:10:31,659
，以确保

1779
01:10:31,659 --> 01:10:33,940
使用这个调试功能的反应会让

1780
01:10:33,940 --> 01:10:36,489
你知道打印 f 雪标准 C

1781
01:10:36,489 --> 01:10:40,179
输出正确 好吧

1782
01:10:40,179 --> 01:10:41,829
，当您

1783
01:10:41,829 --> 01:10:43,989
在 github 上提交拉取请求时，脚本会检查，但您

1784
01:10:43,989 --> 01:10:45,519
知道通常确保他们

1785
01:10:45,519 --> 01:10:48,159
正确地做这些事情 一切都

1786
01:10:48,159 --> 01:10:49,929
应该被记录下来，以便

1787
01:10:49,929 --> 01:10:51,159
对代码的评论实际上应该

1788
01:10:51,159 --> 01:10:52,690
描述什么 是代码的真正意图，

1789
01:10:52,690 --> 01:10:55,900
所有函数都应该遵循

1790
01:10:55,900 --> 01:10:57,969
doxygen Javadoc 格式，并且

1791
01:10:57,969 --> 01:11:00,039
在 Jenkins 中再次检查了这一点，

1792
01:11:00,039 --> 01:11:01,059
确保如果

1793
01:11:01,059 --> 01:11:03,400


1794
01:11:03,400 --> 01:11:05,079
代码中发生任何奇怪的事情，

1795
01:11:05,079 --> 01:11:07,389
通过阅读就可以理解 如果您使用第三方库，它

1796
01:11:07,389 --> 01:11:08,949
确保实际上完全

1797
01:11:08,949 --> 01:11:11,079
记录了系统组件的预期行为是什么

1798
01:11:11,079 --> 01:11:13,360
如果

1799
01:11:13,360 --> 01:11:15,489
您使用第三方库

1800
01:11:15,489 --> 01:11:16,959
确保这是可以理解的

1801
01:11:16,959 --> 01:11:19,030
为什么我们使用该第三方库

1802
01:11:19,030 --> 01:11:21,159
并且有任何代码 单身，

1803
01:11:21,159 --> 01:11:23,590
你知道吗，你应该做

1804
01:11:23,590 --> 01:11:25,090
一些实际标记

1805
01:11:25,090 --> 01:11:26,650
正确的陈述，说明他们

1806
01:11:26,650 --> 01:11:29,260
实际上正在做的测试是什么

1807
01:11:29,260 --> 01:11:31,749
关于

1808
01:11:31,749 --> 01:11:34,389
你的项目的首要规则是代码

1809
01:11:34,389 --> 01:11:36,269
覆盖率永远不会降低你的测试

1810
01:11:36,269 --> 01:11:39,880
你的测试人员实际上是有意义的，所以

1811
01:11:39,880 --> 01:11:41,079
这意味着你不能让

1812
01:11:41,079 --> 01:11:43,570
你知道的测试运行一些代码

1813
01:11:43,570 --> 01:11:45,340
然后打印标准输出，那就是

1814
01:11:45,340 --> 01:11:46,150
你如何检查我是否真的会

1815
01:11:46,150 --> 01:11:47,650
做正确的事情 它

1816
01:11:47,650 --> 01:11:49,119
实际上应该进行严格的检查以

1817
01:11:49,119 --> 01:11:51,940
确保功能和

1818
01:11:51,940 --> 01:11:54,940
行为正确运行

1819
01:11:54,940 --> 01:11:56,530
所以测试是否完整 它们是否

1820
01:11:56,530 --> 01:11:58,630
全面 它们实际上是在测试

1821
01:11:58,630 --> 01:12:02,889
它们必须是什么 测试，我们希望

1822
01:12:02,889 --> 01:12:04,959
尽量减少我们在测试中的硬编码答案的数量，

1823
01:12:04,959 --> 01:12:07,209
现在并非

1824
01:12:07,209 --> 01:12:11,409
我们所有的测试都以这种方式工作，但是您知道是否

1825
01:12:11,409 --> 01:12:15,010
有一种方法可以在没有硬编码常量值的情况下推导出正确的

1826
01:12:15,010 --> 01:12:17,079
预期输出

1827
01:12:17,079 --> 01:12:18,940


1828
01:12:18,940 --> 01:12:21,039
如果我们

1829
01:12:21,039 --> 01:12:24,820
调整您的测试用例并且我们没有

1830
01:12:24,820 --> 01:12:26,739
一堆人知道错误的错误

1831
01:12:26,739 --> 01:12:27,999
或花时间找出

1832
01:12:27,999 --> 01:12:29,199
那个 n，那将是可取的 ew 常数值实际上

1833
01:12:29,199 --> 01:12:31,110
应该没问题，

1834
01:12:31,110 --> 01:12:33,129
所以我会再次发布

1835
01:12:33,129 --> 01:12:35,110
这个关于 Piazza 的这些信息的更新

1836
01:12:35,110 --> 01:12:37,239
以及对你的期望，我

1837
01:12:37,239 --> 01:12:38,889
将在本周三的项目提案中讨论这个问题，

1838
01:12:38,889 --> 01:12:41,760


1839
01:12:41,760 --> 01:12:45,159
所以下一节课将是一个 关于

1840
01:12:45,159 --> 01:12:47,139
我称之为非传统查询

1841
01:12:47,139 --> 01:12:49,360
优化方法的新讲座，这里的想法

1842
01:12:49,360 --> 01:12:51,729
是 - 现在我们了解

1843
01:12:51,729 --> 01:12:53,469
了类似动态编程的背景，

1844
01:12:53,469 --> 01:12:55,300
因此

1845
01:12:55,300 --> 01:12:57,550
进行查询优化的核心基础让我们看看

1846
01:12:57,550 --> 01:12:59,559
人们可以扩展这些

1847
01:12:59,559 --> 01:13:02,969
技术的不同方式或 尝试额外的事情

1848
01:13:02,969 --> 01:13:05,349
来提高我们的查询

1849
01:13:05,349 --> 01:13:08,939
优化器的效率 好的，大家好，请洗手，

1850
01:13:08,939 --> 01:13:12,570
这是什么

1851
01:13:12,620 --> 01:13:32,829
[音乐]

1852
01:13:34,870 --> 01:13:37,480
不会是一样的 我很高兴

1853
01:13:37,480 --> 01:13:40,740
发言 我说了一个祈祷

