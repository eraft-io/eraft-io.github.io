1
00:00:01,300 --> 00:00:05,129
[音乐]

2
00:00:05,200 --> 00:00:05,930
[掌声]

3
00:00:05,930 --> 00:00:08,630
[音乐]

4
00:00:08,630 --> 00:00:10,020
[掌声]

5
00:00:10,020 --> 00:00:12,170
[音乐]

6
00:00:12,170 --> 00:00:14,000
所以今天我们要

7
00:00:14,000 --> 00:00:16,260
继续讨论现在

8
00:00:16,260 --> 00:00:17,460
实际上如何开始执行查询

9
00:00:17,460 --> 00:00:20,220
所以这是我在几

10
00:00:20,220 --> 00:00:23,310
堂课前展示的只是概述

11
00:00:23,310 --> 00:00:24,900
假设的数据库系统看起来

12
00:00:24,900 --> 00:00:26,340
像一个高性能的现代数据库

13
00:00:26,340 --> 00:00:30,000
系统，所以我们已经介绍了你知道

14
00:00:30,000 --> 00:00:31,590
这里的一些部分和

15
00:00:31,590 --> 00:00:33,059
网络层，现在我们在

16
00:00:33,059 --> 00:00:36,149
这里，我们将继续 这个

17
00:00:36,149 --> 00:00:38,160
方向我们开始了 你知道 谈论

18
00:00:38,160 --> 00:00:39,270


19
00:00:39,270 --> 00:00:41,370
执行 下周的 Cori 执行 我们

20
00:00:41,370 --> 00:00:42,870
谈论了编译 然后我们会

21
00:00:42,870 --> 00:00:45,469
回来做更多的查询执行 然后

22
00:00:45,469 --> 00:00:48,809
在期中或

23
00:00:48,809 --> 00:00:50,520
春假之后谈论代码优化

24
00:00:50,520 --> 00:00:55,440
查询计划 好的 我们

25
00:00:55,440 --> 00:00:57,180
今天

26
00:00:57,180 --> 00:01:01,410
和本学期讨论的想法是如何构建一个

27
00:01:01,410 --> 00:01:03,390
高效的查询执行引擎，

28
00:01:03,390 --> 00:01:04,739
我们在折扣系统中讨论的一些技术之间存在差异，

29
00:01:04,739 --> 00:01:06,180


30
00:01:06,180 --> 00:01:08,340
因为如果我们是

31
00:01:08,340 --> 00:01:11,820
实体 依赖于内存，那么我们就不必

32
00:01:11,820 --> 00:01:13,170
担心

33
00:01:13,170 --> 00:01:14,430
面向磁盘的系统

34
00:01:14,430 --> 00:01:17,460
在磁盘学习系统中不得不担心的主要瓶颈，

35
00:01:17,460 --> 00:01:19,500
目标始终是产生磁盘 i/o，因为

36
00:01:19,500 --> 00:01:21,200
那总是最昂贵的东西

37
00:01:21,200 --> 00:01:24,330
，所以 现在，如果我们没有停顿，

38
00:01:24,330 --> 00:01:26,400
因为我们要获取磁盘来运行

39
00:01:26,400 --> 00:01:28,049
我们的查询，那么现在

40
00:01:28,049 --> 00:01:29,310
我们必须担心其他事情，还有那些

41
00:01:29,310 --> 00:01:31,740


42
00:01:31,740 --> 00:01:33,689
我们将在整个学期讨论的瓶颈

43
00:01:33,689 --> 00:01:35,460
，然后是 我将要

44
00:01:35,460 --> 00:01:37,049
描述的技术将向您展示如何真正

45
00:01:37,049 --> 00:01:39,299
克服它们或减轻它们

46
00:01:39,299 --> 00:01:41,430
对系统性能的影响，

47
00:01:41,430 --> 00:01:44,729
因此我们显然仍然需要磁盘来

48
00:01:44,729 --> 00:01:46,560
记录日志，这样它就不会消失，但它

49
00:01:46,560 --> 00:01:48,329
真的就像我实际做的那样 一个查询，我

50
00:01:48,329 --> 00:01:51,210
可以假设我要读取一个元组

51
00:01:51,210 --> 00:01:52,860
或读取一个列，我们需要一个数据块，

52
00:01:52,860 --> 00:01:58,020
并且它在内存中，

53
00:01:58,020 --> 00:01:59,040
所以它本质上考虑

54
00:01:59,040 --> 00:02:01,259
我们在这里谈论的内容的方式是它

55
00:02:01,259 --> 00:02:03,420
不会有任何 我们要使用的一种技术

56
00:02:03,420 --> 00:02:05,820
这样做会让

57
00:02:05,820 --> 00:02:07,290
一切变得更好 这将是

58
00:02:07,290 --> 00:02:11,640
一种跨多个优化的编排或协调

59
00:02:11,640 --> 00:02:13,440


60
00:02:13,440 --> 00:02:16,560
，通过将它们组合在一起，

61
00:02:16,560 --> 00:02:17,550
我们将获得我们需要的高效执行

62
00:02:17,550 --> 00:02:20,700
性能，因此剧透

63
00:02:20,700 --> 00:02:23,370
就像一个头脑 编译

64
00:02:23,370 --> 00:02:25,200
并行化和矢量化

65
00:02:25,200 --> 00:02:26,760
这些将成为三巨头，但是

66
00:02:26,760 --> 00:02:28,890


67
00:02:28,890 --> 00:02:30,620
随着我们的进行，我们可以谈论的其他事情会受到惩罚，

68
00:02:30,620 --> 00:02:33,540
所以我们在系统中的优化目标是什么，

69
00:02:33,540 --> 00:02:35,640
因此磁盘消失了

70
00:02:35,640 --> 00:02:36,660
我们真正想要关心的是什么 现在

71
00:02:36,660 --> 00:02:39,870
要获得良好的查询驱动性能，

72
00:02:39,870 --> 00:02:43,050
所以第一个是

73
00:02:43,050 --> 00:02:46,620
显而易见的，我们将要成为的我们

74
00:02:46,620 --> 00:02:49,140
只想减少我们在执行查询时所做的事情

75
00:02:49,140 --> 00:02:50,970
，我们可以做到这一点我

76
00:02:50,970 --> 00:02:55,230
预测戴维森起诉

77
00:02:55,230 --> 00:02:58,080
的次数 为了处理查询，所以我们

78
00:02:58,080 --> 00:02:59,970
希望执行更少的指令来

79
00:02:59,970 --> 00:03:03,210
完成相同的工作量，这就是你

80
00:03:03,210 --> 00:03:04,170
知道的那样我们将获得更好的性能

81
00:03:04,170 --> 00:03:07,770
，因此编译 ler 会帮助

82
00:03:07,770 --> 00:03:10,170
我们一点，就像我们可以传入

83
00:03:10,170 --> 00:03:12,720
Oh 通常不要

84
00:03:12,720 --> 00:03:15,390
用 oh 三个编译的二进制文件来运送数据库系统，

85
00:03:15,390 --> 00:03:18,990
因为它不是没有它是

86
00:03:18,990 --> 00:03:20,640
实验性的它只是可能有

87
00:03:20,640 --> 00:03:24,540
一些你可能没有准备好的异常

88
00:03:24,540 --> 00:03:27,150
或者可以考虑哦，二是通常

89
00:03:27,150 --> 00:03:29,790
人们随软件一起发布，所以

90
00:03:29,790 --> 00:03:31,110
编译器没有一点帮助，但

91
00:03:31,110 --> 00:03:33,180
我们最终想要做的是将

92
00:03:33,180 --> 00:03:35,520
我们的数据库系统专门用于

93
00:03:35,520 --> 00:03:37,650
我们再次执行

94
00:03:37,650 --> 00:03:39,540
的 cific 查询 将在下周星期一进行查询编译，

95
00:03:39,540 --> 00:03:41,520
但我们将看到

96
00:03:41,520 --> 00:03:44,730
今天的样子 下一个是

97
00:03:44,730 --> 00:03:48,120
减少执行这些指令时必须产生的周期

98
00:03:48,120 --> 00:03:50,880
所以我们

99
00:03:50,880 --> 00:03:52,350
已经这样做了 我们已经减少

100
00:03:52,350 --> 00:03:53,700
了我们的 指令计数，因此对于

101
00:03:53,700 --> 00:03:55,050
我们必须执行的剩余指令，

102
00:03:55,050 --> 00:03:57,209
我们希望减少

103
00:03:57,209 --> 00:04:00,209
处理它们所需的周期数然后我

104
00:04:00,209 --> 00:04:07,739
知道我们实际上想要如何做到这一点是的，

105
00:04:07,739 --> 00:04:13,620
她说并行化不

106
00:04:13,620 --> 00:04:16,000
完全相同 好吧，

107
00:04:16,000 --> 00:04:17,910
这是瘫痪的矢量化，但是

108
00:04:17,910 --> 00:04:19,470
mmm

109
00:04:19,470 --> 00:04:23,680
cindy 会给我们这个它

110
00:04:23,680 --> 00:04:31,990
不一定会给我们这个 Yassir 分支

111
00:04:31,990 --> 00:04:34,870
错误预测是一个但也会

112
00:04:34,870 --> 00:04:37,570
减少它们我们的缓存未命中我们

113
00:04:37,570 --> 00:04:39,280
如果我们有一条指令需要

114
00:04:39,280 --> 00:04:40,539
触摸一段数据并且那 一块

115
00:04:40,539 --> 00:04:42,880
数据不在我们的 CPU 缓存中，它必须

116
00:04:42,880 --> 00:04:46,300
停止并花费更多的周期

117
00:04:46,300 --> 00:04:47,949
进入 DRAM 以将其带入我们的 CPU 缓存，

118
00:04:47,949 --> 00:04:50,440
因此我们希望

119
00:04:50,440 --> 00:04:51,789
在处理数据时最大化数据的局部性以及

120
00:04:51,789 --> 00:04:54,250


121
00:04:54,250 --> 00:04:58,630


122
00:04:58,630 --> 00:05:00,910
当您处理元组以减少

123
00:05:00,910 --> 00:05:03,550
错误预测的数量时，我们对我们如何在四个循环中拥有分支的方式保持智能，然后

124
00:05:03,550 --> 00:05:04,990
最后一个是你们

125
00:05:04,990 --> 00:05:07,210
两个在这里所说的并行是 8 和

126
00:05:07,210 --> 00:05:09,370
rectorization 这是 只是让

127
00:05:09,370 --> 00:05:11,440
我们现在可以使用

128
00:05:11,440 --> 00:05:14,770
我们自己的 CPU 来

129
00:05:14,770 --> 00:05:17,139
并行处理查询的额外内核，

130
00:05:17,139 --> 00:05:18,190
我们将讨论这些不同的方案，

131
00:05:18,190 --> 00:05:20,470
看起来像今天摩尔定律

132
00:05:20,470 --> 00:05:23,020
基本上结束了 tel 真的不能

133
00:05:23,020 --> 00:05:27,270
再提高时钟速度了

134
00:05:27,270 --> 00:05:30,370
，我们可以用替代材料

135
00:05:30,370 --> 00:05:31,960
来制造我们的处理器

136
00:05:31,960 --> 00:05:34,840


137
00:05:34,840 --> 00:05:36,910


138
00:05:36,910 --> 00:05:39,880


139
00:05:39,880 --> 00:05:41,440
这只是鲍里斯，

140
00:05:41,440 --> 00:05:43,810
我们想要在尽可能多的分数上执行我们的查询

141
00:05:43,810 --> 00:05:45,130
，这

142
00:05:45,130 --> 00:05:46,030
真的很棘手，因为现在当你

143
00:05:46,030 --> 00:05:49,330
可能协调员交叉完成

144
00:05:49,330 --> 00:05:51,820
论文时，我让你们读得

145
00:05:51,820 --> 00:05:54,400
更多一些我要说分析然后

146
00:05:54,400 --> 00:05:56,410
我们' 今天会讨论，但这

147
00:05:56,410 --> 00:05:57,910
就是我选择它的原因，因为

148
00:05:57,910 --> 00:06:00,010
至少它是 FIR 的一个喷发部分，

149
00:06:00,010 --> 00:06:00,340


150
00:06:00,340 --> 00:06:01,960
他们经历了

151
00:06:01,960 --> 00:06:03,449
我们今天要讨论的很多技术

152
00:06:03,449 --> 00:06:05,680
，只是向你展示了

153
00:06:05,680 --> 00:06:08,139
很多不同之处 你可以做你

154
00:06:08,139 --> 00:06:10,120
知道如何设计系统来执行

155
00:06:10,120 --> 00:06:12,520
仍然是 OLAP 的查询，

156
00:06:12,520 --> 00:06:14,169
这将主要是我们

157
00:06:14,169 --> 00:06:16,930
今天讲座的重点，但他们再次

158
00:06:16,930 --> 00:06:18,219
谈到了

159
00:06:18,219 --> 00:06:19,750
我应该做一个 in X probe whi 之间的区别 ch 是

160
00:06:19,750 --> 00:06:21,220
随机 i/o 或

161
00:06:21,220 --> 00:06:23,950
特殊扫描，

162
00:06:23,950 --> 00:06:25,360
当您想使用一个与另一个时，没有人可以回答我

163
00:06:25,360 --> 00:06:27,640


164
00:06:27,640 --> 00:06:30,090
想让您摆脱它的主要事情是，

165
00:06:30,090 --> 00:06:32,350
通常在 Discordian 系统中，它

166
00:06:32,350 --> 00:06:35,250
始终是 如果我没有索引并且我有一个可以在索引上使用的谓词，它总是会

167
00:06:35,250 --> 00:06:37,660
做出关于老兄 Enix 是否可以

168
00:06:37,660 --> 00:06:39,370
根据谓词的选择性响应扫描的决定

169
00:06:39,370 --> 00:06:41,410


170
00:06:41,410 --> 00:06:42,610


171
00:06:42,610 --> 00:06:43,180


172
00:06:43,180 --> 00:06:44,770
我认为我会得到多少个元组

173
00:06:44,770 --> 00:06:47,770
从内存世界中的索引回来，

174
00:06:47,770 --> 00:06:49,990
我们实际上确实关心

175
00:06:49,990 --> 00:06:51,190
港口的性能

176
00:06:51,190 --> 00:06:53,440
会是什么样子，

177
00:06:53,440 --> 00:06:55,270
当我们执行我们的数据库系统时 CPU 将实际执行的操作

178
00:06:55,270 --> 00:06:57,340
以及

179
00:06:57,340 --> 00:07:00,130
同时运行的其他查询 时间和这个

180
00:07:00,130 --> 00:07:01,540
有点棘手，因为这个需要

181
00:07:01,540 --> 00:07:04,270
你知道，现在我们需要让优化

182
00:07:04,270 --> 00:07:06,400
器知道同时运行的其他东西

183
00:07:06,400 --> 00:07:09,490
，然后你

184
00:07:09,490 --> 00:07:10,060
根据它做出决定，

185
00:07:10,060 --> 00:07:13,180
所以你只看到这个应用这个

186
00:07:13,180 --> 00:07:14,890
技术在 高端商业

187
00:07:14,890 --> 00:07:15,640


188
00:07:15,640 --> 00:07:17,320
像我这样的数据库系统 Postgres 不会

189
00:07:17,320 --> 00:07:18,400
查看同时运行的其他查询，

190
00:07:18,400 --> 00:07:19,930
因为很难做到

191
00:07:19,930 --> 00:07:21,550
这一点，因为这就像

192
00:07:21,550 --> 00:07:23,080
我通过优化器运行的查询一样，我

193
00:07:23,080 --> 00:07:25,419
要选择可能是什么

194
00:07:25,419 --> 00:07:27,310
当我的查询从

195
00:07:27,310 --> 00:07:28,900
优化器出来并开始运行那些其他查询时运行相同的

196
00:07:28,900 --> 00:07:30,220
可能是错误的所以我的

197
00:07:30,220 --> 00:07:33,070
决定可能是不正确的所以这个

198
00:07:33,070 --> 00:07:35,290
很难做到这一点你可以

199
00:07:35,290 --> 00:07:37,030
在开始时计算虽然它可能

200
00:07:37,030 --> 00:07:38,680
会有所不同 你在亚马逊上运行是

201
00:07:38,680 --> 00:07:41,050
因为你知道即使你得到

202
00:07:41,050 --> 00:07:42,550
相同的实例类型，性能可能会

203
00:07:42,550 --> 00:07:44,410
改变我认为高达 20%

204
00:07:44,410 --> 00:07:45,640
因为其他人可能

205
00:07:45,640 --> 00:07:47,550
和你一样在同一个盒子上运行，

206
00:07:47,550 --> 00:07:50,890
所以类型 我们将

207
00:07:50,890 --> 00:07:52,270
应用他们在那篇

208
00:07:52,270 --> 00:07:53,770
论文中谈到的优化以及

209
00:07:53,770 --> 00:07:56,020
我们今天将讨论的一些其他优化就是我们将

210
00:07:56,020 --> 00:07:57,100
如何实际处理

211
00:07:57,100 --> 00:07:58,870
查询我们将如何将数据从一个

212
00:07:58,870 --> 00:08:00,850
运算符移动到 下一个或 w 在这里，他们

213
00:08:00,850 --> 00:08:02,770
会给您推送或拉取扫描

214
00:08:02,770 --> 00:08:04,650
共享是一种技术，您可以在其中

215
00:08:04,650 --> 00:08:07,060
允许两个或多个

216
00:08:07,060 --> 00:08:09,430
运行相同的查询访问相同的数据以

217
00:08:09,430 --> 00:08:11,830
搭载迭代器，而

218
00:08:11,830 --> 00:08:13,120
不是让每个查询都在同一天读取

219
00:08:13,120 --> 00:08:15,000
同时，将

220
00:08:15,000 --> 00:08:16,810
物化视图组合在一起是一种

221
00:08:16,810 --> 00:08:19,360
提前计算查询的某些部分的方法

222
00:08:19,360 --> 00:08:21,070
，并且可以在表更新时对其进行维护，

223
00:08:21,070 --> 00:08:22,750
以便您可以将其

224
00:08:22,750 --> 00:08:24,340
用于查询执行，因此对于这两个

225
00:08:24,340 --> 00:08:26,320
我们不是 这

226
00:08:26,320 --> 00:08:27,760
学期要谈很多我会尝试稍后

227
00:08:27,760 --> 00:08:30,310
再谈，但

228
00:08:30,310 --> 00:08:31,270
我们将花费大部分时间在这里的其他那些，

229
00:08:31,270 --> 00:08:33,339
因为正如我所说的，这三个

230
00:08:33,339 --> 00:08:34,630
是你获得最大收益的

231
00:08:34,630 --> 00:08:35,479


232
00:08:35,479 --> 00:08:37,760
时候 显然，在某些情况下，

233
00:08:37,760 --> 00:08:39,860
使用屏幕共享实现的工作负载可能

234
00:08:39,860 --> 00:08:42,649
会非常有益，如果您

235
00:08:42,649 --> 00:08:44,240
有很高的机会

236
00:08:44,240 --> 00:08:46,100
利用这些东西的查询，但通常

237
00:08:46,100 --> 00:08:47,720
这些东西是通用的，

238
00:08:47,720 --> 00:08:49,370
我们想要再次查询

239
00:08:49,370 --> 00:08:51,260
com  pilation 是 Co 专业化

240
00:08:51,260 --> 00:08:53,000
向量化 他谈到了使用

241
00:08:53,000 --> 00:08:54,470
Cynthia 指令的并行算法

242
00:08:54,470 --> 00:08:56,269
Lucia 她提到的是

243
00:08:56,269 --> 00:08:57,980
并行运行运算符 然后我们将

244
00:08:57,980 --> 00:09:01,070
完成 animist er 谈论

245
00:09:01,070 --> 00:09:04,459
如何嵌入或人们如何使用 yes 或

246
00:09:04,459 --> 00:09:06,440
用户定义的函数 查询并且

247
00:09:06,440 --> 00:09:09,430
有很大的机会实际上

248
00:09:09,430 --> 00:09:12,110
基本上将它们合并到查询

249
00:09:12,110 --> 00:09:14,480
计划本身中，而不是将

250
00:09:14,480 --> 00:09:16,370
UDF 视为黑盒，并且您

251
00:09:16,370 --> 00:09:19,130
也会获得更好的性能，

252
00:09:19,130 --> 00:09:20,089
因此我们将在学期末

253
00:09:20,089 --> 00:09:22,040
再次削减这些 我们想要讨论的 31 大问题，

254
00:09:22,040 --> 00:09:25,399
所以今天的

255
00:09:25,399 --> 00:09:26,570
议程我们将首先讨论

256
00:09:26,570 --> 00:09:30,320
现代 CPU 在

257
00:09:30,320 --> 00:09:31,910
数据库系统的背景下是什么样子

258
00:09:31,910 --> 00:09:33,560
，当我们需要关心数据库的哪些方面时，

259
00:09:33,560 --> 00:09:35,779
我们需要关心的是

260
00:09:35,779 --> 00:09:37,610
建立我们的数据库系统然后我们将

261
00:09:37,610 --> 00:09:38,839
讨论不同的处理模型

262
00:09:38,839 --> 00:09:40,160
如何在操作员之间移动数据

263
00:09:40,160 --> 00:09:41,630
然后我们将完成

264
00:09:41,630 --> 00:09:43,610
讨论不同的并行

265
00:09:43,610 --> 00:09:45,649
e  xecution 模型 这里的想法

266
00:09:45,649 --> 00:09:46,940
基本上是我们将如何构建

267
00:09:46,940 --> 00:09:49,220
系统以支持同时执行

268
00:09:49,220 --> 00:09:51,319
多个操作符的苍白执行

269
00:09:51,319 --> 00:09:59,990
好吧 15 岁以上

270
00:09:59,990 --> 00:10:05,779
和 2005 年提出了改进版本的

271
00:10:05,779 --> 00:10:07,670
莫奈电视，这是其中之一 原始

272
00:10:07,670 --> 00:10:09,829
开源学术列

273
00:10:09,829 --> 00:10:12,620
存储系统在内存中 Thomas 或 systems 它

274
00:10:12,620 --> 00:10:15,170
是 Monet DB 的改进版本，

275
00:10:15,170 --> 00:10:18,620
他们展示了现有数据库系统

276
00:10:18,620 --> 00:10:21,829
实现如何不足或不

277
00:10:21,829 --> 00:10:24,319
针对现代超标量 CPU 的

278
00:10:24,319 --> 00:10:27,079
外观，以及如果您重新设计

279
00:10:27,079 --> 00:10:29,269
数据库的架构

280
00:10:29,269 --> 00:10:30,740
如果您

281
00:10:30,740 --> 00:10:33,470
以一种理想

282
00:10:33,470 --> 00:10:35,120
或适合 CPU 实际

283
00:10:35,120 --> 00:10:37,339
处理指令的方式编写它，那么您可以获得更好的性能，因此

284
00:10:37,339 --> 00:10:40,579
考虑这一点的方式是大多数时候

285
00:10:40,579 --> 00:10:42,760
人们告诉数据库系统，

286
00:10:42,760 --> 00:10:46,010
当然您知道现在即将到来 但这

287
00:10:46,010 --> 00:10:48,110
在本文中很常见，它们

288
00:10:48,110 --> 00:10:49,190
看起来像我的续集，并且帖子

289
00:10:49,190 --> 00:10:51,230
显示了一个轨道

290
00:10:51,230 --> 00:10:53,380
飞行器 ople 构建软件

291
00:10:53,380 --> 00:10:55,970
他们以这样一种方式构建它，

292
00:10:55,970 --> 00:10:57,890
使人类更容易推理

293
00:10:57,890 --> 00:11:00,170
实际代码实际在做什么的软件，

294
00:11:00,170 --> 00:11:03,350
但事实证明，

295
00:11:03,350 --> 00:11:05,270
对人类来说更容易的方式实际上不

296
00:11:05,270 --> 00:11:08,360
利于 CPU 实际想要的东西等等

297
00:11:08,360 --> 00:11:09,860
他们在这里提出的是，如果你

298
00:11:09,860 --> 00:11:11,630
设计系统的方式

299
00:11:11,630 --> 00:11:13,790
对于普通人来说可能更复杂，

300
00:11:13,790 --> 00:11:14,990
但它实际上

301
00:11:14,990 --> 00:11:16,910
比 CPU 更好，你已经获得

302
00:11:16,910 --> 00:11:18,130
了更好的性能，

303
00:11:18,130 --> 00:11:22,130
所以 Mon ADB X 100 是名字 他们的

304
00:11:22,130 --> 00:11:26,120
原型后来被重命名

305
00:11:26,120 --> 00:11:28,130
并商业化为 vector

306
00:11:28,130 --> 00:11:31,670
wise 然后在它是一家旧软件的控股公司

307
00:11:31,670 --> 00:11:34,570
他们购买了 vector wise

308
00:11:34,570 --> 00:11:38,150
将它重命名为一个 vector

309
00:11:38,150 --> 00:11:39,980
然后他们喜欢将它杀死

310
00:11:39,980 --> 00:11:42,200
几年或者他们击中它

311
00:11:42,200 --> 00:11:43,760
网页，然后每次我教

312
00:11:43,760 --> 00:11:45,590
这门课时，我总是说 vector

313
00:11:45,590 --> 00:11:47,270
wise 太糟糕了痤疮并将其

314
00:11:47,270 --> 00:11:49,040
杀死，然后就像去年或两年前某个家伙给我发电子邮件

315
00:11:49,040 --> 00:11:50,240
说嘿

316
00:11:50,240 --> 00:11:52,130
不不，它仍然存在 这里的

317
00:11:52,130 --> 00:11:53,360
网页实际上就像他们

318
00:11:53,360 --> 00:11:55,040
喜欢该网站竭尽全力

319
00:11:55,040 --> 00:11:56,840
隐藏您可以实际

320
00:11:56,840 --> 00:11:59,780
下载软件的地方这真的很奇怪但

321
00:11:59,780 --> 00:12:01,460
后来他们出来并将

322
00:12:01,460 --> 00:12:03,110
其重新命名为 Avalanche 但他们正在出售

323
00:12:03,110 --> 00:12:05,060
这个 就像那个哦，人工智能中的内存

324
00:12:05,060 --> 00:12:08,750
OLAP 云系统在你

325
00:12:08,750 --> 00:12:13,280
知道 AWS 或 Azure 中运行，所以前几年的

326
00:12:13,280 --> 00:12:15,380
重磅论文第一部分真的

327
00:12:15,380 --> 00:12:17,150
很好第二部分不是那么多，

328
00:12:17,150 --> 00:12:19,190
它有点过时了它是 15 年 以前，

329
00:12:19,190 --> 00:12:20,630
所以他们花了很多时间

330
00:12:20,630 --> 00:12:23,960
谈论我们不再存在的安腾 CPU

331
00:12:23,960 --> 00:12:27,800
，他们谈论您如何了解

332
00:12:27,800 --> 00:12:31,100
具有 31 个阶段的奔腾 4s 流水线，

333
00:12:31,100 --> 00:12:33,740
但显然在现代 CPU 中

334
00:12:33,740 --> 00:12:36,320
，阶段要小得多

335
00:12:36,320 --> 00:12:39,230
像 2015 年，或者当丈夫

336
00:12:39,230 --> 00:12:41,839
Broadwell 出来时，它就像 14 个阶段，

337
00:12:41,839 --> 00:12:44,540
甚至是最新的一个，

338
00:12:44,540 --> 00:12:46,490
比如英特尔的铜湖，我认为 19 个

339
00:12:46,490 --> 00:12:48,560
阶段或没有铜，就像 14 个

340
00:12:48,560 --> 00:12:52,280
阶段，AMD Rison 是 19 个阶段，所以构建

341
00:12:52,280 --> 00:12:53,390
你的系统这样一个 y 处理

342
00:12:53,390 --> 00:12:54,890
这些非常长的管道以及

343
00:12:54,890 --> 00:12:58,370
他们描述的方式并不是仍然很重要，

344
00:12:58,370 --> 00:12:59,930
但与他们之前所做的程度不同，

345
00:12:59,930 --> 00:13:01,850


346
00:13:01,850 --> 00:13:03,080
本文也非常有趣的另一个原因

347
00:13:03,080 --> 00:13:06,350
是多年期债券和 Marcin

348
00:13:06,350 --> 00:13:09,200
Szarkowski Peter 债券回到了 CWI

349
00:13:09,200 --> 00:13:12,740
并且他现在正在研究鸭子结核病 Marcin

350
00:13:12,740 --> 00:13:14,720
基本上离开并共同创立了

351
00:13:14,720 --> 00:13:16,520
雪花和许多雪花

352
00:13:16,520 --> 00:13:19,250
设计的基础是什么博士。

353
00:13:19,250 --> 00:13:22,670
Weis 对系统进行了正确的布局，因此

354
00:13:22,670 --> 00:13:24,230
尽管 vector wise 并不是

355
00:13:24,230 --> 00:13:26,480
那么出名，但雪花

356
00:13:26,480 --> 00:13:28,100
现在非常出名，而且你知道

357
00:13:28,100 --> 00:13:31,430
它是博士的合法继任者。

358
00:13:31,430 --> 00:13:33,950
明智的，所以这将

359
00:13:33,950 --> 00:13:36,500
是两张幻灯片中的速成课程，就像

360
00:13:36,500 --> 00:13:39,110
你所知道的关于 CPU

361
00:13:39,110 --> 00:13:43,430
对数据库很重要的一切一样，所以正如我

362
00:13:43,430 --> 00:13:46,010
所说的那样，一个 CPU 作为小麦是 v 将

363
00:13:46,010 --> 00:13:47,600
根据这些

364
00:13:47,600 --> 00:13:50,630
管道阶段执行指令我和 就像我说的，

365
00:13:50,630 --> 00:13:52,760
英特尔 CPU 有 14 个管道或 14 个

366
00:13:52,760 --> 00:13:55,730
阶段，而 AMD 有 19 个对，所以

367
00:13:55,730 --> 00:13:58,010
它们不是数百个，它

368
00:13:58,010 --> 00:14:00,980
很短，但最终

369
00:14:00,980 --> 00:14:02,300
这些管道的想法是它会

370
00:14:02,300 --> 00:14:05,240
允许 CPU 尝试 一直很忙，

371
00:14:05,240 --> 00:14:10,580
但我在 CPU 的不同部分输入 line

372
00:14:10,580 --> 00:14:13,910
，这样如果一条

373
00:14:13,910 --> 00:14:16,430
指令有一个集水区，它必须

374
00:14:16,430 --> 00:14:17,870
去 D Ram 获取一些需要

375
00:14:17,870 --> 00:14:20,090
处理的数据，但在同一周期内查看

376
00:14:20,090 --> 00:14:21,740
你实际上可以得到一条指令，该指令

377
00:14:21,740 --> 00:14:23,450
可能已经在寄存器中具有数据

378
00:14:23,450 --> 00:14:26,750
，它可以有效地执行，因此它

379
00:14:26,750 --> 00:14:31,040
允许我们执行以

380
00:14:31,040 --> 00:14:32,930
隐藏这些缓存

381
00:14:32,930 --> 00:14:36,080
未命中的所有延迟，但它会

382
00:14:36,080 --> 00:14:37,790
通过执行指令来做到这一点

383
00:14:37,790 --> 00:14:39,920
订单的 在其中它们

384
00:14:39,920 --> 00:14:41,930
进入管道所以这意味着

385
00:14:41,930 --> 00:14:44,000
当您编写代码时编译器

386
00:14:44,000 --> 00:14:45,860
将其转换为 CPU 指令

387
00:14:45,860 --> 00:14:49,160
它处理的机器代码该

388
00:14:49,160 --> 00:14:50,600
指令流允许它们进入

389
00:14:50,600 --> 00:14:53,210
管道 CPU 可能实际上不会

390
00:14:53,210 --> 00:14:55,910
以相同的方式执行它们 它们在该流中定义的顺序，

391
00:14:55,910 --> 00:14:58,610
并且它们将跟踪

392
00:14:58,610 --> 00:15:00,470
不真实的东西，例如依赖关系，以了解

393
00:15:00,470 --> 00:15:02,270
一条指令的输出

394
00:15:02,270 --> 00:15:03,350
用作下一条指令的输入，

395
00:15:03,350 --> 00:15:04,910
它必须确保它

396
00:15:04,910 --> 00:15:08,690
以正确的顺序执行，以便

397
00:15:08,690 --> 00:15:10,070
再次 这些被称为超级超标量

398
00:15:10,070 --> 00:15:14,750
CPU，因此因为我们知道心脏实际上要做什么，所以我们

399
00:15:14,750 --> 00:15:16,130


400
00:15:16,130 --> 00:15:16,460
将

401
00:15:16,460 --> 00:15:18,490
尝试构建我们的数据库系统

402
00:15:18,490 --> 00:15:20,210
执行引擎，在那里我们实际

403
00:15:20,210 --> 00:15:21,410
处理元组，因为这是最

404
00:15:21,410 --> 00:15:24,020
昂贵的部分，以这种方式来

405
00:15:24,020 --> 00:15:26,270
缓解 当港口会犯的愿景出现错误时可能会发生的问题，

406
00:15:26,270 --> 00:15:27,830


407
00:15:27,830 --> 00:15:31,070
所以第一个

408
00:15:31,070 --> 00:15:32,540
问题将是依赖关系，

409
00:15:32,540 --> 00:15:33,920
这就是我所说的，如果 你有一条

410
00:15:33,920 --> 00:15:36,440
指令，该指令的输入取决于

411
00:15:36,440 --> 00:15:37,580


412
00:15:37,580 --> 00:15:39,590
另一条指令的输出 CPU 不能

413
00:15:39,590 --> 00:15:41,450
先执行第二条，它必须

414
00:15:41,450 --> 00:15:42,770
等待第一个完成它，然后

415
00:15:42,770 --> 00:15:45,020
才退出下一条，所以

416
00:15:45,020 --> 00:15:46,520
真的没有 我们可以在我们的

417
00:15:46,520 --> 00:15:51,320
数据库系统中做很多事情来避免这种情况

418
00:15:51,320 --> 00:15:52,550
，就像你知道我

419
00:15:52,550 --> 00:15:54,920
是否需要去扫描一个元组一样，

420
00:15:54,920 --> 00:15:57,320
然后将该元组的输出送入并放入

421
00:15:57,320 --> 00:15:59,870
缓冲区中，我无法放入该数据 进入

422
00:15:59,870 --> 00:16:01,280
缓冲区，直到我真正

423
00:16:01,280 --> 00:16:03,380
对两个球进行扫描，所以

424
00:16:03,380 --> 00:16:05,660
我们可以做很多事情来避免这个

425
00:16:05,660 --> 00:16:07,880
问题，我们要尽量

426
00:16:07,880 --> 00:16:09,800
避免的是当我们有分支

427
00:16:09,800 --> 00:16:12,350
预测错误的时候，所以除了

428
00:16:12,350 --> 00:16:14,210
执行 执行的一部分中的

429
00:16:14,210 --> 00:16:15,560
指令，并且当它看到跳转语句时，您知道

430
00:16:15,560 --> 00:16:17,380
在单个循环中同一条指令中有多个结构，

431
00:16:17,380 --> 00:16:20,060
rat

432
00:16:20,060 --> 00:16:21,920
喜欢基于某些条件跳转到分支，

433
00:16:21,920 --> 00:16:24,140
而不是等待

434
00:16:24,140 --> 00:16:25,160
查看该条件实际

435
00:16:25,160 --> 00:16:26,510
计算的结果，然后 de 终止

436
00:16:26,510 --> 00:16:28,580
你是在 if 子句中知道

437
00:16:28,580 --> 00:16:30,920
还是绕过它，它实际上会尝试

438
00:16:30,920 --> 00:16:32,990
预测你将采取什么路径

439
00:16:32,990 --> 00:16:35,090
并开始执行那些

440
00:16:35,090 --> 00:16:36,950
在那个和那个条件中遵循的指令

441
00:16:36,950 --> 00:16:39,920
，然后如果它出错了

442
00:16:39,920 --> 00:16:42,350
然后它必须扔掉

443
00:16:42,350 --> 00:16:43,820
它已经完成的所有东西，然后

444
00:16:43,820 --> 00:16:45,620
返回并用正确的路径重新填充管道，

445
00:16:45,620 --> 00:16:46,700


446
00:16:46,700 --> 00:16:48,830
如果它正确，它应该会下降，这

447
00:16:48,830 --> 00:16:50,900
太棒了我们基本上进行了

448
00:16:50,900 --> 00:16:52,880
推测执行并假设

449
00:16:52,880 --> 00:16:54,080
你知道 我们要去这个分支

450
00:16:54,080 --> 00:16:55,700
，我们做对了，我们

451
00:16:55,700 --> 00:16:57,560
提前做的所有工作实际上对我们有用，

452
00:16:57,560 --> 00:17:00,260
这又是一条规律，它将

453
00:17:00,260 --> 00:17:01,520
减少

454
00:17:01,520 --> 00:17:06,619
我们处理查询所需的周期数，所以如何

455
00:17:06,619 --> 00:17:08,660


456
00:17:08,660 --> 00:17:10,819
从我们的角度来看，如果人们

457
00:17:10,819 --> 00:17:12,829
在日常系统中构建我们不知道我们

458
00:17:12,829 --> 00:17:14,329
不关心的 CPU 实际上会发生分支错误预测，实际上除非你

459
00:17:14,329 --> 00:17:16,160
喜欢在 Intel AMD 工作，否则你也

460
00:17:16,160 --> 00:17:18,230
不会知道，因为 这就像

461
00:17:18,230 --> 00:17:19,490
数据库系统或 CPU 的那些秘密部分之一，

462
00:17:19,490 --> 00:17:22,880


463
00:17:22,880 --> 00:17:24,050
你能想到的最简单的事情就是，如果你

464
00:17:24,050 --> 00:17:26,990
意识到你看到了一个分支，并且

465
00:17:26,990 --> 00:17:28,339
在你

466
00:17:28,339 --> 00:17:29,740
最后走这条路之前已经在那个分支上

467
00:17:29,740 --> 00:17:31,510
你曾经认为这是最简单

468
00:17:31,510 --> 00:17:33,370
最愚蠢的事情，但显然

469
00:17:33,370 --> 00:17:36,850
在英特尔 AMD AMD 中，他们正在做

470
00:17:36,850 --> 00:17:38,200
更复杂的事情，我们

471
00:17:38,200 --> 00:17:39,970
实际上在做的是商业机密，

472
00:17:39,970 --> 00:17:42,790
好吧，但我们不在乎

473
00:17:42,790 --> 00:17:44,410
实际上是什么 我们只是知道

474
00:17:44,410 --> 00:17:46,179
有一些东西在做分支

475
00:17:46,179 --> 00:17:48,100
预测，我们可以围绕它设计我们的代码

476
00:17:48,100 --> 00:17:56,890
是的，所以这个问题

477
00:17:56,890 --> 00:17:59,110


478
00:17:59,110 --> 00:18:00,400
就像人们在

479
00:18:00,400 --> 00:18:02,080
幽灵或崩溃的东西中遇到的问题的一部分，这是

480
00:18:02,080 --> 00:18:09,280
一部分 是的，正如他们所说的那样，

481
00:18:09,280 --> 00:18:11,110
因为他们有很长的管道，

482
00:18:11,110 --> 00:18:13,300
CPU 可以开始为我们执行镜面反射

483
00:18:13,300 --> 00:18:15,280
分支，而且

484
00:18:15,280 --> 00:18:17,200
我们想要这样做的原因是要隐藏

485
00:18:17,200 --> 00:18:21,940
停顿，好吧，我们认为我们要执行

486
00:18:21,940 --> 00:18:24,490
这个，让我们走吧 如果我得到它，那么

487
00:18:24,490 --> 00:18:26,350
事情就很棒了，这将减少

488
00:18:26,350 --> 00:18:30,429
我每条指令的循环计数，所以

489
00:18:30,429 --> 00:18:32,740
我们会遇到这个问题，最重要的是

490
00:18:32,740 --> 00:18:34,960
分析查询是当我们开始

491
00:18:34,960 --> 00:18:37,300
扫描元组时，我们必须评估

492
00:18:37,300 --> 00:18:38,920
谓词和我们的 where 子句

493
00:18:38,920 --> 00:18:40,420
决定是否将某些内容放在我们的

494
00:18:40,420 --> 00:18:42,820
缓冲区中作为该运算符的输出，这

495
00:18:42,820 --> 00:18:44,950
只是一个 if 子句，

496
00:18:44,950 --> 00:18:48,100
所以现在如果我的表中有十亿个元组

497
00:18:48,100 --> 00:18:49,330
并且我正在对该表进行完整的

498
00:18:49,330 --> 00:18:51,070
顺序扫描，我会

499
00:18:51,070 --> 00:18:54,550
有 10 亿个分支我必须

500
00:18:54,550 --> 00:18:57,330
保护潜在地预测在我的 CPU 中

501
00:18:57,330 --> 00:18:59,890
，现在当你也考虑它时，

502
00:18:59,890 --> 00:19:01,750
除非我像 Vertica 一样预先对我的数据进行排序，否则

503
00:19:01,750 --> 00:19:04,210
数据可能是完全

504
00:19:04,210 --> 00:19:07,330
随机的，因为我做我的谓词你知道

505
00:19:07,330 --> 00:19:09,370
我的所有属性 我做我的谓词

506
00:19:09,370 --> 00:19:12,760
评估，所以 c2 正在发生

507
00:19:12,760 --> 00:19:14,980
无法实际预测

508
00:19:14,980 --> 00:19:16,690
实际将采用哪个分支，

509
00:19:16,690 --> 00:19:18,070
因为您将采用

510
00:19:18,070 --> 00:19:21,040
与上次相同的分支的概率

511
00:19:21,040 --> 00:19:23,230
取决于数据的实际外观

512
00:19:23,230 --> 00:19:24,429
喜欢和谓词的选择性，

513
00:19:24,429 --> 00:19:29,380
所以在现代 C++ 中，你实际上可以，

514
00:19:29,380 --> 00:19:33,010
所以我们将在下一张幻灯片中看到

515
00:19:33,010 --> 00:19:34,630
如何设计我们的数据系统以

516
00:19:34,630 --> 00:19:39,220
避免在超级那二十个中你可以

517
00:19:39,220 --> 00:19:41,980
向编译器传递一个提示，称为

518
00:19:41,980 --> 00:19:43,660
可能和不可能 当你喜欢

519
00:19:43,660 --> 00:19:46,030
if call is a case statement 我们甚至会

520
00:19:46,030 --> 00:19:48,220
说我不太可能去这个

521
00:19:48,220 --> 00:19:50,350
分支或者我可能会去这个

522
00:19:50,350 --> 00:19:52,090
分支所以你可以想象你是否正在

523
00:19:52,090 --> 00:19:53,560
做 koujun 我们将再次

524
00:19:53,560 --> 00:19:54,280
讨论 星期一

525
00:19:54,280 --> 00:19:55,840
你可以开始插入这些东西

526
00:19:55,840 --> 00:19:57,730
如果你知道你的谓词

527
00:19:57,730 --> 00:20:00,400
不会是有选择性的 这就是大多数两个男孩的东西

528
00:20:00,400 --> 00:20:01,600


529
00:20:01,600 --> 00:20:03,790


530
00:20:03,790 --> 00:20:05,560
这些东西

531
00:20:05,560 --> 00:20:07,030
给 cpu 提示，说这

532
00:20:07,030 --> 00:20:07,630
不会发生，

533
00:20:07,630 --> 00:20:10,960
但即使这样 cpu 实际上可以

534
00:20:10,960 --> 00:20:12,790
在这种情况下做得很好，如果你

535
00:20:12,790 --> 00:20:14,140
不是很有选择性的日志，它仍然可以

536
00:20:14,140 --> 00:20:16,930
做得很好，只是做一些

537
00:20:16,930 --> 00:20:19,360
想出了一个有人问过的项目项目

538
00:20:19,360 --> 00:20:20,620
g 关于这个关于

539
00:20:20,620 --> 00:20:22,210
分支错误预测我只想说

540
00:20:22,210 --> 00:20:23,560
有一种方法可以在学校里

541
00:20:23,560 --> 00:20:25,450
做到这一点 20 来实现这一点 我认为现代

542
00:20:25,450 --> 00:20:30,760
GCC 并且有一个内在的我们

543
00:20:30,760 --> 00:20:32,740
在现代 C 中而不是在 GCC 和叮当声中实现这一点

544
00:20:32,740 --> 00:20:34,810
他们没有 确切的关键字，但你

545
00:20:34,810 --> 00:20:37,480
也可以强制它这样做，

546
00:20:37,480 --> 00:20:41,520
所以让我们看一个例子，是的，抱歉，

547
00:20:41,970 --> 00:20:44,620
编译器然后

548
00:20:44,620 --> 00:20:46,450
我认为在 x86 中给出了一条指令，我认为

549
00:20:46,450 --> 00:20:48,580
在实际程序集中的条件

550
00:20:48,580 --> 00:20:50,950
或指令流之前

551
00:20:50,950 --> 00:20:53,380
告诉我，就像我一样 “我不会

552
00:20:53,380 --> 00:20:55,800
在这条路上我不喜欢任何伟大的人这是一个提示，

553
00:20:55,800 --> 00:20:58,150
对我说的很可能我不是在说

554
00:20:58,150 --> 00:21:00,310
CPU

555
00:21:00,310 --> 00:21:01,840
可能会或可能不会考虑到

556
00:21:01,840 --> 00:21:04,000
这一点的可能性以及它实际做什么

557
00:21:04,000 --> 00:21:07,680
时 只在 tonot right 中看到这个提示，

558
00:21:07,680 --> 00:21:12,940
让我们说是

559
00:21:12,940 --> 00:21:15,730
当我们有两个谓词时，让我们查询我们，其中 key

560
00:21:15,730 --> 00:21:17,170
大于等于某个低值，

561
00:21:17,170 --> 00:21:18,870
key 小于等于某个高值，

562
00:21:18,870 --> 00:21:22,210
所以通常我告诉我的博士生不要

563
00:21:22,210 --> 00:21:24,580
显示代码和 幻灯片但对于 t 在

564
00:21:24,580 --> 00:21:25,810
这个例子中，我们必须看到一些代码，

565
00:21:25,810 --> 00:21:27,820
但它应该很容易

566
00:21:27,820 --> 00:21:30,100
理解，所以实现这一点的一个非常简单的方法

567
00:21:30,100 --> 00:21:32,620
是选择查询只是

568
00:21:32,620 --> 00:21:34,180


569
00:21:34,180 --> 00:21:36,520
表中每个元组的 for 循环去抓住你想要鞠躬的键 它

570
00:21:36,520 --> 00:21:38,770
结束了我们调用然后应用我们的

571
00:21:38,770 --> 00:21:40,810
谓词正确如果他毕业

572
00:21:40,810 --> 00:21:42,730
太低并且键小于等于高然后

573
00:21:42,730 --> 00:21:44,710
我们将该元组复制到我们的

574
00:21:44,710 --> 00:21:47,140
输出缓冲区增量都

575
00:21:47,140 --> 00:21:48,730
在输出缓冲区中设置所以我们来了

576
00:21:48,730 --> 00:21:50,350
你知道我们可以对

577
00:21:50,350 --> 00:21:55,120
下一个表进行排序，所以这个查询的不好的部分

578
00:21:55,120 --> 00:21:56,470
显然是这个

579
00:21:56,470 --> 00:21:57,159
if 子句，

580
00:21:57,159 --> 00:22:01,690
因为正如我所说的，除非关键是

581
00:22:01,690 --> 00:22:04,239
你知道几乎总是相同的

582
00:22:04,239 --> 00:22:09,129
值然后就像它可能是

583
00:22:09,129 --> 00:22:11,049
我是否要走这条路是完全随机的

584
00:22:11,049 --> 00:22:12,609
，而且 CPU

585
00:22:12,609 --> 00:22:13,359
将很难实际

586
00:22:13,359 --> 00:22:15,599
预测是否这样做

587
00:22:15,599 --> 00:22:18,970
，如果我知道我可以输入

588
00:22:18,970 --> 00:22:21,190
可能或不可能，但这只是

589
00:22:21,190 --> 00:22:22,509
一个提示和 它是，它可能不是

590
00:22:22,509 --> 00:22:24,909
表示实际数据是什么所以

591
00:22:24,909 --> 00:22:26,799
这是如何使用分支进行扫描

592
00:22:26,799 --> 00:22:29,440
我们可以重写它虽然进行

593
00:22:29,440 --> 00:22:31,929
无分支扫描我们仍然

594
00:22:31,929 --> 00:22:33,309
要迭代每个元组

595
00:22:33,309 --> 00:22:35,979
但我们做的第一件事是

596
00:22:35,979 --> 00:22:38,559
复制元组 进入输出缓冲区，我们

597
00:22:38,559 --> 00:22:41,349
不评估键，我们只是说我们

598
00:22:41,349 --> 00:22:44,039
只是复制它，然后我们

599
00:22:44,039 --> 00:22:47,470
在这里进行了两个三元运算，在那里

600
00:22:47,470 --> 00:22:49,539


601
00:22:49,539 --> 00:22:51,639
我们根据 where 子句谓词对键进行比较，并且

602
00:22:51,639 --> 00:22:53,799
发生的情况是如果谓词

603
00:22:53,799 --> 00:22:55,960
匹配然后我们在我们有一个一，如果

604
00:22:55,960 --> 00:22:57,159
零

605
00:22:57,159 --> 00:23:00,549
和两个东西在一起无关紧要，

606
00:23:00,549 --> 00:23:01,989
然后告诉我们它是一还是

607
00:23:01,989 --> 00:23:04,239
基于它会告诉我们我们

608
00:23:04,239 --> 00:23:05,759
是否增加我们的计数器，

609
00:23:05,759 --> 00:23:10,210
以便如果这两者因此 零

610
00:23:10,210 --> 00:23:14,859
那么当我回来时偏移量将为零

611
00:23:14,859 --> 00:23:18,669
我只是在看

612
00:23:18,669 --> 00:23:21,580
它然后我需要一些代码在这里

613
00:23:21,580 --> 00:23:23,139
以确保最后一个

614
00:23:23,139 --> 00:23:24,759
不匹配的优点我不包括

615
00:23:24,759 --> 00:23:27,159
我的报价 对，但为简单起见，我 我

616
00:23:27,159 --> 00:23:28,989
不是在这里这样做，所以会

617
00:23:28,989 --> 00:23:32,470
发生的是即使那些看起来像这些

618
00:23:32,470 --> 00:23:36,700
条件的情况也会直接暂停光束在

619
00:23:36,700 --> 00:23:40,090
能量上运行的时间并

620
00:23:40,090 --> 00:23:44,590
正确地写出算术运算

621
00:23:44,590 --> 00:23:51,009
我把它变成了像保持我的你

622
00:23:51,009 --> 00:23:52,600
检查但它

623
00:23:52,600 --> 00:23:55,240
检查实际位使用 位

624
00:23:55,240 --> 00:23:56,470
运算符，看看它是否为零，

625
00:23:56,470 --> 00:23:59,710
就像我们可以重写所有更多的

626
00:23:59,710 --> 00:24:01,240
指令，这些指令只是做

627
00:24:01,240 --> 00:24:07,300
正确的数学运算，所以这看起来

628
00:24:07,300 --> 00:24:10,180
很糟糕，因为对于 10 亿次 t

629
00:24:10,180 --> 00:24:12,040
打击，我正在复制所有 10 亿次，

630
00:24:12,040 --> 00:24:15,370
然后在 在这种情况下，我只复制

631
00:24:15,370 --> 00:24:17,980
实际匹配的那些，但再次

632
00:24:17,980 --> 00:24:19,980
取决于谓词的选择性

633
00:24:19,980 --> 00:24:21,940
以及我们的数据看起来如何，

634
00:24:21,940 --> 00:24:24,070
这实际上可能是更好的

635
00:24:24,070 --> 00:24:29,880
方法，以后可以完善图形并

636
00:24:29,880 --> 00:24:33,070
扫描带有分支

637
00:24:33,070 --> 00:24:34,780
和 当我

638
00:24:34,780 --> 00:24:37,090
展示之前，X轴的扫描的无分支版本在此时，X轴

639
00:24:37,090 --> 00:24:38,470
的

640
00:24:38,470 --> 00:24:40,930
选择性在此时，

641
00:24:40,930 --> 00:24:42,700
选择性低意味着大多数元

642
00:24:42,700 --> 00:24:44,860
组不会匹配 就像当没有元组

643
00:24:44,860 --> 00:24:46,780
匹配分支时，一个实际上

644
00:24:46,780 --> 00:24:48,370
执行得最好，因为我再次

645
00:24:48,370 --> 00:24:51,700
检查了我的条件并且它不

646
00:24:51,700 --> 00:24:53,320
匹配所以我不会浪费指令

647
00:24:53,320 --> 00:24:55,780
进行复制，而且 CPU

648
00:24:55,780 --> 00:24:57,100
会像上一次一样预测你

649
00:24:57,100 --> 00:24:59,110
几乎每次都知道这一点 单元组永远

650
00:24:59,110 --> 00:25:00,730
不会匹配 if 调用所以它会

651
00:25:00,730 --> 00:25:03,310
预测绕过它而不做

652
00:25:03,310 --> 00:25:07,270
复制但选择大约 5% 那么它

653
00:25:07,270 --> 00:25:08,470
实际上开始比

654
00:25:08,470 --> 00:25:10,180
分支列表情况更糟糕所以无分支的一个

655
00:25:10,180 --> 00:25:12,760
是一条平线，因为没有

656
00:25:12,760 --> 00:25:14,350
不管谓词评估是否为

657
00:25:14,350 --> 00:25:16,450
真，我总是

658
00:25:16,450 --> 00:25:17,920
为复制权付出代价，所以

659
00:25:17,920 --> 00:25:19,600
这就是为什么它几乎是一个

660
00:25:19,600 --> 00:25:21,640
高原，正如你在这里看到的那样

661
00:25:21,640 --> 00:25:24,550
，当它像 50% 选择性 50%

662
00:25:24,550 --> 00:25:25,930
的时候 元组匹配 50

663
00:25:25,930 --> 00:25:27,430
% 不匹配，这是最糟糕的情况，

664
00:25:27,430 --> 00:25:29,080
因为 CPU

665
00:25:29,080 --> 00:25:31,240
根本无法预测这一点，只有当

666
00:25:31,240 --> 00:25:34,240
你在这里 100 个匹配时

667
00:25:34,240 --> 00:25:38,100
，CPU 才能赶上 是

668
00:25:43,560 --> 00:25:48,750
的，问题是这样 你是说这个

669
00:25:48,750 --> 00:25:50,860
如果你改变内存带宽速度，这个图看起来会有所不同，

670
00:25:50,860 --> 00:25:52,510


671
00:25:52,510 --> 00:26:00,550
或者我的意思

672
00:26:00,550 --> 00:26:05,920
是让扫描的内容留在内存中是的，所以就像我必须

673
00:26:05,920 --> 00:26:09,930
对两种情况都进行扫描

674
00:26:10,380 --> 00:26:12,310
是的，但想想它 回到

675
00:26:12,310 --> 00:26:17,020
这里就像我做这个副本一样

676
00:26:17,020 --> 00:26:19,600
如果我回来如果这样做我做

677
00:26:19,600 --> 00:26:22,360
一个副本元组不匹配我

678
00:26:22,360 --> 00:26:23,890
在做下一个副本时回来我

679
00:26:23,890 --> 00:26:25,690
覆盖了我复制到内存中的最后一个地方就是

680
00:26:25,690 --> 00:26:27,310
这样 无论如何都会坐在我的

681
00:26:27,310 --> 00:26:35,050
CPU 缓存中 传输

682
00:26:35,050 --> 00:26:38,260
这个副本是做什么的 这是给我一个 CPU

683
00:26:38,260 --> 00:26:39,160
缓存的权利

684
00:26:39,160 --> 00:26:40,360


685
00:26:40,360 --> 00:26:42,670


686
00:26:42,670 --> 00:26:44,620


687
00:26:44,620 --> 00:26:45,970
从一个缓存位置运行到

688
00:26:45,970 --> 00:26:47,980
另一个缓存位置的副本可能会是

689
00:26:47,980 --> 00:26:54,880
一个 l1 对我的意思是它是

690
00:26:54,880 --> 00:26:56,590
在此之后的下一

691
00:26:56,590 --> 00:26:59,590


692
00:26:59,590 --> 00:27:02,050


693
00:27:02,050 --> 00:27:05,020
条指令 是的，

694
00:27:05,020 --> 00:27:06,760
当我来的时候，我会这样做 s 然后

695
00:27:06,760 --> 00:27:10,240
回来，我再做一份副本，可能

696
00:27:10,240 --> 00:27:12,040
是这样，如果我

697
00:27:12,040 --> 00:27:13,750
覆盖了我复制的最后一个位置，我复制的那个

698
00:27:13,750 --> 00:27:17,470
位置被刷新了我的 CPU 缓存可能

699
00:27:17,470 --> 00:27:19,030
会从 l1 被刷新，但我想我很

700
00:27:19,030 --> 00:27:22,150
幸运能被刷新 从 l2 l3 开始，

701
00:27:22,150 --> 00:27:23,260
这是一个紧密的循环，我们没有

702
00:27:23,260 --> 00:27:24,670
做任何其他事情，我们只是评估

703
00:27:24,670 --> 00:27:28,150
这个谓词，无法保证，

704
00:27:28,150 --> 00:27:30,250
因为我们无法控制

705
00:27:30,250 --> 00:27:35,950
CPU x86 的缓存策略，您可以给它

706
00:27:35,950 --> 00:27:39,630
提示，但它不会 非常遵循

707
00:27:48,580 --> 00:27:51,230
是的，我同意他的这一点是

708
00:27:51,230 --> 00:27:53,750
，我不知道

709
00:27:53,750 --> 00:27:55,309
CPU 可以在这里做哪些其他优化，

710
00:27:55,309 --> 00:27:57,500
抱歉编译器

711
00:27:57,500 --> 00:27:59,149
可能会像展开循环那样做，所以它

712
00:27:59,149 --> 00:28:01,940
就像四个副本，然后是一堆

713
00:28:01,940 --> 00:28:07,100
这些 事情然后又回来

714
00:28:07,100 --> 00:28:09,080
了，所以这就是姐妹们的研究

715
00:28:09,080 --> 00:28:16,600
是正确的 确切的观点

716
00:28:23,730 --> 00:28:30,490
，我们看到所以假设是

717
00:28:30,490 --> 00:28:34,750
当大多数元组不匹配时分支时

718
00:28:34,750 --> 00:28:37,630
支付复制的惩罚

719
00:28:37,630 --> 00:28:39,160
是不值得的，因为你

720
00:28:39,160 --> 00:28:40,300
你在做什么？  nd 指令

721
00:28:40,300 --> 00:28:44,950
可能不需要写，所以我

722
00:28:44,950 --> 00:28:46,120
同意你的观点，

723
00:28:46,120 --> 00:28:47,410
这里有很多其他事情可能

724
00:28:47,410 --> 00:28:49,180
会发生，编译器

725
00:28:49,180 --> 00:28:53,770
可能会做，但我们离开了，就像我们可以

726
00:28:53,770 --> 00:28:55,750
验证这实际上是有效的一样

727
00:28:55,750 --> 00:28:57,580
正确地我们认为它是基于这些

728
00:28:57,580 --> 00:29:18,010
结果是的所以他的问题是

729
00:29:18,010 --> 00:29:20,080
如果你正在做表扫描这很好用

730
00:29:20,080 --> 00:29:22,090
因为你刚刚

731
00:29:22,090 --> 00:29:23,520
通过连续的内存区域

732
00:29:23,520 --> 00:29:26,140
有一个内存预取器如果他

733
00:29:26,140 --> 00:29:27,220
知道正在访问

734
00:29:27,220 --> 00:29:28,450
细细的东西会带来这些东西并

735
00:29:28,450 --> 00:29:29,770
触及缓存未命中，因此如果是索引扫描，我们可以

736
00:29:29,770 --> 00:29:31,570
从扫描列中获得很多好处，

737
00:29:31,570 --> 00:29:33,910


738
00:29:33,910 --> 00:29:35,950
除了可能

739
00:29:35,950 --> 00:29:38,920
在内存中进行预取之外，我无能为力，但一旦我

740
00:29:38,920 --> 00:29:40,960
停下来 叶节点，现在我开始

741
00:29:40,960 --> 00:29:43,660
沿着叶节点扫描，

742
00:29:43,660 --> 00:29:45,100
如果我

743
00:29:45,100 --> 00:29:50,500
对同一节点中的数据执行这样的操作，

744
00:29:50,500 --> 00:29:51,850
就像我在同一节点中非常便宜

745
00:29:51,850 --> 00:29:53,890
而我没有，我会得到同样的好处 去厕所 k

746
00:29:53,890 --> 00:29:56,710
在元组的其余部分，

747
00:29:56,710 --> 00:30:00,070
如果我有我的键，我的

748
00:30:00,070 --> 00:30:03,010
索引基于这个键，但是

749
00:30:03,010 --> 00:30:04,510
where 子句中还有另一部分

750
00:30:04,510 --> 00:30:05,890
涉及另一个属性

751
00:30:05,890 --> 00:30:07,140
，然后我必须去查看元组

752
00:30:07,140 --> 00:30:09,910
那么这可能是一个坏主意，或者这

753
00:30:09,910 --> 00:30:11,260
可能不会是一个很大的

754
00:30:11,260 --> 00:30:12,670
胜利，但如果我只是看看我

755
00:30:12,670 --> 00:30:15,490
在那个节点中到底需要什么，那么我

756
00:30:15,490 --> 00:30:18,600
认为这仍然适用

757
00:30:20,820 --> 00:30:37,770
于什么克劳斯是你的问题 是如果

758
00:30:37,770 --> 00:30:40,440
你在这种情况下在这里使用可能，

759
00:30:40,440 --> 00:30:44,940
就像我们的选择性是 50% 的可能性一样

760
00:30:44,940 --> 00:30:47,130
，不像他在这里没有帮助我们，所以在

761
00:30:47,130 --> 00:30:49,070
这种情况下，编译器可以

762
00:30:49,070 --> 00:31:17,340
重写代码或做它

763
00:31:17,340 --> 00:31:21,500
基本上像如果我有的话 否则

764
00:31:21,500 --> 00:31:24,150
你会说我是否

765
00:31:24,150 --> 00:31:27,120
能从 else 子句中得到任何好处，

766
00:31:27,120 --> 00:31:30,150
如果

767
00:31:30,150 --> 00:31:33,120
我应该翻转它们，我会做

768
00:31:33,120 --> 00:31:36,090
任何布尔逻辑来反转它，以便

769
00:31:36,090 --> 00:31:38,130
出现的第一件事是最有可能发生的

770
00:31:38,130 --> 00:31:40,400
if 子句中的一个可能是我

771
00:31:40,400 --> 00:31:45,020
实际上不知道的 现在他们做了什么是

772
00:31:47,420 --> 00:31:51,390
啊是啊我明白你的观点是啊是啊III

773
00:31:51,390 --> 00:31:56,730
实际上不知道是的实际上一个好

774
00:31:56,730 --> 00:31:59,090
点实际上

775
00:32:02,550 --> 00:32:04,530
wellyes适用于

776
00:32:04,530 --> 00:32:05,760
允许编译器优化案例

777
00:32:05,760 --> 00:32:06,990
的语句通过该执行包括一个

778
00:32:06,990 --> 00:32:08,190
语句我更多 寻找更有

779
00:32:08,190 --> 00:32:09,540
可能不在此类声明中的替代路径操作，

780
00:32:09,540 --> 00:32:15,870
所以是的，也许我的

781
00:32:15,870 --> 00:32:17,790
意思是这不是很有记录，但

782
00:32:17,790 --> 00:32:19,530
也许这

783
00:32:19,530 --> 00:32:28,620
就是他们实际做的事情的方式是的，

784
00:32:28,620 --> 00:32:30,660
是的，所以他的观点是，如果您知道是否

785
00:32:30,660 --> 00:32:32,250
你是否会去一个分支

786
00:32:32,250 --> 00:32:34,380
你可以决定

787
00:32:34,380 --> 00:32:35,760
是否一致 是的 我的意思是编译器是

788
00:32:35,760 --> 00:32:38,460
另一个野兽 这不是

789
00:32:38,460 --> 00:32:41,790
杂志文章飞行员专家

790
00:32:41,790 --> 00:32:43,380
将在数据库的上下文中谈论编译器

791
00:32:43,380 --> 00:32:45,030
下节课喜欢的

792
00:32:45,030 --> 00:32:48,800
事情我们认为这是一个很好的点，

793
00:32:48,800 --> 00:32:54,900
所以另一件事我们也想尽量

794
00:32:54,900 --> 00:32:56,400
避免它，这是

795
00:32:56,400 --> 00:32:57,810
我们谈到的第一部分，

796
00:32:57,810 --> 00:33:02,220
你知道有很多指令，你知道使用更多

797
00:33:02,220 --> 00:33:03,570
指令

798
00:33:03,570 --> 00:33:07,620
如果我们将

799
00:33:07,620 --> 00:33:10,580
系统设计为某种通用的，

800
00:33:10,580 --> 00:33:12,810
很多时候你会在这些

801
00:33:12,810 --> 00:33:14,580
数据库中看到这些巨大的 switch 子句

802
00:33:14,580 --> 00:33:17,280
，当你开始评估

803
00:33:17,280 --> 00:33:20,160
谓词或评估元组时，这可能意味着需要再次检查 X 射线 对于

804
00:33:20,160 --> 00:33:22,110
你的日报可以支持的每一种类型的数据，

805
00:33:22,110 --> 00:33:24,270
你有这些

806
00:33:24,270 --> 00:33:26,370
调用 switch 调用监听我有一个

807
00:33:26,370 --> 00:33:27,810
整数，我将它与整数

808
00:33:27,810 --> 00:33:29,700


809
00:33:29,700 --> 00:33:33,270
相加 这增加了

810
00:33:33,270 --> 00:33:34,830
你知道错误预测会

811
00:33:34,830 --> 00:33:37,590
减慢我们的速度，只是你知道它有更多的

812
00:33:37,590 --> 00:33:38,970
指令实际上你知道

813
00:33:38,970 --> 00:33:41,130
评估条件并

814
00:33:41,130 --> 00:33:43,620
决定我们的数据类型是什么，

815
00:33:43,620 --> 00:33:45,630
所以我们需要在此之前共享一个表格，

816
00:33:45,630 --> 00:33:48,180
但这是一个介绍 类，如果你去

817
00:33:48,180 --> 00:33:49,470
看看

818
00:33:49,470 --> 00:33:50,850
他们如何处理像

819
00:33:50,850 --> 00:33:52,980
定点小数这样的数字的 Postgres 源代码，这只是

820
00:33:52,980 --> 00:33:55,650
做 add write 以添加到

821
00:33:55,650 --> 00:33:57,480
numerix 的函数，你会看到所有这些

822
00:33:57,480 --> 00:33:59,460
if 原因，比如 if

823
00:33:59,460 --> 00:34:00,390
它是负面的

824
00:34:00,390 --> 00:34:01,740
如果你知道我们是否正在考虑

825
00:34:01,740 --> 00:34:03,270
某些东西的绝对值则它是积极的 所有

826
00:34:03,270 --> 00:34:05,340
这些都是有问题的，因为这是

827
00:34:05,340 --> 00:34:07,320
很多指令，并且 CPU 出错的机会很多，

828
00:34:07,320 --> 00:34:11,219
所以我们会

829
00:34:11,219 --> 00:34:13,139
再次看到这一点 下周一将

830
00:34:13,139 --> 00:34:16,199
讨论如何专门化我们的专用代码

831
00:34:16,199 --> 00:34:20,329
哦，您需要快速完成的代码

832
00:34:20,329 --> 00:34:22,649
，这称为热电联产或

833
00:34:22,649 --> 00:34:25,949
即时编译，所以

834
00:34:25,949 --> 00:34:28,500
现在我们说我们知道如何

835
00:34:28,500 --> 00:34:30,480
知道 CP 将要做什么 看起来并且我们

836
00:34:30,480 --> 00:34:32,129
想知道我们想要如何设计我们的

837
00:34:32,129 --> 00:34:35,250
操作符实现以

838
00:34:35,250 --> 00:34:36,899
注意它现在我们将讨论

839
00:34:36,899 --> 00:34:38,399
我们将如何组织系统以

840
00:34:38,399 --> 00:34:40,199
处理包含在

841
00:34:40,199 --> 00:34:42,210
多个操作符上的查询所以最后一个类是

842
00:34:42,210 --> 00:34:43,770
谈论我们实际上是如何安排的，

843
00:34:43,770 --> 00:34:46,440
但是这些操作员的 XP 的任务，

844
00:34:46,440 --> 00:34:48,480
但现在我们只是在谈论

845
00:34:48,480 --> 00:34:53,040
一种更高级别的骗局，因此

846
00:34:53,040 --> 00:34:53,940
我们将根据类型进行不同的权衡

847
00:34:53,940 --> 00:34:55,889


848
00:34:55,889 --> 00:34:57,329
我们将要减少的工作量 为了

849
00:34:57,329 --> 00:34:59,819
支持像 OLTP 事务那样有一个

850
00:34:59,819 --> 00:35:01,950
左分析查询所以有

851
00:35:01,950 --> 00:35:03,180
最常见的一个通用的

852
00:35:03,180 --> 00:35:05,220
一个迭代器模型物化模型

853
00:35:05,220 --> 00:35:07,020
哦还有一个矢量化模型所以

854
00:35:07,020 --> 00:35:09,780
剧透是在现代

855
00:35:09,780 --> 00:35:11,069
分析系统中我们 想要

856
00:35:11,069 --> 00:35:13,109
使用矢量化模型，因为它在

857
00:35:13,109 --> 00:35:16,559
传递注释时我们可以

858
00:35:16,559 --> 00:35:18,630
在运算符之间传递你知道的列块，然后在运算符

859
00:35:18,630 --> 00:35:20,970
内部使用 cindy 指令

860
00:35:20,970 --> 00:35:24,710
来有效地执行它们

861
00:35:26,990 --> 00:35:29,700
这是一些火山模型或

862
00:35:29,700 --> 00:35:35,180
管道模型沼泽火山方式 - 嘿

863
00:35:35,720 --> 00:35:38,220
，像 1980 年代

864
00:35:38,220 --> 00:35:40,980
末 1990 年代初一样出现，除了定义

865
00:35:40,980 --> 00:35:42,089
我将在稍后讨论的交换运算符之外，

866
00:35:42,089 --> 00:35:44,460
还有

867
00:35:44,460 --> 00:35:45,410


868
00:35:45,410 --> 00:35:48,450
我们将在本学期晚些时候介绍的火山查询优化器

869
00:35:48,450 --> 00:35:50,069
，然后是

870
00:35:50,069 --> 00:35:51,690
前身 到 Cascades，这是另一种

871
00:35:51,690 --> 00:35:53,369
优化器优化方案，我将

872
00:35:53,369 --> 00:35:56,549
像这样讨论 Gertz 图

873
00:35:56,549 --> 00:35:58,200
II 也是

874
00:35:58,200 --> 00:36:01,020
编写

875
00:36:01,020 --> 00:36:02,819
我发给你们的第一个

876
00:36:02,819 --> 00:36:04,500
项目的现代 B 加树书 这家伙的东西确实让我感到惊讶

877
00:36:04,500 --> 00:36:07,319
它非常有影响力所以在

878
00:36:07,319 --> 00:36:08,309
迭代器模型中我们要

879
00:36:08,309 --> 00:36:09,740
实现它的方式是每个

880
00:36:09,740 --> 00:36:12,089
操作符都将实现这个

881
00:36:12,089 --> 00:36:15,359
下一个功能 当

882
00:36:15,359 --> 00:36:17,339
有人调用该运算符的脖子时发生了什么，它

883
00:36:17,339 --> 00:36:21,900
必须返回一个元组，它

884
00:36:21,900 --> 00:36:26,670
可以，因为我们组织了

885
00:36:26,670 --> 00:36:29,190
该运算符需要来自其

886
00:36:29,190 --> 00:36:30,120
子级的数据的树，它

887
00:36:30,120 --> 00:36:31,830
接下来在子级上以及那种

888
00:36:31,830 --> 00:36:33,270
级联到底部，或者你有

889
00:36:33,270 --> 00:36:34,890
访问方法，您

890
00:36:34,890 --> 00:36:37,080
从表或索引中检索数据，

891
00:36:37,080 --> 00:36:40,050
然后我们将元组向上移动

892
00:36:40,050 --> 00:36:42,420
，基本上只是我们将继续

893
00:36:42,420 --> 00:36:43,980
在根处调用 next next next

894
00:36:43,980 --> 00:36:45,270
并继续获取元组，然后我们

895
00:36:45,270 --> 00:36:47,130
得到 为我们的光标输出它，

896
00:36:47,130 --> 00:36:49,800
直到在某个时候我们得到一个很好的

897
00:36:49,800 --> 00:36:51,120
响应并说我们没有可用的倍数

898
00:36:51,120 --> 00:36:53,520
所以在高层次上它

899
00:36:53,520 --> 00:36:56,040
看起来像这样所以说我们

900
00:36:56,040 --> 00:36:58,500
在表 R 和 s 上有一个双向关节和 所以对于每

901
00:36:58,500 --> 00:37:00,090
一个操作符，我们都会有这个

902
00:37:00,090 --> 00:37:02,460
小的 for 循环，通常它

903
00:37:02,460 --> 00:37:05,100
会迭代一些

904
00:37:05,100 --> 00:37:06,750
从表或它的子节点获取的输入数据

905
00:37:06,750 --> 00:37:09,510
，然后承认

906
00:37:09,510 --> 00:37:12,270
它们，所以再次考虑这些只是

907
00:37:12,270 --> 00:37:14,790
下一个 函数所以我的孩子会在

908
00:37:14,790 --> 00:37:16,680
这里第一个我们自己调用下一步的路线

909
00:37:16,680 --> 00:37:18,690
一个孩子我们来到下一个

910
00:37:18,690 --> 00:37:20,640
块并且它想要进行连接所以

911
00:37:20,640 --> 00:37:22,530
它会迭代它的左孩子

912
00:37:22,530 --> 00:37:25,620
来到这里并说给我你的意思

913
00:37:25,620 --> 00:37:26,790
接下来的两个但是你有，这将

914
00:37:26,790 --> 00:37:29,130
发送回一个元组，我们一直

915
00:37:29,130 --> 00:37:30,720
这样做直到完成，直到

916
00:37:30,720 --> 00:37:31,890
我们得到所有的元组，我们建立了我们的

917
00:37:31,890 --> 00:37:33,780
哈希表，然后我们下降到这个孩子的下一个

918
00:37:33,780 --> 00:37:34,380
for 循环

919
00:37:34,380 --> 00:37:36,600
调用 next 然后

920
00:37:36,600 --> 00:37:37,740
它开始将

921
00:37:37,740 --> 00:37:40,830
元组从 s 表向上移动，然后

922
00:37:40,830 --> 00:37:42,060
在哈希表中进行探测，然后

923
00:37:42,060 --> 00:37:43,320
任何匹配的东西都会被推到

924
00:37:43,320 --> 00:37:51,020
这里，所以这种方法是的，

925
00:38:01,280 --> 00:38:07,370
好的，是的

926
00:38:07,370 --> 00:38:10,550
，所以我们不是我们 还没到

927
00:38:10,550 --> 00:38:11,930
呢 就像那就像

928
00:38:11,930 --> 00:38:14,660
我们其中一个 CPU 在处理时如何做

929
00:38:14,660 --> 00:38:16,910
想到这一点 就像

930
00:38:16,910 --> 00:38:18,620
您认为某个线程

931
00:38:18,620 --> 00:38:20,990
在路由上调用 next 的某个地方

932
00:38:20,990 --> 00:38:22,970
在此子进程上调用 next 并且有一个

933
00:38:22,970 --> 00:38:24,080
实例正在迭代 使用这个

934
00:38:24,080 --> 00:38:25,820
元组，但我说这是一个阻塞调用，所以

935
00:38:25,820 --> 00:38:27,830
当我调用 next 时，这不是处理，

936
00:38:27,830 --> 00:38:28,760
这正在等待，

937
00:38:28,760 --> 00:38:33,560
所以融合几乎每个

938
00:38:33,560 --> 00:38:36,440
你听说过的首次亮相的系统，它的

939
00:38:36,440 --> 00:38:37,580
优点是我们将

940
00:38:37,580 --> 00:38:39,920
能够做到 流水线的含义就像在

941
00:38:39,920 --> 00:38:43,660
这种情况下一样，因为我们一路发出最佳

942
00:38:43,660 --> 00:38:50,200
骑行，因为

943
00:38:50,200 --> 00:38:52,760
我们需要的一切或过程

944
00:38:52,760 --> 00:38:55,010
都可以使用单个元组，

945
00:38:55,010 --> 00:38:56,270
当我们这样做时，我们正在

946
00:38:56,270 --> 00:38:57,980
调用 next right 我可以把它

947
00:38:57,980 --> 00:39:00,770
放到这里，或者谓词

948
00:39:00,770 --> 00:39:02,930
把哈希表的探针放在那里，

949
00:39:02,930 --> 00:39:04,730
然后匹配，然后我出现在这里并进行

950
00:39:04,730 --> 00:39:06,590
投影，然后我可以产生

951
00:39:06,590 --> 00:39:09,260
两个男孩我的输出，所以这被认为

952
00:39:09,260 --> 00:39:10,730
是一个管道，我们采取一个事实 元组

953
00:39:10,730 --> 00:39:13,430
在这种

954
00:39:13,430 --> 00:39:15,920
情况下，将它一直放在查询的输出中，或者如果

955
00:39:15,920 --> 00:39:17,720
有管道断路器，或者我们不能

956
00:39:17,720 --> 00:39:19,010
走得更远，那么它就会被缓冲到

957
00:39:19,010 --> 00:39:24,170
那里，所以这是休息区，所以一些

958
00:39:24,170 --> 00:39:25,610
操作员离开了街区，直到 他们

959
00:39:25,610 --> 00:39:27,370
让所有的 Cho 发出他们所有的元组

960
00:39:27,370 --> 00:39:30,800
，你从

961
00:39:30,800 --> 00:39:32,300
迭代器模型中得到的另一个结果是输出控制

962
00:39:32,300 --> 00:39:34,340
真的很容易，因为我们不需要

963
00:39:34,340 --> 00:39:36,500
下推任何逻辑来做限制，

964
00:39:36,500 --> 00:39:38,720
因为如果我知道我只想得到

965
00:39:38,720 --> 00:39:40,970
10 到极点至于我的查询，然后我只是

966
00:39:40,970 --> 00:39:43,460
在路线上调用停止呼叫，一旦

967
00:39:43,460 --> 00:39:46,190
我到达 10 点到极点我已经看到了一切

968
00:39:46,190 --> 00:39:49,460
，所以在这里这

969
00:39:49,460 --> 00:39:53,060


970
00:39:53,060 --> 00:39:54,890
只是使用它的数据库的示例 像

971
00:39:54,890 --> 00:39:56,960
这样的方法是我可以通过

972
00:39:56,960 --> 00:39:58,460
查看文档或查看

973
00:39:58,460 --> 00:39:59,540
源代码来确认的方法 但是

974
00:39:59,540 --> 00:40:06,349
[笑声

975
00:40:06,349 --> 00:40:08,329
] 迭代器模型 它是规范的

976
00:40:08,329 --> 00:40:15,079
方式 是的 编译 这又

977
00:40:15,079 --> 00:40:17,239
是不同于编译 这是

978
00:40:17,239 --> 00:40:18,979
正交的 这就像你刚刚做的

979
00:40:18,979 --> 00:40:21,529
汇编里 我仍然可以将所有

980
00:40:21,529 --> 00:40:22,309
这四个循环

981
00:40:22,309 --> 00:40:25,309
弹出并运行它，并且

982
00:40:25,309 --> 00:40:27,439
在 hyper 的情况下仍然会使用迭代器模型

983
00:40:27,439 --> 00:40:30,979
他们正在这样做 他们仍在这样

984
00:40:30,979 --> 00:40:32,390
做，这是我们需要讨论的另一

985
00:40:32,390 --> 00:40:34,339
件事，就像这样 这

986
00:40:34,339 --> 00:40:36,049
是一种自上而下的方法，这意味着我从

987
00:40:36,049 --> 00:40:38,709
顶部开始，我将元组

988
00:40:38,709 --> 00:40:41,089


989
00:40:41,089 --> 00:40:43,489


990
00:40:43,489 --> 00:40:45,319


991
00:40:45,319 --> 00:40:47,329
向上拉 开始发射

992
00:40:47,329 --> 00:40:53,150
超元组 是不是大多数系统都使用自

993
00:40:53,150 --> 00:40:55,369
顶向下的迭代器模型，这在那些

994
00:40:55,369 --> 00:41:04,640
通用模型中是下一个很棒的，

995
00:41:04,640 --> 00:41:05,359
是的，

996
00:41:05,359 --> 00:41:08,779
我意识到这对我来说有点

997
00:41:08,779 --> 00:41:09,859
蹩脚

998
00:41:09,859 --> 00:41:11,659


999
00:41:11,659 --> 00:41:15,909
类是正确的，就像人们的第一个一样，

1000
00:41:16,269 --> 00:41:20,989
所以这里的另一个是，

1001
00:41:20,989 --> 00:41:23,449
而不是有一个 X 只

1002
00:41:23,449 --> 00:41:27,349
返回一个元组，我要让

1003
00:41:27,349 --> 00:41:31,069
每个操作员拥有所有的元组，这些元组

1004
00:41:31,069 --> 00:41:32,630
将同时产生所有的元组，

1005
00:41:32,630 --> 00:41:35,900
然后推 那到 t 他是下一个操作员

1006
00:41:35,900 --> 00:41:38,150
，我可以

1007
00:41:38,150 --> 00:41:40,819
像你说的那样做这件事，你知道 get nax 或 next

1008
00:41:40,819 --> 00:41:41,839
然后不是得到一个元组，

1009
00:41:41,839 --> 00:41:43,669
你得到一个你得到所有的东西，或者

1010
00:41:43,669 --> 00:41:45,859
我可以从下往上推它像

1011
00:41:45,859 --> 00:41:48,199
run run the operator 得到输出

1012
00:41:48,199 --> 00:41:49,789
然后把它推给下一个人

1013
00:41:49,789 --> 00:41:53,569
好吧，所以在物化模型中，

1014
00:41:53,569 --> 00:41:55,819
你可以将材料作为整

1015
00:41:55,819 --> 00:41:57,799
行或单列来处理，就像你在

1016
00:41:57,799 --> 00:41:59,479
做分析一样，将整个全部物化是没有意义的

1017
00:41:59,479 --> 00:42:01,339


1018
00:42:01,339 --> 00:42:03,019
输出缓冲区中元组的属性，

1019
00:42:03,019 --> 00:42:05,089
如果你知道你知道

1020
00:42:05,089 --> 00:42:06,589
大部分表的大部分内容，大多数查询

1021
00:42:06,589 --> 00:42:08,269
根本不需要列

1022
00:42:08,269 --> 00:42:09,739
或所有其余查询中的那些，这

1023
00:42:09,739 --> 00:42:11,329
意味着注释

1024
00:42:11,329 --> 00:42:13,849
等等 同样重要的事情你需要

1025
00:42:13,849 --> 00:42:15,949
成为一个通信存储或一个行存储，然后

1026
00:42:15,949 --> 00:42:18,690
这样做，

1027
00:42:18,690 --> 00:42:20,680
而不是使用下一个函数，我们

1028
00:42:20,680 --> 00:42:23,170
只是在每个运算符中都有这个，

1029
00:42:23,170 --> 00:42:24,730
现在我们要分配一个输出

1030
00:42:24,730 --> 00:42:26,650
缓冲区，然后我们继续填充它

1031
00:42:26,650 --> 00:42:28,390
与 m 的元组 atch 然后当

1032
00:42:28,390 --> 00:42:29,769
我们完成后，我们把它推上去

1033
00:42:29,769 --> 00:42:32,259
所以再次超级迈克从上到下 我

1034
00:42:32,259 --> 00:42:34,509
调用这个家伙的输出函数 他

1035
00:42:34,509 --> 00:42:36,220
调用了表位函数 这个家伙他

1036
00:42:36,220 --> 00:42:37,630
把所有两个加上如果他有

1037
00:42:37,630 --> 00:42:39,609
缓冲区的话把它放在这个上面 现在他可以

1038
00:42:39,609 --> 00:42:42,609
迭代这个输出缓冲区并

1039
00:42:42,609 --> 00:42:44,769
构建他的哈希表，然后我们

1040
00:42:44,769 --> 00:42:46,210
在这里对另一个缓冲区做同样的事情

1041
00:42:46,210 --> 00:42:51,579
，我们把数据推上去，所以在这个

1042
00:42:51,579 --> 00:42:54,279
例子中，这是这个，

1043
00:42:54,279 --> 00:42:56,319
就像这是一个 天真的实现

1044
00:42:56,319 --> 00:42:58,589
这显然真的很愚蠢，因为

1045
00:42:58,589 --> 00:43:00,819
对于其中的一些事情，我实际上可以

1046
00:43:00,819 --> 00:43:03,009
将操作员实际做的事情结合在一起，

1047
00:43:03,009 --> 00:43:05,589
所以在这种情况下

1048
00:43:05,589 --> 00:43:08,230
，我在做什么我正在扫描

1049
00:43:08,230 --> 00:43:10,630
表 s 将表 s 中的所有元组

1050
00:43:10,630 --> 00:43:12,849
放入 我的输出缓冲区然后

1051
00:43:12,849 --> 00:43:14,319
现在将该输出缓冲区传递给这个运算符

1052
00:43:14,319 --> 00:43:15,910
，它只是要迭代它

1053
00:43:15,910 --> 00:43:18,670
，如果我用我的谓词，那么更好的

1054
00:43:18,670 --> 00:43:19,989
主意显然是将这

1055
00:43:19,989 --> 00:43:21,670
两个运算符组合在一起，所以我做一次

1056
00:43:21,670 --> 00:43:24,279
扫描，就像你只做扫描一样 吨 能够

1057
00:43:24,279 --> 00:43:26,049
评估谓词，如果我看到

1058
00:43:26,049 --> 00:43:30,180
匹配，然后我把我的输出缓冲区放在我的输出缓冲区中

1059
00:43:30,180 --> 00:43:32,680
，你可以做这个分支，或者

1060
00:43:32,680 --> 00:43:33,880
你可以做分支一个，

1061
00:43:33,880 --> 00:43:36,339
这取决于实现，所以

1062
00:43:36,339 --> 00:43:38,680
虽然这看起来像在天真的

1063
00:43:38,680 --> 00:43:39,910
例子中 看起来真的很愚蠢，您

1064
00:43:39,910 --> 00:43:41,829
不想这样做，因为

1065
00:43:41,829 --> 00:43:44,650
您可以进行优化以使其

1066
00:43:44,650 --> 00:43:46,119
更快，并且您可以做其他事情，例如如果我

1067
00:43:46,119 --> 00:43:47,890
知道我有上面的限制子句

1068
00:43:47,890 --> 00:43:49,450
并且我只想要两个 n 元组我 可以

1069
00:43:49,450 --> 00:43:52,779
将其推倒并吃掉它

1070
00:43:52,779 --> 00:43:56,920
，所以我认为

1071
00:43:56,920 --> 00:43:59,849
物化模型最

1072
00:43:59,849 --> 00:44:04,869
适合高质量的工作负载，因为这些

1073
00:44:04,869 --> 00:44:06,700
运算符是这些查询一次只想

1074
00:44:06,700 --> 00:44:08,049
接触少量元组，

1075
00:44:08,049 --> 00:44:10,269
因此输出的大小

1076
00:44:10,269 --> 00:44:11,859
我要推给下一个操作员

1077
00:44:11,859 --> 00:44:13,900
的缓冲区不会那么大

1078
00:44:13,900 --> 00:44:16,089
吗 像亚马逊一样获得轻松的帐户记录，你

1079
00:44:16,089 --> 00:44:17,829
知道亚马逊的网站是一个元组

1080
00:44:17,829 --> 00:44:19,269
，我的意思是需要从一个漏斗移动

1081
00:44:19,269 --> 00:44:21,869
到下一个右边，我们 因为会

1082
00:44:21,869 --> 00:44:25,029
受益 使用

1083
00:44:25,029 --> 00:44:27,609
一旦我们调用该输出函数，

1084
00:44:27,609 --> 00:44:29,259
我们就会调用该运算符，一旦我们获得该运算符所需的所有元组，我们就再也不会

1085
00:44:29,259 --> 00:44:30,400


1086
00:44:30,400 --> 00:44:31,670
返回它了

1087
00:44:31,670 --> 00:44:33,740
，我们将数据推长，这

1088
00:44:33,740 --> 00:44:35,270
减少了函数调用

1089
00:44:35,270 --> 00:44:37,099
的数量 将是昂贵的，因为

1090
00:44:37,099 --> 00:44:39,230
那些是我们指令

1091
00:44:39,230 --> 00:44:41,480
流中的跳转，我们执行，

1092
00:44:41,480 --> 00:44:43,400
所以我认为这是正确的

1093
00:44:43,400 --> 00:44:45,710
方法，然后当我们建造 H 门

1094
00:44:45,710 --> 00:44:47,089
，然后商业化 volte B

1095
00:44:47,089 --> 00:44:50,390
这就是我们如何我们 做到了 Monay DB

1096
00:44:50,390 --> 00:44:52,369
也做到了，尽管他们正试图

1097
00:44:52,369 --> 00:44:54,890
为分析做这件事，

1098
00:44:54,890 --> 00:44:56,059
所以他们不得不提出一堆论文

1099
00:44:56,059 --> 00:44:57,890
来真正克服这个

1100
00:44:57,890 --> 00:44:59,930
问题，比如试图

1101
00:44:59,930 --> 00:45:02,599
在内存中一次实现所有数据 高层

1102
00:45:02,599 --> 00:45:04,220
最初也是如此 有一个德国

1103
00:45:04,220 --> 00:45:07,430
学术系统 这种方法的旧版本

1104
00:45:07,430 --> 00:45:09,049
新版本没有

1105
00:45:09,049 --> 00:45:11,000
重写它来做矢量化模型

1106
00:45:11,000 --> 00:45:13,390
然后令人惊讶的是我认为这是真的

1107
00:45:13,390 --> 00:45:16,250
Teradata 做了同样的事情，但他们很

1108
00:45:16,250 --> 00:45:19,730
喜欢 一个大规模的你知道并行

1109
00:45:19,730 --> 00:45:21,319
数据仓库，所以他们运行 OLAP

1110
00:45:21,319 --> 00:45:23,180
查询，所以他们有一堆废话，

1111
00:45:23,180 --> 00:45:24,680
他们必须做一堆

1112
00:45:24,680 --> 00:45:26,990
尽可能多的下推，并且基本上将

1113
00:45:26,990 --> 00:45:29,660
运算符内联到彼此之间，以

1114
00:45:29,660 --> 00:45:31,760
避免你知道移动

1115
00:45:31,760 --> 00:45:33,650
从一个你知道一个不的批发数据

1116
00:45:33,650 --> 00:45:35,720
到下一个我需要仔细检查这个但

1117
00:45:35,720 --> 00:45:37,160
我很确定这是它的工作原理以及

1118
00:45:37,160 --> 00:45:37,720


1119
00:45:37,720 --> 00:45:41,210
令人惊讶的因为你知道撕裂

1120
00:45:41,210 --> 00:45:43,670
数据是在 1979 年设计的所以它

1121
00:45:43,670 --> 00:45:46,690
在矢量化模型之前

1122
00:45:46,690 --> 00:45:48,890
好的，所以最后一个是这个

1123
00:45:48,890 --> 00:45:50,329
向量化模型，所以这

1124
00:45:50,329 --> 00:45:52,490
对我们来说现在似乎很明显，但是就像在

1125
00:45:52,490 --> 00:45:55,670
来自 peter bouncing 和

1126
00:45:55,670 --> 00:45:58,910
marcin marcin 的 x100 论文之前一样，人们只是没有以

1127
00:45:58,910 --> 00:46:00,140
这种方式构建数据库系统，他们

1128
00:46:00,140 --> 00:46:02,480
要么使用物化模型，要么

1129
00:46:02,480 --> 00:46:05,510
或迭代器模型，所以

1130
00:46:05,510 --> 00:46:07,280
矢量奖模型基本上就像

1131
00:46:07,280 --> 00:46:08,390
迭代器，你有这个下一个

1132
00:46:08,390 --> 00:46:09,619
函数，并且明显地放置而不是

1133
00:46:09,619 --> 00:46:11,569
坐着发送单个元组，这

1134
00:46:11,569 --> 00:46:12,799
将花费 如果我们必须

1135
00:46:12,799 --> 00:46:14,660
一次扫描很多元组，我们可以

1136
00:46:14,660 --> 00:46:17,960
发送一批元组，

1137
00:46:17,960 --> 00:46:19,520
批次的大小将取决于

1138
00:46:19,520 --> 00:46:21,170
港口的

1139
00:46:21,170 --> 00:46:22,460
外观取决于我们是否可以成为运营

1140
00:46:22,460 --> 00:46:24,950
商 将其输入将能够

1141
00:46:24,950 --> 00:46:28,369
直接在 sim DS 上进行矢量化执行，

1142
00:46:28,369 --> 00:46:29,809
因此如果您知道我们高级编辑器的大小，

1143
00:46:29,809 --> 00:46:31,250
我们就可以决定

1144
00:46:31,250 --> 00:46:36,280
我们的批次不应该有多大，所以

1145
00:46:36,280 --> 00:46:38,599
现在回到我们这里的示例

1146
00:46:38,599 --> 00:46:39,799
稍微复杂一点 我们还有

1147
00:46:39,799 --> 00:46:41,510
next 函数，但是现在当我们调用

1148
00:46:41,510 --> 00:46:43,820
next 而不是取回

1149
00:46:43,820 --> 00:46:46,550
单个元组时，我们将取回

1150
00:46:46,550 --> 00:46:48,740
一批元组，然后在

1151
00:46:48,740 --> 00:46:51,200
内核中执行 for 循环时我们

1152
00:46:51,200 --> 00:46:54,350
可以知道要执行的向量化指令

1153
00:46:54,350 --> 00:46:56,030
这些事情并并行

1154
00:46:56,030 --> 00:46:58,040
有效地采取批处理应用

1155
00:46:58,040 --> 00:46:59,180
所有谓词，你

1156
00:46:59,180 --> 00:47:03,110
现在在另一边看同样的事情

1157
00:47:03,110 --> 00:47:06,770


1158
00:47:06,770 --> 00:47:08,750
，因为我们减少了

1159
00:47:08,750 --> 00:47:10,640
每个操作符移动

1160
00:47:10,640 --> 00:47:12,680
tupl的调用次数 从一个 Operator 到另一个 Operator

1161
00:47:12,680 --> 00:47:14,150
，我们可以

1162
00:47:14,150 --> 00:47:17,080
非常有效地执行向量化指令，

1163
00:47:17,080 --> 00:47:19,550
大多数日期和

1164
00:47:19,550 --> 00:47:22,700
过去 10 年中构建的一些数据库系统将

1165
00:47:22,700 --> 00:47:25,520
遵循这种方法，因此

1166
00:47:25,520 --> 00:47:27,230
如果您只是看看 server 和 db2 以及 Oracle

1167
00:47:27,230 --> 00:47:29,360
获取这些数据库系统的常规通用行

1168
00:47:29,360 --> 00:47:30,680
存储版本

1169
00:47:30,680 --> 00:47:32,540
它都将使用迭代器

1170
00:47:32,540 --> 00:47:34,580
模型 但是然后它们有专门的

1171
00:47:34,580 --> 00:47:35,900
执行引擎就像

1172
00:47:35,900 --> 00:47:39,610
我们为 Oracle db2 讨论过的破碎镜像的东西

1173
00:47:39,610 --> 00:47:42,140
有一个名为 blue 的加速器

1174
00:47:42,140 --> 00:47:43,820
对，这些都是

1175
00:47:43,820 --> 00:47:45,890
这些具有

1176
00:47:45,890 --> 00:47:48,230
矢量化执行模型的独立数据副本，它们获得了

1177
00:47:48,230 --> 00:47:50,060
更好的性能 cockroach DB

1178
00:47:50,060 --> 00:47:52,010
实际上不是，令人惊讶的是他们有

1179
00:47:52,010 --> 00:47:53,630
一篇博客文章表明他们有

1180
00:47:53,630 --> 00:47:58,940
一个矢量引擎，然后在

1181
00:47:58,940 --> 00:48:00,230
我们正在研究的新系统中

1182
00:48:00,230 --> 00:48:03,160
一切的效果线程也好

1183
00:48:03,160 --> 00:48:09,830
是的 问题是

1184
00:48:09,830 --> 00:48:15,110
向量的大小与我们系统中的相同膝盖大小对齐

1185
00:48:15,110 --> 00:48:22,040
它是一条线 缝合的大小，

1186
00:48:22,040 --> 00:48:23,750
但它不会完全相同的膝盖

1187
00:48:23,750 --> 00:48:26,000
寄存器大小，所以如果

1188
00:48:26,000 --> 00:48:28,520
你是 simi 寄存器是 512 512 位，

1189
00:48:28,520 --> 00:48:30,290
它不像你想只传递

1190
00:48:30,290 --> 00:48:32,270
5 和 12 位，你会

1191
00:48:32,270 --> 00:48:34,610
传递可能像 10

1192
00:48:34,610 --> 00:48:35,930
每个 5 位和 12 位的块，因此他们

1193
00:48:35,930 --> 00:48:38,420
喜欢您可以在该向量中获取一个块

1194
00:48:38,420 --> 00:48:40,460
，然后对其进行向量

1195
00:48:40,460 --> 00:48:45,020
执行，通常的工作方式

1196
00:48:45,020 --> 00:48:46,550
是，当您打开数据库时，这就是我们在系统中所做

1197
00:48:46,550 --> 00:48:48,740
的

1198
00:48:48,740 --> 00:48:50,900
系统他们会从 CPU 中读取信息，

1199
00:48:50,900 --> 00:48:53,060
就像你的程序集

1200
00:48:53,060 --> 00:48:54,770
寄存器大小一样，你的缓存大小，

1201
00:48:54,770 --> 00:48:55,930
然后你可以决定如何

1202
00:48:55,930 --> 00:48:59,680
通过这种方式调整大小，这

1203
00:48:59,680 --> 00:49:05,020
通常只是启发式的，所以我

1204
00:49:05,020 --> 00:49:06,640
之前已经说过了，

1205
00:49:06,640 --> 00:49:08,920
是的 我确定我所有的例子都是

1206
00:49:08,920 --> 00:49:11,170
从上到下展示的，但你

1207
00:49:11,170 --> 00:49:12,820
实际上可以从上到下，

1208
00:49:12,820 --> 00:49:14,530
这是最常见的，因为这

1209
00:49:14,530 --> 00:49:16,390
对你认识的人来说就像

1210
00:49:16,390 --> 00:49:18,400
人们如何

1211
00:49:18,400 --> 00:49:20,710
投票的教科书实现一样 abase systems

1212
00:49:20,710 --> 00:49:23,200
下周你将从 hyper 读到的论文表明

1213
00:49:23,200 --> 00:49:25,360
你实际上想要使用自下而上的

1214
00:49:25,360 --> 00:49:27,910
方法，因为现在你可以非常

1215
00:49:27,910 --> 00:49:29,950
小心地组织

1216
00:49:29,950 --> 00:49:32,740
额外查询的代码，以便在

1217
00:49:32,740 --> 00:49:35,040
你的管道中 '不仅仅是

1218
00:49:35,040 --> 00:49:38,350
从 CPU 缓存中的元组中获取值，

1219
00:49:38,350 --> 00:49:40,570
它们还可以进行更低级别的

1220
00:49:40,570 --> 00:49:42,250
控制，并尝试控制诸如

1221
00:49:42,250 --> 00:49:44,410
保留 CPU 寄存器之类的东西，因为这

1222
00:49:44,410 --> 00:49:46,750
将比

1223
00:49:46,750 --> 00:49:50,980
我们旧系统中的缓存 l1 缓存更快 是

1224
00:49:50,980 --> 00:49:52,300
因为我们有这种称为松弛

1225
00:49:52,300 --> 00:49:54,970
算子融合的技术，我将在

1226
00:49:54,970 --> 00:49:57,130
后面的讲座中介绍，但这实际上现在

1227
00:49:57,130 --> 00:50:00,280
在我们的新系统中，这里的想法

1228
00:50:00,280 --> 00:50:03,340
是我们正在尝试将

1229
00:50:03,340 --> 00:50:05,290
自下而上的方法与向量相结合 是

1230
00:50:05,290 --> 00:50:07,510
执行，我们正试图

1231
00:50:07,510 --> 00:50:09,100
在向量方面获得两全其美的结果，

1232
00:50:09,100 --> 00:50:11,200
因此我们正在尝试传递向量

1233
00:50:11,200 --> 00:50:13,780
并从下到上执行，并且需要

1234
00:50:13,780 --> 00:50:15,430
小心

1235
00:50:15,430 --> 00:50:17,830
放置缓冲区边界的位置，以便 你可以

1236
00:50:17,830 --> 00:50:19,720
站 获取一定大小的东西，这样

1237
00:50:19,720 --> 00:50:21,520
你就可以传递东西，并且可以

1238
00:50:21,520 --> 00:50:23,020
适应他所说的那种陡峭的寄存器

1239
00:50:23,020 --> 00:50:25,240
，它可能并不总是

1240
00:50:25,240 --> 00:50:27,130
管道中断点，它可能是

1241
00:50:27,130 --> 00:50:30,280
管道内的点，我想我会

1242
00:50:30,280 --> 00:50:33,030
介绍 稍后再讨论这个破坏者

1243
00:50:33,030 --> 00:50:35,940
好吧 现在让我们讨论一下

1244
00:50:35,940 --> 00:50:37,630
我们是否在进行

1245
00:50:37,630 --> 00:50:39,520
物化 你知道

1246
00:50:39,520 --> 00:50:41,260
正在使用什么处理模型 我们可以讨论我们如何

1247
00:50:41,260 --> 00:50:44,110
实际运行并行查询 所以

1248
00:50:44,110 --> 00:50:45,160
我们已经讨论了如何进行

1249
00:50:45,160 --> 00:50:46,840
内部查询 之前的踏板，但那

1250
00:50:46,840 --> 00:50:47,890
是我们上节课讨论过的调度内容，

1251
00:50:47,890 --> 00:50:50,410
或者我们很好地讨论了

1252
00:50:50,410 --> 00:50:51,460
这里的想法是我们将允许

1253
00:50:51,460 --> 00:50:53,560
同时运行多个查询

1254
00:50:53,560 --> 00:50:57,430
，因此您基本上拥有一个您知道的

1255
00:50:57,430 --> 00:50:59,530
调度机制来决定 您知道

1256
00:50:59,530 --> 00:51:01,660
哪些查询运行的任务是超

1257
00:51:01,660 --> 00:51:03,280
原始的，我们只能

1258
00:51:03,280 --> 00:51:04,360


1259
00:51:04,360 --> 00:51:05,830
在该查询完成后一次运行一个查询，然后您切换

1260
00:51:05,830 --> 00:51:08,080
到新系统中的下一个，他们

1261
00:51:08,080 --> 00:51:09,550
不这样做，而大多数情况下

1262
00:51:09,550 --> 00:51:12,280
您不这样做' 不要这样做，因为您

1263
00:51:12,280 --> 00:51:14,170
希望系统尽可能负责

1264
00:51:14,170 --> 00:51:15,940
，所以有时您会喜欢

1265
00:51:15,940 --> 00:51:18,270
快速查询 Q 和慢速查询 Q，

1266
00:51:18,270 --> 00:51:20,440
因此使用不同的技术，然后我们

1267
00:51:20,440 --> 00:51:23,110
使用并发角色来保护

1268
00:51:23,110 --> 00:51:26,970
数据，如果查询是 更新内容，所以

1269
00:51:26,970 --> 00:51:29,260
这是我的一个猜想我无法

1270
00:51:29,260 --> 00:51:30,910
证明它，但在我考虑了一下之后，我认为

1271
00:51:30,910 --> 00:51:33,310


1272
00:51:33,310 --> 00:51:36,820


1273
00:51:36,820 --> 00:51:39,010
实现不同的

1274
00:51:39,010 --> 00:51:42,820
查询处理模型的复杂

1275
00:51:42,820 --> 00:51:44,230
性没有任何差异，复杂性没有' 如果您使用不同的控制方案，则不会改变，

1276
00:51:44,230 --> 00:51:45,670
这意味着如果我正在

1277
00:51:45,670 --> 00:51:47,950
执行两相锁定或 OCC，

1278
00:51:47,950 --> 00:51:49,210
无论我使用的是

1279
00:51:49,210 --> 00:51:50,970
物化模型还是

1280
00:51:50,970 --> 00:51:54,520
矢量化模型 II 都认为

1281
00:51:54,520 --> 00:51:57,220
它们是它们 与我彼此隔离

1282
00:51:57,220 --> 00:51:58,750
，这

1283
00:51:58,750 --> 00:52:01,210
实际上并不重要，因为我的

1284
00:52:01,210 --> 00:52:02,770
访问方法想要去那是元组

1285
00:52:02,770 --> 00:52:04,090
，当它去的时候检查

1286
00:52:04,090 --> 00:52:05,260
我是否真的可以读取某些东西

1287
00:52:05,260 --> 00:52:06,700
是否被持有你知道

1288
00:52:06,700 --> 00:52:08,470
一些 其他的锁定它，所有这一切都

1289
00:52:08,470 --> 00:52:11,740
无关紧要，如果它好的话，

1290
00:52:11,740 --> 00:52:12,880
我们关心虽然是

1291
00:52:12,880 --> 00:52:14,770
介绍查询并行性，这就是

1292
00:52:14,770 --> 00:52:16,900
我们如何处理单个查询，现在

1293
00:52:16,900 --> 00:52:18,790
再次并行处理所有运算符的 X 键，

1294
00:52:18,790 --> 00:52:19,960
调度的东西是 上周这是

1295
00:52:19,960 --> 00:52:23,080
我们如何将这些任务分配给核心

1296
00:52:23,080 --> 00:52:25,900
现在基本上我们如何

1297
00:52:25,900 --> 00:52:28,840
组织查询计划中的数据流，

1298
00:52:28,840 --> 00:52:31,360
以便我们

1299
00:52:31,360 --> 00:52:34,330
可以确定是否允许运行一个任务

1300
00:52:34,330 --> 00:52:45,330
我们正处于

1301
00:52:46,050 --> 00:52:48,370
水平交叉和

1302
00:52:48,370 --> 00:52:49,460
垂直对之间

1303
00:52:49,460 --> 00:52:51,440
我可以让查询

1304
00:52:51,440 --> 00:52:53,420
计划的不同部分再次同时执行 我

1305
00:52:53,420 --> 00:52:54,950
需要注意

1306
00:52:54,950 --> 00:52:56,510
这些不同任务之间的数据依赖关系，

1307
00:52:56,510 --> 00:52:58,760
以确定我是否

1308
00:52:58,760 --> 00:53:03,530
还好 尽管我在

1309
00:53:03,530 --> 00:53:06,470
他接近时进行布局，但两者都不是，或者

1310
00:53:06,470 --> 00:53:08,300
您实际上可以将这两

1311
00:53:08,300 --> 00:53:10,160
件事结合在一起，您可以进行平行

1312
00:53:10,160 --> 00:53:12,109
和垂直堆积，并且

1313
00:53:12,109 --> 00:53:15,730
在同一个查询中一起进行也

1314
00:53:15,730 --> 00:53:18,500
有智慧 在每个单独的运算符中，

1315
00:53:18,500 --> 00:53:21,140
还有一个并行版本，我们可以使用它

1316
00:53:21,140 --> 00:53:22,280
执行查询，

1317
00:53:22,280 --> 00:53:24,050
执行该运算符，这

1318
00:53:24,050 --> 00:53:26,240
就是下周书籍没有涵盖的内容，或者

1319
00:53:26,240 --> 00:53:33,650
它们是我在排序中的并行连接，但

1320
00:53:33,650 --> 00:53:36,080
Twitter 的我们的运算符然后被

1321
00:53:36,080 --> 00:53:38,810
实例化为或 作为单独的

1322
00:53:38,810 --> 00:53:41,030
实例，它们都很好，它们

1323
00:53:41,030 --> 00:53:42,740
将执行所有

1324
00:53:42,740 --> 00:53:44,330
操作实例将

1325
00:53:44,330 --> 00:53:47,060
仅在不同的数据块上形成相同的功能，这是

1326
00:53:47,060 --> 00:53:49,190
上次将我的

1327
00:53:49,190 --> 00:53:50,990
表格分成水平运动的更多部分，

1328
00:53:50,990 --> 00:53:52,820
然后 不同的实例将同时

1329
00:53:52,820 --> 00:53:54,200
运行在不同的不同

1330
00:53:54,200 --> 00:53:56,330
分区中，因此为了

1331
00:53:56,330 --> 00:53:58,099
协调这些

1332
00:53:58,099 --> 00:54:04,099
同时运行的不同实例，它们基本上

1333
00:54:04,099 --> 00:54:07,339
是我们查询计划中的断点的另一种方式，

1334
00:54:07,339 --> 00:54:09,170
以便我们可以认识到我们

1335
00:54:09,170 --> 00:54:11,030
无法继续执行 查询计划，

1336
00:54:11,030 --> 00:54:13,490
直到我们下面的所有运算符实例

1337
00:54:13,490 --> 00:54:16,670
生成它们应该生成的所有元组，然后

1338
00:54:16,670 --> 00:54:18,740
再次

1339
00:54:18,740 --> 00:54:20,150
等待我们组织查询计划并

1340
00:54:20,150 --> 00:54:23,540
保持 在内部跟踪您

1341
00:54:23,540 --> 00:54:25,040
是否知道一组

1342
00:54:25,040 --> 00:54:27,859
操作任务是否允许运行，所以

1343
00:54:27,859 --> 00:54:31,280
说我们对 Beam 进行了简单的查询，这样我们

1344
00:54:31,280 --> 00:54:34,910
就可以在 a 上进行扫描，然后我们可以将

1345
00:54:34,910 --> 00:54:35,900
其分解为不同的操作员

1346
00:54:35,900 --> 00:54:37,640
实例和每个人

1347
00:54:37,640 --> 00:54:39,580
将在我们和一个单独的工作人员中运行

1348
00:54:39,580 --> 00:54:43,520
，然后现在因为我想做我想

1349
00:54:43,520 --> 00:54:45,440
在我的管道中找到其他操作员

1350
00:54:45,440 --> 00:54:48,770
我也可以做过

1351
00:54:48,770 --> 00:54:51,320
滤器所以获取这些扫描中的每一个的输出

1352
00:54:51,320 --> 00:54:52,820
并立即将其输入

1353
00:54:52,820 --> 00:54:55,040
这个过滤器操作符然后删除

1354
00:54:55,040 --> 00:54:57,830
任何不应该存在的东西，但现在

1355
00:54:57,830 --> 00:54:59,810
我也可以做其他组织，比如

1356
00:54:59,810 --> 00:55:01,910
如果我在这里有这个投影，它

1357
00:55:01,910 --> 00:55:03,170
告诉我我只需要

1358
00:55:03,170 --> 00:55:05,960
我只需要八个隐藏的查询并

1359
00:55:05,960 --> 00:55:09,589
说这是一个稳定的 有一千二个

1360
00:55:09,589 --> 00:55:11,869
池，而不是我

1361
00:55:11,869 --> 00:55:13,940
从一个操作附件中复制一千个元组，

1362
00:55:13,940 --> 00:55:16,490
我现在实际上可以向下推

1363
00:55:16,490 --> 00:55:18,260
，在这里制作投影的副本以过滤

1364
00:55:18,260 --> 00:55:19,819
掉所有东西，除了

1365
00:55:19,819 --> 00:55:22,490
我在这里需要的一个，那么现在他们' 关于 

1366
00:55:22,490 --> 00:55:23,869
要做他们需要

1367
00:55:23,869 --> 00:55:25,579
构建哈希表的连接，我没有

1368
00:55:25,579 --> 00:55:28,579
声明这个哈希表是单个哈希

1369
00:55:28,579 --> 00:55:29,990
表还是这个分区

1370
00:55:29,990 --> 00:55:33,040
无关紧要，但我知道我现在不能

1371
00:55:33,040 --> 00:55:35,540
在这方面做任何事情 在实际构建哈希表之前，我无法开始

1372
00:55:35,540 --> 00:55:37,309
扫描 B 并在哈希表中执行程序，

1373
00:55:37,309 --> 00:55:39,559


1374
00:55:39,559 --> 00:55:41,630
否则我可能会得到

1375
00:55:41,630 --> 00:55:43,280
假阴性正确的 ID 查找并

1376
00:55:43,280 --> 00:55:45,440
说它是我的哈希表包含它应该包含的这个键，

1377
00:55:45,440 --> 00:55:49,900
但我只是没有 得到了但我

1378
00:55:49,900 --> 00:55:53,119
在继续下一个之前等待这些带来

1379
00:55:53,119 --> 00:55:55,220
所以这就是

1380
00:55:55,220 --> 00:55:56,900
交换运营商正在为我们做的事情

1381
00:55:56,900 --> 00:55:58,430
现在基本上是一种方法来合并

1382
00:55:58,430 --> 00:55:59,869


1383
00:55:59,869 --> 00:56:01,880
运行在不同工作人员上的这些不同任务的结果

1384
00:56:01,880 --> 00:56:03,980
并跟踪我不能

1385
00:56:03,980 --> 00:56:08,390
继续直到这完成然后现在

1386
00:56:08,390 --> 00:56:10,819
为此在右侧我正在

1387
00:56:10,819 --> 00:56:12,740
对 B 进行扫描同样的事情也做过

1388
00:56:12,740 --> 00:56:15,650
滤器做我的投影现在

1389
00:56:15,650 --> 00:56:18,260
我平行地探测我的哈希表

1390
00:56:18,260 --> 00:56:20,270
，这些人中的每一个都会

1391
00:56:20,270 --> 00:56:22,490
产生输出，但要 确保

1392
00:56:22,490 --> 00:56:24,200
在查询全部完成之前我不会产生查询的最终结果

1393
00:56:24,200 --> 00:56:26,780
我

1394
00:56:26,780 --> 00:56:29,000
在这里添加另一个交换运算符只

1395
00:56:29,000 --> 00:56:30,410
知道我正在等待三个线程

1396
00:56:30,410 --> 00:56:31,760
给我所有结果然后一旦我

1397
00:56:31,760 --> 00:56:32,869
拥有一切 我可以将

1398
00:56:32,869 --> 00:56:36,829
输出显示给上面的两个，所以现在

1399
00:56:36,829 --> 00:56:38,510
我的例子在这里我

1400
00:56:38,510 --> 00:56:41,270
在我们构建哈希

1401
00:56:41,270 --> 00:56:42,859
表之后把交换运算符放在一个瓶子上

1402
00:56:42,859 --> 00:56:45,700
我们绝对需要这个但我可以

1403
00:56:45,700 --> 00:56:50,410
设置查询这样 我有一个我

1404
00:56:50,410 --> 00:56:53,089
在这里有一个交换操作符，我在这里

1405
00:56:53,089 --> 00:56:54,740
进行扫描，过滤器进行

1406
00:56:54,740 --> 00:56:58,089
投影，然后我的所有

1407
00:56:58,089 --> 00:57:00,650
操作符实例任务开始填充

1408
00:57:00,650 --> 00:57:02,540
此交换操作符中的输出缓冲区

1409
00:57:02,540 --> 00:57:04,160
，然后一旦它们全部完成

1410
00:57:04,160 --> 00:57:06,589
，就是这样 完成然后现在我可以平坦地

1411
00:57:06,589 --> 00:57:10,549
拥有查询爆炸或

1412
00:57:10,549 --> 00:57:12,920
执行连接并产生结果的理论，所以

1413
00:57:12,920 --> 00:57:14,180
有不同的选择来

1414
00:57:14,180 --> 00:57:16,520
退出这个查询，这同样

1415
00:57:16,520 --> 00:57:16,850


1416
00:57:16,850 --> 00:57:18,950
取决于 dista 倾向于什么

1417
00:57:18,950 --> 00:57:20,870
谓词的选择性参加

1418
00:57:20,870 --> 00:57:23,390
join 子句的选择性 数据可以

1419
00:57:23,390 --> 00:57:24,560
尝试找出正确的方法来做到

1420
00:57:24,560 --> 00:57:26,870
这一点，或者没有一个

1421
00:57:26,870 --> 00:57:31,760
计划对每个人都适用所以现在对于

1422
00:57:31,760 --> 00:57:34,310
操作符间并行性垂直

1423
00:57:34,310 --> 00:57:37,130
并行性这里的想法是我们

1424
00:57:37,130 --> 00:57:40,190
现在可以重叠不同 运算符同时运行

1425
00:57:40,190 --> 00:57:42,050
，我们仍然必须

1426
00:57:42,050 --> 00:57:43,520
使用交换运算符来

1427
00:57:43,520 --> 00:57:45,710
跟踪您是否知道一个运算符实例

1428
00:57:45,710 --> 00:57:48,260
一组运算符实例已经

1429
00:57:48,260 --> 00:57:49,490
产生了所有结果，

1430
00:57:49,490 --> 00:57:52,280
但不是你知道做

1431
00:57:52,280 --> 00:57:53,900
一个然后你知道 一堆工作

1432
00:57:53,900 --> 00:57:55,100
然后切换到下一个

1433
00:57:55,100 --> 00:57:57,890
我可以让一个线程开始处理

1434
00:57:57,890 --> 00:58:00,560
从它下面的查询计划到达的数据

1435
00:58:00,560 --> 00:58:05,660
并并行执行所以

1436
00:58:05,660 --> 00:58:07,520
这有时是平行切割线

1437
00:58:07,520 --> 00:58:09,020
意味着我正在运行管道

1438
00:58:09,020 --> 00:58:12,530
平行所以说我

1439
00:58:12,530 --> 00:58:15,410
在四个表中做笛卡尔积我加入了一个 B

1440
00:58:15,410 --> 00:58:17,780
和 C 和 D 没有不 - 不要调用

1441
00:58:17,780 --> 00:58:19,310
正确但你实际上不会这样做

1442
00:58:19,310 --> 00:58:24,230
但在这里它是正确的，所以查询

1443
00:58:24,230 --> 00:58:25,970
将 d 看起来像这样我现在可以

1444
00:58:25,970 --> 00:58:28,790
运行 a 然后 B 并并行执行

1445
00:58:28,790 --> 00:58:31,220
但它说我知道我不能

1446
00:58:31,220 --> 00:58:34,870
在场景 D 输出上执行剩余的连接

1447
00:58:34,870 --> 00:58:38,300
，直到这一切都完成然后我

1448
00:58:38,300 --> 00:58:40,400
把我的 交换运算符，所以会

1449
00:58:40,400 --> 00:58:42,980
发生什么是我可以让一个线程

1450
00:58:42,980 --> 00:58:45,170
在 a 和 B 上进行连接，在此处填充一些输出

1451
00:58:45,170 --> 00:58:47,390
缓冲区，然后这意味着

1452
00:58:47,390 --> 00:58:49,670
构建哈希表，然后

1453
00:58:49,670 --> 00:58:51,080
我可以做另一件事，连接和 C

1454
00:58:51,080 --> 00:58:54,590
和 D 但是 然后一次又一次，就像这些

1455
00:58:54,590 --> 00:58:57,830
人一样，对于这个人来说，加入

1456
00:58:57,830 --> 00:59:02,630
结果让这件事小睡时间是

1457
00:59:02,630 --> 00:59:03,790
正确的，

1458
00:59:03,790 --> 00:59:05,380
因为在这种情况下，这里没有

1459
00:59:05,380 --> 00:59:06,880
where 子句

1460
00:59:06,880 --> 00:59:09,340
，没有连接子句来

1461
00:59:09,340 --> 00:59:11,860
确定某些东西是否匹配，所以我正在

1462
00:59:11,860 --> 00:59:13,090
做笛卡尔积，所以 我想

1463
00:59:13,090 --> 00:59:15,310
从 C 和 D 中取出任何元组

1464
00:59:15,310 --> 00:59:17,230
并混搭适合与 a 和 B 匹配的任何元组，

1465
00:59:17,230 --> 00:59:18,940
所以我不需要在

1466
00:59:18,940 --> 00:59:20,380
技术上等待这些人他们

1467
00:59:20,380 --> 00:59:21,940
可以搜索的公平性将所有数据

1468
00:59:21,940 --> 00:59:24,190
并行推出 并且知道你一定会

1469
00:59:24,190 --> 00:59:26,110
开始计算剩下的 联合

1470
00:59:26,110 --> 00:59:32,140
也是正确的 好吧 所以为了尽快完成它

1471
00:59:32,140 --> 00:59:36,130
我们也可以真正谈论的主题

1472
00:59:36,130 --> 00:59:37,930
也是如何

1473
00:59:37,930 --> 00:59:39,580
确定我们将使用的工人数量

1474
00:59:39,580 --> 00:59:41,050
我们

1475
00:59:41,050 --> 00:59:43,870
谈到了最后一次 我们想如何

1476
00:59:43,870 --> 00:59:45,520
组织这种草图

1477
00:59:45,520 --> 00:59:47,500
机制，但我们从来没有真正决定

1478
00:59:47,500 --> 00:59:49,560
好我有这个数量的内核

1479
00:59:49,560 --> 00:59:52,090
还没有，这个数量的任务

1480
00:59:52,090 --> 00:59:54,190
应该实际使用多少工人，正如我

1481
00:59:54,190 --> 00:59:56,050
在那个例子中已经提到的那样

1482
00:59:56,050 --> 00:59:59,770
对于水平

1483
00:59:59,770 --> 01:00:02,470
并行性，它取决于

1484
01:00:02,470 --> 01:00:04,630
数据的样子 谓词的选择性是什么

1485
01:00:04,630 --> 01:00:05,830
以及

1486
01:00:05,830 --> 01:00:08,890
我将生成多少输出数据 所以一种简单的

1487
01:00:08,890 --> 01:00:10,750
方法可以做到这一点，在超级的情况下，

1488
01:00:10,750 --> 01:00:12,700
您只有一名工人 每个核心

1489
01:00:12,700 --> 01:00:14,740
，您只需将它们固定到

1490
01:00:14,740 --> 01:00:16,060
它们实际运行的核心，然后

1491
01:00:16,060 --> 01:00:17,170
另一种方法是

1492
01:00:17,170 --> 01:00:18,220
每个核心有多个工作人员，这就是 Hana

1493
01:00:18,220 --> 01:00:20,920
方法，这里的想法是，如果

1494
01:00:20,920 --> 01:00:24,010
有一个工作人员阻塞，那么我们只是

1495
01:00:24,010 --> 01:00:26,170
您知道 让其他内核同时运行 运行线程在内核中运行

1496
01:00:26,170 --> 01:00:27,280


1497
01:00:27,280 --> 01:00:31,120
正确的最后一件事要再次谈论的

1498
01:00:31,120 --> 01:00:33,850
是，我认为我们

1499
01:00:33,850 --> 01:00:34,720
已经涵盖了最后一个类

1500
01:00:34,720 --> 01:00:37,060
实际上推与拉 是的，实际上我们

1501
01:00:37,060 --> 01:00:38,320
忽略了这一点 这只是 草图

1502
01:00:38,320 --> 01:00:39,160
我不知道为什么会出现在这里

1503
01:00:39,160 --> 01:00:42,040
抱歉这只是说就像在

1504
01:00:42,040 --> 01:00:44,580
hyper 的情况下我

1505
01:00:44,580 --> 01:00:48,040
从全局队列中拉取而在 Hana 的情况

1506
01:00:48,040 --> 01:00:50,200
下我将东西推入

1507
01:00:50,200 --> 01:00:51,610
队列然后线程有

1508
01:00:51,610 --> 01:00:56,250
删除好吧，所以结束

1509
01:00:56,250 --> 01:01:00,910
所以正如我今天所说的那样，周一人们认为这是

1510
01:01:00,910 --> 01:01:03,160
我们最简单的方法，因为

1511
01:01:03,160 --> 01:01:04,270
人类实施我们的

1512
01:01:04,270 --> 01:01:05,830
数据库系统的某些部分可能

1513
01:01:05,830 --> 01:01:07,330
是 CPU 实际执行的最糟糕的方式

1514
01:01:07,330 --> 01:01:09,520
因此，如果我们

1515
01:01:09,520 --> 01:01:10,960
知道港口的样子以及它

1516
01:01:10,960 --> 01:01:12,940
的行为方式，我们可能不知道具体

1517
01:01:12,940 --> 01:01:15,640
会如何，但我们至少要

1518
01:01:15,640 --> 01:01:17,230
注意它看起来

1519
01:01:17,230 --> 01:01:19,390
我们可以为我们的数据系统设计执行代码

1520
01:01:19,390 --> 01:01:22,630
最适合与

1521
01:01:22,630 --> 01:01:24,250
哈佛 CPU 实际上是一次，

1522
01:01:24,250 --> 01:01:27,880
然后正如我们今天在

1523
01:01:27,880 --> 01:01:30,280
本学期剩下的时间里看到的那样，我

1524
01:01:30,280 --> 01:01:31,810
认为矢量化底部执行

1525
01:01:31,810 --> 01:01:32,859
方法将是始终

1526
01:01:32,859 --> 01:01:36,480
退出 OLTP 的 olaf 实验室查询的最佳方式，它将是

1527
01:01:36,480 --> 01:01:39,790
自下而上的物化，但是 大多数

1528
01:01:39,790 --> 01:01:41,290
系统，很多时候你

1529
01:01:41,290 --> 01:01:44,740
认为像 Postgres 我的 siegel db2 oracle

1530
01:01:44,740 --> 01:01:46,240
所有这些都被设计成

1531
01:01:46,240 --> 01:01:47,950
通用系统，这

1532
01:01:47,950 --> 01:01:51,190
就是迭代器试图成为的样子，而不是

1533
01:01:51,190 --> 01:01:54,090
对每个人都有好处 是的，

1534
01:01:54,570 --> 01:01:56,350
为什么 Bodmin 很重要 对于

1535
01:01:56,350 --> 01:02:00,340
自上而下较少的函数

1536
01:02:00,340 --> 01:02:02,500
调用，就像在

1537
01:02:02,500 --> 01:02:05,890
通道化模型中自下而上一样，我调用了

1538
01:02:05,890 --> 01:02:08,470
操作

1539
01:02:08,470 --> 01:02:10,570
符，它运行的那个操作符的执行函数会产生一些

1540
01:02:10,570 --> 01:02:12,850
输出，如果输出现在调用下一个

1541
01:02:12,850 --> 01:02:15,730
函数，依此类推，如果

1542
01:02:15,730 --> 01:02:17,950
你要自上而下，这就像调用

1543
01:02:17,950 --> 01:02:19,480
这个调用这个调用这个我想这些

1544
01:02:19,480 --> 01:02:22,720
东西对于物化仍然是一样的

1545
01:02:22,720 --> 01:02:27,630
它与

1546
01:02:27,630 --> 01:02:53,590
向量化无关是的，是的，他是对的，它

1547
01:02:53,590 --> 01:02:55,480
的内部执行是t 一个清晰的

1548
01:02:55,480 --> 01:02:59,770
执行，然后当你

1549
01:02:59,770 --> 01:03:03,340
喜欢的时候，据我所知

1550
01:03:03,340 --> 01:03:04,780
，如果它只是一堆无条件的，那么你可以为编译器提供最好的代码

1551
01:03:04,780 --> 01:03:08,109
，

1552
01:03:08,109 --> 01:03:10,270
一切都是一条又一条的指令

1553
01:03:10,270 --> 01:03:11,859
，因为

1554
01:03:11,859 --> 01:03:13,510
编译器看起来很热 整体事件并

1555
01:03:13,510 --> 01:03:19,900
做出更好的决定好吧，你的

1556
01:03:19,900 --> 01:03:24,730
交叉腿也更小是的，这

1557
01:03:24,730 --> 01:03:27,990
通常不会成为问题

1558
01:03:27,990 --> 01:03:33,670
查询计划，但

1559
01:03:33,670 --> 01:03:38,490
就像调用堆栈一样，你知道这不是我的意思

1560
01:03:38,490 --> 01:03:41,260
是，但我无法想象会

1561
01:03:41,260 --> 01:03:43,270
就像一百万个函数调用一样，

1562
01:03:43,270 --> 01:03:45,490
就像查询计划中的运算符一样，那

1563
01:03:45,490 --> 01:03:48,220
是洋葱门我什至不能举个例子

1564
01:03:48,220 --> 01:03:51,520
，这样的查询不能很大，但

1565
01:03:51,520 --> 01:03:55,330
就像主题一样，没有人在做 100 万个

1566
01:03:55,330 --> 01:03:57,850
表关节我认为

1567
01:03:57,850 --> 01:04:02,170
解决的最高数字来自我

1568
01:04:02,170 --> 01:04:05,350
最近看到 Hana 人的一次谈话，他们有一个

1569
01:04:05,350 --> 01:04:07,120
查询正在执行 1,500 个表的连接，

1570
01:04:07,120 --> 01:04:10,000
很多，但不是一百万，

1571
01:04:10,000 --> 01:04:14,290
所以它不会成为

1572
01:04:14,290 --> 01:04:16,140
调用堆栈，我不认为 它 我是不是有点不好，

1573
01:04:16,140 --> 01:04:19,120
所以我再次意识到我

1574
01:04:19,120 --> 01:04:20,950
一直在说哦，好吧，周一报道这个，

1575
01:04:20,950 --> 01:04:22,630
我们将在一天内报道这个，所以周一的

1576
01:04:22,630 --> 01:04:24,550
汇编内容

1577
01:04:24,550 --> 01:04:28,600
是我的论文会议，

1578
01:04:28,600 --> 01:04:30,850
来自超级家伙和 我是说上帝，我

1579
01:04:30,850 --> 01:04:33,130
指着像 Thomas Newman 这样的

1580
01:04:33,130 --> 01:04:34,750
系统，他自己写了这篇论文，

1581
01:04:34,750 --> 01:04:37,810
这很疯狂，而且它有点密集，

1582
01:04:37,810 --> 01:04:39,940
因为它显示了所有 L of M bar 中的很少一部分

1583
01:04:39,940 --> 01:04:41,530
，你不需要它，因为是的，

1584
01:04:41,530 --> 01:04:44,070
有任何 想法他们正在做什么

1585
01:04:44,070 --> 01:04:46,450
组织查询计划是这样一种方式

1586
01:04:46,450 --> 01:04:48,400
，它是编译器

1587
01:04:48,400 --> 01:04:51,670
生成 CPU 高效代码的理想选择

1588
01:04:51,670 --> 01:04:54,910
主要内容应该没问题

1589
01:04:54,910 --> 01:05:01,170


1590
01:05:01,980 --> 01:05:04,049


1591
01:05:04,049 --> 01:05:06,240


1592
01:05:06,240 --> 01:05:08,369
以更详细的方式介绍 Cindy 我们将

1593
01:05:08,369 --> 01:05:10,230
不得不就此做两堂课 问题

1594
01:05:10,230 --> 01:05:12,359
是 Cindy 指令是否将

1595
01:05:12,359 --> 01:05:13,559
您想要放入同一

1596
01:05:13,559 --> 01:05:15,180
指令中的数据点做它们是否需要

1597
01:05:15,180 --> 01:05:16,980
连续以便它的工作方式

1598
01:05:16,980 --> 01:05:18,660
是存在的 矢量化

1599
01:05:18,660 --> 01:05:21,119
注册并且您必须加载到

1600
01:05:21,119 --> 01:05:23,819
您正在加载的数据

1601
01:05:23,819 --> 01:05:27,990
不一定是您必须将

1602
01:05:27,990 --> 01:05:29,819
其放入应用程序的全部内容实际上它会继续

1603
01:05:29,819 --> 01:05:31,680
记忆他的PU缓存然后将其

1604
01:05:31,680 --> 01:05:33,990
写入我认为您不能 确实

1605
01:05:33,990 --> 01:05:35,040
喜欢从不同的

1606
01:05:35,040 --> 01:05:39,619
位置多次加载，所以如果现在数据位于内存中的

1607
01:05:39,619 --> 01:05:41,940
不同位置，您

1608
01:05:41,940 --> 01:05:43,530
一直在复制到一个位置然后

1609
01:05:43,530 --> 01:05:45,240
复制它，但我想我是否正在

1610
01:05:45,240 --> 01:05:46,770
尝试对列进行扫描并

1611
01:05:46,770 --> 01:05:48,540
应用 谓词进入 vectra 的

1612
01:05:48,540 --> 01:05:50,160
指令它对我来说都是连续

1613
01:05:50,160 --> 01:05:58,950
的 是的 是的 所以他说有一个

1614
01:05:58,950 --> 01:06:00,329
分散和收集 CP 指令

1615
01:06:00,329 --> 01:06:04,799
为此我不知道其中一个是

1616
01:06:04,799 --> 01:06:07,339
实现我忘记了哪个我

1617
01:06:07,339 --> 01:06:12,930
认为这是一个可能喜欢的

1618
01:06:12,930 --> 01:06:15,660
我想到 2019 年 2020 年，也许

1619
01:06:15,660 --> 01:06:17,369
在某个时期，必须

1620
01:06:17,369 --> 01:06:18,089
通过多个

1621
01:06:18,089 --> 01:06:19,880
指令来实现诸如收集，它为您做到了，

1622
01:06:19,880 --> 01:06:22,710
是的，我们也将涵盖所有内容

1623
01:06:22,710 --> 01:06:30,030
是的，是的，所以我不知道共享是什么

1624
01:06:30,030 --> 01:06:32,730
屏幕所以共享扫描是如果我有

1625
01:06:32,730 --> 01:06:34,559
两个曲 系列

1626
01:06:34,559 --> 01:06:36,540
同时出现，并且船访问同

1627
01:06:36,540 --> 01:06:39,720
一张表，这有点棘手，在

1628
01:06:39,720 --> 01:06:40,740
内存系统中，这就是为什么他们想像

1629
01:06:40,740 --> 01:06:42,510
基于磁盘的系统一样覆盖它，但

1630
01:06:42,510 --> 01:06:43,950
最昂贵的事情是

1631
01:06:43,950 --> 01:06:46,290
获取页面，所以即使 你和我

1632
01:06:46,290 --> 01:06:47,280
同时运行，但我们有

1633
01:06:47,280 --> 01:06:49,079
完全不同的谓词，如果我们

1634
01:06:49,079 --> 01:06:51,270
可以共享该磁盘 i/o 来获取

1635
01:06:51,270 --> 01:06:53,520
它，然后我们获取表

1636
01:06:53,520 --> 01:06:55,770
或块的副本并分别执行我们的谓词，

1637
01:06:55,770 --> 01:06:58,859
那么这是一个巨大的胜利

1638
01:06:58,859 --> 01:07:01,260
对于内存系统

1639
01:07:01,260 --> 01:07:04,050
哦，我仍然会得到一些好处，也许

1640
01:07:04,050 --> 01:07:06,090
让局部性将它带入我的 CPU

1641
01:07:06,090 --> 01:07:08,430
缓存，这样仍然很

1642
01:07:08,430 --> 01:07:12,450
重要，同时协调

1643
01:07:12,450 --> 01:07:13,859
不同谓词的开销我

1644
01:07:13,859 --> 01:07:17,190
认为有时就像你一样棘手 可以

1645
01:07:17,190 --> 01:07:19,020
做的事情就像我认为 Hana 人做的

1646
01:07:19,020 --> 01:07:21,720
事情看起来像这样，如果我的

1647
01:07:21,720 --> 01:07:25,950
查询就像我们是

1648
01:07:25,950 --> 01:07:27,869
等于 1 而您的查询

1649
01:07:27,869 --> 01:07:29,820
等于 2 然后他们会将其转换

1650
01:07:29,820 --> 01:07:33,420
为 where a in 1 逗号 2 并应用该

1651
01:07:33,420 --> 01:07:36,300
谓词 一次然后

1652
01:07:36,300 --> 01:07:38,010
我们都得到的输出然后我们都

1653
01:07:38,010 --> 01:07:39,210
必须应用我们的额外

1654
01:07:39,210 --> 01:07:41,400
谓词来获得我们真正想要的东西所以

1655
01:07:41,400 --> 01:07:44,760
有这样的技巧你可以做

1656
01:07:44,760 --> 01:07:46,050
我不认为这对敌方

1657
01:07:46,050 --> 01:07:49,470
系统来说很常见，因为它 真的需要

1658
01:07:49,470 --> 01:07:50,820
这就像

1659
01:07:50,820 --> 01:07:52,260
在完全相同的时间显示的查询的精确度可以

1660
01:07:52,260 --> 01:07:54,530
做到这

1661
01:07:58,010 --> 01:08:27,540
一点是的，所以他的问题是在

1662
01:08:27,540 --> 01:08:30,180
基于磁盘的系统中进行扫描共享，或者

1663
01:08:30,180 --> 01:08:34,020
一种技术是如果我需要

1664
01:08:34,020 --> 01:08:35,939
进行扫描 表，但我有一个限制

1665
01:08:35,939 --> 01:08:38,100
子句，所以我只需要你知道

1666
01:08:38,100 --> 01:08:40,410
10 到极点，而不仅仅是打开一个

1667
01:08:40,410 --> 01:08:43,080
光标或扫描表

1668
01:08:43,080 --> 01:08:45,450
我可以去看看我的缓冲池中

1669
01:08:45,450 --> 01:08:47,100
找出我已经从那个表中得到了什么

1670
01:08:47,100 --> 01:08:50,189
，如果我 有足够的元组，然后我

1671
01:08:50,189 --> 01:08:52,259
只是基于它进行处理我认为

1672
01:08:52,259 --> 01:08:54,029
实际上没有人这样做我认为

1673
01:08:54,029 --> 01:08:56,069
每个人总是只进行扫描，

1674
01:08:56,069 --> 01:08:58,080
因为如果它已经在您的缓冲

1675
01:08:58,080 --> 01:08:59,759
池中，那么当您在该页面上进行查找时，

1676
01:08:59,759 --> 01:09:02,250
您会得到一个命中 在缓冲池中

1677
01:09:02,250 --> 01:09:04,890
我没有 认为任何人实际上都按照

1678
01:09:04,890 --> 01:09:07,109
您的建议执行了我们应该为

1679
01:09:07,109 --> 01:09:10,160
我做的项目介绍类

1680
01:09:10,160 --> 01:09:12,600
嗯另一个更常见的事情

1681
01:09:12,600 --> 01:09:14,430
是索引的覆盖查询

1682
01:09:14,430 --> 01:09:15,180
如果

1683
01:09:15,180 --> 01:09:16,710
我有所有答案我需要

1684
01:09:16,710 --> 01:09:21,300
处理查询 在索引本身中，它是一个

1685
01:09:21,300 --> 01:09:22,770
最低限度的扫描共享，它只是

1686
01:09:22,770 --> 01:09:24,180
避免不得不去

1687
01:09:24,180 --> 01:09:26,700
看看看看桌子上的实际扫描，所以

1688
01:09:26,700 --> 01:09:28,109
这可能更常见我不

1689
01:09:28,109 --> 01:09:29,430
知道有人偷看buff

1690
01:09:29,430 --> 01:09:30,899
球看看那里有什么 看看

1691
01:09:30,899 --> 01:09:34,319
对我来说是否足够，因为你

1692
01:09:34,319 --> 01:09:35,490
需要保持一些启发式

1693
01:09:35,490 --> 01:09:37,380
来表达，就像我认为你在做的事情一样

1694
01:09:37,380 --> 01:09:39,029
，它是大海捞针搜索中的一根针，

1695
01:09:39,029 --> 01:09:42,029
所以我的查询显示它在

1696
01:09:42,029 --> 01:09:43,830
表 a 上，但大多数查询是 在

1697
01:09:43,830 --> 01:09:45,660
桌子上是这样，但每次我去

1698
01:09:45,660 --> 01:09:47,520
看看我兄弟的游泳池，我都是你

1699
01:09:47,520 --> 01:09:49,529
从 B 看到的页面，然后我只是在浪费

1700
01:09:49,529 --> 01:09:50,040
时间

1701
01:09:50,040 --> 01:09:52,319
——我只是去扫描一个，这样你就可以

1702
01:09:52,319 --> 01:09:54,120
保持一些启发式和 保持

1703
01:09:54,120 --> 01:09:57,420
某种快速查找 说像哦，

1704
01:09:57,420 --> 01:09:59,760
如果你正在寻找桌子，就像去

1705
01:09:59,760 --> 01:10:01,200
你知道的东西，你知道你会

1706
01:10:01,200 --> 01:10:02,070
在缓冲池中找到一些东西

1707
01:10:02,070 --> 01:10:03,210
有可能

1708
01:10:03,210 --> 01:10:07,970
我认为没有人

1709
01:10:08,900 --> 01:10:10,740
会这样做，我不知道是否有 将有足够多的

1710
01:10:10,740 --> 01:10:12,750
查询想要为 ol OTP 做正确的事情

1711
01:10:12,750 --> 01:10:15,900
去获取 Andy 的记录

1712
01:10:15,900 --> 01:10:17,310
我将按照索引它会带

1713
01:10:17,310 --> 01:10:19,080
我到我想要获取的页面然后我

1714
01:10:19,080 --> 01:10:22,440
为 OLAP 获取它通常就像

1715
01:10:22,440 --> 01:10:26,040
扫描整个 具有限制调用的表格内容

1716
01:10:26,040 --> 01:10:27,810
就像加载

1717
01:10:27,810 --> 01:10:30,180
网页一样 看起来像黑客

1718
01:10:30,180 --> 01:10:32,010
新闻 你可以看到前十个帖子，无论

1719
01:10:32,010 --> 01:10:33,410
它们在哪里，最近的十个脚趾

1720
01:10:33,410 --> 01:10:35,250
有一个限制调用，以使其

1721
01:10:35,250 --> 01:10:38,010
正常工作，但它是

1722
01:10:38,010 --> 01:10:41,100
基于时间戳的排序，这些元组

1723
01:10:41,100 --> 01:10:43,610
可能都在同一页面，也可能不在同一页面，

1724
01:10:43,610 --> 01:10:47,400
所以我不认为这实际上是我不

1725
01:10:47,400 --> 01:10:48,510
知道查询是否真的使这种

1726
01:10:48,510 --> 01:10:49,770
影响值得，另一个负责人

1727
01:10:49,770 --> 01:10:51,840
正在这样做 太高了 是的

1728
01:10:51,840 --> 01:10:52,910
，虽然没有，但有一个很好的思想

1729
01:10:52,910 --> 01:10:56,730
实验 其他关于数据库的任何其他随机查询

1730
01:10:56,730 --> 01:11:00,450
很酷很棒的家伙

1731
01:11:00,450 --> 01:11:04,760
好吧我的新课程将是一个

1732
01:11:04,760 --> 01:11:07,860
编译然后尽快开始

1733
01:11:07,860 --> 01:11:10,230
在ii项目上

1734
01:11:10,230 --> 01:11:13,290
然后我们将宣布

1735
01:11:13,290 --> 01:11:14,670
您应该测试什么机器

1736
01:11:14,670 --> 01:11:16,080
并发性很好，

1737
01:11:16,080 --> 01:11:18,000
所以他在课堂上提早提出的问题

1738
01:11:18,000 --> 01:11:20,910
是第一个检查点，我们不会

1739
01:11:20,910 --> 01:11:23,400
检查并发性，我们只

1740
01:11:23,400 --> 01:11:26,250
检查正确性，所以如果你愿意，你

1741
01:11:26,250 --> 01:11:27,810
可以在事情的顶部放一个巨大的闩锁

1742
01:11:27,810 --> 01:11:28,309


1743
01:11:28,309 --> 01:11:31,979
，这个 证明你可以

1744
01:11:31,979 --> 01:11:34,489
正确地进行插入和查找，

1745
01:11:34,489 --> 01:11:36,780
因为在灰色勺子中只给了我们

1746
01:11:36,780 --> 01:11:37,979
一个线程所以我们真的不能锤

1747
01:11:37,979 --> 01:11:45,349
它太多好吧这是什么

1748
01:11:45,510 --> 01:12:12,699
[音乐]

