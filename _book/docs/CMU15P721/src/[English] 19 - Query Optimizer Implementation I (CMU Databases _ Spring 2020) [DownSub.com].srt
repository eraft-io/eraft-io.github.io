1
00:00:01,300 --> 00:00:05,129
[Music]

2
00:00:05,200 --> 00:00:05,930
[Applause]

3
00:00:05,930 --> 00:00:08,630
[Music]

4
00:00:08,630 --> 00:00:10,020
[Applause]

5
00:00:10,020 --> 00:00:11,240
[Music]

6
00:00:11,240 --> 00:00:13,500
today we'll be talking about query

7
00:00:13,500 --> 00:00:15,929
optimization this is a really important

8
00:00:15,929 --> 00:00:17,970
topic in database systems so again I'm

9
00:00:17,970 --> 00:00:20,490
here in my house I have the terior over

10
00:00:20,490 --> 00:00:22,350
there whose be asking questions as we go

11
00:00:22,350 --> 00:00:27,119
along so when we say a query

12
00:00:27,119 --> 00:00:30,060
optimization the idea at a high level is

13
00:00:30,060 --> 00:00:33,750
that we want to take a query that's

14
00:00:33,750 --> 00:00:35,370
written in a declarative language like

15
00:00:35,370 --> 00:00:38,969
sequel and we want to then translate

16
00:00:38,969 --> 00:00:42,120
that into a execution plan that the

17
00:00:42,120 --> 00:00:45,420
database system can execute and so with

18
00:00:45,420 --> 00:00:47,309
query optimization the idea is that we

19
00:00:47,309 --> 00:00:50,879
want to find a correct execution plan

20
00:00:50,879 --> 00:00:53,399
that will have potentially the lowest

21
00:00:53,399 --> 00:00:55,949
cost so the two words that I'm

22
00:00:55,949 --> 00:00:58,859
emphasizing here are correct and cost

23
00:00:58,859 --> 00:01:01,079
correct is kind of obvious it doesn't

24
00:01:01,079 --> 00:01:03,600
help us if we find a really fast plan

25
00:01:03,600 --> 00:01:06,540
that ends up computing the wrong answer

26
00:01:06,540 --> 00:01:08,040
returning the wrong result for our query

27
00:01:08,040 --> 00:01:10,500
like that doesn't help us at all

28
00:01:10,500 --> 00:01:13,130
and the term cost is in quotes because

29
00:01:13,130 --> 00:01:17,369
the cost is going to be this relative

30
00:01:17,369 --> 00:01:20,460
metric that's not necessarily tied to a

31
00:01:20,460 --> 00:01:22,290
real-world metric it's just something

32
00:01:22,290 --> 00:01:23,930
that's that the data system would say

33
00:01:23,930 --> 00:01:26,330
this is the best query for me to execute

34
00:01:26,330 --> 00:01:30,320
so the cost could be in terms of

35
00:01:30,320 --> 00:01:33,750
execution time in terms of monetary cost

36
00:01:33,750 --> 00:01:36,540
after running this on a page you go

37
00:01:36,540 --> 00:01:38,790
cloud system it could be in memory usage

38
00:01:38,790 --> 00:01:40,799
that could be could be any possible

39
00:01:40,799 --> 00:01:43,259
thing but at a high level it's you know

40
00:01:43,259 --> 00:01:45,180
some objective function that the the

41
00:01:45,180 --> 00:01:46,890
database system knows that it wants to

42
00:01:46,890 --> 00:01:50,490
optimize for so the query optimizer is

43
00:01:50,490 --> 00:01:52,229
going to be the hardest part we're gonna

44
00:01:52,229 --> 00:01:54,299
have to touch or a component we're gonna

45
00:01:54,299 --> 00:01:56,100
have to implement in the database system

46
00:01:56,100 --> 00:02:00,390
because finding a you know optimal near

47
00:02:00,390 --> 00:02:03,750
optimal query is going to be super

48
00:02:03,750 --> 00:02:05,070
challenging it's gonna day it's proven

49
00:02:05,070 --> 00:02:08,699
to be a np-complete problem so this

50
00:02:08,699 --> 00:02:10,348
means that although the name of the

51
00:02:10,348 --> 00:02:12,750
component we're going to build is is you

52
00:02:12,750 --> 00:02:15,450
called the query optimizer were almost

53
00:02:15,450 --> 00:02:17,340
never gonna be able to find the optimum

54
00:02:17,340 --> 00:02:19,980
plan because it would just take too long

55
00:02:19,980 --> 00:02:23,430
to look at all possible solutions for

56
00:02:23,430 --> 00:02:25,110
all possible query plans and pick the

57
00:02:25,110 --> 00:02:29,010
best one so what these upcoming lectures

58
00:02:29,010 --> 00:02:31,080
are really about are the techniques that

59
00:02:31,080 --> 00:02:35,310
we'll use to simplify the and reduce the

60
00:02:35,310 --> 00:02:36,870
search space so that it's not an

61
00:02:36,870 --> 00:02:39,420
exhaustive search and techniques we can

62
00:02:39,420 --> 00:02:42,930
use to estimate what the plan cost will

63
00:02:42,930 --> 00:02:44,430
be without actually having to really

64
00:02:44,430 --> 00:02:46,680
execute it so let's make more sense as

65
00:02:46,680 --> 00:02:47,880
we go further along and we talk about

66
00:02:47,880 --> 00:02:51,120
cost models but the way to think about

67
00:02:51,120 --> 00:02:54,060
this is if we need to ask me what is the

68
00:02:54,060 --> 00:02:56,430
cost of one of executing one query plan

69
00:02:56,430 --> 00:02:58,200
to get that true cost we could just

70
00:02:58,200 --> 00:03:00,239
execute the query but now if you want to

71
00:03:00,239 --> 00:03:01,560
look at thousands and thousands of

72
00:03:01,560 --> 00:03:03,270
possible different query plans that's

73
00:03:03,270 --> 00:03:05,489
not feasible for us to do so we need a

74
00:03:05,489 --> 00:03:08,250
way to estimate it and this cost thing

75
00:03:08,250 --> 00:03:11,010
is also going to be a internal metric

76
00:03:11,010 --> 00:03:13,440
that the data system uses to determine

77
00:03:13,440 --> 00:03:15,239
whether one plan is better or not better

78
00:03:15,239 --> 00:03:17,880
better than another and it may not

79
00:03:17,880 --> 00:03:21,360
necessarily be tied to you know the wall

80
00:03:21,360 --> 00:03:25,140
clock time our real cost so this is just

81
00:03:25,140 --> 00:03:26,519
sort of just set us up but what we mean

82
00:03:26,519 --> 00:03:27,630
when we when we start to mount query

83
00:03:27,630 --> 00:03:30,959
optimization the for the next three

84
00:03:30,959 --> 00:03:33,120
weeks would have discussing a lot of

85
00:03:33,120 --> 00:03:37,049
different things in this in this four

86
00:03:37,049 --> 00:03:38,940
query optimization so that I said as I

87
00:03:38,940 --> 00:03:41,130
said the end of last class I will fully

88
00:03:41,130 --> 00:03:44,310
admit that query optimization is the the

89
00:03:44,310 --> 00:03:46,530
one aspect of database systems that I

90
00:03:46,530 --> 00:03:48,090
know the least about and I'm always

91
00:03:48,090 --> 00:03:51,360
trying to learn more and so this year

92
00:03:51,360 --> 00:03:53,430
we've expanded the discussion to include

93
00:03:53,430 --> 00:03:57,390
an extra lecture on sort of extra query

94
00:03:57,390 --> 00:03:59,579
optimization methods beyond the

95
00:03:59,579 --> 00:04:01,860
traditional two method two approaches

96
00:04:01,860 --> 00:04:02,970
that we'll talk about in this lecture in

97
00:04:02,970 --> 00:04:05,100
the next lecture so where we're going

98
00:04:05,100 --> 00:04:06,750
for the next three weeks over the next

99
00:04:06,750 --> 00:04:09,329
four lectures is that we'll spend time

100
00:04:09,329 --> 00:04:10,980
the beginning talking about how to

101
00:04:10,980 --> 00:04:13,560
implement a query optimizer essentially

102
00:04:13,560 --> 00:04:15,030
what does the search strategy could look

103
00:04:15,030 --> 00:04:16,168
like this so that sort of the search

104
00:04:16,168 --> 00:04:18,329
engine inside of it look like then we'll

105
00:04:18,329 --> 00:04:20,010
talk about how to do plan rewriting

106
00:04:20,010 --> 00:04:22,260
query rewriting plan enumeration and

107
00:04:22,260 --> 00:04:25,100
then we'll talk about sort of

108
00:04:25,100 --> 00:04:28,100
more sort of sophisticated techniques to

109
00:04:28,100 --> 00:04:31,220
do at adaptive query optimization and

110
00:04:31,220 --> 00:04:33,410
we'll finish up with talking about cost

111
00:04:33,410 --> 00:04:36,890
models so I'll briefly touch on what all

112
00:04:36,890 --> 00:04:38,210
cost model is I think a little bit in

113
00:04:38,210 --> 00:04:39,770
this lecture but that'll be sort of the

114
00:04:39,770 --> 00:04:41,750
end thing to say well after we design

115
00:04:41,750 --> 00:04:44,060
all this the search stuff that we're

116
00:04:44,060 --> 00:04:46,310
talking about here the cost model is

117
00:04:46,310 --> 00:04:51,970
already used to guide that search so the

118
00:04:51,970 --> 00:04:54,440
for today we're mostly talking about

119
00:04:54,440 --> 00:04:56,540
optimization search strategies because

120
00:04:56,540 --> 00:04:58,850
that's sort of them one of the two main

121
00:04:58,850 --> 00:05:04,790
parts you need to have and then that'll

122
00:05:04,790 --> 00:05:07,160
then segue into these these other these

123
00:05:07,160 --> 00:05:10,100
other topics so for today again as I

124
00:05:10,100 --> 00:05:11,450
said well start talking about search

125
00:05:11,450 --> 00:05:12,800
strategies because that's the most

126
00:05:12,800 --> 00:05:14,600
important thing and that's sort of the

127
00:05:14,600 --> 00:05:15,530
basis of what you need to actually

128
00:05:15,530 --> 00:05:18,440
implement a query optimizer and then

129
00:05:18,440 --> 00:05:20,420
we'll go through the different

130
00:05:20,420 --> 00:05:22,310
approaches people have tried to building

131
00:05:22,310 --> 00:05:25,640
a query optimizer over the last 50 40 50

132
00:05:25,640 --> 00:05:29,990
years and then that'll motivate why we

133
00:05:29,990 --> 00:05:32,180
want to use a more sophisticated dynamic

134
00:05:32,180 --> 00:05:34,250
programming technique or the Cascades

135
00:05:34,250 --> 00:05:36,070
technique that you guys are read about

136
00:05:36,070 --> 00:05:38,900
for next class so today is sort of like

137
00:05:38,900 --> 00:05:40,490
a bunch of background information that

138
00:05:40,490 --> 00:05:44,150
then leads up up into the the modern

139
00:05:44,150 --> 00:05:48,640
implementations so at a high level the

140
00:05:48,640 --> 00:05:53,000
the the the the stack of the system that

141
00:05:53,000 --> 00:05:54,800
we're talking about and what I've sort

142
00:05:54,800 --> 00:05:56,270
of referred to the front of the system

143
00:05:56,270 --> 00:05:58,550
is gonna look like this and this is the

144
00:05:58,550 --> 00:05:59,840
part that we're talking about now in our

145
00:05:59,840 --> 00:06:02,300
system so we start with a sequel query

146
00:06:02,300 --> 00:06:04,640
that the application sends us we can

147
00:06:04,640 --> 00:06:07,000
first pass that into a sequel rewriter

148
00:06:07,000 --> 00:06:09,650
which means that will transform the

149
00:06:09,650 --> 00:06:12,440
sequel string itself to annotate it or

150
00:06:12,440 --> 00:06:15,590
modify it in a certain way and this is

151
00:06:15,590 --> 00:06:17,360
this is optional not all systems have

152
00:06:17,360 --> 00:06:19,370
this you see this sometimes in

153
00:06:19,370 --> 00:06:21,160
middleware systems that are doing

154
00:06:21,160 --> 00:06:23,060
sharding and sometimes can rewrite the

155
00:06:23,060 --> 00:06:26,270
sequel query to to add in you know go to

156
00:06:26,270 --> 00:06:27,890
this table or I'm sorry go to this this

157
00:06:27,890 --> 00:06:30,650
node versus that node but this is sort

158
00:06:30,650 --> 00:06:32,390
of this is like sequel query in sequel

159
00:06:32,390 --> 00:06:33,680
query out there just modifying the

160
00:06:33,680 --> 00:06:35,870
sequel query then we take the sequel

161
00:06:35,870 --> 00:06:37,490
query run it through our sequel parser

162
00:06:37,490 --> 00:06:39,390
and then that will spit

163
00:06:39,390 --> 00:06:42,240
out a abstract syntax tree that just has

164
00:06:42,240 --> 00:06:44,550
the tokens the string tokens of the

165
00:06:44,550 --> 00:06:46,530
query I wouldn't have the token of the

166
00:06:46,530 --> 00:06:47,970
table name of the column names and so

167
00:06:47,970 --> 00:06:51,150
forth and then now we pass us into the

168
00:06:51,150 --> 00:06:54,420
binder which does lookups in the system

169
00:06:54,420 --> 00:06:56,220
catalog of the database system to map

170
00:06:56,220 --> 00:07:00,570
the table names in in the the reference

171
00:07:00,570 --> 00:07:01,650
in the query of the column names that

172
00:07:01,650 --> 00:07:03,540
represent the query into eternal

173
00:07:03,540 --> 00:07:06,000
internal identifier so this is allows

174
00:07:06,000 --> 00:07:08,760
you to get like the the the the type of

175
00:07:08,760 --> 00:07:10,680
the columns whatever constraint you have

176
00:07:10,680 --> 00:07:13,140
in those columns and so forth so then

177
00:07:13,140 --> 00:07:14,730
the binder would then spit out what is

178
00:07:14,730 --> 00:07:17,940
now called a logical plan so this is a

179
00:07:17,940 --> 00:07:21,150
high-level description of what the query

180
00:07:21,150 --> 00:07:23,700
wants to do right sorry I have a select

181
00:07:23,700 --> 00:07:26,370
query that wants to access table foo my

182
00:07:26,370 --> 00:07:29,910
logical plan will be to say scan table

183
00:07:29,910 --> 00:07:32,340
foo doesn't say how I want to scan it it

184
00:07:32,340 --> 00:07:35,430
just says I want to access it then we

185
00:07:35,430 --> 00:07:37,470
can take that logical plan and pass it

186
00:07:37,470 --> 00:07:40,110
into a another optional step called the

187
00:07:40,110 --> 00:07:42,510
tree rewriter and this is again logical

188
00:07:42,510 --> 00:07:45,240
plan in logical plan out these are think

189
00:07:45,240 --> 00:07:46,890
of these as like heuristics we can apply

190
00:07:46,890 --> 00:07:50,840
to manipulate the structure of the tree

191
00:07:50,840 --> 00:07:53,190
for some optimizations that we know we

192
00:07:53,190 --> 00:07:56,700
always want to do if we don't need to

193
00:07:56,700 --> 00:07:58,620
estimate the cost of the change we want

194
00:07:58,620 --> 00:08:00,690
to make so like we can like a predicate

195
00:08:00,690 --> 00:08:02,910
push down here or sometimes you see

196
00:08:02,910 --> 00:08:06,480
rewriting view queries or CT ease into

197
00:08:06,480 --> 00:08:09,720
nested queries this way again this is

198
00:08:09,720 --> 00:08:12,420
entirely optional then we now feed this

199
00:08:12,420 --> 00:08:14,250
into our optimizer

200
00:08:14,250 --> 00:08:16,710
and at a high level we'll be calling you

201
00:08:16,710 --> 00:08:18,570
know we'll be focusing on a cost based

202
00:08:18,570 --> 00:08:20,970
query optimizer right where we have some

203
00:08:20,970 --> 00:08:23,480
cost estimates that are based on

204
00:08:23,480 --> 00:08:26,010
statistics that we've collected from the

205
00:08:26,010 --> 00:08:28,380
database itself that allow us to predict

206
00:08:28,380 --> 00:08:29,820
or estimate you know what's the

207
00:08:29,820 --> 00:08:31,410
execution time of a particular query

208
00:08:31,410 --> 00:08:33,179
plan and then again this is where we can

209
00:08:33,179 --> 00:08:35,250
enumerate a bunch of options and choose

210
00:08:35,250 --> 00:08:36,900
the one plan that that we think is gonna

211
00:08:36,900 --> 00:08:40,380
have the lowest cost and so once the

212
00:08:40,380 --> 00:08:42,390
optimizer is done with this step then it

213
00:08:42,390 --> 00:08:44,039
fits out a fit spits out a physical plan

214
00:08:44,039 --> 00:08:46,560
that would go off and execute it now in

215
00:08:46,560 --> 00:08:49,110
the case of our system and then we talk

216
00:08:49,110 --> 00:08:50,790
about query compilation we take that

217
00:08:50,790 --> 00:08:51,980
physical plan

218
00:08:51,980 --> 00:08:53,839
and then we use we have cogeneration to

219
00:08:53,839 --> 00:08:56,240
convert it into a domain-specific

220
00:08:56,240 --> 00:08:57,800
language that we then compiled into

221
00:08:57,800 --> 00:08:59,810
machine code but other systems you can

222
00:08:59,810 --> 00:09:00,920
take this physical plan and start

223
00:09:00,920 --> 00:09:02,720
interpreting it annex to name right away

224
00:09:02,720 --> 00:09:06,260
I said this is this is at a high level

225
00:09:06,260 --> 00:09:09,079
whoever going for today and the upcoming

226
00:09:09,079 --> 00:09:10,790
lectures so we're mostly gonna be

227
00:09:10,790 --> 00:09:12,620
focusing on these two parts here the

228
00:09:12,620 --> 00:09:14,240
tree tree writer and the optimizer for

229
00:09:14,240 --> 00:09:17,269
sequel rewriting as I said that's mostly

230
00:09:17,269 --> 00:09:20,089
done not really doing that for

231
00:09:20,089 --> 00:09:23,480
optimization as you're doing it for like

232
00:09:23,480 --> 00:09:28,220
redirecting queries or yeah it's most of

233
00:09:28,220 --> 00:09:29,660
them is like control playing stuff not

234
00:09:29,660 --> 00:09:32,720
necessarily for execution stuff the

235
00:09:32,720 --> 00:09:35,269
binder there's not really any magic you

236
00:09:35,269 --> 00:09:37,579
do there it's looking up rickie form you

237
00:09:37,579 --> 00:09:38,810
know looking up cable names and things

238
00:09:38,810 --> 00:09:41,449
like that all right so let's now discuss

239
00:09:41,449 --> 00:09:43,399
this distinction between the logical and

240
00:09:43,399 --> 00:09:44,420
physical plan because this is going to

241
00:09:44,420 --> 00:09:46,310
come up multiple times when we talk

242
00:09:46,310 --> 00:09:50,420
about query optimizer so the essentially

243
00:09:50,420 --> 00:09:51,740
what the optimizer is trying to do is

244
00:09:51,740 --> 00:09:54,350
trying to map a logical algebra

245
00:09:54,350 --> 00:09:58,160
expression of the query itself into a

246
00:09:58,160 --> 00:10:01,540
equivalent physical algebra expression

247
00:10:01,540 --> 00:10:04,579
so as I said like the logical plan would

248
00:10:04,579 --> 00:10:07,370
say I want to access table food the

249
00:10:07,370 --> 00:10:09,800
physical plan would say access table

250
00:10:09,800 --> 00:10:13,100
through using index you know XYZ for

251
00:10:13,100 --> 00:10:16,190
access table food using a square scan or

252
00:10:16,190 --> 00:10:18,199
binary search on the actual table itself

253
00:10:18,199 --> 00:10:20,600
I said is it that high little bit the

254
00:10:20,600 --> 00:10:22,279
distinction is that the physical plan

255
00:10:22,279 --> 00:10:23,839
tells you how you actually want to

256
00:10:23,839 --> 00:10:27,769
execute a you know the query itself but

257
00:10:27,769 --> 00:10:29,779
the logical plan says that this is what

258
00:10:29,779 --> 00:10:33,940
I want the query result of beam so the

259
00:10:33,940 --> 00:10:36,850
the physical plant operators themselves

260
00:10:36,850 --> 00:10:39,440
it's gonna have low level information

261
00:10:39,440 --> 00:10:42,230
that is specific to the physical

262
00:10:42,230 --> 00:10:44,060
properties and the physical format of

263
00:10:44,060 --> 00:10:46,190
the data that they're accessing so in

264
00:10:46,190 --> 00:10:48,470
some cases the physical operators will

265
00:10:48,470 --> 00:10:51,860
know that it's producing a data that's

266
00:10:51,860 --> 00:10:54,260
sorted on a given column or no that's

267
00:10:54,260 --> 00:10:55,730
gonna be operating on data that's

268
00:10:55,730 --> 00:10:57,170
compressed in a certain way it maybe

269
00:10:57,170 --> 00:10:58,959
needs to decompress it into another way

270
00:10:58,959 --> 00:11:01,459
the logical plan has no notion of this

271
00:11:01,459 --> 00:11:03,380
it just knows about relations

272
00:11:03,380 --> 00:11:05,640
so one important thing we'll see and

273
00:11:05,640 --> 00:11:06,510
this will come up when we talk about

274
00:11:06,510 --> 00:11:08,900
Cascades the next class is that the

275
00:11:08,900 --> 00:11:11,040
there's not always going to be a

276
00:11:11,040 --> 00:11:13,980
one-to-one mapping from logical

277
00:11:13,980 --> 00:11:16,170
operators to physical operators so I

278
00:11:16,170 --> 00:11:17,460
mean that is like in the case of like

279
00:11:17,460 --> 00:11:19,440
access table foo I can imagine

280
00:11:19,440 --> 00:11:21,900
easily how that would be mapping the

281
00:11:21,900 --> 00:11:23,610
logical operator to access table food to

282
00:11:23,610 --> 00:11:25,530
a you know a sequential scan to access

283
00:11:25,530 --> 00:11:27,660
table foo that would be one-to-one but

284
00:11:27,660 --> 00:11:29,610
sometimes we'll have logical operators

285
00:11:29,610 --> 00:11:32,940
that can then expand into multiple

286
00:11:32,940 --> 00:11:35,790
physical operators and likewise you can

287
00:11:35,790 --> 00:11:38,640
take a multi logical operators and and

288
00:11:38,640 --> 00:11:40,410
coalesce them into a single physical

289
00:11:40,410 --> 00:11:41,880
operator it depends on the

290
00:11:41,880 --> 00:11:43,230
implementation of the database system

291
00:11:43,230 --> 00:11:45,060
usually you see the logical operators

292
00:11:45,060 --> 00:11:46,680
being exploded into more operators

293
00:11:46,680 --> 00:11:48,300
that's more common than the other way in

294
00:11:48,300 --> 00:11:52,920
my opinion like I actually take that

295
00:11:52,920 --> 00:11:56,460
back right so a logical join with a

296
00:11:56,460 --> 00:11:59,270
logical order by could be merged into a

297
00:11:59,270 --> 00:12:01,020
physical sort merge-join

298
00:12:01,020 --> 00:12:03,270
because you're doing this you know doing

299
00:12:03,270 --> 00:12:09,090
the join and the order by together all

300
00:12:09,090 --> 00:12:11,490
right so a another portent aspect about

301
00:12:11,490 --> 00:12:14,760
what we're doing here relies on this

302
00:12:14,760 --> 00:12:16,100
notion of relational algebra

303
00:12:16,100 --> 00:12:18,300
equivalencies again this is something

304
00:12:18,300 --> 00:12:19,260
that we've covered it in the

305
00:12:19,260 --> 00:12:21,390
introduction class last semester but the

306
00:12:21,390 --> 00:12:24,410
basic idea is that since we know the

307
00:12:24,410 --> 00:12:26,700
commutativity and associativity a chance

308
00:12:26,700 --> 00:12:29,220
transitivity properties of relational

309
00:12:29,220 --> 00:12:32,130
algebra expressions we know we can

310
00:12:32,130 --> 00:12:33,480
define rules that allows to do

311
00:12:33,480 --> 00:12:36,300
transformations of the query plan in

312
00:12:36,300 --> 00:12:38,100
such a way that we know that the end

313
00:12:38,100 --> 00:12:40,200
result is equivalent to the original

314
00:12:40,200 --> 00:12:42,810
plan so in this case here if I'm doing

315
00:12:42,810 --> 00:12:45,510
natural joins between tables a B and C

316
00:12:45,510 --> 00:12:49,470
and if I join B and C first then take

317
00:12:49,470 --> 00:12:51,120
the result of that joint and now join it

318
00:12:51,120 --> 00:12:53,640
with a well that's equivalent to me

319
00:12:53,640 --> 00:12:56,070
joining a and C first and then taking

320
00:12:56,070 --> 00:12:58,770
the output of that and joining B and I

321
00:12:58,770 --> 00:13:00,090
can do this because this is an inner

322
00:13:00,090 --> 00:13:02,880
join or a natural join where I have the

323
00:13:02,880 --> 00:13:04,260
commutativity property I can reorder

324
00:13:04,260 --> 00:13:06,540
them any way I want left out or joined

325
00:13:06,540 --> 00:13:07,920
you can't quit you can't do that because

326
00:13:07,920 --> 00:13:10,110
they're asymmetric whereas these things

327
00:13:10,110 --> 00:13:11,340
they're symmetrical so I can flip these

328
00:13:11,340 --> 00:13:13,680
around in any order I want so now you

329
00:13:13,680 --> 00:13:14,850
can kind of see what the optimizer is

330
00:13:14,850 --> 00:13:15,780
actually going to try to

331
00:13:15,780 --> 00:13:19,230
is if it knows it needs to join table a

332
00:13:19,230 --> 00:13:21,780
B and C together it's gonna try to

333
00:13:21,780 --> 00:13:23,490
figure out what is the correct correct

334
00:13:23,490 --> 00:13:26,010
ordering I should do for you know

335
00:13:26,010 --> 00:13:28,080
joining B and C first or joining a and C

336
00:13:28,080 --> 00:13:29,010
first and so forth

337
00:13:29,010 --> 00:13:30,660
hey can use a cost model to estimate

338
00:13:30,660 --> 00:13:33,000
which of these join orderings is going

339
00:13:33,000 --> 00:13:36,870
to be most efficient then now you can

340
00:13:36,870 --> 00:13:38,490
think about the physical operators as

341
00:13:38,490 --> 00:13:40,860
well I can now decide what what

342
00:13:40,860 --> 00:13:42,420
algorithm do i when you use to actually

343
00:13:42,420 --> 00:13:43,650
do this joint go I'm gonna do the sort

344
00:13:43,650 --> 00:13:45,390
merge stuff we talked about before do I

345
00:13:45,390 --> 00:13:47,580
want to do my parallel hash join so

346
00:13:47,580 --> 00:13:52,770
forth so for these lectures are most of

347
00:13:52,770 --> 00:13:54,540
you focusing on analytical queries

348
00:13:54,540 --> 00:14:00,780
because in this world the the the

349
00:14:00,780 --> 00:14:02,760
difficulty or challenge in finding an

350
00:14:02,760 --> 00:14:05,850
apple query plan is much much much

351
00:14:05,850 --> 00:14:07,980
greater than doing in this for all to be

352
00:14:07,980 --> 00:14:09,300
workloads or transaction processing

353
00:14:09,300 --> 00:14:12,060
workloads and this is because most the

354
00:14:12,060 --> 00:14:14,940
time the the queries and ultimate

355
00:14:14,940 --> 00:14:16,500
workloads are considered to be what is

356
00:14:16,500 --> 00:14:19,050
called sorrel and Sarge will just shorts

357
00:14:19,050 --> 00:14:22,230
is a acronym for the search argument

358
00:14:22,230 --> 00:14:25,070
able some term they made up in the 80s I

359
00:14:25,070 --> 00:14:28,740
don't know why whatever and for these

360
00:14:28,740 --> 00:14:30,660
Sargent queries the reason why it

361
00:14:30,660 --> 00:14:32,370
they're going to be easy for us to be

362
00:14:32,370 --> 00:14:35,190
query planning on is because in old

363
00:14:35,190 --> 00:14:36,420
people workloads you're almost always

364
00:14:36,420 --> 00:14:39,660
doing lookups on on you know a small

365
00:14:39,660 --> 00:14:41,700
number of tables at a time and you

366
00:14:41,700 --> 00:14:45,120
usually have index defined on the

367
00:14:45,120 --> 00:14:46,410
attributes you're trying to do lookup

368
00:14:46,410 --> 00:14:49,950
lookups on in these tables so the many

369
00:14:49,950 --> 00:14:52,020
times the the challenge is just trying

370
00:14:52,020 --> 00:14:53,880
to pick what is the best index for me to

371
00:14:53,880 --> 00:14:57,900
use for this particular query alright so

372
00:14:57,900 --> 00:14:59,850
say I have a simple table foo has two

373
00:14:59,850 --> 00:15:03,660
columns and a name an entry ID and name

374
00:15:03,660 --> 00:15:05,880
ID is the primary key so if I have a

375
00:15:05,880 --> 00:15:07,830
query that comes along that doesn't you

376
00:15:07,830 --> 00:15:10,050
know there's an equality predicate where

377
00:15:10,050 --> 00:15:12,930
ID equals one two three there's not

378
00:15:12,930 --> 00:15:14,760
really any complex search I need to do

379
00:15:14,760 --> 00:15:16,290
to figure out what the best access

380
00:15:16,290 --> 00:15:18,180
method is to access table foo here I

381
00:15:18,180 --> 00:15:20,310
just look at my catalog and say well I

382
00:15:20,310 --> 00:15:22,020
know I'm doing an equality predicate on

383
00:15:22,020 --> 00:15:25,320
an ID field I have a primary key on the

384
00:15:25,320 --> 00:15:27,000
ID so therefore it has to have an index

385
00:15:27,000 --> 00:15:28,920
so I know in this case here

386
00:15:28,920 --> 00:15:30,720
I just use that index to do the to do

387
00:15:30,720 --> 00:15:32,790
the lookup and I don't need it you know

388
00:15:32,790 --> 00:15:34,410
even consider what we all possible

389
00:15:34,410 --> 00:15:36,920
indexes I want to choose

390
00:15:36,920 --> 00:15:40,170
likewise for for for joins they're

391
00:15:40,170 --> 00:15:42,240
almost always going to be an OTP setting

392
00:15:42,240 --> 00:15:46,170
on a foreign key some applications are

393
00:15:46,170 --> 00:15:48,750
not well designed so you they they may

394
00:15:48,750 --> 00:15:53,160
have not defined a foreign key sometimes

395
00:15:53,160 --> 00:15:54,180
you see sort of the applications written

396
00:15:54,180 --> 00:15:55,350
by people may not know what they're

397
00:15:55,350 --> 00:15:57,510
doing databases so clearly it should be

398
00:15:57,510 --> 00:15:59,310
a foreign key but they just didn't

399
00:15:59,310 --> 00:16:02,880
confine it that way in the scheme um but

400
00:16:02,880 --> 00:16:05,310
even then you still figure it out put it

401
00:16:05,310 --> 00:16:07,019
fairly easily but in this case here like

402
00:16:07,019 --> 00:16:08,790
if you have a foreign key relationship

403
00:16:08,790 --> 00:16:10,290
and you know I have a small cardinality

404
00:16:10,290 --> 00:16:13,709
yeah it's gonna be an index to enforce

405
00:16:13,709 --> 00:16:15,810
that that that referential integrity in

406
00:16:15,810 --> 00:16:17,850
the parent table so again when you

407
00:16:17,850 --> 00:16:19,920
wanted your join it's it's pretty easy

408
00:16:19,920 --> 00:16:22,019
to pick out like the the parent table

409
00:16:22,019 --> 00:16:24,329
should be out at our table and then the

410
00:16:24,329 --> 00:16:26,639
inner table is the foreign key child and

411
00:16:26,639 --> 00:16:28,380
I'm doing the nested loop index probe

412
00:16:28,380 --> 00:16:30,839
alright and this loop index join to join

413
00:16:30,839 --> 00:16:33,149
these two tables together so again in

414
00:16:33,149 --> 00:16:36,089
this environment for ot queries it's

415
00:16:36,089 --> 00:16:37,829
usually pretty simple to do query

416
00:16:37,829 --> 00:16:40,980
planning and you can get by doing simple

417
00:16:40,980 --> 00:16:42,630
the simple heuristics based optimizer

418
00:16:42,630 --> 00:16:45,000
which we'll talk about in a second

419
00:16:45,000 --> 00:16:47,160
MongoDB is probably the most famous

420
00:16:47,160 --> 00:16:50,490
database system out around today that

421
00:16:50,490 --> 00:16:52,980
still uses the sort of basic heuristic

422
00:16:52,980 --> 00:16:54,839
to do things like this because in the

423
00:16:54,839 --> 00:16:56,279
type of workload that they originally

424
00:16:56,279 --> 00:16:58,260
were targeting they weren't doing

425
00:16:58,260 --> 00:16:59,370
complex joins because they didn't really

426
00:16:59,370 --> 00:17:02,370
had joins until only a few years ago so

427
00:17:02,370 --> 00:17:04,709
in this world they could get by with

428
00:17:04,709 --> 00:17:09,000
simple heuristics all right so I also

429
00:17:09,000 --> 00:17:11,760
talked briefly about cost estimation the

430
00:17:11,760 --> 00:17:14,959
beginning again the idea here is that we

431
00:17:14,959 --> 00:17:18,959
have we have a query comes in we have a

432
00:17:18,959 --> 00:17:21,240
logical plan and we want to figure out

433
00:17:21,240 --> 00:17:23,900
what's the best physical plan to execute

434
00:17:23,900 --> 00:17:26,660
to represent for that that logical plan

435
00:17:26,660 --> 00:17:29,669
and so we have to use a Cost Estimator

436
00:17:29,669 --> 00:17:33,210
to predict what that you know what won't

437
00:17:33,210 --> 00:17:34,860
be the execution cost of executing that

438
00:17:34,860 --> 00:17:36,059
that physical plan or one of the

439
00:17:36,059 --> 00:17:37,799
physical plans and then we can use that

440
00:17:37,799 --> 00:17:40,400
to determine which physical plan is

441
00:17:40,400 --> 00:17:41,490
preferable

442
00:17:41,490 --> 00:17:45,090
to the other one so there's a bunch of

443
00:17:45,090 --> 00:17:47,640
things we could use to figure out what

444
00:17:47,640 --> 00:17:52,110
should be our or cost we can look at to

445
00:17:52,110 --> 00:17:54,240
see how the queries gonna interact with

446
00:17:54,240 --> 00:17:55,740
other queries running at the same time

447
00:17:55,740 --> 00:17:57,990
that's actually pretty tricky and few

448
00:17:57,990 --> 00:18:00,179
systems actually do this real common

449
00:18:00,179 --> 00:18:01,890
thing is to say well what's the enemy

450
00:18:01,890 --> 00:18:04,140
its size what's the output size of all

451
00:18:04,140 --> 00:18:06,450
my operators and certainly use that as a

452
00:18:06,450 --> 00:18:09,960
proxy for what resources I'll use it

453
00:18:09,960 --> 00:18:11,730
could be just like the asymptotic

454
00:18:11,730 --> 00:18:14,880
analysis of the algorithms we're using

455
00:18:14,880 --> 00:18:16,710
for our physical operators but we know a

456
00:18:16,710 --> 00:18:19,050
hash join is gonna be more efficient or

457
00:18:19,050 --> 00:18:22,830
it you have incur less you know less iOS

458
00:18:22,830 --> 00:18:24,960
or less overhead then a nested loop join

459
00:18:24,960 --> 00:18:26,610
right so we can bake that into our

460
00:18:26,610 --> 00:18:29,309
contest modes how much CPU or memory I'm

461
00:18:29,309 --> 00:18:32,610
gonna use and then some information

462
00:18:32,610 --> 00:18:34,590
about what does the data actually look

463
00:18:34,590 --> 00:18:36,870
like like where is it physically located

464
00:18:36,870 --> 00:18:39,090
how is it compressed like all these

465
00:18:39,090 --> 00:18:40,530
things we can incorporate into our cost

466
00:18:40,530 --> 00:18:42,450
models to make estimates on what will be

467
00:18:42,450 --> 00:18:45,150
the the cost of executing a physical

468
00:18:45,150 --> 00:18:47,340
plan now this is super hard to do

469
00:18:47,340 --> 00:18:50,100
because you're estimating based on a

470
00:18:50,100 --> 00:18:52,230
summarization of what the data looks

471
00:18:52,230 --> 00:18:54,390
like because again I can't scan the

472
00:18:54,390 --> 00:18:55,890
table and say how many tuples you have

473
00:18:55,890 --> 00:18:56,790
it what's the distribution of these

474
00:18:56,790 --> 00:18:58,679
values because you might as well just

475
00:18:58,679 --> 00:19:00,480
execute the query and for really large

476
00:19:00,480 --> 00:19:03,210
databases that's not feasible so you're

477
00:19:03,210 --> 00:19:04,679
trying to estimate this as quickly as

478
00:19:04,679 --> 00:19:06,600
possible because you want to you want to

479
00:19:06,600 --> 00:19:09,600
evaluate as many physical plans as you

480
00:19:09,600 --> 00:19:11,880
can quickly as possible so that you

481
00:19:11,880 --> 00:19:14,280
maybe find the optimal one so there

482
00:19:14,280 --> 00:19:16,550
should be not next week but in two weeks

483
00:19:16,550 --> 00:19:18,690
well we'll discuss more about cost

484
00:19:18,690 --> 00:19:22,770
models and we'll see how wrong they

485
00:19:22,770 --> 00:19:24,660
actually actually get and this can make

486
00:19:24,660 --> 00:19:29,400
lead an optimizer make bad decisions all

487
00:19:29,400 --> 00:19:31,500
right so let's talk about now how to

488
00:19:31,500 --> 00:19:33,750
actually build an optimizer so the

489
00:19:33,750 --> 00:19:36,450
there's some first design situations we

490
00:19:36,450 --> 00:19:37,740
need to consider before we can actually

491
00:19:37,740 --> 00:19:40,290
say what is the search strategy that

492
00:19:40,290 --> 00:19:42,600
we're going to use to enumerate plans

493
00:19:42,600 --> 00:19:44,940
and look for a

494
00:19:44,940 --> 00:19:48,010
an optimal plan so we're gonna go to

495
00:19:48,010 --> 00:19:50,140
each of these topics one by one but an

496
00:19:50,140 --> 00:19:53,100
optimization granularity will be the you

497
00:19:53,100 --> 00:19:55,750
what are we what's the scope of what

498
00:19:55,750 --> 00:19:56,679
we're looking at when we do query

499
00:19:56,679 --> 00:19:58,840
planning when we five days off had a

500
00:19:58,840 --> 00:19:59,950
handle player prepare schemas plan

501
00:19:59,950 --> 00:20:01,570
stability and then when to finish the

502
00:20:01,570 --> 00:20:03,159
search so again we'll go to each of

503
00:20:03,159 --> 00:20:08,610
these so the optimization granularity is

504
00:20:08,610 --> 00:20:12,370
what is the scope of the search problem

505
00:20:12,370 --> 00:20:14,409
that the optimizer is gonna have to deal

506
00:20:14,409 --> 00:20:16,659
with and the choices are to either do it

507
00:20:16,659 --> 00:20:18,429
on a single query or do it with multiple

508
00:20:18,429 --> 00:20:21,370
queries so single query is the most

509
00:20:21,370 --> 00:20:24,370
common approach because oftentimes this

510
00:20:24,370 --> 00:20:26,289
is all that you really have like a

511
00:20:26,289 --> 00:20:28,870
client of misconnection sends a sequel

512
00:20:28,870 --> 00:20:30,669
query you're not gonna wait around to

513
00:20:30,669 --> 00:20:32,019
see what other queries show up from

514
00:20:32,019 --> 00:20:33,610
other connections you take that one

515
00:20:33,610 --> 00:20:34,750
query and you run it through the

516
00:20:34,750 --> 00:20:37,029
optimizer at that point in time right

517
00:20:37,029 --> 00:20:38,889
and the advantage of doing this is that

518
00:20:38,889 --> 00:20:40,419
you're gonna have obviously a much much

519
00:20:40,419 --> 00:20:42,220
potentially much smaller search space

520
00:20:42,220 --> 00:20:43,299
because you're only dealing that one

521
00:20:43,299 --> 00:20:47,139
query at a time you typically also don't

522
00:20:47,139 --> 00:20:49,510
reuse the search results across queries

523
00:20:49,510 --> 00:20:51,370
so you're essentially starting the

524
00:20:51,370 --> 00:20:52,870
search from scratch every single time

525
00:20:52,870 --> 00:20:55,600
now we can talk about some techniques in

526
00:20:55,600 --> 00:20:58,120
adaptive query optimization had a had a

527
00:20:58,120 --> 00:21:00,100
bridge information you've learned from

528
00:21:00,100 --> 00:21:03,039
one search to the next but typically

529
00:21:03,039 --> 00:21:05,409
most database systems don't do this the

530
00:21:05,409 --> 00:21:08,649
other aspect of it is like if you want

531
00:21:08,649 --> 00:21:10,860
to start figuring out like how much

532
00:21:10,860 --> 00:21:13,510
resources I'm gonna use when actually my

533
00:21:13,510 --> 00:21:15,909
query you may have to consider what

534
00:21:15,909 --> 00:21:17,080
other queries running at the same time

535
00:21:17,080 --> 00:21:19,510
so again like if you can do those

536
00:21:19,510 --> 00:21:20,620
multiple queries but if you're doing the

537
00:21:20,620 --> 00:21:22,929
single you do the single pretty much

538
00:21:22,929 --> 00:21:24,130
easily that you do with multiple queries

539
00:21:24,130 --> 00:21:26,190
because you don't have to worry about

540
00:21:26,190 --> 00:21:28,630
what those multiple queries how they're

541
00:21:28,630 --> 00:21:29,769
interfering with each other at the same

542
00:21:29,769 --> 00:21:32,950
time multiple queries as I said is more

543
00:21:32,950 --> 00:21:35,409
rare this would be like if I know I'm

544
00:21:35,409 --> 00:21:37,389
gonna execute a thousand queries in my

545
00:21:37,389 --> 00:21:39,370
application right now rather than me

546
00:21:39,370 --> 00:21:41,200
issuing them one at one after another

547
00:21:41,200 --> 00:21:43,389
like issue one executed get the result

548
00:21:43,389 --> 00:21:45,429
issued the next one I could in theory

549
00:21:45,429 --> 00:21:47,110
give the database system a batch of

550
00:21:47,110 --> 00:21:51,340
queries and have it figure out a single

551
00:21:51,340 --> 00:21:53,649
plan for the into all those queries that

552
00:21:53,649 --> 00:21:55,760
it just executes and

553
00:21:55,760 --> 00:21:58,940
knows how to route the requests route

554
00:21:58,940 --> 00:22:00,860
data between operators that are shared

555
00:22:00,860 --> 00:22:02,960
or not shared and produce the output for

556
00:22:02,960 --> 00:22:05,750
those individual queries that I said

557
00:22:05,750 --> 00:22:09,140
this mostly appears may be the sort of

558
00:22:09,140 --> 00:22:10,870
stream processing systems or continues

559
00:22:10,870 --> 00:22:13,490
continues query systems where I haven't

560
00:22:13,490 --> 00:22:14,480
queries that it was gonna run forever

561
00:22:14,480 --> 00:22:15,980
because there's some you know pipe of

562
00:22:15,980 --> 00:22:17,240
data coming in all the time and I'm and

563
00:22:17,240 --> 00:22:19,880
I'm processing them it did appear in

564
00:22:19,880 --> 00:22:21,950
academic system mr. precision cost-share

565
00:22:21,950 --> 00:22:23,680
DB that does something similar

566
00:22:23,680 --> 00:22:25,970
materialized views are another way to

567
00:22:25,970 --> 00:22:31,460
sort of this but as I said this is for

568
00:22:31,460 --> 00:22:33,020
most applications this is not the

569
00:22:33,020 --> 00:22:34,550
interface there this is not how they're

570
00:22:34,550 --> 00:22:35,600
gonna interact with the data system

571
00:22:35,600 --> 00:22:37,130
they're gonna do it this way open a

572
00:22:37,130 --> 00:22:38,570
connection and send my query the

573
00:22:38,570 --> 00:22:43,460
optimizer takes it plans and runs it the

574
00:22:43,460 --> 00:22:45,950
next question got to deal with is when

575
00:22:45,950 --> 00:22:47,750
are we actually going to fire off the

576
00:22:47,750 --> 00:22:50,180
query optimizer so so this first one

577
00:22:50,180 --> 00:22:51,680
again this is the most common one this

578
00:22:51,680 --> 00:22:53,720
is static optimization would be the

579
00:22:53,720 --> 00:22:56,330
query shows up in the system I've run it

580
00:22:56,330 --> 00:22:58,070
through my optimizer I generate a plan

581
00:22:58,070 --> 00:23:01,100
for that query and then once I leave the

582
00:23:01,100 --> 00:23:02,960
optimizer I never go back to the

583
00:23:02,960 --> 00:23:06,230
optimizer and I just go and execute the

584
00:23:06,230 --> 00:23:08,300
query so it doesn't matter it's like I

585
00:23:08,300 --> 00:23:09,920
so at the time at the optimizer it's

586
00:23:09,920 --> 00:23:11,680
picking what it thinks is the best plan

587
00:23:11,680 --> 00:23:14,270
but it may turn out to be one actually

588
00:23:14,270 --> 00:23:17,120
run the query it it's not as good as I

589
00:23:17,120 --> 00:23:19,370
thought it was I thought it was but I

590
00:23:19,370 --> 00:23:22,100
can't go back like it's sort of it's a

591
00:23:22,100 --> 00:23:24,080
static plan once the optimizer says this

592
00:23:24,080 --> 00:23:25,220
is what you're gonna use you're stuck

593
00:23:25,220 --> 00:23:29,750
with it all right so now the as we

594
00:23:29,750 --> 00:23:31,310
talked about many times the the quality

595
00:23:31,310 --> 00:23:32,690
of these plans will generate will be

596
00:23:32,690 --> 00:23:33,770
highly dependent on the cost model

597
00:23:33,770 --> 00:23:35,480
accuracy that's truly true for

598
00:23:35,480 --> 00:23:37,010
everything but it has to be in this case

599
00:23:37,010 --> 00:23:38,360
here is that you can't go back and tell

600
00:23:38,360 --> 00:23:40,430
the optimizer you're wrong then you told

601
00:23:40,430 --> 00:23:41,570
me something to eat what you told me was

602
00:23:41,570 --> 00:23:43,760
wrong you know pick something better you

603
00:23:43,760 --> 00:23:46,010
you you know you're more dependent maybe

604
00:23:46,010 --> 00:23:48,440
then these other ones here now the other

605
00:23:48,440 --> 00:23:50,150
thing you can deal with too is instead

606
00:23:50,150 --> 00:23:52,910
of having to run this optimizer for

607
00:23:52,910 --> 00:23:54,560
every single query over and over again

608
00:23:54,560 --> 00:23:57,170
especially if it's in the same query you

609
00:23:57,170 --> 00:23:59,690
can amortize this cost using prepared

610
00:23:59,690 --> 00:24:02,870
statements and potentially you know have

611
00:24:02,870 --> 00:24:04,880
a longer time the new query planning

612
00:24:04,880 --> 00:24:05,810
than you would wouldn't normally

613
00:24:05,810 --> 00:24:08,360
otherwise we'll talk about

614
00:24:08,360 --> 00:24:10,820
the cutoff threshold for for the search

615
00:24:10,820 --> 00:24:12,950
of the other parts in a second but think

616
00:24:12,950 --> 00:24:14,150
about this is like you know when I open

617
00:24:14,150 --> 00:24:15,230
up Postgres every time I see coal

618
00:24:15,230 --> 00:24:16,550
whatever terminal I'm using for my data

619
00:24:16,550 --> 00:24:18,650
system I tape a single query in I hit

620
00:24:18,650 --> 00:24:20,840
enter and then I get back a result like

621
00:24:20,840 --> 00:24:23,240
in that time it's gonna run through the

622
00:24:23,240 --> 00:24:25,100
optimizer and generate you know a

623
00:24:25,100 --> 00:24:27,500
physical plan then actually execute the

624
00:24:27,500 --> 00:24:28,910
query and in some cases the queries can

625
00:24:28,910 --> 00:24:33,800
run in in milliseconds so if I have a

626
00:24:33,800 --> 00:24:35,390
bull or comets query that I don't want

627
00:24:35,390 --> 00:24:36,530
to have it you know

628
00:24:36,530 --> 00:24:37,940
you know I'm gonna actually this all the

629
00:24:37,940 --> 00:24:39,290
time and therefore I want to spend some

630
00:24:39,290 --> 00:24:41,810
extra time to do a better job looking

631
00:24:41,810 --> 00:24:44,630
for an optimum plan I can potentially do

632
00:24:44,630 --> 00:24:47,150
that with prepared statements we'll come

633
00:24:47,150 --> 00:24:50,060
to that in a few more slides another

634
00:24:50,060 --> 00:24:52,640
approach that is as far as I know this

635
00:24:52,640 --> 00:24:55,760
doesn't really exist in sort of

636
00:24:55,760 --> 00:24:57,410
relational sequel based database systems

637
00:24:57,410 --> 00:25:00,790
today it mostly shows up potentially in

638
00:25:00,790 --> 00:25:03,380
in stream processing systems but it

639
00:25:03,380 --> 00:25:05,630
might be wrong and the idea here is that

640
00:25:05,630 --> 00:25:09,620
my query shows up I generate logical

641
00:25:09,620 --> 00:25:13,700
plan for it don't want to restart our

642
00:25:13,700 --> 00:25:16,490
generate a logical plan for it and then

643
00:25:16,490 --> 00:25:19,550
I break that plan up into sort of sub

644
00:25:19,550 --> 00:25:23,420
groups of sub plans and before I execute

645
00:25:23,420 --> 00:25:25,580
a sell plan then I run it through the

646
00:25:25,580 --> 00:25:27,650
optimizer to generate the physical plan

647
00:25:27,650 --> 00:25:29,990
and then I execute it and then now I'm

648
00:25:29,990 --> 00:25:31,940
going to learn some information of what

649
00:25:31,940 --> 00:25:34,250
the output of that sub plan will be that

650
00:25:34,250 --> 00:25:38,240
I can then use to guide the optimizer to

651
00:25:38,240 --> 00:25:41,420
find then the next cell plan our next

652
00:25:41,420 --> 00:25:43,700
pipeline I want X dude I could have it

653
00:25:43,700 --> 00:25:45,110
then generate physical plan using the

654
00:25:45,110 --> 00:25:46,550
information I've collected and running

655
00:25:46,550 --> 00:25:48,470
the first one you're sort of iteratively

656
00:25:48,470 --> 00:25:51,500
building up the physical plan by going

657
00:25:51,500 --> 00:25:53,360
back and forth between the execution

658
00:25:53,360 --> 00:25:57,920
engine and the optimizer right so this

659
00:25:57,920 --> 00:26:01,220
is this is rare Ike again I don't think

660
00:26:01,220 --> 00:26:03,380
any commercial system actually does this

661
00:26:03,380 --> 00:26:06,890
approach we'll see in the SEC angrist

662
00:26:06,890 --> 00:26:08,810
actually does this and there it wasn't

663
00:26:08,810 --> 00:26:10,130
so much they were doing this approach

664
00:26:10,130 --> 00:26:12,590
before because they were sophisticated

665
00:26:12,590 --> 00:26:14,780
it's because they were limited to the

666
00:26:14,780 --> 00:26:17,060
sophistication of what the of what they

667
00:26:17,060 --> 00:26:18,080
actually do in the software and the

668
00:26:18,080 --> 00:26:20,660
query planner at the time but I think it

669
00:26:20,660 --> 00:26:21,380
is

670
00:26:21,380 --> 00:26:23,030
exist in academic systems but again I

671
00:26:23,030 --> 00:26:24,260
don't think it exists in any commercial

672
00:26:24,260 --> 00:26:28,820
systems the the last one that does this

673
00:26:28,820 --> 00:26:30,170
one actually does exist in commercial

674
00:26:30,170 --> 00:26:32,420
systems today is this idea called

675
00:26:32,420 --> 00:26:34,790
adaptive query optimization or sometimes

676
00:26:34,790 --> 00:26:36,800
called hybrid optimization and the idea

677
00:26:36,800 --> 00:26:38,480
is that you still do this first step

678
00:26:38,480 --> 00:26:40,610
when you go through the the query shows

679
00:26:40,610 --> 00:26:42,140
up you go through the optimizer the

680
00:26:42,140 --> 00:26:44,660
first time it generates you a plan but

681
00:26:44,660 --> 00:26:47,360
then you your planets also gonna clued

682
00:26:47,360 --> 00:26:51,050
include these built in sort of water

683
00:26:51,050 --> 00:26:53,660
marks or thresholds you can use to

684
00:26:53,660 --> 00:26:55,970
determine whether the estimates that the

685
00:26:55,970 --> 00:26:58,370
cost model used in the first step when I

686
00:26:58,370 --> 00:26:59,450
generated that plan the first time

687
00:26:59,450 --> 00:27:01,460
whether those estimates are actually

688
00:27:01,460 --> 00:27:03,440
matching up with what you're seeing when

689
00:27:03,440 --> 00:27:06,080
you and you access the data so like if I

690
00:27:06,080 --> 00:27:08,150
thought my query was very selective or

691
00:27:08,150 --> 00:27:09,980
so my particle is very selective but

692
00:27:09,980 --> 00:27:12,680
then i run the query and i see the

693
00:27:12,680 --> 00:27:15,110
predicate is not selective at all then

694
00:27:15,110 --> 00:27:17,540
if you identify that the there's a the

695
00:27:17,540 --> 00:27:20,090
error rate for your estimations its

696
00:27:20,090 --> 00:27:22,400
exceeding some threshold then you could

697
00:27:22,400 --> 00:27:24,650
either pivot and change the plan on the

698
00:27:24,650 --> 00:27:27,710
fly right there or you just give up and

699
00:27:27,710 --> 00:27:30,320
go back to the query optimizer and say

700
00:27:30,320 --> 00:27:32,330
hey your plan was wrong make me a new

701
00:27:32,330 --> 00:27:33,620
one and make make me a better one

702
00:27:33,620 --> 00:27:37,160
so the okay we'll talk about this in two

703
00:27:37,160 --> 00:27:39,770
weeks this this one here is you bacon

704
00:27:39,770 --> 00:27:41,450
the query plan itself additional

705
00:27:41,450 --> 00:27:43,370
alternatives and so you can sort of

706
00:27:43,370 --> 00:27:44,750
pivot or change based on what the

707
00:27:44,750 --> 00:27:46,580
thresholds are this one is literally

708
00:27:46,580 --> 00:27:48,260
like saying just stop executing the

709
00:27:48,260 --> 00:27:52,060
query and go back to the optimizer so in

710
00:27:52,060 --> 00:27:54,860
the easiest way to do this is just just

711
00:27:54,860 --> 00:27:56,840
throw everything away and start over

712
00:27:56,840 --> 00:27:59,840
from scratch and the idea is that you

713
00:27:59,840 --> 00:28:01,730
you're you're you're making the gamble

714
00:28:01,730 --> 00:28:03,260
that the physical plan you generate the

715
00:28:03,260 --> 00:28:05,450
first time is so bad that you're better

716
00:28:05,450 --> 00:28:07,010
off throwing away any work you've

717
00:28:07,010 --> 00:28:08,870
already done going back to the optimizer

718
00:28:08,870 --> 00:28:10,310
getting a new plan because that new plan

719
00:28:10,310 --> 00:28:12,050
will be even more efficient than just

720
00:28:12,050 --> 00:28:15,730
letting the first one run to attend

721
00:28:15,730 --> 00:28:18,350
another approach is to then to recognize

722
00:28:18,350 --> 00:28:19,880
how much work you've already done and

723
00:28:19,880 --> 00:28:21,770
then you go back to the optimizer and

724
00:28:21,770 --> 00:28:23,120
say I've already done you know I've

725
00:28:23,120 --> 00:28:25,040
already scan or join these two tables so

726
00:28:25,040 --> 00:28:27,590
generate me a new plan that has that

727
00:28:27,590 --> 00:28:29,390
doesn't change that part I think that

728
00:28:29,390 --> 00:28:31,790
part's fixed we've already computed it

729
00:28:31,790 --> 00:28:35,180
I think everyone pretty much does the

730
00:28:35,180 --> 00:28:36,470
throw everything away and start over at

731
00:28:36,470 --> 00:28:39,160
least in the commercial systems today

732
00:28:39,160 --> 00:28:42,440
alright so this is what prepared

733
00:28:42,440 --> 00:28:44,960
statements so let's say I have a query

734
00:28:44,960 --> 00:28:48,080
here that wants to do a three-way join

735
00:28:48,080 --> 00:28:51,940
on tables ABC and I have some kind of

736
00:28:51,940 --> 00:28:54,260
parameters here that I can use to filter

737
00:28:54,260 --> 00:28:56,090
out the the to pose some of these two

738
00:28:56,090 --> 00:28:58,370
tables so then this is a simple query

739
00:28:58,370 --> 00:29:00,170
right this three by joint it doesn't

740
00:29:00,170 --> 00:29:01,760
it's gonna take no time to execute but

741
00:29:01,760 --> 00:29:04,310
let's say it takes a long time right and

742
00:29:04,310 --> 00:29:06,590
let's say maybe it takes it takes 10

743
00:29:06,590 --> 00:29:08,510
seconds to to run through the query

744
00:29:08,510 --> 00:29:10,970
optimizer but the query only takes one

745
00:29:10,970 --> 00:29:13,490
second to run so in that case every

746
00:29:13,490 --> 00:29:15,290
single time I exceed this quitting say

747
00:29:15,290 --> 00:29:16,580
I'm executing over and over again I

748
00:29:16,580 --> 00:29:18,500
don't want to pay that 10 second search

749
00:29:18,500 --> 00:29:20,300
cost for a query that's going to take

750
00:29:20,300 --> 00:29:23,360
one second so what I can do instead is I

751
00:29:23,360 --> 00:29:25,390
can declare it as a prepared statement

752
00:29:25,390 --> 00:29:27,890
and it's essentially I'm giving this

753
00:29:27,890 --> 00:29:30,020
this this query here this name my query

754
00:29:30,020 --> 00:29:32,480
and now I use the execute command to and

755
00:29:32,480 --> 00:29:35,150
to invoke it all right so now in this

756
00:29:35,150 --> 00:29:38,560
case here the the debut system could

757
00:29:38,560 --> 00:29:40,790
it's told ahead of time what the queries

758
00:29:40,790 --> 00:29:42,620
gonna be as a prepared statement it can

759
00:29:42,620 --> 00:29:44,840
run it through the optimizer take that

760
00:29:44,840 --> 00:29:47,180
10 seconds cache the plan and now I

761
00:29:47,180 --> 00:29:49,280
receive every single time I invoke it

762
00:29:49,280 --> 00:29:51,830
I'm just getting that plan again I said

763
00:29:51,830 --> 00:29:53,660
I so now it runs super fast without

764
00:29:53,660 --> 00:29:55,300
paying the cost to go to the optimizer

765
00:29:55,300 --> 00:29:57,350
so in this case here this is this is a

766
00:29:57,350 --> 00:29:58,850
super simple example this would work

767
00:29:58,850 --> 00:30:01,550
right there's no issues here but let's

768
00:30:01,550 --> 00:30:04,730
say that I want actually this query over

769
00:30:04,730 --> 00:30:06,710
never again but maybe not use these

770
00:30:06,710 --> 00:30:10,070
values that I have here on the to do

771
00:30:10,070 --> 00:30:11,450
this the predicate in the where clause

772
00:30:11,450 --> 00:30:14,150
maybe I want to change these for every

773
00:30:14,150 --> 00:30:16,730
single query so to do this I can replace

774
00:30:16,730 --> 00:30:19,220
the constant values with question marks

775
00:30:19,220 --> 00:30:22,040
which sometimes dollar signs to indicate

776
00:30:22,040 --> 00:30:25,490
that these are input parameters and now

777
00:30:25,490 --> 00:30:28,160
I declare when I declare my prepared

778
00:30:28,160 --> 00:30:29,570
statement I say these are the three

779
00:30:29,570 --> 00:30:30,710
parameters you can pass in and their

780
00:30:30,710 --> 00:30:32,390
types and now when I invoke the query

781
00:30:32,390 --> 00:30:33,860
it's like a function call where I pass

782
00:30:33,860 --> 00:30:37,880
in these actual values all right so now

783
00:30:37,880 --> 00:30:40,120
the tricky thing is gonna be though is

784
00:30:40,120 --> 00:30:42,440
what should the physical plan actually

785
00:30:42,440 --> 00:30:45,320
look like in terms of joint ordering for

786
00:30:45,320 --> 00:30:47,720
this query if I don't know what these

787
00:30:47,720 --> 00:30:49,070
values are at the time

788
00:30:49,070 --> 00:30:50,870
I'm told hey prepare the statement for

789
00:30:50,870 --> 00:30:55,820
me right so if you know it maybe the

790
00:30:55,820 --> 00:30:56,840
first time actually when I have these

791
00:30:56,840 --> 00:30:57,710
values here

792
00:30:57,710 --> 00:31:00,080
I would want to join a a and B first

793
00:31:00,080 --> 00:31:02,899
then join C but maybe for another set of

794
00:31:02,899 --> 00:31:06,710
values I want to join B and C first

795
00:31:06,710 --> 00:31:09,110
followed by a but I don't know that

796
00:31:09,110 --> 00:31:10,519
because all I have are these please

797
00:31:10,519 --> 00:31:12,710
placeholder these variable markers here

798
00:31:12,710 --> 00:31:13,970
I don't know actually what batteries are

799
00:31:13,970 --> 00:31:16,309
gonna be used so there's a couple

800
00:31:16,309 --> 00:31:17,509
different ways we can handle this with

801
00:31:17,509 --> 00:31:18,470
prepared statements and a query

802
00:31:18,470 --> 00:31:22,539
optimizer so easiest thing to do is

803
00:31:22,539 --> 00:31:26,419
every so often we just use whatever the

804
00:31:26,419 --> 00:31:29,389
last plan it is that we had so let's say

805
00:31:29,389 --> 00:31:31,700
that the we call prepared statement we

806
00:31:31,700 --> 00:31:33,230
don't actually prepare it right right

807
00:31:33,230 --> 00:31:34,700
there we don't want to completely see

808
00:31:34,700 --> 00:31:36,200
the query optimizer but when someone

809
00:31:36,200 --> 00:31:38,240
actually invokes it and executed and use

810
00:31:38,240 --> 00:31:40,460
uses the prepared statement now we get

811
00:31:40,460 --> 00:31:43,460
some values we can then say well let's

812
00:31:43,460 --> 00:31:45,049
just assume that those values are gonna

813
00:31:45,049 --> 00:31:46,669
we're gonna represented what we're

814
00:31:46,669 --> 00:31:48,409
always gonna see and I just cache that

815
00:31:48,409 --> 00:31:50,210
plan all right and always use what I

816
00:31:50,210 --> 00:31:52,129
read use before so I think that's what

817
00:31:52,129 --> 00:31:53,840
Postgres does right it's it's pretty

818
00:31:53,840 --> 00:31:58,820
simple the next alternative is that you

819
00:31:58,820 --> 00:32:01,009
actually lose all the benefit of getting

820
00:32:01,009 --> 00:32:02,870
a prepared statement where you set you

821
00:32:02,870 --> 00:32:04,039
run it through the optimizer every

822
00:32:04,039 --> 00:32:05,929
single time you invoke it you can be a

823
00:32:05,929 --> 00:32:08,600
little bit clever and try to use

824
00:32:08,600 --> 00:32:10,460
whatever the last plan you had as the

825
00:32:10,460 --> 00:32:14,299
starting point in the search at least

826
00:32:14,299 --> 00:32:15,590
had that say that you know here's here's

827
00:32:15,590 --> 00:32:17,419
a good starting place for my physical

828
00:32:17,419 --> 00:32:19,370
plan and based your search for the

829
00:32:19,370 --> 00:32:21,740
better plan off of that rather than from

830
00:32:21,740 --> 00:32:23,090
starting from scratch every single time

831
00:32:23,090 --> 00:32:26,149
that it's actually using the previous

832
00:32:26,149 --> 00:32:30,320
plan as an upper bound that is tricky

833
00:32:30,320 --> 00:32:31,399
because that requires you to engineer

834
00:32:31,399 --> 00:32:33,049
optimizer to be able to restart it from

835
00:32:33,049 --> 00:32:36,169
an existing physical plan and most

836
00:32:36,169 --> 00:32:38,570
optimizers written are not written to

837
00:32:38,570 --> 00:32:41,059
handle that another approach is to

838
00:32:41,059 --> 00:32:42,529
generate multiple plans for your

839
00:32:42,529 --> 00:32:46,100
prepared statement so you could say well

840
00:32:46,100 --> 00:32:48,200
I know I'm doing a prepare thing that

841
00:32:48,200 --> 00:32:50,389
has one that has one input parameter on

842
00:32:50,389 --> 00:32:52,759
this one column I can look at my

843
00:32:52,759 --> 00:32:54,470
histograms or statistics that I've

844
00:32:54,470 --> 00:32:56,000
collected through the analyze keyword or

845
00:32:56,000 --> 00:32:57,769
the analyze command about what the

846
00:32:57,769 --> 00:32:59,000
distribution of values look like for

847
00:32:59,000 --> 00:33:00,950
that column and maybe I break them up

848
00:33:00,950 --> 00:33:01,770
into two

849
00:33:01,770 --> 00:33:03,390
buckets in my histogram and I each

850
00:33:03,390 --> 00:33:06,240
bucket I'll generate a generative plan

851
00:33:06,240 --> 00:33:07,920
so now when I invoke the prepared

852
00:33:07,920 --> 00:33:09,330
statement I look at the value mean

853
00:33:09,330 --> 00:33:11,400
passed in and I figure out what bucket

854
00:33:11,400 --> 00:33:12,770
it belongs to and that's the plan I use

855
00:33:12,770 --> 00:33:16,830
so for one variable that's easy to do if

856
00:33:16,830 --> 00:33:18,510
now I have multiple variables and now

857
00:33:18,510 --> 00:33:20,520
becomes exponential or the number of

858
00:33:20,520 --> 00:33:21,840
plans now I'm gonna have possibly have

859
00:33:21,840 --> 00:33:24,210
to would it explode and that would be

860
00:33:24,210 --> 00:33:29,940
expensive to do so I don't think Oracle

861
00:33:29,940 --> 00:33:32,100
might do something like this but it

862
00:33:32,100 --> 00:33:33,960
might be wrong but there's sort of more

863
00:33:33,960 --> 00:33:35,250
primitive versions of trying to look at

864
00:33:35,250 --> 00:33:37,470
have an exhaust of the rate of all

865
00:33:37,470 --> 00:33:39,870
possible plans the last one is just to

866
00:33:39,870 --> 00:33:42,090
say well I know what my parameters are I

867
00:33:42,090 --> 00:33:44,040
can infer what columns doing doing look

868
00:33:44,040 --> 00:33:45,810
doing a lookup someone or what actors

869
00:33:45,810 --> 00:33:48,210
that are accessing and I'll just look at

870
00:33:48,210 --> 00:33:50,270
my statistics take the average value

871
00:33:50,270 --> 00:33:53,010
that each of those columns could

872
00:33:53,010 --> 00:33:55,170
represent and use that as the input

873
00:33:55,170 --> 00:33:57,450
parameters when I prepare that perfectly

874
00:33:57,450 --> 00:33:58,650
when I invoke the prepared statement

875
00:33:58,650 --> 00:34:01,830
through the quarry optimizer so again

876
00:34:01,830 --> 00:34:05,700
there's not one approach that that all

877
00:34:05,700 --> 00:34:07,650
systems actually use this is obvious the

878
00:34:07,650 --> 00:34:10,679
easiest one but I think this is actually

879
00:34:10,679 --> 00:34:11,820
a good research question and I want to

880
00:34:11,820 --> 00:34:15,418
investigate at some point as well all

881
00:34:15,418 --> 00:34:16,469
right the next thing we got to deal with

882
00:34:16,469 --> 00:34:19,980
is is stability so plan stability means

883
00:34:19,980 --> 00:34:23,699
that the that the performance of the

884
00:34:23,699 --> 00:34:26,540
query of a particular query will be

885
00:34:26,540 --> 00:34:29,940
consistent from one day to the next like

886
00:34:29,940 --> 00:34:31,620
if I run the query today and it takes an

887
00:34:31,620 --> 00:34:33,690
X amount of time if I run that same

888
00:34:33,690 --> 00:34:36,659
query tomorrow on the same sort of

889
00:34:36,659 --> 00:34:39,659
database you know modulo some minor

890
00:34:39,659 --> 00:34:41,969
changes I should should take this

891
00:34:41,969 --> 00:34:43,500
roughly about the same amount of time I

892
00:34:43,500 --> 00:34:45,179
would I don't want to happen is I run my

893
00:34:45,179 --> 00:34:49,199
query today and it's it's you know it it

894
00:34:49,199 --> 00:34:51,330
takes this time it run tomorrow and if

895
00:34:51,330 --> 00:34:53,010
you take its half the cost is the

896
00:34:53,010 --> 00:34:54,510
exchange time is cut in half but then

897
00:34:54,510 --> 00:34:56,250
the day after that now it's back to the

898
00:34:56,250 --> 00:34:57,540
original time like I don't want those

899
00:34:57,540 --> 00:34:59,880
oscillations because that makes it super

900
00:34:59,880 --> 00:35:01,850
tricky for it for us to identify

901
00:35:01,850 --> 00:35:03,600
performance bottlenecks and performance

902
00:35:03,600 --> 00:35:06,390
issues DBAs are very conservative about

903
00:35:06,390 --> 00:35:08,550
upgrading database systems David says

904
00:35:08,550 --> 00:35:11,490
some software because they'd rather have

905
00:35:11,490 --> 00:35:13,530
stability and then just better

906
00:35:13,530 --> 00:35:15,920
performance all the time

907
00:35:15,920 --> 00:35:18,839
so how can we achieve stability and have

908
00:35:18,839 --> 00:35:24,060
queries so again this is all about the

909
00:35:24,060 --> 00:35:25,349
query optimizer so we want to make sure

910
00:35:25,349 --> 00:35:26,910
that our query optimizer is generating

911
00:35:26,910 --> 00:35:30,150
plans for queries that from one day to

912
00:35:30,150 --> 00:35:34,440
the next will have state stable

913
00:35:34,440 --> 00:35:37,050
performance so one approach is to

914
00:35:37,050 --> 00:35:39,359
provide hints to the query plan so this

915
00:35:39,359 --> 00:35:40,470
is where essentially you can annotate

916
00:35:40,470 --> 00:35:42,660
the query either through like special

917
00:35:42,660 --> 00:35:45,420
comments in the header or if it's a

918
00:35:45,420 --> 00:35:47,099
graphical tool sometimes you can do this

919
00:35:47,099 --> 00:35:49,349
where you can specify what you want the

920
00:35:49,349 --> 00:35:51,510
query optimizer actually to do all right

921
00:35:51,510 --> 00:35:53,670
for certain choices it has to make so

922
00:35:53,670 --> 00:35:54,950
all the times you'll see this like I

923
00:35:54,950 --> 00:35:57,390
even you can provide a hint to the

924
00:35:57,390 --> 00:35:59,490
optimizer and say this query scene you

925
00:35:59,490 --> 00:36:01,410
should use this index on this table I

926
00:36:01,410 --> 00:36:02,700
don't care about other indexes or scan

927
00:36:02,700 --> 00:36:04,560
so you make sure using its index right

928
00:36:04,560 --> 00:36:06,000
or the join ordering will be another

929
00:36:06,000 --> 00:36:11,640
common one another one is to you can

930
00:36:11,640 --> 00:36:14,069
tell that some database systems which

931
00:36:14,069 --> 00:36:14,940
optimizer

932
00:36:14,940 --> 00:36:16,619
version they want to use for a

933
00:36:16,619 --> 00:36:19,800
particular query so a lot of times when

934
00:36:19,800 --> 00:36:21,000
people upgrade the database system

935
00:36:21,000 --> 00:36:24,390
software expect this is in particularly

936
00:36:24,390 --> 00:36:28,109
for Oracle you can specify which version

937
00:36:28,109 --> 00:36:30,210
of the optimizer you want the queries to

938
00:36:30,210 --> 00:36:32,700
use because if you've already vetted say

939
00:36:32,700 --> 00:36:34,680
a previous version and the optimizer

940
00:36:34,680 --> 00:36:36,450
generated plans that you can understand

941
00:36:36,450 --> 00:36:38,700
you have stable performance numbers when

942
00:36:38,700 --> 00:36:39,960
you do the upgrade maybe you don't want

943
00:36:39,960 --> 00:36:41,040
to update the optimizer and have it

944
00:36:41,040 --> 00:36:42,990
generate different plans for queries and

945
00:36:42,990 --> 00:36:47,010
now the numbers may vary right so again

946
00:36:47,010 --> 00:36:49,710
DBAs are very conservative it's not it's

947
00:36:49,710 --> 00:36:51,359
not helpful if we upgrade the data to

948
00:36:51,359 --> 00:36:54,930
system software and 99% of our queries

949
00:36:54,930 --> 00:36:56,849
now run faster but then 1% of the

950
00:36:56,849 --> 00:36:58,230
queries run slower because the optimizer

951
00:36:58,230 --> 00:37:00,510
picked up a different plan than it used

952
00:37:00,510 --> 00:37:01,220
to

953
00:37:01,220 --> 00:37:04,500
that's me bad because the people whose

954
00:37:04,500 --> 00:37:06,180
queries run slower now are gonna get in

955
00:37:06,180 --> 00:37:07,829
the phone and call you and complain and

956
00:37:07,829 --> 00:37:09,119
say why is my query run slower please

957
00:37:09,119 --> 00:37:12,060
fix it the the the other 99% the queries

958
00:37:12,060 --> 00:37:13,290
those people aren't gonna call and say

959
00:37:13,290 --> 00:37:14,760
you know thank you for making a query

960
00:37:14,760 --> 00:37:16,619
run faster people don't do that

961
00:37:16,619 --> 00:37:18,150
it's when things go bad that's when

962
00:37:18,150 --> 00:37:21,690
people complain right so in this case

963
00:37:21,690 --> 00:37:23,640
here again so if I upgrade my upgrade

964
00:37:23,640 --> 00:37:25,890
Oracle I can say I want to run with the

965
00:37:25,890 --> 00:37:27,420
previous optimizer because that'll

966
00:37:27,420 --> 00:37:28,320
generate plans that I

967
00:37:28,320 --> 00:37:31,860
that I know about the last choice is to

968
00:37:31,860 --> 00:37:34,440
support backwards-compatible plans so

969
00:37:34,440 --> 00:37:36,450
the idea here is that if I say I upgrade

970
00:37:36,450 --> 00:37:39,330
my database system software but before I

971
00:37:39,330 --> 00:37:42,540
do that on the old system I dump out or

972
00:37:42,540 --> 00:37:45,180
export all the plans for my prepared

973
00:37:45,180 --> 00:37:46,680
Sabres or queries that I'm executing all

974
00:37:46,680 --> 00:37:49,470
the time and too much of files then I

975
00:37:49,470 --> 00:37:50,970
upgraded the Devi system software and

976
00:37:50,970 --> 00:37:53,730
then I load back in those plans from the

977
00:37:53,730 --> 00:37:54,990
previous version of the software and

978
00:37:54,990 --> 00:37:57,480
override any decision that the optimizer

979
00:37:57,480 --> 00:37:59,690
make you're saying no for this query

980
00:37:59,690 --> 00:38:02,250
absolutely use this plan that guarantees

981
00:38:02,250 --> 00:38:04,230
you've had the same plan but you had

982
00:38:04,230 --> 00:38:06,780
before so sequel server allows you to do

983
00:38:06,780 --> 00:38:08,130
this sequel server you can dump out the

984
00:38:08,130 --> 00:38:11,160
query plans as as XML and then load them

985
00:38:11,160 --> 00:38:16,860
back into new versions that's the last

986
00:38:16,860 --> 00:38:18,690
thing we talked about is search term

987
00:38:18,690 --> 00:38:20,550
termination so again when you're on the

988
00:38:20,550 --> 00:38:22,380
command line you write you type of query

989
00:38:22,380 --> 00:38:25,200
in you hit enter and to run the query

990
00:38:25,200 --> 00:38:28,710
optimizer and so you need a way for the

991
00:38:28,710 --> 00:38:30,240
query optimizer to determine I've run

992
00:38:30,240 --> 00:38:34,140
long enough and I need to stop because

993
00:38:34,140 --> 00:38:36,150
again some of these problems you know

994
00:38:36,150 --> 00:38:38,940
from very complex queries you know it's

995
00:38:38,940 --> 00:38:41,100
the the search spaces and be complete so

996
00:38:41,100 --> 00:38:42,240
you can just be running this for days

997
00:38:42,240 --> 00:38:44,250
and days and days and people aren't

998
00:38:44,250 --> 00:38:44,910
gonna like that

999
00:38:44,910 --> 00:38:47,250
so the most obvious thing to do is just

1000
00:38:47,250 --> 00:38:48,990
set a wall clock time barrier that says

1001
00:38:48,990 --> 00:38:51,630
that if my optimizer runs first it

1002
00:38:51,630 --> 00:38:54,390
amount of time I just kill and I stop

1003
00:38:54,390 --> 00:38:57,120
all right another approach is to have a

1004
00:38:57,120 --> 00:39:00,120
cost threshold where you say that if I

1005
00:39:00,120 --> 00:39:01,790
find a plan

1006
00:39:01,790 --> 00:39:04,500
if I find a plan that has a lower cost

1007
00:39:04,500 --> 00:39:06,180
than some threshold that I want or

1008
00:39:06,180 --> 00:39:08,370
another one might be if I if I've run

1009
00:39:08,370 --> 00:39:09,450
for a certain amount of time and I don't

1010
00:39:09,450 --> 00:39:11,490
find a plan that's you know twenty

1011
00:39:11,490 --> 00:39:13,200
percent or ten percent better than the

1012
00:39:13,200 --> 00:39:15,120
best plan I've seen so far then I just

1013
00:39:15,120 --> 00:39:16,380
go ahead and stop myself

1014
00:39:16,380 --> 00:39:18,780
the last one is basically you say if you

1015
00:39:18,780 --> 00:39:20,070
can identify that there's no more

1016
00:39:20,070 --> 00:39:22,140
possible permutation or enumeration you

1017
00:39:22,140 --> 00:39:25,260
can do for the target plan then you know

1018
00:39:25,260 --> 00:39:27,630
you you're done for the search and

1019
00:39:27,630 --> 00:39:29,610
typically this is done on a per blue

1020
00:39:29,610 --> 00:39:31,800
basis right because if it's a lot a lot

1021
00:39:31,800 --> 00:39:34,020
of a lot of tables a lot of joins and

1022
00:39:34,020 --> 00:39:36,180
you don't ever actually exhaust this all

1023
00:39:36,180 --> 00:39:40,200
right so give it one example of how this

1024
00:39:40,200 --> 00:39:41,550
is used and

1025
00:39:41,550 --> 00:39:44,880
of my sequel you can specify the

1026
00:39:44,880 --> 00:39:46,290
optimizer search death in the search

1027
00:39:46,290 --> 00:39:49,260
tree so this prevents you from going

1028
00:39:49,260 --> 00:39:52,950
maybe too far down and the branching and

1029
00:39:52,950 --> 00:39:54,630
you started to artificially cut off the

1030
00:39:54,630 --> 00:39:56,910
search you know so many level deep so

1031
00:39:56,910 --> 00:39:59,340
that that you exhaust the number of

1032
00:39:59,340 --> 00:40:03,930
possible choices more quickly it's some

1033
00:40:03,930 --> 00:40:06,540
systems try to be dynamic and often hard

1034
00:40:06,540 --> 00:40:11,210
to get this right so it is this is one

1035
00:40:11,210 --> 00:40:14,220
semi Tina's blog article from percona

1036
00:40:14,220 --> 00:40:17,150
who is one of the major my sequel

1037
00:40:17,150 --> 00:40:19,320
consulting companies do a lot of

1038
00:40:19,320 --> 00:40:21,480
development my sequel so back in 2012

1039
00:40:21,480 --> 00:40:24,510
they talked about how they had this they

1040
00:40:24,510 --> 00:40:26,130
had this one customer that was doing a

1041
00:40:26,130 --> 00:40:29,700
select query on 20 tables and the

1042
00:40:29,700 --> 00:40:32,640
optimizer took took 5 seconds to find

1043
00:40:32,640 --> 00:40:34,440
the query plan and the query only ran

1044
00:40:34,440 --> 00:40:36,540
for 50 milliseconds because it was

1045
00:40:36,540 --> 00:40:38,880
reading a thousand tuples and so by

1046
00:40:38,880 --> 00:40:40,320
saying that like search death and

1047
00:40:40,320 --> 00:40:41,820
artificially cutting it all from just

1048
00:40:41,820 --> 00:40:43,710
doing his also search they were able to

1049
00:40:43,710 --> 00:40:45,300
get it down in the optimizer to

1050
00:40:45,300 --> 00:40:48,750
finishing in milliseconds so all the

1051
00:40:48,750 --> 00:40:49,980
various data systems have different

1052
00:40:49,980 --> 00:40:52,740
tools to figure these things out all

1053
00:40:52,740 --> 00:40:55,550
right so now we want to talk about the

1054
00:40:55,550 --> 00:40:57,870
serve again these are all the we just

1055
00:40:57,870 --> 00:40:59,100
talk about all the design decisions we

1056
00:40:59,100 --> 00:41:00,720
have to consider when we want to build

1057
00:41:00,720 --> 00:41:01,890
our optimizer how to handle prepared

1058
00:41:01,890 --> 00:41:03,180
statements how to decide when to finish

1059
00:41:03,180 --> 00:41:05,490
finish searching what to actually do our

1060
00:41:05,490 --> 00:41:07,170
search on one query multiple queries

1061
00:41:07,170 --> 00:41:09,060
things like that now we want to talk

1062
00:41:09,060 --> 00:41:11,490
about what the search is we know what

1063
00:41:11,490 --> 00:41:13,860
the this serve what the optimizer

1064
00:41:13,860 --> 00:41:15,180
actually looks like how is it actually

1065
00:41:15,180 --> 00:41:17,070
going to generate a physical plan from a

1066
00:41:17,070 --> 00:41:20,540
logical plan so the way to think about

1067
00:41:20,540 --> 00:41:22,760
what we're going to talk about today is

1068
00:41:22,760 --> 00:41:25,730
we're going forward into time and

1069
00:41:25,730 --> 00:41:28,740
complexity so it was like a from a time

1070
00:41:28,740 --> 00:41:30,570
being like historical points so like

1071
00:41:30,570 --> 00:41:32,580
heuristics based optimizers of what they

1072
00:41:32,580 --> 00:41:35,160
they first built in the 1970s and going

1073
00:41:35,160 --> 00:41:36,930
forward in this the you know we're

1074
00:41:36,930 --> 00:41:38,390
coming to newer newer implementations

1075
00:41:38,390 --> 00:41:40,290
the other I think also think about too

1076
00:41:40,290 --> 00:41:44,010
is these are these are the the heuristic

1077
00:41:44,010 --> 00:41:45,090
based one is in the simplest way to

1078
00:41:45,090 --> 00:41:45,810
build an optimizer

1079
00:41:45,810 --> 00:41:47,670
although the engineering side of it can

1080
00:41:47,670 --> 00:41:51,120
get very very messy but going down the

1081
00:41:51,120 --> 00:41:53,310
the implementations become more complex

1082
00:41:53,310 --> 00:41:54,870
and therefore the

1083
00:41:54,870 --> 00:41:57,060
query optimizations and rules they can

1084
00:41:57,060 --> 00:41:59,340
transformations they can apply become

1085
00:41:59,340 --> 00:42:03,470
more sophisticated so we'll talk about

1086
00:42:03,470 --> 00:42:05,370
these these are worth talking about

1087
00:42:05,370 --> 00:42:06,810
because this is what you'll see often

1088
00:42:06,810 --> 00:42:08,160
when people first build into a system

1089
00:42:08,160 --> 00:42:09,240
because they're not gonna have a call

1090
00:42:09,240 --> 00:42:10,680
space search model they're gonna use

1091
00:42:10,680 --> 00:42:12,240
heuristics and sometimes heuristics can

1092
00:42:12,240 --> 00:42:15,330
still be are still widely used today and

1093
00:42:15,330 --> 00:42:17,220
then the unified search and stratified

1094
00:42:17,220 --> 00:42:18,840
searches will we'll end up well talked

1095
00:42:18,840 --> 00:42:21,750
about today will get up to the volcano

1096
00:42:21,750 --> 00:42:23,900
optimizer and then that'll segue into

1097
00:42:23,900 --> 00:42:25,740
the next lecture when we talked about

1098
00:42:25,740 --> 00:42:32,190
Cascades in more detail okay so the very

1099
00:42:32,190 --> 00:42:34,050
first query optimizer is for the

1100
00:42:34,050 --> 00:42:35,880
relational database systems in the 1970s

1101
00:42:35,880 --> 00:42:37,590
for two of the three first relational

1102
00:42:37,590 --> 00:42:41,190
database systems we're using heuristic

1103
00:42:41,190 --> 00:42:44,550
based transformations and the idea here

1104
00:42:44,550 --> 00:42:47,370
is that in the code itself you're you

1105
00:42:47,370 --> 00:42:50,760
define these these rules that will

1106
00:42:50,760 --> 00:42:53,610
transform the logical operators and to

1107
00:42:53,610 --> 00:42:57,330
physical operators so the the most

1108
00:42:57,330 --> 00:42:58,530
common thing would be like if I'm doing

1109
00:42:58,530 --> 00:43:00,780
a scan and I know I have like an index

1110
00:43:00,780 --> 00:43:02,820
that had that matches all the predicates

1111
00:43:02,820 --> 00:43:04,860
in my where clause then that's the index

1112
00:43:04,860 --> 00:43:06,480
I would want to use all right so that's

1113
00:43:06,480 --> 00:43:08,070
sort of like that stargell stuff that we

1114
00:43:08,070 --> 00:43:11,280
talked about a few slides before so

1115
00:43:11,280 --> 00:43:12,540
that's that's sort of the standard

1116
00:43:12,540 --> 00:43:14,220
transformations you can do from logical

1117
00:43:14,220 --> 00:43:15,390
to physical but some of the

1118
00:43:15,390 --> 00:43:16,650
optimizations you can do to improve

1119
00:43:16,650 --> 00:43:19,080
query performance will be applying all

1120
00:43:19,080 --> 00:43:21,240
the the and the basic rules you want to

1121
00:43:21,240 --> 00:43:22,650
have for a query execution like

1122
00:43:22,650 --> 00:43:25,140
predicate pushdown let me push down some

1123
00:43:25,140 --> 00:43:25,770
things like that

1124
00:43:25,770 --> 00:43:27,660
my predicate push down would be instead

1125
00:43:27,660 --> 00:43:29,490
of having you know the may be the

1126
00:43:29,490 --> 00:43:31,020
predicate at the top of the query plan I

1127
00:43:31,020 --> 00:43:33,060
push it all the way down to my access

1128
00:43:33,060 --> 00:43:35,130
method so that I'm filtering out tuples

1129
00:43:35,130 --> 00:43:36,990
as quickly as possible I'm not not you

1130
00:43:36,990 --> 00:43:38,340
know passing in form one hopper to the

1131
00:43:38,340 --> 00:43:39,530
next good that would be expensive

1132
00:43:39,530 --> 00:43:41,640
another common thing will also be to do

1133
00:43:41,640 --> 00:43:43,260
to handle join ordering through just

1134
00:43:43,260 --> 00:43:45,240
cardinality estimates they could say

1135
00:43:45,240 --> 00:43:46,890
that you know we have joining two tables

1136
00:43:46,890 --> 00:43:50,010
you know which one potentially you can

1137
00:43:50,010 --> 00:43:52,350
approximate which one is gonna have more

1138
00:43:52,350 --> 00:43:53,760
triples feeding into the joint operator

1139
00:43:53,760 --> 00:43:55,770
so you make that one versus one the

1140
00:43:55,770 --> 00:43:57,960
outer versus one the inner it's simple

1141
00:43:57,960 --> 00:44:00,450
rules like that so the important thing

1142
00:44:00,450 --> 00:44:01,980
I've seen about this is that there's no

1143
00:44:01,980 --> 00:44:03,960
cost model involved in this it's all

1144
00:44:03,960 --> 00:44:06,960
static it's like I see a query a query

1145
00:44:06,960 --> 00:44:07,990
planner has this

1146
00:44:07,990 --> 00:44:10,730
pattern in it I always apply this rule

1147
00:44:10,730 --> 00:44:13,910
right I always push down the the the

1148
00:44:13,910 --> 00:44:17,390
predicate things like that so as I said

1149
00:44:17,390 --> 00:44:20,119
the the two or the three first

1150
00:44:20,119 --> 00:44:22,460
relational database systems from the

1151
00:44:22,460 --> 00:44:23,869
major relational database systems from

1152
00:44:23,869 --> 00:44:27,200
the 1970s ingress out of Berkeley from

1153
00:44:27,200 --> 00:44:28,970
like Stonebreaker and Oracle from from

1154
00:44:28,970 --> 00:44:31,460
Larry Ellison this is what what they

1155
00:44:31,460 --> 00:44:36,529
used and the in from back then like the

1156
00:44:36,529 --> 00:44:40,190
the resources that they had for you know

1157
00:44:40,190 --> 00:44:42,140
for you know competing researchers to

1158
00:44:42,140 --> 00:44:43,069
run actually run the Devi system

1159
00:44:43,069 --> 00:44:47,019
software itself was was quite limited so

1160
00:44:47,019 --> 00:44:50,000
the size of the databases they were

1161
00:44:50,000 --> 00:44:52,819
trying to store back in the 1970s were

1162
00:44:52,819 --> 00:44:55,940
super small right so like in was talk

1163
00:44:55,940 --> 00:44:56,869
about this in a second I mean case of

1164
00:44:56,869 --> 00:45:00,109
the ingress paper here like they're

1165
00:45:00,109 --> 00:45:01,369
talking about you know scanning tables

1166
00:45:01,369 --> 00:45:02,930
with like three hundred tuples and

1167
00:45:02,930 --> 00:45:05,089
that's that's like that's nothing so the

1168
00:45:05,089 --> 00:45:06,589
complexity of the problem they were

1169
00:45:06,589 --> 00:45:08,869
trying to deal with this is the kind of

1170
00:45:08,869 --> 00:45:09,650
queries they were trying to deal with

1171
00:45:09,650 --> 00:45:13,099
this is was much much less than what we

1172
00:45:13,099 --> 00:45:13,700
deal with today

1173
00:45:13,700 --> 00:45:18,619
in the case of Oracle like Oracle you

1174
00:45:18,619 --> 00:45:20,569
know they got huge and got you know a

1175
00:45:20,569 --> 00:45:23,750
lot of money riding on a you know the

1176
00:45:23,750 --> 00:45:25,490
the simplest type of sort of optimizer

1177
00:45:25,490 --> 00:45:27,859
an you can have again one that I didn't

1178
00:45:27,859 --> 00:45:28,940
have a cost model that all the things

1179
00:45:28,940 --> 00:45:31,099
were talked about and going forward like

1180
00:45:31,099 --> 00:45:33,589
they got huge just based on this so I

1181
00:45:33,589 --> 00:45:34,819
don't want to say I wanna make a sound

1182
00:45:34,819 --> 00:45:37,250
or sound like I'm saying you can't you

1183
00:45:37,250 --> 00:45:38,630
can't have a sophisticated data system

1184
00:45:38,630 --> 00:45:39,890
without having a cost-based optimizer

1185
00:45:39,890 --> 00:45:43,730
clearly Oracle got quite far with it but

1186
00:45:43,730 --> 00:45:45,380
again back in the 1990's the type of

1187
00:45:45,380 --> 00:45:46,579
queries they were dealing with like the

1188
00:45:46,579 --> 00:45:49,309
sequel 92 standard no CT es no one to

1189
00:45:49,309 --> 00:45:51,049
function and no use define aggregates

1190
00:45:51,049 --> 00:45:54,730
right all these things didn't exist so

1191
00:45:54,730 --> 00:45:57,619
it is actually viable but again also

1192
00:45:57,619 --> 00:45:59,390
 got really big without having

1193
00:45:59,390 --> 00:46:02,829
having a cost-based optimizer as well so

1194
00:46:02,829 --> 00:46:04,789
I've talked to some people that worked

1195
00:46:04,789 --> 00:46:06,589
on the the Oracle query optimizer like

1196
00:46:06,589 --> 00:46:09,170
back in the day in the 1980s 1990s and

1197
00:46:09,170 --> 00:46:14,269
they would say that it was the largest

1198
00:46:14,269 --> 00:46:17,450
piece of code in the system and it was

1199
00:46:17,450 --> 00:46:19,099
quite sophisticated and what it could do

1200
00:46:19,099 --> 00:46:21,560
but it was like an engineering nightmare

1201
00:46:21,560 --> 00:46:23,060
cuz everything was written in C there

1202
00:46:23,060 --> 00:46:25,310
wasn't no debt you know high-level DSL

1203
00:46:25,310 --> 00:46:27,470
order declaration of the rules right he

1204
00:46:27,470 --> 00:46:28,790
was a bunch of if if then else

1205
00:46:28,790 --> 00:46:32,480
statements and so again they had a lot

1206
00:46:32,480 --> 00:46:34,190
of money and they had some really smart

1207
00:46:34,190 --> 00:46:36,230
people and they could have done you know

1208
00:46:36,230 --> 00:46:38,510
amazing things by expanding this but it

1209
00:46:38,510 --> 00:46:40,820
just got to come n tenable and I said

1210
00:46:40,820 --> 00:46:43,130
that's why they switched over to the the

1211
00:46:43,130 --> 00:46:45,290
the cost based models cost based

1212
00:46:45,290 --> 00:46:46,130
searches that we'll talk about in a

1213
00:46:46,130 --> 00:46:50,420
second right so again this is what

1214
00:46:50,420 --> 00:46:51,590
ingress did beginning this would all

1215
00:46:51,590 --> 00:46:53,090
post a in the beginning I'm not saying

1216
00:46:53,090 --> 00:46:54,140
that this is the right way to do it in

1217
00:46:54,140 --> 00:46:56,900
some cases it is some cases it's not and

1218
00:46:56,900 --> 00:46:59,120
so let's talk about what ingress does

1219
00:46:59,120 --> 00:47:01,520
again this is mostly just for her stroke

1220
00:47:01,520 --> 00:47:02,840
or curiosity

1221
00:47:02,840 --> 00:47:06,080
so going forward we're gonna use the

1222
00:47:06,080 --> 00:47:07,760
following three table schema and with an

1223
00:47:07,760 --> 00:47:11,200
example query of Spotify or Apple iTunes

1224
00:47:11,200 --> 00:47:13,910
database so we have artists and we have

1225
00:47:13,910 --> 00:47:15,890
albums and then out artists appear on

1226
00:47:15,890 --> 00:47:17,300
albums so we're just keeping track of

1227
00:47:17,300 --> 00:47:19,670
like what you know what would what

1228
00:47:19,670 --> 00:47:21,260
records what albums are being put out

1229
00:47:21,260 --> 00:47:24,740
and what artists are on that so let's

1230
00:47:24,740 --> 00:47:26,480
talk about ingress does so this is what

1231
00:47:26,480 --> 00:47:29,180
ingress used back in the 1970s so for

1232
00:47:29,180 --> 00:47:31,220
this we're to use this query here where

1233
00:47:31,220 --> 00:47:32,690
it's a three-way join between artists

1234
00:47:32,690 --> 00:47:35,030
appear as an album and we want to get

1235
00:47:35,030 --> 00:47:37,700
all the artists that appear on my my

1236
00:47:37,700 --> 00:47:42,950
next tape right so angrist didn't the

1237
00:47:42,950 --> 00:47:47,660
way it did joins is that Hedda says

1238
00:47:47,660 --> 00:47:53,270
ingress didn't support joins so they had

1239
00:47:53,270 --> 00:47:57,200
to rewrite all the queries into single

1240
00:47:57,200 --> 00:47:58,460
table queries so because again because

1241
00:47:58,460 --> 00:48:01,790
they couldn't join tables together so

1242
00:48:01,790 --> 00:48:04,640
the first step what they would do is

1243
00:48:04,640 --> 00:48:06,410
they would take a joint play like this

1244
00:48:06,410 --> 00:48:09,020
and then they would then decompose it

1245
00:48:09,020 --> 00:48:12,890
into single value queries so what am i

1246
00:48:12,890 --> 00:48:15,860
bad so say you take this query here and

1247
00:48:15,860 --> 00:48:17,660
we're gonna rewrite it into two queries

1248
00:48:17,660 --> 00:48:19,580
so the first query now is gonna just

1249
00:48:19,580 --> 00:48:21,950
just be on the album table where we're

1250
00:48:21,950 --> 00:48:23,180
doing the lookup on the album name

1251
00:48:23,180 --> 00:48:24,470
because that's what we're passing over

1252
00:48:24,470 --> 00:48:26,570
here right and so this is just a select

1253
00:48:26,570 --> 00:48:28,520
on the single table here but then we're

1254
00:48:28,520 --> 00:48:31,700
gonna write it out into a temp table and

1255
00:48:31,700 --> 00:48:34,700
then now for this query here we replace

1256
00:48:34,700 --> 00:48:35,390
album

1257
00:48:35,390 --> 00:48:37,819
with our temp table reference here and

1258
00:48:37,819 --> 00:48:39,799
here so now we're going to recursively

1259
00:48:39,799 --> 00:48:43,069
now rewrite this query to remove in the

1260
00:48:43,069 --> 00:48:45,319
the joins that we have and so now we're

1261
00:48:45,319 --> 00:48:47,299
gonna have the this new query here that

1262
00:48:47,299 --> 00:48:48,859
just does a lookup on a peers with a

1263
00:48:48,859 --> 00:48:51,650
joint on temp 1 and it's gonna write the

1264
00:48:51,650 --> 00:48:54,920
output into 10 - then this query on the

1265
00:48:54,920 --> 00:48:57,380
artists table will do a lookup or do the

1266
00:48:57,380 --> 00:49:00,230
join against Tim - so now once you do

1267
00:49:00,230 --> 00:49:02,240
this once you do the rewriting you're

1268
00:49:02,240 --> 00:49:04,640
gonna then substitute the values from

1269
00:49:04,640 --> 00:49:07,430
these temp tables with the actual values

1270
00:49:07,430 --> 00:49:11,599
that are produced by the query so say we

1271
00:49:11,599 --> 00:49:12,799
execute this first one here

1272
00:49:12,799 --> 00:49:15,260
well then generate get the output of the

1273
00:49:15,260 --> 00:49:19,160
album ID 999 so then now we go to the

1274
00:49:19,160 --> 00:49:21,740
next query and we replace the reference

1275
00:49:21,740 --> 00:49:25,670
to temp 1 now with 9999 that's being

1276
00:49:25,670 --> 00:49:27,619
generated by the previous query so now

1277
00:49:27,619 --> 00:49:29,299
this is no longer a joint this is a

1278
00:49:29,299 --> 00:49:31,250
single statement or single table query

1279
00:49:31,250 --> 00:49:33,710
and I'm just substituting that value in

1280
00:49:33,710 --> 00:49:35,680
that produced from the previous query

1281
00:49:35,680 --> 00:49:38,420
same thing here this query runs now

1282
00:49:38,420 --> 00:49:40,309
produces two output and then now I can

1283
00:49:40,309 --> 00:49:42,980
rewrite this query into two queries one

1284
00:49:42,980 --> 00:49:44,480
that takes artist ID one two three and

1285
00:49:44,480 --> 00:49:46,130
the Netherlands it takes artist ID 4 5 6

1286
00:49:46,130 --> 00:49:48,950
and I can actually both of them produce

1287
00:49:48,950 --> 00:49:51,289
results of those queries combine them

1288
00:49:51,289 --> 00:49:53,089
together and then that's the output of

1289
00:49:53,089 --> 00:49:57,920
of my join all right so this is pretty

1290
00:49:57,920 --> 00:49:59,509
impressive right this is like a way to

1291
00:49:59,509 --> 00:50:02,329
do rewriting of queries

1292
00:50:02,329 --> 00:50:05,180
I mean I'm showing this on the sequel

1293
00:50:05,180 --> 00:50:07,210
level they would be doing this on the

1294
00:50:07,210 --> 00:50:12,019
physical plan level you know this allows

1295
00:50:12,019 --> 00:50:13,430
them to actually joins without actually

1296
00:50:13,430 --> 00:50:14,930
having a joint implementation like

1297
00:50:14,930 --> 00:50:16,160
you're just doing the single statement

1298
00:50:16,160 --> 00:50:20,359
selects so it's been argued that this is

1299
00:50:20,359 --> 00:50:22,339
actually an early example of adaptive

1300
00:50:22,339 --> 00:50:24,500
query optimization because rather than

1301
00:50:24,500 --> 00:50:26,059
doing the static optimization approach

1302
00:50:26,059 --> 00:50:30,559
where I would generate the plan all at

1303
00:50:30,559 --> 00:50:34,309
once for my entire query I could take

1304
00:50:34,309 --> 00:50:36,529
the sequel query here I see as a miss

1305
00:50:36,529 --> 00:50:37,640
book they were not operating physical

1306
00:50:37,640 --> 00:50:39,079
plans they probably operating on logical

1307
00:50:39,079 --> 00:50:42,309
plans but I could take this query here

1308
00:50:42,309 --> 00:50:46,309
and only when I get the values one two

1309
00:50:46,309 --> 00:50:47,150
three that I want to substitute

1310
00:50:47,150 --> 00:50:48,800
substitute into it

1311
00:50:48,800 --> 00:50:50,930
then I fired off I send it off to the

1312
00:50:50,930 --> 00:50:52,340
query optimizer and then generate the

1313
00:50:52,340 --> 00:50:54,110
physical plan for it so it's sort of

1314
00:50:54,110 --> 00:50:56,660
like a late binding optimization

1315
00:50:56,660 --> 00:50:59,270
approach right so like like I can learn

1316
00:50:59,270 --> 00:51:00,740
from information about what's coming out

1317
00:51:00,740 --> 00:51:02,990
of these queries to decide what the best

1318
00:51:02,990 --> 00:51:04,690
way to actually this particular query is

1319
00:51:04,690 --> 00:51:07,220
it's sort of again it's not exactly what

1320
00:51:07,220 --> 00:51:08,480
an adapter query optimization is but

1321
00:51:08,480 --> 00:51:09,920
they're essentially running the

1322
00:51:09,920 --> 00:51:12,320
optimizer on a per pupil basis which

1323
00:51:12,320 --> 00:51:18,110
nobody does today okay so all right what

1324
00:51:18,110 --> 00:51:19,370
are some advantage the disadvantages of

1325
00:51:19,370 --> 00:51:20,900
the Harriston based optimization so one

1326
00:51:20,900 --> 00:51:23,750
it's it's easy to implement it's easy to

1327
00:51:23,750 --> 00:51:25,820
debug because you just walk through with

1328
00:51:25,820 --> 00:51:27,230
gdb or whatever your favorite debugger

1329
00:51:27,230 --> 00:51:29,210
is and step through and see what what

1330
00:51:29,210 --> 00:51:32,330
rules actually get fired and in order to

1331
00:51:32,330 --> 00:51:34,250
determine why I mean a why I chose one

1332
00:51:34,250 --> 00:51:37,220
particular plan versus another right and

1333
00:51:37,220 --> 00:51:40,910
as I said when you when you build a new

1334
00:51:40,910 --> 00:51:42,710
database system today just to get it up

1335
00:51:42,710 --> 00:51:43,700
and running and excuse some first

1336
00:51:43,700 --> 00:51:46,160
queries you can get pretty far with a

1337
00:51:46,160 --> 00:51:47,840
arista bake-off heuristic based

1338
00:51:47,840 --> 00:51:54,070
optimizer the downside though is that

1339
00:51:54,070 --> 00:51:57,710
oftentimes if you will have to have

1340
00:51:57,710 --> 00:52:00,370
these these constant thresholds or

1341
00:52:00,370 --> 00:52:03,740
values baked in the source code itself

1342
00:52:03,740 --> 00:52:06,050
or defined in a configuration file to

1343
00:52:06,050 --> 00:52:08,570
help me make determination about certain

1344
00:52:08,570 --> 00:52:11,450
decisions you have to make like if I

1345
00:52:11,450 --> 00:52:13,160
wanted to determine whether a if I want

1346
00:52:13,160 --> 00:52:15,830
to a join a herd a logical doing plan or

1347
00:52:15,830 --> 00:52:17,570
operator into a physical join operator

1348
00:52:17,570 --> 00:52:19,220
and then need to determine whether it's

1349
00:52:19,220 --> 00:52:20,840
sort merge-join as faster than a hash

1350
00:52:20,840 --> 00:52:24,650
join I have to have some notion of sort

1351
00:52:24,650 --> 00:52:28,490
of akin cost I make that decision and

1352
00:52:28,490 --> 00:52:30,680
oftentimes it may have no bearing to

1353
00:52:30,680 --> 00:52:32,870
actually what the data looks like that

1354
00:52:32,870 --> 00:52:36,410
can be tricky the other tricky thing

1355
00:52:36,410 --> 00:52:37,490
about this is that it's going to be

1356
00:52:37,490 --> 00:52:39,260
basically impossible now the generate

1357
00:52:39,260 --> 00:52:42,380
plans when the transformations are

1358
00:52:42,380 --> 00:52:44,480
optimizations you want to apply can have

1359
00:52:44,480 --> 00:52:46,760
dependencies in between them so that

1360
00:52:46,760 --> 00:52:48,950
means I'd like say you you want to I

1361
00:52:48,950 --> 00:52:50,900
wanted to turn I want to apply

1362
00:52:50,900 --> 00:52:54,530
optimization a and based on whether or

1363
00:52:54,530 --> 00:52:57,290
not I choose that optimization I may

1364
00:52:57,290 --> 00:52:58,880
want to may or may not want to choose

1365
00:52:58,880 --> 00:53:00,290
optimization B

1366
00:53:00,290 --> 00:53:04,130
and so now if I if I'm writing this and

1367
00:53:04,130 --> 00:53:06,260
just based rules I have to write that

1368
00:53:06,260 --> 00:53:07,940
explicit rule to know that if I do a

1369
00:53:07,940 --> 00:53:10,430
then don't do B or I do don't do a then

1370
00:53:10,430 --> 00:53:12,200
I can do B I have to write all that

1371
00:53:12,200 --> 00:53:14,510
manually and the source code

1372
00:53:14,510 --> 00:53:16,070
we're in a cost-based search we'll talk

1373
00:53:16,070 --> 00:53:18,110
about it next slide if you write your

1374
00:53:18,110 --> 00:53:20,390
cost model in a crack way you could have

1375
00:53:20,390 --> 00:53:22,930
this search sort of the the search

1376
00:53:22,930 --> 00:53:25,130
engine sort of find that for you

1377
00:53:25,130 --> 00:53:26,360
right and you don't have to code it

1378
00:53:26,360 --> 00:53:28,940
directly so again as I said the

1379
00:53:28,940 --> 00:53:31,280
heuristic based approach is what the

1380
00:53:31,280 --> 00:53:33,280
first two out of the three original

1381
00:53:33,280 --> 00:53:35,120
relational database systems major

1382
00:53:35,120 --> 00:53:36,170
relational database systems that came

1383
00:53:36,170 --> 00:53:39,820
out in the 1970s actually used the other

1384
00:53:39,820 --> 00:53:42,590
sort of famous approach used in 1970s

1385
00:53:42,590 --> 00:53:45,770
was a combination of the heuristics from

1386
00:53:45,770 --> 00:53:48,530
we just talked about plus a call space

1387
00:53:48,530 --> 00:53:51,770
search and this is going to be the

1388
00:53:51,770 --> 00:53:55,490
technique that all the modern optimizers

1389
00:53:55,490 --> 00:53:56,870
that we'll talk about what we will be

1390
00:53:56,870 --> 00:53:59,120
based on they they may not need using

1391
00:53:59,120 --> 00:54:01,340
exactly the approach that IBM system are

1392
00:54:01,340 --> 00:54:03,980
is using but the notion of using the

1393
00:54:03,980 --> 00:54:05,810
cost model to estimate the efficacy or

1394
00:54:05,810 --> 00:54:10,400
the cost of estimate of a plan is is the

1395
00:54:10,400 --> 00:54:12,590
standard push that everyone's use so

1396
00:54:12,590 --> 00:54:13,970
with system or the way it's gonna work

1397
00:54:13,970 --> 00:54:16,460
is they'll have static rules first

1398
00:54:16,460 --> 00:54:18,110
perform some initial optimizations and

1399
00:54:18,110 --> 00:54:20,090
then they'll use a dynamic programming

1400
00:54:20,090 --> 00:54:22,730
method to determine the best joint

1401
00:54:22,730 --> 00:54:26,780
ordering for the tables so I think we

1402
00:54:26,780 --> 00:54:28,370
talked about IBM system are a little bit

1403
00:54:28,370 --> 00:54:31,520
but again Ted Khan was a mathematician

1404
00:54:31,520 --> 00:54:35,360
in New York he wrote these for IBM wrote

1405
00:54:35,360 --> 00:54:39,260
this this this this the far-reaching and

1406
00:54:39,260 --> 00:54:41,600
and very progressive paper on the

1407
00:54:41,600 --> 00:54:44,800
relational model it was all mathematical

1408
00:54:44,800 --> 00:54:47,390
ingress and Burton a nursing at Berkeley

1409
00:54:47,390 --> 00:54:49,190
was was one people group appeal that

1410
00:54:49,190 --> 00:54:50,510
took the paper and try to build system

1411
00:54:50,510 --> 00:54:52,730
IBM trying to build a their own version

1412
00:54:52,730 --> 00:54:55,160
of the system at call system are in his

1413
00:54:55,160 --> 00:54:57,800
San Jose in California and they got a

1414
00:54:57,800 --> 00:55:00,200
bunch of people had PhDs in your brand

1415
00:55:00,200 --> 00:55:01,400
new PCs and computer science mathematics

1416
00:55:01,400 --> 00:55:04,310
put them in a room at IBM Gabe and Ted

1417
00:55:04,310 --> 00:55:05,840
cause paper and says all right go make

1418
00:55:05,840 --> 00:55:08,030
this and so a bunch of people carved off

1419
00:55:08,030 --> 00:55:10,730
different pieces of the problem you know

1420
00:55:10,730 --> 00:55:12,470
one person with a PC went and then its

1421
00:55:12,470 --> 00:55:14,589
sequel another person invented

1422
00:55:14,589 --> 00:55:18,829
storage models or two phase locking Pat

1423
00:55:18,829 --> 00:55:20,960
Salinger was somebody who got assigned

1424
00:55:20,960 --> 00:55:24,170
to work on the query optimizer and it's

1425
00:55:24,170 --> 00:55:27,829
been very very seminal work so this is

1426
00:55:27,829 --> 00:55:29,240
the first example of a call space query

1427
00:55:29,240 --> 00:55:31,970
optimizer it's also an example of using

1428
00:55:31,970 --> 00:55:33,910
bottom-up planning or forward chaining

1429
00:55:33,910 --> 00:55:35,900
explain a few more slides whether it

1430
00:55:35,900 --> 00:55:37,730
actually means but basically it's like

1431
00:55:37,730 --> 00:55:38,930
we're gonna do a divide and conquer

1432
00:55:38,930 --> 00:55:41,390
approach where we're going to start with

1433
00:55:41,390 --> 00:55:44,060
nothing in our query plan and then it

1434
00:55:44,060 --> 00:55:46,460
early build it up to say to produce our

1435
00:55:46,460 --> 00:55:47,630
final result by figuring out what the

1436
00:55:47,630 --> 00:55:50,690
join orders gonna be so as I said system

1437
00:55:50,690 --> 00:55:52,579
R was the first system that used this

1438
00:55:52,579 --> 00:55:55,130
particular invitation the first version

1439
00:55:55,130 --> 00:55:56,869
of db2 that came in the 1980s

1440
00:55:56,869 --> 00:55:58,940
I think borrowed the the query optimizer

1441
00:55:58,940 --> 00:56:01,520
from system R and then most open source

1442
00:56:01,520 --> 00:56:03,200
database systems are gonna be using some

1443
00:56:03,200 --> 00:56:05,990
flavor of the of the the system are

1444
00:56:05,990 --> 00:56:07,790
approached like this is what my sequel

1445
00:56:07,790 --> 00:56:10,819
press press and sequel like use the

1446
00:56:10,819 --> 00:56:12,530
commercial guys usually are having

1447
00:56:12,530 --> 00:56:14,180
something more sophisticated or are

1448
00:56:14,180 --> 00:56:16,790
using Cascades alright so let's go

1449
00:56:16,790 --> 00:56:17,720
through an example what it's actually

1450
00:56:17,720 --> 00:56:19,400
doing so again when a system our

1451
00:56:19,400 --> 00:56:21,770
approach would work is that you'd break

1452
00:56:21,770 --> 00:56:23,930
up the query into blocks and then you

1453
00:56:23,930 --> 00:56:25,760
would have logical operators

1454
00:56:25,760 --> 00:56:27,980
representing each block and then for

1455
00:56:27,980 --> 00:56:29,150
each of these a lot of operators you're

1456
00:56:29,150 --> 00:56:30,980
gonna figure out what are all the

1457
00:56:30,980 --> 00:56:33,170
possible physical operators I could use

1458
00:56:33,170 --> 00:56:35,960
to implement that operator and then

1459
00:56:35,960 --> 00:56:39,560
you're gonna it early construct a query

1460
00:56:39,560 --> 00:56:42,790
plan that has the minimal cost

1461
00:56:42,790 --> 00:56:44,510
essentially you're stitching together

1462
00:56:44,510 --> 00:56:46,099
all the tables you want to access and

1463
00:56:46,099 --> 00:56:48,740
and joins to figure out how to join all

1464
00:56:48,740 --> 00:56:51,470
them and produce the final is all so one

1465
00:56:51,470 --> 00:56:53,329
important observation that IBM made at

1466
00:56:53,329 --> 00:56:55,010
the time was that they were only going

1467
00:56:55,010 --> 00:56:57,890
to pursue left deep join trees so that

1468
00:56:57,890 --> 00:56:59,480
means that like all the joins are sort

1469
00:56:59,480 --> 00:57:01,190
of only on the unless left side of the

1470
00:57:01,190 --> 00:57:03,319
tree going up and contrast this was like

1471
00:57:03,319 --> 00:57:05,060
a bushy tree where you know I can join a

1472
00:57:05,060 --> 00:57:07,430
and B join C and D and take the output

1473
00:57:07,430 --> 00:57:08,510
of those two separate joins and join

1474
00:57:08,510 --> 00:57:10,670
them together this would join a leftie

1475
00:57:10,670 --> 00:57:12,800
tree but join a B first then take the

1476
00:57:12,800 --> 00:57:14,180
output of that and joined C they take

1477
00:57:14,180 --> 00:57:15,470
the output of that and join with T and

1478
00:57:15,470 --> 00:57:17,930
they made this decision to only look

1479
00:57:17,930 --> 00:57:21,859
left D trees purely to minimize reduce

1480
00:57:21,859 --> 00:57:24,319
the search space of the problem all

1481
00:57:24,319 --> 00:57:25,460
right so if you have to go consider

1482
00:57:25,460 --> 00:57:27,550
bushy trees and that um

1483
00:57:27,550 --> 00:57:29,720
there's again that increases the number

1484
00:57:29,720 --> 00:57:32,360
of choices you have to look at and again

1485
00:57:32,360 --> 00:57:33,860
for the hardware they were dealing at

1486
00:57:33,860 --> 00:57:36,050
the time that was deemed too expensive

1487
00:57:36,050 --> 00:57:38,210
sometimes you see this optimization or

1488
00:57:38,210 --> 00:57:41,890
this assumption made in optimizers today

1489
00:57:41,890 --> 00:57:44,720
even though sometimes a bushy plan will

1490
00:57:44,720 --> 00:57:50,390
be preferable will be better it depends

1491
00:57:50,390 --> 00:57:51,860
on the system all right but there's

1492
00:57:51,860 --> 00:57:53,150
there's nothing about the approach I'm

1493
00:57:53,150 --> 00:57:55,010
talking about here today that requires

1494
00:57:55,010 --> 00:57:56,390
you to have the only support leftie

1495
00:57:56,390 --> 00:57:58,820
trees that's just you know show up and

1496
00:57:58,820 --> 00:58:01,520
they took back in the 70s all right so

1497
00:58:01,520 --> 00:58:03,950
let's go back to my my query they had

1498
00:58:03,950 --> 00:58:07,070
before the one difference I'm gonna make

1499
00:58:07,070 --> 00:58:11,000
is that now I'm gonna sort the output of

1500
00:58:11,000 --> 00:58:14,050
this result based on the artist ID right

1501
00:58:14,050 --> 00:58:16,970
so again the first step in this is our

1502
00:58:16,970 --> 00:58:17,960
is that we want to choose the best

1503
00:58:17,960 --> 00:58:20,360
access path for each table so here's all

1504
00:58:20,360 --> 00:58:22,250
the tables that I'm gonna access here's

1505
00:58:22,250 --> 00:58:23,570
all my predicates and I'm gonna pick

1506
00:58:23,570 --> 00:58:26,450
some and with the best access method for

1507
00:58:26,450 --> 00:58:28,550
that so in the case of artisan peers I

1508
00:58:28,550 --> 00:58:33,440
don't have a I don't have a I don't have

1509
00:58:33,440 --> 00:58:35,780
a index I can use so they're doing

1510
00:58:35,780 --> 00:58:38,030
special scans Alamance a has an index on

1511
00:58:38,030 --> 00:58:41,270
the name and we will use that now

1512
00:58:41,270 --> 00:58:43,310
forgive we're gonna numerate all

1513
00:58:43,310 --> 00:58:46,040
possible join our readings for these

1514
00:58:46,040 --> 00:58:49,190
tables again this is just like you know

1515
00:58:49,190 --> 00:58:51,860
a permutation of every possible

1516
00:58:51,860 --> 00:58:55,280
different ordering that my my tables

1517
00:58:55,280 --> 00:58:57,710
could have and I can do joins I can do

1518
00:58:57,710 --> 00:58:59,810
Cartesian products although we can put

1519
00:58:59,810 --> 00:59:01,430
those out later all right

1520
00:59:01,430 --> 00:59:04,700
it's then now for all these possible

1521
00:59:04,700 --> 00:59:07,760
orderings I want to figure out what is

1522
00:59:07,760 --> 00:59:09,560
the one that it's going to have the the

1523
00:59:09,560 --> 00:59:11,780
lowest cost and I need to base that cost

1524
00:59:11,780 --> 00:59:14,990
on what physical operator I'm gonna use

1525
00:59:14,990 --> 00:59:16,400
all right so this is just a logical plan

1526
00:59:16,400 --> 00:59:18,620
I want to join artisan and appear as an

1527
00:59:18,620 --> 00:59:19,070
album

1528
00:59:19,070 --> 00:59:20,330
I'm not saying how to actually do that

1529
00:59:20,330 --> 00:59:22,370
join and this last step here this is

1530
00:59:22,370 --> 00:59:23,390
actually where we want to figure it out

1531
00:59:23,390 --> 00:59:27,230
so system R is a bottom-up approach

1532
00:59:27,230 --> 00:59:29,330
where we're going to start at the bottom

1533
00:59:29,330 --> 00:59:31,790
of the query plan where we don't have

1534
00:59:31,790 --> 00:59:33,380
any information we haven't done any of

1535
00:59:33,380 --> 00:59:34,880
the joins yet we just say we have these

1536
00:59:34,880 --> 00:59:37,760
three tables artist album appears and

1537
00:59:37,760 --> 00:59:39,200
this is this is where we want to get to

1538
00:59:39,200 --> 00:59:39,630
it

1539
00:59:39,630 --> 00:59:41,670
so we want to figure out how do

1540
00:59:41,670 --> 00:59:44,310
communities together to get to this

1541
00:59:44,310 --> 00:59:46,860
final result here right where we joined

1542
00:59:46,860 --> 00:59:49,770
artists appears and how them together so

1543
00:59:49,770 --> 00:59:53,760
we're going to look at a look at all

1544
00:59:53,760 --> 00:59:55,440
possible join our drinks for the first

1545
00:59:55,440 --> 00:59:57,240
stage so I want to take two tables and

1546
00:59:57,240 --> 00:59:59,250
join them together so I can join artisan

1547
00:59:59,250 --> 01:00:01,260
appears Alban appears appears in album

1548
01:00:01,260 --> 01:00:02,700
and then all the other ones that I

1549
01:00:02,700 --> 01:00:04,980
showed in the the last slide I'm

1550
01:00:04,980 --> 01:00:06,060
truncating here because we're out of

1551
01:00:06,060 --> 01:00:08,790
space and then what I have is going out

1552
01:00:08,790 --> 01:00:10,620
I'm emanating from the starting point I

1553
01:00:10,620 --> 01:00:13,770
have a path to get there that's going to

1554
01:00:13,770 --> 01:00:16,500
use a particular physical algorithm all

1555
01:00:16,500 --> 01:00:17,850
right so I could either do a hash join

1556
01:00:17,850 --> 01:00:20,310
to join artisan appears or I can do a

1557
01:00:20,310 --> 01:00:22,200
sort of or join to join artisan peers

1558
01:00:22,200 --> 01:00:24,300
and likewise to join album appears I can

1559
01:00:24,300 --> 01:00:26,070
do a hash join the servers join and so

1560
01:00:26,070 --> 01:00:29,280
forth right but then now for each of

1561
01:00:29,280 --> 01:00:31,620
these different physical physical

1562
01:00:31,620 --> 01:00:33,870
operators I can estimate what is the

1563
01:00:33,870 --> 01:00:37,530
cost of executing it and then I for each

1564
01:00:37,530 --> 01:00:40,290
from going from one node to this I one

1565
01:00:40,290 --> 01:00:44,160
of them select which path to get to that

1566
01:00:44,160 --> 01:00:46,950
node has the lowest cost so let's say

1567
01:00:46,950 --> 01:00:48,510
it's in this case here to go from this

1568
01:00:48,510 --> 01:00:50,280
node to this node the hash join has a

1569
01:00:50,280 --> 01:00:52,200
lower cost same with this one to here

1570
01:00:52,200 --> 01:00:54,270
but this one the sort merge has a lower

1571
01:00:54,270 --> 01:00:57,540
cost then now I want to do the same

1572
01:00:57,540 --> 01:01:00,540
thing starting from the next level of my

1573
01:01:00,540 --> 01:01:04,140
query plan I want to say what physical

1574
01:01:04,140 --> 01:01:06,960
operator could I use to do the last join

1575
01:01:06,960 --> 01:01:09,630
right so again I'm showing a subset here

1576
01:01:09,630 --> 01:01:11,460
I could do a sort most join or hash

1577
01:01:11,460 --> 01:01:13,680
Mahesh has join for these different

1578
01:01:13,680 --> 01:01:16,440
approaches and then now the same thing I

1579
01:01:16,440 --> 01:01:18,870
want to pick which plan on which was

1580
01:01:18,870 --> 01:01:20,970
physical operator from going from one

1581
01:01:20,970 --> 01:01:23,270
node to the next has the lowest cost and

1582
01:01:23,270 --> 01:01:26,130
then now once I have this I backtrack

1583
01:01:26,130 --> 01:01:29,040
and say well what was the path that got

1584
01:01:29,040 --> 01:01:30,780
me from my starting point to my end

1585
01:01:30,780 --> 01:01:32,400
point going through these physical

1586
01:01:32,400 --> 01:01:35,190
operators that that had the lowest cost

1587
01:01:35,190 --> 01:01:37,200
and that's and say that it's doing a

1588
01:01:37,200 --> 01:01:38,580
hash join followed by a hash join and

1589
01:01:38,580 --> 01:01:40,860
that's the one that produces the lowest

1590
01:01:40,860 --> 01:01:42,720
cost amongst all the joins and that's

1591
01:01:42,720 --> 01:01:45,210
the one I want to use right again the

1592
01:01:45,210 --> 01:01:46,470
divide-and-conquer because rather than

1593
01:01:46,470 --> 01:01:51,510
looking at you know complete pass you

1594
01:01:51,510 --> 01:01:53,610
know you know from here to here

1595
01:01:53,610 --> 01:01:55,350
but in order to estimate the cost I'm

1596
01:01:55,350 --> 01:01:57,090
only going from one stage of the next

1597
01:01:57,090 --> 01:01:58,800
and then once I figure that out then I

1598
01:01:58,800 --> 01:02:00,120
go to the next stage and then combine it

1599
01:02:00,120 --> 01:02:04,230
together that produces the result so but

1600
01:02:04,230 --> 01:02:06,510
this particular query though remember

1601
01:02:06,510 --> 01:02:10,440
that I've added the order by so so now I

1602
01:02:10,440 --> 01:02:13,170
care about the what's the sort order of

1603
01:02:13,170 --> 01:02:16,290
the output after I join them but there's

1604
01:02:16,290 --> 01:02:18,840
nothing in this in this plan that I've

1605
01:02:18,840 --> 01:02:22,560
generated here that tells me what what

1606
01:02:22,560 --> 01:02:24,990
that sort order could be right and this

1607
01:02:24,990 --> 01:02:28,830
is because at least how system are was

1608
01:02:28,830 --> 01:02:33,480
sort of set up there's no notion of the

1609
01:02:33,480 --> 01:02:36,090
the physical properties or the sort

1610
01:02:36,090 --> 01:02:39,300
order of the the data that I wanted so

1611
01:02:39,300 --> 01:02:42,030
in this case here I'm doing hash joins

1612
01:02:42,030 --> 01:02:44,520
and that means that the data is going to

1613
01:02:44,520 --> 01:02:46,410
be random in a random sort order and

1614
01:02:46,410 --> 01:02:49,230
then I need to now execute an order by a

1615
01:02:49,230 --> 01:02:51,480
sort of sort operator to put the data

1616
01:02:51,480 --> 01:02:53,970
into the physical order that I want but

1617
01:02:53,970 --> 01:02:57,510
going back here if I had known that I

1618
01:02:57,510 --> 01:02:59,040
needed this day to be sort of a certain

1619
01:02:59,040 --> 01:03:01,530
way then maybe I would have chose a sort

1620
01:03:01,530 --> 01:03:03,540
servers join because that would have

1621
01:03:03,540 --> 01:03:04,710
given you two for one I would have give

1622
01:03:04,710 --> 01:03:06,510
me either do the join plus put the data

1623
01:03:06,510 --> 01:03:08,940
sort it in a way that I wanted it right

1624
01:03:08,940 --> 01:03:11,340
but because the way this is set up

1625
01:03:11,340 --> 01:03:13,320
there's nothing about the physical

1626
01:03:13,320 --> 01:03:14,640
property the data that it can make

1627
01:03:14,640 --> 01:03:17,100
helping make this decision so that's

1628
01:03:17,100 --> 01:03:18,390
actually want to be the limitations

1629
01:03:18,390 --> 01:03:19,980
we'll see what system are and we'll see

1630
01:03:19,980 --> 01:03:23,040
how what we can fix this up in in the

1631
01:03:23,040 --> 01:03:25,640
stratified or unified searches later on

1632
01:03:25,640 --> 01:03:31,830
the yeah so the way system are a few got

1633
01:03:31,830 --> 01:03:33,270
around this was that they would actually

1634
01:03:33,270 --> 01:03:35,130
have to bake in the cost model itself

1635
01:03:35,130 --> 01:03:37,560
some notion of the sort order that they

1636
01:03:37,560 --> 01:03:39,660
wanted dated to be in so that they can

1637
01:03:39,660 --> 01:03:41,580
then identify that the SIRT merge was

1638
01:03:41,580 --> 01:03:44,190
preferable to the to the hash join them

1639
01:03:44,190 --> 01:03:45,960
and for this particular example but that

1640
01:03:45,960 --> 01:03:47,400
was you know that's sort of a half right

1641
01:03:47,400 --> 01:03:49,140
because now you're there's logical what

1642
01:03:49,140 --> 01:03:51,660
the data should look like is in the in

1643
01:03:51,660 --> 01:03:53,850
the cost model and then it's sort of

1644
01:03:53,850 --> 01:03:55,740
separate from the actual the the search

1645
01:03:55,740 --> 01:03:58,530
strategy itself so that's an issue

1646
01:03:58,530 --> 01:04:00,810
so I briefly want to touch on this

1647
01:04:00,810 --> 01:04:02,730
distinction between the the bottom up

1648
01:04:02,730 --> 01:04:05,130
and the top down so again what butters

1649
01:04:05,130 --> 01:04:06,600
showed you was considered a bottom up

1650
01:04:06,600 --> 01:04:07,140
query options

1651
01:04:07,140 --> 01:04:09,450
strategy it's where you start with

1652
01:04:09,450 --> 01:04:11,370
nothing then you build a plan up to get

1653
01:04:11,370 --> 01:04:13,680
to the output that you want so system R

1654
01:04:13,680 --> 01:04:17,070
and IBM starbursts became later on these

1655
01:04:17,070 --> 01:04:19,800
are examples of bottom-up approaches the

1656
01:04:19,800 --> 01:04:21,570
dynamic approaching will see an hyper

1657
01:04:21,570 --> 01:04:23,580
this is also considered a bottom-up

1658
01:04:23,580 --> 01:04:28,950
approach the fee current feeling from

1659
01:04:28,950 --> 01:04:31,980
the the research community is that this

1660
01:04:31,980 --> 01:04:35,220
approach is better for figuring out the

1661
01:04:35,220 --> 01:04:39,870
joint ordering the alternative is the

1662
01:04:39,870 --> 01:04:41,550
top-down approach is what we use in our

1663
01:04:41,550 --> 01:04:43,710
system based on Cascades and this is

1664
01:04:43,710 --> 01:04:44,940
where you start with the outcome that

1665
01:04:44,940 --> 01:04:48,210
you want and then you work down the into

1666
01:04:48,210 --> 01:04:50,430
the QWERTY plan and you start adding in

1667
01:04:50,430 --> 01:04:52,500
physical operators to essentially

1668
01:04:52,500 --> 01:04:54,480
reverse the steps to get back get you

1669
01:04:54,480 --> 01:04:56,640
back from where the goal you need it

1670
01:04:56,640 --> 01:04:59,610
so again volcano was what canaan Exodus

1671
01:04:59,610 --> 01:05:02,310
came from the same data to Cascades

1672
01:05:02,310 --> 01:05:03,750
Cascades is considered the modern

1673
01:05:03,750 --> 01:05:07,710
implication of this so we'll cover this

1674
01:05:07,710 --> 01:05:09,810
I will cover this furthermore I think in

1675
01:05:09,810 --> 01:05:13,410
next class I don't say too much but like

1676
01:05:13,410 --> 01:05:15,780
this is what sequel server and cockroach

1677
01:05:15,780 --> 01:05:18,420
DB used is what our system uses a bunch

1678
01:05:18,420 --> 01:05:19,590
of other systems use this so this is

1679
01:05:19,590 --> 01:05:22,260
sort of like again the the hash join

1680
01:05:22,260 --> 01:05:24,570
versus certain rejoin debate in for

1681
01:05:24,570 --> 01:05:26,610
joint algorithms for databases this is

1682
01:05:26,610 --> 01:05:27,630
sort of the same thing if you care about

1683
01:05:27,630 --> 01:05:29,010
query optimizer this is sort of the same

1684
01:05:29,010 --> 01:05:33,240
debate people can have okay so let's

1685
01:05:33,240 --> 01:05:34,800
talk about what Postgres does a little

1686
01:05:34,800 --> 01:05:36,990
bit so Postgres actually does what this

1687
01:05:36,990 --> 01:05:40,710
is system our approach is for like it

1688
01:05:40,710 --> 01:05:42,450
usually this is the case right we'll

1689
01:05:42,450 --> 01:05:44,130
talk about their other query optimizer

1690
01:05:44,130 --> 01:05:46,080
in a second but if you come along if you

1691
01:05:46,080 --> 01:05:47,760
have a query and Postgres that only

1692
01:05:47,760 --> 01:05:51,000
joins 12 tables then this is what you

1693
01:05:51,000 --> 01:05:53,400
get if you have 13 or more tables and

1694
01:05:53,400 --> 01:05:54,720
you get this genetic algorithm which

1695
01:05:54,720 --> 01:05:56,100
we'll talk about a few more slides but

1696
01:05:56,100 --> 01:05:58,860
the way it works is that they had this

1697
01:05:58,860 --> 01:06:00,750
rewriting phase that has all the static

1698
01:06:00,750 --> 01:06:02,520
rules that we talked about that can do

1699
01:06:02,520 --> 01:06:04,440
some initial rewriting or optimizations

1700
01:06:04,440 --> 01:06:06,990
on on the on the query planner then they

1701
01:06:06,990 --> 01:06:10,770
throw it into a cost-based search model

1702
01:06:10,770 --> 01:06:12,360
using the bottom-up approach the same

1703
01:06:12,360 --> 01:06:14,580
one as a system are to figure out the

1704
01:06:14,580 --> 01:06:17,070
joint owner ring then after that they go

1705
01:06:17,070 --> 01:06:20,160
back and add on the idea

1706
01:06:20,160 --> 01:06:21,660
the remaining things that are missing in

1707
01:06:21,660 --> 01:06:24,089
the query plan so these would be things

1708
01:06:24,089 --> 01:06:26,160
like the sort order or any kind of

1709
01:06:26,160 --> 01:06:27,270
aggregations you would have to have

1710
01:06:27,270 --> 01:06:32,549
right so the the and then you do the

1711
01:06:32,549 --> 01:06:34,170
same thing but you just recursively do

1712
01:06:34,170 --> 01:06:38,960
the same steps for any sub queries so

1713
01:06:38,960 --> 01:06:41,760
the Postgres is phenomenal I think the

1714
01:06:41,760 --> 01:06:43,130
postal code is actually one of those

1715
01:06:43,130 --> 01:06:45,539
beautiful database system source code

1716
01:06:45,539 --> 01:06:49,440
I've ever seen even least anyone written

1717
01:06:49,440 --> 01:06:53,579
in C the query optimizer is sort of like

1718
01:06:53,579 --> 01:06:55,470
the in my opinion at least one lesson it

1719
01:06:55,470 --> 01:06:57,000
looks at it a few years ago is one of

1720
01:06:57,000 --> 01:06:59,579
the dark corners of the system and so

1721
01:06:59,579 --> 01:07:04,260
the it's it's I've been told this is

1722
01:07:04,260 --> 01:07:06,869
very brittle because you implicitly have

1723
01:07:06,869 --> 01:07:08,130
in the source code for like is rewriting

1724
01:07:08,130 --> 01:07:10,410
phase steps that like you basically

1725
01:07:10,410 --> 01:07:12,059
bacon the source code assumptions about

1726
01:07:12,059 --> 01:07:13,859
what the output of that data needs to

1727
01:07:13,859 --> 01:07:15,660
look like if according to look like in

1728
01:07:15,660 --> 01:07:18,599
order for it to be then fed into the the

1729
01:07:18,599 --> 01:07:19,980
next set of you know heuristic

1730
01:07:19,980 --> 01:07:21,030
transformations that you're actually

1731
01:07:21,030 --> 01:07:23,250
doing so if you change sort of some

1732
01:07:23,250 --> 01:07:25,829
assumption you you have about what the

1733
01:07:25,829 --> 01:07:28,109
the next stage expects that the query

1734
01:07:28,109 --> 01:07:29,760
plan will look like if you somehow there

1735
01:07:29,760 --> 01:07:31,500
the query plan you're generating or

1736
01:07:31,500 --> 01:07:34,140
produce is now different then that can

1737
01:07:34,140 --> 01:07:36,660
break everything everything else and

1738
01:07:36,660 --> 01:07:38,579
this is sort of why I like the Cascades

1739
01:07:38,579 --> 01:07:39,839
or unified approach we'll talk about a

1740
01:07:39,839 --> 01:07:41,670
second because you declare all your

1741
01:07:41,670 --> 01:07:43,079
rules you declare your transformations

1742
01:07:43,079 --> 01:07:44,640
and the physical properties you expect

1743
01:07:44,640 --> 01:07:47,579
the query plan to to maintain and then

1744
01:07:47,579 --> 01:07:49,079
you just throw them the engine and let

1745
01:07:49,079 --> 01:07:50,250
it let it figure it out for you and for

1746
01:07:50,250 --> 01:07:51,599
in the force is all these things for you

1747
01:07:51,599 --> 01:07:54,450
whereas this one it's it's you happen to

1748
01:07:54,450 --> 01:07:56,010
understand what that you know in order

1749
01:07:56,010 --> 01:07:57,599
to modify anything you'd understand you

1750
01:07:57,599 --> 01:07:58,799
know everything step what's actually

1751
01:07:58,799 --> 01:08:05,039
happening alright so so again advantage

1752
01:08:05,039 --> 01:08:06,539
the disadvantages of the system are

1753
01:08:06,539 --> 01:08:09,059
approach so the advantage is that it

1754
01:08:09,059 --> 01:08:12,660
usually finds a reasonable plan at least

1755
01:08:12,660 --> 01:08:16,109
for joining for a moderate-sized nor

1756
01:08:16,109 --> 01:08:18,899
joins our number tables in a reasonable

1757
01:08:18,899 --> 01:08:20,729
out of time without having to do it it's

1758
01:08:20,729 --> 01:08:24,238
also search the downside is that you're

1759
01:08:24,238 --> 01:08:25,469
gonna have all the same problems you had

1760
01:08:25,469 --> 01:08:26,850
in the heuristic only approach because

1761
01:08:26,850 --> 01:08:28,198
that's the first step you're applying

1762
01:08:28,198 --> 01:08:30,198
before you go into it and do the search

1763
01:08:30,198 --> 01:08:32,460
this is only really limitation for

1764
01:08:32,460 --> 01:08:33,899
system are that they they're limited

1765
01:08:33,899 --> 01:08:36,960
- left deep trees modern systems I don't

1766
01:08:36,960 --> 01:08:39,870
think have that issue and then in the

1767
01:08:39,870 --> 01:08:41,460
example I showed before where you need

1768
01:08:41,460 --> 01:08:44,040
to have the cost model be aware of what

1769
01:08:44,040 --> 01:08:46,589
your data needs to look like if you have

1770
01:08:46,589 --> 01:08:49,198
sort orders or compression and other

1771
01:08:49,198 --> 01:08:51,149
properties on the data you got to bake

1772
01:08:51,149 --> 01:08:52,469
that into the cost model cuz the search

1773
01:08:52,469 --> 01:08:54,770
I'll go myself is can't can't force that

1774
01:08:54,770 --> 01:08:59,130
so this last one is the worst part this

1775
01:08:59,130 --> 01:09:00,929
is this is this is the major limitation

1776
01:09:00,929 --> 01:09:02,219
you're gonna have using this tomorrow

1777
01:09:02,219 --> 01:09:05,370
system our approach of using the cost

1778
01:09:05,370 --> 01:09:06,630
model to enforce physical properties

1779
01:09:06,630 --> 01:09:08,370
right that I think again I think this

1780
01:09:08,370 --> 01:09:09,870
makes it the from engineering standpoint

1781
01:09:09,870 --> 01:09:14,698
this is problematic so before we get

1782
01:09:14,698 --> 01:09:19,948
into the sort of the modern query

1783
01:09:19,948 --> 01:09:21,839
optimizer implementations I want to talk

1784
01:09:21,839 --> 01:09:25,080
about a another class optimizers that

1785
01:09:25,080 --> 01:09:27,120
are using randomized algorithms this is

1786
01:09:27,120 --> 01:09:28,920
another way to think about the the

1787
01:09:28,920 --> 01:09:30,359
problem we're trying to solve in the

1788
01:09:30,359 --> 01:09:32,609
quarry optimizer so the idea of the

1789
01:09:32,609 --> 01:09:34,679
randomized amalgam is that rather than

1790
01:09:34,679 --> 01:09:37,620
doing this this sort of branch of

1791
01:09:37,620 --> 01:09:40,109
balanced search looking for a better

1792
01:09:40,109 --> 01:09:42,750
better query plan we're just gonna take

1793
01:09:42,750 --> 01:09:47,339
our query plan and do random

1794
01:09:47,339 --> 01:09:49,770
permutations on it and just do a random

1795
01:09:49,770 --> 01:09:53,219
walk of all possible valid query plans

1796
01:09:53,219 --> 01:09:54,810
and then if we just haven't a

1797
01:09:54,810 --> 01:09:56,190
StumbleUpon one that's actually better

1798
01:09:56,190 --> 01:09:58,610
then that's the one we'll end up using

1799
01:09:58,610 --> 01:10:01,320
right and so for this one this is where

1800
01:10:01,320 --> 01:10:03,000
you actually need that threshold it's

1801
01:10:03,000 --> 01:10:04,800
like a time threshold today it'll say

1802
01:10:04,800 --> 01:10:06,750
I've searched long enough I know I know

1803
01:10:06,750 --> 01:10:08,340
when to stop because otherwise this

1804
01:10:08,340 --> 01:10:10,710
thing will just run forever so an

1805
01:10:10,710 --> 01:10:12,330
example of this will be Postgres to the

1806
01:10:12,330 --> 01:10:14,250
genetic algorithm which is actually in

1807
01:10:14,250 --> 01:10:16,080
the real system today we'll talk about

1808
01:10:16,080 --> 01:10:17,730
the next live but let's before that

1809
01:10:17,730 --> 01:10:19,890
there was an implementation using

1810
01:10:19,890 --> 01:10:22,230
simulated annealing so this is back in

1811
01:10:22,230 --> 01:10:24,600
like 1987 as far as in it far as I know

1812
01:10:24,600 --> 01:10:26,040
this F never actually made it into a

1813
01:10:26,040 --> 01:10:29,790
real system the basic idea is that you

1814
01:10:29,790 --> 01:10:30,810
show in your query plan that you

1815
01:10:30,810 --> 01:10:33,540
generate using the - the heuristic based

1816
01:10:33,540 --> 01:10:34,560
approach we talked about in the

1817
01:10:34,560 --> 01:10:37,199
beginning and then now you just do

1818
01:10:37,199 --> 01:10:39,210
random permutations of operators in the

1819
01:10:39,210 --> 01:10:41,730
query plan like swapping the joint or

1820
01:10:41,730 --> 01:10:44,580
two tables and then you estimate the

1821
01:10:44,580 --> 01:10:46,610
cost of that of

1822
01:10:46,610 --> 01:10:49,670
change of that new query plan and if

1823
01:10:49,670 --> 01:10:51,949
it's better than you just accept the

1824
01:10:51,949 --> 01:10:54,650
change if it's worse then you flip a

1825
01:10:54,650 --> 01:10:56,239
weighted coin to decide whether you want

1826
01:10:56,239 --> 01:10:59,630
to keep it or not and then the idea here

1827
01:10:59,630 --> 01:11:01,280
is that every so often you'll get up

1828
01:11:01,280 --> 01:11:04,840
you'll get a by accepting a change

1829
01:11:04,840 --> 01:11:06,710
accepting a new plan that actually made

1830
01:11:06,710 --> 01:11:08,270
things worse

1831
01:11:08,270 --> 01:11:10,400
this allows you to potentially break out

1832
01:11:10,400 --> 01:11:12,320
of local minimums and then find that the

1833
01:11:12,320 --> 01:11:15,619
the true you know the true optimum so

1834
01:11:15,619 --> 01:11:17,719
the tricky thing about this though is

1835
01:11:17,719 --> 01:11:21,710
that you have to write rules that make

1836
01:11:21,710 --> 01:11:24,710
sure you enforce any the the correctness

1837
01:11:24,710 --> 01:11:27,800
of the query plan so that you don't end

1838
01:11:27,800 --> 01:11:30,560
up producing you know incorrect results

1839
01:11:30,560 --> 01:11:35,210
so like if my if my data needs to be

1840
01:11:35,210 --> 01:11:38,659
sorted and I randomly permute the query

1841
01:11:38,659 --> 01:11:41,119
plan by putting the sort the order by

1842
01:11:41,119 --> 01:11:44,810
operator before the hash join and then

1843
01:11:44,810 --> 01:11:46,639
now my outputs not gonna be sorted I'm

1844
01:11:46,639 --> 01:11:48,260
gonna end up with incorrect results so

1845
01:11:48,260 --> 01:11:49,820
you have to either write all these rules

1846
01:11:49,820 --> 01:11:51,920
to make sure that this happens correctly

1847
01:11:51,920 --> 01:11:54,320
which can be tricky is there's a lot of

1848
01:11:54,320 --> 01:11:59,270
corner cases an example of a randomized

1849
01:11:59,270 --> 01:12:00,619
algorithm that is actually used in

1850
01:12:00,619 --> 01:12:02,210
production is the Postgres genetic

1851
01:12:02,210 --> 01:12:04,550
optimizer so again the way this works is

1852
01:12:04,550 --> 01:12:07,010
that if you use the system our approach

1853
01:12:07,010 --> 01:12:09,170
we talked about before if your query has

1854
01:12:09,170 --> 01:12:11,780
12 tables if you try to join 13 or more

1855
01:12:11,780 --> 01:12:14,210
then you get this one you can turn this

1856
01:12:14,210 --> 01:12:15,560
on and off there's a thresher let's say

1857
01:12:15,560 --> 01:12:16,699
when this actually kicks in but by

1858
01:12:16,699 --> 01:12:18,170
default I think it's I think it's 13

1859
01:12:18,170 --> 01:12:20,960
tables so they're gonna use a genetic

1860
01:12:20,960 --> 01:12:23,179
algorithm where at the beginning of

1861
01:12:23,179 --> 01:12:24,679
every round they're gonna generate a

1862
01:12:24,679 --> 01:12:27,100
bunch of different permutations or

1863
01:12:27,100 --> 01:12:31,010
random variations of the query plan then

1864
01:12:31,010 --> 01:12:32,570
they're gonna cook generate castmate the

1865
01:12:32,570 --> 01:12:35,480
cost of all those permutations and then

1866
01:12:35,480 --> 01:12:37,400
they'll pick some number of ones that

1867
01:12:37,400 --> 01:12:39,560
have the lowest cost as the ones to

1868
01:12:39,560 --> 01:12:42,889
propagate from one you know foot to the

1869
01:12:42,889 --> 01:12:45,199
next generation and then you have some

1870
01:12:45,199 --> 01:12:46,820
mutator function to flip around or

1871
01:12:46,820 --> 01:12:49,760
randomly permute the the best plans like

1872
01:12:49,760 --> 01:12:50,960
the idea is like you're getting genes

1873
01:12:50,960 --> 01:12:53,239
from the best plans and hopefully

1874
01:12:53,239 --> 01:12:55,130
producing offspring that produce even

1875
01:12:55,130 --> 01:12:57,739
better plans so visually it looks like

1876
01:12:57,739 --> 01:13:00,199
this so let's say that we in our first

1877
01:13:00,199 --> 01:13:02,869
raishin for a symbol say three table

1878
01:13:02,869 --> 01:13:05,869
join we can estimate the cost of EQ DS

1879
01:13:05,869 --> 01:13:08,300
and say this one ends up being the

1880
01:13:08,300 --> 01:13:10,729
lowest cost so we update our lowest cost

1881
01:13:10,729 --> 01:13:13,639
flag over here and then we're gonna

1882
01:13:13,639 --> 01:13:16,699
randomly permute aspects of this we feed

1883
01:13:16,699 --> 01:13:17,959
that over to this one and we kill off

1884
01:13:17,959 --> 01:13:20,090
this one and then now same thing we

1885
01:13:20,090 --> 01:13:21,349
estimate the cost find the one that has

1886
01:13:21,349 --> 01:13:23,239
a lowest cost this in this case here

1887
01:13:23,239 --> 01:13:24,650
this one is lower than this one so

1888
01:13:24,650 --> 01:13:25,849
that's our new best one we've ever seen

1889
01:13:25,849 --> 01:13:28,099
pick these keep these two guys around

1890
01:13:28,099 --> 01:13:29,869
flip some stuff and generate a new

1891
01:13:29,869 --> 01:13:30,800
clause like that and we just keep going

1892
01:13:30,800 --> 01:13:33,499
on over and over again until we find

1893
01:13:33,499 --> 01:13:36,999
until we run out and running out of time

1894
01:13:37,719 --> 01:13:40,909
so what are the advantages of this well

1895
01:13:40,909 --> 01:13:42,440
jumping around and random locations

1896
01:13:42,440 --> 01:13:43,880
allows us to get our local minimums and

1897
01:13:43,880 --> 01:13:48,559
potentially we can find a better plan to

1898
01:13:48,559 --> 01:13:50,179
the best my knowledge I've not seen any

1899
01:13:50,179 --> 01:13:53,539
detailed analysis or experiments about

1900
01:13:53,539 --> 01:13:55,760
how good the Postgres genetic optimizer

1901
01:13:55,760 --> 01:13:58,159
actually is compared to you know letting

1902
01:13:58,159 --> 01:14:00,309
the the regular optimizer run for longer

1903
01:14:00,309 --> 01:14:02,869
we also have low memory overhead for

1904
01:14:02,869 --> 01:14:05,300
doing the search because if we don't

1905
01:14:05,300 --> 01:14:07,610
need to maintain the history of one

1906
01:14:07,610 --> 01:14:09,499
generation to the next source of our

1907
01:14:09,499 --> 01:14:13,309
random walk then the you know the the

1908
01:14:13,309 --> 01:14:14,840
the memory footprint is just whatever we

1909
01:14:14,840 --> 01:14:15,800
use that you know whatever we're using

1910
01:14:15,800 --> 01:14:19,070
for that back current round the dance

1911
01:14:19,070 --> 01:14:21,380
advantages of though is that unless we

1912
01:14:21,380 --> 01:14:23,539
do extra work to make sure that the

1913
01:14:23,539 --> 01:14:26,959
randomness is deterministic we could end

1914
01:14:26,959 --> 01:14:29,869
up with you know a system that's

1915
01:14:29,869 --> 01:14:33,920
difficult to debug to determine why one

1916
01:14:33,920 --> 01:14:36,559
you know why the Davidson is why the

1917
01:14:36,559 --> 01:14:38,150
data some squares up matters decided to

1918
01:14:38,150 --> 01:14:40,369
use one plan versus another in the case

1919
01:14:40,369 --> 01:14:42,679
of Postgres they always make sure that

1920
01:14:42,679 --> 01:14:46,459
the the random seed is consistent for a

1921
01:14:46,459 --> 01:14:47,959
given query so if i've run the query

1922
01:14:47,959 --> 01:14:49,429
today through the genetic optimizer and

1923
01:14:49,429 --> 01:14:51,590
I run it tomorrow the same query

1924
01:14:51,590 --> 01:14:55,070
I'll always produce the same plan and we

1925
01:14:55,070 --> 01:14:56,570
still also have to still maintain any

1926
01:14:56,570 --> 01:14:58,249
correctness rules to make sure that we

1927
01:14:58,249 --> 01:15:01,309
don't do any mutations that end up with

1928
01:15:01,309 --> 01:15:04,849
an invalid query ok so we're going a bit

1929
01:15:04,849 --> 01:15:07,400
long here but this is good stuff I enjoy

1930
01:15:07,400 --> 01:15:12,590
it so the one observation we can make is

1931
01:15:12,590 --> 01:15:13,949
that everything we talked about so far

1932
01:15:13,949 --> 01:15:18,330
is you know mostly you can imagine

1933
01:15:18,330 --> 01:15:20,160
writing all these transformation rules

1934
01:15:20,160 --> 01:15:23,280
and these algorithms in a procedural

1935
01:15:23,280 --> 01:15:27,540
language like C or C++ and this is

1936
01:15:27,540 --> 01:15:30,449
tricky to do because there's no way to

1937
01:15:30,449 --> 01:15:35,429
verify precisely or through formal

1938
01:15:35,429 --> 01:15:39,210
methods that the the transformations

1939
01:15:39,210 --> 01:15:42,449
that were applying are correct that

1940
01:15:42,449 --> 01:15:44,460
we're guarantee sure that when we do a

1941
01:15:44,460 --> 01:15:46,020
transformation from one query plan to

1942
01:15:46,020 --> 01:15:49,980
the next that you know those two

1943
01:15:49,980 --> 01:15:51,510
algebraic expressions are actually

1944
01:15:51,510 --> 01:15:55,320
equivalent right so we could try to

1945
01:15:55,320 --> 01:15:57,600
verify this by running lots of fuzz

1946
01:15:57,600 --> 01:15:58,949
tests with random queries and just

1947
01:15:58,949 --> 01:16:00,179
checking that the output is the correct

1948
01:16:00,179 --> 01:16:02,310
but of course this is like trying you're

1949
01:16:02,310 --> 01:16:04,199
trying to prove a negative which is not

1950
01:16:04,199 --> 01:16:07,980
easy to do so actually let me let it lit

1951
01:16:07,980 --> 01:16:10,710
up the tear one sec

1952
01:16:10,710 --> 01:16:13,170
so a better push to doing this would be

1953
01:16:13,170 --> 01:16:18,000
if we could have a way to declare what

1954
01:16:18,000 --> 01:16:21,630
our transformation rules are through

1955
01:16:21,630 --> 01:16:24,200
like a high-level language or DSL and

1956
01:16:24,200 --> 01:16:27,540
then we can have we could feed this into

1957
01:16:27,540 --> 01:16:29,880
an optimizer engine who could then

1958
01:16:29,880 --> 01:16:32,040
generate the code or apply these rules

1959
01:16:32,040 --> 01:16:35,880
for us so that way now through these

1960
01:16:35,880 --> 01:16:37,739
declared is declarative rule rule rule

1961
01:16:37,739 --> 01:16:41,489
set we can then do our verification or

1962
01:16:41,489 --> 01:16:42,810
analysis on those rules to determine

1963
01:16:42,810 --> 01:16:44,880
that they are correct and the long as we

1964
01:16:44,880 --> 01:16:46,770
you know we're reasonably sure that our

1965
01:16:46,770 --> 01:16:48,600
rule engine is correct to execute them

1966
01:16:48,600 --> 01:16:50,130
we would know that we're always doing

1967
01:16:50,130 --> 01:16:51,660
transformations that are that are that

1968
01:16:51,660 --> 01:16:58,230
are that are valid so this was the this

1969
01:16:58,230 --> 01:17:00,780
was the movement in the late 1980s early

1970
01:17:00,780 --> 01:17:03,120
1990s to develop what are called

1971
01:17:03,120 --> 01:17:05,640
optimizer generators and think of these

1972
01:17:05,640 --> 01:17:08,040
are like as a framework that allows a

1973
01:17:08,040 --> 01:17:10,710
data system developer to declare the

1974
01:17:10,710 --> 01:17:12,870
rules throw transforming queries to

1975
01:17:12,870 --> 01:17:16,860
generate optimal plans and then this

1976
01:17:16,860 --> 01:17:18,660
this would all be separate from the

1977
01:17:18,660 --> 01:17:19,980
search strategy that we talked about

1978
01:17:19,980 --> 01:17:22,560
before right these are like you know do

1979
01:17:22,560 --> 01:17:23,880
predicate push down you declare a rule

1980
01:17:23,880 --> 01:17:25,380
to do that so no matter whether we were

1981
01:17:25,380 --> 01:17:28,230
doing heuristics or a like the system

1982
01:17:28,230 --> 01:17:30,480
our search we could be guaranteed that

1983
01:17:30,480 --> 01:17:33,150
we we would we produce that that

1984
01:17:33,150 --> 01:17:37,040
transformation correctly all right so

1985
01:17:37,040 --> 01:17:42,570
the first example of of this type of

1986
01:17:42,570 --> 01:17:45,469
optimizer was in the starburst system

1987
01:17:45,469 --> 01:17:47,880
Exodus was another first for a famous

1988
01:17:47,880 --> 01:17:50,370
one this is what IBM this was an

1989
01:17:50,370 --> 01:17:52,580
academic system and then there's been

1990
01:17:52,580 --> 01:17:56,040
some variations improvements from the

1991
01:17:56,040 --> 01:17:58,380
guy that Exodus of volcanoes cascades up

1992
01:17:58,380 --> 01:18:01,020
plus plaus was at Wisconsin Columbia was

1993
01:18:01,020 --> 01:18:03,360
another one at query optimizer in the

1994
01:18:03,360 --> 01:18:05,820
late 1990s at a Portland since then

1995
01:18:05,820 --> 01:18:07,530
there really hasn't been that much

1996
01:18:07,530 --> 01:18:10,469
research in this kind of optimizer

1997
01:18:10,469 --> 01:18:14,310
generators and they're primarily what

1998
01:18:14,310 --> 01:18:16,080
people use today is based on this work

1999
01:18:16,080 --> 01:18:20,010
done in the 1990s so we'll go a little

2000
01:18:20,010 --> 01:18:23,300
more detail about strawberry AIDS

2001
01:18:23,300 --> 01:18:24,949
in necklace but I'll briefly talk about

2002
01:18:24,949 --> 01:18:30,559
it just for them right now so the these

2003
01:18:30,559 --> 01:18:32,989
optimizer generators again they had this

2004
01:18:32,989 --> 01:18:34,760
wool engine that allows you to apply

2005
01:18:34,760 --> 01:18:37,249
these transformations and then you can

2006
01:18:37,249 --> 01:18:39,619
declare in the rule what physical

2007
01:18:39,619 --> 01:18:41,749
properties you wanted the operator to

2008
01:18:41,749 --> 01:18:43,219
enforce on the data that a better was

2009
01:18:43,219 --> 01:18:45,019
processing like the sort order example

2010
01:18:45,019 --> 01:18:47,959
that I showed before but now the

2011
01:18:47,959 --> 01:18:49,610
question is how we're actually going to

2012
01:18:49,610 --> 01:18:52,519
do you know apply these transformations

2013
01:18:52,519 --> 01:18:55,269
and do the search for the optimal plan

2014
01:18:55,269 --> 01:18:57,709
so the two approaches that are the do

2015
01:18:57,709 --> 01:18:59,809
stratified search of unified search so

2016
01:18:59,809 --> 01:19:01,639
stratified search is essentially what I

2017
01:19:01,639 --> 01:19:03,349
said the IBM where the system our

2018
01:19:03,349 --> 01:19:05,300
approach was where I can apply my

2019
01:19:05,300 --> 01:19:07,010
transformation and using heuristics

2020
01:19:07,010 --> 01:19:09,860
without a cost model first then I take

2021
01:19:09,860 --> 01:19:12,380
that out take that query plan and run it

2022
01:19:12,380 --> 01:19:13,579
through a search model that could then

2023
01:19:13,579 --> 01:19:16,090
find me the best drawing ordering a

2024
01:19:16,090 --> 01:19:18,679
unified searches where we're doing all

2025
01:19:18,679 --> 01:19:20,479
aspects of the query plan planning at

2026
01:19:20,479 --> 01:19:22,010
once so the transformations for doing

2027
01:19:22,010 --> 01:19:23,300
predicate push downs and all the sort of

2028
01:19:23,300 --> 01:19:26,150
those static rules if you will they're

2029
01:19:26,150 --> 01:19:29,269
done at the same time in the same search

2030
01:19:29,269 --> 01:19:32,269
space as you do figure out the best

2031
01:19:32,269 --> 01:19:35,749
joint odor so let start with the first

2032
01:19:35,749 --> 01:19:38,119
one so again the stratified search is we

2033
01:19:38,119 --> 01:19:41,539
first rewrite the logical plan using all

2034
01:19:41,539 --> 01:19:42,889
the transformation rules so you go from

2035
01:19:42,889 --> 01:19:44,809
a logical plan into a logical plan again

2036
01:19:44,809 --> 01:19:46,550
this is the same thing they were doing

2037
01:19:46,550 --> 01:19:48,920
in the here's to base approach and so

2038
01:19:48,920 --> 01:19:50,300
this rule engines gonna check to see

2039
01:19:50,300 --> 01:19:52,519
whether the transformation you want to

2040
01:19:52,519 --> 01:19:54,590
do is even allowed before it actually

2041
01:19:54,590 --> 01:19:56,119
applies this this make sure that you

2042
01:19:56,119 --> 01:19:58,369
don't end up with a invalid query plan

2043
01:19:58,369 --> 01:20:00,709
at stake so there's no cost model for

2044
01:20:00,709 --> 01:20:02,840
this these are again the same thing we

2045
01:20:02,840 --> 01:20:03,889
talked about for getting I always wanted

2046
01:20:03,889 --> 01:20:05,239
to predicate push down or a limit push

2047
01:20:05,239 --> 01:20:06,889
down I can write a rule to do that

2048
01:20:06,889 --> 01:20:09,139
transformation and then once the one

2049
01:20:09,139 --> 01:20:11,209
this step is done now you do the cost

2050
01:20:11,209 --> 01:20:13,789
based search to find a mapping from the

2051
01:20:13,789 --> 01:20:15,920
logical plan to a physical plan if that

2052
01:20:15,920 --> 01:20:17,539
could be the joint ordering or it could

2053
01:20:17,539 --> 01:20:20,630
be the you know figuring out whether you

2054
01:20:20,630 --> 01:20:22,249
want is a nested loop join or a certain

2055
01:20:22,249 --> 01:20:23,719
rejoin or a hashed one figure out those

2056
01:20:23,719 --> 01:20:27,130
algorithms the most famous one of these

2057
01:20:27,130 --> 01:20:29,749
optimized generators was with starbursts

2058
01:20:29,749 --> 01:20:33,320
that IBM led by guy lumen let's come and

2059
01:20:33,320 --> 01:20:34,939
again this is just repeats what I said

2060
01:20:34,939 --> 01:20:37,100
before you had a query rewrite phase

2061
01:20:37,100 --> 01:20:40,340
that does that can compute the

2062
01:20:40,340 --> 01:20:43,010
transformations based on these blocks

2063
01:20:43,010 --> 01:20:45,170
and that doesn't have a cost model and

2064
01:20:45,170 --> 01:20:46,940
then you do the system auto style search

2065
01:20:46,940 --> 01:20:50,840
to to find you know joint order things

2066
01:20:50,840 --> 01:20:53,480
like that so as far as you know know the

2067
01:20:53,480 --> 01:20:55,880
latest version of IBM db2 like their

2068
01:20:55,880 --> 01:20:57,800
their enterprise relational database

2069
01:20:57,800 --> 01:21:04,070
system is using this approach I don't

2070
01:21:04,070 --> 01:21:05,690
know of any other ones I mean starburst

2071
01:21:05,690 --> 01:21:09,560
was a you know star bus was system

2072
01:21:09,560 --> 01:21:11,090
developed at IBM so I mean it's

2073
01:21:11,090 --> 01:21:12,920
obviously make sense and to go in db2 I

2074
01:21:12,920 --> 01:21:14,510
don't know of any other davis system

2075
01:21:14,510 --> 01:21:18,530
that follows this similar approach so

2076
01:21:18,530 --> 01:21:20,330
what are the advantages well so in

2077
01:21:20,330 --> 01:21:21,740
practice it works well would think it's

2078
01:21:21,740 --> 01:21:27,530
faster performance the downside though

2079
01:21:27,530 --> 01:21:32,030
is that you have no way to clearly

2080
01:21:32,030 --> 01:21:34,160
define the the priorities you have for

2081
01:21:34,160 --> 01:21:35,870
your transformations again this will

2082
01:21:35,870 --> 01:21:36,920
make more sense when we talk about

2083
01:21:36,920 --> 01:21:39,200
cascades but basically like if I know I

2084
01:21:39,200 --> 01:21:40,820
can't exhaustively search and everything

2085
01:21:40,820 --> 01:21:42,530
so maybe there's some transformations I

2086
01:21:42,530 --> 01:21:44,090
want to look at first because I yeah I

2087
01:21:44,090 --> 01:21:45,740
think I'll get better benefit from them

2088
01:21:45,740 --> 01:21:49,670
and then oh and then that helps me maybe

2089
01:21:49,670 --> 01:21:52,880
then lower my upper bound for for my

2090
01:21:52,880 --> 01:21:55,070
query and then I know I can prune things

2091
01:21:55,070 --> 01:21:56,960
out that maybe don't aren't that I mean

2092
01:21:56,960 --> 01:21:58,940
less helpful so I don't apply those

2093
01:21:58,940 --> 01:22:01,130
transformations first so that so in the

2094
01:22:01,130 --> 01:22:02,330
original version at starburst you

2095
01:22:02,330 --> 01:22:05,870
couldn't do that the other aspect that

2096
01:22:05,870 --> 01:22:07,040
they talked about in the paper that was

2097
01:22:07,040 --> 01:22:09,350
a big pain was that because these

2098
01:22:09,350 --> 01:22:10,400
transformation rules are based on

2099
01:22:10,400 --> 01:22:13,850
relational calculus it became difficult

2100
01:22:13,850 --> 01:22:15,710
to maintain and find programmers to

2101
01:22:15,710 --> 01:22:18,590
write because writing relational

2102
01:22:18,590 --> 01:22:23,450
calculus code is sort of not um doesn't

2103
01:22:23,450 --> 01:22:25,100
come natural to to the writer assistants

2104
01:22:25,100 --> 01:22:26,990
programmers again I don't know whether

2105
01:22:26,990 --> 01:22:31,250
in the suburbs papers from 1990 88 I

2106
01:22:31,250 --> 01:22:33,350
don't know if since then it's been

2107
01:22:33,350 --> 01:22:35,260
rectified

2108
01:22:35,260 --> 01:22:38,060
alright so quickly the unified search is

2109
01:22:38,060 --> 01:22:39,440
where you have this notion of the

2110
01:22:39,440 --> 01:22:40,970
logical logical and logical physical

2111
01:22:40,970 --> 01:22:44,390
transformations done all together and so

2112
01:22:44,390 --> 01:22:45,320
you don't have these separate stages

2113
01:22:45,320 --> 01:22:46,280
because everything is just a

2114
01:22:46,280 --> 01:22:47,810
transformation you throw it into your

2115
01:22:47,810 --> 01:22:49,640
rules engine it does the search and

2116
01:22:49,640 --> 01:22:50,699
applies these things

2117
01:22:50,699 --> 01:22:54,030
for you so the major downside the major

2118
01:22:54,030 --> 01:22:55,110
tricky thing you have to deal with a

2119
01:22:55,110 --> 01:22:57,239
unified search is that there's me so

2120
01:22:57,239 --> 01:23:00,269
many transformations that you have to

2121
01:23:00,269 --> 01:23:02,969
use a memorization table to make sure

2122
01:23:02,969 --> 01:23:04,860
that you cache some of these

2123
01:23:04,860 --> 01:23:06,539
transformations so that you're not

2124
01:23:06,539 --> 01:23:08,010
replying you know applying the same

2125
01:23:08,010 --> 01:23:10,440
change over and over again so now this

2126
01:23:10,440 --> 01:23:12,209
makes the the memory footprint a little

2127
01:23:12,209 --> 01:23:13,979
bit larger here because I have to

2128
01:23:13,979 --> 01:23:15,360
maintain some some history of

2129
01:23:15,360 --> 01:23:17,010
transformations applied in the past to

2130
01:23:17,010 --> 01:23:18,209
know whether I want to apply a new one

2131
01:23:18,209 --> 01:23:23,280
in the future so Gertz graph II was the

2132
01:23:23,280 --> 01:23:26,999
same guy that did the volcano the the

2133
01:23:26,999 --> 01:23:28,769
you know volcano iterator model we

2134
01:23:28,769 --> 01:23:29,909
talked about for for query processing

2135
01:23:29,909 --> 01:23:31,889
models there's a volcano optimizer

2136
01:23:31,889 --> 01:23:33,719
that's part of the same project he's the

2137
01:23:33,719 --> 01:23:35,639
same guy that did some of the work that

2138
01:23:35,639 --> 01:23:38,099
we talked about for you know latching

2139
01:23:38,099 --> 01:23:42,420
and locking and B plus trees so when he

2140
01:23:42,420 --> 01:23:44,489
was an academic he built a series of

2141
01:23:44,489 --> 01:23:48,590
these these new systems that each had a

2142
01:23:48,590 --> 01:23:53,280
optimizer optimizer generator so the

2143
01:23:53,280 --> 01:23:55,559
second one here was was a volcano and

2144
01:23:55,559 --> 01:23:57,719
again this was a general-purpose base

2145
01:23:57,719 --> 01:24:00,059
cost-based optimizer that had these

2146
01:24:00,059 --> 01:24:01,760
equivalence rules baked into it for

2147
01:24:01,760 --> 01:24:04,229
relational algebra it made it really

2148
01:24:04,229 --> 01:24:07,889
easy to add new rules it treated first

2149
01:24:07,889 --> 01:24:10,199
physical properties of the data and

2150
01:24:10,199 --> 01:24:12,389
better as first-class entities or

2151
01:24:12,389 --> 01:24:15,059
components in the system itself so you

2152
01:24:15,059 --> 01:24:16,769
could you could understand whether

2153
01:24:16,769 --> 01:24:18,090
you're making a transformation that was

2154
01:24:18,090 --> 01:24:20,550
valid or not as you were going along and

2155
01:24:20,550 --> 01:24:21,809
rather than trying to clean up things

2156
01:24:21,809 --> 01:24:24,690
after the fact so this is an example of

2157
01:24:24,690 --> 01:24:26,190
a top-down approach will be the same

2158
01:24:26,190 --> 01:24:28,590
thing that Cascades will use double talk

2159
01:24:28,590 --> 01:24:31,469
about next class but this is sort of

2160
01:24:31,469 --> 01:24:33,179
like this was like an early prototype

2161
01:24:33,179 --> 01:24:36,900
this was a predecessor to two Cascades

2162
01:24:36,900 --> 01:24:44,190
right so as far as they know volcano I

2163
01:24:44,190 --> 01:24:45,959
mean the volcano itself was using the

2164
01:24:45,959 --> 01:24:48,449
optimizer other academic prototypes at

2165
01:24:48,449 --> 01:24:50,459
the time we're using this but as far as

2166
01:24:50,459 --> 01:24:53,269
I know this approach is not used in in

2167
01:24:53,269 --> 01:24:58,530
any any in any major system so let's

2168
01:24:58,530 --> 01:24:59,449
look at an example here

2169
01:24:59,449 --> 01:25:02,219
godamn don't restart okay

2170
01:25:02,219 --> 01:25:04,590
so the first thing we want to do is

2171
01:25:04,590 --> 01:25:05,699
start with a logical plan of what we

2172
01:25:05,699 --> 01:25:07,440
want the query to be so this is what we

2173
01:25:07,440 --> 01:25:08,880
want our output to be we want to do a

2174
01:25:08,880 --> 01:25:10,770
three-way join putting these tables and

2175
01:25:10,770 --> 01:25:12,330
we want have it order by on the artist

2176
01:25:12,330 --> 01:25:14,940
ID so again this is the opposite what we

2177
01:25:14,940 --> 01:25:16,260
saw in system our system are we started

2178
01:25:16,260 --> 01:25:18,150
up here and said here's all the tables

2179
01:25:18,150 --> 01:25:20,310
we have figure out how to get us up here

2180
01:25:20,310 --> 01:25:22,140
so we this is where we start with we

2181
01:25:22,140 --> 01:25:23,460
want to and then want to go down and

2182
01:25:23,460 --> 01:25:25,380
apply transformation rules to get us

2183
01:25:25,380 --> 01:25:28,560
there right so we can invoke rules that

2184
01:25:28,560 --> 01:25:31,020
as we go down to either do logical

2185
01:25:31,020 --> 01:25:33,660
logical transformations so like checking

2186
01:25:33,660 --> 01:25:35,550
you join on a and B reverse that and you

2187
01:25:35,550 --> 01:25:37,860
would join them BN a or we give you a

2188
01:25:37,860 --> 01:25:39,510
logical physical take you know join on a

2189
01:25:39,510 --> 01:25:42,449
and B and have it now be executed as a

2190
01:25:42,449 --> 01:25:46,880
hash join on a and B right so we then

2191
01:25:46,880 --> 01:25:49,140
add these nodes here to apply it apply

2192
01:25:49,140 --> 01:25:51,449
these transformations and then we use to

2193
01:25:51,449 --> 01:25:52,650
connect them and say how do we actually

2194
01:25:52,650 --> 01:25:54,660
get there and we can just keep going

2195
01:25:54,660 --> 01:25:57,300
this down you keep going down to do this

2196
01:25:57,300 --> 01:25:59,460
until we reach the bottom and in this

2197
01:25:59,460 --> 01:26:01,469
case here we could compute the cost of

2198
01:26:01,469 --> 01:26:04,590
what our query plan as is here and we

2199
01:26:04,590 --> 01:26:07,100
keep the check bad as as the lowest cost

2200
01:26:07,100 --> 01:26:09,060
so now we just keep doing look at all

2201
01:26:09,060 --> 01:26:11,610
possible other permutations and so forth

2202
01:26:11,610 --> 01:26:15,330
until we find in this case here we if we

2203
01:26:15,330 --> 01:26:17,430
tried to do a hash join we know that

2204
01:26:17,430 --> 01:26:19,199
doing this hash join would violate our

2205
01:26:19,199 --> 01:26:20,880
physical ordering that we have so we

2206
01:26:20,880 --> 01:26:22,680
know we can't do this so we can

2207
01:26:22,680 --> 01:26:26,130
introduce like a quicksort you know to

2208
01:26:26,130 --> 01:26:28,080
do the order by and then now we can do

2209
01:26:28,080 --> 01:26:29,820
the hash join and so forth right in this

2210
01:26:29,820 --> 01:26:31,590
case here say doing the quicksort plus

2211
01:26:31,590 --> 01:26:33,540
the hash join is more expensive than new

2212
01:26:33,540 --> 01:26:35,460
the sort merge join followed by either

2213
01:26:35,460 --> 01:26:37,199
the hash alone insert merge join so we

2214
01:26:37,199 --> 01:26:38,489
cut it off there so you're doing branch

2215
01:26:38,489 --> 01:26:40,290
and bound to identify that as I'm

2216
01:26:40,290 --> 01:26:42,989
traversing the branch on the tree if I'm

2217
01:26:42,989 --> 01:26:45,800
at a point where my query plan is

2218
01:26:45,800 --> 01:26:48,090
already more expensive than the best

2219
01:26:48,090 --> 01:26:49,739
plan I've seen before I don't need to

2220
01:26:49,739 --> 01:26:50,969
look at anything below it in the tree

2221
01:26:50,969 --> 01:26:52,350
because I'll know I'll never get better

2222
01:26:52,350 --> 01:26:56,760
than that all right so the advantage of

2223
01:26:56,760 --> 01:26:59,790
the of the volcano optimizer that we

2224
01:26:59,790 --> 01:27:01,290
have declared a rule to do our

2225
01:27:01,290 --> 01:27:03,390
transformations but strawberries have

2226
01:27:03,390 --> 01:27:05,219
the same thing but it's gonna have

2227
01:27:05,219 --> 01:27:07,110
better extensibility with an efficient

2228
01:27:07,110 --> 01:27:08,460
search algorithm because we can reduce

2229
01:27:08,460 --> 01:27:10,620
the number of redundant estimations we

2230
01:27:10,620 --> 01:27:12,870
have to do by caching our

2231
01:27:12,870 --> 01:27:14,119
transformations

2232
01:27:14,119 --> 01:27:18,229
the problem though is that the at least

2233
01:27:18,229 --> 01:27:20,649
the wave volcano was implemented is that

2234
01:27:20,649 --> 01:27:24,229
for every single possible trim like for

2235
01:27:24,229 --> 01:27:25,550
every single operate I'm looking at I

2236
01:27:25,550 --> 01:27:28,309
would expand out all possible

2237
01:27:28,309 --> 01:27:29,719
combinations like Earl your

2238
01:27:29,719 --> 01:27:31,999
transformations like I'd have and then

2239
01:27:31,999 --> 01:27:33,949
now start doing the the search and all

2240
01:27:33,949 --> 01:27:36,109
those rather than maybe traversing all

2241
01:27:36,109 --> 01:27:38,899
the way the bottom first and then it was

2242
01:27:38,899 --> 01:27:41,599
not easy to modify predicates I don't

2243
01:27:41,599 --> 01:27:43,760
exactly know this what this was about it

2244
01:27:43,760 --> 01:27:45,530
I think essentially it meant that you

2245
01:27:45,530 --> 01:27:47,419
couldn't do rewriting of like where

2246
01:27:47,419 --> 01:27:49,999
clauses because the the optimizer itself

2247
01:27:49,999 --> 01:27:51,739
only know how to do transformations on

2248
01:27:51,739 --> 01:27:53,780
physical arbiters and not be expression

2249
01:27:53,780 --> 01:27:56,989
trees inside of them so I rush this at

2250
01:27:56,989 --> 01:27:58,669
the end was just meant to show you what

2251
01:27:58,669 --> 01:28:01,459
a what a top-down optimizer looks like

2252
01:28:01,459 --> 01:28:04,129
but then next class will pick up on on

2253
01:28:04,129 --> 01:28:04,760
Cascades

2254
01:28:04,760 --> 01:28:07,339
so hopefully the main takeaway from all

2255
01:28:07,339 --> 01:28:10,010
this is that query optimization super

2256
01:28:10,010 --> 01:28:12,919
hard and this is part of reason why the

2257
01:28:12,919 --> 01:28:14,329
newest ecosystems when they first came

2258
01:28:14,329 --> 01:28:18,050
out maybe a decade ago they they

2259
01:28:18,050 --> 01:28:19,489
basically didn't implement a query

2260
01:28:19,489 --> 01:28:20,089
optimizer

2261
01:28:20,089 --> 01:28:21,559
because it ah we don't need to do joins

2262
01:28:21,559 --> 01:28:23,359
you don't need a declarative language

2263
01:28:23,359 --> 01:28:26,569
like sequel and part of the the

2264
01:28:26,569 --> 01:28:28,879
advantage of not supporting those things

2265
01:28:28,879 --> 01:28:29,959
is that you didn't have to build a query

2266
01:28:29,959 --> 01:28:32,419
optimizer but now for the systems that

2267
01:28:32,419 --> 01:28:34,309
did add something that looks like sequel

2268
01:28:34,309 --> 01:28:36,589
orderly's declarative language they're

2269
01:28:36,589 --> 01:28:38,119
having to go implement Cori optimizers

2270
01:28:38,119 --> 01:28:40,699
and then the the quality of them can can

2271
01:28:40,699 --> 01:28:42,589
vary greatly and they're usually gonna

2272
01:28:42,589 --> 01:28:45,739
be heuristic based systems alright so

2273
01:28:45,739 --> 01:28:48,859
next class will pick up discussing more

2274
01:28:48,859 --> 01:28:50,869
optimizers and then the real debate will

2275
01:28:50,869 --> 01:28:52,819
be again is dynamic programming versus

2276
01:28:52,819 --> 01:28:54,739
the Cascades broach the the bottom-up

2277
01:28:54,739 --> 01:28:56,629
approach we saw all system are first the

2278
01:28:56,629 --> 01:28:58,729
top-down approach which volcano is an

2279
01:28:58,729 --> 01:29:00,559
example of but a Cascades Cascades will

2280
01:29:00,559 --> 01:29:02,089
be more sophisticated implementation and

2281
01:29:02,089 --> 01:29:04,999
the this is what we use in our system

2282
01:29:04,999 --> 01:29:10,489
today ok alright so again I'm meeting

2283
01:29:10,489 --> 01:29:12,349
with everyone for the projects this week

2284
01:29:12,349 --> 01:29:15,439
and then will on the on Wednesday next

2285
01:29:15,439 --> 01:29:17,689
week we'll do the in-class presentations

2286
01:29:17,689 --> 01:29:18,469
or over zoom

2287
01:29:18,469 --> 01:29:21,079
ok wash your hands sink it in the side

2288
01:29:21,079 --> 01:29:23,110
park what is this

2289
01:29:23,110 --> 01:29:25,510
would say you're here I took the sipping

2290
01:29:25,510 --> 01:29:28,090
had to spit today with dead deer called

2291
01:29:28,090 --> 01:29:30,790
the hole it cuz I mochi ice cube down

2292
01:29:30,790 --> 01:29:33,489
with the test team I look and it was go

2293
01:29:33,489 --> 01:29:36,489
grab me a 40 just to get my boss song

2294
01:29:36,489 --> 01:29:40,190
cuz I need it just a little more kick

2295
01:29:40,190 --> 01:29:43,170
[Music]

2296
01:29:43,170 --> 01:29:47,500
that's a nice and my hood wants me to

2297
01:29:47,500 --> 01:29:49,780
say I've nice cute take a say I

2298
01:29:49,780 --> 01:29:52,590
celebrate

