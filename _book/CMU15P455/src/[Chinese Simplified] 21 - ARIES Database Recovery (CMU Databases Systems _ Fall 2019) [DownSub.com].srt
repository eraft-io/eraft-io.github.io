1
00:00:06,920 --> 00:00:19,220
今天有很多要谈的，这是

2
00:00:19,220 --> 00:00:21,619
我们周一停课的地方的延续，

3
00:00:21,619 --> 00:00:23,570


4
00:00:23,570 --> 00:00:25,609
有很多恢复，所以 DJ 降级表

5
00:00:25,609 --> 00:00:27,470
仍然在维加斯，所以你

6
00:00:27,470 --> 00:00:29,599
今天不能去，但他 周一会回来

7
00:00:29,599 --> 00:00:31,880
，我说他正在处理

8
00:00:31,880 --> 00:00:36,860
女朋友的多个问题，所以

9
00:00:36,860 --> 00:00:38,480
周一我们开始讨论恢复

10
00:00:38,480 --> 00:00:40,579
算法，我们讨论了如何

11
00:00:40,579 --> 00:00:43,070
让数据库系统能够

12
00:00:43,070 --> 00:00:46,160
将数据库恢复到

13
00:00:46,160 --> 00:00:49,519
之前存在的一致状态 系统

14
00:00:49,519 --> 00:00:51,440
崩溃了，我们想这样做，

15
00:00:51,440 --> 00:00:53,480
确保我们为所有事务提供原子性持久性

16
00:00:53,480 --> 00:00:55,340
和一致性保证

17
00:00:55,340 --> 00:00:57,859
，我说过

18
00:00:57,859 --> 00:00:59,210


19
00:00:59,210 --> 00:01:01,519
，我们可能设计的数据库系统中的每个恢复相册

20
00:01:01,519 --> 00:01:03,530
都将包含两个部分 但首先是

21
00:01:03,530 --> 00:01:04,790
我们在

22
00:01:04,790 --> 00:01:07,160
处理事务以记录额外

23
00:01:07,160 --> 00:01:10,070
信息或以

24
00:01:10,070 --> 00:01:12,979
某种方式将数据刷新到磁盘时我们要做的事情，

25
00:01:12,979 --> 00:01:14,479
这样我们就可以在

26
00:01:14,479 --> 00:01:16,400
崩溃后恢复 sh 所以现在我们今天谈论的

27
00:01:16,400 --> 00:01:18,500
是后半部分 如果有

28
00:01:18,500 --> 00:01:21,079
防撞垫，我们会回来

29
00:01:21,079 --> 00:01:22,549
重新选择我们的生活

30
00:01:22,549 --> 00:01:23,899
将您知道的生活重新组合在一起并

31
00:01:23,899 --> 00:01:28,340
弄清楚发生了什么 所以

32
00:01:28,340 --> 00:01:30,640
我们的协议 '今天要看的是

33
00:01:30,640 --> 00:01:34,040
基于 IBM 开发的这项

34
00:01:34,040 --> 00:01:35,990
称为 Ares 的技术，所以我认为

35
00:01:35,990 --> 00:01:38,110
教科书不会

36
00:01:38,110 --> 00:01:39,950
在章节中明确提及我们今天讨论

37
00:01:39,950 --> 00:01:41,600
的技术中的数据恢复

38
00:01:41,600 --> 00:01:44,180
Ares 我们

39
00:01:44,180 --> 00:01:45,320
只是站在你的脑海里，以

40
00:01:45,320 --> 00:01:47,689
了解这几乎就是这个

41
00:01:47,689 --> 00:01:50,719
Ares 几乎每个人都这样做 所以

42
00:01:50,719 --> 00:01:53,210
Ares 是在

43
00:01:53,210 --> 00:01:56,530
1980 年代末 1990 年代初的 IBM 研究中开发的，用于 db2

44
00:01:56,530 --> 00:01:58,939
并且出现了这篇开创性的论文

45
00:01:58,939 --> 00:02:01,340
如果你睡不着，那是超长的，

46
00:02:01,340 --> 00:02:03,469
它有 70 页，所以

47
00:02:03,469 --> 00:02:04,579
继续尝试一下，看看

48
00:02:04,579 --> 00:02:05,630
你是否可以完成

49
00:02:05,630 --> 00:02:08,810
你不会的整个事情，但是这件事

50
00:02:08,810 --> 00:02:11,990
涉及到所有令人痛苦的细节

51
00:02:11,990 --> 00:02:13,910
步骤和失败 你需要

52
00:02:13,910 --> 00:02:15,980
处理的场景是你的恢复

53
00:02:15,980 --> 00:02:17,660
相册是正确的，并且

54
00:02:17,660 --> 00:02:21,050
你不会丢失任何数据，

55
00:02:21,050 --> 00:02:22,760
所以并不是说

56
00:02:22,760 --> 00:02:24,830
在 1992 年这篇论文发表之前没有人在做恢复，

57
00:02:24,830 --> 00:02:28,130
只是说 这篇论文

58
00:02:28,130 --> 00:02:31,400
是那种被制定或编纂的

59
00:02:31,400 --> 00:02:34,130
确切策略，需要谨慎

60
00:02:34,130 --> 00:02:36,350
行事才能正确恢复杜克

61
00:02:36,350 --> 00:02:38,540
，然后不是每个数据库，

62
00:02:38,540 --> 00:02:39,740
今天已经出来，正在做

63
00:02:39,740 --> 00:02:41,300
检查点和提前写日志

64
00:02:41,300 --> 00:02:44,360
可能不会落到确切的字母

65
00:02:44,360 --> 00:02:46,480
Ares 做了什么，但在高层次上，

66
00:02:46,480 --> 00:02:48,770
他们本质上是在做同样的

67
00:02:48,770 --> 00:02:50,750
事情 带有模糊

68
00:02:50,750 --> 00:02:52,520
检查点的日志，然后是三阶段

69
00:02:52,520 --> 00:02:54,430
分析或三阶段恢复

70
00:02:54,430 --> 00:03:00,020
协议，因此 Ares 用于数据库恢复的三个主要思想

71
00:03:00,020 --> 00:03:02,350
是 Fallen the Fallen

72
00:03:02,350 --> 00:03:04,670
首先是我们将使用

73
00:03:04,670 --> 00:03:07,010
redhead log right forward log 来记录

74
00:03:07,010 --> 00:03:09,710
事务对

75
00:03:09,710 --> 00:03:13,610
这些日志记录中数据库中的数据所做的任何更改，

76
00:03:13,610 --> 00:03:15,650
并且我们必须刷新

77
00:03:15,650 --> 00:03:17,360


78
00:03:17,360 --> 00:03:19,870
在可以写出页面之前响应页面的更改，

79
00:03:19,870 --> 00:03:22,610
正如我们在上一堂课所说的，这是使用

80
00:03:22,610 --> 00:03:25,130
无强制窃取策略，因此窃取

81
00:03:25,130 --> 00:03:30,410
意味着什么窃取表示允许缓冲池将

82
00:03:30,410 --> 00:03:34,310
页面刷新到磁盘或

83
00:03:34,310 --> 00:03:36,590
dick 页面 已被

84
00:03:36,590 --> 00:03:38,180
尚未提交的事务修改的磁盘，

85
00:03:38,180 --> 00:03:40,640
并且没有强制说

86
00:03:40,640 --> 00:03:42,290
我们不需要刷新

87
00:03:42,290 --> 00:03:45,230
事务修改的所有脏页，

88
00:03:45,230 --> 00:03:46,370
以便说明

89
00:03:46,370 --> 00:03:48,040
事务已正确提交，

90
00:03:48,040 --> 00:03:50,150
而是我们所做的是我们 在我们告诉外界我们的事务已经提交之前

91
00:03:50,150 --> 00:03:53,480


92
00:03:53,480 --> 00:03:55,490
，从磁盘刷新事务生成的所有日志记录，确保它们是

93
00:03:55,490 --> 00:03:57,500
持久和安全的，

94
00:03:57,500 --> 00:03:59,000


95
00:03:59,000 --> 00:04:02,570
所以这就是我们在运行时所做的

96
00:04:02,570 --> 00:04:05,180
，我们将对如何做略有

97
00:04:05,180 --> 00:04:07,940
不同 我们要做的事情

98
00:04:07,940 --> 00:04:09,170
会有所不同，当我们周一谈论时，

99
00:04:09,170 --> 00:04:10,340
我们将不得不看看这

100
00:04:10,340 --> 00:04:11,660
家商店一些额外的东西，以确保它

101
00:04:11,660 --> 00:04:14,780
可以正常工作，然后在

102
00:04:14,780 --> 00:04:17,690
重新启动后恢复我们正在使用的数据库

103
00:04:17,690 --> 00:04:20,238
将首先在

104
00:04:20,238 --> 00:04:22,970
日志中重播历史记录以重做

105
00:04:22,970 --> 00:04:25,790
事务所做的所有更改，这包括因中止事务而产生的

106
00:04:25,790 --> 00:04:27,560
任何更改，

107
00:04:27,560 --> 00:04:29,360
我们也将重新应用

108
00:04:29,360 --> 00:04:32,510
它们，然后我们将不得不返回并

109
00:04:32,510 --> 00:04:34,520
撤消一堆 一些东西来弄清楚如何

110
00:04:34,520 --> 00:04:34,700


111
00:04:34,700 --> 00:04:36,110
与应该持久的更改相比

112
00:04:36,110 --> 00:04:38,180
，然后我们要做的另一个更改

113
00:04:38,180 --> 00:04:39,470
也是当

114
00:04:39,470 --> 00:04:42,320
我们在运行

115
00:04:42,320 --> 00:04:44,480
时和恢复期间开始撤消更改时，我们实际上是

116
00:04:44,480 --> 00:04:46,910
为这些撤消创建日志记录

117
00:04:46,910 --> 00:04:49,640
操作也是如此，所以这

118
00:04:49,640 --> 00:04:50,630
也是我们到目前为止还没有谈论的事情，

119
00:04:50,630 --> 00:04:52,490
因为我刚刚说的所有最后一个人

120
00:04:52,490 --> 00:04:53,720
嘿这里是我正在做的所有更新

121
00:04:53,720 --> 00:04:55,520
这里是相应的日志记录

122
00:04:55,520 --> 00:04:57,590
然后当我登机时是的，你知道我

123
00:04:57,590 --> 00:05:00,020
没有 做任何特别的事情，所以现在当

124
00:05:00,020 --> 00:05:02,900
我们

125
00:05:02,900 --> 00:05:04,910
在运行时再次执行边界事务或将其分开时，

126
00:05:04,910 --> 00:05:07,370
我们将添加额外的日志记录来说明

127
00:05:07,370 --> 00:05:09,320
这是我们正在逆转的更改

128
00:05:09,320 --> 00:05:12,020
，我们需要这样做以确保我们

129
00:05:12,020 --> 00:05:14,450
可以重新记录 ver 但是如果我们在恢复过程中崩溃，

130
00:05:14,450 --> 00:05:16,070
我们可以从

131
00:05:16,070 --> 00:05:18,590
恢复中恢复，而你 Majan 这东西

132
00:05:18,590 --> 00:05:20,060
是无限的 所以这是

133
00:05:20,060 --> 00:05:21,470
我们需要的额外步骤，以确保

134
00:05:21,470 --> 00:05:24,590
我们可以处理所有情况 所以

135
00:05:24,590 --> 00:05:26,090
今天的议程是首先谈谈 关于

136
00:05:26,090 --> 00:05:29,060


137
00:05:29,060 --> 00:05:30,950


138
00:05:30,950 --> 00:05:33,290
在 revver 正常

139
00:05:33,290 --> 00:05:35,390
处理期间执行工作负载如何是不同的事务执行过程，我略有不同，所以

140
00:05:35,390 --> 00:05:36,650
我们将介绍锁定

141
00:05:36,650 --> 00:05:38,390
序列号的想法以及

142
00:05:38,390 --> 00:05:40,460
我们为提交和中止沙子和模糊

143
00:05:40,460 --> 00:05:42,320
检查点所做的额外步骤，然后 我们将结束

144
00:05:42,320 --> 00:05:44,360
讨论我们如何实际执行由 Ares

145
00:05:44,360 --> 00:05:46,610
定义的三阶段恢复算法

146
00:05:46,610 --> 00:05:50,120
好吧，这

147
00:05:50,120 --> 00:05:52,220
太难了，正如我所说，这

148
00:05:52,220 --> 00:05:53,600
可能是数据库系统中第三难的部分，

149
00:05:53,600 --> 00:05:56,390
所以在我们继续进行时再次阻止我，

150
00:05:56,390 --> 00:05:58,310
如果 你有问题可以

151
00:05:58,310 --> 00:06:01,490
随意打断所以上节课我们

152
00:06:01,490 --> 00:06:03,260
谈到了写头部日志记录，我们

153
00:06:03,260 --> 00:06:05,570
说为了我们的目的，

154
00:06:05,570 --> 00:06:06,950
我们假设我们正在做物理 l 日志记录

155
00:06:06,950 --> 00:06:09,290
或生理日志记录，而不是

156
00:06:09,290 --> 00:06:11,030
逻辑日志记录，您只

157
00:06:11,030 --> 00:06:12,680
记录续集语句，因此我们将

158
00:06:12,680 --> 00:06:14,690
拥有进行更改的事务 ID，

159
00:06:14,690 --> 00:06:17,840
即他们正在更改的对象

160
00:06:17,840 --> 00:06:20,300
，然后是重做和

161
00:06:20,300 --> 00:06:22,520
撤消信息，但现在我们 '包含

162
00:06:22,520 --> 00:06:24,950
额外的元数据，用于跟踪

163
00:06:24,950 --> 00:06:26,810
这些日志记录的生成顺序，

164
00:06:26,810 --> 00:06:29,090
因此我们将引入

165
00:06:29,090 --> 00:06:30,890
一个称为日志序列号的新概念

166
00:06:30,890 --> 00:06:33,950
LSM，它只是一个

167
00:06:33,950 --> 00:06:35,570
单调递增的计数器，我们

168
00:06:35,570 --> 00:06:37,520
分配给每个博客记录 随着它

169
00:06:37,520 --> 00:06:40,160
被添加，因此序列

170
00:06:40,160 --> 00:06:42,410
号定律对于事务不需要是连续的，

171
00:06:42,410 --> 00:06:43,970
因为再次取决于

172
00:06:43,970 --> 00:06:44,990
您告诉我们正在使用的场景的并发，

173
00:06:44,990 --> 00:06:47,060
我们可以

174
00:06:47,060 --> 00:06:48,410
以任何不同的方式交错这些操作，

175
00:06:48,410 --> 00:06:50,420
所以我可能会给出日志序列

176
00:06:50,420 --> 00:06:52,760
第一 - 事务 1 日志 6 序列

177
00:06:52,760 --> 00:06:54,500
号 2 - 事务 2 你知道

178
00:06:54,500 --> 00:06:55,880
来回它们

179
00:06:55,880 --> 00:06:58,910
不需要都是连续的，所以现在有了这些日志

180
00:06:58,910 --> 00:07:02,360
序列 我们要修改系统的所有

181
00:07:02,360 --> 00:07:05,300
不同部分，

182
00:07:05,300 --> 00:07:08,600
需要知道哪些日志记录

183
00:07:08,600 --> 00:07:10,670
修改了数据，以及它们是否已

184
00:07:10,670 --> 00:07:13,790
被写出磁盘，所以我们想

185
00:07:13,790 --> 00:07:15,320
进一步扩展我们的缓冲池，

186
00:07:15,320 --> 00:07:17,450
现在意识到 这些日志

187
00:07:17,450 --> 00:07:19,670
序列号是什么？

188
00:07:19,670 --> 00:07:20,900


189
00:07:20,900 --> 00:07:22,610
与对其内存中的页面所做的更改相对应的本地序列号是

190
00:07:22,610 --> 00:07:26,720
什么，因此每个日志记录都有

191
00:07:26,720 --> 00:07:28,400
一个日志序列号，但是

192
00:07:28,400 --> 00:07:29,480
整个系统中的所有

193
00:07:29,480 --> 00:07:31,850
其他日志序列号都将具有这些其他日志序列号 所以这

194
00:07:31,850 --> 00:07:33,380
只是一个日志序列号的汇总表，这些日志

195
00:07:33,380 --> 00:07:34,430
序列号将

196
00:07:34,430 --> 00:07:36,320
在课程的其余部分进行计算，但

197
00:07:36,320 --> 00:07:37,550
我们将一一介绍这些，然后您会

198
00:07:37,550 --> 00:07:40,670
看到然后滥用它们，因此

199
00:07:40,670 --> 00:07:42,800
刷新 LSN 只是一个 - 内存计数器

200
00:07:42,800 --> 00:07:45,080
，跟踪

201
00:07:45,080 --> 00:07:47,150
日志恢复刷新到磁盘的最后一个 LSN，这

202
00:07:47,150 --> 00:07:48,770
只是在我们准备好的内存头日志

203
00:07:48,770 --> 00:07:50,960
缓冲区中告诉我们你知道

204
00:07:50,960 --> 00:07:55,340
多远你知道日志记录

205
00:07:55,340 --> 00:07:57,230
多远我们知道多远 嘿，所有记录

206
00:07:57,230 --> 00:07:59,360
实际上是不是 Dorobo 然后对于

207
00:07:59,360 --> 00:08:01,460
每个页面，我们都有页面 LSN 和

208
00:08:01,460 --> 00:08:04,670
鲁莽的 em，因此页面 LSN 将只是

209
00:08:04,670 --> 00:08:08,150
修改该页面的最后一个日志记录，

210
00:08:08,150 --> 00:08:10,250
但是该记录的最新日志序列

211
00:08:10,250 --> 00:08:13,610
，然后 REC LSN 将是

212
00:08:13,610 --> 00:08:17,330


213
00:08:17,330 --> 00:08:20,300
自上次刷新以来修改此页面的最旧日志记录，因此当我

214
00:08:20,300 --> 00:08:22,520
将页面放入内存时，如果我继续

215
00:08:22,520 --> 00:08:24,890
进行第一次修改它的第一个事务，

216
00:08:24,890 --> 00:08:26,750
我将该本地序列

217
00:08:26,750 --> 00:08:28,700
号添加为 REC Ellison，然后

218
00:08:28,700 --> 00:08:30,320


219
00:08:30,320 --> 00:08:32,690
无论我在内存中不断修改它多少次，它们都是鲁莽的

220
00:08:32,690 --> 00:08:34,010
并且总是相同的，而

221
00:08:34,010 --> 00:08:37,010
其他页面并且它会增加然后

222
00:08:37,010 --> 00:08:38,719
我将这些数据也写到

223
00:08:38,719 --> 00:08:40,549
磁盘上，就像这样，所以代码 正在

224
00:08:40,549 --> 00:08:41,960
进入标题，这是您的额外调用

225
00:08:41,960 --> 00:08:43,849
额外信息，以确保

226
00:08:43,849 --> 00:08:45,110
我们在恢复期间做正确的事情，

227
00:08:45,110 --> 00:08:48,080
每个事务都将

228
00:08:48,080 --> 00:08:49,670
跟踪最后一个 LSN，如果这是

229
00:08:49,670 --> 00:08:51,320
您知道的最后一个添加的日志记录，

230
00:08:51,320 --> 00:08:54,110
并且 在全球范围内，我们将拥有

231
00:08:54,110 --> 00:08:56,600
一个主记录，我们将用它来

232
00:08:56,600 --> 00:08:58,339
跟踪 LSN 我们现在成功采取的最后一个检查

233
00:08:58,339 --> 00:09:00,700
点，

234
00:09:00,700 --> 00:09:02,470
记得我说过，当我们采取

235
00:09:02,470 --> 00:09:03,370
这些检查点时，它们实际上是

236
00:09:03,370 --> 00:09:05,410
进入日志的条目 嘿，我

237
00:09:05,410 --> 00:09:08,770
在这个时候采取了一个检查点，所以再次

238
00:09:08,770 --> 00:09:10,030
重申我之前说过的所有内容

239
00:09:10,030 --> 00:09:12,520
，所以每个页面都有一个页面 LSN

240
00:09:12,520 --> 00:09:14,320
只有当对该页面进行最新更新时

241
00:09:14,320 --> 00:09:16,630
，我们才会跟踪刷新 LSN

242
00:09:16,630 --> 00:09:19,870
以了解有多少是什么

243
00:09:19,870 --> 00:09:21,490
日志中的顺序或日志中的哪个点我们已经将

244
00:09:21,490 --> 00:09:23,890
这些内容写入磁盘，正如

245
00:09:23,890 --> 00:09:32,770
我上一堂课所说，是的，抱歉，问题是，

246
00:09:32,770 --> 00:09:35,110
所以我对页面 LS 和

247
00:09:35,110 --> 00:09:36,600
鲁莽的结尾说，他们是否会被写入磁盘，

248
00:09:36,600 --> 00:09:40,030
但他们没有 必须，但总的来说，你这样

249
00:09:40,030 --> 00:09:42,250
做只是一个额外的安全机制，

250
00:09:42,250 --> 00:09:44,140
以防你最终错过听

251
00:09:44,140 --> 00:09:54,160
一些关于

252
00:09:54,160 --> 00:10:07,990
日志记录的信息正确的说法是如果

253
00:10:07,990 --> 00:10:10,330
你把它写出来磁盘是如果你

254
00:10:10,330 --> 00:10:11,500
把页面写到磁盘上 其他页面

255
00:10:11,500 --> 00:10:13,210
和丽贝卡 Ellison 本质上并不是

256
00:10:13,210 --> 00:10:16,090
多余的，因为

257
00:10:16,090 --> 00:10:18,610
现在页面在磁盘上是持久的，

258
00:10:18,610 --> 00:10:20,380
如果它在内存中就不再脏了

259
00:10:20,380 --> 00:10:22,510
，我同意你的看法，我

260
00:10:22,510 --> 00:10:23,620
只是说这是一种额外的安全

261
00:10:23,620 --> 00:10:25,740
机制，

262
00:10:25,740 --> 00:10:27,730
因为我们不 不想丢失任何数据

263
00:10:27,730 --> 00:10:30,700
和光盘是超级的，你知道它们总是

264
00:10:30,700 --> 00:10:32,440
坏的，我们只是想

265
00:10:32,440 --> 00:10:34,150
确保有足够的信息

266
00:10:34,150 --> 00:10:35,770
，如果我们必须覆盖和恢复，

267
00:10:35,770 --> 00:10:38,380
也许我们的法律被破坏得

268
00:10:38,380 --> 00:10:39,280
更好一点，这样 页面

269
00:10:39,280 --> 00:10:41,110
已损坏 我们在

270
00:10:41,110 --> 00:10:42,460
足够多的位置有足够的信息 我们可以

271
00:10:42,460 --> 00:10:44,980
解决问题 是的，现在您会看到

272
00:10:44,980 --> 00:10:46,540
我们进行额外的恢复

273
00:10:46,540 --> 00:10:48,310
过程 我可以做一些明显的事情来

274
00:10:48,310 --> 00:10:50,200
加快速度，让我们谈谈

275
00:10:50,200 --> 00:10:52,960
最后一点关于他们的警惕

276
00:10:52,960 --> 00:10:54,490
我们不会在这里做他们因为我们

277
00:10:54,490 --> 00:10:57,330
想要非常谨慎

278
00:10:57,330 --> 00:10:59,800
当你丢失数据时人们会生气所以

279
00:10:59,800 --> 00:11:02,830
你不想丢失数据好吧所以

280
00:11:02,830 --> 00:11:04,900
这只是说我最后说的话

281
00:11:04,900 --> 00:11:06,460
我说的班员

282
00:11:06,460 --> 00:11:08,290
在我们可以刷新脏页之前使用正确的日志

283
00:11:08,290 --> 00:11:10,180
我们必须刷新

284
00:11:10,180 --> 00:11:12,430
使该页该页正确的日志记录

285
00:11:12,430 --> 00:11:14,470


286
00:11:14,470 --> 00:11:16,480
，这就是我们实际上要

287
00:11:16,480 --> 00:11:18,040
弄清楚我们只是使用这些 LS

288
00:11:18,040 --> 00:11:19,870
结束作为 找出水印

289
00:11:19,870 --> 00:11:22,540
哦，修改这个页面的最后一个日志记录

290
00:11:22,540 --> 00:11:24,280
是这个，你知道一二三，

291
00:11:24,280 --> 00:11:27,190
但我刷新了日志序列号

292
00:11:27,190 --> 00:11:29,500
四五六和四五六

293
00:11:29,500 --> 00:11:31,690
在一二三之后，所以我

294
00:11:31,690 --> 00:11:33,610
知道无论日志序列或 任何

295
00:11:33,610 --> 00:11:35,950
使我的页面变脏的日志记录

296
00:11:35,950 --> 00:11:37,390
也被刷新了，

297
00:11:37,390 --> 00:11:38,800
所以我刷新这个页面是安全的，这

298
00:11:38,800 --> 00:11:41,710
就是我们将如何保证

299
00:11:41,710 --> 00:11:44,110
这一点，所以让我们看一下

300
00:11:44,110 --> 00:11:46,330
所有这些的高级示例 所以

301
00:11:46,330 --> 00:11:48,070
我们再次在内存中有我们的日志缓冲区

302
00:11:48,070 --> 00:11:49,650
，它总是日志的尾部

303
00:11:49,650 --> 00:11:51,580
，它总是像你

304
00:11:51,580 --> 00:11:53,200
知道最近的更改可能已经或可能

305
00:11:53,200 --> 00:11:54,430
没有写出磁盘并

306
00:11:54,430 --> 00:11:58,030
在那里然后挂起 我们

307
00:11:58,030 --> 00:11:58,900
实际上是 o 我们要

308
00:11:58,900 --> 00:12:00,250
介绍的还有一个日志

309
00:12:00,250 --> 00:12:01,810
再次查看数字 这些只是一个计数器，

310
00:12:01,810 --> 00:12:04,840
我们正在增加一个然后

311
00:12:04,840 --> 00:12:08,080
在我们的页面中，我们

312
00:12:08,080 --> 00:12:11,290
再次看到了 Ellison 页面 这

313
00:12:11,290 --> 00:12:12,730
是日志记录的最新日志序列号

314
00:12:12,730 --> 00:12:15,670
修改了这个这个这个页面 它可能

315
00:12:15,670 --> 00:12:17,170
不是一开始让它变脏的

316
00:12:17,170 --> 00:12:18,880
那个，

317
00:12:18,880 --> 00:12:21,070
这就是埃里森的残骸 这是因为我把

318
00:12:21,070 --> 00:12:22,870
这个页面带入内存是什么是第一个

319
00:12:22,870 --> 00:12:24,730
使这个东西变脏的日志记录，

320
00:12:24,730 --> 00:12:26,170
因为我需要 要知道我的

321
00:12:26,170 --> 00:12:29,080
边界是什么，那么现在我们再次拥有刷新

322
00:12:29,080 --> 00:12:31,810
LSN 这只是一个指针，指向

323
00:12:31,810 --> 00:12:34,270
我们

324
00:12:34,270 --> 00:12:37,060
在日志中写入磁盘帮助的最后一个 Ellison 主

325
00:12:37,060 --> 00:12:39,130
记录，并指向我们最后一个

326
00:12:39,130 --> 00:12:42,840
成功的检查点 是

327
00:12:42,840 --> 00:12:44,680
从头开始的问题是为什么你需要

328
00:12:44,680 --> 00:12:47,740
在这里的页面 Ella 声音稍后会

329
00:12:47,740 --> 00:12:52,390
出现为什么我们需要这个它

330
00:12:52,390 --> 00:12:53,440
与当你试图

331
00:12:53,440 --> 00:12:55,810
弄清楚你正在重播日志时的

332
00:12:55,810 --> 00:12:58,810
事情有关 我就是这样 dy写

333
00:12:58,810 --> 00:13:01,000
了这个东西然后我在那里

334
00:13:01,000 --> 00:13:02,200
写了已经写出脏页，

335
00:13:02,200 --> 00:13:03,880
因此我不需要担心

336
00:13:03,880 --> 00:13:05,740
任何来了，在

337
00:13:05,740 --> 00:13:07,810
此之前，序列号kingka这

338
00:13:07,810 --> 00:13:09,250
就像一个边界，就像我把

339
00:13:09,250 --> 00:13:10,510
这个东西放在 这里的内存

340
00:13:10,510 --> 00:13:12,100
是 Ellison 的范围，可以

341
00:13:12,100 --> 00:13:15,960
修改我的页面

342
00:13:17,230 --> 00:13:25,240
是使页面变脏的那个范围是的，嘿，

343
00:13:25,240 --> 00:13:26,710
黄色 Sanders 这

344
00:13:26,710 --> 00:13:29,290
是使页面变脏的最后一个步行序列，所以

345
00:13:29,290 --> 00:13:33,370
它在这里，所以当我想去时决定

346
00:13:33,370 --> 00:13:35,890
是否可以刷新我的页面

347
00:13:35,890 --> 00:13:39,220


348
00:13:39,220 --> 00:13:43,950
如果最后一次更改发生在刷新 LSN 之前，我需要知道对该页面进行的最后更改是

349
00:13:43,950 --> 00:13:48,460


350
00:13:48,460 --> 00:13:52,450
什么，如果我知道我的更改在这里，并且它来自刷新，那么刷新 LSN 就是这个，如果这样的话

351
00:13:52,450 --> 00:13:54,400
，我会

352
00:13:54,400 --> 00:13:56,110
上升 东西已写入

353
00:13:56,110 --> 00:13:57,340
磁盘，但在写入磁盘之前我知道任何事情

354
00:13:57,340 --> 00:13:58,480
，因此

355
00:13:58,480 --> 00:14:07,780
我可以安全地选择该页面是的，

356
00:14:07,780 --> 00:14:10,750
因此在恢复期间您检查该

357
00:14:10,750 --> 00:14:12,910
范围，我们将在运行时刷新时获得该范围

358
00:14:12,910 --> 00:14:14,290
这

359
00:14:14,290 --> 00:14:19,780
第 我再次检查页面 Ellison 好的

360
00:14:19,780 --> 00:14:21,430
，主记录只是

361
00:14:21,430 --> 00:14:22,840
最后一个检查点的位置，

362
00:14:22,840 --> 00:14:25,330
我们在恢复时使用它来

363
00:14:25,330 --> 00:14:26,950
找出我们想要从哪里开始分析

364
00:14:26,950 --> 00:14:28,060
以查看日志以

365
00:14:28,060 --> 00:14:29,500
找出运行正确的内容，因为 如果没有

366
00:14:29,500 --> 00:14:30,550
没有这些检查点的主记录，

367
00:14:30,550 --> 00:14:32,200
我们必须从一开始就开始，

368
00:14:32,200 --> 00:14:33,640
因为我们不知道

369
00:14:33,640 --> 00:14:36,730
什么页面被写出来，

370
00:14:36,730 --> 00:14:39,790
就像我一样在这里非常清楚，因为缓冲

371
00:14:39,790 --> 00:14:41,050
池正在

372
00:14:41,050 --> 00:14:42,850
写出页面抱歉它正在刷新我们的页面 '没有

373
00:14:42,850 --> 00:14:45,340
记录，所以我们不知道

374
00:14:45,340 --> 00:14:47,470
你可能知道哪些页面

375
00:14:47,470 --> 00:14:49,240
被写出磁盘，如果我们

376
00:14:49,240 --> 00:14:51,220
在崩溃后恢复，我们只知道写出的日志

377
00:14:51,220 --> 00:14:54,090
序列号，

378
00:14:54,090 --> 00:14:56,500
所以这实际上只是一个

379
00:14:56,500 --> 00:14:58,060
例子 他在问所以

380
00:14:58,060 --> 00:15:00,130
让我们说我的页面埃里森指向

381
00:15:00,130 --> 00:15:03,100
这里的块他是第 12

382
00:15:03,100 --> 00:15:05,590
我的同花埃利森指向 16 我的

383
00:15:05,590 --> 00:15:08,170
熔岩把这个页面冲出来是的，

384
00:15:08,170 --> 00:15:09,550
因为埃里森的页面比

385
00:15:09,550 --> 00:15:11,350
同花小 埃里森让我们说

386
00:15:11,350 --> 00:15:12,670
其他手指向 19 的页面

387
00:15:12,670 --> 00:15:15,190
我可以写出不，因为我知道

388
00:15:15,190 --> 00:15:17,860


389
00:15:17,860 --> 00:15:20,350
与对该页面所做的最后一次更改相对应的日志记录

390
00:15:20,350 --> 00:15:21,880
没有在磁盘上，因此

391
00:15:21,880 --> 00:15:24,760
我逐出这个和再次这个是不安全的 你

392
00:15:24,760 --> 00:15:27,880
会在你的

393
00:15:27,880 --> 00:15:29,530
驱逐政策或替换政策中添加这个逻辑

394
00:15:29,530 --> 00:15:31,089
你会在你的缓冲之家实施

395
00:15:31,089 --> 00:15:33,639
注意什么是冲洗 LS

396
00:15:33,639 --> 00:15:34,990
结束什么意味着支付嫉妒结束并

397
00:15:34,990 --> 00:15:36,579
在你决定什么时跟踪所有这些事情

398
00:15:36,579 --> 00:15:40,350
-

399
00:15:41,250 --> 00:15:43,449
有点好，所以只是回顾一下我

400
00:15:43,449 --> 00:15:45,579
说的一切我都喜欢记录

401
00:15:45,579 --> 00:15:48,790
每次我们进行更改时都有一个 LS M 我们

402
00:15:48,790 --> 00:15:51,310
首先将条目添加到

403
00:15:51,310 --> 00:15:53,709
日志中 本地模拟

404
00:15:53,709 --> 00:15:55,690
记录中的日志记录到内存中的缓冲区然后

405
00:15:55,690 --> 00:15:58,449
我们返回一个 LS n 然后我们现在可以

406
00:15:58,449 --> 00:16:01,180
修改页面，这就是我们更新

407
00:16:01,180 --> 00:16:02,649
页面 l SN 的地方，因为我们已经

408
00:16:02,649 --> 00:16:03,970
在页面上保持了正确的闩锁，因此

409
00:16:03,970 --> 00:16:06,430
我们可以自动更新，然后

410
00:16:06,430 --> 00:16:08,320
每次我们都有 在受害者

411
00:16:08,320 --> 00:16:10,779
时代，我们只是总是更新这个flush

412
00:16:10,779 --> 00:16:12,670
allah发送的消息，以了解

413
00:16:12,670 --> 00:16:14,529
我们已经写了多远的法律，

414
00:16:14,529 --> 00:16:16,630
然后您现在可以开始截断

415
00:16:16,630 --> 00:16:19,269
该正确上方的日志，因为您不太可能

416
00:16:19,269 --> 00:16:24,370
在内存中需要它 所以让我们现在停下来，

417
00:16:24,370 --> 00:16:27,420
我们将遇到实际的事务，所以

418
00:16:27,420 --> 00:16:29,649
再次每个事务都将

419
00:16:29,649 --> 00:16:31,180
只是最低级别的读取和写入序列以

420
00:16:31,180 --> 00:16:32,860
进行恢复，这就是我们

421
00:16:32,860 --> 00:16:34,000
真正关心

422
00:16:34,000 --> 00:16:35,290
的我们对续集语句一无所知 进行

423
00:16:35,290 --> 00:16:37,149
物理或生理日志记录时，我们

424
00:16:37,149 --> 00:16:39,279
只看到读取和写入，而

425
00:16:39,279 --> 00:16:40,990
不是在事务完成时进行读取和写入

426
00:16:40,990 --> 00:16:43,660
，它在

427
00:16:43,660 --> 00:16:44,620
提交或中止时完成，

428
00:16:44,620 --> 00:16:47,139
因此假设将

429
00:16:47,139 --> 00:16:49,480
简化我们今天或

430
00:16:49,480 --> 00:16:51,699
以下的讨论，因此首先是我们

431
00:16:51,699 --> 00:16:53,380
很快每个日志记录都可以

432
00:16:53,380 --> 00:16:56,740
放入一个页面中，这只是

433
00:16:56,740 --> 00:16:59,050
意味着我们可以在

434
00:16:59,050 --> 00:17:01,329
一个页面上进行原子写入，您知道

435
00:17:01,329 --> 00:17:02,680
单个日志记录的所有内容，我们不用

436
00:17:02,680 --> 00:17:04,150
担心 我们的日志记录跨越

437
00:17:04,150 --> 00:17:06,280
多个页面并不难处理

438
00:17:06,280 --> 00:17:07,750
，您只需要添加一些校验

439
00:17:07,750 --> 00:17:09,849
和并说这是您知道这

440
00:17:09,849 --> 00:17:11,349
是此日志记录的哪些部分在此

441
00:17:11,349 --> 00:17:13,059
页面上与该页面上如果您没有

442
00:17:13,059 --> 00:17:14,470
看到它们 那么它被认为

443
00:17:14,470 --> 00:17:16,540
不是原子的，但出于我们的目的，我们只是

444
00:17:16,540 --> 00:17:18,189
假设它是一个页面 我们假设

445
00:17:18,189 --> 00:17:20,140
我们执行 4 KB 的原子页面写入

446
00:17:20,140 --> 00:17:22,150
我们还将假设

447
00:17:22,150 --> 00:17:23,890
我们只在数据库系统中进行单一版本控制

448
00:17:23,890 --> 00:17:26,290
和 我们只是

449
00:17:26,290 --> 00:17:27,939
对 pl 使用严格，所以我们不用担心

450
00:17:27,939 --> 00:17:31,540
奇怪的商业异常，正如我

451
00:17:31,540 --> 00:17:32,710
之前所说，我们也在做

452
00:17:32,710 --> 00:17:35,140
窃取没有力量只是暗示是

453
00:17:35,140 --> 00:17:36,820
你必须拥有它才能使所有

454
00:17:36,820 --> 00:17:40,480
这些工作，所以当交易时

455
00:17:40,480 --> 00:17:43,030
现在提交我们完全按照

456
00:17:43,030 --> 00:17:44,260
我们在将提交

457
00:17:44,260 --> 00:17:44,559
记录

458
00:17:44,559 --> 00:17:47,110
写入法律之前所做的工作，一旦该提交

459
00:17:47,110 --> 00:17:49,899
记录持久且刷新到磁盘，我们就

460
00:17:49,899 --> 00:17:51,580
可以告诉外界您的

461
00:17:51,580 --> 00:17:52,779
事务已成功提交

462
00:17:52,779 --> 00:17:54,940
正确，因为所有这些 ng

463
00:17:54,940 --> 00:17:56,649
该事务

464
00:17:56,649 --> 00:17:58,539
产生的所有日志记录必须

465
00:17:58,539 --> 00:18:01,120
在此提交记录之前写入日志，

466
00:18:01,120 --> 00:18:02,620
因此我们知道

467
00:18:02,620 --> 00:18:08,499
事务内部的所有内容都是持久的，

468
00:18:08,499 --> 00:18:10,240
尽管实际上尚未完全完成

469
00:18:10,240 --> 00:18:12,370
，因此即使我们告诉

470
00:18:12,370 --> 00:18:15,009
外界它是 承诺我们仍然可以

471
00:18:15,009 --> 00:18:17,309
维护一些关于

472
00:18:17,309 --> 00:18:20,830
该交易实际做了什么的内部元数据，

473
00:18:20,830 --> 00:18:23,740
我们将在更多的幻灯片中看到这一点，例如

474
00:18:23,740 --> 00:18:25,119
将保持一个表，上面

475
00:18:25,119 --> 00:18:27,690
写着我所有的活动交易，

476
00:18:27,690 --> 00:18:29,950
当我们真正完成所有这些时，

477
00:18:29,950 --> 00:18:32,259
所有的元数据 或者

478
00:18:32,259 --> 00:18:33,429
我们需要为该事务进行内部簿记，

479
00:18:33,429 --> 00:18:35,950
当所有这些完成后，我们

480
00:18:35,950 --> 00:18:37,659
将添加一个新的特殊日志记录，

481
00:18:37,659 --> 00:18:40,119
称为事务结束，这

482
00:18:40,119 --> 00:18:42,730
只是告诉数据库系统

483
00:18:42,730 --> 00:18:45,700
在恢复日志中我们将永远不会看到

484
00:18:45,700 --> 00:18:47,049
任何其他有关

485
00:18:47,049 --> 00:18:48,730
一旦我们看到这个交易

486
00:18:48,730 --> 00:18:50,139
结束，这个交易就会再次发生，因此我们可以将它从

487
00:18:50,139 --> 00:18:53,830
我们所有的内部簿记表中

488
00:18:53,830 --> 00:18:56,259
删除 在提交中，我们必须将其

489
00:18:56,259 --> 00:18:57,970
刷新到磁盘，然后才能

490
00:18:57,970 --> 00:19:00,070
告诉外部我们已提交我们

491
00:19:00,070 --> 00:19:02,320
不需要在事务端执行硬刷新或 fsync

492
00:19:02,320 --> 00:19:04,389
我们确实将它附加

493
00:19:04,389 --> 00:19:06,519
到日志缓冲区，它只是

494
00:19:06,519 --> 00:19:11,769
现在作为正常过程的一部分被写

495
00:19:11,769 --> 00:19:13,330
出来所以只是为了看看它是如何工作的

496
00:19:13,330 --> 00:19:17,080
所以这是我们的简单演示 所以在这里我们

497
00:19:17,080 --> 00:19:19,419
看到我们做了一个事务提交 然后我们

498
00:19:19,419 --> 00:19:21,639
现在刷新日志 我们更新

499
00:19:21,639 --> 00:19:24,850
刷新的 LSN 现在指向

500
00:19:24,850 --> 00:19:26,259
到我们生成的较少日志记录的最后一个日志序列

501
00:19:26,259 --> 00:19:28,389
，现在我们可以

502
00:19:28,389 --> 00:19:29,409
告诉外界我们的

503
00:19:29,409 --> 00:19:30,759
事务是安全的我们的事务是

504
00:19:30,759 --> 00:19:33,309
持久的我们已经完成但

505
00:19:33,309 --> 00:19:34,720
稍后我们会做一些

506
00:19:34,720 --> 00:19:36,519
额外的 处理，然后

507
00:19:36,519 --> 00:19:38,169
最终我们会写出一条事务

508
00:19:38,169 --> 00:19:40,629
结束消息，这只是

509
00:19:40,629 --> 00:19:42,399
在日志中的这一点上说，当我们

510
00:19:42,399 --> 00:19:43,659
进行恢复时，我们将

511
00:19:43,659 --> 00:19:45,970
永远不会再次看到此事务进行提交

512
00:19:45,970 --> 00:19:47,320
，没有那么多，

513
00:19:47,320 --> 00:19:48,429
我们实际上什么都没有 会做特别的

514
00:19:48,429 --> 00:19:49,990
在最后的中止提交之间，

515
00:19:49,990 --> 00:19:51,610
我们将看到为什么我们需要

516
00:19:51,610 --> 00:19:54,669
这个，正如我之前所说的，因为

517
00:19:54,669 --> 00:19:56,379
我们知道此时

518
00:19:56,379 --> 00:19:58,240
这里没有任何东西，

519
00:19:58,240 --> 00:19:59,260
我们实际上仍然需要

520
00:19:59,260 --> 00:20:00,460
让它像 提交已经被

521
00:20:00,460 --> 00:20:02,290
清除了，我们可以修剪日志

522
00:20:02,290 --> 00:20:04,240
并回收这些内存，我们使用

523
00:20:04,240 --> 00:20:06,070
它，这就是

524
00:20:06,070 --> 00:20:07,300
我在谈论

525
00:20:07,300 --> 00:20:09,070
上一堂课时想到的乒乓效应，当我们进行组提交时，我

526
00:20:09,070 --> 00:20:10,890
曾经为什么我知道这个日志缓冲区 是空的，

527
00:20:10,890 --> 00:20:12,850
因为我清除了所有内容，然后我

528
00:20:12,850 --> 00:20:14,410
可以使用它再次填充它，

529
00:20:14,410 --> 00:20:18,970
然后我读出另一个缓冲区，因此对于

530
00:20:18,970 --> 00:20:20,920
电路板，这与我们

531
00:20:20,920 --> 00:20:30,309
之前所做的不同，没有事务，

532
00:20:30,309 --> 00:20:32,800
只是作为恢复算法的内部标记

533
00:20:32,800 --> 00:20:34,240
也就是说，

534
00:20:34,240 --> 00:20:35,950
您将永远不会再看到此事务，您将永远不会看到此事务的

535
00:20:35,950 --> 00:20:41,309
任何其他

536
00:20:41,309 --> 00:20:44,230
日志记录，因为

537
00:20:44,230 --> 00:20:45,970
因为我们已经看到中止，所以

538
00:20:45,970 --> 00:20:47,290
当我们中止时它会更有意义，因为有些

539
00:20:47,290 --> 00:20:48,970
东西是你 你在中止之后做的事情是

540
00:20:48,970 --> 00:20:51,340
外部世界没有看到它

541
00:20:51,340 --> 00:20:53,230
不像你执行的查询但这是

542
00:20:53,230 --> 00:20:54,309
我们必须做的事情来逆转更改

543
00:20:54,309 --> 00:20:58,590
它会是的给我更多的幻灯片是的

544
00:21:02,520 --> 00:21:11,110
这场比赛是正确的 一个

545
00:21:11,110 --> 00:21:13,179
在这里它什么时候被刷新，

546
00:21:13,179 --> 00:21:15,480
它是缓冲池替换策略

547
00:21:15,480 --> 00:21:19,960
是什么 - 这是正确的，所以一个是你

548
00:21:19,960 --> 00:21:21,280
需要释放空间你必须让 Vic 将

549
00:21:21,280 --> 00:21:23,880
它的标记分页如果你刷新

550
00:21:23,880 --> 00:21:25,600
它另一个可能是背景

551
00:21:25,600 --> 00:21:27,070
我认为我们简要讨论过的作家

552
00:21:27,070 --> 00:21:28,870
和一些数据库系统

553
00:21:28,870 --> 00:21:31,929
它们只是一个单独的你在后台有一个

554
00:21:31,929 --> 00:21:33,400
单独的进程或线程

555
00:21:33,400 --> 00:21:35,050
，偶尔会

556
00:21:35,050 --> 00:21:37,240
遍历缓冲池找到所有

557
00:21:37,240 --> 00:21:39,790
脏页，然后在之前将它们写出来

558
00:21:39,790 --> 00:21:41,050
当它不是受害者时，它

559
00:21:41,050 --> 00:21:42,429
说嘿，让我把你写出来，然后我

560
00:21:42,429 --> 00:21:43,510
转过头说你不再脏

561
00:21:43,510 --> 00:21:44,020
了

562
00:21:44,020 --> 00:21:45,429
，这样当缓冲区将

563
00:21:45,429 --> 00:21:48,220
在策略运行中替换并且它想要驱逐一个

564
00:21:48,220 --> 00:21:49,960
页面时，嘿，我明白了 一种

565
00:21:49,960 --> 00:21:51,820
标记为干净的艺术我 可以删除它而

566
00:21:51,820 --> 00:21:55,809
不必写出来，但这

567
00:21:55,809 --> 00:21:56,890
与我们在这里谈论的内容无关，这

568
00:21:56,890 --> 00:21:58,330
在某些方面又

569
00:21:58,330 --> 00:22:00,190
是正确的头部日志的美妙之处在于我们

570
00:22:00,190 --> 00:22:03,309
可以将策略与

571
00:22:03,309 --> 00:22:04,690
我们拥有的内容分开

572
00:22:04,690 --> 00:22:05,679
除了确保我们没有大的

573
00:22:05,679 --> 00:22:06,910
事情，没有日志记录

574
00:22:06,910 --> 00:22:08,890
出磁盘，或者我们可以将

575
00:22:08,890 --> 00:22:11,140
决策过程

576
00:22:11,140 --> 00:22:17,820
与正确的头部日志部分分开是很抱歉，

577
00:22:19,410 --> 00:22:21,820
所以声明是如果刷新 LS n

578
00:22:21,820 --> 00:22:24,400
小于 页面 LS n 那么你不能

579
00:22:24,400 --> 00:22:26,140
驱逐那个页面，因为你知道

580
00:22:26,140 --> 00:22:27,760


581
00:22:27,760 --> 00:22:31,570
你写的最后一个日志记录是在这个之前，

582
00:22:31,570 --> 00:22:33,790
所以修改这个页面的日志记录

583
00:22:33,790 --> 00:22:42,040
还没有在磁盘上，所以这个

584
00:22:42,040 --> 00:22:44,410
问题是 如果您的受害者策略正在

585
00:22:44,410 --> 00:22:48,090
运行，您会说哦，我的刷新 LS n

586
00:22:48,090 --> 00:22:51,130
小于所有页面 LS 结束

587
00:22:51,130 --> 00:22:52,360
所有图片 我

588
00:22:52,360 --> 00:22:54,970
日志中的所有脏页 我们所有的数据页 我喜欢池

589
00:22:54,970 --> 00:22:58,570
我所有的页 我的紫色是脏的

590
00:22:58,570 --> 00:23:00,970
你必须拖延吗？你必须写信吗？  te

591
00:23:00,970 --> 00:23:02,410
up一个你不能做的磁盘，你

592
00:23:02,410 --> 00:23:05,620
无能为力，这就是

593
00:23:05,620 --> 00:23:07,240
背景作家应该做的

594
00:23:07,240 --> 00:23:08,830
事情，就像我知道我有一些空闲

595
00:23:08,830 --> 00:23:11,590


596
00:23:11,590 --> 00:23:12,910
时间我可以提前写出这些东西，所以我没有' 不必拖延

597
00:23:12,910 --> 00:23:14,530
我不在关键路径上，因为

598
00:23:14,530 --> 00:23:17,320
我再次执行事务，

599
00:23:17,320 --> 00:23:19,150
你能做的最糟糕的事情是我正在运行

600
00:23:19,150 --> 00:23:20,620
一个事务它获取一堆

601
00:23:20,620 --> 00:23:22,600
锁然后我必须做一堆磁盘

602
00:23:22,600 --> 00:23:24,550
i/o 因为 现在只是支持

603
00:23:24,550 --> 00:23:26,200
每个人，一切都变慢了

604
00:23:26,200 --> 00:23:27,640
所以如果我可以在后台做一些事情，

605
00:23:27,640 --> 00:23:29,380
现在它不在关键

606
00:23:29,380 --> 00:23:30,520
路径上，而我持有锁，

607
00:23:30,520 --> 00:23:31,720
交易可以更快地完成

608
00:23:31,720 --> 00:23:34,570
，但是你如何在两者之间平衡，

609
00:23:34,570 --> 00:23:37,030
比如刷新 这刷新日志

610
00:23:37,030 --> 00:23:38,380
刷新刷新后台内容

611
00:23:38,380 --> 00:23:39,940
这是数据库系统必须弄清楚的棘手的事情

612
00:23:39,940 --> 00:23:42,370
我们不会

613
00:23:42,370 --> 00:23:47,650
让操作系统为我们做这件事，所以中止

614
00:23:47,650 --> 00:23:52,660
中止将成为一种特殊情况，

615
00:23:52,660 --> 00:23:55,210
我们将在下 我们

616
00:23:55,210 --> 00:23:58,000
要逆转的战神

617
00:23:58,000 --> 00:24:00,490
交易的更改，但我们实际上

618
00:24:00,490 --> 00:24:05,110
最终会添加日志记录以

619
00:24:05,110 --> 00:24:06,670
跟踪我们将撤消这些

620
00:24:06,670 --> 00:24:09,130
更改这与我们迄今为止谈论的方式不同，

621
00:24:09,130 --> 00:24:10,840
就像他每次

622
00:24:10,840 --> 00:24:12,340
说哦我们中止事务回滚

623
00:24:12,340 --> 00:24:14,380
说的那样 我们只是假设我们现在可以

624
00:24:14,380 --> 00:24:16,690
撤消内存中的一些内容我们

625
00:24:16,690 --> 00:24:18,010
需要跟踪

626
00:24:18,010 --> 00:24:21,370
我们在反向事务时所做的一切，

627
00:24:21,370 --> 00:24:24,010
因此我们将

628
00:24:24,010 --> 00:24:25,060
在

629
00:24:25,060 --> 00:24:26,950
我们的日志记录中添加一个额外的字段，称为 pre bel SM

630
00:24:26,950 --> 00:24:29,830
和 这不是必需的，但这

631
00:24:29,830 --> 00:24:31,390
只会让您在运行时的生活更轻松，

632
00:24:31,390 --> 00:24:32,980
因为现在您可以知道如何

633
00:24:32,980 --> 00:24:34,780
跳回以找到下一个您

634
00:24:34,780 --> 00:24:36,160
需要为给定事务反转的事情

635
00:24:36,160 --> 00:24:38,110
I 避免对

636
00:24:38,110 --> 00:24:39,580
您认为的所有内容进行某种扫描

637
00:24:39,580 --> 00:24:40,450
就像对于每笔交易一样，

638
00:24:40,450 --> 00:24:41,770
你正在生成一个

639
00:24:41,770 --> 00:24:43,930
链表，为每个中止的

640
00:24:43,930 --> 00:24:45,040
交易说这里是链表，

641
00:24:45,040 --> 00:24:46,540
这里是我需要撤销的所有更改，

642
00:24:46,540 --> 00:24:48,790
所以我需要知道如何返回

643
00:24:48,790 --> 00:24:52,960
一个接一个地反转它们，所以

644
00:24:52,960 --> 00:24:54,640
我们再次拥有像这样的简单事务，

645
00:24:54,640 --> 00:24:57,040
现在我们有了 pls n 和之前的

646
00:24:57,040 --> 00:25:00,520
LSM，因此对于该事务 t4 的第一个 else

647
00:25:00,520 --> 00:25:02,050
和第一个日志记录，

648
00:25:02,050 --> 00:25:05,110
因为

649
00:25:05,110 --> 00:25:07,690
在 begin 语句中没有以前的 Ellison 我们只是

650
00:25:07,690 --> 00:25:11,380
将之前的 Ellison 设置为 null 以便

651
00:25:11,380 --> 00:25:13,120
此事务运行它会进行一些

652
00:25:13,120 --> 00:25:16,570
更改但随后它会中止所以现在

653
00:25:16,570 --> 00:25:18,940
我们需要做的是撤消这些更改

654
00:25:18,940 --> 00:25:21,520
我将为这些添加日志条目

655
00:25:21,520 --> 00:25:24,130
然后一旦我们知道所有这些日志

656
00:25:24,130 --> 00:25:25,960
条目已经在磁盘中持久化，

657
00:25:25,960 --> 00:25:28,330
然后我们可以再次添加事务结束

658
00:25:28,330 --> 00:25:30,370
消息，这就是我所说的，

659
00:25:30,370 --> 00:25:32,110
这是说事务 MS

660
00:25:32,110 --> 00:25:35,650
是 a 表示没有

661
00:25:35,650 --> 00:25:37,780
其他任何事情可以

662
00:25:37,780 --> 00:25:39,220
在我们以后发生此事务 我们已经

663
00:25:39,220 --> 00:25:40,570
逆转了我已经完成了我们

664
00:25:40,570 --> 00:25:44,500
需要做的一切，

665
00:25:44,500 --> 00:25:45,640
当你谈论 Nexus 时，这部分在这里知道我们如何

666
00:25:45,640 --> 00:25:48,040
实际记录我们进行时正在逆转的变化，

667
00:25:48,040 --> 00:25:51,130
所以这些被

668
00:25:51,130 --> 00:25:53,310
称为补偿 离子日志记录或 CLRS

669
00:25:53,310 --> 00:25:56,290
所以 CLR 就像一个更新

670
00:25:56,290 --> 00:25:58,960
记录，但它是它在事务实际运行

671
00:25:58,960 --> 00:26:01,210
时反转实际更新记录的更改是的

672
00:26:01,210 --> 00:26:06,750


673
00:26:13,410 --> 00:26:14,730
所以你的问题是为什么我们甚至

674
00:26:14,730 --> 00:26:16,170
有以前的 Ellison 这

675
00:26:16,170 --> 00:26:22,980
实际上是什么 买我们 是的 她的问题

676
00:26:22,980 --> 00:26:24,180
你的陈述是你能不能

677
00:26:24,180 --> 00:26:26,370
检查这个简单的例子 只是找到所有

678
00:26:26,370 --> 00:26:28,560
t4 的东西，然后

679
00:26:28,560 --> 00:26:29,700
找出那些我需要河流的东西

680
00:26:29,700 --> 00:26:32,670
是的，但是如果我像高端系统一样运行怎么办

681
00:26:32,670 --> 00:26:34,110


682
00:26:34,110 --> 00:26:36,810
每秒一百万笔交易，我现在崩溃了 我

683
00:26:36,810 --> 00:26:39,240
有任何给定的时间，当我崩溃时，我

684
00:26:39,240 --> 00:26:40,590
可能有十万

685
00:26:40,590 --> 00:26:42,690
笔交易在进行中，这样就

686
00:26:42,690 --> 00:26:44,280
不必一遍又一遍地扫描所有内容

687
00:26:44,280 --> 00:26:45,630
以找到您确切地知道我

688
00:26:45,630 --> 00:26:48,300
需要什么来扭转这种情况 只是

689
00:26:48,300 --> 00:26:50,430
让我们到达那里的帮手所以它不需要

690
00:26:50,430 --> 00:26:52,170
正确性它可以为了方便而使用它

691
00:26:52,170 --> 00:26:57,230
是的

692
00:26:57,260 --> 00:27:02,760
为什么我们需要反转所以对于这个

693
00:27:02,760 --> 00:27:06,630
例子不但是你怎么知道在真实系统中的现实

694
00:27:06,630 --> 00:27:09,540
生活中做了什么 我说我

695
00:27:09,540 --> 00:27:11,490
说我们不知道我们没有记录

696
00:27:11,490 --> 00:27:13,650
我们写入磁盘的页面我们对写入磁盘的

697
00:27:13,650 --> 00:27:14,550
内容一无所知，

698
00:27:14,550 --> 00:27:16,380
因为驱逐

699
00:27:16,380 --> 00:27:19,230
政策正在做自己的事情，这就是为什么

700
00:27:19,230 --> 00:27:20,670
我们 小心翼翼 我只是

701
00:27:20,670 --> 00:27:25,470
颠倒一切，所以 CLR 再次它

702
00:27:25,470 --> 00:27:27,600
会像一个更新日志记录，

703
00:27:27,600 --> 00:27:30,800
它会有前后值，

704
00:27:30,800 --> 00:27:33,180
但它会被绑定到

705
00:27:33,180 --> 00:27:34,590
在

706
00:27:34,590 --> 00:27:37,140
事务正常生命周期中实际发生的更新记录，然后

707
00:27:37,140 --> 00:27:38,490
我们将有这个撤销下一个指针

708
00:27:38,490 --> 00:27:40,380
，再次只是为了方便谁可以

709
00:27:40,380 --> 00:27:42,330
告诉我们下一个我们需要反转的 LSN 是什么，

710
00:27:42,330 --> 00:27:46,650
以便我们知道你知道

711
00:27:46,650 --> 00:27:48,090
每个给定的交易我们会知道

712
00:27:48,090 --> 00:27:49,740
我们是否真的处理了所有

713
00:27:49,740 --> 00:27:51,150
我们 需要我们需要这个过程来

714
00:27:51,150 --> 00:27:54,630
逆转所有这些变化，所以 CLR

715
00:27:54,630 --> 00:27:55,890
会像任何其他日志记录一样被添加到法律中，

716
00:27:55,890 --> 00:27:57,600
但是它们

717
00:27:57,600 --> 00:27:59,640
会在事务中止后添加

718
00:27:59,640 --> 00:28:03,030
，然后一旦我们完成了逆转

719
00:28:03,030 --> 00:28:04,560
一切，然后我们添加 反式 saction

720
00:28:04,560 --> 00:28:04,890
end

721
00:28:04,890 --> 00:28:08,250
所以不像commit with commit 我必须在我告诉外界我已经提交

722
00:28:08,250 --> 00:28:10,770
之前将所有日志记录刷新到磁盘，

723
00:28:10,770 --> 00:28:11,790


724
00:28:11,790 --> 00:28:13,530
如果事务被中止，我们

725
00:28:13,530 --> 00:28:14,970
立即返回到

726
00:28:14,970 --> 00:28:16,530
你登上的应用程序，他们不需要

727
00:28:16,530 --> 00:28:18,540
等待 在磁盘上写任何东西，

728
00:28:18,540 --> 00:28:21,720
因为谁在乎他们会尝试

729
00:28:21,720 --> 00:28:23,160
去阅读他们的更改不

730
00:28:23,160 --> 00:28:24,360
会这样做，只要我们

731
00:28:24,360 --> 00:28:26,620
使用正确的内核协议运行，

732
00:28:26,620 --> 00:28:29,140
所以 CLR 只会记录任何其他

733
00:28:29,140 --> 00:28:30,669
记录，然后他们只是 被冲洗

734
00:28:30,669 --> 00:28:33,250
掉你知道最终它是在某个

735
00:28:33,250 --> 00:28:36,490
时候所以让我们看一个例子我们将如何

736
00:28:36,490 --> 00:28:38,169
去 UCL RS 所以因为我

737
00:28:38,169 --> 00:28:39,970
在幻灯片上的空间用完了因为我们

738
00:28:39,970 --> 00:28:41,830
有太多太多的冥想领域

739
00:28:41,830 --> 00:28:43,390
我现在要去 以表格形式显示，

740
00:28:43,390 --> 00:28:45,880
所以这里我们有一个事务 t1

741
00:28:45,880 --> 00:28:48,490
它只是更新 哦，名称

742
00:28:48,490 --> 00:28:50,710
，然后它中止 我们不关心

743
00:28:50,710 --> 00:28:52,360
它是如何中止事务

744
00:28:52,360 --> 00:28:54,070
应用程序对边界或

745
00:28:54,070 --> 00:28:55,840
数据库系统当前协议说的  说

746
00:28:55,840 --> 00:28:57,400
要中止它我们不在乎它都是

747
00:28:57,400 --> 00:28:59,799
一样的所以现在当我们想要开始

748
00:28:59,799 --> 00:29:01,990
撤消它的更改时这是

749
00:29:01,990 --> 00:29:03,789
在常规执行期间这不是

750
00:29:03,789 --> 00:29:05,110
在恢复期间因为我们正在

751
00:29:05,110 --> 00:29:07,149
处理事务我们将

752
00:29:07,149 --> 00:29:10,330
创建一个 CLR 条目将与

753
00:29:10,330 --> 00:29:13,149
它所做的更新赌注相关联，

754
00:29:13,149 --> 00:29:14,620
它看起来与第一个完全

755
00:29:14,620 --> 00:29:15,940
一样，只是前后

756
00:29:15,940 --> 00:29:18,340
值颠倒了，所以在值是 30 之前

757
00:29:18,340 --> 00:29:20,500
，然后在更新之后是 40 所以

758
00:29:20,500 --> 00:29:21,970
现在我们' 重新做一个逆转或

759
00:29:21,970 --> 00:29:25,950
将旧值设置回 30

760
00:29:25,950 --> 00:29:29,740
正确，然后我们有这个撤消下

761
00:29:29,740 --> 00:29:31,809
一条记录，艾莉森说

762
00:29:31,809 --> 00:29:34,179
我们需要撤消的下一件事情是什么来完全

763
00:29:34,179 --> 00:29:35,919
逆转这个交易，但在这个

764
00:29:35,919 --> 00:29:38,320
特定的例子中，撤消埃里森

765
00:29:38,320 --> 00:29:40,750
去了 到开始语句，所以我们知道

766
00:29:40,750 --> 00:29:41,950
我们没有其他东西可以

767
00:29:41,950 --> 00:29:43,630
撤销这笔交易，所以我们可以

768
00:29:43,630 --> 00:29:50,909
继续添加我们的交易结束记录是的，

769
00:29:57,149 --> 00:30:00,279
这个问题是我说的，当

770
00:30:00,279 --> 00:30:02,529
您中止社区时，请返回

771
00:30:02,529 --> 00:30:04,090
应用程序 ion 并说您的事务

772
00:30:04,090 --> 00:30:06,010
中止并且您不必

773
00:30:06,010 --> 00:30:07,210
将这些东西中的任何一个写入磁盘

774
00:30:07,210 --> 00:30:19,539
正确的语句是我说如果

775
00:30:19,539 --> 00:30:21,159
您真的告诉外界您

776
00:30:21,159 --> 00:30:24,700
中止了但是您创建了这些

777
00:30:24,700 --> 00:30:26,890
日志记录，您将反转 改变，但

778
00:30:26,890 --> 00:30:34,690
随后你崩溃了，你是对的，所以

779
00:30:34,690 --> 00:30:38,700
你是对的，你可能会失去这些，我们在乎

780
00:30:39,180 --> 00:30:46,450
他在摇头，不，为什么好吧，是的，

781
00:30:46,450 --> 00:30:48,460
你会厌烦它，但喜欢

782
00:30:48,460 --> 00:30:52,300
更基本的正确的东西，

783
00:30:52,300 --> 00:30:54,280
所以页面被修改了，但是

784
00:30:54,280 --> 00:30:57,460
这个 事务不在磁盘上，所以谁

785
00:30:57,460 --> 00:31:13,710
在乎一半抱歉是的谁在乎

786
00:31:18,390 --> 00:31:20,440
你能撤消它因为他们没有

787
00:31:20,440 --> 00:31:24,400
提交正确所以我们会再次看到这个

788
00:31:24,400 --> 00:31:26,320
，例如，如果我不知道

789
00:31:26,320 --> 00:31:29,110
我是否在这里崩溃并且 我不明白事务

790
00:31:29,110 --> 00:31:30,520
的最终决定是什么，

791
00:31:30,520 --> 00:31:31,920
其中提交的

792
00:31:31,920 --> 00:31:36,040
中止没有中止，

793
00:31:36,040 --> 00:31:37,120
这就是前面日志的美妙之处，这是一个单一的

794
00:31:37,120 --> 00:31:38,230
源位置，告诉我们事务中

795
00:31:38,230 --> 00:31:40,840
发生的事情的最终结果是什么

796
00:31:40,840 --> 00:31:42,910
我们到了这里说我们得到了

797
00:31:42,910 --> 00:31:46,630
在这里，我们中止了我们告诉 AUSA 或者

798
00:31:46,630 --> 00:31:49,180
我们中止了我们在做所有这些事情之前崩溃了

799
00:31:49,180 --> 00:31:51,760
谁在乎因为

800
00:31:51,760 --> 00:31:54,130
交易中止了我们不必

801
00:31:54,130 --> 00:31:55,720
保证任何东西的持久性我们

802
00:31:55,720 --> 00:31:57,040
回来就好像它不存在

803
00:31:57,040 --> 00:31:58,330
因为我们 将反转任何

804
00:31:58,330 --> 00:32:01,410
可能已正确写入磁盘的更改，

805
00:32:02,940 --> 00:32:06,520
因此，如果页面已写入

806
00:32:06,520 --> 00:32:08,050
磁盘，您将看到无论如何您都必须查看

807
00:32:08,050 --> 00:32:11,110
所有这些内容，因此我们知道如何

808
00:32:11,110 --> 00:32:12,100
在必要时将其恢复为正确状态

809
00:32:12,100 --> 00:32:26,110
是这里是 所以这么说

810
00:32:26,110 --> 00:32:27,640
好吧 所以说他们说他们告诉我们

811
00:32:27,640 --> 00:32:28,990
从应用程序从终端回滚

812
00:32:28,990 --> 00:32:33,640
然后我们可以将此

813
00:32:33,640 --> 00:32:35,680
日志记录附加到内存中的红发日志中

814
00:32:35,680 --> 00:32:38,170
返回并见面 e 告诉他们

815
00:32:38,170 --> 00:32:40,420
它中止然后现在开始

816
00:32:40,420 --> 00:32:43,300
清理 它的所有内部更改都是正确的，所以我们

817
00:32:43,300 --> 00:32:44,590
不必我们不必等待

818
00:32:44,590 --> 00:32:47,110


819
00:32:47,110 --> 00:32:48,970
清理它修改的所有内容我们可以立即告诉他们

820
00:32:48,970 --> 00:32:50,559


821
00:32:50,559 --> 00:32:57,370
我提交并提交说我已经提交

822
00:32:57,370 --> 00:32:58,059


823
00:32:58,059 --> 00:33:00,309
如果 戴维斯没有告诉他告诉你

824
00:33:00,309 --> 00:33:02,409
你提交了它必须保证

825
00:33:02,409 --> 00:33:04,149
一切都是持久的所以它必须

826
00:33:04,149 --> 00:33:07,240
准备好

827
00:33:07,240 --> 00:33:08,740
与它所做的更改相对应的任何日志记录

828
00:33:08,740 --> 00:33:10,840
都必须写入磁盘到

829
00:33:10,840 --> 00:33:12,309
提交我们不

830
00:33:12,309 --> 00:33:17,470
关心我们内部的事务结束整齐

831
00:33:17,470 --> 00:33:19,720
回来是的，我在想为什么

832
00:33:19,720 --> 00:33:21,730
像谁在乎我中止了为什么我

833
00:33:21,730 --> 00:33:23,110
在乎你会做很多事情我停下

834
00:33:23,110 --> 00:33:24,490
来清理东西为什么我要等待

835
00:33:24,490 --> 00:33:35,559
所以这个问题适用于任何

836
00:33:35,559 --> 00:33:38,169
交易想要修改

837
00:33:38,169 --> 00:33:40,119
被事务委员会修改的同一页面

838
00:33:40,119 --> 00:33:42,340
是否需要

839
00:33:42,340 --> 00:33:48,129
等到修改它的日志记录

840
00:33:48,129 --> 00:33:52,529
写出磁盘没有

841
00:33:52,529 --> 00:33:55,809
权利因为如果我喜欢说我在这里登

842
00:33:55,809 --> 00:33:57,909
我说这不是这不是 一个

843
00:33:57,909 --> 00:34:01,210
页面我在这里中止 我只能释放

844
00:34:01,210 --> 00:34:02,889
它所能做的假设今天的锁定 我

845
00:34:02,889 --> 00:34:04,570
释放我在该页面上的正确锁定

846
00:34:04,570 --> 00:34:07,360
现在任何其他事务都可以

847
00:34:07,360 --> 00:34:09,520
开始修改它，因此他们开始

848
00:34:09,520 --> 00:34:10,719
修改将

849
00:34:10,719 --> 00:34:13,599
要执行的操作 创建  新的日志记录

850
00:34:13,599 --> 00:34:16,168
增加了我页面的页面 LSN，

851
00:34:16,168 --> 00:34:18,280
因此该页面无法

852
00:34:18,280 --> 00:34:20,589
写出磁盘，直到我的新日志记录了

853
00:34:20,589 --> 00:34:24,129
每个不是磁盘的新日志，所以谁在乎谁

854
00:34:24,129 --> 00:34:25,418
在乎这是交易

855
00:34:25,418 --> 00:34:44,560
修改你哭如果我 如果我

856
00:34:44,560 --> 00:34:48,550
尝试读取更改可能会尝试做 如果我是一个

857
00:34:48,550 --> 00:34:50,230
中止的事务 我必须

858
00:34:50,230 --> 00:34:53,849
在我被允许读取之前反转它们是的，

859
00:34:57,730 --> 00:35:00,200
当我们说写了一个写了内存的磁盘时

860
00:35:00,200 --> 00:35:03,290
是的，是的，你必须是

861
00:35:03,290 --> 00:35:05,210
你 我的意思是

862
00:35:05,210 --> 00:35:12,170
，如果它是单一版本，那么他的方式总是正确的，

863
00:35:12,170 --> 00:35:14,900
是的，多版本知道，因为

864
00:35:14,900 --> 00:35:16,820
多版本的权利谁在乎，

865
00:35:16,820 --> 00:35:18,290
因为你现在只有一个

866
00:35:18,290 --> 00:35:21,440
不再存在的版本，你

867
00:35:21,440 --> 00:35:26,240
忽略它是在单一版本中 是的，

868
00:35:26,240 --> 00:35:27,200
你让你反过来做这些

869
00:35:27,200 --> 00:35:51,740
事情是的是的，同样是假设我有

870
00:35:51,740 --> 00:35:54,110
一个交易，它进行了很多

871
00:35:54,110 --> 00:35:58,400
更新让更新让你

872
00:35:58,400 --> 00:36:01,270
应用所有更新，但其中一半

873
00:36:01,270 --> 00:36:05,630
被写到磁盘我如何反转

874
00:36:05,630 --> 00:36:07,310
这些更改现在已在

875
00:36:07,310 --> 00:36:08,720
磁盘上 因为这是窃取政策我

876
00:36:08,720 --> 00:36:10,790
有很多提交我宁愿

877
00:36:10,790 --> 00:36:13,010
清除脏页是的你必须

878
00:36:13,010 --> 00:36:16,100
将它们带回来并在

879
00:36:16,100 --> 00:36:17,630
你实际这样做时反转它们，无论是

880
00:36:17,630 --> 00:36:19,940
在中止时立即执行还是在中止时执行 这样

881
00:36:19,940 --> 00:36:23,360
做你懒洋洋地知道哦，当

882
00:36:23,360 --> 00:36:24,800
有人下次有人去

883
00:36:24,800 --> 00:36:27,340
阅读它时，我会扭转它

884
00:36:27,340 --> 00:36:33,380
是的，我喜欢这个问题，有些

885
00:36:33,380 --> 00:36:36,530
人不要

886
00:36:36,530 --> 00:36:38,420
像巴勃罗教授一样在YouTube上抱怨，我

887
00:36:38,420 --> 00:36:40,130
喜欢你 班级我喜欢这些材料，但

888
00:36:40,130 --> 00:36:41,210
所有那些讨厌的学生一直

889
00:36:41,210 --> 00:36:43,040
打断我问问题糟糕的

890
00:36:43,040 --> 00:36:46,010
家伙，让他开始 CMU 并来

891
00:36:46,010 --> 00:36:50,180
问问题好吧，所以

892
00:36:50,180 --> 00:36:51,320
现在我们的董事会倡导我们已经

893
00:36:51,320 --> 00:36:53,240
说过了，我们要写一个董事会

894
00:36:53,240 --> 00:36:55,040
将每个事务的记录记录到日志中

895
00:36:55,040 --> 00:36:57,590
，然后我们

896
00:36:57,590 --> 00:36:59,480
将以与事务相反的顺序回放事务更新

897
00:36:59,480 --> 00:37:01,400
，然后

898
00:37:01,400 --> 00:37:03,560
对于我们将要反转的所有内容，我们将一个

899
00:37:03,560 --> 00:37:05,600
CLR 条目添加到与原始更新相关的日志中

900
00:37:05,600 --> 00:37:06,650
发生的 d 在

901
00:37:06,650 --> 00:37:08,750
正常操作中，然后我们存储

902
00:37:08,750 --> 00:37:09,770
值的版本

903
00:37:09,770 --> 00:37:12,340
，然后一旦我们完成所有这些

904
00:37:12,340 --> 00:37:15,500
事务，这些 CLRS 一旦我们完成

905
00:37:15,500 --> 00:37:16,490
了它们需要为该事务执行的所有操作，

906
00:37:16,490 --> 00:37:18,140
那么我们可以添加

907
00:37:18,140 --> 00:37:21,530
事务结束消息，因此 CLRS 将

908
00:37:21,530 --> 00:37:25,850
永远不需要 做得很好，我们

909
00:37:25,850 --> 00:37:28,430
只能在达勒姆恢复期间重做它们，

910
00:37:28,430 --> 00:37:31,550
因为它就像一个单向

911
00:37:31,550 --> 00:37:36,770
更新，好吧，所以现在你已经

912
00:37:36,770 --> 00:37:37,670
涵盖了到目前为止，但现在我们知道我们

913
00:37:37,670 --> 00:37:39,290
有很长的序列号，我们有这些

914
00:37:39,290 --> 00:37:41,030
CLRS，我们知道如何保持

915
00:37:41,030 --> 00:37:42,560
跟踪 Ellison 在不同位置的位置，以便

916
00:37:42,560 --> 00:37:44,090
我们

917
00:37:44,090 --> 00:37:46,610
弄清楚磁盘上写了些什么，现在让我们

918
00:37:46,610 --> 00:37:48,290
谈谈我们将如何带来

919
00:37:48,290 --> 00:37:49,490
一些额外的元数据来

920
00:37:49,490 --> 00:37:50,690
确定当时系统中正在运行的内容

921
00:37:50,690 --> 00:37:53,450
和 使用它是一个更好的检查点

922
00:37:53,450 --> 00:37:56,030
方案，所以在我们上一堂课中，我说

923
00:37:56,030 --> 00:37:58,580
检查

924
00:37:58,580 --> 00:38:00,440
点对于我们能够弄清楚我们

925
00:38:00,440 --> 00:38:02,090
可以在什么时候开始

926
00:38:02,090 --> 00:38:03,680
恢复数据库是必要的，因为没有

927
00:38:03,680 --> 00:38:05,630
检查点 我们可能必须

928
00:38:05,630 --> 00:38:07,670
查看整个日志 如果我们有

929
00:38:07,670 --> 00:38:09,140
一年的价值 没有

930
00:38:09,140 --> 00:38:10,730
检查点的日志 我们可能有可能

931
00:38:10,730 --> 00:38:12,650
重播一年的价值

932
00:38:12,650 --> 00:38:15,560
法律可能需要很长时间 所以让我们

933
00:38:15,560 --> 00:38:17,210
看看采取检查点的两种不好的方法

934
00:38:17,210 --> 00:38:19,430
我们将看到为什么模糊检查点

935
00:38:19,430 --> 00:38:21,800
是更好的方法，所以如果我在

936
00:38:21,800 --> 00:38:24,530
上节课讨论这些坏方法之一，我说

937
00:38:24,530 --> 00:38:26,570
我们将使用的技术

938
00:38:26,570 --> 00:38:30,950
是停止任何新事务的执行

939
00:38:30,950 --> 00:38:34,370
，然后采取

940
00:38:34,370 --> 00:38:35,690
检查点，这将保证

941
00:38:35,690 --> 00:38:38,390
我的页面

942
00:38:38,390 --> 00:38:40,430
作为该检查点的一部分写出磁盘是

943
00:38:40,430 --> 00:38:43,010
一致的没有来自

944
00:38:43,010 --> 00:38:44,120
正在运行中途的事务的

945
00:38:44,120 --> 00:38:46,520
撕裂更新所以基本上发生的事情

946
00:38:46,520 --> 00:38:47,870
发生在网络的前端

947
00:38:47,870 --> 00:38:49,670
网络层我们停止

948
00:38:49,670 --> 00:38:51,290
任何新事务的执行，

949
00:38:51,290 --> 00:38:53,030
然后我们只是等待我们所有的工作人员

950
00:38:53,030 --> 00:38:54,950
完成执行任何

951
00:38:54,950 --> 00:38:58,040
已经运行的事务，所以这显然很糟糕，

952
00:38:58,040 --> 00:39:01,400
因为我们有 o 等到

953
00:39:01,400 --> 00:39:03,080
所有您认识的所有

954
00:39:03,080 --> 00:39:04,220
事务完成我们无法开始

955
00:39:04,220 --> 00:39:06,290
执行任何新事务所以我们有一个

956
00:39:06,290 --> 00:39:07,700
事务需要五个小时

957
00:39:07,700 --> 00:39:09,770
才能运行他们已经等待

958
00:39:09,770 --> 00:39:11,870
五个小时完成等待它

959
00:39:11,870 --> 00:39:13,340
完成之前 我们继续执行

960
00:39:13,340 --> 00:39:14,600
检查行，然后在此期间我们

961
00:39:14,600 --> 00:39:16,760
无法执行任何其他事务，因此从恢复的角度来看，

962
00:39:16,760 --> 00:39:19,000
我们的系统看起来完全没有响应

963
00:39:19,000 --> 00:39:21,410
，

964
00:39:21,410 --> 00:39:23,630
这很棒，

965
00:39:23,630 --> 00:39:25,100
因为检查点是一致的，正如我

966
00:39:25,100 --> 00:39:27,110
所说的没有 中间更新

967
00:39:27,110 --> 00:39:28,880
它就像你知道它只

968
00:39:28,880 --> 00:39:30,260
包含来自已提交事务的更改一样，

969
00:39:30,260 --> 00:39:34,430
所以一个稍微好一点的方法

970
00:39:34,430 --> 00:39:38,690


971
00:39:38,690 --> 00:39:40,820
是在我们取检查点时暂停正在运行的事务，

972
00:39:40,820 --> 00:39:43,070
所以我们将意味着

973
00:39:43,070 --> 00:39:44,540
这是什么 任何事务都有一个

974
00:39:44,540 --> 00:39:48,140
正在修改数据库的查询我们

975
00:39:48,140 --> 00:39:50,180
只是在他们尝试

976
00:39:50,180 --> 00:39:52,610
获取页面上的写闩锁时暂停它我们不会

977
00:39:52,610 --> 00:39:55,150
阻止它并且他们必须停止

978
00:39:55,150 --> 00:39:57,620
任何只读事务 动作仍然可以运行，

979
00:39:57,620 --> 00:39:58,820
他们可以读取他们想要的任何内容，因为

980
00:39:58,820 --> 00:39:59,720
这不会干扰该

981
00:39:59,720 --> 00:40:02,510
检查点，然后上面有 concur trail

982
00:40:02,510 --> 00:40:03,920
协议来确定是否

983
00:40:03,920 --> 00:40:04,880
允许他们读取某些内容，

984
00:40:04,880 --> 00:40:07,220
我们可以忽略所有这些，但都是

985
00:40:07,220 --> 00:40:08,180
正确的交易

986
00:40:08,180 --> 00:40:11,660
我们只是要暂停它们 所以它

987
00:40:11,660 --> 00:40:13,250
看起来像这样 所以说我

988
00:40:13,250 --> 00:40:14,810
在内存中 我有三个页面 我有一个

989
00:40:14,810 --> 00:40:16,130
检查点将

990
00:40:16,130 --> 00:40:18,470
同时发生的事务 所以说这个

991
00:40:18,470 --> 00:40:19,850
事务将更新页面 第三页和第一

992
00:40:19,850 --> 00:40:21,860
页所以将从

993
00:40:21,860 --> 00:40:24,080
底部开始将其更改应用到

994
00:40:24,080 --> 00:40:26,480
第三页，然后在更新第一页

995
00:40:26,480 --> 00:40:29,480
之前检查点开始，所以我们必须

996
00:40:29,480 --> 00:40:30,830
正确地停止我们的事务，因为

997
00:40:30,830 --> 00:40:32,180
要尝试在第一页上获取正确的闩锁

998
00:40:32,180 --> 00:40:34,160
你不能这样做，

999
00:40:34,160 --> 00:40:35,930
因为检查点发生了所以它只是

1000
00:40:35,930 --> 00:40:38,480
停顿所以现在检查点它

1001
00:40:38,480 --> 00:40:39,800
真正做的只是顺序扫描

1002
00:40:39,800 --> 00:40:42,500
或扫描或每个页面和我们的

1003
00:40:42,500 --> 00:40:44,480
缓冲池，不是吗 错过将

1004
00:40:44,480 --> 00:40:46,430
它们从磁盘中刷新，因此我们的检查点将

1005
00:40:46,430 --> 00:40:47,840
写出第一到第三页

1006
00:40:47,840 --> 00:40:49,730
，并修改

1007
00:40:49,730 --> 00:40:52,580
了对第三页进行的事务的修改，

1008
00:40:52,580 --> 00:40:54,590
检查点完成我们的事务让

1009
00:40:54,590 --> 00:40:56,810
Sun 停顿，然后我们现在更新第一

1010
00:40:56,810 --> 00:40:59,570
页，问题现在是我们的

1011
00:40:59,570 --> 00:41:02,120
在我们的数据库中为该事务执行的一个查询创建了快照，

1012
00:41:02,120 --> 00:41:03,830
我们看到了一半

1013
00:41:03,830 --> 00:41:06,740
的更改，因此我们的检查点或

1014
00:41:06,740 --> 00:41:08,330
磁盘上数据库的状态

1015
00:41:08,330 --> 00:41:13,730
不一致，因此为了处理

1016
00:41:13,730 --> 00:41:15,260
此问题，我们希望记录一些额外的

1017
00:41:15,260 --> 00:41:18,320
元数据以找出哪些事务

1018
00:41:18,320 --> 00:41:19,490
是 在我们获取检查点的时间运行，以及我们获取

1019
00:41:19,490 --> 00:41:22,460
检查点时缓冲池中哪些页面被弄脏

1020
00:41:22,460 --> 00:41:25,190
，

1021
00:41:25,190 --> 00:41:26,870
以便我们可以使用该

1022
00:41:26,870 --> 00:41:28,820
信息稍后找出哦，

1023
00:41:28,820 --> 00:41:32,420
这个家伙更新了第一页，我

1024
00:41:32,420 --> 00:41:33,860
错过了它或我的检查点，所以我

1025
00:41:33,860 --> 00:41:35,450
知道我没有确定我想

1026
00:41:35,450 --> 00:41:37,320
重播这个人的任何日志记录

1027
00:41:37,320 --> 00:41:39,680
来让我回到正确的状态

1028
00:41:39,680 --> 00:41:47,640
回到这里 是的，现在要非常小心

1029
00:41:47,640 --> 00:42:04,110
这里的语言检查 kpoint 是的，他的问题

1030
00:42:04,110 --> 00:42:07,800
在我这里的例子中，我在手腕

1031
00:42:07,800 --> 00:42:09,660


1032
00:42:09,660 --> 00:42:12,360
上展示了整个系统上的蛮力或粗粒右闩锁，所以这个人

1033
00:42:12,360 --> 00:42:14,400
必须在这个人被允许离开之前完成他的检查站，

1034
00:42:14,400 --> 00:42:17,520
或者我可以说

1035
00:42:17,520 --> 00:42:19,020
我会 只需松开第一页上的正确闩锁

1036
00:42:19,020 --> 00:42:22,710
，然后再更新它，是的，但

1037
00:42:22,710 --> 00:42:23,790
您仍然遇到相同的

1038
00:42:23,790 --> 00:42:26,790
问题，我不是认真的，我将此

1039
00:42:26,790 --> 00:42:28,860
用作稻草人说您所说的

1040
00:42:28,860 --> 00:42:30,840
这是一个坏主意，并且 我们将看到如何

1041
00:42:30,840 --> 00:42:31,440
以更好的方式做到这一点，

1042
00:42:31,440 --> 00:42:35,780
但这是一个明显的优化是的

1043
00:42:43,310 --> 00:42:46,110
这个问题是当我说

1044
00:42:46,110 --> 00:42:48,540
我们关心我们是否关心脏页这

1045
00:42:48,540 --> 00:42:51,330
将是脏页表我们

1046
00:42:51,330 --> 00:42:54,840
是否关心暂停的事务

1047
00:42:54,840 --> 00:42:58,410
或 真实系统中的

1048
00:42:58,410 --> 00:43:00,960
任何脏页都是豁免中的任何脏页 做

1049
00:43:00,960 --> 00:43:01,950
模糊检查点 我们实际上不是

1050
00:43:01,950 --> 00:43:32,310
nopales 事务 是的 他叫

1051
00:43:32,310 --> 00:43:37,680
什么名字 你不需要脏页

1052
00:43:37,680 --> 00:43:39,300
表和实际事务表

1053
00:43:39,300 --> 00:43:41,510
因为如果你 只是重播一切

1054
00:43:41,510 --> 00:43:44,820
，然后反转 t 下摆不会让

1055
00:43:44,820 --> 00:43:47,460
你处于正确的状态

1056
00:43:47,460 --> 00:43:53,190
是的，我想我同意你的看法，但这

1057
00:43:53,190 --> 00:43:57,180
会非常慢，因为

1058
00:43:57,180 --> 00:43:58,380
你将不得不更新你会

1059
00:43:58,380 --> 00:44:00,450
带回每一页，修改它

1060
00:44:00,450 --> 00:44:02,880
正确地使用这些元数据我们

1061
00:44:02,880 --> 00:44:09,510
可以避免现在不是真的，你必须

1062
00:44:09,510 --> 00:44:12,270
回到更远的地方，可能会给你

1063
00:44:12,270 --> 00:44:14,670
更多的幻灯片，我们会到达那里，因为你

1064
00:44:14,670 --> 00:44:19,110
不知道磁盘写了什么，

1065
00:44:19,110 --> 00:44:20,700
所以对了，所以有一个

1066
00:44:20,700 --> 00:44:23,040
事务表和脏页

1067
00:44:23,040 --> 00:44:24,180
表我们' 在检查点开始

1068
00:44:24,180 --> 00:44:26,550
时我们将在检查时记录此信息 我们将在检查运行结束

1069
00:44:26,550 --> 00:44:28,080


1070
00:44:28,080 --> 00:44:30,690
时用模糊检查点将其写出来

1071
00:44:30,690 --> 00:44:32,730
然后我们会看到这

1072
00:44:32,730 --> 00:44:34,230
两个棉花 这两个概念

1073
00:44:34,230 --> 00:44:35,610
在我们进行恢复时再次出现 我们将

1074
00:44:35,610 --> 00:44:37,680
基本上重播日志并填充

1075
00:44:37,680 --> 00:44:38,760
此信息以找出我们

1076
00:44:38,760 --> 00:44:41,850
需要提交或撤消的内容，因此在 actus

1077
00:44:41,850 --> 00:44:43,500
reus 操作表中，这将

1078
00:44:43,500 --> 00:44:45,300
用于检查点启动时每个主动运行的

1079
00:44:45,300 --> 00:44:47,010
事务

1080
00:44:47,010 --> 00:44:49,020
或者记录它的事务 ID

1081
00:44:49,020 --> 00:44:51,690
它的状态，然后

1082
00:44:51,690 --> 00:44:53,550
是这个事务创建的最后一个 LSN，这样

1083
00:44:53,550 --> 00:44:55,800
状态要么是它正在运行的

1084
00:44:55,800 --> 00:44:57,630
提交，它提交正确，所以它已

1085
00:44:57,630 --> 00:44:58,860
提交，但在我们到达

1086
00:44:58,860 --> 00:45:01,650
事务结束之前，或者它是

1087
00:45:01,650 --> 00:45:04,740
我们认为我们必须的东西 撤消它可能必须

1088
00:45:04,740 --> 00:45:06,630
撤消我们还不知道是对的，

1089
00:45:06,630 --> 00:45:09,060
因为我们不

1090
00:45:09,060 --> 00:45:11,340
知道它的最终结果会是什么，并且

1091
00:45:11,340 --> 00:45:12,900
再次当我们看到交易和

1092
00:45:12,900 --> 00:45:14,910
消息时，我们可以我们可以

1093
00:45:14,910 --> 00:45:16,800
从 ATT 因为我们知道我们

1094
00:45:16,800 --> 00:45:18,960
永远不会再看到它 所以

1095
00:45:18,960 --> 00:45:20,340
这就是为什么这里没有完成或

1096
00:45:20,340 --> 00:45:23,940
完成 所以这将是

1097
00:45:23,940 --> 00:45:25,380
挂出内部存储器 我们可以

1098
00:45:25,380 --> 00:45:27,210
在我们采取

1099
00:45:27,210 --> 00:45:28,950
检查点的同时填充它 但随后它被包含在

1100
00:45:28,950 --> 00:45:30,450


1101
00:45:30,450 --> 00:45:33,660
我们将在一秒钟内看到检查点和消息，然后脏 PA

1102
00:45:33,660 --> 00:45:35,190
只是跟踪缓冲池中的所有页面

1103
00:45:35,190 --> 00:45:37,560
，这些页面在缓冲池中

1104
00:45:37,560 --> 00:45:38,670


1105
00:45:38,670 --> 00:45:40,500
已被未提交的 tr 修改的脏页面

1106
00:45:40,500 --> 00:45:42,300
ansactions，对于这个，我们只是

1107
00:45:42,300 --> 00:45:44,490
要记录 wreck LSN，它

1108
00:45:44,490 --> 00:45:47,760
是修改这个页面的第一个事务的日志记录，

1109
00:45:47,760 --> 00:45:49,320


1110
00:45:49,320 --> 00:45:51,060
因为它被带入

1111
00:45:51,060 --> 00:45:55,020
内存，所以让我们看看一个稍微好

1112
00:45:55,020 --> 00:45:56,880
一点的检查点版本

1113
00:45:56,880 --> 00:46:00,060
使用这些信息，所以我们现在

1114
00:46:00,060 --> 00:46:01,019
在检查点条目中看到

1115
00:46:01,019 --> 00:46:03,029
我们和我们的日志记录，我们将

1116
00:46:03,029 --> 00:46:05,189
拥有 ATT，此时我们

1117
00:46:05,189 --> 00:46:07,380
只有一个事务运行 t2，所以

1118
00:46:07,380 --> 00:46:08,880
这是我们在那里唯一的东西

1119
00:46:08,880 --> 00:46:11,459
，然后我们有 脏页

1120
00:46:11,459 --> 00:46:14,939
表，我们有 P 11 P 23 正确，

1121
00:46:14,939 --> 00:46:17,509
因为这里修改了 P 11

1122
00:46:17,509 --> 00:46:21,839
所以我偷看 P 11 P 22 pp11 在

1123
00:46:21,839 --> 00:46:23,909
这里修改了 P 22 在这里修改了所以

1124
00:46:23,909 --> 00:46:25,649
我现在展示的语法就像这里

1125
00:46:25,649 --> 00:46:26,999
的对象一样 已修改，它

1126
00:46:26,999 --> 00:46:28,319
指向

1127
00:46:28,319 --> 00:46:32,789
正确的页码，因此在这种情况下，我们不

1128
00:46:32,789 --> 00:46:34,319
记录有关事务 t1 的任何内容，

1129
00:46:34,319 --> 00:46:37,349
因为事务 t1 在

1130
00:46:37,349 --> 00:46:39,239
我的检查点开始之前提交，因此此时我

1131
00:46:39,239 --> 00:46:43,949
不再关心它，因此 n

1132
00:46:43,949 --> 00:46:46,049
现在在第二个检查点 t3 仍然

1133
00:46:46,049 --> 00:46:49,019
处于活动状态，然后我们必须在

1134
00:46:49,019 --> 00:46:51,179
这里创建两个脏页，因为 t2 在

1135
00:46:51,179 --> 00:46:57,599
我们的事务开始之前提交，所以这

1136
00:46:57,599 --> 00:46:58,799
仍然不理想，因为我们仍在

1137
00:46:58,799 --> 00:47:00,179
拖延所有事务

1138
00:47:00,179 --> 00:47:03,630
以便正确处理，所以我们 在这里暂停

1139
00:47:03,630 --> 00:47:06,689
一切，这些

1140
00:47:06,689 --> 00:47:08,909
人不允许修改它，所以这

1141
00:47:08,909 --> 00:47:10,859
只是说我们写了一个检查

1142
00:47:10,859 --> 00:47:13,019
点，但顺便

1143
00:47:13,019 --> 00:47:15,209
说一下，这里有一些

1144
00:47:15,209 --> 00:47:18,269
可以在这段时间内修改的东西，以

1145
00:47:18,269 --> 00:47:21,239
确保 你发现它很像第

1146
00:47:21,239 --> 00:47:23,849
一个检查点 我

1147
00:47:23,849 --> 00:47:26,309
向你展示的一个方案 没有人真正做过这个

1148
00:47:26,309 --> 00:47:28,039
要么

1149
00:47:28,039 --> 00:47:30,989
每个人都做模糊检查点

1150
00:47:30,989 --> 00:47:33,089
支持高性能

1151
00:47:33,089 --> 00:47:34,549
检查点的系统正在做模糊检查点，

1152
00:47:34,549 --> 00:47:37,739
所以模糊检查点正是我们

1153
00:47:37,739 --> 00:47:39,179
要允许的地方 继续

1154
00:47:39,179 --> 00:47:42,649
运行的事务

1155
00:47:42,649 --> 00:47:45,659
在我们采取检查点的同时不断修改数据库

1156
00:47:45,659 --> 00:47:47,659
，以便记录

1157
00:47:47,659 --> 00:47:49,469
检查点何时开始的

1158
00:47:49,469 --> 00:47:50,759
边界 heckpoint 结束

1159
00:47:50,759 --> 00:47:51,779
以了解是否有一些

1160
00:47:51,779 --> 00:47:54,719
我们错过的内容我们添加了一个整体检查点

1161
00:47:54,719 --> 00:47:56,880
开始和检查点 n 日志消息，

1162
00:47:56,880 --> 00:47:58,380
所以开始只是告诉我们

1163
00:47:58,380 --> 00:48:00,149
检查点何时开始，结束告诉我们

1164
00:48:00,149 --> 00:48:01,499
何时结束，这将

1165
00:48:01,499 --> 00:48:05,909
包括 ATT 和 DBT 是在检查点执行期间发生的

1166
00:48:05,909 --> 00:48:07,409
，

1167
00:48:07,409 --> 00:48:11,909
所以现在回到这里，所以现在

1168
00:48:11,909 --> 00:48:14,210
我们的检查点开始

1169
00:48:14,210 --> 00:48:15,980
检查点做这件事搜索

1170
00:48:15,980 --> 00:48:17,240
任何事情，然后在

1171
00:48:17,240 --> 00:48:20,210
检查点结束我们包括我们有

1172
00:48:20,210 --> 00:48:22,130
事务 t2 因为 t2 在

1173
00:48:22,130 --> 00:48:24,050
检查点开始之前开始，然后

1174
00:48:24,050 --> 00:48:27,110
脏页表告诉我们 D 11

1175
00:48:27,110 --> 00:48:29,060
在检查点期间也被修改了，

1176
00:48:29,060 --> 00:48:31,160
我们不需要在此处包含 t3

1177
00:48:31,160 --> 00:48:33,140
，因为 t3 在我们的

1178
00:48:33,140 --> 00:48:35,590
检查点开始之前开始

1179
00:48:35,590 --> 00:48:38,170
抱歉在我检查我的开始之后开始

1180
00:48:38,170 --> 00:48:43,910
所以一旦我们有了检查点并

1181
00:48:43,910 --> 00:48:46,520
成功写出到磁盘，我们

1182
00:48:46,520 --> 00:48:48,200
就可以了，这意味着我们刷新

1183
00:48:48,200 --> 00:48:50,360
了我们想要带你进入的所有页面

1184
00:48:50,360 --> 00:48:52,310
检查点然后我们继续更新

1185
00:48:52,310 --> 00:48:56,030
我们的主记录，现在包括

1186
00:48:56,030 --> 00:48:57,920
检查点开始的点，因为

1187
00:48:57,920 --> 00:48:59,150
那将是我们

1188
00:48:59,150 --> 00:49:00,500
在恢复期间开始分析的锚点，

1189
00:49:00,500 --> 00:49:03,650
因为我们将

1190
00:49:03,650 --> 00:49:06,740
在此时知道这里就是我们的全部

1191
00:49:06,740 --> 00:49:08,690
刷新了所有脏页，但我们

1192
00:49:08,690 --> 00:49:10,190
可能会跟踪我们可能

1193
00:49:10,190 --> 00:49:12,370
遗漏的那些，因为它们被修改

1194
00:49:12,370 --> 00:49:17,750


1195
00:49:17,750 --> 00:49:23,380


1196
00:49:31,120 --> 00:49:33,170


1197
00:49:33,170 --> 00:49:35,840
了 进入日志但赢了

1198
00:49:35,840 --> 00:49:40,400
它，当它结束时，你把它推进去

1199
00:49:40,400 --> 00:49:41,960
，当你

1200
00:49:41,960 --> 00:49:43,220
扫描缓冲池并将

1201
00:49:43,220 --> 00:49:46,070
所有脏页写到磁盘后，在

1202
00:49:46,070 --> 00:49:46,850
你把它们刷新出来后，

1203
00:49:46,850 --> 00:49:48,320
你就会下沉，因为你确保

1204
00:49:48,320 --> 00:49:51,290
它是持久的，然后您在此处添加日志条目

1205
00:49:51,290 --> 00:49:53,420
并提交我正在使用

1206
00:49:53,420 --> 00:49:54,500
提交该引号，因为就像

1207
00:49:54,500 --> 00:49:56,150
常规事务一样，我将日志

1208
00:49:56,150 --> 00:50:13,370
记录刷新到磁盘是的，这个

1209
00:50:13,370 --> 00:50:16,460
问题是我持有任何锁吗

1210
00:50:16,460 --> 00:50:17,750
在整个数据库中 为什么我现在写出这

1211
00:50:17,750 --> 00:50:21,130
件事

1212
00:50:26,070 --> 00:50:27,540
把我放在这里

1213
00:50:27,540 --> 00:50:29,490
就像你在写一个

1214
00:50:29,490 --> 00:50:35,550
法律代表的职责 是的，我们现在没有将

1215
00:50:35,550 --> 00:50:37,560
它们写入日志 这就是为什么

1216
00:50:37,560 --> 00:50:44,160
这些权利并不重要，或者

1217
00:50:44,160 --> 00:50:52,530
他们可以 通过你的写作 attn DVD 那么

1218
00:50:52,530 --> 00:50:55,020
它会很长，因为你写的

1219
00:50:55,020 --> 00:51:00,240
就像交易 t2 是赚钱的一样，是的，我

1220
00:51:00,240 --> 00:51:01,770
想我想我想我认为这里有

1221
00:51:01,770 --> 00:51:03,870
一种停止世界的时刻，在那里

1222
00:51:03,870 --> 00:51:05,910
你短暂地冲洗掉这件事，

1223
00:51:05,910 --> 00:51:07,980
但这不是 blip 这是一件

1224
00:51:07,980 --> 00:51:15,480
小事是正确的 是的 他们可以在常规缓冲区页面中

1225
00:51:15,480 --> 00:51:16,620
更改他们想要更改的任何其他

1226
00:51:16,620 --> 00:51:22,910


1227
00:51:22,910 --> 00:51:27,240


1228
00:51:27,240 --> 00:51:30,600


1229
00:51:30,600 --> 00:51:31,650


1230
00:51:31,650 --> 00:51:33,150
内容

1231
00:51:33,150 --> 00:51:35,250
恢复这个，然后考虑到

1232
00:51:35,250 --> 00:51:36,720
我们现在设置的一切，因为我们拥有

1233
00:51:36,720 --> 00:51:38,670
所有这些额外的元数据，我们正在

1234
00:51:38,670 --> 00:51:39,240
记录

1235
00:51:39,240 --> 00:51:40,710
恢复实际上不会

1236
00:51:40,710 --> 00:51:43,050
那么糟糕，但棘手的部分只是

1237
00:51:43,050 --> 00:51:44,580
弄清楚你

1238
00:51:44,580 --> 00:51:47,520
在日志中开始每个阶段的位置，因此在分析

1239
00:51:47,520 --> 00:51:49,050
阶段，您将查看

1240
00:51:49,050 --> 00:51:50,880
磁盘上数据库的主记录，

1241
00:51:50,880 --> 00:51:52,770
这将为您提供日志

1242
00:51:52,770 --> 00:51:54,600
中最后一个检查点开始的位置，

1243
00:51:54,600 --> 00:51:57,780
因此您跳转到该位置 位置，您

1244
00:51:57,780 --> 00:52:00,060
不时地向前推进，

1245
00:52:00,060 --> 00:52:02,970
直到到达日志的末尾

1246
00:52:02,970 --> 00:52:04,890
，然后您只需

1247
00:52:04,890 --> 00:52:08,670
填充 DP te na TTE 以跟踪

1248
00:52:08,670 --> 00:52:10,800
系统中正在发生

1249
00:52:10,800 --> 00:52:14,010
的事情 崩溃然后这

1250
00:52:14,010 --> 00:52:15,300
会找出你的消息，以

1251
00:52:15,300 --> 00:52:16,560
确定你需要

1252
00:52:16,560 --> 00:52:16,950
中止

1253
00:52:16,950 --> 00:52:17,940
哪些事务你需要

1254
00:52:17,940 --> 00:52:20,940
确保你提交哪些操作然后在重做

1255
00:52:20,940 --> 00:52:23,760
阶段你会跳转到

1256
00:52:23,760 --> 00:52:27,800
日志中的某个适当位置

1257
00:52:27,800 --> 00:52:30,120
你 知道交易可能会发生潜在的

1258
00:52:30,120 --> 00:52:31,560
变化，这些变化

1259
00:52:31,560 --> 00:52:34,170
不能安全地传输到磁盘，你可以开始

1260
00:52:34,170 --> 00:52:36,150
重新应用这些变化，直到

1261
00:52:36,150 --> 00:52:36,960
法律结束

1262
00:52:36,960 --> 00:52:39,930
，你会为你看到的任何交易都这样做，

1263
00:52:39,930 --> 00:52:41,640
即使是那些

1264
00:52:41,640 --> 00:52:43,950
你知道关于登机的租金，因为

1265
00:52:43,950 --> 00:52:45,540
在分析阶段你会看到

1266
00:52:45,540 --> 00:52:47,880
你知道的所有第一次通过所以你知道

1267
00:52:47,880 --> 00:52:49,050
什么会提交什么会中止

1268
00:52:49,050 --> 00:52:51,390
所以然后在重做阶段只是为了

1269
00:52:51,390 --> 00:52:53,040
安全起见我们只会做你

1270
00:52:53,040 --> 00:52:56,339
知道然后重新应用所有东西 然后是

1271
00:52:56,339 --> 00:52:57,780
撤消阶段，现在您将

1272
00:52:57,780 --> 00:52:59,670
从头开始以相反的顺序返回，

1273
00:52:59,670 --> 00:53:02,369
然后记录直到某个

1274
00:53:02,369 --> 00:53:05,670
点，以撤消

1275
00:53:05,670 --> 00:53:07,589


1276
00:53:07,589 --> 00:53:10,859
未提交的未提交事务的任何更改以及撤消

1277
00:53:10,859 --> 00:53:13,530
阶段何时完成 那么数据库现在

1278
00:53:13,530 --> 00:53:15,960
处于崩溃时存在的存在状态，

1279
00:53:15,960 --> 00:53:18,059


1280
00:53:18,059 --> 00:53:20,730
没有来自

1281
00:53:20,730 --> 00:53:23,460
中止事务的部分更新，并且

1282
00:53:23,460 --> 00:53:25,290
来自已提交事务的所有更改都已

1283
00:53:25,290 --> 00:53:31,500
应用于后面的磁盘是的下

1284
00:53:31,500 --> 00:53:32,960
一张幻灯片是的，

1285
00:53:32,960 --> 00:53:37,020
所以再次三 页面分析重做和

1286
00:53:37,020 --> 00:53:38,940
撤消所以一开始我们就

1287
00:53:38,940 --> 00:53:40,950
看看开始，找出开始

1288
00:53:40,950 --> 00:53:42,660
检查点在主记录

1289
00:53:42,660 --> 00:53:44,309
中的位置，这就是我们要开始

1290
00:53:44,309 --> 00:53:46,740
分析的地方 是的，所以我们假设这里的

1291
00:53:46,740 --> 00:53:48,299
日志记录是最后一个检查点的开始，

1292
00:53:48,299 --> 00:53:50,040
因为在我们的

1293
00:53:50,040 --> 00:53:51,150
主记录中，我们知道它

1294
00:53:51,150 --> 00:53:54,030
在哪里，然后现在我们要向前扫描

1295
00:53:54,030 --> 00:53:55,680
并查看这些

1296
00:53:55,680 --> 00:53:57,869
日志记录 并构建我们的 ATT e 和

1297
00:53:57,869 --> 00:54:01,020
d PT 然后现在我们必须

1298
00:54:01,020 --> 00:54:04,349
弄清楚重做阶段的内容是什么是

1299
00:54:04,349 --> 00:54:06,510
脏页表中的最小请求 Ellison

1300
00:54:06,510 --> 00:54:08,369


1301
00:54:08,369 --> 00:54:11,250


1302
00:54:11,250 --> 00:54:13,559
第一个日志

1303
00:54:13,559 --> 00:54:15,690
记录的位置

1304
00:54:15,690 --> 00:54:18,900
修改了可能尚未

1305
00:54:18,900 --> 00:54:22,049
写入磁盘的页面的最旧日志记录，因此当我们重做时，我们

1306
00:54:22,049 --> 00:54:24,059
在这一点跳转并重新应用我们的所有

1307
00:54:24,059 --> 00:54:28,319
更改，然后现在在撤消阶段

1308
00:54:28,319 --> 00:54:31,020
我们从结束点开始 并

1309
00:54:31,020 --> 00:54:34,200
回到过去，直到

1310
00:54:34,200 --> 00:54:36,510
我们知道这是最古老的

1311
00:54:36,510 --> 00:54:37,890
事务，它的边界正在

1312
00:54:37,890 --> 00:54:39,990
积极运行，而我们

1313
00:54:39,990 --> 00:54:42,329
采取了检查点，我们撤消了所有

1314
00:54:42,329 --> 00:54:44,549
这些更改，因此错误有点

1315
00:54:44,549 --> 00:54:45,990
向您显示边界

1316
00:54:45,990 --> 00:54:48,960
您可以在日志中及时返回多远，

1317
00:54:48,960 --> 00:54:51,329
以便您知道我将

1318
00:54:51,329 --> 00:54:54,210
在上下文中更准确地处理这些问题 Ellis 一一结束

1319
00:54:54,210 --> 00:54:56,010
，但在高层次上是否

1320
00:54:56,010 --> 00:54:58,680
清楚我们正在做的分析

1321
00:54:58,680 --> 00:55:01,829
一次重做一次，

1322
00:55:01,829 --> 00:55:05,790
然后撤消时间倒退，对于撤消，

1323
00:55:05,790 --> 00:55:08,520
我可能不会撤消

1324
00:55:08,520 --> 00:55:10,740
我在这里看到的每条日志记录，这仅适用

1325
00:55:10,740 --> 00:55:12,359


1326
00:55:12,359 --> 00:55:15,000
于分析后在我的 ATT 中识别的

1327
00:55:15,000 --> 00:55:20,970
不应该提交的事务 好的，所以这种

1328
00:55:20,970 --> 00:55:24,210
总结更具体地说是

1329
00:55:24,210 --> 00:55:26,069
我刚刚说的，所以分析阶段我们

1330
00:55:26,069 --> 00:55:27,270
将从最后一个

1331
00:55:27,270 --> 00:55:29,609
成功的检查点向前扫描日志，只要您

1332
00:55:29,609 --> 00:55:31,650
在分析过程中发现交易和记录，

1333
00:55:31,650 --> 00:55:33,619
我们就可以将其从我的 ATT 中删除，

1334
00:55:33,619 --> 00:55:36,839
否则对于任何 其他记录 如果

1335
00:55:36,839 --> 00:55:37,829
这是我第一次看到这个

1336
00:55:37,829 --> 00:55:39,420
交易 我们将它添加到 ATT

1337
00:55:39,420 --> 00:55:42,720
的状态为撤消 因为我们不知道

1338
00:55:42,720 --> 00:55:44,670
因为我们正在及时推进 我们

1339
00:55:44,670 --> 00:55:45,990
不知道它是否会

1340
00:55:45,990 --> 00:55:49,410
在以后中止 我们看到一个提交重新 然后

1341
00:55:49,410 --> 00:55:51,150
我们只是将它的状态更改为提交，就像

1342
00:55:51,150 --> 00:55:52,710
我说的那样，一个是无罪的，我们可以删除

1343
00:55:52,710 --> 00:55:55,650
它，然后对于任何更新记录，

1344
00:55:55,650 --> 00:55:57,180
我们将查看

1345
00:55:57,180 --> 00:55:58,500
正在修改的更新记录中的页面

1346
00:55:58,500 --> 00:56:02,190
是否在我们的 DBT 中，如果 不是然后我们

1347
00:56:02,190 --> 00:56:04,079
继续添加它，我们将鲁莽的

1348
00:56:04,079 --> 00:56:07,500
结尾设置为我们的 Ellison 因为这又是

1349
00:56:07,500 --> 00:56:08,790
这告诉我们这是

1350
00:56:08,790 --> 00:56:12,089


1351
00:56:12,089 --> 00:56:16,319
当它被带入内存时首先使这个页面变脏的日志记录所以

1352
00:56:16,319 --> 00:56:18,660
现在在结束时 在分析阶段，

1353
00:56:18,660 --> 00:56:20,700
ATT 会告诉我们崩溃时

1354
00:56:20,700 --> 00:56:21,869
我们在系统中运行的所有参与者事务是什么

1355
00:56:21,869 --> 00:56:23,160


1356
00:56:23,160 --> 00:56:26,430
，而 DP T 会告诉我们哪些

1357
00:56:26,430 --> 00:56:28,829
是我们缓冲池中可能存在的脏页

1358
00:56:28,829 --> 00:56:30,210
可能

1359
00:56:30,210 --> 00:56:33,359
尚未写入磁盘，我们正在这样做

1360
00:56:33,359 --> 00:56:34,619
，我们必须构建此

1361
00:56:34,619 --> 00:56:36,329
表，因为

1362
00:56:36,329 --> 00:56:38,280
我们不会在每次执行缓冲池刷新

1363
00:56:38,280 --> 00:56:40,950
到我们未记录的磁盘上的页面时都注销

1364
00:56:40,950 --> 00:56:44,069
在日志或日志

1365
00:56:44,069 --> 00:56:45,390
记录或不t 嗯，你知道

1366
00:56:45,390 --> 00:56:46,619
潜力会被修改，我们正在

1367
00:56:46,619 --> 00:56:53,099
尝试重建它是的这个

1368
00:56:53,099 --> 00:56:54,000
问题是我如何

1369
00:56:54,000 --> 00:56:55,799
确定页面是像在日志中一样写入磁盘

1370
00:56:55,799 --> 00:56:59,369
还是在现实世界中像在

1371
00:56:59,369 --> 00:57:02,299
硬件或模拟上一样

1372
00:57:02,860 --> 00:57:06,530
你不能 因为我没有任何

1373
00:57:06,530 --> 00:57:07,850
信息告诉我它已经被

1374
00:57:07,850 --> 00:57:12,650
写入当我们看到重做时并不完全正确，我们

1375
00:57:12,650 --> 00:57:14,360
将在一秒钟内调整

1376
00:57:14,360 --> 00:57:16,340
但总的来说，如果您知道

1377
00:57:16,340 --> 00:57:20,750
您正在查看的墙上记录的 LSN

1378
00:57:20,750 --> 00:57:24,020
比鲁莽少

1379
00:57:24,020 --> 00:57:26,780
磁盘上存在的页面日志的末尾然后您

1380
00:57:26,780 --> 00:57:29,690
知道您的更改已

1381
00:57:29,690 --> 00:57:32,120
写出磁盘，但到该页面时，该页面被

1382
00:57:32,120 --> 00:57:33,590
读取而不是磁盘然后

1383
00:57:33,590 --> 00:57:35,300
它又被另一个页面弄脏了，但在那之前您的内容已被

1384
00:57:35,300 --> 00:57:39,890
写出 好的

1385
00:57:39,890 --> 00:57:43,460
，分析阶段的快速概述，

1386
00:57:43,460 --> 00:57:45,530
所以在这里我只是向您

1387
00:57:45,530 --> 00:57:47,360
展示 ATT 到 DP t 或者看起来

1388
00:57:47,360 --> 00:57:49,940
这些不同的 LS

1389
00:57:49,940 --> 00:57:52,370
端的这些不同 所以开始我们的检查点我们什么都不

1390
00:57:52,370 --> 00:57:54,380
知道所以 ATT 并且 GPT 为

1391
00:57:54,380 --> 00:57:57,980
空然后我们进行更新 批量

1392
00:57:57,980 --> 00:58:00,350
序列 20 所以对于这里的这个我们有

1393
00:58:00,350 --> 00:58:02,630
事务 T 96 这是我们第

1394
00:58:02,630 --> 00:58:04,520
一次看到它是正确的 因为

1395
00:58:04,520 --> 00:58:05,660
我们在这里没有开始记录

1396
00:58:05,660 --> 00:58:07,250
因为它在检查点开始之前

1397
00:58:07,250 --> 00:58:13,510
开始 所以我们看到并更新 我们的

1398
00:58:13,510 --> 00:58:15,950
ATT 说嘿，我们曾经在这里

1399
00:58:15,950 --> 00:58:18,200
RT 96 并且状态是撤消的候选者，

1400
00:58:18,200 --> 00:58:19,400
因为我们不知道它

1401
00:58:19,400 --> 00:58:21,620
是否会提交，然后我们

1402
00:58:21,620 --> 00:58:24,350
看到它修改了第 33 页，因此我们将其添加

1403
00:58:24,350 --> 00:58:27,380
到我们的脏 页表与

1404
00:58:27,380 --> 00:58:31,270
我们的日志记录的 req Ellison 在这里

1405
00:58:31,270 --> 00:58:34,340
然后现在我们的事务结束，现在我们

1406
00:58:34,340 --> 00:58:36,530
获得更多关于

1407
00:58:36,530 --> 00:58:38,330
额外内容在 TVT 实际表中的信息，所以现在

1408
00:58:38,330 --> 00:58:39,890
我们看到有

1409
00:58:39,890 --> 00:58:41,630
一个我们没有看到的 t97 在我们的

1410
00:58:41,630 --> 00:58:43,700
检查点之间，所以我们知道

1411
00:58:43,700 --> 00:58:46,090
在这个检查点上方有一个事务

1412
00:58:46,090 --> 00:58:50,240
检查点起点做了

1413
00:58:50,240 --> 00:58:51,860
一些我们可能需要去看看

1414
00:58:51,860 --> 00:58:55,640
的东西 然后还有一个新的新

1415
00:58:55,640 --> 00:58:58,100
页面 20 也被修改了所以你

1416
00:58:58,100 --> 00:58:59,930
想要 将其包含在我们的 DPT 中

1417
00:58:59,930 --> 00:59:04,670
同样，现在我们在这里看到 T 96 提交，所以

1418
00:59:04,670 --> 00:59:08,080
我们将它的状态翻转为正在提交，

1419
00:59:08,080 --> 00:59:10,220
然后当我们在这里看到交易和

1420
00:59:10,220 --> 00:59:13,820
消息时，我们知道我们

1421
00:59:13,820 --> 00:59:15,010
可以从 ATT 中删除它，

1422
00:59:15,010 --> 00:59:17,960
但现在在崩溃点你

1423
00:59:17,960 --> 00:59:19,790
看到 t97 仍然在

1424
00:59:19,790 --> 00:59:22,130
这里挂着一个新的候选状态，

1425
00:59:22,130 --> 00:59:24,650
所以我们知道这个事务在

1426
00:59:24,650 --> 00:59:26,540
我们的检查点上方做了

1427
00:59:26,540 --> 00:59:29,060
一些我们在日志中没有看到的更改，我们

1428
00:59:29,060 --> 00:59:30,380
需要返回并确保我们反转，

1429
00:59:30,380 --> 00:59:31,970
因为我们 不知道这些

1430
00:59:31,970 --> 00:59:38,260
页面是否已经写出来了，是的，

1431
00:59:46,150 --> 00:59:48,800
您的问题是

1432
00:59:48,800 --> 00:59:51,890
在分析阶段之后 ATT 和 EPT

1433
00:59:51,890 --> 00:59:53,390
是否可能为空，因此您知道

1434
00:59:53,390 --> 00:59:55,910
没有什么是脏的，

1435
00:59:55,910 --> 00:59:57,200
您可以说我很好

1436
00:59:57,200 --> 01:00:00,710
是的，实际上你会

1437
01:00:00,710 --> 01:00:01,790
看到这一点，因为

1438
01:00:01,790 --> 01:00:05,360
如果它是空的，那什么

1439
01:00:05,360 --> 01:00:06,320


1440
01:00:06,320 --> 01:00:20,300


1441
01:00:20,300 --> 01:00:23,720


1442
01:00:23,720 --> 01:00:25,100
都不是 马上就脏了爸爸 出去

1443
01:00:25,100 --> 01:00:34,430
把桌子上的 boobies 放在磁盘上 是的，

1444
01:00:34,430 --> 01:00:36,530
我不认为是的，但实际上我不

1445
01:00:36,530 --> 01:00:38,900
知道我认为是的答案，

1446
01:00:38,900 --> 01:00:41,210
因为为什么不知道为什么

1447
01:00:41,210 --> 01:00:42,170
轰炸机池管理器需要

1448
01:00:42,170 --> 01:00:43,580
写出脏页 好吧，我需要给 Vic 一些

1449
01:00:43,580 --> 01:00:45,050
东西来腾出空间，检查站

1450
01:00:45,050 --> 01:00:56,420
基本上就是这样做的，是的，我

1451
01:00:56,420 --> 01:00:58,790
认为答案是肯定的，但我应该

1452
01:00:58,790 --> 01:00:59,320
仔细检查一下，

1453
01:00:59,320 --> 01:01:01,370
所以他的声明是，在

1454
01:01:01,370 --> 01:01:03,050
检查站期间，强大的经理并不是

1455
01:01:03,050 --> 01:01:04,370
那么大声 将脏

1456
01:01:04,370 --> 01:01:10,100
页写到磁盘，因为您可能不会

1457
01:01:10,100 --> 01:01:12,290
错过这个术语嘿感觉答案是

1458
01:01:12,290 --> 01:01:13,880
肯定的但我实际上不知道我的意思是您

1459
01:01:13,880 --> 01:01:18,770


1460
01:01:18,770 --> 01:01:20,630
在分析阶段之后再次考虑这个问题我们有 ATT 和

1461
01:01:20,630 --> 01:01:22,040
DBT 告诉我们什么是什么

1462
01:01:22,040 --> 01:01:24,440
崩溃时发生了什么，所以

1463
01:01:24,440 --> 01:01:25,940
现在在重做阶段，我们想要重复

1464
01:01:25,940 --> 01:01:28,450
历史，因此我们将

1465
01:01:28,450 --> 01:01:31,600
应用法律中某个点的所有更改

1466
01:01:31,600 --> 01:01:33,250
，我们知道有一个

1467
01:01:33,250 --> 01:01:35,290
修改过的脏页面

1468
01:01:35,290 --> 01:01:37,210
可能不会 磁盘，因此

1469
01:01:37,210 --> 01:01:38,800
我们将重新应用所有这些更改

1470
01:01:38,800 --> 01:01:40,600
，即使是中止的

1471
01:01:40,600 --> 01:01:43,180
事务以及我们从中止的事务中看到的任何 CRR，

1472
01:01:43,180 --> 01:01:44,680
我们也会重做

1473
01:01:44,680 --> 01:01:49,420
它们，所以正如我之前所说，

1474
01:01:49,420 --> 01:01:51,670
这看起来非常昂贵，

1475
01:01:51,670 --> 01:01:54,250
因为我们 将重新应用

1476
01:01:54,250 --> 01:01:56,530
我们在技术上可能需要的更改可能

1477
01:01:56,530 --> 01:01:59,320
不需要重新应用您知道

1478
01:01:59,320 --> 01:02:00,700
例如对于交易我们知道它

1479
01:02:00,700 --> 01:02:04,000
会登上谁关心您知道

1480
01:02:04,000 --> 01:02:06,850
带来一个页面进行更新

1481
01:02:06,850 --> 01:02:08,530
然后在CLRS中反转

1482
01:02:08,530 --> 01:02:09,970
然后你知道 是

1483
01:02:09,970 --> 01:02:11,590
唯一修改该页面的事务，我

1484
01:02:11,590 --> 01:02:14,290
可以跳过该事务，

1485
01:02:14,290 --> 01:02:15,430
因此您可以进行类似的优化，

1486
01:02:15,430 --> 01:02:17,590
但我们将再次

1487
01:02:17,590 --> 01:02:18,550
忽略它，因为您想

1488
01:02:18,550 --> 01:02:20,410
确保一切都是干净

1489
01:02:20,410 --> 01:02:24,850
和正确的，因此 我们读取谁

1490
01:02:24,850 --> 01:02:27,430
付款，然后我们从

1491
01:02:27,430 --> 01:02:29,290
包含最小鲁莽和

1492
01:02:29,290 --> 01:02:31,540
DPT 的日志记录开始，因为这又是

1493
01:02:31,540 --> 01:02:33,940
第一个修改页面的日志记录，

1494
01:02:33,940 --> 01:02:35,980
它弄脏了页面，我们可能没有 没有

1495
01:02:35,980 --> 01:02:38,260
把它放到磁盘然后当我们扫描

1496
01:02:38,260 --> 01:02:39,700


1497
01:02:39,700 --> 01:02:42,070
CLR 的每一个单球记录时，我们会查看所有 LSN，我们将

1498
01:02:42,070 --> 01:02:44,980
重做该操作，除非该页

1499
01:02:44,980 --> 01:02:47,320
不在脏页表中，在这种情况下，我们

1500
01:02:47,320 --> 01:02:51,040
知道我们的 修改

1501
01:02:51,040 --> 01:02:52,780
在之前的某个时间点被刷新，

1502
01:02:52,780 --> 01:02:55,300
或者如果它在我们的脏页

1503
01:02:55,300 --> 01:02:57,250
表中，但我们的记录

1504
01:02:57,250 --> 01:03:01,660
LSN 小于记录 Lawson 的页面

1505
01:03:01,660 --> 01:03:04,510
，这意味着我们

1506
01:03:04,510 --> 01:03:06,520
对页面进行了一些更改，然后页面

1507
01:03:06,520 --> 01:03:08,440
被写出 光盘，但随后一些

1508
01:03:08,440 --> 01:03:10,150
其他事务让您知道

1509
01:03:10,150 --> 01:03:12,460
，这可能使它更改了同一页，

1510
01:03:12,460 --> 01:03:14,260
然后第二次更改并没有摆脱

1511
01:03:14,260 --> 01:03:16,570
光盘，这就是为什么我们再次

1512
01:03:16,570 --> 01:03:18,760
记录鲁莽的结尾写出

1513
01:03:18,760 --> 01:03:20,890
我们可以识别的光盘的原因 是什么

1514
01:03:20,890 --> 01:03:22,930
让您知道实际修改了哪些更改，

1515
01:03:22,930 --> 01:03:28,540
因此要撤消操作，我们只需

1516
01:03:28,540 --> 01:03:31,600
重新应用更改，并将

1517
01:03:31,600 --> 01:03:33,730
页面 LSN 设置为记录 love worker

1518
01:03:33,730 --> 01:03:35,080
sells n 这就像我们

1519
01:03:35,080 --> 01:03:38,770
在常规执行期间通常会做的事情一样，您

1520
01:03:38,770 --> 01:03:41,590
知道交易 乙 ut

1521
01:03:41,590 --> 01:03:42,580
在正常操作期间，我们不会

1522
01:03:42,580 --> 01:03:44,470
做任何额外的日志记录，我们不

1523
01:03:44,470 --> 01:03:45,820
担心刷新它，并且您有

1524
01:03:45,820 --> 01:03:47,650
任何额外的权利，我们可以异步完成所有操作，

1525
01:03:47,650 --> 01:03:50,470
因此当我们

1526
01:03:50,470 --> 01:03:52,780
到达事务结束消息时，我们将

1527
01:03:52,780 --> 01:03:55,780
继续进行 并将其从 ATT 中删除

1528
01:03:55,780 --> 01:03:58,630
，如果我们想要非常小心，我们

1529
01:03:58,630 --> 01:04:03,250
可以在那时刷新所有内容，所以

1530
01:04:03,250 --> 01:04:05,590
现在最后一个阶段是撤消，因此这

1531
01:04:05,590 --> 01:04:07,000
只是撤消

1532
01:04:07,000 --> 01:04:08,500
我们在分析阶段之后在 ATT 上

1533
01:04:08,500 --> 01:04:10,570
看到的所有挂起的事务

1534
01:04:10,570 --> 01:04:14,320
使用撤消标志或撤消加拿大标志退出，因此

1535
01:04:14,320 --> 01:04:17,010
我们将返回并反转顺序

1536
01:04:17,010 --> 01:04:19,330
，我们将反转

1537
01:04:19,330 --> 01:04:22,600
日志序列顺序中的更改，即使

1538
01:04:22,600 --> 01:04:26,260
事务 t1 在 tt 她的 t1

1539
01:04:26,260 --> 01:04:28,840
中止和 t3 中止之前运行，如果我们

1540
01:04:28,840 --> 01:04:31,210
先看看日志记录 43

1541
01:04:31,210 --> 01:04:33,670
我们将在到达 t1 之前先反转它们

1542
01:04:33,670 --> 01:04:38,440
，每次我们反转

1543
01:04:38,440 --> 01:04:40,960
更改时，我们都会添加一条 CLR 消息，

1544
01:04:40,960 --> 01:04:42,520


1545
01:04:42,520 --> 01:04:44,680
如果我们在恢复期间崩溃，则允许恢复数据库 因为

1546
01:04:44,680 --> 01:04:48,070
我们知道我们实际上反转了什么，所以

1547
01:04:48,070 --> 01:04:49,540
这让很多人挥舞着大量的

1548
01:04:49,540 --> 01:04:51,040
文字，让我们来看看这里的一个

1549
01:04:51,040 --> 01:04:53,830
简单例子，所以这里我们现在

1550
01:04:53,830 --> 01:04:56,200
有一个正确的前进日志

1551
01:04:56,200 --> 01:04:58,600
，我们看到我们做了一个检查点和

1552
01:04:58,600 --> 01:05:01,090
它完成了，然后我们让 t1

1553
01:05:01,090 --> 01:05:04,360
在第 5 页 t2 上对

1554
01:05:04,360 --> 01:05:06,040
第 3 页进行了修改，但随后 t1

1555
01:05:06,040 --> 01:05:08,440
中止，因此在正常执行期间，

1556
01:05:08,440 --> 01:05:11,980
我们如何中止此操作，我们创建

1557
01:05:11,980 --> 01:05:13,750
了 CLR，表示我们要撤消

1558
01:05:13,750 --> 01:05:16,930
此更改 在这里，然后

1559
01:05:16,930 --> 01:05:18,340
一旦我们知道这已被应用，

1560
01:05:18,340 --> 01:05:20,890
然后我们继续添加我们的交易

1561
01:05:20,890 --> 01:05:22,630
和消息以说明该交易

1562
01:05:22,630 --> 01:05:26,140
已完全完成，所以现在我也没有

1563
01:05:26,140 --> 01:05:27,280
显示之前的 Ellison 但

1564
01:05:27,280 --> 01:05:28,510
您可以认为这是一个链接

1565
01:05:28,510 --> 01:05:29,680
list 告诉你对于一个给定的交易

1566
01:05:29,680 --> 01:05:32,500
如何遍历它的更新并

1567
01:05:32,500 --> 01:05:35,140
能够逆转它们，所以现在让

1568
01:05:35,140 --> 01:05:37,990
我们在这里说我们对 t3 和 t2 进行了一系列更改，

1569
01:05:37,990 --> 01:05:43,330
但随后我们崩溃了，所以在

1570
01:05:43,330 --> 01:05:45,520
分析阶段我们会回来 并

1571
01:05:45,520 --> 01:05:48,700
填充 t 他 ATT 进入 DP 团队，所以这是

1572
01:05:48,700 --> 01:05:49,810
我的空间不足，所以这

1573
01:05:49,810 --> 01:05:51,910
是一个日志的截断版本，

1574
01:05:51,910 --> 01:05:54,760
例如，这里我有 40 45 英寸的上部

1575
01:05:54,760 --> 01:05:55,390
线，现在

1576
01:05:55,390 --> 01:05:57,910
14:45 在一条线上，

1577
01:05:57,910 --> 01:05:59,769
然后是 CLR 通过

1578
01:05:59,769 --> 01:06:03,130
事务和消息，让我

1579
01:06:03,130 --> 01:06:03,460
回来看看

1580
01:06:03,460 --> 01:06:05,079
你是不是 TD 告诉我们我们有两个

1581
01:06:05,079 --> 01:06:07,960
活动事务 t2 和 t3 然后

1582
01:06:07,960 --> 01:06:10,510
我们有最后一个 LS 结束，指向

1583
01:06:10,510 --> 01:06:14,140
他们所做的最后一次修改，所以

1584
01:06:14,140 --> 01:06:15,190
我们要看看 交易

1585
01:06:15,190 --> 01:06:21,390
是埃里森开始在平分上做的最大要求的交易，

1586
01:06:21,390 --> 01:06:23,559
所以假设

1587
01:06:23,559 --> 01:06:24,819
我们已经把

1588
01:06:24,819 --> 01:06:27,430
所有事情都做对了，现在我们要

1589
01:06:27,430 --> 01:06:29,049
撤消这件事，我们要添加新的日志

1590
01:06:29,049 --> 01:06:31,000
条目来扭转这些 因为

1591
01:06:31,000 --> 01:06:32,109
这些事务不允许

1592
01:06:32,109 --> 01:06:34,599
提交所以我们看看这个并说 t2 是

1593
01:06:34,599 --> 01:06:38,349
最后一个 LSN 它是 60 t3 s 少 LS n 是 50 所以

1594
01:06:38,349 --> 01:06:41,529
我们要我们首先要反转 LS

1595
01:06:41,529 --> 01:06:44,769
n 60 所以我们继续

1596
01:06:44,769 --> 01:06:48,160
创建 CLR 写这个来逆转这个

1597
01:06:48,160 --> 01:06:51,789
变化，然后我们添加这个撤消下一个 LS

1598
01:06:51,789 --> 01:06:54,039
n 指向下一个 LS，我们

1599
01:06:54,039 --> 01:06:55,329
需要在此处为该事务反转此

1600
01:06:55,329 --> 01:06:57,069
事务，再次，

1601
01:06:57,069 --> 01:06:58,630
为了方便起见，该事物是一个逻辑指针，

1602
01:06:58,630 --> 01:07:00,220
告诉我们我们需要

1603
01:07:00,220 --> 01:07:05,049
跳转到下一个位置，然后也许我们

1604
01:07:05,049 --> 01:07:08,410
为事务 t3 正确添加 CLR 这是

1605
01:07:08,410 --> 01:07:09,640
我们实际上需要为此事务撤消的最后一件事

1606
01:07:09,640 --> 01:07:11,619
，因此我们可以

1607
01:07:11,619 --> 01:07:13,000
继续并立即创建事务结束

1608
01:07:13,000 --> 01:07:15,130
消息，

1609
01:07:15,130 --> 01:07:17,559
然后我们将刷新

1610
01:07:17,559 --> 01:07:19,569
显示实际修改的所有脏页，

1611
01:07:19,569 --> 01:07:22,240
以及 正确地将日志记录到磁盘，因此

1612
01:07:22,240 --> 01:07:24,190
此时我们知道我们永远不需要再次

1613
01:07:24,190 --> 01:07:25,900
恢复或撤消此事务

1614
01:07:25,900 --> 01:07:28,299
以反转任何内容，因为

1615
01:07:28,299 --> 01:07:29,559
日志已经包含

1616
01:07:29,559 --> 01:07:32,319
您需要反转它的所有内容，因此如果我们再次崩溃，我们将重做，

1617
01:07:32,319 --> 01:07:34,509
但我们 想要撤消

1618
01:07:34,509 --> 01:07:38,019
任何事情，所以现在我说我们在这里崩溃了，

1619
01:07:38,019 --> 01:07:39,880
我们正在做恢复我们处于

1620
01:07:39,880 --> 01:07:43,210
撤消阶段我们崩溃并重新启动所有这一切都

1621
01:07:43,210 --> 01:07:44,650
被吹走了，因为这

1622
01:07:44,650 --> 01:07:46,809
只是挂在内存中所以当

1623
01:07:46,809 --> 01:07:49,779
我们回来时 d 我们的 ATT 会说

1624
01:07:49,779 --> 01:07:51,309
我们最后只有

1625
01:07:51,309 --> 01:07:52,829
t2 我们确保我们需要反转它

1626
01:07:52,829 --> 01:07:55,809
所以接下来我们需要反转

1627
01:07:55,809 --> 01:07:57,730
我们反转的起点就

1628
01:07:57,730 --> 01:08:00,700
在这里所以为此我们只是我们已经

1629
01:08:00,700 --> 01:08:02,140
应用了 它在撤消阶段，所以

1630
01:08:02,140 --> 01:08:03,250
没有什么可撤消的，因为你

1631
01:08:03,250 --> 01:08:06,309
无法撤消撤消，你只是重做它们，所以

1632
01:08:06,309 --> 01:08:08,610
你重做撤消，但你不

1633
01:08:08,610 --> 01:08:11,670
撤消撤消，所以撤消下一个告诉我们

1634
01:08:11,670 --> 01:08:12,900
我们需要在 20 点反转的下一件事

1635
01:08:12,900 --> 01:08:14,880
所以我们添加，你看到了周围

1636
01:08:14,880 --> 01:08:16,710
的一切，然后我们有我们的事务

1637
01:08:16,710 --> 01:08:17,729
结束消息，因为这是我们需要做的最后一件事

1638
01:08:17,729 --> 01:08:20,130
，我们刷新日志，然后在刷新日志

1639
01:08:20,130 --> 01:08:22,319
之后我们就在这里完成

1640
01:08:22,319 --> 01:08:23,370
了你的新

1641
01:08:23,370 --> 01:08:25,140
页面 我们知道数据库中的刷新

1642
01:08:25,140 --> 01:08:27,660
处于一致状态，因为它在

1643
01:08:27,660 --> 01:08:29,760
第一次崩溃时就存在，没有

1644
01:08:29,760 --> 01:08:31,470
任何中止

1645
01:08:31,470 --> 01:08:38,310
事务的部分影响是的，这个问题是

1646
01:08:38,310 --> 01:08:39,779
值得在重做阶段做一个检查点

1647
01:08:39,779 --> 01:08:46,680
，这样会使

1648
01:08:46,680 --> 01:08:48,930
所以你会这样做，如果 你认为

1649
01:08:48,930 --> 01:08:51,960
你会在不久的

1650
01:08:51,960 --> 01:08:54,390
将来再次崩溃，否则只是

1651
01:08:54,390 --> 01:08:56,310
磁盘写入过多

1652
01:08:56,310 --> 01:09:00,840
，所以如果是 1970 年代的波多黎各，

1653
01:09:00,840 --> 01:09:04,790
并且你没有权力，那么没有人会这样做，是的，你这样做

1654
01:09:13,640 --> 01:09:16,800
，问题是我们需要这样做

1655
01:09:16,800 --> 01:09:18,390
现在在这里做这个刷新，这是一个

1656
01:09:18,390 --> 01:09:21,229
优化，是的，是的，

1657
01:09:21,229 --> 01:09:26,250
下一张幻灯片好吧，所以我在这个

1658
01:09:26,250 --> 01:09:27,479
例子中展示了如果

1659
01:09:27,479 --> 01:09:30,450
你在撤消过程中崩溃会发生什么如果我们

1660
01:09:30,450 --> 01:09:33,560
在分析阶段崩溃，我们有什么要做

1661
01:09:33,560 --> 01:09:37,050
的，没有什么对的

1662
01:09:37,050 --> 01:09:38,430
无事可做，因为它已经只是

1663
01:09:38,430 --> 01:09:39,810
呼吸日志 我们只是回来然后

1664
01:09:39,810 --> 01:09:41,790
再做一遍 如果我们在重做过程中崩溃

1665
01:09:41,790 --> 01:09:49,109
我们必须在后面做什么

1666
01:09:49,109 --> 01:09:51,330


1667
01:09:51,330 --> 01:09:53,220


1668
01:09:53,220 --> 01:09:55,410


1669
01:09:55,410 --> 01:09:57,120
如果您之前撤消了事情，那么您在前面生成的 CLRS

1670
01:09:57,120 --> 01:10:00,420
所以它只是在

1671
01:10:00,420 --> 01:10:01,710
撤消阶段，您可能

1672
01:10:01,710 --> 01:10:03,720
需要弄清楚我在这个给定时间撤消了什么，

1673
01:10:03,720 --> 01:10:09,300
所以他的问题是相关的

1674
01:10:09,300 --> 01:10:13,530
一种避免

1675
01:10:13,530 --> 01:10:14,850
每次

1676
01:10:14,850 --> 01:10:16,740
交易结束时所有额外磁盘刷新的方法，这也

1677
01:10:16,740 --> 01:10:18,570
与他的问题有关，您

1678
01:10:18,570 --> 01:10:19,620
只是假设您不会

1679
01:10:19,620 --> 01:10:21,960
在恢复期间崩溃，

1680
01:10:21,960 --> 01:10:23,790
或者您只是要刷新

1681
01:10:23,790 --> 01:10:26,940


1682
01:10:26,940 --> 01:10:29,489


1683
01:10:29,489 --> 01:10:33,300
当我认为您终于

1684
01:10:33,300 --> 01:10:34,710
说数据在线并准备

1685
01:10:34,710 --> 01:10:37,340
开始处理新事务时，脏页中的外观使用aa神圣的更改可能会将它们从磁盘中刷新II

1686
01:10:37,340 --> 01:10:40,469
认为大多数系统会采取另一个

1687
01:10:40,469 --> 01:10:42,360
检查点然后 你不必

1688
01:10:42,360 --> 01:10:46,050
正确的理由你不必那么

1689
01:10:46,050 --> 01:10:47,010
我们如何在撤消阶段用另一种方法来

1690
01:10:47,010 --> 01:10:48,810
提高性能

1691
01:10:48,810 --> 01:10:50,489
我们已经讨论过其中

1692
01:10:50,489 --> 01:10:52,080
的一些我们讨论过你知道

1693
01:10:52,080 --> 01:10:53,940
弄清楚这个事务

1694
01:10:53,940 --> 01:10:55,260
中止了 这是修改此页面的唯一内容，

1695
01:10:55,260 --> 01:10:56,850
因此我

1696
01:10:56,850 --> 01:10:59,570
不需要撤消该页面上的任何更改，

1697
01:10:59,570 --> 01:11:03,239
另一种方法是实际上

1698
01:11:03,239 --> 01:11:06,560
懒惰地重新绘制

1699
01:11:06,560 --> 01:11:11,400
在运行时应用事务 o 的回滚，所以 y 你

1700
01:11:11,400 --> 01:11:14,130
做你做分析你做重做

1701
01:11:14,130 --> 01:11:16,020
然后你弄清楚你需要

1702
01:11:16,020 --> 01:11:18,960
为每个页面撤消什么但是然后

1703
01:11:18,960 --> 01:11:20,910
而不是应用这些更改你

1704
01:11:20,910 --> 01:11:22,230
只是将它们保留

1705
01:11:22,230 --> 01:11:25,590
在内存中的某个地方然后任何时候出现新

1706
01:11:25,590 --> 01:11:27,030
事务并且 它想

1707
01:11:27,030 --> 01:11:30,330
阅读那个页面，然后你继续

1708
01:11:30,330 --> 01:11:34,020
写日志，所以这里的想法就像你

1709
01:11:34,020 --> 01:11:35,280
必须有即时恢复，你

1710
01:11:35,280 --> 01:11:36,620
说好的我重新上线，

1711
01:11:36,620 --> 01:11:39,330
即使我的戴维斯没有处于

1712
01:11:39,330 --> 01:11:42,270
不正确的状态，没有交易可以读取

1713
01:11:42,270 --> 01:11:44,010
那些 尚未正确回滚的页面

1714
01:11:44,010 --> 01:11:46,440
，只有当您

1715
01:11:46,440 --> 01:11:47,880
继续阅读它们时，您才会真正

1716
01:11:47,880 --> 01:11:50,730
应用它们

1717
01:11:50,730 --> 01:11:53,940


1718
01:11:53,940 --> 01:11:56,700


1719
01:11:56,700 --> 01:11:59,070
它的一小部分而不是

1720
01:11:59,070 --> 01:12:00,780
阻止对整个数据库的访问

1721
01:12:00,780 --> 01:12:02,730
为什么要撤消这少量的页面

1722
01:12:02,730 --> 01:12:05,160
你只是立即返回并让

1723
01:12:05,160 --> 01:12:06,450
任何人阅读他们想要的任何内容

1724
01:12:06,450 --> 01:12:07,650
只是当他们尝试阅读时阻止他们

1725
01:12:07,650 --> 01:12:08,940
y 你还没有回滚，

1726
01:12:08,940 --> 01:12:12,480
我认为没有人真正做过这个

1727
01:12:12,480 --> 01:12:15,090
优化，最后一个

1728
01:12:15,090 --> 01:12:18,360
只是重写你的应用程序，这样

1729
01:12:18,360 --> 01:12:19,530
你就没有长时间运行的事务，

1730
01:12:19,530 --> 01:12:21,810
因为你最大限度地减少了日志中的回滚时间

1731
01:12:21,810 --> 01:12:23,280
最后一个检查点你必须

1732
01:12:23,280 --> 01:12:25,590
去然后重播，如果你能减少

1733
01:12:25,590 --> 01:12:28,350
它，那么重做阶段和

1734
01:12:28,350 --> 01:12:34,030
撤销支付会更快

1735
01:12:34,030 --> 01:12:36,230


1736
01:12:36,230 --> 01:12:38,420


1737
01:12:38,420 --> 01:12:42,980
数据库没问题，所以

1738
01:12:42,980 --> 01:12:44,600
主要思想是针对我们覆盖的区域，我们

1739
01:12:44,600 --> 01:12:47,600
使用钢铁

1740
01:12:47,600 --> 01:12:49,460
无力和模糊检查点，这

1741
01:12:49,460 --> 01:12:50,480
基本上只是拍摄

1742
01:12:50,480 --> 01:12:52,580
所有脏页 ID 的快照，因此我们认为我们

1743
01:12:52,580 --> 01:12:54,950
知道哪个被修改了，然后

1744
01:12:54,950 --> 01:12:56,480
我们 将重做自

1745
01:12:56,480 --> 01:12:58,700
我们右头日志中最早的付费脏页以来的所有内容

1746
01:12:58,700 --> 01:13:00,260
，然后我们撤消

1747
01:13:00,260 --> 01:13:01,850


1748
01:13:01,850 --> 01:13:03,410
在右头

1749
01:13:03,410 --> 01:13:05,750
日志完成之前没有最终提交的事务，然后我们添加这些 CLR，

1750
01:13:05,750 --> 01:13:07,910
因此请确保我们 r 记录

1751
01:13:07,910 --> 01:13:09,950
为更新数据库而执行的所有撤消操作

1752
01:13:09,950 --> 01:13:11,870
和日志序列

1753
01:13:11,870 --> 01:13:12,710
号是我们将

1754
01:13:12,710 --> 01:13:16,190
用来确定修改页面的日志记录是否

1755
01:13:16,190 --> 01:13:17,900
已

1756
01:13:17,900 --> 01:13:22,190
成功写入磁盘的方式

1757
01:13:22,190 --> 01:13:25,490
大约三分钟，让

1758
01:13:25,490 --> 01:13:26,600
我们做一个快速演示，向你展示

1759
01:13:26,600 --> 01:13:29,300
这确实有效，所以

1760
01:13:29,300 --> 01:13:32,060
会有我的续集，我们会有一张

1761
01:13:32,060 --> 01:13:43,460
桌子，让我也把它关掉，对不起，

1762
01:13:43,460 --> 01:13:50,680
让我们太糟糕了，所以我们会有一张

1763
01:13:50,680 --> 01:13:58,190
桌子 只有一行有十

1764
01:13:58,190 --> 01:14:00,520
列，

1765
01:14:03,800 --> 01:14:07,139
一二三四五六七

1766
01:14:07,139 --> 01:14:08,699
八九 然后我们将有一个

1767
01:14:08,699 --> 01:14:10,979
简单的 Python 程序，它在

1768
01:14:10,979 --> 01:14:13,429
单个事务中它会取

1769
01:14:13,429 --> 01:14:17,340
第一列并将其

1770
01:14:17,340 --> 01:14:20,280
滑到下一列 一个然后你知道它会将

1771
01:14:20,280 --> 01:14:21,959
每一列增加一

1772
01:14:21,959 --> 01:14:31,709
所以我们要让它运行哦对了

1773
01:14:31,709 --> 01:14:32,579
只是为了证明它确实在工作

1774
01:14:32,579 --> 01:14:34,439
我们再次选择正确我们看到它正在

1775
01:14:34,439 --> 01:14:37,050
一一增加所以我们的

1776
01:14:37,050 --> 01:14:38,519
交易它正在运行 在一个无限

1777
01:14:38,519 --> 01:14:40,679
循环中我的意思是在这里我们有

1778
01:14:40,679 --> 01:14:42,570
来自我的续集的日志消息告诉

1779
01:14:42,570 --> 01:14:44,669
我们它实际上正在运行所以

1780
01:14:44,669 --> 01:14:47,219
我们要做的是对我的

1781
01:14:47,219 --> 01:14:51,389
续集杀戮进行硬杀 - 9 好吧，

1782
01:14:51,389 --> 01:14:53,280
这将杀死一切 瞧，

1783
01:14:53,280 --> 01:14:55,380
你看到日志实际上被

1784
01:14:55,380 --> 01:14:56,760
绊倒了，它说我们崩溃了，然后

1785
01:14:56,760 --> 01:14:58,530
它正在运行 Ubuntu 它有一个服务

1786
01:14:58,530 --> 01:15:00,209
说，如果像我的续集崩溃一样，它会

1787
01:15:00,209 --> 01:15:01,800
自动为你重新启动它，但

1788
01:15:01,800 --> 01:15:03,209
你可以看到我们在这里断开了连接

1789
01:15:03,209 --> 01:15:04,530
， 然后我们的 Python 代码在

1790
01:15:04,530 --> 01:15:06,149
此处断开连接，所以这证明了

1791
01:15:06,149 --> 01:15:07,979
当我执行 kill 时 - 九个就像它

1792
01:15:07,979 --> 01:15:10,229
杀死了所有东西，所以让我们实际

1793
01:15:10,229 --> 01:15:18,209
查看日志，看看它说了什么

1794
01:15:18,209 --> 01:15:20,010
细节所有这些都无关紧要但 Lona

1795
01:15:20,010 --> 01:15:24,599
躲在这里 说数据库没有

1796
01:15:24,599 --> 01:15:25,800
正常关闭，开始崩溃

1797
01:15:25,800 --> 01:15:27,300
恢复开始在数据中应用一批旧的步行

1798
01:15:27,300 --> 01:15:29,550
记录，所以这只是

1799
01:15:29,550 --> 01:15:32,130
百分比，所以这是在做 Aires 这

1800
01:15:32,130 --> 01:15:33,360
就是说，嘿，他们去查看

1801
01:15:33,360 --> 01:15:35,820
日志，找出正在运行的内容，然后

1802
01:15:35,820 --> 01:15:37,889
继续 回复他们，所以现在当我们

1803
01:15:37,889 --> 01:15:40,709
回去查看我们的数据库时，我们

1804
01:15:40,709 --> 01:15:43,979
连接它以证明

1805
01:15:43,979 --> 01:15:45,389
我们的交易没有任何损坏的日期，

1806
01:15:45,389 --> 01:15:46,709
我们应该保证每一

1807
01:15:46,709 --> 01:15:48,780
列都比

1808
01:15:48,780 --> 01:15:51,300
前一列大一 瞧，

1809
01:15:51,300 --> 01:15:56,789
在这种情况下，这是我的续集，还可以，

1810
01:15:56,789 --> 01:15:58,769
我不知道还有什么其他方式可以向

1811
01:15:58,769 --> 01:16:01,559
您展示数据库崩溃的演示

1812
01:16:01,559 --> 01:16:03,929
，但这是我能想到的最好的方法

1813
01:16:03,929 --> 01:16:07,130
，是的，

1814
01:16:09,870 --> 01:16:11,950
就像我杀死它时那样为什么 他们是否立即

1815
01:16:11,950 --> 01:16:13,900
恢复了这是一个 Ubuntu 的东西

1816
01:16:13,900 --> 01:16:16,540
这是你的一群人有一个服务 它说

1817
01:16:16,540 --> 01:16:18,040
如果这个东西崩溃了它会重新启动

1818
01:16:18,040 --> 01:16:20,260
它 是的 这对我的续集来说并不特别

1819
01:16:20,260 --> 01:16:21,360
它是操作系统这样做

1820
01:16:21,360 --> 01:16:29,320
是的 好吧 所以这一点你

1821
01:16:29,320 --> 01:16:31,240
可以 假设你知道你可以退出 CMU

1822
01:16:31,240 --> 01:16:33,130
你的大脑中有足够的信息

1823
01:16:33,130 --> 01:16:35,440
可以出去伪造一个可靠的

1824
01:16:35,440 --> 01:16:36,910
事务数据库分钟系统

1825
01:16:36,910 --> 01:16:38,590
因为你知道恢复新

1826
01:16:38,590 --> 01:16:39,760
事务你知道查询优化

1827
01:16:39,760 --> 01:16:42,460
你可以做数据库存储

1828
01:16:42,460 --> 01:16:44,170
这就是我在本学期的这一点上

1829
01:16:44,170 --> 01:16:45,970
的内容 这些是

1830
01:16:45,970 --> 01:16:48,450
您需要了解的关于数据库功能的核心内容

1831
01:16:48,450 --> 01:16:51,850
所以从下周一

1832
01:16:51,850 --> 01:16:53,200
开始现在开始讨论我的分布式数据库

1833
01:16:53,200 --> 01:16:55,630


1834
01:16:55,630 --> 01:16:57,970
到目前为止我们讨论过的所有相同的概念 学期仍然

1835
01:16:57,970 --> 01:16:59,350
有同样的

1836
01:16:59,350 --> 01:17:00,610
问题我们认为

1837
01:17:00,610 --> 01:17:02,500
刚才考虑实习和数据库的同样问题我们

1838
01:17:02,500 --> 01:17:03,610
必须考虑网络，这可能

1839
01:17:03,610 --> 01:17:07,090
稍微有点棘手，所以在这

1840
01:17:07,090 --> 01:17:09,430
一点上再说一遍，尽管说哦，我赢了或

1841
01:17:09,430 --> 01:17:10,510
贡献了数据库 你需要

1842
01:17:10,510 --> 01:17:11,860
先解开单节点数据库的链接

1843
01:17:11,860 --> 01:17:16,120
，这就是你知道

1844
01:17:16,120 --> 01:17:21,240
他们实际上在做什么的关键，伙计们

1845
01:17:34,470 --> 01:17:37,549
[音乐]

1846
01:17:53,960 --> 01:17:57,050
[音乐]

