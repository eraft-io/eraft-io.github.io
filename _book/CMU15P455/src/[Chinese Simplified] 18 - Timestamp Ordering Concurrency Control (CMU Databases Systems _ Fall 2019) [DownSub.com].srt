1
00:00:03,640 --> 00:00:19,630
[音乐]

2
00:00:19,630 --> 00:00:24,439
好吧，所以上一课我

3
00:00:24,439 --> 00:00:28,720
认为 Matt 介绍了两阶段锁定和

4
00:00:28,720 --> 00:00:30,859
两件式锁定是一种机制

5
00:00:30,859 --> 00:00:32,930
，数据库可以使用该机制

6
00:00:32,930 --> 00:00:35,870
在运行时生成可序列化的调度，

7
00:00:35,870 --> 00:00:36,290


8
00:00:36,290 --> 00:00:38,450
而今天它依赖于锁才能做到

9
00:00:38,450 --> 00:00:40,010
这一点 我们将要讨论

10
00:00:40,010 --> 00:00:42,350
的是一个

11
00:00:42,350 --> 00:00:44,000
不依赖于锁而是依赖

12
00:00:44,000 --> 00:00:47,539
于高级时间戳的协议集合 也许

13
00:00:47,539 --> 00:00:49,760
有一个很好的思考方式

14
00:00:49,760 --> 00:00:53,420
是两阶段锁定假设

15
00:00:53,420 --> 00:00:54,500
会有 在数据库

16
00:00:54,500 --> 00:00:56,449
内部执行的事务

17
00:00:56,449 --> 00:00:57,949
内部

18
00:00:57,949 --> 00:01:00,199
有很多争用，所以如果有很多

19
00:01:00,199 --> 00:01:01,579
争用，那么显然我

20
00:01:01,579 --> 00:01:05,330
有防御的优势并需要很多

21
00:01:05,330 --> 00:01:06,950
锁，所以任何时候你想读或

22
00:01:06,950 --> 00:01:09,890
写 进入数据库对象，您

23
00:01:09,890 --> 00:01:12,500
获得这些锁，因此从这个意义上说，

24
00:01:12,500 --> 00:01:14,540
这是非常悲观的，另一方面，

25
00:01:14,540 --> 00:01:17,240
您可以将基于时间戳排序的

26
00:01:17,240 --> 00:01:20,360
技术视为更乐观的权利，您

27
00:01:20,360 --> 00:01:22,790
允许数据库操作和读取

28
00:01:22,790 --> 00:01:23,600
以及 在没有实际获取锁的情况下写入数据，

29
00:01:23,600 --> 00:01:25,280
并且在一天结束时，

30
00:01:25,280 --> 00:01:26,840
您可以在一天结束时

31
00:01:26,840 --> 00:01:29,450
正确协调正确的可

32
00:01:29,450 --> 00:01:31,070
序列化计划

33
00:01:31,070 --> 00:01:32,570
，我们将讨论这

34
00:01:32,570 --> 00:01:33,799
实际上是如何在数据库内部完成的

35
00:01:33,799 --> 00:01:37,670
我们

36
00:01:37,670 --> 00:01:39,740


37
00:01:39,740 --> 00:01:41,030
将在本讲座中讨论两次时间排序协议

38
00:01:41,030 --> 00:01:42,500
，其中一个实际上称为时间戳

39
00:01:42,500 --> 00:01:43,939
排序或基本时间戳排序

40
00:01:43,939 --> 00:01:46,759
，另一个称为

41
00:01:46,759 --> 00:01:48,920
乐观并发控制，所以它

42
00:01:48,920 --> 00:01:49,880
有点 令人困惑，因为它们

43
00:01:49,880 --> 00:01:50,990
都很乐观，而且它们都是

44
00:01:50,990 --> 00:01:53,180
时间戳排序 这

45
00:01:53,180 --> 00:01:54,439
只是社区提出

46
00:01:54,439 --> 00:01:58,399


47
00:01:58,399 --> 00:02:00,439


48
00:02:00,439 --> 00:02:03,200


49
00:02:03,200 --> 00:02:05,899
的术语 将数值分配

50
00:02:05,899 --> 00:02:08,060
给预定义

51
00:02:08,060 --> 00:02:09,830
这些事务的提交顺序的时间戳，

52
00:02:09,830 --> 00:02:11,960
您可以假设

53
00:02:11,960 --> 00:02:12,980
这里将有一个新函数调用 d

54
00:02:12,980 --> 00:02:16,430
给定事务的 TS 为您

55
00:02:16,430 --> 00:02:18,260
提供该事务的时间戳，

56
00:02:18,260 --> 00:02:20,810
因此数据库试图保证的

57
00:02:20,810 --> 00:02:22,760
是，如果事务 TI 的

58
00:02:22,760 --> 00:02:24,050
时间戳小于

59
00:02:24,050 --> 00:02:26,240
事务 TJ，那么在串行

60
00:02:26,240 --> 00:02:28,190
调度中，就好像 TI 发生

61
00:02:28,190 --> 00:02:32,980
在 TJ 内部之前 数据库好的，那么

62
00:02:32,980 --> 00:02:34,880
这是如何完成的，比如这些

63
00:02:34,880 --> 00:02:37,250
时间戳是什么样的，时间戳是

64
00:02:37,250 --> 00:02:40,459
一种独特的固定数值，

65
00:02:40,459 --> 00:02:42,260
它们有几个有趣的

66
00:02:42,260 --> 00:02:44,270
特征

67
00:02:44,270 --> 00:02:46,310
，数据库必须维护的

68
00:02:46,310 --> 00:02:48,560
第一个特征是这些时间戳

69
00:02:48,560 --> 00:02:50,420
必须 可以单调增加，所以

70
00:02:50,420 --> 00:02:52,400
他们必须总是及时前进

71
00:02:52,400 --> 00:02:55,010
并增加时间第二件事

72
00:02:55,010 --> 00:02:57,410
是他们必须是唯一的值，

73
00:02:57,410 --> 00:02:59,150
这样你就可以有两个交易

74
00:02:59,150 --> 00:03:01,280
具有相同的时间戳，因为这种

75
00:03:01,280 --> 00:03:03,340
单调增加的特征

76
00:03:03,340 --> 00:03:06,170
所以再次假设 数据库现在

77
00:03:06,170 --> 00:03:08,390
有这个新函数 这个 TS 函数

78
00:03:08,390 --> 00:03:10,790
能够获取事务 ID 并

79
00:03:10,790 --> 00:03:11,870
返回给你 该

80
00:03:11,870 --> 00:03:16,519
交易的时间戳，这些不同的 x

81
00:03:16,519 --> 00:03:18,130
时间协议具有不同的

82
00:03:18,130 --> 00:03:21,470
机制和时间点，它们

83
00:03:21,470 --> 00:03:23,780
实际将这些时间戳分配给

84
00:03:23,780 --> 00:03:26,570
交易，一个重要的特征

85
00:03:26,570 --> 00:03:28,340
是这些时间戳

86
00:03:28,340 --> 00:03:29,989
不一定必须与挂钟时间相对应，

87
00:03:29,989 --> 00:03:32,810
因为它们 可以

88
00:03:32,810 --> 00:03:34,519


89
00:03:34,519 --> 00:03:36,769
在其执行期间的任何时候分配给事务，不一定

90
00:03:36,769 --> 00:03:38,120
在它进入系统时甚至

91
00:03:38,120 --> 00:03:39,410
在即将提交正确时也不一定，

92
00:03:39,410 --> 00:03:40,790
因此不同的协议具有

93
00:03:40,790 --> 00:03:42,560
不同的机制

94
00:03:42,560 --> 00:03:43,850
，它们实际

95
00:03:43,850 --> 00:03:47,900
为事务分配时间戳的机制和时间点是

96
00:03:47,900 --> 00:03:49,370
有的 关于如何为事务实际获取时间戳的几种不同方法

97
00:03:49,370 --> 00:03:52,130


98
00:03:52,130 --> 00:03:53,540
好的，我在这里列出了

99
00:03:53,540 --> 00:03:55,489
一些 最简单的事情你

100
00:03:55,489 --> 00:03:57,769
可以做的就是问 CPU 好

101
00:03:57,769 --> 00:03:59,030
，当前时间是什么，因为时间

102
00:03:59,030 --> 00:04:00,230
总是在增加，你可以 假设

103
00:04:00,230 --> 00:04:03,709
这种是有道理的，但是

104
00:04:03,709 --> 00:04:05,269
有一些缺点可以

105
00:04:05,269 --> 00:04:06,950
任何人都会考虑

106
00:04:06,950 --> 00:04:09,530
使用挂钟时间或实时

107
00:04:09,530 --> 00:04:18,140
作为时间戳的一些缺点是的，所以

108
00:04:18,140 --> 00:04:19,370
只要您使用

109
00:04:19,370 --> 00:04:21,019
同一台计算机并且只要

110
00:04:21,019 --> 00:04:22,880
时间单调增加

111
00:04:22,880 --> 00:04:26,120
那么这并不重要 应该没问题，所以这是

112
00:04:26,120 --> 00:04:26,990
一个好点，所以如果你有

113
00:04:26,990 --> 00:04:29,300
基于残疾的分布式，并且

114
00:04:29,300 --> 00:04:30,650
很难保持这些时间点

115
00:04:30,650 --> 00:04:32,419
同步使用挂钟时间的另一个问题是

116
00:04:32,419 --> 00:04:34,870


117
00:04:37,800 --> 00:04:39,910
你可以倒转时钟什么时候

118
00:04:39,910 --> 00:04:48,040
你会真正倒转时钟 当然

119
00:04:48,040 --> 00:04:49,600
是的，所以你记录的实际ganya粒度可能会有些偏差，

120
00:04:49,600 --> 00:04:51,310


121
00:04:51,310 --> 00:04:53,740
还有另一个

122
00:04:53,740 --> 00:05:06,490
可能的缺点是的，所以你

123
00:05:06,490 --> 00:05:07,900
实际上不必保持

124
00:05:07,900 --> 00:05:09,820
你只需要像这样

125
00:05:09,820 --> 00:05:12,400
的时间点的持续时间就是时间点 时间点二而且

126
00:05:12,400 --> 00:05:15,490
它在增加所以它不一定

127
00:05:15,490 --> 00:05:17,170
是持续时间只是一个

128
00:05:17,170 --> 00:05:20,290
时间点，所以一个线索是它会

129
00:05:20,290 --> 00:05:24,580
发生在这个周末是的，是的，是的，

130
00:05:24,580 --> 00:05:26,050
所以一天就像说那天 ht 节省是

131
00:05:26,050 --> 00:05:27,400
正确的，所以可能是这样的情况，你

132
00:05:27,400 --> 00:05:28,690
知道你在周末工作，

133
00:05:28,690 --> 00:05:31,030
然后随机在一个随机点

134
00:05:31,030 --> 00:05:32,920
你的时钟倒退一个小时，

135
00:05:32,920 --> 00:05:34,300
你的时间戳几乎被

136
00:05:34,300 --> 00:05:37,470
搞砸了，

137
00:05:37,710 --> 00:05:40,090
另一个选择实际上是 正确使用这些

138
00:05:40,090 --> 00:05:41,800
逻辑计数器，这样你就可以

139
00:05:41,800 --> 00:05:43,660
想到只有一个寄存器寄存器

140
00:05:43,660 --> 00:05:45,370
和 CPU 专用于单调时间

141
00:05:45,370 --> 00:05:47,860
单调递增的 32 位 64 位

142
00:05:47,860 --> 00:05:51,750
值，这种方法有什么缺点或

143
00:05:51,750 --> 00:05:54,610
潜在的缺点

144
00:05:54,610 --> 00:06:05,110
是的，所以分布方面是

145
00:06:05,110 --> 00:06:08,350
仍然是一个重要因素，但

146
00:06:08,350 --> 00:06:09,580
假设 CPU 有一个计数器，并且

147
00:06:09,580 --> 00:06:11,470


148
00:06:11,470 --> 00:06:13,990
在不需要锁的情况下增加它真的很快，就像你可以做一个

149
00:06:13,990 --> 00:06:15,280
原子加法或类似的事情

150
00:06:15,280 --> 00:06:17,170
，使用这个逻辑计数器有什么问题，

151
00:06:17,170 --> 00:06:24,140
所以我说

152
00:06:24,140 --> 00:06:27,500
两位或 64 位 如果您

153
00:06:27,500 --> 00:06:30,140
用完 32 位值会发生什么，然后您

154
00:06:30,140 --> 00:06:31,640
使您的版本饱和并向右回滚，

155
00:06:31,640 --> 00:06:33,590
因此您的计数器现在会

156
00:06:33,590 --> 00:06:35,390
及时倒退，这是其中之一

157
00:06:35,390 --> 00:06:38,300
这种方法存在问题，

158
00:06:38,300 --> 00:06:40,070
所以大多数系统实际上使用这种混合

159
00:06:40,070 --> 00:06:41,270
方法，就像

160
00:06:41,270 --> 00:06:42,950
生理学的东西，它有点

161
00:06:42,950 --> 00:06:44,660
匹配物理计数器和

162
00:06:44,660 --> 00:06:46,130
逻辑计数器，以确保

163
00:06:46,130 --> 00:06:51,890
一切正常，因此

164
00:06:51,890 --> 00:06:54,050
系统时钟的一个问题是你有

165
00:06:54,050 --> 00:06:56,210
夏令时是正确的，所以在

166
00:06:56,210 --> 00:06:57,800
一天的某个时间点，比如

167
00:06:57,800 --> 00:06:59,900
夏令时发生，你的时间

168
00:06:59,900 --> 00:07:02,960
倒退或倒退一个小时，所以现在你的

169
00:07:02,960 --> 00:07:04,550
时间不是单调增加

170
00:07:04,550 --> 00:07:10,570
它不会及时倒退，

171
00:07:10,600 --> 00:07:14,420
所以只是给你一个

172
00:07:14,420 --> 00:07:15,860
了解今天的议程，所以

173
00:07:15,860 --> 00:07:17,270
我们将讨论

174
00:07:17,270 --> 00:07:18,950
称为基本时间戳排序协议的内容，

175
00:07:18,950 --> 00:07:20,050
然后我们将讨论

176
00:07:20,050 --> 00:07:22,370
乐观并发协议，它

177
00:07:22,370 --> 00:07:25,040
也是基于时间戳的协议，然后

178
00:07:25,040 --> 00:07:26,150
我们将讨论 关于基于分区

179
00:07:26,150 --> 00:07:27,560
的时间戳囤积协议，它

180
00:07:27,560 --> 00:07:29,450
缓解了一些瓶颈，然后

181
00:07:29,450 --> 00:07:30,980
常规时间滑雪板协议有

182
00:07:30,980 --> 00:07:32,360
，然后我们要讨论的

183
00:07:32,360 --> 00:07:35,090
是 处理级别 好的，所以让我们

184
00:07:35,090 --> 00:07:35,570


185
00:07:35,570 --> 00:07:37,850
开始使用这些时间排序

186
00:07:37,850 --> 00:07:40,190
方案 总体思路是，您

187
00:07:40,190 --> 00:07:41,960
希望事务在

188
00:07:41,960 --> 00:07:43,820
系统中继续读取和写入对象，

189
00:07:43,820 --> 00:07:47,240
而无需实际获取锁 可以

190
00:07:47,240 --> 00:07:49,220
使这成为可能，您知道您必须

191
00:07:49,220 --> 00:07:51,050
添加一些额外的元数据 对于所有

192
00:07:51,050 --> 00:07:52,840
数据库对象，要使这成为可能，

193
00:07:52,840 --> 00:07:55,370
特别是您必须为系统

194
00:07:55,370 --> 00:07:57,680
中的每个元组添加两个额外的时间戳，

195
00:07:57,680 --> 00:07:59,330
您必须添加一个读取时间戳

196
00:07:59,330 --> 00:08:02,450
，代表它们的

197
00:08:02,450 --> 00:08:04,460
事务时间戳最近的事务

198
00:08:04,460 --> 00:08:06,560
然后读取此项目和 一个写

199
00:08:06,560 --> 00:08:07,940
时间戳，它是

200
00:08:07,940 --> 00:08:09,920
最近写入

201
00:08:09,920 --> 00:08:11,990
这个元组和系统

202
00:08:11,990 --> 00:08:15,380
中的事务的时间戳，然后当事务

203
00:08:15,380 --> 00:08:16,940
正在执行它的操作时，它只是

204
00:08:16,940 --> 00:08:18,740
要确保它实际上可以读取

205
00:08:18,740 --> 00:08:20,960
这个元组 利用

206
00:08:20,960 --> 00:08:23,060
与这个元组相关联的时间戳现在可以

207
00:08:23,060 --> 00:08:25,270
了，我将讨论这是如何做到的

208
00:08:25,270 --> 00:08:30,050
，对于读取来说有一个不变式

209
00:08:30,050 --> 00:08:31,340
你必须确保在你

210
00:08:31,340 --> 00:08:32,990
真正被允许从数据库系统中读取一个值之前，

211
00:08:32,990 --> 00:08:34,669
你必须

212
00:08:34,669 --> 00:08:36,229
确保时间戳，这样你

213
00:08:36,229 --> 00:08:38,500
才能为这个事务读取你自己的时间戳 TI

214
00:08:38,500 --> 00:08:40,270
你必须确保它

215
00:08:40,270 --> 00:08:43,030
小于正确的时间 在系统中为这个元组打上戳

216
00:08:43,030 --> 00:08:46,330
好的 这是否有意义

217
00:08:46,330 --> 00:08:47,770
这对我意味着什么 这

218
00:08:47,770 --> 00:08:49,590
意味着基本上确保

219
00:08:49,590 --> 00:08:51,550
没有其他事务

220
00:08:51,550 --> 00:08:55,210
写入系统 是的 系统中没有

221
00:08:55,210 --> 00:08:56,890
其他事务

222
00:08:56,890 --> 00:08:58,960
写入到这个元组中

223
00:08:58,960 --> 00:09:01,420
应该读过你的，但谁能说

224
00:09:01,420 --> 00:09:03,940
你没有从未来读取元组的值，

225
00:09:03,940 --> 00:09:05,530
所以未来的

226
00:09:05,530 --> 00:09:07,030
交易会

227
00:09:07,030 --> 00:09:09,030
覆盖

228
00:09:09,030 --> 00:09:12,070
你现在应该读取的数据库值，这

229
00:09:12,070 --> 00:09:14,380
本质上是一个问题，

230
00:09:14,380 --> 00:09:15,850
当这个 碰巧你本质上

231
00:09:15,850 --> 00:09:17,560
必须中止，当你中止时，你必须

232
00:09:17,560 --> 00:09:18,550
确保你从一个更新的事务开始，

233
00:09:18,550 --> 00:09:21,700


234
00:09:21,700 --> 00:09:22,750
一个比你当时拥有的时间戳更新的时间戳 您最初

235
00:09:22,750 --> 00:09:24,970
开始了交易 是否每个人都

236
00:09:24,970 --> 00:09:26,230
有些理解为什么您需要

237
00:09:26,230 --> 00:09:29,680
分配一个更新的时间戳

238
00:09:29,680 --> 00:09:31,120
如果您拥有与之前相同的时间戳会发生

239
00:09:31,120 --> 00:09:35,020
什么 您会遇到

240
00:09:35,020 --> 00:09:36,460
同样的问题，您必须这样做，

241
00:09:36,460 --> 00:09:37,900
因为 mod 因为您必须 确保

242
00:09:37,900 --> 00:09:39,490
时间戳单调增加

243
00:09:39,490 --> 00:09:41,350
你必须得到一个新的时间戳来避免

244
00:09:41,350 --> 00:09:53,590
这个问题是的所以如果你的时间戳

245
00:09:53,590 --> 00:09:55,540
与正确的时间戳相同

246
00:09:55,540 --> 00:09:57,960
这意味着

247
00:09:58,200 --> 00:09:59,380


248
00:09:59,380 --> 00:10:01,570
你可以阅读它你可以正确阅读它

249
00:10:01,570 --> 00:10:03,070
应该是可重复读取它

250
00:10:03,070 --> 00:10:15,180
非常好 是的，所以在这个方案中，

251
00:10:15,180 --> 00:10:17,770
其他时间在您开始时分配，也

252
00:10:17,770 --> 00:10:20,730
就是开始事务的时间，

253
00:10:20,730 --> 00:10:23,620
所以如果这个不变式无效，

254
00:10:23,620 --> 00:10:25,690
您基本上必须中止，但

255
00:10:25,690 --> 00:10:28,600
另一方面，如果您实际上被允许

256
00:10:28,600 --> 00:10:31,900
执行读取，那么您修改

257
00:10:31,900 --> 00:10:33,550
读取该元组的时间戳，以获取当前

258
00:10:33,550 --> 00:10:35,890
读取时间戳的最大值

259
00:10:35,890 --> 00:10:37,900
以及您

260
00:10:37,900 --> 00:10:40,870
自己的时间戳是否有人知道为什么

261
00:10:40,870 --> 00:10:43,920
你必须采取最大

262
00:10:47,089 --> 00:10:48,230
时间必须是单调

263
00:10:48,230 --> 00:10:49,910
递增的速度你可以有一个

264
00:10:49,910 --> 00:10:51,920
比你

265
00:10:51,920 --> 00:10:54,110
更新读取时间戳更新的事务，但你不能将

266
00:10:54,110 --> 00:10:55,910
时间戳设置回你原来的时间

267
00:10:55,910 --> 00:10:57,709
，因为你年纪大了正确的

268
00:10:57,709 --> 00:10:58,879
时间 必须单调

269
00:10:58,879 --> 00:11:00,470
增加，所以你必须

270
00:11:00,470 --> 00:11:02,209
在阅读它的时候取最大值或任何正确的

271
00:11:02,209 --> 00:11:03,800
时间，

272
00:11:03,800 --> 00:11:07,100
你的时间戳是什么所以这很

273
00:11:07,100 --> 00:11:09,829
重要，所以一旦你更新

274
00:11:09,829 --> 00:11:12,259
了时间戳，你现在必须

275
00:11:12,259 --> 00:11:14,350
将此元组的副本复制到某个

276
00:11:14,350 --> 00:11:17,209
仅对您可见的本地私有工作区中，

277
00:11:17,209 --> 00:11:18,680
以便您可以确保获得

278
00:11:18,680 --> 00:11:52,639
可重复读取，因此

279
00:11:52,639 --> 00:11:54,259


280
00:11:54,259 --> 00:11:55,639
假设您想要正确读取某些元组，并且

281
00:11:55,639 --> 00:11:57,350
正确的时间戳来自

282
00:11:57,350 --> 00:11:59,179
比你新的交易是

283
00:11:59,179 --> 00:12:01,189
未来的正确你不应该能够正确

284
00:12:01,189 --> 00:12:02,329
读取该值你应该

285
00:12:02,329 --> 00:12:04,370


286
00:12:04,370 --> 00:12:05,990
在新交易写入之前读取它写入之前存在的值

287
00:12:05,990 --> 00:12:13,370
所以这就是它的原因 hidden 验证您

288
00:12:13,370 --> 00:12:14,990
是的，是的，因为您现在以

289
00:12:14,990 --> 00:12:16,339
不同的顺序出现在串行顺序中，

290
00:12:16,339 --> 00:12:18,319
您不应该这样做，因为您的

291
00:12:18,319 --> 00:12:20,059
时间戳比在串行顺序

292
00:12:20,059 --> 00:12:22,730
中逻辑上出现在此事务之后写入它

293
00:12:22,730 --> 00:12:26,259


294
00:12:28,569 --> 00:12:33,069
之前写入的时间戳要新

295
00:12:33,350 --> 00:12:35,250
这不是我认为

296
00:12:35,250 --> 00:12:36,810
本书中没有涵盖的内容，但是

297
00:12:36,810 --> 00:12:38,610
您必须确保必须制作本地副本，

298
00:12:38,610 --> 00:12:41,960
以便您可以发出可重复的读取，

299
00:12:43,700 --> 00:12:45,930
这样您就可以想象在租金中另一

300
00:12:45,930 --> 00:12:47,430
笔交易进入并更新

301
00:12:47,430 --> 00:12:49,800
系统，但是 您必须能够

302
00:12:49,800 --> 00:12:52,250
读取您最初正确读取的相同值，

303
00:12:52,250 --> 00:12:55,350
但是如果您

304
00:12:55,350 --> 00:12:56,550
允许另一个事务在此处更新该

305
00:12:56,550 --> 00:12:57,839
值，那么您将使

306
00:12:57,839 --> 00:13:00,420
这个不变的顶部无效，并且您

307
00:13:00,420 --> 00:13:01,290
将无法读取它 但

308
00:13:01,290 --> 00:13:02,370
实际上你应该能够正确阅读它，

309
00:13:02,370 --> 00:13:04,800
因为你写了它，你在

310
00:13:04,800 --> 00:13:20,760
事务中阅读了一致的状态是的

311
00:13:20,760 --> 00:13:22,589
，这是一个很好的观点，我

312
00:13:22,589 --> 00:13:24,240
认为你在暗示

313
00:13:24,240 --> 00:13:25,440
可能会有饥饿的事实 您

314
00:13:25,440 --> 00:13:28,200
在董事会中始终保持一致，这

315
00:13:28,200 --> 00:13:29,460
是这种方法的一个缺点，

316
00:13:29,460 --> 00:13:31,110
我们稍后会

317
00:13:31,110 --> 00:13:34,440
在演示文稿中讨论这个

318
00:13:34,440 --> 00:13:36,300


319
00:13:36,300 --> 00:13:40,800


320
00:13:40,800 --> 00:13:43,500
问题 如果您的时间戳

321
00:13:43,500 --> 00:13:47,250
小于您尝试写入的对象的读取时间戳，则

322
00:13:47,250 --> 00:13:48,510


323
00:13:48,510 --> 00:13:51,660
意味着它是一个较新的事务，它

324
00:13:51,660 --> 00:13:54,089
读取了一个过时的值，一个您

325
00:13:54,089 --> 00:13:55,260
应该作为事务来自您的值，

326
00:13:55,260 --> 00:13:57,450
但作为 不再如此

327
00:13:57,450 --> 00:13:59,459
，因此这同样违反了此时间

328
00:13:59,459 --> 00:14:02,610
步长登机协议

329
00:14:02,610 --> 00:14:05,400


330
00:14:05,400 --> 00:14:09,390


331
00:14:09,390 --> 00:14:11,130


332
00:14:11,130 --> 00:14:13,140


333
00:14:13,140 --> 00:14:15,270
这又是一个违规行为

334
00:14:15,270 --> 00:14:17,339
，这个想法是，如果这些

335
00:14:17,339 --> 00:14:19,800
条件中的任何一个为真，您必须中止

336
00:14:19,800 --> 00:14:21,900
并再次以更新的时间戳

337
00:14:21,900 --> 00:14:24,589
值开始，如果另一方面，则再次开始整个过程

338
00:14:24,589 --> 00:14:27,900


339
00:14:27,900 --> 00:14:29,550
这是一个有效的权利，然后您必须

340
00:14:29,550 --> 00:14:30,959
更新元组的正确时间戳

341
00:14:30,959 --> 00:14:34,230
，并且您

342
00:14:34,230 --> 00:14:37,400
基本上已经完成了您还必须进行

343
00:14:37,760 --> 00:14:40,980
口语阅读，您阅读了本地

344
00:14:40,980 --> 00:14:42,810
副本，而不是返回到

345
00:14:42,810 --> 00:14:45,920
进入数据库全局保持

346
00:14:46,120 --> 00:14:54,939
正常所以让我们通过一个

347
00:14:54,939 --> 00:14:56,920
例子来看看这会

348
00:14:56,920 --> 00:14:59,319
澄清一点所以我们这里有两个

349
00:14:59,319 --> 00:15:00,999
事务并且

350
00:15:00,999 --> 00:15:02,230
假设你一次只能执行一个

351
00:15:02,230 --> 00:15:04,120
事务一个操作所以

352
00:15:04,120 --> 00:15:05,649
你可以假设单个 核心单线程

353
00:15:05,649 --> 00:15:08,290
，在这个数据库中，

354
00:15:08,290 --> 00:15:10,269
我们现在已经

355
00:15:10,269 --> 00:15:12,699


356
00:15:12,699 --> 00:15:14,410
用读取时间戳和写入

357
00:15:14,410 --> 00:15:17,259


358
00:15:17,259 --> 00:15:21,459
时间戳对所有元组进行

359
00:15:21,459 --> 00:15:23,230
了注释 被分配了一个时间戳

360
00:15:23,230 --> 00:15:25,720
假设 T 1 被分配了一个

361
00:15:25,720 --> 00:15:27,879
时间戳 1 并且 T 2 被分配了一个时间戳

362
00:15:27,879 --> 00:15:31,209
书来写很简单然后

363
00:15:31,209 --> 00:15:34,360
你读了所以 T 1 读了 B 你

364
00:15:34,360 --> 00:15:36,040
看看 B 的写时间戳 它是

365
00:15:36,040 --> 00:15:38,949
0 1 大于 0 所以你更新

366
00:15:38,949 --> 00:15:43,360
和读取时间戳为 1 然后我们做一个

367
00:15:43,360 --> 00:15:45,610
联系人切换到事务 2 并且

368
00:15:45,610 --> 00:15:48,550
T 2 现在想要读取 B 如果你

369
00:15:48,550 --> 00:15:50,679
查看写入时间戳并且你

370
00:15:50,679 --> 00:15:51,970
很好 去所以你更新读取时间

371
00:15:51,970 --> 00:15:53,589
时间以获取它的最大值

372
00:15:53,589 --> 00:15:56,050
，即 1 和新的时间戳 2，

373
00:15:56,050 --> 00:16:00,879
你现在得到 2 你做一个写

374
00:16:00,879 --> 00:16:04,269
所以 T 2 想要写 B 你

375
00:16:04,269 --> 00:16:05,319
看 写入时间戳和

376
00:16:05,319 --> 00:16:06,999
实时时间戳比两者都大，因此您

377
00:16:06,999 --> 00:16:10,709
将 B 的写入时间戳更新为 2

378
00:16:10,709 --> 00:16:14,259
好吧，现在您将上下文切换

379
00:16:14,259 --> 00:16:17,800
回 t1 t1 想要读取 a 它

380
00:16:17,800 --> 00:16:21,160
查看写入时间戳

381
00:16:21,160 --> 00:16:22,749
1 大于 0，因此您将读取

382
00:16:22,749 --> 00:16:24,730
时间戳更新为最大值 0 1，

383
00:16:24,730 --> 00:16:25,449
您很高兴

384
00:16:25,449 --> 00:16:28,689
抱歉是的，您现在将读取时间更新

385
00:16:28,689 --> 00:16:32,470
为 1，现在您又回到

386
00:16:32,470 --> 00:16:35,050
事务 2 和 2 想做的事情

387
00:16:35,050 --> 00:16:37,360
读a 你看

388
00:16:37,360 --> 00:16:39,459
a 2 的写时间戳大于0 你

389
00:16:39,459 --> 00:16:42,029
不时更新实时读时间戳为2

390
00:16:42,029 --> 00:16:46,720
finall  y t2 想要读取 a，

391
00:16:46,720 --> 00:16:48,639
因此它查看 a

392
00:16:48,639 --> 00:16:50,259
的写入时间戳上的读取时间戳，它

393
00:16:50,259 --> 00:16:51,910
大于它们两个，

394
00:16:51,910 --> 00:16:55,660
因此右侧是有效的，是的，因此不

395
00:16:55,660 --> 00:16:58,209
存在验证，不存在任何违规

396
00:16:58,209 --> 00:16:59,740
所以两个交易都在说

397
00:16:59,740 --> 00:17:03,280
，你可以同时提交它们，

398
00:17:03,280 --> 00:17:07,660
这很清楚，很好，所以让我们

399
00:17:07,660 --> 00:17:11,530
看另一个例子，所以这里的

400
00:17:11,530 --> 00:17:13,599
设置相同所有趋势所有

401
00:17:13,599 --> 00:17:15,819
初始时间戳都是 0 T 1 和 T 2

402
00:17:15,819 --> 00:17:18,579
进入系统 T 1 获取事务

403
00:17:18,579 --> 00:17:21,849
获取时间戳 1 T 2 获取 x 次 2

404
00:17:21,849 --> 00:17:24,670
好吧，所以在这种情况下，T 1

405
00:17:24,670 --> 00:17:27,130
想要读取它，它是一个很好的

406
00:17:27,130 --> 00:17:29,050
读取，因此它更新读取

407
00:17:29,050 --> 00:17:33,550
时间戳进行上下文切换，现在 T 2

408
00:17:33,550 --> 00:17:35,170
想要 写 a 它检查

409
00:17:35,170 --> 00:17:36,520
写时间戳和等待时间戳

410
00:17:36,520 --> 00:17:38,110
它是有效的所以它更新写

411
00:17:38,110 --> 00:17:42,460
时间戳为 2t 1 现在正在尝试

412
00:17:42,460 --> 00:17:45,940
写 a 所以检查正确的时间

413
00:17:45,940 --> 00:17:48,070
时间为 3 次 2m 它不是 更有效，

414
00:17:48,070 --> 00:17:50,200
因为你有它的时间戳

415
00:17:50,200 --> 00:17:53,350
1 是 1 比 a 的正确

416
00:17:53,350 --> 00:17:55,210
时间戳为 2 这是

417
00:17:55,210 --> 00:17:58,960
违规行为，因此 T 1 实际上无法提交

418
00:17:58,960 --> 00:18:04,180
它必须中止很明显

419
00:18:04,180 --> 00:18:06,280
您可以将其视为

420
00:18:06,280 --> 00:18:08,050
串行顺序，因为 T 1 具有时间戳

421
00:18:08,050 --> 00:18:10,360
1 和 T 2  s 次 n 2 T 1 应该出现

422
00:18:10,360 --> 00:18:16,000
在 T 1 和串行顺序之前，所以这

423
00:18:16,000 --> 00:18:17,710
显然是违规的，

424
00:18:17,710 --> 00:18:19,120
因为这里读取它会被

425
00:18:19,120 --> 00:18:26,760
中止，对不起，

426
00:18:26,760 --> 00:18:29,620
实际上我们可以在此处进行优化以

427
00:18:29,620 --> 00:18:31,290
避免在此特定情况下中止 场景

428
00:18:31,290 --> 00:18:34,780
正确，您可以将其视为在

429
00:18:34,780 --> 00:18:37,240
物理时间发生的事情，正确的 T 2

430
00:18:37,240 --> 00:18:38,710
正在写入某些内容，但随后它

431
00:18:38,710 --> 00:18:41,680
被 T 1 覆盖，所以我们真的

432
00:18:41,680 --> 00:18:45,760
需要这个权利吗？我认为

433
00:18:45,760 --> 00:18:47,170
观察结果是您实际上不需要

434
00:18:47,170 --> 00:18:50,590
它 可能是因为我们

435
00:18:50,590 --> 00:18:52,180
维护了一个本地的每个事务都

436
00:18:52,180 --> 00:18:53,680
维护了元组汤的本地副本，

437
00:18:53,680 --> 00:18:56,140
这里可以

438
00:18:56,140 --> 00:18:57,720
基本上被系统忽略，

439
00:18:57,720 --> 00:19:01,360
因为在外部这个权限

440
00:19:01,360 --> 00:19:04,030
是有效的，只要这个权限

441
00:19:04,030 --> 00:19:05,560
我 s 外部有效那么您

442
00:19:05,560 --> 00:19:07,960
实际上并不需要在交易外部使用

443
00:19:07,960 --> 00:19:08,980
此权限 您仍然需要此

444
00:19:08,980 --> 00:19:09,940
权限，因为您必须能够

445
00:19:09,940 --> 00:19:11,100
读取自己的权限，

446
00:19:11,100 --> 00:19:13,040
因此此

447
00:19:13,040 --> 00:19:15,800
观察导致优化

448
00:19:15,800 --> 00:19:17,360
，您可以在这些

449
00:19:17,360 --> 00:19:19,550
基于时间戳的系统中应用该优化 调用 Thomas

450
00:19:19,550 --> 00:19:22,430
Wright 规则，这个想法是，如果

451
00:19:22,430 --> 00:19:25,210
您像以前一样尝试写入对象 X

452
00:19:25,210 --> 00:19:27,770
，如果您的时间戳

453
00:19:27,770 --> 00:19:29,510
小于该对象的读取时间戳，

454
00:19:29,510 --> 00:19:31,490
您仍然必须中止并

455
00:19:31,490 --> 00:19:32,930
从更新的趋势开始 新建一个新的

456
00:19:32,930 --> 00:19:36,980
时间戳，但如果时间戳小于

457
00:19:36,980 --> 00:19:38,450
对象的写入时间戳，这

458
00:19:38,450 --> 00:19:39,800
意味着有一个较新的事务

459
00:19:39,800 --> 00:19:41,480
写入了该对象，您实际上

460
00:19:41,480 --> 00:19:43,670
可以完全忽略忽略正确

461
00:19:43,670 --> 00:19:45,830
您拥有写入的本地副本

462
00:19:45,830 --> 00:19:47,420
你现在可以阅读但从外部

463
00:19:47,420 --> 00:19:57,370
可以忽略这个权利是的是的是的

464
00:20:02,140 --> 00:20:04,690
所以这个权利只对 t1 很重要

465
00:20:04,690 --> 00:20:07,640
所以它不是真的我

466
00:20:07,640 --> 00:20:08,810
实际上不必将它传播

467
00:20:08,810 --> 00:20:09,920
回数据库因为 它会

468
00:20:09,920 --> 00:20:12,320
被这个权限覆盖，因为在

469
00:20:12,320 --> 00:20:14,000
串行顺序中，这首先发生，然后

470
00:20:14,000 --> 00:20:16,460
这个臀部这发生了，因为

471
00:20:16,460 --> 00:20:18,530
它的事务时间戳为 1，

472
00:20:18,530 --> 00:20:27,110
它的时间戳为 - 是的，所以这个

473
00:20:27,110 --> 00:20:28,550
优化实际上非常

474
00:20:28,550 --> 00:20:31,520
有用 特别是这个特定的

475
00:20:31,520 --> 00:20:35,080
场景，它允许你

476
00:20:35,080 --> 00:20:38,570
实际实际提交这个这个这个这个

477
00:20:38,570 --> 00:20:45,800
这个时间表 所以这

478
00:20:45,800 --> 00:20:49,430
与之前

479
00:20:49,430 --> 00:20:52,790


480
00:20:52,790 --> 00:20:55,610


481
00:20:55,610 --> 00:20:58,400
的例子相同 实际上，

482
00:20:58,400 --> 00:21:00,500
但通过应用 Thomas 写入规则，我们

483
00:21:00,500 --> 00:21:02,030
实际上并没有更新写入

484
00:21:02,030 --> 00:21:04,730
时间戳或值，嘿，但我们只是

485
00:21:04,730 --> 00:21:06,230
维护这个本地副本，我们忽略它

486
00:21:06,230 --> 00:21:08,180
，我们允许 T 继续所有

487
00:21:08,180 --> 00:21:09,680
后续读取此读取所有

488
00:21:09,680 --> 00:21:12,980
后续读取 a 在事务中，有时

489
00:21:12,980 --> 00:21:15,520
会在本地副本中

490
00:21:15,520 --> 00:21:23,290
使用此值

491
00:21:26,220 --> 00:21:34,900
好的是的 是的 所以这本质上是基本的

492
00:21:34,900 --> 00:21:37,600
时间戳排序，例如两相

493
00:21:37,600 --> 00:21:39,160
锁定已启动 它是一个机械 只要您不将其应用于 Thomas Wright 规则，

494
00:21:39,160 --> 00:21:40,720
数据库就会生成冲突的可

495
00:21:40,720 --> 00:21:42,940
序列化计划，

496
00:21:42,940 --> 00:21:44,980


497
00:21:44,980 --> 00:21:48,100
那么您可以

498
00:21:48,100 --> 00:21:50,200
完全防止死锁，因为您

499
00:21:50,200 --> 00:21:52,240
类似于两阶段锁定

500
00:21:52,240 --> 00:21:54,010
对您正在执行的每个操作的工作方式 在数据库上执行

501
00:21:54,010 --> 00:21:54,850
你确保

502
00:21:54,850 --> 00:21:57,100
这是一个有效的操作它

503
00:21:57,100 --> 00:21:58,300
有点像死锁预防，

504
00:21:58,300 --> 00:22:00,400
你正在增量生成这个

505
00:22:00,400 --> 00:22:01,570
利用率图，一旦你

506
00:22:01,570 --> 00:22:02,800
检测并检测到一个无效的循环，

507
00:22:02,800 --> 00:22:05,080
你就会在两阶段

508
00:22:05,080 --> 00:22:06,310
锁定中中止 在这里，

509
00:22:06,310 --> 00:22:08,200
您正在根据这些时间戳逐步检查每个

510
00:22:08,200 --> 00:22:10,030
操作是否有效

511
00:22:10,030 --> 00:22:11,410
，然后

512
00:22:11,410 --> 00:22:13,950
尽可能急切地急切地中止

513
00:22:13,950 --> 00:22:17,920
好的，我认为

514
00:22:17,920 --> 00:22:20,530
其中一个学生导致的一个缺点是您可能

515
00:22:20,530 --> 00:22:22,000
有可能

516
00:22:22,000 --> 00:22:23,230
饥饿的权利，你有它，你可以

517
00:22:23,230 --> 00:22:25,210
想到一个已经

518
00:22:25,210 --> 00:22:26,800
运行了很长时间的长事务，然后你

519
00:22:26,800 --> 00:22:28,360
有这些短事务，这些事务是

520
00:22:28,360 --> 00:22:29,950
p 在很短

521
00:22:29,950 --> 00:22:31,660
的时间内更新一些元组，

522
00:22:31,660 --> 00:22:33,370
然后提交并保留这些

523
00:22:33,370 --> 00:22:34,780
基本上会使所有

524
00:22:34,780 --> 00:22:37,090
旧事务无效，从而导致冲突，

525
00:22:37,090 --> 00:22:45,850
导致循环中止，

526
00:22:45,850 --> 00:22:46,810
所以我们应该在这里讨论的另一件事

527
00:22:46,810 --> 00:22:50,410
是这些时间 步进

528
00:22:50,410 --> 00:22:53,980
协议，它们允许它们允许

529
00:22:53,980 --> 00:22:57,100
不可恢复的时间表，

530
00:22:57,100 --> 00:22:59,350
所以什么是可恢复的时间表，所以

531
00:22:59,350 --> 00:23:02,980
如果事务

532
00:23:02,980 --> 00:23:04,840
仅在它依赖数据的所有先前事务也已提交的情况下提交，则时间表是可恢复的

533
00:23:04,840 --> 00:23:07,030
，

534
00:23:07,030 --> 00:23:09,490
您可以

535
00:23:09,490 --> 00:23:11,770
将其视为 就像他们喜欢 Casco Attucks

536
00:23:11,770 --> 00:23:12,640
级联

537
00:23:12,640 --> 00:23:15,310
中止一样，你想确保如果你

538
00:23:15,310 --> 00:23:16,930
从中读取一个值，该值由

539
00:23:16,930 --> 00:23:18,340
另一个事务更新，该

540
00:23:18,340 --> 00:23:20,610
事务在你提交

541
00:23:20,610 --> 00:23:23,200
基本时间戳排序之前提交并不能

542
00:23:23,200 --> 00:23:26,470
保证这对你来说没问题，所以我想

543
00:23:26,470 --> 00:23:29,560
谈谈 这个特定的

544
00:23:29,560 --> 00:23:31,720
恢复特定的特性是如何

545
00:23:31,720 --> 00:23:35,020
被一个基本的时间戳排序所违反的所以

546
00:23:35,020 --> 00:23:35,410
想象

547
00:23:35,410 --> 00:23:37,660
我们有 相同的设置在这里我们有两个

548
00:23:37,660 --> 00:23:39,790
事务 t1 和 t2 t1 有时间快照

549
00:23:39,790 --> 00:23:41,290
1 T 2 的时间 2

550
00:23:41,290 --> 00:23:45,520
所以 t1 写入 t2

551
00:23:45,520 --> 00:23:48,460
读取 a 然后写入 B 所以在这个

552
00:23:48,460 --> 00:23:49,180
串行顺序中

553
00:23:49,180 --> 00:23:52,480
t1 首先发生，t2 第二次发生，所以

554
00:23:52,480 --> 00:23:55,930
这个读取现在可以正确读取这个

555
00:23:55,930 --> 00:23:56,590
，没关系，

556
00:23:56,590 --> 00:23:58,900
它做了 B 的一些权利，这在提交中是可以的，

557
00:23:58,900 --> 00:24:01,900
所以 t2 在

558
00:24:01,900 --> 00:24:04,930
这一点上已经提交，但让我们稍后

559
00:24:04,930 --> 00:24:07,450
在系统中说这个事务已经

560
00:24:07,450 --> 00:24:10,180
中止了问题是 我们现在已经

561
00:24:10,180 --> 00:24:11,710
通知客户我们已经

562
00:24:11,710 --> 00:24:13,300
向外界通知了该

563
00:24:13,300 --> 00:24:15,670
事务已提交，但它

564
00:24:15,670 --> 00:24:18,060
从一个正确中止的事务中读取了一个值，

565
00:24:18,060 --> 00:24:20,590
因此这实际上是无效的，而不是

566
00:24:20,590 --> 00:24:21,970
它不是一个不可恢复的

567
00:24:21,970 --> 00:24:23,290
时间表，因为当系统出现时

568
00:24:23,290 --> 00:24:26,020
回来我们必须认识到这是

569
00:24:26,020 --> 00:24:27,490
中止的，我们不应该应用

570
00:24:27,490 --> 00:24:33,160
这些权利，所以这不是一个

571
00:24:33,160 --> 00:24:34,930
可恢复的时间表，但它是

572
00:24:34,930 --> 00:24:36,220
基本时间戳顺序和

573
00:24:36,220 --> 00:24:42,940
并发协议允许的，好吧，

574
00:24:42,940 --> 00:24:44,740
所以 t1 在 t2 之后中止 提交，

575
00:24:44,740 --> 00:24:46,930
这违反了可恢复的

576
00:24:46,930 --> 00:24:54,880
时间表要求，好吧，所以我认为

577
00:24:54,880 --> 00:24:55,990
很多人都对此有所了解，

578
00:24:55,990 --> 00:25:00,040
但这是这些基本的

579
00:25:00,040 --> 00:25:01,630
时间戳排序协议有

580
00:25:01,630 --> 00:25:03,940
很多开销，因此每次您

581
00:25:03,940 --> 00:25:06,520
进行写入或读取时 您现在需要将

582
00:25:06,520 --> 00:25:09,280
它复制到您的本地工作区，因此如果

583
00:25:09,280 --> 00:25:10,480
您要更新或读取和写入

584
00:25:10,480 --> 00:25:11,980
数十亿个两个极点，您必须

585
00:25:11,980 --> 00:25:13,870


586
00:25:13,870 --> 00:25:15,670
在本地内存空间中为每个事务制作数十亿个副本

587
00:25:15,670 --> 00:25:17,260
，这显然是另一个

588
00:25:17,260 --> 00:25:18,840
开销

589
00:25:18,840 --> 00:25:20,830


590
00:25:20,830 --> 00:25:23,350
一位学生再次提出的事情是，您可能

591
00:25:23,350 --> 00:25:25,420
会因长时间运行的事务的长时间负载而饥饿，

592
00:25:25,420 --> 00:25:28,150
而短期

593
00:25:28,150 --> 00:25:29,680
运行的事务会快速更新

594
00:25:29,680 --> 00:25:32,440
一两个元组，然后需要

595
00:25:32,440 --> 00:25:33,850
长时间运行的长时间运行的

596
00:25:33,850 --> 00:25:37,620
事务中止，我们 开始

597
00:25:40,610 --> 00:25:45,990
吧，如果你想得对，我们能做什么

598
00:25:45,990 --> 00:25:49,470
所以两阶段锁定和我刚刚谈到的

599
00:25:49,470 --> 00:25:51,000
这个基本的时间戳记录协议

600
00:25:51,000 --> 00:25:53,030
他们也

601
00:25:53,030 --> 00:25:55,650
有点 悲观的权利，因此在

602
00:25:55,650 --> 00:25:58,020
两阶段锁定中，一旦您

603
00:25:58,020 --> 00:26:00,120
从数据库中读取和写入值，您

604
00:26:00,120 --> 00:26:02,039
就必须获取一些块以保护

605
00:26:02,039 --> 00:26:03,809
自己免受

606
00:26:03,809 --> 00:26:06,630
系统中具有基本时间戳顺序的其他事务的影响，并且

607
00:26:06,630 --> 00:26:07,470
您正在做同样的

608
00:26:07,470 --> 00:26:09,600
事情 每次你想读取和

609
00:26:09,600 --> 00:26:11,340
写入一个元组时，你必须

610
00:26:11,340 --> 00:26:15,059
确保时间戳正好对齐，以便

611
00:26:15,059 --> 00:26:16,289
你可以执行你想要正确执行的操作，

612
00:26:16,289 --> 00:26:18,570
所以他们都

613
00:26:18,570 --> 00:26:19,919
假设系统中有很多

614
00:26:19,919 --> 00:26:21,659
争用和 尝试

615
00:26:21,659 --> 00:26:24,900
防止这种

616
00:26:24,900 --> 00:26:27,419
情况发生，以防止出现错误，但是如果您

617
00:26:27,419 --> 00:26:28,770
做出不同的假设，如果您

618
00:26:28,770 --> 00:26:30,630
假设系统中不会有

619
00:26:30,630 --> 00:26:32,669
很多争用，

620
00:26:32,669 --> 00:26:34,200
您可以应用哪些不同类型的优化，

621
00:26:34,200 --> 00:26:36,809
假设那里的

622
00:26:36,809 --> 00:26:38,280
交易本质上是 一个非常

623
00:26:38,280 --> 00:26:40,650
短暂的，基本上没有冲突

624
00:26:40,650 --> 00:26:43,230
的权利，你能不能

625
00:26:43,230 --> 00:26:44,700
比我们

626
00:26:44,700 --> 00:26:46,950
迄今为止讨论的这些东西更乐观，我们将讨论

627
00:26:46,950 --> 00:26:49,140
一个例子 一个并发协议

628
00:26:49,140 --> 00:26:50,700
，它做出了这个假设并应用了

629
00:26:50,700 --> 00:26:52,520
许多不同类型的

630
00:26:52,520 --> 00:26:56,130
优化，它被称为

631
00:26:56,130 --> 00:26:58,409
乐观并发控制，

632
00:26:58,409 --> 00:26:59,880
因此它对事务在系统中的运行方式采取了非常乐观的观点，

633
00:26:59,880 --> 00:27:01,890


634
00:27:01,890 --> 00:27:05,150
因此 OCC 乐观并发控制

635
00:27:05,150 --> 00:27:08,760
是 HT Cong 在 CMU 写的

636
00:27:08,760 --> 00:27:11,429
这他不再是这里的教授 我

637
00:27:11,429 --> 00:27:13,559
想他在哈佛说过但是

638
00:27:13,559 --> 00:27:15,179
你知道的主要

639
00:27:15,179 --> 00:27:16,440
并发控制协议之一

640
00:27:16,440 --> 00:27:20,630
实际上是在 CMU 写的，这很酷，哎呀

641
00:27:20,630 --> 00:27:24,240
，这个想法和基础时间一样

642
00:27:24,240 --> 00:27:26,070
time time step boarding protocol

643
00:27:26,070 --> 00:27:28,260
你执行的每一个操作你所做的都是你

644
00:27:28,260 --> 00:27:31,350
首先制作一个你首先将该数据的本地副本复制

645
00:27:31,350 --> 00:27:34,159
到本地线程本地

646
00:27:34,159 --> 00:27:37,470
私有工作区中，任何时候你

647
00:27:37,470 --> 00:27:39,150
想读取一个副本任何时候你想读取

648
00:27:39,150 --> 00:27:40,830
一个元素 从数据库中，您首先

649
00:27:40,830 --> 00:27:42,330
从中复制一份，

650
00:27:42,330 --> 00:27:43,890
然后如果您想对其进行更新就

651
00:27:43,890 --> 00:27:45,690
可以了，您首先将其复制到您的

652
00:27:45,690 --> 00:27:46,919
本地工作中 空间，然后您将

653
00:27:46,919 --> 00:27:49,470
更新应用到您的本地副本 好吧，您

654
00:27:49,470 --> 00:27:51,659
不再执行就地更新，

655
00:27:51,659 --> 00:27:52,539


656
00:27:52,539 --> 00:27:56,279
然后一旦所有这些工作完成

657
00:27:56,279 --> 00:27:58,719
并且您准备好提交，您必须

658
00:27:58,719 --> 00:28:00,309
基本上确保您必须

659
00:28:00,309 --> 00:28:02,440
验证您所做的所有更改是否

660
00:28:02,440 --> 00:28:04,089
与系统中与您同时运行的其余事务在事务上一致

661
00:28:04,089 --> 00:28:05,199


662
00:28:05,199 --> 00:28:06,999


663
00:28:06,999 --> 00:28:08,919


664
00:28:08,919 --> 00:28:10,269


665
00:28:10,269 --> 00:28:14,099


666
00:28:14,099 --> 00:28:16,899


667
00:28:16,899 --> 00:28:19,119
数据库有 Vallot 保险后的步骤是的，嘿嘿，

668
00:28:19,119 --> 00:28:21,699
听着你的交易是好的，

669
00:28:21,699 --> 00:28:23,440
我们现在必须将

670
00:28:23,440 --> 00:28:25,269
你私人工作区中的所有更改安装到

671
00:28:25,269 --> 00:28:27,009
全局数据库系统中，我们必须以原子方式执行

672
00:28:27,009 --> 00:28:29,259
此操作，然后我再谈谈

673
00:28:29,259 --> 00:28:32,909
关于这是如何在系统中完成的，

674
00:28:32,909 --> 00:28:36,669
所以 OCC 的工作方式是

675
00:28:36,669 --> 00:28:38,469
它分为三个阶段，

676
00:28:38,469 --> 00:28:40,019
第一阶段称为读取阶段，

677
00:28:40,019 --> 00:28:42,039
然后是验证阶段，这

678
00:28:42,039 --> 00:28:43,299
是必不可少的 我会验证这个

679
00:28:43,299 --> 00:28:44,829
交易实际上仍然有效并且

680
00:28:44,829 --> 00:28:46,419
不与其他任何事情发生冲突，

681
00:28:46,419 --> 00:28:48,339
一旦验证阶段完成，那么你

682
00:28:48,339 --> 00:28:49,809
实际上必须将你的更改

683
00:28:49,809 --> 00:28:51,879
从私有工作区安装到全局

684
00:28:51,879 --> 00:28:54,369
数据库中，所以读取阶段

685
00:28:54,369 --> 00:28:55,690
有点 用词不当，你

686
00:28:55,690 --> 00:28:57,399
实际上被允许在其中进行阅读和

687
00:28:57,399 --> 00:28:59,109
写作，所以我不想

688
00:28:59,109 --> 00:29:01,029
确保这一点被理解我实际上

689
00:29:01,029 --> 00:29:03,219
甚至不喜欢短语阅读阶段我

690
00:29:03,219 --> 00:29:04,929
实际上更喜欢你所在的工作阶段

691
00:29:04,929 --> 00:29:06,279
为事务做实际的工作

692
00:29:06,279 --> 00:29:08,339
没问题 所以在工作阶段

693
00:29:08,339 --> 00:29:10,569
你正在做你的读和写

694
00:29:10,569 --> 00:29:12,039
你正在更新你

695
00:29:12,039 --> 00:29:15,339
在验证阶段在私有工作区中读取值

696
00:29:15,339 --> 00:29:16,929
当

697
00:29:16,929 --> 00:29:19,059
交互准备好提交时

698
00:29:19,059 --> 00:29:20,859
数据库做了一堆你知道的

699
00:29:20,859 --> 00:29:22,089
健全性检查，以确保

700
00:29:22,089 --> 00:29:24,129
这是一个有效的事务，

701
00:29:24,129 --> 00:29:25,899
然后在写入阶段你原子地

702
00:29:25,899 --> 00:29:27,819
将所有更改安装

703
00:29:27,819 --> 00:29:31,059
到全局数据库中 oka 是的，所以让我们

704
00:29:31,059 --> 00:29:32,739
快速浏览一个示例，说明

705
00:29:32,739 --> 00:29:35,619
这是如何正常工作的，所以第一

706
00:29:35,619 --> 00:29:36,789
件事是我们拥有与以前相同的数据库

707
00:29:36,789 --> 00:29:38,469
，但我们已经删除

708
00:29:38,469 --> 00:29:40,029
了读取时间戳的正确时间，现在我们

709
00:29:40,029 --> 00:29:42,339
只有写入时间 盖章第二

710
00:29:42,339 --> 00:29:43,899
件事是我们现在已经

711
00:29:43,899 --> 00:29:46,869
为所有阶段划定了界限

712
00:29:46,869 --> 00:29:48,279
我们真的只是为了

713
00:29:48,279 --> 00:29:50,349
说明他们做了这个交易

714
00:29:50,349 --> 00:29:51,969
不会特别说嘿我

715
00:29:51,969 --> 00:29:52,959
想开始我的阅读阶段我要去 开始

716
00:29:52,959 --> 00:29:54,309
我的有效阶段，然后是提交

717
00:29:54,309 --> 00:29:56,289
阶段，这是将要完成的，它将

718
00:29:56,289 --> 00:29:58,959
由数据库系统本身为您处理，

719
00:29:58,959 --> 00:30:01,509
就像两

720
00:30:01,509 --> 00:30:02,859
阶段锁定协议是如何

721
00:30:02,859 --> 00:30:03,999
由数据库为您实现的，而不是由

722
00:30:03,999 --> 00:30:05,499
事务正确的事务 只是

723
00:30:05,499 --> 00:30:06,160
做一堆

724
00:30:06,160 --> 00:30:11,680
读取没问题，所以我想我

725
00:30:11,680 --> 00:30:13,840
想指出的另一件事是，与基本

726
00:30:13,840 --> 00:30:15,250
时间戳或在事务期间不同

727
00:30:15,250 --> 00:30:17,200
，时间戳不一定

728
00:30:17,200 --> 00:30:19,390
在事务进入系统时分配，

729
00:30:19,390 --> 00:30:21,190
好吧，它们是 实际上

730
00:30:21,190 --> 00:30:22,570
推迟到稍后的时间点，

731
00:30:22,570 --> 00:30:28,870
我们将讨论如何完成，所以

732
00:30:28,870 --> 00:30:31,750
我们准备开始我们开始

733
00:30:31,750 --> 00:30:34,270
事务 t1 它现在想要读取

734
00:30:34,270 --> 00:30:37,240
a 所以它构建了一个私人工作区

735
00:30:37,240 --> 00:30:39,400
，本质上有点像

736
00:30:39,400 --> 00:30:42,580
读取时的数据库副本，它将

737
00:30:42,580 --> 00:30:45,010
读取或复制 a 到其

738
00:30:45,010 --> 00:30:47,200
私有工作区，以及

739
00:30:47,200 --> 00:30:49,120
它从数据库系统读取的任何内容的写入时间戳，

740
00:30:49,120 --> 00:30:52,900
现在 t2 开始

741
00:30:52,900 --> 00:30:55,570
，当它开始读取阶段时，它

742
00:30:55,570 --> 00:30:57,220
开始其读取阶段 它必须

743
00:30:57,220 --> 00:30:59,140
为事务 t2 构建这个私有工作区，

744
00:30:59,140 --> 00:31:03,730
它将 a 与写入时间戳一起读入它的私有

745
00:31:03,730 --> 00:31:05,380
工作空间

746
00:31:05,380 --> 00:31:08,200
，然后我们就可以开始了，所以

747
00:31:08,200 --> 00:31:10,420
现在我们进入到验证阶段的集会，

748
00:31:10,420 --> 00:31:11,890
所以这 本质上是

749
00:31:11,890 --> 00:31:13,900
t2 对数据库说嘿听我

750
00:31:13,900 --> 00:31:16,630
准备提交它所做的是

751
00:31:16,630 --> 00:31:17,980
数据库现在将进入验证

752
00:31:17,980 --> 00:31:21,880
阶段 42 在这一点上，该

753
00:31:21,880 --> 00:31:23,470
事务将时间戳分配

754
00:31:23,470 --> 00:31:26,320
给事务 F A  r

755
00:31:26,320 --> 00:31:27,940
这个交易还没有

756
00:31:27,940 --> 00:31:29,260
时间戳，你可以假设它的

757
00:31:29,260 --> 00:31:32,380
时间戳在这里是无穷大的，当

758
00:31:32,380 --> 00:31:34,720
t2 进入验证阶段时，它会得到

759
00:31:34,720 --> 00:31:39,640
一个正确的时间戳，所以

760
00:31:39,640 --> 00:31:44,290
它现在做什么它不需要做任何事情

761
00:31:44,290 --> 00:31:45,900
某种验证，因为没有

762
00:31:45,900 --> 00:31:47,710
什么可做的 B 验证它是一个

763
00:31:47,710 --> 00:31:50,110
只读事务，因此它开始

764
00:31:50,110 --> 00:31:52,440
写入它落入写入阶段

765
00:31:52,440 --> 00:31:55,120
没有什么可写入然后它

766
00:31:55,120 --> 00:31:57,930
提交，一切都完成了

767
00:31:57,930 --> 00:32:02,290
，这是一个非常简单的例子和

768
00:32:02,290 --> 00:32:04,870
我们做了一个上下文切换回 t1 t1

769
00:32:04,870 --> 00:32:07,540
现在想要做一个写，所以它

770
00:32:07,540 --> 00:32:10,630
修改了它的本地副本，并

771
00:32:10,630 --> 00:32:14,620
分配了一个无穷大的时间戳 好的

772
00:32:14,620 --> 00:32:15,760
为什么时间戳必须是

773
00:32:15,760 --> 00:32:18,150
无穷大

774
00:32:20,920 --> 00:32:22,940
这个事务有时间戳

775
00:32:22,940 --> 00:32:27,380
吗 没有正确的时间戳，

776
00:32:27,380 --> 00:32:29,600
因为它有一个间隔版本，

777
00:32:29,600 --> 00:32:30,650
当你输入一个位置时，你只会得到一个时间戳，

778
00:32:30,650 --> 00:32:32,420
所以如果它没有

779
00:32:32,420 --> 00:32:33,740
时间戳，那么它不知道它

780
00:32:33,740 --> 00:32:35,300
的时间采样类型是什么，所以它

781
00:32:35,300 --> 00:32:37,940
假设 一世 nfinity 正确，它将

782
00:32:37,940 --> 00:32:39,770
在它开始验证阶段时填充它

783
00:32:39,770 --> 00:32:45,080
，因此它现在开始

784
00:32:45,080 --> 00:32:46,700
验证阶段，它也获得

785
00:32:46,700 --> 00:32:50,750
分配给它的时间戳，然后当系统中

786
00:32:50,750 --> 00:32:52,070
没有其他并发事务

787
00:32:52,070 --> 00:32:53,300
在运行时，验证阶段

788
00:32:53,300 --> 00:32:55,820
完成并 现在如何将

789
00:32:55,820 --> 00:32:58,120
其本地副本将其所有本地更改

790
00:32:58,120 --> 00:33:01,790
写入全局数据库空间，当

791
00:33:01,790 --> 00:33:04,220
它进行复制时，它必须将

792
00:33:04,220 --> 00:33:06,260
这个元组的写入时间戳更新到 Trent

793
00:33:06,260 --> 00:33:07,430
到它开始验证时分配的时间戳

794
00:33:07,430 --> 00:33:10,760
所以 - 所以

795
00:33:10,760 --> 00:33:15,470
在这里写了 2 的写入时间戳 好的，这

796
00:33:15,470 --> 00:33:16,820
是一个非常简单的例子，它就像一个

797
00:33:16,820 --> 00:33:18,830
快乐的路径例子，说明事务如何

798
00:33:18,830 --> 00:33:25,790
正常工作，所以工作面在

799
00:33:25,790 --> 00:33:27,020
任何时候你想读取

800
00:33:27,020 --> 00:33:29,180
和写入一个值时都很简单 将其复制

801
00:33:29,180 --> 00:33:30,530
到本地工作区，然后

802
00:33:30,530 --> 00:33:33,140


803
00:33:33,140 --> 00:33:34,370
在完成工作阶段后单独修改本地工作空间 现在

804
00:33:34,370 --> 00:33:37,220
开始验证阶段

805
00:33:37,220 --> 00:33:38,540
验证阶段是数据库

806
00:33:38,540 --> 00:33:40,430
确保 sc 它可以

807
00:33:40,430 --> 00:33:42,110
生成的 hedule 是可序列化的，它的冲突是可

808
00:33:42,110 --> 00:33:44,420
序列化的，它这样做的方式

809
00:33:44,420 --> 00:33:46,150
是，对于每个事务，

810
00:33:46,150 --> 00:33:48,470
它必须确保

811
00:33:48,470 --> 00:33:50,660
读写设置正确，因此它修改的一组事物

812
00:33:50,660 --> 00:33:52,850
不会发生冲突

813
00:33:52,850 --> 00:33:54,050


814
00:33:54,050 --> 00:33:55,430
与系统中的所有其他并发事务发生读写冲突或写入冲突，

815
00:33:55,430 --> 00:33:57,280


816
00:33:57,280 --> 00:33:59,630
并且有一种机制可以

817
00:33:59,630 --> 00:34:00,740
做到这

818
00:34:00,740 --> 00:34:01,850


819
00:34:01,850 --> 00:34:05,270


820
00:34:05,270 --> 00:34:08,540
一点 当这些幻灯片有点乱时，实际上有几种不同的

821
00:34:08,540 --> 00:34:10,100
机制 所以数据库可以

822
00:34:10,100 --> 00:34:11,989
确保这些事务不或不

823
00:34:11,989 --> 00:34:14,659
喜欢这些集合的方式是你知道正确可

824
00:34:14,659 --> 00:34:17,030
序列化的方法是，

825
00:34:17,030 --> 00:34:19,130


826
00:34:19,130 --> 00:34:21,050
如果你有

827
00:34:21,050 --> 00:34:22,639
所有事务的全局视图，它需要有系统中运行的所有活动事务的全局视图

828
00:34:22,639 --> 00:34:24,020
在系统中运行，您现在可以全局查看系统中

829
00:34:24,020 --> 00:34:26,449
每个事务所做的所有修改

830
00:34:26,449 --> 00:34:28,699


831
00:34:28,699 --> 00:34:30,770
，然后您可以使用这些读写

832
00:34:30,770 --> 00:34:32,330
集

833
00:34:32,330 --> 00:34:34,760
作为一种机制 确定

834
00:34:34,760 --> 00:34:40,900
系统中交易的顺序 所以我

835
00:34:40,900 --> 00:34:44,719
想我认为我们

836
00:34:44,719 --> 00:34:46,070
想要尝试在这里

837
00:34:46,070 --> 00:34:47,960
简化的一件事是简化整个协议

838
00:34:47,960 --> 00:34:49,610
据说这种验证和写入

839
00:34:49,610 --> 00:34:51,980
发生 看到令人毛骨悚然的发布 所以整个

840
00:34:51,980 --> 00:34:54,230
系统你 可以考虑一下，因为

841
00:34:54,230 --> 00:34:56,960
在验证

842
00:34:56,960 --> 00:34:58,430
阶段quote-unquote Kuala验证

843
00:34:58,430 --> 00:34:59,600
阶段有一个巨大的闩锁，以确保一次只有一个

844
00:34:59,600 --> 00:35:01,280
交易执行

845
00:35:01,280 --> 00:35:02,750
验证，这将简化

846
00:35:02,750 --> 00:35:04,310
我们将要使用的一些协议，从而

847
00:35:04,310 --> 00:35:05,300
简化了一些 我们正在

848
00:35:05,300 --> 00:35:06,920
讨论的细节稍后会在协议中结束

849
00:35:06,920 --> 00:35:11,750
，所以是的，

850
00:35:11,750 --> 00:35:14,300
当我之前提到的读取阶段时，每当

851
00:35:14,300 --> 00:35:15,140
您尝试读取和写入

852
00:35:15,140 --> 00:35:18,890
值时，您都会制作本地副本并且您只

853
00:35:18,890 --> 00:35:22,580
更新该本地副本 确保

854
00:35:22,580 --> 00:35:24,620
可重复读取，然后在

855
00:35:24,620 --> 00:35:27,740
验证阶段是

856
00:35:27,740 --> 00:35:29,330
当您获得时间戳时，然后您

857
00:35:29,330 --> 00:35:30,860
使用此时间戳来查看

858
00:35:30,860 --> 00:35:32,690
系统要执行的所有其他并发事务

859
00:35:32,690 --> 00:35:34,280
确保你不你不

860
00:35:34,280 --> 00:35:35,900
拦截你的读写集到

861
00:35:35,900 --> 00:35:37,490
最后相交以确保你

862
00:35:37,490 --> 00:35:41,780
有一个正确的序列顺序所以你

863
00:35:41,780 --> 00:35:43,400
看看你你看看你的时间戳，

864
00:35:43,400 --> 00:35:45,740
它是 40 我你找到了所有 其他时候

865
00:35:45,740 --> 00:35:47,510
系统中

866
00:35:47,510 --> 00:35:49,430
比你年轻的交易比你新

867
00:35:49,430 --> 00:35:51,050
，你必须确保一组

868
00:35:51,050 --> 00:35:53,810
条件成立我的意思是

869
00:35:53,810 --> 00:35:55,880
我们使用新交易的事实

870
00:35:55,880 --> 00:35:58,250
不一定需要你也可以

871
00:35:58,250 --> 00:35:59,480
看看 所有的交易都是正确的，我们没有

872
00:35:59,480 --> 00:36:00,680
理由特别关注

873
00:36:00,680 --> 00:36:03,110
年轻的交易，但它简化了

874
00:36:03,110 --> 00:36:04,910
它使事情变得更简单，但

875
00:36:04,910 --> 00:36:06,560
我将谈谈我们可以使用的另一种方法，

876
00:36:06,560 --> 00:36:07,850
它与这种方法略有不同，

877
00:36:07,850 --> 00:36:11,060
所以当你 准备

878
00:36:11,060 --> 00:36:12,500
好验证您基本上调用

879
00:36:12,500 --> 00:36:14,690
提交，然后数据库执行

880
00:36:14,690 --> 00:36:16,460
验证阶段，以便它找到，因为它

881
00:36:16,460 --> 00:36:17,300
具有系统中所有事务的全局视图，

882
00:36:17,300 --> 00:36:18,680
我们可以找到

883
00:36:18,680 --> 00:36:20,270
所有较新的事务和所有

884
00:36:20,270 --> 00:36:21,950
事务 并确保

885
00:36:21,950 --> 00:36:24,320
一切都适合在一起

886
00:36:24,320 --> 00:36:26,570
，您可以执行两种类型的验证

887
00:36:26,570 --> 00:36:28,790
，您可以执行

888
00:36:28,790 --> 00:36:30,470
验证或胸罩或向后

889
00:36:30,470 --> 00:36:32,210
验证，那么

890
00:36:32,210 --> 00:36:33,290
这两种类型的验证技术之间有什么区别，

891
00:36:33,290 --> 00:36:37,790
所以在 in in in in in in in in in in in in

892
00:36:37,790 --> 00:36:39,140
in 向后验证 你

893
00:36:39,140 --> 00:36:40,640
看到的是什么时候事务

894
00:36:40,640 --> 00:36:42,080
准备好提交 让我们假设

895
00:36:42,080 --> 00:36:43,700
事务 t2 准备好提交你

896
00:36:43,700 --> 00:36:45,400
看看系统中的所有旧事务

897
00:36:45,400 --> 00:36:48,100
，所以 t2 准备好

898
00:36:48,100 --> 00:36:51,340
提交它的提交点是 在这里，

899
00:36:51,340 --> 00:36:52,420
您正在进行向后验证，您

900
00:36:52,420 --> 00:36:53,950
必须找到所有交易，以便

901
00:36:53,950 --> 00:36:55,540
传输

902
00:36:55,540 --> 00:36:57,360
时间戳小于此时间戳的不同交易并

903
00:36:57,360 --> 00:36:59,920
执行验证，因此我们将其称为

904
00:36:59,920 --> 00:37:02,020
事物的范围，我们

905
00:37:02,020 --> 00:37:03,520
必须查看验证范围 所以

906
00:37:03,520 --> 00:37:05,260
这是 t2 的验证范围，如果

907
00:37:05,260 --> 00:37:07,350
我们正在做向后验证，因为

908
00:37:07,350 --> 00:37:10,330
t1 和 t2 同时运行并且

909
00:37:10,330 --> 00:37:14,680
t1 在 t2 之前提交，所以 t1

910
00:37:14,680 --> 00:37:18,640
比 t2 早 我是对的，因为

911
00:37:18,640 --> 00:37:22,180
可能是 t1 更新

912
00:37:22,180 --> 00:37:25,000
了应该由 t2 读取的内容，

913
00:37:25,000 --> 00:37:29,500
但我们没有更新，因为 T 一旦

914
00:37:29,500 --> 00:37:33,580
对私有副本进行了更改，好吧，所以我们

915
00:37:33,580 --> 00:37:34,840
可能会从中读取

916
00:37:34,840 --> 00:37:36,550
新内容 我们应该从 t1 读取的数据库系统，

917
00:37:36,550 --> 00:37:37,960


918
00:37:37,960 --> 00:37:39,610
但我们实际上是从主数据库读取的，

919
00:37:39,610 --> 00:37:41,950
因为 t1 正在

920
00:37:41,950 --> 00:37:44,530
对其自己的空间进行私有更改，因此我们

921
00:37:44,530 --> 00:37:46,030
必须确保

922
00:37:46,030 --> 00:37:48,040
不会发生这种情况，如果发生，我们 必须

923
00:37:48,040 --> 00:37:48,790
实际中止

924
00:37:48,790 --> 00:37:52,480
t1 所以这是向后验证我们正在

925
00:37:52,480 --> 00:37:55,170
向后看是

926
00:38:01,170 --> 00:38:03,220
正确的，因为此时已经

927
00:38:03,220 --> 00:38:05,110
提交了我们无法

928
00:38:05,110 --> 00:38:09,130
做任何事情 - 好吧，类似地

929
00:38:09,130 --> 00:38:10,900
，您也可以向前看，而不是向后看，

930
00:38:10,900 --> 00:38:13,270
所以我们再次 尝试

931
00:38:13,270 --> 00:38:16,540
对 t2 进行验证，我们找到

932
00:38:16,540 --> 00:38:18,370
所有

933
00:38:18,370 --> 00:38:20,920
尚未提交的并发运行事务，我们

934
00:38:20,920 --> 00:38:22,900
对这些事务进行验证，因此在此

935
00:38:22,900 --> 00:38:26,650
特定场景中 t3 当前正在

936
00:38:26,650 --> 00:38:28,540
运行，我们必须确保

937
00:38:28,540 --> 00:38:31,120
这在事务上是安全的，因为

938
00:38:31,120 --> 00:38:32,800
可能是我进行了更新，

939
00:38:32,800 --> 00:38:35,320
因此 t2 对其本地私有空间进行了更新，

940
00:38:35,320 --> 00:38:37,150
但是因为它

941
00:38:37,150 --> 00:38:40,000
以串行顺序发生在 t3 之前，这个

942
00:38:40,000 --> 00:38:41,950
已经从数据库中读取为陈旧值，

943
00:38:41,950 --> 00:38:43,690
它应该读取

944
00:38:43,690 --> 00:38:45,520
我修改过的东西也许我

945
00:38:45,520 --> 00:38:48,460
在这里修改了它，但它没有在这里读取它，但

946
00:38:48,460 --> 00:38:51,160
它实际上读取了一个陈旧的值，如果

947
00:38:51,160 --> 00:38:54,999
发生这种情况，我必须放弃自己，

948
00:38:54,999 --> 00:38:57,349
所以这些只是

949
00:38:57,349 --> 00:38:59,390
我们执行的两种机制的两种技术

950
00:38:59,390 --> 00:39:01,249
验证这里真正重要的

951
00:39:01,249 --> 00:39:03,049
是，他们都

952
00:39:03,049 --> 00:39:04,460
认为所有交易

953
00:39:04,460 --> 00:39:06,529
在同一方向执行此验证的整个日期，您

954
00:39:06,529 --> 00:39:07,999
不能让 t1 执行前向

955
00:39:07,999 --> 00:39:10,099
验证和 t2 执行后向

956
00:39:10,099 --> 00:39:11,089
验证，因为这会

957
00:39:11,089 --> 00:39:36,140
弄乱整个系统是的，所以如果

958
00:39:36,140 --> 00:39:37,249
验证完成然后你

959
00:39:37,249 --> 00:39:38,539
基本上已经承诺你准备好

960
00:39:38,539 --> 00:39:48,349
写出你的更改，即使

961
00:39:48,349 --> 00:39:56,660
系统出现故障也不行，因为

962
00:39:56,660 --> 00:39:58,940
验证验证成功

963
00:39:58,940 --> 00:40:00,079
l 数据库说这是一个

964
00:40:00,079 --> 00:40:01,549
有效的交易它不

965
00:40:01,549 --> 00:40:03,349
与其他任何东西冲突所以它

966
00:40:03,349 --> 00:40:04,910
现在应该被安装到

967
00:40:04,910 --> 00:40:14,299
互联网到系统中所以

968
00:40:14,299 --> 00:40:15,410
没问题所以在本讲座的其余部分

969
00:40:15,410 --> 00:40:16,730
让我们 假设我们总是

970
00:40:16,730 --> 00:40:18,440
在进行前向验证，所以无论何时你

971
00:40:18,440 --> 00:40:19,970
想验证一个交易，你都会发现

972
00:40:19,970 --> 00:40:21,950
所有比你更新的交易，然后你

973
00:40:21,950 --> 00:40:26,509
执行 Vettes 验证步骤，

974
00:40:26,509 --> 00:40:27,499
所以我们必须涵盖几个不同的

975
00:40:27,499 --> 00:40:29,809
场景，

976
00:40:29,809 --> 00:40:31,130
第一个场景是 如果您发现

977
00:40:31,130 --> 00:40:34,999
交易 TJ，其中

978
00:40:34,999 --> 00:40:36,950
您阅读的所有阶段都是肯定的，或者您的工作

979
00:40:36,950 --> 00:40:39,019
是您的正确步骤中的验证

980
00:40:39,019 --> 00:40:42,170
发生在 TJ 所做的任何事情之前，

981
00:40:42,170 --> 00:40:43,789
这有点像

982
00:40:43,789 --> 00:40:46,220
这里的简单快乐路径案例，所以这

983
00:40:46,220 --> 00:40:49,579
是一个例子，你有 t1 和 t2 t1

984
00:40:49,579 --> 00:40:51,950
在 t2 之前完成它的所有步骤，

985
00:40:51,950 --> 00:40:54,440
然后一切正常，所以这是一个非常

986
00:40:54,440 --> 00:40:55,579
简单的例子，你基本上可以把它

987
00:40:55,579 --> 00:40:57,109
折叠成一个，现在你有

988
00:40:57,109 --> 00:40:59,779
一个 真正的执行所以你只需要在

989
00:40:59,779 --> 00:41:01,309
这里做任何有趣

990
00:41:01,309 --> 00:41:05,200
的事情 这自然是给你

991
00:41:05,200 --> 00:41:07,070
的第二

992
00:41:07,070 --> 00:41:09,040
个我们必须处理的第二种情况

993
00:41:09,040 --> 00:41:13,369
是如果 t1 在 TJ

994
00:41:13,369 --> 00:41:16,790
之前完成 抱歉 TI 在 TJ 开始其

995
00:41:16,790 --> 00:41:20,119
正确阶段之前完成 并且我们必须

996
00:41:20,119 --> 00:41:21,950
确保在这种情况下

997
00:41:21,950 --> 00:41:24,320
，我们在事务中写入正确集的内容

998
00:41:24,320 --> 00:41:26,690
不会

999
00:41:26,690 --> 00:41:28,099
与另一个事务的读取集交互，

1000
00:41:28,099 --> 00:41:29,240
因此另一个事务

1001
00:41:29,240 --> 00:41:30,440
没有读取我们将要读取的任何内容

1002
00:41:30,440 --> 00:41:33,080
奇怪的是，我们已经写好了

1003
00:41:33,080 --> 00:41:33,830
为什么这很重要

1004
00:41:33,830 --> 00:41:36,589
所以让我们通过一个例子来看看

1005
00:41:36,589 --> 00:41:37,970
这个场景中我们有两个事务

1006
00:41:37,970 --> 00:41:40,460
t1 正在读取和写入 t2 正在

1007
00:41:40,460 --> 00:41:44,930
读取 a 而什么都不做所以

1008
00:41:44,930 --> 00:41:46,910
这是数据库的状态所以 t1

1009
00:41:46,910 --> 00:41:49,040
已经读取 a 并写入它假设

1010
00:41:49,040 --> 00:41:51,320
正在写入相同的值 1 2 3 并且它的

1011
00:41:51,320 --> 00:41:55,099
时间戳是无穷大 T 2 被读取 a 所以

1012
00:41:55,099 --> 00:41:56,869
它的时间戳为 0 并且它

1013
00:41:56,869 --> 00:41:58,609
在其私有

1014
00:41:58,609 --> 00:42:00,290
工作区中有一个本地副本，然后 你赢了 t

1015
00:42:00,290 --> 00:42:04,609
在此处正确执行验证，因此 t1

1016
00:42:04,609 --> 00:42:07,220
必须中止，因为它是读取集，因此

1017
00:42:07,220 --> 00:42:09,410
它具有较低的时间戳，然后 t2，

1018
00:42:09,410 --> 00:42:11,810
因为它首先开始验证，因此

1019
00:42:11,810 --> 00:42:13,670
它的写入集与此处的读取集相交

1020
00:42:13,670 --> 00:42:15,980
，好吧，这样就

1021
00:42:15,980 --> 00:42:17,270
违反了 我们

1022
00:42:17,270 --> 00:42:20,480
之前

1023
00:42:20,480 --> 00:42:24,080


1024
00:42:24,080 --> 00:42:27,290


1025
00:42:27,290 --> 00:42:30,080
拥有的不变量

1026
00:42:30,080 --> 00:42:35,530


1027
00:42:35,530 --> 00:42:39,640
所以我们必须以串行顺序中止

1028
00:42:39,640 --> 00:42:41,680
此事务 调整它，现在

1029
00:42:41,680 --> 00:42:44,740
我们将有茶

1030
00:42:44,740 --> 00:42:48,790
在 t1 之前开始验证所以在串行顺序 t2

1031
00:42:48,790 --> 00:42:51,880
发生在 t1 之前

1032
00:42:51,880 --> 00:42:55,330
在这种情况下会发生什么在这种情况下会发生什么，所以 t1 读取

1033
00:42:55,330 --> 00:42:57,609
开始验证它没有

1034
00:42:57,609 --> 00:42:59,260
正确的设置所以它没有' 它没有

1035
00:42:59,260 --> 00:43:00,220
任何东西与这个事务相交，

1036
00:43:00,220 --> 00:43:04,150
所以它提交 t2 做

1037
00:43:04,150 --> 00:43:11,400
同样的事情，它的正确设置不

1038
00:43:11,400 --> 00:43:14,170
与读取的牙齿集

1039
00:43:14,170 --> 00:43:16,810
相交 它不与任何其他

1040
00:43:16,810 --> 00:43:18,670
并发事务相交，因为它是什么

1041
00:43:18,670 --> 00:43:21,580
这一切都已经过时了，所以另一

1042
00:43:21,580 --> 00:43:22,810
件事就像什么都没有发生一样，所以

1043
00:43:22,810 --> 00:43:24,369
当串行顺序 t2 在 t1 之前发生时，

1044
00:43:24,369 --> 00:43:26,320
它读取

1045
00:43:26,320 --> 00:43:28,060
在此

1046
00:43:28,060 --> 00:43:30,099
事务将要读取 a 的值之前最初

1047
00:43:30,099 --> 00:43:33,900
存在的 a 的值，然后进行本地复制 它

1048
00:43:33,900 --> 00:43:40,890
和一切都好

1049
00:43:40,890 --> 00:43:51,190
问题是的 所以在这种

1050
00:43:51,190 --> 00:43:53,920
情况下 因为 T 2 首先开始验证

1051
00:43:53,920 --> 00:43:56,589
它首先出现在

1052
00:43:56,589 --> 00:44:12,300
串行顺序 是的

1053
00:44:15,710 --> 00:44:21,540
所以 T 所以 T 1 必须中止 因为在

1054
00:44:21,540 --> 00:44:23,280
串行顺序中应该发生

1055
00:44:23,280 --> 00:44:26,520
的是 T 2 因为它首先开始验证

1056
00:44:26,520 --> 00:44:28,380
它是第一个认识到

1057
00:44:28,380 --> 00:44:33,810
有问题的所以它

1058
00:44:33,810 --> 00:44:35,070
一旦开始验证就会识别出问题

1059
00:44:35,070 --> 00:44:36,780
因为它被分配了一个

1060
00:44:36,780 --> 00:44:38,430
时间戳 它看到一个并发

1061
00:44:38,430 --> 00:44:40,080
事务是就绪的陈旧值 所以

1062
00:44:40,080 --> 00:44:47,580
它很好地中止 T 22 去验证 T 1

1063
00:44:47,580 --> 00:44:49,950
注释不再是一个有效的事务，所以

1064
00:44:49,950 --> 00:44:51,740
它不会看到任何并发事务

1065
00:44:51,740 --> 00:44:53,910
，没有什么可以交叉的，

1066
00:44:53,910 --> 00:44:55,620
它也是一个只读事务，所以有

1067
00:44:55,620 --> 00:45:18,020
n 与 T 2 相交的东西

1068
00:45:18,020 --> 00:45:20,280
不能不直到摊位它的

1069
00:45:20,280 --> 00:45:22,320
变化因为它是私人的私人

1070
00:45:22,320 --> 00:45:56,160
事物是的所以当这个 T 1

1071
00:45:56,160 --> 00:45:59,100
开始时它马上回来哦因为

1072
00:45:59,100 --> 00:46:01,710
验证人脸你没有得到时间戳

1073
00:46:01,710 --> 00:46:03,330
是的我不知道 不知道我不知道 1 或 2

1074
00:46:03,330 --> 00:46:05,430
什么的，但是这个 T 2

1075
00:46:05,430 --> 00:46:08,640
没有正确的时间戳，是的，我的意思是它是

1076
00:46:08,640 --> 00:46:10,590
无穷大，它没有任何时间戳，

1077
00:46:10,590 --> 00:46:13,850
因为它还没有开始验证但

1078
00:46:14,270 --> 00:46:19,590
不不不所以 不不不不所以

1079
00:46:19,590 --> 00:46:20,820
交易时间戳被分配给

1080
00:46:20,820 --> 00:46:23,100
交易它不会假设它

1081
00:46:23,100 --> 00:46:24,360
不会

1082
00:46:24,360 --> 00:46:30,780
从元组中花费任何时间是的所以这

1083
00:46:30,780 --> 00:46:56,580
只是一个本地副本好吧是的你是

1084
00:46:56,580 --> 00:47:00,750
说如果t2 执行对这个对象的权利，

1085
00:47:00,750 --> 00:47:04,800
它会得到一个它会得到一个它会

1086
00:47:04,800 --> 00:47:07,020
修改它的本地副本的咬时间戳

1087
00:47:07,020 --> 00:47:26,400
到无穷大所以如果它

1088
00:47:26,400 --> 00:47:28,050
做对它会得到一个本地时间它会得到

1089
00:47:28,050 --> 00:47:29,400
一个时间戳 验证，如果没有冲突，它会

1090
00:47:29,400 --> 00:47:31,980
更新正确的

1091
00:47:31,980 --> 00:47:58,380


1092
00:47:58,380 --> 00:48:00,030
时间戳 必须让这个权利

1093
00:48:00,030 --> 00:48:02,310
是原子的，所以你在这个阶段将所有的

1094
00:48:02,310 --> 00:48:03,960
更改写回数据库，

1095
00:48:03,960 --> 00:48:06,320
这

1096
00:48:11,150 --> 00:48:13,050
只是因为

1097
00:48:13,050 --> 00:48:15,990
我们在这里的时间表所以我们有设备你

1098
00:48:15,990 --> 00:48:17,070
可以把它想象成我们开始

1099
00:48:17,070 --> 00:48:18,750
我们完成的验证 敌人

1100
00:48:18,750 --> 00:48:20,910
在这里进行接触切换，现在我们

1101
00:48:20,910 --> 00:48:28,500
在正确的阶段开始验证，

1102
00:48:28,500 --> 00:48:31,980
所以这是第二个例子，在这个例子中

1103
00:48:31,980 --> 00:48:33,570
还有一个要

1104
00:48:33,570 --> 00:48:37,200
处理的事务，您必须

1105
00:48:37,200 --> 00:48:40,200
确保事务 TI

1106
00:48:40,200 --> 00:48:42,740
在事务 TJ 开始之前完成其读取阶段

1107
00:48:42,740 --> 00:48:44,790
它的读取阶段，因此我们必须

1108
00:48:44,790 --> 00:48:46,350
确保我的事务的正确集

1109
00:48:46,350 --> 00:48:48,660
不会与

1110
00:48:48,660 --> 00:48:50,550
所有这些属于此类别的事务的读取集和正确集相交，

1111
00:48:50,550 --> 00:48:52,410


1112
00:48:52,410 --> 00:48:54,060
或者读取阶段

1113
00:48:54,060 --> 00:48:58,020
重叠，这是另一个示例

1114
00:48:58,020 --> 00:49:03,330
我们如何完成这个，所以让我们

1115
00:49:03,330 --> 00:49:05,940
看看在这个场景中 t1 正在读取和

1116
00:49:05,940 --> 00:49:09,810
写入 oops t2 正在读取 B 并

1117
00:49:09,810 --> 00:49:12,990
读取 t1 法式面包并开始

1118
00:49:12,990 --> 00:49:15,690
验证阶段，因此它的时间戳

1119
00:49:15,690 --> 00:49:20,370
为 1 现在我可以提交它，因为我的

1120
00:49:20,370 --> 00:49:24,210
正确集

1121
00:49:24,210 --> 00:49:26,640
在这个时间点不与事务 t2 的读取集相交，

1122
00:49:26,640 --> 00:49:32,640
所以我可以将我的更改安装

1123
00:49:32,640 --> 00:49:35,520
回数据库我更新

1124
00:49:35,520 --> 00:49:38,160
4 5 6 或用值更新 a  4 5 6 然后我

1125
00:49:38,160 --> 00:49:39,990
将我的写入时间戳设置为 1，这

1126
00:49:39,990 --> 00:49:41,640
是我在验证阶段分配的时间戳

1127
00:49:41,640 --> 00:49:47,910


1128
00:49:47,910 --> 00:49:49,920


1129
00:49:49,920 --> 00:49:53,790


1130
00:49:53,790 --> 00:49:55,950
a 现在它可以返回

1131
00:49:55,950 --> 00:49:57,480
到主它转到主

1132
00:49:57,480 --> 00:49:59,820
数据库并执行

1133
00:49:59,820 --> 00:50:05,100
t1 生成的 a 的更新值的本地副本，然后

1134
00:50:05,100 --> 00:50:06,570
它可以验证和写入成功，

1135
00:50:06,570 --> 00:50:07,590
因为没有并发

1136
00:50:07,590 --> 00:50:12,290
事务好

1137
00:50:12,290 --> 00:50:25,520
是这样 如果你让我们回到

1138
00:50:25,520 --> 00:50:29,540
这个例子，那么当你想

1139
00:50:29,540 --> 00:50:32,420
执行正确的权利时，你将数据库对象的本地副本复制

1140
00:50:32,420 --> 00:50:34,790
到

1141
00:50:34,790 --> 00:50:36,260
本地私有工作区，然后

1142
00:50:36,260 --> 00:50:38,090
当你将发送的时间设置为无穷大时，

1143
00:50:38,090 --> 00:50:40,220
你将它设置为 无穷大，因为你不

1144
00:50:40,220 --> 00:50:41,360
知道你的时间是多少 p 将是

1145
00:50:41,360 --> 00:50:42,530
因为你还没有被分配

1146
00:50:42,530 --> 00:50:47,900
一个，它是 0 只是

1147
00:50:47,900 --> 00:50:49,460
为了说明目的，你

1148
00:50:49,460 --> 00:50:50,600
可以想象一下，就像在

1149
00:50:50,600 --> 00:50:51,950
尝试一些带有时间戳

1150
00:50:51,950 --> 00:50:54,050
箭头的事务时，将所有这些对象批量加载

1151
00:50:54,050 --> 00:50:55,850
到 数据库所以这就是

1152
00:50:55,850 --> 00:51:00,500
为什么当你读取它时正确的 x 乘以 r0

1153
00:51:00,500 --> 00:51:02,540
你读取它正确的任何

1154
00:51:02,540 --> 00:51:04,190
时间戳与对象关联的任何时间戳是的

1155
00:51:04,190 --> 00:51:13,250
所以

1156
00:51:13,250 --> 00:51:15,590
t2 读取 a 是否有效

1157
00:51:15,590 --> 00:51:17,270
验证是否正确一切都

1158
00:51:17,270 --> 00:51:18,290
很好 因为没有

1159
00:51:18,290 --> 00:51:24,350
并发交易是的，这些都是为了

1160
00:51:24,350 --> 00:51:35,480
验证是的，正确的，是的，你

1161
00:51:35,480 --> 00:51:36,560
仍然需要依赖相同

1162
00:51:36,560 --> 00:51:45,740


1163
00:51:45,740 --> 00:51:47,870


1164
00:51:47,870 --> 00:51:49,010
的时间戳 您实际上如何

1165
00:51:49,010 --> 00:51:50,690
安装正确的 Saitama Klee 以及如何

1166
00:51:50,690 --> 00:51:52,850
以并行方式进行验证，

1167
00:51:52,850 --> 00:51:54,260
因为在实际系统中您必须

1168
00:51:54,260 --> 00:51:56,120
进行并行并行验证，但我

1169
00:51:56,120 --> 00:51:58,610
认为希望 想法已经

1170
00:51:58,610 --> 00:52:01,100
得到了正确的理解 它并不太

1171
00:52:01,100 --> 00:52:02,660
复杂 有一些

1172
00:52:02,660 --> 00:52:03,800
这里和那里有一些技巧

1173
00:52:03,800 --> 00:52:06,940
但通常它非常直观

1174
00:52:06,940 --> 00:52:08,930
所以有一些观察

1175
00:52:08,930 --> 00:52:11,360
我们应该尝试让所有

1176
00:52:11,360 --> 00:52:13,130
这些时间支持乐观

1177
00:52:13,130 --> 00:52:15,890
并发协议

1178
00:52:15,890 --> 00:52:18,200
当冲突很少时工作良好，

1179
00:52:18,200 --> 00:52:20,750
因为您允许事务在

1180
00:52:20,750 --> 00:52:22,490
不获取锁的情况下继续进行，而无需

1181
00:52:22,490 --> 00:52:24,200
执行任何重量级的

1182
00:52:24,200 --> 00:52:25,020
工作

1183
00:52:25,020 --> 00:52:26,490
，最后您会进行一种

1184
00:52:26,490 --> 00:52:28,830
轻量级的半轻量级验证

1185
00:52:28,830 --> 00:52:29,910
以确保您的交易

1186
00:52:29,910 --> 00:52:34,260
仍然有效，因此如果您

1187
00:52:34,260 --> 00:52:38,100
如果您的所有

1188
00:52:38,100 --> 00:52:39,750
事务本质上都只是做

1189
00:52:39,750 --> 00:52:41,970
只读工作，并且访问

1190
00:52:41,970 --> 00:52:43,980
不相交的数据集，那么这些

1191
00:52:43,980 --> 00:52:46,020
协议就可以很好

1192
00:52:46,020 --> 00:52:47,130
地工作，因为它们实际上除了做一些工作之外根本没有做太多工作

1193
00:52:47,130 --> 00:52:48,660
本地数据复制

1194
00:52:48,660 --> 00:52:52,740
的另一种思考方式是

1195
00:52:52,740 --> 00:52:55,770
，如果您有一个非常大的工作区

1196
00:52:55,770 --> 00:52:57,869
，  d 非常小的事务，并且

1197
00:52:57,869 --> 00:52:59,369
这些事务

1198
00:52:59,369 --> 00:53:00,900
在读取器中重叠的可能性

1199
00:53:00,900 --> 00:53:04,500
在这种特定情况下可能非常低，这些

1200
00:53:04,500 --> 00:53:05,910
乐观并发协议

1201
00:53:05,910 --> 00:53:08,220
在另一方面在

1202
00:53:08,220 --> 00:53:11,610
非常有争议的工作负载中工作得非常好

1203
00:53:11,610 --> 00:53:12,360


1204
00:53:12,360 --> 00:53:14,550


1205
00:53:14,550 --> 00:53:18,150
是的，所以他们在他们的工作阶段做了很多工作，

1206
00:53:18,150 --> 00:53:20,580
假设如果

1207
00:53:20,580 --> 00:53:22,110
没有就没有争用，

1208
00:53:22,110 --> 00:53:23,520
然后只有在最后他们才

1209
00:53:23,520 --> 00:53:24,840
弄清楚哦，废话，

1210
00:53:24,840 --> 00:53:26,400
我所做的所有这些工作都是无用的 在我们正确开始之后，

1211
00:53:26,400 --> 00:53:31,050


1212
00:53:31,050 --> 00:53:32,700


1213
00:53:32,700 --> 00:53:34,170
假设不会有

1214
00:53:34,170 --> 00:53:35,670
很多繁重的

1215
00:53:35,670 --> 00:53:37,290
工作，但在有争议的工作中，尽管有繁重的工作，您还是将很多繁重的工作推迟到最后，

1216
00:53:37,290 --> 00:53:38,280
因为您觉得它们必须

1217
00:53:38,280 --> 00:53:42,180
中止 你所做的一切我

1218
00:53:42,180 --> 00:53:43,859
认为我认为研究

1219
00:53:43,859 --> 00:53:47,750
表明，在有争议的工作负载中

1220
00:53:47,750 --> 00:53:50,400
，两阶段锁定和耗尽

1221
00:53:50,400 --> 00:53:51,840
神秘的并发协议 通常

1222
00:53:51,840 --> 00:53:53,100
不起作用，它们有点像几乎

1223
00:53:53,100 --> 00:53:55,440
等价，所以当两个 plu 只是简单地获取时，锁上

1224
00:53:55,440 --> 00:53:57,359
有很多

1225
00:53:57,359 --> 00:53:59,220
争用，因此您有

1226
00:53:59,220 --> 00:54:01,859
事务在等待，而这些热锁

1227
00:54:01,859 --> 00:54:03,600
在这里您的事务

1228
00:54:03,600 --> 00:54:05,670
正在完成所有工作，几乎是浪费

1229
00:54:05,670 --> 00:54:07,050
工作，然后在最后中止，

1230
00:54:07,050 --> 00:54:10,080
因此它们都不适用于有争议的

1231
00:54:10,080 --> 00:54:12,480
工作负载，但如果您的工作负载

1232
00:54:12,480 --> 00:54:14,690
竞争非常低，那么通常

1233
00:54:14,690 --> 00:54:17,430
这些乐观协议会更好地工作，

1234
00:54:17,430 --> 00:54:19,950
因为除了一些本地数据副本之外，它们没有开销并且

1235
00:54:19,950 --> 00:54:21,450
覆盖非常少

1236
00:54:21,450 --> 00:54:24,510
好的，而在

1237
00:54:24,510 --> 00:54:26,250
两个 PL 协议中，您实际上必须

1238
00:54:26,250 --> 00:54:28,470
获取锁，即使没有合乎逻辑的

1239
00:54:28,470 --> 00:54:30,180
理由应该获取

1240
00:54:30,180 --> 00:54:32,540
这些锁，

1241
00:54:52,880 --> 00:54:55,349
因此时间戳是

1242
00:54:55,349 --> 00:55:20,099
在验证时分配的，我认为

1243
00:55:20,099 --> 00:55:21,690
您所描述的基本上是基本的

1244
00:55:21,690 --> 00:55:23,340
时间戳 顺序正确，因此在基本

1245
00:55:23,340 --> 00:55:24,450
时间戳排序中，您

1246
00:55:24,450 --> 00:55:27,500
在 OCC 聊天中交易开始时分配时间戳

1247
00:55:27,500 --> 00:55:30,450
，协议规定了 您

1248
00:55:30,450 --> 00:55:32,250
在验证时分配时间戳是

1249
00:55:32,250 --> 00:55:35,730
因为您想推迟

1250
00:55:35,730 --> 00:55:38,820
进行实际检查的工作 - 当

1251
00:55:38,820 --> 00:55:40,109
您准备提交时，而基本的

1252
00:55:40,109 --> 00:55:42,030
时间步无聊是说

1253
00:55:42,030 --> 00:55:43,560
我将要执行的每个操作我

1254
00:55:43,560 --> 00:55:44,730
想做一个检查 为了确保这是一个

1255
00:55:44,730 --> 00:55:47,970
有效的操作，所以协议的

1256
00:55:47,970 --> 00:55:59,280
工作原理是的，

1257
00:55:59,280 --> 00:56:03,480
即使您正在阅读以

1258
00:56:03,480 --> 00:56:11,820
确保可重复读取，您仍然需要制作本地副本，因此这张

1259
00:56:11,820 --> 00:56:13,440
幻灯片本质上只是说

1260
00:56:13,440 --> 00:56:15,930
对于低争用工作负载，这些

1261
00:56:15,930 --> 00:56:17,490
乐观并发 协议工作

1262
00:56:17,490 --> 00:56:18,780
得很好，因为

1263
00:56:18,780 --> 00:56:21,510
与两阶段锁定相比，它们的开销非常小

1264
00:56:21,510 --> 00:56:23,390
，你知道即使事务

1265
00:56:23,390 --> 00:56:25,830
之间有不相交的工作集，

1266
00:56:25,830 --> 00:56:27,119
你仍然必须让

1267
00:56:27,119 --> 00:56:29,760
事务需要锁，而

1268
00:56:29,760 --> 00:56:32,960
这里根本没有锁，

1269
00:56:44,410 --> 00:56:46,880
这家伙是的，你 是对的，

1270
00:56:46,880 --> 00:56:49,099
所以你不必像锁的数据库一样获取

1271
00:56:49,099 --> 00:56:50,479
你仍然

1272
00:56:50,479 --> 00:56:52,430
需要闩锁你仍然需要

1273
00:56:52,430 --> 00:56:54,680
确保数据结构的完整性

1274
00:56:54,680 --> 00:56:56,269
是 val 是的，

1275
00:56:56,269 --> 00:56:58,970
您不能盲目地覆盖

1276
00:56:58,970 --> 00:57:00,140
内存中的内容，因为可能

1277
00:57:00,140 --> 00:57:01,609
对这些结构进行并发访问，

1278
00:57:01,609 --> 00:57:02,930
所以我认为您有点

1279
00:57:02,930 --> 00:57:04,130
想我们将

1280
00:57:04,130 --> 00:57:05,119
讨论它

1281
00:57:05,119 --> 00:57:09,319
我认为在这张幻灯片中是的，所以有

1282
00:57:09,319 --> 00:57:12,410
OCC 中的一点工作开销是对的，

1283
00:57:12,410 --> 00:57:13,519
因为您必须维护

1284
00:57:13,519 --> 00:57:15,019
要读取和写入的所有内容的本地副本，

1285
00:57:15,019 --> 00:57:16,249
因此如果您要更新

1286
00:57:16,249 --> 00:57:17,119
十亿两个极点，您必须制作

1287
00:57:17,119 --> 00:57:18,979
十亿个副本，每个事务都必须

1288
00:57:18,979 --> 00:57:20,749
制作十亿个副本 所以这里有

1289
00:57:20,749 --> 00:57:24,079
很多开销，另一件事是

1290
00:57:24,079 --> 00:57:25,489
验证和正确的阶段

1291
00:57:25,489 --> 00:57:27,559
是它们是连续发生

1292
00:57:27,559 --> 00:57:29,329
的，只有一个事务可以

1293
00:57:29,329 --> 00:57:30,470
一次验证

1294
00:57:30,470 --> 00:57:33,170
在现实中你知道在真实系统中你

1295
00:57:33,170 --> 00:57:34,819
在并行写入中有并行验证

1296
00:57:34,819 --> 00:57:36,440
但是 再次，即使在那些

1297
00:57:36,440 --> 00:57:38,569
场景中，这些阶段也成为一个很大的

1298
00:57:38,569 --> 00:57:43,999
瓶颈，最后因为我们

1299
00:57:43,999 --> 00:57:45,589
很乐观，我们假设我们

1300
00:57:45,589 --> 00:57:47,479
可以安全地与你一起执行所有工作，

1301
00:57:47,479 --> 00:57:49,549
而无需

1302
00:57:49,549 --> 00:57:51,619
被其他事务打断了，但

1303
00:57:51,619 --> 00:57:53,269
在有争议的工作负载中，

1304
00:57:53,269 --> 00:57:54,319
事实并非如此，

1305
00:57:54,319 --> 00:57:55,400
假设无效，

1306
00:57:55,400 --> 00:57:57,440
因此在有争议的工作负载中预先路由所有

1307
00:57:57,440 --> 00:57:59,809
这些工作，然后我们可以

1308
00:57:59,809 --> 00:58:01,249
发现我们实际上必须

1309
00:58:01,249 --> 00:58:03,049
中止所有这些 工作被浪费了，

1310
00:58:03,049 --> 00:58:04,969
我们很乐观，我们

1311
00:58:04,969 --> 00:58:12,829
对这种乐观态度是错误的，所以当

1312
00:58:12,829 --> 00:58:16,640
交易提交时，他们他们我

1313
00:58:16,640 --> 00:58:18,619
认为学生

1314
00:58:18,619 --> 00:58:20,650
正确地指出了这一点，

1315
00:58:20,650 --> 00:58:23,150
即使这些交易在

1316
00:58:23,150 --> 00:58:25,460
逻辑上不重叠 彼此之间，

1317
00:58:25,460 --> 00:58:27,650
您仍然必须确保

1318
00:58:27,650 --> 00:58:29,749
保持要查看的数据结构的物理完整性，

1319
00:58:29,749 --> 00:58:31,099


1320
00:58:31,099 --> 00:58:33,829
因此作为验证阶段的一部分，

1321
00:58:33,829 --> 00:58:35,329
您必须查看哦，我让您知道我拥有的

1322
00:58:35,329 --> 00:58:36,710
所有其他数千个 Trent

1323
00:58:36,710 --> 00:58:37,969
交易

1324
00:58:37,969 --> 00:58:39,859
以一致的方式查看读取和写入集的内部，

1325
00:58:39,859 --> 00:58:43,239
我通过正确获取锁存器来使其保持一致，

1326
00:58:43,239 --> 00:58:47,180
因此这个锁存器

1327
00:58:47,180 --> 00:58:49,730
开销实际上可以发挥很大的作用 le

1328
00:58:49,730 --> 00:58:52,580
即使它们在逻辑上只是物理上不相交，

1329
00:58:52,580 --> 00:58:54,230
它们仍然在

1330
00:58:54,230 --> 00:58:55,400
那里竞争相同的数据结构，因此

1331
00:58:55,400 --> 00:58:56,360
在读取和写入数据

1332
00:58:56,360 --> 00:58:58,790
集上竞争，即使逻辑上它们

1333
00:58:58,790 --> 00:59:02,750
断开连接是的，所以当我进行

1334
00:59:02,750 --> 00:59:04,760
验证时，我有 一个交易

1335
00:59:04,760 --> 00:59:06,290
和我我准备验证我必须

1336
00:59:06,290 --> 00:59:07,400
进入他的读写交易

1337
00:59:07,400 --> 00:59:09,400
集以确保我们不会

1338
00:59:09,400 --> 00:59:11,480
交叉但他可能正在修改它

1339
00:59:11,480 --> 00:59:13,580
因为他仍在运行他或她

1340
00:59:13,580 --> 00:59:15,350
仍在正确运行所以我 必须获取

1341
00:59:15,350 --> 00:59:17,630
闩锁读取它的一致视图

1342
00:59:17,630 --> 00:59:19,010
执行交集以确保

1343
00:59:19,010 --> 00:59:21,710
我没事，他和另一个

1344
00:59:21,710 --> 00:59:23,480
事务无法修改

1345
00:59:23,480 --> 00:59:30,470
我正在阅读它时所说的内容，但我正在阅读

1346
00:59:30,470 --> 00:59:32,090
本地副本我 m 读取该事务

1347
00:59:32,090 --> 00:59:37,520
的工作集本地副本，因为

1348
00:59:37,520 --> 00:59:38,660
该表没有所有

1349
00:59:38,660 --> 00:59:41,390
已应用的更新，该

1350
00:59:41,390 --> 00:59:42,980
事务已读取并已读取和

1351
00:59:42,980 --> 00:59:44,780
写入写入事务具有

1352
00:59:44,780 --> 00:59:47,030
Reason 权限的本地副本，以便查看是否

1353
00:59:47,030 --> 00:59:49,610
日 是事务读取了

1354
00:59:49,610 --> 00:59:52,250
我正在写入的值我只知道通过

1355
00:59:52,250 --> 00:59:53,480
查看他我们没有写说我

1356
00:59:53,480 --> 00:59:57,460
不知道通过查看表

1357
00:59:59,410 --> 01:00:02,960
所以我必须查看本地

1358
01:00:02,960 --> 01:00:04,340
世界本地工作 所有这两个的副本

1359
01:00:04,340 --> 01:00:05,540
是其他交易

1360
01:00:05,540 --> 01:00:08,090
作为我验证的一部分，我这样

1361
01:00:08,090 --> 01:00:09,560
做，为了以一致的方式做到这一点，

1362
01:00:09,560 --> 01:00:11,300
我必须获取闩锁，这个闩锁

1363
01:00:11,300 --> 01:00:13,300
是这些闩锁可能有一些开销

1364
01:00:13,300 --> 01:00:29,900
是的，有这个是的

1365
01:00:29,900 --> 01:00:31,070
有很多技术可以

1366
01:00:31,070 --> 01:00:32,720
用来减少斜线争用，但

1367
01:00:32,720 --> 01:00:33,950
在一天结束时，

1368
01:00:33,950 --> 01:00:35,900
即使你有平行的瞄准，也会

1369
01:00:35,900 --> 01:00:41,690
有一些开销，所以如果我们采取

1370
01:00:41,690 --> 01:00:45,250
稍微不同的观点怎么办，如果我们

1371
01:00:45,250 --> 01:00:49,660
如果我们对整个数据库进行分区，

1372
01:00:49,660 --> 01:00:51,860
以便一个

1373
01:00:51,860 --> 01:00:53,150
事务必须处理的所有内容都只

1374
01:00:53,150 --> 01:00:55,250
在一个事务中，然后我可以完全

1375
01:00:55,250 --> 01:00:56,900
删除所有锁和闩锁，

1376
01:00:56,900 --> 01:01:00,680
那甚至是可能的，所以

1377
01:01:00,680 --> 01:01:02,480
结果证明这是一个有效的 技术

1378
01:01:02,480 --> 01:01:03,170
一 nd

1379
01:01:03,170 --> 01:01:05,660
它被称为基于分区的时间戳

1380
01:01:05,660 --> 01:01:06,140
排序

1381
01:01:06,140 --> 01:01:08,239
的想法是我想将我的

1382
01:01:08,239 --> 01:01:10,579
数据库拆分为这些水平

1383
01:01:10,579 --> 01:01:14,329
分区，然后我希望

1384
01:01:14,329 --> 01:01:16,789
能够使用时间戳以正确

1385
01:01:16,789 --> 01:01:19,099
的顺序对分区上的事务进行

1386
01:01:19,099 --> 01:01:21,829
排序，所以如果我有事务

1387
01:01:21,829 --> 01:01:23,749
串行执行然后

1388
01:01:23,749 --> 01:01:25,700
没有理由我很抱歉在数据库

1389
01:01:25,700 --> 01:01:27,049
中根本没有理由有锁和

1390
01:01:27,049 --> 01:01:28,549
闩锁，因为

1391
01:01:28,549 --> 01:01:32,329
如果它们在单线程运行，则没有并发活动正确

1392
01:01:32,329 --> 01:01:34,339
我不需要

1393
01:01:34,339 --> 01:01:34,670
灯

1394
01:01:34,670 --> 01:01:36,880
我不需要锁 我不需要闩锁

1395
01:01:36,880 --> 01:01:40,940
，然后

1396
01:01:40,940 --> 01:01:41,809
如果您必须访问

1397
01:01:41,809 --> 01:01:43,880
多个这些数据库分区，它会变得有点复杂，

1398
01:01:43,880 --> 01:01:46,130
但是如果您只访问

1399
01:01:46,130 --> 01:01:48,349
一个分区内的所有数据，那么它

1400
01:01:48,349 --> 01:01:49,640
可能真的非常快

1401
01:01:49,640 --> 01:01:51,739
，这是排序 什么基于分区的

1402
01:01:51,739 --> 01:01:53,920
时间步排序试图实现

1403
01:01:53,920 --> 01:01:56,180
让我们通过一个例子来

1404
01:01:56,180 --> 01:02:00,410
想象一下我有这个模式

1405
01:02:00,410 --> 01:02:01,759
代表我正在运行的某个在线商店

1406
01:02:01,759 --> 01:02:04,730
我有 e 客户订单

1407
01:02:04,730 --> 01:02:07,819
和订单项目 订单中的项目

1408
01:02:07,819 --> 01:02:10,670
我

1409
01:02:10,670 --> 01:02:13,309
可能会做的是因为我有这些

1410
01:02:13,309 --> 01:02:15,019
外键引用 我可以

1411
01:02:15,019 --> 01:02:16,970
在表当天的一个分区中存储

1412
01:02:16,970 --> 01:02:19,940
一组客户 他们的

1413
01:02:19,940 --> 01:02:22,099
订单和他们订单的所有项目

1414
01:02:22,099 --> 01:02:24,920
通过使用这个这个这个

1415
01:02:24,920 --> 01:02:27,739
外键参考结构

1416
01:02:27,739 --> 01:02:29,150
可以想象我现在有两个数据库

1417
01:02:29,150 --> 01:02:31,999
，我

1418
01:02:31,999 --> 01:02:35,900
在一个单独的数据库中拥有一个到 1001 和 1002 2000 的客户，

1419
01:02:35,900 --> 01:02:37,759
我想要我不' 不知道让我们说我

1420
01:02:37,759 --> 01:02:39,890
想更新一个客户的名字我想

1421
01:02:39,890 --> 01:02:42,579
添加到一个客户的订单中

1422
01:02:42,579 --> 01:02:45,910
我该怎么

1423
01:02:45,910 --> 01:02:48,619
做交易我在这里有一个应用程序

1424
01:02:48,619 --> 01:02:50,599
它开始一个交易并且

1425
01:02:50,599 --> 01:02:52,029
假设它正在尝试更新

1426
01:02:52,029 --> 01:02:54,319
一个客户客户

1427
01:02:54,319 --> 01:02:58,849
在这里落入这个分区所以好吧它丢失了

1428
01:02:58,849 --> 01:02:59,150
一些东西

1429
01:02:59,150 --> 01:03:02,299
所以假设在这一行中

1430
01:03:02,299 --> 01:03:04,039
有一个操作说让我知道

1431
01:03:04,039 --> 01:03:05,869
客户的姓名，他的 ID 是一个

1432
01:03:05,869 --> 01:03:07,910
好的，这是一个明显的操作 y

1433
01:03:07,910 --> 01:03:09,289
落入这个分区，因为这个

1434
01:03:09,289 --> 01:03:13,740
客户属于这个分区

1435
01:03:13,740 --> 01:03:16,140
，然后它确实提交了，它可以

1436
01:03:16,140 --> 01:03:18,029
安全地做到这一点，因为所有

1437
01:03:18,029 --> 01:03:19,589
这些事务都

1438
01:03:19,589 --> 01:03:21,089
在一个线程中排队和操作，并且

1439
01:03:21,089 --> 01:03:22,230
在这个数据库

1440
01:03:22,230 --> 01:03:24,559
中的这种传输没有并发活动

1441
01:03:24,559 --> 01:03:28,170
同样，我可以有另一个应用程序

1442
01:03:28,170 --> 01:03:31,130
服务器想要更新客户

1443
01:03:31,130 --> 01:03:35,430
1004 将在这里进行，这两个

1444
01:03:35,430 --> 01:03:37,259
事务完全不相交，

1445
01:03:37,259 --> 01:03:38,700
它们在不同的客户上运行，

1446
01:03:38,700 --> 01:03:40,499
这是我们获得并行性的一种方式，

1447
01:03:40,499 --> 01:03:42,539
即使每个数据库都在单线程运行

1448
01:03:42,539 --> 01:03:45,329


1449
01:03:45,329 --> 01:03:47,130
我们可以拥有这些客户的粒度越细，我们可以

1450
01:03:47,130 --> 01:03:48,630
存储这些数据库

1451
01:03:48,630 --> 01:03:52,049
分区，我们可以获得更多的并行性，

1452
01:03:52,049 --> 01:03:54,089
这样每个处理单个事务的

1453
01:03:54,089 --> 01:03:55,259
运行速度就会快得多，因为我们

1454
01:03:55,259 --> 01:03:57,509
不必获取锁和闩锁，我们

1455
01:03:57,509 --> 01:03:59,009
通过拥有更多来获得并行性 这些

1456
01:03:59,009 --> 01:04:00,269
事务在

1457
01:04:00,269 --> 01:04:05,509
不相交的数据集上并发时是清楚的，

1458
01:04:05,509 --> 01:04:10,289
所以结果是 要成为一个非常

1459
01:04:10,289 --> 01:04:13,470
流行的协议，您仍然必须

1460
01:04:13,470 --> 01:04:15,269
分配事务和 ID，然后将

1461
01:04:15,269 --> 01:04:20,450
它们排队，再见，这些 ID

1462
01:04:20,450 --> 01:04:22,890
，这种基于分区的

1463
01:04:22,890 --> 01:04:25,769
协议实际上非常

1464
01:04:25,769 --> 01:04:27,539
非常成功，因此 Andy 研究了

1465
01:04:27,539 --> 01:04:28,589
这个称为 a  store 这是一个

1466
01:04:28,589 --> 01:04:32,730
商业系统，现在已经

1467
01:04:32,730 --> 01:04:34,200
商业化到 volt EB 中，他们

1468
01:04:34,200 --> 01:04:35,789
仍在使用这种

1469
01:04:35,789 --> 01:04:37,950
基于分区的时间戳排序 Andy

1470
01:04:37,950 --> 01:04:40,019
与一个

1471
01:04:40,019 --> 01:04:41,249
叫 Danny body 的教授一起工作，我认为

1472
01:04:41,249 --> 01:04:43,319
Marilyn 现在做了一些初始 在

1473
01:04:43,319 --> 01:04:44,819
一个名为 Calvin 的系统上工作，该系统现在已经

1474
01:04:44,819 --> 01:04:47,309
商业化为动物群，它也使用

1475
01:04:47,309 --> 01:04:48,569
与此非常相似的东西，

1476
01:04:48,569 --> 01:04:50,910
还有一个名为 K DB 的系统，它

1477
01:04:50,910 --> 01:04:53,430
类似于金融数据库，他们也

1478
01:04:53,430 --> 01:04:55,079
使用这种技术，

1479
01:04:55,079 --> 01:04:56,880
如果你的工作，它实际上非常成功

1480
01:04:56,880 --> 01:04:58,619
投票支持这种类型的

1481
01:04:58,619 --> 01:05:03,210
基于分区的操作，您可以

1482
01:05:03,210 --> 01:05:04,349
查看的方式是每个单个数据库

1483
01:05:04,349 --> 01:05:06,480
本质上都有一个巨大的锁或一个闩

1484
01:05:06,480 --> 01:05:08,609
锁 d 它，当一个事务

1485
01:05:08,609 --> 01:05:10,079
准备好提交时，它获取这个锁存器

1486
01:05:10,079 --> 01:05:12,170
，它开始在

1487
01:05:12,170 --> 01:05:14,700
数据库内执行完全

1488
01:05:14,700 --> 01:05:16,769
单线程裸机裸机速度，

1489
01:05:16,769 --> 01:05:19,410
然后当其他事务出现时，它们

1490
01:05:19,410 --> 01:05:21,420
在这个锁存器上排队，它们

1491
01:05:21,420 --> 01:05:22,739
基本上被分配了一个 时间戳，

1492
01:05:22,739 --> 01:05:24,989
然后当他们的时间戳被敲响

1493
01:05:24,989 --> 01:05:26,430
时，他们开始在这个

1494
01:05:26,430 --> 01:05:27,510
数据库中执行

1495
01:05:27,510 --> 01:05:31,100
到这个数据库分区中

1496
01:05:33,500 --> 01:05:36,030


1497
01:05:36,030 --> 01:05:41,190


1498
01:05:41,190 --> 01:05:42,840


1499
01:05:42,840 --> 01:05:44,700


1500
01:05:44,700 --> 01:05:46,050


1501
01:05:46,050 --> 01:05:47,790
因为他们来了 Garon，

1502
01:05:47,790 --> 01:05:49,619
数据库系统保证系统中

1503
01:05:49,619 --> 01:05:50,700
没有其他事务在运行，

1504
01:05:50,700 --> 01:05:54,600
这很好，如果您只想

1505
01:05:54,600 --> 01:05:56,550
读取一个数据库分区内的内容，

1506
01:05:56,550 --> 01:05:58,590


1507
01:05:58,590 --> 01:06:02,700
当您想尝试读取

1508
01:06:02,700 --> 01:06:04,650
跨分区存在的行时会变得复杂，所以在 在

1509
01:06:04,650 --> 01:06:06,030
我们之前拥有的应用程序服务器中，

1510
01:06:06,030 --> 01:06:07,680
假设您想在一个

1511
01:06:07,680 --> 01:06:09,510
事务中进行修改 c 来自两个不同

1512
01:06:09,510 --> 01:06:11,369
分区的客户变得复杂，

1513
01:06:11,369 --> 01:06:13,290
因为现在我必须先获取

1514
01:06:13,290 --> 01:06:15,000
一个分区的锁并获取另一个分区的锁，

1515
01:06:15,000 --> 01:06:16,710
然后才能进行任何

1516
01:06:16,710 --> 01:06:19,050
类型的操作，好吧，通常

1517
01:06:19,050 --> 01:06:20,820
甚至不可能先验地知道

1518
01:06:20,820 --> 01:06:22,740
所有分区 并且必须接触

1519
01:06:22,740 --> 01:06:24,690
它，所以一些系统他们实际做的

1520
01:06:24,690 --> 01:06:25,890
是他们会

1521
01:06:25,890 --> 01:06:27,900
像推测或

1522
01:06:27,900 --> 01:06:29,400
侦察模式一样运行系统以找出

1523
01:06:29,400 --> 01:06:31,850
我需要访问的所有分区，然后

1524
01:06:31,850 --> 01:06:34,380
回滚获取所有锁

1525
01:06:34,380 --> 01:06:38,570
时间，然后开始执行，

1526
01:06:38,570 --> 01:06:41,160
是的，所以这就是本质上的

1527
01:06:41,160 --> 01:06:42,630
内容，如果我必须

1528
01:06:42,630 --> 01:06:45,390
跨分区行访问跨分区我

1529
01:06:45,390 --> 01:06:47,580
必须中止并重新启动并获取新

1530
01:06:47,580 --> 01:06:48,869
锁我

1531
01:06:48,869 --> 01:06:51,210
在执行过程中发现的新锁集和 这可能

1532
01:06:51,210 --> 01:06:53,460
会很浪费，所以如果你必须在

1533
01:06:53,460 --> 01:06:54,990
何时要

1534
01:06:54,990 --> 01:06:59,910
应用基于分区的时间步长顺序时要小心，

1535
01:06:59,910 --> 01:07:02,040
所以与常规时间步长

1536
01:07:02,040 --> 01:07:04,530
排序和 OCC 我现在可以正确地应用我的所有

1537
01:07:04,530 --> 01:07:07,109
更新，所以当 oasis-c

1538
01:07:07,109 --> 01:07:09,030
和基本时间戳排序时，我有一个

1539
01:07:09,030 --> 01:07:10,830
私人工作区或数据图，

1540
01:07:10,830 --> 01:07:12,690
我必须应用我的更新，这样我

1541
01:07:12,690 --> 01:07:14,820
就不会与其他

1542
01:07:14,820 --> 01:07:17,040
正在运行的事务发生冲突 同时

1543
01:07:17,040 --> 01:07:18,200
想要阅读我正在写的相同的东西，

1544
01:07:18,200 --> 01:07:20,760
但是这里的商品系统

1545
01:07:20,760 --> 01:07:22,440
保证一次只有一个

1546
01:07:22,440 --> 01:07:24,119
事务在运行，我可以

1547
01:07:24,119 --> 01:07:27,330
在适当的位置应用我的更新，当然

1548
01:07:27,330 --> 01:07:28,770
我有一些额外的逻辑来确保

1549
01:07:28,770 --> 01:07:30,540
当我 中止我撤消了这些更改，但我

1550
01:07:30,540 --> 01:07:32,340
可以在不制作本地副本的情况下执行此操作，

1551
01:07:32,340 --> 01:07:34,109
因此如果我尝试修改存在的元组，我减少了 OCC 系统

1552
01:07:34,109 --> 01:07:35,369
中通常存在的数据复制开销，

1553
01:07:35,369 --> 01:07:38,090


1554
01:07:41,160 --> 01:07:44,740
以及希腊案例中的广告

1555
01:07:44,740 --> 01:07:47,830
在

1556
01:07:47,830 --> 01:07:48,790
与我现在运行时不同的分区中，

1557
01:07:48,790 --> 01:07:51,250
我将中止重新

1558
01:07:51,250 --> 01:07:53,110
启动锁定两个数据库系统或

1559
01:07:53,110 --> 01:07:55,150
数据库分区，然后

1560
01:07:55,150 --> 01:08:14,860


1561
01:08:14,860 --> 01:08:16,390


1562
01:08:16,390 --> 01:08:18,790
开始执行 广告每个

1563
01:08:18,790 --> 01:08:20,259
分区都有一个事务执行

1564
01:08:20,259 --> 01:08:24,729
线程，这

1565
01:08:24,729 --> 01:08:26,290
就是你想要这样做的原因之一，因为

1566
01:08:26,290 --> 01:08:28,569
你只有一个线程，你

1567
01:08:28,569 --> 01:08:29,680
不必复制你不必有

1568
01:08:29,680 --> 01:08:49,109
锁和闩锁是的，所以我 认为

1569
01:08:49,109 --> 01:08:51,160
他们是通过这种方式解决问题的方法，

1570
01:08:51,160 --> 01:08:52,120
如果你有一个

1571
01:08:52,120 --> 01:08:53,589
确定性的顺序来获取

1572
01:08:53,589 --> 01:08:54,880
锁，这是缓解这个问题的一种方法，

1573
01:08:54,880 --> 01:08:56,830
但我认为你有点

1574
01:08:56,830 --> 01:08:59,049
暗指你可以

1575
01:08:59,049 --> 01:09:01,270
拥有 如果您在

1576
01:09:01,270 --> 01:09:02,589
执行过程中不断了解您正在

1577
01:09:02,589 --> 01:09:04,990
接触不同的分区，因此您做

1578
01:09:04,990 --> 01:09:06,790
了一些工作，意识到您必须将其

1579
01:09:06,790 --> 01:09:08,830
获取到分区的锁中，

1580
01:09:08,830 --> 01:09:11,290
而您没有中止重试

1581
01:09:11,290 --> 01:09:12,609
在执行中进一步实现 你

1582
01:09:12,609 --> 01:09:14,229
必须获得一个不同的锁，一个

1583
01:09:14,229 --> 01:09:16,180
不同的分区中止，然后我们

1584
01:09:16,180 --> 01:09:17,920
开始，你

1585
01:09:17,920 --> 01:09:19,330
希望逐渐增加你必须获得的锁集，

1586
01:09:19,330 --> 01:09:21,609
因为你不

1587
01:09:21,609 --> 01:09:24,210
知道

1588
01:09:50,549 --> 01:09:52,538
先验是的，但是你看到了所以你解决了这个

1589
01:09:52,538 --> 01:09:53,649
问题 m 通过让这些

1590
01:09:53,649 --> 01:09:55,750
事务以确定性顺序以特定顺序获取锁，

1591
01:09:55,750 --> 01:09:57,760


1592
01:09:57,760 --> 01:09:59,980
因此您假设分区 a 和

1593
01:09:59,980 --> 01:10:03,760
B，您有 t1 t2 20 X sa 和 B，他们

1594
01:10:03,760 --> 01:10:04,480
意识到他们需要不同的

1595
01:10:04,480 --> 01:10:06,849
分区，然后他们重新启动中止

1596
01:10:06,849 --> 01:10:08,650
，现在 他们都获得了a，他们都

1597
01:10:08,650 --> 01:10:10,329
获得了B，然后他们排队

1598
01:10:10,329 --> 01:10:14,829
并按照这个顺序执行，

1599
01:10:14,829 --> 01:10:18,480
好吧，这基本上是

1600
01:10:18,480 --> 01:10:21,070
基于分区的时间步长排序，这

1601
01:10:21,070 --> 01:10:22,420
是正在发生的事情的直观说明，

1602
01:10:22,420 --> 01:10:25,809
假设你有两个

1603
01:10:25,809 --> 01:10:26,980
两个服务器都试图访问

1604
01:10:26,980 --> 01:10:28,929
第一个

1605
01:10:28,929 --> 01:10:32,020
分区中的一些客户数据 发出开始请求 他们

1606
01:10:32,020 --> 01:10:33,610
在这个事务队列中排队

1607
01:10:33,610 --> 01:10:35,530
他们得到分配的时间戳

1608
01:10:35,530 --> 01:10:37,570
假设服务器一个得到 x 倍 100 的

1609
01:10:37,570 --> 01:10:42,159
奴役 它得到时间戳 101

1610
01:10:42,159 --> 01:10:44,079
显然是数据库 在这种情况下，系统将

1611
01:10:44,079 --> 01:10:45,460
采用具有最低时间戳的事务，它

1612
01:10:45,460 --> 01:10:47,170
是从

1613
01:10:47,170 --> 01:10:50,320
服务器开始执行的事务，它是

1614
01:10:50,320 --> 01:10:52,030
通过获取对此数据的锁定来获取的

1615
01:10:52,030 --> 01:10:54,670
基本分区 它完成了它的

1616
01:10:54,670 --> 01:10:58,750
执行 它很抱歉它正在做

1617
01:10:58,750 --> 01:10:59,800
一堆工作 它正在获取客户

1618
01:10:59,800 --> 01:11:00,820
ID 并且它正在更新

1619
01:11:00,820 --> 01:11:02,679
动画 有点不稳定 但是

1620
01:11:02,679 --> 01:11:06,309
然后它提交了 它是安全的 因为

1621
01:11:06,309 --> 01:11:07,840
没有其他东西在

1622
01:11:07,840 --> 01:11:10,480
运行 同时，现在这个分区

1623
01:11:10,480 --> 01:11:13,539
现在可以向上移动这个来自

1624
01:11:13,539 --> 01:11:16,599
服务器 2 的请求在队列中向上开始执行

1625
01:11:16,599 --> 01:11:19,420
获取锁然后整个

1626
01:11:19,420 --> 01:11:24,210
循环继续正常，

1627
01:11:25,500 --> 01:11:28,570
因为我们已经讨论过

1628
01:11:28,570 --> 01:11:31,510
一些这些系统显然不是 一个

1629
01:11:31,510 --> 01:11:33,340
灵丹妙药，他们有

1630
01:11:33,340 --> 01:11:35,770
一些性能问题，所以

1631
01:11:35,770 --> 01:11:38,409
如果数据库

1632
01:11:38,409 --> 01:11:41,020
在开始执行之前就知道事务需要哪些分区，

1633
01:11:41,020 --> 01:11:43,179
这

1634
01:11:43,179 --> 01:11:44,500
在某种交互式事务协议中是不可能的，所以这些系统非常快，

1635
01:11:44,500 --> 01:11:45,989


1636
01:11:45,989 --> 01:11:48,909
但您可以通过以下方式解决这个问题： 存储

1637
01:11:48,909 --> 01:11:51,340
过程就在存储过程中，您可以

1638
01:11:51,340 --> 01:11:55,000
在自己的身上声明所有内容，

1639
01:11:55,000 --> 01:11:57,579
而不必来回往返，

1640
01:11:57,579 --> 01:11:58,570
数据库会一直运行 ything 在服务器

1641
01:11:58,570 --> 01:12:00,880
端，所以可以在持久执行之前更快地确定

1642
01:12:00,880 --> 01:12:02,770
所有锁定系统

1643
01:12:02,770 --> 01:12:09,969
，

1644
01:12:09,969 --> 01:12:11,469
如果事务只涉及一个

1645
01:12:11,469 --> 01:12:12,940
分区，那么显然它会

1646
01:12:12,940 --> 01:12:14,200
非常快，但如果它必须涉及

1647
01:12:14,200 --> 01:12:16,719
多个分区，你必须做

1648
01:12:16,719 --> 01:12:19,060
一些 执行通过获取

1649
01:12:19,060 --> 01:12:20,650
更多锁来中止重试，然后再次继续执行

1650
01:12:20,650 --> 01:12:23,350
是正确的，因此它变得更慢，但是

1651
01:12:23,350 --> 01:12:25,150
如果您的事务只涉及

1652
01:12:25,150 --> 01:12:26,500
一个分区内的数据，那么您

1653
01:12:26,500 --> 01:12:28,210
实际上运行的是裸机速度，

1654
01:12:28,210 --> 01:12:30,910
因为它是单线程

1655
01:12:30,910 --> 01:12:34,480
的，没有锁没有闩锁 另一个

1656
01:12:34,480 --> 01:12:37,360
缺点是，如果你有这个多

1657
01:12:37,360 --> 01:12:38,980
分区设置，你可以

1658
01:12:38,980 --> 01:12:41,140
处理一些

1659
01:12:41,140 --> 01:12:42,520
基本上空闲的分区，因为你有

1660
01:12:42,520 --> 01:12:50,320
一个热分区，所以

1661
01:12:50,320 --> 01:12:52,330
这基本上是基于分区的

1662
01:12:52,330 --> 01:12:56,410
时间戳排序尝试

1663
01:12:56,410 --> 01:12:58,450
尽可能快地通过 可能所以

1664
01:12:58,450 --> 01:12:59,200
我们在

1665
01:12:59,200 --> 01:13:01,660
整个工作中所做的假设之一是

1666
01:13:01,660 --> 01:13:03,660
交易执行时 不要真正

1667
01:13:03,660 --> 01:13:06,520
插入新数据，他们只修改数据

1668
01:13:06,520 --> 01:13:09,400
，他们读取数据，所以当你现在

1669
01:13:09,400 --> 01:13:11,410
添加要求时，数据

1670
01:13:11,410 --> 01:13:14,830
可以在执行过程中插入和更新，删除和

1671
01:13:14,830 --> 01:13:18,160
插入它违反

1672
01:13:18,160 --> 01:13:19,180
了我们一直在

1673
01:13:19,180 --> 01:13:20,800
那里的一些假设 我们已经在我们的协议中做出了

1674
01:13:20,800 --> 01:13:23,920
，我们必须好好处理它们，

1675
01:13:23,920 --> 01:13:26,200
特别是引入了一个有趣的

1676
01:13:26,200 --> 01:13:29,020
问题，称为幻影

1677
01:13:29,020 --> 01:13:31,030
问题，所以想象一下我们在这里有相同

1678
01:13:31,030 --> 01:13:33,100
的执行顺序，但现在我

1679
01:13:33,100 --> 01:13:34,239
使用的是续集语句而不是

1680
01:13:34,239 --> 01:13:36,310
常规读取和 写操作，我们

1681
01:13:36,310 --> 01:13:38,850
有这两个事务 t1 和 t2

1682
01:13:38,850 --> 01:13:41,050
，我们在这个数据库中有数据，这些

1683
01:13:41,050 --> 01:13:42,940
人有你知道姓名、

1684
01:13:42,940 --> 01:13:45,190
H 和一些状态，

1685
01:13:45,190 --> 01:13:46,840
所以正在执行的事务 t1 获得

1686
01:13:46,840 --> 01:13:48,820
最大值 最年长的人

1687
01:13:48,820 --> 01:13:52,000
状态亮起 好的，让我们假设它

1688
01:13:52,000 --> 01:13:53,950
运行并计算出最大

1689
01:13:53,950 --> 01:13:55,750
年龄为 72，然后我们有了这个

1690
01:13:55,750 --> 01:13:57,969
事务 t2，

1691
01:13:57,969 --> 01:14:00,340
它基本上将把它输入到同一个数据库中

1692
01:14:00,340 --> 01:14:02,560
一个 96 岁的新人，他也

1693
01:14:02,560 --> 01:14:05,440
碰巧被点亮，然后我们

1694
01:14:05,440 --> 01:14:07,540
回到这里，所以它是相同的 t1

1695
01:14:07,540 --> 01:14:11,380
尝试重新执行相同的查询，

1696
01:14:11,380 --> 01:14:14,170
它得到一个不同的版本，它

1697
01:14:14,170 --> 01:14:16,789
从这个查询中得到不同的结果，所以得到了 这里

1698
01:14:16,789 --> 01:14:19,460
有 96 个，今天这里有 72 个这显然

1699
01:14:19,460 --> 01:14:20,150
是一个问题，

1700
01:14:20,150 --> 01:14:23,210
孩子们可以锁相解决

1701
01:14:23,210 --> 01:14:40,579
这个假设元组轴谁说不

1702
01:14:40,579 --> 01:14:50,449
为什么你说不是的，就是这样

1703
01:14:50,449 --> 01:14:52,429
，这是完全正确的，你只能

1704
01:14:52,429 --> 01:14:54,920
访问那个元组上的锁

1705
01:14:54,920 --> 01:15:00,769
之所以存在，是因为有新

1706
01:15:00,769 --> 01:15:01,909
事务插入了一个新元组，

1707
01:15:01,909 --> 01:15:04,340
他们甚至没有

1708
01:15:04,340 --> 01:15:06,710
获得正确锁定的东西，这

1709
01:15:06,710 --> 01:15:08,150
显然是一个问题，

1710
01:15:08,150 --> 01:15:09,500
如果我想确保它是可

1711
01:15:09,500 --> 01:15:11,329
实现的，我们如何解决这个问题，我必须确保 我

1712
01:15:11,329 --> 01:15:13,940
可以确保我可以确保快速读取所以

1713
01:15:13,940 --> 01:15:15,679
如果你看到这个幻影问题没问题

1714
01:15:15,679 --> 01:15:18,949
那么如果

1715
01:15:18,949 --> 01:15:21,440
我可以获取抽象对象的锁而不是获取元组的锁

1716
01:15:21,440 --> 01:15:24,230
怎么办如果我可以

1717
01:15:24,230 --> 01:15:27,079
获取表达式状态的锁 Lit 会

1718
01:15:27,079 --> 01:15:30,440
解决 如果我锁定

1719
01:15:30,440 --> 01:15:32,690
所有满足条件状态的元组，问题

1720
01:15:32,690 --> 01:15:38,539
就等于说是的盖子一个

1721
01:15:38,539 --> 01:15:43,179
说不的人说他们不知道

1722
01:15:43,179 --> 01:15:46,010
好所以答案是肯定的，如果你能

1723
01:15:46,010 --> 01:15:47,539
有一个足够强大的

1724
01:15:47,539 --> 01:15:48,860
锁定 系统，你可以有一个

1725
01:15:48,860 --> 01:15:51,530
ex-con 一个表达式说 status is

1726
01:15:51,530 --> 01:15:53,630
equal to Lid 你可以解决这个问题

1727
01:15:53,630 --> 01:15:56,210
，这将为你解决它，

1728
01:15:56,210 --> 01:15:59,269
但是这个问题

1729
01:15:59,269 --> 01:16:00,199
我们在这里谈论的术语称为

1730
01:16:00,199 --> 01:16:02,150
谓词锁定是 能够做到这一点非常非常

1731
01:16:02,150 --> 01:16:04,010
昂贵，

1732
01:16:04,010 --> 01:16:05,329
事实上我认为没有任何系统能够真正

1733
01:16:05,329 --> 01:16:07,579
执行这种非常复杂的逻辑，

1734
01:16:07,579 --> 01:16:10,099
因为它非常复杂，我给了

1735
01:16:10,099 --> 01:16:11,510
你一个状态等于盖子的例子，

1736
01:16:11,510 --> 01:16:13,039
但我们实际上是在谈论 关于这是一个

1737
01:16:13,039 --> 01:16:14,210
多维问题，因为你

1738
01:16:14,210 --> 01:16:16,519
可以有任何任意复杂的

1739
01:16:16,519 --> 01:16:18,289
表达式，并且你想确保

1740
01:16:18,289 --> 01:16:20,840
你正在评估的表达式不会

1741
01:16:20,840 --> 01:16:22,429
与这个多维空间相交，

1742
01:16:22,429 --> 01:16:24,619
所以实现

1743
01:16:24,619 --> 01:16:28,880
大多数系统并不容易 不要那样做 是的

1744
01:16:28,880 --> 01:16:31,499
[音乐]

1745
01:16:31,499 --> 01:16:33,909
是的 所以你可以像表

1746
01:16:33,909 --> 01:16:44,289
级锁或页级锁一样获取是的 所以

1747
01:16:44,289 --> 01:16:45,789
你可以使用这些层次锁

1748
01:16:45,789 --> 01:16:47,349
这是一种绝对解决它

1749
01:16:47,349 --> 01:16:48,969
的方法 另一种解决它的方法是这个

1750
01:16:48,969 --> 01:16:49,989
谓词 锁定我正在

1751
01:16:49,989 --> 01:16:52,659
谈论哪个更通用，

1752
01:16:52,659 --> 01:16:55,480
还有另一个称为索引锁定，

1753
01:16:55,480 --> 01:16:57,039
所以如果我在系统上有一个索引，

1754
01:16:57,039 --> 01:16:58,570
假设我在状态属性上有一个索引，

1755
01:16:58,570 --> 01:17:01,210
我可以做的

1756
01:17:01,210 --> 01:17:04,389
是锁定 索引

1757
01:17:04,389 --> 01:17:07,329
中状态等于lid的插槽，因此任何

1758
01:17:07,329 --> 01:17:09,070
新插入都必须通过

1759
01:17:09,070 --> 01:17:10,630
索引，我进行更新他们无法

1760
01:17:10,630 --> 01:17:14,289
获得该锁，所以如果状态点亮甚至没有，这是另

1761
01:17:14,289 --> 01:17:16,480
一种解决它的方法

1762
01:17:16,480 --> 01:17:18,039
存在于索引中我

1763
01:17:18,039 --> 01:17:20,530
必须做的是获取

1764
01:17:20,530 --> 01:17:23,289
所谓的间隙锁，因此索引中的间隙我获取

1765
01:17:23,289 --> 01:17:25,780
该间隙的锁，以便如果另一个

1766
01:17:25,780 --> 01:17:27,280
插入尝试插入

1767
01:17:27,280 --> 01:17:29,499
状态等于该空间

1768
01:17:29,499 --> 01:17:33,539
中的lid  index 不允许这样做，

1769
01:17:33,539 --> 01:17:37,389
所以这 t 这是两种

1770
01:17:37,389 --> 01:17:44,019
基本上两种方法来做到这一点，所以

1771
01:17:44,019 --> 01:17:45,280
这基本上可以追溯到之前提出的观点

1772
01:17:45,280 --> 01:17:46,300
，如果

1773
01:17:46,300 --> 01:17:47,860
您没有索引并且没有谓词

1774
01:17:47,860 --> 01:17:50,349
锁，您可以通过锁定每个页面来做到这一点，

1775
01:17:50,349 --> 01:17:52,630
或者您可以 通过

1776
01:17:52,630 --> 01:17:55,809
锁定整个表或者是分层

1777
01:17:55,809 --> 01:17:56,230
锁来做到这一点，

1778
01:17:56,230 --> 01:17:59,559
所以我看到你知道解决这个问题的最后一种方法

1779
01:17:59,559 --> 01:18:00,880
是通过

1780
01:18:00,880 --> 01:18:03,329
在提交之前通过提交抱歉来重复扫描

1781
01:18:03,329 --> 01:18:05,739
所以我认为

1782
01:18:05,739 --> 01:18:07,090
最流行的系统

1783
01:18:07,090 --> 01:18:09,280
之一是 hecatomb 来自 Microsoft

1784
01:18:09,280 --> 01:18:10,659
所以基本上所有内容在你

1785
01:18:10,659 --> 01:18:11,469
提交之前你必须确保

1786
01:18:11,469 --> 01:18:14,619
你之前阅读的所有内容都发生

1787
01:18:14,619 --> 01:18:16,360
在你提交之前以确保可以看到

1788
01:18:16,360 --> 01:18:17,980
你有一致的阅读我认为我们

1789
01:18:17,980 --> 01:18:21,130
在最后一节是较弱的

1790
01:18:21,130 --> 01:18:22,570
隔离级别 也许我们会

1791
01:18:22,570 --> 01:18:27,460
在下一节课中讲到 好吧 好吧

1792
01:18:27,460 --> 01:18:29,849
那是

1793
01:18:30,639 --> 01:18:34,780
一台机器在他们身上 这是一个破碎的酒吧 被

1794
01:18:34,780 --> 01:18:35,830
压碎了孩子们

1795
01:18:35,830 --> 01:18:39,699
让演示中的奶牛 我会尝试

1796
01:18:39,699 --> 01:18:42,070
在我的系统中看到夜晚 我是 bl  esed

1797
01:18:42,070 --> 01:18:49,840
让我们去拿下一张好网将

1798
01:18:49,840 --> 01:18:52,119
是儿子 ricochet jelly 击中熟食店的

1799
01:18:52,119 --> 01:18:54,340
船 自然祝福你 说唱歌手

1800
01:18:54,340 --> 01:18:55,780
喜欢激光束 灌木丛中的球

1801
01:18:55,780 --> 01:18:58,179
什么都不说 就像国王 包裹

1802
01:18:58,179 --> 01:19:00,460
我们的瓶子 一个很好的同情

1803
01:19:00,460 --> 01:19:02,560
不想喝小马 - 你喝醉了，

1804
01:19:02,560 --> 01:19:05,260
你不能在赌注中掉下来不

1805
01:19:05,260 --> 01:19:08,760
知道你的手机可以敲蛋糕

