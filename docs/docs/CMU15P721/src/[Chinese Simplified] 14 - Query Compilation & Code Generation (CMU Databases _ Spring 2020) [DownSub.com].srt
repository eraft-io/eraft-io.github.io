1
00:00:01,300 --> 00:00:05,129
[音乐]

2
00:00:05,200 --> 00:00:05,930
[掌声]

3
00:00:05,930 --> 00:00:08,630
[音乐]

4
00:00:08,630 --> 00:00:10,020
[掌声]

5
00:00:10,020 --> 00:00:11,630
[音乐]

6
00:00:11,630 --> 00:00:15,269
让我们开始吧 编译是一个

7
00:00:15,269 --> 00:00:16,859
很棒的话题 有很多要讨论的

8
00:00:16,859 --> 00:00:20,430
好 所以这就是

9
00:00:20,430 --> 00:00:24,029
这里每个人的待办事项 项目

10
00:00:24,029 --> 00:00:24,720
检查站

11
00:00:24,720 --> 00:00:26,460
我想他是他会发布的 它在很大

12
00:00:26,460 --> 00:00:28,140
范围内 我认为它

13
00:00:28,140 --> 00:00:30,480
今天还没有发布 我们正在努力弄清楚我们正在

14
00:00:30,480 --> 00:00:32,340
寻找方法来

15
00:00:32,340 --> 00:00:34,559
完成并加快速度

16
00:00:34,559 --> 00:00:36,960
这不是什么明显的但就像当

17
00:00:36,960 --> 00:00:39,000
你提交这个它不会它 像

18
00:00:39,000 --> 00:00:41,160
clang格式和clanged ID一样运行，但它不会

19
00:00:41,160 --> 00:00:44,789
运行完整的linter，所以

20
00:00:44,789 --> 00:00:46,770
你要确保你自己

21
00:00:46,770 --> 00:00:49,590
运行它，因为当我们从它运行它时必须

22
00:00:49,590 --> 00:00:51,390
通过它，所以第一个检查点

23
00:00:51,390 --> 00:00:53,070
只是插入将 找出

24
00:00:53,070 --> 00:00:57,600
删除然后扫描键，然后

25
00:00:57,600 --> 00:00:59,309
这个必须是完全并发的，

26
00:00:59,309 --> 00:01:01,109
而这个他没有检查

27
00:01:01,109 --> 00:01:03,690
并发性，因为伟大的跳过只

28
00:01:03,690 --> 00:01:05,400
给你一个线程将

29
00:01:05,400 --> 00:01:07,619
在最后的最终分析中进行更详尽的测试，

30
00:01:07,619 --> 00:01:12,090
好的，然后 现在每周三

31
00:01:12,090 --> 00:01:14,610
上课 宣布了

32
00:01:14,610 --> 00:01:16,710
我们讨论的项目三是什么

33
00:01:16,710 --> 00:01:20,729
，我将提出一些

34
00:01:20,729 --> 00:01:21,960
你们可以看看的主题，当然

35
00:01:21,960 --> 00:01:23,790
我们已经讨论过一些事情，所以

36
00:01:23,790 --> 00:01:25,530
我们今天要讨论的是 Jemaine 或

37
00:01:25,530 --> 00:01:29,189
您可以探索的适用主题，但是

38
00:01:29,189 --> 00:01:31,110
然后在第

39
00:01:31,110 --> 00:01:34,799
一个星期一春假后的第一堂课上，我们将在

40
00:01:34,799 --> 00:01:36,390
课堂上进行演讲，每个小组

41
00:01:36,390 --> 00:01:37,680
都会出来花五分钟

42
00:01:37,680 --> 00:01:39,770
说嘿，这就是我们要做的事情，

43
00:01:39,770 --> 00:01:42,479
所以你至少应该我的意思是我意识到你

44
00:01:42,479 --> 00:01:43,829
停止了击败 B+ 树的法案，

45
00:01:43,829 --> 00:01:45,659
开始思考

46
00:01:45,659 --> 00:01:47,329
您实际上想要

47
00:01:47,329 --> 00:01:50,549
为项目 3 构建的内容是什么，好吧，如果

48
00:01:50,549 --> 00:01:53,399
您不确定潜在主题

49
00:01:53,399 --> 00:01:55,020
并想要进一步澄清，您

50
00:01:55,020 --> 00:01:56,280
知道我会 春假前后，我们

51
00:01:56,280 --> 00:02:01,170
可以满足必要的好吧，好吧，查询

52
00:02:01,170 --> 00:02:04,560
编译非常重要，它

53
00:02:04,560 --> 00:02:06,540
是我们的

54
00:02:06,540 --> 00:02:08,008
人今天在现代系统

55
00:02:08,008 --> 00:02:10,110
数据库系统中使用的主要技术之一，以获得最佳

56
00:02:10,110 --> 00:02:12,569
性能 你知道这就是为什么我们

57
00:02:12,569 --> 00:02:13,530
把整堂课都

58
00:02:13,530 --> 00:02:15,900
花在疾病上，所以我们将首先讨论

59
00:02:15,900 --> 00:02:17,550
一些背景，关于它是

60
00:02:17,550 --> 00:02:19,950
什么你知道什么你知道热电联产为什么我们

61
00:02:19,950 --> 00:02:20,970
实际上想要这样做做

62
00:02:20,970 --> 00:02:23,100
编译然后我们将讨论

63
00:02:23,100 --> 00:02:25,410
这两种技术

64
00:02:25,410 --> 00:02:27,150
转换的热电联产基本上是

65
00:02:27,150 --> 00:02:28,950
源编译的来源，然后我们将

66
00:02:28,950 --> 00:02:31,380
讨论使用 LLVM 的 JIT 编译，

67
00:02:31,380 --> 00:02:32,819
因为那在你们阅读的超级论文中，

68
00:02:32,819 --> 00:02:34,500
但这当然不是

69
00:02:34,500 --> 00:02:36,450
编译的唯一方法，所以我们将

70
00:02:36,450 --> 00:02:37,500
看看一些真实的 工作技术，

71
00:02:37,500 --> 00:02:40,170
包括弹出后图和我们

72
00:02:40,170 --> 00:02:42,120
自己的数据库系统，以及

73
00:02:42,120 --> 00:02:44,730
查看这些不同系统的令人信服的安静是什么样子的，所以上一课

74
00:02:44,730 --> 00:02:49,530


75
00:02:49,530 --> 00:02:51,360
或几节课之前我们一直在

76
00:02:51,360 --> 00:02:54,360
讨论如何让我们的

77
00:02:54,360 --> 00:02:57,150
系统达到 尽可能快地运行，我们

78
00:02:57,150 --> 00:03:00,300
说你知道我们可以

79
00:03:00,300 --> 00:03:03,510
这样做的方法是减少

80
00:03:03,510 --> 00:03:06,239
我们必须正确执行的指令数量，

81
00:03:06,239 --> 00:03:08,810
并且每个周期也获得更多指令，

82
00:03:08,810 --> 00:03:11,489
所以如果你st 艺术来谈论

83
00:03:11,489 --> 00:03:13,769
这是多么困难 这真的让你知道

84
00:03:13,769 --> 00:03:15,510
仅仅根据自己的指示 良好的加速

85
00:03:15,510 --> 00:03:18,660
这是餐巾纸计算的背后

86
00:03:18,660 --> 00:03:20,880


87
00:03:20,880 --> 00:03:23,040


88
00:03:23,040 --> 00:03:24,720


89
00:03:24,720 --> 00:03:26,910
在他们的

90
00:03:26,910 --> 00:03:29,700
系统中进行热电联产编译，它基本上是说，如果你

91
00:03:29,700 --> 00:03:31,519
想让你的数据速度提高 10 倍，

92
00:03:31,519 --> 00:03:35,549
那么你需要执行的指令减少 90%，

93
00:03:35,549 --> 00:03:38,640
这是可行的，这

94
00:03:38,640 --> 00:03:40,920
是你知道的，不仅你知道

95
00:03:40,920 --> 00:03:44,250
可能会转动编译优化标志

96
00:03:44,250 --> 00:03:45,660
来获得 你知道更好更好的

97
00:03:45,660 --> 00:03:48,959
二进制文件，但通过仔细重新设计

98
00:03:48,959 --> 00:03:51,030
数据库架构，我们可以实现

99
00:03:51,030 --> 00:03:53,070
这一点，但如果我们现在想要快一百倍，

100
00:03:53,070 --> 00:03:55,620
我们现在有 2 倍 X 99% 很少的

101
00:03:55,620 --> 00:03:57,269
指令，这开始变得

102
00:03:57,269 --> 00:04:01,170
非常困难，所以今天的

103
00:04:01,170 --> 00:04:03,000
课程 然后是周三的课程，

104
00:04:03,000 --> 00:04:04,290
然后是春假之后，当

105
00:04:04,290 --> 00:04:05,970
我们开始进行矢量化时，这些是

106
00:04:05,970 --> 00:04:07,230
我们将要使用的技术，以

107
00:04:07,230 --> 00:04:08,519
允许我们执行一些指令

108
00:04:08,519 --> 00:04:10,590
吸引做相同数量的工作，这样我们

109
00:04:10,590 --> 00:04:13,769
就可以尝试实现这 100 倍的正确率，

110
00:04:13,769 --> 00:04:15,600
因为英特尔不再提高

111
00:04:15,600 --> 00:04:16,978
时钟速度了，他们给我们提供了

112
00:04:16,978 --> 00:04:19,168
更广泛的无缝寄存器更专业的

113
00:04:19,168 --> 00:04:20,820
指令还有更多的东西英特尔

114
00:04:20,820 --> 00:04:22,108
今天中午会给我们 时钟速度，

115
00:04:22,108 --> 00:04:23,610
所以我们有设计器系统

116
00:04:23,610 --> 00:04:26,490
来尝试实现这一点，并且 GCC 中不会有

117
00:04:26,490 --> 00:04:27,480


118
00:04:27,480 --> 00:04:30,690
像 Oh 100 这样的魔法，我们可以

119
00:04:30,690 --> 00:04:33,810
用它来再次发生这种情况是我们，

120
00:04:33,810 --> 00:04:36,630
因为数据系统开发人员必须

121
00:04:36,630 --> 00:04:38,550
设计 系统和 20

122
00:04:38,550 --> 00:04:39,720
人再次支付我们很多钱来做这件事

123
00:04:39,720 --> 00:04:41,970
很好所以这就是为什么我们

124
00:04:41,970 --> 00:04:43,860
要进行代码专业化或查询

125
00:04:43,860 --> 00:04:47,250
编译所以代码专业化的想法是

126
00:04:47,250 --> 00:04:49,470


127
00:04:49,470 --> 00:04:51,750
在我们的数据库

128
00:04:51,750 --> 00:04:54,180
系统中拥有通用代码而不是 处理查询或

129
00:04:54,180 --> 00:04:57,240
在我们的系统中执行我们想要的任何任务 我们将

130
00:04:57,240 --> 00:05:00,090
生成特定于

131
00:05:00,090 --> 00:05:03,090
我们正在尝试处理或完成的一项任务的代码

132
00:05:03,090 --> 00:05:05,730
，对于我们今天的目的而言，它

133
00:05:05,730 --> 00:05:06,930
始终是一个 查询，所以我们有一个

134
00:05:06,930 --> 00:05:08,790
查询和 Retin，而不是

135
00:05:08,790 --> 00:05:10,620
通过通用系统运行它，然后我们将

136
00:05:10,620 --> 00:05:14,340
生成硬编码或

137
00:05:14,340 --> 00:05:17,940
烘焙的代码，只是为了执行该查询，

138
00:05:17,940 --> 00:05:20,280
这是为什么这对性能更好的原因

139
00:05:20,280 --> 00:05:22,590
，因为在

140
00:05:22,590 --> 00:05:24,480
通用系统 你将拥有

141
00:05:24,480 --> 00:05:26,130
所有这些间接我们将拥有

142
00:05:26,130 --> 00:05:28,080
所有这些 if 原因或 switch 语句

143
00:05:28,080 --> 00:05:30,630
来处理所有可能执行的几乎不可能的

144
00:05:30,630 --> 00:05:33,210
数据类型或操作数或谓词或

145
00:05:33,210 --> 00:05:34,740
聚合 你为什么

146
00:05:34,740 --> 00:05:36,810
要处理查询，这意味着

147
00:05:36,810 --> 00:05:38,670
当我查看每一个元组

148
00:05:38,670 --> 00:05:40,740
并称我为一个很棒的函数时，我有一个

149
00:05:40,740 --> 00:05:42,150
switch 语句，它说如果我的数据

150
00:05:42,150 --> 00:05:43,950
类型是这样的，那么我的数据类型是

151
00:05:43,950 --> 00:05:46,260
那样的，我们不会避免所有我们

152
00:05:46,260 --> 00:05:47,880
将其分解为 只是

153
00:05:47,880 --> 00:05:49,410
为了执行该查询我需要的确切指令

154
00:05:49,410 --> 00:05:53,220
所以这会很

155
00:05:53,220 --> 00:05:57,510
棘手，这并不是说人们在

156
00:05:57,510 --> 00:05:59,070
编写通用数据

157
00:05:59,070 --> 00:06:02,100
系统代码时他们不会这样做只是

158
00:06:02,100 --> 00:06:04,200
因为 因为他们很笨，他们这样

159
00:06:04,200 --> 00:06:05,880
做主要是出于软件工程的原因，

160
00:06:05,880 --> 00:06:07,320
你这样做是为了让代码可以

161
00:06:07,320 --> 00:06:08,940
重用，所以你不必这样做

162
00:06:08,940 --> 00:06:10,620
你知道

163
00:06:10,620 --> 00:06:12,120
一遍又一遍的重复操作你知道添加两个数字

164
00:06:12,120 --> 00:06:16,260
我们' 重新添加两个浮点数，我们还

165
00:06:16,260 --> 00:06:18,060
以一种更易于人们维护和支持的方式编写代码，

166
00:06:18,060 --> 00:06:21,900


167
00:06:21,900 --> 00:06:23,190
但问题将是正如我之前

168
00:06:23,190 --> 00:06:24,990
所说的那样，我们编写代码的方式

169
00:06:24,990 --> 00:06:26,730
使人们更容易理解我们实际上

170
00:06:26,730 --> 00:06:28,730
将成为 为 CPU 实际编写代码的最糟糕的方式

171
00:06:28,730 --> 00:06:33,180
所以我将

172
00:06:33,180 --> 00:06:34,380
展示一堆示例 我将

173
00:06:34,380 --> 00:06:37,380
使用这个简单的三表模式 ABC

174
00:06:37,380 --> 00:06:40,350
写一个 B 有主键整数和

175
00:06:40,350 --> 00:06:41,220
一些值

176
00:06:41,220 --> 00:06:43,920
，然后看到只需要 外键

177
00:06:43,920 --> 00:06:45,630
引用 a 处

178
00:06:45,630 --> 00:06:47,760
的主键以及主键和 B 所以我展示了

179
00:06:47,760 --> 00:06:49,620
一堆示例，在

180
00:06:49,620 --> 00:06:52,590
这个表上的外键上执行三个海湾连接，所以现在让我们

181
00:06:52,590 --> 00:06:54,570
看看我们如何在这里处理这个查询

182
00:06:54,570 --> 00:06:56,790
，一个三向连接 使用嵌套

183
00:06:56,790 --> 00:06:59,970
查询学习酯聚合

184
00:06:59,970 --> 00:07:02,040
使用解释模型进行转换

185
00:07:02,040 --> 00:07:04,650
我们之前讨论过的迭代器模型，

186
00:07:04,650 --> 00:07:06,840
所以我们在这个内部查询中有一个组 I 或

187
00:07:06,840 --> 00:07:08,880
聚合或组 I 用于 B

188
00:07:08,880 --> 00:07:10,950
，

189
00:07:10,950 --> 00:07:14,490
然后我们将在 B 和 C 上进行连接，所以

190
00:07:14,490 --> 00:07:16,260
查询计划看起来像这样，

191
00:07:16,260 --> 00:07:18,690
这是为了我们的目的，这

192
00:07:18,690 --> 00:07:20,130
只是逻辑计划，我们没有说

193
00:07:20,130 --> 00:07:22,740
联合专辑实际上是什么，但我们

194
00:07:22,740 --> 00:07:23,970
可以假设它是一个哈希表，

195
00:07:23,970 --> 00:07:25,320
我们没有说我们如何 做

196
00:07:25,320 --> 00:07:27,090
聚合假设它也是一个哈希

197
00:07:27,090 --> 00:07:31,530
表，所以如果我们回过头来使用

198
00:07:31,530 --> 00:07:33,740
我们在上一节课看到的 for 循环迭代器模型方法，

199
00:07:33,740 --> 00:07:36,600
我们执行这个

200
00:07:36,600 --> 00:07:38,430
查询的方式只是一堆 for

201
00:07:38,430 --> 00:07:40,560
循环，它们迭代一个操作符

202
00:07:40,560 --> 00:07:43,440
在这种情况下，

203
00:07:43,440 --> 00:07:45,090
我们正在扫描 B 中的每个元组的目标输入，

204
00:07:45,090 --> 00:07:47,130
然后我们将其推入下一个

205
00:07:47,130 --> 00:07:48,840
运算符以进行过滤，这

206
00:07:48,840 --> 00:07:52,230
将推入以进行正确的连接，因此

207
00:07:52,230 --> 00:07:54,360
再次这会很慢 一个敌人的

208
00:07:54,360 --> 00:07:56,010
数据库它仍然会因为置换而变慢

209
00:07:56,010 --> 00:07:58,590
d 数据库，因为我们正在

210
00:07:58,590 --> 00:08:00,360
复制很多人知道从一个到下一个的所有数据

211
00:08:00,360 --> 00:08:02,430
是的我们可以组合这些但是

212
00:08:02,430 --> 00:08:04,260
你知道我们有所有这些下一个

213
00:08:04,260 --> 00:08:06,090
调用和这些 MIT 调用，就像所有这些

214
00:08:06,090 --> 00:08:07,680
函数调用一样

215
00:08:07,680 --> 00:08:09,930
昂贵 我们是对的，我们必须正确地做到这

216
00:08:09,930 --> 00:08:11,090
一点我们有这个通用的

217
00:08:11,090 --> 00:08:13,050
评估或值八个谓词

218
00:08:13,050 --> 00:08:16,140
函数，因为我们

219
00:08:16,140 --> 00:08:17,310
实际上并不知道谓词实际上是什么

220
00:08:17,310 --> 00:08:18,840
样子我们只知道我们

221
00:08:18,840 --> 00:08:20,310
将拥有这种表达式的源代码

222
00:08:20,310 --> 00:08:21,720
我们要评估的树

223
00:08:21,720 --> 00:08:23,940
和这里的所有代码 执行

224
00:08:23,940 --> 00:08:27,060
下一个迭代

225
00:08:27,060 --> 00:08:30,120
来自子级的每个元组 它只是调用

226
00:08:30,120 --> 00:08:32,219
这个函数 它没有做

227
00:08:32,219 --> 00:08:33,450
任何特别的事情 它没有做任何事情 没有做任何

228
00:08:33,450 --> 00:08:36,900
事情所以再次有很多

229
00:08:36,900 --> 00:08:38,250
来自所有这些下一个调用的开销，

230
00:08:38,250 --> 00:08:39,929
因为我们可以有

231
00:08:39,929 --> 00:08:41,940
不同类型的间接，但

232
00:08:41,940 --> 00:08:43,289
表达式本身也会很

233
00:08:43,289 --> 00:08:45,570
昂贵，所以我们只

234
00:08:45,570 --> 00:08:47,550
在这里使用 B 点的内部部分

235
00:08:47,550 --> 00:08:49,860
Val 等于问号，意味着它是一个

236
00:08:49,860 --> 00:08:51,270
输入参数，这是一个准备好的

237
00:08:51,270 --> 00:08:52,890
语句，所以在运行时有人会

238
00:08:52,890 --> 00:08:54,290
传递这个参数的值

239
00:08:54,290 --> 00:08:56,630
，然后我们将向它添加一个值，所以

240
00:08:56,630 --> 00:08:58,880
通常你和你代表

241
00:08:58,880 --> 00:09:01,310
这些谓词是通过这些

242
00:09:01,310 --> 00:09:03,290
表达式树和

243
00:09:03,290 --> 00:09:05,449
思考这个问题的方式是，日常

244
00:09:05,449 --> 00:09:07,790
系统将进入根并调用

245
00:09:07,790 --> 00:09:09,380
该运算符的任何内容并说嘿我

246
00:09:09,380 --> 00:09:11,060
想从根计算这个表达式树

247
00:09:11,060 --> 00:09:12,740
然后

248
00:09:12,740 --> 00:09:14,630
它现在必须向下遍历 进入树并

249
00:09:14,630 --> 00:09:16,519
评估它的所有两个孩子并开始

250
00:09:16,519 --> 00:09:19,670
向上推结果所以说我们来到

251
00:09:19,670 --> 00:09:21,529
这里我们看看相等的运算符我们

252
00:09:21,529 --> 00:09:23,209
开始去左孩子我们看到

253
00:09:23,209 --> 00:09:24,500
这里的表达式是

254
00:09:24,500 --> 00:09:26,899
P点Val上的元组属性所以我们看看

255
00:09:26,899 --> 00:09:28,130
在我们正在查看的当前小管上，

256
00:09:28,130 --> 00:09:29,720
因为我们正在调用它，因为我们在扫描时知道

257
00:09:29,720 --> 00:09:31,160
每个元组的值 8 谓词函数

258
00:09:31,160 --> 00:09:33,589
所以我们说

259
00:09:33,589 --> 00:09:35,360
好的我想要 B 点 Val 所以现在我要

260
00:09:35,360 --> 00:09:37,430
看看我的表 e 模式并说

261
00:09:37,430 --> 00:09:40,370
好吧，Bao 属性是第二

262
00:09:40,370 --> 00:09:42,110
个或第二个属性，所以我需要

263
00:09:42,110 --> 00:09:43,490
知道如何跳过此处获得

264
00:09:43,490 --> 00:09:45,230
一千，然后我将其作为

265
00:09:45,230 --> 00:09:47,240
我的输出现在我必须首先归结到

266
00:09:47,240 --> 00:09:49,190
这个 树的一侧说我

267
00:09:49,190 --> 00:09:51,350
想要参数 0 所以我去查找我的

268
00:09:51,350 --> 00:09:53,569
参数数组找到第一个，

269
00:09:53,569 --> 00:09:56,240
那是 99 所以我到那里然后这

270
00:09:56,240 --> 00:09:57,889
只是评估它常量所以我只是

271
00:09:57,889 --> 00:09:59,690
把它推到这里把这些加

272
00:09:59,690 --> 00:10:01,880
在一起 我得到一千然后现在我可以

273
00:10:01,880 --> 00:10:05,839
做我的我可以做我的比较并且

274
00:10:05,839 --> 00:10:08,209
结果是真的所以我再次

275
00:10:08,209 --> 00:10:10,100
为

276
00:10:10,100 --> 00:10:11,839
我评估的每个元组遍历这棵树所以有十亿个

277
00:10:11,839 --> 00:10:15,199
元组我正在制作十亿次你

278
00:10:15,199 --> 00:10:18,290
知道什么 对于所有

279
00:10:18,290 --> 00:10:19,430
这些不同的表达式，你知道

280
00:10:19,430 --> 00:10:21,529
函数调用的跳转，我们这样做

281
00:10:21,529 --> 00:10:23,690
是因为作为人类，我们很

282
00:10:23,690 --> 00:10:25,819
容易推理如何

283
00:10:25,819 --> 00:10:27,620
通过这棵树来表示 where 子句，但这

284
00:10:27,620 --> 00:10:29,360
又会很慢，因为你

285
00:10:29,360 --> 00:10:32,420
知道所有 这个间接 部分所以

286
00:10:32,420 --> 00:10:34,550
这又是 oida

287
00:10:34,550 --> 00:10:37,310
ng 的这两件事，即

288
00:10:37,310 --> 00:10:38,990
查询计划的解释以处理

289
00:10:38,990 --> 00:10:40,699
不同运算符的所有方向

290
00:10:40,699 --> 00:10:42,860
以及谓词，因此我们

291
00:10:42,860 --> 00:10:44,779
在这些运算符中的值 8

292
00:10:44,779 --> 00:10:47,110
是 我们将尝试

293
00:10:47,110 --> 00:10:51,730
通过 Co 专业化摆脱的主要两件事

294
00:10:53,019 --> 00:10:55,069
所以好吧，这个想法是，

295
00:10:55,069 --> 00:10:58,160
无论何时我们的数据库中有 CPU 密集型任务，

296
00:10:58,160 --> 00:11:00,860
我们都希望将其转换

297
00:11:00,860 --> 00:11:05,269
或编译成机器代码，

298
00:11:05,269 --> 00:11:06,949
然后我们可以 可以直接散发，所以它就像

299
00:11:06,949 --> 00:11:08,060
再次

300
00:11:08,060 --> 00:11:09,290
滚动开关恶魔会滚动

301
00:11:09,290 --> 00:11:11,210
如果你知道

302
00:11:11,210 --> 00:11:12,380
检查谓词评估为真的地方的子句

303
00:11:12,380 --> 00:11:14,570
并且它归结为我们在方向上进行最少的查找而将其剥离为

304
00:11:14,570 --> 00:11:17,780
正是查询想要的，

305
00:11:17,780 --> 00:11:20,780
所以我 '

306
00:11:20,780 --> 00:11:22,850
已经展示了如何为访问

307
00:11:22,850 --> 00:11:24,860
方法或评估谓词或

308
00:11:24,860 --> 00:11:27,290
操作执行执行此操作我们也可以对

309
00:11:27,290 --> 00:11:29,060
存储过程或准备好的语句执行此操作，

310
00:11:29,060 --> 00:11:31,430
并使用逻辑上诉续集，

311
00:11:31,430 --> 00:11:35,300
然后我们可以 c 仅转换为机器代码

312
00:11:35,300 --> 00:11:37,430
Oracle 确实执行此谓词

313
00:11:37,430 --> 00:11:39,200
评估 我们还解决

314
00:11:39,200 --> 00:11:40,850
了系统的其他部分，如日志操作，

315
00:11:40,850 --> 00:11:42,950
如恢复时，如果我必须重放这些日志

316
00:11:42,950 --> 00:11:44,690
记录，而不是我查看

317
00:11:44,690 --> 00:11:46,670
模式，然后间接

318
00:11:46,670 --> 00:11:48,890
说哦，我的模式，我的 日志记录具有这些

319
00:11:48,890 --> 00:11:51,230
类型和这些值，因此我

320
00:11:51,230 --> 00:11:52,670
知道如何将它们应用到我

321
00:11:52,670 --> 00:11:55,190
可以编译或指导的数据库中，但是我已经

322
00:11:55,190 --> 00:11:58,070
应用了 Co 专业化方法来

323
00:11:58,070 --> 00:12:00,560
加快恢复工作速度没有戴维森实际上

324
00:12:00,560 --> 00:12:02,900
这样做了这个谓词评估

325
00:12:02,900 --> 00:12:04,700
可能是 最常见的紧随其后

326
00:12:04,700 --> 00:12:06,530
的是帕累托访问方法操作性

327
00:12:06,530 --> 00:12:08,480
挤压，然后只有少数

328
00:12:08,480 --> 00:12:10,190
数字系统真正做到这一点，

329
00:12:10,190 --> 00:12:11,630
这实际上是

330
00:12:11,630 --> 00:12:15,470
我们在自己的系统中探索的东西，所以我之前已经

331
00:12:15,470 --> 00:12:16,610
说过了，但是我们为什么要这样做

332
00:12:16,610 --> 00:12:19,040
这很好，我们可以做到这一点，因为

333
00:12:19,040 --> 00:12:20,720
我们提前知道我们数据库中的属性是什么，

334
00:12:20,720 --> 00:12:23,030
以及

335
00:12:23,030 --> 00:12:24,290
您可以声明模式的关系模型，

336
00:12:24,290 --> 00:12:26,360
所以它 不像我们正在查看

337
00:12:26,360 --> 00:12:28,610
任意 JSON 字段或任意 CSV

338
00:12:28,610 --> 00:12:29,060
文件

339
00:12:29,060 --> 00:12:31,370
我们确切地知道架构是什么

340
00:12:31,370 --> 00:12:33,950
样的 我们确切地知道

341
00:12:33,950 --> 00:12:36,050
数据的大小 必须

342
00:12:36,050 --> 00:12:37,310
区别对待 varchars 但至少我们

343
00:12:37,310 --> 00:12:39,320
知道我们有一个固定的 指向

344
00:12:39,320 --> 00:12:41,390
那个大臂的大小指针，因此我们可以

345
00:12:41,390 --> 00:12:43,400
而不是让所有这些函数

346
00:12:43,400 --> 00:12:45,110
调用进行查找并说你知道

347
00:12:45,110 --> 00:12:46,850
给我你知道我想要

348
00:12:46,850 --> 00:12:48,530
这个元组的这个属性，因此

349
00:12:48,530 --> 00:12:49,910
我跳到这个知道

350
00:12:49,910 --> 00:12:51,380
如何进行算术的函数中 找到

351
00:12:51,380 --> 00:12:53,660
我正在寻找的值我猜直接

352
00:12:53,660 --> 00:12:57,260
在地址数学中去

353
00:12:57,260 --> 00:13:00,440
获取我正在寻找的数据同样我们

354
00:13:00,440 --> 00:13:01,820
所有的谓词都是提前知道的，

355
00:13:01,820 --> 00:13:03,320
因为我们得到了 where

356
00:13:03,320 --> 00:13:05,570
子句或我们' 重新

357
00:13:05,570 --> 00:13:07,190
给出我们投影列表中的任何内容，因此我们

358
00:13:07,190 --> 00:13:10,010
确切地知道如何然后而不是将其

359
00:13:10,010 --> 00:13:11,450
表示为树，我们可以

360
00:13:11,450 --> 00:13:14,810
准确地表示为

361
00:13:14,810 --> 00:13:15,770
您知道我们

362
00:13:15,770 --> 00:13:18,020
实际上试图应用的谓词，然后

363
00:13:18,020 --> 00:13:19,520
同样我们w  ant 摆脱

364
00:13:19,520 --> 00:13:21,800
我们在循环内部的所有函数调用

365
00:13:21,800 --> 00:13:23,390
，这样我们就有了这个紧密的内核，

366
00:13:23,390 --> 00:13:25,010
然后我们不会在其中做任何分支，

367
00:13:25,010 --> 00:13:27,290
我们一遍又一遍地快速迭代

368
00:13:27,290 --> 00:13:28,580
，这

369
00:13:28,580 --> 00:13:30,350
从编译器中获得了一些好处 因为你

370
00:13:30,350 --> 00:13:32,300
可以做一些展开，在某些情况下

371
00:13:32,300 --> 00:13:34,100
它可以做一些自动矢量化

372
00:13:34,100 --> 00:13:36,290
，我们将在周三介绍，

373
00:13:36,290 --> 00:13:39,650
好的，所以在

374
00:13:39,650 --> 00:13:41,120
DAT 的高层，我们现在谈论的系统

375
00:13:41,120 --> 00:13:42,620
看起来像这样 所以我之前没有

376
00:13:42,620 --> 00:13:43,760
分享过这张图片，但这

377
00:13:43,760 --> 00:13:45,260
基本上是一个真正的

378
00:13:45,260 --> 00:13:47,750
数据库系统中的管道，当查询出现时，

379
00:13:47,750 --> 00:13:49,580
所以说这里有一个网络层

380
00:13:49,580 --> 00:13:51,350
在续集查询出现第一

381
00:13:51,350 --> 00:13:53,150
件事，我们要解析续集，然后从

382
00:13:53,150 --> 00:13:54,500
部分续集我们得到一个抽象

383
00:13:54,500 --> 00:13:56,810
语法树，这只是像

384
00:13:56,810 --> 00:13:58,970
通过

385
00:13:58,970 --> 00:14:00,850
Siebel 本身内部的所有字符串选择名称的标记，

386
00:14:00,850 --> 00:14:03,320
然后我们将它运行到我们的活页夹中，

387
00:14:03,320 --> 00:14:05,150
活页夹在目录中进行查找以

388
00:14:05,150 --> 00:14:07,790
替换 th

389
00:14:07,790 --> 00:14:09,230
数据库中对象名称的

390
00:14:09,230 --> 00:14:11,870


391
00:14:11,870 --> 00:14:14,480
字符串标记，带有内部

392
00:14:14,480 --> 00:14:16,340


393
00:14:16,340 --> 00:14:18,620


394
00:14:18,620 --> 00:14:20,570


395
00:14:20,570 --> 00:14:21,740
标识符 表，这里有一个内部

396
00:14:21,740 --> 00:14:23,510
标识符，让您将来可以更快地找到它

397
00:14:23,510 --> 00:14:26,060
，然后您

398
00:14:26,060 --> 00:14:29,060
现在将这个带注释的 ast 传递到我们的

399
00:14:29,060 --> 00:14:30,860
查询优化器中，然后它将

400
00:14:30,860 --> 00:14:33,410
生成一个物理计划，但

401
00:14:33,410 --> 00:14:34,850
我们会看到更多的步骤 这

402
00:14:34,850 --> 00:14:36,440
在本学期晚些时候，但就我们今天的目的而言

403
00:14:36,440 --> 00:14:37,760
，我们只关心

404
00:14:37,760 --> 00:14:39,410
优化器生成一个物理计划

405
00:14:39,410 --> 00:14:41,870
，然后我们现在将其提供给某些

406
00:14:41,870 --> 00:14:45,140
编译器或 trance 传单或有

407
00:14:45,140 --> 00:14:46,490
说服力的引擎，无论您想

408
00:14:46,490 --> 00:14:48,200
怎么称呼它 物理

409
00:14:48,200 --> 00:14:50,060
计划将是那个

410
00:14:50,060 --> 00:14:52,220
运算符树的计划，然后它会

411
00:14:52,220 --> 00:14:54,830
吐出某种本机代码或字节

412
00:14:54,830 --> 00:14:57,350
码，然后我们可以正确地解释它们，

413
00:14:57,350 --> 00:14:59,240
所以现在的想法是我们 采取

414
00:14:59,240 --> 00:15:00,590
我们从中获得的物理计划

415
00:15:00,590 --> 00:15:02,990
，我们将其转换为源代码或

416
00:15:02,990 --> 00:15:04,880
本机代码，这些代码或本机代码完全

417
00:15:04,880 --> 00:15:06,650
可以执行该查询想要执行的操作，而无需任何

418
00:15:06,650 --> 00:15:07,690
间接访问

419
00:15:07,690 --> 00:15:12,140


420
00:15:12,140 --> 00:15:13,670


421
00:15:13,670 --> 00:15:14,810
这

422
00:15:14,810 --> 00:15:16,040
实际上来自这件事

423
00:15:16,040 --> 00:15:17,420
可以根据

424
00:15:17,420 --> 00:15:19,580
我们今天将讨论的不同方法而有所

425
00:15:19,580 --> 00:15:22,790
不同 所以我也说的一件事

426
00:15:22,790 --> 00:15:25,400
就像在我们

427
00:15:25,400 --> 00:15:28,490
将实际

428
00:15:28,490 --> 00:15:31,190
编译物理计划的情况下 成类似机器

429
00:15:31,190 --> 00:15:33,110
代码，然后我们可以链接你知道或

430
00:15:33,110 --> 00:15:35,230
在饱和的系统进程中执行，

431
00:15:35,230 --> 00:15:38,270
因为我们就像我们作为可用的数据库一样

432
00:15:38,270 --> 00:15:40,010
，在编写

433
00:15:40,010 --> 00:15:42,320
这个翻译步骤的错误我们不必

434
00:15:42,320 --> 00:15:44,270
有任何安全问题，因为它

435
00:15:44,270 --> 00:15:46,040
不是 就像我们从用户那里获取任意 C 代码

436
00:15:46,040 --> 00:15:47,900
并在我们的

437
00:15:47,900 --> 00:15:49,730
数据系统中运行一样，这将是愚蠢

438
00:15:49,730 --> 00:15:52,190
的，因为我们控制了这一步，所以我们

439
00:15:52,190 --> 00:15:53,870
不必做额外的安全检查来

440
00:15:53,870 --> 00:15:55,580
确保 l 就像我们不会有像

441
00:15:55,580 --> 00:15:57,410
缓冲区溢出或恶意代码之类

442
00:15:57,410 --> 00:15:58,910
的东西，这

443
00:15:58,910 --> 00:16:00,380
是 davison 开发人员会吐出的其他代码，

444
00:16:00,380 --> 00:16:03,110
所以我们可以假设它是消毒的，除非

445
00:16:03,110 --> 00:16:04,700
你知道内部有人试图

446
00:16:04,700 --> 00:16:06,680
把我们打倒 可以假设

447
00:16:06,680 --> 00:16:07,790
这对我们直接

448
00:16:07,790 --> 00:16:09,529
在我们的数据库进程中运行是安全的，我们

449
00:16:09,529 --> 00:16:13,370
根本不需要沙箱它，当我们谈论 UDS 时会看到

450
00:16:13,370 --> 00:16:15,260
像在 Oracle 等一些

451
00:16:15,260 --> 00:16:18,050
商业系统中一样，

452
00:16:18,050 --> 00:16:21,680
例如您可以在其中编写 UDS  NC

453
00:16:21,680 --> 00:16:23,060
总是很容易 超级危险 因为你

454
00:16:23,060 --> 00:16:25,790
可以跳转到任何地址库 呃你

455
00:16:25,790 --> 00:16:27,589
在你的过程中知道所以在这种情况下他们会

456
00:16:27,589 --> 00:16:29,779
分叉一个沙箱并在那里运行它所以

457
00:16:29,779 --> 00:16:31,070
你不能伤害真正的数据库系统

458
00:16:31,070 --> 00:16:32,600
但再次在我们的代码中 我们不

459
00:16:32,600 --> 00:16:45,470
担心这个是的问题是我怎么

460
00:16:45,470 --> 00:16:48,200
知道如果我有全局数据

461
00:16:48,200 --> 00:16:49,970
结构我怎么知道全局

462
00:16:49,970 --> 00:16:52,510
数据结构在编译代码中

463
00:16:52,510 --> 00:16:57,170
的位置编译代码可以调用

464
00:16:57,170 --> 00:16:59,780
它会链接的任何东西 与

465
00:16:59,780 --> 00:17:01,550
任何运行的东西一起 使用 setter 数据系统，所以

466
00:17:01,550 --> 00:17:04,550
你不会想要拥有它，就像你

467
00:17:04,550 --> 00:17:07,130
知道有这个任意内存地址

468
00:17:07,130 --> 00:17:09,020
，它有你想要的对象，

469
00:17:09,020 --> 00:17:10,490
你有办法链接它并说

470
00:17:10,490 --> 00:17:12,079
这是我可以再次调用的函数

471
00:17:12,079 --> 00:17:13,400
给我访问

472
00:17:13,400 --> 00:17:15,650
对象的权限，我可以做我想做

473
00:17:15,650 --> 00:17:17,329
的事情是的，这就像

474
00:17:17,329 --> 00:17:19,400
他老板的仲裁一样，就像我可以将

475
00:17:19,400 --> 00:17:21,650
它与现有库链接起来并

476
00:17:21,650 --> 00:17:23,270
能够唤起该库它的工作

477
00:17:23,270 --> 00:17:25,609
方式相同 Linux 的 avi 或

478
00:17:25,609 --> 00:17:27,020
您所做的任何属性系统

479
00:17:27,020 --> 00:17:31,310
都可以为您处理所有这些，

480
00:17:31,310 --> 00:17:32,720
所以有两种方法，即

481
00:17:32,720 --> 00:17:34,970
转译和 JIT

482
00:17:34,970 --> 00:17:37,760
编译，因此翻译也称其为

483
00:17:37,760 --> 00:17:40,370
源代码到源代码编译，这里的想法

484
00:17:40,370 --> 00:17:42,020


485
00:17:42,020 --> 00:17:44,570
是系统将拥有专门代码的那一天

486
00:17:44,570 --> 00:17:47,810
承认新的源代码，所以就像它

487
00:17:47,810 --> 00:17:50,440
会有 C++ 代码吐出 C++ 代码

488
00:17:50,440 --> 00:17:53,300
然后你然后你

489
00:17:53,300 --> 00:17:54,800
通过一个常规的编译器链接运行那些新的源代码

490
00:17:54,800 --> 00:17:57,350
，然后

491
00:17:57,350 --> 00:17:59,030
运行那个和 t 那是你的

492
00:17:59,030 --> 00:18:00,920
数据库，那是你的查询，你

493
00:18:00,920 --> 00:18:03,890
会正确地执行另一篇文章

494
00:18:03,890 --> 00:18:06,500
是一个编译，而不是

495
00:18:06,500 --> 00:18:08,420
生成一个你知道的直接就像你

496
00:18:08,420 --> 00:18:10,340
知道更高级别的源代码我们

497
00:18:10,340 --> 00:18:12,110
要生成这个低级别的我

498
00:18:12,110 --> 00:18:14,300
或中间表示的

499
00:18:14,300 --> 00:18:17,300
东西喜欢 LLVM ir 或 JVM

500
00:18:17,300 --> 00:18:19,520
字节码我们将直接 MIT

501
00:18:19,520 --> 00:18:22,460
然后我们可以

502
00:18:22,460 --> 00:18:23,570
在我们的数据中调用它最近你可以

503
00:18:23,570 --> 00:18:26,480
编译它或解释它所以我有一个

504
00:18:26,480 --> 00:18:28,160
高级别的 最终结果仍然

505
00:18:28,160 --> 00:18:30,080
是相同的，我们将采用我们的

506
00:18:30,080 --> 00:18:33,010
物理查询计划并生成

507
00:18:33,010 --> 00:18:36,170
可执行代码，您知道这些代码

508
00:18:36,170 --> 00:18:40,730
仅适用于该查询计划，无论我们这样

509
00:18:40,730 --> 00:18:43,430
做是因为我们首先生成您知道

510
00:18:43,430 --> 00:18:45,830
C++ 代码还是生成此代码 小我

511
00:18:45,830 --> 00:18:49,880
我们的第一个，

512
00:18:49,880 --> 00:18:51,580
这两者之间的编译时间会有所不同，

513
00:18:51,580 --> 00:18:53,480
而且软件工程也

514
00:18:53,480 --> 00:18:55,790
有所不同，但最终它

515
00:18:55,790 --> 00:18:57,350
仍然是同一件事，我的意思是这

516
00:18:57,350 --> 00:19:00,020
不是解释或拥有 这些

517
00:19:00,020 --> 00:19:03,050
针对不同

518
00:19:03,050 --> 00:19:04,040
类型间接的不同查找我们可以

519
00:19:04,040 --> 00:19:06,740
处理任意数据类型，

520
00:19:06,740 --> 00:19:08,960
我们正在生成的查询计划或

521
00:19:08,960 --> 00:19:10,550
来自编译器的查询计划仅

522
00:19:10,550 --> 00:19:13,820
针对该查询进行烘焙，所以我们将

523
00:19:13,820 --> 00:19:19,310
通过这些查询 一个

524
00:19:19,310 --> 00:19:22,370
是现代最早的数据库系统

525
00:19:22,370 --> 00:19:23,990
之一，我将解释当

526
00:19:23,990 --> 00:19:25,670
我们谈论系统时

527
00:19:25,670 --> 00:19:26,960
，现代第一个

528
00:19:26,960 --> 00:19:28,430
进行热电联产的数据系统

529
00:19:28,430 --> 00:19:31,810
是大学外被称为高 Q 的东西 Edinboro

530
00:19:31,810 --> 00:19:34,040
，就像我说的

531
00:19:34,040 --> 00:19:35,210
，对于优化器提供的给定查询计划，

532
00:19:35,210 --> 00:19:38,500
它会写出一个

533
00:19:38,500 --> 00:19:42,260
C+ 代码来实现该查询的 X 立方计划

534
00:19:42,260 --> 00:19:45,140
，我们的所有谓词

535
00:19:45,140 --> 00:19:46,310
和所有类型转换都

536
00:19:46,310 --> 00:19:48,860
完全准确地烘焙

537
00:19:48,860 --> 00:19:51,770
根据该给定表的模式进入查询计划

538
00:19:51,770 --> 00:19:54,440
，然后可能在

539
00:19:54,440 --> 00:19:55,550
GCC 上

540
00:19:55,550 --> 00:19:57,830
进行精确的分叉

541
00:19:57,830 --> 00:19:59,750


542
00:19:59,750 --> 00:20:02,720


543
00:20:02,720 --> 00:20:04,070
执行查询所以考虑这个的方式

544
00:20:04,070 --> 00:20:06,830
是源代码在

545
00:20:06,830 --> 00:20:09,320
这里生成它会有一个像一个

546
00:20:09,320 --> 00:20:11,240
主函数但是假设我们调用了

547
00:20:11,240 --> 00:20:12,410
name 它会有一个函数，

548
00:20:12,410 --> 00:20:15,800
它的名字是已知的并且具有

549
00:20:15,800 --> 00:20:17,690
参数签名是

550
00:20:17,690 --> 00:20:19,790
数据库系统已知，因此当您获得

551
00:20:19,790 --> 00:20:21,140
共享对象并想要调用

552
00:20:21,140 --> 00:20:23,720
查询时，您知道您只需调用该一个

553
00:20:23,720 --> 00:20:25,250
函数，然后无论结果是否正确，它都会吐回任何

554
00:20:25,250 --> 00:20:28,550
结果，因此

555
00:20:28,550 --> 00:20:29,870
看起来您显然会

556
00:20:29,870 --> 00:20:32,390
付出代价 不得不 fork 确切的 GCC 对性能的巨大损失，

557
00:20:32,390 --> 00:20:34,760
因为这会

558
00:20:34,760 --> 00:20:36,260
启动另一个进程

559
00:20:36,260 --> 00:20:38,420
，GCC 想要读取它自己的

560
00:20:38,420 --> 00:20:39,680
配置文件的上下文，如果你

561
00:20:39,680 --> 00:20:40,730
对每个查询都这样做，永远不会再这样做

562
00:20:40,730 --> 00:20:43,070
它会很慢，这是

563
00:20:43,070 --> 00:20:45,070
JIT 编译要解决什么

564
00:20:45,070 --> 00:20:49,790
让我们大致看看它是如何工作的，所以我们

565
00:20:49,790 --> 00:20:52,640
在这里有我们的查询 select star from a

566
00:20:52,640 --> 00:20:54,110
where a dot Val等于问号

567
00:20:54,110 --> 00:20:58,340
加一所以对于解释

568
00:20:58,340 --> 00:21:01,130
计划，你知道

569
00:21:01,130 --> 00:21:02,450
我之前在第一个示例中展示的那种 for 循环是

570
00:21:02,450 --> 00:21:04,840
对的，我们将警告为

571
00:21:04,840 --> 00:21:07,880
迭代每个元组以获取

572
00:21:07,880 --> 00:21:09,380
我们提供给它的新元组我

573
00:21:09,380 --> 00:21:10,670
在我们的私有谓词中给出了这种方式的偏移量

574
00:21:10,670 --> 00:21:13,340
，然后承认 它的输出所以

575
00:21:13,340 --> 00:21:14,840
在第一步中，当我们调用

576
00:21:14,840 --> 00:21:17,360
这个函数时，它必须做的是

577
00:21:17,360 --> 00:21:19,040
查看目录并找出

578
00:21:19,040 --> 00:21:21,290
表的架构是什么样的，

579
00:21:21,290 --> 00:21:23,020
然后你必须

580
00:21:23,020 --> 00:21:25,280
根据元组大小计算偏移量，所以我 知道

581
00:21:25,280 --> 00:21:26,840
跳转到块和固定的

582
00:21:26,840 --> 00:21:28,910
像偏移量然后我返回

583
00:21:28,910 --> 00:21:30,920
指向元组的指针现在你可以

584
00:21:30,920 --> 00:21:32,660
在这里兑现第一个你可以尝试避免

585
00:21:32,660 --> 00:21:34,940
每次都去获取模式

586
00:21:34,940 --> 00:21:37,100
但是其他的你在这里 仍然

587
00:21:37,100 --> 00:21:39,560
需要做，但现在最大的成本将

588
00:21:39,560 --> 00:21:40,880
是一个小时，当我们验证我们的

589
00:21:40,880 --> 00:21:42,080
谓词时，因为现在我们必须

590
00:21:42,080 --> 00:21:44,810
遍历该表达式树并将

591
00:21:44,810 --> 00:21:46,490
所有值拉起来，看看它是否

592
00:21:46,490 --> 00:21:48,710
返回 true 或 false，然后如果是，

593
00:21:48,710 --> 00:21:53,390
那么 我们把元组做好了，所以哇

594
00:21:53,390 --> 00:21:55,910
俳句要做的是有一个模板，一个

595
00:21:55,910 --> 00:21:59,300
计划，其中这一切都是 Python 但

596
00:21:59,300 --> 00:22:00,800
他们正在这样做 他们正在

597
00:22:00,800 --> 00:22:03,650
用 C++ 做他们的寺庙，他们知道他们

598
00:22:03,650 --> 00:22:06,050
必须进行迭代或扫描

599
00:22:06,050 --> 00:22:09,140
一个表，

600
00:22:09,140 --> 00:22:11,030
那就是 真的会有所不同的

601
00:22:11,030 --> 00:22:12,350
是谓词是什么

602
00:22:12,350 --> 00:22:14,090
你必须替换不同的值

603
00:22:14,090 --> 00:22:17,270
你知道什么时候你想

604
00:22:17,270 --> 00:22:19,520
评估扫描正确所以元组

605
00:22:19,520 --> 00:22:20,870
大小谓词偏移和

606
00:22:20,870 --> 00:22:22,340
参数值就像这些是正在

607
00:22:22,340 --> 00:22:24,650
发生的事情

608
00:22:24,650 --> 00:22:26,570
当我们调用查询时被告知，但

609
00:22:26,570 --> 00:22:29,360
谓词将改变的其他一切你知道

610
00:22:29,360 --> 00:22:30,980
可以从一个核心改变到下一个，

611
00:22:30,980 --> 00:22:32,300
但其他一切对我来说

612
00:22:32,300 --> 00:22:34,940
从下一次扫描开始总是相同的所以

613
00:22:34,940 --> 00:22:36,140
现在我需要做的就是采取 这些值

614
00:22:36,140 --> 00:22:40,580
并使用这个模板和只猫

615
00:22:40,580 --> 00:22:42,530
一次它会为我填充这些东西在

616
00:22:42,530 --> 00:22:45,170
这里我只是检查

617
00:22:45,170 --> 00:22:46,250
这些值在哪里是真的或不

618
00:22:46,250 --> 00:22:48,380
一样的东西我只是从这里得到它

619
00:22:48,380 --> 00:22:50,840
然后我可以评估 这又是我

620
00:22:50,840 --> 00:22:53,660
摆脱了对 for 的查找来

621
00:22:53,660 --> 00:22:55,760
获取元组，我也摆脱

622
00:22:55,760 --> 00:22:57,800
了对谓词求值的查找，所以我

623
00:22:57,800 --> 00:22:59,060
删除了两个

624
00:22:59,060 --> 00:23:00,770
会导致我们在 for 循环内部跳转的函数

625
00:23:00,770 --> 00:23:04,310
，现在是 the  CPU

626
00:23:04,310 --> 00:23:05,990
可以

627
00:23:05,990 --> 00:23:11,360
非常快速地遍历这个是如何使用

628
00:23:11,360 --> 00:23:18,080
信用谓词偏移量所以

629
00:23:18,080 --> 00:23:19,820
我们是所以我们必须得到

630
00:23:19,820 --> 00:23:21,710
谓词偏移量是什么

631
00:23:21,710 --> 00:23:23,380
属性和元组我想评估

632
00:23:23,380 --> 00:23:27,830
所以我 必须知道我想要我

633
00:23:27,830 --> 00:23:30,770
之前是一个 B 点值所以这会

634
00:23:30,770 --> 00:23:32,420
告诉我两个男孩

635
00:23:32,420 --> 00:23:53,810
击败的偏移量是的哦是的这个谓词因为

636
00:23:53,810 --> 00:23:57,400
我因为你的意思看起来我知道

637
00:24:00,310 --> 00:24:02,480
正确所以它就在这里它的问题

638
00:24:02,480 --> 00:24:06,230
是 我如何将一个弓转换为

639
00:24:06,230 --> 00:24:08,330
问号加上一个我如何将其转换为

640
00:24:08,330 --> 00:24:12,140
这个所以我必须通过

641
00:24:12,140 --> 00:24:13,490


642
00:24:13,490 --> 00:24:15,200
优化器出来的查询计划并

643
00:24:15,200 --> 00:24:16,220
弄清楚它实际上

644
00:24:16,220 --> 00:24:18,590
在做什么谓词和 我将表达式树

645
00:24:18,590 --> 00:24:20,900
转换为 thi  s line在这里所以你可能会认为

646
00:24:20,900 --> 00:24:22,669
很好不是那样做

647
00:24:22,669 --> 00:24:25,399
查找你会有十亿两个碗

648
00:24:25,399 --> 00:24:28,129
我只做一次对而在这种

649
00:24:28,129 --> 00:24:29,269
情况下你必须做十亿

650
00:24:29,269 --> 00:24:33,019
次正确所以应该很明显为什么

651
00:24:33,019 --> 00:24:34,549
再次为什么 这对我们来说是否会是一个巨大的

652
00:24:34,549 --> 00:24:36,769
胜利，因为一切都已经完成，

653
00:24:36,769 --> 00:24:38,989
没有额外的查找，我们可以

654
00:24:38,989 --> 00:24:40,309
非常快速地迭代

655
00:24:40,309 --> 00:24:41,989
每个元组评估我们的谓词并

656
00:24:41,989 --> 00:24:50,749
产生输出是的所以这个问题

657
00:24:50,749 --> 00:24:53,389
是整个谓词的情况如何

658
00:24:53,389 --> 00:25:04,940
事情是正确的，

659
00:25:04,940 --> 00:25:07,700
我们会到达那里，所以他的问题在我的

660
00:25:07,700 --> 00:25:10,090
示例中，当查询出现时，

661
00:25:10,090 --> 00:25:12,499
它每次都会生成这个

662
00:25:12,499 --> 00:25:14,659
结构，所以如果我

663
00:25:14,659 --> 00:25:16,549
实际上在理论上，如果我知道执行

664
00:25:16,549 --> 00:25:18,109
查询计划将其兑现为同一个

665
00:25:18,109 --> 00:25:19,909
查询 一遍又一遍，它会预先生成

666
00:25:19,909 --> 00:25:20,960
这个东西，一遍又一遍地打开，

667
00:25:20,960 --> 00:25:22,820
一遍又一遍地编译它，所以

668
00:25:22,820 --> 00:25:24,889
你难道不知道，哦，好吧，我

669
00:25:24,889 --> 00:25:26,299
只需要在某些光线的数据库中做很多事情，

670
00:25:26,299 --> 00:25:27,529
就像只有

671
00:25:27,529 --> 00:25:30,799
这么多谓词一样 叹息你知道

672
00:25:30,799 --> 00:25:32,659
小于等于只有

673
00:25:32,659 --> 00:25:34,489
在论坛里只有这么多事情

674
00:25:34,489 --> 00:25:36,619
我要做执行查询我

675
00:25:36,619 --> 00:25:38,289
是否需要预先生成所有这些

676
00:25:38,289 --> 00:25:40,070
原语是我将实际使用的词，

677
00:25:40,070 --> 00:25:43,220
并在运行时以这种方式 我

678
00:25:43,220 --> 00:25:45,950
不必生成 C++ 代码我只是直接调用这些

679
00:25:45,950 --> 00:25:46,519
函数

680
00:25:46,519 --> 00:25:48,379
这就是向量明智的，我们将

681
00:25:48,379 --> 00:25:49,909
在后面的课程中看到，

682
00:25:49,909 --> 00:25:51,559
是的，这就是我们在系统中所做的实际工作，

683
00:25:51,559 --> 00:25:56,779
尤其是

684
00:25:56,779 --> 00:25:58,159
依赖于深度的谓词数量

685
00:25:58,159 --> 00:26:01,519
树，但我认为他的观点

686
00:26:01,519 --> 00:26:02,779
就像说我在这里做什么

687
00:26:02,779 --> 00:26:07,539
Val 等于正确的东西，所以

688
00:26:07,539 --> 00:26:10,429
与其再次拥有一个

689
00:26:10,429 --> 00:26:12,200
函数，而不是拥有这个，如果调用

690
00:26:12,200 --> 00:26:16,070
这里来做这件事，我可以有一个函数

691
00:26:16,070 --> 00:26:18,259
说拿两个整数检查看看

692
00:26:18,259 --> 00:26:19,909
它们是否相等并且是否经过预编译

693
00:26:19,909 --> 00:26:22,210
，

694
00:26:25,870 --> 00:26:29,030
除了你以外没有

695
00:26:29,030 --> 00:26:31,570
人像连词子句一样将它们分解为喜欢，

696
00:26:31,570 --> 00:26:35,920
现在它是一个数组，它不是一棵树 a

697
00:26:35,920 --> 00:26:38,660
等于 1，B 等于 2，C 等于

698
00:26:38,660 --> 00:26:40,070
3，其中的每一个都可能是一个

699
00:26:40,070 --> 00:26:41,390
调用的函数你知道某

700
00:26:41,390 --> 00:26:44,390
事等于某事，我

701
00:26:44,390 --> 00:26:45,860
一个接一个地在数组中调用它们我不想

702
00:26:45,860 --> 00:27:01,970
遍历任何一棵树

703
00:27:01,970 --> 00:27:03,560
，当我们有更好的智慧时，我们就向量化了，

704
00:27:03,560 --> 00:27:06,950
但就像一

705
00:27:06,950 --> 00:27:09,140
秒钟一样，编译成本是什么

706
00:27:09,140 --> 00:27:11,390
会终止这种方法，所以如果

707
00:27:11,390 --> 00:27:13,850
你现在不必

708
00:27:13,850 --> 00:27:15,500
每次执行查询时都编译一些等于某物的东西

709
00:27:15,500 --> 00:27:17,300
，他的例子你能

710
00:27:17,300 --> 00:27:19,550
抓住那个或者副驾驶想要在这个

711
00:27:19,550 --> 00:27:23,570
链接中它是的，这是向量

712
00:27:23,570 --> 00:27:35,030
购买的 正确如此相关，他的

713
00:27:35,030 --> 00:27:37,370
问题是如果我不知道内存地址又在哪里，我的生成

714
00:27:37,370 --> 00:27:39,890
查询代码如何调用和接触

715
00:27:39,890 --> 00:27:40,910
系统的其他部分，

716
00:27:40,910 --> 00:27:42,890
这

717
00:27:42,890 --> 00:27:45,320
只是 Cephas 丢失代码，我们要将

718
00:27:45,320 --> 00:27:47,720
其与我们的数据库链接 系统共享

719
00:27:47,720 --> 00:27:50,630
对象，所以如果我们公开一个 API，它允许

720
00:27:50,630 --> 00:27:52,520
您访问

721
00:27:52,520 --> 00:27:54,890
我们数据库系统的内部组件，那么

722
00:27:54,890 --> 00:27:58,400
我们的您知道我们的有说服力的查询计划

723
00:27:58,400 --> 00:28:00,170
也可以调用和触及这些东西，

724
00:28:00,170 --> 00:28:00,560


725
00:28:00,560 --> 00:28:02,870
我说 如果我需要

726
00:28:02,870 --> 00:28:04,700
像事务管理器那样访问它，我有一个

727
00:28:04,700 --> 00:28:06,320
功能说你知道我

728
00:28:06,320 --> 00:28:08,330
当前的执行联系人给我我的

729
00:28:08,330 --> 00:28:10,970
事务管理器，现在我

730
00:28:10,970 --> 00:28:13,700
的即时代码可以调用它，你

731
00:28:13,700 --> 00:28:14,720
知道检查它是否很多

732
00:28:14,720 --> 00:28:16,880
提交与否之类的事情，所以

733
00:28:16,880 --> 00:28:19,370
它几乎就像

734
00:28:19,370 --> 00:28:20,930
你在我们的数据库系统中编写的 coab 一样，

735
00:28:20,930 --> 00:28:23,780
但我们正在编写它

736
00:28:23,780 --> 00:28:26,090
并在运行时即时编译它，

737
00:28:26,090 --> 00:28:28,490
所以我们作为数据系统开发人员

738
00:28:28,490 --> 00:28:29,660
我们不确切知道

739
00:28:29,660 --> 00:28:33,110
将要显示什么查询，但我们仍然可以

740
00:28:33,110 --> 00:28:35,030
知道我们仍然可以调用

741
00:28:35,030 --> 00:28:35,879
系统的各个部分并实际

742
00:28:35,879 --> 00:28:40,589
使其发生

743
00:28:40,589 --> 00:28:44,849


744
00:28:44,849 --> 00:28:46,949
LLVM 因为它的 C++ 那么你有

745
00:28:46,949 --> 00:28:48,959
这些被破坏的传递给函数，

746
00:28:48,959 --> 00:28:50,039
就像你曾经看过其他人

747
00:28:50,039 --> 00:28:51,899
一样

748
00:28:51,899 --> 00:28:53,339
，当你在 gdb 中查看他们的名字时，这些函数实际上是什么样子的，

749
00:28:53,339 --> 00:28:56,339
除非他们在修改

750
00:28:56,339 --> 00:28:57,749
你知道这些长字符串时这样做 无线

751
00:28:57,749 --> 00:28:59,459
像类名和函数名之类的

752
00:28:59,459 --> 00:29:02,009
东西，如果这可能

753
00:29:02,009 --> 00:29:03,779
会变得有点粗糙，所以你需要

754
00:29:03,779 --> 00:29:07,199
一种方法来桥接戴维森

755
00:29:07,199 --> 00:29:09,779
在他们的世界中做到这一点，因为

756
00:29:09,779 --> 00:29:11,429
他们正在生成 C 代码 这

757
00:29:11,429 --> 00:29:13,289
不是问题或尖顶，因为这不是

758
00:29:13,289 --> 00:29:14,909
问题，因为他们只是投票给其他

759
00:29:14,909 --> 00:29:16,469
函数，就好像所有这些函数都是

760
00:29:16,469 --> 00:29:19,679


761
00:29:19,679 --> 00:29:20,879
同时编译的一样，这种

762
00:29:20,879 --> 00:29:22,859
翻译方法的另一个好处是它使

763
00:29:22,859 --> 00:29:24,839
调试更容易，因为 现在，如果我

764
00:29:24,839 --> 00:29:29,279
在我生成的代码中崩溃，我

765
00:29:29,279 --> 00:29:31,619
可以使用 gdb 和我所有的标准

766
00:29:31,619 --> 00:29:33,089
调试工具来找出我

767
00:29:33,089 --> 00:29:36,029
崩溃的原因，这

768
00:29:36,029 --> 00:29:40,559
对于 LLVM 的东西来说实际上是一个大问题，

769
00:29:40,559 --> 00:29:42,389
你怎么做你必须有 做

770
00:29:42,389 --> 00:29:43,739
一些额外的工作来

771
00:29:43,739 --> 00:29:45,539
弄清楚生成这个 T 的最简单的代码是什么

772
00:29:45,539 --> 00:29:47,190
加上崩溃的代码

773
00:29:47,190 --> 00:29:49,229
是的，你必须

774
00:29:49,229 --> 00:29:51,059
在调试符号或关于如何发生的提示中进行跳转，

775
00:29:51,059 --> 00:29:53,219
但它又没有那么

776
00:29:53,219 --> 00:29:56,219
糟糕 都在 LLVM 中 是的，让我们

777
00:29:56,219 --> 00:29:58,709
看看他们为俳句做的一些实验，

778
00:29:58,709 --> 00:30:00,419
以了解

779
00:30:00,419 --> 00:30:02,999
他们方法的好处 所以这篇论文已经很老了

780
00:30:02,999 --> 00:30:08,039
我认为现在是 2010 年，但我非常喜欢它，

781
00:30:08,039 --> 00:30:09,959
因为它们产生了所有

782
00:30:09,959 --> 00:30:11,489
不同的变体，就像你可以

783
00:30:11,489 --> 00:30:12,869
做翻译一样 或者你可以构建一个

784
00:30:12,869 --> 00:30:14,909
davis 系统，然后他们把它全部放在

785
00:30:14,909 --> 00:30:16,619
一个引擎中并与所有它们进行比较，

786
00:30:16,619 --> 00:30:20,069
这样他们就会有五种

787
00:30:20,069 --> 00:30:21,929
不同的方法，所以通用

788
00:30:21,929 --> 00:30:23,789
迭代器就像

789
00:30:23,789 --> 00:30:26,549
数据库系统的教科书实现

790
00:30:26,549 --> 00:30:28,709
，你有像火山一样 模型

791
00:30:28,709 --> 00:30:29,909
，你

792
00:30:29,909 --> 00:30:31,409
在四个循环中调用这些函数 2 乘 8 次

793
00:30:31,409 --> 00:30:34,049
调用 next 10x 然后

794
00:30:34,049 --> 00:30:35,639
他们会有一个稍微

795
00:30:35,639 --> 00:30:36,929
优化的版本，现在你

796
00:30:36,929 --> 00:30:38,729
有特定于

797
00:30:38,729 --> 00:30:40,769
你可以访问的不同类型列的迭代器

798
00:30:40,769 --> 00:30:42,179
或者您将

799
00:30:42,179 --> 00:30:46,049
在数据库中访问的树，您可以

800
00:30:46,049 --> 00:30:48,239
在将谓词

801
00:30:48,239 --> 00:30:49,590
传递给下一个运算符之前评估谓词，

802
00:30:49,590 --> 00:30:50,940
它们基本上是 doi  ng

803
00:30:50,940 --> 00:30:53,130
predicate push down 然后你有这些

804
00:30:53,130 --> 00:30:54,630
硬编码的实现，就像

805
00:30:54,630 --> 00:30:56,160
他们有一个研究生实现一样，就像一个

806
00:30:56,160 --> 00:30:59,070
尽力而为的方法，就像

807
00:30:59,070 --> 00:31:00,270
通用迭代和谓词

808
00:31:00,270 --> 00:31:02,100
等价于这个，然后是一个更

809
00:31:02,100 --> 00:31:03,450
优化的版本，相当于

810
00:31:03,450 --> 00:31:05,280
这个，但又一次 它就像是

811
00:31:05,280 --> 00:31:06,630
为查询而硬编码，而不是

812
00:31:06,630 --> 00:31:09,060
通用引擎，然后最后

813
00:31:09,060 --> 00:31:12,300
一个就是它们是什么，你知道

814
00:31:12,300 --> 00:31:15,270
它们是源到源编译器代码

815
00:31:15,270 --> 00:31:16,770
生成器引擎会为

816
00:31:16,770 --> 00:31:20,190
查询吐出 思考这个问题的方式，

817
00:31:20,190 --> 00:31:21,930
乐观主义者的心可能是他

818
00:31:21,930 --> 00:31:24,630
问的问题，比如我能不能提前预编译所有

819
00:31:24,630 --> 00:31:26,580
的谓词

820
00:31:26,580 --> 00:31:27,630
和类型，现在我只是将

821
00:31:27,630 --> 00:31:29,100
这些不同的函数链接在一起，所以

822
00:31:29,100 --> 00:31:32,310
这就是这个函数 所以

823
00:31:32,310 --> 00:31:33,900
对于

824
00:31:33,900 --> 00:31:36,140
他们正在运行的这个，我认为这只是

825
00:31:36,140 --> 00:31:42,570
对 10,000 个元组表的扫描或连接查询

826
00:31:42,570 --> 00:31:45,270
以产生 1000 万个，所以

827
00:31:45,270 --> 00:31:46,560
你看到的是，对于

828
00:31:46,560 --> 00:31:48,240
通用迭代器，它执行的惊喜

829
00:31:48,240 --> 00:31:49,800
最糟糕的是，当你

830
00:31:49,800 --> 00:31:52,020
到达这里时，我的不同之处

831
00:31:52,020 --> 00:31:53,490
是硬编码的俳句之一

832
00:31:53,490 --> 00:31:56,040
，它们大致相同，

833
00:31:56,040 --> 00:31:59,610
因为俳句之类的引擎正在

834
00:31:59,610 --> 00:32:01,890
吐出 C++ 代码，大致

835
00:32:01,890 --> 00:32:05,430
相当于 硬编码的人可以这样做，

836
00:32:05,430 --> 00:32:07,260
现在再次针对任何任意查询

837
00:32:07,260 --> 00:32:08,850
而不是我时间

838
00:32:08,850 --> 00:32:10,740
一遍又一遍地手动编写代码我可以让

839
00:32:10,740 --> 00:32:13,640
引擎生成该代码直接编写

840
00:32:13,640 --> 00:32:17,010
您指出的另一件事

841
00:32:17,010 --> 00:32:18,390
就像我们有 更多的内存

842
00:32:18,390 --> 00:32:22,020
在通用内存中停滞，只是因为

843
00:32:22,020 --> 00:32:24,660
有很多类似的间接性，

844
00:32:24,660 --> 00:32:25,890
我们正在做这些跳转，我们不

845
00:32:25,890 --> 00:32:27,330
知道什么

846
00:32:27,330 --> 00:32:28,380
内存会提前读取你知道的，

847
00:32:28,380 --> 00:32:31,350
而在这些情况下再次

848
00:32:31,350 --> 00:32:33,270
for 循环非常紧凑，我们可以

849
00:32:33,270 --> 00:32:34,590
非常快速地完成所有内容，然后

850
00:32:34,590 --> 00:32:35,580
硬件预取器可以

851
00:32:35,580 --> 00:32:40,580
为

852
00:32:40,580 --> 00:32:43,580


853
00:32:46,520 --> 00:32:49,970
我们提前将

854
00:32:49,970 --> 00:32:51,950


855
00:32:51,950 --> 00:32:55,010
内容放入内存中 永远不想内联小

856
00:32:55,010 --> 00:32:57,860
函数 不会

857
00:32:57,860 --> 00:33:00,050
在 for 循环内核内部将它们内联

858
00:33:00,050 --> 00:33:09,380


859
00:33:09,380 --> 00:33:17,900


860
00:33:17,900 --> 00:33:19,580


861
00:33:19,580 --> 00:33:22,340


862
00:33:22,340 --> 00:33:24,670
你真的很大，但我

863
00:33:24,670 --> 00:33:27,080
实际上我认为这些天的编译器

864
00:33:27,080 --> 00:33:28,970
实际上在弄清楚什么是内联方面做得很好

865
00:33:28,970 --> 00:33:31,100
，所以在

866
00:33:31,100 --> 00:33:32,809
像俳句的情况下，当它是

867
00:33:32,809 --> 00:33:35,030
cogentiva 源代码时，我认为你

868
00:33:35,030 --> 00:33:37,160
不想把像 内联提示 我

869
00:33:37,160 --> 00:33:38,720
认为你希望编译器做任何

870
00:33:38,720 --> 00:33:40,190
想做的事 我认为这是

871
00:33:40,190 --> 00:33:41,900
现在 C++ 的传统智慧 你

872
00:33:41,900 --> 00:33:44,059
不要在我的任何地方添加你让

873
00:33:44,059 --> 00:33:49,700
编译器最喜欢的东西出来

874
00:33:49,700 --> 00:33:50,960
好的 这种方法的缺点是什么 它

875
00:33:50,960 --> 00:33:52,460
会 现在是编译成本，

876
00:33:52,460 --> 00:33:54,800
所以对于这个，他们将

877
00:33:54,800 --> 00:33:57,590
使用 o 0 + o - o 0 进行编译，基本上没有

878
00:33:57,590 --> 00:34:00,290
优化，所以 2 是最

879
00:34:00,290 --> 00:34:01,370
积极的优化，被

880
00:34:01,370 --> 00:34:03,230
认为是安全和显而易见的 狡猾地

881
00:34:03,230 --> 00:34:05,270
，当你做 o 时会有更多的通过 -

882
00:34:05,270 --> 00:34:07,460
所以编译时间会增加

883
00:34:07,460 --> 00:34:10,609
所以这是 40 PCH 对 ISM 这

884
00:34:10,609 --> 00:34:11,929
不是查询执行时间这

885
00:34:11,929 --> 00:34:13,820
只是编译时间所以现在

886
00:34:13,820 --> 00:34:16,219
你正试图陷入问题，

887
00:34:16,219 --> 00:34:19,219
因为在 在 Q 3 的情况下，

888
00:34:19,219 --> 00:34:23,000
我需要 600 毫秒来编译

889
00:34:23,000 --> 00:34:25,070
它，在某些情况下，查询

890
00:34:25,070 --> 00:34:27,168
可以在 100 毫秒内完成，所以我

891
00:34:27,168 --> 00:34:29,090
花在编译上的时间

892
00:34:29,090 --> 00:34:32,300
比你好，我实际上你知道我什么时候

893
00:34:32,300 --> 00:34:33,619
花 实际上实际上并没有

894
00:34:33,619 --> 00:34:36,770
正确查询所以这是我

895
00:34:36,770 --> 00:34:39,918
使用这种方法的一个问题，我们将

896
00:34:39,918 --> 00:34:41,570
在后面的课程中看到 mem 续集，

897
00:34:41,570 --> 00:34:43,429
但就像 mem Seco 实际上他们的第一个

898
00:34:43,429 --> 00:34:45,129
实现实际上做到了这一点，

899
00:34:45,129 --> 00:34:47,149
当他看一些

900
00:34:47,149 --> 00:34:48,500
他们从 Ruby 开始的早期博客文章，

901
00:34:48,500 --> 00:34:49,609
您在存档中查看您仍然

902
00:34:49,609 --> 00:34:51,290
可以找到它们是正确的，它们会提供示例

903
00:34:51,290 --> 00:34:52,639
，例如您运行查询并且

904
00:34:52,639 --> 00:34:54,800
即使它不知道工作也需要一秒钟才能运行，

905
00:34:54,800 --> 00:34:56,449
因为它们” 重新叉

906
00:34:56,449 --> 00:34:59,030
严格 G  CC 那里

907
00:34:59,030 --> 00:35:00,410
有 C++ 代码，Jen

908
00:35:00,410 --> 00:35:02,270
为该查询编译它，然后重新

909
00:35:02,270 --> 00:35:04,549
链接并运行它，但他们在

910
00:35:04,549 --> 00:35:06,619
缓存所有内容时做得很好，这样当你

911
00:35:06,619 --> 00:35:08,059
再次执行相同的查询时，

912
00:35:08,059 --> 00:35:09,380
他们会在他们的示例中显示

913
00:35:09,380 --> 00:35:10,609
公司每次的行动现在都

914
00:35:10,609 --> 00:35:12,859
为零，因为他们可以

915
00:35:12,859 --> 00:35:21,520
一遍又一遍地重复使用那个二进制文件，所以

916
00:35:21,520 --> 00:35:23,869
正如我开始

917
00:35:23,869 --> 00:35:26,150
所说的那样，我们组织查询

918
00:35:26,150 --> 00:35:27,920
计划树的方式对我们来说是有用的，

919
00:35:27,920 --> 00:35:30,440
因为人类制造 代码可重用

920
00:35:30,440 --> 00:35:32,150
使代码易于扩展，但

921
00:35:32,150 --> 00:35:33,140
它再次不是执行者最

922
00:35:33,140 --> 00:35:35,030
有效的方式，

923
00:35:35,030 --> 00:35:36,980
如果俳句再次出现，即使我们

924
00:35:36,980 --> 00:35:38,750
可以执行看到拼图代码，这

925
00:35:38,750 --> 00:35:40,970
将是执行

926
00:35:40,970 --> 00:35:43,609
这些查询的更有效方式

927
00:35:43,609 --> 00:35:47,539
我们编译正确的速度也很慢 一个大问题

928
00:35:47,539 --> 00:35:48,740
也是高 q - 是他们不会

929
00:35:48,740 --> 00:35:50,510
支持完整的流水线，他们仍然

930
00:35:50,510 --> 00:35:52,430
会在每个操作员上生成

931
00:35:52,430 --> 00:35:54,829
for 循环的饮料 一个

932
00:35:54,829 --> 00:35:56,990
操作符仍然有一个 MIT 函数可以将

933
00:35:56,990 --> 00:35:58,309
它推送给下一个操作符，

934
00:35:58,309 --> 00:36:00,619
然后他将拥有自己的 for 循环来

935
00:36:00,619 --> 00:36:02,329
处理事物，现在向下推一个新的谓词

936
00:36:02,329 --> 00:36:03,799
，这样当你

937
00:36:03,799 --> 00:36:04,849
在表上进行扫描时，尽管评估

938
00:36:04,849 --> 00:36:06,559
谓词，但一切 否则再次进入

939
00:36:06,559 --> 00:36:08,150
查询计划，就像

940
00:36:08,150 --> 00:36:10,609
下一次调用一样，您知道您还必须

941
00:36:10,609 --> 00:36:14,660
运行自己的 for 循环，以便

942
00:36:14,660 --> 00:36:16,130
了解我们如何通过流水线获得更好的

943
00:36:16,130 --> 00:36:18,079
性能，我们将

944
00:36:18,079 --> 00:36:20,569
回到这三种方式 加入查询，

945
00:36:20,569 --> 00:36:22,609
现在我们将把它分成

946
00:36:22,609 --> 00:36:25,220
管道列表，管道

947
00:36:25,220 --> 00:36:28,130
是查询计划的一部分，我可以在其中

948
00:36:28,130 --> 00:36:31,039
获取一个元组并

949
00:36:31,039 --> 00:36:32,599
尽可能地将它放入查询计划中，

950
00:36:32,599 --> 00:36:34,789
直到我到达 在某些时候我无法

951
00:36:34,789 --> 00:36:36,890
继续执行查询计划，直到我去

952
00:36:36,890 --> 00:36:38,809
获取下两个将获取

953
00:36:38,809 --> 00:36:40,670
进入我的

954
00:36:40,670 --> 00:36:42,710
管道中的所有元组所以这里最容易

955
00:36:42,710 --> 00:36:45,289
理解的是我正在

956
00:36:45,289 --> 00:36:47,690
扫描 B 然后我的管道 正在应用我的

957
00:36:47,690 --> 00:36:49,970
谓词，但现在我想

958
00:36:49,970 --> 00:36:52,190
在组上进行聚合 I 但我不能

959
00:36:52,190 --> 00:36:56,059


960
00:36:56,059 --> 00:36:58,970
在我将所有元组放入哈希表

961
00:36:58,970 --> 00:37:01,250
进行聚合之前我不能通过这个运算符 因为我正在

962
00:37:01,250 --> 00:37:03,380
计算计数所以我需要你知道计数是多少

963
00:37:03,380 --> 00:37:04,670
我拥有的另一个工具，

964
00:37:04,670 --> 00:37:06,740
你知道 group by 子句之前

965
00:37:06,740 --> 00:37:09,440
我可以在

966
00:37:09,440 --> 00:37:11,240
管道的情况下传递任何东西在这里我极客

967
00:37:11,240 --> 00:37:13,670
可以看到并假设我已经构建

968
00:37:13,670 --> 00:37:14,240
了

969
00:37:14,240 --> 00:37:16,880
能够在一个上进行连接的哈希 并且 BI 可以

970
00:37:16,880 --> 00:37:18,920
将单个元组写在这里

971
00:37:18,920 --> 00:37:21,860
检查它是否我执行连接

972
00:37:21,860 --> 00:37:24,050
它匹配是所以然后我可以在这里运行它

973
00:37:24,050 --> 00:37:25,369
并检查我是否可以

974
00:37:25,369 --> 00:37:28,160
执行连接 a 以及它是否匹配

975
00:37:28,160 --> 00:37:29,420
有想法 又是我们可以让

976
00:37:29,420 --> 00:37:31,430
管道去看看古巴走得更远作为帐户

977
00:37:31,430 --> 00:37:33,050
，你知道在跛子之前，直到

978
00:37:33,050 --> 00:37:37,369
我们有一个管道断路器，这

979
00:37:37,369 --> 00:37:39,440
就是hyper所做的所以hyper实际上有

980
00:37:39,440 --> 00:37:40,850
两个主要想法，

981
00:37:40,850 --> 00:37:42,650
你们这些人的论文 阅读所以首先是

982
00:37:42,650 --> 00:37:45,860
他们要做这个基于推送的查询

983
00:37:45,860 --> 00:37:47,720
工厂或过程 essing 模型，但

984
00:37:47,720 --> 00:37:50,030
他们也会

985
00:37:50,030 --> 00:37:54,290
使用 LLVM 及时编译查询计划

986
00:37:54,290 --> 00:37:58,250
，所以当你阅读这篇论文时，

987
00:37:58,250 --> 00:37:59,420
希望没有阅读附录我

988
00:37:59,420 --> 00:38:00,050
应该提前警告你，

989
00:38:00,050 --> 00:38:02,510
因为所有这些都是 Mir 我不

990
00:38:02,510 --> 00:38:03,920
明白它就像它不是真正

991
00:38:03,920 --> 00:38:05,869
有用的核心材料

992
00:38:05,869 --> 00:38:07,520
论文中实际发生的事情是它的

993
00:38:07,520 --> 00:38:10,640
前半部分

994
00:38:10,640 --> 00:38:11,990
所以他们要做这个

995
00:38:11,990 --> 00:38:15,200
基于推送的模型的原因是什么不仅仅是保持

996
00:38:15,200 --> 00:38:16,880
现在你可以在 CPU 缓存中

997
00:38:16,880 --> 00:38:18,680
保存元组和值，

998
00:38:18,680 --> 00:38:20,810
这比

999
00:38:20,810 --> 00:38:23,780


1000
00:38:23,780 --> 00:38:26,510


1001
00:38:26,510 --> 00:38:29,630
l1 缓存更快 那么

1002
00:38:29,630 --> 00:38:30,650
这可以非常

1003
00:38:30,650 --> 00:38:34,150
快速

1004
00:38:35,200 --> 00:38:38,420
地完成它，对于那些实际上不知道

1005
00:38:38,420 --> 00:38:40,670
谁在此之前听说过 El Elyon 或

1006
00:38:40,670 --> 00:38:42,220
在此之前没有听说过他的人

1007
00:38:42,220 --> 00:38:47,540
好吧完美所以 LLVM 最初是

1008
00:38:47,540 --> 00:38:48,740
一个低级虚拟机的立场，

1009
00:38:48,740 --> 00:38:49,880
尽管 你不应该认为o 把它作为一个

1010
00:38:49,880 --> 00:38:51,320
虚拟机，不像 VirtualBox

1011
00:38:51,320 --> 00:38:55,070
到 vmware 最初是在 UIUC 开始的，

1012
00:38:55,070 --> 00:38:58,400
比如 2000 年或 1999 年，他们

1013
00:38:58,400 --> 00:38:59,859
试图构建一个工具来研究

1014
00:38:59,859 --> 00:39:02,510


1015
00:39:02,510 --> 00:39:04,520
编程语言的动态编译技术，他们最终

1016
00:39:04,520 --> 00:39:06,320
构建了这样的工具

1017
00:39:06,320 --> 00:39:09,590
包 所有这些不同的组件，

1018
00:39:09,590 --> 00:39:10,940
你需要成为一个成熟的

1019
00:39:10,940 --> 00:39:12,740
编译器，这个想法是，而不是

1020
00:39:12,740 --> 00:39:15,140
让你知道用

1021
00:39:15,140 --> 00:39:16,850
一种编程语言编译它

1022
00:39:16,850 --> 00:39:18,109
会有不同的前端

1023
00:39:18,109 --> 00:39:19,700
插件，然后你可以用不同的

1024
00:39:19,700 --> 00:39:22,340
编程语言构建一个

1025
00:39:22,340 --> 00:39:23,960
它的前端，然后可以将其转换为

1026
00:39:23,960 --> 00:39:25,700
LMI r，然后从那里您可以将其

1027
00:39:25,700 --> 00:39:27,130


1028
00:39:27,130 --> 00:39:30,670
编译为机器代码，因此 Apple

1029
00:39:30,670 --> 00:39:32,619
在这方面投入了大量资金，他们

1030
00:39:32,619 --> 00:39:35,489
在 2004-2005 年聘请了 UIUC 的主要人员之一

1031
00:39:35,489 --> 00:39:38,729
， 他基本上运行他们的

1032
00:39:38,729 --> 00:39:41,259
你知道他们是他们所做的所有工作

1033
00:39:41,259 --> 00:39:42,970
我是叮当声和法学学士我以此为基础

1034
00:39:42,970 --> 00:39:45,309
所以再次发生的事情是我们

1035
00:39:45,309 --> 00:39:46,869
可以随意使用任何语言 uage

1036
00:39:46,869 --> 00:39:49,150
并将其转换为

1037
00:39:49,150 --> 00:39:50,979
这种看起来像汇编的低级 IR，

1038
00:39:50,979 --> 00:39:52,960
但它是专门为 LLVM 提供的

1039
00:39:52,960 --> 00:39:54,849
那种虚拟机设计的

1040
00:39:54,849 --> 00:39:57,279
，然后在

1041
00:39:57,279 --> 00:39:59,259
后端，他们可以将该 IR 编译成

1042
00:39:59,259 --> 00:40:02,170
任何目标 target is a is

1043
00:40:02,170 --> 00:40:03,999
以便它支持 x86 或支持 arm，因此

1044
00:40:03,999 --> 00:40:05,529
您可以将任何任意语言

1045
00:40:05,529 --> 00:40:07,269
转换为 IR，然后将其

1046
00:40:07,269 --> 00:40:10,839
吐出到任何 CPU 我说嗯，

1047
00:40:10,839 --> 00:40:13,630
M 的 L 支持正确

1048
00:40:13,630 --> 00:40:16,960
但要理解的重要事情是 在

1049
00:40:16,960 --> 00:40:19,479
hyper hyper 的情况下，C++ 代码会

1050
00:40:19,479 --> 00:40:23,200
直接承认他的 L，所以俳句正在使用

1051
00:40:23,200 --> 00:40:24,789
无缝代码生成无缝

1052
00:40:24,789 --> 00:40:26,769
代码 Piper 让 Cisco 的 Steve

1053
00:40:26,769 --> 00:40:30,579
生成 IR，但系统的其余部分

1054
00:40:30,579 --> 00:40:32,680
就像在俳句中一样不需要

1055
00:40:32,680 --> 00:40:35,789
使用与生成查询计划相同的语言编写

1056
00:40:35,789 --> 00:40:39,940
，因此

1057
00:40:39,940 --> 00:40:42,190
hyper 的其余部分是用 C++ 编写的，

1058
00:40:42,190 --> 00:40:45,640
它仍然可以生成 C++ 代码，但是您

1059
00:40:45,640 --> 00:40:47,559
必须

1060
00:40:47,559 --> 00:40:49,390
像我所说的那样修改函数名称和类名称 您

1061
00:40:49,390 --> 00:40:51,160
知道 LM 不会这样做，因为您是

1062
00:40:51,160 --> 00:40:53,079
免费的，但是您仍然可以将 IR 代码

1063
00:40:53,079 --> 00:40:55,690
调用到您最简单的代码中，您仍然

1064
00:40:55,690 --> 00:40:57,309
可以从在同一个基础上运行的所有内容获得相同的好处，

1065
00:40:57,309 --> 00:41:01,059
所以

1066
00:41:01,059 --> 00:41:02,319
现在让我们回到这个查询计划

1067
00:41:02,319 --> 00:41:05,950
看看我们将如何生成一个源代码

1068
00:41:05,950 --> 00:41:10,059
来执行

1069
00:41:10,059 --> 00:41:13,809
hyper 中的 push 和 push up 方法，所以现在对于

1070
00:41:13,809 --> 00:41:14,859
这些将这些不同的

1071
00:41:14,859 --> 00:41:16,210
for 循环视为不同的管道，

1072
00:41:16,210 --> 00:41:18,160
并且管道的想法是

1073
00:41:18,160 --> 00:41:20,890
它的 一个 for 循环或一堆 for 循环

1074
00:41:20,890 --> 00:41:22,180
，可以采用单个元组并尽可能地继续

1075
00:41:22,180 --> 00:41:24,249
处理它，

1076
00:41:24,249 --> 00:41:26,229
首先进入查询计划，所以如果我们

1077
00:41:26,229 --> 00:41:28,180
在 a 上进行缩放只是第四个打开 a

1078
00:41:28,180 --> 00:41:30,069
然后我们评估 一个谓词，

1079
00:41:30,069 --> 00:41:33,640
然后我们可以将它具体化到我们的

1080
00:41:33,640 --> 00:41:36,700
哈希表中，然后现在我们这样做我们

1081
00:41:36,700 --> 00:41:39,579
跳到管道 B 然后我们可以

1082
00:41:39,579 --> 00:41:40,869
扫描那个层，

1083
00:41:40,869 --> 00:41:43,089
然后我们可以将其具体

1084
00:41:43,089 --> 00:41:45,640
化到我们的哈希表中

1085
00:41:45,640 --> 00:41:48,339
聚合表的存在但

1086
00:41:48,339 --> 00:41:50,740
没有 在管道中看到我们有三个

1087
00:41:50,740 --> 00:41:51,490
嵌套的 for 循环，

1088
00:41:51,490 --> 00:41:54,009
所以我们将在 C 中获取一个元组，

1089
00:41:54,009 --> 00:41:58,569
然后尝试在 B 上对它进行连接

1090
00:41:58,569 --> 00:42:00,849
，如果匹配，我们尝试

1091
00:42:00,849 --> 00:42:03,369
在 on 上对它进行连接 a

1092
00:42:03,369 --> 00:42:05,380
然后那是正确的然后

1093
00:42:05,380 --> 00:42:07,990
我们可以把它吐出来作为我们的输出所以对于

1094
00:42:07,990 --> 00:42:10,839
一个元组和 C 我们可以做 join

1095
00:42:10,839 --> 00:42:12,309
和 a 加入 B 然后

1096
00:42:12,309 --> 00:42:13,990
在必要时产生一个输出我们没有任何

1097
00:42:13,990 --> 00:42:21,519
开关 转向另一个元组 是的，他的

1098
00:42:21,519 --> 00:42:23,230
问题是是否有多种方法可以

1099
00:42:23,230 --> 00:42:26,410
生成这些管道，如果是这样，

1100
00:42:26,410 --> 00:42:28,059
是否总会有一种最佳

1101
00:42:28,059 --> 00:42:30,599
方法来做到这一点

1102
00:42:31,769 --> 00:42:34,539
典型的优化策略是

1103
00:42:34,539 --> 00:42:40,599
，你好，有两

1104
00:42:40,599 --> 00:42:42,670
件事 生成

1105
00:42:42,670 --> 00:42:44,589
这个查询计划的不同方法是的，

1106
00:42:44,589 --> 00:42:45,819
因为那是采石场优化器

1107
00:42:45,819 --> 00:42:48,940
所做的，所以从我们这门课的角度来看，

1108
00:42:48,940 --> 00:42:50,769
我们只是想说

1109
00:42:50,769 --> 00:42:53,470
优化器给了我们一个查询计划

1110
00:42:53,470 --> 00:42:55,480
我们如何为它生成管道，在这种

1111
00:42:55,480 --> 00:42:57,819
情况下它是 一个非常简单的启发式方法来

1112
00:42:57,819 --> 00:42:59,559
决定这些 它

1113
00:42:59,559 --> 00:43:01,660
应该看起来像的管道以及

1114
00:43:01,660 --> 00:43:04,720
您执行此操作的通常方式是从

1115
00:43:04,720 --> 00:43:08,319
树的左侧开始，它们有任何

1116
00:43:08,319 --> 00:43:10,180
连接，这是向连接馈送的管道

1117
00:43:10,180 --> 00:43:12,190
，然后在右侧，您

1118
00:43:12,190 --> 00:43:14,079
尝试让管道全部运行

1119
00:43:14,079 --> 00:43:15,970
直到你撞到一个管道断路器

1120
00:43:15,970 --> 00:43:19,180
所以转换过程来介绍

1121
00:43:19,180 --> 00:43:20,619
你的问题是的，

1122
00:43:20,619 --> 00:43:22,480
我可以通过不同的方式从纤毛

1123
00:43:22,480 --> 00:43:24,160
财政计划中生成管道，就像我可以在这里有一条管道

1124
00:43:24,160 --> 00:43:26,470
，有一条新管道，这将是

1125
00:43:26,470 --> 00:43:28,359
愚蠢的 但我可以这样做，但是

1126
00:43:28,359 --> 00:43:29,710
为给定的物理计划找到最佳方案的启发式方法

1127
00:43:29,710 --> 00:43:32,109
是非常

1128
00:43:32,109 --> 00:43:34,960
简单的，更难的决定是

1129
00:43:34,960 --> 00:43:37,329
我应该像所有这些一样加入 ab 或 ba

1130
00:43:37,329 --> 00:43:41,160
好

1131
00:43:41,160 --> 00:43:44,499
所以再次hyper正在做的事情hyper

1132
00:43:44,499 --> 00:43:46,809
将采取代替 生成

1133
00:43:46,809 --> 00:43:48,579
伪代码，他们将生成 ll

1134
00:43:48,579 --> 00:43:50,999
比 ir 完全按照这些步骤将其

1135
00:43:50,999 --> 00:43:53,739
编译为一个巨大的函数，

1136
00:43:53,739 --> 00:43:55,060
所有管道都到了

1137
00:43:55,060 --> 00:43:57,250
，然后现在只是阶段，

1138
00:43:57,250 --> 00:43:58,420
我将运行这个 for 循环

1139
00:43:58,420 --> 00:44:00,220
现在完成后我跳到这部分，或者

1140
00:44:00,220 --> 00:44:01,630
它实际上不是跳转，只是你

1141
00:44:01,630 --> 00:44:03,220
知道只是顺序执行然后我

1142
00:44:03,220 --> 00:44:04,930
做这个 for 循环然后我做那个 for

1143
00:44:04,930 --> 00:44:06,190
循环然后我为管道做最后一个 for 循环

1144
00:44:06,190 --> 00:44:10,870
所以 在我们的新

1145
00:44:10,870 --> 00:44:12,520
系统中我们实际上可以

1146
00:44:12,520 --> 00:44:14,710


1147
00:44:14,710 --> 00:44:16,030
单独编译这些

1148
00:44:16,030 --> 00:44:18,010


1149
00:44:18,010 --> 00:44:19,390


1150
00:44:19,390 --> 00:44:21,040


1151
00:44:21,040 --> 00:44:22,960


1152
00:44:22,960 --> 00:44:28,990
管道 将它发射到两个 LLVM 所以让我们

1153
00:44:28,990 --> 00:44:30,730
在 Midsummer

1154
00:44:30,730 --> 00:44:33,820
比较两个不同版本的

1155
00:44:33,820 --> 00:44:36,490
超级之前看一些，一个是做 LLM IR，然后

1156
00:44:36,490 --> 00:44:38,200
一个是做高 Q 方法

1157
00:44:38,200 --> 00:44:39,700
，你吐出来所以 Fusco

1158
00:44:39,700 --> 00:44:42,160
然后是测验第二个 GCC 然后 我们

1159
00:44:42,160 --> 00:44:43,600
有向量明智的方法，它使用

1160
00:44:43,600 --> 00:44:46,240
他提到的预编译谓词方法，他

1161
00:44:46,240 --> 00:44:49,840
提到 Monet DB 会生成它

1162
00:44:49,840 --> 00:44:52,000
生成看起来像 IR 的东西，但是

1163
00:44:52,000 --> 00:44:53,230
他们有一个解释器，他们

1164
00:44:53,230 --> 00:44:54,430
不采取行动 最终编译成

1165
00:44:54,430 --> 00:44:57,210
机器码，然后 Oracle 什么都不做，

1166
00:44:57,210 --> 00:44:59,230
它只是解释查询计划，

1167
00:44:59,230 --> 00:45:00,580
而且我们总是以同样的方式正确地做这件事，

1168
00:45:00,580 --> 00:45:05,140
所以这也不是衡量

1169
00:45:05,140 --> 00:45:06,640
编译时间这只是

1170
00:45:06,640 --> 00:45:08,590
说假设我提前编译了所有东西

1171
00:45:08,590 --> 00:45:11,260
有多快 我可以去吗

1172
00:45:11,260 --> 00:45:14,230
，因为在 lol M 版本的 hyper 的情况下，

1173
00:45:14,230 --> 00:45:16,090
他们正在做更

1174
00:45:16,090 --> 00:45:19,990
积极的流水线，他们

1175
00:45:19,990 --> 00:45:21,910
确保流水线尽可能长

1176
00:45:21,910 --> 00:45:24,220
，他们可以选择

1177
00:45:24,220 --> 00:45:26,590
比这个版本稍好

1178
00:45:26,590 --> 00:45:28,030
的 Oracle 总是会再次失败，

1179
00:45:28,030 --> 00:45:28,840
因为它总是对 q1 q1

1180
00:45:28,840 --> 00:45:32,430
的类似情况进行正确的解释

1181
00:45:32,430 --> 00:45:36,970
是因为它没有

1182
00:45:36,970 --> 00:45:38,950
连接 它是一个单一的表 它只是

1183
00:45:38,950 --> 00:45:41,590
一堆聚合 所以

1184
00:45:41,590 --> 00:45:43,360
如果你指导和

1185
00:45:43,360 --> 00:45:46,480
q5 是 a 的所有内容就像五个或六个

1186
00:45:46,480 --> 00:45:49,570
连接，输出非常简单，因此

1187
00:45:49,570 --> 00:45:51,700
您不会获得太大的好处，

1188
00:45:51,700 --> 00:45:53,740
因为执行此查询的主要成本

1189
00:45:53,740 --> 00:45:55,210
始终是 b

1190
00:45:55,210 --> 00:45:58,900
无论如何你都会预编译的连接你

1191
00:45:58,900 --> 00:46:00,670
知道要探测一个哈希表，例如

1192
00:46:00,670 --> 00:46:02,710
调用哈希函数，所以在这种情况下，

1193
00:46:02,710 --> 00:46:04,240
你不会得到那么大的

1194
00:46:04,240 --> 00:46:06,640
好处，因为事情的枪械方面是

1195
00:46:06,640 --> 00:46:07,770


1196
00:46:07,770 --> 00:46:12,300
好的，所以现在让我们看看 在

1197
00:46:12,300 --> 00:46:14,400
编译成本上，所以现在这不是一个

1198
00:46:14,400 --> 00:46:16,020
真正的像苹果与苹果的比较，

1199
00:46:16,020 --> 00:46:19,050
因为我是茶，我喜欢

1200
00:46:19,050 --> 00:46:21,360
从俳句纸中获取数字并将

1201
00:46:21,360 --> 00:46:24,240
其与超级结果混合在一起，

1202
00:46:24,240 --> 00:46:25,710
因此它们不会在相同的情况下运行

1203
00:46:25,710 --> 00:46:27,750
硬件我认为超级家伙

1204
00:46:27,750 --> 00:46:30,150
像 Z 一样运行

1205
00:46:30,150 --> 00:46:31,790
在 Core 2 Duo 上，就像你知道的

1206
00:46:31,790 --> 00:46:34,800
2008-2009 比例因子仍然

1207
00:46:34,800 --> 00:46:37,020
相同他们仍在编译相同的 TP

1208
00:46:37,020 --> 00:46:38,880
CH 查询，这有点像 相对

1209
00:46:38,880 --> 00:46:40,590
差异很重要，

1210
00:46:40,590 --> 00:46:42,090
因为他们有一个稍微更新的 CPU，

1211
00:46:42,090 --> 00:46:43,950
你知道它不会神奇地变得

1212
00:46:43,950 --> 00:46:45,930
更快，所以这只是告诉你

1213
00:46:45,930 --> 00:46:49,320
不必然后解析你的 C++ 代码，

1214
00:46:49,320 --> 00:46:52,320
你知道你知道你的 a ste 和

1215
00:46:52,320 --> 00:46:54,240
你的分词器和 然后编译 它就像

1216
00:46:54,240 --> 00:46:56,100
你和 GCC 或 clang 一样，但是

1217
00:46:56,100 --> 00:46:58,260
直接发射 IR 然后

1218
00:46:58,260 --> 00:47:00,030
能够在 LLVM 内部运行你的操作，

1219
00:47:00,030 --> 00:47:02,730
这将使你知道

1220
00:47:02,730 --> 00:47:05,100


1221
00:47:05,100 --> 00:47:10,350
比 GCC 快几个数量级或者这些一个数量级比 GCC 快所以

1222
00:47:10,350 --> 00:47:13,350
出于这个原因我 认为元素

1223
00:47:13,350 --> 00:47:14,910
编译方法是正确的方法

1224
00:47:14,910 --> 00:47:16,290
，如果你有一个基于睡眠丢失的

1225
00:47:16,290 --> 00:47:18,990
引擎，看起来像一些

1226
00:47:18,990 --> 00:47:21,090
基于 Java 的数据库系统的例子，他们会做

1227
00:47:21,090 --> 00:47:22,380
同样的事情，他们会直接 MIT Java

1228
00:47:22,380 --> 00:47:24,690
字节码而不是我知道

1229
00:47:24,690 --> 00:47:27,440
发射 Java 代码然后编译就可以了

1230
00:47:27,440 --> 00:47:32,040
所以这个编译成本是

1231
00:47:32,040 --> 00:47:35,730
从哪里来的 所以你知道 37 毫秒

1232
00:47:35,730 --> 00:47:38,400
它不像 400 毫秒那么糟糕但是

1233
00:47:38,400 --> 00:47:42,810
它仍然很多我的麦克风我的查询

1234
00:47:42,810 --> 00:47:44,310
一些查询可以在不到一

1235
00:47:44,310 --> 00:47:45,420
毫秒的时间内运行但我需要 37

1236
00:47:45,420 --> 00:47:47,130
假设我不能提前兑现，编译它需要几毫秒，

1237
00:47:47,130 --> 00:47:49,920
那么我并没有

1238
00:47:49,920 --> 00:47:52,980
真正得到任何好处，所以

1239
00:47:52,980 --> 00:47:55,619
这里发生了什么，所以问题

1240
00:47:55,619 --> 00:47:57,150
是编译时间将

1241
00:47:57,150 --> 00:47:59,790
取决于 查询大小，所以这意味着

1242
00:47:59,790 --> 00:48:01,230
我们拥有的连接数然后我

1243
00:48:01,230 --> 00:48:03,240
说我们有聚合的数量我刚刚

1244
00:48:03,240 --> 00:48:05,040
看到查询是多么复杂，

1245
00:48:05,040 --> 00:48:06,630
我们尝试做的事情越多，

1246
00:48:06,630 --> 00:48:09,930
编译时间就会增加，现在

1247
00:48:09,930 --> 00:48:11,700
它是排序的

1248
00:48:11,700 --> 00:48:15,270
如果我的查询要运行 30

1249
00:48:15,270 --> 00:48:17,369
秒，那么这种权衡之间的权衡谁在乎是否需要

1250
00:48:17,369 --> 00:48:18,330
额外的一秒来编译，因为我

1251
00:48:18,330 --> 00:48:20,369
仍然会在我们看到的性能数据方面取得巨大的胜利

1252
00:48:20,369 --> 00:48:21,839


1253
00:48:21,839 --> 00:48:24,239
/ Oracle 但是 对于其他

1254
00:48:24,239 --> 00:48:27,390
非常快的查询，

1255
00:48:27,390 --> 00:48:29,279
他们需要处理的数据量可能会

1256
00:48:29,279 --> 00:48:30,589
非常快，因为它是一个平静的存储，

1257
00:48:30,589 --> 00:48:32,609
您知道及时完成可能会

1258
00:48:32,609 --> 00:48:35,849
开始吃掉挤出时间，因此

1259
00:48:35,849 --> 00:48:38,099
对于所有应用程序来说，这都赢了

1260
00:48:38,099 --> 00:48:38,900
不是问题，我

1261
00:48:38,900 --> 00:48:42,359
猜猜为什么我们会不关心

1262
00:48:42,359 --> 00:48:48,059
滚动 TP 说更少的加入是

1263
00:48:48,059 --> 00:48:56,190
的，这是其中之一是的，但正如你

1264
00:48:56,190 --> 00:48:57,749
所说的一样，所以他说

1265
00:48:57,749 --> 00:48:59,339
执行查询的复杂性

1266
00:48:59,339 --> 00:49:01,559
相对容易比较 到或实验室 这

1267
00:49:01,559 --> 00:49:03,569
意味着它们的关节较少，所以是

1268
00:49:03,569 --> 00:49:05,819
的，燕麦任何查询都不会那么

1269
00:49:05,819 --> 00:49:07,469
复杂，你不会做一百个

1270
00:49:07,469 --> 00:49:09,359
表连接，就像膝盖

1271
00:49:09,359 --> 00:49:11,609
查找安第斯山脉从索引中记录拇指，然后

1272
00:49:11,609 --> 00:49:13,200
去了解一些基本信息

1273
00:49:13,200 --> 00:49:14,700
和 也许与外键

1274
00:49:14,700 --> 00:49:17,569
表进行连接还有另一个原因以及

1275
00:49:17,569 --> 00:49:19,859
精确缓存，并且所有 T

1276
00:49:19,859 --> 00:49:20,999
应用程序实际上并不是

1277
00:49:20,999 --> 00:49:23,369
一遍又一遍的相同查询，就像我

1278
00:49:23,369 --> 00:49:25,140
加载网页和亚马逊他们进行查询

1279
00:49:25,140 --> 00:49:27,269
查找和索引以获取 我的记录他

1280
00:49:27,269 --> 00:49:28,920
去亚马逊它是相同的查询

1281
00:49:28,920 --> 00:49:30,930
只是一个不同的键所以你可以缓存

1282
00:49:30,930 --> 00:49:32,910
它作为准备好的语句

1283
00:49:32,910 --> 00:49:34,380
或者你知道预编译的代码

1284
00:49:34,380 --> 00:49:36,359
我们已经为OLAP一遍又一遍地调用它

1285
00:49:36,359 --> 00:49:40,349
这将是一个

1286
00:49:40,349 --> 00:49:42,329
问题 但是当

1287
00:49:42,329 --> 00:49:44,819
你知道你是否知道还没有决定的时候，权衡就在那里，

1288
00:49:44,819 --> 00:49:46,469
这已经足够编译了，这

1289
00:49:46,469 --> 00:49:48,150
只是解释，很难

1290
00:49:48,150 --> 00:49:52,650
弄清楚，因为在编译器

1291
00:49:52,650 --> 00:49:53,819
级别再生成一个，我们正在做代码

1292
00:49:53,819 --> 00:49:57,329
gen 我们有一个粗略的想法

1293
00:49:57,329 --> 00:49:59,579
我们将访问多少数据但是这些估计

1294
00:49:59,579 --> 00:50:06,269
总是非常错误是的

1295
00:50:06,269 --> 00:50:11,729
对不起忘记他她是什么并且在内存中

1296
00:50:11,729 --> 00:50:14,249
如果它在内存中那么它可以非常

1297
00:50:14,249 --> 00:50:21,150
快正确我们可以像这样运行 我

1298
00:50:21,150 --> 00:50:22,529
想我认为这就像比例因子

1299
00:50:22,529 --> 00:50:25,979
1 所以这就像你知道这

1300
00:50:25,979 --> 00:50:27,450
是在 35 毫秒内读取 1 GB 的数据

1301
00:50:27,450 --> 00:50:30,809
所以乘以它你知道

1302
00:50:30,809 --> 00:50:34,069
1024 TB

1303
00:50:34,130 --> 00:50:36,390
和内存是

1304
00:50:36,390 --> 00:50:37,440
基于磁盘的系统的问题，距离总是在变化

1305
00:50:37,440 --> 00:50:39,359
压垮你，所以它不那么重要，这就是

1306
00:50:39,359 --> 00:50:40,859
为什么 Oracle

1307
00:50:40,859 --> 00:50:43,280
可能永远不会这样做的部分原因，至少对于

1308
00:50:43,280 --> 00:50:50,579
传统的并且基于系统正确的

1309
00:50:50,579 --> 00:50:53,760
是在内存中编译时间

1310
00:50:53,760 --> 00:50:55,109
或者你知道所有这些函数

1311
00:50:55,109 --> 00:50:59,720
现在查找我的瓶颈 有了这个，我

1312
00:50:59,869 --> 00:51:02,640
也会说喜欢 Postgres 是一个

1313
00:51:02,640 --> 00:51:04,859
系统，我们将在一秒钟内看到这一点，他们

1314
00:51:04,859 --> 00:51:07,950
现在也进行编译，

1315
00:51:07,950 --> 00:51:12,690
就像 2018 年一样，但最后他们有这个

1316
00:51:12,690 --> 00:51:15,780
小参数，您可以设置它来

1317
00:51:15,780 --> 00:51:17,160
做出关于 shoul 的决定 d 我实际上

1318
00:51:17,160 --> 00:51:18,540
是否编译基于额外

1319
00:51:18,540 --> 00:51:19,470
应该花费的查询它实际上

1320
00:51:19,470 --> 00:51:22,800
会是什么所以让我得到实际的给它

1321
00:51:22,800 --> 00:51:24,180
我要谈论什么 hyper

1322
00:51:24,180 --> 00:51:27,329
是什么 Hyper

1323
00:51:27,329 --> 00:51:30,329
在这里要做的事情的动机是他们试图

1324
00:51:30,329 --> 00:51:31,380
只是 像我们一样，他们试图支持

1325
00:51:31,380 --> 00:51:32,760
有线协议的帖子，并且帖子

1326
00:51:32,760 --> 00:51:34,890
有目录，所以有

1327
00:51:34,890 --> 00:51:37,440
一个相反的常用工具调用 PG admin，

1328
00:51:37,440 --> 00:51:40,170
它就像一个 PHP 界面来配置

1329
00:51:40,170 --> 00:51:42,480
你的 Postgres 安装，所以

1330
00:51:42,480 --> 00:51:45,240
所有这些像这些你知道的

1331
00:51:45,240 --> 00:51:48,089
视觉 数据库工具的工作是，当

1332
00:51:48,089 --> 00:51:49,170
你打开它们时，它们会连接到

1333
00:51:49,170 --> 00:51:50,880
数据库，它会立即运行一个查询

1334
00:51:50,880 --> 00:51:52,410
，对目录进行一堆查询，并

1335
00:51:52,410 --> 00:51:53,940
找出哪些表我有哪些

1336
00:51:53,940 --> 00:51:55,530
列我有哪些索引，

1337
00:51:55,530 --> 00:51:57,780
以便他们可以公开 到 DBA 来

1338
00:51:57,780 --> 00:52:00,450
管理数据库，所以当你打开

1339
00:52:00,450 --> 00:52:02,880
它时，当你在超级情况下，当

1340
00:52:02,880 --> 00:52:04,680
你打开 PGM 并在超级点上

1341
00:52:04,680 --> 00:52:07,440
时，一开始就会有这么长的停顿，

1342
00:52:07,440 --> 00:52:09,810
我们正在谈论 可能需要

1343
00:52:09,810 --> 00:52:13,109
10 秒，因为 PG 管理员触发了

1344
00:52:13,109 --> 00:52:14,730
所有这些查询，然后必须

1345
00:52:14,730 --> 00:52:16,470
通过提升和编译器运行只是为了

1346
00:52:16,470 --> 00:52:17,490
弄清楚您将拥有哪些表，

1347
00:52:17,490 --> 00:52:18,900
而周围的关键是常规后期

1348
00:52:18,900 --> 00:52:20,250
休息，它不进行任何

1349
00:52:20,250 --> 00:52:22,170
编译，所以当 你打开 PG 管理员

1350
00:52:22,170 --> 00:52:23,579
它会更快你知道

1351
00:52:23,579 --> 00:52:27,119
启动更快所以要解决这个问题所以

1352
00:52:27,119 --> 00:52:29,190
让我们这样做，这些查询不是那么

1353
00:52:29,190 --> 00:52:30,839
复杂，但只有很多，

1354
00:52:30,839 --> 00:52:32,730
而且编译成本一直在

1355
00:52:32,730 --> 00:52:37,710
吃东西 所以

1356
00:52:37,710 --> 00:52:39,450
这是 2018 年

1357
00:52:39,450 --> 00:52:41,880
在 ICD 中获得最佳论文的超级家伙发表的一篇论文我认为

1358
00:52:41,880 --> 00:52:45,510
这实际上是一个

1359
00:52:45,510 --> 00:52:46,810
非常好的主意

1360
00:52:46,810 --> 00:52:50,650
我们尝试在大部队中这样做但是当

1361
00:52:50,650 --> 00:52:52,360
我们杀死大部队时我们没有

1362
00:52:52,360 --> 00:52:54,400
现在我们做一些不同的事情，我们

1363
00:52:54,400 --> 00:52:55,390
在他们正在做的事情上做一些稍微不同的

1364
00:52:55,390 --> 00:52:57,340
事情，但这里的想法是这是

1365
00:52:57,340 --> 00:52:59,530
一个非常好的想法，所以他们

1366
00:52:59,530 --> 00:53:01,210
要做的是当出现查询时，他们

1367
00:53:01,210 --> 00:53:03,520
仍然会像你一样生成 IR

1368
00:53:03,520 --> 00:53:05,920
通常会但是然后rath 不是

1369
00:53:05,920 --> 00:53:08,800
触发 LLVM 编译器等待

1370
00:53:08,800 --> 00:53:10,270
它完成然后开始

1371
00:53:10,270 --> 00:53:12,430
执行查询，他们会有一个 IR

1372
00:53:12,430 --> 00:53:14,950
解释器认为这就像一个 VM

1373
00:53:14,950 --> 00:53:17,110
，然后可以解释那个 IR 并

1374
00:53:17,110 --> 00:53:20,860
开始执行它，所以他们有

1375
00:53:20,860 --> 00:53:22,480
德国指南 Thomas 在两周内以父级编写它，

1376
00:53:22,480 --> 00:53:24,910
您基本上

1377
00:53:24,910 --> 00:53:27,400
将 LVM 吐出的字节码和

1378
00:53:27,400 --> 00:53:29,830
它的 IR 和您实现一个虚拟

1379
00:53:29,830 --> 00:53:31,660
机来执行它，所以现在它将

1380
00:53:31,660 --> 00:53:33,910


1381
00:53:33,910 --> 00:53:35,590
对系统的其余部分进行所有相同的函数调用 make all 与通常在 cop-out 引擎中一样

1382
00:53:35,590 --> 00:53:37,450
调用所有相同的操作数和

1383
00:53:37,450 --> 00:53:38,920
谓词，

1384
00:53:38,920 --> 00:53:41,650
但它将其作为解释器运行，

1385
00:53:41,650 --> 00:53:43,390
因此

1386
00:53:43,390 --> 00:53:44,470
您不必完全构建两个单独的

1387
00:53:44,470 --> 00:53:46,600
引擎，您只需让

1388
00:53:46,600 --> 00:53:47,680
解释器执行相同的

1389
00:53:47,680 --> 00:53:49,600
指令 编译后的版本

1390
00:53:49,600 --> 00:53:52,240
很好，所以现在解释器正在

1391
00:53:52,240 --> 00:53:54,760
运行，然后在后台开始

1392
00:53:54,760 --> 00:53:57,040
编译查询，然后当

1393
00:53:57,040 --> 00:53:59,170
编译的查询准备好

1394
00:53:59,170 --> 00:54:01,180
时，如果 查询仍在运行以

1395
00:54:01,180 --> 00:54:04,780
替换解释器执行，所以

1396
00:54:04,780 --> 00:54:06,220
他们再次使用少量，

1397
00:54:06,220 --> 00:54:08,590
所以会发生的是每次一个

1398
00:54:08,590 --> 00:54:11,020
线程，一个工作线程完成

1399
00:54:11,020 --> 00:54:13,120
一个少量时，它会检查一些标志并

1400
00:54:13,120 --> 00:54:15,550
说我的编译版本是否准备好，如果是，

1401
00:54:15,550 --> 00:54:17,890
那么 调用，如果没有，那么我只是继续

1402
00:54:17,890 --> 00:54:19,890
运行可能会在解释器中运行，

1403
00:54:19,890 --> 00:54:22,090
所以现在对于那些可能需要

1404
00:54:22,090 --> 00:54:24,220
很长时间编译但

1405
00:54:24,220 --> 00:54:27,670
在这些情况下执行得非常快的查询，您

1406
00:54:27,670 --> 00:54:28,870
可以完成它们，只需执行

1407
00:54:28,870 --> 00:54:30,940
解释器而不是等待 很长的

1408
00:54:30,940 --> 00:54:33,730
编译时间要完成，所以他们

1409
00:54:33,730 --> 00:54:36,940
实际上要做的通常是三个

1410
00:54:36,940 --> 00:54:38,290
阶段，不同类型的

1411
00:54:38,290 --> 00:54:40,180
编译通常可以根据什么类型的

1412
00:54:40,180 --> 00:54:42,880
优化来完成

1413
00:54:42,880 --> 00:54:44,380
，续集查询会再次出现，所以在

1414
00:54:44,380 --> 00:54:45,820
他们的情况下，他们的优化器可能 需要

1415
00:54:45,820 --> 00:54:49,180
你知道 0.2 毫秒，然后他们有

1416
00:54:49,180 --> 00:54:51,130
这个 cochon 引擎，这需要 0.7

1417
00:54:51,130 --> 00:54:51,820
毫秒，

1418
00:54:51,820 --> 00:54:53,290
因为你正在遍历

1419
00:54:53,290 --> 00:54:56,170
树吐出 IR 然后 t 他

1420
00:54:56,170 --> 00:54:57,520
要做的第一件事是，

1421
00:54:57,520 --> 00:55:00,210
他们会将 IR 传递给

1422
00:55:00,210 --> 00:55:01,770
这个字节码编译器或解释器

1423
00:55:01,770 --> 00:55:05,400
并执行它，因此某些情况

1424
00:55:05,400 --> 00:55:07,380
可能会在 0.4 毫秒内完成，

1425
00:55:07,380 --> 00:55:09,839
对不起，它是编译器，所以您

1426
00:55:09,839 --> 00:55:11,190
正在使用 IR 并将其转换为

1427
00:55:11,190 --> 00:55:12,859
字节码，然后他们可以解释

1428
00:55:12,859 --> 00:55:17,520
这需要四毫秒，然后 IR

1429
00:55:17,520 --> 00:55:19,589
也会转到 Allium 编译器，但

1430
00:55:19,589 --> 00:55:22,440
他们关闭了所有优化过程

1431
00:55:22,440 --> 00:55:24,630
，例如展开循环和窥视孔

1432
00:55:24,630 --> 00:55:26,819
优化，所有这些都已关闭，

1433
00:55:26,819 --> 00:55:28,920
以便在六毫秒内完成 现在

1434
00:55:28,920 --> 00:55:30,450
它会比

1435
00:55:30,450 --> 00:55:32,250
这个快一点，所以当这个完成时，

1436
00:55:32,250 --> 00:55:34,440
你可以用这个替换它，但是

1437
00:55:34,440 --> 00:55:35,910
如果它运行更

1438
00:55:35,910 --> 00:55:38,309
长时间，那么他们也会运行它

1439
00:55:38,309 --> 00:55:40,109
通过 hello 的所有优化通道 并

1440
00:55:40,109 --> 00:55:42,240
提供现在你正在做的像死

1441
00:55:42,240 --> 00:55:43,680
代码消除和子表达式

1442
00:55:43,680 --> 00:55:46,200
消除以及窥视孔的东西

1443
00:55:46,200 --> 00:55:47,640
然后他们可以通过

1444
00:55:47,640 --> 00:55:49,710
编译器运行它然后它挑选出x86

1445
00:55:49,710 --> 00:55:53,069
代码所以 我的想法是，如果

1446
00:55:53,069 --> 00:55:54,540
字节码

1447
00:55:54,540 --> 00:55:57,869
在你知道之前完成，我就

1448
00:55:57,869 --> 00:56:00,990
立即开始解释，如果这件事

1449
00:56:00,990 --> 00:56:03,359
在这个借口执行完成之前

1450
00:56:03,359 --> 00:56:04,470
完成，我就完成了，然后我就开始执行

1451
00:56:04,470 --> 00:56:06,900
这个，但我也把这个这个

1452
00:56:06,900 --> 00:56:09,690
这个这个 通过然后如果这是

1453
00:56:09,690 --> 00:56:11,400
完成如果这在我得到这个时还没有完成

1454
00:56:11,400 --> 00:56:13,890
那么我用那个替换它所以

1455
00:56:13,890 --> 00:56:15,599
你在某种程度上分期

1456
00:56:15,599 --> 00:56:19,020
执行引擎将获得多快并且这个想法

1457
00:56:19,020 --> 00:56:20,880
是而不是等待 这件事要

1458
00:56:20,880 --> 00:56:22,710
完成，在这个特定的例子中

1459
00:56:22,710 --> 00:56:24,119
25 毫秒加 70

1460
00:56:24,119 --> 00:56:25,859
毫秒，而不是

1461
00:56:25,859 --> 00:56:27,630
在这段时间内执行

1462
00:56:27,630 --> 00:56:29,220


1463
00:56:29,220 --> 00:56:31,500


1464
00:56:31,500 --> 00:56:36,720
任何

1465
00:56:36,720 --> 00:56:39,359
工作 cpc-h 再次用于这三个阶段，

1466
00:56:39,359 --> 00:56:41,099
这将向您展示

1467
00:56:41,099 --> 00:56:42,980


1468
00:56:42,980 --> 00:56:45,359
字节码解释器

1469
00:56:45,359 --> 00:56:46,920
或未优化的 LVM 与优化的

1470
00:56:46,920 --> 00:56:48,960
LLVM 之间性能的相对差异，因此您再次获得

1471
00:56:48,960 --> 00:56:50,760
在

1472
00:56:50,760 --> 00:56:52,530
优化的编译版本和

1473
00:56:52,530 --> 00:56:55,530
解释器之间有一个自动的两个差异，这就是为什么

1474
00:56:55,530 --> 00:56:57,359
你想要同时获得其他好处的原因

1475
00:56:57,359 --> 00:56:58,380
，他们

1476
00:56:58,380 --> 00:57:00,900
在论文中没有谈论那么多，因为

1477
00:57:00,900 --> 00:57:03,030
它们又是同一只眼睛

1478
00:57:03,030 --> 00:57:05,970


1479
00:57:05,970 --> 00:57:07,770


1480
00:57:07,770 --> 00:57:10,410
如果现在我生成该 IR 的方式存在错误，

1481
00:57:10,410 --> 00:57:13,220
而不是

1482
00:57:13,220 --> 00:57:15,440
您知道查看

1483
00:57:15,440 --> 00:57:17,300
查询计划的编译版本，那么字节码正在执行与此处执行的相同查询，在这种情况下

1484
00:57:17,300 --> 00:57:18,650
您不会 有调试符号

1485
00:57:18,650 --> 00:57:20,660


1486
00:57:20,660 --> 00:57:22,280
当你崩溃时你不会有堆栈跟踪你只是要

1487
00:57:22,280 --> 00:57:24,740
进入一个程序集你至少可以

1488
00:57:24,740 --> 00:57:26,060
通过这个解释器并

1489
00:57:26,060 --> 00:57:28,930
找出为什么你的查询中断

1490
00:57:28,930 --> 00:57:46,070
是正确的团队是如果有一个

1491
00:57:46,070 --> 00:57:49,340
如果在将 IR 应用

1492
00:57:49,340 --> 00:57:51,590
到字节码中存在错误或

1493
00:57:51,590 --> 00:57:54,980
解释器本身中存在错误，请

1494
00:57:54,980 --> 00:57:56,330
在此处

1495
00:57:56,330 --> 00:58:07,780


1496
00:58:07,780 --> 00:58:12,609
打包 mpiler 可能是错误

1497
00:58:12,609 --> 00:58:15,440
的，有一个层次结构，比如

1498
00:58:15,440 --> 00:58:16,609
什么可能是错误的，就像它总是

1499
00:58:16,609 --> 00:58:18,589
像首先责备的是

1500
00:58:18,589 --> 00:58:20,810
您的代码，然后责备的是

1501
00:58:20,810 --> 00:58:24,050
您正在使用的库，然后

1502
00:58:24,050 --> 00:58:26,810
也许您接下来责怪编译器

1503
00:58:26,810 --> 00:58:28,400
和 那么也许他们不太可能

1504
00:58:28,400 --> 00:58:30,680
责怪硬件，所以

1505
00:58:30,680 --> 00:58:33,050
你的代码很可能是错误的，就像这

1506
00:58:33,050 --> 00:58:35,119
件事不会出错一样，

1507
00:58:35,119 --> 00:58:37,220
但我想说明的是，我们

1508
00:58:37,220 --> 00:58:39,140
不必写这个，这

1509
00:58:39,140 --> 00:58:40,940
不会是 写起来很困难，而且

1510
00:58:40,940 --> 00:58:42,230


1511
00:58:42,230 --> 00:58:43,760
当我们扩展您的

1512
00:58:43,760 --> 00:58:47,030
功能时，如果我们将系统设计

1513
00:58:47,030 --> 00:58:48,530


1514
00:58:48,530 --> 00:58:50,690
得足够通用，您就知道每次我们

1515
00:58:50,690 --> 00:58:52,130
添加新的续集功能时都不

1516
00:58:52,130 --> 00:58:54,500
需要修改 所以只有你知道的一

1517
00:58:54,500 --> 00:58:56,960
小部分聪明人考虑一下

1518
00:58:56,960 --> 00:58:58,520
这个 有一小部分

1519
00:58:58,520 --> 00:58:59,540
人可以编写 Devi 系统

1520
00:58:59,540 --> 00:59:01,250
还有更少的

1521
00:59:01,250 --> 00:59:03,250
聪明人可以正确地写出这篇文章

1522
00:59:03,250 --> 00:59:05,900
所以我们付钱 那个人很多

1523
00:59:05,900 --> 00:59:08,030
钱都做对了，并假设它是

1524
00:59:08,030 --> 00:59:11,710
正确的，好吧，

1525
00:59:11,850 --> 00:59:14,310
我们有 15 分钟的时间，我想

1526
00:59:14,310 --> 00:59:15,720
快速了解这对

1527
00:59:15,720 --> 00:59:16,830
现实世界的一系列不同影响，

1528
00:59:16,830 --> 00:59:18,840
所以正如我在开头所说的那样，

1529
00:59:18,840 --> 00:59:21,330
我说哦 高 Q

1530
00:59:21,330 --> 00:59:24,720
是现代时代的第一个例子，

1531
00:59:24,720 --> 00:59:26,370
我使用它作为这种措辞的原因是因为

1532
00:59:26,370 --> 00:59:29,430
IBM 做了与 1970 年代一样多的事情和

1533
00:59:29,430 --> 00:59:31,860
数据库，但

1534
00:59:31,860 --> 00:59:33,180
后来他们放弃了它，但现在几乎

1535
00:59:33,180 --> 00:59:34,740
很多系统 今天正在

1536
00:59:34,740 --> 00:59:38,130
使用这种方法，所以 IBM 在 19 世纪 70 年代为系统 R Roberts 提供了一种

1537
00:59:38,130 --> 00:59:40,050
原始形式的有说服力和编码的

1538
00:59:40,050 --> 00:59:41,070
编译

1539
00:59:41,070 --> 00:59:43,080


1540
00:59:43,080 --> 00:59:44,970
方式，我们的项目是他们将 Ted

1541
00:59:44,970 --> 00:59:47,250
cots 纸柄交给

1542
00:59:47,250 --> 00:59:49,620
圣何塞的研究人员让他在一个房间里，一群

1543
00:59:49,620 --> 00:59:51,210
人 使用全新的 PC 并说嘿

1544
00:59:51,210 --> 00:59:52,260
构建一个数据库系统 构建一个

1545
00:59:52,260 --> 00:59:53,820
关系数据库系统

1546
00:59:53,820 --> 00:59:55,500
我们所认识的每一张卡片 每一个拥有 PC 的人都

1547
00:59:55,500 --> 00:59:57,120
从它的一块上切下 一个人做了

1548
00:59:57,120 --> 00:59:59,790
存储 一个人发明了续集 另一个

1549
00:59:59,790 --> 01:00:01,860
女人 做了查询优化，然后

1550
01:00:01,860 --> 01:00:03,450
有人正确地做了这个热电联产的

1551
01:00:03,450 --> 01:00:05,160
事情，然后会发生什么是他们

1552
01:00:05,160 --> 01:00:06,870
会采取一个续集声明，他们

1553
01:00:06,870 --> 01:00:09,510
我们有它吐出的程序集，

1554
01:00:09,510 --> 01:00:11,670
然后就像一个俳句或

1555
01:00:11,670 --> 01:00:14,940
LLVM 的 IR 正是培根执行

1556
01:00:14,940 --> 01:00:18,240
为那个查询做计划，他们

1557
01:00:18,240 --> 01:00:19,200
会有一堆模板和一些

1558
01:00:19,200 --> 01:00:21,750
拼接的东西，所以结果

1559
01:00:21,750 --> 01:00:23,640
证明这是一个巨大的气喘吁吁的

1560
01:00:23,640 --> 01:00:26,820
维护工程师，因为

1561
01:00:26,820 --> 01:00:29,280
在 1970 年代，IBM 有一个完整的这些

1562
01:00:29,280 --> 01:00:30,810
不同的大型机 这些

1563
01:00:30,810 --> 01:00:32,400
不同的 ISA 和指令集

1564
01:00:32,400 --> 01:00:34,200
得到了他们的支持，所以为了让

1565
01:00:34,200 --> 01:00:36,030
系统 R 工作，你知道你知道

1566
01:00:36,030 --> 01:00:38,280
360 或其他一些系统，你必须

1567
01:00:38,280 --> 01:00:39,720
确保你倾倒了所有这些

1568
01:00:39,720 --> 01:00:42,300
容易出错的组装材料，所以当他们

1569
01:00:42,300 --> 01:00:46,140
去的时候 并开始构建 db2

1570
01:00:46,140 --> 01:00:48,030
一些系统被做成了

1571
01:00:48,030 --> 01:00:50,460
他们首先构建的 db2 版本，

1572
01:00:50,460 --> 01:00:53,910
就像续集一样，但所有这些

1573
01:00:53,910 --> 01:00:56,340
热电联产的东西并放弃了

1574
01:00:56,340 --> 01:00:58,800
另一个大问题 也有任何时候系统的

1575
01:00:58,800 --> 01:01:00,510
其他部分发生变化，

1576
01:01:00,510 --> 01:01:04,200
例如元组的页面布局

1577
01:01:04,200 --> 01:01:06,300
或索引，您必须更改所有

1578
01:01:06,300 --> 01:01:08,160
这些汇编代码，这是一个巨大的

1579
01:01:08,160 --> 01:01:09,210
噩梦，因为每次

1580
01:01:09,210 --> 01:01:11,190
发生更改时，您都必须 改变这部分

1581
01:01:11,190 --> 01:01:13,790
并测试它，所以这很棒

1582
01:01:13,790 --> 01:01:16,110
1981 年出现了一个回顾，

1583
01:01:16,110 --> 01:01:17,970
它谈论了系统 R 的历史，

1584
01:01:17,970 --> 01:01:20,670
但当时在 IBM 工作的主要开发

1585
01:01:20,670 --> 01:01:22,770
人员确实

1586
01:01:22,770 --> 01:01:24,810
像小组一样或

1587
01:01:24,810 --> 01:01:26,610
在后期或早期接受了采访 谈到 1990 年代

1588
01:01:26,610 --> 01:01:28,350
，您知道

1589
01:01:28,350 --> 01:01:30,030
在 1970 年代构建 Davis 系统是什么感觉，

1590
01:01:30,030 --> 01:01:31,050
当时没有人知道如何构建

1591
01:01:31,050 --> 01:01:32,790
数据库系统，其中一件事，

1592
01:01:32,790 --> 01:01:33,900
当您阅读这些采访时，他们

1593
01:01:33,900 --> 01:01:34,890
谈论这件事是一个巨大的

1594
01:01:34,890 --> 01:01:36,600
噩梦，而当他们构建时 db2

1595
01:01:36,600 --> 01:01:43,940
他们把它去掉了，所以 Oracle 因为

1596
01:01:43,940 --> 01:01:46,980
他们的高端东西，比如

1597
01:01:46,980 --> 01:01:49,320
内存列存储中的断裂镜像，

1598
01:01:49,320 --> 01:01:51,120
然后像 Exadata 他们做了

1599
01:01:51,120 --> 01:01:53,100
类似的事情，但就像你只下载

1600
01:01:53,100 --> 01:01:56,310
普通的 Orac 在基于磁盘的版本中，它

1601
01:01:56,310 --> 01:01:58,770
不会对查询进行任何编译，

1602
01:01:58,770 --> 01:02:01,650
他们可能会做谓词，但同样，这

1603
01:02:01,650 --> 01:02:05,280
可能仅适用于

1604
01:02:05,280 --> 01:02:07,140
它的高端版本，但他们编译的一件事

1605
01:02:07,140 --> 01:02:09,390
是存储过程，因此

1606
01:02:09,390 --> 01:02:10,560
他们将 使用你的 PL 续集

1607
01:02:10,560 --> 01:02:13,110
存储过程并将它们转换为

1608
01:02:13,110 --> 01:02:16,140
pro C 或 prostar C，这是他们

1609
01:02:16,140 --> 01:02:19,050
专门的 C 方言，然后

1610
01:02:19,050 --> 01:02:21,090
他们将把它编译成本机和 C

1611
01:02:21,090 --> 01:02:26,640
C++ 代码，

1612
01:02:26,640 --> 01:02:29,580
他们这样做的原因是因为

1613
01:02:29,580 --> 01:02:30,900
会有一堆安全检查，

1614
01:02:30,900 --> 01:02:33,180
以确保您的存储过程

1615
01:02:33,180 --> 01:02:34,710
不会对地址空间做一些奇怪的事情，

1616
01:02:34,710 --> 01:02:36,270
所以他们不会

1617
01:02:36,270 --> 01:02:37,380
在沙箱中运行它并

1618
01:02:37,380 --> 01:02:38,460
直接在数据库系统

1619
01:02:38,460 --> 01:02:41,010
系统进程中运行它

1620
01:02:41,010 --> 01:02:42,630
其他人无法做到的可怕

1621
01:02:42,630 --> 01:02:45,450
的事情 超级疯狂就像现在

1622
01:02:45,450 --> 01:02:47,430
将数据库操作直接放在

1623
01:02:47,430 --> 01:02:48,150
硬件

1624
01:02:48,150 --> 01:02:51,240
上 FPGA 是您可以做的事情

1625
01:02:51,240 --> 01:02:52,350
，人们已经从数据库系统中完成了这项工作，

1626
01:02:52,350 --> 01:02:54,570
但这些都是滑雪 那些

1627
01:02:54,570 --> 01:02:55,890
仍然稍微通用一点，

1628
01:02:55,890 --> 01:02:57,630
这就像他们实际上在

1629
01:02:57,630 --> 01:02:59,040
制造 CPU 并且他们会在他们 15 年前购买的 CPU 上放置专门的

1630
01:02:59,040 --> 01:03:01,320
指令或 Aqua 数据库

1631
01:03:01,320 --> 01:03:02,250


1632
01:03:02,250 --> 01:03:05,760
有人在

1633
01:03:05,760 --> 01:03:07,470
制造火花芯片 所以一些

1634
01:03:07,470 --> 01:03:08,670
新的 版本的火花芯片直接在硬件上

1635
01:03:08,670 --> 01:03:11,370
支持或主机压缩

1636
01:03:11,370 --> 01:03:12,810
算法或 Oracles 位图内容

1637
01:03:12,810 --> 01:03:15,660
，以避免

1638
01:03:15,660 --> 01:03:17,520
你知道这会破坏你可以

1639
01:03:17,520 --> 01:03:19,290
用 cojan 做的任何事情，因为你

1640
01:03:19,290 --> 01:03:22,080
不知道编译代码来完成

1641
01:03:22,080 --> 01:03:23,610
你的日报想要做的事情 你只是调用

1642
01:03:23,610 --> 01:03:25,290
硬件本身的操作

1643
01:03:25,290 --> 01:03:29,190
并没有比这更快我

1644
01:03:29,190 --> 01:03:30,270
认为他们不再这样做了，因为我

1645
01:03:30,270 --> 01:03:31,860
认为他们不再产生火花了，

1646
01:03:31,860 --> 01:03:34,110
但这可能就像四五

1647
01:03:34,110 --> 01:03:35,310
年前他们吹捧这个一样 您

1648
01:03:35,310 --> 01:03:38,060
可以从 hadson Sons 硬件购买 Oracle RAC 机器

1649
01:03:38,060 --> 01:03:40,700
，它们

1650
01:03:40,700 --> 01:03:43,970
将使您的 Oracle debase 运行得更快

1651
01:03:43,970 --> 01:03:45,410


1652
01:03:45,410 --> 01:03:47,900


1653
01:03:47,900 --> 01:03:49,790
喜欢 Bakic 一个朋友，但是存储

1654
01:03:49,790 --> 01:03:52,700
过程和续集有点

1655
01:03:52,700 --> 01:03:55,400
酷的是他们会

1656
01:03:55,400 --> 01:03:57,020
预编译一堆这些运算

1657
01:03:57,020 --> 01:03:59,050
符，允许您对数据进行非黑客马拉松

1658
01:03:59,050 --> 01:04:02,420
查询接触 Hecate 我可以

1659
01:04:02,420 --> 01:04:04,430
有效地运行它们以及它们的方式

1660
01:04:04,430 --> 01:04:05,930
会这样做是他们会

1661
01:04:05,930 --> 01:04:08,060
从查询计划的语法树中生成 C 代码

1662
01:04:08,060 --> 01:04:11,450
编译使用你知道

1663
01:04:11,450 --> 01:04:14,930
微软编译器生成

1664
01:04:14,930 --> 01:04:16,580
DLL 然后在运行时链接它的

1665
01:04:16,580 --> 01:04:18,110
方式与 Haiku 实际执行

1666
01:04:18,110 --> 01:04:20,720
此操作的方式相同并确保 任何人都

1667
01:04:20,720 --> 01:04:22,040
在做一些笨重的事情 他们会有

1668
01:04:22,040 --> 01:04:23,510
一堆额外的检查以确保

1669
01:04:23,510 --> 01:04:25,430
你知道你没有一个奇怪的

1670
01:04:25,430 --> 01:04:26,870
谓词试图做一个杯子提供

1671
01:04:26,870 --> 01:04:28,690
溢出来控制系统

1672
01:04:28,690 --> 01:04:31,160
现在 Actium vector 就是他要问的

1673
01:04:31,160 --> 01:04:33,410
大约在之前，所以他们并没有真正做到

1674
01:04:33,410 --> 01:04:36,470
令人信服，他们正在预编译这些

1675
01:04:36,470 --> 01:04:37,640
原语，这就是为什么我使用

1676
01:04:37,640 --> 01:04:39,320
这个术语并将原语视为

1677
01:04:39,320 --> 01:04:42,320
您

1678
01:04:42,320 --> 01:04:44,660
想要在一块上进行的一些低级操作 数据重复，但

1679
01:04:44,660 --> 01:04:46,600
它会全部写入

1680
01:04:46,600 --> 01:04:49,580
特定类型，那么原始数据

1681
01:04:49,580 --> 01:04:51,710
如何比较两个数字，

1682
01:04:51,710 --> 01:04:54,380
或者一个将用于 32 位 64 位 16 位

1683
01:04:54,380 --> 01:04:56,090
浮点数，我将预编译所有这些

1684
01:04:56,090 --> 01:04:59,990
原始数据 然后现在在运行时我的

1685
01:04:59,990 --> 01:05:01,370
查询计划基本上做的是

1686
01:05:01,370 --> 01:05:03,260
将所有这些预计算

1687
01:05:03,260 --> 01:05:05,690
原语拼接在一起，就好像它是一堆动态生成的 C++

1688
01:05:05,690 --> 01:05:07,220
代码

1689
01:05:07,220 --> 01:05:09,380
，现在我只是

1690
01:05:09,380 --> 01:05:11,510
调用这些预编译的函数

1691
01:05:11,510 --> 01:05:13,760
这将几乎一样快或在

1692
01:05:13,760 --> 01:05:18,290
某些情况下更快，所以在这里看一个

1693
01:05:18,290 --> 01:05:20,390
例子，所以这里是 L 一个

1694
01:05:20,390 --> 01:05:24,230
原始做它是否需要一个

1695
01:05:24,230 --> 01:05:26,570
指向一列内的一堆 32 个调用

1696
01:05:26,570 --> 01:05:28,490
值的指针获取我想要比较的值

1697
01:05:28,490 --> 01:05:31,280
反对，然后我只做一个

1698
01:05:31,280 --> 01:05:33,230
小于，如果它匹配，那么我

1699
01:05:33,230 --> 01:05:35,150
在我的输出缓冲区中生成，这

1700
01:05:35,150 --> 01:05:36,710
是相同的功能，但现在我正在

1701
01:05:36,710 --> 01:05:40,280
比较双精度所以我的输入列是一个

1702
01:05:40,280 --> 01:05:42,470
32 位整数，但我的比较值

1703
01:05:42,470 --> 01:05:44,660
是一个双重所以我只是你知道我

1704
01:05:44,660 --> 01:05:45,830
在那里添加那部分，副驾驶会

1705
01:05:45,830 --> 01:05:47,750
为我生成正确的 Caston 代码，

1706
01:05:47,750 --> 01:05:49,700


1707
01:05:49,700 --> 01:05:52,410
所以我们会看到下一节课，我们会

1708
01:05:52,410 --> 01:05:54,060
谈谈下一个人 NL 所以在

1709
01:05:54,060 --> 01:05:56,340
春假之后，你会认为这不是吗

1710
01:05:56,340 --> 01:05:57,690


1711
01:05:57,690 --> 01:05:59,370
如果我为每个

1712
01:05:59,370 --> 01:06:01,530
单独的元组调用这个函数，现在会很慢，这就是为什么他们

1713
01:06:01,530 --> 01:06:03,600
传递一种指定给

1714
01:06:03,600 --> 01:06:05,700
列的原因，这有点以向量的名义，

1715
01:06:05,700 --> 01:06:07,170
他们传递的是一个

1716
01:06:07,170 --> 01:06:09,930
元组向量 然后

1717
01:06:09,930 --> 01:06:13,260
编译器可以使用似乎指令对它进行矢量化，

1718
01:06:13,260 --> 01:06:15,060
所以现在我没有在

1719
01:06:15,060 --> 01:06:17,460
单个标量和

1720
01:06:17,460 --> 01:06:19,380
另一个标量之间进行比较我正在处理

1721
01:06:19,380 --> 01:06:21,960
调用单个指令以

1722
01:06:21,960 --> 01:06:24,260
更有效地执行该指令的一批值，

1723
01:06:24,260 --> 01:06:28,530
所以我们再次' 将看到这一点 我们将

1724
01:06:28,530 --> 01:06:29,640
在下一堂课中看到如何进行矢量化，

1725
01:06:29,640 --> 01:06:31,890
但这

1726
01:06:31,890 --> 01:06:34,170
就是原因之一，尽管矢量 Y 不是

1727
01:06:34,170 --> 01:06:36,870
一个完整的引擎，但您仍然可以匹配

1728
01:06:36,870 --> 01:06:38,940
具有说服力的引擎的性能，

1729
01:06:38,940 --> 01:06:40,290
因为您可以在这里获得此好处

1730
01:06:40,290 --> 01:06:41,820
而毒蛇不能 t 做向量化

1731
01:06:41,820 --> 01:06:45,780
执行，它一次只有一个元组，

1732
01:06:45,780 --> 01:06:47,040
所以现在有一堆

1733
01:06:47,040 --> 01:06:48,420
基于 JVM 的数据库系统在 JVM 上

1734
01:06:48,420 --> 01:06:51,660
运行，所以 spark 在 2015 年

1735
01:06:51,660 --> 01:06:53,220
宣布他们有这个新的钨

1736
01:06:53,220 --> 01:06:55,950
执行引擎 sparks 完全

1737
01:06:55,950 --> 01:06:56,700
用 Scala 编写，

1738
01:06:56,700 --> 01:06:58,890
所以在里面 那些源代码他们有

1739
01:06:58,890 --> 01:07:01,110
办法获取查询内部的谓词，

1740
01:07:01,110 --> 01:07:02,970
因为 spark 支持

1741
01:07:02,970 --> 01:07:04,950
sequel，然后他们会将其

1742
01:07:04,950 --> 01:07:07,980
直接转换为 Scala ast S，然后可以

1743
01:07:07,980 --> 01:07:09,900
将其生成为字节码，他们可以

1744
01:07:09,900 --> 01:07:11,490
调用它并在内部本地执行

1745
01:07:11,490 --> 01:07:14,630
引擎的运行方式，所以

1746
01:07:14,630 --> 01:07:18,240
SPARC 再次为 Scala 执行此操作 它

1747
01:07:18,240 --> 01:07:20,190
只是运行 JVM 有一堆

1748
01:07:20,190 --> 01:07:21,810
其他 JVM 数据库

1749
01:07:21,810 --> 01:07:23,730
或多或少都在做同样的事情 neo4j

1750
01:07:23,730 --> 01:07:26,130
拼接机器 presto 和 Derby 拼接

1751
01:07:26,130 --> 01:07:27,930
机器使用 Derby 所以这两个

1752
01:07:27,930 --> 01:07:30,600
有点像我

1753
01:07:30,600 --> 01:07:32,220
昨晚看的 Neo4j 源代码，它

1754
01:07:32,220 --> 01:07:33,390
不是很好，因为没有

1755
01:07:33,390 --> 01:07:35,370
文档，但据我所知，

1756
01:07:35,370 --> 01:07:37,470
它看起来像你可以 实际

1757
01:07:37,470 --> 01:07:41,460
生成您为查询生成字节码

1758
01:07:41,460 --> 01:07:44,370
，然后他们也可以

1759
01:07:44,370 --> 01:07:45,900
将其反转并将其放回 Java

1760
01:07:45,900 --> 01:07:48,150
源代码中，因此如果您赢了，现在

1761
01:07:48,150 --> 01:07:49,200
通过调试器运行它并找出

1762
01:07:49,200 --> 01:07:50,370
您知道为什么您的查询实际上

1763
01:07:50,370 --> 01:07:50,990
不起作用的

1764
01:07:50,990 --> 01:07:53,340
原因 我不

1765
01:07:53,340 --> 01:07:54,720
知道其他人是否可以做

1766
01:07:54,720 --> 01:07:56,220
同样的事情

1767
01:07:56,220 --> 01:07:58,200


1768
01:07:58,200 --> 01:07:59,640


1769
01:07:59,640 --> 01:08:00,660


1770
01:08:00,660 --> 01:08:02,880


1771
01:08:02,880 --> 01:08:04,799
立即运行任何编译器传递

1772
01:08:04,799 --> 01:08:08,640
给它然后热点

1773
01:08:08,640 --> 01:08:10,829
VM 将识别我是否极端

1774
01:08:10,829 --> 01:08:13,049
这个这个字节码现在再次

1775
01:08:13,049 --> 01:08:15,089
在我的为他们我访问每

1776
01:08:15,089 --> 01:08:17,189
一个元组然后它会做编译器

1777
01:08:17,189 --> 01:08:20,250
编译的东西 对我来说，所以我不需要

1778
01:08:20,250 --> 01:08:21,839
做我们在 LLVM 中所做的多个阶段，

1779
01:08:21,839 --> 01:08:23,880
JVM 会为我处理这个问题

1780
01:08:23,880 --> 01:08:27,139
，但我认为这很酷，

1781
01:08:27,139 --> 01:08:30,509
所以 mem Seco 很有趣，

1782
01:08:30,509 --> 01:08:32,520
因为他们有两个版本的

1783
01:08:32,520 --> 01:08:35,370
引擎 所以正如我在 mem 之前所说的 孟菲斯的

1784
01:08:35,370 --> 01:08:37,109
一位联合创始人曾

1785
01:08:37,109 --> 01:08:38,189
说过，微软在构建

1786
01:08:38,189 --> 01:08:41,130
黑客马拉松时看到了早期的谈话，

1787
01:08:41,130 --> 01:08:43,170
你从微软内部知道

1788
01:08:43,170 --> 01:08:45,060
他没有参与黑客马拉松，所以

1789
01:08:45,060 --> 01:08:46,620
从研究人员那里谈谈他们如何对

1790
01:08:46,620 --> 01:08:50,250
新的有说服力的 hackathon 使用 C，所以当

1791
01:08:50,250 --> 01:08:51,479
你在 Belton MC 电话会议上离开时，他做了

1792
01:08:51,479 --> 01:08:53,100
更多

1793
01:08:53,100 --> 01:08:54,750
与俳句相同的事情，所以他们会有

1794
01:08:54,750 --> 01:08:56,819
代码来生成这个

1795
01:08:56,819 --> 01:08:59,819
查询计划的 C 源代码，然后 fork

1796
01:08:59,819 --> 01:09:02,729
exec GCC 链接 那个共享对象，

1797
01:09:02,729 --> 01:09:04,979
然后运行那个查询，正如我在

1798
01:09:04,979 --> 01:09:07,109
早期版本的 mem Siegel 中所说，当你

1799
01:09:07,109 --> 01:09:08,969
查看他们的博客文章时，他们会

1800
01:09:08,969 --> 01:09:10,439
显示示例就像你第一次

1801
01:09:10,439 --> 01:09:11,698
运行查询是一秒钟，因为

1802
01:09:11,698 --> 01:09:13,439
这就是所有的编译开销但是

1803
01:09:13,439 --> 01:09:15,109
然后 第二次会比raid快得多，

1804
01:09:15,109 --> 01:09:17,310
他们能够

1805
01:09:17,310 --> 01:09:20,429
通过缓存通过

1806
01:09:20,429 --> 01:09:22,469
提取出现的任何查询提取

1807
01:09:22,469 --> 01:09:24,839
常量然后识别

1808
01:09:24,839 --> 01:09:26,729
查询是否显示相同的查询来使其更快 再次

1809
01:09:26,729 --> 01:09:28,290
使用不同的输入参数 我可以

1810
01:09:28,290 --> 01:09:31,620
重用我的缓存衬衫共享对象 所以我的

1811
01:09:31,620 --> 01:09:33,630
查询显示 select star from a where

1812
01:09:33,630 --> 01:09:35,750
egg a ID 等于一二三 我

1813
01:09:35,750 --> 01:09:38,279
知道我这里有一

1814
01:09:38,279 --> 01:09:40,589
二三 把它作为参数 编译该

1815
01:09:40,589 --> 01:09:42,719
缓存 然后现在另一个查询

1816
01:09:42,719 --> 01:09:44,549
显示一个 ID 等于四五六

1817
01:09:44,549 --> 01:09:46,259
我可以认识到我可以重用

1818
01:09:46,259 --> 01:09:47,969
相同的查询计划并运行它并且

1819
01:09:47,969 --> 01:09:49,229


1820
01:09:49,229 --> 01:09:51,658
现在我们问他们并且他们告诉我们

1821
01:09:51,658 --> 01:09:52,920
唯一的事情不需要支付编译开销 他们在这里做的

1822
01:09:52,920 --> 01:09:55,050
只是字符串匹配，所以如果我的

1823
01:09:55,050 --> 01:09:57,750
谓词就像 ID 等于 1 并且 n 是 ID

1824
01:09:57,750 --> 01:10:00,060
等于 2 我兑现了那个，但是现在如果我

1825
01:10:00,060 --> 01:10:02,190
出现像 B ID 等于

1826
01:10:02,190 --> 01:10:04,980
1 和 ID 等于 2 的反向 无法

1827
01:10:04,980 --> 01:10:06,540
重用它，即使在语义上它

1828
01:10:06,540 --> 01:10:08,520
与字符串不匹配的查询相同，

1829
01:10:08,520 --> 01:10:14,030
所以发生的事情是

1830
01:10:14,030 --> 01:10:16,530
，实际上，

1831
01:10:16,530 --> 01:10:18,719
单身的尼基塔告诉我，

1832
01:10:18,719 --> 01:10:22,800
就像最早的海鸥一样，

1833
01:10:22,800 --> 01:10:24,449
他们不得不这样做 再一次，他们

1834
01:10:24,449 --> 01:10:25,800
会 我一开始没有添加这个编译的

1835
01:10:25,800 --> 01:10:27,150
东西，因为

1836
01:10:27,150 --> 01:10:28,739
维护它们对他们来说是一个巨大的痛苦我认为

1837
01:10:28,739 --> 01:10:29,730
他们会遇到很多

1838
01:10:29,730 --> 01:10:33,059
与 IBM 人一样的痛苦，

1839
01:10:33,059 --> 01:10:49,800
他说是的，他说你说 - 这个编译

1840
01:10:49,800 --> 01:10:52,409
很昂贵，但是 比如

1841
01:10:52,409 --> 01:10:53,820
编译的开销

1842
01:10:53,820 --> 01:10:55,639
与查询的执行时间有

1843
01:10:55,639 --> 01:11:02,480
多少以及我们实际上可以兑现多少是

1844
01:11:02,480 --> 01:11:04,710
对的，但是如果我们查询从

1845
01:11:04,710 --> 01:11:07,619
一毫秒开始运行，就像如果你运行

1846
01:11:07,619 --> 01:11:09,119
解释器并且花了十分钟 毫秒，

1847
01:11:09,119 --> 01:11:11,219
但我编译的版本从一

1848
01:11:11,219 --> 01:11:13,110
毫秒开始运行，但我需要 20

1849
01:11:13,110 --> 01:11:14,880
毫秒来编译它然后我

1850
01:11:14,880 --> 01:11:16,460
最好只运行解释器

1851
01:11:16,460 --> 01:11:19,170
mem 续集以避免工程开销

1852
01:11:19,170 --> 01:11:20,219
你不想必须正确构建两个

1853
01:11:20,219 --> 01:11:22,199
单独的引擎所以他们会

1854
01:11:22,199 --> 01:11:26,070
编译 每个查询都是为了避免，

1855
01:11:26,070 --> 01:11:27,360
他们有点关注所有这些事情，所以

1856
01:11:27,360 --> 01:11:29,280
你可以希望大多数

1857
01:11:29,280 --> 01:11:31,860
查询以相同的模式显示，你可以

1858
01:11:31,860 --> 01:11:33,449
一遍又一遍地重复使用缓存计划

1859
01:11:33,449 --> 01:11:35,730
如果我要读取一个元组，那么它提供了多少好处

1860
01:11:35,730 --> 01:11:37,409
，或者取决于查询实际上要做什么，

1861
01:11:37,409 --> 01:11:38,699


1862
01:11:38,699 --> 01:11:42,539
那么缓存可能

1863
01:11:42,539 --> 01:11:45,270
会有很大帮助，因为

1864
01:11:45,270 --> 01:11:47,190
如果我正在阅读，查询无论如何都会被缩短，你

1865
01:11:47,190 --> 01:11:49,260
知道 PB 级的数据缓存

1866
01:11:49,260 --> 01:11:50,280
可能不会有什么不同，谁

1867
01:11:50,280 --> 01:11:54,059
在乎内存，你知道大多数

1868
01:11:54,059 --> 01:11:55,980
你没有在

1869
01:11:55,980 --> 01:11:57,900
PB 级内存中运行数据库，因为那是

1870
01:11:57,900 --> 01:12:00,570
非常昂贵的，所以

1871
01:12:00,570 --> 01:12:02,400
我们正在查看的大多数内存数据库或数以百计

1872
01:12:02,400 --> 01:12:03,000
千兆字节

1873
01:12:03,000 --> 01:12:04,739
我认为孟菲斯老鹰队

1874
01:12:04,739 --> 01:12:06,210
他们有一个大约 14 TB 或

1875
01:12:06,210 --> 01:12:08,239
类似的东西仍然很像

1876
01:12:08,239 --> 01:12:10,079
大多数方块不需要

1877
01:12:10,079 --> 01:12:15,570
撕掉重复所以我说如果他们的

1878
01:12:15,570 --> 01:12:16,500
续集指南告诉我他们有

1879
01:12:16,500 --> 01:12:17,880
套索 再一次，他们不会

1880
01:12:17,880 --> 01:12:19,679
从编译的东西开始，但

1881
01:12:19,679 --> 01:12:21,750
后来他们得到了一大笔钱，这

1882
01:12:21,750 --> 01:12:23,489
总是让事情变得更容易，他们

1883
01:12:23,489 --> 01:12:26,429
从 Facebook 雇佣了那个

1884
01:12:26,429 --> 01:12:28,739
为 Facebook 构建嘻哈虚拟机的人，所以

1885
01:12:28,739 --> 01:12:30,239
Facebook fa 经常在 PHP 上运行

1886
01:12:30,239 --> 01:12:32,340
PHP 是一种解释性语言

1887
01:12:32,340 --> 01:12:34,650
，并且是默认语言，因为当

1888
01:12:34,650 --> 01:12:36,690
我开发 PHP 时，当天

1889
01:12:36,690 --> 01:12:39,059
默认的 PHP 解释器非常慢，所以

1890
01:12:39,059 --> 01:12:41,699
Facebook 也没有获得更好的可扩展性，他们

1891
01:12:41,699 --> 01:12:43,079
构建了自己的 B 端，可以编译

1892
01:12:43,079 --> 01:12:45,929
PHP 所以 mem Seco 聘请了

1893
01:12:45,929 --> 01:12:47,369
发明她的那个人，他在那个嘻哈

1894
01:12:47,369 --> 01:12:49,380
虚拟机上工作，让这个项目去

1895
01:12:49,380 --> 01:12:51,659
读写执行引擎完全

1896
01:12:51,659 --> 01:12:54,139
基于 LLVM，所以现在他们

1897
01:12:54,139 --> 01:12:57,780
会在我认为正确的方法时

1898
01:12:57,780 --> 01:13:01,050
做 做一个 LM 查询执行引擎，

1899
01:13:01,050 --> 01:13:02,159
这基本上就是我们现在

1900
01:13:02,159 --> 01:13:04,079
在我们自己的系统中所做的，所以

1901
01:13:04,079 --> 01:13:05,369
他们要做的是他们将采用

1902
01:13:05,369 --> 01:13:06,989
优化器吐出的物理查询计划，

1903
01:13:06,989 --> 01:13:09,420
然后他们首先要转换 它变成了

1904
01:13:09,420 --> 01:13:12,570
一个命令式计划，该计划是

1905
01:13:12,570 --> 01:13:14,940
用 DSL 的高级域特定

1906
01:13:14,940 --> 01:13:17,190
语言编写的，他们称 MPL 为 mem 续集

1907
01:13:17,190 --> 01:13:19,679
编程语言，它基本上看起来

1908
01:13:19,679 --> 01:13:21,719
像 C++，我们将在一秒钟内看到我们的示例，

1909
01:13:21,719 --> 01:13:24,630
然后您采用该 DSL 现在

1910
01:13:24,630 --> 01:13:26,190
你编译 进入一堆操作码，

1911
01:13:26,190 --> 01:13:28,650
然后现在你可以拥有这些操作码

1912
01:13:28,650 --> 01:13:31,559
，现在可以解释或编译，

1913
01:13:31,559 --> 01:13:32,880
嗯，续集案例我认为他们总是

1914
01:13:32,880 --> 01:13:35,070
直接进行编译，但

1915
01:13:35,070 --> 01:13:36,510
你仍然可以

1916
01:13:36,510 --> 01:13:38,099
像超级家伙那样使用解释器 对

1917
01:13:38,099 --> 01:13:41,219
他们的 IR 来说，现在你

1918
01:13:41,219 --> 01:13:43,170
从中得到的好处是，如果我是一名数据库

1919
01:13:43,170 --> 01:13:45,090
工程师，我们实际上是在

1920
01:13:45,090 --> 01:13:47,489
构建系统的人，

1921
01:13:47,489 --> 01:13:49,440
雇用新人来从事这部分工作会更容易，而

1922
01:13:49,440 --> 01:13:50,999
不用担心这部分，

1923
01:13:50,999 --> 01:13:52,440
因为我” 我会假设

1924
01:13:52,440 --> 01:13:53,670
我真的很贵很聪明的人

1925
01:13:53,670 --> 01:13:56,880
正确地写了这部分，

1926
01:13:56,880 --> 01:13:59,849
你认识的其他人我可以来

1927
01:13:59,849 --> 01:14:01,769
这里工作所以你们

1928
01:14:01,769 --> 01:14:03,719
对你的项目 3 来说是一样的，如果

1929
01:14:03,719 --> 01:14:04,769
你结束了 大多数人在执行引擎上工作

1930
01:14:04,769 --> 01:14:06,749
如果您想添加

1931
01:14:06,749 --> 01:14:08,130
新功能，例如新的字符串函数

1932
01:14:08,130 --> 01:14:10,110
和您的续集函数或日期

1933
01:14:10,110 --> 01:14:11,639
函数 您不必在此处触摸此

1934
01:14:11,639 --> 01:14:13,530
部分 您只需要在此处修改此

1935
01:14:13,530 --> 01:14:19,190
部分就可以了 ht

1936
01:14:19,190 --> 01:14:22,320
Postgres 在 2018 年添加了对高程的支持，

1937
01:14:22,320 --> 01:14:25,260
首先在版本 11 中出现，但

1938
01:14:25,260 --> 01:14:27,030
它默认关闭

1939
01:14:27,030 --> 01:14:29,159
，然后现在版本 12 我认为从

1940
01:14:29,159 --> 01:14:31,679
去年开始它默认打开，所以

1941
01:14:31,679 --> 01:14:33,179
每个查询和他们都有一个内部

1942
01:14:33,179 --> 01:14:34,409
成本模型来决定 无论我是否应该进行

1943
01:14:34,409 --> 01:14:36,860
编译，他们都会进行

1944
01:14:36,860 --> 01:14:38,789
完成谓词和元组进行

1945
01:14:38,789 --> 01:14:41,159
序列化并基本上被删除

1946
01:14:41,159 --> 01:14:43,110
减少您

1947
01:14:43,110 --> 01:14:43,840
认为

1948
01:14:43,840 --> 01:14:45,340
和迭代器模型中的 get next 调用次数，因此我将

1949
01:14:45,340 --> 01:14:46,659
尝试尽可能多地内联所有内容

1950
01:14:46,659 --> 01:14:48,909
好吧，他们这样做的

1951
01:14:48,909 --> 01:14:50,110
方式非常有趣，他们采用了

1952
01:14:50,110 --> 01:14:52,900
所有后端 Postgres 代码，就像

1953
01:14:52,900 --> 01:14:55,540
他们编写的实际服务器本身一样，

1954
01:14:55,540 --> 01:14:57,610
然后他们可以

1955
01:14:57,610 --> 01:15:01,929
将相同的源代码转换为 LEM C++，

1956
01:15:01,929 --> 01:15:03,310
然后通过它们可以删除

1957
01:15:03,310 --> 01:15:04,719
这些迭代器调用，所以你有点

1958
01:15:04,719 --> 01:15:06,760
采取函数让你知道将两个

1959
01:15:06,760 --> 01:15:08,409
数字加在一起，他们可以

1960
01:15:08,409 --> 01:15:10,929
在 LMC 脉冲代码中预编译它，所以现在当

1961
01:15:10,929 --> 01:15:12,880
我为查询做 cojan 时，

1962
01:15:12,880 --> 01:15:16,810
我调用了 C++ 代码，而不是

1963
01:15:16,810 --> 01:15:21,040
常规的 Postgres C 代码，

1964
01:15:21,040 --> 01:15:24,550
我加班我可以做一个演示，但让

1965
01:15:24,550 --> 01:15:26,500
我们给它我们将在

1966
01:15:26,500 --> 01:15:28,330
更多时间的云或黑斑羚的末尾

1967
01:15:28,330 --> 01:15:30,699
使用 LLVM 在双重图像中进行，因此它们只执行

1968
01:15:30,699 --> 01:15:33,190
谓词，就像在 Postgres 但

1969
01:15:33,190 --> 01:15:34,599
它们也用于记录解析，这很

1970
01:15:34,599 --> 01:15:35,199
有趣，

1971
01:15:35,199 --> 01:15:39,340
因此 Impala 没有自己的

1972
01:15:39,340 --> 01:15:41,050
专有存储格式，例如 post

1973
01:15:41,050 --> 01:15:41,800
cast my seagull 总是

1974
01:15:41,800 --> 01:15:44,050
专有的你知道写

1975
01:15:44,050 --> 01:15:45,790
数据的列布局你知道他们运行镶木地板

1976
01:15:45,790 --> 01:15:47,320
他们运行了 Avro 他们在所有

1977
01:15:47,320 --> 01:15:50,679
Hadoop 或基于云的文件格式上运行，所以

1978
01:15:50,679 --> 01:15:52,690
他们要做的是

1979
01:15:52,690 --> 01:15:54,159
为了更快地解析这些记录，

1980
01:15:54,159 --> 01:15:57,369
他们将提前预编译

1981
01:15:57,369 --> 01:16:00,010
一堆这些解析器，或者

1982
01:16:00,010 --> 01:16:02,170
如果我的查询显示 启动并操作

1983
01:16:02,170 --> 01:16:04,179
一些 CSV 文件，所以我知道架构是什么，

1984
01:16:04,179 --> 01:16:07,750
然后我可以预编译 CSV 解析器，

1985
01:16:07,750 --> 01:16:09,369
这样我就不必让这个解释

1986
01:16:09,369 --> 01:16:11,050
器看起来像你知道细列或

1987
01:16:11,050 --> 01:16:12,900
逗号之类的东西，

1988
01:16:12,900 --> 01:16:15,400
我是 我想跳过 Vitesse DB

1989
01:16:15,400 --> 01:16:18,580
快速讨论几个小时，所以

1990
01:16:18,580 --> 01:16:20,320
第一版 Peloton 我们做了 L Piper

1991
01:16:20,320 --> 01:16:22,090
所做的我们会有我们的 C 加涂层，但

1992
01:16:22,090 --> 01:16:25,060
我直接说我们没有做完整的

1993
01:16:25,060 --> 01:16:26,830
流水线他们正在做我们实际上

1994
01:16:26,830 --> 01:16:29,260
可以做到我们实际上

1995
01:16:29,260 --> 01:16:30,670
在不同的地方引入了这些管道断路器

1996
01:16:30,670 --> 01:16:32,199
查询计划的一部分，因为现在我们

1997
01:16:32,199 --> 01:16:32,830
可以将

1998
01:16:32,830 --> 01:16:34,510
向量 R 传递到池中以获得

1999
01:16:34,510 --> 01:16:36,040
我们在向量方面的好处这将在

2000
01:16:36,040 --> 01:16:38,650
下一堂课更有意义，当您解决我们的

2001
01:16:38,650 --> 01:16:41,199
宠物时，您需要隐藏它，以便

2002
01:16:41,199 --> 01:16:42,940
显示一些数字这个数字 这

2003
01:16:42,940 --> 01:16:45,099
就是我的耐心 Prashant 运行的，所以这

2004
01:16:45,099 --> 01:16:46,540
就像 peloton 的解释版本，

2005
01:16:46,540 --> 01:16:48,400
而不是带有

2006
01:16:48,400 --> 01:16:51,369
和不带有这种放松算子融合

2007
01:16:51,369 --> 01:16:54,960
技术的编译版本，所以这不是一个很好的

2008
01:16:54,960 --> 01:16:57,219
例子，说明你可以

2009
01:16:57,219 --> 01:16:58,690
从这样的编译中获得什么好处 如果

2010
01:16:58,690 --> 01:17:00,250
你是智障而不是像格雷巴那样智障

2011
01:17:00,250 --> 01:17:02,170
，他击退了城镇，

2012
01:17:02,170 --> 01:17:04,630
那是一个坏引擎，对，它一点都不

2013
01:17:04,630 --> 01:17:06,310
好，所以我不知道

2014
01:17:06,310 --> 01:17:07,780
你会得到一个猎人 r X 通过编译带来的

2015
01:17:07,780 --> 01:17:09,400
性能改进

2016
01:17:09,400 --> 01:17:11,620
通常类似于

2017
01:17:11,620 --> 01:17:14,620
从 2 到 25 X 之间的任何一个，但是这

2018
01:17:14,620 --> 01:17:16,690
在这里向您展示了我们可以再次从

2019
01:17:16,690 --> 01:17:20,050
88 8 秒到 800 毫秒，

2020
01:17:20,050 --> 01:17:21,790
就像在此处进行编译一样，这是一个非常显着的

2021
01:17:21,790 --> 01:17:24,670
下降 但

2022
01:17:24,670 --> 01:17:26,320
我们放弃了这个，因为这是一个巨大的

2023
01:17:26,320 --> 01:17:27,969
痛苦，因为现在你需要

2024
01:17:27,969 --> 01:17:30,400
成为 ela Mir 的专家才能调试

2025
01:17:30,400 --> 01:17:31,719
任何东西或对执行引擎进行任何更改，

2026
01:17:31,719 --> 01:17:33,610
因为当查询

2027
01:17:33,610 --> 01:17:35,560
崩溃时，你会登陆一个程序集并且

2028
01:17:35,560 --> 01:17:37,660
没有堆栈 trace 并且只有 2 或 3 个

2029
01:17:37,660 --> 01:17:39,510
学生可以实际使用它现在

2030
01:17:39,510 --> 01:17:41,469
我们的新系统目前

2031
01:17:41,469 --> 01:17:42,880
未命名但我们有一个名称我们尚未

2032
01:17:42,880 --> 01:17:44,590
宣布它是我们做 mem Siegel 所做的事情

2033
01:17:44,590 --> 01:17:46,810
我们将查询计划

2034
01:17:46,810 --> 01:17:49,180
转换为

2035
01:17:49,180 --> 01:17:50,350
特定于我们的数据库系统的级别 DSL

2036
01:17:50,350 --> 01:17:53,320
基本上看起来像 C，然后我们

2037
01:17:53,320 --> 01:17:55,210
将该 DSL 编译成操作码

2038
01:17:55,210 --> 01:17:56,830
，然后我们可以

2039
01:17:56,830 --> 01:17:58,150
在后台进行编译时解释该代码，

2040
01:17:58,150 --> 01:18:01,840
就像我的查询 pl  an

2041
01:18:01,840 --> 01:18:03,910
出现然后我可以将它转换成

2042
01:18:03,910 --> 01:18:05,949
一些方言，它再次看起来像

2043
01:18:05,949 --> 01:18:08,410
C 就像这是对 foo 进行扫描，

2044
01:18:08,410 --> 01:18:10,390
然后在

2045
01:18:10,390 --> 01:18:13,510
我的 DSL 内的列 B 上有这个谓词我

2046
01:18:13,510 --> 01:18:16,210
现在直接做那个操作 我

2047
01:18:16,210 --> 01:18:18,820
要把它转换成操作码，

2048
01:18:18,820 --> 01:18:20,620
确切的细节并不重要，但

2049
01:18:20,620 --> 01:18:21,850
就像这实际上是人类可读的，

2050
01:18:21,850 --> 01:18:23,890
就像我们有像表向量这样的东西

2051
01:18:23,890 --> 01:18:25,300
来迭代轮询和获取

2052
01:18:25,300 --> 01:18:28,180
下一个，并有函数调用来获取

2053
01:18:28,180 --> 01:18:30,040
整数 以及诸如此类的事情，所以现在我

2054
01:18:30,040 --> 01:18:32,920
可以使用这个 OP 代码

2055
01:18:32,920 --> 01:18:34,780
在我精益启动时开始解释它意味着我

2056
01:18:34,780 --> 01:18:35,980
可以开始执行而无需

2057
01:18:35,980 --> 01:18:37,960
运行编译器然后在后台

2058
01:18:37,960 --> 01:18:39,670
运行我的 LM 优化编译器我

2059
01:18:39,670 --> 01:18:41,860
生成 C++ 我先生们我的共享

2060
01:18:41,860 --> 01:18:44,380
对象我 然后可以将其链接并

2061
01:18:44,380 --> 01:18:46,110


2062
01:18:46,110 --> 01:18:48,610
再次启动它有点匆忙我可以展示

2063
01:18:48,610 --> 01:18:51,210
下一个课程，

2064
01:18:51,210 --> 01:18:53,020
所以主要的收获是

2065
01:18:53,020 --> 01:18:55,690
查询编译非常重要，

2066
01:18:55,690 --> 01:18:56,949
任何现代数据系统都将

2067
01:18:56,949 --> 01:18:57,699
采用 蚂蚁要做到这一点

2068
01:18:57,699 --> 01:18:59,440
，专栏将是不

2069
01:18:59,440 --> 01:19:01,300
容易实现的，但你需要了解

2070
01:19:01,300 --> 01:19:03,310
一些关于编译器和政治

2071
01:19:03,310 --> 01:19:05,770
系统的知识，截至 2016 年的 Mystique 方法

2072
01:19:05,770 --> 01:19:07,120
是要走的路

2073
01:19:07,120 --> 01:19:11,280
，现在每个系统都在探索，

2074
01:19:11,339 --> 01:19:19,139
好吧，这是什么

2075
01:19:19,310 --> 01:19:46,500
[音乐]

