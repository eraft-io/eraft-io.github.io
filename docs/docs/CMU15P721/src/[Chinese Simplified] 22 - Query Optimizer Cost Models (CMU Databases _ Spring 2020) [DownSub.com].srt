1
00:00:01,300 --> 00:00:05,129
[音乐]

2
00:00:05,200 --> 00:00:05,930
[掌声]

3
00:00:05,930 --> 00:00:08,630
[音乐]

4
00:00:08,630 --> 00:00:10,020
[掌声]

5
00:00:10,020 --> 00:00:15,619
[音乐]

6
00:00:15,619 --> 00:00:19,350
所以今天的重点是如何

7
00:00:19,350 --> 00:00:21,090
实际然后

8
00:00:21,090 --> 00:00:24,119
构建居里优化器的第二个主要组件，即如何

9
00:00:24,119 --> 00:00:27,539
实际估计我们认为

10
00:00:27,539 --> 00:00:29,670
该系统将实际执行的操作 什么时候

11
00:00:29,670 --> 00:00:30,750
做查询的借口，比如

12
00:00:30,750 --> 00:00:33,210
这会花费我们多少执行查询所以

13
00:00:33,210 --> 00:00:38,180
是的所以这不起作用所以

14
00:00:38,180 --> 00:00:40,440
我们必须这样做的原因

15
00:00:40,440 --> 00:00:42,480
当我们谈论基于成本的搜索时我应该有点明显

16
00:00:42,480 --> 00:00:44,460


17
00:00:44,460 --> 00:00:46,559
来自最后两个课程的模型 我说过有

18
00:00:46,559 --> 00:00:48,450
一种黑魔法盒的东西

19
00:00:48,450 --> 00:00:50,190
它会告诉我们这

20
00:00:50,190 --> 00:00:51,570
是执行这个特定查询的预期成本

21
00:00:51,570 --> 00:00:53,610
是什么 再次这是一个

22
00:00:53,610 --> 00:00:55,649
内部成本 它不是

23
00:00:55,649 --> 00:00:57,600
在数据库系统之外有意义的东西

24
00:00:57,600 --> 00:00:59,280
我的意思是你不能拿我的续集

25
00:00:59,280 --> 00:01:01,410
成本模型让它吐出一个数字

26
00:01:01,410 --> 00:01:02,940
然后拿 Postgres 这个成本模型拿

27
00:01:02,940 --> 00:01:04,830
那个数字然后做一个

28
00:01:04,830 --> 00:01:07,560
比较对这完全

29
00:01:07,560 --> 00:01:09,090
取决于系统的实现

30
00:01:09,090 --> 00:01:10,920
并且这真的只是为了让我们

31
00:01:10,920 --> 00:01:13,350
能够说这个

32
00:01:13,350 --> 00:01:15,479
查询计划由于某种原因比这个其他查询计划更好

33
00:01:15,479 --> 00:01:17,340
，这将在

34
00:01:17,340 --> 00:01:19,290
本讲座中描述，因此这就是我

35
00:01:19,290 --> 00:01:23,610
想正确使用的，所以另一件

36
00:01:23,610 --> 00:01:24,930
重要的事情是理解 - 这

37
00:01:24,930 --> 00:01:26,369
也是独立的 此成本模型

38
00:01:26,369 --> 00:01:28,799
与我们上次讨论的搜索策略无关 这

39
00:01:28,799 --> 00:01:30,360
意味着无论

40
00:01:30,360 --> 00:01:33,150
我们是自上而下还是自下而上

41
00:01:33,150 --> 00:01:34,950
我都没关系 我们在一天结束时

42
00:01:34,950 --> 00:01:36,299
我们仍然需要一个成本模型 那

43
00:01:36,299 --> 00:01:38,150
仍然需要我对你做出预测

44
00:01:38,150 --> 00:01:41,610
知道一个计划是否

45
00:01:41,610 --> 00:01:45,840
比另一个更好 所以如果你要建立一个

46
00:01:45,840 --> 00:01:47,880
成本模型 你实际上会如何

47
00:01:47,880 --> 00:01:49,950
做得好

48
00:01:49,950 --> 00:01:52,500
你可以在其中包含一些不同的东西 所以第一个是

49
00:01:52,500 --> 00:01:54,560
是物理成本，所以这些

50
00:01:54,560 --> 00:01:57,390
将是硬件

51
00:01:57,390 --> 00:02:00,240
在 X 使用查询时实际要做的事情

52
00:02:00,240 --> 00:02:01,890
多少 CPU 周期 多少缓存未

53
00:02:01,890 --> 00:02:04,020
命中 多少

54
00:02:04,020 --> 00:02:08,399
你将从磁盘读取多少日期 这是

55
00:02:08,399 --> 00:02:10,229
显而易见的 仅

56
00:02:10,229 --> 00:02:11,670
取决于您运行的机器及其硬件

57
00:02:11,670 --> 00:02:13,750
配置，因为正如我们看到的

58
00:02:13,750 --> 00:02:15,640
几个不同的例子，

59
00:02:15,640 --> 00:02:17,710
您是否将至强 CPU 用于

60
00:02:17,710 --> 00:02:20,230
至强 Phi，这些 CPU 具有非常不同的

61
00:02:20,230 --> 00:02:21,910
特性，因此

62
00:02:21,910 --> 00:02:24,220
您的性能 算法或您的

63
00:02:24,220 --> 00:02:26,710
查询可能会有所不同，这取决于

64
00:02:26,710 --> 00:02:29,920
它是什么硬件，因此这通常非常棘手

65
00:02:29,920 --> 00:02:31,780
，因为由于这个

66
00:02:31,780 --> 00:02:33,370
原因，实际上很难

67
00:02:33,370 --> 00:02:35,530
根据所有可能存在的可能的

68
00:02:35,530 --> 00:02:38,220
硬件配置构建模型

69
00:02:38,220 --> 00:02:40,900
，下一个方法是做什么 我将

70
00:02:40,900 --> 00:02:43,810
称为逻辑成本，这些是

71
00:02:43,810 --> 00:02:47,190
我们根据

72
00:02:47,190 --> 00:02:50,260
查询计划中的运算符在逻辑级别实际执行的操作来估算成本的地方，

73
00:02:50,260 --> 00:02:52,230


74
00:02:52,230 --> 00:02:54,489
因此不，它是物理级别

75
00:02:54,489 --> 00:02:56,200
，我将再次阅读此内容何时阻塞 某个

76
00:02:56,200 --> 00:02:58,840
磁盘的逻辑级别是我

77
00:02:58,840 --> 00:03:01,540
将从表中读取这么多元组，或者我的

78
00:03:01,540 --> 00:03:03,670
联合操作员会

79
00:03:03,670 --> 00:03:06,550
在连接后吐出这么多元组，或者我的扫描

80
00:03:06,550 --> 00:03:08,350
会过滤掉 ny 到这么多元组，

81
00:03:08,350 --> 00:03:11,020
所以对于这些，这将

82
00:03:11,020 --> 00:03:12,850
独立

83
00:03:12,850 --> 00:03:15,340
于我们在查询计划中实际使用的算法，所以这

84
00:03:15,340 --> 00:03:16,870
只是查看逻辑运算符

85
00:03:16,870 --> 00:03:19,120
，物理运算符是正确的，

86
00:03:19,120 --> 00:03:21,610
这应该是显而易见的，

87
00:03:21,610 --> 00:03:23,200
如果我 '正在做一个嵌套循环连接

88
00:03:23,200 --> 00:03:25,390
与哈希连接在一天结束时，

89
00:03:25,390 --> 00:03:27,370
两种算法应该

90
00:03:27,370 --> 00:03:30,430
生成完全相同的结果，写入

91
00:03:30,430 --> 00:03:32,470
相同数量的元组，否则

92
00:03:32,470 --> 00:03:35,019
我的实现会出现问题，

93
00:03:35,019 --> 00:03:36,760
因此我们不关心是否在

94
00:03:36,760 --> 00:03:38,680
对于逻辑方面，我们不

95
00:03:38,680 --> 00:03:40,450
关心您是否知道这是一种

96
00:03:40,450 --> 00:03:43,120
算法与另一种算法，所以棘手的

97
00:03:43,120 --> 00:03:44,890
事情将会是

98
00:03:44,890 --> 00:03:46,540
你们阅读的论文中的内容，我们将继续

99
00:03:46,540 --> 00:03:48,549
讨论未来

100
00:03:48,549 --> 00:03:49,959
需要能够

101
00:03:49,959 --> 00:03:52,450
准确估计操作员的输出将是什么，

102
00:03:52,450 --> 00:03:54,820
因为它将

103
00:03:54,820 --> 00:03:56,680
被馈送并作为

104
00:03:56,680 --> 00:03:58,600
下一个操作员的输入所以为了说你

105
00:03:58,600 --> 00:03:59,680
是第二个因为我要读

106
00:03:59,680 --> 00:04:00,880
进入这个操作符，因此

107
00:04:00,880 --> 00:04:02,590
产生这么多输出，你

108
00:04:02,590 --> 00:04:04,390
需要知道查询计划器中我下面的内容

109
00:04:04,390 --> 00:04:06,700
，这将

110
00:04:06,700 --> 00:04:09,010
是我们必须做的最困难的

111
00:04:09,010 --> 00:04:11,260
事情，最后一个将是

112
00:04:11,260 --> 00:04:12,549
平均成本 或

113
00:04:12,549 --> 00:04:15,340
运算符的渐近复杂性

114
00:04:15,340 --> 00:04:16,450
，这才是真正重要的地方，

115
00:04:16,450 --> 00:04:17,890
无论我们是在进行哈希连接还是

116
00:04:17,890 --> 00:04:20,140
嵌套循环连接或索引扫描与

117
00:04:20,140 --> 00:04:22,660
Quantrill 扫描，对于这些

118
00:04:22,660 --> 00:04:25,150
我们你知道我们可以只是

119
00:04:25,150 --> 00:04:28,509
我们可以排序 有权重是

120
00:04:28,509 --> 00:04:30,669
人们说的哦，散列关节是

121
00:04:30,669 --> 00:04:32,919
你知道 x 比凌乱的循环关节好 x 倍

122
00:04:32,919 --> 00:04:35,050
，因此更喜欢它，但

123
00:04:35,050 --> 00:04:36,310


124
00:04:36,310 --> 00:04:39,820
解决方案中显然有一些场景会更好，

125
00:04:39,820 --> 00:04:41,410
所以看看正在发生的事情，

126
00:04:41,410 --> 00:04:42,759
实际上我 将在接下来的几张

127
00:04:42,759 --> 00:04:45,789
幻灯片中展示我们主要要

128
00:04:45,789 --> 00:04:47,830
为内存数据库

129
00:04:47,830 --> 00:04:51,520


130
00:04:51,520 --> 00:04:55,720
做的事情 如果你能做到，我们将把这两者结合起来，但这很难，

131
00:04:55,720 --> 00:04:57,370
这是另一个很好的例子 就像

132
00:04:57,370 --> 00:04:59,979


133
00:04:59,979 --> 00:05:01,030
开源

134
00:05:01,030 --> 00:05:02,949
数据库系统的商业数据库系统之间的区别，所以

135
00:05:02,949 --> 00:05:05,590
在周一的演讲中，如果你

136
00:05:05,590 --> 00:05:07,690
去那个史诗般的 Rattus 演讲，他们

137
00:05:07,690 --> 00:05:10,330
就像哦，就像

138
00:05:10,330 --> 00:05:13,360
他们系统中的查询优化器是成熟困难的一样

139
00:05:13,360 --> 00:05:16,240
你知道他们

140
00:05:16,240 --> 00:05:19,000
在亚马逊上花了很多钱来修复它，

141
00:05:19,000 --> 00:05:20,500
它比任何开源软件都要好得多

142
00:05:20,500 --> 00:05:21,340
，

143
00:05:21,340 --> 00:05:23,020
它是商业级或

144
00:05:23,020 --> 00:05:24,550
企业级的，因为企业

145
00:05:24,550 --> 00:05:25,870
人员会包括所有这些

146
00:05:25,870 --> 00:05:28,090
东西 源人员可能只包括

147
00:05:28,090 --> 00:05:32,949
这两个人，所以对于基于光盘的

148
00:05:32,949 --> 00:05:35,320
数据库系统，我们关心的最明显的事情

149
00:05:35,320 --> 00:05:37,030
是光盘，

150
00:05:37,030 --> 00:05:38,199
这是一天结束时

151
00:05:38,199 --> 00:05:39,460
最昂贵的事情，例如

152
00:05:39,460 --> 00:05:41,800
从你知道的

153
00:05:41,800 --> 00:05:46,210
旋转中取出东西 这个硬盘驱动器或 SSD 所以在

154
00:05:46,210 --> 00:05:49,270
这个世界上，CPU 成本是不可

155
00:05:49,270 --> 00:05:51,370
忽略的，就像我们可以

156
00:05:51,370 --> 00:05:54,010
忽略它们一样，但如果你的成本模型只

157
00:05:54,010 --> 00:05:56,380
包括多少块

158
00:05:56,380 --> 00:05:58,030
你知道我

159
00:05:58,030 --> 00:06:00,220
从磁盘读取和写入多少数据块，这可能

160
00:06:00,220 --> 00:06:01,960
会让你知道 90% 的方式

161
00:06:01,960 --> 00:06:04,240
，谁在乎

162
00:06:04,240 --> 00:06:05,919
你在将数据放入内存时实际做

163
00:06:05,919 --> 00:06:07,810
了什么我猜它是从

164
00:06:07,810 --> 00:06:10,449
现在显然是最昂贵的东西

165
00:06:10,449 --> 00:06:14,770
，它

166
00:06:14,770 --> 00:06:17,740
在现代 SSD 上不是问题，但如果

167
00:06:17,740 --> 00:06:19,330
你有一个旋转的这个硬盘，你

168
00:06:19,330 --> 00:06:20,590
知道考虑到

169
00:06:20,590 --> 00:06:22,210
顺序 i/o 与随机 i/o

170
00:06:22,210 --> 00:06:24,699
之间的差异是一个很大的区别，一个 很多时候，

171
00:06:24,699 --> 00:06:27,310
您可以在磁盘或

172
00:06:27,310 --> 00:06:28,840
数据库系统中看到，尤其是较旧的系统，

173
00:06:28,840 --> 00:06:31,330
它们使用

174
00:06:31,330 --> 00:06:32,560
旨在优化

175
00:06:32,560 --> 00:06:36,419
顺序 I/O 数量的算法，您所做的一切都很好，因此

176
00:06:36,419 --> 00:06:39,030


177
00:06:39,030 --> 00:06:40,860
您知道的重要事情是理解但并且 基于磁盘

178
00:06:40,860 --> 00:06:43,680
的系统是数据库系统

179
00:06:43,680 --> 00:06:45,979
将

180
00:06:45,979 --> 00:06:48,389
通过其缓冲池管理完全控制内存中的内容，

181
00:06:48,389 --> 00:06:50,430
假设您没有使用 em

182
00:06:50,430 --> 00:06:54,210
映射，我们可以稍后讨论，

183
00:06:54,210 --> 00:06:56,460
您知道我们完全了解 在我们的

184
00:06:56,460 --> 00:06:57,990
数据库中，我们知道我们实际上是如何

185
00:06:57,990 --> 00:07:00,060
引入块的 我们知道我们如何

186
00:07:00,060 --> 00:07:02,819
写块 我们知道你知道

187
00:07:02,819 --> 00:07:05,189
什么算法正在使用什么算法来决定

188
00:07:05,189 --> 00:07:06,689
哪些数据是colle 我们想要驱逐哪些数据

189
00:07:06,689 --> 00:07:09,030
所以我们可以完全控制

190
00:07:09,030 --> 00:07:11,960
这个和 我们可以

191
00:07:11,960 --> 00:07:14,310
在成本

192
00:07:14,310 --> 00:07:16,349


193
00:07:16,349 --> 00:07:18,029


194
00:07:18,029 --> 00:07:19,590
模型的计算中包含

195
00:07:19,590 --> 00:07:20,939


196
00:07:20,939 --> 00:07:23,490
它 这是顺序说

197
00:07:23,490 --> 00:07:25,259
随机 i/o 我们可以然后你

198
00:07:25,259 --> 00:07:27,240
知道考虑到我们的成本模型

199
00:07:27,240 --> 00:07:28,680
来估计我们认为

200
00:07:28,680 --> 00:07:32,250
查询实际上会做的很好所以我

201
00:07:32,250 --> 00:07:34,949
会说你知道这就是

202
00:07:34,949 --> 00:07:36,300
我所描述的

203
00:07:36,300 --> 00:07:38,699


204
00:07:38,699 --> 00:07:40,740
如果您的分布式数据库只是

205
00:07:40,740 --> 00:07:43,770
将单词磁盘替换为网络

206
00:07:43,770 --> 00:07:46,860
，那么您将如何在单节点替换数据库系统上执行此操作，这基本上是相同的事情并且

207
00:07:46,860 --> 00:07:49,500
您有相同的问题，所以我想要一个

208
00:07:49,500 --> 00:07:52,560
快速示例 Postgr 这

209
00:07:52,560 --> 00:07:53,819
就是为什么我总是喜欢

210
00:07:53,819 --> 00:07:56,279
用课后作为例子来描述

211
00:07:56,279 --> 00:07:58,979
你如何知道真实的 Sussman 实际上是如何

212
00:07:58,979 --> 00:08:00,569
实现的，所以在我看来，

213
00:08:00,569 --> 00:08:02,009
这几乎就像教科书

214
00:08:02,009 --> 00:08:04,229
定义或

215
00:08:04,229 --> 00:08:06,029
数据库数据库系统的实现，就像你

216
00:08:06,029 --> 00:08:08,009
参加任何介绍课程，您

217
00:08:08,009 --> 00:08:10,349
在使用该课程时都会参加教科书以及

218
00:08:10,349 --> 00:08:12,150
他们描述算法的方式，并且在

219
00:08:12,150 --> 00:08:13,439
教科书中假定它

220
00:08:13,439 --> 00:08:16,889
在 Postgres 中的实际实现方式是准确的，因此

221
00:08:16,889 --> 00:08:18,000
对于 Postgres，他们将使用

222
00:08:18,000 --> 00:08:21,509
CPU 和 I/O 成本的组合。

223
00:08:21,509 --> 00:08:22,949
将被这些所谓的

224
00:08:22,949 --> 00:08:25,439
魔法常数因素加权，正确的魔法魔法

225
00:08:25,439 --> 00:08:28,379
权重，你这样做的原因

226
00:08:28,379 --> 00:08:30,150
基本上就是这样说，因为

227
00:08:30,150 --> 00:08:31,199
它取决于硬件

228
00:08:31,199 --> 00:08:32,969
实际可以做什么，所以他们会说你知道

229
00:08:32,969 --> 00:08:36,570
顺序输入/输出 你会知道比随机 i/o 快 x 倍，

230
00:08:36,570 --> 00:08:40,229
直接时间比

231
00:08:40,229 --> 00:08:43,078
随机 i/o 和内存 i/o 快 x

232
00:08:43,078 --> 00:08:44,940
倍，所以抓住为什么哦，

233
00:08:44,940 --> 00:08:49,100
好吧，所以在这种环境中，它们

234
00:08:49,100 --> 00:08:51,720
显然是目标

235
00:08:51,720 --> 00:08:54,149
在这些默认配置中使用

236
00:08:54,149 --> 00:08:56,009
磁盘上的数据库，因此

237
00:08:56,009 --> 00:08:57,509
您没有大量内存，因此

238
00:08:57,509 --> 00:08:59,069
他们再次希望以他们的成本使用它

239
00:08:59,069 --> 00:09:03,480
想要说明您知道

240
00:09:03,480 --> 00:09:05,250
实际发生了什么，但棘手的

241
00:09:05,250 --> 00:09:07,649
是他们 作为管理员向您公开这一点

242
00:09:07,649 --> 00:09:08,879
，您实际上可以

243
00:09:08,879 --> 00:09:10,230
为您调整这些等待，因此默认

244
00:09:10,230 --> 00:09:12,540
情况下内存比从磁盘读取快 400 倍

245
00:09:12,540 --> 00:09:14,430
，然后划伤 iOS，

246
00:09:14,430 --> 00:09:16,709
因为它比随机 i/o 快，因此您

247
00:09:16,709 --> 00:09:19,079
可以进入外观 在文档

248
00:09:19,079 --> 00:09:22,110
中查看您如何更改这些成本，

249
00:09:22,110 --> 00:09:23,550
但是他们在这里有一个很好的小

250
00:09:23,550 --> 00:09:26,220
警告，基本上是说如果

251
00:09:26,220 --> 00:09:28,620
您开始处理这些

252
00:09:28,620 --> 00:09:30,360
问题，您可能会遇到问题，因为

253
00:09:30,360 --> 00:09:33,839
这些都高度依赖于

254
00:09:33,839 --> 00:09:35,370
实际工作量是什么， 数据

255
00:09:35,370 --> 00:09:36,509
是什么样子以及你的硬件

256
00:09:36,509 --> 00:09:37,680
实际上是什么样子 真的很难

257
00:09:37,680 --> 00:09:40,889
做到这一点

258
00:09:40,889 --> 00:09:42,060


259
00:09:42,060 --> 00:09:43,290


260
00:09:43,290 --> 00:09:43,949
知道你在做什么

261
00:09:43,949 --> 00:09:46,050
，你不想导致

262
00:09:46,050 --> 00:09:47,279
回归 你知道你的

263
00:09:47,279 --> 00:09:50,790
工作负载的一部分 联合一个商业系统

264
00:09:50,790 --> 00:09:53,699
是做什么的 我们可以看看 db2 在

265
00:09:53,699 --> 00:09:55,769
他们的系统中的所有三个主要

266
00:09:55,769 --> 00:09:58,889
系统 db2 sequel server 和 Oracle

267
00:09:58,889 --> 00:10:00,870
db2 实际上是最开放的，

268
00:10:00,870 --> 00:10:02,939
讨论他们的查询优化器

269
00:10:02,939 --> 00:10:04,170
做什么以及他们的成本模型实际上

270
00:10:04,170 --> 00:10:06,959
做了什么我

271
00:10:06,959 --> 00:10:08,550
据我所知没有

272
00:10:08,550 --> 00:10:12,720
来自 Oracle 或续集

273
00:10:12,720 --> 00:10:13,769
服务器的主要出版物谈论他们

274
00:10:13,769 --> 00:10:14,970
做什么我们只是有点

275
00:10:14,970 --> 00:10:16,410
通过与那里的人交谈了解一些事情

276
00:10:16,410 --> 00:10:18,269
，但 IBM 实际上非常

277
00:10:18,269 --> 00:10:19,769
擅长讨论这个问题，这个电话

278
00:10:19,769 --> 00:10:22,199
来自 Guy Loman 的演讲，

279
00:10:22,199 --> 00:10:24,360
他发明了

280
00:10:24,360 --> 00:10:26,220
我们在两个类前讨论过的星爆材料，

281
00:10:26,220 --> 00:10:29,550
所以 db2 成本模型

282
00:10:29,550 --> 00:10:31,649
是所有这些东西的组合

283
00:10:31,649 --> 00:10:32,939
所以首先他们要

284
00:10:32,939 --> 00:10:34,800
看看数据库实际上是什么样子

285
00:10:34,800 --> 00:10:36,809
所以架构 他说他们

286
00:10:36,809 --> 00:10:38,670
在表上收集 c  olumns 在

287
00:10:38,670 --> 00:10:41,040
索引中，但是

288
00:10:41,040 --> 00:10:42,899
当您打开系统时，它们也会

289
00:10:42,899 --> 00:10:44,309
运行这些小型微型基准测试

290
00:10:44,309 --> 00:10:46,379
微型基准测试，这些微型基准测试将进行

291
00:10:46,379 --> 00:10:48,829
压力测试，例如 CPU、磁盘

292
00:10:48,829 --> 00:10:51,389
内存和网络，如果您愿意的话 这是

293
00:10:51,389 --> 00:10:54,300
一个分布式系统，我然后我们用

294
00:10:54,300 --> 00:10:57,660
它来基本上

295
00:10:57,660 --> 00:10:59,430
生成我在最后一张 Postgres 幻灯片中向您展示的权重，

296
00:10:59,430 --> 00:11:01,380
所以第一个

297
00:11:01,380 --> 00:11:04,199
问题是手动设置这些权重 db2

298
00:11:04,199 --> 00:11:05,040
试图弄清楚这一点

299
00:11:05,040 --> 00:11:06,180
，并尝试成为真正的细粒度

300
00:11:06,180 --> 00:11:07,740
基于您的硬件实际可以

301
00:11:07,740 --> 00:11:11,670
做什么，但是当您实际开始

302
00:11:11,670 --> 00:11:13,560
对显示的查询进行成本估算时，

303
00:11:13,560 --> 00:11:15,810
他们只是不会单独查看您

304
00:11:15,810 --> 00:11:17,790
的查询，

305
00:11:17,790 --> 00:11:19,740
他们还会考虑

306
00:11:19,740 --> 00:11:21,680
其他同时运行的内容 时间，

307
00:11:21,680 --> 00:11:24,420
然后使用它来确定您

308
00:11:24,420 --> 00:11:26,190
知道这些并发

309
00:11:26,190 --> 00:11:27,569
操作对您的特定

310
00:11:27,569 --> 00:11:29,970
查询的影响，例如如果您自己运行，

311
00:11:29,970 --> 00:11:31,470
那么您就知道您占用

312
00:11:31,470 --> 00:11:34,410
了世界上的所有内存，并且 你运行得非常快，但是如果

313
00:11:34,410 --> 00:11:35,579
你的一堆其他查询不

314
00:11:35,579 --> 00:11:36,810
同时你不会得到所有的

315
00:11:36,810 --> 00:11:38,399
内存，那么到目前为止他们可能会在

316
00:11:38,399 --> 00:11:40,350
他们再次

317
00:11:40,350 --> 00:11:42,139
估计你的查询计划的成本时考虑到这

318
00:11:42,139 --> 00:11:44,970
一点 这只是它

319
00:11:44,970 --> 00:11:47,399
比任何

320
00:11:47,399 --> 00:11:49,440
开源人员所做的更复杂

321
00:11:49,440 --> 00:11:50,759
，据我所知，Postgres 至少 Alessa med

322
00:11:50,759 --> 00:11:53,370
locus 比我的续集要好得多，

323
00:11:53,370 --> 00:11:58,529
它可能是最好的开源，它

324
00:11:58,529 --> 00:11:59,699
是最好的开源 查询优化器

325
00:11:59,699 --> 00:12:01,339
成本模型，今天就在那里

326
00:12:01,339 --> 00:12:03,690
他是一年前租用的，当我查看时，

327
00:12:03,690 --> 00:12:05,160
我不知道

328
00:12:05,160 --> 00:12:08,100


329
00:12:08,100 --> 00:12:09,060


330
00:12:09,060 --> 00:12:12,470
那么他们是如何通过

331
00:12:12,470 --> 00:12:15,360
查看

332
00:12:15,360 --> 00:12:17,389
内存数据库系统专业的文档和手册来做到这一点的呢？

333
00:12:17,389 --> 00:12:20,420
据他们所知，每个人都在

334
00:12:20,420 --> 00:12:23,510
做我在这里写的事情，所以

335
00:12:23,510 --> 00:12:25,860
基本上磁盘不见了，所以你不关心

336
00:12:25,860 --> 00:12:28,170
磁盘我 /o 是的，您必须写入

337
00:12:28,170 --> 00:12:30,269
日志，但那是 inc

338
00:12:30,269 --> 00:12:32,699
不影响您选择一个

339
00:12:32,699 --> 00:12:33,930
特定查询计划还是选择另一个查询计划的相同权利，

340
00:12:33,930 --> 00:12:37,079
比如我更新一个表，比如谁

341
00:12:37,079 --> 00:12:39,660
在乎磁盘，不考虑在正确

342
00:12:39,660 --> 00:12:41,100
写入日志记录的成本中，

343
00:12:41,100 --> 00:12:44,639
所以在一天结束时

344
00:12:44,639 --> 00:12:47,939
他们是所有的中间

345
00:12:47,939 --> 00:12:50,360
基础将主要结合

346
00:12:50,360 --> 00:12:52,709


347
00:12:52,709 --> 00:12:53,939
操作员正在处理的元组数量或有多少

348
00:12:53,939 --> 00:12:57,360
人担任将军和一些基本

349
00:12:57,360 --> 00:13:00,209
权重来说明散列连接

350
00:13:00,209 --> 00:13:02,670
比初始循环连接更好，但是

351
00:13:02,670 --> 00:13:04,529
进出元组的数量是

352
00:13:04,529 --> 00:13:08,519
您实际上不能

353
00:13:08,519 --> 00:13:10,589
做任何更细粒度的事情的主要原因

354
00:13:10,589 --> 00:13:12,449


355
00:13:12,449 --> 00:13:14,069


356
00:13:14,069 --> 00:13:17,040
您可以在基于磁盘的

357
00:13:17,040 --> 00:13:18,899
系统中使用是因为我们

358
00:13:18,899 --> 00:13:20,819
实际上可以控制系统的现金

359
00:13:20,819 --> 00:13:23,279
管理，这

360
00:13:23,279 --> 00:13:25,680
一切都由 CPU 和 CPU 完成 我们可以

361
00:13:25,680 --> 00:13:27,059
向它提供提示 我们可以预取

362
00:13:27,059 --> 00:13:28,410
东西 我们可以尝试将东西固定在我们的

363
00:13:28,410 --> 00:13:30,300
缓存中 但是 归根结底，

364
00:13:30,300 --> 00:13:32,939
CPU 会自行决定什么

365
00:13:32,939 --> 00:13:34,680
会移入和移出缓存，因此我们

366
00:13:34,680 --> 00:13:35,910
甚至不关心任何这些，因此我们

367
00:13:35,910 --> 00:13:39,689
只是尝试估计

368
00:13:39,689 --> 00:13:41,449
操作员将要读取的数据量和 写

369
00:13:41,449 --> 00:13:46,170
出来结果是一口井

370
00:13:46,170 --> 00:13:47,879
我会说一个合理的估计

371
00:13:47,879 --> 00:13:50,670
我要使用的 CPU 资源 我要

372
00:13:50,670 --> 00:13:53,610
用来运行我的查询 这也说明我们

373
00:13:53,610 --> 00:13:57,110
这也不是会计天气，

374
00:13:57,110 --> 00:13:59,579
比如我是否 想要运行一个线程

375
00:13:59,579 --> 00:14:01,920
而不是 100 个线程，这是

376
00:14:01,920 --> 00:14:03,869
一种单独的策略，与

377
00:14:03,869 --> 00:14:06,240
我们在这里尝试做的不同，但这

378
00:14:06,240 --> 00:14:07,679
几乎就像系统的任务控制或

379
00:14:07,679 --> 00:14:10,040
资源管理，因此

380
00:14:10,040 --> 00:14:12,269
通常据我所知你没有 你

381
00:14:12,269 --> 00:14:13,949
不会在会计中看到这一点，而不是

382
00:14:13,949 --> 00:14:15,720
像路径后的那种小屋那样的成本模型

383
00:14:15,720 --> 00:14:19,679
，如果你有它

384
00:14:19,679 --> 00:14:20,970
，即使你是一个内存

385
00:14:20,970 --> 00:14:23,879
系统，就像看看 mem 续集一样，因为

386
00:14:23,879 --> 00:14:25,949
它们” 重新分发再回到

387
00:14:25,949 --> 00:14:27,240
最后一张幻灯片他们关心的网络

388
00:14:27,240 --> 00:14:29,670
s  o 他们必须考虑到这一点，

389
00:14:29,670 --> 00:14:32,339
在这方面并不重要，但

390
00:14:32,339 --> 00:14:36,240
就像网络是主要因素一样，好吧，

391
00:14:36,240 --> 00:14:40,730
所以我想举一个例子，

392
00:14:40,730 --> 00:14:43,980
说明 1990 年代的复杂成本

393
00:14:43,980 --> 00:14:46,620
模型是在小基础上完成的

394
00:14:46,620 --> 00:14:47,819
实际上，我们使用 db2 进行了一些我们讨论的事情，

395
00:14:47,819 --> 00:14:50,790
因此

396
00:14:50,790 --> 00:14:52,079
他们将采用这种两阶段

397
00:14:52,079 --> 00:14:57,209
方法，其中 vidalias

398
00:14:57,209 --> 00:14:58,589
开发人员正在构建系统，

399
00:14:58,589 --> 00:15:00,389
就像在公司中

400
00:15:00,389 --> 00:15:02,370
构建小型基础一样，他们会尝试

401
00:15:02,370 --> 00:15:04,019
确定在查询执行期间发生的所有这些低级

402
00:15:04,019 --> 00:15:07,290
原语是什么，

403
00:15:07,290 --> 00:15:09,149
无论

404
00:15:09,149 --> 00:15:10,470
它们是否是原语，

405
00:15:10,470 --> 00:15:12,299
就像在向量明智的

406
00:15:12,299 --> 00:15:13,589
原语中你喜欢的那些，

407
00:15:13,589 --> 00:15:15,329
但它就像低一样 - 级别的

408
00:15:15,329 --> 00:15:17,910
事情，例如我读取索引或

409
00:15:17,910 --> 00:15:21,509
写入元组，以便它们生成这些

410
00:15:21,509 --> 00:15:25,350
低级别操作，然后

411
00:15:25,350 --> 00:15:29,220
创建这些微基准测试，使

412
00:15:29,220 --> 00:15:31,680
它们能够模拟

413
00:15:31,680 --> 00:15:34,050
这些不同的操作中的每一个，

414
00:15:34,050 --> 00:15:37,500
然后 现在在您的系统中运行时，当

415
00:15:37,500 --> 00:15:40,860
您部署以部署一个小型基础时，他们

416
00:15:40,860 --> 00:15:42,390
会

417
00:15:42,390 --> 00:15:44,490
在您打开系统时运行所有这些微基准测试并

418
00:15:44,490 --> 00:15:46,560
收集一些有关

419
00:15:46,560 --> 00:15:49,290
您的机器的速度的配置文件信息，然后在

420
00:15:49,290 --> 00:15:51,750
您查看成本模型时 一个查询计划，

421
00:15:51,750 --> 00:15:52,950
你计算他们正在做的这些

422
00:15:52,950 --> 00:15:54,510
低级操作或原语的数量

423
00:15:54,510 --> 00:15:57,330
，乘以

424
00:15:57,330 --> 00:16:00,060
你收集的微基准测试结果

425
00:16:00,060 --> 00:16:01,740
，然后这就是他们如何

426
00:16:01,740 --> 00:16:03,300
确定你知道

427
00:16:03,300 --> 00:16:07,020
的执行查询的成本 计划没问题，所以

428
00:16:07,020 --> 00:16:10,680
对于内存数据库中早期的小型基础

429
00:16:10,680 --> 00:16:12,630
，惠普

430
00:16:12,630 --> 00:16:15,270
实验室的一些原型惠普实验室然后将其剥离为

431
00:16:15,270 --> 00:16:16,890
一家名为 10 次的独立公司，

432
00:16:16,890 --> 00:16:19,500
然后 10 次在 2006 年被甲骨文收购

433
00:16:19,500 --> 00:16:23,250
，它今天仍然存在

434
00:16:23,250 --> 00:16:26,970
可以下载它 用于击败它的旧系统

435
00:16:26,970 --> 00:16:28,200
我们还没有针对新系统尝试过它，

436
00:16:28,200 --> 00:16:32,040
但 Oracle 主要

437
00:16:32,040 --> 00:16:34,529
将它作为 CPU 缓存出售，或者对不起

438
00:16:34,529 --> 00:16:36,630
，主要 Oracle 的内存缓存，

439
00:16:36,630 --> 00:16:38,670
如 flagsh  ip 数据库，但你仍然不能把

440
00:16:38,670 --> 00:16:40,260
它作为一个独立的系统运行，

441
00:16:40,260 --> 00:16:42,270
但据我所知，通过

442
00:16:42,270 --> 00:16:44,850
查看文档，

443
00:16:44,850 --> 00:16:46,589
他们在 1990 年代做了 19 就像这篇论文一样，他们

444
00:16:46,589 --> 00:16:48,330
在今天的真实系统中没有这样做 他们

445
00:16:48,330 --> 00:16:49,890
仍然 他们会做我之前描述的事情吗？

446
00:16:49,890 --> 00:16:51,150
他们只是

447
00:16:51,150 --> 00:16:52,589
估计操作员进出球的数量是多少，

448
00:16:52,589 --> 00:16:56,100
这种

449
00:16:56,100 --> 00:16:57,660
方法类似于 boga mips 如果您

450
00:16:57,660 --> 00:16:59,580
在

451
00:16:59,580 --> 00:17:02,190
启动 linux 时就知道 linux 中的内容，他们运行

452
00:17:02,190 --> 00:17:03,360
这个叫做 booger bits 的小型微型企业

453
00:17:03,360 --> 00:17:05,400
试图估算

454
00:17:05,400 --> 00:17:07,260
你的 CPU 的速度，如果你看起来像 /proc 斜线 cpu 信息，他们会使用它来

455
00:17:07,260 --> 00:17:10,079
进行诸如中断和调度的定时决策，

456
00:17:10,079 --> 00:17:11,939


457
00:17:11,939 --> 00:17:14,699
你会看到你

458
00:17:14,699 --> 00:17:16,829
知道这里是这里的 这是我的英特尔

459
00:17:16,829 --> 00:17:18,900
CPU 这是这里的型号

460
00:17:18,900 --> 00:17:20,819
当然我会有一

461
00:17:20,819 --> 00:17:22,800
点点 karpova mips 你用

462
00:17:22,800 --> 00:17:24,359
它来估计

463
00:17:24,359 --> 00:17:31,710
你的 CPU 的速度有多快所以我说

464
00:17:31,710 --> 00:17:32,730
我们最重要的事情 会关心一个 bout

465
00:17:32,730 --> 00:17:35,040
是输入的元组数量，

466
00:17:35,040 --> 00:17:39,000
第二个是由操作员输出或处理的，

467
00:17:39,000 --> 00:17:40,860
所以现在我们必须弄清楚

468
00:17:40,860 --> 00:17:42,030
我们将如何实际能够

469
00:17:42,030 --> 00:17:43,120
估计它，

470
00:17:43,120 --> 00:17:45,080
所以我们要这样做的方式

471
00:17:45,080 --> 00:17:46,520
是 我们将尝试估计

472
00:17:46,520 --> 00:17:52,220
一个运算符的选择性，该运算符

473
00:17:52,220 --> 00:17:54,200
将

474
00:17:54,200 --> 00:17:57,350
确定输入其中的元组的

475
00:17:57,350 --> 00:17:58,400
百分比，然后

476
00:17:58,400 --> 00:18:00,590
将被视为输出的元组的百分比，所以

477
00:18:00,590 --> 00:18:02,150
如果我是 给定一百个元组，我的

478
00:18:02,150 --> 00:18:05,120
选择性是 10%，那么我承认

479
00:18:05,120 --> 00:18:09,400
十个 tubal 没问题，所以你

480
00:18:09,400 --> 00:18:11,120
在数据库系统中传统上这样做的方式

481
00:18:11,120 --> 00:18:12,590
是你可以将其建模为

482
00:18:12,590 --> 00:18:15,770
一个谓词

483
00:18:15,770 --> 00:18:19,330
是否满足的概率 特定的元组

484
00:18:19,330 --> 00:18:23,090
，所以我们现在可以生成

485
00:18:23,090 --> 00:18:24,650
这些概率估计的方式

486
00:18:24,650 --> 00:18:26,480
是通过这些不同技术的组合，

487
00:18:26,480 --> 00:18:28,220
因此我们可以

488
00:18:28,220 --> 00:18:29,840
正确地设置域约束，这

489
00:18:29,840 --> 00:18:32,990
就像如果我们知道您

490
00:18:32,990 --> 00:18:35,090
提前知道值范围 一个

491
00:18:35,090 --> 00:18:37,880
特定的属性，比如它是一个

492
00:18:37,880 --> 00:18:39,920
枚举字段，我们知道只有

493
00:18:39,920 --> 00:18:42,890
基数是固定的，我们可以依靠预先

494
00:18:42,890 --> 00:18:44,570
计算的统计数据，我们可以生成

495
00:18:44,570 --> 00:18:47,000
并放入我们的数据块和

496
00:18:47,000 --> 00:18:48,650
表中 我的意思是我们之前

497
00:18:48,650 --> 00:18:49,940
在谈论压缩时与我们交谈过

498
00:18:49,940 --> 00:18:51,140
这些就像缩放地图，所以我可以预先计算

499
00:18:51,140 --> 00:18:54,350


500
00:18:54,350 --> 00:18:56,840
块中不同列的聚合，然后当我想

501
00:18:56,840 --> 00:18:59,330
弄清楚

502
00:18:59,330 --> 00:19:01,040
我的运算符

503
00:19:01,040 --> 00:19:02,840
匹配我的谓词匹配

504
00:19:02,840 --> 00:19:04,820
元组的可能性是多少时 在一个块内，我

505
00:19:04,820 --> 00:19:05,990
可以查看区域图，并可能

506
00:19:05,990 --> 00:19:08,030
获得一些早期信息，例如

507
00:19:08,030 --> 00:19:11,240
最小最大值，我们也可以使用

508
00:19:11,240 --> 00:19:13,250
直方图或近似值，我将

509
00:19:13,250 --> 00:19:14,930
在稍后讨论，然后我们还

510
00:19:14,930 --> 00:19:18,530
进行采样，因此没有一个

511
00:19:18,530 --> 00:19:20,600
是 比另一个像你一样

512
00:19:20,600 --> 00:19:22,040
想要使用所有这些东西的组合

513
00:19:22,040 --> 00:19:23,240
，你可以尝试估计

514
00:19:23,240 --> 00:19:24,770
选择性，比如

515
00:19:24,770 --> 00:19:32,450
你可以获得的信息越多越好，所以现在

516
00:19:32,450 --> 00:19:34,010
的元组数量 我们将

517
00:19:34,010 --> 00:19:35,230
最终处理将

518
00:19:35,230 --> 00:19:38,930
组合我们正在

519
00:19:38,930 --> 00:19:41,300
处理的两条船将是 10 并且

520
00:19:41,300 --> 00:19:43,520
取决于三个不同的事情所以首先

521
00:19:43,520 --> 00:19:45,230
显然是我们用来访问的访问方法

522
00:19:45,230 --> 00:19:47,090


523
00:19:47,090 --> 00:19:49,010
如果是顺序扫描，则从表中读取到 Plus，

524
00:19:49,010 --> 00:19:50,930
然后我们可能会查看

525
00:19:50,930 --> 00:19:52,400
所有内容，除非我们下推限制

526
00:19:52,400 --> 00:19:55,130
子句，如果它是索引扫描，我们可以进行

527
00:19:55,130 --> 00:19:56,540
更细粒度的扫描，然后

528
00:19:56,540 --> 00:19:58,550
查看您知道的子集 总

529
00:19:58,550 --> 00:20:00,980
键空间然后我们实际上

530
00:20:00,980 --> 00:20:02,150
将数据库属性的值的分布

531
00:20:02,150 --> 00:20:03,920
正确这

532
00:20:03,920 --> 00:20:05,390
是估计的东西将

533
00:20:05,390 --> 00:20:07,430
发挥作用的地方我不知道对于

534
00:20:07,430 --> 00:20:10,250
给定的谓词

535
00:20:10,250 --> 00:20:12,350
我有什么概率的可能性 值，

536
00:20:12,350 --> 00:20:15,230
你知道这会满足我

537
00:20:15,230 --> 00:20:16,730
会当然然后还有什么是

538
00:20:16,730 --> 00:20:18,470
实际的谓词 - 如果

539
00:20:18,470 --> 00:20:20,900
我在一个独特的列上做一个质量谓词，

540
00:20:20,900 --> 00:20:23,360
那么我知道我的

541
00:20:23,360 --> 00:20:25,250
选择性会变得麻木

542
00:20:25,250 --> 00:20:26,960
我拥有的元组，因为只有一个

543
00:20:26,960 --> 00:20:28,910
实际上可以匹配，但是现在如果我开始

544
00:20:28,910 --> 00:20:32,180
进行范围扫描，那么尝试正确估计这一点就变得有

545
00:20:32,180 --> 00:20:33,650
问题，

546
00:20:33,650 --> 00:20:35,870
所以主要的收获是对于

547
00:20:35,870 --> 00:20:37,400
简单的查询，例如某事等于某

548
00:20:37,400 --> 00:20:40,010
事，我们可以做一个 相当

549
00:20:40,010 --> 00:20:42,770
好的匹配工作，如果你开始

550
00:20:42,770 --> 00:20:46,670
抛出不等式抛出范围

551
00:20:46,670 --> 00:20:49,790
扫描抛出析取然后它

552
00:20:49,790 --> 00:20:52,550
变得非常困难，因为

553
00:20:52,550 --> 00:20:58,940
更多的数据你可以获得更好的所以

554
00:20:58,940 --> 00:21:00,890
我们在介绍课上再次

555
00:21:00,890 --> 00:21:02,210
教你如何生成直方图

556
00:21:02,210 --> 00:21:04,550
的一种方法 这基本上是你

557
00:21:04,550 --> 00:21:06,890


558
00:21:06,890 --> 00:21:08,660
在你的数据库系统中运行分析操作的分析函数

559
00:21:08,660 --> 00:21:11,000
，它对你的表进行顺序扫描，它

560
00:21:11,000 --> 00:21:14,690
根据

561
00:21:14,690 --> 00:21:18,170
它实际看到的值计算某种直方图，所以

562
00:21:18,170 --> 00:21:19,340
这就是标准

563
00:21:19,340 --> 00:21:23,690
技术。 近年来更

564
00:21:23,690 --> 00:21:26,900
流行的是生成一

565
00:21:26,900 --> 00:21:28,760
组精确的直方图来生成

566
00:21:28,760 --> 00:21:30,530
所谓的草图，这些草图是这些

567
00:21:30,530 --> 00:21:33,110
近似的 数据数据结构

568
00:21:33,110 --> 00:21:36,110
可以为您提供有关

569
00:21:36,110 --> 00:21:38,270
数据中包含的内容的提示，因此可以

570
00:21:38,270 --> 00:21:39,920
将其视为像布隆过滤器一样的命中，这

571
00:21:39,920 --> 00:21:41,150
是一种近似的数据

572
00:21:41,150 --> 00:21:42,830
结构，因为它可能会给您

573
00:21:42,830 --> 00:21:44,330
误报，但我 我永远不会是

574
00:21:44,330 --> 00:21:45,980
假阴性，你实际上不能

575
00:21:45,980 --> 00:21:48,680
告诉它不会告诉你

576
00:21:48,680 --> 00:21:50,450
布隆过滤器中实际有哪些值或键，

577
00:21:50,450 --> 00:21:51,890
如果你只是问它是否存在某些东西

578
00:21:51,890 --> 00:21:53,320
，它会给你一个真或假，

579
00:21:53,320 --> 00:21:55,280
所以这些草图

580
00:21:55,280 --> 00:21:57,770
比让你

581
00:21:57,770 --> 00:21:59,270
知道简单的真假要复杂得多，它们

582
00:21:59,270 --> 00:22:01,400
实际上可以告诉你

583
00:22:01,400 --> 00:22:04,370
可能存在的价值，但同样你可能

584
00:22:04,370 --> 00:22:06,230
会有误报我不知道

585
00:22:06,230 --> 00:22:07,610
其中一些我实际上有时不知道

586
00:22:07,610 --> 00:22:08,480
我不知道你是否也得到了假

587
00:22:08,480 --> 00:22:10,350
阴性，

588
00:22:10,350 --> 00:22:13,059
所以有很多不同类型的

589
00:22:13,059 --> 00:22:17,049
草图人们可以正确使用

590
00:22:17,049 --> 00:22:19,299
我提出这个的原因是

591
00:22:19,299 --> 00:22:22,630
几年前我们有拼接机的 CEO

592
00:22:22,630 --> 00:22:25,570
来给一个 在内部

593
00:22:25,570 --> 00:22:29,590
交谈 ro 班，他看到了我

594
00:22:29,590 --> 00:22:31,809
，他是院长的顾问委员会成员，

595
00:22:31,809 --> 00:22:34,870
他在 2 月份来到这里，

596
00:22:34,870 --> 00:22:36,280
当他谈论

597
00:22:36,280 --> 00:22:37,660
他们的查询优化器和他们的成本

598
00:22:37,660 --> 00:22:40,240
模型时，他发表了这样的评论，他们最初按照教科书的方式

599
00:22:40,240 --> 00:22:41,799
进行了提炼

600
00:22:41,799 --> 00:22:43,750
首先是直方图，他们使用

601
00:22:43,750 --> 00:22:45,370
标准算法方程来尝试

602
00:22:45,370 --> 00:22:47,380
对谓词及其运算符的选择性进行估计，

603
00:22:47,380 --> 00:22:50,290
但后来

604
00:22:50,290 --> 00:22:51,730
他们最终使用

605
00:22:51,730 --> 00:22:54,070
了 Yahoo 的这个草图库，它正确地进行了这些

606
00:22:54,070 --> 00:22:56,290
近似，因此您可以

607
00:22:56,290 --> 00:22:58,240
限制您得到的错误限制和

608
00:22:58,240 --> 00:22:59,890
估计可以说，哦，

609
00:22:59,890 --> 00:23:01,030
这就是我认为的

610
00:23:01,030 --> 00:23:03,010
结果，这是我的信心，但

611
00:23:03,010 --> 00:23:05,559
我要告诉你的是，他们说，当

612
00:23:05,559 --> 00:23:07,480
他们转而使用这些草图

613
00:23:07,480 --> 00:23:09,790
而不是直方图时，

614
00:23:09,790 --> 00:23:11,710
他们预测的准确性和

615
00:23:11,710 --> 00:23:14,620
查询优化器的健壮性我主要是因为

616
00:23:14,620 --> 00:23:17,650
它因为更好的成本

617
00:23:17,650 --> 00:23:19,600
模型差异相当显着所以我

618
00:23:19,600 --> 00:23:21,040
认为他们说他们喜欢 e 在旧

619
00:23:21,040 --> 00:23:22,510
系统中，当他们使用直方图时，

620
00:23:22,510 --> 00:23:24,940
他们可以执行成本模型

621
00:23:24,940 --> 00:23:28,480
，每个查询最多 10 个表，

622
00:23:28,480 --> 00:23:30,490
查看 10 个表连接，但是当

623
00:23:30,490 --> 00:23:32,020
他们添加这个时，我认为我们

624
00:23:32,020 --> 00:23:34,660
可以增加到 75 个表，其中 又

625
00:23:34,660 --> 00:23:36,850
不是那么我说的是

626
00:23:36,850 --> 00:23:38,679
用于确定

627
00:23:38,679 --> 00:23:40,390
成本模型质量的正确指标，但这是一种

628
00:23:40,390 --> 00:23:42,880
轶事证据，表明

629
00:23:42,880 --> 00:23:45,130
使用现金比直方图更好，并且

630
00:23:45,130 --> 00:23:47,860
在我们结束的旧系统中的旧优化器中

631
00:23:47,860 --> 00:23:50,679
也使用直方图，但

632
00:23:50,679 --> 00:23:52,360
很抱歉，是的，然后我也在使用其中

633
00:23:52,360 --> 00:23:55,240
一些草图，但我们

634
00:23:55,240 --> 00:23:56,559
从来没有发明过它，我们从来没有，我们从来没有

635
00:23:56,559 --> 00:23:57,700
真正测量过它实际上有多好

636
00:23:57,700 --> 00:24:02,710
，我认为这种方法

637
00:24:02,710 --> 00:24:04,120
是 也用于商业

638
00:24:04,120 --> 00:24:07,270
系统

639
00:24:07,270 --> 00:24:09,010
生成关于

640
00:24:09,010 --> 00:24:12,610
选择性的估计的另一个主要技术是进行采样这里的基本

641
00:24:12,610 --> 00:24:14,950
思想是，而不是查看

642
00:24:14,950 --> 00:24:16,570
这些草图或直方图并

643
00:24:16,570 --> 00:24:18,419
尝试近似选择性

644
00:24:18,419 --> 00:24:21,460
让我实际上只是取

645
00:24:21,460 --> 00:24:22,990
我正在访问的表的一个子集

646
00:24:22,990 --> 00:24:26,380
运行我的查询或运行我的皮肤并

647
00:24:26,380 --> 00:24:28,420
在其上使用谓词然后确定

648
00:24:28,420 --> 00:24:31,000
我的选择性是什么然后

649
00:24:31,000 --> 00:24:33,160
假设我的样本是一个很好的近似值

650
00:24:33,160 --> 00:24:35,830
实际上总表 看起来

651
00:24:35,830 --> 00:24:37,480
然后现在我有了更好的

652
00:24:37,480 --> 00:24:39,700
知识，让我可以在

653
00:24:39,700 --> 00:24:43,510
我的成本模型中做出我的选择，所以基本上有

654
00:24:43,510 --> 00:24:45,309
两种方法可以做到这一点，就像在线

655
00:24:45,309 --> 00:24:48,370
和离线一样，所以离线方法

656
00:24:48,370 --> 00:24:51,580
是你在后台每

657
00:24:51,580 --> 00:24:53,470
隔一段时间你就会产生 这个

658
00:24:53,470 --> 00:24:56,950
只读的表格副本，你

659
00:24:56,950 --> 00:25:00,040
把它放在一边，然后你做

660
00:25:00,040 --> 00:25:01,330
你的样本，你在你的

661
00:25:01,330 --> 00:25:02,950
交叉模型中使用它来预测

662
00:25:02,950 --> 00:25:05,380
你的谓词的选择性，然后你

663
00:25:05,380 --> 00:25:07,420
有这样的背景

664
00:25:07,420 --> 00:25:10,630
工作 看起来并说清楚

665
00:25:10,630 --> 00:25:13,450
我的数据有多少发生了变化，然后

666
00:25:13,450 --> 00:25:14,770
如果你知道它高于某个

667
00:25:14,770 --> 00:25:17,260
阈值，那么我回去刷新

668
00:25:17,260 --> 00:25:21,100
我的样本另一个人来做这个

669
00:25:21,100 --> 00:25:23,980
在线时尚是w 当查询

670
00:25:23,980 --> 00:25:26,130
出现并且你进入你的成本模型时，你

671
00:25:26,130 --> 00:25:30,130
实际上进入真实的表并运行

672
00:25:30,130 --> 00:25:32,530
你的一点查询

673
00:25:32,530 --> 00:25:34,750
，然后确定

674
00:25:34,750 --> 00:25:36,550
你的谓词谓词的选择性是什么，

675
00:25:36,550 --> 00:25:37,840
显然这变得棘手，因为

676
00:25:37,840 --> 00:25:39,970
你必须 您试图

677
00:25:39,970 --> 00:25:43,410
为运行查询进行成本估算，

678
00:25:43,410 --> 00:25:45,460
但现在您实际上运行并运行

679
00:25:45,460 --> 00:25:47,200
了查询，它是表上查询的某个子集

680
00:25:47,200 --> 00:25:49,480
，最终可能

681
00:25:49,480 --> 00:25:53,170
会变慢，然后您也

682
00:25:53,170 --> 00:25:54,100
不想变慢

683
00:25:54,100 --> 00:25:55,570
同时运行的其他事务或查询，

684
00:25:55,570 --> 00:25:56,679
所以你想运行确保

685
00:25:56,679 --> 00:25:57,640
你在未提交的读读上运行它，

686
00:25:57,640 --> 00:25:59,860
而你不知道而不编辑任何

687
00:25:59,860 --> 00:26:01,570
闩锁或锁以避免干扰

688
00:26:01,570 --> 00:26:05,320
其他任何人，因此

689
00:26:05,320 --> 00:26:07,059
考虑进行采样的方法是 就像我

690
00:26:07,059 --> 00:26:09,370
有我的 where 子句而不是

691
00:26:09,370 --> 00:26:10,929
做任何连接，

692
00:26:10,929 --> 00:26:12,550
从我的 where 子句中挑选出谓词 s

693
00:26:12,550 --> 00:26:14,500
，我们是连接的子句，我只是

694
00:26:14,500 --> 00:26:17,470
在你知道的

695
00:26:17,470 --> 00:26:19,330
表上运行它 精灵来计算这个

696
00:26:19,330 --> 00:26:20,500
课程现在如果你有连接这会变得很难

697
00:26:20,500 --> 00:26:22,000
因为现在连接的选择性

698
00:26:22,000 --> 00:26:24,460
很难计算除非你

699
00:26:24,460 --> 00:26:29,350
开始连接所以

700
00:26:29,350 --> 00:26:31,570
人们使用不同系统的程度使用

701
00:26:31,570 --> 00:26:36,190
积极采样的程度会有所不同，这又

702
00:26:36,190 --> 00:26:36,790
是哪里

703
00:26:36,790 --> 00:26:37,930
我们进入的地方就像商业

704
00:26:37,930 --> 00:26:39,280
系统正在做一些他们

705
00:26:39,280 --> 00:26:40,810
并没有真正公开谈论的事情，所以

706
00:26:40,810 --> 00:26:41,620
很难知道他们实际上在做什么，

707
00:26:41,620 --> 00:26:44,050
但我知道在你们阅读的论文的情况下，

708
00:26:44,050 --> 00:26:45,370
我认为他们

709
00:26:45,370 --> 00:26:47,440
提到了一些 纸质续集

710
00:26:47,440 --> 00:26:49,120
服务器执行最好的续集 我们的服务器

711
00:26:49,120 --> 00:26:51,310
结合了直方图或

712
00:26:51,310 --> 00:26:56,650
近似值和采样

713
00:26:56,650 --> 00:26:57,970


714
00:26:57,970 --> 00:26:59,980


715
00:26:59,980 --> 00:27:02,380


716
00:27:02,380 --> 00:27:04,810


717
00:27:04,810 --> 00:27:06,820
谓词，然后我们可以使用它

718
00:27:06,820 --> 00:27:09,250
来计算我们的运算符的基数，

719
00:27:09,250 --> 00:27:11,560
然后

720
00:27:11,560 --> 00:27:13,690
是正在生成的数据量

721
00:27:13,690 --> 00:27:15,940
作为 ou  tput right 以及我们

722
00:27:15,940 --> 00:27:17,320
想知道这是什么的原因，

723
00:27:17,320 --> 00:27:21,400
因为然后被输入它是

724
00:27:21,400 --> 00:27:24,970
尝试我们下一个操作符的输入，

725
00:27:24,970 --> 00:27:26,470
问题将是

726
00:27:26,470 --> 00:27:29,650
我们对基数的估计越不准确，我们

727
00:27:29,650 --> 00:27:30,940
的选择性

728
00:27:30,940 --> 00:27:33,100
在树的较低部分的这些运算符中的谓词

729
00:27:33,100 --> 00:27:35,140
然后

730
00:27:35,140 --> 00:27:36,910
当你上升时它会被放大，因为当我上升时

731
00:27:36,910 --> 00:27:39,400
我离开底部叶节点

732
00:27:39,400 --> 00:27:41,830
，错误被延续

733
00:27:41,830 --> 00:27:45,010
，现在变得更加关闭我可以再次进入

734
00:27:45,010 --> 00:27:46,450
这就是你在论文中看到的，

735
00:27:46,450 --> 00:27:54,190
你们读得很好，所以

736
00:27:54,190 --> 00:27:56,950
你实际计算

737
00:27:56,950 --> 00:28:01,210
基数的教科书方式是通过将

738
00:28:01,210 --> 00:28:03,430
选择性建模为概率

739
00:28:03,430 --> 00:28:06,730
，然后你

740
00:28:06,730 --> 00:28:08,350
对这些

741
00:28:08,350 --> 00:28:10,480
概率做出以下三个假设 计算

742
00:28:10,480 --> 00:28:12,880
你知道什么 基数

743
00:28:12,880 --> 00:28:13,960
是什么 选择性是

744
00:28:13,960 --> 00:28:16,810
正确的 所以我想说这

745
00:28:16,810 --> 00:28:18,580
就是我在这里描述的是我们

746
00:28:18,580 --> 00:28:20,380
在中断课程中教你的内容

747
00:28:20,380 --> 00:28:22,150
广告每一本关于

748
00:28:22,150 --> 00:28:23,470
数据库的教科书他们会告诉你的

749
00:28:23,470 --> 00:28:25,300
，希望他们会说这样的警告

750
00:28:25,300 --> 00:28:27,220
，哦，这真的很快就出错了，

751
00:28:27,220 --> 00:28:31,000
但人们仍然这样做是

752
00:28:31,000 --> 00:28:32,380
对的，因为没有

753
00:28:32,380 --> 00:28:34,000
其他的事情是正确的，看看唯一的其他方法

754
00:28:34,000 --> 00:28:36,160
获得查询的确切成本的唯一方法

755
00:28:36,160 --> 00:28:37,840
实际上是运行查询，

756
00:28:37,840 --> 00:28:39,100
但这实际上非常慢，所以你不能

757
00:28:39,100 --> 00:28:41,080
这样做，所以你尽快使用一些

758
00:28:41,080 --> 00:28:43,330
这些应该

759
00:28:43,330 --> 00:28:44,920
降低准确性才能 得到

760
00:28:44,920 --> 00:28:48,520
一些运行良好的东西，所以

761
00:28:48,520 --> 00:28:49,660
在许多情况下我们要做的第一个假设

762
00:28:49,660 --> 00:28:50,530


763
00:28:50,530 --> 00:28:52,440


764
00:28:52,440 --> 00:28:55,240
是我们的属性中的值具有均匀分布，这

765
00:28:55,240 --> 00:28:56,560
意味着给定属性

766
00:28:56,560 --> 00:29:00,640
出现在我的列中的概率是

767
00:29:00,640 --> 00:29:02,740
相同的 所有的价值观当然我们都

768
00:29:02,740 --> 00:29:04,090
知道这不是真的，因为

769
00:29:04,090 --> 00:29:05,470
住在纽约市的人比住在

770
00:29:05,470 --> 00:29:08,200
蒙大拿州的人多，所以我不能假设你

771
00:29:08,200 --> 00:29:09,760
知道蒙大拿州的邮政编码

772
00:29:09,760 --> 00:29:12,010
有相同的发生概率 对于

773
00:29:12,010 --> 00:29:14,080
人们来说，一个人的数据库而不是

774
00:29:14,080 --> 00:29:15,790
纽约市的人，你

775
00:29:15,790 --> 00:29:17,980
通常解决这个问题的方式是

776
00:29:17,980 --> 00:29:19,150
为所谓的重击者维护一个单独的数据结构

777
00:29:19,150 --> 00:29:21,310
，

778
00:29:21,310 --> 00:29:23,650
这就像一个小哈希

779
00:29:23,650 --> 00:29:26,020
表，上面写着

780
00:29:26,020 --> 00:29:30,810
出现在我的专栏中的前 10 个或前 20 个值，

781
00:29:30,810 --> 00:29:34,030
因为因为比您知道的次数

782
00:29:34,030 --> 00:29:35,980
更多，我更有可能查询这些值

783
00:29:35,980 --> 00:29:38,110
，因此我可以在

784
00:29:38,110 --> 00:29:39,850
这个重量级表中进行查找并获得更

785
00:29:39,850 --> 00:29:41,050
准确的估计，但

786
00:29:41,050 --> 00:29:44,260
其他一切 只是假设是统一的

787
00:29:44,260 --> 00:29:45,520
接下来是我们将假设我们所有

788
00:29:45,520 --> 00:29:48,660
的谓词都是独立的

789
00:29:48,660 --> 00:29:50,770
我们将这些建模为

790
00:29:50,770 --> 00:29:51,970
概率 这意味着我们实际上可以

791
00:29:51,970 --> 00:29:53,440
将它们相乘，这将

792
00:29:53,440 --> 00:29:55,060
产生我们谓词的真正选择性

793
00:29:55,060 --> 00:29:56,560
当然这

794
00:29:56,560 --> 00:29:58,410
行不通，我们将在下一张幻灯片中看到

795
00:29:58,410 --> 00:30:02,440
，最后一张是我们将

796
00:30:02,440 --> 00:30:06,460
假设我们试图加入的相互关系的加入键

797
00:30:06,460 --> 00:30:08,380


798
00:30:08,380 --> 00:30:11,650
将始终 s 存在于奉承权中，

799
00:30:11,650 --> 00:30:13,690
这显然是行不通的，如果您

800
00:30:13,690 --> 00:30:14,890
开始进行左外连接或右

801
00:30:14,890 --> 00:30:16,480
外连接，这又会出现问题

802
00:30:16,480 --> 00:30:18,130
，这是

803
00:30:18,130 --> 00:30:21,220
人们

804
00:30:21,220 --> 00:30:24,220
在交叉模型中的另一个主要假设，所以让我

805
00:30:24,220 --> 00:30:27,400
举例说明如何 这一切都变坏了，这个

806
00:30:27,400 --> 00:30:29,320
很棒的小垃圾箱，或者

807
00:30:29,320 --> 00:30:32,470
这种简单的问题，

808
00:30:32,470 --> 00:30:35,110
那是洛根人的博客荣誉，但

809
00:30:35,110 --> 00:30:36,250
我喜欢这个，因为它说明

810
00:30:36,250 --> 00:30:38,200
了

811
00:30:38,200 --> 00:30:39,160
当你做所有这些时你会遇到的所有问题

812
00:30:39,160 --> 00:30:41,410
假设假设你有一个简单的

813
00:30:41,410 --> 00:30:44,650
数据库来跟踪汽车，

814
00:30:44,650 --> 00:30:46,930
你的数据库中有

815
00:30:46,930 --> 00:30:50,650
十种不同的模型，比如特斯拉本田

816
00:30:50,650 --> 00:30:53,920
福特等等，然后开始使用

817
00:30:53,920 --> 00:30:57,060
十种混合测试特斯拉福特本

818
00:30:57,060 --> 00:30:59,890
田丰田，然后你有 一百

819
00:30:59,890 --> 00:31:03,290
种不同的车型，

820
00:31:03,290 --> 00:31:08,809
比如福特 Escort 是一款车型，或者

821
00:31:08,809 --> 00:31:10,790
丰田卡罗拉是一款车型，所以你有

822
00:31:10,790 --> 00:31:13,280
一百种车型，所以如果你现在有一个问题

823
00:31:13,280 --> 00:31:16,220
，说明在哪里制造 eCos Honda 和

824
00:31:16,220 --> 00:31:19,070
mo  del 等于一个和弦，所以我们有一个

825
00:31:19,070 --> 00:31:20,750
连词和等号谓词，

826
00:31:20,750 --> 00:31:23,960
如果你

827
00:31:23,960 --> 00:31:25,490


828
00:31:25,490 --> 00:31:27,770
在尝试估计

829
00:31:27,770 --> 00:31:31,309
这个谓词的选择性时从上一张幻灯片中做出独立性和一致性假设，那么

830
00:31:31,309 --> 00:31:32,960
你最终会得到一个比十个，

831
00:31:32,960 --> 00:31:35,809
因为我们有 十是正确的，所以我的

832
00:31:35,809 --> 00:31:37,429
意思是它是一个相等的谓词，所以它的

833
00:31:37,429 --> 00:31:39,710
本田可以出现一次，所以它是十分之一

834
00:31:39,710 --> 00:31:43,520
，我们将其乘以 100 多一点，

835
00:31:43,520 --> 00:31:45,230
因为我们有一百

836
00:31:45,230 --> 00:31:46,880
多种不同的模型，而雅阁是一种模型，

837
00:31:46,880 --> 00:31:50,120
所以它是 1 或 1 多 100 所以在这种

838
00:31:50,120 --> 00:31:52,160
情况下，选择性估计

839
00:31:52,160 --> 00:31:57,280
为 0.001 但实际上我们知道

840
00:31:57,280 --> 00:31:59,240
本田是唯一一个让他们重新

841
00:31:59,240 --> 00:32:03,049
录制的所以你不知道这

842
00:32:03,049 --> 00:32:05,419
不是这不是 1 比 10 乘以

843
00:32:05,419 --> 00:32:07,190
100 这些列是 实际上是

844
00:32:07,190 --> 00:32:08,990
相关的，就像如果你有

845
00:32:08,990 --> 00:32:10,840
一个协议那么你有一个本田雅阁，

846
00:32:10,840 --> 00:32:13,760
所以真正的选择性是 1 比

847
00:32:13,760 --> 00:32:17,990
100 所以再次

848
00:32:17,990 --> 00:32:20,570
从上一张幻灯片中的独立假设

849
00:32:20,570 --> 00:32:21,710
将使我们成为一个

850
00:32:21,710 --> 00:32:24,040
在我们的估计中降低了一个数量级，

851
00:32:24,040 --> 00:32:26,840
然后现在如果我开始说我是否会

852
00:32:26,840 --> 00:32:29,000
自动关闭

853
00:32:29,000 --> 00:32:31,160
某个较低的低运算符的选择性，我

854
00:32:31,160 --> 00:32:33,020
现在将其输入另一个运算符，该运算符也

855
00:32:33,020 --> 00:32:34,370
将降低另一个数量级，

856
00:32:34,370 --> 00:32:38,200
那么我是 真的搞砸了，

857
00:32:38,200 --> 00:32:42,559
所以解决这个问题的方法，

858
00:32:42,559 --> 00:32:45,440
据您所知，仅此此此此

859
00:32:45,440 --> 00:32:47,900
功能仅存在于商业

860
00:32:47,900 --> 00:32:49,070
系统中，如果您将调用

861
00:32:49,070 --> 00:32:51,740
列组统计信息或基本上

862
00:32:51,740 --> 00:32:53,540
告诉数据库系统这些

863
00:32:53,540 --> 00:32:55,640
列是相关的并且 因此它

864
00:32:55,640 --> 00:32:57,169
应该维护关于它们的统计数据，

865
00:32:57,169 --> 00:32:59,000
并且当它计算

866
00:32:59,000 --> 00:33:00,740
成本模型估计期间的选择性时

867
00:33:00,740 --> 00:33:02,600
，将它们视为

868
00:33:02,600 --> 00:33:04,309
相关的正确并且不要假设

869
00:33:04,309 --> 00:33:07,340
它们是独立的，所以

870
00:33:07,340 --> 00:33:08,750
基本上它的工作方式就像

871
00:33:08,750 --> 00:33:10,370
DB必须进来告诉它做一些

872
00:33:10,370 --> 00:33:11,780
嘿这两个列是相关的

873
00:33:11,780 --> 00:33:14,030
然后如果系统支持那么

874
00:33:14,030 --> 00:33:15,650
他们可以更新他们的交叉

875
00:33:15,650 --> 00:33:16,640
模型appro 尤其是

876
00:33:16,640 --> 00:33:19,730
只有 db2 和 Oracle 这样做我

877
00:33:19,730 --> 00:33:21,770
不认为据我所知我的续集

878
00:33:21,770 --> 00:33:23,390
和 Postgres 不这样做而且

879
00:33:23,390 --> 00:33:25,100
其他主要的源系统

880
00:33:25,100 --> 00:33:29,150
系统都没有这样做现在主要的事情为什么会

881
00:33:29,150 --> 00:33:31,400
这样为什么会这样 手动正确

882
00:33:31,400 --> 00:33:33,730
为什么 DBA 必须告诉晚餐系统

883
00:33:33,730 --> 00:33:35,960
，我认为这就是为什么我们不能

884
00:33:35,960 --> 00:33:38,470
自动执行此操作，

885
00:33:39,130 --> 00:33:41,990
因为这很难，就像

886
00:33:41,990 --> 00:33:44,510
在此示例中考虑如何解决这个问题一样，

887
00:33:44,510 --> 00:33:46,880
这非常简单，因为我

888
00:33:46,880 --> 00:33:49,640
只有 你知道 10 10 个品牌和 100 个

889
00:33:49,640 --> 00:33:53,179
模型，但我有 10 亿个元组，

890
00:33:53,179 --> 00:33:54,440
我知道他们有一个非常

891
00:33:54,440 --> 00:33:57,290
宽的表，有一千列现在我

892
00:33:57,290 --> 00:33:58,730
必须去寻找

893
00:33:58,730 --> 00:34:01,549
你知道不同

894
00:34:01,549 --> 00:34:03,650
列的每一个单元组合

895
00:34:03,650 --> 00:34:05,809
可能发生的不同可能值，这

896
00:34:05,809 --> 00:34:08,570
件事会导致搜索基数

897
00:34:08,570 --> 00:34:11,929
很大，所以这就是为什么你不能自动执行此操作的原因，

898
00:34:11,929 --> 00:34:14,270
现在可能有一些方法可以

899
00:34:14,270 --> 00:34:16,340
自动进行近似处理，但同样

900
00:34:16,340 --> 00:34:19,668
，据我所知，没有主要系统

901
00:34:19,668 --> 00:34:21,260
做不到 他会自动为你

902
00:34:21,260 --> 00:34:24,739
提前告诉它我们可以

903
00:34:24,739 --> 00:34:26,030
离线讨论深网是否

904
00:34:26,030 --> 00:34:27,679
对此有所帮助人们现在正在研究

905
00:34:27,679 --> 00:34:29,570
这个但什么都不是什么都

906
00:34:29,570 --> 00:34:34,550
没有什么都不存在所以

907
00:34:34,550 --> 00:34:37,489
现在让我们看看这些简单的

908
00:34:37,489 --> 00:34:40,159
例子如何 真的让我们犯规了，

909
00:34:40,159 --> 00:34:42,168
我们开始将连接加入到我们的查询

910
00:34:42,168 --> 00:34:44,418
计划中，所以在这里我们在 ABC 上做一个简单的 3

911
00:34:44,418 --> 00:34:47,750
路连接，其中 ID 等于 B ID

912
00:34:47,750 --> 00:34:50,210
ID 去查看 ID，然后 b ID 有一个过滤器

913
00:34:50,210 --> 00:34:52,969
，其中 ID 是 大于 100

914
00:34:52,969 --> 00:34:55,190
好吧，所以假设这里我们有一个，因为

915
00:34:55,190 --> 00:34:56,810
有一个你知道的过滤

916
00:34:56,810 --> 00:34:58,460
谓词在 v 或运算符

917
00:34:58,460 --> 00:35:00,470
在 B 之间，然后为了

918
00:35:00,470 --> 00:35:02,480
简单的原因加入 right am 我只是

919
00:35:02,480 --> 00:35:05,780
在这里展示正在完成的过滤器，所以

920
00:35:05,780 --> 00:35:06,890
我们需要做的第一件事是计算

921
00:35:06,890 --> 00:35:11,030
访问方法的基数，这些方法

922
00:35:11,030 --> 00:35:13,070


923
00:35:13,070 --> 00:35:15,500
从表中为 a 和 C 检索元组，

924
00:35:15,500 --> 00:35:17,750
没有过滤器，因此

925
00:35:17,750 --> 00:35:19,220


926
00:35:19,220 --> 00:35:21,590
扫描 a 和 C 的运算符的基数只是麻木

927
00:35:21,590 --> 00:35:23,869
表中的元组，

928
00:35:23,869 --> 00:35:26,060
这对我来说很容易计算 我

929
00:35:26,060 --> 00:35:29,660
可以从 B 的目录中得到它这

930
00:35:29,660 --> 00:35:30,500
将是

931
00:35:30,500 --> 00:35:34,130
数字乘以我们这里谓词的选择性，

932
00:35:34,130 --> 00:35:37,670
所以现在我们

933
00:35:37,670 --> 00:35:40,340
要吃饱了 这些扫描

934
00:35:40,340 --> 00:35:43,670
算子的输出到我们的关节 所以现在我们需要

935
00:35:43,670 --> 00:35:46,130
能够计算

936
00:35:46,130 --> 00:35:49,070
我们的关节算子的

937
00:35:49,070 --> 00:35:53,780


938
00:35:53,780 --> 00:35:56,570
基数 所以这里会发生的是

939
00:35:56,570 --> 00:35:58,340
没有

940
00:35:58,340 --> 00:36:01,430
过滤器，但如果这件事错了，那么

941
00:36:01,430 --> 00:36:03,710
现在我将错误的数字

942
00:36:03,710 --> 00:36:06,350
元组输入到这个联合运算符中，然后

943
00:36:06,350 --> 00:36:08,330
现在我必须弄清楚

944
00:36:08,330 --> 00:36:11,690
这两个属性的选择性是什么

945
00:36:11,690 --> 00:36:14,030
假设我没有外键

946
00:36:14,030 --> 00:36:15,830
假设这些人不相关，因为我

947
00:36:15,830 --> 00:36:18,290
对他们一无所知，所以我现在

948
00:36:18,290 --> 00:36:20,120
必须找出

949
00:36:20,120 --> 00:36:24,230
存在于八天 ID 中的每个

950
00:36:24,230 --> 00:36:26,240
值有多少值将与 ID 中的值相匹配

951
00:36:26,240 --> 00:36:30,080
，我可以 试着弄清楚这一点，

952
00:36:30,080 --> 00:36:33,740
并在 m 你找到了我的直方图，但你

953
00:36:33,740 --> 00:36:36,170
知道这会很难 所以现在我

954
00:36:36,170 --> 00:36:38,960
把这个估计的输出

955
00:36:38,960 --> 00:36:40,760
输入到这个估计中

956
00:36:40,760 --> 00:36:43,040


957
00:36:43,040 --> 00:36:44,270


958
00:36:44,270 --> 00:36:46,430
遇到了与我之前相同的问题

959
00:36:46,430 --> 00:36:47,650
，现在我必须弄清楚

960
00:36:47,650 --> 00:36:51,260


961
00:36:51,260 --> 00:36:54,410
这里匹配 ID 等于 B ID 的元组

962
00:36:54,410 --> 00:36:56,330
存在的可能性有多大，并且对这件事感到厌烦，

963
00:36:56,330 --> 00:36:57,890
然后也能够在看到

964
00:36:57,890 --> 00:37:02,420
该 ID 时进行网络匹配 所以我又错了，

965
00:37:02,420 --> 00:37:04,370
这错了，然后看到这让

966
00:37:04,370 --> 00:37:07,160
我更错了所以

967
00:37:07,160 --> 00:37:09,260
这就是我们正在处理的

968
00:37:09,260 --> 00:37:13,600
事情就像数学一样

969
00:37:13,630 --> 00:37:15,230
，无论我们是否正在处理

970
00:37:15,230 --> 00:37:16,460
这些事情，它都不对您有利 在概率方面，

971
00:37:16,460 --> 00:37:18,920
这些专家并不总是会

972
00:37:18,920 --> 00:37:21,710
出错，而且随着我们的上升，情况会变得更糟，

973
00:37:21,710 --> 00:37:23,990
所以再次这是您

974
00:37:23,990 --> 00:37:25,190
将在我们的论文基准的联合中看到这一点，

975
00:37:25,190 --> 00:37:27,050
你们阅读的表格越多

976
00:37:27,050 --> 00:37:30,710
，添加的表格就越多 糟糕的客人适合

977
00:37:30,710 --> 00:37:32,810
t 他的原因是什么是抛出错误

978
00:37:32,810 --> 00:37:34,430
和一连串的错误 一个很好的膨胀另一个

979
00:37:34,430 --> 00:37:39,710
查询计划 所以我

980
00:37:39,710 --> 00:37:41,930
让你们读的论文来自

981
00:37:41,930 --> 00:37:43,850
德国的超级团队

982
00:37:43,850 --> 00:37:50,900
，这

983
00:37:50,900 --> 00:37:52,430
是对这种类型的准确度的评估 各种不同数据库系统的

984
00:37:52,430 --> 00:37:54,230
基数估计和运算符

985
00:37:54,230 --> 00:37:56,900


986
00:37:56,900 --> 00:37:59,000
，然后他们想用它来

987
00:37:59,000 --> 00:38:03,680
弄清楚事情

988
00:38:03,680 --> 00:38:05,000
实际上有多糟糕，你可以

989
00:38:05,000 --> 00:38:06,800
从那个到实时，所以

990
00:38:06,800 --> 00:38:08,420
论文没有告诉 你如何

991
00:38:08,420 --> 00:38:11,480
建立一个成本模型 我

992
00:38:11,480 --> 00:38:14,810
在这里粗略地勾勒出如何做到这一点，但

993
00:38:14,810 --> 00:38:16,250
它只是向你展示了

994
00:38:16,250 --> 00:38:17,660
当捕获和 s 出现在你的成本

995
00:38:17,660 --> 00:38:21,770
模型中时会发生什么，然后他们

996
00:38:21,770 --> 00:38:25,510
提出了某种建议 设计所以

997
00:38:25,510 --> 00:38:27,950
构建大卫

998
00:38:27,950 --> 00:38:29,270
系统的设计原则是你应该关注的重点是

999
00:38:29,270 --> 00:38:31,400
试图使系统更

1000
00:38:31,400 --> 00:38:33,860
健壮你知道

1001
00:38:33,860 --> 00:38:36,410
成本模型中的偏差或错误所以在论文中他们

1002
00:38:36,410 --> 00:38:38,930
提出了一个新的基准代码Jo B

1003
00:38:38,930 --> 00:38:42,200
那个联合订购了一个基准，所以在这个基准中，

1004
00:38:42,200 --> 00:38:44,510
他们实际上是

1005
00:38:44,510 --> 00:38:47,180
基于我认为 IMDB 数据集，

1006
00:38:47,180 --> 00:38:51,080
所以电影网站，这是一个

1007
00:38:51,080 --> 00:38:53,960
真实的数据集，所以表格

1008
00:38:53,960 --> 00:38:55,190
实际上会基于

1009
00:38:55,190 --> 00:38:57,200
真实的数据倾斜 - 世界分布权和像

1010
00:38:57,200 --> 00:38:58,520
tpc 代理 TPCC 一样，

1011
00:38:58,520 --> 00:39:00,260
它们具有均匀分布

1012
00:39:00,260 --> 00:39:02,240
，其中您知道

1013
00:39:02,240 --> 00:39:04,250
的所有属性发生的可能性

1014
00:39:04,250 --> 00:39:06,200
对于所有开始都是相同的，就像

1015
00:39:06,200 --> 00:39:08,270
给定列中发生的一种值

1016
00:39:08,270 --> 00:39:10,850
一样，对于联合中的所有值都是相同的

1017
00:39:10,850 --> 00:39:12,560
基准测试实际上是真实的，你

1018
00:39:12,560 --> 00:39:14,510
知道它有真正的偏差，

1019
00:39:14,510 --> 00:39:17,720
所以他们将生成一堆

1020
00:39:17,720 --> 00:39:19,550
不同的查询，这些查询将加入

1021
00:39:19,550 --> 00:39:21,830
越来越多的表，然后他们希望

1022
00:39:21,830 --> 00:39:24,170
能够衡量成本

1023
00:39:24,170 --> 00:39:25,970
模型认为的选择性是什么

1024
00:39:25,970 --> 00:39:28,040
将超过优秀运营商的基数，

1025
00:39:28,040 --> 00:39:29,900
并将其与

1026
00:39:29,900 --> 00:39:32,240
实际数据

1027
00:39:32,240 --> 00:39:35,150
进行

1028
00:39:35,150 --> 00:39:36,590


1029
00:39:36,590 --> 00:39:39,560
比较 他们会

1030
00:39:39,560 --> 00:39:41,480
一次性加载你知道的数据，然后他们会

1031
00:39:41,480 --> 00:39:43,970
运行analyze which，这会触发

1032
00:39:43,970 --> 00:39:46,100
后台作业来实际扫描

1033
00:39:46,100 --> 00:39:47,960
所有表并让系统计算

1034
00:39:47,960 --> 00:39:49,250
我想要计算的任何统计信息

1035
00:39:49,250 --> 00:39:50,810
最好的情况

1036
00:39:50,810 --> 00:39:52,580
没有更新，所以我只是加载

1037
00:39:52,580 --> 00:39:55,160
数据并运行分析他们

1038
00:39:55,160 --> 00:39:56,960
想在这个最好的情况下看到的任何东西

1039
00:39:56,960 --> 00:39:57,480
但是

1040
00:39:57,480 --> 00:40:00,630
一旦你在这里有了这张图，事情就会变得如此

1041
00:40:00,630 --> 00:40:02,609
，因为这真的

1042
00:40:02,609 --> 00:40:05,100
是这里最重要的一张图

1043
00:40:05,100 --> 00:40:07,010
所以理解这一点的方法是，

1044
00:40:07,010 --> 00:40:11,550
y 轴是你

1045
00:40:11,550 --> 00:40:15,000
离在基数估计中完全准确的距离有多远，

1046
00:40:15,000 --> 00:40:17,820
所以

1047
00:40:17,820 --> 00:40:19,590
这里的中间线是你

1048
00:40:19,590 --> 00:40:21,750
完全准确的时候，然后如果你是 如果

1049
00:40:21,750 --> 00:40:22,740
你高于这个，那么你就

1050
00:40:22,740 --> 00:40:24,450
高估了如果你

1051
00:40:24,450 --> 00:40:25,859
低于这个，那么你就低估

1052
00:40:25,859 --> 00:40:30,570
了，然后 x 轴

1053
00:40:30,570 --> 00:40:32,670
是他们在这里加入查询的表的数量

1054
00:40:32,670 --> 00:40:36,380


1055
00:40:36,380 --> 00:40:38,390
所以首先要注意 nt out 是

1056
00:40:38,390 --> 00:40:40,740
每个人 总体趋势似乎

1057
00:40:40,740 --> 00:40:42,840
是每个人都在估计正确，

1058
00:40:42,840 --> 00:40:45,600
因为你添加了更多的桌子 每个人都

1059
00:40:45,600 --> 00:40:48,390
开始了它开始下降好吧

1060
00:40:48,390 --> 00:40:52,200


1061
00:40:52,200 --> 00:40:54,840
我们

1062
00:40:54,840 --> 00:40:55,830
谈到了假设，所以我可以

1063
00:40:55,830 --> 00:40:57,540
假设事物是独立的，然后

1064
00:40:57,540 --> 00:41:00,560
我假设我的选择性会

1065
00:41:00,560 --> 00:41:03,570
比实际情况要少得多，所以这就是

1066
00:41:03,570 --> 00:41:04,680
为什么他们再次他们都

1067
00:41:04,680 --> 00:41:06,359
低估了实际价值

1068
00:41:06,359 --> 00:41:10,890
应该是什么 第一个要指出的

1069
00:41:10,890 --> 00:41:13,230
是这个这个这个这个这里的一个人

1070
00:41:13,230 --> 00:41:15,930
实际上在

1071
00:41:15,930 --> 00:41:19,650
大约三到四张桌子上做得相当好并且

1072
00:41:19,650 --> 00:41:21,540
跨越所有这些他们实际上是

1073
00:41:21,540 --> 00:41:22,740
他们最他们拥有最

1074
00:41:22,740 --> 00:41:25,260
紧密的平衡从 你知道

1075
00:41:25,260 --> 00:41:26,820
作为一个人准确与所有

1076
00:41:26,820 --> 00:41:31,700
其他人这里的三个系统

1077
00:41:31,700 --> 00:41:33,780
本质上都是如何都有相同的趋势，

1078
00:41:33,780 --> 00:41:37,530
但是

1079
00:41:37,530 --> 00:41:42,240
当你添加更多表格时，界限再次变得非常正确

1080
00:41:42,240 --> 00:41:44,310
更糟糕的是，然后

1081
00:41:44,310 --> 00:41:46,859
你知道这是六张桌子，

1082
00:41:46,859 --> 00:41:48,900
这真的很糟糕，然后你有这个

1083
00:41:48,900 --> 00:41:50,580
中间人，他

1084
00:41:50,580 --> 00:41:53,070
马上就要离开了，两张桌子就可以了

1085
00:41:53,070 --> 00:41:54,210
，然后

1086
00:41:54,210 --> 00:41:56,280
就这样了，它被低估

1087
00:41:56,280 --> 00:41:57,109
了 其他所有人，

1088
00:41:57,109 --> 00:42:03,540
所以我认为在论文中他们告诉你

1089
00:42:03,540 --> 00:42:05,220
最后一个中的第

1090
00:42:05,220 --> 00:42:08,910
一个或超级右侧的 Postgres，我

1091
00:42:08,910 --> 00:42:11,210
想我上次放慢了速度，谁

1092
00:42:11,210 --> 00:42:13,220
是这里最好的，让我

1093
00:42:13,220 --> 00:42:17,030
猜猜这个是什么 Microsoft 续集

1094
00:42:17,030 --> 00:42:19,220
服务器 好的 然后我们认为你猜

1095
00:42:19,220 --> 00:42:22,040
这两个是什么

1096
00:42:22,040 --> 00:42:28,010
甲骨文这个 在这里你 Teddy

1097
00:42:28,010 --> 00:42:30,200
titovs 这个 我创造了一个假甲骨文的

1098
00:42:30,200 --> 00:42:33,050
这个 辐射 你认为甲骨文的

1099
00:42:33,050 --> 00:42:37,609
这个好 然后我们需要

1100
00:42:37,609 --> 00:42:41,660
最后一课 一个 db2 可以，所以

1101
00:42:41,660 --> 00:42:43,520
你认为这是 db2 这是

1102
00:42:43,520 --> 00:42:55,580
Oracle

1103
00:42:55,580 --> 00:42:59,089


1104
00:42:59,089 --> 00:43:01,369


1105
00:43:01,369 --> 00:43:03,260


1106
00:43:03,260 --> 00:43:04,670
做级联

1107
00:43:04,670 --> 00:43:08,420
或或自下而上，但他们在做

1108
00:43:08,420 --> 00:43:11,560
采样 他们在做直方图

1109
00:43:11,560 --> 00:43:14,599
我只是序列

1110
00:43:14,599 --> 00:43:17,000
在我看来它真的很好 我

1111
00:43:17,000 --> 00:43:20,210
认为这三个系统都在这里 我认为

1112
00:43:20,210 --> 00:43:23,990
这至少是他们的

1113
00:43:23,990 --> 00:43:25,880
在我看来，公开谈论的最像

1114
00:43:25,880 --> 00:43:27,170
最先进的前沿系统，在

1115
00:43:27,170 --> 00:43:30,440
db2 中正确工作是好的，它们不是

1116
00:43:30,440 --> 00:43:32,690
坏系统，只是我觉得续集

1117
00:43:32,690 --> 00:43:35,660
服务器是基于他们所

1118
00:43:35,660 --> 00:43:36,950
谈论的内容 关于公开，这件事似乎

1119
00:43:36,950 --> 00:43:40,640
是他的方式，你知道得

1120
00:43:40,640 --> 00:43:43,369
更远，然后其他人都

1121
00:43:43,369 --> 00:43:46,849
遇到了所以我想说对于所有的数据库

1122
00:43:46,849 --> 00:43:48,970
系统开源和商业

1123
00:43:48,970 --> 00:43:50,960
秘密回复有最好的查询

1124
00:43:50,960 --> 00:43:56,119
优化器所以它显示在这里但让我们

1125
00:43:56,119 --> 00:44:00,589
现在看看 更详细地了解

1126
00:44:00,589 --> 00:44:02,480


1127
00:44:02,480 --> 00:44:05,720
当您获得正确估计时实际发生的情况，因此

1128
00:44:05,720 --> 00:44:06,920
对于这个，他们将使用

1129
00:44:06,920 --> 00:44:11,420
Postgres 9.4 并且在

1130
00:44:11,420 --> 00:44:15,589
此处理解此图的方法是

1131
00:44:15,589 --> 00:44:19,210
x 轴是 

1132
00:44:19,210 --> 00:44:23,300
他们将要执行

1133
00:44:23,300 --> 00:44:25,599


1134
00:44:25,720 --> 00:44:28,790


1135
00:44:28,790 --> 00:44:30,610
的查询与查询本身的实际执行相比

1136
00:44:30,610 --> 00:44:35,900


1137
00:44:35,900 --> 00:44:38,540
要慢多少

1138
00:44:38,540 --> 00:44:40,460


1139
00:44:40,460 --> 00:44:42,890
使用直方图来估计

1140
00:44:42,890 --> 00:44:45,290
他们修改系统的操作符的基数，

1141
00:44:45,290 --> 00:44:47,270
这样你就知道

1142
00:44:47,270 --> 00:44:49,010
无论什么函数说去估计

1143
00:44:49,010 --> 00:44:50,600
基数是他们

1144
00:44:50,600 --> 00:44:52,040
用神奇的甲骨文代替它，每次总是

1145
00:44:52,040 --> 00:44:53,570
正确地给他们正确的答案

1146
00:44:53,570 --> 00:44:56,660
阅读这篇文章

1147
00:44:56,660 --> 00:45:01,160
是他们与实际估计要做的事情相距多远，

1148
00:45:01,160 --> 00:45:04,880


1149
00:45:04,880 --> 00:45:07,730


1150
00:45:07,730 --> 00:45:08,690
如果您有

1151
00:45:08,690 --> 00:45:10,850
确切的湿疹，查询性能将是什么，而如果您

1152
00:45:10,850 --> 00:45:12,590
使用内置成本模型会怎样，但这

1153
00:45:12,590 --> 00:45:15,410
是近似值 如果你在

1154
00:45:15,410 --> 00:45:17,420
这个范围内 0.9 在某一点上

1155
00:45:17,420 --> 00:45:20,720
意味着你

1156
00:45:20,720 --> 00:45:23,060
使用近似值的查询性能与

1157
00:45:23,060 --> 00:45:26,060
当你有 appr 时获得的性能大致相同

1158
00:45:26,060 --> 00:45:27,470
模拟你知道如果

1159
00:45:27,470 --> 00:45:29,450
你有确切的结果然后在

1160
00:45:29,450 --> 00:45:31,250
这里就像你得到的方式你知道的

1161
00:45:31,250 --> 00:45:34,580
方式在你朝这个方向前进时会变慢

1162
00:45:34,580 --> 00:45:36,140
然后这是

1163
00:45:36,140 --> 00:45:37,640
查询在他们提供的查询总数中的百分比

1164
00:45:37,640 --> 00:45:39,110


1165
00:45:39,110 --> 00:45:40,850
进入系统适合这些不同的

1166
00:45:40,850 --> 00:45:45,080
桶，所以这会告诉你

1167
00:45:45,080 --> 00:45:49,640
，当你使用估计时，

1168
00:45:49,640 --> 00:45:55,400
60% 的查询比你知道的查询慢 1.2 到 1.1 或 8

1169
00:45:55,400 --> 00:46:00,020
倍，你在

1170
00:46:00,020 --> 00:46:01,670
这里有真正的基数

1171
00:46:01,670 --> 00:46:04,730
精确估计 是的，所以

1172
00:46:04,730 --> 00:46:07,940
发生的事情是因为 Postgres

1173
00:46:07,940 --> 00:46:10,820
低估了

1174
00:46:10,820 --> 00:46:14,150
它的操作符的基数，它认为你

1175
00:46:14,150 --> 00:46:15,260
知道它

1176
00:46:15,260 --> 00:46:17,030
要通过一个机会

1177
00:46:17,030 --> 00:46:19,160
的元组数量比

1178
00:46:19,160 --> 00:46:21,320
实际要少 并且他们使用这些

1179
00:46:21,320 --> 00:46:23,840
基数估计来确定哈希

1180
00:46:23,840 --> 00:46:26,630
表的大小，以便您何时正确执行哈希联合，

1181
00:46:26,630 --> 00:46:29,420
或者决定是否甚至想要执行

1182
00:46:29,420 --> 00:46:31,070
哈希联合，如果您

1183
00:46:31,070 --> 00:46:32,420
只想访问少量

1184
00:46:32,420 --> 00:46:36,350
tup 也可以 les 并享受 if you are then

1185
00:46:36,350 --> 00:46:38,750
嵌套循环连接非常快，

1186
00:46:38,750 --> 00:46:39,830
因为您不必设置哈希

1187
00:46:39,830 --> 00:46:41,030
表，不必构建它，

1188
00:46:41,030 --> 00:46:42,620
也不必探测它，只需执行这两个

1189
00:46:42,620 --> 00:46:44,180
四个小循环即可 在像四个元组

1190
00:46:44,180 --> 00:46:45,890
和外表一个内表

1191
00:46:45,890 --> 00:46:47,390
上，你知道的速度和你将

1192
00:46:47,390 --> 00:46:50,240
得到的一样快所以 Postgres 最终因为

1193
00:46:50,240 --> 00:46:52,460
它低估了

1194
00:46:52,460 --> 00:46:54,500
他的运算符的基数来为你的应用程序唱歌你正在

1195
00:46:54,500 --> 00:46:56,480
操作十个元组之一 Nestle's up

1196
00:46:56,480 --> 00:46:58,250
Joint right 然后它开始运行

1197
00:46:58,250 --> 00:47:00,410
，它说 oh shit list is not this

1198
00:47:00,410 --> 00:47:03,410
not 10 do pools 但到那时

1199
00:47:03,410 --> 00:47:04,850
查询计划已经正确烘焙，您无法

1200
00:47:04,850 --> 00:47:07,660
切换回进行哈希连接，为什么不这样做，

1201
00:47:07,660 --> 00:47:10,220


1202
00:47:10,220 --> 00:47:11,660
因为您看到了 那个你必须正确地

1203
00:47:11,660 --> 00:47:13,640
进行自适应查询处理，所以

1204
00:47:13,640 --> 00:47:15,950
你必须能够说我的查询

1205
00:47:15,950 --> 00:47:18,590
优化器犯了一个错误回去并

1206
00:47:18,590 --> 00:47:20,300
重新运行你知道运行优化器并

1207
00:47:20,300 --> 00:47:21,920
根据我知道的东西获得一个新计划，

1208
00:47:21,920 --> 00:47:25,960
基于什么 到目前为止我看到的数据

1209
00:47:27,850 --> 00:47:36,260
Stadium next loop join hash join 并

1210
00:47:36,260 --> 00:47:41,570
获得 s 好吧，但就像这样你

1211
00:47:41,570 --> 00:47:43,010
可以这样做，实际上一种

1212
00:47:43,010 --> 00:47:48,620
方法是，如果我现在看到，好像我

1213
00:47:48,620 --> 00:47:51,680
看到了，我认为它

1214
00:47:51,680 --> 00:47:52,850
有点像十两个人，所以现在我有

1215
00:47:52,850 --> 00:47:55,190
10 亿管 在我

1216
00:47:55,190 --> 00:47:56,570
什至开始嵌套循环关节之前就进来了我可以

1217
00:47:56,570 --> 00:47:58,370
说不要做那种曾经

1218
00:47:58,370 --> 00:48:00,800
做过散列连接的滑动关节你可以在某些方面做到这一点，

1219
00:48:00,800 --> 00:48:02,300
这取决于它们如何

1220
00:48:02,300 --> 00:48:05,660
流水线化元组，但它们不是

1221
00:48:05,660 --> 00:48:07,580
工程的事情有点

1222
00:48:07,580 --> 00:48:09,200
像一旦优化器做出

1223
00:48:09,200 --> 00:48:10,670
决定，他们现在就采用它

1224
00:48:10,670 --> 00:48:12,560
自适应查询处理或

1225
00:48:12,560 --> 00:48:16,430
优化是当你说我认为

1226
00:48:16,430 --> 00:48:17,990
优化器犯了一个错误，然后返回并

1227
00:48:17,990 --> 00:48:19,520
重新生成一个查询工厂，然后

1228
00:48:19,520 --> 00:48:21,380
现在你知道了 必须让你

1229
00:48:21,380 --> 00:48:23,600
进入这个世界，我是扔掉

1230
00:48:23,600 --> 00:48:25,880
迄今为止处理的所有数据并

1231
00:48:25,880 --> 00:48:28,190
从头开始还是我可以提出一个

1232
00:48:28,190 --> 00:48:29,990
新的查询计划，该计划可以使用一些

1233
00:48:29,990 --> 00:48:31,700
已经处理的数据，只要你知道

1234
00:48:31,700 --> 00:48:33,710
继续 这样

1235
00:48:33,710 --> 00:48:35,660
基本上就可以做你想做的事 提出异议，

1236
00:48:35,660 --> 00:48:37,700
但据您所知，我的意思是我知道

1237
00:48:37,700 --> 00:48:40,580
Postgres 没有这样做，我

1238
00:48:40,580 --> 00:48:42,620
实际上不知道续集服务器和 oracle 是

1239
00:48:42,620 --> 00:48:43,940
什么我认为他们扔掉所有东西

1240
00:48:43,940 --> 00:48:47,810
并重新开始，您

1241
00:48:47,810 --> 00:48:50,240
主要是为约翰这样做

1242
00:48:50,240 --> 00:48:51,250
订购

1243
00:48:51,250 --> 00:48:53,080
切换例程 Nestle pet 和 hash

1244
00:48:53,080 --> 00:48:58,300
join 没有理由你可以在

1245
00:48:58,300 --> 00:48:59,109
扑克中不这样做

1246
00:48:59,109 --> 00:49:03,280
我认为我们是工程师的原因

1247
00:49:03,280 --> 00:49:06,400
好吧 所以在这种情况下，事情再次

1248
00:49:06,400 --> 00:49:09,160
运行缓慢，因为

1249
00:49:09,160 --> 00:49:10,240
很多报价最终被

1250
00:49:10,240 --> 00:49:11,560
当它们真正应该是散列散列连接时，它们依偎在一起，

1251
00:49:11,560 --> 00:49:12,250


1252
00:49:12,250 --> 00:49:15,640
所以他们做的下一件事是在

1253
00:49:15,640 --> 00:49:17,680
Postgres 中，您可以通过一个标志说

1254
00:49:17,680 --> 00:49:34,150
抱歉，是的，但我不知道为什么我们

1255
00:49:34,150 --> 00:49:51,060
可以成为幽灵我不知道只是噪音哦

1256
00:49:56,580 --> 00:50:00,820
上帝，好吧，所以他说，就像

1257
00:50:00,820 --> 00:50:03,970
第一个无人机操作员进入

1258
00:50:03,970 --> 00:50:06,369
第一个连接时的空气高估了第二个连接，而第二个连接

1259
00:50:06,369 --> 00:50:08,200
被低估

1260
00:50:08,200 --> 00:50:10,690
了然后结果完全

1261
00:50:10,690 --> 00:50:13,420
正确，为什么现在正在运行你知道

1262
00:50:13,420 --> 00:50:17,280
零点更快 或者我不知道

1263
00:50:17,280 --> 00:50:21,700
现在好了，但我的意思是它是

1264
00:50:21,700 --> 00:50:24,099
一个相当低的数量，就像你知道

1265
00:50:24,099 --> 00:50:26,440
百分之一或百分之二没关系

1266
00:50:26,440 --> 00:50:29,020
所以我所说的我在

1267
00:50:29,020 --> 00:50:33,430
这里说的是，这又是对

1268
00:50:33,430 --> 00:50:35,859
事情原因的第一种评估

1269
00:50:35,859 --> 00:50:37,720
运行楼层，因为

1270
00:50:37,720 --> 00:50:39,430
当您可以散列连接时，它会选择度量 Luke John

1271
00:50:39,430 --> 00:50:41,320
所以在 Postgres 中，您可以在

1272
00:50:41,320 --> 00:50:42,930
会话和 Gilberts 终端中传递一个标志

1273
00:50:42,930 --> 00:50:45,160
，您可以说 set no merge 或

1274
00:50:45,160 --> 00:50:46,540
类似的东西或 no nest luke join

1275
00:50:46,540 --> 00:50:49,480
您可以告诉优化器 甚至不

1276
00:50:49,480 --> 00:50:51,670
考虑为您的查询使用嵌套循环连接，

1277
00:50:51,670 --> 00:50:53,619
因此在这种情况下，此处仅

1278
00:50:53,619 --> 00:50:56,140
将其视为散列连接，但

1279
00:50:56,140 --> 00:50:58,330
现在您仍然看到

1280
00:50:58,330 --> 00:51:01,570
性能仍然最差

1281
00:51:01,570 --> 00:51:02,530
，那么如果您有两个基数，您就知道应该在哪里

1282
00:51:02,530 --> 00:51:04,780
它确实有帮助，

1283
00:51:04,780 --> 00:51:06,070
更少的查询被选为

1284
00:51:06,070 --> 00:51:07,780
嵌套循环连接，但在这种情况下，您的一些

1285
00:51:07,780 --> 00:51:10,180
查询仍然开始运行较慢，

1286
00:51:10,180 --> 00:51:14,080
结果证明在此

1287
00:51:14,080 --> 00:51:16,260
版本的 Postgres 中，他们使用的是

1288
00:51:16,260 --> 00:51:18,580
Cardinal 基数 est 来自

1289
00:51:18,580 --> 00:51:22,810
操作员的 imates 决定如何

1290
00:51:22,810 --> 00:51:25,350
在您正确进行哈希连接时分配哈希表，

1291
00:51:25,350 --> 00:51:27,520
因此您说您知道我要执行

1292
00:51:27,520 --> 00:51:29,740
100 我在胡同里有我的卡 100 所以

1293
00:51:29,740 --> 00:51:31,660
确保我有一个哈希表，您

1294
00:51:31,660 --> 00:51:33,820
知道 200 你知道把东西放进去的槽

1295
00:51:33,820 --> 00:51:36,430
，所以如果你的哈希表过小，

1296
00:51:36,430 --> 00:51:39,040
会发生什么，正如我们

1297
00:51:39,040 --> 00:51:39,850
谈到的那样，你最终会得到这些

1298
00:51:39,850 --> 00:51:41,800
很长的东西，你知道我认为他们正在

1299
00:51:41,800 --> 00:51:44,350
做一个桶哈希表，所以你

1300
00:51:44,350 --> 00:51:45,520
有这些非常长的桶

1301
00:51:45,520 --> 00:51:47,290


1302
00:51:47,290 --> 00:51:48,960
每次你做一次探测时，链本质上都会变成一个顺序扫描，

1303
00:51:48,960 --> 00:51:52,930
所以如果

1304
00:51:52,930 --> 00:51:55,030
你对基数有正确的估计，

1305
00:51:55,030 --> 00:51:56,230
那么你可以说好吧，我的

1306
00:51:56,230 --> 00:51:57,520
哈希表需要这么大，因为

1307
00:51:57,520 --> 00:51:59,170
我的数据集会进入 这么

1308
00:51:59,170 --> 00:52:01,240
大，然后你不用担心你

1309
00:52:01,240 --> 00:52:03,910
知道这些长的特殊扫描，所以

1310
00:52:03,910 --> 00:52:06,390
为了证明这实际上是

1311
00:52:06,390 --> 00:52:08,320
这样，这是一个帖子错过了九点

1312
00:52:08,320 --> 00:52:11,410
四，然后在 Postgres 9.5 他们有

1313
00:52:11,410 --> 00:52:13,570
能力动态调整

1314
00:52:13,570 --> 00:52:16,090
有 h 表，如果您的估计出错，那么

1315
00:52:16,090 --> 00:52:18,070
他们将

1316
00:52:18,070 --> 00:52:20,230
帖子 9 的该功能从 5 点移植到 9 点 4 点，然后他们

1317
00:52:20,230 --> 00:52:21,910
重新进行了相同的实验，

1318
00:52:21,910 --> 00:52:24,550
现在您看到有更多的查询

1319
00:52:24,550 --> 00:52:26,590
实际上很重要或越来越

1320
00:52:26,590 --> 00:52:27,940
接近您应该到达的位置 如果你

1321
00:52:27,940 --> 00:52:35,410
有真正的基数，那么这

1322
00:52:35,410 --> 00:52:37,090
是一个很好的例子，表明它

1323
00:52:37,090 --> 00:52:39,730
不仅仅是选择一个运算符是否

1324
00:52:39,730 --> 00:52:41,200
应该是一个散列联合还是一个

1325
00:52:41,200 --> 00:52:42,790
循环的网络

1326
00:52:42,790 --> 00:52:43,870
实际上你在该运算符中实际做的事情

1327
00:52:43,870 --> 00:52:46,120
可能会受到很大影响

1328
00:52:46,120 --> 00:52:47,550
估计你的成本模型

1329
00:52:47,550 --> 00:52:54,250
一切正常 所以维克多然后说

1330
00:52:54,250 --> 00:52:55,900
你知道在谈论这个 他

1331
00:52:55,900 --> 00:52:59,800
给我发了一份概要 他

1332
00:52:59,800 --> 00:53:00,880


1333
00:53:00,880 --> 00:53:02,530
认为是从这个实验或这项

1334
00:53:02,530 --> 00:53:06,460
研究中得出的最重要的事情 他做到了，第一个

1335
00:53:06,460 --> 00:53:10,620
是他们认为从查询优化器中获得准确的

1336
00:53:10,620 --> 00:53:12,970
成本模型，

1337
00:53:12,970 --> 00:53:15,430
并且实际上在某些

1338
00:53:15,430 --> 00:53:17,110
情况下比

1339
00:53:17,110 --> 00:53:18,750
拥有最快的成本模型更重要 如果我们的优化器完全一团糟，

1340
00:53:18,750 --> 00:53:22,770
我们喜欢挑选最糟糕的订单，

1341
00:53:22,770 --> 00:53:24,540
那么我们就知道 Cindy 处理或查询

1342
00:53:24,540 --> 00:53:25,859
编译以及

1343
00:53:25,859 --> 00:53:26,760
我们整个学期讨论的所有其他技巧

1344
00:53:26,760 --> 00:53:29,400


1345
00:53:29,400 --> 00:53:31,260


1346
00:53:31,260 --> 00:53:33,359
我们总是在做这个循环连接然后

1347
00:53:33,359 --> 00:53:35,310
谁在乎引擎有多快，就像

1348
00:53:35,310 --> 00:53:36,420
你知道简单的例子，当我们

1349
00:53:36,420 --> 00:53:38,520
实际向它抛出真实的真实世界数据时

1350
00:53:38,520 --> 00:53:41,310
，我们只是想让你知道

1351
00:53:41,310 --> 00:53:46,020
我们会被压垮所以

1352
00:53:46,020 --> 00:53:47,880
能够拿起细木工

1353
00:53:47,880 --> 00:53:49,320
是我们所有人最重要的事情，

1354
00:53:49,320 --> 00:53:52,890
他们发现的另一件事基本上

1355
00:53:52,890 --> 00:53:55,619
是基数估计

1356
00:53:55,619 --> 00:53:57,320
总是错误的，

1357
00:53:57,320 --> 00:54:00,030
所以当你

1358
00:54:00,030 --> 00:54:02,609
在你的系统中实际实施你想要的运算符时

1359
00:54:02,609 --> 00:54:05,250
它们具有足够的适应性而不会

1360
00:54:05,250 --> 00:54:07,640
适应它，因此它们不依赖于

1361
00:54:07,640 --> 00:54:10,020
来自查询

1362
00:54:10,020 --> 00:54:11,790
优化器的估计，因为您只是假设这

1363
00:54:11,790 --> 00:54:14,490
会是错误的，并且随着数据进入

1364
00:54:14,490 --> 00:54:16,260
您希望能够适应

1365
00:54:16,260 --> 00:54:18,420
它我 s 您的系统正在考虑

1366
00:54:18,420 --> 00:54:19,680
实际看到的实际数据，

1367
00:54:19,680 --> 00:54:22,050
因此只是自动调整哈希表的大小，

1368
00:54:22,050 --> 00:54:23,880
而

1369
00:54:23,880 --> 00:54:25,650
不仅仅是您知道成本

1370
00:54:25,650 --> 00:54:27,119
模型为您提供的位置并仅将大小

1371
00:54:27,119 --> 00:54:29,580
固定为正是这样，我们

1372
00:54:29,580 --> 00:54:32,670
现在在我们自己的系统中执行此操作我们还没有将

1373
00:54:32,670 --> 00:54:34,260
它推送到主分支广告这是

1374
00:54:34,260 --> 00:54:37,020
在单独的 LLVM 分支中但我们可以

1375
00:54:37,020 --> 00:54:38,640
像谓词一样重新排序因此一些

1376
00:54:38,640 --> 00:54:39,510
谓词比其他谓词更具选择性

1377
00:54:39,510 --> 00:54:41,430
成本模型可能认为

1378
00:54:41,430 --> 00:54:43,080
您想要执行您的 谓词按照

1379
00:54:43,080 --> 00:54:44,910
这个顺序，然后我们可以在

1380
00:54:44,910 --> 00:54:49,650
看到真实数据时动态地洗牌

1381
00:54:49,650 --> 00:54:52,980
，他说的其他事情，

1382
00:54:52,980 --> 00:54:56,339
你在hyper的设计中看到的

1383
00:54:56,339 --> 00:55:00,630
就是拥有一个引擎，它可以做

1384
00:55:00,630 --> 00:55:03,270
更快的淬火扫描和快速 散列

1385
00:55:03,270 --> 00:55:06,750
连接实际上最终可能

1386
00:55:06,750 --> 00:55:08,670
比让所有这些花哨的

1387
00:55:08,670 --> 00:55:10,650
索引来正确地进行连接和

1388
00:55:10,650 --> 00:55:13,470
查找更好，因为您拥有的索引越多，

1389
00:55:13,470 --> 00:55:15,150
您的估计就越复杂

1390
00:55:15,150 --> 00:55:17,609
你的

1391
00:55:17,609 --> 00:55:19,980
成本模型，而不是试图解释其中

1392
00:55:19,980 --> 00:55:22,290
的任何一个，你只是说

1393
00:55:22,290 --> 00:55:23,520
老实说，我要顺序扫描

1394
00:55:23,520 --> 00:55:25,770
所有东西，只是

1395
00:55:25,770 --> 00:55:28,650
非常快速地翻阅数据，谁在乎

1396
00:55:28,650 --> 00:55:29,880
你知道索引是否会

1397
00:55:29,880 --> 00:55:31,880
在这里

1398
00:55:31,880 --> 00:55:33,799
帮助我 分析查询 我可能

1399
00:55:33,799 --> 00:55:35,480
同意这一点，因为有些事情可能对其他事情来说还

1400
00:55:35,480 --> 00:55:40,069
不够，我

1401
00:55:40,069 --> 00:55:42,650
对这最后一个有复杂的感觉，他

1402
00:55:42,650 --> 00:55:45,650
说试图拥有一个更准确的成本

1403
00:55:45,650 --> 00:55:47,240
模型，例如使用微基准

1404
00:55:47,240 --> 00:55:48,079


1405
00:55:48,079 --> 00:55:49,970
开始就像试图让你了解

1406
00:55:49,970 --> 00:55:51,920
硬件配置并将其包含在

1407
00:55:51,920 --> 00:55:54,769
你的估计中，他们认为

1408
00:55:54,769 --> 00:55:56,630
只是有更好的

1409
00:55:56,630 --> 00:55:58,400
基数估计是浪费时间是最

1410
00:55:58,400 --> 00:56:00,019
重要的事情，这意味着拥有更好的

1411
00:56:00,019 --> 00:56:02,329
统计数据更好的草图，无论

1412
00:56:02,329 --> 00:56:03,529
你是在那里投入深网还是

1413
00:56:03,529 --> 00:56:06,789
我们不能单独讨论这个问题，

1414
00:56:06,789 --> 00:56:09,349
但正确处理

1415
00:56:09,349 --> 00:56:11,839
比拥有更细粒度的

1416
00:56:11,839 --> 00:56:13,009
准确性以及港口实际上

1417
00:56:13,009 --> 00:56:16,009
可以做的事情更重要 所以我认为这些

1418
00:56:16,009 --> 00:56:18,170
再次非常有用，就像

1419
00:56:18,170 --> 00:56:20,269
我们在系统设计中采用的一些一样，

1420
00:56:20,269 --> 00:56:23,900
其他的不太好所以

1421
00:56:23,900 --> 00:56:25,789
我想谈论的最后一

1422
00:56:25,789 --> 00:56:27,259
件事将引导我们进入我们将要谈论的内容

1423
00:56:27,259 --> 00:56:31,430
大约一个星期一是

1424
00:56:31,430 --> 00:56:35,539
来自 IBM 的这个项目，我猜是 2000 年 2001 年，所以

1425
00:56:35,539 --> 00:56:39,190
18 年前的这个叫做 Leo 的东西，

1426
00:56:39,190 --> 00:56:41,480
所以你可能在想，

1427
00:56:41,480 --> 00:56:43,309
他早些时候暗示的东西是

1428
00:56:43,309 --> 00:56:45,950
，如果我的成本模型会做

1429
00:56:45,950 --> 00:56:46,910
这些 估计，

1430
00:56:46,910 --> 00:56:47,450


1431
00:56:47,450 --> 00:56:50,359
然后当我运行我的查询时，他们会出错，然后我看到哦，

1432
00:56:50,359 --> 00:56:51,589
数据实际上完全不同，

1433
00:56:51,589 --> 00:56:54,289
我不能自己解决，或者我不能

1434
00:56:54,289 --> 00:56:57,410
也正确地修复估计

1435
00:56:57,410 --> 00:57:00,410
，这就是 IBM 尝试

1436
00:57:00,410 --> 00:57:01,309
使用称为学习

1437
00:57:01,309 --> 00:57:03,680
优化器的这个东西，所以我的想法是我的

1438
00:57:03,680 --> 00:57:05,630
查询显示我通过我的核心运行它

1439
00:57:05,630 --> 00:57:07,759
我的查询优化器我生成成本

1440
00:57:07,759 --> 00:57:09,140
金额生成关于

1441
00:57:09,140 --> 00:57:11,089
我认为数据看起来像什么的估计然后我运行

1442
00:57:11,089 --> 00:57:13,579
该查询 然后现在我观察到

1443
00:57:13,579 --> 00:57:15,680
他

1444
00:57:15,680 --> 00:57:17,329
对我的谓词选择性基数的估计是

1445
00:57:17,329 --> 00:57:19,819
匹配我在真实数据中实际看到的内容

1446
00:57:19,819 --> 00:57:22,460
，然后当查询

1447
00:57:22,460 --> 00:57:25,099
完成时，他们检查

1448
00:57:25,099 --> 00:57:30,230
估计是否与

1449
00:57:30,230 --> 00:57:32,539
真实数据不同，如果不同，则 他们

1450
00:57:32,539 --> 00:57:36,079
尝试将真实数据反馈

1451
00:57:36,079 --> 00:57:38,119
回优化器，以便在下一个

1452
00:57:38,119 --> 00:57:40,400
查询出现时，他们可以依赖

1453
00:57:40,400 --> 00:57:41,390
他们已经从

1454
00:57:41,390 --> 00:57:45,170
上一个查询中收集的数据，所以

1455
00:57:45,170 --> 00:57:46,520
这似乎可以解决这个问题

1456
00:57:46,520 --> 00:57:49,069
，就像 oh 我们有些错误

1457
00:57:49,069 --> 00:57:50,690
我们运行真实数据 看看实际

1458
00:57:50,690 --> 00:58:01,819
发生了什么 我想说

1459
00:58:01,819 --> 00:58:03,260
我曾经与之交谈过的每个 db2 管理员

1460
00:58:03,260 --> 00:58:06,650
，我问过他这个问题 他们

1461
00:58:06,650 --> 00:58:08,240
总是说他们在安装 db2 时做的第一件事

1462
00:58:08,240 --> 00:58:10,339
是他们 把所有的球都转过来，

1463
00:58:10,339 --> 00:58:13,849
因为它从来没有工作过，我们让

1464
00:58:13,849 --> 00:58:15,770
Oracle 有类似的东西来做

1465
00:58:15,770 --> 00:58:17,630
内存管理，比如

1466
00:58:17,630 --> 00:58:18,589
缓冲池管理器的自动内存管理，

1467
00:58:18,589 --> 00:58:21,859
几周前我们和一些 DBA 谈过

1468
00:58:21,859 --> 00:58:23,569
，它 就像是的，我们

1469
00:58:23,569 --> 00:58:25,460
立即关闭它，就像所有这些自动化的

1470
00:58:25,460 --> 00:58:29,960
东西都不对，所以我的意思是我从来没有

1471
00:58:29,960 --> 00:58:32,839
发现为什么我听说

1472
00:58:32,839 --> 00:58:34,490
在 IBM 有一些工程困难

1473
00:58:34,490 --> 00:58:35,780
要让这个东西真正

1474
00:58:35,780 --> 00:58:37,730
按照他们想要的方式工作 并

1475
00:58:37,730 --> 00:58:40,250
正确地融入系统的其余部分我认为

1476
00:58:40,250 --> 00:58:41,630
由于工程

1477
00:58:41,630 --> 00:58:43,790
原因这不起作用而且很遗憾因为

1478
00:58:43,790 --> 00:58:45,920
这似乎可以解决我们的

1479
00:58:45,920 --> 00:58:48,079
问题但因此我认为

1480
00:58:48,079 --> 00:58:50,150
很多人很多 的

1481
00:58:50,150 --> 00:58:51,619
商业系统一直在犹豫是否

1482
00:58:51,619 --> 00:58:53,750
采用类似的技术，因为

1483
00:58:53,750 --> 00:58:56,390
这件事你知道它已经崩溃了

1484
00:58:56,390 --> 00:58:58,640
，但是这个事件让我们进入了

1485
00:58:58,640 --> 00:58:59,930
我们周一将要讨论的话题，

1486
00:58:59,930 --> 00:59:02,270
比如复兴或不是

1487
00:59:02,270 --> 00:59:03,859
复兴而是延续 尝试

1488
00:59:03,859 --> 00:59:06,790


1489
00:59:06,790 --> 00:59:10,430
在数据库系统中进行自动调优以

1490
00:59:10,430 --> 00:59:11,780
给 e8 留下其中一些困难

1491
00:59:11,780 --> 00:59:14,299
的悠久历史，所以现在您知道流行的是

1492
00:59:14,299 --> 00:59:15,950
机器学习以及

1493
00:59:15,950 --> 00:59:16,970
尝试应用机器学习的人们 解决这些

1494
00:59:16,970 --> 00:59:18,770
问题，但实际上回到

1495
00:59:18,770 --> 00:59:21,109
了 1970 年代，就像人们

1496
00:59:21,109 --> 00:59:22,309
已经在这个问题上研究了很

1497
00:59:22,309 --> 00:59:24,770
长时间，所以这只是一个

1498
00:59:24,770 --> 00:59:30,400
例子，它确实不起作用，所以

1499
00:59:30,400 --> 00:59:33,440
今天的主要收获是 一个

1500
00:59:33,440 --> 00:59:35,780
能够

1501
00:59:35,780 --> 00:59:37,010
估计每个操作员将要处理的工具数量的内存数据库

1502
00:59:37,010 --> 00:59:40,880
对我们

1503
00:59:40,880 --> 00:59:42,460


1504
00:59:42,460 --> 00:59:46,369
来说将是一个核心成本的合理近似值，当然

1505
00:59:46,369 --> 00:59:48,230
现在这意味着为了

1506
00:59:48,230 --> 00:59:49,910
估计 每个运营商要处理的数字

1507
00:59:49,910 --> 00:59:52,099
你必须知道

1508
00:59:52,099 --> 00:59:54,319
基数中的卡片是你的

1509
00:59:54,319 --> 00:59:57,920
孩子运营商的卡，然后正如我们展示的那样

1510
00:59:57,920 --> 00:59:58,970
事情可能会

1511
00:59:58,970 --> 01:00:04,790
很快变坏，所以我认为

1512
01:00:04,790 --> 01:00:06,350
微软进行成本估算的方式是使用

1513
01:00:06,350 --> 01:00:07,790
草图抽样的组合

1514
01:00:07,790 --> 01:00:09,650
是正确的方法，我们尝试

1515
01:00:09,650 --> 01:00:10,850
在我们自己的数据库系统中这样做，

1516
01:00:10,850 --> 01:00:12,350
但我们从未对其进行审查以

1517
01:00:12,350 --> 01:00:13,700
确定它是否真的准确，

1518
01:00:13,700 --> 01:00:15,380
并且会在夏天

1519
01:00:15,380 --> 01:00:18,200
我们带来旧的操作时发生什么 timizer 从

1520
01:00:18,200 --> 01:00:20,630
Peloton 引入新系统 我们

1521
01:00:20,630 --> 01:00:21,920
可能不会引入成本

1522
01:00:21,920 --> 01:00:23,870
模型 我们将从一个简单的成本模型开始

1523
01:00:23,870 --> 01:00:27,320


1524
01:00:27,320 --> 01:00:28,910


1525
01:00:28,910 --> 01:00:31,190


1526
01:00:31,190 --> 01:00:32,300
您可能拥有的最简单的成本模型

1527
01:00:32,300 --> 01:00:33,890
不会为我们处理图纸订购

1528
01:00:33,890 --> 01:00:35,030
，但至少这将使我们

1529
01:00:35,030 --> 01:00:39,520
开始使用图片索引好吧

1530
01:00:40,020 --> 01:01:08,500
这是什么我不会说你

1531
01:01:08,500 --> 01:01:11,820
坐下祈祷

