1
00:00:01,300 --> 00:00:05,129
[Music]

2
00:00:05,200 --> 00:00:05,930
[Applause]

3
00:00:05,930 --> 00:00:08,630
[Music]

4
00:00:08,630 --> 00:00:10,020
[Applause]

5
00:00:10,020 --> 00:00:11,540
[Music]

6
00:00:11,540 --> 00:00:14,700
today is part three for our lecture on

7
00:00:14,700 --> 00:00:18,000
query optimization it's again I'm here

8
00:00:18,000 --> 00:00:20,340
at my home office it's just me and the

9
00:00:20,340 --> 00:00:23,609
Terrier who may or may not be asking

10
00:00:23,609 --> 00:00:25,430
questions as we go along

11
00:00:25,430 --> 00:00:29,519
so the the type of optimizers we've

12
00:00:29,519 --> 00:00:32,520
talked about so far have been this sort

13
00:00:32,520 --> 00:00:34,950
of classic query optimizers where the

14
00:00:34,950 --> 00:00:37,440
query shows up we parse the sequel then

15
00:00:37,440 --> 00:00:38,730
we run it through the optimizer and we

16
00:00:38,730 --> 00:00:41,219
generate a plan before we even begin

17
00:00:41,219 --> 00:00:43,649
executing the query this is how most

18
00:00:43,649 --> 00:00:45,809
query optimizers work right obviously

19
00:00:45,809 --> 00:00:47,850
you can't run the query unless you have

20
00:00:47,850 --> 00:00:49,559
a query plan so you have to put it

21
00:00:49,559 --> 00:00:51,719
through the optimizer but the challenge

22
00:00:51,719 --> 00:00:54,600
is going to be that what maybe we think

23
00:00:54,600 --> 00:00:58,739
is the best plan during the journey this

24
00:00:58,739 --> 00:01:00,390
optimization phase before we even start

25
00:01:00,390 --> 00:01:03,510
running it may actually be incorrect

26
00:01:03,510 --> 00:01:06,420
right because there's a since we can't

27
00:01:06,420 --> 00:01:08,520
actually run the query without a plan

28
00:01:08,520 --> 00:01:10,619
there's some assumptions we have to make

29
00:01:10,619 --> 00:01:12,479
about what the database and what our

30
00:01:12,479 --> 00:01:15,360
environment looks like but these things

31
00:01:15,360 --> 00:01:17,490
can change over time for various reasons

32
00:01:17,490 --> 00:01:20,280
right so the physical design that

33
00:01:20,280 --> 00:01:22,439
database can change because the

34
00:01:22,439 --> 00:01:24,090
administrator the application could add

35
00:01:24,090 --> 00:01:25,740
and drop indexes or change change the

36
00:01:25,740 --> 00:01:28,829
partitioning scheme the the database

37
00:01:28,829 --> 00:01:30,540
itself could get modified people could

38
00:01:30,540 --> 00:01:32,460
insert tuples or delete tuples and that

39
00:01:32,460 --> 00:01:33,840
could change the distribution of values

40
00:01:33,840 --> 00:01:37,049
for our columns if we're invoking our

41
00:01:37,049 --> 00:01:39,799
queries as prepared statements then the

42
00:01:39,799 --> 00:01:43,649
the behavior of the query for one set of

43
00:01:43,649 --> 00:01:44,909
the parameters might be different for

44
00:01:44,909 --> 00:01:46,950
another set of parameters and of course

45
00:01:46,950 --> 00:01:50,040
every time you run analyze or whatever

46
00:01:50,040 --> 00:01:52,619
the command is in our database system to

47
00:01:52,619 --> 00:01:54,810
recollect the statistics that we use in

48
00:01:54,810 --> 00:01:57,180
our cost models every time we update

49
00:01:57,180 --> 00:01:59,969
them then the decisions we'll make in

50
00:01:59,969 --> 00:02:01,710
our optimizer could be entirely

51
00:02:01,710 --> 00:02:05,610
different so the sort of focus today is

52
00:02:05,610 --> 00:02:07,979
to understand like how can we

53
00:02:07,979 --> 00:02:12,180
potentially improve our optimizers the

54
00:02:12,180 --> 00:02:13,569
efficacy of our the

55
00:02:13,569 --> 00:02:15,040
the quality the plans that were

56
00:02:15,040 --> 00:02:16,900
generating by maybe relaxing this

57
00:02:16,900 --> 00:02:18,340
requirement that we that we only

58
00:02:18,340 --> 00:02:20,109
generate a plan or only revisit

59
00:02:20,109 --> 00:02:23,349
assumptions or we never visit our

60
00:02:23,349 --> 00:02:25,299
assumptions once we generate the plan

61
00:02:25,299 --> 00:02:27,790
the beginning so to do this we want

62
00:02:27,790 --> 00:02:30,939
understand a little bit what what a bad

63
00:02:30,939 --> 00:02:33,120
query pan looks like a wide query plans

64
00:02:33,120 --> 00:02:35,409
can be considered bad and then end up

65
00:02:35,409 --> 00:02:39,099
with less than optimal performance so

66
00:02:39,099 --> 00:02:41,680
we'll cover this more on Wednesday when

67
00:02:41,680 --> 00:02:44,590
we discuss cost models but in general I

68
00:02:44,590 --> 00:02:46,450
say the high-level the biggest problem

69
00:02:46,450 --> 00:02:48,790
we're always going to have is the we're

70
00:02:48,790 --> 00:02:50,349
gonna get the join order is incorrect

71
00:02:50,349 --> 00:02:52,030
joins are almost always the most

72
00:02:52,030 --> 00:02:53,919
expensive thing we're gonna execute in a

73
00:02:53,919 --> 00:02:56,950
analytical workload and so if we get the

74
00:02:56,950 --> 00:03:00,189
ordering incorrect that can get lead to

75
00:03:00,189 --> 00:03:02,530
too poor performance and the reason why

76
00:03:02,530 --> 00:03:05,319
we're going to make a select incorrect

77
00:03:05,319 --> 00:03:07,269
ordering is because we're gonna have

78
00:03:07,269 --> 00:03:08,919
inaccurate cardinality estimations

79
00:03:08,919 --> 00:03:11,590
meaning we think that our join is going

80
00:03:11,590 --> 00:03:13,659
to produce X number of tuples but it's

81
00:03:13,659 --> 00:03:16,389
really gonna be you know X x wires you

82
00:03:16,389 --> 00:03:19,690
know some some some larger multiple they

83
00:03:19,690 --> 00:03:21,549
mobile it's gonna happen again we'll

84
00:03:21,549 --> 00:03:23,949
discuss why this occurs more in the next

85
00:03:23,949 --> 00:03:27,489
lecture but this this this issue is

86
00:03:27,489 --> 00:03:28,989
gonna be a reoccurring theme that we

87
00:03:28,989 --> 00:03:31,870
have to overcome and today's discussion

88
00:03:31,870 --> 00:03:36,299
is sort of C techniques to do this so

89
00:03:36,299 --> 00:03:38,560
but since we know things are gonna go

90
00:03:38,560 --> 00:03:40,479
bad like we just know we can just assume

91
00:03:40,479 --> 00:03:42,129
that our cost model is gonna mean

92
00:03:42,129 --> 00:03:43,690
accurate or optimizers gonna make bad

93
00:03:43,690 --> 00:03:47,709
decisions then ideally if we can detect

94
00:03:47,709 --> 00:03:51,099
how bad our query plan is once we start

95
00:03:51,099 --> 00:03:53,650
running it then we can make a decision

96
00:03:53,650 --> 00:03:57,790
to adapt the plan to come to modify

97
00:03:57,790 --> 00:03:59,979
potentially to account for these

98
00:03:59,979 --> 00:04:01,540
differences and what we're seeing in the

99
00:04:01,540 --> 00:04:02,919
real data versus what we assume we're

100
00:04:02,919 --> 00:04:05,229
going to see and then we can then try to

101
00:04:05,229 --> 00:04:08,919
convert our plan into into something

102
00:04:08,919 --> 00:04:12,310
that's closer to the optimal plan so

103
00:04:12,310 --> 00:04:13,989
what I mean that like that is say we

104
00:04:13,989 --> 00:04:15,489
have a simple query like this it's a

105
00:04:15,489 --> 00:04:17,649
four-way join between eight tables a B C

106
00:04:17,649 --> 00:04:19,449
and D and then we just have a simple

107
00:04:19,449 --> 00:04:23,289
where clause for the B and D tables so

108
00:04:23,289 --> 00:04:26,050
let's say that we run this query through

109
00:04:26,050 --> 00:04:27,400
our query optimizer and we do

110
00:04:27,400 --> 00:04:29,440
this plan right it's a bunch of hash

111
00:04:29,440 --> 00:04:30,820
drawings and nothing about sequential

112
00:04:30,820 --> 00:04:34,930
scans but let's say that when we when we

113
00:04:34,930 --> 00:04:36,400
generate this plan for this particular

114
00:04:36,400 --> 00:04:39,220
join we estimated the cardinality of

115
00:04:39,220 --> 00:04:43,000
that operator to be 1000 right this is

116
00:04:43,000 --> 00:04:44,770
this is an arbitrary number that I'm

117
00:04:44,770 --> 00:04:46,360
using for this illustration like the

118
00:04:46,360 --> 00:04:48,639
cardinality is the number of tuples that

119
00:04:48,639 --> 00:04:51,490
this operator all MIT but let's say when

120
00:04:51,490 --> 00:04:52,870
we actually started run it we see that

121
00:04:52,870 --> 00:04:55,210
were actually generating a hundred

122
00:04:55,210 --> 00:04:58,870
thousand tuples so our actual

123
00:04:58,870 --> 00:05:00,430
cardinality is two orders of magnitude

124
00:05:00,430 --> 00:05:03,940
greater than the estimate one so the

125
00:05:03,940 --> 00:05:05,289
question we're trying to deal with today

126
00:05:05,289 --> 00:05:07,389
is if we knew what the district our

127
00:05:07,389 --> 00:05:10,570
tonality was before we started executing

128
00:05:10,570 --> 00:05:12,280
it I'm sorry

129
00:05:12,280 --> 00:05:15,550
while we're executing it then could we

130
00:05:15,550 --> 00:05:18,789
change some aspect of this query plan to

131
00:05:18,789 --> 00:05:22,570
get us closer to a more optimal plan but

132
00:05:22,570 --> 00:05:23,740
could we change the Jordan ordering

133
00:05:23,740 --> 00:05:25,270
where we want to choose a different

134
00:05:25,270 --> 00:05:27,160
algorithm to do our join well we want to

135
00:05:27,160 --> 00:05:28,570
change maybe the access methods that

136
00:05:28,570 --> 00:05:31,599
come below the join to use and maybe an

137
00:05:31,599 --> 00:05:33,250
index or a different different type of

138
00:05:33,250 --> 00:05:36,130
scam so this is sort of what we're

139
00:05:36,130 --> 00:05:37,840
focusing on today is how to then maybe

140
00:05:37,840 --> 00:05:40,570
adapt this this kind of plan when we

141
00:05:40,570 --> 00:05:42,669
know something about the what the data

142
00:05:42,669 --> 00:05:46,000
looks like once we start running it so

143
00:05:46,000 --> 00:05:51,430
the the high-level idea again is that we

144
00:05:51,430 --> 00:05:53,229
want to be able to execute but you ask

145
00:05:53,229 --> 00:05:56,020
maybe the behavior of a plan to in order

146
00:05:56,020 --> 00:05:58,599
to determine X maybe the behavior of a

147
00:05:58,599 --> 00:06:01,389
plan to determine its quality relative

148
00:06:01,389 --> 00:06:02,260
to other plans

149
00:06:02,260 --> 00:06:04,599
and so the cost model is doing but the

150
00:06:04,599 --> 00:06:06,490
tricky thing is gonna be back here

151
00:06:06,490 --> 00:06:08,320
before I started executing us

152
00:06:08,320 --> 00:06:11,349
I had to derive this cardinality from

153
00:06:11,349 --> 00:06:14,289
the from my like statistics that I have

154
00:06:14,289 --> 00:06:16,419
maintaining my catalog about what my

155
00:06:16,419 --> 00:06:18,880
table looks like or what the what these

156
00:06:18,880 --> 00:06:20,530
two tables look like when you join them

157
00:06:20,530 --> 00:06:25,120
together so the stats are me based on

158
00:06:25,120 --> 00:06:27,310
histograms and possibly samples that

159
00:06:27,310 --> 00:06:29,199
we're collecting from the data we can

160
00:06:29,199 --> 00:06:32,139
also make decisions about what the

161
00:06:32,139 --> 00:06:33,460
hardware looks like what kind of cache

162
00:06:33,460 --> 00:06:34,810
sizes we have what kind of maybe I

163
00:06:34,810 --> 00:06:36,969
wouldn't want to use what other queries

164
00:06:36,969 --> 00:06:38,680
and run into the same time like the cost

165
00:06:38,680 --> 00:06:40,599
model stuff we'll cover next class but

166
00:06:40,599 --> 00:06:41,230
then

167
00:06:41,230 --> 00:06:43,090
main idea to think about is what we

168
00:06:43,090 --> 00:06:45,070
talked about today is before we run the

169
00:06:45,070 --> 00:06:48,250
query we only have an estimation of what

170
00:06:48,250 --> 00:06:49,780
the data looks like and how our query

171
00:06:49,780 --> 00:06:53,530
will perform and if we get that wrong we

172
00:06:53,530 --> 00:06:54,880
wanted then try to be able to correct

173
00:06:54,880 --> 00:06:58,210
ourselves so the technique we're talking

174
00:06:58,210 --> 00:07:00,490
about today is called adaptive query

175
00:07:00,490 --> 00:07:02,530
optimization and sometimes called in the

176
00:07:02,530 --> 00:07:04,450
research literature adaptive query

177
00:07:04,450 --> 00:07:06,550
processing right they're essentially

178
00:07:06,550 --> 00:07:08,890
synonymous and into everything I said so

179
00:07:08,890 --> 00:07:11,410
far the idea is that this technique is

180
00:07:11,410 --> 00:07:12,790
gonna allow the database system to

181
00:07:12,790 --> 00:07:17,290
modify the query plan for a query to

182
00:07:17,290 --> 00:07:19,450
better fit what the actual underlying

183
00:07:19,450 --> 00:07:22,300
data looks like and we leave modifying

184
00:07:22,300 --> 00:07:24,490
before the query plan by just generating

185
00:07:24,490 --> 00:07:26,470
an entirely new query plan like throwing

186
00:07:26,470 --> 00:07:29,620
away the old one and starting over or we

187
00:07:29,620 --> 00:07:32,800
could try to modify a subset of the

188
00:07:32,800 --> 00:07:34,840
query plan a read query plan by

189
00:07:34,840 --> 00:07:37,090
introducing new sort of sub plans almost

190
00:07:37,090 --> 00:07:40,030
like a pipeline at different points

191
00:07:40,030 --> 00:07:41,230
where we have to materialize people

192
00:07:41,230 --> 00:07:43,240
where we could potentially switch from

193
00:07:43,240 --> 00:07:45,850
you know one plan strategy to it to

194
00:07:45,850 --> 00:07:48,850
another and this one here you basically

195
00:07:48,850 --> 00:07:50,500
go back to the optimizer and start over

196
00:07:50,500 --> 00:07:52,810
this one here is that you can try to

197
00:07:52,810 --> 00:07:56,500
have the optimizer only do only replan a

198
00:07:56,500 --> 00:07:57,910
portion of it or provide these

199
00:07:57,910 --> 00:08:00,960
alternative strategies at the beginning

200
00:08:00,960 --> 00:08:05,140
so the main the main up sort of takeaway

201
00:08:05,140 --> 00:08:06,660
approach what we're doing here is that

202
00:08:06,660 --> 00:08:09,040
rather than just relying on our

203
00:08:09,040 --> 00:08:10,750
statistical models that our estimations

204
00:08:10,750 --> 00:08:12,430
or approximations on what the data looks

205
00:08:12,430 --> 00:08:14,230
like we're trying to use the data we've

206
00:08:14,230 --> 00:08:16,870
collected while we actually execute the

207
00:08:16,870 --> 00:08:18,870
query to then help us make a decision

208
00:08:18,870 --> 00:08:21,850
about what the right plan should be for

209
00:08:21,850 --> 00:08:25,000
our particular query right and this data

210
00:08:25,000 --> 00:08:27,610
we're gonna collect is could be used for

211
00:08:27,610 --> 00:08:32,020
helping our current query or merge it we

212
00:08:32,020 --> 00:08:33,520
can merge it back into the system as

213
00:08:33,520 --> 00:08:35,440
we've collected through our analyze

214
00:08:35,440 --> 00:08:38,380
operation and have it be used for other

215
00:08:38,380 --> 00:08:42,099
queries so again we'll cover the various

216
00:08:42,099 --> 00:08:44,440
ways you have to do this but when you

217
00:08:44,440 --> 00:08:45,760
think about what a query actually is

218
00:08:45,760 --> 00:08:47,590
doing you know or what analyze does

219
00:08:47,590 --> 00:08:50,320
analyzers doing a sequential scan to

220
00:08:50,320 --> 00:08:52,660
compute some statistical models about

221
00:08:52,660 --> 00:08:54,910
what the data looks like

222
00:08:54,910 --> 00:08:58,120
and so these if we're doing the cilantro

223
00:08:58,120 --> 00:09:00,550
scan on a table that's essentially the

224
00:09:00,550 --> 00:09:01,960
same thing as analyzed and so rather

225
00:09:01,960 --> 00:09:03,880
than just evaluating predicates or using

226
00:09:03,880 --> 00:09:05,980
the you know the tuples as we scan them

227
00:09:05,980 --> 00:09:08,650
to generate the result we need for that

228
00:09:08,650 --> 00:09:10,150
particular query we can piggyback

229
00:09:10,150 --> 00:09:13,300
piggyback off of those off of that scan

230
00:09:13,300 --> 00:09:16,360
operator and sort of main or maintain or

231
00:09:16,360 --> 00:09:20,440
update our and update our Cisco models

232
00:09:20,440 --> 00:09:22,390
with new information and the question

233
00:09:22,390 --> 00:09:24,250
here is whether we just update that

234
00:09:24,250 --> 00:09:26,020
models for ourselves to make our query

235
00:09:26,020 --> 00:09:28,900
go better Oracle you can share this with

236
00:09:28,900 --> 00:09:30,730
other queries are in a global catalog

237
00:09:30,730 --> 00:09:32,880
and now other queries can benefit from

238
00:09:32,880 --> 00:09:36,450
from the data we've collected from this

239
00:09:36,450 --> 00:09:39,250
all right so there's sort of three broad

240
00:09:39,250 --> 00:09:43,600
categories that I want to cover using a

241
00:09:43,600 --> 00:09:46,330
qo or adaptive query optimization one is

242
00:09:46,330 --> 00:09:49,840
that we can use a qo to benefit future

243
00:09:49,840 --> 00:09:52,840
invocations of our query the second

244
00:09:52,840 --> 00:09:54,370
approach is to try to make our current

245
00:09:54,370 --> 00:09:56,440
invocation of our query better and then

246
00:09:56,440 --> 00:09:59,500
the last one would be well this is like

247
00:09:59,500 --> 00:10:00,760
helping your current query this is also

248
00:10:00,760 --> 00:10:02,170
helping your current query but this one

249
00:10:02,170 --> 00:10:03,670
would be sort of starting over from

250
00:10:03,670 --> 00:10:06,760
scratch and just running through the

251
00:10:06,760 --> 00:10:07,840
optimizer all over again

252
00:10:07,840 --> 00:10:11,470
this would be adding locations in the

253
00:10:11,470 --> 00:10:13,900
query plan that allow you to change one

254
00:10:13,900 --> 00:10:15,640
strategy for versus you know switching

255
00:10:15,640 --> 00:10:17,500
one strategy to the next which again out

256
00:10:17,500 --> 00:10:19,420
having to go back to to the optimizer so

257
00:10:19,420 --> 00:10:21,400
we'll go through each of these one by

258
00:10:21,400 --> 00:10:28,240
one so the so the most simplest form of

259
00:10:28,240 --> 00:10:30,850
adaptive query optimization is as I said

260
00:10:30,850 --> 00:10:36,190
where as we execute our query we also

261
00:10:36,190 --> 00:10:37,840
collect some information about what the

262
00:10:37,840 --> 00:10:40,810
data looks like and then we can use that

263
00:10:40,810 --> 00:10:43,090
information to decide whether our query

264
00:10:43,090 --> 00:10:45,730
is wrong and when we plan it or we could

265
00:10:45,730 --> 00:10:49,300
then merge that back into the sort of

266
00:10:49,300 --> 00:10:50,980
global catalog again when you think

267
00:10:50,980 --> 00:10:52,060
about this right what if the optimize

268
00:10:52,060 --> 00:10:53,680
are actually doing you have bunch of

269
00:10:53,680 --> 00:10:55,270
histograms or statistical models about

270
00:10:55,270 --> 00:10:57,280
what your your your attributes look like

271
00:10:57,280 --> 00:10:59,380
so for a given predicate in your where

272
00:10:59,380 --> 00:11:01,180
clause you want to estimate the

273
00:11:01,180 --> 00:11:02,830
selectivity of that predicate because I

274
00:11:02,830 --> 00:11:04,750
don't determine how many tuples your

275
00:11:04,750 --> 00:11:07,030
scan will emit and the amuse that make

276
00:11:07,030 --> 00:11:08,470
decisions about you

277
00:11:08,470 --> 00:11:10,000
during orderings and other things above

278
00:11:10,000 --> 00:11:14,560
in the query plan so the as you execute

279
00:11:14,560 --> 00:11:17,140
the scan if you if you you know you

280
00:11:17,140 --> 00:11:18,490
actually know the true selectivity

281
00:11:18,490 --> 00:11:19,900
because you're applying the predicate

282
00:11:19,900 --> 00:11:21,280
and the tuples and you know the number

283
00:11:21,280 --> 00:11:23,440
the the number of tuples or percentage

284
00:11:23,440 --> 00:11:26,020
of the tuples are gonna match so if you

285
00:11:26,020 --> 00:11:28,150
then determined that the cost model

286
00:11:28,150 --> 00:11:30,640
estimated my selectivity was one percent

287
00:11:30,640 --> 00:11:33,880
but when I run the real query and I run

288
00:11:33,880 --> 00:11:35,470
the query and actually do the evaluation

289
00:11:35,470 --> 00:11:37,420
of the predicate my selectivity is 99

290
00:11:37,420 --> 00:11:40,060
percent then I wanted to use that

291
00:11:40,060 --> 00:11:41,950
information to help me decide whether to

292
00:11:41,950 --> 00:11:44,590
replan my query or that future queries

293
00:11:44,590 --> 00:11:47,650
come along they can you know exploit the

294
00:11:47,650 --> 00:11:51,010
knowledge that I've gained so again the

295
00:11:51,010 --> 00:11:53,410
the the one approach is to try to fix my

296
00:11:53,410 --> 00:11:55,180
current query but the other one is just

297
00:11:55,180 --> 00:11:58,750
merging it back into the into the

298
00:11:58,750 --> 00:12:03,400
overall mystical cattle of models and in

299
00:12:03,400 --> 00:12:06,670
the catalog so that I can then help feet

300
00:12:06,670 --> 00:12:10,360
of queries in the future so the most

301
00:12:10,360 --> 00:12:11,830
basic approach to do this is called a

302
00:12:11,830 --> 00:12:14,230
reversion based plant correction and the

303
00:12:14,230 --> 00:12:16,600
idea here is as I said is just every

304
00:12:16,600 --> 00:12:18,820
single time I invoke a query I keep

305
00:12:18,820 --> 00:12:20,920
track of what query plan I generated

306
00:12:20,920 --> 00:12:22,420
forward I keep track of the cost

307
00:12:22,420 --> 00:12:25,300
estimations I have for and then the I'll

308
00:12:25,300 --> 00:12:26,770
have all my metrics of what what

309
00:12:26,770 --> 00:12:28,090
happened when actually when I ran it

310
00:12:28,090 --> 00:12:29,890
right how many how many tuples I

311
00:12:29,890 --> 00:12:31,330
selected how much CPU and memory that I

312
00:12:31,330 --> 00:12:34,180
used and I'm gonna maintain this history

313
00:12:34,180 --> 00:12:36,640
inside the database itself so you'll see

314
00:12:36,640 --> 00:12:38,350
this in like the commercial systems like

315
00:12:38,350 --> 00:12:42,340
in db2 Oracle and Seigle server they

316
00:12:42,340 --> 00:12:46,210
have this built in repository of the

317
00:12:46,210 --> 00:12:47,470
history of every single query that ever

318
00:12:47,470 --> 00:12:49,210
got them vocht and they can use that

319
00:12:49,210 --> 00:12:51,370
information to help decide how to do

320
00:12:51,370 --> 00:12:54,730
query planning in the future so let's

321
00:12:54,730 --> 00:12:56,080
say that we have a prepared statement or

322
00:12:56,080 --> 00:12:57,190
we have a query that that's being

323
00:12:57,190 --> 00:12:59,380
invoked all the time and we have a cache

324
00:12:59,380 --> 00:13:01,570
query plan so rather than maybe run it

325
00:13:01,570 --> 00:13:02,950
through the optimizer every single time

326
00:13:02,950 --> 00:13:05,890
we can use the cache quarry plan that

327
00:13:05,890 --> 00:13:07,150
we've already generated from previous

328
00:13:07,150 --> 00:13:10,990
implications so if now there's a change

329
00:13:10,990 --> 00:13:16,150
in our in in the you know the statistics

330
00:13:16,150 --> 00:13:18,250
or something about the database physical

331
00:13:18,250 --> 00:13:20,620
design that changes and we recognize

332
00:13:20,620 --> 00:13:22,209
that we maybe want it for this

333
00:13:22,209 --> 00:13:24,309
queer even keep invoking we want to run

334
00:13:24,309 --> 00:13:26,439
it back through the optimizer and see we

335
00:13:26,439 --> 00:13:28,929
generate C we generate a new plan but

336
00:13:28,929 --> 00:13:30,670
then when we run that new plan for this

337
00:13:30,670 --> 00:13:33,129
query if we see that the performance of

338
00:13:33,129 --> 00:13:36,369
the query is worse than the old plan

339
00:13:36,369 --> 00:13:38,829
that we had before then we just want to

340
00:13:38,829 --> 00:13:41,829
run back to it right if there's a

341
00:13:41,829 --> 00:13:43,869
regression in the performance we switch

342
00:13:43,869 --> 00:13:45,639
back to the plan that we know actually

343
00:13:45,639 --> 00:13:47,470
performed better for us despite the

344
00:13:47,470 --> 00:13:49,839
change in the other in the physical

345
00:13:49,839 --> 00:13:53,230
design or the statistical models so we

346
00:13:53,230 --> 00:13:54,339
use that simple query example that I

347
00:13:54,339 --> 00:13:57,009
have a for right the four-way join say

348
00:13:57,009 --> 00:13:59,679
again this is my original plan I am

349
00:13:59,679 --> 00:14:01,269
doing nothing with special scans and a

350
00:14:01,269 --> 00:14:03,519
hash drawing and say that my estimated

351
00:14:03,519 --> 00:14:06,249
cost is a thousand and my cost

352
00:14:06,249 --> 00:14:07,660
estimation is pretty good so my actual

353
00:14:07,660 --> 00:14:09,730
cost actually matches up ideas just

354
00:14:09,730 --> 00:14:12,699
synthetic numbers here so I'm going to

355
00:14:12,699 --> 00:14:15,009
store in my execution history for my

356
00:14:15,009 --> 00:14:16,869
database system that I generated for

357
00:14:16,869 --> 00:14:18,550
this query I generated this plan and

358
00:14:18,550 --> 00:14:21,999
when I ran it I had this cost and this

359
00:14:21,999 --> 00:14:24,220
is just another database or another

360
00:14:24,220 --> 00:14:26,319
table in my database system right you're

361
00:14:26,319 --> 00:14:27,939
sort of eating your own dog food rather

362
00:14:27,939 --> 00:14:31,269
than having an axillary store this is

363
00:14:31,269 --> 00:14:33,040
just another table that you looking to

364
00:14:33,040 --> 00:14:35,619
record this information all right so now

365
00:14:35,619 --> 00:14:37,540
let's say there's a there's a change in

366
00:14:37,540 --> 00:14:39,999
our databases on say the DBA comes along

367
00:14:39,999 --> 00:14:43,569
and adds two indexes on the B table in

368
00:14:43,569 --> 00:14:45,610
the D table which we're using in our

369
00:14:45,610 --> 00:14:47,889
where clause so now when we invoke the

370
00:14:47,889 --> 00:14:50,170
same query again we would recognize that

371
00:14:50,170 --> 00:14:52,749
the design the database has changed in

372
00:14:52,749 --> 00:14:54,339
such a way where we may not want to

373
00:14:54,339 --> 00:14:58,119
reconsider the query plan for this

374
00:14:58,119 --> 00:14:59,799
particular query right so this query

375
00:14:59,799 --> 00:15:02,259
touches B dot Val and D dot Val well I

376
00:15:02,259 --> 00:15:03,850
just happen to create indexes on those

377
00:15:03,850 --> 00:15:06,399
columns so I want to run this through my

378
00:15:06,399 --> 00:15:08,069
optimizer again and see what plan again

379
00:15:08,069 --> 00:15:10,869
let's say now for the new plan it's

380
00:15:10,869 --> 00:15:12,220
completely different so now we're

381
00:15:12,220 --> 00:15:14,290
instead of running hash joins or running

382
00:15:14,290 --> 00:15:15,699
index nested loop joins and we're doing

383
00:15:15,699 --> 00:15:17,769
an index scan on beyond D which we can

384
00:15:17,769 --> 00:15:19,629
now do because we have index on that

385
00:15:19,629 --> 00:15:21,999
which we didn't have before and so now

386
00:15:21,999 --> 00:15:24,160
we're gonna pick this plan for our query

387
00:15:24,160 --> 00:15:26,799
because the St estimated cost is 800

388
00:15:26,799 --> 00:15:28,689
which is less than the estimated cost so

389
00:15:28,689 --> 00:15:30,610
that we had over here but when we

390
00:15:30,610 --> 00:15:33,160
actually run it for whatever reason that

391
00:15:33,160 --> 00:15:34,509
we think that we don't care about at

392
00:15:34,509 --> 00:15:38,199
this point the actual cost is is 1200

393
00:15:38,199 --> 00:15:40,799
this could be that the you know we

394
00:15:40,799 --> 00:15:43,059
incorrectly estimated that the cost of

395
00:15:43,059 --> 00:15:44,290
these nested loop joins would be cheaper

396
00:15:44,290 --> 00:15:46,480
than the hash joins so we picked in that

397
00:15:46,480 --> 00:15:49,929
nested loop joins so just as before it's

398
00:15:49,929 --> 00:15:55,480
when we actually put this give me that's

399
00:15:55,480 --> 00:15:58,870
not Corona um if we actually now put

400
00:15:58,870 --> 00:16:01,179
this in our extra history we would

401
00:16:01,179 --> 00:16:05,699
recognize that the for this plan here

402
00:16:05,699 --> 00:16:07,749
again it performed worse than this other

403
00:16:07,749 --> 00:16:09,939
one here so the next time we invoke it

404
00:16:09,939 --> 00:16:11,499
we want to make sure that we use this

405
00:16:11,499 --> 00:16:13,540
plan oh you want to look back to the one

406
00:16:13,540 --> 00:16:17,919
that we know perform better so for this

407
00:16:17,919 --> 00:16:20,199
approach here this is something that

408
00:16:20,199 --> 00:16:22,540
Microsoft has had in sequel server and I

409
00:16:22,540 --> 00:16:24,490
think Oracle has something similar in

410
00:16:24,490 --> 00:16:28,449
since maybe 2012-2013 but this is pretty

411
00:16:28,449 --> 00:16:29,769
coarse-grained right this is pretty

412
00:16:29,769 --> 00:16:31,209
brain-dead heuristic that's basically

413
00:16:31,209 --> 00:16:34,660
saying oh this query plan is bad let me

414
00:16:34,660 --> 00:16:36,790
just switch back to this one I said so

415
00:16:36,790 --> 00:16:39,669
it's not at all or nothing thing so the

416
00:16:39,669 --> 00:16:40,809
payment you guys are assigned reading

417
00:16:40,809 --> 00:16:42,579
from Microsoft is called plan stitching

418
00:16:42,579 --> 00:16:44,709
and the eye high-low idea is exactly the

419
00:16:44,709 --> 00:16:46,869
same where if we recognize that our

420
00:16:46,869 --> 00:16:49,990
query is running slower than query plans

421
00:16:49,990 --> 00:16:52,269
we saw in the past rather than

422
00:16:52,269 --> 00:16:56,350
potentially this strong way the entire

423
00:16:56,350 --> 00:16:58,089
query plan that the new query plan and

424
00:16:58,089 --> 00:17:00,089
reverting back to the old one maybe

425
00:17:00,089 --> 00:17:03,100
there are elements or aspects or sub

426
00:17:03,100 --> 00:17:06,010
plans within the newer plan we actually

427
00:17:06,010 --> 00:17:09,849
wouldn't want to retain because and then

428
00:17:09,849 --> 00:17:11,799
that data that'll help us lead us

429
00:17:11,799 --> 00:17:13,359
towards towards a better plan a more

430
00:17:13,359 --> 00:17:16,630
optimal plan right and the other if you

431
00:17:16,630 --> 00:17:18,069
think about plant stitch as well is that

432
00:17:18,069 --> 00:17:22,119
the sub plans you're gonna borrow from

433
00:17:22,119 --> 00:17:24,789
other queries don't need to be actually

434
00:17:24,789 --> 00:17:26,409
from the same query like in this case

435
00:17:26,409 --> 00:17:29,830
here I can only reuse the plan in the

436
00:17:29,830 --> 00:17:31,630
simplest form I can only swap the team

437
00:17:31,630 --> 00:17:33,220
plans if they're running on the exact

438
00:17:33,220 --> 00:17:35,289
same query but with planned stitch

439
00:17:35,289 --> 00:17:38,049
because I can excise out sub plans or

440
00:17:38,049 --> 00:17:39,850
portions of the query plan as long as

441
00:17:39,850 --> 00:17:41,020
they know that they're logically

442
00:17:41,020 --> 00:17:43,059
equivalent I can take bits and pieces

443
00:17:43,059 --> 00:17:46,899
from from other queries alright the

444
00:17:46,899 --> 00:17:48,640
other thing too is that

445
00:17:48,640 --> 00:17:50,770
if there is a change in the physical

446
00:17:50,770 --> 00:17:52,540
design we're a new planet query plan

447
00:17:52,540 --> 00:17:55,570
becomes invalid meaning like it defined

448
00:17:55,570 --> 00:17:57,040
that it wouldn't do index scan but and

449
00:17:57,040 --> 00:17:59,020
then I drop that index rather than just

450
00:17:59,020 --> 00:18:01,450
getting thrown away the entire query the

451
00:18:01,450 --> 00:18:03,280
query planet in its entirety I could

452
00:18:03,280 --> 00:18:05,890
maybe in pull out pieces of it type so

453
00:18:05,890 --> 00:18:07,570
the basic approach they're going to use

454
00:18:07,570 --> 00:18:09,790
is or the way they're gonna generate

455
00:18:09,790 --> 00:18:13,360
these these stitch plans is a dynamic

456
00:18:13,360 --> 00:18:15,430
programming search method using a

457
00:18:15,430 --> 00:18:18,100
bottom-up approach where you just you

458
00:18:18,100 --> 00:18:20,050
check the see from going from one level

459
00:18:20,050 --> 00:18:21,220
to the next in the same way we do a

460
00:18:21,220 --> 00:18:23,620
system are going one one note of the

461
00:18:23,620 --> 00:18:26,770
next to pick which which which which sub

462
00:18:26,770 --> 00:18:28,720
plan is the best and then once you reach

463
00:18:28,720 --> 00:18:31,270
the end goal you you find that the

464
00:18:31,270 --> 00:18:33,550
cheapest path so this means that it's

465
00:18:33,550 --> 00:18:36,190
not guaranteed to find a better plan

466
00:18:36,190 --> 00:18:38,920
than the best plan you have so far and

467
00:18:38,920 --> 00:18:41,950
it is not guaranteed to always produce a

468
00:18:41,950 --> 00:18:46,300
battle plan and but there's some basic

469
00:18:46,300 --> 00:18:47,320
heuristic so you use to make sure that

470
00:18:47,320 --> 00:18:49,300
happens right so going back to our

471
00:18:49,300 --> 00:18:53,380
example here right say that this is our

472
00:18:53,380 --> 00:18:55,780
new plan and say it was working just

473
00:18:55,780 --> 00:18:57,430
fine right like it was actually faster

474
00:18:57,430 --> 00:18:59,590
so we always want to use this but now if

475
00:18:59,590 --> 00:19:01,540
I come along and I drop one of the

476
00:19:01,540 --> 00:19:03,970
indexes that I'm using this plan now

477
00:19:03,970 --> 00:19:07,600
becomes invalid and under just sort of

478
00:19:07,600 --> 00:19:08,740
coarse-grained reversion

479
00:19:08,740 --> 00:19:11,200
I can't reuse it but with plan stitching

480
00:19:11,200 --> 00:19:13,330
I actually want to figure out what

481
00:19:13,330 --> 00:19:15,610
components of this sub plan of the query

482
00:19:15,610 --> 00:19:17,680
plan here that I may want to use in the

483
00:19:17,680 --> 00:19:19,390
new plan even though overall it's

484
00:19:19,390 --> 00:19:20,980
invalid there's still portions that are

485
00:19:20,980 --> 00:19:23,260
that are still usable so in that state's

486
00:19:23,260 --> 00:19:24,760
case say or say this portion of the sub

487
00:19:24,760 --> 00:19:27,430
plan the the sub plan of this part of

488
00:19:27,430 --> 00:19:30,610
the query the extrusion cost is 600 and

489
00:19:30,610 --> 00:19:31,930
we would know this because we can keep

490
00:19:31,930 --> 00:19:35,200
track of every although the ratchet

491
00:19:35,200 --> 00:19:37,690
runtime cost of all the operators in art

492
00:19:37,690 --> 00:19:40,630
and aquarium and for this one here this

493
00:19:40,630 --> 00:19:43,420
sub plane over here has a cost of 150 so

494
00:19:43,420 --> 00:19:45,160
now if I combine these together into a

495
00:19:45,160 --> 00:19:47,410
stitch plan the total cost of this case

496
00:19:47,410 --> 00:19:51,040
would be 750 whereas before if I didn't

497
00:19:51,040 --> 00:19:53,110
run this it was a thousand so again the

498
00:19:53,110 --> 00:19:54,730
idea is that we want to be able to

499
00:19:54,730 --> 00:19:56,710
borrow bits and pieces of different

500
00:19:56,710 --> 00:19:59,590
query plans to and help us produce the a

501
00:19:59,590 --> 00:20:00,990
more optimal plan

502
00:20:00,990 --> 00:20:03,030
and this is being done separately from

503
00:20:03,030 --> 00:20:05,280
the the regular optimizer in the case of

504
00:20:05,280 --> 00:20:06,900
Microsoft's sequel server

505
00:20:06,900 --> 00:20:08,460
they're running cascade - they're

506
00:20:08,460 --> 00:20:10,470
actually doing a top-down search but

507
00:20:10,470 --> 00:20:12,420
this is sort of this auxilary search

508
00:20:12,420 --> 00:20:15,630
that's running on the side that in the

509
00:20:15,630 --> 00:20:17,970
background it tries to find a plans it

510
00:20:17,970 --> 00:20:20,580
can stitch together so let's talk about

511
00:20:20,580 --> 00:20:23,490
how they actually do this the the first

512
00:20:23,490 --> 00:20:25,260
step is you need to identify which

513
00:20:25,260 --> 00:20:27,390
portions are which what cell plans in

514
00:20:27,390 --> 00:20:30,020
our queries are logically equivalent

515
00:20:30,020 --> 00:20:32,970
right we talked about before under live

516
00:20:32,970 --> 00:20:34,740
Cascades when we have when he had multi

517
00:20:34,740 --> 00:20:36,990
group multi expression groups we want to

518
00:20:36,990 --> 00:20:41,490
know that the the the output of a given

519
00:20:41,490 --> 00:20:44,540
some plan is is the same or equivalent

520
00:20:44,540 --> 00:20:48,059
to another sub plan right and again we

521
00:20:48,059 --> 00:20:50,910
have to rely on our the rules of

522
00:20:50,910 --> 00:20:52,890
relational algebra to recognize which

523
00:20:52,890 --> 00:20:54,990
operations can be commutative or

524
00:20:54,990 --> 00:20:58,320
associative so in this case here this

525
00:20:58,320 --> 00:21:01,050
portion of the cell plan just the output

526
00:21:01,050 --> 00:21:04,410
is the a join be joined see this portion

527
00:21:04,410 --> 00:21:06,990
of another sub plan is the output is C

528
00:21:06,990 --> 00:21:09,960
join B's join a but since joins these

529
00:21:09,960 --> 00:21:12,030
inner joins here are commutative we know

530
00:21:12,030 --> 00:21:15,150
that these are logically equivalent now

531
00:21:15,150 --> 00:21:18,450
as I said the well one one challenge

532
00:21:18,450 --> 00:21:22,860
with this is that determining whether

533
00:21:22,860 --> 00:21:25,880
any arbitrary logical expressions or

534
00:21:25,880 --> 00:21:29,460
logical sub plans are equivalent has

535
00:21:29,460 --> 00:21:31,920
been shown to be undecidable meaning

536
00:21:31,920 --> 00:21:34,590
like it the questions like are these two

537
00:21:34,590 --> 00:21:36,480
cell plans logically equivalent it's

538
00:21:36,480 --> 00:21:39,000
it's a yes or no answer but there's no

539
00:21:39,000 --> 00:21:41,700
algorithm that exists as a been proven

540
00:21:41,700 --> 00:21:44,400
that can can be guaranteed to always

541
00:21:44,400 --> 00:21:47,280
give the correct answer so in the

542
00:21:47,280 --> 00:21:48,840
planned stitch phase they're gonna rely

543
00:21:48,840 --> 00:21:50,490
on some additional heuristics to

544
00:21:50,490 --> 00:21:52,980
identify things like oh I know that

545
00:21:52,980 --> 00:21:54,990
these two sub plans are accessing

546
00:21:54,990 --> 00:21:56,490
different tables so therefore they can't

547
00:21:56,490 --> 00:21:57,900
be logically equivalent right you

548
00:21:57,900 --> 00:21:59,690
obviously can do more complicated things

549
00:21:59,690 --> 00:22:02,640
the optimizer itself in sequel server

550
00:22:02,640 --> 00:22:05,059
also has those kind of checks in place

551
00:22:05,059 --> 00:22:08,220
and so they rely on that as well so they

552
00:22:08,220 --> 00:22:09,480
have their own heuristics to prune

553
00:22:09,480 --> 00:22:11,760
things that can never be logically

554
00:22:11,760 --> 00:22:13,800
equivalent and they rely on the sequel

555
00:22:13,800 --> 00:22:14,590
server optimizer

556
00:22:14,590 --> 00:22:19,480
identify that the logical sub plane

557
00:22:19,480 --> 00:22:21,070
you're trying to mash together or that

558
00:22:21,070 --> 00:22:22,090
the sub plane trying to match together

559
00:22:22,090 --> 00:22:26,919
in the stitch plan is is invalid so the

560
00:22:26,919 --> 00:22:28,600
heuristics are providing them with this

561
00:22:28,600 --> 00:22:31,419
sort of sweet spot balance between the

562
00:22:31,419 --> 00:22:33,669
difficulty in the implementation by it

563
00:22:33,669 --> 00:22:36,520
symmetry enforcer rules the accuracy of

564
00:22:36,520 --> 00:22:40,150
the of the determination whether they're

565
00:22:40,150 --> 00:22:41,650
equivalent and then the performance

566
00:22:41,650 --> 00:22:43,299
right it's not an exhaustive search and

567
00:22:43,299 --> 00:22:45,159
exhaust evaluation of all possible

568
00:22:45,159 --> 00:22:47,020
inputs to different cell plans

569
00:22:47,020 --> 00:22:50,230
it's just rules based on the relational

570
00:22:50,230 --> 00:22:53,169
algebra all right so now once we

571
00:22:53,169 --> 00:22:55,840
identify that we have a bunch of

572
00:22:55,840 --> 00:22:58,840
equivalent sub plans we want to figure

573
00:22:58,840 --> 00:23:00,580
out we want to sort of combine them

574
00:23:00,580 --> 00:23:03,850
together into one giant query plan that

575
00:23:03,850 --> 00:23:04,899
where you're going to add some

576
00:23:04,899 --> 00:23:08,140
additional operators to determine that

577
00:23:08,140 --> 00:23:09,520
you can have branches to go down

578
00:23:09,520 --> 00:23:11,559
different different paths in the sub

579
00:23:11,559 --> 00:23:13,659
plan so this is how they're going to

580
00:23:13,659 --> 00:23:16,299
encode the the all the different

581
00:23:16,299 --> 00:23:17,860
combinations of the sub plans for each

582
00:23:17,860 --> 00:23:20,289
stitch together so the way this is going

583
00:23:20,289 --> 00:23:21,220
to work is they're going to introduce

584
00:23:21,220 --> 00:23:23,529
this new or operator which is not

585
00:23:23,529 --> 00:23:25,870
actually used for execution this is just

586
00:23:25,870 --> 00:23:28,299
something for the search and the the or

587
00:23:28,299 --> 00:23:30,669
basically indicates that the sub plans

588
00:23:30,669 --> 00:23:35,200
below it are logically equivalent so we

589
00:23:35,200 --> 00:23:37,990
could choose either path so starting

590
00:23:37,990 --> 00:23:40,570
from the from the top we have an or

591
00:23:40,570 --> 00:23:43,029
clause at the very beginning and then we

592
00:23:43,029 --> 00:23:44,440
have the two for this particular query

593
00:23:44,440 --> 00:23:46,480
we have the you know doing the hash join

594
00:23:46,480 --> 00:23:49,270
or the the nested loop join and again

595
00:23:49,270 --> 00:23:50,320
these are logically equivalent because

596
00:23:50,320 --> 00:23:52,419
this is a joint B joint c.join D and

597
00:23:52,419 --> 00:23:55,630
this is C join B join a John D and those

598
00:23:55,630 --> 00:23:57,159
are in the joins are commutative so

599
00:23:57,159 --> 00:23:59,309
therefore these are logically equivalent

600
00:23:59,309 --> 00:24:02,529
so then now say go down we're gonna go

601
00:24:02,529 --> 00:24:04,690
like a depth-first search going down on

602
00:24:04,690 --> 00:24:07,750
this side for this one here the same

603
00:24:07,750 --> 00:24:09,370
thing we do the hash join on a and B

604
00:24:09,370 --> 00:24:11,380
followed by C this is the next loop

605
00:24:11,380 --> 00:24:14,230
joint on C followed by C join be join a

606
00:24:14,230 --> 00:24:16,480
again these are logically equivalent so

607
00:24:16,480 --> 00:24:17,770
that's why we have or clause we can

608
00:24:17,770 --> 00:24:19,600
choose either one and then we're gonna

609
00:24:19,600 --> 00:24:21,010
keep going down until we get to our leaf

610
00:24:21,010 --> 00:24:23,950
node in scheduled scan and then here we

611
00:24:23,950 --> 00:24:25,000
don't see we don't there's another

612
00:24:25,000 --> 00:24:27,620
option for us

613
00:24:27,620 --> 00:24:29,420
in in this portion of the query plan

614
00:24:29,420 --> 00:24:31,340
because the one we stitched from just

615
00:24:31,340 --> 00:24:33,380
you know only had only had a hash join

616
00:24:33,380 --> 00:24:35,809
so now in this case here for the hash

617
00:24:35,809 --> 00:24:38,210
donor a we can do a sequential scan as

618
00:24:38,210 --> 00:24:39,680
we saw on the first plan already knew

619
00:24:39,680 --> 00:24:41,870
the index scan on B because that came

620
00:24:41,870 --> 00:24:43,070
from the second plan and so we have an

621
00:24:43,070 --> 00:24:45,890
or operator to express that going back

622
00:24:45,890 --> 00:24:46,460
up here

623
00:24:46,460 --> 00:24:48,680
we can only do a sequential scan on C so

624
00:24:48,680 --> 00:24:50,450
that's a straight path coming back up

625
00:24:50,450 --> 00:24:53,090
here for the nested loop join it can you

626
00:24:53,090 --> 00:24:54,410
know only thing we knew below it is

627
00:24:54,410 --> 00:24:56,360
another nested loop join and then for

628
00:24:56,360 --> 00:24:57,410
this we can get either do a sequential

629
00:24:57,410 --> 00:25:00,410
scan on a or again for B we now to do

630
00:25:00,410 --> 00:25:01,870
the scheduled scan or the index scan

631
00:25:01,870 --> 00:25:04,040
going back up here for the hash join

632
00:25:04,040 --> 00:25:07,040
again we that's feeding a special scan

633
00:25:07,040 --> 00:25:08,960
on D feeding in and then we just

634
00:25:08,960 --> 00:25:11,030
complete the the rest of the tree like

635
00:25:11,030 --> 00:25:13,580
this so this is a bit more simplified

636
00:25:13,580 --> 00:25:14,960
version of what they showed in the paper

637
00:25:14,960 --> 00:25:18,020
but these are actually the possible

638
00:25:18,020 --> 00:25:22,340
options you can have and so what I think

639
00:25:22,340 --> 00:25:23,660
remember in the paper what they talked

640
00:25:23,660 --> 00:25:25,429
about is that this approach and doing

641
00:25:25,429 --> 00:25:27,440
the search within this define stitch

642
00:25:27,440 --> 00:25:29,809
plan that they're able to stitch about

643
00:25:29,809 --> 00:25:32,300
75 to almost a hundred cent of all the

644
00:25:32,300 --> 00:25:34,070
plans together but for the workloads of

645
00:25:34,070 --> 00:25:36,800
it they looked at alright so now that

646
00:25:36,800 --> 00:25:38,720
we've encoded our search space we

647
00:25:38,720 --> 00:25:40,340
actually want to do our search and this

648
00:25:40,340 --> 00:25:41,920
is just starting from the bottom and

649
00:25:41,920 --> 00:25:44,120
going up in the same way we did with the

650
00:25:44,120 --> 00:25:46,280
system our dynamic programming search

651
00:25:46,280 --> 00:25:48,890
where we just for every single leaf node

652
00:25:48,890 --> 00:25:51,410
we started off with figuring out what

653
00:25:51,410 --> 00:25:54,350
the cost is for going to the next

654
00:25:54,350 --> 00:25:56,300
operator we pick which one is the best

655
00:25:56,300 --> 00:25:58,760
and then once we complete all the we do

656
00:25:58,760 --> 00:25:59,840
this search for all the nodes at our

657
00:25:59,840 --> 00:26:01,340
current level we then go up to the next

658
00:26:01,340 --> 00:26:03,710
level and complete this process okay so

659
00:26:03,710 --> 00:26:05,120
the say we start with a central scan on

660
00:26:05,120 --> 00:26:07,610
a it only has one option first which is

661
00:26:07,610 --> 00:26:11,630
just the oh it has either a hash join an

662
00:26:11,630 --> 00:26:15,530
a B or or the the the necess

663
00:26:15,530 --> 00:26:17,480
that's a loop over here say the hash

664
00:26:17,480 --> 00:26:20,330
join is cheaper so we pick that now we

665
00:26:20,330 --> 00:26:22,309
just crunch will scan a B this has an or

666
00:26:22,309 --> 00:26:24,530
operator alright so this is either doing

667
00:26:24,530 --> 00:26:26,510
a hash join or the next loop join and

668
00:26:26,510 --> 00:26:28,309
say the hash join is cheaper so we pick

669
00:26:28,309 --> 00:26:31,850
that now we do this for the index kin on

670
00:26:31,850 --> 00:26:34,700
B again there's an or operator you need

671
00:26:34,700 --> 00:26:36,260
the rational in the nested loop join and

672
00:26:36,260 --> 00:26:40,070
so because we have an index the nested

673
00:26:40,070 --> 00:26:41,370
loop join actually would be cheaper

674
00:26:41,370 --> 00:26:43,410
we picked that and we just keep going

675
00:26:43,410 --> 00:26:45,180
down the line and do this for all our

676
00:26:45,180 --> 00:26:46,860
leaf nodes and then we're done we go up

677
00:26:46,860 --> 00:26:48,360
to the next level and then again now we

678
00:26:48,360 --> 00:26:51,150
have a cost for all these paths leading

679
00:26:51,150 --> 00:26:53,490
up and we just pick which one is is the

680
00:26:53,490 --> 00:26:56,040
cheapest for us and then we reconstruct

681
00:26:56,040 --> 00:27:00,420
the we struck the stitch plan that way

682
00:27:00,420 --> 00:27:03,420
right so I get I think this is an

683
00:27:03,420 --> 00:27:04,770
interesting approach

684
00:27:04,770 --> 00:27:07,050
I don't think Microsoft is actually

685
00:27:07,050 --> 00:27:08,460
running this in production like this was

686
00:27:08,460 --> 00:27:09,720
a research paper that was published in

687
00:27:09,720 --> 00:27:12,870
Sigma I don't know of any other system

688
00:27:12,870 --> 00:27:14,280
that's doing something similar like this

689
00:27:14,280 --> 00:27:17,790
I from an engineering standpoint the

690
00:27:17,790 --> 00:27:19,020
fact that you have to run this

691
00:27:19,020 --> 00:27:22,380
separately from the from the query

692
00:27:22,380 --> 00:27:25,170
optimizer and sort of have separate

693
00:27:25,170 --> 00:27:27,120
infrastructure for that tier what are

694
00:27:27,120 --> 00:27:29,390
you doing

695
00:27:31,490 --> 00:27:35,190
alright so rather than having you know

696
00:27:35,190 --> 00:27:36,690
separate so search infrastructure if

697
00:27:36,690 --> 00:27:38,040
there's an integrated into the query

698
00:27:38,040 --> 00:27:40,440
optimizer like a component itself I

699
00:27:40,440 --> 00:27:41,760
think this would be an interesting

700
00:27:41,760 --> 00:27:45,179
approach so there's another system that

701
00:27:45,179 --> 00:27:47,460
does something similar to this plan

702
00:27:47,460 --> 00:27:49,740
stitching but they're actually working

703
00:27:49,740 --> 00:27:54,480
on a sort of a sort of a cogent level

704
00:27:54,480 --> 00:27:55,890
rather than the called physical query

705
00:27:55,890 --> 00:27:58,800
plan level so amazon has their redshift

706
00:27:58,800 --> 00:28:02,610
data warehouse service and it's based on

707
00:28:02,610 --> 00:28:06,120
par Excel and they use actually a they

708
00:28:06,120 --> 00:28:08,730
do it's a translation engine so the

709
00:28:08,730 --> 00:28:11,100
database system for a given physical

710
00:28:11,100 --> 00:28:14,280
plan generates C++ code or C code which

711
00:28:14,280 --> 00:28:17,100
they then compile and then they run you

712
00:28:17,100 --> 00:28:19,260
know they invoke the the shared object

713
00:28:19,260 --> 00:28:20,820
that comes out of the compiler and then

714
00:28:20,820 --> 00:28:23,490
that's how they do query compilation so

715
00:28:23,490 --> 00:28:26,150
the obviously the most expensive part of

716
00:28:26,150 --> 00:28:28,830
you know cogent engine is the

717
00:28:28,830 --> 00:28:30,059
compilation right in their case they're

718
00:28:30,059 --> 00:28:31,860
actually forking GCC or whatever

719
00:28:31,860 --> 00:28:33,300
compiled using to actually generate the

720
00:28:33,300 --> 00:28:35,940
the machine code so they want to try to

721
00:28:35,940 --> 00:28:38,700
avoid that for every single query so

722
00:28:38,700 --> 00:28:41,429
what they can do is they say you're

723
00:28:41,429 --> 00:28:43,350
doing you want you want to compile the

724
00:28:43,350 --> 00:28:46,080
scan on B where you want to see what B

725
00:28:46,080 --> 00:28:48,510
Val equals some some input parameter so

726
00:28:48,510 --> 00:28:50,550
the coach and that piece run it through

727
00:28:50,550 --> 00:28:53,580
the compiler that generates x86 code and

728
00:28:53,580 --> 00:28:55,430
then they'll go ahead and cash it

729
00:28:55,430 --> 00:28:58,870
and then now anytime you reinvest weary

730
00:28:58,870 --> 00:29:02,120
you know you can just reuse the compiled

731
00:29:02,120 --> 00:29:05,000
version of the scan on beam but similar

732
00:29:05,000 --> 00:29:06,620
to plan stitching what they can also do

733
00:29:06,620 --> 00:29:08,540
is they can recognize that if you have

734
00:29:08,540 --> 00:29:10,550
another query with the same kind of

735
00:29:10,550 --> 00:29:13,790
predicate be davao equals you know some

736
00:29:13,790 --> 00:29:14,500
parameter

737
00:29:14,500 --> 00:29:17,180
it'll Co gen the exact same thing so

738
00:29:17,180 --> 00:29:19,400
rather than recompiling it which is

739
00:29:19,400 --> 00:29:20,990
again to extent the part they can

740
00:29:20,990 --> 00:29:23,930
identify that they have a cache plan

741
00:29:23,930 --> 00:29:27,590
fragment for this this scan here and

742
00:29:27,590 --> 00:29:30,350
they can reuse that and so they actually

743
00:29:30,350 --> 00:29:34,370
can do this across all possible or press

744
00:29:34,370 --> 00:29:36,440
all their customers so like this you

745
00:29:36,440 --> 00:29:39,560
know this scan on a table to do one you

746
00:29:39,560 --> 00:29:41,420
know something equals something on a bar

747
00:29:41,420 --> 00:29:43,760
chart field that's gonna be the same

748
00:29:43,760 --> 00:29:45,650
from one table to the next because it's

749
00:29:45,650 --> 00:29:47,240
a column sure sure you're just ripping

750
00:29:47,240 --> 00:29:48,860
through the column so they can actually

751
00:29:48,860 --> 00:29:52,070
share these little fragments and stitch

752
00:29:52,070 --> 00:29:53,780
these physical query plans of the

753
00:29:53,780 --> 00:29:55,670
compiled query plans together from all

754
00:29:55,670 --> 00:29:58,430
possible you know customers so now for a

755
00:29:58,430 --> 00:30:00,140
given query that they never seen before

756
00:30:00,140 --> 00:30:02,270
if it has the same pattern of access

757
00:30:02,270 --> 00:30:03,770
methods and joins and other things as

758
00:30:03,770 --> 00:30:05,960
queries from an another customer they

759
00:30:05,960 --> 00:30:07,340
just pull from the cogent cache and

760
00:30:07,340 --> 00:30:09,680
stitch it together so that's kind of

761
00:30:09,680 --> 00:30:10,870
cool

762
00:30:10,870 --> 00:30:13,880
alright so there another interesting

763
00:30:13,880 --> 00:30:17,360
system to talk about is ibm's leo the

764
00:30:17,360 --> 00:30:19,490
learning optimizer and so this is an

765
00:30:19,490 --> 00:30:21,320
example of where you have a feedback

766
00:30:21,320 --> 00:30:24,400
loop being used to improve the the

767
00:30:24,400 --> 00:30:26,480
accuracy of the cost models in the

768
00:30:26,480 --> 00:30:30,830
system i said the idea is that again if

769
00:30:30,830 --> 00:30:33,860
i I keep track of what my cost model

770
00:30:33,860 --> 00:30:35,210
estimates were when I want to generate

771
00:30:35,210 --> 00:30:37,610
the query plan and then when I run it if

772
00:30:37,610 --> 00:30:39,500
I recognize that those estimates are way

773
00:30:39,500 --> 00:30:42,020
off I start recording information about

774
00:30:42,020 --> 00:30:43,780
what I'm seeing in the real data and

775
00:30:43,780 --> 00:30:46,820
then when my quarry completes I return

776
00:30:46,820 --> 00:30:49,160
the result back to the the user or the

777
00:30:49,160 --> 00:30:50,750
application that requested a quest the

778
00:30:50,750 --> 00:30:53,620
query but I also go update my cost model

779
00:30:53,620 --> 00:30:55,820
assistive sixth with the new information

780
00:30:55,820 --> 00:30:59,090
that I've collected um so I BM is Leo

781
00:30:59,090 --> 00:31:00,980
was is actually shipped in production in

782
00:31:00,980 --> 00:31:04,070
db2 today but this is one of the earth

783
00:31:04,070 --> 00:31:06,170
examples of a commercial system do

784
00:31:06,170 --> 00:31:08,180
applying one of these debit query

785
00:31:08,180 --> 00:31:11,100
processing tech

786
00:31:11,100 --> 00:31:16,029
all right so the the plant stitching

787
00:31:16,029 --> 00:31:17,470
stuff that we talked about or the virgin

788
00:31:17,470 --> 00:31:21,909
stuff is about fixing future invocations

789
00:31:21,909 --> 00:31:24,909
of a query to improve them based on the

790
00:31:24,909 --> 00:31:26,619
results that I'm seeing when I when I

791
00:31:26,619 --> 00:31:28,389
actually execute my query but now we

792
00:31:28,389 --> 00:31:30,009
want to talk about how do we fix my

793
00:31:30,009 --> 00:31:33,009
query live up my sequel query and I

794
00:31:33,009 --> 00:31:35,320
determined that I have a bad plan what

795
00:31:35,320 --> 00:31:35,799
do I do

796
00:31:35,799 --> 00:31:37,419
all right how can I fix it because I

797
00:31:37,419 --> 00:31:38,499
don't want to wait for the next

798
00:31:38,499 --> 00:31:39,850
invocations I want to fix the one I have

799
00:31:39,850 --> 00:31:42,399
right now so I'm calling this the

800
00:31:42,399 --> 00:31:44,109
replaying the current invocation again

801
00:31:44,109 --> 00:31:45,909
the idea is that if I determined that

802
00:31:45,909 --> 00:31:48,850
the observed behavior of the query plan

803
00:31:48,850 --> 00:31:51,609
as I'm executing it is way off or

804
00:31:51,609 --> 00:31:53,799
divergent from what the estimated

805
00:31:53,799 --> 00:31:55,269
behavior was that the cost models

806
00:31:55,269 --> 00:31:58,739
produced then I can decide to

807
00:31:58,739 --> 00:32:01,779
potentially either stop the query and go

808
00:32:01,779 --> 00:32:03,789
back and generate a new plan or I can

809
00:32:03,789 --> 00:32:07,679
decide to maybe how much smelled

810
00:32:08,519 --> 00:32:10,389
recognize that I've already produced

811
00:32:10,389 --> 00:32:12,249
some work for me

812
00:32:12,249 --> 00:32:15,489
and keep that portion of the data that

813
00:32:15,489 --> 00:32:17,499
I've already processed and then return

814
00:32:17,499 --> 00:32:18,999
back to the optimizer and ask it to just

815
00:32:18,999 --> 00:32:21,190
just generate a sub plan so again you

816
00:32:21,190 --> 00:32:23,169
know just start with a scratch and you

817
00:32:23,169 --> 00:32:25,210
know you decide that continuing with the

818
00:32:25,210 --> 00:32:27,820
same query plan that I have now is gonna

819
00:32:27,820 --> 00:32:30,359
be worse than just starting over

820
00:32:30,359 --> 00:32:32,379
obviously if you're at the last to put

821
00:32:32,379 --> 00:32:33,909
the last operator then it's a bad idea

822
00:32:33,909 --> 00:32:36,279
just let it finish so striking right

823
00:32:36,279 --> 00:32:38,440
balance of this it's difficult and then

824
00:32:38,440 --> 00:32:40,090
the other approaches are determining

825
00:32:40,090 --> 00:32:42,730
that well I'm doing 100 joins and I've

826
00:32:42,730 --> 00:32:44,679
already done one of them let me keep

827
00:32:44,679 --> 00:32:46,720
that one that I have because I was

828
00:32:46,720 --> 00:32:48,700
expensive and then I'll replan the

829
00:32:48,700 --> 00:32:51,249
ordering for the other 99 and the whole

830
00:32:51,249 --> 00:32:52,929
idea here is that you're going back to

831
00:32:52,929 --> 00:32:55,179
the optimizer and saying hey generate

832
00:32:55,179 --> 00:32:59,200
generate me a new plan so let me give it

833
00:32:59,200 --> 00:33:01,269
a give of that so it does something sort

834
00:33:01,269 --> 00:33:04,330
of similar to like this so this is from

835
00:33:04,330 --> 00:33:06,700
Apache quick step quick step was it or

836
00:33:06,700 --> 00:33:10,899
is a embedded analytical engine sort of

837
00:33:10,899 --> 00:33:13,749
similar to duck TB but I don't think

838
00:33:13,749 --> 00:33:15,940
it's supported sequel it came out of

839
00:33:15,940 --> 00:33:18,950
unity Wisconsin and then it's been

840
00:33:18,950 --> 00:33:21,740
it's been turned over to the Apache

841
00:33:21,740 --> 00:33:22,490
foundation

842
00:33:22,490 --> 00:33:24,289
I think it's been kicked out of the

843
00:33:24,289 --> 00:33:25,370
incubator program because I don't think

844
00:33:25,370 --> 00:33:27,080
they've updated it recently I don't know

845
00:33:27,080 --> 00:33:28,519
what's going on with chicken ash and his

846
00:33:28,519 --> 00:33:30,500
team but I haven't really seen any

847
00:33:30,500 --> 00:33:32,149
updates in a while but they had this

848
00:33:32,149 --> 00:33:33,320
really interesting approach called

849
00:33:33,320 --> 00:33:36,169
look-ahead information passing where I

850
00:33:36,169 --> 00:33:39,320
can do some work at the beginning of my

851
00:33:39,320 --> 00:33:42,230
query and pass that along to other

852
00:33:42,230 --> 00:33:44,120
operators or other portions of my query

853
00:33:44,120 --> 00:33:46,779
plan and help me make a decision about

854
00:33:46,779 --> 00:33:49,190
what the right ordering is for for

855
00:33:49,190 --> 00:33:52,370
things up ahead so for this example say

856
00:33:52,370 --> 00:33:56,149
we have a simple data says three tables

857
00:33:56,149 --> 00:33:58,279
and so this would be a star schema so

858
00:33:58,279 --> 00:33:59,720
this this this approach only works for

859
00:33:59,720 --> 00:34:02,149
star schema we have a fact table in the

860
00:34:02,149 --> 00:34:03,559
middle and then you have dimension

861
00:34:03,559 --> 00:34:05,840
tables coming out of it right so it's

862
00:34:05,840 --> 00:34:08,480
not for arbitrary star schemas or

863
00:34:08,480 --> 00:34:10,429
arbitrary like treat tree based schemas

864
00:34:10,429 --> 00:34:13,969
so the way this is gonna work is say

865
00:34:13,969 --> 00:34:15,440
this is my sequel query like this I'm

866
00:34:15,440 --> 00:34:17,389
doing a three-way join between the fact

867
00:34:17,389 --> 00:34:19,460
table and the two dimension tables so

868
00:34:19,460 --> 00:34:22,929
what I'm gonna do is before I begin the

869
00:34:22,929 --> 00:34:25,969
before I start scanning the fact table

870
00:34:25,969 --> 00:34:27,409
and start computing the hash table of

871
00:34:27,409 --> 00:34:29,899
hash tables for my join I'm gonna scan

872
00:34:29,899 --> 00:34:32,449
through the dimension tables and

873
00:34:32,449 --> 00:34:35,239
generate a bloom filter we solved this

874
00:34:35,239 --> 00:34:36,679
similar technique being used when we

875
00:34:36,679 --> 00:34:38,480
talk about joins right this idea came

876
00:34:38,480 --> 00:34:40,310
from vector wise that you can generate a

877
00:34:40,310 --> 00:34:44,270
bloom filter and pass it along to to the

878
00:34:44,270 --> 00:34:46,389
other side the query plan so so that

879
00:34:46,389 --> 00:34:49,790
maybe avoid a hash table probe and we

880
00:34:49,790 --> 00:34:51,589
said this so the joins are gonna be on

881
00:34:51,589 --> 00:34:52,969
the dimension tables these are in front

882
00:34:52,969 --> 00:34:54,560
of the hash tables and the fact table is

883
00:34:54,560 --> 00:34:55,940
just gonna do a probe so I want to

884
00:34:55,940 --> 00:34:57,650
generate the bloom filter and then check

885
00:34:57,650 --> 00:34:59,930
the bloom filter to see whether the key

886
00:34:59,930 --> 00:35:01,310
I'm looking for can even exist in the

887
00:35:01,310 --> 00:35:02,839
hash table which is cheaper than doing

888
00:35:02,839 --> 00:35:05,540
the hash table probe but we're gonna do

889
00:35:05,540 --> 00:35:06,740
differently here is that we're actually

890
00:35:06,740 --> 00:35:08,390
gonna pass these bloom filters and when

891
00:35:08,390 --> 00:35:09,700
we pass it over here to the fact table

892
00:35:09,700 --> 00:35:14,150
we're going to start do some sampling to

893
00:35:14,150 --> 00:35:18,200
determine the selectivity of the of the

894
00:35:18,200 --> 00:35:20,900
of the different bloom filter so for

895
00:35:20,900 --> 00:35:22,880
these different tables and then if we

896
00:35:22,880 --> 00:35:26,750
determine that well the second second

897
00:35:26,750 --> 00:35:28,160
table here DeMint the second dimension

898
00:35:28,160 --> 00:35:30,470
table is actually more selective than

899
00:35:30,470 --> 00:35:32,780
the first one then I want to

900
00:35:32,780 --> 00:35:37,910
shuffle the reshuffle my joins so that I

901
00:35:37,910 --> 00:35:39,800
do that the probe on this hash table

902
00:35:39,800 --> 00:35:41,330
first because I'm gonna end up throwing

903
00:35:41,330 --> 00:35:43,790
away more tuples and we can do this

904
00:35:43,790 --> 00:35:44,810
before we actually start running

905
00:35:44,810 --> 00:35:47,390
anything because we've already got the

906
00:35:47,390 --> 00:35:48,800
hash tables we generate the bloom filter

907
00:35:48,800 --> 00:35:51,110
and we can make the decision before we

908
00:35:51,110 --> 00:35:53,240
start scanning and doing the probe so I

909
00:35:53,240 --> 00:35:54,710
think this is a really interesting idea

910
00:35:54,710 --> 00:35:56,330
as far as you know quickstep is the only

911
00:35:56,330 --> 00:35:58,490
one that does this and I don't know

912
00:35:58,490 --> 00:36:00,080
whether it actually made it into the

913
00:36:00,080 --> 00:36:04,390
open source version all right the last

914
00:36:04,390 --> 00:36:06,260
adapter query optimization techniques

915
00:36:06,260 --> 00:36:08,240
sort of category you want to talk about

916
00:36:08,240 --> 00:36:12,200
is what I call sort of plan pivot points

917
00:36:12,200 --> 00:36:14,780
and the idea here is that we want to

918
00:36:14,780 --> 00:36:17,990
introduce additional sub plans in our

919
00:36:17,990 --> 00:36:24,350
query and then have a have a sort of

920
00:36:24,350 --> 00:36:26,720
special synthetic operator that we put

921
00:36:26,720 --> 00:36:28,490
into our query plan that allows us to

922
00:36:28,490 --> 00:36:31,130
pivot or switch which query you know

923
00:36:31,130 --> 00:36:32,570
which path and that query plan we want

924
00:36:32,570 --> 00:36:36,760
to do and the idea here is that we can

925
00:36:36,760 --> 00:36:39,980
put conditions in our in the switch

926
00:36:39,980 --> 00:36:42,260
operator or the the change plan operator

927
00:36:42,260 --> 00:36:45,590
that if we determined that our data

928
00:36:45,590 --> 00:36:47,750
looks one way we'll go down one path if

929
00:36:47,750 --> 00:36:49,310
it looks another way what will go down

930
00:36:49,310 --> 00:36:51,830
another the other path it doesn't have

931
00:36:51,830 --> 00:36:54,380
to be - it can be multiple ones so the

932
00:36:54,380 --> 00:36:55,940
sort of two most famous techniques for

933
00:36:55,940 --> 00:36:57,620
doing this are parametric optimization

934
00:36:57,620 --> 00:36:59,240
in a proactive e opposition again in a

935
00:36:59,240 --> 00:37:00,290
high-level they're gonna work exactly

936
00:37:00,290 --> 00:37:01,970
the same way it's just the

937
00:37:01,970 --> 00:37:03,860
sophistication of their technique is

938
00:37:03,860 --> 00:37:06,920
slightly different so parametric

939
00:37:06,920 --> 00:37:08,900
optimization was actually developed in

940
00:37:08,900 --> 00:37:12,080
the late 1980s and in 1989 this actually

941
00:37:12,080 --> 00:37:14,090
came out of the volcano project again

942
00:37:14,090 --> 00:37:16,070
the same one that does the volcano query

943
00:37:16,070 --> 00:37:18,080
optimizer the volcano iterative model

944
00:37:18,080 --> 00:37:20,420
they also did early work on adaptive

945
00:37:20,420 --> 00:37:22,160
query opposition which is in as I'm

946
00:37:22,160 --> 00:37:24,500
saying that work is very influential so

947
00:37:24,500 --> 00:37:27,110
as I said the idea is that for each

948
00:37:27,110 --> 00:37:30,800
pipeline and a query that we think that

949
00:37:30,800 --> 00:37:31,880
the different alternatives we could have

950
00:37:31,880 --> 00:37:32,810
that would make a big performance

951
00:37:32,810 --> 00:37:35,150
difference well generate different sub

952
00:37:35,150 --> 00:37:37,970
plans for them and then now in our query

953
00:37:37,970 --> 00:37:39,920
will have this choose plan operator that

954
00:37:39,920 --> 00:37:41,990
basically has gonna an if clause that

955
00:37:41,990 --> 00:37:45,590
says if the cardinality of the operator

956
00:37:45,590 --> 00:37:46,670
below me looks

957
00:37:46,670 --> 00:37:49,400
way of a certain size then I want to

958
00:37:49,400 --> 00:37:51,440
choose the first plan if it looks

959
00:37:51,440 --> 00:37:53,299
another way then I'll choose this other

960
00:37:53,299 --> 00:37:56,299
plan right and in this case here if I

961
00:37:56,299 --> 00:37:58,760
know that my data is really small then

962
00:37:58,760 --> 00:38:00,349
maybe I want to do a nested loop joining

963
00:38:00,349 --> 00:38:01,250
because that's gonna be cheaper than

964
00:38:01,250 --> 00:38:04,420
having to build a hash table and probit

965
00:38:04,420 --> 00:38:07,579
but if my data's really big then I maybe

966
00:38:07,579 --> 00:38:10,069
want to do the hash Tron alright how do

967
00:38:10,069 --> 00:38:13,579
the hash run so again I think this is

968
00:38:13,579 --> 00:38:15,529
actually interesting idea of course

969
00:38:15,529 --> 00:38:16,789
obviously the the tricky thing is

970
00:38:16,789 --> 00:38:20,059
determining what this conditional in

971
00:38:20,059 --> 00:38:23,510
this condition should be and you know

972
00:38:23,510 --> 00:38:26,539
there's it's sort of through trial and

973
00:38:26,539 --> 00:38:27,740
error and as you develop the thing and

974
00:38:27,740 --> 00:38:28,849
it's actually very dependent also it

975
00:38:28,849 --> 00:38:31,760
won't be on the harbor but the nice

976
00:38:31,760 --> 00:38:33,140
thing about this is like there's nothing

977
00:38:33,140 --> 00:38:35,089
we end up like not having go back to the

978
00:38:35,089 --> 00:38:37,460
optimizer and sort of replaying

979
00:38:37,460 --> 00:38:40,730
everything the and we don't throw away

980
00:38:40,730 --> 00:38:41,859
any of the data that we've collected

981
00:38:41,859 --> 00:38:45,289
right so that we do this hash join and

982
00:38:45,289 --> 00:38:46,579
then we just determine whether we want

983
00:38:46,579 --> 00:38:49,569
to go down one path versus another a

984
00:38:49,569 --> 00:38:51,890
more recent sophisticated approach of

985
00:38:51,890 --> 00:38:53,119
this is called proactive reoptimize

986
00:38:53,119 --> 00:38:55,970
ation and this is actually combining the

987
00:38:55,970 --> 00:38:58,609
ability to go back to the optimizer and

988
00:38:58,609 --> 00:39:01,970
generate a new plan as well as to tweak

989
00:39:01,970 --> 00:39:03,859
it in the same way we saw in the

990
00:39:03,859 --> 00:39:05,390
previous example so they actually can do

991
00:39:05,390 --> 00:39:07,579
both and so at a high level it works

992
00:39:07,579 --> 00:39:10,250
like this so crazy shows up we gender

993
00:39:10,250 --> 00:39:11,059
through the optimizer

994
00:39:11,059 --> 00:39:13,029
and so we'll generate different

995
00:39:13,029 --> 00:39:15,319
different switchable plans just like

996
00:39:15,319 --> 00:39:17,420
before we're also gonna now gonna

997
00:39:17,420 --> 00:39:21,069
generate bounding boxes that allow us to

998
00:39:21,069 --> 00:39:24,079
determine whether the assumptions we're

999
00:39:24,079 --> 00:39:25,670
making in our decisions about whether go

1000
00:39:25,670 --> 00:39:27,230
down one path versus another we're

1001
00:39:27,230 --> 00:39:29,450
actually gonna match up with reality but

1002
00:39:29,450 --> 00:39:32,720
it's basically trying to put a bounds on

1003
00:39:32,720 --> 00:39:34,220
the uncertainty we're seeing in the data

1004
00:39:34,220 --> 00:39:37,490
as we run so now we start exiting the

1005
00:39:37,490 --> 00:39:40,339
query and just like before in in leo and

1006
00:39:40,339 --> 00:39:42,170
other techniques we exit query collects

1007
00:39:42,170 --> 00:39:43,430
as statistics about the data that we're

1008
00:39:43,430 --> 00:39:45,380
seeing for a particular query and then

1009
00:39:45,380 --> 00:39:47,660
we can switch the query plan just as we

1010
00:39:47,660 --> 00:39:50,390
saw before if we determine that you know

1011
00:39:50,390 --> 00:39:52,069
one plan path might be better than

1012
00:39:52,069 --> 00:39:54,019
another but then if you also determine

1013
00:39:54,019 --> 00:39:56,720
based on on our if we're exceeding our

1014
00:39:56,720 --> 00:39:59,119
estimations in our in our bounding box

1015
00:39:59,119 --> 00:40:00,260
thresholds

1016
00:40:00,260 --> 00:40:01,790
we see that we're way out of you know

1017
00:40:01,790 --> 00:40:05,240
way out of whack and our estimations are

1018
00:40:05,240 --> 00:40:07,340
way off then we just go back and can we

1019
00:40:07,340 --> 00:40:09,290
optimize and then you determine whether

1020
00:40:09,290 --> 00:40:11,990
to pin the portions of the query plan

1021
00:40:11,990 --> 00:40:13,040
that you've already executed because you

1022
00:40:13,040 --> 00:40:14,930
know they're expensive or you can just

1023
00:40:14,930 --> 00:40:17,950
say throw everything away and start over

1024
00:40:17,950 --> 00:40:20,570
so this is sort of getting a crash

1025
00:40:20,570 --> 00:40:23,140
course on a depth of query optimization

1026
00:40:23,140 --> 00:40:27,290
the I actually really like this these

1027
00:40:27,290 --> 00:40:29,120
techniques and there's for obvious

1028
00:40:29,120 --> 00:40:31,070
reasons right like it doesn't rely on

1029
00:40:31,070 --> 00:40:32,960
getting it right the very beginning like

1030
00:40:32,960 --> 00:40:35,480
you can even sort of correct yourself as

1031
00:40:35,480 --> 00:40:38,830
you're actually running the query so

1032
00:40:38,830 --> 00:40:41,360
well again we'll see a next class when

1033
00:40:41,360 --> 00:40:42,710
we talk about cost models of how bad

1034
00:40:42,710 --> 00:40:45,500
things can actually get but the way you

1035
00:40:45,500 --> 00:40:46,820
actually need to implement this is super

1036
00:40:46,820 --> 00:40:48,530
important that it's just not you know

1037
00:40:48,530 --> 00:40:50,300
you don't want to implement your

1038
00:40:50,300 --> 00:40:52,310
optimizer and your execution engine

1039
00:40:52,310 --> 00:40:54,260
completely separately from each other

1040
00:40:54,260 --> 00:40:55,880
it's sort of a symbiotic relationship

1041
00:40:55,880 --> 00:40:58,850
where you have to know what kind of

1042
00:40:58,850 --> 00:41:00,860
strategies could be employed by the

1043
00:41:00,860 --> 00:41:02,990
execution in the optimizer in terms of

1044
00:41:02,990 --> 00:41:04,520
like switching paths and throwing weight

1045
00:41:04,520 --> 00:41:06,320
interviewed results or not and then you

1046
00:41:06,320 --> 00:41:07,670
build your optimizer or you build

1047
00:41:07,670 --> 00:41:09,590
optimize around what your execution

1048
00:41:09,590 --> 00:41:12,710
engine can actually do so for this

1049
00:41:12,710 --> 00:41:16,610
reason I think like the I think applying

1050
00:41:16,610 --> 00:41:18,530
this technique for our using this

1051
00:41:18,530 --> 00:41:20,900
technique with sort of those optimizer

1052
00:41:20,900 --> 00:41:23,960
as a service like Orca or calcite could

1053
00:41:23,960 --> 00:41:25,400
actually tricky because there's

1054
00:41:25,400 --> 00:41:26,900
different approaches for how you can

1055
00:41:26,900 --> 00:41:28,790
actually support adapter query execution

1056
00:41:28,790 --> 00:41:34,580
in the system itself so the in addition

1057
00:41:34,580 --> 00:41:36,970
to having sort of more robust or more

1058
00:41:36,970 --> 00:41:40,270
more sophisticated query optimizers all

1059
00:41:40,270 --> 00:41:42,560
versus the open source one open source

1060
00:41:42,560 --> 00:41:44,600
systems all the major database vendors

1061
00:41:44,600 --> 00:41:46,870
now support this within the last

1062
00:41:46,870 --> 00:41:48,830
actually mostly in the last three or

1063
00:41:48,830 --> 00:41:50,630
four years like db2 had this Leo thing

1064
00:41:50,630 --> 00:41:53,600
in early 2000s but really in the last

1065
00:41:53,600 --> 00:41:56,990
three years about Oracle and sequel

1066
00:41:56,990 --> 00:41:59,480
server and now Teradata also included

1067
00:41:59,480 --> 00:42:00,860
the ability to do that the Cori

1068
00:42:00,860 --> 00:42:02,600
operation but it's best my knowledge

1069
00:42:02,600 --> 00:42:05,390
Postgres and my sequel simply can't do

1070
00:42:05,390 --> 00:42:07,030
this and none of this sort of the newer

1071
00:42:07,030 --> 00:42:08,990
open source systems that's come around

1072
00:42:08,990 --> 00:42:10,490
in the last decade support anything like

1073
00:42:10,490 --> 00:42:13,290
this so all right so

1074
00:42:13,290 --> 00:42:14,760
again this was just sort of to show you

1075
00:42:14,760 --> 00:42:15,930
that you don't have to build the

1076
00:42:15,930 --> 00:42:17,820
optimizer the way we described it where

1077
00:42:17,820 --> 00:42:19,470
you sort of plan once and run it through

1078
00:42:19,470 --> 00:42:21,120
our techniques to actually modify the

1079
00:42:21,120 --> 00:42:22,740
query while it's running and they get

1080
00:42:22,740 --> 00:42:24,540
feedback from execution and put it into

1081
00:42:24,540 --> 00:42:28,200
the system tier with doing all right

1082
00:42:28,200 --> 00:42:31,410
sorry um so next class will then start

1083
00:42:31,410 --> 00:42:34,890
discussing how how cost models work and

1084
00:42:34,890 --> 00:42:39,530
we'll see why they're so bad okay guys

1085
00:42:39,530 --> 00:42:41,080
what is

1086
00:42:41,080 --> 00:43:03,409
[Music]

1087
00:43:05,460 --> 00:43:08,099
won't be the same I've diced you take a

1088
00:43:08,099 --> 00:43:11,390
sake to the player

