1
00:00:01,300 --> 00:00:05,129
[Music]

2
00:00:05,200 --> 00:00:05,930
[Applause]

3
00:00:05,930 --> 00:00:08,630
[Music]

4
00:00:08,630 --> 00:00:10,020
[Applause]

5
00:00:10,020 --> 00:00:11,900
[Music]

6
00:00:11,900 --> 00:00:14,700
for today's class I've gone back and

7
00:00:14,700 --> 00:00:16,079
forth three or four times and what I

8
00:00:16,079 --> 00:00:18,180
want to call this lecture like it was

9
00:00:18,180 --> 00:00:19,529
originally I think just old to be

10
00:00:19,529 --> 00:00:21,720
indexes lat free data structures then I

11
00:00:21,720 --> 00:00:22,800
switched it to be plus tree data

12
00:00:22,800 --> 00:00:24,570
structures and then as of last night I

13
00:00:24,570 --> 00:00:26,039
said let's call it whole key data

14
00:00:26,039 --> 00:00:27,720
structures and then I'll make more set

15
00:00:27,720 --> 00:00:30,990
more sense and a few more slides but the

16
00:00:30,990 --> 00:00:32,610
main idea here is just like we're just

17
00:00:32,610 --> 00:00:34,200
talking meant what kind of indexes or

18
00:00:34,200 --> 00:00:36,030
data structures we could build or use

19
00:00:36,030 --> 00:00:40,620
for doing for all GP workloads the other

20
00:00:40,620 --> 00:00:41,700
thing that I forgot to mention when

21
00:00:41,700 --> 00:00:44,460
Piazza because they were later and gave

22
00:00:44,460 --> 00:00:46,700
me the information there actually is a

23
00:00:46,700 --> 00:00:49,379
visitor today from snowflake coming to

24
00:00:49,379 --> 00:00:52,739
give a talk at 4:30 on the query

25
00:00:52,739 --> 00:00:54,980
optimizer in snowflake snowflake is a

26
00:00:54,980 --> 00:00:58,399
one of the biggest sort of OLAP cloud

27
00:00:58,399 --> 00:01:00,989
database vendors davis is a service i

28
00:01:00,989 --> 00:01:02,609
competitor to be something like google's

29
00:01:02,609 --> 00:01:06,570
bigquery or amazon's redshift and so

30
00:01:06,570 --> 00:01:09,060
beau way is actually a former student of

31
00:01:09,060 --> 00:01:09,930
mine here at CMU

32
00:01:09,930 --> 00:01:12,720
he took 721 like you guys started

33
00:01:12,720 --> 00:01:14,340
working in the query optimizer people

34
00:01:14,340 --> 00:01:16,920
could not hire him fast enough so he's

35
00:01:16,920 --> 00:01:18,509
been a snowflake for two years now and

36
00:01:18,509 --> 00:01:20,220
he loves it so they'll give a talk today

37
00:01:20,220 --> 00:01:21,720
about the kind of stuff they're doing in

38
00:01:21,720 --> 00:01:23,729
the query optimizer at 4:30 so by all

39
00:01:23,729 --> 00:01:25,229
means please come to this and I'll I'll

40
00:01:25,229 --> 00:01:27,780
send a reminder on Piazza ok everyone's

41
00:01:27,780 --> 00:01:28,520
invited

42
00:01:28,520 --> 00:01:31,530
but wait I think there's a summer

43
00:01:31,530 --> 00:01:33,479
recruiting event and campus this week

44
00:01:33,479 --> 00:01:35,670
guy I forget why he's here what's

45
00:01:35,670 --> 00:01:39,720
tomorrow with that ok so he's here for

46
00:01:39,720 --> 00:01:43,079
that but like I said if you take this

47
00:01:43,079 --> 00:01:45,390
class many ways the things that you'll

48
00:01:45,390 --> 00:01:47,100
learn from this will help you get know

49
00:01:47,100 --> 00:01:48,869
past the interviews various data to

50
00:01:48,869 --> 00:01:51,270
companies and so boy I can tell you

51
00:01:51,270 --> 00:01:52,380
whether that's true or not cuz he's been

52
00:01:52,380 --> 00:01:53,369
it you know he's been uh something like

53
00:01:53,369 --> 00:01:57,420
for a while ok all right so as I said at

54
00:01:57,420 --> 00:01:59,399
the beginning I debated back and forth

55
00:01:59,399 --> 00:02:02,159
what I want to call this lecture and

56
00:02:02,159 --> 00:02:05,250
whole key is kind of not exactly true

57
00:02:05,250 --> 00:02:07,049
but the main thing I want to try to

58
00:02:07,049 --> 00:02:09,598
distinguish is the things we'll talk

59
00:02:09,598 --> 00:02:10,770
about today versus what we're going to

60
00:02:10,770 --> 00:02:13,770
talk about on on Wednesdays class

61
00:02:13,770 --> 00:02:16,050
so this is also in quotes because this

62
00:02:16,050 --> 00:02:17,520
is my term I don't think this is

63
00:02:17,520 --> 00:02:19,380
actually what this is not standard

64
00:02:19,380 --> 00:02:21,870
standard vernacular I don't know what

65
00:02:21,870 --> 00:02:23,970
they say an information theory but this

66
00:02:23,970 --> 00:02:25,400
is this is what I'm using just to

67
00:02:25,400 --> 00:02:28,110
contrast the two by whole key I mean

68
00:02:28,110 --> 00:02:30,120
that we're have a data structure where

69
00:02:30,120 --> 00:02:32,310
it's gonna be ordered reserving so we

70
00:02:32,310 --> 00:02:33,810
want to make sure we can keep track of

71
00:02:33,810 --> 00:02:35,130
you know whether one key is less than

72
00:02:35,130 --> 00:02:36,780
another key and that we're going to

73
00:02:36,780 --> 00:02:38,850
store all the digits of that key

74
00:02:38,850 --> 00:02:41,850
together in the various parts of its

75
00:02:41,850 --> 00:02:44,010
representation inside of the the data

76
00:02:44,010 --> 00:02:46,260
structure so what I mean that is if I

77
00:02:46,260 --> 00:02:49,170
have a key ABC I could have in in my

78
00:02:49,170 --> 00:02:51,510
leaf node I could have Kiki ABC together

79
00:02:51,510 --> 00:02:53,460
and now if I want to do comparison see

80
00:02:53,460 --> 00:02:55,110
where the my key is less than a greater

81
00:02:55,110 --> 00:02:57,600
than or equal to that given key I I have

82
00:02:57,600 --> 00:02:59,280
all the contents of the key right there

83
00:02:59,280 --> 00:03:01,710
that's not entirely true when you start

84
00:03:01,710 --> 00:03:04,170
doing some compression techniques but

85
00:03:04,170 --> 00:03:05,640
for our purposes today we can assume

86
00:03:05,640 --> 00:03:10,020
that's the case all right and then on on

87
00:03:10,020 --> 00:03:11,400
Wednesdays class we'll talk about what

88
00:03:11,400 --> 00:03:12,840
I'll call partial key data structures or

89
00:03:12,840 --> 00:03:15,600
tries where you actually break up the

90
00:03:15,600 --> 00:03:17,760
digits of a key and store them

91
00:03:17,760 --> 00:03:19,170
separately inside the nodes inside the

92
00:03:19,170 --> 00:03:21,360
data structure right so one way to think

93
00:03:21,360 --> 00:03:27,000
about this is like with this approach so

94
00:03:27,000 --> 00:03:28,980
with this approach you the partial key

95
00:03:28,980 --> 00:03:31,050
like you may have to do less work to

96
00:03:31,050 --> 00:03:32,220
find whether something that you matches

97
00:03:32,220 --> 00:03:33,840
amantha store less data potentially as

98
00:03:33,840 --> 00:03:37,080
well to represent all the keys in your

99
00:03:37,080 --> 00:03:40,470
in your data structure but you may have

100
00:03:40,470 --> 00:03:42,150
to still go out and look at the original

101
00:03:42,150 --> 00:03:44,430
tuple or the original record to see what

102
00:03:44,430 --> 00:03:46,080
was the original key that you're doing a

103
00:03:46,080 --> 00:03:47,490
canoe and look up long because it may

104
00:03:47,490 --> 00:03:49,650
not all be contained in the tree whereas

105
00:03:49,650 --> 00:03:52,350
in the the whole key you know key ABC

106
00:03:52,350 --> 00:03:54,780
exists in the tuple key ABC will exist

107
00:03:54,780 --> 00:03:56,520
in in the data structure

108
00:03:56,520 --> 00:03:58,710
okay so again this will make more sense

109
00:03:58,710 --> 00:04:01,170
as we go along I think I contrasting it

110
00:04:01,170 --> 00:04:03,600
with with with Wednesday's lecture but

111
00:04:03,600 --> 00:04:04,710
for our purposes today we just assume

112
00:04:04,710 --> 00:04:07,460
that we're dealing with B plus trees so

113
00:04:07,460 --> 00:04:09,810
today I understand most of the time

114
00:04:09,810 --> 00:04:11,670
talking about the BW tree because that

115
00:04:11,670 --> 00:04:12,900
was the assigned reading and that's the

116
00:04:12,900 --> 00:04:15,150
current data structure we use in our in

117
00:04:15,150 --> 00:04:18,060
our database system today and part of

118
00:04:18,060 --> 00:04:19,470
the reason I want to have you guys read

119
00:04:19,470 --> 00:04:23,669
this is because it is exposure to how

120
00:04:23,669 --> 00:04:25,590
you actually want to build a lat tree

121
00:04:25,590 --> 00:04:27,230
data structure lacks flash

122
00:04:27,230 --> 00:04:29,000
B+ tree right you may if you read on

123
00:04:29,000 --> 00:04:30,950
Hacker News or we don't own the Internet

124
00:04:30,950 --> 00:04:32,270
you may think people saying like oh

125
00:04:32,270 --> 00:04:33,680
these lats read data structures relax

126
00:04:33,680 --> 00:04:35,750
that tree algorithms are superior to one

127
00:04:35,750 --> 00:04:37,280
that do use latches and you always want

128
00:04:37,280 --> 00:04:38,600
to be using the latter II data structure

129
00:04:38,600 --> 00:04:40,850
and I certainly thought that was the

130
00:04:40,850 --> 00:04:42,200
case when we first started building our

131
00:04:42,200 --> 00:04:44,420
own BW tree but the paper you guys read

132
00:04:44,420 --> 00:04:47,390
basically shows that you don't so before

133
00:04:47,390 --> 00:04:49,100
we get there though I want to provide

134
00:04:49,100 --> 00:04:50,660
some historical background of what kind

135
00:04:50,660 --> 00:04:51,980
of data structures people built

136
00:04:51,980 --> 00:04:54,320
originally for in memory memory

137
00:04:54,320 --> 00:04:56,420
databases and particularly the tea tree

138
00:04:56,420 --> 00:04:58,340
and then we'll also then finish up how

139
00:04:58,340 --> 00:05:00,290
to actually then take a regular P Plus

140
00:05:00,290 --> 00:05:01,970
tree as we described in the introduction

141
00:05:01,970 --> 00:05:04,400
class and maybe do something a bit

142
00:05:04,400 --> 00:05:06,830
smarter and how we do latching right and

143
00:05:06,830 --> 00:05:08,780
that's how when you read that paper when

144
00:05:08,780 --> 00:05:10,400
you see the B+ tree beat the BW treaty

145
00:05:10,400 --> 00:05:11,990
so everybody using this last last

146
00:05:11,990 --> 00:05:16,370
technique here okay all right so back in

147
00:05:16,370 --> 00:05:19,570
the day in 1970s before we were all born

148
00:05:19,570 --> 00:05:22,670
they mentioned the B+ tree

149
00:05:22,670 --> 00:05:25,010
and at the time since they were dealing

150
00:05:25,010 --> 00:05:27,290
with discs going to databases and discs

151
00:05:27,290 --> 00:05:30,740
was super slow the B+ tree turn out to

152
00:05:30,740 --> 00:05:33,350
be a a well-designed data structure to

153
00:05:33,350 --> 00:05:36,260
allow you to efficient access for long

154
00:05:36,260 --> 00:05:38,900
strides of sequential sequential data so

155
00:05:38,900 --> 00:05:41,840
I trust the tree died in log n time in I

156
00:05:41,840 --> 00:05:44,510
land on my leaf node and I scan along

157
00:05:44,510 --> 00:05:46,610
the leaf nodes until I find the key to

158
00:05:46,610 --> 00:05:48,740
looking for all right so that's

159
00:05:48,740 --> 00:05:50,330
fantastic right again if this is slow

160
00:05:50,330 --> 00:05:53,060
scruncher weeds are faster than random

161
00:05:53,060 --> 00:05:55,400
reads this this this approach was

162
00:05:55,400 --> 00:05:59,320
perfect for it so then in the 1980s

163
00:05:59,320 --> 00:06:02,140
there's some early work done on

164
00:06:02,140 --> 00:06:05,120
designing the first Mme databases and in

165
00:06:05,120 --> 00:06:06,830
that world you don't have a slow disk

166
00:06:06,830 --> 00:06:10,340
you have fast random i/o in memory so

167
00:06:10,340 --> 00:06:12,200
the idea what they were looking into was

168
00:06:12,200 --> 00:06:15,500
can we build a it you know is there an

169
00:06:15,500 --> 00:06:16,940
alternative data structure we want to

170
00:06:16,940 --> 00:06:19,190
use instead of a B+ tree that would be

171
00:06:19,190 --> 00:06:22,700
preferable and more efficient for a in

172
00:06:22,700 --> 00:06:25,850
memory databases and so the the most

173
00:06:25,850 --> 00:06:27,260
famous one that came out of this work

174
00:06:27,260 --> 00:06:30,620
was called the Tea Tree so Tea Tree is

175
00:06:30,620 --> 00:06:32,330
gonna look like an AVL tree basically

176
00:06:32,330 --> 00:06:34,610
just means that instead of having you're

177
00:06:34,610 --> 00:06:36,950
looking at B+ tree where the the keys

178
00:06:36,950 --> 00:06:39,560
always exist on the leaf nodes and then

179
00:06:39,560 --> 00:06:40,760
the inner nodes are just gone

180
00:06:40,760 --> 00:06:41,990
posta to tell me to tell you whether

181
00:06:41,990 --> 00:06:44,120
goes left to right in the inn and the

182
00:06:44,120 --> 00:06:46,490
tea tree the keys gonna be scattered all

183
00:06:46,490 --> 00:06:47,630
throughout the different notes with the

184
00:06:47,630 --> 00:06:50,000
leaf nodes and the inter notes but the

185
00:06:50,000 --> 00:06:52,040
big way the big difference between us

186
00:06:52,040 --> 00:06:53,990
treating and the tea tree is that

187
00:06:53,990 --> 00:06:56,840
instead of throwing the keys in all the

188
00:06:56,840 --> 00:06:58,940
nodes like copies of the keys in all the

189
00:06:58,940 --> 00:07:02,540
nodes there instead disgust reporters to

190
00:07:02,540 --> 00:07:04,250
the original wreckers the two Plzen

191
00:07:04,250 --> 00:07:07,310
cells and the idea here was back in the

192
00:07:07,310 --> 00:07:08,990
1980s when memory was quite limited

193
00:07:08,990 --> 00:07:11,210
instead of storing redundant copies of

194
00:07:11,210 --> 00:07:13,040
the keys like in a whole key B plus tree

195
00:07:13,040 --> 00:07:15,710
if we destroyed the pointers then that's

196
00:07:15,710 --> 00:07:18,650
way more efficient in terms of memory so

197
00:07:18,650 --> 00:07:20,000
yes we paid that penalty of doing that

198
00:07:20,000 --> 00:07:22,070
lookup to say we know for this pointer

199
00:07:22,070 --> 00:07:23,330
what's the actual key that corresponds

200
00:07:23,330 --> 00:07:25,610
to that tuple but again that reduces the

201
00:07:25,610 --> 00:07:29,330
amount of total size of the index so the

202
00:07:29,330 --> 00:07:32,690
tea tree was originally posed in 1986 by

203
00:07:32,690 --> 00:07:35,870
the universe University Wisconsin I was

204
00:07:35,870 --> 00:07:37,250
Mike Carey in his group of doing a lot

205
00:07:37,250 --> 00:07:38,870
of early work in memory databases of the

206
00:07:38,870 --> 00:07:42,830
1980s and in the 1990s when people

207
00:07:42,830 --> 00:07:44,540
started building the first in memory

208
00:07:44,540 --> 00:07:47,120
databases the commercial ones like small

209
00:07:47,120 --> 00:07:49,340
base out of HP which became times 10

210
00:07:49,340 --> 00:07:51,020
that Oracle bought and it's still around

211
00:07:51,020 --> 00:07:54,860
today you know these first early in

212
00:07:54,860 --> 00:07:56,120
memory data businesses actually used the

213
00:07:56,120 --> 00:07:59,900
T to design so one key aspect of why tea

214
00:07:59,900 --> 00:08:02,120
trees actually worked back then was that

215
00:08:02,120 --> 00:08:05,150
the difference in speed between CPU

216
00:08:05,150 --> 00:08:08,720
caches and and and DRAM was not as

217
00:08:08,720 --> 00:08:11,120
significant as it is now all right so

218
00:08:11,120 --> 00:08:12,440
back then if I if I had at the cache

219
00:08:12,440 --> 00:08:13,550
miss and had to go read something in

220
00:08:13,550 --> 00:08:15,860
memory that you know in the teaching

221
00:08:15,860 --> 00:08:16,850
role in the nineteen eighties that

222
00:08:16,850 --> 00:08:18,920
wasn't that big of a deal so it was okay

223
00:08:18,920 --> 00:08:20,570
to follow that pointer right because you

224
00:08:20,570 --> 00:08:22,580
know it wasn't a big performance penalty

225
00:08:22,580 --> 00:08:25,270
and you saved a lot of space in the in

226
00:08:25,270 --> 00:08:29,600
the in the data structure itself right

227
00:08:29,600 --> 00:08:33,140
so I've been teaching tea trees because

228
00:08:33,140 --> 00:08:34,099
I think they're fascinating and there's

229
00:08:34,099 --> 00:08:35,419
not a lot of there is a Wikipedia

230
00:08:35,419 --> 00:08:37,760
article about them and as I said time

231
00:08:37,760 --> 00:08:40,099
stands still uses them today but default

232
00:08:40,099 --> 00:08:41,539
though like you get if you create a

233
00:08:41,539 --> 00:08:43,909
table or index in times 10 you get a B+

234
00:08:43,909 --> 00:08:45,680
tree you can pass a flag to force to get

235
00:08:45,680 --> 00:08:47,270
a tea tree but there's very few

236
00:08:47,270 --> 00:08:48,620
databases that still use tea tree

237
00:08:48,620 --> 00:08:50,270
today's they're mostly for like embedded

238
00:08:50,270 --> 00:08:52,510
devices running like extreme low memory

239
00:08:52,510 --> 00:08:55,150
environments so there really isn't that

240
00:08:55,150 --> 00:08:56,920
much information about them so I always

241
00:08:56,920 --> 00:08:58,090
like to talk about them because I think

242
00:08:58,090 --> 00:08:59,950
I think they're kind of fascinating and

243
00:08:59,950 --> 00:09:01,900
it turns out the guy that actually

244
00:09:01,900 --> 00:09:03,550
invented it sent me an e-mail at last

245
00:09:03,550 --> 00:09:05,020
month and just say hey look I see you're

246
00:09:05,020 --> 00:09:07,960
talking about tea trees and the mistake

247
00:09:07,960 --> 00:09:09,850
I always made was I said oh it's called

248
00:09:09,850 --> 00:09:11,770
a tea because the the note looks like a

249
00:09:11,770 --> 00:09:14,650
tea but he tells me I'm wrong and so the

250
00:09:14,650 --> 00:09:16,270
guy's name is Toby Lehman he got his PhD

251
00:09:16,270 --> 00:09:19,120
at University Wisconsin I he named it

252
00:09:19,120 --> 00:09:21,610
after himself so the tea and tea tree is

253
00:09:21,610 --> 00:09:24,220
Toby which i think is awesome so now the

254
00:09:24,220 --> 00:09:27,370
for a B+ tree right we always say oh the

255
00:09:27,370 --> 00:09:29,920
B means balanced he says that it

256
00:09:29,920 --> 00:09:31,270
actually just means it's named after

257
00:09:31,270 --> 00:09:33,100
himself the Rudy Bey or the guy that did

258
00:09:33,100 --> 00:09:34,810
the original work he just called it be

259
00:09:34,810 --> 00:09:36,460
for himself I don't know whether that's

260
00:09:36,460 --> 00:09:38,830
true but tea tea and tea tree means Toby

261
00:09:38,830 --> 00:09:40,390
which is awesome and he points out some

262
00:09:40,390 --> 00:09:41,620
other organizations that I'll talk about

263
00:09:41,620 --> 00:09:44,050
in a second so again this is why I love

264
00:09:44,050 --> 00:09:45,790
the Internet because I've never met this

265
00:09:45,790 --> 00:09:47,530
guy I actually know who he is he just

266
00:09:47,530 --> 00:09:48,970
found the YouTube video and he sent me

267
00:09:48,970 --> 00:09:49,990
an email hey that you're wrong about

268
00:09:49,990 --> 00:09:51,910
some things which is fantastic okay so

269
00:09:51,910 --> 00:09:53,410
here's here's what the data truck looks

270
00:09:53,410 --> 00:09:55,210
like again I always thought because it

271
00:09:55,210 --> 00:09:57,580
was the the nose look like look like t's

272
00:09:57,580 --> 00:10:00,070
and that's why they call my tea tree but

273
00:10:00,070 --> 00:10:02,770
that's not the case so what does the

274
00:10:02,770 --> 00:10:04,900
node actually look like so the nodes me

275
00:10:04,900 --> 00:10:07,330
a combination of pointers and then just

276
00:10:07,330 --> 00:10:10,000
two keys so the first thing we'd have

277
00:10:10,000 --> 00:10:11,590
here these are the data pointers and

278
00:10:11,590 --> 00:10:13,870
these are gonna point out now out to the

279
00:10:13,870 --> 00:10:16,570
actual table and a correspond to the to

280
00:10:16,570 --> 00:10:18,160
the tuples that they represent all right

281
00:10:18,160 --> 00:10:19,600
so this is our data table these are the

282
00:10:19,600 --> 00:10:21,610
keys so these are just pointers to two

283
00:10:21,610 --> 00:10:23,650
different keys right or to the original

284
00:10:23,650 --> 00:10:26,320
to post so these pointers will be sorted

285
00:10:26,320 --> 00:10:28,150
in the order of the keys that are stored

286
00:10:28,150 --> 00:10:30,520
in the data table right so now I keep

287
00:10:30,520 --> 00:10:32,560
again I can do that binary search that I

288
00:10:32,560 --> 00:10:34,780
would normally do in a B+ tree to jump

289
00:10:34,780 --> 00:10:36,670
around to find the the entry that I'm

290
00:10:36,670 --> 00:10:38,050
looking for but any single time I need

291
00:10:38,050 --> 00:10:39,940
you to comparison like is my key equal

292
00:10:39,940 --> 00:10:41,050
to this key or less than a greater than

293
00:10:41,050 --> 00:10:43,690
I gotta follow the pointer to get to the

294
00:10:43,690 --> 00:10:44,890
original tuple to figure out what the

295
00:10:44,890 --> 00:10:48,520
original key was all right okay in a

296
00:10:48,520 --> 00:10:51,820
modern system I our pointers are 64 bits

297
00:10:51,820 --> 00:10:54,250
in the actuality they're 48 bits but but

298
00:10:54,250 --> 00:10:56,410
you have to allocate a 64 bit 64-bit

299
00:10:56,410 --> 00:10:59,200
pointers space back then you know these

300
00:10:59,200 --> 00:11:01,540
things were I think probably 16 bits and

301
00:11:01,540 --> 00:11:04,030
the values neighbor 16 bits so by not

302
00:11:04,030 --> 00:11:06,100
having store the key plus the the

303
00:11:06,100 --> 00:11:07,900
pointer back to the key right I can

304
00:11:07,900 --> 00:11:08,980
reduce the size

305
00:11:08,980 --> 00:11:12,670
of the amount of states had the story

306
00:11:12,670 --> 00:11:15,940
nice knowed by half right the other

307
00:11:15,940 --> 00:11:17,620
thing would have now is also these data

308
00:11:17,620 --> 00:11:20,410
pointers so unlike in a B+ tree where

309
00:11:20,410 --> 00:11:22,300
you normally only have the pointer to

310
00:11:22,300 --> 00:11:24,850
either your child or any sibling if

311
00:11:24,850 --> 00:11:28,060
you're a leaf node in a tea tree you

312
00:11:28,060 --> 00:11:29,520
have to have pointer back to your parent

313
00:11:29,520 --> 00:11:31,750
because the leaf nodes aren't going to

314
00:11:31,750 --> 00:11:33,220
be the final location of keys we may

315
00:11:33,220 --> 00:11:34,720
have to reverse backups we need have a

316
00:11:34,720 --> 00:11:37,360
pointer to go back there and then we we

317
00:11:37,360 --> 00:11:38,380
have pointers to the right and left

318
00:11:38,380 --> 00:11:41,410
child then we have our node boundary

319
00:11:41,410 --> 00:11:43,690
keys and this will just be the min and

320
00:11:43,690 --> 00:11:46,870
Max value of the key that's represented

321
00:11:46,870 --> 00:11:50,110
by this node and so anything that is

322
00:11:50,110 --> 00:11:52,630
less than this key will be found on this

323
00:11:52,630 --> 00:11:54,070
side of the tree anything that's great

324
00:11:54,070 --> 00:11:55,150
in that key will be found on the other

325
00:11:55,150 --> 00:11:57,730
side right so this is not like how does

326
00:11:57,730 --> 00:12:01,240
his it's not like in a in a and a B plus

327
00:12:01,240 --> 00:12:03,310
tree where the root node would have you

328
00:12:03,310 --> 00:12:04,660
know the right and left boundary would

329
00:12:04,660 --> 00:12:07,300
be sort of encompass most of the space

330
00:12:07,300 --> 00:12:09,220
below you in the key space right this is

331
00:12:09,220 --> 00:12:12,970
just a slice of the key space all rights

332
00:12:12,970 --> 00:12:16,180
and then now let's look at it say about

333
00:12:16,180 --> 00:12:17,560
actually want to look up so we have a

334
00:12:17,560 --> 00:12:19,660
three node tea tree and we're trying to

335
00:12:19,660 --> 00:12:22,660
find key k2 so again I started the root

336
00:12:22,660 --> 00:12:25,120
right these are just pointers to the

337
00:12:25,120 --> 00:12:27,400
original keys so my key space here for

338
00:12:27,400 --> 00:12:29,290
this node here encompasses some Kum Kee

339
00:12:29,290 --> 00:12:31,630
for two key six inclusive so here now I

340
00:12:31,630 --> 00:12:33,430
have pointers that are that are sorted

341
00:12:33,430 --> 00:12:36,070
in the key order over to what's being

342
00:12:36,070 --> 00:12:39,640
stored in the data table so now then I

343
00:12:39,640 --> 00:12:42,040
have my my pointers down here and that

344
00:12:42,040 --> 00:12:43,720
allows me to do my traversal so the very

345
00:12:43,720 --> 00:12:44,860
beginning i struttin the root I'm

346
00:12:44,860 --> 00:12:48,250
looking for a key key to so I only need

347
00:12:48,250 --> 00:12:52,150
to potentially do one comparison per key

348
00:12:52,150 --> 00:12:53,740
to figure out a perm node to figure out

349
00:12:53,740 --> 00:12:55,420
where I need to go so again I have a

350
00:12:55,420 --> 00:12:57,250
copy of this key here because this way I

351
00:12:57,250 --> 00:12:58,690
can do this efficiently without having

352
00:12:58,690 --> 00:13:01,810
to go out to the original table but I

353
00:13:01,810 --> 00:13:03,490
just do a quick comparison it's K 2 less

354
00:13:03,490 --> 00:13:06,910
than k 4 and if yes then I know I want

355
00:13:06,910 --> 00:13:10,060
to follow that pointer down here all

356
00:13:10,060 --> 00:13:11,500
right so even though I said it's kind of

357
00:13:11,500 --> 00:13:13,060
inefficient to have to do these pointer

358
00:13:13,060 --> 00:13:15,010
lookups most the time you don't have to

359
00:13:15,010 --> 00:13:16,180
do that it's only when you land on the

360
00:13:16,180 --> 00:13:17,290
node to find what you're looking for

361
00:13:17,290 --> 00:13:19,180
that you think the key should be in this

362
00:13:19,180 --> 00:13:21,610
that you have to do follow this all

363
00:13:21,610 --> 00:13:22,870
right so then we we land down here

364
00:13:22,870 --> 00:13:24,790
and then now we check to see whether K 2

365
00:13:24,790 --> 00:13:27,910
is greater than K 1 it is we also want

366
00:13:27,910 --> 00:13:29,320
to check where the K 2 is less than K 3

367
00:13:29,320 --> 00:13:32,560
it is so we know that our key will exist

368
00:13:32,560 --> 00:13:34,750
because we know or it should it could

369
00:13:34,750 --> 00:13:36,490
potentially exist because it's within

370
00:13:36,490 --> 00:13:39,060
our boundaries here right

371
00:13:39,060 --> 00:13:42,580
so now we just do now again this keep it

372
00:13:42,580 --> 00:13:44,490
simple because we don't we only have

373
00:13:44,490 --> 00:13:47,080
three keys per node but we used to a

374
00:13:47,080 --> 00:13:48,910
linear scan and look at every single

375
00:13:48,910 --> 00:13:51,550
record right follow the pointer and then

376
00:13:51,550 --> 00:13:52,630
do our prepare some of the key over

377
00:13:52,630 --> 00:13:56,620
there yes question is when would you go

378
00:13:56,620 --> 00:13:58,870
back up I don't have a slide for this

379
00:13:58,870 --> 00:14:00,760
but when you do a range scan like final

380
00:14:00,760 --> 00:14:04,780
Keys greater than k2 I would come to

381
00:14:04,780 --> 00:14:06,310
come down here scan along find

382
00:14:06,310 --> 00:14:08,170
everything and then jump back up and

383
00:14:08,170 --> 00:14:08,620
keep going

384
00:14:08,620 --> 00:14:11,020
so basically in the initial search

385
00:14:11,020 --> 00:14:13,450
you're trying to find the from your side

386
00:14:13,450 --> 00:14:16,180
the leftmost starting point and then you

387
00:14:16,180 --> 00:14:17,680
scan along and when you realize there's

388
00:14:17,680 --> 00:14:19,480
nothing below me and I think there's

389
00:14:19,480 --> 00:14:24,400
something up above I filed back home his

390
00:14:24,400 --> 00:14:25,510
question is are there no sibling

391
00:14:25,510 --> 00:14:27,190
pointers and that's why we have to go up

392
00:14:27,190 --> 00:14:30,370
correct yes that's that's how AVL trees

393
00:14:30,370 --> 00:14:37,270
work yes y3 in this example because it

394
00:14:37,270 --> 00:14:45,790
fit in a slide so again like there's

395
00:14:45,790 --> 00:14:46,720
there's nothing in the original

396
00:14:46,720 --> 00:14:48,550
specification the key of the tea tree

397
00:14:48,550 --> 00:14:50,050
that says you have to have three again

398
00:14:50,050 --> 00:14:52,060
to make it fit I put three you could

399
00:14:52,060 --> 00:14:53,470
have five get 20 in whatever it doesn't

400
00:14:53,470 --> 00:14:54,420
matter

401
00:14:54,420 --> 00:15:04,780
yes so her question is what

402
00:15:04,780 --> 00:15:06,550
differentiates that this range in the

403
00:15:06,550 --> 00:15:08,140
pin the route between are the parent

404
00:15:08,140 --> 00:15:17,350
between the children so again so in a B+

405
00:15:17,350 --> 00:15:19,050
tree all the keys are at the bottom

406
00:15:19,050 --> 00:15:22,600
alright and in a ABL tree you can

407
00:15:22,600 --> 00:15:24,910
actually regular B tree you could have

408
00:15:24,910 --> 00:15:27,250
keys anywhere throughout or key and

409
00:15:27,250 --> 00:15:28,540
value pointers to the actual tuples

410
00:15:28,540 --> 00:15:30,280
anywhere in the data structure in the

411
00:15:30,280 --> 00:15:33,970
tree right so in a B+ tree if I only

412
00:15:33,970 --> 00:15:36,760
have keys in the leaf nodes

413
00:15:36,760 --> 00:15:38,350
a couple keys and then the values to the

414
00:15:38,350 --> 00:15:40,210
point is leaf nodes then I have up above

415
00:15:40,210 --> 00:15:41,860
I'm wasting space because a now I'm

416
00:15:41,860 --> 00:15:43,720
storing these guidepost keys so they're

417
00:15:43,720 --> 00:15:45,550
trying to use get the maximum usage of

418
00:15:45,550 --> 00:15:48,220
every single node and so they store the

419
00:15:48,220 --> 00:15:50,140
key value pointers anyone including the

420
00:15:50,140 --> 00:15:53,310
root node here in the parent node here

421
00:15:54,420 --> 00:15:57,760
well the these are guideposts but if I'm

422
00:15:57,760 --> 00:16:00,040
looking for for Keith's key five for

423
00:16:00,040 --> 00:16:03,160
example and I'm here then I would say

424
00:16:03,160 --> 00:16:05,140
key four key five is greater the key for

425
00:16:05,140 --> 00:16:07,390
and key 5 is less than key six so I know

426
00:16:07,390 --> 00:16:11,020
the thing I'm looking for is in here so

427
00:16:11,020 --> 00:16:13,020
I don't need to look at leaf nodes right

428
00:16:13,020 --> 00:16:15,460
again and a B+ tree they pushed

429
00:16:15,460 --> 00:16:17,680
everything to the bottom because now if

430
00:16:17,680 --> 00:16:19,120
I want to do that skin I don't backtrack

431
00:16:19,120 --> 00:16:21,040
I just scan along leaf nodes

432
00:16:21,040 --> 00:16:23,410
sequentially and I find what I want yeah

433
00:16:23,410 --> 00:16:40,540
yes question is why does having a B+

434
00:16:40,540 --> 00:16:42,040
tree design of pushing all the the

435
00:16:42,040 --> 00:16:44,230
actual the keys and the values to the

436
00:16:44,230 --> 00:16:47,050
leaf nodes how's that better for the

437
00:16:47,050 --> 00:16:48,250
scoring there versus this being

438
00:16:48,250 --> 00:16:50,620
scattered anywhere for a four in meri

439
00:16:50,620 --> 00:16:53,790
system so again if I'm trying to find a

440
00:16:53,790 --> 00:16:57,460
find a range of values right it's an

441
00:16:57,460 --> 00:16:59,290
order preserving tree so if it is a B+

442
00:16:59,290 --> 00:17:02,050
tree all the leaf nodes are stored in in

443
00:17:02,050 --> 00:17:04,180
that order I just try to find the left

444
00:17:04,180 --> 00:17:05,470
most node to start and then I

445
00:17:05,470 --> 00:17:08,050
sequentially scan which is faster on a

446
00:17:08,050 --> 00:17:09,760
disk Orion system least in the spinning

447
00:17:09,760 --> 00:17:11,349
us even actually even today them SSDs

448
00:17:11,349 --> 00:17:12,790
they're still faster but like I just now

449
00:17:12,790 --> 00:17:13,900
do a sequential scan along the bottom

450
00:17:13,900 --> 00:17:15,880
and find what I want I never to go back

451
00:17:15,880 --> 00:17:18,069
up we're trying to avoid random i/o in

452
00:17:18,069 --> 00:17:20,530
this world random i/o is not a big deal

453
00:17:20,530 --> 00:17:22,720
because it's in memories who cares so I

454
00:17:22,720 --> 00:17:24,579
can jump around and Traverse back up and

455
00:17:24,579 --> 00:17:27,280
I don't pay a big penalty for that all

456
00:17:27,280 --> 00:17:29,260
right am i sticking to her back to her

457
00:17:29,260 --> 00:17:32,440
point by storing the the by using all

458
00:17:32,440 --> 00:17:33,820
the upper notes or the inner nodes of

459
00:17:33,820 --> 00:17:35,350
the data structure to actually store

460
00:17:35,350 --> 00:17:38,890
keys and values that I care about I buy

461
00:17:38,890 --> 00:17:41,200
a waste less space right cuz in a B+

462
00:17:41,200 --> 00:17:43,390
tree I could I could delete a key right

463
00:17:43,390 --> 00:17:46,450
in the leaf node and I can extend the in

464
00:17:46,450 --> 00:17:49,590
the internet because that's my guidepost

465
00:17:50,610 --> 00:17:53,610
okay

466
00:17:53,760 --> 00:17:57,310
it's got here look at it okay so I think

467
00:17:57,310 --> 00:17:58,750
I've said a lot of this already

468
00:17:58,750 --> 00:18:01,180
again like part of the reason why I

469
00:18:01,180 --> 00:18:02,950
teach tea trees is because it's just in

470
00:18:02,950 --> 00:18:04,510
its a different way of thinking about

471
00:18:04,510 --> 00:18:06,340
how to do a memory database and then the

472
00:18:06,340 --> 00:18:09,850
indexes and you may come across some or

473
00:18:09,850 --> 00:18:11,140
you may come across somebody who says oh

474
00:18:11,140 --> 00:18:13,270
why are we using a B+ tree for in memory

475
00:18:13,270 --> 00:18:16,390
database shouldn't we be using you know

476
00:18:16,390 --> 00:18:17,890
in a more optimizing their data

477
00:18:17,890 --> 00:18:19,750
structure like a tea tree the answer's

478
00:18:19,750 --> 00:18:21,700
no because well I'll get to the

479
00:18:21,700 --> 00:18:23,260
defenders in the next slide but just a

480
00:18:23,260 --> 00:18:25,120
missus mostly just for your background

481
00:18:25,120 --> 00:18:27,040
information so again we already said

482
00:18:27,040 --> 00:18:28,660
this we store use less memory for index

483
00:18:28,660 --> 00:18:30,220
because we don't store the copy keys in

484
00:18:30,220 --> 00:18:31,780
every single node and then every single

485
00:18:31,780 --> 00:18:33,790
key is also always being used for

486
00:18:33,790 --> 00:18:35,590
storing key value pairs and not just

487
00:18:35,590 --> 00:18:37,570
guideposts the other interesting thing

488
00:18:37,570 --> 00:18:39,610
that the the inventor of the teacher you

489
00:18:39,610 --> 00:18:40,660
pointed out which I think there's kind

490
00:18:40,660 --> 00:18:41,950
of something I didn't think about is

491
00:18:41,950 --> 00:18:46,540
that in a tea tree because now when you

492
00:18:46,540 --> 00:18:49,900
do the evaluation of saying is my key

493
00:18:49,900 --> 00:18:52,030
equal this key or does my search key

494
00:18:52,030 --> 00:18:54,220
equal that the two plus key I'm falling

495
00:18:54,220 --> 00:18:55,780
the pointer I'm looking at the whole

496
00:18:55,780 --> 00:18:58,510
record so once you do that you're

497
00:18:58,510 --> 00:19:00,160
already sort of paid the penalty of

498
00:19:00,160 --> 00:19:01,480
falling the pointer and now looking in

499
00:19:01,480 --> 00:19:03,700
the record instead of just comparing you

500
00:19:03,700 --> 00:19:05,110
see whether that's the search key

501
00:19:05,110 --> 00:19:08,020
matches that the indexed keys for that

502
00:19:08,020 --> 00:19:10,210
tuple you might as well evaluate all the

503
00:19:10,210 --> 00:19:11,740
other predicates that you have in your

504
00:19:11,740 --> 00:19:14,170
where clause right if I have a where

505
00:19:14,170 --> 00:19:16,060
clause where a equals one and B equals

506
00:19:16,060 --> 00:19:19,300
two and my index is only on a and a B

507
00:19:19,300 --> 00:19:21,310
plus tree I would just do traversal

508
00:19:21,310 --> 00:19:22,930
because and only look at a because

509
00:19:22,930 --> 00:19:24,130
that's the only thing I can see inside

510
00:19:24,130 --> 00:19:26,290
my index then I have to go do the lookup

511
00:19:26,290 --> 00:19:28,690
on the index or the tuple then evaluate

512
00:19:28,690 --> 00:19:31,660
B but in a tea tree you could just do

513
00:19:31,660 --> 00:19:33,130
that all at once right while I'm looking

514
00:19:33,130 --> 00:19:35,890
at the tuple for a maza look at B so you

515
00:19:35,890 --> 00:19:37,420
could potentially end up throwing away

516
00:19:37,420 --> 00:19:40,210
or throwing out tuples that more quickly

517
00:19:40,210 --> 00:19:41,820
than you would otherwise

518
00:19:41,820 --> 00:19:51,760
yes david has been the key table what do

519
00:19:51,760 --> 00:19:54,390
you like a key table

520
00:19:56,380 --> 00:19:59,530
this is the whole yet so yeah this

521
00:19:59,530 --> 00:20:01,210
column data this is like a bunch of

522
00:20:01,210 --> 00:20:02,530
other attributes this is this is the

523
00:20:02,530 --> 00:20:05,309
attribute I'm Keith I'm the next one

524
00:20:05,309 --> 00:20:07,360
there's no separate key table that would

525
00:20:07,360 --> 00:20:10,090
be waste of space why because I mean the

526
00:20:10,090 --> 00:20:11,950
index itself is a key table to think of

527
00:20:11,950 --> 00:20:19,120
it okay so for this one here there are

528
00:20:19,120 --> 00:20:22,059
techniques in modern systems to sort of

529
00:20:22,059 --> 00:20:24,490
get this benefit as well so you can do

530
00:20:24,490 --> 00:20:26,410
like partial indexes where you you

531
00:20:26,410 --> 00:20:28,750
define a where clause for what keys

532
00:20:28,750 --> 00:20:32,350
could be in the index like build index

533
00:20:32,350 --> 00:20:35,470
that only have students that are in

534
00:20:35,470 --> 00:20:37,900
enrolled at fifteen seven 21 right and

535
00:20:37,900 --> 00:20:39,159
so all the other students that aren't in

536
00:20:39,159 --> 00:20:41,140
the class aren't inside the index and so

537
00:20:41,140 --> 00:20:42,360
that way that's sort of like

538
00:20:42,360 --> 00:20:44,470
pre-filtering the where clause ahead of

539
00:20:44,470 --> 00:20:46,450
time without having a stores an extra

540
00:20:46,450 --> 00:20:48,520
information or in other systems you can

541
00:20:48,520 --> 00:20:50,650
have include columns so you can say I

542
00:20:50,650 --> 00:20:52,870
want to be indexed on a but also by the

543
00:20:52,870 --> 00:20:56,289
way store B in the in the leaf nodes so

544
00:20:56,289 --> 00:20:57,520
that I don't have to go do the lookup

545
00:20:57,520 --> 00:20:58,809
the index but look up the tube or to

546
00:20:58,809 --> 00:20:59,980
figure out how to evaluate a predicate

547
00:20:59,980 --> 00:21:02,140
on B right post-course can do this

548
00:21:02,140 --> 00:21:03,100
sequel server can do this this is

549
00:21:03,100 --> 00:21:05,799
actually a bit more common now today and

550
00:21:05,799 --> 00:21:07,390
it's not as bad as actually have a store

551
00:21:07,390 --> 00:21:10,030
B everywhere throughout the the index

552
00:21:10,030 --> 00:21:11,890
you're only storing it and just let the

553
00:21:11,890 --> 00:21:14,140
leaf nodes so the benefit you would get

554
00:21:14,140 --> 00:21:17,080
from this I think is not as significant

555
00:21:17,080 --> 00:21:18,250
as maybe it was back in the day when

556
00:21:18,250 --> 00:21:21,130
they evaluated this all right so why

557
00:21:21,130 --> 00:21:23,500
don't anybody use them well I didn't

558
00:21:23,500 --> 00:21:24,610
talk about how to actually how to

559
00:21:24,610 --> 00:21:25,960
maintain this thing and keep it balanced

560
00:21:25,960 --> 00:21:27,490
if yellow trees are kind of tricky

561
00:21:27,490 --> 00:21:28,570
because you don't really do split some

562
00:21:28,570 --> 00:21:30,669
merges you have to do rotations I said

563
00:21:30,669 --> 00:21:31,780
now I have to take more heavyweight

564
00:21:31,780 --> 00:21:34,150
latches on my data structure in order to

565
00:21:34,150 --> 00:21:36,429
make significant changes and that's sort

566
00:21:36,429 --> 00:21:37,809
of late at this as well like it's hard

567
00:21:37,809 --> 00:21:40,320
to make sure that I guarantee that all

568
00:21:40,320 --> 00:21:43,900
my operations in a thread safe and then

569
00:21:43,900 --> 00:21:46,090
as I said once the CPU cache has got

570
00:21:46,090 --> 00:21:49,870
much faster the cost of going chasing

571
00:21:49,870 --> 00:21:51,549
those pointers I'm looking at the tuple

572
00:21:51,549 --> 00:21:53,320
that actually became quite significant

573
00:21:53,320 --> 00:21:55,929
so it's better off actually just yes or

574
00:21:55,929 --> 00:21:57,909
making a redundant copy of keys in your

575
00:21:57,909 --> 00:22:00,429
data structure but that avoids this this

576
00:22:00,429 --> 00:22:01,870
penalty here you're paying a little

577
00:22:01,870 --> 00:22:03,549
extra storage overhead to get a quite a

578
00:22:03,549 --> 00:22:06,370
significant performance efficiency game

579
00:22:06,370 --> 00:22:09,850
so there's a paper done in like 1999 by

580
00:22:09,850 --> 00:22:13,179
Ken Ross in Columbia that basically said

581
00:22:13,179 --> 00:22:15,130
that teachers are a bad idea for M

582
00:22:15,130 --> 00:22:17,200
indexes and actually a B+ tree or

583
00:22:17,200 --> 00:22:18,520
aberrant that looks like a B+ tree is a

584
00:22:18,520 --> 00:22:20,320
better way to go and so that's why I say

585
00:22:20,320 --> 00:22:24,190
nobody nobody today actually actually

586
00:22:24,190 --> 00:22:26,799
actually uses this other than like you

587
00:22:26,799 --> 00:22:28,150
know embedded devices like because a

588
00:22:28,150 --> 00:22:29,679
game is called extreme DB that's just a

589
00:22:29,679 --> 00:22:31,690
run on like you know little IOT devices

590
00:22:31,690 --> 00:22:34,030
and that world sure right that I think

591
00:22:34,030 --> 00:22:35,890
that makes sense but for you know a

592
00:22:35,890 --> 00:22:37,780
large you know Xeon server

593
00:22:37,780 --> 00:22:40,030
teachers are probably not the right

594
00:22:40,030 --> 00:22:49,360
choice yes this question is how can a

595
00:22:49,360 --> 00:22:51,490
binary search actually work here well

596
00:22:51,490 --> 00:22:53,799
again so this is linear search so say I

597
00:22:53,799 --> 00:22:56,320
did binary search and I landed here so

598
00:22:56,320 --> 00:22:58,030
what am I gonna go do I'm gonna go look

599
00:22:58,030 --> 00:23:00,909
up the key in the data table I get the

600
00:23:00,909 --> 00:23:03,070
key now and then I compare it with the

601
00:23:03,070 --> 00:23:05,860
key I'm looking for if my key is greater

602
00:23:05,860 --> 00:23:06,669
than that Keeney

603
00:23:06,669 --> 00:23:08,350
then I know I want to go this way if

604
00:23:08,350 --> 00:23:09,220
it's less than then I go to the other

605
00:23:09,220 --> 00:23:13,299
way these are sorted on the key and the

606
00:23:13,299 --> 00:23:15,880
key the values of the Kings the data

607
00:23:15,880 --> 00:23:17,140
table can be sorted any way at once

608
00:23:17,140 --> 00:23:20,409
right it's a relational database bag

609
00:23:20,409 --> 00:23:24,730
algebra these are unsorted so all the

610
00:23:24,730 --> 00:23:26,380
points I make is all the standard tricks

611
00:23:26,380 --> 00:23:29,290
we would do in a B+ tree of doing like

612
00:23:29,290 --> 00:23:30,790
linear search of binary search or

613
00:23:30,790 --> 00:23:32,649
tribulation search we can still do all

614
00:23:32,649 --> 00:23:34,179
those things it's just we have to pay

615
00:23:34,179 --> 00:23:36,100
extra a penalty extra jump somewhere

616
00:23:36,100 --> 00:23:39,299
there and see what the actual Milky is

617
00:23:39,480 --> 00:23:41,049
one think we actually would be

618
00:23:41,049 --> 00:23:43,030
interesting to do though now I think

619
00:23:43,030 --> 00:23:47,440
about it I know it's too late to do this

620
00:23:47,440 --> 00:23:52,059
for project two but so as I said before

621
00:23:52,059 --> 00:23:54,490
like when you get a pointer in in on x86

622
00:23:54,490 --> 00:23:57,370
like you have to allocate 64 bits right

623
00:23:57,370 --> 00:24:00,549
but in the hardware they actually only

624
00:24:00,549 --> 00:24:03,669
store 48 bits so you kind of have 16

625
00:24:03,669 --> 00:24:04,659
bits there you can actually store

626
00:24:04,659 --> 00:24:07,059
whatever you want and when you do it

627
00:24:07,059 --> 00:24:08,289
when you do reference to that pointer

628
00:24:08,289 --> 00:24:09,970
that dereference that memory address the

629
00:24:09,970 --> 00:24:12,090
the the harbor just ignores the 16 bits

630
00:24:12,090 --> 00:24:14,290
so you could do something where like

631
00:24:14,290 --> 00:24:17,380
this is 64 bits I still have the 48 bit

632
00:24:17,380 --> 00:24:18,820
pointer to take me back wherever I need

633
00:24:18,820 --> 00:24:20,320
to go into the data table but I

634
00:24:20,320 --> 00:24:23,169
store part of the key in here so some of

635
00:24:23,169 --> 00:24:24,460
the times I have to go look up sometimes

636
00:24:24,460 --> 00:24:29,860
I don't so yeah that potentially work

637
00:24:29,860 --> 00:24:32,980
but the problem with this is one Intel

638
00:24:32,980 --> 00:24:34,570
could take that away at any time and

639
00:24:34,570 --> 00:24:37,269
start using the full 64 bits I I was at

640
00:24:37,269 --> 00:24:40,389
a that it's our technical seminar but

641
00:24:40,389 --> 00:24:42,190
with this Intel guy a few years ago they

642
00:24:42,190 --> 00:24:43,870
said like they had an in-memory database

643
00:24:43,870 --> 00:24:45,970
that was maxing out to to the 48 you

644
00:24:45,970 --> 00:24:48,159
know minus one addresses and that

645
00:24:48,159 --> 00:24:49,600
eventually Intel would be going to to

646
00:24:49,600 --> 00:24:51,429
the 64 so don't store anything in those

647
00:24:51,429 --> 00:24:53,200
extra 16 bits but that was like three

648
00:24:53,200 --> 00:24:54,970
years ago and it hasn't happened yet huh

649
00:24:54,970 --> 00:24:58,720
so I I don't know what I don't know I

650
00:24:58,720 --> 00:25:00,279
don't think it's a good idea at least a

651
00:25:00,279 --> 00:25:02,169
future-proof the system we will see this

652
00:25:02,169 --> 00:25:03,789
technique used though for hash pass

653
00:25:03,789 --> 00:25:05,590
joins from hyper they use chain hash

654
00:25:05,590 --> 00:25:07,059
table because they store that some crab

655
00:25:07,059 --> 00:25:08,919
net they sort bloom filter in that 16

656
00:25:08,919 --> 00:25:12,549
bits which is kind of cool okay I won't

657
00:25:12,549 --> 00:25:13,990
dwell on teacher he's too much like this

658
00:25:13,990 --> 00:25:16,929
is again there's the beat up beat up

659
00:25:16,929 --> 00:25:19,149
retreat in the B+ tree or or more modern

660
00:25:19,149 --> 00:25:20,799
we should focus on that so any questions

661
00:25:20,799 --> 00:25:24,059
for teaching story switchover okay

662
00:25:24,059 --> 00:25:28,179
so part of the reason why it's difficult

663
00:25:28,179 --> 00:25:32,320
to make the tea tree perform efficiently

664
00:25:32,320 --> 00:25:33,940
or making it even make it latch free is

665
00:25:33,940 --> 00:25:37,000
that we have pointers all over the place

666
00:25:37,000 --> 00:25:38,830
we have you know every every parent

667
00:25:38,830 --> 00:25:40,210
pointer has a pointer to the child and

668
00:25:40,210 --> 00:25:42,159
that child has a pointer to the parent

669
00:25:42,159 --> 00:25:45,600
so now if I need to move one of them I

670
00:25:45,600 --> 00:25:47,500
changed one memory address I got to

671
00:25:47,500 --> 00:25:49,539
change a bunch of memory just as to all

672
00:25:49,539 --> 00:25:50,440
the children about pointing to that

673
00:25:50,440 --> 00:25:53,200
parent and I can't do that with atomic

674
00:25:53,200 --> 00:25:55,019
compare-and-swap instructions because

675
00:25:55,019 --> 00:25:57,370
you can't update multiple memory

676
00:25:57,370 --> 00:25:59,190
addresses it's like one 64-bit one

677
00:25:59,190 --> 00:26:01,960
128-bit location I can't say atomically

678
00:26:01,960 --> 00:26:05,590
update these two things so related this

679
00:26:05,590 --> 00:26:07,120
week this is also reason why we can't

680
00:26:07,120 --> 00:26:09,340
build a latch for you P plus tree you

681
00:26:09,340 --> 00:26:10,360
know for the same reason we're gonna

682
00:26:10,360 --> 00:26:11,710
have pointers to things in

683
00:26:11,710 --> 00:26:13,149
multiplications that update them

684
00:26:13,149 --> 00:26:15,850
atomically it's just not possible so to

685
00:26:15,850 --> 00:26:18,789
sort of motivate the design of how we

686
00:26:18,789 --> 00:26:21,250
may be potentially want to build a a lat

687
00:26:21,250 --> 00:26:24,039
tree B plus tree the way to sort of

688
00:26:24,039 --> 00:26:26,169
solve this multiple address problem is

689
00:26:26,169 --> 00:26:28,659
that if we had an indirection layer or

690
00:26:28,659 --> 00:26:32,139
some centralized data structure where we

691
00:26:32,139 --> 00:26:34,020
could record

692
00:26:34,020 --> 00:26:39,440
aren't these addresses and then multiple

693
00:26:39,440 --> 00:26:41,730
multiple elements or notes in our data

694
00:26:41,730 --> 00:26:43,260
structure could know how to do lookups

695
00:26:43,260 --> 00:26:44,850
in that indirection layer that that

696
00:26:44,850 --> 00:26:47,220
mapping table and then now I just need

697
00:26:47,220 --> 00:26:48,510
to do a compare and swap in that mapping

698
00:26:48,510 --> 00:26:49,740
table change one address and that

699
00:26:49,740 --> 00:26:51,840
automatically propagates the change

700
00:26:51,840 --> 00:26:54,600
through throughout the entire data

701
00:26:54,600 --> 00:26:56,220
structure and then I can make a latch

702
00:26:56,220 --> 00:26:59,760
ring so that's essentially what the BW

703
00:26:59,760 --> 00:27:02,220
tree is well B Dimitri is a latch tree B

704
00:27:02,220 --> 00:27:04,230
plus tree that came out of the hackathon

705
00:27:04,230 --> 00:27:06,360
project as I said I think two classes

706
00:27:06,360 --> 00:27:08,940
ago the the awesome people at Microsoft

707
00:27:08,940 --> 00:27:10,590
they when they first art a building

708
00:27:10,590 --> 00:27:12,270
hackathon they originally building it

709
00:27:12,270 --> 00:27:13,890
with skip list cuz skip list or latch

710
00:27:13,890 --> 00:27:15,750
tree then they realized skip lists are a

711
00:27:15,750 --> 00:27:18,360
bad idea the graph will show showed that

712
00:27:18,360 --> 00:27:20,670
it performs poorly ed then where they

713
00:27:20,670 --> 00:27:23,100
came up with was was the BW tree I

714
00:27:23,100 --> 00:27:25,560
should also comment to that they beat

715
00:27:25,560 --> 00:27:27,120
every tree although it's sort of

716
00:27:27,120 --> 00:27:30,360
described in our paper and there's most

717
00:27:30,360 --> 00:27:32,130
of the papers that talk about at least

718
00:27:32,130 --> 00:27:33,450
the original BW paper that talks about

719
00:27:33,450 --> 00:27:35,040
from Microsoft talks about in the

720
00:27:35,040 --> 00:27:37,950
context as an in-memory system in

721
00:27:37,950 --> 00:27:39,330
hackathons at Emory system there's

722
00:27:39,330 --> 00:27:40,380
another project they built called

723
00:27:40,380 --> 00:27:43,500
Deuteronomy at a Microsoft that actually

724
00:27:43,500 --> 00:27:46,410
stored things on flash and so the Delta

725
00:27:46,410 --> 00:27:49,140
record approach in the VW tree you know

726
00:27:49,140 --> 00:27:50,910
a pending changes to nodes those

727
00:27:50,910 --> 00:27:52,110
actually worked really well for Flash

728
00:27:52,110 --> 00:27:53,610
environments we just appending to a log

729
00:27:53,610 --> 00:27:56,790
but for an in-memory database the p30 is

730
00:27:56,790 --> 00:27:59,130
gonna be a bad idea so I'm jumping ahead

731
00:27:59,130 --> 00:28:01,590
but before we get into details who here

732
00:28:01,590 --> 00:28:02,700
read the paper and felt like they

733
00:28:02,700 --> 00:28:06,030
understand the BW tree okay I asked this

734
00:28:06,030 --> 00:28:07,650
every year very people raise their hand

735
00:28:07,650 --> 00:28:09,000
look at the hard data structure right

736
00:28:09,000 --> 00:28:10,710
hard to wrap your head around there's a

737
00:28:10,710 --> 00:28:12,690
lot going on and this is not so much a

738
00:28:12,690 --> 00:28:16,110
commentary about the complexity of the

739
00:28:16,110 --> 00:28:18,690
BW tree it's just the complexity of any

740
00:28:18,690 --> 00:28:20,400
lat tree data structure any laterally

741
00:28:20,400 --> 00:28:21,930
algorithm is actually pretty gnarly

742
00:28:21,930 --> 00:28:27,330
right and so a lot of times even though

743
00:28:27,330 --> 00:28:29,550
you're using latches could potentially

744
00:28:29,550 --> 00:28:32,070
be slower the engineering complexity of

745
00:28:32,070 --> 00:28:34,440
the data structure or what you're trying

746
00:28:34,440 --> 00:28:36,300
to do is we significantly less and

747
00:28:36,300 --> 00:28:37,470
therefore you're you're less likely to

748
00:28:37,470 --> 00:28:39,300
make mistakes and you it's easier for

749
00:28:39,300 --> 00:28:41,160
other people to work on it so right now

750
00:28:41,160 --> 00:28:43,530
for a BW in our system I think it's like

751
00:28:43,530 --> 00:28:45,660
five thousand eight thousand lines of

752
00:28:45,660 --> 00:28:47,520
code

753
00:28:47,520 --> 00:28:49,230
very few people and our team can

754
00:28:49,230 --> 00:28:51,030
actually touch it the one guy that wrote

755
00:28:51,030 --> 00:28:53,400
it is like he's not like crazy but like

756
00:28:53,400 --> 00:28:55,980
he's kind of eccentric right so he wrote

757
00:28:55,980 --> 00:28:57,210
the beat every tree the rumor is he

758
00:28:57,210 --> 00:28:58,980
wrote me to retreat for our team it took

759
00:28:58,980 --> 00:29:02,430
him like a year and a half he wrote it a

760
00:29:02,430 --> 00:29:06,330
lot of it in notepad um on a Windows

761
00:29:06,330 --> 00:29:08,220
laptop there was Windows 10 but he

762
00:29:08,220 --> 00:29:10,320
modified his Windows 10 to make it look

763
00:29:10,320 --> 00:29:12,570
like Windows 95 and then he sets the

764
00:29:12,570 --> 00:29:14,730
default font to Comic Sans and he wrote

765
00:29:14,730 --> 00:29:15,990
like in one of the hardest data

766
00:29:15,990 --> 00:29:17,010
structures he wrote in that environment

767
00:29:17,010 --> 00:29:21,180
so like there's a lot going on um all

768
00:29:21,180 --> 00:29:22,950
right so let me go through the actual

769
00:29:22,950 --> 00:29:25,050
key ideas of the main ideas and then

770
00:29:25,050 --> 00:29:26,400
we'll sort of increase the complexity of

771
00:29:26,400 --> 00:29:28,530
what else this you know we need to do

772
00:29:28,530 --> 00:29:29,610
our data structure actually support real

773
00:29:29,610 --> 00:29:32,910
things yes question is why is called the

774
00:29:32,910 --> 00:29:35,400
BWT let me take a guess it was in the

775
00:29:35,400 --> 00:29:39,660
title of the paper buzz words so it was

776
00:29:39,660 --> 00:29:44,400
I like it was all take all the buzz

777
00:29:44,400 --> 00:29:45,540
words at the time when the paper was

778
00:29:45,540 --> 00:29:48,230
written written like lat tree in memory

779
00:29:48,230 --> 00:29:51,960
LSM long structure murmurs trees to take

780
00:29:51,960 --> 00:29:53,160
all those buzzwords and they throw into

781
00:29:53,160 --> 00:29:56,270
a single index and it's called the tree

782
00:29:56,270 --> 00:30:01,860
your face is really disappointed its

783
00:30:01,860 --> 00:30:07,080
neighbors really bizarre yeah all right

784
00:30:07,080 --> 00:30:11,040
okay so two key ideas the deltas and the

785
00:30:11,040 --> 00:30:13,680
mapping table so they are gonna argue

786
00:30:13,680 --> 00:30:17,220
that you want to avoid cache

787
00:30:17,220 --> 00:30:19,980
invalidation right again think of like a

788
00:30:19,980 --> 00:30:21,210
multi socket system where you have a

789
00:30:21,210 --> 00:30:24,210
bunch of Numa nodes and the CPUs are

790
00:30:24,210 --> 00:30:25,470
trying to update the same data structure

791
00:30:25,470 --> 00:30:29,250
to reduce invalidation of having to make

792
00:30:29,250 --> 00:30:32,340
in place changes to the nodes they're

793
00:30:32,340 --> 00:30:34,890
gonna do Delta records so you pend Delta

794
00:30:34,890 --> 00:30:37,560
records to the node as you modify them

795
00:30:37,560 --> 00:30:38,640
and that's some later point you'll

796
00:30:38,640 --> 00:30:42,720
consolidate them now this is not

797
00:30:42,720 --> 00:30:43,470
entirely true

798
00:30:43,470 --> 00:30:44,760
because it won't work the way we

799
00:30:44,760 --> 00:30:45,870
actually implement it because we're

800
00:30:45,870 --> 00:30:47,070
actually stored the Delta records in the

801
00:30:47,070 --> 00:30:48,780
notes themselves so you still have cache

802
00:30:48,780 --> 00:30:51,570
invalidation but this is what they

803
00:30:51,570 --> 00:30:53,820
claimed and we didn't see at this we

804
00:30:53,820 --> 00:30:55,860
didn't see this this this benefit the

805
00:30:55,860 --> 00:30:57,390
other thing was the mapping table and

806
00:30:57,390 --> 00:30:58,950
again this was a central location that

807
00:30:58,950 --> 00:31:01,320
your store all the the addresses of

808
00:31:01,320 --> 00:31:03,360
physical nodes and then now if I need to

809
00:31:03,360 --> 00:31:06,150
change the address of a logical needing

810
00:31:06,150 --> 00:31:07,230
to change the physical address of a

811
00:31:07,230 --> 00:31:09,840
logical node I just go to my mapping

812
00:31:09,840 --> 00:31:13,110
table and update it okay so let's look

813
00:31:13,110 --> 00:31:14,190
at really simple tables so here were a

814
00:31:14,190 --> 00:31:17,400
three node BW tree so the first thing to

815
00:31:17,400 --> 00:31:18,600
point out here is that again we have our

816
00:31:18,600 --> 00:31:20,610
mapping table and every nodes going to

817
00:31:20,610 --> 00:31:22,740
be assigned a page ID or our note I do

818
00:31:22,740 --> 00:31:26,520
all right so page 101 1 2 - 104 and then

819
00:31:26,520 --> 00:31:28,650
now in our mapping table we'll have

820
00:31:28,650 --> 00:31:30,900
physical pointers that tell us the

821
00:31:30,900 --> 00:31:32,730
address the starting address for each of

822
00:31:32,730 --> 00:31:35,700
these nodes so I'll denote this in in in

823
00:31:35,700 --> 00:31:39,750
in all these diagrams the the solid

824
00:31:39,750 --> 00:31:41,790
black line will represent the physical

825
00:31:41,790 --> 00:31:44,280
address and the dotted red lines will

826
00:31:44,280 --> 00:31:46,650
represent the logical addresses so in

827
00:31:46,650 --> 00:31:49,470
this case here we have the root node and

828
00:31:49,470 --> 00:31:51,960
it has two pointers to its children so

829
00:31:51,960 --> 00:31:53,640
the only thing we need to store now in

830
00:31:53,640 --> 00:31:56,340
that node is just the page ID of the

831
00:31:56,340 --> 00:32:00,480
children 102 and 104 so now if anytime I

832
00:32:00,480 --> 00:32:02,400
need to go say alright I I'm traversing

833
00:32:02,400 --> 00:32:04,680
my tree I'm at page 101 and now I need

834
00:32:04,680 --> 00:32:06,780
to keep to page 102 all right this is

835
00:32:06,780 --> 00:32:08,430
not a pointer I can actually follow I

836
00:32:08,430 --> 00:32:10,650
have to do a lookup in my mapping table

837
00:32:10,650 --> 00:32:13,260
and say oh I want page 102 tell me the

838
00:32:13,260 --> 00:32:14,940
physical address of it and then now I

839
00:32:14,940 --> 00:32:17,910
can land into this right you're gonna

840
00:32:17,910 --> 00:32:19,290
have this indirection layer that allows

841
00:32:19,290 --> 00:32:22,890
me to take any logical page ID and map

842
00:32:22,890 --> 00:32:25,920
it to a physical address all right so

843
00:32:25,920 --> 00:32:29,430
let's see now if when we do an update so

844
00:32:29,430 --> 00:32:31,530
let's say I have a single page here by

845
00:32:31,530 --> 00:32:34,890
page 102 and now every single time I'm

846
00:32:34,890 --> 00:32:37,020
gonna do an update to a page like insert

847
00:32:37,020 --> 00:32:39,600
a key delete a key we're not worried

848
00:32:39,600 --> 00:32:41,010
about updating keys because that's but

849
00:32:41,010 --> 00:32:42,690
it's just a delete followed by an insert

850
00:32:42,690 --> 00:32:45,510
all right so it's leader insert so again

851
00:32:45,510 --> 00:32:47,400
instead of making the change directly on

852
00:32:47,400 --> 00:32:49,920
the page itself right so this is just

853
00:32:49,920 --> 00:32:51,870
another this is just a node like in a B

854
00:32:51,870 --> 00:32:52,440
plus tree

855
00:32:52,440 --> 00:32:54,870
I have an array of keys an array of

856
00:32:54,870 --> 00:32:57,840
values it's the same same same physical

857
00:32:57,840 --> 00:32:59,430
layout but now instead of making an

858
00:32:59,430 --> 00:33:01,410
update to those arrays I'm gonna create

859
00:33:01,410 --> 00:33:03,150
a Delta record that says what the change

860
00:33:03,150 --> 00:33:05,730
I want to make into the quines

861
00:33:05,730 --> 00:33:07,980
that's represented in 102 so let's say

862
00:33:07,980 --> 00:33:11,400
now I want to sort key key 0 so this

863
00:33:11,400 --> 00:33:13,890
record will have a physical pointer to

864
00:33:13,890 --> 00:33:15,000
the base page

865
00:33:15,000 --> 00:33:17,730
so how do I get that while I do my look

866
00:33:17,730 --> 00:33:20,070
up and my mapping table and I would say

867
00:33:20,070 --> 00:33:21,390
I know what this physical dress is gonna

868
00:33:21,390 --> 00:33:25,470
be 1 or 2 so then now at this point

869
00:33:25,470 --> 00:33:27,630
nobody can see my change because if

870
00:33:27,630 --> 00:33:29,730
anybody is looking for page 102 they

871
00:33:29,730 --> 00:33:31,230
would look in the mapping table and see

872
00:33:31,230 --> 00:33:33,299
this pointer and bypass my Delta record

873
00:33:33,299 --> 00:33:35,909
entirely so what what I need to do now

874
00:33:35,909 --> 00:33:38,700
is do to install it I'm gonna do a

875
00:33:38,700 --> 00:33:41,820
compare and swap in the mapping table to

876
00:33:41,820 --> 00:33:44,700
replace the the physical address that it

877
00:33:44,700 --> 00:33:46,890
used to point to to now my physical

878
00:33:46,890 --> 00:33:49,200
address now that anybody goes looks at

879
00:33:49,200 --> 00:33:51,539
102 they're not gonna land here they're

880
00:33:51,539 --> 00:33:53,640
gonna land here recognize they're

881
00:33:53,640 --> 00:33:56,970
looking at a Delta record and evaluate

882
00:33:56,970 --> 00:33:58,590
it accordingly so if I'm looking for a

883
00:33:58,590 --> 00:34:00,780
key 0 I landed this Delta record here I

884
00:34:00,780 --> 00:34:02,730
say Oh insert key 0 voila

885
00:34:02,730 --> 00:34:04,110
I'm done I found exactly what I was

886
00:34:04,110 --> 00:34:05,940
looking for if I'm not looking for a key

887
00:34:05,940 --> 00:34:08,250
0 then I just follow along now down here

888
00:34:08,250 --> 00:34:11,219
and then now I can look at me in the in

889
00:34:11,219 --> 00:34:15,480
the base page the base node so this

890
00:34:15,480 --> 00:34:17,250
clear this is like the sort of the core

891
00:34:17,250 --> 00:34:18,409
idea what they're doing

892
00:34:18,409 --> 00:34:21,409
yes

893
00:34:34,980 --> 00:34:38,409
your question is I the question was like

894
00:34:38,409 --> 00:34:40,690
if I'm storing this with this I fight

895
00:34:40,690 --> 00:34:52,510
because I'm not storing with this it's

896
00:34:52,510 --> 00:34:54,789
like this is always the latest version

897
00:34:54,789 --> 00:34:59,260
and then if I want to say what was the

898
00:34:59,260 --> 00:35:00,970
version before this then I picked

899
00:35:00,970 --> 00:35:03,490
somehow and then this would be like what

900
00:35:03,490 --> 00:35:07,839
would be the Versa insert k0 with like

901
00:35:07,839 --> 00:35:09,280
you said this is like the reverse of the

902
00:35:09,280 --> 00:35:10,750
change you made here so what's the

903
00:35:10,750 --> 00:35:14,410
reverse insert KZ row it's not really

904
00:35:14,410 --> 00:35:17,520
delete k0 cuz it didn't exist before and

905
00:35:17,520 --> 00:35:19,750
then what would happen now and at least

906
00:35:19,750 --> 00:35:21,640
in that case and for your example I've

907
00:35:21,640 --> 00:35:23,619
modified this page to be in cache

908
00:35:23,619 --> 00:35:25,329
invalidation to the other other suffice

909
00:35:25,329 --> 00:35:27,579
to view sockets but then also it's

910
00:35:27,579 --> 00:35:28,660
another cache invalidation because I

911
00:35:28,660 --> 00:35:30,549
updated another region of memory at

912
00:35:30,549 --> 00:35:33,160
least in this case I just and I create

913
00:35:33,160 --> 00:35:35,529
this Delta record this day's unmodified

914
00:35:35,529 --> 00:35:38,410
so the only sort of cache reference I

915
00:35:38,410 --> 00:35:42,119
need to update would be this thing here

916
00:35:45,210 --> 00:35:48,250
yeah they're packing together yes we do

917
00:35:48,250 --> 00:35:58,270
that for efficiency reasons your cache

918
00:35:58,270 --> 00:36:06,190
line though is what 64 the cache line is

919
00:36:06,190 --> 00:36:07,990
64 bytes so long as you update something

920
00:36:07,990 --> 00:36:10,000
less than it's something more than 64

921
00:36:10,000 --> 00:36:14,770
bytes it'd be ok I had to think like

922
00:36:14,770 --> 00:36:18,599
that but I think it's sort of weird

923
00:36:18,599 --> 00:36:20,859
cuz like you're creating a personal

924
00:36:20,859 --> 00:36:22,270
something it doesn't exist and you need

925
00:36:22,270 --> 00:36:26,020
to know like even in your example you

926
00:36:26,020 --> 00:36:30,400
need to know I'm looking for k0 I don't

927
00:36:30,400 --> 00:36:34,809
I see it here I'm done but he have what

928
00:36:34,809 --> 00:36:37,059
there's no reversal for that delete

929
00:36:37,059 --> 00:36:38,619
maybe you could say alright I see

930
00:36:38,619 --> 00:36:39,490
something here

931
00:36:39,490 --> 00:36:41,589
I don't see something but did it used to

932
00:36:41,589 --> 00:36:44,020
exist yeah I have to think would you

933
00:36:44,020 --> 00:36:46,119
just would you say he's weird sorry

934
00:36:46,119 --> 00:36:52,059
yeah so the question is like when would

935
00:36:52,059 --> 00:36:53,440
I actually follow this pointer right so

936
00:36:53,440 --> 00:36:55,869
at this point here I've been created the

937
00:36:55,869 --> 00:36:58,089
I created this Delta record it has a

938
00:36:58,089 --> 00:37:00,549
physical pointer to the page nobody else

939
00:37:00,549 --> 00:37:01,839
could see it though because everyone

940
00:37:01,839 --> 00:37:03,130
else is following the mapping table that

941
00:37:03,130 --> 00:37:04,420
takes you to the base page

942
00:37:04,420 --> 00:37:06,910
I do the compare-and-swap on this and

943
00:37:06,910 --> 00:37:09,190
now anybody that's looking for page one

944
00:37:09,190 --> 00:37:11,680
or two lands here doesn't matter where

945
00:37:11,680 --> 00:37:12,789
you're looking for k0 or not if you're

946
00:37:12,789 --> 00:37:14,049
looking for page one or two you land

947
00:37:14,049 --> 00:37:16,180
here and then you have to evaluate

948
00:37:16,180 --> 00:37:18,609
you're essentially replaying like a log

949
00:37:18,609 --> 00:37:21,099
in memory to say well what's actually

950
00:37:21,099 --> 00:37:26,200
being stored in one or two question is

951
00:37:26,200 --> 00:37:28,089
the more records you have the longer it

952
00:37:28,089 --> 00:37:30,220
takes actually fine the the key if you

953
00:37:30,220 --> 00:37:31,690
had a look at the base page yes we'll

954
00:37:31,690 --> 00:37:37,119
fix that in a second yes so this

955
00:37:37,119 --> 00:37:38,020
question is what if there is a

956
00:37:38,020 --> 00:37:40,450
concurrent delta update next slide will

957
00:37:40,450 --> 00:37:44,020
handle that so again now if I do this

958
00:37:44,020 --> 00:37:45,220
let's do another one if I do a delete

959
00:37:45,220 --> 00:37:47,349
eight same thing compare-and-swap on

960
00:37:47,349 --> 00:37:49,089
this right and now the points of this so

961
00:37:49,089 --> 00:37:50,609
now anybody coming along for one or two

962
00:37:50,609 --> 00:37:53,230
right they would have to evaluate delete

963
00:37:53,230 --> 00:37:55,059
k0k date that's not what I want

964
00:37:55,059 --> 00:37:57,099
delete key zero that's not what I want

965
00:37:57,099 --> 00:37:59,049
and then do the search down here in the

966
00:37:59,049 --> 00:38:02,430
base note yeah

967
00:38:02,920 --> 00:38:06,099
so we've already covered this that this

968
00:38:06,099 --> 00:38:07,799
is just doing search like a B+ tree

969
00:38:07,799 --> 00:38:11,170
alright if the thing you're looking for

970
00:38:11,170 --> 00:38:14,680
is found in the Delta chain you're done

971
00:38:14,680 --> 00:38:16,599
otherwise again you just do a search of

972
00:38:16,599 --> 00:38:20,500
the BOP I'm alright so let's handle his

973
00:38:20,500 --> 00:38:23,200
problem so now we're back here we've

974
00:38:23,200 --> 00:38:25,450
installed a delta record for inserting

975
00:38:25,450 --> 00:38:28,510
key 0 and then now I have two threads

976
00:38:28,510 --> 00:38:29,829
they're gonna try and stall to Delta

977
00:38:29,829 --> 00:38:32,049
records at the exact same time so two

978
00:38:32,049 --> 00:38:34,089
threads are inside inside the index and

979
00:38:34,089 --> 00:38:35,500
they say oh I need to perform an

980
00:38:35,500 --> 00:38:37,180
operation and this is the note I want to

981
00:38:37,180 --> 00:38:38,740
pour this is the base page I want to

982
00:38:38,740 --> 00:38:41,140
perform my operation on so the first guy

983
00:38:41,140 --> 00:38:43,900
wants to leak 88 is second I want to

984
00:38:43,900 --> 00:38:47,170
leak key 6 so what's gonna happen here

985
00:38:47,170 --> 00:38:51,180
how do we install these updates

986
00:38:51,599 --> 00:38:53,609
like yup it's actually only applied

987
00:38:53,609 --> 00:38:55,859
whenever you update yeah correct so his

988
00:38:55,859 --> 00:38:58,019
statement is the updates are only

989
00:38:58,019 --> 00:39:01,410
applied and are only visible to everyone

990
00:39:01,410 --> 00:39:04,289
else if you know when you update this

991
00:39:04,289 --> 00:39:06,420
thing so these guys now are gonna do

992
00:39:06,420 --> 00:39:08,699
compare and swap at the same time on

993
00:39:08,699 --> 00:39:10,619
this memory location in the mapping

994
00:39:10,619 --> 00:39:13,349
table but only one can succeed so you

995
00:39:13,349 --> 00:39:14,670
know essentially what you're doing is

996
00:39:14,670 --> 00:39:16,859
when you're back here you know what you

997
00:39:16,859 --> 00:39:19,019
note that the physical address is to the

998
00:39:19,019 --> 00:39:21,569
head of doesn't record a delta chain for

999
00:39:21,569 --> 00:39:23,160
this node all right that's what these

1000
00:39:23,160 --> 00:39:24,809
guys that's how these guys got got these

1001
00:39:24,809 --> 00:39:27,119
these physical dresses so now when I do

1002
00:39:27,119 --> 00:39:29,009
a compare and swap you say if the

1003
00:39:29,009 --> 00:39:31,259
current value of this address here is

1004
00:39:31,259 --> 00:39:34,199
what I think it should be then go ahead

1005
00:39:34,199 --> 00:39:37,049
and swap it and install my new update

1006
00:39:37,049 --> 00:39:39,869
right so let's say the first guy is able

1007
00:39:39,869 --> 00:39:43,079
to do this right that's fine so now he

1008
00:39:43,079 --> 00:39:45,479
is at the head of the Delta vector Delta

1009
00:39:45,479 --> 00:39:48,719
chain and his his update got installed

1010
00:39:48,719 --> 00:39:51,150
the second guy with that compare and

1011
00:39:51,150 --> 00:39:53,190
swap operation would fail because we

1012
00:39:53,190 --> 00:39:55,380
would do the evaluation of the mapping

1013
00:39:55,380 --> 00:39:58,049
table see that the address is not what

1014
00:39:58,049 --> 00:39:59,699
it's thought it was gonna be pointing to

1015
00:39:59,699 --> 00:40:01,380
this does record here it's now pointing

1016
00:40:01,380 --> 00:40:03,150
to this one so it knows that somebody

1017
00:40:03,150 --> 00:40:06,479
else got in before he did and updated

1018
00:40:06,479 --> 00:40:10,529
this so my update will now fail and then

1019
00:40:10,529 --> 00:40:12,059
depending on implementation I can either

1020
00:40:12,059 --> 00:40:14,849
try to another compare and swap and try

1021
00:40:14,849 --> 00:40:17,729
to update this or I could just repeat

1022
00:40:17,729 --> 00:40:19,349
and do the whole operation Traverse down

1023
00:40:19,349 --> 00:40:38,729
and try again you're saying that if I

1024
00:40:38,729 --> 00:40:49,219
try to compare and swap now yes yes yes

1025
00:40:52,190 --> 00:40:56,579
so what I could do is I up take this

1026
00:40:56,579 --> 00:41:00,380
this visible just here now point to this

1027
00:41:01,450 --> 00:41:04,900
one out so they so if you're here the

1028
00:41:04,900 --> 00:41:07,750
compare-and-swap succeeds case comparing

1029
00:41:07,750 --> 00:41:10,270
saw it feels so now I could go back

1030
00:41:10,270 --> 00:41:11,710
inside wall just fail what's in there

1031
00:41:11,710 --> 00:41:21,970
now no number copy but like this thing

1032
00:41:21,970 --> 00:41:23,440
is always gonna point to whatever the

1033
00:41:23,440 --> 00:41:24,490
head of the Virgin chain that doesn't

1034
00:41:24,490 --> 00:41:34,359
record genius correct I just go look and

1035
00:41:34,359 --> 00:41:35,950
see this again you could do that way I

1036
00:41:35,950 --> 00:41:37,089
don't think we implemented that way

1037
00:41:37,089 --> 00:41:38,530
because for like safety reasons because

1038
00:41:38,530 --> 00:41:41,680
like you don't know now that this thing

1039
00:41:41,680 --> 00:41:42,940
might do a split and the thing you're

1040
00:41:42,940 --> 00:41:43,900
looking for may no longer be

1041
00:41:43,900 --> 00:41:46,450
encapsulated in this index or this note

1042
00:41:46,450 --> 00:41:48,490
here like this I might have done a split

1043
00:41:48,490 --> 00:41:51,369
and now we're k-6 should be should not

1044
00:41:51,369 --> 00:41:53,079
be page one or two H now mean another

1045
00:41:53,079 --> 00:42:23,290
page when yes yes so again we're only to

1046
00:42:23,290 --> 00:42:25,420
delete and inserts all right so there's

1047
00:42:25,420 --> 00:42:27,760
no if we handover updates right the

1048
00:42:27,760 --> 00:42:30,490
other thing too is like this is a inside

1049
00:42:30,490 --> 00:42:32,020
the data structure we don't have to

1050
00:42:32,020 --> 00:42:34,180
worry about higher-level consistency

1051
00:42:34,180 --> 00:42:36,910
issues of the transactions like I think

1052
00:42:36,910 --> 00:42:38,859
maybe we're possibly saying is like well

1053
00:42:38,859 --> 00:42:40,869
what if one transaction deletes k-8 and

1054
00:42:40,869 --> 00:42:42,609
I try to insert it or I'd I'm kind of

1055
00:42:42,609 --> 00:42:44,619
read it and it's been deleted all that's

1056
00:42:44,619 --> 00:42:47,170
handled up above in the and like either

1057
00:42:47,170 --> 00:42:49,030
doing this the rerunning the scans are

1058
00:42:49,030 --> 00:42:50,650
doing the validation stuff all that's

1059
00:42:50,650 --> 00:42:52,079
handled above us we just care about the

1060
00:42:52,079 --> 00:42:54,579
low levels linearize ability correctness

1061
00:42:54,579 --> 00:42:56,230
of the data structure and this thing

1062
00:42:56,230 --> 00:42:59,670
will handle that for us yes

1063
00:43:03,010 --> 00:43:04,780
you're currently accessing that case

1064
00:43:04,780 --> 00:43:06,820
would be different from you know every

1065
00:43:06,820 --> 00:43:09,400
study again I mean what like I don't

1066
00:43:09,400 --> 00:43:11,050
really see the point of why you worry

1067
00:43:11,050 --> 00:43:14,250
about it's pretty known that page 102

1068
00:43:14,250 --> 00:43:16,210
like we'd have to restart on the

1069
00:43:16,210 --> 00:43:18,490
beginning that how does that propagating

1070
00:43:18,490 --> 00:43:26,890
that could ensure that um when I say Inc

1071
00:43:26,890 --> 00:43:30,970
uses Cu it has to do with like it has to

1072
00:43:30,970 --> 00:43:32,530
do with like I'm trying to insert

1073
00:43:32,530 --> 00:43:34,690
something and in a trying to start a

1074
00:43:34,690 --> 00:43:37,240
logical key that is not that is not

1075
00:43:37,240 --> 00:43:39,070
represented or should not be stored at

1076
00:43:39,070 --> 00:43:42,970
this this this location here so if now

1077
00:43:42,970 --> 00:43:44,800
key six should not be in page one or two

1078
00:43:44,800 --> 00:43:46,540
should be page 103 if I try to

1079
00:43:46,540 --> 00:43:47,590
immediately come back and do equal

1080
00:43:47,590 --> 00:43:49,390
parents WAP here now I'm starting key

1081
00:43:49,390 --> 00:43:52,090
six into this page but anybody else that

1082
00:43:52,090 --> 00:43:53,440
looks for key six it's not gonna lay in

1083
00:43:53,440 --> 00:43:54,820
here they're gonna follow the guide

1084
00:43:54,820 --> 00:43:56,770
posts and lans mother node and they'll

1085
00:43:56,770 --> 00:43:59,940
have a false false negative

1086
00:44:01,000 --> 00:44:04,119
[Music]

1087
00:44:08,100 --> 00:44:10,119
how do I make sure I'm landing up here

1088
00:44:10,119 --> 00:44:11,109
where I should be right yeah because

1089
00:44:11,109 --> 00:44:13,330
that's just the weight I mean because

1090
00:44:13,330 --> 00:44:16,630
we're enforcing the the the the ordering

1091
00:44:16,630 --> 00:44:18,340
of the directions of where you go from

1092
00:44:18,340 --> 00:44:19,600
left to right from one node to the next

1093
00:44:19,600 --> 00:44:22,150
right with the keys and so we're

1094
00:44:22,150 --> 00:44:23,619
guaranteeing that we're propagating the

1095
00:44:23,619 --> 00:44:26,140
changes from the bottom to the top so

1096
00:44:26,140 --> 00:44:27,700
you're not in this weird state where

1097
00:44:27,700 --> 00:44:28,840
like something is pointing you to

1098
00:44:28,840 --> 00:44:30,369
something that shouldn't be or something

1099
00:44:30,369 --> 00:44:31,119
that being stored in the place that

1100
00:44:31,119 --> 00:44:32,740
shouldn't be but always restarting at

1101
00:44:32,740 --> 00:44:34,810
the top it's inefficient and that's sort

1102
00:44:34,810 --> 00:44:36,730
of that the the downside of a laterally

1103
00:44:36,730 --> 00:44:38,320
data structure but we guarantee the

1104
00:44:38,320 --> 00:44:40,359
correctness the kids Assistance II of

1105
00:44:40,359 --> 00:44:43,180
the data structure at a at a physical

1106
00:44:43,180 --> 00:44:49,570
level okay so now to his earlier

1107
00:44:49,570 --> 00:44:51,190
question and would like well can't this

1108
00:44:51,190 --> 00:44:54,130
Delta chain get kind of long yes it will

1109
00:44:54,130 --> 00:44:56,530
and so we want to do consolidation so

1110
00:44:56,530 --> 00:44:59,260
basically what's gonna happen is one

1111
00:44:59,260 --> 00:45:01,150
thread will recognize as it's going

1112
00:45:01,150 --> 00:45:02,680
along this Delta chain has gotten too

1113
00:45:02,680 --> 00:45:04,480
long alright this could be like a

1114
00:45:04,480 --> 00:45:05,800
threshold you say if the Delta chain is

1115
00:45:05,800 --> 00:45:08,260
as more has more than these number

1116
00:45:08,260 --> 00:45:09,730
records then I want to have a solid

1117
00:45:09,730 --> 00:45:11,410
ation so what you're going to do is

1118
00:45:11,410 --> 00:45:14,380
you're gonna make first a copy of the

1119
00:45:14,380 --> 00:45:14,970
base page

1120
00:45:14,970 --> 00:45:17,339
and then now you're going to apply the

1121
00:45:17,339 --> 00:45:21,240
the changes in reverse order of the

1122
00:45:21,240 --> 00:45:23,760
Delta chain we take us why were you

1123
00:45:23,760 --> 00:45:27,990
doing reverse order that is the order

1124
00:45:27,990 --> 00:45:31,740
right like this is like in physical time

1125
00:45:31,740 --> 00:45:33,630
the change to be made is like this is

1126
00:45:33,630 --> 00:45:35,430
the oldest change and this is going to

1127
00:45:35,430 --> 00:45:37,799
the newest change right so if I say if I

1128
00:45:37,799 --> 00:45:42,809
if I'm deleting k-8 here and I insert

1129
00:45:42,809 --> 00:45:45,270
k-8 here then does it make sense or try

1130
00:45:45,270 --> 00:45:46,380
to delete something if I'm going in this

1131
00:45:46,380 --> 00:45:47,609
direction so we always go in reverse

1132
00:45:47,609 --> 00:45:49,980
order so basically it's gonna be as I

1133
00:45:49,980 --> 00:45:52,049
scan through and I recognize this depth

1134
00:45:52,049 --> 00:45:53,579
of change it's gotten too long I have a

1135
00:45:53,579 --> 00:45:55,680
copy of all these things and now I can

1136
00:45:55,680 --> 00:45:57,450
replay them in reverse order one by one

1137
00:45:57,450 --> 00:46:01,109
alright so now after I replay all my

1138
00:46:01,109 --> 00:46:04,760
changes now this new copy of the node

1139
00:46:04,760 --> 00:46:06,990
represents all the same things that are

1140
00:46:06,990 --> 00:46:09,390
represented by this base page and it's

1141
00:46:09,390 --> 00:46:12,150
in his dental records so how do I

1142
00:46:12,150 --> 00:46:16,230
install it now command swap easy right

1143
00:46:16,230 --> 00:46:18,089
all I needed to go back now is compare

1144
00:46:18,089 --> 00:46:21,779
and swap to this this for the record

1145
00:46:21,779 --> 00:46:24,809
here the entry here for 102 and now

1146
00:46:24,809 --> 00:46:26,640
anybody else that comes along can see me

1147
00:46:26,640 --> 00:46:28,890
if I fail then I wasted work I've done

1148
00:46:28,890 --> 00:46:30,180
my consolidation and somebody else

1149
00:46:30,180 --> 00:46:31,260
changed something like if someone else

1150
00:46:31,260 --> 00:46:33,839
appends a new Delta record before I get

1151
00:46:33,839 --> 00:46:36,690
my before I do my compare and swap well

1152
00:46:36,690 --> 00:46:38,010
then that solves the problem of not

1153
00:46:38,010 --> 00:46:39,779
seeing that you know potentially missing

1154
00:46:39,779 --> 00:46:42,329
a doesn't record update because now this

1155
00:46:42,329 --> 00:46:43,440
thing would have pointed to a new Delta

1156
00:46:43,440 --> 00:46:45,119
record that I didn't see and therefore I

1157
00:46:45,119 --> 00:46:48,680
throw away my work and start up yes

1158
00:46:49,490 --> 00:46:52,690
[Music]

1159
00:46:53,920 --> 00:46:58,280
it calls this a virtual moon yeah it's

1160
00:46:58,280 --> 00:47:00,800
just in the heat it's just like an ode

1161
00:47:00,800 --> 00:47:03,170
that nobody else can see yet it's in the

1162
00:47:03,170 --> 00:47:05,210
like only my thread is doing the

1163
00:47:05,210 --> 00:47:17,630
consolidation can can see it yeah this

1164
00:47:17,630 --> 00:47:19,670
question is why don't I just instead of

1165
00:47:19,670 --> 00:47:21,230
doing this and comparing solving this

1166
00:47:21,230 --> 00:47:22,790
why don't I take all these things and

1167
00:47:22,790 --> 00:47:31,760
apply to this you think you questions

1168
00:47:31,760 --> 00:47:33,140
why didn't have these Delta records

1169
00:47:33,140 --> 00:47:35,869
wanted to apply this change here again

1170
00:47:35,869 --> 00:47:40,670
they're they're arguing that in order to

1171
00:47:40,670 --> 00:47:44,359
make it latch free if I fat from

1172
00:47:44,359 --> 00:47:45,890
allowing anybody to make any change down

1173
00:47:45,890 --> 00:47:50,440
here you still need latches right

1174
00:47:50,440 --> 00:47:52,580
because that these things that have to

1175
00:47:52,580 --> 00:47:53,900
be sorted and you have to deploy latches

1176
00:47:53,900 --> 00:47:55,339
to try to like you know enforce the

1177
00:47:55,339 --> 00:47:57,349
ordering on them so they're trying to be

1178
00:47:57,349 --> 00:48:05,089
entirely Larry yes this question is is

1179
00:48:05,089 --> 00:48:06,560
the comparison in your latch we will

1180
00:48:06,560 --> 00:48:07,580
cover this next class could you

1181
00:48:07,580 --> 00:48:10,790
implement latches with clear and swap no

1182
00:48:10,790 --> 00:48:13,820
like still a it'd be like I hold I'm

1183
00:48:13,820 --> 00:48:16,310
holding a latch on some critical section

1184
00:48:16,310 --> 00:48:21,260
and I do a bunch of stuff so this is

1185
00:48:21,260 --> 00:48:23,960
like here's a single update I apply now

1186
00:48:23,960 --> 00:48:26,510
you're right well if it's a spin latch

1187
00:48:26,510 --> 00:48:33,890
what do you do you spin so I could we

1188
00:48:33,890 --> 00:48:38,380
don't yes

1189
00:48:55,490 --> 00:48:59,270
no you make it latch free yes if you

1190
00:48:59,270 --> 00:49:01,070
don't wanna make a latch free then like

1191
00:49:01,070 --> 00:49:03,589
you take a latch do the update yes then

1192
00:49:03,589 --> 00:49:04,500
you have a B+ tree

1193
00:49:04,500 --> 00:49:08,340
yes so like if you whenever you try to

1194
00:49:08,340 --> 00:49:10,290
recompute this like consolidated note

1195
00:49:10,290 --> 00:49:12,030
yes pray and like let's see go back to

1196
00:49:12,030 --> 00:49:14,010
compare and swap that you fail right I

1197
00:49:14,010 --> 00:49:15,330
don't necessarily think you actually

1198
00:49:15,330 --> 00:49:16,410
that throw it all that work because you

1199
00:49:16,410 --> 00:49:17,580
could essentially read all this new

1200
00:49:17,580 --> 00:49:19,349
chain and then see where like your

1201
00:49:19,349 --> 00:49:20,760
change in this last word and then

1202
00:49:20,760 --> 00:49:22,380
updating compares about that one point I

1203
00:49:22,380 --> 00:49:24,330
ready to swap yourself like if you're

1204
00:49:24,330 --> 00:49:26,070
right if this is just an insert you

1205
00:49:26,070 --> 00:49:28,170
could say alright I missed it just put

1206
00:49:28,170 --> 00:49:30,450
it in and then try it again I don't

1207
00:49:30,450 --> 00:49:31,910
think we do that I think we play it safe

1208
00:49:31,910 --> 00:49:33,869
because again if you have a split or

1209
00:49:33,869 --> 00:49:35,849
merge that's why that's what that's when

1210
00:49:35,849 --> 00:49:41,970
things get bad yeah all right so one or

1211
00:49:41,970 --> 00:49:43,980
two is new one or two is installed this

1212
00:49:43,980 --> 00:49:45,330
guy's sitting around what do we need to

1213
00:49:45,330 --> 00:49:47,520
do with it you wouldn't we obviously

1214
00:49:47,520 --> 00:49:48,780
want to clean it up at some point right

1215
00:49:48,780 --> 00:49:50,700
so these things can be marked as garbage

1216
00:49:50,700 --> 00:49:52,260
and at some point we need to clean them

1217
00:49:52,260 --> 00:49:54,060
up what does this look like this is

1218
00:49:54,060 --> 00:49:55,650
starting to look like MVCC right once we

1219
00:49:55,650 --> 00:49:56,790
recognize that something's no longer

1220
00:49:56,790 --> 00:49:58,830
visible to bunch of threads or

1221
00:49:58,830 --> 00:50:01,500
transactions in MVCC world then we want

1222
00:50:01,500 --> 00:50:02,790
to go ahead and clean this up and reuse

1223
00:50:02,790 --> 00:50:06,359
the memory so this now looks a little

1224
00:50:06,359 --> 00:50:09,450
bit different though then slightly

1225
00:50:09,450 --> 00:50:10,260
different than what we've talked about

1226
00:50:10,260 --> 00:50:12,000
before but the high/low idea is going to

1227
00:50:12,000 --> 00:50:14,730
be the same all right so what for

1228
00:50:14,730 --> 00:50:15,900
garbage collection for these in memory

1229
00:50:15,900 --> 00:50:17,310
data structures what do we what's what's

1230
00:50:17,310 --> 00:50:19,380
the issue well we don't want to throw

1231
00:50:19,380 --> 00:50:21,990
away something that somebody could be

1232
00:50:21,990 --> 00:50:23,700
reading a jump into because then they'll

1233
00:50:23,700 --> 00:50:25,349
have a seg fault because a reading you

1234
00:50:25,349 --> 00:50:27,660
know unallocated memory so like say I

1235
00:50:27,660 --> 00:50:29,670
want to delete k2 here and this is a

1236
00:50:29,670 --> 00:50:31,020
simple single Direction linked list

1237
00:50:31,020 --> 00:50:33,720
right my thread is here it's at the key

1238
00:50:33,720 --> 00:50:35,520
one it sees the physical pointer now to

1239
00:50:35,520 --> 00:50:37,650
the next key then the garbage capture

1240
00:50:37,650 --> 00:50:40,020
comes in cleans up this thing but now I

1241
00:50:40,020 --> 00:50:41,700
follow this pointer just some random

1242
00:50:41,700 --> 00:50:44,040
invalid you know and your member dress

1243
00:50:44,040 --> 00:50:46,550
that doesn't mean anything anymore and

1244
00:50:46,550 --> 00:50:48,780
you know worst case scenario I said fall

1245
00:50:48,780 --> 00:50:50,280
actually worth chasing they're also like

1246
00:50:50,280 --> 00:50:51,540
I could read garbage and think it's

1247
00:50:51,540 --> 00:50:54,030
something real right so we want to avoid

1248
00:50:54,030 --> 00:50:56,730
this so the two approaches we'll talk

1249
00:50:56,730 --> 00:50:58,080
about our reference counting an epoch

1250
00:50:58,080 --> 00:50:59,940
based reclamation there's a bunch of

1251
00:50:59,940 --> 00:51:03,500
other techniques to use hazard pointers

1252
00:51:03,500 --> 00:51:06,060
what's the other one I forget to forget

1253
00:51:06,060 --> 00:51:07,320
what they're called it does matter like

1254
00:51:07,320 --> 00:51:09,210
there's other things these are two ones

1255
00:51:09,210 --> 00:51:11,099
that the the most prominent most common

1256
00:51:11,099 --> 00:51:15,300
in in memory databases so reference

1257
00:51:15,300 --> 00:51:16,349
counting is essentially what you get

1258
00:51:16,349 --> 00:51:17,670
with the shared pointer on the Unruh

1259
00:51:17,670 --> 00:51:17,940
Steven

1260
00:51:17,940 --> 00:51:19,829
Plus on a standard template library so

1261
00:51:19,829 --> 00:51:22,920
all it is now is that inside of every

1262
00:51:22,920 --> 00:51:24,450
node in a data structure or in a

1263
00:51:24,450 --> 00:51:25,710
SharePoint inside the points the the

1264
00:51:25,710 --> 00:51:27,810
pointer data structure itself we're just

1265
00:51:27,810 --> 00:51:29,910
gonna maintain a counter that keeps

1266
00:51:29,910 --> 00:51:32,130
track of the number of threads that

1267
00:51:32,130 --> 00:51:34,230
could be accessing a that memory

1268
00:51:34,230 --> 00:51:36,750
location I inserted before I go access

1269
00:51:36,750 --> 00:51:38,760
it I increment the counter that's at an

1270
00:51:38,760 --> 00:51:40,530
atomic add right that's that part's

1271
00:51:40,530 --> 00:51:42,510
efficient but then when I'm done doing

1272
00:51:42,510 --> 00:51:44,579
you know accessing it then I decrement

1273
00:51:44,579 --> 00:51:46,440
that counter to by one

1274
00:51:46,440 --> 00:51:48,839
so the garbage collector would know that

1275
00:51:48,839 --> 00:51:51,450
it's safe to reality to deallocate some

1276
00:51:51,450 --> 00:51:53,730
region of memory when we know that our

1277
00:51:53,730 --> 00:51:55,290
counter is zero because we know no

1278
00:51:55,290 --> 00:51:56,940
thread could be looking at it so long as

1279
00:51:56,940 --> 00:51:58,500
everyone updates that Conn before they

1280
00:51:58,500 --> 00:52:00,810
jump to the next location right we won't

1281
00:52:00,810 --> 00:52:03,300
have it have an issue turns out though

1282
00:52:03,300 --> 00:52:04,650
this is actually really bad for

1283
00:52:04,650 --> 00:52:07,920
performance because now I'm probably

1284
00:52:07,920 --> 00:52:09,329
every single time I jump to a new

1285
00:52:09,329 --> 00:52:11,160
location I'm incrementing this counter

1286
00:52:11,160 --> 00:52:12,960
and that's a global counter that

1287
00:52:12,960 --> 00:52:14,010
everybody needs to be able to read and

1288
00:52:14,010 --> 00:52:15,569
write so if I have a lot of course a lot

1289
00:52:15,569 --> 00:52:17,220
of sockets that's a cache invalidation

1290
00:52:17,220 --> 00:52:19,109
message to everyone just to go read

1291
00:52:19,109 --> 00:52:26,010
something yes especially this is this

1292
00:52:26,010 --> 00:52:27,359
invalidation also apply when updating

1293
00:52:27,359 --> 00:52:33,480
the map in general yes but but I can

1294
00:52:33,480 --> 00:52:34,680
read the mapping table without having

1295
00:52:34,680 --> 00:52:37,079
updated this turns every read into a

1296
00:52:37,079 --> 00:52:43,050
write this is bad right so again this is

1297
00:52:43,050 --> 00:52:46,740
what you get and share pointers and this

1298
00:52:46,740 --> 00:52:48,510
you know this is obviously gonna be slow

1299
00:52:48,510 --> 00:52:51,119
so one obvious thing to point out though

1300
00:52:51,119 --> 00:52:54,780
is we don't actually care what that

1301
00:52:54,780 --> 00:52:57,200
counter actually the value actually is

1302
00:52:57,200 --> 00:52:59,700
all we really care is whether it's

1303
00:52:59,700 --> 00:53:03,990
nonzero right so whether it's 1 2 4

1304
00:53:03,990 --> 00:53:05,730
whatever who cares we know somebody's

1305
00:53:05,730 --> 00:53:07,319
reading it we can't garb something it's

1306
00:53:07,319 --> 00:53:09,990
only when it's 0 do we do we actually

1307
00:53:09,990 --> 00:53:11,849
care so maybe instead of storing this

1308
00:53:11,849 --> 00:53:15,540
fine-grain counter per per node in our

1309
00:53:15,540 --> 00:53:17,790
data structure we could just try to keep

1310
00:53:17,790 --> 00:53:19,800
track of a higher level contract more

1311
00:53:19,800 --> 00:53:22,200
coarse-grained counter and just know

1312
00:53:22,200 --> 00:53:24,540
that when nothing can be visible to by

1313
00:53:24,540 --> 00:53:27,390
anybody within some some time range just

1314
00:53:27,390 --> 00:53:29,250
like an MVC see then it's safe for us to

1315
00:53:29,250 --> 00:53:30,430
go ahead and promote

1316
00:53:30,430 --> 00:53:33,640
things so this is what EPA epoch base

1317
00:53:33,640 --> 00:53:35,770
grabber selection is and we briefly

1318
00:53:35,770 --> 00:53:38,710
mentioned this last class and I said I

1319
00:53:38,710 --> 00:53:40,150
was going to spend more time than on it

1320
00:53:40,150 --> 00:53:42,430
today but again the high-level idea of

1321
00:53:42,430 --> 00:53:44,020
what we did msec for epoch base copper

1322
00:53:44,020 --> 00:53:45,849
collection is the same one here so

1323
00:53:45,849 --> 00:53:48,339
there's me this global counter that's me

1324
00:53:48,339 --> 00:53:50,500
periodically updated like you can have a

1325
00:53:50,500 --> 00:53:52,349
thread do this or cooperatively

1326
00:53:52,349 --> 00:53:54,970
cooperatively every 10 milliseconds and

1327
00:53:54,970 --> 00:53:57,010
the only thing we need to keep track of

1328
00:53:57,010 --> 00:53:59,680
now in our in our index is that what

1329
00:53:59,680 --> 00:54:02,619
threads exist at a given a POC I went

1330
00:54:02,619 --> 00:54:04,329
what time did they show up what you pop

1331
00:54:04,329 --> 00:54:06,160
do they show up and then when did they

1332
00:54:06,160 --> 00:54:10,240
leave and I don't care what you pocket

1333
00:54:10,240 --> 00:54:11,829
that they left in all i care is that

1334
00:54:11,829 --> 00:54:14,349
like that they did leave so I could show

1335
00:54:14,349 --> 00:54:17,170
up an epoch one then I leave epoch -

1336
00:54:17,170 --> 00:54:18,609
that's fine but I'm still only

1337
00:54:18,609 --> 00:54:22,240
considered to be an epoch one and then

1338
00:54:22,240 --> 00:54:24,130
now what'll happen is when we do our

1339
00:54:24,130 --> 00:54:26,500
consolidation we'll say what's the

1340
00:54:26,500 --> 00:54:31,119
current epoch of my of this node or so

1341
00:54:31,119 --> 00:54:32,980
what's the current epoch of the B but B

1342
00:54:32,980 --> 00:54:33,730
EE

1343
00:54:33,730 --> 00:54:35,980
I mark that garbage with that epoch and

1344
00:54:35,980 --> 00:54:37,809
then once I know that there's no threat

1345
00:54:37,809 --> 00:54:40,690
could we possibly see that node because

1346
00:54:40,690 --> 00:54:42,640
they're not in that epoch anymore then

1347
00:54:42,640 --> 00:54:45,220
it's safe for me to go ahead and delete

1348
00:54:45,220 --> 00:54:48,790
it remove it so in Linux this is called

1349
00:54:48,790 --> 00:54:50,890
our Cu recopy update this is used in

1350
00:54:50,890 --> 00:54:52,480
various different data structures

1351
00:54:52,480 --> 00:54:55,240
internally inside of the kernel to go

1352
00:54:55,240 --> 00:54:56,799
read systems papers they'll refer to

1353
00:54:56,799 --> 00:54:58,329
this as our Cu in database papers we've

1354
00:54:58,329 --> 00:54:59,980
heard of this epoch based garbage

1355
00:54:59,980 --> 00:55:03,190
collection all right so now to do this

1356
00:55:03,190 --> 00:55:04,540
again and this is just repeating what I

1357
00:55:04,540 --> 00:55:06,880
said but every tree again we tagged

1358
00:55:06,880 --> 00:55:08,589
everything we're gonna do any search

1359
00:55:08,589 --> 00:55:10,750
insert or delete is tagged with my

1360
00:55:10,750 --> 00:55:13,780
current epoch is we register with the

1361
00:55:13,780 --> 00:55:15,490
garbage collector when a thread shows up

1362
00:55:15,490 --> 00:55:17,559
say you know I'm showing up and then do

1363
00:55:17,559 --> 00:55:19,690
something I'm in this epoch and then

1364
00:55:19,690 --> 00:55:21,490
when you leave you D register and then

1365
00:55:21,490 --> 00:55:22,750
the garbage collection can say I know

1366
00:55:22,750 --> 00:55:24,400
that nobody else is in this epoch here's

1367
00:55:24,400 --> 00:55:26,319
a bunch of garbage for that epoch let me

1368
00:55:26,319 --> 00:55:29,290
go ahead and remove it so let's look at

1369
00:55:29,290 --> 00:55:30,339
this example here so this is the same

1370
00:55:30,339 --> 00:55:32,140
one we had before we get our cut we're

1371
00:55:32,140 --> 00:55:35,440
gonna do a consolidation on on 102 so

1372
00:55:35,440 --> 00:55:38,020
CPU 1 thread 1 is gonna do this

1373
00:55:38,020 --> 00:55:41,200
consolidation so it when it showed up in

1374
00:55:41,200 --> 00:55:42,670
the very beginning it just registered

1375
00:55:42,670 --> 00:55:43,809
with this epoch table said the garbage

1376
00:55:43,809 --> 00:55:44,290
collector

1377
00:55:44,290 --> 00:55:46,060
all right and now there's some other

1378
00:55:46,060 --> 00:55:48,310
thread thread - all right that's gonna

1379
00:55:48,310 --> 00:55:51,550
be scanning this at the same time so we

1380
00:55:51,550 --> 00:55:52,630
registered with the epoch table so now

1381
00:55:52,630 --> 00:55:54,250
we do now the compare-and-swap

1382
00:55:54,250 --> 00:55:58,780
to update 102 and now nobody else that

1383
00:55:58,780 --> 00:56:02,260
comes in after this point will ever see

1384
00:56:02,260 --> 00:56:04,870
this original thing but this thread here

1385
00:56:04,870 --> 00:56:07,210
is still hanging out we actually don't

1386
00:56:07,210 --> 00:56:08,670
know where it is it could be anywhere

1387
00:56:08,670 --> 00:56:10,570
inside the data structure looking any

1388
00:56:10,570 --> 00:56:13,540
node but it could potentially be in here

1389
00:56:13,540 --> 00:56:15,490
so instead of tracking exactly you know

1390
00:56:15,490 --> 00:56:17,140
what no damn I'm looking at or what

1391
00:56:17,140 --> 00:56:18,460
Delta rather looking at every single

1392
00:56:18,460 --> 00:56:20,080
time we just say hey there's somebody

1393
00:56:20,080 --> 00:56:23,560
around that you know within this time so

1394
00:56:23,560 --> 00:56:26,140
now we registered this garbage with it

1395
00:56:26,140 --> 00:56:29,350
and but then epoch this first epoch this

1396
00:56:29,350 --> 00:56:32,110
guy goes away and we D register this

1397
00:56:32,110 --> 00:56:33,880
guy's scans down and then when he finds

1398
00:56:33,880 --> 00:56:35,190
whatever he's looking for in page 102

1399
00:56:35,190 --> 00:56:37,630
right and then when he's done it's safe

1400
00:56:37,630 --> 00:56:40,780
for us to go ahead and delete this right

1401
00:56:40,780 --> 00:56:42,730
so instead of actually giving every node

1402
00:56:42,730 --> 00:56:44,080
a timestamp or every Delta record on

1403
00:56:44,080 --> 00:56:46,300
timestamp like an MVC see we just have

1404
00:56:46,300 --> 00:56:55,270
this chorus granny box yes the epoch

1405
00:56:55,270 --> 00:56:57,040
gave us means the entire instance of the

1406
00:56:57,040 --> 00:57:01,060
data structure all it is it's just it's

1407
00:57:01,060 --> 00:57:03,850
just a it's a pointer to the physical

1408
00:57:03,850 --> 00:57:07,120
address of this node here so this says

1409
00:57:07,120 --> 00:57:10,450
like alright if I've register this

1410
00:57:10,450 --> 00:57:12,820
garbage here I'm not actually making a

1411
00:57:12,820 --> 00:57:14,020
copy of this we're storing the pointer

1412
00:57:14,020 --> 00:57:15,820
to the head of it there's out the record

1413
00:57:15,820 --> 00:57:18,370
chain so then I know that anything any

1414
00:57:18,370 --> 00:57:20,200
doubt the record and the base table base

1415
00:57:20,200 --> 00:57:23,670
page itself can be garbage collected

1416
00:57:24,150 --> 00:57:26,740
again nobody else can can never jump to

1417
00:57:26,740 --> 00:57:27,790
this because we did a compare and swap

1418
00:57:27,790 --> 00:57:29,650
here and we're able to you know and now

1419
00:57:29,650 --> 00:57:34,630
point to the new page yes your question

1420
00:57:34,630 --> 00:57:36,310
is is what is the data structure of

1421
00:57:36,310 --> 00:57:40,080
edging the threads yeah it's just a cue

1422
00:57:40,950 --> 00:57:43,450
array like it could be array pointing to

1423
00:57:43,450 --> 00:57:44,650
a cue because you could cycle through

1424
00:57:44,650 --> 00:57:47,950
the epochs yes it could be a bottleneck

1425
00:57:47,950 --> 00:57:50,860
but traversing the index itself is more

1426
00:57:50,860 --> 00:57:54,030
expensive than that yes

1427
00:57:59,270 --> 00:58:06,660
so we're back here we're here so what if

1428
00:58:06,660 --> 00:58:08,700
somebody else creates a new Delta record

1429
00:58:08,700 --> 00:58:10,500
here while we're doing compaction what

1430
00:58:10,500 --> 00:58:11,520
would happen when I do the compare and

1431
00:58:11,520 --> 00:58:14,430
swap I would fail because it's now

1432
00:58:14,430 --> 00:58:16,049
pointing to now some dealt with record

1433
00:58:16,049 --> 00:58:17,819
above this that I didn't see and that's

1434
00:58:17,819 --> 00:58:19,460
what I was saying to him like you could

1435
00:58:19,460 --> 00:58:21,930
be smart saying oh well this is just

1436
00:58:21,930 --> 00:58:25,380
another insert let me reapply it and

1437
00:58:25,380 --> 00:58:28,710
then do the compare and swap for that

1438
00:58:28,710 --> 00:58:30,030
one you basically do add if you're

1439
00:58:30,030 --> 00:58:31,170
trying to figure out well what did I

1440
00:58:31,170 --> 00:58:32,160
have and what did I miss

1441
00:58:32,160 --> 00:58:33,660
so it's just one maybe it's not a big

1442
00:58:33,660 --> 00:58:34,950
big of a deal but it's a bunch of them

1443
00:58:34,950 --> 00:58:36,270
you might just be better off just

1444
00:58:36,270 --> 00:58:38,609
restarting but again the compare and

1445
00:58:38,609 --> 00:58:40,049
swap because this mapping table

1446
00:58:40,049 --> 00:58:41,819
guarantees that this thing is always

1447
00:58:41,819 --> 00:58:44,309
gonna be like the ground truth of what

1448
00:58:44,309 --> 00:58:45,839
the correct what the correct pointer

1449
00:58:45,839 --> 00:58:47,790
should be so it's not what we think it

1450
00:58:47,790 --> 00:58:49,410
is somebody else got in before before we

1451
00:58:49,410 --> 00:58:58,349
did okay so far so good right let's make

1452
00:58:58,349 --> 00:59:00,240
it hard let's do splits emerges right

1453
00:59:00,240 --> 00:59:01,680
though this book will just focus on

1454
00:59:01,680 --> 00:59:04,200
splits merges essentially the same thing

1455
00:59:04,200 --> 00:59:05,940
in reverse order so now we're gonna

1456
00:59:05,940 --> 00:59:09,299
introduce two new types of archetypes

1457
00:59:09,299 --> 00:59:10,770
the split delta record and the separator

1458
00:59:10,770 --> 00:59:13,079
so the split is going to be a delta

1459
00:59:13,079 --> 00:59:16,500
record that says that the node paid the

1460
00:59:16,500 --> 00:59:18,359
base page below us in our and that in

1461
00:59:18,359 --> 00:59:20,220
our delta chain has been split and

1462
00:59:20,220 --> 00:59:22,829
here's where to go find the two new

1463
00:59:22,829 --> 00:59:24,809
boundaries of keys so we'll have a

1464
00:59:24,809 --> 00:59:27,089
physical pointer down to the the next

1465
00:59:27,089 --> 00:59:29,130
delta record and then a logical pointer

1466
00:59:29,130 --> 00:59:31,589
to the page they got we got split off

1467
00:59:31,589 --> 00:59:35,400
from and then a separator Delta record

1468
00:59:35,400 --> 00:59:36,990
it's not required for correctness but

1469
00:59:36,990 --> 00:59:40,049
it's just a it's a shortcut up above in

1470
00:59:40,049 --> 00:59:42,000
in the higher part students to tree to

1471
00:59:42,000 --> 00:59:44,400
say oh by the way below you there was a

1472
00:59:44,400 --> 00:59:46,230
split here's where to go find the things

1473
00:59:46,230 --> 00:59:48,420
you're looking for so let's look at

1474
00:59:48,420 --> 00:59:50,599
example here so now you have four pages

1475
00:59:50,599 --> 00:59:53,190
and we're gonna want to do is and then

1476
00:59:53,190 --> 00:59:54,540
the keys are sort organized like this

1477
00:59:54,540 --> 00:59:58,200
and we want to do a split on one 103 so

1478
00:59:58,200 --> 01:00:01,260
say we want to insert actually let's do

1479
01:00:01,260 --> 01:00:04,020
a split we don't insert anything so the

1480
01:00:04,020 --> 01:00:07,440
first thing I'm gonna do is do a split

1481
01:00:07,440 --> 01:00:08,190
in you know

1482
01:00:08,190 --> 01:00:10,410
from my thread what you know with a

1483
01:00:10,410 --> 01:00:11,760
virtual note here the thick nobody could

1484
01:00:11,760 --> 01:00:13,319
actually see yet and then he's just now

1485
01:00:13,319 --> 01:00:16,859
pointing to the next sibling 104 so now

1486
01:00:16,859 --> 01:00:20,099
I'm gonna do a compare and swap here

1487
01:00:20,099 --> 01:00:22,230
nobody else could get in it before I did

1488
01:00:22,230 --> 01:00:23,819
so that's not a big deal but I want to

1489
01:00:23,819 --> 01:00:27,720
update now the the Delta record of Delta

1490
01:00:27,720 --> 01:00:29,670
chain from 103 with this new split

1491
01:00:29,670 --> 01:00:33,030
record here right and the way what the

1492
01:00:33,030 --> 01:00:34,380
split burgers gonna store is that

1493
01:00:34,380 --> 01:00:35,970
there's the physical pointer to the base

1494
01:00:35,970 --> 01:00:38,130
page and that just says key three key

1495
01:00:38,130 --> 01:00:40,740
three keys keep three to five are here

1496
01:00:40,740 --> 01:00:43,349
and then five this key seven or over

1497
01:00:43,349 --> 01:00:45,200
here and this is just a logical pointer

1498
01:00:45,200 --> 01:00:49,170
so now I do my compare and swap to now

1499
01:00:49,170 --> 01:00:52,770
update 103 to be now pointing at my mind

1500
01:00:52,770 --> 01:00:54,750
you split record so now anybody that

1501
01:00:54,750 --> 01:00:57,420
comes along is looking for key five for

1502
01:00:57,420 --> 01:01:00,270
example will come down follow this the

1503
01:01:00,270 --> 01:01:01,430
Virgin chain here

1504
01:01:01,430 --> 01:01:03,390
okay these all get updated to

1505
01:01:03,390 --> 01:01:04,589
automatically again because I have the

1506
01:01:04,589 --> 01:01:06,210
mapping table all right these guys have

1507
01:01:06,210 --> 01:01:08,010
logical pointers it turns like up there

1508
01:01:08,010 --> 01:01:09,540
that everyone automatically now points

1509
01:01:09,540 --> 01:01:11,190
with a split record so anybody coming

1510
01:01:11,190 --> 01:01:13,710
along either from from the bottling

1511
01:01:13,710 --> 01:01:15,569
pointer or from the top let's see the

1512
01:01:15,569 --> 01:01:17,460
split record and recognize oh well if

1513
01:01:17,460 --> 01:01:19,050
I'm looking for key five I want to

1514
01:01:19,050 --> 01:01:20,940
follow a logical pointer here otherwise

1515
01:01:20,940 --> 01:01:22,560
follow the physical pointer down here

1516
01:01:22,560 --> 01:01:24,660
now this point here we actually ever

1517
01:01:24,660 --> 01:01:26,369
done two copies of key five and key 6

1518
01:01:26,369 --> 01:01:28,680
right they're still stored in in 103

1519
01:01:28,680 --> 01:01:31,589
because we can't do in place updates so

1520
01:01:31,589 --> 01:01:33,960
you so when you're now traversing like

1521
01:01:33,960 --> 01:01:35,400
down here and saying I'm trying to find

1522
01:01:35,400 --> 01:01:37,859
keys greater than four for example I

1523
01:01:37,859 --> 01:01:39,990
would have to remember that I saw a

1524
01:01:39,990 --> 01:01:42,630
split record up above that said alright

1525
01:01:42,630 --> 01:01:44,190
this note here if you looking for

1526
01:01:44,190 --> 01:01:45,800
anything greater than C five or greater

1527
01:01:45,800 --> 01:01:48,119
should not be short on one or three even

1528
01:01:48,119 --> 01:01:49,619
though you may see it in this one or

1529
01:01:49,619 --> 01:01:51,630
this one or three you know you need to

1530
01:01:51,630 --> 01:01:53,720
go find it down down here and 105

1531
01:01:53,720 --> 01:02:00,690
alright so then now I need to sort of

1532
01:02:00,690 --> 01:02:02,940
propagate this key space up above or key

1533
01:02:02,940 --> 01:02:06,240
or split up above so at this point here

1534
01:02:06,240 --> 01:02:09,540
the root table has the still the

1535
01:02:09,540 --> 01:02:11,490
original splits or demarcations for

1536
01:02:11,490 --> 01:02:14,670
what's below me and so if i from a

1537
01:02:14,670 --> 01:02:16,079
correctness standpoint if I follow it in

1538
01:02:16,079 --> 01:02:17,609
here and I'm looking for something key

1539
01:02:17,609 --> 01:02:21,450
five I would say key threes keep I was

1540
01:02:21,450 --> 01:02:21,990
in case

1541
01:02:21,990 --> 01:02:24,090
and k7 and still follow that logical

1542
01:02:24,090 --> 01:02:26,280
pointer down to the split one and then I

1543
01:02:26,280 --> 01:02:27,690
would recognize I really need to go down

1544
01:02:27,690 --> 01:02:28,920
to this other side now this other side

1545
01:02:28,920 --> 01:02:32,640
but to avoid having to you know do that

1546
01:02:32,640 --> 01:02:35,190
as necessary look up I could insert a

1547
01:02:35,190 --> 01:02:39,270
separator record that just says all

1548
01:02:39,270 --> 01:02:42,290
right well key 5k7 are now at this new

1549
01:02:42,290 --> 01:02:44,250
here's a logic component to this new

1550
01:02:44,250 --> 01:02:46,320
node here right

1551
01:02:46,320 --> 01:02:48,750
same thing compare and swap on this gal

1552
01:02:48,750 --> 01:02:50,760
that gets installed and anybody else

1553
01:02:50,760 --> 01:02:52,830
comes along with but see this okay and

1554
01:02:52,830 --> 01:02:53,760
you don't need to separate it for

1555
01:02:53,760 --> 01:02:55,170
correctness it's it's just for

1556
01:02:55,170 --> 01:02:57,990
efficiency reasons and then when I do

1557
01:02:57,990 --> 01:02:59,850
consolidation obviously compact it and

1558
01:02:59,850 --> 01:03:12,150
update this correctly any questions the

1559
01:03:12,150 --> 01:03:14,160
logic point is what what is a lot of a

1560
01:03:14,160 --> 01:03:17,869
pointer what are we actually storing

1561
01:03:17,869 --> 01:03:22,020
yeah hey ready so if I'm scanning along

1562
01:03:22,020 --> 01:03:23,610
like final Keys greater than greater

1563
01:03:23,610 --> 01:03:24,780
than equal okay k2

1564
01:03:24,780 --> 01:03:27,150
I would land here I say all right well I

1565
01:03:27,150 --> 01:03:28,680
see k2 but I want to keep going so I'm

1566
01:03:28,680 --> 01:03:30,630
looking for he's greater than k2 oh I

1567
01:03:30,630 --> 01:03:32,280
need to follow my sibling pointer my

1568
01:03:32,280 --> 01:03:35,609
sibling pointer is page 103 right that's

1569
01:03:35,609 --> 01:03:37,050
what you know that's sort of this thing

1570
01:03:37,050 --> 01:03:39,359
is but I'm just only storing you know

1571
01:03:39,359 --> 01:03:40,830
the ID one two three here it's in order

1572
01:03:40,830 --> 01:03:42,330
to get to there I go look my mapping

1573
01:03:42,330 --> 01:03:44,790
table and wallah now my physical dress

1574
01:03:44,790 --> 01:03:47,430
points to here and then and I can either

1575
01:03:47,430 --> 01:03:49,140
scan down find when I mean you split the

1576
01:03:49,140 --> 01:03:53,540
one side to the other as needed yes

1577
01:04:01,070 --> 01:04:04,020
question is when I did the split here

1578
01:04:04,020 --> 01:04:06,330
would 105 1 3 show the same doesn't

1579
01:04:06,330 --> 01:04:06,600
change

1580
01:04:06,600 --> 01:04:13,710
now the split is the Delta chain of 103

1581
01:04:13,710 --> 01:04:16,430
because that's what we're back here

1582
01:04:16,430 --> 01:04:20,490
right so again I just copied out the

1583
01:04:20,490 --> 01:04:23,580
keys I need for 105 now I have a split

1584
01:04:23,580 --> 01:04:25,859
record here and I want to have anybody

1585
01:04:25,859 --> 01:04:28,140
that ghost of 103 should know that I

1586
01:04:28,140 --> 01:04:31,950
split right so my compare-and-swap needs

1587
01:04:31,950 --> 01:04:34,980
to be on this guy's delta chain this guy

1588
01:04:34,980 --> 01:04:35,910
has his own doesn't

1589
01:04:35,910 --> 01:04:38,470
and again if I now start making changes

1590
01:04:38,470 --> 01:04:39,670
to page 105

1591
01:04:39,670 --> 01:04:41,320
well that's gonna have its own Delta

1592
01:04:41,320 --> 01:04:44,230
Delta chain but the logical pointer to

1593
01:04:44,230 --> 01:04:46,420
it will still get knee to the head of

1594
01:04:46,420 --> 01:04:58,660
that double chain if anything goes to

1595
01:04:58,660 --> 01:05:00,880
103 there should be going to 104 you

1596
01:05:00,880 --> 01:05:03,130
like the separator so now the separator

1597
01:05:03,130 --> 01:05:04,540
just allows you to avoid having to do

1598
01:05:04,540 --> 01:05:06,730
like an extra actually lookups going

1599
01:05:06,730 --> 01:05:09,370
down in say so you're saving as

1600
01:05:09,370 --> 01:05:10,840
something that should be in 105 can

1601
01:05:10,840 --> 01:05:13,120
never end up at 1 or 3 yeah because we

1602
01:05:13,120 --> 01:05:15,010
can't because like I've displayed record

1603
01:05:15,010 --> 01:05:16,930
say well if I want to insert say a key

1604
01:05:16,930 --> 01:05:20,140
5.5 this should be in between 5 5 & 5 &

1605
01:05:20,140 --> 01:05:23,350
6 I would get here 5.5 is greater than

1606
01:05:23,350 --> 01:05:26,170
or equal to 5 so therefore it has to go

1607
01:05:26,170 --> 01:05:30,760
here I can't I can never get there why

1608
01:05:30,760 --> 01:05:35,650
wouldn't you if you're here yes when

1609
01:05:35,650 --> 01:05:38,230
you're up here no yes so like if there's

1610
01:05:38,230 --> 01:05:40,090
a lot of lines here so confusing sorry

1611
01:05:40,090 --> 01:05:43,240
so the root note still thinks that if

1612
01:05:43,240 --> 01:05:45,490
I'm looking for key range k3 to k7 I

1613
01:05:45,490 --> 01:05:49,050
should be looking at a logical pointer

1614
01:05:49,050 --> 01:05:55,240
103 right so this arrow should really be

1615
01:05:55,240 --> 01:05:58,240
here but physically when I do the lookup

1616
01:05:58,240 --> 01:05:59,890
I'm gonna land this split so I'm looking

1617
01:05:59,890 --> 01:06:02,710
for key 5 I do my I think it should be

1618
01:06:02,710 --> 01:06:04,660
in page 1 2 3 I landed a delta record

1619
01:06:04,660 --> 01:06:06,430
that that's a split and I would

1620
01:06:06,430 --> 01:06:08,200
recognize Oh split therefore I need to

1621
01:06:08,200 --> 01:06:09,760
look at the boundaries in the split and

1622
01:06:09,760 --> 01:06:23,680
then that'll take me left or right here

1623
01:06:23,680 --> 01:06:25,210
so this is the separator key is

1624
01:06:25,210 --> 01:06:28,800
basically updating this information yeah

1625
01:06:28,800 --> 01:06:31,300
so once this thing's installed and I'm

1626
01:06:31,300 --> 01:06:34,120
looking for key 5 I could potentially go

1627
01:06:34,120 --> 01:06:36,670
now down here again this is like say I

1628
01:06:36,670 --> 01:06:38,500
could store four things in this node and

1629
01:06:38,500 --> 01:06:40,180
I don't need to split it instead of

1630
01:06:40,180 --> 01:06:42,520
having to do in place update to add a

1631
01:06:42,520 --> 01:06:44,260
fourth entry or a guidepost

1632
01:06:44,260 --> 01:06:46,270
in this thing this the separator thing

1633
01:06:46,270 --> 01:06:49,000
does that for me yeah yes

1634
01:06:49,000 --> 01:06:50,380
so I'm going back to the previous

1635
01:06:50,380 --> 01:06:52,300
questions where if you do convince water

1636
01:06:52,300 --> 01:06:54,340
fails you would essentially see that's

1637
01:06:54,340 --> 01:06:56,920
pretty low right so if the comparative

1638
01:06:56,920 --> 01:06:59,560
Vic parents ops fails where whatever

1639
01:06:59,560 --> 01:07:02,400
like when you're trying to update like

1640
01:07:02,400 --> 01:07:03,790
so here

1641
01:07:03,790 --> 01:07:06,760
yeah so in the implementation and you

1642
01:07:06,760 --> 01:07:08,230
guys did that you have to go star upon

1643
01:07:08,230 --> 01:07:10,270
the news because you might not be going

1644
01:07:10,270 --> 01:07:11,680
to the same page correct

1645
01:07:11,680 --> 01:07:13,570
1:03 of like a shaved you go dude 105

1646
01:07:13,570 --> 01:07:16,540
yes so but I but the one that fails that

1647
01:07:16,540 --> 01:07:19,360
we were actually see this prenup cat so

1648
01:07:19,360 --> 01:07:21,310
if that's Ryan right now it could just

1649
01:07:21,310 --> 01:07:23,890
actually follow the logical 0.02 to 105

1650
01:07:23,890 --> 01:07:26,770
and it doesn't happen if it fails where

1651
01:07:26,770 --> 01:07:35,080
when at 103 like they say insert k72 103

1652
01:07:35,080 --> 01:07:39,420
keep 5.5 I'm trying to sir Kay 5.5 and

1653
01:07:39,420 --> 01:07:43,630
yes so in seats you're here this has

1654
01:07:43,630 --> 01:07:47,130
been updated and you will see the

1655
01:07:48,180 --> 01:07:50,380
correct there I think there are some

1656
01:07:50,380 --> 01:07:51,790
optimizations I don't know whether we do

1657
01:07:51,790 --> 01:07:54,010
them all we're like five compare swap

1658
01:07:54,010 --> 01:07:55,990
fails and I recognize oh well if I come

1659
01:07:55,990 --> 01:07:57,430
back and read what am I seeing

1660
01:07:57,430 --> 01:07:59,830
I could then use that as a way to jump

1661
01:07:59,830 --> 01:08:01,810
to what I'm looking for I think we are

1662
01:08:01,810 --> 01:08:03,370
very conservative and we don't always do

1663
01:08:03,370 --> 01:08:11,470
that in the implementation yes sir

1664
01:08:11,470 --> 01:08:13,900
question is when I'm creating if I'm

1665
01:08:13,900 --> 01:08:17,380
creating 105 how do i what I apply

1666
01:08:17,380 --> 01:08:20,140
changes yes and I would know again you

1667
01:08:20,140 --> 01:08:22,420
know what you're splitting on so if it's

1668
01:08:22,420 --> 01:08:24,700
like delete k4 I ignore it because I'm

1669
01:08:24,700 --> 01:08:26,799
not not that's not in mine but it's like

1670
01:08:26,799 --> 01:08:29,920
insert k 5.5 that should be in mine then

1671
01:08:29,920 --> 01:08:30,609
I apply it

1672
01:08:30,609 --> 01:08:38,229
yes question is are the split and

1673
01:08:38,229 --> 01:08:40,210
separator at atomically again I can only

1674
01:08:40,210 --> 01:08:41,710
do one thing atomically I can only

1675
01:08:41,710 --> 01:08:43,180
update one address in the mapping table

1676
01:08:43,180 --> 01:08:45,040
atomically it's because the latch it

1677
01:08:45,040 --> 01:08:47,460
Slattery

1678
01:08:55,779 --> 01:08:57,399
we'd have to read them tear down forever

1679
01:08:57,399 --> 01:08:59,130
to find this place

1680
01:08:59,130 --> 01:09:02,500
Ford this page here right yes there

1681
01:09:02,500 --> 01:09:11,439
could be stuff up above like there could

1682
01:09:11,439 --> 01:09:18,970
be like okay it could be like delete it

1683
01:09:18,970 --> 01:09:22,089
could be insert Cape if there's insert

1684
01:09:22,089 --> 01:09:28,210
five point five I think we're insert you

1685
01:09:28,210 --> 01:09:29,920
always have to go to the debates page so

1686
01:09:29,920 --> 01:09:32,670
then you would always see this split

1687
01:09:32,670 --> 01:09:34,390
actually think for everything you always

1688
01:09:34,390 --> 01:09:36,580
have to go to the base page yeah for

1689
01:09:36,580 --> 01:09:38,920
delete and insert yeah so I it's not

1690
01:09:38,920 --> 01:09:41,020
like I would blindly append this thing

1691
01:09:41,020 --> 01:09:44,920
all right weren't shorten time um I'm

1692
01:09:44,920 --> 01:09:46,630
rushing this a bit much but I can answer

1693
01:09:46,630 --> 01:09:48,220
questions afterwards so I would quickly

1694
01:09:48,220 --> 01:09:50,500
to start talk about the our optimization

1695
01:09:50,500 --> 01:09:53,170
so again the paper how do you guys read

1696
01:09:53,170 --> 01:09:57,790
this was our attempt to write the sort

1697
01:09:57,790 --> 01:09:59,170
of the the the missing guide on how to

1698
01:09:59,170 --> 01:10:00,100
build opw tree

1699
01:10:00,100 --> 01:10:01,300
so the original be double tree paper

1700
01:10:01,300 --> 01:10:03,010
from Microsoft doesn't explain a lot of

1701
01:10:03,010 --> 01:10:03,760
the core things you actually need

1702
01:10:03,760 --> 01:10:05,530
actually build a real real P Double Tree

1703
01:10:05,530 --> 01:10:07,150
there's a bunch of these other papers

1704
01:10:07,150 --> 01:10:09,550
they wrote after the original paper that

1705
01:10:09,550 --> 01:10:11,710
sort of sprinkle in some of the the

1706
01:10:11,710 --> 01:10:13,210
things that are in our paper and asked

1707
01:10:13,210 --> 01:10:14,440
our papers meant to be consolidated

1708
01:10:14,440 --> 01:10:16,870
guide on here's how to build a real BW

1709
01:10:16,870 --> 01:10:18,970
tree and so when I first started at CMU

1710
01:10:18,970 --> 01:10:19,870
I said alright we're gonna build a new

1711
01:10:19,870 --> 01:10:21,280
database system and have a super

1712
01:10:21,280 --> 01:10:23,080
enamored with the BW teams like well we

1713
01:10:23,080 --> 01:10:24,280
ever build a new system we're gonna use

1714
01:10:24,280 --> 01:10:26,710
a BW tree the first time I taught this

1715
01:10:26,710 --> 01:10:29,170
class the second project was implemented

1716
01:10:29,170 --> 01:10:32,050
BW tree which was a nightmare right but

1717
01:10:32,050 --> 01:10:33,370
the like I said the one student the

1718
01:10:33,370 --> 01:10:35,080
peaches student that was super awesome

1719
01:10:35,080 --> 01:10:36,610
we took his beat-up tree he kept on

1720
01:10:36,610 --> 01:10:37,690
working for two years and that's that's

1721
01:10:37,690 --> 01:10:39,460
what the paper was but his paper was not

1722
01:10:39,460 --> 01:10:41,650
meant to be like oh look how crappy bbw

1723
01:10:41,650 --> 01:10:43,570
tree was it was like you know we were

1724
01:10:43,570 --> 01:10:44,560
actually one of the benchmark and see

1725
01:10:44,560 --> 01:10:45,910
how I'd actually cook perform and it

1726
01:10:45,910 --> 01:10:48,460
turns out it was terrible um so that's

1727
01:10:48,460 --> 01:10:49,840
why it's sort of the split brain like

1728
01:10:49,840 --> 01:10:51,520
half the paper says here's how to build

1729
01:10:51,520 --> 01:10:52,960
it and then the second half paper says

1730
01:10:52,960 --> 01:10:54,970
why it's bad right because the RISM

1731
01:10:54,970 --> 01:10:57,220
wasn't supposed to be like that alright

1732
01:10:57,220 --> 01:10:58,090
so almonds quickly talk about some

1733
01:10:58,090 --> 01:11:00,100
optimizations that we did in our version

1734
01:11:00,100 --> 01:11:01,960
so as is called to open beta every tree

1735
01:11:01,960 --> 01:11:05,260
ours is is to the best my knowledge it's

1736
01:11:05,260 --> 01:11:07,000
the best open source implementation

1737
01:11:07,000 --> 01:11:08,650
of the beat every tree there's a couple

1738
01:11:08,650 --> 01:11:10,150
other ones that are out there but they

1739
01:11:10,150 --> 01:11:11,260
don't do all the things that we do

1740
01:11:11,260 --> 01:11:13,420
there's one system out of Germany called

1741
01:11:13,420 --> 01:11:15,940
sled it's like an embedded system that's

1742
01:11:15,940 --> 01:11:17,800
written in rust they're supposedly

1743
01:11:17,800 --> 01:11:19,120
using a beat-up retreat I don't know

1744
01:11:19,120 --> 01:11:20,740
whether they go to the extreme extent

1745
01:11:20,740 --> 01:11:23,740
that houses the be dimitri shows up in

1746
01:11:23,740 --> 01:11:25,750
other systems that Microsoft so cosmos

1747
01:11:25,750 --> 01:11:27,880
DP or used to be document DBS their

1748
01:11:27,880 --> 01:11:30,160
version of MongoDB or their cloud

1749
01:11:30,160 --> 01:11:31,810
database they use it the beat every tree

1750
01:11:31,810 --> 01:11:34,360
in certain cases but ours is the best

1751
01:11:34,360 --> 01:11:35,110
open sort one

1752
01:11:35,110 --> 01:11:37,540
alright so I even talk about what these

1753
01:11:37,540 --> 01:11:38,680
two help we're actually storing these

1754
01:11:38,680 --> 01:11:40,600
Delta records like you know the original

1755
01:11:40,600 --> 01:11:42,610
the original discussion of in Microsoft

1756
01:11:42,610 --> 01:11:44,320
they said oh there's room they don't

1757
01:11:44,320 --> 01:11:45,700
really say where they are so you could

1758
01:11:45,700 --> 01:11:46,900
just allocate a bunch of little it up

1759
01:11:46,900 --> 01:11:48,370
duck doesn't records on the heap but

1760
01:11:48,370 --> 01:11:49,540
that's a bad idea because you'll have

1761
01:11:49,540 --> 01:11:51,340
fragmentation and memory so what we do

1762
01:11:51,340 --> 01:11:53,020
is when we allocate a base page we have

1763
01:11:53,020 --> 01:11:54,670
a little extra space in the header of

1764
01:11:54,670 --> 01:11:56,440
the base page that we can use for

1765
01:11:56,440 --> 01:12:00,250
storing Delta records so now all I need

1766
01:12:00,250 --> 01:12:04,780
to do now is if I'm gonna update the so

1767
01:12:04,780 --> 01:12:06,220
I'm going to add a new Delta record I

1768
01:12:06,220 --> 01:12:08,650
just do a compare and swap on this thing

1769
01:12:08,650 --> 01:12:10,990
here get a new offset and now I can

1770
01:12:10,990 --> 01:12:13,180
insert my Delta record here and then I

1771
01:12:13,180 --> 01:12:15,070
go back here and do the the compare and

1772
01:12:15,070 --> 01:12:16,330
swap to have it point in my head of the

1773
01:12:16,330 --> 01:12:19,150
Delta record right so again I don't need

1774
01:12:19,150 --> 01:12:20,470
to take a latches to acquire the space

1775
01:12:20,470 --> 01:12:22,240
and then when this thing gets full then

1776
01:12:22,240 --> 01:12:25,300
I do the consolidation the other thing

1777
01:12:25,300 --> 01:12:27,430
that would that was too important was I

1778
01:12:27,430 --> 01:12:29,170
have really described what the mapping

1779
01:12:29,170 --> 01:12:31,540
table is in the original version of the

1780
01:12:31,540 --> 01:12:35,820
b/w paper it seems to be a hash table an

1781
01:12:35,820 --> 01:12:38,710
application it's just an array and so

1782
01:12:38,710 --> 01:12:40,600
you want to allocate an array that could

1783
01:12:40,600 --> 01:12:42,790
store any possible and you know noted

1784
01:12:42,790 --> 01:12:45,340
you up to something some limit and so

1785
01:12:45,340 --> 01:12:48,700
the problem though is that if you

1786
01:12:48,700 --> 01:12:49,930
allocate the full array in the very

1787
01:12:49,930 --> 01:12:51,160
beginning for every single possible no

1788
01:12:51,160 --> 01:12:52,240
data you could ever have

1789
01:12:52,240 --> 01:12:54,130
then you end up wasting a lot of space

1790
01:12:54,130 --> 01:12:55,300
because you're allocating memory that

1791
01:12:55,300 --> 01:12:58,270
you probably don't need and so I think

1792
01:12:58,270 --> 01:13:01,990
in the in the in the current version of

1793
01:13:01,990 --> 01:13:03,220
the bead every tree that we have in our

1794
01:13:03,220 --> 01:13:06,780
system the mapping table the max size is

1795
01:13:06,780 --> 01:13:10,030
1 million so I can have 1 million node

1796
01:13:10,030 --> 01:13:12,400
IDs in my system and so if we're storing

1797
01:13:12,400 --> 01:13:16,390
128 keys per node I can have up to 128

1798
01:13:16,390 --> 01:13:18,580
potentially hundred 180 keys total it's

1799
01:13:18,580 --> 01:13:19,840
less than that because we're only

1800
01:13:19,840 --> 01:13:20,800
starting things in them

1801
01:13:20,800 --> 01:13:22,930
I'll eat in the leaf notes but roughly

1802
01:13:22,930 --> 01:13:24,580
that's what it is so to allocate an

1803
01:13:24,580 --> 01:13:26,680
array with 64-bit pointers

1804
01:13:26,680 --> 01:13:30,250
with 1 1 main entries is 8 megabytes so

1805
01:13:30,250 --> 01:13:31,660
it doesn't seem like a lot but if you

1806
01:13:31,660 --> 01:13:34,630
like load the TVC database if every

1807
01:13:34,630 --> 01:13:36,340
table has two or three indexes so for

1808
01:13:36,340 --> 01:13:38,920
every table I'm creating three indexes 8

1809
01:13:38,920 --> 01:13:40,450
megabytes starts to add up a lot from

1810
01:13:40,450 --> 01:13:42,880
naturally not storing anything so in the

1811
01:13:42,880 --> 01:13:44,350
rolled version of peloton when you first

1812
01:13:44,350 --> 01:13:46,330
load a TPCC the database would grow to

1813
01:13:46,330 --> 01:13:49,990
be like 256 Meg's with no data in it

1814
01:13:49,990 --> 01:13:52,600
right so the way we got around this was

1815
01:13:52,600 --> 01:13:54,750
we just use we allocate virtual memory

1816
01:13:54,750 --> 01:13:57,130
and this is not using anything special

1817
01:13:57,130 --> 01:13:59,080
just using the constructs you have from

1818
01:13:59,080 --> 01:14:01,300
the OS we allocate a chunk of memory and

1819
01:14:01,300 --> 01:14:03,130
make sure we only use the upper portion

1820
01:14:03,130 --> 01:14:05,470
of the mapping table when our index is

1821
01:14:05,470 --> 01:14:07,150
small so it doesn't actually get backed

1822
01:14:07,150 --> 01:14:08,350
by physical memory so although the

1823
01:14:08,350 --> 01:14:10,420
virtual size can get large the resident

1824
01:14:10,420 --> 01:14:13,120
set size is quite quite small right

1825
01:14:13,120 --> 01:14:14,800
because it's only when you touch a page

1826
01:14:14,800 --> 01:14:16,630
in memory does the OS actually back it

1827
01:14:16,630 --> 01:14:19,180
with physical memory all right quickly

1828
01:14:19,180 --> 01:14:21,400
to finish up so this is the this is the

1829
01:14:21,400 --> 01:14:23,410
the the these are the results that were

1830
01:14:23,410 --> 01:14:24,670
in the original bead of retreat paper

1831
01:14:24,670 --> 01:14:27,070
that Microsoft published with Justin and

1832
01:14:27,070 --> 01:14:28,540
the other people there and this is when

1833
01:14:28,540 --> 01:14:29,830
I saw this I'm like oh this is awesome

1834
01:14:29,830 --> 01:14:31,270
we totally want to build a luxury index

1835
01:14:31,270 --> 01:14:32,920
here at CMU so what are they comparing

1836
01:14:32,920 --> 01:14:34,120
yes it's their version to beat every

1837
01:14:34,120 --> 01:14:37,270
tree against the Skip list and then the

1838
01:14:37,270 --> 01:14:39,640
B+ tree but this B+ tree is actually

1839
01:14:39,640 --> 01:14:42,310
from Berkeley DB Berkeley DB came out of

1840
01:14:42,310 --> 01:14:45,640
UC Berkeley it was its an embedded

1841
01:14:45,640 --> 01:14:48,130
database it has you know basically like

1842
01:14:48,130 --> 01:14:49,750
level DB a Roxie B but like one of the

1843
01:14:49,750 --> 01:14:51,010
first ones to do this an Oracle bought

1844
01:14:51,010 --> 01:14:53,350
it and like 2006 so they extracted out

1845
01:14:53,350 --> 01:14:55,300
the source code for the d-bus tree from

1846
01:14:55,300 --> 01:14:57,820
from Berkeley DB and they modify it so

1847
01:14:57,820 --> 01:14:59,500
it didn't actually store anything on

1848
01:14:59,500 --> 01:15:02,500
disk so this this shows that the bit of

1849
01:15:02,500 --> 01:15:04,720
tree crushes everything right so when I

1850
01:15:04,720 --> 01:15:05,980
saw this like this is amazing we should

1851
01:15:05,980 --> 01:15:07,900
totally do this but then when you

1852
01:15:07,900 --> 01:15:08,980
actually implement it so these are our

1853
01:15:08,980 --> 01:15:12,820
results this is the best our best

1854
01:15:12,820 --> 01:15:15,310
version of the open BW tree this is

1855
01:15:15,310 --> 01:15:16,270
actually the state-of-the-art

1856
01:15:16,270 --> 01:15:18,130
implementation of the Skip list right

1857
01:15:18,130 --> 01:15:20,680
it's out of and from alan techies group

1858
01:15:20,680 --> 01:15:22,600
in australia instead of using towers it

1859
01:15:22,600 --> 01:15:24,940
uses wheels which it's some minor change

1860
01:15:24,940 --> 01:15:27,340
whatever and then this is a B+ tree

1861
01:15:27,340 --> 01:15:28,930
written by one of the authors from hyper

1862
01:15:28,930 --> 01:15:30,430
who came and visited us for a couple

1863
01:15:30,430 --> 01:15:32,440
months and this is like his this is one

1864
01:15:32,440 --> 01:15:33,949
of the data structures they you

1865
01:15:33,949 --> 01:15:36,139
in hyper for their comparisons so as you

1866
01:15:36,139 --> 01:15:38,630
can see the deep uh streak rushes except

1867
01:15:38,630 --> 01:15:39,889
for this one here this won't make me

1868
01:15:39,889 --> 01:15:41,959
wrong I get the mitosis but V Plus V

1869
01:15:41,959 --> 01:15:44,079
pretty much crushes everything alright

1870
01:15:44,079 --> 01:15:46,280
so then when you look at all the data

1871
01:15:46,280 --> 01:15:47,719
structures we'll talk about next class

1872
01:15:47,719 --> 01:15:49,280
alright then you see the open media

1873
01:15:49,280 --> 01:15:51,380
which we gets gets gets gets wiped away

1874
01:15:51,380 --> 01:15:54,050
so I'm now gonna bring in the mash tree

1875
01:15:54,050 --> 01:15:55,969
and art index art index is what you read

1876
01:15:55,969 --> 01:15:58,159
on Wednesday's class it's a radix tree

1877
01:15:58,159 --> 01:16:01,880
or tri from piper and then the mash tree

1878
01:16:01,880 --> 01:16:04,130
is at Harvard this is a tree of trys

1879
01:16:04,130 --> 01:16:05,959
which we'll cover next class so again in

1880
01:16:05,959 --> 01:16:07,820
this environment the beatable tree just

1881
01:16:07,820 --> 01:16:10,400
loses to everything so this is why we

1882
01:16:10,400 --> 01:16:11,840
need to get rid of it but we just have

1883
01:16:11,840 --> 01:16:14,630
we haven't started it yet okay okay that

1884
01:16:14,630 --> 01:16:15,829
was like super rushed at the end I

1885
01:16:15,829 --> 01:16:16,780
apologize

1886
01:16:16,780 --> 01:16:21,289
any questions all right so next class

1887
01:16:21,289 --> 01:16:22,760
I'll spend more time talking about

1888
01:16:22,760 --> 01:16:24,650
latches for B put B plus trees then

1889
01:16:24,650 --> 01:16:25,820
we'll talk about the radix tree stuff

1890
01:16:25,820 --> 01:16:27,309
and then we'll talk a little bit about

1891
01:16:27,309 --> 01:16:30,920
what you can do for project one okay hi

1892
01:16:30,920 --> 01:16:36,190
guys see ya what is this

1893
01:16:36,350 --> 01:16:46,280
[Music]

1894
01:16:46,280 --> 01:16:48,950
Mia 40 just to get my buzz song cuz I

1895
01:16:48,950 --> 01:16:51,170
needed just a little more kick look like

1896
01:16:51,170 --> 01:16:53,600
a fish after just one slip-up put it to

1897
01:16:53,600 --> 01:16:55,670
my lips and rip the top off eight ball

1898
01:16:55,670 --> 01:16:58,460
just drop them to say nice

1899
01:16:58,460 --> 01:17:01,100
won't be the same I've diced you take a

1900
01:17:01,100 --> 01:17:04,390
sake to the player

