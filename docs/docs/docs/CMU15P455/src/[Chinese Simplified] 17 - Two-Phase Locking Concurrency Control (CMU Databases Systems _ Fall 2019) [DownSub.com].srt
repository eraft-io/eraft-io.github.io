1
00:00:03,640 --> 00:00:18,609
[音乐

2
00:00:18,609 --> 00:00:21,619
] 希望你已经注意到我不是

3
00:00:21,619 --> 00:00:26,720
安迪安迪和 KB 上周迎来了他们的第一个

4
00:00:26,720 --> 00:00:28,279
孩子，每个人都过得很好

5
00:00:28,279 --> 00:00:31,579
，我们只是

6
00:00:31,579 --> 00:00:33,260
看到安迪巴勃罗育儿实验非常激动，

7
00:00:33,260 --> 00:00:41,149
所以答题器停止

8
00:00:41,149 --> 00:00:47,989
工作了 上一堂课安迪谈到了很多

9
00:00:47,989 --> 00:00:50,390
关于事务的酸性属性，

10
00:00:50,390 --> 00:00:53,420
重点是隔离，

11
00:00:53,420 --> 00:00:57,199
特别是关于

12
00:00:57,199 --> 00:00:58,910
调度是否可序列化的推理，我们

13
00:00:58,910 --> 00:01:00,980
谈到了冲突可序列化和视图可

14
00:01:00,980 --> 00:01:04,670
序列化，通过冲突可

15
00:01:04,670 --> 00:01:07,430
序列化，我们能够

16
00:01:07,430 --> 00:01:09,020
验证调度是否

17
00:01:09,020 --> 00:01:11,600
基于可序列化 关于能够交换

18
00:01:11,600 --> 00:01:12,920
操作或查看

19
00:01:12,920 --> 00:01:14,720
依赖关系图并能够说

20
00:01:14,720 --> 00:01:17,680
是这个时间表是可序列化的，

21
00:01:17,680 --> 00:01:20,329
或者它是否会违反保证的可

22
00:01:20,329 --> 00:01:22,939
序列化性，然后

23
00:01:22,939 --> 00:01:24,049
还有其他视图可序列化性的概念

24
00:01:24,049 --> 00:01:26,810
，大多数应用

25
00:01:26,810 --> 00:01:28,909
程序实际上都不是系统 真的支持，

26
00:01:28,909 --> 00:01:31,670
因为正是这种

27
00:01:31,670 --> 00:01:33,619
能够产生结果的概念

28
00:01:33,619 --> 00:01:34,820
看起来适合

29
00:01:34,820 --> 00:01:36,430
应用程序但实际上不可序列化的应用程序，

30
00:01:36,430 --> 00:01:38,509
因为我们已经定义了它们，它

31
00:01:38,509 --> 00:01:40,159
不会是可序列化的冲突，所以我

32
00:01:40,159 --> 00:01:42,259
认为他举了几个例子，其中一个

33
00:01:42,259 --> 00:01:45,950
就像计算所有

34
00:01:45,950 --> 00:01:47,060
具有正余额的帐户数量

35
00:01:47,060 --> 00:01:48,710
当他在账户之间洗钱时

36
00:01:48,710 --> 00:01:50,689
，因为

37
00:01:50,689 --> 00:01:52,039
账户从未下降为负数，我们得到

38
00:01:52,039 --> 00:01:54,140
了正确的结果，但从技术上讲，这不会

39
00:01:54,140 --> 00:01:55,340
是一个可序列化的冲突

40
00:01:55,340 --> 00:01:58,579
时间表，我认为另一个只是

41
00:01:58,579 --> 00:02:00,229
在两个账户中进行盲写，

42
00:02:00,229 --> 00:02:02,210
因为最后一次写的是 我们

43
00:02:02,210 --> 00:02:04,340
关心的是被执行的那个它

44
00:02:04,340 --> 00:02:05,990
算作视图可序列化，但它实际上并不是可

45
00:02:05,990 --> 00:02:11,120
序列化的冲突，

46
00:02:11,120 --> 00:02:12,380
所以花了很多时间，比如

47
00:02:12,380 --> 00:02:14,959
你如何验证这些时间表，但现在我们

48
00:02:14,959 --> 00:02:17,330
想要关心的是你如何做这些

49
00:02:17,330 --> 00:02:20,409
事情 实时，因为

50
00:02:20,409 --> 00:02:23,200
他在这里有一个例子，所以这个例子

51
00:02:23,200 --> 00:02:26,739
不是冲突可序列化的，

52
00:02:26,739 --> 00:02:29,470
因为我们在 a 上有这个权利，

53
00:02:29,470 --> 00:02:32,530
然后在 unrepeata 上有另一个读取 ble 阅读

54
00:02:32,530 --> 00:02:35,319
这不是冲突可序列化所以

55
00:02:35,319 --> 00:02:37,239
这基本上是安迪

56
00:02:37,239 --> 00:02:40,629
在上一堂课中谈到的我将尝试在

57
00:02:40,629 --> 00:02:41,950
这里弥补时间因为我们

58
00:02:41,950 --> 00:02:45,640
开始有点晚所以我

59
00:02:45,640 --> 00:02:47,560
说我们需要一种方法

60
00:02:47,560 --> 00:02:49,180
在真实系统中，

61
00:02:49,180 --> 00:02:50,680


62
00:02:50,680 --> 00:02:52,900
当客户端连接

63
00:02:52,900 --> 00:02:54,190
到数据库并开始

64
00:02:54,190 --> 00:02:55,930
事务时，当它们被提交时，我们无法获得事务的完整时间表，我们不知道

65
00:02:55,930 --> 00:02:58,690
查询将是先验的，所以我们

66
00:02:58,690 --> 00:03:01,030
可以'

67
00:03:01,030 --> 00:03:02,620


68
00:03:02,620 --> 00:03:04,030


69
00:03:04,030 --> 00:03:06,540
我们需要一个协议，我们需要一个

70
00:03:06,540 --> 00:03:08,829
允许我们

71
00:03:08,829 --> 00:03:11,230
并行执行这些事务的系统，

72
00:03:11,230 --> 00:03:12,489
因为我们希望在

73
00:03:12,489 --> 00:03:14,099
系统，但我们仍然需要保证

74
00:03:14,099 --> 00:03:19,150
这些事务之间的隔离 所以

75
00:03:19,150 --> 00:03:23,379
我认为 Andy 简要提到了这个想法

76
00:03:23,379 --> 00:03:24,880
有悲观方法和

77
00:03:24,880 --> 00:03:26,620
乐观方法 今天我们

78
00:03:26,620 --> 00:03:28,209
将研究两阶段锁定 我们

79
00:03:28,209 --> 00:03:30,579
将使用锁 系统这是一种

80
00:03:30,579 --> 00:03:31,870
悲观的方法，因为基本上

81
00:03:31,870 --> 00:03:35,560
你必须

82
00:03:35,560 --> 00:03:38,980
在每次操作之前请求系统的许可，

83
00:03:38,980 --> 00:03:42,099
所以在你可以对元组进行读取或写入之前

84
00:03:42,099 --> 00:03:44,139
，你将不得不请求

85
00:03:44,139 --> 00:03:48,669
对该对象的锁定

86
00:03:48,669 --> 00:03:49,870
在接下来的几节课中，乐观会变得过于乐观，

87
00:03:49,870 --> 00:03:51,190
但今天所有的都是关于

88
00:03:51,190 --> 00:03:57,810
锁的悲观主义，所以这

89
00:03:57,810 --> 00:04:00,190
只是一种高级的东西，我

90
00:04:00,190 --> 00:04:05,560
只是在我们可以阅读我们之前描述的一个例子

91
00:04:05,560 --> 00:04:07,930
要去一个

92
00:04:07,930 --> 00:04:10,319
锁管理器并说我想锁定一个

93
00:04:10,319 --> 00:04:13,120
这个锁管理器，这是

94
00:04:13,120 --> 00:04:14,290
关于你是否被

95
00:04:14,290 --> 00:04:16,779
允许访问元组的中央权限，它维护

96
00:04:16,779 --> 00:04:19,750
关于谁持有锁的元数据，并

97
00:04:19,750 --> 00:04:22,419
在其中执行锁协议

98
00:04:22,419 --> 00:04:25,810
系统因此 tyonne 将开始它

99
00:04:25,810 --> 00:04:27,669
会向锁管理器请求锁，

100
00:04:27,669 --> 00:04:30,700
因为没有

101
00:04:30,700 --> 00:04:33,130
其他人持有它 t2 开始让我们想象

102
00:04:33,130 --> 00:04:34,060
我们在一个

103
00:04:34,060 --> 00:04:35,580
线程环境中，所以我们只

104
00:04:35,580 --> 00:04:38,080
执行这些事务中的一个

105
00:04:38,080 --> 00:04:39,220
我们只是米 一次在

106
00:04:39,220 --> 00:04:41,320
这些事务中的一个上取得进展，所以 t1

107
00:04:41,320 --> 00:04:43,840
开始获取 a 上的锁，我们切换到

108
00:04:43,840 --> 00:04:45,790
t2 它开始它想要 a 上的锁，

109
00:04:45,790 --> 00:04:47,110
因为它最终将

110
00:04:47,110 --> 00:04:50,380
在这里进行读取和写入操作，但它

111
00:04:50,380 --> 00:04:52,030
被锁管理器拒绝 因为 t1

112
00:04:52,030 --> 00:04:54,810
已经持有那个锁，

113
00:04:54,930 --> 00:04:58,590
所以 t2 在这里唯一能做的就是暂停

114
00:04:58,590 --> 00:05:01,360
行为是什么

115
00:05:01,360 --> 00:05:03,910
取决于实现，但是

116
00:05:03,910 --> 00:05:05,080
必须有某种暂停，

117
00:05:05,080 --> 00:05:06,400
因为你无法获得你想要的锁

118
00:05:06,400 --> 00:05:10,180
t1 收益进行写入

119
00:05:10,180 --> 00:05:12,760
读取释放锁定 锁定管理器

120
00:05:12,760 --> 00:05:15,610
现在基本上会告诉 t2

121
00:05:15,610 --> 00:05:17,290
您可以获得想要的锁定，它

122
00:05:17,290 --> 00:05:19,210
会授予它 t2 将执行

123
00:05:19,210 --> 00:05:21,970
他需要执行的操作，然后它就会执行

124
00:05:21,970 --> 00:05:22,840
在概念上释放锁

125
00:05:22,840 --> 00:05:25,479
这就是我们将如何

126
00:05:25,479 --> 00:05:27,130
在系统中使用锁 有

127
00:05:27,130 --> 00:05:28,240
一个比这更多的细微差别

128
00:05:28,240 --> 00:05:30,280
我们将通过

129
00:05:30,280 --> 00:05:34,690
讲座的其余部分进行讨论 有意义 我们

130
00:05:34,690 --> 00:05:39,160
今天很好 我们要

131
00:05:39,160 --> 00:05:40,510
看看 首先是锁类型 我们

132
00:05:40,510 --> 00:05:43,240
将从两种基本锁类型开始，然后

133
00:05:43,240 --> 00:05:46,260
我们将进入我们的第一个适当的

134
00:05:46,260 --> 00:05:48,400
并发控制协议两阶段

135
00:05:48,400 --> 00:05:48,970
锁定

136
00:05:48,970 --> 00:05:52,180
我们将讨论我们如何

137
00:05:52,180 --> 00:05:53,680
推理死锁以及我们将如何

138
00:05:53,680 --> 00:05:57,010
解决这个问题，然后我们将

139
00:05:57,010 --> 00:05:59,289
引入分层锁定的概念，

140
00:05:59,289 --> 00:06:00,700
这将允许我们

141
00:06:00,700 --> 00:06:02,140
在系统中使用更少的锁，从而

142
00:06:02,140 --> 00:06:03,280
提高我们如何

143
00:06:03,280 --> 00:06:06,750
使用锁的效率，然后最后一件事

144
00:06:06,750 --> 00:06:08,830
实际上是错误的 我们

145
00:06:08,830 --> 00:06:10,539
今天不会达到隔离级别 他

146
00:06:10,539 --> 00:06:13,600
去年没有做到而且它们不再出现在

147
00:06:13,600 --> 00:06:15,130
这些幻灯片中 所以我们将进入

148
00:06:15,130 --> 00:06:16,660
隔离级别 我想我们会

149
00:06:16,660 --> 00:06:21,250
在下一节课中处理它们 所以我想

150
00:06:21,250 --> 00:06:23,050
你 之前看过这张幻灯片，II

151
00:06:23,050 --> 00:06:26,470
介绍了这是来自 Gus

152
00:06:26,470 --> 00:06:29,229
grapha 的工作

153
00:06:29,229 --> 00:06:31,600


154
00:06:31,600 --> 00:06:33,280


155
00:06:33,280 --> 00:06:35,080


156
00:06:35,080 --> 00:06:39,130


157
00:06:39,130 --> 00:06:40,660
这张幻灯片前 只是为了让

158
00:06:40,660 --> 00:06:41,950
戴夫安德森停止取笑我们，

159
00:06:41,950 --> 00:06:43,720
因为他说数据库人员将

160
00:06:43,720 --> 00:06:46,210
锁称为闩锁很奇怪，但是在他谈论之前，

161
00:06:46,210 --> 00:06:47,889
它们是我们世界中不同的术语

162
00:06:47,889 --> 00:06:51,490
，他正在谈论

163
00:06:51,490 --> 00:06:52,240


164
00:06:52,240 --> 00:06:55,870
就像我所说的锁存器以保护线程

165
00:06:55,870 --> 00:06:57,849
免受 有点破坏

166
00:06:57,849 --> 00:07:00,249
并发数据结构的内存 今天

167
00:07:00,249 --> 00:07:02,199
我们谈论的是锁，它

168
00:07:02,199 --> 00:07:04,240
保护

169
00:07:04,240 --> 00:07:06,249
数据库中的逻辑结构，所以像数据库表元组这样的东西，

170
00:07:06,249 --> 00:07:09,840
它们被设计用来保护

171
00:07:09,840 --> 00:07:11,590
事务不相互冲突

172
00:07:11,590 --> 00:07:13,990
，这可能是区分的关键

173
00:07:13,990 --> 00:07:17,770
部分是在使用

174
00:07:17,770 --> 00:07:19,770
锁存器时，我们通过编程规则避免了死锁，

175
00:07:19,770 --> 00:07:22,360
我们正在编写

176
00:07:22,360 --> 00:07:24,250
有关如何

177
00:07:24,250 --> 00:07:26,229


178
00:07:26,229 --> 00:07:29,830
通过 B+ 树中的锁存器抓取等方式获取这些锁存器的逻辑，我们如何

179
00:07:29,830 --> 00:07:31,509
推理操作正在执行的操作，

180
00:07:31,509 --> 00:07:33,460
以便我们知道如何安全

181
00:07:33,460 --> 00:07:36,039
以一种顺序获取闩锁，然后确保

182
00:07:36,039 --> 00:07:37,840
我们遵守该顺序并

183
00:07:37,840 --> 00:07:38,979
以正确的顺序释放它们以避免

184
00:07:38,979 --> 00:07:42,099
带锁的死锁我们不能这样做，

185
00:07:42,099 --> 00:07:43,750
因为我们不知道

186
00:07:43,750 --> 00:07:45,310
事务会做什么，

187
00:07:45,310 --> 00:07:48,339
他们会运行什么查询，所以我们需要

188
00:07:48,339 --> 00:07:52,060
能够处理向系统发出查询的客户端

189
00:07:52,060 --> 00:07:53,680
，这会导致

190
00:07:53,680 --> 00:07:55,210
死锁，我们需要讨论

191
00:07:55,210 --> 00:07:57,610
一下我们接下来要做什么，因为

192
00:07:57,610 --> 00:08:00,129


193
00:08:00,129 --> 00:08:01,060
在讲座的稍后部分展示一个演示非常简单，

194
00:08:01,060 --> 00:08:02,889
很容易使系统

195
00:08:02,889 --> 00:08:10,960
陷入僵局是的，就像我说的那样，我们'

196
00:08:10,960 --> 00:08:13,539
首先从两种基本的锁类型开始 我们有

197
00:08:13,539 --> 00:08:15,789
共享锁和排他锁 共享

198
00:08:15,789 --> 00:08:18,250
锁用于读取 排他

199
00:08:18,250 --> 00:08:19,960
锁用于写入 这些有点

200
00:08:19,960 --> 00:08:22,629
类似于读写锁 我

201
00:08:22,629 --> 00:08:23,860
认为我们在

202
00:08:23,860 --> 00:08:26,649
并发数据结构中讨论过

203
00:08:26,649 --> 00:08:28,599
兼容性 矩阵类型表示

204
00:08:28,599 --> 00:08:30,639
如果您已经有一个共享锁存

205
00:08:30,639 --> 00:08:32,469
器，您可以分发更多共享锁存器

206
00:08:32,469 --> 00:08:36,250


207
00:08:36,250 --> 00:08:37,929


208
00:08:37,929 --> 00:08:40,029
吗？

209
00:08:40,029 --> 00:08:41,620
你不能

210
00:08:41,620 --> 00:08:42,940
给已经有共享锁存器的东西分配一个独占锁存器，这就是

211
00:08:42,940 --> 00:08:48,029


212
00:08:48,029 --> 00:08:52,199
这些锁存器的基本兼容性，

213
00:08:54,300 --> 00:08:55,830
或者对不起，这些锁我

214
00:08:55,830 --> 00:08:58,170
不应该称它们为锁存器，因为

215
00:08:58,170 --> 00:09:00,560
安迪会生我的气，

216
00:09:00,560 --> 00:09:03,960
所以 我们

217
00:09:03,960 --> 00:09:05,460
将如何使用锁的基本语义就像我在

218
00:09:05,460 --> 00:09:06,720
那个例子中描述的那样，你

219
00:09:06,720 --> 00:09:07,800
要去一个锁管理器，你

220
00:09:07,800 --> 00:09:09,330
会说嘿，我可以得到这个

221
00:09:09,330 --> 00:09:12,630
对象的锁，锁管理器是 将

222
00:09:12,630 --> 00:09:14,310
根据其内部元数据决定是否

223
00:09:14,310 --> 00:09:15,960
允许您拥有该锁

224
00:09:15,960 --> 00:09:18,420
，然后由事务在完成后

225
00:09:18,420 --> 00:09:20,130
释放锁

226
00:09:20,130 --> 00:09:22,500
事务管理器 或者请原谅

227
00:09:22,500 --> 00:09:25,590
锁管理器不一定

228
00:09:25,590 --> 00:09:29,120
对如何进行任何限制 很长一段时间

229
00:09:29,120 --> 00:09:32,430
你必须拥有那个锁，所以

230
00:09:32,430 --> 00:09:33,810
它取决于事务以确保

231
00:09:33,810 --> 00:09:35,550
他们在完成后返回释放锁

232
00:09:35,550 --> 00:09:38,040
然后它更新

233
00:09:38,040 --> 00:09:40,200
内部元数据我认为

234
00:09:40,200 --> 00:09:42,570
没有一个安迪没有做一个

235
00:09:42,570 --> 00:09:44,220
wal 本学期的 k manager 项目我们

236
00:09:44,220 --> 00:09:45,870
过去做过一个，但就像基本

237
00:09:45,870 --> 00:09:48,480
实现一样，有一个内部

238
00:09:48,480 --> 00:09:51,630
表可能是一个哈希表，用于

239
00:09:51,630 --> 00:09:54,300
跟踪系统中所有可能的锁

240
00:09:54,300 --> 00:09:56,340
，然后当

241
00:09:56,340 --> 00:09:57,750
请求进来时 将它们放入

242
00:09:57,750 --> 00:09:59,730
队列，您将它们从队列中处理出来，

243
00:09:59,730 --> 00:10:04,770
然后从那里继续前进，所以这是一个很酷的

244
00:10:04,770 --> 00:10:05,760
项目，但我认为您

245
00:10:05,760 --> 00:10:10,620
今年不会这样做，所以让我们看一下我们之前定义

246
00:10:10,620 --> 00:10:15,510
的这些共享排他

247
00:10:15,510 --> 00:10:18,480
锁的示例 t1

248
00:10:18,480 --> 00:10:20,460
开始时它想对 a 进行读取和

249
00:10:20,460 --> 00:10:21,570
写入操作，因此它将直接

250
00:10:21,570 --> 00:10:23,760
获取排他锁，因此它将

251
00:10:23,760 --> 00:10:26,790
转到锁管理器 给我

252
00:10:26,790 --> 00:10:28,440
排他锁锁管理器，就像确保

253
00:10:28,440 --> 00:10:31,440
没有其他人拥有锁 全部都是

254
00:10:31,440 --> 00:10:32,810
你的

255
00:10:32,810 --> 00:10:35,490
t1 完成了它

256
00:10:35,490 --> 00:10:39,750
需要在元组 a 上执行的操作 释放锁，

257
00:10:39,750 --> 00:10:42,030
因为它已经完成 t2 出现并

258
00:10:42,030 --> 00:10:44,190
说我想对 a 进行写操作，所以它

259
00:10:44,190 --> 00:10:46,290
现在想要排他锁 锁定

260
00:10:46,290 --> 00:10:47,520
管理器就像确定没有人得到那个

261
00:10:47,520 --> 00:10:48,630
锁 都是你的

262
00:10:48,630 --> 00:10:51,120
d  o 无论你想要它做什么它都是正确的

263
00:10:51,120 --> 00:10:54,540
它解锁 a 然后 t1 想要

264
00:10:54,540 --> 00:10:56,340
回来只是做一个读取所以我们只需要

265
00:10:56,340 --> 00:10:58,980
一个共享锁再次询问锁

266
00:10:58,980 --> 00:11:01,500
管理器给我法律它的

267
00:11:01,500 --> 00:11:03,840
操作是否释放锁，正如我们

268
00:11:03,840 --> 00:11:05,700
所描述的 在最后一张幻灯片中，

269
00:11:05,700 --> 00:11:07,290
事务负责锁定和

270
00:11:07,290 --> 00:11:08,010


271
00:11:08,010 --> 00:11:09,750
解锁步行管理器，只是

272
00:11:09,750 --> 00:11:11,460
为了直接交通，并确保

273
00:11:11,460 --> 00:11:12,540
每个人都在做他们

274
00:11:12,540 --> 00:11:17,130
应该做的

275
00:11:17,130 --> 00:11:21,500


276
00:11:21,500 --> 00:11:24,780
事情 它不是孤立的，所以特别是

277
00:11:24,780 --> 00:11:26,850
当最后的 t1 进行另一次

278
00:11:26,850 --> 00:11:29,280
读取时，它正在获得不可重复的

279
00:11:29,280 --> 00:11:32,390
读取，它读取元组 a 它在 a 上进行了写入，

280
00:11:32,390 --> 00:11:34,770
但随后返回并读取 a 并且

281
00:11:34,770 --> 00:11:36,390
它实际上看到的

282
00:11:36,390 --> 00:11:39,030
是 t2 写，所以我们有一个不可重复的

283
00:11:39,030 --> 00:11:41,490
读取异常，我们不能有，所以我们

284
00:11:41,490 --> 00:11:42,540
需要更聪明

285
00:11:42,540 --> 00:11:44,730
地处理我们对锁的处理，

286
00:11:44,730 --> 00:11:46,010
我们需要更多的

287
00:11:46,010 --> 00:11:49,800
纪律和 NA 和一个亲 tocol

288
00:11:49,800 --> 00:11:53,000
应用于我们在这里所做的事情，

289
00:11:53,330 --> 00:11:56,160
所以 Andy 添加了一个更酷的

290
00:11:56,160 --> 00:11:58,050
动画来表明这是一个问题，这

291
00:11:58,050 --> 00:11:59,490
是您的，这是您的不可重复

292
00:11:59,490 --> 00:12:03,450
读取，所以我们将使用的是一种

293
00:12:03,450 --> 00:12:05,690
称为两阶段锁定的协议，

294
00:12:05,690 --> 00:12:09,230
它是 将允许数据库系统

295
00:12:09,230 --> 00:12:12,180
以始终

296
00:12:12,180 --> 00:12:13,470
保证冲突可序列化

297
00:12:13,470 --> 00:12:16,080
调度的方式分发锁，这是一个大问题，因为现在

298
00:12:16,080 --> 00:12:19,260
我们不必尝试限制

299
00:12:19,260 --> 00:12:20,880
系统中的并行性，我们可以尝试

300
00:12:20,880 --> 00:12:22,350
同时运行多个事务

301
00:12:22,350 --> 00:12:26,010
并且我们不需要提前知道

302
00:12:26,010 --> 00:12:27,510
事务

303
00:12:27,510 --> 00:12:29,310
要做什么来决定它们是否是冲突可

304
00:12:29,310 --> 00:12:30,900
序列化的在系统可以运行的地方我们

305
00:12:30,900 --> 00:12:32,730
可以进行操作，我们希望

306
00:12:32,730 --> 00:12:34,530
在

307
00:12:34,530 --> 00:12:38,310
不产生不可实现的情况下获得事务的高吞吐量

308
00:12:38,310 --> 00:12:40,410
计划或违反我们的隔离

309
00:12:40,410 --> 00:12:43,560
要求 这

310
00:12:43,560 --> 00:12:48,420
是 IBM 在 70 年代中期为系统所做的所有工作 我们的

311
00:12:48,420 --> 00:12:50,520
项目由 Jim Gray 领导，他

312
00:12:50,520 --> 00:12:53,910
后来赢得了图灵奖 所以这很

313
00:12:53,910 --> 00:12:55,260
漂亮 开创性的东西 这是

314
00:12:55,260 --> 00:12:57,600
在他们构建

315
00:12:57,600 --> 00:12:59,070
第一个关系数据库管理

316
00:12:59,070 --> 00:13:01,380
系统的时候，所以没有教科书教你

317
00:13:01,380 --> 00:13:03,540
如何做这个东西 两阶段锁定是

318
00:13:03,540 --> 00:13:04,440
他们提出的，

319
00:13:04,440 --> 00:13:06,060
结果证明这是一个很好的主意，大多数

320
00:13:06,060 --> 00:13:09,530
系统使用两个 现在是阶段锁定，

321
00:13:11,440 --> 00:13:14,780
所以你可能不会惊讶地

322
00:13:14,780 --> 00:13:17,540
看到两阶段锁定有两个阶段

323
00:13:17,540 --> 00:13:19,280
，一个是增长阶段，

324
00:13:19,280 --> 00:13:20,930
然后是收缩阶段，所以在

325
00:13:20,930 --> 00:13:22,670
事务的增长阶段，它

326
00:13:22,670 --> 00:13:24,470
可以获取任何 Locke 所说的

327
00:13:24,470 --> 00:13:27,380
需要它去 Locke  manager 得到

328
00:13:27,380 --> 00:13:29,630
它需要的一切，然后它执行它的

329
00:13:29,630 --> 00:13:31,700
所有操作，

330
00:13:31,700 --> 00:13:33,710
然后第二个它释放一个锁告诉

331
00:13:33,710 --> 00:13:35,210
Locke manager 我已经完成了这个

332
00:13:35,210 --> 00:13:37,370
锁，事务现在处于收缩

333
00:13:37,370 --> 00:13:39,320
阶段，不再允许获取更多的

334
00:13:39,320 --> 00:13:42,440
锁 所以在一个例子中，我们将看到

335
00:13:42,440 --> 00:13:44,450
这如何帮助我们解决

336
00:13:44,450 --> 00:13:47,240
我们担心的异常情况

337
00:13:47,240 --> 00:13:53,630
，我认为是的，所以换一种

338
00:13:53,630 --> 00:13:55,010
方式来思考它是这样的

339
00:13:55,010 --> 00:13:57,710
可视化 x 轴是时间，这

340
00:13:57,710 --> 00:13:59,870
是单个事务的生命周期 y 轴

341
00:13:59,870 --> 00:14:01,040
是该事务持有的锁的数量，

342
00:14:01,040 --> 00:14:03,110
因此在增长阶段，它

343
00:14:03,110 --> 00:14:04,730
可以继续积累

344
00:14:04,730 --> 00:14:06,650
所需的锁，第二次释放

345
00:14:06,650 --> 00:14:07,940
锁它会 进入收缩

346
00:14:07,940 --> 00:14:14,000
阶段，您将不再获得锁，

347
00:14:14,000 --> 00:14:17,330
这是违反

348
00:14:17,330 --> 00:14:19,400
两阶段锁定的一个示例，因为

349
00:14:19,400 --> 00:14:20,600
事务释放了一些锁，而我

350
00:14:20,600 --> 00:14:22,460
又返回并获取了更多锁，我们

351
00:14:22,460 --> 00:14:27,140
不能拥有它，这会导致

352
00:14:27,140 --> 00:14:28,580
我们在前面的例子中看到的同样类型的问题

353
00:14:28,580 --> 00:14:29,720
，我们有一个

354
00:14:29,720 --> 00:14:31,100
不可重复的读取，

355
00:14:31,100 --> 00:14:32,570
当他们返回获取一个锁时你释放锁

356
00:14:32,570 --> 00:14:36,080
，因此你会得到异常

357
00:14:36,080 --> 00:14:40,940
，所以这里有一个例子，有两个

358
00:14:40,940 --> 00:14:43,730
阶段的锁定事务，一个将

359
00:14:43,730 --> 00:14:46,010
开始 就像之前它需要一个排他

360
00:14:46,010 --> 00:14:47,090
锁因为它想要

361
00:14:47,090 --> 00:14:50,420
对元组进行读和写操作 它可以

362
00:14:50,420 --> 00:14:51,770
从共享锁开始并升级它

363
00:14:51,770 --> 00:14:53,210
在之前的升级幻灯片上有一个概念，

364
00:14:53,210 --> 00:14:54,860
我们将 ta  lk 关于

365
00:14:54,860 --> 00:14:57,350
在讲座稍后再升级一点，但

366
00:14:57,350 --> 00:14:58,610
我们现在要从

367
00:14:58,610 --> 00:15:01,460
排他律开始，锁管理器

368
00:15:01,460 --> 00:15:07,400
获得锁 t2 想要排他锁，它

369
00:15:07,400 --> 00:15:09,530
不能拥有它，因为 t1 仍然持有它，

370
00:15:09,530 --> 00:15:10,550
所以我们 将继续持有该

371
00:15:10,550 --> 00:15:11,780
锁，直到我们完成所有

372
00:15:11,780 --> 00:15:14,360
操作我们将

373
00:15:14,360 --> 00:15:16,280
在 t1 中进行我们想要的额外读取，然后我们将

374
00:15:16,280 --> 00:15:18,920
释放锁 t2 一直停滞不前，

375
00:15:18,920 --> 00:15:20,330
无法取得任何

376
00:15:20,330 --> 00:15:22,070
进展 因为它没有

377
00:15:22,070 --> 00:15:23,360


378
00:15:23,360 --> 00:15:26,390
锁定十万经理会说好的 t2 你得到

379
00:15:26,390 --> 00:15:29,420
你想要的你是对的 然后

380
00:15:29,420 --> 00:15:40,399
t2 会解锁然后提交

381
00:15:40,399 --> 00:15:41,180
所以两阶段锁定的好处

382
00:15:41,180 --> 00:15:44,060
是如果你遵循这个 协议你会

383
00:15:44,060 --> 00:15:47,360
得到冲突 可序列化的调度

384
00:15:47,360 --> 00:15:49,220
那里得到的依赖图

385
00:15:49,220 --> 00:15:51,260
保证是一个循环 这很好

386
00:15:51,260 --> 00:15:53,600
这正是我们想要的 它确实

387
00:15:53,600 --> 00:15:56,450
有一个小问题虽然这是

388
00:15:56,450 --> 00:15:59,060
级联中止 所以我们将在下一个例子

389
00:15:59,060 --> 00:16:02,540
中 幻灯片，但这个想法是可以的，

390
00:16:02,540 --> 00:16:05,240
因为 tw  o 单独的锁相并不能

391
00:16:05,240 --> 00:16:07,100
保证您不会获得脏读，

392
00:16:07,100 --> 00:16:12,010
您可能会导致级联中止

393
00:16:15,279 --> 00:16:19,839
所以这与

394
00:16:19,839 --> 00:16:26,060
我们将要访问不同

395
00:16:26,060 --> 00:16:28,490
元组之前的时间表相同，我们将获得排他

396
00:16:28,490 --> 00:16:29,810
锁 B 处的排他锁

397
00:16:29,810 --> 00:16:31,160
是因为一直到这里

398
00:16:31,160 --> 00:16:32,990
我们都要对 B 进行操作，

399
00:16:32,990 --> 00:16:34,279
我们必须在开始解锁任何东西之前获取所有锁，

400
00:16:34,279 --> 00:16:35,810
因为我们

401
00:16:35,810 --> 00:16:39,110
处于两阶段锁定中，所以 t1 会

402
00:16:39,110 --> 00:16:41,449
执行它的操作 需要释放

403
00:16:41,449 --> 00:16:45,050
t2 上的锁 获取 t2 上的锁 进行读取，

404
00:16:45,050 --> 00:16:50,800
然后也进行写入，然后 t1 中止，

405
00:16:50,800 --> 00:16:54,550
但是现在存在这个问题，t2

406
00:16:54,550 --> 00:16:58,670
从 t1 读取一个值，该值现在

407
00:16:58,670 --> 00:17:00,529
实际上不在系统中，因为

408
00:17:00,529 --> 00:17:03,800
事务中止了它 没有提交，所以

409
00:17:03,800 --> 00:17:06,049
我们现在有了这个依赖，因为

410
00:17:06,049 --> 00:17:08,540
t1 中止了，你现在也必须中止 t2，

411
00:17:08,540 --> 00:17:10,339
因为它读取了一个不再有效的值，

412
00:17:10,339 --> 00:17:12,049
所以这就是我们

413
00:17:12,049 --> 00:17:14,569
所说的两阶段锁定

414
00:17:14,569 --> 00:17:19,669
容易受到级联中止的影响 这

415
00:17:19,669 --> 00:17:21,420


416
00:17:21,420 --> 00:17:23,010
就是原因 这是一个问题，因为

417
00:17:23,010 --> 00:17:26,069
你可能会浪费很多工作，所以 t2

418
00:17:26,069 --> 00:17:28,170
可以让你知道，因为它读取

419
00:17:28,170 --> 00:17:30,000
了 t1 中的值，它可以

420
00:17:30,000 --> 00:17:31,860
在系统上完成一系列操作，现在

421
00:17:31,860 --> 00:17:33,960
因为 t2 也必须中止

422
00:17:33,960 --> 00:17:36,000
你增加了回滚逻辑的复杂性

423
00:17:36,000 --> 00:17:37,770
越来越多的东西需要

424
00:17:37,770 --> 00:17:39,000
在系统中回滚 仅仅

425
00:17:39,000 --> 00:17:41,430
因为一个事务中止 它会

426
00:17:41,430 --> 00:17:42,510
导致另一个事务板

427
00:17:42,510 --> 00:17:43,560


428
00:17:43,560 --> 00:17:44,730
如果你有一堆，你可以看到 Domino 如何通过系统

429
00:17:44,730 --> 00:17:46,380
正在运行的事务

430
00:17:46,380 --> 00:17:48,570
同时从彼此读取值

431
00:17:48,570 --> 00:17:54,630
然后从一个板上读取值 所以另一

432
00:17:54,630 --> 00:17:56,190
件值得指出的事情是这是

433
00:17:56,190 --> 00:17:58,620
在两阶段锁定下的有效时间表

434
00:17:58,620 --> 00:18:00,380


435
00:18:00,380 --> 00:18:06,270
它是的它基本上是我

436
00:18:06,270 --> 00:18:08,760
已经说过的那种你不能让信息

437
00:18:08,760 --> 00:18:10,410
从 t1 泄漏到外部世界，

438
00:18:10,410 --> 00:18:12,060
因为它中止了，但

439
00:18:12,060 --> 00:18:13,380
在两阶段锁定下这将是一个允许的时间表，

440
00:18:13,380 --> 00:18:14,400
所以我们必须以

441
00:18:14,400 --> 00:18:20,010
某种方式解决这个问题，是的，就像我说的那样，这

442
00:18:20,010 --> 00:18:21,570
都是浪费的工作 t2 可以完成

443
00:18:21,570 --> 00:18:23,280
一堆复杂的逻辑和

444
00:18:23,280 --> 00:18:24,960
一堆更多的系统写入，

445
00:18:24,960 --> 00:18:26,880
因为我们必须中止它，我们浪费了

446
00:18:26,880 --> 00:18:34,290
很多时间，所以我们想指出

447
00:18:34,290 --> 00:18:35,370
一些关于两阶段锁定的其他一些事情

448
00:18:35,370 --> 00:18:37,410
有

449
00:18:37,410 --> 00:18:40,110
一些可序列化的时间表，

450
00:18:40,110 --> 00:18:41,760
两相锁定实际上不允许

451
00:18:41,760 --> 00:18:44,360
两相锁定多一点我

452
00:18:44,360 --> 00:18:50,970
想我会说保守，或者是的，

453
00:18:50,970 --> 00:18:53,760
我们会使用这个词，因为

454
00:18:53,760 --> 00:18:55,140
有两相

455
00:18:55,140 --> 00:18:58,170
锁定会尝试的可序列化时间表 我们将

456
00:18:58,170 --> 00:18:59,910
不被允许，并且由于锁定，我们将

457
00:18:59,910 --> 00:19:01,200


458
00:19:01,200 --> 00:19:04,530
稍微限制系统的并发性，正如我提到的，我们有这个

459
00:19:04,530 --> 00:19:06,840
问题，

460
00:19:06,840 --> 00:19:08,580
可能会导致级联中止的脏读，我们将

461
00:19:08,580 --> 00:19:12,360
通过修改来解决这个问题 两

462
00:19:12,360 --> 00:19:13,830
相锁定称为强严格两

463
00:19:13,830 --> 00:19:15,300
相锁定它也称为严格

464
00:19:15,300 --> 00:19:17,040
两相锁定

465
00:19:17,040 --> 00:19:18,360
这些术语可以

466
00:19:18,360 --> 00:19:19,950
互换使用我认为教科书中

467
00:19:19,950 --> 00:19:23,040
提到了两者，我们还有另一个

468
00:19:23,040 --> 00:19:25,230
问题 h 在许多

469
00:19:25,230 --> 00:19:27,900
锁定协议中很常见，我们可能会导致

470
00:19:27,900 --> 00:19:29,670
死锁，因此我们需要

471
00:19:29,670 --> 00:19:32,490
通过检测机制来解决该问题

472
00:19:32,490 --> 00:19:34,140
，我们可以检测何时

473
00:19:34,140 --> 00:19:35,340
进入死锁状态

474
00:19:35,340 --> 00:19:37,230
或

475
00:19:37,230 --> 00:19:40,020
协议的某种扩展 在那里我们

476
00:19:40,020 --> 00:19:41,670
防止自己进入死锁

477
00:19:41,670 --> 00:19:44,490
状态，所以再次回到

478
00:19:44,490 --> 00:19:46,020
我们对并发数据结构的 laches 所做的事情，

479
00:19:46,020 --> 00:19:48,180
我们确保我们

480
00:19:48,180 --> 00:19:50,520
以非常特定的方式获取锁

481
00:19:50,520 --> 00:19:52,650
，这样我们就可以保证 我们

482
00:19:52,650 --> 00:19:54,450
永远不会进入死锁

483
00:19:54,450 --> 00:20:06,930
场景，所以我们将首先解决

484
00:20:06,930 --> 00:20:07,980
第一个我们将

485
00:20:07,980 --> 00:20:11,780
讨论强假双阶段锁定

486
00:20:12,140 --> 00:20:14,850
这有点用词不当，因为

487
00:20:14,850 --> 00:20:17,070
第二阶段不再真正存在

488
00:20:17,070 --> 00:20:19,140
所有强严格的两阶段

489
00:20:19,140 --> 00:20:21,900
锁定都表示

490
00:20:21,900 --> 00:20:23,040
在事务结束之前你不会释放任何锁，

491
00:20:23,040 --> 00:20:24,710
当你要

492
00:20:24,710 --> 00:20:27,000
提交增长阶段时，

493
00:20:27,000 --> 00:20:28,530
你会根据需要不断获取锁，

494
00:20:28,530 --> 00:20:32,670
但你没有 

495
00:20:32,670 --> 00:20:35,460
在提交时间之前释放任何锁，这将

496
00:20:35,460 --> 00:20:38,040
允许我们防止任何不可重复的或

497
00:20:38,040 --> 00:20:39,960
原谅任何脏读

498
00:20:39,960 --> 00:20:41,850
跨事务传播，这

499
00:20:41,850 --> 00:20:43,500
也将为我们解决级联中止

500
00:20:43,500 --> 00:20:49,140
问题所以是的，这个数字

501
00:20:49,140 --> 00:20:50,340
有点更新，但正如你 可以

502
00:20:50,340 --> 00:20:53,730
看到收缩阶段，无论你想

503
00:20:53,730 --> 00:20:55,590
在哪里定义它，就像你获得的最后一个

504
00:20:55,590 --> 00:20:57,120
锁是收缩阶段的开始，

505
00:20:57,120 --> 00:20:58,650
但基本上

506
00:20:58,650 --> 00:21:00,240
没有收缩阶段，一切都

507
00:21:00,240 --> 00:21:01,890
在事务结束时立即释放

508
00:21:01,890 --> 00:21:08,970
是的，并且 严格这个词

509
00:21:08,970 --> 00:21:10,530
确实有特定的含义

510
00:21:10,530 --> 00:21:12,570
，当我们谈论并发

511
00:21:12,570 --> 00:21:17,310
控制时，它基本上意味着

512
00:21:17,310 --> 00:21:18,840
您编写的任何内容，您的任何权利都不

513
00:21:18,840 --> 00:21:21,000
会对任何其他资产可见，

514
00:21:21,000 --> 00:21:22,620
系统的任何其他区域，任何其他

515
00:21:22,620 --> 00:21:26,280
事务，诸如此类 直到你

516
00:21:26,280 --> 00:21:29,400
如此提交，所以在这种情况下严格有

517
00:21:29,400 --> 00:21:32,340
一个非常具体的含义，就像我说的

518
00:21:32,340 --> 00:21:34,110
那样解决了我们的级联级联中止

519
00:21:34,110 --> 00:21:35,850
问题，因为没有其他反式 操作

520
00:21:35,850 --> 00:21:37,080
将看到

521
00:21:37,080 --> 00:21:39,240
尚未提交给系统的值，因此它们

522
00:21:39,240 --> 00:21:40,820
只查看提交的数据，

523
00:21:40,820 --> 00:21:45,630
每个人都很高兴，并且就像我

524
00:21:45,630 --> 00:21:47,550
之前提到的那样，这简化了您的

525
00:21:47,550 --> 00:21:49,170
中止逻辑，因为

526
00:21:49,170 --> 00:21:50,820
中止的交易只需要

527
00:21:50,820 --> 00:21:53,640
放回您不需要的值 需要

528
00:21:53,640 --> 00:21:55,500
担心系统中的所有这些事务

529
00:21:55,500 --> 00:21:57,060
可能会读取

530
00:21:57,060 --> 00:21:59,550
未提交的数据，然后

531
00:21:59,550 --> 00:22:03,120
他们几乎必须存储自己的元数据

532
00:22:03,120 --> 00:22:05,760
或方法才能

533
00:22:05,760 --> 00:22:07,950
回滚他们所做的工作，从而

534
00:22:07,950 --> 00:22:09,690
大大简化了事情 必须

535
00:22:09,690 --> 00:22:11,220
对系统中的多个版本进行推理，

536
00:22:11,220 --> 00:22:11,670


537
00:22:11,670 --> 00:22:13,770
如果

538
00:22:13,770 --> 00:22:19,590
你写了一个值，那么你只有一个撤消要做，所以我们将看

539
00:22:19,590 --> 00:22:24,120
一个简单的例子，andy欠他的赌注

540
00:22:24,120 --> 00:22:26,610
钱，我猜所以他要把

541
00:22:26,610 --> 00:22:28,140
一百美元转移到 他的博彩

542
00:22:28,140 --> 00:22:29,640
账户，然后第二笔交易

543
00:22:29,640 --> 00:22:32,310
将计算这个

544
00:22:32,310 --> 00:22:34,860
echo 命令的总和，这不是一个

545
00:22:34,860 --> 00:22:36,720
真正的声明，他只是想

546
00:22:36,720 --> 00:22:38,460
证明你正在阅读这些

547
00:22:38,460 --> 00:22:41,400
值 o 我们本来可以做一些

548
00:22:41,400 --> 00:22:43,230
更复杂的事情，但我们想让这个

549
00:22:43,230 --> 00:22:45,360
例子保持相当简单，首先我们要

550
00:22:45,360 --> 00:22:47,490
看看它，我认为只是基本的

551
00:22:47,490 --> 00:22:49,230
步行，然后是两阶段锁定，然后是

552
00:22:49,230 --> 00:22:52,350
强严格的牙齿日锁定，

553
00:22:52,350 --> 00:22:53,790
所以我们使用两个锁定 一

554
00:22:53,790 --> 00:22:55,020
开始就定义，如果我们不

555
00:22:55,020 --> 00:22:58,580
使用两相锁定，我们就不会，我们可以看到

556
00:22:58,580 --> 00:23:00,600
剧透警报你会得到一个你

557
00:23:00,600 --> 00:23:03,180
会得到一个错误的输出所以

558
00:23:03,180 --> 00:23:04,710
我们从每个一千美元开始

559
00:23:04,710 --> 00:23:09,120
帐户 t1 已经获得

560
00:23:09,120 --> 00:23:10,590
排他锁 进行读取，因为它

561
00:23:10,590 --> 00:23:13,260
需要将他的余额减少

562
00:23:13,260 --> 00:23:17,370
一百美元 t2 想要获得共享

563
00:23:17,370 --> 00:23:18,750
锁，因为它正在尝试计算

564
00:23:18,750 --> 00:23:20,520
无法获得的总和，因此它开始

565
00:23:20,520 --> 00:23:24,060
等待 t1 完成他的

566
00:23:24,060 --> 00:23:28,590
减量操作在那个时间解锁 a t2 获取 a

567
00:23:28,590 --> 00:23:30,720
上的锁并执行它的读取，

568
00:23:30,720 --> 00:23:32,550
然后解锁它，因为我们在

569
00:23:32,550 --> 00:23:33,990
这里不是两阶段锁定，所以你可以自由

570
00:23:33,990 --> 00:23:36,180
地获取和释放锁，因为你需要

571
00:23:36,180 --> 00:23:41,280
它们它也是 t2 还获得

572
00:23:41,280 --> 00:23:42,570
了 B 上的共享锁 bec 因为它需要对

573
00:23:42,570 --> 00:23:44,820
导致 t1 停止的内容进行写入，因为

574
00:23:44,820 --> 00:23:46,920
它无法执行操作或无法

575
00:23:46,920 --> 00:23:50,720
访问该元组，但最终 t2

576
00:23:50,720 --> 00:23:54,590
释放锁 t1 获得 B 上的锁

577
00:23:54,590 --> 00:23:56,400
完成将资金转移到

578
00:23:56,400 --> 00:24:01,140
博彩公司 帐户解锁提交并且 t2

579
00:24:01,140 --> 00:24:02,670
给了我们错误的输出，

580
00:24:02,670 --> 00:24:05,190
因为它是否读取了不一致的状态，它

581
00:24:05,190 --> 00:24:08,970
读取了 t1 所做工作的苛刻部分，

582
00:24:08,970 --> 00:24:11,400
并且 t1 将该信息泄露给

583
00:24:11,400 --> 00:24:12,390
了系统的其余部分，并说好的

584
00:24:12,390 --> 00:24:14,730
这个银行帐户余额 900 美元，但

585
00:24:14,730 --> 00:24:16,470
它

586
00:24:16,470 --> 00:24:18,720
当 t2 出现并获得

587
00:24:18,720 --> 00:24:21,560
所需的锁时，那一百美元丢失了，

588
00:24:21,770 --> 00:24:27,570
因此使用两阶段锁定密钥，

589
00:24:27,570 --> 00:24:31,260
这里要注意的关键是

590
00:24:31,260 --> 00:24:33,540
它开始相同的 t1 开始

591
00:24:33,540 --> 00:24:35,310
执行它需要的操作 但

592
00:24:35,310 --> 00:24:37,860
在它解锁 a 之前，它会将它

593
00:24:37,860 --> 00:24:40,020
放入收缩阶段，它获取

594
00:24:40,020 --> 00:24:42,050
它在 B 上所需的锁，一直到这里，

595
00:24:42,050 --> 00:24:46,440
所以它在 b t2 上获得排他锁，

596
00:24:46,440 --> 00:24:47,940
等待

597
00:24:47,940 --> 00:24:50,940
它需要的锁，因为这不是

598
00:24:50,940 --> 00:24:52,710
强严格的两阶段锁定

599
00:24:52,710 --> 00:24:59,460
t1 实际上很好地解锁它是的，如果这

600
00:24:59,460 --> 00:25:00,570
是强严格的，它会

601
00:25:00,570 --> 00:25:03,600
在提交时在这里关闭，因此它解锁 a

602
00:25:03,600 --> 00:25:06,330
完成对对象 B 的此操作

603
00:25:06,330 --> 00:25:09,750
，然后释放锁，这

604
00:25:09,750 --> 00:25:13,650
实际上给了我们一个正确的 输出

605
00:25:13,650 --> 00:25:14,910
与强技巧两阶段

606
00:25:14,910 --> 00:25:17,610
行走相同的示例就像我说的解锁

607
00:25:17,610 --> 00:25:19,650
发生在提交之前的最后

608
00:25:19,650 --> 00:25:22,020
所以是的 t1 获得它的锁定 t2 必须

609
00:25:22,020 --> 00:25:25,850
等待整个时间你可以看到

610
00:25:25,850 --> 00:25:27,840
严格的两阶段锁定

611
00:25:27,840 --> 00:25:30,660
有效地强制

612
00:25:30,660 --> 00:25:34,020
这些事务的串行排序通过基本上

613
00:25:34,020 --> 00:25:35,820
获取持有它们的所有锁，

614
00:25:35,820 --> 00:25:38,040
直到您提交时间，您

615
00:25:38,040 --> 00:25:39,390


616
00:25:39,390 --> 00:25:41,250
保证 t2 将具有的任何

617
00:25:41,250 --> 00:25:43,410
会冲突的操作都将

618
00:25:43,410 --> 00:25:51,600
在串行排序中强制执行 感觉我会

619
00:25:51,600 --> 00:25:52,800
选择是

620
00:25:52,800 --> 00:25:56,700
然后再次正确的输出

621
00:25:56,700 --> 00:25:59,610
所以我想我认为安迪

622
00:25:59,610 --> 00:26:02,220
之前在时间表的世界中展示过这张幻灯片

623
00:26:02,220 --> 00:26:03,030


624
00:26:03,030 --> 00:26:06,060
他展示了谷物时间表冲突

625
00:26:06,060 --> 00:26:08,070
系列 zable 安排你可以序列

626
00:26:08,070 --> 00:26:09,930
化然后我不知道他是否有

627
00:26:09,930 --> 00:26:12,360
级联中止所以这张幻灯片

628
00:26:12,360 --> 00:26:14,520
实际上我认为他去年提到

629
00:26:14,520 --> 00:26:16,050
它实际上是不完整的他的

630
00:26:16,050 --> 00:26:18,120
意思是展示两阶段行走

631
00:26:18,120 --> 00:26:19,860
和强严格两阶段锁定 住

632
00:26:19,860 --> 00:26:25,500
在这个层次结构中，我会看看我是否

633
00:26:25,500 --> 00:26:27,270
至少可以使用激光笔，因为

634
00:26:27,270 --> 00:26:29,100
答题器似乎没有做

635
00:26:29,100 --> 00:26:31,950
任何事情，

636
00:26:31,950 --> 00:26:35,630
所以两阶段锁定将存在于

637
00:26:35,630 --> 00:26:38,970
这里的这种区域中，它

638
00:26:38,970 --> 00:26:40,200
保证会产生冲突

639
00:26:40,200 --> 00:26:43,110
可序列化的时间表，但它

640
00:26:43,110 --> 00:26:47,340
很容易受到级联中止的影响 我会

641
00:26:47,340 --> 00:26:49,110
看看我们是否可以为

642
00:26:49,110 --> 00:26:50,430
实际发布在网站上的幻灯片更新这张幻灯片，

643
00:26:50,430 --> 00:26:52,350
所以我们实际上看到的

644
00:26:52,350 --> 00:26:54,270
不仅仅是视频上的激光笔，但是

645
00:26:54,270 --> 00:26:55,890
是两相锁定 会在这里

646
00:26:55,890 --> 00:26:59,580
然后在这个盒子里面和一个圆形的

647
00:26:59,580 --> 00:27:01,080
序列，你会有强大的

648
00:27:01,080 --> 00:27:02,700
两阶段锁定技巧，因为它

649
00:27:02,700 --> 00:27:04,230
保证不会有级联中止

650
00:27:04,230 --> 00:27:06,200
我们得到冲突可序列化的时间表

651
00:27:06,200 --> 00:27:14,010
我们很高兴 感觉所以现在让我们

652
00:27:14,010 --> 00:27:15,990
谈谈

653
00:27:15,990 --> 00:27:18,300
两阶段锁定的另一个问题，即它会

654
00:27:18,300 --> 00:27:19,920
导致死锁，就像我

655
00:27:19,920 --> 00:27:21,480
之前提到的，有几种不同的

656
00:27:21,480 --> 00:27:23,160
方法可以尝试解决这个问题，我们可以

657
00:27:23,160 --> 00:27:27,960
对它有点懒惰并等待使用 一种

658
00:27:27,960 --> 00:27:30,390
用于查找死锁的检测算法，

659
00:27:30,390 --> 00:27:32,070
或者我们可以

660
00:27:32,070 --> 00:27:33,990
对事物采取更积极主动的方式，并首先

661
00:27:33,990 --> 00:27:35,130
尝试防止它们发生，

662
00:27:35,130 --> 00:27:43,710
因此您可能已经

663
00:27:43,710 --> 00:27:46,770
见过死锁，因为它是一个相当

664
00:27:46,770 --> 00:27:50,580
普遍的概念 计算机系统，但

665
00:27:50,580 --> 00:27:53,610
无论如何我们都会给出一个基本的例子，所以 t1

666
00:27:53,610 --> 00:27:55,710
想要一个块管理器上的排他锁，

667
00:27:55,710 --> 00:27:57,150
就像你可以肯定没有

668
00:27:57,150 --> 00:28:00,330
其他人拥有那个锁 t2 获得

669
00:28:00,330 --> 00:28:01,860
B 上的锁，因为现在没有其他人拥有那个

670
00:28:01,860 --> 00:28:05,310
锁 t2 说我 想要像不一样的块管理器上的锁，

671
00:28:05,310 --> 00:28:06,570


672
00:28:06,570 --> 00:28:08,610
你没有得到，但是 t2 会坐在

673
00:28:08,610 --> 00:28:11,730
那里等待那个锁，而 t1 现在

674
00:28:11,730 --> 00:28:14,910
想要 B 上的排他锁，它

675
00:28:14,910 --> 00:28:16,620
也会等待我们现在有问题，

676
00:28:16,620 --> 00:28:18,800
这两个事务都是 等待

677
00:28:18,800 --> 00:28:21,750
锁 另一个事务持有

678
00:28:21,750 --> 00:28:27,470
所以我们需要以某种方式打破这个是的

679
00:28:27,470 --> 00:28:38,130
很好的动画我们有问题是的所以

680
00:28:38,130 --> 00:28:42,840
就像我说的死锁是当你

681
00:28:42,840 --> 00:28:47,160
在

682
00:28:47,160 --> 00:28:48,420
事务与他们持有

683
00:28:48,420 --> 00:28:51,450
锁的地方之间存在依赖循环时我们有几种方法 在这里

684
00:28:51,450 --> 00:28:52,920
处理它们的检测和

685
00:28:52,920 --> 00:28:59,460
预防，因此

686
00:28:59,460 --> 00:29:01,260
系统的死锁检测

687
00:29:01,260 --> 00:29:02,520
就像后台线程一样，您

688
00:29:02,520 --> 00:29:03,960
基本上会查看锁

689
00:29:03,960 --> 00:29:06,180
管理器的元数据，并且您将构建

690
00:29:06,180 --> 00:29:09,480
一个等待图，因此每个节点都是

691
00:29:09,480 --> 00:29:11,580
想法 是一个事务，每条边都是

692
00:29:11,580 --> 00:29:14,340
a 指向另一个节点，该节点

693
00:29:14,340 --> 00:29:18,380
持有该事务所需的锁，

694
00:29:18,380 --> 00:29:20,160
这一切都将在后台完成，

695
00:29:20,160 --> 00:29:22,440
您可以

696
00:29:22,440 --> 00:29:23,790
平衡完成此操作的频率，我们

697
00:29:23,790 --> 00:29:25,860
将在稍后讨论 但想法是

698
00:29:25,860 --> 00:29:28,860
它是一个后台任务，它检查

699
00:29:28,860 --> 00:29:30,300
锁管理器的状态并说嘿，

700
00:29:30,300 --> 00:29:33,570
是否有任何死锁使用你

701
00:29:33,570 --> 00:29:36,470
最喜欢的循环检测算法，

702
00:29:36,470 --> 00:29:38,550
你必须决定你是什么

703
00:29:38,550 --> 00:29:42,720
为了解决这个死锁，让我们

704
00:29:42,720 --> 00:29:44,310
看一个简单的例子，看看

705
00:29:44,310 --> 00:29:47,870
这些等待图是什么样子

706
00:29:48,470 --> 00:29:54,900


707
00:29:54,900 --> 00:29:57,180


708
00:29:57,180 --> 00:29:59,940
的

709
00:29:59,940 --> 00:30:03,930
指向 T 2 T 2 的边将以

710
00:30:03,930 --> 00:30:05,400
指向 t 3 的边结束，因为

711
00:30:05,400 --> 00:30:07,260
正如你在这里看到的，它需要一个

712
00:30:07,260 --> 00:30:09,000
排他锁，而 T 3 已经持有一个

713
00:30:09,000 --> 00:30:11,430
不兼容的共享锁，所以

714
00:30:11,430 --> 00:30:13,770
我们只是在等待和 那么最后

715
00:30:13,770 --> 00:30:14,850
T 3 最终会得到一个

716
00:30:14,850 --> 00:30:16,500
指向 T 1 的边，因为它想要一个

717
00:30:16,500 --> 00:30:18,240
排他锁，T 1 有一个共享

718
00:30:18,240 --> 00:30:20,730
锁，我们有

719
00:30:20,730 --> 00:30:24,180
一个死锁，所以我们必须

720
00:30:24,180 --> 00:30:32,810
对这个问题做些什么，

721
00:30:34,850 --> 00:30:40,860
所以死锁处理是什么 简单地

722
00:30:40,860 --> 00:30:44,790
选择一个受害者杀死它你选择一个

723
00:30:44,790 --> 00:30:47,520
事务然后

724
00:30:47,520 --> 00:30:49,860
你回滚它你回滚到什么程度是一种

725
00:30:49,860 --> 00:30:51,510
实现来发现它可能你

726
00:30:51,510 --> 00:30:53,430
没有，我认为这是一张

727
00:30:53,430 --> 00:30:56,820
后来的幻灯片，但你可能不必

728
00:30:56,820 --> 00:30:58,200
中止整个事务可能

729
00:30:58,200 --> 00:30:59,490
不必撤消 它所做的所有查询

730
00:30:59,490 --> 00:31:00,900
也许只有您可能只需要

731
00:31:00,900 --> 00:31:02,340
部分回滚一些查询

732
00:31:02,340 --> 00:31:04,110
以释放您需要关联的锁，

733
00:31:04,110 --> 00:31:06,780
以消除死锁并

734
00:31:06,780 --> 00:31:11,610
在系统中取得进展

735
00:31:11,610 --> 00:31:13,710
这里的最后一点基本上是

736
00:31:13,710 --> 00:31:15,540
说 你在系统中需要

737
00:31:15,540 --> 00:31:17,000


738
00:31:17,000 --> 00:31:19,650
权衡你为图表构建这些权重的频率

739
00:31:19,650 --> 00:31:21,540
如果你处理死锁的方式

740
00:31:21,540 --> 00:31:24,150
是检测 你有这个后台

741
00:31:24,150 --> 00:31:25,920
任务 它正在构建这些图表

742
00:31:25,920 --> 00:31:28,560
检查死锁 对您来说，

743
00:31:28,560 --> 00:31:30,150
您希望以多长时间完成该任务，

744
00:31:30,150 --> 00:31:31,650
如果您愿意，可以每微秒执行一次，

745
00:31:31,650 --> 00:31:33,870
但是您将消耗大量

746
00:31:33,870 --> 00:31:36,000
CPU 周期不断构建这些

747
00:31:36,000 --> 00:31:37,800
图，并且可能找不到

748
00:31:37,800 --> 00:31:40,050
任何死锁，因此您可能想要

749
00:31:40,050 --> 00:31:42,450
推理的是可以的 也许我想

750
00:31:42,450 --> 00:31:44,250
不那么频繁地检查死锁，

751
00:31:44,250 --> 00:31:45,750
如果我确实进入了死锁状态，你

752
00:31:45,750 --> 00:31:49,230
知道我想让这些

753
00:31:49,230 --> 00:31:50,870
事务等待多

754
00:31:50,870 --> 00:31:53,130
长时间我可以坐下的可接受的超时时间

755
00:31:53,130 --> 00:31:56,730
没有立即检测到的死锁状态

756
00:31:56,730 --> 00:31:58,200
所以这些都是

757
00:31:58,200 --> 00:31:59,550
你的数据库系统中的可调参数

758
00:31:59,550 --> 00:32:01,740
因为不同的工作负载

759
00:32:01,740 --> 00:32:03,780
会表现出不同的死锁

760
00:32:03,780 --> 00:32:05,610
行为 所以我们要确保我们

761
00:32:05,610 --> 00:32:08,160
不会太激进 这可能没问题

762
00:32:08,160 --> 00:32:09,450
使系统处于死锁

763
00:32:09,450 --> 00:32:12,300
状态甚至十秒钟，但这

764
00:32:12,300 --> 00:32:14,100
取决于系统的响应能力需要是什么，

765
00:32:14,100 --> 00:32:17,030


766
00:32:21,020 --> 00:32:26,250
所以受害者选择有很多

767
00:32:26,250 --> 00:32:27,330
不同的东西你可以在这里查看

768
00:32:27,330 --> 00:32:30,090
，并且某些系统会变得非常

769
00:32:30,090 --> 00:32:31,620
详细 他们做了什么，但是

770
00:32:31,620 --> 00:32:32,220
有各种各样不同的

771
00:32:32,220 --> 00:32:34,860
启发式方法，你可以先看看

772
00:32:34,860 --> 00:32:35,850


773
00:32:35,850 --> 00:32:37,860
当你试图找到一个

774
00:32:37,860 --> 00:32:39,390
你要杀死的受害者时，看看交易的年龄，因为

775
00:32:39,390 --> 00:32:40,260
在一天结束时 你有这个

776
00:32:40,260 --> 00:32:43,409
循环 你必须选择一个 你可以

777
00:32:43,409 --> 00:32:45,750
从时间戳开始 你可以看看

778
00:32:45,750 --> 00:32:47,280
它完成了多少工作

779
00:32:47,280 --> 00:32:48,919
它执行了多少查询 它执行了多少

780
00:32:48,919 --> 00:32:53,190
进度 你不知道如何 关闭

781
00:32:53,190 --> 00:32:54,600
它正在完成，但你最不可能

782
00:32:54,600 --> 00:32:58,380
推断出它完成了多少工作

783
00:32:58,380 --> 00:33:05,220
它已经持有多少个锁，这

784
00:33:05,220 --> 00:33:06,750
可能你必须查看

785
00:33:06,750 --> 00:33:07,980
你必须回滚的事务数量

786
00:33:07,980 --> 00:33:09,480
，

787
00:33:09,480 --> 00:33:11,700
如果你 有级联中止

788
00:33:11,700 --> 00:33:15,179
我不认为我之前提到过你

789
00:33:15,179 --> 00:33:16,679
不必做强严格的两阶段

790
00:33:16,679 --> 00:33:17,100
锁定

791
00:33:17,100 --> 00:33:19,230
一些系统可能只做两阶段

792
00:33:19,230 --> 00:33:22,590
锁定并忍受

793
00:33:22,590 --> 00:33:24,090
级联再次中止的可能性 这将

794
00:33:24,090 --> 00:33:30,120
取决于工作负载，你可以 决定

795
00:33:30,120 --> 00:33:32,690
工作负载是否不太容易受到

796
00:33:32,690 --> 00:33:35,850
级联中止或脏读的影响 你

797
00:33:35,850 --> 00:33:37,380
可以说两阶段锁定很好 我可以

798
00:33:37,380 --> 00:33:38,970
更快地释放我的锁 这可能会

799
00:33:38,970 --> 00:33:40,860
再次导致系统中更高的吞吐量

800
00:33:40,860 --> 00:33:41,970
这通常是可

801
00:33:41,970 --> 00:33:55,919
配置的东西是的 我们稍后会

802
00:33:55,919 --> 00:33:59,880
讨论几种不同的方法来

803
00:33:59,880 --> 00:34:01,559
决定哪个

804
00:34:01,559 --> 00:34:03,570
事务被杀死

805
00:34:03,570 --> 00:34:07,669
有几种不同的解决方案，

806
00:34:07,669 --> 00:34:14,849
但另一种是是的 他

807
00:34:14,849 --> 00:34:16,080
通常会是多种因素的

808
00:34:16,080 --> 00:34:17,460
组合 它不一定

809
00:34:17,460 --> 00:34:18,960
总是只是交易的年龄

810
00:34:18,960 --> 00:34:20,040
将是决定您

811
00:34:20,040 --> 00:34:21,989
是否被杀的因素 通常

812
00:34:21,989 --> 00:34:23,369
最重要的事情之一就是

813
00:34:23,369 --> 00:34:24,629
数量 很多时候你已经

814
00:34:24,629 --> 00:34:27,599
被杀了，是的，然后最后一个

815
00:34:27,599 --> 00:34:29,250
说在那里，因为你确实想

816
00:34:29,250 --> 00:34:30,540
确保你在系统中取得进展，你

817
00:34:30,540 --> 00:34:31,859
需要防止这些

818
00:34:31,859 --> 00:34:33,330
交易的饥饿

819
00:34:33,330 --> 00:34:36,389
，我不是说这些中的任何一个

820
00:34:36,389 --> 00:34:38,010
是 正是您将用于

821
00:34:38,010 --> 00:34:40,500
终止交易的商业

822
00:34:40,500 --> 00:34:42,869
系统变得相当复杂，并且可以

823
00:34:42,869 --> 00:34:45,089
构建预测模型甚至试图

824
00:34:45,089 --> 00:34:47,040
找出他们

825
00:34:47,040 --> 00:34:48,300
应该尝试终止哪个交易并

826
00:34:48,300 --> 00:34:50,369
根据所有这些不同的启发式回答死锁场景，

827
00:34:50,369 --> 00:34:53,879
所以 它通常是一个

828
00:34:53,879 --> 00:34:55,409
组合，它不只是

829
00:34:55,409 --> 00:34:56,760
时间戳，我想回答你的问题还有很长的路要走，

830
00:34:56,760 --> 00:35:22,830


831
00:35:22,830 --> 00:35:25,470
所以你的问题是你为什么会抱歉

832
00:35:25,470 --> 00:35:26,580
我想确保我代表 为视频吃回来

833
00:35:26,580 --> 00:35:27,990
你的问题是为什么你

834
00:35:27,990 --> 00:35:29,730
总是想在什么情况下杀死

835
00:35:29,730 --> 00:35:30,930
你想

836
00:35:30,930 --> 00:35:39,240
用最低的时间戳杀死事务总是是的我

837
00:35:39,240 --> 00:35:41,580
怀疑它仍然总是

838
00:35:41,580 --> 00:35:47,339
取决于工作量，这取决于

839
00:35:47,339 --> 00:35:49,280
导致死锁的原因是什么

840
00:35:49,280 --> 00:35:53,820
某种情况导致了它，但是是的，我们将

841
00:35:53,820 --> 00:35:55,950
在几张

842
00:35:55,950 --> 00:35:58,500
幻灯片中正式确定什么被杀死以及为什么被杀死，

843
00:35:58,500 --> 00:36:04,530
但我认为在示例中的 Postgres 的情况下，

844
00:36:04,530 --> 00:36:06,210
我们将看到最高

845
00:36:06,210 --> 00:36:08,880
时间戳被杀死我 我想我认为

846
00:36:08,880 --> 00:36:09,900
这只是一个例子我只是

847
00:36:09,900 --> 00:36:12,750
说就像你是一根棍子你可以

848
00:36:12,750 --> 00:36:15,020


849
00:36:18,330 --> 00:36:20,190
像我之前提到的那样看

850
00:36:20,190 --> 00:36:21,690
你可能不需要中止整个

851
00:36:21,690 --> 00:36:23,580
交易你可以完全中止

852
00:36:23,580 --> 00:36:25,230
它或者你可以做 某种最小的

853
00:36:25,230 --> 00:36:27,540
中止，您只回滚

854
00:36:27,540 --> 00:36:29,130
该事务中的查询数量，这将

855
00:36:29,130 --> 00:36:30,480
允许您释放死锁并

856
00:36:30,480 --> 00:36:32,390


857
00:36:32,390 --> 00:36:34,320
再次在系统中取得进展，这将

858
00:36:34,320 --> 00:36:35,640
取决于工作 广告您放弃了多少工作

859
00:36:35,640 --> 00:36:39,120
，以及

860
00:36:39,120 --> 00:36:40,920
让事务

861
00:36:40,920 --> 00:36:44,330
重新提交所有查询是否有意义，或者您是否可以

862
00:36:44,330 --> 00:36:47,660
慢慢展开其中的一部分以便

863
00:36:47,660 --> 00:36:49,710
在僵局中释放系统并

864
00:36:49,710 --> 00:36:56,760
取得进展让我们看看我们是否

865
00:36:56,760 --> 00:37:16,770
可以得到一个演示，请原谅我

866
00:37:16,770 --> 00:37:33,660
在这个表面键盘上打字很酷，看起来

867
00:37:33,660 --> 00:37:37,740
它正在工作，所以我们将从我的

868
00:37:37,740 --> 00:37:43,260
续集开始 我们将打开两个终端 我们

869
00:37:43,260 --> 00:37:46,980
有一个非常基本的表设置，称为

870
00:37:46,980 --> 00:37:49,800
事务演示 这太可怕了，你

871
00:37:49,800 --> 00:37:51,090
看不到 那里发生了什么 但

872
00:37:51,090 --> 00:37:53,240
基本上我们有两个元组

873
00:37:53,240 --> 00:37:55,740
主键 ID 一和二

874
00:37:55,740 --> 00:37:59,550
值 100 和 200 非常简单 我们有

875
00:37:59,550 --> 00:38:01,320
两个元组 这应该很

876
00:38:01,320 --> 00:38:05,760
容易让我们进入死锁状态所以

877
00:38:05,760 --> 00:38:13,470
我不知道是哪个 如果你

878
00:38:13,470 --> 00:38:15,860
按下所有按钮

879
00:38:15,860 --> 00:38:18,120
我很高兴我站在你旁边

880
00:38:18,120 --> 00:38:30,170
我们在磁带制作人 Juan

881
00:38:34,790 --> 00:38:37,440
那里得到了每个人 所以我们在我们的表交易演示中得到了这两个元组

882
00:38:37,440 --> 00:38:39,720


883
00:38:39,720 --> 00:38:45,860
我们要做的第一件事就是设置我们的 在这里超时

884
00:38:47,210 --> 00:38:49,230
所以就像我说的那样，在你可以

885
00:38:49,230 --> 00:38:51,030
调整诸如检测死锁的频率之类的东西之前

886
00:38:51,030 --> 00:38:52,650
，在

887
00:38:52,650 --> 00:38:56,610
这种情况下，我们将尝试

888
00:38:56,610 --> 00:39:00,060
更改锁定等待时间，你知道 DB

889
00:39:00,060 --> 00:39:03,710
是我续集的存储引擎

890
00:39:03,710 --> 00:39:06,960
的我不知道我的续集五我想

891
00:39:06,960 --> 00:39:07,890
或者类似的

892
00:39:07,890 --> 00:39:10,410
所以第一个终端将开始

893
00:39:10,410 --> 00:39:13,170
交易我们要做的第一件事

894
00:39:13,170 --> 00:39:17,520
是尝试更新元组的值

895
00:39:17,520 --> 00:39:23,660
哦实际上我错过了

896
00:39:23,660 --> 00:39:27,750
我们需要明确的步骤 告诉我的续集我们

897
00:39:27,750 --> 00:39:28,920
想在可序列化的隔离级别上运行，

898
00:39:28,920 --> 00:39:30,270
这样就会给

899
00:39:30,270 --> 00:39:33,060
我们冲突可序列化的时间表我们

900
00:39:33,060 --> 00:39:34,260
还

901
00:39:34,260 --> 00:39:35,310
没有像我说的那样谈论隔离级别我认为这

902
00:39:35,310 --> 00:39:38,790
将在下一节课中进行但我们需要我们

903
00:39:38,790 --> 00:39:41,490
需要 告诉系统我们想要可

904
00:39:41,490 --> 00:39:50,360
序列化的隔离级别返回

905
00:39:50,360 --> 00:39:54,450
开始我们的事务我们会

906
00:39:54,450 --> 00:39:59,430
像我说的更新元组上的值

907
00:39:59,430 --> 00:40:04,350
切换到我们的另一个终端我们

908
00:40:04,350 --> 00:40:05,880
要开始一个事务我们

909
00:40:05,880 --> 00:40:09,080
要更新元组上的值 两个

910
00:40:15,050 --> 00:40:17,990
如此 到目前为止还没有冲突 t1 持有一个

911
00:40:17,990 --> 00:40:21,080
步行元组 1 t2 持有元组 2 的锁

912
00:40:21,080 --> 00:40:23,030
我们将回到

913
00:40:23,030 --> 00:40:24,890
这里的两个事务 1 我们会说

914
00:40:24,890 --> 00:40:28,040
好的 我想更新 ID 2 上的值

915
00:40:28,040 --> 00:40:30,620
，它只是 等待我所能做的就是

916
00:40:30,620 --> 00:40:34,400
停止它等待锁定然后

917
00:40:34,400 --> 00:40:36,680
我们可以回到 t2 并说我想

918
00:40:36,680 --> 00:40:38,450
更新一个 t1 上的值持有该

919
00:40:38,450 --> 00:40:40,250
步行我们应该会陷入僵局

920
00:40:40,250 --> 00:40:43,610
，果然我们会陷入僵局，我的

921
00:40:43,610 --> 00:40:46,750
续集大喊大叫 我们很快就

922
00:40:46,810 --> 00:40:50,110
不是大量的调试信息，而是

923
00:40:50,110 --> 00:40:51,830
在尝试获取

924
00:40:51,830 --> 00:40:53,570
锁定时出现死锁声音尝试重新启动应用程序，

925
00:40:53,570 --> 00:40:57,890
您会注意到 t1 正在等待

926
00:40:57,890 --> 00:41:01,730
值 2 上的锁定，

927
00:41:01,730 --> 00:41:04,280
一旦系统检测到死锁

928
00:41:04,280 --> 00:41:07,400
t2 它杀死了那个事务 t1 得到了

929
00:41:07,400 --> 00:41:11,050
锁并取得了它需要的进展

930
00:41:20,590 --> 00:41:22,520
你是什么意思为什么没有我

931
00:41:22,520 --> 00:41:29,930
没有隔离我们可以检查所以

932
00:41:29,930 --> 00:41:31,610
我只是要杀死但我要

933
00:41:31,610 --> 00:41:38,530
回滚这两个和 我们将开始

934
00:41:38,530 --> 00:41:40,330
[Music]

935
00:41:40,330 --> 00:41:44,350
我们将更新 ID 1 中的值

936
00:41:44,350 --> 00:41:48,580
转到 t2 开始交易

937
00:41:48,580 --> 00:41:53,180
更新值或 ID 为 2 然后

938
00:41:53,180 --> 00:41:57,130
我们将

939
00:41:57,130 --> 00:42:02,360
在 t1 中从交易演示中选择一个星，所以它无法

940
00:42:02,360 --> 00:42:06,820
获得闩锁或请原谅我的锁，

941
00:42:06,820 --> 00:42:09,440
它只是会它只是

942
00:42:09,440 --> 00:42:11,620


943
00:42:13,860 --> 00:42:18,340
如果我们进行回滚，我们会看到

944
00:42:18,340 --> 00:42:20,620
值 t2 从未写入表中，

945
00:42:20,620 --> 00:42:23,530
因为它没有提交并且 t1 能够

946
00:42:23,530 --> 00:42:24,670
通过获取共享锁来向前推进

947
00:42:24,670 --> 00:42:33,990
很酷的好问题

948
00:42:33,990 --> 00:42:38,470
是的，我是说在实践中你 '可能

949
00:42:38,470 --> 00:42:40,360
会看到严格的两阶段

950
00:42:40,360 --> 00:42:42,190
步行，因为系统无法

951
00:42:42,190 --> 00:42:44,770
推理它是否应该急切地

952
00:42:44,770 --> 00:42:46,510
开始发布法律，因为它不

953
00:42:46,510 --> 00:42:47,980
知道客户接下来要做什么，

954
00:42:47,980 --> 00:42:51,160
所以你可以，但我不认为 任何

955
00:42:51,160 --> 00:42:53,140
系统都这样做，您可以

956
00:42:53,140 --> 00:42:55,660
推测尽早开始释放锁，

957
00:42:55,660 --> 00:42:59,260
但您可能会弄错，我们不会错，因为

958
00:42:59,260 --> 00:43:02,320
我们必须确保

959
00:43:02,320 --> 00:43:04,720
我们保证这些隔离

960
00:43:04,720 --> 00:43:12,820
保证确实很好，这

961
00:43:12,820 --> 00:43:15,580
实际上不是真的，就像我一样 说我们会

962
00:43:15,580 --> 00:43:17,410
谈谈 ut 隔离级别在下一

963
00:43:17,410 --> 00:43:19,900
课中也有一些场景，

964
00:43:19,900 --> 00:43:21,190
您可能愿意以

965
00:43:21,190 --> 00:43:23,170
较低的隔离保证运行，并且

966
00:43:23,170 --> 00:43:25,000


967
00:43:25,000 --> 00:43:27,790
如果您对

968
00:43:27,790 --> 00:43:28,930
它们感到满意，或者如果在

969
00:43:28,930 --> 00:43:30,310
应用程序层您有您的需求，您可以开始将某些异常引入系统 自己的

970
00:43:30,310 --> 00:43:31,630
逻辑来推理那种东西

971
00:43:31,630 --> 00:43:35,740
你可以降低隔离保证，如果它

972
00:43:35,740 --> 00:43:38,910
提高了你的系统的性能

973
00:43:45,750 --> 00:43:48,250
是的，如此强大的技巧强大的

974
00:43:48,250 --> 00:43:49,930
严格两阶段锁定或严格的

975
00:43:49,930 --> 00:43:51,790
两阶段锁定是我们需要使用的，

976
00:43:51,790 --> 00:43:53,110
如果我们想保证 我们没有得到任何

977
00:43:53,110 --> 00:43:54,910
可能导致级联中止的脏读，

978
00:43:54,910 --> 00:43:58,050


979
00:44:02,720 --> 00:44:04,460
所以这是我的续集，我们可以

980
00:44:04,460 --> 00:44:12,579
真正快速地看看 Postgres，我们将做一个

981
00:44:12,819 --> 00:44:16,550
类似的演示 Postgres 还有一件

982
00:44:16,550 --> 00:44:17,839
很酷的事情我们可以在这里做，所以我们

983
00:44:17,839 --> 00:44:19,010
将死锁超时设置为 10

984
00:44:19,010 --> 00:44:25,730
秒演示本身是让

985
00:44:25,730 --> 00:44:35,569
我确保我创建了这个表很酷

986
00:44:35,569 --> 00:44:42,260
同一个表存在两个值与

987
00:44:42,260 --> 00:44:45,369
Postgres 我们实际上可以

988
00:44:45,369 --> 00:44:48,170
开始每个 t 说我们希望

989
00:44:48,170 --> 00:44:50,030
隔离级别可序列化，因为

990
00:44:50,030 --> 00:44:51,710
实际上它不一定是

991
00:44:51,710 --> 00:44:52,970
会话范围的设置，您实际上可以

992
00:44:52,970 --> 00:44:55,940
添加事务粒度定义

993
00:44:55,940 --> 00:44:57,349
要运行的隔离级别

994
00:44:57,349 --> 00:45:00,470
，我一直说隔离级别，

995
00:45:00,470 --> 00:45:01,940
我们将在 未来的

996
00:45:01,940 --> 00:45:11,060
讲座 t1 将开始 哦，已经

997
00:45:11,060 --> 00:45:13,369
开始了，没错，我们将

998
00:45:13,369 --> 00:45:16,690
执行相同的操作，我们将更新

999
00:45:16,690 --> 00:45:19,790
值或 ID 为 1，我们将

1000
00:45:19,790 --> 00:45:22,220
继续执行相同的操作，其中值

1001
00:45:22,220 --> 00:45:27,020
等于 2 返回 t1 尝试更新 2

1002
00:45:27,020 --> 00:45:29,839
我们等待寻找我们

1003
00:45:29,839 --> 00:45:32,210
还没有的锁，然后我们将

1004
00:45:32,210 --> 00:45:34,130
通过要求 t2 更新

1005
00:45:34,130 --> 00:45:39,380
与 1 相关的值来强制死锁，那里有

1006
00:45:39,380 --> 00:45:40,849
一点延迟我不知道 你看到

1007
00:45:40,849 --> 00:45:42,530
了，但它与我的续集相比，我的续集

1008
00:45:42,530 --> 00:45:45,430
立即就好像这是一个僵局

1009
00:45:45,430 --> 00:45:47,569
Postgres

1010
00:45:47,569 --> 00:45:49,010
在它对我们大喊大叫并说

1011
00:45:49,010 --> 00:45:50,960
嘿你在系统中陷入僵局之前

1012
00:45:50,960 --> 00:45:52,069
就像我说这些是可调参数一样

1013
00:45:52,069 --> 00:45:54,140
你可以你可以调整

1014
00:45:54,140 --> 00:45:56,240
数据库系统在

1015
00:45:56,240 --> 00:45:57,130
寻找死日志方面的积极性如何

1016
00:45:57,130 --> 00:45:59,859
Postgres 为我们提供了更多的信息，

1017
00:45:59,859 --> 00:46:02,599
它告诉我们哪个进程正在

1018
00:46:02,599 --> 00:46:04,130
等待另一个事务持有什么样的锁，

1019
00:46:04,130 --> 00:46:06,170
这是另一个

1020
00:46:06,170 --> 00:46:08,770
进程

1021
00:46:09,579 --> 00:46:12,410
Postgres 我认为这是一个 一个重要的

1022
00:46:12,410 --> 00:46:14,390
原因，他喜欢提到

1023
00:46:14,390 --> 00:46:15,770
Postgres，因为它基本上是一本

1024
00:46:15,770 --> 00:46:16,520
教科书，

1025
00:46:16,520 --> 00:46:18,830
你从系统中得到的措辞

1026
00:46:18,830 --> 00:46:22,190
正是你

1027
00:46:22,190 --> 00:46:23,810
在数据库教科书中看到的，以及

1028
00:46:23,810 --> 00:46:25,790
可以帮助我们

1029
00:46:25,790 --> 00:46:30,290
理解发生了什么的行为 这里还有

1030
00:46:30,290 --> 00:46:34,010
一件事我们可以尝试，

1031
00:46:34,010 --> 00:46:38,620
但我会再做一件事，

1032
00:46:38,620 --> 00:46:43,000
所以我要把这两个都回滚

1033
00:46:48,280 --> 00:46:50,600
我要把超时设置为 20

1034
00:46:50,600 --> 00:46:52,010
秒，因为还有一件事

1035
00:46:52,010 --> 00:47:08,540
我们想要 试着看看让我们看看我是否能再

1036
00:47:08,540 --> 00:47:16,190
得到一个酷的终端 希望

1037
00:47:16,190 --> 00:47:27,800
这仍然可以播放

1038
00:47:27,800 --> 00:47:31,820
死锁超时 做同样的事情 开始

1039
00:47:31,820 --> 00:47:35,120
交易并序列化到

1040
00:47:35,120 --> 00:47:39,830
终端 这将是 sli

1041
00:47:39,830 --> 00:47:41,530
与死锁检测

1042
00:47:41,530 --> 00:47:45,680
算法竞争所以我在这里尝试做的是

1043
00:47:45,680 --> 00:47:51,530
展示

1044
00:47:51,530 --> 00:47:55,510
一些 Postgres 提供给你的内部元数据，

1045
00:47:55,990 --> 00:47:59,420
以及它如何跟踪这些

1046
00:47:59,420 --> 00:48:07,580
事情，我的团队加入

1047
00:48:07,580 --> 00:48:10,030
刚刚死了

1048
00:48:13,220 --> 00:48:18,920
它死了很酷

1049
00:48:19,520 --> 00:48:23,840
这仍然有 一个连接 没什么意思

1050
00:48:23,840 --> 00:48:27,480
那个演示很酷

1051
00:48:27,480 --> 00:48:30,750
反正我们已经很久了 但这个想法是

1052
00:48:30,750 --> 00:48:31,890
如果我们能够将系统

1053
00:48:31,890 --> 00:48:34,109
置于死锁状态

1054
00:48:34,109 --> 00:48:35,670
我将查询目录 它将能够

1055
00:48:35,670 --> 00:48:38,940
显示哪个 事务持有

1056
00:48:38,940 --> 00:48:40,740
锁哪些锁他们正在等待

1057
00:48:40,740 --> 00:48:42,300
哪些事务和进程

1058
00:48:42,300 --> 00:48:43,369
属于

1059
00:48:43,369 --> 00:48:50,609
Postgres 很棒让我们回到这些

1060
00:48:50,609 --> 00:49:00,990
东西，就像我们之前讨论过的那样

1061
00:49:00,990 --> 00:49:02,640
，做检测算法的替代方法

1062
00:49:02,640 --> 00:49:04,920
是防止自己

1063
00:49:04,920 --> 00:49:06,270
进入其他人 首先是死锁

1064
00:49:06,270 --> 00:49:07,680
状态 如果我们能

1065
00:49:07,680 --> 00:49:08,670
想出某种系统来

1066
00:49:08,670 --> 00:49:11,550
防止这种情况发生 我们

1067
00:49:11,550 --> 00:49:12,900
永远不需要为图构建权重

1068
00:49:12,900 --> 00:49:14,550
我们不需要这个 地面

1069
00:49:14,550 --> 00:49:16,109
任务然后需要决定

1070
00:49:16,109 --> 00:49:18,900
我们要杀死哪个进程或

1071
00:49:18,900 --> 00:49:23,450
我们要杀死哪个事务，我

1072
00:49:23,450 --> 00:49:26,790
怀疑这可能是我的续集

1073
00:49:26,790 --> 00:49:29,040
正在做的事情，因为我的续集立即

1074
00:49:29,040 --> 00:49:31,430
对我们大喊我们陷入僵局或

1075
00:49:31,430 --> 00:49:33,510
立即检测到它并没有

1076
00:49:33,510 --> 00:49:34,890
防止死锁，但它立即检测到

1077
00:49:34,890 --> 00:49:37,440
它，而不是 Postgres，后者

1078
00:49:37,440 --> 00:49:39,030


1079
00:49:39,030 --> 00:49:45,600
在检测时有一点滞后，因此一个非常简单的

1080
00:49:45,600 --> 00:49:47,609
方法是根据时间戳分配优先级，

1081
00:49:47,609 --> 00:49:49,710
因此 较旧的交易被

1082
00:49:49,710 --> 00:49:52,109
认为具有更高的优先级，然后

1083
00:49:52,109 --> 00:49:53,460
你有两种不同的协议，你

1084
00:49:53,460 --> 00:49:55,890
可以遵循你有这个等待死亡系统

1085
00:49:55,890 --> 00:49:58,080
，这基本上只是意味着旧

1086
00:49:58,080 --> 00:50:00,420
交易等待新交易，

1087
00:50:00,420 --> 00:50:02,550
所以如果请求交易具有

1088
00:50:02,550 --> 00:50:06,540
更高的优先级，它会被

1089
00:50:06,540 --> 00:50:07,950
持有 交易所以持有

1090
00:50:07,950 --> 00:50:10,710
交易比它年轻但

1091
00:50:10,710 --> 00:50:13,020
旧的交易想要它的锁

1092
00:50:13,020 --> 00:50:14,790
然后请求的交易只是会

1093
00:50:14,790 --> 00:50:18,990
坐下来等待其他 反过来，

1094
00:50:18,990 --> 00:50:20,190
请求交易将

1095
00:50:20,190 --> 00:50:22,290
中止另一个系统称为伤口权重，

1096
00:50:22,290 --> 00:50:23,760
您可以将其视为年轻

1097
00:50:23,760 --> 00:50:25,910
等待旧的请求交易

1098
00:50:25,910 --> 00:50:28,069
他们比持有交易具有更高的优先级

1099
00:50:28,069 --> 00:50:30,589


1100
00:50:30,589 --> 00:50:32,420
董事会的持有交易所以基本上

1101
00:50:32,420 --> 00:50:34,220
请求交易进来 窃取

1102
00:50:34,220 --> 00:50:36,099
您的锁并取得进展

1103
00:50:36,099 --> 00:50:38,180
或者请求的事务

1104
00:50:38,180 --> 00:50:40,700
只是等待 所以这可能会令人困惑

1105
00:50:40,700 --> 00:50:42,589
它有点清晰 我认为

1106
00:50:42,589 --> 00:50:46,220
在下一张幻灯片的示例中所以我们

1107
00:50:46,220 --> 00:50:48,829
有这两个场景 这两个

1108
00:50:48,829 --> 00:50:50,869
我们想要查看的时间表

1109
00:50:50,869 --> 00:50:53,539
先看第一个 t1 和 t2 t1

1110
00:50:53,539 --> 00:50:55,309
首先开始，所以 t1 的

1111
00:50:55,309 --> 00:50:58,970
优先级会

1112
00:50:58,970 --> 00:51:02,930


1113
00:51:02,930 --> 00:51:05,690


1114
00:51:05,690 --> 00:51:08,000
比 t2 高

1115
00:51:08,000 --> 00:51:11,000
优先所以体重过轻的人

1116
00:51:11,000 --> 00:51:14,119
会等待那个锁和受伤的

1117
00:51:14,119 --> 00:51:17,420
体重 T t1 基本上会

1118
00:51:17,420 --> 00:51:19,630
进来杀死 T 来偷它的午餐钱和

1119
00:51:19,630 --> 00:51:24,650
t2 必须重新启动或任何它

1120
00:51:24,650 --> 00:51:26,930
需要做的任何应用程序需要对第二个计划

1121
00:51:26,930 --> 00:51:30,069
中的应用事务做的任何事情

1122
00:51:30,069 --> 00:51:35,539
t1 再次

1123
00:51:35,539 --> 00:51:37,490
在 t2 之前开始，因此它有一个较旧的时间戳

1124
00:51:37,490 --> 00:51:39,380
，它具有更高的优先级，但它首先获得了锁

1125
00:51:39,380 --> 00:51:43,099
t2 希望该锁在重量下

1126
00:51:43,099 --> 00:51:48,859
die t2 将中止并且在伤口

1127
00:51:48,859 --> 00:51:52,190
重量下 t2 将等待所以

1128
00:51:52,190 --> 00:51:53,480
这两个策略正在做的是它们

1129
00:51:53,480 --> 00:51:59,529
基本上定义了

1130
00:51:59,529 --> 00:52:02,480
我们用于闩锁和

1131
00:52:02,480 --> 00:52:03,650
并发数据结构的相同类型的逻辑，其中

1132
00:52:03,650 --> 00:52:05,359
我们只采用闩锁的概念 一个

1133
00:52:05,359 --> 00:52:08,089
方向，我们以一种

1134
00:52:08,089 --> 00:52:09,319
纪律的方式释放它们，就像如果你

1135
00:52:09,319 --> 00:52:13,430
可以对

1136
00:52:13,430 --> 00:52:14,779
你如何获得你的锁应用某种排序，这

1137
00:52:14,779 --> 00:52:17,359
实际上是这样做的，你

1138
00:52:17,359 --> 00:52:20,770
可以完全避免死锁，所以一个人的

1139
00:52:20,770 --> 00:52:23,119
体重基本上消失了，我们说好的 '

1140
00:52:23,119 --> 00:52:26,299
我们要

1141
00:52:26,299 --> 00:52:27,500
在一个方向上对我们的时间戳进行排序，以及我们如何

1142
00:52:27,500 --> 00:52:29,000
分发锁，然后在月球重量中

1143
00:52:29,000 --> 00:52:30,890
，只要

1144
00:52:30,890 --> 00:52:32,299
我们保持一致，基本上就相反了 不能混合这些

1145
00:52:32,299 --> 00:52:33,980
东西，如果你开始混合它们，你

1146
00:52:33,980 --> 00:52:36,020
会得到死锁，因为你为什么

1147
00:52:36,020 --> 00:52:37,039
要这样做，因为那样你需要一个

1148
00:52:37,039 --> 00:52:38,940
死锁检测算法，

1149
00:52:38,940 --> 00:52:49,210
你没有解决任何问题，

1150
00:52:49,210 --> 00:52:50,769
所以问题是为什么 这被称为伤口

1151
00:52:50,769 --> 00:52:52,829
重量而不是某种

1152
00:52:52,829 --> 00:52:55,569
相反的重量死我不知道我

1153
00:52:55,569 --> 00:52:57,130
真的不喜欢这个命名

1154
00:52:57,130 --> 00:53:01,329
我觉得它很混乱是的

1155
00:53:01,329 --> 00:53:02,710
如果你感到困惑但如果是的如果你

1156
00:53:02,710 --> 00:53:07,420
被 命名我和你在一起 我认为

1157
00:53:07,420 --> 00:53:10,089
这就是为什么安迪有点

1158
00:53:10,089 --> 00:53:12,010
像

1159
00:53:12,010 --> 00:53:13,720
年轻的旧重量或老年人的年轻重量这样的简化

1160
00:53:13,720 --> 00:53:16,690
因为是的等等死伤等等

1161
00:53:16,690 --> 00:53:21,309
这是一个奇怪的命名法任何其他

1162
00:53:21,309 --> 00:53:28,059
问题所以这有点

1163
00:53:28,059 --> 00:53:30,880
在这些方案之前我所说的

1164
00:53:30,880 --> 00:53:31,990
保证不会出现死锁，因为你

1165
00:53:31,990 --> 00:53:35,529
基本上是在强制

1166
00:53:35,529 --> 00:53:37,599
执行在一个方向上分发的步行，或者锁

1167
00:53:37,599 --> 00:53:39,400
甚至可以在一个方向上被盗，

1168
00:53:39,400 --> 00:53:45,309
所以如果是的，我们已经讨论过

1169
00:53:45,309 --> 00:53:46,930
这个，所以当 交易

1170
00:53:46,930 --> 00:53:51,539
资源 我猜它的新优先级

1171
00:53:51,539 --> 00:53:58,440
是什么我猜它的时间戳是什么

1172
00:54:04,170 --> 00:54:07,029
它必须是原始的任何猜测

1173
00:54:07,029 --> 00:54:16,210
为什么如果你有一个事务你开始

1174
00:54:16,210 --> 00:54:17,740
然后它被另一个

1175
00:54:17,740 --> 00:54:19,839
事务杀死让我们说因为

1176
00:54:19,839 --> 00:54:22,000
它的优先级会增加旧的

1177
00:54:22,000 --> 00:54:24,190
是你想保持它的年龄是的，

1178
00:54:24,190 --> 00:54:26,019
当然，而不是仅仅重置年龄，

1179
00:54:26,019 --> 00:54:30,130
所以

1180
00:54:30,130 --> 00:54:32,950
在一个词中，饥饿是正确的，我们

1181
00:54:32,950 --> 00:54:34,960
不能让交易挨饿，所以

1182
00:54:34,960 --> 00:54:36,730
当你重新开始交易时，我们

1183
00:54:36,730 --> 00:54:37,599
要确保 它仍然使用

1184
00:54:37,599 --> 00:54:39,849
相同的时间戳，因此最终

1185
00:54:39,849 --> 00:54:41,920
使用哪个 Eve

1186
00:54:41,920 --> 00:54:43,779
防止死锁的顺序

1187
00:54:43,779 --> 00:54:45,339
我们要确保

1188
00:54:45,339 --> 00:54:48,839
在一个点上取得进展，另一个点，

1189
00:54:50,640 --> 00:54:57,100
所以我们有 10 分钟，这就是我们”

1190
00:54:57,100 --> 00:55:00,850
看看到目前为止我们能走多远这

1191
00:55:00,850 --> 00:55:02,410
似乎不是很有效，就像如果

1192
00:55:02,410 --> 00:55:03,490
我们有一个需要

1193
00:55:03,490 --> 00:55:06,130
更新十亿个元组的事务，我们会

1194
00:55:06,130 --> 00:55:07,660
像去锁管理器一样锁定管理器十亿次

1195
00:55:07,660 --> 00:55:09,310
这并不便宜，

1196
00:55:09,310 --> 00:55:11,350
你本学期没有实施，但你

1197
00:55:11,350 --> 00:55:12,550
可以想象如果你必须

1198
00:55:12,550 --> 00:55:14,410
在一个系统中实施它，你将需要

1199
00:55:14,410 --> 00:55:16,000
受锁存器保护的数据结构

1200
00:55:16,000 --> 00:55:19,330
它必须是并发的它在

1201
00:55:19,330 --> 00:55:20,740
每一个的关键路径上

1202
00:55:20,740 --> 00:55:23,860
事务正在执行，我们无法将所有

1203
00:55:23,860 --> 00:55:27,010
这些行程都转到锁管理器，因此

1204
00:55:27,010 --> 00:55:28,810
我们要做的是引入

1205
00:55:28,810 --> 00:55:30,970
某种层次结构或授予或

1206
00:55:30,970 --> 00:55:32,470
更改粒度或允许系统中

1207
00:55:32,470 --> 00:55:33,940
不同粒度的锁，

1208
00:55:33,940 --> 00:55:39,610
以便我们可以 应用锁 -

1209
00:55:39,610 --> 00:55:45,460
如果您知道

1210
00:55:45,460 --> 00:55:47,110
需要对单个表进行 10 亿次更新，则对表进行元组分页，

1211
00:55:47,110 --> 00:55:49,060
也许

1212
00:55:49,060 --> 00:55:50,860
只要求

1213
00:55:50,860 --> 00:55:52,930
在整个表上使用单个排他锁是有意义的，您将

1214
00:55:52,930 --> 00:55:54,010
阻止其他事务

1215
00:55:54,010 --> 00:55:56,140
访问它，但是 也许这就是你

1216
00:55:56,140 --> 00:55:58,600
想要做的目标是通过使用这个分层模型来减少

1217
00:55:58,600 --> 00:56:00,430
到锁管理器的总次数，

1218
00:56:00,430 --> 00:56:01,720


1219
00:56:01,720 --> 00:56:04,119
所以我们

1220
00:56:04,119 --> 00:56:06,520
将不得不引入更多的锁

1221
00:56:06,520 --> 00:56:08,920
类型，然后这个

1222
00:56:08,920 --> 00:56:12,910
层次结构的概念就像我所描述的那样在概念上

1223
00:56:12,910 --> 00:56:15,760
你现在可以

1224
00:56:15,760 --> 00:56:17,950
在系统的不同级别上锁，这样

1225
00:56:17,950 --> 00:56:19,740
数据库可以有多个表

1226
00:56:19,740 --> 00:56:21,760
不同的表可以有多个

1227
00:56:21,760 --> 00:56:23,200
元组，在不同的元组中你

1228
00:56:23,200 --> 00:56:24,490
可以有多个属性，所以你

1229
00:56:24,490 --> 00:56:26,020
想获得最少的数字 如果 T 1 获取表 1 上的锁，则

1230
00:56:26,020 --> 00:56:27,760
可以执行您需要执行的工作

1231
00:56:27,760 --> 00:56:34,230
的锁

1232
00:56:34,230 --> 00:56:37,930
如果它显式地获取

1233
00:56:37,930 --> 00:56:40,869
表 1 上的锁，它现在隐式锁定

1234
00:56:40,869 --> 00:56:43,630
这棵树中它下面的所有内容，

1235
00:56:43,630 --> 00:56:46,840
这棵树又是 一个稍微

1236
00:56:46,840 --> 00:56:48,760
抽象的概念概念 这

1237
00:56:48,760 --> 00:56:50,320
不像 B+ 树或类似的东西 它

1238
00:56:50,320 --> 00:56:52,869
只是在您插入

1239
00:56:52,869 --> 00:56:54,820
系统中的所有表和元组的数据库系统的层次结构中

1240
00:56:54,820 --> 00:56:57,250
它是系统

1241
00:56:57,250 --> 00:57:01,090
中的概念层次结构

1242
00:57:01,090 --> 00:57:03,359


1243
00:57:04,060 --> 00:57:06,560
所以安迪 试图获得

1244
00:57:06,560 --> 00:57:10,700
他阴暗的离岸银行账户的余额，同时他

1245
00:57:10,700 --> 00:57:12,530
给了我 1% 的利息，这

1246
00:57:12,530 --> 00:57:21,170
很酷，这在

1247
00:57:21,170 --> 00:57:23,119
这棵概念树中证明了我们拥有

1248
00:57:23,119 --> 00:57:25,040
什么 rt of locks 我们需要

1249
00:57:25,040 --> 00:57:26,450
拿吗 我们需要各种不同

1250
00:57:26,450 --> 00:57:29,090
类型的锁 我们需要排他锁

1251
00:57:29,090 --> 00:57:32,810
因为我的银行账户余额正在

1252
00:57:32,810 --> 00:57:35,869
改变 Andy 需要共享锁

1253
00:57:35,869 --> 00:57:38,600
然后

1254
00:57:38,600 --> 00:57:41,480
我认为这是一个意图锁的

1255
00:57:41,480 --> 00:57:43,640
概念 在下一张幻灯片中，您基本上会

1256
00:57:43,640 --> 00:57:45,530
在这棵树中给出提示，您基本上会

1257
00:57:45,530 --> 00:57:48,619
在更高级别上使用意图锁，以

1258
00:57:48,619 --> 00:57:49,970
向其他事务提供有关

1259
00:57:49,970 --> 00:57:51,170
您在系统较低级别所做的事情的提示，这些事务

1260
00:57:51,170 --> 00:57:53,240
将尝试增加

1261
00:57:53,240 --> 00:57:59,360
系统的并行度，就像我一样

1262
00:57:59,360 --> 00:58:02,510
说一个意图锁是一个暗示

1263
00:58:02,510 --> 00:58:04,640
其他事务，它会

1264
00:58:04,640 --> 00:58:06,140
通过一个例子变得更清楚，但是

1265
00:58:06,140 --> 00:58:07,760
基本的想法就像如果你

1266
00:58:07,760 --> 00:58:10,940
在这棵树中有一个意图共享锁，那么

1267
00:58:10,940 --> 00:58:13,130
以该节点为根的子树有一个显式

1268
00:58:13,130 --> 00:58:14,990
共享 锁定同一事物下的

1269
00:58:14,990 --> 00:58:17,750


1270
00:58:17,750 --> 00:58:19,550
某处，并在以该节点为根的子树中某处有意排他锁

1271
00:58:19,550 --> 00:58:21,650
，有一个

1272
00:58:21,650 --> 00:58:29,300
显式排他锁，我们将再添加

1273
00:58:29,300 --> 00:58:32,750
三个锁 类型意图共享

1274
00:58:32,750 --> 00:58:35,900
，就像我在

1275
00:58:35,900 --> 00:58:37,580
以该节点为根的子树中的某处所描述的那样有

1276
00:58:37,580 --> 00:58:39,560
一个显式共享锁

1277
00:58:39,560 --> 00:58:41,630
意图独占在该

1278
00:58:41,630 --> 00:58:43,460
子树中的某处有一个显式排他

1279
00:58:43,460 --> 00:58:46,220
锁然后有一种棘手

1280
00:58:46,220 --> 00:58:49,100
的共享意图独占这是

1281
00:58:49,100 --> 00:58:52,400
一个显式共享 锁定这个节点

1282
00:58:52,400 --> 00:58:55,280
，这意味着你

1283
00:58:55,280 --> 00:58:57,080
在它的子树和该子树中的某个地方共享了它下面的所有内容的锁

1284
00:58:57,080 --> 00:58:59,960
，你也

1285
00:58:59,960 --> 00:59:03,590
有一个显式的排他锁，所以你

1286
00:59:03,590 --> 00:59:05,600
可以想象如果你想

1287
00:59:05,600 --> 00:59:08,869
对整个表进行读取然后可能更新

1288
00:59:08,869 --> 00:59:10,430
一个值，您将

1289
00:59:10,430 --> 00:59:12,140
在该表上获得一个共享意图，

1290
00:59:12,140 --> 00:59:13,520
因为您将

1291
00:59:13,520 --> 00:59:15,560
在整个表上使用共享锁，并说我正在读取

1292
00:59:15,560 --> 00:59:17,119
此元组或此磁带的所有值，

1293
00:59:17,119 --> 00:59:17,600


1294
00:59:17,600 --> 00:59:19,520
但我只会更新一个值 所以

1295
00:59:19,520 --> 00:59:22,070
你在一个元组上有一个排他锁，

1296
00:59:22,070 --> 00:59:24,350


1297
00:59:24,350 --> 00:59:26,030
我认为用一个实际的例子会更有意义，但有

1298
00:59:26,030 --> 00:59:31,130
没有任何问题，第一个例子是我们的

1299
00:59:31,130 --> 00:59:33,020
兼容性矩阵 变得有点

1300
00:59:33,020 --> 00:59:38,180
复杂，

1301
00:59:38,180 --> 00:59:40,040
除了我认为

1302
00:59:40,040 --> 00:59:41,510
实际看到示例的树更清楚一点之外，对此没什么可说的，

1303
00:59:41,510 --> 00:59:43,820
但基本上

1304
00:59:43,820 --> 00:59:45,620
语义类似于共享

1305
00:59:45,620 --> 00:59:51,290
专有步行兼容性，只需

1306
00:59:51,290 --> 00:59:56,000
将其应用于树即可 LOC 协议

1307
00:59:56,000 --> 00:59:57,710
基本上只是说为了获得

1308
00:59:57,710 --> 01:00:01,220
共享锁，您必须至少

1309
01:00:01,220 --> 01:00:03,710
在父节点中暗示您

1310
01:00:03,710 --> 01:00:06,410
有意图共享锁与exclusive 相同的事情

1311
01:00:06,410 --> 01:00:08,900
以获得独占意图

1312
01:00:08,900 --> 01:00:11,300
独占共享意图独占您

1313
01:00:11,300 --> 01:00:13,340
必须持有意图独占

1314
01:00:13,340 --> 01:00:16,640
再次在父节点上让我们做一个

1315
01:00:16,640 --> 01:00:17,600
例子 因为我认为这

1316
01:00:17,600 --> 01:00:19,190
会让事情变得更清晰 我们有

1317
01:00:19,190 --> 01:00:24,470
五分钟非常简单的表或一个非常

1318
01:00:24,470 --> 01:00:25,910
简单的例子 两层 有一个

1319
01:00:25,910 --> 01:00:31,040
表 有一堆我们想要检查的元组

1320
01:00:31,040 --> 01:00:33,800
andis bank 帐户他

1321
01:00:33,800 --> 01:00:36,970
想读取元组一所以他希望

1322
01:00:36,970 --> 01:00:39,680
他只想要这个元组的共享

1323
01:00:39,680 --> 01:00:41,660
锁来进行读取，但我们将

1324
01:00:41,660 --> 01:00:43,940
不得不采取共享的意图 t

1325
01:00:43,940 --> 01:00:45,680
父节点首先基本上是作为一个提示，

1326
01:00:45,680 --> 01:00:48,500
在这个节点下面说嘿我将

1327
01:00:48,500 --> 01:00:55,270
采取显式共享锁 t2 出现

1328
01:00:55,270 --> 01:00:58,430
我们想要将我的银行余额更新

1329
01:00:58,430 --> 01:01:03,880
百分之一所以我们希望

1330
01:01:03,880 --> 01:01:08,660
在这个元组上显式排他锁所以我们 重新尝试

1331
01:01:08,660 --> 01:01:15,920
得到是的，我们在父节点上获得了我们的意图排他

1332
01:01:15,920 --> 01:01:17,960
锁，我们

1333
01:01:17,960 --> 01:01:20,240
在单个元组上获得了排他锁，

1334
01:01:20,240 --> 01:01:24,260
现在事情会变

1335
01:01:24,260 --> 01:01:25,820
得更有趣一些我认为 t1 基本上是

1336
01:01:25,820 --> 01:01:27,950
在执行我之前描述的

1337
01:01:27,950 --> 01:01:29,000
场景 将进行大量

1338
01:01:29,000 --> 01:01:29,840
读取，然后您将更新

1339
01:01:29,840 --> 01:01:31,400
一个元组

1340
01:01:31,400 --> 01:01:32,960
t-too 也将读取单个元组 t3

1341
01:01:32,960 --> 01:01:35,779
将扫描所有这些元组 我很

1342
01:01:35,779 --> 01:01:37,700
抱歉我的速度有点快 我意识到

1343
01:01:37,700 --> 01:01:41,119
这可能有点 令人困惑，但我们有

1344
01:01:41,119 --> 01:01:46,520
很长的时间，所以 t1 就像我说的它

1345
01:01:46,520 --> 01:01:47,869
想读取所有元组并对一个元组进行

1346
01:01:47,869 --> 01:01:49,819
更新，因此它会获得共享

1347
01:01:49,819 --> 01:01:52,130
意图排他这意味着我

1348
01:01:52,130 --> 01:01:54,859
在整个表上使用共享锁

1349
01:01:54,859 --> 01:01:57,500
所以我 可以读取它们

1350
01:01:57,500 --> 01:01:59,599
在所有 t 中的所有属性 这个表中的元组和

1351
01:01:59,599 --> 01:02:01,940
意图独占部分意味着我将

1352
01:02:01,940 --> 01:02:04,099
至少更新这些元组中的一个

1353
01:02:04,099 --> 01:02:09,920
在这种情况下它是元组 n 所以

1354
01:02:09,920 --> 01:02:11,809
因为这是共享意图

1355
01:02:11,809 --> 01:02:13,549
独占所有这些元组都

1356
01:02:13,549 --> 01:02:15,799
隐式锁定在共享模式

1357
01:02:15,799 --> 01:02:17,539
然后这是 我们实际上

1358
01:02:17,539 --> 01:02:19,279
唯一需要显式排他锁

1359
01:02:19,279 --> 01:02:20,450
，因为这是唯一一个被

1360
01:02:20,450 --> 01:02:24,200
更新的 t2 想要读取单个元组，

1361
01:02:24,200 --> 01:02:26,990
我们将需要这个人的共享共享

1362
01:02:26,990 --> 01:02:28,220
锁，这意味着我们需要

1363
01:02:28,220 --> 01:02:34,339
在这个级别共享意图，仅此而已

1364
01:02:34,339 --> 01:02:36,770
很好，我们可以做到最后

1365
01:02:36,770 --> 01:02:38,119
一个事务是会出现

1366
01:02:38,119 --> 01:02:41,480
问题的事务它想要读取所有

1367
01:02:41,480 --> 01:02:45,380
这些它会想要共享排他

1368
01:02:45,380 --> 01:02:47,750
共享法对不起

1369
01:02:47,750 --> 01:02:49,180
，表上的显式共享锁

1370
01:02:49,180 --> 01:02:51,109
无法获得，因为它不会进行

1371
01:02:51,109 --> 01:02:53,420
为了与共享意图独占兼容，

1372
01:02:53,420 --> 01:02:54,829
因为

1373
01:02:54,829 --> 01:02:58,670
在表 t3 的下层发生了写操作

1374
01:02:58,670 --> 01:03:01,750
必须等待所以基本上它希望

1375
01:03:01,750 --> 01:03:05,029
表上的这个显式共享锁不能

1376
01:03:05,029 --> 01:03:05,510
有那个

1377
01:03:05,510 --> 01:03:29,569
al 我能做的就是等待，所以我可能走得

1378
01:03:29,569 --> 01:03:32,180
太快了示例操作

1379
01:03:32,180 --> 01:03:33,650
发生了变化，当我通过三个事务到达这个时，这

1380
01:03:33,650 --> 01:03:35,119
不再

1381
01:03:35,119 --> 01:03:37,460
像阅读 Andy's Bakic 那样使

1382
01:03:37,460 --> 01:03:39,890
我的帐户余额增加 1% tyonne

1383
01:03:39,890 --> 01:03:42,079
阅读所有元组 然后

1384
01:03:42,079 --> 01:03:44,600
修改一个 t2

1385
01:03:44,600 --> 01:03:47,180
只是读取

1386
01:03:47,180 --> 01:03:49,460
一个，然后 t3 是试图

1387
01:03:49,460 --> 01:03:51,650
读取整个表格的那个，所以是的，这是一个

1388
01:03:51,650 --> 01:03:53,000
不同的例子，如果我走得很快，我很抱歉，

1389
01:03:53,000 --> 01:04:07,540
所以在实践

1390
01:04:07,540 --> 01:04:09,500
中似乎 复杂，但实际上

1391
01:04:09,500 --> 01:04:10,760
非常有用，因为您可以减少

1392
01:04:10,760 --> 01:04:12,200
锁的数量或

1393
01:04:12,200 --> 01:04:13,580
前往锁管理器

1394
01:04:13,580 --> 01:04:15,260
的次数，您可以显着减少锁请求的数量

1395
01:04:15,260 --> 01:04:19,910
，就像我们

1396
01:04:19,910 --> 01:04:21,770
之前提到的

1397
01:04:21,770 --> 01:04:23,840
那样，如果您已经有了锁升级的概念 锁

1398
01:04:23,840 --> 01:04:25,340
和共享模式你想把它们

1399
01:04:25,340 --> 01:04:26,510
撞到排他锁因为你已经决定

1400
01:04:26,510 --> 01:04:28,010
要在元组上正确地做你

1401
01:04:28,010 --> 01:04:30,410
可以再次这样做这是

1402
01:04:30,410 --> 01:04:31,940
旨在减少旅行

1403
01:04:31,940 --> 01:04:33,410
次数 他是锁管理器，也不会

1404
01:04:33,410 --> 01:04:34,640
违反两阶段锁定，因为您

1405
01:04:34,640 --> 01:04:35,780
可以升级您的锁，但实际上并不会

1406
01:04:35,780 --> 01:04:42,170
释放锁，因此

1407
01:04:42,170 --> 01:04:44,180
在实际系统中，您不会坐在

1408
01:04:44,180 --> 01:04:46,330
那里告诉它要锁定哪些元组，

1409
01:04:46,330 --> 01:04:48,800
您可以给出提示 就像我说的，如果你

1410
01:04:48,800 --> 01:04:50,020
知道你要

1411
01:04:50,020 --> 01:04:53,780
在一个表上做一堆操作，并且你

1412
01:04:53,780 --> 01:04:55,130
想一直持有锁，

1413
01:04:55,130 --> 01:04:56,870
你就不能明确地锁定表，

1414
01:04:56,870 --> 01:04:59,540
所以它不是续集标准的一部分，

1415
01:04:59,540 --> 01:05:01,250
但这里是 关于如何

1416
01:05:01,250 --> 01:05:03,440
在 Postgres Oracle db2 sequel 之类的例子中做到这一点 我的

1417
01:05:03,440 --> 01:05:08,180
续集 这些人都

1418
01:05:08,180 --> 01:05:09,620
使用我们现在正在学习的命名法，

1419
01:05:09,620 --> 01:05:11,300
这是共享和独占的，

1420
01:05:11,300 --> 01:05:12,710
因为我的续集喜欢与众不同，

1421
01:05:12,710 --> 01:05:14,540
他们称它们为 read 和 write blocks

1422
01:05:14,540 --> 01:05:17,890
因为他们想要 不同

1423
01:05:17,890 --> 01:05:20,210
的是，还有这个选择

1424
01:05:20,210 --> 01:05:21,440
更新的概念，所以如果你正在阅读一个

1425
01:05:21,440 --> 01:05:22,700
你最终想要更新的元组，

1426
01:05:22,700 --> 01:05:24,020
你可以给数据库

1427
01:05:24,020 --> 01:05:25,700
系统一个提示，说看起来我知道，因为

1428
01:05:25,700 --> 01:05:27,140
你正在阅读你 会要求

1429
01:05:27,140 --> 01:05:29,870
一个共享锁我稍后会写

1430
01:05:29,870 --> 01:05:32,720
，现在就拿独占锁并

1431
01:05:32,720 --> 01:05:34,760
为我持有它，这样你就可以

1432
01:05:34,760 --> 01:05:38,840
选择并添加这个以进行更新，

1433
01:05:38,840 --> 01:05:41,630
基本上告诉系统

1434
01:05:41,630 --> 01:05:43,250
采取正确的锁或请原谅我采取

1435
01:05:43,250 --> 01:05:46,100
现在的排他锁，您

1436
01:05:46,100 --> 01:05:47,990
也可以告诉它只是获取

1437
01:05:47,990 --> 01:05:49,400


1438
01:05:49,400 --> 01:05:50,870


1439
01:05:50,870 --> 01:05:52,220


1440
01:05:52,220 --> 01:05:54,490


1441
01:05:55,890 --> 01:05:59,800
共享锁 就像幻灯片上说的，

1442
01:05:59,800 --> 01:06:02,290
它在几乎所有系统中都使用了

1443
01:06:02,290 --> 01:06:04,120
至少大多数转换最

1444
01:06:04,120 --> 01:06:05,590
广泛部署到商业系统

1445
01:06:05,590 --> 01:06:08,950
续集服务器我的续集 Postgres 到

1446
01:06:08,950 --> 01:06:11,740
锁相很重要，但它

1447
01:06:11,740 --> 01:06:14,230
也不太难实现，

1448
01:06:14,230 --> 01:06:15,460
它为我们提供了我们所需要的 want 为

1449
01:06:15,460 --> 01:06:18,460
我们提供了可序列化的时间表，我们只

1450
01:06:18,460 --> 01:06:20,650
需要遵守纪律，即

1451
01:06:20,650 --> 01:06:22,120
我们是要尝试检测我们的死锁

1452
01:06:22,120 --> 01:06:23,500
并处理它们，还是要

1453
01:06:23,500 --> 01:06:27,120
在下一堂课中首先尝试完全防止它们

1454
01:06:27,120 --> 01:06:29,860
我认为这将是 Dana

1455
01:06:29,860 --> 01:06:31,570
和你们谈论时间戳

1456
01:06:31,570 --> 01:06:35,730
订购这很好

1457
01:06:46,079 --> 01:06:48,479
他在我的系统中的wixi晚上崩溃

1458
01:06:48,479 --> 01:06:49,349
了我很幸运

1459
01:06:49,349 --> 01:06:50,880
让我们去拿下一个然后

1460
01:06:50,880 --> 01:06:57,450
现在穿上沙发好永远不会是儿子

1461
01:06:57,450 --> 01:06:59,609
跳弹果冻

1462
01:06:59,609 --> 01:07:01,710
自然而然地去熟食店坐船 祝福你 说唱歌手

1463
01:07:01,710 --> 01:07:03,479
喜欢激光束 灌木丛中的球

1464
01:07:03,479 --> 01:07:06,210
Sena ka-ching 包裹着我们的瓶子 一个

1465
01:07:06,210 --> 01:07:08,190
很好的同情

1466
01:07:08,190 --> 01:07:10,170


1467
01:07:10,170 --> 01:07:12,779
你

1468
01:07:12,779 --> 01:07:16,009
忘了煎饼

