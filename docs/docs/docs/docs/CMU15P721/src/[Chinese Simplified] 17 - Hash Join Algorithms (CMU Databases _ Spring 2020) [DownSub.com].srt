1
00:00:01,300 --> 00:00:05,129
[音乐]

2
00:00:05,200 --> 00:00:05,930
[掌声]

3
00:00:05,930 --> 00:00:08,630
[音乐]

4
00:00:08,630 --> 00:00:10,020
[掌声]

5
00:00:10,020 --> 00:00:11,269
[音乐]

6
00:00:11,269 --> 00:00:13,349
今天我们将再次讨论哈希

7
00:00:13,349 --> 00:00:15,210
连接我只是在这里我的家庭办公室

8
00:00:15,210 --> 00:00:18,660
它是我在这里与梗犬

9
00:00:18,660 --> 00:00:21,359
出席所以它会问问题

10
00:00:21,359 --> 00:00:26,279
正如我们今天所做的那样，为什么散列

11
00:00:26,279 --> 00:00:28,199
币很重要，它的加入

12
00:00:28,199 --> 00:00:29,460
通常很重要，因为这是

13
00:00:29,460 --> 00:00:30,929


14
00:00:30,929 --> 00:00:34,860
在分析工作负载中执行操作的常见事物之一，所以

15
00:00:34,860 --> 00:00:36,420
今天我们将开始讨论

16
00:00:36,420 --> 00:00:38,309
它意味着什么的背景

17
00:00:38,309 --> 00:00:39,329
做一个联合算法

18
00:00:39,329 --> 00:00:41,040
我有一个高级别的

19
00:00:41,040 --> 00:00:42,780
历史，在

20
00:00:42,780 --> 00:00:45,450
散列

21
00:00:45,450 --> 00:00:47,250
联合与我们将讨论的排序合并连接的性能权衡之间来回的历史中，

22
00:00:47,250 --> 00:00:48,120
有一个并行的

23
00:00:48,120 --> 00:00:50,579
房子连接和 以不同的方式来

24
00:00:50,579 --> 00:00:52,829
完成三个阶段 然后我们讨论

25
00:00:52,829 --> 00:00:54,059
了你是如何构建一个哈希表

26
00:00:54,059 --> 00:00:55,530
哈希方案 哈希函数

27
00:00:55,530 --> 00:00:57,180
然后我们将讨论

28
00:00:57,180 --> 00:00:59,520
基于

29
00:00:59,520 --> 00:01:00,750
一些结果的评估 你们

30
00:01:00,750 --> 00:01:06,060
分配的论文 对我来说，所以在

31
00:01:06,060 --> 00:01:08,220
上学期的介绍课上，当我们

32
00:01:08,220 --> 00:01:10,110
谈论联合专辑时，我们并没有

33
00:01:10,110 --> 00:01:12,180
真正谈论如何

34
00:01:12,180 --> 00:01:15,119
在多线程

35
00:01:15,119 --> 00:01:18,150
并行的情况下设置执行它们，我们主要专注于尝试

36
00:01:18,150 --> 00:01:21,450
评估您知道多少磁盘 IO 我们本来

37
00:01:21,450 --> 00:01:22,799
打算使用不同的

38
00:01:22,799 --> 00:01:24,810
算法，但现在在内存

39
00:01:24,810 --> 00:01:26,430
系统中我们没有磁盘，现在我们

40
00:01:26,430 --> 00:01:28,729
想要最大化

41
00:01:28,729 --> 00:01:31,049
我们在 CPU 上的课程可以得到的并行化量

42
00:01:31,049 --> 00:01:33,060
，现在我们需要

43
00:01:33,060 --> 00:01:34,500
专注于 我们实际上将如何

44
00:01:34,500 --> 00:01:37,009
有效地使用我们的硬件来进行联合

45
00:01:37,009 --> 00:01:39,150
所以并行联合只是将两个

46
00:01:39,150 --> 00:01:41,400
表 我们想要

47
00:01:41,400 --> 00:01:42,840
连接在一起的两个关系 但我们要

48
00:01:42,840 --> 00:01:44,220
跨多个线程进行这个联合 我将

49
00:01:44,220 --> 00:01:45,540
尽量减少 尽可能多的

50
00:01:45,540 --> 00:01:47,280
争用和同步，

51
00:01:47,280 --> 00:01:49,170
以便我们获得最佳

52
00:01:49,170 --> 00:01:51,450
性能，因此

53
00:01:51,450 --> 00:01:53,159
我们将在

54
00:01:53,159 --> 00:01:54,810
OLAP 系统中进行视图连接的两种主要方法将是

55
00:01:54,810 --> 00:01:57,329
散列或服务器或排序

56
00:01:57,329 --> 00:01:58,799
，没有其他方法 一种神奇的方法，

57
00:01:58,799 --> 00:02:01,259
可以确定何时

58
00:02:01,259 --> 00:02:03,000
有匹配的元组，它是

59
00:02:03,000 --> 00:02:05,130
一个或另一个，因此对于本课程，这

60
00:02:05,130 --> 00:02:06,329
也意味着我们不打算

61
00:02:06,329 --> 00:02:09,508
讨论国家循环连接，因为

62
00:02:09,508 --> 00:02:12,840
这就像 OLAP 中最糟糕的

63
00:02:12,840 --> 00:02:14,459
情况 系统，因为它只是

64
00:02:14,459 --> 00:02:16,290


65
00:02:16,290 --> 00:02:17,940
在表上进行 scruncho 扫描的蛮力搜索以尝试找到

66
00:02:17,940 --> 00:02:18,810
匹配的元组，

67
00:02:18,810 --> 00:02:21,480
因此在 OLAP 系统中，您不会看到

68
00:02:21,480 --> 00:02:23,730
嵌套循环连接，除非

69
00:02:23,730 --> 00:02:25,610
在表超小的一些罕见情况下

70
00:02:25,610 --> 00:02:27,959
，等等 因为它们也是你

71
00:02:27,959 --> 00:02:31,890
知道并行运行它们的

72
00:02:31,890 --> 00:02:32,910
方式与你并行运行

73
00:02:32,910 --> 00:02:35,400
扫描的方式相同所以

74
00:02:35,400 --> 00:02:37,680
我们在这里谈论的不多，

75
00:02:37,680 --> 00:02:39,629
我还要说的另一件事 - 尽管在 OTP

76
00:02:39,629 --> 00:02:42,780
系统中你会看到 最初加入

77
00:02:42,780 --> 00:02:44,959
是因为很棒的谈话通常

78
00:02:44,959 --> 00:02:46,769
这些专为事务处理工作负载设计的数据库系统

79
00:02:46,769 --> 00:02:49,019


80
00:02:49,019 --> 00:02:50,459
不需要进行哈希联接，甚至

81
00:02:50,459 --> 00:02:52,530
不需要进行排序合并联接，因为它们

82
00:02:52,530 --> 00:02:55,079
之间没有进行大的联接 不同的

83
00:02:55,079 --> 00:02:57,390
表，它总是在进行外键

84
00:02:57,390 --> 00:02:59,400
查找或小数键查找

85
00:02:59,400 --> 00:03:01,739
以获取数据，然后将这些数据提供

86
00:03:01,739 --> 00:03:03,180
给应用程序或渲染网页，

87
00:03:03,180 --> 00:03:05,099
让我们在

88
00:03:05,099 --> 00:03:07,709
登录时像亚马逊一样考虑可能存在嵌套循环连接

89
00:03:07,709 --> 00:03:10,049
以供获取 Amy 的帐户并获取所有

90
00:03:10,049 --> 00:03:12,180
andis 订单，因此将有一个

91
00:03:12,180 --> 00:03:14,970
从订单

92
00:03:14,970 --> 00:03:18,480
客户 ID 到客户表的外键引用

93
00:03:18,480 --> 00:03:20,130
，然后这种情况只是一个索引

94
00:03:20,130 --> 00:03:21,630
嵌套循环联合，这将是

95
00:03:21,630 --> 00:03:23,010
比您更高效的超级时尚

96
00:03:23,010 --> 00:03:24,690
方式 散列绘图，因为您

97
00:03:24,690 --> 00:03:26,280
不需要构建散列表来

98
00:03:26,280 --> 00:03:28,380
进行连接，您只需使用现有

99
00:03:28,380 --> 00:03:31,470
索引，因此，

100
00:03:31,470 --> 00:03:33,959
此循环中的索引在高级别

101
00:03:33,959 --> 00:03:38,250
连接看起来很像散列连接 只是

102
00:03:38,250 --> 00:03:40,739
您用来

103
00:03:40,739 --> 00:03:42,540
查找匹配元组的数据结构已经存在，

104
00:03:42,540 --> 00:03:44,760
因为 OGB 应用程序已经

105
00:03:44,760 --> 00:03:47,069
定义了您要对其进行

106
00:03:47,069 --> 00:03:49,980
连接的索引 我再说一遍，这里的高级

107
00:03:49,980 --> 00:03:51,630
差异是哈希连接

108
00:03:51,630 --> 00:03:54,630
b  uilds 数据结构，如索引

109
00:03:54,630 --> 00:03:55,919
，允许您找到匹配的

110
00:03:55,919 --> 00:03:59,069
元组，但是当该查询完成时，它

111
00:03:59,069 --> 00:04:00,810
会丢弃哈希表，并且出现一个 x

112
00:04:00,810 --> 00:04:02,489
平方，并且真正

113
00:04:02,489 --> 00:04:05,099
关于哈希表再次出现在索引

114
00:04:05,099 --> 00:04:07,139
mmm 中作为循环加入索引 已经

115
00:04:07,139 --> 00:04:08,579
存在，因此您无需即时构建它，

116
00:04:08,579 --> 00:04:10,440
您只需使用它来

117
00:04:10,440 --> 00:04:12,870
查找元组的匹配项，但一个

118
00:04:12,870 --> 00:04:15,030
很大的区别是，在海洋设置中，

119
00:04:15,030 --> 00:04:18,298
该索引很可能是基于

120
00:04:18,298 --> 00:04:20,250
树的数据结构，因此 要么是

121
00:04:20,250 --> 00:04:21,779
我们之前讨论过的加号树或基数树

122
00:04:21,779 --> 00:04:24,570
，这意味着

123
00:04:24,570 --> 00:04:25,490


124
00:04:25,490 --> 00:04:27,949
您在进行连接时将获得登录 Gups 但对于

125
00:04:27,949 --> 00:04:29,690
使用斧头的哈希连接，我们

126
00:04:29,690 --> 00:04:32,300
平均会给您一次查找

127
00:04:32,300 --> 00:04:34,910
更快，所以这就是为什么没有人

128
00:04:34,910 --> 00:04:37,340
在您进行连接时建立 B+ 交易的原因，

129
00:04:37,340 --> 00:04:39,410
除了一些罕见的例外，当您这样做时，

130
00:04:39,410 --> 00:04:41,120
就像您知道范围范围谓词和

131
00:04:41,120 --> 00:04:42,080
诸如此类的事情一样，但我们

132
00:04:42,080 --> 00:04:43,569
专注于等连接，

133
00:04:43,569 --> 00:04:46,610
所以也许 我们将使用哈希

134
00:04:46,610 --> 00:04:47,569
表 bec 这样做会更有

135
00:04:47,569 --> 00:04:52,789
效率，所以关于排序

136
00:04:52,789 --> 00:04:55,539
合并连接是否比散列连接更快的争论是

137
00:04:55,539 --> 00:04:59,180


138
00:04:59,180 --> 00:05:01,550
数据库中的经典问题之一，在过去的 50 年里，

139
00:05:01,550 --> 00:05:03,319
它反复讨论哪种

140
00:05:03,319 --> 00:05:05,569
方法实际上更好，所以在

141
00:05:05,569 --> 00:05:08,150
1970 年代的传统观点是

142
00:05:08,150 --> 00:05:11,330
排序与高级连接，因为

143
00:05:11,330 --> 00:05:12,770
当时

144
00:05:12,770 --> 00:05:14,659
这些早期早期计算机早期

145
00:05:14,659 --> 00:05:16,729
系统可用的内存量非常有限，

146
00:05:16,729 --> 00:05:20,000
而且它们有执行外部

147
00:05:20,000 --> 00:05:21,740
合并排序的算法，因此您可以溢出磁盘

148
00:05:21,740 --> 00:05:24,440
并且仍然 对数据进行排序，所以我

149
00:05:24,440 --> 00:05:26,300
不清楚他们是否知道他们可以做

150
00:05:26,300 --> 00:05:28,880
一个可能会洒出桌子的哈希联合

151
00:05:28,880 --> 00:05:30,889
，但传统观点认为

152
00:05:30,889 --> 00:05:32,539
加入 MERS 的排序更好，因为他们

153
00:05:32,539 --> 00:05:34,070
已经有了 1980 年代出现的外部更短的

154
00:05:34,070 --> 00:05:37,460
算法，并且

155
00:05:37,460 --> 00:05:40,370
然后有一种叫做

156
00:05:40,370 --> 00:05:41,990
数据库机器的运动，他们

157
00:05:41,990 --> 00:05:43,699
发现

158
00:05:43,699 --> 00:05:46,940
如果你有专门的

159
00:05:46,940 --> 00:05:49,130
硬件支持，哈希双胞胎可能会更好 做散列和

160
00:05:49,130 --> 00:05:52,039
做散列连接，所以在 1980 年代，

161
00:05:52,039 --> 00:05:53,599
潜在的智慧是散列

162
00:05:53,599 --> 00:05:56,530
模式是优越的，因为他们有

163
00:05:56,530 --> 00:05:58,520
因为他们有硬件可以

164
00:05:58,520 --> 00:05:59,539
比你做排序更有效，

165
00:05:59,539 --> 00:06:03,110
所以我们并没有真正谈论

166
00:06:03,110 --> 00:06:05,000
戴维森 机器了，我

167
00:06:05,000 --> 00:06:06,680
认为这就像一个定制的

168
00:06:06,680 --> 00:06:09,080
设备，具有

169
00:06:09,080 --> 00:06:11,300
专门针对特定数据库系统的特殊说明或特殊硬件，

170
00:06:11,300 --> 00:06:14,389
它们

171
00:06:14,389 --> 00:06:17,569
在 1980 年代有点过时了，因为

172
00:06:17,569 --> 00:06:19,520
英特尔和所有其他芯片

173
00:06:19,520 --> 00:06:20,780
制造商都在推出新

174
00:06:20,780 --> 00:06:24,259
东西 一直在使用新的 CPU，甚至

175
00:06:24,259 --> 00:06:25,940
用摩尔定律投票，事情变得

176
00:06:25,940 --> 00:06:27,110
越来越快，因为你有更多的

177
00:06:27,110 --> 00:06:29,300
晶体管，所以如果你是一家

178
00:06:29,300 --> 00:06:30,919
数据库公司，你用专门的硬件

179
00:06:30,919 --> 00:06:33,319
制造或设计和制造

180
00:06:33,319 --> 00:06:34,940
数据库机器所花费的时间

181
00:06:34,940 --> 00:06:36,860
，然后 实际上将其投入

182
00:06:36,860 --> 00:06:38,660
生产并开始销售

183
00:06:38,660 --> 00:06:40,550
英特尔或任何已经推出新

184
00:06:40,550 --> 00:06:43,880
CPU 的人，这些 CPU 否定

185
00:06:43,880 --> 00:06:45,380
了您的任何性能提升 在你的定制

186
00:06:45,380 --> 00:06:47,270
硬件中，你真的再也看不到这个

187
00:06:47,270 --> 00:06:49,700
了，这有点像哈佛

188
00:06:49,700 --> 00:06:52,850
专业的那样重新流行起来，

189
00:06:52,850 --> 00:06:54,290
就像他们没有数据机器一样，

190
00:06:54,290 --> 00:06:57,890
而是更像是 FPGA、GPU 和其他

191
00:06:57,890 --> 00:06:59,420
类型的硬件加速器，它

192
00:06:59,420 --> 00:07:01,970
仍然存在 商品基础，但你可以

193
00:07:01,970 --> 00:07:03,500
为它们设计自定义内核，

194
00:07:03,500 --> 00:07:07,850
然后在 1990 年代有这篇

195
00:07:07,850 --> 00:07:09,890
论文来自 gertz graphi 同一

196
00:07:09,890 --> 00:07:11,570
个人做了火山 同一个人做

197
00:07:11,570 --> 00:07:13,280
了 BP 加树的东西我们

198
00:07:13,280 --> 00:07:16,340
之前谈到了闩锁他出来的 一篇

199
00:07:16,340 --> 00:07:19,910
论文说这些算法

200
00:07:19,910 --> 00:07:21,800
基本上是等效的，对于当时存在的所有

201
00:07:21,800 --> 00:07:24,380
不同的真实世界场景，

202
00:07:24,380 --> 00:07:26,510
你

203
00:07:26,510 --> 00:07:29,570
不会真正看到短版本散列

204
00:07:29,570 --> 00:07:31,540
之间的明显性能差异，

205
00:07:31,540 --> 00:07:34,580
因此它们与 Dean

206
00:07:34,580 --> 00:07:39,740
等效，但在 2000 年代 随着

207
00:07:39,740 --> 00:07:42,710
越来越多的分析

208
00:07:42,710 --> 00:07:45,170
数据库被创建，比如 Vertica

209
00:07:45,170 --> 00:07:47,270
greenplum aster 数据，诸如此类的事情

210
00:07:47,270 --> 00:07:48,710
被证明考虑了哈希连接

211
00:07:48,710 --> 00:07:52,700
为了在当时可用的恐怖

212
00:07:52,700 --> 00:07:53,980
方面表现出色，而且

213
00:07:53,980 --> 00:07:56,840
从那时起，

214
00:07:56,840 --> 00:07:59,720
2010 年代的情况就是

215
00:07:59,720 --> 00:08:00,860
如此 如果辩论是您是否想要，那么关于某些

216
00:08:00,860 --> 00:08:02,480
突发连接是否比散列连接更好

217
00:08:02,480 --> 00:08:04,070
做一个

218
00:08:04,070 --> 00:08:05,990
分区散列连接或非分区

219
00:08:05,990 --> 00:08:07,760
散列连接，这就是我们

220
00:08:07,760 --> 00:08:10,850
今天和当前十年

221
00:08:10,850 --> 00:08:15,200
再次讨论的内容，除非有一些，除非

222
00:08:15,200 --> 00:08:16,970
硬件上有一些重大突破

223
00:08:16,970 --> 00:08:19,490
我不认为某个版本

224
00:08:19,490 --> 00:08:20,990
会出现 再一次，我认为

225
00:08:20,990 --> 00:08:23,810
散列在许多情况下已经被证明是

226
00:08:23,810 --> 00:08:27,080
优越的，现在很明显，如果

227
00:08:27,080 --> 00:08:28,910
您的数据已经在连接键上排序，

228
00:08:28,910 --> 00:08:31,730
那么您根本不需要进行

229
00:08:31,730 --> 00:08:33,020
排序，只需进行合并阶段，

230
00:08:33,020 --> 00:08:35,179
然后您就知道了 这是最好的

231
00:08:35,179 --> 00:08:36,650
情况，这肯定会

232
00:08:36,650 --> 00:08:40,960
是 beta 哈希联合算法，但

233
00:08:40,960 --> 00:08:43,309
数据库通常不会一直保持

234
00:08:43,309 --> 00:08:47,990
排序，所以现在让

235
00:08:47,990 --> 00:08:49,610
我们谈谈过去十年的情况

236
00:08:49,610 --> 00:08:51,140
，我们是如何得到的 关于

237
00:08:51,140 --> 00:08:52,340
我们今天的位置以及我为什么

238
00:08:52,340 --> 00:08:53,630


239
00:08:53,630 --> 00:08:56,090
在 2000 年和世纪之交的 2000 年代初再次签署你们正在阅读的论文

240
00:08:56,090 --> 00:08:59,120
，人们

241
00:08:59,120 --> 00:09:00,770
认为该研究表明哈希连接

242
00:09:00,770 --> 00:09:04,220
是优越的，因此是本文中的关键

243
00:09:04,220 --> 00:09:05,990
论文之一 2009 年甲骨文从英特尔出来时

244
00:09:05,990 --> 00:09:09,140
，他们表明

245
00:09:09,140 --> 00:09:10,550
散列确实比剑合并优越，

246
00:09:10,550 --> 00:09:15,230
但他们推测如果

247
00:09:15,230 --> 00:09:17,840
我们现在有更大的 Cindy 寄存器，

248
00:09:17,840 --> 00:09:20,150
特别是 512 位 Cindy 寄存器，如

249
00:09:20,150 --> 00:09:24,080
英特尔的 avx-512 那么排序 MERS join

250
00:09:24,080 --> 00:09:26,750
实际上会 据

251
00:09:26,750 --> 00:09:29,210
他们所知，现在要更快 我

252
00:09:29,210 --> 00:09:31,880
自 2017 年 tx5 咒语

253
00:09:31,880 --> 00:09:36,460
问世以来没有一篇论文实际测试过这个理论，

254
00:09:36,460 --> 00:09:38,450
但古代你可以看看

255
00:09:38,450 --> 00:09:39,590
那是否真的是你知道这是

256
00:09:39,590 --> 00:09:42,080
真的还是假的 现在仍然是

257
00:09:42,080 --> 00:09:43,580
每个人都只是在做散列

258
00:09:43,580 --> 00:09:48,440
连接 然后在 2011 年

259
00:09:48,440 --> 00:09:50,180
威斯康星州的研究人员发表了一篇论文，

260
00:09:50,180 --> 00:09:52,250
开始辩论你是否去了

261
00:09:52,250 --> 00:09:53,930
分区已加入与非

262
00:09:53,930 --> 00:09:56,210
分区已经显示并且将 我

263
00:09:56,210 --> 00:09:58,280
稍后会在本次讲座中讨论这些结果，

264
00:09:58,280 --> 00:10:02,150
但是后来有 hyper 的德国人

265
00:10:02,150 --> 00:10:06,470
出来说哦，英特尔

266
00:10:06,470 --> 00:10:09,410
实际上是错误的，而威斯康星州是错误的，

267
00:10:09,410 --> 00:10:11,630
某些加入的速度已经很快，

268
00:10:11,630 --> 00:10:13,850
甚至没有更大的 Cindy 寄存器

269
00:10:13,850 --> 00:10:15,860
，他们展示了如何做

270
00:10:15,860 --> 00:10:18,980
这是超级的，但一年后他们发表

271
00:10:18,980 --> 00:10:21,200
了另一篇论文说

272
00:10:21,200 --> 00:10:22,730
忽略我们在前一年刚刚说的

273
00:10:22,730 --> 00:10:25,940
我们错了散列实际上是

274
00:10:25,940 --> 00:10:27,650
优越的，这里是一个更好的

275
00:10:27,650 --> 00:10:31,670
实现然后在 2013 年

276
00:10:31,670 --> 00:10:33,680
有另一篇研究人员的论文 在

277
00:10:33,680 --> 00:10:36,020
瑞士的 ETH，他们有

278
00:10:36,020 --> 00:10:37,580
很多方法可以使基数散列

279
00:10:37,580 --> 00:10:39,830
绘图更有效地执行，因此

280
00:10:39,830 --> 00:10:41,240
基数散列绘图基数分区

281
00:10:41,240 --> 00:10:43,640
加入我们将讨论这个问题和更多的

282
00:10:43,640 --> 00:10:44,900
讲座，他们只是展示了

283
00:10:44,900 --> 00:10:46,430
如何才能更有效地执行此操作

284
00:10:46,430 --> 00:10:49,460
一个分区加入但随后另一

285
00:10:49,460 --> 00:10:52,460
组德国人在 2016 年站出来说

286
00:10:52,460 --> 00:10:56,090
每个人都需要坚持但停止

287
00:10:56,090 --> 00:10:58,280
发表这些说你知道的

288
00:10:58,280 --> 00:11:00,260
论文 这是我的哈希，回顾

289
00:11:00,260 --> 00:11:03,080
一下它们实际上有多好，然后

290
00:11:03,080 --> 00:11:05,910


291
00:11:05,910 --> 00:11:07,290


292
00:11:07,290 --> 00:11:10,080
对您在联合算法中可能有的不同设计决策进行了详尽的评估，以

293
00:11:10,080 --> 00:11:11,400
更好地了解权衡

294
00:11:11,400 --> 00:11:12,690
是什么以及哪个实际上要权衡

295
00:11:12,690 --> 00:11:15,180
再一次比另一个好，这就是

296
00:11:15,180 --> 00:11:16,560
为什么我签署了你们这篇论文，因为

297
00:11:16,560 --> 00:11:18,300
我得到而不是仅仅说

298
00:11:18,300 --> 00:11:19,710
这是我们

299
00:11:19,710 --> 00:11:22,230
像威斯康星州那样做的一次性实施或超日期或

300
00:11:22,230 --> 00:11:24,660
ETH 他们只是对所有可能的情况进行了彻底的扫描

301
00:11:24,660 --> 00:11:26,970


302
00:11:26,970 --> 00:11:28,800
这些含义中的参数，并向您展示了

303
00:11:28,800 --> 00:11:30,600
在哪些情况下会

304
00:11:30,600 --> 00:11:36,300
比另一种更好，所以现在如果您

305
00:11:36,300 --> 00:11:37,920
想设计我们的联合算法，但是

306
00:11:37,920 --> 00:11:40,830
排序与联合或哈希连接相比，

307
00:11:40,830 --> 00:11:42,390
您应该考虑哪些事情才能

308
00:11:42,390 --> 00:11:44,160
使这个事情运行 有效地，它

309
00:11:44,160 --> 00:11:47,460
可以提供性能，因此在

310
00:11:47,460 --> 00:11:48,570
我们将要实现的两个目标的高水平

311
00:11:48,570 --> 00:11:49,860
上，我们希望最大限度地减少坚持

312
00:11:49,860 --> 00:11:51,690
Rinna 的活动并最大限度地减少

313
00:11:51,690 --> 00:11:54,380
访问成本 g 内存，

314
00:11:54,380 --> 00:11:56,610
所以第一个是显而易见的，我们

315
00:11:56,610 --> 00:12:00,150
之前讨论过这个基本上

316
00:12:00,150 --> 00:12:01,530
意味着我们想要避免必须

317
00:12:01,530 --> 00:12:02,940
使用闩锁来保护

318
00:12:02,940 --> 00:12:04,950
我们连接的数据结构的关键部分，

319
00:12:04,950 --> 00:12:08,580
这样你就没有任何

320
00:12:08,580 --> 00:12:10,650
线程之间的争用或复杂性，

321
00:12:10,650 --> 00:12:11,970
因此每个线程基本上都

322
00:12:11,970 --> 00:12:13,800
在全速运行，并且它们不会

323
00:12:13,800 --> 00:12:15,270
等待另一个线程放弃某些

324
00:12:15,270 --> 00:12:19,710
资源

325
00:12:19,710 --> 00:12:21,240


326
00:12:21,240 --> 00:12:24,240
free 并且有无闩锁

327
00:12:24,240 --> 00:12:26,520
技术可以进行排序

328
00:12:26,520 --> 00:12:30,030
和合并或排序和散列连接 这

329
00:12:30,030 --> 00:12:31,920
只是意味着我们需要更聪明地

330
00:12:31,920 --> 00:12:36,090
了解我们如何将我们的闩锁用于

331
00:12:36,090 --> 00:12:38,070
这里的第二个我们想要的想法是

332
00:12:38,070 --> 00:12:41,820
确保任何时候我们有

333
00:12:41,820 --> 00:12:43,260
一个工作线程正在计算一个连接，

334
00:12:43,260 --> 00:12:45,630
任何时候他们必须接触数据访问

335
00:12:45,630 --> 00:12:48,240
它以进行检查或编写一些我们

336
00:12:48,240 --> 00:12:50,580
想要确保该数据是

337
00:12:50,580 --> 00:12:53,400
该核心的本地数据并且这

338
00:12:53,400 --> 00:12:55,380
可以在 萨 我编号或理想情况下

339
00:12:55,380 --> 00:12:57,930
在相同的 CPU 缓存中，我们希望

340
00:12:57,930 --> 00:12:59,370
最小化内存缓存未命中，并且

341
00:12:59,370 --> 00:13:02,790
永远不会最小化套接字之间的交叉互连流量的数量，

342
00:13:02,790 --> 00:13:04,500


343
00:13:04,500 --> 00:13:10,830
因此我们可以这样做的方法是

344
00:13:10,830 --> 00:13:12,180
最后一个改进我们的缓存行为

345
00:13:12,180 --> 00:13:13,520
是双重的，

346
00:13:13,520 --> 00:13:15,390
所以事情 对我们来说最重要的是

347
00:13:15,390 --> 00:13:17,670
当我们有

348
00:13:17,670 --> 00:13:19,110
我们的算法会导致我们

349
00:13:19,110 --> 00:13:19,640
有缓存

350
00:13:19,640 --> 00:13:23,600
时我们需要考虑

351
00:13:23,600 --> 00:13:26,090
我们的现金和我们的 TLD 翻译

352
00:13:26,090 --> 00:13:28,760
后备缓冲区的大小，这样我们就不会

353
00:13:28,760 --> 00:13:31,370
试图 同时访问大量页面

354
00:13:31,370 --> 00:13:34,430
，所以请考虑一下，如果

355
00:13:34,430 --> 00:13:36,890
我现在需要触摸 10 到 'pls，

356
00:13:36,890 --> 00:13:38,930
如果这 10 到极点位于 10 个

357
00:13:38,930 --> 00:13:42,710
不同的页面

358
00:13:42,710 --> 00:13:45,800
中 我的 TLD 中只有五个条目将虚拟

359
00:13:45,800 --> 00:13:47,030
内存地址映射到 物理内存

360
00:13:47,030 --> 00:13:49,850
地址，然后为了让我真正

361
00:13:49,850 --> 00:13:51,830
对这十件事进行操作，

362
00:13:51,830 --> 00:13:53,390
我将不得不开始为

363
00:13:53,390 --> 00:13:56,090
我的 TLB 上瘾，因此

364
00:13:56,090 --> 00:13:57,530
我想要的数据的缓存未命中加上

365
00:13:57,530 --> 00:14:00,020
TLB 中的缓存未命中 我说我的访问

366
00:14:00,020 --> 00:14:03,080
速度慢了两倍所以理想情况下我想要一个勇敢的

367
00:14:03,080 --> 00:14:06,260
它会带来少量数据

368
00:14:06,260 --> 00:14:07,580
或中等数据我需要做

369
00:14:07,580 --> 00:14:08,900
任何我认为需要

370
00:14:08,900 --> 00:14:11,150
做的操作并在我之前完成所有这些操作

371
00:14:11,150 --> 00:14:14,630
转到下一个名称

372
00:14:14,630 --> 00:14:17,000
，这就是所谓的位置

373
00:14:17,000 --> 00:14:18,470
寺庙和空间位置，所以我只是

374
00:14:18,470 --> 00:14:20,750
确保我正在访问该文件

375
00:14:20,750 --> 00:14:22,100
多次访问这个东西我想

376
00:14:22,100 --> 00:14:24,080
在同一短时间窗口内执行此操作

377
00:14:24,080 --> 00:14:25,220
它总是在缓存中

378
00:14:25,220 --> 00:14:27,200
并且我正在访问多个东西我会

379
00:14:27,200 --> 00:14:28,130
确保它们

380
00:14:28,130 --> 00:14:30,560
在同一个缓存行中靠近在一起

381
00:14:30,560 --> 00:14:31,790
最好在同一个缓存行中这样

382
00:14:31,790 --> 00:14:33,560
我就不会支付多个缓存的惩罚

383
00:14:33,560 --> 00:14:36,980
错过并污染了我的 TLB 所以

384
00:14:36,980 --> 00:14:40,430
我们实现这一目标

385
00:14:40,430 --> 00:14:45,470
的方式是我们需要成为实现这一目标的

386
00:14:45,470 --> 00:14:47,150


387
00:14:47,150 --> 00:14:49,010


388
00:14:49,010 --> 00:14:50,780
方式 或

389
00:14:50,780 --> 00:14:54,410
使用非随机访问进行随机查找

390
00:14:54,410 --> 00:14:56,660
我只是按顺序读取一个字节序列，

391
00:14:56,660 --> 00:15:00,680
然后再次我想

392
00:15:00,680 --> 00:15:02,300
确保该数据适合

393
00:15:02,300 --> 00:15:04,610
单个缓存行，这样您就知道

394
00:15:04,610 --> 00:15:06,560
缓存未命中，并且一个内存被盗去

395
00:15:06,560 --> 00:15:08,330
获取它并带来它

396
00:15:08,330 --> 00:15:10,790
进入 CPU，然后

397
00:15:10,790 --> 00:15:13,190
对于我带入 CPU 缓存的所有内容，我想执行尽可能

398
00:15:13,190 --> 00:15:14,870
多的操作，因为

399
00:15:14,870 --> 00:15:17,870
如果我必须进行随机查找，我就无法对它们进行操作，尽管

400
00:15:17,870 --> 00:15:20,870
我想确保这些随机

401
00:15:20,870 --> 00:15:23,510
查找正在聚集 一起

402
00:15:23,510 --> 00:15:26,990
在同一个缓存行中，所以

403
00:15:26,990 --> 00:15:30,200
我再次对内存进行了大量的查找

404
00:15:30,200 --> 00:15:31,560
，

405
00:15:31,560 --> 00:15:34,980
这是

406
00:15:34,980 --> 00:15:36,569


407
00:15:36,569 --> 00:15:37,889
我们将要拥有的数量指令或

408
00:15:37,889 --> 00:15:40,740
格兰瑟姆产生的周期与数量之间

409
00:15:40,740 --> 00:15:46,560
的经典权衡 内存，所以你马上就会看到这一点

410
00:15:46,560 --> 00:15:48,089
，但就像我们可以

411
00:15:48,089 --> 00:15:49,559
实现所有这些事情的方式是通过

412
00:15:49,559 --> 00:15:51,629
仔细分区并

413
00:15:51,629 --> 00:15:53,790
了解哪些数据存在以及在什么位置，

414
00:15:53,790 --> 00:15:56,189
以便我们的线程始终访问

415
00:15:56,189 --> 00:16:00,300
数据就是这样 CL 没关系，

416
00:16:00,300 --> 00:16:02,459
所以对于并行哈希绘制，

417
00:16:02,459 --> 00:16:04,379
哈希连接对我们来说非常重要，

418
00:16:04,379 --> 00:16:06,660
因为它将成为系统中实现的最常见的

419
00:16:06,660 --> 00:16:07,949
联合算法，

420
00:16:07,949 --> 00:16:12,990
并且许多 OLAP 查询

421
00:16:12,990 --> 00:16:14,970
将包含连接，我们希望这种形式

422
00:16:14,970 --> 00:16:18,540
尽可能高效 在你们阅读的论文中，

423
00:16:18,540 --> 00:16:20,910
虽然你看到

424
00:16:20,910 --> 00:16:23,519
一个特定 TP CH 查询的连接部分

425
00:16:23,519 --> 00:16:26,490
实际上并不是

426
00:16:26,490 --> 00:16:29,040
执行时间的大部分我实际上

427
00:16:29,040 --> 00:16:31,139
看到了两种方式的数字我已经看到

428
00:16:31,139 --> 00:16:33,059
来自 Impala 的数字显示 在

429
00:16:33,059 --> 00:16:35,009


430
00:16:35,009 --> 00:16:38,850


431
00:16:38,850 --> 00:16:40,589
你们从德国或萨尔读到的那种测试平台系统的情况下，连接就像系统时间的 45%，

432
00:16:40,589 --> 00:16:44,519
它

433
00:16:44,519 --> 00:16:46,139
可能不到总时间的 10% 到 15%，

434
00:16:46,139 --> 00:16:48,139
所以有多少

435
00:16:48,139 --> 00:16:50,009
系统将花费在

436
00:16:50,009 --> 00:16:52,199
哈希币上的时间，您可以因系统而异，

437
00:16:52,199 --> 00:16:53,970
但肯定会有

438
00:16:53,970 --> 00:16:55,800
很多连接，并且这些连接几乎

439
00:16:55,800 --> 00:16:57,420
总是作为哈希连接执行，

440
00:16:57,420 --> 00:16:59,069
所以我们将运行 尽可能快，

441
00:16:59,069 --> 00:17:03,629
所以在高层次上的目标

442
00:17:03,629 --> 00:17:05,010
是并行散列一张专辑

443
00:17:05,010 --> 00:17:06,929
是我们希望我们的所有内核始终忙碌

444
00:17:06,929 --> 00:17:08,789
没有人应该被拖延

445
00:17:08,789 --> 00:17:10,799
赢得数据 不应该是没有人

446
00:17:10,799 --> 00:17:12,390
应该被拖延等待另一个

447
00:17:12,390 --> 00:17:13,919
线程完成一些操作，然后

448
00:17:13,919 --> 00:17:15,809
才能理想地进行，您希望

449
00:17:15,809 --> 00:17:17,429
每个人都一直在全力

450
00:17:17,429 --> 00:17:19,559
运行，当然这说起来容易

451
00:17:19,559 --> 00:17:24,390
做起来难，所以哈希连接由

452
00:17:24,390 --> 00:17:25,549
三个阶段组成

453
00:17:25,549 --> 00:17:27,839
分区构建 分区构建

454
00:17:27,839 --> 00:17:29,909
和探测 所以我们要

455
00:17:29,909 --> 00:17:30,600
一个一个地浏览每一个，

456
00:17:30,600 --> 00:17:33,030
但这是一个展示它

457
00:17:33,030 --> 00:17:34,470
作为我们将

458
00:17:34,470 --> 00:17:37,080
在本讲座中进行的大纲，所以在第一阶段

459
00:17:37,080 --> 00:17:38,789
它是完全可选的分区

460
00:17:38,789 --> 00:17:41,039
阶段，这里的想法是我们想要的

461
00:17:41,039 --> 00:17:43,230
根据散列键将我们

462
00:17:43,230 --> 00:17:44,690
连接在一起的表

463
00:17:44,690 --> 00:17:47,220
划分为更小的块，

464
00:17:47,220 --> 00:17:51,870
以便在后续阶段我们

465
00:17:51,870 --> 00:17:54,660
可以让线程仅

466
00:17:54,660 --> 00:17:56,190
对其分区中的数据进行操作，他们不需要去

467
00:17:56,190 --> 00:17:58,770
查看 d  ata 和其他分区，所以如果

468
00:17:58,770 --> 00:18:00,240
你的介绍类成员我们

469
00:18:00,240 --> 00:18:02,160
讨论过

470
00:18:02,160 --> 00:18:04,080
在磁盘上进行分区和溢出存储桶，这有时也

471
00:18:04,080 --> 00:18:05,910
称为宽限散列连接

472
00:18:05,910 --> 00:18:08,070
正确的宽限散列连接只是意味着

473
00:18:08,070 --> 00:18:09,179
您处于高级别您正在做 这是

474
00:18:09,179 --> 00:18:11,549
这个分区阶段，但是您

475
00:18:11,549 --> 00:18:13,590
如何进行分区可能会因下一个

476
00:18:13,590 --> 00:18:16,080
实现的一个实现而

477
00:18:16,080 --> 00:18:18,150


478
00:18:18,150 --> 00:18:20,850


479
00:18:20,850 --> 00:18:22,320


480
00:18:22,320 --> 00:18:24,630
异 通过我们的外部表，

481
00:18:24,630 --> 00:18:26,850
然后我们

482
00:18:26,850 --> 00:18:30,660
将为我们的查询要求的连接键动态构建一个哈希表

483
00:18:30,660 --> 00:18:33,270
，然后在

484
00:18:33,270 --> 00:18:34,470
第二次拟合或我们正在进行的探测的最后

485
00:18:34,470 --> 00:18:35,910
阶段

486
00:18:35,910 --> 00:18:39,660
将对内部表 s 进行 scruncher 扫描，

487
00:18:39,660 --> 00:18:42,090
我们将查找作为连接键哈希的它对

488
00:18:42,090 --> 00:18:44,730
哈希表进行探测，看看

489
00:18:44,730 --> 00:18:47,309
我们是否有匹配项，如果有，那么

490
00:18:47,309 --> 00:18:49,260
我们将产生将组合元组

491
00:18:49,260 --> 00:18:50,820
并产生为

492
00:18:50,820 --> 00:18:52,350
运算符的输出，然后是 f 进入

493
00:18:52,350 --> 00:18:55,470
查询计划，所以要指出的重要一点

494
00:18:55,470 --> 00:18:57,510
是在这个探测阶段

495
00:18:57,510 --> 00:18:59,070
，你们被分配到

496
00:18:59,070 --> 00:19:02,429
真实系统中阅读的论文，如果

497
00:19:02,429 --> 00:19:03,809
你在探测上有匹配，你实际上

498
00:19:03,809 --> 00:19:05,280
需要实现这个组合 元组

499
00:19:05,280 --> 00:19:07,590
，然后将其复制到

500
00:19:07,590 --> 00:19:10,020
操作员的输出缓冲区中，以及

501
00:19:10,020 --> 00:19:11,040
我展示的许多开始的散列绘制论文

502
00:19:11,040 --> 00:19:13,169
或开始时的荷兰语连接论文

503
00:19:13,169 --> 00:19:14,220
他们实际上并没有做

504
00:19:14,220 --> 00:19:17,429
这最后一步只是因为你知道

505
00:19:17,429 --> 00:19:18,540
然后 的数字看起来

506
00:19:18,540 --> 00:19:20,880
真的非常好，或者他们有点没有

507
00:19:20,880 --> 00:19:22,679
真正考虑过，但在

508
00:19:22,679 --> 00:19:24,360
真实系统和萨尔论文中，

509
00:19:24,360 --> 00:19:26,160
他们实际上做了最后一步，这很

510
00:19:26,160 --> 00:19:27,510
重要，因为这会影响

511
00:19:27,510 --> 00:19:29,360
其余部分的表现 关于系统，

512
00:19:29,360 --> 00:19:31,230
我们将在更多的幻灯片中

513
00:19:31,230 --> 00:19:32,669
讨论有限的早期

514
00:19:32,669 --> 00:19:34,200
实现和晚期实现的影响，

515
00:19:34,200 --> 00:19:39,059
好吧，让我们分别

516
00:19:39,059 --> 00:19:40,799
进入每个阶段

517
00:19:40,799 --> 00:19:42,120
，我们将讨论不同的

518
00:19:42,120 --> 00:19:44,160
方法 再次实现它们，

519
00:19:44,160 --> 00:19:45,929
分区阶段是我们将获取

520
00:19:45,929 --> 00:19:47,580
内部和外部关系，

521
00:19:47,580 --> 00:19:49,350
我们将扫描

522
00:19:49,350 --> 00:19:52,919
它们查看连接键散列它们，

523
00:19:52,919 --> 00:19:55,320
然后将它们分配给某个输出

524
00:19:55,320 --> 00:19:58,419
缓冲区分区缓冲区 所以整个

525
00:19:58,419 --> 00:20:00,999
想法是，虽然我们

526
00:20:00,999 --> 00:20:03,279
支付了额外的成本，

527
00:20:03,279 --> 00:20:05,049
必须扫描数据并在一次复制它

528
00:20:05,049 --> 00:20:07,269
的想法是，如果我们

529
00:20:07,269 --> 00:20:09,609
对如何做到这一点很聪明，我们可以

530
00:20:09,609 --> 00:20:11,499
写出数据 以这样一种方式，

531
00:20:11,499 --> 00:20:14,259
当我们进行内置探测时

532
00:20:14,259 --> 00:20:16,690


533
00:20:16,690 --> 00:20:18,159
，我们必须执行这些指令的周期数将减少到最少，

534
00:20:18,159 --> 00:20:19,779
因为我们将最大程度地减少

535
00:20:19,779 --> 00:20:21,789
缓存未命中的次数我将

536
00:20:21,789 --> 00:20:24,580
确保线程正在对

537
00:20:24,580 --> 00:20:26,590
一个数据进行操作 那就是他们的

538
00:20:26,590 --> 00:20:29,320
本地我所以我的想法是我们支付这笔

539
00:20:29,320 --> 00:20:31,239
前期费用以使其他东西

540
00:20:31,239 --> 00:20:34,600
以后更快所以有时在这篇

541
00:20:34,600 --> 00:20:36,220
文献中正如我所说有时有时可以

542
00:20:36,220 --> 00:20:37,450
称为查询哈希Dorn有时

543
00:20:37,450 --> 00:20:39,039
称为混合哈希绘图或t

544
00:20:39,039 --> 00:20:41,139
每当你在散列连接前面看到这些限定符时，基数散列连接就正确

545
00:20:41,139 --> 00:20:42,789
，这

546
00:20:42,789 --> 00:20:43,989
意味着它们

547
00:20:43,989 --> 00:20:46,119
在它前面执行某种分区步骤，

548
00:20:46,119 --> 00:20:48,850
所以正如我在上一张幻灯片中所说的，

549
00:20:48,850 --> 00:20:51,730
我们需要了解我们 '

550
00:20:51,730 --> 00:20:53,789
实际上是放入我们的缓冲区，

551
00:20:53,789 --> 00:20:56,139
因为这会极大地影响

552
00:20:56,139 --> 00:20:58,210
性能，事实证明，

553
00:20:58,210 --> 00:20:59,350
您在缓冲区中蚀刻的内容

554
00:20:59,350 --> 00:21:01,149
将取决于

555
00:21:01,149 --> 00:21:03,820
我们之前讨论过的存储模型，因此如果

556
00:21:03,820 --> 00:21:06,850
它是行存储，通常他们会放入

557
00:21:06,850 --> 00:21:09,159
上传缓冲区中的整个元组，

558
00:21:09,159 --> 00:21:11,859
因为即使我可能只

559
00:21:11,859 --> 00:21:13,179
需要属性的一个子集来

560
00:21:13,179 --> 00:21:15,009
进行连接或 X 是查询的其余部分，

561
00:21:15,009 --> 00:21:17,980
它只是复制一些连续

562
00:21:17,980 --> 00:21:19,450
的内存块并写入我的

563
00:21:19,450 --> 00:21:21,879
输出缓冲区赫兹 我

564
00:21:21,879 --> 00:21:25,869
在列存储中的分区缓冲区通常您所做的

565
00:21:25,869 --> 00:21:28,749
是只存储您

566
00:21:28,749 --> 00:21:32,440
需要进行连接的键，然后将偏移量

567
00:21:32,440 --> 00:21:34,119
存储到可以找到其余部分的位置 如果

568
00:21:34,119 --> 00:21:36,039
您需要将它拼接在一起以及

569
00:21:36,039 --> 00:21:38,129
原因 为什么你可以这样做是因为

570
00:21:38,129 --> 00:21:40,330
你想这样做是因为你

571
00:21:40,330 --> 00:21:41,649
最大限度地减少了你实际复制的数据量，

572
00:21:41,649 --> 00:21:44,950
从你

573
00:21:44,950 --> 00:21:48,700
知道的复制并制作这些分区，你

574
00:21:48,700 --> 00:21:49,869
不必担心把它

575
00:21:49,869 --> 00:21:51,249
切碎 将在行存储中，因为它

576
00:21:51,249 --> 00:21:53,200
已经作为列存储为您进行了划分或分区，

577
00:21:53,200 --> 00:21:55,809
因此更有效的

578
00:21:55,809 --> 00:21:57,489
方法是再次执行的

579
00:21:57,489 --> 00:21:59,499
最低限度数字是

580
00:21:59,499 --> 00:22:01,179
您计算连接所需的最低限度信息

581
00:22:01,179 --> 00:22:02,830
，然后如果另一个部分

582
00:22:02,830 --> 00:22:04,690
上面的查询和计划需要

583
00:22:04,690 --> 00:22:05,889
额外的列是额外的

584
00:22:05,889 --> 00:22:08,019
属性，您使用偏移量来

585
00:22:08,019 --> 00:22:10,679
查找该信息，

586
00:22:10,899 --> 00:22:14,149
因此对于分区有两种

587
00:22:14,149 --> 00:22:15,860
方法，

588
00:22:15,860 --> 00:22:17,809
即非阻塞分区和阻塞分区或基数

589
00:22:17,809 --> 00:22:21,679
分区，因此使用

590
00:22:21,679 --> 00:22:23,120
非阻塞方法的想法 是您

591
00:22:23,120 --> 00:22:24,710
有一组线程将

592
00:22:24,710 --> 00:22:27,649
要通过并对数据进行分区，因此

593
00:22:27,649 --> 00:22:29,659
扫描我们内部表中的加法器开始

594
00:22:29,659 --> 00:22:32,690
生成这些分区，然后就像

595
00:22:32,690 --> 00:22:34,639
它一样 enerating 是输出，您可以拥有

596
00:22:34,639 --> 00:22:36,260
另一组线程，我们将读取该

597
00:22:36,260 --> 00:22:38,840
数据并开始下一个阶段以

598
00:22:38,840 --> 00:22:42,230
开始正确填充哈希表

599
00:22:42,230 --> 00:22:43,580
，您可以这样做，因为您不

600
00:22:43,580 --> 00:22:44,990
担心任何误报漏报

601
00:22:44,990 --> 00:22:45,740


602
00:22:45,740 --> 00:22:48,409
我很抱歉 误报，例如

603
00:22:48,409 --> 00:22:50,210
数据被分区后，您可以

604
00:22:50,210 --> 00:22:52,549
立即填充哈希表，这

605
00:22:52,549 --> 00:22:53,929
取决于您是否进行一次

606
00:22:53,929 --> 00:22:55,250
传递，但一般而言，对于

607
00:22:55,250 --> 00:22:57,799
非阻塞，人们是否会

608
00:22:57,799 --> 00:23:02,029
在第二种方法中正确传递

609
00:23:02,029 --> 00:23:03,409
一次” 重新进行基数分区

610
00:23:03,409 --> 00:23:05,330
的工作方式是，您可以让

611
00:23:05,330 --> 00:23:07,669
所有线程

612
00:23:07,669 --> 00:23:11,419
扫描一次表和一次表并

613
00:23:11,419 --> 00:23:14,690
生成分区，因为

614
00:23:14,690 --> 00:23:17,149
您不确切知道每个线程走了多远

615
00:23:17,149 --> 00:23:19,070
，您知道 是否因为

616
00:23:19,070 --> 00:23:20,570
一切都已经被分成了桶，

617
00:23:20,570 --> 00:23:23,330
你不能保证你拥有

618
00:23:23,330 --> 00:23:24,559
填充哈希表所需的所有数据，

619
00:23:24,559 --> 00:23:26,419
所以所有线程都在这样做，

620
00:23:26,419 --> 00:23:27,830
但是这个分区同时

621
00:23:27,830 --> 00:23:29,360
进行 当完成后，您

622
00:23:29,360 --> 00:23:32,080
切换并执行构建阶段，

623
00:23:32,080 --> 00:23:34,100
因此让我们逐一完成其中的

624
00:23:34,100 --> 00:23:36,500
每一个，以防万一非阻塞

625
00:23:36,500 --> 00:23:39,620
分区实际上有两种

626
00:23:39,620 --> 00:23:41,210
子集或两种额外的方式，

627
00:23:41,210 --> 00:23:44,149
您可以再次实际实现这一点

628
00:23:44,149 --> 00:23:45,289
这就是我们要扫描

629
00:23:45,289 --> 00:23:47,000
关系，然后扫描一次，然后

630
00:23:47,000 --> 00:23:49,519
即时构建输出，因此使用共享

631
00:23:49,519 --> 00:23:51,769
分区，您将让所有

632
00:23:51,769 --> 00:23:53,330
线程尝试同时写入相同的

633
00:23:53,330 --> 00:23:55,130
内存位置或

634
00:23:55,130 --> 00:23:57,919
相同的存储桶 您的分区，

635
00:23:57,919 --> 00:23:59,299
这意味着您必须使用闩锁

636
00:23:59,299 --> 00:24:01,490
来同步存储桶，以

637
00:24:01,490 --> 00:24:02,720
确保一个线程不会

638
00:24:02,720 --> 00:24:04,190
覆盖另一个线程

639
00:24:04,190 --> 00:24:07,039
在第二篇文章中错误写入的内容，

640
00:24:07,039 --> 00:24:08,389
您曾经拥有私有

641
00:24:08,389 --> 00:24:10,039
分区，其中每个 线程现在有

642
00:24:10,039 --> 00:24:12,110
自己的一组可以填充的桶，

643
00:24:12,110 --> 00:24:14,690
没有其他线程

644
00:24:14,690 --> 00:24:15,889
写入这个桶，所以你不需要闩锁

645
00:24:15,889 --> 00:24:19,570
来保护任何东西，然后一旦

646
00:24:19,570 --> 00:24:21,380


647
00:24:21,380 --> 00:24:23,900
第一阶段完成 首先将

648
00:24:23,900 --> 00:24:25,400
其与私有分区一起传递，

649
00:24:25,400 --> 00:24:27,320
然后您可以通过另一

650
00:24:27,320 --> 00:24:29,770
组线程进行处理，然后填充

651
00:24:29,770 --> 00:24:33,110
您正在执行的第一个全局分区存储桶，

652
00:24:33,110 --> 00:24:36,740
因此再次成为经典的

653
00:24:36,740 --> 00:24:38,570
经典通勤科学

654
00:24:38,570 --> 00:24:41,000
，一方面没有免费的午餐 在这种

655
00:24:41,000 --> 00:24:42,650
情况下，我们在这里使用锁存器来

656
00:24:42,650 --> 00:24:44,840
保护数据结构，但我们只需要

657
00:24:44,840 --> 00:24:47,660
每次通过分区一次，

658
00:24:47,660 --> 00:24:50,930
在这个分区中它是无锁存器的，但这

659
00:24:50,930 --> 00:24:52,430
意味着我们必须再

660
00:24:52,430 --> 00:24:54,620
通过数据来合并

661
00:24:54,620 --> 00:24:56,150
整合

662
00:24:56,150 --> 00:24:58,850
在不同线程中分散或划分的所有信息，

663
00:24:58,850 --> 00:25:01,310
所以我们将通过

664
00:25:01,310 --> 00:25:03,920
让我们通过其中的每一个，所以这里

665
00:25:03,920 --> 00:25:06,500
是共享分区方法好吧，

666
00:25:06,500 --> 00:25:07,820
所以我们有我们的数据表，我们有三

667
00:25:07,820 --> 00:25:09,830
列，我们的第一件事 我们

668
00:25:09,830 --> 00:25:13,130
要做的就是像以前一样将数据分成

669
00:25:13,130 --> 00:25:14,900
不同的块或小块

670
00:25:14,900 --> 00:25:17,750
，这些只是数据范围，

671
00:25:17,750 --> 00:25:19,310
我们实际上并不知道其中的内容，

672
00:25:19,310 --> 00:25:20,810
但我们只是说您知道 前

673
00:25:20,810 --> 00:25:23,000
102 次打击是这个线程

674
00:25:23,000 --> 00:25:24,230
接下来的 100 次打击是另一个

675
00:25:24,230 --> 00:25:27,230
线程所以现在假设我们希望您

676
00:25:27,230 --> 00:25:30,200
在 B 列上进行连接，因此我们将获取

677
00:25:30,200 --> 00:25:31,580
B 的值和每个元组，然后我们将

678
00:25:31,580 --> 00:25:33,500
用

679
00:25:33,500 --> 00:25:35,330
我们将在

680
00:25:35,330 --> 00:25:39,950
内置探测阶段使用相同的哈希函数，所以我们必须这样做，

681
00:25:39,950 --> 00:25:40,850
因为您必须确保

682
00:25:40,850 --> 00:25:43,280
如果我们在一个阶段

683
00:25:43,280 --> 00:25:45,530
中对一个键进行哈希处理，如果我们稍后对相同的键进行哈希处理，

684
00:25:45,530 --> 00:25:47,510
我们就会结束 在相同的位置或我们的

685
00:25:47,510 --> 00:25:48,890
哈希表或我们的存储桶中，以确保

686
00:25:48,890 --> 00:25:50,240
我们可以找到我们正在寻找的信息，

687
00:25:50,240 --> 00:25:53,060
因此我们将对其进行哈希处理，并且

688
00:25:53,060 --> 00:25:54,680
我们知道我们的患者是我们将

689
00:25:54,680 --> 00:25:56,660
要提前指定 时间，所以我们

690
00:25:56,660 --> 00:25:59,150
只是通过分区数量的哈希值来修改

691
00:25:59,150 --> 00:26:00,410
它，这将

692
00:26:00,410 --> 00:26:02,150
告诉我们我们将进入哪个分区链，

693
00:26:02,150 --> 00:26:04,760
所以现在每个线程都将

694
00:26:04,760 --> 00:26:07,820
写入哈希的每个值

695
00:26:07,820 --> 00:26:09,500
它和 mod 告诉

696
00:26:09,500 --> 00:26:10,430
你他们直接进入他们的哪个

697
00:26:10,430 --> 00:26:13,760
，所以这又是一个全局设置

698
00:26:13,760 --> 00:26:15,530
桶所以每个线程都可以

699
00:26:15,530 --> 00:26:18,200
在任何时候写入任何桶所以我们

700
00:26:18,200 --> 00:26:19,760
只需要使用闩锁来保护

701
00:26:19,760 --> 00:26:22,100
你想要插入的最后一个地方

702
00:26:22,100 --> 00:26:24,650
我非常想要你然后你

703
00:26:24,650 --> 00:26:28,070
可以插入一个新值

704
00:26:28,070 --> 00:26:29,810
另一种方法是使用

705
00:26:29,810 --> 00:26:32,090
相同的私有分区设置我们

706
00:26:32,090 --> 00:26:34,190
在不同的线程之间恢复数据，

707
00:26:34,190 --> 00:26:34,909
他们只是

708
00:26:34,909 --> 00:26:37,820
扔了一把斧头然后

709
00:26:37,820 --> 00:26:39,409
修改我们想要的数量请愿

710
00:26:39,409 --> 00:26:42,289
但会发生的是每个线程

711
00:26:42,289 --> 00:26:44,299
都有自己的排序

712
00:26:44,299 --> 00:26:46,549
我们在上一张幻灯片中看到的一组存储桶，所以现在

713
00:26:46,549 --> 00:26:48,259
当我

714
00:26:48,259 --> 00:26:50,659
在每个线程中写入这些不同的存储桶时，我是唯一

715
00:26:50,659 --> 00:26:52,039
在那里写入的线程 我不需要

716
00:26:52,039 --> 00:26:53,419
保护我的两个闩锁，所以这

717
00:26:53,419 --> 00:26:56,090
真的会发生 现在真的很快，一旦所有

718
00:26:56,090 --> 00:26:58,340
线程都完成，那么我必须

719
00:26:58,340 --> 00:27:00,080
将所有内容组合在一起以创建

720
00:27:00,080 --> 00:27:02,299


721
00:27:02,299 --> 00:27:05,299
我在上一张幻灯片中拥有的空间的全局分区，因此要做到这一点，我

722
00:27:05,299 --> 00:27:08,139
可以让一堆线程

723
00:27:08,139 --> 00:27:11,889
每个选择一个单独的你 知道分区

724
00:27:11,889 --> 00:27:15,080
对不同线程的一组调用

725
00:27:15,080 --> 00:27:17,419
并负责填充这个东西，

726
00:27:17,419 --> 00:27:20,059
所以在这种情况下，

727
00:27:20,059 --> 00:27:21,379
我在进行合并时不需要获取闩锁，

728
00:27:21,379 --> 00:27:23,450
但我仍然需要采用

729
00:27:23,450 --> 00:27:25,429
第二条路径，因此线程二我们将进行

730
00:27:25,429 --> 00:27:26,570
分区二 线程 3 执行

731
00:27:26,570 --> 00:27:30,470
Parchin 3

732
00:27:30,470 --> 00:27:32,210
等等，这也是一个很好的示例，

733
00:27:32,210 --> 00:27:34,489
说明物化问题可能很

734
00:27:34,489 --> 00:27:37,369
重要，因为我将数据

735
00:27:37,369 --> 00:27:39,619
复制两次，然后将数据

736
00:27:39,619 --> 00:27:41,539
从数据表中复制到我的分区中，

737
00:27:41,539 --> 00:27:43,220
然后 从私人分区

738
00:27:43,220 --> 00:27:45,739
到组合分区，所以如果我是一个

739
00:27:45,739 --> 00:27:47,239
行存储并且我正在复制

740
00:27:47,239 --> 00:27:49,309
我的两个螺栓的整个元组非常大那么

741
00:27:49,309 --> 00:27:52,129
这个副本是昂贵的如果它是一个列

742
00:27:52,129 --> 00:27:53,869
存储并且我都在复制

743
00:27:53,869 --> 00:27:55,129
他们需要加入的中等数据量

744
00:27:55,129 --> 00:27:57,049
加上可能

745
00:27:57,049 --> 00:27:58,700
比元组的完整大小小得多的偏移量

746
00:27:58,700 --> 00:28:00,919
，因此这个副本可以让你知道

747
00:28:00,919 --> 00:28:03,019
CPU 缓存和内存的压力更小

748
00:28:03,019 --> 00:28:05,090
，当然你

749
00:28:05,090 --> 00:28:10,700
知道的指令可能更少 好的，所以这

750
00:28:10,700 --> 00:28:14,200
是

751
00:28:14,200 --> 00:28:18,049
非阻塞分区方案的一个例子，让

752
00:28:18,049 --> 00:28:19,129
我们现在讨论基数分区

753
00:28:19,129 --> 00:28:22,879
方法，这里的想法是我们正在

754
00:28:22,879 --> 00:28:24,229
做我们之前看到的相同类型的分区，

755
00:28:24,229 --> 00:28:28,489
但我们正在 更

756
00:28:28,489 --> 00:28:32,450
仔细或更小心地进行

757
00:28:32,450 --> 00:28:38,210
分区，这样我们

758
00:28:38,210 --> 00:28:41,210
可以让线程在内存中写入两个单独的

759
00:28:41,210 --> 00:28:43,909
位置，而无需如何获取

760
00:28:43,909 --> 00:28:46,640
闩锁，但是我们必须等待

761
00:28:46,640 --> 00:28:48,530
每个人都完成后才能

762
00:28:48,530 --> 00:28:50,660
进入下一阶段，因为 我们不知道

763
00:28:50,660 --> 00:28:53,480
还缺少什么，

764
00:28:53,480 --> 00:28:55,160
当我们谈论时，这会更有意义

765
00:28:55,160 --> 00:28:57,380
我将展示图表，因此

766
00:28:57,380 --> 00:28:58,160
根据分区率，我们将采取

767
00:28:58,160 --> 00:29:01,040
多步进行多步

768
00:29:01,040 --> 00:29:03,830
传递每个 的关系，因此

769
00:29:03,830 --> 00:29:04,850
在第一步中，我们将

770
00:29:04,850 --> 00:29:07,130
扫描并计算一个直方图，该直方图

771
00:29:07,130 --> 00:29:09,080
将告诉我们

772
00:29:09,080 --> 00:29:12,770
我们将拥有她的手的元组数量，然后我们可以

773
00:29:12,770 --> 00:29:14,960
使用该直方图来计算

774
00:29:14,960 --> 00:29:17,030
所谓的 Pixum 会告诉我们什么时候

775
00:29:17,030 --> 00:29:20,419
如果我们写一个特定的元组，我们分区空间中的偏移量，

776
00:29:20,419 --> 00:29:23,870
那么现在我们将

777
00:29:23,870 --> 00:29:27,530
再次扫描我们的，

778
00:29:27,530 --> 00:29:29,929
现在进行散列，并根据

779
00:29:29,929 --> 00:29:31,520
我们定义的位置，我们

780
00:29:31,520 --> 00:29:33,110
使用前一列转向我们的写入，然后我们

781
00:29:33,110 --> 00:29:35,809
写入 分区空间，所以

782
00:29:35,809 --> 00:29:37,490
我们将再次逐个讨论，

783
00:29:37,490 --> 00:29:39,140
所以首先要指出

784
00:29:39,140 --> 00:29:40,309
的是，术语最大

785
00:29:40,309 --> 00:29:42,770
分区是指

786
00:29:42,770 --> 00:29:45,590
总键的数字或一个字节，它是相同的

787
00:29:45,590 --> 00:29:48,530
速率 X 术语 我们之前在讨论基数条约时看到的，

788
00:29:48,530 --> 00:29:50,210


789
00:29:50,210 --> 00:29:51,980
而不是拥有整个键 我只是

790
00:29:51,980 --> 00:29:54,559
要散列或分区地下室的

791
00:29:54,559 --> 00:29:57,470
一部分前缀列只是

792
00:29:57,470 --> 00:30:00,169
一种再次

793
00:30:00,169 --> 00:30:01,460
确定我们想要的起始位置的方法

794
00:30:01,460 --> 00:30:04,010


795
00:30:04,010 --> 00:30:06,410
为每个线程写入我们的全局全局分区缓冲区，

796
00:30:06,410 --> 00:30:07,610
让我们首先了解前缀 um 是什么，

797
00:30:07,610 --> 00:30:10,730
所以raid X

798
00:30:10,730 --> 00:30:13,700
只是键中某个数字的值，

799
00:30:13,700 --> 00:30:16,760
所以我的键是 89 12 2300

800
00:30:16,760 --> 00:30:20,210
841 和 64 吨 他在这里第一个

801
00:30:20,210 --> 00:30:21,380
位置的raid X对于这些键中的每一个

802
00:30:21,380 --> 00:30:23,210
都是九二三八一四

803
00:30:23,210 --> 00:30:25,880
，然后下一个键的raid X

804
00:30:25,880 --> 00:30:29,630
只是八一二等等

805
00:30:29,630 --> 00:30:32,030
，所以这就是

806
00:30:32,030 --> 00:30:33,290
raid X分区的全部意思 我们将一次查看

807
00:30:33,290 --> 00:30:35,360
密钥中的一个数字

808
00:30:35,360 --> 00:30:37,730
散列那个数字，

809
00:30:37,730 --> 00:30:39,559
然后如果你想进行额外的

810
00:30:39,559 --> 00:30:42,130
传递，我们可以查看我们可以查看

811
00:30:42,130 --> 00:30:46,309
Malton 人获得后续数字，

812
00:30:46,309 --> 00:30:48,770
因此在现代 CPU 中 你可以

813
00:30:48,770 --> 00:30:49,309


814
00:30:49,309 --> 00:30:50,630
用这个乘法指令非常有效地计算这个基数，

815
00:30:50,630 --> 00:30:52,010
所以

816
00:30:52,010 --> 00:30:54,230
这不是一个昂贵的操作，

817
00:30:54,230 --> 00:30:55,730


818
00:30:55,730 --> 00:30:59,570
所以现在有了这个基数，基数就是

819
00:30:59,570 --> 00:31:01,639
这些键，我们可以计算

820
00:31:01,639 --> 00:31:03,500
所谓的 P Pixum，这只是一个

821
00:31:03,500 --> 00:31:08,360
运行求和

822
00:31:08,360 --> 00:31:13,309
数字的运行计数和

823
00:31:13,309 --> 00:31:15,889
输出中前缀 um 的位置确定是

824
00:31:15,889 --> 00:31:19,399
基于它之前

825
00:31:19,399 --> 00:31:21,950
出现的键所以我有键 1 2 3 4 5 6 所以对于我的

826
00:31:21,950 --> 00:31:24,320
前缀 um 在第一个位置

827
00:31:24,320 --> 00:31:25,700
上一次是  只是 1 因为它

828
00:31:25,700 --> 00:31:26,899
之前没有任何

829
00:31:26,899 --> 00:31:29,990
东西所以它只是一个值 1 但现在

830
00:31:29,990 --> 00:31:31,639
对于下一个位置我要取

831
00:31:31,639 --> 00:31:33,440
前一个前缀

832
00:31:33,440 --> 00:31:36,440
的值一些计算然后这个键的值

833
00:31:36,440 --> 00:31:38,809
并将它们加在一起就是 现在

834
00:31:38,809 --> 00:31:41,360
我这个位置的前缀 um 所以 1 加

835
00:31:41,360 --> 00:31:44,029
2 是 3 相同的东西现在我在这里采取这个

836
00:31:44,029 --> 00:31:47,929
位置 3 3 6 10 15 20 和 21

837
00:31:47,929 --> 00:31:50,269
等等，我们

838
00:31:50,269 --> 00:31:51,950
学习这样做的原因是因为现在我们可以

839
00:31:51,950 --> 00:31:54,350
使用这些 这些选择一些来

840
00:31:54,350 --> 00:31:56,179
再次告诉我们我们想要写入的偏移量，

841
00:31:56,179 --> 00:31:58,460
因为我们说如果我之前有一个元组

842
00:31:58,460 --> 00:32:00,669
那么我应该开始写我

843
00:32:00,669 --> 00:32:04,340
喜欢我的元组在位置 1 之后

844
00:32:04,340 --> 00:32:05,779
但是现在这个人说我想写

845
00:32:05,779 --> 00:32:07,100
元组 并且他知道他刚刚开始

846
00:32:07,100 --> 00:32:08,929
偏移 3 这些基本上将

847
00:32:08,929 --> 00:32:12,159
用于分区数组中的偏移

848
00:32:12,159 --> 00:32:14,480
所以让我们看看分区的会费率

849
00:32:14,480 --> 00:32:15,980
所以我们

850
00:32:15,980 --> 00:32:19,010
需要做的第一步是检查输入键和

851
00:32:19,010 --> 00:32:21,559
火山口直方图所以说输出

852
00:32:21,559 --> 00:32:22,429
输入键，我们是 d 在

853
00:32:22,429 --> 00:32:24,500
这里已经解决了我们已经对其进行了

854
00:32:24,500 --> 00:32:25,909
哈希处理我们已经根据

855
00:32:25,909 --> 00:32:28,940
我们拥有的分区数量进行了修改我

856
00:32:28,940 --> 00:32:30,110
只是再见我们还没有陷入

857
00:32:30,110 --> 00:32:32,029
分区数量我们已经对它进行了哈希处理现在

858
00:32:32,029 --> 00:32:33,260
我们 想要查看散列的数字，

859
00:32:33,260 --> 00:32:36,289
所以我们要做的是

860
00:32:36,289 --> 00:32:40,490
查看这里的第一个数字，对于

861
00:32:40,490 --> 00:32:42,139
每个线程，

862
00:32:42,139 --> 00:32:43,669
您只需站在指定的

863
00:32:43,669 --> 00:32:47,169
范围内并计算直方图 是

864
00:32:47,169 --> 00:32:50,000
正确的，所以它是

865
00:32:50,000 --> 00:32:52,309
将出现在特定分区的值的数量，所以

866
00:32:52,309 --> 00:32:55,250
在这种情况下，对于分区

867
00:32:55,250 --> 00:32:58,760
0 的 CPU 0，它在分区 1 有 2 个条目 1 2 在分区 1

868
00:32:58,760 --> 00:33:01,700
有 2 个条目 1 2 就像在这里它

869
00:33:01,700 --> 00:33:04,669
在分区 0 它有 有一个因为

870
00:33:04,669 --> 00:33:06,559
那里有 1 0 然后对于分区

871
00:33:06,559 --> 00:33:09,230
1 它有 3 1 2 3

872
00:33:09,230 --> 00:33:10,519
我认为我们只是

873
00:33:10,519 --> 00:33:12,519
通过有效地扫描数据来计算这个直方图

874
00:33:12,519 --> 00:33:14,750
然后现在我们要做的是计算

875
00:33:14,750 --> 00:33:18,559
我们的分区数组中的偏移量，

876
00:33:18,559 --> 00:33:21,529
线程可以 好的，所以我们必须

877
00:33:21,529 --> 00:33:23,179
阻塞并等待所有线程

878
00:33:23,179 --> 00:33:25,700
完成他们的分区，然后我们现在

879
00:33:25,700 --> 00:33:27,830
根据直方图计算前缀 um

880
00:33:27,830 --> 00:33:29,179
，直方图告诉我们我们

881
00:33:29,179 --> 00:33:30,950
将从哪里开始写入每个

882
00:33:30,950 --> 00:33:32,240
线程可以写入该分区

883
00:33:32,240 --> 00:33:34,970
数组的位置，所以像这样所以

884
00:33:34,970 --> 00:33:37,580
CPU 0 的分区 0 是正确的 这里和

885
00:33:37,580 --> 00:33:40,460
CPU 1 的分区 0 可以写在这里，

886
00:33:40,460 --> 00:33:43,700
所以位置 0 从位置 0 开始，

887
00:33:43,700 --> 00:33:45,769
因为前一个 um 请愿 0

888
00:33:45,769 --> 00:33:48,049
在 CPU 1 但就在这里，因为它的

889
00:33:48,049 --> 00:33:49,909
这个值是 2 因为前一

890
00:33:49,909 --> 00:33:52,639
列将是 3 所以 1 2 3 和 等等

891
00:33:52,639 --> 00:33:56,000
对于另一个现在

892
00:33:56,000 --> 00:33:57,529
这对我们有什么作用现在会给我们一个

893
00:33:57,529 --> 00:34:01,940
巨大的数组或巨大的缓冲区，

894
00:34:01,940 --> 00:34:04,130
线程可以开始写入并且他们

895
00:34:04,130 --> 00:34:05,990
不需要协调器获取锁存器

896
00:34:05,990 --> 00:34:09,530
来保护内存中的任何位置

897
00:34:09,530 --> 00:34:11,449
当它做对了，因为它

898
00:34:11,449 --> 00:34:12,980
已经计算了自己的前缀，我们

899
00:34:12,980 --> 00:34:14,359
已经知道没有其他人会

900
00:34:14,359 --> 00:34:16,639
写入我们的位置，所以我们

901
00:34:16,639 --> 00:34:18,918
可以很好地写入它，我们必须

902
00:34:18,918 --> 00:34:20,869
在我们的 CPU 中维护一个内部计数器

903
00:34:20,869 --> 00:34:23,270
来说哦 4 分区 0 我已经

904
00:34:23,270 --> 00:34:24,469
插入你知道一两

905
00:34:24,469 --> 00:34:26,569
件事或三件事，所以使用我的

906
00:34:26,569 --> 00:34:28,699
起点我可以快速决定

907
00:34:28,699 --> 00:34:31,369
所有设置我应该将我的新数据写入我的下一个

908
00:34:31,369 --> 00:34:34,639
数据，所以现在有了

909
00:34:34,639 --> 00:34:37,250
这个我们 已经计算了这个

910
00:34:37,250 --> 00:34:38,869
分区输出，起始

911
00:34:38,869 --> 00:34:40,520
位置是我们行使权利的地方，现在

912
00:34:40,520 --> 00:34:42,889
我们返回并再次进行扫描，现在

913
00:34:42,889 --> 00:34:44,179
我们进行分区，现在我们正在

914
00:34:44,179 --> 00:34:47,659
复制

915
00:34:47,659 --> 00:34:49,909
我们散列的键的值 再次进入我们的写入分区，

916
00:34:49,909 --> 00:34:51,649
我们可以在不应用锁存器的情况下做到这一点，

917
00:34:51,649 --> 00:34:54,589
所以现在在高层次

918
00:34:54,589 --> 00:34:55,579
上思考这个问题的方式是

919
00:34:55,579 --> 00:34:57,349
我们有分区 0 和

920
00:34:57,349 --> 00:35:00,589
分区 1，所以在这一点上，我们可以

921
00:35:00,589 --> 00:35:02,930
将其移交 到构建阶段或

922
00:35:02,930 --> 00:35:04,190
并开始计算哈希

923
00:35:04,190 --> 00:35:06,920
表，或者如果我们愿意，我们可以再次

924
00:35:06,920 --> 00:35:09,680
开始进一步划分子

925
00:35:09,680 --> 00:35:13,130
分区，以便我们

926
00:35:13,130 --> 00:35:15,020
在这些分区中的数据块现在可以

927
00:35:15,020 --> 00:35:17,000
放入缓存行或少量 缓存

928
00:35:17,000 --> 00:35:19,369
行一切正常等等 这样做我们

929
00:35:19,369 --> 00:35:22,460
现在就回去并

930
00:35:22,460 --> 00:35:25,280
在这个下一个基数值内跳转到下一个下一个

931
00:35:25,280 --> 00:35:27,500
基数并且这样做你知道

932
00:35:27,500 --> 00:35:30,400
再次分区，

933
00:35:30,400 --> 00:35:34,790
但是我会说在实践中很好

934
00:35:34,790 --> 00:35:36,080
在实践中大多数人不会 做速率

935
00:35:36,080 --> 00:35:38,570
分区虽然它被证明是

936
00:35:38,570 --> 00:35:41,869
优越的 然后我知道的其他几个系统

937
00:35:41,869 --> 00:35:44,570
这样做 他们主要是

938
00:35:44,570 --> 00:35:47,960
学术原型 他们几乎从不做

939
00:35:47,960 --> 00:35:49,609
两次通过通常是一次通过并且

940
00:35:49,609 --> 00:35:54,640
你已经完成了所以现在我们有我们的

941
00:35:54,640 --> 00:35:56,930
无论我们是否完成分区，现在

942
00:35:56,930 --> 00:35:58,700
我们都进入构建阶段，

943
00:35:58,700 --> 00:35:59,839
这里的想法是我们将

944
00:35:59,839 --> 00:36:02,810
扫描外部表，要么只在

945
00:36:02,810 --> 00:36:04,820
原始表本身中，要么如果我们分区

946
00:36:04,820 --> 00:36:06,740
，然后分区，然后对于

947
00:36:06,740 --> 00:36:08,230
每个单独的元组我们 '

948
00:36:08,230 --> 00:36:10,609
我们要在分区阶段使用的同一个键上对它进行散列

949
00:36:10,609 --> 00:36:12,800
，然后

950
00:36:12,800 --> 00:36:16,270
我们要把它正确地存储到一个哈希表中

951
00:36:16,270 --> 00:36:19,580
，理想情况下，我们希望设计

952
00:36:19,580 --> 00:36:21,650
我们的哈希表，使得

953
00:36:21,650 --> 00:36:23,599
每个桶的大小 我们正在写

954
00:36:23,599 --> 00:36:26,270
你只知道几个缓存

955
00:36:26,270 --> 00:36:28,640
行的大小是正确的，因为这样

956
00:36:28,640 --> 00:36:29,810
可以更

957
00:36:29,810 --> 00:36:33,200
有效地处理事情，所以我们现在需要讨论

958
00:36:33,200 --> 00:36:34,910
这个哈希表实际上是

959
00:36:34,910 --> 00:36:36,619
什么样子的

960
00:36:36,619 --> 00:36:38,990
写入哈希

961
00:36:38,990 --> 00:36:40,790
表将是一些缓存行

962
00:36:40,790 --> 00:36:42,380
这实际上意味着

963
00:36:42,380 --> 00:36:43,580
什么 我们的哈希表实际上是什么

964
00:36:43,580 --> 00:36:46,130
样子

965
00:36:46,130 --> 00:36:47,900
以便了解我们需要什么哈希表

966
00:36:47,900 --> 00:36:49,940


967
00:36:49,940 --> 00:36:51,770
通常当人们说他们有两个主要设计决策时 一个

968
00:36:51,770 --> 00:36:54,320
哈希表，它是一种使用的口语

969
00:36:54,320 --> 00:36:55,940
，就像数据结构本身一样，

970
00:36:55,940 --> 00:37:00,050
但在实践中实际上

971
00:37:00,050 --> 00:37:01,310
提交了这两

972
00:37:01,310 --> 00:37:02,900
件事的组合哈希函数哈希

973
00:37:02,900 --> 00:37:05,300
方案所以哈希函数是

974
00:37:05,300 --> 00:37:06,589
我们将采用的一种方式 获取

975
00:37:06,589 --> 00:37:08,630
位于更大域过敏空间中的密钥

976
00:37:08,630 --> 00:37:12,500
，我们希望将其映射到

977
00:37:12,500 --> 00:37:15,290
哈希表数据结构中的特定位置或插槽，

978
00:37:15,290 --> 00:37:17,420
但它说就像

979
00:37:17,420 --> 00:37:19,970
您获取所有可能的字符串

980
00:37:19,970 --> 00:37:21,440
一样 有一个散列函数，

981
00:37:21,440 --> 00:37:23,869
然后可以将其转换为某个整数，

982
00:37:23,869 --> 00:37:25,910
然后我们可以说您知道在一到

983
00:37:25,910 --> 00:37:28,430
十个范围内或某个更小的范围内您

984
00:37:28,430 --> 00:37:30,220
知道我们将要写入的插槽

985
00:37:30,220 --> 00:37:34,700
所以让我们在第二个 B 中看到我们有这个

986
00:37:34,700 --> 00:37:35,810


987
00:37:35,810 --> 00:37:37,940
拥有快速

988
00:37:37,940 --> 00:37:39,560
散列算法和拥有低冲突率的散列算法之间的争论，

989
00:37:39,560 --> 00:37:41,900
因为我们想

990
00:37:41,900 --> 00:37:43,370
确保如果我们采用两个不同的键，

991
00:37:43,370 --> 00:37:46,010
我们不希望它们散列

992
00:37:46,010 --> 00:37:47,780
到相同的位置，但我们 希望

993
00:37:47,780 --> 00:37:49,870
能够非常快速地计算该散列

994
00:37:49,870 --> 00:37:52,310
第二个设计决策是

995
00:37:52,310 --> 00:37:53,630
散列方案，这基本上是说

996
00:37:53,630 --> 00:37:55,190
，在您完成散列之后，如果

997
00:37:55,190 --> 00:37:57,320
现在您有两个散列到

998
00:37:57,320 --> 00:37:58,580
同一位置的键，这意味着您在该位置上发生了

999
00:37:58,580 --> 00:38:01,100
冲突 关键你

1000
00:38:01,100 --> 00:38:03,170
实际上如何处理这个问题，所以

1001
00:38:03,170 --> 00:38:05,780
在

1002
00:38:05,780 --> 00:38:07,580
为哈希表分配大量内存之间进行权衡，以便

1003
00:38:07,580 --> 00:38:10,280
每个可能的缓存 PI 都看到它

1004
00:38:10,280 --> 00:38:11,930
保证不会与任何其他键发生冲突，

1005
00:38:11,930 --> 00:38:15,350
但这会花费很多时间 f 内存

1006
00:38:15,350 --> 00:38:18,350
，所以如果我想支持冲突，我

1007
00:38:18,350 --> 00:38:21,220
想让我的冲突协调，

1008
00:38:21,220 --> 00:38:24,650
你知道方法或程序

1009
00:38:24,650 --> 00:38:26,360
尽可能高效，所以我不

1010
00:38:26,360 --> 00:38:27,350
知道我没有花费大量的

1011
00:38:27,350 --> 00:38:28,970
计算时间来查找或插入一个新的

1012
00:38:28,970 --> 00:38:32,060
密钥 我们将再次介绍

1013
00:38:32,060 --> 00:38:35,720
可能想要的每一个我会说虽然

1014
00:38:35,720 --> 00:38:36,770
我将介绍一堆不同的

1015
00:38:36,770 --> 00:38:38,480
方法来处理散列表或散列

1016
00:38:38,480 --> 00:38:40,850
函数

1017
00:38:40,850 --> 00:38:42,110
我曾经与每家公司交谈过的每个数据库系统

1018
00:38:42,110 --> 00:38:46,400
都与他们交谈过 通常只

1019
00:38:46,400 --> 00:38:48,650
选择一个他们会有他们

1020
00:38:48,650 --> 00:38:50,090
选择它的原因，就像我们运行了一些基准测试

1021
00:38:50,090 --> 00:38:51,710
，看起来你知道似乎工作得

1022
00:38:51,710 --> 00:38:54,590
很好，尽管在某些情况下，

1023
00:38:54,590 --> 00:38:56,030


1024
00:38:56,030 --> 00:38:56,990
对于不同查询类型的不同工作负载，某些

1025
00:38:56,990 --> 00:38:59,540
散列方案可能更好 据我所知，

1026
00:38:59,540 --> 00:39:01,310
实际上是尝试自适应每个人

1027
00:39:01,310 --> 00:39:03,170
都会选择一个哈希表或一个哈希

1028
00:39:03,170 --> 00:39:05,270
函数，并试图使其

1029
00:39:05,270 --> 00:39:06,760
尽可能高效，他们不会尝试

1030
00:39:06,760 --> 00:39:09,560
自动调整哈希

1031
00:39:09,560 --> 00:39:11,570
方案 你使用的是基于查询

1032
00:39:11,570 --> 00:39:12,830
的数据集看起来每个人都只是

1033
00:39:12,830 --> 00:39:15,800
选择一个并运行它，

1034
00:39:15,800 --> 00:39:18,050
所以对于哈希函数

1035
00:39:18,050 --> 00:39:19,190
，我们的想法是我们想要获取

1036
00:39:19,190 --> 00:39:21,800
任何可能长度的任意键一个

1037
00:39:21,800 --> 00:39:24,890
不可能的域，然后 将它映射到一个

1038
00:39:24,890 --> 00:39:26,840
较小的域，然后我们就可以知道

1039
00:39:26,840 --> 00:39:28,490
使用它在我们的哈希表中找到一个位置，

1040
00:39:28,490 --> 00:39:31,580
这意味着尽管那些

1041
00:39:31,580 --> 00:39:32,810


1042
00:39:32,810 --> 00:39:34,340
提供安全性的

1043
00:39:34,340 --> 00:39:36,680
哈希函数保证了加密哈希函数或双向

1044
00:39:36,680 --> 00:39:37,820
哈希函数，就像我可以 加密

1045
00:39:37,820 --> 00:39:39,560
一些东西并解密它我们不

1046
00:39:39,560 --> 00:39:41,570
关心任何我们关心的权利我们关心的

1047
00:39:41,570 --> 00:39:43,280
是有一个有效的单向

1048
00:39:43,280 --> 00:39:46,970
散列和本地生成

1049
00:39:46,970 --> 00:39:48,800
我们将在下一张幻灯片中看到一些例子

1050
00:39:48,800 --> 00:39:49,730


1051
00:39:49,730 --> 00:39:53,210
所以最好的方法 要理解

1052
00:39:53,210 --> 00:39:54,500
冲突和性能之间的这种权衡，请

1053
00:39:54,500 --> 00:39:57,580
考虑两个极端，

1054
00:39:57,580 --> 00:40:00,470
因此您可以拥有的最快的哈希函数

1055
00:40:00,470 --> 00:40:02,780
是无论

1056
00:40:02,780 --> 00:40:04,910
您给它什么键，您总是返回

1057
00:40:04,910 --> 00:40:07,670
一个正确的值，即 li  ke

1058
00:40:07,670 --> 00:40:09,440
那里没有计算它只是你

1059
00:40:09,440 --> 00:40:11,930
知道写一个给工作人员或

1060
00:40:11,930 --> 00:40:14,090
函数的输出然后你就

1061
00:40:14,090 --> 00:40:16,040
完成了但这当然意味着

1062
00:40:16,040 --> 00:40:17,180
碰撞率可能很糟糕因为

1063
00:40:17,180 --> 00:40:18,740
无论我给它什么键它总是会

1064
00:40:18,740 --> 00:40:21,440
出现 返回值 1，所以它非常

1065
00:40:21,440 --> 00:40:22,670
高效，但我的碰撞

1066
00:40:22,670 --> 00:40:25,400
率在频谱的

1067
00:40:25,400 --> 00:40:27,800


1068
00:40:27,800 --> 00:40:30,590


1069
00:40:30,590 --> 00:40:33,860


1070
00:40:33,860 --> 00:40:35,930
另一端很糟糕 一个唯一的

1071
00:40:35,930 --> 00:40:39,800
散列键，所以这些在

1072
00:40:39,800 --> 00:40:41,630
文献中或理论上存在于实践中，

1073
00:40:41,630 --> 00:40:43,370
没有人真正实现它们，因为

1074
00:40:43,370 --> 00:40:44,420
通常你实际实现它们的方式

1075
00:40:44,420 --> 00:40:46,490
是你需要提前知道所有的键

1076
00:40:46,490 --> 00:40:50,960
，然后你会

1077
00:40:50,960 --> 00:40:53,690
用它来构建它 映射函数

1078
00:40:53,690 --> 00:40:57,410
本身带有一个哈希表，因此您

1079
00:40:57,410 --> 00:40:58,880
需要一个哈希表才能

1080
00:40:58,880 --> 00:41:01,610
拥有一个哈希表，这有点违背

1081
00:41:01,610 --> 00:41:02,840
让您

1082
00:41:02,840 --> 00:41:06,050
再次了解有效哈希表的目的 这是

1083
00:41:06,050 --> 00:41:07,790
我们想要

1084
00:41:07,790 --> 00:41:13,460
介于两者之间的两个极端，所以你知道这是一种

1085
00:41:13,460 --> 00:41:16,040
活跃的开发领域，适用于

1086
00:41:16,040 --> 00:41:20,210
研究、公司和初创公司

1087
00:41:20,210 --> 00:41:22,670
以及一般的黑客，所以

1088
00:41:22,670 --> 00:41:24,380
有这个由

1089
00:41:24,380 --> 00:41:27,380
murmur to hash 的人创建的基准，称之为 SM hasher

1090
00:41:27,380 --> 00:41:29,270
这是一种基准测试套件，

1091
00:41:29,270 --> 00:41:30,710
可以通过测量来确定

1092
00:41:30,710 --> 00:41:32,570
一堆散列函数的性能和冲突率，

1093
00:41:32,570 --> 00:41:33,740
所以如果你

1094
00:41:33,740 --> 00:41:35,540
对这类东西感兴趣，你可以

1095
00:41:35,540 --> 00:41:38,030
去看看他的博客或游戏页面

1096
00:41:38,030 --> 00:41:41,590
，但我想要 快速关注

1097
00:41:41,590 --> 00:41:44,240
您在野外经常看到的五种高级哈希

1098
00:41:44,240 --> 00:41:46,960
函数

1099
00:41:46,960 --> 00:41:49,070
CRC 最初是在 1970 年代开发的，

1100
00:41:49,070 --> 00:41:52,360
用于在网络中进行错误代码检测

1101
00:41:52,360 --> 00:41:56,900
现在在现代 CPU

1102
00:41:56,900 --> 00:41:58,760
上有内置指令来

1103
00:41:58,760 --> 00:42:02,360
执行 CRC 有效地 我认为在

1104
00:42:02,360 --> 00:42:03,530
幻灯片中 我将展示下一张幻灯片

1105
00:42:03,530 --> 00:42:04,250
我不认为我实际上在使用这些

1106
00:42:04,250 --> 00:42:05,420
说明 我很确定

1107
00:42:05,420 --> 00:42:08,390
我不是这样 如果你只使用算法

1108
00:42:08,390 --> 00:42:10,730
你会得到一个软件基础 ed here 我看到它

1109
00:42:10,730 --> 00:42:11,960
会很慢你使用

1110
00:42:11,960 --> 00:42:15,080
说明它会跑得更快杂音散列

1111
00:42:15,080 --> 00:42:17,510
是互联网上这个随机的家伙他

1112
00:42:17,510 --> 00:42:19,160
说嘿这是我开发的这个散列函数

1113
00:42:19,160 --> 00:42:21,800
，它是通用的，

1114
00:42:21,800 --> 00:42:24,470
而且速度很快，一群人似乎

1115
00:42:24,470 --> 00:42:26,300
喜欢它，他们拿起它并

1116
00:42:26,300 --> 00:42:29,330
对其进行了扩展或修改

1117
00:42:29,330 --> 00:42:32,660
，特别是 Google City 哈希

1118
00:42:32,660 --> 00:42:34,190
是基于成员哈希的，但

1119
00:42:34,190 --> 00:42:35,390
他们为自己的环境设计了它

1120
00:42:35,390 --> 00:42:37,580
，他们希望

1121
00:42:37,580 --> 00:42:39,820
对短键进行有效的哈希处理

1122
00:42:39,820 --> 00:42:42,350
Facebook xx 哈希值现在被

1123
00:42:42,350 --> 00:42:43,730
认为是最先进

1124
00:42:43,730 --> 00:42:45,860
的 我这是来自 Facebook 的同一个人，

1125
00:42:45,860 --> 00:42:47,810


1126
00:42:47,810 --> 00:42:52,270
压缩的顽固标准再次这样做

1127
00:42:52,270 --> 00:42:54,620
，只是你知道

1128
00:42:54,620 --> 00:42:57,020
所用方法的数学变化

1129
00:42:57,020 --> 00:42:58,850
在成员散列中，然后农场散列

1130
00:42:58,850 --> 00:43:01,400
是城市散列的较新版本，

1131
00:43:01,400 --> 00:43:02,900
旨在为较大的密钥提供更好的冲突率

1132
00:43:02,900 --> 00:43:07,940
，因此在 2016 年

1133
00:43:07,940 --> 00:43:11,300
也有来自 Google 的高速公路散列，但

1134
00:43:11,300 --> 00:43:16,190
t 对某种加密有类似的保证，

1135
00:43:16,190 --> 00:43:17,300
你知道密码

1136
00:43:17,300 --> 00:43:19,130
分析，你不能

1137
00:43:19,130 --> 00:43:22,670
再次从散列函数中泄漏任何数据我们

1138
00:43:22,670 --> 00:43:24,110
不关心散列表中的数据，

1139
00:43:24,110 --> 00:43:26,750
因为我们正在使用这个散列

1140
00:43:26,750 --> 00:43:28,100
函数 在内部，它没有暴露

1141
00:43:28,100 --> 00:43:31,430
给外部世界，所以这

1142
00:43:31,430 --> 00:43:34,760
只是我每年运行的一个基准测试，

1143
00:43:34,760 --> 00:43:37,580
它不是 SM 散列器，它是一种

1144
00:43:37,580 --> 00:43:39,350
不同类型的工作负载，我们只是

1145
00:43:39,350 --> 00:43:40,400
试图衡量

1146
00:43:40,400 --> 00:43:42,530
这些不同的散列函数的吞吐率

1147
00:43:42,530 --> 00:43:43,100


1148
00:43:43,100 --> 00:43:45,440
所以再次 CRC 64 我认为这只是所有

1149
00:43:45,440 --> 00:43:47,210
基于软件的实际上我应该重写

1150
00:43:47,210 --> 00:43:49,120
它以使用港口指令

1151
00:43:49,120 --> 00:43:51,290
但这里的主要内容是

1152
00:43:51,290 --> 00:43:52,790
你会看到的一个常见的常见事情是

1153
00:43:52,790 --> 00:43:56,690
你的密钥大小为 32 或 64 64

1154
00:43:56,690 --> 00:44:00,830
它是 30 32 和 64 字节的位，你

1155
00:44:00,830 --> 00:44:03,320
看不到像超大键，这

1156
00:44:03,320 --> 00:44:05,570
只是表明

1157
00:44:05,570 --> 00:44:08,780
如果你有

1158
00:44:08,780 --> 00:44:11,450
与缓存行对齐的键大小，那么这些

1159
00:44:11,450 --> 00:44:12,800
算法可以更有效地形成

1160
00:44:12,800 --> 00:44:14,540


1161
00:44:14,540 --> 00:44:15,560


1162
00:44:15,560 --> 00:44:17,540


1163
00:44:17,540 --> 00:44:19,490


1164
00:44:19,490 --> 00:44:21,140


1165
00:44:21,140 --> 00:44:23,210


1166
00:44:23,210 --> 00:44:26,030


1167
00:44:26,030 --> 00:44:27,860


1168
00:44:27,860 --> 00:44:29,330


1169
00:44:29,330 --> 00:44:30,500


1170
00:44:30,500 --> 00:44:33,410


1171
00:44:33,410 --> 00:44:35,930


1172
00:44:35,930 --> 00:44:38,480


1173
00:44:38,480 --> 00:44:39,140


1174
00:44:39,140 --> 00:44:40,760


1175
00:44:40,760 --> 00:44:45,740


1176
00:44:45,740 --> 00:44:48,440


1177
00:44:48,440 --> 00:44:50,870


1178
00:44:50,870 --> 00:44:53,030


1179
00:44:53,030 --> 00:44:54,710


1180
00:44:54,710 --> 00:44:57,020


1181
00:44:57,020 --> 00:44:59,180


1182
00:44:59,180 --> 00:45:01,910


1183
00:45:01,910 --> 00:45:04,940


1184
00:45:04,940 --> 00:45:08,000


1185
00:45:08,000 --> 00:45:10,850


1186
00:45:10,850 --> 00:45:13,460
所以模式的盐分是当你开始通过下一个缓存行时，你会付出代价，所以这里的主要结论是 XX 哈希 3 被认为是最快的，然后是城市有一些农场哈希 我认为这是 murmur hash 3 的旧版本 我认为可能会有一个更新的版本，它会表现得更好，但在我们自己的系统中，我们再次使用多余的哈希 3，因为该引脚决定了事情是这表明它好得多所以让我们现在再次讨论散列方案，散列方案是我们处理冲突的方式，因此我们的散列函数说这个键应该散列到我们数据结构中的这个桶或这个槽，还有一些东西在那里我们如何正确处理它所以怎么了好的所以我会说 - 除了链散列之外，这些也是大多数情况下的静态散列方案，这意味着我要调整散列的大小 能够在我实际

1187
00:45:13,460 --> 00:45:14,690
对它做任何事情之前，所以我有一个

1188
00:45:14,690 --> 00:45:17,150
粗略的近似值，我

1189
00:45:17,150 --> 00:45:19,520
将不得不在我的哈希泵或

1190
00:45:19,520 --> 00:45:23,270
哈希表中存储多少个键，如果现在我有一个

1191
00:45:23,270 --> 00:45:24,440
我无法协调的冲突，因为

1192
00:45:24,440 --> 00:45:26,060
没有 基于我使用的协议的可用空间

1193
00:45:26,060 --> 00:45:28,160
然后我必须调整它的大小，而

1194
00:45:28,160 --> 00:45:29,540
你通常调整它的方式只是

1195
00:45:29,540 --> 00:45:32,000
你将大小加倍

1196
00:45:32,000 --> 00:45:33,710
并重新散列所有内容并将其放回链

1197
00:45:33,710 --> 00:45:35,600
散列中你可以扩展

1198
00:45:35,600 --> 00:45:36,790
我的散列链 将无限期地显示在下一张幻灯片中

1199
00:45:36,790 --> 00:45:39,050
，但是这会

1200
00:45:39,050 --> 00:45:42,380
在您进行查找时询问何时扫描，

1201
00:45:42,380 --> 00:45:44,390
如果所有内容都散列

1202
00:45:44,390 --> 00:45:48,470
到同一链，那么

1203
00:45:48,470 --> 00:45:49,790
人们在考虑

1204
00:45:49,790 --> 00:45:51,110
散列表时会考虑链散列表，我认为这就是

1205
00:45:51,110 --> 00:45:54,350
当你说你想要一个哈希映射类时，你进入了 Java

1206
00:45:54,350 --> 00:45:57,110
并且这个想法是

1207
00:45:57,110 --> 00:46:01,100
有一个指向链的指针数组

1208
00:46:01,100 --> 00:46:04,400
，我把我的密钥散列它

1209
00:46:04,400 --> 00:46:06,320
告诉我我想

1210
00:46:06,320 --> 00:46:11,420
在我的链中查看什么偏移量 然后我就可以直接

1211
00:46:11,420 --> 00:46:14,900
跳到那个位置 d

1212
00:46:14,900 --> 00:46:16,370
所以我们解决冲突的方法是

1213
00:46:16,370 --> 00:46:19,520
，如果两个键映射到同一个链，

1214
00:46:19,520 --> 00:46:21,410
我们只需将它们分类到同一个

1215
00:46:21,410 --> 00:46:24,440
桶中，如果我的桶满了，那么我

1216
00:46:24,440 --> 00:46:26,180
就扩展它分配一个新的桶，然后

1217
00:46:26,180 --> 00:46:28,550
我添加 到我的链表，所以

1218
00:46:28,550 --> 00:46:29,190
链可以

1219
00:46:29,190 --> 00:46:31,890
无限增长，如果所有东西都

1220
00:46:31,890 --> 00:46:33,780
在同一位置散列，那么做任何外观

1221
00:46:33,780 --> 00:46:38,700
的野人都可以扫描，所以让我们

1222
00:46:38,700 --> 00:46:40,800
看一个简单的例子，所以

1223
00:46:40,800 --> 00:46:42,210
现在忽略这个，但就像这里是我们的桶一样

1224
00:46:42,210 --> 00:46:44,069
，所以在 每个桶我们有两个

1225
00:46:44,069 --> 00:46:46,890
槽所以我拿我的第一个键我要

1226
00:46:46,890 --> 00:46:50,640
散列它它会匹配这个

1227
00:46:50,640 --> 00:46:53,400
桶这里这个桶是空的所以我

1228
00:46:53,400 --> 00:46:56,160
可以将我的密钥插入第一个槽所以

1229
00:46:56,160 --> 00:46:57,450
这里要指出的

1230
00:46:57,450 --> 00:47:00,720
是 我们想要存储密钥的散列

1231
00:47:00,720 --> 00:47:03,510
以及原始密钥，

1232
00:47:03,510 --> 00:47:04,470
我们想要存储散列

1233
00:47:04,470 --> 00:47:05,849
的原因是因为现在如果我们要进行

1234
00:47:05,849 --> 00:47:09,480
比较以查看是否存在，如果我们

1235
00:47:09,480 --> 00:47:11,190
已经有了散列，我们可以

1236
00:47:11,190 --> 00:47:12,480
仅用整数快速进行比较，

1237
00:47:12,480 --> 00:47:14,250
但如果 这个键就像一个

1238
00:47:14,250 --> 00:47:16,560
条形图或更大的东西，那么我们

1239
00:47:16,560 --> 00:47:17,880
显然需要确保这个

1240
00:47:17,880 --> 00:47:19,619
东西我们有这个原始键，这样我们

1241
00:47:19,619 --> 00:47:21,240
就可以确定哪些人是误报，

1242
00:47:21,240 --> 00:47:23,609
但我们也保留这个，

1243
00:47:23,609 --> 00:47:25,500
以便我们可以做更多的查找

1244
00:47:25,500 --> 00:47:28,349
有效所以 a 到这里我们可以

1245
00:47:28,349 --> 00:47:32,490
写入第一个位置 BB 到这里我

1246
00:47:32,490 --> 00:47:35,790
可以写入那个位置 C 到这里

1247
00:47:35,790 --> 00:47:37,619
正确匹配同一个桶这个槽

1248
00:47:37,619 --> 00:47:39,869
是空的所以可以写入那里但是现在

1249
00:47:39,869 --> 00:47:42,540
D 想要写入这个桶

1250
00:47:42,540 --> 00:47:44,640
但是 两个槽已满，所以我们

1251
00:47:44,640 --> 00:47:47,640
现在需要做的就是分配一个新的存储桶，在链表中添加一个

1252
00:47:47,640 --> 00:47:49,020
从第一个存储桶到

1253
00:47:49,020 --> 00:47:51,150
第二个存储桶的指针，现在

1254
00:47:51,150 --> 00:47:54,150
我们可以为 E 添加相同的东西，这个

1255
00:47:54,150 --> 00:47:55,800
存储桶已满，我们遵循链表

1256
00:47:55,800 --> 00:47:58,560
去这里，现在我们可以写 E，然后

1257
00:47:58,560 --> 00:48:01,109
F 被写在这里，所以现在如果

1258
00:48:01,109 --> 00:48:04,170
我想做一个查找，说找到我的关键

1259
00:48:04,170 --> 00:48:06,839
DD 会散列到这个桶我

1260
00:48:06,839 --> 00:48:08,369
会在桶内进行顺序扫描，

1261
00:48:08,369 --> 00:48:09,619
查看每一个 键

1262
00:48:09,619 --> 00:48:11,579
通常是你做的 首先散列因为

1263
00:48:11,579 --> 00:48:14,339
如果我没有

1264
00:48:14,339 --> 00:48:17,069
找到匹配项会更有效率然后我知道我需要并且

1265
00:48:17,069 --> 00:48:18,540
如果

1266
00:48:18,540 --> 00:48:19,619
我在我所在的桶中没有找到匹配项并且

1267
00:48:19,619 --> 00:48:21,270
在下一个桶中有一个指向它的指针 他们

1268
00:48:21,270 --> 00:48:22,349
不需要跳过这里并

1269
00:48:22,349 --> 00:48:24,710
继续我的特殊扫描，

1270
00:48:24,710 --> 00:48:27,030
因此您

1271
00:48:27,030 --> 00:48:31,079
可以对插槽数组进行一项有趣的优化，而不是

1272
00:48:31,079 --> 00:48:34,079
将它们作为 64 位指针抛出，或者您

1273
00:48:34,079 --> 00:48:36,060
将存储指针存储在 64 位，

1274
00:48:36,060 --> 00:48:37,920
因为这就是英特尔硬件所说的

1275
00:48:37,920 --> 00:48:40,140
你必须这样做，但英特尔的行动

1276
00:48:40,140 --> 00:48:41,730
不会为每个你知道的地址使用所有 64 位，

1277
00:48:41,730 --> 00:48:42,660
你知道实际上

1278
00:48:42,660 --> 00:48:45,660
使用 48 位，所以在超级的情况下，

1279
00:48:45,660 --> 00:48:47,760
他们所做的是他们实际上存储

1280
00:48:47,760 --> 00:48:51,210
所有这些指针，他们存储一个位图

1281
00:48:51,210 --> 00:48:53,460
我很抱歉 布隆过滤器说

1282
00:48:53,460 --> 00:48:56,400
这是我的链中存在的所有键，

1283
00:48:56,400 --> 00:48:59,520
所以现在我可以做的是当我做

1284
00:48:59,520 --> 00:49:01,800
一个散列，我说我应该去这个

1285
00:49:01,800 --> 00:49:03,780
桶，我看着这个点

1286
00:49:03,780 --> 00:49:06,120
告诉我我需要去那里

1287
00:49:06,120 --> 00:49:07,530
实际上将成为其中的布隆过滤

1288
00:49:07,530 --> 00:49:10,800
器，然后我们检查

1289
00:49:10,800 --> 00:49:12,330
是否 我正在寻找的键实际上

1290
00:49:12,330 --> 00:49:13,800
会存在于我的蓝色页脚中，

1291
00:49:13,800 --> 00:49:15,570
因为布隆过滤器会给你它不会

1292
00:49:15,570 --> 00:49:16,740
给你假阴性但它可能

1293
00:49:16,740 --> 00:49:18,090
会给我假阳性所以可以告诉

1294
00:49:18,090 --> 00:49:20,130
你这个键存在，什么时候它实际上

1295
00:49:20,130 --> 00:49:21,570
不存在 你必须去扫描并找到它

1296
00:49:21,570 --> 00:49:23,700
只是为了看到它不存在但如果

1297
00:49:23,700 --> 00:49:25,710
它不存在于你的密钥中那么这个

1298
00:49:25,710 --> 00:49:27,240
东西将保证说它

1299
00:49:27,240 --> 00:49:28,590
不存在所以你实际上

1300
00:49:28,590 --> 00:49:30,600
不需要遵循 链你只需要

1301
00:49:30,600 --> 00:49:34,440
看看这个布隆过滤器，所以我认为出于

1302
00:49:34,440 --> 00:49:36,660
这个原因，超级家伙说如果你使用这个技巧

1303
00:49:36,660 --> 00:49:40,050
，哈希链哈希表将与所有其他哈希表对等，

1304
00:49:40,050 --> 00:49:42,360


1305
00:49:42,360 --> 00:49:45,290
但问题是虽然我

1306
00:49:45,290 --> 00:49:48,210
可以同意 问题在于

1307
00:49:48,210 --> 00:49:51,870
，英特尔不能保证将来

1308
00:49:51,870 --> 00:49:54,330
所有指针只使用 60 48 位

1309
00:49:54,330 --> 00:49:56,790
对，有些晚了

1310
00:49:56,790 --> 00:49:58,470
可能会说现在使用所有 64 位都很好

1311
00:49:58,470 --> 00:50:00,600
，然后这件事不起作用，

1312
00:50:00,600 --> 00:50:02,340
所以也许他们可以 存储 16

1313
00:50:02,340 --> 00:50:05,760
位布隆过滤器并把它拍出来

1314
00:50:05,760 --> 00:50:07,380
就像我们在 Judea Ray 上看到的 Judi 胖指针一样，

1315
00:50:07,380 --> 00:50:09,090
您可以将

1316
00:50:09,090 --> 00:50:14,480
其存储在槽数组中，

1317
00:50:14,480 --> 00:50:18,300
所以链散列

1318
00:50:18,300 --> 00:50:20,190
在数据库系统中用于连接的数据结构中非常常见，

1319
00:50:20,190 --> 00:50:22,560
尽管大多数时候您会

1320
00:50:22,560 --> 00:50:26,310
看到一个线性探针散列表 因为

1321
00:50:26,310 --> 00:50:28,050
它非常简单而且最终

1322
00:50:28,050 --> 00:50:30,330
会变得更高效，所以使用更精简的探针哈希

1323
00:50:30,330 --> 00:50:32,520
表，我认为这是一个巨大的

1324
00:50:32,520 --> 00:50:36,210
插槽表，我将散列我的密钥，我

1325
00:50:36,210 --> 00:50:37,710
将根据我拥有的插槽数量对其进行修改

1326
00:50:37,710 --> 00:50:38,790
，那就是 当告诉我从哪里

1327
00:50:38,790 --> 00:50:40,920
跳转以找到我想要的插槽的内存地址时，

1328
00:50:40,920 --> 00:50:43,290
当我想要

1329
00:50:43,290 --> 00:50:45,090
插入时，如果该插槽中不存在任何内容，

1330
00:50:45,090 --> 00:50:46,380
那么我可以继续写入

1331
00:50:46,380 --> 00:50:48,960
它，如果确实存在，那么我

1332
00:50:48,960 --> 00:50:52,950
需要扫描

1333
00:50:52,950 --> 00:50:54,660
从该插槽位置从顶部到底部，然后

1334
00:50:54,660 --> 00:50:56,500
查看所有 slauson 的妻子

1335
00:50:56,500 --> 00:50:58,900
是空的，然后我可以

1336
00:50:58,900 --> 00:51:01,810
继续将我的值插入其中，这

1337
00:51:01,810 --> 00:51:03,130
意味着当我想要进行查找

1338
00:51:03,130 --> 00:51:05,410
以找到我的 关键我要去屠杀

1339
00:51:05,410 --> 00:51:07,630
跳到那个 s 我的位置，我必须

1340
00:51:07,630 --> 00:51:08,980
开始寻找我正在寻找的密钥

1341
00:51:08,980 --> 00:51:11,320
是否真的在那里，

1342
00:51:11,320 --> 00:51:13,150
因为我不知道它

1343
00:51:13,150 --> 00:51:14,470
是否实际上不在一个插槽中，它应该

1344
00:51:14,470 --> 00:51:16,540
散列到它可能低于我需要的位置

1345
00:51:16,540 --> 00:51:18,100
扫描直到我找到它，

1346
00:51:18,100 --> 00:51:20,500
或者我找到空槽，它告诉

1347
00:51:20,500 --> 00:51:23,770
我密钥不存在所以这

1348
00:51:23,770 --> 00:51:26,050
看起来是一个例子确实再次说我

1349
00:51:26,050 --> 00:51:28,090
想把这些密钥放在这里第

1350
00:51:28,090 --> 00:51:30,100
一个我们散列我们通过数量修改 槽，

1351
00:51:30,100 --> 00:51:31,240
这告诉我们我们想写入

1352
00:51:31,240 --> 00:51:32,830
这里很好 那里已经没有什么了

1353
00:51:32,830 --> 00:51:34,840
我们可以继续做 现在我想

1354
00:51:34,840 --> 00:51:37,060
在 BI 上做散列 可以写这个槽

1355
00:51:37,060 --> 00:51:39,490
什么都没有 所以我们现在完成了 我

1356
00:51:39,490 --> 00:51:42,190
想做一个 将 CC 哈希插入到此

1357
00:51:42,190 --> 00:51:45,010
插槽位置，但一个已经存在，所以我

1358
00:51:45,010 --> 00:51:47,230
无法将其存储在这里我要将它存储

1359
00:51:47,230 --> 00:51:49,900
在下一个空插槽中

1360
00:51:49,900 --> 00:51:52,570


1361
00:51:52,570 --> 00:51:54,610
在 CI 上查找会

1362
00:51:54,610 --> 00:51:57,970
在这里孵化出 C a 并且我会看到密钥 a

1363
00:51:57,970 --> 00:51:59,410
这不是我正在寻找的那个，

1364
00:51:59,410 --> 00:52:02,500
所以我 s 可以一直向下直到我找到

1365
00:52:02,500 --> 00:52:04,180
一个空槽或我想要的键，在

1366
00:52:04,180 --> 00:52:06,010
这种情况下，我会

1367
00:52:06,010 --> 00:52:09,490
在下一个位置看到，现在在这个位置再次使用 DD 哈希，

1368
00:52:09,490 --> 00:52:11,080
我们无法将它

1369
00:52:11,080 --> 00:52:13,060
写入，因为 C 在这里是两个，所以

1370
00:52:13,060 --> 00:52:15,070
我们写在他想写的

1371
00:52:15,070 --> 00:52:16,810
下一个我们不能写下一个

1372
00:52:16,810 --> 00:52:18,160
我们不能写下一个凯伦

1373
00:52:18,160 --> 00:52:19,360
做下一个并继续前进直到我们找到

1374
00:52:19,360 --> 00:52:22,810
像那个空位F就像

1375
00:52:22,810 --> 00:52:24,040
Wright State一样 在这里，但它

1376
00:52:24,040 --> 00:52:27,540
不能因此转到下一个，因此

1377
00:52:27,540 --> 00:52:30,070
您必须跟踪的事情

1378
00:52:30,070 --> 00:52:34,120
是，如果我进行查找或插入，我

1379
00:52:34,120 --> 00:52:35,950
需要跟踪我

1380
00:52:35,950 --> 00:52:37,570
在 for 的插槽数组中的起始位置 这张

1381
00:52:37,570 --> 00:52:39,510
表是因为如果我回过头来

1382
00:52:39,510 --> 00:52:41,770
试图找到我正在寻找的东西

1383
00:52:41,770 --> 00:52:44,140
或空槽，然后我又回到

1384
00:52:44,140 --> 00:52:46,360
我的起点，那么我知道我的哈希

1385
00:52:46,360 --> 00:52:48,310
表已满，没有更多的空闲

1386
00:52:48,310 --> 00:52:49,720
空间可供我插入一些东西

1387
00:52:49,720 --> 00:52:51,940
好吧，我正在寻找的钥匙不在

1388
00:52:51,940 --> 00:52:55,300
那里，然后我必须再次重新整理

1389
00:52:55,300 --> 00:52:57,190
所有内容，然后做 将大小加倍或

1390
00:52:57,190 --> 00:52:58,900
内置哈希表 将大小加倍并

1391
00:52:58,900 --> 00:53:00,970
重新散列所有内容，因此再次尝试

1392
00:53:00,970 --> 00:53:02,830
选择正确的哈希表大小可能

1393
00:53:02,830 --> 00:53:04,930
会很棘手，我们将在更多

1394
00:53:04,930 --> 00:53:07,000
讲座中看到如果您不知道这将如何成为问题

1395
00:53:07,000 --> 00:53:08,170
if 你

1396
00:53:08,170 --> 00:53:10,710
在第一个中没有正确估计

1397
00:53:10,710 --> 00:53:14,440
事情所以关于这个数据结构的另一个有趣的事情

1398
00:53:14,440 --> 00:53:15,579
我们将

1399
00:53:15,579 --> 00:53:19,380
在下一张幻灯片中看到一些变化是

1400
00:53:19,380 --> 00:53:23,230
它会惩罚碰撞

1401
00:53:23,230 --> 00:53:24,550
方案，而碰撞方案将同时惩罚

1402
00:53:24,550 --> 00:53:29,109
插入和查找 同样的方式，所以

1403
00:53:29,109 --> 00:53:31,569
在这里的情况下，我想

1404
00:53:31,569 --> 00:53:35,530
插入 E，

1405
00:53:35,530 --> 00:53:38,710
如果现在我想在 e 上进行查找，我必须跳到四个插槽中存储在这里，

1406
00:53:38,710 --> 00:53:40,359
我将支付

1407
00:53:40,359 --> 00:53:42,250
同样的罚款，因为我' 我要在这里散列

1408
00:53:42,250 --> 00:53:44,980
，我必须向下扫描，直到

1409
00:53:44,980 --> 00:53:46,089
找到我正在寻找的密钥的空槽，

1410
00:53:46,089 --> 00:53:48,190
所以在这个碰撞

1411
00:53:48,190 --> 00:53:50,369
方案或这个散列方案中没有任何东西

1412
00:53:50,369 --> 00:53:52,660
更喜欢使插入更快或

1413
00:53:52,660 --> 00:53:54,609
使不同的缓冲区使

1414
00:53:54,609 --> 00:54:01,950
查找更快 在散列连接中

1415
00:54:01,950 --> 00:54:07,000
确定

1416
00:54:07,000 --> 00:54:08,319
内部表的大小与平均值是否

1417
00:54:08,319 --> 00:54:10,930
取决于该比率，您可能想要

1418
00:54:10,930 --> 00:54:12,220
选择不同的碰撞方案，

1419
00:54:12,220 --> 00:54:14,260
如果外部表更大，则插入速度更快，

1420
00:54:14,260 --> 00:54:16,210
或者爱查找

1421
00:54:16,210 --> 00:54:20,260
速度更快，如果 内表更大，

1422
00:54:20,260 --> 00:54:21,849
但正如我所说，据我所知，大多数

1423
00:54:21,849 --> 00:54:24,280
能源系统不会切换，

1424
00:54:24,280 --> 00:54:26,290
它总是选择一种方案，而且

1425
00:54:26,290 --> 00:54:28,450
通常这是最简单的方案，

1426
00:54:28,450 --> 00:54:30,670
而且该功能很重要，这表明它的

1427
00:54:30,670 --> 00:54:36,730
性能最好 所以我们

1428
00:54:36,730 --> 00:54:38,290
已经讨论过这个你知道

1429
00:54:38,290 --> 00:54:39,579
为了减少

1430
00:54:39,579 --> 00:54:42,970
我们必须做的浪费比较的数量我们想要

1431
00:54:42,970 --> 00:54:44,920
避免哈希键上的冲突当然

1432
00:54:44,920 --> 00:54:46,780
这完全取决于我们

1433
00:54:46,780 --> 00:54:50,339
每个哈希函数的冲突率和

1434
00:54:50,339 --> 00:54:52,720
一种方式的好坏 完全避免它是我们

1435
00:54:52,720 --> 00:54:55,630
可以只拥有一个包含两个 EP 的巨大哈希表，

1436
00:54:55,630 --> 00:54:56,859
我们希望有许多插槽，

1437
00:54:56,859 --> 00:54:59,109
这样每次您对

1438
00:54:59,109 --> 00:55:01,470
密钥进行哈希处理并将其放入数据结构时，

1439
00:55:01,470 --> 00:55:03,579
它什么都不会发生

1440
00:55:03,579 --> 00:55:05,079
也在尝试写入的插槽中，

1441
00:55:05,079 --> 00:55:06,670
但您又要付出

1442
00:55:06,670 --> 00:55:08,230
为哈希表分配更多内存的代价，所以

1443
00:55:08,230 --> 00:55:10,540
我如何正确平衡这一点并非

1444
00:55:10,540 --> 00:55:14,079
微不足道，所以让我们看看

1445
00:55:14,079 --> 00:55:19,030
尝试切换的线性探针哈希的一些变体

1446
00:55:19,030 --> 00:55:21,460
通过改变碰撞方式来动态或切换

1447
00:55:21,460 --> 00:55:22,400
插入

1448
00:55:22,400 --> 00:55:25,550
和查找之间的惩罚

1449
00:55:25,550 --> 00:55:27,740
我们

1450
00:55:27,740 --> 00:55:30,770
将要使用的碰撞协议所以一种方法称为

1451
00:55:30,770 --> 00:55:32,450
罗宾汉散列，这里的想法是

1452
00:55:32,450 --> 00:55:36,680
，当我们进行插入时，如果

1453
00:55:36,680 --> 00:55:39,620
我们发现插槽 想要插入

1454
00:55:39,620 --> 00:55:42,980
已经被占用，那么我们看看

1455
00:55:42,980 --> 00:55:46,010


1456
00:55:46,010 --> 00:55:49,070
我们想要写入的插槽中存在的密钥是否离

1457
00:55:49,070 --> 00:55:52,130
它的主宰更远它不是它应该在的地方，

1458
00:55:52,130 --> 00:55:56,270
那么我们的密钥在哪里，

1459
00:55:56,270 --> 00:55:58,310
如果不是，那么 我们将窃取它的插槽

1460
00:55:58,310 --> 00:56:00,530
并强制它使用我们刚刚驱逐的其他密钥

1461
00:56:00,530 --> 00:56:02,930
去一个新的位置

1462
00:56:02,930 --> 00:56:04,880
所以它被称为罗宾汉哈希

1463
00:56:04,880 --> 00:56:05,900
因为我们的想法是我们

1464
00:56:05,900 --> 00:56:08,930
将从我们要

1465
00:56:08,930 --> 00:56:11,330
窃取的 Porky 窃取 富可 是的，并将

1466
00:56:11,330 --> 00:56:13,220
插槽分配给差劲的钥匙，这又一次，

1467
00:56:13,220 --> 00:56:16,370
钥匙的财富取决于

1468
00:56:16,370 --> 00:56:19,610
您距离

1469
00:56:19,610 --> 00:56:22,250
您的大位置的跳数 您的

1470
00:56:22,250 --> 00:56:23,740
位置选择位置您应该在桌子上的位置

1471
00:56:23,740 --> 00:56:27,740
好吧 这是一种古老的技术，

1472
00:56:27,740 --> 00:56:29,690
它实际上是在 1985 年的技术报告

1473
00:56:29,690 --> 00:56:34,490
中或在一份公共报纸中发表的，它

1474
00:56:34,490 --> 00:56:38,240
有点丢失或没有丢失，或者

1475
00:56:38,240 --> 00:56:40,190
直到最近几年才真正得到任何关注

1476
00:56:40,190 --> 00:56:42,770
，特别是这出现在

1477
00:56:42,770 --> 00:56:46,820
Hacker News a 几年前和现在

1478
00:56:46,820 --> 00:56:48,740
有点像这样 有一些

1479
00:56:48,740 --> 00:56:51,080
系统实际上在使用它，尽管我会

1480
00:56:51,080 --> 00:56:52,310
说研究表明这

1481
00:56:52,310 --> 00:56:54,070
实际上是一个坏主意，

1482
00:56:54,070 --> 00:56:56,660
因为您支付的罚款只是

1483
00:56:56,660 --> 00:57:00,410
复制和移动是昂贵的，

1484
00:57:00,410 --> 00:57:01,850
好吧，所以让我们说它是

1485
00:57:01,850 --> 00:57:03,830
我们希望再次拥有相同的皮肤密钥 Robin

1486
00:57:03,830 --> 00:57:05,840
散列是月球探测器散列的一种变体，

1487
00:57:05,840 --> 00:57:08,590
所以它只是一个巨大的插槽数组，

1488
00:57:08,590 --> 00:57:11,660
我们开始散列 a，

1489
00:57:11,660 --> 00:57:14,240
就像以前一样，但现在另外

1490
00:57:14,240 --> 00:57:15,470
只在原点绘制散列 al

1491
00:57:15,470 --> 00:57:18,410
key 我们还将存储

1492
00:57:18,410 --> 00:57:20,570
该键从其

1493
00:57:20,570 --> 00:57:22,700
最佳位置跳转的次数，最佳

1494
00:57:22,700 --> 00:57:24,440
位置由它

1495
00:57:24,440 --> 00:57:27,770
应该在的

1496
00:57:27,770 --> 00:57:29,690
位置或当我们正确执行初始哈希时跳转到的第一个位置决定

1497
00:57:29,690 --> 00:57:32,750
就像如果你正在

1498
00:57:32,750 --> 00:57:34,640
寻找这个键并使用这个散列

1499
00:57:34,640 --> 00:57:35,390
你的

1500
00:57:35,390 --> 00:57:37,940
散列函数在哪里你能立即找到它

1501
00:57:37,940 --> 00:57:39,260
假设没有任何

1502
00:57:39,260 --> 00:57:42,289
其他碰撞说他们现在会在

1503
00:57:42,289 --> 00:57:44,690
这里散列它位于这个

1504
00:57:44,690 --> 00:57:46,430
最佳位置所以它是跳数

1505
00:57:46,430 --> 00:57:47,930
远离它应该

1506
00:57:47,930 --> 00:57:51,500
是零的地方，但现在我们要散列 CC

1507
00:57:51,500 --> 00:57:52,849
会落在 a 所在的相同位置，

1508
00:57:52,849 --> 00:57:55,339
所以现在我们需要看看

1509
00:57:55,339 --> 00:57:58,339
我们是否应该驱逐

1510
00:57:58,339 --> 00:58:00,710
我们想要的插槽中的任何东西 进入或者我们应该

1511
00:58:00,710 --> 00:58:02,480
不理会它，然后

1512
00:58:02,480 --> 00:58:05,000
像线性程序一样跳到下一个槽，所以

1513
00:58:05,000 --> 00:58:09,380
这里的第一次跳转 a 是 a

1514
00:58:09,380 --> 00:58:12,140
离其最佳位置

1515
00:58:12,140 --> 00:58:14,690
零跳，而 C 是离其原始位置零跳，

1516
00:58:14,690 --> 00:58:17,960
所以 C 将留下一个人所有

1517
00:58:17,960 --> 00:58:19,039
ri  ght 因为它们被认为是

1518
00:58:19,039 --> 00:58:21,380
等价的 所以现在它会跳到

1519
00:58:21,380 --> 00:58:23,660
这里 这个翻牌是空的 所以现在我们将

1520
00:58:23,660 --> 00:58:25,339
C 存储在这里 所以现在这是

1521
00:58:25,339 --> 00:58:29,269
说 C 离它

1522
00:58:29,269 --> 00:58:32,809
原本应该存在的位置只有一跳 D 出现

1523
00:58:32,809 --> 00:58:34,670
了 这里 D 想去 C 所在的

1524
00:58:34,670 --> 00:58:39,380
位置 C 因为 a 的跳跃成本为 或

1525
00:58:39,380 --> 00:58:42,109
跳跃距离为 1 因此

1526
00:58:42,109 --> 00:58:45,079
对于 D 来说 1 大于 0 因为 D 的 D 是 0

1527
00:58:45,079 --> 00:58:46,940
步如果我们可以去这里所以在这种

1528
00:58:46,940 --> 00:58:49,940
情况下这里 C 是 被认为比 D 更穷，

1529
00:58:49,940 --> 00:58:54,500
所以 D 将不理会 C 然后我们

1530
00:58:54,500 --> 00:58:57,349
跳到这里我们写 D 现在我们

1531
00:58:57,349 --> 00:59:00,140
写 e egh 想要去 a 的地方你

1532
00:59:00,140 --> 00:59:03,589
不能这样做 aa 0 等于 e 0 所以

1533
00:59:03,589 --> 00:59:05,839
我们不理会它 然后我们来到这里

1534
00:59:05,839 --> 00:59:07,579
，此时 E 现在

1535
00:59:07,579 --> 00:59:09,710
离它应该在的地方只有一跳，但哦，C

1536
00:59:09,710 --> 00:59:11,029
也是如此，所以它们也是等价的，所以我们不理会

1537
00:59:11,029 --> 00:59:13,880
那些，但后来我们到了这里，现在

1538
00:59:13,880 --> 00:59:16,130
他离它应该有两跳了 应该

1539
00:59:16,130 --> 00:59:19,519
是，而且 D 距离只有一跳，所以 D

1540
00:59:19,519 --> 00:59:21,289
被认为比 e 更富有或更富有

1541
00:59:21,289 --> 00:59:26,029
，所以很容易插入它的钥匙

1542
00:59:26,029 --> 00:59:27,799
，然后现在 thr  ead 继续并

1543
00:59:27,799 --> 00:59:29,269
找出下一个放置 D 的位置，

1544
00:59:29,269 --> 00:59:31,400
这是下一个空槽，然后

1545
00:59:31,400 --> 00:59:34,039
现在 D 离

1546
00:59:34,039 --> 00:59:37,309
它应该在的位置两跳，然后现在我们到达 FF

1547
00:59:37,309 --> 00:59:39,609
去 D 所在的位置，但它不能做

1548
00:59:39,609 --> 00:59:42,440
所以然后它在这里下降 所以这里的

1549
00:59:42,440 --> 00:59:45,819
想法是我们正在摊销 ingush

1550
00:59:45,819 --> 00:59:49,230
窃取插槽并重新插入

1551
00:59:49,230 --> 00:59:51,450
表中已经存在的

1552
00:59:51,450 --> 00:59:53,750


1553
00:59:53,750 --> 00:59:58,880
密钥 通过让每个密钥

1554
00:59:58,880 --> 01:00:00,780
更接近它们的位置来摊销任何给定密钥的想法 本来应该

1555
01:00:00,780 --> 01:00:04,380
是这样的，所以

1556
01:00:04,380 --> 01:00:08,430
定期带着 e 回到这里 嗯 没

1557
01:00:08,430 --> 01:00:09,000
问题

1558
01:00:09,000 --> 01:00:11,430
II 它在这里结束了，你们

1559
01:00:11,430 --> 01:00:13,560
每个人都独自留在这儿，所以 II 会

1560
01:00:13,560 --> 01:00:15,750


1561
01:00:15,750 --> 01:00:17,550
离它原来的位置三三跳，而 D

1562
01:00:17,550 --> 01:00:19,470
会被留下 一跳就知道了，

1563
01:00:19,470 --> 01:00:22,320
但在罗宾汉上，

1564
01:00:22,320 --> 01:00:24,990
他们最终都相距两跳，所以

1565
01:00:24,990 --> 01:00:27,680
平均而言，你说谁

1566
01:00:27,680 --> 01:00:30,900
在所有键上的查找大致相同，

1567
01:00:30,900 --> 01:00:32,490
所以你没有一个你知道的键

1568
01:00:32,490 --> 01:00:36,170
比其他的长得多 所以

1569
01:00:36,170 --> 01:00:38,490
这似乎是一个不错的主意好吧，

1570
01:00:38,490 --> 01:00:39,570
看看这是否有趣，

1571
01:00:39,570 --> 01:00:40,980
但研究文献表明

1572
01:00:40,980 --> 01:00:45,450
这是不好的，因为这是窃取

1573
01:00:45,450 --> 01:00:48,990
密钥是可怕的，因为你知道缓存

1574
01:00:48,990 --> 01:00:52,829
性能，所以它使插入

1575
01:00:52,829 --> 01:00:54,569
变得更加昂贵，没有任何好处

1576
01:00:54,569 --> 01:00:58,319
您通过查找

1577
01:00:58,319 --> 01:01:00,240
使罚款速度更快现在完全

1578
01:01:00,240 --> 01:01:04,650
否定了哈希连接您知道

1579
01:01:04,650 --> 01:01:05,670
我们正在构建这些临时哈希

1580
01:01:05,670 --> 01:01:07,770
表，我们将它们插入其中进行我们的

1581
01:01:07,770 --> 01:01:09,750
探测，在账单阶段左右

1582
01:01:09,750 --> 01:01:12,540
，然后是专业阶段 如果您的

1583
01:01:12,540 --> 01:01:14,550
数据结构可能

1584
01:01:14,550 --> 01:01:16,440
像您构建哈希表那样寿命更长，然后

1585
01:01:16,440 --> 01:01:18,380
再继续进行查找，则将其扔掉，

1586
01:01:18,380 --> 01:01:20,670
那么这种方法实际上

1587
01:01:20,670 --> 01:01:23,220
可能更适合连接它不会

1588
01:01:23,220 --> 01:01:26,880
是另一种称为跳房子

1589
01:01:26,880 --> 01:01:29,609
散列的技术 2008 年从

1590
01:01:29,609 --> 01:01:32,670
Maurice Hurley 那里出来

1591
01:01:32,670 --> 01:01:34,050


1592
01:01:34,050 --> 01:01:37,550


1593
01:01:37,550 --> 01:01:41,970


1594
01:01:41,970 --> 01:01:45,359
键改变位置就像在

1595
01:01:45,359 --> 01:01:47,790
Robin Hood 中移动到

1596
01:01:47,790 --> 01:01:51,750
槽阵列中的任何可能位置，

1597
01:01:51,750 --> 01:01:54,480
我们将限制它们可以

1598
01:01:54,480 --> 01:01:57,300
进入所谓的邻域的距离，因此

1599
01:01:57,300 --> 01:01:59,490
邻域我们定义为

1600
01:01:59,490 --> 01:02:02,609
一个键所在的连续的槽范围

1601
01:02:02,609 --> 01:02:03,269
允许它

1602
01:02:03,269 --> 01:02:07,319
，它可以存在于该社区的任何地方，

1603
01:02:07,319 --> 01:02:08,729
因此如果您正在

1604
01:02:08,729 --> 01:02:10,319
寻找钥匙，并且您查看它

1605
01:02:10,319 --> 01:02:11,399
应该在该社区的位置，但它

1606
01:02:11,399 --> 01:02:12,779
不在那里，那么您就知道该钥匙不

1607
01:02:12,779 --> 01:02:15,659
存在，所以您 限制你实际上

1608
01:02:15,659 --> 01:02:19,979
必须扫描多远，所以

1609
01:02:19,979 --> 01:02:21,419
邻域的大小是可配置的我

1610
01:02:21,419 --> 01:02:24,869
忘记仪式论文说的是什么，但

1611
01:02:24,869 --> 01:02:26,640
在这个例子中，我们将使用

1612
01:02:26,640 --> 01:02:28,829
我们的邻域大小为 3 的密钥大小，

1613
01:02:28,829 --> 01:02:30,449
所以它只是线性探测，所以我们

1614
01:02:30,449 --> 01:02:33,029
我们没有我们的槽阵列，所以

1615
01:02:33,029 --> 01:02:34,140
这里第一个位置的第一个邻域

1616
01:02:34,140 --> 01:02:36,119
的大小是三，所以

1617
01:02:36,119 --> 01:02:36,989
一二三

1618
01:02:36,989 --> 01:02:38,759
但是邻域是重叠的，

1619
01:02:38,759 --> 01:02:40,769
所以对于下一个和下一个

1620
01:02:40,769 --> 01:02:43,259
等等，他们有 ap 选择

1621
01:02:43,259 --> 01:02:44,999
他们附近的前一个

1622
01:02:44,999 --> 01:02:47,099
街区，你会一直这样做

1623
01:02:47,099 --> 01:02:49,799
，所以现在假设我想

1624
01:02:49,799 --> 01:02:51,569
开始并开始插入这些键，

1625
01:02:51,569 --> 01:02:53,789
就像在我想要开始之前一样，

1626
01:02:53,789 --> 01:02:56,609
它会进入这里，它的邻居

1627
01:02:56,609 --> 01:02:58,559
是 三个三个插槽所以我可以将

1628
01:02:58,559 --> 01:03:00,539
它排序到任何我想要的地方并练习

1629
01:03:00,539 --> 01:03:01,769
虽然你刚刚将它插入到

1630
01:03:01,769 --> 01:03:03,299
第一个位置，如果它是空的，

1631
01:03:03,299 --> 01:03:05,969
我们完成了然后我们为 B 做一个插入，

1632
01:03:05,969 --> 01:03:07,529
我们去第一个

1633
01:03:07,529 --> 01:03:10,169
位置 这个街区，我们已经完成了，但

1634
01:03:10,169 --> 01:03:12,359
现在我们想从 CC 开始，应该去

1635
01:03:12,359 --> 01:03:13,769
a 所在的位置，但它可以，因为 a 正在

1636
01:03:13,769 --> 01:03:17,039
占用，所以我们说我们需要

1637
01:03:17,039 --> 01:03:20,189
在我们的邻居中找到下一个空位

1638
01:03:20,189 --> 01:03:23,429
插入进去，所以我们只是

1639
01:03:23,429 --> 01:03:25,019
现在做顺序扫描直到我们

1640
01:03:25,019 --> 01:03:26,399
找到空槽让我继续

1641
01:03:26,399 --> 01:03:29,069
为自己服务到目前为止这

1642
01:03:29,069 --> 01:03:32,069
与线性程序是一样的现在

1643
01:03:32,069 --> 01:03:33,479
我想开始DD你应该去

1644
01:03:33,479 --> 01:03:36,119
C反对紧缩的地方我们将扫描 我

1645
01:03:36,119 --> 01:03:37,699
找到了然后我得到了 确定在那里，

1646
01:03:37,699 --> 01:03:41,159
但现在我想在这个社区开始 e ninis

1647
01:03:41,159 --> 01:03:44,069
但是当我进行

1648
01:03:44,069 --> 01:03:45,659
顺序扫描时，我会发现

1649
01:03:45,659 --> 01:03:48,719
我附近的所有这些插槽都

1650
01:03:48,719 --> 01:03:50,939
被占用了所以现在我需要走出我的

1651
01:03:50,939 --> 01:03:53,309
社区并找到第一个空闲

1652
01:03:53,309 --> 01:03:56,279
插槽 碰巧在这里，所以

1653
01:03:56,279 --> 01:03:57,599
现在我想做的是我想

1654
01:03:57,599 --> 01:04:01,049
确定我是否可以以相反的

1655
01:04:01,049 --> 01:04:03,659
顺序交换任何密钥或任何我以前

1656
01:04:03,659 --> 01:04:05,039
试图

1657
01:04:05,039 --> 01:04:10,409
进入这个空插槽的邻居的密钥，这样我

1658
01:04:10,409 --> 01:04:12,479
就可以 然后将我的密钥插入我的

1659
01:04:12,479 --> 01:04:14,249
社区，这里的想法是

1660
01:04:14,249 --> 01:04:15,599
确保我们绑定

1661
01:04:15,599 --> 01:04:16,600
我们正在移动的任何密钥

1662
01:04:16,600 --> 01:04:18,400
以确保它在我们的插槽

1663
01:04:18,400 --> 01:04:21,130
中所以如果 D ID 应该属于这里

1664
01:04:21,130 --> 01:04:22,900
所以它的邻居是这两个

1665
01:04:22,900 --> 01:04:25,690
事情一二三所以可以让 D

1666
01:04:25,690 --> 01:04:28,630
把它们移到这里然后我们

1667
01:04:28,630 --> 01:04:30,580
可以散列 e 并将其放入我们的

1668
01:04:30,580 --> 01:04:35,350
邻居然后我们现在完成了

1669
01:04:35,350 --> 01:04:37,840
我插入 FF 应该去 D 是它的

1670
01:04:37,840 --> 01:04:39,250
邻居或这两个和这个 一个

1671
01:04:39,250 --> 01:04:40,960
可以是环绕式的，在这个 在这种情况下

1672
01:04:40,960 --> 01:04:42,970
，我可以向下扫描我找到一个

1673
01:04:42,970 --> 01:04:46,360
空闲插槽，然后我就可以开始了，所以

1674
01:04:46,360 --> 01:04:48,100
这是如何工作的，您必须

1675
01:04:48,100 --> 01:04:50,050
在每个社区中维护一些元数据，这些元数据是

1676
01:04:50,050 --> 01:04:53,010
关于它们中有哪些密钥

1677
01:04:53,010 --> 01:04:56,470
或我属于哪个社区，这样

1678
01:04:56,470 --> 01:04:58,420
您就可以 做出决定，如果

1679
01:04:58,420 --> 01:05:01,090
我试图进入 Perl 占用的邻居中的所有密钥都

1680
01:05:01,090 --> 01:05:03,460


1681
01:05:03,460 --> 01:05:07,600
属于我的邻居，那么

1682
01:05:07,600 --> 01:05:09,460
我必须将 Builder 上的散列大小加倍

1683
01:05:09,460 --> 01:05:11,230
并重建它，所以这里的想法

1684
01:05:11,230 --> 01:05:13,180
我们是否正在限制我们必须寻找多少

1685
01:05:13,180 --> 01:05:16,630
空闲位置才能

1686
01:05:16,630 --> 01:05:19,090
在我的社区中成为本地人，如果我不能

1687
01:05:19,090 --> 01:05:20,950
在我的社区中找到任何东西或在我的社区中

1688
01:05:20,950 --> 01:05:22,420
找不到我正在寻找的东西，

1689
01:05:22,420 --> 01:05:23,650
那么我不 不需要

1690
01:05:23,650 --> 01:05:25,420
潜在地扫描整个事情所以

1691
01:05:25,420 --> 01:05:27,580
只是这样它是一个变体我认为一个

1692
01:05:27,580 --> 01:05:28,810
罗宾汉散列在那里你限制

1693
01:05:28,810 --> 01:05:31,060
了你知道你如何限制

1694
01:05:31,060 --> 01:05:34,060
插入搜索空间并且他们查找

1695
01:05:34,060 --> 01:05:37,720
空间

1696
01:05:37,720 --> 01:05:39,430
好吧最后一个散列意味着我们的

1697
01:05:39,430 --> 01:05:42,130
杜鹃散列，这是 我与

1698
01:05:42,130 --> 01:05:45,580
我们所在的所有其他地方不同，如果

1699
01:05:45,580 --> 01:05:48,700
我们对某些东西进行哈希处理，您知道您不能

1700
01:05:48,700 --> 01:05:50,380
保证您首先

1701
01:05:50,380 --> 01:05:52,390
跳入的插槽将

1702
01:05:52,390 --> 01:05:54,100
与您所知道的完全相同，这将

1703
01:05:54,100 --> 01:05:55,840
正是您可以找到密钥的位置 在

1704
01:05:55,840 --> 01:05:58,000
跳房子散列

1705
01:05:58,000 --> 01:05:59,020
的情况下，在线性探测或罗宾汉散列的情况下，它会在附近，

1706
01:05:59,020 --> 01:06:00,700
你必须

1707
01:06:00,700 --> 01:06:01,930
继续向下扫描，直到找到

1708
01:06:01,930 --> 01:06:03,340
寻找 odie 的键找到空的空间，

1709
01:06:03,340 --> 01:06:04,990
但是当你散列时，使用布谷鸟散列

1710
01:06:04,990 --> 01:06:06,340
处理查找 并且您可以

1711
01:06:06,340 --> 01:06:08,170
保证要么键不存在，

1712
01:06:08,170 --> 01:06:09,850
要么您跳到的第一个位置

1713
01:06:09,850 --> 01:06:12,670
将是您想要的键 这是

1714
01:06:12,670 --> 01:06:14,590
他们实现这一目标的方式是

1715
01:06:14,590 --> 01:06:15,910
他们将同时维护多个哈希

1716
01:06:15,910 --> 01:06:18,910
表，每个哈希表

1717
01:06:18,910 --> 01:06:20,950
散列函数 所以现在当我想做

1718
01:06:20,950 --> 01:06:23,220
一个插入时，我会多次散列它，然后我

1719
01:06:23,220 --> 01:06:25,990
看看我是否可以将它插入任何

1720
01:06:25,990 --> 01:06:29,560
空闲插槽和任何我的表，如果现在该

1721
01:06:29,560 --> 01:06:30,520
插槽正在打开，

1722
01:06:30,520 --> 01:06:34,240
那么我将窃取该插槽并拿走那个

1723
01:06:34,240 --> 01:06:35,980
键 出和 n 拥有那个密钥，我

1724
01:06:35,980 --> 01:06:37,630
Vic tada 重新哈希并将其放入

1725
01:06:37,630 --> 01:06:40,030
另一个表中 想法是你可以

1726
01:06:40,030 --> 01:06:41,590
改变这个东西改变一个

1727
01:06:41,590 --> 01:06:44,260
哈希表一个键你可以有

1728
01:06:44,260 --> 01:06:46,120
一个已经插入的键多次改变它的

1729
01:06:46,120 --> 01:06:49,290
哈希表

1730
01:06:55,880 --> 01:06:57,940
你

1731
01:26:07,020 --> 01:26:10,590
是什么 这

1732
01:26:10,790 --> 01:26:37,989
[音乐]

