1
00:00:01,300 --> 00:00:05,129
[音乐]

2
00:00:05,200 --> 00:00:05,930
[鼓掌]

3
00:00:05,930 --> 00:00:08,630
[音乐]

4
00:00:08,630 --> 00:00:10,020
[鼓掌]

5
00:00:10,020 --> 00:00:11,480
[音乐

6
00:00:11,480 --> 00:00:13,530
]今天的课程我们将

7
00:00:13,530 --> 00:00:15,960
继续讨论多版本

8
00:00:15,960 --> 00:00:18,810
炊具对待所有人，所以上节课我们

9
00:00:18,810 --> 00:00:20,730
花时间讨论了

10
00:00:20,730 --> 00:00:22,710
构建时的四大设计决策 一个 NBC

11
00:00:22,710 --> 00:00:24,660
数据库系统，Kurt 是你的

12
00:00:24,660 --> 00:00:26,789
协议，即使控制在

13
00:00:26,789 --> 00:00:29,070
名称中再次设计，这就是

14
00:00:29,070 --> 00:00:30,779
我们将创建事务的方式

15
00:00:30,779 --> 00:00:32,880
Virgen 存储基本上每次我们

16
00:00:32,880 --> 00:00:34,469
更新一个元组时，我们实际上在哪里

17
00:00:34,469 --> 00:00:36,140
存储适合新物理版本的

18
00:00:36,140 --> 00:00:37,980
垃圾收集清理 所有

19
00:00:37,980 --> 00:00:39,450
版本然后索引管理

20
00:00:39,450 --> 00:00:42,750
基本上我们如何跟踪什么

21
00:00:42,750 --> 00:00:44,160
是二级索引指向

22
00:00:44,160 --> 00:00:45,570
真正指向实际

23
00:00:45,570 --> 00:00:46,950
物理版本版本链的头部

24
00:00:46,950 --> 00:00:48,870
或 D 指向一些逻辑

25
00:00:48,870 --> 00:00:51,750
标识符所以对于今天的课程我们

26
00:00:51,750 --> 00:00:53,340
现在将更详细地

27
00:00:53,340 --> 00:00:55,800
了解

28
00:00:55,800 --> 00:00:59,010
现代 nbcc 系统的现实世界实现，将会发生的事情

29
00:00:59,010 --> 00:01:00,570
是我们将在四个设计决策的背景下执行此

30
00:01:00,570 --> 00:01:01,800
操作 我们讨论

31
00:01:01,800 --> 00:01:04,559
了上一堂课，但我们将花

32
00:01:04,559 --> 00:01:05,790
更多时间讨论

33
00:01:05,790 --> 00:01:07,260
他们实际上将如何进行

34
00:01:07,260 --> 00:01:08,670
第一堂课 他们实际上同意协议

35
00:01:08,670 --> 00:01:09,780
本身 好吧 他们将如何

36
00:01:09,780 --> 00:01:12,360
协调交易 但随着我们的

37
00:01:12,360 --> 00:01:14,340
进行 沿着它们还将

38
00:01:14,340 --> 00:01:15,600
是我们将介绍的这些数据库系统的其他方面，这些

39
00:01:15,600 --> 00:01:19,200
是

40
00:01:19,200 --> 00:01:21,180
可能具有高性能 MVCC

41
00:01:21,180 --> 00:01:23,820
系统的好主意，该系统不完全适合

42
00:01:23,820 --> 00:01:25,470
我们之前讨论的四个设计决策

43
00:01:25,470 --> 00:01:28,560
等等 我们将

44
00:01:28,560 --> 00:01:29,729
通过并认为讨论将

45
00:01:29,729 --> 00:01:31,170
首先从 Microsoft hackathon 开始，

46
00:01:31,170 --> 00:01:32,820
因为这是

47
00:01:32,820 --> 00:01:35,460


48
00:01:35,460 --> 00:01:39,420
2011 年和 2012 年现代内存中 MVCC 系统的第一次实现

49
00:01:39,420 --> 00:01:41,579
，它将作为我们

50
00:01:41,579 --> 00:01:43,649
理解这些其他系统如何的基线

51
00:01:43,649 --> 00:01:45,060
实施 MVCC 好吧，所以如果你

52
00:01:45,060 --> 00:01:46,380
理解这一点，他们会说

53
00:01:46,380 --> 00:01:48,030
我们如何调整它或做

54
00:01:48,030 --> 00:01:50,399
不同的事情是

55
00:01:50,399 --> 00:01:52,049
通过 nbcc 实现添加额外的东西

56
00:01:52,049 --> 00:01:55,530
，可以改善什么 kathon 原来

57
00:01:55,530 --> 00:01:58,770
又反对了，所以 hackathons 我们

58
00:01:58,770 --> 00:02:01,320
专注于 OLTP 这两个在这里 hyper 和

59
00:02:01,320 --> 00:02:03,630
hana 我们专注于旧电视是 OLAP

60
00:02:03,630 --> 00:02:05,250
然后我们会带着 cicada 回来

61
00:02:05,250 --> 00:02:08,429
讨论我们如何做或如何

62
00:02:08,429 --> 00:02:12,720
做 所以这里

63
00:02:12,720 --> 00:02:13,890
有谁真正听说过汤姆的鬼话，

64
00:02:13,890 --> 00:02:16,830
因为它并没有在我身边徘徊

65
00:02:16,830 --> 00:02:20,700
，这很好，所以就像它

66
00:02:20,700 --> 00:02:22,470
开始时是微软的一个研究项目

67
00:02:22,470 --> 00:02:25,400
，然后现在动作在

68
00:02:25,400 --> 00:02:28,080
今天的续集服务器中发布，但就像你

69
00:02:28,080 --> 00:02:29,310
阅读时一样 他们不

70
00:02:29,310 --> 00:02:30,959
称其为 hackathon 的文档我认为它只是称为

71
00:02:30,959 --> 00:02:33,090
内存存储，但是如果您

72
00:02:33,090 --> 00:02:35,910
查看论文，我指的是所有内容，因为您

73
00:02:35,910 --> 00:02:37,730
知道这个项目有 hackathon，因此

74
00:02:37,730 --> 00:02:41,010
hecatomb 项目于 2008 年在

75
00:02:41,010 --> 00:02:44,840
Microsoft 开始作为扩展的一种方式

76
00:02:44,840 --> 00:02:47,730
续集服务器的生命周期 所以

77
00:02:47,730 --> 00:02:49,650
此时 2008 续集服务器已经有 20 年的

78
00:02:49,650 --> 00:02:51,510
历史了，所以他们开始了这个项目，

79
00:02:51,510 --> 00:02:54,090
说清楚我们可以做些什么来

80
00:02:54,090 --> 00:02:55,769
提高性能和

81
00:02:55,769 --> 00:02:58,650
使系统现代化，从而使 Mikus 成为我们的续集

82
00:02:58,650 --> 00:03:00,300
服务器 你知道 20 年后仍然很重要

83
00:03:00,300 --> 00:03:02,340
我的续集服务器 它

84
00:03:02,340 --> 00:03:04,500
使它混合了微软的一点钱 所以他们

85
00:03:04,500 --> 00:03:05,850
说你知道我们如何

86
00:03:05,850 --> 00:03:09,390
在未来 20 年保持那辆肉汁列车运行 所以

87
00:03:09,390 --> 00:03:10,800
他们决定研究你如何

88
00:03:10,800 --> 00:03:12,530
真正建立一个 新的 OTP 引擎

89
00:03:12,530 --> 00:03:14,790
专门为您所知 CI

90
00:03:14,790 --> 00:03:17,220
服务器生态系统所以如果您不知道

91
00:03:17,220 --> 00:03:21,480
1919 年 93 92 年续集服务器的历史，

92
00:03:21,480 --> 00:03:25,049
他们实际上购买了 Sybase 的许可证

93
00:03:25,049 --> 00:03:27,600
，然后他们将其支持到

94
00:03:27,600 --> 00:03:29,579
Windows NT，然后再支持

95
00:03:29,579 --> 00:03:30,720
它 然后他们从 Sybase 购买了源代码

96
00:03:30,720 --> 00:03:32,190
许可证，他们最终使用了

97
00:03:32,190 --> 00:03:34,320
它，在这一点上，他们已经

98
00:03:34,320 --> 00:03:36,510
从头开始重写了所有内容，我敢肯定

99
00:03:36,510 --> 00:03:38,549
，现在仍然

100
00:03:38,549 --> 00:03:41,989
存在续集的残余或续集服务器中的叹息基础影响，

101
00:03:41,989 --> 00:03:44,280
例如续集服务器

102
00:03:44,280 --> 00:03:45,989
使用 T sequel，它是 Sybase 使用的 sequel 的变体，

103
00:03:45,989 --> 00:03:49,140


104
00:03:49,140 --> 00:03:50,400
当然现在续集服务器

105
00:03:50,400 --> 00:03:51,930
仍然被认为是

106
00:03:51,930 --> 00:03:53,160
最先进的系统，而 sigh

107
00:03:53,160 --> 00:03:55,320
基础或多或少在维护中 e

108
00:03:55,320 --> 00:03:57,930
mode ASAP 购买了 Sybase，他们仍然在上面赚

109
00:03:57,930 --> 00:04:00,690
了一大笔钱，因为去年我们有

110
00:04:00,690 --> 00:04:02,579
一个领导

111
00:04:02,579 --> 00:04:04,110
Sybase 项目的人在这门课上做客座讲座，

112
00:04:04,110 --> 00:04:07,590
但你知道

113
00:04:07,590 --> 00:04:09,900
没有明星说像哦，我是

114
00:04:09,900 --> 00:04:11,160
将基于 Sybase 构建我的新系统

115
00:04:11,160 --> 00:04:12,709
没有人会这样做

116
00:04:12,709 --> 00:04:16,529
，所以他们开始了这个

117
00:04:16,529 --> 00:04:19,410
项目 微软接触了非常家庭的

118
00:04:19,410 --> 00:04:21,660
数据库人员 在微软 Paul Larsen

119
00:04:21,660 --> 00:04:23,130
是一位 MSR，他是一位著名的

120
00:04:23,130 --> 00:04:24,300
数据库人，像他一样已经存在了一段

121
00:04:24,300 --> 00:04:26,220
时间 在 1980 年代发明了线性散列，

122
00:04:26,220 --> 00:04:27,540


123
00:04:27,540 --> 00:04:29,640
并且确实做了很多工作。

124
00:04:29,640 --> 00:04:30,930


125
00:04:30,930 --> 00:04:32,340


126
00:04:32,340 --> 00:04:33,960
当他们开始排序以帮助

127
00:04:33,960 --> 00:04:36,090
他们将 Sybase 代码移植到

128
00:04:36,090 --> 00:04:38,910
Windows NT 时，Mike Zwilling 实际上是他们最开始雇用的主要人员之一，他在统一工作

129
00:04:38,910 --> 00:04:40,110
他在一个非常

130
00:04:40,110 --> 00:04:42,480
有影响力的系统上的内容被称为肯定，

131
00:04:42,480 --> 00:04:44,160
所以他们基本上得到了两个最好的

132
00:04:44,160 --> 00:04:47,550
人来领导这个项目，所以不像

133
00:04:47,550 --> 00:04:50,310
哈娜赫卡特在蝉和一堆

134
00:04:50,310 --> 00:04:51,240
其他系统上我们将讨论 他的

135
00:04:51,240 --> 00:04:53,460
学期而不是

136
00:04:53,460 --> 00:04:55,980
从头开始为黑客马拉松项目构建一个全新的数据库，

137
00:04:55,980 --> 00:04:57,420
他们必须确保它

138
00:04:57,420 --> 00:04:59,760
可以与现有的续集

139
00:04:59,760 --> 00:05:02,400
服务器生态系统集成，这更像是

140
00:05:02,400 --> 00:05:05,610
一个商业决策，你

141
00:05:05,610 --> 00:05:06,960
知道数百万人正在

142
00:05:06,960 --> 00:05:08,490
今天运行续集服务器有所有

143
00:05:08,490 --> 00:05:10,230
这些工具和所有这些可视化

144
00:05:10,230 --> 00:05:11,400
框架以及构建在

145
00:05:11,400 --> 00:05:13,170
Siebel 服务器之上的东西，你想

146
00:05:13,170 --> 00:05:15,000
保留这些东西，因为这有助于你

147
00:05:15,000 --> 00:05:18,060
了解帮助销售产品，所以

148
00:05:18,060 --> 00:05:19,350
如果你从头开始并

149
00:05:19,350 --> 00:05:20,790
构建它 黑客马拉松作为一个新的独立

150
00:05:20,790 --> 00:05:22,710
系统，您基本上必须重新植入

151
00:05:22,710 --> 00:05:25,230
所有生态系统，因此，出于这个原因，

152
00:05:25,230 --> 00:05:27,510
他们不得不将其作为

153
00:05:27,510 --> 00:05:30,180
引擎运行在单个服务器中，就像

154
00:05:30,180 --> 00:05:31,560
今天的工作方式一样，当您调用 create

155
00:05:31,560 --> 00:05:33,390
table 时，您可以通过 最后一个标志

156
00:05:33,390 --> 00:05:35,700
在内存中，然后

157
00:05:35,700 --> 00:05:38,000
最终使用黑客马拉松引擎

158
00:05:38,000 --> 00:05:39,990
关于

159
00:05:39,990 --> 00:05:41,070
他们将要做出的设计决策的另一个有趣

160
00:05:41,070 --> 00:05:42,960
的事情是 他们选择 MVCC 的部分原因

161
00:05:42,960 --> 00:05:44,760
以及他们将要采用的方法是他们

162
00:05:44,760 --> 00:05:47,310


163
00:05:47,310 --> 00:05:49,380
希望能够支持所有

164
00:05:49,380 --> 00:05:51,750
可能的 o2b 工作负载，并具有相同的

165
00:05:51,750 --> 00:05:55,290
可预测性能，所以我们没有

166
00:05:55,290 --> 00:05:56,760
谈论 我不认为我们

167
00:05:56,760 --> 00:05:58,650
在介绍课上讨论过 volte 的每一扇门，

168
00:05:58,650 --> 00:05:59,910
但这是我在读研究生时帮助构建的一个系统，

169
00:05:59,910 --> 00:06:02,190


170
00:06:02,190 --> 00:06:03,810
它的工作方式是你有一个

171
00:06:03,810 --> 00:06:06,000
单线程执行引擎，它

172
00:06:06,000 --> 00:06:07,920
实际上可以 当然，一次事务

173
00:06:07,920 --> 00:06:09,270
你会在多个核心之间瘫痪，

174
00:06:09,270 --> 00:06:11,940
但是现在一个事务

175
00:06:11,940 --> 00:06:13,890
超级快，因为没有争用，

176
00:06:13,890 --> 00:06:15,300
你不需要锁或闩锁，

177
00:06:15,300 --> 00:06:16,350
因为没有其他人

178
00:06:16,350 --> 00:06:18,330
同时运行我几乎可以以裸机速度运行，

179
00:06:18,330 --> 00:06:20,490
但是 一旦我接触

180
00:06:20,490 --> 00:06:22,050
多个核心，我们的数据就会出现在多个

181
00:06:22,050 --> 00:06:24,060
核心上，然后在保持锁上，然后

182
00:06:24,060 --> 00:06:25,560
事情就会变慢，所以你的一些

183
00:06:25,560 --> 00:06:27,660
事务会非常快，其他

184
00:06:27,660 --> 00:06:30,840
事务会非常慢，并且

185
00:06:30,840 --> 00:06:32,880
在 Microso 中 ft world 这是一个

186
00:06:32,880 --> 00:06:35,400
很难销售的产品，因为基本上你是

187
00:06:35,400 --> 00:06:37,470
说嘿去购买我们的新产品给

188
00:06:37,470 --> 00:06:39,630
我们很多钱来支付你的一些

189
00:06:39,630 --> 00:06:41,190
交易它会非常好

190
00:06:41,190 --> 00:06:43,050
90% 你的交易运行得非常

191
00:06:43,050 --> 00:06:44,490
快 Kember 发送你的

192
00:06:44,490 --> 00:06:46,650
交易会 跑起来真的很慢，就像你不能卖

193
00:06:46,650 --> 00:06:47,910
那样，但没有人会买那个

194
00:06:47,910 --> 00:06:50,130
嘿例子我喜欢像你这样的用户试着

195
00:06:50,130 --> 00:06:51,660
卖一辆车说嘿这是最快的

196
00:06:51,660 --> 00:06:52,650
车它会有很好的燃油经济性

197
00:06:52,650 --> 00:06:54,720
它会是我你知道你

198
00:06:54,720 --> 00:06:57,060
应该 买这个，但顺便说一句，

199
00:06:57,060 --> 00:06:58,050
当你开车时，10% 你会得癌症

200
00:06:58,050 --> 00:07:00,150
，没有人会买那辆车，

201
00:07:00,150 --> 00:07:02,310
所以出于这个原因，他们

202
00:07:02,310 --> 00:07:03,840
不会得到那种相对于鞋子或鞋子之类的最佳性能的动作

203
00:07:03,840 --> 00:07:05,370


204
00:07:05,370 --> 00:07:07,320
volte 是，但它最不可

205
00:07:07,320 --> 00:07:09,630
预测，这已经结束了

206
00:07:09,630 --> 00:07:13,530
mvcc 可以为我们提供的内容，因此它的核心将

207
00:07:13,530 --> 00:07:16,140
再次执行它可以使用

208
00:07:16,140 --> 00:07:18,230
时间戳来确定交易的顺序

209
00:07:18,230 --> 00:07:20,340
以及哪些处女

210
00:07:20,340 --> 00:07:22,740
对它可见，但与上次不同

211
00:07:22,740 --> 00:07:24,360
当我们上课时 谈到了保持排序的时间

212
00:07:24,360 --> 00:07:27,780
，因此基本 MVCC 交易

213
00:07:27,780 --> 00:07:30,330
现在必须有时间戳，所以当

214
00:07:30,330 --> 00:07:31,680
我们再次谈论时间相同的排序时

215
00:07:31,680 --> 00:07:32,670
，交易会在出现时分配一个

216
00:07:32,670 --> 00:07:35,160
时间戳，而 OCC 则

217
00:07:35,160 --> 00:07:36,680
在您验证时获得一个时间戳

218
00:07:36,680 --> 00:07:39,060
等等 在这个世界中，你会同时

219
00:07:39,060 --> 00:07:40,500
拥有你在开始时会被分配一个

220
00:07:40,500 --> 00:07:42,810
时间戳，然后

221
00:07:42,810 --> 00:07:44,400
当你必须通过验证时你会得到另一个提交时间戳

222
00:07:44,400 --> 00:07:46,950
，然后我们必须

223
00:07:46,950 --> 00:07:48,690
再次使用它，你正在使用这些

224
00:07:48,690 --> 00:07:50,490
信息 弄清楚什么是实际的

225
00:07:50,490 --> 00:07:53,790
什么对我们来说实际上是可见的所有

226
00:07:53,790 --> 00:07:54,990
两个帖子也将包含两个

227
00:07:54,990 --> 00:07:58,110
我们必须在最后

228
00:07:58,110 --> 00:08:00,390
开始的时间戳，因此开始时间戳

229
00:08:00,390 --> 00:08:02,280
就像之前一样，它将

230
00:08:02,280 --> 00:08:04,590
代表开始的时间戳

231
00:08:04,590 --> 00:08:06,690
创建它的 actor 事务或提交时间 提交创建它的事务的

232
00:08:06,690 --> 00:08:08,550
提交时间戳

233
00:08:08,550 --> 00:08:10,020


234
00:08:10,020 --> 00:08:13,470
，然后

235
00:08:13,470 --> 00:08:14,520
会发生什么，

236
00:08:14,520 --> 00:08:16,560
在下一张幻灯片中看到这件事必须

237
00:08:16,560 --> 00:08:18,060
返回并更改，因为我们将从这里

238
00:08:18,060 --> 00:08:19,770
开始我们创建一个新版本我们可以

239
00:08:19,770 --> 00:08:21,180
使用我们的事务的开始时间戳填充它

240
00:08:21,180 --> 00:08:23,070
但是当我们

241
00:08:23,070 --> 00:08:24,780
现在提交时我们有提交时间戳现在

242
00:08:24,780 --> 00:08:26,910
我们必须返回并更新我们的所有

243
00:08:26,910 --> 00:08:29,010
版本和 替换时间戳，

244
00:08:29,010 --> 00:08:31,320
我将向您展示一切仍然

245
00:08:31,320 --> 00:08:33,630
有效，我们知道没有

246
00:08:33,630 --> 00:08:35,039
幻影，

247
00:08:35,039 --> 00:08:36,650
即使我们正在更改时间戳也没有问题

248
00:08:36,650 --> 00:08:39,089
，元组的结束时间戳有点

249
00:08:39,089 --> 00:08:41,309
棘手，所以这将是开始

250
00:08:41,309 --> 00:08:43,789
时间戳 创建它的后事务

251
00:08:43,789 --> 00:08:46,980
在维珍链亲和性中创建了下一个版本，

252
00:08:46,980 --> 00:08:49,710
这意味着

253
00:08:49,710 --> 00:08:51,750
它是最新版本，并且您

254
00:08:51,750 --> 00:08:53,010
知道在它之后没有其他任何东西，

255
00:08:53,010 --> 00:08:54,960
或者创建下一个版本

256
00:08:54,960 --> 00:08:56,610
的已提交事务的提交时间 Stan

257
00:08:56,610 --> 00:08:59,730
然后

258
00:08:59,730 --> 00:09:01,620
无效 当前一个，然后它

259
00:09:01,620 --> 00:09:03,720
指向下一个如此之大的，

260
00:09:03,720 --> 00:09:04,830
这个有点令人困惑，但是

261
00:09:04,830 --> 00:09:06,480
当我们展示一个例子时我更有意义，

262
00:09:06,480 --> 00:09:10,170
好吧，所以说 我们再次有一个

263
00:09:10,170 --> 00:09:12,390
简单的表，所以 Hecate on 正在做

264
00:09:12,390 --> 00:09:15,120
一个笔式存储，只存储从最旧到最新

265
00:09:15,120 --> 00:09:18,060
的 Virgin 链，并说对于这个，

266
00:09:18,060 --> 00:09:20,010
我们只有你知道一个带有

267
00:09:20,010 --> 00:09:22,520
逻辑元组的两个处女 a1 和 a2，

268
00:09:22,520 --> 00:09:25,800
所以我们的交易一直在进行

269
00:09:25,800 --> 00:09:27,089
是的，一开始我们必须给

270
00:09:27,089 --> 00:09:29,459
它一个时间戳，所以

271
00:09:29,459 --> 00:09:33,120
在这个例子中它的开始时间戳是 25，所以现在我们

272
00:09:33,120 --> 00:09:35,520
要读取 a，所以我们会

273
00:09:35,520 --> 00:09:37,260
以某种方式到达

274
00:09:37,260 --> 00:09:39,870
Virgin 链的头部 在 a1 这里我们是如何到达那里的

275
00:09:39,870 --> 00:09:41,070


276
00:09:41,070 --> 00:09:42,870
对于我们的目的是索引还是顺序扫描并不重要，我们

277
00:09:42,870 --> 00:09:45,570
不在乎所以现在我们要

278
00:09:45,570 --> 00:09:46,980
看看这个版本是否对

279
00:09:46,980 --> 00:09:48,779
我们可见所以我们必须再次去 看看

280
00:09:48,779 --> 00:09:50,250
开始和结束时间戳，它告诉

281
00:09:50,250 --> 00:09:52,620
我们在这种情况下元组的可见性，

282
00:09:52,620 --> 00:09:55,470
这里 25 大于 20，所以我们

283
00:09:55,470 --> 00:09:57,720
知道这件事出现

284
00:09:57,720 --> 00:10:00,150
在我们之前或出现在

285
00:10:00,150 --> 00:10:02,279
我们的交易快照之前，所以现在

286
00:10:02,279 --> 00:10:03,959
我们遵循 版本更改指针

287
00:10:03,959 --> 00:10:06,180
，现在我们到达这里 这里的情况是

288
00:10:06,180 --> 00:10:09,480
20 25 介于 20 和亲和力之间，所以

289
00:10:09,480 --> 00:10:10,709
我们知道这是

290
00:10:10,709 --> 00:10:11,790
我们可以看到的版本，这就是我们将要

291
00:10:11,790 --> 00:10:14,430
阅读的内容，因此与上一堂课之前的内容相同，

292
00:10:14,430 --> 00:10:17,490
好吧，现在让我们看看

293
00:10:17,490 --> 00:10:19,890
我们不会 做一个写或命名一样的

294
00:10:19,890 --> 00:10:21,390
事情我们以某种方式登陆

295
00:10:21,390 --> 00:10:22,650
原始链的头部我们知道

296
00:10:22,650 --> 00:10:24,750
这是我们想要更新的逻辑所以

297
00:10:24,750 --> 00:10:26,490
我们想找到我们应该在哪里安装

298
00:10:26,490 --> 00:10:29,580
我们的版本所以在这种情况下再次在这里

299
00:10:29,580 --> 00:10:32,370
25 大于 20 所以我们知道我们

300
00:10:32,370 --> 00:10:33,510
不想要它 这不是

301
00:10:33,510 --> 00:10:35,250
鸟的头 这不是我们想要写的版本

302
00:10:35,250 --> 00:10:37,800
下来这里 20 到

303
00:10:37,800 --> 00:10:39,750
无穷大 所以我们现在

304
00:10:39,750 --> 00:10:41,760
知道这是这个 最近

305
00:10:41,760 --> 00:10:43,740
提交的版本然后因为这

306
00:10:43,740 --> 00:10:46,589
是无穷大并且我们的指针为空我们

307
00:10:46,589 --> 00:10:47,850
知道现在没有其他人试图

308
00:10:47,850 --> 00:10:49,279
在我们之后创建新版本

309
00:10:49,279 --> 00:10:53,100
所以现在我们需要安装我们的

310
00:10:53,100 --> 00:10:55,680
新版本所以对于这个我们需要

311
00:10:55,680 --> 00:10:56,850
小心如何 我们要点菜，

312
00:10:56,850 --> 00:10:58,740
因为不像我们上一堂课

313
00:10:58,740 --> 00:11:00,630
这种锁定整个

314
00:11:00,630 --> 00:11:04,170
元组，然后对这个元组进行更新，

315
00:11:04,170 --> 00:11:06,120
我们希望将所有事情都做为

316
00:11:06,120 --> 00:11:07,740
比较和交换，所以我们希望

317
00:11:07,740 --> 00:11:08,579
避免必须锁定这个

318
00:11:08,579 --> 00:11:10,889
东西，他们会做出什么改变，所以

319
00:11:10,889 --> 00:11:12,389
我们需要做的第一件事 要做的是

320
00:11:12,389 --> 00:11:14,819
正确附加我们的新版本它是一个仅限笔的

321
00:11:14,819 --> 00:11:16,980
存储我们只是在我们的表空间中找到一个空闲插槽

322
00:11:16,980 --> 00:11:19,920
然后我们声明它

323
00:11:19,920 --> 00:11:21,829
然后我们现在可以安装我们的新版本

324
00:11:21,829 --> 00:11:24,239
但是现在你会看到我们的

325
00:11:24,239 --> 00:11:25,860
开始时间戳我们 '在这里做一些

326
00:11:25,860 --> 00:11:28,439
特别的事情所以我在这里有这个小

327
00:11:28,439 --> 00:11:31,470
标记说交易在 25

328
00:11:31,470 --> 00:11:34,319
那么这意味着什么所以黑客马拉松

329
00:11:34,319 --> 00:11:37,499
将举行而不是

330
00:11:37,499 --> 00:11:40,319
让我们使用某种特殊的交易 ID

331
00:11:40,319 --> 00:11:42,179
来说明这是代表

332
00:11:42,179 --> 00:11:43,799
时间戳 对于未提交的事务，

333
00:11:43,799 --> 00:11:45,720
他们将使用开始

334
00:11:45,720 --> 00:11:49,559
时间戳来记录

335
00:11:49,559 --> 00:11:51,360
这是由该

336
00:11:51,360 --> 00:11:53,399
事务为已提交和

337
00:11:53,399 --> 00:11:55,439
未提交创建的版本，因此

338
00:11:55,439 --> 00:11:56,879
他们要做的是他们将使用

339
00:11:56,879 --> 00:12:00,179
大多数 ignificant 位并将其设置为 1

340
00:12:00,179 --> 00:12:02,189
表示此时时间戳的事务

341
00:12:02,189 --> 00:12:04,980
未提交，因此我

342
00:12:04,980 --> 00:12:07,230
通过在其前面放置前缀事务

343
00:12:07,230 --> 00:12:08,220
来表示这一点，这仅用于

344
00:12:08,220 --> 00:12:09,959
说明目的，但在

345
00:12:09,959 --> 00:12:11,429
封面之下是它们的真正含义 这样做

346
00:12:11,429 --> 00:12:14,429
只是稍微翻转一下让我接受我

347
00:12:14,429 --> 00:12:17,419
猜你为什么要这样做

348
00:12:30,130 --> 00:12:32,259
啊所以她说因为这

349
00:12:32,259 --> 00:12:33,519
认为我们知道没有其他人

350
00:12:33,519 --> 00:12:35,050
可以每次

351
00:12:35,050 --> 00:12:37,300
都拥有比我们大的他，所以当我们

352
00:12:37,300 --> 00:12:38,199
做比较实际上会

353
00:12:38,199 --> 00:12:44,290
忽略一个是的帮助我避免

354
00:12:44,290 --> 00:12:47,680
级联中止 巴基斯坦会

355
00:12:47,680 --> 00:12:49,060
支持光谱读取所以我们仍然有

356
00:12:49,060 --> 00:12:59,860
级联板所以他说你

357
00:12:59,860 --> 00:13:00,790
可以使用它来防止你通过

358
00:13:00,790 --> 00:13:01,990
检查阅读尚未提交的内容

359
00:13:01,990 --> 00:13:07,300
这个，他们说我

360
00:13:07,300 --> 00:13:09,699
不想再读这个，所以他们

361
00:13:09,699 --> 00:13:11,740
各自的读物所以你希望

362
00:13:11,740 --> 00:13:12,940
能够阅读未提交的东西，

363
00:13:12,940 --> 00:13:13,990
因为你会假设他们

364
00:13:13,990 --> 00:13:15,310
交易你 从

365
00:13:15,310 --> 00:13:17,500
修改中读取此内容不会中止

366
00:13:17,500 --> 00:13:19,060
所以你想要继续并

367
00:13:19,060 --> 00:13:24,160
允许我们她说你可以阅读

368
00:13:24,160 --> 00:13:25,449
你更新的其他内容是的但我

369
00:13:25,449 --> 00:13:26,850
不需要一点点来弄清楚

370
00:13:26,850 --> 00:13:29,170
这些都是她好的 实际上

371
00:13:29,170 --> 00:13:38,860
非常有趣，是的，所以你是说

372
00:13:38,860 --> 00:13:40,689
，如果你读了这个并且看到

373
00:13:40,689 --> 00:13:41,860
了那个，那么你就知道你读到了

374
00:13:41,860 --> 00:13:55,089
一些未提交的内容 Yama Sara

375
00:13:55,089 --> 00:13:55,509


376
00:13:55,509 --> 00:14:04,600
是的，非常接近是的，他说他们

377
00:14:04,600 --> 00:14:06,040
通过构造函数并

378
00:14:06,040 --> 00:14:07,630
识别另一个 这东西没用过，

379
00:14:07,630 --> 00:14:09,610
继续清理，但没用过，

380
00:14:09,610 --> 00:14:14,350
我们把东西放在那里他没有

381
00:14:14,350 --> 00:14:17,279
承诺是的，

382
00:14:19,200 --> 00:14:21,420
但是为什么那个人

383
00:14:21,420 --> 00:14:23,850
实际上为我们做了什么你们非常

384
00:14:23,850 --> 00:14:28,200
接近他说现在做一个光屏不

385
00:14:28,200 --> 00:14:31,560
她 说现在恢复好了，

386
00:14:31,560 --> 00:14:33,240
这是奥利弗，这很好，因为

387
00:14:33,240 --> 00:14:34,620
这就像我吃过纸

388
00:14:34,620 --> 00:14:35,850
哦，当然是的，这样做，

389
00:14:35,850 --> 00:14:38,670
然后你们因为

390
00:14:38,670 --> 00:14:39,870
没有所有这些先验知识而得到它，所以

391
00:14:39,870 --> 00:14:40,920
很高兴见到你们 喜欢你

392
00:14:40,920 --> 00:14:41,940
伙计们认为这很重要

393
00:14:41,940 --> 00:14:44,040
所以我们实际上要做

394
00:14:44,040 --> 00:14:47,160
的是我们需要在某个时候我们

395
00:14:47,160 --> 00:14:49,350
需要弄清楚因为他非常

396
00:14:49,350 --> 00:14:50,850
接近我们需要

397
00:14:50,850 --> 00:14:52,560
弄清楚我们是否阅读了未

398
00:14:52,560 --> 00:14:55,200
提交的内容如果是的话我们 需要知道

399
00:14:55,200 --> 00:14:57,810
那个事务发生了什么，所以通过

400
00:14:57,810 --> 00:15:00,540
设置这个位 1 哇，当我们的

401
00:15:00,540 --> 00:15:01,860
事务另一个事务正在

402
00:15:01,860 --> 00:15:03,390
读取这个时，它会说哦，我

403
00:15:03,390 --> 00:15:05,370
在 1 处看到这个位，这意味着这

404
00:15:05,370 --> 00:15:07,470
件事可能未提交它实际上

405
00:15:07,470 --> 00:15:09,120
可能已提交我们只是 还不知道

406
00:15:09,120 --> 00:15:10,320
因为他们还没有更新

407
00:15:10,320 --> 00:15:13,650
这个这个这个这个这个时间戳

408
00:15:13,650 --> 00:15:16,260
你知道删除1所以我们会

409
00:15:16,260 --> 00:15:17,490
在更多的幻灯片中看到但实际上

410
00:15:17,490 --> 00:15:19,620
会有这个全局状态图来

411
00:15:19,620 --> 00:15:21,540
跟踪 系统中运行的每个事务的当前状态，

412
00:15:21,540 --> 00:15:22,980


413
00:15:22,980 --> 00:15:24,930
所以如果我正在寻找

414
00:15:24,930 --> 00:15:26,640
镜面读取，我需要一种方法来确定

415
00:15:26,640 --> 00:15:28,860
我读到的东西

416
00:15:28,860 --> 00:15:31,770
是否真的被提交，所以通过

417
00:15:31,770 --> 00:15:33,600
将它设置为 1 我 不要哈 必须去

418
00:15:33,600 --> 00:15:35,220
检查一下是否真的

419
00:15:35,220 --> 00:15:36,720
允许阅读这个我

420
00:15:36,720 --> 00:15:39,150
在我的本地元数据中做一个小标记，就像在

421
00:15:39,150 --> 00:15:41,100
我的线程中说的那样

422
00:15:41,100 --> 00:15:42,720
3 弄清楚后来发生了什么

423
00:15:42,720 --> 00:15:44,040
，因为它可能 并且可能没有

424
00:15:44,040 --> 00:15:50,160
提交是，所以他说如果

425
00:15:50,160 --> 00:15:52,350
我继续检查我的事务

426
00:15:52,350 --> 00:15:54,720
提交时会发生什么，他们继续阅读

427
00:15:54,720 --> 00:15:56,490
这个如果它仍然未提交怎么办我必须

428
00:15:56,490 --> 00:16:00,770
等待让我们再做几张幻灯片是的，

429
00:16:01,620 --> 00:16:03,610
我们还没有到那里 是的，他的

430
00:16:03,610 --> 00:16:05,290
问题是更新原来的是

431
00:16:05,290 --> 00:16:13,960
的，是的，是的，是的，是的，是的，所以在这

432
00:16:13,960 --> 00:16:16,260
一点上没有人可以看到这一点，

433
00:16:16,260 --> 00:16:18,520
因为我所做的就是我只是

434
00:16:18,520 --> 00:16:21,250
安装了这个权利的第一个事务，

435
00:16:21,250 --> 00:16:23,290
而不是锁定 e 我只是

436
00:16:23,290 --> 00:16:24,310
说让我继续创建这个

437
00:16:24,310 --> 00:16:26,860
然后现在我将在这里进行比较和交换

438
00:16:26,860 --> 00:16:29,830
如果成功那么我

439
00:16:29,830 --> 00:16:31,570
知道我能够成功安装

440
00:16:31,570 --> 00:16:33,760
这个新版本但此时

441
00:16:33,760 --> 00:16:35,410
这里任何人都可以看到这个每个人都可以看到

442
00:16:35,410 --> 00:16:37,960
我的新版本为什么不是

443
00:16:37,960 --> 00:16:41,050
我的意思是fini 现在我需要

444
00:16:41,050 --> 00:16:43,420
回到这里并将其翻转为我的

445
00:16:43,420 --> 00:16:45,520
时间戳，现在我的版本已

446
00:16:45,520 --> 00:16:47,410
安装它仍然未提交我的位

447
00:16:47,410 --> 00:16:49,540
仍然设置为 true 或者因此位

448
00:16:49,540 --> 00:16:51,160
设置为表示这

449
00:16:51,160 --> 00:16:52,060
可能来自未提交的

450
00:16:52,060 --> 00:16:53,980
事务 但在这

451
00:16:53,980 --> 00:16:55,840
一点上，任何想

452
00:16:55,840 --> 00:16:58,630
在时间戳 25 之后读取数据的人

453
00:16:58,630 --> 00:17:00,100
都应该能够看到我的新

454
00:17:00,100 --> 00:17:08,740
版本

455
00:17:08,740 --> 00:17:10,329


456
00:17:10,329 --> 00:17:12,160


457
00:17:12,160 --> 00:17:13,240
就像结束时间戳一样，让我们说

458
00:17:13,240 --> 00:17:16,380
当你在 2 中开始时间戳时像

459
00:17:16,380 --> 00:17:19,510
1 所以他的问题是为什么我需要

460
00:17:19,510 --> 00:17:21,369
在这里跟踪这个结束时间戳

461
00:17:21,369 --> 00:17:22,839
我不能只是按照维珍

462
00:17:22,839 --> 00:17:25,420
链说哦，我知道

463
00:17:25,420 --> 00:17:28,270
这个元组的可见性是 20 到 25 因为

464
00:17:28,270 --> 00:17:30,100
我在这里有它但是现在当我进行垃圾

465
00:17:30,100 --> 00:17:31,330
收集时我总是要保留最后

466
00:17:31,330 --> 00:17:35,140
一个

467
00:17:35,140 --> 00:17:37,630


468
00:17:37,630 --> 00:17:41,250
我真的不是说

469
00:17:46,830 --> 00:17:49,660
错误吗 重点是如果你知道正确所以

470
00:17:49,660 --> 00:17:51,070
他说如果你知道这个指针为

471
00:17:51,070 --> 00:17:53,530
空那么不应该只是读取

472
00:17:53,530 --> 00:18:00,510
因为这是无穷大是的也许

473
00:18:21,100 --> 00:18:23,870
所以你说所以你说如果

474
00:18:23,870 --> 00:18:26,170
在时间戳 24 有交易

475
00:18:26,170 --> 00:18:28,790
他们应该阅读 这就是他所说的

476
00:18:28,790 --> 00:18:32,150
，你可以推断出我认为你

477
00:18:32,150 --> 00:18:33,380
想减少我的指针追逐我认为

478
00:18:33,380 --> 00:18:35,300
这是计算与存储成本，所以如果

479
00:18:35,300 --> 00:18:37,040
我正在扫描我从最旧到最新

480
00:18:37,040 --> 00:18:39,080
我看到这个我不知道结束

481
00:18:39,080 --> 00:18:41,600
时间戳 我的指针不为空

482
00:18:41,600 --> 00:18:43,730
我现在再次跟随指针去

483
00:18:43,730 --> 00:18:45,290
弄清楚到底有什么

484
00:18:45,290 --> 00:18:47,600
这实际上应该是什么以及

485
00:18:47,600 --> 00:18:48,800
任何浪费

486
00:18:48,800 --> 00:18:52,090
时间的事情都不值得所以为了

487
00:18:52,090 --> 00:18:54,470
位的安全你避免额外的

488
00:18:54,470 --> 00:19:16,090
计算所以他的观点又回到了这里

489
00:19:16,090 --> 00:19:18,680
这个东西设置在一个所以因此

490
00:19:18,680 --> 00:19:20,060
当你做

491
00:19:20,060 --> 00:19:21,590
比较时你拥有的数字超高你自己看起来63位

492
00:19:21,590 --> 00:19:35,980
你忽略了我们为什么不

493
00:19:41,710 --> 00:19:46,190
改变它仍然保持这样是我们的

494
00:19:46,190 --> 00:19:48,890
开始时间戳我们只翻转 那一吨

495
00:19:48,890 --> 00:19:51,410
oa 零，当我们得到通勤

496
00:19:51,410 --> 00:19:55,010
时间戳时，我会显示下一个

497
00:19:55,010 --> 00:19:56,630


498
00:19:56,630 --> 00:19:57,710


499
00:19:57,710 --> 00:20:00,050


500
00:20:00,050 --> 00:20:01,990


501
00:20:01,990 --> 00:20:05,570
好的 现在我们的家伙再次提交

502
00:20:05,570 --> 00:20:07,070
所以我们将永远不会CC 所以我们正在

503
00:20:07,070 --> 00:20:08,810
做我们正在做验证所以我们需要

504
00:20:08,810 --> 00:20:11,030
去你知道去检查看看我们

505
00:20:11,030 --> 00:20:12,410
在这种情况下被允许提交是的，

506
00:20:12,410 --> 00:20:14,030
我们就是这样 我们的提交时间保持

507
00:20:14,030 --> 00:20:15,470
在 35 左右，

508
00:20:15,470 --> 00:20:17,659
所以我们现在需要做的就是

509
00:20:17,659 --> 00:20:20,720
稍后返回并将其翻转到现在的

510
00:20:20,720 --> 00:20:22,789
35 不需要立即发生

511
00:20:22,789 --> 00:20:25,460
，因为这又是

512
00:20:25,460 --> 00:20:27,409
说如果有人阅读此内容 找出

513
00:20:27,409 --> 00:20:29,059
稍后在我的全球

514
00:20:29,059 --> 00:20:30,320
地图中让您知道我是否真的提交了

515
00:20:30,320 --> 00:20:32,809
但现在如果我安装了 35

516
00:20:32,809 --> 00:20:34,490
位设置为零所以我知道我正在

517
00:20:34,490 --> 00:20:35,900
阅读我

518
00:20:35,900 --> 00:20:37,580
肯定已提交的内容而我没有

519
00:20:37,580 --> 00:20:49,460
不需要检查那张地图是的，繁荣好所以

520
00:20:49,460 --> 00:20:51,500
让我们来回答这个问题 是的，

521
00:20:51,500 --> 00:20:53,900
所以让我们现在倒带，让

522
00:20:53,900 --> 00:20:55,610
我们删除我们回到这个 D 的提交，

523
00:20:55,610 --> 00:20:57,500
让我们现在带来另一个事务，

524
00:20:57,500 --> 00:20:58,520
好吧，

525
00:20:58,520 --> 00:21:01,190
这是你的问题，所以我们的

526
00:21:01,190 --> 00:21:03,020
事务从时间戳 30 开始，

527
00:21:03,020 --> 00:21:05,780
然后再次

528
00:21:05,780 --> 00:21:08,059
阅读 原始链 30 大于 20

529
00:21:08,059 --> 00:21:10,809
我们不想要这个 30 大于

530
00:21:10,809 --> 00:21:14,120
25 我们不想要这个所以然后我们降落

531
00:21:14,120 --> 00:21:15,260
在这里 这是我们

532
00:21:15,260 --> 00:21:17,210
真正想要再次读取的版本 我们

533
00:21:17,210 --> 00:21:19,429
正在 Hecate 中进行镜面读取 而不是

534
00:21:19,429 --> 00:21:20,900
在这个元组上使用写锁存器或右锁，

535
00:21:20,900 --> 00:21:22,250
我被允许读取

536
00:21:22,250 --> 00:21:24,200
未提交的内容稍后振荡

537
00:21:24,200 --> 00:21:25,850
确保我

538
00:21:25,850 --> 00:21:26,840
知道创建这个版本的事务我已经阅读过

539
00:21:26,840 --> 00:21:28,640
它是否实际提交但

540
00:21:28,640 --> 00:21:31,220
我 允许这样做，但现在这个人

541
00:21:31,220 --> 00:21:33,260
想要向右或颈部，所以在这种情况下

542
00:21:33,260 --> 00:21:33,770
，

543
00:21:33,770 --> 00:21:36,950
我的时间戳是 30，也就是 25 之后，

544
00:21:36,950 --> 00:21:38,720
但这又是第一位作家获胜，所以这个

545
00:21:38,720 --> 00:21:40,429
人将来到这里并

546
00:21:40,429 --> 00:21:44,270
认识到那里的 另一个

547
00:21:44,270 --> 00:21:46,280
交易是你 ncommitted 在这里

548
00:21:46,280 --> 00:21:49,039
创建了一个新版本，

549
00:21:49,039 --> 00:21:50,390
在此之后我无法创建新版本，

550
00:21:50,390 --> 00:21:52,450
因此我必须再次中止我的交易，

551
00:21:52,450 --> 00:21:55,130
因此在这里看到这个东西我

552
00:21:55,130 --> 00:21:57,740
知道在这种情况下它是未提交的实际在

553
00:21:57,740 --> 00:21:59,600
这里你想要去检查

554
00:21:59,600 --> 00:22:01,909
但我 认为是的，如果你去检查你

555
00:22:01,909 --> 00:22:03,230
可以去看看哦，它实际上是提交的，

556
00:22:03,230 --> 00:22:04,480
因此我无法在

557
00:22:04,480 --> 00:22:07,309
此处安装此示例的版本 2025

558
00:22:07,309 --> 00:22:09,260
尚未提交，因此这将是

559
00:22:09,260 --> 00:22:10,610
写入冲突，因此我们继续前进

560
00:22:10,610 --> 00:22:15,260
，董事会是您的 问题 好的 是的

561
00:22:15,260 --> 00:22:18,349
[音乐]

562
00:22:19,840 --> 00:22:24,130
抱歉所以当他试图写上时，什么线程无法读取

563
00:22:24,799 --> 00:22:26,659
他们的威胁在这一点上已经死

564
00:22:26,659 --> 00:22:30,159
了

565
00:22:30,159 --> 00:22:36,789
所以你假装你回到这里

566
00:22:37,720 --> 00:22:46,460
好的是的 所以这可以

567
00:22:46,460 --> 00:22:50,690
在 ste 之后提交时间戳 ste 再次获得 35 然后当

568
00:22:50,690 --> 00:23:04,399
这个人做对了只是为了读这个

569
00:23:04,399 --> 00:23:11,419
人所以这个人提交猜想这个人

570
00:23:11,419 --> 00:23:19,970
然后读是的问题是在我

571
00:23:19,970 --> 00:23:21,169
的 Apple 少这里这个人的提交

572
00:23:21,169 --> 00:23:23,630
时间设置为 35 但如果现在如果我回来

573
00:23:23,630 --> 00:23:27,200
并做这个阅读，但我 有时间戳 30

574
00:23:27,200 --> 00:23:31,130
我看到没有因为在快照

575
00:23:31,130 --> 00:23:35,080
隔离下我应该只看到

576
00:23:35,860 --> 00:23:42,399
我在这种情况下开始之前的事情

577
00:23:53,080 --> 00:24:15,320
这里没关系是的问题我如何

578
00:24:15,320 --> 00:24:17,720
确定我是否需要翻转这些所以

579
00:24:17,720 --> 00:24:20,120
如果我去看看会发生什么 起来，我看到

580
00:24:20,120 --> 00:24:22,610
这些事情已经提交了，有人说

581
00:24:22,610 --> 00:24:24,289
我去弄清楚实际

582
00:24:24,289 --> 00:24:26,210
发生了什么，所以如果将它们设置为一个，我会

583
00:24:26,210 --> 00:24:27,409
查看我的地图，我会说哦，它已

584
00:24:27,409 --> 00:24:29,149
提交，真正的提交时间戳是

585
00:24:29,149 --> 00:24:30,889
35，所以我想我是 在

586
00:24:30,889 --> 00:24:33,440
我的本地观点中很难做到这一点，然后当你

587
00:24:33,440 --> 00:24:35,240
进行更新时，你会

588
00:24:35,240 --> 00:24:36,950
从最新到最旧，因为人们

589
00:24:36,950 --> 00:24:38,249
正在朝着另一个方向前进，

590
00:24:38,249 --> 00:24:41,090
所以你不会遇到那个问题，

591
00:24:41,090 --> 00:24:42,799


592
00:24:42,799 --> 00:24:45,509
所以让我们现在跳 并讨论

593
00:24:45,509 --> 00:24:47,159
我们实际上将如何再次使用状态映射

594
00:24:47,159 --> 00:24:48,720
，因此这是一个全局散列映射，

595
00:24:48,720 --> 00:24:51,389
他们将在

596
00:24:51,389 --> 00:24:53,279
整个数据库系统中维护它，只

597
00:24:53,279 --> 00:24:54,239
跟踪每个正在运行的事务的状态，

598
00:24:54,239 --> 00:24:56,940
因此活动

599
00:24:56,940 --> 00:24:58,080
事务只是 一笔交易 ion

600
00:24:58,080 --> 00:24:59,820
显示它已经完成了一堆读取和

601
00:24:59,820 --> 00:25:01,679
写入 它有开始时间戳 你

602
00:25:01,679 --> 00:25:03,149
仍然可以做更多的读取和写入 我们只是

603
00:25:03,149 --> 00:25:04,580
不知道结果只是尚未

604
00:25:04,580 --> 00:25:06,450
验证是当应用程序说

605
00:25:06,450 --> 00:25:08,220
我想提交我的事务 现在

606
00:25:08,220 --> 00:25:09,450
我们开始 确定

607
00:25:09,450 --> 00:25:10,859
是否真的有很多提交

608
00:25:10,859 --> 00:25:12,659
正确的过程，就像我们必须去检查

609
00:25:12,659 --> 00:25:14,220
重写集并查看是否有任何

610
00:25:14,220 --> 00:25:16,739
冲突提交的事务是

611
00:25:16,739 --> 00:25:20,749
我们通过验证阶段我们有一个

612
00:25:20,749 --> 00:25:24,299
社区来读取我们的数据

613
00:25:24,299 --> 00:25:25,679
很清楚 它实际上已经

614
00:25:25,679 --> 00:25:27,389
提交，但我们还没有回去

615
00:25:27,389 --> 00:25:29,609
，将那些开始时间戳

616
00:25:29,609 --> 00:25:31,590
和结束时间戳翻转为

617
00:25:31,590 --> 00:25:33,809
我们的提交时间戳，然后

618
00:25:33,809 --> 00:25:35,309
终止是当我们

619
00:25:35,309 --> 00:25:36,749
为我们创建的版本更新所有时间戳时

620
00:25:36,749 --> 00:25:38,879
， 然后在某个时候

621
00:25:38,879 --> 00:25:40,590
我们将得到的将被修剪掉 将被

622
00:25:40,590 --> 00:25:43,460
扔出地图之外 所以

623
00:25:43,460 --> 00:25:46,289
现在让我们来看看生命周期更多的

624
00:25:46,289 --> 00:25:48,720
细节 所以它开始交易得到

625
00:25:48,720 --> 00:25:50,609
开始时间戳 p 我们说它

626
00:25:50,609 --> 00:25:52,559
在地图中说它处于活动状态，然后我们

627
00:25:52,559 --> 00:25:54,539
在 OCC 下再次进行正常处理，他们

628
00:25:54,539 --> 00:25:56,309
将其称为读取阶段，用于

629
00:25:56,309 --> 00:25:58,950
在数据上进行读取和写入，但是当

630
00:25:58,950 --> 00:26:00,929
我们运行 maratha 时，我会跟踪读取

631
00:26:00,929 --> 00:26:02,940
集 扫描集和事务的正确集，

632
00:26:02,940 --> 00:26:04,950
因此对于正确集中的读取集，

633
00:26:04,950 --> 00:26:06,480
这些只是

634
00:26:06,480 --> 00:26:09,119
指向我们正确读取和写入的版本的物理指针，

635
00:26:09,119 --> 00:26:11,460
但

636
00:26:11,460 --> 00:26:13,080
实际上它们就像读取

637
00:26:13,080 --> 00:26:15,690
集一样 是

638
00:26:15,690 --> 00:26:19,109
为事务的访问方法生成的版本

639
00:26:19,109 --> 00:26:21,119
对不起查询

640
00:26:21,119 --> 00:26:22,980
执行器 我将在下

641
00:26:22,980 --> 00:26:25,710
一张幻灯片中解释，扫描集将

642
00:26:25,710 --> 00:26:28,139
是我们用来

643
00:26:28,139 --> 00:26:30,989
在表上进行扫描的实际 where 子句 因为我们需要它

644
00:26:30,989 --> 00:26:32,789
来对可串行化进行幻像检查

645
00:26:32,789 --> 00:26:35,220
然后我们点击预提交

646
00:26:35,220 --> 00:26:36,570
这是当应用程序告诉我们我们

647
00:26:36,570 --> 00:26:38,159
想要提交 我们现在得到我们的提交

648
00:26:38,159 --> 00:26:40,919
提交时间戳 我们进行验证以

649
00:26:40,919 --> 00:26:42,269
确定我们是否真的存在

650
00:26:42,269 --> 00:26:44,820
任何 冲突，然后正确和 th

651
00:26:44,820 --> 00:26:46,169
再次验证我们只是检查

652
00:26:46,169 --> 00:26:48,869
所有内容，看看我们是否

653
00:26:48,869 --> 00:26:51,359
没有违反可序列化的顺序，但

654
00:26:51,359 --> 00:26:52,140
你为什么不认为

655
00:26:52,140 --> 00:26:53,280
这是他们现在要写的

656
00:26:53,280 --> 00:26:56,220
新版本到红发的新版本在

657
00:26:56,220 --> 00:26:58,230
磁盘上注销所以这是不同的 与

658
00:26:58,230 --> 00:26:59,820
Discordian 系统中的 Discordian 系统相比，

659
00:26:59,820 --> 00:27:01,020
记住您只是附加到

660
00:27:01,020 --> 00:27:02,790
正确的头部日志缓冲区，并且在某些时候

661
00:27:02,790 --> 00:27:04,740
缓冲区已满或

662
00:27:04,740 --> 00:27:06,240
在您执行机组提交时超时，然后

663
00:27:06,240 --> 00:27:07,830
您的所有日志记录都会刷新到磁盘，

664
00:27:07,830 --> 00:27:09,330
即使那样

665
00:27:09,330 --> 00:27:11,730
在 Hecate 的情况下，事务可能尚未提交

666
00:27:11,730 --> 00:27:13,740
，它们将缓冲

667
00:27:13,740 --> 00:27:15,840
内存中的所有日志权限，并且仅

668
00:27:15,840 --> 00:27:17,760
在事务实际提交时才将它们刷新

669
00:27:17,760 --> 00:27:19,470
，这意味着发生了

670
00:27:19,470 --> 00:27:21,300
崩溃，你回来了，你不会看到

671
00:27:21,300 --> 00:27:22,920
来自确实发生但未提交的交易的任何日志记录

672
00:27:22,920 --> 00:27:24,870
您将

673
00:27:24,870 --> 00:27:25,920
看到所有内容 您将看到所有

674
00:27:25,920 --> 00:27:29,160
整体记录 您还看到我们

675
00:27:29,160 --> 00:27:30,120
所有的客人都只参与了已提交的

676
00:27:30,120 --> 00:27:32,550
交易 然后我们进行通信 我们

677
00:27:32,550 --> 00:27:33,720
将我们的事务状态设置为已提交

678
00:27:33,720 --> 00:27:36,030
我们现在通过并更新我们的版本

679
00:27:36,030 --> 00:27:38,280
时间戳以翻转开始

680
00:27:38,280 --> 00:27:40,380
时间戳和结束时间现在是

681
00:27:40,380 --> 00:27:42,840
事务提交时间戳然后

682
00:27:42,840 --> 00:27:44,280
在我们完成时我们将我们设置为

683
00:27:44,280 --> 00:27:45,570
终止和 我们稍后会得到清理，

684
00:27:45,570 --> 00:27:49,200
所以让我们讨论一下

685
00:27:49,200 --> 00:27:51,660
这是用于跟踪的元数据，

686
00:27:51,660 --> 00:27:52,890
因为这对于

687
00:27:52,890 --> 00:27:54,210
理解我们如何实际保持消毒

688
00:27:54,210 --> 00:27:56,550
能力很重要，因此对于读取集和

689
00:27:56,550 --> 00:27:57,900
正确的集，这些是我的

690
00:27:57,900 --> 00:27:59,760
物理顶点 指向

691
00:27:59,760 --> 00:28:03,210
我访问或创建的内存中的物理原始数据

692
00:28:03,210 --> 00:28:05,430
，对于访问一个，它将

693
00:28:05,430 --> 00:28:06,720


694
00:28:06,720 --> 00:28:09,240
返回我生成的物理版本，返回到

695
00:28:09,240 --> 00:28:12,300
我用来执行查询的访问方法，所以

696
00:28:12,300 --> 00:28:14,850
这就像说我 有一个

697
00:28:14,850 --> 00:28:17,160
原始链，我知道其中的三个

698
00:28:17,160 --> 00:28:19,110
版本访问方法会

699
00:28:19,110 --> 00:28:20,760
在想要取回

700
00:28:20,760 --> 00:28:22,320
元组时进行扫描，它只会取回一个

701
00:28:22,320 --> 00:28:24,750
版本，因此我的重置不包含

702
00:28:24,750 --> 00:28:26,220
前两个版本 我看过的那些

703
00:28:26,220 --> 00:28:27,540
对我来说是不可见的我不关心

704
00:28:27,540 --> 00:28:29,670
那些我然后返回

705
00:28:29,670 --> 00:28:32,970
给查询执行器的那个现在在我的

706
00:28:32,970 --> 00:28:35,130
查询计划中一个版本可能会被

707
00:28:35,130 --> 00:28:36,360
修剪掉，就像它被送入一个

708
00:28:36,360 --> 00:28:38,040
关节一样 操作符和连接操作符

709
00:28:38,040 --> 00:28:39,330
说我不需要这个来绑定它把

710
00:28:39,330 --> 00:28:41,340
它扔掉我仍然需要正确地了解它

711
00:28:41,340 --> 00:28:43,110
我即使它没有产生

712
00:28:43,110 --> 00:28:44,580
管或查询的最终结果

713
00:28:44,580 --> 00:28:46,770
因为我把它给了我的访问

714
00:28:46,770 --> 00:28:49,370
方法我 我是否必须返回它，

715
00:28:49,370 --> 00:28:53,550
然后扫描集将成为这样的东西

716
00:28:53,550 --> 00:28:55,170
，就像它是

717
00:28:55,170 --> 00:28:57,360
我们重新执行扫描操作所需的最低限度的信息，

718
00:28:57,360 --> 00:29:00,090
所以

719
00:29:00,090 --> 00:29:01,920
它只是查询的 where 子句

720
00:29:01,920 --> 00:29:04,620
以及正在发生的事情 发生在我们的

721
00:29:04,620 --> 00:29:05,770
验证中，我们将

722
00:29:05,770 --> 00:29:07,810
基本上只是重新执行

723
00:29:07,810 --> 00:29:10,120
一次扫描，看看我们是否

724
00:29:10,120 --> 00:29:12,460
得到相同的结果，因为如果我们没有

725
00:29:12,460 --> 00:29:13,750
得到相同的结果，那么我们就知道

726
00:29:13,750 --> 00:29:15,130
有人插入了幻影，或者 删除了

727
00:29:15,130 --> 00:29:17,560
一些东西，因为你知道自从

728
00:29:17,560 --> 00:29:19,600
我们 tarted，因此我们知道您会

729
00:29:19,600 --> 00:29:21,040
返回不同的结果，

730
00:29:21,040 --> 00:29:22,270
因此我们有边界事务，

731
00:29:22,270 --> 00:29:24,010
因为

732
00:29:24,010 --> 00:29:25,270
如果我们在较低的隔离级别下运行，这将违反可序列化的订单，

733
00:29:25,270 --> 00:29:26,770
我们不关心这一点，

734
00:29:26,770 --> 00:29:31,180
但首先是可用性我们做是的

735
00:29:31,180 --> 00:29:35,200
何时和进行验证是正确的，

736
00:29:35,200 --> 00:29:38,710
所以我正在检查我的读取集以

737
00:29:38,710 --> 00:29:42,360
查看我是否访问了

738
00:29:42,360 --> 00:29:44,560
来自未提交事务的任何内容，并且您

739
00:29:44,560 --> 00:29:46,420
知道它们是否提交，然后

740
00:29:46,420 --> 00:29:48,220
我再次运行我的扫描以确定是否

741
00:29:48,220 --> 00:29:49,930
我会第二次运行它，如果我不这样做，我会得到

742
00:29:49,930 --> 00:29:51,400
相同的结果吗然后我知道

743
00:29:51,400 --> 00:29:55,900
有一个风扇并且我中止所以你可能

744
00:29:55,900 --> 00:29:57,160
认为这有点严厉，

745
00:29:57,160 --> 00:29:59,140
就像我的扫描读取十亿次民意调查

746
00:29:59,140 --> 00:30:01,360
一样 当我进行验证时，我将

747
00:30:01,360 --> 00:30:07,390
再次读取 10 亿个元组 是的 所以这

748
00:30:07,390 --> 00:30:10,390
只是元数据 这是

749
00:30:10,390 --> 00:30:11,680
轨道上的元数据 为了做到

750
00:30:11,680 --> 00:30:14,800
这一点，如果我有写写冲突，董事会将在这里或

751
00:30:14,800 --> 00:30:16,120
实际上在这里

752
00:30:16,120 --> 00:30:16,510
发生

753
00:30:16,510 --> 00:30:18,310
我得让自己厌烦 离开，如果在验证下，

754
00:30:18,310 --> 00:30:20,170
就像我再次扫描一样，我得到了

755
00:30:20,170 --> 00:30:26,050
不同的结果，然后我把自己杀死了

756
00:30:26,050 --> 00:30:28,780


757
00:30:28,780 --> 00:30:30,070


758
00:30:30,070 --> 00:30:31,780


759
00:30:31,780 --> 00:30:33,130
然后垃圾破解者会

760
00:30:33,130 --> 00:30:34,150
通过并清理任何版本

761
00:30:34,150 --> 00:30:39,400
不应该是好的，是的，

762
00:30:39,400 --> 00:30:42,660
可能毫无疑问

763
00:30:46,200 --> 00:30:50,679
，酷儿呼叫赞助商是的，所以

764
00:30:50,679 --> 00:30:52,120
where 子句包含谓词，

765
00:30:52,120 --> 00:30:54,100
谓词就像等于一和

766
00:30:54,100 --> 00:30:56,440
B 等于这八个

767
00:30:56,440 --> 00:30:59,700
中的每一个，我称之为谓词它

768
00:30:59,700 --> 00:31:05,049
只是谓词集，好吧，

769
00:31:05,049 --> 00:31:06,340
然后提交并看看他在

770
00:31:06,340 --> 00:31:08,679
这里问的是什么，这基本上

771
00:31:08,679 --> 00:31:10,900
是所有交易的列表，正在

772
00:31:10,900 --> 00:31:12,490
等待我的交易 提交是因为

773
00:31:12,490 --> 00:31:13,870
他们在我提交之前阅读了我写的东西，

774
00:31:13,870 --> 00:31:15,940
所以想想这就像一个

775
00:31:15,940 --> 00:31:18,850
发布/订阅系统，比如事务读取我

776
00:31:18,850 --> 00:31:21,190
未提交的数据，然后他们订阅

777
00:31:21,190 --> 00:31:23,919
我的你知道提交通知，无论

778
00:31:23,919 --> 00:31:26,020
我是否会完成，然后如果我

779
00:31:26,020 --> 00:31:27,820
提交，我和我读了一些

780
00:31:27,820 --> 00:31:29,080
你写的东西，你已经提交了，但

781
00:31:29,080 --> 00:31:30,400
我需要等待看看你是否提交，

782
00:31:30,400 --> 00:31:37,270
因为我可以提交是的，问题是

783
00:31:37,270 --> 00:31:38,350
我会使用提交时间戳来

784
00:31:38,350 --> 00:31:40,299
做出反应，所以你可以是的，你必须，因为

785
00:31:40,299 --> 00:31:41,590
就好像我正在安装所有东西的时候一样，

786
00:31:41,590 --> 00:31:56,919
你可以

787
00:31:56,919 --> 00:31:58,030
在提交

788
00:31:58,030 --> 00:32:04,720
提交提交时间戳中有一个依赖的圆圈

789
00:32:04,720 --> 00:32:06,040
吗？因为当你第

790
00:32:06,040 --> 00:32:08,830
一次读到一堆东西时，

791
00:32:08,830 --> 00:32:11,320
我的意思是我在你之前，但我 还没有

792
00:32:11,320 --> 00:32:13,870
提交所以你看不到

793
00:32:13,870 --> 00:32:17,320
我自己是的，如果你的时间戳

794
00:32:17,320 --> 00:32:18,850
比我的大，那么我不会然后你

795
00:32:18,850 --> 00:32:20,650
写一些表格我不会读它是的所以

796
00:32:20,650 --> 00:32:24,640
它总是一个方向，所以

797
00:32:24,640 --> 00:32:27,400
在见鬼

798
00:32:27,400 --> 00:32:30,100
他们实际上提出了时间论文，并评估

799
00:32:30,100 --> 00:32:31,690


800
00:32:31,690 --> 00:32:33,040
了我刚刚描述的乐观和悲观版本 如此

801
00:32:33,040 --> 00:32:34,059
乐观是我们已经

802
00:32:34,059 --> 00:32:35,559
再次讨论的内容 关键是在这里

803
00:32:35,559 --> 00:32:37,630
为了确保序列化能力 我必须

804
00:32:37,630 --> 00:32:39,460
通过以下方式检查幻影 重新运行 我

805
00:32:39,460 --> 00:32:42,460
在提交时进行扫描，因此当您下载

806
00:32:42,460 --> 00:32:44,679
续集服务器并运行它并

807
00:32:44,679 --> 00:32:46,030
在每个表中运行它时，这实际上

808
00:32:46,030 --> 00:32:47,530
就是您得到的，但他们还实现了

809
00:32:47,530 --> 00:32:48,880
基于两阶段锁定的悲观版本

810
00:32:48,880 --> 00:32:52,000
以及要理解的主要内容

811
00:32:52,000 --> 00:32:53,500
是因为他们没有

812
00:32:53,500 --> 00:32:55,059
验证阶段，因为他们

813
00:32:55,059 --> 00:32:58,059
要进行索引锁，并且您知道共享

814
00:32:58,059 --> 00:32:58,940
锁是排他锁

815
00:32:58,940 --> 00:33:00,830
以避免任何幻影，并且他们有一个

816
00:33:00,830 --> 00:33:03,080
后台线程可以进行死锁

817
00:33:03,080 --> 00:33:05,539
检测，所以这是唯一的

818
00:33:05,539 --> 00:33:06,830
图 我想再次从论文中向您展示

819
00:33:06,830 --> 00:33:10,849
2012 年的论文，因此相

820
00:33:10,849 --> 00:33:12,049
对于我们正在谈论的其他系统而言，

821
00:33:12,049 --> 00:33:15,919
这是相当古老的，并且

822
00:33:15,919 --> 00:33:18,379
运行的恐怖有点过时了主要

823
00:33:18,379 --> 00:33:20,029
内容再次是当您扩大规模

824
00:33:20,029 --> 00:33:21,979
时

825
00:33:21,979 --> 00:33:23,210
此类高或有工作负载的线程数只有

826
00:33:23,210 --> 00:33:25,429
一千个元组悲观

827
00:33:25,429 --> 00:33:28,489
版本比乐观版本更糟糕，

828
00:33:28,489 --> 00:33:30,799
并且间隙伙伴可能看起来不多，

829
00:33:30,799 --> 00:33:32,090
但如果您查看

830
00:33:32,090 --> 00:33:35,629
此处的数字，那就是 这是

831
00:33:35,629 --> 00:33:38,269
乐观版本每秒最多执行 150

832
00:33:38,269 --> 00:33:40,129
万个事务，

833
00:33:40,129 --> 00:33:42,019
然后悲观版本每秒执行 120 万个

834
00:33:42,019 --> 00:33:43,970


835
00:33:43,970 --> 00:33:45,950
事务，因此差异是每秒 300,000 个事务，这

836
00:33:45,950 --> 00:33:48,529
实际上很多，所以就像运行这个特定的

837
00:33:48,529 --> 00:33:49,639
工作负载我不知道确切的

838
00:33:49,639 --> 00:33:52,129
细节 硬件，但我的亮片 po 的东西

839
00:33:52,129 --> 00:33:54,139
可能每秒最多可以完成十万

840
00:33:54,139 --> 00:33:56,869
笔交易我不知道

841
00:33:56,869 --> 00:33:58,309
你知道什么，如果你禁用日志记录可能会

842
00:33:58,309 --> 00:34:00,440
快一点但你知道这很

843
00:34:00,440 --> 00:34:02,210
漂亮所以这是一条法律，即使

844
00:34:02,210 --> 00:34:03,710
相对于 其中两个

845
00:34:03,710 --> 00:34:07,129
似乎不太对，所以这篇

846
00:34:07,129 --> 00:34:08,418
论文基本上是这样说的哦

847
00:34:08,418 --> 00:34:10,129
，内存中和

848
00:34:10,129 --> 00:34:11,809
多版本系统的乐观方法是要走的路，

849
00:34:11,809 --> 00:34:16,909
而不是悲观的方法，好吧，

850
00:34:16,909 --> 00:34:18,500
那么哪里有人外卖我们

851
00:34:18,500 --> 00:34:20,629
可以从 Hecate 开始，所以从设计的

852
00:34:20,629 --> 00:34:22,719
角度来看，他们谈到拥有

853
00:34:22,719 --> 00:34:24,859
这张全球地图来跟踪

854
00:34:24,859 --> 00:34:26,179
他们要笑的每件事的状态。

855
00:34:26,179 --> 00:34:27,739


856
00:34:27,739 --> 00:34:29,109
一个人会做第一个作家获胜，

857
00:34:29,109 --> 00:34:31,429
但是

858
00:34:31,429 --> 00:34:32,869
他们讨论的论文中出现的一些事情说，

859
00:34:32,869 --> 00:34:34,879
就像您在内存系统中的设计一样

860
00:34:34,879 --> 00:34:36,260
，您应该

861
00:34:36,260 --> 00:34:38,029
首先遵循某种租户，他们说

862
00:34:38,029 --> 00:34:40,159
您只想使用锁 对于您的 lat

863
00:34:40,159 --> 00:34:42,049
树数据结构，这意味着没有

864
00:34:42,049 --> 00:34:43,879
闩锁而不是自旋锁没有关键

865
00:34:43,879 --> 00:34:45,230
部分所有内容都应该始终

866
00:34:45,230 --> 00:34:47,839
写入并且采用无锁方法

867
00:34:47,839 --> 00:34:48,949
这将是免费索引您的

868
00:34:48,949 --> 00:34:50,418
事务映射内存分配器

869
00:34:50,418 --> 00:34:52,789
垃圾收集器所以我只是同意

870
00:34:52,789 --> 00:34:54,918
除了这里的索引之外的所有内容，

871
00:34:54,918 --> 00:34:58,130
所以下周你们将

872
00:34:58,130 --> 00:35:00,200
阅读 BW 树，这是他们构建的很多免费

873
00:35:00,200 --> 00:35:02,000
索引，并且是

874
00:35:02,000 --> 00:35:04,220
黑客马拉松项目的一部分，我们和他们

875
00:35:04,220 --> 00:35:07,609
实施了同样的事情，它得到

876
00:35:07,609 --> 00:35:11,300
它不是废话，但是 它新的

877
00:35:11,300 --> 00:35:13,610
两个索引仍然使用

878
00:35:13,610 --> 00:35:16,760
传统的锁定技术，

879
00:35:16,760 --> 00:35:18,380
就像 Hecate 反演开始的方式一样，它们

880
00:35:18,380 --> 00:35:20,180
全部采用跳过列表跳过列表作为

881
00:35:20,180 --> 00:35:21,920
无步行数据结构 那种对

882
00:35:21,920 --> 00:35:24,620
Kabbalistic B+ 流的看法，

883
00:35:24,620 --> 00:35:26,090
你可以免锁，所以在

884
00:35:26,090 --> 00:35:27,320
原始版本中，他们的 Hecate

885
00:35:27,320 --> 00:35:28,580
就像跳过列表一样，

886
00:35:28,580 --> 00:35:30,800
这就是他们设计系统的方式，然后

887
00:35:30,800 --> 00:35:32,600
他们说实际上跳过列表或废话你

888
00:35:32,600 --> 00:35:35,270
实际上想要使用 BW 树，但即使

889
00:35:35,270 --> 00:35:36,710
那样 B 双树也会输给

890
00:35:36,710 --> 00:35:38,840
你知道常规的 P 加树这

891
00:35:38,840 --> 00:35:40,160
是你最终为

892
00:35:40,160 --> 00:35:42,140
第二个项目构建的所以它也很

893
00:35:42,140 --> 00:35:43,730
有趣这个数据库

894
00:35:43,730 --> 00:35:45,170
系统在那里 这在跳过列表上非常重要，

895
00:35:45,170 --> 00:35:48,020
他的 mem 续集是正确的，

896
00:35:48,020 --> 00:35:49,220
原因是因为

897
00:35:49,220 --> 00:35:51,050


898
00:35:51,050 --> 00:35:52,850


899
00:35:52,850 --> 00:35:54,110
当 hecatomb 项目正在进行时，联合创始人和续集的那个人当时在微软工作在续集服务器

900
00:35:54,110 --> 00:35:55,940
上，他看到了这些

901
00:35:55,940 --> 00:35:57,590
内部谈话 来自 Paul Larsen 和

902
00:35:57,590 --> 00:35:59,000
Mike 的意愿 这两个领导

903
00:35:59,000 --> 00:36:00,980
黑客马拉松项目的人在项目的一

904
00:36:00,980 --> 00:36:02,630
开始他们就像跳过

905
00:36:02,630 --> 00:36:04,100
了要走的路的清单 这是你

906
00:36:04,100 --> 00:36:06,440
应该使用的所以 mem Siegel 人看到

907
00:36:06,440 --> 00:36:08,450
了 d 然后你知道

908
00:36:08,450 --> 00:36:10,100
在他离开并完成续集时借用这些想法但是

909
00:36:10,100 --> 00:36:11,540
他错过了

910
00:36:11,540 --> 00:36:13,490
谈话的后半部分基本说跳过列表是废话

911
00:36:13,490 --> 00:36:16,310
而且你想使用BW但我

912
00:36:16,310 --> 00:36:18,200
认为今天仍然像MEMC go

913
00:36:18,200 --> 00:36:21,440
跳过列表仍然很大，但

914
00:36:21,440 --> 00:36:23,210
研究表明那是垃圾，

915
00:36:23,210 --> 00:36:27,860
所以我想说就像房子是你几乎

916
00:36:27,860 --> 00:36:30,320
做的，除了非常罕见的例外，你永远

917
00:36:30,320 --> 00:36:31,640
不想使用跳过列表，就像

918
00:36:31,640 --> 00:36:33,020
有些情况不喜欢内存中的

919
00:36:33,020 --> 00:36:35,360
东西一样 那个小的跳过列表可能没问题，

920
00:36:35,360 --> 00:36:37,670
我只是有一些不错的

921
00:36:37,670 --> 00:36:39,560
内存碎片属性，但总的来说，

922
00:36:39,560 --> 00:36:41,840
索引将涵盖这一点，你知道下周所有的

923
00:36:41,840 --> 00:36:42,170


924
00:36:42,170 --> 00:36:43,640
跳过列表都是一个坏主意，不要去不要

925
00:36:43,640 --> 00:36:45,200
使用那个，不要使用 P Double

926
00:36:45,200 --> 00:36:47,120
Tree 即使我们仍在使用我们仍然可以

927
00:36:47,120 --> 00:36:48,860
使用它

928
00:36:48,860 --> 00:36:50,120
他们谈论的另一件有趣的事情

929
00:36:50,120 --> 00:36:53,060
是，我同意这一点

930
00:36:53,060 --> 00:36:55,430
，即您应该真正知道您

931
00:36:55,430 --> 00:36:56,600
想要最小化

932
00:36:56,600 --> 00:36:57,800
文明点或瓶颈

933
00:36:57,800 --> 00:36:59,720
点的数量 在系统和 t

934
00:36:59,720 --> 00:37:01,310
在黑客马拉松的情况下，你唯一需要这样做的地方

935
00:37:01,310 --> 00:37:03,290
是当你分发

936
00:37:03,290 --> 00:37:04,880
开始时开始提交时间戳，

937
00:37:04,880 --> 00:37:06,380
因为这些总是需要

938
00:37:06,380 --> 00:37:07,820
单调增加，你不能

939
00:37:07,820 --> 00:37:10,040
你不能放弃安抚时间戳，

940
00:37:10,040 --> 00:37:12,260
所以他们的方式 这样做是通过

941
00:37:12,260 --> 00:37:13,790
比较和交换原子加法

942
00:37:13,790 --> 00:37:15,500
正确的单指令将一个添加

943
00:37:15,500 --> 00:37:18,200
到计数器的文件中你们让

944
00:37:18,200 --> 00:37:22,190
读上节课我们展示了如果这种

945
00:37:22,190 --> 00:37:24,050
方法你能知道真正高的核心

946
00:37:24,050 --> 00:37:25,100
数可以获得最大

947
00:37:25,100 --> 00:37:27,320
可能就像你知道一百

948
00:37:27,320 --> 00:37:28,820
一秒钟几百万次这样你可以尝试

949
00:37:28,820 --> 00:37:31,250
在我们当前的系统中批量处理这些东西

950
00:37:31,250 --> 00:37:34,850
我们我们实际上不这样做我们做

951
00:37:34,850 --> 00:37:36,560
我们超级做的事情，在这种

952
00:37:36,560 --> 00:37:38,780
情况下实际上有一个围绕某种关键的自旋锁

953
00:37:38,780 --> 00:37:40,490
部分，所以

954
00:37:40,490 --> 00:37:41,600
如果黑客马拉松没有这个问题，

955
00:37:41,600 --> 00:37:42,620
他们只是分发这些时间戳

956
00:37:42,620 --> 00:37:48,800
数组，效率高，好吧好吧，

957
00:37:48,800 --> 00:37:51,140
Hecate 我花了你知道前

958
00:37:51,140 --> 00:37:52,490
四十分钟谈论它，

959
00:37:52,490 --> 00:37:53,780
因为这就是我的意思 这

960
00:37:53,780 --> 00:37:55,940
是现在了解

961
00:37:55,940 --> 00:37:57,410


962
00:37:57,410 --> 00:38:00,770
多版本控制的所有现代实现或变体的基线，

963
00:38:00,770 --> 00:38:01,970
以便我们可以进行一些观察，

964
00:38:01,970 --> 00:38:03,640
现在关于 Hecate on

965
00:38:03,640 --> 00:38:05,780
架构的外观以及一些挑战和他们将

966
00:38:05,780 --> 00:38:06,650
遇到的

967
00:38:06,650 --> 00:38:08,210
瓶颈 当

968
00:38:08,210 --> 00:38:09,500
我们查看 OTP 以外的其他工作负载时面临

969
00:38:09,500 --> 00:38:12,290
的第一件事

970
00:38:12,290 --> 00:38:13,460
就是我已经提到的，

971
00:38:13,460 --> 00:38:16,790


972
00:38:16,790 --> 00:38:18,410
如果我们的

973
00:38:18,410 --> 00:38:20,470
事务访问大量数据，那么

974
00:38:20,470 --> 00:38:22,580
通常情况下，重置并因此可以设置验证将非常昂贵 你知道的油是工作负载

975
00:38:22,580 --> 00:38:24,710
交易更新可能有

976
00:38:24,710 --> 00:38:27,080
几十个元组或作为一对夫妇

977
00:38:27,080 --> 00:38:28,490
钻研碗所以在这种情况下

978
00:38:28,490 --> 00:38:29,960
它们是扫描端或重置

979
00:38:29,960 --> 00:38:31,280
将非常小所以我们可以

980
00:38:31,280 --> 00:38:33,500
非常快速地进行验证但是现在如果 我正在

981
00:38:33,500 --> 00:38:35,180
运行分析查询，我

982
00:38:35,180 --> 00:38:37,130
扫描整个表，我的表现在有 10 亿个

983
00:38:37,130 --> 00:38:39,950
元组，当我进行验证时，

984
00:38:39,950 --> 00:38:41,540
我必须再次阅读一个构建两个民意调查的内容

985
00:38:41,540 --> 00:38:42,080


986
00:38:42,080 --> 00:38:43,730
，然后 将需要很

987
00:38:43,730 --> 00:38:47,090
长时间，下一个问题

988
00:38:47,090 --> 00:38:48,560
是他们

989
00:38:48,560 --> 00:38:51,590
使用的最旧和最新的仅附加版本

990
00:38:51,590 --> 00:38:53,780
对 OLAP 扫描不利，因为现在当我

991
00:38:53,780 --> 00:38:55,820
沿着版本链扫描时，我

992
00:38:55,820 --> 00:38:57,530
阅读一堆我可能不需要的东西

993
00:38:57,530 --> 00:38:58,790
只是为了获得

994
00:38:58,790 --> 00:39:00,710
我真正想让你知道的版本，这

995
00:39:00,710 --> 00:39:01,850
取决于我进行垃圾收集的速度，

996
00:39:01,850 --> 00:39:04,430
版本更改可能会变得很长，并且

997
00:39:04,430 --> 00:39:05,870
所有这些指针链接追逐和

998
00:39:05,870 --> 00:39:07,940
分支都会发生 在现代 CPU 架构上很糟糕，

999
00:39:07,940 --> 00:39:09,980
因为它们

1000
00:39:09,980 --> 00:39:11,690
会有这些长指令管道，所以

1001
00:39:11,690 --> 00:39:13,280
现在如果我错过了分支上的预测，

1002
00:39:13,280 --> 00:39:15,020
我必须刷新我的管道并将

1003
00:39:15,020 --> 00:39:16,490
所有东西取回，我将长时间

1004
00:39:16,490 --> 00:39:20,140
停顿，最后一个问题将是

1005
00:39:20,140 --> 00:39:22,430
与 Hecate 一起，他们正在做

1006
00:39:22,430 --> 00:39:25,010
粗粒度的冲突检测并

1007
00:39:25,010 --> 00:39:27,050
确定您是否有一个复杂

1008
00:39:27,050 --> 00:39:29,540
的事务例程，所以我的

1009
00:39:29,540 --> 00:39:31,400
意思是他们所做的就是

1010
00:39:31,400 --> 00:39:33,140
确定是否存在冲突

1011
00:39:33,140 --> 00:39:36,620
只是指针是否存在您

1012
00:39:36,620 --> 00:39:38,540
知道吗，我认为你知道

1013
00:39:38,540 --> 00:39:38,960


1014
00:39:38,960 --> 00:39:41,630
在我尝试阅读的版本之后是否还有另一个版本，所以

1015
00:39:41,630 --> 00:39:44,270
现在让我们说，尽管我

1016
00:39:44,270 --> 00:39:46,700
有一个包含一千个元组的表，并且我的事务

1017
00:39:46,700 --> 00:39:49,010
读取读取其中一个我很抱歉我的

1018
00:39:49,010 --> 00:39:51,020
交易权限 其中你的

1019
00:39:51,020 --> 00:39:53,299
交易读取了另外 999 个

1020
00:39:53,299 --> 00:39:55,670
你没有阅读我写的那个，但

1021
00:39:55,670 --> 00:39:57,200
现在我认为它是一种阅读规范，

1022
00:39:57,200 --> 00:39:59,510
因为你阅读了我创建的一个版本，

1023
00:39:59,510 --> 00:40:01,910
但你实际上没有阅读我写的

1024
00:40:01,910 --> 00:40:03,799
部分 我修改的数据，

1025
00:40:03,799 --> 00:40:06,380
如果我中止，你也必须工作，

1026
00:40:06,380 --> 00:40:08,029
因为数据库 sim

1027
00:40:08,029 --> 00:40:10,250
对你阅读的内容一无所知，只知道你阅读了

1028
00:40:10,250 --> 00:40:11,630


1029
00:40:11,630 --> 00:40:12,740
由另一个事务创建的版本，该

1030
00:40:12,740 --> 00:40:14,450
事务中止了它，因此你

1031
00:40:14,450 --> 00:40:18,289
有 工作太正确所以

1032
00:40:18,289 --> 00:40:19,520
又如此 我们正在做这次访问 我们

1033
00:40:19,520 --> 00:40:21,500
只是存在 指针

1034
00:40:21,500 --> 00:40:22,700
足以说明你读

1035
00:40:22,700 --> 00:40:24,680
了我写的东西 但

1036
00:40:24,680 --> 00:40:28,400
内部没有什么 没有什么更细粒度

1037
00:40:28,400 --> 00:40:30,980
所以超级 系统再次这是

1038
00:40:30,980 --> 00:40:33,260
离开欧盟慕尼黑，这就是

1039
00:40:33,260 --> 00:40:34,730
我提到的德国人哦，德国人在

1040
00:40:34,730 --> 00:40:35,779
打败我们，我们必须更加努力地工作，

1041
00:40:35,779 --> 00:40:37,490
因为德国人是这些德国人，

1042
00:40:37,490 --> 00:40:39,410
他们非常优秀，所以 hyper 是第一个

1043
00:40:39,410 --> 00:40:42,920
提交的数据，他们建立了一个

1044
00:40:42,920 --> 00:40:44,630
-使用 Delta 记录

1045
00:40:44,630 --> 00:40:46,609
版本控制的内存列存储从最新到最旧

1046
00:40:46,609 --> 00:40:49,930
，他们要做的是

1047
00:40:49,930 --> 00:40:52,880
支持更细粒度的

1048
00:40:52,880 --> 00:40:55,520
冲突检测，然后 Hecate on

1049
00:40:55,520 --> 00:40:57,920
可以做什么，我们将看到我们如何做到这

1050
00:40:57,920 --> 00:41:00,319
一点 他们也会

1051
00:41:00,319 --> 00:41:01,579
通过说第一个

1052
00:41:01,579 --> 00:41:04,609
作者获胜然后其他人来避免写写复杂，

1053
00:41:04,609 --> 00:41:06,109
你认为我们讨论过

1054
00:41:06,109 --> 00:41:07,369
最后一个类的结束就像他们将

1055
00:41:07,369 --> 00:41:10,130
在多版本系统中处理索引的方式那样

1056
00:41:10,130 --> 00:41:12,980
，无论何时你

1057
00:41:12,980 --> 00:41:13,579


1058
00:41:13,579 --> 00:41:16,670
如果您要更新的属性是

1059
00:41:16,670 --> 00:41:18,619
我们的索引，但您知道在某些

1060
00:41:18,619 --> 00:41:21,410
索引中，则对元组进行更新，那么您必须在索引中删除，

1061
00:41:21,410 --> 00:41:24,200
然后插入正确

1062
00:41:24,200 --> 00:41:25,940
，否则您必须维护

1063
00:41:25,940 --> 00:41:27,529
这些不同的版本信息

1064
00:41:27,529 --> 00:41:29,420
在索引中指向这

1065
00:41:29,420 --> 00:41:32,630
两个 I 并且它变得非常痛苦，所以

1066
00:41:32,630 --> 00:41:34,099
你把它当作一个按答案删除

1067
00:41:34,099 --> 00:41:35,770
，这解决了这个问题，

1068
00:41:35,770 --> 00:41:38,839
所以让我们在这里看一个例子，所以

1069
00:41:38,839 --> 00:41:41,270
他们再次进行增量存储，这是一个

1070
00:41:41,270 --> 00:41:44,420
列风暴所以他们在每个

1071
00:41:44,420 --> 00:41:45,980
元组块内他们将

1072
00:41:45,980 --> 00:41:47,270
维护一个称为 Virgen 向量的特殊列

1073
00:41:47,270 --> 00:41:49,579
，这个版本向量

1074
00:41:49,579 --> 00:41:52,820
现在将指向我们将要为

1075
00:41:52,820 --> 00:41:54,800
每个线程或每个事务分配的增量存储

1076
00:41:54,800 --> 00:41:56,960
维护

1077
00:41:56,960 --> 00:41:59,090
我们为你

1078
00:41:59,090 --> 00:42:01,190
知道的这个特定元组的所有更新，所以如果

1079
00:42:01,190 --> 00:42:02,930
指针为空，我们知道这

1080
00:42:02,930 --> 00:42:04,550
是这个元组最新版本中的主版本

1081
00:42:04,550 --> 00:42:05,300


1082
00:42:05,300 --> 00:42:08,720
，没有你知道

1083
00:42:08,720 --> 00:42:10,100
我们不需要其他版本 检查

1084
00:42:10,100 --> 00:42:12,320
指针是否不为空，然后如果我们需要

1085
00:42:12,320 --> 00:42:13,640
返回并尝试找到一个早期版本，

1086
00:42:13,640 --> 00:42:14,900
我们只需沿着该指针进行操作，然后

1087
00:42:14,900 --> 00:42:17,210
查看我们的交易红色空间内部，这

1088
00:42:17,210 --> 00:42:19,730
与 Hector

1089
00:42:19,730 --> 00:42:21,020
Tom 所说的内容有关 不想 任何

1090
00:42:21,020 --> 00:42:22,220
你不想要

1091
00:42:22,220 --> 00:42:24,770
任何全局内存空间的全局数据结构，这个 Delta

1092
00:42:24,770 --> 00:42:26,000
存储将基于每个线程，

1093
00:42:26,000 --> 00:42:28,700
所以当我

1094
00:42:28,700 --> 00:42:30,470
为我的线程和线程本地存储分配一堆空间时，

1095
00:42:30,470 --> 00:42:32,600
我不担心

1096
00:42:32,600 --> 00:42:34,220
竞争到 其他线程的内存分配器，

1097
00:42:34,220 --> 00:42:35,480
因为该空间是

1098
00:42:35,480 --> 00:42:36,340
从我那里分配的，

1099
00:42:36,340 --> 00:42:38,480
尽管线程可以读取我的内存

1100
00:42:38,480 --> 00:42:40,190
，这很好，但没有其他人可以

1101
00:42:40,190 --> 00:42:41,870
写入它，但我和那个声音没有

1102
00:42:41,870 --> 00:42:43,460
对我们在这里拥有的任何内部数据结构进行任何闩锁，

1103
00:42:43,460 --> 00:42:46,670
所以现在如果 我

1104
00:42:46,670 --> 00:42:48,080
有另一个事务

1105
00:42:48,080 --> 00:42:50,720
想要做一个更新，所以

1106
00:42:50,720 --> 00:42:52,580
说它想要更新 Tupac 元组，所以

1107
00:42:52,580 --> 00:42:53,990
我们要做的第一件事就是

1108
00:42:53,990 --> 00:42:56,720
复制我们要修改的属性，

1109
00:42:56,720 --> 00:42:58,280
所以我们要修改 属性

1110
00:42:58,280 --> 00:43:00,410
二所以他把旧值放在这里

1111
00:43:00,410 --> 00:43:02,360
然后我们更新我们的指针现在

1112
00:43:02,360 --> 00:43:04,310
指向以前的

1113
00:43:04,310 --> 00:43:06,620
版本然后我们可以继续进行

1114
00:43:06,620 --> 00:43:08,420
比较和交换安装我们的版本

1115
00:43:08,420 --> 00:43:12,890
向量并更新我们的值同样的

1116
00:43:12,890 --> 00:43:14,360
事情 对于下一个人，我们更新

1117
00:43:14,360 --> 00:43:16,520
这个表，没有旧版本，所以

1118
00:43:16,520 --> 00:43:18,290
我们的指针不指向任何我们

1119
00:43:18,290 --> 00:43:20,540
在这里复制旧值的东西，它在

1120
00:43:20,540 --> 00:43:23,270
那里更新了版本指针，所以在我们

1121
00:43:23,270 --> 00:43:25,520
当前的系统中，我们以同样的方式做，

1122
00:43:25,520 --> 00:43:27,970
但是我们 实际上，这一切都是以无

1123
00:43:27,970 --> 00:43:30,410
闩锁的方式完成的，这会有点

1124
00:43:30,410 --> 00:43:33,170
棘手，以确保

1125
00:43:33,170 --> 00:43:34,100
当您有两条线索时，您将获得正确的版本，

1126
00:43:34,100 --> 00:43:35,990
我们

1127
00:43:35,990 --> 00:43:38,540
现在可以在 Hecate 中忽略这一点，因为

1128
00:43:38,540 --> 00:43:40,670
他们实际上是有闩锁的 在整个

1129
00:43:40,670 --> 00:43:42,950
元组块上，它们每个块

1130
00:43:42,950 --> 00:43:45,710
都像 1024 个元组，所以在这种情况下

1131
00:43:45,710 --> 00:43:47,450
，我拿了正确的闩锁

1132
00:43:47,450 --> 00:43:48,950
和整个东西，我不担心

1133
00:43:48,950 --> 00:43:50,930
其他人出现并阅读

1134
00:43:50,930 --> 00:43:53,150
一些东西，而我是一个

1135
00:43:53,150 --> 00:43:55,940
我们系统中的中间状态，因为删除很

1136
00:43:55,940 --> 00:43:58,550
棘手，我们知道我们做了一些额外的

1137
00:43:58,550 --> 00:44:01,370
事情来使这一切变得不那么自由，但

1138
00:44:01,370 --> 00:44:04,360
现在您不必担心，

1139
00:44:04,360 --> 00:44:06,070
好吧，hyper 真正酷的地方

1140
00:44:06,070 --> 00:44:07,540
又是它们如何“ 重新

1141
00:44:07,540 --> 00:44:08,980
做验证 确保序列化

1142
00:44:08,980 --> 00:44:11,260
建筑物，因此再次第一个作者获胜

1143
00:44:11,260 --> 00:44:13,120
，这很容易，如果我有两个

1144
00:44:13,120 --> 00:44:14,410
事务尝试更新相同的

1145
00:44:14,410 --> 00:44:16,630
事物，首先到达那里的人成功

1146
00:44:16,630 --> 00:44:19,420
而另一个人中止，

1147
00:44:19,420 --> 00:44:21,070
所以你们正在尝试阅读的论文

1148
00:44:21,070 --> 00:44:22,840
描述了如何 实际上处理这个问题，

1149
00:44:22,840 --> 00:44:24,850
这在论文中没有讨论

1150
00:44:24,850 --> 00:44:27,190
，它不是真正公开的，但

1151
00:44:27,190 --> 00:44:28,930
它们实际上没有写写

1152
00:44:28,930 --> 00:44:30,700
冲突，因为它们实际上

1153
00:44:30,700 --> 00:44:33,730
只有一个编写器线程，所以只有一个

1154
00:44:33,730 --> 00:44:35,740
线程可以一次更新事务或

1155
00:44:35,740 --> 00:44:36,940
更新 Davis 有很多 一个

1156
00:44:36,940 --> 00:44:38,830
读取器线程进行分析，但

1157
00:44:38,830 --> 00:44:40,660
没有写写冲突，因为

1158
00:44:40,660 --> 00:44:41,830
只有一个人可以

1159
00:44:41,830 --> 00:44:45,880
同时更新数据，但

1160
00:44:45,880 --> 00:44:47,200
你们阅读的协议

1161
00:44:47,200 --> 00:44:50,770
实际上会处理多个线程，所以现在

1162
00:44:50,770 --> 00:44:54,040
他们要做验证的方式

1163
00:44:54,040 --> 00:44:55,870
说你对扫描集的反应

1164
00:44:55,870 --> 00:44:57,640
是他们将使用一种

1165
00:44:57,640 --> 00:45:00,070
称为精确阻塞的技术所以这

1166
00:45:00,070 --> 00:45:03,430
真的很酷，因为这个精确

1167
00:45:03,430 --> 00:45:05,170
锁定纸凸轮 在我

1168
00:45:05,170 --> 00:45:07,900
1980 年出生之前，在这些德国人

1169
00:45:07,900 --> 00:45:09,970
拿起它之前的一段时间，它被引用了大约 40

1170
00:45:09,970 --> 00:45:13,930
次，所以一篇 30 年 40 年的论文

1171
00:45:13,930 --> 00:45:15,760
被引用了 40 次，基本上被遗忘了，

1172
00:45:15,760 --> 00:45:17,200
没有人在引用它，没有人

1173
00:45:17,200 --> 00:45:19,000
正确地阅读它，不知何故 德国人

1174
00:45:19,000 --> 00:45:21,640
挖出了这个东西，它会做什么

1175
00:45:21,640 --> 00:45:22,990
它会像一个近似的

1176
00:45:22,990 --> 00:45:25,060
谓词锁定所以我不记得

1177
00:45:25,060 --> 00:45:26,800
我们是否在介绍类中讨论过谓词锁定，

1178
00:45:26,800 --> 00:45:28,930
但基本上谓词

1179
00:45:28,930 --> 00:45:30,520
锁定是一种查看 where

1180
00:45:30,520 --> 00:45:32,410
子句和查询的方法， 弄清楚

1181
00:45:32,410 --> 00:45:35,590
它们是否拦截一切正常，对于

1182
00:45:35,590 --> 00:45:37,360
像 egos 1 和 B 等于

1183
00:45:37,360 --> 00:45:39,640
2 这样的简单情况，它们不相交这

1184
00:45:39,640 --> 00:45:42,370
不是问题，但对于更复杂的事情，它

1185
00:45:42,370 --> 00:45:44,290
变得非常困难，我认为它是

1186
00:45:44,290 --> 00:45:45,000
np-complete

1187
00:45:45,000 --> 00:45:47,950
所以精确锁定就像

1188
00:45:47,950 --> 00:45:50,140
我

1189
00:45:50,140 --> 00:45:52,240
只需要查看我实际修改的内容的近似值

1190
00:45:52,240 --> 00:45:54,280
，我修改它的元组是否

1191
00:45:54,280 --> 00:45:56,350
与我的查询

1192
00:45:56,350 --> 00:45:59,470
尝试执行的操作重叠，而不是

1193
00:45:59,470 --> 00:46:01,600
执行扫描 y 你只是

1194
00:46:01,600 --> 00:46:04,330
根据事务生成的 Delta 记录重新执行查询

1195
00:46:04,330 --> 00:46:07,480


1196
00:46:07,480 --> 00:46:08,770
，下一张幻灯片会更有意义，但

1197
00:46:08,770 --> 00:46:10,570
基本上当我的事务提交

1198
00:46:10,570 --> 00:46:12,340
进行验证时，我会查看

1199
00:46:12,340 --> 00:46:14,770
在我启动后提交的所有事务

1200
00:46:14,770 --> 00:46:17,040


1201
00:46:17,040 --> 00:46:18,840
我在运行时没有看到他们的更新，

1202
00:46:18,840 --> 00:46:20,850
因为他们

1203
00:46:20,850 --> 00:46:22,740
在我开始之前没有提交，所以我要看看

1204
00:46:22,740 --> 00:46:24,690
他们是否创建

1205
00:46:24,690 --> 00:46:27,450
了我第一次运行时应该运行的新版本，

1206
00:46:27,450 --> 00:46:30,870
所以让我们看看

1207
00:46:30,870 --> 00:46:32,310
这里有一个例子，所以说这是

1208
00:46:32,310 --> 00:46:33,780
我们想要验证的事务，它有

1209
00:46:33,780 --> 00:46:35,520
三个查询，然后有三个

1210
00:46:35,520 --> 00:46:36,870
事务已经提交，

1211
00:46:36,870 --> 00:46:38,850
所以他们

1212
00:46:38,850 --> 00:46:42,900
过去了，他们走了，我们有他们的重做

1213
00:46:42,900 --> 00:46:44,670
记录，所以这些是 同样的视频

1214
00:46:44,670 --> 00:46:45,690
记录我们无论如何都会写出磁盘

1215
00:46:45,690 --> 00:46:47,430
所以我们生成

1216
00:46:47,430 --> 00:46:49,800
这些并不是为了做这个验证我们必须

1217
00:46:49,800 --> 00:46:51,840
将它们注销到磁盘所以我们

1218
00:46:51,840 --> 00:46:54,840
保留一个内存来做我们的检查，

1219
00:46:54,840 --> 00:46:56,430
这样我 dea 是我们将

1220
00:46:56,430 --> 00:46:57,720
查看每个查询的 where 子句，

1221
00:46:57,720 --> 00:47:00,230
并检查是否

1222
00:47:00,230 --> 00:47:02,550
与我们在

1223
00:47:02,550 --> 00:47:04,440
此处查找的内容与他们实际

1224
00:47:04,440 --> 00:47:06,600
修改的内容重叠，如果是，那么我们知道

1225
00:47:06,600 --> 00:47:07,800
我们应该阅读 他们写了什么，但

1226
00:47:07,800 --> 00:47:10,710
我们没有，所以我们必须中止，

1227
00:47:10,710 --> 00:47:13,320
所以你很容易接受这个的方式是

1228
00:47:13,320 --> 00:47:14,550
，我们查看并查看

1229
00:47:14,550 --> 00:47:15,900
我们在每个谓词的 where 子句中访问的属性

1230
00:47:15,900 --> 00:47:18,120
，然后我们查看

1231
00:47:18,120 --> 00:47:19,890
他们是否修改了那个 属性在

1232
00:47:19,890 --> 00:47:21,780
任何日志记录中，然后我们只是

1233
00:47:21,780 --> 00:47:24,420
在此处替换该值所以

1234
00:47:24,420 --> 00:47:26,790
对于第一个属性要求我

1235
00:47:26,790 --> 00:47:29,100
它大于 20 这个人修改

1236
00:47:29,100 --> 00:47:32,250
属性为 799 所以他在这里放了 99

1237
00:47:32,250 --> 00:47:35,430
所以 99 不大于 30 或

1238
00:47:35,430 --> 00:47:38,520
大于 20 并且小于 30 所以我们知道

1239
00:47:38,520 --> 00:47:39,810
这个东西不会

1240
00:47:39,810 --> 00:47:41,460
在这里为我们的查询评估

1241
00:47:41,460 --> 00:47:48,900
它 我们不会读这个

1242
00:47:48,900 --> 00:47:54,680


1243
00:47:54,680 --> 00:47:57,510


1244
00:47:57,510 --> 00:47:59,130
事物

1245
00:47:59,130 --> 00:48:01,590
如果它们是由在我开始之前提交的事务创建的，那么对我来说是可见的，

1246
00:48:01,590 --> 00:48:03,090


1247
00:48:03,090 --> 00:48:05,280
所以我已经开始，并且有

1248
00:48:05,280 --> 00:48:06,150
一堆事务已经

1249
00:48:06,150 --> 00:48:07,380
开始在那里制作一些东西，而

1250
00:48:07,380 --> 00:48:08,700


1251
00:48:08,700 --> 00:48:10,140
在我开始之后开始的当前事务写了一些东西

1252
00:48:10,140 --> 00:48:14,520
然后也提交了，所以在这种情况下

1253
00:48:14,520 --> 00:48:16,260
，

1254
00:48:16,260 --> 00:48:17,850
对于这个事务的这两个谓词，它评估为

1255
00:48:17,850 --> 00:48:19,710
假，所以我们再次知道这个

1256
00:48:19,710 --> 00:48:21,420
事务没有创建任何

1257
00:48:21,420 --> 00:48:24,960
我会读的东西，如果我

1258
00:48:24,960 --> 00:48:26,700
在你知道我什么时候安装之前安装了它

1259
00:48:26,700 --> 00:48:28,110
必须第一次阅读所以我

1260
00:48:28,110 --> 00:48:29,490
没有错过任何东西所以

1261
00:48:29,490 --> 00:48:30,580


1262
00:48:30,580 --> 00:48:32,890
这里没有幻影我可以在两点之后与一个前任在这里做同样的事情

1263
00:48:32,890 --> 00:48:35,710
在十点二十或

1264
00:48:35,710 --> 00:48:38,740
三十之后这个人创造了九十九和

1265
00:48:38,740 --> 00:48:40,330
三十三，所以对于这两个

1266
00:48:40,330 --> 00:48:41,980
谓词的计算结果为假

1267
00:48:41,980 --> 00:48:43,180
三分之三，不是十点二十分或三十九分之三，不是十点

1268
00:48:43,180 --> 00:48:45,160
二十分或三十，

1269
00:48:45,160 --> 00:48:47,140
因此，我没有读过任何内容，我没有

1270
00:48:47,140 --> 00:48:49,720
错过任何内容，所以这是错误的，所以我们

1271
00:48:49,720 --> 00:48:52,840
可以 在这种情况下，我

1272
00:48:52,840 --> 00:48:55,510
正在查找一个属性，这个人

1273
00:48:55,510 --> 00:48:59,080
只修改了属性，

1274
00:48:59,080 --> 00:49:00,550
所以这个人没有

1275
00:49:00,550 --> 00:49:02,110
修改它读取的内容，所以我将它替换为

1276
00:49:02,110 --> 00:49:05,140
null null，就像任何通配符一样

1277
00:49:05,140 --> 00:49:07,750
它实际上评估为空，只要

1278
00:49:07,750 --> 00:49:11,230
它不是真的那么我们就很好，我

1279
00:49:11,230 --> 00:49:13,690
没有错过任何东西所以我会

1280
00:49:13,690 --> 00:49:15,190
为所有这些人做这件事，

1281
00:49:15,190 --> 00:49:18,070
好的，但现在

1282
00:49:18,070 --> 00:49:21,700
我们准确地找到了这个人 一个像 ice 外

1283
00:49:21,700 --> 00:49:23,920
卡 ice 外卡 在这种情况下

1284
00:49:23,920 --> 00:49:27,370
有人安装了你知道

1285
00:49:27,370 --> 00:49:29,950
字符串 Ice Cube 所以现在在这种情况下

1286
00:49:29,950 --> 00:49:32,260
我的谓词将评估为 true

1287
00:49:32,260 --> 00:49:33,850
所以这又意味着这个

1288
00:49:33,850 --> 00:49:36,370
事务做了一个更新，

1289
00:49:36,370 --> 00:49:38,710
在我之后提交 开始了，但是因为我

1290
00:49:38,710 --> 00:49:40,870
正在查看之前的快照，所以我

1291
00:49:40,870 --> 00:49:41,880
错过了它，

1292
00:49:41,880 --> 00:49:43,840
这是正确的倾斜异常，

1293
00:49:43,840 --> 00:49:47,560
因为我错过了它，然后我必须

1294
00:49:47,560 --> 00:49:49,990
然后你知道我必须中止，因为

1295
00:49:49,990 --> 00:49:51,430
这是我应该阅读的内容，

1296
00:49:51,430 --> 00:49:52,750
但我没有阅读 我会违反

1297
00:49:52,750 --> 00:50:21,910
可消毒的排序 好的 是的 是的

1298
00:50:21,910 --> 00:50:25,630
问题是这个问题是 if

1299
00:50:25,630 --> 00:50:28,750
like what if like here 这评估为

1300
00:50:28,750 --> 00:50:31,360
真然后说这

1301
00:50:31,360 --> 00:50:32,860
是及时进行所以交易 1 0

1302
00:50:32,860 --> 00:50:34,420
1 比交易旧有 3

1303
00:50:34,420 --> 00:50:37,360
所以这评估为 true 但 那么这

1304
00:50:37,360 --> 00:50:40,750
评估为假在那种情况下应该发生什么

1305
00:50:40,750 --> 00:50:41,980


1306
00:50:41,980 --> 00:50:44,119
让我们去提问

1307
00:50:44,119 --> 00:50:46,890
吧有一个短暂的时期它

1308
00:50:46,890 --> 00:50:49,109
是真的但是我的结果会是

1309
00:50:49,109 --> 00:50:56,300
假的我认为最后一位作家会赢

1310
00:50:56,300 --> 00:50:58,260
是的我认为最后一位作家会赢

1311
00:50:58,260 --> 00:51:00,540
所以你可以 理论和这个人

1312
00:51:00,540 --> 00:51:04,520
更新实际上赢得了同样的民意调查

1313
00:51:06,470 --> 00:51:08,160
，你是否真的有这些信息，

1314
00:51:08,160 --> 00:51:10,349
尽管我认为你

1315
00:51:10,349 --> 00:51:14,280
不会知道，所以这又

1316
00:51:14,280 --> 00:51:17,460
是一个幻影检查的近似值，

1317
00:51:17,460 --> 00:51:21,359
所以误报是可以的，

1318
00:51:21,359 --> 00:51:23,369
因为 当我们没有两个假阴性时我们中止

1319
00:51:23,369 --> 00:51:26,339
是不好的我们不想

1320
00:51:26,339 --> 00:51:29,670
中止我们不想我们不想

1321
00:51:29,670 --> 00:51:32,099
在我们出现时不中止所以在这种情况下

1322
00:51:32,099 --> 00:51:33,809
我认为安全的做法

1323
00:51:33,809 --> 00:51:36,119
是 即使 gh 有一个窗口，

1324
00:51:36,119 --> 00:51:39,210
就像我们一样或在这个人

1325
00:51:39,210 --> 00:51:41,250
之后，然后一切都会好起来的，因为我

1326
00:51:41,250 --> 00:51:42,329
至少有一次冲突，

1327
00:51:42,329 --> 00:51:43,740
我会玩它，然后立即保存它并

1328
00:51:43,740 --> 00:51:47,040
立即再次显示板，这不是谓词

1329
00:51:47,040 --> 00:51:49,799
锁定将是一个精确的度量或

1330
00:51:49,799 --> 00:51:51,000


1331
00:51:51,000 --> 00:51:53,280
尽管名称有点不精确，但确定是否存在冲突 精确锁定

1332
00:51:53,280 --> 00:51:55,920
是否

1333
00:51:55,920 --> 00:51:58,589
有误报或

1334
00:51:58,589 --> 00:52:02,900
误报可以吗？

1335
00:52:02,900 --> 00:52:05,040


1336
00:52:05,040 --> 00:52:09,359
他们所做的关于 hyper 的另一件很酷的事情是这些 Virgin 概要，所以

1337
00:52:09,359 --> 00:52:11,400
问题再次出现在 Hecate 下 关键

1338
00:52:11,400 --> 00:52:13,109
是我们有这些长版本

1339
00:52:13,109 --> 00:52:15,299
链，然后当我们扫描时，

1340
00:52:15,299 --> 00:52:17,910
我们基本上必须一直遍历

1341
00:52:17,910 --> 00:52:19,140
它们以找出

1342
00:52:19,140 --> 00:52:22,410
我们真正想要的正确版本，因此如果

1343
00:52:22,410 --> 00:52:24,450
您正在执行电视查询，则“ 通过索引重新

1344
00:52:24,450 --> 00:52:25,829
对单个属性进行查找，

1345
00:52:25,829 --> 00:52:27,510
然后我

1346
00:52:27,510 --> 00:52:29,970
落在床垫的前面，是的，谁在乎，

1347
00:52:29,970 --> 00:52:32,940
因为我只是遵循原始链，我

1348
00:52:32,940 --> 00:52:34,799
找到了我想要的东西，但是现在如果我在做

1349
00:52:34,799 --> 00:52:36,270
分析查询 w 当我基本上

1350
00:52:36,270 --> 00:52:39,960
想做整个表扫描时，

1351
00:52:39,960 --> 00:52:41,579
我不想去检查那个原始向量并

1352
00:52:41,579 --> 00:52:43,829
在那里跟踪一些 JSON 指针，

1353
00:52:43,829 --> 00:52:45,210
因为这会破坏我的缓存

1354
00:52:45,210 --> 00:52:46,619
位置，因为我希望能够

1355
00:52:46,619 --> 00:52:48,240
非常有效地读取这些列

1356
00:52:48,240 --> 00:52:49,980
这就是拥有列存储的全部意义，

1357
00:52:49,980 --> 00:52:51,599
但是拥有这些

1358
00:52:51,599 --> 00:52:53,250
指针会导致它们具有

1359
00:52:53,250 --> 00:52:55,799
间接性，因此

1360
00:52:55,799 --> 00:52:57,210
它们将在每个块的基础上执行的操作将

1361
00:52:57,210 --> 00:52:57,540
维护

1362
00:52:57,540 --> 00:52:59,820
Virgen 概要，这只是要

1363
00:52:59,820 --> 00:53:03,450
跟踪范围 这里的

1364
00:53:03,450 --> 00:53:06,030
元组如果可能会阻塞

1365
00:53:06,030 --> 00:53:07,980
没有原始向量 没有

1366
00:53:07,980 --> 00:53:10,590
我需要检查的旧版本 所以在

1367
00:53:10,590 --> 00:53:12,980
这种情况下，这里是 2 到 5 之间的

1368
00:53:12,980 --> 00:53:15,390
独占 所以想想

1369
00:53:15,390 --> 00:53:17,490
这些偏移量是数字 从 0 0

1370
00:53:17,490 --> 00:53:20,790
到 6 所以这会说在 0 和 5 之间，

1371
00:53:20,790 --> 00:53:26,100
所以我

1372
00:53:26,100 --> 00:53:27,630
不需要看任何其他东西，所以

1373
00:53:27,630 --> 00:53:29,970
在这种情况下，当我扫描

1374
00:53:29,970 --> 00:53:31,800
我的处女杜松子酒时，它会说

1375
00:53:31,800 --> 00:53:34,680
哦 我在偏移零关闭 et 1

1376
00:53:34,680 --> 00:53:36,780
不与我的处女概要相交，所以

1377
00:53:36,780 --> 00:53:38,790
我知道我可以完全忽略这件事，

1378
00:53:38,790 --> 00:53:41,910
但现在对于这个范围，我有时必须去

1379
00:53:41,910 --> 00:53:43,830
检查一下，这

1380
00:53:43,830 --> 00:53:46,530
很好，但当我在做扫描时，我没有

1381
00:53:46,530 --> 00:53:47,880
甚至必须在这里查看这些

1382
00:53:47,880 --> 00:53:50,370
其他部分，现在我可以

1383
00:53:50,370 --> 00:53:51,690
尽可能快地浏览这些列，

1384
00:53:51,690 --> 00:53:53,550
您甚至可以做一些

1385
00:53:53,550 --> 00:53:56,760
事情，因为续集或关系

1386
00:53:56,760 --> 00:53:58,770
代数是无序的，然后我可以

1387
00:53:58,770 --> 00:54:02,160
对这两个人进行快速扫描，然后

1388
00:54:02,160 --> 00:54:03,840
在 最后然后去检查这个我

1389
00:54:03,840 --> 00:54:05,610
实际上不知道它是如何实际

1390
00:54:05,610 --> 00:54:07,110
实现的，你可能

1391
00:54:07,110 --> 00:54:08,370
不想为一个非常大的列或大块这样做，

1392
00:54:08,370 --> 00:54:10,710
因为这将是你

1393
00:54:10,710 --> 00:54:13,200
知道的，你将有一个你

1394
00:54:13,200 --> 00:54:15,600
知道的大步 在您的缓存中并将我跳转到

1395
00:54:15,600 --> 00:54:16,830
另一部分可能会使您的缓存无效，

1396
00:54:16,830 --> 00:54:17,940
因此最好

1397
00:54:17,940 --> 00:54:20,790
按顺序翻录，所以这有点

1398
00:54:20,790 --> 00:54:22,710
像区域地图，但对于物理

1399
00:54:22,710 --> 00:54:24,000
版本，因为区域地图是

1400
00:54:24,000 --> 00:54:25,590
块标题的一个小东西 说

1401
00:54:25,590 --> 00:54:27,360
你认识他 re 是在

1402
00:54:27,360 --> 00:54:28,740
我的块中的值并使用它来

1403
00:54:28,740 --> 00:54:29,670
确定您是否真的需要阅读它

1404
00:54:29,670 --> 00:54:31,290
这就像一种表达方式一样好

1405
00:54:31,290 --> 00:54:32,910
这里是这里的版本你

1406
00:54:32,910 --> 00:54:34,680
可以这里是你知道你不检查的元组

1407
00:54:34,680 --> 00:54:36,620
版本没

1408
00:54:36,620 --> 00:54:39,870
问题 想法是，随着数据随着

1409
00:54:39,870 --> 00:54:42,210
时间的推移变冷，当您没有旧版本时，您可以拥有

1410
00:54:42,210 --> 00:54:43,800
越来越大的范围

1411
00:54:43,800 --> 00:54:45,660
，这使您的扫描

1412
00:54:45,660 --> 00:54:48,330
在 hackaton 下更快，只是

1413
00:54:48,330 --> 00:54:50,100
您没有这个概念而已 也是

1414
00:54:50,100 --> 00:54:52,530
一个惩罚，但没有任何概念，

1415
00:54:52,530 --> 00:54:54,050
你是否必须扫描所有内容

1416
00:54:54,050 --> 00:54:59,490
是的 Birju schnapps 它在一个块中，所以

1417
00:54:59,490 --> 00:55:00,990
这个块有十个二十四元组

1418
00:55:00,990 --> 00:55:02,910
，这只是说就像这里是一个范围

1419
00:55:02,910 --> 00:55:06,240
，我实际上不知道

1420
00:55:06,240 --> 00:55:07,500
你在哪里 可以有多个 我想你

1421
00:55:07,500 --> 00:55:09,300
可以 但这是你

1422
00:55:09,300 --> 00:55:10,410
必须检查版本

1423
00:55:10,410 --> 00:55:11,250
的范围 任何不在这个范围内的东西 你

1424
00:55:11,250 --> 00:55:19,170
不知道为什么不使用雨

1425
00:55:19,170 --> 00:55:26,420
与位图

1426
00:55:27,950 --> 00:55:34,320
是的 我的意思是像 espe 所以

1427
00:55:34,320 --> 00:55:35,490
实际上这对于项目三部落来说是一个很棒的项目

1428
00:55:35,490 --> 00:55:37,590
，也许是位图，

1429
00:55:37,590 --> 00:55:38,790
然后尝试一下，看看曾经

1430
00:55:38,790 --> 00:55:40,590
更快的速度，我想

1431
00:55:40,590 --> 00:55:42,120
块越大，位图越大，块中的元组

1432
00:55:42,120 --> 00:55:43,530
越多，位图

1433
00:55:43,530 --> 00:55:47,880
越大，但如果 做 1024 这不是一个

1434
00:55:47,880 --> 00:55:53,040
更大的位图你实际上

1435
00:55:53,040 --> 00:55:54,300
知道你所做的可能只是

1436
00:55:54,300 --> 00:55:56,760
把它转换成一个位图并使用它

1437
00:55:56,760 --> 00:55:58,680
进行扫描和管理只是保持它

1438
00:55:58,680 --> 00:56:00,000
周围是的这是我们应该探索的

1439
00:56:00,000 --> 00:56:06,480
关于你的酷项目好吧

1440
00:56:06,480 --> 00:56:09,540
是的，所以我们现在要讨论的另一个系统

1441
00:56:09,540 --> 00:56:11,970
是做那种 NBCC

1442
00:56:11,970 --> 00:56:13,680
但专注于进行交易

1443
00:56:13,680 --> 00:56:18,690
和分析的是 si P Hannam 所以 Hana

1444
00:56:18,690 --> 00:56:21,060
是它在

1445
00:56:21,060 --> 00:56:25,410
由 SI p 构建的每个约会系统中都是为了你

1446
00:56:25,410 --> 00:56:27,420
知道主要旨在为

1447
00:56:27,420 --> 00:56:29,250
他们的大企业资源提供动力，您

1448
00:56:29,250 --> 00:56:31,590
知道 RP 应用程序是否

1449
00:56:31,590 --> 00:56:32,700
编写用于跟踪

1450
00:56:32,700 --> 00:56:34,440
工资单之类的东西以摆脱

1451
00:56:34,440 --> 00:56:36,660
Oracle，但它实际上是一个独立的

1452
00:56:36,660 --> 00:56:38,490
da 您可以将系统主题用于

1453
00:56:38,490 --> 00:56:40,920
其他应用程序，因此他们将

1454
00:56:40,920 --> 00:56:43,140
使用最新到最旧的方式进行时间旅行存储，

1455
00:56:43,140 --> 00:56:46,170
并且像 Hecate 一样

1456
00:56:46,170 --> 00:56:47,790
支持乐观和悲观我

1457
00:56:47,790 --> 00:56:49,260
实际上不知道默认情况下您会得到什么

1458
00:56:49,260 --> 00:56:52,260
我不知道我 假设 Utley 这

1459
00:56:52,260 --> 00:56:56,010
是可调的，所以他们会有一个

1460
00:56:56,010 --> 00:56:57,480
混合存储布局，然后有行和

1461
00:56:57,480 --> 00:57:00,120
列，所以一些版本

1462
00:57:00,120 --> 00:57:01,740
会在行存储中，然后一些

1463
00:57:01,740 --> 00:57:02,730
版本会在列

1464
00:57:02,730 --> 00:57:04,350
存储中，这个想法是你想要的 要

1465
00:57:04,350 --> 00:57:06,000
获得最新版本，很抱歉

1466
00:57:06,000 --> 00:57:07,710
，列存储中没有最旧的版本，

1467
00:57:07,710 --> 00:57:09,330
因为您的大多数

1468
00:57:09,330 --> 00:57:10,740
分析查询都可以通过

1469
00:57:10,740 --> 00:57:14,100
它，然后您就可以进行烘焙，或者

1470
00:57:14,100 --> 00:57:15,720
在那里添加新的和新

1471
00:57:15,720 --> 00:57:17,370
的 跟踪时间旅行空间你可以

1472
00:57:17,370 --> 00:57:19,140
很快地写下它们，因为

1473
00:57:19,140 --> 00:57:21,420
它们只是你知道

1474
00:57:21,420 --> 00:57:24,580
你正在添加的增量所以他们

1475
00:57:24,580 --> 00:57:25,870
hana 的首里实际上有点

1476
00:57:25,870 --> 00:57:27,550
有趣它最初是作为

1477
00:57:27,550 --> 00:57:29,200
这个 Frankenstein Frankenstein s 开始的

1478
00:57:29,200 --> 00:57:30,580
他们买了一堆数据库

1479
00:57:30,580 --> 00:57:32,440
公司的系统把这个东西混在一起

1480
00:57:32,440 --> 00:57:35,740
叫它 Hana 所以这个 P time 是

1481
00:57:35,740 --> 00:57:37,000
一个内存中的日系统，它来自

1482
00:57:37,000 --> 00:57:41,050
韩国，

1483
00:57:41,050 --> 00:57:42,520
无论出于什么原因，韩国有很多很棒的

1484
00:57:42,520 --> 00:57:44,770
敌人数据库 韩国 alta 基地

1485
00:57:44,770 --> 00:57:47,800
是另一个，所以他们买了这些家伙

1486
00:57:47,800 --> 00:57:49,660
他们有这个东西 t-rex 它

1487
00:57:49,660 --> 00:57:51,340
就像一个搜索系统 然后 maxtv

1488
00:57:51,340 --> 00:57:53,590
是一个嵌入式 Rho 星系统 他们把

1489
00:57:53,590 --> 00:57:55,240
这些东西混在一起 他们

1490
00:57:55,240 --> 00:57:57,190
称之为 Hana 结果 是一个clusterfuck

1491
00:57:57,190 --> 00:58:00,010
然后他们从去年开始

1492
00:58:00,010 --> 00:58:01,180
发布了一个新版本，

1493
00:58:01,180 --> 00:58:02,260
他们实际上已经重写了所有内容以

1494
00:58:02,260 --> 00:58:04,270
成为一个干净的代码库我不知道还有

1495
00:58:04,270 --> 00:58:05,590
多少Appy时间仍然存在但就像

1496
00:58:05,590 --> 00:58:08,590
它好多了 现在它实际上

1497
00:58:08,590 --> 00:58:09,190
很有趣

1498
00:58:09,190 --> 00:58:11,950
Hana 这个名字不是他们告诉我的

1499
00:58:11,950 --> 00:58:13,300
对大公司来说没有任何意义

1500
00:58:13,300 --> 00:58:15,220
名字是一个大问题，因为

1501
00:58:15,220 --> 00:58:17,320
他们害怕被起诉

1502
00:58:17,320 --> 00:58:19,660
，这就是为什么 Zeon 的所有 Intel CPU 都

1503
00:58:19,660 --> 00:58:22,210
像 KB Lake sk  ylake 那些

1504
00:58:22,210 --> 00:58:24,040
实际上是以真正的湖泊命名的，

1505
00:58:24,040 --> 00:58:25,780
他们这样做是因为没有人可以起诉他们

1506
00:58:25,780 --> 00:58:26,770
并说他们偷了他们的名字，因为

1507
00:58:26,770 --> 00:58:28,120
它就像是一个地理区域，

1508
00:58:28,120 --> 00:58:30,280
所以我正在取一个像 Hana 这样的名字 这

1509
00:58:30,280 --> 00:58:31,990
并不意味着任何避免 他们

1510
00:58:31,990 --> 00:58:33,880
让你知道被起诉我

1511
00:58:33,880 --> 00:58:35,650
听说这意味着没有规划师新

1512
00:58:35,650 --> 00:58:38,110
架构没有规划师是

1513
00:58:38,110 --> 00:58:40,120
sa P 的创始人之一，就像他是 P

1514
00:58:40,120 --> 00:58:43,690
和 s AP 但我不认为这是真的

1515
00:58:43,690 --> 00:58:44,650
我认为这是有人补充说的

1516
00:58:44,650 --> 00:58:47,800
之后没关系 所以让我们谈谈

1517
00:58:47,800 --> 00:58:48,850
白宫权威处女的故事 所以

1518
00:58:48,850 --> 00:58:49,600
这有点有趣

1519
00:58:49,600 --> 00:58:51,970
所以最老的处女总是

1520
00:58:51,970 --> 00:58:53,920
提供主数据表 这将是

1521
00:58:53,920 --> 00:58:56,200
一个列存储 然后枢纽 这个

1522
00:58:56,200 --> 00:58:58,990
小标志这个 说嘿，

1523
00:58:58,990 --> 00:59:00,580
实际上可能有 成为

1524
00:59:00,580 --> 00:59:02,590
时间旅行空间中的较新版本，您

1525
00:59:02,590 --> 00:59:04,060
需要检查它是否

1526
00:59:04,060 --> 00:59:05,200
确实是您正在寻找的版本

1527
00:59:05,200 --> 00:59:09,400
，因此对于某些查询，

1528
00:59:09,400 --> 00:59:10,960
例如分析查询，

1529
00:59:10,960 --> 00:59:12,820
我可能不需要运行和 有

1530
00:59:12,820 --> 00:59:15,850
一个元组的确切最新版本，比如

1531
00:59:15,850 --> 00:59:17,530
谁在乎我是否正在尝试

1532
00:59:17,530 --> 00:59:19,960
计算你知道的未结订单的数量，我

1533
00:59:19,960 --> 00:59:21,970
需要去检查谁在乎我是否

1534
00:59:21,970 --> 00:59:25,030
落后 10 毫秒，所以我只需

1535
00:59:25,030 --> 00:59:26,950
扫描 列存储在

1536
00:59:26,950 --> 00:59:27,430
主 Dave

1537
00:59:27,430 --> 00:59:29,140
表空间中，它可能不是最新

1538
00:59:29,140 --> 00:59:30,760
版本，但这对我的

1539
00:59:30,760 --> 00:59:33,760
查询来说已经足够了，所以现在当您进入

1540
00:59:33,760 --> 00:59:35,920
时间旅行空间时，他们将拥有一个

1541
00:59:35,920 --> 00:59:38,470
哈希表，可以像双重查找一样

1542
00:59:38,470 --> 00:59:40,900
找到头

1543
00:59:40,900 --> 00:59:47,260
特定元组的原始链 是的，我说什么

1544
00:59:47,260 --> 00:59:49,420
都完成了 ooh 是的 抱歉 是这里 好的，

1545
00:59:49,420 --> 00:59:52,690
所以主数据表中的每个元组

1546
00:59:52,690 --> 00:59:53,890
都会有一个记录 ID

1547
00:59:53,890 --> 00:59:55,869
正确，这是一个不可变的标识符，

1548
00:59:55,869 --> 00:59:57,609
表示这是一个

1549
00:59:57,609 --> 00:59:59,680
逻辑 元组然后是我们的

1550
00:59:59,680 --> 01:00:01,119
版本标志，它可能只是一个

1551
01:00:01,119 --> 01:00:03,550
位图，表示每个版本

1552
01:00:03,550 --> 01:00:06,460
是否有更新的版本我们

1553
01:00:06,460 --> 01:00:08,020
需要检查时间旅行

1554
01:00:08,020 --> 01:00:11,710
空间，所以如果我在 a1 上查找，

1555
01:00:11,710 --> 01:00:13,119
我会说所有 好吧，这件事

1556
01:00:13,119 --> 01:00:15,300
设置了 t 是的，所以现在我在这里使用我的记录 ID 一个

1557
01:00:15,300 --> 01:00:17,890
土地，然后现在我可以遍历我的

1558
01:00:17,890 --> 01:00:22,869
原始链，所以是的，所以它是全球最旧到

1559
01:00:22,869 --> 01:00:24,790
最新的，然后当你

1560
01:00:24,790 --> 01:00:26,650
在这个哈希表中登陆时，这也是

1561
01:00:26,650 --> 01:00:28,210
旧的，或者这实际上是最新到

1562
01:00:28,210 --> 01:00:29,230
最旧的 这就是我感到困惑的原因，

1563
01:00:29,230 --> 01:00:31,660
所以全球范围内从最旧到最新，我

1564
01:00:31,660 --> 01:00:33,760
在这里查看最旧的版本，但是

1565
01:00:33,760 --> 01:00:35,380
如果我想找到最新版本，我会

1566
01:00:35,380 --> 01:00:37,840
在这里登陆，然后

1567
01:00:37,840 --> 01:00:40,840
虚拟链的头是最新的，如果

1568
01:00:40,840 --> 01:00:42,760
我是 做更新我最关心的是

1569
01:00:42,760 --> 01:00:44,830
验证最新的，这是我的

1570
01:00:44,830 --> 01:00:46,420
哈希映射，如果我需要安装一个新

1571
01:00:46,420 --> 01:00:48,790
版本，我可以非常有效地做到这

1572
01:00:48,790 --> 01:00:51,130
一点，而且我认为这种

1573
01:00:51,130 --> 01:00:52,570
架构从他们试图匹配的事实中脱颖而出

1574
01:00:52,570 --> 01:00:53,650
这些

1575
01:00:53,650 --> 01:00:56,800
不同的系统放在一起，你知道这

1576
01:00:56,800 --> 01:00:58,119
可能就像 t-rex 方面，这

1577
01:00:58,119 --> 01:01:02,040
可能就像内存 P 时间方面一样，

1578
01:01:02,040 --> 01:01:05,380
所以现在不像

1579
01:01:05,380 --> 01:01:07,359
黑客马拉松和超级，我们将

1580
01:01:07,359 --> 01:01:10,180
跟踪时间戳

1581
01:01:10,180 --> 01:01:11,920
在标题中 o 对于每个

1582
01:01:11,920 --> 01:01:14,440
元组，他们实际上会

1583
01:01:14,440 --> 01:01:18,460
为每个元组嵌入一个指向某个辅助元数据对象的指针，这将包含每个元组

1584
01:01:18,460 --> 01:01:20,770
的

1585
01:01:20,770 --> 01:01:22,540
所有时间戳信息

1586
01:01:22,540 --> 01:01:26,700
，这里的想法是

1587
01:01:26,700 --> 01:01:28,720
我们这样做是为了减少存储，

1588
01:01:28,720 --> 01:01:30,580
因为

1589
01:01:30,580 --> 01:01:31,839
对于

1590
01:01:31,839 --> 01:01:33,910
我为给定事务创建的每个版本所做的每次更新，这个重复的时间戳不再重复

1591
01:01:33,910 --> 01:01:35,460


1592
01:01:35,460 --> 01:01:38,170
，它们现在都有一个 64 位的

1593
01:01:38,170 --> 01:01:40,810
指向某个元数据对象的指针，该对象具有

1594
01:01:40,810 --> 01:01:42,150
他们需要知道的关于

1595
01:01:42,150 --> 01:01:45,430
那个元组的所有信息 我减少了

1596
01:01:45,430 --> 01:01:46,869
为每个元组存储的元头或空间的数量

1597
01:01:46,869 --> 01:01:48,580
，现在当我需要

1598
01:01:48,580 --> 01:01:49,960
像我们在

1599
01:01:49,960 --> 01:01:52,180
黑客马拉松中所做的那样更新时间戳时，我确实去了那个位置

1600
01:01:52,180 --> 01:01:54,609
更新了一个制作元数据对象

1601
01:01:54,609 --> 01:01:57,029
并更新了我的所有版本 立即

1602
01:01:57,029 --> 01:01:59,140
反对

1603
01:01:59,140 --> 01:02:03,250
在较慢的蜜蜂或更快的

1604
01:02:03,250 --> 01:02:04,690
更新或大型更新之间进行这种权衡，

1605
01:02:04,690 --> 01:02:06,490
因为我可以

1606
01:02:06,490 --> 01:02:07,510
在更新前夕更新一件事情

1607
01:02:07,510 --> 01:02:10,210
一下子就对了，所以它看起来像

1608
01:02:10,210 --> 01:02:13,240
这样，在我这个交易

1609
01:02:13,240 --> 01:02:16,630
元数据空间中，对于每一个

1610
01:02:16,630 --> 01:02:19,210
交易，我是一组曲调的维护先生，

1611
01:02:19,210 --> 01:02:20,529
实际上我将

1612
01:02:20,529 --> 01:02:22,539
跟踪就像这里的所有事情

1613
01:02:22,539 --> 01:02:25,299
一样 他们一直在修改，所以现在当

1614
01:02:25,299 --> 01:02:26,619
我的交易出现一次

1615
01:02:26,619 --> 01:02:29,500
更新时，这些人

1616
01:02:29,500 --> 01:02:31,180
在我创建这些新版本时写信给 C 和 D 这些人现在

1617
01:02:31,180 --> 01:02:33,430
指出这是我交易中的单个对象，

1618
01:02:33,430 --> 01:02:35,470
它说这是

1619
01:02:35,470 --> 01:02:37,119
我的当前状态 所以我没有那个

1620
01:02:37,119 --> 01:02:39,400
全局地图我并没有真正维护

1621
01:02:39,400 --> 01:02:40,799
所有版本信息和每个

1622
01:02:40,799 --> 01:02:43,270
元组我可以在这里

1623
01:02:43,270 --> 01:02:45,069
找出你知道什么我你知道

1624
01:02:45,069 --> 01:02:46,089
当我看一个时我实际上在看什么

1625
01:02:46,089 --> 01:02:48,520
版本，他们有另一层

1626
01:02:48,520 --> 01:02:50,589
间接，然后

1627
01:02:50,589 --> 01:02:52,569


1628
01:02:52,569 --> 01:02:55,390
当它对提交进行分组并将它们

1629
01:02:55,390 --> 01:02:56,289
一起添加到这组提交

1630
01:02:56,289 --> 01:02:57,549
联系人中时，将一堆这些交易税组合在一起，然后

1631
01:02:57,549 --> 01:02:59,710
如果上部

1632
01:02:59,710 --> 01:03:01,869
系统的 s 想说，嘿，我

1633
01:03:01,869 --> 01:03:04,299
在 ID 3 上的事务确实

1634
01:03:04,299 --> 01:03:05,829
提交了，而不是

1635
01:03:05,829 --> 01:03:07,359
为每个事务维护该信息

1636
01:03:07,359 --> 01:03:09,220


1637
01:03:09,220 --> 01:03:10,750


1638
01:03:10,750 --> 01:03:13,960


1639
01:03:13,960 --> 01:03:15,430
有点不稳定，我认为这有点过度

1640
01:03:15,430 --> 01:03:18,520
设计，但我确实明白他们为什么要这样做，

1641
01:03:18,520 --> 01:03:19,779
如果您正在进行大型更新，

1642
01:03:19,779 --> 01:03:21,369
我确定他们正在执行他们的工作量

1643
01:03:21,369 --> 01:03:23,020
或因此推断他们的目标

1644
01:03:23,020 --> 01:03:25,180
应用程序这种方法不会“

1645
01:03:25,180 --> 01:03:26,829
没有道理，我认为有人说

1646
01:03:26,829 --> 01:03:28,660
我喜欢这种想法，即

1647
01:03:28,660 --> 01:03:30,339
您拥有这个全局性的东西来

1648
01:03:30,339 --> 01:03:31,720
跟踪所有内容，这样您就可以快速

1649
01:03:31,720 --> 01:03:34,660
更新这个我认为我没有看到

1650
01:03:34,660 --> 01:03:40,150
拥有这个的真正原因 好的，嗨，

1651
01:03:40,150 --> 01:03:41,109
让我们尽快结束你谈论的电路

1652
01:03:41,109 --> 01:03:42,910
，所以让我们不要

1653
01:03:42,910 --> 01:03:44,230
对我们到目前为止所讨论的 nbcc 方法有一些限制，

1654
01:03:44,230 --> 01:03:46,720
并且

1655
01:03:46,720 --> 01:03:48,190
有点乐观和伤害重组，

1656
01:03:48,190 --> 01:03:50,260
然后我们将看到一个

1657
01:03:50,260 --> 01:03:52,049
专门设计用于的系统 克服这些

1658
01:03:52,049 --> 01:03:55,660
问题 一个是到目前为止我们已经讨论过的问题

1659
01:03:55,660 --> 01:03:57,250
有这个有

1660
01:03:57,250 --> 01:03:59,289
这个方向 因为这个

1661
01:03:59,289 --> 01:04:00,670
版本链 他们必须一直

1662
01:04:00,670 --> 01:04:01,660
查找以找出

1663
01:04:01,660 --> 01:04:05,650
适合我们的版本 在 Hana 的情况下，

1664
01:04:05,650 --> 01:04:06,430
我们

1665
01:04:06,430 --> 01:04:08,530
看对了，他们有这个全局上下文

1666
01:04:08,530 --> 01:04:12,099
对象 hyper 尝试通过版本概要来减少这种情况，

1667
01:04:12,099 --> 01:04:13,450
以

1668
01:04:13,450 --> 01:04:15,069
避免检查版本更改，但

1669
01:04:15,069 --> 01:04:16,990
总的来说，我们必须让您知道我们是否要

1670
01:04:16,990 --> 01:04:18,220
更新发布我们必须维护

1671
01:04:18,220 --> 01:04:20,770
这些版本指针，所以我们现在必须

1672
01:04:20,770 --> 01:04:22,089
进行垃圾收集以通过并

1673
01:04:22,089 --> 01:04:23,619
尝试清理东西，所以如果我们没有

1674
01:04:23,619 --> 01:04:25,210
用完空间，它会产生

1675
01:04:25,210 --> 01:04:27,550
维珍链的大小，减少

1676
01:04:27,550 --> 01:04:28,480
需要查看的东西的数量

1677
01:04:28,480 --> 01:04:31,869
当我们扫描所有其他购买时

1678
01:04:31,869 --> 01:04:32,829
，到目前为止我们讨论的大多数方法

1679
01:04:32,829 --> 01:04:34,660
也在全局内存中维护一堆东西，

1680
01:04:34,660 --> 01:04:36,490
有

1681
01:04:36,490 --> 01:04:39,970
用于 Hyper 的 hackaton 的全局映射，有

1682
01:04:39,970 --> 01:04:42,010
一种元组块的全局空间

1683
01:04:42,010 --> 01:04:45,579
，等等 这里是这种情况，因为

1684
01:04:45,579 --> 01:04:47,230
我们正在读取写入以输入

1685
01:04:47,230 --> 01:04:49,510
内存中的任何地址空间，我们的线程

1686
01:04:49,510 --> 01:04:52,780
并不完全了解

1687
01:04:52,780 --> 01:04:54,339
它们正在读取的数据在哪里以及它们正在读取

1688
01:04:54,339 --> 01:04:55,990
的数据所在的位置

1689
01:04:55,990 --> 01:04:57,579
以及它们是如何写入

1690
01:04:57,579 --> 01:04:58,980
的 会影响它们的缓存位置，

1691
01:04:58,980 --> 01:05:02,410
所以我们将在本学期详细讨论 Numa 的东西，

1692
01:05:02,410 --> 01:05:05,079
但在现代

1693
01:05:05,079 --> 01:05:06,430
架构中，如果你有多个 CPU

1694
01:05:06,430 --> 01:05:09,790
插槽，

1695
01:05:09,790 --> 01:05:11,440
你知道一个内存位置的内存访问速度意味着在一个

1696
01:05:11,440 --> 01:05:12,609
袜子上它可能不一样 在另一个

1697
01:05:12,609 --> 01:05:14,440
套接字上，所以如果我不知道我的

1698
01:05:14,440 --> 01:05:15,910
内存实际在哪里，我可能最终会

1699
01:05:15,910 --> 01:05:17,650
在另一个套接字上读取，这

1700
01:05:17,650 --> 01:05:20,319
可能真的很慢，然后对于所有这些

1701
01:05:20,319 --> 01:05:21,880
方法，我们还讨论了

1702
01:05:21,880 --> 01:05:24,400
如何有一个计数器给

1703
01:05:24,400 --> 01:05:26,200
你 时间戳分配，这可能会

1704
01:05:26,200 --> 01:05:28,540
成为瓶颈，并且

1705
01:05:28,540 --> 01:05:32,109
线程数的核心数非常高，因此对于 OCC

1706
01:05:32,109 --> 01:05:33,040
，我们讨论过

1707
01:05:33,040 --> 01:05:34,720
的一些限制不是特定于多

1708
01:05:34,720 --> 01:05:36,280
版本的，这是肯定的

1709
01:05:36,280 --> 01:05:40,329
对于 OCC 协议是通用的，但是如果存在高

1710
01:05:40,329 --> 01:05:41,740
争用，那么我们将有

1711
01:05:41,740 --> 01:05:43,599
很多中止，

1712
01:05:43,599 --> 01:05:44,859
当我们向她展示所有内容时，我们看到 1,000 个核心的论文都

1713
01:05:44,859 --> 01:05:47,170
在 1000 个核心

1714
01:05:47,170 --> 01:05:48,369
上弹坑，我们一直在执行

1715
01:05:48,369 --> 01:05:49,420
交易，基本上只是

1716
01:05:49,420 --> 01:05:50,470
中止它们，因为

1717
01:05:50,470 --> 01:05:53,109
Brett 立即发生了冲突，如果我们为 OCC 实现私有工作区，它必须

1718
01:05:53,109 --> 01:05:54,520
做一个实际读取和写入的度量

1719
01:05:54,520 --> 01:05:56,530


1720
01:05:56,530 --> 01:06:00,970
，这是在

1721
01:06:00,970 --> 01:06:02,829
内存中的额外复制，这会增加

1722
01:06:02,829 --> 01:06:04,270
它会减慢我们的速度，因为该

1723
01:06:04,270 --> 01:06:08,309
部门工作，然后现在 当我们这样做时，

1724
01:06:08,309 --> 01:06:10,299
我们将在下一堂课中讨论更多，

1725
01:06:10,299 --> 01:06:12,990
但在某些协议中，

1726
01:06:12,990 --> 01:06:15,460
在我实际提交事务之前处理索引更新的方式

1727
01:06:15,460 --> 01:06:17,799
是我必须

1728
01:06:17,799 --> 01:06:18,849
安装所谓的虚拟索引

1729
01:06:18,849 --> 01:06:19,790
节点，

1730
01:06:19,790 --> 01:06:21,470
基本上是一个占位符，就像我要说的那样

1731
01:06:21,470 --> 01:06:23,990
将此键启动到此索引中

1732
01:06:23,990 --> 01:06:25,970
我不确切知道我的提交

1733
01:06:25,970 --> 01:06:26,990
时间戳是什么 是的，因为我还没有

1734
01:06:26,990 --> 01:06:28,550
提交，但这只是

1735
01:06:28,550 --> 01:06:29,570
防止其他人的一种方式 当试图同时

1736
01:06:29,570 --> 01:06:31,040
启动相同的密钥时，

1737
01:06:31,040 --> 01:06:33,859
这是另一种方式来获得第一名作家的胜利，

1738
01:06:33,859 --> 01:06:37,460
但对于索引，所以 Sakina 是

1739
01:06:37,460 --> 01:06:40,130
CMU 在这里通过治愈技术肢体构建的引擎，

1740
01:06:40,130 --> 01:06:41,750
所以他是 Dave Anderson 的一个桃色学生，

1741
01:06:41,750 --> 01:06:43,910
在博士后工作 并

1742
01:06:43,910 --> 01:06:45,890
涉足数据库最终构建了

1743
01:06:45,890 --> 01:06:48,020
这个系统，所以有一堆

1744
01:06:48,020 --> 01:06:49,670
对我们来说很有趣的优化，

1745
01:06:49,670 --> 01:06:53,540
蝉提出我

1746
01:06:53,540 --> 01:06:56,150
想通过将尽最大努力排列

1747
01:06:56,150 --> 01:06:56,780


1748
01:06:56,780 --> 01:06:58,490
Lucey 同步时钟，这是我们

1749
01:06:58,490 --> 01:07:00,170
不打算涵盖的 很多但

1750
01:07:00,170 --> 01:07:01,640
争论的地方是验证索引记录

1751
01:07:01,640 --> 01:07:03,500
所以后两个中的第一个是

1752
01:07:03,500 --> 01:07:05,060
我们可以在

1753
01:07:05,060 --> 01:07:07,100
我们自己的系统中考虑几周的事情这个我没有

1754
01:07:07,100 --> 01:07:08,180
更仔细地思考

1755
01:07:08,180 --> 01:07:09,560
这是否真的有意义

1756
01:07:09,560 --> 01:07:10,940
这实际上是从

1757
01:07:10,940 --> 01:07:12,710
分布式系统中借用技术 数据库世界

1758
01:07:12,710 --> 01:07:13,940
如果你说如果我有

1759
01:07:13,940 --> 01:07:15,740
很多核心有很多套接字它

1760
01:07:15,740 --> 01:07:17,300
本质上就像一个分布式数据库

1761
01:07:17,300 --> 01:07:19,609
，它在一台机器上 但我

1762
01:07:19,609 --> 01:07:21,590
想专注于你知道的这三个，

1763
01:07:21,590 --> 01:07:23,300
因为在我们谈论到目前为止之前这更有意义，

1764
01:07:23,300 --> 01:07:26,930
所以在

1765
01:07:26,930 --> 01:07:28,310
这里排列基本思想的最大努力是，如果我分配一些，

1766
01:07:28,310 --> 01:07:30,109
而不是让这个版本

1767
01:07:30,109 --> 01:07:32,930
链可以指向任何地方

1768
01:07:32,930 --> 01:07:34,780
固定大小的空间

1769
01:07:34,780 --> 01:07:38,330
以及版本指针，

1770
01:07:38,330 --> 01:07:39,680
这样当我想要查找并

1771
01:07:39,680 --> 01:07:41,720
说出最新版本是什么时，我

1772
01:07:41,720 --> 01:07:42,710
也许可以

1773
01:07:42,710 --> 01:07:46,190
直接在这里找到最新版本，所以这里的

1774
01:07:46,190 --> 01:07:49,150
想法是到目前为止我 我扫描

1775
01:07:49,150 --> 01:07:51,410
而不是跳转到

1776
01:07:51,410 --> 01:07:53,960
其他位置的指针，你知道这里有一个

1777
01:07:53,960 --> 01:07:55,040
小的物质空间，里面

1778
01:07:55,040 --> 01:07:57,140
有我需要的最新数据和

1779
01:07:57,140 --> 01:07:59,230
对我来说足够好的时间的欢乐，

1780
01:07:59,230 --> 01:08:03,109
所以这个没问题，我的意思是我想

1781
01:08:03,109 --> 01:08:05,030
该论文表明，这实际上

1782
01:08:05,030 --> 01:08:07,310
对于某种已修复的旧工作负载来说，这

1783
01:08:07,310 --> 01:08:08,359
会产生很大的不同，但我认为

1784
01:08:08,359 --> 01:08:10,580
当您拥有可变长度数据时，这很难做到，

1785
01:08:10,580 --> 01:08:11,960
因为如果这些字符串

1786
01:08:11,960 --> 01:08:13,520
的大小不同，那么这就是 很难

1787
01:08:13,520 --> 01:08:16,819
做，对于分析查询，

1788
01:08:16,819 --> 01:08:18,770
我认为列存储方法

1789
01:08:18,770 --> 01:08:21,399
实际上显然会更好，

1790
01:08:21,399 --> 01:08:23,180
但让我们谈谈我们

1791
01:08:23,180 --> 01:08:25,460
如何正确地进行快速验证，所以

1792
01:08:25,460 --> 01:08:29,120
再次扫描统计方法可以很好地保证

1793
01:08:29,120 --> 01:08:31,069
Hecate 下的

1794
01:08:31,069 --> 01:08:32,479
精确锁定方法的灭菌能力

1795
01:08:32,479 --> 01:08:33,529


1796
01:08:33,529 --> 01:08:36,080
我认为他

1797
01:08:36,080 --> 01:08:39,229
主要是

1798
01:08:39,229 --> 01:08:42,109
在反驳在黑客马拉松中使用的扫描设置所写的，他

1799
01:08:42,109 --> 01:08:43,670
实际上并没有评估精确

1800
01:08:43,670 --> 01:08:45,170
锁定，因为我认为

1801
01:08:45,170 --> 01:08:46,670
他在写这篇论文时并不知道这篇论文

1802
01:08:46,670 --> 01:08:48,620
他并没有坐下来，他针对 MVCC

1803
01:08:48,620 --> 01:08:50,750
系统，但它基本上有三种

1804
01:08:50,750 --> 01:08:52,670
方法可以加快

1805
01:08:52,670 --> 01:08:53,120


1806
01:08:53,120 --> 01:08:56,210
速度进行验证，第一种是

1807
01:08:56,210 --> 01:08:58,340
，而不是

1808
01:08:58,340 --> 01:09:00,620
盲目地对待每笔交易或盲目地进行验证，

1809
01:09:00,620 --> 01:09:03,080
您实际上可以维护

1810
01:09:03,080 --> 01:09:05,000
一些关于

1811
01:09:05,000 --> 01:09:06,560
您验证的最后一笔交易发生了什么，

1812
01:09:06,560 --> 01:09:09,430
因此您是否可以确定是否

1813
01:09:09,430 --> 01:09:11,510
存在高度竞争的记录，例如

1814
01:09:11,510 --> 01:09:12,859
每个人都试图更新这个

1815
01:09:12,859 --> 01:09:15,290
元组，而不是

1816
01:09:15,290 --> 01:09:17,689
在最后或随机检查我

1817
01:09:17,689 --> 01:09:19,370
会在验证的最开始检查

1818
01:09:19,370 --> 01:09:21,800
，如果我要中止，我会立即

1819
01:09:21,800 --> 01:09:23,149
中止，而不必检查

1820
01:09:23,149 --> 01:09:25,609
其他所有内容 所以你基本上要做的

1821
01:09:25,609 --> 01:09:28,100
就是为

1822
01:09:28,100 --> 01:09:30,319
我保持登机交易的元组的大部分内容保留一个计数器，

1823
01:09:30,319 --> 01:09:32,720
所以现在如果我去

1824
01:09:32,720 --> 01:09:34,670
看看当我做我的验证时是否那个

1825
01:09:34,670 --> 01:09:36,859
元组我读过那个元组并且

1826
01:09:36,859 --> 01:09:38,660
每个人 保持登机以

1827
01:09:38,660 --> 01:09:40,490
确保我先检查一个，

1828
01:09:40,490 --> 01:09:44,029
然后男孩们会做无用的工作

1829
01:09:44,029 --> 01:09:45,470
我们要做的另一种技术是早期

1830
01:09:45,470 --> 01:09:46,760
一致性检查 这实际上被

1831
01:09:46,760 --> 01:09:48,710
禁止在我们在 DB X 1000 方法之后我们写的一篇论文中

1832
01:09:48,710 --> 01:09:51,229
有另一个

1833
01:09:51,229 --> 01:09:54,350
协议代码 tik-tok，

1834
01:09:54,350 --> 01:09:56,540
如果我

1835
01:09:56,540 --> 01:09:58,870
在验证阶段跟踪我正在争论的事情

1836
01:09:58,870 --> 01:10:01,940
，如果我可以

1837
01:10:01,940 --> 01:10:03,650
将这些信息推到现在，那么这又是什么，就像以前一样，实际上

1838
01:10:03,650 --> 01:10:06,200
我为什么要运行 交易所以现在

1839
01:10:06,200 --> 01:10:08,120
我 如果我事务读取了一些

1840
01:10:08,120 --> 01:10:10,550
我可能会发生冲突的内容，而

1841
01:10:10,550 --> 01:10:11,780
不是等待验证进行

1842
01:10:11,780 --> 01:10:15,080
验证，

1843
01:10:15,080 --> 01:10:16,250
我会在读取后或什

1844
01:10:16,250 --> 01:10:17,570
至在读取之前立即检查，看看我现在是否阅读了这个

1845
01:10:17,570 --> 01:10:19,820
中止，这里的想法

1846
01:10:19,820 --> 01:10:21,680
不是等待事务的整个

1847
01:10:21,680 --> 01:10:23,270
生命周期只是为了看看

1848
01:10:23,270 --> 01:10:26,000
我要中止而不是一点点完成我

1849
01:10:26,000 --> 01:10:27,920
可以做一些早期检查并

1850
01:10:27,920 --> 01:10:30,530
避免最后一个是通过增量

1851
01:10:30,530 --> 01:10:32,890
版本搜索和想法 这是

1852
01:10:32,890 --> 01:10:35,030
因为如果

1853
01:10:35,030 --> 01:10:38,060
我知道我一直在阅读一些旧

1854
01:10:38,060 --> 01:10:40,100
版本，那么他们所做的是从最新到最旧的版本，而不是必须

1855
01:10:40,100 --> 01:10:41,270
遵循那个链，我可以在主版本中维护

1856
01:10:41,270 --> 01:10:45,770
一个小内存地址，

1857
01:10:45,770 --> 01:10:48,080
但主版本表明

1858
01:10:48,080 --> 01:10:49,460
您的版本“ 我可能正在

1859
01:10:49,460 --> 01:10:51,110
寻找这里是如何跳转到它

1860
01:10:51,110 --> 01:10:53,330
，如果我进入一个版本，这

1861
01:10:53,330 --> 01:10:55,280
正是我想要的，如果这

1862
01:10:55,280 --> 01:10:56,780
不是我想要的，我就完成了，然后我就像

1863
01:10:56,780 --> 01:10:59,540
往常一样重复搜索它

1864
01:10:59,540 --> 01:11:01,430
需要一个 一点额外的 内存空间

1865
01:11:01,430 --> 01:11:03,530
并避免必须进行完整版本

1866
01:11:03,530 --> 01:11:08,270
更改搜索，因此对于前两个，

1867
01:11:08,270 --> 01:11:10,100
如果您的事务大部分提交成功，您想跳过这些，

1868
01:11:10,100 --> 01:11:12,680


1869
01:11:12,680 --> 01:11:14,300
但只有当您有高度争用时

1870
01:11:14,300 --> 01:11:15,350
，这些事情才真正有意义

1871
01:11:15,350 --> 01:11:17,420
，所以这有点像您 有点

1872
01:11:17,420 --> 01:11:18,980
需要适应并且有一种方法来确定

1873
01:11:18,980 --> 01:11:20,960
哦，好吧，我继续登机，因为我有

1874
01:11:20,960 --> 01:11:22,580
冲突，然后你打开这些

1875
01:11:22,580 --> 01:11:24,290
东西，也许这可以减少

1876
01:11:24,290 --> 01:11:27,110
工作量，因为再次 OCC 我们

1877
01:11:27,110 --> 01:11:28,790
只在有交易提交时才进行验证

1878
01:11:28,790 --> 01:11:30,650
因此，如果我要进行

1879
01:11:30,650 --> 01:11:33,680
一千次更新并且这是第一个更新，

1880
01:11:33,680 --> 01:11:35,180
那么我将与之发生冲突，

1881
01:11:35,180 --> 01:11:36,980
如果我

1882
01:11:36,980 --> 01:11:38,090
不检查是否有

1883
01:11:38,090 --> 01:11:39,050
中止

1884
01:11:39,050 --> 01:11:40,870
操作直到我执行其他 999 次，这将导致我中止

1885
01:11:40,870 --> 01:11:44,360
更新然后这都是浪费的工作 所以

1886
01:11:44,360 --> 01:11:46,160
像这样的技术技术

1887
01:11:46,160 --> 01:11:49,460
试图避免这一切 所以关于蝉的另一件

1888
01:11:49,460 --> 01:11:51,530
有趣的事情我

1889
01:11:51,530 --> 01:11:53,120
觉得非常迷人 这是

1890
01:11:53,120 --> 01:11:54,890
第三年 我说这是

1891
01:11:54,890 --> 01:11:57,020
我们应该研究的东西，

1892
01:11:57,020 --> 01:11:59,030
希望我有一个博士生

1893
01:11:59,030 --> 01:12:02,120
开始研究这个，而

1894
01:12:02,120 --> 01:12:04,250
不是将 B+ 树的索引节点存储

1895
01:12:04,250 --> 01:12:07,460
在堆中，他们实际上

1896
01:12:07,460 --> 01:12:09,350
将它存储为元组本身

1897
01:12:09,350 --> 01:12:12,740
作为表中的 blob，这里的想法是

1898
01:12:12,740 --> 01:12:14,930
，如果索引节点本身只是元组，则不必进行扫描

1899
01:12:14,930 --> 01:12:16,100
检查，而不必进行

1900
01:12:16,100 --> 01:12:18,500
精确锁定

1901
01:12:18,500 --> 01:12:21,440
，

1902
01:12:21,440 --> 01:12:22,940
我可以进行验证以查看是否

1903
01:12:22,940 --> 01:12:24,590
允许 读点什么或不

1904
01:12:24,590 --> 01:12:26,810
做点什么，然后我可能会免费获得

1905
01:12:26,810 --> 01:12:28,400
消毒能力和幻象

1906
01:12:28,400 --> 01:12:32,360
检查，如果一切都是一张桌子，那么

1907
01:12:32,360 --> 01:12:34,100
再次正常，你会在

1908
01:12:34,100 --> 01:12:36,470
你将构建的 B+ 树或

1909
01:12:36,470 --> 01:12:38,210
我们已经拥有节点的 BW 树中看到这一点

1910
01:12:38,210 --> 01:12:40,550
只是坐在高温中，

1911
01:12:40,550 --> 01:12:41,780
但实际上我们现在将这些存储

1912
01:12:41,780 --> 01:12:44,480
为像这样的表中的 blob

1913
01:12:44,480 --> 01:12:45,800
我们只是序列化密钥并

1914
01:12:45,800 --> 01:12:47,570
消毒指向下一个版本的指针

1915
01:12:47,570 --> 01:12:50,840
所以现在当我从 你

1916
01:12:50,840 --> 01:12:53,600
知道要深入到 G 我会做我的

1917
01:12:53,600 --> 01:12:55,490
查找 我基本上知道如何解释

1918
01:12:55,490 --> 01:12:56,660
这些字节 这会告诉我

1919
01:12:56,660 --> 01:12:59,030
哦，你知道的关于 Kievan 钥匙的事情

1920
01:12:59,030 --> 01:12:59,719
我正在寻找

1921
01:12:59,719 --> 01:13:03,709
我想跳进两个 B 或 C 然后

1922
01:13:03,709 --> 01:13:05,209
我知道怎么做然后进行查找并

1923
01:13:05,209 --> 01:13:09,409
找到代表 C 的节点

1924
01:13:09,409 --> 01:13:11,689
当然现在问题是如果

1925
01:13:11,689 --> 01:13:15,679
我对我的节点中的单个键进行更新，

1926
01:13:15,679 --> 01:13:18,619
这将使整个

1927
01:13:18,619 --> 01:13:19,519
版本无效 因为要么创建一个新

1928
01:13:19,519 --> 01:13:21,409
版本，这可能是过度

1929
01:13:21,409 --> 01:13:22,669
复制，所以我认为这只是权衡

1930
01:13:22,669 --> 01:13:25,189
，例如有多少流失有一个索引

1931
01:13:25,189 --> 01:13:27,260
，您将获得多少收益，

1932
01:13:27,260 --> 01:13:29,449
但我再次认为该论文是

1933
01:13:29,449 --> 01:13:31,070
正确的 这将免费为您提供经过

1934
01:13:31,070 --> 01:13:32,869
消毒的身体检查，但我

1935
01:13:32,869 --> 01:13:35,090
不知道这一点，然后他声称

1936
01:13:35,090 --> 01:13:37,189
Segel 灯实际上可以做到这一点，

1937
01:13:37,189 --> 01:13:39,320
据我所知，没有嗡嗡声，好吧，没有真正的系统

1938
01:13:39,320 --> 01:13:41,269
实际上做到了这一点，我最后与一个灯光师进行了检查

1939
01:13:41,269 --> 01:13:43,340
晚上

1940
01:13:43,340 --> 01:13:45,409
创作者和他告诉我他们

1941
01:13:45,409 --> 01:13:46,999
不会为 B 加 tr 这样做 ees 但他们这样做是为了

1942
01:13:46,999 --> 01:13:49,189
像倒排索引这样的全表索引，

1943
01:13:49,189 --> 01:13:51,979
因为在数据库系统

1944
01:13:51,979 --> 01:13:53,510
中的第一类对象

1945
01:13:53,510 --> 01:13:55,459
或实体中没有这些东西的概念，因此

1946
01:13:55,459 --> 01:13:56,869
您将它们存储为 blob，并且可以

1947
01:13:56,869 --> 01:13:59,090
免费拍摄存储的 B+

1948
01:13:59,090 --> 01:14:01,010
对待是 分开存储，因为你又知道

1949
01:14:01,010 --> 01:14:03,229
在热中分开页面我认为

1950
01:14:03,229 --> 01:14:04,340
这非常有趣

1951
01:14:04,340 --> 01:14:06,349
，如果我们想要起床，我们

1952
01:14:06,349 --> 01:14:08,269
想要真正离开 BW 树，

1953
01:14:08,269 --> 01:14:09,709
在我们的系统中我们可能想要追求

1954
01:14:09,709 --> 01:14:13,039
这一点，但我们' 会看到没问题 所以两个

1955
01:14:13,039 --> 01:14:15,739
快筏用于蝉 所以这是

1956
01:14:15,739 --> 01:14:16,699
我们将有低

1957
01:14:16,699 --> 01:14:19,249
争用权的第一个工作负载 他们

1958
01:14:19,249 --> 01:14:20,449
将与一堆不同的系统进行比较

1959
01:14:20,449 --> 01:14:22,489
所以两阶段锁定是一种

1960
01:14:22,489 --> 01:14:25,219
标准方法筒仓是 一个

1961
01:14:25,219 --> 01:14:26,570
来自哈佛的系统，将

1962
01:14:26,570 --> 01:14:27,979
在本学期晚些时候讨论一下，他们

1963
01:14:27,979 --> 01:14:29,209
有一个名为 mash tree 的数据结构

1964
01:14:29,209 --> 01:14:30,559
，我们将介绍

1965
01:14:30,559 --> 01:14:33,619
tick-tock 是我

1966
01:14:33,619 --> 01:14:35,989
帮助为 OCC 工作的协议，然后是

1967
01:14:35,989 --> 01:14:37,639
所有 其他一些是筒仓的变体

1968
01:14:37,639 --> 01:14:39,949
hermia 是筒仓

1969
01:14:39,949 --> 01:14:41,630
的更好版本 胎儿是筒仓的更好版本，

1970
01:14:41,630 --> 01:14:44,900
它们有蝉，因此在低争用情况下，

1971
01:14:44,900 --> 01:14:46,760
您会看到 Hecate on 实际上

1972
01:14:46,760 --> 01:14:49,869
在这里做得最差，以及筒仓的这些

1973
01:14:49,869 --> 01:14:52,459
变体 都在

1974
01:14:52,459 --> 01:14:54,739
做同样的事情但是当你有很高的

1975
01:14:54,739 --> 01:14:58,699
竞争时，因为蝉有

1976
01:14:58,699 --> 01:15:00,469
我谈到的所有额外的东西，比如

1977
01:15:00,469 --> 01:15:02,749
早期的吻新检查跳到

1978
01:15:02,749 --> 01:15:04,849
我需要的正确版本正在

1979
01:15:04,849 --> 01:15:06,919
检查验证，看看

1980
01:15:06,919 --> 01:15:10,579
你是否知道什么是 用什么管子或

1981
01:15:10,579 --> 01:15:12,050
我最有可能是哦，我必须中止

1982
01:15:12,050 --> 01:15:13,660
，所以我确保我首先检查，

1983
01:15:13,660 --> 01:15:16,100
因为这就是为什么他们能够

1984
01:15:16,100 --> 01:15:19,070
比其他人做得更好，所以

1985
01:15:19,070 --> 01:15:21,230
蝉的整体架构很

1986
01:15:21,230 --> 01:15:22,220
有趣，但它是

1987
01:15:22,220 --> 01:15:24,050
我认为所有这些一次性的小优化

1988
01:15:24,050 --> 01:15:25,730
都非常有趣，也

1989
01:15:25,730 --> 01:15:27,590
值得追求，所以这

1990
01:15:27,590 --> 01:15:29,150
也可能是另一个项目的结果，

1991
01:15:29,150 --> 01:15:32,510
所以除了蝉

1992
01:15:32,510 --> 01:15:34,520
风格的 B+ tre 我们还可以考虑

1993
01:15:34,520 --> 01:15:36,200
将所有这些早期验证检查添加到我们自己的系统中，

1994
01:15:36,200 --> 01:15:39,050
因为我们正在

1995
01:15:39,050 --> 01:15:42,650
做同样的事情，我以为我已经

1996
01:15:42,650 --> 01:15:43,760
很快完成了最后一部分，

1997
01:15:43,760 --> 01:15:45,290
但主要的想法是只

1998
01:15:45,290 --> 01:15:46,880
显示喜欢而不是处理

1999
01:15:46,880 --> 01:15:48,590
你知道的每笔交易我们都

2000
01:15:48,590 --> 01:15:49,820
从头开始学习我是否会

2001
01:15:49,820 --> 01:15:50,510
中止

2002
01:15:50,510 --> 01:15:52,190
我们可以为下一个交易保留一些信息，

2003
01:15:52,190 --> 01:15:54,140
并

2004
01:15:54,140 --> 01:15:58,010
在我们进行

2005
01:15:58,010 --> 01:16:02,270


2006
01:16:02,270 --> 01:16:04,070
验证时做出更好的决定 是

2007
01:16:04,070 --> 01:16:05,660


2008
01:16:05,660 --> 01:16:07,160
我们讨论过的许多其他设计决策并没有

2009
01:16:07,160 --> 01:16:09,650
完全遵循我们上个月讨论的前向事项

2010
01:16:09,650 --> 01:16:10,580
最后一

2011
01:16:10,580 --> 01:16:13,940
类会影响

2012
01:16:13,940 --> 01:16:15,470
系统性能，具体取决于您是

2013
01:16:15,470 --> 01:16:16,910
针对 o2b 工作负载还是 OLAP

2014
01:16:16,910 --> 01:16:18,980
工作负载 因此，如果您正在

2015
01:16:18,980 --> 01:16:21,830
对 OLAP 查询进行长时间扫描，那么全局

2016
01:16:21,830 --> 01:16:23,300
哈希映射和

2017
01:16:23,300 --> 01:16:24,500
仅用于笔的原始链可能是一个坏

2018
01:16:24,500 --> 01:16:25,760


2019
01:16:25,760 --> 01:16:28,310
主意 呃方式可能会

2020
01:16:28,310 --> 01:16:30,680
更好，因此

2021
01:16:30,680 --> 01:16:32,270
在让这些

2022
01:16:32,270 --> 01:16:33,770
不同的交互层可以

2023
01:16:33,770 --> 01:16:35,900
单独存储内容或将

2024
01:16:35,900 --> 01:16:37,430
冗余信息存储在一个

2025
01:16:37,430 --> 01:16:39,350
位置以减少我们的存储开销之间再次存在这种经典的权衡，

2026
01:16:39,350 --> 01:16:40,940
但这可能会影响性能

2027
01:16:40,940 --> 01:16:42,950
和某些系统 像 Hana 一样，他们决定

2028
01:16:42,950 --> 01:16:46,010
做出这个选择，好吧，所以

2029
01:16:46,010 --> 01:16:47,420
下一节课将是我们关于垃圾收集的最后一堂课，

2030
01:16:47,420 --> 01:16:49,430
所以 Jenna 正在

2031
01:16:49,430 --> 01:16:51,050
阅读 hyper 的另一篇论文，这

2032
01:16:51,050 --> 01:16:53,120
是在 VO 中发表的，或者只是

2033
01:16:53,120 --> 01:16:55,760
去年发表的关于他们如何的更少 做

2034
01:16:55,760 --> 01:16:58,310
垃圾收集，然后我们会

2035
01:16:58,310 --> 01:17:00,530
在最后花时间做一些演示如何

2036
01:17:00,530 --> 01:17:03,050
为第一个项目运行

2037
01:17:03,050 --> 01:17:06,770


2038
01:17:06,770 --> 01:17:10,060


2039
01:17:11,220 --> 01:17:14,070


2040
01:17:14,070 --> 01:17:17,340
perf 麻糬冰块和暴躁的

2041
01:17:17,340 --> 01:17:20,310
你看起来，它是去抓我

2042
01:17:20,310 --> 01:17:22,830
四十只是为了让我的嗡嗡声因为我

2043
01:17:22,830 --> 01:17:25,080
需要像鱼一样多踢

2044
01:17:25,080 --> 01:17:30,840
一次，如果我的嘴唇和只是说

2045
01:17:30,840 --> 01:17:33,960
好和我的引擎盖 w 不是说我

2046
01:17:33,960 --> 01:17:38,240
很高兴对猎物说话

