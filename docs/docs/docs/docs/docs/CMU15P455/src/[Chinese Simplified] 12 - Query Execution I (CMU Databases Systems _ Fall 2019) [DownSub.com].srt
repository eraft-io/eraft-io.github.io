1
00:00:03,640 --> 00:00:13,140
[音乐]

2
00:00:14,260 --> 00:00:16,520
好的，让我们开始吧

3
00:00:16,520 --> 00:00:18,369
[音乐]

4
00:00:18,369 --> 00:00:20,600
再次为 DJ 删除表放弃它

5
00:00:20,600 --> 00:00:22,720
谢谢你

6
00:00:22,720 --> 00:00:24,439
今天真棒

7
00:00:24,439 --> 00:00:27,289
你知道我们为什么要告诉我的数据库 哦

8
00:00:27,289 --> 00:00:28,539


9
00:00:28,539 --> 00:00:31,880
好吧 在我们

10
00:00:31,880 --> 00:00:34,520
再次开始今天的材料之前 只是

11
00:00:34,520 --> 00:00:37,340
提醒

12
00:00:37,340 --> 00:00:39,440
你们在课程作业三中到期或即将完成的事情是

13
00:00:39,440 --> 00:00:41,750
从现在起两天后的星期三

14
00:00:41,750 --> 00:00:45,140
午夜我们将

15
00:00:45,140 --> 00:00:48,739
在下周 16 日的课堂上进行期末考试或抱歉的期中考试

16
00:00:48,739 --> 00:00:52,370
，这将在

17
00:00:52,370 --> 00:00:54,190
正常时间开始 然后我会在

18
00:00:54,190 --> 00:00:57,019
星期三的下一节课结束时做一个快速的期中复习

19
00:00:57,019 --> 00:00:59,379
，然后我们会

20
00:00:59,379 --> 00:01:03,320
像学习指南一样在网站上发布

21
00:01:03,320 --> 00:01:04,459
所有需要了解的关于

22
00:01:04,459 --> 00:01:06,470


23
00:01:06,470 --> 00:01:08,930
本周晚些时候准备期中的信息，然后项目两个 它将

24
00:01:08,930 --> 00:01:11,840
在 10 月 20 日星期日的期中考试之后到期

25
00:01:11,840 --> 00:01:14,780
，然后在第三个项目之后

26
00:01:14,780 --> 00:01:16,640
立即结束，但是

27
00:01:16,640 --> 00:01:17,900
关于您作为学生的任何这些期望的任何问题

28
00:01:17,900 --> 00:01:18,290


29
00:01:18,290 --> 00:01:25,119
是的，他的问题是我们是否会提供

30
00:01:25,119 --> 00:01:28,579
以前的考试是的，我们将提供 aw 我的

31
00:01:28,579 --> 00:01:31,159
解决方案也是如此 是的 可能在

32
00:01:31,159 --> 00:01:37,820
本周末之前 是的 所以我会讲一

33
00:01:37,820 --> 00:01:39,530
件事 是的 你会有一张手写

34
00:01:39,530 --> 00:01:42,500
的笔记 没有幻灯片的副本

35
00:01:42,500 --> 00:01:45,710
没有你知道 缩小版的

36
00:01:45,710 --> 00:01:52,270
教科书 每次通过 再次手写 好吧

37
00:01:52,270 --> 00:01:54,770
我们将介绍更多细节

38
00:01:54,770 --> 00:01:56,479
它将进行调整和调整，包括

39
00:01:56,479 --> 00:01:58,909
周三的课程，因此

40
00:01:58,909 --> 00:02:00,409
本课程和周三课程的所有内容将

41
00:02:00,409 --> 00:02:02,750
在下周的期中涵盖

42
00:02:02,750 --> 00:02:08,240
不是下周一 是的，所以我们一直在

43
00:02:08,240 --> 00:02:11,750
谈论查询 执行没问题，

44
00:02:11,750 --> 00:02:14,780
但到目前为止我们主要关注的

45
00:02:14,780 --> 00:02:16,370
是我们如何

46
00:02:16,370 --> 00:02:19,099
在查询计划中实际实现运算符我们如何进行

47
00:02:19,099 --> 00:02:20,630
排序如何进行哈希连接

48
00:02:20,630 --> 00:02:23,060
等等所以现在我们将开始

49
00:02:23,060 --> 00:02:25,040
将所有这些放在一起以及如何 我们是否

50
00:02:25,040 --> 00:02:27,110
执行端到端查询并

51
00:02:27,110 --> 00:02:30,020
为应用程序生成最终结果，

52
00:02:30,020 --> 00:02:32,570
所以这些都是我们查询计划中的所有运算符

53
00:02:32,570 --> 00:02:34,850
，我们知道如何

54
00:02:34,850 --> 00:02:37,010
进行排序合并哈希连接嵌套循环

55
00:02:37,010 --> 00:02:38,960
连接，我们可以做一个 排序我们知道

56
00:02:38,960 --> 00:02:40,010
进行排序和聚合的不同方法，

57
00:02:40,010 --> 00:02:41,810
所以现在我们试图

58
00:02:41,810 --> 00:02:43,310
将所有这些放在一起并说明

59
00:02:43,310 --> 00:02:46,190
我们如何给出查询计划我们如何

60
00:02:46,190 --> 00:02:48,730
实际继续执行它

61
00:02:48,730 --> 00:02:50,690
所以我们今天讨论了三件事

62
00:02:50,690 --> 00:02:52,490
所以第一件事 是我们要

63
00:02:52,490 --> 00:02:53,690
讨论我们如何真正

64
00:02:53,690 --> 00:02:56,300
正确地处理查询计划，以及我们如何

65
00:02:56,300 --> 00:02:58,070
组织

66
00:02:58,070 --> 00:03:00,410
这些操作符之间的执行流和数据流，

67
00:03:00,410 --> 00:03:03,470
以便它可以产生

68
00:03:03,470 --> 00:03:05,300
快速的结果，我们只会 看看

69
00:03:05,300 --> 00:03:06,410
如何以不同的方式或不同的

70
00:03:06,410 --> 00:03:08,420
环境或不同的存储模型

71
00:03:08,420 --> 00:03:11,210
为我们下面的东西做，然后我们将

72
00:03:11,210 --> 00:03:12,500
讨论访问方法，我们已经

73
00:03:12,500 --> 00:03:15,650


74
00:03:15,650 --> 00:03:17,210
在整个学期中零零碎碎地介绍了如何

75
00:03:17,210 --> 00:03:18,980
进行索引扫描 如何进行调度扫描，

76
00:03:18,980 --> 00:03:20,720
所以现在我们试图

77
00:03:20,720 --> 00:03:22,760
更详细地理解这一点，然后我们将

78
00:03:22,760 --> 00:03:25,190
结束讨论

79
00:03:25,190 --> 00:03:26,630


80
00:03:26,630 --> 00:03:28,850
如果我们有 where 子句，如何评估查询计划中的谓词和表达式

81
00:03:28,850 --> 00:03:32,270
如何 我们要不要 我们如何

82
00:03:32,270 --> 00:03:34,850
将 where 子句应用于元组，无论

83
00:03:34,850 --> 00:03:36,950
我们是在进行频谱扫描还是索引

84
00:03:36,950 --> 00:03:39,830
扫描，您再次

85
00:03:39,830 --> 00:03:43,010
看到我们到目前为止所做的高级想法是我们

86
00:03:43,010 --> 00:03:44,630
现在有一堆零碎的东西

87
00:03:44,630 --> 00:03:46,340
如何排序 如何进行连接 如何

88
00:03:46,340 --> 00:03:48,440
进行索引探测 现在我们开始

89
00:03:48,440 --> 00:03:51,440
将它们放在一起以实际

90
00:03:51,440 --> 00:03:55,310
能够执行

91
00:03:55,310 --> 00:03:56,630


92
00:03:56,630 --> 00:03:59,240


93
00:03:59,240 --> 00:04:02,600
查询 处理模型指定

94
00:04:02,600 --> 00:04:05,120
它将如何正确执行查询计划，

95
00:04:05,120 --> 00:04:07,360
因此本质上它指定

96
00:04:07,360 --> 00:04:09,290
您是否在

97
00:04:09,290 --> 00:04:11,390
顶部从上到下底部，然后在每个

98
00:04:11,390 --> 00:04:13,490
运算符之间实际

99
00:04:13,490 --> 00:04:17,149
从一个到下一个传递什么等等

100
00:04:17,149 --> 00:04:18,560
将是三种不同的

101
00:04:18,560 --> 00:04:21,079
主要方法 我们可以做的三种主要方法，它们

102
00:04:21,079 --> 00:04:22,400
都会有不同的权衡，

103
00:04:22,400 --> 00:04:24,200


104
00:04:24,200 --> 00:04:25,760
对不同的工作负载和不同的

105
00:04:25,760 --> 00:04:28,700
操作环境有不同的性能影响，所以我们

106
00:04:28,700 --> 00:04:29,990
将逐一介绍这些方法 并

107
00:04:29,990 --> 00:04:32,150
展示示例，因此最常见的

108
00:04:32,150 --> 00:04:34,460
将是迭代器模型 这几乎是

109
00:04:34,460 --> 00:04:35,870


110
00:04:35,870 --> 00:04:37,610
您了解的每个数据库系统 这是这是为了

111
00:04:37,610 --> 00:04:38,660
他妈的 这是他们执行

112
00:04:38,660 --> 00:04:41,060
查询的方式 物化模型

113
00:04:41,060 --> 00:04:43,940
是此的专用版本

114
00:04:43,940 --> 00:04:45,979
主要仅用于内存

115
00:04:45,979 --> 00:04:48,319
系统，然后矢量化模型

116
00:04:48,319 --> 00:04:51,139
是基于迭代器

117
00:04:51,139 --> 00:04:52,759
模型的，但是您正在发送成批的

118
00:04:52,759 --> 00:04:55,039
事物或矢量向量或事物，

119
00:04:55,039 --> 00:04:57,380
这在分析工作负载中会更有用，

120
00:04:57,380 --> 00:05:00,889
好吧，因为我 已经

121
00:05:00,889 --> 00:05:02,630
说过迭代器模型是最

122
00:05:02,630 --> 00:05:05,330
常见的一种我认为教科书

123
00:05:05,330 --> 00:05:07,280
将其称为迭代器模型

124
00:05:07,280 --> 00:05:08,449
有时我将其

125
00:05:08,449 --> 00:05:10,940
称为火山模型或管道模型

126
00:05:10,940 --> 00:05:13,520
所以火山之所以

127
00:05:13,520 --> 00:05:14,900
称为火山模型的原因是 因为

128
00:05:14,900 --> 00:05:17,570
在 1980 年代末 1990 年代初在学术界有一个有影响力的系统

129
00:05:17,570 --> 00:05:19,729
叫做

130
00:05:19,729 --> 00:05:22,490
火山，它在高层次上描述了它

131
00:05:22,490 --> 00:05:25,220
正是这种方法人们

132
00:05:25,220 --> 00:05:27,380
正在这样做 最重要的是，这个人

133
00:05:27,380 --> 00:05:29,270
有点安排了你知道

134
00:05:29,270 --> 00:05:31,310
做到这一点的确切方法，同时这就是

135
00:05:31,310 --> 00:05:33,409
我们将在周三讨论的内容，

136
00:05:33,409 --> 00:05:34,849
火山系统是由同一

137
00:05:34,849 --> 00:05:36,289
个人 Gertz graphy 发明的，他写的那

138
00:05:36,289 --> 00:05:37,819
本书被刷新了我们

139
00:05:37,819 --> 00:05:40,280
之前讨论过的也是他们

140
00:05:40,280 --> 00:05:41,630
实现火山查询优化

141
00:05:41,630 --> 00:05:43,580
模型的人，我们将在下周讨论

142
00:05:43,580 --> 00:05:46,520
这个问题，所以这个家伙非常多产，

143
00:05:46,520 --> 00:05:49,400
所以它的基本工作方式是

144
00:05:49,400 --> 00:05:51,380
我们在

145
00:05:51,380 --> 00:05:52,880
我们的数据库系统中的每个操作符 所以如果你想

146
00:05:52,880 --> 00:05:54,169
支持连接我们有一个联合操作

147
00:05:54,169 --> 00:05:56,150
你知道排序我们有一个排序

148
00:05:56,150 --> 00:05:59,330
操作符所以对于所有这些，

149
00:05:59,330 --> 00:06:00,830
他们将实现一个 next

150
00:06:00,830 --> 00:06:04,310
函数，发生的事情是

151
00:06:04,310 --> 00:06:06,650
明显的节点将调用 next 在我们的

152
00:06:06,650 --> 00:06:10,130
子节点上，然后该子节点

153
00:06:10,130 --> 00:06:11,960
将作为下一个

154
00:06:11,960 --> 00:06:14,150
函数的返回结果生成父需要处理的下一个债务元组，

155
00:06:14,150 --> 00:06:16,610
因此您开始

156
00:06:16,610 --> 00:06:18,080
了解这将如何级联，因此

157
00:06:18,080 --> 00:06:20,000
我将在 r 上调用 next  oute 它调用一个

158
00:06:20,000 --> 00:06:21,770
优秀的孩子，它调用它的下一个未

159
00:06:21,770 --> 00:06:23,630
命中的孩子 它会一直下降，直到

160
00:06:23,630 --> 00:06:25,280
我们命中查询计划中的叶节点

161
00:06:25,280 --> 00:06:27,650
，然后我们开始在

162
00:06:27,650 --> 00:06:29,960
查询计划中发出元组并开始

163
00:06:29,960 --> 00:06:33,440
一个一个地处理它们，这就是为什么 他们

164
00:06:33,440 --> 00:06:34,550
将把它称为管道 这也

165
00:06:34,550 --> 00:06:36,830
称为管道模型 这

166
00:06:36,830 --> 00:06:39,500
将允许我们使用单个元组

167
00:06:39,500 --> 00:06:41,719
尝试尽可能地

168
00:06:41,719 --> 00:06:43,760
在查询计划中使用它并继续在

169
00:06:43,760 --> 00:06:45,740
一个中处理它 在我们

170
00:06:45,740 --> 00:06:47,220
返回并获取下一个之前，一个接一个的操作员

171
00:06:47,220 --> 00:06:49,440
，这在基于磁盘的系统中很重要，

172
00:06:49,440 --> 00:06:52,230
因为如果它是每一个，那么你

173
00:06:52,230 --> 00:06:53,640
只能在内存中只有一页，

174
00:06:53,640 --> 00:06:55,590
然后每一个支付或每

175
00:06:55,590 --> 00:06:57,810
一个，但我们去获取那个 在我们返回并让下一页在下一页

176
00:06:57,810 --> 00:06:59,640
工作之前，我们希望

177
00:06:59,640 --> 00:07:01,650
在该元组在内存中时尽可能多地使用该元组

178
00:07:01,650 --> 00:07:03,300
进行工作，

179
00:07:03,300 --> 00:07:06,630
以便

180
00:07:06,630 --> 00:07:08,780
您在给定的查询计划中执行的一系列工作或任务

181
00:07:08,780 --> 00:07:11,760
一个给定的元组将被

182
00:07:11,760 --> 00:07:14,550
称为管道所以 让我们看一下

183
00:07:14,550 --> 00:07:17,310
它是如何工作的概述，它

184
00:07:17,310 --> 00:07:18,570
与我们

185
00:07:18,570 --> 00:07:21,270
之前在 NS 上查看的相同连接或 r ID 等于 s ib

186
00:07:21,270 --> 00:07:22,980
然后我们有一个简单的谓词

187
00:07:22,980 --> 00:07:25,490
，其中 s 值大于 100 所以

188
00:07:25,490 --> 00:07:28,590
通常我不 喜欢在

189
00:07:28,590 --> 00:07:30,570
讲座续集中展示代码不算数，因为

190
00:07:30,570 --> 00:07:33,690
它很漂亮，但就像但为此我们

191
00:07:33,690 --> 00:07:35,820
别无选择，所以这是一些

192
00:07:35,820 --> 00:07:37,800
伪代码，可以向您展示

193
00:07:37,800 --> 00:07:40,320
这些运算符的不同下一个函数

194
00:07:40,320 --> 00:07:42,330
，本质上它们只是用于

195
00:07:42,330 --> 00:07:45,720
循环 正在迭代

196
00:07:45,720 --> 00:07:49,290
他们的子操作符的输出，所以如果你

197
00:07:49,290 --> 00:07:50,640
从一开始就说我们

198
00:07:50,640 --> 00:07:53,040
从我们在根节点上调用 next 的根开始，

199
00:07:53,040 --> 00:07:55,560
这就是

200
00:07:55,560 --> 00:07:58,710
这只是一个投影，所以它有

201
00:07:58,710 --> 00:08:00,120
一个 for 循环

202
00:08:00,120 --> 00:08:02,040
我从 next 回来的孩子中的每一个元组都会说的话

203
00:08:02,040 --> 00:08:05,850
做投影所以

204
00:08:05,850 --> 00:08:07,380
在我们调用 next 的一开始我们

205
00:08:07,380 --> 00:08:09,390
进入这个 for 循环并把它想象

206
00:08:09,390 --> 00:08:10,890
成一个迭代器，我可以继续

207
00:08:10,890 --> 00:08:12,660
调用 next 和 如果我去道琼斯 n 和

208
00:08:12,660 --> 00:08:15,120
Traverse 并产生一个输出，如果我

209
00:08:15,120 --> 00:08:17,220
在我的操作符中再次被调用我知道

210
00:08:17,220 --> 00:08:18,620
如何从我之前离开的地方开始，

211
00:08:18,620 --> 00:08:20,850
所以一开始我们

212
00:08:20,850 --> 00:08:24,000
在根中调用 next 它没有元组所以

213
00:08:24,000 --> 00:08:25,680
它有的第一件事 现在要做的是调用

214
00:08:25,680 --> 00:08:28,740
next 是它的子节点，它是连接

215
00:08:28,740 --> 00:08:31,140
运算符，连接运算符

216
00:08:31,140 --> 00:08:33,000
由两部分或两个阶段组成，正如

217
00:08:33,000 --> 00:08:34,349
我们之前讨论的那样，我们正在

218
00:08:34,349 --> 00:08:36,179
执行哈希连接，我们有构建

219
00:08:36,179 --> 00:08:37,409
阶段 将

220
00:08:37,409 --> 00:08:38,640
在探测阶段的 B 中构建哈希表 我们

221
00:08:38,640 --> 00:08:40,349
将探测哈希表 所以

222
00:08:40,349 --> 00:08:42,929
一开始我在我的

223
00:08:42,929 --> 00:08:44,970
哈希联合运算符中调用 next 我在左孩子上调用 next

224
00:08:44,970 --> 00:08:45,960
因为那时我

225
00:08:45,960 --> 00:08:49,170
想要填充哈希表，

226
00:08:49,170 --> 00:08:52,110
所以现在调用

227
00:08:52,110 --> 00:08:55,470
这个子操作符上的 next 函数，现在你

228
00:08:55,470 --> 00:08:56,970
进入叶节点，这又

229
00:08:56,970 --> 00:08:58,200
是我们的活动方法，这就是

230
00:08:58,200 --> 00:09:00,900
我们如何访问

231
00:09:00,900 --> 00:09:02,880
从索引或 表所以这

232
00:09:02,880 --> 00:09:04,560
只是有它自己的小 for 循环

233
00:09:04,560 --> 00:09:07,350
将迭代关系 R

234
00:09:07,350 --> 00:09:10,080
然后它会承认一个元组，所以对于

235
00:09:10,080 --> 00:09:11,730
每个省略函数，我们传递

236
00:09:11,730 --> 00:09:13,950
一个元组作为

237
00:09:13,950 --> 00:09:16,350
next 调用的返回结果，所以我们将继续

238
00:09:16,350 --> 00:09:18,839
这样做，父级

239
00:09:18,839 --> 00:09:20,130
操作符连接操作符会继续

240
00:09:20,130 --> 00:09:22,560
调用 next 对他的孩子，但是一遍又

241
00:09:22,560 --> 00:09:23,760
一遍，这个东西

242
00:09:23,760 --> 00:09:25,890
在 for 循环中不断发出元组，我们正在

243
00:09:25,890 --> 00:09:27,600
构建我们的哈希表，在某个

244
00:09:27,600 --> 00:09:29,279
时候我们到达最后，我们处理所有

245
00:09:29,279 --> 00:09:31,350
的元组，然后我们只是 传递一个

246
00:09:31,350 --> 00:09:33,600
空指针，然后现在父级

247
00:09:33,600 --> 00:09:34,860
知道我已经得到了我将从我的孩子身上得到的一切

248
00:09:34,860 --> 00:09:35,790


249
00:09:35,790 --> 00:09:39,180


250
00:09:39,180 --> 00:09:40,380


251
00:09:40,380 --> 00:09:42,450


252
00:09:42,450 --> 00:09:44,100
正在循环并

253
00:09:44,100 --> 00:09:47,130
一个一个地获取所有元组，所以

254
00:09:47,130 --> 00:09:49,529
在我们完成左侧之后，现在我们

255
00:09:49,529 --> 00:09:50,850
落到右侧的运算符上，

256
00:09:50,850 --> 00:09:52,770
我们称之为下一个它是

257
00:09:52,770 --> 00:09:54,660
子组，它在这里下降，然后我们只是

258
00:09:54,660 --> 00:09:57,330
省略了一个元组 一个又一个 现在

259
00:09:57,330 --> 00:09:59,910
我们进行探测，然后对于

260
00:09:59,910 --> 00:10:02,010
在我们的哈希表中匹配的任何元组，

261
00:10:02,010 --> 00:10:03,779
当我们进行连接时，我们将其忽略

262
00:10:03,779 --> 00:10:09,839
到父级，所以这很清楚，所以有时

263
00:10:09,839 --> 00:10:10,950
再次将其称为

264
00:10:10,950 --> 00:10:13,980
管道模型的原因是 说在

265
00:10:13,980 --> 00:10:15,870
树的右侧，我们回到

266
00:10:15,870 --> 00:10:17,910
这里，我们接下来调用这个人，他

267
00:10:17,910 --> 00:10:18,959
接下来调用这个人，

268
00:10:18,959 --> 00:10:22,670
现在我们将成为一个元组到这里，所以

269
00:10:22,670 --> 00:10:25,470
我们希望我们把这个元组带入

270
00:10:25,470 --> 00:10:27,300
我们想要的内存中 做尽可能多的工作

271
00:10:27,300 --> 00:10:29,310
来处理

272
00:10:29,310 --> 00:10:31,380
内存中元组的查询墙，而不是调用

273
00:10:31,380 --> 00:10:33,720
next 并获取下一个，

274
00:10:33,720 --> 00:10:37,080
然后我们将它传递到这里，让

275
00:10:37,080 --> 00:10:40,230
我们在执行过滤器之后进行连接，然后

276
00:10:40,230 --> 00:10:41,610
如果匹配 然后我们可以将它传递

277
00:10:41,610 --> 00:10:43,770
到管道更远的地方，然后将它

278
00:10:43,770 --> 00:10:46,380
发送给我们的父级，tank man 将

279
00:10:46,380 --> 00:10:49,050
其作为输出到池中

280
00:10:49,050 --> 00:10:50,760
，然后我们只调用 next

281
00:10:50,760 --> 00:10:51,779
一路返回，然后我们一直这样做

282
00:10:51,779 --> 00:10:54,140
再次所以

283
00:10:54,140 --> 00:10:56,520
我们可以为单个元组在进程中操作的这种系列的运算符

284
00:10:56,520 --> 00:11:00,320
被调用 da 管道

285
00:11:01,410 --> 00:11:02,309
，就像我们

286
00:11:02,309 --> 00:11:05,789
之前讨论过的，当我们

287
00:11:05,789 --> 00:11:07,229
在内存中引入一些东西时，我们

288
00:11:07,229 --> 00:11:08,879
想要做的工作与内存中的钱包一样多，

289
00:11:08,879 --> 00:11:10,410


290
00:11:10,410 --> 00:11:12,660
因为磁盘 i/os 是如此

291
00:11:12,660 --> 00:11:17,399
对我们来说很昂贵，所以迭代器

292
00:11:17,399 --> 00:11:19,379
模型是最常见的模型，它

293
00:11:19,379 --> 00:11:20,579
几乎用在

294
00:11:20,579 --> 00:11:22,439
你能想到的每一个数据库系统中，它们正在

295
00:11:22,439 --> 00:11:26,729
使用迭代器模型，

296
00:11:26,729 --> 00:11:28,079
你这样做的原因是因为它是

297
00:11:28,079 --> 00:11:31,169
从人类的角度来看的 很

298
00:11:31,169 --> 00:11:34,229
容易推断出程序

299
00:11:34,229 --> 00:11:36,449
流程 很容易

300
00:11:36,449 --> 00:11:38,029
推断出什么是内存还是不是内存

301
00:11:38,029 --> 00:11:40,319


302
00:11:40,319 --> 00:11:43,220


303
00:11:43,220 --> 00:11:46,470


304
00:11:46,470 --> 00:11:47,189
我们一直在做

305
00:11:47,189 --> 00:11:49,199
流水线，所以这些将

306
00:11:49,199 --> 00:11:51,329
被称为管道断路器，所以这些

307
00:11:51,329 --> 00:11:53,489
是需要从我们的孩子那里获得更多数据的操作员，

308
00:11:53,489 --> 00:11:55,709
然后我们才能

309
00:11:55,709 --> 00:11:57,059
继续做下一件事情，

310
00:11:57,059 --> 00:11:59,399
所以我的联合示例 这是一个完美的

311
00:11:59,399 --> 00:12:02,459
选择，所以如果我在左边右边打电话，

312
00:12:02,459 --> 00:12:05,189
我会从这个人那里得到一个元组

313
00:12:05,189 --> 00:12:06,959
我必须建立哈希

314
00:12:06,959 --> 00:12:09,299
表我无法在树中进一步处理它，

315
00:12:09,299 --> 00:12:11,189
因为我没有 知道

316
00:12:11,189 --> 00:12:12,389
它是否会与左侧的任何内容匹配，

317
00:12:12,389 --> 00:12:14,339
因此这将

318
00:12:14,339 --> 00:12:15,929
在此管道中称为管道断路器，

319
00:12:15,929 --> 00:12:18,869
因此我进行了扫描，我构建了

320
00:12:18,869 --> 00:12:20,459
哈希表，现在我必须返回并

321
00:12:20,459 --> 00:12:21,600
获取下一个东西，因为我 无法

322
00:12:21,600 --> 00:12:24,779
使用它继续向上树，因此您会

323
00:12:24,779 --> 00:12:26,669
看到相同的顺序字节或子

324
00:12:26,669 --> 00:12:27,929
查询 任何需要您

325
00:12:27,929 --> 00:12:30,929
在向上移动之前拥有更多元组的东西是

326
00:12:30,929 --> 00:12:33,600
管道断路器，它们是不可避免的，

327
00:12:33,600 --> 00:12:35,429
您不能，没有办法

328
00:12:35,429 --> 00:12:38,009
绕过这个

329
00:12:38,009 --> 00:12:39,989
你知道迭代器模型的另一个好处是

330
00:12:39,989 --> 00:12:42,209
像限制子句这样的输出控制

331
00:12:42,209 --> 00:12:45,569
非常容易做，因为现在你

332
00:12:45,569 --> 00:12:47,879
可以在父井中说我只想要

333
00:12:47,879 --> 00:12:48,600
10 到 'pls

334
00:12:48,600 --> 00:12:51,029
所以如果我接下来调用它十次 我

335
00:12:51,029 --> 00:12:53,819
回到了 n 个元组我做对了我

336
00:12:53,819 --> 00:12:56,269
不需要继续保持 再次调用它，

337
00:12:56,269 --> 00:12:58,859
所以 alpha 控制是有效的，它

338
00:12:58,859 --> 00:12:59,759
与此一起工作很好，

339
00:12:59,759 --> 00:13:01,649
并行并行查询也工作

340
00:13:01,649 --> 00:13:03,419
得很好，我们将介绍

341
00:13:03,419 --> 00:13:04,979
下一节如何

342
00:13:04,979 --> 00:13:06,389
在不同线程

343
00:13:06,389 --> 00:13:07,739
或不同机器上同时运行这些运算符

344
00:13:07,739 --> 00:13:14,159
同时，下一个方法是物化

345
00:13:14,159 --> 00:13:15,650


346
00:13:15,650 --> 00:13:18,420
，这里的想法是，不是有

347
00:13:18,420 --> 00:13:20,730
一个输出单个元组的下一个函数，

348
00:13:20,730 --> 00:13:24,210
每个运算符都将在任何时候都转储出所有

349
00:13:24,210 --> 00:13:27,210
元

350
00:13:27,210 --> 00:13:28,410
组，就像所有将要实际发出它的元组一样投票

351
00:13:28,410 --> 00:13:31,980
一下子就出来了，

352
00:13:31,980 --> 00:13:33,960
你不会一直回去并

353
00:13:33,960 --> 00:13:37,650
正确地调用下一个 xmx 所以当然现在

354
00:13:37,650 --> 00:13:40,560
的问题是，如果我们

355
00:13:40,560 --> 00:13:42,090
可能只想要十个两个池，

356
00:13:42,090 --> 00:13:44,180
因为它们有一个限制条款，除非

357
00:13:44,180 --> 00:13:47,190
我们向下传播到

358
00:13:47,190 --> 00:13:48,900
关于顶部可能需要的元组或 X 数量的查询计划信息

359
00:13:48,900 --> 00:13:51,090
最终会

360
00:13:51,090 --> 00:13:52,650
传递比我们实际需要的更多的数据，

361
00:13:52,650 --> 00:13:55,140


362
00:13:55,140 --> 00:13:56,400
所以你需要做一些额外的

363
00:13:56,400 --> 00:13:57,690
事情 不必在迭代器模型中

364
00:13:57,690 --> 00:13:59,550
执行以确保传递的

365
00:13:59,550 --> 00:14:02,550
数据不会超出您的需要，然后输出

366
00:14:02,550 --> 00:14:04,740
可以是实体化的行或

367
00:14:04,740 --> 00:14:06,690
通常在迭代器模型中的单个列，

368
00:14:06,690 --> 00:14:08,910
它通常是整个元组，

369
00:14:08,910 --> 00:14:10,440
就像 整个记录，但在

370
00:14:10,440 --> 00:14:12,000
物化模型中，某些系统

371
00:14:12,000 --> 00:14:14,190
实际上可以传递单个列，但

372
00:14:14,190 --> 00:14:16,800
它是所有元组，因此所有元组

373
00:14:16,800 --> 00:14:18,990
的该单个列

374
00:14:18,990 --> 00:14:22,980
的所有值都可以，所以现在回到我们的

375
00:14:22,980 --> 00:14:24,960
示例，现在我们不再有

376
00:14:24,960 --> 00:14:27,600
现在我们有一个 X 函数，而

377
00:14:27,600 --> 00:14:29,490
不是我们有

378
00:14:29,490 --> 00:14:31,350
这个返回值是一个输出缓冲区

379
00:14:31,350 --> 00:14:33,120
，就像所有元组的列表一样，

380
00:14:33,120 --> 00:14:35,490
所以我们从一开始就

381
00:14:35,490 --> 00:14:37,980
开始调用子输出，然后在

382
00:14:37,980 --> 00:14:40,170
我们的路由中调用下面的操作符

383
00:14:40,170 --> 00:14:42,810
我们和之前一样

384
00:14:42,810 --> 00:14:45,360
，获取左侧的所有元组

385
00:14:45,360 --> 00:14:47,010
来构建我们的哈希表，

386
00:14:47,010 --> 00:14:49,290
结果再次是我们获取的所有元

387
00:14:49,290 --> 00:14:50,460
组，我们的进一步处理

388
00:14:50,460 --> 00:14:52,920
都得到了我们的哈希表然后 g  o

389
00:14:52,920 --> 00:14:55,110
从右侧向下并

390
00:14:55,110 --> 00:14:58,290
向前渗透我们需要向上写入的数据

391
00:14:58,290 --> 00:15:02,690
，它是所有元组

392
00:15:02,690 --> 00:15:04,940


393
00:15:04,940 --> 00:15:11,430


394
00:15:11,430 --> 00:15:13,590


395
00:15:13,590 --> 00:15:16,290
侧面

396
00:15:16,290 --> 00:15:21,180
或右侧或只是一个然后

397
00:15:21,180 --> 00:15:33,620
什么对不起中间那个什么哦是的是

398
00:15:33,620 --> 00:15:44,370
加入右边它是一棵树所以在这个例子中的这个最小

399
00:15:44,370 --> 00:15:47,370
右边这是

400
00:15:47,370 --> 00:15:49,980
投影算子它有一个孩子

401
00:15:49,980 --> 00:15:52,710
它是联合算子但是再次

402
00:15:52,710 --> 00:15:54,630
因为 每个人都在

403
00:15:54,630 --> 00:15:57,930
使用相同的 API 实现标准

404
00:15:57,930 --> 00:16:00,120
这段代码中没有任何内容知道我在

405
00:16:00,120 --> 00:16:02,040
处理连接运算符 每个人都

406
00:16:02,040 --> 00:16:04,410
知道你会返回所有你需要的元组

407
00:16:04,410 --> 00:16:07,020
它是单元组或所有

408
00:16:07,020 --> 00:16:08,130
元组在向量眼中都是向量

409
00:16:08,130 --> 00:16:10,500
模型所以像我主要的收获 II

410
00:16:10,500 --> 00:16:12,390
如果我实现这个标准 API，

411
00:16:12,390 --> 00:16:13,620
它们要么有一个输出函数，要么有一个

412
00:16:13,620 --> 00:16:15,450
下一个函数

413
00:16:15,450 --> 00:16:16,950


414
00:16:16,950 --> 00:16:19,200


415
00:16:19,200 --> 00:16:21,330
尝试一次，所以我现在可以

416
00:16:21,330 --> 00:16:23,070
说我首先建立了我的系统

417
00:16:23,070 --> 00:16:25,710
如果我有这个标准 API，我没有联合操作员

418
00:16:25,710 --> 00:16:27,120
稍后我

419
00:16:27,120 --> 00:16:28,380
可以添加一个联合操作员，它

420
00:16:28,380 --> 00:16:29,550
可以适应并与所有人一起工作 其他

421
00:16:29,550 --> 00:16:32,490
元组 对不起，我会做所有其他的

422
00:16:32,490 --> 00:16:35,070
运算符 它只是一个标准化的 API

423
00:16:35,070 --> 00:16:36,900
它允许我通过

424
00:16:36,900 --> 00:16:39,330
根据

425
00:16:39,330 --> 00:16:45,230
法院实际想要做的事情来插入运算符来编写查询计划所以

426
00:16:45,230 --> 00:16:47,010
再次迭代器之间的主要区别

427
00:16:47,010 --> 00:16:48,330
模型和物化

428
00:16:48,330 --> 00:16:51,060
模型它既不是一个也不是

429
00:16:51,060 --> 00:16:52,860
所有迭代器模型是一个

430
00:16:52,860 --> 00:16:53,250
元组

431
00:16:53,250 --> 00:16:55,010
物化模型一切都

432
00:16:55,010 --> 00:16:58,290
正确所以一旦我调用输出并重新

433
00:16:58,290 --> 00:17:00,480
开始这个操作符它就会吐回

434
00:17:00,480 --> 00:17:02,670
所有我永远不会去的元组的缓冲区

435
00:17:02,670 --> 00:17:04,140
回来并要求更多我有

436
00:17:04,140 --> 00:17:04,709
我需要的一切

437
00:17:04,709 --> 00:17:12,510
是的这些问题是一个

438
00:17:12,510 --> 00:17:14,550
原子化的元组还是一两个块

439
00:17:14,550 --> 00:17:18,500
你是什么意思就像它

440
00:17:19,329 --> 00:17:26,589
在迭代器模型中的一切抱歉所以他

441
00:17:26,589 --> 00:17:27,759
说实施起来会不会更

442
00:17:27,759 --> 00:17:29,619
有效 在你付钱的地方传递一个

443
00:17:29,619 --> 00:17:32,830
元组块而不是一个元组是的

444
00:17:32,830 --> 00:17:34,389
，这是一个矢量化模型，它是

445
00:17:34,389 --> 00:17:38,429
下一个是的，

446
00:17:38,429 --> 00:17:41,789
所以材料代理模型

447
00:17:41,789 --> 00:17:46,570
非常适合 ot 工作负载，因为在 ot

448
00:17:46,570 --> 00:17:48,159
工作负载中你在做什么你的烤饼

449
00:17:48,159 --> 00:17:50,080
获得一个记录 一次或一次

450
00:17:50,080 --> 00:17:53,259
少量的记录，因此

451
00:17:53,259 --> 00:17:55,359
调用下一个退出口音的开销会

452
00:17:55,359 --> 00:17:57,279
渗透到正确的位置

453
00:17:57,279 --> 00:17:58,809
，

454
00:17:58,809 --> 00:18:02,049
如果一切都在内存中，这些函数调用实际上开始变得重要，因为

455
00:18:02,049 --> 00:18:04,450
那是 CPU 上的一个分支，而且

456
00:18:04,450 --> 00:18:06,340
那些很昂贵但是 这是一个跳跃

457
00:18:06,340 --> 00:18:09,609
，你知道在摄取基础中，所以

458
00:18:09,609 --> 00:18:11,019
对于物化模型，如果我们一次只

459
00:18:11,019 --> 00:18:13,509
推一个元组，谁在乎

460
00:18:13,509 --> 00:18:18,220
这真是太棒了，这是超快的，所以

461
00:18:18,220 --> 00:18:19,989
这实际上是我们在两个数据库中实现的方式，

462
00:18:19,989 --> 00:18:21,669
两个数据库都基于一个 我

463
00:18:21,669 --> 00:18:23,019
在研究生院帮助建立的系统称为商店，

464
00:18:23,019 --> 00:18:24,970
商店使用材料到

465
00:18:24,970 --> 00:18:27,159
物化模型，

466
00:18:27,159 --> 00:18:28,659
据我所知，TB 仍然使用相同的东西，

467
00:18:28,659 --> 00:18:30,489
因为它是内存数据库

468
00:18:30,489 --> 00:18:32,649
设计 对于真正快速的事务，它

469
00:18:32,649 --> 00:18:35,739
不能很好地进行分析，所以

470
00:18:35,739 --> 00:18:38,259
这是一个很棒的东西 Monay DB

471
00:18:38,259 --> 00:18:41,820
是一个来自荷兰的内存列存储

472
00:18:41,820 --> 00:18:44,739
系统它是一个很棒的

473
00:18:44,739 --> 00:18:47,739
系统 - 它不适合 Ana 抱歉不是

474
00:18:47,739 --> 00:18:49,539
为了 交易是为了分析我

475
00:18:49,539 --> 00:18:52,210
不知道他们为什么采用这种方法

476
00:18:52,210 --> 00:18:56,440
但他们这样做了而且我还有一堆

477
00:18:56,440 --> 00:18:59,889
我们不想解决的其他问题

478
00:18:59,889 --> 00:19:02,080
但我认为这是一个坏主意

479
00:19:02,080 --> 00:19:03,549
我认为这是正确的选择 对于

480
00:19:03,549 --> 00:19:06,159
volte 光束，好吧，因为如果我再次

481
00:19:06,159 --> 00:19:08,889
扫描 10 亿个元组，除非我的

482
00:19:08,889 --> 00:19:11,529
过滤器是超级选择性的，否则我可以将

483
00:19:11,529 --> 00:19:13,389
10 亿到 +1 操作推到

484
00:19:13,389 --> 00:19:15,399
下一个只在

485
00:19:15,399 --> 00:19:16,690
我不需要的查询计划中定义上面 十亿来

486
00:19:16,690 --> 00:19:18,789
摆姿势我不需要像你知道的那样可能有

487
00:19:18,789 --> 00:19:20,919
10% 所以你最终移动了

488
00:19:20,919 --> 00:19:22,059
比你实际需要的更多的数据

489
00:19:22,059 --> 00:19:25,539
用这种方法好吧，所以

490
00:19:25,539 --> 00:19:28,509
现在他的建议就是我们正在

491
00:19:28,509 --> 00:19:29,980
谈论的 这是我

492
00:19:29,980 --> 00:19:32,530
通过的每一个下一次调用，而不是

493
00:19:32,530 --> 00:19:34,780
沿着一批元组，我们的

494
00:19:34,780 --> 00:19:36,160
向量元组而不是单个元组

495
00:19:36,160 --> 00:19:38,710
不会更有效率，是的，所以

496
00:19:38,710 --> 00:19:39,790
这就是向量化模型

497
00:19:39,790 --> 00:19:42,250
在每次调用 next 时再次这样做

498
00:19:42,250 --> 00:19:43,780
我们得到一批元组

499
00:19:43,780 --> 00:19:46,030
而不是单个元组然后 现在

500
00:19:46,030 --> 00:19:48,160
我们要设计我们的系统，

501
00:19:48,160 --> 00:19:49,930
使得内部循环这些运算符实现的内核，

502
00:19:49,930 --> 00:19:52,780
它们

503
00:19:52,780 --> 00:19:54,220
将被重写或设计为

504
00:19:54,220 --> 00:19:56,350
对元组向量

505
00:19:56,350 --> 00:20:01,030
而不是单个元组进行操作，

506
00:20:01,030 --> 00:20:02,530
因此 您

507
00:20:02,530 --> 00:20:04,570
将为 next 的每个职业吐出的批次

508
00:20:04,570 --> 00:20:07,270
可能取决于它的

509
00:20:07,270 --> 00:20:09,490


510
00:20:09,490 --> 00:20:12,010


511
00:20:12,010 --> 00:20:13,900


512
00:20:13,900 --> 00:20:15,820
难易程度，因此这也可以基于实际存储设备的速度与 chaleurs 的速度 /o 但也可能

513
00:20:15,820 --> 00:20:18,280
因您的 CPU 的外观而异，所以我们

514
00:20:18,280 --> 00:20:19,810
不会在这里讨论这个问题，因为我们

515
00:20:19,810 --> 00:20:21,340
在本课程中没有说过我们

516
00:20:21,340 --> 00:20:22,870
不会担心 CPU 寄存器和

517
00:20:22,870 --> 00:20:25,150
缓存线，但如果一切都合适 在

518
00:20:25,150 --> 00:20:28,360
记忆中 现代 CPU 有一些

519
00:20:28,360 --> 00:20:30,190
指令允许您在这样

520
00:20:30,190 --> 00:20:32,020


521
00:20:32,020 --> 00:20:33,700
的时间对一大块数据进行向量化执行反射运算符，

522
00:20:33,700 --> 00:20:35,500
如果您使用

523
00:20:35,500 --> 00:20:37,930
418 或并行

524
00:20:37,930 --> 00:20:41,950
类 6 18 14，那么如果您

525
00:20:41,950 --> 00:20:43,270
现在有一个批处理，则称为 sim d 现在可以

526
00:20:43,270 --> 00:20:45,340
适合您的数据和带有这条指令的 ycp 寄存器，

527
00:20:45,340 --> 00:20:46,660
您可以

528
00:20:46,660 --> 00:20:48,820
应用谓词或评估您

529
00:20:48,820 --> 00:20:50,800
知道该数据上的一些运算符非常

530
00:20:50,800 --> 00:20:53,020
有效，所以这就是为什么这种

531
00:20:53,020 --> 00:20:55,000
矢量化方法实际上是一个

532
00:20:55,000 --> 00:20:58,210
好主意，所以再次 它现在看起来

533
00:20:58,210 --> 00:21:01,150
基本上像迭代器模型，但是

534
00:21:01,150 --> 00:21:05,050
旁边的名词在我们的

535
00:21:05,050 --> 00:21:07,570
内核函数内部，用于运算符我们有

536
00:21:07,570 --> 00:21:09,940
这个输出缓冲区，然后我们只

537
00:21:09,940 --> 00:21:11,350
检查输出缓冲区是否

538
00:21:11,350 --> 00:21:15,760
随着我们的下降而大于我们想要的大小

539
00:21:15,760 --> 00:21:17,500
发出，如果是，那么我们推回

540
00:21:17,500 --> 00:21:20,620
一个元组批次，但它仍然是同

541
00:21:20,620 --> 00:21:22,150
一种模型，或者只是你知道每个

542
00:21:22,150 --> 00:21:23,650
含义，然后下到我们的

543
00:21:23,650 --> 00:21:25,360
孩子一个孩子做某种

544
00:21:25,360 --> 00:21:27,160
处理ma  ybe 去一个孩子那里获取

545
00:21:27,160 --> 00:21:29,080
一些数据，一旦

546
00:21:29,080 --> 00:21:30,910
我们在批处理中拥有了我们需要的一切，然后我们将其推入

547
00:21:30,910 --> 00:21:37,020
并让它进行处理，所以这很清楚，

548
00:21:37,250 --> 00:21:40,170
所以矢量化模型

549
00:21:40,170 --> 00:21:42,750
非常适合分析查询，因为

550
00:21:42,750 --> 00:21:44,580
他们在做什么分析查询

551
00:21:44,580 --> 00:21:46,680
是 对桌子的大部分进行长时间扫描

552
00:21:46,680 --> 00:21:48,780
，因此而

553
00:21:48,780 --> 00:21:49,920
不是每次假期我们的脖子

554
00:21:49,920 --> 00:21:51,240
都离球太近了，我

555
00:21:51,240 --> 00:21:53,340
得到了一批双打，批次的

556
00:21:53,340 --> 00:21:55,170
大小可能

557
00:21:55,170 --> 00:21:56,400
会根据数据的来源和 你

558
00:21:56,400 --> 00:21:58,740
将如何正确地处理它 这是

559
00:21:58,740 --> 00:21:59,730
我之前谈到的简单的东西

560
00:21:59,730 --> 00:22:03,780
所以在过去的十年左右构建的每个主要数据仓库

561
00:22:03,780 --> 00:22:07,800
我的意思

562
00:22:07,800 --> 00:22:10,110
是使用向量向量化模型是

563
00:22:10,110 --> 00:22:12,090
正确的，因为性能影响

564
00:22:12,090 --> 00:22:13,860
非常显着 这实际上

565
00:22:13,860 --> 00:22:15,030
是我们在我们这里构建的系统中使用的

566
00:22:15,030 --> 00:22:20,940
所以这是剪辑 所以

567
00:22:20,940 --> 00:22:22,650
总的来说我们将专注于

568
00:22:22,650 --> 00:22:24,690
迭代器模型 但还有其他方法可以

569
00:22:24,690 --> 00:22:26,820
做到这一点 我已经使用了向量

570
00:22:26,820 --> 00:22:28,200
ctorize 模型很容易看出如何

571
00:22:28,200 --> 00:22:29,360
扩展迭代器模型

572
00:22:29,360 --> 00:22:31,290
物化模型实际上只

573
00:22:31,290 --> 00:22:50,430
出现在专门的系统

574
00:22:50,430 --> 00:22:52,050


575
00:22:52,050 --> 00:22:54,030


576
00:22:54,030 --> 00:23:12,810


577
00:23:12,810 --> 00:23:16,640
中 一切都在内存中，然后在

578
00:23:16,640 --> 00:23:19,950
物化模型中，即使对于 OLAP

579
00:23:19,950 --> 00:23:21,270


580
00:23:21,270 --> 00:23:22,950


581
00:23:22,950 --> 00:23:24,240
，如果您只取回所有内容，那么不必一遍又一遍地调用 x 轴颈部仍然是一个好处，

582
00:23:24,240 --> 00:23:28,110
是的，但是如果您正在阅读

583
00:23:28,110 --> 00:23:30,390
大量数据和 如果

584
00:23:30,390 --> 00:23:34,110


585
00:23:34,110 --> 00:23:35,430
您的谓词没有足够的选择性，您将无法下推谓词，

586
00:23:35,430 --> 00:23:38,640
这意味着您

587
00:23:38,640 --> 00:23:41,640
输出的数据量很大，就像我的表

588
00:23:41,640 --> 00:23:43,740
有 100 GB 一样，而我现在

589
00:23:43,740 --> 00:23:46,830
正在推高 你知道 90 GB 的

590
00:23:46,830 --> 00:23:49,050
数据你很聪明，如果你在

591
00:23:49,050 --> 00:23:50,659
做后期实现 停止

592
00:23:50,659 --> 00:23:52,519
谈论如果你正在复制大量数据

593
00:23:52,519 --> 00:24:05,239
然后它很糟糕混合术语

594
00:24:05,239 --> 00:24:07,220
或者混合环境 我是说

595
00:24:07,220 --> 00:24:08,989
这适用于 m  emory 系统我认为

596
00:24:08,989 --> 00:24:11,139
这对基于磁盘的

597
00:24:11,139 --> 00:24:13,879
系统不好，我不知道任何

598
00:24:13,879 --> 00:24:16,700
基于磁盘的系统实际上在内存中执行此操作，

599
00:24:16,700 --> 00:24:18,979
因此对于基于磁盘的

600
00:24:18,979 --> 00:24:23,509
系统，矢量化模型仍然会更好，

601
00:24:23,509 --> 00:24:26,629
因为您知道 内存量

602
00:24:26,629 --> 00:24:28,159
不是内存我必须保留

603
00:24:28,159 --> 00:24:30,799
中间结果的量较小我不能

604
00:24:30,799 --> 00:24:32,330
我不想在我的管道上溢出磁盘

605
00:24:32,330 --> 00:24:33,950


606
00:24:33,950 --> 00:24:36,139
所以矢量化模型更

607
00:24:36,139 --> 00:24:41,029
适合 OLAP 系统你摇头 好像

608
00:24:41,029 --> 00:24:50,289
你很困惑

609
00:24:50,289 --> 00:24:55,009
好吧好吧好吧好吧 你想谈论的最后一件事

610
00:24:55,009 --> 00:24:55,609


611
00:24:55,609 --> 00:24:58,039
我只是我们不会

612
00:24:58,039 --> 00:24:59,419
太关注这个 我只是想

613
00:24:59,419 --> 00:25:02,299
知道在所有处理模型

614
00:25:02,299 --> 00:25:03,919
示例中 我展示了迭代器我

615
00:25:03,919 --> 00:25:05,869
一直在螯合和矢量化我展示了一种

616
00:25:05,869 --> 00:25:08,359
自上而下的方法，这意味着我们从

617
00:25:08,359 --> 00:25:10,309
我们调用 next 或输出的路由开始

618
00:25:10,309 --> 00:25:13,039
，它渗透到调用

619
00:25:13,039 --> 00:25:15,229
树中，然后我们开始将数据

620
00:25:15,229 --> 00:25:18,529
拉到根

621
00:25:18,529 --> 00:25:19,999
人们实施曲的最常见方式 ery 执行

622
00:25:19,999 --> 00:25:22,220
记录 查询处理模型 但

623
00:25:22,220 --> 00:25:24,769
你可以从另一个方向

624
00:25:24,769 --> 00:25:27,710
开始 你可以从底部开始并实际

625
00:25:27,710 --> 00:25:31,309
将数据向上推 这有点罕见 我们

626
00:25:31,309 --> 00:25:35,119
在 volte B 中再次这样做

627
00:25:35,119 --> 00:25:37,700
我们今天在我们的新系统中这样做 超级输出

628
00:25:37,700 --> 00:25:39,349
德国也这样做，

629
00:25:39,349 --> 00:25:41,479
你之所以要这样做，是因为现在我们

630
00:25:41,479 --> 00:25:43,129
可以更加蹩脚和更加

631
00:25:43,129 --> 00:25:45,529
小心，因为我们将数据向上移动以

632
00:25:45,529 --> 00:25:48,409


633
00:25:48,409 --> 00:25:50,179
确保我们正在处理的登船信息可以闲置 在

634
00:25:50,179 --> 00:25:52,669
我们的 CPU 缓存和寄存器中，所以如果

635
00:25:52,669 --> 00:25:53,989
你非常小心你的内存

636
00:25:53,989 --> 00:25:55,429
放置和你的内存分配，

637
00:25:55,429 --> 00:25:58,580
这种方式是可取的，但这

638
00:25:58,580 --> 00:26:00,070
假设一切都适合内存

639
00:26:00,070 --> 00:26:02,269
，因此对于

640
00:26:02,269 --> 00:26:04,380
基于磁盘的系统，

641
00:26:04,380 --> 00:26:06,600
这种方法也是 作为人类有点难以

642
00:26:06,600 --> 00:26:07,950
推理，因为我们

643
00:26:07,950 --> 00:26:10,710
以一种对我们来说可能不自然的方式拥有正确的程序，

644
00:26:10,710 --> 00:26:12,630
因为我们通常会

645
00:26:12,630 --> 00:26:15,059
考虑如何编写正确的代码

646
00:26:15,059 --> 00:26:16,470
从人类的角度来看，我们又是这个人，

647
00:26:16,470 --> 00:26:17,820
这很容易 呃，我

648
00:26:17,820 --> 00:26:19,830
接下来打电话给我的孩子，它给了我一些

649
00:26:19,830 --> 00:26:21,990
数据，这实际上就像精心

650
00:26:21,990 --> 00:26:23,970
制作程序，以这样一种方式

651
00:26:23,970 --> 00:26:26,549
对 CPU 更好，但

652
00:26:26,549 --> 00:26:28,190
对人类来说更难以

653
00:26:28,190 --> 00:26:30,179
再次推理我不想走太多

654
00:26:30,179 --> 00:26:31,860
如果你

655
00:26:31,860 --> 00:26:32,940
在春季参加高级课程，这是一些细节，

656
00:26:32,940 --> 00:26:35,909
我们将介绍这一点 对你们的主要收获

657
00:26:35,909 --> 00:26:37,260
是每个人都

658
00:26:37,260 --> 00:26:42,720
在大多数情况下实现了最重要的部分 好的，所以

659
00:26:42,720 --> 00:26:43,980
现在让我们谈谈这片叶子上发生了什么

660
00:26:43,980 --> 00:26:46,740
节点或在我们的查询计划中

661
00:26:46,740 --> 00:26:48,210
所以这些是访问方法 这些

662
00:26:48,210 --> 00:26:49,350
是我们实际上如何

663
00:26:49,350 --> 00:26:51,690
从我们的表中的数据库中检索数据

664
00:26:51,690 --> 00:26:54,750
然后能够将它们

665
00:26:54,750 --> 00:26:57,120
传递给我们的下一个操作符 所以我们已经

666
00:26:57,120 --> 00:26:59,789
基本上涵盖了这些我已经 只需多

667
00:26:59,789 --> 00:27:01,860
花一点时间，然后再复习

668
00:27:01,860 --> 00:27:03,480
一遍，然后我们将讨论如何

669
00:27:03,480 --> 00:27:05,580
使用多个索引来执行此操作，

670
00:27:05,580 --> 00:27:07,590
因此通常有两种方法，您

671
00:27:07,590 --> 00:27:09,179
要么从索引中读取数据，要么

672
00:27:09,179 --> 00:27:10,980
从表中读取数据 h

673
00:27:10,980 --> 00:27:14,279
顺序扫描和索引并非总是如此，

674
00:27:14,279 --> 00:27:15,750
但根据

675
00:27:15,750 --> 00:27:17,760
您正在执行的查询可能更可取，如果我没有索引，则后备

676
00:27:17,760 --> 00:27:19,080
解决方案始终是顺序扫描

677
00:27:19,080 --> 00:27:20,580
s 可以做我

678
00:27:20,580 --> 00:27:22,110
想做的事，或者它有 就像

679
00:27:22,110 --> 00:27:23,850
我的查询的正确属性一样，我只是回

680
00:27:23,850 --> 00:27:26,820
退到特殊扫描，

681
00:27:26,820 --> 00:27:28,289
多索引只是它的扩展，

682
00:27:28,289 --> 00:27:29,940
它允许您知道设置它访问

683
00:27:29,940 --> 00:27:32,070
一个索引我们可以访问多个索引

684
00:27:32,070 --> 00:27:35,630
并将它们的结果组合在一起

685
00:27:35,630 --> 00:27:39,269
好吧 再次扫描毛衣我们已经

686
00:27:39,269 --> 00:27:41,639
多次讨论过它实际上

687
00:27:41,639 --> 00:27:43,679
只是我们运算符内部的一堆四个循环，

688
00:27:43,679 --> 00:27:47,639
因此扫描运算符将

689
00:27:47,639 --> 00:27:49,440
在我们表中的单个页面上迭代十次

690
00:27:49,440 --> 00:27:51,929
，然后对于每个页面我们

691
00:27:51,929 --> 00:27:53,909
迭代到业务 那些页面

692
00:27:53,909 --> 00:27:56,250
，然后我们可以对它们做任何我们

693
00:27:56,250 --> 00:27:58,470
想做的工作，然后我们可以

694
00:27:58,470 --> 00:28:01,169
根据需要将它们省略到下一个操作符，

695
00:28:01,169 --> 00:28:03,149
所以

696
00:28:03,149 --> 00:28:05,250
如果你熟悉 Python 的话，它的实现方式就像一个游标

697
00:28:05,250 --> 00:28:06,750
收益率 f

698
00:28:06,750 --> 00:28:10,200
迭代器的unction 基本上我称之为我的

699
00:28:10,200 --> 00:28:11,610
for循环，我在我的迭代器上调用next

700
00:28:11,610 --> 00:28:13,169
，然后当我到达下一页时，

701
00:28:13,169 --> 00:28:14,909
我可以迭代每个元组

702
00:28:14,909 --> 00:28:16,710
，然后我可以调用其他一些函数

703
00:28:16,710 --> 00:28:17,290
或

704
00:28:17,290 --> 00:28:18,910
将此控制传递回另一个

705
00:28:18,910 --> 00:28:21,100
部分 系统的一部分，然后如果

706
00:28:21,100 --> 00:28:22,480
有人回来说我会给

707
00:28:22,480 --> 00:28:24,040
我下一个元组，我知道如何

708
00:28:24,040 --> 00:28:25,270
从我离开的地方开始，

709
00:28:25,270 --> 00:28:27,550
所以操作员必须保持

710
00:28:27,550 --> 00:28:29,080
迭代器

711
00:28:29,080 --> 00:28:30,760
每次关闭时停止的状态，并且 返回一个

712
00:28:30,760 --> 00:28:32,650
元组，这样当我们回来时，我们可以

713
00:28:32,650 --> 00:28:37,030
从我们离开的地方开始，

714
00:28:37,030 --> 00:28:39,430
这是典型的方式，这

715
00:28:39,430 --> 00:28:44,830
在系统中经常被称为游标，所以

716
00:28:44,830 --> 00:28:46,360
我们可以做很多优化来使

717
00:28:46,360 --> 00:28:48,250
我们的 scruncho 扫描速度更快，并且 我们已经

718
00:28:48,250 --> 00:28:49,510
介绍了其中一些已经正确的

719
00:28:49,510 --> 00:28:51,520
抢注者可以再次这是它的

720
00:28:51,520 --> 00:28:53,920
后备选项如果我们没有

721
00:28:53,920 --> 00:28:55,000
索引所以我们有更好的方法来

722
00:28:55,000 --> 00:28:56,890
处理查询但它很慢

723
00:28:56,890 --> 00:28:58,720
尤其是在基于盘的系统中

724
00:28:58,720 --> 00:29:00,570
每个 单页 c 应该在磁盘上，

725
00:29:00,570 --> 00:29:02,350
所以有很多我们

726
00:29:02,350 --> 00:29:03,700
已经介绍过的，我们谈到了

727
00:29:03,700 --> 00:29:05,710
预取，这是进行连接的双缓冲区

728
00:29:05,710 --> 00:29:08,440
优化我们

729
00:29:08,440 --> 00:29:10,330
谈到了完全绕过，而不是

730
00:29:10,330 --> 00:29:12,670
污染我们的缓冲池缓存，我们

731
00:29:12,670 --> 00:29:14,500
有一点 侧缓冲区仅用于我们的线程

732
00:29:14,500 --> 00:29:16,630
或查询，我们将

733
00:29:16,630 --> 00:29:18,930
在下一堂课中讨论如何并行运行顺序扫描，

734
00:29:18,930 --> 00:29:21,430
所以我想再次关注这三个，

735
00:29:21,430 --> 00:29:23,290
其中一些我们已经

736
00:29:23,290 --> 00:29:25,300
涵盖，但这些只是方法

737
00:29:25,300 --> 00:29:27,430
和使 当 Cho 扫描速度更快并且

738
00:29:27,430 --> 00:29:30,010
我们再次没有

739
00:29:30,010 --> 00:29:31,720
什么可以神奇地询问何时选择

740
00:29:31,720 --> 00:29:34,360
可以更快的想法时，就像我们受到

741
00:29:34,360 --> 00:29:35,980
从磁盘读取数据

742
00:29:35,980 --> 00:29:38,560
并将其带入内存的速度的限制，但如果有办法

743
00:29:38,560 --> 00:29:40,360
让我们 弄清楚如何做更少的工作

744
00:29:40,360 --> 00:29:42,610
，这个目标就是我们想要做的

745
00:29:42,610 --> 00:29:43,930
，这就是这些

746
00:29:43,930 --> 00:29:47,800
优化试图让我们做的事情，所以区域

747
00:29:47,800 --> 00:29:50,200
地图实际上是他

748
00:29:50,200 --> 00:29:52,480
之前提出的关于预计算的一些讲座的内容。

749
00:29:52,480 --> 00:29:55,030
关于页面的信息，让我们

750
00:29:55,030 --> 00:29:55,960
能够确定我们是否真的

751
00:29:55,960 --> 00:29:58,960
需要访问它们，因此

752
00:29:58,960 --> 00:30:00,370
区域映射的基本思想是，对于

753
00:30:00,370 --> 00:30:02,830
我们数据库和表中的每个页面，

754
00:30:02,830 --> 00:30:04,750
我们都会有一些额外的

755
00:30:04,750 --> 00:30:07,480
元数据“ 已经从该页面计算或派生，

756
00:30:07,480 --> 00:30:10,600
该页面为我们提供了关于

757
00:30:10,600 --> 00:30:13,390


758
00:30:13,390 --> 00:30:15,310
给定属性的页面内的值是什么的信息，

759
00:30:15,310 --> 00:30:17,200
所以假设我们有一个

760
00:30:17,200 --> 00:30:18,760
非常简单的表，它只有一

761
00:30:18,760 --> 00:30:20,860
列，然后在单个页面中我们

762
00:30:20,860 --> 00:30:22,720
只有五个元组，

763
00:30:22,720 --> 00:30:25,090
因此缩放地图可以具有

764
00:30:25,090 --> 00:30:27,700
有关此列的此页面内的值的计算机前汇总信息，

765
00:30:27,700 --> 00:30:29,710


766
00:30:29,710 --> 00:30:30,700


767
00:30:30,700 --> 00:30:34,480
因此最小/最大平均值某些帐户所以

768
00:30:34,480 --> 00:30:37,029
现在如果我查询出现它看起来

769
00:30:37,029 --> 00:30:38,230
像这样所以让我们从

770
00:30:38,230 --> 00:30:41,700
值大于 600 的表所以

771
00:30:41,700 --> 00:30:43,960
没有区域地图我该怎么

772
00:30:43,960 --> 00:30:45,879
做它是一个顺序扫描我去抓取

773
00:30:45,879 --> 00:30:47,379
这个页面现在我开始

774
00:30:47,379 --> 00:30:48,940
遍历每个元组并

775
00:30:48,940 --> 00:30:50,440
评估我的谓词以查看我是否

776
00:30:50,440 --> 00:30:53,139
找到一个匹配，但如果我有一个

777
00:30:53,139 --> 00:30:55,389
区域地图，我可以说得很好，我知道我

778
00:30:55,389 --> 00:30:57,309
想我需要访问此页面让我

779
00:30:57,309 --> 00:30:59,379
去看看区域地图我正在寻找

780
00:30:59,379 --> 00:31:01,899
大于 600 的值，同时我去检查

781
00:31:01,899 --> 00:31:04,029
并说

782
00:31:04,029 --> 00:31:06,940
这个列和这个页面的最大值是 400，所以我

783
00:31:06,940 --> 00:31:09,159
知道没有任何值或任何

784
00:31:09,159 --> 00:31:11,679
值大于 400 的元组，

785
00:31:11,679 --> 00:31:13,690
因此我的页面中没有任何内容

786
00:31:13,690 --> 00:31:15,789
与我的谓词匹配，所以我只是跳过

787
00:31:15,789 --> 00:31:18,960
查看 整个页面完全

788
00:31:19,049 --> 00:31:21,789
正确，所以现在你说好的

789
00:31:21,789 --> 00:31:23,980
缩放地图实际上存储在哪里一些

790
00:31:23,980 --> 00:31:25,179
系统可以将它打包在页面

791
00:31:25,179 --> 00:31:26,590
本身所以你应该把

792
00:31:26,590 --> 00:31:28,419
页面带进来但至少现在你没有

793
00:31:28,419 --> 00:31:30,940
迭代其他

794
00:31:30,940 --> 00:31:32,259
系统可以的每个元组 实际上将这些区域

795
00:31:32,259 --> 00:31:34,779
地图存储为单独的页面，所以我会有

796
00:31:34,779 --> 00:31:37,090
一个区域地图块或缩放页面，该页面

797
00:31:37,090 --> 00:31:38,590
具有不同页面的一堆区域地图，

798
00:31:38,590 --> 00:31:40,899
所以可能会

799
00:31:40,899 --> 00:31:43,419
更频繁地留在内存中，

800
00:31:43,419 --> 00:31:45,399
然后我只是跳转到 该页面检查

801
00:31:45,399 --> 00:31:46,869
区域地图 然后决定我是要

802
00:31:46,869 --> 00:31:48,399
转到下一页还是实际

803
00:31:48,399 --> 00:31:52,899
访问底层页面，所以我使用

804
00:31:52,899 --> 00:31:54,840
术语区域映射，因为这

805
00:31:54,840 --> 00:31:58,989
是常用术语，我忘记

806
00:31:58,989 --> 00:32:01,029
了是不是 ISA 或 Oracle 发明了

807
00:32:01,029 --> 00:32:02,679
这个术语，而是 Oracle 如果 你去谷歌

808
00:32:02,679 --> 00:32:04,600
Oracle 自己的地图是一堆

809
00:32:04,600 --> 00:32:06,580
文档我不知道这

810
00:32:06,580 --> 00:32:08,019
是否是一个商标术语，因为

811
00:32:08,019 --> 00:32:10,960
其他系统不使用该术语，

812
00:32:10,960 --> 00:32:12,279
但今天几乎每个主要数据仓库都再次发现它

813
00:32:12,279 --> 00:32:14,109
，

814
00:32:14,109 --> 00:32:15,970
因为性能优势相当

815
00:32:15,970 --> 00:32:19,080
很重要，因为磁盘太慢了，所以

816
00:32:19,080 --> 00:32:21,159


817
00:32:21,159 --> 00:32:22,720
你可以想象你可以根据这些统计数据进行一系列不同类型的查询，

818
00:32:22,720 --> 00:32:24,190


819
00:32:24,190 --> 00:32:25,769


820
00:32:25,769 --> 00:32:28,029
我们有一个问题是它们

821
00:32:28,029 --> 00:32:35,129
虽然保持完全正确，所以

822
00:32:35,129 --> 00:32:38,289
每当我更新某些内容时 在这里，

823
00:32:38,289 --> 00:32:39,730
我必须确保这实际上

824
00:32:39,730 --> 00:32:40,599
是同步的，因为我不想有一个

825
00:32:40,599 --> 00:32:42,159
假的假阴性 我不想

826
00:32:42,159 --> 00:32:43,539
看着我的缩小并说

827
00:32:43,539 --> 00:32:44,360
我没有匹配项

828
00:32:44,360 --> 00:32:47,960
她我这样做这些通常是

829
00:32:47,960 --> 00:32:49,309
我在这里展示的所有这些系统

830
00:32:49,309 --> 00:32:51,200
这些运行用于

831
00:32:51,200 --> 00:32:53,210
分析的东西 但你

832
00:32:53,210 --> 00:32:56,000
不想用作 OMAP 400 TP 因为你

833
00:32:56,000 --> 00:32:57,200
必须再次维护

834
00:32:57,200 --> 00:32:58,880
它们会非常好 昂贵但对于

835
00:32:58,880 --> 00:33:00,380
分析来说，一旦阅读很多，它通常就像正确的

836
00:33:00,380 --> 00:33:03,380
那样，所以地图是一个巨大的

837
00:33:03,380 --> 00:33:04,970
胜利，这就是为什么所有主要

838
00:33:04,970 --> 00:33:09,380
系统实际上都支持这些，

839
00:33:09,380 --> 00:33:10,790
所以下一个优化是

840
00:33:10,790 --> 00:33:12,770
我们在确保

841
00:33:12,770 --> 00:33:14,540
每个人都理解之前讨论过的事情 对于

842
00:33:14,540 --> 00:33:17,049
细节，这是延迟实现，

843
00:33:17,049 --> 00:33:20,510
因此对于列存储系统，我们实际上

844
00:33:20,510 --> 00:33:24,590
可以延迟或不延迟或避免必须

845
00:33:24,590 --> 00:33:27,919
从下一个提供的数据传播数据，

846
00:33:27,919 --> 00:33:29,840
并且 Stampede 会沿所有

847
00:33:29,840 --> 00:33:31,669
集合或列 ID 传递，以允许我们

848
00:33:31,669 --> 00:33:34,940
获取实际数据 我们

849
00:33:34,940 --> 00:33:36,740
稍后在行存储系统中需要的数据通常是

850
00:33:36,740 --> 00:33:38,840
操作符，输出将是实际的

851
00:33:38,840 --> 00:33:40,640
整个元组，因为我已经

852
00:33:40,640 --> 00:33:42,860
将文件转到磁盘以获取它

853
00:33:42,860 --> 00:33:45,440
具有该元组的页面，我可能 只需将

854
00:33:45,440 --> 00:33:47,570
整个元组传递到查询计划树上

855
00:33:47,570 --> 00:33:49,970
，而不必回去

856
00:33:49,970 --> 00:33:53,360
获取更多数据，而是在列存储中

857
00:33:53,360 --> 00:33:55,160
获取单个元组的所有数据，

858
00:33:55,160 --> 00:33:56,780
这是一堆不同的读取，

859
00:33:56,780 --> 00:33:58,400
因为数据已损坏 跨越

860
00:33:58,400 --> 00:34:00,710
不同的列，因此我

861
00:34:00,710 --> 00:34:02,929
想避免这种情况，因为我想尽可能地延迟

862
00:34:02,929 --> 00:34:05,390
它，所以假设我们

863
00:34:05,390 --> 00:34:07,940
连接了两个表 foo 和 bar

864
00:34:07,940 --> 00:34:10,460
并说食物表有三列

865
00:34:10,460 --> 00:34:14,030
a B 和 C 所以我的查询 在我的

866
00:34:14,030 --> 00:34:16,310
管道中进行计划，因为我正在

867
00:34:16,310 --> 00:34:19,489
连接的左侧进行处理 首先

868
00:34:19,489 --> 00:34:21,500
我需要的第一件事是过滤器

869
00:34:21,500 --> 00:34:24,260
运算符 我只需要一个列，所以我将

870
00:34:24,260 --> 00:34:26,840
在这里传递这个迭代器，我们

871
00:34:26,840 --> 00:34:29,149
将传递 沿着 a 列中的块或页面，

872
00:34:29,149 --> 00:34:30,980
然后我进行

873
00:34:30,980 --> 00:34:33,440
处理，但后来我知道在我的

874
00:34:33,440 --> 00:34:35,899
查询计划中，我不再需要

875
00:34:35,899 --> 00:34:38,060
通信，因为我正在执行 B 的连接，

876
00:34:38,060 --> 00:34:40,850
我正在 C 上进行聚合，所以 我

877
00:34:40,850 --> 00:34:43,489
不需要传递所以相反我

878
00:34:43,489 --> 00:34:47,690
只会传递

879
00:34:47,690 --> 00:34:49,489
元组的集合 通过或传递

880
00:34:49,489 --> 00:34:52,310
谓词所以现在在连接

881
00:34:52,310 --> 00:34:55,250
运算符内部我可以去获取 B 列来

882
00:34:55,250 --> 00:34:57,380
完成连接

883
00:34:57,380 --> 00:34:58,789
然后同样的事情我不知道我知道

884
00:34:58,789 --> 00:35:01,009
我不需要在上面所以我只是

885
00:35:01,009 --> 00:35:02,990
传递偏移量 现在当我

886
00:35:02,990 --> 00:35:05,299
计算平均值时该死的然后我转到

887
00:35:05,299 --> 00:35:07,849
磁盘并获得 C 然后现在我

888
00:35:07,849 --> 00:35:10,599
传递最终结果

889
00:35:10,599 --> 00:35:13,279
这里的想法是我们可以

890
00:35:13,279 --> 00:35:15,259
聪明地识别我们

891
00:35:15,259 --> 00:35:16,789
在查询计划的不同部分需要的数据

892
00:35:16,789 --> 00:35:20,150
和 只传递长偏移量允许我们

893
00:35:20,150 --> 00:35:21,589
返回并

894
00:35:21,589 --> 00:35:28,220
在稍后获取我们需要的其余数据 好吧

895
00:35:28,220 --> 00:35:29,329
最后要讨论的是热

896
00:35:29,329 --> 00:35:31,369
聚簇或聚簇索引

897
00:35:31,369 --> 00:35:33,039
我们已经讨论过这个之前

898
00:35:33,039 --> 00:35:36,920
这只是允许我们 沿着

899
00:35:36,920 --> 00:35:39,650
索引的叶节点扫描并

900
00:35:39,650 --> 00:35:42,579
从头开始获取数据将是有序的，

901
00:35:42,579 --> 00:35:44,630
因为我们知道这两个

902
00:35:44,630 --> 00:35:46,670
极点在我们的页面

903
00:35:46,670 --> 00:35:48,019
中的排序方式与我们索引中的排序方式相同，

904
00:35:48,019 --> 00:35:50,869
所以没有太多其他的

905
00:35:50,869 --> 00:35:52,130
要说这个，我们已经 c

906
00:35:52,130 --> 00:35:56,000
已经过头了所以现在让我们谈谈

907
00:35:56,000 --> 00:36:01,700
我们将如何进行索引扫描所以索引扫描的

908
00:36:01,700 --> 00:36:03,230
基本思想是我们

909
00:36:03,230 --> 00:36:05,299
希望能够识别

910
00:36:05,299 --> 00:36:07,579
我们在我们的表上有什么索引，这将

911
00:36:07,579 --> 00:36:09,109
允许我们快速找到 我们需要的数据，

912
00:36:09,109 --> 00:36:11,000
并限制

913
00:36:11,000 --> 00:36:12,920
我们必须做的无用工作或浪费的

914
00:36:12,920 --> 00:36:14,660
工作量我们必须再次这样做这一切都是为了

915
00:36:14,660 --> 00:36:16,819
减少

916
00:36:16,819 --> 00:36:18,920
正在处理的数据的选择性，以便我们

917
00:36:18,920 --> 00:36:20,480
从一个操作员传递更少的数据

918
00:36:20,480 --> 00:36:23,359
到 接下来，如何选择一个

919
00:36:23,359 --> 00:36:25,730
索引是非常困难的，因为它

920
00:36:25,730 --> 00:36:27,380
取决于一堆不同的东西它

921
00:36:27,380 --> 00:36:29,150
取决于

922
00:36:29,150 --> 00:36:31,039
我们索引中的哪些属性我们的查询中引用的星号

923
00:36:31,039 --> 00:36:33,200
取决于这些值

924
00:36:33,200 --> 00:36:34,369
最初的实际情况

925
00:36:34,369 --> 00:36:36,230
对我们的查询是超级有选择性的

926
00:36:36,230 --> 00:36:38,180
我不是有选择性的取决于

927
00:36:38,180 --> 00:36:40,160
我们的谓词看起来像它们

928
00:36:40,160 --> 00:36:42,079
小于大于等于不

929
00:36:42,079 --> 00:36:43,759
等于决定我们是否使用

930
00:36:43,759 --> 00:36:46,009
索引然后当然取决于

931
00:36:46,009 --> 00:36:47,269
它是否 唯一索引或非

932
00:36:47,269 --> 00:36:50,240
唯一索引，所以我将通过一个

933
00:36:50,240 --> 00:36:51,980
非常高级的示例来说明我们如何

934
00:36:51,980 --> 00:36:53,539
选择索引，但下周我们将以这种方式进行更

935
00:36:53,539 --> 00:36:55,400
详细的介绍，因为这

936
00:36:55,400 --> 00:36:57,920
就是查询优化器为我们所做的，对

937
00:36:57,920 --> 00:36:59,420
有一个选择语句 我没有指定

938
00:36:59,420 --> 00:37:01,460
我想使用的索引 我希望

939
00:37:01,460 --> 00:37:03,259
数据库系统内的优化器

940
00:37:03,259 --> 00:37:04,970
说哦这些是我对我的

941
00:37:04,970 --> 00:37:07,009
索引的选择 这里是最好的一个基于

942
00:37:07,009 --> 00:37:09,529
你的查询试图再次这样做

943
00:37:09,529 --> 00:37:11,300
我们会 下周更详细地介绍这一点，

944
00:37:11,300 --> 00:37:13,550
但让我们

945
00:37:13,550 --> 00:37:17,480
看看一个非常简单的例子，假设

946
00:37:17,480 --> 00:37:18,500
我们有这样一个简单的查询

947
00:37:18,500 --> 00:37:21,050
，我们希望

948
00:37:21,050 --> 00:37:22,730
从学生表

949
00:37:22,730 --> 00:37:25,820
中获取所有 30 岁以下的学生

950
00:37:25,820 --> 00:37:27,589
C 的部门和

951
00:37:27,589 --> 00:37:29,900
来自美国的说对于这个特殊的

952
00:37:29,900 --> 00:37:32,630
数据库我们只有两个索引我们

953
00:37:32,630 --> 00:37:34,790
有年龄索引我们有索引在

954
00:37:34,790 --> 00:37:37,580
部门所以对于这个特定的查询

955
00:37:37,580 --> 00:37:39,380
我们想要使用

956
00:37:39,380 --> 00:37:42,530
什么索引是的取决于 数据

957
00:37:42,530 --> 00:37:45,950
实际上看起来像 e 在我们的表中，所以

958
00:37:45,950 --> 00:37:48,740
在第一种情况下，我们

959
00:37:48,740 --> 00:37:51,380
有 100 个元组，其他 99 名学生

960
00:37:51,380 --> 00:37:52,510
都在 30 岁以下，这

961
00:37:52,510 --> 00:37:56,119
对于这所大学来说可能是正确的，

962
00:37:56,119 --> 00:37:57,410
但是 CS 部门只有两个人

963
00:37:57,410 --> 00:37:58,700
对我们来说不是这样 但

964
00:37:58,700 --> 00:38:00,530
假设是这种情况，所以

965
00:38:00,530 --> 00:38:02,839
最好使用的索引是

966
00:38:02,839 --> 00:38:06,260
你的索引或抱歉的年龄或部门

967
00:38:06,260 --> 00:38:08,660
部门，因为

968
00:38:08,660 --> 00:38:11,510
如果我选择这个，我只会得到两个元组来匹配我们

969
00:38:11,510 --> 00:38:14,210
一

970
00:38:14,210 --> 00:38:17,270
岁那么我的索引皮肤基本上

971
00:38:17,270 --> 00:38:19,220
没用，因为我只是要通过中央扫描

972
00:38:19,220 --> 00:38:20,780
找到无论如何我会找到的所有记录

973
00:38:20,780 --> 00:38:23,570
，现在我

974
00:38:23,570 --> 00:38:25,160
支付了遍历索引的一分钱，

975
00:38:25,160 --> 00:38:28,010
如果我们不需要再次

976
00:38:28,010 --> 00:38:29,869
反过来说

977
00:38:29,869 --> 00:38:31,280
，CS 部门有 99 人，只有两个

978
00:38:31,280 --> 00:38:34,910
30 岁的人现在还好

979
00:38:34,910 --> 00:38:36,830
，年龄指数对我们来说更好，因为

980
00:38:36,830 --> 00:38:39,349
这更具选择性，所以在高层次上，

981
00:38:39,349 --> 00:38:40,790
这就是我们正在努力做的 在我们的

982
00:38:40,790 --> 00:38:42,920
索引扫描中，我们试图避免 h

983
00:38:42,920 --> 00:38:44,540
想要去读取我们

984
00:38:44,540 --> 00:38:47,260
不一定需要的数据，这也包括

985
00:38:47,260 --> 00:38:49,339
你知道实际探索索引的成本，

986
00:38:49,339 --> 00:38:51,770
所以如果数据系统

987
00:38:51,770 --> 00:38:53,690
可以很好地识别我不会

988
00:38:53,690 --> 00:38:55,670
对这个索引非常有选择性

989
00:38:55,670 --> 00:38:57,170
我将支付遍历该

990
00:38:57,170 --> 00:38:58,880
索引或在哈希

991
00:38:58,880 --> 00:39:00,859
表中查找该索引的惩罚，然后

992
00:39:00,859 --> 00:39:04,070
最好再次进行特殊扫描，这是

993
00:39:04,070 --> 00:39:05,540
关于如何在下周实际做出

994
00:39:05,540 --> 00:39:09,830
更多决定的原因，但我确实想要什么

995
00:39:09,830 --> 00:39:12,740


996
00:39:12,740 --> 00:39:16,369
如果两个指数都是一个好主意，我们

997
00:39:16,369 --> 00:39:17,750
可能会傻到抛硬币说

998
00:39:17,750 --> 00:39:18,920
好吧，我就掷骰子，

999
00:39:18,920 --> 00:39:20,359
看看你知道我会选择年长

1000
00:39:20,359 --> 00:39:22,400
的那个，那就是了 足够好，但

1001
00:39:22,400 --> 00:39:23,990
数据库系统可以识别

1002
00:39:23,990 --> 00:39:24,740
出它们实际上

1003
00:39:24,740 --> 00:39:26,950
对我有很大帮助并且非常有选择性，

1004
00:39:26,950 --> 00:39:30,350
然后我想对它们进行探测以

1005
00:39:30,350 --> 00:39:33,770
获取结果，然后

1006
00:39:33,770 --> 00:39:35,450
根据什么以某种方式将它们组合起来

1007
00:39:35,450 --> 00:39:36,710
查询实际上是尝试

1008
00:39:36,710 --> 00:39:39,290
做然后使用 t 帽子组合结果

1009
00:39:39,290 --> 00:39:40,670
然后找出哪些数据实际

1010
00:39:40,670 --> 00:39:42,320
匹配或找到我正在寻找的数据

1011
00:39:42,320 --> 00:39:42,710


1012
00:39:42,710 --> 00:39:47,210
是的，这是很好的问题，找到这

1013
00:39:47,210 --> 00:39:52,850
两个值是什么意思我们如何

1014
00:39:52,850 --> 00:39:58,869
决定在此示例中的内容

1015
00:39:58,869 --> 00:40:02,869
前一个是的，她的帽子如此自由的

1016
00:40:02,869 --> 00:40:04,400
场景 一个让你兴奋的

1017
00:40:04,400 --> 00:40:23,330
选择转换 30 变成如何是的，

1018
00:40:23,330 --> 00:40:25,190
我们将在下周介绍我们有

1019
00:40:25,190 --> 00:40:27,680
这些是的，就像我们有一个

1020
00:40:27,680 --> 00:40:30,020
近似值它在数学上并不总是

1021
00:40:30,020 --> 00:40:31,730
准确的两个问题，但

1022
00:40:31,730 --> 00:40:33,590
让我们假设我们知道我们知道

1023
00:40:33,590 --> 00:40:36,050
这样的事情 极端的

1024
00:40:36,050 --> 00:40:37,190
例子是超级观众我们会知道

1025
00:40:37,190 --> 00:40:39,170
就像国务院有两个人

1026
00:40:39,170 --> 00:40:40,910
我们会知道

1027
00:40:40,910 --> 00:40:43,070
这是一个异常值

1028
00:40:43,070 --> 00:40:44,630
这是另一种方式他们有击球手

1029
00:40:44,630 --> 00:40:46,369
我们甚至知道这个超级常见所以

1030
00:40:46,369 --> 00:40:48,350
我们 会选择还是不选择

1031
00:40:48,350 --> 00:40:54,050
是的 这个问题是它在 X 中

1032
00:40:54,050 --> 00:40:57,290
总是可以更好 是索引

1033
00:40:57,290 --> 00:41:00,670
总是可以比 scruncher 扫描更好 不

1034
00:41:05,410 --> 00:41:07,400
是的，但我们将在更多内容中介绍

1035
00:41:07,400 --> 00:41:09,440
幻灯片是的，这个问题是，如果它

1036
00:41:09,440 --> 00:41:10,850
不是聚集索引，我们可以有随机输入

1037
00:41:10,850 --> 00:41:12,650
/输出，我们如何解决它给我

1038
00:41:12,650 --> 00:41:27,140
两张幻灯片三边是的，好吧，所以

1039
00:41:27,140 --> 00:41:31,090
这个问题是在这种情况下，

1040
00:41:32,880 --> 00:41:34,200
我是否必须探测索引

1041
00:41:34,200 --> 00:41:37,140
一百 不是因为

1042
00:41:37,140 --> 00:41:41,489
我喜欢这里的查询计划是的，所以在

1043
00:41:41,489 --> 00:41:43,920
ping 时，它会考虑我的

1044
00:41:43,920 --> 00:41:45,450
查询计划的叶节点，用于此查询

1045
00:41:45,450 --> 00:41:48,720
我在叶节点处调用 next 以

1046
00:41:48,720 --> 00:41:50,849
很好地访问实际表 '正在

1047
00:41:50,849 --> 00:41:52,890
通过索引访问它，

1048
00:41:52,890 --> 00:41:55,289
索引现在将进行探测以找到

1049
00:41:55,289 --> 00:41:57,539
CS 部门的所有学生，

1050
00:41:57,539 --> 00:42:00,569
如果它是 B+ 树，

1051
00:42:00,569 --> 00:42:03,869
它将找到叶节点的左侧

1052
00:42:03,869 --> 00:42:05,880
，所有学生都在 cs2

1053
00:42:05,880 --> 00:42:08,609
艺术家开始我承认第一双鞋 - 我

1054
00:42:08,609 --> 00:42:11,489
发现它上升到我的父母

1055
00:42:11,489 --> 00:42:12,839
父母回来并再次调用 next

1056
00:42:12,839 --> 00:42:15,329
现在我的迭代器跳转到

1057
00:42:15,329 --> 00:42:17,099
叶节点中的下一个是另一个学生

1058
00:42:17,099 --> 00:42:19,739
是的，承认来了 X 再一次现在

1059
00:42:19,739 --> 00:42:20,970
我把它输入到下一个

1060
00:42:20,970 --> 00:42:22,829
哦现在它在你里面 现在

1061
00:42:22,829 --> 00:42:24,869
不是那个与

1062
00:42:24,869 --> 00:42:26,940
我的谓词不匹配的生物学系我已经返回了 null 所以我

1063
00:42:26,940 --> 00:42:28,920
探测了一次索引然后我单独扫描

1064
00:42:28,920 --> 00:42:30,210
了叶节点所以我找到了我现在正在寻找的一切

1065
00:42:30,210 --> 00:42:33,450
他的问题是

1066
00:42:33,450 --> 00:42:35,849
他的问题是 索引总是

1067
00:42:35,849 --> 00:42:39,180
比猎人知道的更可取，

1068
00:42:39,180 --> 00:42:41,369
因为如果我

1069
00:42:41,369 --> 00:42:42,960
像现在 CS 部门的 99 个人那样匹配每个人，

1070
00:42:42,960 --> 00:42:45,029
我将付出代价来

1071
00:42:45,029 --> 00:42:47,729
遍历索引，这只是

1072
00:42:47,729 --> 00:42:50,369
浪费了 IO 或浪费了查找

1073
00:42:50,369 --> 00:42:51,479
最好只是跳到

1074
00:42:51,479 --> 00:42:52,890
表的开头并按顺序向下扫描，这样

1075
00:42:52,890 --> 00:42:55,619


1076
00:42:55,619 --> 00:42:57,960
在这种情况下，截止点很明显 99% 的

1077
00:42:57,960 --> 00:42:59,700
元组匹配顺序扫描是正确的

1078
00:42:59,700 --> 00:43:02,430
方法，它取决于阈值

1079
00:43:02,430 --> 00:43:04,109


1080
00:43:04,109 --> 00:43:05,309
数据库系统内的查询优化器内的成本模型

1081
00:43:05,309 --> 00:43:06,839
，这会因

1082
00:43:06,839 --> 00:43:09,119
不同的系统而异，所以下周星期一

1083
00:43:09,119 --> 00:43:10,920
我总是觉得我只是在

1084
00:43:10,920 --> 00:43:12,630
说我们的下一堂课或另外

1085
00:43:12,630 --> 00:43:15,869
两堂课将讨论这个，

1086
00:43:15,869 --> 00:43:17,809
我  试图只关注一个想法，但

1087
00:43:17,809 --> 00:43:20,160
下周我们将展示我们如何获得

1088
00:43:20,160 --> 00:43:22,410
这些信息，然后使用

1089
00:43:22,410 --> 00:43:23,910
它来估计

1090
00:43:23,910 --> 00:43:24,509
哪个更好，

1091
00:43:24,509 --> 00:43:26,759
这样不仅可以判断哪个指数

1092
00:43:26,759 --> 00:43:28,469
最适合使用，而且 顺序

1093
00:43:28,469 --> 00:43:30,599
扫描仍然会更好我们将

1094
00:43:30,599 --> 00:43:34,769
在下周介绍现在我们专注于

1095
00:43:34,769 --> 00:43:37,950
如何我你是什么这个执行

1096
00:43:37,950 --> 00:43:40,619
实际上看起来很好所以

1097
00:43:40,619 --> 00:43:43,650
多多索引扫描再次

1098
00:43:43,650 --> 00:43:44,940
对不同的不同索引进行多次查找

1099
00:43:44,940 --> 00:43:46,200


1100
00:43:46,200 --> 00:43:47,490
和 然后我们将根据谓词的内容将它们组合成一个结果

1101
00:43:47,490 --> 00:43:50,099
，所以如果

1102
00:43:50,099 --> 00:43:51,990
它是 a 如果我们有一个连词和一个

1103
00:43:51,990 --> 00:43:54,720


1104
00:43:54,720 --> 00:43:56,520
从句然后我们使用交集如果它是一个 or 子句或析取我们

1105
00:43:56,520 --> 00:43:58,349
使用一个联合我们只是组合这些

1106
00:43:58,349 --> 00:44:01,290
集合 在一起，然后对于

1107
00:44:01,290 --> 00:44:03,960
在我们的组合之后匹配的任何元组集，

1108
00:44:03,960 --> 00:44:06,480
然后我们可以

1109
00:44:06,480 --> 00:44:08,160
去查找它们并进行额外的

1110
00:44:08,160 --> 00:44:11,099
处理，以便所有主要数据库

1111
00:44:11,099 --> 00:44:13,349
都支持这一点，如果你这样做，他们称之为

1112
00:44:13,349 --> 00:44:15,390
不同的东西 你使用 Postgres

1113
00:44:15,390 --> 00:44:17,190
有时我们会看到一个解释的输出

1114
00:44:17,190 --> 00:44:19,500
但是称之为位图扫描 这

1115
00:44:19,500 --> 00:44:20,490
本质上是他们正在做的 他们正在

1116
00:44:20,490 --> 00:44:21,900
构建某种类型 他们正在构建一个

1117
00:44:21,900 --> 00:44:24,359
位图，其中每个位都对应于

1118
00:44:24,359 --> 00:44:27,000
我们在某个位置的记录，然后 现在

1119
00:44:27,000 --> 00:44:28,619
他们可以使用你

1120
00:44:28,619 --> 00:44:31,020
知道的位操作运算符将它们组合在一起，但

1121
00:44:31,020 --> 00:44:32,869
不同的系统

1122
00:44:32,869 --> 00:44:42,119
在叶节点上做不同的事情是的，这

1123
00:44:42,119 --> 00:44:44,849
取决于谓词，如果它在子句中，

1124
00:44:44,849 --> 00:44:47,490
它们将是多个探测器，如果它是

1125
00:44:47,490 --> 00:44:48,990
某种类似的范围，因为你可以

1126
00:44:48,990 --> 00:44:52,040
沿着叶节点做一个特殊的扫描 我

1127
00:44:52,040 --> 00:44:53,849
不应该使用特殊的术语 不能进行

1128
00:44:53,849 --> 00:44:55,200
范围扫描 它是在指示节点上调用的

1129
00:44:55,200 --> 00:45:05,930
是的，你做了枪口探测

1130
00:45:05,930 --> 00:45:10,560


1131
00:45:10,560 --> 00:45:11,880
就像哦我知道

1132
00:45:11,880 --> 00:45:13,290
我有一个哈希表索引我应该

1133
00:45:13,290 --> 00:45:14,940
知道写这种查询你

1134
00:45:14,940 --> 00:45:17,579
不知道你不关心我的意思是你

1135
00:45:17,579 --> 00:45:18,630
在高层次上你不知道你不

1136
00:45:18,630 --> 00:45:20,400
关心这些日子是 我们可以弄清楚我

1137
00:45:20,400 --> 00:45:22,140
有一个哈希索引 s 准确，

1138
00:45:22,140 --> 00:45:23,730
并且同一属性上的 B+ 树索引

1139
00:45:23,730 --> 00:45:25,710
取决于我的谓词

1140
00:45:25,710 --> 00:45:28,230
它知道如何选择哪个并

1141
00:45:28,230 --> 00:45:32,700
为您完成所有这一切都是

1142
00:45:32,700 --> 00:45:34,290
续集的美或声明性语言的美

1143
00:45:34,290 --> 00:45:35,339
，您不必

1144
00:45:35,339 --> 00:45:36,210
担心如何 事情实际上是

1145
00:45:36,210 --> 00:45:38,250
物理存储的，所以我可以删除

1146
00:45:38,250 --> 00:45:39,869
索引，查询仍然可以

1147
00:45:39,869 --> 00:45:41,160
回退到顺序扫描，但它

1148
00:45:41,160 --> 00:45:43,550
仍然可以

1149
00:45:43,609 --> 00:45:46,470
正常工作，所以这里是我们之前的相同查询

1150
00:45:46,470 --> 00:45:48,690
，所以这次我们有

1151
00:45:48,690 --> 00:45:51,390
两个年龄的索引 和部门，所以

1152
00:45:51,390 --> 00:45:53,190
我们要做的就是首先检索

1153
00:45:53,190 --> 00:45:55,230
与索引中年龄小于 3 的所有记录 ID，

1154
00:45:55,230 --> 00:45:57,599
然后我们将做

1155
00:45:57,599 --> 00:45:59,820
同样的事情，它可能在不同的

1156
00:45:59,820 --> 00:46:01,020
权利同时它可能是

1157
00:46:01,020 --> 00:46:02,850
相同的 线程没关系，他们确实

1158
00:46:02,850 --> 00:46:04,860
在部门上查找然后您

1159
00:46:04,860 --> 00:46:07,650
将这两个的交集作为

1160
00:46:07,650 --> 00:46:08,940
这两个索引的输出，因为

1161
00:46:08,940 --> 00:46:11,940
它是一个子句，因此是一个连词，然后

1162
00:46:11,940 --> 00:46:14,160
是在交集之后匹配的任何其他记录，

1163
00:46:14,160 --> 00:46:17,220
然后我们再做

1164
00:46:17,220 --> 00:46:18,390
实际获取元组并将

1165
00:46:18,390 --> 00:46:20,130
最终谓词应用于国家的 ookup 等于我们，

1166
00:46:20,130 --> 00:46:22,400
因此再次从视觉上看，

1167
00:46:22,400 --> 00:46:25,860
您在此查询上查找年龄小于 30 的

1168
00:46:25,860 --> 00:46:27,720
此探测部门等于此部门上的 CS

1169
00:46:27,720 --> 00:46:29,550
，然后中间的任何内容

1170
00:46:29,550 --> 00:46:31,800
都是 然后我们知道

1171
00:46:31,800 --> 00:46:34,430
匹配这两个索引的

1172
00:46:34,430 --> 00:46:36,540
那些，因此那些是我们真正想要查看的那些，

1173
00:46:36,540 --> 00:46:37,740
因为这将匹配我们的

1174
00:46:37,740 --> 00:46:39,810
连词，然后我们去检索它们

1175
00:46:39,810 --> 00:46:41,750
并按国家检查它们等于我们

1176
00:46:41,750 --> 00:46:44,910
所以我们在这里实际生成的

1177
00:46:44,910 --> 00:46:47,880
可以 再次是位图，就像它在

1178
00:46:47,880 --> 00:46:50,430
Postgres 中一样，它可能是另一个哈希表

1179
00:46:50,430 --> 00:46:52,380
，我们可以将其与

1180
00:46:52,380 --> 00:46:54,540
另一个哈希表结合或进行连接 它可能

1181
00:46:54,540 --> 00:46:55,800
是我们之前讨论过的一本bloom book

1182
00:46:55,800 --> 00:46:59,040
对 不同的

1183
00:46:59,040 --> 00:47:01,230
系统做不同的事情并不重要 理想情况下，您

1184
00:47:01,230 --> 00:47:02,250
希望这尽可能简洁，

1185
00:47:02,250 --> 00:47:03,840
因为您不希望为匹配它们

1186
00:47:03,840 --> 00:47:05,520
的每个元组都拥有一个非常大的哈希表

1187
00:47:05,520 --> 00:47:07,140
并尝试

1188
00:47:07,140 --> 00:47:09,210
将它们组合起来，这样您就可以 一个

1189
00:47:09,210 --> 00:47:10,590
有效的方法来做它的交集

1190
00:47:10,590 --> 00:47:11,730
然后你回去

1191
00:47:11,730 --> 00:47:17,940
得到你需要的其余数据好吧

1192
00:47:17,940 --> 00:47:19,350
我们将谈论的最后一件事是

1193
00:47:19,350 --> 00:47:21,150
他之前问过的问题，我

1194
00:47:21,150 --> 00:47:23,070
认为这已经提出了几个

1195
00:47:23,070 --> 00:47:26,010
学期中的时间是，如果我有一个

1196
00:47:26,010 --> 00:47:28,200
非聚集索引，我只是

1197
00:47:28,200 --> 00:47:29,940
沿着叶节点扫描我

1198
00:47:29,940 --> 00:47:33,090
可能随机跳转

1199
00:47:33,090 --> 00:47:36,410
到不同页面的不同记录 ID，

1200
00:47:36,410 --> 00:47:38,910
因为元组的方式不

1201
00:47:38,910 --> 00:47:40,530
一样 叶节点

1202
00:47:40,530 --> 00:47:44,130
在索引中排序，所以在最坏的

1203
00:47:44,130 --> 00:47:46,950
情况下，说我只有一个你知道

1204
00:47:46,950 --> 00:47:48,330
一个缓冲页，我可以在其中存储

1205
00:47:48,330 --> 00:47:50,820
一些你知道的单页和

1206
00:47:50,820 --> 00:47:53,460
我更喜欢的每一次，因为

1207
00:47:53,460 --> 00:47:55,980
我沿着信念扫描 知道我正在

1208
00:47:55,980 --> 00:47:58,650
阅读一个页面，如果我正在查看的页面

1209
00:47:58,650 --> 00:48:00,150
与我刚刚检索的最后一个页面不同，

1210
00:48:00,150 --> 00:48:01,980
那么这是另一个磁盘

1211
00:48:01,980 --> 00:48:05,610
i/o 来获取它，但取决于

1212
00:48:05,610 --> 00:48:07,950
我的查询是什么，如果输出

1213
00:48:07,950 --> 00:48:11,610
不需要 根据索引所基于的 ID 进行排序

1214
00:48:11,610 --> 00:48:13,610


1215
00:48:13,610 --> 00:48:16,460
然后，在我实际对我扫描的数据进行任何查找之前

1216
00:48:16,460 --> 00:48:19,040
，获取所有记录

1217
00:48:19,040 --> 00:48:21,650
ID，然后我根据它们的页面 ID 对它们进行排序

1218
00:48:21,650 --> 00:48:24,380
，所以现在对于每个单独的页面，

1219
00:48:24,380 --> 00:48:26,300
它们都组合在一起，这是一个 IO

1220
00:48:26,300 --> 00:48:28,280
来获取我的一页 处理

1221
00:48:28,280 --> 00:48:29,540
该页面内的所有元组，然后

1222
00:48:29,540 --> 00:48:32,690
再进入下一个

1223
00:48:32,690 --> 00:48:33,770


1224
00:48:33,770 --> 00:48:35,600


1225
00:48:35,600 --> 00:48:37,010


1226
00:48:37,010 --> 00:48:40,280
您

1227
00:48:40,280 --> 00:48:41,750
知道每天的输出可能不同，

1228
00:48:41,750 --> 00:48:43,550
因为

1229
00:48:43,550 --> 00:48:44,990
如果您关心以某种方式订购的东西，您就不能不在您的应用程序中，

1230
00:48:44,990 --> 00:48:46,430


1231
00:48:46,430 --> 00:48:48,110
您将不得不按条款编写特定的订单

1232
00:48:48,110 --> 00:48:52,130
，所以有一天我们的 元组 你知道

1233
00:48:52,130 --> 00:48:55,370
有两个元组可能靠得很近，

1234
00:48:55,370 --> 00:48:57,470
并且按照排序顺序存在

1235
00:48:57,470 --> 00:48:59,630
于同一页面上，第二天在

1236
00:48:59,630 --> 00:49:01,040
一些压缩或一些垃圾

1237
00:49:01,040 --> 00:49:02,780
收集过程之后然后现在在不同的

1238
00:49:02,780 --> 00:49:04,730
页面中，所以我最终可以进入

1239
00:49:04,730 --> 00:49:06,110
不同的页面 山姆的结果 e 查询

1240
00:49:06,110 --> 00:49:10,460
，没关系，我们被允许这样做，

1241
00:49:10,460 --> 00:49:11,750
所以我们可以做很多事情，因为

1242
00:49:11,750 --> 00:49:14,600
重新处理数据可能会改变

1243
00:49:14,600 --> 00:49:15,080
结果

1244
00:49:15,080 --> 00:49:17,510
改变不变是一种

1245
00:49:17,510 --> 00:49:18,950
高级正确性，可以

1246
00:49:18,950 --> 00:49:23,390
改变确切的输出排序有任何

1247
00:49:23,390 --> 00:49:32,720
问题 关于这个是的，你的

1248
00:49:32,720 --> 00:49:35,780
问题就像在你进行排序之后你是否

1249
00:49:35,780 --> 00:49:43,370
必须走一遍，所以就像你

1250
00:49:43,370 --> 00:49:45,860
根据页面排序所以说

1251
00:49:45,860 --> 00:49:49,130
我在第 101 页需要两个元组我知道

1252
00:49:49,130 --> 00:49:50,360
它们在哪个页面它们在第 101 页 我

1253
00:49:50,360 --> 00:49:55,070
知道槽号，所以当我

1254
00:49:55,070 --> 00:49:56,750
把页面放进去时，我跳了一个槽，我跳

1255
00:49:56,750 --> 00:49:58,370
了一个槽五，然后我去找了我想要的元组

1256
00:49:58,370 --> 00:50:00,140
，你没有迭代，你

1257
00:50:00,140 --> 00:50:01,280
没有扫描，因为你没有

1258
00:50:01,280 --> 00:50:02,810
在看 每一个元组你

1259
00:50:02,810 --> 00:50:04,010
只是在寻找这个

1260
00:50:04,010 --> 00:50:09,520
东西在这里匹配的元组是的是

1261
00:50:17,350 --> 00:50:20,030
正确的所以他的问题我应该

1262
00:50:20,030 --> 00:50:21,740
在上周讨论这个你

1263
00:50:21,740 --> 00:50:22,940
实际上如何维护聚集索引

1264
00:50:22,940 --> 00:50:24,460
因为你

1265
00:50:24,460 --> 00:50:26,920
说这个页面已满然后 我在里面

1266
00:50:26,920 --> 00:50:28,240
插入了一些东西 有点适合在

1267
00:50:28,240 --> 00:50:30,460
这里做什么这意味着我必须

1268
00:50:30,460 --> 00:50:32,670
喜欢然后重新洗牌所有内容是的，

1269
00:50:32,670 --> 00:50:36,670
除非您将所有内容存储在

1270
00:50:36,670 --> 00:50:40,300
我的续集或任何 InnoDB 中

1271
00:50:40,300 --> 00:50:41,920
，叶节点本身的页面

1272
00:50:41,920 --> 00:50:43,780
是元组实际存储的位置，就像

1273
00:50:43,780 --> 00:50:45,670
你一样 拆分一些合并，然后

1274
00:50:45,670 --> 00:50:47,260
将您知道的键值从一页移动

1275
00:50:47,260 --> 00:50:49,380
到下一页，

1276
00:50:49,380 --> 00:50:51,940
如果断开连接，如果它是组织的索引，

1277
00:50:51,940 --> 00:50:53,320
如果很抱歉，如果它

1278
00:50:53,320 --> 00:50:54,700
是未完全连接到基础数据页的聚集索引，则情况相同

1279
00:50:54,700 --> 00:50:57,339
是的，

1280
00:50:57,339 --> 00:50:58,240
有很多你必须做的 一堆

1281
00:50:58,240 --> 00:51:02,710
实际工作 这就是为什么这两个系统

1282
00:51:02,710 --> 00:51:04,180
都是索引组织或集群索引

1283
00:51:04,180 --> 00:51:13,210
它与否默认是严重的

1284
00:51:13,210 --> 00:51:15,460
问题是它是否像排序限制十

1285
00:51:15,460 --> 00:51:17,920
就像有一个带有限制子句的订单一样

1286
00:51:17,920 --> 00:51:20,430
你不能 这样做是正确的，

1287
00:51:20,430 --> 00:51:23,410
但又是这样的日子，我们有

1288
00:51:23,410 --> 00:51:24,849
规则和我们的查询优化器来

1289
00:51:24,849 --> 00:51:26,140
识别你喜欢

1290
00:51:26,140 --> 00:51:28,450
哦，所以这就是

1291
00:51:28,450 --> 00:51:30,940
管道断路器的一个例子，我

1292
00:51:30,940 --> 00:51:32,560
必须有一个订单 我必须查看所有

1293
00:51:32,560 --> 00:51:34,300
元组才能知道全局排序

1294
00:51:34,300 --> 00:51:37,060
顺序是什么 I 现在我不能转到

1295
00:51:37,060 --> 00:51:38,830
我查询计划上方的限制子句

1296
00:51:38,830 --> 00:51:47,470
直到我完成排序

1297
00:51:47,470 --> 00:51:51,520


1298
00:51:51,520 --> 00:51:55,450
例如，让我们使用这个

1299
00:51:55,450 --> 00:51:59,170
返回来迭代一个模型，好吧，所以

1300
00:51:59,170 --> 00:52:01,320
假设这不是一个

1301
00:52:01,320 --> 00:52:04,390
投影，而是一个订单，然后

1302
00:52:04,390 --> 00:52:06,010
实际上有使它

1303
00:52:06,010 --> 00:52:07,960
成为订单，使这成为一个

1304
00:52:07,960 --> 00:52:10,270
约成为限制，所以 order by 是一个

1305
00:52:10,270 --> 00:52:12,130
管道断路器我不知道

1306
00:52:12,130 --> 00:52:14,230
所有记录的完整排序顺序，

1307
00:52:14,230 --> 00:52:16,780
直到我看到所有记录因为如果我

1308
00:52:16,780 --> 00:52:18,010
尝试开始排序它们只是通过查看

1309
00:52:18,010 --> 00:52:20,230
部分内容你知道你知道我看到你

1310
00:52:20,230 --> 00:52:23,369
知道我看到九十 11 我对它们进行排序，

1311
00:52:23,369 --> 00:52:26,589
但后来我看不到你知道值一，

1312
00:52:26,589 --> 00:52:28,330
因为我还没有打电话给 next 现在我的

1313
00:52:28,330 --> 00:52:30,460
商店订购不正确所以

1314
00:52:30,460 --> 00:52:31,990
管道断路器说你不能

1315
00:52:31,990 --> 00:52:33,520
继续查询计划，直到你得到

1316
00:52:33,520 --> 00:52:35,890
你需要的所有元组 所以这里的订单

1317
00:52:35,890 --> 00:52:38,080
将是一个管道断路器，然后

1318
00:52:38,080 --> 00:52:39,460
我有一个带有限制调用的订单

1319
00:52:39,460 --> 00:52:41,410
，我想在排序后选择前十名和两个

1320
00:52:41,410 --> 00:52:44,110
极点 我不能做

1321
00:52:44,110 --> 00:52:45,840
前十名，直到我把所有东西都排序了才有

1322
00:52:45,840 --> 00:52:52,170
意义，所以按子查询

1323
00:52:52,170 --> 00:52:54,400
的顺序加入了订单的限制调用 购买将是一个

1324
00:52:54,400 --> 00:53:00,280
管道断路器 其他示例 mins

1325
00:53:00,280 --> 00:53:05,320
maxes 类似的东西 所以如何

1326
00:53:05,320 --> 00:53:07,360
与索引相关 所以索引

1327
00:53:07,360 --> 00:53:10,540
扫描就在这里 只是你

1328
00:53:10,540 --> 00:53:12,610
知道我们这四十年 我不是

1329
00:53:12,610 --> 00:53:14,200
说霍华德是什么

1330
00:53:14,200 --> 00:53:15,400
因为在后面，是的，它可能是

1331
00:53:15,400 --> 00:53:17,430
毛衣扫描，也可能是索引扫描，

1332
00:53:17,430 --> 00:53:22,030
所以如果它是计划扫描，它是

1333
00:53:22,030 --> 00:53:24,490
无序的，所以我必须通过电话订购我的订单

1334
00:53:24,490 --> 00:53:26,710
做一个 Bob 做很多额外的

1335
00:53:26,710 --> 00:53:31,990
事情，如果我 我正在做索引扫描，我的

1336
00:53:31,990 --> 00:53:34,510
专业人士在我的索引中进行范围扫描，

1337
00:53:34,510 --> 00:53:39,460
而且索引的排序顺序与

1338
00:53:39,460 --> 00:53:41,920
上面的 order by 子句相同，然后

1339
00:53:41,920 --> 00:53:43,420
我知道这两个男孩会

1340
00:53:43,420 --> 00:53:45,490
按排序顺序出现，所以我不 不需要

1341
00:53:45,490 --> 00:53:48,850
再在上面做我的订单，但我们

1342
00:53:48,850 --> 00:53:50,230
提前知道这一切，因为我们是

1343
00:53:50,230 --> 00:53:52,270
ge 制定这个查询计划是因为我们

1344
00:53:52,270 --> 00:53:53,470
确切地知道查询计划是什么

1345
00:53:53,470 --> 00:53:57,540
因为它是声明性

1346
00:53:57,540 --> 00:53:59,950
的 没有什么神奇的功能 我们不

1347
00:53:59,950 --> 00:54:01,720
知道它会是什么直到我们

1348
00:54:01,720 --> 00:54:03,910
实际运行它 不完全正确

1349
00:54:03,910 --> 00:54:10,150
但现在情况就是这样

1350
00:54:10,150 --> 00:54:13,990
好吧 好吧 所以

1351
00:54:13,990 --> 00:54:18,100
我们要讨论的最后一件事是我们如何实际

1352
00:54:18,100 --> 00:54:20,890
评估这些谓词 无论这些

1353
00:54:20,890 --> 00:54:22,500
where 子句 我们有这些连接子句

1354
00:54:22,500 --> 00:54:25,030
我们实际上如何你知道我们如何

1355
00:54:25,030 --> 00:54:27,670
真正理解这一点 所以我们的方式

1356
00:54:27,670 --> 00:54:29,040
要做到这一点是我们

1357
00:54:29,040 --> 00:54:31,840
将 where 子句表示为

1358
00:54:31,840 --> 00:54:34,900
表达式树，表达式树中的所有节点

1359
00:54:34,900 --> 00:54:36,220
都将

1360
00:54:36,220 --> 00:54:38,350
表示我们

1361
00:54:38,350 --> 00:54:40,600
可以在谓词中使用的不同类型的表达式，因此所有的比较连词都使用了

1362
00:54:40,600 --> 00:54:42,340
Dish dongju 的

1363
00:54:42,340 --> 00:54:45,180
算术运算符函数调用

1364
00:54:45,180 --> 00:54:47,560
查找实际元组常

1365
00:54:47,560 --> 00:54:49,720
量值所有这些现在都可以

1366
00:54:49,720 --> 00:54:51,710
用树表示，

1367
00:54:51,710 --> 00:54:53,599
所以对于这个特定的例子，我

1368
00:54:53,599 --> 00:54:55,760
有我自己的子句，其中我们的 ID 等于 s

1369
00:54:55,760 --> 00:54:58,550
I  D，然后我们用不大于 100 的值的 SSS 关闭，

1370
00:54:58,550 --> 00:55:01,339
所以我可以

1371
00:55:01,339 --> 00:55:03,710
将整个谓词表示

1372
00:55:03,710 --> 00:55:04,880
连接子句和

1373
00:55:04,880 --> 00:55:09,109
where 子句的组合作为我的根中的一棵树我有

1374
00:55:09,109 --> 00:55:11,030
一个我有一个连接和

1375
00:55:11,030 --> 00:55:13,280
运算符 一边我有质量

1376
00:55:13,280 --> 00:55:15,710
谓词它匹配我们的 ID 和 s ID

1377
00:55:15,710 --> 00:55:18,609
另一边我有大于 prep

1378
00:55:18,609 --> 00:55:22,010
操作符的属性值对不起

1379
00:55:22,010 --> 00:55:24,559


1380
00:55:24,559 --> 00:55:27,619
元组的 value 属性的值的值，然后是

1381
00:55:27,619 --> 00:55:31,520
常量 100 所以就像以前一样 在

1382
00:55:31,520 --> 00:55:33,380
查询计划中，我们去顶部底部将

1383
00:55:33,380 --> 00:55:35,270
做同样的事情在这里

1384
00:55:35,270 --> 00:55:38,839
确定元组是否匹配所以让我们看一个

1385
00:55:38,839 --> 00:55:41,420
更简单的例子所以这里我们有一个

1386
00:55:41,420 --> 00:55:43,910
查询 where flexstar from s 然后我们的

1387
00:55:43,910 --> 00:55:46,069
where 子句是 B 值等于

1388
00:55:46,069 --> 00:55:48,200
问号的地方 加 1 所以我们还没有

1389
00:55:48,200 --> 00:55:49,099
谈过我不知道我们

1390
00:55:49,099 --> 00:55:50,300
谈过准备好的语句但是

1391
00:55:50,300 --> 00:55:52,309
准备好的语句就像一个楔子来

1392
00:55:52,309 --> 00:55:55,790
声明一个查询模板现在你

1393
00:55:55,790 --> 00:55:57,260
提前告诉数据系统嘿

1394
00:55:57,260 --> 00:55:58,369
我要实际 一遍又一遍地重复这个查询

1395
00:55:58,369 --> 00:56:00,020
，这是一个占位符

1396
00:56:00,020 --> 00:56:01,819
，您可以在其中在运行时填写一个值，以便

1397
00:56:01,819 --> 00:56:03,589
您了解自己并几乎

1398
00:56:03,589 --> 00:56:05,420
像一个函数一样投票这个查询，并且您将传入

1399
00:56:05,420 --> 00:56:07,270
一个它们在运行时被替换的值，

1400
00:56:07,270 --> 00:56:10,520
我们将介绍我 想想可能是下周

1401
00:56:10,520 --> 00:56:13,069
或期中考试之后，但很清楚

1402
00:56:13,069 --> 00:56:14,180
这里发生了什么这只是一个下

1403
00:56:14,180 --> 00:56:27,680
订单是的，为什么你可以这样做是的，是的，

1404
00:56:27,680 --> 00:56:29,359
为什么不只在客户端完成 +1，

1405
00:56:29,359 --> 00:56:31,250


1406
00:56:31,250 --> 00:56:34,150
所以这是一个哲学

1407
00:56:34,150 --> 00:56:39,530
问题 不是这样 - 所以我总是

1408
00:56:39,530 --> 00:56:43,880
必须正确添加 +1 所以假设我

1409
00:56:43,880 --> 00:56:45,770
有我的我有一个大应用程序

1410
00:56:45,770 --> 00:56:48,380
我有我的桌面版本我有一个

1411
00:56:48,380 --> 00:56:50,329
基于网络的版本我有一个电话

1412
00:56:50,329 --> 00:56:52,730
应用程序和他们'

1413
00:56:52,730 --> 00:56:55,250
如果我总是

1414
00:56:55,250 --> 00:56:56,510
确保我必须调用 +1 我

1415
00:56:56,510 --> 00:56:57,950
将确保在所有三个不同的

1416
00:56:57,950 --> 00:57:01,930
程序中他们都调用 +1

1417
00:57:02,200 --> 00:57:04,090
如果这应该

1418
00:57:04,090 --> 00:57:05,800
是我想隐藏的逻辑 从

1419
00:57:05,800 --> 00:57:07,750
应用程序然后我可以把它写

1420
00:57:07,750 --> 00:57:10,030
在我的查询中然后我得到的

1421
00:57:10,030 --> 00:57:11,740
使用加号就像一个微不足道的

1422
00:57:11,740 --> 00:57:13,750
例子，但想想其他事情，

1423
00:57:13,750 --> 00:57:17,320
比如更复杂的操作这只是

1424
00:57:17,320 --> 00:57:19,360
为了玩这只是为了向你展示会

1425
00:57:19,360 --> 00:57:22,120
发生什么树是的，我们是，所以

1426
00:57:22,120 --> 00:57:23,830
我们称之为我们将拥有 整个

1427
00:57:23,830 --> 00:57:25,900
讲座称为服务器端程序

1428
00:57:25,900 --> 00:57:26,230
逻辑

1429
00:57:26,230 --> 00:57:28,690
服务器端执行我们将

1430
00:57:28,690 --> 00:57:31,210
在期中考试之后介绍但为什么和这是一个

1431
00:57:31,210 --> 00:57:32,350
权衡，因为现在我们

1432
00:57:32,350 --> 00:57:35,140
有应用程序的逻辑

1433
00:57:35,140 --> 00:57:36,640
现在在数据库系统

1434
00:57:36,640 --> 00:57:38,980
和 应用程序代码本身，这

1435
00:57:38,980 --> 00:57:40,180
就是为什么我说的是哲学，有些

1436
00:57:40,180 --> 00:57:42,100
人说哦，数据库系统应该

1437
00:57:42,100 --> 00:57:44,110
知道一切，因为 II 可以

1438
00:57:44,110 --> 00:57:45,310
在所有不同的场合重用那个小屋

1439
00:57:45,310 --> 00:57:47,860
，我们都说这是一个坏

1440
00:57:47,860 --> 00:57:49,810
主意，因为现在我就像程序员一样

1441
00:57:49,810 --> 00:57:51,370
我写了一些你知道蹩脚的 Python

1442
00:57:51,370 --> 00:57:53,590
代码，有一些数据可以做一堆

1443
00:57:53,590 --> 00:57:54,580
我不知道它在做什么的东西，

1444
00:57:54,580 --> 00:57:55,600
所以最好把

1445
00:57:55,600 --> 00:57:56,740
所有东西都放在我的应用程序代码中，

1446
00:57:56,740 --> 00:57:58,180
因为我们可以看到许可程序

1447
00:57:58,180 --> 00:58:01,750
这是一个很长的答案，y

1448
00:58:01,750 --> 00:58:05,320
加一个就在这里，但相信我，有

1449
00:58:05,320 --> 00:58:06,820
一些有用的，对我们有一些用处，

1450
00:58:06,820 --> 00:58:09,970
所以这个表达式

1451
00:58:09,970 --> 00:58:11,590
B 点值等于

1452
00:58:11,590 --> 00:58:14,110
问号加一个的 where 子句看起来像这样的

1453
00:58:14,110 --> 00:58:16,570
树，所以在 为了调用和

1454
00:58:16,570 --> 00:58:18,820
评估这个表达式，当我们调用这个表达式时，我们需要

1455
00:58:18,820 --> 00:58:21,640
一些关于我们查询中发生了什么的上下文信息，

1456
00:58:21,640 --> 00:58:23,620


1457
00:58:23,620 --> 00:58:26,110
所以你会说

1458
00:58:26,110 --> 00:58:28,090
我们正在处理的当前小管是什么，

1459
00:58:28,090 --> 00:58:29,050
想想这就像我们要

1460
00:58:29,050 --> 00:58:31,720
在我们的一个操作符内的 for 循环内部调用评估

1461
00:58:31,720 --> 00:58:33,310
所以

1462
00:58:33,310 --> 00:58:35,020
我们得到的所有 L 到我们

1463
00:58:35,020 --> 00:58:36,520
想要评估这棵树所以我们需要知道

1464
00:58:36,520 --> 00:58:38,130
我们正在查看的当前小管

1465
00:58:38,130 --> 00:58:40,210
我们还需要知道

1466
00:58:40,210 --> 00:58:42,010
这个查询的输入参数是什么我说

1467
00:58:42,010 --> 00:58:43,570
这是客户端在

1468
00:58:43,570 --> 00:58:44,710
他们想要投票这个查询来

1469
00:58:44,710 --> 00:58:46,930
替换问号时传递给我们的所以在这种

1470
00:58:46,930 --> 00:58:49,420
情况下它是 999 然后我们需要一些

1471
00:58:49,420 --> 00:58:51,820
关于元组模式的信息

1472
00:58:51,820 --> 00:58:53,290
我们正在处理，所以我们

1473
00:58:53,290 --> 00:58:54,670
需要知道，就像你知道的，这

1474
00:58:54,670 --> 00:58:57,160
是记录，第一个属性是

1475
00:58:57,160 --> 00:58:59,050
呼叫 ID，它是整数，第二个

1476
00:58:59,050 --> 00:59:00,400
被称为 value，它也是整数，

1477
00:59:00,400 --> 00:59:02,290
它只是更多关于

1478
00:59:02,290 --> 00:59:04,900
她看起来的原因的上下文 就像这样，

1479
00:59:04,900 --> 00:59:06,610
它的工作方式是我们

1480
00:59:06,610 --> 00:59:08,860
开始我们称之为评估的路线，

1481
00:59:08,860 --> 00:59:12,310
然后我们只是向下并

1482
00:59:12,310 --> 00:59:14,500
深入到我们的每个叶节点

1483
00:59:14,500 --> 00:59:15,400
并开始

1484
00:59:15,400 --> 00:59:18,970
向上移动值，所以我们从这里开始

1485
00:59:18,970 --> 00:59:21,130
转到 左侧，这是一个表达式，

1486
00:59:21,130 --> 00:59:24,789
表示

1487
00:59:24,789 --> 00:59:27,010
从当前元组中检索 s 值和 value 属性，

1488
00:59:27,010 --> 00:59:29,890
因此这将只生成一个

1489
00:59:29,890 --> 00:59:31,809
1000 对，因为

1490
00:59:31,809 --> 00:59:33,609
我们正在查看的当前值

1491
00:59:33,609 --> 00:59:36,460
属性为千，那么现在 我

1492
00:59:36,460 --> 00:59:38,589
回到这里并再次进行深度优先

1493
00:59:38,589 --> 00:59:38,890
搜索，

1494
00:59:38,890 --> 00:59:41,890
不，对不起，我们走到了这一边，

1495
00:59:41,890 --> 00:59:43,299
这说哦给我偏移零处的参数

1496
00:59:43,299 --> 00:59:45,609
我看看我的上下文

1497
00:59:45,609 --> 00:59:48,099
设置 0 它是 999 所以这东西产生

1498
00:59:48,099 --> 00:59:51,190
99 我跳 在这里，我下去 另一

1499
00:59:51,190 --> 00:59:52,869
边说给我 1 的常

1500
00:59:52,869 --> 00:59:55,390
数值，你知道牧师是

1501
00:59:55,390 --> 00:59:57,190
出现在这里的人，

1502
00:59:57,190 --> 01:00:00,670
现在我评估 99 加 1，即 1,000

1503
01:00:00,670 --> 01:00:02,410
然后我将在这里进行我的质量

1504
01:00:02,410 --> 01:00:04,180
谓词，它说 千

1505
01:00:04,180 --> 01:00:06,849
自我一千是结果是真的所以

1506
01:00:06,849 --> 01:00:08,020
这个元组将匹配这个特定的

1507
01:00:08,020 --> 01:00:12,549
谓词，以便清楚地设想

1508
01:00:12,549 --> 01:00:14,740
我们正在为我们在我们的for循环内部查看的每一个元组都这样做

1509
01:00:14,740 --> 01:00:17,079
，我们的

1510
01:00:17,079 --> 01:00:21,849
一个操作符就是这样

1511
01:00:21,849 --> 01:00:24,180
好 或

1512
01:00:24,390 --> 01:00:29,380
如此快速或缓慢的错误改写，他

1513
01:00:29,380 --> 01:00:31,119
说他说我们每次都不必要地进行加号

1514
01:00:31,119 --> 01:00:32,829


1515
01:00:32,829 --> 01:00:37,359
是的，所以我们将在创建授权时再次介绍这

1516
01:00:37,359 --> 01:00:39,130


1517
01:00:39,130 --> 01:00:41,200
一点，但他在这里指出的一个明显的事情

1518
01:00:41,200 --> 01:00:43,599
是这件事也是 一个常量 - 999

1519
01:00:43,599 --> 01:00:45,549
总是相同的，因为它被

1520
01:00:45,549 --> 01:00:46,839
传递到查询中，所以我们可以

1521
01:00:46,839 --> 01:00:50,890
重写这个，让它只是重写

1522
01:00:50,890 --> 01:00:52,210
这个东西只是一个常量值

1523
01:00:52,210 --> 01:00:56,650
一千是的，但他仍然是你的，

1524
01:00:56,650 --> 01:01:00,099
直到走下那个行为的树

1525
01:01:00,099 --> 01:01:03,880
真的很烂所以我在这里再次描述的

1526
01:01:03,880 --> 01:01:05,559
是系统

1527
01:01:05,559 --> 01:01:07,359
第一次很好地实现时的每一天

1528
01:01:07,359 --> 01:01:08,529
这就是他们实现

1529
01:01:08,529 --> 01:01:11,980
表达式的方式，但它会很慢，

1530
01:01:11,980 --> 01:01:13,510
因为现在他们有十亿个元组

1531
01:01:13,510 --> 01:01:15,190
我正在调用 该函数用于

1532
01:01:15,190 --> 01:01:16,720
评估表达式树并遍历

1533
01:01:16,720 --> 01:01:20,650
表达式树十亿次，因此

1534
01:01:20,650 --> 01:01:22,960
高端系统不会这样做，或者

1535
01:01:22,960 --> 01:01:23,980
超级优化的系统

1536
01:01:23,980 --> 01:01:26,799
不会这样做，因此他们想做的

1537
01:01:26,799 --> 01:01:28,790


1538
01:01:28,790 --> 01:01:30,860
是与抱歉相同的事情 即时

1539
01:01:30,860 --> 01:01:33,350
编译所以说我有一个像这样一个愚蠢的

1540
01:01:33,350 --> 01:01:34,970
谓词，一个等于一，

1541
01:01:34,970 --> 01:01:36,890
现在我再次意识到你可以

1542
01:01:36,890 --> 01:01:38,600
优化这种方式，它总是

1543
01:01:38,600 --> 01:01:41,120
评估为真但作为st。 假设

1544
01:01:41,120 --> 01:01:43,220
你有一个蹩脚的系统，它

1545
01:01:43,220 --> 01:01:44,870
总是运行你知道总是有这

1546
01:01:44,870 --> 01:01:47,420
棵树并且总是不得不遍历它

1547
01:01:47,420 --> 01:01:49,310
你想要做的实际上是

1548
01:01:49,310 --> 01:01:54,470
编译

1549
01:01:54,470 --> 01:01:57,130
你想要为给定元组评估的谓词，

1550
01:01:57,130 --> 01:02:00,710
所以现在我 可以在一条

1551
01:02:00,710 --> 01:02:03,110
指令中写入常数值 1 等于

1552
01:02:03,110 --> 01:02:05,240
CPU 上的常数值 1 这

1553
01:02:05,240 --> 01:02:07,550
比遍历这棵树

1554
01:02:07,550 --> 01:02:09,620
做查找要快得多 你知道看看什么样

1555
01:02:09,620 --> 01:02:11,210
的表达式类型 我想知道

1556
01:02:11,210 --> 01:02:13,160
我需要复制什么样的输出然后

1557
01:02:13,160 --> 01:02:14,480
有 这些巨大的 switch 语句可以

1558
01:02:14,480 --> 01:02:16,040
很好地说明我正在尝试评估的运算符

1559
01:02:16,040 --> 01:02:17,990
是一个等号子句作为教训，

1560
01:02:17,990 --> 01:02:21,620
因为如果我可以精简为

1561
01:02:21,620 --> 01:02:24,470
谓词想要做的事情

1562
01:02:24,470 --> 01:02:29,270
，那将会更快，所以这

1563
01:02:29,270 --> 01:02:31,490
又是最高的 - 终端系统做 Postgres

1564
01:02:31,490 --> 01:02:35,090
12 刚刚添加了这个，我认为

1565
01:02:35,090 --> 01:02:36,560
在这一点上它非常有限，但这

1566
01:02:36,560 --> 01:02:38,930
不是我的秘密，据我所知不这样做，

1567
01:02:38,930 --> 01:02:41,510
但喜欢高端系统

1568
01:02:41,510 --> 01:02:43,160
和更好的开源系统

1569
01:02:43,160 --> 01:02:46,910
对于我们在 CMU 构建的系统，系统可以做到这一点，再次剧透

1570
01:02:46,910 --> 01:02:49,580
，现在我们只需

1571
01:02:49,580 --> 01:02:51,620
将谓词编译成

1572
01:02:51,620 --> 01:02:53,540
简单的指令，我们实际上

1573
01:02:53,540 --> 01:02:56,030
将整个查询计划编译为 B 成为

1574
01:02:56,030 --> 01:02:58,970
一条指令管道，然后现在

1575
01:02:58,970 --> 01:03:00,080
您 不再是你没有

1576
01:03:00,080 --> 01:03:01,760
间接你没有跳转子句

1577
01:03:01,760 --> 01:03:03,920
这只是一种内疚 X

1578
01:03:03,920 --> 01:03:06,410
正是你的查询计划

1579
01:03:06,410 --> 01:03:08,120
就像几乎有人

1580
01:03:08,120 --> 01:03:10,820
在退出查询时编写了代码然后

1581
01:03:10,820 --> 01:03:14,200
编译它我们可以做到这一点 动态

1582
01:03:14,740 --> 01:03:19,340
可以，所以主要的收获

1583
01:03:19,340 --> 01:03:21,320
是相同的查询计划和不同的

1584
01:03:21,320 --> 01:03:22,670
系统可以以多种方式执行

1585
01:03:22,670 --> 01:03:24,590
，这取决于环境

1586
01:03:24,590 --> 01:03:27,530
是列存储还是烘焙，

1587
01:03:27,530 --> 01:03:29,600
或者取决于工作负载是否

1588
01:03:29,600 --> 01:03:32,600
是 OLAP 系统 OTP 系统，但正如我所说

1589
01:03:32,600 --> 01:03:34,610
的迭代器模型，自上而下的方法

1590
01:03:34,610 --> 01:03:36,890
是最常见的方法，这就是你会

1591
01:03:36,890 --> 01:03:40,010
看到在大多数情况下，大多数

1592
01:03:40,010 --> 01:03:41,960
情况下假期总是喜欢

1593
01:03:41,960 --> 01:03:42,710
使用它索引键

1594
01:03:42,710 --> 01:03:44,000
/这是缺点 科学可以尽可能多

1595
01:03:44,000 --> 01:03:46,010
地在某些情况下

1596
01:03:46,010 --> 01:03:48,260
这实际上不会解决，

1597
01:03:48,260 --> 01:03:49,880
然后表达式树很好，

1598
01:03:49,880 --> 01:03:51,860
因为作为人类他们很容易让

1599
01:03:51,860 --> 01:03:53,150
我们推理和理解

1600
01:03:53,150 --> 01:03:54,980
我们谓词的正确性“ 重新

1601
01:03:54,980 --> 01:03:57,560
评估，但在实践中它们

1602
01:03:57,560 --> 01:03:58,880
会非常慢，相反，你想把

1603
01:03:58,880 --> 01:04:03,560
它们编译成任何

1604
01:04:03,560 --> 01:04:05,510
关于你所知道的可以

1605
01:04:05,510 --> 01:04:07,910
创建执行的问题，并希望你

1606
01:04:07,910 --> 01:04:09,530
看到我们在本学期所做的事情

1607
01:04:09,530 --> 01:04:11,180
是我们已经 再次讨论

1608
01:04:11,180 --> 01:04:13,070
了系统的所有这些不同部分 你

1609
01:04:13,070 --> 01:04:14,540
如何进行扫描 如何构建索引

1610
01:04:14,540 --> 01:04:16,520
如何拥有缓冲池 现在我们正在

1611
01:04:16,520 --> 01:04:17,480
尝试将所有这些东西放在一起

1612
01:04:17,480 --> 01:04:22,630
并实际构建一个完整的

1613
01:04:22,630 --> 01:04:25,160
系统 我们将继续

1614
01:04:25,160 --> 01:04:26,660
讨论采石场执行，但我们将

1615
01:04:26,660 --> 01:04:28,340
专注于如何实际查询

1616
01:04:28,340 --> 01:04:31,700
并行执行查询，并且

1617
01:04:31,700 --> 01:04:32,780
我将在

1618
01:04:32,780 --> 01:04:34,390
分布式系统和并行系统之间做出的区分是，

1619
01:04:34,390 --> 01:04:36,470
对于并行执行，我们很重要

1620
01:04:36,470 --> 01:04:38,750
关于在单个机器的单个数据库实例上运行单个查询的国王

1621
01:04:38,750 --> 01:04:40,720


1622
01:04:40,720 --> 01:04:42,590
分布式执行将

1623
01:04:42,590 --> 01:04:45,470
在多台机器上运行查询，但

1624
01:04:45,470 --> 01:04:46,640
我将在本讲座中讨论的很多想法

1625
01:04:46,640 --> 01:04:48,020
将适用于

1626
01:04:48,020 --> 01:04:52,400
trivet 环境，好吧，大家

1627
01:04:52,400 --> 01:04:53,270
喜欢 天气，我周三见

1628
01:04:53,270 --> 01:04:55,450


1629
01:05:04,000 --> 01:05:10,840
，米奇拒绝了我的系统下一个

1630
01:05:14,530 --> 01:05:17,510
将是儿子跳弹果冻撞到

1631
01:05:17,510 --> 01:05:19,550
熟食店乘船自然会祝福你

1632
01:05:19,550 --> 01:05:20,900
什么说唱歌手喜欢激光束

1633
01:05:20,900 --> 01:05:22,940
丛林中的傻瓜说甚至不像

1634
01:05:22,940 --> 01:05:25,220
国王包裹 我们这瓶漂亮漂亮的

1635
01:05:25,220 --> 01:05:27,680
金子不想喝酒，

1636
01:05:27,680 --> 01:05:29,900
只有你喝醉了你不能

1637
01:05:29,900 --> 01:05:31,520
越界，如果不知道你的手机

1638
01:05:31,520 --> 01:05:34,100
可以敲痛

1639
01:05:34,100 --> 01:05:37,139
[音乐]

