1
00:00:01,280 --> 00:00:11,400
[音乐]

2
00:00:15,750 --> 00:00:17,410
好吧

3
00:00:17,410 --> 00:00:21,700
嘿 抓紧你的包裹 你往下看有

4
00:00:21,700 --> 00:00:28,439
什么问题 都市女性 女人问题

5
00:00:28,439 --> 00:00:34,690
你说什么 男人问题 你有什么

6
00:00:34,690 --> 00:00:42,220
问题 他们说你的

7
00:00:42,220 --> 00:00:43,180
节奏太新鲜了，他们

8
00:00:43,180 --> 00:00:47,680
应付不来 我没有资格 帮助 我很抱歉

9
00:00:47,680 --> 00:00:48,370


10
00:00:48,370 --> 00:00:49,960
好吧好吧 所以让我们谈谈数据库

11
00:00:49,960 --> 00:00:54,579
那么好吧 所以快速提醒

12
00:00:54,579 --> 00:00:59,079
一下今晚要交的作业 然后

13
00:00:59,079 --> 00:01:02,230
今天要完成第一个项目 我会坐在

14
00:01:02,230 --> 00:01:03,190
课程结束时 那里实际上

15
00:01:03,190 --> 00:01:04,390
是网站现在是源 代码

16
00:01:04,390 --> 00:01:07,600
在线，但我会讨论

17
00:01:07,600 --> 00:01:09,909
你今天需要做什么，然后

18
00:01:09,909 --> 00:01:11,229
就像在你提交一些

19
00:01:11,229 --> 00:01:14,619
伟大的范围之前一样，你知道一切都会

20
00:01:14,619 --> 00:01:17,530
被自动评分好吧，我想

21
00:01:17,530 --> 00:01:19,030
花点时间谈谈 无论实验室

22
00:01:19,030 --> 00:01:20,380
工作负载是什么，在您

23
00:01:20,380 --> 00:01:22,509
在 OLT 端收集了大量数据之后，您

24
00:01:22,509 --> 00:01:24,490
现在想要开始分析它

25
00:01:24,490 --> 00:01:26,649
以推断新信息，就像

26
00:01:26,649 --> 00:01:28,179
匹兹堡市的人们

27
00:01:28,179 --> 00:01:30,130
更有可能购买这种产品

28
00:01:30,130 --> 00:01:31,869
我说过可以 使用该信息

29
00:01:31,869 --> 00:01:33,729
然后你知道将信息推送到

30
00:01:33,729 --> 00:01:35,709
OTB 端，让人们做你

31
00:01:35,709 --> 00:01:37,719
想让他们做的事情，然后混合

32
00:01:37,719 --> 00:01:39,279
事务分析处理 h 型

33
00:01:39,279 --> 00:01:41,109
工作负载，这是

34
00:01:41,109 --> 00:01:43,810
Gartner 几年前发明的一个新流行语，

35
00:01:43,810 --> 00:01:45,549
基本上描述了这些 数据库

36
00:01:45,549 --> 00:01:47,979
系统尝试同时执行这两种操作，

37
00:01:47,979 --> 00:01:51,279
因此您经常会看到的典型设置是

38
00:01:51,279 --> 00:01:53,679
这样的，您将拥有前端 ODB

39
00:01:53,679 --> 00:01:55,509
数据库，然后拥有庞大

40
00:01:55,509 --> 00:01:57,819
的后端数据仓库，因此这些

41
00:01:57,819 --> 00:02:00,009
有时被称为数据孤岛，因为您

42
00:02:00,009 --> 00:02:01,450
可以对它们进行雨披更新，就像

43
00:02:01,450 --> 00:02:03,759
一个数据库实例，无论它是

44
00:02:03,759 --> 00:02:05,079
单个节点还是 shivudu 都没有关系，

45
00:02:05,079 --> 00:02:06,669
因为它是一个逻辑数据库

46
00:02:06,669 --> 00:02:10,568
，然后您在此处应用您的更改，但

47
00:02:10,568 --> 00:02:11,650
它们并没有真正相互通信，每个

48
00:02:11,650 --> 00:02:13,660
都是 一个岛

49
00:02:13,660 --> 00:02:15,700
本身，所以你可以做所谓的

50
00:02:15,700 --> 00:02:17,739
提取转换和加载或 ETL，

51
00:02:17,739 --> 00:02:19,310
这是

52
00:02:19,310 --> 00:02:21,140
你使用的术语描述

53
00:02:21,140 --> 00:02:23,959
从这些前端取出数据清理它

54
00:02:23,959 --> 00:02:26,270
处理它 然后把它

55
00:02:26,270 --> 00:02:28,910
放到后端数据仓库所以

56
00:02:28,910 --> 00:02:30,230
我喜欢的例子就像

57
00:02:30,230 --> 00:02:32,930
Zynga 的farmville 人 他们购买了

58
00:02:32,930 --> 00:02:35,360
很多游戏初创公司 然后当

59
00:02:35,360 --> 00:02:36,590
他们购买它们时 他们都运行自己的

60
00:02:36,590 --> 00:02:39,380
前端中介基础 但是然后当

61
00:02:39,380 --> 00:02:40,459
他们想把它放在他们后端的

62
00:02:40,459 --> 00:02:42,980
巨型数据仓库中，这样他们就可以进行

63
00:02:42,980 --> 00:02:44,510
分析，让你在

64
00:02:44,510 --> 00:02:46,970
farmville上更好地购买废话，所以因为

65
00:02:46,970 --> 00:02:49,190
说在一个数据库中，

66
00:02:49,190 --> 00:02:51,110
客户的名字将是F 命名另一个

67
00:02:51,110 --> 00:02:53,150
数据库，我们你 知道 F 第一个下划线

68
00:02:53,150 --> 00:02:55,280
名称，所以它是相同的概念或

69
00:02:55,280 --> 00:02:56,180
相同的实体，只是具有不同的

70
00:02:56,180 --> 00:02:58,970
语法和命名法，

71
00:02:58,970 --> 00:03:01,069
所以这个 ETL 过程会清理所有这些

72
00:03:01,069 --> 00:03:03,080
你把它推到你的数据仓库你

73
00:03:03,080 --> 00:03:05,090
在这里做所有的分析，然后

74
00:03:05,090 --> 00:03:06,319
你有任何新信息

75
00:03:06,319 --> 00:03:09,739
把它推到前面就好了，当

76
00:03:09,739 --> 00:03:10,790
你看到像买了

77
00:03:10,790 --> 00:03:12,319
这个项目的人也买了这个项目时

78
00:03:12,319 --> 00:03:14,090
，他们在 OLAP 端这样做

79
00:03:14,090 --> 00:03:15,769
，然后他们把它推到

80
00:03:15,769 --> 00:03:17,150
前端 o 通过 OTP 应用程序公开它，

81
00:03:17,150 --> 00:03:19,310
所以 H 选项卡基本上是说

82
00:03:19,310 --> 00:03:21,290
让我们也做一些

83
00:03:21,290 --> 00:03:23,060
我们通常只能

84
00:03:23,060 --> 00:03:25,310
在 OLAP 端做的整体查询我们可以在

85
00:03:25,310 --> 00:03:28,280
前端数据孤岛上做你仍然想要这个巨大的

86
00:03:28,280 --> 00:03:30,260
东西你的巨量数据 仓库，因为

87
00:03:30,260 --> 00:03:32,750
您希望能够查看

88
00:03:32,750 --> 00:03:35,690
放在一起的所有数据孤岛，但现在

89
00:03:35,690 --> 00:03:36,799
无需等待将事情

90
00:03:36,799 --> 00:03:38,480
传播到后端，您可以

91
00:03:38,480 --> 00:03:40,220
在前端做一些事情，这

92
00:03:40,220 --> 00:03:42,019
基本上就是 H 类型再次如此 这

93
00:03:42,019 --> 00:03:43,519
可能就像你我的续集

94
00:03:43,519 --> 00:03:45,829
做你想要的 Postgres MongoDB

95
00:03:45,829 --> 00:03:47,450
然后你的后端数据仓库将

96
00:03:47,450 --> 00:03:51,410
是 Hadoop 的东西 spark greenplum Vertica

97
00:03:51,410 --> 00:03:53,239
那里有大型企业数据

98
00:03:53,239 --> 00:03:55,400
仓库系统 redshift 或雪花

99
00:03:55,400 --> 00:03:57,380
你的其他云系统好所以这很

100
00:03:57,380 --> 00:04:01,970
清楚好所以 我们今天要讨论的主要

101
00:04:01,970 --> 00:04:03,889
话题是，我们

102
00:04:03,889 --> 00:04:05,750
已经花了之前的两堂课来

103
00:04:05,750 --> 00:04:06,859
决定我们实际上将如何

104
00:04:06,859 --> 00:04:10,100
在磁盘上表示数据库，现在我们

105
00:04:10,100 --> 00:04:11,750
想要计算 k 关于我们实际上做了什么

106
00:04:11,750 --> 00:04:14,329
来从磁盘上的那些文件中取出数据库

107
00:04:14,329 --> 00:04:16,488
磁盘上的页面并将它们

108
00:04:16,488 --> 00:04:17,988
放入内存中以便我们可以对

109
00:04:17,988 --> 00:04:21,380
它们进行正确的操作所以请记住我们

110
00:04:21,380 --> 00:04:22,760
数据库系统不能直接

111
00:04:22,760 --> 00:04:25,340
在磁盘上操作我们不能 进行读取和写入

112
00:04:25,340 --> 00:04:26,810
而不必先进入内存

113
00:04:26,810 --> 00:04:28,220
那是冯诺依曼

114
00:04:28,220 --> 00:04:29,870
架构 现在有一些新

115
00:04:29,870 --> 00:04:31,400
硬件出来 你可以将

116
00:04:31,400 --> 00:04:32,870
执行

117
00:04:32,870 --> 00:04:35,600
逻辑下推到磁盘 但我们

118
00:04:35,600 --> 00:04:38,240
现在可以忽略它 所以我们试图

119
00:04:38,240 --> 00:04:39,650
弄清楚如何 我们是否希望将

120
00:04:39,650 --> 00:04:41,660
这些页面带回磁盘中，我们希望这样

121
00:04:41,660 --> 00:04:42,680
做并能够支持

122
00:04:42,680 --> 00:04:44,000
超过

123
00:04:44,000 --> 00:04:45,530
我们拥有的内存量的数据库，我们希望

124
00:04:45,530 --> 00:04:48,380
将速度减慢或查询挖掘的问题的影响降至最低

125
00:04:48,380 --> 00:04:51,140


126
00:04:51,140 --> 00:04:52,490
触摸磁盘上的数据 我们想让它

127
00:04:52,490 --> 00:04:55,220
看起来好像所有的东西都在内存中 所以

128
00:04:55,220 --> 00:04:57,260
另一种思考问题

129
00:04:57,260 --> 00:04:59,180
的方式也是空间与时间

130
00:04:59,180 --> 00:05:02,630
控制 所以空间控制是你知道

131
00:05:02,630 --> 00:05:04,490
我们在哪里写这个

132
00:05:04,490 --> 00:05:07,160
磁盘上的数据正确意味着我们希望

133
00:05:07,160 --> 00:05:08,450
我们知道这些页面

134
00:05:08,450 --> 00:05:10,610
通常可以一个接

135
00:05:10,610 --> 00:05:12,470
一个地一起使用，因此当我们写出这些页面时，

136
00:05:12,470 --> 00:05:13,850
我们希望按顺序写入它们，

137
00:05:13,850 --> 00:05:15,710
以便当我们再次读取它们时，

138
00:05:15,710 --> 00:05:17,840
尽管我们知道 写入和

139
00:05:17,840 --> 00:05:19,850
物理上彼此靠近，我们

140
00:05:19,850 --> 00:05:21,200
不必长时间寻找

141
00:05:21,200 --> 00:05:23,930
磁盘上的不同位置，我们还

142
00:05:23,930 --> 00:05:25,700
关心时间控制，这是

143
00:05:25,700 --> 00:05:27,890
我们决定何时将

144
00:05:27,890 --> 00:05:29,780
页面读入内存的时间，

145
00:05:29,780 --> 00:05:30,980
以及 然后在某个时候我们必须将

146
00:05:30,980 --> 00:05:33,320
它写回，如果它

147
00:05:33,320 --> 00:05:34,910
被修改了，并且我们不

148
00:05:34,910 --> 00:05:36,170
决定何时真正继续

149
00:05:36,170 --> 00:05:38,270
这样做，是的，这

150
00:05:38,270 --> 00:05:40,340
是尝试最小

151
00:05:40,340 --> 00:05:43,040
化数量的总体目标 我们有停顿是因为我们的

152
00:05:43,040 --> 00:05:44,300
查询试图读取我们

153
00:05:44,300 --> 00:05:45,920
没有在内存中的数据，我们有它，

154
00:05:45,920 --> 00:05:47,480
你知道它在磁盘上我们不得不

155
00:05:47,480 --> 00:05:50,540
去获取它所以这

156
00:05:50,540 --> 00:05:52,640
是下层商店经理的整体架构，

157
00:05:52,640 --> 00:05:54,290
但我 显示在 开始所以我们

158
00:05:54,290 --> 00:05:55,820
已经涵盖了这部分所以现在

159
00:05:55,820 --> 00:05:57,860
我们知道如何在磁盘上拥有一个或多个数据库

160
00:05:57,860 --> 00:05:59,990
文件我们知道如何

161
00:05:59,990 --> 00:06:01,250
表示页面目录以查找我们需要的数据

162
00:06:01,250 --> 00:06:03,080
然后我们有很多页面

163
00:06:03,080 --> 00:06:04,670
页面日志结构页面

164
00:06:04,670 --> 00:06:06,260
没关系我们

165
00:06:06,260 --> 00:06:07,820
在磁盘上有一堆页面，我们知道如何跳转到它们

166
00:06:07,820 --> 00:06:09,650
以找到它们所以我们现在

167
00:06:09,650 --> 00:06:10,700
我们正在缓冲池中谈论这部分

168
00:06:10,700 --> 00:06:12,890


169
00:06:12,890 --> 00:06:14,090
像执行引擎这样的系统

170
00:06:14,090 --> 00:06:15,620
执行查询的东西说

171
00:06:15,620 --> 00:06:17,690
我想阅读第二页 我们必须知道

172
00:06:17,690 --> 00:06:19,040
如何将页面目录提取到

173
00:06:19,040 --> 00:06:20,600
内存中 找出那里的内容

174
00:06:20,600 --> 00:06:22,250
然后去找到我们想要的页面

175
00:06:22,250 --> 00:06:24,800
并将其提取到内存中 然后

176
00:06:24,800 --> 00:06:25,940
棘手的事情将是如果我们

177
00:06:25,940 --> 00:06:28,070
现在没有足够的空间释放内存

178
00:06:28,070 --> 00:06:29,720
来放入我们需要的页面 我们必须

179
00:06:29,720 --> 00:06:32,330
决定要写出哪个页面

180
00:06:32,330 --> 00:06:34,160
这样你就知道这就是我们正在

181
00:06:34,160 --> 00:06:36,350
努力解决的问题 今天对了，然后

182
00:06:36,350 --> 00:06:38,300
是 sy 的其他部分 词干

183
00:06:38,300 --> 00:06:41,810
不需要知道或真正关心你

184
00:06:41,810 --> 00:06:43,190
知道什么在内存中而不在内存中

185
00:06:43,190 --> 00:06:44,540
会有等到你得到你的

186
00:06:44,540 --> 00:06:44,950
东西

187
00:06:44,950 --> 00:06:46,420
并给你一个指针让你

188
00:06:46,420 --> 00:06:48,070
做任何你想做的

189
00:06:48,070 --> 00:06:51,670
事情 所以今天讨论的事情

190
00:06:51,670 --> 00:06:53,140
本质上只是

191
00:06:53,140 --> 00:06:54,760
如何构建缓冲池管理器

192
00:06:54,760 --> 00:06:57,400
在某些喜剧中实际要做的事情术语

193
00:06:57,400 --> 00:06:59,170
缓冲池管理器某些系统将其

194
00:06:59,170 --> 00:07:01,420
称为缓冲区缓存它是同一

195
00:07:01,420 --> 00:07:03,340
件事，它是由数据库系统管理的内存

196
00:07:03,340 --> 00:07:05,260
然后我们将

197
00:07:05,260 --> 00:07:07,240
讨论我们实际上可以如何执行不同的

198
00:07:07,240 --> 00:07:09,190
策略来决定我们知道哪些

199
00:07:09,190 --> 00:07:10,360
页面我们想要写出

200
00:07:10,360 --> 00:07:12,540
哪些页面如果您需要释放空间

201
00:07:12,540 --> 00:07:14,620
我们可以做的额外优化以

202
00:07:14,620 --> 00:07:16,690
最大程度地减少这种影响然后我们将

203
00:07:16,690 --> 00:07:18,790
结束讨论

204
00:07:18,790 --> 00:07:20,830
可能需要内存的数据系统的另外两个部分

205
00:07:20,830 --> 00:07:25,120
好吧，所以缓冲池

206
00:07:25,120 --> 00:07:26,950
本质上只是一个大内存区域

207
00:07:26,950 --> 00:07:28,390
，我们将在我们的

208
00:07:28,390 --> 00:07:30,040
数据库系统中分配我们将要ca  ll malloc

209
00:07:30,040 --> 00:07:31,810
我想获得一些内存块

210
00:07:31,810 --> 00:07:33,970
，这

211
00:07:33,970 --> 00:07:36,430
就是我们将从磁盘获取的所有页面，所以

212
00:07:36,430 --> 00:07:37,750
这又完全

213
00:07:37,750 --> 00:07:39,370
由数据库系统的内存管理，而

214
00:07:39,370 --> 00:07:40,660
不是去操作 系统

215
00:07:40,660 --> 00:07:42,790
并要求我们必须使用 malloc 的内存权利，因为

216
00:07:42,790 --> 00:07:44,740
我们传递了 malloc 或

217
00:07:44,740 --> 00:07:46,360
我们自己分配内存，所以我们知道 s

218
00:07:46,360 --> 00:07:48,940
可以为我们提供这些，但是然后我们要将

219
00:07:48,940 --> 00:07:52,510
这个内存区域分解成固定

220
00:07:52,510 --> 00:07:55,090
大小或页面大小的块，称为帧

221
00:07:55,090 --> 00:07:58,240
这就是你知道框架看起来有点

222
00:07:58,240 --> 00:08:00,040
不寻常为什么我不只说页面或

223
00:08:00,040 --> 00:08:01,600
块或数据库系统中有这么多

224
00:08:01,600 --> 00:08:04,180
不同的术语来

225
00:08:04,180 --> 00:08:06,010
粗略地描述相同的事物所以

226
00:08:06,010 --> 00:08:09,970
框架对应于中的插槽或看

227
00:08:09,970 --> 00:08:11,590
我使用术语插槽 当使用该帧

228
00:08:11,590 --> 00:08:13,300
对应于缓冲池内存区域中的区域或块时

229
00:08:13,300 --> 00:08:15,130
，我们可以

230
00:08:15,130 --> 00:08:17,680
将页面放在正确的位置，而我们的插槽是

231
00:08:17,680 --> 00:08:19,270
我们将内容放入

232
00:08:19,270 --> 00:08:19,930
元组的页面中的东西，

233
00:08:19,930 --> 00:08:22,330
因此对于缓冲池，

234
00:08:22,330 --> 00:08:25,840
它是页面上的帧 将是插槽所以

235
00:08:25,840 --> 00:08:27,580
会发生什么是当数据库系统

236
00:08:27,580 --> 00:08:29,440
调用发出请求并说我想要一个

237
00:08:29,440 --> 00:08:31,390
正确的页面时，我们将查看

238
00:08:31,390 --> 00:08:32,590
它是否已经在我们的

239
00:08:32,590 --> 00:08:34,690
缓冲池中，如果没有，那么我们在

240
00:08:34,690 --> 00:08:36,940
磁盘中执行 它的副本获取您

241
00:08:36,940 --> 00:08:38,830
没有将其放入内存中所以这是一个

242
00:08:38,830 --> 00:08:40,780
直接的一对一副本我们没有做

243
00:08:40,780 --> 00:08:43,299
任何 D 文明好吧我们

244
00:08:43,299 --> 00:08:44,830
现在可以忽略压缩但是

245
00:08:44,830 --> 00:08:46,720
无论它在磁盘上如何表示都是

246
00:08:46,720 --> 00:08:48,640
它将在内存中表示

247
00:08:48,640 --> 00:08:50,320
我们不会对数据进行任何编组

248
00:08:50,320 --> 00:08:51,640
我们只是从

249
00:08:51,640 --> 00:08:52,830
磁盘中取出它并将其直接放入内存

250
00:08:52,830 --> 00:08:54,970
中 我们继续这样做 滚动

251
00:08:54,970 --> 00:08:56,650
我们可能需要的所有其他页面

252
00:08:56,650 --> 00:08:57,740


253
00:08:57,740 --> 00:09:01,730
所以在我之前的例子中，当

254
00:09:01,730 --> 00:09:03,380
我犯罪时，我展示了执行程序如何

255
00:09:03,380 --> 00:09:06,230
说嘿我想要一个页面来手动编写它

256
00:09:06,230 --> 00:09:08,000
你知道布法罗经理魔术

257
00:09:08,000 --> 00:09:12,020
在我们的第二页是这样

258
00:09:12,020 --> 00:09:14,060
如果我们只是将这些东西组织为

259
00:09:14,060 --> 00:09:18,110
框架页面 可以在

260
00:09:18,110 --> 00:09:20,900
他们想要的框架中以任何顺序进入 在这种情况下

261
00:09:20,900 --> 00:09:22,880
，即使它

262
00:09:22,880 --> 00:09:25,640
是我缓冲池中的第一页第一二三页

263
00:09:25,640 --> 00:09:26,990
它的第三页与

264
00:09:26,990 --> 00:09:29,300
它在磁盘上的顺序不同，所以我们需要一个额外的

265
00:09:29,300 --> 00:09:31,190
间接层来

266
00:09:31,190 --> 00:09:33,530
确定我是否想要一个特定的页面 哪个

267
00:09:33,530 --> 00:09:35,180
框架有我想要的框架，因为它

268
00:09:35,180 --> 00:09:36,350
不会完全匹配

269
00:09:36,350 --> 00:09:39,080
它在磁盘上的顺序，所以这

270
00:09:39,080 --> 00:09:41,630
就是页表是什么页表只是一个

271
00:09:41,630 --> 00:09:43,730
哈希表，它将跟踪

272
00:09:43,730 --> 00:09:45,860
我们在内存中拥有的页面和 如果您

273
00:09:45,860 --> 00:09:47,600
要求特定的页面 ID，它会告诉

274
00:09:47,600 --> 00:09:50,240
您位于哪个框架

275
00:09:50,240 --> 00:09:54,080


276
00:09:54,080 --> 00:09:55,820


277
00:09:55,820 --> 00:09:59,060


278
00:09:59,060 --> 00:10:00,110


279
00:10:00,110 --> 00:10:03,380
中 它的缓冲池，所以

280
00:10:03,380 --> 00:10:04,730
我们要跟踪的第一件事

281
00:10:04,730 --> 00:10:06,770
称为脏标志，这只是一个

282
00:10:06,770 --> 00:10:08,840
标志位，它告诉我们

283
00:10:08,840 --> 00:10:11,780
页面是否已被修改，因为它

284
00:10:11,780 --> 00:10:14,540
是从磁盘读取的 做了一些查询

285
00:10:14,540 --> 00:10:17,840
某些事务进行了更改 对它而言

286
00:10:17,840 --> 00:10:19,310
，我跟踪的另一件事也

287
00:10:19,310 --> 00:10:21,200
称为引脚计数或引用

288
00:10:21,200 --> 00:10:23,210
计数器，这只是跟踪

289
00:10:23,210 --> 00:10:25,490


290
00:10:25,490 --> 00:10:29,090
当前正在运行的线程或查询的数量，这些线程或查询希望此

291
00:10:29,090 --> 00:10:31,490
页面保留在内存中，这意味着我们

292
00:10:31,490 --> 00:10:32,780
没有 我们不想把它写到

293
00:10:32,780 --> 00:10:34,730
磁盘上，这可能是因为我要

294
00:10:34,730 --> 00:10:36,830
更新它所以我做我的获取我去获取

295
00:10:36,830 --> 00:10:38,000
我需要带入我的缓冲池的页面

296
00:10:38,000 --> 00:10:40,130
然后我要继续

297
00:10:40,130 --> 00:10:41,690
前进 修改我不希望该页面

298
00:10:41,690 --> 00:10:43,340


299
00:10:43,340 --> 00:10:45,290
在它被

300
00:10:45,290 --> 00:10:46,760
引入到我实际

301
00:10:46,760 --> 00:10:49,370
更新它之前被驱逐或换回磁盘，这也会

302
00:10:49,370 --> 00:10:52,850
阻止我们驱逐

303
00:10:52,850 --> 00:10:55,090
尚未安全写入的页面 回到磁盘

304
00:10:55,090 --> 00:10:57,200
还好，所以再次这样，就像我得到了画

305
00:10:57,200 --> 00:10:59,410
页，并说我不希望这个

306
00:10:59,410 --> 00:11:02,330
东西现在从缓冲

307
00:11:02,330 --> 00:11:04,340
池中删除，然后说我正在阅读一个

308
00:11:04,340 --> 00:11:06,440
页面，抱歉，我想阅读一个

309
00:11:06,440 --> 00:11:08,240
当前不是内存的页面我想

310
00:11:08,240 --> 00:11:10,730
在 t 中的这个条目上放一个闩锁

311
00:11:10,730 --> 00:11:11,510
哈希表，

312
00:11:11,510 --> 00:11:12,920
这样我就可以去获取页面，然后

313
00:11:12,920 --> 00:11:14,240
在我没有正确指向它的情况下更新页面

314
00:11:14,240 --> 00:11:16,370
，我必须这样做，因为

315
00:11:16,370 --> 00:11:17,630
同时运行多个威胁

316
00:11:17,630 --> 00:11:19,850
我不能假设我是

317
00:11:19,850 --> 00:11:20,960
唯一的 我正在查看页

318
00:11:20,960 --> 00:11:22,340
表，所以我想租用其他人

319
00:11:22,340 --> 00:11:24,290
从我的

320
00:11:24,290 --> 00:11:26,240
病人身上获取这个条目，当我正在获取

321
00:11:26,240 --> 00:11:27,470
我需要的页面时，他们来从我这里偷走它

322
00:11:27,470 --> 00:11:30,680
并再次放入其他东西

323
00:11:30,680 --> 00:11:32,870
当我们在本学期晚些时候进行时，他们是否清楚地看到了这一点，

324
00:11:32,870 --> 00:11:34,460
但是

325
00:11:34,460 --> 00:11:35,900
我们必须做很多额外的事情来

326
00:11:35,900 --> 00:11:37,640
跟踪哪些页面已被

327
00:11:37,640 --> 00:11:39,260
修改，因此脏的部分只是

328
00:11:39,260 --> 00:11:41,180
其中的一部分，我们也需要

329
00:11:41,180 --> 00:11:43,400
跟踪 谁实际上进行了

330
00:11:43,400 --> 00:11:45,740
修改，所以因为我们想写

331
00:11:45,740 --> 00:11:47,870
一个日志记录来说明

332
00:11:47,870 --> 00:11:48,830
这是所做的更改我们要确保

333
00:11:48,830 --> 00:11:50,240
在我们的页面写入之前首先写入日志记录

334
00:11:50,240 --> 00:11:52,190
这是另一个例子

335
00:11:52,190 --> 00:11:55,070
ymf 是一个坏主意，因为我 不能

336
00:11:55,070 --> 00:11:56,420
保证操作系统

337
00:11:56,420 --> 00:11:57,950
不会写 在我想要它之前将我的页面从磁盘中取出

338
00:11:57,950 --> 00:12:01,160
它

339
00:12:01,160 --> 00:12:03,080
不会阻止你

340
00:12:03,080 --> 00:12:04,760
至少在 linux 上这样做 freebsd 可以让你这样

341
00:12:04,760 --> 00:12:07,250
做但是 windows 和 linux 不希望

342
00:12:07,250 --> 00:12:10,010
你阻止这个，所以是这样

343
00:12:10,010 --> 00:12:11,240
清楚我们在这里要做的事情

344
00:12:11,240 --> 00:12:13,250
基本上是管理我们自己的内存，但

345
00:12:13,250 --> 00:12:15,470
我们正在跟踪

346
00:12:15,470 --> 00:12:17,120
事务或查询如何

347
00:12:17,120 --> 00:12:19,340
修改页面，我们必须保护

348
00:12:19,340 --> 00:12:21,110
自己和页表以防止

349
00:12:21,110 --> 00:12:23,240
其他人，你知道上瘾的

350
00:12:23,240 --> 00:12:25,220
事情 或者在我们

351
00:12:25,220 --> 00:12:28,450
完成我们希望我做的

352
00:12:28,450 --> 00:12:35,000
任何问题之前写东西，所以我现在需要对

353
00:12:35,000 --> 00:12:37,280


354
00:12:37,280 --> 00:12:39,260
锁和闩锁的区别做出非常重要的区分，

355
00:12:39,260 --> 00:12:40,790
所以稍后会出现你必须

356
00:12:40,790 --> 00:12:43,670
为 第一个项目，如果

357
00:12:43,670 --> 00:12:44,870
您来自操作系统

358
00:12:44,870 --> 00:12:48,560
背景，在那里滚动锁是

359
00:12:48,560 --> 00:12:53,090
我们所说的闩锁，所以在让

360
00:12:53,090 --> 00:12:54,470
我在数据库的上下文中尝试它们

361
00:12:54,470 --> 00:12:56,000
，我会看到我们描述

362
00:12:56,000 --> 00:12:58,730
它们如何映射到操作系统世界

363
00:12:58,730 --> 00:13:01,400
数据库世界中过时的 oa 锁是一些

364
00:13:01,400 --> 00:13:03,740
更高级别的逻辑原语，

365
00:13:03,740 --> 00:13:06,290
它将保护

366
00:13:06,290 --> 00:13:07,730
数据库的内容逻辑内容，如

367
00:13:07,730 --> 00:13:11,420
元组，表，数据库，一切正常

368
00:13:11,420 --> 00:13:13,970
，事务将

369
00:13:13,970 --> 00:13:16,190
在其持续时间内持有此锁。 运行

370
00:13:16,190 --> 00:13:17,540
这意味着可能是多个

371
00:13:17,540 --> 00:13:19,520
查询 这可能是您知道多

372
00:13:19,520 --> 00:13:21,410
毫秒或多秒，

373
00:13:21,410 --> 00:13:23,390
甚至在几分钟或几小时内，如果它是一个

374
00:13:23,390 --> 00:13:24,890
真正长时间运行的查询，

375
00:13:24,890 --> 00:13:27,170
那么在那个世界中，这又

376
00:13:27,170 --> 00:13:28,790
是数据系统可以提供给我们并

377
00:13:28,790 --> 00:13:32,270
暴露给我们的东西 您就像应用程序程序员一样，

378
00:13:32,270 --> 00:13:33,830
您甚至可以

379
00:13:33,830 --> 00:13:36,130
在运行查询时看到锁的用途，

380
00:13:36,130 --> 00:13:38,840
锁存器

381
00:13:38,840 --> 00:13:41,480
是我们用于数据库系统内部关键部分的低级保护原语，

382
00:13:41,480 --> 00:13:42,740


383
00:13:42,740 --> 00:13:45,100
例如完善

384
00:13:45,100 --> 00:13:47,240
保护数据结构完善

385
00:13:47,240 --> 00:13:50,330
保护内存区域 所以对于

386
00:13:50,330 --> 00:13:51,830
这些锁存器，我们将

387
00:13:51,830 --> 00:13:53,360
在我们正在进行的操作期间保持，

388
00:13:53,360 --> 00:13:55,160
就像我 g  o 更新我的页

389
00:13:55,160 --> 00:13:58,660
表 我在我要修改的位置的条目上使用闩锁

390
00:13:58,660 --> 00:14:01,100


391
00:14:01,100 --> 00:14:03,070
进行更改然后我释放闩锁

392
00:14:03,070 --> 00:14:05,060
一切正常 我们不需要

393
00:14:05,060 --> 00:14:06,380
担心回滚任何更改

394
00:14:06,380 --> 00:14:08,420
与我们对锁的处理方式相同，因为

395
00:14:08,420 --> 00:14:11,330
它是内部事物或更新

396
00:14:11,330 --> 00:14:12,650


397
00:14:12,650 --> 00:14:14,480
数据库系统的物理数据结构

398
00:14:14,480 --> 00:14:15,950


399
00:14:15,950 --> 00:14:18,440


400
00:14:18,440 --> 00:14:23,090
担心回滚是的，所以他说

401
00:14:23,090 --> 00:14:24,470
回滚更改这将在

402
00:14:24,470 --> 00:14:25,550
稍后我们谈论礼貌巨魔

403
00:14:25,550 --> 00:14:28,340
但基本上说就像我想

404
00:14:28,340 --> 00:14:29,630
从我的银行帐户中取出钱并将其

405
00:14:29,630 --> 00:14:31,070
放入您的银行帐户中，因此我们

406
00:14:31,070 --> 00:14:32,840
从我的银行中取出钱 帐户，但

407
00:14:32,840 --> 00:14:34,190
在我将钱存入

408
00:14:34,190 --> 00:14:35,540
您的帐户之前系统

409
00:14:35,540 --> 00:14:36,860


410
00:14:36,860 --> 00:14:38,240


411
00:14:38,240 --> 00:14:40,190


412
00:14:40,190 --> 00:14:41,540
崩溃了 滚动它

413
00:14:41,540 --> 00:14:44,390
很棒相信我但是现在 主要的

414
00:14:44,390 --> 00:14:45,440
事情我们在这里专注于这

415
00:14:45,440 --> 00:14:48,950
件事 所以在操作系统

416
00:14:48,950 --> 00:14:50,480
世界中这将允许应该

417
00:14:50,480 --> 00:14:52,670
像互斥锁 我们实际上

418
00:14:52,670 --> 00:14:54,920
将在我们的数据库系统中使用互斥锁

419
00:14:54,920 --> 00:14:56,420
来保护事物的关键

420
00:14:56,420 --> 00:14:58,760
部分 所以我会 尝试非常

421
00:14:58,760 --> 00:15:00,350
小心，当我的意思是闩锁时总是说闩

422
00:15:00,350 --> 00:15:02,840
锁，但偶尔我会滑倒，

423
00:15:02,840 --> 00:15:05,210
我们会使用锁，但我说这是

424
00:15:05,210 --> 00:15:08,090
内部的事情，我们的意思是闩锁它也

425
00:15:08,090 --> 00:15:09,560
非常令人困惑，因为

426
00:15:09,560 --> 00:15:11,210
您将使用互斥锁实现来保护

427
00:15:11,210 --> 00:15:13,700
您 他的闩锁被称为自旋锁，

428
00:15:13,700 --> 00:15:15,650
好吧，但实际上你知道这个

429
00:15:15,650 --> 00:15:20,490
东西而不是这个东西好吧

430
00:15:20,490 --> 00:15:22,320
所以另一个认为我们想要做的是

431
00:15:22,320 --> 00:15:23,310
页

432
00:15:23,310 --> 00:15:25,650
目录和页表之间的区别所以

433
00:15:25,650 --> 00:15:29,100
记住页目录是我们的

434
00:15:29,100 --> 00:15:31,140
将用于找出在我们的文件中找到页面的位置

435
00:15:31,140 --> 00:15:34,230
，因此我们想要第 1 2 3 页，它会

436
00:15:34,230 --> 00:15:35,700
告诉我们所有

437
00:15:35,700 --> 00:15:37,470
内容中的哪个文件或哪些文件集

438
00:15:37,470 --> 00:15:40,440
具有我们正在寻找的所有内容

439
00:15:40,440 --> 00:15:42,120
我们要改变 进入页面

440
00:15:42,120 --> 00:15:44,100
目录必须是持久的，它们

441
00:15:44,100 --> 00:15:45,600
必须写在磁盘上，因为如果

442
00:15:45,600 --> 00:15:48,300
我们崩溃回来，我们想知道在哪里

443
00:15:48,300 --> 00:15:51,240
可以找到我们拥有的页面页

444
00:15:51,240 --> 00:15:54,420
表是一个内部内存映射，它

445
00:15:54,420 --> 00:15:56,520
只是将页面 ID 匹配到 a 的

446
00:15:56,520 --> 00:15:59,370
帧在缓冲池中，所以

447
00:15:59,370 --> 00:16:00,840
这个东西可以是意大利临时的，

448
00:16:00,840 --> 00:16:02,460
我们不需要通过磁盘备份，因为

449
00:16:02,460 --> 00:16:05,010
如果我们崩溃并回来，我们的缓冲

450
00:16:05,010 --> 00:16:07,010
池无论如何都会被吹走，所以谁在乎

451
00:16:07,010 --> 00:16:09,960
所以这个页面目录有 为了

452
00:16:09,960 --> 00:16:12,840
持久，页表不一定

453
00:16:12,840 --> 00:16:14,640
非得如此，这意味着我们只是使用

454
00:16:14,640 --> 00:16:16,440
了您最喜欢的哈希图或哈希

455
00:16:16,440 --> 00:16:19,050
表实现，适用于

456
00:16:19,050 --> 00:16:20,640
项目 1 您只是使用 s 作为

457
00:16:20,640 --> 00:16:24,150
城市地图，这很好，因为再次 我们

458
00:16:24,150 --> 00:16:25,200
不必担心这个东西

459
00:16:25,200 --> 00:16:27,540
是持久的我们必须确保它

460
00:16:27,540 --> 00:16:29,640
当然是线程安全的但不是

461
00:16:29,640 --> 00:16:33,360
持久的所以现在当我们开始

462
00:16:33,360 --> 00:16:34,560
谈论我们希望如何

463
00:16:34,560 --> 00:16:37,170
在我们的数据库中为缓冲池分配内存时

464
00:16:37,170 --> 00:16:39,390
我们会 投掷思考

465
00:16:39,390 --> 00:16:41,970
有两种不同的方式，所以第一个

466
00:16:41,970 --> 00:16:43,260
是我们可以选择我所说的

467
00:16:43,260 --> 00:16:46,350
一种全局策略，我们试图

468
00:16:46,350 --> 00:16:48,450
做出有利于整个

469
00:16:48,450 --> 00:16:50,130
工作负载的决策，我们试图转向

470
00:16:50,130 --> 00:16:52,680
尝试执行我们查看所有

471
00:16:52,680 --> 00:16:53,910
查询系统中正在进行的所有事务，

472
00:16:53,910 --> 00:16:55,650
我们试图

473
00:16:55,650 --> 00:16:56,940
在此时说出什么是

474
00:16:56,940 --> 00:16:59,160
我应该做的正确的事情来选择

475
00:16:59,160 --> 00:17:02,550
应该在内存中而不是内存中的

476
00:17:02,550 --> 00:17:05,550
替代方案是使用我们正在使用的本地策略

477
00:17:05,550 --> 00:17:08,339


478
00:17:08,339 --> 00:17:10,920
我们正在运行的每一个查询或每一个事务我们都

479
00:17:10,920 --> 00:17:12,599
试图说出让我的一个查询一个事务更快地做的最好的事情，

480
00:17:12,599 --> 00:17:14,700


481
00:17:14,700 --> 00:17:17,459
即使对于

482
00:17:17,459 --> 00:17:19,380
实际上可能是一个糟糕的全局系统来说是一个

483
00:17:19,380 --> 00:17:23,970
糟糕的选择所以 没有一种方法

484
00:17:23,970 --> 00:17:25,349
比另一种方法更好 显然

485
00:17:25,349 --> 00:17:27,119
，如果您

486
00:17:27,119 --> 00:17:28,710
拥有全局视图与本地视图

487
00:17:28,710 --> 00:17:30,270
，则可以进行优化，但是对于每个整数查询，您

488
00:17:30,270 --> 00:17:32,160
可能会更适合他们

489
00:17:32,160 --> 00:17:33,620
想要做的事情，以使其快速运行，

490
00:17:33,620 --> 00:17:35,390
因此我们 已经

491
00:17:35,390 --> 00:17:36,590
在我们进行

492
00:17:36,590 --> 00:17:38,990
优化的过程中看到了很多这样的例子 大多数系统

493
00:17:38,990 --> 00:17:40,490
可能会尝试适应其中的

494
00:17:40,490 --> 00:17:42,770
两个 你将

495
00:17:42,770 --> 00:17:44,570
在第一个项目中实现的东西被认为是一个

496
00:17:44,570 --> 00:17:45,620
全局策略，因为只要

497
00:17:45,620 --> 00:17:47,870
看看你就知道是什么

498
00:17:47,870 --> 00:17:49,690
最近最少使用的页面并删除它，

499
00:17:49,690 --> 00:17:51,830
即使这让我对某个

500
00:17:51,830 --> 00:17:55,580
特定查询

501
00:17:55,580 --> 00:17:56,960


502
00:17:56,960 --> 00:17:59,090


503
00:17:59,090 --> 00:18:00,679


504
00:18:00,679 --> 00:18:03,080
不好 然后你

505
00:18:03,080 --> 00:18:05,120
查看所有集合，你在

506
00:18:05,120 --> 00:18:07,220
分配的内存中，这告诉你

507
00:18:07,220 --> 00:18:08,330
这是你正在寻找的页面，

508
00:18:08,330 --> 00:18:12,890
它看起来很简单，所以现在

509
00:18:12,890 --> 00:18:14,000
我们想谈谈如何真正

510
00:18:14,000 --> 00:18:15,620
让这个东西变得超级棒或

511
00:18:15,620 --> 00:18:18,380
超级 为

512
00:18:18,380 --> 00:18:20,059
我们尝试运行的应用程序或

513
00:18:20,059 --> 00:18:21,289
尝试在我们的数据库

514
00:18:21,289 --> 00:18:23,120
系统内部运行的工作量身定制，这将允许我们做

515
00:18:23,120 --> 00:18:24,470
操作系统

516
00:18:24,470 --> 00:18:26,210
不能做的某些事情，因为 它不知道

517
00:18:26,210 --> 00:18:27,440


518
00:18:27,440 --> 00:18:28,610
你正在运行什么样的查询 它不知道

519
00:18:28,610 --> 00:18:29,630
他们正在接触什么数据 他们接下来要接触什么

520
00:18:29,630 --> 00:18:30,289


521
00:18:30,289 --> 00:18:32,029
所以现在我们可以谈谈

522
00:18:32,029 --> 00:18:33,770
我们可以做些什么来做这件事

523
00:18:33,770 --> 00:18:35,659
比什么样的天真的方案

524
00:18:35,659 --> 00:18:37,520
做得更好所以谈论如何处理多个

525
00:18:37,520 --> 00:18:39,140
缓冲池预取扫描

526
00:18:39,140 --> 00:18:41,270
共享然后最后一个是缓冲

527
00:18:41,270 --> 00:18:45,799
池绕过好的所以在我展示的示例中

528
00:18:45,799 --> 00:18:48,380
我将缓冲池称为

529
00:18:48,380 --> 00:18:51,110
单个 实体和数据实际上有一个

530
00:18:51,110 --> 00:18:54,140
缓冲池，您可以有

531
00:18:54,140 --> 00:18:56,179
多个缓冲池，因此您分配了

532
00:18:56,179 --> 00:18:57,440
多个内存区域，

533
00:18:57,440 --> 00:18:59,270
每个区域都有自己的页

534
00:18:59,270 --> 00:19:00,380
表，每个区域都有自己

535
00:19:00,380 --> 00:19:03,980
的页表映射到帧 ID 或

536
00:19:03,980 --> 00:19:07,309
帧 好吧，你

537
00:19:07,309 --> 00:19:09,080
想要这样做的原因是现在你可以为

538
00:19:09,080 --> 00:19:11,200
每个缓冲池拥有你实际上可以

539
00:19:11,200 --> 00:19:13,880
为该缓冲池制定本地策略，该策略针对你放入其中

540
00:19:13,880 --> 00:19:15,770
的任何数据量身定制

541
00:19:15,770 --> 00:19:18,049
，

542
00:19:18,049 --> 00:19:20,960
例如我 可以吗

543
00:19:20,960 --> 00:19:23,630
每个表都有一个缓冲池，因为也许有些

544
00:19:23,630 --> 00:19:24,860
表我在做一堆 scruncho

545
00:19:24,860 --> 00:19:27,169
扫描，有些表我在做点

546
00:19:27,169 --> 00:19:28,220
查询，或者我一次跳转到单个

547
00:19:28,220 --> 00:19:30,320
页面，我可以有不同的

548
00:19:30,320 --> 00:19:31,669
收银员政策或不同的 放置

549
00:19:31,669 --> 00:19:33,620
策略根据两种

550
00:19:33,620 --> 00:19:35,690
工作负载类型来决定，但

551
00:19:35,690 --> 00:19:38,000
如果它是一个巨人，我就不能那么容易 只是一个巨大的

552
00:19:38,000 --> 00:19:40,130
缓冲池 假设我有它 我

553
00:19:40,130 --> 00:19:41,510
可以有一个用于索引的

554
00:19:41,510 --> 00:19:43,190
缓冲池和用于表的缓冲池，然后 他们

555
00:19:43,190 --> 00:19:44,390
有不同的访问模式，然后

556
00:19:44,390 --> 00:19:45,919
我可以为每个人制定不同的策略，

557
00:19:45,919 --> 00:19:46,990


558
00:19:46,990 --> 00:19:49,059
你还得到的另一个大优势

559
00:19:49,059 --> 00:19:50,620
是它最终会减少试图正确访问它

560
00:19:50,620 --> 00:19:53,799
的不同线程的闩锁争用，

561
00:19:53,799 --> 00:19:55,779
所以

562
00:19:55,779 --> 00:19:56,980
当我这样做时，请查找 在页表中，

563
00:19:56,980 --> 00:19:58,510
我必须锁定我正在查看的条目，

564
00:19:58,510 --> 00:20:01,000
因为我要找到

565
00:20:01,000 --> 00:20:02,350
包含我想要的数据的框架，我将

566
00:20:02,350 --> 00:20:03,700
确保没有其他人将其换掉

567
00:20:03,700 --> 00:20:06,399
，但您从 时间

568
00:20:06,399 --> 00:20:07,720
我从 当我去获取

569
00:20:07,720 --> 00:20:10,990
我想要的页面时，这意味着

570
00:20:10,990 --> 00:20:12,970
我可以有一堆线程调用

571
00:20:12,970 --> 00:20:14,919
在同一个锁存器上竞争，

572
00:20:14,919 --> 00:20:16,149
它们可能都访问同一个页

573
00:20:16,149 --> 00:20:18,340
表，所以无论我的品牌有多少个内核 -

574
00:20:18,340 --> 00:20:20,380
新机器我没有得到

575
00:20:20,380 --> 00:20:22,690
很好的可扩展性，因为一切都

576
00:20:22,690 --> 00:20:25,059
在这些关键部分上进行竞争，

577
00:20:25,059 --> 00:20:27,279
但是现在如果我只有多个

578
00:20:27,279 --> 00:20:30,700
页表每个线程你知道他们

579
00:20:30,700 --> 00:20:32,020
可以同时访问

580
00:20:32,020 --> 00:20:33,850
不同页表的不同页面

581
00:20:33,850 --> 00:20:35,620
，因此它们不是 争夺

582
00:20:35,620 --> 00:20:37,360
这些闩锁，现在我获得了更好的

583
00:20:37,360 --> 00:20:39,429
可扩展性，现在仍然可能成为

584
00:20:39,429 --> 00:20:40,779
磁盘馈送的瓶颈，这

585
00:20:40,779 --> 00:20:42,730
始终是一个大问题，至少在内部

586
00:20:42,730 --> 00:20:44,860
现在我不担心它们，你知道

587
00:20:44,860 --> 00:20:48,010
试图获得相同的闩锁，所以

588
00:20:48,010 --> 00:20:50,260
这是一些东西 你看到的大多是

589
00:20:50,260 --> 00:20:52,179
企业或昂贵的数据库系统，

590
00:20:52,179 --> 00:20:56,679
所以 Oracle db2 Sybase 和 max Seigle

591
00:20:56,679 --> 00:20:58,450
服务器都支持这种拥有

592
00:20:58,450 --> 00:21:01,000
多个紫色 db2 的能力，你可以做

593
00:21:01,000 --> 00:21:01,990
各种疯狂的事情 创建多个

594
00:21:01,990 --> 00:21:04,059
多个缓冲池 您可以为它们签署

595
00:21:04,059 --> 00:21:05,169
不同的表

596
00:21:05,169 --> 00:21:06,940
如果

597
00:21:06,940 --> 00:21:08,500
您将它们设置为不同的页面

598
00:21:08,500 --> 00:21:11,710
大小，您可以为所有人制定不同的收银员政策 我的 Siegel 即使它是

599
00:21:11,710 --> 00:21:13,659
开源的实际上也有这个，但

600
00:21:13,659 --> 00:21:15,789
它并不那么复杂 你只是

601
00:21:15,789 --> 00:21:17,230
说你想要多少缓冲池实例

602
00:21:17,230 --> 00:21:19,330
，然后他们只是做循环

603
00:21:19,330 --> 00:21:22,960
哈希来决定你知道什么，如果

604
00:21:22,960 --> 00:21:24,850
你会原谅和 pagenty

605
00:21:24,850 --> 00:21:25,990
我正在寻找的数据在哪里，缓冲

606
00:21:25,990 --> 00:21:29,770
池有它，所以有两种方法 要

607
00:21:29,770 --> 00:21:31,990
正确使用这些东西，他们必须

608
00:21:31,990 --> 00:21:33,159
将您正在寻找的东西映射到一个

609
00:21:33,159 --> 00:21:35,440
缓冲池，

610
00:21:35,440 --> 00:21:36,760
该缓冲池

611
00:21:36,760 --> 00:21:38,710


612
00:21:38,710 --> 00:21:41,559
具有您想要的页面 这次您在

613
00:21:41,559 --> 00:21:43,270
缓冲池中知道一个，然后当

614
00:21:43,270 --> 00:21:44,679
您稍后获取有关迪斯科舞厅的信息时，它

615
00:21:44,679 --> 00:21:46,120
会出现另一个它总是

616
00:21:46,120 --> 00:21:47,230
希望在同一位置，因此

617
00:21:47,230 --> 00:21:50,289
您知道如何快速找到它，因此

618
00:21:50,289 --> 00:21:51,429
第一种方法是 您实际上

619
00:21:51,429 --> 00:21:53,649
可以将记录 ID 扩展为现在包含

620
00:21:53,649 --> 00:21:56,409
有关

621
00:21:56,409 --> 00:21:59,230
此缓冲池正在管理的数据库对象的附加元数据，

622
00:21:59,230 --> 00:22:01,529
因此如果您还记得当我们查看

623
00:22:01,529 --> 00:22:05,500
Oracle 和续集服务器的记录 ID 时，

624
00:22:05,500 --> 00:22:07,899
它们具有 Postgres 没有的额外列的额外信息

625
00:22:07,899 --> 00:22:09,940
后面的邮政编码

626
00:22:09,940 --> 00:22:12,190
有页面和插槽编号，

627
00:22:12,190 --> 00:22:14,470
就像对象编号

628
00:22:14,470 --> 00:22:17,440
页码和插槽编号一样，因此我们可以

629
00:22:17,440 --> 00:22:19,570
使用该附加对象编号，

630
00:22:19,570 --> 00:22:21,279
他们没有另一张地图，

631
00:22:21,279 --> 00:22:23,889
说明您知道 XYZ，您

632
00:22:23,889 --> 00:22:25,659
可以 这是一个小姐，它在这个缓冲池

633
00:22:25,659 --> 00:22:28,750
或那个缓冲池中，所以现在

634
00:22:28,750 --> 00:22:30,669
来自你所说的系统级别的请求

635
00:22:30,669 --> 00:22:31,750
给我你知道给我一个

636
00:22:31,750 --> 00:22:33,429
记录一二三，我知道如何

637
00:22:33,429 --> 00:22:35,769
拆分它并找出

638
00:22:35,769 --> 00:22:37,419
它对应于什么对象以及什么缓冲池

639
00:22:37,419 --> 00:22:41,169
将再次为散列方法维护该数据

640
00:22:41,169 --> 00:22:42,190
我认为这就是我的

641
00:22:42,190 --> 00:22:43,840
秘密它非常简单你只需

642
00:22:43,840 --> 00:22:45,909
获取你散列它的记录 ID 和 mod n

643
00:22:45,909 --> 00:22:47,740
的数量 你拥有的缓冲池

644
00:22:47,740 --> 00:22:49,960
，它只是告诉你去哪里

645
00:22:49,960 --> 00:22:52,210
吃你想要的晚餐，你做

646
00:22:52,210 --> 00:22:54,250
的真的很快 真的很快 这不是

647
00:22:54,250 --> 00:22:55,570
一个昂贵的操作

648
00:22:55,570 --> 00:22:56,679
实际上因为它不是一个昂贵的

649
00:22:56,679 --> 00:22:58,950
操作

650
00:22:58,950 --> 00:23:01,029
好吧 我们可以做的下一个优化

651
00:23:01,029 --> 00:23:04,539
是 进行预取，所以这里的想法

652
00:23:04,539 --> 00:23:06,639
是，我们再次希望最大限度地减少

653
00:23:06,639 --> 00:23:09,490
由于必须转到磁盘或读取数据而导致的停顿和数据系统，

654
00:23:09,490 --> 00:23:12,760
因此如果我们

655
00:23:12,760 --> 00:23:15,039
开始进行扫描并且我们的缓冲

656
00:23:15,039 --> 00:23:17,260
池正在清空此查询想要

657
00:23:17,260 --> 00:23:20,110
读取页面 零页

658
00:23:20,110 --> 00:23:22,480
内存中没有不在我们的缓冲池中，因此我们

659
00:23:22,480 --> 00:23:24,519
必须暂停该线程，直到我们从

660
00:23:24,519 --> 00:23:26,409
磁盘取出它然后将其放入我们的

661
00:23:26,409 --> 00:23:28,720
缓冲池中，然后一旦它在我们的适当

662
00:23:28,720 --> 00:23:30,820
池中，然后我们将指针交

663
00:23:30,820 --> 00:23:32,409
还给 上层系统说您

664
00:23:32,409 --> 00:23:34,450
想要的页面现在在我们的记忆中

665
00:23:34,450 --> 00:23:37,679


666
00:23:37,679 --> 00:23:39,970


667
00:23:39,970 --> 00:23:42,460


668
00:23:42,460 --> 00:23:44,470
一个数据库

669
00:23:44,470 --> 00:23:47,169
系统 会跟踪

670
00:23:47,169 --> 00:23:48,850
这种类似光标的东西，就像你遍历

671
00:23:48,850 --> 00:23:50,500
每一页一样，你的查询

672
00:23:50,500 --> 00:23:52,149
需要你知道你上次离开的地方

673
00:23:52,149 --> 00:23:53,320
，所以当你回去

674
00:23:53,320 --> 00:23:55,179
说给我下一页时，它不会

675
00:23:55,179 --> 00:23:56,230
开始 一开始它跳到

676
00:23:56,230 --> 00:23:59,049
你离开的地方，所以在这种情况下

677
00:23:59,049 --> 00:24:01,210
，我得到零报酬我现在完成了

678
00:24:01,210 --> 00:24:03,130
我开始阅读同样的事情我

679
00:24:03,130 --> 00:24:04,679
不得不停止，因为它不在内存中

680
00:24:04,679 --> 00:24:06,909
，磁盘移动并得到它我们' 已经放入

681
00:24:06,909 --> 00:24:08,019
我们的旅游缓冲池，然后一旦我

682
00:24:08,019 --> 00:24:10,389
有了它，现在我可以继续

683
00:24:10,389 --> 00:24:11,530
操作他们自己的

684
00:24:11,530 --> 00:24:13,570
所以假设这里的这个查询想要

685
00:24:13,570 --> 00:24:15,490
扫描整个表，这些

686
00:24:15,490 --> 00:24:17,460
是我们的表，这里是所有的页面，

687
00:24:17,460 --> 00:24:20,410
所以在这一点上 过去的数据

688
00:24:20,410 --> 00:24:22,300
可能会识别哦，我知道

689
00:24:22,300 --> 00:24:24,100
你最终会扫描整个表格，

690
00:24:24,100 --> 00:24:26,740
所以与其等着我

691
00:24:26,740 --> 00:24:28,390
等着你一页一页地问

692
00:24:28,390 --> 00:24:30,490
，让我继续向前跳

693
00:24:30,490 --> 00:24:31,900
，说哦，我想你 我还

694
00:24:31,900 --> 00:24:34,330
需要第二页和第三页所以让我走

695
00:24:34,330 --> 00:24:36,670
为你预取它放入

696
00:24:36,670 --> 00:24:39,070
缓冲池，所以当你完成

697
00:24:39,070 --> 00:24:41,290
处理第一页的时候，现在你去问

698
00:24:41,290 --> 00:24:44,260
我第 2 页或第 3 页它已经

699
00:24:44,260 --> 00:24:46,810
在那里了，现在你没有一个摊位，

700
00:24:46,810 --> 00:24:48,940
再次基于我如何布置这些

701
00:24:48,940 --> 00:24:51,190
磁盘上的页面，这可能是一个

702
00:24:51,190 --> 00:24:54,280
超快的顺序读取，所以

703
00:24:54,280 --> 00:24:55,900
通过提前阻止事情我你

704
00:24:55,900 --> 00:24:58,420
知道我正在最小化

705
00:24:58,420 --> 00:25:02,170
我正在做的随机 i/o 的数量让我们继续

706
00:25:02,170 --> 00:25:03,580
下去并预取

707
00:25:03,580 --> 00:25:05,200
一切都是为了最大限度

708
00:25:05,200 --> 00:25:09,310
地减少这些远端 x' 的影响，所以这个

709
00:25:09,310 --> 00:25:13,300
例子非常简单

710
00:25:13,300 --> 00:25:14,260
，你的操作系统现在也可以解决

711
00:25:14,260 --> 00:25:17,140
这个问题，nmap

712
00:25:17,140 --> 00:25:19,570
实际上会为你做这件事，所以

713
00:25:19,570 --> 00:25:21,430
你可以轻拍标志的 M 地图 说我要

714
00:25:21,430 --> 00:25:23,230
对磁盘上的这些页面进行特殊读取

715
00:25:23,230 --> 00:25:25,690
，它会继续并提前预取

716
00:25:25,690 --> 00:25:28,090
一堆它们，这样再次

717
00:25:28,090 --> 00:25:30,040
将最大程度地减少停顿，因为

718
00:25:30,040 --> 00:25:30,880
因为您必须从磁盘读取某些内容，

719
00:25:30,880 --> 00:25:34,410
所以 M 映射 甚至可以在

720
00:25:34,410 --> 00:25:36,340
不知道的情况下弄清楚这一点

721
00:25:36,340 --> 00:25:37,600
找出查询试图做什么，数据

722
00:25:37,600 --> 00:25:38,770
系统知道查询想要做什么，

723
00:25:38,770 --> 00:25:41,110
并且可以提前预取，但是

724
00:25:41,110 --> 00:25:43,390
现在有一些查询，

725
00:25:43,390 --> 00:25:44,800
操作系统

726
00:25:44,800 --> 00:25:46,570
无法知道要做什么，但是 我们在

727
00:25:46,570 --> 00:25:47,920
本土主义系统中这样做，因为我们知道

728
00:25:47,920 --> 00:25:50,530
查询想要什么所以你所以一个例子

729
00:25:50,530 --> 00:25:53,350
就像一个索引游戏所以假设

730
00:25:53,350 --> 00:25:55,300
我想在这个表上做一个扫描，我

731
00:25:55,300 --> 00:25:57,340
想得到我想找到的所有值

732
00:25:57,340 --> 00:25:58,570
所有具有该值的元组都

733
00:25:58,570 --> 00:26:03,130
在 100 到 250 之间，所以现在

734
00:26:03,130 --> 00:26:06,160
假设我有一个关于该值的索引，并且

735
00:26:06,160 --> 00:26:07,450
我已经解释了索引的含义。

736
00:26:07,450 --> 00:26:09,460


737
00:26:09,460 --> 00:26:10,990


738
00:26:10,990 --> 00:26:12,280
具有您想要的数据的特定页面

739
00:26:12,280 --> 00:26:14,620
如此正确，因此

740
00:26:14,620 --> 00:26:16,570
我可以

741
00:26:16,570 --> 00:26:18,190
跳过索引并准确找到

742
00:26:18,190 --> 00:26:20,140
我正在寻找的内容，而不是连续扫描

743
00:26:20,140 --> 00:26:23,560


744
00:26:23,560 --> 00:26:25,619


745
00:26:25,619 --> 00:26:28,479
当我的查询开始时范围是多少 做那次扫描

746
00:26:28,479 --> 00:26:30,369
我总是要阅读索引的第一页，

747
00:26:30,369 --> 00:26:31,389
因为那是路线，

748
00:26:31,389 --> 00:26:33,759
所以你知道我必须跳到

749
00:26:33,759 --> 00:26:36,190
那里，但现在我要做一个查找并

750
00:26:36,190 --> 00:26:38,289
说我正在寻找我的查询

751
00:26:38,289 --> 00:26:40,929
在 100 之间 和 250 所以我知道

752
00:26:40,929 --> 00:26:42,879
我需要的所有页面或我

753
00:26:42,879 --> 00:26:44,889
想要的值大于等于

754
00:26:44,889 --> 00:26:47,079
100 或将从树的这一侧开始

755
00:26:47,079 --> 00:26:49,359
所以现在我要跳到第一

756
00:26:49,359 --> 00:26:51,969
页并阅读正确的

757
00:26:51,969 --> 00:26:53,200
在这一点上仍然是连续的，

758
00:26:53,200 --> 00:26:54,429
所以操作系统可以再次解决

759
00:26:54,429 --> 00:26:57,070
这个问题，但现在我要分支并向

760
00:26:57,070 --> 00:27:00,909
下走，我要扫描

761
00:27:00,909 --> 00:27:04,029
叶节点，但这是索引页三

762
00:27:04,029 --> 00:27:06,249
索引页五它们不连续

763
00:27:06,249 --> 00:27:09,579
彼此在磁盘上，所以

764
00:27:09,579 --> 00:27:10,929
操作系统可能会尝试最终

765
00:27:10,929 --> 00:27:13,299
预取第二页和第三页，但

766
00:27:13,299 --> 00:27:15,159
我不需要浪费的第二页，

767
00:27:15,159 --> 00:27:16,899
我需要第五页，但它没有预取

768
00:27:16,899 --> 00:27:19,899
，因为我们知道什么是 查询

769
00:27:19,899 --> 00:27:22,119
要做我们可以继续并

770
00:27:22,119 --> 00:27:23,979
准确地预取我们想要的页面 t 并将

771
00:27:23,979 --> 00:27:27,159
它们带入我们的缓冲池，因为我们可以

772
00:27:27,159 --> 00:27:29,169
理解什么是

773
00:27:29,169 --> 00:27:31,269
实际上下文什么是查询的上下文

774
00:27:31,269 --> 00:27:32,499
以及这些页面实际

775
00:27:32,499 --> 00:27:34,570
代表什么因为

776
00:27:34,570 --> 00:27:35,889
操作系统处理这些页面它不知道其中有

777
00:27:35,889 --> 00:27:37,719
什么但我们 知道因为我们

778
00:27:37,719 --> 00:27:39,639
写了这段代码 我们知道这些是

779
00:27:39,639 --> 00:27:40,899
索引页并且它们

780
00:27:40,899 --> 00:27:42,999
以某种方式连接在一起 所以我们知道如何进行这种

781
00:27:42,999 --> 00:27:45,609
遍历 所以这不是

782
00:27:45,609 --> 00:27:47,019
免费的 我们必须跟踪一些额外的元数据

783
00:27:47,019 --> 00:27:48,940
这些页面

784
00:27:48,940 --> 00:27:50,799
说这里是兄弟姐妹 这是我的

785
00:27:50,799 --> 00:27:52,329
起点 或我的终点 这是

786
00:27:52,329 --> 00:27:54,190
他的起点 所以我知道我是否

787
00:27:54,190 --> 00:27:56,229
会扫描这里 实际上

788
00:27:56,229 --> 00:27:57,940
我不知道在我看三个之前我是否需要五个

789
00:27:57,940 --> 00:28:01,239
所以你 知道这一点，我并不是

790
00:28:01,239 --> 00:28:02,979
说这非常容易做到，但是

791
00:28:02,979 --> 00:28:05,379
您可以再次看到我们可能无法

792
00:28:05,379 --> 00:28:07,629
以操作系统无法再次找到

793
00:28:07,629 --> 00:28:09,700
的方式准确地按顺序跳转页面，

794
00:28:09,700 --> 00:28:13,809


795
00:28:13,809 --> 00:28:15,249
这是这样的 我  这是

796
00:28:15,249 --> 00:28:16,479
我们可以在我们的数据库系统中做的事情的经典示例，

797
00:28:16,479 --> 00:28:18,190
而 opera sim 不能做，

798
00:28:18,190 --> 00:28:20,169
因为它不

799
00:28:20,169 --> 00:28:22,389
知道数据中的内容，它只是看到

800
00:28:22,389 --> 00:28:26,559
一堆区域写入，我们可以做的下一个

801
00:28:26,559 --> 00:28:28,089
优化是 称为扫描

802
00:28:28,089 --> 00:28:31,989
共享，所以这里的想法是我们可以

803
00:28:31,989 --> 00:28:34,569
让查询相互捎带

804
00:28:34,569 --> 00:28:38,750
并重用一个

805
00:28:38,750 --> 00:28:40,730
查询从磁盘读取的数据并将其

806
00:28:40,730 --> 00:28:43,220
用于其查询，因此这与

807
00:28:43,220 --> 00:28:45,679
结果缓存不同，结果缓存是说我

808
00:28:45,679 --> 00:28:48,140
完全运行 相同的查询，我计算了

809
00:28:48,140 --> 00:28:49,940
一些答案，然后我缓存

810
00:28:49,940 --> 00:28:51,740
了相同查询的结果再次显示我可以

811
00:28:51,740 --> 00:28:53,419
重新运行查询我只是

812
00:28:53,419 --> 00:28:55,610
给你我之前的答案在存储层

813
00:28:55,610 --> 00:28:57,230
的 puffle 管理器中处于较低级别

814
00:28:57,230 --> 00:28:59,240
我们现在的位置

815
00:28:59,240 --> 00:29:02,000
只是让这个游标访问页面，

816
00:29:02,000 --> 00:29:03,950
然后我们可以将

817
00:29:03,950 --> 00:29:05,799
我们从一个线程中获取的页面重用于另一个线程

818
00:29:05,799 --> 00:29:08,600
，这样它就会起作用，当

819
00:29:08,600 --> 00:29:10,039
允许多个查询附加到

820
00:29:10,039 --> 00:29:11,720
单个游标时 浏览

821
00:29:11,720 --> 00:29:13,159
我们的页面并将它们放入缓冲

822
00:29:13,159 --> 00:29:14,960
池，这几乎就像一个 pub sub 的事情

823
00:29:14,960 --> 00:29:17,210
，我们说我想知道你是否

824
00:29:17,210 --> 00:29:18,530
得到了一个新页面，然后你可以通知

825
00:29:18,530 --> 00:29:19,940
任何可能正在等待

826
00:29:19,940 --> 00:29:21,110
它的线程，即使它们没有

827
00:29:21,110 --> 00:29:23,900
实际执行读取的那个，因此

828
00:29:23,900 --> 00:29:25,400
根据实现，查询

829
00:29:25,400 --> 00:29:26,740
不需要完全相同，

830
00:29:26,740 --> 00:29:29,330
通常在结果缓存中他们在

831
00:29:29,330 --> 00:29:31,400
我们和我们的世界中所做的他们

832
00:29:31,400 --> 00:29:32,630
不必只是我需要知道我是否

833
00:29:32,630 --> 00:29:35,179
阅读相同的页面，然后在某些

834
00:29:35,179 --> 00:29:37,840
情况下，如果他们正在计算

835
00:29:37,840 --> 00:29:41,000
相似的结果，我们可以共享这些

836
00:29:41,000 --> 00:29:42,740
直接结果并跨不同的

837
00:29:42,740 --> 00:29:45,830
线程，因此最像它被称为

838
00:29:45,830 --> 00:29:47,360
物化视图，我们将

839
00:29:47,360 --> 00:29:48,860
在本学期晚些时候介绍，但对于我们的

840
00:29:48,860 --> 00:29:49,850
这个游戏的目的我们只是在

841
00:29:49,850 --> 00:29:53,630
看页面访问，所以它的

842
00:29:53,630 --> 00:29:55,370
工作方式是，如果一个查询开始一个立场

843
00:29:55,370 --> 00:29:58,280
，然后它识别出

844
00:29:58,280 --> 00:30:01,010
另一个查询也在做同样的扫描，

845
00:30:01,010 --> 00:30:03,650
它只是将自己附加到第一

846
00:30:03,650 --> 00:30:07,280
个人 的光标，然后当它获取页面时，

847
00:30:07,280 --> 00:30:09,320
我们会收到该页面进入的通知

848
00:30:09,320 --> 00:30:12,320
，我们也可以访问它，

849
00:30:12,320 --> 00:30:13,940
所以重要的是要知道我们

850
00:30:13,940 --> 00:30:15,500
必须跟踪第二个

851
00:30:15,500 --> 00:30:17,150
查询出现的位置

852
00:30:17,150 --> 00:30:19,730
游标的训练，以便我们

853
00:30:19,730 --> 00:30:21,080
知道游标是否在第一个查询中结束，

854
00:30:21,080 --> 00:30:22,880
可能还有其他数据我们必须

855
00:30:22,880 --> 00:30:25,970
返回阅读

856
00:30:25,970 --> 00:30:27,350


857
00:30:27,350 --> 00:30:29,059
所以我们

858
00:30:29,059 --> 00:30:31,970
可以回来看看剩下的，

859
00:30:31,970 --> 00:30:34,100
据我所知，这种技术

860
00:30:34,100 --> 00:30:36,590
只在 db2 和 sequel 服务器

861
00:30:36,590 --> 00:30:38,990
中得到完全支持，很难得到正确的结果，这

862
00:30:38,990 --> 00:30:40,580
看起来有点微不足道，但根据查询的内容，它可能会变得

863
00:30:40,580 --> 00:30:42,380
非常粗糙

864
00:30:42,380 --> 00:30:45,110
做 Oracle 支持有一个

865
00:30:45,110 --> 00:30:48,470
基本的恐慌改变他们称之为游标

866
00:30:48,470 --> 00:30:50,600
共享然后但它只有在

867
00:30:50,600 --> 00:30:52,370
你有两个完全相同的时间运行的精确查询时才有效，

868
00:30:52,370 --> 00:30:55,010
而这些人可以

869
00:30:55,010 --> 00:30:56,270
根据你

870
00:30:56,270 --> 00:30:57,530
知道我需要的查询进行推断我知道你正在阅读这张

871
00:30:57,530 --> 00:30:59,570
表 我需要阅读 同样的事情并

872
00:30:59,570 --> 00:31:01,220
跳上它这件事必须说我有

873
00:31:01,220 --> 00:31:02,360
两个查询我正在做完全相同的

874
00:31:02,360 --> 00:31:06,110
事情所以让我们看一个例子所以说我们

875
00:31:06,110 --> 00:31:07,730
在这里有我们的第一个查询它正在计算a

876
00:31:07,730 --> 00:31:10,850
的总和所以查询

877
00:31:10,850 --> 00:31:12,559
游标正在运行 开始，它只是

878
00:31:12,559 --> 00:31:15,559
开始扫描表格，

879
00:31:15,559 --> 00:31:18,770
查看每一页，所以现在

880
00:31:18,770 --> 00:31:20,570
让我们说此时它想要

881
00:31:20,570 --> 00:31:23,390
读取第三页我们没有任何空闲

882
00:31:23,390 --> 00:31:25,460
帧和缓冲池，所以我们运行我们的

883
00:31:25,460 --> 00:31:27,380
替换策略 算法来决定

884
00:31:27,380 --> 00:31:28,970


885
00:31:28,970 --> 00:31:30,559
在这种情况下我们要删除哪些页面在这里我们将做一些

886
00:31:30,559 --> 00:31:32,960
简单的事情并说第零页是

887
00:31:32,960 --> 00:31:35,809


888
00:31:35,809 --> 00:31:37,760
自我访问它以来最旧的页面的最后一页所以让我

889
00:31:37,760 --> 00:31:39,290
继续 用第三页替换它

890
00:31:39,290 --> 00:31:42,280
，然后现在我继续扫描，

891
00:31:42,280 --> 00:31:45,050
但现在让我们说在

892
00:31:45,050 --> 00:31:47,020
我们在第 3 页换出第 0 页之后发生这种情况后，

893
00:31:47,020 --> 00:31:50,240
第二个查询出现了，它也想

894
00:31:50,240 --> 00:31:52,970
在这个表上进行中央扫描，

895
00:31:52,970 --> 00:31:56,480
所以没有扫描共享它会

896
00:31:56,480 --> 00:31:58,010
像 t 一样从头开始 他是第一个家伙

897
00:31:58,010 --> 00:32:00,530
，一直剥皮，但这

898
00:32:00,530 --> 00:32:01,790
对我们来说实际上是最糟糕的事情，因为

899
00:32:01,790 --> 00:32:03,860
要读取的第一件事是第零页，

900
00:32:03,860 --> 00:32:06,080
但我们只是将其扔到磁盘上，

901
00:32:06,080 --> 00:32:08,450
所以现在我们最终可能会崩溃，因为

902
00:32:08,450 --> 00:32:09,950
这家伙可以' 直到页面

903
00:32:09,950 --> 00:32:12,050
0 进入所以这会你知道它

904
00:32:12,050 --> 00:32:13,760
必须被盗才能取回

905
00:32:13,760 --> 00:32:15,470
但我只是在内存中但我摆脱了

906
00:32:15,470 --> 00:32:19,100
它所以这很糟糕所以扫描共享

907
00:32:19,100 --> 00:32:20,630
这个家伙只是跳来跳去 骑车

908
00:32:20,630 --> 00:32:23,570
并阅读 q1 读取的相同内容

909
00:32:23,570 --> 00:32:26,450
，您知道会产生您计算

910
00:32:26,450 --> 00:32:27,710


911
00:32:27,710 --> 00:32:28,760
该部分数据正在查看的那部分所需的任何敌人

912
00:32:28,760 --> 00:32:32,360
，所以现在此时 q1 已完成，因此

913
00:32:32,360 --> 00:32:35,059
它的光标消失，然后 q2 重新

914
00:32:35,059 --> 00:32:36,559
开始 开始和

915
00:32:36,559 --> 00:32:38,059
我在你阅读

916
00:32:38,059 --> 00:32:40,790
第三页时开始的那些节点所以这是我需要

917
00:32:40,790 --> 00:32:43,780
向下扫描的时间，直到我得到最终结果

918
00:32:43,780 --> 00:32:46,780
是的

919
00:32:56,330 --> 00:33:02,730
这个问题是每个查询

920
00:33:02,730 --> 00:33:05,760
也在计算中间结果，因为它读取

921
00:33:05,760 --> 00:33:08,400
这个数据所以他们也 现在需要一个

922
00:33:08,400 --> 00:33:11,460
内存区域 把这些数据放在

923
00:33:11,460 --> 00:33:13,370
与这个缓冲池分开的地方

924
00:33:13,370 --> 00:33:15,750
是的，所以我们会在一秒钟内看到这是一个关于 Postgres 的考试，

925
00:33:15,750 --> 00:33:20,010
但

926
00:33:20,010 --> 00:33:21,659
通常内存也会得到一个

927
00:33:21,659 --> 00:33:25,650
缓冲池的支持，因为如果我

928
00:33:25,650 --> 00:33:27,419
最终计算一些你知道的东西 假设

929
00:33:27,419 --> 00:33:29,429
我正在计算一个连接并且

930
00:33:29,429 --> 00:33:31,919
该联合运算符的输出不适合

931
00:33:31,919 --> 00:33:32,460
内存

932
00:33:32,460 --> 00:33:34,890
我需要 B 它开始将这些页面

933
00:33:34,890 --> 00:33:37,740
输出到磁盘，因此任何像这样的临时内存

934
00:33:37,740 --> 00:33:38,909
仍然会得到

935
00:33:38,909 --> 00:33:40,650
缓冲池的支持，但它是否在

936
00:33:40,650 --> 00:33:41,970
全局缓冲池是否

937
00:33:41,970 --> 00:33:43,799
是查询的私有缓冲池它

938
00:33:43,799 --> 00:33:50,250
取决于实现他的问题同样

939
00:33:50,250 --> 00:33:51,780
是我不需要我不需要将

940
00:33:51,780 --> 00:33:53,880
磁盘中的页面带入

941
00:33:53,880 --> 00:34:00,450
Amira 的所有缓冲池中的该查询是的

942
00:34:00,450 --> 00:34:02,640
我正在像这样写数据，这个家伙，

943
00:34:02,640 --> 00:34:03,840
这是一个微不足道的表，因为

944
00:34:03,840 --> 00:34:06,059
平均值是一个定标器，让我们说

945
00:34:06,059 --> 00:34:07,609
这是你知道一些非常复杂的

946
00:34:07,609 --> 00:34:10,379
计算，因为我正在生成，因为我正在

947
00:34:10,379 --> 00:34:12,210
扫描这些数据我正在更新我的敌人

948
00:34:12,210 --> 00:34:15,210
结果我可能会溢出内存和那些

949
00:34:15,210 --> 00:34:16,800
被换出磁盘，所以我正在

950
00:34:16,800 --> 00:34:18,060
写入内存，然后他们会

951
00:34:18,060 --> 00:34:20,129
根据需要写出磁盘，

952
00:34:20,129 --> 00:34:22,830
但这不像我会为我的

953
00:34:22,830 --> 00:34:25,918
查询读取是的，它没有意义，因为

954
00:34:25,918 --> 00:34:27,300
你需要的任何东西都没有

955
00:34:27,300 --> 00:34:29,250
低级数据是你要

956
00:34:29,250 --> 00:34:30,690
放入缓冲池的页面，每个人都可以看到，

957
00:34:30,690 --> 00:34:32,280
所以这又是另一个

958
00:34:32,280 --> 00:34:33,830
好处，这是一个共享数据结构，

959
00:34:33,830 --> 00:34:39,030
所以它就像 q1 正在读取

960
00:34:39,030 --> 00:34:41,520
页面并放入缓冲区一样 池

961
00:34:41,520 --> 00:34:43,409
允许需要这些页面的任何其他线程

962
00:34:43,409 --> 00:34:45,440
继续阅读它

963
00:34:45,440 --> 00:34:48,060
引脚闩锁 只是

964
00:34:48,060 --> 00:34:49,469
告诉您不要将其换

965
00:34:49,469 --> 00:34:51,989
出磁盘的引脚 不会阻止

966
00:34:51,989 --> 00:34:52,889
其他人不会 在阅读的同时，

967
00:34:52,889 --> 00:34:55,230
你在那里有更高级别的东西，

968
00:34:55,230 --> 00:34:57,089
比如锁，它跟踪

969
00:34:57,089 --> 00:34:58,410
你被允许读写的页面

970
00:34:58,410 --> 00:34:59,820
或者你对

971
00:34:59,820 --> 00:35:01,710
数据库对象的了解这是画的

972
00:35:01,710 --> 00:35:03,690
间距说嘿我正在操作这个

973
00:35:03,690 --> 00:35:06,150
不要把它换掉，这样你的问题就没有了

974
00:35:06,150 --> 00:35:07,500


975
00:35:07,500 --> 00:35:10,830
好的，所以还有另一个很好的例子

976
00:35:10,830 --> 00:35:12,330
，关系模型有什么很棒的，

977
00:35:12,330 --> 00:35:14,400
因为关系模型是

978
00:35:14,400 --> 00:35:18,840
无序的，就像它不喜欢我

979
00:35:18,840 --> 00:35:21,390
实际上可以让 Q 从任何地方开始

980
00:35:21,390 --> 00:35:24,720
进行某些查询，而我

981
00:35:24,720 --> 00:35:26,849
要产生的答案可能与

982
00:35:26,849 --> 00:35:29,190
基于 当我执行它但它仍然

983
00:35:29,190 --> 00:35:32,310
被认为是正确的所以如果我改变这个

984
00:35:32,310 --> 00:35:34,710
查询来计算平均值并且我

985
00:35:34,710 --> 00:35:36,780
将它限制为一百意味着我只

986
00:35:36,780 --> 00:35:38,450
希望我成为 100 元组的平均值

987
00:35:38,450 --> 00:35:41,310
它没有指定我只能我

988
00:35:41,310 --> 00:35:42,390
必须查看前一百个

989
00:35:42,390 --> 00:35:45,480
元组，所以我可以从第三页开始，并

990
00:35:45,480 --> 00:35:48,060
在此光标上共享我的扫描，

991
00:35:48,060 --> 00:35:49,740
然后查看

992
00:35:49,740 --> 00:35:51,119
前三页中的前一百个元组，

993
00:35:51,119 --> 00:35:52,980
然后这足以让我

994
00:35:52,980 --> 00:35:56,190
计算结果，如果我 从

995
00:35:56,190 --> 00:35:57,240
现在开始我实际上可能会得到

996
00:35:57,240 --> 00:35:58,560
不同的结果，但根据

997
00:35:58,560 --> 00:36:02,490
关系模型仍然很好，

998
00:36:02,490 --> 00:36:10,349
因为数据库是无序的，是的，所以他很

999
00:36:10,349 --> 00:36:12,240
完美，所以他说如果我们愿意，它是否仍然

1000
00:36:12,240 --> 00:36:14,369
有效 不是让

1001
00:36:14,369 --> 00:36:15,619
光标说好的让我们去看看

1002
00:36:15,619 --> 00:36:17,910
我的调度是开始获取他们

1003
00:36:17,910 --> 00:36:19,050
我该怎么做检查缓冲池并

1004
00:36:19,050 --> 00:36:20,339
找出实际内存并

1005
00:36:20,339 --> 00:36:22,080
计算聚合或这个

1006
00:36:22,080 --> 00:36:23,790
特定查询，其中

1007
00:36:23,790 --> 00:36:26,490
绝对是内存 最聪明的

1008
00:36:26,490 --> 00:36:31,440
系统可以做到这一点没关系

1009
00:36:31,440 --> 00:36:31,770


1010
00:36:31,770 --> 00:36:34,380
只要我看到

1011
00:36:34,380 --> 00:36:35,910
一百个元组就可以在内存中写入然后这个查询

1012
00:36:35,910 --> 00:36:39,030
现在仍然正确这是我不知道

1013
00:36:39,030 --> 00:36:41,990
你不想写这个但

1014
00:36:41,990 --> 00:36:48,089
它是的 它仍然有效，

1015
00:36:48,089 --> 00:36:49,349
我们将讨论的最后一个优化

1016
00:36:49,349 --> 00:36:52,950
是缓冲池旁路，所以这种

1017
00:36:52,950 --> 00:36:54,359
与他之前的问题相关的问题

1018
00:36:54,359 --> 00:36:57,780
类似于中间结果内存，但

1019
00:36:57,780 --> 00:36:59,609
假设我有一些查询，我们正在

1020
00:36:59,609 --> 00:37:03,570
执行结构扫描和 I

1021
00:37:03,570 --> 00:37:04,980
不想支付必须

1022
00:37:04,980 --> 00:37:07,440
在页表中查找并查看我的

1023
00:37:07,440 --> 00:37:10,020
缓冲池以找出

1024
00:37:10,020 --> 00:37:11,099
我正在查找的页面是否在内存中的惩罚

1025
00:37:11,099 --> 00:37:12,690
而且我也不想

1026
00:37:12,690 --> 00:37:14,369
污染缓存 它 可能正在读取一些

1027
00:37:14,369 --> 00:37:16,260
我在不久的将来不需要的数据，

1028
00:37:16,260 --> 00:37:20,970
因此缓冲池

1029
00:37:20,970 --> 00:37:21,720
绕过

1030
00:37:21,720 --> 00:37:23,640
现金绕过取决于什么系统它

1031
00:37:23,640 --> 00:37:26,280
的想法是您分配

1032
00:37:26,280 --> 00:37:29,280
少量内存到您的

1033
00:37:29,280 --> 00:37:32,130
查询运行的线程 然后当它

1034
00:37:32,130 --> 00:37:34,380
从磁盘读取页面时，如果它

1035
00:37:34,380 --> 00:37:35,520
不在缓冲池中，它必须转到 DISA

1036
00:37:35,520 --> 00:37:37,260
来获取它，而不是将它放入

1037
00:37:37,260 --> 00:37:39,180
缓冲池中，它只是将它放在其本地

1038
00:37:39,180 --> 00:37:40,440
内存中，然后当查询完成

1039
00:37:40,440 --> 00:37:42,300
所有这些 只是被扔掉然后

1040
00:37:42,300 --> 00:37:45,750
扔掉，然后你再做一次，

1041
00:37:45,750 --> 00:37:46,800
因为你想避免

1042
00:37:46,800 --> 00:37:48,180
去病人那里的开销，我们会的，

1043
00:37:48,180 --> 00:37:49,740
它是一个哈希表，它有锁存器它

1044
00:37:49,740 --> 00:37:51,510
不是它不是它不是超级昂贵

1045
00:37:51,510 --> 00:37:54,960
但它不是免费的它是 不便宜所以

1046
00:37:54,960 --> 00:37:56,730
在最大中这些被称为光扫描但

1047
00:37:56,730 --> 00:37:58,109
几乎每个主要的

1048
00:37:58,109 --> 00:38:00,810
数据库系统都支持这样的东西

1049
00:38:00,810 --> 00:38:01,920
我不知道我不知道

1050
00:38:01,920 --> 00:38:03,510
我的续集八是否我认为五

1051
00:38:03,510 --> 00:38:07,440
点七不支持然后 再一次，如果你

1052
00:38:07,440 --> 00:38:08,940
认识 你知道只有

1053
00:38:08,940 --> 00:38:10,200
当你知道

1054
00:38:10,200 --> 00:38:11,700
亲密的结果或者你正在扫描的他们的东西

1055
00:38:11,700 --> 00:38:15,390
不是很大的时候，你才真正想要这样做 如果你正在做

1056
00:38:15,390 --> 00:38:16,470
一种你知道

1057
00:38:16,470 --> 00:38:18,240
TB 级内存的事情，那么你想要

1058
00:38:18,240 --> 00:38:19,410
回来 缓冲池，因为那

1059
00:38:19,410 --> 00:38:23,000
东西可以根据需要支付到磁盘上

1060
00:38:23,000 --> 00:38:24,990
好吧 最后

1061
00:38:24,990 --> 00:38:28,500
要理解的还有

1062
00:38:28,500 --> 00:38:30,119
数据库系统下面实际

1063
00:38:30,119 --> 00:38:33,570
发生的事情 当我们从明显的页面中读取页面时发生的事情

1064
00:38:33,570 --> 00:38:34,680
以及实际执行的操作

1065
00:38:34,680 --> 00:38:37,080
是什么 所以再次我们所有的磁盘

1066
00:38:37,080 --> 00:38:38,099
操作都将通过

1067
00:38:38,099 --> 00:38:40,740
最低级别的 OS API，

1068
00:38:40,740 --> 00:38:44,609
它们中的每一个都吓坏了你知道我们

1069
00:38:44,609 --> 00:38:45,930
不会自己访问所有磁盘

1070
00:38:45,930 --> 00:38:47,609
，因为我们现在正在

1071
00:38:47,609 --> 00:38:50,010
通过操作系统 默认情况下

1072
00:38:50,010 --> 00:38:51,420
，操作系统

1073
00:38:51,420 --> 00:38:53,160
将为文件系统维护自己的单独缓存，

1074
00:38:53,160 --> 00:38:55,470
这称为操作系统

1075
00:38:55,470 --> 00:38:58,500
页面缓存，这意味着当

1076
00:38:58,500 --> 00:39:01,320
我从磁盘读取页面时，操作系统将

1077
00:39:01,320 --> 00:39:03,180
在他的文件中保留它的大写副本  系统

1078
00:39:03,180 --> 00:39:04,859
缓存或操作系统页面缓存，然后我将

1079
00:39:04,859 --> 00:39:06,570
在我的缓冲池中拥有另一个副本，

1080
00:39:06,570 --> 00:39:11,160
因此大多数数据库系统都

1081
00:39:11,160 --> 00:39:12,839
不想这样做，希望您这样做，不，

1082
00:39:12,839 --> 00:39:14,849
操作系统不这样做，因此当

1083
00:39:14,849 --> 00:39:17,010
您打开传递的文件时 在 POSIX 标志中，

1084
00:39:17,010 --> 00:39:20,609
哦直接或直接 IO，您

1085
00:39:20,609 --> 00:39:23,220
的操作系统不会自行执行任何缓存操作，

1086
00:39:23,220 --> 00:39:26,190
并且您几乎每天都在自行管理内存中的内容，

1087
00:39:26,190 --> 00:39:27,839


1088
00:39:27,839 --> 00:39:29,280
当您阅读手册时，

1089
00:39:29,280 --> 00:39:31,230
他们会告诉您 确定您

1090
00:39:31,230 --> 00:39:34,440
实际上可以在唯一的

1091
00:39:34,440 --> 00:39:35,550
数据库系统上打开

1092
00:39:35,550 --> 00:39:38,850
它，据您所知，

1093
00:39:38,850 --> 00:39:40,230
唯一依赖

1094
00:39:40,230 --> 00:39:43,650
其他页面缓存的主要数据发送是 Postgres，所以

1095
00:39:43,650 --> 00:39:45,380
他们说这样做的原因是因为

1096
00:39:45,380 --> 00:39:48,480
他们声称来自工程

1097
00:39:48,480 --> 00:39:50,670
从观点来看，这是

1098
00:39:50,670 --> 00:39:53,250
他们必须管理的少一点额外的集水区 他们

1099
00:39:53,250 --> 00:39:54,480
仍然有自己的缓冲池，但它

1100
00:39:54,480 --> 00:39:55,950
不会那么大 它不会

1101
00:39:55,950 --> 00:39:57,990
像我的

1102
00:39:57,990 --> 00:40:01,710
续集或 Oracle 那样使用系统上的所有内存 但让

1103
00:40:01,710 --> 00:40:02,730
OSD 有一些附加 管理

1104
00:40:02,730 --> 00:40:04,260
本身，所以从工程的

1105
00:40:04,260 --> 00:40:06,030
角度来看，他们

1106
00:40:06,030 --> 00:40:07,650
实际维护那

1107
00:40:07,650 --> 00:40:09,780
部分系统的开销更少，依赖这一点会造成轻微的

1108
00:40:09,780 --> 00:40:11,670
性能损失

1109
00:40:11,670 --> 00:40:14,960
，我们稍后会看到，所以我

1110
00:40:14,960 --> 00:40:19,170
喜欢使用 Postgres 进行演示，因为

1111
00:40:19,170 --> 00:40:20,910
这几乎就像一个数据库系统的教科书模仿

1112
00:40:20,910 --> 00:40:22,920
，你实际上

1113
00:40:22,920 --> 00:40:27,360
暴露了很多

1114
00:40:27,360 --> 00:40:28,410
我们正在谈论的重要概念，非常

1115
00:40:28,410 --> 00:40:33,210
容易

1116
00:40:33,210 --> 00:40:37,110


1117
00:40:37,110 --> 00:40:45,930
我在那些

1118
00:40:45,930 --> 00:40:47,940
笔记本电脑上打字 因为在表面上打字很痛苦

1119
00:40:47,940 --> 00:40:54,440
我讨厌键盘 好吧

1120
00:40:54,710 --> 00:40:56,670
所以这正在运行 这只是运行

1121
00:40:56,670 --> 00:40:58,280
H top 它是 top 的更好版本

1122
00:40:58,280 --> 00:41:00,870
我想要关注

1123
00:41:00,870 --> 00:41:05,070
的是 你应该把内存塞在

1124
00:41:05,070 --> 00:41:07,920
这里 所以绿色条告诉

1125
00:41:07,920 --> 00:41:09,480
你在这台机器上运行的进程的常驻集大小是多少

1126
00:41:09,480 --> 00:41:11,670


1127
00:41:11,670 --> 00:41:14,580
这是他们现在看到的内存

1128
00:41:14,580 --> 00:41:16,620
这里的橙色条

1129
00:41:16,620 --> 00:41:20,610
是 t 文件系统页面缓存是

1130
00:41:20,610 --> 00:41:21,780
操作系统的页面缓存，所以

1131
00:41:21,780 --> 00:41:23,220
再次作为在这台机器上运行的任何进程，

1132
00:41:23,220 --> 00:41:26,760
如果

1133
00:41:26,760 --> 00:41:28,560
他们不使用直接 I/O

1134
00:41:28,560 --> 00:41:33,750
读取，如果他们从文件中读取页面，操作系统也

1135
00:41:33,750 --> 00:41:37,050
将缓存 它也是如此，所以我们可以

1136
00:41:37,050 --> 00:41:39,360
把这一切都吹走，所以它在 Linux 上运行，

1137
00:41:39,360 --> 00:41:41,510
所以在 Linux 中，我们可以做一个

1138
00:41:41,510 --> 00:41:44,569
[音乐]

1139
00:41:45,309 --> 00:41:53,029
这不是哦对不起，所以我们可以运行

1140
00:41:53,029 --> 00:41:59,059
这个命令，我们基本上是被动的

1141
00:41:59,059 --> 00:42:02,119
，我们使操作系统发臭，FASTA 一些缓存

1142
00:42:02,119 --> 00:42:04,490
我们将这个标志 3 传递到

1143
00:42:04,490 --> 00:42:07,009
proc 文件系统中，以允许我们强制

1144
00:42:07,009 --> 00:42:11,089
执行相反的操作来刷新我们的页面缓存，所以

1145
00:42:11,089 --> 00:42:13,609
现在如果我们回去查看 H top 现在

1146
00:42:13,609 --> 00:42:15,950
我们看到内存总量

1147
00:42:15,950 --> 00:42:17,240
超过了购买使用但机器运行了

1148
00:42:17,240 --> 00:42:19,730
减少到 3 场演出，所以之前有 32 场演出

1149
00:42:19,730 --> 00:42:21,470
，但现在减少到 3 场演出，

1150
00:42:21,470 --> 00:42:23,210
所以我们完全清除了文件系统缓存，

1151
00:42:23,210 --> 00:42:28,519
所以现在让我们开始吧，让我们去

1152
00:42:28,519 --> 00:42:31,849
启动 Postgres，但我想做的第一件事

1153
00:42:31,849 --> 00:42:35,750
是重新启动它，所以通过

1154
00:42:35,750 --> 00:42:36,829
重新启动它我们会吹走

1155
00:42:36,829 --> 00:42:45,980
它是它的 b  uffer pool 好吧，

1156
00:42:45,980 --> 00:42:48,890
现在提出这个，然后重新连接

1157
00:42:48,890 --> 00:42:51,859
我们是内部的和计时的，然后我们将

1158
00:42:51,859 --> 00:42:56,150
关闭并行线程，所以我们

1159
00:42:56,150 --> 00:42:58,549
将使用同一张表，我向

1160
00:42:58,549 --> 00:43:01,250
他们展示了上一堂课的一千万个条目

1161
00:43:01,250 --> 00:43:04,640
小数，所以我们可以运行这个

1162
00:43:04,640 --> 00:43:07,279
查询，现在我要做的是我

1163
00:43:07,279 --> 00:43:09,349
要再次使用解释，但我要

1164
00:43:09,349 --> 00:43:11,480
传递和分析两个标志分析和

1165
00:43:11,480 --> 00:43:13,910
缓冲区，所以再次分析将

1166
00:43:13,910 --> 00:43:15,230
实际运行查询，并向你展示

1167
00:43:15,230 --> 00:43:16,700
查询计划发生了什么这个

1168
00:43:16,700 --> 00:43:19,009
缓冲区标志将告诉您

1169
00:43:19,009 --> 00:43:21,289
它从磁盘读取了多少数据

1170
00:43:21,289 --> 00:43:23,210
它正在读取的页面

1171
00:43:23,210 --> 00:43:25,369
百分比对磁盘上的缓冲池进行评级

1172
00:43:25,369 --> 00:43:27,319
，因此因为我们炸毁了文件

1173
00:43:27,319 --> 00:43:29,150
系统缓存，我们炸毁了缓冲区

1174
00:43:29,150 --> 00:43:30,230
池因为我们重新启动了数据库

1175
00:43:30,230 --> 00:43:33,410
系统它应该命中应该

1176
00:43:33,410 --> 00:43:36,859
为零，你看到它说

1177
00:43:36,859 --> 00:43:38,450
对于缓冲池它必须读取

1178
00:43:38,450 --> 00:43:40,759
四百四四四到四

1179
00:43:40,759 --> 00:43:44,599
十八页它必须从磁盘读取表

1180
00:43:44,599 --> 00:43:47,420
并且它 花了一千三

1181
00:43:47,420 --> 00:43:49,700
百米 illiseconds 一分三秒 所以

1182
00:43:49,700 --> 00:43:52,410
如果我现在再次运行相同的查询，

1183
00:43:52,410 --> 00:43:55,380
你会看到它说命中是 32，

1184
00:43:55,380 --> 00:43:59,430
所以它能够读取 32

1185
00:43:59,430 --> 00:44:02,009
个已经在 puffer 池中的页面，

1186
00:44:02,009 --> 00:44:03,619
然后其余的它一直在收获磁盘

1187
00:44:03,619 --> 00:44:05,789
，原因是 为什么我不是所有的

1188
00:44:05,789 --> 00:44:09,180
页面是因为 Postgres 维护一个

1189
00:44:09,180 --> 00:44:11,549
缓冲池，每个查询都有一个小的缓冲池

1190
00:44:11,549 --> 00:44:15,779
环，它是 32 页，所以对于

1191
00:44:15,779 --> 00:44:17,220
这个，它被允许

1192
00:44:17,220 --> 00:44:18,660
从上次运行时读取 30 页我

1193
00:44:18,660 --> 00:44:22,710
再次运行它应该 去感谢 64 yes

1194
00:44:22,710 --> 00:44:24,329
所以当我再次执行查询时它的大小一直在增长，

1195
00:44:24,329 --> 00:44:25,589


1196
00:44:25,589 --> 00:44:28,019
因为它认识到哦

1197
00:44:28,019 --> 00:44:30,960
我需要的数据是它不是我的缓冲

1198
00:44:30,960 --> 00:44:33,329
池让我增加它的缓存的大小

1199
00:44:33,329 --> 00:44:36,799
好吧那么现在怎么办 我们可以做的是，

1200
00:44:36,799 --> 00:44:40,740
我们可以强制数据库系统将

1201
00:44:40,740 --> 00:44:44,190
所有内容都放入内存中，因此

1202
00:44:44,190 --> 00:44:46,049


1203
00:44:46,049 --> 00:44:47,730
当您安装它时，默认情况下它们具有 Postgres 的这个扩展，

1204
00:44:47,730 --> 00:44:50,640
称为 PGwarm，所有这

1205
00:44:50,640 --> 00:44:52,740
一切都是我们在调用

1206
00:44:52,740 --> 00:44:55,259
数据系统说嘿 去把

1207
00:44:55,259 --> 00:44:57,930
这个表的所有页面

1208
00:44:57,930 --> 00:45:00,930
带到一个缓冲池，然后告诉

1209
00:45:00,930 --> 00:45:02,940
你我运行了我这样做了，我读了

1210
00:45:02,940 --> 00:45:05,190
四十四万四千二四

1211
00:45:05,190 --> 00:45:05,849
十八页

1212
00:45:05,849 --> 00:45:07,650
记得我第一次运行查询

1213
00:45:07,650 --> 00:45:10,349
时它说 不得不从磁盘上读取

1214
00:45:10,349 --> 00:45:11,789
4428 页

1215
00:45:11,789 --> 00:45:13,710
因为它让

1216
00:45:13,710 --> 00:45:15,390
你知道这就是这张表的页数

1217
00:45:15,390 --> 00:45:17,480


1218
00:45:17,480 --> 00:45:19,380
他说还有六页已经

1219
00:45:19,380 --> 00:45:21,089
在那里 所以这就像强制

1220
00:45:21,089 --> 00:45:23,250
阅读所有内容 我认为那些 64

1221
00:45:23,250 --> 00:45:27,900
页可能 是的，我认为它

1222
00:45:27,900 --> 00:45:29,609
不会查看内存中的内容，它

1223
00:45:29,609 --> 00:45:31,440
只是说我会得到所有东西，因为

1224
00:45:31,440 --> 00:45:32,579
如果我再做一次，它应该给

1225
00:45:32,579 --> 00:45:35,119
我相同的数字是的，

1226
00:45:35,119 --> 00:45:39,690
所以现在如果我去跑步

1227
00:45:39,690 --> 00:45:45,690
再次查询我做得更好一些

1228
00:45:45,690 --> 00:45:49,559


1229
00:45:49,559 --> 00:45:52,049
我需要的1616000页我需要在

1230
00:45:52,049 --> 00:45:54,660
内存中所以我命中了它在

1231
00:45:54,660 --> 00:45:56,190
缓冲池中命中但我开始读取

1232
00:45:56,190 --> 00:46:01,430
一些磁盘然后我们猜测为什么

1233
00:46:01,910 --> 00:46:07,140
是的，他是无线的 de 仍然将所有内容加载

1234
00:46:07,140 --> 00:46:13,140
到缓冲池中取决于缓冲池的大小

1235
00:46:13,140 --> 00:46:15,330
，因此我们可以

1236
00:46:15,330 --> 00:46:16,950
在 Postgres 中执行此操作，因此 Postgres 有一个

1237
00:46:16,950 --> 00:46:22,890
称为共享缓冲区的标志，它告诉

1238
00:46:22,890 --> 00:46:24,660
我它当前设置为 128 兆字节，

1239
00:46:24,660 --> 00:46:29,670
但大小约为 4 对于 4 到

1240
00:46:29,670 --> 00:46:33,030
8 所以选择你可以使用给我你我会

1241
00:46:33,030 --> 00:46:34,530
更新你可以将它们用作计算器

1242
00:46:34,530 --> 00:46:47,300
所以 4 到 8 乘以 8 除以 1024

1243
00:46:47,300 --> 00:46:51,110
大约给出兆字节所以

1244
00:46:51,110 --> 00:46:54,840
我正在阅读的表的大小是 345 兆字节，所以

1245
00:46:54,840 --> 00:46:58,020
再次 共享缓冲区为 128，但我的

1246
00:46:58,020 --> 00:47:02,340
表大小为 345，因此理论上我可以转到

1247
00:47:02,340 --> 00:47:08,270
post rest 配置，因为

1248
00:47:09,020 --> 00:47:13,940
这是 post Chris 11，然后找到

1249
00:47:13,940 --> 00:47:18,230
该特定参数，你看

1250
00:47:18,230 --> 00:47:23,630
它是 128 兆字节，所以让我将其设置

1251
00:47:23,630 --> 00:47:27,320
为 慷慨让我们说 360

1252
00:47:27,320 --> 00:47:30,600
兆字节现在我们将重新启动

1253
00:47:30,600 --> 00:47:36,150
Postgres 我们将从操作系统中删除我们的文件

1254
00:47:36,150 --> 00:47:37,530
系统缓存因为

1255
00:47:37,530 --> 00:47:39,540
当我们实际上再次读取该页面时

1256
00:47:39,540 --> 00:47:43,380
我们返回到 H 停止它我的意思是

1257
00:47:43,380 --> 00:47:44,550
很难看到我们已经 有点

1258
00:47:44,550 --> 00:47:46,800
大了嗯李 如果你看到那里有一个

1259
00:47:46,800 --> 00:47:48,750
酒吧，因为

1260
00:47:48,750 --> 00:47:51,750
那是我们正在阅读的桌子，所以

1261
00:47:51,750 --> 00:47:53,790
让我去吹掉文件系统

1262
00:47:53,790 --> 00:47:58,380
缓存，现在回到草地上我

1263
00:47:58,380 --> 00:48:04,800
需要重新连接打开定时

1264
00:48:04,800 --> 00:48:06,990
设置为这个 并行线程

1265
00:48:06,990 --> 00:48:11,570
检查共享缓冲区现在是

1266
00:48:12,060 --> 00:48:16,430
哦，我是个白痴，对吧抱歉

1267
00:48:16,430 --> 00:48:20,850
服务器 10 Klein 11 太多联合主演

1268
00:48:20,850 --> 00:48:23,730
安装抱歉所以回到这里

1269
00:48:23,730 --> 00:48:36,230
是关于 1:28 我说的关于 360

1270
00:48:37,790 --> 00:48:44,570
现在我们开始 Postgres go 回到这里

1271
00:48:44,570 --> 00:48:48,000
重新连接 360 好的

1272
00:48:48,000 --> 00:48:52,910
打开定时打开并行线程

1273
00:48:52,910 --> 00:48:57,840
预热我们得到了它四四二八

1274
00:48:57,840 --> 00:49:00,000
四二四八页现在我

1275
00:49:00,000 --> 00:49:05,880
再次运行该查询现在我的头是

1276
00:49:05,880 --> 00:49:08,880
四四到四十所以我给了它 一个

1277
00:49:08,880 --> 00:49:11,010
系统 适量的内存 我预取

1278
00:49:11,010 --> 00:49:12,450
和所有东西 现在一切都

1279
00:49:12,450 --> 00:49:14,250
在缓冲池中 我有我根本没有

1280
00:49:14,250 --> 00:49:15,270
为这个

1281
00:49:15,270 --> 00:49:17,310
特定查询使用这样的磁盘 我每次查找每个

1282
00:49:17,310 --> 00:49:19,020
页面并且我需要访问我要去

1283
00:49:19,020 --> 00:49:20,340
在那个页表中

1284
00:49:20,340 --> 00:49:22,140
查找并找到 将页面引用

1285
00:49:22,140 --> 00:49:24,210
放在一个框架中，但这里的所有内容都在内存中

1286
00:49:24,210 --> 00:49:29,100
，所以我们如何证明

1287
00:49:29,100 --> 00:49:30,510
Postgres 正在使用的数据库系统

1288
00:49:30,510 --> 00:49:32,670
依赖于文件系统缓存，所以

1289
00:49:32,670 --> 00:49:34,320
让我们关闭这里只解释所有内容

1290
00:49:34,320 --> 00:49:36,180
，让我们看看它实际需要多长时间

1291
00:49:36,180 --> 00:49:38,730
实际上，第

1292
00:49:38,730 --> 00:49:43,110
一次是 12 点 50 分，然后他们变

1293
00:49:43,110 --> 00:49:48,240
快了一点，然后是 7 点 33 分，

1294
00:49:48,240 --> 00:49:49,260
所以我花了大约 700

1295
00:49:49,260 --> 00:49:53,390
毫秒，所以我们可以做的是

1296
00:49:53,390 --> 00:49:56,640
重新启动 Postgres

1297
00:49:56,640 --> 00:49:58,510
[音乐]

1298
00:49:58,510 --> 00:50:02,500
，然后这会吹走缓冲池

1299
00:50:02,500 --> 00:50:07,520
， 现在，如果我回来并重新

1300
00:50:07,520 --> 00:50:11,510
连接 Postgres，我认为我需要是的，所以

1301
00:50:11,510 --> 00:50:14,900
现在我现在重新连接我睡了一个

1302
00:50:14,900 --> 00:50:15,890
很好的打开定时

1303
00:50:15,890 --> 00:50:20,150
关闭并行线程我运行

1304
00:50:20,150 --> 00:50:22,760
相同的查询之前，当一切

1305
00:50:22,760 --> 00:50:24,920
都在磁盘上时我 认为它花了一分

1306
00:50:24,920 --> 00:50:27,590
三秒所以这一点然后

1307
00:50:27,590 --> 00:50:29,119
所有东西都在缓冲池中花

1308
00:50:29,119 --> 00:50:30,920
了七百毫秒所以这个

1309
00:50:30,920 --> 00:50:34,100
应该是大约一点点

1310
00:50:34,100 --> 00:50:35,810
时间很抱歉破坏

1311
00:50:35,810 --> 00:50:40,390
了演示他妈的所以去 返回 我返回本次

1312
00:50:40,390 --> 00:50:47,200
重启 本次返回本次重新连接的

1313
00:50:47,200 --> 00:50:51,830
时间是在是的 是的 是的 我知道

1314
00:50:51,830 --> 00:50:52,780


1315
00:50:52,780 --> 00:50:56,000
并行线程再次关闭

1316
00:50:56,000 --> 00:50:58,070
所以我要运行这个

1317
00:50:58,070 --> 00:50:59,780


1318
00:50:59,780 --> 00:51:01,520
查询 操作系统

1319
00:51:01,520 --> 00:51:03,650
仍然有它的文件系统缓存，所以

1320
00:51:03,650 --> 00:51:05,390
现在我运行这个查询，我们将有

1321
00:51:05,390 --> 00:51:09,140
一堆缓冲池未命中，因为

1322
00:51:09,140 --> 00:51:11,240
内存中没有任何东西，但它仍然

1323
00:51:11,240 --> 00:51:15,650
不会花费全部时间 正确花费

1324
00:51:15,650 --> 00:51:17,480
800 毫秒而不是 1.3

1325
00:51:17,480 --> 00:51:20,240
秒 因为如果我再次运行它，它需要的数据

1326
00:51:20,240 --> 00:51:22,220
在文件系统缓存中

1327
00:51:22,220 --> 00:51:24,440
我现在应该得到 700

1328
00:51:24,440 --> 00:51:27,520
毫秒 不

1329
00:51:28,560 --> 00:51:33,260
，让我们去看看发生了什么

1330
00:51:38,480 --> 00:51:44,660
仍然从磁盘读取日期 为什么那么

1331
00:51:46,220 --> 00:51:51,480
好 它仍然运行得很快，即使

1332
00:51:51,480 --> 00:51:53,400
我认为那个时候 那是因为那个时间

1333
00:51:53,400 --> 00:51:54,390
较慢，因为我认为它正在运行

1334
00:51:54,390 --> 00:51:59,760
解释分析它会慢慢变快，

1335
00:51:59,760 --> 00:52:01,050
因为它为该查询增加了缓存大小

1336
00:52:01,050 --> 00:52:03,240
我认为我认为这是一个

1337
00:52:03,240 --> 00:52:04,710
查询缓存而不是全局 我的

1338
00:52:04,710 --> 00:52:05,940
事情但是我们展示的主要内容

1339
00:52:05,940 --> 00:52:06,900
是我们必须给它

1340
00:52:06,900 --> 00:52:08,550
足够的内存并将所有内容

1341
00:52:08,550 --> 00:52:11,040
放入我们的缓冲池然后我们

1342
00:52:11,040 --> 00:52:13,560
能够获得全速

1343
00:52:13,560 --> 00:52:22,980
性能开始问题是预运行两次

1344
00:52:22,980 --> 00:52:27,150
我的意思是哦

1345
00:52:27,150 --> 00:52:30,330
关于美国现金问题的文件系统缓存

1346
00:52:30,330 --> 00:52:55,620
是的 是的 是的 所以我第一次这样

1347
00:52:55,620 --> 00:52:58,500
做 缓冲池大小是 120

1348
00:52:58,500 --> 00:53:01,290
兆字节 表大小是 345

1349
00:53:01,290 --> 00:53:07,230
兆字节 这不是我

1350
00:53:07,230 --> 00:53:15,480
必须在读取中添加查找的原因 从

1351
00:53:15,480 --> 00:53:19,590
一开始就从磁盘开始，嗯，我们没有

1352
00:53:19,590 --> 00:53:21,780
花所有的时间，男孩，这

1353
00:53:21,780 --> 00:53:25,680
是演练，所以让我们这样做

1354
00:53:25,680 --> 00:53:28,650
回去，我们将吹走文件

1355
00:53:28,650 --> 00:53:31,440
系统缓存重新启动 Postgres 你知道

1356
00:53:31,440 --> 00:53:36,660
现在我们去看看并在我们的 我的意思

1357
00:53:36,660 --> 00:53:37,830
是那个栏不是一个微不足道的

1358
00:53:37,830 --> 00:53:41,010
潜在建议草，就像系统

1359
00:53:41,010 --> 00:53:42,150
上正在运行其他东西一样，

1360
00:53:42,150 --> 00:53:42,510


1361
00:53:42,510 --> 00:53:44,609
但我吹走了虚假的 ISM 现金我已经

1362
00:53:44,609 --> 00:53:45,990
重新启动了 Postgres 现在

1363
00:53:45,990 --> 00:53:47,760
内存中没有任何东西所以我回到

1364
00:53:47,760 --> 00:53:50,850
你需要的 Postgres  econnect 关闭苍白的

1365
00:53:50,850 --> 00:53:54,630
线程，所以如果我

1366
00:53:54,630 --> 00:54:02,550
现在第一次运行查询，很好

1367
00:54:02,550 --> 00:54:05,220
，内存中没有任何内容，我必须读取 44,000

1368
00:54:05,220 --> 00:54:05,670
页，

1369
00:54:05,670 --> 00:54:12,510
所以预期预热会

1370
00:54:12,510 --> 00:54:13,650
告诉数据库系统去读取

1371
00:54:13,650 --> 00:54:15,119
磁盘上的所有内容，以便将表

1372
00:54:15,119 --> 00:54:20,940
大脑发送给我 缓冲池全部 44,000

1373
00:54:20,940 --> 00:54:29,520
页是的，我可以再次执行此操作，它

1374
00:54:29,520 --> 00:54:31,290
现在读取了 44,000 页，现在我运行相同的

1375
00:54:31,290 --> 00:54:36,960
查询，现在我的命中正好是 44,000

1376
00:54:36,960 --> 00:54:39,420
次，这意味着它被命中了我

1377
00:54:39,420 --> 00:54:40,680
正在寻找的东西在缓冲池中找到了

1378
00:54:40,680 --> 00:54:43,470
所以 我强迫当天没有把

1379
00:54:43,470 --> 00:54:46,350
所有东西都带回到内存中，

1380
00:54:46,350 --> 00:54:48,030
第一个例子我只有

1381
00:54:48,030 --> 00:54:49,470
120 兆字节，所以我不能把

1382
00:54:49,470 --> 00:55:07,380
所有东西都放在

1383
00:55:07,380 --> 00:55:09,330


1384
00:55:09,330 --> 00:55:11,520
上面 唯一

1385
00:55:11,520 --> 00:55:13,950
可以为您服务的系统

1386
00:55:13,950 --> 00:55:16,619
唯一依赖于操作系统页面缓存的主要系统 为什么

1387
00:55:16,619 --> 00:55:18,990
其他人都做得不好，

1388
00:55:18,990 --> 00:55:21,600
因为现在我可能会有两个副本或

1389
00:55:21,600 --> 00:55:24,570
每个页面，这样我就可以

1390
00:55:24,570 --> 00:55:27,030
在操作系统页面中拥有一个页面 缓存然后

1391
00:55:27,030 --> 00:55:28,320
我 将在我的缓冲池中有该页面的副本，

1392
00:55:28,320 --> 00:55:30,380
因为现在如果我修改

1393
00:55:30,380 --> 00:55:32,940
该页面，它不再是精确的副本

1394
00:55:32,940 --> 00:55:35,490
，所以操作系统有旧的，我

1395
00:55:35,490 --> 00:55:37,619
有新的，所以它是冗余

1396
00:55:37,619 --> 00:55:39,000
数据，所以你更有效

1397
00:55:39,000 --> 00:55:41,040
如果你自己管理所有的

1398
00:55:41,040 --> 00:55:46,950
东西，而且你

1399
00:55:46,950 --> 00:55:49,560
知道在不同的数据库系统中我的

1400
00:55:49,560 --> 00:55:51,869
意思是大多数它现在不支持 Linux，

1401
00:55:51,869 --> 00:55:53,260


1402
00:55:53,260 --> 00:55:55,359
但是就像他们必须

1403
00:55:55,359 --> 00:55:57,940
支持 Windows BSD 所有这些不同的

1404
00:55:57,940 --> 00:55:59,470
操作系统的主要操作系统一样 操作系统页面

1405
00:55:59,470 --> 00:56:00,430
缓存可能具有不同的性能

1406
00:56:00,430 --> 00:56:02,109
影响或不同的策略，

1407
00:56:02,109 --> 00:56:04,240
因此为了保证

1408
00:56:04,240 --> 00:56:06,430
跨不同操作系统的一致性能或一致行为，

1409
00:56:06,430 --> 00:56:09,840
您只需自己管理所有内容，

1410
00:56:09,840 --> 00:56:15,100
这是一个很好的问题，是的，有页面数，

1411
00:56:15,100 --> 00:56:19,240
但同样如此，就像我发布为 8

1412
00:56:19,240 --> 00:56:21,760
KB 的页面一样，我采用这个数字

1413
00:56:21,760 --> 00:56:24,310
乘以 8 除以 1024 告诉我

1414
00:56:24,310 --> 00:56:26,800
它们是兆字节的麦克风我的东西我将

1415
00:56:26,800 --> 00:56:28,359
缓冲池大小设置为该大小

1416
00:56:28,359 --> 00:56:32,490
并且可以保证一切都适合

1417
00:56:33,690 --> 00:56:36,490
co 我们的问题是缓冲

1418
00:56:36,490 --> 00:56:39,570
池如何再次与操作系统页面缓存交互

1419
00:56:39,570 --> 00:56:50,050
，就像这些问题

1420
00:56:50,050 --> 00:56:51,550
就像有不同的选择如何

1421
00:56:51,550 --> 00:56:53,400
使用

1422
00:56:53,400 --> 00:56:56,980
它一样，所以它对程序透明，

1423
00:56:56,980 --> 00:57:00,369
就像我调用 read every go

1424
00:57:00,369 --> 00:57:03,280
从 from 中读取一个页面 如果操作系统

1425
00:57:03,280 --> 00:57:05,020
有一个页面缓存为我提供该

1426
00:57:05,020 --> 00:57:06,520
页面，则它会消失，

1427
00:57:06,520 --> 00:57:09,220
如果

1428
00:57:09,220 --> 00:57:12,220
我通过该标志直接 i/o

1429
00:57:12,220 --> 00:57:13,930
告诉选项系统不捕获任何东西

1430
00:57:13,930 --> 00:57:15,580
，它总是会去，这对我来说是透明的。 磁盘并

1431
00:57:15,580 --> 00:57:20,740
获取它是完全可以的，因为操作系统页面

1432
00:57:20,740 --> 00:57:22,960
缓存位于磁盘类型

1433
00:57:22,960 --> 00:57:24,130
和数据库中的数据之间，

1434
00:57:24,130 --> 00:57:26,109
绝对是的，

1435
00:57:26,109 --> 00:57:28,270
如果

1436
00:57:28,270 --> 00:57:29,920
您像编写 C 一样调用它，那么当我们开始写入时它也很重要 你调用

1437
00:57:29,920 --> 00:57:32,410
F write 的程序是我

1438
00:57:32,410 --> 00:57:33,369
实际上要立即写的操作

1439
00:57:33,369 --> 00:57:35,859
没有把它放在页面缓存中

1440
00:57:35,859 --> 00:57:37,359
稍后磁盘计划说

1441
00:57:37,359 --> 00:57:38,890
好的 我要去写这个它

1442
00:57:38,890 --> 00:57:40,690
只是我的 我称之为 s  Inc 什么时候

1443
00:57:40,690 --> 00:57:42,340
是什么时候 已写，但如果我想

1444
00:57:42,340 --> 00:57:43,510
完全控制我如何准备好

1445
00:57:43,510 --> 00:57:44,770
所有的磁盘我想使用

1446
00:57:44,770 --> 00:57:47,170
直接 I/O 和大多数数据库系统这样做

1447
00:57:47,170 --> 00:57:50,550


1448
00:57:51,400 --> 00:57:54,140
是的，所有的 t-80

1449
00:57:54,140 --> 00:57:57,590
和 v60 并进入这本书

1450
00:57:57,590 --> 00:57:59,810
发生在第一个 1 点 28 分，我们会

1451
00:57:59,810 --> 00:58:01,940
被覆盖，你做了多少，先生，

1452
00:58:01,940 --> 00:58:04,820
你清楚地被击中了，但很多时候

1453
00:58:04,820 --> 00:58:06,560
你从一开始就开始查询，

1454
00:58:06,560 --> 00:58:10,190
所以你应该得到它，因为

1455
00:58:10,190 --> 00:58:14,960
内存存在是后来的 128m 让我们

1456
00:58:14,960 --> 00:58:16,850
将通过项目的事情，

1457
00:58:16,850 --> 00:58:18,680
但让我来谈谈它，

1458
00:58:18,680 --> 00:58:21,770
所以没关系，所以

1459
00:58:21,770 --> 00:58:23,240
现在快速谈论的是

1460
00:58:23,240 --> 00:58:26,600
缓冲区放置策略，所以我们再次

1461
00:58:26,600 --> 00:58:29,000
讨论了如何正确地找到

1462
00:58:29,000 --> 00:58:30,530
我们想要的页面基于 页 ID

1463
00:58:30,530 --> 00:58:32,810
和页表，但现在你知道我所有的

1464
00:58:32,810 --> 00:58:34,490
例子我们有足够的内存

1465
00:58:34,490 --> 00:58:36,320
，所以现在我们想谈谈

1466
00:58:36,320 --> 00:58:37,910
如果我需要引入一个页面会发生

1467
00:58:37,910 --> 00:58:39,710
什么，但我没有空间放它我该怎么办 这样

1468
00:58:39,710 --> 00:58:41,780
做的事情是关心和

1469
00:58:41,780 --> 00:58:43,400
更换政策是 o 显然

1470
00:58:43,400 --> 00:58:45,320
正确性是正确的 我们不想写出

1471
00:58:45,320 --> 00:58:47,480


1472
00:58:47,480 --> 00:58:48,770
某人在实际完成之前固定的数据或大数据

1473
00:58:48,770 --> 00:58:50,540
我们会关心准确性，

1474
00:58:50,540 --> 00:58:52,010
因为我们将确保我们的

1475
00:58:52,010 --> 00:58:53,990
Vic 页面非常 将来不太可能

1476
00:58:53,990 --> 00:58:55,520
使用，所以我们最大限度地减少

1477
00:58:55,520 --> 00:58:57,650
了磁盘搜索的数量，我们希望将

1478
00:58:57,650 --> 00:58:59,300
某些策略过快，因为我们

1479
00:58:59,300 --> 00:59:01,040
不知道，因为我们

1480
00:59:01,040 --> 00:59:03,440
正在页表中查找或持有闩锁，而我们

1481
00:59:03,440 --> 00:59:05,060
不知道” 不想运行一些 MD 完整

1482
00:59:05,060 --> 00:59:06,500
算法来找出

1483
00:59:06,500 --> 00:59:08,600
正确驱逐的页面，因为这可能

1484
00:59:08,600 --> 00:59:09,830
比实际读取页面花费的时间更长

1485
00:59:09,830 --> 00:59:11,750
，当然显然我们不希望

1486
00:59:11,750 --> 00:59:13,460
有很多元数据开销

1487
00:59:13,460 --> 00:59:14,870
来跟踪和所有这些

1488
00:59:14,870 --> 00:59:16,430
我们不希望有页面元数据的额外数据

1489
00:59:16,430 --> 00:59:18,920
跟踪

1490
00:59:18,920 --> 00:59:21,500
它被使用的可能性大于

1491
00:59:21,500 --> 00:59:24,440
页面本身的可能性 所以这些替换

1492
00:59:24,440 --> 00:59:25,850
策略再次作为另一个很好的

1493
00:59:25,850 --> 00:59:28,670
例子来区分高端

1494
00:59:28,670 --> 00:59:30,830
非常昂贵的企业 e 数据库

1495
00:59:30,830 --> 00:59:33,380
和开源人员 因为

1496
00:59:33,380 --> 00:59:35,650
高端数据库有非常复杂的

1497
00:59:35,650 --> 00:59:37,910
替换策略 他们跟踪

1498
00:59:37,910 --> 00:59:39,470
页面如何使用的统计信息

1499
00:59:39,470 --> 00:59:41,090
他们试图从

1500
00:59:41,090 --> 00:59:43,700
查询实际执行的操作中推断出来并尝试

1501
00:59:43,700 --> 00:59:45,980
做出最佳决策，而

1502
00:59:45,980 --> 00:59:49,040
在 开源人员和较新的

1503
00:59:49,040 --> 00:59:50,810
系统并没有说它们不好，但他们

1504
00:59:50,810 --> 00:59:52,310
不知道几

1505
00:59:52,310 --> 00:59:54,530
十年来花费数百万美元试图使这个

1506
00:59:54,530 --> 00:59:56,480
东西尽可能快地运行，所以

1507
00:59:56,480 --> 00:59:57,740
你知道他们会做一些更

1508
00:59:57,740 --> 00:59:59,630
简单的事情 我们要

1509
00:59:59,630 --> 01:00:02,030
在这里谈论的就像是

1510
01:00:02,030 --> 01:00:03,680
CS 中最古老的问题之一，就像

1511
01:00:03,680 --> 01:00:06,950
多年来他们叔叔的每个人都有一篇

1512
01:00:06,950 --> 01:00:08,630
关于如何进行缓存之

1513
01:00:08,630 --> 01:00:10,569
类的论文，我有这样的权利，就像这样

1514
01:00:10,569 --> 01:00:12,530


1515
01:00:12,530 --> 01:00:14,869
在计算机科学中最古老的问题中，这方面有很长的

1516
01:00:14,869 --> 01:00:18,050
历史，所以最简单的

1517
01:00:18,050 --> 01:00:19,339
技术使用和几乎

1518
01:00:19,339 --> 01:00:21,170
每个人第一次使用的都是 LRU 或

1519
01:00:21,170 --> 01:00:23,960
至少最近使用过，所以我们在这里所做的

1520
01:00:23,960 --> 01:00:26,109
只是保留 跟踪

1521
01:00:26,109 --> 01:00:28,700
上次访问页面的时间的时间戳，

1522
01:00:28,700 --> 01:00:30,140
然后我们必须找出

1523
01:00:30,140 --> 01:00:32,000
您将要驱逐的页面，我们只需要查看

1524
01:00:32,000 --> 01:00:33,980
哪个页面具有那么旧的时间戳

1525
01:00:33,980 --> 01:00:35,630
，这就是我们继续并

1526
01:00:35,630 --> 01:00:38,420
删除的那个 加快速度的方法而不是

1527
01:00:38,420 --> 01:00:41,030
只跟踪一个你知道

1528
01:00:41,030 --> 01:00:42,829
她的页面的时间戳，因为然后我们必须

1529
01:00:42,829 --> 01:00:43,970
对

1530
01:00:43,970 --> 01:00:45,170
缓冲池中的所有页面进行特殊扫描，以确定

1531
01:00:45,170 --> 01:00:47,000
哪个具有最低的时间戳，我们

1532
01:00:47,000 --> 01:00:48,200
可以只维护一个单独的 数据

1533
01:00:48,200 --> 01:00:50,599
结构就像一个队列，

1534
01:00:50,599 --> 01:00:53,750
按他们的时间戳排序，所以

1535
01:00:53,750 --> 01:00:55,359
每当有人读取和写入页面时，

1536
01:00:55,359 --> 01:00:57,950
我们只需将其从队列中拉出并将

1537
01:00:57,950 --> 01:00:59,210
其放回末尾，因为这是

1538
01:00:59,210 --> 01:01:02,359
先进先出的，你们将

1539
01:01:02,359 --> 01:01:04,280
拥有 在项目中实施的

1540
01:01:04,280 --> 01:01:06,319
是 LRU 的近似值，称为时钟

1541
01:01:06,319 --> 01:01:08,059
实际上是快速举手谁在

1542
01:01:08,059 --> 01:01:11,359
这里听过时钟之前没有人

1543
01:01:11,359 --> 01:01:13,099
真棒好酷所以我的意思是 LRU

1544
01:01:13,099 --> 01:01:13,819
Emily 应该知道对的

1545
01:01:13,819 --> 01:01:17,210
好所以时钟所以 LRU 是

1546
01:01:17,210 --> 01:01:19,579
最近的 y used clock 是一个

1547
01:01:19,579 --> 01:01:21,349
近似值，您

1548
01:01:21,349 --> 01:01:22,910
不必为每个页面精确跟踪时间戳

1549
01:01:22,910 --> 01:01:26,150
，因此

1550
01:01:26,150 --> 01:01:27,589
我们需要跟踪的唯一信息

1551
01:01:27,589 --> 01:01:29,450
是每页一个参考

1552
01:01:29,450 --> 01:01:31,970
位，它告诉您是否 该

1553
01:01:31,970 --> 01:01:34,460
页面自上次检查以来一直被访问

1554
01:01:34,460 --> 01:01:37,069
，因此您将

1555
01:01:37,069 --> 01:01:39,020
在像时钟一样的循环缓冲区中组织您的页面

1556
01:01:39,020 --> 01:01:40,730
，然后您有一个时钟指针，它会

1557
01:01:40,730 --> 01:01:42,319
四处走动并进行扫描并检查

1558
01:01:42,319 --> 01:01:44,030
该参考位是否设置为 1

1559
01:01:44,030 --> 01:01:46,099
或 0，如果它设置为 0，则您知道

1560
01:01:46,099 --> 01:01:47,420
自上次检查以来一直被访问

1561
01:01:47,420 --> 01:01:48,770
，因此可以将其

1562
01:01:48,770 --> 01:01:52,250
逐出，所以说我再次翻页 1

1563
01:01:52,250 --> 01:01:54,380
2 3 4，每个页面都有自己的

1564
01:01:54,380 --> 01:01:56,299
参考位 开始时

1565
01:01:56,299 --> 01:01:58,849
引用位被设置为 0 所以

1566
01:01:58,849 --> 01:02:02,000
假设一些查询访问了第 1 页，所以

1567
01:02:02,000 --> 01:02:02,930
我将继续将其

1568
01:02:02,930 --> 01:02:04,790
引用位翻转为 1，无论

1569
01:02:04,790 --> 01:02:06,710
有人访问此页面多少次，

1570
01:02:06,710 --> 01:02:09,049
它始终设置为 1，但不是 一个

1571
01:02:09,049 --> 01:02:12,530
计数器，所以现在我需要 Inv  icta 页面，

1572
01:02:12,530 --> 01:02:14,210
因为我没有更多空间，所以

1573
01:02:14,210 --> 01:02:15,559
我的时钟指针将启动第

1574
01:02:15,559 --> 01:02:17,570
一个我看到它的参考

1575
01:02:17,570 --> 01:02:19,970
设置了一个，因此它已被

1576
01:02:19,970 --> 01:02:21,410
访问，因此我不应该有

1577
01:02:21,410 --> 01:02:23,870
受害者，但现在我将其参考位

1578
01:02:23,870 --> 01:02:26,600
重置为零和 然后继续到

1579
01:02:26,600 --> 01:02:28,190
下一个，如果我回来设置零，我会四处扫荡

1580
01:02:28,190 --> 01:02:30,110
然后我

1581
01:02:30,110 --> 01:02:33,170
知道我可以驱逐它所以这里的这个人他的

1582
01:02:33,170 --> 01:02:34,940
位设置为零所以我们可以继续

1583
01:02:34,940 --> 01:02:37,280
并击败它 删除它并

1584
01:02:37,280 --> 01:02:41,150
用一个新页面替换它然后我们不将

1585
01:02:41,150 --> 01:02:42,830
它的引用设置为一个我们只是将它设置为零

1586
01:02:42,830 --> 01:02:45,650
然后移动到下一个所以

1587
01:02:45,650 --> 01:02:46,910
假设现在第三页和第四页已经

1588
01:02:46,910 --> 01:02:48,920
被访问所以我们检查重置它 到

1589
01:02:48,920 --> 01:02:50,900
零检查重置为零现在

1590
01:02:50,900 --> 01:02:52,040
我们回到页面第一

1591
01:02:52,040 --> 01:02:54,260
是我们检查其引用的第一个

1592
01:02:54,260 --> 01:02:55,850
自上次检查以来它为零

1593
01:02:55,850 --> 01:02:57,130
因此它可以再次被驱逐

1594
01:02:57,130 --> 01:02:59,060
所以这是一个

1595
01:02:59,060 --> 01:03:02,360
近似值的原因是因为 azzaman 受害者

1596
01:03:02,360 --> 01:03:04,940
页面我不是受害者，正是

1597
01:03:04,940 --> 01:03:06,500
那个 mos 至少最近

1598
01:03:06,500 --> 01:03:09,260
使用过它有点你知道它

1599
01:03:09,260 --> 01:03:11,570
在某个时间窗口内是相同的

1600
01:03:11,570 --> 01:03:13,490


1601
01:03:13,490 --> 01:03:17,180


1602
01:03:17,180 --> 01:03:19,190


1603
01:03:19,190 --> 01:03:21,440
那么它

1604
01:03:21,440 --> 01:03:22,910
可能不会在

1605
01:03:22,910 --> 01:03:25,280
不久的将来再次使用，因此

1606
01:03:25,280 --> 01:03:30,470
我可以继续正确地进行

1607
01:03:30,470 --> 01:03:32,900
一些假设，因此假设

1608
01:03:32,900 --> 01:03:34,580
对于简单的事情很有效，例如进行点

1609
01:03:34,580 --> 01:03:37,760
查询以访问单个事物，但

1610
01:03:37,760 --> 01:03:39,800
时钟和 LRU 是 容易受到

1611
01:03:39,800 --> 01:03:42,740
所谓的顺序泛滥的影响，这

1612
01:03:42,740 --> 01:03:44,600
意味着当我们进行特殊

1613
01:03:44,600 --> 01:03:46,160
扫描时会读取每

1614
01:03:46,160 --> 01:03:48,350
一个会污染我们的页面缓存的页面，

1615
01:03:48,350 --> 01:03:50,960
这最终会导致我们最终

1616
01:03:50,960 --> 01:03:52,910
可能会驱逐我们确实

1617
01:03:52,910 --> 01:03:56,930
想要的页面 参数使用非常正确，并且

1618
01:03:56,930 --> 01:03:58,790
在不久的将来，但是因为该扫描

1619
01:03:58,790 --> 01:04:00,380
读取了一堆页面，所有这些页面

1620
01:04:00,380 --> 01:04:04,100
都会有更新的时间戳，然后

1621
01:04:04,100 --> 01:04:06,590
在这种情况下我真正想要的页面是正确的

1622
01:04:06,590 --> 01:04:08,120
他最近的页面

1623
01:04:08,120 --> 01:04:10,940
使用页面实际上是我想要

1624
01:04:10,940 --> 01:04:14,360
驱逐的页面，而不是最近最少使用的页面，所以

1625
01:04:14,360 --> 01:04:15,620
还有另一个很好的例子，

1626
01:04:15,620 --> 01:04:16,880
如果您可以根据查询将如何访问它们而拥有不同的缓冲池、

1627
01:04:16,880 --> 01:04:18,470
不同的缓冲池或不同的

1628
01:04:18,470 --> 01:04:19,880
表，

1629
01:04:19,880 --> 01:04:22,130
可能是一个 我想

1630
01:04:22,130 --> 01:04:23,390
在另一个中使用最近使用过的我想

1631
01:04:23,390 --> 01:04:25,940
使用最近最少使用的所以让我们看一个

1632
01:04:25,940 --> 01:04:28,490
例子 假设我有一个

1633
01:04:28,490 --> 01:04:30,350
查询正在进行点查找，其中

1634
01:04:30,350 --> 01:04:31,490
a 等于

1635
01:04:31,490 --> 01:04:34,040
我们的 ID 等于 1 并且它读取第

1636
01:04:34,040 --> 01:04:36,290
0 页所以去 提前并将其提取到我的

1637
01:04:36,290 --> 01:04:38,840
缓冲池中，我很好，

1638
01:04:38,840 --> 01:04:39,980
所以现在有另一个查询将进行

1639
01:04:39,980 --> 01:04:41,500
中央扫描，因此它会翻遍

1640
01:04:41,500 --> 01:04:45,200
我所有的页面，如果再次我们，他们想要

1641
01:04:45,200 --> 01:04:46,910
一次并为第三页腾出空间

1642
01:04:46,910 --> 01:04:49,930
' 重新使用最近最少使用

1643
01:04:49,930 --> 01:04:52,190
然后它会发现哦第

1644
01:04:52,190 --> 01:04:53,720
零页是最近最少使用的让我

1645
01:04:53,720 --> 01:04:55,970
继续并驱逐它并放入

1646
01:04:55,970 --> 01:04:59,630
第三页但在我的工作负载中我正在执行

1647
01:04:59,630 --> 01:05:01,369
看起来像第一个的查询

1648
01:05:01,369 --> 01:05:03,560
一遍又一遍 阿加 所以现在如果

1649
01:05:03,560 --> 01:05:04,520
我再次执行这个查询

1650
01:05:04,520 --> 01:05:07,970
现在我偿还了零我只是驱逐了它

1651
01:05:07,970 --> 01:05:09,260
现在我搞砸了因为现在我必须

1652
01:05:09,260 --> 01:05:12,530
出去磁盘并让它好起来所以我

1653
01:05:12,530 --> 01:05:13,700
真正想做的就是

1654
01:05:13,700 --> 01:05:15,890
驱逐一个 一两个因为这个扫描

1655
01:05:15,890 --> 01:05:17,510
会通过阅读更多的

1656
01:05:17,510 --> 01:05:19,580
数据并且不太可能其他人

1657
01:05:19,580 --> 01:05:22,840
会来这里阅读这个东西

1658
01:05:23,770 --> 01:05:27,800
所以有三种方法可以

1659
01:05:27,800 --> 01:05:30,290
解决这个问题让我稍微介绍

1660
01:05:30,290 --> 01:05:33,740
一下到目前为止的一些 首先是做

1661
01:05:33,740 --> 01:05:36,590
它被称为 LRU K，其中 K 只是你

1662
01:05:36,590 --> 01:05:38,510
跟踪一个数字，每次访问这个页面时

1663
01:05:38,510 --> 01:05:39,950
多个时间戳的次数，

1664
01:05:39,950 --> 01:05:41,990


1665
01:05:41,990 --> 01:05:44,060
所以现在当你想说

1666
01:05:44,060 --> 01:05:45,380
我应该删除哪个时

1667
01:05:45,380 --> 01:05:46,280
不要看哪个

1668
01:05:46,280 --> 01:05:48,380
时间最短，Stan 你去看看

1669
01:05:48,380 --> 01:05:50,450
这些时间戳之间的间隔，然后

1670
01:05:50,450 --> 01:05:53,180
你说哪个

1671
01:05:53,180 --> 01:05:54,920
在一次访问和下一次访问之间有很长的时间

1672
01:05:54,920 --> 01:05:57,109
，然后可以用它来

1673
01:05:57,109 --> 01:05:59,119
找出哪个是 最不可能被

1674
01:05:59,119 --> 01:06:03,650
使用，所以 t 这是因为我们正在使用

1675
01:06:03,650 --> 01:06:05,390
历史来估计何时可以

1676
01:06:05,390 --> 01:06:06,920
再次访问它，以帮助我们

1677
01:06:06,920 --> 01:06:08,450
更好地决定哪些页面应该

1678
01:06:08,450 --> 01:06:08,960
被驱逐，

1679
01:06:08,960 --> 01:06:15,080
所以 LRU K 是在

1680
01:06:15,080 --> 01:06:16,400
更复杂的广告说我们会

1681
01:06:16,400 --> 01:06:18,680
做类似的事情时使用的 这个我不知道我认为

1682
01:06:18,680 --> 01:06:20,510
我的续集可能会使用这个我不记得我不

1683
01:06:20,510 --> 01:06:23,869
记得我们可以做的下一个优化

1684
01:06:23,869 --> 01:06:24,740
我们已经

1685
01:06:24,740 --> 01:06:28,369
讨论过有多个缓冲

1686
01:06:28,369 --> 01:06:30,109
池是有本地化和每个

1687
01:06:30,109 --> 01:06:33,410
查询所以 而不是让你知道，

1688
01:06:33,410 --> 01:06:34,880
因为我正在滑行并将其

1689
01:06:34,880 --> 01:06:36,650
放入全局缓冲池，如果我

1690
01:06:36,650 --> 01:06:39,320
在缓冲池中留出一些页面，这些页面在

1691
01:06:39,320 --> 01:06:40,570


1692
01:06:40,570 --> 01:06:45,019
读取它们之前是接受的，但它是

1693
01:06:45,019 --> 01:06:46,669
我正在跟踪 我是如何使用页面的

1694
01:06:46,669 --> 01:06:49,609
，然后当我想

1695
01:06:49,609 --> 01:06:51,979
决定从我的查询中驱逐什么时，我

1696
01:06:51,979 --> 01:06:54,559
驱逐了最近最少使用的那些，而

1697
01:06:54,559 --> 01:06:58,429
不是全局视图，所以我们

1698
01:06:58,429 --> 01:07:00,439
在 Postgres Perez 中看到了这个命中

1699
01:07:00,439 --> 01:07:02,299
内存显示 命中是 32 然后

1700
01:07:02,299 --> 01:07:04,309
是 64 对 这就是这个小的

1701
01:07:04,309 --> 01:07:05,599
环形缓冲区，他们

1702
01:07:05,599 --> 01:07:07,609
跟踪查询

1703
01:07:07,609 --> 01:07:09,469
访问的页面他们做出决定什么

1704
01:07:09,469 --> 01:07:13,159
要驱逐什么最后一个是查看

1705
01:07:13,159 --> 01:07:15,469
优先级提示再次这是我们

1706
01:07:15,469 --> 01:07:16,759
之前讨论过的地方，当我们有

1707
01:07:16,759 --> 01:07:18,169
我们知道的索引时 他们如何扫描

1708
01:07:18,169 --> 01:07:20,689
数据 知道哪些页面有不同的访问权限，因此

1709
01:07:20,689 --> 01:07:22,249
我们可以使用该信息来

1710
01:07:22,249 --> 01:07:24,619
做出关于什么的决定 -

1711
01:07:24,619 --> 01:07:26,989
假设我们有我们的 B 加树或

1712
01:07:26,989 --> 01:07:28,669
我们想要的任何树数据结构，并且他们

1713
01:07:28,669 --> 01:07:29,569
有一堆查询他们' 重新

1714
01:07:29,569 --> 01:07:31,549
插入数据，在

1715
01:07:31,549 --> 01:07:32,869
该表有全局计数器的地方，或者只是将其

1716
01:07:32,869 --> 01:07:34,609
递增一并

1717
01:07:34,609 --> 01:07:36,829
像序列键或自动递增键一样一遍又一遍地插入，

1718
01:07:36,829 --> 01:07:39,619
因此如果我们现在

1719
01:07:39,619 --> 01:07:41,929
在此索引上排序，则根据 ID

1720
01:07:41,929 --> 01:07:44,509
从 min 到 max 排序 我们知道，

1721
01:07:44,509 --> 01:07:47,269
每次我们插入时，ID 值

1722
01:07:47,269 --> 01:07:48,679
总是会比

1723
01:07:48,679 --> 01:07:50,689
我们刚刚插入的最后一个多 1，这意味着

1724
01:07:50,689 --> 01:07:52,159
我们总是会

1725
01:07:52,159 --> 01:07:53,749
沿着树的右侧向下触摸

1726
01:07:53,749 --> 01:07:56,389
这些页面 所以因此我们应该对

1727
01:07:56,389 --> 01:07:57,619
我们将管理的缓冲区进行提示，

1728
01:07:57,619 --> 01:07:59,509
并说这些页面应该尝试

1729
01:07:59,509 --> 01:08:01,579
留在内存中

1730
01:08:01,579 --> 01:08:04,489


1731
01:08:04,489 --> 01:08:05,989


1732
01:08:05,989 --> 01:08:09,709
不同的 ID 或实际上

1733
01:08:09,709 --> 01:08:10,759
任何对该索引进行查找的查询

1734
01:08:10,759 --> 01:08:12,799
我知道我总是会

1735
01:08:12,799 --> 01:08:13,969
通过蓝页 因为那是

1736
01:08:13,969 --> 01:08:15,739
我输入该索引的方式 我必须通过

1737
01:08:15,739 --> 01:08:17,118
它 所以我想确保

1738
01:08:17,118 --> 01:08:18,710
它总是被固定

1739
01:08:18,710 --> 01:08:20,630
总是留在那里的记忆，因为

1740
01:08:20,630 --> 01:08:22,639
否则，如果我到达

1741
01:08:22,639 --> 01:08:24,469
底部并且我需要空间并且我 Vic 这

1742
01:08:24,469 --> 01:08:26,809
东西这是一个坏主意，因为我看起来

1743
01:08:26,809 --> 01:08:28,368
这是最近最少使用的，但我

1744
01:08:28,368 --> 01:08:29,509
知道下一个查询会

1745
01:08:29,509 --> 01:08:30,920
通过 它并转到该

1746
01:08:30,920 --> 01:08:33,649
页面，所以这也是

1747
01:08:33,649 --> 01:08:35,269
商业系统可以为您提供的

1748
01:08:35,269 --> 01:08:39,488
一些额外信息上面

1749
01:08:39,488 --> 01:08:42,319
的最后一件事要讨论的是

1750
01:08:42,319 --> 01:08:46,399
我们如何实际处理脏页面以便

1751
01:08:46,399 --> 01:08:47,839
成员有一个脏位和pa  ge

1752
01:08:47,839 --> 01:08:50,779
表示查询

1753
01:08:50,779 --> 01:08:52,609
自上次

1754
01:08:52,609 --> 01:08:55,460


1755
01:08:55,460 --> 01:08:57,948
进入缓冲池以来是否修改

1756
01:08:57,948 --> 01:08:58,880


1757
01:08:58,880 --> 01:09:00,620
了

1758
01:09:00,620 --> 01:09:04,010
该页面的内容 只需

1759
01:09:04,010 --> 01:09:06,170
找到一个未标记为脏的页面，

1760
01:09:06,170 --> 01:09:08,680
然后立即将其删除，

1761
01:09:08,680 --> 01:09:11,300
您就知道将其框架用于新的缓冲

1762
01:09:11,300 --> 01:09:14,689
池，我们要做的较慢的事情是，

1763
01:09:14,689 --> 01:09:16,819
如果页面脏了，我们必须

1764
01:09:16,819 --> 01:09:20,330
先将其安全地写回磁盘 我们可以

1765
01:09:20,330 --> 01:09:22,090
为我们的新页面重用该空间，

1766
01:09:22,090 --> 01:09:24,410
所以现在我们必须进行权衡

1767
01:09:24,410 --> 01:09:26,000
，我们的替换策略

1768
01:09:26,000 --> 01:09:28,220
很好地决定有一堆页面

1769
01:09:28,220 --> 01:09:30,170
都是干净的，我可以

1770
01:09:30,170 --> 01:09:32,180
非常轻松地丢弃它们，但实际上它们 可能

1771
01:09:32,180 --> 01:09:35,540
在不久的将来需要，所以我

1772
01:09:35,540 --> 01:09:36,740
不想实际删除它们，而是我

1773
01:09:36,740 --> 01:09:38,060
想支付罚款写出一个

1774
01:09:38,060 --> 01:09:40,670
脏页刷新它从我的

1775
01:09:40,670 --> 01:09:43,250
缓冲池中删除它并重用它的空间，所以

1776
01:09:43,250 --> 01:09:45,260
你实际上如何平衡它们是 超级

1777
01:09:45,260 --> 01:09:48,620
难对，因为 在这种情况下

1778
01:09:48,620 --> 01:09:50,569
，如果我必须写出一个脏页，我会在这里进行磁盘读取，

1779
01:09:50,569 --> 01:09:52,970
这是到磁盘 i/os 的一个

1780
01:09:52,970 --> 01:09:54,770
IO 来写出脏页，然后

1781
01:09:54,770 --> 01:09:56,000
从缓冲池中删除它，然后

1782
01:09:56,000 --> 01:09:57,560
另一个 IO 来读取一个页面 我想在

1783
01:09:57,560 --> 01:10:00,380
这种情况下，这是一个 IO 只是

1784
01:10:00,380 --> 01:10:01,670
去阅读我想要的页面，因为我可以

1785
01:10:01,670 --> 01:10:03,050
删除已经在缓冲池中的页面，

1786
01:10:03,050 --> 01:10:05,360
所以你如何

1787
01:10:05,360 --> 01:10:07,160
再次真正弄清楚它是非常困难的，这

1788
01:10:07,160 --> 01:10:08,480
就是商业系统 我的

1789
01:10:08,480 --> 01:10:09,890
意见比开源

1790
01:10:09,890 --> 01:10:13,430
的做得更好，因此可以解决

1791
01:10:13,430 --> 01:10:16,280
这个问题，以避免在缓冲池中

1792
01:10:16,280 --> 01:10:17,750
的可用空间需要它时必须立即写出页面的问题

1793
01:10:17,750 --> 01:10:19,490
我可以

1794
01:10:19,490 --> 01:10:22,310
定期进行后台写入

1795
01:10:22,310 --> 01:10:23,420
数据 系统会有一个线程，他们

1796
01:10:23,420 --> 01:10:25,100
会查看我的缓冲池，

1797
01:10:25,100 --> 01:10:27,170
找出哪些页面被标记为脏，然后

1798
01:10:27,170 --> 01:10:30,560
将它们写到磁盘，这样我就可以

1799
01:10:30,560 --> 01:10:32,060
翻转它们以标记它是干净的，

1800
01:10:32,060 --> 01:10:34,070
现在当我从我的替换策略中

1801
01:10:34,070 --> 01:10:36,260
做 滑动要删除的页面 我有

1802
01:10:36,260 --> 01:10:38,090
一堆干净的 页面我可以我可以立即

1803
01:10:38,090 --> 01:10:41,510
删除所以当你这样做时你必须小心，

1804
01:10:41,510 --> 01:10:43,100
因为你不想

1805
01:10:43,100 --> 01:10:44,780
在对应于它们的记录法则之前写出脏页面

1806
01:10:44,780 --> 01:10:47,320
来

1807
01:10:47,320 --> 01:10:49,940
修改它们以使它们变脏你

1808
01:10:49,940 --> 01:10:51,020
知道确保它们' 在你写出脏页之前，法律是

1809
01:10:51,020 --> 01:10:52,220
习惯地先写到磁盘上的，

1810
01:10:52,220 --> 01:10:54,230
我们将在本学期晚些时候

1811
01:10:54,230 --> 01:10:55,490
进行整场讲座，说明为什么会出现这种情况

1812
01:10:55,490 --> 01:10:57,500
，但要知道

1813
01:10:57,500 --> 01:10:58,820
这不仅仅是因为我可以

1814
01:10:58,820 --> 01:11:01,010
盲目地写任何页我 希望我必须

1815
01:11:01,010 --> 01:11:02,360
做一些 Etra 步骤保护以

1816
01:11:02,360 --> 01:11:03,440
确保我以正确的

1817
01:11:03,440 --> 01:11:05,570
顺序写东西这是 n mapkit

1818
01:11:05,570 --> 01:11:09,140
不能做的所有事情所以我要跳过

1819
01:11:09,140 --> 01:11:11,510
这个其他记忆帖子只是

1820
01:11:11,510 --> 01:11:12,890
我们已经有点 涵盖了这一点

1821
01:11:12,890 --> 01:11:14,660
它不仅仅是

1822
01:11:14,660 --> 01:11:17,330
表或索引中的页面 当我们运行

1823
01:11:17,330 --> 01:11:19,220
查询时，我们还

1824
01:11:19,220 --> 01:11:22,160


1825
01:11:22,160 --> 01:11:26,450


1826
01:11:26,450 --> 01:11:27,770


1827
01:11:27,770 --> 01:11:30,110
需要生成一些信息 因为

1828
01:11:30,110 --> 01:11:31,280
我们知道 现在库尔兹在做什么我们

1829
01:11:31,280 --> 01:11:32,480
知道页面中的内容我们知道如何

1830
01:11:32,480 --> 01:11:33,920
访问事物并且我们可以做出

1831
01:11:33,920 --> 01:11:36,080
更好的决定并且本质上我们

1832
01:11:36,080 --> 01:11:37,910
将使用有关查询中的信息的信息，

1833
01:11:37,910 --> 01:11:39,770
以便您了解

1834
01:11:39,770 --> 01:11:40,670
我们讨论过的所有这些不同的事情

1835
01:11:40,670 --> 01:11:42,200
以及 我们可以应用一系列优化

1836
01:11:42,200 --> 01:11:44,810
来帮助我们更好地完成这项工作，

1837
01:11:44,810 --> 01:11:47,950
所以关于缓冲池的任何问题

1838
01:11:48,040 --> 01:11:49,760
都在这里，这就是您真正关心的

1839
01:11:49,760 --> 01:11:54,140
项目，所以对于

1840
01:11:54,140 --> 01:11:55,670
第一个项目，您是我构建

1841
01:11:55,670 --> 01:11:57,770
自己的缓冲池管理器和 替换

1842
01:11:57,770 --> 01:12:00,950
策略，所以这一切都将在我们

1843
01:12:00,950 --> 01:12:03,010
称为 bust hub 的新数据库系统中完成，

1844
01:12:03,010 --> 01:12:05,780
它是一个开源系统，

1845
01:12:05,780 --> 01:12:08,060
它再次基于磁盘，您将看到这

1846
01:12:08,060 --> 01:12:10,700
将是代码中的存根文件，您

1847
01:12:10,700 --> 01:12:12,230
将从 github 下载然后

1848
01:12:12,230 --> 01:12:13,910
清楚地显示这里的 函数需要

1849
01:12:13,910 --> 01:12:15,170
编写，这里是

1850
01:12:15,170 --> 01:12:16,730
您如何知道如何实现我们

1851
01:12:16,730 --> 01:12:19,400
要求您执行的操作，因此该项目

1852
01:12:19,400 --> 01:12:20,510
是在线编写的，

1853
01:12:20,510 --> 01:12:22,550
尚未设置大范围

1854
01:12:22,550 --> 01:12:23,900
我们今天晚些时候会做，但如果你能

1855
01:12:23,900 --> 01:12:25,850
在一天内完成这个项目，请

1856
01:12:25,850 --> 01:12:28,220
来找我，因为我们不想

1857
01:12:28,220 --> 01:12:30,409
做其他事情，

1858
01:12:30,409 --> 01:12:32,780
所以我们已经为你提供了

1859
01:12:32,780 --> 01:12:34,580
经理和页面布局，

1860
01:12:34,580 --> 01:12:36,530
所以你 不用担心，您

1861
01:12:36,530 --> 01:12:38,889
只会给您一个页面块一个块一个页面

1862
01:12:38,889 --> 01:12:40,940
，由您决定如何

1863
01:12:40,940 --> 01:12:43,040
将它们存储在内存中，然后

1864
01:12:43,040 --> 01:12:44,659
调用磁盘管理器

1865
01:12:44,659 --> 01:12:48,290
根据需要将它们写出，因此对于我们拥有的第一个页面

1866
01:12:48,290 --> 01:12:49,760
一个名为时钟替换器的单独类

1867
01:12:49,760 --> 01:12:52,340
，您将再次实现

1868
01:12:52,340 --> 01:12:53,900
我今天在这里讨论的时钟策略，

1869
01:12:53,900 --> 01:12:56,659
它是 LRU 的近似值，

1870
01:12:56,659 --> 01:12:59,300
我们只需扫一扫并翻转

1871
01:12:59,300 --> 01:13:01,699
这些参考引用位，这

1872
01:13:01,699 --> 01:13:04,429
意味着您需要跟踪页面

1873
01:13:04,429 --> 01:13:05,630
的位置 被访问是因为您将

1874
01:13:05,630 --> 01:13:07,940
在缓冲点 API 中看到这一点，您必须

1875
01:13:07,940 --> 01:13:09,620
知道，当我说读取页面或

1876
01:13:09,620 --> 01:13:12,620
写入页面时，您将更新

1877
01:13:12,620 --> 01:13:14,330
LRU 内部的参考位，替换

1878
01:13:14,330 --> 01:13:17,840
或抱歉您的时钟或布局器，所以只有一

1879
01:13:17,840 --> 01:13:19,730
件事 很重要 知道的是，如果

1880
01:13:19,730 --> 01:13:23,420
您进行扫描并且所有页面

1881
01:13:23,420 --> 01:13:27,590
都已修改，那么您只需

1882
01:13:27,590 --> 01:13:29,420
选择具有最低框架 ID

1883
01:13:29,420 --> 01:13:31,159
的任何页面，或者所有页面中的任何页面都是固定的并且您无法

1884
01:13:31,159 --> 01:13:32,690
释放一个，那么您可以在

1885
01:13:32,690 --> 01:13:34,639
最低的页面 ID 上选择它们 因为否则

1886
01:13:34,639 --> 01:13:37,250
你会永远旋转，这将

1887
01:13:37,250 --> 01:13:40,130
在写作中主要工作将

1888
01:13:40,130 --> 01:13:41,719
在缓冲管理器上进行，因此您的

1889
01:13:41,719 --> 01:13:43,280
元素时钟首先替换您的算法

1890
01:13:43,280 --> 01:13:45,530
，然后将其连接到您的

1891
01:13:45,530 --> 01:13:47,540
缓冲池管理器中，对于这个，

1892
01:13:47,540 --> 01:13:48,860
它是 再次由您决定

1893
01:13:48,860 --> 01:13:50,150
您实际上想要如何维护您的

1894
01:13:50,150 --> 01:13:52,219
内存 如何决定

1895
01:13:52,219 --> 01:13:53,389
您想要跟踪哪些内部数据结构

1896
01:13:53,389 --> 01:13:55,040
哪些页面可用 哪些页面

1897
01:13:55,040 --> 01:13:58,370
是脏的 哪些页面被

1898
01:13:58,370 --> 01:14:00,170
正确固定 您可以为所欲为

1899
01:14:00,170 --> 01:14:00,530


1900
01:14:00,530 --> 01:14:02,150
只是你必须实现

1901
01:14:02,150 --> 01:14:05,449
我们公开给你的 API 所以这

1902
01:14:05,449 --> 01:14:06,949
意味着每年总是欺骗学生的事情

1903
01:14:06,949 --> 01:14:08,300
是确保你正确地

1904
01:14:08,300 --> 01:14:10,010
获得

1905
01:14:10,010 --> 01:14:12,860
如何正确固定页面的操作顺序，所以我们会

1906
01:14:12,860 --> 01:14:14,929
做多线程分级测试将

1907
01:14:14,929 --> 01:14:16,550
尝试同时读取页面和引脚，

1908
01:14:16,550 --> 01:14:18,350
您将确保一切

1909
01:14:18,350 --> 01:14:20,389
都按正确的顺序进行，

1910
01:14:20,389 --> 01:14:21,800
当您查看文章

1911
01:14:21,800 --> 01:14:22,969
并了解我们的内容时，这一点会更加清晰” 再次要求您

1912
01:14:22,969 --> 01:14:26,420
这样做，您如何开始？再次，

1913
01:14:26,420 --> 01:14:27,949
所有内容都可以在 github 上找到，

1914
01:14:27,949 --> 01:14:29,780
如果您不原谅它，请访问您

1915
01:14:29,780 --> 01:14:31,670
的 github 帐户 注册一个它是

1916
01:14:31,670 --> 01:14:33,110
免费的 还有我

1917
01:14:33,110 --> 01:14:36,560
认为您可以获得额外的教育 东西，但

1918
01:14:36,560 --> 01:14:37,850
基本上你会去数据库系统的 github 页面

1919
01:14:37,850 --> 01:14:39,980
，

1920
01:14:39,980 --> 01:14:41,210
可能是一个小分叉按钮，你

1921
01:14:41,210 --> 01:14:43,760
把它分叉到你的私人仓库 fokin

1922
01:14:43,760 --> 01:14:44,210
是你自己的

1923
01:14:44,210 --> 01:14:46,270
市场是私人的，所以没有什么是公开的

1924
01:14:46,270 --> 01:14:48,830
，然后就做你所有的

1925
01:14:48,830 --> 01:14:50,360
如果您注册 github

1926
01:14:50,360 --> 01:14:54,080
帐户，您可以在那里进行更改，您可以获得免费的私有分叉存储

1927
01:14:54,080 --> 01:14:55,910
库，因为如果您将

1928
01:14:55,910 --> 01:14:57,050
所有内容都公开，其他学生

1929
01:14:57,050 --> 01:14:58,070
就可以看到您在做什么，然后

1930
01:14:58,070 --> 01:15:02,150
可能会从您那里复制

1931
01:15:02,150 --> 01:15:03,260
您应该尝试做的第一件事

1932
01:15:03,260 --> 01:15:04,640
今天或者明天 尽快成为超级

1933
01:15:04,640 --> 01:15:07,400
有用的尝试让软件构建

1934
01:15:07,400 --> 01:15:08,930
在您要

1935
01:15:08,930 --> 01:15:11,330
进行开发的任何机器上，以便它可以在

1936
01:15:11,330 --> 01:15:14,330
Ubuntu上运行它可以在OSX上运行它可以在

1937
01:15:14,330 --> 01:15:16,070
Windows服务器或

1938
01:15:16,070 --> 01:15:18,350
像Linux这样的服务器上运行，无论这个包

1939
01:15:18,350 --> 01:15:21,740
你可以下载安装这个东西，

1940
01:15:21,740 --> 01:15:24,110
虽然 OSX 不支持

1941
01:15:24,110 --> 01:15:25,340
我们稍后将讨论的 clang 格式化的东西

1942
01:15:25,340 --> 01:15:27,950
太好了，我们会

1943
01:15:27,950 --> 01:15:30,050
为你运行它 你可以在 docker 中运行它，

1944
01:15:30,050 --> 01:15:31,340
如果你这是一个问题，我们可以

1945
01:15:31,340 --> 01:15:33,350
还给你一个 VM 映像，但你必须

1946
01:15:33,350 --> 01:15:35,450
要你不必自己弄清楚这一点

1947
01:15:35,450 --> 01:15:36,680
我们会有说明

1948
01:15:36,680 --> 01:15:37,400
试图帮助我们解决

1949
01:15:37,400 --> 01:15:39,410
它不能编译 Android 机器

1950
01:15:39,410 --> 01:15:42,260
我们试过它它不起作用

1951
01:15:42,260 --> 01:15:44,270
他们的软件太慢了，如果这

1952
01:15:44,270 --> 01:15:45,320
是一个问题，你没有你的笔记本电脑，

1953
01:15:45,320 --> 01:15:46,520
请给我发电子邮件，我们会

1954
01:15:46,520 --> 01:15:50,360
解决问题，所以要注意的事情

1955
01:15:50,360 --> 01:15:52,250
不应该改变你必须提交的文件以外的任何文件

1956
01:15:52,250 --> 01:15:53,900
，因为 我们

1957
01:15:53,900 --> 01:15:54,980
基本上要把所有的东西都

1958
01:15:54,980 --> 01:15:56,840
吹走有四个文件 es 你必须交出来

1959
01:15:56,840 --> 01:15:59,240
我们把所有其他东西都扔掉

1960
01:15:59,240 --> 01:16:01,400
把你的代码放在最新版本

1961
01:16:01,400 --> 01:16:04,250
的系统之上 运行你所有的测试

1962
01:16:04,250 --> 01:16:06,170
这些项目是累积的意思如果

1963
01:16:06,170 --> 01:16:07,280
你轰炸这个，你

1964
01:16:07,280 --> 01:16:10,220
以后会遇到问题，因为你 知道

1965
01:16:10,220 --> 01:16:11,810
下一个项目实际上是我们使用

1966
01:16:11,810 --> 01:16:13,040
您今天构建的缓冲池管理器

1967
01:16:13,040 --> 01:16:15,290
我现在构建我们也不会

1968
01:16:15,290 --> 01:16:18,110
在开始时提供解决方案

1969
01:16:18,110 --> 01:16:19,490
然后我们不会愉快地调试和

1970
01:16:19,490 --> 01:16:22,700
您在 Piazza 上的代码 我们正在做的另一件事

1971
01:16:22,700 --> 01:16:23,900
今年的新变化是我们

1972
01:16:23,900 --> 01:16:25,360
要求你编写好看的代码，

1973
01:16:25,360 --> 01:16:28,460
通常人们喜欢合适的代码，所以现在

1974
01:16:28,460 --> 01:16:29,780
我们都想检查以确保它

1975
01:16:29,780 --> 01:16:32,120
确实符合一个好的风格指南，

1976
01:16:32,120 --> 01:16:33,980
所以我们遵循了谷歌无袖

1977
01:16:33,980 --> 01:16:35,540
风格指南和 我们还遵循

1978
01:16:35,540 --> 01:16:38,240
了 Java 文档样式指南中的文档，因此我们

1979
01:16:38,240 --> 01:16:39,800
已经进行了检查，

1980
01:16:39,800 --> 01:16:41,330
这些检查将为您检查所有这些内容，例如，如果您

1981
01:16:41,330 --> 01:16:43,130
调用 make 格式，它将确保您的

1982
01:16:43,130 --> 01:16:44,990
代码在最简单的过道指南中看起来很漂亮，

1983
01:16:44,990 --> 01:16:46,370
但是有很多 其他的

1984
01:16:46,370 --> 01:16:49,370
事情，比如你如何分配内存，

1985
01:16:49,370 --> 01:16:50,810
你如何设置你的 for 循环等等

1986
01:16:50,810 --> 01:16:53,270
，我们使用 clang tidy 和 clang 格式

1987
01:16:53,270 --> 01:16:56,570
来强制执行更多细节，这样你就可以

1988
01:16:56,570 --> 01:16:57,800
运行这些命令，比如

1989
01:16:57,800 --> 01:17:00,470
clang tidy collect check censored check

1990
01:17:00,470 --> 01:17:02,210
lint it will throw 错误他们

1991
01:17:02,210 --> 01:17:03,530
不会为您纠正或抛出错误并

1992
01:17:03,530 --> 01:17:05,330
说您的代码看起来很糟糕这里是如何

1993
01:17:05,330 --> 01:17:07,490
修复它，我们将运行

1994
01:17:07,490 --> 01:17:08,870
一些等级范围，因此当您提交它时，

1995
01:17:08,870 --> 01:17:11,150
如果您编写了糟糕的代码，您就会

1996
01:17:11,150 --> 01:17:12,950
明白 将获得零分，因为您将

1997
01:17:12,950 --> 01:17:15,710
无法通过这些测试 所以这就是我所说的

1998
01:17:15,710 --> 01:17:17,330
Linux 和 Windows 我认为这适用

1999
01:17:17,330 --> 01:17:19,430
于 OSX 我认为这行不通 但

2000
01:17:19,430 --> 01:17:21,020
我们可以为您提供一个 PM 您可以做

2001
01:17:21,020 --> 01:17:24,530
所有 你在那里的开发 好的 最后一

2002
01:17:24,530 --> 01:17:25,970
件事不要抄袭 我们将通过 moss 运行你的

2003
01:17:25,970 --> 01:17:27,620
代码

2004
01:17:27,620 --> 01:17:28,970
在中国有些人拿走了代码

2005
01:17:28,970 --> 01:17:30,050
我已经实现了一些东西

2006
01:17:30,050 --> 01:17:31,880
我们已经运行了所有的废话 它不起作用

2007
01:17:31,880 --> 01:17:33,520


2008
01:17:33,520 --> 01:17:35,570
不要 不要再制造你的东西 不要把

2009
01:17:35,570 --> 01:17:37,100
你的东西放在公共回购上，因为如果

2010
01:17:37,100 --> 01:17:39,260
我运行你的东西，有人从你那里复制，

2011
01:17:39,260 --> 01:17:40,790
因为你的帐户是公开的，

2012
01:17:40,790 --> 01:17:43,130
重新运行苔藓，你们俩都是

2013
01:17:43,130 --> 01:17:44,690
彼此的副本我不

2014
01:17:44,690 --> 01:17:47,030
知道谁偷了谁，好吧，所以你

2015
01:17:47,030 --> 01:17:49,730
打破了他们会失败的，所以不要 不要把

2016
01:17:49,730 --> 01:17:51,680
你的任何代码公开你可以在这个学期做这

2017
01:17:51,680 --> 01:17:53,090
件事因为我知道

2018
01:17:53,090 --> 01:17:54,230
你想进入就业市场我就像

2019
01:17:54,230 --> 01:17:57,080
哦这就是我在这门课上所做的事实

2020
01:17:57,080 --> 01:17:58,340
被告知没有人真的会关心

2021
01:17:58,340 --> 01:17:59,750
因为每个人都在实施相同的

2022
01:17:59,750 --> 01:18:00,950
事情不像一个独立的研究

2023
01:18:00,950 --> 01:18:02,390
，你在那里你取得了一些突破，它可能会

2024
01:18:02,390 --> 01:18:04,970
突破，所以雇主他们不太

2025
01:18:04,970 --> 01:18:06,470
关心你有你的

2026
01:18:06,470 --> 01:18:09,050
在线项目，但如果你想这样做，

2027
01:18:09,050 --> 01:18:09,980
如果我们没问题，那么这个学期就可以了

2028
01:18:09,980 --> 01:18:15,080
哈希表接下来的任何问题都

2029
01:18:15,080 --> 01:18:19,400
可以在学校与米歇尔一起解决，以防

2030
01:18:19,400 --> 01:18:22,040
万一琳达混合破碎的瓶子

2031
01:18:22,040 --> 01:18:25,210
和压碎的孩子让

2032
01:18:25,500 --> 01:18:28,450
他在我的系统中迷雾

2033
01:18:28,450 --> 01:18:30,370


2034
01:18:30,370 --> 01:18:37,420
蒙蒙 是儿子

2035
01:18:37,420 --> 01:18:39,580
里 cochet jelly 去熟食店

2036
01:18:39,580 --> 01:18:41,710
坐船 自然祝福你 说唱

2037
01:18:41,710 --> 01:18:43,630
就像激光束 灌木丛中的小卒说

2038
01:18:43,630 --> 01:18:45,850
甚至不像链条 包裹着

2039
01:18:45,850 --> 01:18:48,550
我们的瓶子

2040
01:18:48,550 --> 01:18:50,350
一路走好 不要觉得喝醉了 不能尝试

2041
01:18:50,350 --> 01:18:52,390
十字架他还活着，如果不

2042
01:18:52,390 --> 01:18:55,650
知道你他妈的不能爆炸

