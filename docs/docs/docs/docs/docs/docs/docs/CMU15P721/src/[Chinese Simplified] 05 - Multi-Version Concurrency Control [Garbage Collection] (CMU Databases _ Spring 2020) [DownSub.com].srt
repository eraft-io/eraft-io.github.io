1
00:00:01,300 --> 00:00:05,129
[音乐]

2
00:00:05,200 --> 00:00:05,930
[掌声]

3
00:00:05,930 --> 00:00:08,630
[音乐]

4
00:00:08,630 --> 00:00:10,020
[掌声]

5
00:00:10,020 --> 00:00:13,219
[音乐]

6
00:00:13,219 --> 00:00:17,190
这将是

7
00:00:17,190 --> 00:00:19,410
我们关于多版本

8
00:00:19,410 --> 00:00:21,420
控制的最后一堂课，今天我们将再次

9
00:00:21,420 --> 00:00:23,760
关注垃圾问题，因为

10
00:00:23,760 --> 00:00:27,090
这对一个人来说非常重要 NBC

11
00:00:27,090 --> 00:00:31,349
数据库系统，所以我们已经

12
00:00:31,349 --> 00:00:32,610
在最后两节课中恢复了这一点，

13
00:00:32,610 --> 00:00:34,200
但让我们深入了解 Mojo

14
00:00:34,200 --> 00:00:37,170


15
00:00:37,170 --> 00:00:38,969


16
00:00:38,969 --> 00:00:41,129


17
00:00:41,129 --> 00:00:43,620
识别

18
00:00:43,620 --> 00:00:46,530
回收 Abul 的物理版本，然后

19
00:00:46,530 --> 00:00:48,329
将它们删除，否则

20
00:00:48,329 --> 00:00:49,920
我们将耗尽空间 我想我

21
00:00:49,920 --> 00:00:51,870
在开始时说过，

22
00:00:51,870 --> 00:00:53,969
当我

23
00:00:53,969 --> 00:00:56,370
在 1980 年代第一次创建我的第一个单词时，Postgres

24
00:00:56,370 --> 00:00:57,600
并没有使用时间旅行查询 任何垃圾收集，

25
00:00:57,600 --> 00:00:59,609
因为他们说我们想要支持

26
00:00:59,609 --> 00:01:01,649
时间

27
00:01:01,649 --> 00:01:04,080


28
00:01:04,080 --> 00:01:06,689


29
00:01:06,689 --> 00:01:08,340


30
00:01:08,340 --> 00:01:09,990
旅行查询 ostgres 也有学术界

31
00:01:09,990 --> 00:01:11,970
，他们做的第一件事就是重新添加

32
00:01:11,970 --> 00:01:13,439
垃圾收集，因为

33
00:01:13,439 --> 00:01:15,210
如果您的数据库中有大量流失，空间很快就会耗尽，

34
00:01:15,210 --> 00:01:18,720
所以很

35
00:01:18,720 --> 00:01:19,970
明显为什么我们需要这样做，

36
00:01:19,970 --> 00:01:22,290
所以我们定义了一个普通的 Bowl

37
00:01:22,290 --> 00:01:24,180
将是一个物理版本，其中

38
00:01:24,180 --> 00:01:26,280


39
00:01:26,280 --> 00:01:30,000
系统中没有运行的活动事务可以看到该

40
00:01:30,000 --> 00:01:31,530
特定物理版本，这意味着它

41
00:01:31,530 --> 00:01:33,689
在快照隔离下对该事务不可见，

42
00:01:33,689 --> 00:01:37,049
或者显然如果

43
00:01:37,049 --> 00:01:38,280
版本是由 de Borda 事务创建的，

44
00:01:38,280 --> 00:01:40,229
我们不 希望它

45
00:01:40,229 --> 00:01:41,490
永远存在，我们想

46
00:01:41,490 --> 00:01:44,520
继续清理它，

47
00:01:44,520 --> 00:01:45,930
这是多版本控制的

48
00:01:45,930 --> 00:01:47,640
好处，因为我们记录这些时间戳

49
00:01:47,640 --> 00:01:49,770
是为了提供隔离的快照

50
00:01:49,770 --> 00:01:52,320
，我们可以使用所有这些相同的

51
00:01:52,320 --> 00:01:55,619
时间戳来确定何时 当元

52
00:01:55,619 --> 00:01:57,240
组实际上可见或不正常时，

53
00:01:57,240 --> 00:01:58,740
这里的想法是时间

54
00:01:58,740 --> 00:02:00,450
代表用于分配事务

55
00:02:00,450 --> 00:02:02,670
以了解它们是全局的

56
00:02:02,670 --> 00:02:05,130
订购是相同的时间戳，因此用户

57
00:02:05,130 --> 00:02:07,469
可以在 Martin 版本

58
00:02:07,469 --> 00:02:10,139
或物理版本的生命周期中告诉您，

59
00:02:10,139 --> 00:02:12,150
如果没有人可以看到这个，我们只是说好的，

60
00:02:12,150 --> 00:02:13,490
那么我们想要继续

61
00:02:13,490 --> 00:02:16,940
并删除它，所以我们需要做一件事

62
00:02:16,940 --> 00:02:18,920
谈论的是，

63
00:02:18,920 --> 00:02:20,480
你们从超级团队那里读到的论文中的内容

64
00:02:20,480 --> 00:02:25,160
是这个概念，就像

65
00:02:25,160 --> 00:02:27,230
如果您

66
00:02:27,230 --> 00:02:28,940
现在开始处理长时间运行的事务或查询

67
00:02:28,940 --> 00:02:31,910
一样会出现的复杂情况，我

68
00:02:31,910 --> 00:02:33,440
在 OLTP 环境中说过的成员

69
00:02:33,440 --> 00:02:35,060
交易几乎总是

70
00:02:35,060 --> 00:02:37,760
短暂的正确更新，并且 E

71
00:02:37,760 --> 00:02:39,650
在亚马逊上的帐户提交了该交易，

72
00:02:39,650 --> 00:02:42,410
您就做得对了，因此在那个世界中

73
00:02:42,410 --> 00:02:46,760
更新这些版本

74
00:02:46,760 --> 00:02:47,720
需要使其读取旧

75
00:02:47,720 --> 00:02:50,450
版本的交易他们不是你 知道

76
00:02:50,450 --> 00:02:51,500
他们不会长时间坐在那里，

77
00:02:51,500 --> 00:02:53,600
所以它不像有一个

78
00:02:53,600 --> 00:02:55,490
长时间运行的事务需要

79
00:02:55,490 --> 00:02:57,710
查看数据库的版本，因为它

80
00:02:57,710 --> 00:02:59,960
在一小时前与

81
00:02:59,960 --> 00:03:01,700
我们没有的环境并行 有这个问题，

82
00:03:01,700 --> 00:03:04,130
但现在是当我们开始

83
00:03:04,130 --> 00:03:07,040
投入分析工作负载和法律

84
00:03:07,040 --> 00:03:09,080
查询时，然后我们必须关心

85
00:03:09,080 --> 00:03:11,420
这个权利他会理解

86
00:03:11,420 --> 00:03:14,330
隔离我只需要查看

87
00:03:14,330 --> 00:03:18,040
它们存在的元组的版本

88
00:03:18,040 --> 00:03:20,450
是由事务创建的

89
00:03:20,450 --> 00:03:22,780
在我开始之前提交的，所以如果

90
00:03:22,780 --> 00:03:25,130
我微波炉需要一个小时那么我

91
00:03:25,130 --> 00:03:26,930
需要查看数据库的快照，

92
00:03:26,930 --> 00:03:30,920
因为它存在整整一个小时我现在

93
00:03:30,920 --> 00:03:33,020
可以在较低的隔离级别下运行，

94
00:03:33,020 --> 00:03:34,940
例如读取未提交的条目，无论

95
00:03:34,940 --> 00:03:36,650
我想要谁在乎，但如果 你想

96
00:03:36,650 --> 00:03:38,690
提供 snåsa 隔离，然后你需要

97
00:03:38,690 --> 00:03:42,470
做这一切，所以同样的问题

98
00:03:42,470 --> 00:03:44,060
将是我们在

99
00:03:44,060 --> 00:03:46,040
第一堂课中谈到的关于如何称呼

100
00:03:46,040 --> 00:03:47,630
传统抓取器的问题，

101
00:03:47,630 --> 00:03:48,980
就像没事的我看看我的时间戳

102
00:03:48,980 --> 00:03:51,950
和我所有的活动 交易，

103
00:03:51,950 --> 00:03:55,150
如果任何版本小于

104
00:03:55,150 --> 00:03:57,440
最小的活动交易时间戳，

105
00:03:57,440 --> 00:03:59,270
那么我知道我知道并继续

106
00:03:59,270 --> 00:04:00,800
修剪它但现在如果我有这些

107
00:04:00,800 --> 00:04:02,450
查询 坐了一个小时然后

108
00:04:02,450 --> 00:04:04,850
那会是你知道那会

109
00:04:04,850 --> 00:04:12,940
是更长的时间是的是的

110
00:04:14,140 --> 00:04:17,019
是的在介绍类中正确覆盖了每个水龙头

111
00:04:17,019 --> 00:04:19,360


112
00:04:19,360 --> 00:04:23,140
所以lhp和重叠以及在

113
00:04:23,140 --> 00:04:25,390
2000年代人们基本上想通了哦

114
00:04:25,390 --> 00:04:27,460
您实际上希望为每一个都有专门的

115
00:04:27,460 --> 00:04:28,990
系统，然后您

116
00:04:28,990 --> 00:04:30,220
可以在这个数据库中运行您的 OTP 查询，

117
00:04:30,220 --> 00:04:32,140
并在这个数据库中运行您的 OLAP 查询

118
00:04:32,140 --> 00:04:33,580
，这样它们就有

119
00:04:33,580 --> 00:04:35,410
不同的设计选择作为不同的

120
00:04:35,410 --> 00:04:37,690
目标，您可以构建一个

121
00:04:37,690 --> 00:04:39,700
针对两者进行优化的系统 其中这个年龄的

122
00:04:39,700 --> 00:04:41,920
东西是一个有点新的概念混合

123
00:04:41,920 --> 00:04:44,020
事务分析处理，

124
00:04:44,020 --> 00:04:46,420
这里的想法是我希望能够

125
00:04:46,420 --> 00:04:48,310
在数据到达后立即运行分析查询，

126
00:04:48,310 --> 00:04:50,380
而不是等待

127
00:04:50,380 --> 00:04:52,510
我使用某种 ETL 过程来

128
00:04:52,510 --> 00:04:54,280
卸载 它从 OTP 端到

129
00:04:54,280 --> 00:04:55,990
另一个数据库系统我会在

130
00:04:55,990 --> 00:04:58,420
它出现时立即运行它，所以

131
00:04:58,420 --> 00:04:59,890
现在这是一个更常见的事情，

132
00:04:59,890 --> 00:05:01,480
因为我需要的时间越长

133
00:05:01,480 --> 00:05:03,400
弄清楚如果你正在玩游戏

134
00:05:03,400 --> 00:05:05,860
，我想让你知道

135
00:05:05,860 --> 00:05:08,320
如果我必须运行它并让它进入

136
00:05:08,320 --> 00:05:09,760
我的后端机器并且需要很

137
00:05:09,760 --> 00:05:11,290
长时间才能传输数据

138
00:05:11,290 --> 00:05:19,360
然后我就欺骗你购买废话 可能会失去销售是的，所以

139
00:05:19,360 --> 00:05:22,510
他有一个非常好的陈述，

140
00:05:22,510 --> 00:05:25,090
对于这些分析查询来说很好，

141
00:05:25,090 --> 00:05:27,310
我们是否真的需要在

142
00:05:27,310 --> 00:05:28,870
快照隔离下运行，只是在

143
00:05:28,870 --> 00:05:31,210
较低的隔离级别下运行，并且

144
00:05:31,210 --> 00:05:31,480


145
00:05:31,480 --> 00:05:34,510
在许多情况下足够好，是的，并且 所以这有点

146
00:05:34,510 --> 00:05:40,290
像这是一种提供服务 嗯

147
00:05:40,290 --> 00:05:43,030
，学术界的看法实际上

148
00:05:43,030 --> 00:05:44,500
略有不同，好吧实际上

149
00:05:44,500 --> 00:05:45,669
它

150
00:05:45,669 --> 00:05:47,470
与现实世界中实际发生的情况大不相同，所以在

151
00:05:47,470 --> 00:05:48,730
学术界你会说哦，当然是

152
00:05:48,730 --> 00:05:50,200
你 想要运行可序列化的隔离

153
00:05:50,200 --> 00:05:51,850
或快照隔离，但在

154
00:05:51,850 --> 00:05:53,140
现实世界中，大多数人都像读取提交一样运行它，

155
00:05:53,140 --> 00:05:54,460
因为这是您

156
00:05:54,460 --> 00:05:57,070
在我的续集中在 Postgres 中获得的默认设置，

157
00:05:57,070 --> 00:06:00,550
所以是的，在某些情况下，

158
00:06:00,550 --> 00:06:01,900
您确实想要 sy  npse 隔离大多数时候你不需要

159
00:06:01,900 --> 00:06:03,550
这个分析性的东西，你想要可消毒的查询，

160
00:06:03,550 --> 00:06:05,310


161
00:06:05,310 --> 00:06:08,740
但即使这样，它确实发生了

162
00:06:08,740 --> 00:06:10,660
，我们不得不解决问题，

163
00:06:10,660 --> 00:06:14,919
好吧，是的，我们三年前对 DBA 进行了调查

164
00:06:14,919 --> 00:06:17,590
，我们基本上 说

165
00:06:17,590 --> 00:06:19,780
看起来像 50

166
00:06:19,780 --> 00:06:22,360
在 Sigma novio DB 中的所有论文中有 60% 他们假设

167
00:06:22,360 --> 00:06:23,560
事务在可序列化

168
00:06:23,560 --> 00:06:25,450
隔离下运行但然后你问真正的

169
00:06:25,450 --> 00:06:27,680
DBA 就像 10% 的

170
00:06:27,680 --> 00:06:29,330
事务在无菌隔离下

171
00:06:29,330 --> 00:06:30,620
运行每个人都运行重新提交因为这是

172
00:06:30,620 --> 00:06:32,990
你进入的默认值 在真实的

173
00:06:32,990 --> 00:06:34,100
数据库系统中以及那些

174
00:06:34,100 --> 00:06:35,570
除非您知道自己在做什么才懒得更改它的人，

175
00:06:35,570 --> 00:06:39,320
所以我说样本

176
00:06:39,320 --> 00:06:42,530
驱动是可以忍受的，您实际上

177
00:06:42,530 --> 00:06:45,470
想要进行分析，您可能

178
00:06:45,470 --> 00:06:47,000
几乎从不想要像可

179
00:06:47,000 --> 00:06:49,130
序列化的分析那样 没有

180
00:06:49,130 --> 00:06:49,550
意义

181
00:06:49,550 --> 00:06:53,660
例外足够好实际上它

182
00:06:53,660 --> 00:06:54,560
没有意义如果它在

183
00:06:54,560 --> 00:06:57,020
绝缘材料上折断那么我认为一切

184
00:06:57,020 --> 00:06:58,639
都已承诺我不能有任何

185
00:06:58,639 --> 00:06:59,900
异常 因为我没有做权利

186
00:06:59,900 --> 00:07:00,349
，

187
00:07:00,349 --> 00:07:02,419
所以是的，我的模拟就像

188
00:07:02,419 --> 00:07:04,990
我们想要的最高水平是的好吧

189
00:07:04,990 --> 00:07:08,210
好吧所以我已经涵盖了

190
00:07:08,210 --> 00:07:10,280
这个但是

191
00:07:10,280 --> 00:07:11,960
假设我们再次拥有这些旧版本的问题

192
00:07:11,960 --> 00:07:13,820
想要为我们的分析查询实现 samsa 隔离，

193
00:07:13,820 --> 00:07:17,030
或者显然我们正在

194
00:07:17,030 --> 00:07:19,400
增加内存使用量，因为现在

195
00:07:19,400 --> 00:07:22,610
我们正在创建新版本并且我们的

196
00:07:22,610 --> 00:07:24,440
版本链越来越长，但我们

197
00:07:24,440 --> 00:07:26,270
无法回收该内存，因此

198
00:07:26,270 --> 00:07:29,360
它们是存储空间的数量

199
00:07:29,360 --> 00:07:32,120
我们的大卫说正在消耗或使用的

200
00:07:32,120 --> 00:07:33,110
只是不断增长和无限增长，

201
00:07:33,110 --> 00:07:36,830
但这也

202
00:07:36,830 --> 00:07:39,530
意味着如果我们必须知道我们是否不能

203
00:07:39,530 --> 00:07:41,659
重用旧版本的内存，

204
00:07:41,659 --> 00:07:43,190
因为我们现在无法

205
00:07:43,190 --> 00:07:45,229
回收空间 '将返回到

206
00:07:45,229 --> 00:07:46,909
重新分配器，并可能

207
00:07:46,909 --> 00:07:49,280
通过 malloc 返回到操作系统并

208
00:07:49,280 --> 00:07:52,820
要求更多内存，并且该调用并不

209
00:07:52,820 --> 00:07:55,310
便宜，也不像去 malloc 那样免费，

210
00:07:55,310 --> 00:07:58,180
并且要求我的内存

211
00:07:58,180 --> 00:07:59,990
肯定会成为瓶颈 如果您

212
00:07:59,990 --> 00:08:01,340
有很多线程同时执行此操作，

213
00:08:01,340 --> 00:08:03,710
我们将再次变

214
00:08:03,710 --> 00:08:05,870
长，这意味着

215
00:08:05,870 --> 00:08:08,150
交易必须遍历 Virgin 链

216
00:08:08,150 --> 00:08:09,380
才能找到他们想要的正确版本

217
00:08:09,380 --> 00:08:11,180
，我永远不会接受我 现在更长的时间，

218
00:08:11,180 --> 00:08:13,130
如果你正在做最旧的新闻，并且

219
00:08:13,130 --> 00:08:14,539
大多数你的 OTP 交易只是

220
00:08:14,539 --> 00:08:16,820
触及最新版本，这

221
00:08:16,820 --> 00:08:19,190
对于分析查询来说没什么大不了的，

222
00:08:19,190 --> 00:08:20,509
是的，他们必须

223
00:08:20,509 --> 00:08:21,770
遍历整个链，但可能会找到

224
00:08:21,770 --> 00:08:24,470
唯一的正确版本 我

225
00:08:24,470 --> 00:08:27,560
知道从最旧到最新的系统是

226
00:08:27,560 --> 00:08:28,880
Hecate on，所以他们会遇到这个

227
00:08:28,880 --> 00:08:32,990
问题，但是如果你注意到一个

228
00:08:32,990 --> 00:08:34,940
通知，那么将新的放在 m 上是一个很长的遍历，

229
00:08:34,940 --> 00:08:36,559
这只是一个

230
00:08:36,559 --> 00:08:38,240
问题 Hecate on 但用于分析

231
00:08:38,240 --> 00:08:39,679
查询 他们需要更长的时间才能找到

232
00:08:39,679 --> 00:08:41,520
他们想要的正确版本

233
00:08:41,520 --> 00:08:43,860
另一个我们还没有

234
00:08:43,860 --> 00:08:45,360
真正讨论过的大问题是

235
00:08:45,360 --> 00:08:47,880


236
00:08:47,880 --> 00:08:50,399
在您的数据库系统

237
00:08:50,399 --> 00:08:54,330
中在性能方面具有一致的性能和稳定性的概念 如果现在你

238
00:08:54,330 --> 00:08:56,339
喜欢这些长时间运行的查询一个

239
00:08:56,339 --> 00:08:58,709
小时，然后查询完成的那个小时

240
00:08:58,709 --> 00:09:00,540
，现在我需要回去清理

241
00:09:00,540 --> 00:09:01,830
所有最终回收的旧版本

242
00:09:01,830 --> 00:09:03,930
Abul 我们现在

243
00:09:03,930 --> 00:09:06,300
会有这个巨大的峰值 在

244
00:09:06,300 --> 00:09:07,320
垃圾收集线程的 CPU 使用率中，

245
00:09:07,320 --> 00:09:08,430
因为他们会说哦，看看所有

246
00:09:08,430 --> 00:09:10,080
这些版本，我可以清理一下，让我

247
00:09:10,080 --> 00:09:13,230


248
00:09:13,230 --> 00:09:15,089
把它们撕掉，然后你就知道开始扔掉它们，现在

249
00:09:15,089 --> 00:09:16,500
正在运行的查询可能会在同一时间运行

250
00:09:16,500 --> 00:09:17,910
性能没有下降 因为现在

251
00:09:17,910 --> 00:09:19,830
CPU 上存在资源争用

252
00:09:19,830 --> 00:09:21,750
因为你正在做

253
00:09:21,750 --> 00:09:25,410
垃圾收集所以再次

254
00:09:25,410 --> 00:09:27,600
就像在现实世界中

255
00:09:27,600 --> 00:09:30,380
很多公司或组织

256
00:09:30,380 --> 00:09:32,990
他们非常 保守地

257
00:09:32,990 --> 00:09:35,610
采用一种数据库新技术，

258
00:09:35,610 --> 00:09:37,800
因为他们希望具有

259
00:09:37,800 --> 00:09:39,420
一致的性能，这并不能帮助

260
00:09:39,420 --> 00:09:40,800
您说好，这

261
00:09:40,800 --> 00:09:41,910
是新数据库系统的最新最佳版本

262
00:09:41,910 --> 00:09:44,040
，它将使 95%

263
00:09:44,040 --> 00:09:45,720
的 我的查询进行得更快了，但是

264
00:09:45,720 --> 00:09:47,420
那 5% 我会像随机缓慢的

265
00:09:47,420 --> 00:09:50,070
人不希望他们会

266
00:09:50,070 --> 00:09:50,970
坚持使用他们

267
00:09:50,970 --> 00:09:53,610
实际上知道的旧东西，最后

268
00:09:53,610 --> 00:09:55,730
一个会成为问题 当我们开始做的时候，

269
00:09:55,730 --> 00:09:58,380
我们会更多地谈论缓存局部性和

270
00:09:58,380 --> 00:10:01,920
其他事情，所以我正在压缩，所以如果我

271
00:10:01,920 --> 00:10:03,600
现在将所有这些旧版本

272
00:10:03,600 --> 00:10:06,390
分散在我的表空间中，

273
00:10:06,390 --> 00:10:10,410
那么当我开始这样做时，如果我正在这样做

274
00:10:10,410 --> 00:10:12,870
，垃圾部分就会一次 现在

275
00:10:12,870 --> 00:10:15,029
我的桌子上有一堆洞

276
00:10:15,029 --> 00:10:16,500
，我可以用其他其他对象重新填充，

277
00:10:16,500 --> 00:10:19,380
但是当我想进行

278
00:10:19,380 --> 00:10:20,850
压缩时，我想基本上获取

279
00:10:20,850 --> 00:10:22,890
一堆旧数据并将其压缩，

280
00:10:22,890 --> 00:10:26,850
因为它是只读的，如果我全部

281
00:10:26,850 --> 00:10:28,470
处女座有点分散，

282
00:10:28,470 --> 00:10:30,480
因为我不能一遍又一遍地重复使用相同的

283
00:10:30,480 --> 00:10:32,430
空间然后我失去了

284
00:10:32,430 --> 00:10:34,020
这个地方，我必须做

285
00:10:34,020 --> 00:10:36,810
一堆额外的工作来将在一段时间

286
00:10:36,810 --> 00:10:38,279
内彼此相关的对象组合在一起

287
00:10:38,279 --> 00:10:41,250
它们可以被

288
00:10:41,250 --> 00:10:43,620
压缩的方式这不会 现在感觉

289
00:10:43,620 --> 00:10:45,480
我会在选举结束时报道这个事件

290
00:10:45,480 --> 00:10:50,010
好吧所以今天我

291
00:10:50,010 --> 00:10:51,240
想花一点时间

292
00:10:51,240 --> 00:10:52,290
开始讨论我们讨论了关于删除的问题

293
00:10:52,290 --> 00:10:53,490
所以这是我们

294
00:10:53,490 --> 00:10:55,500
没有

295
00:10:55,500 --> 00:10:57,000
在 我应该有最后几堂课，

296
00:10:57,000 --> 00:10:59,040
但它现在就在这里，然后我们将

297
00:10:59,040 --> 00:11:01,110
专注于垃圾收集的不同设计决策

298
00:11:01,110 --> 00:11:02,160
，

299
00:11:02,160 --> 00:11:03,540
这在你们阅读的超级论文中，

300
00:11:03,540 --> 00:11:06,120
然后是什么是岩石压实

301
00:11:06,120 --> 00:11:07,530
，这就是我所做的 说关于

302
00:11:07,530 --> 00:11:10,800
将数据表中未使用的空间组合在一起

303
00:11:10,800 --> 00:11:13,170
，以便您知道

304
00:11:13,170 --> 00:11:15,300
压缩器会将它们组合在一起并

305
00:11:15,300 --> 00:11:16,920
忘记内存然后我错过了

306
00:11:16,920 --> 00:11:18,060
这里的要点但我会

307
00:11:18,060 --> 00:11:20,790
完成并做一个关于性能的

308
00:11:20,790 --> 00:11:22,860
教程 你需要为项目做一个

309
00:11:22,860 --> 00:11:28,800
好的，所以我们已经讨论过它

310
00:11:28,800 --> 00:11:29,880
做插入或讨论做

311
00:11:29,880 --> 00:11:31,260
更新我们并没有真正谈论

312
00:11:31,260 --> 00:11:34,170
如何做删除，所以在你这么简单的权利中

313
00:11:34,170 --> 00:11:36,450
，它是元组的第一个物理版本

314
00:11:36,450 --> 00:11:39,330
我在我的夜间数据表中找到了一个空闲插槽

315
00:11:39,330 --> 00:11:40,950
，我只是将其插入

316
00:11:40,950 --> 00:11:43,110
，没什么大不了的，然后更新我们

317
00:11:43,110 --> 00:11:43,920
已经知道，句柄是否正确

318
00:11:43,920 --> 00:11:45,270
取决于正在使用的版本方案是否

319
00:11:45,270 --> 00:11:47,340
正确使用 Delta 记录

320
00:11:47,340 --> 00:11:49,230
是否仅使用笔 你

321
00:11:49,230 --> 00:11:50,730
知道版本链的方向我们

322
00:11:50,730 --> 00:11:52,680
知道如何处理删除

323
00:11:52,680 --> 00:11:57,930
现在有点棘手因为你

324
00:11:57,930 --> 00:12:00,630
现在需要基本上记录

325
00:12:00,630 --> 00:12:02,340
这个逻辑元组的这个拳头已经被删除

326
00:12:02,340 --> 00:12:04,920
，即使有人可能会出现

327
00:12:04,920 --> 00:12:07,230
并插入相同的

328
00:12:07,230 --> 00:12:09,210
从技术上讲，元组现在在

329
00:12:09,210 --> 00:12:10,740
另一个快照中，并且您不想

330
00:12:10,740 --> 00:12:13,770
重复使用 Virgin 链，因此基本上

331
00:12:13,770 --> 00:12:15,330
您需要一种记录方式来说明一切

332
00:12:15,330 --> 00:12:19,920
正常，这件事现在已被删除，没有

333
00:12:19,920 --> 00:12:21,510
其他版本的船舶应该落后于它，

334
00:12:21,510 --> 00:12:24,960
所以 再一次，我们不能有任何正确的

335
00:12:24,960 --> 00:12:26,070
复合体，这只是第一个

336
00:12:26,070 --> 00:12:28,140
作者获胜，所以如果我的事务

337
00:12:28,140 --> 00:12:29,700
在我提交之前删除了这个元组，

338
00:12:29,700 --> 00:12:31,860
你尝试更新它我会打败

339
00:12:31,860 --> 00:12:33,540
你，所以我们需要

340
00:12:33,540 --> 00:12:36,510
和以前一样正确的正确语义

341
00:12:36,510 --> 00:12:39,900
所以现在的问题是我们如何

342
00:12:39,900 --> 00:12:42,330
实际记录我们的元组

343
00:12:42,330 --> 00:12:44,130
在某个时间点被逻辑删除，

344
00:12:44,130 --> 00:12:46,410
因为我们无法删除版本

345
00:12:46,410 --> 00:12:48,510
链，因为那是你知道然后

346
00:12:48,510 --> 00:12:53,070
存在就消失了 是的，因此有两种

347
00:12:53,070 --> 00:12:55,620
基本方法可以做到这一点，一种

348
00:12:55,620 --> 00:12:57,360
是在某处维护一个单独的标志

349
00:12:57,360 --> 00:12:59,730
，表明该逻辑元组已

350
00:12:59,730 --> 00:13:02,730
被删除，因此您现在可以将其

351
00:13:02,730 --> 00:13:04,650
存储在我们在记录所有这些之前讨论过的元组标头

352
00:13:04,650 --> 00:13:06,510
中

353
00:13:06,510 --> 00:13:08,790
时间戳，或者你可以只拥有

354
00:13:08,790 --> 00:13:09,000
一个

355
00:13:09,000 --> 00:13:11,700
每列，它只是一个位图字段

356
00:13:11,700 --> 00:13:14,210
，表示我们块中的元组

357
00:13:14,210 --> 00:13:17,820
在这所有集合中已被删除，这

358
00:13:17,820 --> 00:13:19,740
意味着现在当我开始扫描或我的

359
00:13:19,740 --> 00:13:21,120
事务开始读取数据库时，

360
00:13:21,120 --> 00:13:23,580
我总是必须检查这个 首先

361
00:13:23,580 --> 00:13:25,680
要看看它是否真的是你知道

362
00:13:25,680 --> 00:13:26,940
我是否正在走一条

363
00:13:26,940 --> 00:13:28,670
不相信或不相信的

364
00:13:28,670 --> 00:13:32,610
道路所以在我们的系统中我们将它存储为

365
00:13:32,610 --> 00:13:33,840
一个单独的列 这是一个单独的

366
00:13:33,840 --> 00:13:36,750
位图字段，另

367
00:13:36,750 --> 00:13:38,610
一种方法是做一个墓碑元组，

368
00:13:38,610 --> 00:13:42,690
这里的想法是我们在版本链的末尾或末尾存储一个新的

369
00:13:42,690 --> 00:13:44,490
物理版本一个特殊的物理

370
00:13:44,490 --> 00:13:46,410
版本，这

371
00:13:46,410 --> 00:13:48,420
取决于我们的

372
00:13:48,420 --> 00:13:51,450
方向 做然后以

373
00:13:51,450 --> 00:13:54,210
某种方式表明在这个

374
00:13:54,210 --> 00:13:56,160
特殊版本中它代表

375
00:13:56,160 --> 00:13:59,400
这个元组被删除然后

376
00:13:59,400 --> 00:14:00,930
那个 per 销毁所有时间戳

377
00:14:00,930 --> 00:14:02,100
和你之前要做的一切，

378
00:14:02,100 --> 00:14:03,300
这给你没有关于什么

379
00:14:03,300 --> 00:14:04,770
时候这个元组的信息 实际上

380
00:14:04,770 --> 00:14:07,110
已被删除，因此在

381
00:14:07,110 --> 00:14:08,820
该快照和更早快照之前出现的任何人仍

382
00:14:08,820 --> 00:14:13,170
请查看旧版本，因此可以通过一种方法

383
00:14:13,170 --> 00:14:14,670
来改进这一点并使这项

384
00:14:14,670 --> 00:14:16,740
工作很好地工作，而不是

385
00:14:16,740 --> 00:14:20,280
污染

386
00:14:20,280 --> 00:14:22,260
其固定数据池中的所有扩展浪费空间 你可以

387
00:14:22,260 --> 00:14:25,740
有一个单独的数据池来存储这

388
00:14:25,740 --> 00:14:26,730
两个 Serna，因为你

389
00:14:26,730 --> 00:14:28,620
实际上不需要恢复整个元组

390
00:14:28,620 --> 00:14:30,600
，然后现在这个 p 的版本链

391
00:14:30,600 --> 00:14:31,800
oints 指向这个东西，你

392
00:14:31,800 --> 00:14:33,800
会看着说哦，设置了这个位，

393
00:14:33,800 --> 00:14:36,030
里面有一些位模式说

394
00:14:36,030 --> 00:14:37,920
哦，这实际上是墓碑元组，而

395
00:14:37,920 --> 00:14:39,960
不是普通的管壁，这才是真正

396
00:14:39,960 --> 00:14:41,100
的问题，如果你正在做附加，

397
00:14:41,100 --> 00:14:43,140
那么再次 想一想，如果

398
00:14:43,140 --> 00:14:46,200
我在做一个钟摆，

399
00:14:46,200 --> 00:14:49,320
如果我删除那个元组，我有一千列

400
00:14:49,320 --> 00:14:50,670
，我想创建一个墓碑来

401
00:14:50,670 --> 00:14:52,680
汇集一个方法是我现在

402
00:14:52,680 --> 00:14:54,930
在我的同一个表中制作一个特殊的元组，我的所有

403
00:14:54,930 --> 00:14:57,360
其他元组为此

404
00:14:57,360 --> 00:14:59,760
具有一千个属性的表，因此浪费了

405
00:14:59,760 --> 00:15:01,320
空间只是一个记录，该记录

406
00:15:01,320 --> 00:15:03,720
实际上已被删除，或者它可以有一个标记

407
00:15:03,720 --> 00:15:05,880
，说嘿你知道，或者有一个特殊的

408
00:15:05,880 --> 00:15:07,740
元组空间来表示这代表一个

409
00:15:07,740 --> 00:15:09,660
已删除的元组，这意味着

410
00:15:09,660 --> 00:15:11,370
在不同的表之间共享 因为我们

411
00:15:11,370 --> 00:15:12,930
没有在

412
00:15:12,930 --> 00:15:14,250
墓碑和元组中存储任何属性我们只是

413
00:15:14,250 --> 00:15:16,040
说这个东西被删除了

414
00:15:16,040 --> 00:15:19,440
所以在我们的大部队中我会说不是但

415
00:15:19,440 --> 00:15:21,120
爱但无论我们杀死的旧系统

416
00:15:21,120 --> 00:15:22,920
我们做了什么 以这种方式

417
00:15:22,920 --> 00:15:24,149
，我们将使用这个特殊的池，

418
00:15:24,149 --> 00:15:25,740
因为我们正在做一个只舔

419
00:15:25,740 --> 00:15:28,529
Hecate 的笔，因此如果我们现在创建

420
00:15:28,529 --> 00:15:30,660
一个墓碑来池，如果我们把它放在

421
00:15:30,660 --> 00:15:32,220
同一个数据表中，将是一个很大的空间浪费，

422
00:15:32,220 --> 00:15:34,920
而且更新的系统 我们使用我们

423
00:15:34,920 --> 00:15:39,470
使用单独的列作为已删除的标志是的

424
00:15:40,579 --> 00:15:42,660
这个问题是为什么

425
00:15:42,660 --> 00:15:46,680
不需要一个 Oh 开始不同来

426
00:15:46,680 --> 00:15:48,420
为已删除的元组或

427
00:15:48,420 --> 00:15:59,490
不同的表发送涟漪可以是如果我

428
00:15:59,490 --> 00:16:01,560
从同一个表中删除三个元组为什么要

429
00:16:01,560 --> 00:16:02,940
我需要为他们每个人准备一个单独的房间中心表，

430
00:16:02,940 --> 00:16:04,800
因为在墓碑中

431
00:16:04,800 --> 00:16:06,300
煮沸你正在记录开始和结束

432
00:16:06,300 --> 00:16:08,610
时间戳，因为我需要

433
00:16:08,610 --> 00:16:10,680
知道这件事是什么时候删除它现在是的，我

434
00:16:10,680 --> 00:16:11,970
认为你的另一个问题也是

435
00:16:11,970 --> 00:16:15,230
为什么要这样做 我需要知道为什么我可以拥有

436
00:16:15,230 --> 00:16:19,139
为什么我可以拥有一个

437
00:16:19,139 --> 00:16:21,360
可以在

438
00:16:21,360 --> 00:16:23,610
多个数据表之间共享的相同墓碑表特殊表因为我们没有

439
00:16:23,610 --> 00:16:25,320
在墓碑中存储任何属性

440
00:16:25,320 --> 00:16:27,630
墓碑只是说嘿此时您已经死

441
00:16:27,630 --> 00:16:30,180
了所以 它没有 不管

442
00:16:30,180 --> 00:16:50,010
它对应的是什么表，但你需要

443
00:16:50,010 --> 00:16:54,000
知道那个时间戳，是的，

444
00:16:54,000 --> 00:16:56,149
是的，

445
00:16:59,410 --> 00:17:02,649
我想我认为

446
00:17:02,649 --> 00:17:06,490
我认为问题的一部分是第一个骑手

447
00:17:06,490 --> 00:17:08,730
会赢，所以谁在乎你的市场领先

448
00:17:08,730 --> 00:17:10,839
，可能会有一些订单

449
00:17:10,839 --> 00:17:14,559
像这样的问题，我可以记录已删除的内容

450
00:17:14,559 --> 00:17:19,119
，然后我停下来，如果我这样做，

451
00:17:19,119 --> 00:17:21,099
那么如果删除该

452
00:17:21,099 --> 00:17:23,199
元组的事务中止，那么我必须确保

453
00:17:23,199 --> 00:17:26,829
返回并删除它，如果我不

454
00:17:26,829 --> 00:17:30,669
修改前一个元组 除了

455
00:17:30,669 --> 00:17:32,289
可能是指针然后

456
00:17:32,289 --> 00:17:35,049
当我购买时停止更新

457
00:17:35,049 --> 00:17:37,539
指针是的，您可能会逃脱

458
00:17:37,539 --> 00:17:38,379
类似的事情我必须考虑

459
00:17:38,379 --> 00:17:44,500
一下哦，是的，如果是

460
00:17:44,500 --> 00:17:45,909
学生制作了这

461
00:17:45,909 --> 00:17:48,789
系统并不是说他喜欢

462
00:17:48,789 --> 00:17:50,049
偷工减料，但他基本上

463
00:17:50,049 --> 00:17:52,960
以最有效的方式做了所有事情，

464
00:17:52,960 --> 00:17:54,429
但这始终不是最好的工程

465
00:17:54,429 --> 00:17:56,590
方法，所以如果有办法使

466
00:17:56,590 --> 00:17:59,500
这项工作成功，我会并且喜欢做

467
00:17:59,500 --> 00:18:00,070
你提议的那个黑客

468
00:18:00,070 --> 00:18:02,350
我 怀疑 ct你本来可以做的，但我们

469
00:18:02,350 --> 00:18:04,179
可以把它脱机，也许在董事会上做，

470
00:18:04,179 --> 00:18:05,080
然后弄清楚为什么这

471
00:18:05,080 --> 00:18:08,139
不会再正常工作了，所以再次对于

472
00:18:08,139 --> 00:18:10,649
这个我认为除了我们之外没有人会这样做，

473
00:18:10,649 --> 00:18:13,149
因为如果你正在做

474
00:18:13,149 --> 00:18:16,120
Delta 商店，如果它不存储

475
00:18:16,120 --> 00:18:17,649
会做同样的事情，但他正在做

476
00:18:17,649 --> 00:18:23,110
最新到最旧的 Delta 商店，那么

477
00:18:23,110 --> 00:18:24,639
这不会给你买任何东西，因为

478
00:18:24,639 --> 00:18:27,070
你确实存储在该管的标题

479
00:18:27,070 --> 00:18:28,899
中，其他东西已被删除

480
00:18:28,899 --> 00:18:34,240
是的但那是他的状态问题

481
00:18:34,240 --> 00:18:35,169
就像他的更新结束

482
00:18:35,169 --> 00:18:37,179
时间戳是否足以

483
00:18:37,179 --> 00:18:38,590
表示它已被删除我开始在某处有一个

484
00:18:38,590 --> 00:18:40,149
标志说该内容

485
00:18:40,149 --> 00:18:49,509
已正确删除但他就是这样你需要它

486
00:18:49,509 --> 00:18:52,990
结束时间戳 表示

487
00:18:52,990 --> 00:18:54,460
有一个特殊的删除，比如可能把你

488
00:18:54,460 --> 00:18:56,559
拿走了第一位，并

489
00:18:56,559 --> 00:18:59,070
表示它被删除了，你可以这样

490
00:18:59,070 --> 00:19:01,210
做我只是在那里放了一个结束时间戳

491
00:19:01,210 --> 00:19:02,529
我不知道这是否是一个删除

492
00:19:02,529 --> 00:19:03,490
或者它是否真的 一个新

493
00:19:03,490 --> 00:19:05,820
版本

494
00:19:10,549 --> 00:19:17,249
是啊是啊 好吧好吧好吧现在让我们

495
00:19:17,249 --> 00:19:18,869
谈谈不同的设计

496
00:19:18,869 --> 00:19:21,269
决策所以我希望这部分

497
00:19:21,269 --> 00:19:22,499
不在论文中但我想谈谈

498
00:19:22,499 --> 00:19:25,710
我们实际上如何清理

499
00:19:25,710 --> 00:19:29,580
索引中的键然后实际上只有

500
00:19:29,580 --> 00:19:31,169
两篇论文是关于 MVCC 垃圾收集的

501
00:19:31,169 --> 00:19:33,389
系统我让你读过这个人

502
00:19:33,389 --> 00:19:35,460
是几个月前才发表的来自 hyper 的那篇

503
00:19:35,460 --> 00:19:37,320


504
00:19:37,320 --> 00:19:39,119
论文 还有另一篇 2016 年的论文，我让

505
00:19:39,119 --> 00:19:40,679
学生们去年从 SAP

506
00:19:40,679 --> 00:19:45,269
团队读过他们不是，但他们

507
00:19:45,269 --> 00:19:48,330
都是 好的论文，我不喜欢

508
00:19:48,330 --> 00:19:50,789
的是他们有点

509
00:19:50,789 --> 00:19:53,100
定义相同的概念，但使用

510
00:19:53,100 --> 00:19:55,049
不同的术语，就像我认为的那样，

511
00:19:55,049 --> 00:19:56,940
就像超级家伙称之为精度

512
00:19:56,940 --> 00:19:59,730
和频率之类的东西，但他们你知道这些

513
00:19:59,730 --> 00:20:01,379
人称之为识别之类的

514
00:20:01,379 --> 00:20:03,570
东西 就像这样，

515
00:20:03,570 --> 00:20:05,100
高级别的概念是相同的，只是

516
00:20:05,100 --> 00:20:06,450
他们用来

517
00:20:06,450 --> 00:20:08,009
描述这些东西的术语会略有

518
00:20:08,009 --> 00:20:10,200
不同，所以当我们继续

519
00:20:10,200 --> 00:20:12,059
讨论一些哈娜（Hana）时，我会混淆，更热门的论文和

520
00:20:12,059 --> 00:20:13,499
d 超级论文 但希望它

521
00:20:13,499 --> 00:20:15,119
应该有意义 所以让我们

522
00:20:15,119 --> 00:20:16,679
谈谈我们将如何跟踪版本

523
00:20:16,679 --> 00:20:17,999
我们调用 Carbon Scotch 的频率以及我们

524
00:20:17,999 --> 00:20:20,070


525
00:20:20,070 --> 00:20:22,590
将查看我们可以删除的潜在版本的粒度

526
00:20:22,590 --> 00:20:25,259
并有一个 比较是否

527
00:20:25,259 --> 00:20:28,590
可以将它们放入或不可以

528
00:20:28,590 --> 00:20:32,789
好吧 所以再次四个索引会

529
00:20:32,789 --> 00:20:35,720
发生的是当我的事务运行

530
00:20:35,720 --> 00:20:39,480
并且我正在创建新的你知道我正在

531
00:20:39,480 --> 00:20:40,830
创建新的元组并放置新

532
00:20:40,830 --> 00:20:44,279
版本我必须存储它 在

533
00:20:44,279 --> 00:20:47,100
索引中，因为现在如果我尝试返回

534
00:20:47,100 --> 00:20:48,720
并阅读我刚刚写的相同内容，

535
00:20:48,720 --> 00:20:50,129
我希望能够

536
00:20:50,129 --> 00:20:52,320
通过索引并查看我自己的权利，如果

537
00:20:52,320 --> 00:20:53,879
您正在做 OCC 是一个您不做的私人工作空间

538
00:20:53,879 --> 00:20:55,710
这是因为您在最后上演了所有

539
00:20:55,710 --> 00:20:58,320
权限，但我们

540
00:20:58,320 --> 00:20:59,129
一直在谈论的是执行

541
00:20:59,129 --> 00:21:00,720
时间戳排序方法，您

542
00:21:00,720 --> 00:21:02,279
可以在该全局空间中应用该权限，

543
00:21:02,279 --> 00:21:03,450
因为这允许您对前面

544
00:21:03,450 --> 00:21:05,549
的其他事务进行特定读取

545
00:21:05,549 --> 00:21:07,950
你在 s 逻辑时间太长了，

546
00:21:07,950 --> 00:21:10,350
所以现在的

547
00:21:10,350 --> 00:21:13,679
问题是，如果我需要中止或

548
00:21:13,679 --> 00:21:15,509
清理版本，我需要

549
00:21:15,509 --> 00:21:18,149
确保删除

550
00:21:18,149 --> 00:21:20,850
与我需要删除的旧版本相对应的所有密钥

551
00:21:20,850 --> 00:21:22,980


552
00:21:22,980 --> 00:21:24,720
任何基本上这样做的方式是

553
00:21:24,720 --> 00:21:27,090
墙交易正在运行并且它正在

554
00:21:27,090 --> 00:21:29,730
更新索引我们只需要

555
00:21:29,730 --> 00:21:31,800
记录你知道我们插入了哪些键

556
00:21:31,800 --> 00:21:38,640
或者我们是否容易从

557
00:21:38,640 --> 00:21:40,080
我们的索引中失效，因为我们正在进行更改

558
00:21:40,080 --> 00:21:42,540
然后我们什么时候去 要提交或进行

559
00:21:42,540 --> 00:21:44,790
边界事务，我们必须让

560
00:21:44,790 --> 00:21:45,930
垃圾收集器启动并说

561
00:21:45,930 --> 00:21:49,290
好吧让我去清理让

562
00:21:49,290 --> 00:21:51,780
我去清理索引，

563
00:21:51,780 --> 00:21:52,800
因为这些是人们

564
00:21:52,800 --> 00:21:56,190
不应该看到的东西，所以 hyper 得到了

565
00:21:56,190 --> 00:22:00,480
围绕这一点，任何时候你都会

566
00:22:00,480 --> 00:22:03,870
修改一个被索引的属性，然后

567
00:22:03,870 --> 00:22:05,490
你把它当作一个删除，然后

568
00:22:05,490 --> 00:22:07,710
为那个事务插入一个插入，

569
00:22:07,710 --> 00:22:09,360
因为这样你就不必

570
00:22:09,360 --> 00:22:11,250
担心去寻找键并

571
00:22:11,250 --> 00:22:13,560
正确更新指针 你只是说

572
00:22:13,560 --> 00:22:15,090
这是来自密钥的旧版本

573
00:22:15,090 --> 00:22:17,040
和你删除它的索引他们让我

574
00:22:17,040 --> 00:22:20,280
插入一个新的所以我们没有

575
00:22:20,280 --> 00:22:22,620
在大部队中这样做我们做了一些非常

576
00:22:22,620 --> 00:22:24,450
非常愚蠢的事情就像我们完全愚蠢

577
00:22:24,450 --> 00:22:25,980
我不知道 为什么这是其中一

578
00:22:25,980 --> 00:22:26,970
件事就像学生这样做是

579
00:22:26,970 --> 00:22:28,350
因为它看起来

580
00:22:28,350 --> 00:22:29,700
使我们的

581
00:22:29,700 --> 00:22:31,320
基准测试的性能变得更好，直到

582
00:22:31,320 --> 00:22:32,730
后来我们就像哦，我们必须将其

583
00:22:32,730 --> 00:22:34,020
修改为 可以修复一些事情，

584
00:22:34,020 --> 00:22:36,450
比如天哪，他们做了一些坏事，

585
00:22:36,450 --> 00:22:38,550
我们不应该这样做，所以

586
00:22:38,550 --> 00:22:39,690
这就是我们在巴勒斯坦所做的，所以

587
00:22:39,690 --> 00:22:43,530
我们再次只将最旧的附加到

588
00:22:43,530 --> 00:22:46,980
最新的，是的，

589
00:22:46,980 --> 00:22:48,600
如果我有交易会发生什么 出现

590
00:22:48,600 --> 00:22:51,900
并说他们更新了一个权限，我们

591
00:22:51,900 --> 00:22:54,810
现在将这个键设置为 22 我会

592
00:22:54,810 --> 00:22:59,100
只追加一个新的挂件来指向

593
00:22:59,100 --> 00:23:01,170
我的表空间，但随后我会

594
00:23:01,170 --> 00:23:05,010
在我的索引中添加一个新条目来表示键 20

595
00:23:05,010 --> 00:23:07,170
- 2  - 这是它的版本，所以

596
00:23:07,170 --> 00:23:10,260
即使从逻辑上讲它们不是

597
00:23:10,260 --> 00:23:12,150
从索引的角度来看，相同的元组它们看起来

598
00:23:12,150 --> 00:23:13,220
像是分开的东西，

599
00:23:13,220 --> 00:23:16,650
所以我们遇到了麻烦，

600
00:23:16,650 --> 00:23:18,750
如果你尝试

601
00:23:18,750 --> 00:23:21,510
在同一个元组上再次更新相同的键，而不是

602
00:23:21,510 --> 00:23:24,150
在索引中创建一个新条目，我们

603
00:23:24,150 --> 00:23:26,550
实际上会去覆盖

604
00:23:26,550 --> 00:23:29,100
我们创建的以前的版本，所以在

605
00:23:29,100 --> 00:23:30,660
这种情况下，我会

606
00:23:30,660 --> 00:23:34,200
用现在的 33 我们的 3 3 3 替换 2 - 2 然后现在我

607
00:23:34,200 --> 00:23:36,710
也会更新我的索引并

608
00:23:36,710 --> 00:23:39,020
指向它，

609
00:23:39,020 --> 00:23:40,850
我每次都这样做 更新

610
00:23:40,850 --> 00:23:42,440
就对了，这就是二四四

611
00:23:42,440 --> 00:23:45,320
，我有一个更新条目指向

612
00:23:45,320 --> 00:23:47,510
这里的两个所以现在问题是当我们继续

613
00:23:47,510 --> 00:23:49,340
进行以及如何中止此

614
00:23:49,340 --> 00:23:51,919
事务时，我们不知道

615
00:23:51,919 --> 00:23:54,289
您知道的另一个是什么 2:00 到 2:30 3:00 我们

616
00:23:54,289 --> 00:23:57,380
插入，所以我们可以删除 4 4 4

617
00:23:57,380 --> 00:23:58,760
因为我们知道这是我们

618
00:23:58,760 --> 00:23:59,809
需要清理的版本 因为这是

619
00:23:59,809 --> 00:24:02,149
我们看到的 你知道你知道脏

620
00:24:02,149 --> 00:24:04,669
表空间或脏脏元组列表

621
00:24:04,669 --> 00:24:06,289
对于我们的交易，但我们不

622
00:24:06,289 --> 00:24:07,909
知道我们已经离开了那里

623
00:24:07,909 --> 00:24:10,340
里面的其他键，所以我们会运行一段

624
00:24:10,340 --> 00:24:11,690
时间运行一些基准测试，突然之间

625
00:24:11,690 --> 00:24:13,820
你会得到它是一个唯一的索引，你

626
00:24:13,820 --> 00:24:14,929
会得到一个错误并说一个

627
00:24:14,929 --> 00:24:16,610
键已经存在，即使

628
00:24:16,610 --> 00:24:17,929
表中的数字因为我们

629
00:24:17,929 --> 00:24:21,200
从中止的交易中泄露你的这些密钥

630
00:24:21,200 --> 00:24:24,919
所以你知道这很

631
00:24:24,919 --> 00:24:28,250
尴尬 这是愚蠢的 你知道

632
00:24:28,250 --> 00:24:29,990
这并不是

633
00:24:29,990 --> 00:24:33,049
关于你知道的论文的任何具体内容 你们阅读这

634
00:24:33,049 --> 00:24:34,399
只是表明

635
00:24:34,399 --> 00:24:36,380
即使你有这些事情也很难做到正确

636
00:24:36,380 --> 00:24:40,429
最好的意图，只是不跟踪

637
00:24:40,429 --> 00:24:41,960


638
00:24:41,960 --> 00:24:43,820
您所知道的所有更新的键或

639
00:24:43,820 --> 00:24:45,230
您在索引中修改的所有情况

640
00:24:45,230 --> 00:24:49,490
，最终可能会丢失一些东西，

641
00:24:49,490 --> 00:24:50,539
所以我们不再这样做了

642
00:24:50,539 --> 00:24:54,380
这很好，所以现在让我们谈谈

643
00:24:54,380 --> 00:24:56,059
我们实际上将如何跟踪

644
00:24:56,059 --> 00:24:58,450


645
00:24:58,450 --> 00:25:01,190
交易将创建的版本，这里有一个

646
00:25:01,190 --> 00:25:04,190
错字抱歉，所以

647
00:25:04,190 --> 00:25:05,630
我们谈论的第一种方法我们

648
00:25:05,630 --> 00:25:08,720
首先与 MVCC 第一讲中的两个，

649
00:25:08,720 --> 00:25:08,990


650
00:25:08,990 --> 00:25:11,740
这就是我们只有

651
00:25:11,740 --> 00:25:15,830
一些机制，事务

652
00:25:15,830 --> 00:25:17,960
线程或单独的垃圾接触

653
00:25:17,960 --> 00:25:20,029
线程可以通过我们的表并

654
00:25:20,029 --> 00:25:23,480
确定我们需要修剪的版本，如果

655
00:25:23,480 --> 00:25:25,370
后台清理

656
00:25:25,370 --> 00:25:26,809
是一个单独的线程 正确的

657
00:25:26,809 --> 00:25:28,820
清理技术是在

658
00:25:28,820 --> 00:25:30,529
事务或查询

659
00:25:30,529 --> 00:25:32,270
运行的地方，如果他们注意到他们有一个

660
00:25:32,270 --> 00:25:34,490
对任何事务都不可见的版本，

661
00:25:34,490 --> 00:25:36,169
那么他们会继续

662
00:25:36,169 --> 00:25:38,600
清理它，所以 hackathon 这样做是因为

663
00:25:38,600 --> 00:25:40,070
他们是从最旧到最新的，所以

664
00:25:40,070 --> 00:25:42,020
交易运行并且必须遍历

665
00:25:42,020 --> 00:25:42,980
原始链才能获得最新

666
00:25:42,980 --> 00:25:44,960
版本，他们会看到

667
00:25:44,960 --> 00:25:46,370
一堆他们知道

668
00:25:46,370 --> 00:25:47,960
正在回收碗的旧版本，他们会继续

669
00:25:47,960 --> 00:25:48,659
并在

670
00:25:48,659 --> 00:25:52,499
那里删除它们，交易级别的

671
00:25:52,499 --> 00:25:53,820
方法是 我们过去在 Peloton 中做的事情

672
00:25:53,820 --> 00:25:55,979
，这是事务

673
00:25:55,979 --> 00:25:57,149
将跟踪他们创建的所有版本的地方

674
00:25:57,149 --> 00:25:59,940
，然后当他们

675
00:25:59,940 --> 00:26:01,710
提交时，他们交出 是

676
00:26:01,710 --> 00:26:04,769
垃圾收集器的信息，然后他们可以

677
00:26:04,769 --> 00:26:06,989
查看哪些事务正在运行

678
00:26:06,989 --> 00:26:08,690
，它们的时间戳是什么，请

679
00:26:08,690 --> 00:26:11,909
原谅，他们可以识别

680
00:26:11,909 --> 00:26:14,190
哪些您知道哪些

681
00:26:14,190 --> 00:26:15,989
被这些事务无效的版本

682
00:26:15,989 --> 00:26:19,919
现在现在可以打印，最后一种方法

683
00:26:19,919 --> 00:26:21,960
是 基于纪元的方法，这

684
00:26:21,960 --> 00:26:23,399
与事务级别基本上相同，

685
00:26:23,399 --> 00:26:25,019
这里的想法是你会问

686
00:26:25,019 --> 00:26:27,299
你一堆交易，而

687
00:26:27,299 --> 00:26:28,979
不是完全在同一时间召开的批量会议，

688
00:26:28,979 --> 00:26:30,509
但你把它们放在同一个

689
00:26:30,509 --> 00:26:32,940
纪元下，这个 会好起来的，我们会

690
00:26:32,940 --> 00:26:34,080
在周一谈论 Beta 撤退时再次看到这一点，

691
00:26:34,080 --> 00:26:36,179
但基本上

692
00:26:36,179 --> 00:26:37,619
就像另一个计数器

693
00:26:37,619 --> 00:26:39,450
总是一次发生一样，我们会知道

694
00:26:39,450 --> 00:26:41,970
当我们从一个纪元进入下一个纪元时，我们

695
00:26:41,970 --> 00:26:43,320
会知道是否 有任何

696
00:26:43,320 --> 00:26:44,940
交易

697
00:26:44,940 --> 00:26:47,099
在前一个纪元中仍然可以看到某些东西，然后

698
00:26:47,099 --> 00:26:48,690
如果没有，那么我们知道

699
00:26:48,690 --> 00:26:50,190
在那个纪元中无效的任何东西

700
00:26:50,190 --> 00:26:53,729
似乎都可以很好地回收 再一次，

701
00:26:53,729 --> 00:26:56,009
我们会看到更多关于种子这种

702
00:26:56,009 --> 00:26:58,320
方法或技术

703
00:26:58,320 --> 00:26:59,609
在星期一当你阅读那篇论文时在树

704
00:26:59,609 --> 00:27:01,619


705
00:27:01,619 --> 00:27:03,299


706
00:27:03,299 --> 00:27:04,979
的节拍

707
00:27:04,979 --> 00:27:07,710
中使用 现在是 Sam 10 的时候了，我将

708
00:27:07,710 --> 00:27:10,499
更新我创建的新版本，

709
00:27:10,499 --> 00:27:13,710
然后现在因为我知道这

710
00:27:13,710 --> 00:27:15,899
是我看到的最新

711
00:27:15,899 --> 00:27:17,879
版本的版本，然后我创建了我的

712
00:27:17,879 --> 00:27:20,249
新版本，因此我知道 对于此

713
00:27:20,249 --> 00:27:23,700
事务，现在可能会

714
00:27:23,700 --> 00:27:25,379
在下面回收 2，因此如果我的事务

715
00:27:25,379 --> 00:27:27,419
提交，那么我知道我可以继续

716
00:27:27,419 --> 00:27:30,259
清理

717
00:27:30,259 --> 00:27:32,220
我的旧版本事务本地空间中的两侧记录

718
00:27:32,220 --> 00:27:33,690
，这只是指向

719
00:27:33,690 --> 00:27:36,690
此位置的指针和 这可以工作

720
00:27:36,690 --> 00:27:38,729
这些指针可以使用这些指针

721
00:27:38,729 --> 00:27:40,859
因为我们不会最终我们不会

722
00:27:40,859 --> 00:27:42,659
正确移动这个东西我们没有

723
00:27:42,659 --> 00:27:43,919
进行压缩我们可以将

724
00:27:43,919 --> 00:27:45,779
它从一个块移动到坚果我们只是

725
00:27:45,779 --> 00:27:49,080
说这个东西有 现在留在那里我

726
00:27:49,080 --> 00:27:52,559
对 B 同样的事情做一个更新 我

727
00:27:52,559 --> 00:27:54,840
有我知道我创建的旧版本

728
00:27:54,840 --> 00:27:56,700
我在以前的旧版本之后创建了我的新

729
00:27:56,700 --> 00:27:59,190
版本 我现在在我的旧

730
00:27:59,190 --> 00:28:01,529
版本列表中更新它然后当我的事务

731
00:28:01,529 --> 00:28:02,309
继续并提交时

732
00:28:02,309 --> 00:28:04,169
我只是通过这个

733
00:28:04,169 --> 00:28:05,849
然后我们查看垃圾收集器的信息，

734
00:28:05,849 --> 00:28:09,330
并说好这个提交时间戳

735
00:28:09,330 --> 00:28:11,399
是 15，所以我知道这些版本

736
00:28:11,399 --> 00:28:15,509
的任何小于 15 的人，其

737
00:28:15,509 --> 00:28:19,080
最高时间戳小于 15

738
00:28:19,080 --> 00:28:22,259
应该能够正确地看到它们，所以如果现在

739
00:28:22,259 --> 00:28:24,479
没有

740
00:28:24,479 --> 00:28:26,609
时间戳小于 15 的事务，但我知道这些

741
00:28:26,609 --> 00:28:28,169
版本是可移动的

742
00:28:28,169 --> 00:28:31,739


743
00:28:31,739 --> 00:28:33,389


744
00:28:33,389 --> 00:28:36,509


745
00:28:36,509 --> 00:28:39,149
我可以拥有的最低时间戳是什么

746
00:28:39,149 --> 00:28:40,619
，有人

747
00:28:40,619 --> 00:28:41,729
实际上仍然可以看到这个，所以如果没有

748
00:28:41,729 --> 00:28:43,109
事务低于该

749
00:28:43,109 --> 00:28:53,119
时间戳，那么我可以删除它是的，是的，

750
00:28:56,210 --> 00:28:58,049
这个问题是我是否有另一个

751
00:28:58,049 --> 00:28:59,580
正在运行的事务

752
00:28:59,580 --> 00:29:02,099
杜松子酒的时间戳你不能因为

753
00:29:02,099 --> 00:29:05,519
这个人已经有十个所以九个好吧所以

754
00:29:05,519 --> 00:29:08,429
他来了他会读他

755
00:29:08,429 --> 00:29:09,509
会读这个因为九

756
00:29:09,509 --> 00:29:12,269
是不是在 1 和 15 之间，

757
00:29:12,269 --> 00:29:18,450
所以是的，他读了 a - 你又知道了，

758
00:29:18,450 --> 00:29:21,119
垃圾医生知道，就像它知道

759
00:29:21,119 --> 00:29:22,139
它还有什么其他东西一样，你必须知道哪些

760
00:29:22,139 --> 00:29:23,879
事务正在运行，所以在最喜欢的人中，

761
00:29:23,879 --> 00:29:25,049
他们谈论这个链接列表到底是怎么回事，它

762
00:29:25,049 --> 00:29:26,249
是我的

763
00:29:26,249 --> 00:29:27,570
事务 ID，你可以

764
00:29:27,570 --> 00:29:29,249
看看头部或取决于什么顺序是

765
00:29:29,249 --> 00:29:30,659
找出最低

766
00:29:30,659 --> 00:29:32,519
的那个是低水位

767
00:29:32,519 --> 00:29:33,690
还是高更多取决于你在

768
00:29:33,690 --> 00:29:35,700
看什么，这个想法是我知道

769
00:29:35,700 --> 00:29:36,929
哪些实际上在运行 如果

770
00:29:36,929 --> 00:29:38,219
有一个以时间戳 9 运行的事务，

771
00:29:38,219 --> 00:29:41,580
那么 9 小于 15

772
00:29:41,580 --> 00:29:43,769
，因此它可能仍会

773
00:29:43,769 --> 00:29:46,139
读取这些内容，因此我无法

774
00:29:46,139 --> 00:29:49,259
回收它们，它可能永远不会读取 B 但我

775
00:29:49,259 --> 00:29:50,399
不知道，因为我不知道

776
00:29:50,399 --> 00:29:51,389
交易实际上

777
00:29:51,389 --> 00:29:53,609
要做什么，所以我 必须保守并

778
00:29:53,609 --> 00:29:57,619
引导你所知道的一切，让它保持

779
00:29:59,089 --> 00:30:02,159
正确，就像你可以

780
00:30:02,159 --> 00:30:03,570
使用hyper所做的排序链表

781
00:30:03,570 --> 00:30:04,889
你可以只记录一个

782
00:30:04,889 --> 00:30:08,779
值有不同的方式我做得

783
00:30:08,779 --> 00:30:11,300
很好

784
00:30:11,300 --> 00:30:13,790
所以下一个问题是多久 我们是否

785
00:30:13,790 --> 00:30:15,700
要调用垃圾

786
00:30:15,700 --> 00:30:19,040
收集器，如果

787
00:30:19,040 --> 00:30:20,840
我们在垃圾收集中非常积极，

788
00:30:20,840 --> 00:30:22,790
那么我们可以

789
00:30:22,790 --> 00:30:24,350
尽快释放空间，

790
00:30:24,350 --> 00:30:25,550
前提是没有您

791
00:30:25,550 --> 00:30:27,400
知道的长时间闲置的事务 时间戳，

792
00:30:27,400 --> 00:30:30,350
但问题将是将

793
00:30:30,350 --> 00:30:32,870
更快地回收空间，但现在我们

794
00:30:32,870 --> 00:30:33,890
最终可能会减慢事务速度，

795
00:30:33,890 --> 00:30:35,840
因为现在垃圾

796
00:30:35,840 --> 00:30:36,980
收集线程如果在后台运行，

797
00:30:36,980 --> 00:30:40,340
它们将开始使用 CPU

798
00:30:40,340 --> 00:30:42,080
，这会消耗掉周期并使

799
00:30:42,080 --> 00:30:43,970
您的查询和事务运行速度较慢

800
00:30:43,970 --> 00:30:46,700
，显然如果我们这样做 - 我们不那么

801
00:30:46,700 --> 00:30:47,930
积极并且运行它并且 - 并且

802
00:30:47,930 --> 00:30:52,130
经常并且现在我们将拥有

803
00:30:52,130 --> 00:30:53,570
数据库的大小 变得更大，

804
00:30:53,570 --> 00:30:55,130
因为我们没有

805
00:30:55,130 --> 00:30:57,740
像我们应该的那样尽快回收版本 Virgin

806
00:30:57,740 --> 00:30:59,240
链可能会变得更长，

807
00:30:59,240 --> 00:31:00,590
这意味着查询需要更长的时间

808
00:31:00,590 --> 00:31:01,700
才能找到他们想要的确切版本

809
00:31:01,700 --> 00:31:03,950
，所以如果这

810
00:31:03,950 --> 00:31:05,240
两者之间的微妙平衡 我

811
00:31:05,240 --> 00:31:08,240
实际上认为 hyper 方法

812
00:31:08,240 --> 00:31:10,520
比后台垃圾

813
00:31:10,520 --> 00:31:12,260
收集更好，所以你再次

814
00:31:12,260 --> 00:31:13,780
定期运行它你连续运行它

815
00:31:13,780 --> 00:31:15,920
这就是 hyper 所做的 这就是我们

816
00:31:15,920 --> 00:31:19,700
所做的 这就是没有系统所做的 所以周期性的

817
00:31:19,700 --> 00:31:21,700
眼睛意味着在某个固定的时间间隔

818
00:31:21,700 --> 00:31:25,100
或者在达到某个阈值时，

819
00:31:25,100 --> 00:31:28,310
例如如果我知道我有 20% 的

820
00:31:28,310 --> 00:31:30,980
记忆被象牙可

821
00:31:30,980 --> 00:31:32,810
认领的版本所使用，我可以以某种方式

822
00:31:32,810 --> 00:31:34,160
计算出来，然后我开始清理

823
00:31:34,160 --> 00:31:36,080
垃圾并找到正确

824
00:31:36,080 --> 00:31:37,640
的 JVM 类型

825
00:31:37,640 --> 00:31:39,110
当你让你的堆大小

826
00:31:39,110 --> 00:31:40,940
达到一定百分比时，它会做类似的事情，

827
00:31:40,940 --> 00:31:43,910
然后它开始，所以这只是说

828
00:31:43,910 --> 00:31:45,680
，我会在后台运行它

829
00:31:45,680 --> 00:31:46,850
线程并每隔一段时间运行一次

830
00:31:46,850 --> 00:31:48,680
，对于像 hackaton 这样的一些系统，

831
00:31:48,680 --> 00:31:51,350
他们可以确定如果我的

832
00:31:51,350 --> 00:31:54,410
负载或我的版本的流失率真的

833
00:31:54,410 --> 00:31:57,350
很高那么我可以做到这一点我可以

834
00:31:57,350 --> 00:32:02,780
更频繁地运行这个

835
00:32:02,780 --> 00:32:04,370
超级偷猎是运行

836
00:32:04,370 --> 00:32:06,470
垃圾收集

837
00:32:06,470 --> 00:32:09,830
程序一直是正常

838
00:32:09,830 --> 00:32:11,180
事务处理或查询

839
00:32:11,180 --> 00:32:16,820
执行步骤的一部分，所以在超级中

840
00:32:16,820 --> 00:32:18,140
他们自己提交，所以只要

841
00:32:18,140 --> 00:32:20,150
事务提交，他们就会

842
00:32:20,150 --> 00:32:21,590
让那个线程通过，看看

843
00:32:21,590 --> 00:32:23,150
我能做什么 回收什么我可以清理拖把

844
00:32:23,150 --> 00:32:23,950


845
00:32:23,950 --> 00:32:28,990
清理新版 hyper 中的蒸汽版本

846
00:32:28,990 --> 00:32:31,330
这是

847
00:32:31,330 --> 00:32:33,340
快速转动漂亮的氧气所以我

848
00:32:33,340 --> 00:32:34,390
称之为与合作清洁的合作查询执行部分相同的事情

849
00:32:34,390 --> 00:32:36,280


850
00:32:36,280 --> 00:32:37,360
等待说等待黑客马拉松在

851
00:32:37,360 --> 00:32:39,640
何处添加 如果

852
00:32:39,640 --> 00:32:41,530
我看到需要清理的东西，我正在运行我的查询，让

853
00:32:41,530 --> 00:32:42,820
我继续清理它们，

854
00:32:42,820 --> 00:32:45,340
但是因为 hyper 正在为最老的新闻做新闻，

855
00:32:45,340 --> 00:32:46,840
所以他们没有尘土飞扬的眼角 r

856
00:32:46,840 --> 00:32:49,480
hackathon 有一个问题，你

857
00:32:49,480 --> 00:32:50,650
可以拥有从未

858
00:32:50,650 --> 00:32:52,330
访问过的版本，

859
00:32:52,330 --> 00:32:54,970
如果你阅读它，你会看到它

860
00:32:54,970 --> 00:32:58,960
并且你可以回收它，它们永远不会被正确回收，所以我想我

861
00:32:58,960 --> 00:33:02,320
想这样做，尽管我们的方式

862
00:33:02,320 --> 00:33:04,300
我们的系统有点

863
00:33:04,300 --> 00:33:06,370
设置现在我们的垃圾收集

864
00:33:06,370 --> 00:33:08,020
器与其他位或后台清理进程集成在一起，这些

865
00:33:08,020 --> 00:33:11,140
进程执行了

866
00:33:11,140 --> 00:33:12,400
许多其他内存管理工作，

867
00:33:12,400 --> 00:33:14,020
所以我认为我们不能切换到

868
00:33:14,020 --> 00:33:15,940
这个，我认为我们被卡住了 有了这个，

869
00:33:15,940 --> 00:33:17,260
但我还是更喜欢这个，因为

870
00:33:17,260 --> 00:33:19,390
如果我实际上有很多

871
00:33:19,390 --> 00:33:21,070
查询可以很好地进行大量更新，

872
00:33:21,070 --> 00:33:22,630
这有点像他们

873
00:33:22,630 --> 00:33:24,370
自我调节的那样，因为我在

874
00:33:24,370 --> 00:33:26,590
运行查询时创建了很多版本

875
00:33:26,590 --> 00:33:27,940
查询将清理声称旧的版本

876
00:33:27,940 --> 00:33:31,180
，如果查询运行

877
00:33:31,180 --> 00:33:32,230
速度较慢，因为我有很多版本

878
00:33:32,230 --> 00:33:34,000
要回收，实际上

879
00:33:34,000 --> 00:33:36,220
最终会

880
00:33:36,220 --> 00:33:39,280
减慢我创建旧版本的速度，所以我喜欢

881
00:33:39,280 --> 00:33:42,850
那个模型 现在  问题

882
00:33:42,850 --> 00:33:45,010
是我们将如何在

883
00:33:45,010 --> 00:33:46,960
内部组织垃圾收集器的元数据，

884
00:33:46,960 --> 00:33:50,470
以确定我们是否可以

885
00:33:50,470 --> 00:33:52,690
继续并一次又一次地回收东西，

886
00:33:52,690 --> 00:33:53,950


887
00:33:53,950 --> 00:33:55,930
在我们是否将拥有某种

888
00:33:55,930 --> 00:33:58,360
细粒度跟踪信息之间有更多的权衡 说

889
00:33:58,360 --> 00:33:59,830
这是一个可以

890
00:33:59,830 --> 00:34:01,510
在这个时间戳内声明的单一版本，或者

891
00:34:01,510 --> 00:34:03,700
我们是否可以将它们组合在一起并且

892
00:34:03,700 --> 00:34:05,320
只是在多个元组中有一个时间戳，

893
00:34:05,320 --> 00:34:07,060
并且可以分摊

894
00:34:07,060 --> 00:34:09,130
跟踪信息的存储成本，

895
00:34:09,130 --> 00:34:11,168
以换取

896
00:34:11,168 --> 00:34:12,699
可能不回收 事情尽可能快，

897
00:34:12,699 --> 00:34:15,850
所以这就是

898
00:34:15,850 --> 00:34:17,679
我现在刚刚说的任何事情，所以单一

899
00:34:17,679 --> 00:34:20,380
版本跟踪将用于每个

900
00:34:20,380 --> 00:34:22,449
元组我知道他们的版本

901
00:34:22,449 --> 00:34:24,550
是什么，他们的时间戳是什么，

902
00:34:24,550 --> 00:34:27,070
然后当垃圾车启动时我

903
00:34:27,070 --> 00:34:28,540
可以做 那时的决定

904
00:34:28,540 --> 00:34:30,130
决定它是否可以 - 如果您正在进行连续或合作清洁，我们可以要求

905
00:34:30,130 --> 00:34:32,739
您免费获得这种东西吗？

906
00:34:32,739 --> 00:34:34,659


907
00:34:34,659 --> 00:34:36,850
g 因为当我扫描

908
00:34:36,850 --> 00:34:37,869
并

909
00:34:37,869 --> 00:34:39,998
尝试找到我想要的版本时，

910
00:34:39,998 --> 00:34:42,549
我最终会在

911
00:34:42,549 --> 00:34:44,859
找到它们时清理它们，并且无论如何我已经将该

912
00:34:44,859 --> 00:34:46,389
元数据存储在

913
00:34:46,389 --> 00:34:48,279
元组或其他记录的标题中，所以它不是

914
00:34:48,279 --> 00:34:50,699
就像我需要单独对这些东西进行排序一样

915
00:34:50,699 --> 00:34:53,559
，组版本是我

916
00:34:53,559 --> 00:34:55,029
之前在真空线程的一个示例中保证的内容，

917
00:34:55,029 --> 00:34:57,099
并且这个想法就在这里，因为我

918
00:34:57,099 --> 00:34:59,890
说这里有一堆元组，这些元组

919
00:34:59,890 --> 00:35:01,660
在某个时间戳被交易无效

920
00:35:01,660 --> 00:35:03,519
，所以任何 小于

921
00:35:03,519 --> 00:35:06,009
该时间戳任何事务都有一个

922
00:35:06,009 --> 00:35:07,180
更少的时间戳，这仍然

923
00:35:07,180 --> 00:35:09,009
可能会看到它们，否则它们不会

924
00:35:09,009 --> 00:35:10,089
很好，

925
00:35:10,089 --> 00:35:12,039
所以再次跟踪事物的开销较少，

926
00:35:12,039 --> 00:35:17,019
但它可能会

927
00:35:17,019 --> 00:35:18,400
延迟我们可以回收某些东西并

928
00:35:18,400 --> 00:35:21,099
取回内存的时间，所以有一个

929
00:35:21,099 --> 00:35:23,470
Hana 论文中的第三种方法，

930
00:35:23,470 --> 00:35:24,970
你们没有读过，但我

931
00:35:24,970 --> 00:35:27,609
认为超级论文提到了这一点，

932
00:35:27,609 --> 00:35:31,029


933
00:35:31,029 --> 00:35:34,779
如果你知道，你实际上可以从整个表中回收所有版本

934
00:35:34,779 --> 00:35:37,029
现在没有事务正在运行

935
00:35:37,029 --> 00:35:38,380
，并且可以访问它，

936
00:35:38,380 --> 00:35:41,019
所以它是如何工作的，因为

937
00:35:41,019 --> 00:35:44,230
记得我说过这里有一个例子，就像

938
00:35:44,230 --> 00:35:45,009


939
00:35:45,009 --> 00:35:47,380
在时间戳 9 处可能是另一个事务可以

940
00:35:47,380 --> 00:35:50,230
读取它可以读取 B 但我们不知道

941
00:35:50,230 --> 00:35:52,029
因为我们不知道该

942
00:35:52,029 --> 00:35:54,400
事务将执行哪些查询，但在

943
00:35:54,400 --> 00:35:56,079
某些情况下，如果您将

944
00:35:56,079 --> 00:35:57,700
事务作为准备好的语句或

945
00:35:57,700 --> 00:35:59,999
存储过程执行，那么您

946
00:35:59,999 --> 00:36:02,230
可能知道它

947
00:36:02,230 --> 00:36:04,569
可以像准备好的语句一样执行的所有可能的查询

948
00:36:04,569 --> 00:36:06,249
就像一个预定义的函数

949
00:36:06,249 --> 00:36:08,019
您可以在数据库

950
00:36:08,019 --> 00:36:09,819
系统中安装它说运行一些事务逻辑，

951
00:36:09,819 --> 00:36:11,259
例如我将

952
00:36:11,259 --> 00:36:12,910
调用查询，以便您可以

953
00:36:12,910 --> 00:36:14,910
提前查看所有查询的内容

954
00:36:14,910 --> 00:36:18,039
并非总是如此，但有时如果

955
00:36:18,039 --> 00:36:23,170
一切都预先确定了

956
00:36:23,170 --> 00:36:25,180
我系统中的操作，则可以 如果我知道

957
00:36:25,180 --> 00:36:27,279
他们可能会执行哪些查询，那么我

958
00:36:27,279 --> 00:36:28,480
知道他们很难处理哪些表，尽管

959
00:36:28,480 --> 00:36:30,400
他们会触及，我看到他们

960
00:36:30,400 --> 00:36:32,259
是他们 他们永远无法触及

961
00:36:32,259 --> 00:36:34,299
特定的表，然后我可以继续

962
00:36:34,299 --> 00:36:36,430
回收整个表的所有版本，

963
00:36:36,430 --> 00:36:38,650
而无需进行任何您知道的

964
00:36:38,650 --> 00:36:40,779
细粒度跟踪，以防 Hana 他们正在

965
00:36:40,779 --> 00:36:43,660
执行时间旅行存储，因此对于

966
00:36:43,660 --> 00:36:45,819
给定的表所有 版本在

967
00:36:45,819 --> 00:36:47,410
旁边，另一个你知道另一个

968
00:36:47,410 --> 00:36:49,420
表空间所以我确实吹走了

969
00:36:49,420 --> 00:36:52,029
整个时间旅行存储空间

970
00:36:52,029 --> 00:36:53,739
而无需做任何你知道任何

971
00:36:53,739 --> 00:36:56,170
检查他们的时间戳它

972
00:36:56,170 --> 00:36:57,819
基本上就像一个拖放表

973
00:36:57,819 --> 00:36:59,920
并再次创建它这是超级

974
00:36:59,920 --> 00:37:03,789
再次快速 这是这是这是一个正如

975
00:37:03,789 --> 00:37:05,499
我所说的特殊情况或极端情况，

976
00:37:05,499 --> 00:37:07,599
如果您的交易如果您的

977
00:37:07,599 --> 00:37:09,549
应用程序正在调用一堆存储

978
00:37:09,549 --> 00:37:11,229
过程，那么您可以做到这一点，

979
00:37:11,229 --> 00:37:13,539
大多数系统不会这样做，

980
00:37:13,539 --> 00:37:15,640
尽管对，我 不要认为如果您正在

981
00:37:15,640 --> 00:37:17,589
执行 Delta 存储或

982
00:37:17,589 --> 00:37:18,910
仅附加存储，其中

983
00:37:18,910 --> 00:37:21,069
版本与常规元组

984
00:37:21,069 --> 00:37:22,959
或 Delta 记录混合在一起，我认为这

985
00:37:22,959 --> 00:37:25,059
实际上行不通，这

986
00:37:25,059 --> 00:37:26,469
有点 Hana 分析的一个特例

987
00:37:26,469 --> 00:37:30,640


988
00:37:30,640 --> 00:37:34,599


989
00:37:34,599 --> 00:37:38,799


990
00:37:38,799 --> 00:37:40,509


991
00:37:40,509 --> 00:37:43,479


992
00:37:43,479 --> 00:37:44,559
我们的

993
00:37:44,559 --> 00:37:47,259
活动交易以及

994
00:37:47,259 --> 00:37:48,670
我们可以处理的回收旧版本是什么

995
00:37:48,670 --> 00:37:50,049
，我们想这样做我还没有

996
00:37:50,049 --> 00:37:52,329
获得任何闩锁所以这是我

997
00:37:52,329 --> 00:37:53,799
之前在超级论文中看到的他们

998
00:37:53,799 --> 00:37:55,749
维护一个我可以的无闩锁链接列表

999
00:37:55,749 --> 00:37:57,099
保持相当有效，

1000
00:37:57,099 --> 00:37:58,719
我可以用它来弄清楚我

1001
00:37:58,719 --> 00:38:02,859
当前的事务是什么，所以一个

1002
00:38:02,859 --> 00:38:05,289
需要理解的重要概念是，

1003
00:38:05,289 --> 00:38:07,779
当我们

1004
00:38:07,779 --> 00:38:09,849
在快照隔离下实际运行查询时，

1005
00:38:09,849 --> 00:38:12,039
我们不能有任何误报或

1006
00:38:12,039 --> 00:38:14,680
丢失数据的漏报权，我们

1007
00:38:14,680 --> 00:38:16,660
实际上应该看到，但不知何故我们错过了

1008
00:38:16,660 --> 00:38:19,239
它，对于垃圾收集，我们

1009
00:38:19,239 --> 00:38:20,739
实际上可能在这里有点松散

1010
00:38:20,739 --> 00:38:22,959
，如果我们最终遗漏了

1011
00:38:22,959 --> 00:38:25,630
一些正确的东西也没关系，所以如果我的 ga  rbage

1012
00:38:25,630 --> 00:38:27,670
spectre 运行，在同一时刻，

1013
00:38:27,670 --> 00:38:29,440
另一个线程提交了一个事务，

1014
00:38:29,440 --> 00:38:31,359
其中包含一堆元组，这些元组正在

1015
00:38:31,359 --> 00:38:32,680
回收一堆回收良好的物理版本

1016
00:38:32,680 --> 00:38:35,019
，如果你

1017
00:38:35,019 --> 00:38:37,209
知道我是否最终在地毯上丢失了，我

1018
00:38:37,209 --> 00:38:39,009
应该在它的过程中丢失它

1019
00:38:39,009 --> 00:38:41,440
你知道

1020
00:38:41,440 --> 00:38:44,589
当前调用的路径谁在乎因为

1021
00:38:44,589 --> 00:38:46,209
下次我跑来跑去然后

1022
00:38:46,209 --> 00:38:49,930
我就能看到它所以我们可以使用我们

1023
00:38:49,930 --> 00:38:52,269
不需要你知道我们

1024
00:38:52,269 --> 00:38:53,890
不需要 你知道

1025
00:38:53,890 --> 00:38:56,259
对关键部分的超级严密保护

1026
00:38:56,259 --> 00:38:58,299
我们决定如何回收

1027
00:38:58,299 --> 00:39:00,759
东西我们可能知道一些你

1028
00:39:00,759 --> 00:39:01,959
知道的东西至少一次和第二

1029
00:39:01,959 --> 00:39:04,150
次我们会看到它

1030
00:39:04,150 --> 00:39:05,920
所以这是现在的重要部分

1031
00:39:05,920 --> 00:39:07,650
超级论文的主要

1032
00:39:07,650 --> 00:39:09,490
贡献之一，

1033
00:39:09,490 --> 00:39:10,900
虽然他们没有发明这个

1034
00:39:10,900 --> 00:39:12,940
区间的东西，但它实际上

1035
00:39:12,940 --> 00:39:16,180
来自于 Hana 论文，但它基本上

1036
00:39:16,180 --> 00:39:17,440
是说你将如何

1037
00:39:17,440 --> 00:39:19,180
确定某物是否是索赔人，

1038
00:39:19,180 --> 00:39:21,850
所以 f 或者这个时间戳，这

1039
00:39:21,850 --> 00:39:23,020
就是他们在论文中所说的传统垃圾

1040
00:39:23,020 --> 00:39:24,790
收集，这只是

1041
00:39:24,790 --> 00:39:26,770
我知道

1042
00:39:26,770 --> 00:39:29,050
我所有活动事务的最小时间戳是多少，

1043
00:39:29,050 --> 00:39:31,300
因此任何小于那个

1044
00:39:31,300 --> 00:39:33,400
时间戳的东西对任何人都是不可见的

1045
00:39:33,400 --> 00:39:34,900
那些活跃的交易，因此

1046
00:39:34,900 --> 00:39:38,050
我可以继续，我们

1047
00:39:38,050 --> 00:39:40,000
声称间隔方法会

1048
00:39:40,000 --> 00:39:43,900
更狡猾一点，然后我们

1049
00:39:43,900 --> 00:39:48,210
现在可以查看时间戳的范围并

1050
00:39:48,210 --> 00:39:50,890
确定是否存在不存在的党派

1051
00:39:50,890 --> 00:39:52,840
版本更改 完全可见

1052
00:39:52,840 --> 00:39:55,780
，而不是实际

1053
00:39:55,780 --> 00:39:58,270
等待您知道首先取出最旧的

1054
00:39:58,270 --> 00:40:00,880
并按时间戳顺序修剪它，

1055
00:40:00,880 --> 00:40:02,950
我们实际上可以切除

1056
00:40:02,950 --> 00:40:05,740
不可见的范围重新连接

1057
00:40:05,740 --> 00:40:08,620
维珍链，一切

1058
00:40:08,620 --> 00:40:10,450
都很好 因为每个人都可以

1059
00:40:10,450 --> 00:40:11,590
看到任何你知道他们

1060
00:40:11,590 --> 00:40:13,630
应该看到的东西 所以棘手的

1061
00:40:13,630 --> 00:40:14,920
事情是我们如何确定这些

1062
00:40:14,920 --> 00:40:17,920
范围以及我们如何对 ou 进行巩固

1063
00:40:17,920 --> 00:40:19,980
r 原始链来删除那些

1064
00:40:19,980 --> 00:40:23,560
不可见的范围 所以假设现在我们

1065
00:40:23,560 --> 00:40:25,390
有一个像这样的简单示例 我们有

1066
00:40:25,390 --> 00:40:28,260
一个交易，他将读取正确的

1067
00:40:28,260 --> 00:40:31,810
交易将更新一个高

1068
00:40:31,810 --> 00:40:35,290
，所以现在我们有一个旧版本或

1069
00:40:35,290 --> 00:40:37,720
一个我们最终 认为我们要

1070
00:40:37,720 --> 00:40:39,220
删除的是这个人，他

1071
00:40:39,220 --> 00:40:41,860
在 25 时执行并提交，所以

1072
00:40:41,860 --> 00:40:43,510
现在我们有另一个事务

1073
00:40:43,510 --> 00:40:47,080
伴随更新 30 然后提交 35

1074
00:40:47,080 --> 00:40:49,870
它不是在这一点上，这里有两个是

1075
00:40:49,870 --> 00:40:52,930
回收 Abul 因为唯一的另一个

1076
00:40:52,930 --> 00:40:55,210
正在运行的事务是第一个

1077
00:40:55,210 --> 00:40:58,000
在这里他在时间戳 10 所以他

1078
00:40:58,000 --> 00:41:01,810
永远看不到 25 或 35 他也看不到这个

1079
00:41:01,810 --> 00:41:04,030
a3 但在快照隔离下

1080
00:41:04,030 --> 00:41:06,160
他不被允许所以我们有这个

1081
00:41:06,160 --> 00:41:07,750
人我们需要继续 并

1082
00:41:07,750 --> 00:41:10,840
删除所以如果我们正在做时间戳

1083
00:41:10,840 --> 00:41:13,030
比较那么我们的垃圾收集

1084
00:41:13,030 --> 00:41:14,650
器不能删除两个因为我们的高

1085
00:41:14,650 --> 00:41:16,000
水印是低水印是

1086
00:41:16,000 --> 00:41:17,650
不准确的最低时间戳

1087
00:41:17,650 --> 00:41:21,009
并且是 10 因此 25 大于

1088
00:41:21,009 --> 00:41:24,009
10 所以我们可以' 删除 这个但是如果我们正在

1089
00:41:24,009 --> 00:41:25,960
做基于间隔的方法那么

1090
00:41:25,960 --> 00:41:27,670
我们就不能回收这个因为

1091
00:41:27,670 --> 00:41:30,730
时间戳 10 不与

1092
00:41:30,730 --> 00:41:33,369
这个版本的生命周期范围 25 和 35 相交

1093
00:41:33,369 --> 00:41:36,099
10 永远不会看到这个东西

1094
00:41:36,099 --> 00:41:39,999
所以我们继续并删除它 对于这种

1095
00:41:39,999 --> 00:41:41,440
方法，如果您只使用笔

1096
00:41:41,440 --> 00:41:44,859
存储，这很容易做到，因为我

1097
00:41:44,859 --> 00:41:47,349
现在要做的只是更新，如果我

1098
00:41:47,349 --> 00:41:48,789
从最旧到最新，我可以只更新

1099
00:41:48,789 --> 00:41:51,099
a1 的指针，现在将其指向

1100
00:41:51,099 --> 00:41:54,009
3 然后现在基本上丢失了 2

1101
00:41:54,009 --> 00:41:55,150
，我可以继续并回收

1102
00:41:55,150 --> 00:41:57,339
它，因为我需要

1103
00:41:57,339 --> 00:41:59,980
重建元组的一切只是说出你

1104
00:41:59,980 --> 00:42:01,180
知道的这个元组的版本

1105
00:42:01,180 --> 00:42:03,910
和 Pickler 时间戳它包含

1106
00:42:03,910 --> 00:42:06,130
在元组本身中，因为又是一个 pen

1107
00:42:06,130 --> 00:42:09,069
仅具有所有属性

1108
00:42:09,069 --> 00:42:11,170
，但如果您正在执行

1109
00:42:11,170 --> 00:42:12,880
delta 存储，则现在更难做到，因为您可能没有

1110
00:42:12,880 --> 00:42:15,249
所有属性，所以让我们看看

1111
00:42:15,249 --> 00:42:17,339
这里的示例，假设我有一个

1112
00:42:17,339 --> 00:42:21,009
正确的元组，即时间戳 60，然后我

1113
00:42:21,009 --> 00:42:24,039
有一个 像t这样的长版本链 他所以

1114
00:42:24,039 --> 00:42:26,289
我现在有了我的第一笔交易，他

1115
00:42:26,289 --> 00:42:28,539
在时间戳 15 上运行，所以我再次需要看到在时间戳

1116
00:42:28,539 --> 00:42:31,140
为 15 或更少的已提交事务中存在的元组版本，

1117
00:42:31,140 --> 00:42:33,690


1118
00:42:33,690 --> 00:42:36,730
所以我可以

1119
00:42:36,730 --> 00:42:40,539
在这里读取 10，我的另一个人在这里他在 他

1120
00:42:40,539 --> 00:42:44,680
将读取 55 及以下的任何内容，

1121
00:42:44,680 --> 00:42:47,289
因此这意味着

1122
00:42:47,289 --> 00:42:50,349
这里的这个基本元组块可能会被回收

1123
00:42:50,349 --> 00:42:53,049
而不是 50，但所有这些其他的都在这里

1124
00:42:53,049 --> 00:42:54,880
我们回收了一点，但现在

1125
00:42:54,880 --> 00:42:57,430
问题是因为我们正在做 Delta

1126
00:42:57,430 --> 00:42:59,470
存储一些 其中一些具有接触

1127
00:42:59,470 --> 00:43:00,640
属性 - 其中一些是接触

1128
00:43:00,640 --> 00:43:02,140
属性之一，因此当我们进行

1129
00:43:02,140 --> 00:43:04,690
合并时，我们有点需要采用

1130
00:43:04,690 --> 00:43:06,759
联合和这些不同的 Delta

1131
00:43:06,759 --> 00:43:09,039
记录，并且在我们的最终压缩中只有对特定属性的最新版本

1132
00:43:09,039 --> 00:43:12,460
或最新修改

1133
00:43:12,460 --> 00:43:14,589
或

1134
00:43:14,589 --> 00:43:17,109
合并 Delta 记录权限，因此在

1135
00:43:17,109 --> 00:43:19,660
这种情况下，我将属性更新为

1136
00:43:19,660 --> 00:43:23,380
77 88 99 的 3 倍，因此当我现在创建

1137
00:43:23,380 --> 00:43:25,930
合并版本时，最新版本

1138
00:43:25,930 --> 00:43:28,599
的属性 - 是 99，因此我可以

1139
00:43:28,599 --> 00:43:30,340


1140
00:43:30,340 --> 00:43:32,740
在这里丢弃这些其他 Delta 但这里的这个人修改了

1141
00:43:32,740 --> 00:43:35,440
属性一所以我需要知道

1142
00:43:35,440 --> 00:43:36,910


1143
00:43:36,910 --> 00:43:38,620
为了理解你知道在时间戳 50 处重新创建这个元组的版本

1144
00:43:38,620 --> 00:43:41,500
所以我必须将它记录

1145
00:43:41,500 --> 00:43:44,230
在我的记录中，然后

1146
00:43:44,230 --> 00:43:46,150
我要为这个

1147
00:43:46,150 --> 00:43:48,550
合并的 Delta 记录签名的

1148
00:43:48,550 --> 00:43:51,000
时间戳将是我合并的最大时间戳，

1149
00:43:51,000 --> 00:43:55,450
所以现在如果我能你

1150
00:43:55,450 --> 00:43:57,490
知道我是否来这个家伙想要读

1151
00:43:57,490 --> 00:44:00,160
15 到 15 他仍然可以达到

1152
00:44:00,160 --> 00:44:02,440
10 这家伙想读取时间戳 55

1153
00:44:02,440 --> 00:44:04,480
他仍然可以找到这个，它将

1154
00:44:04,480 --> 00:44:06,160


1155
00:44:06,160 --> 00:44:08,080
包含发生在时间戳 50 之后的所有 Delta 记录的所有信息，

1156
00:44:08,080 --> 00:44:11,530
所以现在要正确安装它

1157
00:44:11,530 --> 00:44:14,020
我有一点，我

1158
00:44:14,020 --> 00:44:15,670
只是做一个比较 并交换

1159
00:44:15,670 --> 00:44:17,800
版本向量现在再次更新它

1160
00:44:17,800 --> 00:44:19,720
第一个作者获胜我们将

1161
00:44:19,720 --> 00:44:21,130
其视为这样你知道这就像一个

1162
00:44:21,130 --> 00:44:22,450
更新但它就像一个内部更新

1163
00:44:22,450 --> 00:44:24,130
所以如果其他人出现这个

1164
00:44:24,130 --> 00:44:25,270
版本向量为什么我们要做一些

1165
00:44:25,270 --> 00:44:28,150
合作 nsolidation 然后我们失败并且必须

1166
00:44:28,150 --> 00:44:30,100
重新启动但是让我们再说一次它成功了

1167
00:44:30,100 --> 00:44:33,040
所以现在我的版本向量指向

1168
00:44:33,040 --> 00:44:35,530
这个合并的一个然后我可以

1169
00:44:35,530 --> 00:44:37,570
吹走版本链的其余部分

1170
00:44:37,570 --> 00:44:46,480
是的你的问题是我是否需要

1171
00:44:46,480 --> 00:44:47,530
这些代表这些东西

1172
00:44:47,530 --> 00:44:50,200
在 Delta 存储下再次提交

1173
00:44:50,200 --> 00:44:55,000
第一个写入者获胜，如果版本向量为空，则这

1174
00:44:55,000 --> 00:44:56,620
将始终是已提交的

1175
00:44:56,620 --> 00:44:58,810
版本，

1176
00:44:58,810 --> 00:45:00,550
或者最新提交的版本是

1177
00:45:00,550 --> 00:45:03,250
第一个，其他所有内容也已

1178
00:45:03,250 --> 00:45:06,250
提交，所以它不是

1179
00:45:06,250 --> 00:45:07,480
这样的 就像一个正在进行的交易，

1180
00:45:07,480 --> 00:45:09,330
因为没有人可以创建另一个

1181
00:45:09,330 --> 00:45:11,620
交易 没有两个交易可以

1182
00:45:11,620 --> 00:45:14,140
在同一个逻辑元组上创建 Delta 记录，

1183
00:45:14,140 --> 00:45:16,300
因为第一个人能够

1184
00:45:16,300 --> 00:45:23,670
成功

1185
00:45:32,349 --> 00:45:35,690


1186
00:45:35,690 --> 00:45:37,910
合并

1187
00:45:37,910 --> 00:45:40,489
这些 Delta 记录，这样你就可以回到

1188
00:45:40,489 --> 00:45:43,099
过去，他会说我知道我有 X

1189
00:45:43,099 --> 00:45:45,229
号属性，所以我需要

1190
00:45:45,229 --> 00:45:47,779
确保当我通过

1191
00:45:47,779 --> 00:45:50,539
早点看到我看到所有的

1192
00:45:50,539 --> 00:45:52,369
属性然后我知道在这之后

1193
00:45:52,369 --> 00:45:53,989
没有什么我会关心的

1194
00:45:53,989 --> 00:45:55,940
所以

1195
00:45:55,940 --> 00:45:58,279
我你停止这个过程因为你

1196
00:45:58,279 --> 00:46:00,259
必须能够说这些你遵循

1197
00:46:00,259 --> 00:46:01,190
维珍链并说这个 是我

1198
00:46:01,190 --> 00:46:03,289
要收回的东西，但你不需要

1199
00:46:03,289 --> 00:46:04,849
你不会成为

1200
00:46:04,849 --> 00:46:06,259
带有这些信息的新戴尔记录的 Delta 记录，

1201
00:46:06,259 --> 00:46:09,769
所以我们去年将其作为一个班级

1202
00:46:09,769 --> 00:46:13,309
项目进行了尝试，

1203
00:46:13,309 --> 00:46:15,769
我认为为什么这很棘手

1204
00:46:15,769 --> 00:46:18,950
回收口头链接

1205
00:46:18,950 --> 00:46:22,119
数据的顺序使这具有挑战性，因为

1206
00:46:22,119 --> 00:46:24,529
您希望这样显示

1207
00:46:24,529 --> 00:46:26,509
嵌入在 Delta 记录中的字符串，但

1208
00:46:26,509 --> 00:46:28,130
如果它是一个大字符串，那么

1209
00:46:28,130 --> 00:46:29,450
它实际上是一个指向可变

1210
00:46:29,450 --> 00:46:31,369
长度池的指针，我 认为我们在

1211
00:46:31,369 --> 00:46:33,259
试图获得正确的顺序时遇到了麻烦，

1212
00:46:33,259 --> 00:46:35,569
但这将是

1213
00:46:35,569 --> 00:46:38,180
我们可能在本学期再次探索

1214
00:46:38,180 --> 00:46:41,660
的事情，你真的知道如果你

1215
00:46:41,660 --> 00:46:42,589
做这个项目，

1216
00:46:42,589 --> 00:46:43,700
它真的会强迫你

1217
00:46:43,700 --> 00:46:44,930
像这样接近的信息

1218
00:46:44,930 --> 00:46:46,849
以及所有的极端情况是什么，

1219
00:46:46,849 --> 00:46:47,930
但这显然是对问题的过度

1220
00:46:47,930 --> 00:46:50,170
简化，

1221
00:46:50,170 --> 00:46:54,219
所以好吧，是的，

1222
00:47:03,970 --> 00:47:07,340
您的问题是

1223
00:47:07,340 --> 00:47:09,109
对 Delta 记录进行垃圾问题，我们是否必须先

1224
00:47:09,109 --> 00:47:10,369
进行合并或上限操作？

1225
00:47:10,369 --> 00:47:15,609
然后我们可以清理一些不大的东西，

1226
00:47:19,540 --> 00:47:26,920
所以你怎么知道第一个动作 - 如果

1227
00:47:26,920 --> 00:47:32,630
说我删除第一个线程，我关心的

1228
00:47:32,630 --> 00:47:34,700
就像如果我知道没有其他人

1229
00:47:34,700 --> 00:47:35,930
可以阅读此之后的任何内容，

1230
00:47:35,930 --> 00:47:37,910
那么他们总是会阅读

1231
00:47:37,910 --> 00:47:39,980
版本 在这里我只是在做这个

1232
00:47:39,980 --> 00:47:41,119
整合，因为我知道

1233
00:47:41,119 --> 00:47:42,650
这里的这个人可以阅读这个我需要

1234
00:47:42,650 --> 00:47:44,359
知道在那之后的版本是什么

1235
00:47:44,359 --> 00:47:48,470
如果我不事件如果我

1236
00:47:48,470 --> 00:47:49,760
不需要这样做我不需要做这个间隔

1237
00:47:49,760 --> 00:47:52,970
合并它是一件好事

1238
00:47:52,970 --> 00:47:54,260
，但你不需要它的

1239
00:47:54,260 --> 00:47:56,119
正确性，因为没有它，

1240
00:47:56,119 --> 00:47:58,460
虽然我没有它，但我必须等待

1241
00:47:58,460 --> 00:48:01,400
这个人提交或 B 在我

1242
00:48:01,400 --> 00:48:12,040
可以修剪其他所有东西之前

1243
00:48:12,040 --> 00:48:15,109
他的问题 是不是我真的

1244
00:48:15,109 --> 00:48:21,920
需要巩固这不能我只是

1245
00:48:21,920 --> 00:48:23,810
删除这些人保留这个

1246
00:48:23,810 --> 00:48:25,640
是否足够了是的

1247
00:48:25,640 --> 00:48:33,619
实际上仍然可以工作 - 它需要

1248
00:48:33,619 --> 00:48:35,540
早上不，因为我认为它会

1249
00:48:35,540 --> 00:48:38,450
你说的是对的所以 我们回到

1250
00:48:38,450 --> 00:48:40,910
这里，而不是合并到

1251
00:48:40,910 --> 00:48:43,670
这个新人中，我保留这个，我可以

1252
00:48:43,670 --> 00:48:45,080
删除这些人，因为这些人

1253
00:48:45,080 --> 00:48:47,240
被这个覆盖了，我现在要做的就是将

1254
00:48:47,240 --> 00:48:50,420
这个指针更新到这个

1255
00:48:50,420 --> 00:48:58,490
会起作用哦，是的 - 是的，当我 当

1256
00:48:58,490 --> 00:49:00,350
我扫描时，我想回来

1257
00:49:00,350 --> 00:49:04,450
看看哭泣的版本是什么是的，是的，

1258
00:49:06,820 --> 00:49:08,930
是的，我不喜欢纸质封面，

1259
00:49:08,930 --> 00:49:10,850
甚至显然要设计不同的

1260
00:49:10,850 --> 00:49:12,740
合成基准来练习

1261
00:49:12,740 --> 00:49:14,840
不同的更新模式我不

1262
00:49:14,840 --> 00:49:16,190
知道真正的工作实际上是什么 你知道吗

1263
00:49:16,190 --> 00:49:17,920


1264
00:49:17,920 --> 00:49:20,590
去年我们这样做时说一种方式比另一种方式更好 我认为我们

1265
00:49:20,590 --> 00:49:23,840
创建了一个新的 Delta 记录 然后

1266
00:49:23,840 --> 00:49:29,360
棘手的事情是你创建了新的

1267
00:49:29,360 --> 00:49:31,820
Delta 记录

1268
00:49:31,820 --> 00:49:33,800


1269
00:49:33,800 --> 00:49:36,560
成为 这些东西都

1270
00:49:36,560 --> 00:49:38,600
位于每个更难的记录中

1271
00:49:38,600 --> 00:49:39,860
，它们位于线程本地

1272
00:49:39,860 --> 00:49:41,960
内存中，用于运行它们的事务，

1273
00:49:41,960 --> 00:49:44,270
但现在问题

1274
00:49:44,270 --> 00:49:48,950
将是，通常只有

1275
00:49:48,950 --> 00:49:51,380
线程会回收该内存，但是 现在

1276
00:49:51,380 --> 00:49:53,510
你在后台有这个整合线程

1277
00:49:53,510 --> 00:49:55,070
想要能够回收

1278
00:49:55,070 --> 00:49:56,420
东西，你必须喜欢用闩锁

1279
00:49:56,420 --> 00:49:57,650
来保护内存空间，它

1280
00:49:57,650 --> 00:49:59,180
实际上弥补了事情变得更慢我

1281
00:49:59,180 --> 00:50:00,980
不知道我们有

1282
00:50:00,980 --> 00:50:08,200
笔记要知道的确切细节 好吧

1283
00:50:08,200 --> 00:50:10,310
好吧，接下来

1284
00:50:10,310 --> 00:50:14,210
在所有这些例子中讨论的结束是

1285
00:50:14,210 --> 00:50:16,000
什么，很明显，是的，

1286
00:50:16,000 --> 00:50:17,900
回收内存是一个好主意，对了

1287
00:50:17,900 --> 00:50:20,030
，如果我们不需要

1288
00:50:20,030 --> 00:50:21,830
我们应该得到的数据，我们想要得到你 继续

1289
00:50:21,830 --> 00:50:23,869
释放空间，但现在的问题是

1290
00:50:23,869 --> 00:50:26,000
我们实际上如何处理我们

1291
00:50:26,000 --> 00:50:29,630
刚刚释放的内存，因为说

1292
00:50:29,630 --> 00:50:32,930
我插入了十亿个元组然后我

1293
00:50:32,930 --> 00:50:35,690
删除了十亿个元组应该

1294
00:50:35,690 --> 00:50:38,510
发生什么我应该 我将

1295
00:50:38,510 --> 00:50:40,300
那 10 亿个元组的内存归还给操作系统，

1296
00:50:40,300 --> 00:50:42,440
或者我应该归还其中一些还是

1297
00:50:42,440 --> 00:50:44,840
自己保留所有我认为它实际上

1298
00:50:44,840 --> 00:50:46,430
想要在中间，我

1299
00:50:46,430 --> 00:50:47,600
认为你想要保留一些 它但

1300
00:50:47,600 --> 00:50:48,619
你确实想给一些权利，

1301
00:50:48,619 --> 00:50:49,670
因为

1302
00:50:49,670 --> 00:50:51,920
如果我有

1303
00:50:51,920 --> 00:50:53,330
十亿件事情然后删除十亿

1304
00:50:53,330 --> 00:50:55,130
件事情并且你应该的内存

1305
00:50:55,130 --> 00:51:00,710
不会下降，所以我人们最终会认为他们的系统坏了，所以很长一段时间

1306
00:51:00,710 --> 00:51:03,320
数据数据池，我们总是可以正确地

1307
00:51:03,320 --> 00:51:05,359
重用内存空间，因为

1308
00:51:05,359 --> 00:51:06,470
我们本质上是在做一个装箱

1309
00:51:06,470 --> 00:51:08,180
问题来发现你知道

1310
00:51:08,180 --> 00:51:09,470
你实际需要存储

1311
00:51:09,470 --> 00:51:11,030
在柏林数据池中的每一个动作，我们只是找到一个

1312
00:51:11,030 --> 00:51:13,010
空闲的插槽并把它放进去 在那里对于

1313
00:51:13,010 --> 00:51:15,050
固定链接数据开始插槽，它

1314
00:51:15,050 --> 00:51:17,920
有点棘手，因为

1315
00:51:19,200 --> 00:51:25,549
如果我们开始将插槽重用于元组，

1316
00:51:25,549 --> 00:51:28,290
您知道我们需要它们，因为我们要求

1317
00:51:28,290 --> 00:51:30,450
版本，那么最终可能会导致

1318
00:51:30,450 --> 00:51:33,839
我们出现这种时间方面的时间方面

1319
00:51:33,839 --> 00:51:35,549
的问题 我们所有的维度

1320
00:51:35,549 --> 00:51:40,020
数据现在有点随机，所以我的

1321
00:51:40,020 --> 00:51:44,369
意思是说我有

1322
00:51:44,369 --> 00:51:45,869
一个应用程序，大多数时候

1323
00:51:45,869 --> 00:51:48,000
人们接触最新数据，例如

1324
00:51:48,000 --> 00:51:50,430
reddit或黑客新闻，大多数只会

1325
00:51:50,430 --> 00:51:52,980
评论最新帖子，没有人会

1326
00:51:52,980 --> 00:51:54,660
回复五 几个月前，我什至不认为

1327
00:51:54,660 --> 00:51:57,030
让你知道并尝试更新知道

1328
00:51:57,030 --> 00:51:58,230
在五个月前对帖子发表评论，

1329
00:51:58,230 --> 00:52:02,819
这意味着现在如果我

1330
00:52:02,819 --> 00:52:04,920
忽略多版本和东西，如果

1331
00:52:04,920 --> 00:52:06,270
我为所有人创建新元组

1332
00:52:06,270 --> 00:52:09,630
关于这些文章的这些评论，它们大

1333
00:52:09,630 --> 00:52:12,119
约会

1334
00:52:12,119 --> 00:52:13,559
彼此靠近并且有相同的时间，

1335
00:52:13,559 --> 00:52:15,630
因为说我要插入一个新的评论

1336
00:52:15,630 --> 00:52:17,609
，按时间顺序排列，

1337
00:52:17,609 --> 00:52:19,500
它们

1338
00:52:19,500 --> 00:52:20,490
都将在

1339
00:52:20,490 --> 00:52:21,920
自从它们被正确创建

1340
00:52:21,920 --> 00:52:24,240
以来的时间相同，我不会尝试

1341
00:52:24,240 --> 00:52:25,680
从五个月前的一篇文章中插入评论

1342
00:52:25,680 --> 00:52:26,910
，现在它穿插

1343
00:52:26,910 --> 00:52:29,609
着今天的文章，所以

1344
00:52:29,609 --> 00:52:31,319
这很重要的原因是因为在

1345
00:52:31,319 --> 00:52:35,520
ogv 工作负载 你的

1346
00:52:35,520 --> 00:52:38,760
元组被更新的概率

1347
00:52:38,760 --> 00:52:39,720
取决于上次

1348
00:52:39,720 --> 00:52:42,020
访问的时间或插入的时间，所以如果我

1349
00:52:42,020 --> 00:52:45,059
今天插入我的第一个版本，

1350
00:52:45,059 --> 00:52:46,829
我今天要更新它的概率

1351
00:52:46,829 --> 00:52:48,990
比今天高 将是五个月

1352
00:52:48,990 --> 00:52:50,700
后，因为大多数时候你

1353
00:52:50,700 --> 00:52:55,020
只更新最新的东西，所以如果

1354
00:52:55,020 --> 00:52:57,119
现在在我的数据块中，如果

1355
00:52:57,119 --> 00:52:58,920
它们大致相同，你知道

1356
00:52:58,920 --> 00:53:01,079
在同一时间创建，写

1357
00:53:01,079 --> 00:53:02,160
版本是在同一时间创建的 时间

1358
00:53:02,160 --> 00:53:04,140
然后我知道他们将有相同的

1359
00:53:04,140 --> 00:53:05,609
可能性他们将被

1360
00:53:05,609 --> 00:53:07,020
更新，因此它可能会

1361
00:53:07,020 --> 00:53:09,059
失效，因此如果我

1362
00:53:09,059 --> 00:53:10,770
有五个月前的数据全部在

1363
00:53:10,770 --> 00:53:12,960
一个块中，我现在可以压缩它使其

1364
00:53:12,960 --> 00:53:15,869
只读 并且不必担心

1365
00:53:15,869 --> 00:53:19,049
必须解压缩它以更新某些内容

1366
00:53:19,049 --> 00:53:20,640
然后重新运行压缩

1367
00:53:20,640 --> 00:53:22,980
方案是否有意义

1368
00:53:22,980 --> 00:53:24,990
就像如果数据位于一起它们

1369
00:53:24,990 --> 00:53:26,309
都是同时创建的所以

1370
00:53:26,309 --> 00:53:28,020
这就是全部 将以相同的

1371
00:53:28,020 --> 00:53:30,150
概率更新然后我现在可以使用压缩

1372
00:53:30,150 --> 00:53:32,069
来减小该数据块的大小，

1373
00:53:32,069 --> 00:53:33,090


1374
00:53:33,090 --> 00:53:34,590
而不必担心稍后重新运行

1375
00:53:34,590 --> 00:53:37,770
压缩，因此

1376
00:53:37,770 --> 00:53:38,790
您不想压缩

1377
00:53:38,790 --> 00:53:39,990
要按旧的内容 因为旧的

1378
00:53:39,990 --> 00:53:43,560
东西将是只读的所以这

1379
00:53:43,560 --> 00:53:45,330
是两个问题，如果我在

1380
00:53:45,330 --> 00:53:47,610
创建新版本时以我想要的方式重用插槽

1381
00:53:47,610 --> 00:53:50,430
并且我们声明旧

1382
00:53:50,430 --> 00:53:53,430
版本然后在我的内存物理布局中

1383
00:53:53,430 --> 00:53:55,200
它会发生 像

1384
00:53:55,200 --> 00:53:56,820
一些东西会是新的一样随机化一些东西

1385
00:53:56,820 --> 00:53:59,220
会旧现在如果我去压缩它如果

1386
00:53:59,220 --> 00:54:00,870
有一些与旧的新东西混合如果我

1387
00:54:00,870 --> 00:54:03,930
压缩那个数据块那么

1388
00:54:03,930 --> 00:54:05,160
那里有一些东西可以

1389
00:54:05,160 --> 00:54:07,350
更新然后我有 你知道

1390
00:54:07,350 --> 00:54:09,000
再次压缩所以我们失去了

1391
00:54:09,000 --> 00:54:12,000
那个时间局部性我们可以

1392
00:54:12,000 --> 00:54:14,250
不理会它并且基本上让

1393
00:54:14,250 --> 00:54:16,590
这些插槽未使用这些插槽中的这些孔

1394
00:54:16,590 --> 00:54:19,260
在插槽中这很糟糕

1395
00:54:19,260 --> 00:54:21,660
因为你知道你知道多少

1396
00:54:21,660 --> 00:54:22,980
我们不能使用的空洞和空间，

1397
00:54:22,980 --> 00:54:24,450
但我们仍然分配了这些

1398
00:54:24,450 --> 00:54:26,520
内存，所以在稍后的某个时候，我们必须

1399
00:54:26,520 --> 00:54:30,270
回去进行压缩，并

1400
00:54:30,270 --> 00:54:31,740
用一堆空洞整合多个块

1401
00:54:31,740 --> 00:54:33,360
，你知道 将

1402
00:54:33,360 --> 00:54:37,020
它们组合在一起，使我们变得更好 我们

1403
00:54:37,020 --> 00:54:38,730
得到更好的利用和更少的

1404
00:54:38,730 --> 00:54:42,480
碎片 还有第三种方法

1405
00:54:42,480 --> 00:54:45,720
与此相关，例如当

1406
00:54:45,720 --> 00:54:47,340
您执行 truncate 命令

1407
00:54:47,340 --> 00:54:48,540


1408
00:54:48,540 --> 00:54:50,640


1409
00:54:50,640 --> 00:54:53,190
时 而

1410
00:54:53,190 --> 00:54:55,770
不是必须扫描和删除元组

1411
00:54:55,770 --> 00:54:57,750
并基本上在没有 where 子句的情况下检查它们

1412
00:54:57,750 --> 00:54:59,520
并将它们设置为删除

1413
00:54:59,520 --> 00:55:02,280
，进行截断的简单方法就是

1414
00:55:02,280 --> 00:55:04,650
删除表然后重新创建它

1415
00:55:04,650 --> 00:55:05,850
吹走所有索引吹走表

1416
00:55:05,850 --> 00:55:07,740
空间并且是 重新创建，这样你

1417
00:55:07,740 --> 00:55:09,480
就不用担心任何本地

1418
00:55:09,480 --> 00:55:11,120
信息或看看你好

1419
00:55:11,120 --> 00:55:13,770
属性它只是从头开始的东西

1420
00:55:13,770 --> 00:55:16,200
但是 truncate truncate 是

1421
00:55:16,200 --> 00:55:18,600
一个特例，所以 现在要进行

1422
00:55:18,600 --> 00:55:21,090
我正在谈论的压缩 是的，

1423
00:55:21,090 --> 00:55:23,300


1424
00:55:28,620 --> 00:55:31,750
抱歉，问题是针对 5 个月的示例，

1425
00:55:31,750 --> 00:55:33,760
为什么我假设我不会

1426
00:55:33,760 --> 00:55:34,960
将它们全部压缩在一起而不是

1427
00:55:34,960 --> 00:55:38,710
将它们全部删除，你可以保护

1428
00:55:38,710 --> 00:55:41,320
你会这样做 有些

1429
00:55:41,320 --> 00:55:43,480
网站只

1430
00:55:43,480 --> 00:55:45,520
向您公开过去 90 天的数据，

1431
00:55:45,520 --> 00:55:48,010
本质上它们就像 TTL 一样，或者在

1432
00:55:48,010 --> 00:55:50,290
数据变旧时删除数据，在这种

1433
00:55:50,290 --> 00:55:52,930
情况下，如果所有数据都在一个块中，

1434
00:55:52,930 --> 00:55:55,810
因为它是在其中创建的

1435
00:55:55,810 --> 00:55:58,180
当我修剪整个块时，在同一时间范围内的相同时间戳

1436
00:55:58,180 --> 00:55:59,800
被

1437
00:55:59,800 --> 00:56:02,350
吹走然后我可以回收它

1438
00:56:02,350 --> 00:56:04,480
它全部混合然后我最终

1439
00:56:04,480 --> 00:56:05,740
删除了一些

1440
00:56:05,740 --> 00:56:07,270
五个月大的元组和一些其他三个月大的元组

1441
00:56:07,270 --> 00:56:08,380
他们现在必须留下来，

1442
00:56:08,380 --> 00:56:10,980
但现在我有一堆漏洞是

1443
00:56:10,980 --> 00:56:14,110
为了压缩假设我们

1444
00:56:14,110 --> 00:56:15,610
想保留他们所有的数据压缩

1445
00:56:15,610 --> 00:56:17,710
我们想要一个

1446
00:56:17,710 --> 00:56:20,380
永远不会再更新的数据块

1447
00:56:20,380 --> 00:56:21,880
如果我们仍然可以这样做 nee  d 我们必须

1448
00:56:21,880 --> 00:56:24,130
支持它，但它不太可能被

1449
00:56:24,130 --> 00:56:25,030
更新，因此我们可以使用

1450
00:56:25,030 --> 00:56:27,010
重量级压缩来减小它的

1451
00:56:27,010 --> 00:56:30,100
大小，然后如果有人尝试更新它，

1452
00:56:30,100 --> 00:56:31,090
我们会处理它，但我们

1453
00:56:31,090 --> 00:56:32,950
想避免这种情况，所以它都是一样的

1454
00:56:32,950 --> 00:56:35,440
大小 不会再更新了 全部都是

1455
00:56:35,440 --> 00:56:36,990
Craig 同一时间 以后不会再更新

1456
00:56:36,990 --> 00:56:40,090
好吧 所以

1457
00:56:40,090 --> 00:56:41,080
再去修补它 基本上是

1458
00:56:41,080 --> 00:56:43,690
我们发现这些空块 起始

1459
00:56:43,690 --> 00:56:45,760
块 上面都有洞的想法 没错，

1460
00:56:45,760 --> 00:56:46,990
这个是半满的，这个是半

1461
00:56:46,990 --> 00:56:48,460
满的，而不是必须有完整的

1462
00:56:48,460 --> 00:56:50,500
块，我可以将它们绑定到一个

1463
00:56:50,500 --> 00:56:55,570
完整的块中，所以理想情况下

1464
00:56:55,570 --> 00:56:57,490
，如果

1465
00:56:57,490 --> 00:56:59,310
元组可能

1466
00:56:59,310 --> 00:57:01,720
在 我们希望将

1467
00:57:01,720 --> 00:57:03,190
它们放在同一个块中的同一窗口时间，因为当我们

1468
00:57:03,190 --> 00:57:06,190
压缩它们时，您

1469
00:57:06,190 --> 00:57:07,360
知道其中一个我们更新而

1470
00:57:07,360 --> 00:57:09,610
另一个不会更新的可能性将很低

1471
00:57:09,610 --> 00:57:11,440
，我们可以

1472
00:57:11,440 --> 00:57:13,270
在本学期晚些时候讨论另一种技术 就像如果

1473
00:57:13,270 --> 00:57:15,040
我们现在也知道这些数据

1474
00:57:15,040 --> 00:57:17,050
不太可能不仅不会被

1475
00:57:17,050 --> 00:57:19,080
更新而且也不太可能被读取

1476
00:57:19,080 --> 00:57:21,190
然后我们可以开始将它从

1477
00:57:21,190 --> 00:57:23,980
磁盘中取出并开始节省内存空间

1478
00:57:23,980 --> 00:57:25,990
我们仍然会跟踪

1479
00:57:25,990 --> 00:57:27,430
内存中的一些信息所以 如果您尝试阅读它，我们

1480
00:57:27,430 --> 00:57:31,090
会从磁盘中获取它，但您知道它

1481
00:57:31,090 --> 00:57:32,920
仍然存在，但它是主要位置，我

1482
00:57:32,920 --> 00:57:35,050
不知道，这里的想法是

1483
00:57:35,050 --> 00:57:36,130
在学期开始时我说

1484
00:57:36,130 --> 00:57:37,119
我们想留在记忆中

1485
00:57:37,119 --> 00:57:38,230
把所有的东西都在内存中，我们可以

1486
00:57:38,230 --> 00:57:39,400
运行得很快，但这有点

1487
00:57:39,400 --> 00:57:41,289
以一种智能的方式把磁盘带回来，

1488
00:57:41,289 --> 00:57:43,299
说好吧，我们大部分时间都可以把一些数据推

1489
00:57:43,299 --> 00:57:45,099
到

1490
00:57:45,099 --> 00:57:47,230
内存中，但如果我们溢出了一个磁盘，我们

1491
00:57:47,230 --> 00:57:48,970
可以处理这个问题 我想我们

1492
00:57:48,970 --> 00:57:52,150
在第二节或最后一节课 nettie 上

1493
00:57:52,150 --> 00:57:53,829
再次介绍了这就像我们没有带回

1494
00:57:53,829 --> 00:57:55,569
我们的缓冲池 因为那很慢 它

1495
00:57:55,569 --> 00:57:59,619
只是一种二级存储 好吧

1496
00:57:59,619 --> 00:58:01,150
所以我们可以弄清楚如何做的三种方法

1497
00:58:01,150 --> 00:58:02,980
什么是紧凑的，我们可以

1498
00:58:02,980 --> 00:58:04,930
走了 看看自上次更新以来的时间戳，

1499
00:58:04,930 --> 00:58:07,539
我们已经有了

1500
00:58:07,539 --> 00:58:08,769
这些信息，因为我们正在存储

1501
00:58:08,769 --> 00:58:09,940
每个元组的开始时间戳

1502
00:58:09,940 --> 00:58:11,799
，我们只是看看它，然后

1503
00:58:11,799 --> 00:58:12,970
说这些事情大致

1504
00:58:12,970 --> 00:58:14,619
在同一时间 我们继续并

1505
00:58:14,619 --> 00:58:16,480
使用它来确定我们可以

1506
00:58:16,480 --> 00:58:18,069
继续并删除所有内容 先生

1507
00:58:18,069 --> 00:58:20,950


1508
00:58:20,950 --> 00:58:22,119


1509
00:58:22,119 --> 00:58:26,410


1510
00:58:26,410 --> 00:58:29,769


1511
00:58:29,769 --> 00:58:31,059
访问越近

1512
00:58:31,059 --> 00:58:32,259
，在不久的将来再次访问的可能性

1513
00:58:32,259 --> 00:58:33,819
就大于

1514
00:58:33,819 --> 00:58:34,869
很久以前访问的可能性，

1515
00:58:34,869 --> 00:58:37,420


1516
00:58:37,420 --> 00:58:38,920
如果您正在执行时间戳

1517
00:58:38,920 --> 00:58:40,180
排序基本时间戳警告，我认为它对这个有衰减影响

1518
00:58:40,180 --> 00:58:41,799
带有重定时样本的协议，您

1519
00:58:41,799 --> 00:58:43,480
每次读取事物时都会记录，然后您

1520
00:58:43,480 --> 00:58:45,339
可以使用它，否则您必须

1521
00:58:45,339 --> 00:58:46,839
维护一些额外的元数据，可能

1522
00:58:46,839 --> 00:58:49,059
是块级别，因为

1523
00:58:49,059 --> 00:58:51,039
维护成本太高

1524
00:58:51,039 --> 00:58:52,779
每个学生的访问时间戳，因为

1525
00:58:52,779 --> 00:58:54,759
现在所有内容都会读取它会

1526
00:58:54,759 --> 00:58:56,049
变成写，因为你必须

1527
00:58:56,049 --> 00:58:57,339
更新这个时间戳 这

1528
00:58:57,339 --> 00:59:00,640
是第三种方法，据我所知

1529
00:59:00,640 --> 00:59:02,410
没有人真正这样做，但很多

1530
00:59:02,410 --> 00:59:05,200
人想要这样做 是如果您可以

1531
00:59:05,200 --> 00:59:07,869
推断出一些关于

1532
00:59:07,869 --> 00:59:10,599
数据实际上是如何

1533
00:59:10,599 --> 00:59:12,249
跨表或在

1534
00:59:12,249 --> 00:59:14,680
同一个表中的数据相互关联的信息，那么您可以

1535
00:59:14,680 --> 00:59:16,210
合并或重新组合

1536
00:59:16,210 --> 00:59:19,410
将

1537
00:59:19,410 --> 00:59:21,999
在同一个中更频繁地一起访问的事物 块，

1538
00:59:21,999 --> 00:59:23,890
因为这样你就可以应用你想要的相同的

1539
00:59:23,890 --> 00:59:25,089
压缩或压缩方案

1540
00:59:25,089 --> 00:59:27,099
，所以外键将是一个

1541
00:59:27,099 --> 00:59:28,660
明显的例子，如果我知道

1542
00:59:28,660 --> 00:59:31,900
我是否有两个具有外

1543
00:59:31,900 --> 00:59:33,819
键的表，那么我将

1544
00:59:33,819 --> 00:59:34,930
要访问的可能性 父表，然后

1545
00:59:34,930 --> 00:59:36,249
跟随外键并在子表中取得好成绩，

1546
00:59:36,249 --> 00:59:38,230
它非常高，所以也许

1547
00:59:38,230 --> 00:59:40,119
我想将这些家伙

1548
00:59:40,119 --> 00:59:41,410
在内存中紧密地放在一起，这样我就可以进行

1549
00:59:41,410 --> 00:59:43,269
压缩压缩

1550
00:59:43,269 --> 00:59:46,599
我曾经听说过的另一个考试

1551
00:59:46,599 --> 00:59:49,690
是一个订单处理系统，

1552
00:59:49,690 --> 00:59:50,980
他们想将所有内容都保存在内存中

1553
00:59:50,980 --> 00:59:53,319
，然后将次冷订单推送到

1554
00:59:53,319 --> 00:59:56,140
磁盘，但是如果

1555
00:59:56,140 --> 00:59:58,990
他记录的这个订单的订单状态被

1556
00:59:58,990 --> 01:00:01,299
标记为 open 可能会

1557
01:00:01,299 --> 01:00:03,279
在以后的某个时间开放数月，他们会

1558
01:00:03,279 --> 01:00:04,750
再次访问它，所以如果我

1559
01:00:04,750 --> 01:00:07,089
知道如果订单说等于开放，

1560
01:00:07,089 --> 01:00:08,829
请将其保存在内存中或保留这些

1561
01:00:08,829 --> 01:00:10,509
位置，订单状态

1562
01:00:10,509 --> 01:00:12,309
关闭的任何东西都会被推到另一个 location

1563
01:00:12,309 --> 01:00:14,140
那么我可以 我可以做这种

1564
01:00:14,140 --> 01:00:18,670
优化 好的，

1565
01:00:18,670 --> 01:00:19,869
为了时间我想我们已经讨论过

1566
01:00:19,869 --> 01:00:23,079
truncate write 基本上主干一个 zit

1567
01:00:23,079 --> 01:00:24,880
删除没有意识到子句删除

1568
01:00:24,880 --> 01:00:26,589
所有内容，

1569
01:00:26,589 --> 01:00:29,170
一旦你知道一切都是不

1570
01:00:29,170 --> 01:00:31,779
可见的，就运行你的垃圾收集并且 然后重新创建表，所以

1571
01:00:31,779 --> 01:00:33,039
我们将在一两周内

1572
01:00:33,039 --> 01:00:36,250
讨论事务目录，以便

1573
01:00:36,250 --> 01:00:37,990
目录存储有关

1574
01:00:37,990 --> 01:00:40,480
哪些表存在哪些属性

1575
01:00:40,480 --> 01:00:42,700
或列的元数据 他们有所以如果你的

1576
01:00:42,700 --> 01:00:45,069
目录是事务性的，这意味着如果我

1577
01:00:45,069 --> 01:00:49,359
调用 drop table 那么任何

1578
01:00:49,359 --> 01:00:50,950
在我的 drop table 事务之前有时间戳的人

1579
01:00:50,950 --> 01:00:53,019
仍然可以看到表，

1580
01:00:53,019 --> 01:00:54,910
然后一旦它们都消失了我可以

1581
01:00:54,910 --> 01:00:56,109
回收空间所以如果这都是

1582
01:00:56,109 --> 01:00:58,569
事务性的 然后这样做

1583
01:00:58,569 --> 01:01:00,430
这个截断方法非常简单

1584
01:01:00,430 --> 01:01:02,230
实际上与压缩相同的

1585
01:01:02,230 --> 01:01:04,480
事情正确压缩是压缩

1586
01:01:04,480 --> 01:01:06,400
将两个块并将它们组合

1587
01:01:06,400 --> 01:01:07,569
在一起我们只是将

1588
01:01:07,569 --> 01:01:09,069
这些块中那些元组的物理位置移动

1589
01:01:09,069 --> 01:01:11,410
到一个新位置所以它就像

1590
01:01:11,410 --> 01:01:12,849
它就像一个删除，然后是一个

1591
01:01:12,849 --> 01:01:14,230
插入，所以如果我可以在事务中做到这一点，

1592
01:01:14,230 --> 01:01:15,970
那么我不担心

1593
01:01:15,970 --> 01:01:18,279


1594
01:01:18,279 --> 01:01:19,599


1595
01:01:19,599 --> 01:01:21,730
在运行和压缩的同时运行的事务中的任何假阴性误报，所以在我们的

1596
01:01:21,730 --> 01:01:24,490
系统中，我们的目录是 完全是

1597
01:01:24,490 --> 01:01:25,990
事务性的，它使所有这些

1598
01:01:25,990 --> 01:01:27,579
事情变得容易，我们只是我们还没有完成

1599
01:01:27,579 --> 01:01:31,029
所有事情，所以再次完成，

1600
01:01:31,029 --> 01:01:33,490
这只是更

1601
01:01:33,490 --> 01:01:34,900
经典的 我们在计算机

1602
01:01:34,900 --> 01:01:36,730
科学和存储数据库

1603
01:01:36,730 --> 01:01:38,380
与计算中看到的权衡，所以你相信

1604
01:01:38,380 --> 01:01:39,880
在进行垃圾收集

1605
01:01:39,880 --> 01:01:42,160
和回收更多内存空间方面更积极，但这

1606
01:01:42,160 --> 01:01:43,269
会减慢我们的交易速度，

1607
01:01:43,269 --> 01:01:45,369
或者我们可以让我们的处女是所有

1608
01:01:45,369 --> 01:01:48,460
版本积累和 你

1609
01:01:48,460 --> 01:01:50,440
知道节省我们的计算周期，但

1610
01:01:50,440 --> 01:01:51,460
我们正在花费更多的内存或

1611
01:01:51,460 --> 01:01:52,480
花费更多的存储空间来处理这个

1612
01:01:52,480 --> 01:01:56,859
问题，因此在与

1613
01:01:56,859 --> 01:01:58,329
运行 MVC 系统的人交谈时，尤其是在

1614
01:01:58,329 --> 01:02:01,329
内存系统中，每个人都愿意

1615
01:02:01,329 --> 01:02:03,100
为性能付出代价

1616
01:02:03,100 --> 01:02:04,630
交换减少内存

1617
01:02:04,630 --> 01:02:10,600
占用 任何人都在想什么更

1618
01:02:10,600 --> 01:02:13,810
贵 Ram

1619
01:02:13,810 --> 01:02:15,850
Rams 更贵 不仅需要

1620
01:02:15,850 --> 01:02:17,260
购买更多，而且维护起来更兴奋 你

1621
01:02:17,260 --> 01:02:18,910
必须为此付出能量，所以如果我可以

1622
01:02:18,910 --> 01:02:21,130
运行我的数据库慢一点但

1623
01:02:21,130 --> 01:02:24,340
使用少得多 内存那么我你

1624
01:02:24,340 --> 01:02:26,890
知道这可以节省一点成本所以

1625
01:02:26,890 --> 01:02:28,870
这就是为什么我喜欢

1626
01:02:28,870 --> 01:02:30,160
你们从蒸汽中读到的论文中的超级方法，

1627
01:02:30,160 --> 01:02:32,860
因为 他们正在运行垃圾

1628
01:02:32,860 --> 01:02:33,820
收集，因为他们正在运行

1629
01:02:33,820 --> 01:02:36,160
查询 查询运行速度较慢，但他们正在

1630
01:02:36,160 --> 01:02:37,990
尽快回收东西

1631
01:02:37,990 --> 01:02:41,160
并减少内存占用

1632
01:02:41,160 --> 01:02:46,150


1633
01:02:46,150 --> 01:02:50,920


1634
01:02:50,920 --> 01:02:52,180
不知道在某些时候你可能已经

1635
01:02:52,180 --> 01:02:53,710
涵盖了这种信息我

1636
01:02:53,710 --> 01:02:56,980
认为 213 没有涵盖这一点，但

1637
01:02:56,980 --> 01:02:58,510
整个学期都有一个反复出现的主题，

1638
01:02:58,510 --> 01:02:59,560
就像好吧，我们想

1639
01:02:59,560 --> 01:03:00,730
确定我们的系统是否运行

1640
01:03:00,730 --> 01:03:04,240
缓慢，然后是 慢如果是这样为什么那么

1641
01:03:04,240 --> 01:03:05,320
让我们看一个非常简单的例子

1642
01:03:05,320 --> 01:03:07,480
我的程序中有两个函数 foo 和 bar

1643
01:03:07,480 --> 01:03:10,390
好吧所以我想我想

1644
01:03:10,390 --> 01:03:12,340
加快速度我想弄清楚如何

1645
01:03:12,340 --> 01:03:13,780
弄明白为什么这些人运行得更慢

1646
01:03:13,780 --> 01:03:15,550
以及什么可以 我确实想弄清楚你知道

1647
01:03:15,550 --> 01:03:18,820
如何让它们更快，所以一个非常

1648
01:03:18,820 --> 01:03:22,750
愚蠢的方法是我们这样做的天真

1649
01:03:22,750 --> 01:03:24,160
方法将

1650
01:03:24,160 --> 01:03:27,240
在调试器 gdb 或任何

1651
01:03:27,240 --> 01:03:31,300
适用于 Apple 的程序中运行我们的程序，我们经常只是 点击

1652
01:03:31,300 --> 01:03:34,360
暂停 程序查看堆栈

1653
01:03:34,360 --> 01:03:36,850
跟踪，找出它在哪个函数

1654
01:03:36,850 --> 01:03:39,640
中并记录下来，他

1655
01:03:39,640 --> 01:03:40,870
时常不停地按暂停并

1656
01:03:40,870 --> 01:03:42,010
根据信息，然后随着

1657
01:03:42,010 --> 01:03:45,550
时间的推移，我将获得有关

1658
01:03:45,550 --> 01:03:48,060
最愚蠢的函数被调用的信息

1659
01:03:48,060 --> 01:03:51,480
但它会正常工作，

1660
01:03:51,480 --> 01:03:55,060
所以假设我这样做了，我得到了 10 个

1661
01:03:55,060 --> 01:03:58,690
调用堆栈样本，然后

1662
01:03:58,690 --> 01:04:00,370
在我暂停的 10 次中的 6 次，

1663
01:04:00,370 --> 01:04:02,110
看起来它们在函数 foo 中，

1664
01:04:02,110 --> 01:04:06,250
所以我们会

1665
01:04:06,250 --> 01:04:07,660
根据我们的测量结果知道那个地下室

1666
01:04:07,660 --> 01:04:10,690
我们程序的大约 60% 的时间现在都花在

1667
01:04:10,690 --> 01:04:11,470
了这个 foo 函数上，

1668
01:04:11,470 --> 01:04:13,960
显然这个计算的准确性

1669
01:04:13,960 --> 01:04:15,940
会增加

1670
01:04:15,940 --> 01:04:16,869
我暂停的时间越多，

1671
01:04:16,869 --> 01:04:18,430
就像我一次又一次地被一个小马达击中 Paul 一样

1672
01:04:18,430 --> 01:04:20,349
，我可以自动化 这

1673
01:04:20,349 --> 01:04:22,720
我可以得到更多的样本，他们有

1674
01:04:22,720 --> 01:04:25,299
更多你知道更准确的测量，

1675
01:04:25,299 --> 01:04:30,400
所以现在说我们

1676
01:04:30,400 --> 01:04:32,440
运行 foo 的大部分时间，所以这应该是

1677
01:04:32,440 --> 01:04:34,960
我们应该首先优化的

1678
01:04:34,960 --> 01:04:36,730
目标 我们有两个函数 foo 和 bar

1679
01:04:36,730 --> 01:04:38,559
我们应该首先优化 foo 因为

1680
01:04:38,559 --> 01:04:40,440
他们的大部分时间都花在了数学上

1681
01:04:40,440 --> 01:04:44,349
所以假设现在我们能够使 foo

1682
01:04:44,349 --> 01:04:47,200
运行速度

1683
01:04:47,200 --> 01:04:50,140


1684
01:04:50,140 --> 01:04:54,609
提高两倍 在

1685
01:04:54,609 --> 01:04:59,109
是课之前的娃娃法一半还好所以我是

1686
01:04:59,109 --> 01:05:01,660
这些法律一种计算

1687
01:05:01,660 --> 01:05:03,670
预期改进的方法如果我们知道

1688
01:05:03,670 --> 01:05:05,170
我们的程序

1689
01:05:05,170 --> 01:05:06,999
在特定功能或

1690
01:05:06,999 --> 01:05:09,400
代码的不同部分花费的百分比那么如果我们制作这个

1691
01:05:09,400 --> 01:05:11,289
东西 快 2% 或抱歉

1692
01:05:11,289 --> 01:05:13,749
快 2 倍，我们知道 6% 的

1693
01:05:13,749 --> 01:05:17,109
时间花在 foo 上，那么我们可以将这个

1694
01:05:17,109 --> 01:05:18,309
时间减少一半，

1695
01:05:18,309 --> 01:05:19,960
但我们仍然

1696
01:05:19,960 --> 01:05:22,059
在这个功能栏中花费了 4% 的时间，所以

1697
01:05:22,059 --> 01:05:24,039
法律给了我们 这个很好的

1698
01:05:24,039 --> 01:05:26,079
公式会告诉我们

1699
01:05:26,079 --> 01:05:28,599
基于

1700
01:05:28,599 --> 01:05:30,220
我们正在调用的函数的分布的总体预期

1701
01:05:30,220 --> 01:05:32,529
加速以及我们期望获得正确的加速我们

1702
01:05:32,529 --> 01:05:34,269
运行我们插入数学我们会

1703
01:05:34,269 --> 01:05:35,829
说我们 会在一点四

1704
01:05:35,829 --> 01:05:37,720
倍的改进，所以即使我将

1705
01:05:37,720 --> 01:05:39,039


1706
01:05:39,039 --> 01:05:41,829
大部分时间称为 2 倍的函数提高了 2 倍，但整体

1707
01:05:41,829 --> 01:05:44,549
系统加速仅是 X 的一个点，

1708
01:05:44,549 --> 01:05:47,619
因此我们可以使用这些定律作为

1709
01:05:47,619 --> 01:05:49,539
我们查看时找出的一种方法

1710
01:05:49,539 --> 01:05:51,880
我们的数据库系统我们花费

1711
01:05:51,880 --> 01:05:53,859
了多少时间以及需要付出多少努力

1712
01:05:53,859 --> 01:05:55,390
才能使该特定功能运行

1713
01:05:55,390 --> 01:05:57,730
得更快，然后我们可以

1714
01:05:57,730 --> 01:05:59,380
进行粗略的计算，

1715
01:05:59,380 --> 01:06:01,059
确定应该进行哪些改进，

1716
01:06:01,059 --> 01:06:03,249
以查看我 意思是有时你只是想

1717
01:06:03,249 --> 01:06:06,339
这样做，当你在做

1718
01:06:06,339 --> 01:06:07,720
你正在做的事情时，你知道性能

1719
01:06:07,720 --> 01:06:10,690
分析和开发，因为如果我的

1720
01:06:10,690 --> 01:06:12,069
功能不那么常见，那么

1721
01:06:12,069 --> 01:06:15,849
我可能不想改进它，

1722
01:06:15,849 --> 01:06:17,109
但没关系 不是它调用了多少次

1723
01:06:17,109 --> 01:06:18,039
它有多少时间我在里面

1724
01:06:18,039 --> 01:06:19,900
度过 所以我可以用它来弄清楚

1725
01:06:19,900 --> 01:06:21,220


1726
01:06:21,220 --> 01:06:22,450
帐篷里的高杆是什么 我们花费最多的系统部分是什么

1727
01:06:22,450 --> 01:06:24,009


1728
01:06:24,009 --> 01:06:25,150
我们的时间，这些是我们

1729
01:06:25,150 --> 01:06:27,039
应该做的事情 打算改进它，但当我们

1730
01:06:27,039 --> 01:06:29,380
评估如何改进它时，我们可以使用这种

1731
01:06:29,380 --> 01:06:30,580
形式做出很好的决定 我想我的

1732
01:06:30,580 --> 01:06:32,290
速度快了 2 倍，真正的

1733
01:06:32,290 --> 01:06:35,590
好处是什么我会让他们回答

1734
01:06:35,590 --> 01:06:38,440
这是系统中的一句古老格言你想要

1735
01:06:38,440 --> 01:06:40,090
避免过早的优化，所以是的

1736
01:06:40,090 --> 01:06:41,260
，可能会有一种新的无锁

1737
01:06:41,260 --> 01:06:42,820
算法，我们可以将其用于

1738
01:06:42,820 --> 01:06:44,380
系统的某些部分，这可能

1739
01:06:44,380 --> 01:06:46,180
比我们现在拥有的更好，但在那

1740
01:06:46,180 --> 01:06:47,890
部分代码不会经常执行，

1741
01:06:47,890 --> 01:06:49,600
然后我们 只是在浪费我们的时间

1742
01:06:49,600 --> 01:06:50,950
还有其他事情我们应该

1743
01:06:50,950 --> 01:06:54,100
担心，所以现在我们需要

1744
01:06:54,100 --> 01:06:55,030
弄清楚我们如何才能真正获得这些

1745
01:06:55,030 --> 01:06:56,350
信息，所以

1746
01:06:56,350 --> 01:06:57,550
我在键盘上再次点击暂停的小例子

1747
01:06:57,550 --> 01:06:59,140
是愚蠢的，但

1748
01:06:59,140 --> 01:07:00,670
实际上有真正的工具 会为我们做这件事

1749
01:07:00,670 --> 01:07:03,130
所以我们要关注的两个主要问题

1750
01:07:03,130 --> 01:07:05,020
是 Val grant 和 callgrind

1751
01:07:05,020 --> 01:07:08,500
和 perf 所以 Val盐水是一个

1752
01:07:08,500 --> 01:07:09,640
重量级的仪器和

1753
01:07:09,640 --> 01:07:12,370
框架，基本上将

1754
01:07:12,370 --> 01:07:17,050
注入东西到二进制文件中

1755
01:07:17,050 --> 01:07:18,790
它 的运行允许它收集

1756
01:07:18,790 --> 01:07:21,370
有关它所在系统的哪个部分的信息

1757
01:07:21,370 --> 01:07:24,670
，因此这

1758
01:07:24,670 --> 01:07:26,860
将使您的程序运行得更慢，但您

1759
01:07:26,860 --> 01:07:30,910
知道这将是我的意思是 Andy

1760
01:07:30,910 --> 01:07:32,790
Childress 否则您走得太慢但

1761
01:07:32,790 --> 01:07:36,610
这样会让您展示 你是的，这

1762
01:07:36,610 --> 01:07:37,780
会告诉你我们已经在代码

1763
01:07:37,780 --> 01:07:39,010
级别看到你花时间

1764
01:07:39,010 --> 01:07:41,230
这会说一些像

1765
01:07:41,230 --> 01:07:43,930
哈佛级别的东西所以 perf 是一种从该企业中

1766
01:07:43,930 --> 01:07:46,270
获取低级性能计数器的方法

1767
01:07:46,270 --> 01:07:49,900
zone x86 并记录

1768
01:07:49,900 --> 01:07:51,580
诸如我花费了多少个周期之类的东西

1769
01:07:51,580 --> 01:07:53,500
，例如单独的汇编

1770
01:07:53,500 --> 01:07:56,050
指令或代码行，因此这两者都

1771
01:07:56,050 --> 01:07:57,880
可以用于不同的事情，这

1772
01:07:57,880 --> 01:07:59,500
将为您提供较低级别的信息，

1773
01:07:59,500 --> 01:08:02,080
例如缓存未命中

1774
01:08:02,080 --> 01:08:04,600
周期计数，而这则告诉您

1775
01:08:04,600 --> 01:08:08,080
就像指令计数为此

1776
01:08:08,080 --> 01:08:09,040
告诉你中断计数，因为它

1777
01:08:09,040 --> 01:08:10,090
不知道它实际在 CPU 中花费了多长时间，

1778
01:08:10,090 --> 01:08:12,490
而紫色给

1779
01:08:12,490 --> 01:08:13,600
你，所以你实际上想要同时使用两者，

1780
01:08:13,600 --> 01:08:16,720
但我会给出 pe 的演示 rf 又是一次

1781
01:08:16,720 --> 01:08:19,330
Valgrind 实际上是一个工具包

1782
01:08:19,330 --> 01:08:22,420
我们可以使用的一堆其他东西 mem 检查是

1783
01:08:22,420 --> 01:08:26,050
一种检查内存错误的方法 这

1784
01:08:26,050 --> 01:08:27,160
东西这

1785
01:08:27,160 --> 01:08:28,720
是 valgrind 的原始版本 这是

1786
01:08:28,720 --> 01:08:30,700
检查诸如如果你有的东西

1787
01:08:30,700 --> 01:08:32,140
内存泄漏和诸如此类的事情它会

1788
01:08:32,140 --> 01:08:34,779
找到那些我们使用地址

1789
01:08:34,779 --> 01:08:37,990
清理器作为来自 Google 的 clang 或 GCC 的一部分的东西，

1790
01:08:37,990 --> 01:08:39,609
并且它是识别这些东西的更轻量级的

1791
01:08:39,609 --> 01:08:41,620
调用 研磨它

1792
01:08:41,620 --> 01:08:42,700
会告诉你你

1793
01:08:42,700 --> 01:08:44,350
在源代码中花费的时间 然后

1794
01:08:44,350 --> 01:08:46,359
massif 是一种向您展示进程地址空间

1795
01:08:46,359 --> 01:08:48,340
的总堆空间内的方式，

1796
01:08:48,340 --> 01:08:50,380
您知道程序的哪些

1797
01:08:50,380 --> 01:08:52,359
部分正在

1798
01:08:52,359 --> 01:08:53,920
分配最多的内存，

1799
01:08:53,920 --> 01:08:55,270
显然对我们来说，数据库部分

1800
01:08:55,270 --> 01:08:57,130
将始终是 更大的最大但

1801
01:08:57,130 --> 01:08:58,390
在其中我们可以深入了解并说出

1802
01:08:58,390 --> 01:08:59,649
像我们第一次开始时为数据结构花费了多少时间或您知道多少

1803
01:08:59,649 --> 01:09:01,420
空间

1804
01:09:01,420 --> 01:09:03,330
来跟踪事物和

1805
01:09:03,330 --> 01:09:05,859
索引以及其他东西

1806
01:09:05,859 --> 01:09:08,050
构建成黛比树

1807
01:09:08,050 --> 01:09:10,390
，当他打开这个东西时，它被分配了内存

1808
01:09:10,390 --> 01:09:11,590
，当他看着

1809
01:09:11,590 --> 01:09:13,120
海量时，即使你将零

1810
01:09:13,120 --> 01:09:16,210
数据放入表中，它也会显示出

1811
01:09:16,210 --> 01:09:18,160
这个巨大的内存块被花在

1812
01:09:18,160 --> 01:09:19,300
了黛比树上，因为它

1813
01:09:19,300 --> 01:09:21,310
无缘无故地分配了一个映射表，但

1814
01:09:21,310 --> 01:09:24,670
没有实际使用它，

1815
01:09:24,670 --> 01:09:26,710
所以让我们看看如何使用 call rent 所以对于

1816
01:09:26,710 --> 01:09:29,560
callgrind II 认为你需要有

1817
01:09:29,560 --> 01:09:30,880
root 权限，因为你

1818
01:09:30,880 --> 01:09:33,850
对二进制文件进行了检测，所以你

1819
01:09:33,850 --> 01:09:35,439
会在命令上使用它 对于这一行，

1820
01:09:35,439 --> 01:09:37,990
我在 wiki 上有说明

1821
01:09:37,990 --> 01:09:40,779
如何在

1822
01:09:40,779 --> 01:09:43,359
没有断言的情况下在发布模式下编译但维护调试

1823
01:09:43,359 --> 01:09:46,240
符号，以便当您查看

1824
01:09:46,240 --> 01:09:48,370
调用研磨或蛋糕神社中的跟踪时，

1825
01:09:48,370 --> 01:09:50,529
它会显示您喜欢这里的 源

1826
01:09:50,529 --> 01:09:51,580
代码或者这里你知道这里是

1827
01:09:51,580 --> 01:09:52,870
函数调用这里

1828
01:09:52,870 --> 01:09:54,610
是源代码中维护

1829
01:09:54,610 --> 01:09:57,250
信息的行号所以这种

1830
01:09:57,250 --> 01:09:59,770
模式下的编译将维护所有简单的

1831
01:09:59,770 --> 01:10:01,360
信息，而无需所有额外的

1832
01:10:01,360 --> 01:10:02,890
断言 会减慢系统速度，因此

1833
01:10:02,890 --> 01:10:04,210
它会很接近，因为您可以

1834
01:10:04,210 --> 01:10:05,200
实际运行编写的真实

1835
01:10:05,200 --> 01:10:07,570
系统，另一件事也在这里，这

1836
01:10:07,570 --> 01:10:11,580
是我昨晚将其推送到项目的一个

1837
01:10:11,580 --> 01:10:14,230
分支，但现在您可以

1838
01:10:14,230 --> 01:10:16,090
通过 一个环境变量

1839
01:10:16,090 --> 01:10:18,310
你想用多少线程来运行

1840
01:10:18,310 --> 01:10:19,900
基准测试，所以默认情况下，如果你只

1841
01:10:19,900 --> 01:10:21,700
运行槽迭代器基准测试，它会给

1842
01:10:21,700 --> 01:10:23,740
你一个线程，你可以设置它来说明

1843
01:10:23,740 --> 01:10:24,850
你想使用多少线程

1844
01:10:24,850 --> 01:10:26,920
记住来识别什么

1845
01:10:26,920 --> 01:10:28,780
瓶颈是如果你

1846
01:10:28,780 --> 01:10:30,430
有一个线程它不会出现它会在你

1847
01:10:30,430 --> 01:10:32,110
有更多线程时出现

1848
01:10:32,110 --> 01:10:33,640
如果你想以更高的

1849
01:10:33,640 --> 01:10:37,210
线程数运行这将是非常明显的所以你运行

1850
01:10:37,210 --> 01:10:40,030
了一会儿 然后它会吐出这个呼叫

1851
01:10:40,030 --> 01:10:42,220
研磨文件，然后有像

1852
01:10:42,220 --> 01:10:43,930
蛋糕神社这样的工具，它会给你一个很好的

1853
01:10:43,930 --> 01:10:46,060
可视化并分解一个什么叫它

1854
01:10:46,060 --> 01:10:47,590
所以这实际上来自

1855
01:10:47,590 --> 01:10:49,000
我们去年给学生的基准

1856
01:10:49,000 --> 01:10:51,160
但是高 -级别的想法是

1857
01:10:51,160 --> 01:10:52,990
一样的，所以在这里你可以 ee

1858
01:10:52,990 --> 01:10:55,390
社区分发时间，它

1859
01:10:55,390 --> 01:10:57,160


1860
01:10:57,160 --> 01:10:57,969


1861
01:10:57,969 --> 01:10:59,289
位于系统中调用堆栈的顶部，您知道

1862
01:10:59,289 --> 01:11:00,610
在这些

1863
01:11:00,610 --> 01:11:02,380
不同的函数调用中花费的时间百分比是多少，然后这

1864
01:11:02,380 --> 01:11:03,610
是一个很好的调用图视图，您可以

1865
01:11:03,610 --> 01:11:05,650
深入查看 并为这个函数说得好

1866
01:11:05,650 --> 01:11:07,690
它调用了这个函数你

1867
01:11:07,690 --> 01:11:09,579
知道一百万次但我在这方面发送

1868
01:11:09,579 --> 01:11:10,449
了我总时间的零点百分之三四

1869
01:11:10,449 --> 01:11:12,489
但我在这里花了百分之九

1870
01:11:12,489 --> 01:11:14,139
但我去了九百万次所以

1871
01:11:14,139 --> 01:11:16,059
你可以深入了解

1872
01:11:16,059 --> 01:11:17,800
我实际上在什么功能上花费了最多的

1873
01:11:17,800 --> 01:11:20,739
时间，但这再次向

1874
01:11:20,739 --> 01:11:24,610
您展示这就像调用，只是在

1875
01:11:24,610 --> 01:11:26,829
挂钟时间它不会向

1876
01:11:26,829 --> 01:11:29,170
您显示循环计数，这将是有用

1877
01:11:29,170 --> 01:11:32,800
的，好吧，如此完美，这就是

1878
01:11:32,800 --> 01:11:35,199
收集

1879
01:11:35,199 --> 01:11:37,360
从 Linux 形成的低级性能计数器，

1880
01:11:37,360 --> 01:11:40,030
exit 8s 为您提供我认为 Mac

1881
01:11:40,030 --> 01:11:43,630
只是为了工作我认为它应该我不

1882
01:11:43,630 --> 01:11:44,949
知道最大我还没有尝试过但是

1883
01:11:44,949 --> 01:11:47,979
如果它没有我们就行不通 会想

1884
01:11:47,979 --> 01:11:50,739
一切正常，所以基本上

1885
01:11:50,739 --> 01:11:52,869
有很多不同的

1886
01:11:52,869 --> 01:11:55,929
事情你可以从

1887
01:11:55,929 --> 01:11:57,579
硬件中收集关于正在运行的进程的信息

1888
01:11:57,579 --> 01:12:00,519
，然后你可以设置

1889
01:12:00,519 --> 01:12:02,679
你想要采样的频率我说这

1890
01:12:02,679 --> 01:12:03,999
将每两千次采样一次

1891
01:12:03,999 --> 01:12:05,889
事件，然后在您

1892
01:12:05,889 --> 01:12:07,119
运行时，它会将其记录在这个

1893
01:12:07,119 --> 01:12:08,820
完美的数据文件

1894
01:12:08,820 --> 01:12:10,809


1895
01:12:10,809 --> 01:12:13,269


1896
01:12:13,269 --> 01:12:15,039


1897
01:12:15,039 --> 01:12:16,749


1898
01:12:16,749 --> 01:12:18,130
中 硬件获得这些哈佛

1899
01:12:18,130 --> 01:12:19,300
计数器，

1900
01:12:19,300 --> 01:12:21,280
操作系统 nomen 没有为您提供一些东西，因为

1901
01:12:21,280 --> 01:12:22,570
您可以为任何运行正常的进程执行此操作，

1902
01:12:22,570 --> 01:12:25,929
所以基本上发生的

1903
01:12:25,929 --> 01:12:27,280
事情就像有内部计数器

1904
01:12:27,280 --> 01:12:28,960
和硬件，然后当它们

1905
01:12:28,960 --> 01:12:30,849
转到某个

1906
01:12:30,849 --> 01:12:34,389
基于事件计数器的量权，然后它记录一个

1907
01:12:34,389 --> 01:12:36,550
样本权，它包含

1908
01:12:36,550 --> 01:12:39,579
有关各个

1909
01:12:39,579 --> 01:12:41,050
代码行的所有信息，实际上在

1910
01:12:41,050 --> 01:12:42,909
再次调用什么的程序集级别

1911
01:12:42,909 --> 01:12:44,710
你想用

1912
01:12:44,710 --> 01:12:46,389
带有调试符号的发布模式编译它，这样当你

1913
01:12:46,389 --> 01:12:47,889
查看每个文件时，它会向

1914
01:12:47,889 --> 01:12:51,179
你显示实际的代码行是的，

1915
01:12:55,489 --> 01:13:03,950
我吃它如果你运行会发生什么

1916
01:13:03,950 --> 01:13:05,360
它有点弱，如果你

1917
01:13:05,360 --> 01:13:07,730
有时间在较低的核心数上做一个演示

1918
01:13:07,730 --> 01:13:09,440
瓶颈可能不会出现，因为

1919
01:13:09,440 --> 01:13:11,270
每个人都没有在较高的核心数上击中它

1920
01:13:11,270 --> 01:13:12,770
它肯定会出现

1921
01:13:12,770 --> 01:13:17,120
并且你可以尝试它真的很明显

1922
01:13:17,120 --> 01:13:18,860
你的笔记本电脑第一次出现 我现在会告诉

1923
01:13:18,860 --> 01:13:20,270
你 我应该告诉你它是什么 它

1924
01:13:20,270 --> 01:13:21,980
不是没有 它是一个鞭子 不是

1925
01:13:21,980 --> 01:13:28,850
一个神秘的权利和什么 Indus INR 是的

1926
01:13:28,850 --> 01:13:33,050
是的 所以无论如何所以你运行这个如果

1927
01:13:33,050 --> 01:13:36,200
你运行 perf 我想我 今天早上试过这个，

1928
01:13:36,200 --> 01:13:37,610
如果你用更高的核心

1929
01:13:37,610 --> 01:13:40,760
帐户运行更高的线程数需要

1930
01:13:40,760 --> 01:13:43,340
很长时间，然后基准测试

1931
01:13:43,340 --> 01:13:44,960
甚至无法完成并且文件就像 10 个演出

1932
01:13:44,960 --> 01:13:47,210
所以你我会告诉你你可以早点杀死它

1933
01:13:47,210 --> 01:13:49,969
然后有很好的第三方

1934
01:13:49,969 --> 01:13:51,920
可视化工具，我称之为热门 发现

1935
01:13:51,920 --> 01:13:53,000
它适用于 Linux 我不知道它是否

1936
01:13:53,000 --> 01:13:54,590
适用于 Mac 我会给你像

1937
01:13:54,590 --> 01:13:55,730
火焰图和向你展示

1938
01:13:55,730 --> 01:13:57,860
更容易阅读的东西，

1939
01:13:57,860 --> 01:14:01,010
比如 perf 工具，但让我给

1940
01:14:01,010 --> 01:14:13,520
你一个 快速演示对，所以我说这又是

1941
01:14:13,520 --> 01:14:15,800
我用调试信息编译的

1942
01:14:15,800 --> 01:14:17,630
这只是底部的 H 顶部 这是

1943
01:14:17,630 --> 01:14:18,860
我们实验室中的机器有 40 个

1944
01:14:18,860 --> 01:14:21,770
内核所以我已经设置了

1945
01:14:21,770 --> 01:14:23,150
环境变量实际上我没有这样

1946
01:14:23,150 --> 01:14:28,900
做 我的意思是低回答案，

1947
01:14:33,050 --> 01:14:36,270
所以我再次将环境

1948
01:14:36,270 --> 01:14:38,760
变量 Terrier 基准线程设置为 16

1949
01:14:38,760 --> 01:14:40,830
，这将保证我将

1950
01:14:40,830 --> 01:14:42,690
使其运行 16 个威胁，所以再次

1951
01:14:42,690 --> 01:14:44,130
在这里我不会运行我

1952
01:14:44,130 --> 01:14:45,810
要去的垃圾 运行 perf the salaat iterate

1953
01:14:45,810 --> 01:14:47,700
benchmark 我要记录循环计数

1954
01:14:47,700 --> 01:14:49,650
，我不会每 2,000 次收集样本

1955
01:14:49,650 --> 01:14:51,240
，然后只收集

1956
01:14:51,240 --> 01:14:54,390
我要正确运行的二进制文件，然后这

1957
01:14:54,390 --> 01:14:56,960
只是在右下角向我展示那个

1958
01:14:56,960 --> 01:15:00,660
镜头 我正在使用我正在使用 16 个内核，

1959
01:15:00,660 --> 01:15:04,290
正如预期的那样，所以我

1960
01:15:04,290 --> 01:15:07,590
再次使用 100%，因为

1961
01:15:07,590 --> 01:15:08,580
他们的系统存在瓶颈，他们试图

1962
01:15:08,580 --> 01:15:10,200
一遍又一遍地做某事，但

1963
01:15:10,200 --> 01:15:11,730
实际上并

1964
01:15:11,730 --> 01:15:12,840
没有取得进展，他们实际上并没有开始

1965
01:15:12,840 --> 01:15:14,340
工作，所以尽管

1966
01:15:14,340 --> 01:15:16,080
看起来我的利用率很棒，

1967
01:15:16,080 --> 01:15:18,810
但实际上很糟糕，因为 这是我

1968
01:15:18,810 --> 01:15:21,480
被困在这个瓶颈上，所以这

1969
01:15:21,480 --> 01:15:23,910
可能会永远运行很长时间

1970
01:15:23,910 --> 01:15:26,910
，并需要一段时间，所以你去 control-c

1971
01:15:26,910 --> 01:15:28,350
并杀死它它会告诉你

1972
01:15:28,350 --> 01:15:31,410
它被唤醒多少次以获取某些

1973
01:15:31,410 --> 01:15:34,710
数据 然后 perf 跟踪又是 32

1974
01:15:34,710 --> 01:15:36,390
Meg，从几秒钟

1975
01:15:36,390 --> 01:15:42,060
到 32 Meg，所以现在我可以运行了，我

1976
01:15:42,060 --> 01:15:44,610
可以在这里实际运行 perf 报告，所以

1977
01:15:44,610 --> 01:15:47,820
在我的目录中，它会

1978
01:15:47,820 --> 01:15:49,920
在你运行后立即生成这个 perf 数据文件 perf

1979
01:15:49,920 --> 01:15:51,690
它会吐出来所以如果我再次运行 perf

1980
01:15:51,690 --> 01:15:53,610
report 你必须是

1981
01:15:53,610 --> 01:15:56,660
这个权利的 root 它会处理文件

1982
01:15:56,660 --> 01:16:01,740
然后给你一个

1983
01:16:01,740 --> 01:16:02,850
你在程序中花费所有时间的列表

1984
01:16:02,850 --> 01:16:04,380
因为我再次

1985
01:16:04,380 --> 01:16:05,580
使用调试符号运行我可以看到

1986
01:16:05,580 --> 01:16:08,040
每个 这么一看，我看到

1987
01:16:08,040 --> 01:16:09,660
了槽迭代基准测试的最顶端

1988
01:16:09,660 --> 01:16:13,590
我在这里花费了 48 49%

1989
01:16:13,590 --> 01:16:15,480
的时间在一些函数上，然后

1990
01:16:15,480 --> 01:16:16,770
我 45% 的时间在这里看起来是函数

1991
01:16:16,770 --> 01:16:19,200
，所以其余的就是它

1992
01:16:19,200 --> 01:16:21,120
实际所做的 工作所以这

1993
01:16:21,120 --> 01:16:22,470
显然是瓶颈所以你可以

1994
01:16:22,470 --> 01:16:24,540
做的是你可以Joe down目的一个很好的

1995
01:16:24,540 --> 01:16:26,730
工具你可以深入到这个你

1996
01:16:26,730 --> 01:16:29,220
说注释插槽8或加号

1997
01:16:29,220 --> 01:16:31,410
运算符然后现在我看到源代码

1998
01:16:31,410 --> 01:16:33,690
然后我 可以深入查看我

1999
01:16:33,690 --> 01:16:36,630


2000
01:16:36,630 --> 01:16:39,810
在这个测试操作符中花费了 94% 的时间来处理这个函数，

2001
01:16:39,810 --> 01:16:40,980
因为我在做什么，我试图

2002
01:16:40,980 --> 01:16:42,300
尝试获取一个自旋锁存器，所以我

2003
01:16:42,300 --> 01:16:44,100
在这个锁存器上旋转试图获取

2004
01:16:44,100 --> 01:16:46,310
它 这就是为什么我在那个右边花了 94% 的

2005
01:16:46,310 --> 01:16:48,640
时间，那是瓶颈

2006
01:16:48,640 --> 01:16:52,760
，我可以回去我认为是逃避，

2007
01:16:52,760 --> 01:16:57,290
现在看到另一个注释现在花

2008
01:16:57,290 --> 01:17:00,290
了我 91% 的时间在同一个旋转

2009
01:17:00,290 --> 01:17:02,780
比赛上 TVB 是线程构建块 这

2010
01:17:02,780 --> 01:17:04,310
是 我们使用一些英特尔的库来

2011
01:17:04,310 --> 01:17:06,290
为我们提供自旋匹配它 实际上是

2012
01:17:06,290 --> 01:17:08,690
一个很好的模仿，但同样，

2013
01:17:08,690 --> 01:17:09,920
如果你

2014
01:17:09,920 --> 01:17:11,150
不正确地使用它，你会遇到问题，

2015
01:17:11,150 --> 01:17:12,410
所以即使它

2016
01:17:12,410 --> 01:17:14,870
是自旋锁存器的一个很好的实现，如果你

2017
01:17:14,870 --> 01:17:16,850
有一个诀窍注意点它

2018
01:17:16,850 --> 01:17:19,670
会很慢，所以我 正在发送

2019
01:17:19,670 --> 01:17:21,410
一个链接 有一个很棒的视频

2020
01:17:21,410 --> 01:17:25,220
大约一个小时长关于如何再次使用

2021
01:17:25,220 --> 01:17:27,920
perf 是同样的事情

2022
01:17:27,920 --> 01:17:30,500
向您展示了有一个很好的工具可以

2023
01:17:30,500 --> 01:17:31,910
为您提供这样的火焰图但是对于

2024
01:17:31,910 --> 01:17:33,650
这个很明显可以

2025
01:17:33,650 --> 01:17:34,940
还有很多其他事件你可以

2026
01:17:34,940 --> 01:17:37,820
在这里找回一堆链接 好吧 下

2027
01:17:37,820 --> 01:17:40,190
节课将学习索引 我们将

2028
01:17:40,190 --> 01:17:41,390
花一点时间开始谈论

2029
01:17:41,390 --> 01:17:42,470
茶树 因为

2030
01:17:42,470 --> 01:17:44,690
从历史的角度来看它们是永存

2031
01:17:44,690 --> 01:17:46,160
的 我们大部分时间都在 谈论

2032
01:17:46,160 --> 01:17:49,100
前面索引的 lat 树和来自 Microsoft 的 BW 树

2033
01:17:49,100 --> 01:17:51,080
，然后我们将讨论如何

2034
01:17:51,080 --> 01:17:53,060
为 B 加树锁定新版本，

2035
01:17:53,060 --> 01:17:56,300
好的，有任何问题，谢谢，在旁边的

2036
01:17:56,300 --> 01:17:59,620
公园里，这是什么

2037
01:17:59,780 --> 01:18:02,890
[音乐]

2038
01:18:02,890 --> 01:18:05,020
在这里 cal 带领整个它，因为我很喜欢

2039
01:18:05,020 --> 01:18:07,750
测试团队，你好，你看

2040
01:18:07,750 --> 01:18:10,870
，它是去拿我四十来

2041
01:18:10,870 --> 01:18:12,970
获得我的流行歌曲因为我需要

2042
01:18:12,970 --> 01:18:15,580
像鱼一样多踢一点，只要

2043
01:18:15,580 --> 01:18:18,040
一次滑过就可以了 到我的嘴唇，

2044
01:18:18,040 --> 01:18:21,940
撕掉顶部 April 做了一个很好的热狗，我的

2045
01:18:21,940 --> 01:18:24,520
心会说我已经把你切成丁

2046
01:18:24,520 --> 01:18:27,810
了，为了猎物

