1
00:00:01,300 --> 00:00:05,129
[Music]

2
00:00:05,200 --> 00:00:05,930
[Applause]

3
00:00:05,930 --> 00:00:08,630
[Music]

4
00:00:08,630 --> 00:00:10,020
[Applause]

5
00:00:10,020 --> 00:00:11,420
[Music]

6
00:00:11,420 --> 00:00:14,670
today is our second lecture on query

7
00:00:14,670 --> 00:00:18,240
optimization so again the high-level

8
00:00:18,240 --> 00:00:19,350
idea or what we're trying to do here

9
00:00:19,350 --> 00:00:22,859
today is give it a sequel query we want

10
00:00:22,859 --> 00:00:26,070
to generate a physical execution plan

11
00:00:26,070 --> 00:00:28,380
for that query that is both correct

12
00:00:28,380 --> 00:00:30,960
meaning it will generate the correct

13
00:00:30,960 --> 00:00:33,480
answer we'd expect as well as has the

14
00:00:33,480 --> 00:00:36,120
lowest cost of all the query plans that

15
00:00:36,120 --> 00:00:42,329
we we could examine the again we said

16
00:00:42,329 --> 00:00:43,860
last class that this is super hard to do

17
00:00:43,860 --> 00:00:47,010
because the the problem trying to find a

18
00:00:47,010 --> 00:00:49,649
query plan is proven to be np-complete

19
00:00:49,649 --> 00:00:52,559
and therefore even though the name of

20
00:00:52,559 --> 00:00:53,489
what we're trying to do is called the

21
00:00:53,489 --> 00:00:55,140
optimizer we're not really ever gonna be

22
00:00:55,140 --> 00:00:57,000
gonna try to find in most cases form

23
00:00:57,000 --> 00:00:59,520
useful complex queries the true optimal

24
00:00:59,520 --> 00:01:04,049
plan so we last class we looked over a

25
00:01:04,049 --> 00:01:07,320
bunch of different approaches to doing

26
00:01:07,320 --> 00:01:10,200
this search we first talked up talked

27
00:01:10,200 --> 00:01:13,380
about how to take use heuristics where

28
00:01:13,380 --> 00:01:14,610
you just have these if-then-else

29
00:01:14,610 --> 00:01:16,650
statements that are bacon the source

30
00:01:16,650 --> 00:01:18,540
code looking for certain query patterns

31
00:01:18,540 --> 00:01:20,880
and applying changes to to the query

32
00:01:20,880 --> 00:01:23,369
plan to put into a different form then

33
00:01:23,369 --> 00:01:25,320
we talked about how to do a combination

34
00:01:25,320 --> 00:01:26,850
of the heuristics from the first

35
00:01:26,850 --> 00:01:30,020
approach as well as a cost based search

36
00:01:30,020 --> 00:01:32,250
approach that came from the system or

37
00:01:32,250 --> 00:01:35,700
from IBM that allows us to find a

38
00:01:35,700 --> 00:01:37,860
optimal joint ordering and the key idea

39
00:01:37,860 --> 00:01:39,990
here what makes the cost model base one

40
00:01:39,990 --> 00:01:42,299
different here is that the cost model is

41
00:01:42,299 --> 00:01:43,979
guiding our search it's a way for us to

42
00:01:43,979 --> 00:01:47,520
approximate the cost of a query plan and

43
00:01:47,520 --> 00:01:49,740
then use that approximation to compare

44
00:01:49,740 --> 00:01:52,590
one plan versus another we then talked

45
00:01:52,590 --> 00:01:55,259
about how to do a randomized search with

46
00:01:55,259 --> 00:01:58,170
simulated nailing or the gener algorithm

47
00:01:58,170 --> 00:01:59,939
from Postgres and as far as I know again

48
00:01:59,939 --> 00:02:02,520
Postgres is the only one using this

49
00:02:02,520 --> 00:02:03,390
third choice here

50
00:02:03,390 --> 00:02:05,880
but they only use it for queries that

51
00:02:05,880 --> 00:02:09,288
are have more than 13 tables otherwise

52
00:02:09,288 --> 00:02:12,020
by default you get the second approach

53
00:02:12,020 --> 00:02:14,610
and then now we talked about

54
00:02:14,610 --> 00:02:16,340
the movement in late 1980s early 1990s

55
00:02:16,340 --> 00:02:19,650
towards these optimizer generators where

56
00:02:19,650 --> 00:02:22,230
instead of having imperative code we

57
00:02:22,230 --> 00:02:25,140
didn't see or C++ to do all these steps

58
00:02:25,140 --> 00:02:29,090
for the query plan lien instead write a

59
00:02:29,090 --> 00:02:31,410
our optimizer rules in a high-level

60
00:02:31,410 --> 00:02:34,020
language than have a compiler generate

61
00:02:34,020 --> 00:02:37,530
the optimizer for us so Starbucks was

62
00:02:37,530 --> 00:02:39,000
sort of the first one in this space from

63
00:02:39,000 --> 00:02:41,400
IBM and it was using a stratified search

64
00:02:41,400 --> 00:02:44,250
which which is like this the heuristics

65
00:02:44,250 --> 00:02:47,340
plus the cost base joint search and then

66
00:02:47,340 --> 00:02:51,750
the unified search is doing the sort of

67
00:02:51,750 --> 00:02:53,820
the logical and logical logical

68
00:02:53,820 --> 00:02:55,170
illogical physical transformations

69
00:02:55,170 --> 00:02:57,990
all in one and this is what was used in

70
00:02:57,990 --> 00:03:01,320
Cascades for the paper you guys read so

71
00:03:01,320 --> 00:03:04,170
again just to reiterate in the last two

72
00:03:04,170 --> 00:03:06,360
points just repeating myself the

73
00:03:06,360 --> 00:03:09,030
stratified search is where we're gonna

74
00:03:09,030 --> 00:03:11,400
have these rules to do that the logical

75
00:03:11,400 --> 00:03:15,300
quad plan transformations and the the

76
00:03:15,300 --> 00:03:16,770
idea of way this is going to work is

77
00:03:16,770 --> 00:03:18,930
again there isn't like there isn't just

78
00:03:18,930 --> 00:03:22,500
a list of rules where we apply them one

79
00:03:22,500 --> 00:03:25,590
after another there's this rule engine

80
00:03:25,590 --> 00:03:27,270
for us that it's gonna look at the query

81
00:03:27,270 --> 00:03:29,730
plan figure out sort of patterns that

82
00:03:29,730 --> 00:03:32,880
would match what what is what rules we

83
00:03:32,880 --> 00:03:35,130
have to find and then fire them off to

84
00:03:35,130 --> 00:03:37,260
to make make our change but again in

85
00:03:37,260 --> 00:03:39,750
this first step it's entirely done

86
00:03:39,750 --> 00:03:43,800
without any without consulting a cost

87
00:03:43,800 --> 00:03:46,140
model cuz there is no cost model then

88
00:03:46,140 --> 00:03:48,120
after this we do the same cost based

89
00:03:48,120 --> 00:03:49,980
search to map the logical plan to the

90
00:03:49,980 --> 00:03:52,140
physical plan and again that was the IBM

91
00:03:52,140 --> 00:03:55,080
technique but you know if I'd search

92
00:03:55,080 --> 00:03:57,150
again the idea here is that rather than

93
00:03:57,150 --> 00:03:59,310
having these two separate stages you

94
00:03:59,310 --> 00:04:03,030
just have a single single search process

95
00:04:03,030 --> 00:04:07,020
or a single search procedure that can do

96
00:04:07,020 --> 00:04:09,330
both the logical to logical and logical

97
00:04:09,330 --> 00:04:11,790
physical transformations so no longer do

98
00:04:11,790 --> 00:04:13,710
you need the separate stages because

99
00:04:13,710 --> 00:04:15,080
you're just doing everything all at once

100
00:04:15,080 --> 00:04:18,750
right so the and what we'll see when we

101
00:04:18,750 --> 00:04:22,200
talk about cascades is that the this

102
00:04:22,200 --> 00:04:23,900
approach is going to generate a lot of

103
00:04:23,900 --> 00:04:26,960
redundant transformations

104
00:04:26,960 --> 00:04:29,310
because again like in the stratified

105
00:04:29,310 --> 00:04:31,620
search once I get past that first stage

106
00:04:31,620 --> 00:04:33,870
I'm never gonna reconsider those rules

107
00:04:33,870 --> 00:04:36,990
again but in the unified search it's all

108
00:04:36,990 --> 00:04:39,240
combined together so you may be trying

109
00:04:39,240 --> 00:04:42,150
to evaluate the same rule over and over

110
00:04:42,150 --> 00:04:44,160
again and so you'd have to use

111
00:04:44,160 --> 00:04:47,070
memorization to to identify that you're

112
00:04:47,070 --> 00:04:49,770
doing redundant computation or add

113
00:04:49,770 --> 00:04:52,370
redundant transformation and use a cache

114
00:04:52,370 --> 00:04:54,570
cache result rather than applying it

115
00:04:54,570 --> 00:04:56,700
again again what we'll cover this in

116
00:04:56,700 --> 00:04:58,380
more detail about when we talk Cascades

117
00:04:58,380 --> 00:05:03,300
the in addition to whether you want a

118
00:05:03,300 --> 00:05:07,160
unified versus stratified another

119
00:05:07,160 --> 00:05:09,930
another sort of design decision you have

120
00:05:09,930 --> 00:05:12,000
to make in your query optimizer is

121
00:05:12,000 --> 00:05:14,550
whether you want to do a top top-down or

122
00:05:14,550 --> 00:05:18,120
bottom-up optimization so top-down will

123
00:05:18,120 --> 00:05:19,260
be Cascades and that's where you start

124
00:05:19,260 --> 00:05:21,180
with a final outcome that you want okay

125
00:05:21,180 --> 00:05:23,370
I want to join these three tables

126
00:05:23,370 --> 00:05:25,920
together and then you Traverse down into

127
00:05:25,920 --> 00:05:29,330
a search tree and start adding in the

128
00:05:29,330 --> 00:05:31,260
operators the physical operators or

129
00:05:31,260 --> 00:05:32,970
logical operators you need to get to

130
00:05:32,970 --> 00:05:35,430
that end goal and you can use the

131
00:05:35,430 --> 00:05:37,680
classic branch about pruning technique

132
00:05:37,680 --> 00:05:39,720
to recognize that if there's a branch

133
00:05:39,720 --> 00:05:43,169
that has a the current cost is greater

134
00:05:43,169 --> 00:05:44,669
than the lowest cost you've seen from it

135
00:05:44,669 --> 00:05:46,260
from the current off-the-book current

136
00:05:46,260 --> 00:05:47,910
best plan you know you don't need to

137
00:05:47,910 --> 00:05:53,190
burst down into it the the dynamic

138
00:05:53,190 --> 00:05:54,390
programming technique these fall from

139
00:05:54,390 --> 00:05:56,700
the system are is an example of a

140
00:05:56,700 --> 00:05:58,919
bottom-up optimization where you start

141
00:05:58,919 --> 00:06:01,590
with nothing at the bottom and you start

142
00:06:01,590 --> 00:06:05,190
it early adding in the components or the

143
00:06:05,190 --> 00:06:06,660
operators that you need for the query

144
00:06:06,660 --> 00:06:10,050
plan to get to that end goal right again

145
00:06:10,050 --> 00:06:12,120
this is this is the dynamic web eutectic

146
00:06:12,120 --> 00:06:15,870
so the current literature suggests that

147
00:06:15,870 --> 00:06:18,270
the dynamic programming bottom-up

148
00:06:18,270 --> 00:06:20,130
optimization is better we'll talk a

149
00:06:20,130 --> 00:06:22,230
little bit about today why that's the

150
00:06:22,230 --> 00:06:28,050
case the in my opinion from a software

151
00:06:28,050 --> 00:06:31,290
engineering standpoint I feel that I'm

152
00:06:31,290 --> 00:06:33,150
able to reason about the unified

153
00:06:33,150 --> 00:06:34,830
approach and the top-down approach

154
00:06:34,830 --> 00:06:37,169
better and this is what we implemented

155
00:06:37,169 --> 00:06:39,479
in our system

156
00:06:39,479 --> 00:06:41,139
again there's like the research

157
00:06:41,139 --> 00:06:42,130
literature and then there's what

158
00:06:42,130 --> 00:06:43,180
actually gets implemented in real

159
00:06:43,180 --> 00:06:47,380
systems so you will see for the paper in

160
00:06:47,380 --> 00:06:49,780
to next week or two weeks when I order

161
00:06:49,780 --> 00:06:52,410
yeah next week next Wednesday that

162
00:06:52,410 --> 00:06:54,250
sequel server actually has the best

163
00:06:54,250 --> 00:06:55,870
query optimizer and they're using a

164
00:06:55,870 --> 00:06:59,229
top-down Cascades approach but the

165
00:06:59,229 --> 00:07:00,729
literature shows that the dynamic

166
00:07:00,729 --> 00:07:02,560
reading bottom one bottom-up one is

167
00:07:02,560 --> 00:07:04,180
better because again there's a lot more

168
00:07:04,180 --> 00:07:06,340
going on than just you know whether

169
00:07:06,340 --> 00:07:08,320
you're going in.i these directions the

170
00:07:08,320 --> 00:07:09,910
cost model matters a lot how you

171
00:07:09,910 --> 00:07:11,770
collecting that the cardinality

172
00:07:11,770 --> 00:07:13,570
estimations all that will contribute to

173
00:07:13,570 --> 00:07:16,810
the overall efficacy and quality of the

174
00:07:16,810 --> 00:07:18,760
query plan so generate and not just what

175
00:07:18,760 --> 00:07:21,639
algorithm using it alright so for

176
00:07:21,639 --> 00:07:23,889
today's agenda I want to spend some time

177
00:07:23,889 --> 00:07:25,630
beginning talk about how we're gonna do

178
00:07:25,630 --> 00:07:28,240
logical query optimization again these

179
00:07:28,240 --> 00:07:29,919
the things we'll talk about here are

180
00:07:29,919 --> 00:07:30,970
applicable to whether you're doing a

181
00:07:30,970 --> 00:07:33,250
stratified or unified search then we'll

182
00:07:33,250 --> 00:07:35,080
spend time talking about what the

183
00:07:35,080 --> 00:07:37,000
Cascades how the Cascades optimize it

184
00:07:37,000 --> 00:07:38,740
looks like and we'll do this in the

185
00:07:38,740 --> 00:07:40,660
context as described in the paper ahead

186
00:07:40,660 --> 00:07:42,610
you guys read which say master's thesis

187
00:07:42,610 --> 00:07:45,130
from the late nineteen eighty nineteen

188
00:07:45,130 --> 00:07:48,520
90s on a query optimizer based on

189
00:07:48,520 --> 00:07:51,010
cascade called Columbia the reason why I

190
00:07:51,010 --> 00:07:52,270
had you read that paper instead of the

191
00:07:52,270 --> 00:07:53,650
original Cascades papers because the

192
00:07:53,650 --> 00:07:55,990
original cascades paper is not very good

193
00:07:55,990 --> 00:07:58,000
it doesn't really describe what they're

194
00:07:58,000 --> 00:07:59,409
actually doing they keep banging on

195
00:07:59,409 --> 00:08:00,789
about how great it was that their

196
00:08:00,789 --> 00:08:02,800
object-oriented because that was in

197
00:08:02,800 --> 00:08:05,080
vogue and in the early 1990s whereas

198
00:08:05,080 --> 00:08:07,240
those thirty pages from that columbia

199
00:08:07,240 --> 00:08:08,760
master's thesis

200
00:08:08,760 --> 00:08:11,190
lays out in my opinion the best

201
00:08:11,190 --> 00:08:13,360
description of how cascades actually

202
00:08:13,360 --> 00:08:15,159
works and how its implemented well

203
00:08:15,159 --> 00:08:17,560
briefly talk about why some things that

204
00:08:17,560 --> 00:08:19,539
dynamic programming can do that maybe

205
00:08:19,539 --> 00:08:21,599
Cask use Cascades can't do very easily

206
00:08:21,599 --> 00:08:23,800
at least in the moderate implementation

207
00:08:23,800 --> 00:08:26,380
as you've i've got the hyper guys in

208
00:08:26,380 --> 00:08:28,210
germany then we'll talk about a bunch of

209
00:08:28,210 --> 00:08:30,220
other sort of optimizer implementations

210
00:08:30,220 --> 00:08:31,780
that are out there again these are be

211
00:08:31,780 --> 00:08:33,549
categorized as whether they're doing

212
00:08:33,549 --> 00:08:35,620
dynamic programming or Cascades

213
00:08:35,620 --> 00:08:37,208
but again I just want it should be we

214
00:08:37,208 --> 00:08:38,620
want you to be aware of what's out there

215
00:08:38,620 --> 00:08:42,520
and then we'll finish up with a quick

216
00:08:42,520 --> 00:08:45,580
overview of what's expected starting on

217
00:08:45,580 --> 00:08:47,890
Wednesday this week for your project

218
00:08:47,890 --> 00:08:49,360
three code review submissions so

219
00:08:49,360 --> 00:08:51,130
and we'll do two rounds of Coast

220
00:08:51,130 --> 00:08:53,470
missions equip of use so I'll sign you

221
00:08:53,470 --> 00:08:55,810
to another group on Wednesday you sweep

222
00:08:55,810 --> 00:08:58,870
your code on github doto code review of

223
00:08:58,870 --> 00:09:00,970
your code and you do a code review of

224
00:09:00,970 --> 00:09:02,800
their code so I want to talk about what

225
00:09:02,800 --> 00:09:04,360
sort of expected for you as a student

226
00:09:04,360 --> 00:09:05,829
participating in this project for the

227
00:09:05,829 --> 00:09:10,209
stuff yeah all right so again there's

228
00:09:10,209 --> 00:09:12,010
going to be two types of optimizations

229
00:09:12,010 --> 00:09:13,450
that we can do there's the logical

230
00:09:13,450 --> 00:09:15,279
optimization and and physical

231
00:09:15,279 --> 00:09:17,910
optimization logical optimization are

232
00:09:17,910 --> 00:09:19,990
changes or transformations that we could

233
00:09:19,990 --> 00:09:23,920
apply to the logical query plan that we

234
00:09:23,920 --> 00:09:28,329
get from the binder right or a further

235
00:09:28,329 --> 00:09:32,769
up in our in our front-end stack that we

236
00:09:32,769 --> 00:09:34,450
can apply rules based on matching

237
00:09:34,450 --> 00:09:38,079
patterns or certain yeah certain

238
00:09:38,079 --> 00:09:40,000
patterns that we would see in the

239
00:09:40,000 --> 00:09:41,860
logical query plan and we can make

240
00:09:41,860 --> 00:09:43,959
changes to the query plan in such a way

241
00:09:43,959 --> 00:09:45,640
that we can potentially set ourselves up

242
00:09:45,640 --> 00:09:48,490
so that when we do the plan enumeration

243
00:09:48,490 --> 00:09:51,700
in the the physical query optimization

244
00:09:51,700 --> 00:09:56,079
step that we can potentially find a the

245
00:09:56,079 --> 00:10:00,070
album plan more easily so it's not

246
00:10:00,070 --> 00:10:01,930
always gonna be the case that the

247
00:10:01,930 --> 00:10:03,399
changes will make here will be guarantee

248
00:10:03,399 --> 00:10:04,839
that we'll be able to find alcone plan

249
00:10:04,839 --> 00:10:06,610
but if we know a little bit about how

250
00:10:06,610 --> 00:10:08,320
our optimizer works we know a little bit

251
00:10:08,320 --> 00:10:10,029
what our you know our plan a new version

252
00:10:10,029 --> 00:10:13,180
album actually is then we can apply

253
00:10:13,180 --> 00:10:14,890
these changes in such a way that we can

254
00:10:14,890 --> 00:10:17,260
prepare ourselves I'm quoting right so

255
00:10:17,260 --> 00:10:18,459
the important thing I'm saying about

256
00:10:18,459 --> 00:10:20,529
this step how we're gonna stage this

257
00:10:20,529 --> 00:10:24,339
between the the when we do physical

258
00:10:24,339 --> 00:10:26,560
query optimization is that again because

259
00:10:26,560 --> 00:10:29,170
there's no cost model we have no way to

260
00:10:29,170 --> 00:10:32,320
determine whether one query plan is

261
00:10:32,320 --> 00:10:34,060
better than another so we don't know

262
00:10:34,060 --> 00:10:36,160
whether we take a collage achill query

263
00:10:36,160 --> 00:10:37,540
plan then transform it to another

264
00:10:37,540 --> 00:10:40,899
logical query plan the the optimizer

265
00:10:40,899 --> 00:10:42,970
that stage can't say oh yes that

266
00:10:42,970 --> 00:10:45,010
transformation was a good thing it's

267
00:10:45,010 --> 00:10:46,630
gonna make a it's gonna help me generate

268
00:10:46,630 --> 00:10:48,850
a query plan with a lower cost we don't

269
00:10:48,850 --> 00:10:52,300
know that but we know systems since we

270
00:10:52,300 --> 00:10:54,040
know some aspects about you know

271
00:10:54,040 --> 00:10:55,630
relational databases or the kana davises

272
00:10:55,630 --> 00:10:56,709
we're trying to run and what our query

273
00:10:56,709 --> 00:10:58,329
looks like and how our system actually

274
00:10:58,329 --> 00:11:01,709
performs we can then maybe direct our

275
00:11:01,709 --> 00:11:03,279
transformations so

276
00:11:03,279 --> 00:11:07,079
we prefer you know one plan over another

277
00:11:07,079 --> 00:11:09,009
okay but the end of the day the

278
00:11:09,009 --> 00:11:11,170
important thing is that the the original

279
00:11:11,170 --> 00:11:13,329
plan or the new plan we generate after

280
00:11:13,329 --> 00:11:14,350
these transformations has to be

281
00:11:14,350 --> 00:11:15,999
equivalent to the original plan because

282
00:11:15,999 --> 00:11:17,800
it doesn't help us that yes we found out

283
00:11:17,800 --> 00:11:19,870
faster query if we produce the incorrect

284
00:11:19,870 --> 00:11:22,809
result because people will get tests and

285
00:11:22,809 --> 00:11:23,860
now your database system is considered

286
00:11:23,860 --> 00:11:24,970
unreliable or there's something wrong

287
00:11:24,970 --> 00:11:26,589
with the data like it's harder to debug

288
00:11:26,589 --> 00:11:28,209
that so we want to make sure that any

289
00:11:28,209 --> 00:11:29,980
changes we make be ensure that that

290
00:11:29,980 --> 00:11:33,850
query is equivalent so I want to go

291
00:11:33,850 --> 00:11:37,389
through four different examples of the

292
00:11:37,389 --> 00:11:39,579
types of logical query optimizations we

293
00:11:39,579 --> 00:11:42,639
can do and this actually comes from Tom

294
00:11:42,639 --> 00:11:45,220
Thomas Norman the hyper guy in Germany

295
00:11:45,220 --> 00:11:47,319
he actually teaches a whole class on

296
00:11:47,319 --> 00:11:48,639
coordination and he goes to much more

297
00:11:48,639 --> 00:11:50,620
detail over multiple lectures than what

298
00:11:50,620 --> 00:11:53,199
I can do in just four lectures but some

299
00:11:53,199 --> 00:11:54,790
of these examples are coming come from

300
00:11:54,790 --> 00:11:58,420
from from his slides so we'll see how we

301
00:11:58,420 --> 00:12:00,699
can do splits on conductor predicates

302
00:12:00,699 --> 00:12:03,160
predicates push down replacing Cartesian

303
00:12:03,160 --> 00:12:04,870
products with joins because again at the

304
00:12:04,870 --> 00:12:06,069
very beginning all we have are Cartesian

305
00:12:06,069 --> 00:12:08,170
products and then we can finish up with

306
00:12:08,170 --> 00:12:11,620
during projection push down so for each

307
00:12:11,620 --> 00:12:12,759
of these we're gonna use that same

308
00:12:12,759 --> 00:12:14,110
example clear we have from last class

309
00:12:14,110 --> 00:12:17,350
where we want to do a three-way join

310
00:12:17,350 --> 00:12:20,050
between artist appears an album good to

311
00:12:20,050 --> 00:12:22,089
go find all the artists that appeared on

312
00:12:22,089 --> 00:12:27,100
my on my remix tape so a very beginning

313
00:12:27,100 --> 00:12:28,660
what we're gonna get out of the binder

314
00:12:28,660 --> 00:12:30,160
which is essentially just a copy of what

315
00:12:30,160 --> 00:12:32,879
comes out of the the sequel parser is

316
00:12:32,879 --> 00:12:35,740
all our predicates are going to be

317
00:12:35,740 --> 00:12:39,309
combined together into a single filter

318
00:12:39,309 --> 00:12:43,089
clause so we have three predicate

319
00:12:43,089 --> 00:12:45,250
expressions in our where clause so we

320
00:12:45,250 --> 00:12:46,899
would have a single filter expression in

321
00:12:46,899 --> 00:12:49,059
our query plan again there's a logical

322
00:12:49,059 --> 00:12:50,170
query plan it's not telling us how we

323
00:12:50,170 --> 00:12:51,850
want to execute anything we said we

324
00:12:51,850 --> 00:12:54,670
think the single filter up here that has

325
00:12:54,670 --> 00:12:57,220
all three predicates combined to each

326
00:12:57,220 --> 00:12:59,709
other and we do that filter after we've

327
00:12:59,709 --> 00:13:02,920
taken the Cartesian product of all of

328
00:13:02,920 --> 00:13:06,490
the three tables so in order to make it

329
00:13:06,490 --> 00:13:09,009
easier for us to then start doing

330
00:13:09,009 --> 00:13:10,149
predicate push down on other

331
00:13:10,149 --> 00:13:12,819
optimizations on these individual

332
00:13:12,819 --> 00:13:14,470
predicate expressions we want to

333
00:13:14,470 --> 00:13:16,430
decompose the filter into

334
00:13:16,430 --> 00:13:20,910
multiple filters that each have one one

335
00:13:20,910 --> 00:13:23,399
conjunction of the of the where clause

336
00:13:23,399 --> 00:13:26,430
so we just split it on the end and we

337
00:13:26,430 --> 00:13:29,160
get it like this four ORS it's a little

338
00:13:29,160 --> 00:13:30,389
bit tricky you can essentially start

339
00:13:30,389 --> 00:13:31,620
duplicating the ORS if you have

340
00:13:31,620 --> 00:13:34,110
different conjunctions knots or

341
00:13:34,110 --> 00:13:35,879
negations or a little bit tricky as well

342
00:13:35,879 --> 00:13:37,740
but a little about the high-level idea

343
00:13:37,740 --> 00:13:40,800
is essentially the same alright so now

344
00:13:40,800 --> 00:13:43,019
that we have these these these filters

345
00:13:43,019 --> 00:13:44,970
like this we can start moving them in

346
00:13:44,970 --> 00:13:46,319
different ways we can start moving them

347
00:13:46,319 --> 00:13:48,990
to separately into different parts of

348
00:13:48,990 --> 00:13:51,870
the query plan so this is how the

349
00:13:51,870 --> 00:13:53,459
classic predicate pushdown is going to

350
00:13:53,459 --> 00:13:56,279
work and the idea here is then we can we

351
00:13:56,279 --> 00:14:00,240
can move the the predicate that we have

352
00:14:00,240 --> 00:14:03,810
to be after the Cartesian product or at

353
00:14:03,810 --> 00:14:05,279
the lowest point we can in the query

354
00:14:05,279 --> 00:14:07,410
plan where we have all the information

355
00:14:07,410 --> 00:14:10,800
we need or all the attributes that we

356
00:14:10,800 --> 00:14:13,230
need for the filter at some point in the

357
00:14:13,230 --> 00:14:16,019
tree all right so in this case here

358
00:14:16,019 --> 00:14:17,670
after we do the Cartesian product we can

359
00:14:17,670 --> 00:14:19,560
then apply artists ID equals appears

360
00:14:19,560 --> 00:14:20,399
through our decidd

361
00:14:20,399 --> 00:14:22,680
but we can't do it before on either side

362
00:14:22,680 --> 00:14:25,439
because we don't have those two combine

363
00:14:25,439 --> 00:14:27,779
tuples the two tuples together same

364
00:14:27,779 --> 00:14:29,220
thing for this one up here but in this

365
00:14:29,220 --> 00:14:32,040
case for album name equals Andes remix

366
00:14:32,040 --> 00:14:34,850
we can put that immediately after the

367
00:14:34,850 --> 00:14:38,100
scan on the album table because we have

368
00:14:38,100 --> 00:14:42,689
all the information that we need so now

369
00:14:42,689 --> 00:14:45,089
now we want to replace all the Cartesian

370
00:14:45,089 --> 00:14:46,439
products that we have on a query plan

371
00:14:46,439 --> 00:14:49,980
with with inner joins and this is pretty

372
00:14:49,980 --> 00:14:51,029
simple right this is just identifying

373
00:14:51,029 --> 00:14:53,339
that oh we have a Cartesian product

374
00:14:53,339 --> 00:14:55,230
right above it we have a filter that

375
00:14:55,230 --> 00:14:56,699
takes the output of the Cartesian

376
00:14:56,699 --> 00:14:59,160
product from the table on the left and

377
00:14:59,160 --> 00:15:00,240
table on the right and combine them

378
00:15:00,240 --> 00:15:01,680
together or you know do our quality

379
00:15:01,680 --> 00:15:03,540
match so we can just replace those

380
00:15:03,540 --> 00:15:04,920
Cartesian products were here and here

381
00:15:04,920 --> 00:15:08,579
with a within the join operator when

382
00:15:08,579 --> 00:15:09,930
with the join up or specify where the

383
00:15:09,930 --> 00:15:13,620
join clause is you know is that filter

384
00:15:13,620 --> 00:15:15,269
that you should be right above it and we

385
00:15:15,269 --> 00:15:17,519
can do this regardless of whether the

386
00:15:17,519 --> 00:15:20,160
we're using the old old-style sequel

387
00:15:20,160 --> 00:15:21,930
where the join is actually in the where

388
00:15:21,930 --> 00:15:25,110
clause or some of the more modern sequel

389
00:15:25,110 --> 00:15:27,930
syntax where you have the the join one

390
00:15:27,930 --> 00:15:31,050
clause right this is the same idea works

391
00:15:31,050 --> 00:15:34,560
in either one then the last optimization

392
00:15:34,560 --> 00:15:37,560
we can apply is to do a projection post

393
00:15:37,560 --> 00:15:43,230
push down so in in this case here you

394
00:15:43,230 --> 00:15:45,870
know the beam we're being pedantic here

395
00:15:45,870 --> 00:15:50,519
about the you know whatever query plan

396
00:15:50,519 --> 00:15:52,440
is going to look like in a column store

397
00:15:52,440 --> 00:15:54,269
you could you could implicitly assume

398
00:15:54,269 --> 00:15:57,089
somehow that I'm not scanning the entire

399
00:15:57,089 --> 00:15:58,380
tuple name in the scanning just two

400
00:15:58,380 --> 00:15:59,820
columns that I need but you still need

401
00:15:59,820 --> 00:16:01,440
some information say what actually those

402
00:16:01,440 --> 00:16:02,519
columns you actually need to propagate

403
00:16:02,519 --> 00:16:04,829
up into the query plan so in this case

404
00:16:04,829 --> 00:16:07,380
here we can recognize which attributes

405
00:16:07,380 --> 00:16:10,019
we actually need at different levels in

406
00:16:10,019 --> 00:16:12,269
the tree and we introduced projection

407
00:16:12,269 --> 00:16:16,740
projection operators to then only

408
00:16:16,740 --> 00:16:20,279
propagate up the just the actions we

409
00:16:20,279 --> 00:16:22,350
need at each step and so the way you

410
00:16:22,350 --> 00:16:23,760
think about this is implicitly there's

411
00:16:23,760 --> 00:16:28,410
pipeline breakers here here and I guess

412
00:16:28,410 --> 00:16:31,020
up above here but like at the pipeline

413
00:16:31,020 --> 00:16:34,110
breaker we would introduce a introduce

414
00:16:34,110 --> 00:16:37,410
the the projection and that make sure we

415
00:16:37,410 --> 00:16:38,700
only propagate the data actually need

416
00:16:38,700 --> 00:16:39,899
and the reason why we don't wanna do

417
00:16:39,899 --> 00:16:42,000
this all different parts because at the

418
00:16:42,000 --> 00:16:43,350
pipeline if you're doing a push up

419
00:16:43,350 --> 00:16:47,820
approach like in case of hyper is you

420
00:16:47,820 --> 00:16:49,140
you were going to take a single tuple

421
00:16:49,140 --> 00:16:51,420
and write it up as many as far as you

422
00:16:51,420 --> 00:16:53,190
can up in the query plan and only

423
00:16:53,190 --> 00:16:54,600
materialize it when you get to the

424
00:16:54,600 --> 00:16:56,670
pipeline breaker other systems are doing

425
00:16:56,670 --> 00:16:59,610
volcano are going top-down and that and

426
00:16:59,610 --> 00:17:01,520
that the boundaries aren't aren't aren't

427
00:17:01,520 --> 00:17:08,120
exactly the same okay

428
00:17:08,510 --> 00:17:10,980
again sort of saying here like in this

429
00:17:10,980 --> 00:17:13,679
case here we only need album name and

430
00:17:13,679 --> 00:17:16,050
the album ID so we could have a

431
00:17:16,050 --> 00:17:19,410
projection here just to filter out on my

432
00:17:19,410 --> 00:17:21,720
D now name but again what will happen is

433
00:17:21,720 --> 00:17:23,069
this filter action will get combined

434
00:17:23,069 --> 00:17:25,559
here with whatever this this access

435
00:17:25,559 --> 00:17:26,939
method here however accessing the tuple

436
00:17:26,939 --> 00:17:30,990
so again we're not we don't have

437
00:17:30,990 --> 00:17:32,520
projections everywhere we could write

438
00:17:32,520 --> 00:17:33,600
but because so now is gonna be

439
00:17:33,600 --> 00:17:36,740
implicitly represented this way

440
00:17:36,809 --> 00:17:38,340
again these are all logical

441
00:17:38,340 --> 00:17:41,190
optimizations again I didn't look at a

442
00:17:41,190 --> 00:17:43,499
cost model I just said I know I want to

443
00:17:43,499 --> 00:17:45,080
do things and I can bake the

444
00:17:45,080 --> 00:17:48,419
transformation rules in my optimizer to

445
00:17:48,419 --> 00:17:50,700
do this right like this one's the most

446
00:17:50,700 --> 00:17:52,049
obvious one if I have a Cartesian

447
00:17:52,049 --> 00:17:53,850
product and I have a filter that has a

448
00:17:53,850 --> 00:17:55,919
joined clause right above it then I can

449
00:17:55,919 --> 00:17:57,360
easily just write a rule that combines

450
00:17:57,360 --> 00:17:58,980
that and I don't need to consult a cost

451
00:17:58,980 --> 00:18:02,429
model cuz I know in my data is a inner

452
00:18:02,429 --> 00:18:05,100
joins always going to be preferable to a

453
00:18:05,100 --> 00:18:07,289
Cartesian product you must never really

454
00:18:07,289 --> 00:18:08,460
you never want to exit Cartesian

455
00:18:08,460 --> 00:18:10,200
products unless you're explicitly told

456
00:18:10,200 --> 00:18:13,289
to do across join alright so now let's

457
00:18:13,289 --> 00:18:16,139
talk about how to do physical free

458
00:18:16,139 --> 00:18:18,749
optimization so this is where now we

459
00:18:18,749 --> 00:18:20,549
have a logical query plan we have these

460
00:18:20,549 --> 00:18:22,320
logical operators and we want to

461
00:18:22,320 --> 00:18:24,629
transform them into physical operators

462
00:18:24,629 --> 00:18:26,639
that we can then either koujun if we're

463
00:18:26,639 --> 00:18:28,679
doing compilation or to actually execute

464
00:18:28,679 --> 00:18:33,090
on in our execution engine so what are

465
00:18:33,090 --> 00:18:34,080
the kind of transformations we're going

466
00:18:34,080 --> 00:18:35,940
to want to do the most obvious ones are

467
00:18:35,940 --> 00:18:38,129
gonna be things like specifying how

468
00:18:38,129 --> 00:18:40,139
we're actually going to access the table

469
00:18:40,139 --> 00:18:42,330
or the data and that we're targeting but

470
00:18:42,330 --> 00:18:44,100
I'm gonna use a sequential scan but we

471
00:18:44,100 --> 00:18:46,799
need an index scan if it's so on index

472
00:18:46,799 --> 00:18:48,149
scan then which index we're going to

473
00:18:48,149 --> 00:18:50,220
pick we can add additional execution

474
00:18:50,220 --> 00:18:52,950
information about how we expect the the

475
00:18:52,950 --> 00:18:55,019
data and be represented or sorted or

476
00:18:55,019 --> 00:18:58,230
compressed choose operator invitations

477
00:18:58,230 --> 00:18:59,700
for the joins like we're joint album we

478
00:18:59,700 --> 00:19:01,019
want to use how we actually do our

479
00:19:01,019 --> 00:19:03,240
aggregation and then in some cases also

480
00:19:03,240 --> 00:19:05,240
to which we won't talk about today is

481
00:19:05,240 --> 00:19:07,350
identifying when you actually want to

482
00:19:07,350 --> 00:19:11,129
materialize potentially the the data for

483
00:19:11,129 --> 00:19:13,889
one portion of the query so that another

484
00:19:13,889 --> 00:19:15,509
portion you know another part of the

485
00:19:15,509 --> 00:19:16,980
query plan could actually access it I

486
00:19:16,980 --> 00:19:20,330
can be doing this sub query or views or

487
00:19:20,330 --> 00:19:25,049
cities so in this stage here we now need

488
00:19:25,049 --> 00:19:26,970
to make sure that we or we now have to

489
00:19:26,970 --> 00:19:29,730
support cost model estimates because now

490
00:19:29,730 --> 00:19:31,889
we want to be able to determine is one

491
00:19:31,889 --> 00:19:33,690
physical plan going to be better than

492
00:19:33,690 --> 00:19:35,039
another and the cost model is going to

493
00:19:35,039 --> 00:19:39,480
allow us to do this so before we go a

494
00:19:39,480 --> 00:19:44,070
little bit deeper into into Cascades I

495
00:19:44,070 --> 00:19:46,350
want to talk about and how we're

496
00:19:46,350 --> 00:19:49,230
actually going to do these

497
00:19:49,230 --> 00:19:52,769
the physical transformations we wanted

498
00:19:52,769 --> 00:19:54,389
somebody have a caveat and say that

499
00:19:54,389 --> 00:19:57,000
everything we've talked about so far has

500
00:19:57,000 --> 00:20:00,510
been sort of the simple case of always

501
00:20:00,510 --> 00:20:03,389
doing Ecuadorians or inner inner inner

502
00:20:03,389 --> 00:20:07,380
inner joins things now though become

503
00:20:07,380 --> 00:20:09,480
more tricky when you start having you

504
00:20:09,480 --> 00:20:11,070
know as you see more realistic queries

505
00:20:11,070 --> 00:20:13,769
outer joins semi joints or Angie joins

506
00:20:13,769 --> 00:20:15,840
because now we're not always going to be

507
00:20:15,840 --> 00:20:18,149
able to makes have symmetrical

508
00:20:18,149 --> 00:20:20,639
transformations to allow us to move any

509
00:20:20,639 --> 00:20:23,399
operation around you know the or reorder

510
00:20:23,399 --> 00:20:26,490
our query plan easily because there may

511
00:20:26,490 --> 00:20:30,389
be some cases where you you you're not

512
00:20:30,389 --> 00:20:31,409
actually allowed to do that because that

513
00:20:31,409 --> 00:20:34,230
would end up with an incorrect query or

514
00:20:34,230 --> 00:20:37,320
an incorrect result so let's say for

515
00:20:37,320 --> 00:20:39,419
example here so say again I'm doing now

516
00:20:39,419 --> 00:20:41,610
I'm doing a three-way join on a B and C

517
00:20:41,610 --> 00:20:43,740
but I'm gonna do a left outer join on a

518
00:20:43,740 --> 00:20:47,000
and B and then do a full outer join on C

519
00:20:47,000 --> 00:20:50,519
so what we're getting into now is how we

520
00:20:50,519 --> 00:20:51,899
actually explore the different join

521
00:20:51,899 --> 00:20:53,909
orderings that are available to us in a

522
00:20:53,909 --> 00:20:56,399
query plan so we can decide whether you

523
00:20:56,399 --> 00:20:58,710
wanna join B and C first or a and C

524
00:20:58,710 --> 00:21:01,590
first and so forth as we saw and with

525
00:21:01,590 --> 00:21:04,580
system R but in this particular example

526
00:21:04,580 --> 00:21:07,289
there's actually no joint orderings that

527
00:21:07,289 --> 00:21:08,519
that are actually available to us are

528
00:21:08,519 --> 00:21:10,380
possible because that would end up with

529
00:21:10,380 --> 00:21:12,210
incorrect state and this is because we

530
00:21:12,210 --> 00:21:13,669
have these outer joins

531
00:21:13,669 --> 00:21:18,210
so in particular the outer join on a and

532
00:21:18,210 --> 00:21:20,610
B the left outer join a and B is not

533
00:21:20,610 --> 00:21:22,830
commutative without the outer join the

534
00:21:22,830 --> 00:21:25,200
four outer join and B and C because I

535
00:21:25,200 --> 00:21:28,169
don't know what the value coming out of

536
00:21:28,169 --> 00:21:30,630
this joint for B will be for V dot Val

537
00:21:30,630 --> 00:21:34,320
in order to join it with C so I have to

538
00:21:34,320 --> 00:21:36,630
execute this first because they don't

539
00:21:36,630 --> 00:21:38,039
know whether it's gonna be a real value

540
00:21:38,039 --> 00:21:41,490
or null right because there's the left

541
00:21:41,490 --> 00:21:44,970
outer join if is a de ID doesn't match

542
00:21:44,970 --> 00:21:47,340
anything with be de ID then the portion

543
00:21:47,340 --> 00:21:49,799
of B in the combined tuple will just be

544
00:21:49,799 --> 00:21:52,679
null and B dot val could be null here

545
00:21:52,679 --> 00:21:55,529
but I don't know that until I actually

546
00:21:55,529 --> 00:21:59,070
do this join so you need a way when we

547
00:21:59,070 --> 00:22:00,629
start doing these join reorderings of

548
00:22:00,629 --> 00:22:01,889
the planet abrasions a look at the

549
00:22:01,889 --> 00:22:02,559
different possible

550
00:22:02,559 --> 00:22:04,749
choices to be mindful that there are

551
00:22:04,749 --> 00:22:06,759
some cases where I can't do the

552
00:22:06,759 --> 00:22:08,980
reordering and I'm is bringing this up

553
00:22:08,980 --> 00:22:10,539
now because I'm going to show examples

554
00:22:10,539 --> 00:22:12,909
where we assume that you everything's

555
00:22:12,909 --> 00:22:14,049
commutative you assume that everything

556
00:22:14,049 --> 00:22:16,509
could be flipped around but just in the

557
00:22:16,509 --> 00:22:19,080
back of your mind be recognized that oh

558
00:22:19,080 --> 00:22:21,519
there is an additional mechanism we need

559
00:22:21,519 --> 00:22:23,620
to make sure that we don't reorder

560
00:22:23,620 --> 00:22:25,600
things incorrectly the dynamic

561
00:22:25,600 --> 00:22:27,580
programming is a little bit easier to do

562
00:22:27,580 --> 00:22:29,129
this because you're having explicit

563
00:22:29,129 --> 00:22:31,539
explicit graphs that you know you can

564
00:22:31,539 --> 00:22:34,509
can can can move things around in the

565
00:22:34,509 --> 00:22:36,610
case of Cascades the best my knowledge

566
00:22:36,610 --> 00:22:38,019
you need to have additional property

567
00:22:38,019 --> 00:22:41,019
enforcers to recognize that this this

568
00:22:41,019 --> 00:22:46,299
reordering is invalid so the way we're

569
00:22:46,299 --> 00:22:48,879
going to enumerate different plans at a

570
00:22:48,879 --> 00:22:50,080
high level of there's two different

571
00:22:50,080 --> 00:22:51,940
approaches this is the transformation

572
00:22:51,940 --> 00:22:54,429
approach where you take an existing plan

573
00:22:54,429 --> 00:22:56,409
and you start permuting it in different

574
00:22:56,409 --> 00:22:58,149
ways to generate new plans that are

575
00:22:58,149 --> 00:22:59,740
equivalent to each other you should have

576
00:22:59,740 --> 00:23:03,309
to check to say make sure that you check

577
00:23:03,309 --> 00:23:04,690
to make sure that the transformation

578
00:23:04,690 --> 00:23:08,019
doing is valid and it's almost sort of

579
00:23:08,019 --> 00:23:09,970
like a random walk except that you have

580
00:23:09,970 --> 00:23:11,950
these rules to apply them and change

581
00:23:11,950 --> 00:23:16,090
things and in sort of a directed way the

582
00:23:16,090 --> 00:23:19,320
another approach is as was used in the

583
00:23:19,320 --> 00:23:22,379
genetic program approach where you are

584
00:23:22,379 --> 00:23:25,929
doing generative enumeration where you

585
00:23:25,929 --> 00:23:28,809
start you take the parts of the query

586
00:23:28,809 --> 00:23:30,220
that you want to execute it as building

587
00:23:30,220 --> 00:23:31,960
blocks and you start graphing them alone

588
00:23:31,960 --> 00:23:33,820
and constructing the query plan and can

589
00:23:33,820 --> 00:23:36,730
be mindful that you don't want to add

590
00:23:36,730 --> 00:23:38,440
things incorrectly to produce an invalid

591
00:23:38,440 --> 00:23:40,119
query plan but you sort of start with

592
00:23:40,119 --> 00:23:42,179
nothing and start adding adding things

593
00:23:42,179 --> 00:23:45,070
so not saying one way is better than

594
00:23:45,070 --> 00:23:46,480
another but these are just sort of at a

595
00:23:46,480 --> 00:23:48,279
high level the two approaches we could

596
00:23:48,279 --> 00:23:54,399
pursue so the state of the art for this

597
00:23:54,399 --> 00:23:55,840
for academically for doing dynamic

598
00:23:55,840 --> 00:23:58,690
programming is the method used in hyper

599
00:23:58,690 --> 00:24:03,840
where you're doing sort of hyper graph

600
00:24:03,860 --> 00:24:09,270
hypergraph generation where you start

601
00:24:09,270 --> 00:24:11,309
with you know it's the general approach

602
00:24:11,309 --> 00:24:12,480
where you start adding building blocks

603
00:24:12,480 --> 00:24:14,190
of the query one by one and you're

604
00:24:14,190 --> 00:24:15,809
checking as you go along whether the

605
00:24:15,809 --> 00:24:17,280
change you want to make by adding a

606
00:24:17,280 --> 00:24:21,179
piece in is valid or not so this is the

607
00:24:21,179 --> 00:24:22,380
approach that's using hyper this is

608
00:24:22,380 --> 00:24:24,150
approach that you used in duck TB I

609
00:24:24,150 --> 00:24:27,500
don't know of any commercial system that

610
00:24:27,500 --> 00:24:30,960
uses this approach the hyper guys might

611
00:24:30,960 --> 00:24:32,400
might know but I don't know the answer

612
00:24:32,400 --> 00:24:38,850
for this we in our system though we were

613
00:24:38,850 --> 00:24:40,800
based on Cascades so I'm going to spend

614
00:24:40,800 --> 00:24:42,809
more time talking about that so as I

615
00:24:42,809 --> 00:24:44,490
said there is an original cascade paper

616
00:24:44,490 --> 00:24:47,940
from 1995 but I didn't have you guys

617
00:24:47,940 --> 00:24:49,500
read it because like I said I don't

618
00:24:49,500 --> 00:24:51,059
think it's very good it's not that it's

619
00:24:51,059 --> 00:24:53,429
not well written in terms of like

620
00:24:53,429 --> 00:24:54,300
English grammar

621
00:24:54,300 --> 00:24:56,850
I just don't think as from from a

622
00:24:56,850 --> 00:24:58,530
pedagogical standpoint for this course

623
00:24:58,530 --> 00:25:00,809
it provides a clear explanation on what

624
00:25:00,809 --> 00:25:02,760
Cascades is actually doing so that's why

625
00:25:02,760 --> 00:25:04,679
I had you guys read the the master's

626
00:25:04,679 --> 00:25:06,000
thesis because I might get my opinion

627
00:25:06,000 --> 00:25:08,120
that's the best explanation of Cascades

628
00:25:08,120 --> 00:25:11,370
so what is Cascades well last class we

629
00:25:11,370 --> 00:25:12,929
talked about volcano and that was a

630
00:25:12,929 --> 00:25:15,809
top-down approach for doing a branch of

631
00:25:15,809 --> 00:25:18,860
mountain search of adding adding

632
00:25:18,860 --> 00:25:21,960
constructing a query plan Cascades is

633
00:25:21,960 --> 00:25:25,410
the sort of third generation optimizer

634
00:25:25,410 --> 00:25:28,050
that grits gravity had built and there's

635
00:25:28,050 --> 00:25:30,360
a sort of again this this this

636
00:25:30,360 --> 00:25:31,860
state-of-the-art approach that we sent

637
00:25:31,860 --> 00:25:34,410
from what I'm aware of and so the big

638
00:25:34,410 --> 00:25:35,490
difference we're gonna do here in

639
00:25:35,490 --> 00:25:38,340
Cascades that we didn't do in volcano is

640
00:25:38,340 --> 00:25:42,929
that we're gonna the the optimizer is

641
00:25:42,929 --> 00:25:45,179
going to generate the transformations on

642
00:25:45,179 --> 00:25:48,240
the fly as it needs them rather than

643
00:25:48,240 --> 00:25:49,710
pre-computing all possible

644
00:25:49,710 --> 00:25:51,990
transformations at every level we go

645
00:25:51,990 --> 00:25:54,990
into as we're searching into the query

646
00:25:54,990 --> 00:25:57,030
plan right so in the case of volcano

647
00:25:57,030 --> 00:25:59,250
what happened is when I went from one

648
00:25:59,250 --> 00:26:01,230
group to the next one down one level in

649
00:26:01,230 --> 00:26:04,500
the tree before I did any evaluation of

650
00:26:04,500 --> 00:26:05,700
the possible transformations I could

651
00:26:05,700 --> 00:26:07,860
have each transformation I could apply I

652
00:26:07,860 --> 00:26:09,920
generated all possible transformations

653
00:26:09,920 --> 00:26:14,029
which will explode the search base right

654
00:26:14,029 --> 00:26:15,979
and maybe the case that maybe got stuck

655
00:26:15,979 --> 00:26:17,719
in a local minimum and didn't explore

656
00:26:17,719 --> 00:26:19,700
the the the rest of the tree more

657
00:26:19,700 --> 00:26:23,749
carefully right so the other cool thing

658
00:26:23,749 --> 00:26:24,999
that we're gonna be able to do in

659
00:26:24,999 --> 00:26:27,830
cascades is that we're gonna be able to

660
00:26:27,830 --> 00:26:35,149
do a simple rewriting of a multi

661
00:26:35,149 --> 00:26:36,590
questions or expressions within the

662
00:26:36,590 --> 00:26:39,469
query plan but is having these function

663
00:26:39,469 --> 00:26:41,179
and be able to apply them without having

664
00:26:41,179 --> 00:26:44,479
to do an exhaustive search for all

665
00:26:44,479 --> 00:26:47,059
possible combinations of how to execute

666
00:26:47,059 --> 00:26:48,950
that multi expression that make more

667
00:26:48,950 --> 00:26:50,539
sense and if you want a few more slides

668
00:26:50,539 --> 00:26:52,549
the basic idea here is like I could have

669
00:26:52,549 --> 00:26:55,190
a placeholder to say here's some lower

670
00:26:55,190 --> 00:26:57,679
portion of the tree I don't know how I'm

671
00:26:57,679 --> 00:26:59,479
gonna actually implement it just yet but

672
00:26:59,479 --> 00:27:00,979
I don't need to search it just now I can

673
00:27:00,979 --> 00:27:03,859
search other aspects of the tree and use

674
00:27:03,859 --> 00:27:08,629
that place order okay all right

675
00:27:08,629 --> 00:27:12,799
so for Cascades the sort of the four

676
00:27:12,799 --> 00:27:16,609
main design ideas that person uses that

677
00:27:16,609 --> 00:27:19,879
first is that all the all the

678
00:27:19,879 --> 00:27:21,769
optimizations are going to be the simple

679
00:27:21,769 --> 00:27:24,710
pair data structures when you contain

680
00:27:24,710 --> 00:27:26,210
the pattern that you want to match in

681
00:27:26,210 --> 00:27:29,210
your query plan and then if it matches

682
00:27:29,210 --> 00:27:32,269
there's a rule to fire to do some kind

683
00:27:32,269 --> 00:27:34,639
of transformation and they contrast this

684
00:27:34,639 --> 00:27:36,729
with like the heuristic based approach

685
00:27:36,729 --> 00:27:39,349
using Postgres use in other systems we

686
00:27:39,349 --> 00:27:40,700
have a bunch of if-then-else statements

687
00:27:40,700 --> 00:27:43,639
it's always these rules and you know

688
00:27:43,639 --> 00:27:45,169
there's a rule and then then there's the

689
00:27:45,169 --> 00:27:47,359
then there's the okay there's the

690
00:27:47,359 --> 00:27:48,499
pattern and then there's a rule that

691
00:27:48,499 --> 00:27:50,539
does the transformation and I can do

692
00:27:50,539 --> 00:27:52,639
this from a logical the logical logical

693
00:27:52,639 --> 00:27:55,479
and logical physical it's all the same

694
00:27:55,479 --> 00:27:57,889
the next thing is that gonna have rules

695
00:27:57,889 --> 00:28:01,519
to to enforce the property requirements

696
00:28:01,519 --> 00:28:04,159
you would have on data or if they're the

697
00:28:04,159 --> 00:28:05,929
enemy results produced but give an

698
00:28:05,929 --> 00:28:07,609
operator and these are the things like

699
00:28:07,609 --> 00:28:12,619
the the sorting order care about

700
00:28:12,619 --> 00:28:13,909
compression and other things like that

701
00:28:13,909 --> 00:28:15,889
like we can afford those things and then

702
00:28:15,889 --> 00:28:17,839
the rule engine knows that it can apply

703
00:28:17,839 --> 00:28:21,109
the transformation if the transformation

704
00:28:21,109 --> 00:28:22,759
would end up violating the rule that it

705
00:28:22,759 --> 00:28:25,549
has to be has to be has to maintain and

706
00:28:25,549 --> 00:28:26,989
contrast this with the system our

707
00:28:26,989 --> 00:28:27,810
approach where I said

708
00:28:27,810 --> 00:28:31,140
that the rules to do the enumeration or

709
00:28:31,140 --> 00:28:32,820
the search of the joint ordering it had

710
00:28:32,820 --> 00:28:36,030
no notion of these physical properties

711
00:28:36,030 --> 00:28:38,220
of the data it all had to be baked into

712
00:28:38,220 --> 00:28:40,050
the cost model but now again in one

713
00:28:40,050 --> 00:28:42,420
place I can define my rule that says my

714
00:28:42,420 --> 00:28:43,980
data has to be sorted this way and make

715
00:28:43,980 --> 00:28:45,480
sure that you don't do a transformation

716
00:28:45,480 --> 00:28:48,960
that violates that the next thing is

717
00:28:48,960 --> 00:28:52,760
that we can then now also define the

718
00:28:52,760 --> 00:28:55,380
priority or the ordering of the rules

719
00:28:55,380 --> 00:28:58,320
that we get applied based on these

720
00:28:58,320 --> 00:29:00,900
promises so the way to think about this

721
00:29:00,900 --> 00:29:04,590
is that rather than just randomly

722
00:29:04,590 --> 00:29:06,180
picking what transfer transformation we

723
00:29:06,180 --> 00:29:08,280
want to apply at a given level in our

724
00:29:08,280 --> 00:29:11,310
tree we can specify an or and we'd even

725
00:29:11,310 --> 00:29:13,830
get actually the dynamically so that we

726
00:29:13,830 --> 00:29:16,770
can identify aspects of our query plan

727
00:29:16,770 --> 00:29:18,960
and say we think these transformations

728
00:29:18,960 --> 00:29:20,160
will lead us to the optimum plan more

729
00:29:20,160 --> 00:29:22,140
quickly so apply these transformations

730
00:29:22,140 --> 00:29:24,540
first and only evaluate the other ones

731
00:29:24,540 --> 00:29:26,580
if we have more time and want to

732
00:29:26,580 --> 00:29:28,230
continue searching at that level in the

733
00:29:28,230 --> 00:29:31,380
tree and the last one that's important

734
00:29:31,380 --> 00:29:32,730
is that they're going to treat the

735
00:29:32,730 --> 00:29:36,120
predicates as first-class entities in

736
00:29:36,120 --> 00:29:38,130
the system that's going to allow us to

737
00:29:38,130 --> 00:29:40,560
do transformations on them just as we

738
00:29:40,560 --> 00:29:43,320
would do for operators and this is how

739
00:29:43,320 --> 00:29:44,670
we're gonna do all the things that I

740
00:29:44,670 --> 00:29:45,960
showed in beginning like the predicate

741
00:29:45,960 --> 00:29:50,070
push down projection push down and

742
00:29:50,070 --> 00:29:52,560
things like that because a predicate

743
00:29:52,560 --> 00:29:54,960
push an example because those again even

744
00:29:54,960 --> 00:29:56,640
though they're like predicates inside

745
00:29:56,640 --> 00:29:58,590
the where clause that would normally be

746
00:29:58,590 --> 00:30:00,690
baked inside of like a select statement

747
00:30:00,690 --> 00:30:03,510
or sorry scan operator we can have our

748
00:30:03,510 --> 00:30:05,970
the engine do transformations on them

749
00:30:05,970 --> 00:30:08,220
and do other optimizations just as it

750
00:30:08,220 --> 00:30:10,170
would with the physical in logical

751
00:30:10,170 --> 00:30:11,910
operators and this is actually something

752
00:30:11,910 --> 00:30:13,380
we're trying to build now in our own

753
00:30:13,380 --> 00:30:16,440
system we had a project in 7:21 last

754
00:30:16,440 --> 00:30:18,960
year where they built a expression

755
00:30:18,960 --> 00:30:21,990
rewriter using our cascades engine and

756
00:30:21,990 --> 00:30:24,030
the student that's worked on that last

757
00:30:24,030 --> 00:30:25,140
year is now working on it this year

758
00:30:25,140 --> 00:30:27,780
again to help finish porting it into the

759
00:30:27,780 --> 00:30:29,880
new system so we won't talk about this

760
00:30:29,880 --> 00:30:31,200
today but this is allowed to do certain

761
00:30:31,200 --> 00:30:33,660
things like if I have a where clause

762
00:30:33,660 --> 00:30:36,750
that says where 1 equals 1 we can

763
00:30:36,750 --> 00:30:38,210
rewrite that into

764
00:30:38,210 --> 00:30:41,960
just to be true and instead of having to

765
00:30:41,960 --> 00:30:45,169
evaluate the query tree and it's a tidy

766
00:30:45,169 --> 00:30:47,299
for every single tuple now we compile

767
00:30:47,299 --> 00:30:49,369
with LLVM so the Alabama compiler can

768
00:30:49,369 --> 00:30:52,220
easily wipe that away by doing constant

769
00:30:52,220 --> 00:30:54,559
folding but the these are the kind of

770
00:30:54,559 --> 00:30:56,720
things we can do now though inside the

771
00:30:56,720 --> 00:30:58,399
same cascades framework that we normally

772
00:30:58,399 --> 00:31:03,409
would use for optimizing query trees all

773
00:31:03,409 --> 00:31:05,389
right so the first thing we got to talk

774
00:31:05,389 --> 00:31:08,029
about to understand Cascades is what an

775
00:31:08,029 --> 00:31:10,369
expression is so this parts a bit

776
00:31:10,369 --> 00:31:12,980
confusing because normally I've been

777
00:31:12,980 --> 00:31:14,929
talking about expressions in terms of

778
00:31:14,929 --> 00:31:17,539
the the predicates that are in where

779
00:31:17,539 --> 00:31:20,360
clauses or join clauses or select

780
00:31:20,360 --> 00:31:23,059
outputs and certainly in the in the code

781
00:31:23,059 --> 00:31:25,009
of our system we use expressions to mean

782
00:31:25,009 --> 00:31:27,320
there's no expression treated like one

783
00:31:27,320 --> 00:31:29,960
equals one and things like that but in

784
00:31:29,960 --> 00:31:32,240
cascade they're gonna declare an

785
00:31:32,240 --> 00:31:36,950
expression to be a high-level opera

786
00:31:36,950 --> 00:31:39,110
operation or operator in our system or

787
00:31:39,110 --> 00:31:42,679
in the query plan that's gonna have zero

788
00:31:42,679 --> 00:31:46,249
or more or input expressions to it so

789
00:31:46,249 --> 00:31:48,139
say I have my query here a select star

790
00:31:48,139 --> 00:31:52,519
from a join a B and C together like I

791
00:31:52,519 --> 00:31:55,009
have a logical expression that would be

792
00:31:55,009 --> 00:31:57,769
the join on a and B followed by the join

793
00:31:57,769 --> 00:32:00,139
on C and then I could have a physical

794
00:32:00,139 --> 00:32:02,480
expression that would be the scruncher

795
00:32:02,480 --> 00:32:04,850
scan on a during a hash join on the

796
00:32:04,850 --> 00:32:07,070
sequential scan on b and then doing an s

797
00:32:07,070 --> 00:32:11,679
a loop join on a index scan on on c so

798
00:32:11,679 --> 00:32:15,940
it's an expression would be some some

799
00:32:15,940 --> 00:32:18,549
essentially the relational algebra

800
00:32:18,549 --> 00:32:21,679
components for the query but if i

801
00:32:21,679 --> 00:32:23,059
annotate them with these of these

802
00:32:23,059 --> 00:32:24,619
subscripts i'm specifying what the

803
00:32:24,619 --> 00:32:26,600
physical operator i want to use to

804
00:32:26,600 --> 00:32:29,240
perform that before that relational

805
00:32:29,240 --> 00:32:33,559
operator okay right so in this example

806
00:32:33,559 --> 00:32:37,070
here these two expressions are logically

807
00:32:37,070 --> 00:32:39,529
equivalent okay so even though this is a

808
00:32:39,529 --> 00:32:41,210
specifying that the physical operator is

809
00:32:41,210 --> 00:32:42,350
and this is just a logical operators

810
00:32:42,350 --> 00:32:44,029
logically they're equivalent

811
00:32:44,029 --> 00:32:46,429
they're both computing the join on a b

812
00:32:46,429 --> 00:32:48,740
and c and so now we're going to be able

813
00:32:48,740 --> 00:32:51,450
to rely on this community property

814
00:32:51,450 --> 00:32:52,950
to enumerate all the different jointer

815
00:32:52,950 --> 00:32:55,049
rings as part of transformations to do

816
00:32:55,049 --> 00:32:58,559
exploration of the the search base with

817
00:32:58,559 --> 00:33:00,840
this query plan and try to find a you

818
00:33:00,840 --> 00:33:03,000
know find the optimal one and this is

819
00:33:03,000 --> 00:33:04,380
what I was saying before when we talked

820
00:33:04,380 --> 00:33:06,389
about left out of dueling 400 or an

821
00:33:06,389 --> 00:33:08,760
example so in these case I can move

822
00:33:08,760 --> 00:33:11,010
these movies operators down anyway one

823
00:33:11,010 --> 00:33:13,470
because they're commutative but if I one

824
00:33:13,470 --> 00:33:15,389
of these was doing a left outer join or

825
00:33:15,389 --> 00:33:17,549
for doing then I would have to restrict

826
00:33:17,549 --> 00:33:19,350
the transformation to make sure that I

827
00:33:19,350 --> 00:33:22,350
do things in the correct order but for

828
00:33:22,350 --> 00:33:24,149
simplicity in our example here we won't

829
00:33:24,149 --> 00:33:28,769
worry about that all right so now now we

830
00:33:28,769 --> 00:33:30,330
have we have expressions and that's

831
00:33:30,330 --> 00:33:32,820
gonna be some sequence or some

832
00:33:32,820 --> 00:33:35,970
relational algebra expression now we're

833
00:33:35,970 --> 00:33:38,700
going to define groups so group is gonna

834
00:33:38,700 --> 00:33:41,399
be the set of logically equivalent

835
00:33:41,399 --> 00:33:44,789
logical and physical expressions for one

836
00:33:44,789 --> 00:33:47,429
expression that that will produce in the

837
00:33:47,429 --> 00:33:52,110
same output expression right so all

838
00:33:52,110 --> 00:33:54,210
logical forms it's especially for a

839
00:33:54,210 --> 00:33:55,710
given expression will have all logical

840
00:33:55,710 --> 00:33:57,720
forms and it will have all physical

841
00:33:57,720 --> 00:34:00,110
expressions that we can derive by

842
00:34:00,110 --> 00:34:03,090
converting any logical operator into the

843
00:34:03,090 --> 00:34:05,820
allowable physical operators from the

844
00:34:05,820 --> 00:34:09,359
corresponding logical forms so what I

845
00:34:09,359 --> 00:34:11,429
mean with this so this entire unit here

846
00:34:11,429 --> 00:34:14,339
is a group and this group represents the

847
00:34:14,339 --> 00:34:18,739
output expression of a join be join seat

848
00:34:18,739 --> 00:34:21,929
and then now we have the logical and

849
00:34:21,929 --> 00:34:23,460
physical expressions that are all gonna

850
00:34:23,460 --> 00:34:26,310
be equivalent to this output expression

851
00:34:26,310 --> 00:34:30,418
here alright so the contents of the

852
00:34:30,418 --> 00:34:33,030
group are going to find based on on its

853
00:34:33,030 --> 00:34:36,239
output and so I can't have a another

854
00:34:36,239 --> 00:34:39,389
group with the same output right it has

855
00:34:39,389 --> 00:34:41,940
me unique to to do Mike my query plan

856
00:34:41,940 --> 00:34:44,310
right so I was important to note that

857
00:34:44,310 --> 00:34:47,389
these expressions in here are unordered

858
00:34:47,389 --> 00:34:50,780
meaning the

859
00:34:51,649 --> 00:34:53,460
illustration of what's being contained

860
00:34:53,460 --> 00:34:54,149
inside them

861
00:34:54,149 --> 00:34:56,429
but just because this one's first

862
00:34:56,429 --> 00:34:58,500
doesn't mean anything about whether we

863
00:34:58,500 --> 00:35:00,089
should examine this one first that's

864
00:35:00,089 --> 00:35:02,640
implied or that sort of computed as part

865
00:35:02,640 --> 00:35:04,470
of the priorities you would get

866
00:35:04,470 --> 00:35:07,530
your transformation the other important

867
00:35:07,530 --> 00:35:08,730
thing they also point to is as I was

868
00:35:08,730 --> 00:35:12,390
saying in the case of volcano for this

869
00:35:12,390 --> 00:35:14,520
output expression they have to generate

870
00:35:14,520 --> 00:35:16,920
all possible all possible permutations

871
00:35:16,920 --> 00:35:18,660
of a lot of expressions and feature

872
00:35:18,660 --> 00:35:20,820
those all possible permutations the

873
00:35:20,820 --> 00:35:23,490
filter expressions in Cascades these are

874
00:35:23,490 --> 00:35:25,680
sort of like you know these are sort of

875
00:35:25,680 --> 00:35:28,050
computed on demand or just in time so

876
00:35:28,050 --> 00:35:31,020
that I don't have to materialize every

877
00:35:31,020 --> 00:35:32,580
possible logical expression in feature

878
00:35:32,580 --> 00:35:34,230
those every possible physical expression

879
00:35:34,230 --> 00:35:36,960
I can say I can apply my transformation

880
00:35:36,960 --> 00:35:39,869
rule and it'll generate some equipment

881
00:35:39,869 --> 00:35:41,760
logical expressions and I can determine

882
00:35:41,760 --> 00:35:43,320
whether I even explode them further and

883
00:35:43,320 --> 00:35:44,640
look at their physical expressions

884
00:35:44,640 --> 00:35:49,590
alright so this you know this is so this

885
00:35:49,590 --> 00:35:52,230
what I'm saying the in the case of

886
00:35:52,230 --> 00:35:54,810
volcano since they were doing it all at

887
00:35:54,810 --> 00:35:57,510
once the amount of state you had a

888
00:35:57,510 --> 00:35:59,250
represent here it got really large and

889
00:35:59,250 --> 00:36:02,550
so the on demand thing is is is the way

890
00:36:02,550 --> 00:36:04,619
we're gonna sort of speed this way to

891
00:36:04,619 --> 00:36:06,480
reduce that state but another

892
00:36:06,480 --> 00:36:09,270
optimization we can do in Cascades is to

893
00:36:09,270 --> 00:36:10,710
use what are called multi expressions

894
00:36:10,710 --> 00:36:13,230
and the idea here is that instead of

895
00:36:13,230 --> 00:36:16,410
instead of instantiating exactly the

896
00:36:16,410 --> 00:36:19,770
verbose form of all possible expressions

897
00:36:19,770 --> 00:36:22,290
for a given group we can instead

898
00:36:22,290 --> 00:36:26,550
represent the sum sub expression with an

899
00:36:26,550 --> 00:36:30,000
expression as a placeholder that is then

900
00:36:30,000 --> 00:36:32,490
represented by or taken care of by some

901
00:36:32,490 --> 00:36:36,000
group lower in the query plan and so the

902
00:36:36,000 --> 00:36:40,140
they the set of redundant expressions

903
00:36:40,140 --> 00:36:43,050
represented by these placeholders in a

904
00:36:43,050 --> 00:36:44,640
group together is called as a called a

905
00:36:44,640 --> 00:36:48,000
multi expression right so in this case

906
00:36:48,000 --> 00:36:51,359
here before I was saying a join B join C

907
00:36:51,359 --> 00:36:53,430
and have it's explicitly saying hey I'm

908
00:36:53,430 --> 00:36:56,910
joining a a and B but now in the multi

909
00:36:56,910 --> 00:36:58,830
expression I just have a placeholder

910
00:36:58,830 --> 00:37:01,800
here that says hey it was a and B

911
00:37:01,800 --> 00:37:03,990
they're being combined together I don't

912
00:37:03,990 --> 00:37:05,880
know how somebody else below me the

913
00:37:05,880 --> 00:37:07,230
query plan will tell you how to do this

914
00:37:07,230 --> 00:37:08,580
but I know that I just have a

915
00:37:08,580 --> 00:37:10,440
placeholder here and the same thing for

916
00:37:10,440 --> 00:37:14,400
in this case here I have a scan on C I'm

917
00:37:14,400 --> 00:37:17,010
not saying how to actually scan it

918
00:37:17,010 --> 00:37:17,720
whereas

919
00:37:17,720 --> 00:37:19,190
here I was explicitly saying you know

920
00:37:19,190 --> 00:37:21,020
here that one news twins can I don't say

921
00:37:21,020 --> 00:37:23,210
anything for that right so makes more

922
00:37:23,210 --> 00:37:24,349
sense when you look at the physical ones

923
00:37:24,349 --> 00:37:25,310
or the physical ones a mutton

924
00:37:25,310 --> 00:37:27,410
I'm not specifying how I'm doing joining

925
00:37:27,410 --> 00:37:29,540
a and B or how I'm actually accessing C

926
00:37:29,540 --> 00:37:31,640
but I am specifying that I have a

927
00:37:31,640 --> 00:37:33,140
physical join operator that's doing a

928
00:37:33,140 --> 00:37:37,099
cert mode here right and so the idea

929
00:37:37,099 --> 00:37:39,020
here the reason why we're doing this is

930
00:37:39,020 --> 00:37:42,380
that in a top-down search strategy like

931
00:37:42,380 --> 00:37:45,109
in Cascades we can then make the sames

932
00:37:45,109 --> 00:37:47,030
about whether you want to traverse lower

933
00:37:47,030 --> 00:37:49,940
down into the tree to understand how we

934
00:37:49,940 --> 00:37:51,050
actually want to join these things

935
00:37:51,050 --> 00:37:53,180
together right without explicitly blunt

936
00:37:53,180 --> 00:37:57,530
blowing it all out in the the bottom-up

937
00:37:57,530 --> 00:37:59,660
optimizer they're going to enumerate all

938
00:37:59,660 --> 00:38:02,060
the most expressions sort of from one

939
00:38:02,060 --> 00:38:03,380
group at a time and the order of the

940
00:38:03,380 --> 00:38:04,609
tables that they're generated so they'll

941
00:38:04,609 --> 00:38:07,760
start with a figure out how to maybe

942
00:38:07,760 --> 00:38:10,099
access that and then figure out access

943
00:38:10,099 --> 00:38:12,140
beam to figure out X se and then figure

944
00:38:12,140 --> 00:38:13,790
out how to combine ami and together and

945
00:38:13,790 --> 00:38:14,270
go for it

946
00:38:14,270 --> 00:38:15,740
so it's sort of a different way of

947
00:38:15,740 --> 00:38:25,010
looking at it so the before we can make

948
00:38:25,010 --> 00:38:26,839
decisions now we'll see in the next

949
00:38:26,839 --> 00:38:29,060
slide or the next few slides before we

950
00:38:29,060 --> 00:38:31,280
make decisions about how you know how

951
00:38:31,280 --> 00:38:34,010
we're actually gonna do you know for

952
00:38:34,010 --> 00:38:35,869
this physical operator here we have to

953
00:38:35,869 --> 00:38:38,930
make sure that for all placeholder

954
00:38:38,930 --> 00:38:40,369
expressions we have below us in the tree

955
00:38:40,369 --> 00:38:42,200
that we we figured out how we're

956
00:38:42,200 --> 00:38:44,690
actually going to access them what's the

957
00:38:44,690 --> 00:38:47,300
best physical cost or best plan with the

958
00:38:47,300 --> 00:38:48,830
lowest cost for the physical operator

959
00:38:48,830 --> 00:38:50,660
blue that in the tree and then we can

960
00:38:50,660 --> 00:38:51,950
combine that together when we make a

961
00:38:51,950 --> 00:38:54,260
decision about which operator we want to

962
00:38:54,260 --> 00:38:56,210
do this for here again when we go

963
00:38:56,210 --> 00:38:57,500
through the example this make more sense

964
00:38:57,500 --> 00:39:00,890
so the last thing we need to understand

965
00:39:00,890 --> 00:39:04,460
in Cascades is the rule system so again

966
00:39:04,460 --> 00:39:06,650
a rule is gonna be some transformation

967
00:39:06,650 --> 00:39:08,839
and we can apply to an expression that

968
00:39:08,839 --> 00:39:11,690
will convert it into a logically

969
00:39:11,690 --> 00:39:13,310
equivalent expression meaning it will

970
00:39:13,310 --> 00:39:15,170
produce the same logical results and

971
00:39:15,170 --> 00:39:17,510
when we actually execute it but so we'll

972
00:39:17,510 --> 00:39:19,520
have two types of rules we'll have a

973
00:39:19,520 --> 00:39:21,500
transformation rule which is a logical

974
00:39:21,500 --> 00:39:23,180
logical logical operator to physical

975
00:39:23,180 --> 00:39:26,990
operator or a logical plan to a plant or

976
00:39:26,990 --> 00:39:29,030
plant subset into another logical plan

977
00:39:29,030 --> 00:39:30,060
subset

978
00:39:30,060 --> 00:39:31,680
and they'll have an implementation rule

979
00:39:31,680 --> 00:39:33,810
that will convert a logical operator or

980
00:39:33,810 --> 00:39:36,450
a set of logical operators to physical

981
00:39:36,450 --> 00:39:39,270
operators and as I said every rule is

982
00:39:39,270 --> 00:39:42,090
defined by the pattern will match to

983
00:39:42,090 --> 00:39:44,760
identify which sub plan or find a a

984
00:39:44,760 --> 00:39:47,160
portion of the plan that has a Civic

985
00:39:47,160 --> 00:39:49,590
layout a configuration that matches to

986
00:39:49,590 --> 00:39:51,810
our rule and then if we find one of

987
00:39:51,810 --> 00:39:53,700
those then we apply the substitution

988
00:39:53,700 --> 00:39:55,890
policy or the transformation that we

989
00:39:55,890 --> 00:39:58,620
want to convert the the query plan

990
00:39:58,620 --> 00:40:01,170
structure into the logically logically

991
00:40:01,170 --> 00:40:04,100
equivalent change or logical equivalent

992
00:40:04,100 --> 00:40:08,570
new plan so let's look an example here

993
00:40:08,570 --> 00:40:11,220
to say this is our pattern and our

994
00:40:11,220 --> 00:40:13,110
pattern is we want to match a sub plan

995
00:40:13,110 --> 00:40:15,900
that has a equi-join

996
00:40:15,900 --> 00:40:18,630
followed by another equi-join and then

997
00:40:18,630 --> 00:40:20,250
we have these placeholder groups where

998
00:40:20,250 --> 00:40:21,810
we're just saying we don't actually care

999
00:40:21,810 --> 00:40:24,450
or no we don't need to know and we don't

1000
00:40:24,450 --> 00:40:27,090
care what these other groups are

1001
00:40:27,090 --> 00:40:29,000
actually doing we just care about having

1002
00:40:29,000 --> 00:40:31,500
sort of lefty tree where you have a go

1003
00:40:31,500 --> 00:40:34,650
join fall behind an equijoin so now say

1004
00:40:34,650 --> 00:40:36,210
this is a query that will match this so

1005
00:40:36,210 --> 00:40:39,270
again I have now a group here that's

1006
00:40:39,270 --> 00:40:41,550
combining a and B and joining us C then

1007
00:40:41,550 --> 00:40:43,170
I have another here another group here

1008
00:40:43,170 --> 00:40:46,890
that's doing joined between a and B so

1009
00:40:46,890 --> 00:40:48,390
these are both equi-join assuming that

1010
00:40:48,390 --> 00:40:49,770
you know you're doing a natural join and

1011
00:40:49,770 --> 00:40:51,840
then below that below each join operator

1012
00:40:51,840 --> 00:40:53,970
I have these get expressions but this is

1013
00:40:53,970 --> 00:40:55,170
somehow saying right here's how I'm

1014
00:40:55,170 --> 00:40:58,080
going to access the tables a B and C but

1015
00:40:58,080 --> 00:41:00,510
we don't care what that actually is in

1016
00:41:00,510 --> 00:41:01,920
our rule because we only care about

1017
00:41:01,920 --> 00:41:03,480
having these two matching joins like

1018
00:41:03,480 --> 00:41:06,900
that so the first type of join we do is

1019
00:41:06,900 --> 00:41:10,110
a transformation rule the first change

1020
00:41:10,110 --> 00:41:11,790
we do is the transformation rule where

1021
00:41:11,790 --> 00:41:15,270
we want to rotate the the joins to go

1022
00:41:15,270 --> 00:41:18,660
left to right so in this case here we're

1023
00:41:18,660 --> 00:41:22,350
going to switch the the the the join

1024
00:41:22,350 --> 00:41:24,690
below the joint at the top to now be on

1025
00:41:24,690 --> 00:41:25,860
the right side of the tree

1026
00:41:25,860 --> 00:41:28,290
whereas originally started off in the on

1027
00:41:28,290 --> 00:41:32,520
the left side a implementation rule

1028
00:41:32,520 --> 00:41:36,230
would actually now be converting the

1029
00:41:36,230 --> 00:41:38,550
logical operators for these joins into

1030
00:41:38,550 --> 00:41:41,520
now a physical operator specifies what

1031
00:41:41,520 --> 00:41:42,589
algorithm how

1032
00:41:42,589 --> 00:41:45,140
or I want to use so in this case here we

1033
00:41:45,140 --> 00:41:47,359
can convert these to be the joys of

1034
00:41:47,359 --> 00:41:49,989
useless or merge-join

1035
00:41:49,989 --> 00:41:53,569
so one thing with the mindful of in our

1036
00:41:53,569 --> 00:41:56,479
system is that or in cascades is that

1037
00:41:56,479 --> 00:41:58,249
we're gonna make sure that we don't get

1038
00:41:58,249 --> 00:42:00,859
stuck in infinite loops so in the same

1039
00:42:00,859 --> 00:42:02,569
way here that I have a transformation

1040
00:42:02,569 --> 00:42:04,789
rule that allows me to go that rotate

1041
00:42:04,789 --> 00:42:07,069
the joins from left to right on another

1042
00:42:07,069 --> 00:42:09,229
transformation rule that will convert it

1043
00:42:09,229 --> 00:42:12,529
from right to left so unless I'm careful

1044
00:42:12,529 --> 00:42:13,969
I could just keep getting stuck in if

1045
00:42:13,969 --> 00:42:15,289
the loop going left to right right left

1046
00:42:15,289 --> 00:42:18,680
and back fourth over never again so we

1047
00:42:18,680 --> 00:42:20,509
need a way to recognize that we've

1048
00:42:20,509 --> 00:42:23,029
already applied a transformation and

1049
00:42:23,029 --> 00:42:24,589
therefore we don't need to do it again

1050
00:42:24,589 --> 00:42:26,809
and possibly search what the query plan

1051
00:42:26,809 --> 00:42:31,549
looks like every we apply it so this is

1052
00:42:31,549 --> 00:42:32,779
what the memo table with a memorization

1053
00:42:32,779 --> 00:42:35,089
table in Cascades is going to do for us

1054
00:42:35,089 --> 00:42:37,339
so in the original Cascades paper I

1055
00:42:37,339 --> 00:42:38,989
think they use they talked about using a

1056
00:42:38,989 --> 00:42:41,839
graph data structure in our application

1057
00:42:41,839 --> 00:42:43,729
we use a hash table as far as they know

1058
00:42:43,729 --> 00:42:46,640
in the other open source Cascades

1059
00:42:46,640 --> 00:42:48,259
invitations they're also using a hash

1060
00:42:48,259 --> 00:42:51,140
table so what if acknowledged to do is

1061
00:42:51,140 --> 00:42:55,219
we can identify that we've you can

1062
00:42:55,219 --> 00:42:56,809
identify that we can have a group that

1063
00:42:56,809 --> 00:42:58,940
we visited before and therefore we don't

1064
00:42:58,940 --> 00:43:00,469
need to examine it again because we

1065
00:43:00,469 --> 00:43:03,049
already know what the query plan looks

1066
00:43:03,049 --> 00:43:04,249
like after we apply of that

1067
00:43:04,249 --> 00:43:06,140
transformation so that's good so if we

1068
00:43:06,140 --> 00:43:08,509
do that left to right if we try to try

1069
00:43:08,509 --> 00:43:09,769
to apply the transformation rule to go

1070
00:43:09,769 --> 00:43:12,200
back right the left we would say well we

1071
00:43:12,200 --> 00:43:13,729
already know what that looks like we've

1072
00:43:13,729 --> 00:43:15,319
already been there and we see that cost

1073
00:43:15,319 --> 00:43:18,289
in our in our in our memo table

1074
00:43:18,289 --> 00:43:21,739
therefore we don't need to apply it so

1075
00:43:21,739 --> 00:43:23,509
well how we're gonna do this is that

1076
00:43:23,509 --> 00:43:24,920
we're going to have equivalent operator

1077
00:43:24,920 --> 00:43:26,420
trees and their corresponding groups

1078
00:43:26,420 --> 00:43:28,999
store together or together into groups

1079
00:43:28,999 --> 00:43:31,219
and we store them in in the memo table

1080
00:43:31,219 --> 00:43:34,190
and we need a way to quickly hash and in

1081
00:43:34,190 --> 00:43:35,779
a fighh that we have we have duplicates

1082
00:43:35,779 --> 00:43:39,529
all right so what this memo tables can

1083
00:43:39,529 --> 00:43:42,289
do for us is it's going to in addition

1084
00:43:42,289 --> 00:43:46,359
to be able to avoid duplications and

1085
00:43:46,359 --> 00:43:49,460
duplicate query plan transformations we

1086
00:43:49,460 --> 00:43:51,619
can also use that to be identify quickly

1087
00:43:51,619 --> 00:43:54,710
that we've gone down now it's some part

1088
00:43:54,710 --> 00:43:55,950
of the query plan

1089
00:43:55,950 --> 00:43:57,210
and we don't need you traverse it any

1090
00:43:57,210 --> 00:44:01,200
further so this is tied to now this idea

1091
00:44:01,200 --> 00:44:03,840
of the principle of optimality that

1092
00:44:03,840 --> 00:44:07,110
cascades this could be based on and this

1093
00:44:07,110 --> 00:44:08,670
is from control theory this is for this

1094
00:44:08,670 --> 00:44:09,870
the Bellman's principle of optimality

1095
00:44:09,870 --> 00:44:13,350
and this is not specific to kept the

1096
00:44:13,350 --> 00:44:15,030
Cascades top-down search but this is

1097
00:44:15,030 --> 00:44:17,190
this is how we're gonna be able to you

1098
00:44:17,190 --> 00:44:19,560
converge on finally finding an optimal

1099
00:44:19,560 --> 00:44:22,140
query plan so all it really says is that

1100
00:44:22,140 --> 00:44:26,130
if I if I have an optimal query plan and

1101
00:44:26,130 --> 00:44:28,620
surprise of two groups then I know there

1102
00:44:28,620 --> 00:44:31,260
can't be another optimal physical plan

1103
00:44:31,260 --> 00:44:35,130
that for one of those groups because if

1104
00:44:35,130 --> 00:44:38,640
there was then I wouldn't be the optimal

1105
00:44:38,640 --> 00:44:40,530
plan it's almost like a tautology look

1106
00:44:40,530 --> 00:44:44,430
if I know that I know that this is the

1107
00:44:44,430 --> 00:44:47,070
best plan I've ever seen and I have a

1108
00:44:47,070 --> 00:44:48,450
best plan I've ever seen and I'm at some

1109
00:44:48,450 --> 00:44:51,390
point in the my search tree and now I

1110
00:44:51,390 --> 00:44:54,270
have a cost that's greater than the best

1111
00:44:54,270 --> 00:44:56,520
one I've ever seen but that if I

1112
00:44:56,520 --> 00:44:59,880
Traverse down into further down in my

1113
00:44:59,880 --> 00:45:01,890
query plan tree I'm not gonna magically

1114
00:45:01,890 --> 00:45:04,020
find the optimal plan that's me better

1115
00:45:04,020 --> 00:45:08,330
than the best one I've ever seen because

1116
00:45:08,330 --> 00:45:12,270
then because the way the search works is

1117
00:45:12,270 --> 00:45:13,620
that you're you're adding more in cost

1118
00:45:13,620 --> 00:45:15,300
as you go down and your automagically

1119
00:45:15,300 --> 00:45:17,220
going to get less than what you seen

1120
00:45:17,220 --> 00:45:19,530
before so this is just the branch and

1121
00:45:19,530 --> 00:45:22,040
balanced search method for solution tree

1122
00:45:22,040 --> 00:45:24,930
this is just saying that like we know

1123
00:45:24,930 --> 00:45:26,760
that if we get to a point in a query

1124
00:45:26,760 --> 00:45:29,610
plan that we have a sub plan that is

1125
00:45:29,610 --> 00:45:31,290
worse than the best movie ever seen we

1126
00:45:31,290 --> 00:45:32,970
don't we don't need to do any further

1127
00:45:32,970 --> 00:45:37,200
exploration on it okay so let's look at

1128
00:45:37,200 --> 00:45:40,680
now a full and an example of doing a

1129
00:45:40,680 --> 00:45:42,750
search so to say we want to do that

1130
00:45:42,750 --> 00:45:46,170
3-way join between a B and C and so at

1131
00:45:46,170 --> 00:45:48,270
the very beginning I have that this

1132
00:45:48,270 --> 00:45:51,270
group up here that says the output

1133
00:45:51,270 --> 00:45:55,440
expression should be a B and C so the

1134
00:45:55,440 --> 00:45:59,550
first step I need to do is fire off a

1135
00:45:59,550 --> 00:46:01,410
transformation rule that will generate

1136
00:46:01,410 --> 00:46:06,090
me a logical mult expression so here we

1137
00:46:06,090 --> 00:46:07,740
have now a and B combined together and

1138
00:46:07,740 --> 00:46:09,780
then we're joining joining C

1139
00:46:09,780 --> 00:46:11,340
so now what I want to do is Traverse

1140
00:46:11,340 --> 00:46:14,280
down into the tree and figure out what's

1141
00:46:14,280 --> 00:46:19,050
the cost of executing of you know these

1142
00:46:19,050 --> 00:46:21,480
two components of my my expression

1143
00:46:21,480 --> 00:46:23,280
so I'll start down here I'll take a and

1144
00:46:23,280 --> 00:46:25,230
B so again now I have a new group with

1145
00:46:25,230 --> 00:46:27,210
output it's is a and B because that

1146
00:46:27,210 --> 00:46:29,100
matches what my place hold or up here is

1147
00:46:29,100 --> 00:46:31,140
and same thing now I want to have a

1148
00:46:31,140 --> 00:46:32,790
logical transformation or logic

1149
00:46:32,790 --> 00:46:35,340
expression to represent what how to

1150
00:46:35,340 --> 00:46:37,320
compute this output so that's just now

1151
00:46:37,320 --> 00:46:40,140
somehow accessing a and I'm gonna join

1152
00:46:40,140 --> 00:46:41,820
that with somehow some way of accessing

1153
00:46:41,820 --> 00:46:44,370
B so now same thing I got to start with

1154
00:46:44,370 --> 00:46:46,470
this first this first component of my

1155
00:46:46,470 --> 00:46:48,900
expression and go down and examine how

1156
00:46:48,900 --> 00:46:50,880
I'm actually gonna access it so my

1157
00:46:50,880 --> 00:46:53,520
logical operator would just be get get a

1158
00:46:53,520 --> 00:46:55,560
I'm gonna access a hey they're not

1159
00:46:55,560 --> 00:46:57,630
saying actually how to do it so I can

1160
00:46:57,630 --> 00:46:58,580
have a logical to physical

1161
00:46:58,580 --> 00:47:01,350
transformation to then say oh I can do

1162
00:47:01,350 --> 00:47:03,960
an index scan on a or I can do a

1163
00:47:03,960 --> 00:47:07,410
sequential scan or name and then now at

1164
00:47:07,410 --> 00:47:09,600
this point here we have these physical

1165
00:47:09,600 --> 00:47:11,820
expressions because nobody below us in

1166
00:47:11,820 --> 00:47:14,400
the query plan tree so we can compute

1167
00:47:14,400 --> 00:47:16,680
the cost of what's going to take to Xu

1168
00:47:16,680 --> 00:47:18,870
both of these so let's say in this case

1169
00:47:18,870 --> 00:47:20,490
here the sequential scan for whatever

1170
00:47:20,490 --> 00:47:23,580
reason is is the cheapest way to execute

1171
00:47:23,580 --> 00:47:27,330
this this the access method on a so

1172
00:47:27,330 --> 00:47:28,800
we're going to compute the calls for

1173
00:47:28,800 --> 00:47:30,210
this and then we update our memo table

1174
00:47:30,210 --> 00:47:32,970
it's cut off here but this is just a to

1175
00:47:32,970 --> 00:47:34,620
say that the best expression we've ever

1176
00:47:34,620 --> 00:47:36,810
seen for the producing the output of

1177
00:47:36,810 --> 00:47:40,140
just a is the sequential scan on a with

1178
00:47:40,140 --> 00:47:44,040
the cost of 10 so now I can't even do

1179
00:47:44,040 --> 00:47:45,450
the same thing going the other side take

1180
00:47:45,450 --> 00:47:47,910
be I end up with this logical expression

1181
00:47:47,910 --> 00:47:50,520
be get B I compute all the different

1182
00:47:50,520 --> 00:47:51,570
physical expressions I could possibly

1183
00:47:51,570 --> 00:47:54,360
have sequential scan index scan the

1184
00:47:54,360 --> 00:47:55,680
sequential scan turns out to be cheap

1185
00:47:55,680 --> 00:47:57,480
the cheapest the cost 20

1186
00:47:57,480 --> 00:47:59,850
I upload 8 my memo table say to access

1187
00:47:59,850 --> 00:48:02,100
be sequential scan is the fastest with

1188
00:48:02,100 --> 00:48:04,590
the cost of 20 but now I come back up

1189
00:48:04,590 --> 00:48:07,830
here and I can up into that convinced

1190
00:48:07,830 --> 00:48:09,330
coop here and if they still start

1191
00:48:09,330 --> 00:48:12,330
computing more logic expressions for our

1192
00:48:12,330 --> 00:48:13,620
generating more logical specialists

1193
00:48:13,620 --> 00:48:16,620
pretty this produces output for me so

1194
00:48:16,620 --> 00:48:18,570
now I want to join be an egg because I

1195
00:48:18,570 --> 00:48:20,500
did that rotation

1196
00:48:20,500 --> 00:48:24,250
right the order it's a now same thing I

1197
00:48:24,250 --> 00:48:26,590
need to get the cost of accessing B and

1198
00:48:26,590 --> 00:48:28,180
then I get the cost of accessing a

1199
00:48:28,180 --> 00:48:30,480
before I compute the physical cost of

1200
00:48:30,480 --> 00:48:35,560
converting this to a physical physical

1201
00:48:35,560 --> 00:48:38,470
operator so but in this case here when I

1202
00:48:38,470 --> 00:48:40,420
go down and say what's the cost of

1203
00:48:40,420 --> 00:48:42,550
accessing B or what's the cost of

1204
00:48:42,550 --> 00:48:44,859
accessing a I've actually already done

1205
00:48:44,859 --> 00:48:47,050
this right I don't need to do that

1206
00:48:47,050 --> 00:48:49,090
because I already have the best cost in

1207
00:48:49,090 --> 00:48:51,970
my memo table so I don't need to do this

1208
00:48:51,970 --> 00:48:54,580
search again down here or plyo more

1209
00:48:54,580 --> 00:48:57,130
transformations I'm done and I just

1210
00:48:57,130 --> 00:49:00,040
reuse the cost that I've had here so I

1211
00:49:00,040 --> 00:49:01,810
can I could keep doing this like it's

1212
00:49:01,810 --> 00:49:03,609
only a joint B or B joint a there's only

1213
00:49:03,609 --> 00:49:05,710
two choices but now I can look at all

1214
00:49:05,710 --> 00:49:08,590
possible combinations of what physical

1215
00:49:08,590 --> 00:49:11,080
operator I want to use for computing the

1216
00:49:11,080 --> 00:49:13,510
join and here I'm only showing a subset

1217
00:49:13,510 --> 00:49:14,830
but now again if I want to get this

1218
00:49:14,830 --> 00:49:16,660
physical cost and you know that the cost

1219
00:49:16,660 --> 00:49:18,040
of accessing any of the code calls

1220
00:49:18,040 --> 00:49:20,800
exiting B but I already have that in my

1221
00:49:20,800 --> 00:49:24,369
physical plan right so the cost to save

1222
00:49:24,369 --> 00:49:25,540
this one here to do in the SERP

1223
00:49:25,540 --> 00:49:27,640
merge-join it's the cost of accessing a

1224
00:49:27,640 --> 00:49:29,800
which is 10 the cost of X is in B which

1225
00:49:29,800 --> 00:49:31,839
is 20 and the cost of the server is

1226
00:49:31,839 --> 00:49:34,359
joined assume is 50 and now I can write

1227
00:49:34,359 --> 00:49:37,390
that into my memo table to say the cost

1228
00:49:37,390 --> 00:49:40,780
of doing this is 80 so now here I come

1229
00:49:40,780 --> 00:49:42,670
back up to my according to this group

1230
00:49:42,670 --> 00:49:44,200
here and now I didn't need to examine

1231
00:49:44,200 --> 00:49:46,780
the other side access some C so same

1232
00:49:46,780 --> 00:49:48,700
thing jump down here I can gather do a

1233
00:49:48,700 --> 00:49:50,200
sequential scan or indexed and let's say

1234
00:49:50,200 --> 00:49:51,700
for whatever reason index scan is faster

1235
00:49:51,700 --> 00:49:54,790
so I record that cost to here being 5

1236
00:49:54,790 --> 00:49:57,220
and then now I just can I could do more

1237
00:49:57,220 --> 00:49:58,720
permutations of different joint

1238
00:49:58,720 --> 00:50:01,780
orderings of a B and C or I can start

1239
00:50:01,780 --> 00:50:05,020
examining be converting a lot of

1240
00:50:05,020 --> 00:50:06,550
expressions into physical physical

1241
00:50:06,550 --> 00:50:08,380
operators and examining what are the

1242
00:50:08,380 --> 00:50:12,099
different ways to access to do the

1243
00:50:12,099 --> 00:50:16,030
actual join and then I can pick one

1244
00:50:16,030 --> 00:50:17,770
different has the lower cost based on

1245
00:50:17,770 --> 00:50:21,940
the summation of what I've done below me

1246
00:50:21,940 --> 00:50:25,510
in the query planet all right so that's

1247
00:50:25,510 --> 00:50:27,220
essentially how Cascades works right at

1248
00:50:27,220 --> 00:50:28,869
a high level like we just keep doing

1249
00:50:28,869 --> 00:50:30,210
more more permutations

1250
00:50:30,210 --> 00:50:32,560
use the memory table as much as possible

1251
00:50:32,560 --> 00:50:34,180
but then we invoke the cost model

1252
00:50:34,180 --> 00:50:37,030
when we have enough to do a estimation

1253
00:50:37,030 --> 00:50:42,070
on the physical cost and now makes more

1254
00:50:42,070 --> 00:50:43,180
sense what we talked about last time at

1255
00:50:43,180 --> 00:50:45,220
the search termination you could see how

1256
00:50:45,220 --> 00:50:46,930
for really complex curves a lot of joins

1257
00:50:46,930 --> 00:50:49,120
I could heat going really deep into my

1258
00:50:49,120 --> 00:50:50,980
query plan and I just keep doing this

1259
00:50:50,980 --> 00:50:53,050
search forever so you need a way to

1260
00:50:53,050 --> 00:50:55,870
determine when should you stop and we

1261
00:50:55,870 --> 00:50:56,770
talked about how the wall clock time

1262
00:50:56,770 --> 00:50:58,870
just says I stop when I run out of time

1263
00:50:58,870 --> 00:51:00,790
right for a certain amount you know some

1264
00:51:00,790 --> 00:51:03,070
configurable amount I could have a cost

1265
00:51:03,070 --> 00:51:06,880
threshold to say like if I if I find a

1266
00:51:06,880 --> 00:51:08,320
look if I haven't found a lower cost I

1267
00:51:08,320 --> 00:51:10,870
haven't found a better plan that has

1268
00:51:10,870 --> 00:51:12,730
been 10% better than the best one I've

1269
00:51:12,730 --> 00:51:15,160
seen so far then I just should just stop

1270
00:51:15,160 --> 00:51:17,530
because I'm I'm sort of getting

1271
00:51:17,530 --> 00:51:19,330
diminishing returns on continuing the

1272
00:51:19,330 --> 00:51:21,610
search and then you know the last one to

1273
00:51:21,610 --> 00:51:23,440
be if I because also they search all

1274
00:51:23,440 --> 00:51:28,480
different options then I didn't stop so

1275
00:51:28,480 --> 00:51:33,850
cascades is as I said as far as I know I

1276
00:51:33,850 --> 00:51:35,620
don't think there ever was a standalone

1277
00:51:35,620 --> 00:51:40,000
cascade to implementation least I don't

1278
00:51:40,000 --> 00:51:42,490
think so I think that grid graph II

1279
00:51:42,490 --> 00:51:44,290
worked with Microsoft in the nineties

1280
00:51:44,290 --> 00:51:46,510
the emblem that cascades in single

1281
00:51:46,510 --> 00:51:49,870
server and it's best my knowledge there

1282
00:51:49,870 --> 00:51:52,450
they're still based on that but it's

1283
00:51:52,450 --> 00:51:54,550
been using a bunch of different bunch of

1284
00:51:54,550 --> 00:51:57,640
different systems as well most database

1285
00:51:57,640 --> 00:51:59,110
systems as far as I know are using the

1286
00:51:59,110 --> 00:52:02,290
dynamic programming technique method but

1287
00:52:02,290 --> 00:52:04,360
some of the newer ones in the last 20

1288
00:52:04,360 --> 00:52:07,060
years or so or using some of them are

1289
00:52:07,060 --> 00:52:10,030
using cascades so Wisconsin ah plus plus

1290
00:52:10,030 --> 00:52:11,620
was like Columbia where sort of

1291
00:52:11,620 --> 00:52:14,920
standalone optimizer generator that

1292
00:52:14,920 --> 00:52:16,270
would you know you define the rules and

1293
00:52:16,270 --> 00:52:17,590
we compute the or generate the cost

1294
00:52:17,590 --> 00:52:20,100
model or generate the optimizer for you

1295
00:52:20,100 --> 00:52:23,350
pivotal Orica and calcite are actually

1296
00:52:23,350 --> 00:52:24,460
two interesting projects we'll talk

1297
00:52:24,460 --> 00:52:26,190
about in a second but think of these as

1298
00:52:26,190 --> 00:52:28,960
standalone services that do query

1299
00:52:28,960 --> 00:52:30,430
optimization so you can have like your

1300
00:52:30,430 --> 00:52:32,140
database system running one machine your

1301
00:52:32,140 --> 00:52:33,580
query optimization service running on

1302
00:52:33,580 --> 00:52:34,270
the machine

1303
00:52:34,270 --> 00:52:36,780
and you send query requests over to the

1304
00:52:36,780 --> 00:52:39,340
optimizer service it crunches on them

1305
00:52:39,340 --> 00:52:41,470
and then spit you back a hospital plan

1306
00:52:41,470 --> 00:52:43,930
that you then execute and so these again

1307
00:52:43,930 --> 00:52:45,400
these are not these are not tied to any

1308
00:52:45,400 --> 00:52:47,130
specific database system

1309
00:52:47,130 --> 00:52:48,539
the ones that are actually integrated

1310
00:52:48,539 --> 00:52:49,680
the system against Eagle server is

1311
00:52:49,680 --> 00:52:53,569
pretty famous non-stop sequel is a

1312
00:52:53,569 --> 00:52:55,170
distributed database or parallel

1313
00:52:55,170 --> 00:52:56,989
database from the early nineteen

1314
00:52:56,989 --> 00:52:59,849
nineteen eighties that's still widely

1315
00:52:59,849 --> 00:53:01,579
used today in a lot of banks and

1316
00:53:01,579 --> 00:53:04,710
financial systems and so they rewrote

1317
00:53:04,710 --> 00:53:07,319
the choreographer in the 1990s cluster

1318
00:53:07,319 --> 00:53:11,369
expose a or is this to exist is a

1319
00:53:11,369 --> 00:53:13,259
distributed version of my sequel that

1320
00:53:13,259 --> 00:53:17,400
was blocked by the Morea DB people it's

1321
00:53:17,400 --> 00:53:19,619
two years ago now and according their

1322
00:53:19,619 --> 00:53:21,059
documentation they use the Cascades

1323
00:53:21,059 --> 00:53:23,009
optimizer to replace the original my

1324
00:53:23,009 --> 00:53:24,989
sequel optimizer and then our system

1325
00:53:24,989 --> 00:53:27,150
peloton which we started in 2000 we

1326
00:53:27,150 --> 00:53:29,640
killed it off two years ago but since

1327
00:53:29,640 --> 00:53:32,789
then 7:21 students have ported it over

1328
00:53:32,789 --> 00:53:35,099
into the newer system that you guys are

1329
00:53:35,099 --> 00:53:39,769
working on today so and as open-source

1330
00:53:39,769 --> 00:53:42,720
alright let's talk about pivotal Orca

1331
00:53:42,720 --> 00:53:44,400
and calcite because I think those are

1332
00:53:44,400 --> 00:53:47,460
like I said these are standalone

1333
00:53:47,460 --> 00:53:49,259
optimizer systems that are not tied to

1334
00:53:49,259 --> 00:53:53,009
any one database system we did examine

1335
00:53:53,009 --> 00:53:55,559
Orca in the very beginning days of

1336
00:53:55,559 --> 00:53:57,059
peloton decide whether we wanted to use

1337
00:53:57,059 --> 00:53:58,529
it they didn't have a look at that

1338
00:53:58,529 --> 00:54:00,539
locked imputation and the way it worked

1339
00:54:00,539 --> 00:54:02,549
was you would run the service and yet a

1340
00:54:02,549 --> 00:54:03,900
sent over these XML files that a

1341
00:54:03,900 --> 00:54:06,210
specified like the query plan and the

1342
00:54:06,210 --> 00:54:08,819
rules and and the catalog statistics

1343
00:54:08,819 --> 00:54:10,289
about what the data looks like but I

1344
00:54:10,289 --> 00:54:11,729
guess I wasn't very documented it's

1345
00:54:11,729 --> 00:54:13,109
gotten much better since than less when

1346
00:54:13,109 --> 00:54:15,690
we looked at it at the time it was it

1347
00:54:15,690 --> 00:54:16,799
was not initiate where we could I can

1348
00:54:16,799 --> 00:54:20,249
use it so Orca is a key annular cascades

1349
00:54:20,249 --> 00:54:21,809
implementation that was originally

1350
00:54:21,809 --> 00:54:24,180
written for green plum green plum was

1351
00:54:24,180 --> 00:54:27,269
one of the original data warehouse

1352
00:54:27,269 --> 00:54:30,029
systems from the mid-2000s that came out

1353
00:54:30,029 --> 00:54:33,119
with Vertica and data Allegro and Astra

1354
00:54:33,119 --> 00:54:37,799
data and so what happened was EMC bought

1355
00:54:37,799 --> 00:54:43,529
green plum and then VMware bought gem

1356
00:54:43,529 --> 00:54:48,509
fire single fire and EMC didn't wanna

1357
00:54:48,509 --> 00:54:50,549
have a database division VMware I didn't

1358
00:54:50,549 --> 00:54:51,690
have database vision so they both

1359
00:54:51,690 --> 00:54:55,259
divested their database products combine

1360
00:54:55,259 --> 00:54:56,759
them into a single company called called

1361
00:54:56,759 --> 00:55:00,329
pivotal so Orca was originally written

1362
00:55:00,329 --> 00:55:01,059
for green plum

1363
00:55:01,059 --> 00:55:03,009
but then they broke it out and had to be

1364
00:55:03,009 --> 00:55:04,419
a stimulant system so they can then use

1365
00:55:04,419 --> 00:55:06,939
it for their sequel engine on top of

1366
00:55:06,939 --> 00:55:08,859
Hadoop the Hadoop file system called

1367
00:55:08,859 --> 00:55:11,739
Hawk so again it's agnostic what the

1368
00:55:11,739 --> 00:55:13,599
actual data model is or what the actual

1369
00:55:13,599 --> 00:55:16,119
database system it is you specify

1370
00:55:16,119 --> 00:55:19,359
through these XML files what you you

1371
00:55:19,359 --> 00:55:20,559
know what rules you have and how it

1372
00:55:20,559 --> 00:55:21,849
actually wants to how it should actually

1373
00:55:21,849 --> 00:55:23,949
form the plans and then it's up for you

1374
00:55:23,949 --> 00:55:25,479
in your data system to take those XML

1375
00:55:25,479 --> 00:55:26,859
files when you get the response of

1376
00:55:26,859 --> 00:55:29,079
here's the optimized plan and be able to

1377
00:55:29,079 --> 00:55:31,900
execute it so the one interesting thing

1378
00:55:31,900 --> 00:55:34,239
about orca that we haven't talked about

1379
00:55:34,239 --> 00:55:36,459
here is that because it's a standalone

1380
00:55:36,459 --> 00:55:39,339
service you can imagine like I have my

1381
00:55:39,339 --> 00:55:41,559
cluster of database machines and then I

1382
00:55:41,559 --> 00:55:43,269
have one machines that's dedicated as

1383
00:55:43,269 --> 00:55:45,640
the query optimizer machine so that

1384
00:55:45,640 --> 00:55:47,559
means that can that machine can use all

1385
00:55:47,559 --> 00:55:49,059
the cores or all the resources that

1386
00:55:49,059 --> 00:55:51,039
available to it to do query optimization

1387
00:55:51,039 --> 00:55:53,769
so they actually can do multi-threaded

1388
00:55:53,769 --> 00:55:57,489
search so how would that look well in

1389
00:55:57,489 --> 00:55:59,439
either were doing dynamic programming or

1390
00:55:59,439 --> 00:56:01,539
the Cascades approach you could it's

1391
00:56:01,539 --> 00:56:02,979
easy to imagine that there's different

1392
00:56:02,979 --> 00:56:06,039
points of the query tree where I could

1393
00:56:06,039 --> 00:56:07,509
for call for spawn off different threads

1394
00:56:07,509 --> 00:56:10,839
to do exploration in them and there but

1395
00:56:10,839 --> 00:56:12,309
they're all using the cost model at all

1396
00:56:12,309 --> 00:56:13,269
examining doing their own

1397
00:56:13,269 --> 00:56:15,909
transformations you still have to maybe

1398
00:56:15,909 --> 00:56:17,559
update a global memo table to avoid

1399
00:56:17,559 --> 00:56:19,569
redundant calculations or update here's

1400
00:56:19,569 --> 00:56:22,150
the best plan I've ever seen but in for

1401
00:56:22,150 --> 00:56:25,119
the most part the search themselves is

1402
00:56:25,119 --> 00:56:28,089
very independent so they're one of the

1403
00:56:28,089 --> 00:56:29,709
few optimizers that I know about that

1404
00:56:29,709 --> 00:56:33,039
can do that can that is multi-threaded

1405
00:56:33,039 --> 00:56:34,689
which I think is kind of cool and

1406
00:56:34,689 --> 00:56:39,789
certainly our optimizers not thank our

1407
00:56:39,789 --> 00:56:42,299
optimizer right now could run different

1408
00:56:42,299 --> 00:56:44,349
queries do optimizing different queries

1409
00:56:44,349 --> 00:56:46,449
that when different threads but we can't

1410
00:56:46,449 --> 00:56:47,979
take one query and do the search on

1411
00:56:47,979 --> 00:56:51,400
multiple threads so there's two

1412
00:56:51,400 --> 00:56:52,900
interesting engineering things that came

1413
00:56:52,900 --> 00:56:54,609
out of the that are in the Oracle paper

1414
00:56:54,609 --> 00:56:56,829
that I find really fascinating that I

1415
00:56:56,829 --> 00:56:59,079
haven't really seen discussed in other

1416
00:56:59,079 --> 00:57:02,169
descriptions of optimizers so the first

1417
00:57:02,169 --> 00:57:06,009
is that in Orca they've set it up to

1418
00:57:06,009 --> 00:57:07,959
enable them to do remote debugging more

1419
00:57:07,959 --> 00:57:09,789
easily so greenplum

1420
00:57:09,789 --> 00:57:12,579
is designed as on-premise software so

1421
00:57:12,579 --> 00:57:13,959
it's not running as a hosted service in

1422
00:57:13,959 --> 00:57:14,420
the cloud

1423
00:57:14,420 --> 00:57:16,400
like if your corporation you download

1424
00:57:16,400 --> 00:57:17,750
the software that the green thumb

1425
00:57:17,750 --> 00:57:19,760
software in Orca and you run it on your

1426
00:57:19,760 --> 00:57:22,069
own machines in your own data center so

1427
00:57:22,069 --> 00:57:23,720
now the problem is though if now the

1428
00:57:23,720 --> 00:57:25,700
optimizer breaks or throws an error

1429
00:57:25,700 --> 00:57:27,200
there's a some problem with it

1430
00:57:27,200 --> 00:57:29,299
how you how do you actually debug that

1431
00:57:29,299 --> 00:57:31,549
if you're now the Orca developers back

1432
00:57:31,549 --> 00:57:33,200
and working in pivotal because they're

1433
00:57:33,200 --> 00:57:34,819
not gonna let you SSH into the Machine

1434
00:57:34,819 --> 00:57:37,609
and you know rerun the the the query

1435
00:57:37,609 --> 00:57:39,799
that failed or you know get a dump of

1436
00:57:39,799 --> 00:57:41,690
the data and run it locally because it's

1437
00:57:41,690 --> 00:57:44,059
gonna be way too big so what they did

1438
00:57:44,059 --> 00:57:46,250
was they had it so that anytime that

1439
00:57:46,250 --> 00:57:49,790
there is an error the system would be a

1440
00:57:49,790 --> 00:57:53,690
dump out its state in such a way that it

1441
00:57:53,690 --> 00:57:55,220
made it that allowed the developer to

1442
00:57:55,220 --> 00:57:57,890
take that state dump load it back

1443
00:57:57,890 --> 00:58:00,349
locally and be able to walk through

1444
00:58:00,349 --> 00:58:03,950
exactly what the state of the the system

1445
00:58:03,950 --> 00:58:06,559
was the optimizer was when that query

1446
00:58:06,559 --> 00:58:08,780
had an error so that you can easily

1447
00:58:08,780 --> 00:58:12,950
reproduce the problem and and fix it so

1448
00:58:12,950 --> 00:58:15,680
think of this as like a core dump for

1449
00:58:15,680 --> 00:58:18,559
your optimizer where it has additional

1450
00:58:18,559 --> 00:58:22,369
information like what was you know what

1451
00:58:22,369 --> 00:58:23,240
were all the transformations that I

1452
00:58:23,240 --> 00:58:24,740
applied what's in the memo table like

1453
00:58:24,740 --> 00:58:25,970
it's more than the quota dump it's sort

1454
00:58:25,970 --> 00:58:28,760
of more it's more specific customized to

1455
00:58:28,760 --> 00:58:30,530
doing court optimization to make their

1456
00:58:30,530 --> 00:58:33,589
life easier and again I have not seen

1457
00:58:33,589 --> 00:58:34,819
this maybe the commercial guys have this

1458
00:58:34,819 --> 00:58:37,430
but I have not seen this talked about in

1459
00:58:37,430 --> 00:58:40,069
other other optimizers the other cool

1460
00:58:40,069 --> 00:58:42,140
thing they do in Oracle which I find

1461
00:58:42,140 --> 00:58:45,410
super interesting is that they talk

1462
00:58:45,410 --> 00:58:46,640
about how they have this testing

1463
00:58:46,640 --> 00:58:48,980
framework that allows them to easily

1464
00:58:48,980 --> 00:58:51,740
check that the cost model and the

1465
00:58:51,740 --> 00:58:55,670
optimizer is truly picking the best

1466
00:58:55,670 --> 00:58:57,109
query plan the one that has the lowest

1467
00:58:57,109 --> 00:58:59,270
cost so they had this thing called taco

1468
00:58:59,270 --> 00:59:01,670
which is the testing the accuracy of the

1469
00:59:01,670 --> 00:59:03,470
query optimizer they claim it's open

1470
00:59:03,470 --> 00:59:03,859
source

1471
00:59:03,859 --> 00:59:06,079
I haven't maybe I'll find on on github I

1472
00:59:06,079 --> 00:59:08,839
need to email them but the way it works

1473
00:59:08,839 --> 00:59:11,569
is that I think of things like I think I

1474
00:59:11,569 --> 00:59:13,400
take my query I put into the optimizer

1475
00:59:13,400 --> 00:59:15,799
and then it'll spit out what I think is

1476
00:59:15,799 --> 00:59:17,299
the best plan but I can also have it

1477
00:59:17,299 --> 00:59:20,210
spit out what it what was the worst plan

1478
00:59:20,210 --> 00:59:23,119
and so now I can take the worst plan of

1479
00:59:23,119 --> 00:59:24,950
the best plan actually execute them on

1480
00:59:24,950 --> 00:59:27,680
my database system and see oh yes it

1481
00:59:27,680 --> 00:59:28,250
actually true

1482
00:59:28,250 --> 00:59:30,530
is that that the best one is actually

1483
00:59:30,530 --> 00:59:32,900
faster than the worst one now in that

1484
00:59:32,900 --> 00:59:34,070
case you don't want to do you know

1485
00:59:34,070 --> 00:59:36,650
that's to extremes the worst one

1486
00:59:36,650 --> 00:59:37,940
probably would be so slow that you don't

1487
00:59:37,940 --> 00:59:38,660
want to do it like it's a bunch of

1488
00:59:38,660 --> 00:59:39,980
Cartesian products it'll take forever to

1489
00:59:39,980 --> 00:59:41,810
run that's obvious so you ought to sort

1490
00:59:41,810 --> 00:59:44,600
of narrow the gap of what the worst plan

1491
00:59:44,600 --> 00:59:47,030
actually years or the the less optimum

1492
00:59:47,030 --> 00:59:49,100
plan is how many steps away from that is

1493
00:59:49,100 --> 00:59:51,110
from the optimal plan like you take the

1494
00:59:51,110 --> 00:59:53,690
best plan and the second-best plan run

1495
00:59:53,690 --> 00:59:55,430
them and improve that the best plan

1496
00:59:55,430 --> 00:59:57,650
actually truly is the better plan this

1497
00:59:57,650 --> 00:59:58,940
is something we want to do in our own

1498
00:59:58,940 --> 01:00:01,100
system we have the infrastructure and

1499
01:00:01,100 --> 01:00:03,440
the optimizer to potentially do this we

1500
01:00:03,440 --> 01:00:04,640
just haven't built out the testing you

1501
01:00:04,640 --> 01:00:06,650
know the testing framework to make it

1502
01:00:06,650 --> 01:00:10,580
happen so Orko is super cool Oracle was

1503
01:00:10,580 --> 01:00:12,170
one of the first standalone query

1504
01:00:12,170 --> 01:00:13,670
optimizer frameworks least in the modern

1505
01:00:13,670 --> 01:00:19,370
area era the got + + + + Columbia around

1506
01:00:19,370 --> 01:00:21,530
for the 90s but as far as I know in the

1507
01:00:21,530 --> 01:00:23,450
codes online but you know it's it's

1508
01:00:23,450 --> 01:00:25,310
dated and nobody actually uses that I

1509
01:00:25,310 --> 01:00:27,080
might have not maintained whereas orc

1510
01:00:27,080 --> 01:00:29,320
has actually maintained the other

1511
01:00:29,320 --> 01:00:31,430
optimizer framework that is actually

1512
01:00:31,430 --> 01:00:33,950
more popular I think in Orca at least

1513
01:00:33,950 --> 01:00:35,120
when I'm talking from David's companies

1514
01:00:35,120 --> 01:00:37,610
is this thing called calcite so again

1515
01:00:37,610 --> 01:00:40,000
this is another standalone code

1516
01:00:40,000 --> 01:00:42,680
optimization framework that where you

1517
01:00:42,680 --> 01:00:46,790
can specify you know what what data

1518
01:00:46,790 --> 01:00:48,050
model you want to use what crazy

1519
01:00:48,050 --> 01:00:48,950
language your support what the cost

1520
01:00:48,950 --> 01:00:50,180
models are and all the transformation

1521
01:00:50,180 --> 01:00:51,590
you want to apply and again it just

1522
01:00:51,590 --> 01:00:53,570
compiles them down and can do this all

1523
01:00:53,570 --> 01:00:54,790
all for you

1524
01:00:54,790 --> 01:00:58,160
so it originally came out of lucidi be

1525
01:00:58,160 --> 01:01:00,470
lucid DB was a Java based database

1526
01:01:00,470 --> 01:01:04,040
system start up out of the late 2000s

1527
01:01:04,040 --> 01:01:06,740
that failed as many different startups

1528
01:01:06,740 --> 01:01:08,900
actually fail there's a lot of them but

1529
01:01:08,900 --> 01:01:10,400
what came out of the ashes of lucidi B

1530
01:01:10,400 --> 01:01:12,200
was the actual query optimizer which

1531
01:01:12,200 --> 01:01:15,860
then got open sourced as Cal said if

1532
01:01:15,860 --> 01:01:17,810
everything's written in Java and there's

1533
01:01:17,810 --> 01:01:20,690
a quite a number of database startup

1534
01:01:20,690 --> 01:01:22,340
projects open source and closed source

1535
01:01:22,340 --> 01:01:24,500
that are interested in actually using

1536
01:01:24,500 --> 01:01:27,500
using Kaltura or we're actively using it

1537
01:01:27,500 --> 01:01:30,380
or pursuing the adoption of it some

1538
01:01:30,380 --> 01:01:32,230
examples are would omnis I heard DB

1539
01:01:32,230 --> 01:01:34,970
plays in sequel Apache hive spliced

1540
01:01:34,970 --> 01:01:37,340
machine and I know maybe two others that

1541
01:01:37,340 --> 01:01:39,740
have talked about they they wanna start

1542
01:01:39,740 --> 01:01:41,990
using this now they all use it to do

1543
01:01:41,990 --> 01:01:45,680
to different levels so this calcite also

1544
01:01:45,680 --> 01:01:47,089
provides you the sequel parser as well

1545
01:01:47,089 --> 01:01:49,300
so some of them is using two parts equal

1546
01:01:49,300 --> 01:01:52,310
and calcite has the seven dialect some

1547
01:01:52,310 --> 01:01:53,660
of them are using it to active you the

1548
01:01:53,660 --> 01:01:55,700
query optimization I have not seen

1549
01:01:55,700 --> 01:01:59,599
reports on how good it actually is but I

1550
01:01:59,599 --> 01:02:01,160
think again this seems to be a lot of

1551
01:02:01,160 --> 01:02:02,990
traction around this because this is

1552
01:02:02,990 --> 01:02:05,750
Apache project whereas Orca for whatever

1553
01:02:05,750 --> 01:02:07,640
reason maybe because pivotal stone owns

1554
01:02:07,640 --> 01:02:11,450
it that uh as far as their know only

1555
01:02:11,450 --> 01:02:13,400
pivotal Xin one using Orca even though

1556
01:02:13,400 --> 01:02:16,820
it's open source so I think for this one

1557
01:02:16,820 --> 01:02:18,200
this one you'll see a lot more in

1558
01:02:18,200 --> 01:02:20,900
systems going forward at the last

1559
01:02:20,900 --> 01:02:22,460
optimizer implication we'll talk about

1560
01:02:22,460 --> 01:02:26,619
is from them sequel it's not anything

1561
01:02:26,619 --> 01:02:30,530
mind-blowing the reason I'm bringing it

1562
01:02:30,530 --> 01:02:31,820
up cuz they do one thing that's slightly

1563
01:02:31,820 --> 01:02:34,040
different than the other optimizer we

1564
01:02:34,040 --> 01:02:37,400
talked about here and this is probably

1565
01:02:37,400 --> 01:02:39,650
because they're targeting distributed a

1566
01:02:39,650 --> 01:02:41,030
distributed database system environment

1567
01:02:41,030 --> 01:02:44,359
which we've not really focused on in in

1568
01:02:44,359 --> 01:02:46,670
the semester at all but it's just we're

1569
01:02:46,670 --> 01:02:47,900
sort of brick worth bringing up to and

1570
01:02:47,900 --> 01:02:50,540
understand you know the types of things

1571
01:02:50,540 --> 01:02:53,150
people can do in a query optimizer so

1572
01:02:53,150 --> 01:02:54,980
it's gonna have three stages it's like

1573
01:02:54,980 --> 01:02:56,540
the stratified approach you'll have a

1574
01:02:56,540 --> 01:02:58,460
lot of rewriter that is Lodge alots with

1575
01:02:58,460 --> 01:03:00,920
the transparent transformations but

1576
01:03:00,920 --> 01:03:02,839
these logical logical transformations

1577
01:03:02,839 --> 01:03:05,000
actually can use a cost model then

1578
01:03:05,000 --> 01:03:06,109
they're doing the logical physical

1579
01:03:06,109 --> 01:03:07,790
transformations and this is mostly going

1580
01:03:07,790 --> 01:03:10,160
to be a dynamic programming approach to

1581
01:03:10,160 --> 01:03:13,339
do the join reordering but then now then

1582
01:03:13,339 --> 01:03:15,560
the last stage they're actually going to

1583
01:03:15,560 --> 01:03:17,030
take the physical plan that you get out

1584
01:03:17,030 --> 01:03:19,130
of the numerator and then convert it

1585
01:03:19,130 --> 01:03:20,869
back into sequel but they're gonna

1586
01:03:20,869 --> 01:03:22,640
annotate the sequel with some additional

1587
01:03:22,640 --> 01:03:25,609
mem see ghosts of the commands for

1588
01:03:25,609 --> 01:03:27,830
moving data that in a way that sequel

1589
01:03:27,830 --> 01:03:29,690
can actually specify goes against egos

1590
01:03:29,690 --> 01:03:30,740
high-level doesn't say where the textual

1591
01:03:30,740 --> 01:03:32,420
data is but now we're gonna add commands

1592
01:03:32,420 --> 01:03:33,920
here to say like alright run this query

1593
01:03:33,920 --> 01:03:36,440
but then send the data to this this this

1594
01:03:36,440 --> 01:03:39,430
particular machine and in your cluster

1595
01:03:39,430 --> 01:03:41,810
so this parts is super interesting that

1596
01:03:41,810 --> 01:03:44,089
I've never really heard about in the

1597
01:03:44,089 --> 01:03:46,339
from the optimizer standpoint of doing

1598
01:03:46,339 --> 01:03:47,630
this I've heard about this for testing

1599
01:03:47,630 --> 01:03:50,109
where people take the physical plan

1600
01:03:50,109 --> 01:03:52,130
that's produced by their optimizer and

1601
01:03:52,130 --> 01:03:54,540
then reverse it back into sequel and

1602
01:03:54,540 --> 01:03:56,640
see if you run that to be optimizer

1603
01:03:56,640 --> 01:03:58,860
again does it generate the same planner

1604
01:03:58,860 --> 01:04:01,560
or logically equivalent plan but I've

1605
01:04:01,560 --> 01:04:02,640
never heard of this where they convert

1606
01:04:02,640 --> 01:04:03,570
it back to sequel and then actually

1607
01:04:03,570 --> 01:04:05,310
execute it and then parse it all over

1608
01:04:05,310 --> 01:04:08,700
again so this is this is their pipeline

1609
01:04:08,700 --> 01:04:10,200
for the query optimizer and again it

1610
01:04:10,200 --> 01:04:12,030
looks a lot like me what we talked about

1611
01:04:12,030 --> 01:04:14,130
so far you parse it you bind it and

1612
01:04:14,130 --> 01:04:15,900
there's the rewrite or enumeration phase

1613
01:04:15,900 --> 01:04:18,930
but then you take the physical plan and

1614
01:04:18,930 --> 01:04:21,240
then this planner thing converts it to

1615
01:04:21,240 --> 01:04:23,550
sequel and then you send it to all the

1616
01:04:23,550 --> 01:04:25,560
interval execution nodes who are then

1617
01:04:25,560 --> 01:04:27,720
gonna do all these same steps all over

1618
01:04:27,720 --> 01:04:30,750
again except for this last one here

1619
01:04:30,750 --> 01:04:33,150
because now the idea is that we want to

1620
01:04:33,150 --> 01:04:35,940
have each local node that has the data

1621
01:04:35,940 --> 01:04:38,970
to make a decision about how to actually

1622
01:04:38,970 --> 01:04:42,000
do the lowest levels of putting

1623
01:04:42,000 --> 01:04:43,680
optimization like accent method things

1624
01:04:43,680 --> 01:04:45,450
like that so the way to think about this

1625
01:04:45,450 --> 01:04:48,480
is like say I want to do a join or say I

1626
01:04:48,480 --> 01:04:51,210
want to scan on a table across five

1627
01:04:51,210 --> 01:04:54,090
nodes and on some nodes maybe the data

1628
01:04:54,090 --> 01:04:55,530
has certain different distribution

1629
01:04:55,530 --> 01:04:57,810
that's different than other nodes so

1630
01:04:57,810 --> 01:05:00,210
rather than me and a global a global

1631
01:05:00,210 --> 01:05:02,370
planner try to make a decision of what's

1632
01:05:02,370 --> 01:05:04,110
the best way to execute this query on

1633
01:05:04,110 --> 01:05:07,110
all five nodes I'll come up with a high

1634
01:05:07,110 --> 01:05:08,940
level global plan of how we want to move

1635
01:05:08,940 --> 01:05:11,580
data around in this first phase here and

1636
01:05:11,580 --> 01:05:13,860
then I send the sequel query that I've

1637
01:05:13,860 --> 01:05:16,530
some regenerate back from the political

1638
01:05:16,530 --> 01:05:19,740
plan send that to the local node who

1639
01:05:19,740 --> 01:05:21,930
then can now make a decision like oh now

1640
01:05:21,930 --> 01:05:25,200
I know since I have a more accurate view

1641
01:05:25,200 --> 01:05:26,820
of what my data looks like because it's

1642
01:05:26,820 --> 01:05:27,540
local to me

1643
01:05:27,540 --> 01:05:29,250
I can make a better decision of how I

1644
01:05:29,250 --> 01:05:31,400
want to exceed that plan on that node

1645
01:05:31,400 --> 01:05:34,620
again most distributed databases as far

1646
01:05:34,620 --> 01:05:36,330
as I know don't do this last step they

1647
01:05:36,330 --> 01:05:38,010
take a physical plan and then ship that

1648
01:05:38,010 --> 01:05:40,890
off to all individual nodes which I

1649
01:05:40,890 --> 01:05:45,270
think this is kind of interesting okay

1650
01:05:45,270 --> 01:05:51,360
so just to finish up the main takeaway

1651
01:05:51,360 --> 01:05:53,040
you should get all out of all this that

1652
01:05:53,040 --> 01:05:54,900
we looked at the dynamic programming

1653
01:05:54,900 --> 01:05:55,830
approach we look at the Cascades

1654
01:05:55,830 --> 01:05:59,400
approach these are sort of begin to two

1655
01:05:59,400 --> 01:06:03,750
ways to to go out searching for a

1656
01:06:03,750 --> 01:06:06,779
physical plan the

1657
01:06:06,779 --> 01:06:09,089
all of this though is gonna make me

1658
01:06:09,089 --> 01:06:11,039
highly dependent on having a good cost

1659
01:06:11,039 --> 01:06:13,559
model if you don't have a good cost

1660
01:06:13,559 --> 01:06:14,669
model doesn't matter when you're doing

1661
01:06:14,669 --> 01:06:16,529
top down and bottom up you're gonna make

1662
01:06:16,529 --> 01:06:18,900
bad decisions and you in their plans are

1663
01:06:18,900 --> 01:06:22,140
just gonna be gonna be terrible and so

1664
01:06:22,140 --> 01:06:26,669
we will see next week on Wednesday next

1665
01:06:26,669 --> 01:06:29,429
week does how bad these cost models

1666
01:06:29,429 --> 01:06:31,619
gonna actually get in particular we do

1667
01:06:31,619 --> 01:06:33,419
cardinality estimations with joins and

1668
01:06:33,419 --> 01:06:35,519
so there's no magic way to make this

1669
01:06:35,519 --> 01:06:37,829
work and so when I say sequel server has

1670
01:06:37,829 --> 01:06:39,749
the best query optimizer the research

1671
01:06:39,749 --> 01:06:41,400
shows it actually picks the best plans

1672
01:06:41,400 --> 01:06:44,039
and that might be because they have the

1673
01:06:44,039 --> 01:06:46,199
best cost model and cost best estimates

1674
01:06:46,199 --> 01:06:51,449
okay all right so let's quickly go

1675
01:06:51,449 --> 01:06:53,099
through what's expected for you for the

1676
01:06:53,099 --> 01:06:55,079
project three code review so again as I

1677
01:06:55,079 --> 01:06:57,299
said on on this Wednesday as part of the

1678
01:06:57,299 --> 01:06:59,359
project presentations or project updates

1679
01:06:59,359 --> 01:07:01,319
every group is gonna have to send a pull

1680
01:07:01,319 --> 01:07:03,959
request to the master branch on on

1681
01:07:03,959 --> 01:07:07,319
github so this will kick off a build and

1682
01:07:07,319 --> 01:07:08,729
Travis if that fails you can ignore it

1683
01:07:08,729 --> 01:07:10,380
but I'll kick off a build on Jenkins and

1684
01:07:10,380 --> 01:07:12,179
that one we do need to pay attention to

1685
01:07:12,179 --> 01:07:15,349
and also compete your code coverage so

1686
01:07:15,349 --> 01:07:18,089
for this one your PR needs to be able to

1687
01:07:18,089 --> 01:07:19,439
cleanly merge in the master branch that

1688
01:07:19,439 --> 01:07:21,239
means you want to do a rebase get all

1689
01:07:21,239 --> 01:07:23,819
our latest changes depending on when you

1690
01:07:23,819 --> 01:07:25,409
guys fork the code from us this

1691
01:07:25,409 --> 01:07:28,409
shouldn't mean that many changes and so

1692
01:07:28,409 --> 01:07:30,119
what will happen is you'll go to the

1693
01:07:30,119 --> 01:07:30,809
Google spreadsheet

1694
01:07:30,809 --> 01:07:32,939
I'll now non toast Piazza you put the

1695
01:07:32,939 --> 01:07:35,819
link to your pull request there then

1696
01:07:35,819 --> 01:07:37,499
I'll sign you to another group you guys

1697
01:07:37,499 --> 01:07:41,390
go into the I'll give you one access on

1698
01:07:41,390 --> 01:07:44,069
github you can go comment do a code

1699
01:07:44,069 --> 01:07:45,989
review on github against the other teams

1700
01:07:45,989 --> 01:07:48,299
pull request and I'll keep track of

1701
01:07:48,299 --> 01:07:51,359
who's participating and the idea is that

1702
01:07:51,359 --> 01:07:53,819
when the pull request is done or the

1703
01:07:53,819 --> 01:07:54,949
code review is done in a week from now

1704
01:07:54,949 --> 01:07:57,779
the the team that you reviewed will take

1705
01:07:57,779 --> 01:07:59,009
your suggestions to take your comments

1706
01:07:59,009 --> 01:08:00,239
and actually incorporate them and make

1707
01:08:00,239 --> 01:08:02,849
changes into onto your code and we'll do

1708
01:08:02,849 --> 01:08:04,709
this around again another round of code

1709
01:08:04,709 --> 01:08:07,289
reviews when we get closer to when we

1710
01:08:07,289 --> 01:08:10,409
get near to end in this pasture so above

1711
01:08:10,409 --> 01:08:11,789
all else we should be you want to your

1712
01:08:11,789 --> 01:08:13,499
code reviews to be helpful would be

1713
01:08:13,499 --> 01:08:16,738
courteous you don't want to be overly

1714
01:08:16,738 --> 01:08:18,149
disparaging or hard

1715
01:08:18,149 --> 01:08:21,479
to your fellow students so don't say

1716
01:08:21,479 --> 01:08:22,799
like this is the worst curve ever see my

1717
01:08:22,799 --> 01:08:24,960
wife that doesn't help anybody if you

1718
01:08:24,960 --> 01:08:27,000
want to give constructive criticism

1719
01:08:27,000 --> 01:08:31,408
about about about their project so these

1720
01:08:31,408 --> 01:08:32,759
are just again some general tips about

1721
01:08:32,759 --> 01:08:34,529
how to actually proceed with the code

1722
01:08:34,529 --> 01:08:37,439
review so for the group that Smith's the

1723
01:08:37,439 --> 01:08:38,460
code review or Smith's the pull request

1724
01:08:38,460 --> 01:08:40,738
you want to include a summary and

1725
01:08:40,738 --> 01:08:42,689
information about what files and

1726
01:08:42,689 --> 01:08:44,969
functions and methods that you want the

1727
01:08:44,969 --> 01:08:46,859
reviewing team to look at so doesn't

1728
01:08:46,859 --> 01:08:48,299
help us if you have this giant pull

1729
01:08:48,299 --> 01:08:50,399
request with all these changes and some

1730
01:08:50,399 --> 01:08:51,479
of these changes are a work in progress

1731
01:08:51,479 --> 01:08:52,890
and you don't actually want feedback on

1732
01:08:52,890 --> 01:08:55,049
them yet so you want to enter in your in

1733
01:08:55,049 --> 01:08:56,040
your summary you should provide

1734
01:08:56,040 --> 01:08:58,109
information say here's the list of files

1735
01:08:58,109 --> 01:08:59,790
or here's a list of functions that you

1736
01:08:59,790 --> 01:09:01,549
want the other team to review for you

1737
01:09:01,549 --> 01:09:04,890
now when you do the review you want to

1738
01:09:04,890 --> 01:09:06,569
try to limit yourself to only look at

1739
01:09:06,569 --> 01:09:08,549
maybe four hundred lines of code at a

1740
01:09:08,549 --> 01:09:11,158
time and sort of set a max limit for any

1741
01:09:11,158 --> 01:09:12,658
time you sit down to do the review to be

1742
01:09:12,658 --> 01:09:14,670
up to sixty minutes because after after

1743
01:09:14,670 --> 01:09:17,580
60 minutes it all becomes a blur and

1744
01:09:17,580 --> 01:09:19,229
you're just leaving stupid comments and

1745
01:09:19,229 --> 01:09:21,330
you're missing obvious mistakes right so

1746
01:09:21,330 --> 01:09:22,589
we're sort of limit yourself to to

1747
01:09:22,589 --> 01:09:23,729
looking at this amount of code at a time

1748
01:09:23,729 --> 01:09:26,069
and then when you go into the do the

1749
01:09:26,069 --> 01:09:27,179
pull request you want to have a

1750
01:09:27,179 --> 01:09:29,908
checklist or so when you go into the

1751
01:09:29,908 --> 01:09:31,290
code view you want to have a checklist

1752
01:09:31,290 --> 01:09:33,540
set on the side to say what did that is

1753
01:09:33,540 --> 01:09:34,770
that you're actually looking for and how

1754
01:09:34,770 --> 01:09:37,589
can you actually provide help so these

1755
01:09:37,589 --> 01:09:40,380
are some things that that I'm suggesting

1756
01:09:40,380 --> 01:09:42,689
that you should look into or be mindful

1757
01:09:42,689 --> 01:09:44,969
of when you're doing in code view so

1758
01:09:44,969 --> 01:09:46,679
above all else obviously does the code

1759
01:09:46,679 --> 01:09:48,000
work right there should be you know

1760
01:09:48,000 --> 01:09:50,100
should compile to pass any test that you

1761
01:09:50,100 --> 01:09:52,290
have that they would have for their code

1762
01:09:52,290 --> 01:09:54,840
in the pool class is all the code easily

1763
01:09:54,840 --> 01:09:57,060
easily understandable like it's not

1764
01:09:57,060 --> 01:09:59,730
something you know arcane assembly code

1765
01:09:59,730 --> 01:10:02,760
or weird intrinsic that are not obvious

1766
01:10:02,760 --> 01:10:04,830
and make sure so make sure that the code

1767
01:10:04,830 --> 01:10:06,390
is getting you people don't have these

1768
01:10:06,390 --> 01:10:07,920
giant functions that do much of things

1769
01:10:07,920 --> 01:10:11,699
make sure things are broken up into you

1770
01:10:11,699 --> 01:10:14,640
know nice composable chunks we avoid any

1771
01:10:14,640 --> 01:10:16,350
duplicate code and avoid any commented

1772
01:10:16,350 --> 01:10:18,960
out code again is the code modular as

1773
01:10:18,960 --> 01:10:21,510
possible ish we know global variables we

1774
01:10:21,510 --> 01:10:23,159
can't I don't think we check for that

1775
01:10:23,159 --> 01:10:24,760
but

1776
01:10:24,760 --> 01:10:26,469
humanly I think as a human you have to

1777
01:10:26,469 --> 01:10:30,010
check for this if they have any debug

1778
01:10:30,010 --> 01:10:31,659
output to make sure the reaction using

1779
01:10:31,659 --> 01:10:33,940
the this the debug functions would give

1780
01:10:33,940 --> 01:10:36,489
you you know print f snow standard C

1781
01:10:36,489 --> 01:10:40,179
outs right well the the scripts will

1782
01:10:40,179 --> 01:10:41,829
check that when you when you submit the

1783
01:10:41,829 --> 01:10:43,989
pull request on github but you know it's

1784
01:10:43,989 --> 01:10:45,519
in general make sure that they're doing

1785
01:10:45,519 --> 01:10:48,159
that these things correctly everything

1786
01:10:48,159 --> 01:10:49,929
should be documented all right so that

1787
01:10:49,929 --> 01:10:51,159
comments on the code should actually

1788
01:10:51,159 --> 01:10:52,690
describe what is the true intent of the

1789
01:10:52,690 --> 01:10:55,900
code all the functions should follow the

1790
01:10:55,900 --> 01:10:57,969
doxygen Javadoc format and there's a

1791
01:10:57,969 --> 01:11:00,039
check for this again in Jenkins make

1792
01:11:00,039 --> 01:11:01,059
sure you every function is actually

1793
01:11:01,059 --> 01:11:03,400
documented if there's anything weird

1794
01:11:03,400 --> 01:11:05,079
that's happening in the code that's not

1795
01:11:05,079 --> 01:11:07,389
trivial to understand just by reading it

1796
01:11:07,389 --> 01:11:08,949
make sure that's actually fully

1797
01:11:08,949 --> 01:11:11,079
documented what the expected behavior of

1798
01:11:11,079 --> 01:11:13,360
the component of the system is here if

1799
01:11:13,360 --> 01:11:15,489
you're using the third-party libraries

1800
01:11:15,489 --> 01:11:16,959
make sure that it's an understandable

1801
01:11:16,959 --> 01:11:19,030
why we're using that third-party library

1802
01:11:19,030 --> 01:11:21,159
and there's any code that single please

1803
01:11:21,159 --> 01:11:23,590
you know it you should have to do

1804
01:11:23,590 --> 01:11:25,090
statements that are actually labeled

1805
01:11:25,090 --> 01:11:26,650
correctly to say what it is they're

1806
01:11:26,650 --> 01:11:29,260
actually doing testing is super

1807
01:11:29,260 --> 01:11:31,749
important the overarching rule about

1808
01:11:31,749 --> 01:11:34,389
your your projects is that the code

1809
01:11:34,389 --> 01:11:36,269
coverage never go down for your tests

1810
01:11:36,269 --> 01:11:39,880
your tester is actually meaningful so

1811
01:11:39,880 --> 01:11:41,079
that means you just can't have your

1812
01:11:41,079 --> 01:11:43,570
tests you know run through some code and

1813
01:11:43,570 --> 01:11:45,340
then print a standard out and that's how

1814
01:11:45,340 --> 01:11:46,150
you're checking to see whether I would

1815
01:11:46,150 --> 01:11:47,650
actually do something correct right it

1816
01:11:47,650 --> 01:11:49,119
should actually do rigorous checking to

1817
01:11:49,119 --> 01:11:51,940
make sure that the functionality and the

1818
01:11:51,940 --> 01:11:54,940
behavior is operating correctly so are

1819
01:11:54,940 --> 01:11:56,530
the tests complete are they

1820
01:11:56,530 --> 01:11:58,630
comprehensive are they actually testing

1821
01:11:58,630 --> 01:12:02,889
what they have to be testing and we want

1822
01:12:02,889 --> 01:12:04,959
to minimize the amount of hard-coded

1823
01:12:04,959 --> 01:12:07,209
answers we have in our tests now not all

1824
01:12:07,209 --> 01:12:11,409
our tests work this way but you know if

1825
01:12:11,409 --> 01:12:15,010
there's a way to derive what the correct

1826
01:12:15,010 --> 01:12:17,079
expected output is without having a

1827
01:12:17,079 --> 01:12:18,940
hard-coded constant value then that

1828
01:12:18,940 --> 01:12:21,039
would be preferable so that if we if we

1829
01:12:21,039 --> 01:12:24,820
tweaked your test case and we don't have

1830
01:12:24,820 --> 01:12:26,739
a bunch of you know erroneous errors or

1831
01:12:26,739 --> 01:12:27,999
having spent time to figure out with

1832
01:12:27,999 --> 01:12:29,199
that new constant value should actually

1833
01:12:29,199 --> 01:12:31,110
be

1834
01:12:31,110 --> 01:12:33,129
all right so again I'll post this on

1835
01:12:33,129 --> 01:12:35,110
these updates on this information on

1836
01:12:35,110 --> 01:12:37,239
Piazza and what's expected of you and I

1837
01:12:37,239 --> 01:12:38,889
will discuss this on on Wednesday this

1838
01:12:38,889 --> 01:12:41,760
week at the project proposals alright so

1839
01:12:41,760 --> 01:12:45,159
for next class will be a new lecture on

1840
01:12:45,159 --> 01:12:47,139
what I call non-traditional query

1841
01:12:47,139 --> 01:12:49,360
optimization methods and the idea here

1842
01:12:49,360 --> 01:12:51,729
is to - now that we understand the

1843
01:12:51,729 --> 01:12:53,469
background of like dynamic programming a

1844
01:12:53,469 --> 01:12:55,300
cascade so the core fundamentals of

1845
01:12:55,300 --> 01:12:57,550
doing query optimization let's look at

1846
01:12:57,550 --> 01:12:59,559
different ways people can extend these

1847
01:12:59,559 --> 01:13:02,969
techniques or try additional things to

1848
01:13:02,969 --> 01:13:05,349
to improve the efficacy of our query

1849
01:13:05,349 --> 01:13:08,939
optimizer okay hi guys wash your hands

1850
01:13:08,939 --> 01:13:12,570
what is this

1851
01:13:12,620 --> 01:13:32,829
[Music]

1852
01:13:34,870 --> 01:13:37,480
won't be the same I've nice to take a

1853
01:13:37,480 --> 01:13:40,740
say I said a prayer

