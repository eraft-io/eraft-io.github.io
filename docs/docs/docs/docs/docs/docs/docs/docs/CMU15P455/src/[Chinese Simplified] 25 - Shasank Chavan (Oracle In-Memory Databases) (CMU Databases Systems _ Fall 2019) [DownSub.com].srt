1
00:00:03,640 --> 00:00:17,970
[音乐]

2
00:00:20,380 --> 00:00:26,240
你没有买你的开场我听说

3
00:00:26,240 --> 00:00:29,269
可以让你过一些人过圣诞节

4
00:00:29,269 --> 00:00:36,410
的假期好吧好吧好吧

5
00:00:36,410 --> 00:00:36,980
你们怎么了

6
00:00:36,980 --> 00:00:39,710
好吧所以上周这个

7
00:00:39,710 --> 00:00:42,190
项目的课程仍然做回家 5 我们所做

8
00:00:42,190 --> 00:00:44,780
的然后继续 星期三的课我们

9
00:00:44,780 --> 00:00:47,420
会有系统杂烩和最后的

10
00:00:47,420 --> 00:00:49,579
复习，我也会宣布

11
00:00:49,579 --> 00:00:53,960
关于我孩子的兄弟会测试的结果

12
00:00:53,960 --> 00:00:56,629
，好吧，我们离我们不是两英里远，

13
00:00:56,629 --> 00:00:58,460
所以我在课结束时在外面

14
00:00:58,460 --> 00:01:00,289
星期三也好，

15
00:01:00,289 --> 00:01:01,910
在我们切换到维加斯演讲者之前，

16
00:01:01,910 --> 00:01:03,170
任何关于

17
00:01:03,170 --> 00:01:06,880
本学期剩余进展的问题对你们来说是的，

18
00:01:06,880 --> 00:01:10,340
现在你们要在同一天做

19
00:01:10,340 --> 00:01:13,090
项目，因为它应该在网站上，

20
00:01:13,090 --> 00:01:15,770
它会发送反馈给

21
00:01:15,770 --> 00:01:18,560
明天或星期三的额外信用飞行

22
00:01:18,560 --> 00:01:24,079
好吧，大家好，有任何其他问题，

23
00:01:24,079 --> 00:01:26,000
所以我们今天非常高兴

24
00:01:26,000 --> 00:01:29,780
有来自甲骨文的 Shashank 来做客座

25
00:01:29,780 --> 00:01:31,040
讲座，就像我说

26
00:01:31,040 --> 00:01:32,420
的那样，我喜欢他在这里的原因是

27
00:01:32,420 --> 00:01:34,549
因为这会让我不 硒 他们

28
00:01:34,549 --> 00:01:35,869
疯了，我没有告诉你

29
00:01:35,869 --> 00:01:37,460
关于数据库的所有这些，只是没有编造

30
00:01:37,460 --> 00:01:39,439
出来他会说哦，是的，有

31
00:01:39,439 --> 00:01:40,790
一个真正的系统，那里赚了很多钱，

32
00:01:40,790 --> 00:01:42,649
它完成了我们本学期讨论的所有事情，

33
00:01:42,649 --> 00:01:45,110
但他会

34
00:01:45,110 --> 00:01:46,430


35
00:01:46,430 --> 00:01:48,710
在内存数据库的上下文中谈论它，这不是我们

36
00:01:48,710 --> 00:01:51,079
谈论的内容，但它将

37
00:01:51,079 --> 00:01:53,090
在不同的环境中应用相同的概念

38
00:01:53,090 --> 00:01:54,770
，如果您对

39
00:01:54,770 --> 00:01:56,659
他今天谈论的事情感兴趣，这

40
00:01:56,659 --> 00:01:58,939
就是 高级班 15 7:21 将

41
00:01:58,939 --> 00:02:02,600
完全是关于下学期的 好吧 所以她

42
00:02:02,600 --> 00:02:05,479
shank 是内存数据库技术的副总裁 是

43
00:02:05,479 --> 00:02:06,890


44
00:02:06,890 --> 00:02:08,538
的 没错 所以他拥有

45
00:02:08,538 --> 00:02:10,070


46
00:02:10,070 --> 00:02:12,140
加州大学圣地亚哥分校的本科和硕士学位 并且他已经成为 Oracle

47
00:02:12,140 --> 00:02:14,660
六年 年 九年

48
00:02:14,660 --> 00:02:17,880
九年 九年 再一次像

49
00:02:17,880 --> 00:02:19,860
一个真正的家伙在系统上工作 不是

50
00:02:19,860 --> 00:02:22,920
某种营销 这是真实的

51
00:02:22,920 --> 00:02:24,330
所以一定要停下来问一些棘手的技术

52
00:02:24,330 --> 00:02:26,310
问题 这是推动他看看

53
00:02:26,310 --> 00:02:27,150
他是否真的知道 现在他说的

54
00:02:27,150 --> 00:02:29,180


55
00:02:32,330 --> 00:02:35,220
真棒，好吧，嘿伙计们，谢谢你们

56
00:02:35,220 --> 00:02:38,730
再次光临，我的名字是 Josh shank

57
00:02:38,730 --> 00:02:41,250
Yvonne，我时不时来这里，我

58
00:02:41,250 --> 00:02:43,410
猜有一个 PDL 实验室，他们来

59
00:02:43,410 --> 00:02:45,870
这里进行静修，我认为这

60
00:02:45,870 --> 00:02:48,060
就像冬天和春天 我想并且

61
00:02:48,060 --> 00:02:50,430
他很友好地

62
00:02:50,430 --> 00:02:51,600
邀请我 所以再次感谢你邀请

63
00:02:51,600 --> 00:02:54,060
我今天的演讲将围绕

64
00:02:54,060 --> 00:02:55,920
Oracle 内存中数据库的前五项创新

65
00:02:55,920 --> 00:02:58,410
所以这个演讲最初是

66
00:02:58,410 --> 00:02:59,970
给那些真正了解

67
00:02:59,970 --> 00:03:02,310
内存中数据库产品的人 我

68
00:03:02,310 --> 00:03:03,660
稍微改变了一下，让

69
00:03:03,660 --> 00:03:05,160
你们了解一下

70
00:03:05,160 --> 00:03:08,250
内存中的数据库是什么样的

71
00:03:08,250 --> 00:03:10,050


72
00:03:10,050 --> 00:03:11,580


73
00:03:11,580 --> 00:03:13,080
安迪 我通常有

74
00:03:13,080 --> 00:03:14,760
更多的幻灯片，而且我在演讲前有时间，

75
00:03:14,760 --> 00:03:16,380
所以有时我讲得太快了，

76
00:03:16,380 --> 00:03:18,540
所以只要你想来就打断我

77
00:03:18,540 --> 00:03:22,590
，好吧，让我看看我只是想

78
00:03:22,590 --> 00:03:23,580
确保我正确地跟着幻灯片走，

79
00:03:23,580 --> 00:03:25,140
好吧 gre 这是我的

80
00:03:25,140 --> 00:03:27,960
下一张幻灯片，所以我想

81
00:03:27,960 --> 00:03:30,240
从这张动机幻灯片开始 这是

82
00:03:30,240 --> 00:03:32,280
谈论实时企业需要

83
00:03:32,280 --> 00:03:36,660
在内存创新中的现在 好的 所以这

84
00:03:36,660 --> 00:03:38,670
是我目前拥有的幻灯片

85
00:03:38,670 --> 00:03:40,440
我真正想展示的是这张

86
00:03:40,440 --> 00:03:43,200
幻灯片 我们的总统

87
00:03:43,200 --> 00:03:45,030
早上发推特称，实时

88
00:03:45,030 --> 00:03:46,650
企业现在需要内存创新，

89
00:03:46,650 --> 00:03:48,960
但有人告诉

90
00:03:48,960 --> 00:03:52,490
我这太政治化了，所以我选择了这个，

91
00:03:52,490 --> 00:03:55,440
但我实际上更喜欢这个，因为

92
00:03:55,440 --> 00:03:59,100
它是真实的，实际上是真的，他

93
00:03:59,100 --> 00:04:03,570
真的说 不不 这

94
00:04:03,570 --> 00:04:05,340
实际上是弹劾审判

95
00:04:05,340 --> 00:04:07,410
开始的时候 我认为是当我们把幻灯片

96
00:04:07,410 --> 00:04:09,270
放在一起的时候 但现实是关注

97
00:04:09,270 --> 00:04:10,830
实时企业 我们的企业

98
00:04:10,830 --> 00:04:13,650
现在需要访问数据 他们是

99
00:04:13,650 --> 00:04:14,490
数据驱动的

100
00:04:14,490 --> 00:04:16,798
他们是敏捷的 他们是高效的 他们

101
00:04:16,798 --> 00:04:18,358
想要成为 能够对数据立即做出反应，

102
00:04:18,358 --> 00:04:21,120
所以你可以想象他们是一群

103
00:04:21,120 --> 00:04:22,770
适合这一类别的企业，

104
00:04:22,770 --> 00:04:25,320
就像保险公司的零售业正在

105
00:04:25,320 --> 00:04:26,970
制造过程中这些 金融

106
00:04:26,970 --> 00:04:28,380
服务人们需要实时进行欺诈

107
00:04:28,380 --> 00:04:30,690
检测 实际上这

108
00:04:30,690 --> 00:04:31,139
只是

109
00:04:31,139 --> 00:04:33,719
昨天发生的 我正在购买

110
00:04:33,719 --> 00:04:35,159
Best Buy 的一些扬声器 因为它们

111
00:04:35,159 --> 00:04:38,159
正在打折 从字面上看 在我

112
00:04:38,159 --> 00:04:40,379
购买后 我收到一条短信

113
00:04:40,379 --> 00:04:41,849
说你确定你想要 进行

114
00:04:41,849 --> 00:04:42,960
这次购买您是否进行了此次购买

115
00:04:42,960 --> 00:04:44,610
等等，因为他们立即

116
00:04:44,610 --> 00:04:46,650
知道我不是那种一时冲动

117
00:04:46,650 --> 00:04:49,469
购买 500

118
00:04:49,469 --> 00:04:50,789


119
00:04:50,789 --> 00:04:54,150
美元的人，这不是我，所以无论如何那是实时的，并且

120
00:04:54,150 --> 00:04:57,029
所以为了实现这一点，我们需要做

121
00:04:57,029 --> 00:04:58,919
很多事情，所以我们看到

122
00:04:58,919 --> 00:05:00,120
了来自

123
00:05:00,120 --> 00:05:02,639
企业公司的需求，所以

124
00:05:02,639 --> 00:05:06,029
实际上是什么使这成为可能，所以如果你

125
00:05:06,029 --> 00:05:08,250
看看硬件趋势，你会

126
00:05:08,250 --> 00:05:10,740
开始有更大更便宜的 memory

127
00:05:10,740 --> 00:05:13,439
so DRAM 每个人都熟悉内存

128
00:05:13,439 --> 00:05:15,300
P man 我不知道你们中有多少人

129
00:05:15,300 --> 00:05:17,340
熟悉持久内存

130
00:05:17,340 --> 00:05:19,289


131
00:05:19,289 --> 00:05:21,210
更大的

132
00:05:21,210 --> 00:05:24,150
CPU 缓存，所以现在我们谈论的是

133
00:05:24,150 --> 00:05:27,180
英特尔最新处理器上的 32 兆字节共享 l3 缓存，

134
00:05:27,180 --> 00:05:29,699
您拥有更大

135
00:05:29,699 --> 00:05:32,969
的多核处理器，因此 24 核与

136
00:05:32,969 --> 00:05:36,270
英特尔级联 Lake 更大的 SIM D 矢量

137
00:05:36,270 --> 00:05:37,139
处理数年

138
00:05:37,139 --> 00:05:38,639
展示知道 Cindy 是什么的人们

139
00:05:38,639 --> 00:05:40,560
你听说在单

140
00:05:40,560 --> 00:05:42,000
条指令多 ADA 之前，很好，

141
00:05:42,000 --> 00:05:45,839
所以现在你有 512 位 sim D 寄存器

142
00:05:45,839 --> 00:05:47,899
，可以在一个更快的周期内基本上使你的操作

143
00:05:47,899 --> 00:05:49,800
在接收器中瘫痪

144
00:05:49,800 --> 00:05:52,620
网络，所以你有 100

145
00:05:52,620 --> 00:05:55,050


146
00:05:55,050 --> 00:05:57,110
Gb/s 使用

147
00:05:57,110 --> 00:05:58,229
InfiniBand

148
00:05:58,229 --> 00:06:00,539
Numa 架构，因此您现在

149
00:06:00,539 --> 00:06:01,919
必须专注于本地内存

150
00:06:01,919 --> 00:06:03,479
与远程内存 有很多

151
00:06:03,479 --> 00:06:06,270
因素持久内存

152
00:06:06,270 --> 00:06:08,969
在我看来真的是最大的，在 Oracle 和

153
00:06:08,969 --> 00:06:11,129
我们团队的很多人我们认为是一个重要的时间

154
00:06:11,129 --> 00:06:14,219
内存技术领域的游戏改变者

155
00:06:14,219 --> 00:06:16,439
所以持久内存基本上

156
00:06:16,439 --> 00:06:19,139
就像 DRAM 就像内存一样，除了

157
00:06:19,139 --> 00:06:21,680
它大得多，大约

158
00:06:21,680 --> 00:06:24,479
是 DRAM 大小的 3 倍

159
00:06:24,479 --> 00:06:26,310
它具有可用性，因为它是

160
00:06:26,310 --> 00:06:28,500
持久的 你拔掉你正在

161
00:06:28,500 --> 00:06:30,060
做的插头 你把插头放回数据中

162
00:06:30,060 --> 00:06:31,830
他们仍然坐在这些

163
00:06:31,830 --> 00:06:34,500
持久内存中 变暗而且它

164
00:06:34,500 --> 00:06:37,500
很快 它不比 DRAM 快 但

165
00:06:37,500 --> 00:06:40,379
它比闪存快得多 所以它有

166
00:06:40,379 --> 00:06:42,690
许多非常酷的品质和所有

167
00:06:42,690 --> 00:06:44,050
这些东西的结合

168
00:06:44,050 --> 00:06:47,440
帮助我们朝着

169
00:06:47,440 --> 00:06:51,110
满足实时企业

170
00:06:51,110 --> 00:06:52,289
的要求迈进

171
00:06:52,289 --> 00:06:56,379


172
00:06:56,379 --> 00:06:58,569


173
00:06:58,569 --> 00:07:00,159


174
00:07:00,159 --> 00:07:06,190
为工作做项目完全没问题

175
00:07:06,190 --> 00:07:08,500
，如果我们有不同的层，我们在内存中的哪里有

176
00:07:08,500 --> 00:07:11,259
那么

177
00:07:11,259 --> 00:07:13,690
顶层是应用层，这

178
00:07:13,690 --> 00:07:15,430
是你关心即时

179
00:07:15,430 --> 00:07:17,440
响应时间的地方，所以想象你有一个

180
00:07:17,440 --> 00:07:19,240
应用程序，你会 将此

181
00:07:19,240 --> 00:07:21,699
数据库直接链接到您的应用程序

182
00:07:21,699 --> 00:07:23,590
共享相同的进程基础内存

183
00:07:23,590 --> 00:07:25,539
空间所有内容都共享因此您

184
00:07:25,539 --> 00:07:27,550
将获得即时响应时间这

185
00:07:27,550 --> 00:07:29,650
非常重要如果您像

186
00:07:29,650 --> 00:07:31,240
石油一样 TP 敏感，并且您想

187
00:07:31,240 --> 00:07:32,860
非常快速地进行插入或非常快地读取

188
00:07:32,860 --> 00:07:34,840
您只是获得了此特定键的值，

189
00:07:34,840 --> 00:07:37,479
因此 10 倍

190
00:07:37,479 --> 00:07:39,460
10 年前出现是内存中的

191
00:07:39,460 --> 00:07:41,229
第一个，我认为它是

192
00:07:41,229 --> 00:07:43,539
第一个 在内存数据库中，我认为这

193
00:07:43,539 --> 00:07:45,280
就是 20 年前，哦，不，所以

194
00:07:45,280 --> 00:07:49,330
Chris 96 还可以，时间足够长了，所以

195
00:07:49,330 --> 00:07:51,639
那是应用层数据库层中的 10 倍

196
00:07:51,639 --> 00:07:53,590
我要

197
00:07:53,590 --> 00:07:55,330
谈论的就是我们

198
00:07:55,330 --> 00:07:58,000
在内存中拥有 Oracle 数据库的地方 这是我们

199
00:07:58,000 --> 00:07:59,800
真正关心分析的地方，但

200
00:07:59,800 --> 00:08:01,900
也会混合工作负载性能，它

201
00:08:01,900 --> 00:08:04,389
直接嵌入到实际工作的

202
00:08:04,389 --> 00:08:06,789
企业数据库中，然后

203
00:08:06,789 --> 00:08:08,289


204
00:08:08,289 --> 00:08:09,550
您在查看分析时每秒处理数十亿行的内容，

205
00:08:09,550 --> 00:08:12,400
然后还有存储

206
00:08:12,400 --> 00:08:14,319
层 所以我也将讨论这个问题

207
00:08:14,319 --> 00:08:16,090
，存储主席意味着

208
00:08:16,090 --> 00:08:17,770
数据实际上驻留在何处，无论它是

209
00:08:17,770 --> 00:08:19,900
在闪存上的某个持久存储的磁盘上，

210
00:08:19,900 --> 00:08:22,419
还是接近于基本上

211
00:08:22,419 --> 00:08:23,680
持久的存储

212
00:08:23,680 --> 00:08:25,479
是的，将应用程序存储到您的数据库

213
00:08:25,479 --> 00:08:27,610
层存储层，我将主要

214
00:08:27,610 --> 00:08:30,130
讨论数据库层和存储

215
00:08:30,130 --> 00:08:33,820
层

216
00:08:33,820 --> 00:08:35,770


217
00:08:35,770 --> 00:08:40,270


218
00:08:40,270 --> 00:08:44,190
Ken 好的，所以在我们拥有

219
00:08:44,190 --> 00:08:46,180
下一张幻灯片中的更平静的数据库之前，

220
00:08:46,180 --> 00:08:48,579
我们基本上拥有行数据库

221
00:08:48,579 --> 00:08:51,430
如果您关心交易，行明智的数据库非常棒

222
00:08:51,430 --> 00:08:53,740


223
00:08:53,740 --> 00:08:56,890
，例如您的 ATM 机，

224
00:08:56,890 --> 00:08:57,880
您有 ATM 卡，

225
00:08:57,880 --> 00:09:00,190
您想要鸭子 25 美元 20 美元

226
00:09:00,190 --> 00:09:02,680
帐户是您正在申请的交易

227
00:09:02,680 --> 00:09:04,389
您将快速

228
00:09:04,389 --> 00:09:07,029
搜索这个庞大的数据库，其中包含

229
00:09:07,029 --> 00:09:09,550
数百万或数十亿的用户，而不是

230
00:09:09,550 --> 00:09:11,170
数十亿，但肯定是数百万，然后

231
00:09:11,170 --> 00:09:14,170
搜索您的特定帐户 找到

232
00:09:14,170 --> 00:09:16,660
您的余额并从中扣除 20

233
00:09:16,660 --> 00:09:18,490
美元 就像寻找特定的行

234
00:09:18,490 --> 00:09:21,519
和潜在的顶部可能

235
00:09:21,519 --> 00:09:23,500
访问该行中的多列，

236
00:09:23,500 --> 00:09:25,480
这对它的

237
00:09:25,480 --> 00:09:27,550
事务处理非常有用，因此行基数为

238
00:09:27,550 --> 00:09:30,279
v 非常适合访问特定行

239
00:09:30,279 --> 00:09:32,500
，然后触摸

240
00:09:32,500 --> 00:09:34,300
该领域内的多列，因此作为示例，

241
00:09:34,300 --> 00:09:36,880
如果您正在运行此查询，例如

242
00:09:36,880 --> 00:09:39,940
从我的表中选择第 4 列，您需要

243
00:09:39,940 --> 00:09:42,430
做的是基本上必须处理每一

244
00:09:42,430 --> 00:09:45,610
行并跳转到 第 4 列使其

245
00:09:45,610 --> 00:09:48,699
正确，所以问题在于，当涉及到

246
00:09:48,699 --> 00:09:50,980
分析时，您基本上是在访问

247
00:09:50,980 --> 00:09:53,110
每一行，但最重要的是，

248
00:09:53,110 --> 00:09:55,720
您将通过调用调用它们

249
00:09:55,720 --> 00:09:57,550
来访问列来访问多个缓存行以到达您要访问

250
00:09:57,550 --> 00:09:59,709
的列

251
00:09:59,709 --> 00:10:01,480
如果您想

252
00:10:01,480 --> 00:10:03,519
访问特定行并访问

253
00:10:03,519 --> 00:10:08,860
行格式的特定列，那么它再次很棒 现在列行

254
00:10:08,860 --> 00:10:11,740
格式对于分析来说很快 好的

255
00:10:11,740 --> 00:10:13,990
分析是您说我实际上

256
00:10:13,990 --> 00:10:17,139
关心访问所有行的地方，但我

257
00:10:17,139 --> 00:10:20,470
只是 对某些列感兴趣，

258
00:10:20,470 --> 00:10:23,230
所以在这种情况下，现在如果我只想

259
00:10:23,230 --> 00:10:25,360
说从我的表中选择第 4 列，

260
00:10:25,360 --> 00:10:29,050
我需要做的就是访问第 4 列，

261
00:10:29,050 --> 00:10:31,180
好的，数据存储在

262
00:10:31,180 --> 00:10:34,060
连续内存中的列中，这里的每一列都

263
00:10:34,060 --> 00:10:37,600
在连续的 p 中 iece of memory

264
00:10:37,600 --> 00:10:38,889
到目前为止的任何问题

265
00:10:38,889 --> 00:10:41,529
行格式和列或格式之间的区别 我们

266
00:10:41,529 --> 00:10:48,550
不做 ok

267
00:10:48,550 --> 00:10:50,560


268
00:10:50,560 --> 00:10:53,110


269
00:10:53,110 --> 00:10:55,660
只是有一个

270
00:10:55,660 --> 00:10:56,259
或另一个

271
00:10:56,259 --> 00:10:58,720
这对企业公司来说真的不可行

272
00:10:58,720 --> 00:11:00,250
企业

273
00:11:00,250 --> 00:11:01,660
基本上对混合

274
00:11:01,660 --> 00:11:02,800
工作负载更感兴趣 有时是运行

275
00:11:02,800 --> 00:11:03,910
分析 有时是统治

276
00:11:03,910 --> 00:11:06,819
事务 有时它可能

277
00:11:06,819 --> 00:11:08,079
非常混合 有时他们运行临时

278
00:11:08,079 --> 00:11:10,510
查询 有时使用巨大的查询

279
00:11:10,510 --> 00:11:11,130


280
00:11:11,130 --> 00:11:13,980
简单的查询所以它是一个混合所以我们

281
00:11:13,980 --> 00:11:16,140
基本上决定你

282
00:11:16,140 --> 00:11:17,790
不是你不能选择一种格式我们

283
00:11:17,790 --> 00:11:19,500
基本上想要两种格式

284
00:11:19,500 --> 00:11:20,880
所以这就是为什么我们有这个叫做

285
00:11:20,880 --> 00:11:24,090
双格式架构的东西所以有了双

286
00:11:24,090 --> 00:11:25,290
格式架构我们 基本上

287
00:11:25,290 --> 00:11:28,110
保持传统的烤肉或

288
00:11:28,110 --> 00:11:30,230
位于缓冲区缓存中的烤肉

289
00:11:30,230 --> 00:11:33,090
以及位于内存中的柱状表示，

290
00:11:33,090 --> 00:11:35,670
好吧我们 保持

291
00:11:35,670 --> 00:11:38,640
两者并且它们同时

292
00:11:38,640 --> 00:11:40,740
处于活动状态并且彼此一致

293
00:11:40,740 --> 00:11:43,500
所有的大脑都进入优化器

294
00:11:43,500 --> 00:11:45,720
优化器决定何时看到

295
00:11:45,720 --> 00:11:48,690
查询它应该采用哪条路径

296
00:11:48,690 --> 00:11:50,520
例如如果它看到一个查询说我

297
00:11:50,520 --> 00:11:52,470
真的想要去 这个特定的

298
00:11:52,470 --> 00:11:54,960
行这个键并提取那个值，

299
00:11:54,960 --> 00:11:57,540
我有这个旧的 TP 索引，

300
00:11:57,540 --> 00:11:59,280
优化器会说去缓冲区

301
00:11:59,280 --> 00:12:01,590
缓存并为它获取索引块

302
00:12:01,590 --> 00:12:03,570
并读取该行，这就是

303
00:12:03,570 --> 00:12:05,760
它获得该行的速度，如果 查询是一个

304
00:12:05,760 --> 00:12:08,010
分析查询，你正在做

305
00:12:08,010 --> 00:12:09,810
某种疯狂的聚合或分组，

306
00:12:09,810 --> 00:12:11,490
某些连接或任何

307
00:12:11,490 --> 00:12:17,760
它会使用列存储，所以

308
00:12:17,760 --> 00:12:21,150
当我们在内存中开发这个数据库时，

309
00:12:21,150 --> 00:12:23,670
我们将它本地构建到

310
00:12:23,670 --> 00:12:25,380
数据库所以它不是一个单独的存储

311
00:12:25,380 --> 00:12:27,720
引擎它是现有存储引擎的一部分

312
00:12:27,720 --> 00:12:30,150
它基本上只是

313
00:12:30,150 --> 00:12:32,190
将颜色表示视为

314
00:12:32,190 --> 00:12:34,320
一个索引驻留在

315
00:12:34,320 --> 00:12:52,440
内存中的索引好的任何快速问题所以如果它

316
00:12:52,440 --> 00:12:55,830
取决于写入工作量的百分比，

317
00:12:55,830 --> 00:12:58,350
所以我

318
00:12:58,350 --> 00:12:59,910
将在第二部分介绍我们如何处理

319
00:12:59,910 --> 00:13:02,820
写入或更新或其他任何内容或 DML

320
00:13:02,820 --> 00:13:05,730
，如果您正在这样做，假设

321
00:13:05,730 --> 00:13:07,920
您的工作量的 1% 是正确的

322
00:13:07,920 --> 00:13:09,750
这不是问题 基本上是

323
00:13:09,750 --> 00:13:11,820
混合工作负载

324
00:13:11,820 --> 00:13:14,550
当您开始

325
00:13:14,550 --> 00:13:15,960
达到更高的百分比或

326
00:13:15,960 --> 00:13:17,760
大约 2340% 时，10% 甚至 5% 到 10%

327
00:13:17,760 --> 00:13:19,710


328
00:13:19,710 --> 00:13:21,960
都可以 你

329
00:13:21,960 --> 00:13:23,100
基本上是糟糕的我很抱歉我不知道

330
00:13:23,100 --> 00:13:23,529
有多

331
00:13:23,529 --> 00:13:25,509
先进啊你知道我可能你

332
00:13:25,509 --> 00:13:27,810
可能正在运行计时器是的

333
00:13:27,810 --> 00:13:29,589
好吧

334
00:13:29,589 --> 00:13:31,290
所以你所做的是你基本上

335
00:13:31,290 --> 00:13:33,310
保持正确的你 重新

336
00:13:33,310 --> 00:13:34,749
维护这个列存储和

337
00:13:34,749 --> 00:13:36,759
行存储，这可能会成为

338
00:13:36,759 --> 00:13:39,759
问题，好吧，所以我将描述我们如何

339
00:13:39,759 --> 00:13:43,600
非常有效地处理下周的任何其他问题，很好，

340
00:13:43,600 --> 00:13:52,899
很酷，我们

341
00:13:52,899 --> 00:13:54,689
将所有内容都移开，很棒，

342
00:13:54,689 --> 00:13:57,610
好吧，让我们深入了解一些

343
00:13:57,610 --> 00:13:59,410
细节，好吧 就浩而言 我们存储

344
00:13:59,410 --> 00:14:02,350
这些数据，所以你在这里看到的是一个

345
00:14:02,350 --> 00:14:05,439
表，我们将数据存储在一个非常不纯的

346
00:14:05,439 --> 00:14:08,529
内存中冷静地表示所以销售

347
00:14:08,529 --> 00:14:11,829
表继续坐在磁盘上不会

348
00:14:11,829 --> 00:14:14,170
改变它就像你们知道的那样

349
00:14:14,170 --> 00:14:16,240
它可以被拉出 进入

350
00:14:16,240 --> 00:14:19,120
缓冲区缓存，如果它被访问

351
00:14:19,120 --> 00:14:21,819
不会改变，但你要做的是，如果你

352
00:14:21,819 --> 00:14:25,600
保持这个表进入内存，我们

353
00:14:25,600 --> 00:14:28,029
基本上会把它带入内存，

354
00:14:28,029 --> 00:14:30,850
我们将把行转换成

355
00:14:30,850 --> 00:14:33,279
列，然后存储列 到

356
00:14:33,279 --> 00:14:36,240
连续的内存块中

357
00:14:36,240 --> 00:14:39,129
好的 磁盘格式没有改变

358
00:14:39,129 --> 00:14:41,800
我们是 Oracle 所以我们支持所有

359
00:14:41,800 --> 00:14:45,160
平台 你可以在

360
00:14:45,160 --> 00:14:47,350
任何级别的内存中启用 可以在表空间级别

361
00:14:47,350 --> 00:14:50,860
在列级别的表中启用，即使你

362
00:14:50,860 --> 00:14:53,259
可以指定任何级别和 你唯一

363
00:14:53,259 --> 00:14:54,790
需要做的就是告诉我们

364
00:14:54,790 --> 00:14:58,149
你想为

365
00:14:58,149 --> 00:15:01,629
你的列存储保留多少内存 好的，因为我将

366
00:15:01,629 --> 00:15:02,860
谈论

367
00:15:02,860 --> 00:15:04,899
我们正在研究的一些未来的东西，但这是你唯一的

368
00:15:04,899 --> 00:15:06,339
事情 真正要做的是 告诉我们

369
00:15:06,339 --> 00:15:09,399
现在有多少内存，如果你

370
00:15:09,399 --> 00:15:12,939
深入了解我们，好吧，我们基本上

371
00:15:12,939 --> 00:15:15,399


372
00:15:15,399 --> 00:15:18,250
在内存压缩单元中的称为 IMC 用户的东西中屏蔽了这些

373
00:15:18,250 --> 00:15:19,870


374
00:15:19,870 --> 00:15:22,990


375
00:15:22,990 --> 00:15:25,209
行 一百万到一

376
00:15:25,209 --> 00:15:28,809
百万行，在每个 IMC 中，您

377
00:15:28,809 --> 00:15:31,589
拥有该表的所有列，

378
00:15:31,589 --> 00:15:34,540
因此在此销售表中，您

379
00:15:34,540 --> 00:15:37,490
有员工 ID 名称部门工资，

380
00:15:37,490 --> 00:15:41,149
我们现在也有此行 ID 列，

381
00:15:41,149 --> 00:15:42,950
这非常重要

382
00:15:42,950 --> 00:15:45,890
有点小技巧，我们将行

383
00:15:45,890 --> 00:15:50,240
ID 列映射到

384
00:15:50,240 --> 00:15:52,940
磁盘上这些行的实际位置，这是这里的

385
00:15:52,940 --> 00:15:56,360
底部，所以在磁盘上我们基本上

386
00:15:56,360 --> 00:15:58,040
将数据存储在

387
00:15:58,040 --> 00:16:00,320
基本上是连续块的

388
00:16:00,320 --> 00:16:03,950
范围中，这个范围表示范围编号 13 作为

389
00:16:03,950 --> 00:16:06,950
块 20 到 120 范围编号 14 作为

390
00:16:06,950 --> 00:16:09,020
块到 80 到 180 - 在每个块中

391
00:16:09,020 --> 00:16:11,029
，你知道一些你知道

392
00:16:11,029 --> 00:16:15,709
数百或数千行，所以

393
00:16:15,709 --> 00:16:20,000
这个 imc U 直接映射到

394
00:16:20,000 --> 00:16:23,120
关于这个的物理位置以及为什么这

395
00:16:23,120 --> 00:16:25,190
很重要是因为当你

396
00:16:25,190 --> 00:16:28,399
对一行进行修改时，很容易

397
00:16:28,399 --> 00:16:31,040
说出我看到的那个映射到哪个，

398
00:16:31,040 --> 00:16:34,130
我将通过另一张幻灯片

399
00:16:34,130 --> 00:16:35,720
讨论我们如何利用它 我们

400
00:16:35,720 --> 00:16:38,420
谈论 DML 所以这里唯一要说明的另一

401
00:16:38,420 --> 00:16:41,420
点是你可以指定你

402
00:16:41,420 --> 00:16:44,000
想如何压缩这个列，这样你就知道

403
00:16:44,000 --> 00:16:45,050
你认为你们还没有讨论过

404
00:16:45,050 --> 00:16:47,000
压缩或不同的数据

405
00:16:47,000 --> 00:16:48,380
格式，你们以前听说过字典

406
00:16:48,380 --> 00:16:50,870
编码或 前缀编码很好，

407
00:16:50,870 --> 00:16:52,520
我想我有几张幻灯片，

408
00:16:52,520 --> 00:16:54,230
但是您可以指定

409
00:16:54,230 --> 00:16:55,579
您希望限制在内存上的压缩级别，

410
00:16:55,579 --> 00:16:58,070
这样您就可以将其带入内存

411
00:16:58,070 --> 00:16:59,360
并按您想要的方式压缩它，

412
00:16:59,360 --> 00:17:02,810
这样就可以了 我们如何存储

413
00:17:02,810 --> 00:17:04,490
东西，因为我很震惊 这里是

414
00:17:04,490 --> 00:17:07,040
关于压缩的幻灯片 所以我们如何实际

415
00:17:07,040 --> 00:17:10,520
存储这些数据 好吧 想象一下这是

416
00:17:10,520 --> 00:17:12,140
你的列 好吧 这是你的

417
00:17:12,140 --> 00:17:14,420
未压缩数据 我有猫猫

418
00:17:14,420 --> 00:17:16,550
鱼鱼马马马马狗

419
00:17:16,550 --> 00:17:20,270
ca 等好吧，它实际上并没有排序 我

420
00:17:20,270 --> 00:17:22,490
在这里有狗，这里有猫，但这

421
00:17:22,490 --> 00:17:24,770
只是我的例子，所以我们做的第一件事

422
00:17:24,770 --> 00:17:27,589
是我们对它进行字典编码，因此

423
00:17:27,589 --> 00:17:29,929
字典编码意味着它

424
00:17:29,929 --> 00:17:33,020
识别该

425
00:17:33,020 --> 00:17:36,110
列中的不同符号并提取出那些不同的符号

426
00:17:36,110 --> 00:17:38,630
和 然后对这些不同的符号进行排序

427
00:17:38,630 --> 00:17:41,720
，然后为它们分配一个代码，这样你

428
00:17:41,720 --> 00:17:44,150
就有了 cat dog fish horse 这就是你在本列中的所有内容

429
00:17:44,150 --> 00:17:47,120
我对它们进行排序

430
00:17:47,120 --> 00:17:51,030
并在 0 1 2 & 3 处对它们签名，

431
00:17:51,030 --> 00:17:53,340
然后你只需要替换

432
00:17:53,340 --> 00:17:57,090
猫猫鱼鱼等的值和代码

433
00:17:57,090 --> 00:17:58,860
本身，我们

434
00:17:58,860 --> 00:18:01,530
更进一步，我们实际上对这些代码进行了位打包

435
00:18:01,530 --> 00:18:03,330
，因为它们只有四个不同的

436
00:18:03,330 --> 00:18:05,340
符号，所以我只需要两个位

437
00:18:05,340 --> 00:18:07,740
来表示这些符号中的每一个，

438
00:18:07,740 --> 00:18:12,810
所以 0 0  0 0 1 0 等等 到目前为止

439
00:18:12,810 --> 00:18:15,180
一切顺利 所以这是字典编码

440
00:18:15,180 --> 00:18:18,030
我们接下来要做的是我们口头应用或

441
00:18:18,030 --> 00:18:20,430
运行长度编码 运行长度编码

442
00:18:20,430 --> 00:18:22,200
基本上是说让我看看我是否可以

443
00:18:22,200 --> 00:18:25,590
识别相同符号和

444
00:18:25,590 --> 00:18:28,500
数量的运行  次并将所有结束

445
00:18:28,500 --> 00:18:31,110
副本替换为单个副本以及

446
00:18:31,110 --> 00:18:34,980
运行写入帐户，因此在这里您会

447
00:18:34,980 --> 00:18:37,140
注意到我们有 Cat Cat 和 fish fish 或者

448
00:18:37,140 --> 00:18:39,360
更确切地说是零零零零和

449
00:18:39,360 --> 00:18:41,700
零零零，我可以

450
00:18:41,700 --> 00:18:44,100
用零零和一替换它 零，然后

451
00:18:44,100 --> 00:18:47,250
我跑过去 有这个小

452
00:18:47,250 --> 00:18:50,520
按钮 是的，你很完美，

453
00:18:50,520 --> 00:18:51,900
所以你可以看到他们的名字基本上

454
00:18:51,900 --> 00:18:54,090
保持了一些运行，这些运行只是标识

455
00:18:54,090 --> 00:18:55,350


456
00:18:55,350 --> 00:18:57,630
到目前为止这些符号有多少运行那么好，

457
00:18:57,630 --> 00:19:02,010
然后我们接受它 更进一步，我们

458
00:19:02,010 --> 00:19:04,230
应用了一种称为 zip 或 oracle

459
00:19:04,230 --> 00:19:07,800
zip 本地 zip 的东西，它

460
00:19:07,800 --> 00:19:10,320
几乎是一种奇特的字典编码

461
00:19:10,320 --> 00:19:12,690
算法，但它非常棒，因为

462
00:19:12,690 --> 00:19:16,260
它非常简单，而且

463
00:19:16,260 --> 00:19:18,690
解压缩对硬件友好

464
00:19:18,690 --> 00:19:20,010
在描述之前我不会详细介绍

465
00:19:20,010 --> 00:19:21,330
这里发生了什么，所以它

466
00:19:21,330 --> 00:19:25,560
正在做的是

467
00:19:25,560 --> 00:19:28,380
现在在编码的值中找到模式，所以这里你

468
00:19:28,380 --> 00:19:32,040
有 0 0 1 0 1 1 0 1 并且你看到

469
00:19:32,040 --> 00:19:35,460
相同的模式 0 0 1 0 1 1 0 1 所以

470
00:19:35,460 --> 00:19:39,000
你会 现在用单个代码 0 替换一组 8 位

471
00:19:39,000 --> 00:19:42,420
，或者唱一点

472
00:19:42,420 --> 00:19:45,630
0，然后将 0 1 替换为 1，现在

473
00:19:45,630 --> 00:19:47,760
您已经进一步压缩了它，因此

474
00:19:47,760 --> 00:19:48,870
您正在构建另一个

475
00:19:48,870 --> 00:19:52,280
字典 到目前为止的编码流

476
00:19:52,280 --> 00:19:55,770
很好，所以这就是我们所做的，

477
00:19:55,770 --> 00:19:57,450
我们把它带到了一种极端，

478
00:19:57,450 --> 00:19:59,460
然后你实际上可以

479
00:19:59,460 --> 00:20:01,740
把它放在上面，你把 ZZ Lib 放在它上面或者 B zip

480
00:20:01,740 --> 00:20:03,539
好的在它上面的更高级别

481
00:20:03,539 --> 00:20:06,409


482
00:20:06,649 --> 00:20:08,999
好吧，我想谈论的另一种压缩形式

483
00:20:08,999 --> 00:20:10,200
是称为

484
00:20:10,200 --> 00:20:12,840
前缀编码的东西，所以我们谈到了那个

485
00:20:12,840 --> 00:20:16,259
字典，写了一个猫狗马等等，

486
00:20:16,259 --> 00:20:19,590
注意它们是如何排序好的，所以

487
00:20:19,590 --> 00:20:22,109
一旦排序，你实际上可以

488
00:20:22,109 --> 00:20:25,080
从相邻的符号中删除一个公共前缀

489
00:20:25,080 --> 00:20:27,330
和 将它们分开存储，所以

490
00:20:27,330 --> 00:20:29,729
我在这本字典中的例子被

491
00:20:29,729 --> 00:20:32,940
使用了有用的有用的用处

492
00:20:32,940 --> 00:20:36,210
等等，它们都用过，但

493
00:20:36,210 --> 00:20:37,830
有些符号实际上可以受益于

494
00:20:37,830 --> 00:20:40,379
更有用的东西，所以我们

495
00:20:40,379 --> 00:20:42,299
要做的就是我们基本上会 出来也许

496
00:20:42,299 --> 00:20:44,820
像一个 bl  ock 八个符号，然后

497
00:20:44,820 --> 00:20:46,379
从这八个符号中，我们将在本示例中找到这八个符号

498
00:20:46,379 --> 00:20:48,330
的公共前缀

499
00:20:48,330 --> 00:20:49,859


500
00:20:49,859 --> 00:20:53,220


501
00:20:53,220 --> 00:20:56,309


502
00:20:56,309 --> 00:20:59,070
前缀以及

503
00:20:59,070 --> 00:21:01,320
第一个符号的空后缀和第二个符号的

504
00:21:01,320 --> 00:21:03,749
D 然后下一个

505
00:21:03,749 --> 00:21:07,289
我们将使用有用的因为这里的第三个

506
00:21:07,289 --> 00:21:09,929
符号是有用的并且相同的东西

507
00:21:09,929 --> 00:21:12,330
然后我们抓取后缀所以这

508
00:21:12,330 --> 00:21:15,539
只是给你一些 到目前为止，更多的压缩

509
00:21:15,539 --> 00:21:18,359
如此好，这东西的问题

510
00:21:18,359 --> 00:21:19,710
是以下正确的

511
00:21:19,710 --> 00:21:22,409
你必须解压缩它，这可能

512
00:21:22,409 --> 00:21:23,129
需要一些时间

513
00:21:23,129 --> 00:21:27,029
你不能只指向使用和 D

514
00:21:27,029 --> 00:21:28,889
因为你必须在

515
00:21:28,889 --> 00:21:30,869
某个时候将它们缝合并返回 对于任何

516
00:21:30,869 --> 00:21:33,450
操作员想要实际符号的任何操作员，因此

517
00:21:33,450 --> 00:21:35,179
存在与

518
00:21:35,179 --> 00:21:37,979
压缩然后解压缩相关的成本，

519
00:21:37,979 --> 00:21:49,950
因此对于 com

520
00:21:49,950 --> 00:21:52,889
我们有专门的格式，我们

521
00:21:52,889 --> 00:21:54,989
喜欢我们知道格式是什么 您

522
00:21:54,989 --> 00:21:56,399
不必解压缩它我们有一些

523
00:21:56,399 --> 00:21:57,059
tric  ks 也

524
00:21:57,059 --> 00:21:58,379
喜欢

525
00:21:58,379 --> 00:22:00,389
例如前缀编码的字典编码我们有

526
00:22:00,389 --> 00:22:02,789
使用 sim D 的技巧，允许

527
00:22:02,789 --> 00:22:04,139
您在进行扫描时不必将东西重新拼接

528
00:22:04,139 --> 00:22:05,340


529
00:22:05,340 --> 00:22:08,220


530
00:22:08,220 --> 00:22:10,710
在一起 有一个非常像字典编码的压缩器，

531
00:22:10,710 --> 00:22:12,210
但它可以

532
00:22:12,210 --> 00:22:15,330
跨多行运行，而且它要复杂得多，

533
00:22:15,330 --> 00:22:16,590
所以当你

534
00:22:16,590 --> 00:22:17,040
实际上

535
00:22:17,040 --> 00:22:18,990
必须投影时，这是一个复杂的

536
00:22:18,990 --> 00:22:20,280
拼接算法，可以将它

537
00:22:20,280 --> 00:22:22,040
重新组合在一起

538
00:22:22,040 --> 00:22:24,020


539
00:22:24,020 --> 00:22:27,210
我们讨论了如何

540
00:22:27,210 --> 00:22:30,270
将数据导入内存 我们讨论

541
00:22:30,270 --> 00:22:32,460
了如何对其进行格式化和压缩

542
00:22:32,460 --> 00:22:34,020
现在我们将讨论

543
00:22:34,020 --> 00:22:35,760
如何扫描 我们如何实际使用这些数据

544
00:22:35,760 --> 00:22:37,470
以及实际快速扫描 我们如何

545
00:22:37,470 --> 00:22:39,720
达到数十亿 当您查看行存储中的缓冲区缓存

546
00:22:39,720 --> 00:22:41,070
时，每秒行数与每秒数百万行，

547
00:22:41,070 --> 00:22:42,450


548
00:22:42,450 --> 00:22:42,990


549
00:22:42,990 --> 00:22:45,360
因此这就是 sim D 出现的地方，

550
00:22:45,360 --> 00:22:47,340
所以对于那些不知道的人来说，sim D 再次

551
00:22:47,340 --> 00:22:48,570
代表单指令 抽取

552
00:22:48,570 --> 00:22:52,020
多个数据，它所做的是

553
00:22:52,020 --> 00:22:55,440
现在大多数现代进程的

554
00:22:55,440 --> 00:22:57,930
最后一个我不知道 15 20 年

555
00:22:57,930 --> 00:23:02,010
也许从 96 年开始我认为

556
00:23:02,010 --> 00:23:05,640
处理器中有一个向量 一个向量化

557
00:23:05,640 --> 00:23:08,190
单元，它们非常胖 寄存器

558
00:23:08,190 --> 00:23:09,900
，它们不仅有那些胖

559
00:23:09,900 --> 00:23:11,520
寄存器，它们有一个序列，而且

560
00:23:11,520 --> 00:23:14,100
它们有一个指令集，可以

561
00:23:14,100 --> 00:23:15,450
应用于那些寄存器寄存器

562
00:23:15,450 --> 00:23:18,480
，允许你瘫痪数据

563
00:23:18,480 --> 00:23:21,060
操作，所以让我们通过一个

564
00:23:21,060 --> 00:23:23,040
例子来清楚地说明你

565
00:23:23,040 --> 00:23:24,870
有 再次在您的列存储中，您

566
00:23:24,870 --> 00:23:27,080
有一个名为 state right 的列，并且

567
00:23:27,080 --> 00:23:30,510
您的查询在加利福尼亚州销售良好，

568
00:23:30,510 --> 00:23:33,300
所以您要做的就是

569
00:23:33,300 --> 00:23:37,430
将 state 列放入寄存器，

570
00:23:37,430 --> 00:23:39,690
现在你们我们刚刚谈到了

571
00:23:39,690 --> 00:23:41,940
字典编码，所以这些 状态

572
00:23:41,940 --> 00:23:44,400
列都可以打包成多少

573
00:23:44,400 --> 00:23:49,010
位 你们认为思维敏捷的人

574
00:23:51,290 --> 00:23:54,090
完全没问题 这是一个很好的答案是

575
00:23:54,090 --> 00:23:56,280
对的 所以你得到了五位或

576
00:23:56,280 --> 00:23:59,730
六位 谢谢六位 所以六位

577
00:23:59,730 --> 00:24:02,310
来了 在这里，但是你有一个

578
00:24:02,310 --> 00:24:06,570
设置 512 位的寄存器，所以我可以引入其中的 64

579
00:24:06,570 --> 00:24:08,400
个，假设它们都是 8 位，

580
00:24:08,400 --> 00:24:11,910
让我们说对了，我可以在

581
00:24:11,910 --> 00:24:14,700
512 位寄存器中引入 64 64 个状态可以

582
00:24:14,700 --> 00:24:15,630
一次加载，

583
00:24:15,630 --> 00:24:17,970
这是一条指令

584
00:24:17,970 --> 00:24:19,710
循环数取决于它是否在

585
00:24:19,710 --> 00:24:22,380
您的 CPU 缓存中，但让我们假设

586
00:24:22,380 --> 00:24:24,420
它在您的 CPU 缓存中没问题，所以这是一个

587
00:24:24,420 --> 00:24:27,870
循环我已将它们加载到此处

588
00:24:27,870 --> 00:24:30,600
下一步是将

589
00:24:30,600 --> 00:24:32,520
加利福尼亚州的任何位表示都带入

590
00:24:32,520 --> 00:24:35,580
加利福尼亚州 穿过

591
00:24:35,580 --> 00:24:37,590
另一个寄存器 California California

592
00:24:37,590 --> 00:24:40,530
California California California cetera 然后我

593
00:24:40,530 --> 00:24:44,039
计划这是一个周期，然后这

594
00:24:44,039 --> 00:24:46,289
是我在这里使用

595
00:24:46,289 --> 00:24:49,080
向量寄存器的向量指令集的地方，在

596
00:24:49,080 --> 00:24:50,880
这里我可以做一个向量比较

597
00:24:50,880 --> 00:24:54,780
一个周期中的所有值，所以这个状态将

598
00:24:54,780 --> 00:24:56,760
被比较 加利福尼亚州

599
00:24:56,760 --> 00:24:58,860
将与加利福尼亚州等进行比较，

600
00:24:58,860 --> 00:25:01,289
并在一个循环中应用

601
00:25:01,289 --> 00:25:03,750
64 次比较，产生

602
00:25:03,750 --> 00:25:07,740
64 位的位掩码，这告诉我

603
00:25:07,740 --> 00:25:11,130
这 64 个州中的哪一个或等于 到

604
00:25:11,130 --> 00:25:20,640
加利福尼亚，你不能在

605
00:25:20,640 --> 00:25:24,150
一个循环中做到这一点 做 64 个元组

606
00:25:24,150 --> 00:25:27,030
你会知道下一次调用 64 次

607
00:25:27,030 --> 00:25:28,919
这是超级幻影这就是为什么你

608
00:25:28,919 --> 00:25:31,080
使用矢量化模型就像他们在

609
00:25:31,080 --> 00:25:31,679
这里所做的那样

610
00:25:31,679 --> 00:25:33,299
你可以打所有废话 立即

611
00:25:33,299 --> 00:25:35,309
进行过滤器审查 谓词

612
00:25:35,309 --> 00:25:37,140
评估您的速度非常快 这就是为什么

613
00:25:37,140 --> 00:25:44,190
它们的速度提高了 100 倍 让

614
00:25:44,190 --> 00:25:48,900
您感觉非常好 这就是为什么你们

615
00:25:48,900 --> 00:25:54,809
学习速度慢了 100 倍

616
00:25:54,809 --> 00:25:57,150


617
00:25:57,150 --> 00:25:59,520
我们所有的

618
00:25:59,520 --> 00:26:02,130
操作员都可以，所以因为这有魔法

619
00:26:02,130 --> 00:26:04,710
，所以当我

620
00:26:04,710 --> 00:26:07,440
有一张幻灯片时它很复杂，我认为但

621
00:26:07,440 --> 00:26:09,450
让我们继续前进，好让

622
00:26:09,450 --> 00:26:11,640
我看到这张幻灯片，所以我们真的

623
00:26:11,640 --> 00:26:14,580
希望改进所有方面

624
00:26:14,580 --> 00:26:16,890
分析 所以我们刚刚讨论

625
00:26:16,890 --> 00:26:20,700
了矢量化连接的骗局 我们着眼于

626
00:26:20,700 --> 00:26:22,770
矢量化连接 当

627
00:26:22,770 --> 00:26:24,179


628
00:26:24,179 --> 00:26:25,679
您处理列存储

629
00:26:25,679 --> 00:26:27,480
和字典编码时，还有各种漂亮的技术 您可以

630
00:26:27,480 --> 00:26:29,280
利用格式利用

631
00:26:29,280 --> 00:26:31,679
硬件以

632
00:26:31,679 --> 00:26:33,570
每秒数十亿行的速度再次处理这里我们

633
00:26:33,570 --> 00:26:35,640
通过简单地使

634
00:26:35,640 --> 00:26:37,679
称为布隆过滤器的东西更快地使关节更快展示

635
00:26:37,679 --> 00:26:38,880
了解布隆过滤器的人们的手

636
00:26:38,880 --> 00:26:41,309
非常棒

637
00:26:41,309 --> 00:26:43,530
出色的布隆过滤器是

638
00:26:43,530 --> 00:26:44,780
我喜欢魔术，

639
00:26:44,780 --> 00:26:46,669
所以这就是我们

640
00:26:46,669 --> 00:26:48,530
在五年前的第一个版本中最初如何使关节更快

641
00:26:48,530 --> 00:26:51,230
，然后

642
00:26:51,230 --> 00:26:53,240
通过一些类似的东西

643
00:26:53,240 --> 00:27:05,000
报告聚合组好的，是的，是的，这是在它上面使用 sim D

644
00:27:05,000 --> 00:27:07,340
好的，现在让我们继续前进

645
00:27:07,340 --> 00:27:09,290
我们终于进入了前五名

646
00:27:09,290 --> 00:27:12,200
，这就是我想要进入的前五名 所以

647
00:27:12,200 --> 00:27:14,210
我只想列出

648
00:27:14,210 --> 00:27:18,140
我们在过去

649
00:27:18,140 --> 00:27:20,690
五年中所做的五件事 我想我认为

650
00:27:20,690 --> 00:27:22,700
就什么使数据库脱颖而出

651
00:27:22,700 --> 00:27:26,450
至少对我们来说，记忆有点酷

652
00:27:26,450 --> 00:27:28,460
，顺便说一句，其中大部分

653
00:27:28,460 --> 00:27:30,080
导致了我们

654
00:27:30,080 --> 00:27:31,400
提交给各种不同会议的学术论文，

655
00:27:31,400 --> 00:27:33,710
所以我会在我们学习时向您指出它们

656
00:27:33,710 --> 00:27:36,799
一直以来，第一件事是

657
00:27:36,799 --> 00:27:39,440
双格式架构快速混合

658
00:27:39,440 --> 00:27:42,080
工作负载和更快的分析为什么我们

659
00:27:42,080 --> 00:27:44,540
认为这是非常创新的所以让我们

660
00:27:44,540 --> 00:27:47,090
解释它是如何工作的所以双

661
00:27:47,090 --> 00:27:48,860
格式和架构支持快速混合

662
00:27:48,860 --> 00:27:51,049
工作负载和更快的分析所以如果你

663
00:27:51,049 --> 00:27:53,350
看看你的 没错，这就是

664
00:27:53,350 --> 00:27:56,320
我上次向您展示的我们的眼图 现在

665
00:27:56,320 --> 00:27:59,780
您可以在内存 DML 中获得非常快的速度，

666
00:27:59,780 --> 00:28:02,809
因为无效的行

667
00:28:02,809 --> 00:28:05,480
已从列存储中逻辑删除，因此我

668
00:28:05,480 --> 00:28:06,860
将逐步完成此示例让我们

669
00:28:06,860 --> 00:28:10,610
假设行已被修改 所以

670
00:28:10,610 --> 00:28:12,650
无论出于何种原因修改了该行，

671
00:28:12,650 --> 00:28:14,270
也许我在那里称他或

672
00:28:14,270 --> 00:28:15,980
一些列数，但

673
00:28:15,980 --> 00:28:18,620
无论在正常路径上发生什么，它都会被更新或删除，

674
00:28:18,620 --> 00:28:20,870


675
00:28:20,870 --> 00:28:22,250
就像 Oracle 过去 3040 年来一直在做的那样

676
00:28:22,250 --> 00:28:25,370
当发生这种情况时，它会

677
00:28:25,370 --> 00:28:28,640
立即告诉我们使用该行

678
00:28:28,640 --> 00:28:30,230
ID 看到您还记得我是如何告诉您我们

679
00:28:30,230 --> 00:28:32,809
从磁盘映射到领事的，我们可以

680
00:28:32,809 --> 00:28:35,030
立即设置一个表示

681
00:28:35,030 --> 00:28:37,970
该行无效的位 d 不需要

682
00:28:37,970 --> 00:28:39,740
那么长时间 如果

683
00:28:39,740 --> 00:28:41,090
你已经完成了如果你创建了一个布隆过滤

684
00:28:41,090 --> 00:28:43,250
器 不需要很长时间你必须

685
00:28:43,250 --> 00:28:45,590
发现我看到你这

686
00:28:45,590 --> 00:28:47,360
有点查找但不是 这么长然后

687
00:28:47,360 --> 00:28:50,809
用来设置一点，所以这就是 DML 的工作方式

688
00:28:50,809 --> 00:28:53,240
超级简单，你只说这一行，

689
00:28:53,240 --> 00:28:54,830
那个列存储无效，所以现在

690
00:28:54,830 --> 00:28:57,419
当你想进行扫描时会发生什么，

691
00:28:57,419 --> 00:29:02,009
你只需忽略无效的行就可以了，

692
00:29:02,009 --> 00:29:04,739
这是我的例子 假设我正在

693
00:29:04,739 --> 00:29:07,499
做全表扫描，我只是走路线，

694
00:29:07,499 --> 00:29:09,869
我只是避开那个无效的行，然后我

695
00:29:09,869 --> 00:29:11,849
继续前进

696
00:29:11,849 --> 00:29:15,209
，我避开那一行，但这

697
00:29:15,209 --> 00:29:17,039
并没有给我一致的结果，

698
00:29:17,039 --> 00:29:18,929
现在我必须实际处理那一行，

699
00:29:18,929 --> 00:29:23,369
所以只是 对于那一行，我将转到磁盘

700
00:29:23,369 --> 00:29:25,700
或缓冲区缓存来获取该行，

701
00:29:25,700 --> 00:29:29,249
现在很可能

702
00:29:29,249 --> 00:29:30,959
在缓冲区缓存中，因为我已经更新了

703
00:29:30,959 --> 00:29:33,479
它或者我已经做了一些更新

704
00:29:33,479 --> 00:29:34,979
它将该块带入缓冲区缓存

705
00:29:34,979 --> 00:29:38,219
等 我仍然在技术上

706
00:29:38,219 --> 00:29:40,109
以内存速度处理，因为 bu  ffer

707
00:29:40,109 --> 00:29:42,299
缓存在内存中，但我

708
00:29:42,299 --> 00:29:46,979
现在反对行存储 我是 Sue 没有

709
00:29:46,979 --> 00:29:49,799
覆盖无效行不受影响，

710
00:29:49,799 --> 00:29:51,719
所以当你将数据分解成

711
00:29:51,719 --> 00:29:53,519
块时，它有很多价值，

712
00:29:53,519 --> 00:29:56,039
块不受影响 仍然会

713
00:29:56,039 --> 00:29:58,559
经历一个很好的你知道正确的向量

714
00:29:58,559 --> 00:30:00,269
扫描我们刚刚谈到的 cindy 扫描

715
00:30:00,269 --> 00:30:03,299
好的 这是一个

716
00:30:03,299 --> 00:30:03,929
重要的点

717
00:30:03,929 --> 00:30:06,570
如果

718
00:30:06,570 --> 00:30:09,119
无效行的数量

719
00:30:09,119 --> 00:30:12,329
在您的 IMC 中累积，那么混合工作负载性能可能会

720
00:30:12,329 --> 00:30:14,519
受到影响 如果行

721
00:30:14,519 --> 00:30:17,039
开始变得非常脏，那么我

722
00:30:17,039 --> 00:30:18,629
会一直访问缓冲区缓存

723
00:30:18,629 --> 00:30:20,549
我没有利用公共

724
00:30:20,549 --> 00:30:21,379
表示

725
00:30:21,379 --> 00:30:24,239
所以这是快速重新填充

726
00:30:24,239 --> 00:30:25,919
技术节省一天的地方

727
00:30:25,919 --> 00:30:27,779
所以让我们通过让我们解释

728
00:30:27,779 --> 00:30:30,320
一下 一秒钟，所以我们做了一些叫做

729
00:30:30,320 --> 00:30:32,669
持续智能的事情 好吧，这

730
00:30:32,669 --> 00:30:35,129
实际上是一种分析草本继续 LH

731
00:30:35,129 --> 00:30:37,349
智能只是意味着我们将

732
00:30:37,349 --> 00:30:40,950
跟踪您的眼睛 MCU 有多脏，

733
00:30:40,950 --> 00:30:43,019
我们扫描它的方式和频率 做一个

734
00:30:43,019 --> 00:30:45,719
组合，我会解释为什么

735
00:30:45,719 --> 00:30:48,690
我们关心它有多脏，

736
00:30:48,690 --> 00:30:50,820
如果你的 iamsu 超级脏，它扫描的

737
00:30:50,820 --> 00:30:53,549
频率有很多更新正在

738
00:30:53,549 --> 00:30:55,799
发生，但你从不扫描它我

739
00:30:55,799 --> 00:30:58,979
不一定关心 刷新它或

740
00:30:58,979 --> 00:31:00,570
重新填充它 没有人实际

741
00:31:00,570 --> 00:31:03,059
访问它 所以这是它的某种组合

742
00:31:03,059 --> 00:31:05,039
我们有一个算法来

743
00:31:05,039 --> 00:31:07,769
决定我们何时应该刷新它 所以

744
00:31:07,769 --> 00:31:09,179
我们拥有的第一个技术是

745
00:31:09,179 --> 00:31:10,830
所谓的双缓冲

746
00:31:10,830 --> 00:31:13,080
所以双缓冲的想法

747
00:31:13,080 --> 00:31:16,980
是当你 有一个脏的 IMC，你

748
00:31:16,980 --> 00:31:20,910
需要刷新它，所以我们保留

749
00:31:20,910 --> 00:31:24,570
脏的，在后台我们将

750
00:31:24,570 --> 00:31:26,400
创建一个新的

751
00:31:26,400 --> 00:31:28,640
，带来那些脏行

752
00:31:28,640 --> 00:31:31,410
重新填充坐，现在有一个很好

753
00:31:31,410 --> 00:31:34,080
的 IMC 副本，一旦它 准备好

754
00:31:34,080 --> 00:31:36,480
我们做那个 switcheroo 旧的

755
00:31:36,480 --> 00:31:38,760
出去了，一个新的进来了

756
00:31:38,760 --> 00:31:40,800
我们之所以要这样做的主要原因

757
00:31:40,800 --> 00:31:43,170
是因为我们不希望您的查询因

758
00:31:43,170 --> 00:31:45,840
每次操作脱机而受到影响，

759
00:31:45,840 --> 00:31:49,200
如果您学习 几

760
00:31:49,200 --> 00:31:51,600
薄 gs 我猜在数据库类中，您

761
00:31:51,600 --> 00:31:52,800
真的想尝试将所有内容保持

762
00:31:52,800 --> 00:31:55,500
在线状态，您永远不想降低某些内容

763
00:31:55,500 --> 00:31:58,050
，然后

764
00:31:58,050 --> 00:32:00,270
在刷新

765
00:32:00,270 --> 00:32:03,420
索引或在这种情况下刷新 IMS

766
00:32:03,420 --> 00:32:06,180
时性能变慢，任何人都知道双重

767
00:32:06,180 --> 00:32:08,190
提供可以 第二件事是

768
00:32:08,190 --> 00:32:10,590
增量重新填充我们所说的

769
00:32:10,590 --> 00:32:12,630
增量填充这里的想法是

770
00:32:12,630 --> 00:32:16,700
您可以

771
00:32:16,700 --> 00:32:19,260
利用旧

772
00:32:19,260 --> 00:32:21,810
列中的信息构建一个新列，例如，

773
00:32:21,810 --> 00:32:23,160
当您实际上从

774
00:32:23,160 --> 00:32:25,200
行存储中进行跟踪时，列存储非常

775
00:32:25,200 --> 00:32:27,510
昂贵 人口 我们称之为

776
00:32:27,510 --> 00:32:29,040
人口 将其带入

777
00:32:29,040 --> 00:32:31,860
内存 识别不同的符号是非常昂贵的

778
00:32:31,860 --> 00:32:33,690
您基本上

779
00:32:33,690 --> 00:32:36,210
将使用哈希表或艺术 你们

780
00:32:36,210 --> 00:32:38,610
听说过艺术改编基数树 非常

781
00:32:38,610 --> 00:32:39,990
好

782
00:32:39,990 --> 00:32:43,020
好的 索引或其他东西 是的 很棒 极端

783
00:32:43,020 --> 00:32:44,730
你需要一些东西来识别给我

784
00:32:44,730 --> 00:32:47,730
我独特的符号这样做很昂贵

785
00:32:47,730 --> 00:32:49,440
所以你想做的是

786
00:32:49,440 --> 00:32:50,970
利用这个事实 嘿，

787
00:32:50,970 --> 00:32:53,040
在我这里有一些脏行之前，我已经创建了一个字典，

788
00:32:53,040 --> 00:32:56,040
所以

789
00:32:56,040 --> 00:32:58,770
你可以利用它来构建新的 C

790
00:32:58,770 --> 00:33:00,960
或新的列 C 你可以，所以

791
00:33:00,960 --> 00:33:03,030
这是增量重新填充

792
00:33:03,030 --> 00:33:05,250
，我们在这里做的最后一件事有点

793
00:33:05,250 --> 00:33:08,070
棘手 通常，当您

794
00:33:08,070 --> 00:33:10,590
使一行无效时，无效意味着您正在

795
00:33:10,590 --> 00:33:12,120
更新和删除或任何您

796
00:33:12,120 --> 00:33:14,850
真正只是触及一列或某些

797
00:33:14,850 --> 00:33:16,860
数量的列，您实际上并未

798
00:33:16,860 --> 00:33:19,980
触及所有列，因此如果您

799
00:33:19,980 --> 00:33:22,950
运行的查询不受

800
00:33:22,950 --> 00:33:24,090
列，因为

801
00:33:24,090 --> 00:33:25,380
您只访问那些

802
00:33:25,380 --> 00:33:28,140
未受影响的列，那么您仍然可以

803
00:33:28,140 --> 00:33:29,880
正确访问列，您不必

804
00:33:29,880 --> 00:33:32,450
担心访问无效理由，

805
00:33:32,450 --> 00:33:35,340
所以这里的这三种技术

806
00:33:35,340 --> 00:33:38,370
使我们能够真正

807
00:33:38,370 --> 00:33:41,010
更快地运行混合工作负载 它给了我们

808
00:33:41,010 --> 00:33:56,820
两全其美的

809
00:33:56,820 --> 00:34:02,070
好处 没有没有分页 没有 所以从一

810
00:34:02,070 --> 00:34:03,510
开始 Oracle

811
00:34:03,510 --> 00:34:05,460
我们就一直说你不能

812
00:34:05,460 --> 00:34:06,659
假设所有的东西都适合备忘录 ry

813
00:34:06,659 --> 00:34:08,369
那只是它不现实

814
00:34:08,369 --> 00:34:10,320
所以会发生什么是如果

815
00:34:10,320 --> 00:34:12,210
你有任何内存的限制你会

816
00:34:12,210 --> 00:34:14,310
填充它把它带到内存

817
00:34:14,310 --> 00:34:15,989
任何不适合的东西都会留在

818
00:34:15,989 --> 00:34:18,389
磁盘上现在你就像我说的那样

819
00:34:18,389 --> 00:34:19,710
最终控制 你可以说

820
00:34:19,710 --> 00:34:21,060
你想要哪些列 你可以说

821
00:34:21,060 --> 00:34:26,960
你想要哪些分区 不管这不不

822
00:34:26,960 --> 00:34:29,668
它是一个存储 它是一个列存储

823
00:34:29,668 --> 00:34:32,489
所以它现在不是缓存 我会和

824
00:34:32,489 --> 00:34:34,349
你谈谈我们如何

825
00:34:34,349 --> 00:34:36,270
过渡 在

826
00:34:36,270 --> 00:34:37,619
我们进行存储分层和

827
00:34:37,619 --> 00:34:41,270
类似的事情时实际将其作为缓存 到目前为止还好

828
00:34:41,270 --> 00:34:43,800
一切顺利 这是一张非常

829
00:34:43,800 --> 00:34:45,780
快速的幻灯片 我只是要跳过

830
00:34:45,780 --> 00:34:47,580
这里的动画 这只是

831
00:34:47,580 --> 00:34:49,320
告诉 你如何问题我很抱歉继续

832
00:34:49,320 --> 00:34:51,349


833
00:35:13,400 --> 00:35:19,440
是的所以让我好所以我认为

834
00:35:19,440 --> 00:35:21,300
问题是如果你带来你

835
00:35:21,300 --> 00:35:22,710
听起来像你将

836
00:35:22,710 --> 00:35:25,170
行行格式颜色数据和列

837
00:35:25,170 --> 00:35:27,180
他们的数据都带入内存并且听起来

838
00:35:27,180 --> 00:35:28,380
就像基本上

839
00:35:28,380 --> 00:35:30,720
有两个 v 那样效率低下 你的数据和

840
00:35:30,720 --> 00:35:33,080
内存中的版本

841
00:35:34,550 --> 00:35:36,750
，你需要让它们保持同步和

842
00:35:36,750 --> 00:35:40,680
最新的正确，这样就可以了所以

843
00:35:40,680 --> 00:35:41,790
让我看看我是否可以适当地回答这个问题，

844
00:35:41,790 --> 00:35:44,400
如果你取决于

845
00:35:44,400 --> 00:35:46,710
你的工作量，你可能是一名分析员

846
00:35:46,710 --> 00:35:48,780
繁重的工作负载 如果您是分析

847
00:35:48,780 --> 00:35:50,520
繁重的工作负载，您永远不会

848
00:35:50,520 --> 00:35:54,930
将行格式化的数据带入

849
00:35:54,930 --> 00:35:57,359
缓冲区缓存是有道理的，您

850
00:35:57,359 --> 00:35:58,710
只会利用列

851
00:35:58,710 --> 00:36:02,130
存储中的内容，如果您是全部

852
00:36:02,130 --> 00:36:04,380
TP 很重，您所做的只是

853
00:36:04,380 --> 00:36:06,030
事务 插入 更新 删除

854
00:36:06,030 --> 00:36:09,300
您没有进行连接或聚合

855
00:36:09,300 --> 00:36:11,430


856
00:36:11,430 --> 00:36:13,800


857
00:36:13,800 --> 00:36:14,130


858
00:36:14,130 --> 00:36:18,150


859
00:36:18,150 --> 00:36:20,369
当您有一定

860
00:36:20,369 --> 00:36:22,380
比例的 DML 时，现在一定比例的

861
00:36:22,380 --> 00:36:25,500
扫描在内存中将是

862
00:36:25,500 --> 00:36:27,690
有益的，当然如果

863
00:36:27,690 --> 00:36:30,180
您更倾向于扫描而不是

864
00:36:30,180 --> 00:36:33,119
DML 现在 DML 会将

865
00:36:33,119 --> 00:36:35,340
事物块带入缓冲区 缓存，但

866
00:36:35,340 --> 00:36:36,480
它不会带来 将整个表

867
00:36:36,480 --> 00:36:38,250
放入缓冲区缓存中，所以这是

868
00:36:38,250 --> 00:36:39,930
有道理的，因此您

869
00:36:39,930 --> 00:36:41,730
偶尔会进入行存储，

870
00:36:41,730 --> 00:36:43,109
因为您只是在寻找一行，

871
00:36:43,109 --> 00:36:44,580
并且您将使用索引来获取

872
00:36:44,580 --> 00:36:46,350
该行，否则您将这样做 分析

873
00:36:46,350 --> 00:36:47,460
并检查所有这些，所以这就是

874
00:36:47,460 --> 00:36:48,390
区别

875
00:36:48,390 --> 00:37:02,250
了 没问题 好问题

876
00:37:02,250 --> 00:37:04,740
所以问题是，既然我们不

877
00:37:04,740 --> 00:37:05,910
带它，你就不必把

878
00:37:05,910 --> 00:37:08,190
所有东西都记入内存 当

879
00:37:08,190 --> 00:37:09,450
你做全桌站立时会发生什么

880
00:37:09,450 --> 00:37:10,590
你实际上是他们访问了

881
00:37:10,590 --> 00:37:12,300
不在内存中的东西，这是你的

882
00:37:12,300 --> 00:37:12,540
问题，

883
00:37:12,540 --> 00:37:14,850
所以这与我提到的无效行没有什么不同，

884
00:37:14,850 --> 00:37:17,250
如果你

885
00:37:17,250 --> 00:37:19,770
有一个无效的行，你必须去

886
00:37:19,770 --> 00:37:21,960
磁盘去获取它，所以它是相同的

887
00:37:21,960 --> 00:37:24,630
概念想象 你有所以你

888
00:37:24,630 --> 00:37:27,420
在内存中填充了 50% 的数据并且你

889
00:37:27,420 --> 00:37:29,720
有那些在 IMS 中使用的想象你

890
00:37:29,720 --> 00:37:33,570
有另外 50% 作为空的 AIIMS 鞋子或

891
00:37:33,570 --> 00:37:36,390
脏的 IM 鞋子你知道如果你能

892
00:37:36,390 --> 00:37:38,160
想象那么你总是

893
00:37:38,160 --> 00:37:40,170
会 磁盘以获取 50% 的卷

894
00:37:40,170 --> 00:37:42,330
t 这是您将拥有的行为，

895
00:37:42,330 --> 00:37:44,220
因此您将从

896
00:37:44,220 --> 00:37:45,080
内存中

897
00:37:45,080 --> 00:37:46,610
获取列存储中的所有内容，然后

898
00:37:46,610 --> 00:37:49,270
从磁盘或缓冲区缓存中获取其余内容，

899
00:37:49,270 --> 00:37:51,260
记住它，您可以

900
00:37:51,260 --> 00:37:53,240
压缩这些内容，以便您可以

901
00:37:53,240 --> 00:37:54,770
尽可能地适合你说的所以我没有

902
00:37:54,770 --> 00:37:57,230
说每堆但你不能给你

903
00:37:57,230 --> 00:38:03,350
让我们说我想要什么好吧好吧好吧

904
00:38:03,350 --> 00:38:03,650


905
00:38:03,650 --> 00:38:06,080
它在那里但是你可以压缩

906
00:38:06,080 --> 00:38:07,910
它直到你想要

907
00:38:07,910 --> 00:38:10,040
如果你可以继续前进，它会把你能做的一切都记入记忆，

908
00:38:10,040 --> 00:38:11,810


909
00:38:11,810 --> 00:38:14,360
所以这就是我将

910
00:38:14,360 --> 00:38:16,250
通过这一点，但这对我来说是一个

911
00:38:16,250 --> 00:38:18,290
非常明显的旋钮

912
00:38:18,290 --> 00:38:20,000
，因为我一直在解释它，

913
00:38:20,000 --> 00:38:22,370
但可能不会 对其他人来说很明显，我们如何在

914
00:38:22,370 --> 00:38:24,650
不做太多事情的情况下让混合工作负载运行得

915
00:38:24,650 --> 00:38:27,110
更快，但只要

916
00:38:27,110 --> 00:38:29,660
有一个平静的存储，通常当您

917
00:38:29,660 --> 00:38:32,360
有混合工作负载时，您将拥有

918
00:38:32,360 --> 00:38:34,670
一张桌子，您有一个两个三个旧的圆锥形帐篷

919
00:38:34,670 --> 00:38:36,890
索引 再次

920
00:38:36,890 --> 00:38:39,020
索引诸如键列主键之类的列上的索引

921
00:38:39,020 --> 00:38:40,820
你真的

922
00:38:40,820 --> 00:38:42,380
很快就想得到值

923
00:38:42,380 --> 00:38:46,610
的列，然后你有 10 到 20 个分析

924
00:38:46,610 --> 00:38:48,890
索引，因为对于

925
00:38:48,890 --> 00:38:50,060
你想要运行分析的所有列，

926
00:38:50,060 --> 00:38:52,340
你将有一个单独的索引，现在

927
00:38:52,340 --> 00:38:54,380
你基本上可以填满 那些

928
00:38:54,380 --> 00:38:56,150
分析索引放在一起，只

929
00:38:56,150 --> 00:38:58,850
维护列存储，任何时候

930
00:38:58,850 --> 00:39:00,950
有更新，正如我提到的，你可以

931
00:39:00,950 --> 00:39:03,620
非常快速地标记一点，说这个

932
00:39:03,620 --> 00:39:04,730
人已经更新了这个人已被

933
00:39:04,730 --> 00:39:07,250
删除，因为内存

934
00:39:07,250 --> 00:39:09,050
更新非常快

935
00:39:09,050 --> 00:39:13,730
以指示 DML 已经发生了，

936
00:39:13,730 --> 00:39:15,590
这就是方式，所以

937
00:39:15,590 --> 00:39:18,320


938
00:39:18,320 --> 00:39:20,870
现在您不必为每次更新

939
00:39:20,870 --> 00:39:25,760


940
00:39:25,760 --> 00:39:29,930
所有这些分析

941
00:39:29,930 --> 00:39:32,090
索引支付成本 D

942
00:39:32,090 --> 00:39:34,670
扫描 我将

943
00:39:34,670 --> 00:39:36,470
详细

944
00:39:36,470 --> 00:39:39,200
介绍它的工作原理 如此瘫痪的谓词

945
00:39:39,200 --> 00:39:42,380
评估负载评估商店消费者所有

946
00:39:42,380 --> 00:39:44,210
这些都是您在执行时采取的步骤

947
00:39:44,210 --> 00:39:46,070
你想评估一个谓词，

948
00:39:46,070 --> 00:39:48,410
所以让我们通过一个简单的例子，

949
00:39:48,410 --> 00:39:49,700
假设你有这个

950
00:39:49,700 --> 00:39:52,460
表 T 中的选择计数星，其中 a

951
00:39:52,460 --> 00:39:55,760
大于 10，B 小于 20，所以

952
00:39:55,760 --> 00:39:56,840
你要做的第一件事是

953
00:39:56,840 --> 00:39:58,640
你将加载 a 并且你

954
00:39:58,640 --> 00:39:58,849


955
00:39:58,849 --> 00:40:02,890
将把值放入一个 sim 注销

956
00:40:02,890 --> 00:40:05,119
然后就像我提到的那样你会

957
00:40:05,119 --> 00:40:08,989
在那个 Cindy 寄存器上 splat 10 然后

958
00:40:08,989 --> 00:40:10,910
你会做一个大于

959
00:40:10,910 --> 00:40:12,019
大于大于大于大于的

960
00:40:12,019 --> 00:40:14,209
比较 所有在一个循环中，你得到了

961
00:40:14,209 --> 00:40:16,609
一点点的了解，说 1 1 0 1 然后

962
00:40:16,609 --> 00:40:18,559
你对 B 做同样的事情，你加载 B

963
00:40:18,559 --> 00:40:20,599
你将它与 20 进行比较，这

964
00:40:20,599 --> 00:40:23,479
就是你拥有的位向量，现在你

965
00:40:23,479 --> 00:40:25,459
只需要 和这两个位向量

966
00:40:25,459 --> 00:40:28,279
一起，现在你有了最终的集合

967
00:40:28,279 --> 00:40:30,979
0 1 0 1 现在实际上还没有

968
00:40:30,979 --> 00:40:33,829
完全完成，因为它存储在

969
00:40:33,829 --> 00:40:36,699
一个 sim D 寄存器中 4 位存储在

970
00:40:36,699 --> 00:40:39,140
128 位寄存器中 我不想浪费

971
00:40:39,140 --> 00:40:41,749
128 位 存储 4 位，因此您

972
00:40:41,749 --> 00:40:43,309
基本上将它们打包，这是另一

973
00:40:43,309 --> 00:40:45,289
条指令 Simeon

974
00:40:45,289 --> 00:40:46,880
结构集支持将它们打包

975
00:40:46,880 --> 00:40:48,650
成四位，字面意思是四位

976
00:40:48,650 --> 00:40:50,809
，然后你将它存储在你知道的

977
00:40:50,809 --> 00:40:52,579
任何地方或利用它然后

978
00:40:52,579 --> 00:40:54,679
用于下一个谓词，这样你就知道我

979
00:40:54,679 --> 00:40:57,859
有更多关于 house m.d. 的细节。

980
00:40:57,859 --> 00:41:02,779
操作工作正常，所以不仅扫描，而且

981
00:41:02,779 --> 00:41:06,289
我们还使连接更快，所以布隆

982
00:41:06,289 --> 00:41:08,359
过滤器你们很熟悉布隆

983
00:41:08,359 --> 00:41:10,459
过滤器我们使布隆过滤器

984
00:41:10,459 --> 00:41:12,650
更快的方式这是

985
00:41:12,650 --> 00:41:14,719
我们首先在字典上应用布隆过滤器的组合，

986
00:41:14,719 --> 00:41:17,179
这是第一个

987
00:41:17,179 --> 00:41:18,589
因为你只需要在两个

988
00:41:18,589 --> 00:41:20,509
不同的符号上运行它，你不需要

989
00:41:20,509 --> 00:41:22,759
在所有值上运行它，一旦你

990
00:41:22,759 --> 00:41:24,289
用完不同的符号，你需要将

991
00:41:24,289 --> 00:41:27,380
它们映射回那些映射

992
00:41:27,380 --> 00:41:29,659
到那些代码的符号第二件事 我们使

993
00:41:29,659 --> 00:41:31,489
布隆过滤器更快是我们对

994
00:41:31,489 --> 00:41:33,529
使用 sim d 的操作进行矢量化，基本上是在位向量中

995
00:41:33,529 --> 00:41:36,289
进行集合成员查找这说

996
00:41:36,289 --> 00:41:39,409
在位向量中查找确定是否

997
00:41:39,409 --> 00:41:41,900
在此位向量中设置

998
00:41:41,900 --> 00:41:43,819
此值此幻灯片不讨论布隆

999
00:41:43,819 --> 00:41:45,439
过滤器 把它提升到一个新的水平，

1000
00:41:45,439 --> 00:41:49,519
这就是说，如果你能告诉我

1001
00:41:49,519 --> 00:41:52,039
你计划加入两个表中的哪两列

1002
00:41:52,039 --> 00:41:54,619
，那么

1003
00:41:54,619 --> 00:41:56,709
我们称之为加入组，如果你说嘿

1004
00:41:56,709 --> 00:41:58,699
你要加入 ve

1005
00:41:58,699 --> 00:42:02,509
现在，一旦

1006
00:42:02,509 --> 00:42:05,959
您告诉我或告诉我们，我们将

1007
00:42:05,959 --> 00:42:09,349
使用相同的字典对这两个列进行编码，

1008
00:42:09,349 --> 00:42:13,010


1009
00:42:13,010 --> 00:42:15,660
没有这个，我们将不知道

1010
00:42:15,660 --> 00:42:17,880
这两个是相关的，因此我们将

1011
00:42:17,880 --> 00:42:19,710
基本上拥有此名称列上的 hicles 和 sales

1012
00:42:19,710 --> 00:42:21,690
这个人的一个单独的字典 这个人的一个单独的字典

1013
00:42:21,690 --> 00:42:23,820
他们可以有不同的代码，

1014
00:42:23,820 --> 00:42:25,470
这取决于项目下水道的

1015
00:42:25,470 --> 00:42:27,570
分解方式，所以一旦他们有

1016
00:42:27,570 --> 00:42:29,610
不同的代码，他们就不再相互关联

1017
00:42:29,610 --> 00:42:31,680
了，就像这里的代码 5

1018
00:42:31,680 --> 00:42:34,290
没有 在这里匹配代码 8，

1019
00:42:34,290 --> 00:42:37,620
即使 5 和 8 都出 BMW

1020
00:42:37,620 --> 00:42:38,970
或任何车辆名称

1021
00:42:38,970 --> 00:42:42,330
BMW 无论如何，一旦您告诉我们，我们

1022
00:42:42,330 --> 00:42:44,340
将使用相同的字典来映射

1023
00:42:44,340 --> 00:42:47,820
代码，现在您只是在执行代码

1024
00:42:47,820 --> 00:42:51,510
以进行代码匹配 你不是在做一个普通的

1025
00:42:51,510 --> 00:42:54,180
连接 你们实现了一个连接 是的，

1026
00:42:54,180 --> 00:42:54,750


1027
00:42:54,750 --> 00:42:56,760
所以你知道你们 一个散列 散列连接

1028
00:42:56,760 --> 00:42:59,160
散列钻探涉及构建一个哈希

1029
00:42:59,160 --> 00:43:00,660
表 你必须对

1030
00:43:00,660 --> 00:43:04,110
你插入到哈希表中的键进行哈希处理

1031
00:43:04,110 --> 00:43:06,030
做一个试探 你们再次散列

1032
00:43:06,030 --> 00:43:08,130
键 你必须做一个键比较 你

1033
00:43:08,130 --> 00:43:11,130
得到的所有这些都在这里

1034
00:43:11,130 --> 00:43:14,250
它只是一个好的代码 十个索引到一个

1035
00:43:14,250 --> 00:43:17,460
数组中 不为空 有一个匹配

1036
00:43:17,460 --> 00:43:20,040
就是这样 整个事情可以被

1037
00:43:20,040 --> 00:43:22,020
矢量化 这是一个非常简单的

1038
00:43:22,020 --> 00:43:30,960
做一个有意义的查找的操作是的 是的

1039
00:43:30,960 --> 00:43:32,730
好问题 所以有些情况下

1040
00:43:32,730 --> 00:43:34,620
我们会自动做事 然后当

1041
00:43:34,620 --> 00:43:36,000
我谈论未来时我们会

1042
00:43:36,000 --> 00:43:41,540
在这个问题上走极端 所以这就是

1043
00:43:41,540 --> 00:43:45,030
加入聚合 我们做同样的

1044
00:43:45,030 --> 00:43:46,980
事情 这张幻灯片非常详细，所以

1045
00:43:46,980 --> 00:43:48,720
只需按照我的话去做，不必

1046
00:43:48,720 --> 00:43:51,600
看太多，但我们有两种

1047
00:43:51,600 --> 00:43:53,970
形式的聚合下推 这是

1048
00:43:53,970 --> 00:43:56,490
单表航空下推

1049
00:43:56,490 --> 00:43:57,630
这就是所谓的矢量

1050
00:43:57,630 --> 00:43:59,580
转换在连接上方进行聚合

1051
00:43:59,580 --> 00:44:02,430
，这有点像你 知道这

1052
00:44:02,430 --> 00:44:04,020
很复杂，这只是看这张图你无法理解

1053
00:44:04,020 --> 00:44:05,670
，

1054
00:44:05,670 --> 00:44:08,840
但让我们首先谈谈

1055
00:44:08,840 --> 00:44:11,670
我们在这里所做的是想象你

1056
00:44:11,670 --> 00:44:14,640
从 th 中选择了一个总和 是带有

1057
00:44:14,640 --> 00:44:18,030
谓词的表，通常再次使用该

1058
00:44:18,030 --> 00:44:20,100
火山模型正确，您将

1059
00:44:20,100 --> 00:44:23,310
每行通过的行发送回另一个运算符

1060
00:44:23,310 --> 00:44:26,090
，然后该运算符

1061
00:44:26,090 --> 00:44:28,250
然后添加和添加并一次添加一行

1062
00:44:28,250 --> 00:44:30,170
，也许一次有一批

1063
00:44:30,170 --> 00:44:33,020
行 但它正在

1064
00:44:33,020 --> 00:44:34,700
做一些事情 一个是它正在

1065
00:44:34,700 --> 00:44:37,280
做它 将符号复制到

1066
00:44:37,280 --> 00:44:39,680
缓冲区 另一个操作员正在读取

1067
00:44:39,680 --> 00:44:41,900
该缓冲区 然后它正在查找和

1068
00:44:41,900 --> 00:44:44,000
聚合并添加它 它是

1069
00:44:44,000 --> 00:44:47,300
非常昂贵的 我们在这里做的是

1070
00:44:47,300 --> 00:44:48,860
我们 是说你知道让我们

1071
00:44:48,860 --> 00:44:51,140
利用字典编码的格式

1072
00:44:51,140 --> 00:44:53,930
，如果它是字典编码的，

1073
00:44:53,930 --> 00:44:56,210
我们可以使用字典代码并

1074
00:44:56,210 --> 00:44:58,190
针对字典代码

1075
00:44:58,190 --> 00:45:00,590
和不同的符号进行聚合，然后我们可以

1076
00:45:00,590 --> 00:45:03,560
在扫描层完成所有这些，然后

1077
00:45:03,560 --> 00:45:05,870
只进行投影 将部分聚合

1078
00:45:05,870 --> 00:45:09,500
结果返回给更高级别的运算符

1079
00:45:09,500 --> 00:45:10,940
好的，这就是

1080
00:45:10,940 --> 00:45:11,930
我们进行聚合的技术 我有一个

1081
00:45:11,930 --> 00:45:13,610
例子 这个向量转换 我

1082
00:45:13,610 --> 00:45:14,930
不打算 g 进入这个我

1083
00:45:14,930 --> 00:45:17,450
要说的是，这是一篇

1084
00:45:17,450 --> 00:45:22,760
我们在 2018 年看到的论文，我认为这是一种

1085
00:45:22,760 --> 00:45:24,380
非常新颖的技术，它基本上

1086
00:45:24,380 --> 00:45:28,070
将聚合向下推并连接

1087
00:45:28,070 --> 00:45:30,110
到扫描层，因此基本上而

1088
00:45:30,110 --> 00:45:31,850
不是实际发送 所有这些行在

1089
00:45:31,850 --> 00:45:33,950
运算符之间备份以加入

1090
00:45:33,950 --> 00:45:35,510
运算符聚合顶部 我们

1091
00:45:35,510 --> 00:45:37,070
在扫描运算符中完成所有工作

1092
00:45:37,070 --> 00:45:39,440
这就是我再次我不会

1093
00:45:39,440 --> 00:45:41,330
谈论这个但我要谈论这个

1094
00:45:41,330 --> 00:45:43,850
这有点酷 您

1095
00:45:43,850 --> 00:45:45,470
可能没有考虑过，但我们必须

1096
00:45:45,470 --> 00:45:48,530
在行业中考虑非常大的

1097
00:45:48,530 --> 00:45:50,540
数字 任何人都知道非常大的

1098
00:45:50,540 --> 00:45:54,440
数字是如何编码的 有多种

1099
00:45:54,440 --> 00:45:57,440
不同的格式，而且非常大

1100
00:45:57,440 --> 00:45:59,510
我正在谈论 比方说有

1101
00:45:59,510 --> 00:46:02,210
30 个以上的数字 你

1102
00:46:02,210 --> 00:46:05,090
知道它不适合 64 位和 64 位

1103
00:46:05,090 --> 00:46:10,580
寄存器 Oracle 支持软件

1104
00:46:10,580 --> 00:46:14,180
实现的数字类型 你可能

1105
00:46:14,180 --> 00:46:15,740
认为数字只是寄存器 a

1106
00:46:15,740 --> 00:46:18,560
6 一个 int 或任何我们

1107
00:46:18,560 --> 00:46:22,280
对待它的权利或长度 作为

1108
00:46:22,280 --> 00:46:25,700
当每个字节的每一组都代表一个

1109
00:46:25,700 --> 00:46:28,760
高达 100 的数字时，字节序列可以，所以它是它的基数

1110
00:46:28,760 --> 00:46:32,720
100，所以你有第一个字节表示

1111
00:46:32,720 --> 00:46:35,120
像一个指数以及一个符号

1112
00:46:35,120 --> 00:46:36,710
加上一个

1113
00:46:36,710 --> 00:46:41,210
减号右数字可以，所以这只是

1114
00:46:41,210 --> 00:46:43,220
和 它是如何实现的，你知道你们是

1115
00:46:43,220 --> 00:46:46,040
怎么做的，所以我们基本上

1116
00:46:46,040 --> 00:46:48,680
在每个操作中都有一个数字

1117
00:46:48,680 --> 00:46:50,750
类型就像数百个周期，

1118
00:46:50,750 --> 00:46:52,790
实际上是数百个周期，而

1119
00:46:52,790 --> 00:46:56,180
不是一个周期来做一个简单的

1120
00:46:56,180 --> 00:46:59,359
寄存器操作，所以让我们来看看

1121
00:46:59,359 --> 00:47:01,130
我们如何支持非常大的数字的一个例子，

1122
00:47:01,130 --> 00:47:03,410
所以想象你有

1123
00:47:03,410 --> 00:47:05,690
一个从表 T 中选择的总和，其中由 J

1124
00:47:05,690 --> 00:47:09,380
逗号 K 分组，所以你正在做一个

1125
00:47:09,380 --> 00:47:11,869
由 J 逗号 K 分组的人，让我们假设

1126
00:47:11,869 --> 00:47:14,180
这是你的表，好吧

1127
00:47:14,180 --> 00:47:16,280
这些 是您的分组列 J 和 K

1128
00:47:16,280 --> 00:47:21,020
，那是您的度量列 好吧

1129
00:47:21,020 --> 00:47:23,810
我们所做的是我们创建

1130
00:47:23,810 --> 00:47:26,720
这个频率表，

1131
00:47:26,720 --> 00:47:29,900
x 轴上的这个频率

1132
00:47:29,900 --> 00:47:31,520
表是字典

1133
00:47:31,520 --> 00:47:33,560
代码 实际

1134
00:47:33,560 --> 00:47:35,690
符号只是为了在

1135
00:47:35,690 --> 00:47:38,330
这里说明这个例子，所以你会有 0

1136
00:47:38,330 --> 00:47:41,089
1 2 3，这是 10,000 和 1

1137
00:47:41,089 --> 00:47:43,250
一直到 50 1000 这里 19 cetera

1138
00:47:43,250 --> 00:47:46,280
那是 y 轴上的 x 轴，你

1139
00:47:46,280 --> 00:47:49,730
有组 不同的组，因此组的

1140
00:47:49,730 --> 00:47:51,650
可能组合是 0 0

1141
00:47:51,650 --> 00:47:55,310
0 1 1 0 和 1 1 如果您

1142
00:47:55,310 --> 00:47:59,240
现在查看此处的所有这些值，我们所做的

1143
00:47:59,240 --> 00:48:03,490
是遍历每一行并添加一个

1144
00:48:03,490 --> 00:48:07,310
计数，因此如果我转到 0 1 那个地图 所以这个

1145
00:48:07,310 --> 00:48:12,320
组我索引到 50 1819 我

1146
00:48:12,320 --> 00:48:14,060
在这里增加了一个计数，说我见过

1147
00:48:14,060 --> 00:48:17,480
一次，我对这些值中的每一个都做同样的事情

1148
00:48:17,480 --> 00:48:20,030
51 8 或 9 再次

1149
00:48:20,030 --> 00:48:22,130
为另一组我增加了 起来 我这样做 我

1150
00:48:22,130 --> 00:48:24,349
把它调高 最后我基本上

1151
00:48:24,349 --> 00:48:26,330
有一张表格 上面写着

1152
00:48:26,330 --> 00:48:29,150
我看到

1153
00:48:29,150 --> 00:48:32,510
这些不同群体的字典代码 到目前为止，每个人都和我

1154
00:48:32,510 --> 00:48:32,930


1155
00:48:32,930 --> 00:48:38,570
在一起 好的 现在我们要做的是我们将

1156
00:48:38,570 --> 00:48:41,690
通过

1157
00:48:41,690 --> 00:48:44,810
将字典符号的频率乘以

1158
00:48:44,810 --> 00:48:50,050
它会说代码 0 出现了 0

1159
00:48:50,050 --> 00:48:52,540
次所以我不需要 d 乘以它但是

1160
00:48:52,540 --> 00:48:55,060
这个人出现了一次所以我需要

1161
00:48:55,060 --> 00:48:57,100
获取它的代码在

1162
00:48:57,100 --> 00:49:00,280
字典中查找它并乘以它所以这

1163
00:49:00,280 --> 00:49:02,770
基本上是操作零

1164
00:49:02,770 --> 00:49:05,110
乘以符号加上零乘以下一个

1165
00:49:05,110 --> 00:49:07,600
符号等等为什么我们 做这个

1166
00:49:07,600 --> 00:49:33,070
问题映射你是说

1167
00:49:33,070 --> 00:49:34,960
如果数字组太大或者

1168
00:49:34,960 --> 00:49:44,670
字典的数量是否

1169
00:49:45,150 --> 00:49:47,140
完全正确所以你打赌你已经

1170
00:49:47,140 --> 00:49:48,490
确定了

1171
00:49:48,490 --> 00:49:51,460
这个问题的一些弱点所以问题是我想我是否

1172
00:49:51,460 --> 00:49:52,720
理解你的问题 有

1173
00:49:52,720 --> 00:49:53,890
可能你

1174
00:49:53,890 --> 00:49:56,770
在这里到处都有一个，例如，因为它是

1175
00:49:56,770 --> 00:49:59,800
如此多样化，我想这是正确的词

1176
00:49:59,800 --> 00:50:02,290
，所以你知道这些代码中的每一个

1177
00:50:02,290 --> 00:50:04,090
都只显示一个特定的组，或者

1178
00:50:04,090 --> 00:50:05,800
可能是所有组中的节目，或者

1179
00:50:05,800 --> 00:50:07,300
不管它是什么， 所以你基本上最终会

1180
00:50:07,300 --> 00:50:11,650
乘以所有东西，

1181
00:50:11,650 --> 00:50:14,830
这是它的一个弱点，它取决于它

1182
00:50:14,830 --> 00:50:17,890
，所以它取决于数据

1183
00:50:17,890 --> 00:50:19,720
以及数据在案例中的实际组织方式

1184
00:50:19,720 --> 00:50:21,310
，还取决于有多少

1185
00:50:21,310 --> 00:50:23,260
组 如果你有很多组

1186
00:50:23,260 --> 00:50:25,750
并且这个表的东西变得非常大，

1187
00:50:25,750 --> 00:50:27,100
因为你有许多不同的符号

1188
00:50:27,100 --> 00:50:29,230
和许多组，那么对每个组

1189
00:50:29,230 --> 00:50:30,760
进行这个操作将是一个非常昂贵的操作，

1190
00:50:30,760 --> 00:50:33,730
但只是为了

1191
00:50:33,730 --> 00:50:35,800
完成这里的想法 如果

1192
00:50:35,800 --> 00:50:39,940


1193
00:50:39,940 --> 00:50:43,240


1194
00:50:43,240 --> 00:50:44,890
我必须将这些值中的每一个

1195
00:50:44,890 --> 00:50:46,840
加起来并总结相同的值，我们基本上是用乘法替换加法，如果我

1196
00:50:46,840 --> 00:50:48,430
可以替换它，如果它是

1197
00:50:48,430 --> 00:50:51,190
十倍五我宁愿做十次

1198
00:50:51,190 --> 00:50:53,470
五次而不是五次相加十

1199
00:50:53,470 --> 00:50:56,110
次 这很明显是

1200
00:50:56,110 --> 00:50:57,220
您在因式分解方面会考虑的事情，

1201
00:50:57,220 --> 00:50:59,170
但这对于

1202
00:50:59,170 --> 00:51:00,730
软件实现的类型非常重要，因为

1203
00:51:00,730 --> 00:51:02,980
这些操作中的每一个都有如此

1204
00:51:02,980 --> 00:51:03,910
多的周期 80

1205
00:51:03,910 --> 00:51:07,210
一些周期 所以你 是说这

1206
00:51:07,210 --> 00:51:09,460
确实取决于工作量，

1207
00:51:09,460 --> 00:51:11,890
这实际上何时开始或不开始，所以

1208
00:51:11,890 --> 00:51:13,240
如果我

1209
00:51:13,240 --> 00:51:17,859
再次理解该组的一个问题，那么这很有意义，这样

1210
00:51:17,859 --> 00:51:20,470
组就可以通过 wal 的内容进行分析

1211
00:51:20,470 --> 00:51:22,450
浏览 J&K 的列，

1212
00:51:22,450 --> 00:51:25,539
所以当你浏览 J 时，你会确定 J 中

1213
00:51:25,539 --> 00:51:27,309
有多少不同的符号

1214
00:51:27,309 --> 00:51:29,770
你浏览 K 有多少

1215
00:51:29,770 --> 00:51:32,140
不同的符号 K 你将

1216
00:51:32,140 --> 00:51:33,190
两者相乘，就像一个

1217
00:51:33,190 --> 00:51:34,990
多维数组一样得到 最大

1218
00:51:34,990 --> 00:51:38,619
可能的代码，这

1219
00:51:38,619 --> 00:51:41,020
就是你创建的表，然后当你

1220
00:51:41,020 --> 00:51:42,700
想索引它时，你把

1221
00:51:42,700 --> 00:51:44,890
它们相乘，这就是

1222
00:51:44,890 --> 00:51:47,920
你如何索引到表中

1223
00:51:47,920 --> 00:51:51,280


1224
00:51:51,280 --> 00:51:53,349
这里是为了节省时间，所以

1225
00:51:53,349 --> 00:51:57,609
数字连接会更快记住

1226
00:51:57,609 --> 00:52:00,579
表达式我会跳过这里动态

1227
00:52:00,579 --> 00:52:02,230
扫描我会跳过我会

1228
00:52:02,230 --> 00:52:04,390
直接进入这个叫做内存

1229
00:52:04,390 --> 00:52:07,930
加额外数据的东西所以这是

1230
00:52:07,930 --> 00:52:09,579
我们引入的第三个地方 内存进入

1231
00:52:09,579 --> 00:52:14,859
存储层，所以使用 Oracle 我们有

1232
00:52:14,859 --> 00:52:17,049
一个叫做 Exadata 的东西 Exadata 是一个

1233
00:52:17,049 --> 00:52:19,329
我们从头开始构建的数据库机器，

1234
00:52:19,329 --> 00:52:20,069


1235
00:52:20,069 --> 00:52:22,420
基本上使用最好的 reed

1236
00:52:22,420 --> 00:52:25,029
硬件，所以最快的网络

1237
00:52:25,029 --> 00:52:28,660
最好的 SSD 驱动了很多 m  emory 很多

1238
00:52:28,660 --> 00:52:31,750
闪存，我们从头开始构建

1239
00:52:31,750 --> 00:52:35,020
，我们构建它以尽可能快地运行 Oracle

1240
00:52:35,020 --> 00:52:42,520
这是一个很好的问题，

1241
00:52:42,520 --> 00:52:46,180
我们

1242
00:52:46,180 --> 00:52:47,650
以各种不同的配置出售它们

1243
00:52:47,650 --> 00:52:50,730
肯定有数百万，但绝对是数百万，但

1244
00:52:50,730 --> 00:52:53,079
令人惊讶的是如何 许多人购买它们，

1245
00:52:53,079 --> 00:52:55,660
这真是太神奇了，对于 achill 来说，这是一项价值

1246
00:52:55,660 --> 00:53:01,029
10 亿美元的业务

1247
00:53:01,029 --> 00:53:06,279


1248
00:53:06,279 --> 00:53:10,230


1249
00:53:10,230 --> 00:53:13,270


1250
00:53:13,270 --> 00:53:15,670


1251
00:53:15,670 --> 00:53:17,720


1252
00:53:17,720 --> 00:53:19,580
排序和所有

1253
00:53:19,580 --> 00:53:23,810
在存储节点上发生的爵士乐是

1254
00:53:23,810 --> 00:53:26,720
您最接近数据的地方，它

1255
00:53:26,720 --> 00:53:30,500
位于 SSD 驱动器中，因此您

1256
00:53:30,500 --> 00:53:33,470
实际上可以在这里进行一些快速过滤，

1257
00:53:33,470 --> 00:53:36,470
然后仅将通过网络的行发送

1258
00:53:36,470 --> 00:53:40,250
回 计算节点

1259
00:53:40,250 --> 00:53:50,090
正确正确，所以你

1260
00:53:50,090 --> 00:53:52,970
在内存中没有的是我们还有一些

1261
00:53:52,970 --> 00:53:54,859
闪存位于这些存储

1262
00:53:54,859 --> 00:53:57,500
节点上，以及我们如何使用该闪存作为我们

1263
00:53:57,500 --> 00:53:59,750
使用它 一个缓存，这与

1264
00:53:59,750 --> 00:54:01,220
Andy 之前所说的有关

1265
00:54:01,220 --> 00:54:03,859
，我们实际上将它作为缓存

1266
00:54:03,859 --> 00:54:05,780
，因为您正在访问的最热数据

1267
00:54:05,780 --> 00:54:08,119
将从

1268
00:54:08,119 --> 00:54:12,890
SSD 驱动器移动到闪存缓存中，现在

1269
00:54:12,890 --> 00:54:16,130
您将和 它也将存储在

1270
00:54:16,130 --> 00:54:20,119
列状表示中，现在它的美妙

1271
00:54:20,119 --> 00:54:21,859
之处在于，在计算节点上，

1272
00:54:21,859 --> 00:54:23,570
您仅限于拥有多少 DRAM，

1273
00:54:23,570 --> 00:54:25,490
例如 1 TB 的内存

1274
00:54:25,490 --> 00:54:27,650
，您可能认为这很多，但

1275
00:54:27,650 --> 00:54:30,109
在实际企业中 没关系，

1276
00:54:30,109 --> 00:54:31,460
这就像杯水车薪，您

1277
00:54:31,460 --> 00:54:33,170
确实需要

1278
00:54:33,170 --> 00:54:35,599
闪存为您提供的数百 TB，一旦您拥有

1279
00:54:35,599 --> 00:54:37,940
所有这些内存，您基本上可以进行

1280
00:54:37,940 --> 00:54:39,680
一些非常漂亮的存储分层，现在

1281
00:54:39,680 --> 00:54:42,230
您可以拥有一些最

1282
00:54:42,230 --> 00:54:45,950
热门的数据 您的计算，

1283
00:54:45,950 --> 00:54:48,650
如果内存不足，没问题，它会

1284
00:54:48,650 --> 00:54:51,440
自动填充到

1285
00:54:51,440 --> 00:54:53,500
存储节点上的闪存缓存中，

1286
00:54:53,500 --> 00:54:57,410
现在查询如何正常工作，因此想象一下

1287
00:54:57,410 --> 00:54:59,599
您正在执行扫描全表扫描

1288
00:54:59,599 --> 00:55:02,210
说你k 现在从我的电话簿中选择

1289
00:55:02,210 --> 00:55:04,220
我地址中居住在

1290
00:55:04,220 --> 00:55:06,410
加利福尼亚的所有人 无论将要

1291
00:55:06,410 --> 00:55:08,660
经过这里它都会说好的 我已经

1292
00:55:08,660 --> 00:55:10,310
用完了这里的所有东西

1293
00:55:10,310 --> 00:55:12,650
我桌子的其余部分坐在我的

1294
00:55:12,650 --> 00:55:15,290
存储空间中 它会说一切都被

1295
00:55:15,290 --> 00:55:17,240
缓存 到我的闪存缓存中，它将

1296
00:55:17,240 --> 00:55:19,130
使用与

1297
00:55:19,130 --> 00:55:21,260
我们讨论过的

1298
00:55:21,260 --> 00:55:23,150
相同的矢量化技术，我们对连接和聚合等进行了相同的改进，

1299
00:55:23,150 --> 00:55:25,190
它利用了

1300
00:55:25,190 --> 00:55:27,290
所有这一切，它只是

1301
00:55:27,290 --> 00:55:29,599
从闪存中完成的，因此您必须从

1302
00:55:29,599 --> 00:55:31,370
闪存中获取它

1303
00:55:31,370 --> 00:55:33,860
到该存储节点本地的 D 中，

1304
00:55:33,860 --> 00:55:34,910
然后您执行相同的

1305
00:55:34,910 --> 00:55:37,780
技术，然后将其发送回

1306
00:55:37,780 --> 00:55:40,550
可能是有道理的，这只是

1307
00:55:40,550 --> 00:55:42,320
存储调整的形式为您提供

1308
00:55:42,320 --> 00:55:44,570
了更大的列存储，它允许

1309
00:55:44,570 --> 00:55:47,300
您放置 属于哪个位置的

1310
00:55:47,300 --> 00:55:50,690
数据 最昂贵内存

1311
00:55:50,690 --> 00:55:52,910
中的热数据 闪存缓存中最快的热数据

1312
00:55:52,910 --> 00:55:55,550
冷数据

1313
00:55:55,550 --> 00:55:58,160
就在磁盘上的持久性存储中

1314
00:55:58,160 --> 00:56:02,300
好吧，这些只是 一些

1315
00:56:02,300 --> 00:56:05,420
性能数字我认为我们可以跳过

1316
00:56:05,420 --> 00:56:11,240
这个我们会跳过这个任何

1317
00:56:11,240 --> 00:56:13,490
对容错感兴趣的人好吧好吧

1318
00:56:13,490 --> 00:56:15,890
好吧让我告诉你我们如何

1319
00:56:15,890 --> 00:56:20,510
实现容错好吧我们

1320
00:56:20,510 --> 00:56:22,400
基本上维护了一个我们称之为机架的节点集群

1321
00:56:22,400 --> 00:56:23,330


1322
00:56:23,330 --> 00:56:25,610
你可以有许多

1323
00:56:25,610 --> 00:56:27,410
不同的节点，假设在

1324
00:56:27,410 --> 00:56:29,720
这个例子中有四个节点，你

1325
00:56:29,720 --> 00:56:32,090
在每个节点上都有一个列存储，

1326
00:56:32,090 --> 00:56:33,470
每个节点都有内存

1327
00:56:33,470 --> 00:56:34,760
你可以单独放置一个列

1328
00:56:34,760 --> 00:56:38,600
存储你可以做什么 是您可以将

1329
00:56:38,600 --> 00:56:41,120
您的数据带入这个列存储，您

1330
00:56:41,120 --> 00:56:43,220
可以在这些其他节点中的任何一个上复制它

1331
00:56:43,220 --> 00:56:45,950
，例如，这个红眼

1332
00:56:45,950 --> 00:56:49,430
MCU 在这个节点上是重复的，这个

1333
00:56:49,430 --> 00:56:51,380
蓝色是在那个节点上重复的，黑色是

1334
00:56:51,380 --> 00:56:53,300
在那里重复的，你可以有

1335
00:56:53,300 --> 00:56:55,730
至少有两个你可以复制

1336
00:56:55,730 --> 00:56:57,620
它的节点，这样如果

1337
00:56:57,620 --> 00:56:59,900
这个节点发生任何事情，查询只需要

1338
00:56:59,900 --> 00:57:01,850
重定向到我 MCU 正确的节点，

1339
00:57:01,850 --> 00:57:05,720
这真的很简单，

1340
00:57:05,720 --> 00:57:08,960
就像你可以做的一样简单 呃

1341
00:57:08,960 --> 00:57:11,840
通过完全复制，这个

1342
00:57:11,840 --> 00:57:14,720
红眼 MCU 存储在任何地方，这

1343
00:57:14,720 --> 00:57:16,910
为您提供可用性和

1344
00:57:16,910 --> 00:57:20,000
性能性能，因为

1345
00:57:20,000 --> 00:57:22,580
现在每次访问它时都将是

1346
00:57:22,580 --> 00:57:25,250
本地的，您不会远程

1347
00:57:25,250 --> 00:57:28,610
访问另一个节点来获取它 内容

1348
00:57:28,610 --> 00:57:30,970
并运行该查询 一切都是本地的

1349
00:57:30,970 --> 00:57:32,120
好的

1350
00:57:32,120 --> 00:57:34,760
所以这就是我们如何实现光子

1351
00:57:34,760 --> 00:57:36,560
它是相当简单和直接的

1352
00:57:36,560 --> 00:57:39,980
每一个都是 IMC 你对每个 IMC 你

1353
00:57:39,980 --> 00:57:41,630
这是一百万行的一半

1354
00:57:41,630 --> 00:57:43,910
被复制 我要跳过数据

1355
00:57:43,910 --> 00:57:45,770
保护和 我将直接转向

1356
00:57:45,770 --> 00:57:48,170
智能自动化 Andy 我们如何

1357
00:57:48,170 --> 00:57:53,420
按时完成 好吧好吧

1358
00:57:53,420 --> 00:57:55,750
好吧 第四是智能自动化

1359
00:57:55,750 --> 00:57:58,340
这是我们努力变得

1360
00:57:58,340 --> 00:58:00,980
更聪明的地方 到目前为止我告诉你

1361
00:58:00,980 --> 00:58:06,050
的大部分内容是 DBA 或者你

1362
00:58:06,050 --> 00:58:08,690
知道你是否用户必须以

1363
00:58:08,690 --> 00:58:10,910
某种方式指导我们说嘿把这张桌子

1364
00:58:10,910 --> 00:58:13,100
和记忆或嘿创建这个加入

1365
00:58:13,100 --> 00:58:17,080
组正确我们想要变得更聪明

1366
00:58:17,080 --> 00:58:20,630
你们都和安迪一起工作 dy

1367
00:58:20,630 --> 00:58:22,670
是自动驾驶数据库的创建者

1368
00:58:22,670 --> 00:58:28,760
Larry Ellison 盗用了这个名字 我说过我们

1369
00:58:28,760 --> 00:58:31,490


1370
00:58:31,490 --> 00:58:33,590


1371
00:58:33,590 --> 00:58:36,680
从中赚钱 所以无论如何这就是我们朝着正确的自动驾驶数据库迈进 我

1372
00:58:36,680 --> 00:58:38,930
今天晚些时候有一个单独的谈话 那

1373
00:58:38,930 --> 00:58:42,260
更多地是关于如何 我们实现了这一点，但

1374
00:58:42,260 --> 00:58:43,880
这里的想法是

1375
00:58:43,880 --> 00:58:47,660
这张 DBA 可怜的 DBA 的图片，并且 DBA 说我

1376
00:58:47,660 --> 00:58:51,080
必须手动管理要放入

1377
00:58:51,080 --> 00:58:53,870
此列存储的内容以及要保留的内容我

1378
00:58:53,870 --> 00:58:55,640
不知道哪些表很热我不知道 不

1379
00:58:55,640 --> 00:58:57,470
知道什么是冷的 我知道它是热的 我

1380
00:58:57,470 --> 00:58:59,390
不知道你会正确运行哪些查询，

1381
00:58:59,390 --> 00:59:02,420
但正如我之前提到的，

1382
00:59:02,420 --> 00:59:05,540
它是一个列存储，所以一旦这个存储

1383
00:59:05,540 --> 00:59:09,980
充满了表，DBA

1384
00:59:09,980 --> 00:59:12,020
必须决定 Vic 兜售什么

1385
00:59:12,020 --> 00:59:15,080
正确引入的内容和期望的

1386
00:59:15,080 --> 00:59:17,450
结果是您希望将热对象保留在

1387
00:59:17,450 --> 00:59:20,380
内存中并正确删除较冷的对象，

1388
00:59:20,380 --> 00:59:24,380
这样我们就可以

1389
00:59:24,380 --> 00:59:27,740
了，我们现在拥有的是更聪明的东西，

1390
00:59:27,740 --> 00:59:31,070
在这里我们将观察访问

1391
00:59:31,070 --> 00:59:33,320
模式我们有什么 我们称之为  

1392
00:59:33,320 --> 00:59:35,780
热图热图基本上

1393
00:59:35,780 --> 00:59:39,020
以最小的粒度表示，这对

1394
00:59:39,020 --> 00:59:41,390
我们来说是一个块，并且该块

1395
00:59:41,390 --> 00:59:43,550
在块级别有一定数量的行，我们

1396
00:59:43,550 --> 00:59:45,790
会说它多久发生一次，它

1397
00:59:45,790 --> 00:59:48,850
有多热以及它如何被

1398
00:59:48,850 --> 00:59:50,530
很好地访问 访问因为它

1399
00:59:50,530 --> 00:59:54,010
扫描 DML 什么是正确的 所以我们

1400
00:59:54,010 --> 00:59:56,410
观察访问模式 一旦我们观察到

1401
00:59:56,410 --> 00:59:58,990
模式将对数据进行正确分类

1402
00:59:58,990 --> 01:00:01,810
我们会说热中间冷冷

1403
01:00:01,810 --> 01:00:04,570
数据 一旦我们对数据进行分类 然后

1404
01:00:04,570 --> 01:00:06,310
我们将采取行动 热

1405
01:00:06,310 --> 01:00:09,670
数据将删除冷数据 非常

1406
01:00:09,670 --> 01:00:12,040
简单 非常直截了当 我们把它

1407
01:00:12,040 --> 01:00:15,250
带到一个更复杂的级别

1408
01:00:15,250 --> 01:00:17,320
我们将在那里进行我们不仅会在

1409
01:00:17,320 --> 01:00:19,180
表级别或分区级别而且

1410
01:00:19,180 --> 01:00:21,400
甚至在列级别进行操作 所以我们 如果我

1411
01:00:21,400 --> 01:00:25,660
知道此列

1412
01:00:25,660 --> 01:00:28,800


1413
01:00:28,800 --> 01:00:32,200


1414
01:00:32,200 --> 01:00:36,010


1415
01:00:36,010 --> 01:00:37,690
用于谓词或谓词

1416
01:00:37,690 --> 01:00:39,340
谓词评估，并且此列

1417
01:00:39,340 --> 01:00:42,310
用于聚合 我可以用

1418
01:00:42,310 --> 01:00:43,930
不同的方式格式化它们 我可能

1419
01:00:43,930 --> 01:00:46,990
对酒使用字典编码，也可能对另一个使用另一种

1420
01:00:46,990 --> 01:00:49,840
压缩格式，因为

1421
01:00:49,840 --> 01:00:51,640
字典编码顺序涉及

1422
01:00:51,640 --> 01:00:53,740
在

1423
01:00:53,740 --> 01:00:55,420
字典中查找代码获取符号它是

1424
01:00:55,420 --> 01:00:57,220
几个间接级别，

1425
01:00:57,220 --> 01:01:00,670
这很昂贵 但它的扫描速度真的很快

1426
01:01:00,670 --> 01:01:02,830
，因为我只需要

1427
01:01:02,830 --> 01:01:04,390
查看位代码我从来不需要

1428
01:01:04,390 --> 01:01:06,880
解压缩它而聚合我

1429
01:01:06,880 --> 01:01:09,070
需要从字典中实际获取该符号

1430
01:01:09,070 --> 01:01:11,380
然后我需要添加它

1431
01:01:11,380 --> 01:01:13,840
所以为什么要 我用字典编码，

1432
01:01:13,840 --> 01:01:15,820
也许我应该保持未压缩状态，

1433
01:01:15,820 --> 01:01:18,790
所以我在那里有符号，这样

1434
01:01:18,790 --> 01:01:20,230
你就可以开始变得

1435
01:01:20,230 --> 01:01:22,570
更加聪明，知道如何访问你的

1436
01:01:22,570 --> 01:01:24,160
数据如何访问列

1437
01:01:24,160 --> 01:01:25,420
如何访问它们应该如何格式化

1438
01:01:25,420 --> 01:01:27,880
也许记住这些 也许这四

1439
01:01:27,880 --> 01:01:30,130
列永远不会被访问，摆脱

1440
01:01:30,130 --> 01:01:32,140
它们压缩它们，或者如果你想

1441
01:01:32,140 --> 01:01:34,330
安全地压缩它们或将它们从

1442
01:01:34,330 --> 01:01:35,290
列中驱逐出来，那么所有这些 呃

1443
01:01:35,290 --> 01:01:37,720
好吧，无论如何，这就是我们

1444
01:01:37,720 --> 01:01:39,610
试图消除图片中的猜测

1445
01:01:39,610 --> 01:01:41,890
并开始变得

1446
01:01:41,890 --> 01:01:44,350
更加聪明，这变得复杂，

1447
01:01:44,350 --> 01:01:48,040
因为你们都在使用

1448
01:01:48,040 --> 01:01:50,200
缓冲区缓存想象一下你有一个混合的

1449
01:01:50,200 --> 01:01:52,360
工作负载，有时你 ' 将

1450
01:01:52,360 --> 01:01:53,560
运行两部分 有时你

1451
01:01:53,560 --> 01:01:56,560
要运行分析

1452
01:01:56,560 --> 01:01:58,480
你为列存储分配了多少内存与

1453
01:01:58,480 --> 01:01:59,780
为缓冲区分配了多少内存

1454
01:01:59,780 --> 01:02:04,400
- 你如何确定

1455
01:02:04,400 --> 01:02:06,320
你如何知道行为是什么 将是

1456
01:02:06,320 --> 01:02:08,540
今天、明天还是

1457
01:02:08,540 --> 01:02:10,640
第二天等等，所以所有这些因素

1458
01:02:10,640 --> 01:02:12,560
都必须发挥作用，你

1459
01:02:12,560 --> 01:02:15,020
必须非常有弹性，能够

1460
01:02:15,020 --> 01:02:16,820
从一个切换到另一个，你必须

1461
01:02:16,820 --> 01:02:19,790
非常非常快速和准确 没有客户

1462
01:02:19,790 --> 01:02:21,410
想要转移到 Oracle 的

1463
01:02:21,410 --> 01:02:23,240
自治数据库，并且突然之间

1464
01:02:23,240 --> 01:02:26,210
他们体验到更差的性能并且

1465
01:02:26,210 --> 01:02:28,640
体验到像不一致的性能

1466
01:02:28,640 --> 01:02:31,070
这些是两件可怕的事情，

1467
01:02:31,070 --> 01:02:33,080
如果您至少想要成为

1468
01:02:33,080 --> 01:02:35,450
一直不好那将是我的妹妹，如果你会一直很坏，那就是我的妹妹

1469
01:02:35,450 --> 01:02:36,860


1470
01:02:36,860 --> 01:02:39,410
，这样用户就知道还好，

1471
01:02:39,410 --> 01:02:40,790
至少我知道今天和

1472
01:02:40,790 --> 01:02:44,510
明天会发生什么，等等，所以嗯，我

1473
01:02:44,510 --> 01:02:46,190
要跳过更多的事情 我

1474
01:02:46,190 --> 01:02:53,930
将简要谈谈问题是，所以

1475
01:02:53,930 --> 01:02:56,810
这是一个更细粒度的问题

1476
01:02:56,810 --> 01:03:00,230
，例如，当列存储

1477
01:03:00,230 --> 01:03:02,630
已满时，我们可以采取的行动只是

1478
01:03:02,630 --> 01:03:05,690
驱逐冷列，就是这样，我们

1479
01:03:05,690 --> 01:03:08,480
永远不会决定应该用什么来

1480
01:03:08,480 --> 01:03:10,460
替换它 这只是基于您的

1481
01:03:10,460 --> 01:03:12,380
查询，无论您触摸您带来什么，

1482
01:03:12,380 --> 01:03:15,140
这是一种模式，另一种模式现在会

1483
01:03:15,140 --> 01:03:17,210
更聪明，会驱逐并告诉您

1484
01:03:17,210 --> 01:03:19,910
要带什么，而另一种模式是

1485
01:03:19,910 --> 01:03:22,130
极端模式，就像

1486
01:03:22,130 --> 01:03:24,290
放手一样，一切都将决定 一

1487
01:03:24,290 --> 01:03:25,820
开始 列存储中应该有什么

1488
01:03:25,820 --> 01:03:27,470
从一开始就应该有哪些列

1489
01:03:27,470 --> 01:03:28,760
或如何压缩它

1490
01:03:28,760 --> 01:03:45,470
等等 我们只看我们

1491
01:03:45,470 --> 01:03:48,710
只看频率 ndv 对这就是

1492
01:03:48,710 --> 01:03:51,230
我们真正关注的 我们能不能看看

1493
01:03:51,230 --> 01:03:53,390
例如，如果它是一个日期列，

1494
01:03:53,390 --> 01:03:54,770
让我们给出一个日期列，如果它是一个日期

1495
01:03:54,770 --> 01:03:56,630
列，我们可以更聪明地

1496
01:03:56,630 --> 01:03:58,940
编码它，我们可以将

1497
01:03:58,940 --> 01:04:00,320
月份与日期分开，

1498
01:04:00,320 --> 01:04:02,420
如果它是数字列，则可以获得更好的压缩

1499
01:04:02,420 --> 01:04:04,160
我们可以用二进制表示 JSON 给他们留下深刻印象

1500
01:04:04,160 --> 01:04:06,620
我们可以这样做，因此

1501
01:04:06,620 --> 01:04:08,900
我们确实会查看数据类型以将

1502
01:04:08,900 --> 01:04:09,950
它们压缩为更有效的

1503
01:04:09,950 --> 01:04:12,140
表示，但我们现在不会查看它

1504
01:04:12,140 --> 01:04:13,610
以从中获得意义

1505
01:04:13,610 --> 01:04:16,190


1506
01:04:16,190 --> 01:04:18,170
一旦我们

1507
01:04:18,170 --> 01:04:20,270
在存储库中将查询放在一起并且

1508
01:04:20,270 --> 01:04:22,970
我们拥有数据和访问模式我们

1509
01:04:22,970 --> 01:04:27,740
就可以做这样的事情我不知道

1510
01:04:27,740 --> 01:04:31,670
我们是否像我说我们可以做到所以我们

1511
01:04:31,670 --> 01:04:33,380
实际上并没有做任何事情

1512
01:04:33,380 --> 01:04:35,840
然而，因为我们将在这里看到的事情

1513
01:04:35,840 --> 01:04:37,970
是数据可能会按原样加密

1514
01:04:37,970 --> 01:04:41,030
，所以你知道我们不能做

1515
01:04:41,030 --> 01:04:43,400
任何事情我什至不是 NDB 甚至

1516
01:04:43,400 --> 01:04:44,840
很难你可以从字典中做到这一点，

1517
01:04:44,840 --> 01:04:46,810
但除了 再说一遍，

1518
01:04:46,810 --> 01:05:03,920
任何其他问题都很好，是的，

1519
01:05:03,920 --> 01:05:07,280
gre 有问题，这就是

1520
01:05:07,280 --> 01:05:08,840
我们的专家系统，我不知道它不是

1521
01:05:08,840 --> 01:05:10,220
机器学习，但它就像一个

1522
01:05:10,220 --> 01:05:12,170
专家系统，它

1523
01:05:12,170 --> 01:05:14,540
再次考虑，但让我们只考虑最简单的

1524
01:05:14,540 --> 01:05:16,040
指标是它被

1525
01:05:16,040 --> 01:05:18,500
扫描的频率它消耗了多少空间

1526
01:05:18,500 --> 01:05:20,960
以及它是如何被扫描的，这些

1527
01:05:20,960 --> 01:05:22,250
有点像三个非常简单的

1528
01:05:22,250 --> 01:05:24,820
指标，从中你可以划分

1529
01:05:24,820 --> 01:05:28,130
设计一个满足阈值的方程，

1530
01:05:28,130 --> 01:05:30,650
然后优化

1531
01:05:30,650 --> 01:05:32,300
它的另一部分缺失的部分是我

1532
01:05:32,300 --> 01:05:35,180
认为葡萄酒已经访问你的时间 把

1533
01:05:35,180 --> 01:05:36,650
所有这些都考虑在内，你就有了一个

1534
01:05:36,650 --> 01:05:38,720
非常智能的系统，没有

1535
01:05:38,720 --> 01:05:39,710
比这更复杂的了，

1536
01:05:39,710 --> 01:05:41,630
你可以更进一步，你可以查看

1537
01:05:41,630 --> 01:05:43,430


1538
01:05:43,430 --> 01:05:47,200
多个表中的多列相关性之间的相关性等等

1539
01:05:48,190 --> 01:06:07,850
问题在后面是的好问题

1540
01:06:07,850 --> 01:06:09,800
所以问题是如何 你确定

1541
01:06:09,800 --> 01:06:11,630
什么时候把它放到自动正确的列中，

1542
01:06:11,630 --> 01:06:16,040
但是什么时候这些

1543
01:06:16,040 --> 01:06:17,300
相反的好问题

1544
01:06:17,300 --> 01:06:19,640
所以我会回答第一个以及什么时候

1545
01:06:19,640 --> 01:06:21,770
把它带入我 记忆又是它

1546
01:06:21,770 --> 01:06:22,850
类似于我所说的那些

1547
01:06:22,850 --> 01:06:25,040
属性，如果我知道的话，假设

1548
01:06:25,040 --> 01:06:27,740
有一张表不在内存中并且

1549
01:06:27,740 --> 01:06:30,800
辅导员已满该

1550
01:06:30,800 --> 01:06:34,190
表被扫描的频率不那么

1551
01:06:34,190 --> 01:06:35,480
频繁这些表在我们的记忆中被扫描的频率

1552
01:06:35,480 --> 01:06:37,730
非常频繁

1553
01:06:37,730 --> 01:06:40,490
一旦该表的扫描次数

1554
01:06:40,490 --> 01:06:43,640
增加到任何这些表所具有的数量以上，更换它们就没有意义了，

1555
01:06:43,640 --> 01:06:45,740
然后

1556
01:06:45,740 --> 01:06:47,960
从列存储中驱逐一些东西是有意义的

1557
01:06:47,960 --> 01:06:50,720
，但

1558
01:06:50,720 --> 01:06:52,670
它很棘手，因为你必须

1559
01:06:52,670 --> 01:06:54,980
知道只是一小段

1560
01:06:54,980 --> 01:06:56,390
时间然后它不会再次被访问

1561
01:06:56,390 --> 01:06:59,510
我支付了所有这些我花了

1562
01:06:59,510 --> 01:07:01,640
最后一个 CPU 周期将它转置

1563
01:07:01,640 --> 01:07:04,220
到内存中 现在我已经完成了就像它是

1564
01:07:04,220 --> 01:07:06,050
午夜我不需要 再次运行这些

1565
01:07:06,050 --> 01:07:09,080
报告，以便我们在采取行动之前尽量聪明

1566
01:07:09,080 --> 01:07:11,720
地识别访问模式

1567
01:07:11,720 --> 01:07:13,880
我们实际上是一个

1568
01:07:13,880 --> 01:07:16,340
相当保守的系统，我们将

1569
01:07:16,340 --> 01:07:19,070
慢慢进行修改 它就像它的

1570
01:07:19,070 --> 01:07:21,110
任何其他系统一样

1571
01:07:21,110 --> 01:07:22,430
你设计的 xpert 系统 你会

1572
01:07:22,430 --> 01:07:24,260
在这里有反馈机制 你

1573
01:07:24,260 --> 01:07:25,940
会说我做了我刚刚做的正确决定

1574
01:07:25,940 --> 01:07:29,510
如果我不喜欢我

1575
01:07:29,510 --> 01:07:31,369
从中学到的 我记得

1576
01:07:31,369 --> 01:07:33,109
那个 下次这种情况 再来一次

1577
01:07:33,109 --> 01:07:35,119
我会更聪明地考虑我要

1578
01:07:35,119 --> 01:07:37,640
带什么 我会诚实地对你说 这

1579
01:07:37,640 --> 01:07:39,109
不是一个完美的系统，这里有

1580
01:07:39,109 --> 01:07:42,230
很多工作需要完成，

1581
01:07:42,230 --> 01:07:43,970
这就是我们正在努力的地方

1582
01:07:43,970 --> 01:07:45,950
弄清楚我们如何

1583
01:07:45,950 --> 01:07:49,400
通过 20% 的工作获得 80% 的收益，

1584
01:07:49,400 --> 01:07:51,580
以便我们可以快速获得它

1585
01:07:51,580 --> 01:08:14,540


1586
01:08:14,540 --> 01:08:15,830


1587
01:08:15,830 --> 01:08:17,839
说 0 和 1 都很热，这就是

1588
01:08:17,839 --> 01:08:18,890
你说的对，它们都很高，

1589
01:08:18,890 --> 01:08:21,170
你没有 0 和 1 的空间，

1590
01:08:21,170 --> 01:08:23,000
你做什么我们做的第一件事是我们说

1591
01:08:23,000 --> 01:08:24,500
哪些列没有被

1592
01:08:24,500 --> 01:08:27,680
访问好 通常你

1593
01:08:27,680 --> 01:08:30,229
有一张非常胖的桌子或一张胖桌子

1594
01:08:30,229 --> 01:08:32,149
可以让我们像任何人一样熟悉

1595
01:08:32,149 --> 01:08:36,080
PCH 好吧 t PCH 是一个基准 数据

1596
01:08:36,080 --> 01:08:38,410
仓库台架麦克风

1597
01:08:38,410 --> 01:08:42,020
还行 TP CH 有一个名为 line item

1598
01:08:42,020 --> 01:08:45,040
line item 的表有一个名为 L comment 的列

1599
01:08:45,040 --> 01:08:48,620
L comment 在该特定基准测试中的查询中从来没有使用

1600
01:08:48,620 --> 01:08:49,939


1601
01:08:49,939 --> 01:08:53,090


1602
01:08:53,090 --> 01:08:56,029
过

1603
01:08:56,029 --> 01:08:58,520
内存中的空间它是一个巨大的 varchar 不是

1604
01:08:58,520 --> 01:08:59,899
巨大的 varchar 但它是一个很大的

1605
01:08:59,899 --> 01:09:03,170
varchar' 字符串，oracle 非常

1606
01:09:03,170 --> 01:09:03,979
激进，

1607
01:09:03,979 --> 01:09:06,200
我们将对其进行字典编码，这

1608
01:09:06,200 --> 01:09:07,880
实际上没有意义，因为

1609
01:09:07,880 --> 01:09:09,200
它们都是不同的符号，

1610
01:09:09,200 --> 01:09:10,490
为什么我要使用字典编码 I'

1611
01:09:10,490 --> 01:09:12,410
我不会利用它，但我们会这样做，因为

1612
01:09:12,410 --> 01:09:15,229
我们假设你可能会扫描它，

1613
01:09:15,229 --> 01:09:16,970
如果你可以扫描字典

1614
01:09:16,970 --> 01:09:19,010
编码是最聪明的事情，所以

1615
01:09:19,010 --> 01:09:21,350
回到你的例子这里是 L comment

1616
01:09:21,350 --> 01:09:23,899
is never used line item is hot that's a

1617
01:09:23,899 --> 01:09:26,149
hot 表，但 L 列评论

1618
01:09:26,149 --> 01:09:28,490
从未使用过，因此将其驱逐或

1619
01:09:28,490 --> 01:09:30,950
压缩只是为了安全，

1620
01:09:30,950 --> 01:09:32,810
而压缩受害者的行为

1621
01:09:32,810 --> 01:09:34,729
可能允许您将另一个

1622
01:09:34,729 --> 01:09:37,640
表带入有意义的 所以我们

1623
01:09:37,640 --> 01:09:40,040
将首先尝试非常保守，并尝试通过压缩列

1624
01:09:40,040 --> 01:09:42,170
将这两个表都

1625
01:09:42,170 --> 01:09:44,029
放入列存储中

1626
01:09:44,029 --> 01:09:46,939
如果这不起作用我们采取

1627
01:09:46,939 --> 01:09:48,800
下一个更大的行动 如果这不起作用我们采取下一个更大的行动

1628
01:09:48,800 --> 01:09:50,060
行动它非常

1629
01:09:50,060 --> 01:09:52,040
所以例如表通常是

1630
01:09:52,040 --> 01:09:54,350
正确的分区你可以按

1631
01:09:54,350 --> 01:09:57,770
日期分区也许需要旧日期分区

1632
01:09:57,770 --> 01:09:58,940
并且你只关心

1633
01:09:58,940 --> 01:10:00,500
最热的日期所以

1634
01:10:00,500 --> 01:10:03,020
当你维克旧日期时请记住这

1635
01:10:03,020 --> 01:10:04,850
一点如果你现在有意义 “在

1636
01:10:04,850 --> 01:10:08,120
这两种情况都很热的情况下然后我们保持

1637
01:10:08,120 --> 01:10:09,320
保守我们不会

1638
01:10:09,320 --> 01:10:11,780
不断填充我们选择填充一个

1639
01:10:11,780 --> 01:10:14,000
模糊的只会增加更多周期

1640
01:10:14,000 --> 01:10:15,920
来做人口所以我们会选择一个

1641
01:10:15,920 --> 01:10:19,400
并与他们一起生活 后果

1642
01:10:19,400 --> 01:10:22,580
好吧好吧我知道我喜欢在这里度过我们的

1643
01:10:22,580 --> 01:10:24,650
时间所以我只是要起来抱歉

1644
01:10:24,650 --> 01:10:28,100
抱歉我持久内存好吧让

1645
01:10:28,100 --> 01:10:30,140
我们快速谈谈持久

1646
01:10:30,140 --> 01:10:34,310
内存新的硅技术容量

1647
01:10:34,310 --> 01:10:37,160
性能和价格赌注 在 DRAM 和

1648
01:10:37,160 --> 01:10:39,380
闪存之间这是一张不错的小图

1649
01:10:39,380 --> 01:10:42,530
，它显示了当您从磁盘到闪存

1650
01:10:42,530 --> 01:10:44,480
再到持久性内存时，您的 DRAM

1651
01:10:44,480 --> 01:10:46,090
速度会

1652
01:10:46,090 --> 01:10:48,710


1653
01:10:48,710 --> 01:10:50,600
更快 每

1654
01:10:50,600 --> 01:10:51,559
GB

1655
01:10:51,559 --> 01:10:55,369
好吧 最终 pmm 现在真的很贵

1656
01:10:55,369 --> 01:10:57,500
它真的很贵 最终

1657
01:10:57,500 --> 01:10:59,510
这会降低价格 但

1658
01:10:59,510 --> 01:11:01,520
闪存也会更便宜 所以

1659
01:11:01,520 --> 01:11:02,989
我们如何将系统

1660
01:11:02,989 --> 01:11:05,480
与所有这些技术结合在一起以

1661
01:11:05,480 --> 01:11:08,960
获得最佳性能英特尔称之为

1662
01:11:08,960 --> 01:11:11,570
这非常有趣 获得 DC 持久内存 DC 的

1663
01:11:11,570 --> 01:11:14,119
数据中心 我相信他们现在

1664
01:11:14,119 --> 01:11:15,860
几乎是城里唯一的游戏

1665
01:11:15,860 --> 01:11:18,380
好吧还有其他

1666
01:11:18,380 --> 01:11:19,730
游戏但现在城里唯一的游戏

1667
01:11:19,730 --> 01:11:22,309
读取内存速度比

1668
01:11:22,309 --> 01:11:25,190
闪存快得多 正确的生存 断电与

1669
01:11:25,190 --> 01:11:28,039
DRAM 不同 好吧 可以想象构建

1670
01:11:28,039 --> 01:11:30,619
，你说构建一个全新的

1671
01:11:30,619 --> 01:11:32,270
存储引擎，构建在

1672
01:11:32,270 --> 01:11:35,780
持久性内存之上，这很棘手，就像

1673
01:11:35,780 --> 01:11:38,150
你们这里的一个关键，他是 g

1674
01:11:38,150 --> 01:11:41,239
明天将讨论如何

1675
01:11:41,239 --> 01:11:42,829
利用持久内存 这可能很

1676
01:11:42,829 --> 01:11:45,050
棘手，因为它涉及利用

1677
01:11:45,050 --> 01:11:47,690
一些新指令来确保

1678
01:11:47,690 --> 01:11:49,489
数据一直正确

1679
01:11:49,489 --> 01:11:52,639
刷新到内存中 我不会

1680
01:11:52,639 --> 01:11:55,250
详细介绍我会 只需

1681
01:11:55,250 --> 01:11:58,760
在此处展示我们计划

1682
01:11:58,760 --> 01:12:01,699
如何为我们的内存列存储使用持久内存的幻灯片

1683
01:12:01,699 --> 01:12:04,969
，今天作为

1684
01:12:04,969 --> 01:12:05,659
基线，

1685
01:12:05,659 --> 01:12:08,239
您不一定将所有

1686
01:12:08,239 --> 01:12:10,309
数据都放入内存中，这就是

1687
01:12:10,309 --> 01:12:12,230
我们一直在谈论的示例或我们中的一些人

1688
01:12:12,230 --> 01:12:13,820
假设它不适合内存，因此

1689
01:12:13,820 --> 01:12:16,309
您将拥有磁盘磁盘和

1690
01:12:16,309 --> 01:12:18,469
内存，然后查询必须与

1691
01:12:18,469 --> 01:12:21,199
列存储以及

1692
01:12:21,199 --> 01:12:25,400
烤或磁盘右侧的列存储相悖，并且 DRAM 暗淡

1693
01:12:25,400 --> 01:12:26,539
可以增加 228 GB

1694
01:12:26,539 --> 01:12:28,520
没有人买它，因为它非常

1695
01:12:28,520 --> 01:12:32,079
昂贵，所以这就是今天

1696
01:12:32,079 --> 01:12:36,469
P 妈妈的基线，你可以想象将

1697
01:12:36,469 --> 01:12:38,389
所有东西都放在豌豆中，嗯，

1698
01:12:38,389 --> 01:12:42,260
亚当好吧，它的密度提高了 3 倍，

1699
01:12:42,260 --> 01:12:44,119
这就是所谓的内存模式，这是非常酷的

1700
01:12:44,119 --> 01:12:48,559
内存模式 Intel sup 端口它允许

1701
01:12:48,559 --> 01:12:52,119
你有你的持久内存暗和

1702
01:12:52,119 --> 01:12:58,099
aa dram 暗坐在顶部好所以当

1703
01:12:58,099 --> 01:13:01,340
你访问数据时 DRAM 暗作为一个

1704
01:13:01,340 --> 01:13:05,030
缓存所以你最热的数据位于

1705
01:13:05,030 --> 01:13:07,820
内存 Indy Ram 中，如果它不在那个缓存中，

1706
01:13:07,820 --> 01:13:09,920
那么我们' 将把它从

1707
01:13:09,920 --> 01:13:12,260
持久内存dim 带入D Ram den

1708
01:13:12,260 --> 01:13:14,060
所以D lambda 只是作为一个缓存

1709
01:13:14,060 --> 01:13:16,280
它浪费了空间，因为它是

1710
01:13:16,280 --> 01:13:18,860
一个缓存它不像

1711
01:13:18,860 --> 01:13:21,650
你拥有的额外内存，但好处是你

1712
01:13:21,650 --> 01:13:25,100
几乎可以像这样访问PMM 像 SDRAM 一样快，

1713
01:13:25,100 --> 01:13:27,440
所以这被称为内存模式，

1714
01:13:27,440 --> 01:13:29,720
最热的表缓存在 DRAM 中以

1715
01:13:29,720 --> 01:13:31,670
实现最快的访问，这些 DIMM

1716
01:13:31,670 --> 01:13:33,920
可能很大，有 512 GB，

1717
01:13:33,920 --> 01:13:36,230
然后这只是谈论使用我们

1718
01:13:36,230 --> 01:13:38,600
最新的 Oracle 20 C 和一些

1719
01:13:38,600 --> 01:13:39,590
技术以及原因 为什么我提到

1720
01:13:39,590 --> 01:13:42,620
这一点是我们运行了这个基准测试，

1721
01:13:42,620 --> 01:13:44,540
我们使用 SS B 是 SS B 的另一个

1722
01:13:44,540 --> 01:13:46,280
基准测试，称为星型模式基准测试

1723
01:13:46,280 --> 01:13:50,110
它有点基于 T PCH，

1724
01:13:50,110 --> 01:13:53,000
我们在那里展示了 D Ram 大约 380 4

1725
01:13:53,000 --> 01:13:54,800
GB 表不完全适合

1726
01:13:54,800 --> 01:13:57,230
内存这是一个进度条，但

1727
01:13:57,230 --> 01:14:00,470
完成后我们处理了 180 亿行，

1728
01:14:00,470 --> 01:14:02,840
当它不能完全放入内存时花了 130 秒

1729
01:14:02,840 --> 01:14:04,820
，然后我们使用

1730
01:14:04,820 --> 01:14:06,830
带有持久内存的内存模式，

1731
01:14:06,830 --> 01:14:09,590
它像下降了 10 倍，速度下降了 10 倍

1732
01:14:09,590 --> 01:14:11,960
，然后 12 秒到 180

1733
01:14:11,960 --> 01:14:13,880
亿行，然后我们刚刚添加了

1734
01:14:13,880 --> 01:14:16,250
Oracle 20 C，它有一些很酷的

1735
01:14:16,250 --> 01:14:17,990
技术可以让关节更快，

1736
01:14:17,990 --> 01:14:19,790
我们刚刚展示了它

1737
01:14:19,790 --> 01:14:21,710
可以比这快 4 倍，

1738
01:14:21,710 --> 01:14:23,780
我想提的要点是

1739
01:14:23,780 --> 01:14:25,670
这对我们来说真的是一个游戏规则改变者

1740
01:14:25,670 --> 01:14:27,830
我们更多地将持久性内存

1741
01:14:27,830 --> 01:14:31,460
视为扩展内存更大容量

1742
01:14:31,460 --> 01:14:33,920
所以现在您可以将所有内容都放入

1743
01:14:33,920 --> 01:14:35,450
内存中并且您

1744
01:14:35,450 --> 01:14:37,280
需要将所有内容都放在磁盘上的

1745
01:14:37,280 --> 01:14:39,470
日子已经一去不复返了

1746
01:14:39,470 --> 01:14:43,490
TB 级内存 好的

1747
01:14:43,490 --> 01:14:46,280
我要跳过聚合

1748
01:14:46,280 --> 01:14:48,080
分析 我只是要打开它来

1749
01:14:48,080 --> 01:14:49,460
回答问题 但主要 我将在

1750
01:14:49,460 --> 01:14:51,320
这里只讨论这张幻灯片

1751
01:14:51,320 --> 01:14:52,880
关于 Oracle 的主要内容

1752
01:14:52,880 --> 01:14:54,080
我们不知道的事情之一 想要更酷的是，您

1753
01:14:54,080 --> 01:14:56,120
不需要

1754
01:14:56,120 --> 01:14:59,210
为文档存储或空间

1755
01:14:59,210 --> 01:15:04,160
存储 Neo4j 或图形或 AI 或 IOT 拥有单独的存储引擎，或者

1756
01:15:04,160 --> 01:15:05,720
您知道将您的数据库视为文件

1757
01:15:05,720 --> 01:15:07,760
系统 Oracle 试图将

1758
01:15:07,760 --> 01:15:10,340
自己定位为一个 -stop shop right 你可以

1759
01:15:10,340 --> 01:15:12,260
在一个数据库上做所有的事情，

1760
01:15:12,260 --> 01:15:15,290
它有很多好处，一个是

1761
01:15:15,290 --> 01:15:17,630
安全性，你不想

1762
01:15:17,630 --> 01:15:18,770
迁移你的中继

1763
01:15:18,770 --> 01:15:21,950
数据把它带到一个图形

1764
01:15:21,950 --> 01:15:24,320
数据库中，这样你就可以运行图形

1765
01:15:24,320 --> 01:15:27,650
查询 右边有一个客户，

1766
01:15:27,650 --> 01:15:29,930
或者是第二天欧洲的客户

1767
01:15:29,930 --> 01:15:32,870
，他们建立了一个

1768
01:15:32,870 --> 01:15:37,070
图形数据库，他们使用一个图形来

1769
01:15:37,070 --> 01:15:40,130
表示

1770
01:15:40,130 --> 01:15:42,140
他们在他们的 PayPal 或系统上的不同人之间的交易

1771
01:15:42,140 --> 01:15:45,290
，他们的每一个边缘

1772
01:15:45,290 --> 01:15:47,570
他们的图形节点是一个事务，但

1773
01:15:47,570 --> 01:15:49,130
他们必须从关系存储中取出他们的数据

1774
01:15:49,130 --> 01:15:51,440
将其带入

1775
01:15:51,440 --> 01:15:53,270
图形存储，然后他们运行他们的

1776
01:15:53,270 --> 01:15:55,820
查询，这需要一段时间

1777
01:15:55,820 --> 01:15:57,260
，现在总是存在这种安全

1778
01:15:57,260 --> 01:15:58,760
违规行为 因为您将这些

1779
01:15:58,760 --> 01:16:01,990
未加密的数据从数据库中取出

1780
01:16:01,990 --> 01:16:04,730
与 MongoDB 这个 MongoDB 的文档存储相同的东西，

1781
01:16:04,730 --> 01:16:06,920
但是您也可以

1782
01:16:06,920 --> 01:16:10,130
将 JSON 很好地存储在您的

1783
01:16:10,130 --> 01:16:12,710
关系数据库中，所以我不

1784
01:16:12,710 --> 01:16:15,590
打算过多谈论这个我' 我

1785
01:16:15,590 --> 01:16:20,240
只是略过这个，然后

1786
01:16:20,240 --> 01:16:20,660
就这样

1787
01:16:20,660 --> 01:16:22,670
好了 最后一件事就是这个

1788
01:16:22,670 --> 01:16:25,100
创新总结 我想

1789
01:16:25,100 --> 01:16:28,640
非常清楚地表明，你知道这是 2014 年，

1790
01:16:28,640 --> 01:16:31,040
当我们推出所有这些小

1791
01:16:31,040 --> 01:16:33,440
项目时 大型

1792
01:16:33,440 --> 01:16:36,170
项目和 Oracle 有点

1793
01:16:36,170 --> 01:16:40,940
致力于内存，你知道我们的路线图

1794
01:16:40,940 --> 01:16:42,620
正在上升，所以我有点把它

1795
01:16:42,620 --> 01:16:44,900
从 20 到 21 个场景绘制得更高，所以我们

1796
01:16:44,900 --> 01:16:46,310
非常投入，因为我们觉得

1797
01:16:46,310 --> 01:16:49,160
现在是内存时间 变得

1798
01:16:49,160 --> 01:16:51,140
容易获得 它变得越来越便宜

1799
01:16:51,140 --> 01:16:54,350
它变得越来越大 硬件

1800
01:16:54,350 --> 01:16:56,180
技术在那里

1801
01:16:56,180 --> 01:16:57,740
实时企业的要求又在

1802
01:16:57,740 --> 01:16:59,840
那里，因此我们的功能

1803
01:16:59,840 --> 01:17:02,330
需要在那里，我们的主要驱动力

1804
01:17:02,330 --> 01:17:04,160
是自我 浏览内存

1805
01:17:04,160 --> 01:17:05,360
数据库，一切都需要

1806
01:17:05,360 --> 01:17:08,390
自主，真正查看所有内容，

1807
01:17:08,390 --> 01:17:10,700
不仅是关系，还有空间文本

1808
01:17:10,700 --> 01:17:15,170
图等，并且矢量化我们所有的

1809
01:17:15,170 --> 01:17:16,910
操作符不仅仅是我们的简单

1810
01:17:16,910 --> 01:17:20,420
扫描等等，我想就是这样，

1811
01:17:20,420 --> 01:17:22,760
我会跳过我 如果您有任何好问题，我将跳过

1812
01:17:22,760 --> 01:17:26,090
它并打开您

1813
01:17:26,090 --> 01:17:29,200
可能遇到的任何

1814
01:17:35,060 --> 01:17:49,440
问题所以问题是

1815
01:17:49,440 --> 01:17:51,210


1816
01:17:51,210 --> 01:17:53,130
当您想将其用于数据时，我们如何将其表示为您的数据的单一表示

1817
01:17:53,130 --> 01:17:54,390
图形 Corre

1818
01:17:54,390 --> 01:17:56,550
与关系查询或者它是否像

1819
01:17:56,550 --> 01:17:58,470
一个你知道多种表示我

1820
01:17:58,470 --> 01:18:02,070
做对了所以我很快地浏览了

1821
01:18:02,070 --> 01:18:03,600
这些幻灯片但是让我

1822
01:18:03,600 --> 01:18:06,750
解释一下我们对图形做了什么或者

1823
01:18:06,750 --> 01:18:08,550
假设我现在最初会说 JSON

1824
01:18:08,550 --> 01:18:10,740
文本 好的，所以

1825
01:18:10,740 --> 01:18:13,080
我们为文本空间 JSON 所做的技术

1826
01:18:13,080 --> 01:18:15,690
无论它是

1827
01:18:15,690 --> 01:18:19,560


1828
01:18:19,560 --> 01:18:21,960
在列存储的内存中以更有效的方式表示数据，所以它有点

1829
01:18:21,960 --> 01:18:23,760
像考虑字典编码做

1830
01:18:23,760 --> 01:18:25,470
一些技巧 像这样更有效地表示您的

1831
01:18:25,470 --> 01:18:34,800
数据是的，像这样，

1832
01:18:34,800 --> 01:18:37,020
您希望雇用

1833
01:18:37,020 --> 01:18:39,030
某人的重要性是他可能具有

1834
01:18:39,030 --> 01:18:40,620
测试数据库

1835
01:18:40,620 --> 01:18:43,440
系统或查询优化的背景

1836
01:18:43,440 --> 01:18:47,490


1837
01:18:47,490 --> 01:18:50,550
所以第一件事

1838
01:18:50,550 --> 01:18:52,350
是我一直在寻找那些

1839
01:18:52,350 --> 01:18:55,710
对技术充满热情、聪明和兴奋

1840
01:18:55,710 --> 01:18:57,180
的人 这

1841
01:18:57,180 --> 01:18:59,220
首先是因为我们有

1842
01:18:59,220 --> 01:19:00,840
数学家 我们有机械

1843
01:19:00,840 --> 01:19:03,300
工程师 我们有化学家 我们有

1844
01:19:03,300 --> 01:19:04,830
各种各样的人从事数据库

1845
01:19:04,830 --> 01:19:07,710
系统工作 实际上在数据库系统方面具有扎实背景的人，

1846
01:19:07,710 --> 01:19:09,810


1847
01:19:09,810 --> 01:19:14,670
但是他们就像我在某些方面不知道

1848
01:19:14,670 --> 01:19:15,990
圣杯这个词是什么

1849
01:19:15,990 --> 01:19:16,710
，

1850
01:19:16,710 --> 01:19:20,220
因为我们与我们的核心

1851
01:19:20,220 --> 01:19:21,990
存储引擎团队进行交互，但我与我们进行

1852
01:19:21,990 --> 01:19:23,880
交互 我们将要面对的优化器团队 我们

1853
01:19:23,880 --> 01:19:25,560


1854
01:19:25,560 --> 01:19:27,930
与硬件团队互动的渗出团队 我有

1855
01:19:27,930 --> 01:19:29,640
计算机体系结构编译器的背景

1856
01:19:29,640 --> 01:19:32,250
所以我根本没有

1857
01:19:32,250 --> 01:19:37,140
后台数据库系统好吧

1858
01:19:37,140 --> 01:19:39,560
你有两个候选人同等背景

1859
01:19:39,560 --> 01:19:42,360
喇叭一个是JavaScript程序员

1860
01:19:42,360 --> 01:19:44,870
好吧

1861
01:19:48,050 --> 01:19:50,240
[笑声]

1862
01:19:50,240 --> 01:19:53,550
[掌声]

1863
01:20:02,620 --> 01:20:05,699
[音乐]

1864
01:20:11,720 --> 01:20:14,610
儿子跳弹果冻撞到熟食店照片

1865
01:20:14,610 --> 01:20:16,350
放一个自然祝福你

1866
01:20:16,350 --> 01:20:18,150
说唱是 就像激光束一样

1867
01:20:18,150 --> 01:20:23,400
瓶子里的毛孔或吸管去不要填写

1868
01:20:23,400 --> 01:20:27,090
喝它只有你不能，

1869
01:20:27,090 --> 01:20:28,740
如果清酒不扔你的手机可以点击

1870
01:20:28,740 --> 01:20:31,250
一个东西

