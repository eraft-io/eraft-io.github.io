1
00:00:03,640 --> 00:00:13,140
[音乐]

2
00:00:14,379 --> 00:00:19,010
好的，让我们开始吧，嗨哦，谢谢

3
00:00:19,010 --> 00:00:23,480
各位 DJ 医生女孩们，好快

4
00:00:23,480 --> 00:00:26,419
，项目 3 项目的课程的一些公告

5
00:00:26,419 --> 00:00:28,570
将于

6
00:00:28,570 --> 00:00:32,150
今天发布，明天 ish，

7
00:00:32,150 --> 00:00:35,300
将于 11 月周日到期，我只是

8
00:00:35,300 --> 00:00:37,190
做 15 号我昨天更新

9
00:00:37,190 --> 00:00:39,949
了 17 号星期天宣布了 2

10
00:00:39,949 --> 00:00:41,960
下周将发布 3 怎么样

11
00:00:41,960 --> 00:00:43,670
所以我去担心那个但是

12
00:00:43,670 --> 00:00:47,390
这将在项目 3 之前到期

13
00:00:47,390 --> 00:00:49,460
另一个主要公告也是

14
00:00:49,460 --> 00:00:52,699
正如我在学期开始时所说的那样，

15
00:00:52,699 --> 00:00:55,039
我的妻子怀孕了，我认为

16
00:00:55,039 --> 00:01:00,859
这是我的，所以他们

17
00:01:00,859 --> 00:01:05,209
在星期三晚上将它从她身上取出，我让他

18
00:01:05,209 --> 00:01:06,770
在星期二的 Sigma 截止日期之后安排它，

19
00:01:06,770 --> 00:01:08,030
这是基于大数据的

20
00:01:08,030 --> 00:01:09,200
会议 所以它发生在

21
00:01:09,200 --> 00:01:12,409
星期三，所以下周我不会在这里

22
00:01:12,409 --> 00:01:14,780
DJ drop table 会在这里 然后我的

23
00:01:14,780 --> 00:01:17,270
PG 学生将教那两个

24
00:01:17,270 --> 00:01:18,860
讲座 然后根据

25
00:01:18,860 --> 00:01:21,500
发生的情况我应该在

26
00:01:21,500 --> 00:01:23,479
下周左右回来，所以我们可能会调整

27
00:01:23,479 --> 00:01:27,439
其余的部分 我想我们等一下，他们告诉

28
00:01:27,439 --> 00:01:28,909
我起源要到 30 号，所以我

29
00:01:28,909 --> 00:01:30,380
在 30 号取消了课程，但现在

30
00:01:30,380 --> 00:01:31,939
无论这个星期三还是

31
00:01:31,939 --> 00:01:34,880
星期四，它都会出来，所以我可能会调整

32
00:01:34,880 --> 00:01:37,340
那天的休息日，但目标是获得

33
00:01:37,340 --> 00:01:39,560
所有 您需要做

34
00:01:39,560 --> 00:01:42,920
第 3 项家庭作业的材料，在接下来的

35
00:01:42,920 --> 00:01:45,920
两周内可以 任何有关此的问题我

36
00:01:45,920 --> 00:01:49,040
都会将其发布在 Piazza 上，并与

37
00:01:49,040 --> 00:01:52,630
您一起了解更多信息 真的

38
00:01:52,630 --> 00:01:56,780
没问题 其他变化

39
00:01:56,780 --> 00:01:59,119
也是原来的时间表

40
00:01:59,119 --> 00:02:02,960
是 期中考试前的最后一节课

41
00:02:02,960 --> 00:02:04,219
是关于查询优化的，我们

42
00:02:04,219 --> 00:02:06,469
显然时间不够了，所以我

43
00:02:06,469 --> 00:02:08,389
决定现在把这个讲座分成

44
00:02:08,389 --> 00:02:10,788
两部分，所以这是第二部分，然后

45
00:02:10,788 --> 00:02:13,700
我放弃了关于嵌入式数据库逻辑的讲座，

46
00:02:13,700 --> 00:02:15,500
这不是真的

47
00:02:15,500 --> 00:02:17,150
我们需要注意的一些事情或

48
00:02:17,150 --> 00:02:18,680
数据库系统的构建，这

49
00:02:18,680 --> 00:02:20,180
只是

50
00:02:20,180 --> 00:02:21,950
让你们理解，

51
00:02:21,950 --> 00:02:23,599
哦，除了将续集扔到数据库之外，你还可以做其他事情，

52
00:02:23,599 --> 00:02:25,640


53
00:02:25,640 --> 00:02:28,189
所以如果你是 c 好奇

54
00:02:28,189 --> 00:02:29,569
你知道我会在 Piazza 上发送邮政链接

55
00:02:29,569 --> 00:02:31,640
你可以观看去年

56
00:02:31,640 --> 00:02:34,310
关于该主题的讲座查询

57
00:02:34,310 --> 00:02:36,110
优化更重要所以我认为

58
00:02:36,110 --> 00:02:38,209
最好花更多时间在

59
00:02:38,209 --> 00:02:42,980
这个上

60
00:02:42,980 --> 00:02:45,170
当查询优化开始时，我们将重点

61
00:02:45,170 --> 00:02:47,750
放在第一部分，如何

62
00:02:47,750 --> 00:02:50,180
应用规则和启发式方法

63
00:02:50,180 --> 00:02:54,379
来更改查询计划，而

64
00:02:54,379 --> 00:02:57,049
无需检查数据或了解

65
00:02:57,049 --> 00:02:58,519


66
00:02:58,519 --> 00:03:01,489
我们可能需要的数据库内部实际情况

67
00:03:01,489 --> 00:03:02,810
查看目录以了解

68
00:03:02,810 --> 00:03:03,859
我们的属性是什么，无论它们

69
00:03:03,859 --> 00:03:05,629
是否唯一，以及我们是否有

70
00:03:05,629 --> 00:03:07,549
外键，但我们不需要知道

71
00:03:07,549 --> 00:03:09,799
任何关于您知道我们

72
00:03:09,799 --> 00:03:11,299
在表中的值分布看起来像

73
00:03:11,299 --> 00:03:12,889
某种方式或我们 拥有这个数量的

74
00:03:12,889 --> 00:03:15,079
元组，所以这些都是

75
00:03:15,079 --> 00:03:16,189
我们可以做的规则，无需实际

76
00:03:16,189 --> 00:03:19,790
查看了解你知道

77
00:03:19,790 --> 00:03:21,799
元组是什么样子，所以今天我们

78
00:03:21,799 --> 00:03:23,329
将专注于这里的第二

79
00:03:23,329 --> 00:03:26,329
部分 h 是更复杂的部分，

80
00:03:26,329 --> 00:03:27,560
我们现在将使用成本

81
00:03:27,560 --> 00:03:30,799
模型来评估查询计划的

82
00:03:30,799 --> 00:03:33,139
质量或工作量，

83
00:03:33,139 --> 00:03:34,669


84
00:03:34,669 --> 00:03:36,079
而无需在实际运行之前 它

85
00:03:36,079 --> 00:03:38,540
和这里的想法是我们希望

86
00:03:38,540 --> 00:03:40,940
能够枚举尽可能多的查询计划

87
00:03:40,940 --> 00:03:43,699
，然后选择

88
00:03:43,699 --> 00:03:45,560
我们认为最好的任何一个，因此

89
00:03:45,560 --> 00:03:47,030
我们的成本模型越

90
00:03:47,030 --> 00:03:49,220
准确，我们的选择就越准确

91
00:03:49,220 --> 00:03:50,810
。 最好的查询计划是，但

92
00:03:50,810 --> 00:03:53,389
似乎是这样，这是非常

93
00:03:53,389 --> 00:03:54,979
困难的，每个人都会

94
00:03:54,979 --> 00:03:56,750
出错，然后我今天教你的

95
00:03:56,750 --> 00:03:59,180
是一种方法，所以教科书会告诉

96
00:03:59,180 --> 00:04:01,190
你如何去做，这才是

97
00:04:01,190 --> 00:04:03,590
真正的 真的错了，但我们会谈论

98
00:04:03,590 --> 00:04:04,609
一点帮助，我们可能会解决这些

99
00:04:04,609 --> 00:04:05,629
问题，但这是我们可以

100
00:04:05,629 --> 00:04:06,889
在高级课程中恢复的东西，或者如果您学习

101
00:04:06,889 --> 00:04:09,889
更多，您就会知道您可以做到人们

102
00:04:09,889 --> 00:04:11,239
已经完成了关于此类

103
00:04:11,239 --> 00:04:12,979
事情的论文，但它仍然存在 一个未解决的

104
00:04:12,979 --> 00:04:15,919
问题好吧今天 的议程 我们

105
00:04:15,919 --> 00:04:16,820
将首先讨论如何

106
00:04:16,820 --> 00:04:18,500
使用我们的成本模型再次进行计划成本估算

107
00:04:18,500 --> 00:04:19,940
他们只讨论如何进行

108
00:04:19,940 --> 00:04:20,570
计算

109
00:04:20,570 --> 00:04:22,280
我们实际上将如何使用 IntelliJ

110
00:04:22,280 --> 00:04:24,560
智能迭代或不同的

111
00:04:24,560 --> 00:04:26,750
可能查询计划以便找到

112
00:04:26,750 --> 00:04:28,760
我们认为是最好的那个，

113
00:04:28,760 --> 00:04:30,260
因为这又是一个 np-hard 我们无法

114
00:04:30,260 --> 00:04:32,090
进行详尽的搜索，所以我们需要

115
00:04:32,090 --> 00:04:33,440
对我们正在查看的内容保持

116
00:04:33,440 --> 00:04:35,180
清醒，然后我们将完成

117
00:04:35,180 --> 00:04:37,520
讨论必需品，因为 这

118
00:04:37,520 --> 00:04:38,720
与其他所有内容略有不同

119
00:04:38,720 --> 00:04:41,540
，我们可以使用一些规则来

120
00:04:41,540 --> 00:04:43,520
重写它们并提高它们的

121
00:04:43,520 --> 00:04:46,490
效率 所以我们已经讨论

122
00:04:46,490 --> 00:04:48,140
过最后一堂课 我们讨论过这个 我们

123
00:04:48,140 --> 00:04:50,690
说过你知道什么是成本估算

124
00:04:50,690 --> 00:04:52,040
我们的成本模型实际上是什么

125
00:04:52,040 --> 00:04:55,430
反复做它本质上是一种

126
00:04:55,430 --> 00:04:58,130


127
00:04:58,130 --> 00:05:00,230
估算执行查询需要多少工作或多长时间的方法

128
00:05:00,230 --> 00:05:02,240
，一般来说，您总是希望选择

129
00:05:02,240 --> 00:05:04,730
成本最低的那个，因此

130
00:05:04,730 --> 00:05:06,620
这个成本可能是一个组合 您知道

131
00:05:06,620 --> 00:05:08,540
一堆不同的底层港口

132
00:05:08,540 --> 00:05:10,250
指标，因为这

133
00:05:10,250 --> 00:05:11,690
对应于我们实际要做的工作

134
00:05:11,690 --> 00:05:13,790
，所以可能只是

135
00:05:13,790 --> 00:05:15,830
实际要使用多少 CPU 这

136
00:05:15,830 --> 00:05:17,270
通常很难做到，而我们

137
00:05:17,270 --> 00:05:18,830
不这样做 对于基于磁盘的系统，

138
00:05:18,830 --> 00:05:20,390
因为磁盘是主要瓶颈，

139
00:05:20,390 --> 00:05:22,700
但内存系统会关心这个

140
00:05:22,700 --> 00:05:24,050
我们已经讨论过如何

141
00:05:24,050 --> 00:05:25,940
为我们的联合算法计算磁盘 i/o

142
00:05:25,940 --> 00:05:27,290
排序算法这

143
00:05:27,290 --> 00:05:28,520
可能是主要的事情 我们

144
00:05:28,520 --> 00:05:30,680
将专注于我们也关心

145
00:05:30,680 --> 00:05:32,030
我们将使用多少内存 可能

146
00:05:32,030 --> 00:05:33,410
有一种算法使用大量内存

147
00:05:33,410 --> 00:05:36,440
并获得更快的性能，但我们可能

148
00:05:36,440 --> 00:05:37,700
没有实际使用那么多内存

149
00:05:37,700 --> 00:05:39,560
，因此我们想要选择一个

150
00:05:39,560 --> 00:05:42,380
使用较少内存的较慢算法，因为

151
00:05:42,380 --> 00:05:44,060
这将对系统造成较小的压力

152
00:05:44,060 --> 00:05:46,220
，然后对于分布式数据库，

153
00:05:46,220 --> 00:05:47,240
它再次是网络消息的数量

154
00:05:47,240 --> 00:05:48,590
是帐篷中的最高点，

155
00:05:48,590 --> 00:05:51,200
因为通过电线将事物发送到

156
00:05:51,200 --> 00:05:53,840
机器之间 总是很昂贵，

157
00:05:53,840 --> 00:05:56,810
所以一般来说，在高层次上，这些

158
00:05:56,810 --> 00:05:59,180
都将成为我们将

159
00:05:59,180 --> 00:06:00,290
使用我们将访问的元组数量

160
00:06:00,290 --> 00:06:02,570
作为所有这些事情的代理的代理，从

161
00:06:02,570 --> 00:06:05,060
本质上决定

162
00:06:05,060 --> 00:06:06,500
我们获得了多少数据 我们

163
00:06:06,500 --> 00:06:08,360
要从一部歌剧传到下一部

164
00:06:08,360 --> 00:06:09,770
我们可以用它来推导出我们

165
00:06:09,770 --> 00:06:13,700
认为最好的一部 所以我说过我们不能

166
00:06:13,700 --> 00:06:15,890
只是你知道获得最

167
00:06:15,890 --> 00:06:17,930
准确估计的方法 查询

168
00:06:17,930 --> 00:06:19,669
计划要做的实际上只是执行

169
00:06:19,669 --> 00:06:21,350
查询计划，但是如果我们正在查看

170
00:06:21,350 --> 00:06:22,850
成千上万个不同的

171
00:06:22,850 --> 00:06:24,590
可能查询计划，我们不可能

172
00:06:24,590 --> 00:06:27,050
执行每一个，所以我们需要一种

173
00:06:27,050 --> 00:06:30,350
方法来近似这一点，这是

174
00:06:30,350 --> 00:06:31,730
我们的成本模型将要做什么以及

175
00:06:31,730 --> 00:06:34,130
我们将

176
00:06:34,130 --> 00:06:37,250
在我们的数据库系统中使用我们的底层组件的基础概念

177
00:06:37,250 --> 00:06:39,050
我们将使用它来进行

178
00:06:39,050 --> 00:06:42,260
这些估计是数据库系统的内部 Cystic

179
00:06:42,260 --> 00:06:44,720
目录 所以每个

180
00:06:44,720 --> 00:06:46,280
数据库系统 有一个查询

181
00:06:46,280 --> 00:06:47,420
优化

182
00:06:47,420 --> 00:06:49,550
器 正在使用调用空间搜索

183
00:06:49,550 --> 00:06:52,280
将有这个坚持模块，

184
00:06:52,280 --> 00:06:53,930
它允许它收集

185
00:06:53,930 --> 00:06:56,720
有关表格的信息

186
00:06:56,720 --> 00:06:58,040
，元组内部的实际内容

187
00:06:58,040 --> 00:07:00,500
以及收集这些

188
00:07:00,500 --> 00:07:01,880
信息的方式可能因实现而异，

189
00:07:01,880 --> 00:07:05,300
所以所有 主要系统

190
00:07:05,300 --> 00:07:07,130
有一种方法可以强制数据系统

191
00:07:07,130 --> 00:07:09,230
收集新的统计信息 正确分析

192
00:07:09,230 --> 00:07:10,820
分析表更新状态 运行统计信息

193
00:07:10,820 --> 00:07:13,340
这告诉 de 系统嘿

194
00:07:13,340 --> 00:07:15,590
对我的表进行顺序扫描并更新

195
00:07:15,590 --> 00:07:18,560
我的统计信息 一些系统

196
00:07:18,560 --> 00:07:20,060
也来自这个和 cron 作业 就像

197
00:07:20,060 --> 00:07:21,800
每隔一段时间定期

198
00:07:21,800 --> 00:07:23,780
做一次传递一样，所有这些系统都可以

199
00:07:23,780 --> 00:07:25,520
在查询时搭载查询，

200
00:07:25,520 --> 00:07:26,930
并在我进行赞助商扫描时说好的我也会在我进行时

201
00:07:26,930 --> 00:07:29,480
更新我的统计数据

202
00:07:29,480 --> 00:07:31,910
其他系统有触发器

203
00:07:31,910 --> 00:07:35,480
要说 如果我的表的 10% 或 20%

204
00:07:35,480 --> 00:07:37,700
发生了变化，让我启动 run stats

205
00:07:37,700 --> 00:07:41,030
命令并正确更新内容，

206
00:07:41,030 --> 00:07:42,590
没有一种方法可以比另一个通用集合更好地做到这一点

207
00:07:42,590 --> 00:07:46,670


208
00:07:46,670 --> 00:07:48,770
如果您正在运行 OLTP 系统，您会喜欢吗，您

209
00:07:48,770 --> 00:07:50,750
会在白天进行大部分交易时禁用此功能，

210
00:07:50,750 --> 00:07:52,400


211
00:07:52,400 --> 00:07:53,810
但在夜间您可以

212
00:07:53,810 --> 00:07:55,700
通过并更新您的统计数据，因此

213
00:07:55,700 --> 00:07:56,900
在白天它会是 稍微

214
00:07:56,900 --> 00:07:59,830
偏离，但这仍然可以，

215
00:07:59,830 --> 00:08:02,180
因为这样做很昂贵，因为

216
00:08:02,180 --> 00:08:03,350
这件事而且这是

217
00:08:03,350 --> 00:08:08,540
对整个桌子的顺序扫描，所以让我们讨论

218
00:08:08,540 --> 00:08:10,670
一些数学问题，但这是安迪数学而不是难

219
00:08:10,670 --> 00:08:13,310
数学，所以每个人都应该能够

220
00:08:13,310 --> 00:08:13,910
遵循这一点，

221
00:08:13,910 --> 00:08:16,910
所以 我们

222
00:08:16,910 --> 00:08:19,490
要维护的关于每个表的基本主要信息

223
00:08:19,490 --> 00:08:21,650
只是它们拥有的元组

224
00:08:21,650 --> 00:08:24,590
数量以及我们表中每个属性的不同值的数量，

225
00:08:24,590 --> 00:08:26,030


226
00:08:26,030 --> 00:08:28,730
所以我们

227
00:08:28,730 --> 00:08:29,810
实际上将把它作为一个

228
00:08:29,810 --> 00:08:32,840
单独的计数器，因为我们不能

229
00:08:32,840 --> 00:08:34,940
假设您知道我有 X 个

230
00:08:34,940 --> 00:08:37,130
页面，因此我可以容纳 X 个您知道

231
00:08:37,130 --> 00:08:38,840
为什么每个页面中都有元组，并且它是 x 乘以

232
00:08:38,840 --> 00:08:41,960
y，因为同样不是每个

233
00:08:41,960 --> 00:08:43,700
页面中的每个插槽都已满 d 然后我们讨论

234
00:08:43,700 --> 00:08:45,440
多版本并发控制我们

235
00:08:45,440 --> 00:08:47,300
有多个物理副本或

236
00:08:47,300 --> 00:08:48,710


237
00:08:48,710 --> 00:08:50,990
每个逻辑元组的多个物理版本所以我们不能只是

238
00:08:50,990 --> 00:08:52,280
你知道计算我们拥有的块数

239
00:08:52,280 --> 00:08:53,660
我们实际上想要将

240
00:08:53,660 --> 00:08:55,970
它作为一个单独的维护 计数，然后我们将

241
00:08:55,970 --> 00:08:56,840
讨论我们将如何实际

242
00:08:56,840 --> 00:08:59,090
计算或维护此信息

243
00:08:59,090 --> 00:09:01,250
以获得每个属性的不同值的数量，

244
00:09:01,250 --> 00:09:04,759
因此现在有了

245
00:09:04,759 --> 00:09:07,759
这些基本信息，我们现在可以推导出

246
00:09:07,759 --> 00:09:10,670
一个新的统计数据，称为选择

247
00:09:10,670 --> 00:09:13,370
基数 由这个函数 SC 定义

248
00:09:13,370 --> 00:09:16,279
，这只是计算

249
00:09:16,279 --> 00:09:17,990
我们将拥有的平均记录数

250
00:09:17,990 --> 00:09:20,810
或给出具有相同值的属性，

251
00:09:20,810 --> 00:09:24,230
因此对于每个不同的值，

252
00:09:24,230 --> 00:09:26,930
我会说你知道这

253
00:09:26,930 --> 00:09:29,930
是它发生的次数 我们只取

254
00:09:29,930 --> 00:09:31,790
我们拥有的元组的数量，然后除以我们拥有

255
00:09:31,790 --> 00:09:33,500
的唯一属性的数量

256
00:09:33,500 --> 00:09:35,839
，这告诉我们

257
00:09:35,839 --> 00:09:37,129
每个属性出现了多少次有

258
00:09:37,129 --> 00:09:45,889
什么问题 这个 ray 说

259
00:09:45,889 --> 00:09:47,930
一个 like 所以他说一个可能是

260
00:09:47,930 --> 00:09:49,850
一千个可能是一这个

261
00:09:49,850 --> 00:09:52,129
公式显然完全没有把握所以

262
00:09:52,129 --> 00:09:54,199
这是我们

263
00:09:54,199 --> 00:09:55,069
将在整个

264
00:09:55,069 --> 00:09:57,139
讲座中做出的重大假设之一，那就是我们是一个假设

265
00:09:57,139 --> 00:09:59,810
我们有统一的数据，所以这个

266
00:09:59,810 --> 00:10:01,790
公式基本上只是说每个

267
00:10:01,790 --> 00:10:04,730
单独的值出现在每个 C 如果

268
00:10:04,730 --> 00:10:06,259
我在我的表中为这个属性拥有的每个唯一值

269
00:10:06,259 --> 00:10:08,509
它出现

270
00:10:08,509 --> 00:10:11,689
的次数与所有其他值相同，但

271
00:10:11,689 --> 00:10:12,949
我们知道这不是真实的 世界

272
00:10:12,949 --> 00:10:15,350
运行良好，所以以 CMU

273
00:10:15,350 --> 00:10:17,750
为例，我大概有 10,000

274
00:10:17,750 --> 00:10:19,370
名学生，但它比这更多，但它是

275
00:10:19,370 --> 00:10:21,350
简单的数学，我认为

276
00:10:21,350 --> 00:10:23,809
实际上确实有 10 所大学，所以如果你

277
00:10:23,809 --> 00:10:26,269
假设你有统一的数据，那么你

278
00:10:26,269 --> 00:10:27,740
会说所有的 10,000 名

279
00:10:27,740 --> 00:10:30,139
学生 10,000 除以 10，这

280
00:10:30,139 --> 00:10:31,129
就是在读大学的学生人数

281
00:10:31,129 --> 00:10:33,319
每所大学都完全相同，

282
00:10:33,319 --> 00:10:35,089
但我们知道情况并非如此

283
00:10:35,089 --> 00:10:37,610
，我所在的这所计算机科学学校并非如此

284
00:10:37,610 --> 00:10:40,069
这

285
00:10:40,069 --> 00:10:42,860
比学校美术学院的学生多得多 这是一个真实世界的

286
00:10:42,860 --> 00:10:45,350
数据是倾斜的 但

287
00:10:45,350 --> 00:10:46,790
为了让我们今天谈论的数学更容易

288
00:10:46,790 --> 00:10:48,559
我们将假设一切

289
00:10:48,559 --> 00:10:50,959
都是统一的 但同样这是另一个

290
00:10:50,959 --> 00:10:52,370
表格 世界不是这样工作的

291
00:10:52,370 --> 00:10:53,990
现实世界的系统必须

292
00:10:53,990 --> 00:10:56,149
考虑到这一点，我们将简要

293
00:10:56,149 --> 00:10:58,759
讨论如何做到这一点，所以有了

294
00:10:58,759 --> 00:11:00,379
这个选择基数，我们

295
00:11:00,379 --> 00:11:02,930
可以用这口井做什么 我们的目标是

296
00:11:02,930 --> 00:11:05,480
现在弄清楚如何

297
00:11:05,480 --> 00:11:09,290
在我们的谓词扫描期间实际上会选择许多元组，

298
00:11:09,290 --> 00:11:12,230
因为

299
00:11:12,230 --> 00:11:13,429
那时我们需要弄清楚

300
00:11:13,429 --> 00:11:14,880
每个运算符将吐出多少个元组

301
00:11:14,880 --> 00:11:16,410
并将其提供给下一个

302
00:11:16,410 --> 00:11:18,240
运算符，然后我们可以使用它来

303
00:11:18,240 --> 00:11:19,350
计算出有多少工作 他们

304
00:11:19,350 --> 00:11:20,490
实际上会做多少磁盘

305
00:11:20,490 --> 00:11:21,330
他们将使用多少内存

306
00:11:21,330 --> 00:11:23,760
他们将使用多少内存所以我们使用

307
00:11:23,760 --> 00:11:25,050
选择集合基数来计算

308
00:11:25,050 --> 00:11:28,380


309
00:11:28,380 --> 00:11:30,630
我们从我们的子操作员提供的给定输入如何

310
00:11:30,630 --> 00:11:32,780
很多  有多少数据来自我们，

311
00:11:32,780 --> 00:11:36,960
所以如果我们想

312
00:11:36,960 --> 00:11:39,060
在唯一键上获得相等谓词，这是

313
00:11:39,060 --> 00:11:40,920
最容易做的事情，我们的数学会

314
00:11:40,920 --> 00:11:43,080
很好地计算出来，所以说我们有一个

315
00:11:43,080 --> 00:11:45,360
简单的表，我们有一个人表

316
00:11:45,360 --> 00:11:47,910
ID 列是主键，所以如果我

317
00:11:47,910 --> 00:11:49,770
进行查找说 ib 等于一

318
00:11:49,770 --> 00:11:52,740
二三，那么这很容易

319
00:11:52,740 --> 00:11:54,510


320
00:11:54,510 --> 00:11:57,450


321
00:11:57,450 --> 00:11:58,680


322
00:11:58,680 --> 00:12:02,160
表，因为它是一个主键，

323
00:12:02,160 --> 00:12:05,010
它是独一无二的，

324
00:12:05,010 --> 00:12:06,120
现在当您有更复杂的

325
00:12:06,120 --> 00:12:08,310
谓词（如范围谓词或

326
00:12:08,310 --> 00:12:10,380
连词）时，事情变得困难时，因为现在我需要能够

327
00:12:10,380 --> 00:12:11,490


328
00:12:11,490 --> 00:12:12,600


329
00:12:12,600 --> 00:12:15,090
以某种特定且非平凡的

330
00:12:15,090 --> 00:12:20,480
方式组合这些不同谓词的选择基数 所以哦，对不起，

331
00:12:20,480 --> 00:12:23,460
所以基于选择

332
00:12:23,460 --> 00:12:24,810
基数，现在我们将

333
00:12:24,810 --> 00:12:27,450
产生单个谓词的选择性的想法，

334
00:12:27,450 --> 00:12:31,770
所以选择性基本上是一个

335
00:12:31,770 --> 00:12:33,270
函数，表示对于表上的给定谓词，

336
00:12:33,270 --> 00:12:36,030
又是什么 t

337
00:12:36,030 --> 00:12:38,120
是实际要符合条件的数字元组，

338
00:12:38,120 --> 00:12:41,040
所以我们用来

339
00:12:41,040 --> 00:12:42,780
计算它的形式将取决于

340
00:12:42,780 --> 00:12:44,480
我们实际上在做什么类型的操作，

341
00:12:44,480 --> 00:12:46,560
我刚刚向你展示的最后一个是

342
00:12:46,560 --> 00:12:48,300
一个等式谓词 在唯一的

343
00:12:48,300 --> 00:12:51,210
唯一属性上，但您现在知道我们

344
00:12:51,210 --> 00:12:52,380
需要考虑它可能

345
00:12:52,380 --> 00:12:54,570
不是唯一的情况哦，我们正在研究非

346
00:12:54,570 --> 00:12:57,800
您知道的不等式提审范围，

347
00:12:57,800 --> 00:12:59,580
所以让我们在这里看一些简单的示例

348
00:12:59,580 --> 00:13:03,420
，因此现在假设在我们的人员表

349
00:13:03,420 --> 00:13:05,760
中 年龄列我们只有从

350
00:13:05,760 --> 00:13:09,750
0 到 4 的五个唯一值 我说

351
00:13:09,750 --> 00:13:10,680
这样的事情就像不是

352
00:13:10,680 --> 00:13:12,690
存储某人的确切年龄 我们

353
00:13:12,690 --> 00:13:14,400
将他们分成两组，例如

354
00:13:14,400 --> 00:13:16,860
互联网广告或广告商一直

355
00:13:16,860 --> 00:13:18,480
这样做，就像人们一样

356
00:13:18,480 --> 00:13:22,830
年龄 18 18 到 35 35 到 50 等等，所以

357
00:13:22,830 --> 00:13:25,380
我们有五个不同的值，对于我们的

358
00:13:25,380 --> 00:13:28,380
表格，我们有这五个人，所以

359
00:13:28,380 --> 00:13:29,310
如果我们现在想计算

360
00:13:29,310 --> 00:13:31,650
一个平等谓词的选择性，

361
00:13:31,650 --> 00:13:34,320
你知道什么地方等于 ls 是一个

362
00:13:34,320 --> 00:13:37,620
常数，那么我们只需将

363
00:13:37,620 --> 00:13:39,930
我们的谓词

364
00:13:39,930 --> 00:13:41,670
除以我们拥有的元组数量的选择基数，

365
00:13:41,670 --> 00:13:43,050
这将告诉我们

366
00:13:43,050 --> 00:13:45,420
两个男孩在我们的表中匹配的百分比是多少，

367
00:13:45,420 --> 00:13:48,960
所以在这种情况下这里

368
00:13:48,960 --> 00:13:52,050
是 年龄的选择性等于 2 假设

369
00:13:52,050 --> 00:13:54,510
我们有一个简单的所有

370
00:13:54,510 --> 00:13:57,570
元组的直方图，并且因为我们说

371
00:13:57,570 --> 00:13:58,950
我们假设我们的

372
00:13:58,950 --> 00:14:01,740
值分布是均匀的，每个每个

373
00:14:01,740 --> 00:14:04,170
不同的年龄都有一个精确的值或相同

374
00:14:04,170 --> 00:14:06,960
的出现次数，以便计算

375
00:14:06,960 --> 00:14:10,110
选择性它只是把这个

376
00:14:10,110 --> 00:14:11,580
H 的选择基数等于

377
00:14:11,580 --> 00:14:13,530
2 因为它只是一个 你只看

378
00:14:13,530 --> 00:14:15,870
一个值 我们只看

379
00:14:15,870 --> 00:14:18,360
直方图中 你会发现你确切地知道

380
00:14:18,360 --> 00:14:20,430
这个权利的货币数量 所以

381
00:14:20,430 --> 00:14:23,790
它只是五分之一 再次，所以

382
00:14:23,790 --> 00:14:24,810
这里我们假设均匀

383
00:14:24,810 --> 00:14:28,830
分布，我们假设你

384
00:14:28,830 --> 00:14:30,300
会确切地知道这个值是什么

385
00:14:30,300 --> 00:14:32,400
，因此这个数学计算结果很好，

386
00:14:32,400 --> 00:14:35,330
这正是我们 想要，但

387
00:14:35,330 --> 00:14:38,010
我们现在做一些更复杂的事情，

388
00:14:38,010 --> 00:14:40,980
比如获得一个范围谓词，所以现在我们

389
00:14:40,980 --> 00:14:42,510
说我们的年龄大于等于

390
00:14:42,510 --> 00:14:45,570
2 公式在这里

391
00:14:45,570 --> 00:14:47,670
假设我们只是在

392
00:14:47,670 --> 00:14:51,030
看整数 连续我们有

393
00:14:51,030 --> 00:14:52,380
一个连续范围的值，你可以

394
00:14:52,380 --> 00:14:55,140
看到，所以你只需将最大值

395
00:14:55,140 --> 00:14:56,760
除以减去你

396
00:14:56,760 --> 00:14:58,830
期待的值

397
00:14:58,830 --> 00:15:01,170
除以最大值减去最小值的范围，这会告诉

398
00:15:01,170 --> 00:15:02,430
你 Ruffing 与

399
00:15:02,430 --> 00:15:04,320
在这种情况下，选择性是如此，我们正在寻找

400
00:15:04,320 --> 00:15:07,320
大于等于 2 的每个人，因此我们

401
00:15:07,320 --> 00:15:09,570
将最小值和最大值相减，

402
00:15:09,570 --> 00:15:12,150
即 4，然后我们只采用

403
00:15:12,150 --> 00:15:13,440
我们正在寻找的值和

404
00:15:13,440 --> 00:15:15,390
我们想要的高值，它是 4 减 2

405
00:15:15,390 --> 00:15:19,980
是 1 超过 2 所以这是错误的

406
00:15:19,980 --> 00:15:22,920
正确答案实际上是 3/5 但

407
00:15:22,920 --> 00:15:26,550
公式计算的方式我们得到 1/2 所以

408
00:15:26,550 --> 00:15:27,840
这是一个很好的例子，就像这些

409
00:15:27,840 --> 00:15:29,580
公式并不总是正确工作

410
00:15:29,580 --> 00:15:31,620
在这种情况下，他们会产生错误，

411
00:15:31,620 --> 00:15:34,530
我们在 esti 匹配

412
00:15:34,530 --> 00:15:38,250
选择性它应该是 3/5 而不是 1/2 所以

413
00:15:38,250 --> 00:15:40,980
当你知道你什么

414
00:15:40,980 --> 00:15:42,120
时候开始做

415
00:15:42,120 --> 00:15:43,800
你知道一个复杂

416
00:15:43,800 --> 00:15:44,910
查询的估计时会有问题，这些查询有一堆不同的

417
00:15:44,910 --> 00:15:46,170
粒子和不同的运算符，

418
00:15:46,170 --> 00:15:47,670
因为现在我们有错误 建立在

419
00:15:47,670 --> 00:15:49,620
错误上 建立在错误上 所以说这

420
00:15:49,620 --> 00:15:51,180
就像我们在

421
00:15:51,180 --> 00:15:52,920
树的底部进行扫描 我们现在

422
00:15:52,920 --> 00:15:54,240
低估了

423
00:15:54,240 --> 00:15:55,529
我们要生产的两个男孩的数量 我们现在要生产作为

424
00:15:55,529 --> 00:15:58,439
我们的输出 我们

425
00:15:58,439 --> 00:16:00,809
在上面进行计算，现在我们将错误的输入

426
00:16:00,809 --> 00:16:02,939
或错误的估计作为

427
00:16:02,939 --> 00:16:04,620
我们对操作员的输入，然后

428
00:16:04,620 --> 00:16:06,389
对它们进行更多错误的数学运算并产生更多

429
00:16:06,389 --> 00:16:10,139
错误，因此在许多情况下或研究

430
00:16:10,139 --> 00:16:12,600
表明，几乎实际上对于每

431
00:16:12,600 --> 00:16:13,829
一个 他们

432
00:16:13,829 --> 00:16:15,689
为这篇特定论文评估的数据库系统 每个人都

433
00:16:15,689 --> 00:16:18,329
低估了所有

434
00:16:18,329 --> 00:16:21,240
这些运算符的选择性，你可能会说哦，谁

435
00:16:21,240 --> 00:16:22,740
在乎这

436
00:16:22,740 --> 00:16:24,870
有什么大不了的，但是现在当你开始

437
00:16:24,870 --> 00:16:27,839
评估你的 你知道你的数据

438
00:16:27,839 --> 00:16:29,220
结构你喜欢你的联合你的哈希

439
00:16:29,220 --> 00:16:31,050
表连接你的缓冲区进行

440
00:16:31,050 --> 00:16:32,519
排序现在你会低估

441
00:16:32,519 --> 00:16:35,040
这些大小是什么

442
00:16:35,040 --> 00:16:36,870
，一旦你意识到我有

443
00:16:36,870 --> 00:16:38,040
更多的数据比他们实际上没有

444
00:16:38,040 --> 00:16:40,920
预期的更多，你可能必须纠正这一点 对系统有真正的运行时

445
00:16:40,920 --> 00:16:43,709
影响，而且

446
00:16:43,709 --> 00:16:45,420
我们现在正在做出错误的估计，

447
00:16:45,420 --> 00:16:47,339
你知道什么计划可能比

448
00:16:47,339 --> 00:16:51,720
另一个更好，我想看的最后一件事

449
00:16:51,720 --> 00:16:53,189
是否定这个

450
00:16:53,189 --> 00:16:54,269
非常简单，它只是

451
00:16:54,269 --> 00:16:55,829
一个减去无论什么

452
00:16:55,829 --> 00:16:58,259
我们想要正确的谓词的选择性，因此在

453
00:16:58,259 --> 00:16:59,999
这种情况下，年龄的选择基数

454
00:16:59,999 --> 00:17:02,339
等于 2，因此否定

455
00:17:02,339 --> 00:17:04,309
只是该权利之外的边界

456
00:17:04,309 --> 00:17:06,809
，您会得到 4/5，这是该

457
00:17:06,809 --> 00:17:08,789
权利的正确答案，

458
00:17:08,789 --> 00:17:10,020
因为假设 某物等于

459
00:17:10,020 --> 00:17:13,319
某物 所以我们

460
00:17:13,319 --> 00:17:15,559
可以对此做出的主要观察是，

461
00:17:15,559 --> 00:17:18,409
谓词的选择性估计

462
00:17:18,409 --> 00:17:20,220
基本上与概率

463
00:17:20,220 --> 00:17:23,369
相同 是的，它只是

464
00:17:23,369 --> 00:17:24,898
说一个元组

465
00:17:24,898 --> 00:17:29,250
匹配我给定的谓词的概率是多少，所以如果我们

466
00:17:29,250 --> 00:17:31,590
现在做出这个假设，我们可以使用

467
00:17:31,590 --> 00:17:33,870
我们从统计 101 中学到的所有技巧

468
00:17:33,870 --> 00:17:36,419
来开始

469
00:17:36,419 --> 00:17:38,940
将这些

470
00:17:38,940 --> 00:17:42,659
谓词组合在一起 更复杂的方式所以

471
00:17:42,659 --> 00:17:43,830
假设现在我们想要一个合

472
00:17:43,830 --> 00:17:46,049
取你知道年龄等于一个

473
00:17:46,049 --> 00:17:50,880
命名就像你知道一个通配符所以我们

474
00:17:50,880 --> 00:17:52,559
将

475
00:17:52,559 --> 00:17:53,909
在第一个谓词上的计算选择性等于

476
00:17:53,909 --> 00:17:55,920
计算第二个谓词的第二个

477
00:17:55,920 --> 00:17:57,929
选择性和

478
00:17:57,929 --> 00:18:00,270
那么现在我们只需将它们组合或

479
00:18:00,270 --> 00:18:03,480
将 B 与两个概率

480
00:18:03,480 --> 00:18:05,190
相乘，我们就在这里得到我们的交集

481
00:18:05,190 --> 00:18:07,620
，这就是你知道我们会

482
00:18:07,620 --> 00:18:09,420
说它必须是完全匹配的地方我们很

483
00:18:09,420 --> 00:18:11,040
抱歉我们必须同时匹配这两个

484
00:18:11,040 --> 00:18:15,600
内部部分在这里对，

485
00:18:15,600 --> 00:18:17,010
对于析取析取也是如此

486
00:18:17,010 --> 00:18:18,420
，形式略有不同，但是

487
00:18:18,420 --> 00:18:20,190
您只是

488
00:18:20,190 --> 00:18:22,320
假设它们是独立的，

489
00:18:22,320 --> 00:18:23,910
因此您可以使用 th

490
00:18:23,910 --> 00:18:25,890
找出联合是什么的标准数学技巧

491
00:18:25,890 --> 00:18:30,179


492
00:18:30,179 --> 00:18:32,419
所以到目前为止我已经讨论了两个有问题的假设，

493
00:18:32,419 --> 00:18:34,590
但这又是

494
00:18:34,590 --> 00:18:37,040
每本教科书涵盖它

495
00:18:37,040 --> 00:18:39,210
的方式，第一个是我们假设我们的

496
00:18:39,210 --> 00:18:40,710
数据是统一的，但我 展示了一个简单的

497
00:18:40,710 --> 00:18:42,000
例子，但事实并非如此，

498
00:18:42,000 --> 00:18:45,299
然后现在我们假设我们的

499
00:18:45,299 --> 00:18:48,240
数据在谓词中是

500
00:18:48,240 --> 00:18:50,880
独立的，但情况并非总是

501
00:18:50,880 --> 00:18:52,890
如此——实际上，

502
00:18:52,890 --> 00:18:54,150
他们总是会做出第三个假设，这是

503
00:18:54,150 --> 00:18:55,830
有问题的，它被称为 联合

504
00:18:55,830 --> 00:18:58,110
包含原则，所以

505
00:18:58,110 --> 00:18:59,460
我们对计算谓词的基数做了很多

506
00:18:59,460 --> 00:19:00,780


507
00:19:00,780 --> 00:19:03,390
假设，使数学更容易，

508
00:19:03,390 --> 00:19:04,710
但最终会让我们产生

509
00:19:04,710 --> 00:19:07,260
不正确的近似值，因此

510
00:19:07,260 --> 00:19:08,850
统一数据再次假设一切

511
00:19:08,850 --> 00:19:11,490
都将成为曲线 同样的

512
00:19:11,490 --> 00:19:13,980
概率，如果你真的有倾斜的数据并且有十列，

513
00:19:13,980 --> 00:19:15,900
那么对于重量级的击球手来说，解决这个问题的方法就是如此重量级的击球手

514
00:19:15,900 --> 00:19:17,790


515
00:19:17,790 --> 00:19:20,070


516
00:19:20,070 --> 00:19:22,530
或发生的十个值你知道

517
00:19:22,530 --> 00:19:24,660
大部分时间你可以维护一个

518
00:19:24,660 --> 00:19:26,220
单独的哈希表或直方图来

519
00:19:26,220 --> 00:19:28,140
跟踪那些人然后

520
00:19:28,140 --> 00:19:29,400
其他人你只需假设他的制服并

521
00:19:29,400 --> 00:19:32,190
现在推导出贲门和基数

522
00:19:32,190 --> 00:19:34,140
估计基于此

523
00:19:34,140 --> 00:19:35,460
解决统一

524
00:19:35,460 --> 00:19:37,830
数据问题的标准技巧，然后我们讨论了

525
00:19:37,830 --> 00:19:39,150
独立谓词，这样我

526
00:19:39,150 --> 00:19:42,000
就可以使用两个谓词，如果有

527
00:19:42,000 --> 00:19:43,919
连接，只需将它们相乘

528
00:19:43,919 --> 00:19:48,059
以产生组合基数，

529
00:19:48,059 --> 00:19:50,600
然后包含原则说，

530
00:19:50,600 --> 00:19:53,820
如果我是 对两个表进行连接，然后

531
00:19:53,820 --> 00:19:56,429
对于内表中的每个元组，

532
00:19:56,429 --> 00:19:58,350
我都会有一个与外表匹配的元组，

533
00:19:58,350 --> 00:20:01,169
但情况并非

534
00:20:01,169 --> 00:20:03,660
总是如此，但您知道如何

535
00:20:03,660 --> 00:20:05,309
思考这个问题，就像我为什么要连接两个

536
00:20:05,309 --> 00:20:07,140
表如果他们没有办法

537
00:20:07,140 --> 00:20:08,429
实际加入他们没有实际

538
00:20:08,429 --> 00:20:09,810
对应的值会匹配

539
00:20:09,810 --> 00:20:12,840
所以我们做出这个假设但在

540
00:20:12,840 --> 00:20:14,280
现实世界中它并不总是会

541
00:20:14,280 --> 00:20:15,300
你能得到你的情况你可能有

542
00:20:15,300 --> 00:20:17,640
悬空你知道呃你可能有

543
00:20:17,640 --> 00:20:18,930
你不知道存在

544
00:20:18,930 --> 00:20:22,920
于外部表中的引用，所以

545
00:20:22,920 --> 00:20:23,760
这两个可能是最

546
00:20:23,760 --> 00:20:26,070
有问题的，这个发生了，更

547
00:20:26,070 --> 00:20:27,570
高级的事情我们没有 需要

548
00:20:27,570 --> 00:20:30,810
担心所以我总是喜欢展示这个

549
00:20:30,810 --> 00:20:33,650
例子来强调并

550
00:20:33,650 --> 00:20:37,410
说明为什么这是有问题的，这

551
00:20:37,410 --> 00:20:39,510
来自一位

552
00:20:39,510 --> 00:20:42,150
前 IBM 研究人员撰写的博客文章，所以小柠檬

553
00:20:42,150 --> 00:20:44,640
像早期的

554
00:20:44,640 --> 00:20:47,070
早期一样工作 1980 年代末

555
00:20:47,070 --> 00:20:49,050
或 1990 年代的 IBM 优化器实际上

556
00:20:49,050 --> 00:20:51,030
今天仍然在 db2 中使用，它非常有影响力，

557
00:20:51,030 --> 00:20:52,380
所以他有一篇博客文章，但他喜欢在

558
00:20:52,380 --> 00:20:55,470
这里向您展示我们在这里所做的假设有问题的原因

559
00:20:55,470 --> 00:20:58,260


560
00:20:58,260 --> 00:20:59,760
假设我们有一个数据库 一个

561
00:20:59,760 --> 00:21:02,400
汽车表，我们有两个属性，

562
00:21:02,400 --> 00:21:04,530
我们有品牌和型号，

563
00:21:04,530 --> 00:21:07,260
所以品牌会像本田丰田

564
00:21:07,260 --> 00:21:09,720
特斯拉，模型会像凯美瑞雅

565
00:21:09,720 --> 00:21:10,820
阁，

566
00:21:10,820 --> 00:21:13,860
你知道护送，然后说我们有一个

567
00:21:13,860 --> 00:21:16,650
查询 说其中 make 等于 Honda

568
00:21:16,650 --> 00:21:20,070
并且 model 等于 Accord 所以如果

569
00:21:20,070 --> 00:21:21,870
你假设我们到目前为止已经

570
00:21:21,870 --> 00:21:23,250


571
00:21:23,250 --> 00:21:25,590
对数据的独立性和一致性做出了两个假设，

572
00:21:25,590 --> 00:21:28,590
那么当我们将这两个

573
00:21:28,590 --> 00:21:30,480
谓词结合在一起时，我们会说

574
00:21:30,480 --> 00:21:32,160
一个 10 因为那是我们有 10 个

575
00:21:32,160 --> 00:21:34,380
品牌，本田的 1 所以是 1 比 10

576
00:21:34,380 --> 00:21:36,720
然后我们有 1 比 100 模型

577
00:21:36,720 --> 00:21:38,220
因为我们有一百个模型协议

578
00:21:38,220 --> 00:21:40,530
是其中之一所以我们将它们

579
00:21:40,530 --> 00:21:42,780
相乘，我们的基数估计

580
00:21:42,780 --> 00:21:47,370
将是 0.001 但是 作为人类

581
00:21:47,370 --> 00:21:48,690
，我们知道这些值实际上是

582
00:21:48,690 --> 00:21:50,640
相关的，或者这两个谓词是

583
00:21:50,640 --> 00:21:52,740
相关的，就像你不能达成一致，

584
00:21:52,740 --> 00:21:54,570
就像没有其他汽车制造商会

585
00:21:54,570 --> 00:21:55,890
达成一致，它只有

586
00:21:55,890 --> 00:21:58,830
本田，所以如果你知道模型等于

587
00:21:58,830 --> 00:22:01,440
一致，你就可以 知道

588
00:22:01,440 --> 00:22:04,680
制造商必须是本田，所以

589
00:22:04,680 --> 00:22:06,300
这个特定查询的正确选择性

590
00:22:06,300 --> 00:22:09,870
实际上是 1 比 100，所以我们

591
00:22:09,870 --> 00:22:12,330
与公式实际要的数量级相差一个数量级

592
00:22:12,330 --> 00:22:13,440
我们认为

593
00:22:13,440 --> 00:22:17,720
我们来自我们实际上应该是什么

594
00:22:18,299 --> 00:22:29,190
所以问题是如果你有一个

595
00:22:29,190 --> 00:22:30,899
外键会让你的生活

596
00:22:30,899 --> 00:22:33,469
更轻松

597
00:22:34,580 --> 00:22:37,589
不但是你会发生没有

598
00:22:37,589 --> 00:22:44,399
外键孩子是否是唯一的，

599
00:22:44,399 --> 00:22:47,099
因为它可能是一个 到 N 或一对一，

600
00:22:47,099 --> 00:22:48,389
您必须对此有所了解

601
00:22:48,389 --> 00:22:49,889
，但即使如此，我

602
00:22:49,889 --> 00:22:53,159
认为此泡菜示例的外键对

603
00:22:53,159 --> 00:22:57,779
您没有帮助，但我想，但如果

604
00:22:57,779 --> 00:23:00,029
是一张桌子，那么像这样的一张桌子就像一张桌子一样

605
00:23:00,029 --> 00:23:01,829
我所有的汽车

606
00:23:01,829 --> 00:23:03,059
或品牌都等于本田，模型

607
00:23:03,059 --> 00:23:05,309
等于法院，当它没有任何关系时，

608
00:23:05,309 --> 00:23:07,379
就像你知道我们在做联合权利

609
00:23:07,379 --> 00:23:10,469
我需要考虑

610
00:23:10,469 --> 00:23:12,269
关节是否受伤是否外键

611
00:23:12,269 --> 00:23:13,409
有帮助，但是 我们可以

612
00:23:13,409 --> 00:23:16,669
再次离线，就像我们自动

613
00:23:16,669 --> 00:23:18,989
开始估计

614
00:23:18,989 --> 00:23:20,309
我们实际上需要为我们的查询计划做多少工作，

615
00:23:20,309 --> 00:23:22,769
并调整我们的

616
00:23:22,769 --> 00:23:23,909
中间数据结构和我们的

617
00:23:23,909 --> 00:23:27,839
缓冲区，我们将

618
00:23:27,839 --> 00:23:29,759
远离独立假设和 它是 

619
00:23:29,759 --> 00:23:31,320
这将导致我们低估

620
00:23:31,320 --> 00:23:34,440
我们实际要做的工作量，

621
00:23:34,440 --> 00:23:35,609
因此解决这个特定

622
00:23:35,609 --> 00:23:37,229
问题的方法是

623
00:23:37,229 --> 00:23:38,549
我认为高端商业

624
00:23:38,549 --> 00:23:40,739
系统实际上唯一要做的就是进行相关的

625
00:23:40,739 --> 00:23:42,749
列统计，所以我 可以告诉

626
00:23:42,749 --> 00:23:45,059
数据库系统所有正确的模型是

627
00:23:45,059 --> 00:23:47,669
相关的

628
00:23:47,669 --> 00:23:50,039
如果我知道我的模型是

629
00:23:50,039 --> 00:23:52,919
一致的我就不能达成协议我知道我的品牌是另一个

630
00:23:52,919 --> 00:23:55,109
例子如果我知道我的

631
00:23:55,109 --> 00:23:58,049
邮政编码 地址字段是五

632
00:23:58,049 --> 00:24:00,239
到一七，我知道州

633
00:24:00,239 --> 00:24:03,419
必须是宾夕法尼亚州所以如果你

634
00:24:03,419 --> 00:24:05,039


635
00:24:05,039 --> 00:24:07,289
现在将这些列声明为相关数据库是我们

636
00:24:07,289 --> 00:24:10,289
你可以知道特殊情况它是

637
00:24:10,289 --> 00:24:14,039
为了避免这些陷阱的估计它可以知道

638
00:24:14,039 --> 00:24:15,389
这些东西是相关的，因此它

639
00:24:15,389 --> 00:24:17,339
可以使用正确的公式来推导出

640
00:24:17,339 --> 00:24:20,009
它的选择性，但正如我所说的，只有

641
00:24:20,009 --> 00:24:23,119
高端系统的学生是的，

642
00:24:24,570 --> 00:24:26,710
这里有问题或保存它

643
00:24:26,710 --> 00:24:27,850
不需要知道它是如何相关的，只要

644
00:24:27,850 --> 00:24:29,680
它们是 相关我必须

645
00:24:29,680 --> 00:24:31,180
去看看语法和支持

646
00:24:31,180 --> 00:24:33,190
我想你只是说它们是相关的

647
00:24:33,190 --> 00:24:36,610
，它应该弄清楚是的，就像我

648
00:24:36,610 --> 00:24:40,110
认为只有 Oracle 续集服务器 db2

649
00:24:40,110 --> 00:24:43,570
Teradata 也许雪花可以做到这一点，但

650
00:24:43,570 --> 00:24:44,680
就像我的续集和 Postgres 一样

651
00:24:44,680 --> 00:24:47,020
据我所知

652
00:24:47,020 --> 00:24:51,100
，不要这样做续集精简版有点我不能这样做所以现在让我们

653
00:24:51,100 --> 00:24:52,380
谈谈我们实际上将如何

654
00:24:52,380 --> 00:24:55,030
获得这些信息

655
00:24:55,030 --> 00:24:56,470


656
00:24:56,470 --> 00:25:00,310
每个值，所以

657
00:25:00,310 --> 00:25:01,150
我之前已经提到了这一点

658
00:25:01,150 --> 00:25:03,280
，但数据库系统

659
00:25:03,280 --> 00:25:05,890
将在内部维护直方图

660
00:25:05,890 --> 00:25:09,160
以跟踪 e 统计数据，

661
00:25:09,160 --> 00:25:10,660
因此最简单的直方图将用于

662
00:25:10,660 --> 00:25:12,040
我在我的列中拥有的每个不同的值

663
00:25:12,040 --> 00:25:14,410
只需计算

664
00:25:14,410 --> 00:25:17,050
我正确的出现次数，因此在这种

665
00:25:17,050 --> 00:25:19,240
情况下，这是我们的统一数据，因此我

666
00:25:19,240 --> 00:25:22,240
有 15 个唯一值，您知道每个值

667
00:25:22,240 --> 00:25:26,110
都出现了五次，所以现在我们

668
00:25:26,110 --> 00:25:27,540
想说您知道 tup 的数量是多少

669
00:25:27,540 --> 00:25:29,590
匹配你的文件

670
00:25:29,590 --> 00:25:31,270
只知道等于五

671
00:25:31,270 --> 00:25:32,950


672
00:25:32,950 --> 00:25:36,220


673
00:25:36,220 --> 00:25:39,720


674
00:25:39,720 --> 00:25:42,280
像

675
00:25:42,280 --> 00:25:44,020
这样这很好，因为现在我们可以说

676
00:25:44,020 --> 00:25:45,700
你知道有多少个元组有

677
00:25:45,700 --> 00:25:48,180
五个我们会知道确切的值

678
00:25:48,180 --> 00:25:52,200
这有什么问题尽管对于

679
00:25:53,640 --> 00:25:56,320
我列中的每个值我都

680
00:25:56,320 --> 00:25:58,090
存储了一个条目和我的哈希表

681
00:25:58,090 --> 00:26:00,820
从一个很大的直方图中我

682
00:26:00,820 --> 00:26:02,710
假设很快这如果这里的计数

683
00:26:02,710 --> 00:26:05,320
就像 32 位 所以我

684
00:26:05,320 --> 00:26:08,430
在这里的简单示例 我有 15 个唯一值 所以你知道

685
00:26:08,430 --> 00:26:12,040
15 次 32 位大约 50 60 KB

686
00:26:12,040 --> 00:26:15,460
或 50 对不起 50 60 字节到没有 但是

687
00:26:15,460 --> 00:26:17,320
现在如果我有 10 亿个唯一

688
00:26:17,320 --> 00:26:18,700
值，并且我是每个唯一值的 32 位整数，那么

689
00:26:18,700 --> 00:26:22,540
现在 10 亿

690
00:26:22,540 --> 00:26:25,990
次 32 位是 4 GB

691
00:26:25,990 --> 00:26:27,430
好吧，这只是

692
00:26:27,430 --> 00:26:30,370
一列的直方图，所以现在我

693
00:26:30,370 --> 00:26:33,220
对每一列都这样做，所以没有人

694
00:26:33,220 --> 00:26:34,420
是 实际上要存储这样的精确值，

695
00:26:34,420 --> 00:26:35,890
除了我之前谈到的重击者的

696
00:26:35,890 --> 00:26:37,510
东西，

697
00:26:37,510 --> 00:26:38,710
所以重击者将拥有

698
00:26:38,710 --> 00:26:40,690
确切的值，但您可能只存储

699
00:26:40,690 --> 00:26:43,210


700
00:26:43,210 --> 00:26:44,290
每个列的前 10 或 20 个唯一值。 不要

701
00:26:44,290 --> 00:26:47,380
为每一个可能的都存储这个，所以

702
00:26:47,380 --> 00:26:49,210
解决这个问题的方法是开始

703
00:26:49,210 --> 00:26:52,270
将这些值组合到

704
00:26:52,270 --> 00:26:55,000
桶中，这样我们只为桶存储一个

705
00:26:55,000 --> 00:26:57,330
值，而不是为桶

706
00:26:57,330 --> 00:26:59,020
的每个元素存储一个单独的值，

707
00:26:59,020 --> 00:27:02,110
所以 这

708
00:27:02,110 --> 00:27:03,430
将被称为具有直方图的权益，

709
00:27:03,430 --> 00:27:06,910
所以基本上是取这里的每三个

710
00:27:06,910 --> 00:27:09,010
值计算无论计数

711
00:27:09,010 --> 00:27:11,290
是该桶中每个值的所有出现次数的总和，

712
00:27:11,290 --> 00:27:12,970


713
00:27:12,970 --> 00:27:15,580
然后现在我的新直方图只有那个

714
00:27:15,580 --> 00:27:19,330
聚合值，所以我 正在做

715
00:27:19,330 --> 00:27:21,100
我正在做 3 号桶，但你

716
00:27:21,100 --> 00:27:22,600
甚至可以不按你

717
00:27:22,600 --> 00:27:25,090
想要的方式调整它们的大小，所以现在获得估计的方法

718
00:27:25,090 --> 00:27:27,760
是说你知道有

719
00:27:27,760 --> 00:27:30,220
多少次出现的次数 我会

720
00:27:30,220 --> 00:27:32,170
看看我正在寻找的价值属于哪个桶，

721
00:27:32,170 --> 00:27:34,240
所以 2

722
00:27:34,240 --> 00:27:36,490
介于 1 和 3 之间，然后我会

723
00:27:36,490 --> 00:27:38,200
说这里的计数是多少，所以在这种情况下，

724
00:27:38,200 --> 00:27:40,900
大约 9 我有 3 个值，所以我将 9

725
00:27:40,900 --> 00:27:43,180
除以 到 3 时，现在我估计

726
00:27:43,180 --> 00:27:48,700
2 发生了 3 次，所以

727
00:27:48,700 --> 00:27:50,110
我们再次节省空间以节省

728
00:27:50,110 --> 00:27:51,430
维护直方图的计算开销，

729
00:27:51,430 --> 00:27:52,900
但现在我们再次

730
00:27:52,900 --> 00:27:54,160
在我们的近似值中引入更多错误，

731
00:27:54,160 --> 00:27:56,560
因为我们没有

732
00:27:56,560 --> 00:27:57,670
其他 除了

733
00:27:57,670 --> 00:28:02,680
存储精确值之外，解决这个问题的方法也不是

734
00:28:02,680 --> 00:28:04,060
很好，因为现在我可以

735
00:28:04,060 --> 00:28:06,190
在这个桶之间回到这里，

736
00:28:06,190 --> 00:28:09,760
右边 8 的计数很高，7 和 9 的数量

737
00:28:09,760 --> 00:28:11,470
要低得多，但是当我将

738
00:28:11,470 --> 00:28:13,450
它们组合在一起时，我 不知道哪一个

739
00:28:13,450 --> 00:28:16,300
实际上有很高的计数，我的

740
00:28:16,300 --> 00:28:17,620
重量级击球手可以处理，我们

741
00:28:17,620 --> 00:28:20,980
现在可以忽略它，所以更好的方法

742
00:28:20,980 --> 00:28:22,860
是使用分位数，

743
00:28:22,860 --> 00:28:25,330
所以我们要做的就是

744
00:28:25,330 --> 00:28:28,090
我们' 我们要改变

745
00:28:28,090 --> 00:28:29,920
我们的 buc 的宽度 kets 所以最后

746
00:28:29,920 --> 00:28:31,090
一个带扣总是相同的宽度，

747
00:28:31,090 --> 00:28:32,950
但现在我们要改变宽度，

748
00:28:32,950 --> 00:28:36,490
这样每个桶的计数

749
00:28:36,490 --> 00:28:41,110
总和大致相同，所以在

750
00:28:41,110 --> 00:28:42,940
这种情况下，我可以拥有第一个

751
00:28:42,940 --> 00:28:44,980
桶 从 1 到 5 的值

752
00:28:44,980 --> 00:28:47,320
计数变为 2 6 7 & 8

753
00:28:47,320 --> 00:28:49,960
有 3 3 个计数值 12

754
00:28:49,960 --> 00:28:51,370
抱歉的律师 12 帐户

755
00:28:51,370 --> 00:28:55,360
12 9 和 12 等现在我有可变

756
00:28:55,360 --> 00:28:57,490
长度的桶，但现在我

757
00:28:57,490 --> 00:28:58,360
可能有更准确的

758
00:28:58,360 --> 00:29:01,420
估计

759
00:29:01,420 --> 00:29:05,020
这些桶中值的出现，然后是

760
00:29:05,020 --> 00:29:06,340
这个，我在这里展示了分位数，你

761
00:29:06,340 --> 00:29:07,960
可以做十分位数和其他

762
00:29:07,960 --> 00:29:11,470
分组大小，所以关于这个的任何问题，

763
00:29:11,470 --> 00:29:12,670
这就是我们在

764
00:29:12,670 --> 00:29:14,920
运行分析或运行

765
00:29:14,920 --> 00:29:16,630
统计时要填充的内容 我们的数据库系统它将

766
00:29:16,630 --> 00:29:18,220
为我们生成这些信息并将其

767
00:29:18,220 --> 00:29:20,980
存储在我们的目录中，

768
00:29:20,980 --> 00:29:22,330
并且当我们重新启动系统时它是持久的和磁盘

769
00:29:22,330 --> 00:29:23,860
我们回来我们不再运行

770
00:29:23,860 --> 00:29:26,500
分析我们所有的统计数据仍然

771
00:29:26,500 --> 00:29:38,190
存在是的这个问题是如果我 现在添加

772
00:29:38,190 --> 00:29:41,380
如果我再将 10 和 10 个值添加到 5 中，那么

773
00:29:41,380 --> 00:29:44,770
现在它会增加我的直方图中将发生的情况，

774
00:29:44,770 --> 00:29:47,559
因此

775
00:29:47,559 --> 00:29:49,000
每次运行分析时都会被吹走我会重新计算

776
00:29:49,000 --> 00:29:51,190
所有内容，所以是的，在这种情况下它可能

777
00:29:51,190 --> 00:29:53,559
会改变现在的大小

778
00:29:53,559 --> 00:29:56,470
存储桶的

779
00:29:56,470 --> 00:29:58,809
正确，据您所知，在大多数系统中，

780
00:29:58,809 --> 00:30:00,940
它们不会在您

781
00:30:00,940 --> 00:30:02,380
进行插入和更新时维护这些东西，因为它

782
00:30:02,380 --> 00:30:04,450
太贵了，因为

783
00:30:04,450 --> 00:30:06,580
在周三再次讨论事务，但是

784
00:30:06,580 --> 00:30:08,740
当我运行事务时，我想要 为了

785
00:30:08,740 --> 00:30:10,630
最大限度地减少工作量我必须做的

786
00:30:10,630 --> 00:30:12,760
任何现在不重要的事情

787
00:30:12,760 --> 00:30:13,240


788
00:30:13,240 --> 00:30:15,220
我想要我会推迟到以后

789
00:30:15,220 --> 00:30:18,309
因为我在元组上持有锁

790
00:30:18,309 --> 00:30:20,410
并且这会干扰同时运行的其他其他

791
00:30:20,410 --> 00:30:22,390
事务所以

792
00:30:22,390 --> 00:30:23,770
我 不想在我继续的时候保持这个

793
00:30:23,770 --> 00:30:25,330
你可以说好吧我

794
00:30:25,330 --> 00:30:27,940
可以像一个单独的后台

795
00:30:27,940 --> 00:30:30,010
线程可以查看日志中最近的

796
00:30:30,010 --> 00:30:31,240
更改然后去应用这些更改

797
00:30:31,240 --> 00:30:33,250
是的你可以这样做一些公民可能

798
00:30:33,250 --> 00:30:35,260
会这样做 但总的来说，每个人都会

799
00:30:35,260 --> 00:30:38,110
从头开始研究

800
00:30:38,110 --> 00:30:39,610
，尝试进行动态更新

801
00:30:39,610 --> 00:30:43,210
的一个系统是 IBM db2 Zo 的 leo

802
00:30:43,210 --> 00:30:44,980
学习优化器，他们很大，它

803
00:30:44,980 --> 00:30:46,840
会运行扫描，他们可以返回并

804
00:30:46,840 --> 00:30:49,750
更新这个东西，但你 知道它有

805
00:30:49,750 --> 00:30:55,290
问题

806
00:30:55,290 --> 00:31:00,120
所以直方图和这些和

807
00:31:00,120 --> 00:31:01,620
草图 我们做了草图 但就像

808
00:31:01,620 --> 00:31:03,420
这些直方图和重量级的东西

809
00:31:03,420 --> 00:31:05,340
这就是你知道这是

810
00:31:05,340 --> 00:31:07,770
一种最多的数据系统来做这件事的另一种

811
00:31:07,770 --> 00:31:10,410
选择，而不是使用这些

812
00:31:10,410 --> 00:31:12,480
这些 这些额外的数据结构

813
00:31:12,480 --> 00:31:15,150
是我们可以只维护

814
00:31:15,150 --> 00:31:17,190
表的样本并从样本中派生出我们的系统，

815
00:31:17,190 --> 00:31:19,800
所以关于

816
00:31:19,800 --> 00:31:22,290
历史波段的任何事情就像它本质

817
00:31:22,290 --> 00:31:27,090


818
00:31:27,090 --> 00:31:29,730
上是表数据库的低分辨率副本，它是一个

819
00:31:29,730 --> 00:31:33,000
近似值 其他内容，

820
00:31:33,000 --> 00:31:34,590
而不是拥有这些直方图并

821
00:31:34,590 --> 00:31:36,110
尝试从中推导出系统

822
00:31:36,110 --> 00:31:38,490
我们实际上只是

823
00:31:38,490 --> 00:31:40,680
复制了表格本身的较小副本，

824
00:31:40,680 --> 00:31:43,320
然后 在那个较小的副本上运行我们的谓词

825
00:31:43,320 --> 00:31:45,720
，然后假设

826
00:31:45,720 --> 00:31:47,280
该样本中值的分布

827
00:31:47,280 --> 00:31:49,770
与

828
00:31:49,770 --> 00:31:52,080
真实表中存在的相同，因此

829
00:31:52,080 --> 00:31:53,880
我们从样本中得出的任何选择性估计都

830
00:31:53,880 --> 00:31:55,740
将准确反映

831
00:31:55,740 --> 00:31:58,920
真实表中的内容

832
00:31:58,920 --> 00:32:00,780
假设我们有我们的 people 表，我们

833
00:32:00,780 --> 00:32:02,910
有十亿个元组，然后假设

834
00:32:02,910 --> 00:32:04,140
我们只是取一个样本，我们

835
00:32:04,140 --> 00:32:08,040
将获取所有其他元组并将其复制

836
00:32:08,040 --> 00:32:10,290
到样本表中，但

837
00:32:10,290 --> 00:32:11,730
显然您可以使用更复杂的采样

838
00:32:11,730 --> 00:32:13,200
算法 但出于某种

839
00:32:13,200 --> 00:32:15,810
目的，现在这很有趣，所以现在当我的

840
00:32:15,810 --> 00:32:17,850
查询出现并且我想计算

841
00:32:17,850 --> 00:32:21,450
我年龄的选择性等于

842
00:32:21,450 --> 00:32:24,510
大于 50 的年龄我去我的

843
00:32:24,510 --> 00:32:27,320
样本我说巴马已经超过 50 岁

844
00:32:27,320 --> 00:32:30,690
了 1/3，因此

845
00:32:30,690 --> 00:32:32,730
我可以假设不同的值

846
00:32:32,730 --> 00:32:37,400
是我的全表将匹配，

847
00:32:37,940 --> 00:32:39,960
在这种情况下，就像在

848
00:32:39,960 --> 00:32:42,060
直方图中我们可以满足我们可以

849
00:32:42,060 --> 00:32:44,880
在我们继续进行时保持这一点 正如

850
00:32:44,880 --> 00:32:47,070
您所知，它会定期刷新它，或者

851
00:32:47,070 --> 00:32:49,080
我们可以在您

852
00:32:49,080 --> 00:32:50,280
知道表的很大一部分

853
00:32:50,280 --> 00:32:51,570
已更改时触发它，或者您是否都会批量加载

854
00:32:51,570 --> 00:32:55,080
批量删除，但这里的想法

855
00:32:55,080 --> 00:32:56,430
是，而不是维护

856
00:32:56,430 --> 00:32:58,200
直方图，谁可能可以 不准确，

857
00:32:58,200 --> 00:33:02,060
我们只是维护一个样本，

858
00:33:02,550 --> 00:33:04,530
因此这仅发生

859
00:33:04,530 --> 00:33:06,150
在高端系统中，因此

860
00:33:06,150 --> 00:33:07,980
最有名的序列就是这样做的，他们的

861
00:33:07,980 --> 00:33:11,190
优化器可能是我做的最好的优化器

862
00:33:11,190 --> 00:33:12,420
，但他们实际上

863
00:33:12,420 --> 00:33:15,080
组合了直方图和

864
00:33:15,080 --> 00:33:18,170
以及我认为正确的抽样方法

865
00:33:18,170 --> 00:33:20,000


866
00:33:20,000 --> 00:33:28,440
是的 桑迪亚 是什么让这

867
00:33:28,440 --> 00:33:34,800
比这个问题更困难 为什么

868
00:33:34,800 --> 00:33:38,010
是这种情况，只有像

869
00:33:38,010 --> 00:33:39,420
高端商业企业系统才

870
00:33:39,420 --> 00:33:41,730
真正做到这一点，而不是你知道的

871
00:33:41,730 --> 00:33:50,250
开放 - 来源家伙好问题

872
00:33:50,250 --> 00:33:55,110
我认为是的，实际上是个好问题，

873
00:33:55,110 --> 00:33:57,360
如果您已经进行了分析，那么无论如何您都要进行

874
00:33:57,360 --> 00:33:59,460
光谱扫描以竞争您的

875
00:33:59,460 --> 00:34:01,770
直方图，也可能只是生成

876
00:34:01,770 --> 00:34:04,020
这个东西 你实际上

877
00:34:04,020 --> 00:34:06,540
没有答案 可能是这样，

878
00:34:06,540 --> 00:34:07,950
就像历史上的方式一样，它

879
00:34:07,950 --> 00:34:11,130
总是以正确的方式完成 这不是一个非常

880
00:34:11,130 --> 00:34:22,110
令人满意的答案 我的意思是这里有

881
00:34:22,110 --> 00:34:23,699
一件事 所以我认为就像

882
00:34:23,699 --> 00:34:26,489
你的直方图 以您在优化器中的方式，

883
00:34:26,489 --> 00:34:28,139
您实际上只有这个成本

884
00:34:28,139 --> 00:34:30,000
模型 在这里告诉您正确

885
00:34:30,000 --> 00:34:31,409
答案 直方图 我们将

886
00:34:31,409 --> 00:34:34,080
更快地上升 因为再次计算

887
00:34:34,080 --> 00:34:35,460
所有这些可能的不同查询计划

888
00:34:35,460 --> 00:34:37,080
我可以真正快速地转到我的直方图

889
00:34:37,080 --> 00:34:39,510
并得出 我

890
00:34:39,510 --> 00:34:41,489
需要估计

891
00:34:41,489 --> 00:34:43,770
谓词或运算符的选择性的统计数据

892
00:34:43,770 --> 00:34:46,739
计算选择性

893
00:34:46,739 --> 00:34:48,389
估计的东西我必须对其进行顺序扫描

894
00:34:48,389 --> 00:34:50,520
，这

895
00:34:50,520 --> 00:34:52,790
肯定会比运行直方图慢，

896
00:34:52,790 --> 00:34:56,969
所以我们可以覆盖这个 在

897
00:34:56,969 --> 00:34:58,290
刀片

898
00:34:58,290 --> 00:34:59,490
飞行员在续集服务器续集中工作的高级课程中，一些

899
00:34:59,490 --> 00:35:03,270
回复说如果我认识到我的查询

900
00:35:03,270 --> 00:35:05,640
非常简单，如果

901
00:35:05,640 --> 00:35:07,650
我认为它会很简单，请使用直方图 如果工作

902
00:35:07,650 --> 00:35:08,970
可能需要几分钟或几小时

903
00:35:08,970 --> 00:35:11,220
才能运行，那么谁在乎我是否花

904
00:35:11,220 --> 00:35:13,020
额外的几秒钟来同步我的

905
00:35:13,020 --> 00:35:14,910
采样技术，因为这

906
00:35:14,910 --> 00:35:15,690
将使您知道

907
00:35:15,690 --> 00:35:16,680
实际运行

908
00:35:16,680 --> 00:35:20,040
查询加上 pi 的巨大差异，这就是直方图的原因

909
00:35:20,040 --> 00:35:21,869
会更快，这

910
00:35:21,869 --> 00:35:24,089
需要更多的工作，而且它也

911
00:35:24,089 --> 00:35:25,200
有点奇怪，因为就像

912
00:35:25,200 --> 00:35:27,599


913
00:35:27,599 --> 00:35:28,770
您在运行优化器时正在扫描某些东西一样，所以

914
00:35:28,770 --> 00:35:30,329
从工程的角度来看，这

915
00:35:30,329 --> 00:35:58,440
可能很难 像这样设置

916
00:35:58,440 --> 00:35:59,970
像这样的模型 超级简单 就像

917
00:35:59,970 --> 00:36:03,510
小组委员会是什么 这个

918
00:36:03,510 --> 00:36:06,810
谓词 成本

919
00:36:06,810 --> 00:36:11,040
模型本身的组成部分是独立的 我

920
00:36:11,040 --> 00:36:13,020
认为它是直方图还是

921
00:36:13,020 --> 00:36:16,290
样本，但是是的，是的，所以上面

922
00:36:16,290 --> 00:36:17,790
是公式 今天它会说我要给

923
00:36:17,790 --> 00:36:19,619
这个人做一个磁盘 IO 我会你知道

924
00:36:19,619 --> 00:36:21,060
错过这个哈希联合比

925
00:36:21,060 --> 00:36:23,609
另一个连接更好 是的，如果这不是

926
00:36:23,609 --> 00:36:24,510
所有其他部分不是很复杂，

927
00:36:24,510 --> 00:36:28,500
他们可能是这不是 垫

928
00:36:28,500 --> 00:36:39,839
或者是这里的问题，所以他的问题是

929
00:36:39,839 --> 00:36:41,670
，您如何实际创建一个样本，该样本

930
00:36:41,670 --> 00:36:42,829


931
00:36:42,829 --> 00:36:48,109
对于您可能

932
00:36:48,109 --> 00:36:50,849
抛出的每个

933
00:36:50,849 --> 00:36:53,010
查询都

934
00:36:53,010 --> 00:36:55,410
准确 因为也许数据插入出现

935
00:36:55,410 --> 00:36:57,329
在不同的时间，因此

936
00:36:57,329 --> 00:36:59,010
我今天首先插入的

937
00:36:59,010 --> 00:37:00,300
数据是昨天的数据有不同的

938
00:37:00,300 --> 00:37:02,550
分布，所以我可能想以不同的方式采样，

939
00:37:02,550 --> 00:37:03,720
或者我可以查看我的

940
00:37:03,720 --> 00:37:06,599
谓词并说我是我的 我只

941
00:37:06,599 --> 00:37:07,890
看着你知道

942
00:37:07,890 --> 00:37:09,630
今天插入的数据所以我确保

943
00:37:09,630 --> 00:37:12,630
我的样本只包括

944
00:37:12,630 --> 00:37:14,550
这就是它变得困难的地方，这可能

945
00:37:14,550 --> 00:37:16,140
是高级

946
00:37:16,140 --> 00:37:17,579
系统比

947
00:37:17,579 --> 00:37:20,099
开源人员做得更好的原因 不要像

948
00:37:20,099 --> 00:37:21,510
有水库采样那么多

949
00:37:21,510 --> 00:37:21,990
其他采样

950
00:37:21,990 --> 00:37:23,400
有很多采样技术

951
00:37:23,400 --> 00:37:27,210
试图想出方法来做到这一点

952
00:37:27,210 --> 00:37:28,590
II不知道商业

953
00:37:28,590 --> 00:37:31,860
系统实际上是什么d  o 但希望

954
00:37:31,860 --> 00:37:33,120
你能明白为什么这是一个超级难的查询优化，

955
00:37:33,120 --> 00:37:35,460
因为就像现在你需要

956
00:37:35,460 --> 00:37:36,870
一些你知道一些粗糙的数学来

957
00:37:36,870 --> 00:37:38,760
弄清楚什么是正确的采样方法，

958
00:37:38,760 --> 00:37:41,760
并且在你写完之后依赖

959
00:37:41,760 --> 00:37:43,710
于查询一些你知道的查询 统一

960
00:37:43,710 --> 00:37:44,880
采样可能是完美的 其他采样

961
00:37:44,880 --> 00:37:46,640
技术可能对其他人更好

962
00:37:46,640 --> 00:38:01,740


963
00:38:01,740 --> 00:38:04,050


964
00:38:04,050 --> 00:38:06,090


965
00:38:06,090 --> 00:38:08,790


966
00:38:08,790 --> 00:38:10,200


967
00:38:10,200 --> 00:38:11,850
与

968
00:38:11,850 --> 00:38:14,400
您必须进行频谱扫描相同的执行代码，并且

969
00:38:14,400 --> 00:38:16,530
为了放置这些统计信息是的，

970
00:38:16,530 --> 00:38:18,060
这就像鸡蛋里的鸡我无法

971
00:38:18,060 --> 00:38:19,320
运行查询，直到我有了查询计划

972
00:38:19,320 --> 00:38:21,690
但我无法获得查询计划 直到我可以

973
00:38:21,690 --> 00:38:26,360
运行一个查询来计算样本

974
00:38:27,260 --> 00:38:32,520


975
00:38:32,520 --> 00:38:36,420


976
00:38:36,420 --> 00:38:39,090


977
00:38:39,090 --> 00:38:41,070


978
00:38:41,070 --> 00:38:43,470


979
00:38:43,470 --> 00:38:45,030
正如我在开始时所说的那样，这是

980
00:38:45,030 --> 00:38:46,680
我们将进行成本成本模型或

981
00:38:46,680 --> 00:38:48,240
基于成本的搜索以进行查询

982
00:38:48,240 --> 00:38:52,350
优化的地方，因此

983
00:38:52,350 --> 00:38:54,270
在我们使用规则完成所有这些重写之后，我们将再次在管道中

984
00:38:54,270 --> 00:38:56,970
'

985
00:38:56,970 --> 00:38:59,100
要运行输入这个成本模型

986
00:38:59,100 --> 00:39:00,990
搜索基于成本的搜索试图

987
00:39:00,990 --> 00:39:03,240
弄清楚如何将逻辑

988
00:39:03,240 --> 00:39:04,650
计划转换为物理计划

989
00:39:04,650 --> 00:39:06,270
好吧物理计划是

990
00:39:06,270 --> 00:39:07,500
数据系统实际执行的

991
00:39:07,500 --> 00:39:08,700
逻辑计划说我想加入

992
00:39:08,700 --> 00:39:10,560
物理计划说

993
00:39:10,560 --> 00:39:12,600
这两张桌子在这个小时和

994
00:39:12,600 --> 00:39:14,250
这个缓冲区中以这种排序顺序加入这两张桌子以及所有

995
00:39:14,250 --> 00:39:18,720
这些好东西所以对于单身关系

996
00:39:18,720 --> 00:39:20,490
来说非常简单

997
00:39:20,490 --> 00:39:22,290
简单地谈论它我们

998
00:39:22,290 --> 00:39:23,250
将花费大部分时间

999
00:39:23,250 --> 00:39:25,710
最难的是多重

1000
00:39:25,710 --> 00:39:27,930
关系或无论如何加入，因为现在

1001
00:39:27,930 --> 00:39:31,170
它不仅担心你

1002
00:39:31,170 --> 00:39:32,970
知道我想使用什么联合 Algrim 还担心

1003
00:39:32,970 --> 00:39:35,280
我想加入的顺序是

1004
00:39:35,280 --> 00:39:36,990
我上节课说过的成员

1005
00:39:36,990 --> 00:39:39,030
我们可以将可能的查询计划编号

1006
00:39:39,030 --> 00:39:40,440
为 N，其中 n 是表

1007
00:39:40,440 --> 00:39:40,780


1008
00:39:40,780 --> 00:39:42,520
的数量再次是对的，这是针对我所有

1009
00:39:42,520 --> 00:39:43,930
不同的联合算法，我可以再次

1010
00:39:43,930 --> 00:39:45,160
以不同的顺序加入它们，我可以

1011
00:39:45,160 --> 00:39:46,480
将它们与内部

1012
00:39:46,480 --> 00:39:49,330
或 最右边所以搜索

1013
00:39:49,330 --> 00:39:53,110
位置爆炸所以因为这是

1014
00:39:53,110 --> 00:39:55,750
不完整和完整的我们

1015
00:39:55,750 --> 00:39:57,100
不想真正进行详尽的搜索，

1016
00:39:57,100 --> 00:39:58,270
因为我们实际上永远不会

1017
00:39:58,270 --> 00:39:59,860
完成如果我们的

1018
00:39:59,860 --> 00:40:02,320
查询优化器运行一个小时有意义吗？

1019
00:40:02,320 --> 00:40:03,460
查询只需要花一分钟

1020
00:40:03,460 --> 00:40:06,190
的时间运行，这不是一个好的权衡，所以我们

1021
00:40:06,190 --> 00:40:09,550
需要一种方法来弄清楚如何排序

1022
00:40:09,550 --> 00:40:13,570
减少工作或截止查询计划，我们

1023
00:40:13,570 --> 00:40:15,490
不想检查以减少我们的

1024
00:40:15,490 --> 00:40:16,690
搜索空间，所以 我们可以让这个问题

1025
00:40:16,690 --> 00:40:19,630
更容易处理，所以让我们首先谈谈

1026
00:40:19,630 --> 00:40:20,770
我们想要如何处理 sting 关系

1027
00:40:20,770 --> 00:40:21,910
，大多数 MMO 是时间谈论

1028
00:40:21,910 --> 00:40:25,450
多个关系，因此对于单

1029
00:40:25,450 --> 00:40:29,170
关系查询计划，

1030
00:40:29,170 --> 00:40:31,330
我们必须处理的最困难的问题是

1031
00:40:31,330 --> 00:40:34,780
正确选择我们的访问方法 回退

1032
00:40:34,780 --> 00:40:36,490
选项始终是顺序扫描 它是

1033
00:40:36,490 --> 00:40:37,990
最慢的但它始终是

1034
00:40:37,990 --> 00:40:40,420
正确的 然后我们也许可以进行

1035
00:40:40,420 --> 00:40:41,440
二分搜索并且我们有一个集群

1036
00:40:41,440 --> 00:40:44,140
索引或选择并放置选择你知道一

1037
00:40:44,140 --> 00:40:45,910
两个一或

1038
00:40:45,910 --> 00:40:49,690
用于索引扫描的多个索引 我们可以关心的另一

1039
00:40:49,690 --> 00:40:52,270
件事也是我们评估谓词的顺序，

1040
00:40:52,270 --> 00:40:54,160
就像我有

1041
00:40:54,160 --> 00:40:56,500
一些东西，如果第二个

1042
00:40:56,500 --> 00:40:57,640
谓词比第一个更有选择性，

1043
00:40:57,640 --> 00:40:59,440
也许我想先评估那个，

1044
00:40:59,440 --> 00:41:01,680
所以我 迟早扔掉更多的数据

1045
00:41:01,680 --> 00:41:04,840
，也许第二个

1046
00:41:04,840 --> 00:41:06,100
谓词评估总是你知道

1047
00:41:06,100 --> 00:41:07,750
总是正确的所以我们你知道我们

1048
00:41:07,750 --> 00:41:09,660
不想把它作为第二个

1049
00:41:09,660 --> 00:41:13,360
所以在大多数新的数据库系统中，

1050
00:41:13,360 --> 00:41:14,770
就像所有这些初创公司都是新的

1051
00:41:14,770 --> 00:41:16,000
过去十年出现的数据单元，

1052
00:41:16,000 --> 00:41:18,850
如果他们有一个查询优化器，

1053
00:41:18,850 --> 00:41:20,710
他们可能是，而且你知道

1054
00:41:20,710 --> 00:41:22,120
他们可能正在使用启发式

1055
00:41:22,120 --> 00:41:24,340
方法来选择这些东西，但你

1056
00:41:24,340 --> 00:41:25,690
实际上并没有 你真的需要一个

1057
00:41:25,690 --> 00:41:27,910
复杂的成本模型来做到这一点我

1058
00:41:27,910 --> 00:41:29,890
只是说你知道什么索引是

1059
00:41:29,890 --> 00:41:31,030
最具选择性的，那是我

1060
00:41:31,030 --> 00:41:33,400
一直想选择的，或者什么谓词

1061
00:41:33,400 --> 00:41:34,330
最适合选择它们，这是我

1062
00:41:34,330 --> 00:41:37,300
一直想为所有三个选择的

1063
00:41:37,300 --> 00:41:38,980
查询这是特别容易做到的，

1064
00:41:38,980 --> 00:41:41,620
因为他们不会访问很多

1065
00:41:41,620 --> 00:41:43,840
数据，然后你知道他们正在做你

1066
00:41:43,840 --> 00:41:45,310
知道大部分单表查找

1067
00:41:45,310 --> 00:41:49,930
，所以对于许多查询，

1068
00:41:49,930 --> 00:41:51,580
我们要做的查询计划是

1069
00:41:51,580 --> 00:41:53,170
本质上试图确定一个

1070
00:41:53,170 --> 00:41:54,700
查询是否是中士

1071
00:41:54,700 --> 00:41:57,190
，这是 80 年代的一些术语，我

1072
00:41:57,190 --> 00:41:58,450
不知道是谁发明的，好吧，

1073
00:41:58,450 --> 00:41:59,470
中士，我们只是指搜索

1074
00:41:59,470 --> 00:42:02,500
参数 Abel，所有这

1075
00:42:02,500 --> 00:42:04,600
基本上意味着我们可以选择一个索引

1076
00:42:04,600 --> 00:42:06,970
我们知道这是

1077
00:42:06,970 --> 00:42:10,240
最好的查询，就是这样，所以我们再次

1078
00:42:10,240 --> 00:42:12,130
不需要进行详尽的搜索，

1079
00:42:12,130 --> 00:42:13,720
我们只需查找它我们所有的查询计划

1080
00:42:13,720 --> 00:42:15,040
都开始了我们查看

1081
00:42:15,040 --> 00:42:16,540
所有可能满足

1082
00:42:16,540 --> 00:42:20,500
我们查询的索引 并选择

1083
00:42:20,500 --> 00:42:23,500
拥有最好的运气，因为

1084
00:42:23,500 --> 00:42:24,700
这将让我们

1085
00:42:24,700 --> 00:42:27,820
更快地再次访问数据 真的很简单 我有我的

1086
00:42:27,820 --> 00:42:29,410
夜晚 我从

1087
00:42:29,410 --> 00:42:31,240
ID 等于一二三的人中选择明星 我只是有一个

1088
00:42:31,240 --> 00:42:32,920
启发式，说哦，我有一个主

1089
00:42:32,920 --> 00:42:36,280
键 在 ID 上，但因此我完成了一个

1090
00:42:36,280 --> 00:42:38,800
索引 我只是选择它，因为我

1091
00:42:38,800 --> 00:42:42,190
正在对该索引进行索引扫描

1092
00:42:42,190 --> 00:42:46,030


1093
00:42:46,030 --> 00:42:47,410


1094
00:42:47,410 --> 00:42:50,080


1095
00:42:50,080 --> 00:42:54,790
加入虽然

1096
00:42:54,790 --> 00:42:58,360
那是当事情变得困难的时候再次

1097
00:42:58,360 --> 00:43:00,100
因为数字表将加入

1098
00:43:00,100 --> 00:43:01,900
我们的表然后我的替代

1099
00:43:01,900 --> 00:43:03,850
计划会增长所以因此我们需要一种

1100
00:43:03,850 --> 00:43:07,690
方法来修剪它所以我们将

1101
00:43:07,690 --> 00:43:09,370
依靠什么 我将在这里讨论我们

1102
00:43:09,370 --> 00:43:13,330
将依赖于一个核心假设，即

1103
00:43:13,330 --> 00:43:15,400
IBM 人员在 1970 年代

1104
00:43:15,400 --> 00:43:16,570
对系统所做的就是当他们构建第一

1105
00:43:16,570 --> 00:43:18,790
季度优化器时，他们

1106
00:43:18,790 --> 00:43:21,190
将只考虑左深度连接

1107
00:43:21,190 --> 00:43:23,860
处理，以便 意味着一个

1108
00:43:23,860 --> 00:43:26,470
我将展示的其他替代连接树结构

1109
00:43:26,470 --> 00:43:28,230
看起来像在下一张幻灯片中

1110
00:43:28,230 --> 00:43:30,820
他们只是不会费心进行任何

1111
00:43:30,820 --> 00:43:32,260
搜索或成本估算另一个

1112
00:43:32,260 --> 00:43:34,470
说我们甚至不会考虑它

1113
00:43:34,470 --> 00:43:37,300
所以像这样的左深树

1114
00:43:37,300 --> 00:43:40,060
在树的左侧

1115
00:43:40,060 --> 00:43:43,210
，我们正在做所有的连接，

1116
00:43:43,210 --> 00:43:44,890
所以我们连接 a 和 B，然后

1117
00:43:44,890 --> 00:43:46,570
这个联合的输出 a B 然后

1118
00:43:46,570 --> 00:43:49,660
与 C 的输入连接，扫描 C

1119
00:43:49,660 --> 00:43:50,110


1120
00:43:50,110 --> 00:43:52,000
等等 这里的中间人

1121
00:43:52,000 --> 00:43:53,530
有点像大杂烩，就是这样

1122
00:43:53,530 --> 00:43:55,900
，你认识左边的人，

1123
00:43:55,900 --> 00:43:58,750
右边的人，这里的这个被

1124
00:43:58,750 --> 00:44:00,640
称为浓密的树，在那里我

1125
00:44:00,640 --> 00:44:02,560
对你知道 C 和 E 进行连接，然后进行

1126
00:44:02,560 --> 00:44:03,880
连接 在 B 中，

1127
00:44:03,880 --> 00:44:05,140
然后将这两个关节的输出最后连接

1128
00:44:05,140 --> 00:44:07,310
在一起，

1129
00:44:07,310 --> 00:44:10,370
因此系统中的 IBM 或者他们

1130
00:44:10,370 --> 00:44:12,200
甚至不会考虑这里的其他人

1131
00:44:12,200 --> 00:44:14,380
，他们只会看这个

1132
00:44:14,380 --> 00:44:19,460
是的，是的，这是 实际上再次所以他的

1133
00:44:19,460 --> 00:44:21,260
陈述是结果总是

1134
00:44:21,260 --> 00:44:21,680
一样

1135
00:44:21,680 --> 00:44:23,060
是的 这就是关系代数的美妙之处，

1136
00:44:23,060 --> 00:44:26,600
所以连接运算符是

1137
00:44:26,600 --> 00:44:28,790
可交换的，所以我可以把我可以

1138
00:44:28,790 --> 00:44:30,050
以他们想要的任何方式连接这些东西

1139
00:44:30,050 --> 00:44:31,850
，最终结果总是一样的，

1140
00:44:31,850 --> 00:44:33,230
它总是正确的

1141
00:44:33,230 --> 00:44:34,790
，因此 ADA 对我来说是完全安全的

1142
00:44:34,790 --> 00:44:38,540
并做这一切我

1143
00:44:38,540 --> 00:44:40,340
猜他们为什么这样做，而不只是

1144
00:44:40,340 --> 00:44:42,320
减少他们必须考虑的计划数量

1145
00:44:42,320 --> 00:44:47,060
回想一下，当我们

1146
00:44:47,060 --> 00:44:49,880
谈论查询处理模型时，

1147
00:44:49,880 --> 00:44:50,900
好吧，当时他们正在做

1148
00:44:50,900 --> 00:44:53,720
迭代器模型，火山模型单元

1149
00:44:53,720 --> 00:44:58,220
被称为 管道模型是什么，所以在

1150
00:44:58,220 --> 00:44:59,540
这种情况下，在左侧深度联合

1151
00:44:59,540 --> 00:45:02,230
树中，我不必

1152
00:45:02,230 --> 00:45:05,360
将联合操作符的任何输出具体化，

1153
00:45:05,360 --> 00:45:06,740
然后它总是被输入下一个联合

1154
00:45:06,740 --> 00:45:09,470
操作符，所以我做我的联合 a 和 B 然后我

1155
00:45:09,470 --> 00:45:11,150
采取 该联合的输出，我现在

1156
00:45:11,150 --> 00:45:13,280
建立我的哈希表来做，或者你知道做

1157
00:45:13,280 --> 00:45:14,900
任何我想做的连接，

1158
00:45:14,900 --> 00:45:18,170
看看我是否有这棵浓密的树，我会

1159
00:45:18,170 --> 00:45:20,960
做连接和 C 和 D 然后输出

1160
00:45:20,960 --> 00:45:22,430
被写出来喜欢 温度 f 文件在

1161
00:45:22,430 --> 00:45:24,170
磁盘上，因为现在我需要回到

1162
00:45:24,170 --> 00:45:27,320
这里，现在加入 a 和 B，然后

1163
00:45:27,320 --> 00:45:29,690
现在我回去并反馈

1164
00:45:29,690 --> 00:45:32,180
我刚刚在这里做的联合，你知道

1165
00:45:32,180 --> 00:45:33,980
在构建我的哈希表时读回来做

1166
00:45:33,980 --> 00:45:35,480
任何事情 我想做，然后

1167
00:45:35,480 --> 00:45:38,450
和这里的另一个人一起做联合，所以左

1168
00:45:38,450 --> 00:45:42,410
深度连接树不会或不会总是

1169
00:45:42,410 --> 00:45:45,680
被流水线化，但它让你的生活

1170
00:45:45,680 --> 00:45:47,840
更轻松，回到 1970 年代，他们

1171
00:45:47,840 --> 00:45:49,010
没有很多记忆，所以他们会有

1172
00:45:49,010 --> 00:45:50,630
大量溢出到磁盘，这样你就可以

1173
00:45:50,630 --> 00:45:52,190
最大限度地减少工作量，如果

1174
00:45:52,190 --> 00:45:53,360
要按顺序写入磁盘的数据量，

1175
00:45:53,360 --> 00:45:57,980
如果你总是从左到右，

1176
00:45:57,980 --> 00:45:59,930
那么这是我刚刚在这里说的，所以

1177
00:45:59,930 --> 00:46:03,110
在今天的系统中并不是每个人都会做

1178
00:46:03,110 --> 00:46:06,020
这个假设，但我认为每

1179
00:46:06,020 --> 00:46:08,060
本教科书都谈到了这一点，你知道

1180
00:46:08,060 --> 00:46:11,170
他们把这些东西

1181
00:46:11,599 --> 00:46:13,369
都删掉了，所以我们实际上将

1182
00:46:13,369 --> 00:46:17,509
如何枚举我们的查询计划，所以

1183
00:46:17,509 --> 00:46:18,920
我们要做的第一件事就是

1184
00:46:18,920 --> 00:46:20,959
在逻辑级别的分子中命名所有

1185
00:46:20,959 --> 00:46:23,479
我们的表的不同排序

1186
00:46:23,479 --> 00:46:25,880
我们可能会加入看到

1187
00:46:25,880 --> 00:46:27,829
Alan 加入我们的 S&T 我可以先加入 RN

1188
00:46:27,829 --> 00:46:29,900
也许你知道 Tina 的第一个我计算

1189
00:46:29,900 --> 00:46:32,479
所有这些然后如果

1190
00:46:32,479 --> 00:46:34,339
我现在可以列举所有

1191
00:46:34,339 --> 00:46:36,709
不同的可能连接结果我可以

1192
00:46:36,709 --> 00:46:39,410
使用散列连接伙伴连接嵌套 循环

1193
00:46:39,410 --> 00:46:42,739
连接然后对于所有那些现在我现在也可以

1194
00:46:42,739 --> 00:46:44,509
枚举所有

1195
00:46:44,509 --> 00:46:46,099
可能的查询计划，例如 pop 我可以

1196
00:46:46,099 --> 00:46:48,199
拥有一切你可以看到这

1197
00:46:48,199 --> 00:46:52,369
就像搜索空间正在爆炸一样，

1198
00:46:52,369 --> 00:46:54,589
所以 IBM 的人在 1970 年代想出了什么

1199
00:46:54,589 --> 00:46:56,449
是使用一种称为动态规划的技术，

1200
00:46:56,449 --> 00:46:59,539
通过

1201
00:46:59,539 --> 00:47:02,150
将其分解为更小的离散

1202
00:47:02,150 --> 00:47:03,650
问题来使其更易于处理，我们首先解决了更小的

1203
00:47:03,650 --> 00:47:05,569
问题，最后我们

1204
00:47:05,569 --> 00:47:08,449
将所有问题组合在一起，所以

1205
00:47:08,449 --> 00:47:09,819
让我们在这里看一个非常简单的例子，

1206
00:47:09,819 --> 00:47:12,229
让我们说我 想要连接三个表

1207
00:47:12,229 --> 00:47:15,559
是一个 SMT 所以考虑

1208
00:47:15,559 --> 00:47:16,969
这个的方式就像它就像一种

1209
00:47:16,969 --> 00:47:17,779
搜索树，我正在

1210
00:47:17,779 --> 00:47:19,579
水平显示所以

1211
00:47:19,579 --> 00:47:21,619
这是我们逻辑的起点 我计划

1212
00:47:21,619 --> 00:47:23,660
不连接任何表，然后

1213
00:47:23,660 --> 00:47:25,969
我们的最终目标是在这里

1214
00:47:25,969 --> 00:47:29,839
我们将 s 和 T 连接在一起，所以

1215
00:47:29,839 --> 00:47:32,599
在第一步中我们想

1216
00:47:32,599 --> 00:47:34,369
弄清楚你知道我们想要的第一个

1217
00:47:34,369 --> 00:47:36,890
联合排序是什么 为此，我们

1218
00:47:36,890 --> 00:47:38,930
可能会先加入 R 和 s 或先加入 teen s

1219
00:47:38,930 --> 00:47:41,119
，然后为了空间起见，我

1220
00:47:41,119 --> 00:47:42,170
不会展示所有其他的，但对于

1221
00:47:42,170 --> 00:47:44,329
所有其他可能的加入，

1222
00:47:44,329 --> 00:47:46,309
我们想要做的第一次加入没有梦想，我们

1223
00:47:46,309 --> 00:47:49,880
列举了它们 在这里，然后

1224
00:47:49,880 --> 00:47:50,779
现在我们要做的是我们现在

1225
00:47:50,779 --> 00:47:54,759
要计算

1226
00:47:54,759 --> 00:47:57,349


1227
00:47:57,349 --> 00:47:59,390
在第一步中使用我们不同的

1228
00:47:59,390 --> 00:48:02,749
联合算法在此处指定的任何连接的成本，因此再次为

1229
00:48:02,749 --> 00:48:04,130
简单起见，我们 说我们可以

1230
00:48:04,130 --> 00:48:07,880
进行服务器连接或散列连接，然后

1231
00:48:07,880 --> 00:48:09,619
现在我们只使用

1232
00:48:09,619 --> 00:48:11,599
我们之前讨论过的所有这些公式，现在计算

1233
00:48:11,599 --> 00:48:12,890
执行

1234
00:48:12,890 --> 00:48:16,579
这些联合操作符中的每一个的成本，以

1235
00:48:16,579 --> 00:48:17,869
近似我们要的磁盘 IO 量 必须

1236
00:48:17,869 --> 00:48:22,279
对我们所拥有的每个节点都这样做

1237
00:48:22,279 --> 00:48:24,109
第一步，我们将选择

1238
00:48:24,109 --> 00:48:25,880
实际上成本最低的任何路径，

1239
00:48:25,880 --> 00:48:27,890
无论联合算法

1240
00:48:27,890 --> 00:48:29,000
实际上可以具有最低成本，这

1241
00:48:29,000 --> 00:48:32,590
就是我们保留的那个，然后现在从

1242
00:48:32,590 --> 00:48:34,910
下一步的每个音符开始，我们

1243
00:48:34,910 --> 00:48:36,290
做同样的事情并尝试

1244
00:48:36,290 --> 00:48:38,240
计算执行不同

1245
00:48:38,240 --> 00:48:42,260
关节以达到我们的最终目标的估计成本

1246
00:48:42,260 --> 00:48:44,330
，然后我们最终会为每个节点抛出方法，

1247
00:48:44,330 --> 00:48:46,550
我们最终只

1248
00:48:46,550 --> 00:48:48,830
保留成本最低的节点来到达

1249
00:48:48,830 --> 00:48:51,740
我们的终点，现在我们 返回

1250
00:48:51,740 --> 00:48:53,930
并尝试找出哪条路径

1251
00:48:53,930 --> 00:48:55,970
对我们来说成本最低

1252
00:48:55,970 --> 00:48:58,070
，这就是我们最终将

1253
00:48:58,070 --> 00:49:02,900
用于此查询计划的路径 这是对实际工作方式的过度

1254
00:49:02,900 --> 00:49:04,220
简化，

1255
00:49:04,220 --> 00:49:05,780
但这是

1256
00:49:05,780 --> 00:49:07,970
来自 系统是他们

1257
00:49:07,970 --> 00:49:11,360
一直用于动态编程，并且在高

1258
00:49:11,360 --> 00:49:12,220
层次上

1259
00:49:12,220 --> 00:49:14,600
有两类查询

1260
00:49:14,600 --> 00:49:15,770
优化器，我们只讨论其中

1261
00:49:15,770 --> 00:49:17,720
之一 这是最常见的 大多数

1262
00:49:17,720 --> 00:49:19,340
系统应该以这种方式运行 Postgre

1263
00:49:19,340 --> 00:49:20,630
我的 Seco 是这样做的，我的 Seco 是

1264
00:49:20,630 --> 00:49:23,810
这样做的 Oracle 也是这样

1265
00:49:23,810 --> 00:49:26,960


1266
00:49:26,960 --> 00:49:28,160


1267
00:49:28,160 --> 00:49:30,470


1268
00:49:30,470 --> 00:49:31,880


1269
00:49:31,880 --> 00:49:33,140
做的 为了我的最终目标，一切都

1270
00:49:33,140 --> 00:49:36,020
结合在一起，另一件事

1271
00:49:36,020 --> 00:49:37,670
也在这里简化，没有任何

1272
00:49:37,670 --> 00:49:39,290
信息告诉我我

1273
00:49:39,290 --> 00:49:41,270
向你展示

1274
00:49:41,270 --> 00:49:43,220
的数据的物理属性你知道吗？

1275
00:49:43,220 --> 00:49:44,270
我们正在从一个操作员发出

1276
00:49:44,270 --> 00:49:46,340
下一个所以我 没有跟踪是否

1277
00:49:46,340 --> 00:49:48,020
需要对事物进行排序 无论事物

1278
00:49:48,020 --> 00:49:49,610
是被压缩 烤肉还是柱子 搅拌

1279
00:49:49,610 --> 00:49:51,230
所有额外类型的信息，

1280
00:49:51,230 --> 00:49:52,130
让您在

1281
00:49:52,130 --> 00:49:54,440
此处的搜索算法中必须考虑，但出于我们的

1282
00:49:54,440 --> 00:49:58,850
目的，我们忽略了这一点，好吧

1283
00:49:58,850 --> 00:50:01,790


1284
00:50:01,790 --> 00:50:03,290
让我们更具体地介绍一下这个例子，这就是

1285
00:50:03,290 --> 00:50:04,370
动态方法的到来 我们将

1286
00:50:04,370 --> 00:50:06,200
建立我们的搜索，试图

1287
00:50:06,200 --> 00:50:08,570
找出哪一个你知道

1288
00:50:08,570 --> 00:50:09,830
让我走到最后的路径 将

1289
00:50:09,830 --> 00:50:11,420
所有东西连接在一起的目标

1290
00:50:11,420 --> 00:50:13,460
将具有最低成本 但现在让我们

1291
00:50:13,460 --> 00:50:14,930
开始将所有这些放在一起并

1292
00:50:14,930 --> 00:50:17,180
执行我们谈到的三个步骤 所以我们

1293
00:50:17,180 --> 00:50:18,320
想要两个计算所有联合

1294
00:50:18,320 --> 00:50:20,330
排序所有算法和所有

1295
00:50:20,330 --> 00:50:23,240
访问方法并再次强调没有

1296
00:50:23,240 --> 00:50:24,590
数据系统完全按照我在

1297
00:50:24,590 --> 00:50:26,060
这里展示的方式执行它的方式更复杂

1298
00:50:26,060 --> 00:50:28,280
但在高层次上你希望如果你

1299
00:50:28,280 --> 00:50:29,360
理解这一点然后你可以看到如何

1300
00:50:29,360 --> 00:50:30,640
将它应用到更复杂的

1301
00:50:30,640 --> 00:50:35,120
配置和设置所以

1302
00:50:35,120 --> 00:50:36,980
加入联合的第一步是

1303
00:50:36,980 --> 00:50:39,470
我将列举

1304
00:50:39,470 --> 00:50:43,190
我拥有的所有 Joyner 环，但我们

1305
00:50:43,190 --> 00:50:48,470
说过 for for 系统或者我们将

1306
00:50:48,470 --> 00:50:51,530
修剪任何是交叉

1307
00:50:51,530 --> 00:50:53,349
产品但不是左外

1308
00:50:53,349 --> 00:50:55,700
连接的东西，我们可以 只是从

1309
00:50:55,700 --> 00:50:56,890


1310
00:50:56,890 --> 00:50:59,990
中间放下然后对于这些人中的每一个 所以让我们

1311
00:50:59,990 --> 00:51:01,790
在这里为这些

1312
00:51:01,790 --> 00:51:03,140
查询计划中的每一个选择一个 现在我们将进入

1313
00:51:03,140 --> 00:51:06,260
其中，现在开始并计算

1314
00:51:06,260 --> 00:51:07,460
我们可以使用的所有不同的联合算法

1315
00:51:07,460 --> 00:51:08,590
可能有

1316
00:51:08,590 --> 00:51:11,660
权利这样做加入我们的 NS

1317
00:51:11,660 --> 00:51:13,609
然后接着 TI 可以做一个 S

1318
00:51:13,609 --> 00:51:15,770
循环加入我可以做一个散列连接所以现在

1319
00:51:15,770 --> 00:51:17,180
我要再次计算所有可能的

1320
00:51:17,180 --> 00:51:19,369
配置，这些是我的

1321
00:51:19,369 --> 00:51:21,619
优势 那个动态程序

1322
00:51:21,619 --> 00:51:23,300
图那些是我从一个

1323
00:51:23,300 --> 00:51:26,900
步骤到下一个步骤的边 然后我们

1324
00:51:26,900 --> 00:51:29,599
对所有其他人做同样的事情

1325
00:51:29,599 --> 00:51:31,970
上一张幻灯片中的联合自己的路线 所以

1326
00:51:31,970 --> 00:51:34,060
现在我们要选择这些人中的一个

1327
00:51:34,060 --> 00:51:37,700
现在我尝试 你知道枚举你可以拥有的所有

1328
00:51:37,700 --> 00:51:38,900
不同的可能访问方法

1329
00:51:38,900 --> 00:51:40,520
，所以我们可以进行

1330
00:51:40,520 --> 00:51:42,560
中央扫描或索引扫描，然后

1331
00:51:42,560 --> 00:51:44,180
对于每个索引扫描，你知道

1332
00:51:44,180 --> 00:51:45,890
我们可能拥有的每个索引，我们会有

1333
00:51:45,890 --> 00:51:49,310
另一个枚举，好的

1334
00:51:49,310 --> 00:51:51,050
继续散开并拥有

1335
00:51:51,050 --> 00:51:52,670
越来越多的选择，然后您使用

1336
00:51:52,670 --> 00:51:55,099
动态编程技术

1337
00:51:55,099 --> 00:52:01,130
找出最便宜的路径是可以的，所以

1338
00:52:01,130 --> 00:52:05,510
这大致清楚这是如何工作的，

1339
00:52:05,510 --> 00:52:07,010
所以我总是喜欢每年展示这个

1340
00:52:07,010 --> 00:52:10,160
，所以我再次 我要向你

1341
00:52:10,160 --> 00:52:11,510
展示 Postgres 如何让 Postgres 有一个

1342
00:52:11,510 --> 00:52:13,970
专门的优化器，但总的来说

1343
00:52:13,970 --> 00:52:15,800
，我在这里描述的是

1344
00:52:15,800 --> 00:52:19,339
每个系统如何基于查询

1345
00:52:19,339 --> 00:52:21,170
优化器工作的高层次他们有一个成本模型

1346
00:52:21,170 --> 00:52:23,390
，可以在他们

1347
00:52:23,390 --> 00:52:26,000
做的时候进行估计 动态规划搜索以

1348
00:52:26,000 --> 00:52:29,240
达到最终目标 Postgres 实际上有

1349
00:52:29,240 --> 00:52:31,550
两种优化器搜索算法，

1350
00:52:31,550 --> 00:52:33,080
它们有我刚刚谈到的系统 r1，

1351
00:52:33,080 --> 00:52:34,670
但他们也有

1352
00:52:34,670 --> 00:52:36,140
一个称为遗传

1353
00:52:36,140 --> 00:52:41,540
优化器的特殊算法是 geq 遗传查询

1354
00:52:41,540 --> 00:52:44,720
优化器 GE GE qo 和 发生的情况是

1355
00:52:44,720 --> 00:52:47,150
，如果您有一个

1356
00:52:47,150 --> 00:52:49,460
少于 12 个表的查询，他们使用系统我们的

1357
00:52:49,460 --> 00:52:51,589
方法，然后如果您有 13 个或更多，

1358
00:52:51,589 --> 00:52:53,630
那么您开始使用这种遗传

1359
00:52:53,630 --> 00:52:55,220
算法，因为他们可以处理您

1360
00:52:55,220 --> 00:52:56,950
知道更大的搜索基础，

1361
00:52:56,950 --> 00:53:00,019
所以使用 Postgres 他们将支持

1362
00:53:00,019 --> 00:53:01,849
所有不同类型的关节顺序，

1363
00:53:01,849 --> 00:53:04,190
所以左深右深衬套

1364
00:53:04,190 --> 00:53:06,710
无关紧要，正如我所说的那样，然后

1365
00:53:06,710 --> 00:53:08,450
当它变得太多时，他们会退回到这种遗传性的

1366
00:53:08,450 --> 00:53:11,359
复杂，所以在高层次上它

1367
00:53:11,359 --> 00:53:14,450
可以作为你的标准遗传搜索

1368
00:53:14,450 --> 00:53:14,960
算法，

1369
00:53:14,960 --> 00:53:17,000
所以我的第一代我只是

1370
00:53:17,000 --> 00:53:18,200
要枚举

1371
00:53:18,200 --> 00:53:19,880
我的查询计划的一堆不同的随机配置

1372
00:53:19,880 --> 00:53:21,890
，这就是联合发声

1373
00:53:21,890 --> 00:53:23,750
加上索引扫描或暂停

1374
00:53:23,750 --> 00:53:25,250
扫描加上 我想要使用的实际联合算法

1375
00:53:25,250 --> 00:53:27,349
，然后对于其中的每一个，

1376
00:53:27,349 --> 00:53:30,259
我将计算成本，然后

1377
00:53:30,259 --> 00:53:31,880
发生的事情是我选择哪个

1378
00:53:31,880 --> 00:53:33,529
是最好的，所以这个有

1379
00:53:33,529 --> 00:53:35,690
最低的调用我会跟踪那个 在

1380
00:53:35,690 --> 00:53:37,609
上面说这是我见过的最好的计划

1381
00:53:37,609 --> 00:53:40,369
，然后我要

1382
00:53:40,369 --> 00:53:42,200
扔掉成本最低的计划，

1383
00:53:42,200 --> 00:53:47,329
然后现在将没有被扔掉的计划的特征混合起来

1384
00:53:47,329 --> 00:53:50,599


1385
00:53:50,599 --> 00:53:52,940


1386
00:53:52,940 --> 00:53:55,400
如果您将

1387
00:53:55,400 --> 00:53:57,410
查询计划的所有组件正确地生成新的查询

1388
00:53:57,410 --> 00:54:01,970
计划，我将对基因进行随机翻转，所以它有点像

1389
00:54:01,970 --> 00:54:03,650
随机游走，所以现在我

1390
00:54:03,650 --> 00:54:05,660
在我的第二代做同样的事情 我找到了

1391
00:54:05,660 --> 00:54:07,490
一个成本最低的

1392
00:54:07,490 --> 00:54:08,930
在这里的情况下，这里的成本为 80

1393
00:54:08,930 --> 00:54:10,759
，现在成为我见过的最好的新课程

1394
00:54:10,759 --> 00:54:12,799
我扔掉

1395
00:54:12,799 --> 00:54:15,140
成本最低的课程 然后我随机

1396
00:54:15,140 --> 00:54:17,630
混合保留的计划

1397
00:54:17,630 --> 00:54:20,359
并生成 下一代

1398
00:54:20,359 --> 00:54:22,880
，他们会继续这样做，直到

1399
00:54:22,880 --> 00:54:23,960
一定的时间有一个

1400
00:54:23,960 --> 00:54:25,400
超时说我不是我没有看到其他任何

1401
00:54:25,400 --> 00:54:28,309
东西或者我没有看到任何

1402
00:54:28,309 --> 00:54:29,839
比我最好的东西更好的东西 到目前为止，我已经看到

1403
00:54:29,839 --> 00:54:31,490
了一定的时间范围内的

1404
00:54:31,490 --> 00:54:33,410
排气 Mike Mike 我的固定时间限制

1405
00:54:33,410 --> 00:54:35,150
，然后无论结果如何

1406
00:54:35,150 --> 00:54:38,890
都是最好的，它是我要使用的一个

1407
00:54:38,890 --> 00:54:47,809
是的，一个问题是为了简单

1408
00:54:47,809 --> 00:54:49,250
起见，我只展示 你留下了很深的

1409
00:54:49,250 --> 00:54:51,380
树，你可以把它和

1410
00:54:51,380 --> 00:54:54,259
深而浓密的树混在一起，但你把它做成

1411
00:54:54,259 --> 00:54:55,880
只有三张桌子，我们可以想象你

1412
00:54:55,880 --> 00:54:57,079
还有另外三张桌子你想

1413
00:54:57,079 --> 00:54:59,059
加入，也许

1414
00:54:59,059 --> 00:55:01,250
其中一部分很深，另一部分很深 我可以我可以

1415
00:55:01,250 --> 00:55:04,519
根据需要混合和匹配它们是的，但

1416
00:55:04,519 --> 00:55:07,299
很难

1417
00:55:07,510 --> 00:55:14,390
画出问题 第一代

1418
00:55:14,390 --> 00:55:30,260
如何随机产生多少

1419
00:55:30,260 --> 00:55:33,380
候选人我不知道事情

1420
00:55:33,380 --> 00:55:34,700
可能会如何发展我不知道

1421
00:55:34,700 --> 00:55:36,170
我不知道数字是但是

1422
00:55:36,170 --> 00:55:39,590
它不可能是每个人是的它是它的

1423
00:55:39,590 --> 00:55:42,050
某些百分比 大实际上可能是

1424
00:55:42,050 --> 00:55:43,130
一些固定数量我不知道它

1425
00:55:43,130 --> 00:55:47,630
是什么但同样这个成本估算

1426
00:55:47,630 --> 00:55:48,500
与我们之前已经讨论

1427
00:55:48,500 --> 00:55:49,670
过的相同，这是相同的

1428
00:55:49,670 --> 00:55:52,040
直方图或采样，您只是

1429
00:55:52,040 --> 00:55:56,470
在正确使用时应用它

1430
00:55:56,470 --> 00:55:58,760
Postgres 是我知道的唯一一个

1431
00:55:58,760 --> 00:56:02,720
实际上这样做的有一些

1432
00:56:02,720 --> 00:56:04,460
工作和模拟退火其他

1433
00:56:04,460 --> 00:56:06,170
技术这就像一个随机

1434
00:56:06,170 --> 00:56:07,340
算法很好因为它看起来

1435
00:56:07,340 --> 00:56:09,620
它不能保证收敛你

1436
00:56:09,620 --> 00:56:11,510
不能保证看到最好

1437
00:56:11,510 --> 00:56:13,370
的选择 您正在

1438
00:56:13,370 --> 00:56:14,750
解决方案空间中进行随机游走，希望

1439
00:56:14,750 --> 00:56:16,160
您能找到合理的东西，

1440
00:56:16,160 --> 00:56:19,880
因此实际上就他的观点而言，您

1441
00:56:19,880 --> 00:56:22,090
显然想选择正确的东西，

1442
00:56:22,090 --> 00:56:24,710
而您的初始候选人应该是

1443
00:56:24,710 --> 00:56:26,630
你很清楚他们实际上是

1444
00:56:26,630 --> 00:56:28,670
怎么做的，但我不知道，因为如果你们

1445
00:56:28,670 --> 00:56:30,890
这里都是废话，你有丑陋的孩子，

1446
00:56:30,890 --> 00:56:31,790
第一步那么你有丑陋的

1447
00:56:31,790 --> 00:56:33,080
孩子，第二步就

1448
00:56:33,080 --> 00:56:35,210
不会好了，所以可能有一些方法可以

1449
00:56:35,210 --> 00:56:36,500
弄清楚 你的初始候选人

1450
00:56:36,500 --> 00:56:40,670
应该是什么，所以

1451
00:56:40,670 --> 00:56:46,700
关于这个的任何问题是的，好吧，所以这个问题是

1452
00:56:46,700 --> 00:56:48,530
你多久

1453
00:56:48,530 --> 00:56:55,910
收到13个或更多关节的查询，非常频繁，呃这

1454
00:56:55,910 --> 00:57:01,100
取决于你Walt用于

1455
00:57:01,100 --> 00:57:05,440
分析的OLTP，它经常是

1456
00:57:05,860 --> 00:57:08,330
好吧，考虑一下这个，

1457
00:57:08,330 --> 00:57:10,910
所以在数据仓库中，一个非常常见的

1458
00:57:10,910 --> 00:57:14,210
设置确实有所谓的雪花

1459
00:57:14,210 --> 00:57:16,550
模式，这个想法是你

1460
00:57:16,550 --> 00:57:18,020
有一个叫做

1461
00:57:18,020 --> 00:57:19,269
事实表的表

1462
00:57:19,269 --> 00:57:20,499
，然后你

1463
00:57:20,499 --> 00:57:22,089
有围绕它的维度表 所以

1464
00:57:22,089 --> 00:57:24,429
使用沃尔玛书呆子示例

1465
00:57:24,429 --> 00:57:25,989
的事实表沃尔玛有一个事实表，

1466
00:57:25,989 --> 00:57:28,029
其中包含任何人在沃尔玛购买过的每一件商品，因此

1467
00:57:28,029 --> 00:57:29,529
该表很大，它有数

1468
00:57:29,529 --> 00:57:31,390
十亿的东西，但您不会想要 t

1469
00:57:31,390 --> 00:57:33,640
存储每个单一产品的名称、

1470
00:57:33,640 --> 00:57:35,380
价格等等，所以你

1471
00:57:35,380 --> 00:57:36,699
有这些维度表

1472
00:57:36,699 --> 00:57:38,019
，上面写着你知道

1473
00:57:38,019 --> 00:57:39,669
这里是他们在这里购买的产品是他的

1474
00:57:39,669 --> 00:57:41,649
位置，所以这些都是你的维度

1475
00:57:41,649 --> 00:57:42,939
表，所以当你做一个 联合并说

1476
00:57:42,939 --> 00:57:45,579
找到我所有

1477
00:57:45,579 --> 00:57:47,469


1478
00:57:47,469 --> 00:57:49,179
本月宾夕法尼亚州冬季最畅销的商品，适用

1479
00:57:49,179 --> 00:57:51,039
于您认识

1480
00:57:51,039 --> 00:57:53,679
的 35 岁以上的人，这些商品现在都加入了

1481
00:57:53,679 --> 00:57:55,419
他的尺寸表，这样东西就可以

1482
00:57:55,419 --> 00:57:57,759
堆积起来 很快

1483
00:57:57,759 --> 00:57:59,049
我还要说的另一件事是，我总是

1484
00:57:59,049 --> 00:58:00,880
与数据公司交谈，

1485
00:58:00,880 --> 00:58:02,469
我问他们就像您了解查询

1486
00:58:02,469 --> 00:58:03,699
优化器一样，因为这是我

1487
00:58:03,699 --> 00:58:06,880
最感兴趣的部分，也是

1488
00:58:06,880 --> 00:58:08,709
他们一直以来的指标 给我这样的说法哦，

1489
00:58:08,709 --> 00:58:11,469
我们的查询优化器很好，他们总是

1490
00:58:11,469 --> 00:58:13,059
声称他们可以

1491
00:58:13,059 --> 00:58:14,769
支持的连接数，我认为这不是一个好的

1492
00:58:14,769 --> 00:58:17,049
指标，但就像我注意到

1493
00:58:17,049 --> 00:58:18,579
每次我猜马尔萨斯都是汽车

1494
00:58:18,579 --> 00:58:22,269
一样 我 像 mem Siegel 这样的墨水

1495
00:58:22,269 --> 00:58:23,979
曾经告诉我，他们可以做 35 次表

1496
00:58:23,979 --> 00:58:27,429
连接，而其他人可以给

1497
00:58:27,429 --> 00:58:29,169
你 75 次，然后拼接机告诉我

1498
00:58:29,169 --> 00:58:31,869
他们可以在 Vega 上做 135 片雪花，

1499
00:58:31,869 --> 00:58:33,999
而他们的客户

1500
00:58:33,999 --> 00:59:05,799
实际上这样做了，这对你来说很难” 重新

1501
00:59:05,799 --> 00:59:07,599
准备好深入订购

1502
00:59:07,599 --> 00:59:10,419
它喜欢的东西再次加入交换式你

1503
00:59:10,419 --> 00:59:11,889
可以以任何你想要的任何可能的顺序加入它们

1504
00:59:11,889 --> 00:59:26,499
你可以从你那里以任何

1505
00:59:26,499 --> 00:59:27,630
你想要的方式是的

1506
00:59:27,630 --> 00:59:30,159
现在我想你要去的地方

1507
00:59:30,159 --> 00:59:31,959
就像我展示的那样 你到一个联合

1508
00:59:31,959 --> 00:59:32,950
算法，

1509
00:59:32,950 --> 00:59:35,620
比如 for 循环，有多种

1510
00:59:35,620 --> 00:59:37,810
连接方式，你可以说我加入我们的

1511
00:59:37,810 --> 00:59:40,120
SMT 的属性完全相同，让我

1512
00:59:40,120 --> 00:59:42,580
在完全相同的时间加入它们，这

1513
00:59:42,580 --> 00:59:44,830
很难，只有昂贵的活塞才能做到

1514
00:59:44,830 --> 00:59:46,020


1515
00:59:46,020 --> 00:59:49,950
Postgres 我的单身 不这样做

1516
00:59:56,400 --> 00:59:58,570
是的，同样的愿望不会

1517
00:59:58,570 --> 01:00:15,970
被实现，所以这实际上

1518
01:00:15,970 --> 01:00:18,190
是人类 Rick urate 哦，我

1519
01:00:18,190 --> 01:00:19,960
可能会在下节课讲这个，或者我可以像你想要的那样

1520
01:00:19,960 --> 01:00:21,340
在我们的广场上单独给她寄一些东西

1521
01:00:21,340 --> 01:00:26,230
一个人 将

1522
01:00:26,230 --> 01:00:27,990
不得不设计数据库说

1523
01:00:27,990 --> 01:00:30,310
这是我的事实表 这是我的维度

1524
01:00:30,310 --> 01:00:31,150
表 这不是我们

1525
01:00:31,150 --> 01:00:32,980
自动找出的东西 我使用的

1526
01:00:32,980 --> 01:00:34,390
术语维度表 这

1527
01:00:34,390 --> 01:00:36,130
是描述该

1528
01:00:36,130 --> 01:00:37,690
表在雪花模式中的样子的白话

1529
01:00:37,690 --> 01:00:39,790
你有一个事实 中间的表，

1530
01:00:39,790 --> 01:00:41,170
然后它周围的东西称为

1531
01:00:41,170 --> 01:00:42,940
维度表，但从

1532
01:00:42,940 --> 01:00:45,340
数据库的角度来看，除非它是我们

1533
01:00:45,340 --> 01:00:48,280
的 OLAP 查询或

1534
01:00:48,280 --> 01:00:50,980
分析查询的系统设计，否则后续没有特殊的

1535
01:00:50,980 --> 01:00:52,810
名称说哦，你是

1536
01:00:52,810 --> 01:00:54,280
维度表或哦 你是一个事实

1537
01:00:54,280 --> 01:00:56,440
表，就像人类一样，我们使用这个

1538
01:00:56,440 --> 01:00:59,650
词是的，我会发送我会发送

1539
01:00:59,650 --> 01:01:01,200
上一堂课或这门

1540
01:01:01,200 --> 01:01:05,550
高级课程的幻灯片我会在广场上张贴

1541
01:01:11,310 --> 01:01:15,400
是的，所以这里的想法

1542
01:01:15,400 --> 01:01:17,140
就像再次一样 它是随机算法的随机映射，

1543
01:01:17,140 --> 01:01:19,120
但是

1544
01:01:19,120 --> 01:01:20,950
算法说这个东西

1545
01:01:20,950 --> 01:01:23,350


1546
01:01:23,350 --> 01:01:25,150


1547
01:01:25,150 --> 01:01:27,880
的成本最低 呃

1548
01:01:27,880 --> 01:01:30,100
下一代无论哪里不好你

1549
01:01:30,100 --> 01:01:33,970
知道畸形基因是正确的我只是

1550
01:01:33,970 --> 01:01:36,520
要把它扔掉然后所以

1551
01:01:36,520 --> 01:01:38,170
关于这个的东西有最低的

1552
01:01:38,170 --> 01:01:40,900
成本我想向前传播所以

1553
01:01:40,900 --> 01:01:42,760
这就是为什么我会让你知道这个东西

1554
01:01:42,760 --> 01:01:44,920
得到 对这个人很友好

1555
01:01:44,920 --> 01:01:47,080
，然后在你知道你

1556
01:01:47,080 --> 01:01:48,460
周三要去医院并且你

1557
01:01:48,460 --> 01:01:49,620
妻子的分娩就像没事一样之前，

1558
01:01:49,620 --> 01:02:03,280
你的问题是抱歉，

1559
01:02:03,280 --> 01:02:08,770
这有什么

1560
01:02:08,770 --> 01:02:10,930
不同，这和这有什么不同，这是这样做的

1561
01:02:10,930 --> 01:02:14,400
，这是 右深 那是左撇子

1562
01:02:14,400 --> 01:02:17,800
不 不 那是外面的桌子

1563
01:02:17,800 --> 01:02:22,000
这是里面的桌子 所以我在做

1564
01:02:22,000 --> 01:02:23,620
哈希连接 我正在建立哈希表

1565
01:02:23,620 --> 01:02:27,370
阿姨 我正在这里用茶试探 连接

1566
01:02:27,370 --> 01:02:41,590
问题 订单很重要 是的 是的 爸爸

1567
01:02:41,590 --> 01:02:43,660
应该 在这里，是的，这是错误的，是的，

1568
01:02:43,660 --> 01:02:45,430
这只是说这

1569
01:02:45,430 --> 01:02:47,140
家伙被允许向前传播，

1570
01:02:47,140 --> 01:02:51,150
应该在那里，我会解决这个问题，对不起，

1571
01:02:51,240 --> 01:02:55,030
好吧，让我们快速完成

1572
01:02:55,030 --> 01:02:57,550
NSSL 查询，所以这是我们将要解决的问题

1573
01:02:57,550 --> 01:02:59,110
如果你接受它，那么在高级课程中更多

1574
01:02:59,110 --> 01:03:02,320
，但考虑这个问题的主要方法

1575
01:03:02,320 --> 01:03:05,440
是它不像连接，

1576
01:03:05,440 --> 01:03:08,350
因为它是一个子查询，我们

1577
01:03:08,350 --> 01:03:09,520
想要聪明地了解我们实际上将

1578
01:03:09,520 --> 01:03:11,890
如何评估它 因为

1579
01:03:11,890 --> 01:03:13,480
我们能做的最愚蠢的事情就是

1580
01:03:13,480 --> 01:03:15,220
评估内部查询 每个管子的子查询

1581
01:03:15,220 --> 01:03:16,870
我们

1582
01:03:16,870 --> 01:03:19,360
最终看到的是外部查询 我的

1583
01:03:19,360 --> 01:03:20,800
续集曾经这样做过，它需要

1584
01:03:20,800 --> 01:03:24,070
很糟糕 所以我们有两种方法

1585
01:03:24,070 --> 01:03:26,260
可以做到这一点，这里的想法是其中的一些

1586
01:03:26,260 --> 01:03:28,060
我们可以做到这些，而

1587
01:03:28,060 --> 01:03:30,640
无需运行基于成本的搜索我们可以

1588
01:03:30,640 --> 01:03:32,580
在重写阶段的一部分中做到这一点，

1589
01:03:32,580 --> 01:03:34,780
因此首先我们可以重写

1590
01:03:34,780 --> 01:03:37,930
查询以将其关联起来 或者将其展平

1591
01:03:37,930 --> 01:03:40,330
，或者我们可以提取内部查询

1592
01:03:40,330 --> 01:03:42,940
并将其作为自己的查询单独运行

1593
01:03:42,940 --> 01:03:45,640
，然后将其结果提供给第一个

1594
01:03:45,640 --> 01:03:47,800
查询，让我们在这里看一个更复杂的

1595
01:03:47,800 --> 01:03:51,250
例子，所以这个查询

1596
01:03:51,250 --> 01:03:53,500
在这里我们试图得到所有 说

1597
01:03:53,500 --> 01:03:55,120
我们有一张桌子记录 水手

1598
01:03:55,120 --> 01:03:56,980
所以这是从我们过去使用

1599
01:03:56,980 --> 01:03:58,930
威斯康星州威斯康星州

1600
01:03:58,930 --> 01:04:00,430
一个帆船俱乐部的旧教科书开始的，这就是

1601
01:04:00,430 --> 01:04:02,170
问题所在，所以基本上我们试图让

1602
01:04:02,170 --> 01:04:04,480
所有水手都

1603
01:04:04,480 --> 01:04:06,940
知道他们在上面预订了一条船的水手的名字

1604
01:04:06,940 --> 01:04:11,140
一个给定的日期，所以我们在这里有这个内部查询

1605
01:04:11,140 --> 01:04:13,240
，现在我们看看我们是否

1606
01:04:13,240 --> 01:04:17,200
从我们的内部查询引用

1607
01:04:17,200 --> 01:04:20,890
来自外部外部查询的记录，所以在

1608
01:04:20,890 --> 01:04:22,750
这种情况下，我们知道它们是

1609
01:04:22,750 --> 01:04:25,210
相关的，因为它们正在

1610
01:04:25,210 --> 01:04:26,079
相互引用 所以我们需要将它

1611
01:04:26,079 --> 01:04:29,680
重写为一个连接所以我们可以

1612
01:04:29,680 --> 01:04:30,819
在重写阶段再次这样做我们

1613
01:04:30,819 --> 01:04:33,160
可以认识到我们在这里有这个这个

1614
01:04:33,160 --> 01:04:34,809
pedak 我们可以像这样重写它

1615
01:04:34,809 --> 01:04:36,250
然后我们只做我们的调用空间

1616
01:04:36,250 --> 01:04:37,450
搜索来弄清楚是否 正确的

1617
01:04:37,450 --> 01:04:40,780
连接顺序和以前一样 让我们看一下更

1618
01:04:40,780 --> 01:04:42,670
复杂的例子 所以这里

1619
01:04:42,670 --> 01:04:43,930
我们试图为每个

1620
01:04:43,930 --> 01:04:45,700
水手找到总体评分最高的自由航行

1621
01:04:45,700 --> 01:04:47,530
我们的水手获得

1622
01:04:47,530 --> 01:04:49,900
了红船的两个预订，然后找到

1623
01:04:49,900 --> 01:04:51,130
了航行 ID 最早

1624
01:04:51,130 --> 01:04:52,569
的水手预订日期是在

1625
01:04:52,569 --> 01:04:55,089
红船上，所以我们的主要事情

1626
01:04:55,089 --> 01:04:57,250
是我们在这里有这个内部查询，

1627
01:04:57,250 --> 01:04:59,619
我们只是想获得所有水手的最大水手

1628
01:04:59,619 --> 01:05:03,339
评级或排名，所以

1629
01:05:03,339 --> 01:05:05,290
最坏的情况是我们 在这里做这个查找

1630
01:05:05,290 --> 01:05:06,700
，我们评级等于，然后是水

1631
01:05:06,700 --> 01:05:09,069
手表外表上每个元组的中心查询，

1632
01:05:09,069 --> 01:05:11,859
我们

1633
01:05:11,859 --> 01:05:13,359
只是一遍又一遍地重新运行这个东西，

1634
01:05:13,359 --> 01:05:15,490
但这会很慢，这

1635
01:05:15,490 --> 01:05:18,369
会很糟糕，所以我们可以做什么 然后将其

1636
01:05:18,369 --> 01:05:21,220
提取出来，或者我们将其写入其中，

1637
01:05:21,220 --> 01:05:23,079
这样我们就不必

1638
01:05:23,079 --> 01:05:26,980
知道我们每次都运行它，因此

1639
01:05:26,980 --> 01:05:28,809
第一种方法可能只是将其

1640
01:05:28,809 --> 01:05:32,290
取出这个嵌套块，在这里运行

1641
01:05:32,290 --> 01:05:34,270
它以某种方式存储它 的变量，

1642
01:05:34,270 --> 01:05:38,650
然后在下面替换该值，所以

1643
01:05:38,650 --> 01:05:39,760
我想在这里展示的主要内容

1644
01:05:39,760 --> 01:05:41,950
是查询优化器

1645
01:05:41,950 --> 01:05:43,329
不一定必须采用单个查询

1646
01:05:43,329 --> 01:05:46,089
，只将其视为单个查询，我们

1647
01:05:46,089 --> 01:05:48,819
可以重写它并执行它们

1648
01:05:48,819 --> 01:05:50,559
你一个接一个地认识 为了填充

1649
01:05:50,559 --> 01:05:54,339
我们实际需要的值，

1650
01:05:54,339 --> 01:05:55,480
这是更

1651
01:05:55,480 --> 01:05:58,780
复杂的系统可以做到的事情，

1652
01:05:58,780 --> 01:05:59,920
这就是说这是外部块

1653
01:05:59,920 --> 01:06:04,650
，那是上面的内部块

1654
01:06:04,859 --> 01:06:08,099


1655
01:06:08,099 --> 01:06:09,690
我们可以讨论

1656
01:06:09,690 --> 01:06:11,009
本学期剩余时间的查询优化，

1657
01:06:11,009 --> 01:06:13,049
因为我说过这是

1658
01:06:13,049 --> 01:06:15,749
我真正感兴趣的事情，我计划

1659
01:06:15,749 --> 01:06:17,519
在高级课程中涵盖更多内容

1660
01:06:17,519 --> 01:06:19,140


1661
01:06:19,140 --> 01:06:21,059


1662
01:06:21,059 --> 01:06:23,299
开始这个你知道这是你

1663
01:06:23,299 --> 01:06:25,319
联系我因为这也可以保证

1664
01:06:25,319 --> 01:06:28,229
在高级课程中占有一席之地所以

1665
01:06:28,229 --> 01:06:29,279
我们谈论耳朵选择性

1666
01:06:29,279 --> 01:06:30,509
估计我们

1667
01:06:30,509 --> 01:06:32,009
谈论了我们对均匀性独立性所做的主要假设

1668
01:06:32,009 --> 01:06:33,749
以及

1669
01:06:33,749 --> 01:06:35,190
我们谈论的问题 如何

1670
01:06:35,190 --> 01:06:37,380
为您加入排序进行遗传编程

1671
01:06:37,380 --> 01:06:39,359
，然后我们可以使用简单的技术

1672
01:06:39,359 --> 01:06:42,930
来重写嵌套

1673
01:06:42,930 --> 01:06:46,109


1674
01:06:46,109 --> 01:06:47,759
查询 每次您启动查询

1675
01:06:47,759 --> 01:06:49,229
和续集灯或 Postgres 或我的

1676
01:06:49,229 --> 01:06:50,249
续集时，无论您使用什么数据库，

1677
01:06:50,249 --> 01:06:52,499
它都会经历所有这一切，这

1678
01:06:52,499 --> 01:06:55,950
令人惊讶它实际上有多快，

1679
01:06:55,950 --> 01:06:59,099
尽管这是一个非常复杂的问题，

1680
01:06:59,099 --> 01:07:02,729
好吧，所以下一节课我 将在这里，

1681
01:07:02,729 --> 01:07:04,140
我们将开始讨论

1682
01:07:04,140 --> 01:07:05,609
并发控制，这

1683
01:07:05,609 --> 01:07:07,559
是数据库系统中第二难的事情，

1684
01:07:07,559 --> 01:07:09,359
如果你真的很

1685
01:07:09,359 --> 01:07:13,049
擅长，你也可以找到一份工作，这将

1686
01:07:13,049 --> 01:07:15,420
涵盖它，所以我们在星期一 或者抱歉，

1687
01:07:15,420 --> 01:07:16,319
这周周三我们将

1688
01:07:16,319 --> 01:07:19,739
再次介绍控制理论的基础知识 Andy

1689
01:07:19,739 --> 01:07:22,559
理论不是真正的理论 然后下周一

1690
01:07:22,559 --> 01:07:24,420
和下周周三我将

1691
01:07:24,420 --> 01:07:25,410
让 Pichichi 学生介绍

1692
01:07:25,410 --> 01:07:27,029
两阶段锁定和时间戳排序

1693
01:07:27,029 --> 01:07:28,499
因为那些将是

1694
01:07:28,499 --> 01:07:29,999
第四个家庭作业需要两件东西，

1695
01:07:29,999 --> 01:07:36,440
好吧，但我要

1696
01:07:36,440 --> 01:07:42,630
加分，嗯等一下，让我拿

1697
01:07:42,630 --> 01:07:45,869
幻灯片，所以今天在这里发布额外的学分

1698
01:07:45,869 --> 01:07:49,170
作业，这样你就可以获得

1699
01:07:49,170 --> 01:07:51,749
10% 的额外学分

1700
01:07:51,749 --> 01:07:53,459


1701
01:07:53,459 --> 01:07:54,809


1702
01:07:54,809 --> 01:07:57,989
如果你写了一篇关于

1703
01:07:57,989 --> 01:08:01,289
数据库管理系统的文章，那么你现在的最终成绩是整个学期最终成绩的项目考试，所以你

1704
01:08:01,289 --> 01:08:02,880
可以在你想要的时候竞争任何数据库实例，

1705
01:08:02,880 --> 01:08:04,799
而不是

1706
01:08:04,799 --> 01:08:06,329
学生写的那些 在您

1707
01:08:06,329 --> 01:08:07,529
考虑这一点之前，您正在像

1708
01:08:07,529 --> 01:08:10,469
在 cyclopædia 文章中写的

1709
01:08:10,469 --> 01:08:11,999
那样写自由格式的文本，就像

1710
01:08:11,999 --> 01:08:14,009
在 Wikipedia 中一样，它是这样设置的，这样您就可以

1711
01:08:14,009 --> 01:08:16,349
准确指定系统的不同部分是如何

1712
01:08:16,349 --> 01:08:17,250
实现的，有

1713
01:08:17,250 --> 01:08:18,359
选项可供选择

1714
01:08:18,359 --> 01:08:20,009
就像它确实与

1715
01:08:20,009 --> 01:08:21,899
它拥有的所有类型的索引一致，然后您可以编写

1716
01:08:21,899 --> 01:08:24,330
信息，例如描述

1717
01:08:24,330 --> 01:08:27,179
它实际所做的事情

1718
01:08:27,179 --> 01:08:28,469


1719
01:08:28,469 --> 01:08:29,810


1720
01:08:29,810 --> 01:08:31,589


1721
01:08:31,589 --> 01:08:34,109
网站，所以我创建了这个网站，

1722
01:08:34,109 --> 01:08:35,880
称为数据库 DVD

1723
01:08:35,880 --> 01:08:39,000
视频数据库我想将 DV 传输到 i/o，但后来

1724
01:08:39,000 --> 01:08:40,738
要求 IBM 提起诉讼，所以

1725
01:08:40,738 --> 01:08:43,770
我们没有这样做 所以它的

1726
01:08:43,770 --> 01:08:45,270
基本工作方式是用

1727
01:08:45,270 --> 01:08:46,889
不同的方法对不同的

1728
01:08:46,889 --> 01:08:48,299
数据库系统进行分类以找到您要

1729
01:08:48,299 --> 01:08:50,069
查找的内容，因此在这种情况下，这里

1730
01:08:50,069 --> 01:08:51,089
是所有在 rust 中实现的数据系统

1731
01:08:51,089 --> 01:08:52,979
，然后

1732
01:08:52,979 --> 01:08:54,179
这里又是一篇文章 它

1733
01:08:54,179 --> 01:08:55,529
准确地描述了一切是如何工作的，

1734
01:08:55,529 --> 01:08:56,819
并且有关于一切正常的引文，

1735
01:08:56,819 --> 01:09:01,139
所以我会在 Piazza 上张贴一张

1736
01:09:01,139 --> 01:09:03,448
注册表，让你拼写来选择

1737
01:09:03,448 --> 01:09:05,759
你想再次使用的数据库系统

1738
01:09:05,759 --> 01:09:07,259
人们这是我们第二年这样

1739
01:09:07,259 --> 01:09:10,560
做，所以他们 不是每个

1740
01:09:10,560 --> 01:09:12,118
系统都会激活你，

1741
01:09:12,118 --> 01:09:14,130
但那里有足够的系统

1742
01:09:14,130 --> 01:09:15,960
，每个人都应该没有问题

1743
01:09:15,960 --> 01:09:18,238
来实际选择你想要的东西，所以

1744
01:09:18,238 --> 01:09:19,770
先到先得，所以当我在

1745
01:09:19,770 --> 01:09:22,049
网上发布时，当我发布时 在线登记表

1746
01:09:22,049 --> 01:09:24,988
我会在 Piazza 上宣布，

1747
01:09:24,988 --> 01:09:28,560
然后无论谁先到达那里，您都知道

1748
01:09:28,560 --> 01:09:30,238
可以进入任何系统 很多 Long 已

1749
01:09:30,238 --> 01:09:31,679
获得批准，因此请考虑

1750
01:09:31,679 --> 01:09:33,089
一下，如果您选择了一个更广泛的

1751
01:09:33,089 --> 01:09:36,270
系统 你像 Oracle 一样知道和使用，然后

1752
01:09:36,270 --> 01:09:37,679
有很多文档，有

1753
01:09:37,679 --> 01:09:38,908
很多关于它实际上如何工作的信息，

1754
01:09:38,908 --> 01:09:40,319
所以如果你选择一个晦涩的系统，你希望

1755
01:09:40,319 --> 01:09:41,460
写出非常全面的东西，有很多

1756
01:09:41,460 --> 01:09:44,509
引用，

1757
01:09:44,509 --> 01:09:47,219
那么这可能会有问题，因为

1758
01:09:47,219 --> 01:09:48,448
它可能 没有那么多可用的文档

1759
01:09:48,448 --> 01:09:51,509
，因此在这种情况下，我可以

1760
01:09:51,509 --> 01:09:52,408
让您与实际实施它的人取得联系

1761
01:09:52,408 --> 01:09:53,520
，他们可以

1762
01:09:53,520 --> 01:09:54,869
提供我让

1763
01:09:54,869 --> 01:09:56,159
以前的学生在留言板上发布的信息，

1764
01:09:56,159 --> 01:09:58,770
或者在 Twitter 上向人们发送信息，

1765
01:09:58,770 --> 01:09:59,969
他们从信息中询问 这个假设

1766
01:09:59,969 --> 01:10:02,159
实际上是如何运作的 去年一个学生

1767
01:10:02,159 --> 01:10:04,290
选择了一个

1768
01:10:04,290 --> 01:10:05,909
在 1980 年代只存在三年的系统，然后她联系

1769
01:10:05,909 --> 01:10:07,020
了实际编写它的人，

1770
01:10:07,020 --> 01:10:08,820
因为他是麻省理工学院

1771
01:10:08,820 --> 01:10:10,590
的校友，对，这实际上有点令人难以接受，人们

1772
01:10:10,590 --> 01:10:13,380
试图获取这些信息 所以

1773
01:10:13,380 --> 01:10:16,139
你得到的是没有注册并获得一个帐户

1774
01:10:16,139 --> 01:10:17,429
，它将是一个这样的页面，你可以

1775
01:10:17,429 --> 01:10:19,080
再次编辑你可以看到它不是

1776
01:10:19,080 --> 01:10:20,790
自由形式 所有内容的文本，您可以

1777
01:10:20,790 --> 01:10:22,800
准确选择您如何了解

1778
01:10:22,800 --> 01:10:23,730
系统的不同部分或实际

1779
01:10:23,730 --> 01:10:27,119
实施它，因此这可能

1780
01:10:27,119 --> 01:10:30,510
是我要选择的数据库系统，我会选择正确的，我

1781
01:10:30,510 --> 01:10:32,280
只想说那里有足够的

1782
01:10:32,280 --> 01:10:34,380
它们，您应该没有问题

1783
01:10:34,380 --> 01:10:36,330
找到一个你想要的所以我想

1784
01:10:36,330 --> 01:10:39,900
我目前我知道 636 个

1785
01:10:39,900 --> 01:10:41,670
不同的数据库系统 所以

1786
01:10:41,670 --> 01:10:43,250
分布式系统 嵌入式

1787
01:10:43,250 --> 01:10:45,090
系统 用不同语言编写的系统

1788
01:10:45,090 --> 01:10:49,940
可以追溯到 1968 年我们有一个或 65 个

1789
01:10:49,940 --> 01:10:53,070
所以你应该没有问题

1790
01:10:53,070 --> 01:10:54,720
找到一个数据集 这

1791
01:10:54,720 --> 01:10:58,340
激起了你真正的兴趣 是的 是

1792
01:10:58,340 --> 01:11:01,770
什么 等等 一些傻笑是的

1793
01:11:01,770 --> 01:11:06,990
我知道这不是真的 是的 这实际上

1794
01:11:06,990 --> 01:11:08,550
它甚至不是全部 这仍然

1795
01:11:08,550 --> 01:11:10,230
是一个子集 这可能是我喜欢其中的

1796
01:11:10,230 --> 01:11:12,240
400 还有另外 230 我知道

1797
01:11:12,240 --> 01:11:15,120
好吧，你怎么能解决

1798
01:11:15,120 --> 01:11:16,950
你想选择的系统

1799
01:11:16,950 --> 01:11:18,690
，如果你关心你选择原产国你

1800
01:11:18,690 --> 01:11:20,400
知道数据库是用巴西或

1801
01:11:20,400 --> 01:11:23,790
中国或印度写的，我们有这些正确的基础

1802
01:11:23,790 --> 01:11:26,190
编辑流行度，所以我知道我会跟踪

1803
01:11:26,190 --> 01:11:28,620
哪些页面可以最正确地查看我

1804
01:11:28,620 --> 01:11:29,610
可以告诉你你放哪一个你

1805
01:11:29,610 --> 01:11:30,900
应该注意你看看

1806
01:11:30,900 --> 01:11:32,400
法国有这个用 Java 或

1807
01:11:32,400 --> 01:11:34,950
JavaScript 编写的，无论谷歌

1808
01:11:34,950 --> 01:11:36,390
选择我们的原因是什么 无论您不使用哪种编程语言，我们都会获得大量

1809
01:11:36,390 --> 01:11:38,400
流量，

1810
01:11:38,400 --> 01:11:39,690
然后如果您

1811
01:11:39,690 --> 01:11:41,520
喜欢 rust，您喜欢 go，您就像看到我们

1812
01:11:41,520 --> 01:11:43,560
有一个用 bash 编写的数据库 写

1813
01:11:43,560 --> 01:11:45,060
任何你想要的东西 我们

1814
01:11:45,060 --> 01:11:46,380
有你想要的东西 将它发送到

1815
01:11:46,380 --> 01:11:47,910
数据库 嵌入式数据库 单节点

1816
01:11:47,910 --> 01:11:49,620
数据库 我们有这些话语

1817
01:11:49,620 --> 01:11:51,060
内存烘焙 行存储与列存储

1818
01:11:51,060 --> 01:11:53,190
商业与开源或

1819
01:11:53,190 --> 01:11:55,140
企业 我们拥有它 我们拥有

1820
01:11:55,140 --> 01:11:57,090
一切 如果我们有时间 我们可以查看

1821
01:11:57,090 --> 01:11:58,200
排行榜 看看是哪一个

1822
01:11:58,200 --> 01:12:00,000
系统实际上出现得最多，

1823
01:12:00,000 --> 01:12:01,080
你知道哪个国家的编程语言，

1824
01:12:01,080 --> 01:12:04,530
我必须这么说，

1825
01:12:04,530 --> 01:12:06,390
因为 Lea 分享了这并没有发生，所以

1826
01:12:06,390 --> 01:12:09,180
不要抄袭，所以你会把

1827
01:12:09,180 --> 01:12:11,190
它分成两部分 o 零件

1828
01:12:11,190 --> 01:12:12,540
第一部分会像一个检查站，

1829
01:12:12,540 --> 01:12:14,790
也许在感恩节过后，

1830
01:12:14,790 --> 01:12:16,140
我们会仔细检查它并给您反馈，让您

1831
01:12:16,140 --> 01:12:18,810
知道您是否走在正确的轨道上，让您

1832
01:12:18,810 --> 01:12:19,920
知道自己是否在做正确的事情，

1833
01:12:19,920 --> 01:12:21,060
然后就会有 决赛周的最后一次

1834
01:12:21,060 --> 01:12:22,380
提交，这就是

1835
01:12:22,380 --> 01:12:24,210
你获得这两个提交的最终成绩的地方

1836
01:12:24,210 --> 01:12:27,240
不要抄袭去年

1837
01:12:27,240 --> 01:12:28,260
我们有人从

1838
01:12:28,260 --> 01:12:30,540
维基百科上粘贴棉花，他们把它放在那里，

1839
01:12:30,540 --> 01:12:31,590
我们抓住他们的原因是因为

1840
01:12:31,590 --> 01:12:33,270
他们没有 去删除

1841
01:12:33,270 --> 01:12:35,970
你知道的所有引用的括号所以我们不得不

1842
01:12:35,970 --> 01:12:37,920
去华纳大厅报告这是非常

1843
01:12:37,920 --> 01:12:41,760
非常混乱好的所以不要抄袭

1844
01:12:41,760 --> 01:12:43,500
不要复制任何东西不要

1845
01:12:43,500 --> 01:12:45,570
从互联网上复制图像不要假设这是

1846
01:12:45,570 --> 01:12:46,230
有人

1847
01:12:46,230 --> 01:12:47,730
抄写系统 他们的专家

1848
01:12:47,730 --> 01:12:48,780
他们比你更了解，因此

1849
01:12:48,780 --> 01:12:51,390
你觉得重写它是错误的我

1850
01:12:51,390 --> 01:12:53,190
不在乎不要复制任何东西因为你的

1851
01:12:53,190 --> 01:12:54,840
名字会出现在这个这是

1852
01:12:54,840 --> 01:12:55,860
在互联网上公开的

1853
01:12:55,860 --> 01:12:57,720
所以你知道如果你玩驱动 es 我们必须

1854
01:12:57,720 --> 01:13:02,970
去报告你 好的 是的 问题

1855
01:13:02,970 --> 01:13:05,870
是如果你引用了图片 我宁愿不

1856
01:13:05,870 --> 01:13:19,860
你可以没有图片 是的 II

1857
01:13:19,860 --> 01:13:22,190
不会太担心我的图片 是的

1858
01:13:22,190 --> 01:13:33,720
是的 所以这是一种工作方式，因为

1859
01:13:33,720 --> 01:13:34,890
我是学生 我过去做过这件事，

1860
01:13:34,890 --> 01:13:37,140
他们不是，他们不希望所有人

1861
01:13:37,140 --> 01:13:38,580
都具有相同的质量，所以我将提供一份

1862
01:13:38,580 --> 01:13:42,080
清单，列出您不应该从中挑选的那些，

1863
01:13:45,620 --> 01:13:48,960
所以是的，如果我对此有所关注，您

1864
01:13:48,960 --> 01:13:50,130
应该选择您应该挑选的 总是

1865
01:13:50,130 --> 01:13:52,770
假设最新版本是正确的，所以如果

1866
01:13:52,770 --> 01:13:54,270
他们在五年前做了一些事情

1867
01:13:54,270 --> 01:13:55,920
并得到修复我不在乎五

1868
01:13:55,920 --> 01:13:57,060
年前只是描述它现在做什么

1869
01:13:57,060 --> 01:13:58,590
你可以提到他们曾经以

1870
01:13:58,590 --> 01:14:00,450
某种方式做但我会关注如果你

1871
01:14:00,450 --> 01:14:04,200
只关注它现在是如何存在的 是的

1872
01:14:04,200 --> 01:14:06,230
[音乐]

1873
01:14:06,230 --> 01:14:08,640
我会死或者你会离开

1874
01:14:08,640 --> 01:14:09,510
就像别担心别担心它

1875
01:14:09,510 --> 01:14:11,880
是的 实际上我们已经有一些公司

1876
01:14:11,880 --> 01:14:14,700
与我们联系并且我们允许 他们来

1877
01:14:14,700 --> 01:14:17,310
编辑页面，但再次就像我

1878
01:14:17,310 --> 01:14:19,310
喜欢策划它我希望他们避免

1879
01:14:19,310 --> 01:14:21,900
像我们一样的营销狗屎

1880
01:14:21,900 --> 01:14:23,280
最快的数据库，就像所有这些废话一样，我们

1881
01:14:23,280 --> 01:14:27,350
保持它非常科学，是的

1882
01:14:32,210 --> 01:14:34,950
，逐案保留，有任何

1883
01:14:34,950 --> 01:14:35,850
系统，你特别是

1884
01:14:35,850 --> 01:14:37,739
嘴里的牙齿，因为我是蒙古人，

1885
01:14:37,739 --> 01:14:42,330
实际上已经很好了，所以

1886
01:14:42,330 --> 01:14:44,370
如果你必须去你 可以去，但让

1887
01:14:44,370 --> 01:14:47,250
我们快速查看一下网站

1888
01:14:47,250 --> 01:14:49,710
好吧 那么什么日期哪个国家的

1889
01:14:49,710 --> 01:14:51,860
飞机创建了最多的数据库系统

1890
01:14:51,860 --> 01:14:55,580
美国排名第二

1891
01:14:56,090 --> 01:15:01,910
他说他说俄罗斯是中国

1892
01:15:05,120 --> 01:15:11,370
法国和印度 好吧 所以

1893
01:15:11,370 --> 01:15:13,199
这个网站 所以 我们去

1894
01:15:13,199 --> 01:15:15,150
排行榜 实际上让我们这样做 就像

1895
01:15:15,150 --> 01:15:16,170
你可以再次点击任何数据库

1896
01:15:16,170 --> 01:15:20,310
系统 然后在这里 就像它

1897
01:15:20,310 --> 01:15:22,080
有原产国 所以有人说

1898
01:15:22,080 --> 01:15:24,120
中国 所以告诉你有

1899
01:15:24,120 --> 01:15:30,360
多少 中国有多少 中国有 28 美国

1900
01:15:30,360 --> 01:15:47,070
有我们 有 300 人说那是

1901
01:15:47,070 --> 01:15:49,830
什么 印度 什么是

1902
01:15:49,830 --> 01:16:05,580
印度代码 in5 俄罗斯是你 21 你

1903
01:16:05,580 --> 01:16:12,620
错过了它 德国 44 对

1904
01:16:12,680 --> 01:16:15,960
法国不太好 所以我

1905
01:16:15,960 --> 01:16:18,510
可以点击这个 然后我可以

1906
01:16:18,510 --> 01:16:19,800
像编程语言一样点击 是

1907
01:16:19,800 --> 01:16:20,969
实现它，所以这个是用 C++ 编写的，

1908
01:16:20,969 --> 01:16:26,310
直到 101 什么

1909
01:16:26,310 --> 01:16:27,180
可能是最

1910
01:16:27,180 --> 01:16:29,090
常用的数据库系统编程语言，

1911
01:16:29,090 --> 01:16:33,090
每个人都坚持导弹我们看到

1912
01:16:33,090 --> 01:16:38,420
掌声的 C 组合是的 Java

1913
01:16:38,420 --> 01:16:40,560
对，所以我们去写这个排行榜的

1914
01:16:40,560 --> 01:16:43,670
东西在这里它 说正确的细分，

1915
01:16:43,670 --> 01:16:45,840
所以这是国家/地区的细分

1916
01:16:45,840 --> 01:16:48,660
德国是排名第二的

1917
01:16:48,660 --> 01:16:50,160
Java 是最常见的编程

1918
01:16:50,160 --> 01:16:51,719
语言，但是如果您将 C++

1919
01:16:51,719 --> 01:16:55,350
和 C 结合在一起，那么它就会通过它

1920
01:16:55,350 --> 01:16:57,540
，然后我们也会跟踪

1921
01:16:57,540 --> 01:16:59,280
数据库系统使用的内容 其他数据库

1922
01:16:59,280 --> 01:17:00,930
系统，所以这些是这些嵌入式

1923
01:17:00,930 --> 01:17:02,370
数据库，就像摇滚电视

1924
01:17:02,370 --> 01:17:05,130
一样，像时钟蟑螂电视这样的一堆系统使用

1925
01:17:05,130 --> 01:17:07,020
摇滚数据库作为内部存储，

1926
01:17:07,020 --> 01:17:09,030
然后他们就可以使用了 最重要的是，

1927
01:17:09,030 --> 01:17:11,270
还有一些系统已经分叉了

1928
01:17:11,270 --> 01:17:13,740
其他系统并将其用作

1929
01:17:13,740 --> 01:17:16,140
邀请，所以有很多

1930
01:17:16,140 --> 01:17:18,690
公司已经分叉了 Postgres 并使用它

1931
01:17:18,690 --> 01:17:21,420
，以及我的续集，有

1932
01:17:21,420 --> 01:17:23,970
两个最常见的，所以你再次明白

1933
01:17:23,970 --> 01:17:25,080
为什么 我们试图正确跟踪所有

1934
01:17:25,080 --> 01:17:28,800
这些事情，所以我

1935
01:17:28,800 --> 01:17:34,200
总共知道，因为我说的是 630 无论如何，所以如果

1936
01:17:34,200 --> 01:17:35,670
你找到一个系统，我认为这会

1937
01:17:35,670 --> 01:17:36,810
非常有帮助，如果你知道

1938
01:17:36,810 --> 01:17:38,040
你是否来自印度 或者中国或者

1939
01:17:38,040 --> 01:17:39,840
你来自的任何国家，有一个

1940
01:17:39,840 --> 01:17:41,580
数据库系统是用

1941
01:17:41,580 --> 01:17:43,350
那种我不知道的语言写的，让我

1942
01:17:43,350 --> 01:17:45,260
知道吧，因为我想知道这样的

1943
01:17:45,260 --> 01:17:47,460
事情会永远持续下去，

1944
01:17:47,460 --> 01:17:50,670
我有很多哦，好吧 我要

1945
01:17:50,670 --> 01:17:53,580
发布的是今天的 Piazza 项目 3

1946
01:17:53,580 --> 01:17:55,100
将在今天或明天宣布

1947
01:17:55,100 --> 01:17:58,650
，然后你知道的更好，我们将

1948
01:17:58,650 --> 01:18:00,450
为此设置一个很棒的脚本，然后

1949
01:18:00,450 --> 01:18:01,920
我们将在周三上课，然后

1950
01:18:01,920 --> 01:18:04,020
下周开始时 下周一

1951
01:18:04,020 --> 01:18:06,930
将是 mov 即我的研究生，

1952
01:18:06,930 --> 01:18:08,070


1953
01:18:08,070 --> 01:18:09,150
如果你

1954
01:18:09,150 --> 01:18:11,400
想看期中考试，我会在这之后立即有办公时间，但我不会

1955
01:18:11,400 --> 01:18:16,730
在这周晚些时候出现，伙计们，

1956
01:18:25,340 --> 01:18:28,709
他在我的系统中度过了机智的夜晚，我很

1957
01:18:28,709 --> 01:18:29,159
幸运，

1958
01:18:29,159 --> 01:18:30,689
让我们去参加下一个 然后克服

1959
01:18:30,689 --> 01:18:37,949
潜水服好网将儿子弹跳

1960
01:18:37,949 --> 01:18:39,630
果冻撞到熟食店乘船

1961
01:18:39,630 --> 01:18:41,579
自然祝福你说唱就像

1962
01:18:41,579 --> 01:18:43,469
激光束灌木丛中的电话

1963
01:18:43,469 --> 01:18:45,719
什么也不说就像链子包裹我们的瓶子

1964
01:18:45,719 --> 01:18:47,789
一个很好的同情去你不

1965
01:18:47,789 --> 01:18:49,650
不想喝醉酒给你喝那种骨头

1966
01:18:49,650 --> 01:18:51,989


1967
01:18:51,989 --> 01:18:55,820


