1
00:00:01,300 --> 00:00:05,129
[音乐]

2
00:00:05,200 --> 00:00:05,930
[掌声]

3
00:00:05,930 --> 00:00:08,630
[音乐]

4
00:00:08,630 --> 00:00:10,020
[掌声]

5
00:00:10,020 --> 00:00:11,540
[音乐]

6
00:00:11,540 --> 00:00:14,700
今天是我们关于查询优化的讲座的第三部分

7
00:00:14,700 --> 00:00:18,000


8
00:00:18,000 --> 00:00:20,340
，我又回到了我的家庭办公室，只有我和小

9
00:00:20,340 --> 00:00:23,609
猎犬可能会或可能不会提出

10
00:00:23,609 --> 00:00:25,430
问题 我们继续，

11
00:00:25,430 --> 00:00:29,519
所以到目前为止我们讨论的优化器类型

12
00:00:29,519 --> 00:00:32,520
是

13
00:00:32,520 --> 00:00:34,950
这种经典的查询优化器，其中

14
00:00:34,950 --> 00:00:37,440
查询出现我们解析续集然后

15
00:00:37,440 --> 00:00:38,730
我们通过优化器运行它并

16
00:00:38,730 --> 00:00:41,219
在我们开始执行之前生成一个计划

17
00:00:41,219 --> 00:00:43,649
查询 这是大多数

18
00:00:43,649 --> 00:00:45,809
查询优化器正常工作的方式 显然

19
00:00:45,809 --> 00:00:47,850
你不能运行查询，除非你有

20
00:00:47,850 --> 00:00:49,559
一个查询计划所以你必须把它

21
00:00:49,559 --> 00:00:51,719
通过优化器但是

22
00:00:51,719 --> 00:00:54,600
挑战将是我们

23
00:00:54,600 --> 00:00:58,739
认为最好的计划

24
00:00:58,739 --> 00:01:00,390
在我们开始运行之前，这个优化阶段的旅程

25
00:01:00,390 --> 00:01:03,510
实际上可能是不

26
00:01:03,510 --> 00:01:06,420
正确的，因为我们无法

27
00:01:06,420 --> 00:01:08,520
在没有计划的情况下实际运行查询，

28
00:01:08,520 --> 00:01:10,619
因此我们必须

29
00:01:10,619 --> 00:01:12,479
对数据库和

30
00:01:12,479 --> 00:01:15,360
环境做出一些假设 看起来像，但是这些事情

31
00:01:15,360 --> 00:01:17,490
会因各种原因随着时间的推移而发生变化，

32
00:01:17,490 --> 00:01:20,280
因此数据库的物理设计可能

33
00:01:20,280 --> 00:01:22,439
会发生变化，因为

34
00:01:22,439 --> 00:01:24,090
管理员应用程序可以添加

35
00:01:24,090 --> 00:01:25,740
和删除索引或更改

36
00:01:25,740 --> 00:01:28,829
分区方案数据库

37
00:01:28,829 --> 00:01:30,540
本身可能会被修改人们可以

38
00:01:30,540 --> 00:01:32,460
插入元组或删除 元组，如果我们将查询作为准备好的语句调用，这

39
00:01:32,460 --> 00:01:33,840
可能会改变我们列的值的分布，

40
00:01:33,840 --> 00:01:37,049


41
00:01:37,049 --> 00:01:39,799


42
00:01:39,799 --> 00:01:43,649
那么对于另一组参数，一组参数的查询行为

43
00:01:43,649 --> 00:01:44,909
可能会有所不同

44
00:01:44,909 --> 00:01:46,950
，当然

45
00:01:46,950 --> 00:01:50,040
每次运行时 分析或

46
00:01:50,040 --> 00:01:52,619
我们数据库系统中的任何命令来

47
00:01:52,619 --> 00:01:54,810
回忆我们在每次更新成本模型时使用的统计数据，那么我们将

48
00:01:54,810 --> 00:01:57,180


49
00:01:57,180 --> 00:01:59,969


50
00:01:59,969 --> 00:02:01,710
在优化器中做出的决定可能完全

51
00:02:01,710 --> 00:02:05,610
不同，所以今天的重点

52
00:02:05,610 --> 00:02:07,979
是理解 我们如何才能

53
00:02:07,979 --> 00:02:12,180
潜在地提高我们的优化器的

54
00:02:12,180 --> 00:02:13,569
效率我们

55
00:02:13,569 --> 00:02:15,040
的质量

56
00:02:15,040 --> 00:02:16,900
可能是由 r 生成的计划 放宽这一

57
00:02:16,900 --> 00:02:18,340
要求，即我们只

58
00:02:18,340 --> 00:02:20,109
生成计划或仅重新访问

59
00:02:20,109 --> 00:02:23,349
假设，或者一旦我们开始生成计划，我们就永远不会访问我们的

60
00:02:23,349 --> 00:02:25,299
假设，

61
00:02:25,299 --> 00:02:27,790
因此为了做到这一点，我们想

62
00:02:27,790 --> 00:02:30,939
了解一下糟糕

63
00:02:30,939 --> 00:02:33,120
的查询盘是什么样的。

64
00:02:33,120 --> 00:02:35,409
可能会被认为是糟糕的，然后最终会

65
00:02:35,409 --> 00:02:39,099
得到低于最佳性能的结果，所以

66
00:02:39,099 --> 00:02:41,680
我们将在周三讨论成本模型时更多地讨论这个问题，

67
00:02:41,680 --> 00:02:44,590
但总的来说，我

68
00:02:44,590 --> 00:02:46,450
说高级别

69
00:02:46,450 --> 00:02:48,790
我们总是会遇到的最大问题是我们”

70
00:02:48,790 --> 00:02:50,349
重新获得连接顺序是不正确的

71
00:02:50,349 --> 00:02:52,030
连接几乎总是

72
00:02:52,030 --> 00:02:53,919
我们在

73
00:02:53,919 --> 00:02:56,950
分析工作负载中执行的最昂贵的事情，因此如果我们得到的

74
00:02:56,950 --> 00:03:00,189
排序不正确可能导致

75
00:03:00,189 --> 00:03:02,530
性能太差以及

76
00:03:02,530 --> 00:03:05,319
我们要这样做的原因 选择不正确的

77
00:03:05,319 --> 00:03:07,269
排序是因为我们会有

78
00:03:07,269 --> 00:03:08,919
不准确的基数估计，

79
00:03:08,919 --> 00:03:11,590
这意味着我们认为我们的连接

80
00:03:11,590 --> 00:03:13,659
会产生 X 个元组，但它

81
00:03:13,659 --> 00:03:16,389
真的会是你知道 X x 线你

82
00:03:16,389 --> 00:03:19,690
知道一些 一些更大的倍数他们

83
00:03:19,690 --> 00:03:21,549
移动它会再次发生我们将

84
00:03:21,549 --> 00:03:23,949
在下一讲中讨论为什么会更多地发生这种情况

85
00:03:23,949 --> 00:03:27,489
但是这个问题

86
00:03:27,489 --> 00:03:28,989
将成为我们必须克服的反复出现的主题

87
00:03:28,989 --> 00:03:31,870
今天的讨论

88
00:03:31,870 --> 00:03:36,299
是一种C技术来做到这一点

89
00:03:36,299 --> 00:03:38,560
但是因为我们知道事情会变

90
00:03:38,560 --> 00:03:40,479
糟，就像我们只知道我们可以

91
00:03:40,479 --> 00:03:42,129
假设我们的成本模型意味着

92
00:03:42,129 --> 00:03:43,690
准确或优化器会做出错误的

93
00:03:43,690 --> 00:03:47,709
决定那么理想情况下，如果我们能够

94
00:03:47,709 --> 00:03:51,099
在我们开始运行查询计划时检测到它的糟糕程度

95
00:03:51,099 --> 00:03:53,650
，那么我们 可以

96
00:03:53,650 --> 00:03:57,790
决定调整计划以进行

97
00:03:57,790 --> 00:03:59,979
潜在的修改以解决这些

98
00:03:59,979 --> 00:04:01,540
差异以及我们在

99
00:04:01,540 --> 00:04:02,919
真实数据中看到的内容与我们假设

100
00:04:02,919 --> 00:04:05,229
将要看到的内容，然后我们可以尝试

101
00:04:05,229 --> 00:04:08,919
将我们的计划转换为

102
00:04:08,919 --> 00:04:12,310
一些更接近最佳计划的

103
00:04:12,310 --> 00:04:13,989
东西所以我的意思是说我们

104
00:04:13,989 --> 00:04:15,489
有一个像这样的简单查询它是

105
00:04:15,489 --> 00:04:17,649
八个表之间的四向连接 a BC

106
00:04:17,649 --> 00:04:19,449
和 D 然后我们只有一个简单

107
00:04:19,449 --> 00:04:23,289
的 B 和 D 的 where 子句 塔 bles 所以

108
00:04:23,289 --> 00:04:26,050
假设我们通过

109
00:04:26,050 --> 00:04:27,400
我们的查询优化器运行这个查询并且我们

110
00:04:27,400 --> 00:04:29,440
正确地执行这个计划它是一堆散列

111
00:04:29,440 --> 00:04:30,820
图并且没有关于顺序

112
00:04:30,820 --> 00:04:34,930
扫描但是假设当我们

113
00:04:34,930 --> 00:04:36,400
为这个特定连接生成这个计划时

114
00:04:36,400 --> 00:04:39,220
我们估计了基数

115
00:04:39,220 --> 00:04:43,000
该运算符为 1000 对，

116
00:04:43,000 --> 00:04:44,770
这是我用于此插图的任意数字，

117
00:04:44,770 --> 00:04:46,360
例如

118
00:04:46,360 --> 00:04:48,639
基数是

119
00:04:48,639 --> 00:04:51,490
该运算符全部为 MIT 的元组数，但假设当

120
00:04:51,490 --> 00:04:52,870
我们实际开始运行它时，我们

121
00:04:52,870 --> 00:04:55,210
看到实际上正在生成一个

122
00:04:55,210 --> 00:04:58,870
十万个元组所以我们的实际

123
00:04:58,870 --> 00:05:00,430
基数比估计的基数大两个数量级

124
00:05:00,430 --> 00:05:03,940
所以

125
00:05:03,940 --> 00:05:05,289
我们今天要处理的问题是我们

126
00:05:05,289 --> 00:05:07,389


127
00:05:07,389 --> 00:05:10,570
是否在开始执行之前就知道我们的音调是什么地区

128
00:05:10,570 --> 00:05:12,280
我很

129
00:05:12,280 --> 00:05:15,550
抱歉 重新执行它然后我们是否可以

130
00:05:15,550 --> 00:05:18,789
更改此查询计划的某些方面以

131
00:05:18,789 --> 00:05:22,570
使我们更接近更优化的计划

132
00:05:22,570 --> 00:05:23,740
但是我们可以更改 Jordan 的

133
00:05:23,740 --> 00:05:25,270
排序我们想要选择不同的

134
00:05:25,270 --> 00:05:27,160
alg  orithm 做好我们的连接 我们想要

135
00:05:27,160 --> 00:05:28,570
改变可能在连接下面使用的访问方法

136
00:05:28,570 --> 00:05:31,599
，可能是

137
00:05:31,599 --> 00:05:33,250
索引或不同

138
00:05:33,250 --> 00:05:36,130
类型的骗局 所以这就是我们

139
00:05:36,130 --> 00:05:37,840
今天关注的重点是如何然后可能

140
00:05:37,840 --> 00:05:40,570
适应 这是这种计划，当我们

141
00:05:40,570 --> 00:05:42,669
知道

142
00:05:42,669 --> 00:05:46,000
一旦我们开始运行数据的样子，

143
00:05:46,000 --> 00:05:51,430
那么高级想法再次是我们

144
00:05:51,430 --> 00:05:53,229
希望能够执行，但您可能会问

145
00:05:53,229 --> 00:05:56,020
计划的行为是为了

146
00:05:56,020 --> 00:05:58,599
确定 X 可能是一个

147
00:05:58,599 --> 00:06:01,389
计划的行为 确定其相

148
00:06:01,389 --> 00:06:02,260
对于其他计划的质量

149
00:06:02,260 --> 00:06:04,599
，因此成本模型正在做，但

150
00:06:04,599 --> 00:06:06,490
棘手的事情是

151
00:06:06,490 --> 00:06:08,320
在我开始执行我们之前回到这里

152
00:06:08,320 --> 00:06:11,349
我必须

153
00:06:11,349 --> 00:06:14,289
从我的类似统计中得出这个基数 我已经

154
00:06:14,289 --> 00:06:16,419
维护了我的目录，关于我的

155
00:06:16,419 --> 00:06:18,880
表的外观，

156
00:06:18,880 --> 00:06:20,530
或者当你将它们连接在一起时这两个表的外观

157
00:06:20,530 --> 00:06:25,120
，所以统计数据是我基于

158
00:06:25,120 --> 00:06:27,310
直方图和

159
00:06:27,310 --> 00:06:29,199
我们从数据中收集的样本，我们也可以

160
00:06:29,199 --> 00:06:32,139
决定

161
00:06:32,139 --> 00:06:33,460
硬件看起来像什么样的缓存

162
00:06:33,460 --> 00:06:34,810
大小我们有什么样的也许

163
00:06:34,810 --> 00:06:36,969
我不想使用其他什么查询

164
00:06:36,969 --> 00:06:38,680
并且同时遇到像成本模型一样的

165
00:06:38,680 --> 00:06:40,599
东西我们将在下一堂课中介绍但

166
00:06:40,599 --> 00:06:41,230
然后是

167
00:06:41,230 --> 00:06:43,090
主要思想 要考虑的是我们

168
00:06:43,090 --> 00:06:45,070
今天讨论的是在我们运行查询之前，

169
00:06:45,070 --> 00:06:48,250
我们只估计

170
00:06:48,250 --> 00:06:49,780
数据的样子以及我们的查询

171
00:06:49,780 --> 00:06:53,530
将如何执行，如果我们弄错了，我们

172
00:06:53,530 --> 00:06:54,880
想要尝试能够纠正

173
00:06:54,880 --> 00:06:58,210
自己，以便 我们

174
00:06:58,210 --> 00:07:00,490
今天谈论的技术称为自适应查询

175
00:07:00,490 --> 00:07:02,530
优化，有时在

176
00:07:02,530 --> 00:07:04,450
研究文献中称为自适应查询

177
00:07:04,450 --> 00:07:06,550
处理，它们本质上

178
00:07:06,550 --> 00:07:08,890
是同义词，到目前为止我所说的所有内容中

179
00:07:08,890 --> 00:07:11,410
的想法是这种技术

180
00:07:11,410 --> 00:07:12,790
将允许数据库系统

181
00:07:12,790 --> 00:07:17,290
修改 查询的查询计划以

182
00:07:17,290 --> 00:07:19,450
更好地适应实际底层

183
00:07:19,450 --> 00:07:22,300
数据的样子，我们

184
00:07:22,300 --> 00:07:24,490
在查询计划之前进行修改，只需生成

185
00:07:24,490 --> 00:07:26,470
一个全新的查询计划，例如

186
00:07:26,470 --> 00:07:29,620
丢弃 旧的并重新开始，或者我们

187
00:07:29,620 --> 00:07:32,800
可以尝试

188
00:07:32,800 --> 00:07:34,840
通过

189
00:07:34,840 --> 00:07:37,090
引入新类型的子计划来修改查询计划的子集，

190
00:07:37,090 --> 00:07:40,030
就像在不同点的管道一样

191
00:07:40,030 --> 00:07:41,230
，我们必须在那里实现人们

192
00:07:41,230 --> 00:07:43,240
，我们可能会从

193
00:07:43,240 --> 00:07:45,850
你知道的人那里切换 将策略规划到

194
00:07:45,850 --> 00:07:48,850
另一个，这里你基本上

195
00:07:48,850 --> 00:07:50,500
回到优化器并在这里重新开始

196
00:07:50,500 --> 00:07:52,810
这个是你可以尝试

197
00:07:52,810 --> 00:07:56,500
让优化器只重新规划

198
00:07:56,500 --> 00:07:57,910
它的一部分或

199
00:07:57,910 --> 00:08:00,960
在开始时提供这些替代策略

200
00:08:00,960 --> 00:08:05,140
主要的主要外卖

201
00:08:05,140 --> 00:08:06,660
方法我们在这里做的是，

202
00:08:06,660 --> 00:08:09,040
而不是仅仅依赖我们的

203
00:08:09,040 --> 00:08:10,750
统计模型，

204
00:08:10,750 --> 00:08:12,430
我们对数据的估计或

205
00:08:12,430 --> 00:08:14,230
近似值我们正在尝试使用我们收集的数据，

206
00:08:14,230 --> 00:08:16,870
而我们实际上 执行

207
00:08:16,870 --> 00:08:18,870
查询，然后帮助我们决定

208
00:08:18,870 --> 00:08:21,850
对于我们的特定查询正确的计划应该是什么，

209
00:08:21,850 --> 00:08:25,000


210
00:08:25,000 --> 00:08:27,610
我们将收集的这些数据可用于

211
00:08:27,610 --> 00:08:32,020
帮助我们当前的查询 或合并它，我们

212
00:08:32,020 --> 00:08:33,520
可以将它合并回系统，因为

213
00:08:33,520 --> 00:08:35,440
我们通过分析操作收集到的数据

214
00:08:35,440 --> 00:08:38,380
并将其用于其他

215
00:08:38,380 --> 00:08:42,099
查询，因此我们将再次介绍

216
00:08:42,099 --> 00:08:44,440
您必须执行此操作的各种方法，但是当您

217
00:08:44,440 --> 00:08:45,760
考虑查询时 实际上，

218
00:08:45,760 --> 00:08:47,590
您知道吗，或者

219
00:08:47,590 --> 00:08:50,320
分析器执行顺序扫描以

220
00:08:50,320 --> 00:08:52,660
计算一些

221
00:08:52,660 --> 00:08:54,910
有关数据外观的统计模型

222
00:08:54,910 --> 00:08:58,120
，因此如果我们

223
00:08:58,120 --> 00:09:00,550
在表上进行香菜扫描，该表与分析的内容基本

224
00:09:00,550 --> 00:09:01,960
相同，那么这些是什么，而

225
00:09:01,960 --> 00:09:03,880
不是 只是评估谓词或

226
00:09:03,880 --> 00:09:05,980
使用你知道的元组，因为我们扫描它们

227
00:09:05,980 --> 00:09:08,650
以生成我们需要的特定查询的结果，

228
00:09:08,650 --> 00:09:10,150
我们可以

229
00:09:10,150 --> 00:09:13,300
捎带那些关闭的扫描

230
00:09:13,300 --> 00:09:16,360
运算符和排序主要或维护或

231
00:09:16,360 --> 00:09:20,440
更新我们的和更新我们的 Cisco 模型

232
00:09:20,440 --> 00:09:22,390
有了新信息，这里的问题

233
00:09:22,390 --> 00:09:24,250
是我们是否只是

234
00:09:24,250 --> 00:09:26,020
为自己更新该模型以使我们的

235
00:09:26,020 --> 00:09:28,900
查询更好地进行 Oracle 您可以与

236
00:09:28,900 --> 00:09:30,730
其他查询共享此在全局

237
00:09:30,730 --> 00:09:32,880
目录中 查询可以

238
00:09:32,880 --> 00:09:36,450
从我们收集的数据中受益，

239
00:09:36,450 --> 00:09:39,250


240
00:09:39,250 --> 00:09:43,600
所以我想使用

241
00:09:43,600 --> 00:09:46,330
qo 或自适应查询优化涵盖三大类，其中之一

242
00:09:46,330 --> 00:09:49,840
是我们可以使用 qo 来使

243
00:09:49,840 --> 00:09:52,840
我们查询的未来调用受益 第二种

244
00:09:52,840 --> 00:09:54,370
方法是尝试使我们当前

245
00:09:54,370 --> 00:09:56,440
对查询的调用更好，

246
00:09:56,440 --> 00:09:59,500
然后最后一个会很好这就像

247
00:09:59,500 --> 00:10:00,760
帮助您当前的查询这也

248
00:10:00,760 --> 00:10:02,170
有助于您当前的查询但是这

249
00:10:02,170 --> 00:10:03,670
将是

250
00:10:03,670 --> 00:10:06,760
从头开始，只是

251
00:10:06,760 --> 00:10:07,840
再次运行优化器，

252
00:10:07,840 --> 00:10:11,470
这将在

253
00:10:11,470 --> 00:10:13,900
查询计划中添加位置，允许您更改一种

254
00:10:13,900 --> 00:10:15,640
策略，而您知道将

255
00:10:15,640 --> 00:10:17,500
一种策略切换到下一种策略，而后者又

256
00:10:17,500 --> 00:10:19,420
不得不返回优化器，因此

257
00:10:19,420 --> 00:10:21,400
我们将通过 每一个都一个

258
00:10:21,400 --> 00:10:28,240
一个，所以最简单的

259
00:10:28,240 --> 00:10:30,850
自适应查询优化形式是正如我所说的

260
00:10:30,850 --> 00:10:36,190
，当我们执行我们的查询时，我们还

261
00:10:36,190 --> 00:10:37,840
收集了一些关于数据是什么

262
00:10:37,840 --> 00:10:40,810
样子的信息 然后我们可以使用该

263
00:10:40,810 --> 00:10:43,090
信息来决定我们的查询

264
00:10:43,090 --> 00:10:45,730
是否错误以及何时计划它，或者当您考虑这一点时，我们可以

265
00:10:45,730 --> 00:10:49,300
再次将其合并回那种

266
00:10:49,300 --> 00:10:50,980
全局目录中，

267
00:10:50,980 --> 00:10:52,060
如果

268
00:10:52,060 --> 00:10:53,680
优化实际上正在执行您有一堆

269
00:10:53,680 --> 00:10:55,270
关于

270
00:10:55,270 --> 00:10:57,280
你的属性是什么样的直方图或统计模型

271
00:10:57,280 --> 00:10:59,380
因此，对于 where 子句中的给定谓词，

272
00:10:59,380 --> 00:11:01,180
您想估计

273
00:11:01,180 --> 00:11:02,830
该谓词的选择性，因为

274
00:11:02,830 --> 00:11:04,750
我不确定您的扫描将发出多少个元组

275
00:11:04,750 --> 00:11:07,030
以及做出

276
00:11:07,030 --> 00:11:08,470
决定的乐趣 您

277
00:11:08,470 --> 00:11:10,000
在查询计划中的排序和其他事情期间

278
00:11:10,000 --> 00:11:14,560


279
00:11:14,560 --> 00:11:17,140
执行扫描，如果您知道您

280
00:11:17,140 --> 00:11:18,490
实际上知道真正的选择性，

281
00:11:18,490 --> 00:11:19,900
因为您正在应用谓词

282
00:11:19,900 --> 00:11:21,280
和元组并且您知道

283
00:11:21,280 --> 00:11:23,440
元组的数量 或

284
00:11:23,440 --> 00:11:26,020
元组的百分比将匹配，因此如果

285
00:11:26,020 --> 00:11:28,150
您确定成本模型

286
00:11:28,150 --> 00:11:30,640
估计我的选择性为百分之一，

287
00:11:30,640 --> 00:11:33,880
但是当我运行实际查询并运行查询时

288
00:11:33,880 --> 00:11:35,470
尝试并实际

289
00:11:35,470 --> 00:11:37,420
对谓词进行评估，我的选择性为 99

290
00:11:37,420 --> 00:11:40,060
% 然后我想使用该

291
00:11:40,060 --> 00:11:41,950
信息来帮助我决定是否

292
00:11:41,950 --> 00:11:44,590
重新计划我的查询或未来的查询

293
00:11:44,590 --> 00:11:47,650
出现他们你能知道利用

294
00:11:47,650 --> 00:11:51,010
我再次获得的知识

295
00:11:51,010 --> 00:11:53,410
一种方法是尝试修复我

296
00:11:53,410 --> 00:11:55,180
当前的查询，但另一种方法只是

297
00:11:55,180 --> 00:11:58,750
将其合并回

298
00:11:58,750 --> 00:12:03,400
模型的整体神秘牛

299
00:12:03,400 --> 00:12:06,670
和目录中，以便我可以

300
00:12:06,670 --> 00:12:10,360
在将来帮助查询的脚，所以最

301
00:12:10,360 --> 00:12:11,830
执行此操作的基本方法称为基于

302
00:12:11,830 --> 00:12:14,230
回归的工厂校正，

303
00:12:14,230 --> 00:12:16,600
这里的想法正如我所说的只是

304
00:12:16,600 --> 00:12:18,820
每次我调用查询时我

305
00:12:18,820 --> 00:12:20,920
跟踪我生成的查询计划

306
00:12:20,920 --> 00:12:22,420
我跟踪我的成本

307
00:12:22,420 --> 00:12:25,300
估算和 然后我将

308
00:12:25,300 --> 00:12:26,770
获得所有指标，了解

309
00:12:26,770 --> 00:12:28,090
当我正确运行时实际发生的事情

310
00:12:28,090 --> 00:12:29,890
有多少元组我

311
00:12:29,890 --> 00:12:31,330
选择了我使用了多少 CPU 和内存，

312
00:12:31,330 --> 00:12:34,180
并且我将

313
00:12:34,180 --> 00:12:36,640
在数据库本身内部维护此历史记录 所以你会

314
00:12:36,640 --> 00:12:38,350
在像 db2 Oracle 和 Seigle 服务器这样的商业系统中看到这一点，

315
00:12:38,350 --> 00:12:42,340
他们

316
00:12:42,340 --> 00:12:46,210
有这个内置

317
00:12:46,210 --> 00:12:47,470
的每个查询历史的存储库

318
00:12:47,470 --> 00:12:49,210
，他们可以使用这些

319
00:12:49,210 --> 00:12:51,370
信息来帮助决定如何进行

320
00:12:51,370 --> 00:12:54,730
查询计划 在未来，

321
00:12:54,730 --> 00:12:56,080
假设我们有一个准备好的语句，或者

322
00:12:56,080 --> 00:12:57,190
我们有一个一直被调用的查询

323
00:12:57,190 --> 00:12:59,380
，我们有一个缓存

324
00:12:59,380 --> 00:13:01,570
查询计划，而不是

325
00:13:01,570 --> 00:13:02,950
每次

326
00:13:02,950 --> 00:13:05,890
我们可以使用缓存采石场计划时都通过优化器运行它

327
00:13:05,890 --> 00:13:07,150
我们已经从之前的

328
00:13:07,150 --> 00:13:10,990
影响中产生了所以如果现在我们的数据发生

329
00:13:10,990 --> 00:13:16,150
变化，你知道统计数据

330
00:13:16,150 --> 00:13:18,250
或关于数据库物理

331
00:13:18,250 --> 00:13:20,620
设计的一些变化，我们认识

332
00:13:20,620 --> 00:13:22,209
到我们可能想要这个

333
00:13:22,209 --> 00:13:24,309
奇怪的东西，甚至继续调用我们想要的

334
00:13:24,309 --> 00:13:26,439
通过优化器运行它并看到我们

335
00:13:26,439 --> 00:13:28,929
生成了 C 我们生成了一个新计划

336
00:13:28,929 --> 00:13:30,670
但是当我们为此查询运行该新计划时，

337
00:13:30,670 --> 00:13:33,129
如果我们发现

338
00:13:33,129 --> 00:13:36,369
查询的性能比旧的 pl 差

339
00:13:36,369 --> 00:13:38,829
我们之前

340
00:13:38,829 --> 00:13:41,829
有过的一个

341
00:13:41,829 --> 00:13:43,869
，如果性能出现回归，我们只想回到它，我们切换

342
00:13:43,869 --> 00:13:45,639
回我们知道实际上

343
00:13:45,639 --> 00:13:47,470
对我们表现更好的计划，尽管

344
00:13:47,470 --> 00:13:49,839
物理设计或统计模型中的另一个发生了变化

345
00:13:49,839 --> 00:13:53,230
所以我们

346
00:13:53,230 --> 00:13:54,339
使用那个简单的查询示例，我

347
00:13:54,339 --> 00:13:57,009
有一个正确的四向连接再说

348
00:13:57,009 --> 00:13:59,679
一遍这是我的原始计划我

349
00:13:59,679 --> 00:14:01,269
没有做特殊扫描和

350
00:14:01,269 --> 00:14:03,519
哈希图并说我的估计

351
00:14:03,519 --> 00:14:06,249
成本是一千，我的成本

352
00:14:06,249 --> 00:14:07,660
估计是 非常好，所以我的实际

353
00:14:07,660 --> 00:14:09,730
成本实际上与这里的合成数字相匹配，

354
00:14:09,730 --> 00:14:12,699
所以我

355
00:14:12,699 --> 00:14:15,009
将在我的数据库系统的执行历史中存储我

356
00:14:15,009 --> 00:14:16,869
为

357
00:14:16,869 --> 00:14:18,550
这个查询生成的我生成了这个计划，

358
00:14:18,550 --> 00:14:21,999
当我运行它时，我有这个成本和这个

359
00:14:21,999 --> 00:14:24,220
只是

360
00:14:24,220 --> 00:14:26,319
我的数据库系统中的另一个数据库或另一个表，对吧，您是

361
00:14:26,319 --> 00:14:27,939
在吃自己的狗粮，而

362
00:14:27,939 --> 00:14:31,269
不是拥有一个腋窝商店，这

363
00:14:31,269 --> 00:14:33,040
只是另一个表，您希望将

364
00:14:33,040 --> 00:14:35,619
这些信息全部记录下来 现在

365
00:14:35,619 --> 00:14:37,540
假设我们的数据库发生了变化，

366
00:14:37,540 --> 00:14:39,999
假设 DBA 出现

367
00:14:39,999 --> 00:14:43,569
并在 D 表中的 B 表上添加了两个索引

368
00:14:43,569 --> 00:14:45,610
，我们在

369
00:14:45,610 --> 00:14:47,889
where 子句中使用了这些索引，所以现在当我们

370
00:14:47,889 --> 00:14:50,170
再次调用相同的查询时，我们 会认识到

371
00:14:50,170 --> 00:14:52,749
数据库的设计已经

372
00:14:52,749 --> 00:14:54,339
改变，我们可能不想

373
00:14:54,339 --> 00:14:58,119
重新考虑这个特定查询的查询计划，

374
00:14:58,119 --> 00:14:59,799
所以这个查询

375
00:14:59,799 --> 00:15:02,259
很好地触及了 B 点 Val 和 D 点 Val 我

376
00:15:02,259 --> 00:15:03,850
只是碰巧在这些列上创建了索引，

377
00:15:03,850 --> 00:15:06,399
所以 我想再次通过我的优化器运行它并

378
00:15:06,399 --> 00:15:08,069
再次查看什么计划

379
00:15:08,069 --> 00:15:10,869
让我们现在说新计划它

380
00:15:10,869 --> 00:15:12,220
完全不同所以现在我们

381
00:15:12,220 --> 00:15:14,290
不是运行散列连接或运行

382
00:15:14,290 --> 00:15:15,699
索引嵌套循环连接，我们正在做

383
00:15:15,699 --> 00:15:17,769
一个索引扫描超越 D 我们

384
00:15:17,769 --> 00:15:19,629
现在可以做，因为我们有索引

385
00:15:19,629 --> 00:15:21,999
，我们以前没有，所以现在

386
00:15:21,999 --> 00:15:24,160
我们要为我们的查询选择这个计划，

387
00:15:24,160 --> 00:15:26,799
因为 St 估计成本是 800

388
00:15:26,799 --> 00:15:28,689
，比估计成本低，

389
00:15:28,689 --> 00:15:30,610
所以我们有 在这里但是当我们

390
00:15:30,610 --> 00:15:33,160
无论出于何种原因实际运行它，

391
00:15:33,160 --> 00:15:34,509
我们认为此时我们不关心

392
00:15:34,509 --> 00:15:38,199
实际成本是 1200

393
00:15:38,199 --> 00:15:40,799
这可能是因为您知道我们

394
00:15:40,799 --> 00:15:43,059
错误地估计

395
00:15:43,059 --> 00:15:44,290
这些嵌套循环连接的成本会

396
00:15:44,290 --> 00:15:46,480
比散列连接便宜 所以我们选择了

397
00:15:46,480 --> 00:15:49,929
嵌套循环连接，所以就像以前一样，

398
00:15:49,929 --> 00:15:55,480
当我们实际放置它时，给我这

399
00:15:55,480 --> 00:15:58,870
不是 Corona 嗯，如果我们现在将

400
00:15:58,870 --> 00:16:01,179
它放入我们的额外历史中，我们会

401
00:16:01,179 --> 00:16:05,699
认识到，对于这个计划

402
00:16:05,699 --> 00:16:07,749
，它再次表现得比另一个更差

403
00:16:07,749 --> 00:16:09,939
一个在这里，所以下次我们调用它时，

404
00:16:09,939 --> 00:16:11,499
我们要确保我们使用这个

405
00:16:11,499 --> 00:16:13,540
计划哦，你想回顾

406
00:16:13,540 --> 00:16:17,919
一下我们知道性能更好的那个，所以对于

407
00:16:17,919 --> 00:16:20,199
这里的这种方法，这是

408
00:16:20,199 --> 00:16:22,540
微软在续集服务器中所拥有的东西，我

409
00:16:22,540 --> 00:16:24,490
认为 Oracle 可能从 2012-2013 年开始有类似的东西，

410
00:16:24,490 --> 00:16:28,449
但这是非常

411
00:16:28,449 --> 00:16:29,769
粗粒度的，这是非常

412
00:16:29,769 --> 00:16:31,209
脑残的启发式方法，基本上是

413
00:16:31,209 --> 00:16:34,660
说哦，这个查询计划很糟糕，让

414
00:16:34,660 --> 00:16:36,790
我切换回我说的这个，所以

415
00:16:36,790 --> 00:16:39,669
我 这根本不是或什么都不是，所以

416
00:16:39,669 --> 00:16:40,809
你们被分配

417
00:16:40,809 --> 00:16:42,579
从微软读取的付款被称为计划拼接

418
00:16:42,579 --> 00:16:44,709


419
00:16:44,709 --> 00:16:46,869
，如果我们认识到我们的

420
00:16:46,869 --> 00:16:49,990
查询运行速度比

421
00:16:49,990 --> 00:16:52,269
我们过去看到的查询计划慢，那么眼睛高低的想法是完全相同的 而不是

422
00:16:52,269 --> 00:16:56,350
整个

423
00:16:56,350 --> 00:16:58,089
查询计划的强大方式，即新的查询计划并

424
00:16:58,089 --> 00:17:00,089
恢复到旧的查询计划，也许

425
00:17:00,089 --> 00:17:03,100


426
00:17:03,100 --> 00:17:06,010
在新计划中存在我们

427
00:17:06,010 --> 00:17:09,849
实际上不想保留的元素或方面或子计划，因为然后

428
00:17:09,849 --> 00:17:11,799
那些数据' 将帮助我们引导我们

429
00:17:11,799 --> 00:17:13,359
走向一个更好的计划，一个更

430
00:17:13,359 --> 00:17:16,630
优化的计划，另一个，如果您也

431
00:17:16,630 --> 00:17:18,069
考虑植物缝合，

432
00:17:18,069 --> 00:17:22,119
那么您将从

433
00:17:22,119 --> 00:17:24,789
其他查询中借用的子计划实际上不需要

434
00:17:24,789 --> 00:17:26,409
来自同一个查询 就像在这种情况下

435
00:17:26,409 --> 00:17:29,830
，我只能以

436
00:17:29,830 --> 00:17:31,630
最简单的形式重用计划我只能交换团队

437
00:17:31,630 --> 00:17:33,220
计划，如果他们在完全相同的查询上运行

438
00:17:33,220 --> 00:17:35,289
但有计划的缝合，

439
00:17:35,289 --> 00:17:38,049
因为我可以删除子计划或

440
00:17:38,049 --> 00:17:39,850
部分查询 你的计划只要

441
00:17:39,850 --> 00:17:41,020
他们知道它们在逻辑上是

442
00:17:41,020 --> 00:17:43,059
等效的 我可以

443
00:17:43,059 --> 00:17:46,899
从其他查询中获取点点滴滴

444
00:17:46,899 --> 00:17:48,640
另一件事是，

445
00:17:48,640 --> 00:17:50,770
如果物理设计发生变化，

446
00:17:50,770 --> 00:17:52,540
我们是一个新的星球 查询计划

447
00:17:52,540 --> 00:17:55,570
变得无效 就像它定义的

448
00:17:55,570 --> 00:17:57,040
那样，它不会进行索引扫描，但是

449
00:17:57,040 --> 00:17:59,020
然后我删除了该索引，而不是仅仅

450
00:17:59,020 --> 00:18:01,450
将整个查询扔掉

451
00:18:01,450 --> 00:18:03,280
整个查询星球我

452
00:18:03,280 --> 00:18:05,890
可能会提取它的部分类型，因此

453
00:18:05,890 --> 00:18:07,570
他们的基本方法是 将要使用的

454
00:18:07,570 --> 00:18:09,790
是或他们将要生成

455
00:18:09,790 --> 00:18:13,360
这些缝合计划的方式是一种

456
00:18:13,360 --> 00:18:15,430
使用自下而上的方法的动态编程搜索

457
00:18:15,430 --> 00:18:18,100
方法，您只需

458
00:18:18,100 --> 00:18:20,050


459
00:18:20,050 --> 00:18:21,220
按照我们所做的相同方式检查从一个级别到下一个级别的视图

460
00:18:21,220 --> 00:18:23,620
系统正在逐一记

461
00:18:23,620 --> 00:18:26,770
下选择哪个子

462
00:18:26,770 --> 00:18:28,720
计划最好，然后一旦

463
00:18:28,720 --> 00:18:31,270
达到最终目标，您就会发现

464
00:18:31,270 --> 00:18:33,550
最便宜的路径，因此这意味着

465
00:18:33,550 --> 00:18:36,190
不能保证找到比最好的计划更好的计划

466
00:18:36,190 --> 00:18:38,920
计划你 到目前为止，

467
00:18:38,920 --> 00:18:41,950
并不能保证总是制定

468
00:18:41,950 --> 00:18:46,300
作战计划，但是有一些基本的

469
00:18:46,300 --> 00:18:47,320
启发式方法，因此您可以使用它来确保

470
00:18:47,320 --> 00:18:49,300
正确发生，因此回到我们

471
00:18:49,300 --> 00:18:53,380
这里的示例，正确地说这是我们的

472
00:18:53,380 --> 00:18:55,780
新计划并说它正在起作用

473
00:18:55,780 --> 00:18:57,430
很好，就像它实际上更快，

474
00:18:57,430 --> 00:18:59,590
所以我们总是想使用它，但是现在如果

475
00:18:59,590 --> 00:19:01,540
我出现并删除

476
00:19:01,540 --> 00:19:03,970
我正在使用的索引之一，我正在使用这个计划现在

477
00:19:03,970 --> 00:19:07,600
变得无效，并且在

478
00:19:07,600 --> 00:19:08,740
粗粒度的恢复下

479
00:19:08,740 --> 00:19:11,200
我不能 重用它，但使用计划拼接

480
00:19:11,200 --> 00:19:13,330
我实际上想弄清楚

481
00:19:13,330 --> 00:19:15,610
查询计划的这个子计划的哪些组件

482
00:19:15,610 --> 00:19:17,680
我可能想在

483
00:19:17,680 --> 00:19:19,390
新计划中使用，即使总体上它是

484
00:19:19,390 --> 00:19:20,980
无效的，但仍有部分

485
00:19:20,980 --> 00:19:23,260
仍然可用，所以在那个 状态的

486
00:19:23,260 --> 00:19:24,760
情况 说或说这部

487
00:19:24,760 --> 00:19:27,430
分子计划 这部分查询的子计划

488
00:19:27,430 --> 00:19:30,610
挤压成本是 600，

489
00:19:30,610 --> 00:19:31,930
我们会知道这一点，因为我们可以

490
00:19:31,930 --> 00:19:35,200
跟踪每一个，尽管

491
00:19:35,200 --> 00:19:37,690
所有操作符的棘轮运行时间成本在艺术

492
00:19:37,690 --> 00:19:40,630
和 一种 quarium 和这里的这个

493
00:19:40,630 --> 00:19:43,420
子平面的成本是 150 所以

494
00:19:43,420 --> 00:19:45,160
现在如果我将它们组合成一个

495
00:19:45,160 --> 00:19:47,410
缝合计划这个案例的总成本

496
00:19:47,410 --> 00:19:51,040
将是 750 而以前如果我不

497
00:19:51,040 --> 00:19:53,110
运行它它是一千所以 再一次的

498
00:19:53,110 --> 00:19:54,730
想法是，我们希望能够

499
00:19:54,730 --> 00:19:56,710
借用不同

500
00:19:56,710 --> 00:19:59,590
查询计划的点点滴滴，并帮助我们生成

501
00:19:59,590 --> 00:20:00,990
更优化的计划

502
00:20:00,990 --> 00:20:03,030
，这

503
00:20:03,030 --> 00:20:05,280
与 Microsoft 续集服务器的常规优化器分开完成。

504
00:20:05,280 --> 00:20:06,900


505
00:20:06,900 --> 00:20:08,460
运行级联 - 他们

506
00:20:08,460 --> 00:20:10,470
实际上是在进行自上而下的搜索，

507
00:20:10,470 --> 00:20:12,420
但这是一种辅助搜索

508
00:20:12,420 --> 00:20:15,630
，它在后台运行，

509
00:20:15,630 --> 00:20:17,970
它试图找到一个

510
00:20:17,970 --> 00:20:20,580
可以拼接在一起的计划，所以让我们谈谈

511
00:20:20,580 --> 00:20:23,490
他们实际上是如何做到这一点的

512
00:20:23,490 --> 00:20:25,260
第一步是您需要确定哪些

513
00:20:25,260 --> 00:20:27,390
部分是我们查询中的哪些单元格计划在

514
00:20:27,390 --> 00:20:30,020
逻辑上是等效的，

515
00:20:30,020 --> 00:20:32,970
我们之前在 live Cascades 下讨论过

516
00:20:32,970 --> 00:20:34,740
当我们有我们想知道的多

517
00:20:34,740 --> 00:20:36,990
组多表达式组时

518
00:20:36,990 --> 00:20:41,490
如果给定

519
00:20:41,490 --> 00:20:44,540
某个计划的输出

520
00:20:44,540 --> 00:20:48,059
与另一个子计划相同或等效，

521
00:20:48,059 --> 00:20:50,910
我们必须再次依赖

522
00:20:50,910 --> 00:20:52,890
关系代数规则来识别哪些

523
00:20:52,890 --> 00:20:54,990
操作可以是可交换的或可

524
00:20:54,990 --> 00:20:58,320
关联的，因此在这种情况下，这

525
00:20:58,320 --> 00:21:01,050
部分 单元计划的输出

526
00:21:01,050 --> 00:21:04,410
是被连接的连接 看到

527
00:21:04,410 --> 00:21:06,990
另一个子计划的这一部分是输出是 C

528
00:21:06,990 --> 00:21:09,960
连接 B 的连接 a 但由于连接这些

529
00:21:09,960 --> 00:21:12,030
内部连接是可交换的，我们

530
00:21:12,030 --> 00:21:15,150
知道它们现在在逻辑上是等效的，

531
00:21:15,150 --> 00:21:18,450
正如我所说的

532
00:21:18,450 --> 00:21:22,860
与此有关的一个挑战是，确定

533
00:21:22,860 --> 00:21:25,880
任何任意逻辑表达式或

534
00:21:25,880 --> 00:21:29,460
逻辑子计划是否等效已

535
00:21:29,460 --> 00:21:31,920
被证明是不可判定的意义，

536
00:21:31,920 --> 00:21:34,590
例如这两个

537
00:21:34,590 --> 00:21:36,480
单元格计划在逻辑上是否等效之类的

538
00:21:36,480 --> 00:21:39,000
问题是是或否的答案，但没有

539
00:21:39,000 --> 00:21:41,700
算法 事实证明

540
00:21:41,700 --> 00:21:44,400
，可以保证始终

541
00:21:44,400 --> 00:21:47,280
给出正确答案，因此在

542
00:21:47,280 --> 00:21:48,840
计划缝合阶段，他们将依赖

543
00:21:48,840 --> 00:21:50,490
于一些额外的启发式方法 s 来

544
00:21:50,490 --> 00:21:52,980
识别诸如 oh 我知道

545
00:21:52,980 --> 00:21:54,990
这两个子计划正在访问

546
00:21:54,990 --> 00:21:56,490
不同的表，因此它们

547
00:21:56,490 --> 00:21:57,900
不能在逻辑上等效，您

548
00:21:57,900 --> 00:21:59,690
显然可以做更复杂的事情

549
00:21:59,690 --> 00:22:02,640
，续集服务器中的优化器本身

550
00:22:02,640 --> 00:22:05,059
也有这些检查

551
00:22:05,059 --> 00:22:08,220
，所以 他们也依赖于这一点，因此他们

552
00:22:08,220 --> 00:22:09,480
有自己的启发式方法来修剪

553
00:22:09,480 --> 00:22:11,760
永远不会在逻辑上

554
00:22:11,760 --> 00:22:13,800
等效的事物，并且他们依靠续集

555
00:22:13,800 --> 00:22:14,590
服务器优化器

556
00:22:14,590 --> 00:22:19,480
识别

557
00:22:19,480 --> 00:22:21,070
您试图混合在一起的逻辑子平面或

558
00:22:21,070 --> 00:22:22,090
试图匹配的子平面

559
00:22:22,090 --> 00:22:26,919
在缝合计划中在一起是无效的，所以

560
00:22:26,919 --> 00:22:28,600
启发式为他们提供了

561
00:22:28,600 --> 00:22:31,419
这种在实施难度之间的最佳平衡点

562
00:22:31,419 --> 00:22:33,669


563
00:22:33,669 --> 00:22:36,520
对称执行器规则

564
00:22:36,520 --> 00:22:40,150
确定它们是否

565
00:22:40,150 --> 00:22:41,650
等效的准确性，然后是

566
00:22:41,650 --> 00:22:43,299
正确的性能 不是对不同单元计划的所有可能输入的详尽搜索和

567
00:22:43,299 --> 00:22:45,159
详尽评估，

568
00:22:45,159 --> 00:22:47,020


569
00:22:47,020 --> 00:22:50,230
它只是基于关系算法的规则

570
00:22:50,230 --> 00:22:53,169
ebra 好的，所以现在一旦我们

571
00:22:53,169 --> 00:22:55,840
确定我们有一堆

572
00:22:55,840 --> 00:22:58,840
等效的子计划，我们想

573
00:22:58,840 --> 00:23:00,580
弄清楚我们想将它们

574
00:23:00,580 --> 00:23:03,850
组合在一起成一个巨大的查询计划

575
00:23:03,850 --> 00:23:04,899
，您将在其中添加一些

576
00:23:04,899 --> 00:23:08,140
额外的运算符来确定

577
00:23:08,140 --> 00:23:09,520
您 可以有分支沿着

578
00:23:09,520 --> 00:23:11,559
子计划中的不同路径走，

579
00:23:11,559 --> 00:23:13,659
所以这就是他们将如何将

580
00:23:13,659 --> 00:23:16,299


581
00:23:16,299 --> 00:23:17,860
每个针脚的子计划的所有不同组合编码

582
00:23:17,860 --> 00:23:20,289
在一起，所以这将

583
00:23:20,289 --> 00:23:21,220
是他们将要工作的方式 引入

584
00:23:21,220 --> 00:23:23,529
这个实际上并不用于执行的新的 or 运算符，

585
00:23:23,529 --> 00:23:25,870
这只是

586
00:23:25,870 --> 00:23:28,299
用于搜索的东西， or

587
00:23:28,299 --> 00:23:30,669
基本上表明它下面的子计划

588
00:23:30,669 --> 00:23:35,200
在逻辑上是等效的，所以我们

589
00:23:35,200 --> 00:23:37,990
可以选择任何一条路径，所以

590
00:23:37,990 --> 00:23:40,570
从我们有的顶部开始

591
00:23:40,570 --> 00:23:43,029
一开始就有一个 or 子句，然后我们

592
00:23:43,029 --> 00:23:44,440
有两个用于这个特定查询的

593
00:23:44,440 --> 00:23:46,480
我们有你知道的做散列连接

594
00:23:46,480 --> 00:23:49,270
或嵌套循环连接，

595
00:23:49,270 --> 00:23:50,320
这些在逻辑上是等效的，因为

596
00:23:50,320 --> 00:23:52,419
这 s 是联合 B 联合 c.join D

597
00:23:52,419 --> 00:23:55,630
这是 C 加入 B 加入约翰 D 并且

598
00:23:55,630 --> 00:23:57,159
那些在连接中是可交换的，

599
00:23:57,159 --> 00:23:59,309
因此这些在逻辑上是等价的，

600
00:23:59,309 --> 00:24:02,529
所以现在说往下走，我们会

601
00:24:02,529 --> 00:24:04,690
像深度优先一样 搜索在

602
00:24:04,690 --> 00:24:07,750
这一边的这一边在这里同样的

603
00:24:07,750 --> 00:24:09,370
事情我们在 a 和 B 上进行哈希连接，

604
00:24:09,370 --> 00:24:11,380
然后是 C 这是在 C 上的下一个循环

605
00:24:11,380 --> 00:24:14,230
联合，然后是 C 连接是再次加入 a

606
00:24:14,230 --> 00:24:16,480
这些在逻辑上是等效的，

607
00:24:16,480 --> 00:24:17,770
这就是为什么我们有 or 子句我们可以

608
00:24:17,770 --> 00:24:19,600
选择任何一个然后我们将

609
00:24:19,600 --> 00:24:21,010
继续向下直到我们

610
00:24:21,010 --> 00:24:23,950
在计划扫描中到达我们的叶节点然后在这里我们

611
00:24:23,950 --> 00:24:25,000
没有看到我们没有

612
00:24:25,000 --> 00:24:27,620


613
00:24:27,620 --> 00:24:29,420
在查询的这一部分中为我们提供另一个选项 计划

614
00:24:29,420 --> 00:24:31,340
因为我们缝合的那个

615
00:24:31,340 --> 00:24:33,380
只有一个散列连接

616
00:24:33,380 --> 00:24:35,809
所以现在在这种情况下对于散列

617
00:24:35,809 --> 00:24:38,210
捐赠者 a 我们可以像

618
00:24:38,210 --> 00:24:39,680
我们在第一个计划中看到的那样进行顺序扫描已经知道

619
00:24:39,680 --> 00:24:41,870
B 上的索引扫描

620
00:24:41,870 --> 00:24:43,070
来自第二个计划，所以我们有一个

621
00:24:43,070 --> 00:24:45,890
or 运营商来表示要

622
00:24:45,890 --> 00:24:46,460
备份 在这里，

623
00:24:46,460 --> 00:24:48,680
我们只能对 C 进行顺序扫描，因此

624
00:24:48,680 --> 00:24:50,450
这是一条直线路径，返回到

625
00:24:50,450 --> 00:24:53,090
这里进行嵌套循环连接，您能

626
00:24:53,090 --> 00:24:54,410
知道我们在下面只知道的事情是

627
00:24:54,410 --> 00:24:56,360
另一个嵌套循环连接，然后

628
00:24:56,360 --> 00:24:57,410
为此我们可以执行顺序操作

629
00:24:57,410 --> 00:25:00,410
扫描 a 或再次扫描 B 我们现在

630
00:25:00,410 --> 00:25:01,870
执行计划扫描或索引

631
00:25:01,870 --> 00:25:04,040
扫描返回这里再次进行哈希连接

632
00:25:04,040 --> 00:25:07,040
我们正在对 D 提供特殊

633
00:25:07,040 --> 00:25:08,960
扫描，然后我们只需

634
00:25:08,960 --> 00:25:11,030
像这样完成树的其余部分

635
00:25:11,030 --> 00:25:13,580
所以这

636
00:25:13,580 --> 00:25:14,960
是他们在论文中展示的内容的更简化版本，

637
00:25:14,960 --> 00:25:18,020
但这些实际上是

638
00:25:18,020 --> 00:25:22,340
您可以拥有的可能选项，所以我认为

639
00:25:22,340 --> 00:25:23,660
在论文中记得他们谈论的

640
00:25:23,660 --> 00:25:25,429
是这种方法并

641
00:25:25,429 --> 00:25:27,440
在此定义针迹中进行搜索

642
00:25:27,440 --> 00:25:29,809
计划他们能够将大约

643
00:25:29,809 --> 00:25:32,300
75 到几乎 100% 的所有

644
00:25:32,300 --> 00:25:34,070
计划拼接在一起，但是对于工作量

645
00:25:34,070 --> 00:25:36,800
，他们认为还不错，所以现在

646
00:25:36,800 --> 00:25:38,720
我们已经对搜索空间进行了编码，我们

647
00:25:38,720 --> 00:25:40,340
实际上想要进行搜索，这

648
00:25:40,340 --> 00:25:41,920
是 刚开始 从底部

649
00:25:41,920 --> 00:25:44,120
开始，以与系统相同的方式向上移动

650
00:25:44,120 --> 00:25:46,280
我们的动态编程搜索

651
00:25:46,280 --> 00:25:48,890
，我们只针对每个叶节点，

652
00:25:48,890 --> 00:25:51,410
我们开始计算

653
00:25:51,410 --> 00:25:54,350
下一个操作符的成本是多少，

654
00:25:54,350 --> 00:25:56,300
我们选择哪个是 最好

655
00:25:56,300 --> 00:25:58,760
，然后一旦我们完成所有

656
00:25:58,760 --> 00:25:59,840
我们对当前级别的所有节点进行此搜索，

657
00:25:59,840 --> 00:26:01,340
然后我们将进入下一个

658
00:26:01,340 --> 00:26:03,710
级别并完成此过程，

659
00:26:03,710 --> 00:26:05,120
所以说我们从中央扫描开始，

660
00:26:05,120 --> 00:26:07,610
它首先只有一个选项 这

661
00:26:07,610 --> 00:26:11,630
就是哦，它有一个散列连接

662
00:26:11,630 --> 00:26:15,530
一个 B 或或者

663
00:26:15,530 --> 00:26:17,480
这里的循环的必要性说散列

664
00:26:17,480 --> 00:26:20,330
连接更便宜所以我们选择现在我们

665
00:26:20,330 --> 00:26:22,309
只是紧缩将扫描一个 B 这有一个 or

666
00:26:22,309 --> 00:26:24,530
运算符好吧 这要么

667
00:26:24,530 --> 00:26:26,510
进行散列连接，要么进行下一个循环连接，并

668
00:26:26,510 --> 00:26:28,309
说散列连接更便宜，所以我们

669
00:26:28,309 --> 00:26:31,850
选择现在我们再次为 B 上的索引 kin 执行此操作，

670
00:26:31,850 --> 00:26:34,700
有一个 or 运算符，您需要

671
00:26:34,700 --> 00:26:36,260
在嵌套循环连接中使用理性，

672
00:26:36,260 --> 00:26:40,070
所以因为 我们有一个索引嵌套

673
00:26:40,070 --> 00:26:41,370
循环连接实际 如果我们选择它会更便宜

674
00:26:41,370 --> 00:26:43,410
，我们就继续

675
00:26:43,410 --> 00:26:45,180
沿着这条线对我们所有的叶节点执行此操作

676
00:26:45,180 --> 00:26:46,860
然后我们就完成了我们

677
00:26:46,860 --> 00:26:48,360
进入下一个级别然后再次现在我们

678
00:26:48,360 --> 00:26:51,150
对所有这些路径产生了成本

679
00:26:51,150 --> 00:26:53,490
我们只是选择哪一个

680
00:26:53,490 --> 00:26:56,040
对我们来说最便宜，然后我们

681
00:26:56,040 --> 00:27:00,420
重建我们以正确的方式制定了缝合计划，

682
00:27:00,420 --> 00:27:03,420
所以我认为这是一种

683
00:27:03,420 --> 00:27:04,770
有趣的方法

684
00:27:04,770 --> 00:27:07,050
我认为微软实际上并没有

685
00:27:07,050 --> 00:27:08,460
像这样在生产中运行它

686
00:27:08,460 --> 00:27:09,720
在 Sigma 上发表的一篇研究论文

687
00:27:09,720 --> 00:27:12,870
我不知道有任何其他系统

688
00:27:12,870 --> 00:27:14,280
在做类似的事情

689
00:27:14,280 --> 00:27:17,790
我从工程的角度

690
00:27:17,790 --> 00:27:19,020
来看，你必须将它

691
00:27:19,020 --> 00:27:22,380
与查询

692
00:27:22,380 --> 00:27:25,170
优化器分开运行，并且有一些单独的

693
00:27:25,170 --> 00:27:27,120
基础设施 如果有一个集成到查询优化器中的组件本身，那么

694
00:27:27,120 --> 00:27:29,390
你在做

695
00:27:31,490 --> 00:27:35,190
什么，而不是让你知道

696
00:27:35,190 --> 00:27:36,690
单独的搜索基础设施

697
00:27:36,690 --> 00:27:38,040


698
00:27:38,040 --> 00:27:40,440
我

699
00:27:40,440 --> 00:27:41,760
认为这将是一个有趣的

700
00:27:41,760 --> 00:27:45,179
方法，所以 e 是另一个系统，

701
00:27:45,179 --> 00:27:47,460
它执行类似于此计划

702
00:27:47,460 --> 00:27:49,740
拼接的操作，但它们实际上是

703
00:27:49,740 --> 00:27:54,480
在某种有说服力的级别

704
00:27:54,480 --> 00:27:55,890
而不是所谓的物理查询

705
00:27:55,890 --> 00:27:58,800
计划级别上工作，因此亚马逊拥有他们的 redshift

706
00:27:58,800 --> 00:28:02,610
数据仓库服务，它基于

707
00:28:02,610 --> 00:28:06,120
标准 Excel 和 他们实际上使用了

708
00:28:06,120 --> 00:28:08,730
一个翻译引擎，因此

709
00:28:08,730 --> 00:28:11,100
给定物理计划的数据库系统

710
00:28:11,100 --> 00:28:14,280
生成 C++ 代码或 C 代码，

711
00:28:14,280 --> 00:28:17,100
然后他们编译然后运行你

712
00:28:17,100 --> 00:28:19,260
知道他们调用

713
00:28:19,260 --> 00:28:20,820
来自编译器的共享对象，然后

714
00:28:20,820 --> 00:28:23,490
就是 他们如何进行查询编译

715
00:28:23,490 --> 00:28:26,150
所以显然最昂贵的部分

716
00:28:26,150 --> 00:28:28,830
你知道cogent引擎是

717
00:28:28,830 --> 00:28:30,059
在他们的情况下正确的编译他们

718
00:28:30,059 --> 00:28:31,860
实际上是分叉GCC或任何

719
00:28:31,860 --> 00:28:33,300
编译用于实际

720
00:28:33,300 --> 00:28:35,940
生成机器代码的东西，所以他们想尽量

721
00:28:35,940 --> 00:28:38,700
避免这种情况 每一个查询，所以

722
00:28:38,700 --> 00:28:41,429
他们可以做的是他们说你正在

723
00:28:41,429 --> 00:28:43,350
做你想要你想要编译

724
00:28:43,350 --> 00:28:46,080
B 上的扫描，你想要查看 B

725
00:28:46,080 --> 00:28:48,510
Val 等于一些输入参数

726
00:28:48,510 --> 00:28:50,550
所以教练和那部分

727
00:28:50,550 --> 00:28:53,580
通过编译器运行它，生成 x86 代码，

728
00:28:53,580 --> 00:28:55,430
然后他们会继续并兑现

729
00:28:55,430 --> 00:28:58,870
，然后现在任何时候你再投资疲倦

730
00:28:58,870 --> 00:29:02,120
你知道你可以重复使用

731
00:29:02,120 --> 00:29:05,000
光束上扫描的编译版本，但

732
00:29:05,000 --> 00:29:06,620
类似于 计划拼接他们还可以做的

733
00:29:06,620 --> 00:29:08,540
是，他们可以认识到，如果您有

734
00:29:08,540 --> 00:29:10,550
另一个具有相同

735
00:29:10,550 --> 00:29:13,790
谓词的查询，则 davao 等于您知道某些

736
00:29:13,790 --> 00:29:14,500
参数，

737
00:29:14,500 --> 00:29:17,180
它会生成完全相同的内容，

738
00:29:17,180 --> 00:29:19,400
而不是重新编译它，这

739
00:29:19,400 --> 00:29:20,990
再次扩展了 他们可以

740
00:29:20,990 --> 00:29:23,930
识别出他们有一个缓存计划

741
00:29:23,930 --> 00:29:27,590
片段用于此扫描，

742
00:29:27,590 --> 00:29:30,350
他们可以重用它，因此他们实际上

743
00:29:30,350 --> 00:29:34,370
可以在所有可能的情况下执行此操作，或者按所有客户执行此操作，

744
00:29:34,370 --> 00:29:36,440
这样您就

745
00:29:36,440 --> 00:29:39,560
知道在桌子上执行此扫描

746
00:29:39,560 --> 00:29:41,420
知道某些东西等于条形图字段上的某些东西，

747
00:29:41,420 --> 00:29:43,760


748
00:29:43,760 --> 00:29:45,650
从一张表到下一张表都相同，因为它是

749
00:29:45,650 --> 00:29:47,240
一列，确定您只是

750
00:29:47,240 --> 00:29:48,860
翻阅该列，以便他们实际上可以

751
00:29:48,860 --> 00:29:52,070
共享这些小片段 并将

752
00:29:52,070 --> 00:29:53,780
这些已

753
00:29:53,780 --> 00:29:55,670
编译查询计划的物理查询计划从

754
00:29:55,670 --> 00:29:58,430
您认识的所有可能的客户中拼接

755
00:29:58,430 --> 00:30:00,140


756
00:30:00,140 --> 00:30:02,270


757
00:30:02,270 --> 00:30:03,770


758
00:30:03,770 --> 00:30:05,960
在一起

759
00:30:05,960 --> 00:30:07,340
只需从有说服力的缓存中提取并将其

760
00:30:07,340 --> 00:30:09,680
拼接在一起，这有点

761
00:30:09,680 --> 00:30:10,870
酷，

762
00:30:10,870 --> 00:30:13,880
所以还有另一个有趣的

763
00:30:13,880 --> 00:30:17,360
系统要讨论的是 ibm 的

764
00:30:17,360 --> 00:30:19,490
学习优化器 leo，因此这是一个

765
00:30:19,490 --> 00:30:21,320
示例，说明您使用反馈

766
00:30:21,320 --> 00:30:24,400
循环来提高

767
00:30:24,400 --> 00:30:26,480
准确性 在系统中的成本模型中，

768
00:30:26,480 --> 00:30:30,830
我说的想法是，如果

769
00:30:30,830 --> 00:30:33,860
我在想要生成查询计划时跟踪我的成本模型

770
00:30:33,860 --> 00:30:35,210
估计值

771
00:30:35,210 --> 00:30:37,610
，然后在运行它时，如果

772
00:30:37,610 --> 00:30:39,500
我意识到这些估计值

773
00:30:39,500 --> 00:30:42,020
偏离了我 开始记录有关

774
00:30:42,020 --> 00:30:43,780
我在真实数据中看到的内容的信息，

775
00:30:43,780 --> 00:30:46,820
然后当我的采石场完成时，我

776
00:30:46,820 --> 00:30:49,160
将结果返回给用户或

777
00:30:49,160 --> 00:30:50,750
请求查询的应用程序

778
00:30:50,750 --> 00:30:53,620
但我也会用我收集的新信息更新我的成本模型

779
00:30:53,620 --> 00:30:55,820
辅助第六，

780
00:30:55,820 --> 00:30:59,090
所以我 BM 是

781
00:30:59,090 --> 00:31:00,980
Leo 实际上今天在 db2 中进行了生产，

782
00:31:00,980 --> 00:31:04,070
但这

783
00:31:04,070 --> 00:31:06,170
是商业系统的地球示例

784
00:31:06,170 --> 00:31:08,180
之一。 这些借方查询

785
00:31:08,180 --> 00:31:11,100
处理

786
00:31:11,100 --> 00:31:16,029
技术很好，所以我们谈论的植物拼接的

787
00:31:16,029 --> 00:31:17,470
东西或原始的

788
00:31:17,470 --> 00:31:21,909
东西是关于修复未来

789
00:31:21,909 --> 00:31:24,909
的查询调用，以根据

790
00:31:24,909 --> 00:31:26,619
我在实际执行查询时看到的结果来改进它们，

791
00:31:26,619 --> 00:31:28,389
但是 现在我们

792
00:31:28,389 --> 00:31:30,009
想谈谈我们如何修复我的

793
00:31:30,009 --> 00:31:33,009
查询以实现我的续集查询并且我

794
00:31:33,009 --> 00:31:35,320
确定我有一个糟糕的计划

795
00:31:35,320 --> 00:31:35,799
我该怎么做我该

796
00:31:35,799 --> 00:31:37,419
如何修复它因为我

797
00:31:37,419 --> 00:31:38,499
不想等待下一次

798
00:31:38,499 --> 00:31:39,850
调用我 想要修复我现在拥有的那个，

799
00:31:39,850 --> 00:31:42,399
所以我将其称为

800
00:31:42,399 --> 00:31:44,109
再次重播当前调用，

801
00:31:44,109 --> 00:31:45,909
这个想法是，如果我确定在执行

802
00:31:45,909 --> 00:31:48,850
查询计划时观察到的行为与查询计划

803
00:31:48,850 --> 00:31:51,609
的行为相去甚远或

804
00:31:51,609 --> 00:31:53,799
不同 估计的

805
00:31:53,799 --> 00:31:55,269
行为是 生成的成本模型

806
00:31:55,269 --> 00:31:58,739
然后我可以决定

807
00:31:58,739 --> 00:32:01,779
可能停止查询并

808
00:32:01,779 --> 00:32:03,789
返回并生成一个新计划，或者我可以

809
00:32:03,789 --> 00:32:07,679
决定可能有多少气味

810
00:32:08,519 --> 00:32:10,389
认识到我已经

811
00:32:10,389 --> 00:32:12,249
为我制作了一些工作

812
00:32:12,249 --> 00:32:15,489
并保留那部分数据

813
00:32:15,489 --> 00:32:17,499
我已经处理然后

814
00:32:17,499 --> 00:32:18,999
返回优化器并要求

815
00:32:18,999 --> 00:32:21,190
它只生成一个子计划，所以你

816
00:32:21,190 --> 00:32:23,169
知道只是从头开始，你

817
00:32:23,169 --> 00:32:25,210
知道你决定继续

818
00:32:25,210 --> 00:32:27,820
使用我现在拥有的相同查询计划

819
00:32:27,820 --> 00:32:30,359


820
00:32:30,359 --> 00:32:32,379
如果你最后

821
00:32:32,379 --> 00:32:33,909
放置最后一个运算符，显然比重新开始更糟糕，那么这是一个坏

822
00:32:33,909 --> 00:32:36,279
主意，让它完成如此惊人的

823
00:32:36,279 --> 00:32:38,440
平衡，这很困难，

824
00:32:38,440 --> 00:32:40,090
然后其他方法

825
00:32:40,090 --> 00:32:42,730
确定我做得很好，我做 100 加入并且我

826
00:32:42,730 --> 00:32:44,679
已经完成了其中一个让我保留

827
00:32:44,679 --> 00:32:46,720
我拥有的那个因为我

828
00:32:46,720 --> 00:32:48,700
很贵然后我将重新

829
00:32:48,700 --> 00:32:51,249
计划其他 99 的订购这里的整个

830
00:32:51,249 --> 00:32:52,929
想法是你要

831
00:32:52,929 --> 00:32:55,179
回到优化器和 说嘿 generate 为

832
00:32:55,179 --> 00:32:59,200
我生成一个新计划，所以让我给它一个新计划

833
00:32:59,200 --> 00:33:01,269
，所以它会做

834
00:33:01,269 --> 00:33:04,330
一些类似于这样的事情，所以这是来自

835
00:33:04,330 --> 00:33:06,700
Apache 快速步骤快速步骤是它还是

836
00:33:06,700 --> 00:33:10,899
类似于鸭子 TB 的嵌入式分析引擎，

837
00:33:10,899 --> 00:33:13,749
但我 不要认为

838
00:33:13,749 --> 00:33:15,940
它支持续集 它来自

839
00:33:15,940 --> 00:33:18,950
威斯康星州的统一，然后

840
00:33:18,950 --> 00:33:21,740
它已被移交给 Apache

841
00:33:21,740 --> 00:33:22,490
基金会

842
00:33:22,490 --> 00:33:24,289
我认为它已被踢出

843
00:33:24,289 --> 00:33:25,370
孵化器计划 因为我认为

844
00:33:25,370 --> 00:33:27,080
他们最近没有更新它 我不认为 我不

845
00:33:27,080 --> 00:33:28,519
知道鸡灰和他的

846
00:33:28,519 --> 00:33:30,500
团队发生了什么，但我有一段时间没有真正看到任何

847
00:33:30,500 --> 00:33:32,149
更新，但他们有一种

848
00:33:32,149 --> 00:33:33,320
非常有趣的方法，称为

849
00:33:33,320 --> 00:33:36,169
前瞻信息传递，

850
00:33:36,169 --> 00:33:39,320
我可以在查询开始时做一些工作

851
00:33:39,320 --> 00:33:42,230
并通过 连同其他

852
00:33:42,230 --> 00:33:44,120
运算符或我的查询计划的其他部分，

853
00:33:44,120 --> 00:33:46,779
并帮助我决定

854
00:33:46,779 --> 00:33:49,190
正确的顺序是什么，

855
00:33:49,190 --> 00:33:52,370
所以对于这个例子，假设

856
00:33:52,370 --> 00:33:56,149
我们有一个简单的数据表示三个表

857
00:33:56,149 --> 00:33:58,279
，所以这将是一个星型模式 所以

858
00:33:58,279 --> 00:33:59,720
这个这个方法只适用于

859
00:33:59,720 --> 00:34:02,149
星型模式我们在中间有一个事实表

860
00:34:02,149 --> 00:34:03,559
然后你有维度

861
00:34:03,559 --> 00:34:05,840
表从它出来所以它

862
00:34:05,840 --> 00:34:08,480
不是任意的星型模式或

863
00:34:08,480 --> 00:34:10,429
任意像基于树的模式

864
00:34:10,429 --> 00:34:13,969
这样的方式会起作用 是说

865
00:34:13,969 --> 00:34:15,440
这是我这样的续集查询我正在

866
00:34:15,440 --> 00:34:17,389
事实表和二维表之间进行三向连接

867
00:34:17,389 --> 00:34:19,460
所以

868
00:34:19,460 --> 00:34:22,929
我要做的是在我开始

869
00:34:22,929 --> 00:34:25,969
之前 在我开始扫描事实表

870
00:34:25,969 --> 00:34:27,409
并开始计算之前

871
00:34:27,409 --> 00:34:29,899
用于连接的哈希表哈希表 我将

872
00:34:29,899 --> 00:34:32,449
扫描维度表并

873
00:34:32,449 --> 00:34:35,239
生成布隆过滤器 我们解决了

874
00:34:35,239 --> 00:34:36,679
在我们谈论连接时使用的类似技术

875
00:34:36,679 --> 00:34:38,480
这个想法

876
00:34:38,480 --> 00:34:40,310
来自向量明智，您可以生成

877
00:34:40,310 --> 00:34:44,270
布隆过滤器并通过 它一直到

878
00:34:44,270 --> 00:34:46,389
查询计划的另一边，以便

879
00:34:46,389 --> 00:34:49,790
可能避免哈希表探测，我们

880
00:34:49,790 --> 00:34:51,589
说了这个，所以连接将

881
00:34:51,589 --> 00:34:52,969
在维度表上，这些在

882
00:34:52,969 --> 00:34:54,560
哈希表前面，而事实表

883
00:34:54,560 --> 00:34:55,940
只是要 做一个探测，所以我想

884
00:34:55,940 --> 00:34:57,650
生成布隆过滤器，然后

885
00:34:57,650 --> 00:34:59,930
检查布隆过滤器，看看

886
00:34:59,930 --> 00:35:01,310
我正在寻找的键是否甚至可以存在于

887
00:35:01,310 --> 00:35:02,839
哈希表中，这

888
00:35:02,839 --> 00:35:05,540
比做哈希表探测便宜，但我们会做

889
00:35:05,540 --> 00:35:06,740
不同的事情 这是我们实际上

890
00:35:06,740 --> 00:35:08,390
要传递这些布隆过滤器，当

891
00:35:08,390 --> 00:35:09,700
我们将它传递到事实表时，

892
00:35:09,700 --> 00:35:14,150
我们将开始进行一些采样以

893
00:35:14,150 --> 00:35:18,200
确定

894
00:35:18,200 --> 00:35:20,900
不同布隆过滤器的选择性，因此对于

895
00:35:20,900 --> 00:35:22,880
这些不同的表 然后如果我们

896
00:35:22,880 --> 00:35:26,750
确定这里的第二个第二个

897
00:35:26,750 --> 00:35:28,160
表 DeMint 的第二个维度

898
00:35:28,160 --> 00:35:30,470
表实际上

899
00:35:30,470 --> 00:35:32,780
比第一个更有选择性，那么我想

900
00:35:32,780 --> 00:35:37,910
重新洗牌我的连接，以便

901
00:35:37,910 --> 00:35:39,800
我首先对这个哈希表进行探测，

902
00:35:39,800 --> 00:35:41,330
因为我是 最终会

903
00:35:41,330 --> 00:35:43,790
丢弃更多元组，我们可以

904
00:35:43,790 --> 00:35:44,810
在实际开始运行之前执行此操作，

905
00:35:44,810 --> 00:35:47,390
因为我们已经有了

906
00:35:47,390 --> 00:35:48,800
生成布隆过滤器的哈希表

907
00:35:48,800 --> 00:35:51,110
，我们可以在

908
00:35:51,110 --> 00:35:53,240
开始扫描和执行之前做出决定 探针 所以我

909
00:35:53,240 --> 00:35:54,710
认为这是一个非常有趣的想法

910
00:35:54,710 --> 00:35:56,330
，据您所知，quickstep 是唯一

911
00:35:56,330 --> 00:35:58,490
一个这样做的，我不知道

912
00:35:58,490 --> 00:36:00,080
它是否真的进入了

913
00:36:00,080 --> 00:36:04,390
开源版本，好吧，最后一个

914
00:36:04,390 --> 00:36:06,260
适配器查询优化技术

915
00:36:06,260 --> 00:36:08,240
类别 你想谈论的

916
00:36:08,240 --> 00:36:12,200
是我所说的那种计划枢轴点

917
00:36:12,200 --> 00:36:14,780
，这里的想法是我们想

918
00:36:14,780 --> 00:36:17,990
在我们的查询中引入额外的子计划

919
00:36:17,990 --> 00:36:24,350
，然后有一种

920
00:36:24,350 --> 00:36:26,720
特殊的合成运算符，我们将它

921
00:36:26,720 --> 00:36:28,490
放入我们的查询计划中，允许 我们

922
00:36:28,490 --> 00:36:31,130
旋转或切换哪个查询你知道

923
00:36:31,130 --> 00:36:32,570
哪个路径和我们想要做的查询计划

924
00:36:32,570 --> 00:36:36,760
，这里的想法是我们可以

925
00:36:36,760 --> 00:36:39,980
在 switch

926
00:36:39,980 --> 00:36:42,260
运算符或更改计划运算

927
00:36:42,260 --> 00:36:45,590
符中放入条件，如果我们确定我们的数据

928
00:36:45,590 --> 00:36:47,750
看起来是一个 如果它看起来另一种方式，我们将沿着一条路径走

929
00:36:47,750 --> 00:36:49,310


930
00:36:49,310 --> 00:36:51,830
另一条路径它不必是另一条路径

931
00:36:51,830 --> 00:36:54,380
- 它可以是多个路径，因此

932
00:36:54,380 --> 00:36:55,940
最有名的两种技术

933
00:36:55,940 --> 00:36:57,620
是参数优化

934
00:36:57,620 --> 00:36:59,240
在高水平的主动对抗中，

935
00:36:59,240 --> 00:37:00,290
他们将以

936
00:37:00,290 --> 00:37:01,970
完全相同的方式工作，只是

937
00:37:01,970 --> 00:37:03,860
他们技术的复杂程度

938
00:37:03,860 --> 00:37:06,920
略有不同，因此参数

939
00:37:06,920 --> 00:37:08,900
优化实际上是在

940
00:37:08,900 --> 00:37:12,080
1980 年代后期开发的，而在 1989 年这实际上

941
00:37:12,080 --> 00:37:14,090
是从火山中出来的 再次项目

942
00:37:14,090 --> 00:37:16,070
与火山查询

943
00:37:16,070 --> 00:37:18,080
优化器和火山迭代模型相同的项目，

944
00:37:18,080 --> 00:37:20,420
他们也在自适应查询反对方面做了早期的工作

945
00:37:20,420 --> 00:37:22,160
，正如我

946
00:37:22,160 --> 00:37:24,500
所说，这项工作非常有影响力，

947
00:37:24,500 --> 00:37:27,110
所以我说的想法是，对于每个

948
00:37:27,110 --> 00:37:30,800
管道和一个 查询我们认为

949
00:37:30,800 --> 00:37:31,880
我们可以拥有的不同替代

950
00:37:31,880 --> 00:37:32,810
方案会产生很大的性能

951
00:37:32,810 --> 00:37:35,150
差异，并为它们生成不同的子

952
00:37:35,150 --> 00:37:37,970
计划，然后现在在我们的查询

953
00:37:37,970 --> 00:37:39,920
中将有这个选择计划运算符，它

954
00:37:39,920 --> 00:37:41,990
基本上有一个 if 子句，

955
00:37:41,990 --> 00:37:45,590
表示如果基数 我下面的操作员

956
00:37:45,590 --> 00:37:46,670


957
00:37:46,670 --> 00:37:49,400
看起来有一定的规模，然后我想

958
00:37:49,400 --> 00:37:51,440
选择第一个计划，如果它看起来是

959
00:37:51,440 --> 00:37:53,299
另一种方式，那么我会选择另一个

960
00:37:53,299 --> 00:37:56,299
计划 在这种情况下，如果我

961
00:37:56,299 --> 00:37:58,760
知道我的数据非常小，那么

962
00:37:58,760 --> 00:38:00,349
也许我想做一个嵌套循环连接，

963
00:38:00,349 --> 00:38:01,250
因为这

964
00:38:01,250 --> 00:38:04,420
比构建哈希表和概率要便宜，

965
00:38:04,420 --> 00:38:07,579
但是如果我的数据真的很大，那么我可能

966
00:38:07,579 --> 00:38:10,069
想做 散列 Tron 好的

967
00:38:10,069 --> 00:38:13,579
散列如何再次运行我认为这

968
00:38:13,579 --> 00:38:15,529
实际上是一个有趣的想法当然

969
00:38:15,529 --> 00:38:16,789
显然棘手的事情是

970
00:38:16,789 --> 00:38:20,059
确定在

971
00:38:20,059 --> 00:38:23,510
这种情况下的条件应该是什么你

972
00:38:23,510 --> 00:38:26,539
知道它有点通过反复试验

973
00:38:26,539 --> 00:38:27,740
和随着你的发展 事情，

974
00:38:27,740 --> 00:38:28,849
它实际上非常依赖它

975
00:38:28,849 --> 00:38:31,760
也不会在港口，但是

976
00:38:31,760 --> 00:38:33,140
关于这件事的好处是，

977
00:38:33,140 --> 00:38:35,089
我们最终没有什么比没有回到

978
00:38:35,089 --> 00:38:37,460
优化器并重播

979
00:38:37,460 --> 00:38:40,730
所有内容的事情了，我们不会扔掉

980
00:38:40,730 --> 00:38:41,859
我们正确收集的任何数据，

981
00:38:41,859 --> 00:38:45,289
以便我们执行此哈希连接，

982
00:38:45,289 --> 00:38:46,579
然后我们只需确定我们是否

983
00:38:46,579 --> 00:38:49,569
要沿着一条路径与另一条路径前进 一种

984
00:38:49,569 --> 00:38:51,890
最近的复杂

985
00:38:51,890 --> 00:38:53,119
方法称为主动重新优化

986
00:38:53,119 --> 00:38:55,970
这实际上结合了

987
00:38:55,970 --> 00:38:58,609
返回优化器并

988
00:38:58,609 --> 00:39:01,970
生成新计划的能力，并以

989
00:39:01,970 --> 00:39:03,859
我们在前面的示例中看到的相同方式对其进行调整，

990
00:39:03,859 --> 00:39:05,390
因此它们实际上可以同时执行

991
00:39:05,390 --> 00:39:07,579
这两项操作，因此在较高的级别上它是有效的

992
00:39:07,579 --> 00:39:10,250
像这样，如此疯狂地通过优化器显示我们的性别

993
00:39:10,250 --> 00:39:11,059


994
00:39:11,059 --> 00:39:13,029
，所以我们会

995
00:39:13,029 --> 00:39:15,319
像以前一样生成不同的可切换计划，

996
00:39:15,319 --> 00:39:17,420
现在我们还将

997
00:39:17,420 --> 00:39:21,069
生成边界框，使我们能够

998
00:39:21,069 --> 00:39:24,079
确定我们在

999
00:39:24,079 --> 00:39:25,670
决策中所做的假设是否 无论是

1000
00:39:25,670 --> 00:39:27,230
走一条路还是走另一条路，我们

1001
00:39:27,230 --> 00:39:29,450
实际上都会与现实相匹配，

1002
00:39:29,450 --> 00:39:32,720
但这基本上是试图限制

1003
00:39:32,720 --> 00:39:34,220
我们在运行时在数据中看到的不确定性，

1004
00:39:34,220 --> 00:39:37,490
所以现在我们开始退出

1005
00:39:37,490 --> 00:39:40,339
查询，就像之前一样 leo 和

1006
00:39:40,339 --> 00:39:42,170
我们退出查询的其他技术收集

1007
00:39:42,170 --> 00:39:43,430
作为我们为特定查询看到的数据的统计信息

1008
00:39:43,430 --> 00:39:45,380
，然后

1009
00:39:45,380 --> 00:39:47,660
我们可以像之前看到的那样切换查询计划

1010
00:39:47,660 --> 00:39:50,390
，如果我们确定您知道

1011
00:39:50,390 --> 00:39:52,069
一个计划路径可能 不会比另一个更好，

1012
00:39:52,069 --> 00:39:54,019
但是如果您还

1013
00:39:54,019 --> 00:39:56,720
根据我们的边界框阈值确定我们是否超出了我们的

1014
00:39:56,720 --> 00:39:59,119
估计，我们

1015
00:39:59,119 --> 00:40:00,260


1016
00:40:00,260 --> 00:40:01,790
就会发现我们已经超出了您的范围

1017
00:40:01,790 --> 00:40:05,240


1018
00:40:05,240 --> 00:40:07,340
然后我们返回并进行

1019
00:40:07,340 --> 00:40:09,290
优化，然后您确定

1020
00:40:09,290 --> 00:40:11,990
是否固定您已经执行的查询计划的部分，

1021
00:40:11,990 --> 00:40:13,040
因为您

1022
00:40:13,040 --> 00:40:14,930
知道它们很昂贵，或者您可以

1023
00:40:14,930 --> 00:40:17,950
说扔掉所有东西并重新开始，

1024
00:40:17,950 --> 00:40:20,570
所以这是排序 获得

1025
00:40:20,570 --> 00:40:23,140
有关查询优化深度的速成课程，

1026
00:40:23,140 --> 00:40:27,290
我实际上真的很喜欢这些

1027
00:40:27,290 --> 00:40:29,120
技术，并且出于显而易见的

1028
00:40:29,120 --> 00:40:31,070
原因，它不依赖于

1029
00:40:31,070 --> 00:40:32,960
一开始就做好，

1030
00:40:32,960 --> 00:40:35,480
就像您甚至可以像自己一样纠正自己

1031
00:40:35,480 --> 00:40:38,830
实际上

1032
00:40:38,830 --> 00:40:41,360
再次很好地运行查询我们将看到下一节课，当

1033
00:40:41,360 --> 00:40:42,710
我们讨论事情实际上会变得多么糟糕的成本模型时，

1034
00:40:42,710 --> 00:40:45,500
但您

1035
00:40:45,500 --> 00:40:46,820
实际需要实现这一点的方式非常

1036
00:40:46,820 --> 00:40:48,530
重要，这只是不是您知道

1037
00:40:48,530 --> 00:40:50,300
您不知道 ant 将您的

1038
00:40:50,300 --> 00:40:52,310
优化器和执行引擎

1039
00:40:52,310 --> 00:40:54,260
彼此完全分开，

1040
00:40:54,260 --> 00:40:55,880
这是一种共生关系

1041
00:40:55,880 --> 00:40:58,850
，您必须知道

1042
00:40:58,850 --> 00:41:00,860


1043
00:41:00,860 --> 00:41:02,990
优化器中的执行可以采用什么

1044
00:41:02,990 --> 00:41:04,520
样的策略，例如切换路径和加权

1045
00:41:04,520 --> 00:41:06,320
采访结果或 不是，然后

1046
00:41:06,320 --> 00:41:07,670
您构建优化器，或者

1047
00:41:07,670 --> 00:41:09,590
围绕执行

1048
00:41:09,590 --> 00:41:12,710
引擎实际可以执行的操作构建优化，

1049
00:41:12,710 --> 00:41:16,610
因此我认为我认为将

1050
00:41:16,610 --> 00:41:18,530
这种技术应用于我们将这种

1051
00:41:18,530 --> 00:41:20,900
技术与某种优化器

1052
00:41:20,900 --> 00:41:23,960
作为服务（如 Orca 或方解石）一起使用时

1053
00:41:23,960 --> 00:41:25,400
实际上很棘手，因为

1054
00:41:25,400 --> 00:41:26,900
对于如何在系统本身中

1055
00:41:26,900 --> 00:41:28,790
实际支持适配器查询执行有不同的方法，

1056
00:41:28,790 --> 00:41:34,580
因此

1057
00:41:34,580 --> 00:41:36,970
除了拥有更强大或

1058
00:41:36,970 --> 00:41:40,270
更复杂的查询优化器之外，

1059
00:41:40,270 --> 00:41:42,560


1060
00:41:42,560 --> 00:41:44,600
所有主要数据库供应商现在都拥有开源系统

1061
00:41:44,600 --> 00:41:46,870
支持这个在最近

1062
00:41:46,870 --> 00:41:48,830
实际上主要是在最近的三

1063
00:41:48,830 --> 00:41:50,630
四年里 ke db2 在 2000 年代初期就有这个 Leo 的东西

1064
00:41:50,630 --> 00:41:53,600
，但实际上在过去

1065
00:41:53,600 --> 00:41:56,990
三年中关于 Oracle 和续集

1066
00:41:56,990 --> 00:41:59,480
服务器，现在 Teradata 还包括

1067
00:41:59,480 --> 00:42:00,860
执行 Cori 操作的能力，

1068
00:42:00,860 --> 00:42:02,600
但我最好的知识是

1069
00:42:02,600 --> 00:42:05,390
Postgres 和我的续集根本无法做到

1070
00:42:05,390 --> 00:42:07,030
这一点， 在过去的十年中出现的这种较新的

1071
00:42:07,030 --> 00:42:08,990
开源系统都没有

1072
00:42:08,990 --> 00:42:10,490
支持这样的东西

1073
00:42:10,490 --> 00:42:13,290
所以好吧，

1074
00:42:13,290 --> 00:42:14,760
这只是为了向您

1075
00:42:14,760 --> 00:42:15,930
展示您不必

1076
00:42:15,930 --> 00:42:17,820
按照我们描述的方式构建优化器

1077
00:42:17,820 --> 00:42:19,470
您计划一次并通过

1078
00:42:19,470 --> 00:42:21,120
我们的技术运行它以在

1079
00:42:21,120 --> 00:42:22,740
查询运行时实际修改查询，他们

1080
00:42:22,740 --> 00:42:24,540
从执行中获得反馈并将其

1081
00:42:24,540 --> 00:42:28,200
放入系统层，做得很好，

1082
00:42:28,200 --> 00:42:31,410
对不起，所以下一节课将开始

1083
00:42:31,410 --> 00:42:34,890
讨论成本模型如何工作

1084
00:42:34,890 --> 00:42:39,530
我们会明白为什么他们这么糟糕好吧伙计们

1085
00:42:39,530 --> 00:42:41,080
什么是

1086
00:42:41,080 --> 00:43:03,409
[音乐]

1087
00:43:05,460 --> 00:43:08,099
不会一样我已经切碎了你

1088
00:43:08,099 --> 00:43:11,390
为玩家着想

