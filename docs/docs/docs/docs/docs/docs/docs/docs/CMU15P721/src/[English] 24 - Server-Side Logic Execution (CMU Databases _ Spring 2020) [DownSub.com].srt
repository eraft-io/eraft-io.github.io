1
00:00:01,300 --> 00:00:05,129
[Music]

2
00:00:05,200 --> 00:00:05,930
[Applause]

3
00:00:05,930 --> 00:00:08,630
[Music]

4
00:00:08,630 --> 00:00:10,020
[Applause]

5
00:00:10,020 --> 00:00:11,840
[Music]

6
00:00:11,840 --> 00:00:13,950
so in today's class we're going to talk

7
00:00:13,950 --> 00:00:16,500
about server-side logic execution again

8
00:00:16,500 --> 00:00:18,990
I'm at my house here with the Terrier

9
00:00:18,990 --> 00:00:23,660
who for some reason smells like onions

10
00:00:23,660 --> 00:00:26,039
I'm not sure what that what that's about

11
00:00:26,039 --> 00:00:30,359
um so for today's lecture this is a

12
00:00:30,359 --> 00:00:33,600
topic that I find very interesting and

13
00:00:33,600 --> 00:00:37,010
it's not something I would say that is

14
00:00:37,010 --> 00:00:39,930
critical for building a sort of modern

15
00:00:39,930 --> 00:00:41,760
high-performance inmate database that

16
00:00:41,760 --> 00:00:42,570
we've been talking about the entire

17
00:00:42,570 --> 00:00:46,520
semester this is now making it so that

18
00:00:46,520 --> 00:00:49,079
people can you know extend your database

19
00:00:49,079 --> 00:00:51,449
system and have it integrate with more

20
00:00:51,449 --> 00:00:54,600
different types applications so again

21
00:00:54,600 --> 00:00:55,940
this is not something we're going to do

22
00:00:55,940 --> 00:00:59,280
try to support because we want you know

23
00:00:59,280 --> 00:01:00,449
you absolutely need to get the best

24
00:01:00,449 --> 00:01:01,770
performance although it's gonna help in

25
00:01:01,770 --> 00:01:03,300
the way we're gonna exclude our UDS are

26
00:01:03,300 --> 00:01:05,339
gonna help this is more about sort of

27
00:01:05,339 --> 00:01:06,960
extensibility of the database system but

28
00:01:06,960 --> 00:01:08,490
we want to do it in a really smart way

29
00:01:08,490 --> 00:01:11,760
so for today's lecture we're going to

30
00:01:11,760 --> 00:01:13,170
first start talk about the background of

31
00:01:13,170 --> 00:01:15,150
this what I mean by server-side logic

32
00:01:15,150 --> 00:01:18,900
execution and then we'll focus on how to

33
00:01:18,900 --> 00:01:21,240
optimize the performance of user data

34
00:01:21,240 --> 00:01:23,640
user defined functions the one way would

35
00:01:23,640 --> 00:01:26,549
be the the inlining approach that was

36
00:01:26,549 --> 00:01:29,040
used by Microsoft and the fraud paper

37
00:01:29,040 --> 00:01:30,840
that you were assigned to read and then

38
00:01:30,840 --> 00:01:32,640
the other approach would be a newer

39
00:01:32,640 --> 00:01:35,130
method at a Germany on converting UDF's

40
00:01:35,130 --> 00:01:37,920
into common table expressions again both

41
00:01:37,920 --> 00:01:40,250
of these are about making UDS run faster

42
00:01:40,250 --> 00:01:43,619
so as I said server-side logic execution

43
00:01:43,619 --> 00:01:45,840
I think is an interesting topic I used

44
00:01:45,840 --> 00:01:47,189
to teach it in the introduction class

45
00:01:47,189 --> 00:01:49,100
the last night audit I think was maybe

46
00:01:49,100 --> 00:01:52,409
2018 and unfortunately last mr. we had

47
00:01:52,409 --> 00:01:53,759
to cut it out so this is not something

48
00:01:53,759 --> 00:01:55,770
that maybe if you've been here at CMU

49
00:01:55,770 --> 00:01:57,810
that you may be familiar with so it's

50
00:01:57,810 --> 00:01:59,430
been a little time discussing you know

51
00:01:59,430 --> 00:02:00,990
what it is you know we're actually

52
00:02:00,990 --> 00:02:03,930
trying to do on our database system so

53
00:02:03,930 --> 00:02:05,820
the key observation you have to make

54
00:02:05,820 --> 00:02:08,160
about what server-side logic execution

55
00:02:08,160 --> 00:02:10,169
is going to do for us is that up until

56
00:02:10,169 --> 00:02:13,120
now we've assumed that there's

57
00:02:13,120 --> 00:02:16,300
then this clean division or dichotomy in

58
00:02:16,300 --> 00:02:19,239
our application stack between the logic

59
00:02:19,239 --> 00:02:20,530
that's in the application server and the

60
00:02:20,530 --> 00:02:22,090
logic that we execute in the database

61
00:02:22,090 --> 00:02:23,650
system and the database system would

62
00:02:23,650 --> 00:02:27,040
only see queries that were being sent

63
00:02:27,040 --> 00:02:29,230
over from a like what I'll call a

64
00:02:29,230 --> 00:02:32,950
conversational API like JDBC or ODBC

65
00:02:32,950 --> 00:02:35,470
like what we talked about early in the

66
00:02:35,470 --> 00:02:38,890
semester and the downside though with

67
00:02:38,890 --> 00:02:41,830
this approach is that it's going to be

68
00:02:41,830 --> 00:02:44,049
you know it's it's a chatty API like

69
00:02:44,049 --> 00:02:45,640
hypocenter query get resolved and then

70
00:02:45,640 --> 00:02:47,860
process it and send result back all

71
00:02:47,860 --> 00:02:49,510
right so we saw this a diagram sort of

72
00:02:49,510 --> 00:02:51,880
like this before when we talk about JDBC

73
00:02:51,880 --> 00:02:54,160
or ODBC right on the application side

74
00:02:54,160 --> 00:02:56,860
this is where our essentially our

75
00:02:56,860 --> 00:02:58,269
program lives right whether it's written

76
00:02:58,269 --> 00:03:01,930
in nodejs or a PHP or Django you know

77
00:03:01,930 --> 00:03:04,060
Python application right here's all the

78
00:03:04,060 --> 00:03:05,950
business logic or of our of our program

79
00:03:05,950 --> 00:03:08,620
and so when we started transaction we

80
00:03:08,620 --> 00:03:11,349
would call begin and then we would

81
00:03:11,349 --> 00:03:13,510
execute a gift to a Segal save and

82
00:03:13,510 --> 00:03:14,890
execute something that would then go

83
00:03:14,890 --> 00:03:18,400
over the wire again throw through ABC or

84
00:03:18,400 --> 00:03:20,709
JDBC and that'll run through the full

85
00:03:20,709 --> 00:03:22,540
stack that we've talked about like the

86
00:03:22,540 --> 00:03:24,340
sequel parser the plan of the optimizer

87
00:03:24,340 --> 00:03:26,760
and eventually due to the query executor

88
00:03:26,760 --> 00:03:28,870
now you can use prepared statements

89
00:03:28,870 --> 00:03:30,819
maybe skip the first fresh two or three

90
00:03:30,819 --> 00:03:32,530
steps but in the end you're still going

91
00:03:32,530 --> 00:03:34,540
to execute the query so then now the

92
00:03:34,540 --> 00:03:36,670
data system X uses the query and the

93
00:03:36,670 --> 00:03:38,349
sends the result back and then now the

94
00:03:38,349 --> 00:03:40,750
application server can proceed with the

95
00:03:40,750 --> 00:03:42,519
program write this the sequel call is a

96
00:03:42,519 --> 00:03:45,160
blocking call on the application side so

97
00:03:45,160 --> 00:03:46,989
now while goes off and execute some or

98
00:03:46,989 --> 00:03:48,790
program logic to process whatever the

99
00:03:48,790 --> 00:03:50,620
results that it got from the sequel

100
00:03:50,620 --> 00:03:53,919
query our database system is idle for

101
00:03:53,919 --> 00:03:55,540
this particular connection now again

102
00:03:55,540 --> 00:03:57,310
it's a multi-threaded system or multi

103
00:03:57,310 --> 00:03:59,650
process system so therefore we could be

104
00:03:59,650 --> 00:04:02,459
processing queries from other

105
00:04:02,459 --> 00:04:04,660
transactions or other you know from

106
00:04:04,660 --> 00:04:06,579
other connections at the same time but

107
00:04:06,579 --> 00:04:09,310
for the the context handle we're going

108
00:04:09,310 --> 00:04:10,359
to maintain for this particular

109
00:04:10,359 --> 00:04:13,239
connection it's essentially idle so that

110
00:04:13,239 --> 00:04:15,010
means that it for running is in a

111
00:04:15,010 --> 00:04:17,320
transaction if we're using something

112
00:04:17,320 --> 00:04:19,450
like two-phase locking as a concurrent

113
00:04:19,450 --> 00:04:22,060
you to a protocol whether locks that we

114
00:04:22,060 --> 00:04:23,890
acquired for this sequel statement are

115
00:04:23,890 --> 00:04:26,320
now just being held on the servers

116
00:04:26,320 --> 00:04:28,780
side because it's waiting for the next

117
00:04:28,780 --> 00:04:30,430
command to be told what's gonna happen

118
00:04:30,430 --> 00:04:32,440
for this particular transaction and this

119
00:04:32,440 --> 00:04:35,290
network round-trip is not cheap but you

120
00:04:35,290 --> 00:04:36,910
know best-case scenario we're running on

121
00:04:36,910 --> 00:04:38,140
the same machine but that's not very

122
00:04:38,140 --> 00:04:41,290
common it's usually you have a service

123
00:04:41,290 --> 00:04:42,790
reapplication a separate server for the

124
00:04:42,790 --> 00:04:44,620
database system as you can sort of scale

125
00:04:44,620 --> 00:04:47,350
them independently and so maybe you're

126
00:04:47,350 --> 00:04:49,270
on the on the on the rack unit right

127
00:04:49,270 --> 00:04:52,090
above you know the application server is

128
00:04:52,090 --> 00:04:54,160
one unit below the database server and

129
00:04:54,160 --> 00:04:55,840
the same rack but again that's pretty

130
00:04:55,840 --> 00:04:58,870
uncommon too high so this could be a

131
00:04:58,870 --> 00:05:01,420
couple milliseconds to send this you

132
00:05:01,420 --> 00:05:03,220
know these back and forth and who knows

133
00:05:03,220 --> 00:05:04,480
how long this program log just gonna

134
00:05:04,480 --> 00:05:07,420
take to execute so then now after we

135
00:05:07,420 --> 00:05:08,950
complete the program logic here maybe we

136
00:05:08,950 --> 00:05:10,450
do the same thing we exit another sequel

137
00:05:10,450 --> 00:05:12,310
query send it over get a result send it

138
00:05:12,310 --> 00:05:13,840
back we do some more processing and then

139
00:05:13,840 --> 00:05:16,720
we wait and then eventually our

140
00:05:16,720 --> 00:05:19,120
application says okay we're done we send

141
00:05:19,120 --> 00:05:21,910
a commit message and then we can release

142
00:05:21,910 --> 00:05:24,220
whatever locks or whatever memory we've

143
00:05:24,220 --> 00:05:26,020
allocated for this transaction whatever

144
00:05:26,020 --> 00:05:28,450
we did to maintain the state that we had

145
00:05:28,450 --> 00:05:29,500
this connection open and they were

146
00:05:29,500 --> 00:05:31,690
exiting transaction when we get the

147
00:05:31,690 --> 00:05:34,300
commitment we can finally finally start

148
00:05:34,300 --> 00:05:37,300
to clean things up so the things we're

149
00:05:37,300 --> 00:05:38,320
going to talk about today are

150
00:05:38,320 --> 00:05:40,630
essentially how to take that application

151
00:05:40,630 --> 00:05:43,540
logic on this side and now move this

152
00:05:43,540 --> 00:05:45,640
inside the database system to avoid

153
00:05:45,640 --> 00:05:48,610
these round trips and have the you know

154
00:05:48,610 --> 00:05:50,770
have transactions take longer or

155
00:05:50,770 --> 00:05:52,630
whatever the query we were executing

156
00:05:52,630 --> 00:05:54,310
take a longer try to combine everything

157
00:05:54,310 --> 00:05:56,710
into a single vacation invocation that

158
00:05:56,710 --> 00:05:58,900
we can send just one request to the

159
00:05:58,900 --> 00:05:59,980
database server and not go back and

160
00:05:59,980 --> 00:06:02,740
forth to the application we're also

161
00:06:02,740 --> 00:06:04,480
going to bed logic that allow us to

162
00:06:04,480 --> 00:06:07,480
extend the functionality of the database

163
00:06:07,480 --> 00:06:10,420
system so in some cases we'll be able to

164
00:06:10,420 --> 00:06:15,090
do certain types of manipulation or

165
00:06:15,090 --> 00:06:18,760
filtering or other types of steps we do

166
00:06:18,760 --> 00:06:21,580
when we process queries we're able to do

167
00:06:21,580 --> 00:06:22,990
that in a way that the original

168
00:06:22,990 --> 00:06:25,630
developers of the database system may

169
00:06:25,630 --> 00:06:27,970
have not anticipated or may not you know

170
00:06:27,970 --> 00:06:31,300
offered to support so again so the

171
00:06:31,300 --> 00:06:32,460
benefit will get from this is that

172
00:06:32,460 --> 00:06:35,590
because we're going over we could make

173
00:06:35,590 --> 00:06:37,390
fewer round trips that'll improve the

174
00:06:37,390 --> 00:06:39,980
efficiency and of our system

175
00:06:39,980 --> 00:06:43,220
because now transactions can take we're

176
00:06:43,220 --> 00:06:45,590
gonna execute in less time we're also

177
00:06:45,590 --> 00:06:48,680
going to get some reuse because now if I

178
00:06:48,680 --> 00:06:51,170
have some functionality inside a bed in

179
00:06:51,170 --> 00:06:55,100
my bed it's on my database system with

180
00:06:55,100 --> 00:06:57,710
now I have my my web application now is

181
00:06:57,710 --> 00:07:00,050
to be ported over to a mobile phone

182
00:07:00,050 --> 00:07:03,080
application instead of rewriting the PHP

183
00:07:03,080 --> 00:07:05,090
code my web application to now be swift

184
00:07:05,090 --> 00:07:06,260
or whatever I'm using on my cell phone

185
00:07:06,260 --> 00:07:07,910
like whatever that application logic I

186
00:07:07,910 --> 00:07:09,170
had to use to interactive a database

187
00:07:09,170 --> 00:07:12,380
system and the website I got to ported

188
00:07:12,380 --> 00:07:14,000
over to the web to the mobile phone

189
00:07:14,000 --> 00:07:16,280
application but if I can embed it inside

190
00:07:16,280 --> 00:07:19,160
the database system then now potentially

191
00:07:19,160 --> 00:07:21,710
the same logic that would be executed on

192
00:07:21,710 --> 00:07:25,310
the on the web site could be executed on

193
00:07:25,310 --> 00:07:26,750
the mobile phone again depends on your

194
00:07:26,750 --> 00:07:28,400
application stack a setup I did it

195
00:07:28,400 --> 00:07:30,320
assume that there's a logic running it

196
00:07:30,320 --> 00:07:34,100
and button both in both of them so what

197
00:07:34,100 --> 00:07:36,200
does that look like so one example a

198
00:07:36,200 --> 00:07:37,700
simple table that I just showed here

199
00:07:37,700 --> 00:07:39,800
that we could take this entire

200
00:07:39,800 --> 00:07:43,130
transaction logic and somehow send that

201
00:07:43,130 --> 00:07:45,980
over to the database system it'll get

202
00:07:45,980 --> 00:07:49,130
installed and then it will the ability

203
00:07:49,130 --> 00:07:52,520
to call it will get exposed through some

204
00:07:52,520 --> 00:07:53,690
kind of function handle like what's

205
00:07:53,690 --> 00:07:55,370
called as proc and then it takes an

206
00:07:55,370 --> 00:07:57,830
input argument of whatever you want so

207
00:07:57,830 --> 00:08:00,020
now if I want to invoke this transaction

208
00:08:00,020 --> 00:08:02,960
in my application I don't do that back

209
00:08:02,960 --> 00:08:04,880
and forth that I had before now I just

210
00:08:04,880 --> 00:08:06,710
use this invocation or this command

211
00:08:06,710 --> 00:08:08,960
called call so I call the function and

212
00:08:08,960 --> 00:08:10,850
pass in whatever argument I want to that

213
00:08:10,850 --> 00:08:13,370
function I send that one request over

214
00:08:13,370 --> 00:08:14,030
like an RPC

215
00:08:14,030 --> 00:08:16,730
it executes commits and then I get back

216
00:08:16,730 --> 00:08:20,120
the result so the benefit about this is

217
00:08:20,120 --> 00:08:22,490
that it's one round trip over and to

218
00:08:22,490 --> 00:08:24,170
execute all this complex logic where

219
00:08:24,170 --> 00:08:26,630
before it was multiple round trips now

220
00:08:26,630 --> 00:08:29,440
in this case here I'm invoking with call

221
00:08:29,440 --> 00:08:33,530
other this might be the in the seagull

222
00:08:33,530 --> 00:08:35,360
stander and other databases systems

223
00:08:35,360 --> 00:08:38,090
might support exact or execute I but the

224
00:08:38,090 --> 00:08:41,690
basic idea is the same so this is what

225
00:08:41,690 --> 00:08:43,130
is called a strop a seizure with the

226
00:08:43,130 --> 00:08:45,590
idea is that we can take a chunk of

227
00:08:45,590 --> 00:08:50,000
logic and wrap that into to the

228
00:08:50,000 --> 00:08:52,160
procedure call that we can then just

229
00:08:52,160 --> 00:08:53,720
invoke independently

230
00:08:53,720 --> 00:08:57,980
of a query the other types of embedded

231
00:08:57,980 --> 00:09:00,139
logic can you do the ones we focus on

232
00:09:00,139 --> 00:09:02,329
today are user-defined functions where

233
00:09:02,329 --> 00:09:06,500
it's UDF is attached to a query so you

234
00:09:06,500 --> 00:09:09,079
can't invoke a UDF independent of a

235
00:09:09,079 --> 00:09:10,160
query it has to be part of a select

236
00:09:10,160 --> 00:09:12,350
insert update or delete where storage

237
00:09:12,350 --> 00:09:15,410
procedures can be separate triggers are

238
00:09:15,410 --> 00:09:18,939
a way to have functions get invoked when

239
00:09:18,939 --> 00:09:22,430
when a certain event occurs like if I

240
00:09:22,430 --> 00:09:25,100
update a tuple in a table I can have

241
00:09:25,100 --> 00:09:27,529
that fire fire off a trigger actually

242
00:09:27,529 --> 00:09:29,389
before an update or after update update

243
00:09:29,389 --> 00:09:31,579
and then invoke some function to do to

244
00:09:31,579 --> 00:09:34,160
do something so let's say that I wanted

245
00:09:34,160 --> 00:09:36,500
to every time somebody up to the table I

246
00:09:36,500 --> 00:09:38,360
want to insert an audit record in

247
00:09:38,360 --> 00:09:40,069
another table so I could put a trigger

248
00:09:40,069 --> 00:09:41,329
on that table to say anytime it's

249
00:09:41,329 --> 00:09:44,060
updated keep track of what that change

250
00:09:44,060 --> 00:09:46,579
was in another table a user-defined

251
00:09:46,579 --> 00:09:49,790
types are a way to extend the the

252
00:09:49,790 --> 00:09:51,680
internal type system of the database

253
00:09:51,680 --> 00:09:53,750
system and allow you to support again

254
00:09:53,750 --> 00:09:57,500
some more complex object types that go

255
00:09:57,500 --> 00:09:59,720
beyond maybe within what the base scalar

256
00:09:59,720 --> 00:10:01,339
values of the primitive values that the

257
00:10:01,339 --> 00:10:03,559
data supports user defined aggregates

258
00:10:03,559 --> 00:10:05,930
are a way to have some more complex

259
00:10:05,930 --> 00:10:07,759
aggregation functions other than you

260
00:10:07,759 --> 00:10:09,889
know minimax count and some things like

261
00:10:09,889 --> 00:10:14,079
that so I can't prove this but it is my

262
00:10:14,079 --> 00:10:16,730
is it my intuition based when I play and

263
00:10:16,730 --> 00:10:18,290
what I've seen out there in programs and

264
00:10:18,290 --> 00:10:21,110
talking to people the prevalence of

265
00:10:21,110 --> 00:10:24,290
these different applications that are

266
00:10:24,290 --> 00:10:27,620
using these these types of embedded

267
00:10:27,620 --> 00:10:30,019
logic is that the top would be the most

268
00:10:30,019 --> 00:10:31,579
common going down to the least common so

269
00:10:31,579 --> 00:10:33,170
user-defined functions are very very

270
00:10:33,170 --> 00:10:35,120
very common you see these all over the

271
00:10:35,120 --> 00:10:36,829
time all over the place and then

272
00:10:36,829 --> 00:10:38,389
user-defined aggregates are a little

273
00:10:38,389 --> 00:10:40,430
less common triggers and stored

274
00:10:40,430 --> 00:10:42,519
procedures they're probably

275
00:10:42,519 --> 00:10:45,319
interchangeable but again like the way

276
00:10:45,319 --> 00:10:46,730
you implement a trigger is through a

277
00:10:46,730 --> 00:10:50,269
user-defined function the other thing to

278
00:10:50,269 --> 00:10:52,220
about I think in the in the Microsoft

279
00:10:52,220 --> 00:10:53,870
paper they talked about how well

280
00:10:53,870 --> 00:10:56,319
user-defined functions cannot update

281
00:10:56,319 --> 00:10:59,240
update tuples or update tables they can

282
00:10:59,240 --> 00:11:01,189
there they're the read-only where store

283
00:11:01,189 --> 00:11:03,230
procedures you can update things that I

284
00:11:03,230 --> 00:11:05,970
think is a

285
00:11:05,970 --> 00:11:09,389
is specific to sequel server I don't

286
00:11:09,389 --> 00:11:10,980
think the sequel standard specifies one

287
00:11:10,980 --> 00:11:11,720
way or the other

288
00:11:11,720 --> 00:11:13,860
so you could have user-defined functions

289
00:11:13,860 --> 00:11:15,769
that actually do update update tables

290
00:11:15,769 --> 00:11:20,579
okay so the what we're going to focus on

291
00:11:20,579 --> 00:11:21,959
today though is user-defined functions

292
00:11:21,959 --> 00:11:24,389
because again this is this is the the

293
00:11:24,389 --> 00:11:28,079
most common one and you know it's it

294
00:11:28,079 --> 00:11:31,410
could be used in combination of at least

295
00:11:31,410 --> 00:11:32,790
for the store procedures and triggers

296
00:11:32,790 --> 00:11:35,639
you tud keys and you da's are sort of a

297
00:11:35,639 --> 00:11:41,519
severed Beast okay so use defined

298
00:11:41,519 --> 00:11:44,490
function UDF is gonna be a function that

299
00:11:44,490 --> 00:11:46,819
is written by the application developer

300
00:11:46,819 --> 00:11:49,290
that allows them to extend the system

301
00:11:49,290 --> 00:11:52,019
functionality beyond what its built-in

302
00:11:52,019 --> 00:11:54,329
operations provide I said the sequel

303
00:11:54,329 --> 00:11:56,040
standard defines some basic sequel

304
00:11:56,040 --> 00:11:59,160
functions string length string upper you

305
00:11:59,160 --> 00:12:00,920
know casting functions things like that

306
00:12:00,920 --> 00:12:04,680
but there's also now to go beyond what

307
00:12:04,680 --> 00:12:06,209
what the sequel standard says or even

308
00:12:06,209 --> 00:12:07,560
with the proprietary functions that the

309
00:12:07,560 --> 00:12:09,839
database system supports you can write

310
00:12:09,839 --> 00:12:12,329
user blind functions that that you would

311
00:12:12,329 --> 00:12:13,829
invoke just as if they were a built-in

312
00:12:13,829 --> 00:12:16,829
function and so the setup is that you're

313
00:12:16,829 --> 00:12:19,170
always gonna be given as a scalar input

314
00:12:19,170 --> 00:12:21,329
arguments so like single primitive

315
00:12:21,329 --> 00:12:23,790
values or even arrays of scalars but but

316
00:12:23,790 --> 00:12:25,800
but not like you know table sets or row

317
00:12:25,800 --> 00:12:28,079
sets then you perform some kind of

318
00:12:28,079 --> 00:12:31,319
computation in them and this computation

319
00:12:31,319 --> 00:12:33,029
is going to be the the standard

320
00:12:33,029 --> 00:12:34,470
imperative language constructs that

321
00:12:34,470 --> 00:12:36,329
you're familiar with for loops while

322
00:12:36,329 --> 00:12:39,180
loops if clauses things like that and

323
00:12:39,180 --> 00:12:41,339
can also be invocations of other sequel

324
00:12:41,339 --> 00:12:43,860
statements or other UDF's within the

325
00:12:43,860 --> 00:12:47,370
this UDF and then you get to return a

326
00:12:47,370 --> 00:12:50,309
result that's either going to be more

327
00:12:50,309 --> 00:12:54,569
scalar values or a relation or a set of

328
00:12:54,569 --> 00:12:58,500
rows right so that's the basic idea what

329
00:12:58,500 --> 00:13:00,180
we're trying to here so let's look an

330
00:13:00,180 --> 00:13:02,970
example so this is going to be written

331
00:13:02,970 --> 00:13:06,029
in for all the examples in this first

332
00:13:06,029 --> 00:13:08,040
part for Freud we're gonna show examples

333
00:13:08,040 --> 00:13:09,899
in a programming language called T

334
00:13:09,899 --> 00:13:12,329
sequel or transact sequel so this is the

335
00:13:12,329 --> 00:13:14,100
UDF language that microsoft sequel

336
00:13:14,100 --> 00:13:16,550
server supports and fraud was was

337
00:13:16,550 --> 00:13:19,259
improving UDF's in sequel server so

338
00:13:19,259 --> 00:13:19,640
that's why we

339
00:13:19,640 --> 00:13:23,110
using this so TC who comes from Sybase

340
00:13:23,110 --> 00:13:25,610
because Seco server originally started

341
00:13:25,610 --> 00:13:29,420
off as a licensed licensed Fork of

342
00:13:29,420 --> 00:13:32,140
Sybase in the 1990s they ported it to

343
00:13:32,140 --> 00:13:36,590
Windows NT since then the forks have

344
00:13:36,590 --> 00:13:38,810
diverged significantly Sybase got bought

345
00:13:38,810 --> 00:13:42,350
by sa p and it's kind of more or less in

346
00:13:42,350 --> 00:13:43,970
maintenance mode at this point we're a

347
00:13:43,970 --> 00:13:45,140
sequel server is still very

348
00:13:45,140 --> 00:13:46,430
state-of-the-art and still being active

349
00:13:46,430 --> 00:13:49,010
actively developed another way think

350
00:13:49,010 --> 00:13:50,210
about this is like there's a lot of

351
00:13:50,210 --> 00:13:52,580
major major corporations and major

352
00:13:52,580 --> 00:13:55,550
applications running them on Sybase but

353
00:13:55,550 --> 00:13:58,400
you know no startup with a you know

354
00:13:58,400 --> 00:13:59,840
bunch of like 20 20 year old kids are

355
00:13:59,840 --> 00:14:01,160
gonna say you know I'm gonna build my

356
00:14:01,160 --> 00:14:03,710
startup on sideways the PI doesn't

357
00:14:03,710 --> 00:14:04,610
happen anymore

358
00:14:04,610 --> 00:14:06,170
we're siegel server actually still was a

359
00:14:06,170 --> 00:14:11,090
is a still is a good choice for from

360
00:14:11,090 --> 00:14:14,870
many applications okay so i'll say also

361
00:14:14,870 --> 00:14:16,400
to the the sequel standard Divine's

362
00:14:16,400 --> 00:14:19,580
defines a language called a sequel PGM

363
00:14:19,580 --> 00:14:21,860
as far as I know nobody actually

364
00:14:21,860 --> 00:14:25,130
supports that to the exact specification

365
00:14:25,130 --> 00:14:27,680
in the sequel standard they all the

366
00:14:27,680 --> 00:14:29,060
things that look close enough to sequel

367
00:14:29,060 --> 00:14:31,880
PGM still deviate from it so Oracle has

368
00:14:31,880 --> 00:14:35,210
PL sequel Postgres has PL PG sequel

369
00:14:35,210 --> 00:14:37,370
which is a slight variant or is a

370
00:14:37,370 --> 00:14:40,340
variant of the local one usually PL

371
00:14:40,340 --> 00:14:41,990
sequel again PL sequel looks close

372
00:14:41,990 --> 00:14:43,190
enough to sequel PGM but it's not

373
00:14:43,190 --> 00:14:46,400
exactly the same but at a high level it

374
00:14:46,400 --> 00:14:47,810
all looks like Pascal it all looks like

375
00:14:47,810 --> 00:14:50,930
sort of like ADA so other than the more

376
00:14:50,930 --> 00:14:54,410
complex things that the the going from

377
00:14:54,410 --> 00:14:56,240
you know record up press is it a major

378
00:14:56,240 --> 00:14:58,310
change transact sequel it's a little bit

379
00:14:58,310 --> 00:14:59,510
different but it still at a high level

380
00:14:59,510 --> 00:15:00,290
looks the same

381
00:15:00,290 --> 00:15:02,360
alright so here we have a function that

382
00:15:02,360 --> 00:15:04,460
we really fine that's going to get all

383
00:15:04,460 --> 00:15:06,770
the custom IDs from the customer table

384
00:15:06,770 --> 00:15:08,990
and offset from the orders table and

385
00:15:08,990 --> 00:15:11,420
it's gonna compute what customer service

386
00:15:11,420 --> 00:15:12,380
level that they're supposed to have

387
00:15:12,380 --> 00:15:14,480
based on the amount of money they have

388
00:15:14,480 --> 00:15:15,950
spent and the total number orders that

389
00:15:15,950 --> 00:15:19,880
they've they've submitted so our

390
00:15:19,880 --> 00:15:21,770
function is gonna take in a integer

391
00:15:21,770 --> 00:15:24,320
that's the customer key and it's gonna

392
00:15:24,320 --> 00:15:27,560
return a 10 character or string so in

393
00:15:27,560 --> 00:15:29,000
the beginning we will have to declare

394
00:15:29,000 --> 00:15:31,700
all our variables again this is a this

395
00:15:31,700 --> 00:15:33,209
is a remnant of peski

396
00:15:33,209 --> 00:15:36,959
or $1 worth sinking PGM is based on so

397
00:15:36,959 --> 00:15:40,199
in Pasco you define all your your your

398
00:15:40,199 --> 00:15:42,179
variables at the beginning and then we

399
00:15:42,179 --> 00:15:44,189
have now a select statement that again

400
00:15:44,189 --> 00:15:45,209
looks like just like a regular stick

401
00:15:45,209 --> 00:15:46,559
select am except we've added this little

402
00:15:46,559 --> 00:15:48,839
at sign total equals where we're taking

403
00:15:48,839 --> 00:15:52,139
the output of this summation and storing

404
00:15:52,139 --> 00:15:53,639
it and this variable here that we

405
00:15:53,639 --> 00:15:56,670
defined up above then now we have some

406
00:15:56,670 --> 00:15:59,100
if clauses to say if the total order is

407
00:15:59,100 --> 00:16:01,050
greater than a million then there at the

408
00:16:01,050 --> 00:16:03,149
Platinum level otherwise there at the

409
00:16:03,149 --> 00:16:05,759
the regular level and then we just

410
00:16:05,759 --> 00:16:08,279
return the level value which is a 10

411
00:16:08,279 --> 00:16:10,079
character string so the way we would

412
00:16:10,079 --> 00:16:14,189
invoke this for in a query would be a

413
00:16:14,189 --> 00:16:16,399
scam like this on the customer table

414
00:16:16,399 --> 00:16:19,499
where we begin for each customer key

415
00:16:19,499 --> 00:16:21,929
will invoke this function to get the

416
00:16:21,929 --> 00:16:27,779
computer service level okay so the as I

417
00:16:27,779 --> 00:16:30,420
said before the there's some important

418
00:16:30,420 --> 00:16:34,920
advantages of UDF's that sort of explain

419
00:16:34,920 --> 00:16:37,519
why they're actually very very common

420
00:16:37,519 --> 00:16:39,720
again the first one be that they

421
00:16:39,720 --> 00:16:41,339
supporting modularity and reuse because

422
00:16:41,339 --> 00:16:43,529
again if I have a complex function or

423
00:16:43,529 --> 00:16:46,199
complex logic that I need to reuse

424
00:16:46,199 --> 00:16:49,529
across multiple applications in the same

425
00:16:49,529 --> 00:16:50,009
database

426
00:16:50,009 --> 00:16:51,779
I don't want have to re-implement that

427
00:16:51,779 --> 00:16:53,220
logic over and over again

428
00:16:53,220 --> 00:16:56,249
I can instead and bed it inside the

429
00:16:56,249 --> 00:16:59,759
database system and have all instances

430
00:16:59,759 --> 00:17:01,019
of the application no matter how many

431
00:17:01,019 --> 00:17:03,179
times I refactor or change it all rely

432
00:17:03,179 --> 00:17:05,669
on that using that same centralized

433
00:17:05,669 --> 00:17:09,869
location of that logic the we talked

434
00:17:09,869 --> 00:17:11,189
about before having fewer network round

435
00:17:11,189 --> 00:17:14,099
trips again that makes the the queries

436
00:17:14,099 --> 00:17:15,898
run faster because the database has

437
00:17:15,898 --> 00:17:16,949
doesn't have to go back for that never

438
00:17:16,949 --> 00:17:18,599
to say what should you know to find out

439
00:17:18,599 --> 00:17:20,609
what to do next all the logic can run

440
00:17:20,609 --> 00:17:23,880
inside the data system and this one is a

441
00:17:23,880 --> 00:17:25,289
bit subjective but there's been some

442
00:17:25,289 --> 00:17:28,740
arguments that say that the for certain

443
00:17:28,740 --> 00:17:32,070
application domains the sort of the

444
00:17:32,070 --> 00:17:33,210
logic you need to write in your

445
00:17:33,210 --> 00:17:35,159
application is easier to express in

446
00:17:35,159 --> 00:17:38,220
UDF's in the sequel i prefer so then for

447
00:17:38,220 --> 00:17:39,750
some things yes it still makes sense for

448
00:17:39,750 --> 00:17:42,120
other things you know with CT ease

449
00:17:42,120 --> 00:17:45,410
things have gotten a little bit better

450
00:17:45,410 --> 00:17:47,300
but yeah it's certainly some things I'd

451
00:17:47,300 --> 00:17:48,800
like you just don't want to do in sequel

452
00:17:48,800 --> 00:17:51,170
and UDF's are better way to do this by

453
00:17:51,170 --> 00:17:54,590
simply ml gait analysis things sometimes

454
00:17:54,590 --> 00:17:56,150
are better and something that looks like

455
00:17:56,150 --> 00:17:58,370
UDF all right so this sounds amazing

456
00:17:58,370 --> 00:18:00,140
right this sounds like UDS or a big win

457
00:18:00,140 --> 00:18:02,660
we totally want to use this what's the

458
00:18:02,660 --> 00:18:03,860
problem why are we actually spending

459
00:18:03,860 --> 00:18:05,060
time today to talk about how to make

460
00:18:05,060 --> 00:18:08,150
these run faster well the first issue is

461
00:18:08,150 --> 00:18:10,520
going to be that when our query

462
00:18:10,520 --> 00:18:13,250
optimizer encounters in UDF it doesn't

463
00:18:13,250 --> 00:18:15,440
know anything about them and essentially

464
00:18:15,440 --> 00:18:17,860
has to treat them as a black box

465
00:18:17,860 --> 00:18:20,270
because it doesn't know what the

466
00:18:20,270 --> 00:18:22,070
functionality it's going to be right

467
00:18:22,070 --> 00:18:24,770
this is because a UDF's are written in

468
00:18:24,770 --> 00:18:27,320
an imperative language like you know PL

469
00:18:27,320 --> 00:18:32,810
sequel or single PL and we're a sequel

470
00:18:32,810 --> 00:18:34,850
is a declarative language that means the

471
00:18:34,850 --> 00:18:37,520
uploads can reason about what it is if

472
00:18:37,520 --> 00:18:39,380
there's queries actually wants to do and

473
00:18:39,380 --> 00:18:40,970
it also knows something about the data

474
00:18:40,970 --> 00:18:44,030
although as we saw the estimations are

475
00:18:44,030 --> 00:18:45,920
easily wildly inaccurate but Headley

476
00:18:45,920 --> 00:18:47,630
says some some sense of what's what's

477
00:18:47,630 --> 00:18:51,200
happening and so when you encountered

478
00:18:51,200 --> 00:18:53,060
UTF you basically say I don't know what

479
00:18:53,060 --> 00:18:55,220
this is gonna do for me and so if now

480
00:18:55,220 --> 00:18:57,320
you have like a UDF being using the

481
00:18:57,320 --> 00:18:59,150
where clause we're like you know some

482
00:18:59,150 --> 00:19:01,310
value you know just some column equal

483
00:19:01,310 --> 00:19:03,500
another column after it's been churned

484
00:19:03,500 --> 00:19:06,230
through or run through a UDF you have no

485
00:19:06,230 --> 00:19:07,910
idea what their transformation that UDF

486
00:19:07,910 --> 00:19:10,310
is gonna do so therefore you don't know

487
00:19:10,310 --> 00:19:12,110
what the cardinality of the selectivity

488
00:19:12,110 --> 00:19:13,940
of that predicate is going to be so you

489
00:19:13,940 --> 00:19:17,540
basically throw your hands up and you

490
00:19:17,540 --> 00:19:21,590
know you use some I know I don't know

491
00:19:21,590 --> 00:19:22,970
what you do and sometimes the ultimen

492
00:19:22,970 --> 00:19:23,870
time you just say it's the worst case

493
00:19:23,870 --> 00:19:24,770
scenario you say it's the worst

494
00:19:24,770 --> 00:19:25,940
selectively you could ever have like

495
00:19:25,940 --> 00:19:27,740
everything 300 sent selectively or did

496
00:19:27,740 --> 00:19:29,450
the other end could be 0% selectivity or

497
00:19:29,450 --> 00:19:33,170
just take the average you could do a

498
00:19:33,170 --> 00:19:35,300
little bit like the adaptive query

499
00:19:35,300 --> 00:19:36,560
optimization stuff we talked about where

500
00:19:36,560 --> 00:19:37,610
you can run it for a little bit see what

501
00:19:37,610 --> 00:19:40,700
happens and make a decision but as I

502
00:19:40,700 --> 00:19:42,710
said till very recently most systems

503
00:19:42,710 --> 00:19:44,300
didn't actually support those least

504
00:19:44,300 --> 00:19:45,980
commercial systems and none of the open

505
00:19:45,980 --> 00:19:47,120
source systems to support this and when

506
00:19:47,120 --> 00:19:49,820
they do support UDF's all right so the

507
00:19:49,820 --> 00:19:51,380
next one is a bit more nuanced but it's

508
00:19:51,380 --> 00:19:53,750
basically says that the next problem is

509
00:19:53,750 --> 00:19:59,000
that the because the the

510
00:19:59,000 --> 00:20:01,730
is an imperative code we essentially

511
00:20:01,730 --> 00:20:04,460
have to exit them sequentially line by

512
00:20:04,460 --> 00:20:07,100
line and so that means that we're not

513
00:20:07,100 --> 00:20:09,289
going to be able to paralyze any of the

514
00:20:09,289 --> 00:20:12,650
operations on the inside because the

515
00:20:12,650 --> 00:20:15,080
output of one line could be used as the

516
00:20:15,080 --> 00:20:16,460
input for the next line so we can't

517
00:20:16,460 --> 00:20:18,230
execute it to eat so we X Q what came

518
00:20:18,230 --> 00:20:20,690
before it so that sort of lends itself

519
00:20:20,690 --> 00:20:23,840
to Sara execution now it doesn't mean

520
00:20:23,840 --> 00:20:25,700
that if we're doing a scan in parallel

521
00:20:25,700 --> 00:20:26,960
and parallel across multiple threads

522
00:20:26,960 --> 00:20:28,940
that each of those things could invoke

523
00:20:28,940 --> 00:20:32,210
the UDF sequentially but we're not

524
00:20:32,210 --> 00:20:33,850
getting any of the benefits of

525
00:20:33,850 --> 00:20:36,230
recognizing that you know maybe there's

526
00:20:36,230 --> 00:20:38,000
a bunch of sequel queries in the in the

527
00:20:38,000 --> 00:20:40,640
in the UDF that we could run combined

528
00:20:40,640 --> 00:20:42,260
together maybe playing them at the same

529
00:20:42,260 --> 00:20:43,909
time or optimizing at the same time and

530
00:20:43,909 --> 00:20:46,039
instead of invoking all the individual

531
00:20:46,039 --> 00:20:48,049
queries one by one we can combine them

532
00:20:48,049 --> 00:20:50,840
to one one giant query with joins and

533
00:20:50,840 --> 00:20:52,400
make that run fast we don't know

534
00:20:52,400 --> 00:20:54,350
anything about what's going inside so we

535
00:20:54,350 --> 00:20:56,090
can't do those kind of optimizations

536
00:20:56,090 --> 00:20:58,760
that we normally could do and if we had

537
00:20:58,760 --> 00:21:01,280
regular queries the other really tricky

538
00:21:01,280 --> 00:21:04,820
thing is gonna be also is that some

539
00:21:04,820 --> 00:21:05,510
UDF's

540
00:21:05,510 --> 00:21:09,700
actually can contort UDS can create

541
00:21:09,700 --> 00:21:12,289
dynamic sequel statements so essentially

542
00:21:12,289 --> 00:21:16,010
you can declare a string variable and it

543
00:21:16,010 --> 00:21:18,380
incrementally construct the string like

544
00:21:18,380 --> 00:21:20,539
you concatenate strings together say

545
00:21:20,539 --> 00:21:22,120
select star from table things like that

546
00:21:22,120 --> 00:21:25,880
and therefore like you have no idea what

547
00:21:25,880 --> 00:21:27,409
the queries gonna be and to actually

548
00:21:27,409 --> 00:21:29,210
execute that code and then once you have

549
00:21:29,210 --> 00:21:31,159
the string then you invoke that string

550
00:21:31,159 --> 00:21:33,140
as a sequel statement and then that runs

551
00:21:33,140 --> 00:21:35,690
as it you know as a query so you have no

552
00:21:35,690 --> 00:21:37,190
idea how to even prepare for this

553
00:21:37,190 --> 00:21:38,330
because you don't know what the queries

554
00:21:38,330 --> 00:21:41,720
gonna be ahead of time all right some

555
00:21:41,720 --> 00:21:45,710
more problems you have is that the for

556
00:21:45,710 --> 00:21:48,500
complex UDF's the when you have being

557
00:21:48,500 --> 00:21:49,850
there selects tables or where clauses

558
00:21:49,850 --> 00:21:51,740
the database system is gonna have to

559
00:21:51,740 --> 00:21:54,909
execute these things execute the UDF on

560
00:21:54,909 --> 00:21:57,890
each each each each row or each tuple

561
00:21:57,890 --> 00:22:01,490
one by one because again I don't know

562
00:22:01,490 --> 00:22:03,289
what the UDF's gonna do therefore I

563
00:22:03,289 --> 00:22:05,390
don't know whether the logic inside of

564
00:22:05,390 --> 00:22:07,399
it could change from one tuple to the

565
00:22:07,399 --> 00:22:09,440
next because you know I don't know

566
00:22:09,440 --> 00:22:10,850
whether you're just gonna access you

567
00:22:10,850 --> 00:22:12,470
know attribute foo or actual

568
00:22:12,470 --> 00:22:16,120
you know bar in my in my in my to pole

569
00:22:16,120 --> 00:22:19,400
so therefore I don't know how to then

570
00:22:19,400 --> 00:22:21,500
maybe combine multiple in vacations or

571
00:22:21,500 --> 00:22:22,730
vectorize multiple indicators

572
00:22:22,730 --> 00:22:26,570
invocations of the UDF within a batch

573
00:22:26,570 --> 00:22:28,760
you throw your hands up and basically

574
00:22:28,760 --> 00:22:31,730
have to do one by one so Microsoft's

575
00:22:31,730 --> 00:22:34,250
world they have they coined this sort of

576
00:22:34,250 --> 00:22:37,190
the the the term Rho by agonizing bro

577
00:22:37,190 --> 00:22:39,560
are more to represent like how bad you

578
00:22:39,560 --> 00:22:40,910
have to execute why things are bad we

579
00:22:40,910 --> 00:22:46,240
execute UDS so then the last one is that

580
00:22:46,240 --> 00:22:49,460
you know so related all this because

581
00:22:49,460 --> 00:22:51,860
you're executing the the commands or

582
00:22:51,860 --> 00:22:54,830
instructions in the UDF moment one it's

583
00:22:54,830 --> 00:22:56,090
hard to do the cross statement

584
00:22:56,090 --> 00:22:59,060
optimizations for the the for

585
00:22:59,060 --> 00:23:02,890
invocations within the same the same UDF

586
00:23:02,890 --> 00:23:07,490
okay so how do we solve this well one

587
00:23:07,490 --> 00:23:10,400
approach would be to have that people

588
00:23:10,400 --> 00:23:12,370
tried is Microsoft actually tried to

589
00:23:12,370 --> 00:23:14,690
convert the UDF's

590
00:23:14,690 --> 00:23:16,820
into machine code the same way we talked

591
00:23:16,820 --> 00:23:20,270
about we did Co gen for for queries we

592
00:23:20,270 --> 00:23:22,910
could do the same thing for our for

593
00:23:22,910 --> 00:23:25,550
annuity yes but and this may speed up

594
00:23:25,550 --> 00:23:28,970
the invocation of the instructions or

595
00:23:28,970 --> 00:23:31,490
the in the UDF but it still doesn't

596
00:23:31,490 --> 00:23:33,350
solve our paralyzation or a cost

597
00:23:33,350 --> 00:23:34,490
estimation problems or the cross

598
00:23:34,490 --> 00:23:37,250
optimization problems again it just

599
00:23:37,250 --> 00:23:39,380
makes it makes the clapping you di run

600
00:23:39,380 --> 00:23:43,670
faster the the opposite end of the

601
00:23:43,670 --> 00:23:45,350
spectrum tied the worst type of

602
00:23:45,350 --> 00:23:47,420
invocation of the UDF it's not the worse

603
00:23:47,420 --> 00:23:50,510
but it's like the probably the slowest

604
00:23:50,510 --> 00:23:52,160
in the type of invocation would be what

605
00:23:52,160 --> 00:23:53,510
Postgres does which actually converts

606
00:23:53,510 --> 00:23:55,340
each line into a separate query itself

607
00:23:55,340 --> 00:23:57,710
then it invokes that means clever from

608
00:23:57,710 --> 00:23:59,150
the engineering standpoint but from a

609
00:23:59,150 --> 00:24:00,650
performance team point I think it's

610
00:24:00,650 --> 00:24:03,440
pretty abysmal alright so let's see how

611
00:24:03,440 --> 00:24:04,970
bit the bad things can actually get so

612
00:24:04,970 --> 00:24:08,990
this is a curry 12 from TPC H using the

613
00:24:08,990 --> 00:24:11,630
scale factor 1 and so they've modified

614
00:24:11,630 --> 00:24:15,950
the the query to introduce this this

615
00:24:15,950 --> 00:24:18,410
artificial predicate here that have that

616
00:24:18,410 --> 00:24:21,500
invokes a invokes that UDF we saw before

617
00:24:21,500 --> 00:24:23,450
but we're gonna compute the customer

618
00:24:23,450 --> 00:24:25,400
rank all right so we're just gonna get

619
00:24:25,400 --> 00:24:26,179
the customer name

620
00:24:26,179 --> 00:24:29,179
for for each each customer we're looking

621
00:24:29,179 --> 00:24:30,769
at and we just check to see whether it's

622
00:24:30,769 --> 00:24:32,450
it's not null

623
00:24:32,450 --> 00:24:34,279
and so this UDF would just looks like

624
00:24:34,279 --> 00:24:35,990
this all it does is taken the customer

625
00:24:35,990 --> 00:24:37,700
key and it does a single select

626
00:24:37,700 --> 00:24:39,590
statement to do a lookup to get the

627
00:24:39,590 --> 00:24:42,499
customer name and so this this predicate

628
00:24:42,499 --> 00:24:45,529
is essentially useless because in TPCC

629
00:24:45,529 --> 00:24:48,679
for this column the the sorry for the

630
00:24:48,679 --> 00:24:50,929
customer name column it's never going to

631
00:24:50,929 --> 00:24:55,610
be null right but the the optimizer

632
00:24:55,610 --> 00:24:57,440
doesn't know what this is doing here

633
00:24:57,440 --> 00:25:00,049
because this is just a black box now you

634
00:25:00,049 --> 00:25:01,279
could say all right why couldn't try to

635
00:25:01,279 --> 00:25:02,779
interpret what this is you know this

636
00:25:02,779 --> 00:25:06,049
query here and try to inline it but it

637
00:25:06,049 --> 00:25:07,399
doesn't do that because it's not gonna

638
00:25:07,399 --> 00:25:09,080
know not all queries they're gonna not

639
00:25:09,080 --> 00:25:10,340
all you guys are gonna be this simple

640
00:25:10,340 --> 00:25:13,490
so the optimizer doesn't know that this

641
00:25:13,490 --> 00:25:16,940
that no customer name will ever evaluate

642
00:25:16,940 --> 00:25:20,299
to not null or to ever value eight to no

643
00:25:20,299 --> 00:25:22,970
therefore this predicate is always true

644
00:25:22,970 --> 00:25:25,460
so this is just wasted work right we're

645
00:25:25,460 --> 00:25:26,869
invoking this function for something to

646
00:25:26,869 --> 00:25:30,129
check something that will never be false

647
00:25:30,129 --> 00:25:34,610
so if you execute this just the original

648
00:25:34,610 --> 00:25:37,490
query in sequel server you can without

649
00:25:37,490 --> 00:25:39,559
the UDF you can invoke it in in eight

650
00:25:39,559 --> 00:25:42,529
hundred milliseconds but if you just add

651
00:25:42,529 --> 00:25:45,830
this this this simple UDF the same query

652
00:25:45,830 --> 00:25:50,059
now takes 13 hours alright because again

653
00:25:50,059 --> 00:25:54,039
it's for every single for every single

654
00:25:54,039 --> 00:25:57,909
for every single tuple its invoking the

655
00:25:57,909 --> 00:26:00,679
this function over never again now to me

656
00:26:00,679 --> 00:26:02,029
this seems super surprising because it's

657
00:26:02,029 --> 00:26:04,519
like alright well if I if my scale

658
00:26:04,519 --> 00:26:06,259
factors one and how many customers or

659
00:26:06,259 --> 00:26:07,730
line numbers are actually gonna have how

660
00:26:07,730 --> 00:26:10,519
bad that could actually be but for

661
00:26:10,519 --> 00:26:13,070
whatever reason again secret over chokes

662
00:26:13,070 --> 00:26:14,539
on this and getting that goes thirteen

663
00:26:14,539 --> 00:26:18,200
hours so what we'll see today is a

664
00:26:18,200 --> 00:26:20,809
technique called Freud is how to in line

665
00:26:20,809 --> 00:26:22,669
this inside the function to avoid this

666
00:26:22,669 --> 00:26:25,070
you know all the bad things we talked

667
00:26:25,070 --> 00:26:27,889
about and the spoiler D if you write the

668
00:26:27,889 --> 00:26:29,840
same function have the same code and ran

669
00:26:29,840 --> 00:26:31,460
this and Freud you can get it down to

670
00:26:31,460 --> 00:26:33,919
900 milliseconds so it's a hundred

671
00:26:33,919 --> 00:26:37,190
milliseconds slower than then what the

672
00:26:37,190 --> 00:26:38,809
original query was but it's certainly

673
00:26:38,809 --> 00:26:39,740
not the you know

674
00:26:39,740 --> 00:26:41,510
it's not going up to 13 hours like in

675
00:26:41,510 --> 00:26:45,020
orders of magnitude for all right so

676
00:26:45,020 --> 00:26:46,280
let's look at this in shooting history

677
00:26:46,280 --> 00:26:49,460
from how we got to to Freud in single

678
00:26:49,460 --> 00:26:55,160
server and so the in 2001 Microsoft

679
00:26:55,160 --> 00:27:01,179
added support for the scalar UDF's again

680
00:27:01,179 --> 00:27:03,530
computing or taking in scalar values and

681
00:27:03,530 --> 00:27:06,200
producing scaling scalar results in

682
00:27:06,200 --> 00:27:09,350
around 2008 people start to realize that

683
00:27:09,350 --> 00:27:13,070
oh these UDF's are actually kind of bad

684
00:27:13,070 --> 00:27:14,600
they're making things really really slow

685
00:27:14,600 --> 00:27:16,340
like they're great for programmability

686
00:27:16,340 --> 00:27:18,470
and extents extending the the

687
00:27:18,470 --> 00:27:20,600
capabilities of the database system but

688
00:27:20,600 --> 00:27:23,090
it's just crushing performance and so

689
00:27:23,090 --> 00:27:24,980
there's this blog article from an on

690
00:27:24,980 --> 00:27:26,690
Microsoft employee where he basically

691
00:27:26,690 --> 00:27:29,390
says that oh these these UDF's are evil

692
00:27:29,390 --> 00:27:30,590
they write they're making everything

693
00:27:30,590 --> 00:27:34,670
really slow then in 2010 Microsoft

694
00:27:34,670 --> 00:27:36,550
actually publicly acknowledges that

695
00:27:36,550 --> 00:27:39,110
UDF's are evil and they come up with

696
00:27:39,110 --> 00:27:41,090
this blog article that says oh yeah you

697
00:27:41,090 --> 00:27:43,580
do DSR evil here's why

698
00:27:43,580 --> 00:27:45,110
and they actually actively encourage

699
00:27:45,110 --> 00:27:49,040
their developers using sequel server to

700
00:27:49,040 --> 00:27:51,590
not use UTS again and they explain why

701
00:27:51,590 --> 00:27:52,700
and this is when they also introduced

702
00:27:52,700 --> 00:27:54,230
the the native compilation to machine

703
00:27:54,230 --> 00:27:56,450
code of the UTS but even then it doesn't

704
00:27:56,450 --> 00:27:59,000
solve that problem of invoking the UDF

705
00:27:59,000 --> 00:28:02,510
one by one for each tube or each row so

706
00:28:02,510 --> 00:28:08,000
now at this round 2014 there is research

707
00:28:08,000 --> 00:28:12,610
being done at IIT Bombay which is

708
00:28:12,610 --> 00:28:14,540
probably you know it is the best

709
00:28:14,540 --> 00:28:18,920
database school in all of India and they

710
00:28:18,920 --> 00:28:22,190
were doing research on UDF correlations

711
00:28:22,190 --> 00:28:25,670
so it was like early work before Freud

712
00:28:25,670 --> 00:28:26,900
that showed that you can actually do in

713
00:28:26,900 --> 00:28:29,120
lining of UTS and this work was being

714
00:28:29,120 --> 00:28:32,720
done by Karthik Rama Krotz Rama Rama

715
00:28:32,720 --> 00:28:36,110
Rama Chandra who was a PhD student at

716
00:28:36,110 --> 00:28:39,380
IIT Bombay so then he graduates kartha

717
00:28:39,380 --> 00:28:42,200
graduates and then he joins the the Jim

718
00:28:42,200 --> 00:28:43,570
Gray lab in

719
00:28:43,570 --> 00:28:45,820
in Madison Wisconsin she started

720
00:28:45,820 --> 00:28:49,119
exploring how to go further with this as

721
00:28:49,119 --> 00:28:54,669
part of Freud um and so the but by 2018

722
00:28:54,669 --> 00:28:58,320
Microsoft announced that Freud was going

723
00:28:58,320 --> 00:29:01,539
becoming generally available in sequel

724
00:29:01,539 --> 00:29:04,809
server 2019 and last year Microsoft

725
00:29:04,809 --> 00:29:06,279
released the version of secret server

726
00:29:06,279 --> 00:29:09,159
that actually includes Freud and if you

727
00:29:09,159 --> 00:29:10,389
can look in the documentation and Sherin

728
00:29:10,389 --> 00:29:12,879
office says here's here's how to do the

729
00:29:12,879 --> 00:29:16,840
the the in lining of the UDS using the

730
00:29:16,840 --> 00:29:18,009
Freud ticket now they don't call it

731
00:29:18,009 --> 00:29:20,200
Freud because that's like the research

732
00:29:20,200 --> 00:29:22,929
name from a product name no one would

733
00:29:22,929 --> 00:29:24,340
understand that it's just called scale

734
00:29:24,340 --> 00:29:26,049
you know you definitely name but it's

735
00:29:26,049 --> 00:29:27,549
sorta like hackaton Microsoft doesn't

736
00:29:27,549 --> 00:29:29,559
call the the in-memory engine for a

737
00:29:29,559 --> 00:29:30,340
sequel server

738
00:29:30,340 --> 00:29:32,320
Hecate on the researchers know what that

739
00:29:32,320 --> 00:29:33,639
is the researchers know what Freud is

740
00:29:33,639 --> 00:29:36,639
but maybe if you search for a fried in

741
00:29:36,639 --> 00:29:38,019
their documentation it's not going to

742
00:29:38,019 --> 00:29:41,919
show up it's called in mining so this is

743
00:29:41,919 --> 00:29:44,080
say this every year the second year of

744
00:29:44,080 --> 00:29:45,279
talk dick taught us this is very

745
00:29:45,279 --> 00:29:47,679
impressive to go from like starting a

746
00:29:47,679 --> 00:29:51,549
project in 2015 and then getting it

747
00:29:51,549 --> 00:29:55,450
actually in production in in in you know

748
00:29:55,450 --> 00:29:57,489
a major major piece of software that

749
00:29:57,489 --> 00:29:59,109
makes markets all billions of dollars

750
00:29:59,109 --> 00:30:01,479
that will have a lot of impact cause I

751
00:30:01,479 --> 00:30:03,399
mean a lot of people were to get exposed

752
00:30:03,399 --> 00:30:04,720
to this can UDS or use all over the

753
00:30:04,720 --> 00:30:06,820
place but this is a short amount of time

754
00:30:06,820 --> 00:30:08,019
to do some of this this is very

755
00:30:08,019 --> 00:30:10,809
impressive so one it shows you how you

756
00:30:10,809 --> 00:30:12,669
know how significant the gains that

757
00:30:12,669 --> 00:30:13,989
Freud are gonna is going to achieve

758
00:30:13,989 --> 00:30:16,779
because Microsoft put a big engineering

759
00:30:16,779 --> 00:30:18,519
effort to get this in production get

760
00:30:18,519 --> 00:30:22,509
this in the you know the real version of

761
00:30:22,509 --> 00:30:25,479
sequel server and this is rare because

762
00:30:25,479 --> 00:30:27,549
most the time database companies least

763
00:30:27,549 --> 00:30:31,989
the the major ones in Oracle IBM and

764
00:30:31,989 --> 00:30:34,840
Microsoft they are quite conservative

765
00:30:34,840 --> 00:30:37,749
about pushing out new features very

766
00:30:37,749 --> 00:30:39,849
quickly because people rely on these

767
00:30:39,849 --> 00:30:42,039
things and if you know if your product

768
00:30:42,039 --> 00:30:43,479
is seemed especially a database system

769
00:30:43,479 --> 00:30:45,429
it's seen unreliable or kind of flaky or

770
00:30:45,429 --> 00:30:47,139
you're not taking the engineering

771
00:30:47,139 --> 00:30:49,029
process seriously that can seriously

772
00:30:49,029 --> 00:30:52,029
hurt you know sales and your reputation

773
00:30:52,029 --> 00:30:54,700
so to go into this short amount of time

774
00:30:54,700 --> 00:30:56,200
to get this in production is it

775
00:30:56,200 --> 00:30:59,830
is is a big deal all right so what is

776
00:30:59,830 --> 00:31:04,929
Freud so as I said Freud is a is a

777
00:31:04,929 --> 00:31:07,870
technique for converting imperative UDF

778
00:31:07,870 --> 00:31:10,750
code into relational out for expressions

779
00:31:10,750 --> 00:31:12,760
that we can then embed inside of a query

780
00:31:12,760 --> 00:31:17,049
plan inside of a query plan that we're

781
00:31:17,049 --> 00:31:22,360
invoking that UDF right and the reason

782
00:31:22,360 --> 00:31:24,100
why we want to do this is because this

783
00:31:24,100 --> 00:31:27,130
is gonna enable the query optimizer and

784
00:31:27,130 --> 00:31:30,039
the rest of the system to reason about

785
00:31:30,039 --> 00:31:33,309
what the UDF is doing and optimize it

786
00:31:33,309 --> 00:31:35,889
just as it would a regular query but

787
00:31:35,889 --> 00:31:37,659
it's good basically you're converting

788
00:31:37,659 --> 00:31:40,899
imperative code into declared or sequel

789
00:31:40,899 --> 00:31:42,789
declarative relational algebra

790
00:31:42,789 --> 00:31:45,700
expressions all right and the advantage

791
00:31:45,700 --> 00:31:46,929
you're gonna get from this is that from

792
00:31:46,929 --> 00:31:48,330
the application developers perspective

793
00:31:48,330 --> 00:31:51,190
you don't have to do anything you're

794
00:31:51,190 --> 00:31:52,840
just taking your UDS you already have

795
00:31:52,840 --> 00:31:55,990
and you flip a switch to say I want to

796
00:31:55,990 --> 00:31:58,450
use Freud and it'll do that inlining for

797
00:31:58,450 --> 00:31:59,559
you it's it's not like you need to even

798
00:31:59,559 --> 00:32:02,049
touch your application again this this

799
00:32:02,049 --> 00:32:03,610
is super rare think about this anytime

800
00:32:03,610 --> 00:32:05,350
you know there's a new secret say

801
00:32:05,350 --> 00:32:06,700
there's a new magic sequel function

802
00:32:06,700 --> 00:32:09,070
that's gonna be that can make your

803
00:32:09,070 --> 00:32:12,010
application faster they oftentimes

804
00:32:12,010 --> 00:32:13,480
they'll keep the old one in place and

805
00:32:13,480 --> 00:32:14,740
then you have to go change your

806
00:32:14,740 --> 00:32:16,809
application to use the new one or change

807
00:32:16,809 --> 00:32:18,370
how you're instead of the queries there

808
00:32:18,370 --> 00:32:19,750
something like that you don't have to do

809
00:32:19,750 --> 00:32:22,630
any of that Freud it just it just works

810
00:32:22,630 --> 00:32:26,700
right that that's very cool

811
00:32:27,269 --> 00:32:30,490
so what's gonna happen is that the

812
00:32:30,490 --> 00:32:32,470
queries gonna show up that's gonna

813
00:32:32,470 --> 00:32:35,500
invoke an EDF and then Freud would do

814
00:32:35,500 --> 00:32:39,130
the conversion in the sort of binder

815
00:32:39,130 --> 00:32:41,950
rewriter phase before you get to the

816
00:32:41,950 --> 00:32:43,809
cost base clear your query optimizer so

817
00:32:43,809 --> 00:32:47,950
all the rules that we're gonna do to do

818
00:32:47,950 --> 00:32:51,399
this inlining are just don't require a

819
00:32:51,399 --> 00:32:53,380
cost model like they're sort of static

820
00:32:53,380 --> 00:32:55,179
heuristic to say the static

821
00:32:55,179 --> 00:32:57,039
transformation rules to say here's the

822
00:32:57,039 --> 00:32:58,149
minute here's the how to manipulate the

823
00:32:58,149 --> 00:33:00,370
UDF to make the to convert it to

824
00:33:00,370 --> 00:33:03,880
something that i can inline the only

825
00:33:03,880 --> 00:33:07,860
sort of thing you need to consider is

826
00:33:07,860 --> 00:33:10,230
sort of parameter or flag that would

827
00:33:10,230 --> 00:33:12,920
specify how deep you want to go and

828
00:33:12,920 --> 00:33:15,330
instead of doing the in linings for like

829
00:33:15,330 --> 00:33:17,460
nested UDF calls like you can have UDS

830
00:33:17,460 --> 00:33:19,320
called UDS call you do yes

831
00:33:19,320 --> 00:33:21,360
and if you try to inline all of that

832
00:33:21,360 --> 00:33:24,990
then that becomes it becomes you know

833
00:33:24,990 --> 00:33:27,680
more difficult now for the optimizer to

834
00:33:27,680 --> 00:33:31,110
try to to plan and optimize because now

835
00:33:31,110 --> 00:33:33,570
you have this giant giant query whereas

836
00:33:33,570 --> 00:33:35,010
before it was just all bunch of UDF

837
00:33:35,010 --> 00:33:36,600
calls so there's only there's it's far

838
00:33:36,600 --> 00:33:37,410
as you know there's only one parameter

839
00:33:37,410 --> 00:33:40,410
that says how how deep you want to go

840
00:33:40,410 --> 00:33:42,540
and so essentially what's going to do is

841
00:33:42,540 --> 00:33:44,760
it's going to try to do this inlining by

842
00:33:44,760 --> 00:33:47,760
creating sub queries and the reason why

843
00:33:47,760 --> 00:33:49,590
we want to do this is because all the

844
00:33:49,590 --> 00:33:52,080
major database systems especially sequel

845
00:33:52,080 --> 00:33:55,640
server have very sophisticated

846
00:33:55,640 --> 00:33:58,340
constructs or transformations for

847
00:33:58,340 --> 00:34:01,100
unnecessaries and converting them into

848
00:34:01,100 --> 00:34:04,410
either joins or or temp table

849
00:34:04,410 --> 00:34:07,470
invocations right so we're going to burn

850
00:34:07,470 --> 00:34:09,570
all our UDS into sub queries and then

851
00:34:09,570 --> 00:34:11,400
let the optimizer rewrite them those sub

852
00:34:11,400 --> 00:34:16,980
queries into a more optimized form so we

853
00:34:16,980 --> 00:34:18,239
didn't we didn't get the talk about sub

854
00:34:18,239 --> 00:34:20,940
queries too much but I didn't want to

855
00:34:20,940 --> 00:34:22,560
talk about them and lateral joins or the

856
00:34:22,560 --> 00:34:23,880
apply operator because these are these

857
00:34:23,880 --> 00:34:25,350
sort of the set up to understand what

858
00:34:25,350 --> 00:34:27,960
we're gonna do so with the sub query

859
00:34:27,960 --> 00:34:30,300
it's basically when you have us a select

860
00:34:30,300 --> 00:34:34,280
query inside of another query and the

861
00:34:34,280 --> 00:34:37,020
idea is that the the daily system

862
00:34:37,020 --> 00:34:39,270
conditioner to treat these the sub query

863
00:34:39,270 --> 00:34:41,639
the nested query as almost like a

864
00:34:41,639 --> 00:34:44,370
function that will can return a single

865
00:34:44,370 --> 00:34:47,340
by or set of values so so conceptually

866
00:34:47,340 --> 00:34:49,620
the sub query is almost the same thing

867
00:34:49,620 --> 00:34:51,179
as the UF or it's like something inside

868
00:34:51,179 --> 00:34:53,670
of us and you can get back values so as

869
00:34:53,670 --> 00:34:55,889
I said the way the optimizer is going to

870
00:34:55,889 --> 00:34:58,860
handle this is two approaches you either

871
00:34:58,860 --> 00:35:00,810
rewrite them to be correlative flatten

872
00:35:00,810 --> 00:35:02,850
the queries so that they're doing joins

873
00:35:02,850 --> 00:35:04,380
or in some cases you can rewrite them

874
00:35:04,380 --> 00:35:08,460
into a single table query or are you

875
00:35:08,460 --> 00:35:11,040
gonna break out the nested query store

876
00:35:11,040 --> 00:35:13,500
its result in a temporary table or sort

877
00:35:13,500 --> 00:35:15,900
of run that separately first why they're

878
00:35:15,900 --> 00:35:17,580
not attached to the same query plan or

879
00:35:17,580 --> 00:35:18,840
it's broken out the separate query plan

880
00:35:18,840 --> 00:35:21,090
that depends on the implementation

881
00:35:21,090 --> 00:35:23,310
ideas that we run the the inner queries

882
00:35:23,310 --> 00:35:25,230
first materialize it to a temporary

883
00:35:25,230 --> 00:35:27,360
table and then we run the outer query

884
00:35:27,360 --> 00:35:29,940
and then they can do is read that joins

885
00:35:29,940 --> 00:35:31,500
against that temp table and the temp

886
00:35:31,500 --> 00:35:34,230
table is thrown away when the query

887
00:35:34,230 --> 00:35:37,170
finishes so let's look at a simple

888
00:35:37,170 --> 00:35:39,930
example of doing a rewrite so say you

889
00:35:39,930 --> 00:35:42,960
have a query here where I want to get

890
00:35:42,960 --> 00:35:46,200
the name of the sailors that reserved a

891
00:35:46,200 --> 00:35:50,220
boat from the made a reservation for a

892
00:35:50,220 --> 00:35:53,310
boat on this particular day so I just

893
00:35:53,310 --> 00:35:55,080
have give me all the you know I have a

894
00:35:55,080 --> 00:35:57,000
where clauses that exists a tuple where

895
00:35:57,000 --> 00:36:00,480
there's a reference to the the sailor ID

896
00:36:00,480 --> 00:36:02,280
from the outer table and a reserve ID on

897
00:36:02,280 --> 00:36:05,250
the inner table so when a database

898
00:36:05,250 --> 00:36:07,110
system sees this and if it can do

899
00:36:07,110 --> 00:36:08,940
rewriting it could rewrite this as a

900
00:36:08,940 --> 00:36:11,610
simple join like this right because the

901
00:36:11,610 --> 00:36:13,740
alternative would be I run this query

902
00:36:13,740 --> 00:36:15,780
for every single tuple I have in the

903
00:36:15,780 --> 00:36:17,430
sailors table but that's going to be

904
00:36:17,430 --> 00:36:19,740
super slow so I can just rewrite it to

905
00:36:19,740 --> 00:36:22,740
this and then I then I do whatever the

906
00:36:22,740 --> 00:36:24,960
hash join of additional join that I want

907
00:36:24,960 --> 00:36:27,990
to do all right so again we're not gonna

908
00:36:27,990 --> 00:36:30,150
talk about this so much the there's a

909
00:36:30,150 --> 00:36:32,340
group in the in the course is doing this

910
00:36:32,340 --> 00:36:34,110
for the final project and as they talked

911
00:36:34,110 --> 00:36:35,280
about when they do the proposal and

912
00:36:35,280 --> 00:36:37,380
status update the different types of sub

913
00:36:37,380 --> 00:36:39,060
queries that they're going to try to

914
00:36:39,060 --> 00:36:41,940
support in our system the thing another

915
00:36:41,940 --> 00:36:44,400
thing we haven't talked about is lateral

916
00:36:44,400 --> 00:36:47,730
join and the way I think about a lateral

917
00:36:47,730 --> 00:36:53,490
join is when I have nested queries I can

918
00:36:53,490 --> 00:36:57,210
have the inner query reference the the

919
00:36:57,210 --> 00:37:00,060
outer query right so inside my inner

920
00:37:00,060 --> 00:37:02,610
query here I can reference the sailor ID

921
00:37:02,610 --> 00:37:06,630
from the outer table here but if I had

922
00:37:06,630 --> 00:37:10,170
the two queries not nested but sort of

923
00:37:10,170 --> 00:37:12,810
executed one after another like my from

924
00:37:12,810 --> 00:37:14,100
clause I can have a bunch of select

925
00:37:14,100 --> 00:37:16,500
statements inside of that a lateral

926
00:37:16,500 --> 00:37:19,340
joint is gonna allow me to reference the

927
00:37:19,340 --> 00:37:23,840
the attributes or from tuples from

928
00:37:23,840 --> 00:37:26,610
queries being executed sort of

929
00:37:26,610 --> 00:37:29,730
sequentially or executed at the same

930
00:37:29,730 --> 00:37:33,740
nesting level all right so the

931
00:37:33,740 --> 00:37:36,830
without this lateral keyword you and you

932
00:37:36,830 --> 00:37:38,810
would execute each sub-query

933
00:37:38,810 --> 00:37:40,880
independently and you wouldn't be able

934
00:37:40,880 --> 00:37:42,560
to refer to the items of each other

935
00:37:42,560 --> 00:37:44,510
attributes of each other in the from

936
00:37:44,510 --> 00:37:47,030
clause but when this we allow ourselves

937
00:37:47,030 --> 00:37:50,740
to reference the other attributes right

938
00:37:50,740 --> 00:37:53,839
so the this will make more sense when we

939
00:37:53,839 --> 00:37:55,820
see examples in a second but just know

940
00:37:55,820 --> 00:37:59,119
that like in the Freud paper they're

941
00:37:59,119 --> 00:38:00,890
using what is called the apply operator

942
00:38:00,890 --> 00:38:04,339
to do these lateral joins I think that's

943
00:38:04,339 --> 00:38:06,410
within the sequel standard but other

944
00:38:06,410 --> 00:38:08,300
systems like postgis and Oracle you

945
00:38:08,300 --> 00:38:11,560
explicitly call this as a lateral joint

946
00:38:11,560 --> 00:38:15,260
okay so let's go through a Freudian

947
00:38:15,260 --> 00:38:19,250
so it's gonna have five steps so in the

948
00:38:19,250 --> 00:38:22,040
first step we want to transform the

949
00:38:22,040 --> 00:38:25,160
sortie seco statements in our UDF into

950
00:38:25,160 --> 00:38:28,160
sequel queries and then now we're going

951
00:38:28,160 --> 00:38:32,240
to convert the UDF into regions that are

952
00:38:32,240 --> 00:38:33,890
going to allow us to then reason about

953
00:38:33,890 --> 00:38:36,170
the sequel queries within that region

954
00:38:36,170 --> 00:38:38,720
and then we'll combine all the

955
00:38:38,720 --> 00:38:40,820
expressions from each region now weather

956
00:38:40,820 --> 00:38:42,320
gets the individual sequel statements

957
00:38:42,320 --> 00:38:44,570
within a region into a single sequel

958
00:38:44,570 --> 00:38:48,130
statement and then now we can inline the

959
00:38:48,130 --> 00:38:51,050
the UDF expressions that from the

960
00:38:51,050 --> 00:38:55,730
combined the combined giant query into

961
00:38:55,730 --> 00:38:58,400
the query that invoked our UDF and then

962
00:38:58,400 --> 00:38:59,480
we just run this through our query

963
00:38:59,480 --> 00:39:02,810
optimizer to do the optimization that

964
00:39:02,810 --> 00:39:06,050
and the unnecessaries as needed all

965
00:39:06,050 --> 00:39:06,440
right

966
00:39:06,440 --> 00:39:09,140
so what I'll say is that for this

967
00:39:09,140 --> 00:39:11,690
example with Freud I'm gonna show an

968
00:39:11,690 --> 00:39:13,099
illustration that I'm going to show you

969
00:39:13,099 --> 00:39:17,030
these steps using sequel queries but the

970
00:39:17,030 --> 00:39:18,859
real implementation of Freud in sequel

971
00:39:18,859 --> 00:39:20,869
server doesn't operate on sequel queries

972
00:39:20,869 --> 00:39:22,820
and instead operates on relational

973
00:39:22,820 --> 00:39:25,970
algebra operators but I'm using sequel

974
00:39:25,970 --> 00:39:28,369
because it it's easier to read this way

975
00:39:28,369 --> 00:39:31,130
the second technique will to do inlining

976
00:39:31,130 --> 00:39:33,740
I'll show you actually does operate on

977
00:39:33,740 --> 00:39:35,930
sequel queries ok connects going to

978
00:39:35,930 --> 00:39:38,930
convert them into comment expressions

979
00:39:38,930 --> 00:39:41,000
viii immediate forms aren't to be

980
00:39:41,000 --> 00:39:42,500
exactly sequel queries but the end

981
00:39:42,500 --> 00:39:45,170
result is is what it in lines are sequel

982
00:39:45,170 --> 00:39:47,030
queries whereas what this is inlining

983
00:39:47,030 --> 00:39:51,170
is relational algebra expressions all

984
00:39:51,170 --> 00:39:54,380
right so our first step is assuming we

985
00:39:54,380 --> 00:39:55,820
had that example from before where we're

986
00:39:55,820 --> 00:39:57,770
getting given a customer key we'll tell

987
00:39:57,770 --> 00:40:00,620
you what service level your app in the

988
00:40:00,620 --> 00:40:02,650
first step we have going to break up our

989
00:40:02,650 --> 00:40:05,030
all of our imperative statements that

990
00:40:05,030 --> 00:40:07,820
are in our query but we have the you

991
00:40:07,820 --> 00:40:11,480
know setting a level the Select

992
00:40:11,480 --> 00:40:13,280
statement here or doing the if Clause

993
00:40:13,280 --> 00:40:16,270
here we can convert all of these into

994
00:40:16,270 --> 00:40:18,200
into sequel statements we have to do

995
00:40:18,200 --> 00:40:20,000
this because this is t sequel commands

996
00:40:20,000 --> 00:40:21,800
this is not sequel this is not relate

997
00:40:21,800 --> 00:40:23,300
your algebra things right so we have to

998
00:40:23,300 --> 00:40:24,380
convert them to sequel statements so

999
00:40:24,380 --> 00:40:25,630
that we can then combine them together

1000
00:40:25,630 --> 00:40:28,460
so it's almost always gonna be a 1:1

1001
00:40:28,460 --> 00:40:30,230
mapping so from one sort of statement

1002
00:40:30,230 --> 00:40:33,140
within the UDF will produce one query

1003
00:40:33,140 --> 00:40:35,150
it's not always the case but for our

1004
00:40:35,150 --> 00:40:38,690
example will be right so for this

1005
00:40:38,690 --> 00:40:40,520
setting the variable level to Platinum

1006
00:40:40,520 --> 00:40:43,310
that's the same thing as doing a select

1007
00:40:43,310 --> 00:40:45,380
when you take the constant string

1008
00:40:45,380 --> 00:40:48,350
platinum and project it into the

1009
00:40:48,350 --> 00:40:51,530
attribute level in the output the Apple

1010
00:40:51,530 --> 00:40:53,960
result for the query by this table is

1011
00:40:53,960 --> 00:40:56,900
query which is valid sequel then for

1012
00:40:56,900 --> 00:40:58,820
this one here computing the sum well

1013
00:40:58,820 --> 00:41:00,680
that's the same thing is just using the

1014
00:41:00,680 --> 00:41:02,210
same query as before computing the sum

1015
00:41:02,210 --> 00:41:06,500
but then again projecting it out to the

1016
00:41:06,500 --> 00:41:09,620
total the total attribute and the last

1017
00:41:09,620 --> 00:41:11,090
one here if total is greater than 1

1018
00:41:11,090 --> 00:41:14,720
million that's just a case demon I bunch

1019
00:41:14,720 --> 00:41:17,570
of in an estimate if clauses but to then

1020
00:41:17,570 --> 00:41:20,210
produce prettiest applets and then since

1021
00:41:20,210 --> 00:41:22,010
we don't have an else statement here we

1022
00:41:22,010 --> 00:41:23,450
don't know what else to do we end up

1023
00:41:23,450 --> 00:41:26,930
putting a null all right so now the next

1024
00:41:26,930 --> 00:41:29,330
step is again we says we know how to do

1025
00:41:29,330 --> 00:41:32,210
this conversion now what will break up

1026
00:41:32,210 --> 00:41:34,880
our UDF into regions and then construct

1027
00:41:34,880 --> 00:41:36,500
a relational algebra expression or a

1028
00:41:36,500 --> 00:41:39,620
sequel query for for each of those so

1029
00:41:39,620 --> 00:41:41,420
for this first part here we're going to

1030
00:41:41,420 --> 00:41:42,350
quote me where we declare some variables

1031
00:41:42,350 --> 00:41:46,730
and we then take the compute the sum

1032
00:41:46,730 --> 00:41:48,920
total price for the customer starting

1033
00:41:48,920 --> 00:41:52,040
and the total key we're gonna create for

1034
00:41:52,040 --> 00:41:56,480
each region a synthetic table where we

1035
00:41:56,480 --> 00:41:59,920
can assign again the values that

1036
00:41:59,920 --> 00:42:02,950
needed to store in variables to be

1037
00:42:02,950 --> 00:42:05,680
projected output attributes alright so

1038
00:42:05,680 --> 00:42:08,620
in this case here we initialize the

1039
00:42:08,620 --> 00:42:10,510
level attribute sorry the level

1040
00:42:10,510 --> 00:42:13,240
attribute - - - nothing here so we'll

1041
00:42:13,240 --> 00:42:15,340
just you know send that out to be Nome

1042
00:42:15,340 --> 00:42:17,560
and then in here we compute that sum we

1043
00:42:17,560 --> 00:42:19,600
had before and we'll sign it to the

1044
00:42:19,600 --> 00:42:21,940
total variable and then we'll store this

1045
00:42:21,940 --> 00:42:25,570
in a synthetic table for our temporary

1046
00:42:25,570 --> 00:42:27,340
table for for this portion of the query

1047
00:42:27,340 --> 00:42:31,420
as you are one now for this next one

1048
00:42:31,420 --> 00:42:33,400
here our second region is going to cover

1049
00:42:33,400 --> 00:42:35,590
this portion of the if clause and again

1050
00:42:35,590 --> 00:42:37,240
it's that same case statement that I saw

1051
00:42:37,240 --> 00:42:39,520
in the previous slide right and then

1052
00:42:39,520 --> 00:42:41,830
we'll destroy this in let's gonna store

1053
00:42:41,830 --> 00:42:43,450
the result of this into the level

1054
00:42:43,450 --> 00:42:45,070
attribute and then we'll store this in

1055
00:42:45,070 --> 00:42:51,430
the ER PR - er - table so then the third

1056
00:42:51,430 --> 00:42:53,350
one here will be just the other port

1057
00:42:53,350 --> 00:42:56,440
part of the if statement and this would

1058
00:42:56,440 --> 00:42:58,090
just be the the opposite of what exists

1059
00:42:58,090 --> 00:43:00,400
or if the total is less than equal to 1

1060
00:43:00,400 --> 00:43:03,010
million then we'll set it to regular but

1061
00:43:03,010 --> 00:43:05,280
notice actually for both of these here

1062
00:43:05,280 --> 00:43:11,080
the on this case here the the if I don't

1063
00:43:11,080 --> 00:43:14,890
have a if if my if if the total that's

1064
00:43:14,890 --> 00:43:16,960
presented from from this this guy up

1065
00:43:16,960 --> 00:43:19,450
here if this is greater than a million

1066
00:43:19,450 --> 00:43:21,970
set at the Platinum otherwise use

1067
00:43:21,970 --> 00:43:23,680
whatever the level value that was a sign

1068
00:43:23,680 --> 00:43:26,200
up in here right so I'm referencing this

1069
00:43:26,200 --> 00:43:28,450
table I'm referencing you are one down

1070
00:43:28,450 --> 00:43:30,070
inside here because I'm sort of again

1071
00:43:30,070 --> 00:43:32,440
going from top to bottom if I didn't set

1072
00:43:32,440 --> 00:43:33,670
level here that I wanna make sure that I

1073
00:43:33,670 --> 00:43:35,350
did propagating what the level was up

1074
00:43:35,350 --> 00:43:36,970
before I don't know whether was set up

1075
00:43:36,970 --> 00:43:39,010
above me in our example here it's at the

1076
00:43:39,010 --> 00:43:40,690
null but it could have been set by some

1077
00:43:40,690 --> 00:43:42,580
some other computation and so I'm just

1078
00:43:42,580 --> 00:43:43,960
saying that I don't know what it is so

1079
00:43:43,960 --> 00:43:46,150
just and I'm not I'm not modifying it so

1080
00:43:46,150 --> 00:43:48,940
just pass down whatever it was in the in

1081
00:43:48,940 --> 00:43:51,400
the region up above me the other thing

1082
00:43:51,400 --> 00:43:55,390
I'll point out too is for this example

1083
00:43:55,390 --> 00:43:57,010
although it's cut off this is one two

1084
00:43:57,010 --> 00:44:00,220
three I could have a single region for

1085
00:44:00,220 --> 00:44:03,100
my if statement that included the F else

1086
00:44:03,100 --> 00:44:07,440
because then the the else portion of of

1087
00:44:07,440 --> 00:44:10,090
this case statement up here could could

1088
00:44:10,090 --> 00:44:11,710
have just been the regular thing and

1089
00:44:11,710 --> 00:44:13,599
then I don't need to do

1090
00:44:13,599 --> 00:44:17,009
you know total lesson Eagle million for

1091
00:44:17,009 --> 00:44:20,769
for this example you could do this in

1092
00:44:20,769 --> 00:44:23,190
other examples you cannot because the

1093
00:44:23,190 --> 00:44:25,479
you could have like return statements

1094
00:44:25,479 --> 00:44:27,549
inside of us again like this is easy

1095
00:44:27,549 --> 00:44:28,930
because this is like this is like for

1096
00:44:28,930 --> 00:44:30,940
inside be of calls I set one variable

1097
00:44:30,940 --> 00:44:32,650
but I think again I can do anything I

1098
00:44:32,650 --> 00:44:35,289
want inside of this this if calls like

1099
00:44:35,289 --> 00:44:36,489
if I fall into it I can call another

1100
00:44:36,489 --> 00:44:38,140
function I can return statement actually

1101
00:44:38,140 --> 00:44:40,059
a query and if that's the case it'd be

1102
00:44:40,059 --> 00:44:41,529
hard it may be dirt to declare that

1103
00:44:41,529 --> 00:44:44,529
inside of this I and have an else

1104
00:44:44,529 --> 00:44:46,420
statement so for this reason for sort of

1105
00:44:46,420 --> 00:44:48,309
simplicity we're breaking it up into two

1106
00:44:48,309 --> 00:44:51,489
separate regions alright the last one is

1107
00:44:51,489 --> 00:44:53,049
the return statement this one will be

1108
00:44:53,049 --> 00:44:54,420
easy to handle

1109
00:44:54,420 --> 00:44:57,369
we'll just see this on the next on the

1110
00:44:57,369 --> 00:44:58,029
next slide

1111
00:44:58,029 --> 00:44:59,499
it's just producing whatever the output

1112
00:44:59,499 --> 00:45:02,380
of level is when I combine these these

1113
00:45:02,380 --> 00:45:03,849
the queries for the different regions

1114
00:45:03,849 --> 00:45:05,950
together again for this one it's super

1115
00:45:05,950 --> 00:45:07,960
easy because inside my function there's

1116
00:45:07,960 --> 00:45:09,970
only one return statement the paper

1117
00:45:09,970 --> 00:45:12,789
talks about how for statements you could

1118
00:45:12,789 --> 00:45:14,410
have returned for some UDS you could

1119
00:45:14,410 --> 00:45:16,479
have return statements in all different

1120
00:45:16,479 --> 00:45:19,089
parts of the program at the end of the

1121
00:45:19,089 --> 00:45:20,380
day you always kind of need one return

1122
00:45:20,380 --> 00:45:22,569
statement at the bottom and so the way

1123
00:45:22,569 --> 00:45:24,190
they handled that is they look they'll

1124
00:45:24,190 --> 00:45:25,569
create a synthetic variable called

1125
00:45:25,569 --> 00:45:28,299
called return value and instead of

1126
00:45:28,299 --> 00:45:29,650
calling return and try to return the

1127
00:45:29,650 --> 00:45:31,509
result there you'll set return value

1128
00:45:31,509 --> 00:45:33,069
inside of where it wherever it was

1129
00:45:33,069 --> 00:45:35,109
invoked and then just returned that as

1130
00:45:35,109 --> 00:45:38,710
the output at the bottom alright alright

1131
00:45:38,710 --> 00:45:42,339
so now we have our regions that we

1132
00:45:42,339 --> 00:45:44,410
defined the queries we define for the

1133
00:45:44,410 --> 00:45:46,029
regions that we broke up our UDF into

1134
00:45:46,029 --> 00:45:48,339
the next step is now to start merging

1135
00:45:48,339 --> 00:45:52,089
these into two to one one select

1136
00:45:52,089 --> 00:45:53,799
statement so that's what this is here

1137
00:45:53,799 --> 00:45:55,420
and this is where the the lateral

1138
00:45:55,420 --> 00:45:56,920
joining or the cross apply comes into

1139
00:45:56,920 --> 00:45:59,890
play alright so the first thing to point

1140
00:45:59,890 --> 00:46:01,119
out through is like here's our return

1141
00:46:01,119 --> 00:46:02,469
function here's the return value that we

1142
00:46:02,469 --> 00:46:03,400
had before right

1143
00:46:03,400 --> 00:46:06,039
er ER 3 dot level right cuz that's the

1144
00:46:06,039 --> 00:46:07,630
last thing we're gonna look at the

1145
00:46:07,630 --> 00:46:09,400
bottom of the UDF and then we want

1146
00:46:09,400 --> 00:46:10,569
whatever the level was set to and

1147
00:46:10,569 --> 00:46:12,579
because that's the output but now you

1148
00:46:12,579 --> 00:46:13,930
can see why we need to use these cross

1149
00:46:13,930 --> 00:46:16,210
joins because I have my from calls from

1150
00:46:16,210 --> 00:46:19,630
the top and then I have three sub

1151
00:46:19,630 --> 00:46:22,779
queries that aren't nested inside of

1152
00:46:22,779 --> 00:46:24,579
each other right there they're executed

1153
00:46:24,579 --> 00:46:25,580
has

1154
00:46:25,580 --> 00:46:27,830
your service siblings for a lack of a

1155
00:46:27,830 --> 00:46:31,160
better term so in order for this sub

1156
00:46:31,160 --> 00:46:35,060
query to reference a attributes in this

1157
00:46:35,060 --> 00:46:37,220
sub query up here I gotta use the cross

1158
00:46:37,220 --> 00:46:39,830
apply or I gotta use the lateral join so

1159
00:46:39,830 --> 00:46:42,290
that I can reference er one here because

1160
00:46:42,290 --> 00:46:44,420
without this I can't I can't do that

1161
00:46:44,420 --> 00:46:50,080
it'll say undefined attribute alright so

1162
00:46:50,080 --> 00:46:53,120
this also shows you that the output or

1163
00:46:53,120 --> 00:46:57,710
they the computation of each each of

1164
00:46:57,710 --> 00:46:59,900
these sort of sort of regions depends on

1165
00:46:59,900 --> 00:47:03,680
the previous one and then I'm gonna as

1166
00:47:03,680 --> 00:47:06,230
I'm setting up a modifying level as I go

1167
00:47:06,230 --> 00:47:08,150
down and then I the last one whatever

1168
00:47:08,150 --> 00:47:10,160
gets set up down here is what I produce

1169
00:47:10,160 --> 00:47:13,550
as my output alright so this is it so

1170
00:47:13,550 --> 00:47:15,800
this is this is the seagull clear we

1171
00:47:15,800 --> 00:47:18,200
would generate for that original UDF

1172
00:47:18,200 --> 00:47:19,730
that we saw in the beginning written in

1173
00:47:19,730 --> 00:47:21,440
T sequel like this will produce a

1174
00:47:21,440 --> 00:47:24,470
computation that is a produced result

1175
00:47:24,470 --> 00:47:26,450
that is equivalent for an e for any

1176
00:47:26,450 --> 00:47:29,180
given key so now we need to inline this

1177
00:47:29,180 --> 00:47:30,560
we need to put this inside of our

1178
00:47:30,560 --> 00:47:33,440
original query so if we go back the

1179
00:47:33,440 --> 00:47:35,750
original query was that we're invoking

1180
00:47:35,750 --> 00:47:37,430
the customer level function for each

1181
00:47:37,430 --> 00:47:40,310
customer key in the the select output

1182
00:47:40,310 --> 00:47:43,040
clause so all we need to do now is just

1183
00:47:43,040 --> 00:47:46,270
replace customer level here with our

1184
00:47:46,270 --> 00:47:50,540
with our combined together applied

1185
00:47:50,540 --> 00:47:53,480
operator query from the from the last

1186
00:47:53,480 --> 00:47:55,880
slide and then here's again all the same

1187
00:47:55,880 --> 00:47:59,270
regions that we have before okay so now

1188
00:47:59,270 --> 00:48:01,700
with this giant sequel statement we will

1189
00:48:01,700 --> 00:48:03,820
now want we want to inline this into our

1190
00:48:03,820 --> 00:48:06,740
we've inline this into our query and now

1191
00:48:06,740 --> 00:48:08,510
we can run it through the optimizer and

1192
00:48:08,510 --> 00:48:12,850
let it let it do its thing to produce a

1193
00:48:12,850 --> 00:48:15,650
more efficient query plan by rewriting

1194
00:48:15,650 --> 00:48:19,430
and and breaking up our run nesting or

1195
00:48:19,430 --> 00:48:20,690
sub queries here

1196
00:48:20,690 --> 00:48:23,570
so what sequel server optimizer will

1197
00:48:23,570 --> 00:48:25,730
generate is is an equipment plan like

1198
00:48:25,730 --> 00:48:28,700
this where it no longer does all these

1199
00:48:28,700 --> 00:48:30,590
these sort of these sort of sub selects

1200
00:48:30,590 --> 00:48:32,510
I'm just doing a left outer join

1201
00:48:32,510 --> 00:48:36,320
inside this where I compute the you know

1202
00:48:36,320 --> 00:48:39,160
I get the total total amount I

1203
00:48:39,160 --> 00:48:42,130
compute the total amount of orders

1204
00:48:42,130 --> 00:48:43,930
placed for each single customer you're

1205
00:48:43,930 --> 00:48:45,100
doing the group I on the customer key

1206
00:48:45,100 --> 00:48:47,230
then I do is join against that and now I

1207
00:48:47,230 --> 00:48:49,120
pushed Mike Mike a statement up here in

1208
00:48:49,120 --> 00:48:50,770
the Select output just to look whatever

1209
00:48:50,770 --> 00:48:52,690
the output is from this aggregation and

1210
00:48:52,690 --> 00:48:54,360
then produced the right output level

1211
00:48:54,360 --> 00:48:59,520
right so what what went from a blackbox

1212
00:48:59,520 --> 00:49:04,150
invocation of this this computation but

1213
00:49:04,150 --> 00:49:06,070
to get some customer level thing I just

1214
00:49:06,070 --> 00:49:09,490
completely rewrote it into a a simple

1215
00:49:09,490 --> 00:49:11,320
aggregation followed by a left outer

1216
00:49:11,320 --> 00:49:14,710
join this is amazing right this is think

1217
00:49:14,710 --> 00:49:17,500
about it it's like you're doing this for

1218
00:49:17,500 --> 00:49:20,560
any UDF almost any UDF they can do this

1219
00:49:20,560 --> 00:49:22,450
on so it's not like I had a like you

1220
00:49:22,450 --> 00:49:23,950
know I had to pay someone a lot of money

1221
00:49:23,950 --> 00:49:25,510
to sit down and look at my UDS and

1222
00:49:25,510 --> 00:49:26,950
figure out oh how can I actually rewrite

1223
00:49:26,950 --> 00:49:30,280
this into a query because not every you

1224
00:49:30,280 --> 00:49:33,340
know well it's gonna be invoked it's

1225
00:49:33,340 --> 00:49:34,750
gonna be different from you know

1226
00:49:34,750 --> 00:49:36,220
sometimes it'll be in the phone calls

1227
00:49:36,220 --> 00:49:37,870
even though we're close like it could be

1228
00:49:37,870 --> 00:49:39,400
invoked differently every single time

1229
00:49:39,400 --> 00:49:41,410
but and then rather than having to

1230
00:49:41,410 --> 00:49:42,610
rewrite every single see coke where to

1231
00:49:42,610 --> 00:49:45,340
use it by doing this conversion into

1232
00:49:45,340 --> 00:49:48,070
this this giant seagulls inline sequel

1233
00:49:48,070 --> 00:49:51,160
statement I produced a more efficient

1234
00:49:51,160 --> 00:49:54,010
query plan him know change the

1235
00:49:54,010 --> 00:49:55,060
application code didn't have to hire a

1236
00:49:55,060 --> 00:49:56,350
man do that no changes to the query

1237
00:49:56,350 --> 00:49:57,730
optimizer the query optimizer can

1238
00:49:57,730 --> 00:49:58,840
already handle this there's nothing

1239
00:49:58,840 --> 00:50:00,910
specific about Freud in this in this

1240
00:50:00,910 --> 00:50:04,210
query it's all you know vanilla sequel

1241
00:50:04,210 --> 00:50:07,810
servers sequel syntax so this is amazing

1242
00:50:07,810 --> 00:50:10,810
so now also to the benefit is that UDF

1243
00:50:10,810 --> 00:50:11,860
is no longer our black box and the

1244
00:50:11,860 --> 00:50:14,650
optimizer in terms of from a cost model

1245
00:50:14,650 --> 00:50:16,510
perspective so we know how to do you

1246
00:50:16,510 --> 00:50:17,650
know search for the most efficient

1247
00:50:17,650 --> 00:50:20,470
physical plan for for this sequel

1248
00:50:20,470 --> 00:50:22,750
statement you know the logical plan if

1249
00:50:22,750 --> 00:50:24,730
we can now invoke this in parallel as

1250
00:50:24,730 --> 00:50:26,050
well is I can have a parallel threaded

1251
00:50:26,050 --> 00:50:28,450
compute the the group I I can now have a

1252
00:50:28,450 --> 00:50:29,920
parallel and then parallel thread do the

1253
00:50:29,920 --> 00:50:32,950
do the you know produce the output every

1254
00:50:32,950 --> 00:50:34,720
single query in the you do after you

1255
00:50:34,720 --> 00:50:37,780
couldn't do that so again I'm super you

1256
00:50:37,780 --> 00:50:39,490
know excited about this because I think

1257
00:50:39,490 --> 00:50:45,480
that this is a huge win okay so now

1258
00:50:45,480 --> 00:50:47,800
let's talk about what are some

1259
00:50:47,800 --> 00:50:49,450
additional optimizations the query

1260
00:50:49,450 --> 00:50:51,550
optimizer can do that we can get because

1261
00:50:51,550 --> 00:50:52,530
we've in mind

1262
00:50:52,530 --> 00:50:55,770
single statement so let's look at really

1263
00:50:55,770 --> 00:50:57,720
simple UDF like this so-called get vowel

1264
00:50:57,720 --> 00:51:00,300
where you input some value to this

1265
00:51:00,300 --> 00:51:01,530
function and some may be some integer

1266
00:51:01,530 --> 00:51:04,410
and then it's gonna tell you that if it

1267
00:51:04,410 --> 00:51:06,240
turns back a string that says if the

1268
00:51:06,240 --> 00:51:07,800
value is greater than a thousand and for

1269
00:51:07,800 --> 00:51:09,840
turn hi if the gret the value is greater

1270
00:51:09,840 --> 00:51:11,190
than or less than a less than you go to

1271
00:51:11,190 --> 00:51:13,350
a thousand return low and then just

1272
00:51:13,350 --> 00:51:15,600
concatenate whatever that value is to

1273
00:51:15,600 --> 00:51:18,150
the to the string die so you get high

1274
00:51:18,150 --> 00:51:20,720
value low value based on the input

1275
00:51:20,720 --> 00:51:23,190
alright so say that we had this

1276
00:51:23,190 --> 00:51:24,810
invocation so we know what the value of

1277
00:51:24,810 --> 00:51:27,660
this this number is I said we can

1278
00:51:27,660 --> 00:51:32,160
substitute 5000 of X to be 5000 wherever

1279
00:51:32,160 --> 00:51:35,250
you need to so what we would get it with

1280
00:51:35,250 --> 00:51:38,400
Freud is a is a select statement it

1281
00:51:38,400 --> 00:51:42,080
looks like this right where I have a

1282
00:51:42,080 --> 00:51:45,840
lateral join where I'm taking the output

1283
00:51:45,840 --> 00:51:47,580
of this case statement depending what my

1284
00:51:47,580 --> 00:51:49,440
input is and I'll get high value and low

1285
00:51:49,440 --> 00:51:52,920
value so now let's go across and see

1286
00:51:52,920 --> 00:51:54,960
what kind of optimizations the well you

1287
00:51:54,960 --> 00:51:56,580
know the the rewriting the operators are

1288
00:51:56,580 --> 00:51:58,890
gonna do to cut down the complexity of

1289
00:51:58,890 --> 00:52:00,840
this program and it's gonna look a lot

1290
00:52:00,840 --> 00:52:04,980
like what a traditional compiler

1291
00:52:04,980 --> 00:52:07,620
optimizer will do but you know for a

1292
00:52:07,620 --> 00:52:09,840
pair of languages like C or C++ like

1293
00:52:09,840 --> 00:52:11,100
this is something the optimizer can do

1294
00:52:11,100 --> 00:52:14,490
its query optimizer video so the first

1295
00:52:14,490 --> 00:52:16,500
thing is that we can you dynamic slicing

1296
00:52:16,500 --> 00:52:19,500
right we can recognize that we know the

1297
00:52:19,500 --> 00:52:21,480
exact value that that's been given to us

1298
00:52:21,480 --> 00:52:25,130
so we can throw out the the low

1299
00:52:25,130 --> 00:52:30,030
conditional low path in our in our in a

1300
00:52:30,030 --> 00:52:32,310
program because we know what the content

1301
00:52:32,310 --> 00:52:33,930
is for the X so we know that we're never

1302
00:52:33,930 --> 00:52:35,880
even gonna execute this so we just we

1303
00:52:35,880 --> 00:52:38,640
just remove it entirely then we could do

1304
00:52:38,640 --> 00:52:41,130
propagation constant propagation and

1305
00:52:41,130 --> 00:52:44,070
folding again recognizing here that we

1306
00:52:44,070 --> 00:52:46,020
have a select query that all it does is

1307
00:52:46,020 --> 00:52:48,090
produced the output hi and then there's

1308
00:52:48,090 --> 00:52:49,650
a select query that takes whatever this

1309
00:52:49,650 --> 00:52:51,180
thing produced and produces that as the

1310
00:52:51,180 --> 00:52:54,960
output so and then you know do the same

1311
00:52:54,960 --> 00:52:56,790
thing over here or take take append

1312
00:52:56,790 --> 00:52:57,540
these two things together

1313
00:52:57,540 --> 00:53:00,030
so rather than invoking all these these

1314
00:53:00,030 --> 00:53:01,710
these sub queries with the with the

1315
00:53:01,710 --> 00:53:04,720
lateral join eigen is evoke that as

1316
00:53:04,720 --> 00:53:06,370
they sort of combine that together into

1317
00:53:06,370 --> 00:53:08,620
a single constant that I produce right

1318
00:53:08,620 --> 00:53:10,900
and then the equivalent in the UDF will

1319
00:53:10,900 --> 00:53:13,030
be up here and the last step would be

1320
00:53:13,030 --> 00:53:15,250
dead code elimination again recognizing

1321
00:53:15,250 --> 00:53:18,700
that I don't need to even set the value

1322
00:53:18,700 --> 00:53:20,350
to high or set it and clear available

1323
00:53:20,350 --> 00:53:21,910
produces the output I can just return

1324
00:53:21,910 --> 00:53:24,250
the value directly I say the same thing

1325
00:53:24,250 --> 00:53:29,290
in the PDF the same thing as a has as in

1326
00:53:29,290 --> 00:53:30,580
the relational address so Freud is

1327
00:53:30,580 --> 00:53:31,900
essentially achieving the same thing by

1328
00:53:31,900 --> 00:53:35,490
using the the query optimizer to do this

1329
00:53:35,490 --> 00:53:38,680
to do these rewriting steps we're

1330
00:53:38,680 --> 00:53:39,850
getting all the same benefits you would

1331
00:53:39,850 --> 00:53:42,850
get from a traditional like GCC client

1332
00:53:42,850 --> 00:53:44,890
query optimizer so again but they didn't

1333
00:53:44,890 --> 00:53:47,200
have to write that because they got the

1334
00:53:47,200 --> 00:53:49,900
UDF into relational algebra form they

1335
00:53:49,900 --> 00:53:52,540
got all that for free from Microsoft's

1336
00:53:52,540 --> 00:53:55,510
you know very expensive and very good

1337
00:53:55,510 --> 00:54:01,570
query optimizer so what can fluid

1338
00:54:01,570 --> 00:54:06,670
support so as of twine the 2019 in

1339
00:54:06,670 --> 00:54:08,110
sequel server and the paper you guys

1340
00:54:08,110 --> 00:54:11,410
read Freud can support most of the

1341
00:54:11,410 --> 00:54:14,290
constructs in T sequel so declare and

1342
00:54:14,290 --> 00:54:15,790
set select statements if-then-else

1343
00:54:15,790 --> 00:54:19,110
returns exists and other set operators

1344
00:54:19,110 --> 00:54:22,810
they can handle recursive calls or

1345
00:54:22,810 --> 00:54:25,210
nested calls to other UTS they can

1346
00:54:25,210 --> 00:54:27,580
handle all the possible sequel types as

1347
00:54:27,580 --> 00:54:30,280
of this this you know this paper here

1348
00:54:30,280 --> 00:54:34,330
and in in in production sequence over

1349
00:54:34,330 --> 00:54:37,300
2019 they don't support loops they don't

1350
00:54:37,300 --> 00:54:38,800
sort for loops while loops they don't

1351
00:54:38,800 --> 00:54:40,840
support dynamic queries because again

1352
00:54:40,840 --> 00:54:42,520
you don't know what the query is gonna

1353
00:54:42,520 --> 00:54:45,580
be before it runs and you doesn't

1354
00:54:45,580 --> 00:54:46,960
support exceptions which are

1355
00:54:46,960 --> 00:54:49,120
surprisingly common in UDF's

1356
00:54:49,120 --> 00:54:52,780
so alright so you say well there are

1357
00:54:52,780 --> 00:54:55,480
some limitations but how how prevalent

1358
00:54:55,480 --> 00:55:00,220
are these things in in in in sort of

1359
00:55:00,220 --> 00:55:01,930
real world applications so in the paper

1360
00:55:01,930 --> 00:55:04,300
what they did is they looked at the top

1361
00:55:04,300 --> 00:55:07,900
100 sequel as your databases running and

1362
00:55:07,900 --> 00:55:10,450
running the cloud for them and they just

1363
00:55:10,450 --> 00:55:12,850
sort of look at all the scalar UDS the

1364
00:55:12,850 --> 00:55:15,880
people are using and there's like it's

1365
00:55:15,880 --> 00:55:17,590
over 85,000 of them and

1366
00:55:17,590 --> 00:55:20,560
of those 85,000 UDF's they they found

1367
00:55:20,560 --> 00:55:22,870
out about about 60% of them could be

1368
00:55:22,870 --> 00:55:24,840
inline with the technique using Freud

1369
00:55:24,840 --> 00:55:27,190
and then in the paper they evaluate

1370
00:55:27,190 --> 00:55:28,840
three different customer workloads and

1371
00:55:28,840 --> 00:55:31,000
they're showing here again what

1372
00:55:31,000 --> 00:55:32,920
percentage of the yes that they're using

1373
00:55:32,920 --> 00:55:36,840
our Freud compatible right so again

1374
00:55:36,840 --> 00:55:39,010
there are you know they're argue that's

1375
00:55:39,010 --> 00:55:40,330
out there using for loops and dynamic

1376
00:55:40,330 --> 00:55:43,320
reconstruction that fraud can't support

1377
00:55:43,320 --> 00:55:46,000
but for our large percentage of them

1378
00:55:46,000 --> 00:55:49,000
this is this is quite significant and so

1379
00:55:49,000 --> 00:55:50,410
the benefit the speed-up you're going to

1380
00:55:50,410 --> 00:55:52,630
get for some of these customers are very

1381
00:55:52,630 --> 00:55:56,140
impressive so there are some cases where

1382
00:55:56,140 --> 00:55:58,710
Floyd actually makes things worse I

1383
00:55:58,710 --> 00:56:01,150
forget why the paper said this was the

1384
00:56:01,150 --> 00:56:04,930
case I I don't remember just because it

1385
00:56:04,930 --> 00:56:06,910
I don't remember whether because he may

1386
00:56:06,910 --> 00:56:08,230
be optimized and run longer or maybe

1387
00:56:08,230 --> 00:56:10,000
because it picked up a wave on that I

1388
00:56:10,000 --> 00:56:13,150
don't remember but there's still a you

1389
00:56:13,150 --> 00:56:16,180
know large there's a so this is long the

1390
00:56:16,180 --> 00:56:19,630
the x-axis is just a unique invocation

1391
00:56:19,630 --> 00:56:22,210
of one particular UDF and then it's

1392
00:56:22,210 --> 00:56:23,470
sorted based on the speed-up they're

1393
00:56:23,470 --> 00:56:26,320
getting so again for these cases here

1394
00:56:26,320 --> 00:56:29,500
they're getting you know up to 800 X

1395
00:56:29,500 --> 00:56:33,280
improvement in performance for for UDF's

1396
00:56:33,280 --> 00:56:34,750
without having to change any application

1397
00:56:34,750 --> 00:56:38,340
code this and this is unheard of because

1398
00:56:38,340 --> 00:56:40,810
all of them in like you know the money

1399
00:56:40,810 --> 00:56:42,730
if you buy new Hager unless your hugger

1400
00:56:42,730 --> 00:56:43,660
like you're running on like you know

1401
00:56:43,660 --> 00:56:45,010
computers from like nineteen nineteen

1402
00:56:45,010 --> 00:56:46,960
then you buy brand new computers maybe

1403
00:56:46,960 --> 00:56:48,280
you know you would see the speed-up

1404
00:56:48,280 --> 00:56:50,860
but you know where does it ever the case

1405
00:56:50,860 --> 00:56:55,330
that there's something that you can get

1406
00:56:55,330 --> 00:56:57,310
a huge speed up like this for these

1407
00:56:57,310 --> 00:57:00,250
queries without having to modify your

1408
00:57:00,250 --> 00:57:02,980
application code at all and again I

1409
00:57:02,980 --> 00:57:04,420
think this is telling about why

1410
00:57:04,420 --> 00:57:06,190
Microsoft got this in production very

1411
00:57:06,190 --> 00:57:07,960
quickly because the performance benefit

1412
00:57:07,960 --> 00:57:10,060
you can get from this is so massive the

1413
00:57:10,060 --> 00:57:11,830
coach and stuff we talked about today

1414
00:57:11,830 --> 00:57:13,750
like in certainly in that case if you're

1415
00:57:13,750 --> 00:57:15,490
going from an interpreted engine to a

1416
00:57:15,490 --> 00:57:17,050
compiled engine you're gonna get a huge

1417
00:57:17,050 --> 00:57:19,720
speed up but when you know so that one

1418
00:57:19,720 --> 00:57:21,490
would be it's an example of something

1419
00:57:21,490 --> 00:57:22,690
similar to this where you can just you

1420
00:57:22,690 --> 00:57:23,950
could run the same sequel queries and

1421
00:57:23,950 --> 00:57:26,170
get the same kind of speed up um but

1422
00:57:26,170 --> 00:57:27,430
like the vectorized stuff that we talked

1423
00:57:27,430 --> 00:57:29,140
about sure like in the columbia paper

1424
00:57:29,140 --> 00:57:31,120
for individual algorithms they were

1425
00:57:31,120 --> 00:57:31,390
getting

1426
00:57:31,390 --> 00:57:34,180
big speed-up but that only happened when

1427
00:57:34,180 --> 00:57:37,480
everything sat in in CPU cache but when

1428
00:57:37,480 --> 00:57:39,730
you actually put things in and things

1429
00:57:39,730 --> 00:57:41,200
exceed the cache and you actually got a

1430
00:57:41,200 --> 00:57:44,260
you know spilled and DRAM you know maybe

1431
00:57:44,260 --> 00:57:45,670
the best you're seeing like a twenty

1432
00:57:45,670 --> 00:57:47,530
five twenty percent fifteen percent

1433
00:57:47,530 --> 00:57:50,740
improvement like this this is 800 X

1434
00:57:50,740 --> 00:57:53,830
that's massive so this is again this is

1435
00:57:53,830 --> 00:57:55,750
why I teach this paper because I think

1436
00:57:55,750 --> 00:57:58,830
it's actually it's a huge huge deal okay

1437
00:57:58,830 --> 00:58:02,020
so as you can imagine

1438
00:58:02,020 --> 00:58:05,650
Microsoft has patents on this so it sort

1439
00:58:05,650 --> 00:58:09,970
of limits you know at this point I'm not

1440
00:58:09,970 --> 00:58:14,290
a patent lawyer but I imagine the you

1441
00:58:14,290 --> 00:58:15,700
know using the Freud technique and other

1442
00:58:15,700 --> 00:58:19,090
database systems would be well good you

1443
00:58:19,090 --> 00:58:22,570
know could cause some legal problems but

1444
00:58:22,570 --> 00:58:24,310
the good news is there's other ways to

1445
00:58:24,310 --> 00:58:26,710
do this inlining without going through

1446
00:58:26,710 --> 00:58:28,210
the same kind of transformation steps

1447
00:58:28,210 --> 00:58:31,780
that Freud does and so this came from a

1448
00:58:31,780 --> 00:58:33,700
paper published actually this year in

1449
00:58:33,700 --> 00:58:38,080
January at cider on how to convert UDF's

1450
00:58:38,080 --> 00:58:41,020
into common table expressions so rather

1451
00:58:41,020 --> 00:58:44,710
than rewriting the UDS into relational

1452
00:58:44,710 --> 00:58:46,540
object sessions that you then inline

1453
00:58:46,540 --> 00:58:48,730
into the query plan where instead of

1454
00:58:48,730 --> 00:58:50,590
gonna rewrite them into siegel queries

1455
00:58:50,590 --> 00:58:54,310
using recursive CTE recursive comment

1456
00:58:54,310 --> 00:58:56,500
expressions and what this is also going

1457
00:58:56,500 --> 00:58:58,480
to get us is that other than you're not

1458
00:58:58,480 --> 00:59:00,340
doing exactly weighted fluid does it it

1459
00:59:00,340 --> 00:59:03,160
also gets you supporting iterations and

1460
00:59:03,160 --> 00:59:05,250
loops and other control flow concepts

1461
00:59:05,250 --> 00:59:09,000
our constructs that were not possible in

1462
00:59:09,000 --> 00:59:11,830
that version of freud now i will say

1463
00:59:11,830 --> 00:59:14,800
there is a newer version of freud freud

1464
00:59:14,800 --> 00:59:15,850
tupelo know if you want to call it that

1465
00:59:15,850 --> 00:59:18,750
being published this year in sigmod i

1466
00:59:18,750 --> 00:59:20,800
was given an early preview of the paper

1467
00:59:20,800 --> 00:59:23,590
a few days ago so and hans time to

1468
00:59:23,590 --> 00:59:25,360
discuss here and in that version they do

1469
00:59:25,360 --> 00:59:28,630
support loops but up until now this

1470
00:59:28,630 --> 00:59:29,770
particular purchase i'm showing you here

1471
00:59:29,770 --> 00:59:31,870
is the only one that can do this so the

1472
00:59:31,870 --> 00:59:33,100
other interesting thing about this

1473
00:59:33,100 --> 00:59:36,970
approach from another set of Germans is

1474
00:59:36,970 --> 00:59:40,870
that the the rewriting technique that

1475
00:59:40,870 --> 00:59:42,990
they're proposing can actually

1476
00:59:42,990 --> 00:59:45,510
and as a middleware layer that does not

1477
00:59:45,510 --> 00:59:47,340
need to be intrinsically tied or tightly

1478
00:59:47,340 --> 00:59:48,930
coupled with the after database system

1479
00:59:48,930 --> 00:59:52,080
implication so in there in this paper

1480
00:59:52,080 --> 00:59:53,490
they show that they're doing this on

1481
00:59:53,490 --> 00:59:55,920
Postgres but you could do it for Oracle

1482
00:59:55,920 --> 00:59:59,580
you could do it for for any any gaming

1483
00:59:59,580 --> 01:00:00,900
system that supporting you yes and also

1484
01:00:00,900 --> 01:00:02,930
supported recursive comic expressions

1485
01:00:02,930 --> 01:00:05,280
all right so let's see how they're gonna

1486
01:00:05,280 --> 01:00:06,480
do it and how it has to be different

1487
01:00:06,480 --> 01:00:08,520
than fluid so it also is gonna have five

1488
01:00:08,520 --> 01:00:09,840
steps where the last step is again

1489
01:00:09,840 --> 01:00:11,369
running it through the query optimizer

1490
01:00:11,369 --> 01:00:15,810
but they're gonna take a more I can't

1491
01:00:15,810 --> 01:00:17,220
comment on like whether this is more ple

1492
01:00:17,220 --> 01:00:19,230
or overall principle I this is not my

1493
01:00:19,230 --> 01:00:22,320
area it it just seems it's a different

1494
01:00:22,320 --> 01:00:24,440
approach to end up with sort of a

1495
01:00:24,440 --> 01:00:26,610
similar end result that you can in line

1496
01:00:26,610 --> 01:00:29,040
these UDS so we're gonna go through each

1497
01:00:29,040 --> 01:00:30,750
of these one by one but basically we're

1498
01:00:30,750 --> 01:00:34,740
start off with our PL sequel or PL PG

1499
01:00:34,740 --> 01:00:38,610
sequel UDS that's gonna have some kind

1500
01:00:38,610 --> 01:00:40,680
of arbitrary iterative control flow in

1501
01:00:40,680 --> 01:00:43,440
them more so you know going beyond what

1502
01:00:43,440 --> 01:00:45,780
before I can do and then in the first

1503
01:00:45,780 --> 01:00:48,060
step we're going to do is convert them

1504
01:00:48,060 --> 01:00:51,180
into SSA which is going to convert it

1505
01:00:51,180 --> 01:00:55,609
into a program that uses go-to based

1506
01:00:55,609 --> 01:00:58,560
control flow then we're gonna hand this

1507
01:00:58,560 --> 01:01:00,660
off and now convert the SSA form into an

1508
01:01:00,660 --> 01:01:03,600
administrative normal form that will

1509
01:01:03,600 --> 01:01:05,960
give us a mutually tail recursive

1510
01:01:05,960 --> 01:01:11,820
function then we'll convert that will

1511
01:01:11,820 --> 01:01:13,440
convert the type recursion we're doing

1512
01:01:13,440 --> 01:01:15,150
here into with the tail recursion and

1513
01:01:15,150 --> 01:01:17,220
actually we can then rewrite that into

1514
01:01:17,220 --> 01:01:19,740
the CTE using with the with recursive

1515
01:01:19,740 --> 01:01:21,570
command and again now we have a giant

1516
01:01:21,570 --> 01:01:22,950
sequel statement as we did with Freud

1517
01:01:22,950 --> 01:01:24,750
and then we shove that off to our

1518
01:01:24,750 --> 01:01:27,869
optimizer alright so for this one we're

1519
01:01:27,869 --> 01:01:30,480
going to show an example in NP OPG

1520
01:01:30,480 --> 01:01:32,850
sequel so again it's it's different than

1521
01:01:32,850 --> 01:01:34,740
T Seagle but as you can see it roughly

1522
01:01:34,740 --> 01:01:36,810
looks the same like the difference is I

1523
01:01:36,810 --> 01:01:38,369
declare my variables separately outside

1524
01:01:38,369 --> 01:01:41,220
the begin where T sequel you give us all

1525
01:01:41,220 --> 01:01:43,500
you declare them after the begin right

1526
01:01:43,500 --> 01:01:44,850
so it's like minor differences like that

1527
01:01:44,850 --> 01:01:45,960
but at a high level is still the same

1528
01:01:45,960 --> 01:01:48,869
thing so this is going to be the power

1529
01:01:48,869 --> 01:01:50,840
function where we given

1530
01:01:50,840 --> 01:01:52,790
a base value and then we gave an

1531
01:01:52,790 --> 01:01:54,260
exponent and then we're going to take it

1532
01:01:54,260 --> 01:01:55,880
to the nth power so forgive an axe

1533
01:01:55,880 --> 01:01:58,520
ticking to the nth power so and the way

1534
01:01:58,520 --> 01:02:00,980
we do that is just do a while loop for

1535
01:02:00,980 --> 01:02:02,570
the number of iterations that are less

1536
01:02:02,570 --> 01:02:04,370
than the nth power and we're going to

1537
01:02:04,370 --> 01:02:06,980
multiply the the value by itself and

1538
01:02:06,980 --> 01:02:10,810
then we return it so let me record it

1539
01:02:10,810 --> 01:02:15,200
convert it into SSA form again this is

1540
01:02:15,200 --> 01:02:17,630
now the control flow of the function

1541
01:02:17,630 --> 01:02:21,080
expressed with go-to statements and the

1542
01:02:21,080 --> 01:02:22,940
other aspect of SSA is that each

1543
01:02:22,940 --> 01:02:27,500
variable within a within the block other

1544
01:02:27,500 --> 01:02:29,510
than the program can only be assigned

1545
01:02:29,510 --> 01:02:32,930
once so I'm not a compilers person but

1546
01:02:32,930 --> 01:02:34,490
my understanding yet this is what this

1547
01:02:34,490 --> 01:02:36,290
is what compilers are doing on the

1548
01:02:36,290 --> 01:02:39,500
inside when they when they convert their

1549
01:02:39,500 --> 01:02:41,930
programming languages so in this case

1550
01:02:41,930 --> 01:02:43,400
here write the same thing as a power

1551
01:02:43,400 --> 01:02:45,050
function I assign my variables and then

1552
01:02:45,050 --> 01:02:47,390
I use a go to is to jump other to the

1553
01:02:47,390 --> 01:02:49,820
exit to return values or loop through

1554
01:02:49,820 --> 01:02:52,150
and with the body of the loop there

1555
01:02:52,150 --> 01:02:56,300
alright so now that we have our UDF in

1556
01:02:56,300 --> 01:02:58,730
it SSA form we want to convert it to the

1557
01:02:58,730 --> 01:03:01,730
a normal form and for this one here this

1558
01:03:01,730 --> 01:03:03,590
is being mutually recursive calls where

1559
01:03:03,590 --> 01:03:06,590
we were just doing the the recursive

1560
01:03:06,590 --> 01:03:08,780
call to another function is always at

1561
01:03:08,780 --> 01:03:11,930
the tail at the bottom of the of the

1562
01:03:11,930 --> 01:03:14,930
whatever the function block so we call

1563
01:03:14,930 --> 01:03:16,700
power we set up some variables then call

1564
01:03:16,700 --> 01:03:18,560
our while loop and then this spins

1565
01:03:18,560 --> 01:03:21,950
through and in this case here this is

1566
01:03:21,950 --> 01:03:24,500
our exit exit clause right if we if

1567
01:03:24,500 --> 01:03:26,690
you've added enough that were greater

1568
01:03:26,690 --> 01:03:29,000
and greater than equal to n which is the

1569
01:03:29,000 --> 01:03:31,210
the number times when it you want to

1570
01:03:31,210 --> 01:03:34,340
multiply the value by itself if we

1571
01:03:34,340 --> 01:03:36,050
satisfy this constraint then we break

1572
01:03:36,050 --> 01:03:37,460
out so this is essentially the return

1573
01:03:37,460 --> 01:03:39,650
statement here otherwise we jump in here

1574
01:03:39,650 --> 01:03:41,420
and actually do the computation but then

1575
01:03:41,420 --> 01:03:47,210
loop back all right so now with the in

1576
01:03:47,210 --> 01:03:50,510
the a normal form we can then convert it

1577
01:03:50,510 --> 01:03:53,840
into using direct recursion so I'm sort

1578
01:03:53,840 --> 01:03:55,070
of simplifying the step here but now I'm

1579
01:03:55,070 --> 01:03:58,460
combining now the while the wild block

1580
01:03:58,460 --> 01:04:00,500
and the body block in tow stable run

1581
01:04:00,500 --> 01:04:02,630
block where I do all that same

1582
01:04:02,630 --> 01:04:04,520
computation yeah but before

1583
01:04:04,520 --> 01:04:06,570
so now this is a single recursive

1584
01:04:06,570 --> 01:04:10,020
function that is only using the tail

1585
01:04:10,020 --> 01:04:11,190
recursive calls right there's no

1586
01:04:11,190 --> 01:04:13,230
recursive calls somewhere arbitrarily in

1587
01:04:13,230 --> 01:04:17,970
the query so then now with this I can

1588
01:04:17,970 --> 01:04:21,660
take this imperative code and convert

1589
01:04:21,660 --> 01:04:24,870
that into a giant secret single

1590
01:04:24,870 --> 01:04:27,360
statement would see with CT ease so this

1591
01:04:27,360 --> 01:04:31,020
is a bit gnarly to look at but briefly

1592
01:04:31,020 --> 01:04:32,070
the way to think about this here's the

1593
01:04:32,070 --> 01:04:34,530
first part of the function that does

1594
01:04:34,530 --> 01:04:37,170
some initialization so I'm setting up my

1595
01:04:37,170 --> 01:04:39,390
my I vow to keep track of enum times

1596
01:04:39,390 --> 01:04:42,120
I've looped setting up the P bio to keep

1597
01:04:42,120 --> 01:04:44,430
track of you know the running total as I

1598
01:04:44,430 --> 01:04:48,600
do my my my reason I think to the power

1599
01:04:48,600 --> 01:04:50,430
and that's just the Select statement

1600
01:04:50,430 --> 01:04:52,560
here which is just setting up some

1601
01:04:52,560 --> 01:04:54,090
variables as the initialization Clause

1602
01:04:54,090 --> 01:04:56,640
of the CTE but then the Union all it

1603
01:04:56,640 --> 01:04:59,640
allow me to invoke the same same query

1604
01:04:59,640 --> 01:05:02,640
over and over again and get that gift of

1605
01:05:02,640 --> 01:05:04,920
recursive the recursive calls that we

1606
01:05:04,920 --> 01:05:08,490
need so all of this here is combined

1607
01:05:08,490 --> 01:05:10,560
into this sequel statement here which

1608
01:05:10,560 --> 01:05:13,290
does the logic that that we need right

1609
01:05:13,290 --> 01:05:16,380
so the if I've gone past my number

1610
01:05:16,380 --> 01:05:19,850
iterations then I this thing evaluates

1611
01:05:19,850 --> 01:05:22,200
this thing would evaluate to false would

1612
01:05:22,200 --> 01:05:25,050
and then I can break out and then all of

1613
01:05:25,050 --> 01:05:27,180
this down here like so this is sort of

1614
01:05:27,180 --> 01:05:28,860
confusing but this call thing here this

1615
01:05:28,860 --> 01:05:31,230
is the name of a of an attribute that

1616
01:05:31,230 --> 01:05:33,240
we're defining as but the name is call

1617
01:05:33,240 --> 01:05:34,140
question mark when you put the quote

1618
01:05:34,140 --> 01:05:36,120
double quotation marks around it to make

1619
01:05:36,120 --> 01:05:37,950
sure that it's sheena treated this

1620
01:05:37,950 --> 01:05:41,130
ballots equals syntax so we're using

1621
01:05:41,130 --> 01:05:43,080
that variable to decide that the false

1622
01:05:43,080 --> 01:05:44,760
or true whether to keep calling myself

1623
01:05:44,760 --> 01:05:46,800
and then when this thing evaluates to

1624
01:05:46,800 --> 01:05:48,810
false then I my program breaks wrap

1625
01:05:48,810 --> 01:05:51,210
breaks out I unwind from all my

1626
01:05:51,210 --> 01:05:53,880
recursive calls and produce the output

1627
01:05:53,880 --> 01:05:57,090
to the Select statement here so again

1628
01:05:57,090 --> 01:05:59,940
this is widely different than what Freud

1629
01:05:59,940 --> 01:06:01,320
is doing but a conception you end up

1630
01:06:01,320 --> 01:06:02,820
with the same result where you have the

1631
01:06:02,820 --> 01:06:05,820
ability to now inline in arbitrary UDF

1632
01:06:05,820 --> 01:06:08,160
with actually four loops and you get the

1633
01:06:08,160 --> 01:06:09,390
four loops with using recursive

1634
01:06:09,390 --> 01:06:13,140
recursion and be one of oak them in a

1635
01:06:13,140 --> 01:06:16,800
query so at this point it is unclear

1636
01:06:16,800 --> 01:06:17,670
whether

1637
01:06:17,670 --> 01:06:22,609
produces more optimal plans than Freud

1638
01:06:22,609 --> 01:06:25,680
that spearmint of that evaluation has

1639
01:06:25,680 --> 01:06:28,799
not been done this also does not support

1640
01:06:28,799 --> 01:06:30,359
the dynamically structure sequel queries

1641
01:06:30,359 --> 01:06:33,150
and that doesn't support exceptions but

1642
01:06:33,150 --> 01:06:34,890
this is something back to you we are

1643
01:06:34,890 --> 01:06:36,869
talking with now with Karthik and

1644
01:06:36,869 --> 01:06:39,420
Torsten the the other friendly German

1645
01:06:39,420 --> 01:06:41,910
that made this paper that I wrote this

1646
01:06:41,910 --> 01:06:43,770
work we're looking at sort of sort of

1647
01:06:43,770 --> 01:06:46,710
comparing all these together along with

1648
01:06:46,710 --> 01:06:50,010
the the compilation stuff of the UTS

1649
01:06:50,010 --> 01:06:52,079
effect for the for the UDS you can't

1650
01:06:52,079 --> 01:06:54,270
actually inline if you compile them with

1651
01:06:54,270 --> 01:06:56,400
the LLVM what happens so this is sort of

1652
01:06:56,400 --> 01:06:57,540
ongoing research what we're exploring

1653
01:06:57,540 --> 01:07:02,460
here at carnagie mom alright so one

1654
01:07:02,460 --> 01:07:03,540
graph to show the benefit you can

1655
01:07:03,540 --> 01:07:06,059
actually get so this is running this is

1656
01:07:06,059 --> 01:07:08,099
running that same pal function on on

1657
01:07:08,099 --> 01:07:11,430
Postgres 11 and the x-axis is scaling

1658
01:07:11,430 --> 01:07:12,900
the the number times you want to iterate

1659
01:07:12,900 --> 01:07:15,480
the call and keep producing you know

1660
01:07:15,480 --> 01:07:19,260
raising the the base value so the black

1661
01:07:19,260 --> 01:07:21,299
line is with the original UDF and then

1662
01:07:21,299 --> 01:07:24,420
the red line is with the CTE and so you

1663
01:07:24,420 --> 01:07:26,730
you're getting about a roughly forty

1664
01:07:26,730 --> 01:07:28,859
forty to fifty percent performance

1665
01:07:28,859 --> 01:07:34,170
benefit over the UDF call and again from

1666
01:07:34,170 --> 01:07:36,480
this case here the for this particular

1667
01:07:36,480 --> 01:07:40,950
example there is no you know there's no

1668
01:07:40,950 --> 01:07:42,690
issues of the optimizer choosing bad

1669
01:07:42,690 --> 01:07:45,000
plans cuz because you know not knowing

1670
01:07:45,000 --> 01:07:46,829
the cardinality UDF's this is just

1671
01:07:46,829 --> 01:07:49,500
showing you the from a pure performance

1672
01:07:49,500 --> 01:07:51,450
benefit which you can get from using

1673
01:07:51,450 --> 01:07:55,020
recursive calls versus the using the UDF

1674
01:07:55,020 --> 01:07:57,299
and so where you're getting the benefit

1675
01:07:57,299 --> 01:07:58,859
is because in the case of post rest as i

1676
01:07:58,859 --> 01:08:02,730
said all the the individual lines are

1677
01:08:02,730 --> 01:08:05,640
the the commands within a UDF get

1678
01:08:05,640 --> 01:08:06,990
convert into select statements there

1679
01:08:06,990 --> 01:08:08,940
that are then sent to the parser or the

1680
01:08:08,940 --> 01:08:10,710
binder and the optimizer the core planet

1681
01:08:10,710 --> 01:08:13,049
and executed you know for every single

1682
01:08:13,049 --> 01:08:14,490
line so there's essentially for every

1683
01:08:14,490 --> 01:08:16,049
single line the UDF there are voting a

1684
01:08:16,049 --> 01:08:18,179
query and so this is showing that

1685
01:08:18,179 --> 01:08:22,020
avoiding all that overhead by being able

1686
01:08:22,020 --> 01:08:26,359
to do as a recursive CTE is a big win

1687
01:08:26,359 --> 01:08:27,559
okay

1688
01:08:27,559 --> 01:08:32,389
so as I said the these results are huge

1689
01:08:32,389 --> 01:08:34,250
in case the Freud the the Florence gains

1690
01:08:34,250 --> 01:08:36,529
are quite significant the CTE approach

1691
01:08:36,529 --> 01:08:39,469
is still very new so it's unclear how

1692
01:08:39,469 --> 01:08:40,670
much how much benefit you want to go

1693
01:08:40,670 --> 01:08:42,170
from that's polluted the early results

1694
01:08:42,170 --> 01:08:44,448
are very promising and as I said like

1695
01:08:44,448 --> 01:08:49,009
show me another example where unless

1696
01:08:49,009 --> 01:08:50,599
somebody was doing something stupid and

1697
01:08:50,599 --> 01:08:52,189
like Bitcoin mining in the middle of

1698
01:08:52,189 --> 01:08:54,319
your XP of your query engine while you

1699
01:08:54,319 --> 01:08:55,729
run queries like showing you is

1700
01:08:55,729 --> 01:08:57,408
something you can do well you'll have to

1701
01:08:57,408 --> 01:08:58,698
change anything your application and you

1702
01:08:58,698 --> 01:09:00,920
get a 500x improvement like this this is

1703
01:09:00,920 --> 01:09:04,279
quite significant and as I said the

1704
01:09:04,279 --> 01:09:07,368
another approach that we're exploring is

1705
01:09:07,368 --> 01:09:10,069
to how to compile the the UDF into

1706
01:09:10,069 --> 01:09:11,899
machine code the same way you would for

1707
01:09:11,899 --> 01:09:16,609
a query this doesn't solve the optimizer

1708
01:09:16,609 --> 01:09:18,259
cost model problem like you still need

1709
01:09:18,259 --> 01:09:21,349
to use the CTE or the Freud push to get

1710
01:09:21,349 --> 01:09:25,328
that benefit but for some computations

1711
01:09:25,328 --> 01:09:28,578
that you can't inline that actually may

1712
01:09:28,578 --> 01:09:30,349
be a better way to go but I think the

1713
01:09:30,349 --> 01:09:33,529
real end up the solution is gonna be a

1714
01:09:33,529 --> 01:09:35,299
sort of hybrid approach where sometimes

1715
01:09:35,299 --> 01:09:37,099
some Porsche me some portion of you do

1716
01:09:37,099 --> 01:09:38,359
you have to be in line another portion

1717
01:09:38,359 --> 01:09:40,670
could be cogent and how you balance all

1718
01:09:40,670 --> 01:09:41,988
that and where you make sort of the cut

1719
01:09:41,988 --> 01:09:44,630
points is is the interesting direction

1720
01:09:44,630 --> 01:09:47,779
that I want to explore okay all right

1721
01:09:47,779 --> 01:09:52,578
guys so the next week will be the last

1722
01:09:52,578 --> 01:09:55,579
lecture we have for the semester and

1723
01:09:55,579 --> 01:09:59,360
this will be sort of a reoccurring theme

1724
01:09:59,360 --> 01:10:02,929
of in databases of like what happens

1725
01:10:02,929 --> 01:10:04,789
when new harbor comes out and how can

1726
01:10:04,789 --> 01:10:06,170
you have your database system take

1727
01:10:06,170 --> 01:10:08,179
advantage of it often times when new

1728
01:10:08,179 --> 01:10:13,070
harbor comes out the now it's it's

1729
01:10:13,070 --> 01:10:14,690
machine learnings probably the hot thing

1730
01:10:14,690 --> 01:10:16,579
so there's a lot of are tailored for

1731
01:10:16,579 --> 01:10:18,440
machine learning but traditionally you

1732
01:10:18,440 --> 01:10:20,480
know as Intel or disk manufacturers or

1733
01:10:20,480 --> 01:10:22,730
whoever puts out new hardware one of the

1734
01:10:22,730 --> 01:10:25,400
the obvious targets it's gonna be

1735
01:10:25,400 --> 01:10:27,829
database systems because no one ever

1736
01:10:27,829 --> 01:10:29,119
complains that you make your data so

1737
01:10:29,119 --> 01:10:32,530
faster so for next class we want to see

1738
01:10:32,530 --> 01:10:36,469
you some of the newer this or the newer

1739
01:10:36,469 --> 01:10:38,100
data base hardware

1740
01:10:38,100 --> 01:10:44,970
sorry that's coming out in the past the

1741
01:10:44,970 --> 01:10:50,900
way we design architecture okay guys

1742
01:10:52,520 --> 01:11:21,989
[Music]

