1
00:00:03,640 --> 00:00:16,690
[Music]

2
00:00:16,690 --> 00:00:20,029
all right class and it's snowing

3
00:00:20,029 --> 00:00:24,560
did you drop tables thank you so I

4
00:00:24,560 --> 00:00:26,210
noticed you don't have your deck today

5
00:00:26,210 --> 00:00:30,800
what happened yes you had to buy her a

6
00:00:30,800 --> 00:00:35,180
gift now yeah so what'd you do

7
00:00:35,180 --> 00:00:38,960
you sold your deck yeah how you gonna

8
00:00:38,960 --> 00:00:44,989
how you to drop the beats now but this

9
00:00:44,989 --> 00:00:45,980
is getting interfere with your album now

10
00:00:45,980 --> 00:00:53,019
right how long you don't have anything

11
00:00:55,660 --> 00:01:00,140
all right well he's got his problems we

12
00:01:00,140 --> 00:01:02,149
we have database problems but this is

13
00:01:02,149 --> 00:01:04,550
the last class and as I said it's just

14
00:01:04,550 --> 00:01:05,840
gonna be the final review and then a

15
00:01:05,840 --> 00:01:07,430
system top Arif what you guys voted on

16
00:01:07,430 --> 00:01:10,430
for what you want to be talked about so

17
00:01:10,430 --> 00:01:12,140
just real quickly the remaining things

18
00:01:12,140 --> 00:01:14,150
for the semester project for is due next

19
00:01:14,150 --> 00:01:16,939
week on the 10th and it's way off when's

20
00:01:16,939 --> 00:01:18,979
the 10th is that Monday Wednesday it's

21
00:01:18,979 --> 00:01:21,229
not even close right so Tuesday December

22
00:01:21,229 --> 00:01:23,869
10th with the the final project and the

23
00:01:23,869 --> 00:01:27,229
and the extra credit will be due we

24
00:01:27,229 --> 00:01:30,020
promised you feedback we found people

25
00:01:30,020 --> 00:01:32,030
plagiarizing so we have to deal with

26
00:01:32,030 --> 00:01:34,189
that first and then we'll hopefully be

27
00:01:34,189 --> 00:01:37,159
able to put out the reviews for the

28
00:01:37,159 --> 00:01:39,229
feedback for everyone else within like

29
00:01:39,229 --> 00:01:40,490
the next day or so okay

30
00:01:40,490 --> 00:01:43,040
so apologize for the delay overall they

31
00:01:43,040 --> 00:01:44,299
were pretty good some are better than

32
00:01:44,299 --> 00:01:46,820
others obviously but the feedback will

33
00:01:46,820 --> 00:01:52,700
help guide you to finish it up yes so

34
00:01:52,700 --> 00:01:54,170
you remember how when you filled out the

35
00:01:54,170 --> 00:01:55,729
form you know click the check box yes I

36
00:01:55,729 --> 00:01:58,219
agree I'm not gonna play dries big they

37
00:01:58,219 --> 00:01:58,909
still plagiarize

38
00:01:58,909 --> 00:02:05,750
yes well the very least zero where I go

39
00:02:05,750 --> 00:02:07,820
talk to the Provos or not that's another

40
00:02:07,820 --> 00:02:08,300
story

41
00:02:08,300 --> 00:02:12,020
yeah again Seema does around they take

42
00:02:12,020 --> 00:02:13,820
this seriously and the fact that I made

43
00:02:13,820 --> 00:02:15,500
you check click that check box and it's

44
00:02:15,500 --> 00:02:17,209
on video saying me saying don't

45
00:02:17,209 --> 00:02:19,099
plagiarize you don't have any evidence

46
00:02:19,099 --> 00:02:20,390
if

47
00:02:20,390 --> 00:02:22,310
not you understand whoever did it yeah

48
00:02:22,310 --> 00:02:24,400
yeah

49
00:02:24,400 --> 00:02:28,070
and then the final exam is due on a

50
00:02:28,070 --> 00:02:30,140
monday december not after you going back

51
00:02:30,140 --> 00:02:31,820
to X credit this is why we have it's

52
00:02:31,820 --> 00:02:33,380
like a wiki stylus we have revisions so

53
00:02:33,380 --> 00:02:34,790
the person could go back and try to

54
00:02:34,790 --> 00:02:38,420
remove the the plagiarized e-text but

55
00:02:38,420 --> 00:02:39,770
it's still in the Davis we can go see

56
00:02:39,770 --> 00:02:41,930
always go see it anyway again not you

57
00:02:41,930 --> 00:02:44,180
but in general all right final exam is

58
00:02:44,180 --> 00:02:48,440
on Monday at 5:30 p.m. in posner hall i

59
00:02:48,440 --> 00:02:50,570
which i think is over there the old

60
00:02:50,570 --> 00:02:54,110
business school yeah so that so we'll

61
00:02:54,110 --> 00:02:55,850
cover that first okay so any questions

62
00:02:55,850 --> 00:02:57,500
about the extra credit or project for

63
00:02:57,500 --> 00:03:01,550
and then for homework five we will have

64
00:03:01,550 --> 00:03:04,130
that graded and released by Friday

65
00:03:04,130 --> 00:03:05,780
whatever I think he was due yesterday so

66
00:03:05,780 --> 00:03:07,850
four days after that unless everyone has

67
00:03:07,850 --> 00:03:09,290
already turned them in we'll send it out

68
00:03:09,290 --> 00:03:12,890
okay all right

69
00:03:12,890 --> 00:03:15,980
the final exam all right so you have to

70
00:03:15,980 --> 00:03:18,950
take it uh or you don't have to but you

71
00:03:18,950 --> 00:03:21,709
should this is not Bob yet but I'll post

72
00:03:21,709 --> 00:03:24,350
this after class this will be basically

73
00:03:24,350 --> 00:03:26,030
a summary of everything that I've talked

74
00:03:26,030 --> 00:03:27,950
about like it's the the same thing I did

75
00:03:27,950 --> 00:03:29,900
for the midterm it's like the sheet of

76
00:03:29,900 --> 00:03:30,890
everything you need to know what

77
00:03:30,890 --> 00:03:32,060
chapters in the book what homeworks

78
00:03:32,060 --> 00:03:33,980
matter and things like that

79
00:03:33,980 --> 00:03:36,380
again posner hall 100 at 5:30 p.m. don't

80
00:03:36,380 --> 00:03:37,700
come to this room and then if you're

81
00:03:37,700 --> 00:03:39,530
curious why you should take this other

82
00:03:39,530 --> 00:03:40,910
than you want to pass the class you can

83
00:03:40,910 --> 00:03:43,940
watch that video all right so what do

84
00:03:43,940 --> 00:03:46,040
you need to bring you should bring your

85
00:03:46,040 --> 00:03:48,080
CMU ID because it's Class of 95 people

86
00:03:48,080 --> 00:03:49,459
or 96 people I don't know I know

87
00:03:49,459 --> 00:03:52,250
everyone so I need to check your ID this

88
00:03:52,250 --> 00:03:54,170
like the midterm it's one page of

89
00:03:54,170 --> 00:03:56,690
handwritten notes double-sided no

90
00:03:56,690 --> 00:03:58,550
shrinking down the slides no copy and

91
00:03:58,550 --> 00:04:00,380
pasting attacks if you write it by hand

92
00:04:00,380 --> 00:04:02,600
on your iPad won't print that that's

93
00:04:02,600 --> 00:04:05,360
okay but again just know like text text

94
00:04:05,360 --> 00:04:08,269
right from a word processor and then if

95
00:04:08,269 --> 00:04:10,370
you were in the class last night on

96
00:04:10,370 --> 00:04:12,850
Monday bring your extra credit coupon

97
00:04:12,850 --> 00:04:15,140
and you have to turn that in when you

98
00:04:15,140 --> 00:04:18,019
when you turn in your exam so the thing

99
00:04:18,019 --> 00:04:19,250
is you optional if you want to change

100
00:04:19,250 --> 00:04:20,690
your clothes halfway through somebody

101
00:04:20,690 --> 00:04:22,040
did that two years ago I'm fine with

102
00:04:22,040 --> 00:04:24,979
that because also it's at 5:30 uh you

103
00:04:24,979 --> 00:04:26,720
could bring food I think there's will

104
00:04:26,720 --> 00:04:27,979
give up candy I'll try to do something

105
00:04:27,979 --> 00:04:29,720
better than that but don't you know I

106
00:04:29,720 --> 00:04:31,039
can't can't promise anything right it's

107
00:04:31,039 --> 00:04:32,210
not gonna be a full four-course meal

108
00:04:32,210 --> 00:04:34,310
before the exam

109
00:04:34,310 --> 00:04:36,440
what not to bring again I think we

110
00:04:36,440 --> 00:04:37,520
talked about all the problems on the

111
00:04:37,520 --> 00:04:39,140
midterm everyone brought weird stuff in

112
00:04:39,140 --> 00:04:41,570
previous years two years ago again so

113
00:04:41,570 --> 00:04:43,550
when you brought the roommate just to

114
00:04:43,550 --> 00:04:47,210
hang out don't do that okay all right

115
00:04:47,210 --> 00:04:49,460
before we get into the the course

116
00:04:49,460 --> 00:04:50,950
material for that for the for the exam

117
00:04:50,950 --> 00:04:54,340
yes sorry go ahead

118
00:04:54,670 --> 00:04:57,320
is that what pH means all right then

119
00:04:57,320 --> 00:04:59,300
yeah I did whatever that is yes hey

120
00:04:59,300 --> 00:05:01,370
where's Porter Hall oh that's the one

121
00:05:01,370 --> 00:05:03,470
over there yeah if it's not gates I

122
00:05:03,470 --> 00:05:04,700
don't know where it is right I'll be

123
00:05:04,700 --> 00:05:08,510
honest that this is my seventh year okay

124
00:05:08,510 --> 00:05:13,040
so right so the announcer some Piazza as

125
00:05:13,040 --> 00:05:15,410
well I need everyone to fill out the

126
00:05:15,410 --> 00:05:17,390
course evaluations I don't care whether

127
00:05:17,390 --> 00:05:18,980
you say I'm an awful person I have bad

128
00:05:18,980 --> 00:05:20,510
hygiene or you hate the class that

129
00:05:20,510 --> 00:05:23,870
actually is useful to me I you know I

130
00:05:23,870 --> 00:05:25,790
actually read these things so the things

131
00:05:25,790 --> 00:05:26,750
that I mentioned in getting feedback

132
00:05:26,750 --> 00:05:29,180
from or like was the particular mark

133
00:05:29,180 --> 00:05:30,440
assignment you thought was unnecessary

134
00:05:30,440 --> 00:05:32,870
or stupid anything about the projects

135
00:05:32,870 --> 00:05:35,150
you've seen my announcement of Piazza

136
00:05:35,150 --> 00:05:35,960
that we're looking for people to help

137
00:05:35,960 --> 00:05:39,110
with expanding bust hub further you know

138
00:05:39,110 --> 00:05:40,430
fixing all the things and maybe went

139
00:05:40,430 --> 00:05:42,650
wrong this semester but if there's again

140
00:05:42,650 --> 00:05:43,670
something about the project that you

141
00:05:43,670 --> 00:05:45,110
thought was too hard the pacing was not

142
00:05:45,110 --> 00:05:46,940
right you wanted more documentation less

143
00:05:46,940 --> 00:05:48,230
documentation into that was too easy too

144
00:05:48,230 --> 00:05:50,150
hard again that feedback is actually

145
00:05:50,150 --> 00:05:52,460
super useful to me all right so

146
00:05:52,460 --> 00:05:55,370
undergrads are awesome at at filling out

147
00:05:55,370 --> 00:05:57,110
course evaluations like if your stinks

148
00:05:57,110 --> 00:05:59,180
they'll tell you the master students you

149
00:05:59,180 --> 00:06:00,740
guys you guys to click five five five

150
00:06:00,740 --> 00:06:02,450
five on everything and he's the great

151
00:06:02,450 --> 00:06:04,130
professor I don't want any that the

152
00:06:04,130 --> 00:06:06,560
right just like I actually read this the

153
00:06:06,560 --> 00:06:07,880
university apparently reads it to I

154
00:06:07,880 --> 00:06:09,560
don't care about them but I actually

155
00:06:09,560 --> 00:06:10,760
make the course better based on your

156
00:06:10,760 --> 00:06:12,920
feedback right one year a kids

157
00:06:12,920 --> 00:06:14,630
psychoanalyze me with a Myer Briggs test

158
00:06:14,630 --> 00:06:18,200
in the feedback that was useful so again

159
00:06:18,200 --> 00:06:19,820
please go for the cell and I'll send a

160
00:06:19,820 --> 00:06:22,910
reminder on Piazza all right so I didn't

161
00:06:22,910 --> 00:06:25,190
have office hours on Monday but I'll

162
00:06:25,190 --> 00:06:26,720
have office hours extra office hours

163
00:06:26,720 --> 00:06:29,540
this Friday at 3:30 in my office and

164
00:06:29,540 --> 00:06:30,830
then I'll have my regular office hours

165
00:06:30,830 --> 00:06:34,460
at 1:30 on the day of the exam if you

166
00:06:34,460 --> 00:06:35,780
can't make either of these and you're

167
00:06:35,780 --> 00:06:37,310
dying to talk to me please send me an

168
00:06:37,310 --> 00:06:38,660
email and I'll try to make arrangements

169
00:06:38,660 --> 00:06:40,790
I may have to like do it over Skype or

170
00:06:40,790 --> 00:06:43,310
hangouts because because of the thing

171
00:06:43,310 --> 00:06:46,400
the baby and then all the TAS will have

172
00:06:46,400 --> 00:06:47,180
the regular office

173
00:06:47,180 --> 00:06:48,949
hours up until and including September

174
00:06:48,949 --> 00:06:52,009
December 14th right so the due date for

175
00:06:52,009 --> 00:06:54,979
the project for is on the 10th they're

176
00:06:54,979 --> 00:06:56,840
gonna get for late days so it'll go out

177
00:06:56,840 --> 00:07:00,440
into the 14th ok any questions about

178
00:07:00,440 --> 00:07:04,250
office hour stuff alright so this always

179
00:07:04,250 --> 00:07:05,660
comes up every year what do you need to

180
00:07:05,660 --> 00:07:08,570
know from before the midterm so the exam

181
00:07:08,570 --> 00:07:10,039
is not cumulative meaning like I'm not

182
00:07:10,039 --> 00:07:11,300
gonna ask you questions specifically

183
00:07:11,300 --> 00:07:13,340
about like buffer pools right you know

184
00:07:13,340 --> 00:07:14,840
what how does this eviction policy work

185
00:07:14,840 --> 00:07:16,910
but you obviously didn't know you know

186
00:07:16,910 --> 00:07:18,680
it's a part of a database system we've

187
00:07:18,680 --> 00:07:20,000
covered through the full stack you need

188
00:07:20,000 --> 00:07:21,229
to know how all these different pieces

189
00:07:21,229 --> 00:07:23,599
work together so the things that you

190
00:07:23,599 --> 00:07:24,910
have to know about from the previous

191
00:07:24,910 --> 00:07:27,410
prior to the term would be the buffer

192
00:07:27,410 --> 00:07:28,699
management hash tables B plus trees

193
00:07:28,699 --> 00:07:31,070
short models and then enter a query

194
00:07:31,070 --> 00:07:32,960
parallelism which is again running

195
00:07:32,960 --> 00:07:34,370
multiple queries at the same time and

196
00:07:34,370 --> 00:07:35,479
you obviously didn't know how that works

197
00:07:35,479 --> 00:07:37,220
because you have to do transactions I

198
00:07:37,220 --> 00:07:38,240
could be updating the database at the

199
00:07:38,240 --> 00:07:41,210
same time ok so this is clear we're not

200
00:07:41,210 --> 00:07:43,070
asking you separate questions like in

201
00:07:43,070 --> 00:07:44,419
the earlier homeworks before the midterm

202
00:07:44,419 --> 00:07:45,979
but this is background knowledge that

203
00:07:45,979 --> 00:07:47,479
you just you know if you forgot this

204
00:07:47,479 --> 00:07:51,409
already you have other problems ok all

205
00:07:51,409 --> 00:07:52,820
right so the main thing we spent time

206
00:07:52,820 --> 00:07:54,500
talking about was about transactions

207
00:07:54,500 --> 00:07:56,449
right you should be aware of what the

208
00:07:56,449 --> 00:07:59,389
basic concept of acid were the different

209
00:07:59,389 --> 00:08:01,310
properties that are combined in the

210
00:08:01,310 --> 00:08:02,900
acronym and what the data's meant is

211
00:08:02,900 --> 00:08:05,900
supposed to provide then we did a we

212
00:08:05,900 --> 00:08:06,680
talked about the difference between

213
00:08:06,680 --> 00:08:08,389
conflicts their lives be and view sort

214
00:08:08,389 --> 00:08:10,010
of eyes ability number of you sterilized

215
00:08:10,010 --> 00:08:11,479
ability nobody can actually do so

216
00:08:11,479 --> 00:08:12,740
there's no way to actually check this

217
00:08:12,740 --> 00:08:14,840
it's just a higher level concept but for

218
00:08:14,840 --> 00:08:16,370
conflicts their lives ability you want

219
00:08:16,370 --> 00:08:18,110
to know how to check this and how the

220
00:08:18,110 --> 00:08:19,880
data system can ensure that it generates

221
00:08:19,880 --> 00:08:23,090
a schedule for you know that's

222
00:08:23,090 --> 00:08:27,050
guaranteed we conflict serializable what

223
00:08:27,050 --> 00:08:28,340
it means to have a recoverable schedule

224
00:08:28,340 --> 00:08:29,840
right amazing basically means no

225
00:08:29,840 --> 00:08:32,570
cascading aborts and then isolation

226
00:08:32,570 --> 00:08:34,760
levels and the anomalies write dirty

227
00:08:34,760 --> 00:08:39,880
reads on repeatable reads and phantoms

228
00:08:41,659 --> 00:08:44,870
then we talk about concurrent protocols

229
00:08:44,870 --> 00:08:46,910
to actually generate schedules on the

230
00:08:46,910 --> 00:08:50,450
fly for arbitrary transactions that are

231
00:08:50,450 --> 00:08:52,430
conflicts are reliable so we spent a

232
00:08:52,430 --> 00:08:54,080
whole class talking about two things

233
00:08:54,080 --> 00:08:55,940
locking shows you know what the basic

234
00:08:55,940 --> 00:08:57,530
protocol is but the difference between

235
00:08:57,530 --> 00:08:59,320
the non rigorous and rigorous one is

236
00:08:59,320 --> 00:09:01,640
what's the difference what is rigorous

237
00:09:01,640 --> 00:09:08,080
two phase locking mean in the back yes

238
00:09:08,080 --> 00:09:10,970
thanks Matt yeah so rigorous is you've

239
00:09:10,970 --> 00:09:12,080
released all the locks at the end there

240
00:09:12,080 --> 00:09:14,690
is no shrinking phase regular two-phase

241
00:09:14,690 --> 00:09:15,080
locking

242
00:09:15,080 --> 00:09:16,610
soon as you release one block then

243
00:09:16,610 --> 00:09:17,600
you're now in the shrinking phase and

244
00:09:17,600 --> 00:09:20,960
you can't acquire any new locks then we

245
00:09:20,960 --> 00:09:22,540
talked about multiple granite multiple

246
00:09:22,540 --> 00:09:25,730
mostly granularity in locking right and

247
00:09:25,730 --> 00:09:26,780
the big thing there was the intention

248
00:09:26,780 --> 00:09:30,620
box right how do I notify or how do I

249
00:09:30,620 --> 00:09:32,870
post information about what I'm gonna do

250
00:09:32,870 --> 00:09:34,280
at the lower levels of the lock

251
00:09:34,280 --> 00:09:36,350
hierarchy in the upper level so I don't

252
00:09:36,350 --> 00:09:37,750
have to take me locks on everything

253
00:09:37,750 --> 00:09:40,220
right if I have to take a lock on if I

254
00:09:40,220 --> 00:09:42,260
want a go and update a billion tuples

255
00:09:42,260 --> 00:09:44,960
and my tables at billion turbos I better

256
00:09:44,960 --> 00:09:46,460
up just taking a single lock on the

257
00:09:46,460 --> 00:09:48,530
table rather than locking every single

258
00:09:48,530 --> 00:09:51,170
individual tuple and then important to

259
00:09:51,170 --> 00:09:53,720
know how you release these locks like in

260
00:09:53,720 --> 00:09:57,280
what order is it top down or bottom up

261
00:09:57,280 --> 00:09:59,630
then we spent a lecture on talking about

262
00:09:59,630 --> 00:10:00,760
timestamp order and concurrency control

263
00:10:00,760 --> 00:10:03,110
alright so you know what the Thomas

264
00:10:03,110 --> 00:10:04,640
Wright rule is the base of protocol that

265
00:10:04,640 --> 00:10:06,590
we talked about then we spent time

266
00:10:06,590 --> 00:10:08,000
talking my optimistic a country toll

267
00:10:08,000 --> 00:10:10,040
what are the three phases read phase

268
00:10:10,040 --> 00:10:12,740
validation phase and write phase when do

269
00:10:12,740 --> 00:10:14,210
we actually acquire a timestamp for

270
00:10:14,210 --> 00:10:16,330
transaction in these different protocols

271
00:10:16,330 --> 00:10:18,500
in the basic time stamp ordering what

272
00:10:18,500 --> 00:10:22,640
when you get a timestamp when the

273
00:10:22,640 --> 00:10:25,040
transaction starts in optimistic control

274
00:10:25,040 --> 00:10:29,420
when you get a timestamp with that when

275
00:10:29,420 --> 00:10:30,680
you validate yes when you finish the

276
00:10:30,680 --> 00:10:32,840
write the read phase then we talk about

277
00:10:32,840 --> 00:10:34,730
multi-version concurrency toll I'm not

278
00:10:34,730 --> 00:10:37,370
gonna worry so much about the again the

279
00:10:37,370 --> 00:10:39,470
the commercial protocol of that you

280
00:10:39,470 --> 00:10:42,140
would use in MVCC like either you know

281
00:10:42,140 --> 00:10:45,170
mb to PL or MV OCC I'm more care about

282
00:10:45,170 --> 00:10:47,210
the virgin storage and the ordering of

283
00:10:47,210 --> 00:10:49,190
the Delta records are doing the pen only

284
00:10:49,190 --> 00:10:50,810
or you're doing the time travel tables

285
00:10:50,810 --> 00:10:52,100
and then how you want to do garbage

286
00:10:52,100 --> 00:10:54,400
collection

287
00:10:56,019 --> 00:10:57,829
then we spend all the time talking about

288
00:10:57,829 --> 00:11:06,649
crash recovery question yes right so the

289
00:11:06,649 --> 00:11:09,769
isolation levels again it's uh it's it's

290
00:11:09,769 --> 00:11:11,599
sort of a the very top you have

291
00:11:11,599 --> 00:11:13,579
serializable isolation and then below

292
00:11:13,579 --> 00:11:15,859
that you have repeatable read below that

293
00:11:15,859 --> 00:11:17,599
you have read committed and below that

294
00:11:17,599 --> 00:11:19,549
you have uncommitted read and so

295
00:11:19,549 --> 00:11:21,499
basically as you go down that hierarchy

296
00:11:21,499 --> 00:11:24,889
the the database system is not enforcing

297
00:11:24,889 --> 00:11:27,079
or protecting you from different

298
00:11:27,079 --> 00:11:28,579
entities certain kind of all not

299
00:11:28,579 --> 00:11:30,709
anomalies so if your see reliable

300
00:11:30,709 --> 00:11:33,199
isolation then you don't have phantoms

301
00:11:33,199 --> 00:11:34,339
you don't have dirty reads and you don't

302
00:11:34,339 --> 00:11:36,289
have unrepeatable reads but then if you

303
00:11:36,289 --> 00:11:39,679
go down to repeatable read then you're

304
00:11:39,679 --> 00:11:41,509
not gonna do phantom checking if you go

305
00:11:41,509 --> 00:11:43,729
down to be committed now you're not

306
00:11:43,729 --> 00:11:47,419
doing now you're not doing on repeatable

307
00:11:47,419 --> 00:11:50,629
reads and then read uncommitted read or

308
00:11:50,629 --> 00:11:52,689
read uncommitted is is no protections

309
00:11:52,689 --> 00:11:58,819
yes so session is it's not actually when

310
00:11:58,819 --> 00:12:00,619
we love us snapshot isolation is a weird

311
00:12:00,619 --> 00:12:06,339
one it is it's almost a throg '''l to

312
00:12:06,339 --> 00:12:08,569
some answers no it's not in that main

313
00:12:08,569 --> 00:12:10,939
hierarchy if you take the advanced class

314
00:12:10,939 --> 00:12:12,139
we'll discuss a bit further but

315
00:12:12,139 --> 00:12:14,599
basically in 1992 when they invented

316
00:12:14,599 --> 00:12:16,609
when they came up the ANSI standard for

317
00:12:16,609 --> 00:12:19,009
these isolation levels the guy that was

318
00:12:19,009 --> 00:12:20,869
supposed to double check the other guy

319
00:12:20,869 --> 00:12:22,639
didn't double check that they missed

320
00:12:22,639 --> 00:12:24,499
snapshot isolation so there's an anomaly

321
00:12:24,499 --> 00:12:26,689
that can occur on our staffs isolation

322
00:12:26,689 --> 00:12:29,899
that the that cannot occur the other

323
00:12:29,899 --> 00:12:32,419
ones and but the ANSI standard doesn't

324
00:12:32,419 --> 00:12:33,949
support it you don't the worry about

325
00:12:33,949 --> 00:12:36,229
that just go with the ANSI standards so

326
00:12:36,229 --> 00:12:38,449
serializable repeat or read read

327
00:12:38,449 --> 00:12:40,369
committed uncommitted reads read

328
00:12:40,369 --> 00:12:42,489
uncommitted

329
00:12:45,099 --> 00:12:50,059
yes natural isolation is a it's not a

330
00:12:50,059 --> 00:12:51,979
straight hierarchy the tree actually way

331
00:12:51,979 --> 00:12:53,449
more complicated but we'll cover that

332
00:12:53,449 --> 00:12:54,619
meet in the advanced class if you take

333
00:12:54,619 --> 00:12:56,629
that the auntie ones are fine for the

334
00:12:56,629 --> 00:12:59,479
for the final exam alright so we talked

335
00:12:59,479 --> 00:13:02,059
about crash recovery we talked about the

336
00:13:02,059 --> 00:13:03,829
different puffer hole policies steel

337
00:13:03,829 --> 00:13:07,959
versus no steel what a steel mean

338
00:13:10,870 --> 00:13:17,600
yes she said so with this new policy

339
00:13:17,600 --> 00:13:19,970
means that a the data says was allowed

340
00:13:19,970 --> 00:13:22,190
to write dirty records or dirty pages

341
00:13:22,190 --> 00:13:23,930
out the disk from uncommitted

342
00:13:23,930 --> 00:13:26,000
transaction under no steal you're not

343
00:13:26,000 --> 00:13:28,640
allowed to do that and enforces no force

344
00:13:28,640 --> 00:13:37,580
somebody other than Paulina correct so

345
00:13:37,580 --> 00:13:39,230
she said you have to write all you have

346
00:13:39,230 --> 00:13:41,740
to write all dirty records out to disk

347
00:13:41,740 --> 00:13:44,000
before transactions allowed to be saying

348
00:13:44,000 --> 00:13:46,130
that it's committed and then under no

349
00:13:46,130 --> 00:13:47,630
force you don't have to do that

350
00:13:47,630 --> 00:13:49,760
so with write ahead logging is it using

351
00:13:49,760 --> 00:13:54,590
steal versus versus no steal just no

352
00:13:54,590 --> 00:13:56,390
steal no it's already using steal wrong

353
00:13:56,390 --> 00:13:58,610
right because the words right ahead

354
00:13:58,610 --> 00:14:00,620
logging I have to make sure that the log

355
00:14:00,620 --> 00:14:03,020
records that correspond to the changes

356
00:14:03,020 --> 00:14:05,300
to the data the data pages the log

357
00:14:05,300 --> 00:14:07,010
records have to be written to disk but

358
00:14:07,010 --> 00:14:08,300
for my transactions a lot of commits but

359
00:14:08,300 --> 00:14:10,850
I'm allowed to at some later point write

360
00:14:10,850 --> 00:14:13,250
out the the dirty records you know after

361
00:14:13,250 --> 00:14:14,570
the transactions already committed which

362
00:14:14,570 --> 00:14:19,880
means that it's also no force we talked

363
00:14:19,880 --> 00:14:21,530
about different logging schemes the main

364
00:14:21,530 --> 00:14:23,780
distinction I care about is logical

365
00:14:23,780 --> 00:14:26,600
versus physical my physical is where

366
00:14:26,600 --> 00:14:29,120
you're actually writing out the the the

367
00:14:29,120 --> 00:14:31,940
low-level bits or bytes that got changed

368
00:14:31,940 --> 00:14:33,140
to the database system in your log

369
00:14:33,140 --> 00:14:35,330
records and then logical log and you're

370
00:14:35,330 --> 00:14:36,920
just writing a high-level command that

371
00:14:36,920 --> 00:14:38,510
made the change so like the sequel query

372
00:14:38,510 --> 00:14:40,130
and so there's trade-offs are these

373
00:14:40,130 --> 00:14:41,780
things right so if my query is gonna

374
00:14:41,780 --> 00:14:44,270
update a billion tuples with logical

375
00:14:44,270 --> 00:14:45,470
logging all I have to have is that

376
00:14:45,470 --> 00:14:47,210
update query in a single log record and

377
00:14:47,210 --> 00:14:49,430
that'll battle that's enough information

378
00:14:49,430 --> 00:14:51,260
for me to record what change that made

379
00:14:51,260 --> 00:14:53,720
under physical logging I have to have a

380
00:14:53,720 --> 00:14:55,820
billion log records that correspond all

381
00:14:55,820 --> 00:14:58,630
the change I made to every single tuple

382
00:14:58,630 --> 00:15:00,590
then we talked about how do you check

383
00:15:00,590 --> 00:15:02,360
points so you should know about the sort

384
00:15:02,360 --> 00:15:04,610
of the difference between the fuzzy

385
00:15:04,610 --> 00:15:07,100
versus non fuzzy right

386
00:15:07,100 --> 00:15:09,290
fuzzy means that I'm allowed to write

387
00:15:09,290 --> 00:15:11,480
out inconsistent data to the database

388
00:15:11,480 --> 00:15:13,490
system or to the disk when I'm taking

389
00:15:13,490 --> 00:15:15,530
the check point but I need to know what

390
00:15:15,530 --> 00:15:17,930
was going on at the time in my system

391
00:15:17,930 --> 00:15:19,880
when I when I'm taking the check point

392
00:15:19,880 --> 00:15:22,970
that I can reconcile after recovery what

393
00:15:22,970 --> 00:15:24,500
pages may or may not gotten written

394
00:15:24,500 --> 00:15:26,389
during the checkpoint or may have been

395
00:15:26,389 --> 00:15:27,500
modified while I was taking the

396
00:15:27,500 --> 00:15:30,620
checkpoint right in the in the non fuzzy

397
00:15:30,620 --> 00:15:31,490
checkpoint case they're basically

398
00:15:31,490 --> 00:15:33,500
stopping the world for a brief period

399
00:15:33,500 --> 00:15:35,779
while you write everything out so that

400
00:15:35,779 --> 00:15:36,560
way you're guaranteed to have a

401
00:15:36,560 --> 00:15:40,009
consistent check line and then we talked

402
00:15:40,009 --> 00:15:41,120
about her new areas recovery for a

403
00:15:41,120 --> 00:15:43,060
lecture right what are the three phases

404
00:15:43,060 --> 00:15:45,589
like the analyze the redo and the undo

405
00:15:45,589 --> 00:15:47,959
shows you know how far back in the log

406
00:15:47,959 --> 00:15:49,790
you need to look at for each of those

407
00:15:49,790 --> 00:15:52,699
phases potentially right it should know

408
00:15:52,699 --> 00:15:54,740
about the conversation log records when

409
00:15:54,740 --> 00:15:58,639
you write them when you read them right

410
00:15:58,639 --> 00:16:00,889
if I have a compensation log record in

411
00:16:00,889 --> 00:16:02,509
my log and I apply it but then I crash

412
00:16:02,509 --> 00:16:04,339
before I you know finish my recovery

413
00:16:04,339 --> 00:16:06,230
when I come back around the second time

414
00:16:06,230 --> 00:16:07,819
do I need to make another CLR for that

415
00:16:07,819 --> 00:16:12,290
first one no right because you've

416
00:16:12,290 --> 00:16:13,970
already done it the CLR has information

417
00:16:13,970 --> 00:16:15,709
to tell you how to how to undo the

418
00:16:15,709 --> 00:16:21,800
original update all right and then we

419
00:16:21,800 --> 00:16:22,880
briefly talked about distributed

420
00:16:22,880 --> 00:16:26,389
databases you know that we can't

421
00:16:26,389 --> 00:16:29,209
obviously go real deep into this beyond

422
00:16:29,209 --> 00:16:30,740
what was what was covered in homework 5

423
00:16:30,740 --> 00:16:32,240
so this you know about the different

424
00:16:32,240 --> 00:16:33,410
system architectures we talked about

425
00:16:33,410 --> 00:16:35,420
shared everything share discs shared

426
00:16:35,420 --> 00:16:37,459
memory shared nothing what are the

427
00:16:37,459 --> 00:16:39,529
trade-offs for these or when would one

428
00:16:39,529 --> 00:16:41,839
be better than another how did we

429
00:16:41,839 --> 00:16:43,100
actually gonna do replication and in

430
00:16:43,100 --> 00:16:44,120
these different environments at the ship

431
00:16:44,120 --> 00:16:46,069
an environment how do we make sure that

432
00:16:46,069 --> 00:16:48,110
the the database system is fault

433
00:16:48,110 --> 00:16:49,250
tolerant how to make sure that database

434
00:16:49,250 --> 00:16:50,630
system if we're making updates is

435
00:16:50,630 --> 00:16:52,850
consistent across all the copies of the

436
00:16:52,850 --> 00:16:56,329
data how we do partitioning again high

437
00:16:56,329 --> 00:16:57,980
level things you know we talk about hash

438
00:16:57,980 --> 00:16:59,630
partitioning what are the benefits of

439
00:16:59,630 --> 00:17:01,250
them how to actually find the data you

440
00:17:01,250 --> 00:17:05,059
need and then two-phase commit you know

441
00:17:05,059 --> 00:17:07,400
under what circumstances you know at

442
00:17:07,400 --> 00:17:08,390
what steps would you do at different

443
00:17:08,390 --> 00:17:10,819
phases of the protocol don't worry about

444
00:17:10,819 --> 00:17:13,490
Paxos that's too hard for for final exam

445
00:17:13,490 --> 00:17:18,530
in gay basis okay so any questions about

446
00:17:18,530 --> 00:17:20,860
the fire

447
00:17:20,930 --> 00:17:22,670
to sweeten the deal I forgot to announce

448
00:17:22,670 --> 00:17:24,319
this earlier if you take the final exam

449
00:17:24,319 --> 00:17:26,329
when you turn it in I will give you a

450
00:17:26,329 --> 00:17:28,220
bust tub sticker you can put on your

451
00:17:28,220 --> 00:17:31,240
laptop okay we have enough for everyone

452
00:17:31,240 --> 00:17:37,190
yes this question is what is the

453
00:17:37,190 --> 00:17:39,500
duration of the exam it will be the same

454
00:17:39,500 --> 00:17:41,960
as the midterm but you have three hours

455
00:17:41,960 --> 00:17:43,730
and there's always somebody who takes

456
00:17:43,730 --> 00:17:55,550
three hours yeah yes yes yes who

457
00:17:55,550 --> 00:17:56,390
questions question is will they be

458
00:17:56,390 --> 00:17:58,610
present yes when I post the review guide

459
00:17:58,610 --> 00:18:01,370
I will post a same way I did in the

460
00:18:01,370 --> 00:18:04,480
midterm I post the practical exam yes

461
00:18:04,480 --> 00:18:07,940
these will be my own choice yes it's

462
00:18:07,940 --> 00:18:18,890
easier to grade yes all right so this

463
00:18:18,890 --> 00:18:20,030
question is I made the distinction

464
00:18:20,030 --> 00:18:21,290
between force versus no force or

465
00:18:21,290 --> 00:18:23,030
Gilbertson no steel would there be a

466
00:18:23,030 --> 00:18:25,010
case where you would have won like women

467
00:18:25,010 --> 00:18:30,410
you won't want to use one so no I think

468
00:18:30,410 --> 00:18:32,090
you have to be one you have to be sort

469
00:18:32,090 --> 00:18:34,429
of like steel no force or no steel force

470
00:18:34,429 --> 00:18:35,480
right we talked about shadow paging

471
00:18:35,480 --> 00:18:38,780
shadow paging was an example of no steel

472
00:18:38,780 --> 00:18:41,030
force because I wasn't allowed to over

473
00:18:41,030 --> 00:18:43,190
write dirty pages from uncommitted

474
00:18:43,190 --> 00:18:45,710
transactions because I had this shadow

475
00:18:45,710 --> 00:18:47,150
copy on the side I was making all my

476
00:18:47,150 --> 00:18:50,120
updates there right so that's that's

477
00:18:50,120 --> 00:18:52,190
that's the no steal part and then the

478
00:18:52,190 --> 00:18:54,140
fourth part is when my transaction went

479
00:18:54,140 --> 00:18:56,000
to kokum it with shadow paging I had to

480
00:18:56,000 --> 00:18:57,440
make sure all those dirty pages were

481
00:18:57,440 --> 00:18:59,630
flush to disk and then I flipped the

482
00:18:59,630 --> 00:19:01,429
pointer the root pointer to now you know

483
00:19:01,429 --> 00:19:04,070
point to the the old the new the shadow

484
00:19:04,070 --> 00:19:05,960
becomes the new master when I do that I

485
00:19:05,960 --> 00:19:06,710
make sure I have to make sure

486
00:19:06,710 --> 00:19:08,840
everything's all have already flushed so

487
00:19:08,840 --> 00:19:11,179
again write ahead logging is steel no

488
00:19:11,179 --> 00:19:14,080
force shadow paging is no steel force

489
00:19:14,080 --> 00:19:18,500
and then the the the main takeaway was

490
00:19:18,500 --> 00:19:21,650
that the red head logging it is almost

491
00:19:21,650 --> 00:19:24,590
always I can't think of maybe some cases

492
00:19:24,590 --> 00:19:25,820
I haven't thought of it it's almost

493
00:19:25,820 --> 00:19:28,760
always better and it's what every system

494
00:19:28,760 --> 00:19:32,830
uses most systems

495
00:19:34,470 --> 00:19:41,830
any other questions yes yes so this

496
00:19:41,830 --> 00:19:43,330
question is unlike the midterm do I not

497
00:19:43,330 --> 00:19:44,020
need a calculator

498
00:19:44,020 --> 00:19:46,690
I forgot to highlight that yes you do

499
00:19:46,690 --> 00:19:48,610
not you don't need it I can think of

500
00:19:48,610 --> 00:19:49,960
what we did in the homeworks we didn't

501
00:19:49,960 --> 00:19:54,790
estimate joins we didn't yeah I don't

502
00:19:54,790 --> 00:19:59,020
think it like it live is that there we

503
00:19:59,020 --> 00:20:00,340
no questions on like query optimization

504
00:20:00,340 --> 00:20:02,440
stuff that's the only thing I can think

505
00:20:02,440 --> 00:20:04,870
of may need a calculator right say don't

506
00:20:04,870 --> 00:20:09,429
worry about that you know the questions

507
00:20:09,429 --> 00:20:19,780
yes like two phase locking stuff or

508
00:20:19,780 --> 00:20:25,030
about the hierarchy yes sir so her

509
00:20:25,030 --> 00:20:26,230
question is are there more questions

510
00:20:26,230 --> 00:20:28,750
about like multi granular granularity

511
00:20:28,750 --> 00:20:33,309
locking so so in in the in the textbook

512
00:20:33,309 --> 00:20:36,040
all the odd problems the solutions are

513
00:20:36,040 --> 00:20:38,080
online I haven't looked at I haven't

514
00:20:38,080 --> 00:20:39,070
looked at the newer version but like

515
00:20:39,070 --> 00:20:40,179
there might be some questions are there

516
00:20:40,179 --> 00:20:41,710
you can look at and then we do the odd

517
00:20:41,710 --> 00:20:44,110
ones and you go to the DB like DB the

518
00:20:44,110 --> 00:20:45,700
links on the web on the course websites

519
00:20:45,700 --> 00:20:47,679
are DB book calm they'll have the

520
00:20:47,679 --> 00:20:49,120
solutions to our problems you can just

521
00:20:49,120 --> 00:20:53,080
follow those I'll put a link on the the

522
00:20:53,080 --> 00:20:58,150
final review web page yes especially can

523
00:20:58,150 --> 00:21:01,740
you bring a notes on midterm one cheap

524
00:21:01,740 --> 00:21:07,200
one cheap copy whatever you need okay

525
00:21:12,000 --> 00:21:15,970
all right so this is my one this this is

526
00:21:15,970 --> 00:21:17,260
pie my favorite one of the favorite

527
00:21:17,260 --> 00:21:19,720
lectures well they're all good but cuz

528
00:21:19,720 --> 00:21:21,130
he talked about more databases alright

529
00:21:21,130 --> 00:21:23,440
so again I asked everyone in the class

530
00:21:23,440 --> 00:21:25,780
to vote on what systems they were most

531
00:21:25,780 --> 00:21:27,730
interested in learning about so here's

532
00:21:27,730 --> 00:21:30,250
the tally from last year for the top 10

533
00:21:30,250 --> 00:21:33,160
cockroach TV spanner and manga DVD and

534
00:21:33,160 --> 00:21:34,830
here's what we ended up with this year

535
00:21:34,830 --> 00:21:37,450
which is very surprising scuba came up

536
00:21:37,450 --> 00:21:39,610
first followed by manga fought like

537
00:21:39,610 --> 00:21:42,610
cockroach and surprisingly this is my I

538
00:21:42,610 --> 00:21:44,860
think fifth or sixth year teaching like

539
00:21:44,860 --> 00:21:45,669
this puppy thing

540
00:21:45,669 --> 00:21:47,429
spanners always been in the top three

541
00:21:47,429 --> 00:21:50,529
right and so the only thing I could

542
00:21:50,529 --> 00:21:51,909
think of that people why people didn't

543
00:21:51,909 --> 00:21:53,440
vote for this as much is because the

544
00:21:53,440 --> 00:21:56,349
name got changed a cloud spanner right

545
00:21:56,349 --> 00:21:57,639
and maybe people didn't think it was the

546
00:21:57,639 --> 00:21:59,499
same thing so that's okay

547
00:21:59,499 --> 00:22:01,179
but scuba is a really interesting system

548
00:22:01,179 --> 00:22:03,719
so we'll start that for that first okay

549
00:22:03,719 --> 00:22:07,209
all right so Facebook's Cuba now so I

550
00:22:07,209 --> 00:22:08,320
also noticed that people vote for the

551
00:22:08,320 --> 00:22:09,609
ones or has like if has a name of a

552
00:22:09,609 --> 00:22:11,139
company in front of it like Amazon

553
00:22:11,139 --> 00:22:13,179
Aurora Baidu ocean base then people vote

554
00:22:13,179 --> 00:22:17,289
for those things more so all right all

555
00:22:17,289 --> 00:22:18,339
right Facebook's Qi

556
00:22:18,339 --> 00:22:22,269
so what the you know what we're trying

557
00:22:22,269 --> 00:22:24,099
to do here in the system potpourri is to

558
00:22:24,099 --> 00:22:26,469
show you that we can now look at real

559
00:22:26,469 --> 00:22:29,589
world systems and start using the

560
00:22:29,589 --> 00:22:31,149
vernacular that we've discussed all

561
00:22:31,149 --> 00:22:33,279
through it an entire semester to sort of

562
00:22:33,279 --> 00:22:34,599
start to understand what this thing is

563
00:22:34,599 --> 00:22:37,450
actually doing right so now I could say

564
00:22:37,450 --> 00:22:38,679
this things out to shared nothing to

565
00:22:38,679 --> 00:22:39,849
shoot the system and you know what that

566
00:22:39,849 --> 00:22:41,349
means you know what the implications of

567
00:22:41,349 --> 00:22:43,179
that are you know what the performance

568
00:22:43,179 --> 00:22:44,349
characteristic performance challenges

569
00:22:44,349 --> 00:22:47,409
you would have in a system like this so

570
00:22:47,409 --> 00:22:49,389
scuba is an internal database system

571
00:22:49,389 --> 00:22:50,940
that Facebook isn't working on for

572
00:22:50,940 --> 00:22:53,320
several years now was first announced in

573
00:22:53,320 --> 00:22:56,619
vldb in 2013 and they've been still

574
00:22:56,619 --> 00:22:58,089
working on it it's it's not open source

575
00:22:58,089 --> 00:23:01,059
right there's it's only till very

576
00:23:01,059 --> 00:23:03,249
recently is there now some public

577
00:23:03,249 --> 00:23:04,959
information about the newer version and

578
00:23:04,959 --> 00:23:06,429
actually turns out because the guy that

579
00:23:06,429 --> 00:23:07,979
that's actually leading the project is

580
00:23:07,979 --> 00:23:10,690
CMU database alum like he got his PhD

581
00:23:10,690 --> 00:23:12,459
here before I showed up and he's now

582
00:23:12,459 --> 00:23:15,279
running that whole the the running the

583
00:23:15,279 --> 00:23:17,229
the development of this data system and

584
00:23:17,229 --> 00:23:21,190
then his boss is actually a his boss's

585
00:23:21,190 --> 00:23:23,950
is the mother of another CS student here

586
00:23:23,950 --> 00:23:26,409
in the department who actually worked on

587
00:23:26,409 --> 00:23:28,899
bust table over the summer all right so

588
00:23:28,899 --> 00:23:30,489
it's all to all one giant simi family

589
00:23:30,489 --> 00:23:34,179
all right so scuba is a it's a it's MIT

590
00:23:34,179 --> 00:23:35,919
it's designed for having low latency

591
00:23:35,919 --> 00:23:38,679
queries and ingestion of internal metric

592
00:23:38,679 --> 00:23:40,479
data generated from from Facebook's

593
00:23:40,479 --> 00:23:42,729
different services all right so this is

594
00:23:42,729 --> 00:23:44,320
not running an ode to the application

595
00:23:44,320 --> 00:23:47,259
this is not running it's not a good ient

596
00:23:47,259 --> 00:23:49,089
warehouse think of like every single

597
00:23:49,089 --> 00:23:50,649
time you click something on Facebook

598
00:23:50,649 --> 00:23:53,019
right on the website that causes a bunch

599
00:23:53,019 --> 00:23:54,759
of functions are going to vote on the

600
00:23:54,759 --> 00:23:57,249
servers and you can they can have their

601
00:23:57,249 --> 00:23:58,779
developers instrument those function

602
00:23:58,779 --> 00:23:59,440
calls

603
00:23:59,440 --> 00:24:01,500
to keep track of the performance metrics

604
00:24:01,500 --> 00:24:04,000
right throughout the entire stack and

605
00:24:04,000 --> 00:24:05,529
then all that data then gets shoved over

606
00:24:05,529 --> 00:24:08,169
to scuba now they can use that and then

607
00:24:08,169 --> 00:24:09,730
run queries on that data to try to

608
00:24:09,730 --> 00:24:10,960
figure out you know why does this

609
00:24:10,960 --> 00:24:12,970
function take you know run it slower

610
00:24:12,970 --> 00:24:14,830
what are some problems I'm seeing and my

611
00:24:14,830 --> 00:24:18,399
giant fleet so the newer version of

612
00:24:18,399 --> 00:24:21,669
scuba is now a column store it's a

613
00:24:21,669 --> 00:24:23,409
distributed shared nothing system it's

614
00:24:23,409 --> 00:24:25,049
using a tiered store just means that

615
00:24:25,049 --> 00:24:27,820
this just means that like you can have a

616
00:24:27,820 --> 00:24:30,220
you know you can have a in-memory cache

617
00:24:30,220 --> 00:24:32,440
flash cache and then may be slower discs

618
00:24:32,440 --> 00:24:35,710
below that and then it's gonna be using

619
00:24:35,710 --> 00:24:37,720
a heterogeneous hierarchical distributed

620
00:24:37,720 --> 00:24:39,460
architecture and so one interesting

621
00:24:39,460 --> 00:24:41,259
about the system as well is that since

622
00:24:41,259 --> 00:24:42,549
they are trying to have this thing be

623
00:24:42,549 --> 00:24:44,559
really fast but you want to run your

624
00:24:44,559 --> 00:24:46,240
queries very quickly over a lot of data

625
00:24:46,240 --> 00:24:48,250
they are not a lot that can support

626
00:24:48,250 --> 00:24:49,720
sequel they're not going to support

627
00:24:49,720 --> 00:24:51,820
joins I'm not going to support global

628
00:24:51,820 --> 00:24:53,980
sorting so you can only write queries

629
00:24:53,980 --> 00:24:55,570
that access one single table and you

630
00:24:55,570 --> 00:24:58,899
have a where clause that do you know yes

631
00:24:58,899 --> 00:25:00,490
simple filtering and then you can

632
00:25:00,490 --> 00:25:02,799
aggregate aggregations another

633
00:25:02,799 --> 00:25:04,000
interesting about it that's gonna be

634
00:25:04,000 --> 00:25:04,840
different than everything we talked

635
00:25:04,840 --> 00:25:07,360
about before is that they're gonna have

636
00:25:07,360 --> 00:25:09,549
to have replication to have or done a

637
00:25:09,549 --> 00:25:11,399
deployment of an entire Scooba cluster

638
00:25:11,399 --> 00:25:13,690
so you would think about like you have a

639
00:25:13,690 --> 00:25:15,399
bunch of machines I send all my data to

640
00:25:15,399 --> 00:25:17,110
this this this cluster but I'm also

641
00:25:17,110 --> 00:25:18,190
going to send it to other clusters

642
00:25:18,190 --> 00:25:19,509
running in different data centers or

643
00:25:19,509 --> 00:25:21,429
different regions but they're gonna

644
00:25:21,429 --> 00:25:24,610
allow for lossy fault tolerance in this

645
00:25:24,610 --> 00:25:26,559
environment because the data that

646
00:25:26,559 --> 00:25:28,840
they're collecting it's valuable would

647
00:25:28,840 --> 00:25:31,600
not like bank account invaluable right

648
00:25:31,600 --> 00:25:33,460
so like say you know you go click on

649
00:25:33,460 --> 00:25:34,720
something in your time on a Facebook

650
00:25:34,720 --> 00:25:36,460
that generates a bunch of performance

651
00:25:36,460 --> 00:25:38,710
metric data if that data gets lost

652
00:25:38,710 --> 00:25:41,559
yeah right it's not that not the end of

653
00:25:41,559 --> 00:25:42,669
the world you know actually I want to

654
00:25:42,669 --> 00:25:44,950
lose everything but they're an allow

655
00:25:44,950 --> 00:25:46,899
they're gonna tolerate queries to end a

656
00:25:46,899 --> 00:25:49,269
you know may have false negatives false

657
00:25:49,269 --> 00:25:50,080
positives cuz they're gonna end up

658
00:25:50,080 --> 00:25:51,490
missing data that just end up again

659
00:25:51,490 --> 00:25:53,710
getting missing and so the way they're

660
00:25:53,710 --> 00:25:55,480
gonna try to avoid that is to running

661
00:25:55,480 --> 00:25:57,039
multiple points they'll run the query in

662
00:25:57,039 --> 00:25:59,049
different regions at the same time and

663
00:25:59,049 --> 00:26:00,490
then when they get back the result they

664
00:26:00,490 --> 00:26:04,149
see which query actually read them had

665
00:26:04,149 --> 00:26:05,769
the the fewer number the fewest number

666
00:26:05,769 --> 00:26:08,590
of missing data and then they use that

667
00:26:08,590 --> 00:26:10,720
as the CREP result but if they lose some

668
00:26:10,720 --> 00:26:11,889
data it's not a big deal

669
00:26:11,889 --> 00:26:12,759
and actually going to be they're gonna

670
00:26:12,759 --> 00:26:13,270
have

671
00:26:13,270 --> 00:26:15,010
retention policy where you can say any

672
00:26:15,010 --> 00:26:17,230
data stored in this table after after

673
00:26:17,230 --> 00:26:20,050
you know seven days just thrown away and

674
00:26:20,050 --> 00:26:24,700
who cares all right so here's here's the

675
00:26:24,700 --> 00:26:26,920
high-level pipeline of what they're

676
00:26:26,920 --> 00:26:28,480
trying to do so you have your different

677
00:26:28,480 --> 00:26:29,710
application servers right these are all

678
00:26:29,710 --> 00:26:33,160
running the the you know the running the

679
00:26:33,160 --> 00:26:34,720
website running all the back-end stuff

680
00:26:34,720 --> 00:26:36,640
you need to support the website so these

681
00:26:36,640 --> 00:26:39,310
guys can be generating structure debug

682
00:26:39,310 --> 00:26:40,960
logs so think of this as like a JSON

683
00:26:40,960 --> 00:26:43,060
document that the application server

684
00:26:43,060 --> 00:26:44,800
spits out to say you know here's how

685
00:26:44,800 --> 00:26:46,150
much time I spent in the CPU for this

686
00:26:46,150 --> 00:26:48,580
function in that function so then

687
00:26:48,580 --> 00:26:49,840
they're gonna load this into this

688
00:26:49,840 --> 00:26:51,430
internal tool that they develop called

689
00:26:51,430 --> 00:26:53,920
scribe I think of this it's sort of like

690
00:26:53,920 --> 00:26:55,840
a Kafka kind of thing we have a bunch of

691
00:26:55,840 --> 00:26:57,730
log records coming in and then you can

692
00:26:57,730 --> 00:27:00,850
have the pub sub system to say here's

693
00:27:00,850 --> 00:27:01,990
how to categorize the data I've

694
00:27:01,990 --> 00:27:03,730
collected and here's in other systems

695
00:27:03,730 --> 00:27:05,230
get notified when new information

696
00:27:05,230 --> 00:27:08,020
arrives to it so this is an older thing

697
00:27:08,020 --> 00:27:10,180
that since over ten years old there's an

698
00:27:10,180 --> 00:27:11,410
open-source version that they have on

699
00:27:11,410 --> 00:27:12,910
github but that was like abandon a

700
00:27:12,910 --> 00:27:16,300
decade ago so that supposedly the the

701
00:27:16,300 --> 00:27:17,500
internal version it's much better than

702
00:27:17,500 --> 00:27:21,040
what's on online now all right so the

703
00:27:21,040 --> 00:27:23,800
scribe is now gonna take the structured

704
00:27:23,800 --> 00:27:25,720
logs look at some tag to say you know

705
00:27:25,720 --> 00:27:28,090
it's it's generated for you know this

706
00:27:28,090 --> 00:27:29,890
particular application type or this

707
00:27:29,890 --> 00:27:32,260
service and it's gonna combine them and

708
00:27:32,260 --> 00:27:34,000
get together based on that category and

709
00:27:34,000 --> 00:27:35,650
then it's gonna send them to this

710
00:27:35,650 --> 00:27:37,180
streaming platform or they call it the

711
00:27:37,180 --> 00:27:39,010
tailor service because they're just

712
00:27:39,010 --> 00:27:40,840
tailing the log and this is just gonna

713
00:27:40,840 --> 00:27:42,160
bash together a bunch of these log

714
00:27:42,160 --> 00:27:44,710
records they've gotten from scribe and

715
00:27:44,710 --> 00:27:46,150
then when they have a large enough batch

716
00:27:46,150 --> 00:27:47,920
they're gonna convert that into a

717
00:27:47,920 --> 00:27:51,460
columnar data file think of like park'

718
00:27:51,460 --> 00:27:53,230
or orc that we talked about last week

719
00:27:53,230 --> 00:27:54,790
all right this thing's like a standalone

720
00:27:54,790 --> 00:27:57,550
file almost like a CSV but it's actually

721
00:27:57,550 --> 00:28:01,270
a binary column store and so if they

722
00:28:01,270 --> 00:28:02,260
have a larger batch they're gonna

723
00:28:02,260 --> 00:28:03,850
generate these these column store files

724
00:28:03,850 --> 00:28:05,590
and then now they're gonna feed this

725
00:28:05,590 --> 00:28:08,890
into the leaf nodes in scuba and so

726
00:28:08,890 --> 00:28:10,510
we're talking to 16 aggregation notes

727
00:28:10,510 --> 00:28:12,190
and leaf nodes but this is basically the

728
00:28:12,190 --> 00:28:14,290
storage nodes think of this as like the

729
00:28:14,290 --> 00:28:16,660
the shared disk architecture but you can

730
00:28:16,660 --> 00:28:18,310
actually have you know run queries down

731
00:28:18,310 --> 00:28:20,920
here or the the last class when Shashank

732
00:28:20,920 --> 00:28:23,020
talked about Oracle Exadata but they had

733
00:28:23,020 --> 00:28:24,640
the storage nodes at the bottom could

734
00:28:24,640 --> 00:28:25,930
actually do filtering and predicate

735
00:28:25,930 --> 00:28:27,100
evaluation down there

736
00:28:27,100 --> 00:28:30,370
same same idea here so now one

737
00:28:30,370 --> 00:28:31,570
additional thing they're going to do is

738
00:28:31,570 --> 00:28:33,580
that they're gonna each of these leaf

739
00:28:33,580 --> 00:28:35,200
nodes are going to update this

740
00:28:35,200 --> 00:28:37,539
validation service with information

741
00:28:37,539 --> 00:28:39,250
about the number of tuples that they've

742
00:28:39,250 --> 00:28:42,730
inserted for each table and we'll see it

743
00:28:42,730 --> 00:28:44,320
in a second this is how they're gonna

744
00:28:44,320 --> 00:28:47,980
determine which which when they run the

745
00:28:47,980 --> 00:28:49,240
query on multiple deployments or

746
00:28:49,240 --> 00:28:51,309
multiple clusters you'll check that

747
00:28:51,309 --> 00:28:53,139
thing to say well how much data is

748
00:28:53,139 --> 00:28:54,639
actually missing so I know I sorted a

749
00:28:54,639 --> 00:28:56,529
million tuples but I only read maybe

750
00:28:56,529 --> 00:28:58,659
500,000 so half of my data went missing

751
00:28:58,659 --> 00:29:00,610
again they're not they're not gonna go

752
00:29:00,610 --> 00:29:02,710
freak out that's okay in their

753
00:29:02,710 --> 00:29:04,210
environment but just they keep track of

754
00:29:04,210 --> 00:29:05,980
this and they know that which query is

755
00:29:05,980 --> 00:29:09,100
producing the most accurate result so

756
00:29:09,100 --> 00:29:10,990
now it's again it's a seagull system so

757
00:29:10,990 --> 00:29:14,889
they have a vistas sequel interface or

758
00:29:14,889 --> 00:29:16,240
these dashboards that people can use

759
00:29:16,240 --> 00:29:18,279
internally at Facebook that sends sequel

760
00:29:18,279 --> 00:29:20,019
queries to this execution layer which

761
00:29:20,019 --> 00:29:20,980
then is gonna send it to these

762
00:29:20,980 --> 00:29:22,960
aggregators who then are gonna farm it

763
00:29:22,960 --> 00:29:24,730
down to these leaf nodes so I'll discuss

764
00:29:24,730 --> 00:29:26,769
this hierarchy and a few more slides but

765
00:29:26,769 --> 00:29:28,659
this is an important distinction between

766
00:29:28,659 --> 00:29:30,429
all the distributed databases we talked

767
00:29:30,429 --> 00:29:32,590
about because it's a heterogeneous

768
00:29:32,590 --> 00:29:34,330
environment so the leaf nodes are doing

769
00:29:34,330 --> 00:29:36,070
things that are separate or different

770
00:29:36,070 --> 00:29:37,799
than what the aggregator notes are doing

771
00:29:37,799 --> 00:29:39,639
right and you obviously have more of

772
00:29:39,639 --> 00:29:43,740
these because you're have more data yes

773
00:29:43,740 --> 00:29:45,730
the question is the categories name is

774
00:29:45,730 --> 00:29:47,860
accurate yes think of like it's some

775
00:29:47,860 --> 00:29:51,360
internal tag that that Facebook is

776
00:29:51,360 --> 00:29:53,860
ascribing to a particular class of log

777
00:29:53,860 --> 00:29:56,470
records right so again say it's like I

778
00:29:56,470 --> 00:29:58,990
don't know the facebook inbox or

779
00:29:58,990 --> 00:30:00,850
messenger right so you'd say that would

780
00:30:00,850 --> 00:30:03,370
be one category so all the the log

781
00:30:03,370 --> 00:30:05,080
records from the messenger app go to get

782
00:30:05,080 --> 00:30:11,980
combined together okay so again all

783
00:30:11,980 --> 00:30:13,299
right it's a header juice architecture

784
00:30:13,299 --> 00:30:15,850
and we have leaf nodes aggregator nodes

785
00:30:15,850 --> 00:30:18,159
so the leaf nodes are going to store the

786
00:30:18,159 --> 00:30:19,690
column our data that we're getting out

787
00:30:19,690 --> 00:30:24,340
from the the record batchers in a

788
00:30:24,340 --> 00:30:29,500
columnar format and the for each query

789
00:30:29,500 --> 00:30:31,029
every query is gonna go to every single

790
00:30:31,029 --> 00:30:33,039
leaf node so the may not be data that

791
00:30:33,039 --> 00:30:35,950
the query needs on that leaf node but

792
00:30:35,950 --> 00:30:37,149
they're not going to store any

793
00:30:37,149 --> 00:30:38,980
additional metadata or maintain any

794
00:30:38,980 --> 00:30:40,580
indexes on these leaf

795
00:30:40,580 --> 00:30:42,769
give me it'll figure out whether I need

796
00:30:42,769 --> 00:30:45,259
to touch data at them so they're trying

797
00:30:45,259 --> 00:30:46,129
to make this thing be as fast as

798
00:30:46,129 --> 00:30:48,110
possible to trying to make this both in

799
00:30:48,110 --> 00:30:49,399
terms of how fast the query can execute

800
00:30:49,399 --> 00:30:51,049
but also how fast you can ingest new

801
00:30:51,049 --> 00:30:53,539
data so if I don't have to maintain any

802
00:30:53,539 --> 00:30:55,340
metadata or catalog information about

803
00:30:55,340 --> 00:30:59,419
which data is that what leaf node then I

804
00:30:59,419 --> 00:31:00,980
can ingest new data very quickly and

805
00:31:00,980 --> 00:31:02,809
then every query shows up and just scans

806
00:31:02,809 --> 00:31:05,299
everything and then that determines

807
00:31:05,299 --> 00:31:07,279
whether the you know you have data that

808
00:31:07,279 --> 00:31:11,389
you actually need that makes sense right

809
00:31:11,389 --> 00:31:12,590
so like when we talk about partitioning

810
00:31:12,590 --> 00:31:14,480
before we talk about how there's and

811
00:31:14,480 --> 00:31:15,919
we'll see this a and cockroach

812
00:31:15,919 --> 00:31:18,679
there to maintain this this state table

813
00:31:18,679 --> 00:31:20,539
that says if you want data within this

814
00:31:20,539 --> 00:31:22,519
range or this hash value go to these

815
00:31:22,519 --> 00:31:24,289
nodes they're not gonna have any of that

816
00:31:24,289 --> 00:31:26,029
they just blast everything to everything

817
00:31:26,029 --> 00:31:29,419
every query goes everywhere so the

818
00:31:29,419 --> 00:31:30,980
aggregator nodes when they get a query

819
00:31:30,980 --> 00:31:33,350
they're going to dispatch plan fragments

820
00:31:33,350 --> 00:31:34,610
to the leaf it's shown in leaf nodes

821
00:31:34,610 --> 00:31:36,679
there Dan gonna do on the leaf nodes

822
00:31:36,679 --> 00:31:38,659
they're gonna do the scan and some some

823
00:31:38,659 --> 00:31:40,309
basic computation but I'm gonna send the

824
00:31:40,309 --> 00:31:42,110
result up to the aggregator nodes we're

825
00:31:42,110 --> 00:31:44,419
then going to combine the results from

826
00:31:44,419 --> 00:31:46,850
multiple leaf nodes to produce a single

827
00:31:46,850 --> 00:31:48,529
result and then send that up to a root

828
00:31:48,529 --> 00:31:50,090
node who combines combines the final

829
00:31:50,090 --> 00:31:52,730
result so this is an allow them to scale

830
00:31:52,730 --> 00:31:55,009
out the system very easily because I

831
00:31:55,009 --> 00:31:57,019
know if my aggregators are running slow

832
00:31:57,019 --> 00:31:58,639
I can add those nodes because they don't

833
00:31:58,639 --> 00:32:00,110
have any state right that's not where

834
00:32:00,110 --> 00:32:01,610
the data is actually stored or if I need

835
00:32:01,610 --> 00:32:03,139
to scale out my leaf nodes I just add

836
00:32:03,139 --> 00:32:04,789
more of those and keep my a Grenadiers

837
00:32:04,789 --> 00:32:06,649
but the same but it's a very interesting

838
00:32:06,649 --> 00:32:08,240
architecture that shows up in a lot of

839
00:32:08,240 --> 00:32:12,590
other Facebook system design the mem

840
00:32:12,590 --> 00:32:14,179
seagull guys when they before they

841
00:32:14,179 --> 00:32:15,529
started mem sequel they spend their time

842
00:32:15,529 --> 00:32:16,970
at Facebook and they saw this kind of

843
00:32:16,970 --> 00:32:19,039
architecture and then they sort of

844
00:32:19,039 --> 00:32:22,190
copied it or inspired by it when they

845
00:32:22,190 --> 00:32:23,840
went off them psychosom em sequel works

846
00:32:23,840 --> 00:32:28,039
the same way okay so again we talked

847
00:32:28,039 --> 00:32:31,700
about this this tolerating lost aid or

848
00:32:31,700 --> 00:32:34,370
missing data so if a leaf node either

849
00:32:34,370 --> 00:32:37,309
has no data or that it's down and it

850
00:32:37,309 --> 00:32:39,049
can't produce any results within a time

851
00:32:39,049 --> 00:32:41,240
out then they just ignore it and that's

852
00:32:41,240 --> 00:32:43,100
okay and they use the validation service

853
00:32:43,100 --> 00:32:44,419
to figure out well how much data was

854
00:32:44,419 --> 00:32:46,100
this thing actually have and that'll

855
00:32:46,100 --> 00:32:47,360
determine the quality of the query a

856
00:32:47,360 --> 00:32:50,210
query result so let's see what the end

857
00:32:50,210 --> 00:32:52,260
the full pipeline looks like so

858
00:32:52,260 --> 00:32:54,330
again this is this is be considered one

859
00:32:54,330 --> 00:32:55,980
scoop of cluster they're gonna they're

860
00:32:55,980 --> 00:32:58,140
gonna have multiple instances of the

861
00:32:58,140 --> 00:32:59,250
same kind of cluster running in

862
00:32:59,250 --> 00:33:00,480
different data centers different regions

863
00:33:00,480 --> 00:33:02,400
and they're gonna vote a query on all

864
00:33:02,400 --> 00:33:04,080
than at the same time and they all get

865
00:33:04,080 --> 00:33:05,190
back the same result and you pick out

866
00:33:05,190 --> 00:33:07,830
which one is the best one so my query

867
00:33:07,830 --> 00:33:10,470
shows up I want to do a an aggregation

868
00:33:10,470 --> 00:33:12,330
of the number of vents that crashed on

869
00:33:12,330 --> 00:33:14,940
there was a crash on a Monday again so I

870
00:33:14,940 --> 00:33:16,710
can only do single table queries I can

871
00:33:16,710 --> 00:33:18,450
do aggregations I can do group bys I can

872
00:33:18,450 --> 00:33:20,460
do filtering under scans but I can't do

873
00:33:20,460 --> 00:33:22,710
global global sorting on I can do joins

874
00:33:22,710 --> 00:33:25,650
so the routes gonna get the query and

875
00:33:25,650 --> 00:33:26,850
that's going to break it up to query

876
00:33:26,850 --> 00:33:27,960
plan fragments that's can then

877
00:33:27,960 --> 00:33:29,430
distribute down to the aggregators and

878
00:33:29,430 --> 00:33:31,170
the aggregators are gonna tribute them

879
00:33:31,170 --> 00:33:34,230
down to their delete nodes all the leaf

880
00:33:34,230 --> 00:33:35,520
nodes are now going to do a scan and

881
00:33:35,520 --> 00:33:37,980
then send results back up but let's say

882
00:33:37,980 --> 00:33:39,330
while we're executing this query this

883
00:33:39,330 --> 00:33:41,790
node goes down which happens right if

884
00:33:41,790 --> 00:33:44,370
you have a large large cluster so

885
00:33:44,370 --> 00:33:46,170
everybody else I'm still wrong everybody

886
00:33:46,170 --> 00:33:48,240
else is still gonna be able to do the

887
00:33:48,240 --> 00:33:50,940
computation for this query and then they

888
00:33:50,940 --> 00:33:52,680
send the results back up to the

889
00:33:52,680 --> 00:33:54,390
aggregators prepend just can't combine

890
00:33:54,390 --> 00:33:56,490
it together right so I'm doing accounts

891
00:33:56,490 --> 00:33:57,750
I want to know the number of events that

892
00:33:57,750 --> 00:33:59,610
occurred so this guy says has I have ten

893
00:33:59,610 --> 00:34:02,130
events he has 20 events so this guy just

894
00:34:02,130 --> 00:34:04,200
takes 10 plus 20 and produces 30 and

895
00:34:04,200 --> 00:34:06,690
then sends it up to the root and the

896
00:34:06,690 --> 00:34:08,159
root does the same thing just adds all

897
00:34:08,159 --> 00:34:09,659
the results at different aggregators and

898
00:34:09,659 --> 00:34:13,590
then produces the final result so this

899
00:34:13,590 --> 00:34:34,320
is clear yes yes so this query is to

900
00:34:34,320 --> 00:34:37,260
scan everything right so there is no

901
00:34:37,260 --> 00:34:39,000
again there's no metadata there's no

902
00:34:39,000 --> 00:34:40,800
catalog to tell me anything about

903
00:34:40,800 --> 00:34:42,750
whether or not these leaf nodes had the

904
00:34:42,750 --> 00:34:45,210
data in my that I have my where clause

905
00:34:45,210 --> 00:34:47,070
so I don't know but I don't know where

906
00:34:47,070 --> 00:34:48,270
type is I don't know where time is so I

907
00:34:48,270 --> 00:34:50,610
send it everyone so everyone essentially

908
00:34:50,610 --> 00:34:51,929
he's gonna in this example here

909
00:34:51,929 --> 00:34:53,639
everyone's gonna do the exact same query

910
00:34:53,639 --> 00:34:56,760
run it on the leaf nodes alright so he's

911
00:34:56,760 --> 00:34:58,350
doing a count star work type II type

912
00:34:58,350 --> 00:35:00,090
equals crash time he goes Monday he has

913
00:35:00,090 --> 00:35:02,070
10 he just shoves that up and this guy

914
00:35:02,070 --> 00:35:04,050
knows well I'm doing this count thing so

915
00:35:04,050 --> 00:35:05,820
I just added some up

916
00:35:05,820 --> 00:35:14,090
numbers together please the result yes

917
00:35:18,020 --> 00:35:20,700
ah is it true that for every single

918
00:35:20,700 --> 00:35:24,150
query you would always copy the same

919
00:35:24,150 --> 00:35:26,430
query down to the leaf nodes no because

920
00:35:26,430 --> 00:35:28,380
like for averages the way you do that is

921
00:35:28,380 --> 00:35:29,730
account on the sum and then you can put

922
00:35:29,730 --> 00:35:31,860
the average up at the top so that that

923
00:35:31,860 --> 00:35:37,920
would be different yeah so there really

924
00:35:37,920 --> 00:35:41,520
isn't like since there's no joins the

925
00:35:41,520 --> 00:35:42,630
cook there's not really a query

926
00:35:42,630 --> 00:35:44,310
optimizer here it's just I need to know

927
00:35:44,310 --> 00:35:45,900
what the I just convert the seco to a

928
00:35:45,900 --> 00:35:48,210
query plan and to shut that down

929
00:35:48,210 --> 00:35:49,440
and there's some basic heuristic they

930
00:35:49,440 --> 00:35:50,880
probably do to figure out like you know

931
00:35:50,880 --> 00:35:52,770
how to actually break it up and send it

932
00:35:52,770 --> 00:36:03,450
down huitnids yes so this question is

933
00:36:03,450 --> 00:36:05,460
why was it why was it decided to have a

934
00:36:05,460 --> 00:36:08,040
root node here and how all the clients

935
00:36:08,040 --> 00:36:11,130
go to this versus having everyone can

936
00:36:11,130 --> 00:36:13,080
penally go to any aggregator and then

937
00:36:13,080 --> 00:36:14,880
any aggregator can talk to anybody else

938
00:36:14,880 --> 00:36:20,550
so the my understanding is that there's

939
00:36:20,550 --> 00:36:22,860
actually a there's a layer above this as

940
00:36:22,860 --> 00:36:24,960
well the root were they're doing a

941
00:36:24,960 --> 00:36:27,540
mission control so they can do some

942
00:36:27,540 --> 00:36:30,330
things like oh if a query if a node is

943
00:36:30,330 --> 00:36:32,490
sending too many queries a client

944
00:36:32,490 --> 00:36:33,660
sending too many queries maybe want to

945
00:36:33,660 --> 00:36:36,060
throttle them or like if I know I'm

946
00:36:36,060 --> 00:36:38,340
getting bad data from some some set of

947
00:36:38,340 --> 00:36:40,410
these nodes then I can have someone to

948
00:36:40,410 --> 00:36:42,300
make a decision about what to exclude or

949
00:36:42,300 --> 00:36:44,280
not include them in my query execution

950
00:36:44,280 --> 00:36:46,560
so it's allows them to have a single

951
00:36:46,560 --> 00:36:49,170
location to have a global view of what's

952
00:36:49,170 --> 00:36:51,180
going on in the cluster doesn't know

953
00:36:51,180 --> 00:36:52,620
about what's in the database right

954
00:36:52,620 --> 00:36:53,520
because that's that would be to

955
00:36:53,520 --> 00:36:55,050
extensive maintain and keep keep it

956
00:36:55,050 --> 00:36:56,940
fresh all the time it just knows that

957
00:36:56,940 --> 00:36:58,800
like these nodes are performing and well

958
00:36:58,800 --> 00:37:15,720
they're not well yes his question is say

959
00:37:15,720 --> 00:37:18,390
that this node had a ton of results ton

960
00:37:18,390 --> 00:37:20,750
of that would match my predicate

961
00:37:20,750 --> 00:37:23,150
I wouldn't be better for me just abort

962
00:37:23,150 --> 00:37:25,849
this query cuz that because I'm my

963
00:37:25,849 --> 00:37:28,339
counts me way off how do you know that

964
00:37:28,339 --> 00:37:30,349
this node has all the date has a lot of

965
00:37:30,349 --> 00:37:33,410
data that matters for your clearing you

966
00:37:33,410 --> 00:37:38,420
don't know yeah so again think about

967
00:37:38,420 --> 00:37:39,980
what this is design for this is design

968
00:37:39,980 --> 00:37:42,069
for logs being generated by machines

969
00:37:42,069 --> 00:37:44,960
right it's not like hey here's my bank

970
00:37:44,960 --> 00:37:46,640
account I want that to be you know you

971
00:37:46,640 --> 00:37:49,839
know to the penny so if you get

972
00:37:49,839 --> 00:37:53,599
loosey-goosey results that still was

973
00:37:53,599 --> 00:37:56,480
probably okay and then the way they sort

974
00:37:56,480 --> 00:37:57,950
of overcome that again is by having that

975
00:37:57,950 --> 00:37:59,359
validation service they can determine

976
00:37:59,359 --> 00:38:02,230
how much data did they actually not read

977
00:38:02,230 --> 00:38:05,089
so then also again then they have a

978
00:38:05,089 --> 00:38:06,589
bunch of a Dunant copies of the system

979
00:38:06,589 --> 00:38:08,030
running at the same time they're all

980
00:38:08,030 --> 00:38:09,950
gonna produce the same query so the

981
00:38:09,950 --> 00:38:11,480
likelihood that every single every

982
00:38:11,480 --> 00:38:13,819
single cluster that's running Scooba for

983
00:38:13,819 --> 00:38:15,020
a single query is gonna have this node

984
00:38:15,020 --> 00:38:17,569
fail exactly you know exactly this node

985
00:38:17,569 --> 00:38:20,540
has this data fail is pretty low so at

986
00:38:20,540 --> 00:38:22,490
least one of those clusters will have a

987
00:38:22,490 --> 00:38:23,930
more active result and that's the one

988
00:38:23,930 --> 00:38:27,740
they'll use that's way different we talk

989
00:38:27,740 --> 00:38:28,790
about entire semester that's why I like

990
00:38:28,790 --> 00:38:30,680
the system because it's like we talked

991
00:38:30,680 --> 00:38:32,630
about never losing data now I'm saying

992
00:38:32,630 --> 00:38:35,329
it's okay to lose data because and it's

993
00:38:35,329 --> 00:38:36,440
like if the tree falls in the woods and

994
00:38:36,440 --> 00:38:37,730
no one's around to hear it who cares if

995
00:38:37,730 --> 00:38:39,349
this node goes down and no you know no

996
00:38:39,349 --> 00:38:40,640
one knows and it cares about what data

997
00:38:40,640 --> 00:38:43,670
is actually on it does it matter and

998
00:38:43,670 --> 00:38:46,520
because they're not in you know running

999
00:38:46,520 --> 00:38:48,500
wrap or patos every single time or

1000
00:38:48,500 --> 00:38:50,809
they're updating data this thing can run

1001
00:38:50,809 --> 00:38:55,369
really fast all right so this is

1002
00:38:55,369 --> 00:38:56,960
summarizes our whatever I already said

1003
00:38:56,960 --> 00:38:59,020
before right so for every scuba

1004
00:38:59,020 --> 00:39:01,280
deployment there's me multiple there's a

1005
00:39:01,280 --> 00:39:02,440
really multiple scuba deployments

1006
00:39:02,440 --> 00:39:05,540
running in their regions we run the

1007
00:39:05,540 --> 00:39:07,069
query at the same time on all the

1008
00:39:07,069 --> 00:39:09,109
regions and then they come back with a

1009
00:39:09,109 --> 00:39:11,180
result and then the result is annotated

1010
00:39:11,180 --> 00:39:12,980
with information from the validation

1011
00:39:12,980 --> 00:39:15,440
service that says how many how much data

1012
00:39:15,440 --> 00:39:18,049
did I end up not reading I picked the

1013
00:39:18,049 --> 00:39:20,869
one that has the that has the most the

1014
00:39:20,869 --> 00:39:24,790
read the most data and time

1015
00:39:25,180 --> 00:39:28,430
again so we know the guy Stavros that

1016
00:39:28,430 --> 00:39:30,760
runs us he got his PhD from CMU in

1017
00:39:30,760 --> 00:39:31,960
[Music]

1018
00:39:31,960 --> 00:39:35,630
2007-2008 and now he's in charge of us

1019
00:39:35,630 --> 00:39:40,430
so hi any questions all right good step

1020
00:39:40,430 --> 00:39:44,000
all right number two was is

1021
00:39:44,000 --> 00:39:46,849
always always picked every year so let

1022
00:39:46,849 --> 00:39:48,079
me ask you guys I asked this every year

1023
00:39:48,079 --> 00:39:51,529
why did you guys pick I assumed

1024
00:39:51,529 --> 00:39:52,579
you picked Facebook cause some of you

1025
00:39:52,579 --> 00:39:53,900
want to get jobs at Facebook because you

1026
00:39:53,900 --> 00:39:55,640
think like I go in the job interview I

1027
00:39:55,640 --> 00:39:57,910
could talk intelligently about scuba

1028
00:39:57,910 --> 00:39:59,869
same thing for do you want to work

1029
00:39:59,869 --> 00:40:03,190
at or do you want to use

1030
00:40:03,220 --> 00:40:05,000
some people already done internships

1031
00:40:05,000 --> 00:40:06,500
some people are going to new internships

1032
00:40:06,500 --> 00:40:10,190
there I guess he says it's much

1033
00:40:10,190 --> 00:40:12,049
different than what we normally do ok so

1034
00:40:12,049 --> 00:40:13,940
I've known the MongoDB guys for a long

1035
00:40:13,940 --> 00:40:17,720
time the one of the co-founders actually

1036
00:40:17,720 --> 00:40:23,680
went to brown before I did he so he like

1037
00:40:23,680 --> 00:40:26,539
we've known Elliot since like 2009 when

1038
00:40:26,539 --> 00:40:27,589
he first started assessment can you come

1039
00:40:27,589 --> 00:40:29,690
give talks at this year's Sparta they're

1040
00:40:29,690 --> 00:40:31,520
all the time and I actually was there in

1041
00:40:31,520 --> 00:40:33,170
August they have a new office building

1042
00:40:33,170 --> 00:40:35,480
they used to be right around the corner

1043
00:40:35,480 --> 00:40:37,190
from Times Square which is awful they're

1044
00:40:37,190 --> 00:40:39,140
still in Midtown but they have a nice

1045
00:40:39,140 --> 00:40:40,849
office building so you know they're a

1046
00:40:40,849 --> 00:40:42,589
big deal if you have the sign for your

1047
00:40:42,589 --> 00:40:45,380
company outside the building right above

1048
00:40:45,380 --> 00:40:47,000
that says Warner Music Group they have

1049
00:40:47,000 --> 00:40:48,529
the money is doing pretty well

1050
00:40:48,529 --> 00:40:50,240
it's all for the databases so this is

1051
00:40:50,240 --> 00:40:51,500
their Lobby the lobbies nice looks

1052
00:40:51,500 --> 00:40:54,230
familiar right yeah um the view is

1053
00:40:54,230 --> 00:40:55,789
amazing so this is from the kitchen I

1054
00:40:55,789 --> 00:40:58,609
mean it was a cloudy day the view is

1055
00:40:58,609 --> 00:41:01,309
absolutely stellar uh and again all paid

1056
00:41:01,309 --> 00:41:03,650
for by databases it's amazing all right

1057
00:41:03,650 --> 00:41:05,930
so what is is a distributed

1058
00:41:05,930 --> 00:41:09,109
document model data spirit system so

1059
00:41:09,109 --> 00:41:12,260
when I say document think of JSON like a

1060
00:41:12,260 --> 00:41:17,869
JSON object and in the MongoDB world the

1061
00:41:17,869 --> 00:41:19,339
language for when we talked about the

1062
00:41:19,339 --> 00:41:20,270
entire semester has been slightly

1063
00:41:20,270 --> 00:41:21,799
different so again instead of saying to

1064
00:41:21,799 --> 00:41:23,119
bold to say document instead of saying

1065
00:41:23,119 --> 00:41:25,220
table they or a relation they say

1066
00:41:25,220 --> 00:41:27,470
collection but the high-level concepts

1067
00:41:27,470 --> 00:41:31,609
are still the same so it's one of the

1068
00:41:31,609 --> 00:41:33,289
earliest of our original no sequel

1069
00:41:33,289 --> 00:41:35,390
systems it was open source

1070
00:41:35,390 --> 00:41:37,640
it used to be GPL but now they switch to

1071
00:41:37,640 --> 00:41:38,630
the server side

1072
00:41:38,630 --> 00:41:40,099
license and this is basically to protect

1073
00:41:40,099 --> 00:41:42,140
them from Amazon like MongoDB got so

1074
00:41:42,140 --> 00:41:44,000
popular they were worried about Amazon

1075
00:41:44,000 --> 00:41:47,210
coming along and just running MongoDB in

1076
00:41:47,210 --> 00:41:48,470
a hosted environment and selling it for

1077
00:41:48,470 --> 00:41:50,539
cheaper than what mom could be could so

1078
00:41:50,539 --> 00:41:53,210
they switched their license now Amazon

1079
00:41:53,210 --> 00:41:54,680
did come out with a system that does

1080
00:41:54,680 --> 00:41:57,019
clone the mummy protocol called document

1081
00:41:57,019 --> 00:41:59,119
e-beam but my understanding of how it

1082
00:41:59,119 --> 00:42:00,470
works is that underneath the coverage is

1083
00:42:00,470 --> 00:42:02,660
just Postgres so the wire protocol looks

1084
00:42:02,660 --> 00:42:05,240
and smells like looks like looks like

1085
00:42:05,240 --> 00:42:08,779
MongoDB but underneath it is just post

1086
00:42:08,779 --> 00:42:10,609
groceries so it's going to very

1087
00:42:10,609 --> 00:42:11,900
centralized shared nothing architecture

1088
00:42:11,900 --> 00:42:17,559
with a heterogeneous configuration and

1089
00:42:17,559 --> 00:42:19,549
originally they you know as this no

1090
00:42:19,549 --> 00:42:20,569
sequel system they didn't do

1091
00:42:20,569 --> 00:42:22,220
transactions and they need new joins in

1092
00:42:22,220 --> 00:42:25,039
a new sequel so right now the latest

1093
00:42:25,039 --> 00:42:26,329
versions the that will they do

1094
00:42:26,329 --> 00:42:27,289
transactions they brought in

1095
00:42:27,289 --> 00:42:29,240
transactions and they also do joins the

1096
00:42:29,240 --> 00:42:30,460
only thing they haven't brought in is

1097
00:42:30,460 --> 00:42:35,750
sequel now there are some hacky tools

1098
00:42:35,750 --> 00:42:38,269
that can convert sequel into mom-to-be

1099
00:42:38,269 --> 00:42:40,670
queries as far as I know I've never run

1100
00:42:40,670 --> 00:42:42,500
across anybody that runs this and those

1101
00:42:42,500 --> 00:42:44,599
things in production alright so they're

1102
00:42:44,599 --> 00:42:46,009
among enemies gonna have their own API

1103
00:42:46,009 --> 00:42:47,569
which I'll show in a second that is

1104
00:42:47,569 --> 00:42:49,609
basically you write JSON queries to read

1105
00:42:49,609 --> 00:42:53,599
JSON data so one important concept about

1106
00:42:53,599 --> 00:42:55,309
the document data model which is quitly

1107
00:42:55,309 --> 00:42:56,180
different that we talked about the

1108
00:42:56,180 --> 00:42:58,390
entire semester is this concept of

1109
00:42:58,390 --> 00:43:02,509
denormalization so in the relational

1110
00:43:02,509 --> 00:43:04,519
model we would define our tables or

1111
00:43:04,519 --> 00:43:06,559
define our relations and we would use

1112
00:43:06,559 --> 00:43:08,599
foreign keys to say there's a reference

1113
00:43:08,599 --> 00:43:10,940
from this table to another table right

1114
00:43:10,940 --> 00:43:13,579
so if gain if I'm by modeling Amazon is

1115
00:43:13,579 --> 00:43:15,410
my store information so I have customers

1116
00:43:15,410 --> 00:43:16,940
customers orders and orders have order

1117
00:43:16,940 --> 00:43:19,940
items so in a relational database system

1118
00:43:19,940 --> 00:43:20,960
I would define these as separate

1119
00:43:20,960 --> 00:43:22,849
relations and then if I want to say for

1120
00:43:22,849 --> 00:43:24,230
a given customer give me all the items

1121
00:43:24,230 --> 00:43:25,759
that they bought I would have to do a

1122
00:43:25,759 --> 00:43:27,859
three-way join between these three

1123
00:43:27,859 --> 00:43:30,859
tables and the no sequel guys argue that

1124
00:43:30,859 --> 00:43:34,069
that would that was expensive to do to

1125
00:43:34,069 --> 00:43:36,559
do these joins you know because it's now

1126
00:43:36,559 --> 00:43:37,670
you got to run your hash join a nested

1127
00:43:37,670 --> 00:43:41,480
loop join right so what they would argue

1128
00:43:41,480 --> 00:43:42,829
you'd want to do in a document data

1129
00:43:42,829 --> 00:43:44,630
model is to denormalize what basically

1130
00:43:44,630 --> 00:43:48,529
says combined together the the related

1131
00:43:48,529 --> 00:43:50,569
information about a single entity in

1132
00:43:50,569 --> 00:43:52,010
your application into

1133
00:43:52,010 --> 00:43:54,890
single JSON document alright so setup in

1134
00:43:54,890 --> 00:43:55,730
this getting this environment here

1135
00:43:55,730 --> 00:43:57,140
instead of having a three different

1136
00:43:57,140 --> 00:43:59,090
tables you would have one table called

1137
00:43:59,090 --> 00:44:01,460
customer and then inside each customer

1138
00:44:01,460 --> 00:44:03,410
record you would embed their orders and

1139
00:44:03,410 --> 00:44:05,660
then which eaten within each order you

1140
00:44:05,660 --> 00:44:08,240
would embed their order items so now if

1141
00:44:08,240 --> 00:44:09,800
I want to go get all the order items

1142
00:44:09,800 --> 00:44:12,230
that Andy bought I go get my customer

1143
00:44:12,230 --> 00:44:14,540
record from the database system and then

1144
00:44:14,540 --> 00:44:16,280
I just reversed now inside the JSON

1145
00:44:16,280 --> 00:44:19,340
document to get what I want now

1146
00:44:19,340 --> 00:44:20,630
nummy did not invent that idea

1147
00:44:20,630 --> 00:44:23,270
that's an old idea from the 70s XML

1148
00:44:23,270 --> 00:44:25,760
databases did it in the early 2000s late

1149
00:44:25,760 --> 00:44:27,530
nineteen nineties the object-oriented

1150
00:44:27,530 --> 00:44:29,660
guys did this in the 1980s so MongoDB

1151
00:44:29,660 --> 00:44:31,340
did not invent that what Mongi was sort

1152
00:44:31,340 --> 00:44:33,920
of famous for was having a you know fast

1153
00:44:33,920 --> 00:44:37,460
distributed JSON database system right

1154
00:44:37,460 --> 00:44:39,230
when sort of web bill and and JavaScript

1155
00:44:39,230 --> 00:44:42,920
was becoming prominent so again we just

1156
00:44:42,920 --> 00:44:45,470
look like this and your your JSON

1157
00:44:45,470 --> 00:44:46,940
document would have inside of it and

1158
00:44:46,940 --> 00:44:49,070
array called orders and with inside that

1159
00:44:49,070 --> 00:44:50,390
you have additional JSON documents for

1160
00:44:50,390 --> 00:44:51,860
every single order and decide every

1161
00:44:51,860 --> 00:44:53,690
single order you have an array for order

1162
00:44:53,690 --> 00:44:55,010
items and then all the items that they

1163
00:44:55,010 --> 00:44:58,340
bought right so again we've talked to us

1164
00:44:58,340 --> 00:45:00,490
and they're actually the first class

1165
00:45:00,490 --> 00:45:02,870
some a performance standpoint this is we

1166
00:45:02,870 --> 00:45:03,470
really fast

1167
00:45:03,470 --> 00:45:05,390
again it's one read to go get you know

1168
00:45:05,390 --> 00:45:08,600
all Andy's order items the bad thing is

1169
00:45:08,600 --> 00:45:09,800
going to be obviously now we're gonna

1170
00:45:09,800 --> 00:45:12,380
duplicate a bunch of information about

1171
00:45:12,380 --> 00:45:13,550
these different order items over and

1172
00:45:13,550 --> 00:45:16,010
over again and now I need to write my

1173
00:45:16,010 --> 00:45:17,960
application code to make sure that

1174
00:45:17,960 --> 00:45:21,680
everything is is is the I maintain the

1175
00:45:21,680 --> 00:45:23,090
integrity of all of this information so

1176
00:45:23,090 --> 00:45:24,740
if I change the name of item I have to

1177
00:45:24,740 --> 00:45:26,510
write code to go through all my inside

1178
00:45:26,510 --> 00:45:27,560
all my customer records and make sure I

1179
00:45:27,560 --> 00:45:31,550
update everything so the way you panic

1180
00:45:31,550 --> 00:45:34,190
reacts to you queries is through a JSON

1181
00:45:34,190 --> 00:45:40,670
only query API they don't have a query

1182
00:45:40,670 --> 00:45:43,610
optimizer at least not in a call space

1183
00:45:43,610 --> 00:45:44,750
one that we talked about before and I

1184
00:45:44,750 --> 00:45:45,650
think a briefly talked about us when we

1185
00:45:45,650 --> 00:45:47,510
talk about query optimization so they

1186
00:45:47,510 --> 00:45:49,240
basically do is do your query shows up

1187
00:45:49,240 --> 00:45:52,130
and they're gonna generate sort of every

1188
00:45:52,130 --> 00:45:54,230
possible combination for that given

1189
00:45:54,230 --> 00:45:56,810
query and then there's gonna blast every

1190
00:45:56,810 --> 00:45:58,400
node with different different

1191
00:45:58,400 --> 00:46:00,590
combinations of that query and then

1192
00:46:00,590 --> 00:46:02,270
whatever one comes back first then they

1193
00:46:02,270 --> 00:46:04,040
learn that that's the better one to use

1194
00:46:04,040 --> 00:46:05,280
because it came back more quickly

1195
00:46:05,280 --> 00:46:06,900
so the next time you actually that same

1196
00:46:06,900 --> 00:46:08,760
query or similar query they'll just

1197
00:46:08,760 --> 00:46:10,860
reuse the query plan that they generated

1198
00:46:10,860 --> 00:46:13,230
before and they'll do this maybe like a

1199
00:46:13,230 --> 00:46:14,820
thousand times and then just after the

1200
00:46:14,820 --> 00:46:16,530
thousand query invocation they'll do

1201
00:46:16,530 --> 00:46:19,110
that sort of blast them all out first or

1202
00:46:19,110 --> 00:46:20,850
blast them all out and see which one

1203
00:46:20,850 --> 00:46:23,850
comes back first thing so you may think

1204
00:46:23,850 --> 00:46:25,260
is kind of hacky right I spent two

1205
00:46:25,260 --> 00:46:26,790
lectures talk about how hard it is to do

1206
00:46:26,790 --> 00:46:28,230
a query cost based scoring optimization

1207
00:46:28,230 --> 00:46:31,190
and and how hard the problem at you addy

1208
00:46:31,190 --> 00:46:34,230
and they chose this cuz back in the day

1209
00:46:34,230 --> 00:46:35,460
they didn't do joint so you didn't have

1210
00:46:35,460 --> 00:46:36,510
to worry about joint owner he's just

1211
00:46:36,510 --> 00:46:38,030
basically was picking what index to use

1212
00:46:38,030 --> 00:46:40,410
so the random walk approach would

1213
00:46:40,410 --> 00:46:43,410
actually work I don't think they do

1214
00:46:43,410 --> 00:46:44,910
anything sophisticated for the joins now

1215
00:46:44,910 --> 00:46:46,860
they might just use basic heuristic this

1216
00:46:46,860 --> 00:46:48,360
table or this collection is smaller than

1217
00:46:48,360 --> 00:46:49,680
this one so it's one versus the aunt

1218
00:46:49,680 --> 00:46:52,080
once the inner versus the outer they

1219
00:46:52,080 --> 00:46:53,790
support JavaScript UDS we'd actually

1220
00:46:53,790 --> 00:46:56,190
didn't talk about UDS for this semester

1221
00:46:56,190 --> 00:46:57,960
it's basically like a function you can

1222
00:46:57,960 --> 00:46:59,760
write in your query that gets invoked on

1223
00:46:59,760 --> 00:47:03,240
the data server side they do now support

1224
00:47:03,240 --> 00:47:05,580
joins and they now support also multi

1225
00:47:05,580 --> 00:47:08,970
document transactions though the early

1226
00:47:08,970 --> 00:47:10,290
benchmark numbers for MongoDB were

1227
00:47:10,290 --> 00:47:11,640
amazing like you could write data into

1228
00:47:11,640 --> 00:47:13,800
it very quickly because what they were

1229
00:47:13,800 --> 00:47:14,940
doing is one they weren't doing

1230
00:47:14,940 --> 00:47:17,040
transactions and they weren't actually

1231
00:47:17,040 --> 00:47:18,660
guaranteeing anything was actually

1232
00:47:18,660 --> 00:47:20,550
written to disk when you got response

1233
00:47:20,550 --> 00:47:23,490
back that you're right succeeded was

1234
00:47:23,490 --> 00:47:25,260
actually even worse of that if the

1235
00:47:25,260 --> 00:47:27,000
database ever got the packet for your

1236
00:47:27,000 --> 00:47:28,620
right they'd immediately come back when

1237
00:47:28,620 --> 00:47:29,730
to acknowledge and say yeah we got it

1238
00:47:29,730 --> 00:47:31,560
then at some later point would act to

1239
00:47:31,560 --> 00:47:33,530
the right would actually be executed and

1240
00:47:33,530 --> 00:47:36,270
in log to disk so if you wanted to see

1241
00:47:36,270 --> 00:47:37,950
whether you're right actually made it to

1242
00:47:37,950 --> 00:47:39,960
disk yet when you got back the response

1243
00:47:39,960 --> 00:47:41,250
you had to go back again and say hey did

1244
00:47:41,250 --> 00:47:43,140
my right make it alright she had to do

1245
00:47:43,140 --> 00:47:44,370
two round-trips to see whether your

1246
00:47:44,370 --> 00:47:46,650
right was actually successful

1247
00:47:46,650 --> 00:47:48,240
that used to be default for a long time

1248
00:47:48,240 --> 00:47:49,770
so if you look at the early benchmark

1249
00:47:49,770 --> 00:47:51,660
numbers for MongoDB they're amazing

1250
00:47:51,660 --> 00:47:54,960
then 2013 or 2012 they actually turned

1251
00:47:54,960 --> 00:47:57,810
that off it's known only by default all

1252
00:47:57,810 --> 00:47:58,770
right now they're actually doing right

1253
00:47:58,770 --> 00:48:01,890
had log and we'll talk about a second

1254
00:48:01,890 --> 00:48:03,000
and they support multi dublin

1255
00:48:03,000 --> 00:48:04,050
transactions across multiple machines

1256
00:48:04,050 --> 00:48:06,360
which is impressive it's not not easy to

1257
00:48:06,360 --> 00:48:09,570
do alright so the system architecture I

1258
00:48:09,570 --> 00:48:10,560
think we've already talked about before

1259
00:48:10,560 --> 00:48:12,240
it's a heterogeneous distributed

1260
00:48:12,240 --> 00:48:13,500
components shared-nothing

1261
00:48:13,500 --> 00:48:15,450
the centralized query router they're

1262
00:48:15,450 --> 00:48:17,190
doing master slave applications you can

1263
00:48:17,190 --> 00:48:18,720
have your rights from from

1264
00:48:18,720 --> 00:48:20,340
when masternode a master partitioner

1265
00:48:20,340 --> 00:48:23,010
shard will go off to other shards so

1266
00:48:23,010 --> 00:48:24,750
part of reason I think manga Dini was

1267
00:48:24,750 --> 00:48:27,750
very successful in the early days was

1268
00:48:27,750 --> 00:48:30,750
they actually supported Auto sharding so

1269
00:48:30,750 --> 00:48:32,820
the idea was here that like you just

1270
00:48:32,820 --> 00:48:34,580
start shoving data into your database

1271
00:48:34,580 --> 00:48:37,650
and you know it'll be distribute across

1272
00:48:37,650 --> 00:48:39,720
multiple nodes but then if one of those

1273
00:48:39,720 --> 00:48:41,760
nodes gets too full mahogany will

1274
00:48:41,760 --> 00:48:43,680
automatically move your data around to

1275
00:48:43,680 --> 00:48:46,830
balance things out it didn't always work

1276
00:48:46,830 --> 00:48:48,150
the way people thought it was going to

1277
00:48:48,150 --> 00:48:52,230
work but you know back in like 2010 when

1278
00:48:52,230 --> 00:48:54,270
I would go out to Silicon Valley and you

1279
00:48:54,270 --> 00:48:56,160
ask people like you know oh they're

1280
00:48:56,160 --> 00:48:57,359
doing a startup and they're basing it on

1281
00:48:57,359 --> 00:48:59,640
MongoDB you ask him why and maybe say oh

1282
00:48:59,640 --> 00:49:01,020
because this auto sharding thing was a

1283
00:49:01,020 --> 00:49:02,760
big deal for them because you know at

1284
00:49:02,760 --> 00:49:03,900
the very beginning most people don't

1285
00:49:03,900 --> 00:49:04,950
have much data because you're you know

1286
00:49:04,950 --> 00:49:05,970
you're start-up you have a stupid

1287
00:49:05,970 --> 00:49:07,619
Twitter app no one's using it you can

1288
00:49:07,619 --> 00:49:09,300
run on single machine but of course no

1289
00:49:09,300 --> 00:49:10,410
one doesn't start out thinking that

1290
00:49:10,410 --> 00:49:11,940
they're gonna fail everything everyone

1291
00:49:11,940 --> 00:49:13,080
thinks they're gonna be big so of course

1292
00:49:13,080 --> 00:49:14,520
I'm gonna need you know 20 machines in

1293
00:49:14,520 --> 00:49:16,230
the future so I wanna make sure MongoDB

1294
00:49:16,230 --> 00:49:17,910
can scale it with me right with with my

1295
00:49:17,910 --> 00:49:19,740
sequel and Postgres and other relation

1296
00:49:19,740 --> 00:49:20,940
databases at the time you couldn't do

1297
00:49:20,940 --> 00:49:23,970
that so that I think this was a big deal

1298
00:49:23,970 --> 00:49:26,480
but there's a famous Foursquare outage

1299
00:49:26,480 --> 00:49:28,859
51 it was super Foursquare is think of

1300
00:49:28,859 --> 00:49:31,230
like how to describe this

1301
00:49:31,230 --> 00:49:32,640
it was app you could check in what

1302
00:49:32,640 --> 00:49:33,930
location you were in it's still around

1303
00:49:33,930 --> 00:49:36,750
but it's not not sort of the not not a

1304
00:49:36,750 --> 00:49:38,609
phone app everyone uses but they were

1305
00:49:38,609 --> 00:49:40,470
using MongoDB and there was a famous

1306
00:49:40,470 --> 00:49:41,940
like you know multi-day outage because

1307
00:49:41,940 --> 00:49:44,570
the auto sharding stuff got stuck

1308
00:49:44,570 --> 00:49:46,770
alright so here's the architecture again

1309
00:49:46,770 --> 00:49:48,810
we talked about this before and we have

1310
00:49:48,810 --> 00:49:50,250
different type node types we have

1311
00:49:50,250 --> 00:49:51,599
routers we have config server and we

1312
00:49:51,599 --> 00:49:53,849
have a shards so every query from the

1313
00:49:53,849 --> 00:49:55,109
application always goes to the router

1314
00:49:55,109 --> 00:49:57,210
and the router says oh I know I want to

1315
00:49:57,210 --> 00:49:58,710
look up ID 101 but I don't know

1316
00:49:58,710 --> 00:50:00,510
information about where that is so I go

1317
00:50:00,510 --> 00:50:01,800
to the config server to config server

1318
00:50:01,800 --> 00:50:03,510
tells me and it looks in the chart table

1319
00:50:03,510 --> 00:50:05,280
it says the data you want is that it's

1320
00:50:05,280 --> 00:50:07,230
located it's node so then now the router

1321
00:50:07,230 --> 00:50:08,609
knows how to send the query to the right

1322
00:50:08,609 --> 00:50:11,160
location or it could blast it out to all

1323
00:50:11,160 --> 00:50:12,900
of them so again this is important

1324
00:50:12,900 --> 00:50:14,160
distinction between the scuba stuff and

1325
00:50:14,160 --> 00:50:15,780
we're talking about here scuba doesn't

1326
00:50:15,780 --> 00:50:17,130
haunt have it this partition or sharding

1327
00:50:17,130 --> 00:50:19,760
table it blasts the query to everyone in

1328
00:50:19,760 --> 00:50:21,000
MongoDB

1329
00:50:21,000 --> 00:50:22,440
since you don't want to waste resources

1330
00:50:22,440 --> 00:50:23,460
because you're trying to run you know

1331
00:50:23,460 --> 00:50:24,930
update query ISM for your website real

1332
00:50:24,930 --> 00:50:26,670
quickly you you maintain this

1333
00:50:26,670 --> 00:50:27,869
information to figure out exactly where

1334
00:50:27,869 --> 00:50:29,160
the query needs to go so you only touch

1335
00:50:29,160 --> 00:50:30,300
them the data you only touch you can do

1336
00:50:30,300 --> 00:50:34,460
that has the exact data you need yes

1337
00:50:35,210 --> 00:50:37,290
so a question is it sort of catching on

1338
00:50:37,290 --> 00:50:38,730
the router yes so like you wouldn't

1339
00:50:38,730 --> 00:50:40,860
always have to do this but this would be

1340
00:50:40,860 --> 00:50:43,140
the this would consider to be stateless

1341
00:50:43,140 --> 00:50:45,750
so if I crash I come back I just I get

1342
00:50:45,750 --> 00:50:48,690
my cache version from this again but any

1343
00:50:48,690 --> 00:50:50,400
update to like if I say I'm doing the

1344
00:50:50,400 --> 00:50:51,900
auto shouting stuff and I add a new node

1345
00:50:51,900 --> 00:50:53,880
right move some of data to another thing

1346
00:50:53,880 --> 00:50:56,040
I update this thing and that's done as a

1347
00:50:56,040 --> 00:51:03,030
transaction yes what is the origin of

1348
00:51:03,030 --> 00:51:09,450
this what do you mean oh the naming oh I

1349
00:51:09,450 --> 00:51:11,460
think just means humungous I

1350
00:51:11,460 --> 00:51:14,190
thought it is right so and so this is

1351
00:51:14,190 --> 00:51:16,470
like actually the s I don't know that is

1352
00:51:16,470 --> 00:51:21,080
but like maith backwards I don't know no

1353
00:51:21,110 --> 00:51:24,150
yeah it's this demon or data is PI just

1354
00:51:24,150 --> 00:51:26,490
demon and asks I don't know what

1355
00:51:26,490 --> 00:51:28,020
that means yeah I don't know the ask

1356
00:51:28,020 --> 00:51:34,920
means so another thing I said during

1357
00:51:34,920 --> 00:51:37,710
this semester was that never use MF for

1358
00:51:37,710 --> 00:51:38,280
your Davis

1359
00:51:38,280 --> 00:51:41,100
well when month when MongoDB first came

1360
00:51:41,100 --> 00:51:42,600
out they were using em after their Davis

1361
00:51:42,600 --> 00:51:46,110
and we actually did a little study on MF

1362
00:51:46,110 --> 00:51:48,960
database systems in my in our opinion we

1363
00:51:48,960 --> 00:51:50,520
haven't published us yet the MongoDB

1364
00:51:50,520 --> 00:51:52,470
implementation of using MF is probably

1365
00:51:52,470 --> 00:51:54,030
the most sophisticated one that we've

1366
00:51:54,030 --> 00:51:56,370
ever seen it's probably the best one but

1367
00:51:56,370 --> 00:51:59,610
it still sucks it's still bad alright so

1368
00:51:59,610 --> 00:52:01,530
basically what happened is the way they

1369
00:52:01,530 --> 00:52:04,520
would use a map is they would have

1370
00:52:04,520 --> 00:52:06,750
they'd basically maintain multiple

1371
00:52:06,750 --> 00:52:10,140
copies of the database in memory and you

1372
00:52:10,140 --> 00:52:11,970
would do your updates to this like sort

1373
00:52:11,970 --> 00:52:13,890
of private copy that would then get read

1374
00:52:13,890 --> 00:52:15,330
to disk and then you had to replay the

1375
00:52:15,330 --> 00:52:17,100
log to update the sort of the master

1376
00:52:17,100 --> 00:52:19,950
copy and so the OS could swap things out

1377
00:52:19,950 --> 00:52:22,050
anytime it wanted it was a big big pace

1378
00:52:22,050 --> 00:52:24,390
for them the other big problem they had

1379
00:52:24,390 --> 00:52:25,860
was they had a single lock for the

1380
00:52:25,860 --> 00:52:27,240
database now there's a not in time

1381
00:52:27,240 --> 00:52:28,530
because they were using M map but I

1382
00:52:28,530 --> 00:52:31,710
think it's sort of probably probably

1383
00:52:31,710 --> 00:52:34,020
helped make things easier using M map so

1384
00:52:34,020 --> 00:52:35,550
that means that in the entire database

1385
00:52:35,550 --> 00:52:36,810
system even though you may be split

1386
00:52:36,810 --> 00:52:38,760
across multiple machines in the earlier

1387
00:52:38,760 --> 00:52:40,020
versions as a MongoDB you could only

1388
00:52:40,020 --> 00:52:42,690
have one writer in the entire cluster at

1389
00:52:42,690 --> 00:52:45,000
a time so if I have 20 machines I have

1390
00:52:45,000 --> 00:52:46,589
one query that comes along I basic

1391
00:52:46,589 --> 00:52:48,479
Lock all 20 machines to do update on one

1392
00:52:48,479 --> 00:52:51,269
of them and then in the newer versions

1393
00:52:51,269 --> 00:52:53,460
of since version 3 they got rid of

1394
00:52:53,460 --> 00:52:54,960
this so what they end up doing was they

1395
00:52:54,960 --> 00:52:58,109
bought this this storage engine startup

1396
00:52:58,109 --> 00:53:00,359
called wire tiger which was founded by

1397
00:53:00,359 --> 00:53:02,549
the guy that one of the guys that

1398
00:53:02,549 --> 00:53:05,369
invented Berkeley DB Berkeley DB is an

1399
00:53:05,369 --> 00:53:06,599
embedded database wire targeted at a

1400
00:53:06,599 --> 00:53:08,339
Davis we're gonna talk about this too

1401
00:53:08,339 --> 00:53:11,609
much but post best my sequel these are

1402
00:53:11,609 --> 00:53:13,440
all database systems that like run as a

1403
00:53:13,440 --> 00:53:15,569
standalone demon or standalone system

1404
00:53:15,569 --> 00:53:17,249
and you have multiple clients connecting

1405
00:53:17,249 --> 00:53:20,099
them Seco light is typically used as an

1406
00:53:20,099 --> 00:53:21,509
embedded database you embed it inside

1407
00:53:21,509 --> 00:53:23,999
your application and it provides you the

1408
00:53:23,999 --> 00:53:25,289
database functionality but when your

1409
00:53:25,289 --> 00:53:26,849
application closes the database closes

1410
00:53:26,849 --> 00:53:29,069
so why are Tiger is sort of like sequel

1411
00:53:29,069 --> 00:53:31,319
light but it doesn't support sequel it

1412
00:53:31,319 --> 00:53:34,369
supports like a key value store API so

1413
00:53:34,369 --> 00:53:38,400
probably one of the best acquisitions in

1414
00:53:38,400 --> 00:53:40,619
a long time they bought why are tiger

1415
00:53:40,619 --> 00:53:42,239
and they replace the end map stuff with

1416
00:53:42,239 --> 00:53:44,400
with the wire tiger engine so when you

1417
00:53:44,400 --> 00:53:46,920
run when you run MongoDB now you get the

1418
00:53:46,920 --> 00:53:48,869
wire type engine by default and it's

1419
00:53:48,869 --> 00:53:57,660
amazing questions are yes this question

1420
00:53:57,660 --> 00:53:59,309
is if you think MF is so complex why

1421
00:53:59,309 --> 00:54:04,319
would you use this so again I can't I

1422
00:54:04,319 --> 00:54:07,049
want to prove it scientifically I can't

1423
00:54:07,049 --> 00:54:08,279
yet so just take everything what I say

1424
00:54:08,279 --> 00:54:11,400
like this is my opinion M map is like a

1425
00:54:11,400 --> 00:54:13,769
seductress right it's like it's this

1426
00:54:13,769 --> 00:54:15,180
sexy thing that looks like gives you

1427
00:54:15,180 --> 00:54:16,529
what you want for a buffer pool manager

1428
00:54:16,529 --> 00:54:18,569
right without having to do it cuz the OS

1429
00:54:18,569 --> 00:54:19,319
does it for you

1430
00:54:19,319 --> 00:54:20,940
you don't need an eviction policy the OS

1431
00:54:20,940 --> 00:54:21,839
does that you don't need to worry about

1432
00:54:21,839 --> 00:54:24,059
paging you know keeping track of dirty

1433
00:54:24,059 --> 00:54:25,170
pages and things I think oh that doesn't

1434
00:54:25,170 --> 00:54:26,880
that so it's this thing that looks like

1435
00:54:26,880 --> 00:54:28,079
it's gonna give you everything you want

1436
00:54:28,079 --> 00:54:32,069
but it's like it's the extra 5% you

1437
00:54:32,069 --> 00:54:34,019
actually need to actually make it be

1438
00:54:34,019 --> 00:54:35,880
durable and safe that's when all the

1439
00:54:35,880 --> 00:54:38,819
problems come in so like it's sort of

1440
00:54:38,819 --> 00:54:39,960
like the query optimizer it's a Tibetan

1441
00:54:39,960 --> 00:54:41,160
query optimizer let's do something

1442
00:54:41,160 --> 00:54:42,509
really simple and just blast everything

1443
00:54:42,509 --> 00:54:44,819
out and see what comes back first so set

1444
00:54:44,819 --> 00:54:45,900
it bearing a buffer pool manager I'll

1445
00:54:45,900 --> 00:54:46,829
just use the os's

1446
00:54:46,829 --> 00:54:50,719
profitable cache or the man map cache

1447
00:54:55,110 --> 00:55:00,910
let's take that one off line hey me

1448
00:55:00,910 --> 00:55:03,000
Elliot I mean L is a really smart guy

1449
00:55:03,000 --> 00:55:07,000
the co-founder and I've wildly

1450
00:55:07,000 --> 00:55:09,040
successful right like it's a public

1451
00:55:09,040 --> 00:55:16,270
company right I think you know by using

1452
00:55:16,270 --> 00:55:21,250
M map although it causes problems in it

1453
00:55:21,250 --> 00:55:22,780
can cause problems when you really start

1454
00:55:22,780 --> 00:55:24,190
to try to scale up and scale and Hammer

1455
00:55:24,190 --> 00:55:26,650
the system it allows you to build a

1456
00:55:26,650 --> 00:55:27,370
system pretty quickly

1457
00:55:27,370 --> 00:55:29,350
so instead of spending six months having

1458
00:55:29,350 --> 00:55:31,000
to develop a buffer manager that's you

1459
00:55:31,000 --> 00:55:32,530
know safe and transactional and things

1460
00:55:32,530 --> 00:55:32,950
like that

1461
00:55:32,950 --> 00:55:36,760
use these OS you know and map and then

1462
00:55:36,760 --> 00:55:38,080
when they got enough customers they got

1463
00:55:38,080 --> 00:55:40,330
enough money they bought wire tiger and

1464
00:55:40,330 --> 00:55:44,260
did it right my secret was the same way

1465
00:55:44,260 --> 00:55:46,120
right Mike well he didn't use em map

1466
00:55:46,120 --> 00:55:49,450
please I don't think like my Siegel with

1467
00:55:49,450 --> 00:55:51,340
nodb is amazing inner DB is fantastic

1468
00:55:51,340 --> 00:55:53,380
it's a solid database engine storage

1469
00:55:53,380 --> 00:55:57,580
engine but the original engine they use

1470
00:55:57,580 --> 00:56:00,100
was my ISAM that thing sucks that thing

1471
00:56:00,100 --> 00:56:01,750
lost data all the time right you it

1472
00:56:01,750 --> 00:56:04,600
would you have corruption and so but it

1473
00:56:04,600 --> 00:56:05,650
got my C go up and running pretty

1474
00:56:05,650 --> 00:56:07,000
quickly a lot of people are using it and

1475
00:56:07,000 --> 00:56:09,190
then eventually in a DVD came along and

1476
00:56:09,190 --> 00:56:10,450
my sequel bought them out and started

1477
00:56:10,450 --> 00:56:13,560
using it that's a not a very uncommon

1478
00:56:13,560 --> 00:56:18,910
strategy for Davis business all right

1479
00:56:18,910 --> 00:56:23,290
let's do a demo so when we have to tell

1480
00:56:23,290 --> 00:56:26,760
you is semi semi illegal

1481
00:56:26,760 --> 00:56:33,359
alright anybody is about yes this

1482
00:56:33,359 --> 00:56:34,650
question is why would you want to maybe

1483
00:56:34,650 --> 00:56:39,030
use for others so the I think that

1484
00:56:39,030 --> 00:56:40,380
being in a stupid architecture is

1485
00:56:40,380 --> 00:56:42,500
matters a lot

1486
00:56:42,500 --> 00:56:46,530
the the document model is actually

1487
00:56:46,530 --> 00:56:49,200
better for application development right

1488
00:56:49,200 --> 00:56:50,609
think about you when you write Python

1489
00:56:50,609 --> 00:56:52,380
code you write Java code you're writing

1490
00:56:52,380 --> 00:56:53,490
an object it is object oriented

1491
00:56:53,490 --> 00:56:56,880
programming languages and so it kind of

1492
00:56:56,880 --> 00:56:59,430
if you can have now your object just be

1493
00:56:59,430 --> 00:57:01,500
written out as a JSON document and then

1494
00:57:01,500 --> 00:57:03,390
putting the Davis and fetch it back in

1495
00:57:03,390 --> 00:57:04,560
and we instantiate in your application

1496
00:57:04,560 --> 00:57:08,480
code that could potentially be faster

1497
00:57:08,480 --> 00:57:10,470
but the thing I would stress though

1498
00:57:10,470 --> 00:57:12,869
there's nothing about what MongoDB is

1499
00:57:12,869 --> 00:57:15,060
doing because it's document database

1500
00:57:15,060 --> 00:57:16,680
system that is different than anything

1501
00:57:16,680 --> 00:57:18,839
we talked about this entire semester why

1502
00:57:18,839 --> 00:57:20,160
are tired doesn't know that it's

1503
00:57:20,160 --> 00:57:21,960
actually being used for a document

1504
00:57:21,960 --> 00:57:23,640
database system it's doing right ahead

1505
00:57:23,640 --> 00:57:25,770
logging it's doing all the crash

1506
00:57:25,770 --> 00:57:26,790
recovery stuff we're doing it's doing

1507
00:57:26,790 --> 00:57:28,619
transactions underneath our covers in

1508
00:57:28,619 --> 00:57:30,589
the same way that we talked about so

1509
00:57:30,589 --> 00:57:32,730
there's nothing about in the document

1510
00:57:32,730 --> 00:57:35,310
that invalidates or changes anything we

1511
00:57:35,310 --> 00:57:36,990
talked about here today it's all at the

1512
00:57:36,990 --> 00:57:39,540
application level hey it's all sort of

1513
00:57:39,540 --> 00:57:41,310
client level to quit what the query

1514
00:57:41,310 --> 00:57:42,359
looks like what the query is actually

1515
00:57:42,359 --> 00:57:44,280
gonna do everything else below is

1516
00:57:44,280 --> 00:57:45,150
everything we talked about the entire

1517
00:57:45,150 --> 00:57:52,290
semester yes the question is do they use

1518
00:57:52,290 --> 00:57:53,369
special compression enemies so that

1519
00:57:53,369 --> 00:57:55,470
would be wire tiger I think it's just

1520
00:57:55,470 --> 00:58:06,150
snappy yeah yes again the the the older

1521
00:58:06,150 --> 00:58:07,650
versions the user name the default

1522
00:58:07,650 --> 00:58:09,270
username passwords test test it's not

1523
00:58:09,270 --> 00:58:18,329
that way anymore yes ok all right so the

1524
00:58:18,329 --> 00:58:20,609
last one we have 10 minutes left is

1525
00:58:20,609 --> 00:58:23,190
cockroach DB actually I was there in the

1526
00:58:23,190 --> 00:58:25,109
summer as well so when I went DB

1527
00:58:25,109 --> 00:58:26,910
and cockroach DB their headquarters are

1528
00:58:26,910 --> 00:58:28,859
in in New York City so when I was out

1529
00:58:28,859 --> 00:58:30,839
visiting cockroach or whatever I visited

1530
00:58:30,839 --> 00:58:32,339
both of them at the same time this is

1531
00:58:32,339 --> 00:58:33,540
their old office they had this nice

1532
00:58:33,540 --> 00:58:35,540
little pixel art thing for the cockroach

1533
00:58:35,540 --> 00:58:38,069
house and this is their newer office

1534
00:58:38,069 --> 00:58:39,510
though I was actually surprised how big

1535
00:58:39,510 --> 00:58:40,560
it actually is

1536
00:58:40,560 --> 00:58:43,260
I gave a game I gave a talk there they

1537
00:58:43,260 --> 00:58:45,840
just raised 55 million dollars as a

1538
00:58:45,840 --> 00:58:47,910
Series C round which is a little money

1539
00:58:47,910 --> 00:58:49,770
for a database company so that's

1540
00:58:49,770 --> 00:58:52,560
actually very impressive how do I assume

1541
00:58:52,560 --> 00:58:54,360
that means they're doing well so that's

1542
00:58:54,360 --> 00:58:58,410
good right so Krakow HDB started in 2015

1543
00:58:58,410 --> 00:59:01,590
by some X kugel employees they were I

1544
00:59:01,590 --> 00:59:03,750
think incorrectly characterized as the

1545
00:59:03,750 --> 00:59:05,880
open-source version a spanner from

1546
00:59:05,880 --> 00:59:09,330
Google spanner I don't think they ever

1547
00:59:09,330 --> 00:59:11,100
said that people sort of tributed that

1548
00:59:11,100 --> 00:59:12,900
to them I would not say that's true at

1549
00:59:12,900 --> 00:59:15,720
all cockroach TV is sort of a core

1550
00:59:15,720 --> 00:59:16,890
architecture is fundamentally different

1551
00:59:16,890 --> 00:59:18,960
than spanner and spanner has one magic

1552
00:59:18,960 --> 00:59:20,910
piece that nobody else has that

1553
00:59:20,910 --> 00:59:22,440
cockroach doesn't do and nobody else

1554
00:59:22,440 --> 00:59:24,570
does so is a decentralized

1555
00:59:24,570 --> 00:59:26,760
shared-nothing homogeneous database ISM

1556
00:59:26,760 --> 00:59:28,650
architecture and they're going to be

1557
00:59:28,650 --> 00:59:31,860
doing range partitioning the internal

1558
00:59:31,860 --> 00:59:33,750
storage engine they're gonna use is Rox

1559
00:59:33,750 --> 00:59:35,280
TB so the same question is why would

1560
00:59:35,280 --> 00:59:37,980
anyone want to use em map right well my

1561
00:59:37,980 --> 00:59:38,970
answer was because so you don't have to

1562
00:59:38,970 --> 00:59:41,280
build that piece yourself so cockroach

1563
00:59:41,280 --> 00:59:43,200
GP they then wouldn't spend time writing

1564
00:59:43,200 --> 00:59:45,690
a storage manager right the same way

1565
00:59:45,690 --> 00:59:46,890
that you know the wire tiger piece from

1566
00:59:46,890 --> 00:59:49,950
MongoDB so a lot of these newer database

1567
00:59:49,950 --> 00:59:51,360
system startups they're using rocks TV

1568
00:59:51,360 --> 00:59:53,310
or leveldb these embedded storage

1569
00:59:53,310 --> 00:59:54,810
engines so they don't have to worry

1570
00:59:54,810 --> 00:59:55,980
about right reading writing data from

1571
00:59:55,980 --> 00:59:57,780
disk and they worry about the high level

1572
00:59:57,780 --> 00:59:59,130
parts of like you know managing

1573
00:59:59,130 --> 01:00:02,070
transactions in a trivet environment so

1574
01:00:02,070 --> 01:00:03,780
they're going to be doing multi virtual

1575
01:00:03,780 --> 01:00:05,360
but optimistic you know optimistic a

1576
01:00:05,360 --> 01:00:08,460
commercial protocol and I know but this

1577
01:00:08,460 --> 01:00:09,750
is still true but they're only going to

1578
01:00:09,750 --> 01:00:11,540
support serializable snapshot isolation

1579
01:00:11,540 --> 01:00:14,270
so I I don't think they support the

1580
01:00:14,270 --> 01:00:17,670
other assistant isolation levels they

1581
01:00:17,670 --> 01:00:20,040
also speak the Postgres wire protocol so

1582
01:00:20,040 --> 01:00:21,120
that means that if you have an existing

1583
01:00:21,120 --> 01:00:23,790
post test application you can just in

1584
01:00:23,790 --> 01:00:26,970
theory point it to cockroach DB it's

1585
01:00:26,970 --> 01:00:28,590
pointing at progress now you migrate

1586
01:00:28,590 --> 01:00:30,030
your data bit over to cockroach DB and

1587
01:00:30,030 --> 01:00:33,000
you don't have to change potentially any

1588
01:00:33,000 --> 01:00:35,670
of the sequel it's not entirely true for

1589
01:00:35,670 --> 01:00:36,780
everything like there's some things that

1590
01:00:36,780 --> 01:00:38,880
are different like Auto increment keys

1591
01:00:38,880 --> 01:00:40,650
but in general it's migrating to a

1592
01:00:40,650 --> 01:00:43,290
cockroach even Postgres is a should not

1593
01:00:43,290 --> 01:00:46,980
be an owner snek so at its core

1594
01:00:46,980 --> 01:00:49,170
cockroach GB is a distributed key-value

1595
01:00:49,170 --> 01:00:50,850
store transaction attributed key value

1596
01:00:50,850 --> 01:00:52,470
store so that means that the lower

1597
01:00:52,470 --> 01:00:54,780
storage engine of the system

1598
01:00:54,780 --> 01:00:56,850
at rocks TB is a key value system but

1599
01:00:56,850 --> 01:00:58,350
then the way they're doing transactions

1600
01:00:58,350 --> 01:01:00,570
or the way they're managing the the

1601
01:01:00,570 --> 01:01:02,010
database across multiple machines is

1602
01:01:02,010 --> 01:01:03,570
essentially just going to be a key value

1603
01:01:03,570 --> 01:01:06,540
store and so so using that now they can

1604
01:01:06,540 --> 01:01:09,180
build layers above that to provide the

1605
01:01:09,180 --> 01:01:10,950
full sort of sequel compatibility that

1606
01:01:10,950 --> 01:01:13,080
you would want all right so once you get

1607
01:01:13,080 --> 01:01:15,360
past like the sequel query shows up they

1608
01:01:15,360 --> 01:01:17,340
can then convert that sequel query the

1609
01:01:17,340 --> 01:01:18,960
query plan is essentially going to be a

1610
01:01:18,960 --> 01:01:22,230
bunch of key value API calls that can

1611
01:01:22,230 --> 01:01:23,850
then read and write data from from

1612
01:01:23,850 --> 01:01:27,720
different nodes so the way they're going

1613
01:01:27,720 --> 01:01:30,030
to coordinate the updates throughout the

1614
01:01:30,030 --> 01:01:33,030
system is using raft raft is essentially

1615
01:01:33,030 --> 01:01:34,590
at a high level which same thing as

1616
01:01:34,590 --> 01:01:37,170
paxos it's a consensus protocol that

1617
01:01:37,170 --> 01:01:38,970
allows me to say when I make an update

1618
01:01:38,970 --> 01:01:40,590
and I want to commit a transaction

1619
01:01:40,590 --> 01:01:42,240
across multiple Sheen's everyone's gonna

1620
01:01:42,240 --> 01:01:45,030
agree or quorum has to agree that the

1621
01:01:45,030 --> 01:01:47,820
updates allowed to proceed or to occur

1622
01:01:47,820 --> 01:01:49,920
in order for that transaction to be able

1623
01:01:49,920 --> 01:01:53,790
to commit so the way they're going to do

1624
01:01:53,790 --> 01:01:58,080
OCC is through using timestamps it's

1625
01:01:58,080 --> 01:02:01,200
using what are called hybrid clocks so I

1626
01:02:01,200 --> 01:02:02,070
think I talked about this a little bit

1627
01:02:02,070 --> 01:02:04,020
or Prashant Agra this one we talked

1628
01:02:04,020 --> 01:02:07,170
about times not conjectural we need a

1629
01:02:07,170 --> 01:02:08,850
way to have a clock that we can you

1630
01:02:08,850 --> 01:02:10,710
nuclei identify every transaction and

1631
01:02:10,710 --> 01:02:12,270
that clock needs to always be always

1632
01:02:12,270 --> 01:02:13,650
increasing so we know what transaction

1633
01:02:13,650 --> 01:02:15,750
in the serialize will order as their

1634
01:02:15,750 --> 01:02:16,830
neck solution what transaction came

1635
01:02:16,830 --> 01:02:19,980
before the other so you could just use

1636
01:02:19,980 --> 01:02:21,390
the physical clock which is you know

1637
01:02:21,390 --> 01:02:23,130
from from the actual CPU like I'm a

1638
01:02:23,130 --> 01:02:24,510
machine itself what's the system time

1639
01:02:24,510 --> 01:02:26,670
but the problem in that one is that's

1640
01:02:26,670 --> 01:02:28,230
not going to be guaranteed to be highly

1641
01:02:28,230 --> 01:02:30,170
synchronized across multiple machines

1642
01:02:30,170 --> 01:02:34,170
right there's every computer has a clock

1643
01:02:34,170 --> 01:02:36,150
that clock is not super super accurate

1644
01:02:36,150 --> 01:02:38,700
it's not like an atomic clock right this

1645
01:02:38,700 --> 01:02:40,140
can mean you know counting electrons

1646
01:02:40,140 --> 01:02:43,050
coming off of an atom it's gonna be some

1647
01:02:43,050 --> 01:02:44,520
kind of quartz crystal thing that it has

1648
01:02:44,520 --> 01:02:46,290
to approximate so now you can have a

1649
01:02:46,290 --> 01:02:48,240
bunch of skew and your clocks and so now

1650
01:02:48,240 --> 01:02:49,350
what could happen is you know

1651
01:02:49,350 --> 01:02:51,240
transaction rise on one node it thinks

1652
01:02:51,240 --> 01:02:52,890
it's time stamp 1 another transaction

1653
01:02:52,890 --> 01:02:54,330
Rises another node it thinks it's time

1654
01:02:54,330 --> 01:02:57,980
stamp 1 and now I have a conflict I have

1655
01:02:57,980 --> 01:03:00,840
pie of a yeah complicated that I've

1656
01:03:00,840 --> 01:03:02,820
resolved so the way they're going to

1657
01:03:02,820 --> 01:03:04,230
handle that is through a hybrid clock

1658
01:03:04,230 --> 01:03:06,090
where you'll still use the system clock

1659
01:03:06,090 --> 01:03:08,250
to try to get what the current time is

1660
01:03:08,250 --> 01:03:09,900
but then you also used a logical clock

1661
01:03:09,900 --> 01:03:12,330
that allows you to have globally ordered

1662
01:03:12,330 --> 01:03:13,440
transactions without having to

1663
01:03:13,440 --> 01:03:15,630
synchronize every single time so

1664
01:03:15,630 --> 01:03:16,710
basically took a little calendar that

1665
01:03:16,710 --> 01:03:18,660
says here's my current timestamp and I

1666
01:03:18,660 --> 01:03:21,030
just my machine would add one to a disk

1667
01:03:21,030 --> 01:03:23,420
illogical counter to increase it so

1668
01:03:23,420 --> 01:03:26,270
what's gonna happen is under OCC

1669
01:03:26,270 --> 01:03:27,930
transactions gonna stage all those

1670
01:03:27,930 --> 01:03:29,640
rights and the system says these are the

1671
01:03:29,640 --> 01:03:30,750
modifications I want to make yes

1672
01:03:30,750 --> 01:03:37,320
question his question is how's a hybrid

1673
01:03:37,320 --> 01:03:38,460
clock different than the Google spender

1674
01:03:38,460 --> 01:03:42,380
clock the Google spanner clock is not

1675
01:03:42,380 --> 01:03:44,840
the Google spent to the treatment I

1676
01:03:44,840 --> 01:03:47,270
don't get too much into spanner

1677
01:03:47,270 --> 01:03:52,520
Google spanner is relying on the the

1678
01:03:52,520 --> 01:03:55,170
harbour clocks to have super accurate

1679
01:03:55,170 --> 01:03:56,550
times that are synchronized across all

1680
01:03:56,550 --> 01:03:59,550
the machines and the true time API gives

1681
01:03:59,550 --> 01:04:02,520
you a bound of how long we have to wait

1682
01:04:02,520 --> 01:04:03,599
for someone to show up with a lower

1683
01:04:03,599 --> 01:04:06,450
timestamp it's a way to basically is

1684
01:04:06,450 --> 01:04:09,030
like this is like true time but using

1685
01:04:09,030 --> 01:04:12,780
only software so if you have really bad

1686
01:04:12,780 --> 01:04:14,490
clock drift like this one machines one

1687
01:04:14,490 --> 01:04:15,900
hour behind another machine no

1688
01:04:15,900 --> 01:04:17,609
transaction could potentially have a

1689
01:04:17,609 --> 01:04:19,650
complete because you yeah every

1690
01:04:19,650 --> 01:04:20,550
transaction think they're gonna in the

1691
01:04:20,550 --> 01:04:22,859
past in the future get messed up so you

1692
01:04:22,859 --> 01:04:25,230
have to make sure that you try to keep

1693
01:04:25,230 --> 01:04:27,109
the clocks in the sink using like NTP

1694
01:04:27,109 --> 01:04:29,130
spanner doesn't do that spanner does

1695
01:04:29,130 --> 01:04:30,869
that you know the GPS satellites plus

1696
01:04:30,869 --> 01:04:32,790
the atomic locks they have super fine

1697
01:04:32,790 --> 01:04:39,089
granularity all right so again different

1698
01:04:39,089 --> 01:04:41,190
than scuba all the metadata about where

1699
01:04:41,190 --> 01:04:42,420
the data exists what the transaction

1700
01:04:42,420 --> 01:04:44,700
state is that's when the Vista exists in

1701
01:04:44,700 --> 01:04:46,020
their own key value store as well and

1702
01:04:46,020 --> 01:04:48,690
that's all considered transaction so

1703
01:04:48,690 --> 01:04:50,609
let's look at a simple example here so

1704
01:04:50,609 --> 01:04:53,280
we have our application comes along and

1705
01:04:53,280 --> 01:04:54,990
what may be update data and this

1706
01:04:54,990 --> 01:04:58,380
Klosterman so again different from scuba

1707
01:04:58,380 --> 01:04:59,790
we maintain a partition table just like

1708
01:04:59,790 --> 01:05:01,560
a MongoDB to keep track of what node is

1709
01:05:01,560 --> 01:05:05,160
responsible for what range of data so

1710
01:05:05,160 --> 01:05:07,109
when my query shows up the first thing

1711
01:05:07,109 --> 01:05:10,619
like the consult is my is this partition

1712
01:05:10,619 --> 01:05:11,910
table which actually would be replicated

1713
01:05:11,910 --> 01:05:14,640
on every single machine and say well I

1714
01:05:14,640 --> 01:05:17,970
want to access key or ID equals 50 what

1715
01:05:17,970 --> 01:05:20,099
machine what what node is the leader for

1716
01:05:20,099 --> 01:05:21,060
that

1717
01:05:21,060 --> 01:05:22,860
and then in this case here it's this guy

1718
01:05:22,860 --> 01:05:25,170
so now my right has to go here did you

1719
01:05:25,170 --> 01:05:27,660
my update and then the update has to get

1720
01:05:27,660 --> 01:05:29,760
propagated to the other nodes and then

1721
01:05:29,760 --> 01:05:32,400
we use raft to to get everyone to agree

1722
01:05:32,400 --> 01:05:33,660
that we're gonna go ahead and commit

1723
01:05:33,660 --> 01:05:35,330
this transaction

1724
01:05:35,330 --> 01:05:39,390
all right so instead of using two phase

1725
01:05:39,390 --> 01:05:41,700
commit they're just using raft so now if

1726
01:05:41,700 --> 01:05:43,350
I want to do now I read say for this

1727
01:05:43,350 --> 01:05:46,110
this ID goes 150 well I'm always going

1728
01:05:46,110 --> 01:05:48,450
to go to the leader where this guy is

1729
01:05:48,450 --> 01:05:51,150
located even though I have multiple

1730
01:05:51,150 --> 01:05:52,770
copies of the data on different notes

1731
01:05:52,770 --> 01:05:55,440
and I in theory I could read at these

1732
01:05:55,440 --> 01:05:57,240
other nodes but I always want to do my

1733
01:05:57,240 --> 01:05:59,700
read on the leader to make sure that I'm

1734
01:05:59,700 --> 01:06:01,230
reading the most you know the most

1735
01:06:01,230 --> 01:06:02,820
consistent or up-to-date version of it

1736
01:06:02,820 --> 01:06:04,650
because maybe these other nodes have not

1737
01:06:04,650 --> 01:06:06,840
seen the latest update yet because you

1738
01:06:06,840 --> 01:06:08,490
and a raft you only need a quorum you

1739
01:06:08,490 --> 01:06:10,140
don't need to have a every node agree

1740
01:06:10,140 --> 01:06:11,550
which is different you know to Bayes

1741
01:06:11,550 --> 01:06:13,320
committee everyone this one you always

1742
01:06:13,320 --> 01:06:14,910
need a quorum so some node could be

1743
01:06:14,910 --> 01:06:16,560
behind but you were still allowed of

1744
01:06:16,560 --> 01:06:18,720
committed transaction so to handle that

1745
01:06:18,720 --> 01:06:20,160
all the reads are always going to go to

1746
01:06:20,160 --> 01:06:21,840
whatever the leader node is for an ID

1747
01:06:21,840 --> 01:06:25,290
and to avoid having every query go to

1748
01:06:25,290 --> 01:06:27,420
just a one node that's why we have this

1749
01:06:27,420 --> 01:06:28,620
table appeared to tell us which one's

1750
01:06:28,620 --> 01:06:30,030
the leader and we're going to distribute

1751
01:06:30,030 --> 01:06:31,590
that across multiple nodes so the guest

1752
01:06:31,590 --> 01:06:33,840
so the reads can then be scattered

1753
01:06:33,840 --> 01:06:39,360
across multiple machines again it's just

1754
01:06:39,360 --> 01:06:41,880
doing the consensus protocol the

1755
01:06:41,880 --> 01:06:43,860
replicated replicated rights that we

1756
01:06:43,860 --> 01:06:47,160
talked about in the semester the hard so

1757
01:06:47,160 --> 01:06:48,990
the core concepts aren't any error arm

1758
01:06:48,990 --> 01:06:50,610
aren't mind blowing aren't dramatically

1759
01:06:50,610 --> 01:06:51,510
different than what we've already talked

1760
01:06:51,510 --> 01:06:53,220
about the hard part is the engineering

1761
01:06:53,220 --> 01:06:55,710
making this actually work and that's

1762
01:06:55,710 --> 01:06:56,700
what you know that that's what they're

1763
01:06:56,700 --> 01:06:58,290
spending all their time to make happen

1764
01:06:58,290 --> 01:07:00,270
so that you don't have you know lost

1765
01:07:00,270 --> 01:07:01,860
rights or missing updates and things

1766
01:07:01,860 --> 01:07:07,560
like that okay all right so let's finish

1767
01:07:07,560 --> 01:07:11,160
up so hopefully I've conveyed throughout

1768
01:07:11,160 --> 01:07:13,320
the entire semester that I love

1769
01:07:13,320 --> 01:07:14,370
databases they're awesome

1770
01:07:14,370 --> 01:07:15,900
Joran hit him you're gonna hit him

1771
01:07:15,900 --> 01:07:17,670
throughout the rest your life and so

1772
01:07:17,670 --> 01:07:19,650
what hopefully this course has provided

1773
01:07:19,650 --> 01:07:23,150
for you is the ability to say you know

1774
01:07:23,150 --> 01:07:25,020
something's running slow in our

1775
01:07:25,020 --> 01:07:26,520
application because it's the database

1776
01:07:26,520 --> 01:07:28,350
what kind of database system am i

1777
01:07:28,350 --> 01:07:30,000
running on what is my data look like

1778
01:07:30,000 --> 01:07:31,800
what does my query look like it allows

1779
01:07:31,800 --> 01:07:33,060
you to now make an informed decision

1780
01:07:33,060 --> 01:07:34,590
about

1781
01:07:34,590 --> 01:07:36,060
how these systems work and whether

1782
01:07:36,060 --> 01:07:37,290
you're you know you're choosing the

1783
01:07:37,290 --> 01:07:38,820
right database system for your given

1784
01:07:38,820 --> 01:07:40,250
application or workload environment

1785
01:07:40,250 --> 01:07:42,750
right because not everyone's gonna go

1786
01:07:42,750 --> 01:07:45,540
off and build a database system but I

1787
01:07:45,540 --> 01:07:46,980
guarantee you no matter what you do

1788
01:07:46,980 --> 01:07:48,990
especially you mean even if you don't

1789
01:07:48,990 --> 01:07:50,100
stay in the tech field

1790
01:07:50,100 --> 01:07:51,210
you're gonna chrome across databases

1791
01:07:51,210 --> 01:07:54,390
like Excel is a database I said we're

1792
01:07:54,390 --> 01:07:57,260
using Excel you're using a database so

1793
01:07:57,260 --> 01:07:59,730
and the other thing I would say also to

1794
01:07:59,730 --> 01:08:02,400
that's super-important is I would avoid

1795
01:08:02,400 --> 01:08:04,980
premature optimizations in deciding what

1796
01:08:04,980 --> 01:08:07,980
data system to use always start with

1797
01:08:07,980 --> 01:08:10,950
something that is is maybe it's just

1798
01:08:10,950 --> 01:08:12,270
good enough of what you need right now

1799
01:08:12,270 --> 01:08:14,220
and don't worry about you know

1800
01:08:14,220 --> 01:08:15,480
potentially scaling up to you know

1801
01:08:15,480 --> 01:08:17,460
millions of users in the future all

1802
01:08:17,460 --> 01:08:18,420
right that was sort of my mom gonna be

1803
01:08:18,420 --> 01:08:20,069
example everyone said oh my startup is

1804
01:08:20,069 --> 01:08:21,120
gonna be huge I don't have a million

1805
01:08:21,120 --> 01:08:22,589
customers of course I wanted to show you

1806
01:08:22,589 --> 01:08:24,510
a database that can scale out well know

1807
01:08:24,510 --> 01:08:25,920
in the very beginning you probably just

1808
01:08:25,920 --> 01:08:27,569
use Postgres or my sequel on a single

1809
01:08:27,569 --> 01:08:29,850
box and that'll get you you know maybe

1810
01:08:29,850 --> 01:08:31,170
for the next two years that'll be good

1811
01:08:31,170 --> 01:08:32,460
enough but maybe you buy some better

1812
01:08:32,460 --> 01:08:33,839
hardware and scale up a little bit more

1813
01:08:33,839 --> 01:08:36,330
as your domain increases but don't worry

1814
01:08:36,330 --> 01:08:37,560
about bringing in distributed system

1815
01:08:37,560 --> 01:08:38,939
because that's gonna bring more

1816
01:08:38,939 --> 01:08:40,200
complexities that you maybe need right

1817
01:08:40,200 --> 01:08:41,939
now you should focus on what makes your

1818
01:08:41,939 --> 01:08:42,930
app you know what you need for your

1819
01:08:42,930 --> 01:08:45,390
application to succeed so people often

1820
01:08:45,390 --> 01:08:46,680
ask me what database system should I

1821
01:08:46,680 --> 01:08:48,420
start with if I'm building an

1822
01:08:48,420 --> 01:08:50,100
application my interest progress or my

1823
01:08:50,100 --> 01:08:53,490
sequel for you know 99% of applications

1824
01:08:53,490 --> 01:08:55,890
that's gonna be good enough because what

1825
01:08:55,890 --> 01:08:57,630
will happen is if your application does

1826
01:08:57,630 --> 01:08:58,890
blow up and you do have a lot of

1827
01:08:58,890 --> 01:09:02,010
customers what are you gonna have money

1828
01:09:02,010 --> 01:09:04,620
so now you can go pay me to come tell

1829
01:09:04,620 --> 01:09:06,720
you how to scale out your database all

1830
01:09:06,720 --> 01:09:09,750
right or one of my students right so a

1831
01:09:09,750 --> 01:09:12,089
avoid you know introducing new

1832
01:09:12,089 --> 01:09:14,220
complexity by bringing in a you know

1833
01:09:14,220 --> 01:09:16,380
going overboard with with a database

1834
01:09:16,380 --> 01:09:18,210
system you don't need like maybe

1835
01:09:18,210 --> 01:09:19,979
starting with Amazon RDS would be a good

1836
01:09:19,979 --> 01:09:21,270
choice and then you just scale up and

1837
01:09:21,270 --> 01:09:24,450
buy a bigger instant size and you add

1838
01:09:24,450 --> 01:09:26,640
Azure as your as your data size crows or

1839
01:09:26,640 --> 01:09:30,420
your need grows okay all right any

1840
01:09:30,420 --> 01:09:32,750
questions yes

1841
01:09:32,750 --> 01:09:35,788
boom okay all right so

1842
01:09:35,788 --> 01:09:43,828
yes so uh I did get a my test results

1843
01:09:43,828 --> 01:09:50,689
came back last week right this is it

1844
01:09:50,689 --> 01:09:58,639
it's mine isn't it there's no house so

1845
01:09:58,639 --> 01:10:01,889
the probability that I am the father of

1846
01:10:01,889 --> 01:10:07,500
my child is 99.999999 8% so there is a

1847
01:10:07,500 --> 01:10:09,449
point zero zero zero zero zero through

1848
01:10:09,449 --> 01:10:10,769
two percent chance that it's not mine

1849
01:10:10,769 --> 01:10:12,869
but at this point I've accepted my feet

1850
01:10:12,869 --> 01:10:16,369
and it's definitely my kid okay

1851
01:10:17,960 --> 01:10:22,380
yeah no it's yeah all right yeah it's

1852
01:10:22,380 --> 01:10:34,409
mine all right all right guys so I'll

1853
01:10:34,409 --> 01:10:37,110
see you at the final exam on Monday and

1854
01:10:37,110 --> 01:10:39,269
then the I'll have office hours on

1855
01:10:39,269 --> 01:10:40,920
Friday and then again this is the last

1856
01:10:40,920 --> 01:10:42,630
class with DJ drop table so again

1857
01:10:42,630 --> 01:10:45,449
rattleballs for him staying with his

1858
01:10:45,449 --> 01:10:46,320
time Spencer okay

1859
01:10:46,320 --> 01:10:49,699
all right guys take care

1860
01:10:58,950 --> 01:11:01,780
witzy nights in my system racking up I'm

1861
01:11:01,780 --> 01:11:02,320
blessed

1862
01:11:02,320 --> 01:11:09,760
let's go get the next one get over there

1863
01:11:09,760 --> 01:11:12,040
will be Sun ricochet jelly hit the deli

1864
01:11:12,040 --> 01:11:14,440
for a boat one naturally bless ya my rap

1865
01:11:14,440 --> 01:11:16,000
is like the laser beam the pores in the

1866
01:11:16,000 --> 01:11:18,220
bushes say not even like a chain wrap

1867
01:11:18,220 --> 01:11:20,230
the bottle of us a nice sympathy go

1868
01:11:20,230 --> 01:11:22,420
don't feel like drinking at boney to

1869
01:11:22,420 --> 01:11:24,430
drunk you can't drop cross he was alive

1870
01:11:24,430 --> 01:11:26,050
and if the sake don't know your phone

1871
01:11:26,050 --> 01:11:29,010
can tap a pain

