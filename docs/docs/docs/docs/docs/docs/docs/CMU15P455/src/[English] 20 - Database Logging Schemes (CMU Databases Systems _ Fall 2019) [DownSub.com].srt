1
00:00:03,640 --> 00:00:13,140
[Music]

2
00:00:15,070 --> 00:00:19,039
so DJ's dropped cable his what he's

3
00:00:19,039 --> 00:00:19,520
coming

4
00:00:19,520 --> 00:00:21,439
his second girlfriend found out about

5
00:00:21,439 --> 00:00:24,529
his third girlfriend so he went to Vegas

6
00:00:24,529 --> 00:00:27,289
to hide out that's his problem he has to

7
00:00:27,289 --> 00:00:30,470
deal with that so all right I've been

8
00:00:30,470 --> 00:00:35,360
gone what what happened to me well my

9
00:00:35,360 --> 00:00:43,899
wife had a kid and in theory yeah so

10
00:00:43,899 --> 00:00:47,390
let's be honest here it doesn't look

11
00:00:47,390 --> 00:00:51,940
like me and I'm not sure it's mine yet

12
00:00:51,940 --> 00:00:54,260
so we're waiting for the paternity tests

13
00:00:54,260 --> 00:00:56,149
come back so just hold off hold off your

14
00:00:56,149 --> 00:00:59,480
all's okay um the other thing I want to

15
00:00:59,480 --> 00:01:01,100
update for you guys is that at the

16
00:01:01,100 --> 00:01:03,730
beginning this semester I said that I

17
00:01:03,730 --> 00:01:06,140
only care about two things my life

18
00:01:06,140 --> 00:01:08,510
number one was my wife number two was

19
00:01:08,510 --> 00:01:10,460
databases so I have an updated version

20
00:01:10,460 --> 00:01:13,700
for everyone now the new version is that

21
00:01:13,700 --> 00:01:16,430
my wife is still number one databases

22
00:01:16,430 --> 00:01:19,280
are still number two and again depending

23
00:01:19,280 --> 00:01:23,990
on the paternity test the the baby is is

24
00:01:23,990 --> 00:01:27,229
just you know sort of there okay uh I'll

25
00:01:27,229 --> 00:01:30,049
say one thing to everyone here if do not

26
00:01:30,049 --> 00:01:32,000
get pregnant or getting buddy else

27
00:01:32,000 --> 00:01:33,920
pregnant before you graduate school it

28
00:01:33,920 --> 00:01:35,960
is a nightmare I've done nothing for two

29
00:01:35,960 --> 00:01:37,280
for the last two weeks except cleaning

30
00:01:37,280 --> 00:01:38,990
like poop diapers and like vomit stuff

31
00:01:38,990 --> 00:01:42,290
like that it's it's it's awful all right

32
00:01:42,290 --> 00:01:45,110
sorry it's my my for wife is at home now

33
00:01:45,110 --> 00:01:45,619
with the kid

34
00:01:45,619 --> 00:01:48,770
all right so for you guys that that

35
00:01:48,770 --> 00:01:50,390
don't have any newborn children take

36
00:01:50,390 --> 00:01:52,130
care of here's what you have to do so

37
00:01:52,130 --> 00:01:54,920
this is what's coming up you in in the

38
00:01:54,920 --> 00:01:57,710
next month homework 4 is due two days

39
00:01:57,710 --> 00:01:58,990
from now on Wednesday at midnight

40
00:01:58,990 --> 00:02:01,219
project 3 what we do at the end of this

41
00:02:01,219 --> 00:02:03,560
week on Sunday at midnight and then I'll

42
00:02:03,560 --> 00:02:05,270
announce this on Piazza and post this on

43
00:02:05,270 --> 00:02:07,850
the website we'll do the first

44
00:02:07,850 --> 00:02:10,970
checkpoint for the extra credit will be

45
00:02:10,970 --> 00:02:14,360
on will be on on Sunday November 24th

46
00:02:14,360 --> 00:02:16,310
after the one week after the project 3

47
00:02:16,310 --> 00:02:18,140
is due and so what the checkpoint means

48
00:02:18,140 --> 00:02:20,660
basically is yo-yo

49
00:02:20,660 --> 00:02:22,190
the URL to the article that you've been

50
00:02:22,190 --> 00:02:24,680
working on the myself or the TAS will

51
00:02:24,680 --> 00:02:26,540
look at it give you feedback give you

52
00:02:26,540 --> 00:02:28,790
suggestions tell you what looks right

53
00:02:28,790 --> 00:02:30,560
and doesn't look right and then that'll

54
00:02:30,560 --> 00:02:32,990
give you guidance towards the final

55
00:02:32,990 --> 00:02:33,470
submission

56
00:02:33,470 --> 00:02:35,180
so I'll just say up front that you won't

57
00:02:35,180 --> 00:02:37,700
get full credit for the extra credit

58
00:02:37,700 --> 00:02:39,980
unless you submit the check point right

59
00:02:39,980 --> 00:02:41,330
if you just Smith the check if you

60
00:02:41,330 --> 00:02:42,530
submit the final thing at the very end

61
00:02:42,530 --> 00:02:43,850
without giving you know that's giving

62
00:02:43,850 --> 00:02:45,590
you feedback you won't get full credit

63
00:02:45,590 --> 00:02:47,690
and I'll update the the document provide

64
00:02:47,690 --> 00:02:48,920
information about all these things and

65
00:02:48,920 --> 00:02:50,510
then after that there's one more

66
00:02:50,510 --> 00:02:51,860
homework and that'll be due in December

67
00:02:51,860 --> 00:02:53,150
and there's one more project and that'll

68
00:02:53,150 --> 00:02:54,980
be due in December as well

69
00:02:54,980 --> 00:03:02,620
okay so Roma's done any questions okay

70
00:03:02,620 --> 00:03:08,810
so let's talk about logging so the idea

71
00:03:08,810 --> 00:03:10,730
of logging and recovery is that we

72
00:03:10,730 --> 00:03:12,710
obviously want to be able to persist any

73
00:03:12,710 --> 00:03:15,170
changes we make to the database and

74
00:03:15,170 --> 00:03:16,550
whenever there's a crash or a failure

75
00:03:16,550 --> 00:03:18,830
so don't understand this problem let's

76
00:03:18,830 --> 00:03:20,900
talk about the kind of system we've

77
00:03:20,900 --> 00:03:23,630
talked about so far see if the problems

78
00:03:23,630 --> 00:03:25,370
are and then we'll go back now and add

79
00:03:25,370 --> 00:03:26,870
maldium recovery and we'll see how to

80
00:03:26,870 --> 00:03:28,940
handle the issues with making sure

81
00:03:28,940 --> 00:03:31,130
everything is durable and safe let's say

82
00:03:31,130 --> 00:03:33,380
I have a simple transaction t1 was your

83
00:03:33,380 --> 00:03:35,720
read on a write on AIM and it's a very

84
00:03:35,720 --> 00:03:37,820
very beginning there's nothing in our

85
00:03:37,820 --> 00:03:38,720
preferable like we haven't brought

86
00:03:38,720 --> 00:03:40,340
anything into memory and we only have

87
00:03:40,340 --> 00:03:42,410
one page that has the object a in it out

88
00:03:42,410 --> 00:03:45,020
on disk so when our transaction starts

89
00:03:45,020 --> 00:03:46,940
it does the read on a and then we go

90
00:03:46,940 --> 00:03:48,560
fetch that page from disk and bring that

91
00:03:48,560 --> 00:03:50,540
into our buffer pool that's good we know

92
00:03:50,540 --> 00:03:52,130
how to do that we've talked about talked

93
00:03:52,130 --> 00:03:53,480
about about that already

94
00:03:53,480 --> 00:03:55,430
so now when I want to do the right o

95
00:03:55,430 --> 00:03:58,310
name I modify the object as it exists in

96
00:03:58,310 --> 00:04:01,130
the buffer pool right I make a flip that

97
00:04:01,130 --> 00:04:03,530
make me of it and make the change then

98
00:04:03,530 --> 00:04:04,880
now my transaction says I wants to

99
00:04:04,880 --> 00:04:10,120
commit what has to happen here

100
00:04:12,300 --> 00:04:14,800
what does it commit me the application

101
00:04:14,800 --> 00:04:17,709
tells us we want to commit when did we

102
00:04:17,709 --> 00:04:18,880
tell the outside world that your shows

103
00:04:18,880 --> 00:04:24,160
actions actually committed well if we

104
00:04:24,160 --> 00:04:25,690
immediately say they tell us commit we

105
00:04:25,690 --> 00:04:26,889
immediately say well you don't there's

106
00:04:26,889 --> 00:04:28,360
no deadlocks there's no time stamp

107
00:04:28,360 --> 00:04:30,010
violations or validation issues with

108
00:04:30,010 --> 00:04:31,870
your transaction if we merely tell now

109
00:04:31,870 --> 00:04:33,220
the outside world yeah your transactions

110
00:04:33,220 --> 00:04:36,550
committed what could happen well our

111
00:04:36,550 --> 00:04:37,930
change is just hanging out here in

112
00:04:37,930 --> 00:04:39,580
memory again we pass it all our

113
00:04:39,580 --> 00:04:42,100
commercial checks that's all fine but

114
00:04:42,100 --> 00:04:44,320
it's still sitting in memory so now if

115
00:04:44,320 --> 00:04:46,750
like the most evil person for databases

116
00:04:46,750 --> 00:04:48,669
comes along like the Hitler databases

117
00:04:48,669 --> 00:04:51,310
it's just Hitler if he comes and that's

118
00:04:51,310 --> 00:04:51,880
us

119
00:04:51,880 --> 00:04:54,430
taps our data center or our machine and

120
00:04:54,430 --> 00:04:57,669
we lose power then all the changes that

121
00:04:57,669 --> 00:04:59,470
were sitting out in involved tool memory

122
00:04:59,470 --> 00:05:02,770
are gone all right we never wrote

123
00:05:02,770 --> 00:05:04,900
anything out the disk so if we tell the

124
00:05:04,900 --> 00:05:06,669
outside world that when you know

125
00:05:06,669 --> 00:05:08,280
immediately hey your thing committed and

126
00:05:08,280 --> 00:05:10,930
nothing got persisted to disk we can

127
00:05:10,930 --> 00:05:12,520
immediately you know we could lose power

128
00:05:12,520 --> 00:05:14,080
right away and lose all our changes and

129
00:05:14,080 --> 00:05:15,460
now we totally outside where we

130
00:05:15,460 --> 00:05:16,750
committed but you come back and you're

131
00:05:16,750 --> 00:05:19,050
your changes aren't there and that's bad

132
00:05:19,050 --> 00:05:21,370
so this is at a high level is what the

133
00:05:21,370 --> 00:05:22,780
problem trying to deal with today

134
00:05:22,780 --> 00:05:25,419
all right called crash recovery and the

135
00:05:25,419 --> 00:05:27,220
logging schemes it was a mechanism we're

136
00:05:27,220 --> 00:05:30,669
gonna use to prevent these things so the

137
00:05:30,669 --> 00:05:31,960
recovery algos were talked about today

138
00:05:31,960 --> 00:05:33,910
are the techniques that the database

139
00:05:33,910 --> 00:05:36,010
system is going to use to ensure that

140
00:05:36,010 --> 00:05:38,050
all the changes make the changes that

141
00:05:38,050 --> 00:05:40,479
transactions make will guarantee the

142
00:05:40,479 --> 00:05:42,760
database is consistent all the changes

143
00:05:42,760 --> 00:05:44,770
are atomic and all the changes are

144
00:05:44,770 --> 00:05:47,770
durable right so we care about a C and D

145
00:05:47,770 --> 00:05:49,660
in the asset acronym we don't care about

146
00:05:49,660 --> 00:05:51,190
isolation for work talk might here today

147
00:05:51,190 --> 00:05:52,240
cuz that's sort of handled by the

148
00:05:52,240 --> 00:05:53,320
commercial protocols

149
00:05:53,320 --> 00:05:54,789
okay that's worrying about you know who

150
00:05:54,789 --> 00:05:56,979
can reuse writes this is really about

151
00:05:56,979 --> 00:05:58,720
how can we make sure that our changes

152
00:05:58,720 --> 00:06:02,289
are atomic consistent and durable so

153
00:06:02,289 --> 00:06:04,660
every recovery protocol our mechanism is

154
00:06:04,660 --> 00:06:07,330
gonna have two parts the first of all

155
00:06:07,330 --> 00:06:08,530
the things we're gonna do at runtime

156
00:06:08,530 --> 00:06:10,330
while the system is running while we're

157
00:06:10,330 --> 00:06:12,760
executing transactions and queries that

158
00:06:12,760 --> 00:06:15,669
will well set us up so that if we have

159
00:06:15,669 --> 00:06:18,490
to recover after a failure we're able to

160
00:06:18,490 --> 00:06:20,460
do that and not lose any any information

161
00:06:20,460 --> 00:06:22,479
so the first part is all the things we

162
00:06:22,479 --> 00:06:24,449
do at runtime the

163
00:06:24,449 --> 00:06:26,699
second part is if after a restart or if

164
00:06:26,699 --> 00:06:29,370
after a crash how do we use the

165
00:06:29,370 --> 00:06:30,689
information that we collected from the

166
00:06:30,689 --> 00:06:31,919
first part when you're running normally

167
00:06:31,919 --> 00:06:34,259
to go back and put the database back to

168
00:06:34,259 --> 00:06:38,339
the correct state so today's lecture is

169
00:06:38,339 --> 00:06:40,050
focused on the first part what do we do

170
00:06:40,050 --> 00:06:41,669
at run time to make sure that we can

171
00:06:41,669 --> 00:06:43,050
collect the right information so that we

172
00:06:43,050 --> 00:06:45,539
can restore the database correctly the

173
00:06:45,539 --> 00:06:48,150
second part is on Wednesday if after we

174
00:06:48,150 --> 00:06:49,830
crash we look in here and figure out

175
00:06:49,830 --> 00:06:51,180
what the hell we actually did and put us

176
00:06:51,180 --> 00:06:54,839
back to the correct state so for today

177
00:06:54,839 --> 00:06:56,520
there's a bunch of stuff we need to talk

178
00:06:56,520 --> 00:06:57,749
about before we actually talk about the

179
00:06:57,749 --> 00:07:00,089
method we're gonna use so first we gotta

180
00:07:00,089 --> 00:07:01,169
talk about what kind of failures we

181
00:07:01,169 --> 00:07:02,849
could have in our system and how can we

182
00:07:02,849 --> 00:07:04,199
you know which ones we can can recover

183
00:07:04,199 --> 00:07:06,599
not recover from then we're started

184
00:07:06,599 --> 00:07:08,490
talking about how we actually going to

185
00:07:08,490 --> 00:07:11,129
manage memory and our buffer pool in a

186
00:07:11,129 --> 00:07:12,449
slightly different way than we've talked

187
00:07:12,449 --> 00:07:15,029
about so far so that we can assure that

188
00:07:15,029 --> 00:07:16,949
we can again we can recover after a

189
00:07:16,949 --> 00:07:18,870
crash then we'll talk about two

190
00:07:18,870 --> 00:07:20,729
techniques to do database recovery the

191
00:07:20,729 --> 00:07:22,499
first is shadow paging the second is

192
00:07:22,499 --> 00:07:24,479
right ahead logging the spoiler would be

193
00:07:24,479 --> 00:07:27,419
right ahead logging is the better way

194
00:07:27,419 --> 00:07:29,129
this way what every single data system

195
00:07:29,129 --> 00:07:30,930
actually uses but it's good to know what

196
00:07:30,930 --> 00:07:32,789
shadow paging is just to see for stoical

197
00:07:32,789 --> 00:07:34,999
reasons and see why this is superior

198
00:07:34,999 --> 00:07:37,409
then we'll talk about how two different

199
00:07:37,409 --> 00:07:38,460
types of logging and write ahead logging

200
00:07:38,460 --> 00:07:40,259
like what's actually in the log record

201
00:07:40,259 --> 00:07:42,180
itself and then we'll finish up talking

202
00:07:42,180 --> 00:07:43,770
about checkpoints what - then we'll

203
00:07:43,770 --> 00:07:45,930
segue into what we talked about on

204
00:07:45,930 --> 00:07:51,180
Wednesday to do a recovery ok all right

205
00:07:51,180 --> 00:07:54,089
so the the database system itself is

206
00:07:54,089 --> 00:07:57,569
going to be divided so conceptually into

207
00:07:57,569 --> 00:07:59,310
different components based on what the

208
00:07:59,310 --> 00:08:00,959
underlying storage device they operate

209
00:08:00,959 --> 00:08:03,300
on right the buffle manager keeps things

210
00:08:03,300 --> 00:08:05,129
in memory the disk manager keep things

211
00:08:05,129 --> 00:08:07,319
on disk right ones volatile ones

212
00:08:07,319 --> 00:08:10,199
non-volatile and then so so based on

213
00:08:10,199 --> 00:08:11,669
that we want to keep track of and

214
00:08:11,669 --> 00:08:14,909
understand how can these different

215
00:08:14,909 --> 00:08:17,819
components fail based on or have

216
00:08:17,819 --> 00:08:19,560
problems based on the different types of

217
00:08:19,560 --> 00:08:22,110
failures we can incur while we're

218
00:08:22,110 --> 00:08:23,459
running transactions while we're running

219
00:08:23,459 --> 00:08:26,520
queries and in the base of that we can

220
00:08:26,520 --> 00:08:27,449
figure out what you know what do we

221
00:08:27,449 --> 00:08:28,860
actually need to support in our recovery

222
00:08:28,860 --> 00:08:32,458
protocol so there's three categories of

223
00:08:32,458 --> 00:08:34,110
failures and we'll go through each of

224
00:08:34,110 --> 00:08:35,640
these one by one transaction failure

225
00:08:35,640 --> 00:08:36,990
system ferrars and storage media

226
00:08:36,990 --> 00:08:38,130
failures so

227
00:08:38,130 --> 00:08:41,280
the spoiler or the the heads-up for what

228
00:08:41,280 --> 00:08:43,110
I'm talking about we care about the

229
00:08:43,110 --> 00:08:45,420
first two the third one is impossible to

230
00:08:45,420 --> 00:08:48,140
handle and we'll see why as we go along

231
00:08:48,140 --> 00:08:50,460
so transaction fares over all the things

232
00:08:50,460 --> 00:08:52,500
we talked about so far when we talk

233
00:08:52,500 --> 00:08:54,570
about currency control these are things

234
00:08:54,570 --> 00:08:57,870
like when like when the transaction has

235
00:08:57,870 --> 00:08:59,220
a deadlock or transaction tries to

236
00:08:59,220 --> 00:09:00,300
update something that it's not allowed

237
00:09:00,300 --> 00:09:02,970
to update or update a value nor certain

238
00:09:02,970 --> 00:09:04,530
way that's not update right these are

239
00:09:04,530 --> 00:09:05,700
things that we can't allow the

240
00:09:05,700 --> 00:09:07,560
transaction to continue and therefore we

241
00:09:07,560 --> 00:09:08,580
have to abort it and roll back as

242
00:09:08,580 --> 00:09:09,120
changes

243
00:09:09,120 --> 00:09:12,110
so again logical errors would be the

244
00:09:12,110 --> 00:09:14,340
transactions trying to violate some

245
00:09:14,340 --> 00:09:15,780
internal integrity constraint that's

246
00:09:15,780 --> 00:09:17,550
that's put upon the database or a

247
00:09:17,550 --> 00:09:20,310
referential referential constraint like

248
00:09:20,310 --> 00:09:21,540
if you try to insert something but

249
00:09:21,540 --> 00:09:22,620
that's a foreign key preference and that

250
00:09:22,620 --> 00:09:24,810
foreign key doesn't exist then the

251
00:09:24,810 --> 00:09:26,250
database system says you can't complete

252
00:09:26,250 --> 00:09:28,140
your transaction has to fail we're gonna

253
00:09:28,140 --> 00:09:29,580
make sure all your your changes get

254
00:09:29,580 --> 00:09:31,080
rolled back and never persist even

255
00:09:31,080 --> 00:09:32,790
though if we you know we start multiple

256
00:09:32,790 --> 00:09:35,490
times internal state errors are the

257
00:09:35,490 --> 00:09:37,230
things we talked about under two-phase

258
00:09:37,230 --> 00:09:39,780
locking and timestamp ordering right if

259
00:09:39,780 --> 00:09:42,030
we have a developer to between two

260
00:09:42,030 --> 00:09:43,530
transactions we got to kill one of them

261
00:09:43,530 --> 00:09:45,750
and abort them rollback all its changes

262
00:09:45,750 --> 00:09:47,340
and then you know make sure that then

263
00:09:47,340 --> 00:09:48,810
they don't persist after a crash

264
00:09:48,810 --> 00:09:51,270
so our database is logging protocol

265
00:09:51,270 --> 00:09:52,590
needs to handle both of these I think

266
00:09:52,590 --> 00:09:55,740
these are sort of obvious then we get to

267
00:09:55,740 --> 00:09:57,300
actually the system failures the

268
00:09:57,300 --> 00:09:59,760
hardware failures that we can count for

269
00:09:59,760 --> 00:10:03,150
in our protocol as well so the first is

270
00:10:03,150 --> 00:10:04,500
the software failure these are where the

271
00:10:04,500 --> 00:10:07,610
the database system itself is buggy

272
00:10:07,610 --> 00:10:10,050
right there's some crappy code in the

273
00:10:10,050 --> 00:10:11,730
database system and like a divide by

274
00:10:11,730 --> 00:10:14,040
zero and now the software it's system

275
00:10:14,040 --> 00:10:15,990
itself the David system itself crashes

276
00:10:15,990 --> 00:10:19,680
right gets a six set of boards and so we

277
00:10:19,680 --> 00:10:20,670
need to be able to account for those

278
00:10:20,670 --> 00:10:22,260
kind of failures in our database system

279
00:10:22,260 --> 00:10:24,000
and make sure that you know any

280
00:10:24,000 --> 00:10:25,920
transaction is still running they get

281
00:10:25,920 --> 00:10:27,240
aboard and rollback correctly or any she

282
00:10:27,240 --> 00:10:29,060
was actually that did commit before this

283
00:10:29,060 --> 00:10:31,920
this error occurred all this changes are

284
00:10:31,920 --> 00:10:35,640
persistent the hardware failure is when

285
00:10:35,640 --> 00:10:38,010
the actual machine that our data system

286
00:10:38,010 --> 00:10:41,010
is running on crashes or ceased ceases

287
00:10:41,010 --> 00:10:43,320
to operate or runs okay this could be

288
00:10:43,320 --> 00:10:44,820
someone like tripped over the power cord

289
00:10:44,820 --> 00:10:46,920
or like there's a loose wire plugging

290
00:10:46,920 --> 00:10:50,100
into the disk drive right the system has

291
00:10:50,100 --> 00:10:51,720
a failure and they can't keep

292
00:10:51,720 --> 00:10:53,040
the operating system you know crashes

293
00:10:53,040 --> 00:10:55,500
the Davis system crashes and we need to

294
00:10:55,500 --> 00:10:57,470
come back and recover the database state

295
00:10:57,470 --> 00:11:00,330
so in order for us to make this you know

296
00:11:00,330 --> 00:11:02,340
be it'll handle this we have to make

297
00:11:02,340 --> 00:11:05,280
this fail stop assumption and that as we

298
00:11:05,280 --> 00:11:07,620
assume that the harbor is not going to

299
00:11:07,620 --> 00:11:12,990
suffer a unrecoverable damage if we have

300
00:11:12,990 --> 00:11:16,050
a hardware failure meaning like if we

301
00:11:16,050 --> 00:11:17,340
have a spin against hard drive and

302
00:11:17,340 --> 00:11:18,210
there's the needle writing on the

303
00:11:18,210 --> 00:11:21,390
platter if we pull the power and the the

304
00:11:21,390 --> 00:11:23,550
the needle is not gonna like Kareem into

305
00:11:23,550 --> 00:11:25,020
the platter and sort you know mess you

306
00:11:25,020 --> 00:11:27,660
know messing up sectors we assume that

307
00:11:27,660 --> 00:11:29,340
if we if we crash have a heart failure

308
00:11:29,340 --> 00:11:31,140
then we can always come back and recover

309
00:11:31,140 --> 00:11:35,310
the correct state so the last category

310
00:11:35,310 --> 00:11:36,660
there is the ones that we can't handle

311
00:11:36,660 --> 00:11:38,580
at all in our database system simply

312
00:11:38,580 --> 00:11:39,870
because the database system although

313
00:11:39,870 --> 00:11:41,880
it's you know as great piece of software

314
00:11:41,880 --> 00:11:44,850
it is it can't been you know the the

315
00:11:44,850 --> 00:11:47,460
pencil is a matter to its own will so a

316
00:11:47,460 --> 00:11:49,440
harbor a non repairable heart affair

317
00:11:49,440 --> 00:11:51,570
would be like the example of the needle

318
00:11:51,570 --> 00:11:53,790
crashing into the platter or like find

319
00:11:53,790 --> 00:11:55,560
like the machine on fire and melt all my

320
00:11:55,560 --> 00:11:58,200
disks no database system can recover

321
00:11:58,200 --> 00:12:00,750
from that right so we're not gonna

322
00:12:00,750 --> 00:12:02,730
design our protocol to account for this

323
00:12:02,730 --> 00:12:05,130
we can do other things like just

324
00:12:05,130 --> 00:12:08,130
replicate the database to overcome this

325
00:12:08,130 --> 00:12:10,620
or maintain archive backups that we can

326
00:12:10,620 --> 00:12:12,810
recover if there's a crash but that's

327
00:12:12,810 --> 00:12:14,850
not really recovery and the same we're

328
00:12:14,850 --> 00:12:16,770
talking about today like if I had to

329
00:12:16,770 --> 00:12:17,640
restore it from an archived version

330
00:12:17,640 --> 00:12:19,800
that's just backup and restore that's

331
00:12:19,800 --> 00:12:22,170
you notice me loading it in from from a

332
00:12:22,170 --> 00:12:24,240
you know a separate copy that's not

333
00:12:24,240 --> 00:12:26,610
doing anything extra special the kind of

334
00:12:26,610 --> 00:12:27,360
things we're talking about today to

335
00:12:27,360 --> 00:12:29,790
recover the database State so again we

336
00:12:29,790 --> 00:12:31,170
only care about the first few failures

337
00:12:31,170 --> 00:12:33,360
no database system can account for this

338
00:12:33,360 --> 00:12:35,250
but through redundancy which we'll talk

339
00:12:35,250 --> 00:12:37,470
about with distributed databases we can

340
00:12:37,470 --> 00:12:39,839
we can try to avoid this and mitigate

341
00:12:39,839 --> 00:12:46,920
the issue okay so the entire semester

342
00:12:46,920 --> 00:12:48,060
we've been talking about discarding

343
00:12:48,060 --> 00:12:50,339
database systems right and so we've

344
00:12:50,339 --> 00:12:51,630
already covered this already but now we

345
00:12:51,630 --> 00:12:54,000
need to sort of go over it again and see

346
00:12:54,000 --> 00:12:55,020
how this is gonna be an issue when we

347
00:12:55,020 --> 00:12:57,750
talk about logging and recovery so again

348
00:12:57,750 --> 00:12:59,910
and it's what a database says what says

349
00:12:59,910 --> 00:13:01,530
that the systems of design such that B

350
00:13:01,530 --> 00:13:03,240
primary storage location is assumed to

351
00:13:03,240 --> 00:13:04,410
be on disk

352
00:13:04,410 --> 00:13:06,810
and at anytime you want to read a record

353
00:13:06,810 --> 00:13:08,699
or manipulate a record you have to first

354
00:13:08,699 --> 00:13:10,230
copy it into memory into your buffer

355
00:13:10,230 --> 00:13:12,480
pool make your change and then

356
00:13:12,480 --> 00:13:14,129
eventually write it back out the disk in

357
00:13:14,129 --> 00:13:16,560
order to persist it this is the bond

358
00:13:16,560 --> 00:13:18,600
omean Architecture from the 1950s it's

359
00:13:18,600 --> 00:13:19,949
not specific to database systems but

360
00:13:19,949 --> 00:13:22,529
it's it's the operating assumption we're

361
00:13:22,529 --> 00:13:24,660
basing our tired discussion on and there

362
00:13:24,660 --> 00:13:26,129
are some special newer hard drives that

363
00:13:26,129 --> 00:13:29,160
can you know have CPU cores on the disk

364
00:13:29,160 --> 00:13:30,689
itself and you can try to manipulate the

365
00:13:30,689 --> 00:13:32,430
data down there but that's just sort of

366
00:13:32,430 --> 00:13:34,139
moving the problem somewheres else for a

367
00:13:34,139 --> 00:13:36,149
purposes we can ignore that and say you

368
00:13:36,149 --> 00:13:37,589
know what we want to modify something we

369
00:13:37,589 --> 00:13:38,819
bring into memory make the change then

370
00:13:38,819 --> 00:13:41,519
write it back out to disk so the

371
00:13:41,519 --> 00:13:43,680
question is gonna be when do we actually

372
00:13:43,680 --> 00:13:46,350
write those changes out so when you guys

373
00:13:46,350 --> 00:13:48,750
built the buffer pool stuff from before

374
00:13:48,750 --> 00:13:51,060
all you're really doing is just saying

375
00:13:51,060 --> 00:13:52,379
all right well this page should be

376
00:13:52,379 --> 00:13:55,230
evicted it's dirty so therefore I have

377
00:13:55,230 --> 00:13:57,600
to write it back out the disk and you

378
00:13:57,600 --> 00:13:59,550
didn't worry about who actually made

379
00:13:59,550 --> 00:14:02,069
that change and whether it was the right

380
00:14:02,069 --> 00:14:03,480
time to actually write that change out

381
00:14:03,480 --> 00:14:06,269
the disk so that's the thing we need to

382
00:14:06,269 --> 00:14:08,129
account for in our logging protocols

383
00:14:08,129 --> 00:14:12,329
today so the the basic guarantees we

384
00:14:12,329 --> 00:14:14,189
need better to ensure in order to

385
00:14:14,189 --> 00:14:16,019
provide the atomicity because it's the

386
00:14:16,019 --> 00:14:19,139
in durability guarantees is that if we

387
00:14:19,139 --> 00:14:20,579
tell the outside world that their

388
00:14:20,579 --> 00:14:22,410
transaction is committed meaning we send

389
00:14:22,410 --> 00:14:23,399
them an acknowledgment say you've

390
00:14:23,399 --> 00:14:25,560
committed then all of those changes are

391
00:14:25,560 --> 00:14:27,720
persisted and durable forever someone

392
00:14:27,720 --> 00:14:29,519
may come and overwrite those changes and

393
00:14:29,519 --> 00:14:32,120
update them that's fine but you know

394
00:14:32,120 --> 00:14:34,649
before that you know those changes

395
00:14:34,649 --> 00:14:36,230
should always persist forever and

396
00:14:36,230 --> 00:14:38,699
likewise if any transaction makes

397
00:14:38,699 --> 00:14:40,230
changes and those changes make it out

398
00:14:40,230 --> 00:14:42,389
the disk but then that transaction

399
00:14:42,389 --> 00:14:43,829
aborts or doesn't complete correctly

400
00:14:43,829 --> 00:14:45,870
before the crash we need to make sure

401
00:14:45,870 --> 00:14:47,339
that we can reverse those changes as

402
00:14:47,339 --> 00:14:49,860
well so those are the two main

403
00:14:49,860 --> 00:14:50,939
guarantees we need to have in our

404
00:14:50,939 --> 00:14:54,059
logging protocol and the core principles

405
00:14:54,059 --> 00:14:55,860
we're going to use to Nord provide these

406
00:14:55,860 --> 00:14:59,759
guarantees or undo and redo which are

407
00:14:59,759 --> 00:15:01,220
exactly as they sound

408
00:15:01,220 --> 00:15:04,439
so with undo it's basically information

409
00:15:04,439 --> 00:15:06,829
we're going to maintain to allow us to

410
00:15:06,829 --> 00:15:10,170
reverse any changes to an object in the

411
00:15:10,170 --> 00:15:12,870
database that a transaction has made so

412
00:15:12,870 --> 00:15:14,730
it's like here's what the old guy used

413
00:15:14,730 --> 00:15:16,470
to be for this attribute for this tuple

414
00:15:16,470 --> 00:15:17,810
and

415
00:15:17,810 --> 00:15:19,490
store that somewhere so that if I ever

416
00:15:19,490 --> 00:15:21,259
need to reverse the change that someone

417
00:15:21,259 --> 00:15:23,839
made to it I can go always go put put

418
00:15:23,839 --> 00:15:26,629
the old value back in and then redo is

419
00:15:26,629 --> 00:15:28,519
the opposite of that redo is the

420
00:15:28,519 --> 00:15:30,829
information needed to reapply a change

421
00:15:30,829 --> 00:15:33,079
that a transaction made to to a to an

422
00:15:33,079 --> 00:15:35,329
object in the database right here's the

423
00:15:35,329 --> 00:15:36,439
information on how to say you know

424
00:15:36,439 --> 00:15:37,759
here's what the change here's the change

425
00:15:37,759 --> 00:15:39,470
they made at this given time if I ever

426
00:15:39,470 --> 00:15:40,459
need to go back and make that change

427
00:15:40,459 --> 00:15:42,470
again I might redo information tells me

428
00:15:42,470 --> 00:15:45,470
how to do this so based on these two

429
00:15:45,470 --> 00:15:47,509
principal or primitives we can now build

430
00:15:47,509 --> 00:15:49,459
on this and I'll have to build something

431
00:15:49,459 --> 00:15:52,339
more complex a logging protocol that

432
00:15:52,339 --> 00:15:54,050
allows us to generate this information

433
00:15:54,050 --> 00:15:56,290
at the right time and in the right way

434
00:15:56,290 --> 00:15:58,220
to allow us to restore the database

435
00:15:58,220 --> 00:16:01,879
after a crash how we're actually gonna

436
00:16:01,879 --> 00:16:04,309
use undo and redo and when this

437
00:16:04,309 --> 00:16:05,509
information guide sheet gets written to

438
00:16:05,509 --> 00:16:05,930
disk

439
00:16:05,930 --> 00:16:08,149
it's gonna depend on how we're gonna

440
00:16:08,149 --> 00:16:10,550
manage disks should I manage dirty pages

441
00:16:10,550 --> 00:16:14,509
in our buffer pool so let's look at more

442
00:16:14,509 --> 00:16:17,240
complex example here you have t1 t2 t1

443
00:16:17,240 --> 00:16:19,459
does a read on a it right on a t2 does a

444
00:16:19,459 --> 00:16:21,800
read on be right on B so in this case

445
00:16:21,800 --> 00:16:23,420
here we're not worried about deadlocks

446
00:16:23,420 --> 00:16:25,550
or concur to toll we just assume that

447
00:16:25,550 --> 00:16:27,110
they're allowed to acquire these locks

448
00:16:27,110 --> 00:16:28,610
into whatever they need to do we only

449
00:16:28,610 --> 00:16:30,019
care about this point it like the low

450
00:16:30,019 --> 00:16:31,430
level changes they're making to these

451
00:16:31,430 --> 00:16:36,139
objects so we transaction t1 starts we

452
00:16:36,139 --> 00:16:38,809
do a read or a there's only one page in

453
00:16:38,809 --> 00:16:40,879
our database and so in order to do the

454
00:16:40,879 --> 00:16:42,680
read on a we got to first bring into our

455
00:16:42,680 --> 00:16:44,480
buffer pool and then the transaction is

456
00:16:44,480 --> 00:16:46,490
allowed to read it then it does the

457
00:16:46,490 --> 00:16:48,019
write on a and again it's already in our

458
00:16:48,019 --> 00:16:49,759
buffer pool assuming we can get the

459
00:16:49,759 --> 00:16:50,389
latch on it

460
00:16:50,389 --> 00:16:51,620
we can go ahead and make our change

461
00:16:51,620 --> 00:16:54,079
updated directly in place we were

462
00:16:54,079 --> 00:16:55,970
ignoring multi versioning for now we

463
00:16:55,970 --> 00:16:57,529
make our change right there and then our

464
00:16:57,529 --> 00:17:00,589
operation finishes now we have a context

465
00:17:00,589 --> 00:17:02,720
switch t2 starts running it does a read

466
00:17:02,720 --> 00:17:04,789
on B the page is already in memory so

467
00:17:04,789 --> 00:17:06,648
that's fine that happens right away then

468
00:17:06,648 --> 00:17:08,419
it doesn't write on B again already in

469
00:17:08,419 --> 00:17:10,280
memory we we assume you get the right

470
00:17:10,280 --> 00:17:12,380
latch on it we can make our change and

471
00:17:12,380 --> 00:17:15,589
we're fine so now we go ahead and t2

472
00:17:15,589 --> 00:17:18,740
wants to commit what needs to happen

473
00:17:18,740 --> 00:17:21,500
here well there's two decisions we have

474
00:17:21,500 --> 00:17:22,680
to make

475
00:17:22,680 --> 00:17:25,630
the first is in order to be able to tell

476
00:17:25,630 --> 00:17:26,920
the outside world that our transaction

477
00:17:26,920 --> 00:17:30,910
is committed should we force the the

478
00:17:30,910 --> 00:17:32,740
buffer pool to flush out and write out

479
00:17:32,740 --> 00:17:34,390
all the changes that it made for this

480
00:17:34,390 --> 00:17:39,220
page out the disk yes or no yes right

481
00:17:39,220 --> 00:17:40,270
because you have to do theirs otherwise

482
00:17:40,270 --> 00:17:41,980
if I crash a Hitler comes along and it

483
00:17:41,980 --> 00:17:44,200
takes to take this away all my changes

484
00:17:44,200 --> 00:17:47,970
are gone well what's the issue

485
00:17:50,610 --> 00:17:51,840
correct

486
00:17:51,840 --> 00:17:57,670
t1 modified a in the same page so should

487
00:17:57,670 --> 00:18:00,340
I be allowed to write out a page that's

488
00:18:00,340 --> 00:18:02,020
been modified by a transaction that has

489
00:18:02,020 --> 00:18:05,710
not committed yet out the disk he's

490
00:18:05,710 --> 00:18:06,910
shaking her head no well what's the

491
00:18:06,910 --> 00:18:09,370
problem right bees in here T two's made

492
00:18:09,370 --> 00:18:11,170
that change but he wants to commit it's

493
00:18:11,170 --> 00:18:13,420
allowed to but there's this other change

494
00:18:13,420 --> 00:18:16,410
in here from an uncommitted transaction

495
00:18:16,410 --> 00:18:19,570
so let's say that all right well I take

496
00:18:19,570 --> 00:18:21,400
it's better for me to write out t choose

497
00:18:21,400 --> 00:18:23,710
changes even though t1 has a committee

498
00:18:23,710 --> 00:18:26,640
yet so I write write those out the desk

499
00:18:26,640 --> 00:18:29,560
but now I you know I tell the outside

500
00:18:29,560 --> 00:18:31,330
row tteyuu is committed I'll go back to

501
00:18:31,330 --> 00:18:35,440
t1 but now t1 aborts so what needs to

502
00:18:35,440 --> 00:18:42,700
happen here yes right so I need to roll

503
00:18:42,700 --> 00:18:43,960
back the transaction so I need to roll

504
00:18:43,960 --> 00:18:47,110
back the change it made on a I can do

505
00:18:47,110 --> 00:18:48,700
that memory pretty fast right that's not

506
00:18:48,700 --> 00:18:51,390
a big deal but I've wrote out the page

507
00:18:51,390 --> 00:18:54,550
two you know that existed in with the

508
00:18:54,550 --> 00:18:57,520
change that t1 made out the disk so now

509
00:18:57,520 --> 00:18:59,410
I got to go make that change in here and

510
00:18:59,410 --> 00:19:02,260
then write it out again to reverse the

511
00:19:02,260 --> 00:19:04,480
change that I made what's the problem of

512
00:19:04,480 --> 00:19:16,690
that exactly so he said by the time I

513
00:19:16,690 --> 00:19:18,670
get my abort I maybe I've reversed the

514
00:19:18,670 --> 00:19:21,400
change here before I overwrite my change

515
00:19:21,400 --> 00:19:25,360
out the disk I crash now I come back I

516
00:19:25,360 --> 00:19:26,920
don't have any of this I only have

517
00:19:26,920 --> 00:19:29,140
what's on disk and now I have a change

518
00:19:29,140 --> 00:19:31,630
from t1 that I that shouldn't be there

519
00:19:31,630 --> 00:19:33,070
but I don't know it shouldn't be there

520
00:19:33,070 --> 00:19:34,810
because I have no extra information to

521
00:19:34,810 --> 00:19:36,070
tell me that T

522
00:19:36,070 --> 00:19:41,200
t-1 did not actually commit so the two

523
00:19:41,200 --> 00:19:44,259
things we talked about here where the

524
00:19:44,259 --> 00:19:45,840
two decisions we had to make we're here

525
00:19:45,840 --> 00:19:49,299
whether we should require to force the

526
00:19:49,299 --> 00:19:50,559
the transaction and write out all its

527
00:19:50,559 --> 00:19:52,450
dirty pages out the disk but fourth law

528
00:19:52,450 --> 00:19:54,820
to commit and whether or not we're

529
00:19:54,820 --> 00:19:58,899
allowed to copy out a page or a victim a

530
00:19:58,899 --> 00:20:00,879
strimer buffer pool from a transaction

531
00:20:00,879 --> 00:20:04,239
that has not committed yet so these two

532
00:20:04,239 --> 00:20:07,989
policies are called steal and force so

533
00:20:07,989 --> 00:20:09,669
the steal policy says whether

534
00:20:09,669 --> 00:20:11,139
transaction they by their database

535
00:20:11,139 --> 00:20:13,049
systems allows a uncommitted transaction

536
00:20:13,049 --> 00:20:15,940
to overwrite the most recent committed

537
00:20:15,940 --> 00:20:18,759
value of an object in the database ad on

538
00:20:18,759 --> 00:20:23,619
disk before it's allowed to commit so if

539
00:20:23,619 --> 00:20:25,629
you say if steal if you're using a steal

540
00:20:25,629 --> 00:20:27,309
policy then you're allowed to do this if

541
00:20:27,309 --> 00:20:29,080
you're using no steal then it's not

542
00:20:29,080 --> 00:20:31,269
allowed the way to think about this is

543
00:20:31,269 --> 00:20:32,590
if I'm running out of space my buffer

544
00:20:32,590 --> 00:20:35,679
pool from one transaction is that

545
00:20:35,679 --> 00:20:38,590
transaction allowed to steal a page in

546
00:20:38,590 --> 00:20:39,909
the buffer pool or slot in the buffer

547
00:20:39,909 --> 00:20:42,220
pool from another transaction that has

548
00:20:42,220 --> 00:20:45,129
not committed yet right that's why it's

549
00:20:45,129 --> 00:20:49,359
called steal the forest policy says

550
00:20:49,359 --> 00:20:52,119
whether we require that all updates that

551
00:20:52,119 --> 00:20:53,769
a transaction makes to any object in the

552
00:20:53,769 --> 00:20:55,419
database have to be written to disk

553
00:20:55,419 --> 00:21:00,789
first before it's allowed to commit so

554
00:21:00,789 --> 00:21:02,169
if you say I'm using the forest policy

555
00:21:02,169 --> 00:21:04,659
then it's required to do this if you're

556
00:21:04,659 --> 00:21:10,169
using no force then it's not required so

557
00:21:10,169 --> 00:21:12,749
forcing is gonna make it our life easier

558
00:21:12,749 --> 00:21:14,979
because it's gonna allow us to recover

559
00:21:14,979 --> 00:21:16,330
rather quickly because we just come back

560
00:21:16,330 --> 00:21:18,299
and we see all our changes are there

561
00:21:18,299 --> 00:21:20,769
right we don't have to you know look at

562
00:21:20,769 --> 00:21:22,330
any other place to try to redo

563
00:21:22,330 --> 00:21:25,450
information to redo the changes but the

564
00:21:25,450 --> 00:21:26,590
steal policies would be problematic

565
00:21:26,590 --> 00:21:28,119
because now we're clean writing out

566
00:21:28,119 --> 00:21:29,559
changes or transactions that have not

567
00:21:29,559 --> 00:21:33,279
committed so let's look at one way to do

568
00:21:33,279 --> 00:21:34,779
this let's look at the no steal forest

569
00:21:34,779 --> 00:21:35,859
policy right because they're sort of

570
00:21:35,859 --> 00:21:39,399
they have a flippin goals and you know

571
00:21:39,399 --> 00:21:40,869
you can only choose you know two

572
00:21:40,869 --> 00:21:43,539
combinations of these two things so no

573
00:21:43,539 --> 00:21:46,149
steal force means that no steal says

574
00:21:46,149 --> 00:21:49,059
that any uncommitted changes any changes

575
00:21:49,059 --> 00:21:49,840
made by Duncan

576
00:21:49,840 --> 00:21:51,820
action cannot be written a disk and the

577
00:21:51,820 --> 00:21:54,909
force says that any change all changes

578
00:21:54,909 --> 00:21:56,380
ever turns actually may have to be

579
00:21:56,380 --> 00:21:57,610
written to disk before the transactions

580
00:21:57,610 --> 00:22:01,120
allowed to commit so t1 starts does a

581
00:22:01,120 --> 00:22:02,440
read on a we bring that a buffer pool

582
00:22:02,440 --> 00:22:03,309
that's fine

583
00:22:03,309 --> 00:22:05,860
now we do the write on a update the the

584
00:22:05,860 --> 00:22:08,289
the page and our buffer pool then we do

585
00:22:08,289 --> 00:22:10,299
a context switch of t2 t2 does a read

586
00:22:10,299 --> 00:22:12,490
then does the right we update the buffer

587
00:22:12,490 --> 00:22:14,650
pool then now wants to go ahead and

588
00:22:14,650 --> 00:22:17,620
commit again the forest policy says that

589
00:22:17,620 --> 00:22:19,150
all the changes for this transaction

590
00:22:19,150 --> 00:22:21,549
made have to even out the disk but we

591
00:22:21,549 --> 00:22:24,399
have this this change from t1 hanging

592
00:22:24,399 --> 00:22:26,440
out here as well so we need to get rid

593
00:22:26,440 --> 00:22:30,000
of that so what do we need to do right

594
00:22:30,000 --> 00:22:34,029
copy the page in memory right only apply

595
00:22:34,029 --> 00:22:35,679
the change that we want or reverse this

596
00:22:35,679 --> 00:22:37,840
other change we don't want and then we

597
00:22:37,840 --> 00:22:42,309
can go ahead and write that out so now

598
00:22:42,309 --> 00:22:44,820
when we when we come back over here and

599
00:22:44,820 --> 00:22:48,370
we abort t1 now it's super trivial for

600
00:22:48,370 --> 00:22:52,240
us to reverse the change that all the

601
00:22:52,240 --> 00:22:54,010
change that t1 made because it's just

602
00:22:54,010 --> 00:22:56,140
updating this this this page in memory

603
00:22:56,140 --> 00:22:57,730
we don't have to go out the disk was you

604
00:22:57,730 --> 00:22:59,679
know no dirty dirty change got written

605
00:22:59,679 --> 00:23:02,950
out there so the database system is

606
00:23:02,950 --> 00:23:04,450
going to maintain some extra metadata to

607
00:23:04,450 --> 00:23:05,710
keep track of the right set over these

608
00:23:05,710 --> 00:23:07,390
different transactions you guys already

609
00:23:07,390 --> 00:23:08,950
solved this under two-phase locking and

610
00:23:08,950 --> 00:23:11,799
and OCC under concur to your particles

611
00:23:11,799 --> 00:23:13,270
so we already have that information

612
00:23:13,270 --> 00:23:14,980
about what changes they made to what

613
00:23:14,980 --> 00:23:17,080
objects so it's not that big of a deal

614
00:23:17,080 --> 00:23:18,250
or extra work we have to do to be able

615
00:23:18,250 --> 00:23:19,809
to reverse that change when you make

616
00:23:19,809 --> 00:23:22,570
that copy all right and it's in memory

617
00:23:22,570 --> 00:23:25,779
so that should be pretty fast so this

618
00:23:25,779 --> 00:23:31,750
seemed like a good idea or a bad idea so

619
00:23:31,750 --> 00:23:33,580
that's one what's one good thing about

620
00:23:33,580 --> 00:23:36,450
this approach I've already said it

621
00:23:36,450 --> 00:23:40,090
detector right there it's super trivial

622
00:23:40,090 --> 00:23:42,610
to rollback after a crash there's

623
00:23:42,610 --> 00:23:43,360
because there's nothing to rollback

624
00:23:43,360 --> 00:23:45,159
because I know that anything is that

625
00:23:45,159 --> 00:23:47,289
that's on add on disk should be out on

626
00:23:47,289 --> 00:23:48,549
disk because they're all from committed

627
00:23:48,549 --> 00:23:51,000
transactions

628
00:23:53,740 --> 00:23:55,460
what's that sorry is there a deadlock

629
00:23:55,460 --> 00:24:16,970
between two transactions so his question

630
00:24:16,970 --> 00:24:20,030
is going back here in my example here I

631
00:24:20,030 --> 00:24:23,120
have one thread or one transaction wants

632
00:24:23,120 --> 00:24:24,350
to write out something disk it makes one

633
00:24:24,350 --> 00:24:26,270
copy but then another transaction may be

634
00:24:26,270 --> 00:24:28,070
committing at the same time and it

635
00:24:28,070 --> 00:24:29,270
modified the same page you shouldn't

636
00:24:29,270 --> 00:24:31,460
make another copy we can ignore that we

637
00:24:31,460 --> 00:24:34,850
assume that I mean you have to have a

638
00:24:34,850 --> 00:24:36,440
single latch protect these things

639
00:24:36,440 --> 00:24:38,600
there's no way to get around that but we

640
00:24:38,600 --> 00:24:44,210
can ignore all that here so there's

641
00:24:44,210 --> 00:24:47,870
there's two problems actually three

642
00:24:47,870 --> 00:25:03,260
problems yes so you're close these first

643
00:25:03,260 --> 00:25:05,720
two he said the now and your processing

644
00:25:05,720 --> 00:25:07,520
page to commit this copy here it's more

645
00:25:07,520 --> 00:25:09,830
work it's on the critical path it's in

646
00:25:09,830 --> 00:25:11,390
the critical section of the commit the

647
00:25:11,390 --> 00:25:13,610
commit protocol for the commercial

648
00:25:13,610 --> 00:25:15,830
mechanism that becomes more expensive

649
00:25:15,830 --> 00:25:20,059
yes absolutely right yes but more than

650
00:25:20,059 --> 00:25:22,820
just CPU cost it's actually the you have

651
00:25:22,820 --> 00:25:23,870
to write this thing out multiple times

652
00:25:23,870 --> 00:25:26,120
now like so say if you go back if we go

653
00:25:26,120 --> 00:25:29,390
here if t1 didn't actually abort and

654
00:25:29,390 --> 00:25:31,700
actually committed then in order to get

655
00:25:31,700 --> 00:25:33,950
it's changed a out the disk I'll never

656
00:25:33,950 --> 00:25:36,440
write it out again so for every

657
00:25:36,440 --> 00:25:37,820
transaction that commits I potentially

658
00:25:37,820 --> 00:25:39,440
have to write out the same page over and

659
00:25:39,440 --> 00:25:51,919
over again yes exactly

660
00:25:51,919 --> 00:25:54,320
he's actually right so one big issue

661
00:25:54,320 --> 00:25:56,450
with this in my seabone example here I

662
00:25:56,450 --> 00:25:59,030
have one page say it's four kilobytes

663
00:25:59,030 --> 00:26:00,890
the harbor I can guarantee that I can do

664
00:26:00,890 --> 00:26:03,049
a four atonic four kilobyte page right

665
00:26:03,049 --> 00:26:05,659
but if I update multiple pages the

666
00:26:05,659 --> 00:26:06,630
harbor can't guarantee

667
00:26:06,630 --> 00:26:08,880
that for me so I could if I update four

668
00:26:08,880 --> 00:26:10,740
pages I've read out the first two then I

669
00:26:10,740 --> 00:26:12,570
crashed before I get the next two now I

670
00:26:12,570 --> 00:26:14,310
come back and I don't have you know I

671
00:26:14,310 --> 00:26:18,180
have a torn up dates so that see that's

672
00:26:18,180 --> 00:26:19,500
right that's one big problem there's

673
00:26:19,500 --> 00:26:24,980
another big one that's a more nuanced so

674
00:26:24,980 --> 00:26:27,570
again I have one page of this this is

675
00:26:27,570 --> 00:26:31,140
sort of trivial example but in this case

676
00:26:31,140 --> 00:26:33,690
here for a given transaction since I

677
00:26:33,690 --> 00:26:36,330
can't write out any dirty data from

678
00:26:36,330 --> 00:26:38,970
uncommitted transaction to disk that

679
00:26:38,970 --> 00:26:41,610
means I can my my right set all my

680
00:26:41,610 --> 00:26:43,800
transaction has to fit entirely in main

681
00:26:43,800 --> 00:26:46,530
memory so if I have a table has 1

682
00:26:46,530 --> 00:26:47,880
billion tuples I have a single query

683
00:26:47,880 --> 00:26:49,320
that wants to update all 1 billion

684
00:26:49,320 --> 00:26:51,630
tuples but I can only store 1 million

685
00:26:51,630 --> 00:26:54,000
tuples in my buffer pool then I can't

686
00:26:54,000 --> 00:26:55,800
run that transaction in under this this

687
00:26:55,800 --> 00:26:58,710
this this system cuz I'll hit the first

688
00:26:58,710 --> 00:27:00,900
1 million update them that's fine then I

689
00:27:00,900 --> 00:27:02,910
try to get the million plus one and then

690
00:27:02,910 --> 00:27:08,480
I'm running on it I ran out of space so

691
00:27:08,600 --> 00:27:11,190
he says can't you is there a workaround

692
00:27:11,190 --> 00:27:13,110
can you write into a temporary spot yes

693
00:27:13,110 --> 00:27:15,180
give me two slides that is that is that

694
00:27:15,180 --> 00:27:17,340
is the solution yes it's not a good one

695
00:27:17,340 --> 00:27:24,450
but it's one okay so no steal force is

696
00:27:24,450 --> 00:27:26,670
the most easiest way to actually

697
00:27:26,670 --> 00:27:30,030
implement a recoverable correct durable

698
00:27:30,030 --> 00:27:32,250
buffer pool manager and a disscourn a

699
00:27:32,250 --> 00:27:34,470
database system because I don't have to

700
00:27:34,470 --> 00:27:36,360
do any redo after a crash I just come

701
00:27:36,360 --> 00:27:38,430
back my database is guaranteeing the

702
00:27:38,430 --> 00:27:43,080
correct state and I never have to go you

703
00:27:43,080 --> 00:27:44,850
know undo anything from an aborted

704
00:27:44,850 --> 00:27:46,050
transaction at run time because I know

705
00:27:46,050 --> 00:27:47,580
none of us changes ever made it out the

706
00:27:47,580 --> 00:27:50,550
disk but as we said already that you you

707
00:27:50,550 --> 00:27:52,680
can't support transactions that have a

708
00:27:52,680 --> 00:27:53,850
right set that exceed the amount of

709
00:27:53,850 --> 00:27:56,610
memory that's available to you the

710
00:27:56,610 --> 00:27:58,590
commit protocol is now more expensive

711
00:27:58,590 --> 00:28:00,150
because you have to do all these extra

712
00:28:00,150 --> 00:28:01,680
extra work to figure out what things

713
00:28:01,680 --> 00:28:02,790
actually should be written to disk where

714
00:28:02,790 --> 00:28:06,750
it's not written disk and the and you're

715
00:28:06,750 --> 00:28:09,390
doing multiply out to disk you know for

716
00:28:09,390 --> 00:28:11,190
everything that could have just been one

717
00:28:11,190 --> 00:28:13,230
right now for every single transaction

718
00:28:13,230 --> 00:28:14,610
you're writing the same page over and

719
00:28:14,610 --> 00:28:16,740
over again and if you're an SSD those

720
00:28:16,740 --> 00:28:18,120
things actually can't be written forever

721
00:28:18,120 --> 00:28:19,800
right you can burn out the cells on the

722
00:28:19,800 --> 00:28:20,420
SSD

723
00:28:20,420 --> 00:28:23,160
you know it's in the hundreds and

724
00:28:23,160 --> 00:28:25,380
thousands right Purcell but eventually

725
00:28:25,380 --> 00:28:26,670
to keep doing this if you're just

726
00:28:26,670 --> 00:28:28,260
running a lot you'll burn it out in a

727
00:28:28,260 --> 00:28:32,700
short amount of time so nobody actually

728
00:28:32,700 --> 00:28:35,100
does what I'm describing here right it

729
00:28:35,100 --> 00:28:37,080
is the easiest way to implement it but

730
00:28:37,080 --> 00:28:40,050
nobody actually does this the thing that

731
00:28:40,050 --> 00:28:43,950
he alluded to that people have tried

732
00:28:43,950 --> 00:28:46,770
before is to basically store the changes

733
00:28:46,770 --> 00:28:47,940
you're making from uncommitted

734
00:28:47,940 --> 00:28:50,750
transactions in a temporary space and

735
00:28:50,750 --> 00:28:53,070
then at some point when the transaction

736
00:28:53,070 --> 00:28:55,950
commits you somehow resolve the the

737
00:28:55,950 --> 00:28:58,110
directory or the page table to now say

738
00:28:58,110 --> 00:29:00,210
here are actually the correct the latest

739
00:29:00,210 --> 00:29:02,490
versions of our of our pages and that

740
00:29:02,490 --> 00:29:04,500
way if you crash you just ignore

741
00:29:04,500 --> 00:29:06,300
anything that got modified in this can

742
00:29:06,300 --> 00:29:08,610
those temporary buffers so this is what

743
00:29:08,610 --> 00:29:10,890
shadow paging is we briefly touch about

744
00:29:10,890 --> 00:29:12,480
this in the very beginning when we talk

745
00:29:12,480 --> 00:29:15,270
about current control this is one way to

746
00:29:15,270 --> 00:29:18,420
do a no steal force buffle management

747
00:29:18,420 --> 00:29:20,490
system that avoids some of the

748
00:29:20,490 --> 00:29:23,580
complications we talked about before so

749
00:29:23,580 --> 00:29:25,230
lay shadow paging worships it's like

750
00:29:25,230 --> 00:29:28,170
it's sort of like multi versioning but

751
00:29:28,170 --> 00:29:29,610
at the page level instead of the tuple

752
00:29:29,610 --> 00:29:32,040
level and there's only going to be two

753
00:29:32,040 --> 00:29:33,840
copies at any given time there's always

754
00:29:33,840 --> 00:29:36,540
the master copy that's the latest most

755
00:29:36,540 --> 00:29:38,370
recently committed version of of the

756
00:29:38,370 --> 00:29:41,250
database and then there's the the shadow

757
00:29:41,250 --> 00:29:43,080
copy that all new transactions are going

758
00:29:43,080 --> 00:29:46,080
to end up modifying so when a

759
00:29:46,080 --> 00:29:47,940
transaction commits we want a way to

760
00:29:47,940 --> 00:29:51,630
atomically switch the the shadow to

761
00:29:51,630 --> 00:29:54,660
become the new master I mean we can do

762
00:29:54,660 --> 00:29:55,770
this in such a way that we don't worry

763
00:29:55,770 --> 00:29:57,780
about torn rights if we're updating

764
00:29:57,780 --> 00:30:04,710
multiple pages so unlike in in Multi

765
00:30:04,710 --> 00:30:06,660
versioning where we copy every single

766
00:30:06,660 --> 00:30:09,570
thing we're going to modify actually

767
00:30:09,570 --> 00:30:11,400
it's like multi burgeoning but instead

768
00:30:11,400 --> 00:30:12,750
of doing a tuple of what you're doing at

769
00:30:12,750 --> 00:30:15,150
a page level and you can organize the

770
00:30:15,150 --> 00:30:17,760
the directory of your pages as a tree

771
00:30:17,760 --> 00:30:19,890
structure so now you only need a cat

772
00:30:19,890 --> 00:30:22,200
copy sort of portions of the tree and

773
00:30:22,200 --> 00:30:24,750
then just do Pat copying to update them

774
00:30:24,750 --> 00:30:28,200
in place or apply them to the the page

775
00:30:28,200 --> 00:30:30,360
table without having to recreate the

776
00:30:30,360 --> 00:30:32,210
entire hash table all over again

777
00:30:32,210 --> 00:30:35,960
so at the root of this tree is gonna be

778
00:30:35,960 --> 00:30:37,700
the database root that's always gonna

779
00:30:37,700 --> 00:30:40,070
point to the latest master master

780
00:30:40,070 --> 00:30:42,619
version so that means we can make a

781
00:30:42,619 --> 00:30:44,210
bunch of changes to the low portion of

782
00:30:44,210 --> 00:30:46,580
the tree but update the lease to point

783
00:30:46,580 --> 00:30:48,019
into our new pages that we just created

784
00:30:48,019 --> 00:30:50,119
and then when we're ready to apply the

785
00:30:50,119 --> 00:30:51,769
changes to atomically across all these

786
00:30:51,769 --> 00:30:53,929
pages we just swing this database root

787
00:30:53,929 --> 00:30:55,629
pointer to now point to our shadow

788
00:30:55,629 --> 00:30:58,220
portion of the tree and then all all our

789
00:30:58,220 --> 00:31:00,499
changes get immediately become

790
00:31:00,499 --> 00:31:03,139
immediately visible so a high level

791
00:31:03,139 --> 00:31:04,309
looks like this again there's this

792
00:31:04,309 --> 00:31:05,899
database root and it points to the

793
00:31:05,899 --> 00:31:07,669
master page table and this master page

794
00:31:07,669 --> 00:31:10,720
table points to our pages out on disk so

795
00:31:10,720 --> 00:31:13,789
I'm gonna briefly go with this but goof

796
00:31:13,789 --> 00:31:15,889
is sort of quickly but let me just get

797
00:31:15,889 --> 00:31:19,549
this get to the example so say we have a

798
00:31:19,549 --> 00:31:22,129
transaction comes along t1 any

799
00:31:22,129 --> 00:31:23,659
transaction that's read-only can go

800
00:31:23,659 --> 00:31:25,159
always go to this database root and go

801
00:31:25,159 --> 00:31:26,929
to the the master copy and see a

802
00:31:26,929 --> 00:31:28,730
consistent version but if we have an

803
00:31:28,730 --> 00:31:30,080
updating transaction we have to create a

804
00:31:30,080 --> 00:31:32,269
shadow page table that the the

805
00:31:32,269 --> 00:31:34,460
transactions going to modify so the very

806
00:31:34,460 --> 00:31:36,230
beginning the shadow page table it just

807
00:31:36,230 --> 00:31:38,059
all its entries point to the same pages

808
00:31:38,059 --> 00:31:40,009
that the master page points to the

809
00:31:40,009 --> 00:31:42,259
master page table points to them so now

810
00:31:42,259 --> 00:31:44,779
as this transaction starts modifying

811
00:31:44,779 --> 00:31:47,450
pages we're going to make a copy of that

812
00:31:47,450 --> 00:31:49,850
page into a new location in our

813
00:31:49,850 --> 00:31:52,340
temporary space in on disk make all our

814
00:31:52,340 --> 00:31:54,740
changes there right and we keep doing

815
00:31:54,740 --> 00:31:56,090
this for all all the other all the other

816
00:31:56,090 --> 00:31:58,999
pages we want to modify and then when

817
00:31:58,999 --> 00:32:00,529
this transaction says I want to go ahead

818
00:32:00,529 --> 00:32:04,759
and commit all we need to do is update

819
00:32:04,759 --> 00:32:06,499
this database root which is stored in a

820
00:32:06,499 --> 00:32:10,360
single page to now point to that the

821
00:32:10,360 --> 00:32:12,710
this portion or this patient of the

822
00:32:12,710 --> 00:32:15,169
shadow page table so we flush that

823
00:32:15,169 --> 00:32:17,570
change out the disk and then now it

824
00:32:17,570 --> 00:32:19,549
really becomes that becomes once that's

825
00:32:19,549 --> 00:32:21,169
durable we then swing that pointer in

826
00:32:21,169 --> 00:32:22,610
memory and then we now know that

827
00:32:22,610 --> 00:32:24,409
everyone can can follow this one so if a

828
00:32:24,409 --> 00:32:26,269
new transaction comes along and once it

829
00:32:26,269 --> 00:32:27,980
wants to you know want to read what the

830
00:32:27,980 --> 00:32:30,259
latest version is of the database it

831
00:32:30,259 --> 00:32:31,399
just follows this route and finds the

832
00:32:31,399 --> 00:32:37,360
shadow page table yes

833
00:32:41,240 --> 00:32:43,500
questions wisely Davis root written the

834
00:32:43,500 --> 00:32:50,010
desk right so they crash right so so I'm

835
00:32:50,010 --> 00:32:52,140
here byte resident transaction says I

836
00:32:52,140 --> 00:32:53,940
want to commit I want to tell the

837
00:32:53,940 --> 00:32:59,520
outside world I commit it right so if I

838
00:32:59,520 --> 00:33:01,860
don't update this database route I crash

839
00:33:01,860 --> 00:33:04,140
and come back and now I look at my date

840
00:33:04,140 --> 00:33:05,370
of his route and he's putting to the

841
00:33:05,370 --> 00:33:07,050
master page table and all these changes

842
00:33:07,050 --> 00:33:30,210
are gone correct yes it's Alama it's I

843
00:33:30,210 --> 00:33:34,010
think it's a page number two page ID

844
00:33:34,010 --> 00:33:36,540
right dad has to be durable cuz if I

845
00:33:36,540 --> 00:33:38,580
crash to come back if I tell Fiats I'd

846
00:33:38,580 --> 00:33:42,270
world I commit but then I crash I'm like

847
00:33:42,270 --> 00:33:42,930
alright wall

848
00:33:42,930 --> 00:33:44,160
I'll assume whatever this thing was

849
00:33:44,160 --> 00:33:45,810
pointing out is the is the root of the

850
00:33:45,810 --> 00:33:47,580
page table and that means I told the

851
00:33:47,580 --> 00:33:49,050
house I weren't I committed but now all

852
00:33:49,050 --> 00:33:50,250
my changes I made here in the shadow pic

853
00:33:50,250 --> 00:33:52,920
table are gone they're still there on

854
00:33:52,920 --> 00:33:55,650
disk it's just no one can see them there

855
00:33:55,650 --> 00:33:57,660
you can't logically see them so it's as

856
00:33:57,660 --> 00:34:15,570
if they didn't exist you quit your

857
00:34:15,570 --> 00:34:19,440
question is can you be clever and figure

858
00:34:19,440 --> 00:34:22,649
out a way to when you write out these

859
00:34:22,649 --> 00:34:24,899
pages put a little mark in here to say

860
00:34:24,899 --> 00:34:29,520
yeah you're the latest version yeah so

861
00:34:29,520 --> 00:34:31,050
all right so this guy updated three

862
00:34:31,050 --> 00:34:34,739
three pages so I need to now record that

863
00:34:34,739 --> 00:34:38,040
okay you updated three three out of X

864
00:34:38,040 --> 00:34:40,560
pages or n pages to make sure that if I

865
00:34:40,560 --> 00:34:42,469
crash come back I see all those changes

866
00:34:42,469 --> 00:34:44,030
yeah

867
00:34:44,030 --> 00:34:45,469
essentially because you know essentially

868
00:34:45,469 --> 00:34:47,810
I'm disc right now without the according

869
00:34:47,810 --> 00:34:48,800
the data make sure you have some

870
00:34:48,800 --> 00:34:50,510
something like out of some out-of-date

871
00:34:50,510 --> 00:34:52,580
pages there right use except to keep

872
00:34:52,580 --> 00:34:54,139
track of whichever the data major tells

873
00:34:54,139 --> 00:34:55,010
you which ones are the most up-to-date

874
00:34:55,010 --> 00:34:56,389
well yes essentially whatever

875
00:34:56,389 --> 00:34:58,160
transaction commits lets you bring some

876
00:34:58,160 --> 00:35:00,020
pages out to disk with those two pages

877
00:35:00,020 --> 00:35:01,670
right now for this you may know the

878
00:35:01,670 --> 00:35:03,140
timestamps or the transaction or

879
00:35:03,140 --> 00:35:09,470
something sure my database is 100

880
00:35:09,470 --> 00:35:14,630
petabytes that this is one page it has

881
00:35:14,630 --> 00:35:17,810
everything I need always can always

882
00:35:17,810 --> 00:35:27,080
think in extremes yes excellent so he

883
00:35:27,080 --> 00:35:29,570
said and in my example here I have one

884
00:35:29,570 --> 00:35:31,370
transaction what if I have a bunch of

885
00:35:31,370 --> 00:35:32,720
transactions at the same time how does

886
00:35:32,720 --> 00:35:33,320
this work

887
00:35:33,320 --> 00:35:37,280
so you either have to have only one

888
00:35:37,280 --> 00:35:39,770
transaction run out of time which sequel

889
00:35:39,770 --> 00:35:43,310
light does or you you have to commit

890
00:35:43,310 --> 00:35:46,820
them in a batch so I say I ignoring two

891
00:35:46,820 --> 00:35:48,080
days locking because all that is

892
00:35:48,080 --> 00:35:50,210
orthogonal to this assume that you don't

893
00:35:50,210 --> 00:35:51,290
have a way to figure out who's allowed

894
00:35:51,290 --> 00:35:53,540
to update what if I have multi Tunes

895
00:35:53,540 --> 00:35:55,040
actions within the same batch updating

896
00:35:55,040 --> 00:35:57,890
things I have to wait until they all

897
00:35:57,890 --> 00:36:00,170
finish then they all get committed I

898
00:36:00,170 --> 00:36:02,690
swing mop my database root pointer right

899
00:36:02,690 --> 00:36:04,910
and then it get all Tom I can apply so

900
00:36:04,910 --> 00:36:06,530
that's one way to do this if you assume

901
00:36:06,530 --> 00:36:07,850
all transactions are going to finish in

902
00:36:07,850 --> 00:36:09,770
a reason amount of time if you have one

903
00:36:09,770 --> 00:36:11,870
transaction that takes an hour then you

904
00:36:11,870 --> 00:36:13,190
either need to kill it if for a certain

905
00:36:13,190 --> 00:36:14,480
amount of time or wait that one hour

906
00:36:14,480 --> 00:36:15,740
before everybody goes it goes ahead and

907
00:36:15,740 --> 00:36:20,360
commits some systems do this it is rare

908
00:36:20,360 --> 00:36:22,490
it's most systems don't don't operate

909
00:36:22,490 --> 00:36:23,930
this way but you most absorbing do

910
00:36:23,930 --> 00:36:28,130
shadow paging all right IBM did this in

911
00:36:28,130 --> 00:36:31,130
system or in the 1970s they abandoned it

912
00:36:31,130 --> 00:36:33,350
in the 1980s when they did db2 because

913
00:36:33,350 --> 00:36:35,690
you have fragmentation issues right so

914
00:36:35,690 --> 00:36:37,940
now I blow a master page table I blow

915
00:36:37,940 --> 00:36:40,190
away these pages here because they're no

916
00:36:40,190 --> 00:36:42,440
longer visible right so this is all that

917
00:36:42,440 --> 00:36:44,570
I have now but it doesn't match up the

918
00:36:44,570 --> 00:36:47,840
ordering of pages here so now we do

919
00:36:47,840 --> 00:36:49,220
sequential scan I you know I may not be

920
00:36:49,220 --> 00:36:50,090
reading things in the right order so I

921
00:36:50,090 --> 00:36:51,590
can't do clustering index is what they

922
00:36:51,590 --> 00:36:52,670
were trying to do back in the day

923
00:36:52,670 --> 00:36:55,280
so nobody actually does this but you

924
00:36:55,280 --> 00:36:56,090
have to be right you're there you to

925
00:36:56,090 --> 00:36:57,050
commit him to bat or have one

926
00:36:57,050 --> 00:36:57,710
transaction from

927
00:36:57,710 --> 00:37:22,550
a time yes you know so you're going back

928
00:37:22,550 --> 00:37:25,609
to the previous table word t1 t2 would

929
00:37:25,609 --> 00:37:27,980
that handle in this case yes if you

930
00:37:27,980 --> 00:37:29,690
assume t1 t2 are committing together in

931
00:37:29,690 --> 00:37:33,410
the same batch right so yes q this is

932
00:37:33,410 --> 00:37:34,730
Hanna exactly in that case because again

933
00:37:34,730 --> 00:37:37,280
I have the undo information I need to

934
00:37:37,280 --> 00:37:38,599
reverse any changes that a transaction

935
00:37:38,599 --> 00:37:43,280
made in memory so if as long as that

936
00:37:43,280 --> 00:37:46,280
thing has been written out the disk then

937
00:37:46,280 --> 00:37:48,830
I can just reverse it here and I'm fine

938
00:37:48,830 --> 00:37:50,720
and if I crash before I flip the Davis

939
00:37:50,720 --> 00:37:59,540
reporter then I'm fine okay so nobody

940
00:37:59,540 --> 00:38:01,490
actually does this so let's jump through

941
00:38:01,490 --> 00:38:02,890
more quickly and get to the good stuff

942
00:38:02,890 --> 00:38:05,869
so the reason why this sucks it because

943
00:38:05,869 --> 00:38:08,450
copying the entire page table is

944
00:38:08,450 --> 00:38:10,369
expensive you even if you use a tree

945
00:38:10,369 --> 00:38:12,920
structure it becomes it's not cheap and

946
00:38:12,920 --> 00:38:14,750
the committe overhead is high because

947
00:38:14,750 --> 00:38:16,490
you have to update flush every single

948
00:38:16,490 --> 00:38:18,770
page that you modified the page table

949
00:38:18,770 --> 00:38:20,570
and the route the date becomes

950
00:38:20,570 --> 00:38:22,430
fragmented you need a background garbage

951
00:38:22,430 --> 00:38:23,359
collector just like in a multi version

952
00:38:23,359 --> 00:38:25,790
cartridge hole and you either have to

953
00:38:25,790 --> 00:38:27,109
commit everything in a batch or only

954
00:38:27,109 --> 00:38:30,050
have one writer out of time so as I said

955
00:38:30,050 --> 00:38:31,369
the only systems I know that actually

956
00:38:31,369 --> 00:38:35,420
does do this or a couchdb but I think

957
00:38:35,420 --> 00:38:37,730
CouchDB is giving is going away from

958
00:38:37,730 --> 00:38:40,730
that and doing their switching over to

959
00:38:40,730 --> 00:38:44,510
Roxy ve l MV B is a tree based system

960
00:38:44,510 --> 00:38:46,790
that uses M map so that's sort of hidden

961
00:38:46,790 --> 00:38:49,790
from them and then against the system

962
00:38:49,790 --> 00:38:51,980
are in the 1970s but they banded that

963
00:38:51,980 --> 00:38:55,220
IBM abandoned that in 1980s it one

964
00:38:55,220 --> 00:38:56,330
system you probably have heard about

965
00:38:56,330 --> 00:38:57,680
that does something similar to this as

966
00:38:57,680 --> 00:38:59,480
sequel Lite but this is what sequel I

967
00:38:59,480 --> 00:39:02,780
did up until 2010 then they dished it to

968
00:39:02,780 --> 00:39:04,070
and switched to over what we'll talk

969
00:39:04,070 --> 00:39:04,730
about next

970
00:39:04,730 --> 00:39:06,830
the write ahead logging approach so

971
00:39:06,830 --> 00:39:07,970
what's eagle light would do is that

972
00:39:07,970 --> 00:39:11,540
instead of copying the

973
00:39:11,540 --> 00:39:15,260
instead of copying the page that you

974
00:39:15,260 --> 00:39:16,580
would they're gonna modify and make a

975
00:39:16,580 --> 00:39:18,350
modification in the copy they have a

976
00:39:18,350 --> 00:39:20,960
copy original page write that out the

977
00:39:20,960 --> 00:39:23,120
disk then make the modification to the

978
00:39:23,120 --> 00:39:25,760
master version and then if you commit

979
00:39:25,760 --> 00:39:28,190
you just blow away the the copy that you

980
00:39:28,190 --> 00:39:30,290
had or if you crash before you commit

981
00:39:30,290 --> 00:39:32,390
then you then you look back in that that

982
00:39:32,390 --> 00:39:34,280
separate copy file and restore the

983
00:39:34,280 --> 00:39:36,770
restore the change so they would call

984
00:39:36,770 --> 00:39:38,540
this the Journal file so let's say that

985
00:39:38,540 --> 00:39:40,580
my transaction was a month update page

986
00:39:40,580 --> 00:39:43,130
two so before I modify page 2 in memory

987
00:39:43,130 --> 00:39:45,320
I first make a copy to it persist it on

988
00:39:45,320 --> 00:39:47,390
disk and a journal file and then when

989
00:39:47,390 --> 00:39:48,800
that's done I can modify it

990
00:39:48,800 --> 00:39:51,050
same thing with page 3 before I can

991
00:39:51,050 --> 00:39:52,550
modify it I make a copy into separate

992
00:39:52,550 --> 00:39:54,860
journal file then I go ahead and make my

993
00:39:54,860 --> 00:39:57,170
change now let's say before this

994
00:39:57,170 --> 00:39:59,240
transaction actually commits we end up

995
00:39:59,240 --> 00:40:02,120
flushing out page 2 out the disk but

996
00:40:02,120 --> 00:40:04,280
before we flush out page 3 and complete

997
00:40:04,280 --> 00:40:06,820
and actually commit this thing we crash

998
00:40:06,820 --> 00:40:08,900
alright so everything gets it gets blown

999
00:40:08,900 --> 00:40:11,930
away in memory so when we come back we

1000
00:40:11,930 --> 00:40:13,670
would say alright well I have a journal

1001
00:40:13,670 --> 00:40:15,800
file so I need I need I made me make

1002
00:40:15,800 --> 00:40:17,480
sure that all my changes that are in

1003
00:40:17,480 --> 00:40:19,010
this journal Fog cuz these the original

1004
00:40:19,010 --> 00:40:21,290
versions they get written out back to

1005
00:40:21,290 --> 00:40:26,060
the the original disk file so again like

1006
00:40:26,060 --> 00:40:28,460
I said this is what this what sequel

1007
00:40:28,460 --> 00:40:30,770
light did up till 2010 and then they

1008
00:40:30,770 --> 00:40:32,660
abandon this for performance reasons to

1009
00:40:32,660 --> 00:40:38,870
use to write headlong okay so this

1010
00:40:38,870 --> 00:40:42,230
shadow paging approach it'll guarantee

1011
00:40:42,230 --> 00:40:43,730
correctness but it has some of some

1012
00:40:43,730 --> 00:40:44,870
performance issues and the main

1013
00:40:44,870 --> 00:40:47,480
performance issue is going to be that

1014
00:40:47,480 --> 00:40:49,700
it's we're gonna do a bunch of random

1015
00:40:49,700 --> 00:40:53,300
i/o so in my back going back here in the

1016
00:40:53,300 --> 00:40:56,480
sequel Lite example when I had to replay

1017
00:40:56,480 --> 00:40:58,220
the journal file I'm updating random

1018
00:40:58,220 --> 00:41:01,250
locations on disk to in order to restore

1019
00:41:01,250 --> 00:41:02,450
the database back to the correct state

1020
00:41:02,450 --> 00:41:04,460
and here's a shadow paging when I was

1021
00:41:04,460 --> 00:41:06,080
flushing out all my changes and say my

1022
00:41:06,080 --> 00:41:08,360
transaction actually committed again I'm

1023
00:41:08,360 --> 00:41:10,160
doing random i/o to different locations

1024
00:41:10,160 --> 00:41:12,140
to persist all the changes from this

1025
00:41:12,140 --> 00:41:17,360
from the shadow Shadow Copy so even then

1026
00:41:17,360 --> 00:41:20,050
with it fast SSDs that we had today

1027
00:41:20,050 --> 00:41:22,520
sequential i/o has always be faster than

1028
00:41:22,520 --> 00:41:25,160
random i/o so we need

1029
00:41:25,160 --> 00:41:27,650
way to convert all those random iOS into

1030
00:41:27,650 --> 00:41:29,599
fast sequential i/o and still have all

1031
00:41:29,599 --> 00:41:31,849
the durability guarantees that we'd want

1032
00:41:31,849 --> 00:41:35,240
in our logging protocol so this is what

1033
00:41:35,240 --> 00:41:37,309
right ahead logging is gonna is gonna

1034
00:41:37,309 --> 00:41:39,799
achieve for us so the idea was right

1035
00:41:39,799 --> 00:41:40,970
ahead logs that we're going to maintain

1036
00:41:40,970 --> 00:41:43,520
a separate log file on non-volatile

1037
00:41:43,520 --> 00:41:46,670
storage along with our table heap and as

1038
00:41:46,670 --> 00:41:48,500
transactions make changes to the

1039
00:41:48,500 --> 00:41:51,170
database we're gonna make entries into

1040
00:41:51,170 --> 00:41:53,359
this log file that record the changes

1041
00:41:53,359 --> 00:41:56,510
that were made and then when a

1042
00:41:56,510 --> 00:41:58,400
transaction go has goes at once and I

1043
00:41:58,400 --> 00:41:59,349
hope go ahead and commit

1044
00:41:59,349 --> 00:42:01,549
we just need to guarantee that we

1045
00:42:01,549 --> 00:42:03,230
flushed the log records that they

1046
00:42:03,230 --> 00:42:06,099
generated out the disk and not the

1047
00:42:06,099 --> 00:42:08,599
capital changes to the to the objects of

1048
00:42:08,599 --> 00:42:11,420
the pages in the buffer pool so for

1049
00:42:11,420 --> 00:42:12,829
owner for us right head log in to say

1050
00:42:12,829 --> 00:42:13,910
our transaction is committed and it's

1051
00:42:13,910 --> 00:42:16,039
durable we only need to flush the log we

1052
00:42:16,039 --> 00:42:18,829
don't need to flush anything else and so

1053
00:42:18,829 --> 00:42:20,780
now the log file is just switch why oh

1054
00:42:20,780 --> 00:42:22,640
because there's keep appending to this

1055
00:42:22,640 --> 00:42:25,280
this file you know would you know page

1056
00:42:25,280 --> 00:42:27,349
after page of the page that again that's

1057
00:42:27,349 --> 00:42:28,849
when try always to be much faster than

1058
00:42:28,849 --> 00:42:31,279
the random i/o of of writing out the the

1059
00:42:31,279 --> 00:42:33,410
random pages and again the reading

1060
00:42:33,410 --> 00:42:34,670
reason why it's call it right ahead log

1061
00:42:34,670 --> 00:42:38,089
is because we make sure that any log

1062
00:42:38,089 --> 00:42:40,849
record that corresponds to a change made

1063
00:42:40,849 --> 00:42:43,130
to an object in the database is written

1064
00:42:43,130 --> 00:42:45,140
a disk before that object can be written

1065
00:42:45,140 --> 00:42:48,140
a disk so that's that's the very

1066
00:42:48,140 --> 00:42:49,339
important most important thing to

1067
00:42:49,339 --> 00:42:51,890
understand about write ahead logging so

1068
00:42:51,890 --> 00:42:53,089
write ahead logging at his example of

1069
00:42:53,089 --> 00:42:55,069
steal and no forest because we're gonna

1070
00:42:55,069 --> 00:42:56,480
be allowed to write dirty pages out the

1071
00:42:56,480 --> 00:42:58,609
disk before transactions actually commit

1072
00:42:58,609 --> 00:43:00,650
as long as their log records have been

1073
00:43:00,650 --> 00:43:03,440
written out first and then it's no for

1074
00:43:03,440 --> 00:43:04,849
us because we don't require all the

1075
00:43:04,849 --> 00:43:06,200
changes that the transaction made two

1076
00:43:06,200 --> 00:43:08,210
objects we burn out the disk we only

1077
00:43:08,210 --> 00:43:09,410
require that the law of records be

1078
00:43:09,410 --> 00:43:14,119
written as a disk so again this is the

1079
00:43:14,119 --> 00:43:15,170
most important thing you need to

1080
00:43:15,170 --> 00:43:17,029
understand in order to understand the

1081
00:43:17,029 --> 00:43:20,750
protocol so the way anything about this

1082
00:43:20,750 --> 00:43:22,190
is like if I have a transaction that

1083
00:43:22,190 --> 00:43:24,740
updates a thousand tuples I potentially

1084
00:43:24,740 --> 00:43:27,370
have to create a thousand blog records

1085
00:43:27,370 --> 00:43:29,380
so let's say that thousand tubers are

1086
00:43:29,380 --> 00:43:32,260
stored in a thousand pages my log

1087
00:43:32,260 --> 00:43:33,730
records could just be stored in a single

1088
00:43:33,730 --> 00:43:36,880
page and therefore I'll need to want to

1089
00:43:36,880 --> 00:43:39,700
do write one one page out to flush the

1090
00:43:39,700 --> 00:43:41,710
log rather than all the pages that they

1091
00:43:41,710 --> 00:43:43,480
were modified so there's me a bunch of

1092
00:43:43,480 --> 00:43:44,530
performance advantages we're going to

1093
00:43:44,530 --> 00:43:48,340
get from this approach so the database

1094
00:43:48,340 --> 00:43:50,110
is going to stage all the changes that a

1095
00:43:50,110 --> 00:43:51,880
transaction makes in these log records

1096
00:43:51,880 --> 00:43:53,710
in volatile storage this is typically

1097
00:43:53,710 --> 00:43:56,830
bet also backed by the buffer pool and

1098
00:43:56,830 --> 00:43:59,380
then again this is we already talked

1099
00:43:59,380 --> 00:44:00,610
about everything gets flushed out and

1100
00:44:00,610 --> 00:44:02,260
they were not considered committed until

1101
00:44:02,260 --> 00:44:04,000
we know that all our log records have

1102
00:44:04,000 --> 00:44:07,480
been written out to disk as well so the

1103
00:44:07,480 --> 00:44:08,800
protocols don't work this way so when

1104
00:44:08,800 --> 00:44:11,170
our transaction starts we have to write

1105
00:44:11,170 --> 00:44:13,300
a begin record into our log that's gonna

1106
00:44:13,300 --> 00:44:14,380
tell us that hey there's this

1107
00:44:14,380 --> 00:44:16,270
transaction that started it exists

1108
00:44:16,270 --> 00:44:18,010
here's some metadata about it like

1109
00:44:18,010 --> 00:44:20,620
here's the identifier for an image

1110
00:44:20,620 --> 00:44:22,900
transaction commits we're gonna write a

1111
00:44:22,900 --> 00:44:25,870
commit record out to the log and when

1112
00:44:25,870 --> 00:44:27,430
you make sure that this commit record

1113
00:44:27,430 --> 00:44:30,850
appears in the log after any log record

1114
00:44:30,850 --> 00:44:32,500
that corresponds to changes of a bet

1115
00:44:32,500 --> 00:44:34,720
transaction made it's gonna be

1116
00:44:34,720 --> 00:44:36,100
interleaved potentially with other

1117
00:44:36,100 --> 00:44:37,420
changes that other transactions are

1118
00:44:37,420 --> 00:44:39,850
making but for our one transaction that

1119
00:44:39,850 --> 00:44:41,770
we care about at this point in time our

1120
00:44:41,770 --> 00:44:44,080
commit record needs to appear after all

1121
00:44:44,080 --> 00:44:46,750
its changes I think they because once we

1122
00:44:46,750 --> 00:44:48,310
see scenes come into law we know there's

1123
00:44:48,310 --> 00:44:49,450
no other change the transaction could

1124
00:44:49,450 --> 00:44:54,240
ever make so now in each log record

1125
00:44:54,240 --> 00:44:57,070
first in the very you know it's an

1126
00:44:57,070 --> 00:44:58,360
initial simplistic version of the

1127
00:44:58,360 --> 00:45:00,970
protocol I'm teaching right now we need

1128
00:45:00,970 --> 00:45:03,850
to need to record four things the unique

1129
00:45:03,850 --> 00:45:06,130
transaction identifier right like the

1130
00:45:06,130 --> 00:45:07,780
timestamp the transaction the sign when

1131
00:45:07,780 --> 00:45:10,360
it was started the object ID of the

1132
00:45:10,360 --> 00:45:12,280
thing that actually modified and then

1133
00:45:12,280 --> 00:45:14,080
the before value with the corresponds to

1134
00:45:14,080 --> 00:45:15,880
the undo and then the after value that

1135
00:45:15,880 --> 00:45:17,950
corresponds to the redo so this

1136
00:45:17,950 --> 00:45:19,660
information by itself it's enough for us

1137
00:45:19,660 --> 00:45:21,190
to be able that we need to in order to

1138
00:45:21,190 --> 00:45:22,870
recover the database and for all

1139
00:45:22,870 --> 00:45:24,580
possible errors that we talked about at

1140
00:45:24,580 --> 00:45:27,910
the very beginning so let's look at an

1141
00:45:27,910 --> 00:45:28,390
example here

1142
00:45:28,390 --> 00:45:30,610
so we just have t1 there's a write on a

1143
00:45:30,610 --> 00:45:33,730
write on beam and so now in memory we

1144
00:45:33,730 --> 00:45:35,740
have our right ahead log buffer as well

1145
00:45:35,740 --> 00:45:39,690
as our buffer pool so when we do the

1146
00:45:39,690 --> 00:45:41,140
transaction stars

1147
00:45:41,140 --> 00:45:43,180
begin we're going to add an entry into

1148
00:45:43,180 --> 00:45:45,580
our log record that says hey there's a

1149
00:45:45,580 --> 00:45:48,400
transaction that just started it's

1150
00:45:48,400 --> 00:45:50,200
usually not done exactly when you call

1151
00:45:50,200 --> 00:45:53,440
begin it's usually done unless you're

1152
00:45:53,440 --> 00:45:54,940
running with auto commit turned on it's

1153
00:45:54,940 --> 00:45:57,310
usually done at the first right but

1154
00:45:57,310 --> 00:45:58,360
different systems can do different

1155
00:45:58,360 --> 00:46:01,810
things so now I do write our name so the

1156
00:46:01,810 --> 00:46:02,980
first thing I need to do is add our

1157
00:46:02,980 --> 00:46:05,470
entry to my log buffer that says here's

1158
00:46:05,470 --> 00:46:07,000
that here's the change I'm making to a

1159
00:46:07,000 --> 00:46:09,400
right here's the Bears than before value

1160
00:46:09,400 --> 00:46:11,440
and here's the after value and once

1161
00:46:11,440 --> 00:46:13,930
that's in my log buffer now I go ahead

1162
00:46:13,930 --> 00:46:15,850
and make my change into my page in my

1163
00:46:15,850 --> 00:46:20,080
buffer pool all right we'll talk about

1164
00:46:20,080 --> 00:46:21,370
this more that next class the reason why

1165
00:46:21,370 --> 00:46:24,040
you have to do this before this because

1166
00:46:24,040 --> 00:46:25,270
there's gonna be this thing called a log

1167
00:46:25,270 --> 00:46:26,890
sequence number that's gonna get

1168
00:46:26,890 --> 00:46:28,690
assigned to the log record that we had

1169
00:46:28,690 --> 00:46:30,820
to use to figure out what was the what's

1170
00:46:30,820 --> 00:46:32,320
the log entry that course but that

1171
00:46:32,320 --> 00:46:35,080
changed this particular page so you may

1172
00:46:35,080 --> 00:46:36,820
think who cares into the muttering out

1173
00:46:36,820 --> 00:46:37,870
the disk can I just update this this

1174
00:46:37,870 --> 00:46:41,650
first then add this thing in here we'll

1175
00:46:41,650 --> 00:46:43,570
see next next next class why you have to

1176
00:46:43,570 --> 00:46:47,860
do this first followed by this so then

1177
00:46:47,860 --> 00:46:49,810
now I do the right on B same thing I add

1178
00:46:49,810 --> 00:46:51,880
my entry to my right hand a redhead log

1179
00:46:51,880 --> 00:46:54,190
buffer in memory then I go ahead and

1180
00:46:54,190 --> 00:46:56,620
make my change here so now when I go

1181
00:46:56,620 --> 00:46:57,760
ahead and do a commit

1182
00:46:57,760 --> 00:47:00,730
I add my commit record to my redhead log

1183
00:47:00,730 --> 00:47:03,490
buffer then at some point I'm gonna

1184
00:47:03,490 --> 00:47:05,320
flush it out the disk in this case here

1185
00:47:05,320 --> 00:47:06,730
since we need to tell the outside world

1186
00:47:06,730 --> 00:47:08,350
that a transaction is committed will

1187
00:47:08,350 --> 00:47:10,090
immediately flush this out do an F sync

1188
00:47:10,090 --> 00:47:12,370
and once we know that's durable and say

1189
00:47:12,370 --> 00:47:14,410
from disk at this point the transaction

1190
00:47:14,410 --> 00:47:16,150
is considered safe to now return back

1191
00:47:16,150 --> 00:47:17,950
the application and say that it's

1192
00:47:17,950 --> 00:47:21,250
committed so now who cares that Hitler

1193
00:47:21,250 --> 00:47:22,870
comes along and kills shows our buffer

1194
00:47:22,870 --> 00:47:25,930
pool because everything we need to do to

1195
00:47:25,930 --> 00:47:28,000
replay the changes that it made is now

1196
00:47:28,000 --> 00:47:31,690
safe on disk so if this page number got

1197
00:47:31,690 --> 00:47:33,430
written out we can just look in that log

1198
00:47:33,430 --> 00:47:37,210
and replay it to update the page as

1199
00:47:37,210 --> 00:47:39,490
needed to do exactly the same thing the

1200
00:47:39,490 --> 00:47:40,780
transaction did when it ran the first

1201
00:47:40,780 --> 00:47:46,180
time so again at a high level is this

1202
00:47:46,180 --> 00:47:48,350
clear

1203
00:47:48,350 --> 00:47:57,320
yes our question is what is instead of

1204
00:47:57,320 --> 00:47:59,420
storing the redhead log buffer as a

1205
00:47:59,420 --> 00:48:01,970
separate file what if I stored it in the

1206
00:48:01,970 --> 00:48:02,810
page itself

1207
00:48:02,810 --> 00:48:13,460
I said you told me like a log structure

1208
00:48:13,460 --> 00:48:15,260
storage we talked about earlier yeah so

1209
00:48:15,260 --> 00:48:18,130
in the log structure storage you don't

1210
00:48:18,130 --> 00:48:21,050
you don't have this on disk you only

1211
00:48:21,050 --> 00:48:27,950
have this yeah it's a Volks record yet

1212
00:48:27,950 --> 00:48:32,810
correct and the the what your what

1213
00:48:32,810 --> 00:48:35,330
you're giving up by hat not having this

1214
00:48:35,330 --> 00:48:37,670
is that reads are now more expensive

1215
00:48:37,670 --> 00:48:39,350
because you have to replay the log to

1216
00:48:39,350 --> 00:48:40,760
figure out what the page I should look

1217
00:48:40,760 --> 00:48:44,210
like when every read but it makes some

1218
00:48:44,210 --> 00:48:45,920
write super fast cuz now you don't do

1219
00:48:45,920 --> 00:48:47,420
extra writes to write out dirty pages

1220
00:48:47,420 --> 00:48:49,370
you only keep appending things to the

1221
00:48:49,370 --> 00:48:52,130
log so there's a trade-off so this will

1222
00:48:52,130 --> 00:48:55,370
be like rocks DB leveldb Cassandra bunch

1223
00:48:55,370 --> 00:48:57,560
of systems do these log structured merge

1224
00:48:57,560 --> 00:49:01,310
trees log structures storage yeah for us

1225
00:49:01,310 --> 00:49:02,990
we're time I here assume you have table

1226
00:49:02,990 --> 00:49:04,670
heaps we write everything we talked

1227
00:49:04,670 --> 00:49:05,540
about we have table heaps we have

1228
00:49:05,540 --> 00:49:07,070
override a head log we're not doing the

1229
00:49:07,070 --> 00:49:07,940
log structure stuff we talked about

1230
00:49:07,940 --> 00:49:10,190
before but the concept is still the same

1231
00:49:10,190 --> 00:49:12,320
you just you just don't have this you

1232
00:49:12,320 --> 00:49:14,220
don't have a table

1233
00:49:14,220 --> 00:49:17,690
[Music]

1234
00:49:23,670 --> 00:49:25,840
so his question is if I have to

1235
00:49:25,840 --> 00:49:29,050
transactions and they're updating the

1236
00:49:29,050 --> 00:49:31,210
database are there log records and are

1237
00:49:31,210 --> 00:49:32,590
mixed in the same log buffer or they

1238
00:49:32,590 --> 00:49:33,880
have separate log buffers they're

1239
00:49:33,880 --> 00:49:37,330
intermixed again this is this is this is

1240
00:49:37,330 --> 00:49:39,310
independent orthogonal to the commercial

1241
00:49:39,310 --> 00:49:41,380
stuff so some higher-level part of the

1242
00:49:41,380 --> 00:49:43,150
system that says set determines whether

1243
00:49:43,150 --> 00:49:44,470
one transactions allowed to update you

1244
00:49:44,470 --> 00:49:46,030
know what we know this object of that

1245
00:49:46,030 --> 00:49:49,150
object at this point we assume that

1246
00:49:49,150 --> 00:49:51,190
they're allowed to do that and they did

1247
00:49:51,190 --> 00:49:52,510
do that they're going to do it and

1248
00:49:52,510 --> 00:49:54,070
therefore we just we just add their law

1249
00:49:54,070 --> 00:49:56,890
records into the log file we don't eat

1250
00:49:56,890 --> 00:49:58,270
we don't maintain several log files for

1251
00:49:58,270 --> 00:50:02,230
different transactions because we have a

1252
00:50:02,230 --> 00:50:03,520
transaction B we know who did what

1253
00:50:03,520 --> 00:50:08,880
yes okay

1254
00:50:08,880 --> 00:50:11,950
so again if we crash there's everything

1255
00:50:11,950 --> 00:50:13,990
we need to restore the database is in

1256
00:50:13,990 --> 00:50:18,310
the log so to sort of implementation

1257
00:50:18,310 --> 00:50:21,310
questions one is when should the

1258
00:50:21,310 --> 00:50:22,300
database assumed write out the log

1259
00:50:22,300 --> 00:50:23,200
entries to disk

1260
00:50:23,200 --> 00:50:25,480
well the talks as we said it's whenever

1261
00:50:25,480 --> 00:50:27,370
the transaction commits before we tell

1262
00:50:27,370 --> 00:50:28,840
the outside world our transactions going

1263
00:50:28,840 --> 00:50:30,520
to go ahead you know is fully committed

1264
00:50:30,520 --> 00:50:32,740
we do make sure that those log records

1265
00:50:32,740 --> 00:50:34,810
and the buffer are now stored out at on

1266
00:50:34,810 --> 00:50:36,880
disk that's all we need to be able to

1267
00:50:36,880 --> 00:50:40,420
restore the database but my example here

1268
00:50:40,420 --> 00:50:43,690
I only showed one transaction and when

1269
00:50:43,690 --> 00:50:45,280
they said commit you know I just mean

1270
00:50:45,280 --> 00:50:47,800
did s sync and write it out but that's

1271
00:50:47,800 --> 00:50:50,170
actually gonna be super slow if I for

1272
00:50:50,170 --> 00:50:51,700
every single transaction I do an F sync

1273
00:50:51,700 --> 00:50:53,440
when they commit to write out it's a log

1274
00:50:53,440 --> 00:50:55,960
buffer that's not what I'm gonna want to

1275
00:50:55,960 --> 00:50:57,520
do because saying F sync takes five

1276
00:50:57,520 --> 00:51:00,580
milliseconds on a slower disk then I can

1277
00:51:00,580 --> 00:51:02,020
only commit one transaction every five

1278
00:51:02,020 --> 00:51:05,470
milliseconds and that bet that's gonna

1279
00:51:05,470 --> 00:51:07,240
be that's gonna be bad I can only do two

1280
00:51:07,240 --> 00:51:09,910
thousand transactions a second so what

1281
00:51:09,910 --> 00:51:12,340
every system actually implements instead

1282
00:51:12,340 --> 00:51:14,680
is what's called group commit where

1283
00:51:14,680 --> 00:51:16,420
you're gonna allow multiple actions to

1284
00:51:16,420 --> 00:51:18,310
buffer up a bunch of changes in the log

1285
00:51:18,310 --> 00:51:20,500
buffer and then at some point you make a

1286
00:51:20,500 --> 00:51:21,730
decision all right now I'm gonna go

1287
00:51:21,730 --> 00:51:22,660
ahead and write whatever's in the log

1288
00:51:22,660 --> 00:51:24,880
buffer out the disk and then may include

1289
00:51:24,880 --> 00:51:26,560
log records from transactions that have

1290
00:51:26,560 --> 00:51:27,099
not commit

1291
00:51:27,099 --> 00:51:29,950
yeah but that's fine because we know how

1292
00:51:29,950 --> 00:51:31,809
to undo their the undo their changes

1293
00:51:31,809 --> 00:51:33,249
because we have the undo information in

1294
00:51:33,249 --> 00:51:36,190
there in the log record so this is what

1295
00:51:36,190 --> 00:51:36,759
you're going to end up happening

1296
00:51:36,759 --> 00:51:39,970
implement in in project 4 so the way it

1297
00:51:39,970 --> 00:51:41,979
basically works is that in the simple

1298
00:51:41,979 --> 00:51:43,269
form you instead of having one log

1299
00:51:43,269 --> 00:51:45,579
buffer you have to log buffers it's sort

1300
00:51:45,579 --> 00:51:47,589
of like shadow paging there's the master

1301
00:51:47,589 --> 00:51:49,059
there's the master when everyone's

1302
00:51:49,059 --> 00:51:50,049
writing to and there's the background

1303
00:51:50,049 --> 00:51:52,979
one that you're eventually write to next

1304
00:51:52,979 --> 00:51:55,599
so when my transaction starts t1 here

1305
00:51:55,599 --> 00:51:58,479
doesn't write on a or you always go to

1306
00:51:58,479 --> 00:52:00,630
you go to the first one first add the

1307
00:52:00,630 --> 00:52:03,519
begin then do the write on a to write on

1308
00:52:03,519 --> 00:52:06,700
B now I do a contact switch here all

1309
00:52:06,700 --> 00:52:06,999
right

1310
00:52:06,999 --> 00:52:11,200
at t2 sentry-go right on C but now at

1311
00:52:11,200 --> 00:52:14,650
this point my log buffer is full so I

1312
00:52:14,650 --> 00:52:16,450
can't add anything and anything else in

1313
00:52:16,450 --> 00:52:20,079
here so I'm gonna go ahead and write

1314
00:52:20,079 --> 00:52:23,229
this out the disk all right and I have

1315
00:52:23,229 --> 00:52:24,579
to do F sync so that you know that's

1316
00:52:24,579 --> 00:52:26,380
gonna take some time so in the meantime

1317
00:52:26,380 --> 00:52:28,809
now I switch over to my second log

1318
00:52:28,809 --> 00:52:31,089
buffer and now any other changes that

1319
00:52:31,089 --> 00:52:32,769
transactions may get added to this thing

1320
00:52:32,769 --> 00:52:35,920
here the idea is start your wild ones

1321
00:52:35,920 --> 00:52:37,089
getting read out in a disk you fill up

1322
00:52:37,089 --> 00:52:39,359
the next one when that gets filled then

1323
00:52:39,359 --> 00:52:41,440
ideally the other ones been flushed out

1324
00:52:41,440 --> 00:52:42,969
so now then you write the write the

1325
00:52:42,969 --> 00:52:44,200
second one out and then fill up the

1326
00:52:44,200 --> 00:52:47,130
first one so just going back and forth

1327
00:52:47,130 --> 00:52:49,180
while ones getting flushed you fill up

1328
00:52:49,180 --> 00:52:52,089
the other one but let's say for this

1329
00:52:52,089 --> 00:52:55,960
transaction here it stalls right it does

1330
00:52:55,960 --> 00:52:57,849
something right it does additional

1331
00:52:57,849 --> 00:52:59,890
computation so neither transaction are

1332
00:52:59,890 --> 00:53:03,940
generating new log records so instead of

1333
00:53:03,940 --> 00:53:05,499
just waiting till it's filled up before

1334
00:53:05,499 --> 00:53:07,690
I write it out there's also a second

1335
00:53:07,690 --> 00:53:10,509
prop process where you you say well if

1336
00:53:10,509 --> 00:53:12,640
it's been a certain amount of time since

1337
00:53:12,640 --> 00:53:14,589
any since I've last flushed this thing

1338
00:53:14,589 --> 00:53:18,369
out let me go ahead and flush it out and

1339
00:53:18,369 --> 00:53:19,660
the idea is you should want to tune it

1340
00:53:19,660 --> 00:53:21,400
such a way that like if you know that

1341
00:53:21,400 --> 00:53:22,930
what the f sync time is write something

1342
00:53:22,930 --> 00:53:24,880
up the disk then you sort of set your

1343
00:53:24,880 --> 00:53:27,729
timeout to be to be that so like if if

1344
00:53:27,729 --> 00:53:29,079
it takes me five milliseconds to write

1345
00:53:29,079 --> 00:53:30,999
write the first page out or the first

1346
00:53:30,999 --> 00:53:32,710
blog buffer then I'll wait five

1347
00:53:32,710 --> 00:53:35,109
milliseconds for the second one and when

1348
00:53:35,109 --> 00:53:36,759
what five milliseconds is up if I'm not

1349
00:53:36,759 --> 00:53:38,289
full yet I go ahead and write that out

1350
00:53:38,289 --> 00:53:40,680
as well

1351
00:53:42,089 --> 00:53:44,260
so again group commit basically says

1352
00:53:44,260 --> 00:53:47,019
instead of one transaction F sinking the

1353
00:53:47,019 --> 00:53:49,359
log when it commits you back to bunch of

1354
00:53:49,359 --> 00:53:50,829
them together and then you amortize the

1355
00:53:50,829 --> 00:53:51,849
essent costs across multiple

1356
00:53:51,849 --> 00:53:53,650
transactions so if you're the first

1357
00:53:53,650 --> 00:53:55,329
transaction that gets added to the to

1358
00:53:55,329 --> 00:53:57,250
the log buffer and then you commit

1359
00:53:57,250 --> 00:53:59,260
you're kind of like you're screwed

1360
00:53:59,260 --> 00:54:00,369
because you have to wait the longest

1361
00:54:00,369 --> 00:54:01,510
before you're actually written out the

1362
00:54:01,510 --> 00:54:03,970
disk but if you're the last guy then

1363
00:54:03,970 --> 00:54:05,680
it's as if you get that you're getting

1364
00:54:05,680 --> 00:54:07,000
the disk exactly to yourself because

1365
00:54:07,000 --> 00:54:08,890
you're not waiting any time so on

1366
00:54:08,890 --> 00:54:10,660
average this works out to be much better

1367
00:54:10,660 --> 00:54:14,279
than everyone else inking immediately

1368
00:54:15,359 --> 00:54:19,089
all right so then the the last question

1369
00:54:19,089 --> 00:54:20,410
is when she'll be actually write the

1370
00:54:20,410 --> 00:54:21,460
dirty records out to disk

1371
00:54:21,460 --> 00:54:28,450
well this depends now so now that we

1372
00:54:28,450 --> 00:54:30,099
said that the law buffers everything we

1373
00:54:30,099 --> 00:54:31,539
need to do everything all the operations

1374
00:54:31,539 --> 00:54:34,480
we need to be able to redo the changes

1375
00:54:34,480 --> 00:54:37,329
that transaction is made and we say that

1376
00:54:37,329 --> 00:54:38,740
the log records that correspond to

1377
00:54:38,740 --> 00:54:40,869
changes to pages are written out to disk

1378
00:54:40,869 --> 00:54:42,450
before this page is written out to disk

1379
00:54:42,450 --> 00:54:45,190
it's not actually immediately urgent for

1380
00:54:45,190 --> 00:54:47,680
us to flush all those pages immediately

1381
00:54:47,680 --> 00:54:48,910
when the transaction commits because the

1382
00:54:48,910 --> 00:54:51,460
law workers have been flushed so now on

1383
00:54:51,460 --> 00:54:52,660
our replacement policy in our buffer

1384
00:54:52,660 --> 00:54:54,099
pool manager we can account for this we

1385
00:54:54,099 --> 00:54:56,289
can say all right well this thing is

1386
00:54:56,289 --> 00:54:59,319
dirty but I the law workers been written

1387
00:54:59,319 --> 00:55:01,150
out for it so maybe I don't want to Vic

1388
00:55:01,150 --> 00:55:03,910
this one right away Brian can evict it

1389
00:55:03,910 --> 00:55:05,230
right away where this other one here

1390
00:55:05,230 --> 00:55:06,759
although it's probably as a higher

1391
00:55:06,759 --> 00:55:08,259
priority for me getting removed or

1392
00:55:08,259 --> 00:55:10,390
getting evicted its log records haven't

1393
00:55:10,390 --> 00:55:12,579
haven't been flushed yet so maybe I

1394
00:55:12,579 --> 00:55:13,900
don't want to dick that one because I

1395
00:55:13,900 --> 00:55:15,730
have flush the buffer first before I can

1396
00:55:15,730 --> 00:55:20,920
write that out so this this idea of log

1397
00:55:20,920 --> 00:55:22,660
and recovery permeates throughout the

1398
00:55:22,660 --> 00:55:23,799
entire system and now we need to account

1399
00:55:23,799 --> 00:55:24,970
for the other parts of the system but

1400
00:55:24,970 --> 00:55:26,380
we've already talked about we can update

1401
00:55:26,380 --> 00:55:28,329
replacement policy to keep track of

1402
00:55:28,329 --> 00:55:43,660
these things yes all right so so this

1403
00:55:43,660 --> 00:55:45,759
question is well in these example we

1404
00:55:45,759 --> 00:55:48,369
don't recommit so let's say that I have

1405
00:55:48,369 --> 00:55:51,009
a commitment log buffer but before I

1406
00:55:51,009 --> 00:55:53,710
read up at this high crash who cares

1407
00:55:53,710 --> 00:56:00,309
ah no no the application said commit we

1408
00:56:00,309 --> 00:56:02,140
haven't told me you committed yet we

1409
00:56:02,140 --> 00:56:04,299
only tell them that they commit when

1410
00:56:04,299 --> 00:56:05,920
that log buffer that corresponds that

1411
00:56:05,920 --> 00:56:07,900
commit message is written to disk that's

1412
00:56:07,900 --> 00:56:11,230
the genius of this right because again

1413
00:56:11,230 --> 00:56:13,630
the the if we're doing OCC where we're

1414
00:56:13,630 --> 00:56:14,920
doing validation after after the

1415
00:56:14,920 --> 00:56:17,259
transaction commits we still might end

1416
00:56:17,259 --> 00:56:20,230
up getting aborted right at this point

1417
00:56:20,230 --> 00:56:21,940
here at the law buffer we assumed all

1418
00:56:21,940 --> 00:56:23,740
that's taken care of so we see a commit

1419
00:56:23,740 --> 00:56:26,109
message here we don't tell you know

1420
00:56:26,109 --> 00:56:27,369
there's no callback to say yeah you're

1421
00:56:27,369 --> 00:56:29,289
good everything's durable until the law

1422
00:56:29,289 --> 00:56:35,380
buffers we've written a disk his

1423
00:56:35,380 --> 00:56:37,240
question is is the application hanging

1424
00:56:37,240 --> 00:56:42,789
for a while yes correct but I mean like

1425
00:56:42,789 --> 00:56:46,089
what else would you do otherwise if you

1426
00:56:46,089 --> 00:56:47,259
don't want to wait to see what you

1427
00:56:47,259 --> 00:56:48,789
committed that's fine but you could lose

1428
00:56:48,789 --> 00:56:51,339
data right so if I don't run it a

1429
00:56:51,339 --> 00:56:57,730
transaction then then you know actually

1430
00:56:57,730 --> 00:56:59,259
even even if you do auto commit here's a

1431
00:56:59,259 --> 00:57:01,960
single state by transaction I think it's

1432
00:57:01,960 --> 00:57:03,609
still gonna write a write a log record

1433
00:57:03,609 --> 00:57:04,539
before it comes back and says your

1434
00:57:04,539 --> 00:57:09,730
things actually finished I don't some

1435
00:57:09,730 --> 00:57:11,109
systems lottery turn allow you to turn

1436
00:57:11,109 --> 00:57:12,640
off logging on a per transaction basis

1437
00:57:12,640 --> 00:57:15,670
so I can run a transaction that would

1438
00:57:15,670 --> 00:57:20,079
say I make a bunch of changes but when I

1439
00:57:20,079 --> 00:57:22,470
commit don't write anything out the log

1440
00:57:22,470 --> 00:57:25,029
you could do that some systems will

1441
00:57:25,029 --> 00:57:28,500
apply to do that by default they don't

1442
00:57:28,500 --> 00:57:31,500
yes

1443
00:57:32,280 --> 00:57:34,240
do we need to commit entries about

1444
00:57:34,240 --> 00:57:37,119
renewed transaction or we don't his

1445
00:57:37,119 --> 00:57:39,099
question is do we need to commit entries

1446
00:57:39,099 --> 00:57:40,869
for a retailing transaction what do you

1447
00:57:40,869 --> 00:57:44,880
think well what would you have to commit

1448
00:57:45,210 --> 00:57:48,839
what what would the log record beat

1449
00:57:48,839 --> 00:57:50,680
there's nothing there's nothing to log

1450
00:57:50,680 --> 00:57:52,270
this is what I'm saying like going back

1451
00:57:52,270 --> 00:57:58,869
here uh oh sorry guy Taemin hmm oh

1452
00:57:58,869 --> 00:58:06,040
that wasn't me that was PowerPoint sorry

1453
00:58:06,040 --> 00:58:15,010
so I showed the the right and this in

1454
00:58:15,010 --> 00:58:16,599
this case here I showed that when the

1455
00:58:16,599 --> 00:58:18,750
transaction started I had to begin entry

1456
00:58:18,750 --> 00:58:21,369
you don't have to do that right because

1457
00:58:21,369 --> 00:58:22,990
if it's if it's a read-only transaction

1458
00:58:22,990 --> 00:58:25,869
like if this thing called begin but then

1459
00:58:25,869 --> 00:58:28,210
did a bunch of reads then I'm storing

1460
00:58:28,210 --> 00:58:30,490
crap that I don't care about you could

1461
00:58:30,490 --> 00:58:32,859
do that you don't have to though right

1462
00:58:32,859 --> 00:58:35,080
in some systems you can actually declare

1463
00:58:35,080 --> 00:58:36,460
a turns actually read-only at the

1464
00:58:36,460 --> 00:58:38,380
beginning that you say begin as

1465
00:58:38,380 --> 00:58:40,720
read-only or something in sequel then

1466
00:58:40,720 --> 00:58:42,490
you just turn off all logging and all

1467
00:58:42,490 --> 00:58:43,750
control if you're doing snaps to

1468
00:58:43,750 --> 00:58:45,400
isolation because you just know that I'm

1469
00:58:45,400 --> 00:58:48,780
gonna see exactly what I should be seen

1470
00:58:49,320 --> 00:58:51,430
for simplicity's I'm showing that here

1471
00:58:51,430 --> 00:58:57,010
yes I so question is when you garbage

1472
00:58:57,010 --> 00:58:59,980
like the logs a few more slides will get

1473
00:58:59,980 --> 00:59:05,020
there yes actually is spoilers

1474
00:59:05,020 --> 00:59:06,760
checkpointing but we'll get to that

1475
00:59:06,760 --> 00:59:11,080
okay so just to recap everything we

1476
00:59:11,080 --> 00:59:12,940
talked about the way it is heard a thing

1477
00:59:12,940 --> 00:59:14,920
about the different methods for doing

1478
00:59:14,920 --> 00:59:18,130
bustable management and recovery is in

1479
00:59:18,130 --> 00:59:19,480
the context of the runtime performance

1480
00:59:19,480 --> 00:59:22,330
and the recovery performance so the

1481
00:59:22,330 --> 00:59:23,890
wrong time promise would be how fast is

1482
00:59:23,890 --> 00:59:25,630
it for you know to maintain all this

1483
00:59:25,630 --> 00:59:28,750
information while I run transactions so

1484
00:59:28,750 --> 00:59:30,730
in the case of no for steel which is

1485
00:59:30,730 --> 00:59:32,470
right ahead logging that's gonna be the

1486
00:59:32,470 --> 00:59:35,020
fastest during run time because when I

1487
00:59:35,020 --> 00:59:36,550
commit I'm just committing out those log

1488
00:59:36,550 --> 00:59:37,839
records I don't worry about those dirty

1489
00:59:37,839 --> 00:59:39,670
pages hanging my buffer pool I'll take

1490
00:59:39,670 --> 00:59:42,010
care of them at some later point whereas

1491
00:59:42,010 --> 00:59:43,359
with shadow paging it's more expensive

1492
00:59:43,359 --> 00:59:45,369
because I have to make sure I flush all

1493
00:59:45,369 --> 00:59:45,910
the page

1494
00:59:45,910 --> 00:59:47,890
that I modified and my shadow page table

1495
00:59:47,890 --> 00:59:51,039
then flush the database route to disk

1496
00:59:51,039 --> 00:59:52,329
before I can tell the outside world I

1497
00:59:52,329 --> 00:59:55,299
commit him but now the downside is if I

1498
00:59:55,299 --> 00:59:56,500
have to recover the database after a

1499
00:59:56,500 --> 00:59:58,780
crash shadow paging is the fastest

1500
00:59:58,780 --> 01:00:00,460
because I don't do anything extra I just

1501
01:00:00,460 --> 01:00:02,380
come back and my Davis root points to my

1502
01:00:02,380 --> 01:00:04,450
shadow page or the consistent

1503
01:00:04,450 --> 01:00:06,430
master the most recently committed

1504
01:00:06,430 --> 01:00:09,220
version and I'm done but under write

1505
01:00:09,220 --> 01:00:11,410
ahead logging that's actually slower

1506
01:00:11,410 --> 01:00:13,900
because I'm not the replay the logged up

1507
01:00:13,900 --> 01:00:16,869
to some some point which she was sort of

1508
01:00:16,869 --> 01:00:19,410
alluding to with garbage collection so

1509
01:00:19,410 --> 01:00:21,069
because of this trade-off between

1510
01:00:21,069 --> 01:00:24,339
performance and recovery time most

1511
01:00:24,339 --> 01:00:26,710
database system implementations choose

1512
01:00:26,710 --> 01:00:28,450
the the right head logging choose the no

1513
01:00:28,450 --> 01:00:30,309
for steal because they'd rather be

1514
01:00:30,309 --> 01:00:33,400
faster at runtime and assume failure

1515
01:00:33,400 --> 01:00:35,140
failures are gonna be rare which which

1516
01:00:35,140 --> 01:00:36,490
you know in the grand scheme of things

1517
01:00:36,490 --> 01:00:38,859
they are your data systems not crashing

1518
01:00:38,859 --> 01:00:40,839
every minute if you do we have other

1519
01:00:40,839 --> 01:00:42,849
problems so therefore they're willing to

1520
01:00:42,849 --> 01:00:44,470
trade off faster runtime performance in

1521
01:00:44,470 --> 01:00:48,400
exchange for slower recovery there's

1522
01:00:48,400 --> 01:00:52,029
only one system that I'm aware of except

1523
01:00:52,029 --> 01:00:55,029
for the ones that do shadow paging like

1524
01:00:55,029 --> 01:00:56,619
the old sequel light there's only one

1525
01:00:56,619 --> 01:00:57,880
system that I can make the trade-off for

1526
01:00:57,880 --> 01:01:01,809
having faster recovery time in exchange

1527
01:01:01,809 --> 01:01:04,690
for running slower at runtime and it was

1528
01:01:04,690 --> 01:01:05,920
this system I don't know the name of it

1529
01:01:05,920 --> 01:01:08,799
it was a database system built in the

1530
01:01:08,799 --> 01:01:10,750
1970s for the the Puerto Rican

1531
01:01:10,750 --> 01:01:12,819
electrical system because in Puerto Rico

1532
01:01:12,819 --> 01:01:14,589
in the 1970s they had power outages like

1533
01:01:14,589 --> 01:01:17,109
every hour so the DA's ism was crashing

1534
01:01:17,109 --> 01:01:19,240
literally every single hour so for them

1535
01:01:19,240 --> 01:01:21,329
it was much better to be slow at runtime

1536
01:01:21,329 --> 01:01:23,349
such that for every hour when you

1537
01:01:23,349 --> 01:01:25,210
crashed when you lose power you could

1538
01:01:25,210 --> 01:01:28,710
recover the database Amelia Edwards

1539
01:01:28,770 --> 01:01:31,180
right another were there anything like

1540
01:01:31,180 --> 01:01:33,010
this at the high level to is this is

1541
01:01:33,010 --> 01:01:34,750
with no undo no redo because there's

1542
01:01:34,750 --> 01:01:36,069
nothing to reverse and nothing to

1543
01:01:36,069 --> 01:01:37,960
reapply with with right ahead logging

1544
01:01:37,960 --> 01:01:44,069
you need undo and redo all right so I

1545
01:01:44,069 --> 01:01:46,720
showed sort of at a high level what

1546
01:01:46,720 --> 01:01:48,339
these long records are that there's an

1547
01:01:48,339 --> 01:01:51,760
object ID and then there's a for value

1548
01:01:51,760 --> 01:01:54,880
in the after value but what how this is

1549
01:01:54,880 --> 01:01:56,589
actually implemented so there's a couple

1550
01:01:56,589 --> 01:01:58,610
different approaches

1551
01:01:58,610 --> 01:02:00,860
so one but the one would be what it's

1552
01:02:00,860 --> 01:02:01,910
called physical logging which is

1553
01:02:01,910 --> 01:02:02,990
basically what I've talked about so far

1554
01:02:02,990 --> 01:02:06,650
is we're recording the low level byte

1555
01:02:06,650 --> 01:02:08,750
changes to a specific location as some

1556
01:02:08,750 --> 01:02:11,150
object in the database that you made -

1557
01:02:11,150 --> 01:02:12,590
you know and you know how to reverse it

1558
01:02:12,590 --> 01:02:14,240
so thinking this is like if you run

1559
01:02:14,240 --> 01:02:15,850
there for or get diff

1560
01:02:15,850 --> 01:02:18,470
it'sit'sit's but allows you to get out

1561
01:02:18,470 --> 01:02:20,180
the before and after advantage of of the

1562
01:02:20,180 --> 01:02:23,120
change but the downside of this is again

1563
01:02:23,120 --> 01:02:25,010
if I have to make if I update of you

1564
01:02:25,010 --> 01:02:27,800
know billion tuples in my transaction I

1565
01:02:27,800 --> 01:02:30,350
have to have a billion log records that

1566
01:02:30,350 --> 01:02:31,640
corresponds to all those low-level

1567
01:02:31,640 --> 01:02:35,390
physical changes another approach is do

1568
01:02:35,390 --> 01:02:38,210
logical logging where you just record

1569
01:02:38,210 --> 01:02:40,010
the high-level operation that which of

1570
01:02:40,010 --> 01:02:42,040
the change you made to the database and

1571
01:02:42,040 --> 01:02:43,820
that's enough for you to be able to

1572
01:02:43,820 --> 01:02:47,000
reapply it at run time undo is a lot

1573
01:02:47,000 --> 01:02:49,760
more tricky based if you have you know

1574
01:02:49,760 --> 01:02:52,670
based on what the actual query is but

1575
01:02:52,670 --> 01:02:55,730
let's ignore that for now so I think the

1576
01:02:55,730 --> 01:02:57,440
way thing like this is this is storing

1577
01:02:57,440 --> 01:02:59,240
like in the diff of the change you made

1578
01:02:59,240 --> 01:03:01,070
this is storing actually the sequel

1579
01:03:01,070 --> 01:03:06,110
query that of the change you made so the

1580
01:03:06,110 --> 01:03:07,550
advantage or disadvantage of each of

1581
01:03:07,550 --> 01:03:08,900
them are that logical blogging allows

1582
01:03:08,900 --> 01:03:11,960
you to record more changes with less

1583
01:03:11,960 --> 01:03:14,330
data I update a billion to post with a

1584
01:03:14,330 --> 01:03:16,340
single update statement I only know of

1585
01:03:16,340 --> 01:03:19,880
that one update statement the downsides

1586
01:03:19,880 --> 01:03:22,250
gonna be with logical logging though is

1587
01:03:22,250 --> 01:03:25,070
that it's gonna be tricky for me to

1588
01:03:25,070 --> 01:03:27,230
figure out what changes I potentially

1589
01:03:27,230 --> 01:03:29,480
may made to the database that I've got

1590
01:03:29,480 --> 01:03:33,200
written to disk before the crash because

1591
01:03:33,200 --> 01:03:35,120
I don't have that low-level information

1592
01:03:35,120 --> 01:03:37,340
I update a billion to blows over a

1593
01:03:37,340 --> 01:03:39,830
billion pages maybe half of them got

1594
01:03:39,830 --> 01:03:42,350
written out the disk how do I know which

1595
01:03:42,350 --> 01:03:46,940
ones I need to update and reapply the

1596
01:03:46,940 --> 01:03:48,260
other issues gonna be you'll see that

1597
01:03:48,260 --> 01:03:50,240
however long it took me update the

1598
01:03:50,240 --> 01:03:51,800
database the first time when I ran the

1599
01:03:51,800 --> 01:03:53,960
query with a logical logging scheme this

1600
01:03:53,960 --> 01:03:55,160
is gonna take that same amount of time

1601
01:03:55,160 --> 01:03:57,560
the second time so my query took an hour

1602
01:03:57,560 --> 01:03:59,990
to run during recovery to take an hour

1603
01:03:59,990 --> 01:04:01,610
to run again there's no magic because

1604
01:04:01,610 --> 01:04:02,720
I'm in recovery mode that's gonna make

1605
01:04:02,720 --> 01:04:06,170
that go faster so although the skins

1606
01:04:06,170 --> 01:04:07,490
storing I'm storing less information of

1607
01:04:07,490 --> 01:04:08,690
logical logging it's going to make

1608
01:04:08,690 --> 01:04:10,730
recovery more expensive and most systems

1609
01:04:10,730 --> 01:04:12,940
do not make that change

1610
01:04:12,940 --> 01:04:15,110
the hybrid approach that most people use

1611
01:04:15,110 --> 01:04:18,560
is call it physiological logon where

1612
01:04:18,560 --> 01:04:20,240
you're not going to store the low level

1613
01:04:20,240 --> 01:04:22,010
byte information about the changes

1614
01:04:22,010 --> 01:04:24,020
you're making to the database you'll

1615
01:04:24,020 --> 01:04:26,600
still you're still sort like it's a low

1616
01:04:26,600 --> 01:04:28,220
level enough to say here at this page

1617
01:04:28,220 --> 01:04:30,500
I'm modifying this object but you're not

1618
01:04:30,500 --> 01:04:32,000
you're not really taking a diff as you

1619
01:04:32,000 --> 01:04:34,970
would under physical logging you're just

1620
01:04:34,970 --> 01:04:36,620
saying here's this logical thing I want

1621
01:04:36,620 --> 01:04:38,930
you to make up make a change to so this

1622
01:04:38,930 --> 01:04:40,900
is what most systems actually implement

1623
01:04:40,900 --> 01:04:42,950
so let's say we have this update query

1624
01:04:42,950 --> 01:04:44,900
here so in a physical log it would be

1625
01:04:44,900 --> 01:04:47,360
like at this page of this offset here's

1626
01:04:47,360 --> 01:04:49,370
the before and after image and we

1627
01:04:49,370 --> 01:04:50,720
haven't talked about indexes as well but

1628
01:04:50,720 --> 01:04:53,240
indexes you basic at the log in the at

1629
01:04:53,240 --> 01:04:54,440
the same time you're making changes to

1630
01:04:54,440 --> 01:04:57,140
the database because if my of my index

1631
01:04:57,140 --> 01:04:59,060
doesn't fit memory then I don't want to

1632
01:04:59,060 --> 01:05:00,470
have to rebuild it from scratch upon

1633
01:05:00,470 --> 01:05:02,570
recovery so most data systems also

1634
01:05:02,570 --> 01:05:04,820
record the log the changes you makes it

1635
01:05:04,820 --> 01:05:08,300
indexes logical login of query again you

1636
01:05:08,300 --> 01:05:10,340
just store the Seigle statement physical

1637
01:05:10,340 --> 01:05:13,100
logical logging is you're saying at this

1638
01:05:13,100 --> 01:05:16,370
page at this slot number here's the

1639
01:05:16,370 --> 01:05:17,600
change I want you to make these these

1640
01:05:17,600 --> 01:05:20,990
low-level attributes and this allows you

1641
01:05:20,990 --> 01:05:24,770
to not have to but having these in this

1642
01:05:24,770 --> 01:05:26,210
extra indirection sort of like the

1643
01:05:26,210 --> 01:05:27,080
slotted pages

1644
01:05:27,080 --> 01:05:29,780
it doesn't allows you to reorder that

1645
01:05:29,780 --> 01:05:32,450
the the replay operations in such a way

1646
01:05:32,450 --> 01:05:35,240
that the the data it doesn't mean a byte

1647
01:05:35,240 --> 01:05:37,730
for byte copy yet before and after the

1648
01:05:37,730 --> 01:05:39,620
crash you have some wiggle room to

1649
01:05:39,620 --> 01:05:42,050
actually reapply these in different ways

1650
01:05:42,050 --> 01:05:44,150
and restored still restore back to the

1651
01:05:44,150 --> 01:05:49,430
correct state all right so the getting

1652
01:05:49,430 --> 01:05:52,340
to her question is the issue of anything

1653
01:05:52,340 --> 01:05:54,170
we talked about so far so far is that

1654
01:05:54,170 --> 01:05:56,000
these right ahead logs are gonna grow

1655
01:05:56,000 --> 01:05:58,550
forever if my database system is running

1656
01:05:58,550 --> 01:06:00,350
for a year I'm gonna her years worth of

1657
01:06:00,350 --> 01:06:03,920
logs so now if I have to crash if I

1658
01:06:03,920 --> 01:06:05,690
crash and come back into replay this log

1659
01:06:05,690 --> 01:06:07,490
I potentially have to replay the entire

1660
01:06:07,490 --> 01:06:11,060
year's worth of data so logical logging

1661
01:06:11,060 --> 01:06:13,010
that would be terrible right because if

1662
01:06:13,010 --> 01:06:14,600
the query takes the same amount of time

1663
01:06:14,600 --> 01:06:16,250
it took the first time as it does during

1664
01:06:16,250 --> 01:06:18,200
recovery so I have a year's worth of

1665
01:06:18,200 --> 01:06:20,660
data of logical log records if I crash

1666
01:06:20,660 --> 01:06:22,520
and come back I pretend to take a year

1667
01:06:22,520 --> 01:06:25,500
for me to recover the database

1668
01:06:25,500 --> 01:06:29,500
so that's bad so the way we can truncate

1669
01:06:29,500 --> 01:06:32,650
and the the log is to what are called

1670
01:06:32,650 --> 01:06:35,619
checkpoints and the idea of a checkpoint

1671
01:06:35,619 --> 01:06:38,109
is that we're gonna flush out all the

1672
01:06:38,109 --> 01:06:40,119
pages that are dirty in our buffer pull

1673
01:06:40,119 --> 01:06:43,150
out the disk and add a entry to our log

1674
01:06:43,150 --> 01:06:45,940
record to say at this point there's no

1675
01:06:45,940 --> 01:06:47,500
dirty pages that are not durable in

1676
01:06:47,500 --> 01:06:49,480
disks so therefore you don't need to

1677
01:06:49,480 --> 01:06:52,780
replay that far in the past potentially

1678
01:06:52,780 --> 01:06:55,180
from from from from my checkpoint

1679
01:06:55,180 --> 01:06:57,339
because I know all those changes have

1680
01:06:57,339 --> 01:06:59,950
been persistent again the idea here

1681
01:06:59,950 --> 01:07:01,809
again because we're doing the steal

1682
01:07:01,809 --> 01:07:05,349
policy or the no force policy we're not

1683
01:07:05,349 --> 01:07:07,150
requiring that the dirty pages that

1684
01:07:07,150 --> 01:07:09,160
transaction made has to be flushed out

1685
01:07:09,160 --> 01:07:10,390
the disk before the transaction is

1686
01:07:10,390 --> 01:07:13,450
committed so we don't know whether they

1687
01:07:13,450 --> 01:07:15,309
actually made it to disk or not if we

1688
01:07:15,309 --> 01:07:17,619
crash whereas with the checkpoint when

1689
01:07:17,619 --> 01:07:19,540
we know the checkpoint completes we know

1690
01:07:19,540 --> 01:07:21,700
that at that point everything has been

1691
01:07:21,700 --> 01:07:26,410
written a disk so look at really simple

1692
01:07:26,410 --> 01:07:28,329
example here so for this one I'm going

1693
01:07:28,329 --> 01:07:29,859
to use a very simplistic checkpoint

1694
01:07:29,859 --> 01:07:32,410
scheme that basically stops the world

1695
01:07:32,410 --> 01:07:35,190
stops all transactions from running and

1696
01:07:35,190 --> 01:07:37,839
flushes out all their changes all the

1697
01:07:37,839 --> 01:07:40,089
dirty pages out to disk and then once I

1698
01:07:40,089 --> 01:07:41,260
know all the dirty pages are written

1699
01:07:41,260 --> 01:07:43,740
then I let them to start running again

1700
01:07:43,740 --> 01:07:46,150
this is called consistent consistent

1701
01:07:46,150 --> 01:07:48,150
checkpointing or blocking checkpoints

1702
01:07:48,150 --> 01:07:50,170
most systems don't actually implement it

1703
01:07:50,170 --> 01:07:51,819
this way we'll see on Wednesday how to

1704
01:07:51,819 --> 01:07:53,740
do it better and how things can run at

1705
01:07:53,740 --> 01:07:55,569
the same time but just understand it

1706
01:07:55,569 --> 01:07:58,089
edit you know the very basic how the

1707
01:07:58,089 --> 01:07:59,530
basic protocol works assume that's the

1708
01:07:59,530 --> 01:08:01,930
case so I'm gonna add this checkpoint

1709
01:08:01,930 --> 01:08:04,180
entry here so what will happen is when I

1710
01:08:04,180 --> 01:08:06,460
take this checkpoint I stop all

1711
01:08:06,460 --> 01:08:08,170
transaction from running and I flush out

1712
01:08:08,170 --> 01:08:11,349
any dirty pages and so now if I have a

1713
01:08:11,349 --> 01:08:14,920
crash when I come back I know that I

1714
01:08:14,920 --> 01:08:18,100
don't need to look at net1 t1 s changes

1715
01:08:18,100 --> 01:08:21,670
because t1 committed before my

1716
01:08:21,670 --> 01:08:23,859
checkpoint so I know all the t1 changes

1717
01:08:23,859 --> 01:08:25,630
are written a disk so I don't need to

1718
01:08:25,630 --> 01:08:27,939
replay and look at it's long it's the

1719
01:08:27,939 --> 01:08:30,880
other two guys t2 and t3 those guys get

1720
01:08:30,880 --> 01:08:32,229
started and could potentially make

1721
01:08:32,229 --> 01:08:34,149
change before my checkpoint so I need to

1722
01:08:34,149 --> 01:08:35,890
go back in the log up to that point and

1723
01:08:35,890 --> 01:08:38,469
figure out what they actually did to

1724
01:08:38,469 --> 01:08:40,660
my Davis back in the correct state so in

1725
01:08:40,660 --> 01:08:41,560
the case here

1726
01:08:41,560 --> 01:08:44,799
t2 committed before the crash so I know

1727
01:08:44,799 --> 01:08:46,630
I want to reapply it changes to redo

1728
01:08:46,630 --> 01:08:49,600
their exchanges t3 did not commit before

1729
01:08:49,600 --> 01:08:51,460
the crash so I would know I want to

1730
01:08:51,460 --> 01:08:55,509
reverse its changes right so the

1731
01:08:55,509 --> 01:08:56,680
checkpoints basically if your skin is

1732
01:08:56,680 --> 01:08:58,299
telling us that we know that at this

1733
01:08:58,299 --> 01:09:00,670
point in time all dirty pages from any

1734
01:09:00,670 --> 01:09:01,779
transactions have been written to disk

1735
01:09:01,779 --> 01:09:04,509
and it's up for us to then figure out

1736
01:09:04,509 --> 01:09:07,540
well what came slightly before the

1737
01:09:07,540 --> 01:09:09,100
checkpoint and what came after the

1738
01:09:09,100 --> 01:09:10,719
checkpoint to decide who's allowed to

1739
01:09:10,719 --> 01:09:15,759
actually have their changes persisted so

1740
01:09:15,759 --> 01:09:17,319
well game will talk about checkpoints

1741
01:09:17,319 --> 01:09:20,198
more on Wednesday but in my simple

1742
01:09:20,198 --> 01:09:22,600
example here I stalled all the

1743
01:09:22,600 --> 01:09:24,719
transactions to make my life easier

1744
01:09:24,719 --> 01:09:27,310
because if I have a transaction that's

1745
01:09:27,310 --> 01:09:29,380
updating a bunch of pages I don't want

1746
01:09:29,380 --> 01:09:32,170
to have the case or it could be I had to

1747
01:09:32,170 --> 01:09:33,549
do some actual work to figure out well

1748
01:09:33,549 --> 01:09:35,290
I'm updating 20 pages and my checkpoint

1749
01:09:35,290 --> 01:09:36,880
flushed out the first 10 pages that

1750
01:09:36,880 --> 01:09:39,160
transaction modified but then while the

1751
01:09:39,160 --> 01:09:40,238
checkpoint was running it modified these

1752
01:09:40,238 --> 01:09:41,529
other ones I didn't flush those things

1753
01:09:41,529 --> 01:09:43,479
out so I don't want to figure out which

1754
01:09:43,479 --> 01:09:47,710
ones actually should be around the other

1755
01:09:47,710 --> 01:09:49,359
tricky thing is gonna be it's not clear

1756
01:09:49,359 --> 01:09:50,890
how often we should take a checkpoint

1757
01:09:50,890 --> 01:09:52,359
because these checkpoints aren't free

1758
01:09:52,359 --> 01:09:54,310
because we're writing out dirty pages

1759
01:09:54,310 --> 01:09:56,440
and that's slowing slowing the disk when

1760
01:09:56,440 --> 01:09:58,540
we could be running out to a log now in

1761
01:09:58,540 --> 01:10:00,190
a lot of systems they'll have the disks

1762
01:10:00,190 --> 01:10:01,989
the log we stored in separate discs and

1763
01:10:01,989 --> 01:10:03,910
the heat balls are sort of separate

1764
01:10:03,910 --> 01:10:05,560
discs so when you do a net syncs on both

1765
01:10:05,560 --> 01:10:06,820
of them you're not slowing down each

1766
01:10:06,820 --> 01:10:08,739
other but again now my checkpoint is

1767
01:10:08,739 --> 01:10:11,170
running out dirty pages when I could

1768
01:10:11,170 --> 01:10:13,000
have been you know evicting pages for

1769
01:10:13,000 --> 01:10:13,449
disk

1770
01:10:13,449 --> 01:10:16,960
to get new space in my buffer pool to

1771
01:10:16,960 --> 01:10:19,530
have other transactions keep on running

1772
01:10:19,530 --> 01:10:21,730
so how often you take a checkpoint can

1773
01:10:21,730 --> 01:10:25,469
vary based on the implementation so the

1774
01:10:25,469 --> 01:10:28,030
one approach is to say every after every

1775
01:10:28,030 --> 01:10:30,760
every Sura minutes or seconds take the

1776
01:10:30,760 --> 01:10:33,940
checkpoint if I do that then my recovery

1777
01:10:33,940 --> 01:10:36,100
time is much faster because now I don't

1778
01:10:36,100 --> 01:10:37,810
need to go as far back in the log debris

1779
01:10:37,810 --> 01:10:38,560
figure out what should be actually

1780
01:10:38,560 --> 01:10:40,239
persisted because my checkpoint is

1781
01:10:40,239 --> 01:10:42,250
occurring more frequently because now

1782
01:10:42,250 --> 01:10:43,750
the checkpoints are slowing me down so

1783
01:10:43,750 --> 01:10:45,239
I'm like my runtime performance suffers

1784
01:10:45,239 --> 01:10:47,080
another approach which I actually think

1785
01:10:47,080 --> 01:10:49,719
is better is that the checkpoint only

1786
01:10:49,719 --> 01:10:51,219
occurs after a certain amount of data

1787
01:10:51,219 --> 01:10:52,239
that ran out the law

1788
01:10:52,239 --> 01:10:54,099
like after I've written out 250

1789
01:10:54,099 --> 01:10:56,289
megabytes of data to the log then I take

1790
01:10:56,289 --> 01:10:59,050
a checkpoint and that that bounds the

1791
01:10:59,050 --> 01:11:01,599
amount of time you have to wait and you

1792
01:11:01,599 --> 01:11:05,320
don't worry about whether you're taking

1793
01:11:05,320 --> 01:11:07,869
checkpoints unnecessarily because it's

1794
01:11:07,869 --> 01:11:10,030
your I know that I only need to look at

1795
01:11:10,030 --> 01:11:11,619
me but I'd most join fifty megabytes of

1796
01:11:11,619 --> 01:11:13,420
the log before at the recover my

1797
01:11:13,420 --> 01:11:16,119
database again I'm going over this very

1798
01:11:16,119 --> 01:11:17,739
very very fast cuz we're running out of

1799
01:11:17,739 --> 01:11:19,780
time but we'll cover this more detail

1800
01:11:19,780 --> 01:11:23,920
i'm teletrac of ur e on on wednesday so

1801
01:11:23,920 --> 01:11:25,090
any any high-level questions about

1802
01:11:25,090 --> 01:11:28,179
checkpoints saying a checkpoint is like

1803
01:11:28,179 --> 01:11:29,949
garbage collection for for the right

1804
01:11:29,949 --> 01:11:32,289
ahead log but i know that at that at

1805
01:11:32,289 --> 01:11:33,249
that point of checkpoint

1806
01:11:33,249 --> 01:11:35,440
I don't potentially need to look at

1807
01:11:35,440 --> 01:11:42,219
anything it came before of course in the

1808
01:11:42,219 --> 01:11:43,389
extreme case if I have it if I would

1809
01:11:43,389 --> 01:11:45,190
chose action the runs for days and I'm

1810
01:11:45,190 --> 01:11:46,210
taking a check one every five minutes

1811
01:11:46,210 --> 01:11:48,639
and I need to go back to when that

1812
01:11:48,639 --> 01:11:49,719
transaction started to figure out what

1813
01:11:49,719 --> 01:11:55,690
all changes actually made okay so as I

1814
01:11:55,690 --> 01:11:57,369
said right ahead logging is is almost

1815
01:11:57,369 --> 01:12:00,159
always the preferable approach that the

1816
01:12:00,159 --> 01:12:03,340
better approach to handle avoiding data

1817
01:12:03,340 --> 01:12:04,869
loss or to make sure that our database

1818
01:12:04,869 --> 01:12:07,869
ism is durable on disk and the core idea

1819
01:12:07,869 --> 01:12:09,880
what's gonna how it works is that it's

1820
01:12:09,880 --> 01:12:11,590
gonna use steel no force buffer pool

1821
01:12:11,590 --> 01:12:13,989
management policy it's gonna flush all

1822
01:12:13,989 --> 01:12:16,030
changes that transactions made to their

1823
01:12:16,030 --> 01:12:18,369
log records to disk before we tell the

1824
01:12:18,369 --> 01:12:19,539
outside world that a transaction is

1825
01:12:19,539 --> 01:12:21,369
committed and then in the background of

1826
01:12:21,369 --> 01:12:22,539
some later point we can flush out

1827
01:12:22,539 --> 01:12:24,340
there's those dirty pages but we have to

1828
01:12:24,340 --> 01:12:25,690
write the log records first before we

1829
01:12:25,690 --> 01:12:27,429
can write out the dirty pages that they

1830
01:12:27,429 --> 01:12:31,630
modify and so on recovery we just undo

1831
01:12:31,630 --> 01:12:33,400
any changes from uncommitted

1832
01:12:33,400 --> 01:12:35,289
transactions and they redo the commit

1833
01:12:35,289 --> 01:12:37,210
changes the committed to redo the change

1834
01:12:37,210 --> 01:12:38,650
of any committed transactions to make

1835
01:12:38,650 --> 01:12:45,190
sure that they get applied yes this

1836
01:12:45,190 --> 01:12:47,230
question is we have to undo potentially

1837
01:12:47,230 --> 01:12:48,610
changes on recovery again we'll cover

1838
01:12:48,610 --> 01:12:51,460
that on Wednesday because changes from

1839
01:12:51,460 --> 01:12:53,469
uncommitted transactions could have

1840
01:12:53,469 --> 01:12:55,030
those dirty pages could read rid now the

1841
01:12:55,030 --> 01:12:56,739
disk because we're using the steal

1842
01:12:56,739 --> 01:12:59,130
policy

1843
01:13:02,489 --> 01:13:04,809
I'll never ever wore it actually right

1844
01:13:04,809 --> 01:13:05,380
now

1845
01:13:05,380 --> 01:13:08,559
his question is this question is other

1846
01:13:08,559 --> 01:13:11,139
scenarios where upon recovery we would

1847
01:13:11,139 --> 01:13:12,999
not have to undo because we can look at

1848
01:13:12,999 --> 01:13:14,919
data art changes actually make it out

1849
01:13:14,919 --> 01:13:24,939
the disc the know the the spoiler would

1850
01:13:24,939 --> 01:13:28,539
be for Wednesday you redo everything you

1851
01:13:28,539 --> 01:13:29,650
could riff through the law of multiple

1852
01:13:29,650 --> 01:13:30,039
times

1853
01:13:30,039 --> 01:13:32,199
you're gonna redo everything but then as

1854
01:13:32,199 --> 01:13:34,150
you redo you say oh I see this

1855
01:13:34,150 --> 01:13:35,739
transaction didn't commit then you go

1856
01:13:35,739 --> 01:13:37,389
back and reverse on the log and you undo

1857
01:13:37,389 --> 01:13:40,929
anything that is on so you you just you

1858
01:13:40,929 --> 01:13:44,079
play it safe and you always undo there

1859
01:13:44,079 --> 01:13:45,309
are some optimizations that I don't

1860
01:13:45,309 --> 01:13:50,459
think most people do them all right so

1861
01:13:50,459 --> 01:13:53,289
on Wednesdays class again it would be

1862
01:13:53,289 --> 01:13:54,369
the second part of what we talked about

1863
01:13:54,369 --> 01:13:56,110
for logging recovery is two things we do

1864
01:13:56,110 --> 01:13:58,239
after a crash right after a restart how

1865
01:13:58,239 --> 01:13:59,530
do we use the right head log how to use

1866
01:13:59,530 --> 01:14:00,550
the check points to put us back in the

1867
01:14:00,550 --> 01:14:02,889
correct State so this is probably the

1868
01:14:02,889 --> 01:14:05,499
third hardest part of database systems

1869
01:14:05,499 --> 01:14:07,150
so the thing we're talking about is

1870
01:14:07,150 --> 01:14:10,239
Aries Aries is the gold standard of how

1871
01:14:10,239 --> 01:14:11,949
you do database recovery I don't know

1872
01:14:11,949 --> 01:14:14,199
what the textbook calls it Aries

1873
01:14:14,199 --> 01:14:16,539
but and most systems that implement

1874
01:14:16,539 --> 01:14:18,070
right ahead of all are not gonna call

1875
01:14:18,070 --> 01:14:20,110
but they're doing Aries but everybody

1876
01:14:20,110 --> 01:14:21,639
that does red head logging it's me based

1877
01:14:21,639 --> 01:14:23,349
on the IBM's protocol from the 1990s

1878
01:14:23,349 --> 01:14:24,969
whether or not they know that they're

1879
01:14:24,969 --> 01:14:27,219
using their basically using Aries I'm

1880
01:14:27,219 --> 01:14:30,550
Graham all right I'm having office hours

1881
01:14:30,550 --> 01:14:34,900
now at 1:30 and see you guys on Monday

1882
01:14:34,900 --> 01:14:37,019
Oh

1883
01:14:40,929 --> 01:14:42,939
losing crushed up kids let the cows in

1884
01:14:42,939 --> 01:14:46,329
the demo I'll Drive he's with say knives

1885
01:14:46,329 --> 01:14:48,459
in my system I'm blessed

1886
01:14:48,459 --> 01:14:55,929
let's go get the next one get over good

1887
01:14:55,929 --> 01:14:57,969
there will be son ricochet jelly hit the

1888
01:14:57,969 --> 01:15:00,099
deli for a boat one naturally bless ya

1889
01:15:00,099 --> 01:15:01,809
what rap is like a laser beam the fools

1890
01:15:01,809 --> 01:15:04,360
in the bush say nothing like a king wrap

1891
01:15:04,360 --> 01:15:06,670
the bottle of us a nice sympathy go you

1892
01:15:06,670 --> 01:15:08,530
don't feel like drinking that boney to

1893
01:15:08,530 --> 01:15:11,289
you drunk you can't try and if the sake

1894
01:15:11,289 --> 01:15:14,780
don't know your phone can tap a thing

1895
01:15:14,780 --> 01:15:17,840
[Music]

