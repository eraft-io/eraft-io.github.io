1
00:00:01,300 --> 00:00:05,129
[音乐]

2
00:00:05,200 --> 00:00:05,930
[掌声]

3
00:00:05,930 --> 00:00:08,630
[音乐]

4
00:00:08,630 --> 00:00:10,020
[掌声]

5
00:00:10,020 --> 00:00:12,650
[音乐]

6
00:00:12,650 --> 00:00:16,550
正如我所说的，这周我不能在校园里

7
00:00:16,550 --> 00:00:19,770
我现在还在欧洲我

8
00:00:19,770 --> 00:00:22,650
实际上在慕尼黑在 Tum 拜访

9
00:00:22,650 --> 00:00:25,439
托马斯诺曼，那就是 他们在那里

10
00:00:25,439 --> 00:00:27,570
发明了 hyper 和新数据库 并

11
00:00:27,570 --> 00:00:30,449
放了一把雨伞 所以我

12
00:00:30,449 --> 00:00:32,610
去拜访 Thomas 的一部分

13
00:00:32,610 --> 00:00:34,290
是为了更好地理解为什么

14
00:00:34,290 --> 00:00:36,780
德国人如此擅长数据库，因此

15
00:00:36,780 --> 00:00:39,989
作为其中的一部分，他们把我带到了这里

16
00:00:39,989 --> 00:00:41,670
在阿尔卑斯山的某个山上，我

17
00:00:41,670 --> 00:00:43,140
不知道我们到底在哪里，

18
00:00:43,140 --> 00:00:45,570
天气很冷，就像这样，

19
00:00:45,570 --> 00:00:47,969
你在树林里，思考你的想法大约

20
00:00:47,969 --> 00:00:49,530
一个小时，或者

21
00:00:49,530 --> 00:00:51,750
以某种方式会神奇地让你

22
00:00:51,750 --> 00:00:54,930
更好地理解数据库 所以无论

23
00:00:54,930 --> 00:00:56,399
我现在坐在这里，

24
00:00:56,399 --> 00:00:58,020
天气都非常寒冷，有一些猎犬在

25
00:00:58,020 --> 00:01:00,180
四处乱跑，你可能会

26
00:01:00,180 --> 00:01:02,789
在背景中看到这些东西，我认为现在是

27
00:01:02,789 --> 00:01:04,049
通过并开始

28
00:01:04,049 --> 00:01:07,619
讨论下一个讲座的好时机，所以让我们看看

29
00:01:07,619 --> 00:01:09,330
如何 我们可以得到 b 在它变得太冷之前，

30
00:01:09,330 --> 00:01:14,189
最后一节课我们讨论

31
00:01:14,189 --> 00:01:16,530
了数据库系统的高级历史

32
00:01:16,530 --> 00:01:19,670
，我主要关注

33
00:01:19,670 --> 00:01:24,020


34
00:01:24,020 --> 00:01:29,700
的是在高级别的方面思考问题，主要

35
00:01:29,700 --> 00:01:31,680
基于你知道的数据模型 无论

36
00:01:31,680 --> 00:01:33,479
是 codasyl 的东西还是

37
00:01:33,479 --> 00:01:35,490
层次数据模型、关系

38
00:01:35,490 --> 00:01:38,610
数据模型等等，这都是

39
00:01:38,610 --> 00:01:41,970
上一堂课的主要讨论，另

40
00:01:41,970 --> 00:01:43,200
一种思考方式是

41
00:01:43,200 --> 00:01:45,240
贯穿整个

42
00:01:45,240 --> 00:01:48,869
数据库历史的一个总体主题，就是这种不断的

43
00:01:48,869 --> 00:01:51,329
斗争 构建

44
00:01:51,329 --> 00:01:53,369
必须处理

45
00:01:53,369 --> 00:01:56,189
当时港口限制的数据库系统

46
00:01:56,189 --> 00:01:58,409
1970 年代和 1960 年代一样，现在

47
00:01:58,409 --> 00:01:59,880
我们知道我们一直在尝试

48
00:01:59,880 --> 00:02:03,000
在新硬件上运行数据库并

49
00:02:03,000 --> 00:02:05,790
获得最佳性能 我们可以

50
00:02:05,790 --> 00:02:08,068
在 1970 年代摆脱它，尽管当他们

51
00:02:08,068 --> 00:02:09,538
构建第一个关系数据库系统

52
00:02:09,538 --> 00:02:11,819
数据库系统时，硬件与我们今天的有

53
00:02:11,819 --> 00:02:13,470
很大不同

54
00:02:13,470 --> 00:02:16,890
，但在高层次上 ic的

55
00:02:16,890 --> 00:02:20,010
想法仍然相同，所以

56
00:02:20,010 --> 00:02:21,270
问题就像我们开始

57
00:02:21,270 --> 00:02:24,870
谈论现代系统时一样，

58
00:02:24,870 --> 00:02:27,660
尽管基本思想仍然相同

59
00:02:27,660 --> 00:02:29,460
，但港湾的限制并不

60
00:02:29,460 --> 00:02:34,110
完全相同，所以在1970年代，

61
00:02:34,110 --> 00:02:35,670
好吧，您没有“ 没有有

62
00:02:35,670 --> 00:02:37,320
很多插槽的机器 有很多关于一个核心的

63
00:02:37,320 --> 00:02:39,210
权利 你有一个单元处理器 你有一个

64
00:02:39,210 --> 00:02:42,090
单核 CPU

65
00:02:42,090 --> 00:02:45,270
一次只能执行一个线程

66
00:02:45,270 --> 00:02:47,490
内存也受到严重限制 它非常

67
00:02:47,490 --> 00:02:50,280
昂贵 所以你是你 很幸运

68
00:02:50,280 --> 00:02:51,810
让你知道一台机器有 diarrea 但

69
00:02:51,810 --> 00:02:54,780
也许就像一个兆字节抱歉现在

70
00:02:54,780 --> 00:02:56,430
我们可以在

71
00:02:56,430 --> 00:02:59,190
一个盒子里进入 TB 因为麸皮有限

72
00:02:59,190 --> 00:03:00,750
我们将整个数据库存储在

73
00:03:00,750 --> 00:03:02,910
磁盘上所以整个架构

74
00:03:02,910 --> 00:03:04,770
数据库系统基于

75
00:03:04,770 --> 00:03:07,500
您知道从磁盘检索数据

76
00:03:07,500 --> 00:03:09,810
，当然当时

77
00:03:09,810 --> 00:03:12,660
这比现在慢得多，当然

78
00:03:12,660 --> 00:03:15,780
顺序访问

79
00:03:15,780 --> 00:03:18,269
比随机访问快得多，因此您尝试

80
00:03:18,269 --> 00:03:20,550
设计 算法和数据结构

81
00:03:20,550 --> 00:03:24,570
可以最大限度地访问，所以现在

82
00:03:24,570 --> 00:03:29,160
在现代时代，你知道 20 20 年代，现在

83
00:03:29,160 --> 00:03:31,650
我们拥有拥有足够 DRAM 的机器，

84
00:03:31,650 --> 00:03:34,709
这样大多数数据库可能

85
00:03:34,709 --> 00:03:36,780
完全适合主内存，并且

86
00:03:36,780 --> 00:03:38,250
总是会有异常值

87
00:03:38,250 --> 00:03:39,930
永远是你知道世界上的谷歌

88
00:03:39,930 --> 00:03:41,250
、Facebook 和亚马逊

89
00:03:41,250 --> 00:03:43,170
，他们的数据但他们的

90
00:03:43,170 --> 00:03:45,180
数据库可能是 PB 的大小，

91
00:03:45,180 --> 00:03:48,510
但对于大约 99% 的

92
00:03:48,510 --> 00:03:50,310
应用程序，他们的数据库可能

93
00:03:50,310 --> 00:03:53,190
以 GB 或几

94
00:03:53,190 --> 00:03:56,160
TB 为单位，所以 再次使用

95
00:03:56,160 --> 00:03:57,390
这种大小，您当然可以拥有一个

96
00:03:57,390 --> 00:03:59,209
完全适合主内存的数据库，

97
00:03:59,209 --> 00:04:01,380
无论它是分布式系统还是

98
00:04:01,380 --> 00:04:05,150
单节点系统，以便了解为什么

99
00:04:05,150 --> 00:04:07,739
您知道的数据库

100
00:04:07,739 --> 00:04:09,810
没有您认为的那么大，您

101
00:04:09,810 --> 00:04:11,519
必须了解

102
00:04:11,519 --> 00:04:12,900
结构化和

103
00:04:12,900 --> 00:04:14,340
非结构化数据或半结构化

104
00:04:14,340 --> 00:04:17,070
数据之间存在某种差异，因此结构化数据集或成为

105
00:04:17,070 --> 00:04:18,510
我们通常谈论的事物

106
00:04:18,510 --> 00:04:19,978
与您有关数据库，因此您有一个

107
00:04:19,978 --> 00:04:23,310
明确定义的模式，它们具有

108
00:04:23,310 --> 00:04:25,080
正确的属性，并且每个记录都必须具有这些

109
00:04:25,080 --> 00:04:27,669
属性，因此在这些数据中，

110
00:04:27,669 --> 00:04:29,169
它们通常又是

111
00:04:29,169 --> 00:04:31,930
通常较小的非结构化数据

112
00:04:31,930 --> 00:04:35,409
集，例如视频文件声音

113
00:04:35,409 --> 00:04:37,509
文件或 正确的图像在这些情况

114
00:04:37,509 --> 00:04:39,759
下

115
00:04:39,759 --> 00:04:41,860
，该数据集中每条记录的内容都会

116
00:04:41,860 --> 00:04:43,659
有所不同，或者根本没有任何

117
00:04:43,659 --> 00:04:45,219
结构，而且您知道您不能

118
00:04:45,219 --> 00:04:49,469
直接对半结构化的视频数据运行查询

119
00:04:49,469 --> 00:04:52,120


120
00:04:52,120 --> 00:04:54,249
是诸如生成的日志文件之类的东西，

121
00:04:54,249 --> 00:04:55,300
它们本来是人类

122
00:04:55,300 --> 00:04:58,449
可读的，但是您知道它们

123
00:04:58,449 --> 00:05:00,759
不会为每条日志记录提供完全相同的字段，

124
00:05:00,759 --> 00:05:03,159
您可以解析

125
00:05:03,159 --> 00:05:05,409
它们并提取这些字段 但你

126
00:05:05,409 --> 00:05:06,699
知道一些爱情记录可能有其他

127
00:05:06,699 --> 00:05:09,909
领域 其他可能有其他领域 所以

128
00:05:09,909 --> 00:05:11,680
再次非结构化和半结构化

129
00:05:11,680 --> 00:05:13,689
数据集 这些通常更大，你

130
00:05:13,689 --> 00:05:16,689
认为像 YouTube YouTube 是的

131
00:05:16,689 --> 00:05:19,300
，我的续集 l 他们

132
00:05:19,300 --> 00:05:21,939
在 YouTube 中使用的数据库，你知道这将

133
00:05:21,939 --> 00:05:23,800


134
00:05:23,800 --> 00:05:25,150
是他们存储的视频总量的一小部分

135
00:05:25,150 --> 00:05:26,379
，视频所有非结构化的

136
00:05:26,379 --> 00:05:29,370
东西，我的续集四十年代数据库是

137
00:05:29,370 --> 00:05:32,469
结构化数据库，所以为了我们的目的，

138
00:05:32,469 --> 00:05:34,419
这里 在本课程中，我们将

139
00:05:34,419 --> 00:05:36,960
主要关注结构化数据，因为

140
00:05:36,960 --> 00:05:39,490
只有您知道您

141
00:05:39,490 --> 00:05:40,360
可以做我们在这里谈论的事情，

142
00:05:40,360 --> 00:05:42,159
但是没有神奇的方法可以

143
00:05:42,159 --> 00:05:44,560
对视频数据进行矢量化查询执行，

144
00:05:44,560 --> 00:05:46,539
您会怎么做？ 必须做的是，您必须

145
00:05:46,539 --> 00:05:48,550
将该视频数据转换为结构化

146
00:05:48,550 --> 00:05:49,599
数据，然后您可以在其上运行您的查询

147
00:05:49,599 --> 00:05:53,409
，因此它们将

148
00:05:53,409 --> 00:05:55,060
成为我们今天在这里的扑克服务器我们

149
00:05:55,060 --> 00:05:58,449


150
00:05:58,449 --> 00:06:01,680
现在还需要了解的另一件事是 我们

151
00:06:01,680 --> 00:06:03,430
以及我们将如何

152
00:06:03,430 --> 00:06:05,409
在 davis 主义中获得最佳性能以在

153
00:06:05,409 --> 00:06:08,589
结构化数据上运行，因此您可能认为没问题，

154
00:06:08,589 --> 00:06:10,449
如果我的数据库

155
00:06:10,449 --> 00:06:12,849
可以主要用于主内存，我可以

156
00:06:12,849 --> 00:06:15,339
采用您知道的传统 磁盘或

157
00:06:15,339 --> 00:06:18,580
数据库系统就像我

158
00:06:18,580 --> 00:06:20,229
上学期在介绍课上描述的那样，

159
00:06:20,229 --> 00:06:22,479
我们可以让你知道

160
00:06:22,479 --> 00:06:25,029
在一台机器上运行它，

161
00:06:25,029 --> 00:06:26,409
通过 Ram 运行它，并通过 Ram 将缓冲池

162
00:06:26,409 --> 00:06:29,500
缓存大小设置为足够大，以便

163
00:06:29,500 --> 00:06:30,759
一切都会在记忆

164
00:06:30,759 --> 00:06:32,050
中 足以让我们

165
00:06:32,050 --> 00:06:34,060
获得最佳表现 剧透

166
00:06:34,060 --> 00:06:35,680
是不对的 我们需要

167
00:06:35,680 --> 00:06:38,589
了解为什么 所以今天的讲座

168
00:06:38,589 --> 00:06:40,569
看看我们能走多远 在我们变得太冷之前

169
00:06:40,569 --> 00:06:41,560


170
00:06:41,560 --> 00:06:43,630
是 我们将首先讨论什么是

171
00:06:43,630 --> 00:06:45,700
角膜数据库系统，这样我们就可以

172
00:06:45,700 --> 00:06:47,200
理解你知道，当我们开始

173
00:06:47,200 --> 00:06:49,180
谈论模仿系统时，它们如何

174
00:06:49,180 --> 00:06:52,210
避免

175
00:06:52,210 --> 00:06:54,580
扭曲系统的减速问题的所有瓶颈，

176
00:06:54,580 --> 00:06:57,130
然后我们将从这里开始讨论

177
00:06:57,130 --> 00:06:58,510
可以更深入地了解当前的

178
00:06:58,510 --> 00:06:59,740
角色，看看

179
00:06:59,740 --> 00:07:01,690
我们必须克服哪些瓶颈才能让这些

180
00:07:01,690 --> 00:07:04,150
控制协议在内存系统中运行，

181
00:07:04,150 --> 00:07:08,800
所以我

182
00:07:08,800 --> 00:07:10,510
总是喜欢使用磁盘或任何数据的

183
00:07:10,510 --> 00:07:13,690
定义 Tabase 系统是这样一种

184
00:07:13,690 --> 00:07:15,700
系统，其中系统的架构系统

185
00:07:15,700 --> 00:07:18,490
基于这样的假设：

186
00:07:18,490 --> 00:07:20,169
主要搜索位置数据库

187
00:07:20,169 --> 00:07:22,090
就像数据库的所有内容一样，

188
00:07:22,090 --> 00:07:23,740
那里有记录和索引以及使用过的材料

189
00:07:23,740 --> 00:07:25,290
，商店中的所有东西

190
00:07:25,290 --> 00:07:27,700
都将处于某种状态 非易失性

191
00:07:27,700 --> 00:07:29,380
存储，但这是一个旋转的磁盘硬盘

192
00:07:29,380 --> 00:07:32,650
驱动器或 SSD，因此这意味着将

193
00:07:32,650 --> 00:07:34,750


194
00:07:34,750 --> 00:07:35,680
基于此假设设计数据库，因此所有

195
00:07:35,680 --> 00:07:37,479
算法，数据结构以及其中的

196
00:07:37,479 --> 00:07:39,340
所有内容都

197
00:07:39,340 --> 00:07:40,870
必须意识到 你知道在任何时候我们

198
00:07:40,870 --> 00:07:42,419
都可能不得不从磁盘中获取一些东西，

199
00:07:42,419 --> 00:07:44,860
现在数据库本身将被

200
00:07:44,860 --> 00:07:47,320
组织成一组固定长度的

201
00:07:47,320 --> 00:07:48,789
页面或有时会变成

202
00:07:48,789 --> 00:07:51,700
块的东西，然后我们将使用 Emery

203
00:07:51,700 --> 00:07:54,430
缓冲管理器来存储或缓存

204
00:07:54,430 --> 00:07:56,950
当我们再次从磁盘接收内存页面时，

205
00:07:56,950 --> 00:07:59,320
我们假设是冯诺依曼

206
00:07:59,320 --> 00:08:01,990
架构，这意味着我们不能

207
00:08:01,990 --> 00:08:04,630
知道不能直接对数据进行操作，

208
00:08:04,630 --> 00:08:07,270
因为它退出 您知道磁盘上的 sts 可以

209
00:08:07,270 --> 00:08:09,039
在某些现代硬件中更改，但出于

210
00:08:09,039 --> 00:08:10,570
我们的目的，这里假设

211
00:08:10,570 --> 00:08:13,240
情况并非如此，因此更可取的

212
00:08:13,240 --> 00:08:15,490
管理器实际上是关于如何根据需要决定

213
00:08:15,490 --> 00:08:16,900
如何

214
00:08:16,900 --> 00:08:19,750
在磁盘和内存之间来回移动这些数据，我们

215
00:08:19,750 --> 00:08:20,800
想要 以这样一种方式做到这一点，我们可以

216
00:08:20,800 --> 00:08:23,770
最大限度地减少停顿量或

217
00:08:23,770 --> 00:08:25,240
我们必须退出

218
00:08:25,240 --> 00:08:28,930
磁盘的次数，因此该缓冲池

219
00:08:28,930 --> 00:08:32,589
是区分磁盘或

220
00:08:32,589 --> 00:08:33,969
内存数据库

221
00:08:33,969 --> 00:08:35,409
系统与本地化的关键 就像架构一样，

222
00:08:35,409 --> 00:08:38,830
所以将会发生的是

223
00:08:38,830 --> 00:08:39,700
我们将有一个将

224
00:08:39,700 --> 00:08:41,919
在我们的系统中执行的查询，并且在任何时候

225
00:08:41,919 --> 00:08:43,809
要求访问元组我们必须

226
00:08:43,809 --> 00:08:46,029
找到我们的元组所在的页面，

227
00:08:46,029 --> 00:08:49,000
所以数据说去检查

228
00:08:49,000 --> 00:08:50,680
查看该查询所需的页面

229
00:08:50,680 --> 00:08:53,470
是否已经在内存中，如果是，那么

230
00:08:53,470 --> 00:08:54,850
我们只需将指针返回

231
00:08:54,850 --> 00:08:55,810


232
00:08:55,810 --> 00:08:57,310
到正确轮询的慢速位置，

233
00:08:57,310 --> 00:09:00,160
如果不是，则查询可以执行，然后我们开始

234
00:09:00,160 --> 00:09:02,529
需要做一些额外的 stu  ff 所以我们必须做的第一件事

235
00:09:02,529 --> 00:09:05,380
是我们必须决定我们要将

236
00:09:05,380 --> 00:09:07,450


237
00:09:07,450 --> 00:09:10,389
页面复制到缓冲池中的帧，因此帧

238
00:09:10,389 --> 00:09:12,820
只是

239
00:09:12,820 --> 00:09:14,680
我们盈利管理器分配的内存中的一个位置，我们

240
00:09:14,680 --> 00:09:15,940
使用它 用于

241
00:09:15,940 --> 00:09:19,060
区分页面或块的术语，因为对于不同

242
00:09:19,060 --> 00:09:20,680
的页面会反复使用相同的框架

243
00:09:20,680 --> 00:09:23,410
，所以如果

244
00:09:23,410 --> 00:09:25,990
有一个空闲的框架，那么我们的工作很

245
00:09:25,990 --> 00:09:27,699
简单，我们只是说这是

246
00:09:27,699 --> 00:09:29,529
我们要放置的框架 我们

247
00:09:29,529 --> 00:09:30,790
从磁盘中获取它并复制进来，然后我们就

248
00:09:30,790 --> 00:09:33,550
完成了，但是现在没有可用的框架，然后

249
00:09:33,550 --> 00:09:35,170
我们必须从现有框架中找到一个存在的页面

250
00:09:35,170 --> 00:09:37,209
，这就是事情变得复杂的时候，

251
00:09:37,209 --> 00:09:40,480
所以如果我们想要的页面

252
00:09:40,480 --> 00:09:42,190
我们想要 evict 如果它从未

253
00:09:42,190 --> 00:09:43,990
被事务修改过我的意思是它

254
00:09:43,990 --> 00:09:46,180
不脏那么我们的工作很容易我们只需

255
00:09:46,180 --> 00:09:48,790
将它写出来你知道我们只是删除

256
00:09:48,790 --> 00:09:51,610
它然后重新使用框架但是如果它是

257
00:09:51,610 --> 00:09:53,860
脏的那么我们现在必须被驱逐所以

258
00:09:53,860 --> 00:09:55,149
我们 必须写下磁盘并

259
00:09:55,149 --> 00:09:57,760
刷新它，一旦完成 现在我们可以

260
00:09:57,760 --> 00:10:00,970
使用我们的框架了，所以你可以再次看到

261
00:10:00,970 --> 00:10:02,320
为什么这很复杂，因为你

262
00:10:02,320 --> 00:10:03,880
知道我们基本上在运行你知道

263
00:10:03,880 --> 00:10:06,279
LRU 或时钟或任何

264
00:10:06,279 --> 00:10:07,720
你想用来决定如何

265
00:10:07,720 --> 00:10:09,760
驱逐框架的展览政策，我们必须平衡

266
00:10:09,760 --> 00:10:11,500
有了你知道哪些其他查询或

267
00:10:11,500 --> 00:10:12,550
事务同时运行

268
00:10:12,550 --> 00:10:15,250
哪些页面是脏的，这一切都

269
00:10:15,250 --> 00:10:18,279
变得非常复杂，所以现在一旦

270
00:10:18,279 --> 00:10:20,560
页面在内存中，那么你知道我们可以

271
00:10:20,560 --> 00:10:21,850
尝试变得聪明并尝试快速翻译

272
00:10:21,850 --> 00:10:25,420
磁盘上的任何内容 or 对

273
00:10:25,420 --> 00:10:27,550
我们页面的引用现在是一个 或 内存地址，

274
00:10:27,550 --> 00:10:28,600
这样我们就不必

275
00:10:28,600 --> 00:10:30,310


276
00:10:30,310 --> 00:10:31,510
每次都检查缓冲池管理器的整个过程，

277
00:10:31,510 --> 00:10:33,310
但并不是每个系统中的每个现在都

278
00:10:33,310 --> 00:10:35,769
在高层次上这样做

279
00:10:35,769 --> 00:10:37,000
我刚刚谈到的看起来像这样，

280
00:10:37,000 --> 00:10:39,430
所以为了我们的目的，这里

281
00:10:39,430 --> 00:10:40,779
说我们正在做一个查询，它将查找一个索引

282
00:10:40,779 --> 00:10:42,550
索引 它想要找到

283
00:10:42,550 --> 00:10:43,990
一个记录 页面内的记录 我们

284
00:10:43,990 --> 00:10:46,630
可以从磁盘中获取它以便 简化 在我们的

285
00:10:46,630 --> 00:10:49,329
讨论中，我们会说索引不是

286
00:10:49,329 --> 00:10:52,000
不受缓冲池页面支持的，它

287
00:10:52,000 --> 00:10:54,220
实际上只是位于大多数

288
00:10:54,220 --> 00:10:55,990
系统中的内存中，这实际上是不对

289
00:10:55,990 --> 00:10:57,490
的，索引页面本身

290
00:10:57,490 --> 00:10:58,690
将由强大的管理器支持，因此我们

291
00:10:58,690 --> 00:10:59,829
必须去检查以查看 这些

292
00:10:59,829 --> 00:11:01,060
页面是否也在内存中

293
00:11:01,060 --> 00:11:03,100
并完成整个过程，但我们

294
00:11:03,100 --> 00:11:04,089
会保持简单并说它

295
00:11:04,089 --> 00:11:06,430
完全是内存所以首先

296
00:11:06,430 --> 00:11:08,050
要做的是您查找我们的索引以

297
00:11:08,050 --> 00:11:08,570
找到我们

298
00:11:08,570 --> 00:11:11,270
的索引以及索引会给我们什么 返回

299
00:11:11,270 --> 00:11:13,100
给我们作为付费 ID 和槽

300
00:11:13,100 --> 00:11:15,260
号，然后我们可以使用该页面 ID

301
00:11:15,260 --> 00:11:17,060
来查看页表并

302
00:11:17,060 --> 00:11:19,430
找到我们正在寻找的页面的位置，

303
00:11:19,430 --> 00:11:21,200
所以假设我们' 重新

304
00:11:21,200 --> 00:11:24,080
查找第 1 页，然后我们不会

305
00:11:24,080 --> 00:11:25,910
在我们的页表中找到该条目，或者我们会

306
00:11:25,910 --> 00:11:27,290
看到一个条目，上面写着哦，它不在

307
00:11:27,290 --> 00:11:28,580
磁盘上的内存中，

308
00:11:28,580 --> 00:11:31,910
这是在磁盘上找到它的位置，以便将其

309
00:11:31,910 --> 00:11:34,490
带入内存 我们必须去选择一个现有的

310
00:11:34,490 --> 00:11:37,700
页面来攻击，所以我们必须锁定这个

311
00:11:37,700 --> 00:11:39,200
页面 表以确保没有其他

312
00:11:39,200 --> 00:11:40,550
人试图在我们同时带来它

313
00:11:40,550 --> 00:11:42,410
然后我们必须拿起

314
00:11:42,410 --> 00:11:44,090
这些页面中的一页来驱逐所以假设我们

315
00:11:44,090 --> 00:11:47,060
选择了第二页但第二页很脏所以

316
00:11:47,060 --> 00:11:48,860
现在我们必须写出来 到磁盘并

317
00:11:48,860 --> 00:11:51,680
刷新它，然后一旦完成，

318
00:11:51,680 --> 00:11:53,900
我们现在可以使用空闲框架复制第一

319
00:11:53,900 --> 00:11:56,840
页，此时我们更新

320
00:11:56,840 --> 00:11:58,370
我们的页表说嘿，如果您查找第一

321
00:11:58,370 --> 00:12:00,140
页，这是

322
00:12:00,140 --> 00:12:01,880
之前管理中的框架 去找到它，然后

323
00:12:01,880 --> 00:12:03,020
一旦完成，我们就可以释放我们的

324
00:12:03,020 --> 00:12:05,720
闩锁，任何人都可以访问它，所以

325
00:12:05,720 --> 00:12:06,950
这是对

326
00:12:06,950 --> 00:12:10,130
这个驱逐过程如何正确进行的一种粗略的简化，

327
00:12:10,130 --> 00:12:11,780
因为如果有页面条目，我就不能很好地展示它

328
00:12:11,780 --> 00:12:13,190
两个然后你

329
00:12:13,190 --> 00:12:15,410
现在可以在页表中更新它，

330
00:12:15,410 --> 00:12:17,300
说它不在内存中，现在它在

331
00:12:17,300 --> 00:12:20,510
磁盘上，但你知道在高层次上

332
00:12:20,510 --> 00:12:21,620
，你知道

333
00:12:21,620 --> 00:12:23,930
使用缓冲池的每个数据库系统都在做

334
00:12:23,930 --> 00:12:27,380
类似的事情，所以这是什么问题 好吧，

335
00:12:27,380 --> 00:12:30,860
如果现在我们得到我们回到我们的考试

336
00:12:30,860 --> 00:12:33,050
我说让我们给我们的数据库系统

337
00:12:33,050 --> 00:12:35,270
很多内存 现在一切都会

338
00:12:35,270 --> 00:12:37,400
很好地适应内存 我们仍在经历

339
00:12:37,400 --> 00:12:39,020
整个过程 去查找页

340
00:12:39,020 --> 00:12:40,430
表 尝试每次

341
00:12:40,430 --> 00:12:42,080
将记录 ID 翻译成其内存位置

342
00:12:42,080 --> 00:12:44,590
我们访问一个元组，

343
00:12:44,590 --> 00:12:46,730
我们必须采取闩锁并保护

344
00:12:46,730 --> 00:12:48,650
事物，因为我们不希望我们

345
00:12:48,650 --> 00:12:51,170
在页面墙中被访问，然后有

346
00:12:51,170 --> 00:12:52,340
另一个威胁试图驱逐该页面，

347
00:12:52,340 --> 00:12:54,530
但就像我说的，如果我们有足够的

348
00:12:54,530 --> 00:12:56,090
内存，那么我们' 永远不会真正

349
00:12:56,090 --> 00:12:58,370
将任何内容写出磁盘，因此固定

350
00:12:58,370 --> 00:13:00,020
这些页面并锁定它们

351
00:13:00,020 --> 00:13:01,520
实际上根本没有必要，因此只是

352
00:13:01,520 --> 00:13:04,160
浪费了一些工作，然后运行

353
00:13:04,160 --> 00:13:05,540
该驱逐策略以更新

354
00:13:05,540 --> 00:13:07,040
有关如何访问页面的所有内部指标

355
00:13:07,040 --> 00:13:08,480
，这也是一个 也浪费了

356
00:13:08,480 --> 00:13:10,370
工作，因为再没有

357
00:13:10,370 --> 00:13:12,890
什么会成为受害者，所以这种

358
00:13:12,890 --> 00:13:14,540
回答我一开始的稻草人问题，

359
00:13:14,540 --> 00:13:16,970
我们不能给

360
00:13:16,970 --> 00:13:20,090
它一些大量的记忆，你知道

361
00:13:20,090 --> 00:13:21,890
传统 你消耗了大量

362
00:13:21,890 --> 00:13:22,400
内存，这

363
00:13:22,400 --> 00:13:24,080
足以让你知道

364
00:13:24,080 --> 00:13:25,580
获得与我们获得内存系统相同的性能

365
00:13:25,580 --> 00:13:27,800
，答案是否定的，

366
00:13:27,800 --> 00:13:29,240
因为你正在做这些你知道的所有应用程序

367
00:13:29,240 --> 00:13:30,380
都在做这些额外的工作

368
00:13:30,380 --> 00:13:34,910
现在去访问单个页面，这

369
00:13:34,910 --> 00:13:36,589
也会导致其他问题，

370
00:13:36,589 --> 00:13:40,070
比如在并发仪式中，所以

371
00:13:40,070 --> 00:13:41,260
传统的基于磁盘的系统

372
00:13:41,260 --> 00:13:43,910
破坏了系统的设计

373
00:13:43,910 --> 00:13:45,470
，使得事务在任何时候

374
00:13:45,470 --> 00:13:47,089
都可以触及内存，而不是在磁盘中

375
00:13:47,089 --> 00:13:48,680
，因此 该事务

376
00:13:48,680 --> 00:13:51,350
在磁盘管理器

377
00:13:51,350 --> 00:13:54,230
获取它时已停止，因此当它停止时，其他

378
00:13:54,230 --> 00:13:56,210
事务将能够在

379
00:13:56,210 --> 00:13:58,630
其他线程或同一线程上运行，以便

380
00:13:58,630 --> 00:14:01,100
该系统可以继续前进，

381
00:14:01,100 --> 00:14:02,600
即使您知道一个

382
00:14:02,600 --> 00:14:03,680
事务已停止 因为它必须

383
00:14:03,680 --> 00:14:05,300
从磁盘中获取一些东西，

384
00:14:05,300 --> 00:14:07,430
否则我们会这样做，否则如果我们一次只能执行

385
00:14:07,430 --> 00:14:08,900
一个事务并且我们在

386
00:14:08,900 --> 00:14:10,070
任何时候都需要从

387
00:14:10,070 --> 00:14:11,990
我的磁盘中获取东西时就会停止 那么系统会看起来

388
00:14:11,990 --> 00:14:13,370
没有响应，因为它会一直

389
00:14:13,370 --> 00:14:15,260
停滞不前，你知道每次

390
00:14:15,260 --> 00:14:18,200
你知道我们有一个页面未命中，所以因为

391
00:14:18,200 --> 00:14:19,400
现在我们允许其他事务

392
00:14:19,400 --> 00:14:21,350
同时运行，我们必须

393
00:14:21,350 --> 00:14:22,700
使用可能正在设置的并发协议

394
00:14:22,700 --> 00:14:25,610
锁定我们自己的记录或

395
00:14:25,610 --> 00:14:27,620
数据库中的对象，以

396
00:14:27,620 --> 00:14:29,150
确保我们为事务提供所需的资产保证

397
00:14:29,150 --> 00:14:31,790


398
00:14:31,790 --> 00:14:35,950


399
00:14:35,950 --> 00:14:39,050


400
00:14:39,050 --> 00:14:40,880


401
00:14:40,880 --> 00:14:42,800
事务

402
00:14:42,800 --> 00:14:44,900
驱逐那个页面，然后我们必须

403
00:14:44,900 --> 00:14:46,010
确保我们跟踪所有的部分

404
00:14:46,010 --> 00:14:47,690
信息，如果我们崩溃并

405
00:14:47,690 --> 00:14:49,700
回来，未提交的

406
00:14:49,700 --> 00:14:53,540
事务更改不会

407
00:14:53,540 --> 00:14:55,940
在磁盘或任何系统中持续存在，如果它使用

408
00:14:55,940 --> 00:14:57,170
锁定，它将保持 这个

409
00:14:57,170 --> 00:14:58,790
锁定信息在单独的数据

410
00:14:58,790 --> 00:15:00,740
结构中，它是

411
00:15:00,740 --> 00:15:03,980
锁定管理器中的一个内存哈希表，以

412
00:15:03,980 --> 00:15:05,390
避免锁定信息被交换

413
00:15:05,390 --> 00:15:07,220
以这种方式输出到磁盘我不必

414
00:15:07,220 --> 00:15:08,870
确定我是否甚至可以

415
00:15:08,870 --> 00:15:11,330
在元组上保持锁定来获取磁盘并

416
00:15:11,330 --> 00:15:12,709
弄清楚你知道去获取锁定

417
00:15:12,709 --> 00:15:14,480
信息所有东西总是

418
00:15:14,480 --> 00:15:18,110
会在内存中其他问题

419
00:15:18,110 --> 00:15:20,029
会有 内存系统具有日志

420
00:15:20,029 --> 00:15:23,779
恢复功能，因此大多数

421
00:15:23,779 --> 00:15:25,100
使用缓冲区文件管理器的数据库系统

422
00:15:25,100 --> 00:15:26,779
将使用不强制窃取但足球

423
00:15:26,779 --> 00:15:30,740
管理器策略，这基本上

424
00:15:30,740 --> 00:15:32,600
意味着

425
00:15:32,600 --> 00:15:34,400
事务的所有事务都与

426
00:15:34,400 --> 00:15:36,000
事务所做的所有修改相匹配

427
00:15:36,000 --> 00:15:37,379
必须添加到前面的日志中

428
00:15:37,379 --> 00:15:39,120
，并且这些条目必须

429
00:15:39,120 --> 00:15:40,980
在允许提交事务之前刷新到磁盘

430
00:15:40,980 --> 00:15:43,560
，然后

431
00:15:43,560 --> 00:15:46,139
对脏页的任何更新

432
00:15:46,139 --> 00:15:47,129
与这些更新相对应的记录定律

433
00:15:47,129 --> 00:15:48,480
在脏页可以之前重写了磁盘

434
00:15:48,480 --> 00:15:50,759
写了一个磁盘这些

435
00:15:50,759 --> 00:15:52,019
是我们在上学期的介绍

436
00:15:52,019 --> 00:15:55,319
课上讲过的所以现在内存

437
00:15:55,319 --> 00:15:57,899
系统我们不再有脏页

438
00:15:57,899 --> 00:16:00,389
所以也许我们不需要你 使用完全相同的

439
00:16:00,389 --> 00:16:03,420
协议，然后也许我们的日志

440
00:16:03,420 --> 00:16:04,709
条目不需要存储与

441
00:16:04,709 --> 00:16:06,180
我们在面向 dis 的系统中完全相同的信息，

442
00:16:06,180 --> 00:16:08,399
如果没有脏页

443
00:16:08,399 --> 00:16:10,769
必须摆脱磁盘，那么

444
00:16:10,769 --> 00:16:12,509
存储可能没有意义

445
00:16:12,509 --> 00:16:15,509
之前的图像或重做信息

446
00:16:15,509 --> 00:16:19,199
对不起交易修改的撤消信息，

447
00:16:19,199 --> 00:16:21,120
因为该

448
00:16:21,120 --> 00:16:22,500
页面永远不会脏页面永远不会

449
00:16:22,500 --> 00:16:25,529
被写入所以

450
00:16:25,529 --> 00:16:27,629
我们必须在暴政系统中做很多额外的事情，这些

451
00:16:27,629 --> 00:16:29,519
事情可能没有意义 不再

452
00:16:29,519 --> 00:16:32,339
在金刚砂系统中，例如

453
00:16:32,339 --> 00:16:35,759
再次跟踪日志序列号再次

454
00:16:35,759 --> 00:16:38,100
维护撤消信息，

455
00:16:38,100 --> 00:16:40,379
因为再次脏页不会

456
00:16:40,379 --> 00:16:41,370
删除磁盘，因为一切

457
00:16:41,370 --> 00:16:44,430
都适合内存，以便让其他人

458
00:16:44,430 --> 00:16:45,509
更好地了解这种

459
00:16:45,509 --> 00:16:47,519
开销是什么 实际上会有

460
00:16:47,519 --> 00:16:51,509
一项在麻省理工学院完成的研究，实际上是在

461
00:16:51,509 --> 00:16:53,819
2008 年 10 多年前，他们

462
00:16:53,819 --> 00:16:56,120
采用了一个旧的电视数据库系统，并进行了

463
00:16:56,120 --> 00:16:58,709
检测，以便他们可以

464
00:16:58,709 --> 00:17:00,930
测量我的数字 当您运行 TPCC 时，

465
00:17:00,930 --> 00:17:02,670
数据系统

466
00:17:02,670 --> 00:17:04,980
在当前查询执行的不同部分花费的

467
00:17:04,980 --> 00:17:07,559
指令，这里的想法

468
00:17:07,559 --> 00:17:09,720
是将系统分解为

469
00:17:09,720 --> 00:17:11,520
不同的组件，就像我所说

470
00:17:11,520 --> 00:17:13,349
的那样，再次测量

471
00:17:13,349 --> 00:17:15,869
我们花费了多少时间 他们每个人都可以，

472
00:17:15,869 --> 00:17:17,669
这是针对所有内容都

473
00:17:17,669 --> 00:17:19,740
适合内存的数据库，没有任何理由

474
00:17:19,740 --> 00:17:20,939
在内存中写入任何内容都不会刷新到

475
00:17:20,939 --> 00:17:22,140
磁盘，并且前面的日志这就是

476
00:17:22,140 --> 00:17:23,760


477
00:17:23,760 --> 00:17:25,740
使用磁盘访问内存中的数据的成本

478
00:17:25,740 --> 00:17:28,140
面向架构，所以第一个

479
00:17:28,140 --> 00:17:30,480
开销是在可感知的管理器

480
00:17:30,480 --> 00:17:31,679
中，大约 34% 的 CPU

481
00:17:31,679 --> 00:17:33,659
指令用于更新或

482
00:17:33,659 --> 00:17:34,950
查找页表进行

483
00:17:34,950 --> 00:17:37,770
更新 您跟踪

484
00:17:37,770 --> 00:17:39,570
所有用于驱逐策略的元数据

485
00:17:39,570 --> 00:17:43,230
14% 的时间 花在

486
00:17:43,230 --> 00:17:44,970
锁存上的时间可能是用于

487
00:17:44,970 --> 00:17:46,380
内部数据结构，例如

488
00:17:46,380 --> 00:17:49,049
带有锁管理器的页表，

489
00:17:49,049 --> 00:17:50,040
只要你知道

490
00:17:50,040 --> 00:17:51,510
我们需要的低级构造函数

491
00:17:51,510 --> 00:17:54,990
保护 16% 的指令

492
00:17:54,990 --> 00:17:57,990
用在锁定上，所以这个特定的

493
00:17:57,990 --> 00:18:00,600
系统被称为肯定并使用

494
00:18:00,600 --> 00:18:02,070
两阶段锁定，所以这是在

495
00:18:02,070 --> 00:18:03,600


496
00:18:03,600 --> 00:18:04,980
事务运行时更新锁定信息的开销

497
00:18:04,980 --> 00:18:08,700
12% 的

498
00:18:08,700 --> 00:18:10,590
指令用在日志管理器中 所以这

499
00:18:10,590 --> 00:18:11,760
不是耗尽磁盘

500
00:18:11,760 --> 00:18:13,350
的成本，这是准备

501
00:18:13,350 --> 00:18:15,560
我们将要写出的记录法则的成本，

502
00:18:15,560 --> 00:18:18,660
然后 16% 的时间用于

503
00:18:18,660 --> 00:18:22,290
比较

504
00:18:22,290 --> 00:18:24,330
在 B+ 树中进行遍历的键，但是这个

505
00:18:24,330 --> 00:18:25,890
这是不可避免的，这只是说

506
00:18:25,890 --> 00:18:27,090
你知道如果我试图

507
00:18:27,090 --> 00:18:28,230
通过 D 加树找到我想要的记录，

508
00:18:28,230 --> 00:18:30,260
这是比较密钥的成本，

509
00:18:30,260 --> 00:18:32,610
所以现在这将给我们留下

510
00:18:32,610 --> 00:18:35,160
微不足道的 7% 的 CP 指令我们

511
00:18:35,160 --> 00:18:37,290
实际上正在做他们所谓的

512
00:18:37,290 --> 00:18:40,860
实际工作，例如执行

513
00:18:40,860 --> 00:18:43,730
获取数据的事务逻辑

514
00:18:43,730 --> 00:18:46,410
，然后执行您知道的执行

515
00:18:46,410 --> 00:18:47,550
提交操作之类的事情，

516
00:18:47,550 --> 00:18:49,710
所以这又是 向您展示

517
00:18:49,710 --> 00:18:50,970
，如果您使用磁盘学习系统

518
00:18:50,970 --> 00:18:52,860
并为其提供所需的所有内存，

519
00:18:52,860 --> 00:18:54,270
以便所有内容都

520
00:18:54,270 --> 00:18:56,040
适合内存，您将无法获得

521
00:18:56,040 --> 00:18:57,540
最佳性能，因为

522
00:18:57,540 --> 00:18:59,640
您仍然知道所有内容

523
00:18:59,640 --> 00:19:01,320
仍然会受到惩罚 对于所有

524
00:19:01,320 --> 00:19:03,840
假设

525
00:19:03,840 --> 00:19:05,190
数据不在磁盘上的内部架构，并且存在

526
00:19:05,190 --> 00:19:07,020
针对该假设的所有保护机制

527
00:19:07,020 --> 00:19:08,760
，而实际上并不是

528
00:19:08,760 --> 00:19:11,330
必需的，

529
00:19:11,500 --> 00:19:15,429
因此今天早些时候我平板电脑上的电池

530
00:19:15,429 --> 00:19:17,559
在我在外面录制时关闭了

531
00:19:17,559 --> 00:19:20,710
它变得太冷了，一切

532
00:19:20,710 --> 00:19:23,110
只是整个关闭的事情我

533
00:19:23,110 --> 00:19:25,480
就像华氏 20 度，这就像

534
00:19:25,480 --> 00:19:28,929
负 7 摄氏度左右，

535
00:19:28,929 --> 00:19:31,149
所以这有点奇怪，所以回到这个

536
00:19:31,149 --> 00:19:35,950
奇怪的德国黄金剥夺室里

537
00:19:35,950 --> 00:19:38,440
，他们又来了，

538
00:19:38,440 --> 00:19:39,789
后来又进来了 并

539
00:19:39,789 --> 00:19:41,799
深入思考数据库并

540
00:19:41,799 --> 00:19:43,029
以某种方式成为像德国人一样更好的程序员

541
00:19:43,029 --> 00:19:45,070
我不知道这是否

542
00:19:45,070 --> 00:19:46,990
行得通所以让我们继续w 在

543
00:19:46,990 --> 00:19:51,009
讲座中，我们刚才停下来的地方

544
00:19:51,009 --> 00:19:53,080
是我们在谈论

545
00:19:53,080 --> 00:19:56,769
Discordian 系统的情况，因为

546
00:19:56,769 --> 00:19:58,480
他们假设

547
00:19:58,480 --> 00:19:59,799
首相教育戴维斯

548
00:19:59,799 --> 00:20:01,000
可以在磁盘上有所有这些

549
00:20:01,000 --> 00:20:05,620
架构，以便您随时知道 当

550
00:20:05,620 --> 00:20:07,629
你读到一些东西时，你必须去

551
00:20:07,629 --> 00:20:08,799
检查它是否在磁盘上，如果

552
00:20:08,799 --> 00:20:10,509
不是，你可以安装那个线程并做

553
00:20:10,509 --> 00:20:12,610
其他事情，所以现在我们要

554
00:20:12,610 --> 00:20:13,809
切换并讨论内存

555
00:20:13,809 --> 00:20:16,779
数据库系统，所以这是一个

556
00:20:16,779 --> 00:20:19,929
系统将

557
00:20:19,929 --> 00:20:21,460
放大主要搜索位置

558
00:20:21,460 --> 00:20:23,980
将高于所有数据库的位置

559
00:20:23,980 --> 00:20:25,779
将始终永久保存在内存中，因此

560
00:20:25,779 --> 00:20:27,340
这意味着任何时候

561
00:20:27,340 --> 00:20:29,769
事务或查询读取

562
00:20:29,769 --> 00:20:31,929
元组时都可以假设 东西

563
00:20:31,929 --> 00:20:33,730
将在内存中，因此它

564
00:20:33,730 --> 00:20:35,980
不必遍历所有页

565
00:20:35,980 --> 00:20:38,289
表和水牛并检查

566
00:20:38,289 --> 00:20:39,669
任何东西都会去读取它

567
00:20:39,669 --> 00:20:42,929
想要的任何东西或写入它想要的任何东西所以

568
00:20:42,929 --> 00:20:45,250
它不是说

569
00:20:45,250 --> 00:20:46,840
本学期我们要讨论的所有内容都

570
00:20:46,840 --> 00:20:48,429
将仅针对内存数据库，

571
00:20:48,429 --> 00:20:50,200
但我们将看到我们将如何做出某些

572
00:20:50,200 --> 00:20:51,639
设计决策，

573
00:20:51,639 --> 00:20:54,129
如果我们做出这个假设，这将使我们的生活更轻松

574
00:20:54,129 --> 00:20:57,730


575
00:20:57,730 --> 00:20:59,950
内存数据库的这种想法并不

576
00:20:59,950 --> 00:21:02,379
新鲜，第一个提议的系统可以

577
00:21:02,379 --> 00:21:05,799
追溯到 1980 年代，但

578
00:21:05,799 --> 00:21:08,740
现在也许在过去 10 年里它们并不是你真正知道的可行选择，

579
00:21:08,740 --> 00:21:10,870
因为它已经到了

580
00:21:10,870 --> 00:21:11,980
价格和容量都很贵的地步

581
00:21:11,980 --> 00:21:15,159
是这样的，你知道我们可以

582
00:21:15,159 --> 00:21:18,299
在内存中存储非常大的数据库，

583
00:21:18,299 --> 00:21:21,220
所以你知道

584
00:21:21,220 --> 00:21:22,899
在 1980 年代提出了最初的想法，我们将在进行时讨论

585
00:21:22,899 --> 00:21:24,390
一下，

586
00:21:24,390 --> 00:21:27,070
但第一个商业美国

587
00:21:27,070 --> 00:21:28,420
数据库确实没有出现

588
00:21:28,420 --> 00:21:31,540
像 1990 年代，最著名的三个

589
00:21:31,540 --> 00:21:34,090
可能是 10 倍，这实际上

590
00:21:34,090 --> 00:21:36,160
最初称为小基地，然后

591
00:21:36,160 --> 00:21:38,650
它们从 HP 分叉出来，变成了

592
00:21:38,650 --> 00:21:42,810
10 倍，然后甲骨文购买了它们，

593
00:21:42,810 --> 00:21:46,300
大概在 2006 年左右，数据闪电战

594
00:21:46,300 --> 00:21:49,150
是 B 级系统 1990 年代的 ell Labs 1880

595
00:21:49,150 --> 00:21:52,360
它被紧急称为 dolly 它被出售

596
00:21:52,360 --> 00:21:53,560
用于像电信交换机之类的东西

597
00:21:53,560 --> 00:21:55,300
我认为它今天仍然

598
00:21:55,300 --> 00:21:56,860
存在，或者如果它是

599
00:21:56,860 --> 00:21:58,750
它显然处于传统模式并且

600
00:21:58,750 --> 00:22:01,480
Alta 基地是一个 韩国 这

601
00:22:01,480 --> 00:22:03,040
是这些早期的初学者之一 他

602
00:22:03,040 --> 00:22:04,450
每天都在做生意的早期游戏 这实际上

603
00:22:04,450 --> 00:22:05,890
今天仍然存在而且实际上

604
00:22:05,890 --> 00:22:07,270
在过去的两三年内他们是

605
00:22:07,270 --> 00:22:09,130
开源的 它是你可以去 github 中检查它

606
00:22:09,130 --> 00:22:13,750
所以即使和

607
00:22:13,750 --> 00:22:15,220
既然 Davis 将完全

608
00:22:15,220 --> 00:22:18,370
命名为内存，我们仍然会将

609
00:22:18,370 --> 00:22:22,150
数据组织成块，并且页面不会

610
00:22:22,150 --> 00:22:23,890
在页面上插入，因为我们不知道

611
00:22:23,890 --> 00:22:25,300
页面本身内部的间接性是什么意思

612
00:22:25,300 --> 00:22:29,050
，因此系统架构

613
00:22:29,050 --> 00:22:30,250
会稍微有点 现在不同了，因为

614
00:22:30,250 --> 00:22:32,470
现在我们

615
00:22:32,470 --> 00:22:36,070
可以处理直接内存

616
00:22:36,070 --> 00:22:37,600
指针而不是处理这些记录 ID，如果我们与基于磁盘的系统略有不同，我们将处理固定长度

617
00:22:37,600 --> 00:22:39,040
与可变长度数据

618
00:22:39,040 --> 00:22:41,080


619
00:22:41,080 --> 00:22:42,550
的方式 bec 再次使用我们没有

620
00:22:42,550 --> 00:22:45,100
带槽的页面，虽然没有多少

621
00:22:45,100 --> 00:22:48,970
系统有这个，因为有些系统有这样

622
00:22:48,970 --> 00:22:50,350
的问题，因为现在

623
00:22:50,350 --> 00:22:52,810
所有的东西都在内存中，任何线程都可以

624
00:22:52,810 --> 00:22:55,180
读取，或者你可以在进程的地址空间中写入任何内容，

625
00:22:55,180 --> 00:22:57,730
以

626
00:22:57,730 --> 00:23:00,300
确保 我们没有让您知道

627
00:23:00,300 --> 00:23:02,920
容易出错的软件协作我们的

628
00:23:02,920 --> 00:23:05,800
数据并造成许可损坏我们可以

629
00:23:05,800 --> 00:23:07,300
在这些块的整个系统中使用校验和

630
00:23:07,300 --> 00:23:09,670
来跟踪您了解

631
00:23:09,670 --> 00:23:13,750
页面的状态并且您知道检测

632
00:23:13,750 --> 00:23:15,820
这些问题的错误 现在

633
00:23:15,820 --> 00:23:17,500
在幕后，

634
00:23:17,500 --> 00:23:19,540
操作系统和硬件也

635
00:23:19,540 --> 00:23:22,150
将把内存组织成页面，

636
00:23:22,150 --> 00:23:23,800
这

637
00:23:23,800 --> 00:23:25,990
在本学期的大部分时间里并不是我们真正关心的问题，

638
00:23:25,990 --> 00:23:28,000
我们稍后会讨论，还有

639
00:23:28,000 --> 00:23:29,560
一些讲座，因为 我们需要

640
00:23:29,560 --> 00:23:30,790
了解它实际上是如何

641
00:23:30,790 --> 00:23:32,260
布局数据的，这样当我们开始布局数据时

642
00:23:32,260 --> 00:23:34,990
，我们可以

643
00:23:34,990 --> 00:23:35,590


644
00:23:35,590 --> 00:23:37,780
与操作系统中的底层页面表示或现在的

645
00:23:37,780 --> 00:23:38,090
硬件

646
00:23:38,090 --> 00:23:42,320
是罗伯茨的对齐 我们可以忽略它，所以

647
00:23:42,320 --> 00:23:43,460
让我们再次回到我们

648
00:23:43,460 --> 00:23:44,690
的高级示例，在这里我们

649
00:23:44,690 --> 00:23:47,240
有一个查询，其中一个访问元组

650
00:23:47,240 --> 00:23:49,159
让人们通过一个索引来查找

651
00:23:49,159 --> 00:23:52,130
它，所以现在在我们的索引中而不是

652
00:23:52,130 --> 00:23:54,470
返回一个记录 ID 或

653
00:23:54,470 --> 00:23:56,570
偏移量中的页页 ID 我们现在将在偏移量中获得

654
00:23:56,570 --> 00:23:59,840
块 ID，该块 ID

655
00:23:59,840 --> 00:24:02,120
可以

656
00:24:02,120 --> 00:24:04,880
是固定长度块的直接内存地址，也

657
00:24:04,880 --> 00:24:06,169
可以有其他机制

658
00:24:06,169 --> 00:24:08,330
允许我们查找和 看到您已

659
00:24:08,330 --> 00:24:10,490
将该块 ID 转换为内存

660
00:24:10,490 --> 00:24:14,659
位置，因此主要搜索位置

661
00:24:14,659 --> 00:24:16,039
数据库再次在内存中或每个

662
00:24:16,039 --> 00:24:18,200
元组都在内存中，但我们将通过记录

663
00:24:18,200 --> 00:24:20,240
以这些固定长度组织它们

664
00:24:20,240 --> 00:24:22,610
，因此对此

665
00:24:22,610 --> 00:24:23,600
无关紧要 我们假设一个

666
00:24:23,600 --> 00:24:24,890
烤肉或一个列存储，但基本

667
00:24:24,890 --> 00:24:26,720
思想是相同的，那就是我们将

668
00:24:26,720 --> 00:24:30,520
有一组块或恢复

669
00:24:30,520 --> 00:24:33,409
元组的固定长度数据，所以

670
00:24:33,409 --> 00:24:37,070
任何像 int 日期浮动实数这样的

671
00:24:37,070 --> 00:24:38,750
东西 所有可以存储的

672
00:24:38,750 --> 00:24:42,169
都是固定长度 gth 和固定长度块

673
00:24:42,169 --> 00:24:44,240
，这意味着

674
00:24:44,240 --> 00:24:47,539
这里每个元组的大小都将相同，

675
00:24:47,539 --> 00:24:49,820
所以现在说如果我们有块 ID

676
00:24:49,820 --> 00:24:51,049
并且当我们想要查找时将其转换回内存

677
00:24:51,049 --> 00:24:52,940
地址

678
00:24:52,940 --> 00:24:54,919
该块偏移量内的元组

679
00:24:54,919 --> 00:24:57,890
我们只是做一些简单的内存

680
00:24:57,890 --> 00:25:00,500
算术，将元组的

681
00:25:00,500 --> 00:25:01,850
大小乘以我们的偏移量，然后

682
00:25:01,850 --> 00:25:03,320
告诉我们在内存中跳转到

683
00:25:03,320 --> 00:25:06,440
阻塞的位置并后悔现在处理很

684
00:25:06,440 --> 00:25:07,880
长的数据，这是

685
00:25:07,880 --> 00:25:10,580
将与我们在基于

686
00:25:10,580 --> 00:25:13,159
磁盘的系统中所做的有很大不同，因此可变长度

687
00:25:13,159 --> 00:25:14,750
数据而不是实际

688
00:25:14,750 --> 00:25:16,100
将数据存储在固定

689
00:25:16,100 --> 00:25:18,529
长度数据块中，大部分时间

690
00:25:18,529 --> 00:25:21,500
恢复点错误

691
00:25:21,500 --> 00:25:23,299
到一个非常链接的其他内存位置 数据池

692
00:25:23,299 --> 00:25:27,169
，其中直接访问与此元组中

693
00:25:27,169 --> 00:25:29,419
的 this 属性相对应的数据

694
00:25:29,419 --> 00:25:31,490
，这里的想法

695
00:25:31,490 --> 00:25:33,679
是我们可以保证

696
00:25:33,679 --> 00:25:35,059
所有元组和固定长度的数据

697
00:25:35,059 --> 00:25:36,620
块都是固定长度的 对于

698
00:25:36,620 --> 00:25:38,750
任何长度可变的内容，我们再次

699
00:25:38,750 --> 00:25:40,250
将其推入非常长的数据块中

700
00:25:40,250 --> 00:25:42,169
，这与

701
00:25:42,169 --> 00:25:44,270
您在磁盘坐标系中看到的开槽页面设计不同，

702
00:25:44,270 --> 00:25:46,220
因为在那里我们

703
00:25:46,220 --> 00:25:48,049
试图减少磁盘读取的数量，

704
00:25:48,049 --> 00:25:50,330
因此我们尝试 将您知道的元组的

705
00:25:50,330 --> 00:25:51,240
所有可变长度

706
00:25:51,240 --> 00:25:53,250
数据与

707
00:25:53,250 --> 00:25:55,430
元组本身打包在一起，所有固定长度的

708
00:25:55,430 --> 00:25:57,840
数据并不总是发生，如果它

709
00:25:57,840 --> 00:25:59,160
溢出到另一个页面，我们可以这样做，

710
00:25:59,160 --> 00:26:00,900
但大多数时候我们尝试这样做

711
00:26:00,900 --> 00:26:01,230


712
00:26:01,230 --> 00:26:03,210
发生在这个世界中，内存系统

713
00:26:03,210 --> 00:26:04,200
实际上想要单独存储可变

714
00:26:04,200 --> 00:26:05,910
长度数据，这样我们

715
00:26:05,910 --> 00:26:08,460
就可以进行确定性查找来

716
00:26:08,460 --> 00:26:11,820
找到元组的内存地址，

717
00:26:11,820 --> 00:26:12,810
其他一些更好的事情

718
00:26:12,810 --> 00:26:14,310
可能会有所不同，然后我们

719
00:26:14,310 --> 00:26:15,270
很快就讨论了 在内存

720
00:26:15,270 --> 00:26:17,130
数据库中，这些是

721
00:26:17,130 --> 00:26:18,450
我们整个学期都在谈论的事情

722
00:26:18,450 --> 00:26:20,640
，第一个是

723
00:26:20,640 --> 00:26:21,930
我们将如何实际存储索引

724
00:26:21,930 --> 00:26:23,250
我们

725
00:26:23,250 --> 00:26:25,560
将用于索引的数据结构，所以当 1980

726
00:26:25,560 --> 00:26:27,510
年代提出第一个内存数据库系统时，

727
00:26:27,510 --> 00:26:29,850
海港

728
00:26:29,850 --> 00:26:31,020
与我们

729
00:26:31,020 --> 00:26:32,730
今天所了解的硬件或今天海港的

730
00:26:32,730 --> 00:26:34,950
布局有很大不同，特别是当时

731
00:26:34,950 --> 00:26:37,350
缓存和内存访问节拍

732
00:26:37,350 --> 00:26:40,140
大致相同，但现在情况并非如此

733
00:26:40,140 --> 00:26:42,900
，CPU 缓存比

734
00:26:42,900 --> 00:26:45,720
主内存访问快得多，所以当时人们

735
00:26:45,720 --> 00:26:48,180
正在设计数据结构，您是否

736
00:26:48,180 --> 00:26:50,220
知道从缓存中读取与

737
00:26:50,220 --> 00:26:52,440
读取内存相同 所以他们会

738
00:26:52,440 --> 00:26:55,140
以某种方式组织，但现在在

739
00:26:55,140 --> 00:26:56,640
现代我们不想这样做，

740
00:26:56,640 --> 00:26:59,010
所以我们想要使用

741
00:26:59,010 --> 00:27:00,480
知道他们正在处理内存

742
00:27:00,480 --> 00:27:01,710
并且他们有缓存的索引并

743
00:27:01,710 --> 00:27:03,750
尝试最小化 当他访问事物时缓存未命中，

744
00:27:03,750 --> 00:27:06,180
因此剧透

745
00:27:06,180 --> 00:27:08,760
将是 B+ 树

746
00:27:08,760 --> 00:27:13,680
将成为每天用于名称的最佳数据结构，

747
00:27:13,680 --> 00:27:15,060
但即使

748
00:27:15,060 --> 00:27:16,770
d-plus 树最初是

749
00:27:16,770 --> 00:27:19,740
为磁盘库设计的 d 数据库它们

750
00:27:19,740 --> 00:27:20,910
实际上仍然非常适合内存

751
00:27:20,910 --> 00:27:24,300
数据，因此

752
00:27:24,300 --> 00:27:25,650
我们

753
00:27:25,650 --> 00:27:28,410
将拥有索引的差异之间的另一个主要想法是，在基于磁盘

754
00:27:28,410 --> 00:27:30,750
的系统中，您还将

755
00:27:30,750 --> 00:27:33,060
写入日志记录并为

756
00:27:33,060 --> 00:27:34,740
索引磁盘，以便您可以

757
00:27:34,740 --> 00:27:37,650
在系统重新启动内存

758
00:27:37,650 --> 00:27:39,480
系统后恢复它们我们实际上不会

759
00:27:39,480 --> 00:27:41,040
记录任何低记录，

760
00:27:41,040 --> 00:27:43,010
因为大多数系统不会将索引写入磁盘，

761
00:27:43,010 --> 00:27:45,840
因为重新启动系统后重建索引的成本

762
00:27:45,840 --> 00:27:48,570


763
00:27:48,570 --> 00:27:51,450


764
00:27:51,450 --> 00:27:53,460
当系统和速率是当我

765
00:27:53,460 --> 00:27:55,800
重新启动时我必须将数据库

766
00:27:55,800 --> 00:27:57,660
完全带回主内存，因此

767
00:27:57,660 --> 00:27:59,730


768
00:27:59,730 --> 00:28:01,590
从磁盘读取数据的成本非常昂贵，

769
00:28:01,590 --> 00:28:03,820
而

770
00:28:03,820 --> 00:28:05,560
一旦数据已经在

771
00:28:05,560 --> 00:28:09,070
内存中，构建索引的成本是否便宜，因为它

772
00:28:09,070 --> 00:28:12,220
只是 CPU 计算，因此

773
00:28:12,220 --> 00:28:14,470
，并避免必须将记录

774
00:28:14,470 --> 00:28:18,430
记录到日志更新到记录到

775
00:28:18,430 --> 00:28:20,590
th  e 在运行时更新索引

776
00:28:20,590 --> 00:28:22,330
或只是减慢我们的速度

777
00:28:22,330 --> 00:28:25,030
我们只是在重新启动后重建索引

778
00:28:25,030 --> 00:28:27,160
我们将涵盖这一点并清理

779
00:28:27,160 --> 00:28:28,120
它的更多细节 现在当我们

780
00:28:28,120 --> 00:28:32,800
再次讨论用于查询处理的索引时

781
00:28:32,800 --> 00:28:35,290
在令人失望的系统磁盘中 i/

782
00:28:35,290 --> 00:28:37,690
o 总是最昂贵的东西，它

783
00:28:37,690 --> 00:28:39,880
在乎你

784
00:28:39,880 --> 00:28:41,800
如何计算数据，或者你知道

785
00:28:41,800 --> 00:28:43,450
一旦数据

786
00:28:43,450 --> 00:28:47,020
在内存中的组织访问，那么在磁盘婚礼系统或

787
00:28:47,020 --> 00:28:48,760
内存系统中 我们现在会

788
00:28:48,760 --> 00:28:51,040
关心执行函数

789
00:28:51,040 --> 00:28:52,420
调用和诸如此类的分支的开销

790
00:28:52,420 --> 00:28:54,130
，因此您需要更加关心我们如何

791
00:28:54,130 --> 00:28:56,170
组织系统和执行查询

792
00:28:56,170 --> 00:28:59,410
处理顺序扫描在内存系统中也没有

793
00:28:59,410 --> 00:29:02,140
明显更快，

794
00:29:02,140 --> 00:29:03,820
所以也许有一定的

795
00:29:03,820 --> 00:29:06,670
算法并且您知道

796
00:29:06,670 --> 00:29:08,560
用于执行连接和其他操作的连接连接方法

797
00:29:08,560 --> 00:29:11,980
，我们不必

798
00:29:11,980 --> 00:29:14,800
担心优化或最大化

799
00:29:14,800 --> 00:29:16,660
计划访问，因为随机访问

800
00:29:16,660 --> 00:29:18,700
就足够了 再次，

801
00:29:18,700 --> 00:29:20,790
我们将在继续进行日志记录和恢复时更详细地介绍这一点

802
00:29:20,790 --> 00:29:23,320
我之前已经提到过

803
00:29:23,320 --> 00:29:25,450
这一点，但是现在

804
00:29:25,450 --> 00:29:27,520
所有内容都在内存中，没有

805
00:29:27,520 --> 00:29:30,250
脏页可以清除磁盘，我们

806
00:29:30,250 --> 00:29:34,120
可以更加保守，或者我们可以

807
00:29:34,120 --> 00:29:36,760
最终记录的数据少于我们需要的数据，

808
00:29:36,760 --> 00:29:37,840


809
00:29:37,840 --> 00:29:39,730
如果我们知道所有东西都

810
00:29:39,730 --> 00:29:42,760
在内存中，那么我们通常需要一个磁盘或新系统，所以像 root Camp 这样的标准技术

811
00:29:42,760 --> 00:29:44,080
我们将使用一批日志

812
00:29:44,080 --> 00:29:47,470
摊销 FSN 原因这

813
00:29:47,470 --> 00:29:48,880
适用于磁盘 警告系统也是如此，

814
00:29:48,880 --> 00:29:51,820
但能够使用更轻量级的

815
00:29:51,820 --> 00:29:54,610
日志记录方案对于内存系统来说是一个明确的优势

816
00:29:54,610 --> 00:29:56,920
，因为

817
00:29:56,920 --> 00:29:58,750
同样没有脏页，我们

818
00:29:58,750 --> 00:30:00,610
不需要做任何我们写到

819
00:30:00,610 --> 00:30:02,770
磁盘的操作作为检查点的一部分将要撤销

820
00:30:02,770 --> 00:30:03,940


821
00:30:03,940 --> 00:30:08,560
在大多数情况下成为提交事务的一方，所以现在

822
00:30:08,560 --> 00:30:12,310
如果磁盘 I/O 不是最慢的资源，

823
00:30:12,310 --> 00:30:15,310
那么我们可以改变

824
00:30:15,310 --> 00:30:17,680
，我们改变使用该过程的协议、

825
00:30:17,680 --> 00:30:19,600
方法和算法的类型

826
00:30:19,600 --> 00:30:21,160


827
00:30:21,160 --> 00:30:23,650
数据库系统中的查询和事务现在我们可以

828
00:30:23,650 --> 00:30:24,970
注意现在

829
00:30:24,970 --> 00:30:26,140
将成为最前沿的其他瓶颈，因为

830
00:30:26,140 --> 00:30:28,390
磁盘 i/o 不再处于关键

831
00:30:28,390 --> 00:30:30,550
路径，所以这基本上是

832
00:30:30,550 --> 00:30:32,530
整个学期关于如何处理的

833
00:30:32,530 --> 00:30:34,060
当我们设计数据库系统时，还有这些其他问题，

834
00:30:34,060 --> 00:30:36,670
因此锁定闩锁和

835
00:30:36,670 --> 00:30:38,200
Sorkin 内核方法以及

836
00:30:38,200 --> 00:30:39,880
保护这些数据结构的单独低级原语

837
00:30:39,880 --> 00:30:43,690
缓存母狮是大

838
00:30:43,690 --> 00:30:46,030
问题 因为内存访问与缓存

839
00:30:46,030 --> 00:30:48,300
访问相比是更昂贵的

840
00:30:48,300 --> 00:30:50,770
追逐指针跳转到

841
00:30:50,770 --> 00:30:52,900
内存中的随机位置，它会导致

842
00:30:52,900 --> 00:30:54,780
更多的缓存未命中，这是有问题的

843
00:30:54,780 --> 00:30:57,430
评估谓词你知道吗？

844
00:30:57,430 --> 00:30:58,930
为每一个十亿元组采用 where 子句

845
00:30:58,930 --> 00:31:00,850
并评估它，这将是

846
00:31:00,850 --> 00:31:05,020
昂贵的移动数据或复制数据，因此

847
00:31:05,020 --> 00:31:06,670
如果我必须移动数据移动将是

848
00:31:06,670 --> 00:31:08,980
数据从一个 sock CPU 插槽到

849
00:31:08,980 --> 00:31:11,280
另一个昂贵的复制数据将

850
00:31:11,280 --> 00:31:13,750
实现中间结果

851
00:31:13,750 --> 00:31:15,550
或复制数据 之间传递

852
00:31:15,550 --> 00:31:17,350
的东西的套接字是我们

853
00:31:17,350 --> 00:31:19,360
想要避免的事情，当然网络

854
00:31:19,360 --> 00:31:22,630
始终是一个大问题，现在

855
00:31:22,630 --> 00:31:24,580
主要存在于应用程序

856
00:31:24,580 --> 00:31:26,250
和数据库系统之间，而不是在

857
00:31:26,250 --> 00:31:30,000
同一数据库的不同节点之间，这

858
00:31:30,000 --> 00:31:32,050
是一个不一致的系统 - 但

859
00:31:32,050 --> 00:31:35,650
再次 现在磁盘不见了，这

860
00:31:35,650 --> 00:31:37,150
是一个更成问题

861
00:31:37,150 --> 00:31:39,580
的内存系统，所以在本讲座的其余部分，

862
00:31:39,580 --> 00:31:41,230
我想讨论锁定和

863
00:31:41,230 --> 00:31:43,240
闩锁，所以我们将重点关注

864
00:31:43,240 --> 00:31:44,500
这里的墨盒孔，这

865
00:31:44,500 --> 00:31:47,140
主要是为了 让我们了解前进的

866
00:31:47,140 --> 00:31:50,410
方向，你知道

867
00:31:50,410 --> 00:31:53,200
如何思考，就是这样，你知道

868
00:31:53,200 --> 00:31:55,680
是什么让游戏系统变慢，

869
00:31:55,680 --> 00:31:58,210
当我们开始扩展更多的 CPU

870
00:31:58,210 --> 00:31:58,570
内核时

871
00:31:58,570 --> 00:31:59,860
，这些其他瓶颈

872
00:31:59,860 --> 00:32:03,160
和问题意味着什么

873
00:32:03,160 --> 00:32:04,360
再次像我们在

874
00:32:04,360 --> 00:32:05,920
介绍类并发中介绍的那样，您的目标

875
00:32:05,920 --> 00:32:08,560
本质上是

876
00:32:08,560 --> 00:32:10,570
神使用的协议，允许它

877
00:32:10,570 --> 00:32:12,130
同时执行多个事务

878
00:32:12,130 --> 00:32:14,650
时间和每个这些事务

879
00:32:14,650 --> 00:32:16,690
都会有一种错觉

880
00:32:16,690 --> 00:32:19,600
，认为它们是由它们自己在系统上执行

881
00:32:19,600 --> 00:32:21,640
的，因此它们不必

882
00:32:21,640 --> 00:32:23,710
担心同时读取或读取

883
00:32:23,710 --> 00:32:25,030
其他事务的影响

884
00:32:25,030 --> 00:32:27,820
这基本上是

885
00:32:27,820 --> 00:32:29,049
您希望在您的系统中实现的目标，

886
00:32:29,049 --> 00:32:31,299
因为这是对

887
00:32:31,299 --> 00:32:34,629
您的应用程序进行编程的最简单方法，当然现在

888
00:32:34,629 --> 00:32:35,769
这并不容易，如果开始

889
00:32:35,769 --> 00:32:37,629


890
00:32:37,629 --> 00:32:39,220
在不同事务之间进行交织操作，您可能会

891
00:32:39,220 --> 00:32:43,299
违反此顺序，因此

892
00:32:43,299 --> 00:32:44,919
任何 kikuchiyo 协议 数据库系统将

893
00:32:44,919 --> 00:32:46,720


894
00:32:46,720 --> 00:32:52,259
在此 SSN 首字母缩略词中提供原子性和隔离性保证，因此

895
00:32:52,259 --> 00:32:55,330
对于 mme 数据库系统，

896
00:32:55,330 --> 00:32:56,860
我们必须对

897
00:32:56,860 --> 00:32:59,409
如何获取锁以

898
00:32:59,409 --> 00:33:03,519
访问极点进行关键观察，这就是

899
00:33:03,519 --> 00:33:04,989
事务的成本 获取锁

900
00:33:04,989 --> 00:33:06,399
与访问数据本质上是一样的，

901
00:33:06,399 --> 00:33:09,369
所以我的意思

902
00:33:09,369 --> 00:33:12,369
是在磁盘加载系统中我们

903
00:33:12,369 --> 00:33:14,019
说所有的锁都可以 ld以

904
00:33:14,019 --> 00:33:15,309
某种数据结构存储在内存中，

905
00:33:15,309 --> 00:33:18,070
并且它们将与

906
00:33:18,070 --> 00:33:19,149
实际元组分开，但现在

907
00:33:19,149 --> 00:33:21,549
所有内容都在内存中，那么理想情况下

908
00:33:21,549 --> 00:33:24,009
访问和访问锁表的成本将与访问

909
00:33:24,009 --> 00:33:26,320


910
00:33:26,320 --> 00:33:29,139
元组相同 我希望能够同时执行

911
00:33:29,139 --> 00:33:31,929
这些操作，这样我就不会

912
00:33:31,929 --> 00:33:34,090
因为执行两次内存读取而付出代价，

913
00:33:34,090 --> 00:33:36,700
这是

914
00:33:36,700 --> 00:33:39,700
家具尝试安装的核心思想，当我们

915
00:33:39,700 --> 00:33:42,419
在内存中进行数据系统并发控制时

916
00:33:42,419 --> 00:33:44,409
，其他重要的 还要

917
00:33:44,409 --> 00:33:47,679
理解的是，在磁盘运行系统中，

918
00:33:47,679 --> 00:33:50,649
停顿是由于事务试图

919
00:33:50,649 --> 00:33:52,059
访问不是内存的数据，您必须

920
00:33:52,059 --> 00:33:54,190
转到磁盘并获取它们，但

921
00:33:54,190 --> 00:33:55,359
现在我们不会再有这种

922
00:33:55,359 --> 00:33:57,549
停顿了 是的，是的，我会是内存

923
00:33:57,549 --> 00:34:00,549
停滞，但这些会

924
00:34:00,549 --> 00:34:03,759
比你所知道的要少得多，只是偷来的，但

925
00:34:03,759 --> 00:34:05,919
你认为我们会有的或者

926
00:34:05,919 --> 00:34:08,109
早期的助手没有的是

927
00:34:08,109 --> 00:34:11,440
更多的核心，所以现在争论

928
00:34:11,440 --> 00:34:14,530
正在进行中 在 sy 许多

929
00:34:14,530 --> 00:34:16,030
事务试图同时读取和

930
00:34:16,030 --> 00:34:17,980
写入相同的对象，并且

931
00:34:17,980 --> 00:34:20,649
它们没有停止，因为那里有一个

932
00:34:20,649 --> 00:34:22,449
磁盘被盗，因为它们没有我们

933
00:34:22,449 --> 00:34:23,589
无法获得某些东西的锁，

934
00:34:23,589 --> 00:34:28,750
所以你又明白了

935
00:34:28,750 --> 00:34:29,980
我们实际上将能够

936
00:34:29,980 --> 00:34:31,299
维护锁定信息以及

937
00:34:31,299 --> 00:34:35,799
我们理解的这种

938
00:34:35,799 --> 00:34:37,389
基本比较和交换原语的元组，我们

939
00:34:37,389 --> 00:34:40,119
将使用它来修改事物，因此我们

940
00:34:40,119 --> 00:34:42,880
不会使用互斥锁保护元组，

941
00:34:42,880 --> 00:34:44,949
因为 相反，

942
00:34:44,949 --> 00:34:46,449
我们将使用这些

943
00:34:46,449 --> 00:34:47,320
称为比较和交换的原子操作会太慢，

944
00:34:47,320 --> 00:34:50,080
所以我认为这主要

945
00:34:50,080 --> 00:34:52,210
在其他类中涵盖，所以我

946
00:34:52,210 --> 00:34:54,310
只想快速概述它是什么，

947
00:34:54,310 --> 00:34:55,810
因为这将

948
00:34:55,810 --> 00:34:58,570
在整个学期

949
00:34:58,570 --> 00:35:01,150
中多次出现，一次看到我们并没有

950
00:35:01,150 --> 00:35:02,410
真正详细说明这是如何

951
00:35:02,410 --> 00:35:04,300
实现的硬件只是知道

952
00:35:04,300 --> 00:35:07,810
这个概念但实际上存在所以

953
00:35:07,810 --> 00:35:10,360
比较交换是一个原子

954
00:35:10,360 --> 00:35:13,630
指令 几乎每个现代 CPU 都会

955
00:35:13,630 --> 00:35:16,390
为您提供这不是一个新概念我

956
00:35:16,390 --> 00:35:18,880
认为它可以追溯到 1970 年代可能

957
00:35:18,880 --> 00:35:20,800
几乎每个 Zeon arm 架构

958
00:35:20,800 --> 00:35:23,770
或 PowerPC 现在都会给我

959
00:35:23,770 --> 00:35:25,180
这个想法是它是

960
00:35:25,180 --> 00:35:26,740
一条指令

961
00:35:26,740 --> 00:35:29,320
在内存位置中查找，它会检查

962
00:35:29,320 --> 00:35:31,240
该内存位置在哪里具有提供的

963
00:35:31,240 --> 00:35:34,180
特定值，然后如果

964
00:35:34,180 --> 00:35:36,760
该值相等，那么元是一个

965
00:35:36,760 --> 00:35:38,200
值，该内存位置

966
00:35:38,200 --> 00:35:40,270
等于您正在检查的值，那么

967
00:35:40,270 --> 00:35:42,850
您 ' 允许安装一个新值来

968
00:35:42,850 --> 00:35:46,000
更新它，否则操作会失败

969
00:35:46,000 --> 00:35:48,280
，所以在这个例子中这个

970
00:35:48,280 --> 00:35:50,110
下划线下划线接收池比较

971
00:35:50,110 --> 00:35:54,640
交换这是一个 C++ 或 Linux

972
00:35:54,640 --> 00:35:59,530
Lib C 或 Lennox 你看到两个缺陷

973
00:35:59,530 --> 00:36:02,050
操作或内在不同

974
00:36:02,050 --> 00:36:03,340
平台有不同的东西，我

975
00:36:03,340 --> 00:36:05,920
认为在现代系统中的大多数情况下，

976
00:36:05,920 --> 00:36:08,440
要么是

977
00:36:08,440 --> 00:36:12,220
理解，要么是内在

978
00:36:12,220 --> 00:36:14,980
函数可以做同样的事情，爸爸

979
00:36:14,980 --> 00:36:16,360
是我们放弃了我 na 内存

980
00:36:16,360 --> 00:36:16,600
地址

981
00:36:16,600 --> 00:36:18,370
我们给它一个比较值和一个

982
00:36:18,370 --> 00:36:20,730
新值，所以 M 指向的当前内存地址

983
00:36:20,730 --> 00:36:23,620
包含值 20

984
00:36:23,620 --> 00:36:25,990
所以在一条指令中，现在我们

985
00:36:25,990 --> 00:36:28,660
要看看 20 是否等于 20 在

986
00:36:28,660 --> 00:36:31,450
内存位置，如果是 一个摊位

987
00:36:31,450 --> 00:36:33,310
安装新值 30 所以在这种情况下

988
00:36:33,310 --> 00:36:35,080
在这里在一条指令

989
00:36:35,080 --> 00:36:38,650
中我们查找 M 等于 20 并且它这样

990
00:36:38,650 --> 00:36:41,110
做然后我们可以暂停 30 否则

991
00:36:41,110 --> 00:36:44,740
这会失败所以在这个

992
00:36:44,740 --> 00:36:47,980
例子中这里的函数 这里

993
00:36:47,980 --> 00:36:50,740
返回 true false 并说明

994
00:36:50,740 --> 00:36:52,840
是否成功有所有不同

995
00:36:52,840 --> 00:36:55,300
类型的比较和交换指令

996
00:36:55,300 --> 00:36:56,380
，有时它们会由

997
00:36:56,380 --> 00:36:58,479
我安装的新人

998
00:36:58,479 --> 00:36:59,829
或旧人返回，如果它没有得到

999
00:36:59,829 --> 00:37:01,839
更新，然后你 可以改变你

1000
00:37:01,839 --> 00:37:05,079
知道的内存大小，

1001
00:37:05,079 --> 00:37:07,299
你正在用 32 位或 64 位查看，

1002
00:37:07,299 --> 00:37:09,880
但同样的，基本思想

1003
00:37:09,880 --> 00:37:10,839
在单个指令中始终是相同的，

1004
00:37:10,839 --> 00:37:12,940
我们可以执行此检查，

1005
00:37:12,940 --> 00:37:14,859
这是我们合并了它们 给

1006
00:37:14,859 --> 00:37:17,289
你 整个学期都允许

1007
00:37:17,289 --> 00:37:20,829


1008
00:37:20,829 --> 00:37:25,299
非常有效地进行此类无锁或无锁操作，因此我们想

1009
00:37:25,299 --> 00:37:28,960
快速讨论一下我们将在本学期使用

1010
00:37:28,960 --> 00:37:30,999
的类似协议的类别或类的导师

1011
00:37:30,999 --> 00:37:32,799


1012
00:37:32,799 --> 00:37:35,079
，这

1013
00:37:35,079 --> 00:37:37,359
又是 对我们

1014
00:37:37,359 --> 00:37:39,489
在介绍类课程

1015
00:37:39,489 --> 00:37:42,460
Osterman 中介绍的内容进行了复习，因此第一次使用两

1016
00:37:42,460 --> 00:37:44,109
阶段锁定，因此这些是悲观的

1017
00:37:44,109 --> 00:37:45,759
方案，其中数据系统将

1018
00:37:45,759 --> 00:37:47,680
假设事务将

1019
00:37:47,680 --> 00:37:49,960
发生冲突，因此它们

1020
00:37:49,960 --> 00:37:51,460
需要对任何对象进行锁定

1021
00:37:51,460 --> 00:37:53,160
在允许访问它们之前，

1022
00:37:53,160 --> 00:37:55,450
时间戳排序是一种乐观

1023
00:37:55,450 --> 00:37:57,430
方案，您假设冲突

1024
00:37:57,430 --> 00:37:59,710
很少见，因此您不需要事务来

1025
00:37:59,710 --> 00:38:01,119
获取数据库对象上的锁，

1026
00:38:01,119 --> 00:38:02,829
而您所做的只是在

1027
00:38:02,829 --> 00:38:04,869
事务提交时查看

1028
00:38:04,869 --> 00:38:06,729
是否存在 一个冲突，

1029
00:38:06,729 --> 00:38:09,579
然后你根据需要更正它们，所以让

1030
00:38:09,579 --> 00:38:10,769
我们逐个逐一检查，

1031
00:38:10,769 --> 00:38:13,089
展示真正高水平的考试 ples

1032
00:38:13,089 --> 00:38:15,039
然后我们将进入论文讨论

1033
00:38:15,039 --> 00:38:16,210
你如何在现代系统上实际实现它，

1034
00:38:16,210 --> 00:38:19,630
所以如果有一个简单

1035
00:38:19,630 --> 00:38:21,640
的两阶段锁定示例，我们有一个

1036
00:38:21,640 --> 00:38:24,400
事务 t1 并且它想要在 a 上进行读取

1037
00:38:24,400 --> 00:38:27,460
，然后在 P 上进行一次读取 所以再次

1038
00:38:27,460 --> 00:38:29,229
一两个阶段锁定我们必须

1039
00:38:29,229 --> 00:38:31,960
获取我们

1040
00:38:31,960 --> 00:38:33,789
想要读取和写入的任何对象的锁 所以在这种情况下

1041
00:38:33,789 --> 00:38:35,019
，我们必须

1042
00:38:35,019 --> 00:38:37,839
在 B 上的后续锁上获取对锁的读取 所以这

1043
00:38:37,839 --> 00:38:39,999
是 一个非常简单的例子或简化的

1044
00:38:39,999 --> 00:38:42,729
例子，因为我知道

1045
00:38:42,729 --> 00:38:44,920
只有一种简单的锁定

1046
00:38:44,920 --> 00:38:47,979
在 a 和 B 上，但在我们上学期介绍的真实系统中，

1047
00:38:47,979 --> 00:38:51,249
你知道你

1048
00:38:51,249 --> 00:38:52,660
会有不同的锁定模式，你可以有一个

1049
00:38:52,660 --> 00:38:54,789
共享 模式多个事务

1050
00:38:54,789 --> 00:38:56,349
读取同一个对象，独占

1051
00:38:56,349 --> 00:38:58,450
模式表示只有一个事务可以

1052
00:38:58,450 --> 00:39:01,450
锁定它可以连接可以在

1053
00:39:01,450 --> 00:39:04,269
给定时间写入所以在这种情况下因为

1054
00:39:04,269 --> 00:39:06,969
两阶段锁定事务的第一部分

1055
00:39:06,969 --> 00:39:08,140
称为增长阶段

1056
00:39:08,140 --> 00:39:09,940
这就是我们所在的地方

1057
00:39:09,940 --> 00:39:14,530
获取我们需要的锁很

1058
00:39:14,530 --> 00:39:16,180
抱歉我们在事务执行期间需要

1059
00:39:16,180 --> 00:39:18,520
，然后

1060
00:39:18,520 --> 00:39:20,710
一旦我们释放一个块，现在我们

1061
00:39:20,710 --> 00:39:23,770
处于收缩阶段，我们

1062
00:39:23,770 --> 00:39:26,950
不允许获取任何新锁，但我们

1063
00:39:26,950 --> 00:39:29,800
可以这样做 对唯一对象的操作我们

1064
00:39:29,800 --> 00:39:32,170
仍然拥有所有锁定，因此

1065
00:39:32,170 --> 00:39:34,630
在像基于续集的真实系统中，

1066
00:39:34,630 --> 00:39:38,290
您实际上不会有明确的锁定

1067
00:39:38,290 --> 00:39:40,240
和解锁命令这些是

1068
00:39:40,240 --> 00:39:41,410
我们已经过时的一些灰尘，您会

1069
00:39:41,410 --> 00:39:43,200
自动在封面下

1070
00:39:43,200 --> 00:39:46,750
通常，您

1071
00:39:46,750 --> 00:39:48,100
在事务实际提交之前不会释放锁，

1072
00:39:48,100 --> 00:39:50,710
这称为严格的新

1073
00:39:50,710 --> 00:39:52,510
阶段锁定，但对于

1074
00:39:52,510 --> 00:39:53,950
本示例中的首选项，我们不会这样做，我们

1075
00:39:53,950 --> 00:39:56,350
可以解锁 a 然后文件，然后

1076
00:39:56,350 --> 00:39:58,630
在 B 和 仍然

1077
00:39:58,630 --> 00:40:01,170
遵循原始的两阶段锁定协议，

1078
00:40:01,170 --> 00:40:03,280
所以假设现在我们有

1079
00:40:03,280 --> 00:40:05,280
另一个事务 t2 出现并且

1080
00:40:05,280 --> 00:40:07,750
它想要对我不命名的父亲进行写

1081
00:40:07,750 --> 00:40:11,590
操作，所以说这些事务

1082
00:40:11,590 --> 00:40:13,030
正在运行 在

1083
00:40:13,030 --> 00:40:14,590
不同的线程上同时进行，因此

1084
00:40:14,590 --> 00:40:17,170
他们可以彼此并行执行这些操作，

1085
00:40:17,170 --> 00:40:19,870
因此在 t1 中，我们首先

1086
00:40:19,870 --> 00:40:22,240
在 t2 上获得 a 上的锁并在 B 上获得锁，

1087
00:40:22,240 --> 00:40:24,460
假设没有其他

1088
00:40:24,460 --> 00:40:26,110
事务同时写入，这很好 时间，所以

1089
00:40:26,110 --> 00:40:27,640
这两个事务都可以

1090
00:40:27,640 --> 00:40:30,160
在下一步中获取这些锁 他们的

1091
00:40:30,160 --> 00:40:31,900
事务 t1 在 a 上执行读取，这

1092
00:40:31,900 --> 00:40:33,190
是允许的，因为它持有

1093
00:40:33,190 --> 00:40:35,440
事务上的锁

1094
00:40:35,440 --> 00:40:36,700
t2 在 B 上执行正确的操作，因为它

1095
00:40:36,700 --> 00:40:39,370
持有一个 将锁排在梁上，但现在我们

1096
00:40:39,370 --> 00:40:41,770
在这里遇到了麻烦，因为 t1

1097
00:40:41,770 --> 00:40:44,320
想要在 b 上锁定 t2 一个人会在

1098
00:40:44,320 --> 00:40:46,810
a 上锁定，但是这些中的每一个都由

1099
00:40:46,810 --> 00:40:48,450
另一个事务持有，所以它们必须正确地停止

1100
00:40:48,450 --> 00:40:50,590
并且它们本质上已经在那里

1101
00:40:50,590 --> 00:40:51,700
等待另一个事务

1102
00:40:51,700 --> 00:40:53,830
放弃锁定，所以我继续前进，可以

1103
00:40:53,830 --> 00:40:55,570
取得进展，但当然我们

1104
00:40:55,570 --> 00:40:57,190
这里有一个僵局，所以现在我们

1105
00:40:57,190 --> 00:40:58,480
必须做一些事情来打破这个，

1106
00:40:58,480 --> 00:40:59,800
否则系统将永远被锁定，

1107
00:40:59,800 --> 00:41:02,700
所以有 两种方式 做

1108
00:41:02,700 --> 00:41:05,320
死锁或处理死锁，如果他

1109
00:41:05,320 --> 00:41:07,180
锁定第一个进行死锁

1110
00:41:07,180 --> 00:41:08,830
检测，这就是你有一个

1111
00:41:08,830 --> 00:41:10,210
单独的后台线程的地方，它只是

1112
00:41:10,210 --> 00:41:12,730
偶尔或定期

1113
00:41:12,730 --> 00:41:14,560
唤醒检查事务是否

1114
00:41:14,560 --> 00:41:16,600
正在运行，如果它发现一个死锁

1115
00:41:16,600 --> 00:41:18,070
然后使用一些

1116
00:41:18,070 --> 00:41:20,740
决定如何杀死它们的启发式方法 我可以说你

1117
00:41:20,740 --> 00:41:22,600
知道杀死

1118
00:41:22,600 --> 00:41:24,250
完成最少工作

1119
00:41:24,250 --> 00:41:26,170
或最老或持有最多锁

1120
00:41:26,170 --> 00:41:29,100
的事务 各种系统做各种不同的事情

1121
00:41:29,100 --> 00:41:31,630
不同的系统都有不同

1122
00:41:31,630 --> 00:41:34,320
类型的死锁 检测算法

1123
00:41:34,320 --> 00:41:36,670
死锁预防不是有

1124
00:41:36,670 --> 00:41:39,390
一个单独的线程，你只是有一种方法来

1125
00:41:39,390 --> 00:41:41,830
确保当事务尝试

1126
00:41:41,830 --> 00:41:43,840
获取锁时他们不能持有它然后

1127
00:41:43,840 --> 00:41:45,700
它决定它应

1128
00:41:45,700 --> 00:41:48,880
该做什么而不只是等待，

1129
00:41:48,880 --> 00:41:50,350
例如 如果一个事务试图

1130
00:41:50,350 --> 00:41:52,480
持有一个锁，则获取一个锁，但该锁

1131
00:41:52,480 --> 00:41:54,610
被其他人持有，您

1132
00:41:54,610 --> 00:41:56,620
可以杀死自己或杀死另一个

1133
00:41:56,620 --> 00:41:59,070
t 交易并再次窃取锁

1134
00:41:59,070 --> 00:42:01,660
我们必须确保我们

1135
00:42:01,660 --> 00:42:03,460
以正确的顺序执行操作

1136
00:42:03,460 --> 00:42:06,280
，这样你就知道

1137
00:42:06,280 --> 00:42:09,790
没有依赖循环，

1138
00:42:09,790 --> 00:42:12,490
所以另一种类型的协议

1139
00:42:12,490 --> 00:42:16,330
再次称为时间戳排序，这是

1140
00:42:16,330 --> 00:42:17,710
排序 使用

1141
00:42:17,710 --> 00:42:19,210
时间戳而不是锁来确定

1142
00:42:19,210 --> 00:42:21,160
应该允许事务完成的正确顺序的类别系统

1143
00:42:21,160 --> 00:42:25,030
的种类，因此

1144
00:42:25,030 --> 00:42:27,220
两种基本协议是基本时间戳

1145
00:42:27,220 --> 00:42:28,990
排序，这有点令人困惑，

1146
00:42:28,990 --> 00:42:31,810
因为它通常被称为

1147
00:42:31,810 --> 00:42:33,490
时间 邮票登机协议

1148
00:42:33,490 --> 00:42:35,050
属于时间戳订购协议的类别，

1149
00:42:35,050 --> 00:42:38,590
但都称其为基本的 tio

1150
00:42:38,590 --> 00:42:40,810
dis 以区分它，因此这里的想法

1151
00:42:40,810 --> 00:42:42,490
是我们将检查

1152
00:42:42,490 --> 00:42:44,440
每次读取和写入时是否存在冲突，我们只是

1153
00:42:44,440 --> 00:42:46,090
要使用 时间戳确定

1154
00:42:46,090 --> 00:42:47,800
是否存在冲突，然后

1155
00:42:47,800 --> 00:42:50,770
我们将在每个事务读取元组时将元组复制到私有

1156
00:42:50,770 --> 00:42:52,150
工作区中，

1157
00:42:52,150 --> 00:42:54,160
以确保它们是否返回并

1158
00:42:54,160 --> 00:42:55,660
读取 t 使用相同的电缆，它们获得相同的

1159
00:42:55,660 --> 00:42:57,730
值，否则您可能会

1160
00:42:57,730 --> 00:42:58,720
阅读将来编写的内容，

1161
00:42:58,720 --> 00:42:59,590
而这不应该

1162
00:42:59,590 --> 00:43:00,480
发生

1163
00:43:00,480 --> 00:43:03,280
乐观的墨盒角色

1164
00:43:03,280 --> 00:43:05,860
除了将您阅读的内容复制

1165
00:43:05,860 --> 00:43:09,850
到以前的工作空间之外，还可以

1166
00:43:09,850 --> 00:43:11,440
还会复制

1167
00:43:11,440 --> 00:43:13,180
您修改的任何元组，并且您的所有

1168
00:43:13,180 --> 00:43:14,530
权限都进入私有工作区，

1169
00:43:14,530 --> 00:43:17,170
然后当您提交时，您会

1170
00:43:17,170 --> 00:43:18,520
进行验证，以检查是否

1171
00:43:18,520 --> 00:43:20,290
存在撞击冲突，如果

1172
00:43:20,290 --> 00:43:22,210
没有，则可以合并所有私有

1173
00:43:22,210 --> 00:43:23,920
工作区更改回全局

1174
00:43:23,920 --> 00:43:26,230
数据库，因此我们将再次

1175
00:43:26,230 --> 00:43:30,640
逐个逐一检查，例如对于基本

1176
00:43:30,640 --> 00:43:31,870
时间戳警告协议，我们有一个

1177
00:43:31,870 --> 00:43:34,060
事务 t1 想要对 B 上的 a 进行读取，

1178
00:43:34,060 --> 00:43:35,980
并且有某种

1179
00:43:35,980 --> 00:43:36,430
窃取

1180
00:43:36,430 --> 00:43:39,640
并希望在交易开始时正确执行，因此当

1181
00:43:39,640 --> 00:43:41,170
交易开始时，我们必须分配

1182
00:43:41,170 --> 00:43:42,400
时间戳，因为我们将使用它

1183
00:43:42,400 --> 00:43:43,900
来确定交易的序列顺序，

1184
00:43:43,900 --> 00:43:46,359
因此有不同的

1185
00:43:46,359 --> 00:43:48,190
方案 你可以使用我可以使用

1186
00:43:48,190 --> 00:43:49,930
硬件时钟我可以使用逻辑

1187
00:43:49,930 --> 00:43:52,329
计数器我使用一个hypo来调整但为了

1188
00:43:52,329 --> 00:43:53,440
简单起见我们假设我们使用一个

1189
00:43:53,440 --> 00:43:56,230
逻辑计数器并且

1190
00:43:56,230 --> 00:43:57,309
我们每次开始交易时都更新该计数器

1191
00:43:57,309 --> 00:43:58,539
并签署

1192
00:43:58,539 --> 00:44:02,680


1193
00:44:02,680 --> 00:44:04,960
到达事务的新时间戳，所以这个事务

1194
00:44:04,960 --> 00:44:07,660
开始，它

1195
00:44:07,660 --> 00:44:10,480
现在将在数据库中为

1196
00:44:10,480 --> 00:44:11,920
我们存储的每条记录提供时间戳 10000 1 我们

1197
00:44:11,920 --> 00:44:14,529
将维护两个额外的字段，以便

1198
00:44:14,529 --> 00:44:15,940
我们维护重新计时 飞行时间中的时间戳

1199
00:44:15,940 --> 00:44:18,190
2 3 次相同将是成功读取此元组

1200
00:44:18,190 --> 00:44:19,390
的最后一个事务的最高时间戳，

1201
00:44:19,390 --> 00:44:20,799


1202
00:44:20,799 --> 00:44:22,779
而写入时间戳将是

1203
00:44:22,779 --> 00:44:24,490


1204
00:44:24,490 --> 00:44:26,680
最后一次通向此元组的道路的时间戳的最后一次 ii

1205
00:44:26,680 --> 00:44:27,970
这些时间戳

1206
00:44:27,970 --> 00:44:29,740
总是在时间上向前推进，它们

1207
00:44:29,740 --> 00:44:30,910
永远不会倒退，因为这将

1208
00:44:30,910 --> 00:44:32,710
违反交易的时间戳顺序，

1209
00:44:32,710 --> 00:44:34,839
所以我们的

1210
00:44:34,839 --> 00:44:36,400
交易开始读取鸡蛋，

1211
00:44:36,400 --> 00:44:38,289
所以 需要做的第一件事是检查

1212
00:44:38,289 --> 00:44:40,599
写入时间戳，看看它的

1213
00:44:40,599 --> 00:44:43,690
时间戳是否大于小时，这意味着

1214
00:44:43,690 --> 00:44:45,489
我们将来会尝试读取

1215
00:44:45,489 --> 00:44:46,839
我们不会读的

1216
00:44:46,839 --> 00:44:49,599
内容，在这种情况下，我允许在正确的时间阅读

1217
00:44:49,599 --> 00:44:53,019
记录 a 的时间戳是 10,000 小时

1218
00:44:53,019 --> 00:44:55,390
时间戳是 10,000 韩元，所以我们

1219
00:44:55,390 --> 00:44:57,670
允许阅读这个，所以我们现在需要更新

1220
00:44:57,670 --> 00:44:59,680
重新时间戳以检查

1221
00:44:59,680 --> 00:45:03,309
它的时间戳是否

1222
00:45:03,309 --> 00:45:05,170
小于小时，如果是，那么我们想要

1223
00:45:05,170 --> 00:45:07,029
继续更新它，所以在这种情况下

1224
00:45:07,029 --> 00:45:09,309
，我们现在将用 10,000 韩元更新它，

1225
00:45:09,309 --> 00:45:11,019
这告诉其他

1226
00:45:11,019 --> 00:45:13,630
可能想要更新此元

1227
00:45:13,630 --> 00:45:15,940
组的事务，在时间戳 10000 韩元处有一个事务

1228
00:45:15,940 --> 00:45:18,130
已读取它，因此请

1229
00:45:18,130 --> 00:45:19,569
确保 我们过去不写东西，

1230
00:45:19,569 --> 00:45:22,630
实际上错过了这些术语，

1231
00:45:22,630 --> 00:45:24,519
所以现在我们在节拍上做正确的

1232
00:45:24,519 --> 00:45:25,839
事情，首先检查以查看正确的

1233
00:45:25,839 --> 00:45:26,470
时间戳，

1234
00:45:26,470 --> 00:45:27,730
看看我们是否必须查看它是否

1235
00:45:27,730 --> 00:45:29,769
在将来 在，

1236
00:45:29,769 --> 00:45:31,269
因此我们将覆盖

1237
00:45:31,269 --> 00:45:34,450
带有过去数据的未来数据是

1238
00:45:34,450 --> 00:45:36,249
不允许的，然后我们检查读取

1239
00:45:36,249 --> 00:45:38,019
时间戳并确保将来有人没有读取

1240
00:45:38,019 --> 00:45:40,359
此记录，如果我们确实

1241
00:45:40,359 --> 00:45:41,859
写入了它，他们最终会丢失它，

1242
00:45:41,859 --> 00:45:45,039
因此在这种情况下，我们的时间 戳

1243
00:45:45,039 --> 00:45:46,720
检查

1244
00:45:46,720 --> 00:45:48,489
读取和权限，所以我们继续

1245
00:45:48,489 --> 00:45:51,220
更新我的时间戳字段，

1246
00:45:51,220 --> 00:45:53,990
然后我会说我们的交易有

1247
00:45:53,990 --> 00:45:56,060
某种停顿，就像它正在

1248
00:45:56,060 --> 00:45:58,160
计算你知道 pi 的第 10 亿

1249
00:45:58,160 --> 00:46:01,339
位数字或

1250
00:46:01,339 --> 00:46:03,260
无论出于何种原因，它都会远程访问某个根系统，因此

1251
00:46:03,260 --> 00:46:05,540
出现停顿，在此期间，另一个

1252
00:46:05,540 --> 00:46:07,609
事务出现并修改了

1253
00:46:07,609 --> 00:46:10,520
记录 a，现在

1254
00:46:10,520 --> 00:46:13,490
以一万五的正确时间戳更新，所以现在

1255
00:46:13,490 --> 00:46:15,140
我们将看到我们有一个真正的问题，

1256
00:46:15,140 --> 00:46:17,089
因为现在 当我们的事务

1257
00:46:17,089 --> 00:46:20,410
唤醒并尝试写入记录时

1258
00:46:20,410 --> 00:46:23,630
，时间戳 10000 5

1259
00:46:23,630 --> 00:46:26,390
大于我们的时间戳 10000 一所以我们

1260
00:46:26,390 --> 00:46:27,910
不应该被允许这样做，因为

1261
00:46:27,910 --> 00:46:30,790
这会试图覆盖一个

1262
00:46:30,790 --> 00:46:33,320
逻辑记录

1263
00:46:33,320 --> 00:46:36,170
将来用过去的物理记录更新，

1264
00:46:36,170 --> 00:46:38,300
所以在这种情况下，这

1265
00:46:38,300 --> 00:46:40,280
违反了时间符号环，我们的

1266
00:46:40,280 --> 00:46:41,690
事务必须被终止并加入

1267
00:46:41,690 --> 00:46:46,310
它，我们回滚任何更改，因此

1268
00:46:46,310 --> 00:46:48,800
那里的大多数系统都不会 做

1269
00:46:48,800 --> 00:46:50,720
基本的时间戳学习协议

1270
00:46:50,720 --> 00:46:53,500
更常见的方法是

1271
00:46:53,500 --> 00:46:56,060
再次对整个盒式磁带进行 OCC 乐观 这

1272
00:46:56,060 --> 00:47:00,380
很令人困惑，因为时间戳排序

1273
00:47:00,380 --> 00:47:02,540
协议是自己的或

1274
00:47:02,540 --> 00:47:04,460
乐观的方案 但是

1275
00:47:04,460 --> 00:47:05,540
这个数字有一个协议称为

1276
00:47:05,540 --> 00:47:09,349
Optima 安全协议方案 好吧

1277
00:47:09,349 --> 00:47:12,140
这里的基本想法是，就像

1278
00:47:12,140 --> 00:47:16,790
触摸边界一样，就像时间

1279
00:47:16,790 --> 00:47:19,520
看到我在那里订购一样，我们将

1280
00:47:19,520 --> 00:47:21,530
维护一个私人工作区，我们

1281
00:47:21,530 --> 00:47:23,660
将所有读取的数据复制到其中，以便

1282
00:47:23,660 --> 00:47:25,730
我们返回并读取相同的记录 您

1283
00:47:25,730 --> 00:47:27,680
获得相同的值，我们还将

1284
00:47:27,680 --> 00:47:29,359
所有更改写入该私有

1285
00:47:29,359 --> 00:47:31,250
工作区，因此现在当

1286
00:47:31,250 --> 00:47:32,900
事务提交时，我们会

1287
00:47:32,900 --> 00:47:34,880
验证没有冲突，如果没有，

1288
00:47:34,880 --> 00:47:36,740
我们可以 继续将它们安装

1289
00:47:36,740 --> 00:47:40,430
到全局数据库中，因此 OCC 是一个旧的旧

1290
00:47:40,430 --> 00:47:43,099
协议，因为您最常得出的结论

1291
00:47:43,099 --> 00:47:46,430
是基本的协议是旧的，这个

1292
00:47:46,430 --> 00:47:48,290
可以追溯到 1981 年，实际上是

1293
00:47:48,290 --> 00:47:49,730
由 HT Cohn 教授在卡内基梅隆发明的

1294
00:47:49,730 --> 00:47:52,760
HT Kong 不是 更久

1295
00:47:52,760 --> 00:47:56,089
了，他现在在哈佛，他

1296
00:47:56,089 --> 00:47:57,470
甚至不是 Dana 的教授，他不懂

1297
00:47:57,470 --> 00:47:59,450
网络，但这有点像他

1298
00:47:59,450 --> 00:48:01,250
最著名的工作实际上是一篇数据库

1299
00:48:01,250 --> 00:48:03,020
论文，所以这有点酷，这是

1300
00:48:03,020 --> 00:48:03,620
从 CMU 的计算机系出来的，

1301
00:48:03,620 --> 00:48:07,250
所以 这是一个

1302
00:48:07,250 --> 00:48:08,960
简单的事务是在

1303
00:48:08,960 --> 00:48:11,240
写入时读取，在写入时读取，然后

1304
00:48:11,240 --> 00:48:14,810
在 B 上写入，因此在我们的数据库中，现在我们

1305
00:48:14,810 --> 00:48:16,070
不需要记录的读取时间戳字段，

1306
00:48:16,070 --> 00:48:17,330
我们只需要写入

1307
00:48:17,330 --> 00:48:19,880
时间戳字段和 所以现在当我们的

1308
00:48:19,880 --> 00:48:21,890
交易开始时与基本的

1309
00:48:21,890 --> 00:48:23,600
时间戳登机协议不同，我们

1310
00:48:23,600 --> 00:48:25,610
实际上不会为它分配一个时间戳，

1311
00:48:25,610 --> 00:48:27,260
我们稍后会这样做，

1312
00:48:27,260 --> 00:48:29,120
所以每当我们要读写

1313
00:48:29,120 --> 00:48:31,160
东西时，我们都会制作一个副本 将其

1314
00:48:31,160 --> 00:48:33,920
放入公关 ivate 工作区并将其设置

1315
00:48:33,920 --> 00:48:38,000
为无穷大的类型，因此 OCC 有三个

1316
00:48:38,000 --> 00:48:41,300
阶段，因此不幸的是，第一个阶段

1317
00:48:41,300 --> 00:48:42,560
称为读取阶段，因此即使

1318
00:48:42,560 --> 00:48:45,350
我们要执行权限，这

1319
00:48:45,350 --> 00:48:46,670
无论出于何种原因，他们

1320
00:48:46,670 --> 00:48:50,150
称之为读取阶段 如果我有

1321
00:48:50,150 --> 00:48:51,620
我选择的应用程序，我会将其称为

1322
00:48:51,620 --> 00:48:53,330
运行阶段或执行阶段，我

1323
00:48:53,330 --> 00:48:55,610
认为无论出于何种

1324
00:48:55,610 --> 00:48:57,680
原因将其称为读取阶段都更有意义，因此

1325
00:48:57,680 --> 00:48:59,390
我们将再次在 B 阶段对此处进行读取

1326
00:48:59,390 --> 00:49:02,200
所以我们将不得不

1327
00:49:02,200 --> 00:49:05,630
将该记录和全局数据库复制到

1328
00:49:05,630 --> 00:49:08,810
我们的私人工作空间中，这样我们

1329
00:49:08,810 --> 00:49:10,010
就可以总是以相同的值一遍又一遍地读取这个东西，

1330
00:49:10,010 --> 00:49:12,770
所以现在当

1331
00:49:12,770 --> 00:49:15,170
我们在写上写时，我们不是 将

1332
00:49:15,170 --> 00:49:16,610
修改全局数据库我们将

1333
00:49:16,610 --> 00:49:19,550
修改私有工作区中的数据库，因此

1334
00:49:19,550 --> 00:49:21,380
我们还没有写入时间戳，

1335
00:49:21,380 --> 00:49:23,390
因为我们还没有被分配一个，所以

1336
00:49:23,390 --> 00:49:25,160
我们将在我们的工作区中将其设置为无穷大

1337
00:49:25,160 --> 00:49:26,840
然后

1338
00:49:26,840 --> 00:49:29,960
在这里更新 B 上的相同值 nna

1339
00:49:29,960 --> 00:49:32,000
首先将它从全局数据库复制

1340
00:49:32,000 --> 00:49:34,100
到我们的私有工作区，然后

1341
00:49:34,100 --> 00:49:35,990
使用我们的无限时间戳

1342
00:49:35,990 --> 00:49:40,400
和我们的新值更新它，所以现在当我们的

1343
00:49:40,400 --> 00:49:42,140
事务提交时，它

1344
00:49:42,140 --> 00:49:44,390
实际上不会立即提交，

1345
00:49:44,390 --> 00:49:46,250
不会有两个额外的

1346
00:49:46,250 --> 00:49:49,310
验证阶段 写入阶段的阶段，

1347
00:49:49,310 --> 00:49:50,810
因此验证阶段基本上是

1348
00:49:50,810 --> 00:49:51,910
我们要查看私有工作区的

1349
00:49:51,910 --> 00:49:54,920
地方，看看我们修改了哪些记录

1350
00:49:54,920 --> 00:49:57,800
，然后查看是否

1351
00:49:57,800 --> 00:50:01,520


1352
00:50:01,520 --> 00:50:04,130
有任何交易

1353
00:50:04,130 --> 00:50:05,810
仍在运行，但是 已经阅读了这些数据

1354
00:50:05,810 --> 00:50:06,830
，因此他们没有看到我们的

1355
00:50:06,830 --> 00:50:07,940
更新，因为有一个私人

1356
00:50:07,940 --> 00:50:11,240
工作区或

1357
00:50:11,240 --> 00:50:13,070
过去我已经提交的事务

1358
00:50:13,070 --> 00:50:15,860
已经修改了这些，因此我们

1359
00:50:15,860 --> 00:50:17,930
实际上并没有很好地看到他们的

1360
00:50:17,930 --> 00:50:19,460
更改，因此我们 会有

1361
00:50:19,460 --> 00:50:21,170
冲突，所以要么你在做向后验证，要么

1362
00:50:21,170 --> 00:50:22,339


1363
00:50:22,339 --> 00:50:24,770
再次向前验证，我们在介绍类中

1364
00:50:24,770 --> 00:50:26,089
介绍了它不是真实的

1365
00:50:26,089 --> 00:50:27,859
现在很重要，但基本的想法

1366
00:50:27,859 --> 00:50:29,180
就像你一样，你要确保

1367
00:50:29,180 --> 00:50:31,190
事务总是

1368
00:50:31,190 --> 00:50:34,700
以正确的顺序提交，所以如果我们通过

1369
00:50:34,700 --> 00:50:36,740
验证阶段没有冲突，那么

1370
00:50:36,740 --> 00:50:39,550
我们现在进入正确的阶段，我们

1371
00:50:39,550 --> 00:50:41,780
现在最终被分配 一个时间戳

1372
00:50:41,780 --> 00:50:43,910
，然后我们

1373
00:50:43,910 --> 00:50:45,800
使用我们从私有工作区所做的更改更新全局数据库，

1374
00:50:45,800 --> 00:50:47,510
而不使用我们的

1375
00:50:47,510 --> 00:50:49,880
新时间戳，然后在这

1376
00:50:49,880 --> 00:50:51,200
一点上，事务被认为已经

1377
00:50:51,200 --> 00:51:00,950
完成，它会进行并提交，所以一个

1378
00:51:00,950 --> 00:51:02,119
重要的 需要理解的

1379
00:51:02,119 --> 00:51:05,990
是，当真正没有任何

1380
00:51:05,990 --> 00:51:09,050
争用时，像 OCC 这样的乐观

1381
00:51:09,050 --> 00:51:11,030
方案实际上

1382
00:51:11,030 --> 00:51:14,990
比两阶段锁定执行得更好，因为因为我们

1383
00:51:14,990 --> 00:51:16,880
假设冲突很少，所以我们

1384
00:51:16,880 --> 00:51:17,960
将花更少的时间检查

1385
00:51:17,960 --> 00:51:20,240
复杂的权利。

1386
00:51:20,240 --> 00:51:23,089
寻找实际不存在的冲突的时间更少，

1387
00:51:23,089 --> 00:51:24,920
这有点像在

1388
00:51:24,920 --> 00:51:26,720
不和谐系统中，如果一切都

1389
00:51:26,720 --> 00:51:28,400
适合内存，那么我们就会浪费

1390
00:51:28,400 --> 00:51:31,579
时间 我正在寻找您知道我们

1391
00:51:31,579 --> 00:51:33,400
是否必须驱逐某些东西以在

1392
00:51:33,400 --> 00:51:36,349
我们的缓冲池管理器中腾出空间，

1393
00:51:36,349 --> 00:51:37,730
所以最好乐观地

1394
00:51:37,730 --> 00:51:39,260
假设一切都适合和内存并

1395
00:51:39,260 --> 00:51:41,950
正确跳转以获取并获得我们需要的东西，

1396
00:51:41,950 --> 00:51:44,150
但问题可能是现在 高

1397
00:51:44,150 --> 00:51:45,619
争用我的意思是我们有很多

1398
00:51:45,619 --> 00:51:47,390
事务试图读取和

1399
00:51:47,390 --> 00:51:50,780
写入相同的记录然后

1400
00:51:50,780 --> 00:51:52,220
我刚刚谈到的所有协议

1401
00:51:52,220 --> 00:51:54,020
本质上都将退化

1402
00:51:54,020 --> 00:51:56,780
为只是事务的串行执行

1403
00:51:56,780 --> 00:51:58,700
意味着只有一个

1404
00:51:58,700 --> 00:52:00,770
事务可以同时运行，我们

1405
00:52:00,770 --> 00:52:03,260
将浪费所有这些额外的额外这些

1406
00:52:03,260 --> 00:52:05,359
额外花费大量时间在我们的

1407
00:52:05,359 --> 00:52:07,760
协议上做基本上

1408
00:52:07,760 --> 00:52:09,079
无用的工作，因为我们

1409
00:52:09,079 --> 00:52:12,470
永远无法提交事务，因此为了

1410
00:52:12,470 --> 00:52:14,839
更好地理解这个问题，这是

1411
00:52:14,839 --> 00:52:16,760
你们读的这篇论文是

1412
00:52:16,760 --> 00:52:18,680
关于什么的所以这是

1413
00:52:18,680 --> 00:52:22,400
我以前的学生的一个想法，他现在是

1414
00:52:22,400 --> 00:52:23,690
威斯康星大学的新数据，

1415
00:52:23,690 --> 00:52:26,780
我们做了几年 去

1416
00:52:26,780 --> 00:52:29,359
我们实现了一个允许评估不同的测试平台系统的地方，

1417
00:52:29,359 --> 00:52:31,610


1418
00:52:31,610 --> 00:52:33,260
你的协议不是具有丰富的绿色

1419
00:52:33,260 --> 00:52:36,530
并行性水平，所以

1420
00:52:36,530 --> 00:52:37,790
这个项目可能是一种阴谋，而

1421
00:52:37,790 --> 00:52:39,590
不是像我的续集

1422
00:52:39,590 --> 00:52:40,250
或任何

1423
00:52:40,250 --> 00:52:41,900
你想要并尝试的戴维森一样

1424
00:52:41,900 --> 00:52:44,330
在他们两个之间做一个烘焙我们

1425
00:52:44,330 --> 00:52:45,620
实现了一个单一的系统，它有

1426
00:52:45,620 --> 00:52:47,510
一个可插拔的 API，允许在

1427
00:52:47,510 --> 00:52:50,240
不同的文化协议中扑通一声，而不

1428
00:52:50,240 --> 00:52:52,430
会对系统的其余部分进行重大更改，

1429
00:52:52,430 --> 00:52:54,770
这里的想法是我们想要

1430
00:52:54,770 --> 00:52:57,440
将其剥离 只是作为在数据库系统

1431
00:52:57,440 --> 00:52:59,480
中执行事务所需的最低限度，

1432
00:52:59,480 --> 00:53:01,430
而没有所有

1433
00:53:01,430 --> 00:53:02,540
额外的花里胡哨和

1434
00:53:02,540 --> 00:53:04,210
功能，这些功能还没有像普雷斯科特这样的

1435
00:53:04,210 --> 00:53:06,200
全功能系统可能

1436
00:53:06,200 --> 00:53:08,120
会看到的我们只关注

1437
00:53:08,120 --> 00:53:09,230
这些开销是什么

1438
00:53:09,230 --> 00:53:10,600
协议的并发性，

1439
00:53:10,600 --> 00:53:13,730
所以我们的想法是我们想要

1440
00:53:13,730 --> 00:53:16,730


1441
00:53:16,730 --> 00:53:21,980
在高度并行的环境中运行这些系统，以便

1442
00:53:21,980 --> 00:53:24,260
它真正展示 作为系统中

1443
00:53:24,260 --> 00:53:25,910
不同协议实现的主要瓶颈

1444
00:53:25,910 --> 00:53:27,110


1445
00:53:27,110 --> 00:53:29,690
，

1446
00:53:29,690 --> 00:53:30,860
您可能无法在

1447
00:53:30,860 --> 00:53:33,290
32 核或 64 核之类的机器上运行，这

1448
00:53:33,290 --> 00:53:35,330
是您这次最多可以解决的问题

1449
00:53:35,330 --> 00:53:39,680
在 2014 年我们写这篇论文的

1450
00:53:39,680 --> 00:53:41,330
时候，我们将用于这次

1451
00:53:41,330 --> 00:53:44,780
评估的系统称为 DB X 1000 所以这

1452
00:53:44,780 --> 00:53:46,820
又是学生

1453
00:53:46,820 --> 00:53:49,370
为这篇论文编写的系统，然后它是

1454
00:53:49,370 --> 00:53:51,380
从头开始编写的，只是为了让这个

1455
00:53:51,380 --> 00:53:53,720
可插入的 API 允许 您可以

1456
00:53:53,720 --> 00:53:55,910
在这些并发协议的不同实现中添加该下降，

1457
00:53:55,910 --> 00:53:58,220
因此它是

1458
00:53:58,220 --> 00:53:59,690
一个精简的系统，没有

1459
00:53:59,690 --> 00:54:01,790
网络访问，

1460
00:54:01,790 --> 00:54:02,960
至少在我们撰写本文时没有日志记录，

1461
00:54:02,960 --> 00:54:04,790
并且过时的支持并发

1462
00:54:04,790 --> 00:54:06,740
索引它确实只是关注

1463
00:54:06,740 --> 00:54:08,540
您转换协议的速度有多快？

1464
00:54:08,540 --> 00:54:11,570
所有事务都将

1465
00:54:11,570 --> 00:54:13,100
通过存储过程执行，

1466
00:54:13,100 --> 00:54:15,230
这意味着

1467
00:54:15,230 --> 00:54:17,120
执行事务的所有服务器端逻辑都

1468
00:54:17,120 --> 00:54:19,130
包含在 th 上 数据系统本身，

1469
00:54:19,130 --> 00:54:21,080
所以你永远不会通过网络谈论它们，

1470
00:54:21,080 --> 00:54:22,970
并询问客户的应用程序，

1471
00:54:22,970 --> 00:54:24,470
你知道我接下来应该做什么

1472
00:54:24,470 --> 00:54:27,440
，所以我们现在也将在

1473
00:54:27,440 --> 00:54:32,690
由麻省理工学院开发的芯片模拟器中运行它，

1474
00:54:32,690 --> 00:54:36,950
我的团队称为 石墨，这

1475
00:54:36,950 --> 00:54:39,410
是使用 Nuka 架构对基于单套接字表的 CPU 进行建模

1476
00:54:39,410 --> 00:54:42,620
，因此 Nuka

1477
00:54:42,620 --> 00:54:44,890
代表非统一缓存行为

1478
00:54:44,890 --> 00:54:47,290
，我们将其与 Neumann

1479
00:54:47,290 --> 00:54:48,640
架构的非统一内存访问进行对比

1480
00:54:48,640 --> 00:54:50,590
，或者大部分将

1481
00:54:50,590 --> 00:54:52,060
在学期中讨论，就像你一样 知道

1482
00:54:52,060 --> 00:54:55,540
英特尔至强出货，所以 Nuka 基本上

1483
00:54:55,540 --> 00:55:00,670
意味着一个内核访问

1484
00:55:00,670 --> 00:55:03,700
另一个内核的缓存的成本并不

1485
00:55:03,700 --> 00:55:05,590
总是相同的，因为它

1486
00:55:05,590 --> 00:55:07,090
会有这种基于 tile 的架构，

1487
00:55:07,090 --> 00:55:08,560
你必须通过这个网状网络进行通信，

1488
00:55:08,560 --> 00:55:11,740
你知道吗？ 缓存

1489
00:55:11,740 --> 00:55:13,090
失效并

1490
00:55:13,090 --> 00:55:14,860
在不同核心之间进行合理的写入，因此某些

1491
00:55:14,860 --> 00:55:16,570
核心在网络上离您更近

1492
00:55:16,570 --> 00:55:18,760
，因此您的读取写入它们的

1493
00:55:18,760 --> 00:55:22,120
内存位置或它们的缓存我

1494
00:55:22,120 --> 00:55:23,710
比大陆清理网络另一端的速度要快得多，

1495
00:55:23,710 --> 00:55:26,890
所以我

1496
00:55:26,890 --> 00:55:30,130
并不是真正的架构师，

1497
00:55:30,130 --> 00:55:31,540
我们之所以想要这种或基于图块

1498
00:55:31,540 --> 00:55:34,450
的方法是因为当您与

1499
00:55:34,450 --> 00:55:36,550
架构专家交谈时，

1500
00:55:36,550 --> 00:55:38,620
他们说 当你开始让

1501
00:55:38,620 --> 00:55:42,160
他们喜欢一千个核心数

1502
00:55:42,160 --> 00:55:43,720
时，传统智慧是你

1503
00:55:43,720 --> 00:55:45,220
想再次使用这样的基于表的架构，

1504
00:55:45,220 --> 00:55:47,950
我们

1505
00:55:47,950 --> 00:55:49,600
将从研究中获得的主要收获

1506
00:55:49,600 --> 00:55:50,920
不会依赖于使用 基于 tile 的

1507
00:55:50,920 --> 00:55:52,120
架构，它们仍然

1508
00:55:52,120 --> 00:55:54,340
适用于我们在本学期所讨论的 xeon 类型系统，

1509
00:55:54,340 --> 00:55:56,140
这

1510
00:55:56,140 --> 00:55:58,630
正是我们

1511
00:55:58,630 --> 00:56:00,790
当时用来建模的港口，所以另一个

1512
00:56:00,790 --> 00:56:01,960
需要理解的重要事情是

1513
00:56:01,960 --> 00:56:04,060
这个 cpu 刺激器运行 真的

1514
00:56:04,060 --> 00:56:06,550
真的很慢，好吧，它

1515
00:56:06,550 --> 00:56:08,320
比

1516
00:56:08,320 --> 00:56:11,290
你知道的裸机系统的挂钟时间慢

1517
00:56:11,290 --> 00:56:13,720
一万倍，所以这意味着

1518
00:56:13,720 --> 00:56:15,280
学生确实必须进行大量优化

1519
00:56:15,280 --> 00:56:17,680
X 1  000 可以在模拟器中的

1520
00:56:17,680 --> 00:56:19,870
合理时间运行，因此如果

1521
00:56:19,870 --> 00:56:21,400
您查看 github 上的代码，您会

1522
00:56:21,400 --> 00:56:24,400
发现它们中有

1523
00:56:24,400 --> 00:56:25,780
很多在系统的不同部分中有很多程序集，

1524
00:56:25,780 --> 00:56:27,430
因为他必须这样做

1525
00:56:27,430 --> 00:56:28,960
为了让它运行得快，她你

1526
00:56:28,960 --> 00:56:30,550
知道让经验

1527
00:56:30,550 --> 00:56:34,030
及时完成所以

1528
00:56:34,030 --> 00:56:35,440
我们将用于本文的目标工作负载

1529
00:56:35,440 --> 00:56:38,920
将是 y CS 是 W Yahoo Cloud

1530
00:56:38,920 --> 00:56:41,440
一些基准，所以它

1531
00:56:41,440 --> 00:56:43,420
基本上是一个 键值存储工作负载

1532
00:56:43,420 --> 00:56:46,270
，这有点意味着模型

1533
00:56:46,270 --> 00:56:51,190
是一种网络服务或基于网络的应用程序的 ESS 模式，

1534
00:56:51,190 --> 00:56:54,070
因此在数据库中将

1535
00:56:54,070 --> 00:56:55,360
有 200 万个元组，每个

1536
00:56:55,360 --> 00:56:58,779
元组是 1 KB，

1537
00:56:58,779 --> 00:57:00,959
因此我们要建模的每个事务

1538
00:57:00,959 --> 00:57:04,859
我们系统中的伊朗将执行

1539
00:57:04,859 --> 00:57:06,640
查询，他们将一次读取和写入

1540
00:57:06,640 --> 00:57:09,069
16 个不同的元组，

1541
00:57:09,069 --> 00:57:11,109
我们将在访问模式中改变他们

1542
00:57:11,109 --> 00:57:12,609
的访问模式，因此有时

1543
00:57:12,609 --> 00:57:13,839
它们会是热点，有时

1544
00:57:13,839 --> 00:57:16,209
它们会是统一的 访问和所有

1545
00:57:16,209 --> 00:57:17,559
事务将运行存储

1546
00:57:17,559 --> 00:57:18,099
过程

1547
00:57:18,099 --> 00:57:19,449
存储过程运行可

1548
00:57:19,449 --> 00:57:23,529
序列化隔离级别，因此六种

1549
00:57:23,529 --> 00:57:24,640
不同的方案将比较

1550
00:57:24,640 --> 00:57:27,459
或基于我之前谈到的不同类型的

1551
00:57:27,459 --> 00:57:29,859
协议，因此

1552
00:57:29,859 --> 00:57:31,569
对于两阶段锁定，将会有

1553
00:57:31,569 --> 00:57:33,309
死锁检测 然后

1554
00:57:33,309 --> 00:57:34,989
防止死锁，无需等待，等待和死亡

1555
00:57:34,989 --> 00:57:37,659
，这是当今

1556
00:57:37,659 --> 00:57:39,609
一些最大的数据库系统的象征，

1557
00:57:39,609 --> 00:57:42,640
现在在

1558
00:57:42,640 --> 00:57:44,319
时间戳订购方面有一个时间戳

1559
00:57:44,319 --> 00:57:46,659
订购，有 FCC，有一个

1560
00:57:46,659 --> 00:57:49,630
多版本 在 1979 年的论文中存在或描述了原始的多

1561
00:57:49,630 --> 00:57:53,229
版本协议，

1562
00:57:53,229 --> 00:57:55,659
该版本描述

1563
00:57:55,659 --> 00:57:58,689
了使用时间戳的 MVCC 下一

1564
00:57:58,689 --> 00:57:59,979
课我们将看到您可以拥有

1565
00:57:59,979 --> 00:58:01,900


1566
00:58:01,900 --> 00:58:04,900
使用 OCC 或两相锁定的多版本控制的不同变体，但

1567
00:58:04,900 --> 00:58:06,819
对于这个，我们只是

1568
00:58:06,819 --> 00:58:08,199
在 1970 年代的原始协议中采用了这种方式

1569
00:58:08,199 --> 00:58:10,809
，这是

1570
00:58:10,809 --> 00:58:13,719
大多数较新系统的象征 是的，

1571
00:58:13,719 --> 00:58:15,519
还有一些

1572
00:58:15,519 --> 00:58:19,299
使用多版本控制的经典数据库系统，所以对于

1573
00:58:19,299 --> 00:58:21,459
这里的第一个实验，这

1574
00:58:21,459 --> 00:58:24,549


1575
00:58:24,549 --> 00:58:25,779
是这些不同协议和

1576
00:58:25,779 --> 00:58:28,329
只读工作负载的基线性能，所以你看到

1577
00:58:28,329 --> 00:58:30,789
的是 x 轴随着我们扩展

1578
00:58:30,789 --> 00:58:34,299
我们添加的内核数量，

1579
00:58:34,299 --> 00:58:35,829
同时运行的并发事务越多，

1580
00:58:35,829 --> 00:58:38,169
所以每次我们

1581
00:58:38,169 --> 00:58:40,269
添加一个内核时，都会运行一个

1582
00:58:40,269 --> 00:58:42,069
额外的事务，

1583
00:58:42,069 --> 00:58:44,019
你知道运行重要的执行

1584
00:58:44,019 --> 00:58:47,890
部分 工作负载，因此 200 个内核同时有 200 个

1585
00:58:47,890 --> 00:58:50,739
当前事务，因此

1586
00:58:50,739 --> 00:58:52,119
这是具有

1587
00:58:52,119 --> 00:58:55,569
统一内存访问或元组访问的只读工作负载

1588
00:58:55,569 --> 00:58:57,099
，这是这些

1589
00:58:57,099 --> 00:58:58,959
不同协议可以做的最好的事情，因为

1590
00:58:58,959 --> 00:59:01,749
存在零争用，所以

1591
00:59:01,749 --> 00:59:03,819
我们看到的第一件事 死锁

1592
00:59:03,819 --> 00:59:05,880
检测和无等待协议

1593
00:59:05,880 --> 00:59:09,039
实际上几乎可以线性扩展并

1594
00:59:09,039 --> 00:59:11,229
表现最佳，因为这些协议

1595
00:59:11,229 --> 00:59:12,610
非常简单，没有

1596
00:59:12,610 --> 00:59:14,740
锁和 因此，

1597
00:59:14,740 --> 00:59:17,430
事务和执行的开销是心理上的，

1598
00:59:17,430 --> 00:59:19,480
接下来你看到的是

1599
00:59:19,480 --> 00:59:23,500
我在八百辆车旁等待

1600
00:59:23,500 --> 00:59:25,780
和死亡，MVCC 开始下降

1601
00:59:25,780 --> 00:59:28,180
，这是由于为事务分配唯一时间戳的开销，

1602
00:59:28,180 --> 00:59:29,830


1603
00:59:29,830 --> 00:59:31,600
因为它们“

1604
00:59:31,600 --> 00:59:33,100
当您同时运行 100 万个

1605
00:59:33,100 --> 00:59:34,120
事务时，

1606
00:59:34,120 --> 00:59:36,160
或者当您每秒运行 800

1607
00:59:36,160 --> 00:59:38,110
万个事务时，这个

1608
00:59:38,110 --> 00:59:39,460
基于表的架构在

1609
00:59:39,460 --> 00:59:40,810
时间戳分配和跨

1610
00:59:40,810 --> 00:59:41,980
所有不同线程的协调成为

1611
00:59:41,980 --> 00:59:45,670
瓶颈时重新运行 最后你看到

1612
00:59:45,670 --> 00:59:47,590
这里的 OCC 实际上是最糟糕的，所以这

1613
00:59:47,590 --> 00:59:50,410
是必须

1614
00:59:50,410 --> 00:59:52,690
为每个事务复制私有工作区

1615
00:59:52,690 --> 00:59:54,130
并将其复制回

1616
00:59:54,130 --> 00:59:56,170
系统的组合，这实际上是一个很大的

1617
00:59:56,170 --> 01:00:00,130
瓶颈，所以接下来我们看到这里是

1618
01:00:00,130 --> 01:00:01,420
写入密集型 您知道

1619
01:00:01,420 --> 01:00:02,950
我有事务实际

1620
01:00:02,950 --> 01:00:04,840
更新数据库的工作负载，这是在中等

1621
01:00:04,840 --> 01:00:06,820
或有工作负载的情况下，其中 60% 的

1622
01:00:06,820 --> 01:00:08,260
事务是 将尝试访问

1623
01:00:08,260 --> 01:00:11,920
数据库的 20% 的热点，因此

1624
01:00:11,920 --> 01:00:12,730
您需要看到的第一件事是，

1625
01:00:12,730 --> 01:00:14,770
死锁检测实际上现在是

1626
01:00:14,770 --> 01:00:17,380
用于这种未命中环境的最差协议，

1627
01:00:17,380 --> 01:00:19,120
您在上一张幻灯片中知道我

1628
01:00:19,120 --> 01:00:20,920
向您展示的实际上是 最好但是

1629
01:00:20,920 --> 01:00:22,570
现在当你对更高的山争用有很高的内容时，就会

1630
01:00:22,570 --> 01:00:26,190
出现死锁，系统中会有更多的死锁

1631
01:00:26,190 --> 01:00:28,210


1632
01:00:28,210 --> 01:00:29,770
，因此

1633
01:00:29,770 --> 01:00:31,270
死锁检测线程需要更长

1634
01:00:31,270 --> 01:00:33,370
的时间来解决这些死锁，所以你发送给

1635
01:00:33,370 --> 01:00:34,960
你的线程被盗并等待

1636
01:00:34,960 --> 01:00:36,670
它 死锁检测威胁来解决

1637
01:00:36,670 --> 01:00:38,500
并清理事情，

1638
01:00:38,500 --> 01:00:43,260
接下来会损害性能你看到

1639
01:00:43,260 --> 01:00:45,880
没有等待和等待我实际上做得

1640
01:00:45,880 --> 01:00:47,530
最好，这是因为这些

1641
01:00:47,530 --> 01:00:50,620
协议非常简单所以正在发生的

1642
01:00:50,620 --> 01:00:53,410
事情是你知道

1643
01:00:53,410 --> 01:00:56,350
是的，随时都有 存在冲突，

1644
01:00:56,350 --> 01:00:58,240
这些

1645
01:00:58,240 --> 01:00:59,920
协议会立即陷入僵局，只需终止

1646
01:00:59,920 --> 01:01:01,810
事务以重新启动它们，这样您就

1647
01:01:01,810 --> 01:01:03,760
不会浪费时间尝试进行处理

1648
01:01:03,760 --> 01:01:06,300
你知道我应该等待还是你知道

1649
01:01:06,300 --> 01:01:08,200
希望另一笔交易可以

1650
01:01:08,200 --> 01:01:10,150
放弃一个槽你立即采取一些行动

1651
01:01:10,150 --> 01:01:10,420


1652
01:01:10,420 --> 01:01:12,100
不等待最简单的写

1653
01:01:12,100 --> 01:01:13,720
基本上说我试图获得我的交易

1654
01:01:13,720 --> 01:01:15,730
块我无法立即杀死

1655
01:01:15,730 --> 01:01:17,680
我自己 再次因为我们通过癫痫存储，

1656
01:01:17,680 --> 01:01:19,540
没有

1657
01:01:19,540 --> 01:01:21,280
重新启动事务的开销，并且在内存

1658
01:01:21,280 --> 01:01:23,680
环境中它

1659
01:01:23,680 --> 01:01:25,810
在中间非常快，在这里您可以看到

1660
01:01:25,810 --> 01:01:28,750
三个时间戳警告协议基本

1661
01:01:28,750 --> 01:01:31,420
tio MVCC 和 OCC 它们大致都

1662
01:01:31,420 --> 01:01:33,640
在做相同的 CCS 的运行速度

1663
01:01:33,640 --> 01:01:35,320
再次变慢，因为将东西一遍又一遍地

1664
01:01:35,320 --> 01:01:37,540
复制到您所知道的工作空间内外的工作中会产生额外的开销，

1665
01:01:37,540 --> 01:01:38,980


1666
01:01:38,980 --> 01:01:42,040
但您知道它们

1667
01:01:42,040 --> 01:01:46,690
大致相同，所以现在我们在这里得到最后一张

1668
01:01:46,690 --> 01:01:47,890
图，这是最多的 重要

1669
01:01:47,890 --> 01:01:49,870
的一篇论文，这是我们

1670
01:01:49,870 --> 01:01:51,370
运行写入系统工作负载的地方，其中

1671
01:01:51,370 --> 01:01:54,130
90% 的事务正在更新 10%

1672
01:01:54,130 --> 01:01:56,440
的数据库，所以现在您看到

1673
01:01:56,440 --> 01:01:58,210
所有协议基本上都崩溃了

1674
01:01:58,210 --> 01:02:00,790
当我们达到一千个内核时，n 为零

1675
01:02:00,790 --> 01:02:03,100
好吧，这些

1676
01:02:03,100 --> 01:02:06,190
协议实际上都没有扩展缝纫

1677
01:02:06,190 --> 01:02:07,570
，原因是这是所有这些

1678
01:02:07,570 --> 01:02:09,910
事务必须

1679
01:02:09,910 --> 01:02:12,010
检查冲突或复制东西的开销，而且

1680
01:02:12,010 --> 01:02:13,720
冲突太多了，你只是

1681
01:02:13,720 --> 01:02:15,280
不能让你知道进展

1682
01:02:15,280 --> 01:02:18,040
和完成事情，所以一件

1683
01:02:18,040 --> 01:02:20,290
有趣的事情是，你看到没有

1684
01:02:20,290 --> 01:02:23,430
等待相对于其他协议进行得很好

1685
01:02:23,430 --> 01:02:26,260
，直到

1686
01:02:26,260 --> 01:02:28,360
800 个线程，然后它崩溃到

1687
01:02:28,360 --> 01:02:31,630
零，所以它没有做

1688
01:02:31,630 --> 01:02:33,400
与以前的生活相比，这很棒，我认为它

1689
01:02:33,400 --> 01:02:35,110


1690
01:02:35,110 --> 01:02:37,480
每秒只执行 200,000 个事务，而我正在分享的另一个切片是

1691
01:02:37,480 --> 01:02:38,500
你每秒可以执行数百万个

1692
01:02:38,500 --> 01:02:41,350
事务，但它再次运行良好，

1693
01:02:41,350 --> 01:02:43,090
因为它的

1694
01:02:43,090 --> 01:02:45,880
协议非常简单，是的，

1695
01:02:45,880 --> 01:02:47,950
当 系统识别出

1696
01:02:47,950 --> 01:02:49,840
将会出现死锁，它会

1697
01:02:49,840 --> 01:02:51,780
立即终止交易，然后重新

1698
01:02:51,780 --> 01:02:54,970
启动其他交易，并且

1699
01:02:54,970 --> 01:02:56,320
这样做的成本非常低 相对于

1700
01:02:56,320 --> 01:02:58,270
其他的，当然现在有一千个

1701
01:02:58,270 --> 01:03:02,710
核心，这样做只是你只是进行

1702
01:03:02,710 --> 01:03:04,240
大量的交易，以至于你

1703
01:03:04,240 --> 01:03:06,540
无法完成任何

1704
01:03:06,540 --> 01:03:08,800
工作 另一件有趣的

1705
01:03:08,800 --> 01:03:11,950
事情要指出的是，

1706
01:03:11,950 --> 01:03:13,270
当你有一个 核心数量很少，

1707
01:03:13,270 --> 01:03:15,580
但另一方面实际上

1708
01:03:15,580 --> 01:03:18,250
做得最好，这又是

1709
01:03:18,250 --> 01:03:19,810
因为它基本上是向下生成

1710
01:03:19,810 --> 01:03:21,490
以进行用户执行

1711
01:03:21,490 --> 01:03:25,450
交易，因此协议的

1712
01:03:25,450 --> 01:03:26,950
工作方式是，当您进入

1713
01:03:26,950 --> 01:03:28,510
验证阶段时，您可以

1714
01:03:28,510 --> 01:03:30,730
保证 事务处于那个验证

1715
01:03:30,730 --> 01:03:32,470
阶段，因此总是

1716
01:03:32,470 --> 01:03:34,450
允许实际提交，所以当

1717
01:03:34,450 --> 01:03:36,250
你基本上在这里运行

1718
01:03:36,250 --> 01:03:37,630
一千个线程时

1719
01:03:37,630 --> 01:03:40,570
，一千个内核是通过运行同样的

1720
01:03:40,570 --> 01:03:42,190
事情你在一个课程上运行

1721
01:03:42,190 --> 01:03:43,960
至少一个事务会 总是

1722
01:03:43,960 --> 01:03:46,180
保证承诺，这就是为什么如果

1723
01:03:46,180 --> 01:03:47,620
它在相同的性能下变得粗糙，它

1724
01:03:47,620 --> 01:03:49,530
会在图表的另一侧出现，

1725
01:03:49,530 --> 01:03:51,670
但主要的收获还是

1726
01:03:51,670 --> 01:03:53,470
那个 ove  r 这里有一千个内核，

1727
01:03:53,470 --> 01:03:57,640
一切都在做坏事，

1728
01:03:57,640 --> 01:03:59,980
而且自 2014 年以来，情况有所好转，

1729
01:03:59,980 --> 01:04:01,810
我们在这篇论文中，但这

1730
01:04:01,810 --> 01:04:04,000
大致是我们今天在

1731
01:04:04,000 --> 01:04:06,340
现代系统中的实际情况，就在单个盒子中运行我而言，

1732
01:04:06,340 --> 01:04:10,480
有 64 32 或 64 核，所以

1733
01:04:10,480 --> 01:04:11,830
我们真的没有在

1734
01:04:11,830 --> 01:04:14,440
高竞争的现代系统中进入危险区域

1735
01:04:14,440 --> 01:04:18,820
，你知道

1736
01:04:18,820 --> 01:04:20,920
在一个盒子上没有真正大量的核心数，

1737
01:04:20,920 --> 01:04:22,390
我们只是还没有到达那里，

1738
01:04:22,390 --> 01:04:24,610
但这张图基本上显示了 您

1739
01:04:24,610 --> 01:04:25,930
认为我们今天使用的现有

1740
01:04:25,930 --> 01:04:31,030
方法不是我将具有可扩展性并且

1741
01:04:31,030 --> 01:04:32,560
如此快速 我们实际上

1742
01:04:32,560 --> 01:04:34,510
将时间花在哪里 所以这是

1743
01:04:34,510 --> 01:04:37,780
在 xu 交易时不同协议的细分

1744
01:04:37,780 --> 01:04:40,000
，您会在这种

1745
01:04:40,000 --> 01:04:41,920
情况下看到 不用等待，它

1746
01:04:41,920 --> 01:04:43,360
花费了大部分时间来

1747
01:04:43,360 --> 01:04:44,980
处理事务，因为一旦

1748
01:04:44,980 --> 01:04:47,440
发现冲突，它就会说这是

1749
01:04:47,440 --> 01:04:51,010
不好的，只是重新启动它，或者其他

1750
01:04:51,010 --> 01:04:53,710
协议正在花时间等待

1751
01:04:53,710 --> 01:04:55,360
尝试获取锁或尝试 获取

1752
01:04:55,360 --> 01:04:56,380
时间点再次等待一个

1753
01:04:56,380 --> 01:04:58,450
愉快的线程，这只是

1754
01:04:58,450 --> 01:05:02,350
浪费工作，所以让我们

1755
01:05:02,350 --> 01:05:03,400
快速讨论一下

1756
01:05:03,400 --> 01:05:05,550
我们在本文中确定的

1757
01:05:05,550 --> 01:05:10,090
一些瓶颈以及我们可以绕过它们的一些潜在解决方案

1758
01:05:10,090 --> 01:05:12,130
以及这里的想法

1759
01:05:12,130 --> 01:05:14,080
有点理解这些问题的

1760
01:05:14,080 --> 01:05:16,210
高层次，所以当我们

1761
01:05:16,210 --> 01:05:19,540


1762
01:05:19,540 --> 01:05:22,210
在后面的下一堂课中再次开始谈论 FVCC 时，你的头脑

1763
01:05:22,210 --> 01:05:23,440
应该考虑更多细节哦，好吧，

1764
01:05:23,440 --> 01:05:25,660
这就是他们将如何处理这个

1765
01:05:25,660 --> 01:05:26,710
问题，这可能是一个问题 当我们看到

1766
01:05:26,710 --> 01:05:27,790
比我们今天实际拥有的更大的核心帐户时

1767
01:05:27,790 --> 01:05:30,490
，因此锁定抖动

1768
01:05:30,490 --> 01:05:31,840
时间一些分配内存分配

1769
01:05:31,840 --> 01:05:34,300
将导致每一个一个一个，因此

1770
01:05:34,300 --> 01:05:36,340
锁定抖动是一种现象，您

1771
01:05:36,340 --> 01:05:38,320
将在两阶段锁定系统

1772
01:05:38,320 --> 01:05:41,650
中遇到如果事务 最终

1773
01:05:41,650 --> 01:05:44,230
等待更长时间所需的锁，然后这

1774
01:05:44,230 --> 01:05:45,910
会导致其他等待

1775
01:05:45,910 --> 01:05:47,500
它的事务最终等待更长的时间来

1776
01:05:47,500 --> 01:05:49,000
获取第一个持有的事务的锁，

1777
01:05:49,000 --> 01:05:51,069
并且 因此，这会导致

1778
01:05:51,069 --> 01:05:53,799
该服务背后的其他事务的第二条路径

1779
01:05:53,799 --> 01:05:56,049
等待更长时间，因此

1780
01:05:56,049 --> 01:05:58,119
这种护卫效应是我们导致一个

1781
01:05:58,119 --> 01:05:59,589
事务等待更长时间导致

1782
01:05:59,589 --> 01:06:01,690
其他所有人等待更长时间然后

1783
01:06:01,690 --> 01:06:03,779
随着您添加更多事务而加剧，

1784
01:06:03,779 --> 01:06:06,219
因此我们可以实际衡量的一种方式

1785
01:06:06,219 --> 01:06:09,849
在我们的系统中，这是通过消除

1786
01:06:09,849 --> 01:06:11,349
进行任何死锁检查

1787
01:06:11,349 --> 01:06:12,880
预防或死锁检测的所有开销，并且

1788
01:06:12,880 --> 01:06:15,940
让事务只做

1789
01:06:15,940 --> 01:06:18,999
获取锁并等待，因此

1790
01:06:18,999 --> 01:06:20,259
在这种情况下，我们可以这样做的

1791
01:06:20,259 --> 01:06:21,999
方式是我们要 强制事务

1792
01:06:21,999 --> 01:06:23,499
需要的锁总是以某种

1793
01:06:23,499 --> 01:06:25,329
主键顺序 想想就像

1794
01:06:25,329 --> 01:06:26,890
我们持有你知道我们有一个锁

1795
01:06:26,890 --> 01:06:28,509
一二三四五六我们必须

1796
01:06:28,509 --> 01:06:30,279
以那种

1797
01:06:30,279 --> 01:06:32,140
字典顺序获取它们所以在这种

1798
01:06:32,140 --> 01:06:33,880
环境中死锁是 可能所以

1799
01:06:33,880 --> 01:06:36,819
我们永远不会因为死锁而出现任何停顿，

1800
01:06:36,819 --> 01:06:39,249
它只是

1801
01:06:39,249 --> 01:06:43,089
等待获取这些锁的停顿，所以如果你

1802
01:06:43,089 --> 01:06:45,309
在系统上运行那个实验哟 你得到一个

1803
01:06:45,309 --> 01:06:47,829
这样的图表，所以这里的推子变量

1804
01:06:47,829 --> 01:06:50,079
代表

1805
01:06:50,079 --> 01:06:52,239
工作负载的偏差量或

1806
01:06:52,239 --> 01:06:53,769
试图访问少量元组的更多事务，

1807
01:06:53,769 --> 01:06:56,949
所以最极端的情况是 0.8

1808
01:06:56,949 --> 01:06:59,019
并且 theta 零意味着没有

1809
01:06:59,019 --> 01:07:01,449
争用，所以你看到了什么 是这些

1810
01:07:01,449 --> 01:07:05,799
漂亮的曲线 这些膝盖弯曲处

1811
01:07:05,799 --> 01:07:07,900
锁定新生开始发挥作用 现在

1812
01:07:07,900 --> 01:07:09,249
交易最终等待

1813
01:07:09,249 --> 01:07:11,829
越来越长的时间来获取锁定 当

1814
01:07:11,829 --> 01:07:15,009
有更多的争用权时

1815
01:07:15,009 --> 01:07:16,569
，您知道这种争夺一直在

1816
01:07:16,569 --> 01:07:18,009
下降 这些线一直在下降

1817
01:07:18,009 --> 01:07:19,690


1818
01:07:19,690 --> 01:07:21,789
当我真的很喜欢这个实验的时候，不要从这种颠簸效应中恢复过来，

1819
01:07:21,789 --> 01:07:25,569
因为它显示这个图

1820
01:07:25,569 --> 01:07:28,180
实际上看起来就像任何一种

1821
01:07:28,180 --> 01:07:29,890
教科书，表明你描述了

1822
01:07:29,890 --> 01:07:33,130
锁定颠簸，像这样

1823
01:07:33,130 --> 01:07:35,049
是一本教科书的例子，但是 他们

1824
01:07:35,049 --> 01:07:36,430
总是有这样的理论

1825
01:07:36,430 --> 01:07:39,279
图，比如哦，这是锁颠簸的效果，

1826
01:07:39,279 --> 01:07:41,529
但你知道在这种情况下

1827
01:07:41,529 --> 01:07:43,809
，我们的图与 y 完全匹配 您

1828
01:07:43,809 --> 01:07:45,039
希望根据定理看到，

1829
01:07:45,039 --> 01:07:48,279
这

1830
01:07:48,279 --> 01:07:51,999
很好我有一个时间戳

1831
01:07:51,999 --> 01:07:54,069
分配，这

1832
01:07:54,069 --> 01:07:56,769
对我们的系统来说不一定是一个大问题，我们

1833
01:07:56,769 --> 01:07:59,890
将通过

1834
01:07:59,890 --> 01:08:03,039
批量添加或原子操作来解决 另外，这

1835
01:08:03,039 --> 01:08:04,450
是另一种变体

1836
01:08:04,450 --> 01:08:06,790
交换，但它基本上是说在

1837
01:08:06,790 --> 01:08:09,790
非常多的核心计数中，有一个

1838
01:08:09,790 --> 01:08:11,320
事务到 opto 获得了唯一的

1839
01:08:11,320 --> 01:08:12,460
时间戳，因此它们实际上可能是一个

1840
01:08:12,460 --> 01:08:15,220
很大的瓶颈，因此互斥锁总是

1841
01:08:15,220 --> 01:08:16,330
会很糟糕，我们不觉得

1842
01:08:16,330 --> 01:08:19,060
不可能 atomic add bash 这些

1843
01:08:19,060 --> 01:08:21,310
只是比较交换方法，然后对于

1844
01:08:21,310 --> 01:08:24,399
这些特定的 cpu，像 intel 这样的

1845
01:08:24,399 --> 01:08:27,220
cpu 可以有硬件时钟，或者

1846
01:08:27,220 --> 01:08:29,319
您可以通过一些指令，

1847
01:08:29,319 --> 01:08:32,470
但这尚不清楚 intel 是否

1848
01:08:32,470 --> 01:08:35,319
迫切需要保留它，

1849
01:08:35,319 --> 01:08:37,000
这不是我们的东西 可能

1850
01:08:37,000 --> 01:08:39,040
会希望她躺在上面，然后哈佛

1851
01:08:39,040 --> 01:08:41,340
历法

1852
01:08:41,340 --> 01:08:43,660
是学生

1853
01:08:43,660 --> 01:08:45,460
想出的添加到石墨

1854
01:08:45,460 --> 01:08:47,500
模拟中的东西 这不是

1855
01:08:47,500 --> 01:08:49,149
我们想要的东西，你知道它

1856
01:08:49,149 --> 01:08:51,399
今天存在，所以这张图只是

1857
01:08:51,399 --> 01:08:53,950
向你展示了这些瓶颈之一在

1858
01:08:53,950 --> 01:08:55,540
运行

1859
01:08:55,540 --> 01:08:58,029
这些不同的时间方案分配

1860
01:08:58,029 --> 01:09:00,279
方案时发挥作用，而且批处理原子的

1861
01:09:00,279 --> 01:09:01,660
一个可能会 对

1862
01:09:01,660 --> 01:09:04,630
我们需要的东西足够好，我们正在谈论你

1863
01:09:04,630 --> 01:09:05,890
知道尝试分配一

1864
01:09:05,890 --> 01:09:07,779
亿个时间戳一秒钟，这

1865
01:09:07,779 --> 01:09:12,520
比我们永远需要的还要多

1866
01:09:12,520 --> 01:09:14,080


1867
01:09:14,080 --> 01:09:18,310


1868
01:09:18,310 --> 01:09:22,180
将

1869
01:09:22,180 --> 01:09:24,130
某些协议的内容复制到私有工作区中，或者

1870
01:09:24,130 --> 01:09:26,890
您知道复制元组并确保

1871
01:09:26,890 --> 01:09:30,279
在公共空间中进行惩罚读取，复制可能

1872
01:09:30,279 --> 01:09:32,950
很昂贵，因此如果我们使用

1873
01:09:32,950 --> 01:09:35,350
默认的 Lipsy malloc，它总是

1874
01:09:35,350 --> 01:09:37,090
会超级慢，我们永远不想使用

1875
01:09:37,090 --> 01:09:39,609
它所以 本学期我们不会过多讨论不同的

1876
01:09:39,609 --> 01:09:41,290
内存分配器，

1877
01:09:41,290 --> 01:09:43,120
除了说

1878
01:09:43,120 --> 01:09:45,220
当我们最终使用 GE

1879
01:09:45,220 --> 01:09:48,100
malloc 或 TC malloc 或其他时我们不想使用默认的 malloc

1880
01:09:48,100 --> 01:09:50,050
malloc 协议他们的库

1881
01:09:50,050 --> 01:09:55,150
都在那里，所以我再次

1882
01:09:55,150 --> 01:09:56,530
意识到让

1883
01:09:56,530 --> 01:09:58,120
我在这个镀金的房间里讲这个讲座的其余部分有点奇怪，

1884
01:09:58,120 --> 01:10:02,440
但我

1885
01:10:02,440 --> 01:10:03,820
只是想把它放在那里，以便

1886
01:10:03,820 --> 01:10:05,500
我们可以开始交谈 关于 MVC 星期三看到更多

1887
01:10:05,500 --> 01:10:07,060
细节我

1888
01:10:07,060 --> 01:10:09,970
想回来回到校园 所以

1889
01:10:09,970 --> 01:10:11,410
你在这个讲座

1890
01:10:11,410 --> 01:10:13,540
中的主要内容是内存数据

1891
01:10:13,540 --> 01:10:15,220
系统的设计在概念上与磁盘写入系统有很大不同，

1892
01:10:15,220 --> 01:10:16,930
它是

1893
01:10:16,930 --> 01:10:17,620
同样的权利，你们

1894
01:10:17,620 --> 01:10:19,150
两个查询他们的索引不会

1895
01:10:19,150 --> 01:10:21,730
交易，但

1896
01:10:21,730 --> 01:10:24,130
这些系统的协议的实现

1897
01:10:24,130 --> 01:10:26,650
会有很大不同，好消息

1898
01:10:26,650 --> 01:10:29,110
也是，当我刚开始读研究生时，内存数据库

1899
01:10:29,110 --> 01:10:33,060
不再被认为是超级奇怪的

1900
01:10:33,060 --> 01:10:35,850
也许

1901
01:10:35,850 --> 01:10:38,620
十多年前的现在，但像 2007

1902
01:10:38,620 --> 01:10:42,160
年和 2006 年一样，它们被认为是一种

1903
01:10:42,160 --> 01:10:45,040
异国情调的系统，但现在尤其是

1904
01:10:45,040 --> 01:10:48,220
像 Redis 这样的系统，

1905
01:10:48,220 --> 01:10:49,690
如果人们变得更加 C，它们就会变得更加普遍

1906
01:10:49,690 --> 01:10:51,640
对内存系统的想法感到满意

1907
01:10:51,640 --> 01:10:54,820
，我要说的一件事是

1908
01:10:54,820 --> 01:10:57,370
，与我们在 SSD 中看到的游戏相比，近年来

1909
01:10:57,370 --> 01:10:59,650
DRAM 的价格和容量似乎停滞不前

1910
01:10:59,650 --> 01:11:01,620
，

1911
01:11:01,620 --> 01:11:04,960
所以在此之前我非常

1912
01:11:04,960 --> 01:11:07,810
看好哦 内存数据库

1913
01:11:07,810 --> 01:11:08,950
将接管法庭世界

1914
01:11:08,950 --> 01:11:10,360
为什么你会想要使用令人失望的

1915
01:11:10,360 --> 01:11:13,720
系统 II 认为这实际上

1916
01:11:13,720 --> 01:11:18,160
不是真的，我认为值得

1917
01:11:18,160 --> 01:11:21,010
看看我们可以做些什么来恢复

1918
01:11:21,010 --> 01:11:23,020
数据库系统中的 SSD 实际上

1919
01:11:23,020 --> 01:11:24,490
不必放慢速度并带来

1920
01:11:24,490 --> 01:11:25,960
面向磁盘的架构的所有开销，

1921
01:11:25,960 --> 01:11:27,760
所以我们会

1922
01:11:27,760 --> 01:11:29,050
在学期结束时讨论一点，但这

1923
01:11:29,050 --> 01:11:30,490
是我脑海中的一些东西，

1924
01:11:30,490 --> 01:11:33,100
我认为它会出现几个

1925
01:11:33,100 --> 01:11:34,950
学期中的时间

1926
01:11:34,950 --> 01:11:38,860
好的 所以只是为了完成

1927
01:11:38,860 --> 01:11:41,320
今天的工作 我将在本周五飞回来

1928
01:11:41,320 --> 01:11:43,630
，下周周二我将在校园里

1929
01:11:43,630 --> 01:11:45,430
，我们将进行背诵

1930
01:11:45,430 --> 01:11:48,160
以讨论

1931
01:11:48,160 --> 01:11:49,870
系统，然后在下周的周三课程中，

1932
01:11:49,870 --> 01:11:51,340
我们将开始讨论

1933
01:11:51,340 --> 01:11:53,380
多版本商业，因为

1934
01:11:53,380 --> 01:11:55,860
这是

1935
01:11:55,860 --> 01:11:58,330
每个人都使用的主要方法或协议，但它

1936
01:11:58,330 --> 01:11:59,680
不仅仅是与协议相比，它

1937
01:11:59,680 --> 01:12:01,960
会让你完成

1938
01:12:01,960 --> 01:12:03,400
数据系统的所有不同方面 所以

1939
01:12:03,400 --> 01:12:04,900
我们会开始了解

1940
01:12:04,900 --> 01:12:07,210
更多的细节，好的，

1941
01:12:07,210 --> 01:12:08,680


1942
01:12:08,680 --> 01:12:10,990


1943
01:12:10,990 --> 01:12:14,130


1944
01:12:14,130 --> 01:12:16,470
今天就到这里了

1945
01:12:16,470 --> 01:12:19,320
说你来了 我喝了一口，

1946
01:12:19,320 --> 01:12:21,510
和 Ned 一起度过今晚，这里叫做

1947
01:12:21,510 --> 01:12:24,510
Hokey 因为我很喜欢 Ice Cube，因为

1948
01:12:24,510 --> 01:12:27,990
你看起来很暴躁，去给我拿一

1949
01:12:27,990 --> 01:12:31,620
首 40 首歌，因为我需要

1950
01:12:31,620 --> 01:12:42,330
再踢一点 和我的帅哥说我很

1951
01:12:42,330 --> 01:12:45,950
高兴说我祈祷

