1
00:00:00,080 --> 00:00:16,550
哦，伙计们再次重新开始

2
00:00:16,550 --> 00:00:20,900
欢迎，抱歉上周离开，

3
00:00:20,900 --> 00:00:23,180
但我的意思是现在在城里这么

4
00:00:23,180 --> 00:00:24,680
快，我们会停下来看看我们的 DJ

5
00:00:24,680 --> 00:00:29,539
DJ 桌，所以我认为人们不会

6
00:00:29,539 --> 00:00:31,460
知道你有多糟糕，所以一旦你

7
00:00:31,460 --> 00:00:32,270
出现 人们有点人

8
00:00:32,270 --> 00:00:35,430
你可以做什么你可以写信

9
00:00:35,430 --> 00:00:41,650
[笑声]

10
00:00:45,380 --> 00:00:47,910
这是真的，是的，我们确实有一个课程DJ

11
00:00:47,910 --> 00:00:49,410
对，我一直都赢过一个，现在我有一个

12
00:00:49,410 --> 00:00:50,640
，你的夏天

13
00:00:50,640 --> 00:00:56,970
好吗，你会在那里做你的

14
00:00:56,970 --> 00:01:00,120
事情还好很棒是的还有

15
00:01:00,120 --> 00:01:09,560
什么是新的是的是的有那个是的

16
00:01:09,680 --> 00:01:12,420
我的意思是所以我们在卡内基梅隆大学仍然是一个数据库

17
00:01:12,420 --> 00:01:13,500
系统所以我们

18
00:01:13,500 --> 00:01:14,550
仍在研究这只是

19
00:01:14,550 --> 00:01:18,259
花费我所有的时间对你知道

20
00:01:18,350 --> 00:01:20,369
是的 是的，

21
00:01:20,369 --> 00:01:24,030
我确实让某人怀孕了好吧，所以

22
00:01:24,030 --> 00:01:25,140
让我们快速完成这件事

23
00:01:25,140 --> 00:01:27,270
吧，所以我只关心

24
00:01:27,270 --> 00:01:28,800
我生活中的两件事我说每个

25
00:01:28,800 --> 00:01:32,640
学期第一是我的妻子

26
00:01:32,640 --> 00:01:34,500
第二是数据库我不放弃

27
00:01:34,500 --> 00:01:36,869
任何东西 否则我的家人投票给

28
00:01:36,869 --> 00:01:38,970
特朗普我不和他们说话 我你知道我

29
00:01:38,970 --> 00:01:40,380
有一只很好的狗，但就像我

30
00:01:40,380 --> 00:01:41,789
没有任何其他爱好一样，

31
00:01:41,789 --> 00:01:44,670
它只是数据库正确，所以

32
00:01:44,670 --> 00:01:47,729
人们认为我说的是疯狂的话，

33
00:01:47,729 --> 00:01:50,640
所以如果我开始快速说话，我希望

34
00:01:50,640 --> 00:01:52,590
你打断我，让我慢下来

35
00:01:52,590 --> 00:01:54,479
告诉我再说一遍

36
00:01:54,479 --> 00:01:56,159
我说你听起来很蠢 你

37
00:01:56,159 --> 00:01:57,630
走得太快 慢了

38
00:01:57,630 --> 00:01:59,399
你也可以在你不

39
00:01:59,399 --> 00:02:01,259
明白我在说什么

40
00:02:01,259 --> 00:02:02,880
时打断我 我真的鼓励你 我希望

41
00:02:02,880 --> 00:02:04,590
你这样做 因为我知道这就像

42
00:02:04,590 --> 00:02:06,119
我不知道你们是否知道所以

43
00:02:06,119 --> 00:02:08,068
如果你不

44
00:02:08,068 --> 00:02:08,940
明白我在说什么请阻止我已经有一个

45
00:02:08,940 --> 00:02:10,769
服务器数据库相关的问题

46
00:02:10,769 --> 00:02:13,050
你无法阻止我或愚蠢的

47
00:02:13,050 --> 00:02:14,760
事情 你有一个关于区块链的问题，

48
00:02:14,760 --> 00:02:16,260
就像前几年一样 我不

49
00:02:16,260 --> 00:02:17,430
关心球链 好吧，

50
00:02:17,430 --> 00:02:19,049
这门课程不是关于块平面

51
00:02:19,049 --> 00:02:20,880
这不是我们在这里讨论的 如果

52
00:02:20,880 --> 00:02:23,220
你的身体上也有奇怪的皮疹

53
00:02:23,220 --> 00:02:24,840
不要与我们分享 上课前

54
00:02:24,840 --> 00:02:26,220
的班级这发生

55
00:02:26,220 --> 00:02:28,230
了第一次 很奇怪，不要那样做

56
00:02:28,230 --> 00:02:31,980
所以好吧这是什么意思所以

57
00:02:31,980 --> 00:02:34,440
这意味着我希望你

58
00:02:34,440 --> 00:02:36,060
尽可能多地打断我，不要

59
00:02:36,060 --> 00:02:37,290
尴尬，没有愚蠢

60
00:02:37,290 --> 00:02:39,480
的问题所以如果你有关于讲座的问题

61
00:02:39,480 --> 00:02:41,940
不要

62
00:02:41,940 --> 00:02:43,530
在课程结束时在我面前冷静下来 哦

63
00:02:43,530 --> 00:02:45,060
，第三张幻灯片你是什么意思

64
00:02:45,060 --> 00:02:46,530
所有这些我不会回答这些

65
00:02:46,530 --> 00:02:48,090
问题因为如果你

66
00:02:48,090 --> 00:02:49,500
在我说话的时候有问题那么其他人

67
00:02:49,500 --> 00:02:51,450
可能会 是一个问题，我宁愿只是

68
00:02:51,450 --> 00:02:53,010
在每个人面前讨论，而不是

69
00:02:53,010 --> 00:02:54,389
一群人说

70
00:02:54,389 --> 00:02:55,859
向前滑动怎么样 第六张幻灯片 永远不会

71
00:02:55,859 --> 00:02:58,109
再好了 所以我不会被

72
00:02:58,109 --> 00:02:59,819
冒犯 我不在乎

73
00:02:59,819 --> 00:03:02,190
如果你有问题就打断我 好吧，有

74
00:03:02,190 --> 00:03:06,870
任何问题，好吧，所以我也在

75
00:03:06,870 --> 00:03:09,450
Piazza 上发帖说，家庭作业已完成，

76
00:03:09,450 --> 00:03:12,269
将于下周 11 日到期，

77
00:03:12,269 --> 00:03:14,130
然后我们也将

78
00:03:14,130 --> 00:03:17,370
在下周在 github 上发布项目一，并且只是

79
00:03:17,370 --> 00:03:18,569
保留 考虑到这是这

80
00:03:18,569 --> 00:03:20,609
只是你 我们的日程安排谁

81
00:03:20,609 --> 00:03:21,870
在这里完成了第一个作业 我

82
00:03:21,870 --> 00:03:23,040
认为有人已经完成并获得了

83
00:03:23,040 --> 00:03:23,900


84
00:03:23,900 --> 00:03:26,250
满分 他们不是在这里很棒甚至更好

85
00:03:26,250 --> 00:03:29,760
好吧 所以我们再次给你一个

86
00:03:29,760 --> 00:03:31,560
续集字节文件 我们正在让你写

87
00:03:31,560 --> 00:03:32,670
一些简单的查询有点

88
00:03:32,670 --> 00:03:33,959
强迫你做我们

89
00:03:33,959 --> 00:03:35,459
在第二节课中讨论过的一些事情，

90
00:03:35,459 --> 00:03:37,049
这实际上是你唯一一次

91
00:03:37,049 --> 00:03:38,340
正确的查询本学期剩余时间的

92
00:03:38,340 --> 00:03:40,349
所有项目你

93
00:03:40,349 --> 00:03:42,750
将做的和它 将使用 C++ 并且所有

94
00:03:42,750 --> 00:03:44,150
的作业都是铅笔和纸

95
00:03:44,150 --> 00:03:46,590


96
00:03:46,590 --> 00:03:48,030


97
00:03:48,030 --> 00:03:51,079


98
00:03:51,079 --> 00:03:53,930


99
00:03:53,930 --> 00:03:57,390
的 至少最后两

100
00:03:57,390 --> 00:04:00,420
节课我们花时间

101
00:04:00,420 --> 00:04:01,560


102
00:04:01,560 --> 00:04:03,840
在逻辑层面

103
00:04:03,840 --> 00:04:05,640


104
00:04:05,640 --> 00:04:08,550


105
00:04:08,550 --> 00:04:10,980
讨论数据库

106
00:04:10,980 --> 00:04:12,620
是什么样子的 我要构建

107
00:04:12,620 --> 00:04:15,060
将管理这个数据库系统的软件

108
00:04:15,060 --> 00:04:16,200
好吧，这基本上是

109
00:04:16,200 --> 00:04:18,060
课程的内容，我们如何

110
00:04:18,060 --> 00:04:20,250
实际存储数据库，并

111
00:04:20,250 --> 00:04:22,530
允许执行查询，并且您已经

112
00:04:22,530 --> 00:04:23,760
从中干燥了新数据，

113
00:04:23,760 --> 00:04:27,300
因此总体大纲 课程

114
00:04:27,300 --> 00:04:29,040
再次我们已经涵盖了顶部的逻辑

115
00:04:29,040 --> 00:04:30,600
部分，它会从数据库中老化

116
00:04:30,600 --> 00:04:32,520
，现在我们开始

117
00:04:32,520 --> 00:04:35,010
浏览数据库的不同部分

118
00:04:35,010 --> 00:04:36,840
，一些一个一个，好像它们

119
00:04:36,840 --> 00:04:39,060
就像 不同的层，所以我们将开始

120
00:04:39,060 --> 00:04:40,410
讨论存储查询执行

121
00:04:40,410 --> 00:04:41,820
库尔恰托夫恢复，然后我们将

122
00:04:41,820 --> 00:04:43,050
在最后讨论分布式数据库和其他

123
00:04:43,050 --> 00:04:45,720
主题以及

124
00:04:45,720 --> 00:04:47,220
思考这个问题的方式这是

125
00:04:47,220 --> 00:04:48,930
对数据库

126
00:04:48,930 --> 00:04:50,880
外观的粗略近似 就像它只是一堆

127
00:04:50,880 --> 00:04:53,190
建立在彼此之上的层，所以

128
00:04:53,190 --> 00:04:55,410
我们将专注于本

129
00:04:55,410 --> 00:04:57,240
讲座和下一节关于磁盘

130
00:04:57,240 --> 00:04:58,979
管理器的讲座，我们如何实际将

131
00:04:58,979 --> 00:05:01,290
您知道的数据存储在磁盘上的文件上，然后再

132
00:05:01,290 --> 00:05:03,180
存储一次  我们知道我们

133
00:05:03,180 --> 00:05:04,530
将向系统中的上层公开什么 API

134
00:05:04,530 --> 00:05:06,539
我们开始向它添加这些额外的级别，

135
00:05:06,539 --> 00:05:07,890
直到最后我们拥有一个功能齐全的

136
00:05:07,890 --> 00:05:10,470
数据库管理系统 所以这就是

137
00:05:10,470 --> 00:05:11,550
我们正在谈论的思考方式

138
00:05:11,550 --> 00:05:13,080
点所以我们不再是续集的东西不再

139
00:05:13,080 --> 00:05:16,410
有关系模型的东西

140
00:05:16,410 --> 00:05:17,669
它的各个方面对于我们如何

141
00:05:17,669 --> 00:05:19,440
在我们的系统中做出不同的设计决策很重要

142
00:05:19,440 --> 00:05:22,500
但是我们你知道我们必须

143
00:05:22,500 --> 00:05:23,310
弄清楚我们实际上如何运行

144
00:05:23,310 --> 00:05:26,370
续集查询但是 这不像我们

145
00:05:26,370 --> 00:05:27,750
会担心如何编写你知道

146
00:05:27,750 --> 00:05:29,250
你知道复杂的续集查询因为

147
00:05:29,250 --> 00:05:31,110
我们已经这样做了，我们再次

148
00:05:31,110 --> 00:05:33,360
关注

149
00:05:33,360 --> 00:05:35,280
系统中不同层的不同级别

150
00:05:35,280 --> 00:05:36,810
，然后你就知道了

151
00:05:36,810 --> 00:05:40,289
正如我在第一堂课中所说的那样，

152
00:05:40,289 --> 00:05:42,510
这门课程也是关于构建

153
00:05:42,510 --> 00:05:44,550
面向磁盘的数据库管理系统的，所以

154
00:05:44,550 --> 00:05:46,350
只是重申我的意思

155
00:05:46,350 --> 00:05:48,090
，如果 Discordian 数据库系统

156
00:05:48,090 --> 00:05:50,760
是软件进行

157
00:05:50,760 --> 00:05:52,169
假设的系统 数据库的主要搜索

158
00:05:52,169 --> 00:05:54,590
位置在磁盘上

159
00:05:54,590 --> 00:05:57,360
，这意味着任何时候我们

160
00:05:57,360 --> 00:05:59,700
必须执行查询，它可能实际上

161
00:05:59,700 --> 00:06:01,620
想要运行，您知道想要访问

162
00:06:01,620 --> 00:06:03,450
不在内存中的数据，我们必须

163
00:06:03,450 --> 00:06:04,620
出去 磁盘并获取它

164
00:06:04,620 --> 00:06:06,780
沙子里有一堆组件

165
00:06:06,780 --> 00:06:08,639
我们如何设计我们的软件

166
00:06:08,639 --> 00:06:10,289
将基于这个假设来

167
00:06:10,289 --> 00:06:12,000
保护我们自己不会丢失数据

168
00:06:12,000 --> 00:06:14,220
因为你知道无效或不正确的

169
00:06:14,220 --> 00:06:14,560
数据

170
00:06:14,560 --> 00:06:16,240
所以这会

171
00:06:16,240 --> 00:06:17,290
渗透到整个过程中 整个

172
00:06:17,290 --> 00:06:18,790
系统，我们需要在任何

173
00:06:18,790 --> 00:06:20,139
给定时间意识到我们试图

174
00:06:20,139 --> 00:06:23,320
读取的东西不在内存中，所以为了

175
00:06:23,320 --> 00:06:25,510
进一步理解这一点，我们想要

176
00:06:25,510 --> 00:06:27,700
区分易失性和

177
00:06:27,700 --> 00:06:30,160
非易失性存储，所以本质上

178
00:06:30,160 --> 00:06:31,240
我们是什么 尝试做的是我们试图

179
00:06:31,240 --> 00:06:32,620
让数据系统管理

180
00:06:32,620 --> 00:06:35,410
数据从非易失性存储到

181
00:06:35,410 --> 00:06:37,990
易失性存储的移动所以我的意思

182
00:06:37,990 --> 00:06:40,000
是你

183
00:06:40,000 --> 00:06:44,080
对计算机存储层次结构的看法就像这样 是的，

184
00:06:44,080 --> 00:06:45,970
你有点从最底层

185
00:06:45,970 --> 00:06:47,740
开始，或者从最顶端开始，你会拥有

186
00:06:47,740 --> 00:06:49,690
非常快速非常

187
00:06:49,690 --> 00:06:51,400
昂贵的东西，它们非常小，所以

188
00:06:51,400 --> 00:06:53,200
思考这个的方式就像

189
00:06:53,200 --> 00:06:55,450
你拥有的顶部频谱 像 CPU

190
00:06:55,450 --> 00:06:58,900
寄存器或 CPU 缓存 l1 l2 l3 这些

191
00:06:58,900 --> 00:07:01,000
东西非常快，但它们的

192
00:07:01,000 --> 00:07:02,020
容量非常小，因为

193
00:07:02,020 --> 00:07:03,370
它们就像坐在

194
00:07:03,370 --> 00:07:05,979
CPU 本身上，然后我们将拥有 DRAM

195
00:07:05,979 --> 00:07:07,960
，然后我们将在其下方 让 SSD

196
00:07:07,960 --> 00:07:09,220


197
00:07:09,220 --> 00:07:11,740
在底部再次在网络存储中旋转这些硬盘驱动器

198
00:07:11,740 --> 00:07:13,240
它们非常大但速度要慢得多而且

199
00:07:13,240 --> 00:07:16,210
它们更便宜

200
00:07:16,210 --> 00:07:17,740
所以我们关心的二分法是这里的这条分割线

201
00:07:17,740 --> 00:07:20,289
所以这条线以上的任何东西都是

202
00:07:20,289 --> 00:07:27,850
不稳定的 这是否意味着是的，是的，

203
00:07:27,850 --> 00:07:29,560
她说这不是

204
00:07:29,560 --> 00:07:30,970
当你绝对断电时它不会持续存在所以所有

205
00:07:30,970 --> 00:07:33,970
这些存储设备都需要

206
00:07:33,970 --> 00:07:37,180
像电力一样恒定的能量来

207
00:07:37,180 --> 00:07:38,890
维持它们存储的任何东西

208
00:07:38,890 --> 00:07:40,350
你从你的计算机中提取电源

209
00:07:40,350 --> 00:07:42,610
在 DRAM 中的所有东西

210
00:07:42,610 --> 00:07:44,710
被擦除 CPU 缓存上的所有内容 被擦除

211
00:07:44,710 --> 00:07:46,180
低于此值的所有内容都是非易失性的，这意味着它

212
00:07:46,180 --> 00:07:48,100
不需要持续供电

213
00:07:48,100 --> 00:07:50,919
来持久化存储在其中的任何内容，因此

214
00:07:50,919 --> 00:07:52,300
这是高级别的那一刻，这

215
00:07:52,300 --> 00:07:53,650
是我们关心的主要事情 我们

216
00:07:53,650 --> 00:07:56,100
必须将数据从这里向上移动到这里

217
00:07:56,100 --> 00:07:58,450
还有其他方面事件，尽管这些

218
00:07:58,450 --> 00:08:00,430
事件将

219
00:08:00,430 --> 00:08:02,080
影响我们设计软件的方式

220
00:08:02,080 --> 00:08:03,639
，并且必须如何实际

221
00:08:03,639 --> 00:08:06,160
访问这些数据，因此如果它在易失性

222
00:08:06,160 --> 00:08:08,350
存储中，它是 将支持快速随机

223
00:08:08,350 --> 00:08:10,479
访问也许我们可以非常快速地跳转到

224
00:08:10,479 --> 00:08:12,220
存储设备中的任何类型的地址位置，无论我们访问访问的顺序如何

225
00:08:12,220 --> 00:08:16,030
，我们都会获得

226
00:08:16,030 --> 00:08:18,729
大致相同的性能

227
00:08:18,729 --> 00:08:21,070
我的意思是

228
00:08:21,070 --> 00:08:22,419
如果我跳转到这个位置这个位置

229
00:08:22,419 --> 00:08:24,310
也许回到另一个位置我

230
00:08:24,310 --> 00:08:26,440
会得到大约相同的

231
00:08:26,440 --> 00:08:28,570
延迟和相同的速度

232
00:08:28,570 --> 00:08:31,120
对不起他们将拥有的非易失性存储

233
00:08:31,120 --> 00:08:32,650
而不是字节可寻址

234
00:08:32,650 --> 00:08:34,030
访问以及如何块地址 sable

235
00:08:34,030 --> 00:08:36,940
访问，所以在字节可寻址访问中

236
00:08:36,940 --> 00:08:38,740
，这意味着我想在

237
00:08:38,740 --> 00:08:40,419
这个存储位置读取 64 位我可以只读取

238
00:08:40,419 --> 00:08:42,250
那 64 位并得到我

239
00:08:42,250 --> 00:08:44,290
想要的我过于简单化了，但这

240
00:08:44,290 --> 00:08:46,090
基本上是从程序员的

241
00:08:46,090 --> 00:08:48,220
角度来看我们作为 数据库系统

242
00:08:48,220 --> 00:08:51,970
开发人员 这就是我们在

243
00:08:51,970 --> 00:08:53,920
非易失性存储中看到的 我们不能

244
00:08:53,920 --> 00:08:56,530
只得到我们想要的 64 位 我们

245
00:08:56,530 --> 00:08:58,060
必须去获取

246
00:08:58,060 --> 00:09:00,400
包含我们想要的数据的块或页面 我们

247
00:09:00,400 --> 00:09:01,450
必须得到 与

248
00:09:01,450 --> 00:09:03,430
该页面相关的所有内容，所以我只想读取 64 位

249
00:09:03,430 --> 00:09:05,980
，并且您知道这是一个

250
00:09:05,980 --> 00:09:07,300
非易失性存储，我必须去获取

251
00:09:07,300 --> 00:09:08,830
它存储的 4 KB 页面

252
00:09:08,830 --> 00:09:10,210
，然后去挑选

253
00:09:10,210 --> 00:09:13,210
我想要的那部分 想要另一个方面，

254
00:09:13,210 --> 00:09:15,730
即这些系统

255
00:09:15,730 --> 00:09:17,760
通常还具有更快的顺序访问，

256
00:09:17,760 --> 00:09:20,980
这意味着 5v

257
00:09:20,980 --> 00:09:23,260
存储设备中的一堆连续块我可以更有效地做到这一点，

258
00:09:23,260 --> 00:09:24,820
而不仅仅是读取

259
00:09:24,820 --> 00:09:27,280
随机位置，这是最简单的

260
00:09:27,280 --> 00:09:28,960
可视化方法 这只是想想就像在

261
00:09:28,960 --> 00:09:30,670
大多数笔记本电脑上旋转硬盘驱动器一样，

262
00:09:30,670 --> 00:09:32,680
或者几乎每台笔记本电脑

263
00:09:32,680 --> 00:09:33,730
都没有配备旋转磁盘硬盘

264
00:09:33,730 --> 00:09:36,370
驱动器，但是在高温下，您基本上知道

265
00:09:36,370 --> 00:09:38,020
它的工作方式是您的

266
00:09:38,020 --> 00:09:39,460
手臂在物理上移动

267
00:09:39,460 --> 00:09:41,050
盘片就像转盘一样，并且

268
00:09:41,050 --> 00:09:43,810
已经组合了一次你必须

269
00:09:43,810 --> 00:09:44,980
跳到新位置你必须

270
00:09:44,980 --> 00:09:46,030
拿起手臂并将其移动到另一个

271
00:09:46,030 --> 00:09:47,560
位置，这是一个物理运动

272
00:09:47,560 --> 00:09:49,900
，它非常昂贵且速度慢 SSD

273
00:09:49,900 --> 00:09:50,980
没有这个问题，因为 它是

274
00:09:50,980 --> 00:09:54,160
固态的，但还有其他问题，因此

275
00:09:54,160 --> 00:09:56,020
在这些存储设备中，我们希望

276
00:09:56,020 --> 00:09:57,430
尝试最大限度地提高我们

277
00:09:57,430 --> 00:09:59,500
可以读取的顺序正确的数据量，而

278
00:09:59,500 --> 00:10:01,180
对于易失性存储中的这些数据，

279
00:10:01,180 --> 00:10:04,240
我们不太关心，因此出于以下

280
00:10:04,240 --> 00:10:06,310
目的 这门课我们只是要说

281
00:10:06,310 --> 00:10:08,140
DRAM 中的任何东西我们都

282
00:10:08,140 --> 00:10:10,330
将称之为内存

283
00:10:10,330 --> 00:10:11,860


284
00:10:11,860 --> 00:10:14,110


285
00:10:14,110 --> 00:10:16,210
在这里，我们

286
00:10:16,210 --> 00:10:18,250
只想说这是磁盘，对于本课程中将要讨论的所有

287
00:10:18,250 --> 00:10:19,600
大多数算法和大多数

288
00:10:19,600 --> 00:10:20,560
方法，

289
00:10:20,560 --> 00:10:23,140
我们不在乎是不是

290
00:10:23,140 --> 00:10:26,350
你知道它是其中的哪一个它

291
00:10:26,350 --> 00:10:27,220
不完全是 当我们谈论

292
00:10:27,220 --> 00:10:29,430
连接顺序访问很重要时是真的，

293
00:10:29,430 --> 00:10:32,080
但我们稍后会谈到，所以我

294
00:10:32,080 --> 00:10:33,310
认为教科书不会谈论

295
00:10:33,310 --> 00:10:34,750
网络存储他们通常总是

296
00:10:34,750 --> 00:10:36,220
当你看到这些层次结构

297
00:10:36,220 --> 00:10:38,260
的底部总是有磁带驱动器

298
00:10:38,260 --> 00:10:40,150
但是没有人再在这些数据库上运行数据库

299
00:10:40,150 --> 00:10:41,230
了，像灾难

300
00:10:41,230 --> 00:10:42,130
恢复

301
00:10:42,130 --> 00:10:44,110
网络存储这样的救济就像

302
00:10:44,110 --> 00:10:47,590
亚马逊上的 EBS 或 s3 所以我们不

303
00:10:47,590 --> 00:10:48,760
打算在顶部

304
00:10:48,760 --> 00:10:50,710
谈论这些事情的原因是您

305
00:10:50,710 --> 00:10:52,270
在 春季高级课程

306
00:10:52,270 --> 00:10:54,910
和我们在这门课上的目的

307
00:10:54,910 --> 00:10:57,370
本学期的这门课程无论如何都太慢

308
00:10:57,370 --> 00:10:59,640
了，谁在乎我们

309
00:10:59,640 --> 00:11:02,500
在高级课程中将东西放入 CP 寄存器的速度有多快，

310
00:11:02,500 --> 00:11:04,000
我们假设数据库

311
00:11:04,000 --> 00:11:05,500
总是他的 在 DRAM 中，因此这些

312
00:11:05,500 --> 00:11:07,000
事情实际上很重要，但是在

313
00:11:07,000 --> 00:11:08,410
整个学期中，我们不会真正

314
00:11:08,410 --> 00:11:10,450
谈论担心

315
00:11:10,450 --> 00:11:12,370
CPU 缓存中的事情，因为这无关紧要，因为

316
00:11:12,370 --> 00:11:15,970
现在进入磁盘的速度如此之慢我每年都在

317
00:11:15,970 --> 00:11:18,240
谈论这个 实际上有一

318
00:11:18,240 --> 00:11:20,620
类新的存储设备

319
00:11:20,620 --> 00:11:22,390
跨越了称为

320
00:11:22,390 --> 00:11:24,430
非易失性内存的界限 谁在这里

321
00:11:24,430 --> 00:11:27,610
听说过谁在这里听说过英特尔

322
00:11:27,610 --> 00:11:30,790
获得了内存 一二三

323
00:11:30,790 --> 00:11:32,290
好吧 是的 所以英特尔实际上是

324
00:11:32,290 --> 00:11:33,700
第一个制造商 散列标签

325
00:11:33,700 --> 00:11:35,470
发布这个每个人都在

326
00:11:35,470 --> 00:11:37,810
研究这个大约 15 20 年英特尔

327
00:11:37,810 --> 00:11:39,820
实际上把第一个是推出

328
00:11:39,820 --> 00:11:42,460
了第一个设备 所以它就像

329
00:11:42,460 --> 00:11:43,930
DRAM 位于暗槽中，但

330
00:11:43,930 --> 00:11:45,850
它是字节可寻址的，但它就像一个

331
00:11:45,850 --> 00:11:47,650
SSD，意思是如果你拉 机器上的电源

332
00:11:47,650 --> 00:11:49,770
可以保存你所有的数据，

333
00:11:49,770 --> 00:11:51,940
所以这太酷

334
00:11:51,940 --> 00:11:53,320
了，就像计算机的未来

335
00:11:53,320 --> 00:11:55,240
一样，最终我们将

336
00:11:55,240 --> 00:11:57,940
不得不重写这个类来实现 这

337
00:11:57,940 --> 00:11:59,830
是一个帐户，但我们还没有到那里它

338
00:11:59,830 --> 00:12:02,890
现在还没有广泛使用这是

339
00:12:02,890 --> 00:12:03,850
我一直在研究的

340
00:12:03,850 --> 00:12:05,560
东西所以这是我

341
00:12:05,560 --> 00:12:08,110
和我的第一个 PC 学生一起写的一本书我们

342
00:12:08,110 --> 00:12:09,460
基本上是他的论文他们 放入

343
00:12:09,460 --> 00:12:11,980
书本形式但我认为这是未来

344
00:12:11,980 --> 00:12:13,480
我们只是还没有广泛

345
00:12:13,480 --> 00:12:14,950
使用但你还不能进入亚马逊

346
00:12:14,950 --> 00:12:17,620
但最终有很多讨论

347
00:12:17,620 --> 00:12:19,330
如果你有

348
00:12:19,330 --> 00:12:22,570
非易失性内存会消失 是的 所以让我们

349
00:12:22,570 --> 00:12:24,630
谈谈这些事情有多慢

350
00:12:24,630 --> 00:12:26,890
所以互联网上有不同的表格

351
00:12:26,890 --> 00:12:27,940
有不同的

352
00:12:27,940 --> 00:12:29,530
数字 但这些大致相同

353
00:12:29,530 --> 00:12:31,030
你在同一个球场大致了解

354
00:12:31,030 --> 00:12:32,740
最重要的是

355
00:12:32,740 --> 00:12:33,850
这些之间不同的数量级

356
00:12:33,850 --> 00:12:34,830
存储设备，

357
00:12:34,830 --> 00:12:37,620
所以假设我需要

358
00:12:37,620 --> 00:12:39,880
从不同的存储设备中读取 64 位，如果

359
00:12:39,880 --> 00:12:43,420
我在 l1 缓存中，那么它就像半

360
00:12:43,420 --> 00:12:46,780
纳秒，如果它在 l2 l2 中，它是 7

361
00:12:46,780 --> 00:12:49,150
和 1 秒等等以获得

362
00:12:49,150 --> 00:12:52,900
真正的长 jus 长时间的延迟，

363
00:12:52,900 --> 00:12:54,820
这就是为什么我们在这门课上花了这么多时间

364
00:12:54,820 --> 00:12:55,939
担心

365
00:12:55,939 --> 00:12:58,549
我们如何才能尽量减少

366
00:12:58,549 --> 00:13:00,739
从磁盘读取数据的影响，

367
00:13:00,739 --> 00:13:01,669
因为

368
00:13:01,669 --> 00:13:04,939
100 纳秒和 150,000

369
00:13:04,939 --> 00:13:07,069
纳秒之间存在相当大的差异，因此对于每个

370
00:13:07,069 --> 00:13:08,269
查询 如果我们总是不得不退出

371
00:13:08,269 --> 00:13:10,279
磁盘，那么我们就搞砸了，事情

372
00:13:10,279 --> 00:13:11,779
基本上会陷入停顿

373
00:13:11,779 --> 00:13:12,829
，我们将无法完成任何工作

374
00:13:12,829 --> 00:13:14,869
，我意识到将其置于

375
00:13:14,869 --> 00:13:16,729
纳秒级对我们来说很难像 人类

376
00:13:16,729 --> 00:13:18,769
把我们的头包围，所以如果你只是

377
00:13:18,769 --> 00:13:21,769
用秒替换纳秒，那么你就会

378
00:13:21,769 --> 00:13:23,389
开始意识到这些数字

379
00:13:23,389 --> 00:13:26,329
实际上有多久是正确的，所以

380
00:13:26,329 --> 00:13:28,099
思考这个的方式就像

381
00:13:28,099 --> 00:13:29,629
你喜欢使用的另一个比喻来自

382
00:13:29,629 --> 00:13:32,899
著名的数据库研究员吉姆吉姆格雷 是

383
00:13:32,899 --> 00:13:35,359
说我想读一本书我想

384
00:13:35,359 --> 00:13:38,089
读一本书中的一页所以如果它在l1中

385
00:13:38,089 --> 00:13:39,439
那么就像

386
00:13:39,439 --> 00:13:40,819
在我面前在这张桌子上阅读这本书如果

387
00:13:40,819 --> 00:13:43,549
它在l2中那么它可能正在

388
00:13:43,549 --> 00:13:45,799
穿过ro  om 读它，如果它是一个 F 它在

389
00:13:45,799 --> 00:13:47,179
DRAM 中，我必须走到图书馆

390
00:13:47,179 --> 00:13:49,579
，然后现在你开始阅读这些你知道

391
00:13:49,579 --> 00:13:50,959
越来越大的数量级

392
00:13:50,959 --> 00:13:52,669
，如果你必须从磁带

393
00:13:52,669 --> 00:13:54,979
驱动器读取它就像飞行冥王星 阅读

394
00:13:54,979 --> 00:13:56,619
一本书中的一页，它只需要

395
00:13:56,619 --> 00:13:59,059
永远，这就是为什么人们不想

396
00:13:59,059 --> 00:14:00,439
在上面存储数据，但请注意，

397
00:14:00,439 --> 00:14:04,129
他们必须没事，所以

398
00:14:04,129 --> 00:14:05,989
我们在 DNA 系统中尝试做的目标

399
00:14:05,989 --> 00:14:08,539
是 我们想

400
00:14:08,539 --> 00:14:12,319
为应用程序提供一种错觉，即我们有

401
00:14:12,319 --> 00:14:13,909
足够的内存来将其整个数据库存储

402
00:14:13,909 --> 00:14:15,919
在内存中，本质上就像您知道

403
00:14:15,919 --> 00:14:17,299
我们的机器上有大量内存一样

404
00:14:17,299 --> 00:14:20,269
，我们想说我们想要

405
00:14:20,269 --> 00:14:21,589
存储的数据库超过

406
00:14:21,589 --> 00:14:23,929
我们可以使用的内存量，但

407
00:14:23,929 --> 00:14:25,309
您不必知道

408
00:14:25,309 --> 00:14:27,559
每次我们阅读

409
00:14:27,559 --> 00:14:29,899
或写正确的

410
00:14:29,899 --> 00:14:31,849
东西时都会停下来，这也是本课程的重点，

411
00:14:31,849 --> 00:14:33,739
接下来的三堂课实际上是关于

412
00:14:33,739 --> 00:14:36,409
我们如何小心 在任何时候

413
00:14:36,409 --> 00:14:37,669
我们 必须从磁盘读取某些内容或

414
00:14:37,669 --> 00:14:39,639
运行查询以最大程度地减少这种影响，

415
00:14:39,639 --> 00:14:41,509
并且我们将

416
00:14:41,509 --> 00:14:43,669
通过

417
00:14:43,669 --> 00:14:45,649
允许不同的线程或不同的

418
00:14:45,649 --> 00:14:47,059
查询同时运行来通过

419
00:14:47,059 --> 00:14:49,189
缓存内容来执行一系列不同的技巧来缓解此问题 预先计算一些

420
00:14:49,189 --> 00:14:50,629
数据

421
00:14:50,629 --> 00:14:51,709
，我们的

422
00:14:51,709 --> 00:14:53,389
数据库系统中有一大堆技巧，我们

423
00:14:53,389 --> 00:14:57,379
基本上可以避免这个

424
00:14:57,379 --> 00:15:00,649
长长的问题，所以让我们看一下

425
00:15:00,649 --> 00:15:03,470


426
00:15:03,470 --> 00:15:04,639
数据库系统外观的高级图 就像从

427
00:15:04,639 --> 00:15:05,989
我们在学期的这个时候进行关心的角度来看

428
00:15:05,989 --> 00:15:08,509
，然后

429
00:15:08,509 --> 00:15:09,740
我们将

430
00:15:09,740 --> 00:15:10,940
看到接下来的课程如何实际

431
00:15:10,940 --> 00:15:14,060
填写和设计这些东西，

432
00:15:14,060 --> 00:15:15,680
所以在最低层我们有

433
00:15:15,680 --> 00:15:18,710
磁盘，我们 拥有我们的一个或多个数据库

434
00:15:18,710 --> 00:15:21,830
文件并不重要，然后我们

435
00:15:21,830 --> 00:15:22,940
将通过

436
00:15:22,940 --> 00:15:25,910
不同的块或

437
00:15:25,910 --> 00:15:27,290


438
00:15:27,290 --> 00:15:29,780
页面来表示这些文件

439
00:15:29,780 --> 00:15:31,490
高一点的意思是

440
00:15:31,490 --> 00:15:34,700
一样的，所以现在我们将

441
00:15:34,700 --> 00:15:36,740
拥有一个叫做缓冲池的内存，

442
00:15:36,740 --> 00:15:38,030
这将集中在这个和下周的讲座上

443
00:15:38,030 --> 00:15:39,170
，这就是你

444
00:15:39,170 --> 00:15:40,370
将在第一个

445
00:15:40,370 --> 00:15:43,580
作业中实现的内容 项目所以

446
00:15:43,580 --> 00:15:45,230
在系统和执行引擎中有一些更高级别的层

447
00:15:45,230 --> 00:15:46,910
一个查询引擎我们

448
00:15:46,910 --> 00:15:48,440
不在乎它是什么但它会

449
00:15:48,440 --> 00:15:50,240
向我们的缓冲池发出请求并说

450
00:15:50,240 --> 00:15:52,970
嘿我想读取第 2 页 第 2 页

451
00:15:52,970 --> 00:15:54,230
不在内存中所以 我们必须查看

452
00:15:54,230 --> 00:15:56,270
磁盘上的页面目录并说这

453
00:15:56,270 --> 00:15:57,650
是我拥有的页面列表 在

454
00:15:57,650 --> 00:15:59,450
这里可以找到它们 所以我现在可以

455
00:15:59,450 --> 00:16:01,160
找到第 2 页的位置 我把它存入

456
00:16:01,160 --> 00:16:04,670
内存 现在我交出 对我来说，

457
00:16:04,670 --> 00:16:06,320
对不起，引擎这里是指向

458
00:16:06,320 --> 00:16:08,480
内存中第 2 页的指针，然后它可以立即

459
00:16:08,480 --> 00:16:10,070
解释它做任何我们

460
00:16:10,070 --> 00:16:12,320
不在乎的事情，所以这就是我们

461
00:16:12,320 --> 00:16:13,730
在这里关注的内容，至于接下来的三个

462
00:16:13,730 --> 00:16:15,320
讲座是如何 我们实际上

463
00:16:15,320 --> 00:16:19,910
在这里建造这个部分，所以今天和

464
00:16:19,910 --> 00:16:21,440
下周我们会做discu  ss

465
00:16:21,440 --> 00:16:23,930
数据是什么 下周磁盘上的文件将

466
00:16:23,930 --> 00:16:25,670
是缓冲池 然后

467
00:16:25,670 --> 00:16:26,660
稍后我们将讨论我们如何实际

468
00:16:26,660 --> 00:16:31,580
表示目录

469
00:16:31,580 --> 00:16:33,970


470
00:16:35,230 --> 00:16:37,089


471
00:16:37,089 --> 00:16:38,829
我试图让它

472
00:16:38,829 --> 00:16:40,360
看起来我的内存比我

473
00:16:40,360 --> 00:16:43,839
实际做的虚拟内存要多，所以

474
00:16:43,839 --> 00:16:44,800
现在我可能在想我已经

475
00:16:44,800 --> 00:16:47,680
在这里上过操作系统课程为什么我

476
00:16:47,680 --> 00:16:49,180
想让我的数据库像这样管理内存

477
00:16:49,180 --> 00:16:50,350
就像是在浪费时间

478
00:16:50,350 --> 00:16:52,829
，他们的操作系统已经可以

479
00:16:52,829 --> 00:16:56,589
很好地做到这一点，这不是一个好主意，

480
00:16:56,589 --> 00:16:59,860
所以在操作系统的说法中，我们

481
00:16:59,860 --> 00:17:01,209
将称之为内存映射文件，或者

482
00:17:01,209 --> 00:17:04,780
在 POSIX 中有一个称为 em map 的系统调用

483
00:17:04,780 --> 00:17:06,400
，本质上这是做什么的 它是否

484
00:17:06,400 --> 00:17:08,470
需要磁盘上的文件，然后您告诉

485
00:17:08,470 --> 00:17:10,329
操作系统将文件页面映射

486
00:17:10,329 --> 00:17:12,669
到我的进程的地址空间

487
00:17:12,669 --> 00:17:15,640
，现在我可以读取和写入

488
00:17:15,640 --> 00:17:18,609
那些内存位置，而

489
00:17:18,609 --> 00:17:20,500
不是操作系统带来的内存，我

490
00:17:20,500 --> 00:17:22,599
可以 写信给它 然后最终如果我

491
00:17:22,599 --> 00:17:23,949
能告诉它埃丝特为我写

492
00:17:23,949 --> 00:17:25,540
出来我可以做一个 N 同步并将它写

493
00:17:25,540 --> 00:17:27,849
回磁盘所以我们

494
00:17:27,849 --> 00:17:29,320
基本上放弃了

495
00:17:29,320 --> 00:17:30,880
对内存来回移动

496
00:17:30,880 --> 00:17:32,200
数据的控制 然后，我们的内存磁盘

497
00:17:32,200 --> 00:17:33,820
并让操作系统

498
00:17:33,820 --> 00:17:39,250
为我们管理它，所以再次在高

499
00:17:39,250 --> 00:17:40,600
层次上看起来像这样我们

500
00:17:40,600 --> 00:17:43,000
在磁盘文件上有一堆页面，然后

501
00:17:43,000 --> 00:17:44,710
在内存中操作系统有它的虚拟内存

502
00:17:44,710 --> 00:17:46,750
页表和 我们有物理内存，

503
00:17:46,750 --> 00:17:48,400
所以发生的事情是应用程序说

504
00:17:48,400 --> 00:17:50,710
嘿我想读取第 1 页

505
00:17:50,710 --> 00:17:52,150
它在虚拟内存中查找

506
00:17:52,150 --> 00:17:53,590


507
00:17:53,590 --> 00:17:55,480


508
00:17:55,480 --> 00:17:58,179
将它取回

509
00:17:58,179 --> 00:17:59,860
物理内存页面，然后

510
00:17:59,860 --> 00:18:01,390
更新我们的页表，现在指向

511
00:18:01,390 --> 00:18:04,480
该内存位置，所以如果我来了

512
00:18:04,480 --> 00:18:06,070
，我想读取第 3 页，我会

513
00:18:06,070 --> 00:18:08,020
经历相同的过程，将它提取到内存中

514
00:18:08,020 --> 00:18:10,179
，然后应用程序可以 做任何

515
00:18:10,179 --> 00:18:13,330
一次，但现在让我们说 我读了第 2 页，有

516
00:18:13,330 --> 00:18:17,190
什么问题

517
00:18:17,690 --> 00:18:19,309
，没有可用的物理

518
00:18:19,309 --> 00:18:21,769
内存页面来放置

519
00:18:21,769 --> 00:18:24,230
该页面的详细信息，因此我需要

520
00:18:24,230 --> 00:18:25,759
决定删除哪些页面

521
00:18:25,759 --> 00:18:28,340
，而在执行此操作时，

522
00:18:28,340 --> 00:18:30,230
最终必须停止数据库

523
00:18:30,230 --> 00:18:32,090
系统安装我请求

524
00:18:32,090 --> 00:18:34,850
这个页面的线程，因为现在

525
00:18:34,850 --> 00:18:36,710
磁盘，你知道操作系统的磁盘调度

526
00:18:36,710 --> 00:18:37,759
程序会去

527
00:18:37,759 --> 00:18:39,230
支付磁盘获取它并带入

528
00:18:39,230 --> 00:18:43,159
内存所以你有技巧有

529
00:18:43,159 --> 00:18:44,870
办法从 应用程序的

530
00:18:44,870 --> 00:18:46,370
观点，可能不得不读取

531
00:18:46,370 --> 00:18:48,019
一些不在内存中的东西，所以也许

532
00:18:48,019 --> 00:18:49,519
我可以把它交给另一个线程，这样

533
00:18:49,519 --> 00:18:51,049
它就会停顿而不是我，因为我总是

534
00:18:51,049 --> 00:18:52,250
想继续做有用的工作，

535
00:18:52,250 --> 00:18:55,100
因为我想

536
00:18:55,100 --> 00:18:57,860
在我不得不做的时候减轻停顿 正确地取出磁盘但

537
00:18:57,860 --> 00:18:59,600
本质上该操作并不

538
00:18:59,600 --> 00:19:01,009
确切知道我们在做

539
00:19:01,009 --> 00:19:02,149
什么对

540
00:19:02,149 --> 00:19:03,230
数据系统正在做什么一无所知它只是看到

541
00:19:03,230 --> 00:19:04,850
一堆读写两个p 年龄它

542
00:19:04,850 --> 00:19:06,710
不理解任何高级

543
00:19:06,710 --> 00:19:08,690
语义或查询是什么 deta

544
00:19:08,690 --> 00:19:12,230
想要正确读取所以我们希望我们

545
00:19:12,230 --> 00:19:14,600
想要通过使用虚拟内存通过

546
00:19:14,600 --> 00:19:16,370
使用内存映射文件我们放弃

547
00:19:16,370 --> 00:19:18,679
控制或放弃

548
00:19:18,679 --> 00:19:20,600
我们在数据库系统中拥有的知识传递

549
00:19:20,600 --> 00:19:22,279
给我们 那是盲目的，什么都不

550
00:19:22,279 --> 00:19:25,549
知道，所以如果我们只

551
00:19:25,549 --> 00:19:28,279
读取数据，那么我们可以通过一堆系统调用

552
00:19:28,279 --> 00:19:30,529
来缓解其中的一些

553
00:19:30,529 --> 00:19:33,230
问题，但是如果我们开始写东西，

554
00:19:33,230 --> 00:19:35,840
那么它就会变得有问题，因为

555
00:19:35,840 --> 00:19:37,490
现在操作系统不知道 某些页面

556
00:19:37,490 --> 00:19:38,870
必须在

557
00:19:38,870 --> 00:19:40,850
其他页面再次执行之前刷新磁盘 稍后我们将

558
00:19:40,850 --> 00:19:42,019
在讨论日志记录

559
00:19:42,019 --> 00:19:45,710
和并发控制时介绍这一点 但 OSS 认为

560
00:19:45,710 --> 00:19:47,149
是的 我需要我需要写出一些

561
00:19:47,149 --> 00:19:48,620
数据意味着继续写它 它

562
00:19:48,620 --> 00:19:49,759
不知道这是否是

563
00:19:49,759 --> 00:19:52,580
一件好事，所以你

564
00:19:52,580 --> 00:19:55,340
通过给它提示来解决这个问题，比如使用 em

565
00:19:55,340 --> 00:19:56,419
建议告诉它你将如何

566
00:19:56,419 --> 00:19:57,769
访问某些页面，无论它是

567
00:19:57,769 --> 00:19:59,509
按顺序读取还是随机读取 如何防止

568
00:19:59,509 --> 00:20:02,090
页面从一开始就被调出，虽然

569
00:20:02,090 --> 00:20:03,440
你可以锁定并不能阻止它

570
00:20:03,440 --> 00:20:05,720
被写出，这又可能

571
00:20:05,720 --> 00:20:07,429
仍然是一个问题，这是当你

572
00:20:07,429 --> 00:20:11,149
告诉它刷新的时候，所以我会说

573
00:20:11,149 --> 00:20:12,769
虚拟内存的内存映射文件

574
00:20:12,769 --> 00:20:14,870
听起来像 seducti 我们

575
00:20:14,870 --> 00:20:16,730
想在我们的数据库系统中使用的东西，

576
00:20:16,730 --> 00:20:17,990
每年都有一些学生说为什么我们

577
00:20:17,990 --> 00:20:19,129
要做所有这些缓冲池的事情为什么

578
00:20:19,129 --> 00:20:20,480
我们不能让哦让我们为我们做这件事

579
00:20:20,480 --> 00:20:23,240
相信我你不想做

580
00:20:23,240 --> 00:20:25,039
这是因为您可能会遇到

581
00:20:25,039 --> 00:20:26,240
性能瓶颈并且会

582
00:20:26,240 --> 00:20:29,269
遇到正确性问题，

583
00:20:29,269 --> 00:20:31,100
因此实际上使用它们的系统并不多，

584
00:20:31,100 --> 00:20:32,190


585
00:20:32,190 --> 00:20:33,930
最著名的两个可能是 Monet

586
00:20:33,930 --> 00:20:36,570
DB 和 LM DB 级别的 DB，您

587
00:20:36,570 --> 00:20:39,210
从 Google 那里听说过是另一个 一个弹性

588
00:20:39,210 --> 00:20:41,730
搜索是搜索引擎或

589
00:20:41,730 --> 00:20:45,150
文档存储，然后 Raving BB 是以色列的 JSON

590
00:20:45,150 --> 00:20:49,080
数据库，所以所有这些人都使用

591
00:20:49,080 --> 00:20:51,030
和映射，但是

592
00:20:51,030 --> 00:20:53,520
你必须做很多额外的事情来防止

593
00:20:53,520 --> 00:20:55,140
操作系统做不正确的事情，或者有

594
00:20:55,140 --> 00:20:56,250


595
00:20:56,250 --> 00:20:58,290
您必须对我们的内容做出某些限制或假设

596
00:20:58,290 --> 00:21:01,230
被允许这样做是

597
00:21:01,230 --> 00:21:03,120
不对的所以这就像我的意思是还有

598
00:21:03,120 --> 00:21:05,030
一些但没有太多所以

599
00:21:05,030 --> 00:21:06,930
这里缺少的我们缺少

600
00:21:06,930 --> 00:21:08,760
所有主要的数据库系统也许是我的

601
00:21:08,760 --> 00:21:11,520
续集 Oracle db2 续集服务器这些人都没有

602
00:21:11,520 --> 00:21:12,960
使用 em map cuz 这是一个坏

603
00:21:12,960 --> 00:21:14,100
主意，因为你放弃了控制权

604
00:21:14,100 --> 00:21:15,810
，而数据学生总是可以做得

605
00:21:15,810 --> 00:21:17,790
比

606
00:21:17,790 --> 00:21:20,370
操作系统试图弄清楚的更好，所以有些

607
00:21:20,370 --> 00:21:22,380
系统在非常

608
00:21:22,380 --> 00:21:24,120
有限的情况下仍然使用 MF 这实际上已经

609
00:21:24,120 --> 00:21:25,530
过时了 MIT 我的意思是 上周我和这些人聊过，

610
00:21:25,530 --> 00:21:27,450
记忆 Siegel 完全摆脱了 MF 的

611
00:21:27,450 --> 00:21:30,300
续集 Dwight 有一个特殊的

612
00:21:30,300 --> 00:21:31,560
引擎，你必须告诉我想将 M

613
00:21:31,560 --> 00:21:33,090
地图用于一些你知道的嵌入式设备

614
00:21:33,090 --> 00:21:34,500
，这实际上是你

615
00:21:34,500 --> 00:21:36,000
想要使用的，但默认你不使用'  t get

616
00:21:36,000 --> 00:21:38,490
this influx DB 只将它用于

617
00:21:38,490 --> 00:21:40,560
只读缓存，但我

618
00:21:40,560 --> 00:21:41,760
总是喜欢给它讲的例子是

619
00:21:41,760 --> 00:21:44,610
MongoDB 这里的每个人都听说过

620
00:21:44,610 --> 00:21:46,260
MongoDB，这是一个著名的 JSON

621
00:21:46,260 --> 00:21:49,440
数据库系统，所以当他们第一次

622
00:21:49,440 --> 00:21:51,210
开始时 继承人他们的默认存储

623
00:21:51,210 --> 00:21:52,830
引擎或存储管理器正在使用 M

624
00:21:52,830 --> 00:21:54,840
映射，他们必须做很多废话

625
00:21:54,840 --> 00:21:56,310
才能使这个东西真正工作，

626
00:21:56,310 --> 00:21:58,440
但这是一个超级按钮皮条客

627
00:21:58,440 --> 00:22:01,050
对他们来说是一个很大的瓶颈，然后

628
00:22:01,050 --> 00:22:03,300
他们提出了 钱，然后

629
00:22:03,300 --> 00:22:04,800
他们做的第一件事就是摆脱了 em

630
00:22:04,800 --> 00:22:06,330
map 并得到了它，你知道买了这个

631
00:22:06,330 --> 00:22:07,680
叫做 wire Tire 的东西，这是一个非

632
00:22:07,680 --> 00:22:10,170
毫米存储引擎，所以如果地图是个好

633
00:22:10,170 --> 00:22:11,640
主意，这些人拥有世界上所有的钱

634
00:22:11,640 --> 00:22:13,020
一些顶级工程师他们本

635
00:22:13,020 --> 00:22:14,730
可以想通的，但它只是

636
00:22:14,730 --> 00:22:18,540
变得站不住脚，所以如果我在这个班级死了，

637
00:22:18,540 --> 00:22:20,340
而你想有一个纪念

638
00:22:20,340 --> 00:22:22,560
，就说安迪讨厌 M 地图，

639
00:22:22,560 --> 00:22:23,820
你甚至可以公开说这些

640
00:22:23,820 --> 00:22:25,100
话，好吧，

641
00:22:25,100 --> 00:22:27,210
我们是 实际上在纸上写一篇论文

642
00:22:27,210 --> 00:22:29,520
，他们让今年并实际

643
00:22:29,520 --> 00:22:30,840
证明这是一个坏主意，

644
00:22:30,840 --> 00:22:33,780
所以我希望

645
00:22:33,780 --> 00:22:34,560
你从中得到的主要收获是，

646
00:22:34,560 --> 00:22:36,420
数据库系统是哦，它总是可以

647
00:22:36,420 --> 00:22:38,640
做得更好，它总是确切地知道什么是

648
00:22:38,640 --> 00:22:40,050
什么 查询是 tr  ying

649
00:22:40,050 --> 00:22:41,700
知道工作负载是什么样的，

650
00:22:41,700 --> 00:22:43,440
因此它可以做出最好的

651
00:22:43,440 --> 00:22:45,090
决定，操作系统不知道任何

652
00:22:45,090 --> 00:22:46,590
它只是看到一堆再次读取和

653
00:22:46,590 --> 00:22:49,170
写入读取和写入调用

654
00:22:49,170 --> 00:22:50,400
所以我们将讨论的一些事情

655
00:22:50,400 --> 00:22:52,170
如果我们不使用地图，我们可以在学期末做这

656
00:22:52,170 --> 00:22:54,480
件事就像

657
00:22:54,480 --> 00:22:56,340
预取更好的更换政策

658
00:22:56,340 --> 00:22:58,590
更好地再次安排操作系统是

659
00:22:58,590 --> 00:23:00,240
一种通用皮卡车而

660
00:23:00,240 --> 00:23:01,650
我们可以调整我们的系统看起来像

661
00:23:01,650 --> 00:23:04,050
保时捷或法拉利一样 正是我们

662
00:23:04,050 --> 00:23:07,020
想要为应用程序做的所以另一个

663
00:23:07,020 --> 00:23:08,130
主要收获是

664
00:23:08,130 --> 00:23:09,450
操作系统不是你的朋友，我们

665
00:23:09,450 --> 00:23:10,830
不想依赖我们希望尽可能避免它，

666
00:23:10,830 --> 00:23:12,300
因为它会

667
00:23:12,300 --> 00:23:14,010
做出可能有害的决定 我们的

668
00:23:14,010 --> 00:23:15,960
戴维斯系统，所以它就像一个敌人，你

669
00:23:15,960 --> 00:23:17,880
需要它来生存，但理想情况下，你

670
00:23:17,880 --> 00:23:21,030
不想和它说话，好吧，

671
00:23:21,030 --> 00:23:22,440
所以对于数据库存储，这是我们

672
00:23:22,440 --> 00:23:24,390
今天要关注的，所以

673
00:23:24,390 --> 00:23:27,210
我们必须解决两个主要问题 车

674
00:23:27,210 --> 00:23:28,650
第一个是我们将如何表示

675
00:23:28,650 --> 00:23:31,560
磁盘上文件上的数据，第二个

676
00:23:31,560 --> 00:23:34,410
是我们如何实际管理

677
00:23:34,410 --> 00:23:35,940


678
00:23:35,940 --> 00:23:38,130
磁盘文件和缓冲池之间的 Muta 内存，所以对于

679
00:23:38,130 --> 00:23:39,570
今天的讲座，我们是

680
00:23:39,570 --> 00:23:41,430
下节课要关注这个问题 把这个问题搞定

681
00:23:41,430 --> 00:23:42,990
，然后当我们

682
00:23:42,990 --> 00:23:44,010
在下周三谈论缓冲池时开始，

683
00:23:44,010 --> 00:23:45,540
我们将关注第二个

684
00:23:45,540 --> 00:23:48,540
问题 好的，所以今天的

685
00:23:48,540 --> 00:23:49,860
讲座我们将继续讨论

686
00:23:49,860 --> 00:23:51,570
第一个问题 我们实际上将如何

687
00:23:51,570 --> 00:23:54,000
在磁盘上的文件上表示数据库

688
00:23:54,000 --> 00:23:56,220
所以我们首先讨论如何

689
00:23:56,220 --> 00:23:59,520
跨页面序列组织数据库

690
00:23:59,520 --> 00:24:01,470
现在让我们讨论我们

691
00:24:01,470 --> 00:24:03,420
实际上如何将页面存储在

692
00:24:03,420 --> 00:24:05,400
这些文件中 然后让我们谈谈 关于

693
00:24:05,400 --> 00:24:06,930
实际上是什么 元组

694
00:24:06,930 --> 00:24:09,660
在这些页面中看起来像

695
00:24:09,660 --> 00:24:11,100
什么 所以我们将在宏观

696
00:24:11,100 --> 00:24:14,070
层面深入了解 你知道深入

697
00:24:14,070 --> 00:24:15,810
了解我们实际存储的数据内部

698
00:24:15,810 --> 00:24:19,590
所以最后

699
00:24:19,590 --> 00:24:21,540
那天数据库只是

700
00:24:21,540 --> 00:24:24,240
磁盘上的一堆文件，一些系统存储了

701
00:24:24,240 --> 00:24:25,680
数据库有一个文件，如 sequel light

702
00:24:25,680 --> 00:24:26,850
做的第一个作业是你

703
00:24:26,850 --> 00:24:29,040
下载整个数据库的 DB 文件

704
00:24:29,040 --> 00:24:30,180
并将其封装在

705
00:24:30,180 --> 00:24:32,700
单个文件中，但大多数其他系统

706
00:24:32,700 --> 00:24:36,030
将东西存储在多个文件中，所以

707
00:24:36,030 --> 00:24:37,710
在这里看看数据

708
00:24:37,710 --> 00:24:38,910
目录，我看到了骨头 Postgres

709
00:24:38,910 --> 00:24:39,510
你会看到一堆不同的

710
00:24:39,510 --> 00:24:41,580
目录成熟的文件你这样

711
00:24:41,580 --> 00:24:43,500
做是因为你知道数据库可能

712
00:24:43,500 --> 00:24:45,360
非常大，如 PB 而你不

713
00:24:45,360 --> 00:24:47,160
不想让你知道你不想把

714
00:24:47,160 --> 00:24:48,870
文件的水龙头和限制打到

715
00:24:48,870 --> 00:24:52,170
文件的大小，所以操作系统

716
00:24:52,170 --> 00:24:53,250
对

717
00:24:53,250 --> 00:24:54,930
这些文件中的内容一无所知，它只是有一堆

718
00:24:54,930 --> 00:24:56,700
二进制数据 操作系统，

719
00:24:56,700 --> 00:24:58,740
它们并不特殊，但

720
00:24:58,740 --> 00:25:00,990
这些数据文件的格式

721
00:25:00,990 --> 00:25:03,540
通常是专有的或特定于

722
00:25:03,540 --> 00:25:04,530
数据库测量系统的，

723
00:25:04,530 --> 00:25:06,390
因此这意味着您不能将续集

724
00:25:06,390 --> 00:25:08,400
Lite 文件放入目录中

725
00:25:08,400 --> 00:25:10,050
我的续集，我认为我的续集

726
00:25:10,050 --> 00:25:12,210
将能够正确阅读它们总是

727
00:25:12,210 --> 00:25:13,500
他们总是专门用于

728
00:25:13,500 --> 00:25:16,620
任何软件所以这些文件

729
00:25:16,620 --> 00:25:17,940
紧随其后 漂亮的戴维斯我们

730
00:25:17,940 --> 00:25:19,890
通常只是将它们存储在

731
00:25:19,890 --> 00:25:21,300
顶部 操作系统

732
00:25:21,300 --> 00:25:24,990
为我们提供的常规文件系统 ext3 ext4 现在无论 Windows

733
00:25:24,990 --> 00:25:27,900
网络有什么我忘记了这些

734
00:25:27,900 --> 00:25:29,370
只是操作系统看到一堆

735
00:25:29,370 --> 00:25:31,230
文件我们依靠文件系统

736
00:25:31,230 --> 00:25:34,500
为我们提供基本的读写 API

737
00:25:34,500 --> 00:25:36,750
在 1980 年代人们确实尝试过 构建

738
00:25:36,750 --> 00:25:38,640


739
00:25:38,640 --> 00:25:41,460
在原始存储设备上使用自定义文件系统的数据库系统，

740
00:25:41,460 --> 00:25:43,320
比如说你放下一个新的硬盘

741
00:25:43,320 --> 00:25:45,630
驱动器而不是格式化它，你

742
00:25:45,630 --> 00:25:47,730
知道将它设置为 NTFS 或者当

743
00:25:47,730 --> 00:25:50,309
你说 FS 或 xtxt 为你说螺丝所有这些

744
00:25:50,309 --> 00:25:51,809
给我 滚动存储设备，我将

745
00:25:51,809 --> 00:25:54,240
授予我自己管理实际

746
00:25:54,240 --> 00:25:57,630
存储在其中的内容 一些

747
00:25:57,630 --> 00:25:58,920
企业系统，如

748
00:25:58,920 --> 00:26:00,330
企业含义，

749
00:26:00,330 --> 00:26:02,580
如 Oracle db2 和 sequel 服务器等高端系统

750
00:26:02,580 --> 00:26:04,830
仍将执行此操作，但大多数 新的

751
00:26:04,830 --> 00:26:06,059
数据库初创公司是你给

752
00:26:06,059 --> 00:26:07,530
他的任何在过去 10

753
00:26:07,530 --> 00:26:10,170
年或 15 年内问世的东西都做不到这一点，

754
00:26:10,170 --> 00:26:11,730
因为

755
00:26:11,730 --> 00:26:13,559
为你的数据库系统制作你自己的自定义文件系统的工程努力

756
00:26:13,559 --> 00:26:15,360
是不值得的，

757
00:26:15,360 --> 00:26:17,670
你可能像一个 10% 的改进，但

758
00:26:17,670 --> 00:26:19,080
现在你知道你正在管理

759
00:26:19,080 --> 00:26:21,450
自己的水龙头，这是一个很大的混乱，它

760
00:26:21,450 --> 00:26:22,530
使你的东西不那么便携，因为现在

761
00:26:22,530 --> 00:26:24,570
当亚马逊

762
00:26:24,570 --> 00:26:28,830
和其他哈佛供应商所以

763
00:26:28,830 --> 00:26:30,929
我们正在构建时，你无法轻松运行它 本质上现在

764
00:26:30,929 --> 00:26:32,040
又是所谓的存储管理器，

765
00:26:32,040 --> 00:26:33,720
有时也称为存储引擎

766
00:26:33,720 --> 00:26:35,700
，然后这是

767
00:26:35,700 --> 00:26:36,840
我们数据库系统组件中的软件部分

768
00:26:36,840 --> 00:26:39,770
，负责

769
00:26:39,770 --> 00:26:42,630
维护磁盘上的数据库文件，

770
00:26:42,630 --> 00:26:47,340
现在我们可以进行读取和写入

771
00:26:47,340 --> 00:26:49,710
并让操作系统调度

772
00:26:49,710 --> 00:26:51,179
一些更高端的数据库系统

773
00:26:51,179 --> 00:26:54,059
实际上在文件系统正上方有一个填充层

774
00:26:54,059 --> 00:26:55,710
，它

775
00:26:55,710 --> 00:26:57,210
允许戴维森进行一些磁盘

776
00:26:57,210 --> 00:27:00,090
调度，你这样做 他的设置就像我知道我

777
00:27:00,090 --> 00:27:01,410
有一堆线程

778
00:27:01,410 --> 00:27:03,360
写入彼此靠近的块

779
00:27:03,360 --> 00:27:05,100
我可以将它们组合在一起并执行

780
00:27:05,100 --> 00:27:07,290
单个写入请求写入操作系统

781
00:27:07,290 --> 00:27:08,610
可以执行这些操作但同样它

782
00:27:08,610 --> 00:27:10,740
不知道到底是什么 上面这个

783
00:27:10,740 --> 00:27:12,270
不知道上面的语义是什么

784
00:27:12,270 --> 00:27:15,150
它电机系统不这样做

785
00:27:15,150 --> 00:27:16,710
然后对于我们将在这里工作的项目

786
00:27:16,710 --> 00:27:18,990
我们不这样做它通常

787
00:27:18,990 --> 00:27:32,610
用于更高的是的一个问题是我

788
00:27:32,610 --> 00:27:35,280
说大多数数据库并将

789
00:27:35,280 --> 00:27:38,220
文件拆分为

790
00:27:38,220 --> 00:27:39,540
多个文件，因为您没有

791
00:27:39,540 --> 00:27:41,280
达到操作系统的文件大小限制

792
00:27:41,280 --> 00:27:43,140
是否有任何优化可以

793
00:27:43,140 --> 00:27:50,970
将内容放入内存中是的只是一个文件

794
00:27:50,970 --> 00:27:53,190
哦俄罗斯人只是文件有一个

795
00:27:53,190 --> 00:27:54,690
限制它可以在

796
00:27:54,690 --> 00:27:59,460
内存中使用虚拟内存的大小数量没有当我们

797
00:27:59,460 --> 00:28:01,950
与我们交谈时，无论交换大小

798
00:28:01,950 --> 00:28:04,350
是操作系统可以让您存储的内容，但

799
00:28:04,350 --> 00:28:06,390
如果它是本质上限制

800
00:28:06,390 --> 00:28:09,800
了您可用的物理内存

801
00:28:15,170 --> 00:28:17,640
她的问题 是会 最好有

802
00:28:17,640 --> 00:28:19,590
一个文件，因为这样你就

803
00:28:19,590 --> 00:28:21,330
可以摆脱

804
00:28:21,330 --> 00:28:24,630
拥有多个文件

805
00:28:24,630 --> 00:28:26,850
的开销，你不喜欢像 inode 这样的开销

806
00:28:26,850 --> 00:28:29,070
，你必须找到它去打开一个文件

807
00:28:29,070 --> 00:28:40,980
或什么好 所以你说的像

808
00:28:40,980 --> 00:28:44,460
元数据一样，如果我有一个

809
00:28:44,460 --> 00:28:46,050
文件，那么我有一个文件名，

810
00:28:46,050 --> 00:28:48,000
我的文件系统中有一个 inode

811
00:28:48,000 --> 00:28:50,130
指向它，如果我有多个文件

812
00:28:50,130 --> 00:28:51,750
，我有多个 inode 条目

813
00:28:51,750 --> 00:28:53,160
或每个 一个人有自己的文件名，

814
00:28:53,160 --> 00:28:54,030


815
00:28:54,030 --> 00:28:56,250
你知道的很多冥想者都在引用它，但就像

816
00:28:56,250 --> 00:28:59,190
那可能是一千字节的元数据一样，

817
00:28:59,190 --> 00:29:00,630
如果你的数据库是 1

818
00:29:00,630 --> 00:29:02,430
PB，谁在乎你有

819
00:29:02,430 --> 00:29:06,660
一堆文件名是对的，我认为真的很大规模，

820
00:29:06,660 --> 00:29:07,800
它没有”  t

821
00:29:07,800 --> 00:29:12,990
有所作为 II 现在认为对于现代

822
00:29:12,990 --> 00:29:14,190
文件系统来说，这不再是一个真正的问题

823
00:29:14,190 --> 00:29:16,080
，因为您可以拥有 EB 级，

824
00:29:16,080 --> 00:29:19,110
您知道单个文件是 EB 级，但是

825
00:29:19,110 --> 00:29:20,910
在 90 年代或 2000 年代初期，

826
00:29:20,910 --> 00:29:22,380
当您像 fat32 一样运行时，

827
00:29:22,380 --> 00:29:23,900
您可以 只有一个 4 GB 的文件

828
00:29:23,900 --> 00:29:25,020


829
00:29:25,020 --> 00:29:27,540
，那是在过去它更重要的日子里，

830
00:29:27,540 --> 00:29:29,340
现在不是那么重要，但即便如此，

831
00:29:29,340 --> 00:29:30,480
元数据也无关紧要，

832
00:29:30,480 --> 00:29:39,000
是的，他的声明是这不

833
00:29:39,000 --> 00:29:40,410
限制您可以

834
00:29:40,410 --> 00:29:42,120
打开的文件数量通常是打开的文件 处理

835
00:29:42,120 --> 00:29:43,890
它们是你可以创建的东西，

836
00:29:43,890 --> 00:29:45,240
因此你必须有权限

837
00:29:45,240 --> 00:29:46,860
才能做到这一点，这是真的，所以如果

838
00:29:46,860 --> 00:29:48,270
你去看看一堆不同数据系统的调整指南或

839
00:29:48,270 --> 00:29:50,100
设置指南，

840
00:29:50,100 --> 00:29:51,810
他们会谈论像

841
00:29:51,810 --> 00:29:53,640
调整这个 内核参数

842
00:29:53,640 --> 00:29:54,870
喜悦你们有很多人知道这个数字我

843
00:29:54,870 --> 00:29:56,430
记下或文件处理过绝对

844
00:29:56,430 --> 00:30:02,490
是的好棒极了所以

845
00:30:02,490 --> 00:30:03,480
我们正在尝试构建一个存储管理器

846
00:30:03,480 --> 00:30:05,010
并且存储管理器负责

847
00:30:05,010 --> 00:30:07,440
在磁盘上维护这些文件以及

848
00:30:07,440 --> 00:30:09,120
它是否 一个文件或多个文件

849
00:30:09,120 --> 00:30:12,120
都没有关系，所以现在在这些

850
00:30:12,120 --> 00:30:15,180
文件中，我们将把它们组织为一

851
00:30:15,180 --> 00:30:18,600
组页面，因此我们的存储

852
00:30:18,600 --> 00:30:19,770
管理器将跟踪我们将要进行的

853
00:30:19,770 --> 00:30:20,970
所有读取和写入 对

854
00:30:20,970 --> 00:30:23,160
这些页面进行处理，就像您跟踪木头

855
00:30:23,160 --> 00:30:24,720
可用空间一样 我们有多少空间可以

856
00:30:24,720 --> 00:30:28,110
用于在我们的页面中存储新数据，

857
00:30:28,110 --> 00:30:30,330
因此页面本质上只是一个固定大小的

858
00:30:30,330 --> 00:30:33,510
块或数据块，

859
00:30:33,510 --> 00:30:35,580
我们将要组织我们的 文件，你

860
00:30:35,580 --> 00:30:38,640
知道这些块，所以一个页面可以

861
00:30:38,640 --> 00:30:41,190
包含任何东西，它包含

862
00:30:41,190 --> 00:30:43,020
实际的元组数据数据库本身

863
00:30:43,020 --> 00:30:45,660
包含元数据索引

864
00:30:45,660 --> 00:30:47,190
从存储管理的角度来看日志记录

865
00:30:47,190 --> 00:30:49,170
这并不重要，但我们

866
00:30:49,170 --> 00:30:50,610
总是必须将内容存储在

867
00:30:50,610 --> 00:30:54,000
单个 页面所以现在一些数据库系统

868
00:30:54,000 --> 00:30:58,560
会要求你让

869
00:30:58,560 --> 00:31:00,720
页面是自包含的，我的意思

870
00:31:00,720 --> 00:31:02,370
是你

871
00:31:02,370 --> 00:31:04,530
需要知道如何解释和

872
00:31:04,530 --> 00:31:07,170
理解页面内容的所有信息必须存储

873
00:31:07,170 --> 00:31:09,750
在页面中 所以让我举个

874
00:31:09,750 --> 00:31:11,580
例子假设我有一个表

875
00:31:11,580 --> 00:31:14,340
，我有一个表有 10 列，它们

876
00:31:14,340 --> 00:31:15,630
有不同的类型，但我调用

877
00:31:15,630 --> 00:31:16,830
create table 并创建不同属性的表，

878
00:31:16,830 --> 00:31:19,290
所以我可以 获取

879
00:31:19,290 --> 00:31:21,240
有关存储在一页中的表中内容的元数据

880
00:31:21,240 --> 00:31:23,820
，然后是所有

881
00:31:23,820 --> 00:31:25,770
元组或为存储在另一页中的该表付费的元

882
00:31:25,770 --> 00:31:28,260
数据，所以现在的问题是，

883
00:31:28,260 --> 00:31:30,930
如果我的磁盘出现故障，例如我的

884
00:31:30,930 --> 00:31:32,670
数据中心着火，我的磁盘会

885
00:31:32,670 --> 00:31:34,710
融化 我丢失了那一页，它告诉

886
00:31:34,710 --> 00:31:37,170
我现在模式的布局是什么

887
00:31:37,170 --> 00:31:38,429


888
00:31:38,429 --> 00:31:40,110
我不知道如何轻松解释

889
00:31:40,110 --> 00:31:41,940
我的小管

890
00:31:41,940 --> 00:31:44,519
页面的内容，因此某些系统（例如 Oracle）

891
00:31:44,519 --> 00:31:46,320
需要所有元数据

892
00:31:46,320 --> 00:31:47,759
关于怎么说这里是该

893
00:31:47,759 --> 00:31:49,950
页面中的内容必须在页面本身内

894
00:31:49,950 --> 00:31:52,019
，这样如果您丢失任何其他页面，它

895
00:31:52,019 --> 00:31:53,519
不会影响您知道您丢失了

896
00:31:53,519 --> 00:31:54,799
一页它不会影响任何其他页面

897
00:31:54,799 --> 00:31:57,269
您认为这有点开销

898
00:31:57,269 --> 00:31:59,399
这看起来很疯狂，他们再次进行

899
00:31:59,399 --> 00:32:02,009
灾难恢复，所以现在

900
00:32:02,009 --> 00:32:03,509
机器再次着火，你丢失了

901
00:32:03,509 --> 00:32:06,450
一堆页面，你可以

902
00:32:06,450 --> 00:32:07,559
打开一个十六进制编辑器并尝试

903
00:32:07,559 --> 00:32:09,269
通过查看paté来重建数据库的内容

904
00:32:09,269 --> 00:32:11,129
一次一页 并且

905
00:32:11,129 --> 00:32:12,509
您需要的有关该页面内容的所有元数据

906
00:32:12,509 --> 00:32:15,470
都存储在其自身中，

907
00:32:15,470 --> 00:32:19,019
所以所有重要的事情都

908
00:32:19,019 --> 00:32:20,190
需要了解的是，我们

909
00:32:20,190 --> 00:32:21,749
不会在页面内混合不同类型的

910
00:32:21,749 --> 00:32:24,720
数据

911
00:32:24,720 --> 00:32:26,309
我们可以拥有一些研究系统来做到这一点 你

912
00:32:26,309 --> 00:32:27,809
知道一个页面有元组数据和日志

913
00:32:27,809 --> 00:32:29,789
记录数据用于我们这里的目的，

914
00:32:29,789 --> 00:32:31,379
大多数系统他们不这样做

915
00:32:31,379 --> 00:32:32,610
就像这里是一个页面并且只有源

916
00:32:32,610 --> 00:32:34,320
元组这里是一个只存储

917
00:32:34,320 --> 00:32:37,799
索引信息的页面所以现在每个页面都

918
00:32:37,799 --> 00:32:39,840
将被给出 一个唯一的内部

919
00:32:39,840 --> 00:32:41,610
标识符，数据库系统

920
00:32:41,610 --> 00:32:44,129
将为我们生成一个页面 ID，

921
00:32:44,129 --> 00:32:46,379
然后我们将拥有一个

922
00:32:46,379 --> 00:32:47,820
间接层，当我们谈论存储时，这将是一个

923
00:32:47,820 --> 00:32:48,899
反复出现的主题，

924
00:32:48,899 --> 00:32:50,730
我们有一个间接层

925
00:32:50,730 --> 00:32:52,980
，它将允许 我们将页面 ID 映射

926
00:32:52,980 --> 00:32:55,889
到文件中的某个位置，并且

927
00:32:55,889 --> 00:32:59,220
设置正确，我们想要这样做，因为

928
00:32:59,220 --> 00:33:00,809
现在在封面之下我们可以开始

929
00:33:00,809 --> 00:33:02,820
在你周围移动页面，如果我们开始

930
00:33:02,820 --> 00:33:04,919
压缩 磁盘或将它设置为

931
00:33:04,919 --> 00:33:06,659
另一个磁盘，它不会改变我们的

932
00:33:06,659 --> 00:33:08,700
页面 ID 因为我们有这个页面

933
00:33:08,700 --> 00:33:10,710
目录 说你想要第 1 2 3 页 这里是

934
00:33:10,710 --> 00:33:13,860
去哪里找到它 所以有

935
00:33:13,860 --> 00:33:15,720
一堆页面页面概念我们需要

936
00:33:15,720 --> 00:33:18,570
讨论 把它放在真实计算机如何工作的上下文中，

937
00:33:18,570 --> 00:33:21,419
所以在最低

938
00:33:21,419 --> 00:33:22,710
级别我们有所谓的硬件

939
00:33:22,710 --> 00:33:25,830
页面，这是您从实际存储设备本身获得的页面 API 或

940
00:33:25,830 --> 00:33:27,960
页面访问级别

941
00:33:27,960 --> 00:33:30,059
我只

942
00:33:30,059 --> 00:33:31,799
知道 SSD 或旋转 磁盘硬盘驱动器

943
00:33:31,799 --> 00:33:34,320
公开这通常是四千字节

944
00:33:34,320 --> 00:33:36,570
然后在上面你有一个

945
00:33:36,570 --> 00:33:39,299
操作系统页面，这就像

946
00:33:39,299 --> 00:33:40,440
你从存储

947
00:33:40,440 --> 00:33:42,330
设备中取出东西并将其放入内存一样，它们也将其

948
00:33:42,330 --> 00:33:44,009
表示为内部

949
00:33:44,009 --> 00:33:45,990
页面，这通常是

950
00:33:45,990 --> 00:33:48,149
在 Linux 和 Windows 中，默认情况下通常为 4 KB

951
00:33:48,149 --> 00:33:50,279
之类的东西

952
00:33:50,279 --> 00:33:52,889
，您可以在其中打开大页面，您可以将一个

953
00:33:52,889 --> 00:33:54,570
1 GB 的页面分解为

954
00:33:54,570 --> 00:33:57,480
maunsell 4 KB 的恐怖页面，但

955
00:33:57,480 --> 00:33:59,820
出于我们的目的，我们不在乎 关于

956
00:33:59,820 --> 00:34:01,019
我们在此处的数据库页面上关心的事情

957
00:34:01,019 --> 00:34:03,690
，这将隐藏

958
00:34:03,690 --> 00:34:06,720
在不同的系统之间，因此

959
00:34:06,720 --> 00:34:09,270
在 512 字节的

960
00:34:09,270 --> 00:34:10,440
低端，就像嵌入式系统之类的 Seigle Light 之类的东西，

961
00:34:10,440 --> 00:34:12,359
但在高端，您将

962
00:34:12,359 --> 00:34:13,949
拥有 16 个字节 ele 字节可能

963
00:34:13,949 --> 00:34:16,469
就像我的续集一样，所以不同的数据库

964
00:34:16,469 --> 00:34:17,790
系统做不同的事情，

965
00:34:17,790 --> 00:34:19,369
所有这些都有不同的权衡，

966
00:34:19,369 --> 00:34:22,589
不过我们要关心的主要

967
00:34:22,589 --> 00:34:24,899
事情是港口

968
00:34:24,899 --> 00:34:28,230
页面是最低的

969
00:34:28,230 --> 00:34:30,060
我们对存储设备进行原子写入的级别

970
00:34:30,060 --> 00:34:33,060
，通常为 4 KB，所以

971
00:34:33,060 --> 00:34:34,649
我的意思是说我需要修改

972
00:34:34,649 --> 00:34:37,020
一堆数据，港口只能

973
00:34:37,020 --> 00:34:39,418
保证如果我进行写入并刷新

974
00:34:39,418 --> 00:34:41,730
到磁盘，如果它只能

975
00:34:41,730 --> 00:34:45,149
保证在 4 KB 的时间它会是

976
00:34:45,149 --> 00:34:48,869
原子的所以我很兴奋我的意思是我的坏

977
00:34:48,869 --> 00:34:50,668
所以如果我说我需要写 16

978
00:34:50,668 --> 00:34:53,668
KB 我可以尝试写我说

979
00:34:53,668 --> 00:34:55,469
我告诉磁盘嘿为我写 16 KB

980
00:34:55,469 --> 00:34:58,980
可能会在你知道之前崩溃

981
00:34:58,980 --> 00:35:01,140
写入前 8 KB 然后它

982
00:35:01,140 --> 00:35:02,670
在写入接下来的 8 KB 之前崩溃

983
00:35:02,670 --> 00:35:04,470
，然后你回来，现在

984
00:35:04,470 --> 00:35:05,819
你有一个撕裂的权利，你只能看到

985
00:35:05,819 --> 00:35:06,900
前半部分和后半部分，

986
00:35:06,900 --> 00:35:09,690
因为港口一次只能保证 4

987
00:35:09,690 --> 00:35:14,099
KB 好吧 这个会

988
00:35:14,099 --> 00:35:15,540
出现这个 我们稍后会

989
00:35:15,540 --> 00:35:16,829
在讨论日志记录和商业时再讨论

990
00:35:16,829 --> 00:35:18,660
这个 但这是我们需要

991
00:35:18,660 --> 00:35:21,119
我们需要注意的事情 再次

992
00:35:21,119 --> 00:35:22,260
有不同的系统做不同的

993
00:35:22,260 --> 00:35:24,480
事情 高端系统如

994
00:35:24,480 --> 00:35:27,240
Oracle 续集服务器 和 db2 你

995
00:35:27,240 --> 00:35:28,500
实际上可以调整它所以你说我想

996
00:35:28,500 --> 00:35:29,579
开始有 4 KB 8

997
00:35:29,579 --> 00:35:31,440
KB 或 16 KB II 你

998
00:35:31,440 --> 00:35:33,660
甚至可以改变说 4 个索引页存储

999
00:35:33,660 --> 00:35:35,280
更大的页面大小然后数据页

1000
00:35:35,280 --> 00:35:37,740
有点小你可以发疯 可以做

1001
00:35:37,740 --> 00:35:40,410
很多不同的事情 所以

1002
00:35:40,410 --> 00:35:41,849
现在我们想谈谈我们将如何

1003
00:35:41,849 --> 00:35:44,160
表示页面存储

1004
00:35:44,160 --> 00:35:46,619
架构 所以同样有不同的

1005
00:35:46,619 --> 00:35:48,060
方法来做到这一点 对此有不同

1006
00:35:48,060 --> 00:35:50,670
的权衡

1007
00:35:50,670 --> 00:35:52,500
常见的将是堆文件

1008
00:35:52,500 --> 00:35:54,810
组织，因此我们将重点关注这

1009
00:35:54,810 --> 00:35:57,000
一点，但要理解的是，

1010
00:35:57,000 --> 00:35:59,040
在存储管理器的最低级别的这一点上，

1011
00:35:59,040 --> 00:36:00,359
我们不

1012
00:36:00,359 --> 00:36:01,619
关心页面中的实际内容，我们不关心

1013
00:36:01,619 --> 00:36:03,240
关心是索引数据

1014
00:36:03,240 --> 00:36:05,790


1015
00:36:05,790 --> 00:36:06,010


1016
00:36:06,010 --> 00:36:08,560


1017
00:36:08,560 --> 00:36:12,490


1018
00:36:12,490 --> 00:36:16,120


1019
00:36:16,120 --> 00:36:18,430
还是元组数据 以

1020
00:36:18,430 --> 00:36:22,690
随机顺序存储，所以

1021
00:36:22,690 --> 00:36:25,120
如果我

1022
00:36:25,120 --> 00:36:27,640
一个一个地插入元组，关系模型没有任何顺序

1023
00:36:27,640 --> 00:36:30,040
我不能保证它们会以

1024
00:36:30,040 --> 00:36:33,370
这种方式存储在磁盘上，因为这

1025
00:36:33,370 --> 00:36:34,660
无关紧要，因为我编写了续集

1026
00:36:34,660 --> 00:36:36,160
查询和 没有

1027
00:36:36,160 --> 00:36:39,580
排序的概念，所以我们需要再次拥有的 API

1028
00:36:39,580 --> 00:36:41,680
能够一次读写和

1029
00:36:41,680 --> 00:36:44,170
访问页面，并且

1030
00:36:44,170 --> 00:36:45,790
能够迭代

1031
00:36:45,790 --> 00:36:47,620
我们拥有的每个页面，以防我们需要进行

1032
00:36:47,620 --> 00:36:49,950
顺序扫描 在整个表格中，

1033
00:36:49,950 --> 00:36:51,940
我们将有一些补充 所有元数据来

1034
00:36:51,940 --> 00:36:54,040
跟踪我们有哪些页面，哪些页面

1035
00:36:54,040 --> 00:36:55,330
有可用空间，这样如果我们

1036
00:36:55,330 --> 00:36:57,190
需要插入新数据，我们就知道在哪里可以找到

1037
00:36:57,190 --> 00:36:59,490
一个页面继续前进并在内部做正确的事情，

1038
00:36:59,490 --> 00:37:01,330
我们可以

1039
00:37:01,330 --> 00:37:03,760
在一堆中表示这个热球

1040
00:37:03,760 --> 00:37:06,880
在最低层我们可以用不同的方式

1041
00:37:06,880 --> 00:37:08,560
组织这些和页面，然后在

1042
00:37:08,560 --> 00:37:10,360
这些页面中我们可以用

1043
00:37:10,360 --> 00:37:12,700
不同的数据结构来表示它们，所以让我们首先

1044
00:37:12,700 --> 00:37:14,140
谈谈做链表，因为

1045
00:37:14,140 --> 00:37:15,340
这是一种愚蠢的方式来做到这一点，

1046
00:37:15,340 --> 00:37:16,540
否则实际上没有人这样做 但它

1047
00:37:16,540 --> 00:37:18,430
存在然后我们会看到页面

1048
00:37:18,430 --> 00:37:20,940
目录方式这是一种更好的方法

1049
00:37:20,940 --> 00:37:23,590
所以我们将再次这样做的方式

1050
00:37:23,590 --> 00:37:25,300
目标是我们在这里尝试做的

1051
00:37:25,300 --> 00:37:27,280
是我们试图在我的

1052
00:37:27,280 --> 00:37:29,920
文件我有一堆页面

1053
00:37:29,920 --> 00:37:32,020
你知道哪些页面你知道这些页面在哪里

1054
00:37:32,020 --> 00:37:33,430
以及什么样的你知道他们

1055
00:37:33,430 --> 00:37:34,960
是否有数据一路他们有

1056
00:37:34,960 --> 00:37:37,480
空闲空间让我存储东西所以在

1057
00:37:37,480 --> 00:37:40,750
这个堆父亲说的标题中

1058
00:37:40,750 --> 00:37:42,610
对于这个链接 列表 我们

1059
00:37:42,610 --> 00:37:44,380
只有两个指针 我们有一个

1060
00:37:44,380 --> 00:37:45,790
指针表示这

1061
00:37:45,790 --> 00:37:47,380
是我在我的文件

1062
00:37:47,380 --> 00:37:49,330
中的空闲页面列表 这是一个

1063
00:37:49,330 --> 00:37:51,540
实际上完全被占用

1064
00:37:51,540 --> 00:37:53,710
的页面列表 然后这只是一个

1065
00:37:53,710 --> 00:37:55,720
链接列表，所以

1066
00:37:55,720 --> 00:37:57,010
这些页面存储在哪里无关紧要

1067
00:37:57,010 --> 00:37:58,930
是否连续无关紧要 我只是

1068
00:37:58,930 --> 00:38:00,430
我现在只有指针并说嘿

1069
00:38:00,430 --> 00:38:02,290
这里是你知道这里是你知道的数据

1070
00:38:02,290 --> 00:38:04,120
这里是我的

1071
00:38:04,120 --> 00:38:05,590
链接列表的第一页 他们被占用了

1072
00:38:05,590 --> 00:38:07,690
，这里有一个指向下一个的指针，

1073
00:38:07,690 --> 00:38:09,490
所以如果我想说给我找一个页面，

1074
00:38:09,490 --> 00:38:11,440
一个免费的页面，比如商店的东西，我可以

1075
00:38:11,440 --> 00:38:13,360
按照免费页面列表查看这里

1076
00:38:13,360 --> 00:38:14,980
，你知道在 traverse 中，直到我

1077
00:38:14,980 --> 00:38:16,360
找到一些东西 它有足够的空间

1078
00:38:16,360 --> 00:38:18,109
来存储我想要存储的内容，

1079
00:38:18,109 --> 00:38:20,150
并且因为我们可能需要

1080
00:38:20,150 --> 00:38:21,529
以相反的顺序进行迭代，所以我们也需要

1081
00:38:21,529 --> 00:38:26,539
在返回途中的指针是的

1082
00:38:26,539 --> 00:38:27,619
问题是为什么堆文件

1083
00:38:27,619 --> 00:38:30,109
在高层次上是无序

1084
00:38:30,109 --> 00:38:34,940
的 我们要保存的数据 ring

1085
00:38:34,940 --> 00:38:37,299
不需要在我们正确插入时订购，

1086
00:38:37,299 --> 00:38:40,730
所以如果我插入三个元组，我可以

1087
00:38:40,730 --> 00:38:43,099
插入我可以在我的页面布局中

1088
00:38:43,099 --> 00:38:44,809
实际在页面内部我可以有

1089
00:38:44,809 --> 00:38:47,119
元组三元组二二一我

1090
00:38:47,119 --> 00:38:48,710
不需要放置 他们按

1091
00:38:48,710 --> 00:38:56,390
顺序给出正确的所以这个问题如果你

1092
00:38:56,390 --> 00:38:58,430
必须寻找一个带有

1093
00:38:58,430 --> 00:39:00,400
这些链接列表的特定页面我必须反转

1094
00:39:00,400 --> 00:39:02,299
整个链接列表如果我

1095
00:39:02,299 --> 00:39:05,900
可以绝对是的这很糟糕这是一个

1096
00:39:05,900 --> 00:39:11,450
坏主意是他的问题 是

1097
00:39:11,450 --> 00:39:12,680
如果它是订购的，你总是可以

1098
00:39:12,680 --> 00:39:14,989
更快地搜索，所以有不同的费率

1099
00:39:14,989 --> 00:39:18,829
折扣，所以我没有元数据来说明

1100
00:39:18,829 --> 00:39:21,499
我在哪里有免费页面所以我

1101
00:39:21,499 --> 00:39:23,779
现在需要插入一些东西我现在要插入

1102
00:39:23,779 --> 00:39:25,099
它我自从你必须 进行

1103
00:39:25,099 --> 00:39:26,900
顺序扫描并查看每一

1104
00:39:26,900 --> 00:39:28,190
页，直到我找到一个有可用

1105
00:39:28,190 --> 00:39:31,339
空间的页面或以这种方法在这里

1106
00:39:31,339 --> 00:39:32,630


1107
00:39:32,630 --> 00:39:34,099


1108
00:39:34,099 --> 00:39:34,940
这样做我是说如果我不需要，这

1109
00:39:34,940 --> 00:39:37,190
就是它的工作原理 ed 如果我在

1110
00:39:37,190 --> 00:39:38,989
这里有这个，那么我得到这个去按照这个

1111
00:39:38,989 --> 00:39:40,910
指针找到第一个空闲页面，

1112
00:39:40,910 --> 00:39:42,049
看看它是否有足够的空间

1113
00:39:42,049 --> 00:39:44,779
来存储我想要存储的内容这是一个权衡我

1114
00:39:44,779 --> 00:39:47,329
可以要么去你知道几乎二分

1115
00:39:47,329 --> 00:39:48,589
搜索 准确地找到我想要的页面

1116
00:39:48,589 --> 00:39:51,980
或者我可以做我可以做这个

1117
00:39:51,980 --> 00:39:57,559
链表语句你可以维护

1118
00:39:57,559 --> 00:39:59,890
它的有序集自由页面

1119
00:39:59,890 --> 00:40:12,950
和填充页面看起来他通常

1120
00:40:12,950 --> 00:40:14,930
使用链接列表使用一种治疗链接列表

1121
00:40:14,930 --> 00:40:17,509
仍然可以排序 是的，所以你可以

1122
00:40:17,509 --> 00:40:18,680
说好吧，说我

1123
00:40:18,680 --> 00:40:20,029
从这个页面中删除了所有的元组，这是它的第二

1124
00:40:20,029 --> 00:40:22,279
页，这是第一页，这是

1125
00:40:22,279 --> 00:40:24,230
第三页，所以我可以将它插入

1126
00:40:24,230 --> 00:40:27,369
这两个家伙之间确保

1127
00:40:28,140 --> 00:40:36,570
顺序就像我们制作两个不同的或一个

1128
00:40:36,570 --> 00:40:42,630
理想情况下，在页面上，但我再次认为

1129
00:40:42,630 --> 00:40:45,660
您的页面 ID 就像

1130
00:40:45,660 --> 00:40:48,840
在其中设置的一样，这

1131
00:40:48,840 --> 00:40:50,310
不是堆文件顶部没有任何逻辑内容，

1132
00:40:50,310 --> 00:40:53,820


1133
00:40:53,820 --> 00:40:56,850
如果您理解的话，让我们离线链接到麦田

1134
00:40:56,850 --> 00:40:59,910
问题在这里或好吧让我们k

1135
00:40:59,910 --> 00:41:01,260
如果你有问题，我们

1136
00:41:01,260 --> 00:41:04,020
会进一步讨论我的意思是主要的泰勒

1137
00:41:04,020 --> 00:41:04,860
这是一个坏主意

1138
00:41:04,860 --> 00:41:07,110
没有人这样做所以我

1139
00:41:07,110 --> 00:41:09,090
不想过多地关注它人们

1140
00:41:09,090 --> 00:41:11,400
通常做的是拥有一个页面目录

1141
00:41:11,400 --> 00:41:14,250
并且为此 一个是

1142
00:41:14,250 --> 00:41:15,990
我们现在在文件的标题中有一个页面

1143
00:41:15,990 --> 00:41:19,860
，它将维护从

1144
00:41:19,860 --> 00:41:24,840
页面 ID 到它们都设置的映射，然后我们

1145
00:41:24,840 --> 00:41:25,950
还可以

1146
00:41:25,950 --> 00:41:27,960
在这个目录中维护一些额外的元数据，说嘿

1147
00:41:27,960 --> 00:41:29,190
这里是免费的数量

1148
00:41:29,190 --> 00:41:31,380
我在特定页面中可用的空间，所以

1149
00:41:31,380 --> 00:41:33,510
现在当我想说我想

1150
00:41:33,510 --> 00:41:35,550
插入一些数据时我不必去你

1151
00:41:35,550 --> 00:41:37,260
知道扫描该列表我可以查看

1152
00:41:37,260 --> 00:41:38,670
我的页面目录并

1153
00:41:38,670 --> 00:41:41,820
找到我需要的一切 因此，如果我的页面

1154
00:41:41,820 --> 00:41:43,440
只是像这样按顺序排列，

1155
00:41:43,440 --> 00:41:45,540
那么这只是到 Widow 的映射，

1156
00:41:45,540 --> 00:41:49,470
它们就位于正确的位置，因此重要的

1157
00:41:49,470 --> 00:41:50,850
事情可以追溯到我们

1158
00:41:50,850 --> 00:41:52,680
讨论

1159
00:41:52,680 --> 00:41:55,650
的硬件原子权限，所以现在我有了

1160
00:41:55,650 --> 00:41:57,840
很多元数据就是这样 '

1161
00:41:57,840 --> 00:41:59,790
对我实际页面中内容的总结

1162
00:41:59,790 --> 00:42:02,070
，我必须保持同步，但

1163
00:42:02,070 --> 00:42:04,020
实际上我不能保证这一点，

1164
00:42:04,020 --> 00:42:07,230
因为港口不能保证

1165
00:42:07,230 --> 00:42:08,670
我可以完全在同一时间写两页

1166
00:42:08,670 --> 00:42:11,310
所以让我们说 我

1167
00:42:11,310 --> 00:42:14,130
在这里删除了一堆数据和我的页面，然后

1168
00:42:14,130 --> 00:42:15,600
我更新我想更新我的页面

1169
00:42:15,600 --> 00:42:17,010
rectory 说哦我有这么多的

1170
00:42:17,010 --> 00:42:19,860
可用空间我做了一堆数据

1171
00:42:19,860 --> 00:42:22,530
写出来然后在我可以更新我的

1172
00:42:22,530 --> 00:42:23,850
页面目录之前 写出来我

1173
00:42:23,850 --> 00:42:26,310
崩溃了所以现在我回到网上说

1174
00:42:26,310 --> 00:42:28,530
哦这个我认为这个页面已满

1175
00:42:28,530 --> 00:42:30,030
因此我无法读取任何数据

1176
00:42:30,030 --> 00:42:32,160
但我知道它实际上不正确

1177
00:42:32,160 --> 00:42:34,500
实际上它不是所以你可以说

1178
00:42:34,500 --> 00:42:35,970
很好 当我重新启动时，我只会

1179
00:42:35,970 --> 00:42:37,740
扫描我的所有页面并

1180
00:42:37,740 --> 00:42:39,240
找出真正存在的内容，但现在

1181
00:42:39,240 --> 00:42:41,220
再想一想

1182
00:42:41,220 --> 00:42:41,999
如果我有一个

1183
00:42:41,999 --> 00:42:43,769
数据演出那么极端地想那将

1184
00:42:43,769 --> 00:42:44,969
永远或搁置一拍字节的

1185
00:42:44,969 --> 00:42:46,289
数据 要花很长时间才能真正做到

1186
00:42:46,289 --> 00:42:48,509
这一点 一堆机制将

1187
00:42:48,509 --> 00:42:49,979
在后面讨论，或者我们如何

1188
00:42:49,979 --> 00:42:52,339


1189
00:42:52,339 --> 00:42:55,709
在特殊的特殊文件中维护日志和初始元数据，以便

1190
00:42:55,709 --> 00:42:57,209
如果我们崩溃回来我们知道如何

1191
00:42:57,209 --> 00:42:58,739
重建所有这些东西里面的

1192
00:42:58,739 --> 00:43:01,349
内容我认为它只是一个哈希

1193
00:43:01,349 --> 00:43:03,899
表说我想要第 1 2 3 页 在这里

1194
00:43:03,899 --> 00:43:08,759
可以找到它，我可以找到它 是的 是的，

1195
00:43:08,759 --> 00:43:14,939
每个页面的大小都相同

1196
00:43:14,939 --> 00:43:17,059


1197
00:43:17,059 --> 00:43:19,079


1198
00:43:19,079 --> 00:43:21,059


1199
00:43:21,059 --> 00:43:25,379
回到这个图这里 他们做

1200
00:43:25,379 --> 00:43:26,789
不同的系统 做不同的

1201
00:43:26,789 --> 00:43:29,659
事情

1202
00:43:29,659 --> 00:43:32,669
如果故障安全就像你知道我们可以

1203
00:43:32,669 --> 00:43:33,899
写 4 KB 并且因为

1204
00:43:33,899 --> 00:43:35,789
硬件保证是原子的 但现在

1205
00:43:35,789 --> 00:43:37,589
我需要写你知道说我的

1206
00:43:37,589 --> 00:43:39,239
页面本身是 4 KB 但是

1207
00:43:39,239 --> 00:43:41,789
我需要更新一个他们清理的页面

1208
00:43:41,789 --> 00:43:43,469
清除一堆数据 更新

1209
00:43:43,469 --> 00:43:45,029
页面目录 并说好的

1210
00:43:45,029 --> 00:43:46,289
那个页面你已经被清除 我

1211
00:43:46,289 --> 00:43:48,149
不能保证这两个页面都是正确的

1212
00:43:48,149 --> 00:43:50,279
我可以写一个

1213
00:43:50,279 --> 00:43:53,809
在我写第二个之前崩溃了

1214
00:43:57,199 --> 00:44:02,609
好吧 所以这就是

1215
00:44:02,609 --> 00:44:04,019
页面在

1216
00:44:04,019 --> 00:44:11,639
某些文件中的样子所以他说为什么有些

1217
00:44:11,639 --> 00:44:13,559
页面你为什么有些数据系统使用

1218
00:44:13,559 --> 00:44:18,139
更大的页面有

1219
00:44:18,139 --> 00:44:20,339
内部内部的权衡 我的数据库系统我

1220
00:44:20,339 --> 00:44:22,109
必须在内存中将此页面目录

1221
00:44:22,109 --> 00:44:25,139
映射到

1222
00:44:25,139 --> 00:44:27,569
内存或磁盘上的某个位置，但

1223
00:44:27,569 --> 00:44:29,459
现在如果我可以

1224
00:44:29,459 --> 00:44:32,999
用一个页面 ID 表示大量数据，那么

1225
00:44:32,999 --> 00:44:35,999
该表的大小就会下降，想想这是

1226
00:44:35,999 --> 00:44:38,159
就像在 TLB 中，

1227
00:44:38,159 --> 00:44:40,919
如果

1228
00:44:40,919 --> 00:44:42,839
我试图匹配所有一堆页面

1229
00:44:42,839 --> 00:44:44,699
，则在 CPU 内部的翻译后备缓冲区，但这是我的页表变得非常大

1230
00:44:44,699 --> 00:44:47,639
，现在我将有缓存未命中，

1231
00:44:47,639 --> 00:44:50,669
因此您可以在您中表示更多数据

1232
00:44:50,669 --> 00:44:51,949
知道有很少的页面 ID

1233
00:44:51,949 --> 00:44:53,879
并且回过头来讨论

1234
00:44:53,879 --> 00:44:54,989
随机访问和集中访问的区别，

1235
00:44:54,989 --> 00:44:55,710


1236
00:44:55,710 --> 00:44:58,069
所以现在如果我可以连续写出

1237
00:44:58,069 --> 00:45:01,140
你说四个四千字节的页面来

1238
00:45:01,140 --> 00:45:02,930
代表一个 16 千字节的数据库 p

1239
00:45:02,930 --> 00:45:05,760
当我阅读时，我只是按顺序阅读所有内容

1240
00:45:05,760 --> 00:45:07,380
并将其引入现在我

1241
00:45:07,380 --> 00:45:08,670
获得了我需要的潜在更有用的数据

1242
00:45:08,670 --> 00:45:11,550
，但它再次

1243
00:45:11,550 --> 00:45:12,990
使写操作变得更加昂贵

1244
00:45:12,990 --> 00:45:14,040
，现在在这个阶段看一堆

1245
00:45:14,040 --> 00:45:15,990
废话 提前以防止

1246
00:45:15,990 --> 00:45:17,910
自己被撕裂的写入所以它们

1247
00:45:17,910 --> 00:45:19,109
都有优点和缺点

1248
00:45:19,109 --> 00:45:21,000
，这就是为什么商业

1249
00:45:21,000 --> 00:45:22,050
系统再次允许您

1250
00:45:22,050 --> 00:45:22,410


1251
00:45:22,410 --> 00:45:24,119
根据您的应用程序想要

1252
00:45:24,119 --> 00:45:32,010
做的事情以不同的方式调整它们让我们去提问是的所以所以 他的

1253
00:45:32,010 --> 00:45:36,869
问题是针对自包含页面

1254
00:45:36,869 --> 00:45:38,369
是否会在这里解决这个特定问题

1255
00:45:38,369 --> 00:45:41,339
，不，您仍然会遇到如此自包含

1256
00:45:41,339 --> 00:45:44,280
页面的意思是页面的

1257
00:45:44,280 --> 00:45:46,260
那一侧的内容我拥有

1258
00:45:46,260 --> 00:45:48,390
我需要的所有元数据我仍然

1259
00:45:48,390 --> 00:45:49,710
必须拥有 如果我想要第 1 2 3 或 4 5 6 页，页面主管会告诉我在哪里

1260
00:45:49,710 --> 00:45:51,630
可以找到该页面，

1261
00:45:51,630 --> 00:45:54,030
因此它

1262
00:45:54,030 --> 00:45:57,750
在系统的较高级别并不完全独立

1263
00:45:57,750 --> 00:45:59,760
，在底层是不可避免的，

1264
00:45:59,760 --> 00:46:02,640
所以我们在这里的内容可能

1265
00:46:02,640 --> 00:46:04,140
削弱我们 有任何关于页面内部实际内容的讨论，

1266
00:46:04,140 --> 00:46:07,410
但

1267
00:46:07,410 --> 00:46:09,180
在页面目录中，我们不能

1268
00:46:09,180 --> 00:46:11,160
保证自包含好的它没有

1269
00:46:11,160 --> 00:46:26,520
意义对是的所以这个问题

1270
00:46:26,520 --> 00:46:29,809
是有没有办法保证

1271
00:46:29,809 --> 00:46:32,670
如果发生崩溃 当你回来时，

1272
00:46:32,670 --> 00:46:34,230
你可以确定崩溃发生了

1273
00:46:34,230 --> 00:46:34,920
是的，

1274
00:46:34,920 --> 00:46:38,819
所以你知道校验和是正确的，所以说

1275
00:46:38,819 --> 00:46:42,119
我的数据库页面是

1276
00:46:42,119 --> 00:46:44,069
第一页标题中的 d3 页，我会放一个

1277
00:46:44,069 --> 00:46:46,740
校验和，然后从

1278
00:46:46,740 --> 00:46:48,089
我的开始说下一个 指向这里接下来的三

1279
00:46:48,089 --> 00:46:51,270
页，校验和应该像一个

1280
00:46:51,270 --> 00:46:54,390
CRC 或 md5 应该是这个数量，所以

1281
00:46:54,390 --> 00:46:56,670
我回到网上，崩溃后我

1282
00:46:56,670 --> 00:46:59,130
会看，说哦，当

1283
00:46:59,130 --> 00:47:00,299
我去上班时的最后一页校验和没有

1284
00:47:00,299 --> 00:47:01,470
匹配，因为这件事没有

1285
00:47:01,470 --> 00:47:02,880
写出来，所以我会做我

1286
00:47:02,880 --> 00:47:05,790
有一个错误

1287
00:47:05,790 --> 00:47:08,970
，然后我们将讨论日志记录，

1288
00:47:08,970 --> 00:47:10,590
一秒钟内没有，但是就像你可以记录

1289
00:47:10,590 --> 00:47:12,390
你为修改页面所做的操作一样

1290
00:47:12,390 --> 00:47:13,860
，这基本上就是什么 数据库

1291
00:47:13,860 --> 00:47:19,230
没有烦恼 大部分都还不错，很酷

1292
00:47:19,230 --> 00:47:21,180
所以这就是全部 我将再次讨论

1293
00:47:21,180 --> 00:47:22,520
这些页面中的实际外观

1294
00:47:22,520 --> 00:47:26,240
，每个页面都会有一个标题

1295
00:47:26,240 --> 00:47:28,500
，这就是他所问的问题

1296
00:47:28,500 --> 00:47:30,180
我们将获得信息

1297
00:47:30,180 --> 00:47:32,100
页面的大小是多少 校验和 什么

1298
00:47:32,100 --> 00:47:34,650
数据库版本或

1299
00:47:34,650 --> 00:47:36,710
软件版本写出这些数据

1300
00:47:36,710 --> 00:47:39,030
你可能会发生什么是人们你知道

1301
00:47:39,030 --> 00:47:40,800
数据是公司发布

1302
00:47:40,800 --> 00:47:42,780
新版本 Postgres

1303
00:47:42,780 --> 00:47:44,400
每次你知道页面布局可能会

1304
00:47:44,400 --> 00:47:47,100
改变时都会发布新版本所以当你什么时候 你想

1305
00:47:47,100 --> 00:47:48,870
升级你想知道我是否正在查看

1306
00:47:48,870 --> 00:47:50,100
由新

1307
00:47:50,100 --> 00:47:51,840
软件和旧软件创建的页面，如果你正在执行像字典压缩或 lz4 gzip 这样的压缩，我可以有

1308
00:47:51,840 --> 00:47:53,130
不同的代码路径来解释它们

1309
00:47:53,130 --> 00:47:55,170
，

1310
00:47:55,170 --> 00:47:57,750


1311
00:47:57,750 --> 00:48:00,000
你可以存储 关于这一点的信息我们

1312
00:48:00,000 --> 00:48:01,710
在本学期的这个时候都讨论过，

1313
00:48:01,710 --> 00:48:02,790
但它也是

1314
00:48:02,790 --> 00:48:04,530
关于你知道哪些事务或哪些

1315
00:48:04,530 --> 00:48:06,420
查询修改了这些数据以及其他查询是否正常的信息

1316
00:48:06,420 --> 00:48:09,000
再次看到它

1317
00:48:09,000 --> 00:48:11,280
，然后我们已经

1318
00:48:11,280 --> 00:48:15,180
讨论了一个可能是自包含的问题，所以

1319
00:48:15,180 --> 00:48:17,280
现在在一个页面中我们可以

1320
00:48:17,280 --> 00:48:20,190
用两种不同的方式表示数据，所以我们可以将

1321
00:48:20,190 --> 00:48:21,960
其作为一种面向元组的

1322
00:48:21,960 --> 00:48:23,550
方法和 我将

1323
00:48:23,550 --> 00:48:27,180
在下一张幻灯片中解释这意味着什么，或者我们可以采用日志

1324
00:48:27,180 --> 00:48:31,110
结构化方法，因此它

1325
00:48:31,110 --> 00:48:32,850
现在位于一个页面内，假设有一个页面目录

1326
00:48:32,850 --> 00:48:34,200
，

1327
00:48:34,200 --> 00:48:35,280
如果我们希望您知道某个

1328
00:48:35,280 --> 00:48:37,410
页面，我们需要如何访问该页面 一二三 现在我们正在

1329
00:48:37,410 --> 00:48:38,430
讨论当你

1330
00:48:38,430 --> 00:48:39,690
查看页面内部时它是什么样子 你

1331
00:48:39,690 --> 00:48:41,130
实际上是什么数据集 我实际上

1332
00:48:41,130 --> 00:48:44,280
要看到所以对于这个，让

1333
00:48:44,280 --> 00:48:46,470
我们假设我们正在存储元组，让我们说

1334
00:48:46,470 --> 00:48:48,240
这里有一个非常简单的案例 一个非常

1335
00:48:48,240 --> 00:48:51,180
相似的强大的主要思想是，在我们的

1336
00:48:51,180 --> 00:48:54,180
页面中，我们要做的只是从一

1337
00:48:54,180 --> 00:48:56,430
开始就一个接一个地插入元组

1338
00:48:56,430 --> 00:48:57,630
，我们有一点

1339
00:48:57,630 --> 00:48:58,680
标题空间，并说这

1340
00:48:58,680 --> 00:49:00,210
是我们拥有的元组数量 所以我们

1341
00:49:00,210 --> 00:49:02,310
知道我们还想跳到什么地方 如果我们

1342
00:49:02,310 --> 00:49:05,430
想插入一个新的但它非常

1343
00:49:05,430 --> 00:49:07,050
简单，我们只需一次插入一个，

1344
00:49:07,050 --> 00:49:10,200
所以说第三个开始三个元组，

1345
00:49:10,200 --> 00:49:13,110
假设它们每次插入时都是固定长度的，

1346
00:49:13,110 --> 00:49:14,700
我只是

1347
00:49:14,700 --> 00:49:16,620
跳到下一个自由偏移寻找

1348
00:49:16,620 --> 00:49:18,740
然后更新计数器

1349
00:49:18,740 --> 00:49:26,780
所以这是一个坏主意为什么完美所以他

1350
00:49:26,780 --> 00:49:28,730
说是的如果你删除一个元组你

1351
00:49:28,730 --> 00:49:30,320
必须移动一切不一定

1352
00:49:30,320 --> 00:49:33,349
正确我可以这样做没问题

1353
00:49:33,349 --> 00:49:37,220
释放空间表他说

1354
00:49:37,220 --> 00:49:38,990
外部碎片很好为什么为什么

1355
00:49:38,990 --> 00:49:45,190
我不能直接插入那里

1356
00:49:45,190 --> 00:49:47,330
，所以我假设

1357
00:49:47,330 --> 00:49:48,410
它们的长度是固定的，但他是

1358
00:49:48,410 --> 00:49:50,480
绝对正确的，所以这很好用，

1359
00:49:50,480 --> 00:49:51,589
如果一切都固定好了

1360
00:49:51,589 --> 00:49:53,630
，我可以把它推

1361
00:49:53,630 --> 00:49:55,280
到旧的新的，但 它不是固定

1362
00:49:55,280 --> 00:49:58,250
长度，那么这个插槽实际上可能你

1363
00:49:58,250 --> 00:49:59,599
知道这个位置可能

1364
00:49:59,599 --> 00:50:01,040
不足以容纳我要插入的内容，现在我必须

1365
00:50:01,040 --> 00:50:05,720
试着把它放在这里，所以

1366
00:50:05,720 --> 00:50:07,790
这是一个问题，我的意思是另一个问题

1367
00:50:07,790 --> 00:50:09,440
也是如此 单人 当我

1368
00:50:09,440 --> 00:50:12,470
需要说我删除这个东西的时候，我的

1369
00:50:12,470 --> 00:50:14,599
意思是在顶部维护元数据并

1370
00:50:14,599 --> 00:50:16,400
告诉我嘿这里是这里

1371
00:50:16,400 --> 00:50:17,690
是这个页面中的一个位置或者你可以写

1372
00:50:17,690 --> 00:50:19,820
一些数据或者我得到一个顺序扫描

1373
00:50:19,820 --> 00:50:22,099
并查看 每一个元组都

1374
00:50:22,099 --> 00:50:25,609
找出我可以去哪里，所以这很糟糕

1375
00:50:25,609 --> 00:50:28,160
没有人这样做，而是你所做的

1376
00:50:28,160 --> 00:50:31,369
是它导致槽页的原因，所以这

1377
00:50:31,369 --> 00:50:33,410
是最常见的方案，每个磁盘

1378
00:50:33,410 --> 00:50:35,599
或数据系统都将使用它们如何使用的确切

1379
00:50:35,599 --> 00:50:37,190
细节 '将

1380
00:50:37,190 --> 00:50:38,660
代表这些页面，我们略有

1381
00:50:38,660 --> 00:50:40,460
不同，但在高层次上，

1382
00:50:40,460 --> 00:50:42,680
这是每个人都这样做，所以

1383
00:50:42,680 --> 00:50:43,520
事情可以工作的方式我们总是

1384
00:50:43,520 --> 00:50:45,349
会有我们的标题标题它可以存储

1385
00:50:45,349 --> 00:50:47,240
关于校验和的基本元数据，或者

1386
00:50:47,240 --> 00:50:48,859
你知道 访问时间和类似的

1387
00:50:48,859 --> 00:50:51,859
事情，然后我们将不得不对

1388
00:50:51,859 --> 00:50:54,770
我们想要存储在顶部的数据区域进行排序，

1389
00:50:54,770 --> 00:50:56,119
这将具有所谓的槽

1390
00:50:56,119 --> 00:50:57,800
数组，而底部我们实际上

1391
00:50:57,800 --> 00:51:00,050
将拥有我们想要的实际数据

1392
00:51:00,050 --> 00:51:01,880
将这些再次存储在 w 我

1393
00:51:01,880 --> 00:51:03,619
假设我们在这里做元组，那么

1394
00:51:03,619 --> 00:51:05,119
这个可以是可变

1395
00:51:05,119 --> 00:51:07,460
长度元组的固定长度，这并不重要，

1396
00:51:07,460 --> 00:51:09,080
所以屠宰率基本上是

1397
00:51:09,080 --> 00:51:12,349
从特定插槽到

1398
00:51:12,349 --> 00:51:15,380
页面中某个偏移量的映射层。

1399
00:51:15,380 --> 00:51:17,480


1400
00:51:17,480 --> 00:51:21,770
你想要的特定元组的起始位置，以及

1401
00:51:21,770 --> 00:51:23,240
我们想要这个间接

1402
00:51:23,240 --> 00:51:25,339
层的原因，因为现在我们可以开始

1403
00:51:25,339 --> 00:51:27,020
在页面内移动这些

1404
00:51:27,020 --> 00:51:29,780
元组我们可以以任何我们想要的方式再次移动这些元组

1405
00:51:29,780 --> 00:51:31,369
到系统的上层

1406
00:51:31,369 --> 00:51:32,650


1407
00:51:32,650 --> 00:51:34,610
不在乎他们总是可以知道

1408
00:51:34,610 --> 00:51:36,110
记录它会是页面 ID 和

1409
00:51:36,110 --> 00:51:39,110
插槽编号 我需要做的就是移动

1410
00:51:39,110 --> 00:51:40,370
这些东西然后更新

1411
00:51:40,370 --> 00:51:41,390
屠宰率并说

1412
00:51:41,390 --> 00:51:42,910
这就是您实际所在的位置 指向

1413
00:51:42,910 --> 00:51:45,260
和填充页面

1414
00:51:45,260 --> 00:51:47,060
的方式是槽数组

1415
00:51:47,060 --> 00:51:49,340
将从头到尾增长，

1416
00:51:49,340 --> 00:51:50,750
数据将从尾到头增长

1417
00:51:50,750 --> 00:51:52,850
，在某些时候我们将

1418
00:51:52,850 --> 00:51:54,110
到达中间 我们不能的地方 存储

1419
00:51:54,110 --> 00:51:55,730
任何新信息，然后这

1420
00:51:55,730 --> 00:51:57,730
就是我们所说的页面已满，

1421
00:51:57,730 --> 00:52:00,020
所以是的，这意味着中间可能有一个

1422
00:52:00,020 --> 00:52:02,150
小的间隙，我们

1423
00:52:02,150 --> 00:52:04,880
不能存储任何东西，但这是你知道的，

1424
00:52:04,880 --> 00:52:06,740
因为我们想要支持非常长的

1425
00:52:06,740 --> 00:52:10,070
元组 我们必须这样做 我们必须这样

1426
00:52:10,070 --> 00:52:11,720
做 我们可以做所谓的真空

1427
00:52:11,720 --> 00:52:13,160
或压缩 我们可以只扫描

1428
00:52:13,160 --> 00:52:16,310
并重新组织碎片整理 在

1429
00:52:16,310 --> 00:52:19,130
旧文件系统中 我们可以在

1430
00:52:19,130 --> 00:52:20,390
后台这样做 我们可以这样做 但为了

1431
00:52:20,390 --> 00:52:22,910
我们的目的 这就是我们

1432
00:52:22,910 --> 00:52:32,030
最终得到的好点，所以他的

1433
00:52:32,030 --> 00:52:33,920
问题是我们在这里

1434
00:52:33,920 --> 00:52:36,320
假设在一个页面内我们可以有

1435
00:52:36,320 --> 00:52:39,320
来自不同表的元组在实践中

1436
00:52:39,320 --> 00:52:40,490
没有人这样做，

1437
00:52:40,490 --> 00:52:41,870
因为你必须维护一些

1438
00:52:41,870 --> 00:52:43,340
元数据说这是来自元组 想要

1439
00:52:43,340 --> 00:52:45,860
一张来自表二的表，我们会

1440
00:52:45,860 --> 00:52:47,150
在最后看到，有一种方法可以

1441
00:52:47,150 --> 00:52:49,760
让某些系统做到这一点，

1442
00:52:49,760 --> 00:52:51,470
但一般来说，如果你

1443
00:52:51,470 --> 00:52:52,640
打开后续的研究生或

1444
00:52:52,640 --> 00:52:54,560
其他任何事情，没有人会这样做 你调用 create table 它将

1445
00:52:54,560 --> 00:52:56,540
创建页面，只有来自这些

1446
00:52:56,540 --> 00:53:00,380
表的元组才会进入这些页面 这是一个很好的

1447
00:53:00,380 --> 00:53:01,280
问题，一秒钟后会发生什么，

1448
00:53:01,280 --> 00:53:04,220
所以这些是面向元组的页面

1449
00:53:04,220 --> 00:53:06,290
，前几天我们试图

1450
00:53:06,290 --> 00:53:09,110
在这些页面中存储元组 页面，所以你

1451
00:53:09,110 --> 00:53:10,520
知道当我做一个插入我做一个更新

1452
00:53:10,520 --> 00:53:12,440
我想找到你知道我

1453
00:53:12,440 --> 00:53:13,970
把元组的内容

1454
00:53:13,970 --> 00:53:17,350
完整地写在这个页面这里

1455
00:53:17,350 --> 00:53:20,300
我们将在下一堂课中看到我们将讨论

1456
00:53:20,300 --> 00:53:23,720
对于非常大的数据，比如如果你有一

1457
00:53:23,720 --> 00:53:25,010
棵树，就像你想要一个像

1458
00:53:25,010 --> 00:53:27,350
你知道数据库中的视频文件那样的存储，

1459
00:53:27,350 --> 00:53:29,660
不要这样做，这很好，为什么以后但

1460
00:53:29,660 --> 00:53:31,700
就像这里的情况一样，你无法

1461
00:53:31,700 --> 00:53:32,630
存储它，因为它赢了 不适合在

1462
00:53:32,630 --> 00:53:34,400
一个页面中，所以你有一些

1463
00:53:34,400 --> 00:53:35,510
额外的元数据一些指针

1464
00:53:35,510 --> 00:53:37,010
说这里

1465
00:53:37,010 --> 00:53:38,930
有你正在寻找的其余数据的页面，但

1466
00:53:38,930 --> 00:53:40,580
总的来说，我们希望我们将整个

1467
00:53:40,580 --> 00:53:42,380
元组打包在一个页面中 因为现在当

1468
00:53:42,380 --> 00:53:43,910
我们访问时，您需要

1469
00:53:43,910 --> 00:53:45,650
访问元组 读取一个页面来获取

1470
00:53:45,650 --> 00:53:46,100
它，

1471
00:53:46,100 --> 00:53:49,640
而不是一堆不同的页面，

1472
00:53:49,640 --> 00:53:51,230
我们将在下一堂课打破这个假设，

1473
00:53:51,230 --> 00:53:55,520
但就我们的目的而言，这很好，所以

1474
00:53:55,520 --> 00:53:57,560
另一种存储数据和页面的方法是

1475
00:53:57,560 --> 00:54:07,730
我们的问题，所以他的问题是说

1476
00:54:07,730 --> 00:54:09,800
我记得 第三个元组在这里

1477
00:54:09,800 --> 00:54:13,340
发生了什么这取决于

1478
00:54:13,340 --> 00:54:15,320
我会在课堂上给它一分钟一些

1479
00:54:15,320 --> 00:54:16,730
系统实际上会在

1480
00:54:16,730 --> 00:54:18,380
它写出磁盘之前压缩它一些系统会

1481
00:54:18,380 --> 00:54:20,960
在这里留下一个间隙然后如果它

1482
00:54:20,960 --> 00:54:22,160
变满你说哦我 有一些

1483
00:54:22,160 --> 00:54:24,010
可用空间也许我尝试进行压缩

1484
00:54:24,010 --> 00:54:33,770
是的是的这个问题是插槽

1485
00:54:33,770 --> 00:54:35,030
指向

1486
00:54:35,030 --> 00:54:39,310
元组的起始位置问题是点

1487
00:54:42,370 --> 00:54:44,690
是什么因为问题是什么是

1488
00:54:44,690 --> 00:54:46,400
存储地址的顺序是什么

1489
00:54:46,400 --> 00:54:55,910
插槽不确定你的意思，

1490
00:54:55,910 --> 00:54:58,880
就像我说的这是 4 KB II

1491
00:54:58,880 --> 00:55:01,250
想要为 Cuba 1 存储一个 1 KB 元组

1492
00:55:01,250 --> 00:55:04,310
所以从偏移量开始

1493
00:55:04,310 --> 00:55:07,280
我跳到 1 KB 然后我的

1494
00:55:07,280 --> 00:55:19,640
插槽正确指向那个正确的

1495
00:55:19,640 --> 00:55:20,900
问题是 如果我 再次删除中间的一个元组

1496
00:55:20,900 --> 00:55:23,300
我看到人们 3 我

1497
00:55:23,300 --> 00:55:25,760
该怎么做我该怎么做 上面没有导弹

1498
00:55:25,760 --> 00:55:31,130
在阵列上 是的 所以标头可以

1499
00:55:31,130 --> 00:55:33,260
调光系统做不同的事情

1500
00:55:33,260 --> 00:55:35,270
标头可以有一点垫子并

1501
00:55:35,270 --> 00:55:37,160
说你知道这里是

1502
00:55:37,160 --> 00:55:38,570
这是空的插槽，你可以指向

1503
00:55:38,570 --> 00:55:41,120
一些东西，或者我只是切换扫描

1504
00:55:41,120 --> 00:55:44,030
并正确读取它并不重要，

1505
00:55:44,030 --> 00:55:47,570
尽管我认为

1506
00:55:47,570 --> 00:55:51,140
系统的其他部分不知道也不知道

1507
00:55:51,140 --> 00:55:53,630
请注意我实际上

1508
00:55:53,630 --> 00:55:55,700
像它一样实际存储的位置所以对于

1509
00:55:55,700 --> 00:55:58,940
元组 1，它是从这里的插槽中出来的，

1510
00:55:58,940 --> 00:55:59,970


1511
00:55:59,970 --> 00:56:01,650
所以在系统的上部

1512
00:56:01,650 --> 00:56:04,020
它会说 Oh tuple

1513
00:56:04,020 --> 00:56:05,550
one 如果你有第一二三页，你可以找到它

1514
00:56:05,550 --> 00:56:09,869
在插槽零插槽一取决于

1515
00:56:09,869 --> 00:56:12,300
您的起始偏移量所以现在无论

1516
00:56:12,300 --> 00:56:14,820
我如何重新组织我的页面并移动到

1517
00:56:14,820 --> 00:56:16,980
但我知道我总是

1518
00:56:16,980 --> 00:56:18,450
想去第一个插槽找到它的

1519
00:56:18,450 --> 00:56:20,730
实际位置现在如果我重新组织

1520
00:56:20,730 --> 00:56:22,320
我不必向你更新我的索引

1521
00:56:22,320 --> 00:56:24,359
pdate 任何东西，这也是

1522
00:56:24,359 --> 00:56:25,890
页面目录正在尝试做的事情，

1523
00:56:25,890 --> 00:56:28,290
所以无论我

1524
00:56:28,290 --> 00:56:31,230
在文件上的哪个位置移动页面，无论是在磁盘上还是

1525
00:56:31,230 --> 00:56:33,080
在网络上您知道的不同外观

1526
00:56:33,080 --> 00:56:35,550
，系统的其他部分都不关心

1527
00:56:35,550 --> 00:56:37,530
在哪里 它实际上被转移到因为我

1528
00:56:37,530 --> 00:56:39,030
有一个页面，一旦你知道我有

1529
00:56:39,030 --> 00:56:40,560
页面 ID 我只能使用页面

1530
00:56:40,560 --> 00:56:41,460
目录来找到它实际

1531
00:56:41,460 --> 00:56:44,400
主要存储的位置，这些间接

1532
00:56:44,400 --> 00:56:47,460
层避免了更新

1533
00:56:47,460 --> 00:56:48,930
通过系统的所有部分传播

1534
00:56:48,930 --> 00:56:58,320
是的 这些问题是我

1535
00:56:58,320 --> 00:57:02,190
怎么知道第一个元组存储在第一个插槽中，

1536
00:57:02,190 --> 00:57:02,580


1537
00:57:02,580 --> 00:57:08,670
所以如果我有太多，但我们会继续

1538
00:57:08,670 --> 00:57:16,650
这样做，所以这总是在

1539
00:57:16,650 --> 00:57:17,820
最后一张幻灯片中，但现在让我们讨论它，

1540
00:57:17,820 --> 00:57:22,470
以便我们识别 元组是通过

1541
00:57:22,470 --> 00:57:26,609
这些记录 ID 或元组 ID，它

1542
00:57:26,609 --> 00:57:29,070
本质上是一个唯一标识符，表示

1543
00:57:29,070 --> 00:57:32,190
这里是一个元组的逻辑位置或逻辑

1544
00:57:32,190 --> 00:57:37,260
地址，它是

1545
00:57:37,260 --> 00:57:38,550
逻辑和物理的混合，但通常是

1546
00:57:38,550 --> 00:57:41,000
页面 ID 和偏移量或槽等

1547
00:57:41,000 --> 00:57:43,320
一切  我们

1548
00:57:43,320 --> 00:57:45,720
想要解决元组 1 的系统部分他们

1549
00:57:45,720 --> 00:57:47,010
不知道是什么 - Bolin 他们只

1550
00:57:47,010 --> 00:57:48,390
知道我有一个页面 ID 并且我是一个槽

1551
00:57:48,390 --> 00:57:50,550
号，所以我转到页面目录

1552
00:57:50,550 --> 00:57:52,500
并说我想要第 1 页 2 3 页面

1553
00:57:52,500 --> 00:57:54,450
目录说哦，它在这个文件中，

1554
00:57:54,450 --> 00:57:56,910
这一切都设置跳转到那个页面，然后

1555
00:57:56,910 --> 00:57:59,490
我现在到达那个页面

1556
00:57:59,490 --> 00:58:01,710


1557
00:58:01,710 --> 00:58:02,970


1558
00:58:02,970 --> 00:58:05,849
我想要的数据，所以系统的其他部分，

1559
00:58:05,849 --> 00:58:08,970
比如索引日志记录和

1560
00:58:08,970 --> 00:58:09,930
其他东西，他们将在早上

1561
00:58:09,930 --> 00:58:12,390
通过这些记录 ID 解决元组问题

1562
00:58:12,390 --> 00:58:17,089


1563
00:58:22,250 --> 00:58:35,010


1564
00:58:35,010 --> 00:58:37,769
希望让我们让自己说我

1565
00:58:37,769 --> 00:58:40,500
想找到薪水

1566
00:58:40,500 --> 00:58:42,809
找到学生记录或教授

1567
00:58:42,809 --> 00:58:45,210
记录姓名安迪我在姓名索引中查找

1568
00:58:45,210 --> 00:58:47,579
并有话要说哦，

1569
00:58:47,579 --> 00:58:49,319
有一位名叫安迪的教授，

1570
00:58:49,319 --> 00:58:51,930
他有一个记录 第一二三页的 ID

1571
00:58:51,930 --> 00:58:52,920
都设置了第一

1572
00:58:52,920 --> 00:58:55,130
槽，这就是 UNIX 给我的

1573
00:58:55,130 --> 00:58:57,119
我说它转到页面

1574
00:58:57,119 --> 00:58:58,140
目录 好吧

1575
00:58:58,140 --> 00:59:00,089
Gav 我在哪里可以找到第一页二三页

1576
00:59:00,089 --> 00:59:01,829
你去帮我拿它现在去拿它

1577
00:59:01,829 --> 00:59:03,569
我有指向页面的指针然后

1578
00:59:03,569 --> 00:59:06,000
说哦我想要第一槽 我看看我的槽

1579
00:59:06,000 --> 00:59:07,529
阵列 这告诉我所有设置

1580
00:59:07,529 --> 00:59:09,230
跳转到该页面以找到需要

1581
00:59:09,230 --> 00:59:12,569
正确的内容，因此不同的数据系统做

1582
00:59:12,569 --> 00:59:14,369
不同的事情最常见的

1583
00:59:14,369 --> 00:59:16,109
方法是页面 ID 和插槽

1584
00:59:16,109 --> 00:59:18,630
号偏移量，再次他们的

1585
00:59:18,630 --> 00:59:20,819
优势是如果我开始 移动数据

1586
00:59:20,819 --> 00:59:23,069
移动页面或

1587
00:59:23,069 --> 00:59:25,680
移动页面本身，

1588
00:59:25,680 --> 00:59:27,119
索引和所有其他废话

1589
00:59:27,119 --> 00:59:27,930
不必更新，因为他们

1590
00:59:27,930 --> 00:59:29,400
仍在查看第一页二三页全部

1591
00:59:29,400 --> 00:59:35,130
设置为一个所以现在让我 将给出一个

1592
00:59:35,130 --> 00:59:36,779
演示来解释更多的细节，所以在

1593
00:59:36,779 --> 00:59:38,339
不同的系统中做不同的事情，

1594
00:59:38,339 --> 00:59:41,099
比如在 Postgres 中它会是 4 个字节或

1595
00:59:41,099 --> 00:59:42,480
等于 10 个字节，他们存储了一堆额外的

1596
00:59:42,480 --> 00:59:44,670
元数据，续集 Lite

1597
00:59:44,670 --> 00:59:48,750
是 8 个字节，所以让我们做一个演示，因为

1598
00:59:48,750 --> 00:59:52,140
那是 总是很有趣，因为我讨厌

1599
00:59:52,140 --> 00:59:55,819
在 th 上打字 e 表面并使用我的另一台笔记本电脑

1600
00:59:55,819 --> 00:59:57,480
，我可以更好地看到它，

1601
00:59:57,480 --> 00:59:58,980
所以我将再次举一个例子

1602
00:59:58,980 --> 01:00:01,650
，说明我们如何实际

1603
01:00:01,650 --> 01:00:04,170
看到这些页面的样子，因为再次

1604
01:00:04,170 --> 01:00:05,609
在内部存储这些数据的数据系统

1605
01:00:05,609 --> 01:00:07,529
你不应该 看到它，

1606
01:00:07,529 --> 01:00:09,180
但有不同的命令要做才能

1607
01:00:09,180 --> 01:00:10,230
真正得到它

1608
01:00:10,230 --> 01:00:14,250
我不能在后面看到它或者

1609
01:00:14,250 --> 01:00:17,910
它太暗或太亮如何

1610
01:00:17,910 --> 01:00:20,670
更好，好吧，所以我们要制作

1611
01:00:20,670 --> 01:00:22,910
一个

1612
01:00:23,390 --> 01:00:33,260
我们要去 制作一个包含

1613
01:00:33,260 --> 01:00:36,359
两列 ID 和值的简单表，我们将

1614
01:00:36,359 --> 01:00:38,369
在其中插入一些表，这就是

1615
01:00:38,369 --> 01:00:42,300


1616
01:00:42,300 --> 01:00:44,280


1617
01:00:44,280 --> 01:00:47,190


1618
01:00:47,190 --> 01:00:49,020
Postgres 数据的

1619
01:00:49,020 --> 01:00:52,140
数据，所以我可以在这里添加一个像虚拟

1620
01:00:52,140 --> 01:00:54,960
列一样的 CT ID，我在我的输出中得到它，

1621
01:00:54,960 --> 01:00:58,260
所以现在这是一个元组，

1622
01:00:58,260 --> 01:01:00,570
那里会有页面 ID 和

1623
01:01:00,570 --> 01:01:02,310
偏移量，所以这里是我开始的数据，

1624
01:01:02,310 --> 01:01:04,410
三个元组，所以 现在它

1625
01:01:04,410 --> 01:01:07,230
说在页面零插槽一个是第一个

1626
01:01:07,230 --> 01:01:09,150
元组页面 零槽 2 是第二个

1627
01:01:09,150 --> 01:01:11,190
元组，支付零槽 3 是第三个元组，

1628
01:01:11,190 --> 01:01:14,070
所以这又一次，所以它

1629
01:01:14,070 --> 01:01:15,930
实际上并没有存储这些数据，它只是

1630
01:01:15,930 --> 01:01:17,849
在运行查询时可以派生出来，

1631
01:01:17,849 --> 01:01:19,920
因为它说哦，我看看我的页面，我

1632
01:01:19,920 --> 01:01:21,750
看到了 这里的槽是实际上找到的元组，

1633
01:01:21,750 --> 01:01:24,990
所以

1634
01:01:24,990 --> 01:01:26,099
让我们继续删除其中一个

1635
01:01:26,099 --> 01:01:29,280
元组，假设我删除了

1636
01:01:29,280 --> 01:01:32,369
第二个，所以我回去看看我的

1637
01:01:32,369 --> 01:01:34,859
元组，看看我的数据，你

1638
01:01:34,859 --> 01:01:36,690
可以看到它 删除了第二个

1639
01:01:36,690 --> 01:01:38,790
元组，但它没有意识到页面

1640
01:01:38,790 --> 01:01:41,670
右侧第三个元组仍然是它

1641
01:01:41,670 --> 01:01:44,420
你知道页面 0 偏移 3 或槽 3

1642
01:01:44,420 --> 01:01:48,750
好吧，让我们说现在我去开始

1643
01:01:48,750 --> 01:01:52,530
一个新的元组你认为

1644
01:01:52,530 --> 01:01:54,800
会做什么

1645
01:01:55,720 --> 01:01:59,560
我又删除

1646
01:01:59,560 --> 01:02:01,810
了第二个元组，现在我有一个 tublat

1647
01:02:01,810 --> 01:02:04,030
插槽，一个是插槽 3 我开始了一个新的

1648
01:02:04,030 --> 01:02:06,990
元组，它是插槽 2 还是插槽 4

1649
01:02:06,990 --> 01:02:10,930
举手，这是一个插槽，两个半

1650
01:02:10,930 --> 01:02:15,490
平三个是起始插槽 4 少

1651
01:02:15,490 --> 01:02:19,780
4 对，这没有错，因为

1652
01:02:19,780 --> 01:02:21,400
对于我们的目的 ses 关系

1653
01:02:21,400 --> 01:02:22,329
模型没有

1654
01:02:22,329 --> 01:02:25,780
说明我们如何插入元组的顺序 Postgres

1655
01:02:25,780 --> 01:02:27,250
它是实现的方式 我决定把

1656
01:02:27,250 --> 01:02:30,730
它放在最后，所以 Postgres 有

1657
01:02:30,730 --> 01:02:33,700
这个叫做真空的东西 再次把它想象成

1658
01:02:33,700 --> 01:02:36,640
我的垃圾收集器

1659
01:02:36,640 --> 01:02:38,859
对于数据库，它会遍历

1660
01:02:38,859 --> 01:02:42,300
并重新组织所有页面，

1661
01:02:42,300 --> 01:02:44,230
实际上可能需要一段时间，所以我会

1662
01:02:44,230 --> 01:02:46,750
回到那个问题，但是当它这样做时，它

1663
01:02:46,750 --> 01:02:48,730
会说哦，我知道我

1664
01:02:48,730 --> 01:02:52,300
有一个我有一个可用空间 - 所以我

1665
01:02:52,300 --> 01:02:54,400
要压缩页面并按

1666
01:02:54,400 --> 01:02:56,740
顺序写出来 好吧 这

1667
01:02:56,740 --> 01:03:00,190
需要一段时间让我们看看其他的所以

1668
01:03:00,190 --> 01:03:02,920
我们可以做续集服务器同样的事情我

1669
01:03:02,920 --> 01:03:08,349
有我有三个元组让我放下

1670
01:03:08,349 --> 01:03:10,890
表格重新开始

1671
01:03:20,239 --> 01:03:22,890
所以现在我 有三个两个碗

1672
01:03:22,890 --> 01:03:29,969
从我们右边的一个两个三个中选择一个明星所以

1673
01:03:29,969 --> 01:03:31,439
Postgres 确实启动了续集服务器

1674
01:03:31,439 --> 01:03:34,410
没有 CT ID 它像

1675
01:03:34,410 --> 01:03:38,189
其他内置函数一样有这个 它

1676
01:03:38,189 --> 01:03:40,140
告诉你这里是文件 ID 这里是

1677
01:03:40,140 --> 01:03:42,059
页码这里是 插槽零

1678
01:03:42,059 --> 01:03:44,849
一二 o 好吧，让我们做同样的事情，

1679
01:03:44,849 --> 01:03:49,910
让我们删除一个元组，插入一个新的元组，哦，

1680
01:03:49,910 --> 01:03:52,619
是的，我们可以查看旧的查询

1681
01:03:52,619 --> 01:03:54,719
，但它没有回来，它

1682
01:03:54,719 --> 01:03:57,359
仍然说你知道，零一实际上

1683
01:03:57,359 --> 01:03:58,709
不，我没有 回来，对不起，

1684
01:03:58,709 --> 01:04:01,289
收回，让我们重新开始，

1685
01:04:01,289 --> 01:04:04,680
我错过了，对不起，我总是记得

1686
01:04:04,680 --> 01:04:06,390
哪个不正确或

1687
01:04:06,390 --> 01:04:08,430
不正确，哪个不正确，哪个这样做是正确的，

1688
01:04:08,430 --> 01:04:11,969
所以我们插入三个

1689
01:04:11,969 --> 01:04:19,680
元组做一个荡妇正确的 0  1 2 现在我

1690
01:04:19,680 --> 01:04:24,839
删除了第二个元组 做同样的

1691
01:04:24,839 --> 01:04:29,369
选择 哦没有 0 R 0 - 我还没有

1692
01:04:29,369 --> 01:04:35,689
回来抱歉让我们再插入一个

1693
01:04:38,449 --> 01:04:46,650
0 1 2 所以所以这

1694
01:04:46,650 --> 01:04:50,819
是第二个管这是 2 现在它是 1 它

1695
01:04:50,819 --> 01:04:52,319
做了这个 - 因为

1696
01:04:52,319 --> 01:04:54,269
它在更新页面时说的它说哦我有一个

1697
01:04:54,269 --> 01:04:56,789
可用空间让我压缩它并

1698
01:04:56,789 --> 01:05:00,089
从系统的高级部分再次写出来

1699
01:05:00,089 --> 01:05:01,650
我们不知道我们

1700
01:05:01,650 --> 01:05:03,539
不知道 不在乎内部可以做任何它

1701
01:05:03,539 --> 01:05:07,469
想做的事所以回到

1702
01:05:07,469 --> 01:05:10,589
Postgres 当我们插入

1703
01:05:10,589 --> 01:05:12,509
我放置的新元组时它是一个 Postgres 它在最后，但后来我运行

1704
01:05:12,509 --> 01:05:14,609
了真空，

1705
01:05:14,609 --> 01:05:16,890
如果我们组织

1706
01:05:16,890 --> 01:05:19,380
零一三一二一二三

1707
01:05:19,380 --> 01:05:23,670
，那是一三四，所以

1708
01:05:23,670 --> 01:05:25,859
我想展示的最后一个是甲骨文

1709
01:05:25,859 --> 01:05:28,589
，尽管甲骨文赞助 在课堂上，

1710
01:05:28,589 --> 01:05:32,719
我只会说他们的终端，

1711
01:05:33,260 --> 01:05:35,670
你可能会喜欢你不能打，

1712
01:05:35,670 --> 01:05:42,890
没有办法回去放下桌臂

1713
01:05:42,890 --> 01:05:47,250
让我们创建一张桌子，你不能你

1714
01:05:47,250 --> 01:05:48,869
不能所以这是像每天一样的好捷径

1715
01:05:48,869 --> 01:05:50,460
象征你

1716
01:05:50,460 --> 01:05:52,829
像一个插入查询一样插入，然后用两个

1717
01:05:52,829 --> 01:05:54,299
逗号分隔它一旦

1718
01:05:54,299 --> 01:05:57,000
Oracle 不允许你这样做，所以我

1719
01:05:57,000 --> 01:06:06,089
必须一一执行，所以 Oracle

1720
01:06:06,089 --> 01:06:08,880
再次有一个叫做行 ID 的东西，所以这

1721
01:06:08,880 --> 01:06:10,859
是 Oracle 维护您的内部事物

1722
01:06:10,859 --> 01:06:14,339
通常运行查询，您

1723
01:06:14,339 --> 01:06:15,450
不会看到这一点，但是如果您只是添加

1724
01:06:15,450 --> 01:06:18,180
行 ID 列，就像您知道的

1725
01:06:18,180 --> 01:06:20,010
内部虚拟列一样，它会公开此

1726
01:06:20,010 --> 01:06:21,839
信息，因此这是一些十字节的

1727
01:06:21,839 --> 01:06:23,670
胡言乱语，我的意思是我们没有“ 没有解释

1728
01:06:23,670 --> 01:06:26,279
这个所以有一个 命令有

1729
01:06:26,279 --> 01:06:27,960
一堆你可以再次运行的函数我

1730
01:06:27,960 --> 01:06:29,789
在互联网上找到了这个我没有写

1731
01:06:29,789 --> 01:06:30,569


1732
01:06:30,569 --> 01:06:32,609
这个基本上破译了这个现在

1733
01:06:32,609 --> 01:06:34,289
你得到这里的文件号

1734
01:06:34,289 --> 01:06:36,269
块号和行槽

1735
01:06:36,269 --> 01:06:38,910
与我们之前在续集中看到的相同 服务器

1736
01:06:38,910 --> 01:06:41,819
好吧让我们这样做让我们

1737
01:06:41,819 --> 01:06:48,440
删除第二个人然后回去不能这样做

1738
01:06:52,190 --> 01:06:57,509
所以插槽是0 1 2并且

1739
01:06:57,509 --> 01:07:01,230
仍然在0 2让我们去插入我们的

1740
01:07:01,230 --> 01:07:05,480
新元组好吧所以谁说它会

1741
01:07:05,480 --> 01:07:11,880
在插槽1  2 好吧，谁说它会是第

1742
01:07:11,880 --> 01:07:17,160
4 位或第 3 位，更不用说没有人知道第

1743
01:07:17,160 --> 01:07:19,430


1744
01:07:21,329 --> 01:07:25,960
3 位好，所以又一次，

1745
01:07:25,960 --> 01:07:27,789
海岸过度压缩页面的

1746
01:07:27,789 --> 01:07:29,829
主要内容没有写回 Oracle 和

1747
01:07:29,829 --> 01:07:31,660
Postgres 是否精英再次将空插槽

1748
01:07:31,660 --> 01:07:36,609
留在那里 这

1749
01:07:36,609 --> 01:07:38,019
对系统的其他部分无关紧要，

1750
01:07:38,019 --> 01:07:39,549
这只是系统

1751
01:07:39,549 --> 01:07:42,220
内部组织页面内的元组或插槽

1752
01:07:42,220 --> 01:07:49,140


1753
01:07:50,880 --> 01:07:52,089


1754
01:07:52,089 --> 01:07:53,920


1755
01:07:53,920 --> 01:07:59,829
的方式

1756
01:07:59,829 --> 01:08:03,970
谈现在 我们是否在做时间是的这个

1757
01:08:03,970 --> 01:08:05,470
问题是为什么要向用户公开安全 API

1758
01:08:05,470 --> 01:08:17,319
，因此数据库系统是非常

1759
01:08:17,319 --> 01:08:19,600
复杂的软件，人们会

1760
01:08:19,600 --> 01:08:23,080
以维护它们的方式获得报酬，因此通过

1761
01:08:23,080 --> 01:08:25,689
将所有元数据公开给

1762
01:08:25,689 --> 01:08:28,380
最终用户（如管理员） 只是

1763
01:08:28,380 --> 01:08:30,759
可能超级帮助他们弄清楚

1764
01:08:30,759 --> 01:08:32,710
为什么它会做某些事情，这

1765
01:08:32,710 --> 01:08:34,118
就是我要说的，但是如果您不想

1766
01:08:34,118 --> 01:08:36,969
使用其中任何一个来编写您的应用程序，

1767
01:08:36,969 --> 01:08:40,359
它就不可靠，嗯让我们

1768
01:08:40,359 --> 01:08:41,350
使用 Postgres 因为我知道如何做

1769
01:08:41,350 --> 01:08:46,359
Postgres 所以回去 对此，

1770
01:08:46,359 --> 01:08:48,609
Postgres 再次我们已经

1771
01:08:48,609 --> 01:08:50,649
用真空进行了压缩，但 Postgres

1772
01:08:50,649 --> 01:08:52,479
实际上会让你这样做 你可以

1773
01:08:52,479 --> 01:08:57,899
说 CT ID 让我把它放在

1774
01:08:57,899 --> 01:09:05,218
哪里对不起 c tige 等于然后 0 1 对

1775
01:09:05,969 --> 01:09:08,589
这样我就可以访问该工具 完全

1776
01:09:08,589 --> 01:09:10,689
基于它的类似商店位置 我

1777
01:09:10,689 --> 01:09:12,250
不想在我的应用程序中这样做，

1778
01:09:12,250 --> 01:09:15,009
因为在任何时候数据系统

1779
01:09:15,009 --> 01:09:16,569
允许重新组织它我最终可能会

1780
01:09:16,569 --> 01:09:18,549
得到一个不同的 CIT ID，所以它是独一无二的，

1781
01:09:18,549 --> 01:09:20,889
就像你知道的那样我可以独一无二 我确定一个

1782
01:09:20,889 --> 01:09:23,020
元组，但我不想这样做，

1783
01:09:23,020 --> 01:09:26,109
因为它会再次搞砸

1784
01:09:26,109 --> 01:09:28,029
我认为答案只是暴露

1785
01:09:28,029 --> 01:09:29,500
系统的内部结构，让

1786
01:09:29,500 --> 01:09:30,488
管理员了解发生了什么

1787
01:09:30,488 --> 01:09:32,729


1788
01:09:32,729 --> 01:09:39,399
是的，繁荣

1789
01:09:39,399 --> 01:09:40,660
他的问题是什么 如果你有

1790
01:09:40,660 --> 01:09:44,560
一个，如果你尝试命名一个列，

1791
01:09:44,560 --> 01:09:45,850
我可能会尝试命名一个表，

1792
01:09:45,850 --> 01:09:50,170
让我们看看，所以删除表 xxx 创建

1793
01:09:50,170 --> 01:09:51,810
表

1794
01:09:51,810 --> 01:09:59,890
xxx ID 和 CT ID int 看看谁说它会

1795
01:09:59,890 --> 01:10:01,390
被允许这样做是的 或不

1796
01:10:01,390 --> 01:10:05,700
举手 是的 举手的地方 否

1797
01:10:05,700 --> 01:10:09,420
是的，您不能这样做，

1798
01:10:09,750 --> 01:10:14,230
让我们尝试 Oracle 大表

1799
01:10:14,230 --> 01:10:22,960
xxx heidi 和行 ID int nope 喜欢它

1800
01:10:22,960 --> 01:10:26,080
所以是的，它是一个保留名称 还有

1801
01:10:26,080 --> 01:10:27,250
很多其他的东西你不能喜欢我

1802
01:10:27,250 --> 01:10:32,680
实际上不能命名就像我可以命名一

1803
01:10:32,680 --> 01:10:37,740
列这是 C 代码就像抱歉

1804
01:10:38,220 --> 01:10:41,920
续集服务器按下休息好吧所以让我们

1805
01:10:41,920 --> 01:10:43,720
尝试创建表就像你不能命名一个

1806
01:10:43,720 --> 01:10:48,180
列 int 我不认为你可以

1807
01:10:48,790 --> 01:10:51,899
[音乐]

1808
01:10:52,210 --> 01:10:56,170
从不系统 做不同的事情是的，

1809
01:10:56,170 --> 01:11:00,960
好吧，不要那样做，那是个坏主意，

1810
01:11:00,960 --> 01:11:12,340
好吧，你有时间吗 所以

1811
01:11:12,340 --> 01:11:14,110
我们的时间很短 所以让我快速

1812
01:11:14,110 --> 01:11:15,690
谈谈大号布局

1813
01:11:15,690 --> 01:11:18,909
然后将设置它 设置

1814
01:11:18,909 --> 01:11:22,650
我们正在谈论的下一堂课

1815
01:11:23,100 --> 01:11:26,469
所以我们世界中的一个元组它只是一个

1816
01:11:26,469 --> 01:11:29,530
字节序列 是的，如果我们只是

1817
01:11:29,530 --> 01:11:32,170
设置了一个插槽，我们只需要写

1818
01:11:32,170 --> 01:11:33,310
一堆字节序列就

1819
01:11:33,310 --> 01:11:35,170
完成了，所以数据的工作

1820
01:11:35,170 --> 01:11:37,060
是能够再次解释这些字节的

1821
01:11:37,060 --> 01:11:38,710
实际含义，这就是

1822
01:11:38,710 --> 01:11:40,000
这个模式的用武之地 所以该方案

1823
01:11:40,000 --> 01:11:41,590
会说我有一个 int 它是 32 位

1824
01:11:41,590 --> 01:11:43,659
我已经到了 64 位所以当我查看

1825
01:11:43,659 --> 01:11:45,429
我的 60 可能可能是我的

1826
01:11:45,429 --> 01:11:46,690
字节序列我知道如何跳转到不同的

1827
01:11:46,690 --> 01:11:48,280
偏移量以找到我想要的

1828
01:11:48,280 --> 01:11:50,710
所有列 是的，它看起来像

1829
01:11:50,710 --> 01:11:53,500
这样，我们的元组又像

1830
01:11:53,500 --> 01:11:55,420


1831
01:11:55,420 --> 01:11:57,699
我们页面中所有集合中的起始位置，我们将有一个标题

1832
01:11:57,699 --> 01:11:58,989
跟踪不同的事情，例如

1833
01:11:58,989 --> 01:12:00,670
您是否知道什么事务

1834
01:12:00,670 --> 01:12:02,920
查询修改了它，然后我们 将

1835
01:12:02,920 --> 01:12:06,010
有实际的你知道关于什么时候的元数据

1836
01:12:06,010 --> 01:12:07,810
我们有空值，

1837
01:12:07,810 --> 01:12:10,179
然后实际上是元组，所以我们

1838
01:12:10,179 --> 01:12:12,219
通常不需要在元组本身中存储

1839
01:12:12,219 --> 01:12:14,500
关于元组的元数据，

1840
01:12:14,500 --> 01:12:17,830
所以当我们存储两个

1841
01:12:17,830 --> 01:12:19,360
但我们不会说嘿我有四列

1842
01:12:19,360 --> 01:12:21,190
还有这个 类型我们在页面内或在目录页面本身内存储该类型

1843
01:12:21,190 --> 01:12:22,989
和更高级别的元数据信息

1844
01:12:22,989 --> 01:12:24,969
，

1845
01:12:24,969 --> 01:12:27,699
您必须

1846
01:12:27,699 --> 01:12:30,610
在类似 JSON 数据库或

1847
01:12:30,610 --> 01:12:33,040
模式数据库（如 MongoDB）中执行此操作，因为

1848
01:12:33,040 --> 01:12:34,989
每个元组每个记录

1849
01:12:34,989 --> 01:12:36,489
可能与每个文档不同

1850
01:12:36,489 --> 01:12:38,170
不同，所以你必须存储

1851
01:12:38,170 --> 01:12:39,730
关于它实际内部

1852
01:12:39,730 --> 01:12:43,750
内容的元数据，所以在元组数据本身内部，

1853
01:12:43,750 --> 01:12:47,260
你通常

1854
01:12:47,260 --> 01:12:49,719
按照创建表的顺序存储它们，所以如果我

1855
01:12:49,719 --> 01:12:52,080
说你知道创建表 ABCDE，我

1856
01:12:52,080 --> 01:12:54,820
通常只会最 系统

1857
01:12:54,820 --> 01:12:56,770
按照它们在我们创建时发生的顺序扭曲

1858
01:12:56,770 --> 01:12:58,360
你不必

1859
01:12:58,360 --> 01:12:59,830
国家模型说你不必这样

1860
01:12:59,830 --> 01:13:02,080
做但通常大多数系统都会这样做

1861
01:13:02,080 --> 01:13:04,120
如果你被谈论排序 你们中的一些人

1862
01:13:04,120 --> 01:13:05,230
知道在试图提高缓存效率的内存系统中，

1863
01:13:05,230 --> 01:13:06,070


1864
01:13:06,070 --> 01:13:08,290
或者您可以重新排序，以便您的

1865
01:13:08,290 --> 01:13:11,020
字与现金行对齐，但出于我们的

1866
01:13:11,020 --> 01:13:13,800
目的，我们不在乎

1867
01:13:13,800 --> 01:13:16,630
所以我们讨论的最后一件事是

1868
01:13:16,630 --> 01:13:18,850
他之前关于存储数据的问题

1869
01:13:18,850 --> 01:13:21,730
来自同一页面内的不同表

1870
01:13:21,730 --> 01:13:24,670
，我说大多数系统不这样做

1871
01:13:24,670 --> 01:13:29,410
，

1872
01:13:29,410 --> 01:13:31,170
原因是你不想这样做的原因是

1873
01:13:31,170 --> 01:13:33,220
因为如果你希望事情是

1874
01:13:33,220 --> 01:13:35,020
独立的，你不想要 一堆

1875
01:13:35,020 --> 01:13:36,070
关于这些不同表的额外元数据

1876
01:13:36,070 --> 01:13:38,740
出现在你对

1877
01:13:38,740 --> 01:13:41,850
表或预连接表进行反规范化时，

1878
01:13:41,850 --> 01:13:44,110
所以我们不是在谈论你还不知道

1879
01:13:44,110 --> 01:13:45,550
的类中的规范形式或函数依赖关系，

1880
01:13:45,550 --> 01:13:47,620
但你会感谢

1881
01:13:47,620 --> 01:13:49,030
当你长大的时候我，因为他们是

1882
01:13:49,030 --> 01:13:49,690
可怕的

1883
01:13:49,690 --> 01:13:51,190
人们每次你

1884
01:13:51,190 --> 01:13:52,630
试图教他们大多数数据库课程时都会

1885
01:13:52,630 --> 01:13:53,980


1886
01:13:53,980 --> 01:13:56,710


1887
01:13:56,710 --> 01:13:58,240


1888
01:13:58,240 --> 01:14:00,760
哭 但

1889
01:14:00,760 --> 01:14:03,010
几乎没有人这样做 所以

1890
01:14:03,010 --> 01:14:05,530
当我第一次教这门课时，我们做了

1891
01:14:05,530 --> 01:14:07,710
两节关于范式的完整讲座，

1892
01:14:07,710 --> 01:14:10,030
我们不需要这样做，你只

1893
01:14:10,030 --> 01:14:11,560
需要知道它们存在什么，它们

1894
01:14:11,560 --> 01:14:13,600
存在，它意味着什么，

1895
01:14:13,600 --> 01:14:15,250
这就是这张幻灯片的内容 所以我们

1896
01:14:15,250 --> 01:14:16,630
要 Katz 像一张幻灯片中的两个讲座一样

1897
01:14:16,630 --> 01:14:17,050


1898
01:14:17,050 --> 01:14:20,740
好所以规范化基本上是

1899
01:14:20,740 --> 01:14:22,540
我们如何将我们的数据库拆分到

1900
01:14:22,540 --> 01:14:24,340
不同的表中，

1901
01:14:24,340 --> 01:14:25,630
当你有外键时，这种自然会发生，

1902
01:14:25,630 --> 01:14:28,510
比如我有艺术家和专辑，我

1903
01:14:28,510 --> 01:14:30,160
可以让你知道 外键

1904
01:14:30,160 --> 01:14:33,790
将它们分开，因此我们在

1905
01:14:33,790 --> 01:14:35,410
设计

1906
01:14:35,410 --> 01:14:37,720
应用程序时自然而然地执行此类操作，现在在某些情况下，

1907
01:14:37,720 --> 01:14:40,540
我们实际上希望将一个表嵌入到另一个表中，

1908
01:14:40,540 --> 01:14:43,030
如果我们想避免

1909
01:14:43,030 --> 01:14:44,920
它可能会进行连接的开销，我们

1910
01:14:44,920 --> 01:14:46,480
可以说这是艺术家推出的所有专辑，这些专辑

1911
01:14:46,480 --> 01:14:48,190
将它们内联

1912
01:14:48,190 --> 01:14:51,010
在自己的元组中，在这种情况下，在

1913
01:14:51,010 --> 01:14:53,800
单个页面中，我们可以将来自

1914
01:14:53,800 --> 01:14:55,150
两个不同表格的数据打包在

1915
01:14:55,150 --> 01:14:57,280
同一页面旁边的标志中，所以让我们看看

1916
01:14:57,280 --> 01:14:58,660
非常简单的例子我有两个表

1917
01:14:58,660 --> 01:15:00,670
foo 和 bar bar 有一个外键

1918
01:15:00,670 --> 01:15:03,100
依赖引用到 food 表

1919
01:15:03,100 --> 01:15:06,250
所以通常我会像这样存储我的元组

1920
01:15:06,250 --> 01:15:08,680
我会存储它们它完全

1921
01:15:08,680 --> 01:15:10,840
分开存储在其页面中的 bar 表的所有数据

1922
01:15:10,840 --> 01:15:12,640
和所有

1923
01:15:12,640 --> 01:15:14,040
食物表的数据存储在此页面中，

1924
01:15:14,040 --> 01:15:16,720
但如果大部分时间我都尝试

1925
01:15:16,720 --> 01:15:18,280
将这两个表连接在一起以进行每个

1926
01:15:18,280 --> 01:15:19,780


1927
01:15:19,780 --> 01:15:22,360


1928
01:15:22,360 --> 01:15:24,849
查询 一个给定的 foo 那么也许

1929
01:15:24,849 --> 01:15:27,940
我想要做的只是将 bar

1930
01:15:27,940 --> 01:15:30,780
元组直接嵌入到食物表中，

1931
01:15:30,780 --> 01:15:33,900
所以现在如果你像我一样回到这里，我

1932
01:15:33,900 --> 01:15:38,170
正在复制

1933
01:15:38,170 --> 01:15:40,630
每个 bar 元组的 a 属性，但

1934
01:15:40,630 --> 01:15:42,190
现在如果我 把它装在里面 我

1935
01:15:42,190 --> 01:15:44,159
不需要重复它 我只拥有

1936
01:15:44,159 --> 01:15:46,030
另一张桌子唯一的列

1937
01:15:46,030 --> 01:15:48,639
所以这被称为

1938
01:15:48,639 --> 01:15:51,219
非规范化另一个 我认为

1939
01:15:51,219 --> 01:15:52,989
这就像预加入 我将两个

1940
01:15:52,989 --> 01:15:54,460
碗装在彼此里面 我 可以

1941
01:15:54,460 --> 01:15:56,499
做这个逻辑 盟友通过重写我的

1942
01:15:56,499 --> 01:15:57,969
应用程序并以这种方式创建表格，

1943
01:15:57,969 --> 01:15:59,199
或者我可以在物理上做到这一点，这

1944
01:15:59,199 --> 01:16:00,940
就是我们在这里关心的事情，

1945
01:16:00,940 --> 01:16:02,800
我们正在像这样存储我们的页面

1946
01:16:02,800 --> 01:16:04,900
，应用程序仍然可以告诉我们

1947
01:16:04,900 --> 01:16:07,179
嘿，我有两个单独的表格，但

1948
01:16:07,179 --> 01:16:08,739
在下面 封面和我们的页面

1949
01:16:08,739 --> 01:16:09,969
实际上会将它们组合在一起攻击它们

1950
01:16:09,969 --> 01:16:14,380
，所以这是

1951
01:16:14,380 --> 01:16:16,389
我认为系统实际上尝试

1952
01:16:16,389 --> 01:16:17,920
将来自两个不同表的数据存储

1953
01:16:17,920 --> 01:16:21,429
在同一个元组中的唯一一次，这不是

1954
01:16:21,429 --> 01:16:23,590
一个新想法，它可以

1955
01:16:23,590 --> 01:16:26,349
追溯到 1970 年代 IBM 在 IBM

1956
01:16:26,349 --> 01:16:27,849
发明第一个数据库系统

1957
01:16:27,849 --> 01:16:29,380
系统或第一个关系数据库

1958
01:16:29,380 --> 01:16:33,070
系统时首先发明了这个，但结果证明这是一个

1959
01:16:33,070 --> 01:16:34,809
巨大的选择来维护软件

1960
01:16:34,809 --> 01:16:36,880
，然后当他们离开并制作 db2 时他们放弃了它，

1961
01:16:36,880 --> 01:16:39,340
所以系统 R

1962
01:16:39,340 --> 01:16:40,269
第一个关系 最早出现的

1963
01:16:40,269 --> 01:16:41,289
关系数据库之一，

1964
01:16:41,289 --> 01:16:43,150
但他们从未商业化 它从未

1965
01:16:43,150 --> 01:16:44,650
出售过，但他们

1966
01:16:44,650 --> 01:16:46,840
在 1980 年代使用了一些代码并创建了 db2

1967
01:16:46,840 --> 01:16:49,570
今天仍然存在，所以它

1968
01:16:49,570 --> 01:16:51,639
实际上出现在今天更现代的系统中

1969
01:16:51,639 --> 01:16:54,909
，所以如果你从谷歌那里得到了云生成器，

1970
01:16:54,909 --> 01:16:56,889
如果你在

1971
01:16:56,889 --> 01:16:58,150
定义一个 proto protobufs

1972
01:16:58,150 --> 01:17:00,610
API 时拥有它，你实际上可以打包它会

1973
01:17:00,610 --> 01:17:02,650
打包两个 不同的表

1974
01:17:02,650 --> 01:17:04,599
放在同一个元组中，十年前有一个初创公司，

1975
01:17:04,599 --> 01:17:06,159
叫做

1976
01:17:06,159 --> 01:17:08,409
Caban，它基本上

1977
01:17:08,409 --> 01:17:09,670
为我的续集销售了一个存储引擎，它

1978
01:17:09,670 --> 01:17:11,499
自动进行了这种非规范化，他们

1979
01:17:11,499 --> 01:17:13,030
被基金会 BB 收购了，甚至

1980
01:17:13,030 --> 01:17:15,579
基金会 DB 也被收购了 由 Apple 提供，

1981
01:17:15,579 --> 01:17:17,469
因此优惠券不再存在，

1982
01:17:17,469 --> 01:17:19,929
然后一堆这些文档数据库

1983
01:17:19,929 --> 01:17:21,789
或 JSON 数据库本质上在

1984
01:17:21,789 --> 01:17:23,829
做同样的事情，当您定义

1985
01:17:23,829 --> 01:17:25,510
JSON 文档时，您可以

1986
01:17:25,510 --> 01:17:28,389
在 JSON 文档本身的相关属性中预先加入 PAC

1987
01:17:28,389 --> 01:17:30,429
，那就是

1988
01:17:30,429 --> 01:17:32,929
基本上做同样的事情

1989
01:17:32,929 --> 01:17:35,449
好吧，这是人们唯一一次

1990
01:17:35,449 --> 01:17:37,130
真正将来自

1991
01:17:37,130 --> 01:17:39,130
不同表的元组存储在同一页面中的

1992
01:17:39,130 --> 01:17:42,560
时候

1993
01:17:42,560 --> 01:17:45,739
好吧，我们今天又要讨论什么

1994
01:17:45,739 --> 01:17:48,050
数据库是按页面组织的，

1995
01:17:48,050 --> 01:17:49,280
它们以不同的方式跟踪

1996
01:17:49,280 --> 01:17:51,320
我们文件中的页面，然后

1997
01:17:51,320 --> 01:17:52,640
在这些页面中，我们可以以不同的方式存储它们，并以

1998
01:17:52,640 --> 01:17:53,870
不同的方式将我们的元组存储

1999
01:17:53,870 --> 01:17:57,409
在页面中，因此对于

2000
01:17:57,409 --> 01:17:59,690
第一个作业 第一个编程

2001
01:17:59,690 --> 01:18:01,489
项目 我们已经

2002
01:18:01,489 --> 01:18:03,980
为您处理好了页面布局

2003
01:18:03,980 --> 01:18:05,300
，我们已经为您编写了磁盘管理

2004
01:18:05,300 --> 01:18:08,030
器 当我们进入第二个

2005
01:18:08,030 --> 01:18:09,320
项目时，您实际上必须

2006
01:18:09,320 --> 01:18:11,480
定义页面布局 是为

2007
01:18:11,480 --> 01:18:12,980
您的 为您的索引 您将要

2008
01:18:12,980 --> 01:18:17,120
构建的索引 下一节课我们将

2009
01:18:17,120 --> 01:18:18,890
讨论您如何实际表示

2010
01:18:18,890 --> 01:18:20,239
元组中的值 所以我们现在

2011
01:18:20,239 --> 01:18:22,280
将在自行车序列中吃两个

2012
01:18:22,280 --> 01:18:24,380
碗 你谈论的是什么 轴向

2013
01:18:24,380 --> 01:18:26,090
平均看起来像 然后我们将

2014
01:18:26,090 --> 01:18:27,620
讨论存储模型 我们实际上

2015
01:18:27,620 --> 01:18:31,730
将如何表示我们如何

2016
01:18:31,730 --> 01:18:35,000
在一个表中组织两个帖子本身

2017
01:18:35,000 --> 01:18:39,909
好的 任何问题 是

2018
01:18:40,740 --> 01:18:43,810
[音乐]

2019
01:18:44,559 --> 01:18:47,210
她的问题是哪个 是一个很棒的

2020
01:18:47,210 --> 01:18:49,190
问题 数据库的测试驱动开发是

2021
01:18:49,190 --> 01:18:50,780
什么样的 我怎么知道

2022
01:18:50,780 --> 01:18:54,559
我正在正确地运行查询 巨大的话题

2023
01:18:54,559 --> 01:18:56,570
让我们事后谈谈我

2024
01:18:56,570 --> 01:18:57,980
非常感兴趣 我

2025
01:18:57,980 --> 01:18:59,360
实际上正在尝试雇用某人来做

2026
01:18:59,360 --> 01:19:12,800
这件事 我们昨天 好吧伙计

2027
01:19:12,800 --> 01:19:36,949


2028
01:19:36,949 --> 01:19:46,639


2029
01:19:46,639 --> 01:19:50,570


2030
01:19:50,570 --> 01:19:53,530
们周一见

