1
00:00:03,640 --> 00:00:13,140
[音乐]

2
00:00:14,379 --> 00:00:23,480
好的，直接进入它，所以你们的日程安排

3
00:00:23,480 --> 00:00:25,070


4
00:00:25,070 --> 00:00:27,499
显然是两天后的主要事情

5
00:00:27,499 --> 00:00:29,839
，周三在这个教室里，我们

6
00:00:29,839 --> 00:00:33,050
将有

7
00:00:33,050 --> 00:00:35,420
自上周以来一直在线的期中考试学习人员，

8
00:00:35,420 --> 00:00:36,710
还有我也参加过的模拟考试

9
00:00:36,710 --> 00:00:38,780
上传了所有讲座 本周末考试中涵盖的所有课程的

10
00:00:38,780 --> 00:00:39,920
所有讲义和所有幻灯片

11
00:00:39,920 --> 00:00:42,230


12
00:00:42,230 --> 00:00:45,070
然后

13
00:00:45,070 --> 00:00:48,489
教科书中还有其他问题

14
00:00:48,489 --> 00:00:50,390
奇怪的解决方案可

15
00:00:50,390 --> 00:00:53,300
在线获得，因此

16
00:00:53,300 --> 00:00:57,920
您需要携带有关期中考试的任何高级问题 你的 CMU

17
00:00:57,920 --> 00:00:59,300
ID 因为它是一个 100 人的班级

18
00:00:59,300 --> 00:01:01,699
我不认识每个人 我应该

19
00:01:01,699 --> 00:01:03,350
带一个计算器 如果你不能

20
00:01:03,350 --> 00:01:06,310
在你的脑海里做日志而且你没有

21
00:01:06,310 --> 00:01:09,010
一个八分之一 我让我一张纸

22
00:01:09,010 --> 00:01:11,990
加倍 - 手写笔记的一面 没有

23
00:01:11,990 --> 00:01:13,790
缩小它 幻灯片 蹲下来

24
00:01:13,790 --> 00:01:15,320
让你的笔记知道慢慢缩小

25
00:01:15,320 --> 00:01:16,460
教科书我将手写的所有内容

26
00:01:16,460 --> 00:01:20,450
你会得到更多这样的方式所以

27
00:01:20,450 --> 00:01:23,439
任何关于这些事情的问题

28
00:01:23,860 --> 00:01:27,619
好吧好吧，然后项目二也将

29
00:01:27,619 --> 00:01:32,030
在周日午夜到期 我

30
00:01:32,030 --> 00:01:34,280
希望你我在广场上发布了

31
00:01:34,280 --> 00:01:35,810
类似的问题，

32
00:01:35,810 --> 00:01:37,570
然后眼泪在需要时有所帮助

33
00:01:37,570 --> 00:01:41,149
好吧，所以我们今天有很多

34
00:01:41,149 --> 00:01:42,350
讨论 我不认为我

35
00:01:42,350 --> 00:01:43,250
会完成所有这些，

36
00:01:43,250 --> 00:01:45,259
所以它可能会

37
00:01:45,259 --> 00:01:47,770
在考试结束后蔓延到

38
00:01:47,770 --> 00:01:51,259
下周，看看会发生什么，所以今天

39
00:01:51,259 --> 00:01:54,890
我们正在讨论和查询计划，所以

40
00:01:54,890 --> 00:01:56,719
高级别的想法我们是什么 今天尝试做的

41
00:01:56,719 --> 00:01:59,659
是，鉴于续集是

42
00:01:59,659 --> 00:02:03,109
声明性的，这

43
00:02:03,109 --> 00:02:05,149
意味着向我们发送查询的应用程序查询说明

44
00:02:05,149 --> 00:02:07,090
他们希望我们计算的答案

45
00:02:07,090 --> 00:02:09,440
正确地从该表中选择这个

46
00:02:09,440 --> 00:02:12,200
产生具有此

47
00:02:12,200 --> 00:02:15,650
特定属性的所有员工 I 和他们和它

48
00:02:15,650 --> 00:02:17,540
没有告诉我们我们实际上应该

49
00:02:17,540 --> 00:02:19,849
如何计算这个权利并没有说做一个

50
00:02:19,849 --> 00:02:20,640
散列连接

51
00:02:20,640 --> 00:02:22,319
让我们看看加入虽然你可以做这样的

52
00:02:22,319 --> 00:02:24,660
提示但我们现在可以忽略

53
00:02:24,660 --> 00:02:26,490
它是对的，只是他们

54
00:02:26,490 --> 00:02:28,920
告诉我们他们想要什么答案，所以

55
00:02:28,920 --> 00:02:31,020
它是 为我们准备 现在在

56
00:02:31,020 --> 00:02:32,400
人们实际构建的数据库系统中，但他们

57
00:02:32,400 --> 00:02:34,350
有一个系统软件，我们有

58
00:02:34,350 --> 00:02:36,690
责任进行简单的查询

59
00:02:36,690 --> 00:02:39,690
并找出执行它的最佳方式和最

60
00:02:39,690 --> 00:02:44,610
有效的方式，因此如果我们

61
00:02:44,610 --> 00:02:47,520
从上周或

62
00:02:47,520 --> 00:02:48,480
前几周看到 我们讨论了联合

63
00:02:48,480 --> 00:02:50,100
算法，但

64
00:02:50,100 --> 00:02:51,989
根据您选择的专辑，它们的性能可能会有很大差异

65
00:02:51,989 --> 00:02:53,310


66
00:02:53,310 --> 00:02:55,680
我们有愚蠢的循环连接混乱

67
00:02:55,680 --> 00:02:57,239
对于一个 6 兆字节的表需要一点三个小时，

68
00:02:57,239 --> 00:02:59,310
但如果您在

69
00:02:59,310 --> 00:03:02,250
哈希连接中这样做最糟糕 案例场景是 0.5

70
00:03:02,250 --> 00:03:06,900
秒，所以你知道这个有 8 个吐痰，这

71
00:03:06,900 --> 00:03:08,040
是很明显的，我们

72
00:03:08,040 --> 00:03:09,060
不想做愚蠢的事情

73
00:03:09,060 --> 00:03:10,470
，当我们开始获得更复杂的查询时，我们可以弄清楚这一点，

74
00:03:10,470 --> 00:03:12,209
更复杂地加入这些查询，

75
00:03:12,209 --> 00:03:15,480
然后弄清楚如何

76
00:03:15,480 --> 00:03:16,739
从这个开始 对此，它并不总是

77
00:03:16,739 --> 00:03:19,769
很明显，这就是为什么在这个新版本中，这

78
00:03:19,769 --> 00:03:21,660


79
00:03:21,660 --> 00:03:22,860
就是将非常昂贵的高端数据库系统、

80
00:03:22,860 --> 00:03:24,989
oracles、db2 和

81
00:03:24,989 --> 00:03:27,180
Teradata 分开的原因 是续集服务器

82
00:03:27,180 --> 00:03:29,640
与源服务器一样是免费的

83
00:03:29,640 --> 00:03:32,220
Postgres 仍然非常好，但

84
00:03:32,220 --> 00:03:35,010
查询优化器没有

85
00:03:35,010 --> 00:03:37,860
续集服务器报告

86
00:03:37,860 --> 00:03:41,880
示例那么复杂，所以关于查询

87
00:03:41,880 --> 00:03:44,670
优化器的想法可以追溯到 1970 年代，所以我

88
00:03:44,670 --> 00:03:45,810
不 我想我

89
00:03:45,810 --> 00:03:47,489
在这门课上谈过一点系统，但我说的是

90
00:03:47,489 --> 00:03:51,180
为什么，但在 1970 年代，

91
00:03:51,180 --> 00:03:52,890
当 Ted Cod 写了第一篇

92
00:03:52,890 --> 00:03:54,870
关于关系模型的论文时，

93
00:03:54,870 --> 00:03:56,760
基本上有两个人或两个小组

94
00:03:56,760 --> 00:03:57,600
拿起它 并尝试实际

95
00:03:57,600 --> 00:03:59,700
实现它 因为让 Ted Cod 是

96
00:03:59,700 --> 00:04:01,680
一位理论家 它是一位数学家 所以

97
00:04:01,680 --> 00:04:03,120
他不必在软件中使用它 他

98
00:04:03,120 --> 00:04:04,350
只是提出了一个想法

99
00:04:04,350 --> 00:04:06,269
Haagen 放置模型说这是

100
00:04:06,269 --> 00:04:08,610
实际构建软件的正确方法

101
00:04:08,610 --> 00:04:11,010
然后那里 是圣何塞的 IBM 的

102
00:04:11,010 --> 00:04:15,120
一个小组，然后是加州大学伯克利分校的一个小组，他们

103
00:04:15,120 --> 00:04:16,350
最终接受了这笔付款，实际上

104
00:04:16,350 --> 00:04:17,970
建立了你知道前两个

105
00:04:17,970 --> 00:04:19,709
关系数据至少已经评估过

106
00:04:19,709 --> 00:04:22,169
最著名的那些在伯克利没有人

107
00:04:22,169 --> 00:04:25,620
被称为 ingress 那是你

108
00:04:25,620 --> 00:04:27,479
知道我的后期课程被称为

109
00:04:27,479 --> 00:04:29,910
Postgres 同一个人逮捕也是

110
00:04:29,910 --> 00:04:30,449
研究生，

111
00:04:30,449 --> 00:04:32,849
因为它是后移民，这

112
00:04:32,849 --> 00:04:35,279
就是名字的由来 我认为他是

113
00:04:35,279 --> 00:04:37,759
我在研究生院时的顾问

114
00:04:37,759 --> 00:04:42,809
，然后成为 IBM 的人，他们建立了

115
00:04:42,809 --> 00:04:44,969
一个叫做系统艺术的东西，这个

116
00:04:44,969 --> 00:04:46,439
项目实际上很吸引人，因为他们

117
00:04:46,439 --> 00:04:48,300
有八九个人都拥有

118
00:04:48,300 --> 00:04:50,279
数学和计算机科学的博士学位，

119
00:04:50,279 --> 00:04:51,569
这是早期的计算机科学，但

120
00:04:51,569 --> 00:04:53,430
没有多少人拥有数学和计算机科学的研究生

121
00:04:53,430 --> 00:04:55,080
学位。 计算机科学他们把

122
00:04:55,080 --> 00:04:56,039
他们放在房间外说我们要建立

123
00:04:56,039 --> 00:04:57,689
一个关系数据库系统然后

124
00:04:57,689 --> 00:04:59,189
每个人都

125
00:04:59,189 --> 00:05:01,919
从房间里分出问题的一部分，一个

126
00:05:01,919 --> 00:05:03,300
人在存储层

127
00:05:03,300 --> 00:05:04,529
工作，一个人在执行

128
00:05:04,529 --> 00:05:06,240
引擎 一个人从事并发

129
00:05:06,240 --> 00:05:08,639
控制，有一个人

130
00:05:08,639 --> 00:05:10,169
通过气缸，她保持查询

131
00:05:10,169 --> 00:05:13,400
优化 Krita curry 优化器，

132
00:05:13,400 --> 00:05:17,669
所以当时的想法是你可以

133
00:05:17,669 --> 00:05:19,259
拥有 一个数据库分钟系统 进行

134
00:05:19,259 --> 00:05:22,469
查询 像 sequel 这样的声明性语言

135
00:05:22,469 --> 00:05:24,779
get Ted Cod 最初从未真正提出过

136
00:05:24,779 --> 00:05:26,339
一种最初带有关系模型的语言

137
00:05:26,339 --> 00:05:28,409
sequel 后来出现因为它是

138
00:05:28,409 --> 00:05:30,779
由 IBM 嵌入的

139
00:05:30,779 --> 00:05:32,580


140
00:05:32,580 --> 00:05:34,169
语法

141
00:05:34,169 --> 00:05:34,860
有所不同

142
00:05:34,860 --> 00:05:37,469
Mike Stonebraker 这个人不会

143
00:05:37,469 --> 00:05:38,879
穿衣服他会不会声称 Quayle

144
00:05:38,879 --> 00:05:42,149
优于续集我不同意但你

145
00:05:42,149 --> 00:05:44,520
知道现在没有人写得很好所以但

146
00:05:44,520 --> 00:05:47,129
在那时人们认为

147
00:05:47,129 --> 00:05:48,870
丹地下室系统没有办法

148
00:05:48,870 --> 00:05:50,699
接受 高级语言，如 sequel

149
00:05:50,699 --> 00:05:53,249
或 quell，并生成一个高效的查询工厂，

150
00:05:53,249 --> 00:05:54,779
人类可以

151
00:05:54,779 --> 00:05:56,909
在我手中做的事情，因为如果你正在编写这个，

152
00:05:56,909 --> 00:05:58,319
那么在理性模型之前人们正在做

153
00:05:58,319 --> 00:06:00,029
这些查询计划

154
00:06:00,029 --> 00:06:01,439
，就像编写 for 循环并

155
00:06:01,439 --> 00:06:05,219
手动进行连接和扫描等

156
00:06:05,219 --> 00:06:06,810
方式与

157
00:06:06,810 --> 00:06:10,589
他在 CC 语言问世时

158
00:06:10,589 --> 00:06:13,020
争论的方式相同

159
00:06:13,020 --> 00:06:14,399
编译器生成的机器代码永远不会

160
00:06:14,399 --> 00:06:15,959
像今天人类可以

161
00:06:15,959 --> 00:06:17,580
编写的那样有效，或者人类可以

162
00:06:17,580 --> 00:06:19,319
编写程序集，当然现在我们

163
00:06:19,319 --> 00:06:20,999
知道没有人会

164
00:06:20,999 --> 00:06:22,620
手工编写大部分程序集，每个人都使用

165
00:06:22,620 --> 00:06:24,629
比 C 更高的高级语言编写

166
00:06:24,629 --> 00:06:26,999
和 编译器在这些情况下做得非常好，

167
00:06:26,999 --> 00:06:28,349
它们甚至可以做得

168
00:06:28,349 --> 00:06:30,959
比普通人做得更好 这是

169
00:06:30,959 --> 00:06:32,879
我在 1970 年代得到改进的

170
00:06:32,879 --> 00:06:34,319
，您可以采用声明的语言

171
00:06:34,319 --> 00:06:36,870
生活续集，并让查询优化器

172
00:06:36,870 --> 00:06:39,659
或规划器生成一个 退出计划

173
00:06:39,659 --> 00:06:42,019


174
00:06:42,260 --> 00:06:44,270
，如果不是比人类

175
00:06:44,270 --> 00:06:45,710
实际可以做的更好，或者至少比普通人的

176
00:06:45,710 --> 00:06:49,100
权利更好，那么汤姆不是

177
00:06:49,100 --> 00:06:52,100
关于系统优化器的工作原理，而是

178
00:06:52,100 --> 00:06:53,360
在我们继续讨论

179
00:06:53,360 --> 00:06:55,100
不同的引导时我会说的话 它实际上是

180
00:06:55,100 --> 00:06:57,860
我们如何进行基于成本的搜索，IBM

181
00:06:57,860 --> 00:07:00,020
在 1970 年代发明了

182
00:07:00,020 --> 00:07:02,090
许多

183
00:07:02,090 --> 00:07:04,280
他们

184
00:07:04,280 --> 00:07:05,870
对数据的外观和查询内容做出的设计决策和

185
00:07:05,870 --> 00:07:08,170
假设 看起来像简化问题

186
00:07:08,170 --> 00:07:11,030
以使其易于处理的问题今天仍然

187
00:07:11,030 --> 00:07:13,970
在实践中实际使用，好吧，

188
00:07:13,970 --> 00:07:15,830
我将在我们进行时介绍这些内容

189
00:07:15,830 --> 00:07:16,780
，

190
00:07:16,780 --> 00:07:18,830
因此在查询优化方面，

191
00:07:18,830 --> 00:07:20,270
基本上有两种专业方法可以做到

192
00:07:20,270 --> 00:07:22,610
这一点，这也是 进入

193
00:07:22,610 --> 00:07:26,150
像什么区分我的

194
00:07:26,150 --> 00:07:30,080
坏优化器的好所以第一种方法是

195
00:07:30,080 --> 00:07:33,620
使用静态规则或启发式所以

196
00:07:33,620 --> 00:07:35,900
这里的想法是我们可以查看我们的

197
00:07:35,900 --> 00:07:38,420
查询计划并且匹配某个

198
00:07:38,420 --> 00:07:40,730
模式就像查询时间的一部分

199
00:07:40,730 --> 00:07:42,100
匹配一个模式 我们知道

200
00:07:42,100 --> 00:07:44,930
然后我们触发了一个规则，我

201
00:07:44,930 --> 00:07:46,700
对查询计划进行某种转换或重写，

202
00:07:46,700 --> 00:07:49,190
以使其更

203
00:07:49,190 --> 00:07:52,670
频繁地更正确，也许就像 Eevee，如果

204
00:07:52,670 --> 00:07:55,490
你无视一个等于零的愚蠢事情，

205
00:07:55,490 --> 00:07:58,010
那么你可以有一个 规则可以

206
00:07:58,010 --> 00:08:02,810
很容易地去掉它，所以

207
00:08:02,810 --> 00:08:04,370
我在这些规则上说的重要一点是

208
00:08:04,370 --> 00:08:08,270
，我们可能需要查看

209
00:08:08,270 --> 00:08:09,950
系统 kalam 的目录，它告诉我们

210
00:08:09,950 --> 00:08:11,240
我们的数据库是什么样的 我们的表是什么样的

211
00:08:11,240 --> 00:08:12,830
数据包，目录和

212
00:08:12,830 --> 00:08:14,150
是关于数据的元数据什么

213
00:08:14,150 --> 00:08:15,830
表我有什么列他们

214
00:08:15,830 --> 00:08:17,600
有什么属性他们有什么

215
00:08:17,600 --> 00:08:20,060
等等所以对于这些规则，你可以

216
00:08:20,060 --> 00:08:21,620
查看一个目录，参考足够

217
00:08:21,620 --> 00:08:23,470
了解你知道什么我们的

218
00:08:23,470 --> 00:08:25,420
基础表 看起来应该是这样，

219
00:08:25,420 --> 00:08:28,430
但我们从来没有真正拥有女性

220
00:08:28,430 --> 00:08:31,910
实际数据本身，我们可以启动

221
00:08:31,910 --> 00:08:33,169
这些规则，而无需实际

222
00:08:33,169 --> 00:08:34,789
去谈判桌 说清楚它做了什么，它

223
00:08:34,789 --> 00:08:37,580
做了什么，我是什么实际上被

224
00:08:37,580 --> 00:08:43,220
包含了，因为替代方案是

225
00:08:43,220 --> 00:08:45,980
新的 代价高昂的搜索，而不是

226
00:08:45,980 --> 00:08:48,590
你知道你不

227
00:08:48,590 --> 00:08:49,940
看数据，你必须

228
00:08:49,940 --> 00:08:52,490
以某种方式查看数据，看看

229
00:08:52,490 --> 00:08:54,380
成本基础搜索是

230
00:08:54,380 --> 00:08:57,620
什么，我们将枚举一个

231
00:08:57,620 --> 00:08:58,850
一堆不同的计划和不同的

232
00:08:58,850 --> 00:09:01,640
方式以及理想的智能方式

233
00:09:01,640 --> 00:09:03,530
围绕着查看冗余或愚蠢的

234
00:09:03,530 --> 00:09:06,230
事情或使用分子

235
00:09:06,230 --> 00:09:07,970
她为我们制定的一系列计划，我们可以选择

236
00:09:07,970 --> 00:09:10,160
执行我们的单个查询，然后

237
00:09:10,160 --> 00:09:12,080
我们就去 使用某种成本模型来

238
00:09:12,080 --> 00:09:13,010
估计

239
00:09:13,010 --> 00:09:15,560
哪一个是执行成本所有

240
00:09:15,560 --> 00:09:17,810
这些不同的计划当然我们的想法

241
00:09:17,810 --> 00:09:19,070
是我们希望始终选择

242
00:09:19,070 --> 00:09:22,700
成本最低的一个，因此

243
00:09:22,700 --> 00:09:24,920
如果您有准确的估计，显然会得到成本较小的蝙蝠

244
00:09:24,920 --> 00:09:26,390
非常难，

245
00:09:26,390 --> 00:09:28,640
我们会明白为什么随着我们的进展，

246
00:09:28,640 --> 00:09:30,380
然后在你列举计划的方式上

247
00:09:30,380 --> 00:09:32,840
也很难，因为正如我所说，你

248
00:09:32,840 --> 00:09:35,330
不想看你有

249
00:09:35,330 --> 00:09:36,590
有限的时间来看看

250
00:09:36,590 --> 00:09:37,850
不同的 选项，你不想

251
00:09:37,850 --> 00:09:40,190
花你知道的时间和时间做一个

252
00:09:40,190 --> 00:09:42,410
绑定搜索的分支或一个

253
00:09:42,410 --> 00:09:45,530
可能需要一秒钟才能运行的查询 who 它

254
00:09:45,530 --> 00:09:47,540
实际上非常令人惊讶，

255
00:09:47,540 --> 00:09:49,160
这些东西

256
00:09:49,160 --> 00:09:50,270
每次在这堂课上的实际速度有多快 我们将

257
00:09:50,270 --> 00:09:52,340
在稍后每次

258
00:09:52,340 --> 00:09:53,510
在终端中快速打开时展示一些演示 我从未

259
00:09:53,510 --> 00:09:54,740
写过一个查询 我点击回车

260
00:09:54,740 --> 00:09:56,480
它

261
00:09:56,480 --> 00:09:59,630
现在再次以毫秒为单位为我们的查询做这两件事

262
00:09:59,630 --> 00:10:02,300
我们看它们很漂亮 简单所以它是

263
00:10:02,300 --> 00:10:02,990
n 那个

264
00:10:02,990 --> 00:10:06,500
令人兴奋但即使你知道

265
00:10:06,500 --> 00:10:08,600
你不能永远运行任何东西并找到

266
00:10:08,600 --> 00:10:10,970
它你知道最好的计划是

267
00:10:10,970 --> 00:10:13,820
你尝试近似它所以

268
00:10:13,820 --> 00:10:16,640
我们查询优化路径的管道

269
00:10:16,640 --> 00:10:18,950
它正在查看以下所以

270
00:10:18,950 --> 00:10:20,210
一开始 我们有一个应用程序，

271
00:10:20,210 --> 00:10:21,830
该应用程序连接到

272
00:10:21,830 --> 00:10:23,660
数据库系统，然后它将

273
00:10:23,660 --> 00:10:26,120
向我们发送一个续集查询，因此

274
00:10:26,120 --> 00:10:27,800
将通过我们的优化

275
00:10:27,800 --> 00:10:30,700
管道的第一阶段称为续集重写器，

276
00:10:30,700 --> 00:10:33,500
因此这里的想法是我们可以得到

277
00:10:33,500 --> 00:10:36,170
续集 有一些一些一些

278
00:10:36,170 --> 00:10:38,060
转换规则允许我们

279
00:10:38,060 --> 00:10:40,720
以某些方式重写续集所以

280
00:10:40,720 --> 00:10:42,860
有时这发生在分发

281
00:10:42,860 --> 00:10:45,290
数据库或者如果你有像

282
00:10:45,290 --> 00:10:46,910
霍比特人啤酒这样的视图是表名，这

283
00:10:46,910 --> 00:10:48,320
件事可以说哦，我看到这个团队时

284
00:10:48,320 --> 00:10:49,910
相信你把它写成别的

285
00:10:49,910 --> 00:10:50,180
东西

286
00:10:50,180 --> 00:10:51,710
让我用额外的

287
00:10:51,710 --> 00:10:53,960
信息来注释它说这个特定的表

288
00:10:53,960 --> 00:10:55,820
可以在这里的这个节点或

289
00:10:55,820 --> 00:10:58,580
这里的磁盘上找到所以这是选项

290
00:10:58,580 --> 00:11:01,640
对了，这并不常见，我

291
00:11:01,640 --> 00:11:03,110
认为大多数大卫学生不想

292
00:11:03,110 --> 00:11:05,660
直接对续集进行操作，但你知道

293
00:11:05,660 --> 00:11:07,380
这是你可以做的事情，所以

294
00:11:07,380 --> 00:11:10,560
在这里传统反对，然后我们采取

295
00:11:10,560 --> 00:11:11,730
由此产生的续集问题

296
00:11:11,730 --> 00:11:13,140
如果我们有它，否则你

297
00:11:13,140 --> 00:11:14,580
返回应用程序，他们

298
00:11:14,580 --> 00:11:17,010
通过我们的 Seco 解析器传递它，这

299
00:11:17,010 --> 00:11:18,690
只是获取词法分析器令牌的东西你

300
00:11:18,690 --> 00:11:20,790
可以阅读试点课程没有

301
00:11:20,790 --> 00:11:22,350
什么我们在这里做的没有花哨的东西

302
00:11:22,350 --> 00:11:24,390
我们只是 将

303
00:11:24,390 --> 00:11:28,110
续集字符串转换为活动语法

304
00:11:28,110 --> 00:11:30,690
树，那么现在我们看到语法树

305
00:11:30,690 --> 00:11:33,300
进入我们的活页夹，活页夹

306
00:11:33,300 --> 00:11:36,780
负责将

307
00:11:36,780 --> 00:11:38,970
续集查询中引用的命名对象转换

308
00:11:38,970 --> 00:11:41,700
为某种内部标识符，所以

309
00:11:41,700 --> 00:11:42,930
老兄就像咨询

310
00:11:42,930 --> 00:11:45,210
目录一样 销售 我需要它

311
00:11:45,210 --> 00:11:47,610
从餐桌食物中选择明星 我不想

312
00:11:47,610 --> 00:11:48,960
拥有其余的查询计划并且必须

313
00:11:48,960 --> 00:11:51,840
对字符串 foo 进行操作 我转到

314
00:11:51,840 --> 00:11:53,670
目录并说嘿，你有一张名为 fo 的表吗

315
00:11:53,670 --> 00:11:55,830
o 如果是，请给我一些内部

316
00:11:55,830 --> 00:11:57,990
标识或让我稍后找到它

317
00:11:57,990 --> 00:12:00,720
，或者如果它没有它，就像它说

318
00:12:00,720 --> 00:12:03,390
你认识的人此时不存在，

319
00:12:03,390 --> 00:12:04,610
我们可以撒谎说

320
00:12:04,610 --> 00:12:06,720
你知道你在看 上一张桌子，我们

321
00:12:06,720 --> 00:12:10,110
没有共同点，我们没有，所以

322
00:12:10,110 --> 00:12:12,660
现在买家要承认这是一个合乎逻辑的

323
00:12:12,660 --> 00:12:15,000
计划，很好地解释一下，看看你在哪里

324
00:12:15,000 --> 00:12:16,410
知道这是什么，但舌骨我

325
00:12:16,410 --> 00:12:18,840
认为这是一个合乎逻辑的

326
00:12:18,840 --> 00:12:20,280
物理计划中的计划 逻辑计划

327
00:12:20,280 --> 00:12:22,290
可以在较高级别说明查询

328
00:12:22,290 --> 00:12:24,660
想要做什么 我想扫描这个表

329
00:12:24,660 --> 00:12:26,910
我是这个表的中介 我

330
00:12:26,910 --> 00:12:28,680
要加入这两个表 它没有

331
00:12:28,680 --> 00:12:30,120
说明你如何 '实际上要这样做

332
00:12:30,120 --> 00:12:31,740
，那是

333
00:12:31,740 --> 00:12:33,270
您使用的 Oliver 的物理计划实际规范

334
00:12:33,270 --> 00:12:36,210
稍后出现所以

335
00:12:36,210 --> 00:12:37,920
没有逻辑计划的活页夹它基本上是

336
00:12:37,920 --> 00:12:40,110
转换的

337
00:12:40,110 --> 00:12:42,390
Signet 现在读取内部 ID 的转换形式，

338
00:12:42,390 --> 00:12:44,430
我们有人在 关系代数

339
00:12:44,430 --> 00:12:46,830
近似，然后我们现在可以提供它

340
00:12:46,830 --> 00:12:49,740
再次进入树级项目 这是

341
00:12:49,740 --> 00:12:51,870
可选的 这实际上

342
00:12:51,870 --> 00:12:53,220
比续集提供者更常见 这

343
00:12:53,220 --> 00:12:55,290
实际上是出于某种目的，因为

344
00:12:55,290 --> 00:12:58,080
这些是静态规则，因此要进行

345
00:12:58,080 --> 00:12:59,850
树正确重写，我们必须

346
00:12:59,850 --> 00:13:01,620
专心地去 Cal 并问他们嘿

347
00:13:01,620 --> 00:13:03,300
我们的表是什么样的

348
00:13:03,300 --> 00:13:06,420
我们的属性是什么样的 嗯，但是我们

349
00:13:06,420 --> 00:13:07,950
不必花费 Monica 我们

350
00:13:07,950 --> 00:13:10,050
可以这样做，因为使用

351
00:13:10,050 --> 00:13:12,150
您想要为每个查询执行的静态世界，

352
00:13:12,150 --> 00:13:15,050
无论实际数据看起来如何 像

353
00:13:15,050 --> 00:13:17,700
这样然后树的作者被捡起

354
00:13:17,700 --> 00:13:19,790
仍然是finder吐出的相同逻辑计划

355
00:13:19,790 --> 00:13:22,070
所以现在我们将其

356
00:13:22,070 --> 00:13:25,010
输入到我们的第一个晚上我的意思是这

357
00:13:25,010 --> 00:13:26,360
就像黑魔法部分这是我们

358
00:13:26,360 --> 00:13:27,440
实际上要进行搜索尝试的地方

359
00:13:27,440 --> 00:13:29,680
使用成本模型来找出

360
00:13:29,680 --> 00:13:32,390
最适合我们的计划 所以他们一直在

361
00:13:32,390 --> 00:13:34,040
使用

362
00:13:34,040 --> 00:13:36,020
Cal 提供给我们的模式信息的组合

363
00:13:36,020 --> 00:13:37,850
以及其中一些

364
00:13:37,850 --> 00:13:40,850
我们的成本模型可以为我们提供

365
00:13:40,850 --> 00:13:42,830
的这些估计 询问  计划将花费 X

366
00:13:42,830 --> 00:13:44,270
倍的时间 其他方计划

367
00:13:44,270 --> 00:13:46,520
意味着 Y 的时间量 X 少于 Y 我

368
00:13:46,520 --> 00:13:49,310
想选择另一个

369
00:13:49,310 --> 00:13:51,710
我们会看到这个成本

370
00:13:51,710 --> 00:13:54,950
模型将是一个典型的

371
00:13:54,950 --> 00:13:57,320
数据库

372
00:13:57,320 --> 00:14:00,020
没有在内部计算的合成数 它

373
00:14:00,020 --> 00:14:01,400
不需要外部世界

374
00:14:01,400 --> 00:14:03,560
你不能承担成本 不是专家说

375
00:14:03,560 --> 00:14:06,080
哦 那真的是 27 那就是我 你知道

376
00:14:06,080 --> 00:14:06,800
20 分钟

377
00:14:06,800 --> 00:14:08,810
这只是解决这个问题的内部事情

378
00:14:08,810 --> 00:14:11,030
8 这个查询计划 比

379
00:14:11,030 --> 00:14:13,150
另一个好，所以只是用来比较

380
00:14:13,150 --> 00:14:15,440


381
00:14:15,440 --> 00:14:17,090
不同计划之间相对内部的大数据系统

382
00:14:17,090 --> 00:14:19,010
，与外部世界无关，所以如果你

383
00:14:19,010 --> 00:14:20,630
认为 Postgres 这个成本模型它

384
00:14:20,630 --> 00:14:22,400
吐出一个数字我的续集成本我不会

385
00:14:22,400 --> 00:14:23,380
吐出一个数字

386
00:14:23,380 --> 00:14:26,540
你 不能苹果和橙子你不能

387
00:14:26,540 --> 00:14:29,950
比较它们某些系统会尝试

388
00:14:29,950 --> 00:14:32,000
将估计 B 项的类数量

389
00:14:32,000 --> 00:14:34,280
与实际时间相匹配，但这很

390
00:14:34,280 --> 00:14:36,950
棘手，通常不可靠，因为

391
00:14:36,950 --> 00:14:40,670
硬件变化和环境

392
00:14:40,670 --> 00:14:43,130
变化等等 - 现在

393
00:14:43,130 --> 00:14:44,330
优化器将输出一个

394
00:14:44,330 --> 00:14:46,490
物理计划，而物理计划是

395
00:14:46,490 --> 00:14:47,660
我们的数据系统实际可以

396
00:14:47,660 --> 00:14:49,610
执行的，所以当我们谈论非常

397
00:14:49,610 --> 00:14:51,620
执行时，我将这些计划展示

398
00:14:51,620 --> 00:14:53,420
为你知道的哈希连接，是的，进行

399
00:14:53,420 --> 00:14:55,160
洪流扫描 正确的索引扫描

400
00:14:55,160 --> 00:14:56,780
给哈希绘图他们的斩波器

401
00:14:56,780 --> 00:14:58,880
绘图做我的哈希聚合或

402
00:14:58,880 --> 00:15:00,740
排序聚合，规范

403
00:15:00,740 --> 00:15:03,800
在这里发生，所以一旦我们离开

404
00:15:03,800 --> 00:15:05,270
优化器，那么我们真的

405
00:15:05,270 --> 00:15:06,650
没有任何其他事情要做，直到

406
00:15:06,650 --> 00:15:10,310
它们都没有被执行，再次创造乐趣

407
00:15:10,310 --> 00:15:11,780
，高水平的 这就是

408
00:15:11,780 --> 00:15:12,800
每个数据库管理系统如何

409
00:15:12,800 --> 00:15:14,960
实现它的一些东西，例如

410
00:15:14,960 --> 00:15:17,180
我们编写的每个编写器的超级驱动程序，您

411
00:15:17,180 --> 00:15:18,830
不一定必须拥有，但

412
00:15:18,830 --> 00:15:20,690
绑定器和优化器的部分

413
00:15:20,690 --> 00:15:25,460
是标准包，因此只是

414
00:15:25,460 --> 00:15:26,900
在逻辑与物理之间重申

415
00:15:26,900 --> 00:15:30,440
再次

416
00:15:30,440 --> 00:15:31,680
思考的方式是

417
00:15:31,680 --> 00:15:34,619
我将生成一个逻辑计划，该计划

418
00:15:34,619 --> 00:15:37,470
大致相当于

419
00:15:37,470 --> 00:15:38,850
关系代数 e

420
00:15:38,850 --> 00:15:42,839
在我们的查询中的 xpressions 它并不总是

421
00:15:42,839 --> 00:15:44,339
一对一的映射，但在高层次上

422
00:15:44,339 --> 00:15:45,869
你可以这样想

423
00:15:45,869 --> 00:15:47,369


424
00:15:47,369 --> 00:15:48,720


425
00:15:48,720 --> 00:15:50,910
会做一个连接，这些都

426
00:15:50,910 --> 00:15:52,559
包含在一个逻辑计划和

427
00:15:52,559 --> 00:15:53,699
我之前展示的所有查询计划树中，

428
00:15:53,699 --> 00:15:55,170
我有点只是有

429
00:15:55,170 --> 00:15:57,360
关系代数符号，它没有

430
00:15:57,360 --> 00:15:58,589
注释它并说明我正在使用什么专辑

431
00:15:58,589 --> 00:15:59,819
，那些有 我们考虑了

432
00:15:59,819 --> 00:16:03,480
逻辑计划 物理运算符

433
00:16:03,480 --> 00:16:05,670
物理计划是我们实际

434
00:16:05,670 --> 00:16:08,399
专门定义的执行

435
00:16:08,399 --> 00:16:10,199
策略，我们将

436
00:16:10,199 --> 00:16:11,459
在查询计划中为这些不同的运算符使用

437
00:16:11,459 --> 00:16:14,249
什么执行策略 我将

438
00:16:14,249 --> 00:16:16,860
按此顺序使用此索引进行索引扫描 将我的

439
00:16:16,860 --> 00:16:19,079
输出提供一个索引扫描到一个哈希故事

440
00:16:19,079 --> 00:16:22,230
操作符中，这

441
00:16:22,230 --> 00:16:23,990
是我们实际执行它的所有低级细节

442
00:16:23,990 --> 00:16:26,459
，因此我们关注的一堆不同的

443
00:16:26,459 --> 00:16:27,899
元数据是一个我们不关心的

444
00:16:27,899 --> 00:16:29,189
物理计划

445
00:16:29,189 --> 00:16:31,529
这个  点或这门课，

446
00:16:31,529 --> 00:16:34,679
但如果我知道我有一个 Apple Bob 的订单

447
00:16:34,679 --> 00:16:37,620
，我给你一个

448
00:16:37,620 --> 00:16:40,050
关于同一个连接键的简短版本，同样通过 或

449
00:16:40,050 --> 00:16:42,029
键，那么我可以注释我的物理

450
00:16:42,029 --> 00:16:43,980
操作符和我的查询计划来说明这个

451
00:16:43,980 --> 00:16:46,050
数据 我吐出的是 o 我的方式

452
00:16:46,050 --> 00:16:49,079
是根据这个键排序的，所以你

453
00:16:49,079 --> 00:16:50,879
可以推理，你可以将

454
00:16:50,879 --> 00:16:56,639
顺序降低一个球低 V 它可能是

455
00:16:56,639 --> 00:16:58,670
从关系代数到逻辑的 1:1 映射

456
00:16:58,670 --> 00:17:02,970
计划并不总是

457
00:17:02,970 --> 00:17:06,480
正确的，但标题是，但对于视觉

458
00:17:06,480 --> 00:17:08,099
计划，我们不能假设它是逻辑的 1:1

459
00:17:08,099 --> 00:17:09,859
映射，这又是物理

460
00:17:09,859 --> 00:17:14,010
权利，如果我可以有一个 join 加上

461
00:17:14,010 --> 00:17:15,510
一个 order by 但如果我断言合并

462
00:17:15,510 --> 00:17:17,520
join 在我的物理运算符中，然后我可以

463
00:17:17,520 --> 00:17:19,859
摆脱上面运算符的顺序

464
00:17:19,859 --> 00:17:25,799
，所以思考这个问题的方法

465
00:17:25,799 --> 00:17:27,089
是重写我们将讨论的

466
00:17:27,089 --> 00:17:29,730
内容，然后我们得到基于成本成本

467
00:17:29,730 --> 00:17:32,100
的搜索，这些都是在

468
00:17:32,100 --> 00:17:36,630
逻辑上运行的 计划，但最终总是

469
00:17:36,630 --> 00:17:41,740
需要一个物理计划，所以

470
00:17:41,740 --> 00:17:43,760
在我们进入之前 本质

471
00:17:43,760 --> 00:17:45,590
细节 我的意思是说这

472
00:17:45,590 --> 00:17:47,570
太难了 这是关于数据库系统最难的部分

473
00:17:47,570 --> 00:17:48,770
这实际上

474
00:17:48,770 --> 00:17:51,590
是我知道的最少的部分 这就是为什么

475
00:17:51,590 --> 00:17:52,910
我如此着迷，我总是想

476
00:17:52,910 --> 00:17:55,100
尝试做更多，因为 就像我不

477
00:17:55,100 --> 00:17:58,040
知道我不明白如果你能做到

478
00:17:58,040 --> 00:17:59,720
这一点如果你擅长做

479
00:17:59,720 --> 00:18:01,670
查询优化你可以立即找到工作

480
00:18:01,670 --> 00:18:04,040
让人们付钱给你

481
00:18:04,040 --> 00:18:07,160
做这件事因为就像我说的

482
00:18:07,160 --> 00:18:11,270
IBM 在 1970 年代，有

483
00:18:11,270 --> 00:18:12,470
很多查询优化在

484
00:18:12,470 --> 00:18:15,200
80 年代末 90 年代初工作，但

485
00:18:15,200 --> 00:18:16,610
现在一切都像顽固的老人一样，

486
00:18:16,610 --> 00:18:20,750
我们都喜欢退休或继续前进

487
00:18:20,750 --> 00:18:23,960
，你知道 21 岁 21 岁的

488
00:18:23,960 --> 00:18:26,660
人对每日津贴的了解 除了

489
00:18:26,660 --> 00:18:32,450
我的学生，这就是

490
00:18:32,450 --> 00:18:33,950
我经常收到的一封电子邮件 我应该分享我

491
00:18:33,950 --> 00:18:35,420
应该展示

492
00:18:35,420 --> 00:18:37,010
这封电子邮件的屏幕截图 我总是

493
00:18:37,010 --> 00:18:39,350
从戴维斯公司的朋友那里收到的电子邮件 我没有

494
00:18:39,350 --> 00:18:47,920
戴麦克风 也许我拿起大部分是

495
00:18:47,920 --> 00:18:52,190
对的 是的，如果可以的话，如果可以的话 这样

496
00:18:52,190 --> 00:18:54,050
做你会得到很多钱，

497
00:18:54,050 --> 00:18:56,060
因为这太难了，而且

498
00:18:56,060 --> 00:18:57,230
很难雇人做这种

499
00:18:57,230 --> 00:18:58,040
事情，

500
00:18:58,040 --> 00:18:59,780
有一天公司告诉我，如果

501
00:18:59,780 --> 00:19:01,040
他们能找到有 PL

502
00:19:01,040 --> 00:19:03,340
背景的人，他们就能做到

503
00:19:03,340 --> 00:19:05,270
这家戴维斯公司告诉我，他们

504
00:19:05,270 --> 00:19:06,440
有高能物理学背景的人

505
00:19:06,440 --> 00:19:09,020
可以进行查询

506
00:19:09,020 --> 00:19:10,970
优化，所以这是一个笑话，

507
00:19:10,970 --> 00:19:12,890
数据库说就像人们总是

508
00:19:12,890 --> 00:19:14,900
说哦，查询优化和

509
00:19:14,900 --> 00:19:17,690
火箭科学一样难，笑话是

510
00:19:17,690 --> 00:19:19,580
如果 你在做查询优化方面失败了，

511
00:19:19,580 --> 00:19:21,920
你的备份职业计划可以成为火箭

512
00:19:21,920 --> 00:19:23,120
科学，因为还有比这更难的

513
00:19:23,120 --> 00:19:25,130
事情，这就是

514
00:19:25,130 --> 00:19:27,200
将高端人员

515
00:19:27,200 --> 00:19:28,790
与开源人员或

516
00:19:28,790 --> 00:19:32,390
较小系统 Oracle 续集服务器和

517
00:19:32,390 --> 00:19:35,090
IBM 区分开来的原因 和 teradata 以及所有的

518
00:19:35,090 --> 00:19:36,380
企业系统

519
00:19:36,380 --> 00:19:37,940
，他们已经花费了数

520
00:19:37,940 --> 00:19:39,230
百万美元，雇佣了数百

521
00:19:39,230 --> 00:19:40,850
到数百人来处理这些

522
00:19:40,850 --> 00:19:43,700
事情。 嘿

523
00:19:43,700 --> 00:19:47,510
，你很老练，所以如果你知道你能不能做

524
00:19:47,510 --> 00:19:52,720
这种事情，你就会有需求 所以

525
00:19:52,720 --> 00:19:54,590
另一种你说话的方式我们不会

526
00:19:54,590 --> 00:19:55,100
谈论这

527
00:19:55,100 --> 00:19:57,470
门课是你可能会说好吧，

528
00:19:57,470 --> 00:19:59,090
这就像超级 硬 K 机器

529
00:19:59,090 --> 00:20:01,030
学习解决了这个问题，所以 AI 可以解决这个问题

530
00:20:01,030 --> 00:20:05,030
不，但是是的，所以人们尝试

531
00:20:05,030 --> 00:20:07,940
应用机器学习 PR 最近尝试应用

532
00:20:07,940 --> 00:20:09,740
机器学习并

533
00:20:09,740 --> 00:20:11,720
看到一些有希望的结果，但它

534
00:20:11,720 --> 00:20:14,690
仍然与

535
00:20:14,690 --> 00:20:16,460
您所了解的商业广告相去甚远 系统可以做到

536
00:20:16,460 --> 00:20:18,530
IBM 实际上

537
00:20:18,530 --> 00:20:20,270
在 2000 年代初期尝试过类似的东西 这个

538
00:20:20,270 --> 00:20:23,000
叫做 leo 的东西 学习优化器 事实

539
00:20:23,000 --> 00:20:25,309
证明它很糟糕，你知道的每个人都

540
00:20:25,309 --> 00:20:27,409
在生产中转移，但

541
00:20:27,409 --> 00:20:29,090
我曾经与之交谈过的每个 db2 DBA 都会说

542
00:20:29,090 --> 00:20:30,080
他们做的第一件事 当他们

543
00:20:30,080 --> 00:20:32,030
安装 db2 时，会关闭学习

544
00:20:32,030 --> 00:20:33,320
废话，因为它从来没有奏效过让事情

545
00:20:33,320 --> 00:20:37,700
变得更糟，所以机器学习是一种

546
00:20:37,700 --> 00:20:39,440
改进事情的潜在方法，但它

547
00:20:39,440 --> 00:20:41,270
不会是你知道

548
00:20:41,270 --> 00:20:44,419
解决问题的灵丹妙药 就像我说的，这是

549
00:20:44,419 --> 00:20:45,470
关于数据系统的一

550
00:20:45,470 --> 00:20:47,390
件事，我最兴奋，

551
00:20:47,390 --> 00:20:50,690
对上学期我们在高级课程中介绍的知识最少，

552
00:20:50,690 --> 00:20:52,340
我们为此做了三堂课

553
00:20:52,340 --> 00:20:53,990
，我想我正在扩展它，

554
00:20:53,990 --> 00:20:55,429
使其成为四个或 五脖子学期只是

555
00:20:55,429 --> 00:20:57,230
因为就像我们

556
00:20:57,230 --> 00:20:59,720
在 CMU 构建自己的查询优化器一样，我

557
00:20:59,720 --> 00:21:02,840
很难让学生开始研究它，但他们

558
00:21:02,840 --> 00:21:04,820
都会立即找到工作，

559
00:21:04,820 --> 00:21:06,890
但这就是我们

560
00:21:06,890 --> 00:21:12,049
在高级课程中称之为封面的东西 所以，是的，我

561
00:21:12,049 --> 00:21:13,280
不知道对任何其他系统说坏话，

562
00:21:13,280 --> 00:21:15,530
有些系统会创建

563
00:21:15,530 --> 00:21:19,070
优化区域，完全是废话，你

564
00:21:19,070 --> 00:21:22,520
知道稍后会覆盖，好吧好吧，

565
00:21:22,520 --> 00:21:24,289
所以我们今天有很多事情要讲

566
00:21:24,289 --> 00:21:25,159
，就像我说的那样我不知道“ 我不认为我们

567
00:21:25,159 --> 00:21:26,809
要完成所有这一切，所以这可能会

568
00:21:26,809 --> 00:21:28,490
蔓延到下周我不知道

569
00:21:28,490 --> 00:21:29,990
为什么我没有把它分成两个

570
00:21:29,990 --> 00:21:32,659
学期或在此之前的两个讲座，

571
00:21:32,659 --> 00:21:35,120
但事实就是如此 首先我们将

572
00:21:35,120 --> 00:21:36,380
讨论关系代数等价

573
00:21:36,380 --> 00:21:38,450
的核心基础 这个概念

574
00:21:38,450 --> 00:21:39,770
允许我们对

575
00:21:39,770 --> 00:21:41,900
查询计划进行操作和转换以

576
00:21:41,900 --> 00:21:43,880
找到更好的替代方案然后我们将讨论

577
00:21:43,880 --> 00:21:46,309
我们如何进行成本估算

578
00:21:46,309 --> 00:21:48,200
我们如何采用查询计划以及在我们的

579
00:21:48,200 --> 00:21:50,539
成本模型和估算器中我们必须这样

580
00:21:50,539 --> 00:21:52,280
做 执行它然后不会花更多

581
00:21:52,280 --> 00:21:53,780
时间讨论枚举这

582
00:21:53,780 --> 00:21:55,220
就像搜索策略

583
00:21:55,220 --> 00:21:56,750
为成本基础搜索模型定义不同的选项

584
00:21:56,750 --> 00:21:58,220
然后我们将讨论如何处理

585
00:21:58,220 --> 00:22:00,590
子查询我们哦我们可能

586
00:22:00,590 --> 00:22:03,309
想要通过一半 但这没关系，

587
00:22:03,309 --> 00:22:06,409
所以正如我所说

588
00:22:06,409 --> 00:22:08,000
，我们在进行查询优化时要利用的核心基础概念是这样

589
00:22:08,000 --> 00:22:08,960


590
00:22:08,960 --> 00:22:11,690


591
00:22:11,690 --> 00:22:13,670
一个事实，即我们

592
00:22:13,670 --> 00:22:15,620
了解

593
00:22:15,620 --> 00:22:18,260
关系代数的高级属性，因此可以

594
00:22:18,260 --> 00:22:20,840
置换或变换 关系

595
00:22:20,840 --> 00:22:23,240
代数或等价于

596
00:22:23,240 --> 00:22:24,500
某种关系 Auto 语句的计划以

597
00:22:24,500 --> 00:22:26,900
不同的方式仍然产生

598
00:22:26,900 --> 00:22:30,230
相同的结果所以我们会说我们有

599
00:22:30,230 --> 00:22:33,110
两个关系代数表达式或

600
00:22:33,110 --> 00:22:36,830
两个 que 可以这么说，如果它们

601
00:22:36,830 --> 00:22:39,500
产生相同的一组元组，那么我们

602
00:22:39,500 --> 00:22:40,580
知道它们是等价的，

603
00:22:40,580 --> 00:22:42,470
因此对

604
00:22:42,470 --> 00:22:44,060
我来说，将原始关系

605
00:22:44,060 --> 00:22:46,150
代数表达式转换为新表达式是有效的，

606
00:22:46,150 --> 00:22:48,530
所以请注意我又来了 我说的是一

607
00:22:48,530 --> 00:22:50,410
组元组，因为记住

608
00:22:50,410 --> 00:22:52,220
关系代数或关系

609
00:22:52,220 --> 00:22:55,310
模型是无序的，所以我不在乎，

610
00:22:55,310 --> 00:22:56,960
让我们有一个 order by 语句或

611
00:22:56,960 --> 00:23:00,260
order by 子句我不在乎一个

612
00:23:00,260 --> 00:23:01,880
查询计划产生这样排序的元组

613
00:23:01,880 --> 00:23:03,290
，另一个 查询计划

614
00:23:03,290 --> 00:23:04,310
以这种方式产生 troopas 顺序，

615
00:23:04,310 --> 00:23:07,040
它们仍然是等效的，这意味着

616
00:23:07,040 --> 00:23:08,720
我有更多的选择可供

617
00:23:08,720 --> 00:23:10,430
我们确定什么是您不

618
00:23:10,430 --> 00:23:11,660
知道什么是更好的查询计划供

619
00:23:11,660 --> 00:23:14,870
我们使用，以便我们可以应用这些

620
00:23:14,870 --> 00:23:16,250
敏感性 关系代数的三位一体和承诺的嬉皮士

621
00:23:16,250 --> 00:23:18,410
属性正确的

622
00:23:18,410 --> 00:23:20,560
标准你知道标准逻辑

623
00:23:20,560 --> 00:23:22,940
以不同的方式改变表达式

624
00:23:22,940 --> 00:23:25,640
移动运算符来产生更

625
00:23:25,640 --> 00:23:28,250
有效的计划所以这个高水平

626
00:23:28,250 --> 00:23:30,320
技术称为查询重写，所以

627
00:23:30,320 --> 00:23:31,610
这是我在绑定之前所说的重写步骤，

628
00:23:31,610 --> 00:23:33,290


629
00:23:33,290 --> 00:23:37,070
我们可以做一个树重写器，在那里

630
00:23:37,070 --> 00:23:38,620
我们可以查看逻辑计划的关系代数

631
00:23:38,620 --> 00:23:40,760
表示，

632
00:23:40,760 --> 00:23:42,350
然后移动事物以

633
00:23:42,350 --> 00:23:45,020
产生更多的东西 高效所以让我们

634
00:23:45,020 --> 00:23:47,030
看一个非常简单的例子，

635
00:23:47,030 --> 00:23:48,830
假设我有两个表学生并

636
00:23:48,830 --> 00:23:51,680
注册，我想

637
00:23:51,680 --> 00:23:53,120
在两个表之间进行连接，我

638
00:23:53,120 --> 00:23:54,470
想让所有在课堂上注册的学生

639
00:23:54,470 --> 00:23:57,970
都获得了很好的成绩 鸡蛋

640
00:23:57,970 --> 00:24:00,740
所以如果我几乎

641
00:24:00,740 --> 00:24:03,650
对 seco 语句进行字面翻译，我

642
00:24:03,650 --> 00:24:05,720
会粗略地提出这样的关系

643
00:24:05,720 --> 00:24:07,910
代数语句 对注册的学生进行连接，

644
00:24:07,910 --> 00:24:10,610
然后

645
00:24:10,610 --> 00:24:12,290
在年级上应用过滤器，然后

646
00:24:12,290 --> 00:24:13,550
在我只生成

647
00:24:13,550 --> 00:24:15,580
课程 ID 的地方进行投影 和学生的名字是

648
00:24:15,580 --> 00:24:19,040
对的 所以

649
00:24:19,040 --> 00:24:22,200
我们可以为这个

650
00:24:22,200 --> 00:24:26,650
是的大脑做一个真正稳定的优化 他说将过滤器推到

651
00:24:26,650 --> 00:24:29,200
里面并向右滚动所以他正是

652
00:24:29,200 --> 00:24:30,070
r 所以这个技术被称为

653
00:24:30,070 --> 00:24:32,470
谓词下推所以

654
00:24:32,470 --> 00:24:34,270
它被称为的原因他说推入我会

655
00:24:34,270 --> 00:24:36,550
说典型的术语被下推因为

656
00:24:36,550 --> 00:24:38,770
你把它下推到科里

657
00:24:38,770 --> 00:24:40,900
计划所以我们说这是

658
00:24:40,900 --> 00:24:44,200
查询计划 树，所以当你把

659
00:24:44,200 --> 00:24:47,740
这个过滤器放在

660
00:24:47,740 --> 00:24:51,010
连接之前，因为我们在这里做得

661
00:24:51,010 --> 00:24:54,040
很好，

662
00:24:54,040 --> 00:24:55,900
我们想减少我们在联合联合

663
00:24:55,900 --> 00:24:58,900
操作符中必须做的工作量，而不是让

664
00:24:58,900 --> 00:25:00,490
过滤器在连接之上 运营商，

665
00:25:00,490 --> 00:25:02,410
我只是把所有的学生

666
00:25:02,410 --> 00:25:03,940
和所有注册的记录

667
00:25:03,940 --> 00:25:06,040
结合起来，然后应用过滤器

668
00:25:06,040 --> 00:25:08,140
，对我来说最好早点做过滤器

669
00:25:08,140 --> 00:25:10,810
再想一想总是在

670
00:25:10,810 --> 00:25:13,030
极端情况下说我的注册表有

671
00:25:13,030 --> 00:25:16,120
十亿 元组，但只有一个学生

672
00:25:16,120 --> 00:25:19,420
在任何班级都得了 A，那么我会

673
00:25:19,420 --> 00:25:21,820
在 10 亿个元组上做一个联合，

674
00:25:21,820 --> 00:25:23,980
结果只会产生与我的输出一样多的单一结果，

675
00:25:23,980 --> 00:25:26,620
但是如果我在这里早点做我的过滤器

676
00:25:26,620 --> 00:25:28,630
，现在我正在做 一个元组上的联合，

677
00:25:28,630 --> 00:25:29,950
因为那么 t 他是这比一般情况下更

678
00:25:29,950 --> 00:25:31,540
昂贵

679
00:25:31,540 --> 00:25:34,840
我说这是

680
00:25:34,840 --> 00:25:35,920
我们在查询

681
00:25:35,920 --> 00:25:37,980
优化中尝试做的一般想法 我们试图确定

682
00:25:37,980 --> 00:25:40,540
我们最终可以减少

683
00:25:40,540 --> 00:25:42,280
工作的情况，因为那是一分钟

684
00:25:42,280 --> 00:25:44,020
和 这就是我们想要做的事情，如果你

685
00:25:44,020 --> 00:25:46,420
做的工作更少，那么

686
00:25:46,420 --> 00:25:48,850
更快的运行时间成本更低，并且需要的

687
00:25:48,850 --> 00:25:56,980
硬件可能更少

688
00:25:56,980 --> 00:25:59,470


689
00:25:59,470 --> 00:26:01,600


690
00:26:01,600 --> 00:26:04,030
那里但还没有所以他的

691
00:26:04,030 --> 00:26:06,460
问题是它可能会老鼠这就像一个

692
00:26:06,460 --> 00:26:08,260
超级简单的例子就像我可以做到

693
00:26:08,260 --> 00:26:10,570
这一点启发式我有一个查询计划我

694
00:26:10,570 --> 00:26:12,550
总是想推下谓词我

695
00:26:12,550 --> 00:26:13,690
不需要查看数据

696
00:26:13,690 --> 00:26:15,700
看起来像你问的那样

697
00:26:15,700 --> 00:26:17,020
应该是内部还是

698
00:26:17,020 --> 00:26:19,360
外部我需要知道有多少数据

699
00:26:19,360 --> 00:26:20,740
被输入这个

700
00:26:20,740 --> 00:26:21,970
因为较小的表应该始终

701
00:26:21,970 --> 00:26:24,000
是需要成本模型的外部表

702
00:26:24,000 --> 00:26:26,800
我们可以做到这一点 我们可以做这个下推

703
00:26:26,800 --> 00:26:32,760
没有看过数据是的，

704
00:26:33,730 --> 00:26:36,080
所以问题是什么

705
00:26:36,080 --> 00:26:39,350
是相关的，它只是将

706
00:26:39,350 --> 00:26:51,520
等级 b 移动到这个正确的位置并

707
00:26:59,230 --> 00:27:02,390
加入这个所以我的意思是有一个

708
00:27:02,390 --> 00:27:04,130
括号所以这是说

709
00:27:04,130 --> 00:27:14,150
只做过滤器规则 表背立场

710
00:27:14,150 --> 00:27:24,350
是是是是正确是是他死了

711
00:27:24,350 --> 00:27:32,180
很好是好问题好的第一个

712
00:27:32,180 --> 00:27:34,400
问题是可以谓词下推永远

713
00:27:34,400 --> 00:27:39,890
是坏的是的所以在这个非常简单的

714
00:27:39,890 --> 00:27:42,440
例子中就像做某事

715
00:27:42,440 --> 00:27:43,780
你知道一些很容易做的事情

716
00:27:43,780 --> 00:27:46,550
有一些谓词可以

717
00:27:46,550 --> 00:27:49,040
计算成本很高，所以现在这

718
00:27:49,040 --> 00:27:50,300
是数据系统成本

719
00:27:50,300 --> 00:27:54,410
模型可以尝试说得很好的地方，例如，

720
00:27:54,410 --> 00:27:56,810
有时您可能会

721
00:27:56,810 --> 00:27:59,600
在下周星期一介绍下一

722
00:27:59,600 --> 00:28:00,680
节课，但是有些东西称为

723
00:28:00,680 --> 00:28:02,360
用户定义函数，因此它已经过时了

724
00:28:02,360 --> 00:28:05,240
有一个函数，你知道它是一个

725
00:28:05,240 --> 00:28:07,490
表达式，要么自然地接触一个常数，要么

726
00:28:07,490 --> 00:28:09,860
另一个自然和一个元组，我

727
00:28:09,860 --> 00:28:12,140
可以让它调用一个函数，

728
00:28:12,140 --> 00:28:14,630
然后可以是任何任意代码，比如我 c

729
00:28:14,630 --> 00:28:16,190
有一个用 C 或 Python 编写的用户定义函数，

730
00:28:16,190 --> 00:28:19,190
并且该 Python 代码

731
00:28:19,190 --> 00:28:21,260
调用远程服务器进行

732
00:28:21,260 --> 00:28:23,360
某种计算，可能用

733
00:28:23,360 --> 00:28:24,920
比特币支付微交易，然后它

734
00:28:24,920 --> 00:28:29,810
会回来，所以如果我知道这个

735
00:28:29,810 --> 00:28:32,510
谓词 在这里进行连接，这是

736
00:28:32,510 --> 00:28:33,890
非常有选择性的，这意味着没有

737
00:28:33,890 --> 00:28:36,800
太多的元组从这里出来，我

738
00:28:36,800 --> 00:28:39,020
可能最好在这里应用它，

739
00:28:39,020 --> 00:28:41,570
因为你知道这在

740
00:28:41,570 --> 00:28:43,580
金钱上比这样做更昂贵，

741
00:28:43,580 --> 00:28:45,799
所以你并不总是

742
00:28:45,799 --> 00:28:48,200
想把它推下去，但总的来说，你哦，

743
00:28:48,200 --> 00:28:51,710
是的，你做我的微交易是一个

744
00:28:51,710 --> 00:28:53,239
牵强的例子，你可以这样做，但

745
00:28:53,239 --> 00:28:56,210
就像它很愚蠢，你不想这样做

746
00:28:56,210 --> 00:28:58,549
，但还有其他事情，

747
00:28:58,549 --> 00:29:00,080
如果有计算散列或

748
00:29:00,080 --> 00:29:01,580
类似的东西或某种

749
00:29:01,580 --> 00:29:03,679
加密的东西，你可能想把它

750
00:29:03,679 --> 00:29:06,559
放在这里上面，但数据 ISM

751
00:29:06,559 --> 00:29:15,379
可以再次推理，所以现在让我们

752
00:29:15,379 --> 00:29:16,340
通过一堆这些不同的

753
00:29:16,340 --> 00:29:17,919
操作符来讨论什么样的

754
00:29:17,919 --> 00:29:22,279
优化 我们可以申请其他

755
00:29:22,279 --> 00:29:24,049
关系运算符和我们的查询计划，

756
00:29:24,049 --> 00:29:25,759
所以我们已经涵盖了这一点

757
00:29:25,759 --> 00:29:27,919
谓词下推 正确的想法

758
00:29:27,919 --> 00:29:29,239
是我们希望尽可能早地进行过滤而

759
00:29:29,239 --> 00:29:31,279
忽略应用过滤器的成本，

760
00:29:31,279 --> 00:29:33,559
但这将允许 我们

761
00:29:33,559 --> 00:29:35,869
在基于磁盘的系统中更快地丢弃数据

762
00:29:35,869 --> 00:29:37,279
尽早应用过滤器

763
00:29:37,279 --> 00:29:38,570
通常会

764
00:29:38,570 --> 00:29:41,210
更好，因为那样我不会复制

765
00:29:41,210 --> 00:29:43,009
你上面知道的那么多数据并

766
00:29:43,009 --> 00:29:46,759
污染我的记忆 你也可以重新

767
00:29:46,759 --> 00:29:49,039
排序谓词本身

768
00:29:49,039 --> 00:29:51,679
首先应用更具选择性的那些，所以

769
00:29:51,679 --> 00:29:53,690
让我们说我的最后一个例子，

770
00:29:53,690 --> 00:29:55,489
我知道有人的成绩

771
00:29:55,489 --> 00:29:57,559
等于 a 但假设我有另一个

772
00:29:57,559 --> 00:29:59,690
谓词，其中年龄等于你知道

773
00:29:59,690 --> 00:30:02,330
伟大的年龄大于 99 所以找到我

774
00:30:02,330 --> 00:30:03,950
卡内基的所有学生 梅隆

775
00:30:03,950 --> 00:30:05,210
在班上得了 A 并且

776
00:30:05,210 --> 00:30:07,700
年龄在 99 岁以下 我认为

777
00:30:07,700 --> 00:30:09,649
没有人是对的，所以

778
00:30:09,649 --> 00:30:11,899
我最好先应用年龄谓词，

779
00:30:11,899 --> 00:30:13,609
因为 th  at 会

780
00:30:13,609 --> 00:30:16,970
在查看灰色谓词之前过滤掉更多的东西，

781
00:30:16,970 --> 00:30:19,999
现在你可以说一切都好

782
00:30:19,999 --> 00:30:21,529
，因为你知道一个轻微的

783
00:30:21,529 --> 00:30:23,480
计算开销是的，对于令人沮丧的

784
00:30:23,480 --> 00:30:25,129
系统可能并不那么重要，

785
00:30:25,129 --> 00:30:27,470
但在其他系统中 内存

786
00:30:27,470 --> 00:30:33,609
系统那么这很重要 是的

787
00:30:41,139 --> 00:30:47,480
是的 所以他的陈述就像

788
00:30:47,480 --> 00:30:48,889
这个 我声称我们没有

789
00:30:48,889 --> 00:30:50,179
选择性地查看数据 所以你

790
00:30:50,179 --> 00:30:52,309
实际上不能做这个 是的 这

791
00:30:52,309 --> 00:30:54,109
对这个是真的 是的 你是对的，但

792
00:30:54,109 --> 00:30:55,519
你总是想这样做

793
00:30:55,519 --> 00:30:57,610
是的，

794
00:30:57,610 --> 00:30:58,840
打破一个谓词我们比

795
00:30:58,840 --> 00:31:00,550
提出它更好，女士们喜欢合并电影之

796
00:31:00,550 --> 00:31:10,180
夜人类扫描数据一次，所以

797
00:31:10,180 --> 00:31:12,250
他的问题是为什么打破它

798
00:31:12,250 --> 00:31:16,870
比只需要更好

799
00:31:16,870 --> 00:31:19,450
如果其中一个谓词的计算成本比另一个更昂贵，那么再次考虑一下

800
00:31:19,450 --> 00:31:21,460
，

801
00:31:21,460 --> 00:31:22,410


802
00:31:22,410 --> 00:31:24,790
也许您想中断那个谓词并将

803
00:31:24,790 --> 00:31:28,080
它们放在查询计划的上方

804
00:31:28,590 --> 00:31:40,390
是的，如果它是一个列存储，那么也许我

805
00:31:40,390 --> 00:31:42,370
想做一个 通过 粗略的列

806
00:31:42,370 --> 00:31:44,800
首先烤出所有东西，然后

807
00:31:44,800 --> 00:31:45,790
将它们与下一个匹配的东西

808
00:31:45,790 --> 00:31:49,050
是的，但这是正确的例子

809
00:31:49,050 --> 00:31:51,550
，然后再次在这里你可以

810
00:31:51,550 --> 00:31:53,560
简化复杂这是一个简化

811
00:31:53,560 --> 00:31:55,630
复杂的谓词，更容易

812
00:31:55,630 --> 00:31:58,000
计算这个 是一个简单的例子 X x

813
00:31:58,000 --> 00:32:00,310
等于 y 并且 y 通过传递调用再次等于 3

814
00:32:00,310 --> 00:32:02,050


815
00:32:02,050 --> 00:32:04,540
我们知道 x 就是这只是 x

816
00:32:04,540 --> 00:32:06,870
等于 3 所以我们可以像这样重写它

817
00:32:06,870 --> 00:32:10,210
所以现在发生的事情是当我们

818
00:32:10,210 --> 00:32:12,400
使用遍历 十亿个元组，我们

819
00:32:12,400 --> 00:32:14,290
可以只用 x 和 y 查看每条边，

820
00:32:14,290 --> 00:32:17,230
检查是否等于 a 到

821
00:32:17,230 --> 00:32:19,210
一个常数，这

822
00:32:19,210 --> 00:32:21,880
比必须去获取

823
00:32:21,880 --> 00:32:23,290
元组中 y 属性的引用，然后将它

824
00:32:23,290 --> 00:32:25,210
复制给某些人要便宜得多 注册或一些

825
00:32:25,210 --> 00:32:27,360
变量，然后进行正确的比较，

826
00:32:27,360 --> 00:32:29,590
这就像一个微优化

827
00:32:29,590 --> 00:32:30,940
，主要只

828
00:32:30,940 --> 00:32:34,690
对内存中的人很重要，对于预测

829
00:32:34,690 --> 00:32:36,430
我们也可以尽早将它们推下

830
00:32:36,430 --> 00:32:40,150
，这里的想法是 我们

831
00:32:40,150 --> 00:32:42,130
希望最大限度地减少

832
00:32:42,130 --> 00:32:44,560
我们必须从一个

833
00:32:44,560 --> 00:32:46,540
歌剧复制到下一个歌剧的数据量，这

834
00:32:46,540 --> 00:32:48,040
在行存储系统中最重要，

835
00:32:48,040 --> 00:32:50,260
因为如果行真的很宽并且我

836
00:32:50,260 --> 00:32:51,970
正在将整个元组从一个

837
00:32:51,970 --> 00:32:54,880
操作员向上移动 接下来，如果我

838
00:32:54,880 --> 00:32:57,220
可以尽早删除尽可能多的不需要的数据，那么我

839
00:32:57,220 --> 00:32:59,470


840
00:32:59,470 --> 00:33:02,470
将从一个步骤复制到下一个右侧的数据较少，因此

841
00:33:02,470 --> 00:33:05,080
在此示例中说，

842
00:33:05,080 --> 00:33:08,410
学生表有一千列 但

843
00:33:08,410 --> 00:33:10,750
我的查询只需要它需要的两个属性

844
00:33:10,750 --> 00:33:11,200


845
00:33:11,200 --> 00:33:14,110
，他是学生的名字，所以我

846
00:33:14,110 --> 00:33:17,890
现在可以在这里引入一个投影，然后

847
00:33:17,890 --> 00:33:20,410
再输入我的联合运算符，所以

848
00:33:20,410 --> 00:33:22,810
我去掉了

849
00:33:22,810 --> 00:33:24,580
我不需要的九百九十八列，只

850
00:33:24,580 --> 00:33:27,850
通过 在我确实需要的两个中，

851
00:33:27,850 --> 00:33:29,320
这在分布式数据库中实际上非常普遍，

852
00:33:29,320 --> 00:33:31,300
因为

853
00:33:31,300 --> 00:33:32,710
通过网络移动数据既昂贵又

854
00:33:32,710 --> 00:33:35,200
缓慢，所以如果我在一个节点上得到它，

855
00:33:35,200 --> 00:33:37,120
这在另一个节点上，我正在

856
00:33:37,120 --> 00:33:38,890
做连接 在我滚动的同一个节点上

857
00:33:38,890 --> 00:33:40,930
然后

858
00:33:40,930 --> 00:33:43,030
我想在我通过网络发送之前尽可能多地剥离

859
00:33:43,030 --> 00:33:47,980
出来所以到目前为止我在

860
00:33:47,980 --> 00:33:50,010
这里向您展示的所有内容都

861
00:33:50,010 --> 00:33:53,440
在对关系代数运算符中的一个应用优化

862
00:33:53,440 --> 00:33:55,000
关系

863
00:33:55,000 --> 00:33:57,100
代数表达式我们可以应用这些

864
00:33:57,100 --> 00:34:00,190


865
00:34:00,190 --> 00:34:02,860
在我们的查询中对底层谓词表达式本身进行了相同的优化，

866
00:34:02,860 --> 00:34:05,530
因此我将向您展示

867
00:34:05,530 --> 00:34:07,810
一系列示例，说明不同的数据

868
00:34:07,810 --> 00:34:11,260
系统如何重写查询计划以

869
00:34:11,260 --> 00:34:14,520
简化它们或避免做愚蠢的工作

870
00:34:14,520 --> 00:34:16,840
，这来自这篇很棒的博客

871
00:34:16,840 --> 00:34:19,150
文章 几年前，

872
00:34:19,150 --> 00:34:21,460
有人提出了所有这里的

873
00:34:21,460 --> 00:34:23,199
不同操作之一，您可以执行

874
00:34:23,199 --> 00:34:26,290
不需要成本模型的操作，

875
00:34:26,290 --> 00:34:28,659
我们将演示他的一些

876
00:34:28,659 --> 00:34:30,820
比较，但这真的很好，因为

877
00:34:30,820 --> 00:34:32,860
他提供了 一个 github

878
00:34:32,860 --> 00:34:35,168
存储库，其中包含

879
00:34:35,168 --> 00:34:37,960
他用于分析的示例数据库，它在

880
00:34:37,960 --> 00:34:40,120
sequel Server db2 Oracle 上工作就像在

881
00:34:40,120 --> 00:34:41,168
一堆不同的数据系统上工作一样，您

882
00:34:41,168 --> 00:34:43,300
可以使用相同的数据库 同样的查询

883
00:34:43,300 --> 00:34:45,610
，看看不同的优化器

884
00:34:45,610 --> 00:34:48,449
如何可以重写和修复问题，

885
00:34:48,449 --> 00:34:52,030
所以我们可以重写的第一件事

886
00:34:52,030 --> 00:34:55,600
是删除愚蠢的谓词

887
00:34:55,600 --> 00:34:57,850
或不必要的谓词，所以在这种

888
00:34:57,850 --> 00:35:00,130
情况下，这里从表 a 中选择星，其中

889
00:35:00,130 --> 00:35:02,920
一个等于零什么 这个值是

890
00:35:02,920 --> 00:35:06,130
真假是什么意思，这

891
00:35:06,130 --> 00:35:07,360
意味着对于我要

892
00:35:07,360 --> 00:35:10,180
在表上扫描的每个元组，我要检查

893
00:35:10,180 --> 00:35:12,070
哦，谓词假是否等于真，它

894
00:35:12,070 --> 00:35:14,470
永远不会等于真，因此

895
00:35:14,470 --> 00:35:18,490
没有元组 将匹配正确，因此数据

896
00:35:18,490 --> 00:35:19,780
很容易识别出我有一个

897
00:35:19,780 --> 00:35:21,220
不可能的谓词，其中没有元组

898
00:35:21,220 --> 00:35:22,930
可能与此匹配，它

899
00:35:22,930 --> 00:35:24,770
实际上可以完全跳过扫描

900
00:35:24,770 --> 00:35:27,260
并立即为您返回一个空

901
00:35:27,260 --> 00:35:30,350
结果，因此您可以说

902
00:35:30,350 --> 00:35:31,340
好吧，这是 愚蠢的安妮

903
00:35:31,340 --> 00:35:32,720
为什么有人会写一个等于 0

904
00:35:32,720 --> 00:35:33,740
没有人会真正做这个数字 一个

905
00:35:33,740 --> 00:35:36,290
不会正确的理论 人们你知道

906
00:35:36,290 --> 00:35:37,610
人们不应该那么愚蠢但

907
00:35:37,610 --> 00:35:41,060
很多时候在应用程序中

908
00:35:41,060 --> 00:35:42,680
查询不是 将由

909
00:35:42,680 --> 00:35:44,119
一行代码构建

910
00:35:44,119 --> 00:35:46,640
，您的应用程序代码中不会有字符串变量，

911
00:35:46,640 --> 00:35:48,800
然后您就

912
00:35:48,800 --> 00:35:50,480
知道立即发送到

913
00:35:50,480 --> 00:35:52,760
数据库服务器很多次，这些

914
00:35:52,760 --> 00:35:54,980
后续查询是从类似

915
00:35:54,980 --> 00:35:57,350
仪表板构建的 和工具，人们

916
00:35:57,350 --> 00:35:58,640
从不同的东西点击添加不同的

917
00:35:58,640 --> 00:36:00,980
选项或组合查询，所以现在有

918
00:36:00,980 --> 00:36:02,300
一堆不同的库，这样

919
00:36:02,300 --> 00:36:03,800
一堆不同的函数都

920
00:36:03,800 --> 00:36:05,660
将构建一个续集查询，所以

921
00:36:05,660 --> 00:36:07,070
没有一个地方你

922
00:36:07,070 --> 00:36:09,320
可以在代码中查看 你知道

923
00:36:09,320 --> 00:36:11,900
一个等于零的地方它可能来自你组织

924
00:36:11,900 --> 00:36:13,160
其他部分的一些其他功能

925
00:36:13,160 --> 00:36:15,560
来自你

926
00:36:15,560 --> 00:36:18,080
没有编写的代码所以如果数据可以

927
00:36:18,080 --> 00:36:19,550
识别这是愚蠢的而

928
00:36:19,550 --> 00:36:21,410
不是这样做这对我们来说是一个巨大的胜利

929
00:36:21,410 --> 00:36:22,730
因为现在我们甚至不必

930
00:36:22,730 --> 00:36:26,660
查看数据同样你可以做

931
00:36:26,660 --> 00:36:27,680
相反的事情你可以拥有一个

932
00:36:27,680 --> 00:36:30,160
一切都会匹配一个等于一的数据

933
00:36:30,160 --> 00:36:33,650
所以在这种情况下这里每个tupl  e

934
00:36:33,650 --> 00:36:35,810
将匹配，但

935
00:36:35,810 --> 00:36:37,220
实际上我不想实际应用

936
00:36:37,220 --> 00:36:38,570
此谓词，看看

937
00:36:38,570 --> 00:36:41,090
如果我有 10 亿个

938
00:36:41,090 --> 00:36:43,160
元组，它们是否

939
00:36:43,160 --> 00:36:44,720
会再次匹配 并说

940
00:36:44,720 --> 00:36:46,310
嘿这个元组确实一等于一真的

941
00:36:46,310 --> 00:36:47,810
是的我会把它放在旁边但是1

942
00:36:47,810 --> 00:36:49,150
等于1是真的我会说正确

943
00:36:49,150 --> 00:36:51,500
而不是我可以说我不需

944
00:36:51,500 --> 00:36:53,900
要这样做1等于1 现在我只是

945
00:36:53,900 --> 00:36:55,940
做一个 scruncho scan 直接转储

946
00:36:55,940 --> 00:36:58,640
表作为输出而不用担心

947
00:36:58,640 --> 00:37:00,490
应用任何谓词

948
00:37:00,490 --> 00:37:02,600
然后减少

949
00:37:02,600 --> 00:37:05,660
计算调用我想我说你

950
00:37:05,660 --> 00:37:06,830
只是重写它就像 select star from

951
00:37:06,830 --> 00:37:10,369
egg 好吧，所以这些 非常简单，

952
00:37:10,369 --> 00:37:11,780
但我们可以对其他更复杂的查询执行此操作，

953
00:37:11,780 --> 00:37:14,420
我们对连接执行相同类型的操作

954
00:37:14,420 --> 00:37:17,510
，因此现在在我的表上

955
00:37:17,510 --> 00:37:20,119
，此方案在那里，主

956
00:37:20,119 --> 00:37:22,730
键是 ID 列，所以在这里我在做一个

957
00:37:22,730 --> 00:37:25,609
自我 join where a as a 1 join on a as

958
00:37:25,609 --> 00:37:30,410
a 2 on a 1 to ID 等于a to die ID

959
00:37:30,410 --> 00:37:32,330
那么th是什么 查询实际上是在

960
00:37:32,330 --> 00:37:35,840
说它是针对支票上的每个提示说的，

961
00:37:35,840 --> 00:37:37,640
以查看它是否存在于 a

962
00:37:37,640 --> 00:37:39,470
中，当然它总是正确的，

963
00:37:39,470 --> 00:37:41,119
因为我们知道 ID 是主键，所以

964
00:37:41,119 --> 00:37:43,130
我是否存在于另一个表中，

965
00:37:43,130 --> 00:37:46,190
答案总是会是 是的，所以它可以

966
00:37:46,190 --> 00:37:48,470
识别这个谓词完全是

967
00:37:48,470 --> 00:37:49,819
浪费，这个连接完全是

968
00:37:49,819 --> 00:37:51,980
浪费，并将其重写为

969
00:37:51,980 --> 00:37:54,920
从鸡蛋中选择星，再次依赖

970
00:37:54,920 --> 00:37:56,569
关系代数等价，我们

971
00:37:56,569 --> 00:37:58,400
会知道这等价于

972
00:37:58,400 --> 00:38:05,509
这个是，因为他的问题是

973
00:38:05,509 --> 00:38:06,950
妻子条件 ID 是

974
00:38:06,950 --> 00:38:09,289
主键，因为您知道它是唯一的，

975
00:38:09,289 --> 00:38:11,329
并且您知道它不为空，因此

976
00:38:11,329 --> 00:38:16,249
您可以重写它，如果它可以

977
00:38:16,249 --> 00:38:19,519
为空，则空不等于空，

978
00:38:19,519 --> 00:38:21,400
因此您不会有匹配项，

979
00:38:21,400 --> 00:38:24,859
不，它是 总是不喜欢不我们可以

980
00:38:24,859 --> 00:38:27,829
越过头巾我会尝试这个

981
00:38:27,829 --> 00:38:30,619
不等于 null 实际上这个等于 null 的

982
00:38:30,619 --> 00:38:33,190
结果是 null

983
00:38:33,190 --> 00:38:34,369
对

984
00:38:34,369 --> 00:38:37,549
你不知道所以你的问题是不

985
00:38:37,549 --> 00:38:42,440
等于 null 未知是不不我这个

986
00:38:42,440 --> 00:38:45,920
nk 实际上评估为真，但

987
00:38:45,920 --> 00:38:47,480
在这种情况下，如果不是，那么

988
00:38:47,480 --> 00:38:52,039
它将无法正常工作，所以我们做了哪些更

989
00:38:52,039 --> 00:38:54,739
复杂的事情，所以我们

990
00:38:54,739 --> 00:38:56,599
现在也可以忽略

991
00:38:56,599 --> 00:38:59,599
不必要的预测，所以在这里的这个

992
00:38:59,599 --> 00:39:01,279
有点像 重写最后一个

993
00:39:01,279 --> 00:39:03,259
查询 self join 所以这是一个 select

994
00:39:03,259 --> 00:39:05,900
star from a 然后在我的 where 子句中

995
00:39:05,900 --> 00:39:09,950
我不存在我只是说这

996
00:39:09,950 --> 00:39:12,440
基本上是说如果有

997
00:39:12,440 --> 00:39:14,900
任何内容与任何结果匹配，则返回 true

998
00:39:14,900 --> 00:39:17,749
这里是内部查询，所以这

999
00:39:17,749 --> 00:39:21,190
是说如果对于 a 中的每个元组

1000
00:39:21,190 --> 00:39:24,019
产生输出，如果存在一个

1001
00:39:24,019 --> 00:39:26,539
元组，其中点 ID 等于 a2

1002
00:39:26,539 --> 00:39:28,609
到 ID 和主键，所以

1003
00:39:28,609 --> 00:39:30,859
它总是会匹配，所以在

1004
00:39:30,859 --> 00:39:32,599
这里面我们正在实现或

1005
00:39:32,599 --> 00:39:36,200
在元音列上有一个投影，

1006
00:39:36,200 --> 00:39:37,579
但这完全没有必要，这是

1007
00:39:37,579 --> 00:39:39,140
我们不仅要

1008
00:39:39,140 --> 00:39:41,749
连接腰部还要复制这个投影，也

1009
00:39:41,749 --> 00:39:44,569
就是复制这个属性，它是投影的一部分

1010
00:39:44,569 --> 00:39:46,609
，这也是不必要的，

1011
00:39:46,609 --> 00:39:49,940
所以在 在这种情况下，我们

1012
00:39:49,940 --> 00:39:51,470
可以完全重写

1013
00:39:51,470 --> 00:39:54,530
这一部分，这完全

1014
00:39:54,530 --> 00:39:59,089
就像从最后一个选择

1015
00:39:59,089 --> 00:40:01,790
到新兴谓词一样，所以这里

1016
00:40:01,790 --> 00:40:03,890
我们从一到一百之间的 where val 中选择 star

1017
00:40:03,890 --> 00:40:06,560
并

1018
00:40:06,560 --> 00:40:11,300
在 or val 之间鞠躬 是在 50 到 150 之间，所以

1019
00:40:11,300 --> 00:40:12,470
在这种情况下，如果你只

1020
00:40:12,470 --> 00:40:14,480
考虑数字线，这是

1021
00:40:14,480 --> 00:40:16,190
完全多余的，因为如果它

1022
00:40:16,190 --> 00:40:19,460
在 1 到 100 之间，那么它也

1023
00:40:19,460 --> 00:40:21,349
可以在 50 到 150 之间，如果它在 50-100 之间，

1024
00:40:21,349 --> 00:40:24,410
那么对于这个 在这里，我可以

1025
00:40:24,410 --> 00:40:26,660
将其重写为一个

1026
00:40:26,660 --> 00:40:35,980
介于 1 和 150 之间的单曲，因为我们是 1 介于 1 和 150 之间 可以

1027
00:40:35,980 --> 00:40:38,510
选择 所以这就是您知道的方式 这很

1028
00:40:38,510 --> 00:40:40,369
明显 看看您想

1029
00:40:40,369 --> 00:40:42,380
如何做到这一点 让我们看看是否

1030
00:40:42,380 --> 00:40:45,890
真的每个人都喜欢 演示是

1031
00:40:45,890 --> 00:40:50,660
正确的，正如我所说的，

1032
00:40:50,660 --> 00:40:54,650
我提到的那篇博客文章有源代码，您

1033
00:40:54,650 --> 00:40:57,890
可以下载并包含架构

1034
00:40:57,890 --> 00:41:00,050
和插入语句，用于一堆

1035
00:41:00,050 --> 00:41:02,240
不同的 8 个帮助，所以不幸的是

1036
00:41:02,240 --> 00:41:03,500
我昨天破坏了我的续集服务器安装，

1037
00:41:03,500 --> 00:41:04,880
所以我不能 等工作，但

1038
00:41:04,880 --> 00:41:08,050
我会在 Postgres 上做一个演示，我的续集

1039
00:41:08,050 --> 00:41:13,280
oracle maria DB 和续集，

1040
00:41:13,280 --> 00:41:15,560
所以架构看起来像这样，我

1041
00:41:15,560 --> 00:41:18,609
很抱歉，

1042
00:41:24,430 --> 00:41:27,410
所以示例数据是我们

1043
00:41:27,410 --> 00:41:29,510
要使用它就像一个 它就像一个

1044
00:41:29,510 --> 00:41:32,030
在线视频商店，但它有点像

1045
00:41:32,030 --> 00:41:33,319
你看到的 IMDB 的东西，那里有

1046
00:41:33,319 --> 00:41:35,119
演员，然后人们正在租

1047
00:41:35,119 --> 00:41:37,490
电影，但我们将专注

1048
00:41:37,490 --> 00:41:39,589
于演员表，所以再一次，

1049
00:41:39,589 --> 00:41:43,400
关于这个的好处是他们

1050
00:41:43,400 --> 00:41:45,380
提供 同样，你知道

1051
00:41:45,380 --> 00:41:48,319
所有这些

1052
00:41:48,319 --> 00:41:50,420
不同的数据库服务器的所有这些不同的相同的数据库，

1053
00:41:50,420 --> 00:41:51,770
所以这里有 200 个元组

1054
00:41:51,770 --> 00:41:54,140
，然后我们将进入我的续集，

1055
00:41:54,140 --> 00:41:55,609
真正快速地从演员那里选择明星或子计数

1056
00:41:55,609 --> 00:42:00,440
明星，好吧，有 200 个 在

1057
00:42:00,440 --> 00:42:02,750
每一个都可以，

1058
00:42:02,750 --> 00:42:04,400
所以我们要尝试的第一件事

1059
00:42:04,400 --> 00:42:06,349
是不可能的查询，其中一个

1060
00:42:06,349 --> 00:42:11,090
等于零，所以我在这里所做的再次是针对

1061
00:42:11,090 --> 00:42:13,250
Postgres，这是您

1062
00:42:13,250 --> 00:42:15,230
解释的 Postgres 关键字将吐出查询

1063
00:42:15,230 --> 00:42:17,000
计划，然后 阻抗 您

1064
00:42:17,000 --> 00:42:19,250
在解释后放置了苯胺分析修饰符，

1065
00:42:19,250 --> 00:42:21,530
该修饰符将实际运行查询，

1066
00:42:21,530 --> 00:42:23,180
但仍会向您显示查询

1067
00:42:23,180 --> 00:42:26,450
计划及其实际执行的正确操作，因此

1068
00:42:26,450 --> 00:42:29,119
在此此处它表示高于

1069
00:42:29,119 --> 00:42:31,700
一次过滤器为假，因此它识别

1070
00:42:31,700 --> 00:42:35,030
出一等于零 总是会

1071
00:42:35,030 --> 00:42:37,040
评估为假所以它

1072
00:42:37,040 --> 00:42:38,300
一旦安装就应用过滤器，对于

1073
00:42:38,300 --> 00:42:40,280
整个表没有元组会

1074
00:42:40,280 --> 00:42:43,220
匹配所以它实际上并没有

1075
00:42:43,220 --> 00:42:45,800
实际运行并运行读取它说的数据

1076
00:42:45,800 --> 00:42:49,220
哦，它是假的，它什么也没有给

1077
00:42:49,220 --> 00:42:52,790
你 什么都不支持，所以我们可以

1078
00:42:52,790 --> 00:42:55,730
在我的续集中做这件事，所以我的续集

1079
00:42:55,730 --> 00:42:57,470
解释得不像如果

1080
00:42:57,470 --> 00:43:00,170
你这样做那么你会得到类似的东西

1081
00:43:00,170 --> 00:43:02,480
但是如果你出于任何原因这样做

1082
00:43:02,480 --> 00:43:06,020
- 或者那个 /g 那么你

1083
00:43:06,020 --> 00:43:08,570
实际上可以得到一棵树，它是其中之一，

1084
00:43:08,570 --> 00:43:11,030
但在这里你看到了

1085
00:43:11,030 --> 00:43:12,530
他们说的额外参数中的可能

1086
00:43:12,530 --> 00:43:14,180
，所以我认识到没有任何东西

1087
00:43:14,180 --> 00:43:16,160
会匹配甚至不用费心

1088
00:43:16,160 --> 00:43:19,160
应用 where 子句它也有这个

1089
00:43:19,160 --> 00:43:20,630
小警告 这里很

1090
00:43:20,630 --> 00:43:23,599
烦人，这是我的续集 5.7 II 不

1091
00:43:23,599 --> 00:43:27,800
知道它在我的续集 8 中修复了什么

1092
00:43:27,800 --> 00:43:32,359
但是你必须运行显示

1093
00:43:32,359 --> 00:43:34,490
警告然后它会像

1094
00:43:34,490 --> 00:43:36,830
实际发生的那样吐出来所以你在这里看到

1095
00:43:36,830 --> 00:43:39,020
他们重写的条款 我的 1 等于

1096
00:43:39,020 --> 00:43:40,849
0 写为 0 所以一切都

1097
00:43:40,849 --> 00:43:45,320
评估为假所以现在我们将

1098
00:43:45,320 --> 00:43:50,680
尝试并让我们

1099
00:43:59,130 --> 00:44:02,710
使用 Oracle 所以它的工作方式是我说

1100
00:44:02,710 --> 00:44:04,750
解释计划和语法

1101
00:44:04,750 --> 00:44:06,310
总是略有不同它说

1102
00:44:06,310 --> 00:44:11,590
解释现在我必须去

1103
00:44:11,590 --> 00:44:14,950
另一张桌子

1104
00:44:14,950 --> 00:44:18,640
它有它解释的计划 所以解释的油

1105
00:44:18,640 --> 00:44:22,990
实际上是

1106
00:44:22,990 --> 00:44:24,340
更好的然后性感比 post quest post 最好的

1107
00:44:24,340 --> 00:44:25,270
一个非常好 这个实际上也很

1108
00:44:25,270 --> 00:44:27,100
不错 因为它 向你展示你

1109
00:44:27,100 --> 00:44:29,230
知道计算时间然后我在 Rose

1110
00:44:29,230 --> 00:44:30,850
那里访问的数据实际上

1111
00:44:30,850 --> 00:44:33,400
非常好所以他们在这里说什么

1112
00:44:33,400 --> 00:44:35,080
所以这说明它知道我在

1113
00:44:35,080 --> 00:44:36,070
做选择语句并且它有一个

1114
00:44:36,070 --> 00:44:38,170
过滤器并且它说明如何 我要交流

1115
00:44:38,170 --> 00:44:41,500
对表进行处理，所以要指出的是

1116
00:44:41,500 --> 00:44:43,330
，尽管在这里他们有

1117
00:44:43,330 --> 00:44:45,610
关于谓词的信息，所以他们

1118
00:44:45,610 --> 00:44:50,310
说我们过滤空值不为空，所以

1119
00:44:50,310 --> 00:44:52,810
Oracle 不支持布尔

1120
00:44:52,810 --> 00:44:55,000
z' 对，所以它没有办法说 true 或

1121
00:44:55,000 --> 00:44:58,720
false 所以它重写了我的 do 1 equals 0

1122
00:44:58,720 --> 00:45:01,720
to be null is not null 这总是

1123
00:45:01,720 --> 00:45:06,340
false 因为 null 是 null 所以这是他们的

1124
00:45:06,340 --> 00:45:07,720
这是他们表示假的方式

1125
00:45:07,720 --> 00:45:09,610
所以他们现在重写了查询计划

1126
00:45:09,610 --> 00:45:10,870
认识到这件事是 错误

1127
00:45:10,870 --> 00:45:12,460
，因此您实际上不必

1128
00:45:12,460 --> 00:45:13,960
运行它，

1129
00:45:13,960 --> 00:45:15,310
让我们快速返回并真实地发布我们

1130
00:45:15,310 --> 00:45:17,830
- 好吧，他之前问

1131
00:45:17,830 --> 00:45:20,200
对了，所以我可以说正确选择我可以

1132
00:45:20,200 --> 00:45:21,160
像计算器一样对待数据，

1133
00:45:21,160 --> 00:45:24,070
但我可以说选择规范 是的，

1134
00:45:24,070 --> 00:45:27,000
什么都没有，但不等于 null

1135
00:45:27,000 --> 00:45:31,570
什么都不是，它不等于 false 没有

1136
00:45:31,570 --> 00:45:34,060
什么对，这错误地等于

1137
00:45:34,060 --> 00:45:38,380
false true 是真的你知道，

1138
00:45:38,380 --> 00:45:40,000
所以任何时候你说

1139
00:45:40,000 --> 00:45:41,050
没有等于的

1140
00:45:41,050 --> 00:45:43,300
东西答案是 null 空的空间是

1141
00:45:43,300 --> 00:45:45,520
null 获取 ar 的方法 为 null 的 ound

1142
00:45:45,520 --> 00:45:50,080
为 null 那么它是真的，所以 Oracle 正在

1143
00:45:50,080 --> 00:45:56,880
做的不是不是没有错误，

1144
00:45:57,550 --> 00:45:59,770
好吧，那么最后一个你

1145
00:45:59,770 --> 00:46:08,360
会再次寻求光线语法总是

1146
00:46:08,360 --> 00:46:10,610
不同的，他们之前没有解释过查询计划

1147
00:46:10,610 --> 00:46:13,730
，然后它产生了

1148
00:46:13,730 --> 00:46:15,020
这个 这实际上并没有那么有用，

1149
00:46:15,020 --> 00:46:17,060
这只是告诉我们我们正在

1150
00:46:17,060 --> 00:46:19,130
对演员表进行某种扫描，

1151
00:46:19,130 --> 00:46:22,130
所以如果我们删除了查询计划

1152
00:46:22,130 --> 00:46:24,440
部分，那么您会得到一些看起来与

1153
00:46:24,440 --> 00:46:25,520
其他人现在应该得到的东西大不相同的东西

1154
00:46:25,520 --> 00:46:27,830
一些看起来

1155
00:46:27,830 --> 00:46:28,940
像汇编或某种机器

1156
00:46:28,940 --> 00:46:32,510
代码的东西，所以没有去

1157
00:46:32,510 --> 00:46:35,120
浪费代码轻工作的细节是他们

1158
00:46:35,120 --> 00:46:38,150
实际上将优化器吐出的逻辑计划或

1159
00:46:38,150 --> 00:46:39,470
物理计划

1160
00:46:39,470 --> 00:46:43,190
转换成一堆这些操作码

1161
00:46:43,190 --> 00:46:44,840
认为这是 就像 JVM 字节码，

1162
00:46:44,840 --> 00:46:47,420
然后他们有一个解释器，

1163
00:46:47,420 --> 00:46:48,740
他们可以得到并现在执行这些

1164
00:46:48,740 --> 00:46:50,030
字节码，所以这就像这

1165
00:46:50,030 --> 00:46:52,460
实际上是执行这个

1166
00:46:52,460 --> 00:46:54,500
特定查询的程序，所以我可以

1167
00:46:54,500 --> 00:46:57,800
告诉正确，他们说 r1 不是你在

1168
00:46:57,800 --> 00:46:59,330
哪里 - 我不完全是那个意思

1169
00:46:59,330 --> 00:47:03,830
然后你去十但在这种情况下

1170
00:47:03,830 --> 00:47:05,030
，看起来他们实际上在

1171
00:47:05,030 --> 00:47:07,250
这里进行扫描所以我可以

1172
00:47:07,250 --> 00:47:08,780
告诉我最好的 我不确定他们是否

1173
00:47:08,780 --> 00:47:11,510
真的把它去掉了实际上

1174
00:47:11,510 --> 00:47:14,090
不等于这个是的

1175
00:47:14,090 --> 00:47:15,500
它可能会截断它他们

1176
00:47:15,500 --> 00:47:16,790
认识到我不必做

1177
00:47:16,790 --> 00:47:20,030
扫描就可以这样每个人都可以处理

1178
00:47:20,030 --> 00:47:24,170
这个很好所以让我们现在试试

1179
00:47:24,170 --> 00:47:25,550
无用的谓词让我们尝试一个

1180
00:47:25,550 --> 00:47:29,830
等于一 让我们回到

1181
00:47:29,860 --> 00:47:32,840
Postgres 现在看起来它告诉我们

1182
00:47:32,840 --> 00:47:35,720
它实际上做得很好

1183
00:47:35,720 --> 00:47:36,770


1184
00:47:36,770 --> 00:47:38,500


1185
00:47:38,500 --> 00:47:40,490
删除过滤器

1186
00:47:40,490 --> 00:47:43,810
，我立即执行查询

1187
00:47:43,810 --> 00:47:50,560
在我的续集中尝试同样的事情

1188
00:47:52,550 --> 00:48:03,060
没有 Annalize 对不起，这个它

1189
00:48:03,060 --> 00:48:04,920
发现它可以

1190
00:48:04,920 --> 00:48:06,390
完全扔掉过滤器并扫描

1191
00:48:06,390 --> 00:48:08,190
所有东西，这样很好

1192
00:48:08,190 --> 00:48:19,680
让我们尝试 Oracle 解释和 然后

1193
00:48:19,680 --> 00:48:22,830
回到这个右边 过滤器

1194
00:48:22,830 --> 00:48:24,420
完全消失了它现在只是

1195
00:48:24,420 --> 00:48:27,840
瑞士直道心理扫描然后对于

1196
00:48:27,840 --> 00:48:34,740
续集精简版这没有帮助所以我们将

1197
00:48:34,740 --> 00:48:38,250
删除该查询计划部分然后现在

1198
00:48:38,250 --> 00:48:40,710
你看到它在这个for

1199
00:48:40,710 --> 00:48:43,050
循环中它们所在的位置

1200
00:48:43,050 --> 00:48:45,740
扫描表格他们已经删除了谓词，

1201
00:48:45,740 --> 00:48:47,600


1202
00:48:47,600 --> 00:48:49,530
所以让我们看一个例子，在那里你

1203
00:48:49,530 --> 00:48:52,280
有更多的赞美

1204
00:48:52,980 --> 00:48:54,540
可以查看目录并尝试

1205
00:48:54,540 --> 00:48:56,300
找出正确的事情是什么，

1206
00:48:56,300 --> 00:49:01,380
所以演员表的模式

1207
00:49:01,380 --> 00:49:03,990
很漂亮 直截了当，我们

1208
00:49:03,990 --> 00:49:06,030
只有一个演员的名字姓氏和

1209
00:49:06,030 --> 00:49:10,950
最后一次更新，所以我们要

1210
00:49:10,950 --> 00:49:12,030
在这里尝试做的是我们将尝试

1211
00:49:12,030 --> 00:49:16,200
进行查询，我们说演员

1212
00:49:16,200 --> 00:49:21,090
ID 为空的位置，所以我们想要 运行这个查询

1213
00:49:21,090 --> 00:49:23,880
，所以这里应该发生的是，

1214
00:49:23,880 --> 00:49:25,680
我们会查看目录并

1215
00:49:25,680 --> 00:49:28,040
说演员 ID 是主键，

1216
00:49:28,040 --> 00:49:32,940
它不能为空，因此我

1217
00:49:32,940 --> 00:49:36,450
知道没有元组会匹配我的谓词

1218
00:49:36,450 --> 00:49:37,860
，因此我可以删除 那

1219
00:49:37,860 --> 00:49:39,090
where 子句或只是 立即返回结束，

1220
00:49:39,090 --> 00:49:42,300
您知道一个空

1221
00:49:42,300 --> 00:49:44,790
集，因此这是一个示例，在

1222
00:49:44,790 --> 00:49:46,260
重写阶段，这些规则可以

1223
00:49:46,260 --> 00:49:48,060
查看目录并了解

1224
00:49:48,060 --> 00:49:49,530
有关表或正在存在的属性的信息，

1225
00:49:49,530 --> 00:49:51,630
您知道它可能正在

1226
00:49:51,630 --> 00:49:53,670
访问谓词并开始

1227
00:49:53,670 --> 00:49:57,150
扔掉没用的废话，所以只是

1228
00:49:57,150 --> 00:49:59,970
为了证明我们的表不能

1229
00:49:59,970 --> 00:50:02,200


1230
00:50:02,200 --> 00:50:04,510
支持演员 IDE 中的想法的任何属性，

1231
00:50:04,510 --> 00:50:06,910
如果我尝试

1232
00:50:06,910 --> 00:50:10,059
为第一列插入一个空元组，那么

1233
00:50:10,059 --> 00:50:10,510
你知道

1234
00:50:10,510 --> 00:50:11,680
Postgres 选择了它并说

1235
00:50:11,680 --> 00:50:14,140
如果我尝试在 Oracle 中执行相同的操作，则会出现错误

1236
00:50:14,140 --> 00:50:20,140
Oracle

1237
00:50:20,140 --> 00:50:21,970
显示角色 IDE 不能为 null 抛出

1238
00:50:21,970 --> 00:50:27,700
错误让我们在我的续集中尝试此操作

1239
00:50:27,700 --> 00:50:29,109


1240
00:50:29,109 --> 00:50:31,539


1241
00:50:31,539 --> 00:50:38,440
默认应该在这里工作 让我插入

1242
00:50:38,440 --> 00:50:42,640
它 让我们看看它是否真的在

1243
00:50:42,640 --> 00:50:45,000


1244
00:50:45,000 --> 00:50:52,170


1245
00:50:52,170 --> 00:50:54,940


1246
00:50:54,940 --> 00:50:57,640


1247
00:50:57,640 --> 00:51:01,750
那里 而不是在我的续集的这个版本中，

1248
00:51:01,750 --> 00:51:05,650
而不是在我

1249
00:51:05,650 --> 00:51:07,720
尝试插入 null 时抛出错误，它说哦，你是一个

1250
00:51:07,720 --> 00:51:09,910
自动增量键，所以继续

1251
00:51:09,910 --> 00:51:11,829
让我运行它并

1252
00:51:11,829 --> 00:51:13,240
用下一个值替换 null 而

1253
00:51:13,240 --> 00:51:14,380
其他的 系统会抛出一个错误，说

1254
00:51:14,380 --> 00:51:16,450
你试图插入 null 我的续集

1255
00:51:16,450 --> 00:51:19,089
会让你这样做，但是让我们

1256
00:51:19,089 --> 00:51:20,049
尝试运行我们的查询，这样我们就

1257
00:51:20,049 --> 00:51:22,660
知道没有 attrex 实际上应该为 null

1258
00:51:22,660 --> 00:51:26,700
no-no 元组应该有一个 null actor ID，

1259
00:51:26,700 --> 00:51:31,119
所以我们 现在尝试运行这个查询，哪里是

1260
00:51:31,119 --> 00:51:34,900
null 正确的

1261
00:51:34,900 --> 00:51:37,150
Postgres 看起来它实际上

1262
00:51:37,150 --> 00:51:39,630
要运行它

1263
00:51:42,099 --> 00:51:45,019
现在她确实运行它正确应用了

1264
00:51:45,019 --> 00:51:47,589
过滤器并删除了 200 个元组

1265
00:51:47,589 --> 00:51:49,819
所以 Postgres 不是你最好认识

1266
00:51:49,819 --> 00:51:53,269
到没有带有新管的元组是 在

1267
00:51:53,269 --> 00:51:54,890
演员 ID 可能永远为空，而不是

1268
00:51:54,890 --> 00:51:56,720
实际运行它，实际上仍然

1269
00:51:56,720 --> 00:52:06,079
运行它让我们在我的续集中尝试它我的

1270
00:52:06,079 --> 00:52:06,950
电脑去找出

1271
00:52:06,950 --> 00:52:10,309
不可能的地方，它可以像

1272
00:52:10,309 --> 00:52:14,359
Amelie 忽略它在续集服务器中尝试它

1273
00:52:14,359 --> 00:52:24,589
或抱歉或 Oracle 解释了然后

1274
00:52:24,589 --> 00:52:26,450
有我们可爱的 null 不是 null

1275
00:52:26,450 --> 00:52:28,460
有我们的 false 所以认识到

1276
00:52:28,460 --> 00:52:29,720
这是永远不会好的实际上

1277
00:52:29,720 --> 00:52:31,309
会评估为 true 并被

1278
00:52:31,309 --> 00:52:34,450
扔掉所以帖子实际上弄错了

1279
00:52:34,450 --> 00:52:38,509
我的 C 会绕过它

1280
00:52:38,509 --> 00:52:39,680
好吧 再举两个例子

1281
00:52:39,680 --> 00:52:42,049
让我们做 现在，我们之前有一个范围查询

1282
00:52:42,049 --> 00:52:48,259
，我们想说我们想要

1283
00:52:48,259 --> 00:52:49,970
获取

1284
00:52:49,970 --> 00:52:53,990
电影 ID 介于 1 和 2 之间以及电影

1285
00:52:53,990 --> 00:52:56,630
ID 介于 199 和 200 之间的所有电影，所以这又是

1286
00:52:56,630 --> 00:53:00,140
另一个不可能的事情，我们是对的，所以

1287
00:53:00,140 --> 00:53:03,200
什么都不应该 回来我们在

1288
00:53:03,200 --> 00:53:08,180
解释所以我的帖子里的人无法

1289
00:53:08,180 --> 00:53:11,750
弄清楚它正在做

1290
00:53:11,750 --> 00:53:14,180
那种永远不应该发生的查找

1291
00:53:14,180 --> 00:53:20,089
永远不会在我的续集中产生任何

1292
00:53:20,089 --> 00:53:22,450


1293
00:53:24,390 --> 00:53:26,410
结果我不确定没有

1294
00:53:26,410 --> 00:53:28,420
匹配没有匹配 滚动可汗稳定

1295
00:53:28,420 --> 00:53:29,980
我认为这

1296
00:53:29,980 --> 00:53:36,310
意味着他们能够弄清楚他们是

1297
00:53:36,310 --> 00:53:38,980
的这个我不确定它有一个警告

1298
00:53:38,980 --> 00:53:40,420
虽然看看他是否写

1299
00:53:40,420 --> 00:53:49,210
了这个问题这不是一个无所畏惧的状态

1300
00:53:49,210 --> 00:53:51,370
我 建立一个问题 这是

1301
00:53:51,370 --> 00:53:56,560
np-complete 是的但是就像但是对于基本的

1302
00:53:56,560 --> 00:53:58,150
事情我可以确定它

1303
00:53:58,150 --> 00:54:00,130
永远不会你知道生产任何东西

1304
00:54:00,130 --> 00:54:02,550
并将其扔掉

1305
00:54:09,300 --> 00:54:12,160
所以这是一个或实际的危机

1306
00:54:12,160 --> 00:54:15,550
没有没有希望你可以有一个

1307
00:54:15,550 --> 00:54:17,050
规则你可以写一个启发式，

1308
00:54:17,050 --> 00:54:20,320
说如果我

1309
00:54:20,320 --> 00:54:26,590
在给定的属性上进行所有查找，我

1310
00:54:26,590 --> 00:54:28,660
有一个范围在 1 和 2

1311
00:54:28,660 --> 00:54:32,230
之间，并且在 199 和 200 之间，这些

1312
00:54:32,230 --> 00:54:34,720
集合不相交，它是合

1313
00:54:34,720 --> 00:54:36,130
取的 我必须同时拥有

1314
00:54:36,130 --> 00:54:37,780
它们 我知道它永远不会匹配 我可以

1315
00:54:37,780 --> 00:54:41,280
把它扔掉 就像

1316
00:54:41,280 --> 00:54:43,000
那个并不悲伤 非常

1317
00:54:43,000 --> 00:54:44,380
简单 所有部分都

1318
00:54:44,380 --> 00:54:47,340
可以满足你必须这样做 是

1319
00:54:47,340 --> 00:54:49,870
的 好吧 所以任何关于

1320
00:54:49,870 --> 00:54:51,580
我的问题 在这里展示我展示的是，您

1321
00:54:51,580 --> 00:54:53,260
可以在

1322
00:54:53,260 --> 00:54:55,390
不实际

1323
00:54:55,390 --> 00:54:57,310
查看数据的情况下推理查询的外观，而无需实际运行

1324
00:54:57,310 --> 00:55:00,070
任何东西，并确定您是否知道

1325
00:55:00,070 --> 00:55:04,320
这是一种简化谓词的方法

1326
00:55:06,600 --> 00:55:09,160
将导致现在的讨论 fa

1327
00:55:09,160 --> 00:55:13,110
行动委员会的估计如何

1328
00:55:13,110 --> 00:55:16,960
所以对于这些象征性的演示，这里的

1329
00:55:16,960 --> 00:55:19,510
连接非常简单，

1330
00:55:19,510 --> 00:55:21,460
所以我们可以很容易地知道，当你开始有更多的连接时，你可能会很容易地

1331
00:55:21,460 --> 00:55:22,300
知道哪个应该是内部

1332
00:55:22,300 --> 00:55:24,850
和外部的事情变坏的

1333
00:55:24,850 --> 00:55:26,460


1334
00:55:26,460 --> 00:55:29,110
原因，因为 做出这个决定的问题的复杂

1335
00:55:29,110 --> 00:55:31,500
性将会爆炸，

1336
00:55:31,500 --> 00:55:35,950
所以

1337
00:55:35,950 --> 00:55:37,420


1338
00:55:37,420 --> 00:55:39,520
当我们有 n 个表要连接时，我们可以为查询进行连接的不同方式的数量

1339
00:55:39,520 --> 00:55:43,270
将是 N 的四比，所以这

1340
00:55:43,270 --> 00:55:44,710
显然我们没有办法 枚举

1341
00:55:44,710 --> 00:55:46,990
每一个可能的连接顺序

1342
00:55:46,990 --> 00:55:48,430
和我们的查询，并尝试

1343
00:55:48,430 --> 00:55:50,290
找出最好的一个，你知道它是一个很大的

1344
00:55:50,290 --> 00:55:54,580
数字，当它有一个正确的名字时，我们

1345
00:55:54,580 --> 00:55:56,080
将看到数据中心将

1346
00:55:56,080 --> 00:55:58,630
如何能够剥离 必须枚举这些联合排序

1347
00:55:58,630 --> 00:56:00,250
的不同组合和计划的数量，

1348
00:56:00,250 --> 00:56:01,330


1349
00:56:01,330 --> 00:56:04,150
这将减少问题的

1350
00:56:04,150 --> 00:56:06,520
搜索基础，但在我们

1351
00:56:06,520 --> 00:56:08,050
到达那里之前，我们需要了解

1352
00:56:08,050 --> 00:56:10,660
我们实际上将如何估计 估计

1353
00:56:10,660 --> 00:56:12,310
我们要为这些连接或

1354
00:56:12,310 --> 00:56:14,580
这些不同的扫描

1355
00:56:14,580 --> 00:56:16,420
做多少工作，所以我之前已经说过了

1356
00:56:16,420 --> 00:56:20,440
，但是成本模型将

1357
00:56:20,440 --> 00:56:22,780
允许我们评估或估计

1358
00:56:22,780 --> 00:56:24,160
我们认为我们要做多少工作

1359
00:56:24,160 --> 00:56:25,960
必须在我们的数据库系统中做，这

1360
00:56:25,960 --> 00:56:28,870
也是一个内部综合数字，

1361
00:56:28,870 --> 00:56:30,700
它只允许我们比较

1362
00:56:30,700 --> 00:56:32,380
不同查询计划的相对性能，

1363
00:56:32,380 --> 00:56:34,480
我们在同一个数据库系统中我们

1364
00:56:34,480 --> 00:56:37,750
无法比较所有这些，所以这

1365
00:56:37,750 --> 00:56:39,040
可能是一个 结合

1366
00:56:39,040 --> 00:56:40,330
我们已经看到的一堆不同的东西，

1367
00:56:40,330 --> 00:56:42,550
当我们谈论

1368
00:56:42,550 --> 00:56:44,350
你想要做的联合算法时，你想要

1369
00:56:44,350 --> 00:56:47,320
基于磁盘数量我没有磁盘

1370
00:56:47,320 --> 00:56:49,270
IO 我将不得不这样做 所以

1371
00:56:49,270 --> 00:56:50,710


1372
00:56:50,710 --> 00:56:51,790


1373
00:56:51,790 --> 00:56:53,620
你在计算查询时需要多少 DRAM 你必须在缓冲池上占用多少内存空间

1374
00:56:53,620 --> 00:56:55,780
如果你要分发一个

1375
00:56:55,780 --> 00:56:57,490
数据库，那么消息的数量

1376
00:56:57,490 --> 00:56:59,740
也是一个重要的事情，因为

1377
00:56:59,740 --> 00:57:03,250
网络 IO 缓慢且效率低下，因此

1378
00:57:03,250 --> 00:57:06,840
对此的主要结论是

1379
00:57:06,840 --> 00:57:09,700
，成本模型允许我们说

1380
00:57:09,700 --> 00:57:12,070
一种计划比另一种更好，而无需

1381
00:57:12,070 --> 00:57:13,480
实际运行查询计划，

1382
00:57:13,480 --> 00:57:14,560
因为这是获得实际真相的唯一方法，

1383
00:57:14,560 --> 00:57:16,510
真正的成本

1384
00:57:16,510 --> 00:57:18,220
实际上是运行查询计划 但你

1385
00:57:18,220 --> 00:57:19,660
不想这样做，因为

1386
00:57:19,660 --> 00:57:21,220
如果我有 4dn 个不同的联合

1387
00:57:21,220 --> 00:57:21,820
排序，

1388
00:57:21,820 --> 00:57:23,800
我不能为一个查询运行 N 个

1389
00:57:23,800 --> 00:57:25,570
不同的查询计划，

1390
00:57:25,570 --> 00:57:29,350
因为这将永远花费所以成本

1391
00:57:29,350 --> 00:57:31,590
模型 这使我们能够对此进行近似，

1392
00:57:31,590 --> 00:57:34,060
您知道将放弃牺牲

1393
00:57:34,060 --> 00:57:36,130
我们估计的准确性以

1394
00:57:36,130 --> 00:57:39,130
换取效率 现在有些数据库

1395
00:57:39,130 --> 00:57:41,740
系统没有成本

1396
00:57:41,740 --> 00:57:43,030
模型 他们没有查询优化器

1397
00:57:43,030 --> 00:57:45,850
他们实际上只是触发所有查询

1398
00:57:45,850 --> 00:57:47,920
和 看看哪一个先回来

1399
00:57:47,920 --> 00:57:51,579
，那是他们选择

1400
00:57:51,579 --> 00:57:53,690
的那个，所以我知道唯一一个这样做的系统

1401
00:57:53,690 --> 00:57:56,510
实际上是 MongoDB 正确的，这

1402
00:57:56,510 --> 00:57:57,740
看起来有点愚蠢，为什么你要这样做，

1403
00:57:57,740 --> 00:57:59,390
为什么你要建立一个成本模型，

1404
00:57:59,390 --> 00:58:01,250
他们不是 补给 orting 连接

1405
00:58:01,250 --> 00:58:03,589
回到当天，他们需要一个成本模型，

1406
00:58:03,589 --> 00:58:05,390
他们需要一个查询优化器，

1407
00:58:05,390 --> 00:58:07,760
所以如果我必须弄清楚要选择什么索引

1408
00:58:07,760 --> 00:58:09,140
并且只触发 Aquarius 的下降，

1409
00:58:09,140 --> 00:58:10,250
无论哪个先回来，

1410
00:58:10,250 --> 00:58:12,799
那个是最快的，然后我

1411
00:58:12,799 --> 00:58:14,059
只记得 每次我

1412
00:58:14,059 --> 00:58:15,380
一遍又一遍地看到相同的查询时

1413
00:58:15,380 --> 00:58:17,539
，最终你知道他们会

1414
00:58:17,539 --> 00:58:20,180
再次运行试验，而且首先是

1415
00:58:20,180 --> 00:58:21,680
简单的，因为它实际上

1416
00:58:21,680 --> 00:58:24,920
对他们来说效果很好，这就是他们的

1417
00:58:24,920 --> 00:58:27,380
权利无关紧要的地方 什么是

1418
00:58:27,380 --> 00:58:29,569
正确的权利是做一个索引

1419
00:58:29,569 --> 00:58:31,849
查找来找到正确的东西然后

1420
00:58:31,849 --> 00:58:33,710
你进行修改索引

1421
00:58:33,710 --> 00:58:34,730
查找是更昂贵的部分

1422
00:58:34,730 --> 00:58:35,960
发现数据

1423
00:58:35,960 --> 00:58:38,809
比实际权利更昂贵但是如果我正在

1424
00:58:38,809 --> 00:58:41,210
更新表并且 我的索引现在正在改变

1425
00:58:41,210 --> 00:58:44,180
它的分布然后他们会做的

1426
00:58:44,180 --> 00:58:45,200
是他们必须有一个触发器来

1427
00:58:45,200 --> 00:58:46,880
说明我已经运行相同的查询

1428
00:58:46,880 --> 00:58:49,220
一千次让我刷新并再次重新运行

1429
00:58:49,220 --> 00:58:51,650
所有内容或者我的表是我的表

1430
00:58:51,650 --> 00:58:53,750
我 他们的世界收藏发生了变化

1431
00:58:53,750 --> 00:58:55,670
我已经更新了 10%

1432
00:58:55,670 --> 00:58:58,190
让我再次重新运行该试验这

1433
00:58:58,190 --> 00:59:05,690
只是启发式是的这些问题是

1434
00:59:05,690 --> 00:59:06,980
它们按顺序运行是它们

1435
00:59:06,980 --> 00:59:11,839
一个接一个地运行所以就像

1436
00:59:11,839 --> 00:59:13,789
MongoDB 是一个分布式数据库

1437
00:59:13,789 --> 00:59:15,109
就他们所知的方式 他们这样做是因为

1438
00:59:15,109 --> 00:59:17,809
我有一个需要在一堆节点上运行的查询，

1439
00:59:17,809 --> 00:59:19,940
并且它们具有

1440
00:59:19,940 --> 00:59:21,170
不同的数据段或分区，

1441
00:59:21,170 --> 00:59:23,180
并且它们都具有相同的索引，

1442
00:59:23,180 --> 00:59:25,279
仅基于您

1443
00:59:25,279 --> 00:59:28,250
知道该表的不同部分，所以 对于这个我将

1444
00:59:28,250 --> 00:59:29,510
使用这个索引这个我将使用那个

1445
00:59:29,510 --> 00:59:31,010
索引等等，看看哪个

1446
00:59:31,010 --> 00:59:32,720
实际上是最快的，然后你

1447
00:59:32,720 --> 00:59:34,220
再次看到相同的查询，你需要

1448
00:59:34,220 --> 00:59:35,029
在所有这些不同的节点上剥离它，

1449
00:59:35,029 --> 00:59:37,309
你只是 选择相同的索引，这样

1450
00:59:37,309 --> 00:59:38,680
对每个人来说都是最快的，

1451
00:59:38,680 --> 00:59:41,059
超级简单，但它工作得

1452
00:59:41,059 --> 00:59:43,210
很好，

1453
00:59:44,470 --> 00:59:47,180
所以我们

1454
00:59:47,180 --> 00:59:49,339
能够近似

1455
00:59:49,339 --> 00:59:52,400
执行查询的成本的方式是通过

1456
00:59:52,400 --> 00:59:54,230
维护内部统计数据

1457
00:59:54,230 --> 00:59:56,809
我们的表格看起来像这样

1458
00:59:56,809 --> 00:59:57,829
在整个

1459
00:59:57,829 --> 00:59:59,210
学期中出现了多次，我说哦，那天说我们

1460
00:59:59,210 --> 01:00:00,799
可以对表格有所了解，这

1461
01:00:00,799 --> 01:00:02,059
就是我的意思，这就是他们

1462
01:00:02,059 --> 01:00:04,310
实际上能够

1463
01:00:04,310 --> 01:00:07,100
在系统内部执行此操作的方式 目录 我们

1464
01:00:07,100 --> 01:00:09,710
将维护关于

1465
01:00:09,710 --> 01:00:11,300
我们的表的索引是

1466
01:00:11,300 --> 01:00:15,290
什么样的元数据元组中的值

1467
01:00:15,290 --> 01:00:16,880
然后我们将如何实际维护

1468
01:00:16,880 --> 01:00:18,860
这些信息将

1469
01:00:18,860 --> 01:00:20,900
根据不同的系统而有所不同所以我说就像

1470
01:00:20,900 --> 01:00:22,940
得到一个 简单的启发式，比如如果我的

1471
01:00:22,940 --> 01:00:25,790
表改变了 10% 我们收集我的

1472
01:00:25,790 --> 01:00:28,220
统计数据 其他系统

1473
01:00:28,220 --> 01:00:30,590
在我运行查询时也可以说得很好 也看看

1474
01:00:30,590 --> 01:00:32,300
看看磁带 看看我正在处理的数据

1475
01:00:32,300 --> 01:00:34,730
然后传播 你知道

1476
01:00:34,730 --> 01:00:37,810
关于我什么的信息

1477
01:00:37,810 --> 01:00:40,420
回到我的内部说姐妹目录，

1478
01:00:40,420 --> 01:00:43,820
你也可以手动运行它，所以在

1479
01:00:43,820 --> 01:00:45,620
这一次，它们在

1480
01:00:45,620 --> 01:00:47,690
不同的系统中都不同，关于语法

1481
01:00:47,690 --> 01:00:50,270
实际上是什么，但总的来说可以分析

1482
01:00:50,270 --> 01:00:52,010
所以跨一个的共性

1483
01:00:52,010 --> 01:00:54,260
你调用这个分析函数并

1484
01:00:54,260 --> 01:00:56,480
启动一个顺序扫描，它

1485
01:00:56,480 --> 01:00:59,270
会查看数据的日期，并再次

1486
01:00:59,270 --> 01:01:00,830
更新关于分布情况的内部信息

1487
01:01:00,830 --> 01:01:03,710
，

1488
01:01:03,710 --> 01:01:05,270
然后你认为是你可以

1489
01:01:05,270 --> 01:01:06,920
根据更新来触发它

1490
01:01:06,920 --> 01:01:08,960
表或像每天运行的 cron 作业

1491
01:01:08,960 --> 01:01:11,480
，我们看到了多

1492
01:01:11,480 --> 01:01:13,010
版本控制，让我们谈谈

1493
01:01:13,010 --> 01:01:14,870
吸尘，把它想象成垃圾

1494
01:01:14,870 --> 01:01:16,760
收集和 JVM，你也可以同时运行

1495
01:01:16,760 --> 01:01:18,200
分析，因为

1496
01:01:18,200 --> 01:01:19,100
当你在做的时候 Twitch 将扫描

1497
01:01:19,100 --> 01:01:20,870
您正在查看的所有内容，然后您可以

1498
01:01:20,870 --> 01:01:25,310
更新这些内容

1499
01:01:25,310 --> 01:01:26,840


1500
01:01:26,840 --> 01:01:28,490


1501
01:01:28,490 --> 01:01:30,200


1502
01:01:30,200 --> 01:01:34,670
这些值很好，

1503
01:01:34,670 --> 01:01:37,160
我们将在下周开始学习，然后

1504
01:01:37,160 --> 01:01:38,120
我们将讨论您如何

1505
01:01:38,120 --> 01:01:40,270
在列中进行枚举，

1506
01:01:40,270 --> 01:01:45,800
好吧好吧，所以再次在周三的

1507
01:01:45,800 --> 01:01:49,160
课堂上进行考试，这不是真正

1508
01:01:49,160 --> 01:01:50,990
的 开玩笑 一年有人就像 哦，

1509
01:01:50,990 --> 01:01:52,490
我以为你在开玩笑 不，这是

1510
01:01:52,490 --> 01:01:54,040
真的

1511
01:01:54,040 --> 01:01:57,800
带上你的 CMU ID 带上你的

1512
01:01:57,800 --> 01:01:59,060
纸和笔记 然后带上一个

1513
01:01:59,060 --> 01:02:01,130
计算器 之后我的办公时间很

1514
01:02:01,130 --> 01:02:02,360
整齐 但如果你需要

1515
01:02:02,360 --> 01:02:04,400
和我谈谈 你知道在不同的

1516
01:02:04,400 --> 01:02:05,600
时间给我发一封电子邮件

1517
01:02:05,600 --> 01:02:08,150
我很高兴见到任何人

1518
01:02:08,150 --> 01:02:09,860
好吧 伙计们祝你好运周三见

1519
01:02:09,860 --> 01:02:10,370


1520
01:02:10,370 --> 01:02:12,270


1521
01:02:12,270 --> 01:02:15,310


1522
01:02:15,310 --> 01:02:17,320


1523
01:02:17,320 --> 01:02:19,510
演示中的奶牛

1524
01:02:19,510 --> 01:02:22,570
我会尝试他在我的系统中看到刀

1525
01:02:22,570 --> 01:02:24,460
我很幸运

1526
01:02:24,460 --> 01:02:31,930
让我们去下一个好起来

1527
01:02:31,930 --> 01:02:33,970
会有太阳弹跳果冻撞到

1528
01:02:33,970 --> 01:02:36,130
熟食店的一条船自然祝福

1529
01:02:36,130 --> 01:02:37,780
你说唱是什么样的 激光束

1530
01:02:37,780 --> 01:02:40,150
丛林中的男孩们说好人甚至不能

1531
01:02:40,150 --> 01:02:42,160
把我们的瓶子包起来 一个很好的同情

1532
01:02:42,160 --> 01:02:43,960
去 不想喝那种

1533
01:02:43,960 --> 01:02:46,089
品质给你 令牌不能放下十字架 他

1534
01:02:46,089 --> 01:02:47,829
还活着，如果缘故不知道

1535
01:02:47,829 --> 01:02:51,150
你的手机可以点击坦克

