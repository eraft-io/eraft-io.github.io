1
00:00:01,300 --> 00:00:05,129
[音乐]

2
00:00:05,200 --> 00:00:05,930
[鼓掌]

3
00:00:05,930 --> 00:00:08,630
[音乐]

4
00:00:08,630 --> 00:00:10,020
[鼓掌]

5
00:00:10,020 --> 00:00:12,200
[音乐]

6
00:00:12,200 --> 00:00:15,540
今天的讲座是关于比数据库系统可用

7
00:00:15,540 --> 00:00:16,740
的内存量大

8
00:00:16,740 --> 00:00:19,640
的数据库，

9
00:00:19,640 --> 00:00:22,550
所以我家这里仍然处于锁定状态

10
00:00:22,550 --> 00:00:25,230
，运营商在那边，有点像

11
00:00:25,230 --> 00:00:28,529
在我们进行过程中提出问题，但

12
00:00:28,529 --> 00:00:29,970
以前不是很好，所以

13
00:00:29,970 --> 00:00:31,560
人们抱怨说，就像椅子

14
00:00:31,560 --> 00:00:32,640
没有问他们想要问的问题一样，

15
00:00:32,640 --> 00:00:35,430
这就是其中之一，所以在

16
00:00:35,430 --> 00:00:38,070
我们进入今天的讲座材料之前，我

17
00:00:38,070 --> 00:00:40,350
首先 想快速了解一下

18
00:00:40,350 --> 00:00:42,870


19
00:00:42,870 --> 00:00:43,920
本学期注册课程的人会遇到什么，

20
00:00:43,920 --> 00:00:46,260
比如即将到来的截止日期和

21
00:00:46,260 --> 00:00:49,079
日期，所以在本周的星期三，我将发布原定于星期三后一周

22
00:00:49,079 --> 00:00:53,699
的期末考试

23
00:00:53,699 --> 00:00:56,940
所以

24
00:00:56,940 --> 00:00:59,940
下周我现在

25
00:00:59,940 --> 00:01:02,190
将期末考试延长到

26
00:01:02,190 --> 00:01:04,019
13 日到期，所以现在每个人都有

27
00:01:04,019 --> 00:01:10,380
三周的时间来实际完成它

28
00:01:10,380 --> 00:01:16,290
，好的运营商的问题是我们可以

29
00:01:16,290 --> 00:01:17,759
有一个你知道的课程

30
00:01:17,759 --> 00:01:21,000
在我发布这个不之前进行一次练习考试，

31
00:01:21,000 --> 00:01:23,220
因为你会看到这是一个

32
00:01:23,220 --> 00:01:25,080
长形式的问题，并且基于

33
00:01:25,080 --> 00:01:26,670
我们本学期讨论的材料

34
00:01:26,670 --> 00:01:28,350
，现在我给你三个星期的时间

35
00:01:28,350 --> 00:01:30,630
来实际做这件事没有意义

36
00:01:30,630 --> 00:01:34,020
首先发布模拟考试接下来的

37
00:01:34,020 --> 00:01:37,170
事情是，下周星期三，我们

38
00:01:37,170 --> 00:01:39,750
希望有一位

39
00:01:39,750 --> 00:01:42,360
来自亚马逊的演讲嘉宾来为

40
00:01:42,360 --> 00:01:45,450
这个演讲做演讲，因为亚马逊的限制，

41
00:01:45,450 --> 00:01:47,100
我们将不得不把它变成一场现场

42
00:01:47,100 --> 00:01:50,030
讲座，只会

43
00:01:50,030 --> 00:01:53,220
CMU 学生可以访问，所以你需要

44
00:01:53,220 --> 00:01:55,560
在我们

45
00:01:55,560 --> 00:01:56,880
通常安排课程的

46
00:01:56,880 --> 00:01:59,280
时间来，所以是 12:00 下午 12:00 东部

47
00:01:59,280 --> 00:02:02,610
标准时间，因为这不会被

48
00:02:02,610 --> 00:02:06,149
记录，所以现在项目

49
00:02:06,149 --> 00:02:08,310
3 的第二轮审查

50
00:02:08,310 --> 00:02:11,280
将于 5 月 4 日到期，然后我们现在将

51
00:02:11,280 --> 00:02:13,370
在

52
00:02:13,370 --> 00:02:17,360
原定的

53
00:02:17,360 --> 00:02:20,810
5 月 5 日 5 点的期末考试时间进行最后的演讲 :30 下午 再次，我们

54
00:02:20,810 --> 00:02:22,310
将转到唯一的缩放频道，

55
00:02:22,310 --> 00:02:24,110
每个人都将像我们所做的那样展示

56
00:02:24,110 --> 00:02:27,290
之前的状态更新，嘿

57
00:02:27,290 --> 00:02:28,790
再次，然后期末考试将

58
00:02:28,790 --> 00:02:32,329
在 13 日到期，所以我将做的主要事情是

59
00:02:32,329 --> 00:02:35,720
说一下代码

60
00:02:35,720 --> 00:02:37,730
审查，马特和我将在

61
00:02:37,730 --> 00:02:39,650
本周完成并提供第一

62
00:02:39,650 --> 00:02:41,390
轮代码审查的反馈，并

63
00:02:41,390 --> 00:02:43,519
为第二轮做好准备，想法

64
00:02:43,519 --> 00:02:44,569
是你想接受

65
00:02:44,569 --> 00:02:46,160
其他团队的所有建议

66
00:02:46,160 --> 00:02:47,900
从第一轮开始就你的项目做了，

67
00:02:47,900 --> 00:02:49,519
然后将它们实际应用到第二

68
00:02:49,519 --> 00:02:51,109
轮我不想

69
00:02:51,109 --> 00:02:52,489
再犯同样的错误，

70
00:02:52,489 --> 00:02:56,290
让他们重复自己就好了

71
00:02:56,290 --> 00:03:00,890
，正如我在开头所说的那样

72
00:03:00,890 --> 00:03:03,170
这个学期

73
00:03:03,170 --> 00:03:04,700
似乎很长，嗯，

74
00:03:04,700 --> 00:03:08,810
现在回到 1 月份，这门课

75
00:03:08,810 --> 00:03:10,870
的重点是内存数据库，

76
00:03:10,870 --> 00:03:15,230


77
00:03:15,230 --> 00:03:17,540


78
00:03:17,540 --> 00:03:19,609
我们整个学期讨论的所有算法和方法以及架构决策都

79
00:03:19,609 --> 00:03:21,739
基于 假设

80
00:03:21,739 --> 00:03:23,870
数据库完全驻留在主内存中，

81
00:03:23,870 --> 00:03:26,450
这意味着我们没有编写算法或

82
00:03:26,450 --> 00:03:27,380
Rutte 你还不知道联合

83
00:03:27,380 --> 00:03:30,169
算法可以最大化或最小

84
00:03:30,169 --> 00:03:32,060
化它们产生的磁盘 i/o 的数量

85
00:03:32,060 --> 00:03:34,549
假设任何时候我们跟随一个

86
00:03:34,549 --> 00:03:38,989
指向 元组或缓冲区

87
00:03:38,989 --> 00:03:41,260


88
00:03:41,260 --> 00:03:44,239
现在将始终在内存中 缺点就像我说的

89
00:03:44,239 --> 00:03:45,799
我的意思是优点是正如我们

90
00:03:45,799 --> 00:03:47,090
在整个学期中看到的那样，这

91
00:03:47,090 --> 00:03:49,730
使您可以更有效地实施事情，

92
00:03:49,730 --> 00:03:52,310
因为您没有

93
00:03:52,310 --> 00:03:56,180
必须进行所有这些检查，以

94
00:03:56,180 --> 00:03:58,669
说明这样一个事实，就像在磁盘或任何

95
00:03:58,669 --> 00:04:00,889
系统中一样，无论何时你触摸你都知道

96
00:04:00,889 --> 00:04:02,299
一块内存，它实际上

97
00:04:02,299 --> 00:04:04,129
可能在内存中，它是我在办公桌上，你

98
00:04:04,129 --> 00:04:05,840
必须让你知道通过

99
00:04:05,840 --> 00:04:07,910
buffle 一分钟前得到它所以我们如果

100
00:04:07,910 --> 00:04:10,609
你知道我们可以编写我们的系统

101
00:04:10,609 --> 00:04:12,769
而不假设它会非常

102
00:04:12,769 --> 00:04:16,789
快但是缺点

103
00:04:16,789 --> 00:04:18,880
是内存市场已经

104
00:04:18,880 --> 00:04:21,079
在我们的数据库市场中显示出来 蕾丝

105
00:04:21,079 --> 00:04:25,849
在过去十年中表现出的一点是 SSD 和

106
00:04:25,849 --> 00:04:26,630
旋转磁盘

107
00:04:26,630 --> 00:04:31,520
仍然是驱动器，或者仍然在

108
00:04:31,520 --> 00:04:32,840
价格与性能方面

109
00:04:32,840 --> 00:04:36,230
仍然提供

110
00:04:36,230 --> 00:04:38,000
某些特性，

111
00:04:38,000 --> 00:04:41,330
即使从现代以前的

112
00:04:41,330 --> 00:04:44,990
应用程序中也可以提供这些特性，这是 因为

113
00:04:44,990 --> 00:04:48,110
其核心的 DRAM 价格昂贵，而且

114
00:04:48,110 --> 00:04:51,440
相对于 DRAM 而言购买价格昂贵，

115
00:04:51,440 --> 00:04:54,470
并且对 SSD 和

116
00:04:54,470 --> 00:04:57,140
旋转齿轮硬盘感到抱歉，所以大约在

117
00:04:57,140 --> 00:05:01,550
2020 年，

118
00:05:01,550 --> 00:05:03,890
旋转磁盘硬盘的每 GB 价格约为 2

119
00:05:03,890 --> 00:05:06,950
到 3 美分 对于 NAND 闪存，它

120
00:05:06,950 --> 00:05:09,140
不到 1 美元，几年前

121
00:05:09,140 --> 00:05:12,710
我看到它是每 GB 30 美分，

122
00:05:12,710 --> 00:05:13,160


123
00:05:13,160 --> 00:05:17,900
而在 DRAM 中，

124
00:05:17,900 --> 00:05:22,370
由于一些诉讼，我们

125
00:05:22,370 --> 00:05:25,760
可以将其脱机，因此近年来它有所下降，但

126
00:05:25,760 --> 00:05:27,980
大致可能差不多 每 GB 5 到 6

127
00:05:27,980 --> 00:05:29,060
美元

128
00:05:29,060 --> 00:05:30,830
这是假设你是

129
00:05:30,830 --> 00:05:32,330
批量购买我想我的意思是你的制造商

130
00:05:32,330 --> 00:05:33,950
不像你去亚马逊

131
00:05:33,950 --> 00:05:38,060
买你知道丹

132
00:05:38,060 --> 00:05:39,320
你的机器像你一样你是一个主要的

133
00:05:39,320 --> 00:05:41,630
制造商他们可以批量购买这个

134
00:05:41,630 --> 00:05:45,650
所以购买价格很贵

135
00:05:45,650 --> 00:05:46,970
我们也真正谈论过的另一件事

136
00:05:46,970 --> 00:05:48,590


137
00:05:48,590 --> 00:05:51,740
是当我把它放在我的电脑上时保持意义很昂贵而且

138
00:05:51,740 --> 00:05:53,630
我 在我的服务器上，我和我你

139
00:05:53,630 --> 00:05:54,620
知道插入服务器 我实际上

140
00:05:54,620 --> 00:05:57,380
正在运行它

141
00:05:57,380 --> 00:05:59,330
用于为该机器供电的电力的百分比

142
00:05:59,330 --> 00:06:02,720


143
00:06:02,720 --> 00:06:05,450
现在有相当一部分将是圆形的 现在这是

144
00:06:05,450 --> 00:06:07,850
忽略 就像比特币挖矿一样，

145
00:06:07,850 --> 00:06:11,390
或者你不知道在 GPU 上进行网络培训，

146
00:06:11,390 --> 00:06:13,100
这些东西肯定比 DRAM 更耗电，所以这些东西会

147
00:06:13,100 --> 00:06:15,980


148
00:06:15,980 --> 00:06:19,160
在某种数据库服务器中汲取大部分能量，

149
00:06:19,160 --> 00:06:23,120
而这种数据库服务器

150
00:06:23,120 --> 00:06:25,250
不会在 GPU 上做事

151
00:06:25,250 --> 00:06:27,380
大约 40%

152
00:06:27,380 --> 00:06:28,880
这是几年前完成的一项调查

153
00:06:28,880 --> 00:06:29,840
，他们实际测量

154
00:06:29,840 --> 00:06:31,700
了 DIMM 插槽占用的

155
00:06:31,700 --> 00:06:33,500
内存量，结果显示

156
00:06:33,500 --> 00:06:35,210
平均大约为 40%，因此

157
00:06:35,210 --> 00:06:37,550
这意味着所有 权力 你

158
00:06:37,550 --> 00:06:39,169
为运行你的机器支付了 40

159
00:06:39,169 --> 00:06:40,659
% 的费用，

160
00:06:40,659 --> 00:06:44,169
所以现在这意味着如果我正在

161
00:06:44,169 --> 00:06:45,550
运行一个内存数据库，而

162
00:06:45,550 --> 00:06:49,000
数据库必须完全适合 DRAM，

163
00:06:49,000 --> 00:06:51,310
我的数据库越大，dimalanta 就越多

164
00:06:51,310 --> 00:06:54,099
然后更多的口袋用来维护

165
00:06:54,099 --> 00:06:55,900
他基本上主板正在

166
00:06:55,900 --> 00:06:58,539
做的事情就像每隔几秒一样我

167
00:06:58,539 --> 00:07:00,159
认为每隔几秒钟它就会

168
00:07:00,159 --> 00:07:02,650
向暗淡的人发送电荷，以便

169
00:07:02,650 --> 00:07:04,569
他们可以刷新他们存储的地方

170
00:07:04,569 --> 00:07:06,970
，当然 这就是

171
00:07:06,970 --> 00:07:08,680
为什么如果你拉动它们的电源

172
00:07:08,680 --> 00:07:10,659
，你就无法进行刷新，

173
00:07:10,659 --> 00:07:14,259
然后你会丢失数据，所以考虑到我们

174
00:07:14,259 --> 00:07:16,810
整个学期都在讨论

175
00:07:16,810 --> 00:07:18,550
如何制作一个真正快速的内存

176
00:07:18,550 --> 00:07:21,639
数据库系统 如果我们能

177
00:07:21,639 --> 00:07:24,180
带回这些较慢

178
00:07:24,180 --> 00:07:26,590
参与的非易失性存储设备

179
00:07:26,590 --> 00:07:29,289
NAND 闪存或旋转磁盘硬盘驱动器中的一个，

180
00:07:29,289 --> 00:07:31,840
并获得能够将数据写入这些磁盘的好处，而

181
00:07:31,840 --> 00:07:35,979


182
00:07:35,979 --> 00:07:38,889
无需引入我们的所有架构

183
00:07:38,889 --> 00:07:40,590
组件，那就太好了

184
00:07:40,590 --> 00:07:42,550
我们通过

185
00:07:42,550 --> 00:07:44,710
从磁盘或任何架构中了解您所知道的算法

186
00:07:44,710 --> 00:07:46,479
并将其拉

187
00:07:46,479 --> 00:07:48,460
回到内存系统中来避免和我们避免的算法，以便我们

188
00:07:48,460 --> 00:07:50,020
最终得到我们首先试图避免的较慢的面向磁盘的

189
00:07:50,020 --> 00:07:51,669
架构

190
00:07:51,669 --> 00:07:53,590
所以这就是

191
00:07:53,590 --> 00:07:56,199
今天的重点，所以我们将首先

192
00:07:56,199 --> 00:07:58,240
在后台讨论

193
00:07:58,240 --> 00:08:01,719
不同的选择，或者我们可能知道

194
00:08:01,719 --> 00:08:04,990
为什么要这样做

195
00:08:04,990 --> 00:08:06,969
以在内存

196
00:08:06,969 --> 00:08:08,800
数据库系统中支持大于内存的数据库然后让我们谈谈

197
00:08:08,800 --> 00:08:09,909
如何 你实际上想要去实现

198
00:08:09,909 --> 00:08:11,409
它，然后我们将结束讨论

199
00:08:11,409 --> 00:08:15,099


200
00:08:15,099 --> 00:08:16,330
我们今天将要讨论的各种技术的一些实际实现，

201
00:08:16,330 --> 00:08:20,500
所以在高层次

202
00:08:20,500 --> 00:08:22,389
上我已经说过了，但只是

203
00:08:22,389 --> 00:08:24,969
重复一遍 我们

204
00:08:24,969 --> 00:08:28,479
今天讨论的目标是

205
00:08:28,479 --> 00:08:31,180
使内存中的数据库分钟系统

206
00:08:31,180 --> 00:08:34,208
能够存储和访问

207
00:08:34,208 --> 00:08:36,640
已写出磁盘的数据，而

208
00:08:36,640 --> 00:08:39,070
不必带回所有缓慢的

209
00:08:39,070 --> 00:08:40,479
部分，特别是

210
00:08:40,479 --> 00:08:43,839
当我们进入内存架构时，我们摆脱了缓冲池管理器，

211
00:08:43,839 --> 00:08:46,480


212
00:08:46,480 --> 00:08:49,839
因此我们

213
00:08:49,839 --> 00:08:52,300
想要尝试实现的另一种工程更改是，当我们

214
00:08:52,300 --> 00:08:53,880
带回磁盘时，

215
00:08:53,880 --> 00:08:56,430
我们不想去

216
00:08:56,430 --> 00:08:59,970
接触我们

217
00:08:59,970 --> 00:09:01,500
系统中的所有组件，现在考虑

218
00:09:01,500 --> 00:09:04,770
到它可以访问的数据

219
00:09:04,770 --> 00:09:07,290
不是内存中的数据，而是在磁盘上的事实，

220
00:09:07,290 --> 00:09:09,060
就像我们带回传统的

221
00:09:09,060 --> 00:09:10,410
Buffalo 管理器一样

222
00:09:10,410 --> 00:09:15,200
去访问一个你知道的

223
00:09:15,200 --> 00:09:18,030
位置我们需要知道我们

224
00:09:18,030 --> 00:09:20,340
必须知道哪个页面阻止了他们这是

225
00:09:20,340 --> 00:09:22,830
一个univers ID然后通过一个

226
00:09:22,830 --> 00:09:24,330
之前的经理为我们做这所以我们

227
00:09:24,330 --> 00:09:26,130
不得不修改整个系统到

228
00:09:26,130 --> 00:09:27,840
现在 只是

229
00:09:27,840 --> 00:09:29,910
像我们之前那样读取一块内存，现在

230
00:09:29,910 --> 00:09:31,080
通过缓冲池管理器

231
00:09:31,080 --> 00:09:34,410
获取一个页面或一块内存，

232
00:09:34,410 --> 00:09:35,700
然后我们可以访问它并知道其中的偏移量

233
00:09:35,700 --> 00:09:38,760
，这会减慢

234
00:09:38,760 --> 00:09:40,530
设计的算法 最小化

235
00:09:40,530 --> 00:09:42,720
磁盘 i/o  e 真的

236
00:09:42,720 --> 00:09:44,280
比我们今天讨论的随机访问要慢得多，

237
00:09:44,280 --> 00:09:49,620
所以我们

238
00:09:49,620 --> 00:09:51,030
必须这样做的方式或您知道的方式

239
00:09:51,030 --> 00:09:54,510
是我们需要意识到

240
00:09:54,510 --> 00:09:58,110
之间的那种根本

241
00:09:58,110 --> 00:10:01,320
差异 非易失性

242
00:10:01,320 --> 00:10:02,910
存储，如旋转磁盘硬盘

243
00:10:02,910 --> 00:10:05,820
和 man flash 以及内存中的易失性

244
00:10:05,820 --> 00:10:08,610
存储，核心区别

245
00:10:08,610 --> 00:10:10,110
在于内存中的存储将是

246
00:10:10,110 --> 00:10:12,090
面向元组的，本质上是字节

247
00:10:12,090 --> 00:10:15,510
可寻址的，我可以访问跳转

248
00:10:15,510 --> 00:10:17,550
到某个内存位置和 那

249
00:10:17,550 --> 00:10:22,020
就是我的元组将驻留在磁盘或

250
00:10:22,020 --> 00:10:23,730
磁盘存储模型中的任何架构中的地方，

251
00:10:23,730 --> 00:10:26,460
它将是面向块或面向页面

252
00:10:26,460 --> 00:10:28,830
的，这意味着我不能只跳转到

253
00:10:28,830 --> 00:10:31,440
单个字节和内存或页面中，而

254
00:10:31,440 --> 00:10:33,810
只是获取该数据并带来 它在

255
00:10:33,810 --> 00:10:34,290
内存中

256
00:10:34,290 --> 00:10:36,570
我必须去获取我想要的数据所在的整个 4

257
00:10:36,570 --> 00:10:39,750
KB 或 1 KB 页面，

258
00:10:39,750 --> 00:10:41,910
即使我

259
00:10:41,910 --> 00:10:43,440
不想要其他部分我可能只

260
00:10:43,440 --> 00:10:45,120
想要 1 KB 用于

261
00:10:45,120 --> 00:10:46,830
我带来的碰撞页面 在整个 4

262
00:10:46,830 --> 00:10:49,980
KB 页面中，这

263
00:10:49,980 --> 00:10:51,570
就是我们在设计

264
00:10:51,570 --> 00:10:56,250
允许

265
00:10:56,250 --> 00:11:00,110
我们在内存架构中的磁盘中移动数据的功能时必须处理的问题

266
00:11:00,110 --> 00:11:02,010
所以要讨论的另一件重要

267
00:11:02,010 --> 00:11:05,370
事情是整个讲座的 我们

268
00:11:05,370 --> 00:11:08,030
将专注于所有 OLTP 工作

269
00:11:08,030 --> 00:11:10,880
sooro LTP 系统，我们可以在

270
00:11:10,880 --> 00:11:12,560
H tap 系统的上下文中执行此操作，其中

271
00:11:12,560 --> 00:11:14,570
我们正在运行 OLAP 系统，该系统将

272
00:11:14,570 --> 00:11:16,250
同时将其上传为工作负载，

273
00:11:16,250 --> 00:11:20,780
但用于 OLAP 实验室 查询

274
00:11:20,780 --> 00:11:22,340
真的没有什么特别的

275
00:11:22,340 --> 00:11:25,100
或神奇的我们可以在每个数据库

276
00:11:25,100 --> 00:11:28,010
系统中做任何事情来使

277
00:11:28,010 --> 00:11:30,680
他们将要发生的磁盘访问速度更快

278
00:11:30,680 --> 00:11:31,550


279
00:11:31,550 --> 00:11:34,430


280
00:11:34,430 --> 00:11:38,030
大型 2000 次扫描或那些

281
00:11:38,030 --> 00:11:39,590
2000 次站在表中的大段上，

282
00:11:39,590 --> 00:11:41,120
或者他们甚至

283
00:11:41,120 --> 00:11:43,220
整个表现在可能只访问

284
00:11:43,220 --> 00:11:45,680
列的一个子集，列存储

285
00:11:45,680 --> 00:11:48,350
可以缓解

286
00:11:48,350 --> 00:11:49,730
引入数据的问题你不 实际上

287
00:11:49,730 --> 00:11:52,700
需要，我们可以这样做，但这

288
00:11:52,700 --> 00:11:54,560
没什么特别的，因为我们在内存中，

289
00:11:54,560 --> 00:11:56,090
因为蔑视数据库系统的磁盘

290
00:11:56,090 --> 00:11:58,610
仍然可以是列存储，并且

291
00:11:58,610 --> 00:12:01,700
仍然可以获得同样的好处，所以

292
00:12:01,700 --> 00:12:03,140
我再次尝试在这里指出的主要内容

293
00:12:03,140 --> 00:12:04,370
是我们真的什么都不

294
00:12:04,370 --> 00:12:06,830
要做，因为我们运行了一个内存

295
00:12:06,830 --> 00:12:10,910
系统来使磁盘 i/o 和 OLAP

296
00:12:10,910 --> 00:12:13,040
查询变得更好，我们真正能做的唯一一件事

297
00:12:13,040 --> 00:12:16,120
就是说我们

298
00:12:16,120 --> 00:12:18,710
在我们的表中有一个列，我们知道我们

299
00:12:18,710 --> 00:12:21,200
想要扫描得好，我们可以计算一个区域映射，

300
00:12:21,200 --> 00:12:22,940
因为它就像一个预先

301
00:12:22,940 --> 00:12:25,370
计算的列聚合聚合，比如

302
00:12:25,370 --> 00:12:26,780
最小最大你知道你

303
00:12:26,780 --> 00:12:28,190
将要运行的所有东西想要运行聚合的

304
00:12:28,190 --> 00:12:30,920
东西，并始终将其保存在内存

305
00:12:30,920 --> 00:12:35,300
中 列的其余部分是

306
00:12:35,300 --> 00:12:37,550
实际数据本身，我们将其推出磁盘

307
00:12:37,550 --> 00:12:40,220
，因此我们可以使用此 so 映射来尝试

308
00:12:40,220 --> 00:12:41,630
确定我们是否需要

309
00:12:41,630 --> 00:12:43,250
实际需要访问

310
00:12:43,250 --> 00:12:45,800
磁盘上的该列，具体取决于我们的查询 重新

311
00:12:45,800 --> 00:12:48,980
尝试做，这就是

312
00:12:48,980 --> 00:12:50,750
我们之前在讨论在数据系统中进行压缩时看到的数据跳过技术，

313
00:12:50,750 --> 00:12:53,420


314
00:12:53,420 --> 00:12:57,620
但磁盘学习系统

315
00:12:57,620 --> 00:12:59,480
仍然可以在地图上使用，

316
00:12:59,480 --> 00:13:00,800
没有什么特别的，因为我们在这里是在内存中

317
00:13:00,800 --> 00:13:02,720
，因此再次出于这个原因，

318
00:13:02,720 --> 00:13:04,220
我们可以做的不多 从一个好的实验室做的

319
00:13:04,220 --> 00:13:05,750
东西消失了

320
00:13:05,750 --> 00:13:06,980
我们会

321
00:13:06,980 --> 00:13:09,140
在我们的缓冲池中的 Discordian 系统中做的所有相同的优化，

322
00:13:09,140 --> 00:13:11,690
比如扫描共享或缓冲池旁路

323
00:13:11,690 --> 00:13:16,340
我们仍然可以在这里应用它们，所以

324
00:13:16,340 --> 00:13:17,720
我们将专注于

325
00:13:17,720 --> 00:13:19,460
LTP 的原因是 因为他们会有

326
00:13:19,460 --> 00:13:20,790
这个

327
00:13:20,790 --> 00:13:25,660
这是非常常见的模式，在数据库中

328
00:13:25,660 --> 00:13:27,999
会有热数据

329
00:13:27,999 --> 00:13:30,459
和冷数据的概念，这个

330
00:13:30,459 --> 00:13:32,139
想法是我们希望将热

331
00:13:32,139 --> 00:13:33,730
数据保存在内存中，因为那是我们要去的数据

332
00:13:33,730 --> 00:13:35,079


333
00:13:35,079 --> 00:13:37,480
更频繁地一遍又一遍地更新或访问，然后

334
00:13:37,480 --> 00:13:40,149
我们将冷数据推出磁盘

335
00:13:40,149 --> 00:13:43,230
，我们的想法是我们仍然有一个

336
00:13:43,230 --> 00:13:45,579
我们

337
00:13:45,579 --> 00:13:48,040
仍在内存中跟踪冷数据，以便我们知道它存在

338
00:13:48,040 --> 00:13:49,589
并且 我们不 有任何误报，

339
00:13:49,589 --> 00:13:51,939
你知道我们会查找一个元组，

340
00:13:51,939 --> 00:13:53,139
它在磁盘上，然后说哦，我们对它

341
00:13:53,139 --> 00:13:54,730
一无所知，就像我们要取消它一样

342
00:13:54,730 --> 00:13:56,589
，但我们只是不会支付

343
00:13:56,589 --> 00:13:59,139
内存中的存储损失 将

344
00:13:59,139 --> 00:14:03,040
所有冷数据保存在内存中，

345
00:14:03,040 --> 00:14:04,240
即使大部分时间我们都不

346
00:14:04,240 --> 00:14:08,019
需要它，所以我总是喜欢

347
00:14:08,019 --> 00:14:09,879
使用理解热数据与冷

348
00:14:09,879 --> 00:14:12,249
数据的例子就像 reddit 的

349
00:14:12,249 --> 00:14:14,319
黑客新闻一样，大多数人

350
00:14:14,319 --> 00:14:17,110
都会发布 对最近 24 小时或许多天之内在 reddit 上发布的最新文章发表的评论，

351
00:14:17,110 --> 00:14:18,430


352
00:14:18,430 --> 00:14:20,920


353
00:14:20,920 --> 00:14:23,379
但很少有人会回去

354
00:14:23,379 --> 00:14:26,139
发表评论，对六个月前

355
00:14:26,139 --> 00:14:28,800
从未上传或发布过的文章发表评论

356
00:14:28,800 --> 00:14:31,569
对，实际上我

357
00:14:31,569 --> 00:14:33,129
不知道 甚至不要认为阅读甚至可以让您

358
00:14:33,129 --> 00:14:37,269
对旧文章发表评论，因此

359
00:14:37,269 --> 00:14:38,709
我们希望将最近的帖子

360
00:14:38,709 --> 00:14:39,519
保留在内存中的想法，因为这些是

361
00:14:39,519 --> 00:14:41,410
每个人都在阅读的内容

362
00:14:41,410 --> 00:14:43,240
并对旧内容进行更新，

363
00:14:43,240 --> 00:14:44,920
如果有的话，您会掏出磁盘 有人来

364
00:14:44,920 --> 00:14:47,470
来去去寻找它，我们会

365
00:14:47,470 --> 00:14:49,029
从磁盘中取出它并把它带到内存中并将

366
00:14:49,029 --> 00:14:51,309
其提供给他们，但大多数时候我们

367
00:14:51,309 --> 00:14:53,290
不需要它，然后

368
00:14:53,290 --> 00:14:55,449
可能有人会

369
00:14:55,449 --> 00:14:59,800
在感冒中阅读同一篇文章 文章

370
00:14:59,800 --> 00:15:02,559
在它被带回后立即

371
00:15:02,559 --> 00:15:05,920
从磁盘中取出它实际上非常低，因此

372
00:15:05,920 --> 00:15:07,420
我们可以继续将其推

373
00:15:07,420 --> 00:15:09,040
回磁盘，稍后我没有节省

374
00:15:09,040 --> 00:15:11,679
空间，所以再次像我

375
00:15:11,679 --> 00:15:14,490
在 reddit 中所说的那样一些应用程序实际上在那里

376
00:15:14,490 --> 00:15:17,040
阻止你在文章中发帖

377
00:15:17,040 --> 00:15:20,379
，因为你已经到了一定的

378
00:15:20,379 --> 00:15:22,899
年龄 机制实际上是

379
00:15:22,899 --> 00:15:24,699
应用程序所做的

380
00:15:24,699 --> 00:15:26,259
事情 这不是数据扩展器系统

381
00:15:26,259 --> 00:15:28,120
强制执行的事情 据他们所知 没有人 没有

382
00:15:28,120 --> 00:15:29,529
数据库系统实际上说好的

383
00:15:29,529 --> 00:15:33,220
这些东西是旧的 你知道我们不会让

384
00:15:33,220 --> 00:15:34,370
你修改，因为

385
00:15:34,370 --> 00:15:37,580
它不知道你知道你不是

386
00:15:37,580 --> 00:15:40,460
你插入到一个表中，就像

387
00:15:40,460 --> 00:15:41,540


388
00:15:41,540 --> 00:15:42,589
当文章

389
00:15:42,589 --> 00:15:43,760
秘书 p 所以它不知道你

390
00:15:43,760 --> 00:15:46,610
不能这样做，据我所知没有系统

391
00:15:46,610 --> 00:15:49,160
实际上会这样做所以

392
00:15:49,160 --> 00:15:50,720
我们今天尝试做的目的是在

393
00:15:50,720 --> 00:15:52,880
这里我们需要一种机制来

394
00:15:52,880 --> 00:15:55,250
允许我们 确定我们有这些

395
00:15:55,250 --> 00:15:58,400
冷数据 它在哪里 将

396
00:15:58,400 --> 00:16:00,020
它从磁盘中推出 如果再也不需要

397
00:16:00,020 --> 00:16:03,140
它 Brigham 以另一种方式返回 从

398
00:16:03,140 --> 00:16:04,460
概念上考虑这

399
00:16:04,460 --> 00:16:09,290
一点 我们正在尝试做的是推送

400
00:16:09,290 --> 00:16:14,060
冷数据原子 磁盘上的内存

401
00:16:14,060 --> 00:16:16,580
与磁盘或 nyun 系统形成对比，在磁盘或 nyun 系统中，

402
00:16:16,580 --> 00:16:20,089
您从磁盘中提取热数据并将其

403
00:16:20,089 --> 00:16:23,330
带入内存，因此这似乎是一种

404
00:16:23,330 --> 00:16:25,250
语义差异，希望随着我们

405
00:16:25,250 --> 00:16:26,630
继续这样做更有意义，但

406
00:16:26,630 --> 00:16:28,190
就像这个系统正在

407
00:16:28,190 --> 00:16:30,650
架构为冷数据被

408
00:16:30,650 --> 00:16:32,870
移出到磁盘，而在不同的

409
00:16:32,870 --> 00:16:37,100
系统中，热数据被拉入，所以

410
00:16:37,100 --> 00:16:38,390
让我们看一个高级示例，

411
00:16:38,390 --> 00:16:41,180
现在我们有了一个数据库

412
00:16:41,180 --> 00:16:43,370
，可以支持将数据写入

413
00:16:43,370 --> 00:16:45,620
冷数据 存储这是一些

414
00:16:45,620 --> 00:16:47,480
旋转 d  isk 硬盘驱动器或 NAND 闪存

415
00:16:47,480 --> 00:16:49,700
或 EBS 无论你想要什么

416
00:16:49,700 --> 00:16:52,700
对我们的目的现在都无关紧要，然后在

417
00:16:52,700 --> 00:16:54,100
内存中我们仍然有我们的内存索引

418
00:16:54,100 --> 00:16:56,570
，然后我们现在有我们的内存表

419
00:16:56,570 --> 00:16:58,430
堆，假设一切都是固定的

420
00:16:58,430 --> 00:17:02,029
固定大小等等 存在于

421
00:17:02,029 --> 00:17:05,780
这里的这个空间中，所以现在我们有一种

422
00:17:05,780 --> 00:17:09,020
机制来查看我们的元组并

423
00:17:09,020 --> 00:17:11,540
确定哪些是冷的 我们有一种

424
00:17:11,540 --> 00:17:13,400
方法可以确定这三个

425
00:17:13,400 --> 00:17:17,569
元组最近没有被

426
00:17:17,569 --> 00:17:19,819
访问 将来不太可能

427
00:17:19,819 --> 00:17:21,800
再次访问

428
00:17:21,800 --> 00:17:23,599
我们究竟如何做，我们将在稍后介绍，但

429
00:17:23,599 --> 00:17:24,949
无论出于何种原因，我们认为这三个

430
00:17:24,949 --> 00:17:27,949
是我们要被驱逐的候选人，所以

431
00:17:27,949 --> 00:17:29,120
我们要继续做的就是我们

432
00:17:29,120 --> 00:17:31,000
要去 要将它们从我们的表堆中取出，

433
00:17:31,000 --> 00:17:34,610
将它们组合成一个页面或一个块，

434
00:17:34,610 --> 00:17:36,890
然后我们将其写出到磁盘，这样

435
00:17:36,890 --> 00:17:38,780
现在这将是我们的 victor 元组块，有

436
00:17:38,780 --> 00:17:40,100
一些标题在说这里是

437
00:17:40,100 --> 00:17:41,780
你所知道的这里是什么，然后

438
00:17:41,780 --> 00:17:44,330
我们有我们的 元组数据和这个

439
00:17:44,330 --> 00:17:46,520
屁股 ume 我们被组织为一个行

440
00:17:46,520 --> 00:17:47,620
存储

441
00:17:47,620 --> 00:17:49,030
存储，本质上看起来是一样的，

442
00:17:49,030 --> 00:17:51,210
因为如果你做一个 pax 组织的

443
00:17:51,210 --> 00:17:53,710
块，它可以被布局并

444
00:17:53,710 --> 00:17:55,059
在页面内的一个公共存储中，但

445
00:17:55,059 --> 00:17:56,950
所有值或所有

446
00:17:56,950 --> 00:17:59,320
属性 可以在这个块中找到给定的元组

447
00:17:59,320 --> 00:18:01,990
，所以现在我们必须处理的第一个问题

448
00:18:01,990 --> 00:18:04,360
是我们如何

449
00:18:04,360 --> 00:18:07,090
处理我们刚刚在表堆中制造的孔

450
00:18:07,090 --> 00:18:09,820


451
00:18:09,820 --> 00:18:12,130


452
00:18:12,130 --> 00:18:14,050
实际上你知道我们什么时候

453
00:18:14,050 --> 00:18:15,910
真正把东西放在那里因为

454
00:18:15,910 --> 00:18:19,900
问题是现在的索引是因为

455
00:18:19,900 --> 00:18:22,750
现在所有的东西都在我们的数据库中你

456
00:18:22,750 --> 00:18:24,550
知道你有 64 位指针指向

457
00:18:24,550 --> 00:18:26,110
另外两个位置作为内存来

458
00:18:26,110 --> 00:18:28,900
识别元组它不是 您知道页面

459
00:18:28,900 --> 00:18:30,910
ID 和偏移量，就像在槽

460
00:18:30,910 --> 00:18:32,470
号中一样，就像在丢弃

461
00:18:32,470 --> 00:18:34,570
系统中一样，这些指针现在

462
00:18:34,570 --> 00:18:35,920
指向仍在索引中的仍然

463
00:18:35,920 --> 00:18:38,080
指向这些空槽，所以现在如果

464
00:18:38,080 --> 00:18:39,550
我可以进行查找并尝试 找到这个

465
00:18:39,550 --> 00:18:42,550
元组 那个曾经在这里我

466
00:18:42,550 --> 00:18:45,190
要降落在你知道现在看看一些

467
00:18:45,190 --> 00:18:47,350
空的空间因为其他人

468
00:18:47,350 --> 00:18:49,000
现在可能 - 是的我可以

469
00:18:49,000 --> 00:18:52,240
在这个空间再放两个男孩但是现在

470
00:18:52,240 --> 00:18:53,320
让我们说这个查询出现了什么

471
00:18:53,320 --> 00:18:55,000
这个查询 现在想要

472
00:18:55,000 --> 00:18:57,070
引用我们刚刚驱逐的元组之一，

473
00:18:57,070 --> 00:18:59,650
所以这是访问元组 1，但

474
00:18:59,650 --> 00:19:02,200
现在管 1 在磁盘上的某个地方，所以

475
00:19:02,200 --> 00:19:03,970
我们必须处理的问题

476
00:19:03,970 --> 00:19:06,070
是我们如何实际找到它

477
00:19:06,070 --> 00:19:07,480
我们实际上如何 将能够

478
00:19:07,480 --> 00:19:10,450
识别出 Oh tuple 0 1 它不再在

479
00:19:10,450 --> 00:19:11,170
内存中

480
00:19:11,170 --> 00:19:15,429
了它在磁盘上然后说我们

481
00:19:15,429 --> 00:19:17,440
如果我们真的可以识别它

482
00:19:17,440 --> 00:19:20,050
在磁盘上我们需要将它带回

483
00:19:20,050 --> 00:19:22,660
内存现在问题是做什么

484
00:19:22,660 --> 00:19:26,400
我们实际上是这样做的，因为正如我所说

485
00:19:26,400 --> 00:19:29,530
，我们磁盘上的冷数据存储是

486
00:19:29,530 --> 00:19:32,260
面向块的，所以我不能只是去抓取 2

487
00:19:32,260 --> 00:19:34,300
+ 0 1 并只是复制

488
00:19:34,300 --> 00:19:36,520
该元组的字节并将其

489
00:19:36,520 --> 00:19:38,830
放入我的表堆中我 得把

490
00:19:38,830 --> 00:19:41,080
整个街区都带进来，所以现在我要带

491
00:19:41,080 --> 00:19:44,140
在元组 1 中还有 3 和 4 但我没有

492
00:19:44,140 --> 00:19:47,950
要求 3 和 4 我只想要一个所以我

493
00:19:47,950 --> 00:19:50,500
实际上做什么我将所有三个元组合并

494
00:19:50,500 --> 00:19:52,929
回来我只是伤害合并一个元组

495
00:19:52,929 --> 00:19:54,880
然后我要留下一个

496
00:19:54,880 --> 00:19:57,250


497
00:19:57,250 --> 00:19:59,110
所以这些是我们今天试图回答的问题，

498
00:19:59,110 --> 00:20:00,820
我们实际上想要如何

499
00:20:00,820 --> 00:20:05,800
协调我们所有人，所以我们

500
00:20:05,800 --> 00:20:07,930
必须处理的问题如下，

501
00:20:07,930 --> 00:20:10,720
我们再次关注 OTP 系统

502
00:20:10,720 --> 00:20:13,240
，其中 我们假设实际上

503
00:20:13,240 --> 00:20:14,680
您知道我们的查询是好的事务，

504
00:20:14,680 --> 00:20:17,380
或者可以尝试实际上不仅访问

505
00:20:17,380 --> 00:20:21,190
而且更新或修改池，

506
00:20:21,190 --> 00:20:24,180
这些池是已推送到磁盘的数据，

507
00:20:24,180 --> 00:20:26,110
因此我们必须处理的第一件事

508
00:20:26,110 --> 00:20:30,160
是运行时 操作

509
00:20:30,160 --> 00:20:32,230
是我们在

510
00:20:32,230 --> 00:20:33,790
事务性视频和运行查询

511
00:20:33,790 --> 00:20:36,100
和事务时实际要做的事情，以

512
00:20:36,100 --> 00:20:39,460
跟踪数据是热还是冷，就像

513
00:20:39,460 --> 00:20:41,890
必须跟踪它并确定何时

514
00:20:41,890 --> 00:20:43,510
该驱逐或我们想要一些

515
00:20:43,510 --> 00:20:47,490
元组的数据 或者哪些块

516
00:20:47,490 --> 00:20:49,450
没有被访问 过一会儿，

517
00:20:49,450 --> 00:20:50,470
因此我们想继续并解决

518
00:20:50,470 --> 00:20:53,410
它们，下一个是驱逐策略，

519
00:20:53,410 --> 00:20:55,270
这是当数据库系统

520
00:20:55,270 --> 00:20:57,040
认识到它的

521
00:20:57,040 --> 00:20:59,380
空间不足或内存不足时，所以说

522
00:20:59,380 --> 00:21:01,960
让我们继续，让 Vic 一些数据

523
00:21:01,960 --> 00:21:04,480
第一个问题是它何时应该

524
00:21:04,480 --> 00:21:08,410
真正触发驱逐，下一个问题

525
00:21:08,410 --> 00:21:09,820
是我们将跟踪哪些元数据

526
00:21:09,820 --> 00:21:13,180
以记录

527
00:21:13,180 --> 00:21:15,730
过去内存中的数据，但它

528
00:21:15,730 --> 00:21:17,500
现在在磁盘上，这里是如何

529
00:21:17,500 --> 00:21:21,430
找到 它位于磁盘上的位置，我们

530
00:21:21,430 --> 00:21:23,320
需要这样做，因为我们需要避免

531
00:21:23,320 --> 00:21:24,790
误报，我们不想

532
00:21:24,790 --> 00:21:28,950
写我们只回到这里并将元组 1

533
00:21:28,950 --> 00:21:32,380
写到磁盘然后这个查询出现并

534
00:21:32,380 --> 00:21:34,630
说哦我想拉一个但是 我们只

535
00:21:34,630 --> 00:21:37,660
在此处咨询

536
00:21:37,660 --> 00:21:38,710
餐桌热工的这一部分，它没有人们

537
00:21:38,710 --> 00:21:39,970
想要更多，所以它会回来

538
00:21:39,970 --> 00:21:42,040
说我对

539
00:21:42,040 --> 00:21:43,990
像你这样的元组 0 1 一无所知，你所要求的它

540
00:21:43,990 --> 00:21:45,610
不存在，并且 因此这件事

541
00:21:45,610 --> 00:21:48,340
会返回不正确的答案 o 我们需要

542
00:21:48,340 --> 00:21:51,880
一种方法来识别内存

543
00:21:51,880 --> 00:21:54,340
中曾经有一个元组 0 1 在

544
00:21:54,340 --> 00:21:56,110
这里，这是这里的

545
00:21:56,110 --> 00:21:57,070
信息，您知道在哪里

546
00:21:57,070 --> 00:21:59,530
可以在磁盘上找到它，因此这是元数据，然后

547
00:21:59,530 --> 00:22:01,530
在此处进行跟踪

548
00:22:01,530 --> 00:22:05,890
现在，当我们

549
00:22:05,890 --> 00:22:07,360
意识到我们确实需要磁盘上的数据时

550
00:22:07,360 --> 00:22:10,060
，问题是我们应该实际引入多少数据，我们

551
00:22:10,060 --> 00:22:12,940
实际上对请求该数据

552
00:22:12,940 --> 00:22:14,690
的查询或事务

553
00:22:14,690 --> 00:22:18,110
做了什么，以及我们

554
00:22:18,110 --> 00:22:20,090
实际上将数据放在哪里 他们

555
00:22:20,090 --> 00:22:23,180
要求像表堆或私有缓冲区在内存中的位置一样，

556
00:22:23,180 --> 00:22:25,780
我

557
00:22:25,780 --> 00:22:28,190
将涵盖所有这些做了这些

558
00:22:28,190 --> 00:22:30,470
不同的设计决策，这些都

559
00:22:30,470 --> 00:22:34,010
来自我们在 2016 年

560
00:22:34,010 --> 00:22:37,670
与我的一位博士生一起撰写的论文，我们

561
00:22:37,670 --> 00:22:39,350
正在寻找 在这个想法中，

562
00:22:39,350 --> 00:22:42,020
你实际上如何

563
00:22:42,020 --> 00:22:45,500
在内存数据库系统中支持更大的内存数据库，所以

564
00:22:45,500 --> 00:22:47,210
我要说的是，虽然这是基于

565
00:22:47,210 --> 00:22:48,650
我在研究生院帮助建立的一个系统，

566
00:22:48,650 --> 00:22:50,810
称为商店，然后

567
00:22:50,810 --> 00:22:55,540
商业化我 n 2008 2009 作为 volte B

568
00:22:55,540 --> 00:22:57,830
我们将在这里讨论的大多数机制

569
00:22:57,830 --> 00:23:01,340
都将是面向元组的，比如

570
00:23:01,340 --> 00:23:03,620
细粒度逐出和

571
00:23:03,620 --> 00:23:04,990
对单个元组的细粒度识别，

572
00:23:04,990 --> 00:23:08,360
但是我

573
00:23:08,360 --> 00:23:11,060
让你们阅读了这篇文章，其中有很多精益商店

574
00:23:11,060 --> 00:23:13,490
在这篇特别的论文之后，这里是

575
00:23:13,490 --> 00:23:17,720
在页面级别上做的，所以如果你试图在页面级别上做，

576
00:23:17,720 --> 00:23:18,710
我们将在这里讨论的一些

577
00:23:18,710 --> 00:23:20,300
事情没有意义，

578
00:23:20,300 --> 00:23:22,100
因为它们有

579
00:23:22,100 --> 00:23:23,780
一种更粗的粒度 查看

580
00:23:23,780 --> 00:23:25,940
哪些数据是热的和冷的，以及他们如何在团队被驱逐时

581
00:23:25,940 --> 00:23:27,170
实际跟踪您的元数据，

582
00:23:27,170 --> 00:23:29,690
但

583
00:23:29,690 --> 00:23:31,790
重要的是要了解您了解

584
00:23:31,790 --> 00:23:33,350
某种细粒度的方法，然后您将

585
00:23:33,350 --> 00:23:35,450
希望更好地理解为什么

586
00:23:35,450 --> 00:23:37,850
导致我们 想法我实际上认为

587
00:23:37,850 --> 00:23:41,180
真的很好 好吧 计划

588
00:23:41,180 --> 00:23:42,710
你要做的第一件事是如何

589
00:23:42,710 --> 00:23:44,990
识别我们数据库中调用的

590
00:23:44,990 --> 00:23:48,860
数据 所以第一选择是

591
00:23:48,860 --> 00:23:50,590
做我称之为在线识别的

592
00:23:50,590 --> 00:23:53,780
意思，因为数据库系统是

593
00:23:53,780 --> 00:23:55,310
exe 切割事务或执行

594
00:23:55,310 --> 00:23:58,100
查询，我们会跟踪

595
00:23:58,100 --> 00:23:59,810
他们正在访问哪些元组，他们正在访问哪些数据

596
00:23:59,810 --> 00:24:03,530
，然后我们必须

597
00:24:03,530 --> 00:24:07,250
直接在

598
00:24:07,250 --> 00:24:09,260
页面的元组中维护一些元数据，

599
00:24:09,260 --> 00:24:12,110
然后在我们的查询

600
00:24:12,110 --> 00:24:14,120
访问它们时更新这些元数据 你

601
00:24:14,120 --> 00:24:16,160
想把它嵌入元组本身的

602
00:24:16,160 --> 00:24:17,900
原因是因为你不想去然后

603
00:24:17,900 --> 00:24:21,740
咨询一个丑陋的数据结构说嘿

604
00:24:21,740 --> 00:24:24,200
，

605
00:24:24,200 --> 00:24:25,790
如果我把元组输入进去，我已经更新了这个元组 我的

606
00:24:25,790 --> 00:24:27,320
跟踪数据然后向上，

607
00:24:27,320 --> 00:24:29,780
因为在您的痛苦中

608
00:24:29,780 --> 00:24:31,550
，拥有额外的额外数据

609
00:24:31,550 --> 00:24:33,140
结构的存储损失，然后您还需要支付

610
00:24:33,140 --> 00:24:35,180


611
00:24:35,180 --> 00:24:37,580
每次访问小管时都必须更新它的计算开销，

612
00:24:37,580 --> 00:24:42,740
所以当我们这样做时 H

613
00:24:42,740 --> 00:24:46,580
存储我们实际上将存储

614
00:24:46,580 --> 00:24:51,410
一个元组的 64 位指针，指向下一个

615
00:24:51,410 --> 00:24:52,850
最近访问的元组，

616
00:24:52,850 --> 00:24:55,430
我们实际上是在维护

617
00:24:55,430 --> 00:24:58,760
所有单个元组的 LRU 链，因此

618
00:24:58,760 --> 00:25:02,930
每个池 64 位并不理想

619
00:25:02,930 --> 00:25:05,120
所以元组非常大，如果它有

620
00:25:05,120 --> 00:25:07,130
很多属性，那么开销

621
00:25:07,130 --> 00:25:08,210
有点小，但如果它只有

622
00:25:08,210 --> 00:25:11,180
两个属性，比如两个 32 位指针，

623
00:25:11,180 --> 00:25:14,090
我们抱歉的 32 位整数有它的

624
00:25:14,090 --> 00:25:17,090
属性，那么额外的 64  -bit

625
00:25:17,090 --> 00:25:18,770
用于跟踪元数据的指针

626
00:25:18,770 --> 00:25:20,990
它本质上是

627
00:25:20,990 --> 00:25:22,700
将元组的大小加倍只是为了跟踪

628
00:25:22,700 --> 00:25:27,140
它是否热 第二种方法

629
00:25:27,140 --> 00:25:29,300
是离线，这

630
00:25:29,300 --> 00:25:32,300
意味着数据库系统将

631
00:25:32,300 --> 00:25:36,080
像输入一样进行记录 -

632
00:25:36,080 --> 00:25:37,700
查询和

633
00:25:37,700 --> 00:25:39,020
事务在运行时进行的所有天使访问的内存日志，

634
00:25:39,020 --> 00:25:41,270
但这只是

635
00:25:41,270 --> 00:25:43,160
在私有缓冲区中更新到

636
00:25:43,160 --> 00:25:44,900
进行访问的线程，因此尽管

637
00:25:44,900 --> 00:25:46,340


638
00:25:46,340 --> 00:25:48,710
我们对全局数据结构没有争用 没有像我们在这里看到的那样为

639
00:25:48,710 --> 00:25:52,070
每个元组存储这个元数据和支付

640
00:25:52,070 --> 00:25:53,720
惩罚，所以这

641
00:25:53,720 --> 00:25:56,480
只是一些

642
00:25:56,480 --> 00:25:59,450
我们正在做的一些额外的跟踪，在运行

643
00:25:59,450 --> 00:26:03,460
时作为访问数据的查询开销很低，

644
00:26:03,460 --> 00:26:07,220
但是然后 现在会周期性地有一个

645
00:26:07,220 --> 00:26:08,810
后台线程从不同的线程中获取并

646
00:26:08,810 --> 00:26:10,970
查看所有这些日志信息

647
00:26:10,970 --> 00:26:12,740
，然后计算

648
00:26:12,740 --> 00:26:15,920
一些直方图来确定

649
00:26:15,920 --> 00:26:18,410
单个元组的访问频率，

650
00:26:18,410 --> 00:26:21,800
因此这个是协作的，因为

651
00:26:21,800 --> 00:26:23,120
所有线程都是 帮助

652
00:26:23,120 --> 00:26:26,840
维护元数据，这是一个

653
00:26:26,840 --> 00:26:28,670
单独的后台线程，可以

654
00:26:28,670 --> 00:26:30,200
继续将这些信息

655
00:26:30,200 --> 00:26:34,070
组合在一起，所以接下来

656
00:26:34,070 --> 00:26:37,160
要做的基本上是如何识别

657
00:26:37,160 --> 00:26:38,860
数据库系统

658
00:26:38,860 --> 00:26:41,830
何时内存不足，所以一个简单的

659
00:26:41,830 --> 00:26:43,900
方法是 只是有一个管理员

660
00:26:43,900 --> 00:26:46,360
定义的阈值，说明当我的

661
00:26:46,360 --> 00:26:49,330
数据库系统的总内存使用

662
00:26:49,330 --> 00:26:54,190


663
00:26:54,190 --> 00:26:56,230
量达到分配给我的数据库系统的内存量的 80% 或 90% 左右

664
00:26:56,230 --> 00:26:59,049
时，我将启动我的

665
00:26:59,049 --> 00:27:02,890
驱逐我的小说政策然后去

666
00:27:02,890 --> 00:27:04,900


667
00:27:04,900 --> 00:27:07,960
在这种情况下，数据中心

668
00:27:07,960 --> 00:27:10,150
负责删除这些数据，

669
00:27:10,150 --> 00:27:12,400
因为没有其他东西可以 可以

670
00:27:12,400 --> 00:27:14,110
控制这是我们管理我们的

671
00:27:14,110 --> 00:27:15,970
内存因此我们必须这样做

672
00:27:15,970 --> 00:27:19,350
我们不能依赖

673
00:27:19,350 --> 00:27:21,580
通常在数据库系统中的操作系统我的意思是对于

674
00:27:21,580 --> 00:27:22,660
日常肉块，无论它

675
00:27:22,660 --> 00:27:25,660
是否在内存

676
00:27:25,660 --> 00:27:27,790
中必须告诉管理员数据系统 一个人

677
00:27:27,790 --> 00:27:29,650
允许他们再次使用多少内存，

678
00:27:29,650 --> 00:27:31,510
无论是磁盘警告系统的缓冲池大小

679
00:27:31,510 --> 00:27:33,820
还是

680
00:27:33,820 --> 00:27:36,160
内存数据库系统的堆的内存大小

681
00:27:36,160 --> 00:27:37,929
今天再次发送

682
00:27:37,929 --> 00:27:39,040
有人必须告诉我们多少内存

683
00:27:39,040 --> 00:27:41,230
被允许使用，所以我们 DS 然后设置一个

684
00:27:41,230 --> 00:27:43,540
阈值，并说当我忘记

685
00:27:43,540 --> 00:27:45,730
了该阈值的 85% 总上限

686
00:27:45,730 --> 00:27:48,940
然后我开始一个受害者 另一种方法

687
00:27:48,940 --> 00:27:51,669
是按需执行此操作

688
00:27:51,669 --> 00:27:54,850
，如果数据库系统识别

689
00:27:54,850 --> 00:27:56,410
出 它没有更多的内存来

690
00:27:56,410 --> 00:27:58,540
从它需要的磁盘中引入新的数据，

691
00:27:58,540 --> 00:28:00,640
然后运行它的

692
00:28:00,640 --> 00:28:03,070
替换策略，我将在稍后讨论

693
00:28:03,070 --> 00:28:05,860
，但我认为它是 LRU 来

694
00:28:05,860 --> 00:28:08,020
确定哪些页面不再

695
00:28:08,020 --> 00:28:11,410
需要 或者  将来不太可能使用

696
00:28:11,410 --> 00:28:13,600
，我们可以继续将

697
00:28:13,600 --> 00:28:15,580
它们从磁盘中取出，然后

698
00:28:15,580 --> 00:28:17,590
为我们想要引入的新数据回收该空间

699
00:28:17,590 --> 00:28:20,860
，这样您就可以使用 LRU

700
00:28:20,860 --> 00:28:23,650
或时钟来近似 LRU 精益存储

701
00:28:23,650 --> 00:28:26,799
使用 时钟的近似值，

702
00:28:26,799 --> 00:28:28,330
他们称之为第二次机会，我们将

703
00:28:28,330 --> 00:28:32,830
在一秒钟内看到它是什么样子，

704
00:28:32,830 --> 00:28:37,240
所以现在假设我们有一种方法

705
00:28:37,240 --> 00:28:39,520
可以触发驱逐以将数据

706
00:28:39,520 --> 00:28:41,440
移出磁盘，我们有一种方法来识别

707
00:28:41,440 --> 00:28:43,780
我们的感冒 数据是，我们现在需要

708
00:28:43,780 --> 00:28:45,820
移到磁盘上 现在我们

709
00:28:45,820 --> 00:28:47,530
必须处理的问题是当它被

710
00:28:47,530 --> 00:28:49,030
写入磁盘时我们仍然保持什么

711
00:28:49,030 --> 00:28:49,920


712
00:28:49,920 --> 00:28:52,380
并跟踪这些数据实际上

713
00:28:52,380 --> 00:28:54,180
曾经有两个胎盘

714
00:28:54,180 --> 00:28:55,950
曾经在这里过时 在内存中，但如果

715
00:28:55,950 --> 00:28:58,100
不再是，这里是去哪里找到它

716
00:28:58,100 --> 00:29:00,470
所以第一种方法是使用

717
00:29:00,470 --> 00:29:03,180
墓碑，这就是我们将

718
00:29:03,180 --> 00:29:05,370
有一个标记或

719
00:29:05,370 --> 00:29:07,920
我们在表中拥有的特殊类型的元组的地方，上面

720
00:29:07,920 --> 00:29:10,740
写着这个元组你是 在

721
00:29:10,740 --> 00:29:12,750
这个地址寻找不存在但是

722
00:29:12,750 --> 00:29:14,490
这里是可以找到它的地方 这里是块 ID

723
00:29:14,490 --> 00:29:17,010
和所有设置在该块中以

724
00:29:17,010 --> 00:29:19,140
获取您正在寻找的数据以及任何

725
00:29:19,140 --> 00:29:21,180
时候您看到您知道您是否跟随

726
00:29:21,180 --> 00:29:23,190
指针进行扫描并遇到

727
00:29:23,190 --> 00:29:25,530
此墓碑指针或墓碑 一个

728
00:29:25,530 --> 00:29:28,350
元组，你可以说好吧，

729
00:29:28,350 --> 00:29:29,850
让我去和冷数据存储层谈谈，

730
00:29:29,850 --> 00:29:32,460
然后说去获取我正在寻找的数据，

731
00:29:32,460 --> 00:29:36,510
所以如果你

732
00:29:36,510 --> 00:29:38,610
向我们展示了一个磁盘的 Victor 元组并且你

733
00:29:38,610 --> 00:29:40,320
用墓碑替换了你

734
00:29:40,320 --> 00:29:43,320
现在必须为该表的任何或所有

735
00:29:43,320 --> 00:29:44,760
索引更新索引，该索引

736
00:29:44,760 --> 00:29:47,100
指向旧的被驱逐的元组，现在

737
00:29:47,100 --> 00:29:49,530
指向墓碑元组以这种方式写入

738
00:29:49,530 --> 00:29:51,630
没有漏报您的数据

739
00:29:51,630 --> 00:29:53,810
始终在那里您的数据始终可以

740
00:29:53,810 --> 00:29:58,080
识别下一个 方法是使用

741
00:29:58,080 --> 00:30:01,910
布隆过滤器，这是您

742
00:30:01,910 --> 00:30:05,670
将所有数据从磁盘 Victo 中

743
00:30:05,670 --> 00:30:07,830
清除磁盘上的元组的地方，而

744
00:30:07,830 --> 00:30:09,270
不是维护墓碑

745
00:30:09,270 --> 00:30:11,550
/ - 您只拥有

746
00:30:11,550 --> 00:30:12,660
此布隆过滤器的格言

747
00:30:12,660 --> 00:30:15,090
木偶是一个近似数据

748
00:30:15,090 --> 00:30:18,030
一个集合成员的结构，表示

749
00:30:18,030 --> 00:30:21,000
是否可能存在它们为

750
00:30:21,000 --> 00:30:23,580
冷数据存储中的给定键进行元组化

751
00:30:23,580 --> 00:30:27,420
，所以如果我正在寻找

752
00:30:27,420 --> 00:30:30,300
表上的特定键，我会

753
00:30:30,300 --> 00:30:33,210
检查真正的 Mme 索引，如果 它说在那里

754
00:30:33,210 --> 00:30:35,220
然后我会有一个

755
00:30:35,220 --> 00:30:38,700
指向真正元组的指针所以我在内存中完成如果

756
00:30:38,700 --> 00:30:40,530
它说不存在那么我去检查这个

757
00:30:40,530 --> 00:30:43,830
布隆过滤器如果它说它不

758
00:30:43,830 --> 00:30:45,660
存在我知道根本不存在

759
00:30:45,660 --> 00:30:47,460
因为布隆过滤器永远不会给

760
00:30:47,460 --> 00:30:49,410
你错误的傀儡

761
00:30:49,410 --> 00:30:51,780
假阴性如果它确实

762
00:30:51,780 --> 00:30:53,370
说密钥存在并且它是冷

763
00:30:53,370 --> 00:30:55,800
数据存储然后我去获取它在

764
00:30:55,800 --> 00:30:59,400
我带入内存的磁盘索引上

765
00:30:59,400 --> 00:31:01,500
然后我找到真正的 两者在磁盘

766
00:31:01,500 --> 00:31:03,500
上的位置，但我正在

767
00:31:03,500 --> 00:31:06,320
再次寻找我将在下一张幻灯片中解释如何播放这两个

768
00:31:06,320 --> 00:31:07,210


769
00:31:07,210 --> 00:31:10,310
其他两种方法是

770
00:31:10,310 --> 00:31:12,770
执行数据库系统管理内存或

771
00:31:12,770 --> 00:31:14,980
操作系统管理内存或虚拟内存

772
00:31:14,980 --> 00:31:18,200
，对于这个 数据库

773
00:31:18,200 --> 00:31:20,390
系统将保持

774
00:31:20,390 --> 00:31:23,630
在页面级别的垫上跟踪页面是否

775
00:31:23,630 --> 00:31:25,280
实际存在于内存中

776
00:31:25,280 --> 00:31:27,560
或块级别相同类型的东西，所以我

777
00:31:27,560 --> 00:31:30,830
无法告诉您图像或元组是否

778
00:31:30,830 --> 00:31:34,670
存在但如果我知道它会存在

779
00:31:34,670 --> 00:31:36,170
于 这个块和那个块已经

780
00:31:36,170 --> 00:31:38,060
写入磁盘然后我知道两个

781
00:31:38,060 --> 00:31:42,140
血液 i1 在磁盘上，所以对于操作系统虚拟

782
00:31:42,140 --> 00:31:43,310
内存，它会以相同的方式工作

783
00:31:43,310 --> 00:31:45,110
，只是在这种情况下，操作系统将

784
00:31:45,110 --> 00:31:47,150
跟踪内存中的内容你知道

785
00:31:47,150 --> 00:31:48,680
吗 内存与磁盘上的内容，

786
00:31:48,680 --> 00:31:50,290
这是数据系统将跟踪它，

787
00:31:50,290 --> 00:31:52,760
所以我们将专注于这两个，

788
00:31:52,760 --> 00:31:56,660
因为这些将是你知道的，

789
00:31:56,660 --> 00:31:58,430
就像

790
00:31:58,430 --> 00:31:59,840
我们已经讨论过的细粒度到自言自语的方法一样，

791
00:31:59,840 --> 00:32:02,420
我们将讨论 如何

792
00:32:02,420 --> 00:32:05,810
用最少或和 Umbra 来做这件事，然后我们将

793
00:32:05,810 --> 00:32:08,750
看到 epfl 的一项技术，该技术执行

794
00:32:08,750 --> 00:32:13,160
此操作系统管理的内存，我正在使用

795
00:32:13,160 --> 00:32:15,110
球 TB 和更多的幻灯片，因此

796
00:32:15,110 --> 00:32:16,910
恢复所有这些，但我要先

797
00:32:16,910 --> 00:32:19,430


798
00:32:19,430 --> 00:32:23,540
在这里讨论并向您展示这两个的明确示例 好吧，这又

799
00:32:23,540 --> 00:32:25,130
是我们

800
00:32:25,130 --> 00:32:26,720
在内存表堆和冷数据

801
00:32:26,720 --> 00:32:30,080
存储中的 Mme 索引之前进行的相同设置，所以再次假设我们有一些

802
00:32:30,080 --> 00:32:32,510
方法可以查看我们的元组是如何被

803
00:32:32,510 --> 00:32:34,910
访问的，我们可以用计算机直方图

804
00:32:34,910 --> 00:32:37,010
表示这是每个的访问频率

805
00:32:37,010 --> 00:32:39,830
单个单独的元组我们可以使用

806
00:32:39,830 --> 00:32:41,390
此信息来确定

807
00:32:41,390 --> 00:32:44,000
这里的这三个元组

808
00:32:44,000 --> 00:32:45,380
被再次访问的可能性最小，

809
00:32:45,380 --> 00:32:47,120
因为它们在我上次访问的

810
00:32:47,120 --> 00:32:49,940
频率最低，你知道

811
00:32:49,940 --> 00:32:52,070
我上次做这个检查所以我 我要

812
00:32:52,070 --> 00:32:53,420
继续将这些写到我的冷

813
00:32:53,420 --> 00:32:57,380
数据存储中，所以现在索引

814
00:32:57,380 --> 00:32:59,120
中仍然指向这些旧的哦看

815
00:32:59,120 --> 00:33:03,020
位置，所以现在会发生的

816
00:33:03,020 --> 00:33:06,590
是如果我去使用墓碑然后

817
00:33:06,590 --> 00:33:09,110
我会有一个标记

818
00:33:09,110 --> 00:33:11,630
我删除的每个元组

819
00:33:11,630 --> 00:33:13,640
都有一个对应的新元组，新元组

820
00:33:13,640 --> 00:33:15,230
将具有块 ID 和

821
00:33:15,230 --> 00:33:17,389
它们在死时所在位置的偏移量

822
00:33:17,389 --> 00:33:20,119
，所以我不时更新我的 MMA 索引，

823
00:33:20,119 --> 00:33:21,169
而不是指向旧的

824
00:33:21,169 --> 00:33:23,059
位置和表堆，它们现在

825
00:33:23,059 --> 00:33:26,600
指向墓碑元组，因此如果

826
00:33:26,600 --> 00:33:28,549
出现查询并查找您

827
00:33:28,549 --> 00:33:31,159
知道密钥 XYZ，它们将遵循索引并

828
00:33:31,159 --> 00:33:32,869
获取这些指针之一，我检查一个标志

829
00:33:32,869 --> 00:33:35,119
，表明您正在查看墓碑

830
00:33:35,119 --> 00:33:37,429
指针 墓碑一个元组指针，或者

831
00:33:37,429 --> 00:33:38,659
抱歉，您正在查看一个墓碑

832
00:33:38,659 --> 00:33:40,850
元组，而不是要池的数据量，

833
00:33:40,850 --> 00:33:42,860
因此我知道我的块 ID

834
00:33:42,860 --> 00:33:44,690
和偏移量会告诉我去哪里

835
00:33:44,690 --> 00:33:46,549
获取我正在寻找自己的

836
00:33:46,549 --> 00:33:49,279
办公桌的数据 这里的例子我

837
00:33:49,279 --> 00:33:52,369
展示了墓碑元组被

838
00:33:52,369 --> 00:33:55,399
存储在与实际

839
00:33:55,399 --> 00:33:58,159
内存中的常规元组相同的数据表中，

840
00:33:58,159 --> 00:34:00,080
尽管你想将它们存储

841
00:34:00,080 --> 00:34:02,389
为单独的单独数据表，我们

842
00:34:02,389 --> 00:34:05,259
有 1 // 您知道常规表，

843
00:34:05,259 --> 00:34:07,309
因为

844
00:34:07,309 --> 00:34:10,549
在红色常规表中的模式会有所不同，

845
00:34:10,549 --> 00:34:12,859
您知道元组可以具有

846
00:34:12,859 --> 00:34:14,299


847
00:34:14,299 --> 00:34:16,790
模式定义的任意数量的列，当您在

848
00:34:16,790 --> 00:34:18,739
墓碑元组的情况下创建表时，

849
00:34:18,739 --> 00:34:20,690
这些 是  将被存储这些

850
00:34:20,690 --> 00:34:22,489
仅存储两个 32 位

851
00:34:22,489 --> 00:34:24,049
值，即块 ID 和偏移量，

852
00:34:24,049 --> 00:34:26,270
所以我实际上并不想将它们

853
00:34:26,270 --> 00:34:27,619
存储在同一个表中，因为

854
00:34:27,619 --> 00:34:29,299
如果我分配了

855
00:34:29,299 --> 00:34:30,980
我通常拥有的总空间量

856
00:34:30,980 --> 00:34:32,809
用于墓葬某些人的常规元组然后我

857
00:34:32,809 --> 00:34:34,159
没有从中得到任何好处，我只是

858
00:34:34,159 --> 00:34:37,609
在浪费空间，所以好吧，

859
00:34:37,609 --> 00:34:38,809
因此它是单独存储的，

860
00:34:38,809 --> 00:34:41,319
也是为什么您希望

861
00:34:41,319 --> 00:34:44,809
每个数据表有一个单独的墓碑表

862
00:34:44,809 --> 00:34:47,690
而不是一个巨人的原因

863
00:34:47,690 --> 00:34:49,399
数据库中所有表的墓碑表是因为

864
00:34:49,399 --> 00:34:52,010
当我进行顺序扫描时，这意味着我

865
00:34:52,010 --> 00:34:53,510
没有通过索引，我只是

866
00:34:53,510 --> 00:34:55,099
一个一个地

867
00:34:55,099 --> 00:34:56,690


868
00:34:56,690 --> 00:34:59,660
扫描，在我完成常规扫描后继续到达我的表的内存

869
00:34:59,660 --> 00:35:01,490
表堆结束内存元组

870
00:35:01,490 --> 00:35:03,559
然后我需要你开始

871
00:35:03,559 --> 00:35:07,700
对墓碑元组进行扫描现在我无法对墓碑进行任何

872
00:35:07,700 --> 00:35:10,220
谓词评估，

873
00:35:10,220 --> 00:35:12,920
因为那里没有数据

874
00:35:12,920 --> 00:35:14,450
所有数据都在磁盘上

875
00:35:14,450 --> 00:35:16,430
但有 有一些我

876
00:35:16,430 --> 00:35:19,819
可能会做的查询，比如我可以做的查询，

877
00:35:19,819 --> 00:35:23,599
我可以你知道只计算

878
00:35:23,599 --> 00:35:24,589
整个表中存在的元组数

879
00:35:24,589 --> 00:35:27,890
我可以应用它们我可以

880
00:35:27,890 --> 00:35:29,869
在这个上运行那种查询并且仍然

881
00:35:29,869 --> 00:35:31,030
没有正确

882
00:35:31,030 --> 00:35:32,080
的山 不得不下降，

883
00:35:32,080 --> 00:35:35,500
或者现在如果我还根据此处

884
00:35:35,500 --> 00:35:37,390
实际存在的值维护内存区域映射

885
00:35:37,390 --> 00:35:39,460
并记录

886
00:35:39,460 --> 00:35:41,110
来自 tubal 的一块墓葬，

887
00:35:41,110 --> 00:35:42,730
然后我仍然可以在那里进行扫描

888
00:35:42,730 --> 00:35:44,890
并能够计算一些

889
00:35:44,890 --> 00:35:46,600
某些查询的答案，但任何时候我都需要

890
00:35:46,600 --> 00:35:48,220
真正知道

891
00:35:48,220 --> 00:35:51,910
一个单独元组的确切值是什么给一个元组中的一个

892
00:35:51,910 --> 00:35:53,680
属性然后我必须

893
00:35:53,680 --> 00:35:57,220
走出磁盘并获得另一个

894
00:35:57,220 --> 00:35:58,900
优化你可以用这个但我们

895
00:35:58,900 --> 00:36:01,150
实际上从来没有 在 H 存储中实现这一点

896
00:36:01,150 --> 00:36:04,420
是，即使这是

897
00:36:04,420 --> 00:36:09,070
Outland 磁盘，您仍然可以

898
00:36:09,070 --> 00:36:11,020
使用索引作为覆盖索引，就像我

899
00:36:11,020 --> 00:36:13,120
知道我需要

900
00:36:13,120 --> 00:36:14,530
回答查询的所有灰词都可以在此

901
00:36:14,530 --> 00:36:17,170
索引中找到我不知道 甚至必须按照

902
00:36:17,170 --> 00:36:19,090
之前的指针来获取

903
00:36:19,090 --> 00:36:21,660
磁盘上的数据 索引包含所有我需要的

904
00:36:21,660 --> 00:36:23,800
另一件事我们认为我们从未

905
00:36:23,800 --> 00:36:28,030
真正做过的事情是说我有

906
00:36:28,030 --> 00:36:30,550
一个表的索引，该表具有

907
00:36:30,550 --> 00:36:33,520
我的表的所有属性，例如 我有

908
00:36:33,520 --> 00:36:34,930
三个属性，并且有一个索引

909
00:36:34,930 --> 00:36:36,730
，这三个属性中的每一个都有一个单独的索引，

910
00:36:36,730 --> 00:36:39,340
所以现在我的查询

911
00:36:39,340 --> 00:36:40,750
出现在

912
00:36:40,750 --> 00:36:42,370
我将遵循的那些属性之一上进行查找

913
00:36:42,370 --> 00:36:44,200
，然后这里的墓碑元组是什么

914
00:36:44,200 --> 00:36:46,600
，然后而不是向上 磁盘

915
00:36:46,600 --> 00:36:48,970
并获取它我也许

916
00:36:48,970 --> 00:36:53,040
可以在我的索引中进行反向搜索并找到

917
00:36:53,040 --> 00:36:55,330
与我的值匹配的相应键

918
00:36:55,330 --> 00:36:57,790
基本上需要

919
00:36:57,790 --> 00:37:00,310
像这样沿着叶节点扫描这实际上

920
00:37:00,310 --> 00:37:01,990
最终可能比

921
00:37:01,990 --> 00:37:04,690
必须去获取更便宜你知道 一些来自

922
00:37:04,690 --> 00:37:06,370
磁盘的块并将其带入内存，因为

923
00:37:06,370 --> 00:37:07,810
这不仅仅是磁盘 i/o

924
00:37:07,810 --> 00:37:08,920
我必须将它带入内存并

925
00:37:08,920 --> 00:37:11,500
可能更新索引，所以

926
00:37:11,500 --> 00:37:13,810
一个想法是如果我有足够的

927
00:37:13,810 --> 00:37:15,070
没有可以

928
00:37:15,070 --> 00:37:17,200
覆盖我的查询的单个索引，但它们的组合和

929
00:37:17,200 --> 00:37:18,880
它们的交集

930
00:37:18,880 --> 00:37:21,880
会更便宜，你

931
00:37:21,880 --> 00:37:23,680
知道你是否不留下任何扫描或取决于

932
00:37:23,680 --> 00:37:25,480
我使用什么数据结构来查找

933
00:37:25,480 --> 00:37:28,390


934
00:37:28,390 --> 00:37:30,250
为我的给定墓碑找到匹配匹配的所有值，

935
00:37:30,250 --> 00:37:31,990
但我们从未真正植入

936
00:37:31,990 --> 00:37:35,290
实现，所以下

937
00:37:35,290 --> 00:37:38,380
一个是布隆过滤器方法，

938
00:37:38,380 --> 00:37:40,870
所以这里的想法是

939
00:37:40,870 --> 00:37:42,580
我们为每个索引都有一个布隆过滤器

940
00:37:42,580 --> 00:37:45,190
在内存中，然后在磁盘上

941
00:37:45,190 --> 00:37:48,700
为每

942
00:37:48,700 --> 00:37:50,230
一个块或注释添加一个块

943
00:37:50,230 --> 00:37:53,200
将有一个磁盘索引只是另一个

944
00:37:53,200 --> 00:37:55,410
B+ 条约，我们可以使用它来

945
00:37:55,410 --> 00:37:57,730
识别我们正在寻找的给定键

946
00:37:57,730 --> 00:38:00,369
我们去寻找它吗？这里的想法

947
00:38:00,369 --> 00:38:02,410
是我们想要减小这个索引的大小，

948
00:38:02,410 --> 00:38:05,260
因为在墓碑情况下，

949
00:38:05,260 --> 00:38:07,660
我仍然拥有

950
00:38:07,660 --> 00:38:10,480
我被驱逐的两个四元组的所有键，但是

951
00:38:10,480 --> 00:38:12,400
使用布隆过滤器，任何键都是一个

952
00:38:12,400 --> 00:38:13,569
胜利者 和被驱逐的大号

953
00:38:13,569 --> 00:38:15,880
我们从索引中删除了这些键，

954
00:38:15,880 --> 00:38:18,730
现在索引的大小变小了，所以如果

955
00:38:18,730 --> 00:38:20,740
出现一个说键 X 是否

956
00:38:20,740 --> 00:38:21,339
存在的

957
00:38:21,339 --> 00:38:23,710
查询，我总是首先检查内存中的索引，

958
00:38:23,710 --> 00:38:25,839
如果它说它在那里他们不 有一个

959
00:38:25,839 --> 00:38:28,150
指向元组的指针，如果它

960
00:38:28,150 --> 00:38:31,000
说它不存在，我就完成了，然后我咨询它的

961
00:38:31,000 --> 00:38:33,609
布隆过滤器，然后同样的

962
00:38:33,609 --> 00:38:35,050
事情蓝色输入说它不

963
00:38:35,050 --> 00:38:37,210
存在如果它说它确实存在我就完成了

964
00:38:37,210 --> 00:38:40,060
然后我去查找内存中

965
00:38:40,060 --> 00:38:42,670
和磁盘上的索引，这将告诉

966
00:38:42,670 --> 00:38:45,579
我现在位置是块 ID 的位置

967
00:38:45,579 --> 00:38:47,380
以及

968
00:38:47,380 --> 00:38:49,000
我正在寻找的元组位置的所有集合，然后

969
00:38:49,000 --> 00:38:54,640
我会 有一个副本就好了所以

970
00:38:54,640 --> 00:38:56,740
现在你取决于我们是

971
00:38:56,740 --> 00:38:59,020
使用墓碑或布隆过滤器

972
00:38:59,020 --> 00:39:01,060
方法还是西方管理的内存或

973
00:39:01,060 --> 00:39:03,010
数据库系统管理的内存我们现在

974
00:39:03,010 --> 00:39:06,130
必须将我们的数据带回来

975
00:39:06,130 --> 00:39:08,700
然后我们可以 已经记录了运行，

976
00:39:08,700 --> 00:39:12,730
所以你必须做的问题是

977
00:39:12,730 --> 00:39:14,050
我们如何处理我们的元组 引入

978
00:39:14,050 --> 00:39:16,690
是因为再次在 OTP 环境

979
00:39:16,690 --> 00:39:20,260
中，对于给定

980
00:39:20,260 --> 00:39:22,540
的数据块，我们很可能只需要

981
00:39:22,540 --> 00:39:25,480
该块中查询的元组的一个子集，

982
00:39:25,480 --> 00:39:27,369
所以我们也处理

983
00:39:27,369 --> 00:39:30,099
所有其他的元组 所以第一个

984
00:39:30,099 --> 00:39:31,930
选择是，我们将

985
00:39:31,930 --> 00:39:33,880
通过从磁盘中提取将我们在博客中找到的所有元组合并

986
00:39:33,880 --> 00:39:36,579
到我们的表堆中，

987
00:39:36,579 --> 00:39:38,530
但无论是否需要它们

988
00:39:38,530 --> 00:39:40,750
，这意味着什么

989
00:39:40,750 --> 00:39:42,310
布隆过滤器 kate 和布隆放置

990
00:39:42,310 --> 00:39:44,680
他们的排列或管子是

991
00:39:44,680 --> 00:39:47,079
元组，现在我们必须更新

992
00:39:47,079 --> 00:39:50,680
索引，现在指向

993
00:39:50,680 --> 00:39:53,319
我们刚刚合并的元组，所以如果我需要一个来

994
00:39:53,319 --> 00:39:55,780
煮沸我的块，我的块现在有一百万个

995
00:39:55,780 --> 00:39:57,460
元组 我现在必须对我的下一个更新进行一百万次

996
00:39:57,460 --> 00:39:58,510
更新，

997
00:39:58,510 --> 00:40:00,880
以指出我刚刚引入的 100 万个

998
00:40:00,880 --> 00:40:04,180
元组，其

999
00:40:04,180 --> 00:40:05,560
缺点是

1000
00:40:05,560 --> 00:40:06,700
我们刚刚引入的元组

1001
00:40:06,700 --> 00:40:08,650
很可能会再次被驱逐，所以

1002
00:40:08,650 --> 00:40:10,180
我们有点 这个乒乓球你正在

1003
00:40:10,180 --> 00:40:11,950
颠簸效果在哪里 我们将

1004
00:40:11,950 --> 00:40:14,530
索引上的数据前后合并

1005
00:40:14,530 --> 00:40:16,000


1006
00:40:16,000 --> 00:40:18,190
，然后从磁盘到内存返回到我们的表堆中，然后我们运行我们的

1007
00:40:18,190 --> 00:40:19,330
字典算法，然后它们立即

1008
00:40:19,330 --> 00:40:20,680
被推到磁盘上，因为

1009
00:40:20,680 --> 00:40:23,200
它们又一次变冷了

1010
00:40:23,200 --> 00:40:27,160
方法是只合并

1011
00:40:27,160 --> 00:40:29,470
块内我们需要的元组，

1012
00:40:29,470 --> 00:40:32,290
所以在这种情况下，我们确定

1013
00:40:32,290 --> 00:40:33,970
了我们需要的最小数量

1014
00:40:33,970 --> 00:40:35,560
是多少我们带来了我们更新

1015
00:40:35,560 --> 00:40:37,930
这些索引的表热量，但现在我们遇到了这个

1016
00:40:37,930 --> 00:40:42,190
问题 冷数据的磁盘页面，

1017
00:40:42,190 --> 00:40:46,660
如果我们不记录我们已经

1018
00:40:46,660 --> 00:40:50,470
驱逐了该数据，抱歉，然后我们

1019
00:40:50,470 --> 00:40:52,990
将该数据移回内存中，因此

1020
00:40:52,990 --> 00:40:56,110
该元组不应该再存在于

1021
00:40:56,110 --> 00:40:57,730
该块上，我们可以

1022
00:40:57,730 --> 00:40:59,260
在没有它的情况下写出新块 元组，

1023
00:40:59,260 --> 00:41:00,640
但这会很昂贵，因为

1024
00:41:00,640 --> 00:41:03,850
现在每次读取只是为了访问

1025
00:41:03,850 --> 00:41:06,340
一个元组，我必须做一个磁盘 IO 来读取

1026
00:41:06,340 --> 00:41:08,740
它，我将它拉出来合并回

1027
00:41:08,740 --> 00:41:10,330
表 Eve 然后另一个磁盘 IO

1028
00:41:10,330 --> 00:41:13,090
写入它 出去说你 ple

1029
00:41:13,090 --> 00:41:15,370
不再存在，因此您必须维护

1030
00:41:15,370 --> 00:41:17,110
一些簿记以

1031
00:41:17,110 --> 00:41:18,400
跟踪这些漏洞，并且您可能

1032
00:41:18,400 --> 00:41:21,250
希望将它们记录在日志中而不是

1033
00:41:21,250 --> 00:41:25,780
在令人上瘾的块本身中，

1034
00:41:25,780 --> 00:41:27,040
然后您可以运行一些后台进程

1035
00:41:27,040 --> 00:41:28,840
进行压缩或合并

1036
00:41:28,840 --> 00:41:30,760
以将一堆块

1037
00:41:30,760 --> 00:41:32,520
组合成一个

1038
00:41:32,520 --> 00:41:35,080
块，之所以要跟踪这些

1039
00:41:35,080 --> 00:41:37,270
孔，是因为如果

1040
00:41:37,270 --> 00:41:41,020
我获取一个块，将返回一个元组

1041
00:41:41,020 --> 00:41:44,320
，然后将其重新放入一个可销售的块中，然后 现在

1042
00:41:44,320 --> 00:41:45,970
第一个块不应该有那个元组

1043
00:41:45,970 --> 00:41:47,710
但它仍然在物理上只是

1044
00:41:47,710 --> 00:41:49,000
我没有记录它不应该在

1045
00:41:49,000 --> 00:41:51,070
那里如果那个元组再次让受害者

1046
00:41:51,070 --> 00:41:52,720
现在被写入另一个块我

1047
00:41:52,720 --> 00:41:54,820
可以有相同的元组重复

1048
00:41:54,820 --> 00:41:56,560
多个 时间在单独的冷数据

1049
00:41:56,560 --> 00:41:58,750
块中，如果我崩溃并回来，

1050
00:41:58,750 --> 00:42:00,160
现在我不知道哪个实际上

1051
00:42:00,160 --> 00:42:02,290
是我应该做的正确的我

1052
00:42:02,290 --> 00:42:04,150
应该合并大量我

1053
00:42:04,150 --> 00:42:06,130
必须在 恢复方面处理

1054
00:42:06,130 --> 00:42:08,430


1055
00:42:09,040 --> 00:42:15,000
这个问题，倒数第二个问题

1056
00:42:15,000 --> 00:42:16,960
是我们将

1057
00:42:16,960 --> 00:42:18,730
用来确定是否将

1058
00:42:18,730 --> 00:42:21,700
合并元组中的某些内容重新合并回来的阈值是多少，

1059
00:42:21,700 --> 00:42:23,680
否则我们真的没有这个问题

1060
00:42:23,680 --> 00:42:25,900
因为一切都由

1061
00:42:25,900 --> 00:42:27,430
我们可以交换进出

1062
00:42:27,430 --> 00:42:29,020
桌面的页面控制，这是最重要的事情，并且当您

1063
00:42:29,020 --> 00:42:30,220


1064
00:42:30,220 --> 00:42:31,420
执行基于细粒度元组的

1065
00:42:31,420 --> 00:42:34,510
识别和逐出时，这很简单，所以

1066
00:42:34,510 --> 00:42:36,220
最简单的方法是 我之前说的

1067
00:42:36,220 --> 00:42:38,200
只是总是合并它我决定要合并的任何元组

1068
00:42:38,200 --> 00:42:40,240
我只是

1069
00:42:40,240 --> 00:42:41,380
总是将它们放回表堆中

1070
00:42:41,380 --> 00:42:44,410
并更新索引下一个方法

1071
00:42:44,410 --> 00:42:46,450
是仅在有更新时才合并它们

1072
00:42:46,450 --> 00:42:49,869
这意味着 如果我的查询

1073
00:42:49,869 --> 00:42:52,530
只想读取一个元组，我将

1074
00:42:52,530 --> 00:42:56,710
立即获取它遇到的块，但

1075
00:42:56,710 --> 00:42:58,900
将其放在临时缓冲区中，允许

1076
00:42:58,900 --> 00:43:01,180
查询读取它，然后立即

1077
00:43:01,180 --> 00:43:03,940
以这种方式丢弃缓冲区写入，我

1078
00:43:03,940 --> 00:43:06,150
不希望更新 在任何索引中，

1079
00:43:06,150 --> 00:43:10,119
如果是 更新然后我如果查询

1080
00:43:10,119 --> 00:43:11,350
尝试进行更新那么我将

1081
00:43:11,350 --> 00:43:13,060
继续并首先合并它然后允许

1082
00:43:13,060 --> 00:43:15,940
他们进行更新然后最后一个

1083
00:43:15,940 --> 00:43:18,160
是我们可以有点聪明并且

1084
00:43:18,160 --> 00:43:20,230
实际上保持

1085
00:43:20,230 --> 00:43:24,910
被驱逐的访问频率 块，但基本上

1086
00:43:24,910 --> 00:43:26,410
你知道它们被

1087
00:43:26,410 --> 00:43:29,500
检索的频率，如果我的访问频率

1088
00:43:29,500 --> 00:43:31,450
超过某个阈值，那么我已经

1089
00:43:31,450 --> 00:43:33,369
决定在我当前的时间

1090
00:43:33,369 --> 00:43:35,500
窗口内一直在访问这个块

1091
00:43:35,500 --> 00:43:37,480
，所以我保留它可能是个好主意

1092
00:43:37,480 --> 00:43:39,310
这有点

1093
00:43:39,310 --> 00:43:41,830
像我们会以同样的方式

1094
00:43:41,830 --> 00:43:43,420
跟踪两个极点的访问方式 我们的

1095
00:43:43,420 --> 00:43:44,830
页面被很好地访问 10 内存

1096
00:43:44,830 --> 00:43:46,990
我们还可以维护

1097
00:43:46,990 --> 00:43:49,720
说明页面被访问频率的信息

1098
00:43:49,720 --> 00:43:53,320
你从磁盘上知道的

1099
00:43:53,320 --> 00:43:55,600
我想谈论的最后一个是我们

1100
00:43:55,600 --> 00:43:58,960
如何处理访问冷数据的查询或事务，

1101
00:43:58,960 --> 00:44:03,730
你知道

1102
00:44:03,730 --> 00:44:07,330
我们应该如何响应它，所以最简单

1103
00:44:07,330 --> 00:44:09,730
的方法就是中止

1104
00:44:09,730 --> 00:44:11,650
事务，中止查询 y 并重新启动

1105
00:44:11,650 --> 00:44:16,090
它，这里的想法是我们去

1106
00:44:16,090 --> 00:44:18,369
访问一个不在内存中的元组，我们

1107
00:44:18,369 --> 00:44:21,430
记录他们想要的元组

1108
00:44:21,430 --> 00:44:22,920


1109
00:44:22,920 --> 00:44:26,400
或他们实际想要的数据，然后我们中止它一个服务器后台

1110
00:44:26,400 --> 00:44:28,049
线程然后启动并

1111
00:44:28,049 --> 00:44:30,690
获取他们的数据 需要他想要的，

1112
00:44:30,690 --> 00:44:33,089
然后根据我们刚刚谈到的策略合并它

1113
00:44:33,089 --> 00:44:35,970
，当

1114
00:44:35,970 --> 00:44:37,200
数据实际可用时，我们有一种方法

1115
00:44:37,200 --> 00:44:39,270
可以重新启动事务，

1116
00:44:39,270 --> 00:44:40,799
就像它在服务器端通过占用作为存储运行一样，

1117
00:44:40,799 --> 00:44:41,849


1118
00:44:41,849 --> 00:44:44,640
或者我们可能 通知

1119
00:44:44,640 --> 00:44:46,140
客户说嘿，您想要的数据

1120
00:44:46,140 --> 00:44:50,309
实际上现在可用最后一个

1121
00:44:50,309 --> 00:44:52,200
没有人实际上没有人真正支持

1122
00:44:52,200 --> 00:44:54,930
此权利，因此基本上是您

1123
00:44:54,930 --> 00:44:56,280
中止事务并可以

1124
00:44:56,280 --> 00:44:58,950
通过 ODBC 或 JDBC 发回异常并给出

1125
00:44:58,950 --> 00:45:00,599
错误代码来说明数据 你想要

1126
00:45:00,599 --> 00:45:04,410
一些记忆，请重试有

1127
00:45:04,410 --> 00:45:05,670
类似的一次或死锁之

1128
00:45:05,670 --> 00:45:07,890
类的，所以

1129
00:45:07,890 --> 00:45:10,950
你不能这样做并非不可行，但

1130
00:45:10,950 --> 00:45:13,099
实际上没有系统明确地为 fo 将

1131
00:45:13,099 --> 00:45:15,119
数据逐出内存数据库

1132
00:45:15,119 --> 00:45:21,480
系统，所以这将是一件棘手的事情

1133
00:45:21,480 --> 00:45:24,750
，如果我有一个

1134
00:45:24,750 --> 00:45:27,630
事务或查询想要

1135
00:45:27,630 --> 00:45:29,910
以强隔离级别（如快照

1136
00:45:29,910 --> 00:45:34,380
隔离或序列化立法）运行，我

1137
00:45:34,380 --> 00:45:36,000
必须有多个 尝试使用的版本并发性

1138
00:45:36,000 --> 00:45:37,530
我可以有多个版本控制，

1139
00:45:37,530 --> 00:45:41,220
以便允许事务

1140
00:45:41,220 --> 00:45:43,950
多次重新启动或

1141
00:45:43,950 --> 00:45:49,440
暂停和重新启动，并且至少具有

1142
00:45:49,440 --> 00:45:52,859
数据库的一致快照，因此

1143
00:45:52,859 --> 00:45:55,349
使用此快照并不是真正

1144
00:45:55,349 --> 00:45:57,119
中止您是的您中止 并

1145
00:45:57,119 --> 00:45:59,549
重新启动它，但是当您

1146
00:45:59,549 --> 00:46:01,530
第二次回来时，您的事务

1147
00:46:01,530 --> 00:46:04,619
ID 仍然是相同的，这里的想法

1148
00:46:04,619 --> 00:46:07,859
是，

1149
00:46:07,859 --> 00:46:09,599


1150
00:46:09,599 --> 00:46:11,190


1151
00:46:11,190 --> 00:46:13,230
即使您 可能在

1152
00:46:13,230 --> 00:46:17,069
不同的查询调用中运行它，

1153
00:46:17,069 --> 00:46:19,230
所以考虑这个的方式是

1154
00:46:19,230 --> 00:46:21,540
说我有一个查询想要

1155
00:46:21,540 --> 00:46:24,000
扫描整个团队，但只有一半的表

1156
00:46:24,000 --> 00:46:27,990
可以存在于备忘录中 在给定的时间

1157
00:46:27,990 --> 00:46:29,700
会发生什么这种方法是我

1158
00:46:29,700 --> 00:46:32,040
会查询将开始

1159
00:46:32,040 --> 00:46:33,599
扫描并通过表的前半

1160
00:46:33,599 --> 00:46:35,760
部分然后我尝试

1161
00:46:35,760 --> 00:46:36,970
访问下半部

1162
00:46:36,970 --> 00:46:40,400
分然后它会

1163
00:46:40,400 --> 00:46:42,110
出现 要么是墓碑元组，要么以某种方式

1164
00:46:42,110 --> 00:46:44,120
识别出曾经不存在的元组

1165
00:46:44,120 --> 00:46:47,810
然后它被中止

1166
00:46:47,810 --> 00:46:50,240
后台线程获取受害者

1167
00:46:50,240 --> 00:46:54,140
实际需要的剩余数据

1168
00:46:54,140 --> 00:46:56,150
表的前半部分

1169
00:46:56,150 --> 00:46:58,430
然后我的查询事务可以

1170
00:46:58,430 --> 00:47:00,440
重新启动 但是如果我从头

1171
00:47:00,440 --> 00:47:02,060
开始重新开始，那么我会遇到同样的

1172
00:47:02,060 --> 00:47:04,730
问题，我需要去获取的第一

1173
00:47:04,730 --> 00:47:06,590
件事不是内存，而不是去

1174
00:47:06,590 --> 00:47:08,240
上它，现在上半年得到

1175
00:47:08,240 --> 00:47:09,890
报酬，下半年得到写入

1176
00:47:09,890 --> 00:47:12,200
我永远无法真正完成或在

1177
00:47:12,200 --> 00:47:13,940
运行时使用一致的快照，其中

1178
00:47:13,940 --> 00:47:16,160
交易可能会在下半部分更新，

1179
00:47:16,160 --> 00:47:16,880


1180
00:47:16,880 --> 00:47:19,130
而我等待交易让

1181
00:47:19,130 --> 00:47:21,350
我开始，或者如果我有一个吻不是

1182
00:47:21,350 --> 00:47:23,120
快照，那么我只是 sho 我基本上会

1183
00:47:23,120 --> 00:47:25,190
暂停垃圾垃圾收集，而我

1184
00:47:25,190 --> 00:47:27,890
会在上半场冲洗掉他

1185
00:47:27,890 --> 00:47:29,270
的下半场，然后我回来，我

1186
00:47:29,270 --> 00:47:31,550
仍然有一致的视图或

1187
00:47:31,550 --> 00:47:34,460
一致的表格快照，因为我

1188
00:47:34,460 --> 00:47:37,100
说过没有人真正做到这一点，

1189
00:47:37,100 --> 00:47:40,460
我知道 你知道这个原因

1190
00:47:40,460 --> 00:47:41,870
是因为它很难保证

1191
00:47:41,870 --> 00:47:45,830
一致性，更常见的方法

1192
00:47:45,830 --> 00:47:49,010
是进行同步检索，这里的想法

1193
00:47:49,010 --> 00:47:51,350
是，当我尝试访问不在内存中的东西时，它本质上是

1194
00:47:51,350 --> 00:47:53,270
磁盘或本机数据库现在所做的

1195
00:47:53,270 --> 00:47:55,130
事情

1196
00:47:55,130 --> 00:47:57,620
我的事务

1197
00:47:57,620 --> 00:48:00,440
当另一个线程或我

1198
00:48:00,440 --> 00:48:04,280
的磁盘控制器或为什么这是一个磁盘

1199
00:48:04,280 --> 00:48:05,810
管理器时它

1200
00:48:05,810 --> 00:48:07,940


1201
00:48:07,940 --> 00:48:09,710


1202
00:48:09,710 --> 00:48:12,200


1203
00:48:12,200 --> 00:48:13,850
会暂停或停止 你可以玩其中的一些游戏，

1204
00:48:13,850 --> 00:48:18,770
就像我可以尝试让查询

1205
00:48:18,770 --> 00:48:22,450
保持运行很长时间，因为它可以

1206
00:48:22,450 --> 00:48:28,160
访问被驱逐的数据，我只需要

1207
00:48:28,160 --> 00:48:29,570
像绝地思维技巧

1208
00:48:29,570 --> 00:48:31,250
那样做 哦，我想阅读这个元组，

1209
00:48:31,250 --> 00:48:32,900
你假装它实际上可以读取

1210
00:48:32,900 --> 00:48:34,640
它一些查询可以做到这一点，而其他一些查询不能这样做

1211
00:48:34,640 --> 00:48:37,490
，只有当他们

1212
00:48:37,490 --> 00:48:39,110
真正尝试将结果返回给

1213
00:48:39,110 --> 00:48:40,370
应用程序或对被驱逐的个人属性做一些事情时

1214
00:48:40,370 --> 00:48:42,410


1215
00:48:42,410 --> 00:48:44,660
数据然后你继续并暂停它或

1216
00:48:44,660 --> 00:48:48,980
中止它这里的想法是你

1217
00:48:48,980 --> 00:48:50,330
可以让查询

1218
00:48:50,330 --> 00:48:53,060
尽可能长地识别所有

1219
00:48:53,060 --> 00:48:54,560
两个极点所有页面都将

1220
00:48:54,560 --> 00:48:56,810
访问然后在某些时候你说

1221
00:48:56,810 --> 00:48:58,670
好我 已经看够了，让我

1222
00:48:58,670 --> 00:49:00,170
去取你需要的一大批东西

1223
00:49:00,170 --> 00:49:02,360
，这样你就不会像

1224
00:49:02,360 --> 00:49:04,370
这样一次又一次地运行停顿运行停顿，

1225
00:49:04,370 --> 00:49:05,810
你可以做一堆

1226
00:49:05,810 --> 00:49:07,670
顺序 I/O 把它全部取出来

1227
00:49:07,670 --> 00:49:13,370
然后让它运行得更快，所以

1228
00:49:13,370 --> 00:49:14,690
现在我想通过一系列

1229
00:49:14,690 --> 00:49:17,930
不同的系统实现

1230
00:49:17,930 --> 00:49:19,640
来支持比内存更大的

1231
00:49:19,640 --> 00:49:21,650
数据库，并且

1232
00:49:21,650 --> 00:49:23,660
组织方式是这里的前四个

1233
00:49:23,660 --> 00:49:25,820
我们都将使用 那种

1234
00:49:25,820 --> 00:49:27,470
f 我们之前讨论过的基于 ine-grain 元组的方法

1235
00:49:27,470 --> 00:49:29,540


1236
00:49:29,540 --> 00:49:32,750
，然后这 300 万个

1237
00:49:32,750 --> 00:49:34,160
系统实际上将是

1238
00:49:34,160 --> 00:49:36,350
基于页面的，在高层次上，它们都

1239
00:49:36,350 --> 00:49:38,660
将实现相同的目标，我们

1240
00:49:38,660 --> 00:49:40,340
可以有一个 新的内存数据库系统

1241
00:49:40,340 --> 00:49:43,280
，可以维护和存储

1242
00:49:43,280 --> 00:49:44,900
大于

1243
00:49:44,900 --> 00:49:46,100
系统可用内存量的数据库，

1244
00:49:46,100 --> 00:49:49,100
而无需在

1245
00:49:49,100 --> 00:49:53,480
某种程度上重写应用

1246
00:49:53,480 --> 00:49:57,020
程序，我要说的剧透是

1247
00:49:57,020 --> 00:49:59,270
基于页面的方法 特别是从

1248
00:49:59,270 --> 00:50:01,670
精益商店和 Umbra 我认为是

1249
00:50:01,670 --> 00:50:04,370
正确的方法，这两个基本

1250
00:50:04,370 --> 00:50:07,400
的有点太细粒度了

1251
00:50:07,400 --> 00:50:12,230
，你支付的商店和计算

1252
00:50:12,230 --> 00:50:13,790
开销或笔或你支付的费用

1253
00:50:13,790 --> 00:50:15,830
有点支持我

1254
00:50:15,830 --> 00:50:20,180
认为这是不值得的，所以我们将

1255
00:50:20,180 --> 00:50:21,800
再次逐个逐一讨论，但我

1256
00:50:21,800 --> 00:50:23,900
认为 umber one 的叶子

1257
00:50:23,900 --> 00:50:28,160
可能是正确的方法，正如我

1258
00:50:28,160 --> 00:50:31,370
在所有不同工具的论文之前所说的那样

1259
00:50:31,370 --> 00:50:32,780
问题或

1260
00:50:32,780 --> 00:50:36,170
设计决策基于

1261
00:50:36,170 --> 00:50:37,280
我在读研究生时帮助构建的一个系统，

1262
00:50:37,280 --> 00:50:38,900
称为 8 存储，然后将其

1263
00:50:38,900 --> 00:50:41,960
商业化为 volt EP，并且在

1264
00:50:41,960 --> 00:50:45,500


1265
00:50:45,500 --> 00:50:47,990
支持磁盘上的就绪数据的存储的早期原型上是

1266
00:50:47,990 --> 00:50:50,540
这个组件我们 将其称为 T 缓存

1267
00:50:50,540 --> 00:50:52,580
，这个想法就像

1268
00:50:52,580 --> 00:50:54,710
是缓存的反向，而不是

1269
00:50:54,710 --> 00:50:56,510
从磁盘获取热数据并将其拉入

1270
00:50:56,510 --> 00:51:00,080
内存，我们将冷数据从

1271
00:51:00,080 --> 00:51:03,230
内存中推送到磁盘上，因此考虑到所有

1272
00:51:03,230 --> 00:51:04,609
不同的设计决策，我们

1273
00:51:04,609 --> 00:51:06,319
在这里谈到了存储 将要进行在线

1274
00:51:06,319 --> 00:51:08,450
识别 它会

1275
00:51:08,450 --> 00:51:10,130
在我们采样的每个元组的头中维护一个 LRU 链，

1276
00:51:10,130 --> 00:51:12,410
以确保

1277
00:51:12,410 --> 00:51:13,700
我们不会在每次事务运行时都更新它

1278
00:51:13,700 --> 00:51:15,829
以避免过多的

1279
00:51:15,829 --> 00:51:19,460
开销，但它仍然是 64 位的

1280
00:51:19,460 --> 00:51:22,099
每个 单元组它会有

1281
00:51:22,099 --> 00:51:23,479
管理员定义的阈值来

1282
00:51:23,479 --> 00:51:26,559
识别

1283
00:51:26,559 --> 00:51:28,700
当你空间不足时你需要的数据，然后

1284
00:51:28,700 --> 00:51:30,289
继续启动

1285
00:51:30,289 --> 00:51:32,150
我们将要执行的驱逐策略 使用墓碑元组，

1286
00:51:32,150 --> 00:51:33,890
我们将执行董事会和重新启动

1287
00:51:33,890 --> 00:51:35,569
方法，我们可以这样做，因为

1288
00:51:35,569 --> 00:51:39,559
H 存储中的所有事务

1289
00:51:39,559 --> 00:51:42,109
都必须作为存储过程运行，它将

1290
00:51:42,109 --> 00:51:44,170
执行

1291
00:51:44,170 --> 00:51:47,089
合并和数据的块级粒度，然后在

1292
00:51:47,089 --> 00:51:48,619
原始实现中它会 总是

1293
00:51:48,619 --> 00:51:50,839
正确合并它们 最初的

1294
00:51:50,839 --> 00:51:52,430
含义无法决定哦，

1295
00:51:52,430 --> 00:51:54,140
这是正在更新的数据，所以

1296
00:51:54,140 --> 00:51:56,239
让我继续并显示

1297
00:51:56,239 --> 00:51:58,640
该部分或将其放在侧缓冲区中 它

1298
00:51:58,640 --> 00:52:00,079
只是总是抓住它 块已

1299
00:52:00,079 --> 00:52:02,499
更新所有 将它合并的索引

1300
00:52:02,499 --> 00:52:05,719
不用说，这有一个你

1301
00:52:05,719 --> 00:52:07,729
知道相当多的开销来支持

1302
00:52:07,729 --> 00:52:10,819
这个

1303
00:52:10,819 --> 00:52:12,880
大约在这个

1304
00:52:12,880 --> 00:52:15,769
时候支持大于数据库的另一种主要实现

1305
00:52:15,769 --> 00:52:18,499
来自它再次成为

1306
00:52:18,499 --> 00:52:21,890
Hecate on 项目的一部分 Hecate on

1307
00:52:21,890 --> 00:52:23,749
是 Microsoft 为续集服务器构建的内存存储或执行引擎

1308
00:52:23,749 --> 00:52:26,119
，我

1309
00:52:26,119 --> 00:52:27,799
现在认为它们只是在

1310
00:52:27,799 --> 00:52:29,960
内存表中调用，但是搜索

1311
00:52:29,960 --> 00:52:31,999
hackaton 然后它出现了 他是一个副

1312
00:52:31,999 --> 00:52:34,190
项目或一个名为 project Siberia 的研究项目

1313
00:52:34,190 --> 00:52:36,349
，它再次

1314
00:52:36,349 --> 00:52:39,789
研究如何扩展 Hecate 以支持

1315
00:52:39,789 --> 00:52:41,509
超过可用内存量的数据库，

1316
00:52:41,509 --> 00:52:43,460
所以这个项目的主要

1317
00:52:43,460 --> 00:52:44,779
内容是

1318
00:52:44,779 --> 00:52:46,099
我们是布隆过滤器 我们

1319
00:52:46,099 --> 00:52:48,049
讨论的内容来自，想法

1320
00:52:48,049 --> 00:52:49,969
是您执行离线

1321
00:52:49,969 --> 00:52:52,309
识别与年龄相同的阈值或

1322
00:52:52,309 --> 00:52:54,229
由管理员定义的阈值，

1323
00:52:54,229 --> 00:52:58,640
我们将从 Mme 索引的肉中移除元组中的值或键

1324
00:52:58,640 --> 00:52:59,839


1325
00:52:59,839 --> 00:53:02,210
，然后 更新或维护一个

1326
00:53:02,210 --> 00:53:04,099
布隆过滤器以跟踪

1327
00:53:04,099 --> 00:53:06,049
密钥是否真的可以存在于磁盘上

1328
00:53:06,049 --> 00:53:08,539
，然后当事务尝试

1329
00:53:08,539 --> 00:53:10,549
访问冷数据时，我们实际上会暂停

1330
00:53:10,549 --> 00:53:13,369
它们或停止它们，然后去获取它

1331
00:53:13,369 --> 00:53:15,589
并将其引入，它们总是

1332
00:53:15,589 --> 00:53:17,509
这样做合并元组级别的

1333
00:53:17,509 --> 00:53:18,210
粒度，

1334
00:53:18,210 --> 00:53:20,070
就像在商店中一样，他们总是会合并

1335
00:53:20,070 --> 00:53:23,250
所有内容，因此据我所知

1336
00:53:23,250 --> 00:53:25,980
，Microsoft 的所有 Siberia 内容从未

1337
00:53:25,980 --> 00:53:27,390
真正用于生产 uction 从来没有

1338
00:53:27,390 --> 00:53:29,190
真正进入真正的黑客马拉松

1339
00:53:29,190 --> 00:53:32,460
系统，我认为其中的一部分

1340
00:53:32,460 --> 00:53:33,990


1341
00:53:33,990 --> 00:53:37,440
只是维护冷

1342
00:53:37,440 --> 00:53:42,089
数据和热数据的工程复杂性，以及

1343
00:53:42,089 --> 00:53:43,589
你可以从你那里得到的那种不一致的性能

1344
00:53:43,589 --> 00:53:46,830
，有时你知道 元

1345
00:53:46,830 --> 00:53:48,210
组在他们的记忆中，有时

1346
00:53:48,210 --> 00:53:49,140
它们不是，你真的不知道

1347
00:53:49,140 --> 00:53:50,760
，直到你对它们采取行动，所以由于

1348
00:53:50,760 --> 00:53:52,500
这些原因，我 Hecate 从来没有真正

1349
00:53:52,500 --> 00:53:55,140
得到过这个功能，同样

1350
00:53:55,140 --> 00:53:56,970
我认为两台电视都没有得到过

1351
00:53:56,970 --> 00:53:58,260
古董灰和我们在 2 岁时做的事情

1352
00:53:58,260 --> 00:54:02,160
另一个有趣的

1353
00:54:02,160 --> 00:54:06,300
系统来自 epfl，这是

1354
00:54:06,300 --> 00:54:08,790
由 Natasa alum aki 和

1355
00:54:08,790 --> 00:54:11,310
她在瑞士的团队开发的，在我出现之前，tossa 曾经

1356
00:54:11,310 --> 00:54:14,130
是 CMU 的数据库教授

1357
00:54:14,130 --> 00:54:15,540
，她 实际上

1358
00:54:15,540 --> 00:54:19,410
在 13 年前教过 7:21 的早期版本，

1359
00:54:19,410 --> 00:54:22,260
所以他们将要做什么，

1360
00:54:22,260 --> 00:54:23,220
所以他们将进行

1361
00:54:23,220 --> 00:54:26,400
与西伯利亚相同的离线识别，

1362
00:54:26,400 --> 00:54:29,490
但现在他们将

1363
00:54:29,490 --> 00:54:33,750
拥有操作系统管理 内存并

1364
00:54:33,750 --> 00:54:36,119
决定如何将东西从磁盘中驱逐，但

1365
00:54:36,119 --> 00:54:37,050
他们会很聪明，

1366
00:54:37,050 --> 00:54:40,410
他们只会让操作系统驱逐

1367
00:54:40,410 --> 00:54:43,260
表堆的某种部分

1368
00:54:43,260 --> 00:54:46,950
，他们将有一个热点部分

1369
00:54:46,950 --> 00:54:48,960
他们维护但永远

1370
00:54:48,960 --> 00:54:49,920
不会写出到磁盘然后我们

1371
00:54:49,920 --> 00:54:52,020
将数据移动到

1372
00:54:52,020 --> 00:54:54,750
堆的冷冷部分并让操作系统患者根据需要离开，

1373
00:54:54,750 --> 00:54:58,619
因为它正在使用

1374
00:54:58,619 --> 00:55:00,720
em 映射和假定的虚拟

1375
00:55:00,720 --> 00:55:03,060
内存操作系统是 交换出来它会

1376
00:55:03,060 --> 00:55:05,820
做同步检索，因为

1377
00:55:05,820 --> 00:55:07,230
达达主义实际上并不知道

1378
00:55:07,230 --> 00:55:10,080
内存中的内容，而不是不记得它是一个新的

1379
00:55:10,080 --> 00:55:11,339
页面级粒度，因为这就是

1380
00:55:11,339 --> 00:55:13,230
它的工作方式，他们总是会

1381
00:55:13,230 --> 00:55:16,410
合并事物，因为这

1382
00:55:16,410 --> 00:55:18,780
很好，其余的 系统不

1383
00:55:18,780 --> 00:55:20,670
知道元组已被逐出，

1384
00:55:20,670 --> 00:55:23,339
他仍然有一个指向

1385
00:55:23,339 --> 00:55:25,619
堆冷部分的指针，然后当它

1386
00:55:25,619 --> 00:55:27,330
尝试访问时，它会得到然后

1387
00:55:27,330 --> 00:55:28,980
它得到一个页面错误并且它被

1388
00:55:28,980 --> 00:55:31,710
交换了他 所以这是与

1389
00:55:31,710 --> 00:55:32,040


1390
00:55:32,040 --> 00:55:34,950
我们之前看到的不同的关键部分

1391
00:55:34,950 --> 00:55:36,270
所以让我们看看它是如何工作的 所以

1392
00:55:36,270 --> 00:55:38,010
这是我们的内存表 这里又是我们的

1393
00:55:38,010 --> 00:55:39,840
冷存储 这意味着

1394
00:55:39,840 --> 00:55:41,130
这只是

1395
00:55:41,130 --> 00:55:43,620
由操作系统管理的交换空间所以

1396
00:55:43,620 --> 00:55:45,090
好 新闻是他们将

1397
00:55:45,090 --> 00:55:47,340
内存堆划分为热元组和代码

1398
00:55:47,340 --> 00:55:49,950
元组，对于堆的热部分，

1399
00:55:49,950 --> 00:55:52,440
他们将使用 em 锁将

1400
00:55:52,440 --> 00:55:55,230
这些页面固定在内存中，这是 M

1401
00:55:55,230 --> 00:55:58,380
锁可防止操作系统写入

1402
00:55:58,380 --> 00:56:00,270
此内容 数据从磁盘中取出，但冷

1403
00:56:00,270 --> 00:56:02,490
元组部分没有被锁定或没有

1404
00:56:02,490 --> 00:56:05,280
固定，所以现在操作员

1405
00:56:05,280 --> 00:56:07,260
可以随时决定将这些

1406
00:56:07,260 --> 00:56:11,220
数据驱逐出去，所以假设现在我们有了

1407
00:56:11,220 --> 00:56:13,200


1408
00:56:13,200 --> 00:56:14,600
数据库系统将要运行的离线标识

1409
00:56:14,600 --> 00:56:16,950
识别此元组中的此数据

1410
00:56:16,950 --> 00:56:19,110
是冷的，因此我们现在要做的是

1411
00:56:19,110 --> 00:56:23,250
将其复制到冷元组中

1412
00:56:23,250 --> 00:56:24,570
本质上是删除后

1413
00:56:24,570 --> 00:56:26,280
插入就像内部事务所做的

1414
00:56:26,280 --> 00:56:27,570
那样删除后插入 nd

1415
00:56:27,570 --> 00:56:29,190
这将自动更新索引

1416
00:56:29,190 --> 00:56:32,160
现在指向

1417
00:56:32,160 --> 00:56:33,900
这个元组的物理位置的新位置

1418
00:56:33,900 --> 00:56:37,410
然后我们可以

1419
00:56:37,410 --> 00:56:39,840
在稍后的某个时间将我们想要的任何新数据放在这里操作系统

1420
00:56:39,840 --> 00:56:41,250
决定它的内存不足

1421
00:56:41,250 --> 00:56:43,530
它可以 决定继续交换

1422
00:56:43,530 --> 00:56:45,630
冷元组区域中的任何页面，

1423
00:56:45,630 --> 00:56:48,800
但我们无法

1424
00:56:48,800 --> 00:56:53,100
确定这些数据是否在

1425
00:56:53,100 --> 00:56:54,990


1426
00:56:54,990 --> 00:56:57,360


1427
00:56:57,360 --> 00:56:59,760
内存中 所以我们必须确保的棘手的事情

1428
00:56:59,760 --> 00:57:02,460
当然是我们想要

1429
00:57:02,460 --> 00:57:04,050
确保我们所有的元组都是页面

1430
00:57:04,050 --> 00:57:06,060
对齐的，因为我们不

1431
00:57:06,060 --> 00:57:09,060
存在管道可能会被分成

1432
00:57:09,060 --> 00:57:12,390
多个页面的问题，现在

1433
00:57:12,390 --> 00:57:14,010
事情会发生 确保我们以正确的顺序写出这些页面是很棘手的，以

1434
00:57:14,010 --> 00:57:16,800
确保我们在

1435
00:57:16,800 --> 00:57:19,290


1436
00:57:19,290 --> 00:57:20,970
没有其他权利的情况下看不到一个我们不会

1437
00:57:20,970 --> 00:57:22,440
在 Tom 上这样做，这

1438
00:57:22,440 --> 00:57:24,780
不是操作系统可以

1439
00:57:24,780 --> 00:57:26,910
提供的 我们因为 use 和 MF 不能

1440
00:57:26,910 --> 00:57:28,860
在多个页面上是原子的，这

1441
00:57:28,860 --> 00:57:30,360
意味着我们必须在某处维护一个日志

1442
00:57:30,360 --> 00:57:32,730
来跟踪

1443
00:57:32,730 --> 00:57:35,610
这里发生的事情，所以我认为这

1444
00:57:35,610 --> 00:57:37,290
是一个有趣的想法，因为它

1445
00:57:37,290 --> 00:57:39,480
使用地图和一种聪明的数据

1446
00:57:39,480 --> 00:57:44,400
方式 主要是阅读但是为了

1447
00:57:44,400 --> 00:57:45,480
处理这种情况，

1448
00:57:45,480 --> 00:57:47,820
当有更新时，你需要一个日志来

1449
00:57:47,820 --> 00:57:50,210
跟踪这里发生的

1450
00:57:50,210 --> 00:57:52,500
事情，我想谈论的最后一个基于元组的方法

1451
00:57:52,500 --> 00:57:54,660
来自 Apache

1452
00:57:54,660 --> 00:57:57,930
geode，所以 Apache geode 最初是

1453
00:57:57,930 --> 00:57:59,880
这个数据系统 Ameri 数据

1454
00:57:59,880 --> 00:58:04,200
名为 gem fire 的系统长话短说

1455
00:58:04,200 --> 00:58:06,119
gem fire 是与另一

1456
00:58:06,119 --> 00:58:09,119
家名为 gemstone 的公司开发的，然后pivotal

1457
00:58:09,119 --> 00:58:11,580
买下他们，对不起，然后 VMware

1458
00:58:11,580 --> 00:58:14,190
收购了他们，但是 VMware 决定他们

1459
00:58:14,190 --> 00:58:16,230
不想拥有数据库公司，

1460
00:58:16,230 --> 00:58:19,170
所以他们剥离了它并合并了它

1461
00:58:19,170 --> 00:58:20,850
使用 AMC 的 greenplum，这变得

1462
00:58:20,850 --> 00:58:23,940
关键，然后我猜关键决定

1463
00:58:23,940 --> 00:58:25,260
他们不想让你知道某种

1464
00:58:25,260 --> 00:58:28,740
积极维护宝石之火或其他

1465
00:58:28,740 --> 00:58:32,220
什么，然后他们就傻了 把它交给 Apache

1466
00:58:32,220 --> 00:58:35,070
基金会，所以它是 Apache geo 所以

1467
00:58:35,070 --> 00:58:36,000
他们在做什么 在线

1468
00:58:36,000 --> 00:58:38,040
识别就像一个 H 门 Dumanis

1469
00:58:38,040 --> 00:58:39,420
叛徒定义的阈值就像

1470
00:58:39,420 --> 00:58:41,670
以前一样，据我所知，他们正在使用

1471
00:58:41,670 --> 00:58:44,550
墓碑来识别元组

1472
00:58:44,550 --> 00:58:45,840
已从内存中删除和 现在它们

1473
00:58:45,840 --> 00:58:48,480
实际上驻留在 HDFS 上，但这一切都

1474
00:58:48,480 --> 00:58:52,350
假设您在 HDFS 上运行，它们将进行

1475
00:58:52,350 --> 00:58:53,640
同步检索，因为块

1476
00:58:53,640 --> 00:58:55,740
查询和带入

1477
00:58:55,740 --> 00:58:57,810
它们将以两个基本粒度进行，但

1478
00:58:57,810 --> 00:58:59,460
有趣的是它们是

1479
00:58:59,460 --> 00:59:01,410
只会合并元组并将它们

1480
00:59:01,410 --> 00:59:04,920
带回内存并

1481
00:59:04,920 --> 00:59:08,580
在您进行更新时丢弃基于磁盘的块，

1482
00:59:08,580 --> 00:59:10,430
他们这样做的原因是因为

1483
00:59:10,430 --> 00:59:15,840
HDFS 是仅附加的，所以

1484
00:59:15,840 --> 00:59:18,480
他们这样做会很痛苦

1485
00:59:18,480 --> 00:59:21,240
对已经存在的块进行更新，

1486
00:59:21,240 --> 00:59:24,000
您必须写一条日志消息

1487
00:59:24,000 --> 00:59:26,150
，说这个旧块已被驱逐，

1488
00:59:26,150 --> 00:59:27,960
抱歉，它已被拉回

1489
00:59:27,960 --> 00:59:29,700
内存，不再被认为

1490
00:59:29,700 --> 00:59:35,430
是有效或最新的 我你在

1491
00:59:35,430 --> 00:59:37,500
他们的世界里是为了避免那么大的惩罚

1492
00:59:37,500 --> 00:59:39,480
，然后也把事情交给

1493
00:59:39,480 --> 00:59:41,430
独裁者，他们会更新一条日志

1494
00:59:41,430 --> 00:59:43,350
消息说是的，这件事已被

1495
00:59:43,350 --> 00:59:44,970
删除，但他们只想

1496
00:59:44,970 --> 00:59:48,390
在更新时这样做 我知道我的意思是

1497
00:59:48,390 --> 00:59:49,770
我确定人们正在使用它，但我

1498
00:59:49,770 --> 00:59:51,960
还没有遇到

1499
00:59:51,960 --> 00:59:55,020
任何人在使用这些溢出

1500
00:59:55,020 --> 00:59:58,130
表和 apache

1501
00:59:58,150 --> 01:00:03,489


1502
01:00:03,489 --> 01:00:05,359
geode 至少

1503
01:00:05,359 --> 01:00:09,160
在 volt EB 和 Apache geode 示例中的存储数据包中，

1504
01:00:09,160 --> 01:00:11,989
这些都

1505
01:00:11,989 --> 01:00:15,380
基于每个小管进行驱逐，

1506
01:00:15,380 --> 01:00:18,049
这意味着我们必须

1507
01:00:18,049 --> 01:00:19,519
跟踪单个元组如何

1508
01:00:19,519 --> 01:00:21,109
读取它们如何更新，

1509
01:00:21,109 --> 01:00:26,119
然后我们 决定

1510
01:00:26,119 --> 01:00:27,529
如何驱逐他们 你知道我们正在

1511
01:00:27,529 --> 01:00:30,079
根据每个学生做出这些决定

1512
01:00:30,079 --> 01:00:31,819
将它们组合成一个页面或块并将

1513
01:00:31,819 --> 01:00:34,579
它们写出到磁盘 但

1514
01:00:34,579 --> 01:00:41,180
除了西伯利亚项目之外，所有

1515
01:00:41,180 --> 01:00:44,059
这些都不会 实际上减少

1516
01:00:44,059 --> 01:00:46,999
索引和 fu 的大小 此外，它们中没有一个

1517
01:00:46,999 --> 01:00:48,950
实际上可以将索引溢出或将索引的

1518
01:00:48,950 --> 01:00:51,739
一部分写出磁盘，因此

1519
01:00:51,739 --> 01:00:53,390
只有西伯利亚项目会将结束

1520
01:00:53,390 --> 01:00:55,249
键从索引中拉出以减小索引的大小

1521
01:00:55,249 --> 01:00:56,719
，然后填充

1522
01:00:56,719 --> 01:00:57,710
布隆过滤器，这将是很多

1523
01:00:57,710 --> 01:01:00,499
比

1524
01:01:00,499 --> 01:01:01,670
如果键存在于

1525
01:01:01,670 --> 01:01:05,509
索引中的键值要小，但除此之外，它们无法

1526
01:01:05,509 --> 01:01:07,519
识别哦

1527
01:01:07,519 --> 01:01:10,039
，我索引的索引的这部分在那里，它们没有

1528
01:01:10,039 --> 01:01:12,289
被更新或经常访问，所以

1529
01:01:12,289 --> 01:01:13,579
让 我继续将这些东西显示

1530
01:01:13,579 --> 01:01:15,920
到磁盘上，正如我们在讨论压缩时看到的那样

1531
01:01:15,920 --> 01:01:17,390
我在

1532
01:01:17,390 --> 01:01:18,650
讨论如何对某些 Ultima 数据库进行索引压缩时最后展示

1533
01:01:18,650 --> 01:01:21,140


1534
01:01:21,140 --> 01:01:23,109
了索引的大小

1535
01:01:23,109 --> 01:01:24,979
相对于

1536
01:01:24,979 --> 01:01:28,039
数据库的整体大小和

1537
01:01:28,039 --> 01:01:29,930
一些解决索引的示例

1538
01:01:29,930 --> 01:01:32,479
高达数据库总内存大小的 60%，

1539
01:01:32,479 --> 01:01:35,029
所以我们在

1540
01:01:35,029 --> 01:01:37,009
这里做的所有事情实际上并不是

1541
01:01:37,009 --> 01:01:38,450
针对这些应用程序的

1542
01:01:38,450 --> 01:01:40,729
那些大量内存

1543
01:01:40,729 --> 01:01:43,160
实际用于的数据库，所以我们

1544
01:01:43,160 --> 01:01:46,549
真正想要的是一种统一的方法和

1545
01:01:46,549 --> 01:01:50,239
统一的模型，用于将冷数据

1546
01:01:50,239 --> 01:01:52,849
从表或索引中逐出磁盘，

1547
01:01:52,849 --> 01:01:55,160
我们不

1548
01:01:55,160 --> 01:01:57,380
应该有七个策略 分开你

1549
01:01:57,380 --> 01:01:59,569
知道单独的机制或这

1550
01:01:59,569 --> 01:02:02,180
两者它应该只是

1551
01:02:02,180 --> 01:02:05,019
在两种类型的数据中使用的单一方法

1552
01:02:05,019 --> 01:02:07,369
所以这就是我们最终得到

1553
01:02:07,369 --> 01:02:10,770
我让你们阅读的论文的方式

1554
01:02:10,770 --> 01:02:14,100
，所以留置权存储是一个

1555
01:02:14,100 --> 01:02:15,660
内存存储管理器中的原型，

1556
01:02:15,660 --> 01:02:19,140
由德国人慕尼黑开发，

1557
01:02:19,140 --> 01:02:21,030
用于超级系统，但

1558
01:02:21,030 --> 01:02:22,110
据我所知，这实际上并不是

1559
01:02:22,110 --> 01:02:23,400
超级项目的一部分，

1560
01:02:23,400 --> 01:02:25,440
这是一个独立的独立

1561
01:02:25,440 --> 01:02:27,930
事物，所以它真的很酷 精益

1562
01:02:27,930 --> 01:02:28,830
强能做的又是它

1563
01:02:28,830 --> 01:02:33,030
从头开始设计驱逐页面，它

1564
01:02:33,030 --> 01:02:34,440
不知道也不

1565
01:02:34,440 --> 01:02:38,490
关心页面是属于数据

1566
01:02:38,490 --> 01:02:43,620
表的两个部分还是属于索引，所以

1567
01:02:43,620 --> 01:02:44,910
思考的方式 他们正在做的是

1568
01:02:44,910 --> 01:02:48,080
，精益存储提供了一个基于页面层次结构的

1569
01:02:48,080 --> 01:02:50,970
分散式缓冲池管理器，

1570
01:02:50,970 --> 01:02:55,080
这意味着

1571
01:02:55,080 --> 01:02:58,200
它没有

1572
01:02:58,200 --> 01:02:59,790
像常规页表那样只有

1573
01:02:59,790 --> 01:03:03,150
一个将要组织的页面的无序列表

1574
01:03:03,150 --> 01:03:05,400
作为一个树结构，这个

1575
01:03:05,400 --> 01:03:07,470
想法将是你不能驱逐

1576
01:03:07,470 --> 01:03:09,870
一个主要的想法是你不能驱逐

1577
01:03:09,870 --> 01:03:14,940
一个子页面所以你可以 Victorino 它的

1578
01:03:14,940 --> 01:03:16,590
子页面已经被驱逐到

1579
01:03:16,590 --> 01:03:19,110
磁盘，然后现在也是因为它们

1580
01:03:19,110 --> 01:03:24,690
是 基于页面的

1581
01:03:24,690 --> 01:03:26,880
跟踪页面访问方式的开销

1582
01:03:26,880 --> 01:03:29,370
将比必须在每个

1583
01:03:29,370 --> 01:03:31,620
学生的基础上以及在我们在这里讨论的其他系统中进行的要少得多，

1584
01:03:31,620 --> 01:03:34,740
但是

1585
01:03:34,740 --> 01:03:36,030
现在您可以查看跟踪的方式很

1586
01:03:36,030 --> 01:03:37,740
有趣，因为它们 '实际上

1587
01:03:37,740 --> 01:03:39,690
大部分时间都不会跟踪

1588
01:03:39,690 --> 01:03:41,940
，所以他们

1589
01:03:41,940 --> 01:03:43,740
决定驱逐什么的方式是

1590
01:03:43,740 --> 01:03:47,820
随机选择一些页面，然后如果选择了一个

1591
01:03:47,820 --> 01:03:49,560
页面，那么他们开始

1592
01:03:49,560 --> 01:03:50,940
跟踪它是否被访问 sed

1593
01:03:50,940 --> 01:03:53,100
或者它是否被访问 然后

1594
01:03:53,100 --> 01:03:54,570
在某个时候当我们需要释放

1595
01:03:54,570 --> 01:03:56,760
空间时我们去查看

1596
01:03:56,760 --> 01:03:58,980
来自边缘的跟踪信息 最后

1597
01:03:58,980 --> 01:04:01,890
一轮随机选择页面 我们

1598
01:04:01,890 --> 01:04:02,880
找到那些没有

1599
01:04:02,880 --> 01:04:04,860
被访问的页面 Jordan 被访问 让我继续和

1600
01:04:04,860 --> 01:04:10,220
Vic 说得对，这样您只需打开

1601
01:04:10,220 --> 01:04:12,210
跟踪标识，

1602
01:04:12,210 --> 01:04:15,120
当您随机选择一个要被驱逐的页面时，该页面会发出通知，

1603
01:04:15,120 --> 01:04:16,980
因此我们

1604
01:04:16,980 --> 01:04:19,370
将更详细地介绍所有这些政策，

1605
01:04:19,370 --> 01:04:23,240
但关键是他们会 做

1606
01:04:23,240 --> 01:04:25,290
而不是使用墓碑而

1607
01:04:25,290 --> 01:04:27,210
不是使用布隆过滤器

1608
01:04:27,210 --> 01:04:28,440
他们要确定

1609
01:04:28,440 --> 01:04:30,740
内存中是否存在块或页面的关键是

1610
01:04:30,740 --> 01:04:32,880
通过一种称为指针啸叫的技术，

1611
01:04:32,880 --> 01:04:36,290
所以我认为我们没有涵盖

1612
01:04:36,290 --> 01:04:39,060
点呼啸 在介绍

1613
01:04:39,060 --> 01:04:40,530
类中讲了这么多，但现在我将

1614
01:04:40,530 --> 01:04:42,740
在高级类

1615
01:04:42,740 --> 01:04:45,230
中介绍指针哨声的想法是

1616
01:04:45,230 --> 01:04:49,500
我们将切换或

1617
01:04:49,500 --> 01:04:53,490
翻转一个对象具有的指针的内容

1618
01:04:53,490 --> 01:04:56,610
到另一个对象 ject 基于

1619
01:04:56,610 --> 01:04:58,350
我们是否

1620
01:04:58,350 --> 01:05:01,620
知道被指向的那个对象是否在

1621
01:05:01,620 --> 01:05:05,720
内存中，所以这个想法是这样的

1622
01:05:05,720 --> 01:05:09,540
，所以为了弄清楚这一点，我们只需要

1623
01:05:09,540 --> 01:05:12,420
在指针中使用一个位，所以我们将

1624
01:05:12,420 --> 01:05:15,120
使用第一个 稍微说一下

1625
01:05:15,120 --> 01:05:16,980
，如果它在内存中，则它在磁盘零上

1626
01:05:16,980 --> 01:05:20,460
，然后其余的 63 位和我们的

1627
01:05:20,460 --> 01:05:22,560
64 位指针实际上将

1628
01:05:22,560 --> 01:05:24,900
用于地址，这实际上也不

1629
01:05:24,900 --> 01:05:29,220
完全正确，因为在 x86 上，

1630
01:05:29,220 --> 01:05:32,400
当前架构仅使用

1631
01:05:32,400 --> 01:05:36,240
64 位地址的 48 位用于定义内存

1632
01:05:36,240 --> 01:05:38,610
中某些内容的内存位置，

1633
01:05:38,610 --> 01:05:39,840
这样它们实际上最多只能

1634
01:05:39,840 --> 01:05:42,990
存储 35 TB 的内存英特尔声称

1635
01:05:42,990 --> 01:05:44,460
他们最终会使用整个

1636
01:05:44,460 --> 01:05:48,710
64 位我在英特尔的一次演讲中

1637
01:05:48,710 --> 01:05:50,970
三四年前，他们说

1638
01:05:50,970 --> 01:05:53,190
不要在剩余的 16 位指针中存储任何额外的东西，

1639
01:05:53,190 --> 01:05:55,290


1640
01:05:55,290 --> 01:05:56,760
因为最终英特尔会使用它，

1641
01:05:56,760 --> 01:05:58,440
但就像我说的那样，这还没有

1642
01:05:58,440 --> 01:06:00,660
发生，据我所知它

1643
01:06:00,660 --> 01:06:02,250
仍然只是 48 位，所以你可以 使用

1644
01:06:02,250 --> 01:06:04,980
高 16 位做任何你想做的事情，所以

1645
01:06:04,980 --> 01:06:07,500
他们说我们这里有两个块

1646
01:06:07,500 --> 01:06:11,660
，块 b1 有一个指向块 b2 的指针，

1647
01:06:11,660 --> 01:06:16,710
所以当指针未售出时，意味着

1648
01:06:16,710 --> 01:06:19,230
它指向磁盘上的某些东西，那么

1649
01:06:19,230 --> 01:06:21,600
该位将被设置为 第一个

1650
01:06:21,600 --> 01:06:23,190
位将被设置为说它

1651
01:06:23,190 --> 01:06:26,760
在 Swizzle 上，然后我们将

1652
01:06:26,760 --> 01:06:28,590
只有我们的页面 ID 和偏移量，如 32

1653
01:06:28,590 --> 01:06:32,760
位页面 ID 32 位偏移量，但现在如果

1654
01:06:32,760 --> 01:06:36,090
我们总共不可见地 64 位，现在如果

1655
01:06:36,090 --> 01:06:38,230
我们实际上会

1656
01:06:38,230 --> 01:06:40,400
Swizzle 该地址，因为我们

1657
01:06:40,400 --> 01:06:43,010
将块引入内存会将

1658
01:06:43,010 --> 01:06:45,230
第一位翻转为零，说明

1659
01:06:45,230 --> 01:06:47,300
您正在查看的是真实的内存

1660
01:06:47,300 --> 01:06:49,400
地址而不是页面 ID 和偏移量，

1661
01:06:49,400 --> 01:06:51,410
然后剩余的位将用于

1662
01:06:51,410 --> 01:06:53,930
实际上指向内存位置，所以

1663
01:06:53,930 --> 01:06:55,550
发生的事情是当你传递

1664
01:06:55,550 --> 01:06:57,170
一个你在程序中知道的内存地址

1665
01:06:57,170 --> 01:06:58,760
说去访问这个东西让

1666
01:06:58,760 --> 01:07:01,130
我做一个加载你知道这个东西

1667
01:07:01,130 --> 01:07:02,840
没有被使用，因为它不是

1668
01:07:02,840 --> 01:07:05,420
48 位的一部分 x86 关心所以

1669
01:07:05,420 --> 01:07:07,130
它只是 被忽略，所以我们不认为我们

1670
01:07:07,130 --> 01:07:08,990
做任何特别的事情，当我们做一个记忆时，

1671
01:07:08,990 --> 01:07:10,490
你只需使用这些 Quizlet

1672
01:07:10,490 --> 01:07:13,070
地址查找港口只是

1673
01:07:13,070 --> 01:07:17,240
为我们处理它，所以你想要这样做的原因

1674
01:07:17,240 --> 01:07:19,550
是因为这将

1675
01:07:19,550 --> 01:07:21,950
允许 我们有一种分散的方式来

1676
01:07:21,950 --> 01:07:23,680
跟踪页面是否在内存中，

1677
01:07:23,680 --> 01:07:26,690
这就是页表

1678
01:07:26,690 --> 01:07:29,690
在基于磁盘的系统中会做的事情我是这个

1679
01:07:29,690 --> 01:07:33,380
巨大的地图，上面写着页面 ID 1 2 3 是

1680
01:07:33,380 --> 01:07:35,780
在磁盘中还是拥有一个 在内存中得分，

1681
01:07:35,780 --> 01:07:37,310
如果它在内存中，这里是它的地址，

1682
01:07:37,310 --> 01:07:40,970
或者 B+

1683
01:07:40,970 --> 01:07:42,410
树或 B 双树中的映射表本质

1684
01:07:42,410 --> 01:07:45,020
上是一样的，所以

1685
01:07:45,020 --> 01:07:47,930
如果我们

1686
01:07:47,930 --> 01:07:50,420
确保在我们的数据库系统中

1687
01:07:50,420 --> 01:07:53,240
只有一个块会有一个指向另一个块的指针，

1688
01:07:53,240 --> 01:07:55,880
那么我们知道

1689
01:07:55,880 --> 01:07:58,010
只有一个位置有

1690
01:07:58,010 --> 01:08:00,020
这个指向另一个块的指针，所以我们

1691
01:08:00,020 --> 01:08:01,550
可以对它进行比较和交换，以便

1692
01:08:01,550 --> 01:08:03,050
能够将其翻转为 Swizzle run

1693
01:08:03,050 --> 01:08:04,790
Swizzle 因为我们 不必

1694
01:08:04,790 --> 01:08:06,410
担心 尝试跨多个指针进行原子更新

1695
01:08:06,410 --> 01:08:09,140
，所以如果我们

1696
01:08:09,140 --> 01:08:13,010
现在像 B+ 树一样思考，我知道如果你忽略

1697
01:08:13,010 --> 01:08:15,170
它 7 个指针，你基本上会

1698
01:08:15,170 --> 01:08:16,880
免费获得它，因为那是你

1699
01:08:16,880 --> 01:08:21,560
知道它是一个无环图我

1700
01:08:21,560 --> 01:08:22,819
在其他人中说，你认为

1701
01:08:22,819 --> 01:08:24,350
lynnster 有趣吗，驱逐政策

1702
01:08:24,350 --> 01:08:26,600
是它维护 LRU 不是做一个

1703
01:08:26,600 --> 01:08:28,430
时钟它只是随机选择

1704
01:08:28,430 --> 01:08:32,660
一些块来驱逐，然后

1705
01:08:32,660 --> 01:08:34,130
弄清楚它们是否

1706
01:08:34,130 --> 01:08:36,319
真的会被访问所以这有

1707
01:08:36,319 --> 01:08:37,580
什么好处 是您不必

1708
01:08:37,580 --> 01:08:40,310
像我们在其他热数据方法中所做的那样维护任何元

1709
01:08:40,310 --> 01:08:43,100
数据，

1710
01:08:43,100 --> 01:08:45,319
因为如果它很热，那么您就不会跟踪

1711
01:08:45,319 --> 01:08:46,939
任何信息，但是如果它

1712
01:08:46,939 --> 01:08:49,010
可能很冷，那么您可以继续

1713
01:08:49,010 --> 01:08:50,800
跟踪这些信息

1714
01:08:50,800 --> 01:08:53,350
将会发生的事情是我修复了

1715
01:08:53,350 --> 01:08:55,450
一些块 我选择了一些要

1716
01:08:55,450 --> 01:08:58,180
驱逐的块 然后我将维护这个

1717
01:08:58,180 --> 01:09:00,670
全局哈希表 它将

1718
01:09:00,670 --> 01:09:04,569
跟踪跟踪信息 如何访问此

1719
01:09:04,569 --> 01:09:07,450
阻止程序 d 然后

1720
01:09:07,450 --> 01:09:09,220
如果我确定什么时候应该

1721
01:09:09,220 --> 01:09:10,540
释放一些内存，我会检查

1722
01:09:10,540 --> 01:09:12,550
那个哈希表，我看到这里

1723
01:09:12,550 --> 01:09:13,930
有一些尚未访问的块，

1724
01:09:13,930 --> 01:09:16,029
那么我知道它正在前进，

1725
01:09:16,029 --> 01:09:18,550
我可以安全地继续 并再次驱逐

1726
01:09:18,550 --> 01:09:20,500
他们会发生什么是我随机选择一些

1727
01:09:20,500 --> 01:09:22,420
块我要取消他们所有的

1728
01:09:22,420 --> 01:09:24,580
指针这意味着它会恢复

1729
01:09:24,580 --> 01:09:28,899
到页面ID和偏移量但我

1730
01:09:28,899 --> 01:09:32,710
实际上不会驱逐该块仍然

1731
01:09:32,710 --> 01:09:34,510
会坐在 内存，然后会

1732
01:09:34,510 --> 01:09:37,240
发生的情况是，如果现在出现一个线程或

1733
01:09:37,240 --> 01:09:39,899
查询运行，并且遇到

1734
01:09:39,899 --> 01:09:42,760
带有页面 ID 和偏移量的未售出指针，

1735
01:09:42,760 --> 01:09:45,490
我会

1736
01:09:45,490 --> 01:09:48,819
检查数据和冷却阶段的全局哈希表，如果

1737
01:09:48,819 --> 01:09:50,290
它在那里，那么 我知道它实际上

1738
01:09:50,290 --> 01:09:51,819
仍然在内存中，如果它不在那里，我就会去找出

1739
01:09:51,819 --> 01:09:54,910
它在哪里然后我知道

1740
01:09:54,910 --> 01:09:56,350
它实际上根本不记得

1741
01:09:56,350 --> 01:09:59,890
我去磁盘并获取它并将

1742
01:09:59,890 --> 01:10:01,390
显示一个示例

1743
01:10:01,390 --> 01:10:06,040
其次，关于精益存储的最后一件事

1744
01:10:06,040 --> 01:10:07,990
很重要 这

1745
01:10:07,990 --> 01:10:10,300
又是块层次结构，

1746
01:10:10,300 --> 01:10:13,570
没有集中的缓冲池表，

1747
01:10:13,570 --> 01:10:16,350
所以我们需要一种方法来确保

1748
01:10:16,350 --> 01:10:19,450
没有超过一个

1749
01:10:19,450 --> 01:10:23,110
指向数据库中块的指针，这样我就

1750
01:10:23,110 --> 01:10:25,330
可以解锁我的通道 或者

1751
01:10:25,330 --> 01:10:26,680
瑞士是我知道的一个地方

1752
01:10:26,680 --> 01:10:28,390
，它到处都被覆盖，

1753
01:10:28,390 --> 01:10:30,610
因此他们可以将其组织为树

1754
01:10:30,610 --> 01:10:32,920
层次结构，因此每个父级都可以有一个

1755
01:10:32,920 --> 01:10:35,380
指向子级的指针，并且该父级

1756
01:10:35,380 --> 01:10:36,610
是唯一一个具有指向该

1757
01:10:36,610 --> 01:10:40,300
给定块的指针的父级，所以在 索引 他们

1758
01:10:40,300 --> 01:10:41,920
已经像这样管理了，如果

1759
01:10:41,920 --> 01:10:43,990
可以的话，或者再次为

1760
01:10:43,990 --> 01:10:46,630
表堆提供一些指针，你必须将其组织

1761
01:10:46,630 --> 01:10:48,280
为层次结构，然后进行广度优先

1762
01:10:48,280 --> 01:10:52,120
搜索以进行扫描并认为在精益

1763
01:10:52,120 --> 01:10:53,410
商店的情况下总是有索引

1764
01:10:53,410 --> 01:10:54,940
组织 表，如果我是

1765
01:10:54,940 --> 01:10:56,470
兄弟，他们会做同样的事情，

1766
01:10:56,470 --> 01:11:00,520
所以你为什么要再次做好，

1767
01:11:00,520 --> 01:11:04,000
因为我知道

1768
01:11:04,000 --> 01:11:06,640
如果我想要维克多的父母，我不能将

1769
01:11:06,640 --> 01:11:09,700
它驱逐到磁盘，除非孩子们有 被

1770
01:11:09,700 --> 01:11:12,790
驱逐，这 防止我遇到这样

1771
01:11:12,790 --> 01:11:15,520
的情况，我驱逐了一个父母，但

1772
01:11:15,520 --> 01:11:16,660
它的孩子们不在内存

1773
01:11:16,660 --> 01:11:18,640
中，父母被写出光盘

1774
01:11:18,640 --> 01:11:21,520
，然后现在当它被

1775
01:11:21,520 --> 01:11:24,700
取回它会让你知道它什么时候被

1776
01:11:24,700 --> 01:11:27,760
写出来它会在

1777
01:11:27,760 --> 01:11:29,710
指向他们以前存在于内存中的孩子的内存指针，

1778
01:11:29,710 --> 01:11:31,240
但现在我

1779
01:11:31,240 --> 01:11:32,740
要回来那些记忆衣服现在

1780
01:11:32,740 --> 01:11:34,990
B 可能指向我的缓冲

1781
01:11:34,990 --> 01:11:38,320
池的帧，现在缓冲池现在有不同的页面

1782
01:11:38,320 --> 01:11:40,270
，所以现在我在那里

1783
01:11:40,270 --> 01:11:41,830
指着垃圾，他们不是

1784
01:11:41,830 --> 01:11:42,790
指他们是我应该

1785
01:11:42,790 --> 01:11:44,590
看或应该指的东西，

1786
01:11:44,590 --> 01:11:46,090
所以通过确保孩子

1787
01:11:46,090 --> 01:11:48,070
维克多先出去，孩子们被

1788
01:11:48,070 --> 01:11:50,440
驱逐，我现在更新父母，

1789
01:11:50,440 --> 01:11:52,660
必须拧开所以指向他的孩子的指针

1790
01:11:52,660 --> 01:11:54,820
当它被写出到磁盘

1791
01:11:54,820 --> 01:11:59,110
并且我把它带回来时，我可以使用

1792
01:11:59,110 --> 01:12:00,520
那些非社会化的指针来找到包含

1793
01:12:00,520 --> 01:12:02,080
我正在寻找的工具的页面，

1794
01:12:02,080 --> 01:12:04,000
所以就像我无法

1795
01:12:04,000 --> 01:12:04,570
获取一样，

1796
01:12:04,570 --> 01:12:07,090
我无法驱逐 父母之前

1797
01:12:07,090 --> 01:12:08,020
孩子们被驱逐了

1798
01:12:08,020 --> 01:12:10,360
我无法获取孩子，直到它的父级

1799
01:12:10,360 --> 01:12:12,880
被获取，你会

1800
01:12:12,880 --> 01:12:14,530
保证，因为一切都在这个

1801
01:12:14,530 --> 01:12:18,100
树层次结构中，所以让我们看

1802
01:12:18,100 --> 01:12:20,320
一个例子，所以我们将

1803
01:12:20,320 --> 01:12:22,030
再次组织它的方式说我们有一个真正的

1804
01:12:22,030 --> 01:12:23,770
只有四页的简单数据库

1805
01:12:23,770 --> 01:12:27,010
，所以我们将把

1806
01:12:27,010 --> 01:12:29,470
层次结构分成三个阶段，所以我们

1807
01:12:29,470 --> 01:12:30,760
有热阶段，所有东西都

1808
01:12:30,760 --> 01:12:33,820
在内存中，你有一个 Swizzle

1809
01:12:33,820 --> 01:12:35,710
指针，然后你有冷却阶段

1810
01:12:35,710 --> 01:12:37,540
，它仍然是这个 内存，但

1811
01:12:37,540 --> 01:12:39,220
你会有非社交指针，

1812
01:12:39,220 --> 01:12:41,260
然后你有一个冷阶段，

1813
01:12:41,260 --> 01:12:44,710
它在磁盘上用非社交指针出现所以

1814
01:12:44,710 --> 01:12:46,960
假设我运行我的驱逐

1815
01:12:46,960 --> 01:12:48,700
算法，随机选择一些

1816
01:12:48,700 --> 01:12:50,500
块写到磁盘，

1817
01:12:50,500 --> 01:12:53,740
假设我选择 b1 所以我现在要把它

1818
01:12:53,740 --> 01:12:56,500
移到冷却阶段，然后

1819
01:12:56,500 --> 01:12:58,690
我要把它添加到我的哈希

1820
01:12:58,690 --> 01:13:00,940
表中，它会再次跟踪

1821
01:13:00,940 --> 01:13:03,250
访问模式或访问这个块蛋的频率，

1822
01:13:03,250 --> 01:13:04,360


1823
01:13:04,360 --> 01:13:05,890
所以这个 哈希表基本上是

1824
01:13:05,890 --> 01:13:07,930
说 b1 这里是在这个驱逐队列中的哪里可以找到它

1825
01:13:07,930 --> 01:13:09,970
，然后

1826
01:13:09,970 --> 01:13:12,550
驱逐队列将具有

1827
01:13:12,550 --> 01:13:15,310
指向三分之二块的实际内存指针，所以

1828
01:13:15,310 --> 01:13:16,449
现在

1829
01:13:16,449 --> 01:13:20,079
发生的情况是如果如果然后当然

1830
01:13:20,079 --> 01:13:22,479
然后我 必须确保我现在再次更新

1831
01:13:22,479 --> 01:13:24,489
或作为来自我父块的指针，

1832
01:13:24,489 --> 01:13:27,699
如果有人出现

1833
01:13:27,699 --> 01:13:29,800
并试图访问 b1 他们将

1834
01:13:29,800 --> 01:13:31,809
不得不通过内存中的 b0 然后

1835
01:13:31,809 --> 01:13:33,489
他们会在 swizzle 指针上得到这个

1836
01:13:33,489 --> 01:13:35,590
但是然后我会 总是在

1837
01:13:35,590 --> 01:13:38,139
我的哈希表中查找，我会找到 ng for b1

1838
01:13:38,139 --> 01:13:39,820
找到驱逐队列中的位置

1839
01:13:39,820 --> 01:13:41,440
，这会给我真正的内存

1840
01:13:41,440 --> 01:13:43,780
地址，所以现在你现在要付出一些

1841
01:13:43,780 --> 01:13:46,119
代价，就像你有一个

1842
01:13:46,119 --> 01:13:47,800
间接层一样 以及

1843
01:13:47,800 --> 01:13:50,349
磁盘或数据库系统中的页表，但

1844
01:13:50,349 --> 01:13:53,349
实际上并没有那么糟糕，因为如果

1845
01:13:53,349 --> 01:13:55,599
这是热数据，那么第一次

1846
01:13:55,599 --> 01:13:57,070
发生这种情况时，我会将其

1847
01:13:57,070 --> 01:13:59,050
推回热阶段，将其

1848
01:13:59,050 --> 01:14:01,599
从驱逐队列中删除，然后 然后处置

1849
01:14:01,599 --> 01:14:03,969
的指针，所以只有一个查询

1850
01:14:03,969 --> 01:14:06,070
会付出这个代价，但如果它

1851
01:14:06,070 --> 01:14:08,139
真的很冷，那么实际上没有人

1852
01:14:08,139 --> 01:14:10,269
会遇到这个我必须

1853
01:14:10,269 --> 01:14:11,409
通过这个哈希表并最终

1854
01:14:11,409 --> 01:14:13,929
绕过磁盘，你知道没有伤害

1855
01:14:13,929 --> 01:14:16,510
没有犯规所以这个 实际上真的很

1856
01:14:16,510 --> 01:14:17,769
有趣，这个想法也是

1857
01:14:17,769 --> 01:14:19,749
为了这个驱逐提示正在

1858
01:14:19,749 --> 01:14:22,389
跟踪这个本质上是

1859
01:14:22,389 --> 01:14:24,519
自然地排序你知道

1860
01:14:24,519 --> 01:14:26,979
哪个是最新的最旧或

1861
01:14:26,979 --> 01:14:29,889
最新的付费块态度队列所以

1862
01:14:29,889 --> 01:14:31,420
现在如果我需要去 获取

1863
01:14:31,420 --> 01:14:34,239
磁盘上冷阶段的一些东西

1864
01:14:34,239 --> 01:14:36,309
并将其放入内存我只是将

1865
01:14:36,309 --> 01:14:37,630
它驱逐到队列的前面，将

1866
01:14:37,630 --> 01:14:40,809
它推到磁盘上，然后

1867
01:14:40,809 --> 01:14:42,670
将该空间用于元组或

1868
01:14:42,670 --> 01:14:45,249
我所在的块 需要，所以

1869
01:14:45,249 --> 01:14:48,550
在这个派克大衣质地中你只需要一个闩锁

1870
01:14:48,550 --> 01:14:50,679
，那是你

1871
01:14:50,679 --> 01:14:51,969
真正从冷却

1872
01:14:51,969 --> 01:14:54,190
阶段到冷却阶段写东西的时候，因为它们

1873
01:14:54,190 --> 01:14:55,630
只需要保护以确保

1874
01:14:55,630 --> 01:14:58,059
如果你试图驱逐一页 r

1875
01:14:58,059 --> 01:14:59,739
在您尝试取回该块的同时，受害者阻止了

1876
01:14:59,739 --> 01:15:02,889
您不想

1877
01:15:02,889 --> 01:15:03,969
在其中包含重复项并弄脏 gif

1878
01:15:03,969 --> 01:15:05,949
，因此只有一个锁存器您的

1879
01:15:05,949 --> 01:15:08,650
第三次使用来保护该并发

1880
01:15:08,650 --> 01:15:11,979
操作，但这非常罕见，所以 就像

1881
01:15:11,979 --> 01:15:14,289
我说的，这是一个

1882
01:15:14,289 --> 01:15:16,630
由德国人开发的原型系统，我认为

1883
01:15:16,630 --> 01:15:18,880
他们正在继续研究它，它

1884
01:15:18,880 --> 01:15:22,719
与 hyper 分开，它与我们接下来将讨论

1885
01:15:22,719 --> 01:15:24,670
的 Alma 项目分开，

1886
01:15:24,670 --> 01:15:26,389


1887
01:15:26,389 --> 01:15:31,460
所以 Umbra 是一个非常

1888
01:15:31,460 --> 01:15:32,929
德国人一直在构建的新系统

1889
01:15:32,929 --> 01:15:36,350
认为这就像 hyper 2.0，

1890
01:15:36,350 --> 01:15:38,360
他们实际上支持更大的

1891
01:15:38,360 --> 01:15:42,770
内存数据库，这

1892
01:15:42,770 --> 01:15:45,650
是精益商店提出的一种技术，该技术具有这种

1893
01:15:45,650 --> 01:15:48,770
层次结构，具有随机化的

1894
01:15:48,770 --> 01:15:51,409
随机驱逐专辑，但其中一个

1895
01:15:51,409 --> 01:15:52,280
有趣的事情

1896
01:15:52,280 --> 01:15:55,219
不同的是，他们将

1897
01:15:55,219 --> 01:15:58,699
支持可变大小的页面，因此在

1898
01:15:58,699 --> 01:16:01,880
精益商店的情况下，实际上

1899
01:16:01,880 --> 01:16:04,630
我们在页面之前展示的所有架构

1900
01:16:04,630 --> 01:16:07,040
在内存中组织

1901
01:16:07,040 --> 01:16:08,330
页面被

1902
01:16:08,330 --> 01:16:12,469
写入磁盘 我们在 Umbra 中总是相同的大小

1903
01:16:12,469 --> 01:16:14,210
他们要做的是他们

1904
01:16:14,210 --> 01:16:15,380
将允许您以

1905
01:16:15,380 --> 01:16:17,750
与在平板中相同的方式分配内存

1906
01:16:17,750 --> 01:16:19,760
像 je malloc 这样的分配器

1907
01:16:19,760 --> 01:16:22,520
，您可以在其中分配

1908
01:16:22,520 --> 01:16:24,409
不同大小的块，

1909
01:16:24,409 --> 01:16:26,810
它们总是与

1910
01:16:26,810 --> 01:16:29,449
以前的大小呈指数关系，然后现在您可以

1911
01:16:29,449 --> 01:16:32,500
寻址给定大小的整个块，

1912
01:16:32,500 --> 01:16:35,210
而不是您知道单个元组

1913
01:16:35,210 --> 01:16:36,860
或单个偏移量 在一个

1914
01:16:36,860 --> 01:16:40,850
块内，因此您

1915
01:16:40,850 --> 01:16:42,739
将获得的优势是对于

1916
01:16:42,739 --> 01:16:45,050
具有大型文本字段或字符串

1917
01:16:45,050 --> 01:16:47,570
或 varchars 或其他内部数据

1918
01:16:47,570 --> 01:16:49,100
结构（如压缩字典）的数据库

1919
01:16:49,100 --> 01:16:51,920
，您通常无法将它们存储在

1920
01:16:51,920 --> 01:16:56,179
单个页面中 现在可以避免

1921
01:16:56,179 --> 01:16:57,650
必须在内存中复制这些页面

1922
01:16:57,650 --> 01:16:59,389
并在

1923
01:16:59,389 --> 01:17:04,190
您从磁盘中获取内容时重新组合它们的开销，因此

1924
01:17:04,190 --> 01:17:05,510
德国人的人数实际上是一个

1925
01:17:05,510 --> 01:17:08,900
非常有趣的设计论点

1926
01:17:08,900 --> 01:17:11,500
这个系统，他们说

1927
01:17:11,500 --> 01:17:14,030
我们希望支持比内存更大的

1928
01:17:14,030 --> 01:17:16,280
数据库更好

1929
01:17:16,280 --> 01:17:20,179
有一个复杂的缓冲池管理器就像

1930
01:17:20,179 --> 01:17:21,020
在支持可变长度的情况下

1931
01:17:21,020 --> 01:17:22,850
更好

1932
01:17:22,850 --> 01:17:25,760
一个

1933
01:17:25,760 --> 01:17:27,770
更复杂或更难设计

1934
01:17:27,770 --> 01:17:30,530
的系统组件，因为您只

1935
01:17:30,530 --> 01:17:33,230
需要实现该部分一次，现在

1936
01:17:33,230 --> 01:17:35,060
系统的其余部分

1937
01:17:35,060 --> 01:17:36,409
最终将更容易开发，因为

1938
01:17:36,409 --> 01:17:39,020
现在您在此功能中拥有这种灵活性

1939
01:17:39,020 --> 01:17:39,860


1940
01:17:39,860 --> 01:17:43,460
可变大小的缓冲器 经理，

1941
01:17:43,460 --> 01:17:44,330
这就是我们在

1942
01:17:44,330 --> 01:17:49,070
开始时所说的，如果您

1943
01:17:49,070 --> 01:17:51,020
不想带回 Buffalo 经理

1944
01:17:51,020 --> 01:17:54,020
，然后必须重新构建整个

1945
01:17:54,020 --> 01:17:57,590
系统以解决您

1946
01:17:57,590 --> 01:17:59,180
可能正在访问未打开的数据这一事实

1947
01:17:59,180 --> 01:18:03,590
磁盘以同样的方式在这里

1948
01:18:03,590 --> 01:18:07,670
您不必担心以

1949
01:18:07,670 --> 01:18:10,040
各种方式将数据完全打包到一个页面中您

1950
01:18:10,040 --> 01:18:12,170
是固定的页面大小您可以分配所需的

1951
01:18:12,170 --> 01:18:13,340
正确内存量

1952
01:18:13,340 --> 01:18:16,370
无论您在做什么，

1953
01:18:16,370 --> 01:18:18,230
数据结构的算法

1954
01:18:18,230 --> 01:18:20,030
都建立在此之上，

1955
01:18:20,030 --> 01:18:23,000
布法罗经理不必

1956
01:18:23,000 --> 01:18:24,680
担心管理方式的复杂性，

1957
01:18:24,680 --> 01:18:26,780
所以我认为这实际上

1958
01:18:26,780 --> 01:18:29,150
非常有趣并且 - 这就是我的模型

1959
01:18:29,150 --> 01:18:30,290
和知识，这是唯一

1960
01:18:30,290 --> 01:18:31,670
一个真正做到这一点的数据系统，这

1961
01:18:31,670 --> 01:18:34,730
非常令人兴奋，所以就像在

1962
01:18:34,730 --> 01:18:36,620
精益商店中，他们将事物存储为

1963
01:18:36,620 --> 01:18:39,350
层次结构，但所有的表都将

1964
01:18:39,350 --> 01:18:41,000
是所有的关系都是排序的索引

1965
01:18:41,000 --> 01:18:42,800
组织的表所以基本上 所有

1966
01:18:42,800 --> 01:18:44,930
这有点像亲密关系进入数据库

1967
01:18:44,930 --> 01:18:46,970
，其中所有元组都存储在

1968
01:18:46,970 --> 01:18:49,610
B+ 树的叶页中，因此您可以获得

1969
01:18:49,610 --> 01:18:53,300
我们在精益存储中所需的自然层次结构，

1970
01:18:53,300 --> 01:18:56,000
其中每个孩子都

1971
01:18:56,000 --> 01:18:57,410
只有一个父母有一个指针 对

1972
01:18:57,410 --> 01:18:58,810
任何一个孩子

1973
01:18:58,810 --> 01:19:01,700
来说，这

1974
01:19:01,700 --> 01:19:03,260
只是对各种幻灯片缓冲池中正在发生的事情的高级概述，

1975
01:19:03,260 --> 01:19:05,450


1976
01:19:05,450 --> 01:19:08,000
而且它的工作方式是就像一个平板分配器，

1977
01:19:08,000 --> 01:19:10,520
他们将拥有一个小圆面包

1978
01:19:10,520 --> 01:19:11,750
缓冲池中不同大小类别的 ch 帧，对于较小的大小

1979
01:19:11,750 --> 01:19:14,120
类别，您将拥有更多的帧，而对于较大的类别，您将拥有

1980
01:19:14,120 --> 01:19:16,100
更少的

1981
01:19:16,100 --> 01:19:17,840
帧，因为您要分配

1982
01:19:17,840 --> 01:19:19,400
的大部分内存块

1983
01:19:19,400 --> 01:19:21,230
都将非常

1984
01:19:21,230 --> 01:19:24,350
小 所以大的小

1985
01:19:24,350 --> 01:19:26,120
边将是 64 KB 并且会上

1986
01:19:26,120 --> 01:19:30,380
升到 512 KB 所以在

1987
01:19:30,380 --> 01:19:31,790
缓冲帧中你会有

1988
01:19:31,790 --> 01:19:34,250
一些非活动和活动池实际上所有东西

1989
01:19:34,250 --> 01:19:35,990
都将使用 em map 进行管理

1990
01:19:35,990 --> 01:19:38,270
使用 anatomize m map 这给了

1991
01:19:38,270 --> 01:19:40,280
你一个虚拟内存，这

1992
01:19:40,280 --> 01:19:42,350
意味着我可以在这里分配所有这些

1993
01:19:42,350 --> 01:19:44,870
空间，但它实际上并没有

1994
01:19:44,870 --> 01:19:47,150
得到物理内存的支持，直到我继续

1995
01:19:47,150 --> 01:19:49,820
访问它，所以我可以分配

1996
01:19:49,820 --> 01:19:51,050
我需要缓冲

1997
01:19:51,050 --> 01:19:52,820
池的所有空间 数据库总大小的任何框架，

1998
01:19:52,820 --> 01:19:54,230


1999
01:19:54,230 --> 01:19:56,960
但我只有你知道操作系统实际上只会

2000
01:19:56,960 --> 01:19:59,290
在实际需要时支持它，

2001
01:19:59,290 --> 01:20:01,429
所以他们也会

2002
01:20:01,429 --> 01:20:03,530
像你在

2003
01:20:03,530 --> 01:20:05,750
精益商店中那样做指针吹口哨并且在 其他系统

2004
01:20:05,750 --> 01:20:07,760
但有趣的是在一个精益

2005
01:20:07,760 --> 01:20:10,730
商店案例中它只是如果它被吹口哨

2006
01:20:10,730 --> 01:20:12,290
它是一件记忆连衣裙并且它没有扭曲

2007
01:20:12,290 --> 01:20:15,440
这里是偏移量中的页面ID在这种

2008
01:20:15,440 --> 01:20:17,179
情况下在这里你

2009
01:20:17,179 --> 01:20:19,550
不再拥有页面中的所有集合，因为你“ 重新拥有一个

2010
01:20:19,550 --> 01:20:21,800
指向页面的细粒度指针，该指针

2011
01:20:21,800 --> 01:20:25,070
恰好具有您需要的内存，

2012
01:20:25,070 --> 01:20:26,690
因为它的大小合适，所以如果我

2013
01:20:26,690 --> 01:20:28,909
只需要 64 KB，那么我有一个

2014
01:20:28,909 --> 01:20:30,349
指向那 64 KB 的指针，

2015
01:20:30,349 --> 01:20:32,840
剩下的就是那些获得

2016
01:20:32,840 --> 01:20:35,300
64 的人 千字节，以便能够解释其

2017
01:20:35,300 --> 01:20:37,550
内容以获取正在查找的数据，

2018
01:20:37,550 --> 01:20:39,290
但我不需要

2019
01:20:39,290 --> 01:20:42,710
在非社交指针中记录该偏移量，但我确实

2020
01:20:42,710 --> 01:20:45,469
需要记录大小类，

2021
01:20:45,469 --> 01:20:47,389
以便当我去获取该块时我知道

2022
01:20:47,389 --> 01:20:50,119
我需要从哪个类别的数据中

2023
01:20:50,119 --> 01:20:52,040
获取它以及它实际上

2024
01:20:52,040 --> 01:20:53,869
将存储在某个磁盘中的大小，因为

2025
01:20:53,869 --> 01:20:56,239
同样具有虚拟内存的操作系统

2026
01:20:56,239 --> 01:20:59,570
不知道它不会

2027
01:20:59,570 --> 01:21:00,560
允许您使用这些内存

2028
01:21:00,560 --> 01:21:02,690
分配 或页面分配 来自

2029
01:21:02,690 --> 01:21:04,550
不同大小的它总是会是

2030
01:21:04,550 --> 01:21:07,280
你知道的默认值 4 KB 的任何东西，

2031
01:21:07,280 --> 01:21:09,079
或者你正在使用大页面，

2032
01:21:09,079 --> 01:21:11,060
无论是 2GB 的，它只

2033
01:21:11,060 --> 01:21:12,139
知道你有一些内存块，

2034
01:21:12,139 --> 01:21:14,570
所以它取决于数据库系统

2035
01:21:14,570 --> 01:21:16,429
能够 解释一下，您知道

2036
01:21:16,429 --> 01:21:18,949
对于

2037
01:21:18,949 --> 01:21:21,949
给定的页面大小，我实际上需要读取多少数据，这是

2038
01:21:21,949 --> 01:21:24,980
基于此处的大小类，所以我

2039
01:21:24,980 --> 01:21:27,020
认为这实际上是他们说的我的意思是

2040
01:21:27,020 --> 01:21:28,699
这真的很有趣，您知道

2041
01:21:28,699 --> 01:21:31,159
这是这篇论文 仅在

2042
01:21:31,159 --> 01:21:33,440
几个月前问世，据

2043
01:21:33,440 --> 01:21:35,360
我所知，没有其他系统实际实现这一点，

2044
01:21:35,360 --> 01:21:38,590
因此

2045
01:21:38,590 --> 01:21:40,579
您是否知道与精益商店之类的东西相比

2046
01:21:40,579 --> 01:21:43,790
，这是正确的

2047
01:21:43,790 --> 01:21:45,650
方法，但我绝对是非常

2048
01:21:45,650 --> 01:21:46,760
有前途的，我认为还有待观察 它比

2049
01:21:46,760 --> 01:21:49,010
我们

2050
01:21:49,010 --> 01:21:51,250
多年前在每个商店或

2051
01:21:51,250 --> 01:21:54,739
西伯利亚项目中所做的事情要好，所以实际上

2052
01:21:54,739 --> 01:21:55,520
最后要指出的

2053
01:21:55,520 --> 01:21:57,290
是，这些仍然是 64 位指针。

2054
01:21:57,290 --> 01:22:00,560
k ID 现在是 57 位，然后

2055
01:22:00,560 --> 01:22:05,260
这个大小等级只有 6 位，

2056
01:22:05,260 --> 01:22:07,760
所以我想谈论的最后一个方法

2057
01:22:07,760 --> 01:22:10,070
是 mem 续集，因为我

2058
01:22:10,070 --> 01:22:14,020
穿着老派的 minima 续集，所以

2059
01:22:14,020 --> 01:22:16,159
传统上你会选择什么 mem 续集

2060
01:22:16,159 --> 01:22:19,520
做的是，

2061
01:22:19,520 --> 01:22:22,849
即使在今天，当他们引入列存储时，您可以

2062
01:22:22,849 --> 01:22:25,909
声明您希望将表还原为行

2063
01:22:25,909 --> 01:22:27,889
存储并驻留在内存中，或者您

2064
01:22:27,889 --> 01:22:29,869
可以有一个表存在，或者您将一个

2065
01:22:29,869 --> 01:22:31,849
表声明为列存储并且实际上可以

2066
01:22:31,849 --> 01:22:34,099
由磁盘支持，但

2067
01:22:34,099 --> 01:22:37,940
没有办法声明一个

2068
01:22:37,940 --> 01:22:42,889
可以有但两种类型的逻辑表，

2069
01:22:42,889 --> 01:22:46,099
但是当他们第一次推出

2070
01:22:46,099 --> 01:22:50,389
列存储方法时，直到 2017 年，

2071
01:22:50,389 --> 01:22:52,550
他们使用 em map 来管理

2072
01:22:52,550 --> 01:22:54,170
页面 磁盘，但他们如此盲目地

2073
01:22:54,170 --> 01:22:57,380
使用映射，你知道这不是

2074
01:22:57,380 --> 01:22:59,090


2075
01:22:59,090 --> 01:23:00,679
Humber 所做的匿名内存内存虚拟内存分配，

2076
01:23:00,679 --> 01:23:03,560
所以他们很快发现这

2077
01:23:03,560 --> 01:23:05,239
实际上是一个坏主意，有一篇博客

2078
01:23:05,239 --> 01:23:06,530
文章表明他们

2079
01:23:06,530 --> 01:23:08,989
有点 一种 使用地图并获得糟糕的

2080
01:23:08,989 --> 01:23:10,639
性能，因此他们构建了自己的

2081
01:23:10,639 --> 01:23:15,080
缓冲区管理器，在那里他们将获取

2082
01:23:15,080 --> 01:23:17,590
列并将它们拆分为一个

2083
01:23:17,590 --> 01:23:20,090
具有 100 万个元组的段，并且

2084
01:23:20,090 --> 01:23:21,650
知道如何根据需要获取这些段，

2085
01:23:21,650 --> 01:23:26,290
但他们仍然有一个

2086
01:23:26,290 --> 01:23:30,170
用于

2087
01:23:30,170 --> 01:23:32,750
交易或 OTP 工作负载的单独

2088
01:23:32,750 --> 01:23:34,790
行存储是用于分析的单独列存储，

2089
01:23:34,790 --> 01:23:37,900
所以他们现在

2090
01:23:37,900 --> 01:23:41,840
在 2019 年宣布的是他们

2091
01:23:41,840 --> 01:23:43,940
称之为新的单一存储架构，在那里

2092
01:23:43,940 --> 01:23:46,730
你就像超级东西 或者

2093
01:23:46,730 --> 01:23:47,869
我们在我们自己的数据库系统中做的事情，在

2094
01:23:47,869 --> 01:23:50,270
那里你可以在

2095
01:23:50,270 --> 01:23:53,710
列存储的顶部进行交易，

2096
01:23:53,710 --> 01:23:56,659
有一篇这篇博客文章提出了

2097
01:23:56,659 --> 01:23:59,480
一堆关于你知道的声明，

2098
01:23:59,480 --> 01:24:01,219
让他们看起来像是 第一个

2099
01:24:01,219 --> 01:24:04,070
这样做并不是真的，

2100
01:24:04,070 --> 01:24:06,110
然后他们进行了一些优化来

2101
01:24:06,110 --> 01:24:08,719
处理

2102
01:24:08,719 --> 01:24:11,210
我们之前在

2103
01:24:11,210 --> 01:24:13,389
讨论数据类型时在行存储中看到的存储空值的大量开销，

2104
01:24:13,389 --> 01:24:17,060
但您知道这是 我有点

2105
01:24:17,060 --> 01:24:18,560
摆脱了将

2106
01:24:18,560 --> 01:24:20,960
不同的内存烘焙器和保姆

2107
01:24:20,960 --> 01:24:22,610
分开的平静存储，现在有一个

2108
01:24:22,610 --> 01:24:25,640
单一的列用于方法，

2109
01:24:25,640 --> 01:24:27,740
您可以知道将页面写入

2110
01:24:27,740 --> 01:24:29,690
磁盘目前尚不清楚他们如何决定将

2111
01:24:29,690 --> 01:24:31,220
哪些页面写入磁盘 我

2112
01:24:31,220 --> 01:24:34,010
怀疑这是一个基本的 LRU 或时钟

2113
01:24:34,010 --> 01:24:37,520
方法，所以现在回到我们相同的

2114
01:24:37,520 --> 01:24:39,410
分类法来讨论四个他们

2115
01:24:39,410 --> 01:24:41,600
不需要任何驱逐元数据，因为这

2116
01:24:41,600 --> 01:24:42,830
可以让我跟踪哪些页面

2117
01:24:42,830 --> 01:24:44,600
在其中，而不意味着内存或

2118
01:24:44,600 --> 01:24:46,070
不是内存 做 singham 的检索

2119
01:24:46,070 --> 01:24:47,320
，然后他总是把事情合并，

2120
01:24:47,320 --> 01:24:53,360
好吧，所以正如我

2121
01:24:53,360 --> 01:24:56,240
所说的，我们今天谈论

2122
01:24:56,240 --> 01:25:02,300
的只是处理带回

2123
01:25:02,300 --> 01:25:05,210
我阻止的磁盘，这

2124
01:25:05,210 --> 01:25:06,920
会很慢并且正在尝试 聪明

2125
01:25:06,920 --> 01:25:09,470
一点，以避免减慢或在

2126
01:25:09,470 --> 01:25:11,540
主要架构中，正如我多次说过的

2127
01:25:11,540 --> 01:25:12,080
，

2128
01:25:12,080 --> 01:25:14,300
我认为

2129
01:25:14,300 --> 01:25:16,580
精益商店 Umbra 中使用的块基或页括号方法是

2130
01:25:16,580 --> 01:25:18,290
正确的方法，并且是细粒度的

2131
01:25:18,290 --> 01:25:20,600
提取我们在其他

2132
01:25:20,600 --> 01:25:24,410
系统中所做的事情现在不是正确的

2133
01:25:24,410 --> 01:25:25,000
方法

2134
01:25:25,000 --> 01:25:28,010
关于此的另一个引擎问题是

2135
01:25:28,010 --> 01:25:29,830
，我今天在这里谈论的所有内容

2136
01:25:29,830 --> 01:25:33,590
最终都可能

2137
01:25:33,590 --> 01:25:37,400
在我们最终实现时全部无效和过时

2138
01:25:37,400 --> 01:25:41,890
便宜且快速的

2139
01:25:41,890 --> 01:25:45,140
字节可寻址非易失性内存，

2140
01:25:45,140 --> 01:25:46,820
这意味着内存进入

2141
01:25:46,820 --> 01:25:49,010
暗槽，然后您可以

2142
01:25:49,010 --> 01:25:50,570
像 DRAM 一样对其进行读写，

2143
01:25:50,570 --> 01:25:53,390
但是当您拔掉电源时，它会

2144
01:25:53,390 --> 01:25:57,320
像 SSD 一样持续

2145
01:25:57,320 --> 01:26:00,380
存在 港口实际上存在，我们将

2146
01:26:00,380 --> 01:26:02,450
在下周讨论，比如谈论

2147
01:26:02,450 --> 01:26:04,880
现在运行新硬件的数据库

2148
01:26:04,880 --> 01:26:08,000
SSD 或 HBO 的硬盘驱动器是

2149
01:26:08,000 --> 01:26:10,310
非易失性存储的全部，但在

2150
01:26:10,310 --> 01:26:13,940
未来真正的持久性内存或真正

2151
01:26:13,940 --> 01:26:17,000
的非易失性内存将使

2152
01:26:17,000 --> 01:26:18,020
我们今天讨论的所有内容我认为

2153
01:26:18,020 --> 01:26:21,350
没有必要，所以下节课

2154
01:26:21,350 --> 01:26:24,320
我们将讨论它的类型，

2155
01:26:24,320 --> 01:26:26,510
这是一个额外的主题，并不

2156
01:26:26,510 --> 01:26:28,010
完全适合我们讨论的每个

2157
01:26:28,010 --> 01:26:29,160
话题 只是

2158
01:26:29,160 --> 01:26:31,920
这是在数据库系统中获得重大性能改进的另一种方法，

2159
01:26:31,920 --> 01:26:33,510


2160
01:26:33,510 --> 01:26:35,010
如果您知道自己在做什么，那么

2161
01:26:35,010 --> 01:26:36,450
让我们讨论一种提高

2162
01:26:36,450 --> 01:26:40,260
性能的方法，我们将看到两种方法

2163
01:26:40,260 --> 01:26:47,520
，好吧，大家洗手

2164
01:26:47,520 --> 01:26:53,390
，这是什么

2165
01:26:53,550 --> 01:27:20,790
[音乐]

