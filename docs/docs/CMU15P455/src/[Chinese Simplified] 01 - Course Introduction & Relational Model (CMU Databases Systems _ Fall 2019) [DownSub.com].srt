1
00:00:17,590 --> 00:00:31,239
[音乐]

2
00:00:31,239 --> 00:00:35,059
欢迎来到新闻 EMU 1545 6:45

3
00:00:35,059 --> 00:00:37,579
数据库系统介绍 我

4
00:00:37,579 --> 00:00:38,930
叫 Andy 我是这门课程的讲师，

5
00:00:38,930 --> 00:00:42,680
正如我在 Piazza 上所说的，我现在不能在

6
00:00:42,680 --> 00:00:44,600
匹兹堡，我们正在

7
00:00:44,600 --> 00:00:46,879
为 Matt 的笼子战斗做好准备 星期三，

8
00:00:46,879 --> 00:00:49,970
所以我们不得不在洛杉矶

9
00:00:49,970 --> 00:00:53,510
为那场比赛做准备，所以与其

10
00:00:53,510 --> 00:00:55,190
在第一周不上课，

11
00:00:55,190 --> 00:00:57,829
我想在路上记录下来

12
00:00:57,829 --> 00:01:00,229
，然后在网上发布，

13
00:01:00,229 --> 00:01:02,629
然后当我们开始进入时——

14
00:01:02,629 --> 00:01:04,938
下周的课堂讲座我们可以开始

15
00:01:04,938 --> 00:01:07,760
讲好东西 所以在我们进入

16
00:01:07,760 --> 00:01:10,310
今天的讲座之前 我首先想

17
00:01:10,310 --> 00:01:12,979
谈谈 Oracle 如何在本学期帮助我们

18
00:01:12,979 --> 00:01:14,600
完成课程

19
00:01:14,600 --> 00:01:17,270
开发 所以 Oracle 实际上赢得

20
00:01:17,270 --> 00:01:19,130
了第一个关系数据库管理

21
00:01:19,130 --> 00:01:21,680
系统 1970 年代问世，

22
00:01:21,680 --> 00:01:22,909
我将在几张幻灯片中解释什么是关系数据库

23
00:01:22,909 --> 00:01:26,570
有一个

24
00:01:26,570 --> 00:01:29,630
原始的，但它今天仍然被广泛使用

25
00:01:29,630 --> 00:01:32,150
和销售 它可能是世界上

26
00:01:32,150 --> 00:01:35,030
第二大部署的数据库系统

27
00:01:35,030 --> 00:01:36,170
肯定

28
00:01:36,170 --> 00:01:37,580
是世界上部署最多的商业系统

29
00:01:37,580 --> 00:01:40,190
，所以即使它是 1970 年代的

30
00:01:40,190 --> 00:01:41,810
，还有 1970 年代的其他系统

31
00:01:41,810 --> 00:01:44,210
仍然存在或

32
00:01:44,210 --> 00:01:45,409
实际上仍在积极开发中，

33
00:01:45,409 --> 00:01:47,090
并且他们增加了很多你知道

34
00:01:47,090 --> 00:01:49,610
有趣的 它具有新的现代功能，所以

35
00:01:49,610 --> 00:01:52,159
这门课程是关于我的，我将

36
00:01:52,159 --> 00:01:53,600
称它为传统的数据库

37
00:01:53,600 --> 00:01:55,570
管理系统或经典设计

38
00:01:55,570 --> 00:01:57,860
，当他们来时看到有趣的事情，

39
00:01:57,860 --> 00:01:59,270
并在学期中进行客座

40
00:01:59,270 --> 00:02:00,500
讲座，谈论一些

41
00:02:00,500 --> 00:02:03,020
他们今天添加到 Oracle 的东西 你知道他们是

42
00:02:03,020 --> 00:02:05,210
如何超越你

43
00:02:05,210 --> 00:02:07,520
知道我们将在本课程中讨论的内容 以及

44
00:02:07,520 --> 00:02:09,348
一些更高级的

45
00:02:09,348 --> 00:02:13,879
主题 所以在本次讲座中我

46
00:02:13,879 --> 00:02:16,580
想首先讨论这些 或课程中

47
00:02:16,580 --> 00:02:18,830
预期内容的总体大纲，

48
00:02:18,830 --> 00:02:20,390
但您作为学生参加了

49
00:02:20,390 --> 00:02:23,180
它，然后我们将完成给他们

50
00:02:23,180 --> 00:02:25,819
关于关系模型

51
00:02:25,819 --> 00:02:27,620
和关系代数的半场讲座，这

52
00:02:27,620 --> 00:02:29,299
就是背景 d 你需要有

53
00:02:29,299 --> 00:02:32,450
我们将

54
00:02:32,450 --> 00:02:34,840
在本学期剩下的时间里讨论的各种主题，

55
00:02:34,840 --> 00:02:37,610
所以如果你是卡内基梅隆大学的学生，那么

56
00:02:37,610 --> 00:02:40,490


57
00:02:40,490 --> 00:02:42,170
你可能最关心的

58
00:02:42,170 --> 00:02:44,990
就是等待名单，所以很遗憾今年

59
00:02:44,990 --> 00:02:47,120
他们在玛格丽特莫里森给了我一个比我想要的更小的教室

60
00:02:47,120 --> 00:02:49,550
所以这

61
00:02:49,550 --> 00:02:51,410
意味着我们不能容纳很多

62
00:02:51,410 --> 00:02:54,680
人 我认为最大

63
00:02:54,680 --> 00:02:57,200
容量是 100 我认为就像 96

64
00:02:57,200 --> 00:02:59,000
在房间里我们可以淹没那个

65
00:02:59,000 --> 00:03:01,370
数字 一点点，但我的意思是主要的

66
00:03:01,370 --> 00:03:03,110
外卖是在这里我们不能接受

67
00:03:03,110 --> 00:03:06,140
每个人所以我认为现在的候补名单

68
00:03:06,140 --> 00:03:09,080
是 115，当我今天早些时候检查时很

69
00:03:09,080 --> 00:03:10,550
不幸，这意味着如果您

70
00:03:10,550 --> 00:03:12,080
此时没有注册课程

71
00:03:12,080 --> 00:03:13,550
的可能性 您进入

72
00:03:13,550 --> 00:03:16,580
的人数非常少，人们会

73
00:03:16,580 --> 00:03:19,550
在下周左右放弃课程，然后

74
00:03:19,550 --> 00:03:22,060
我们会将人们从候补名单中删除，但

75
00:03:22,060 --> 00:03:24,410
不幸的是蚂蚁会带走所有人，因此

76
00:03:24,410 --> 00:03:25,670
非常欢迎您订购

77
00:03:25,670 --> 00:03:27,020
课程 让我知道你正在

78
00:03:27,020 --> 00:03:30,379
审计 b 但我们不能正式

79
00:03:30,379 --> 00:03:33,020
持有那么多人，因此我们

80
00:03:33,020 --> 00:03:35,569
将在学生退学时招收学生的方式

81
00:03:35,569 --> 00:03:38,150
将只是您

82
00:03:38,150 --> 00:03:41,720
在注册网站上 s3 的候补名单位置，

83
00:03:41,720 --> 00:03:44,120
所以再次抱歉，这只是

84
00:03:44,120 --> 00:03:45,980
在线提供的所有内容 因此

85
00:03:45,980 --> 00:03:47,480
，如果您愿意，我们非常欢迎您继续学习，

86
00:03:47,480 --> 00:03:48,760


87
00:03:48,760 --> 00:03:54,050
所以 1545 645 是其核心

88
00:03:54,050 --> 00:03:56,150
课程是关于数据库管理系统的设计和

89
00:03:56,150 --> 00:03:58,790
实现，

90
00:03:58,790 --> 00:04:02,180
这意味着这不是

91
00:04:02,180 --> 00:04:05,239
关于如何使用数据库的课程

92
00:04:05,239 --> 00:04:06,830
像网站之类的应用程序一样构建

93
00:04:06,830 --> 00:04:08,090
，或者实际上已经

94
00:04:08,090 --> 00:04:09,769
管理了一个数据库 如何部署

95
00:04:09,769 --> 00:04:11,959
一个设置 我们没有做任何这些

96
00:04:11,959 --> 00:04:14,120
我们真正关注的是您如何

97
00:04:14,120 --> 00:04:16,789
实际构建和设计

98
00:04:16,789 --> 00:04:21,079
软件 一个数据库供应商系统，所以如果

99
00:04:21,079 --> 00:04:23,060
这不是你想要的，如果

100
00:04:23,060 --> 00:04:24,229
你不想知道如何拥有一个

101
00:04:24,229 --> 00:04:26,210
更好的数据库管理系统，

102
00:04:26,210 --> 00:04:28,039
那么你

103
00:04:28,039 --> 00:04:30,199
应该在大四时考虑另外两门课程，这些课程

104
00:04:30,199 --> 00:04:32,539
不在 SES，特别是

105
00:04:32,539 --> 00:04:35,030
你可能想看的那个是海因茨学院的 95 7 或 3

106
00:04:35,030 --> 00:04:36,830
我认为是信息

107
00:04:36,830 --> 00:04:38,900
系统，这也是关于

108
00:04:38,900 --> 00:04:41,599
如何设置和管理数据库

109
00:04:41,599 --> 00:04:43,159
管理系统，但你并不真正

110
00:04:43,159 --> 00:04:45,050
了解他们不了解 并没有真正

111
00:04:45,050 --> 00:04:46,580
详细说明您如何实际构建

112
00:04:46,580 --> 00:04:49,400
软件 人们经常问的另一件事

113
00:04:49,400 --> 00:04:51,500
是关于

114
00:04:51,500 --> 00:04:53,120
在 CMU

115
00:04:53,120 --> 00:04:56,300
ooh 15 415 615 上通常有一门课程是我和

116
00:04:56,300 --> 00:04:57,949
克里斯托弗·刘易斯教授过去教

117
00:04:57,949 --> 00:05:00,199
过的 提供

118
00:05:00,199 --> 00:05:02,150
的学期 我不知道它是否

119
00:05:02,150 --> 00:05:03,620
会在春季提供 可能

120
00:05:03,620 --> 00:05:05,090
不太可能

121
00:05:05,090 --> 00:05:07,250
所以现在我认为

122
00:05:07,250 --> 00:05:10,220
SES 中唯一可用的课程是这门课程

123
00:05:10,220 --> 00:05:13,840
4:45 然后是机器学习

124
00:05:13,840 --> 00:05:16,430
机器学习或交叉列出的 26 在

125
00:05:16,430 --> 00:05:20,690
cs 部门所以再次见面

126
00:05:20,690 --> 00:05:23,330
总是只有圣诞节我自己我们

127
00:05:23,330 --> 00:05:24,740
不能教所有东西所以不幸

128
00:05:24,740 --> 00:05:25,910
的是除了这个没有其他数据库课程

129
00:05:25,910 --> 00:05:30,020
所以

130
00:05:30,020 --> 00:05:32,270
课程大纲是 t 我们将

131
00:05:32,270 --> 00:05:35,090
要经历和讨论，然后你就会

132
00:05:35,090 --> 00:05:36,740
知道如何为评估构建面向磁盘的

133
00:05:36,740 --> 00:05:38,000
数据库，我将

134
00:05:38,000 --> 00:05:39,470


135
00:05:39,470 --> 00:05:41,660
在几节课中解释什么是 dis 坐标系，基本上我们

136
00:05:41,660 --> 00:05:43,610
只是将数据写出磁盘 我们

137
00:05:43,610 --> 00:05:46,400
假设数据库在磁盘上，所以它有点

138
00:05:46,400 --> 00:05:48,710
细分 我们将讨论的主题的大纲

139
00:05:48,710 --> 00:05:49,940
被细分并

140
00:05:49,940 --> 00:05:52,190
有点像系统的层，

141
00:05:52,190 --> 00:05:54,289
所以我们将在高层次上讨论

142
00:05:54,289 --> 00:05:56,479
关系数据库是什么以及 然后我们将

143
00:05:56,479 --> 00:05:57,860
讨论如何存储它们 有 x

144
00:05:57,860 --> 00:05:59,660
等于它们 如何在它们上运行事务

145
00:05:59,660 --> 00:06:01,639
如何在发生崩溃时恢复它们

146
00:06:01,639 --> 00:06:04,070
或者我们需要重新

147
00:06:04,070 --> 00:06:06,289
启动系统 到目前为止，恢复

148
00:06:06,289 --> 00:06:08,060
是您需要的核心知识

149
00:06:08,060 --> 00:06:10,370
必须了解数据库

150
00:06:10,370 --> 00:06:12,800
管理系统的工作原理，然后从

151
00:06:12,800 --> 00:06:14,030
那里我们可以在此基础上进行构建并

152
00:06:14,030 --> 00:06:17,120
开始讨论更多您知道的更

153
00:06:17,120 --> 00:06:18,919
高级的主题，例如分布式

154
00:06:18,919 --> 00:06:20,870
数据库或现有的各种其他类型的

155
00:06:20,870 --> 00:06:23,090
数据库或

156
00:06:23,090 --> 00:06:25,550
扩展 关系数据库

157
00:06:25,550 --> 00:06:26,780
再次思考这个问题的方式

158
00:06:26,780 --> 00:06:29,180
是，我们将经历

159
00:06:29,180 --> 00:06:31,160
如何实际构建系统的每一层，然后

160
00:06:31,160 --> 00:06:32,690
我们将完成和恢复，所以在

161
00:06:32,690 --> 00:06:34,550
这一点上，这是您需要

162
00:06:34,550 --> 00:06:36,470
了解的基础知识 数据库系统

163
00:06:36,470 --> 00:06:38,750
工作，然后我们将讨论

164
00:06:38,750 --> 00:06:40,220
您如何知道如何扩展它们以扩展

165
00:06:40,220 --> 00:06:43,039
它们或现在扩展运行和

166
00:06:43,039 --> 00:06:43,940
运行它们以及在云

167
00:06:43,940 --> 00:06:48,500
环境中，因此现在课程

168
00:06:48,500 --> 00:06:50,870
网站与

169
00:06:50,870 --> 00:06:53,210
教学大纲和 安排好基本

170
00:06:53,210 --> 00:06:56,120
大纲，每周有一次讲座

171
00:06:56,120 --> 00:06:58,010
，然后每堂课都会

172
00:06:58,010 --> 00:06:59,780
有一些阅读材料，

173
00:06:59,780 --> 00:07:01,490
但更好的补充内容扩展

174
00:07:01,490 --> 00:07:03,289
了我将要谈论的事情的种类，

175
00:07:03,289 --> 00:07:05,820
也提供了一些

176
00:07:05,820 --> 00:07:09,210
提及 其次，

177
00:07:09,210 --> 00:07:11,490
请随时参考课程网页，该网页

178
00:07:11,490 --> 00:07:14,310
应该是最新的，你知道它

179
00:07:14,310 --> 00:07:15,720
是关于正在

180
00:07:15,720 --> 00:07:19,080
发生的事情的最新信息，所以不幸的是，我们

181
00:07:19,080 --> 00:07:19,920
总是必须诚实地谈论学术，

182
00:07:19,920 --> 00:07:21,300
我”

183
00:07:21,300 --> 00:07:23,100
随着我们的进展，我会更详细地说明我的意思

184
00:07:23,100 --> 00:07:26,520
，但是当您有任何疑问

185
00:07:26,520 --> 00:07:29,430
并且您不明白时，

186
00:07:29,430 --> 00:07:32,970
请与我联系，以便我们讨论

187
00:07:32,970 --> 00:07:34,140
您正在做的事情是否可以被

188
00:07:34,140 --> 00:07:38,460
视为您知道抄袭或

189
00:07:38,460 --> 00:07:40,440
窃取别人的作品，

190
00:07:40,440 --> 00:07:42,210
所以总的来说，这是一门高级

191
00:07:42,210 --> 00:07:43,620
课程，所以每个人都应该意识到

192
00:07:43,620 --> 00:07:44,790
你不能很好地复制代码 不要

193
00:07:44,790 --> 00:07:46,020
在互联网上随意复制你

194
00:07:46,020 --> 00:07:47,790
不会互相复制，但你知道要

195
00:07:47,790 --> 00:07:49,140
非常小心，因为 我们会检查

196
00:07:49,140 --> 00:07:51,810
这些事情，正如我所说的

197
00:07:51,810 --> 00:07:53,160
，项目讲座的所有讨论和公告，

198
00:07:53,160 --> 00:07:56,340
家庭作业将是你

199
00:07:56,340 --> 00:07:58,320
在广场上进行大

200
00:07:58,320 --> 00:08:01,470
范围的评分，你的最终成绩将张贴在

201
00:08:01,470 --> 00:08:03,000
画布上，因为那是见过我一次

202
00:08:03,000 --> 00:08:04,920
但引爆的讨论将

203
00:08:04,920 --> 00:08:06,720
在广场上，

204
00:08:06,720 --> 00:08:08,070
现在课程网页上有一个链接，它会

205
00:08:08,070 --> 00:08:12,360
带你到我们的页面 有一本

206
00:08:12,360 --> 00:08:13,760
教科书为此课程

207
00:08:13,760 --> 00:08:16,320
数据库系统概念 所以这

208
00:08:16,320 --> 00:08:18,060
实际上是一个新版本

209
00:08:18,060 --> 00:08:20,100
我已经看过几乎

210
00:08:20,100 --> 00:08:21,840
所有适合的数据库系统教科书

211
00:08:21,840 --> 00:08:24,090
，在我看来，

212
00:08:24,090 --> 00:08:28,500
这实际上是最好的

213
00:08:28,500 --> 00:08:31,950
，它是最新的，正如我

214
00:08:31,950 --> 00:08:33,690
所说的，我们已经在上面 我

215
00:08:33,690 --> 00:08:35,429
有教科书未涵盖的主题的

216
00:08:35,429 --> 00:08:39,360
讲义 我必须给我麻省理工学院 我没有

217
00:08:39,360 --> 00:08:41,250
仔细查看第七版的细节

218
00:08:41,250 --> 00:08:42,630
以了解它

219
00:08:42,630 --> 00:08:44,370
在第六版中有多少不同所以如果你

220
00:08:44,370 --> 00:08:45,810
想获得第六版 版本我

221
00:08:45,810 --> 00:08:46,230
很好，

222
00:08:46,230 --> 00:08:47,640
我不认为应该有任何重大

223
00:08:47,640 --> 00:08:49,860
差异我只是可能不知道

224
00:08:49,860 --> 00:08:51,810
如何确切地查看上学期

225
00:08:51,810 --> 00:08:54,510


226
00:08:54,510 --> 00:08:56,850


227
00:08:56,850 --> 00:08:58,320
的章节上学期或开始去年的课程并查看带有章节编号的不同主题 因为

228
00:08:58,320 --> 00:08:59,940
他们已经改变了，我实际上

229
00:08:59,940 --> 00:09:01,500
不确定你是否可以再买这本书

230
00:09:01,500 --> 00:09:03,480
，就像你不能把它当作

231
00:09:03,480 --> 00:09:05,820
他们寄给我的装订书一样，你知道一堆

232
00:09:05,820 --> 00:09:08,070
松散的页面，或者你知道

233
00:09:08,070 --> 00:09:10,080
三个三环打孔器 在他们所以我

234
00:09:10,080 --> 00:09:11,940
不知道书店是什么 因为我

235
00:09:11,940 --> 00:09:14,060
不知道是否可以

236
00:09:14,060 --> 00:09:16,350
在第六版中在线提供它，但它

237
00:09:16,350 --> 00:09:17,190
可能已经足够好了，

238
00:09:17,190 --> 00:09:19,209
我们不会，我们不会，我们不会

239
00:09:19,209 --> 00:09:21,129


240
00:09:21,129 --> 00:09:22,959
直接提供任何作业或书中的任何问题，我们将提供

241
00:09:22,959 --> 00:09:26,379
一切都适合你 所以

242
00:09:26,379 --> 00:09:27,939
你在课堂上的成绩细目

243
00:09:27,939 --> 00:09:29,230
如下，

244
00:09:29,230 --> 00:09:32,379
所以家庭作业将是 15% 然后

245
00:09:32,379 --> 00:09:33,759
是课程项目，我将在下一秒讨论

246
00:09:33,759 --> 00:09:36,999
这将是 45% 所以对于

247
00:09:36,999 --> 00:09:40,929
你们中的那些人 是 CS 本科生，因为

248
00:09:40,929 --> 00:09:42,369
项目成绩你的最终成绩

249
00:09:42,369 --> 00:09:45,160
由 45 个参议院项目组成，这就是

250
00:09:45,160 --> 00:09:48,309
为什么这门课程计入 CS 本科课程的系统

251
00:09:48,309 --> 00:09:50,679
软件选修课

252
00:09:50,679 --> 00:09:53,470
，然后

253
00:09:53,470 --> 00:09:55,149
会有 20% 的期中和期末考试

254
00:09:55,149 --> 00:09:56,949
，然后在那里 将是一个额外的学分

255
00:09:56,949 --> 00:09:58,990
，我将在几周内宣布，届时

256
00:09:58,990 --> 00:10:01,179
您可以获得额外 10% 的奖励

257
00:10:01,179 --> 00:10:02,829
积分，这完全是

258
00:10:02,829 --> 00:10:06,429
可选的，因此整个学期将有五项作业

259
00:10:06,429 --> 00:10:09,910
，第一个

260
00:10:09,910 --> 00:10:11,889
将是续集作业

261
00:10:11,889 --> 00:10:13,329
给你续集 ke 数据库你必须

262
00:10:13,329 --> 00:10:15,850
为我们写一些查询，但之后的

263
00:10:15,850 --> 00:10:17,499
一切都将是铅笔和

264
00:10:17,499 --> 00:10:20,170
纸，因为这是一种解决

265
00:10:20,170 --> 00:10:22,300


266
00:10:22,300 --> 00:10:23,679
我们正在谈论的一些事情的那些更理论方面的方法，

267
00:10:23,679 --> 00:10:26,470
但它会像 填写

268
00:10:26,470 --> 00:10:27,759
多项选择，然后你只需拍下

269
00:10:27,759 --> 00:10:29,619
它的照片并将其上传到可能

270
00:10:29,619 --> 00:10:32,019
的范围内，并且会提供很好的

271
00:10:32,019 --> 00:10:34,569
方式，所以第一个任务是

272
00:10:34,569 --> 00:10:36,639
续集，因为你知道我们

273
00:10:36,639 --> 00:10:38,709
实际上不会为

274
00:10:38,709 --> 00:10:40,720
其余的写续集 因为课程

275
00:10:40,720 --> 00:10:42,399
项目不需要它，我

276
00:10:42,399 --> 00:10:44,559
认为你们至少接触

277
00:10:44,559 --> 00:10:46,720
一次我的大乐队的东西

278
00:10:46,720 --> 00:10:48,100
我们会在下学期再次讨论它

279
00:10:48,100 --> 00:10:50,110
，因为是关于说所有

280
00:10:50,110 --> 00:10:50,980
这些 家庭作业和项目都应该单独完成

281
00:10:50,980 --> 00:10:52,720
，但

282
00:10:52,720 --> 00:10:54,040
有人强调，就像

283
00:10:54,040 --> 00:10:55,929
不允许分组工作并

284
00:10:55,929 --> 00:10:57,309
试图弄清楚事情一样，这不像

285
00:10:57,309 --> 00:10:59,230
理论课，但所有这些都是

286
00:10:59,230 --> 00:11:01,179
可以完成的作业，并且应该完成

287
00:11:01,179 --> 00:11:04,029
单独完成的

288
00:11:04,029 --> 00:11:06,670
项目 这是我非常

289
00:11:06,670 --> 00:11:09,189
兴奋的项目，因此在

290
00:11:09,189 --> 00:11:10,749
整个学期中，您将从头开始构建自己的

291
00:11:10,749 --> 00:11:13,809
数据库存储管理器，因此

292
00:11:13,809 --> 00:11:15,999
您将开始逐个添加您知道的部分

293
00:11:15,999 --> 00:11:17,949
并开始构建辅助工具 或者一个

294
00:11:17,949 --> 00:11:20,290
功能齐全的数据库存储管理器，

295
00:11:20,290 --> 00:11:22,779
所以关键词是存储管理器

296
00:11:22,779 --> 00:11:25,299
而不是数据库系统，因为

297
00:11:25,299 --> 00:11:26,649
你不能运行续集或

298
00:11:26,649 --> 00:11:28,120
有查询解析器，

299
00:11:28,120 --> 00:11:30,430
但你将能够

300
00:11:30,430 --> 00:11:32,199
运行手动编码的查询 这将为您提供，所以

301
00:11:32,199 --> 00:11:34,569
它比

302
00:11:34,569 --> 00:11:36,459
那种简单的键值存储更复杂，但

303
00:11:36,459 --> 00:11:38,740
它不像一个成熟的系统，

304
00:11:38,740 --> 00:11:40,449
所以关键是它对

305
00:11:40,449 --> 00:11:43,959
你来说非常重要，你知道

306
00:11:43,959 --> 00:11:45,999
跟上 项目，

307
00:11:45,999 --> 00:11:47,769
因为每个项目都将

308
00:11:47,769 --> 00:11:49,509
一个接一个地构建，所以你

309
00:11:49,509 --> 00:11:51,129
必须让第一个项目

310
00:11:51,129 --> 00:11:52,959
正常工作才能使第二个

311
00:11:52,959 --> 00:11:54,279
项目正常工作，第三个项目

312
00:11:54,279 --> 00:11:57,339
以此类推，所以这个特殊

313
00:11:57,339 --> 00:11:58,990
我们本学期使用的系统

314
00:11:58,990 --> 00:12:02,379
完全是用 c-plus 17 编写的，这并不

315
00:12:02,379 --> 00:12:03,610
意味着我们使用了第

316
00:12:03,610 --> 00:12:05,470
17 条睡眠法则的所有高级功能，这只是

317
00:12:05,470 --> 00:12:08,290
意味着你知道它不像

318
00:12:08,290 --> 00:12:11,829
你知道 C 2099 所以传统的

319
00:12:11,829 --> 00:12:13,089
单加你可能已经在其他课程中学到了

320
00:12:13,089 --> 00:12:15,970
所以因为这是

321
00:12:15,970 --> 00:12:18,129
卡内基梅隆大学，我认为这是

322
00:12:18,129 --> 00:12:21,339
高级课程我不会忽视

323
00:12:21,339 --> 00:12:23,740
TAS 将教你或教你

324
00:12:23,740 --> 00:12:26,740
如何编写或调试 C++ 我发送了一个

325
00:12:26,740 --> 00:12:29,350
自我 - 在 Piazza 考试如果你觉得

326
00:12:29,350 --> 00:12:31,629
你对你知道这些

327
00:12:31,629 --> 00:12:35,050
是 C++ 的粗糙方面感到不舒服，那么你

328
00:12:35,050 --> 00:12:36,999
应该试着弄清楚我们

329
00:12:36,999 --> 00:12:39,759
现在如何开始学习这些东西，你

330
00:12:39,759 --> 00:12:41,709
不能作为 TAS 办公室来找我们 几个小时

331
00:12:41,709 --> 00:12:43,660
然后说嘿你知道什么是堆栈

332
00:12:43,660 --> 00:12:47,110
跟踪意味着你知道这次

333
00:12:47,110 --> 00:12:48,790
真的希望它讨论

334
00:12:48,790 --> 00:12:50,679
为他们提供更高级的重要

335
00:12:50,679 --> 00:12:52,240
数据库概念，你

336
00:12:52,240 --> 00:12:57,339
试图在你的代码中实现，所以所有的

337
00:12:57,339 --> 00:13:00,790
项目 今年将

338
00:13:00,790 --> 00:13:02,980
在这个新的 acad 上实施 我们

339
00:13:02,980 --> 00:13:04,839
一直在研究的 emic 系统叫做 bust ugh

340
00:13:04,839 --> 00:13:07,149
所以所有的源代码都将

341
00:13:07,149 --> 00:13:09,459
在 github 上发布当然显然它不会

342
00:13:09,459 --> 00:13:11,050


343
00:13:11,050 --> 00:13:13,149
有你选择实现的部分的实现但是你

344
00:13:13,149 --> 00:13:16,209
有点填写所以在 高级它是

345
00:13:16,209 --> 00:13:18,249
一个基于磁盘的磁盘或需要一个数据

346
00:13:18,249 --> 00:13:19,389
管理系统的磁盘，该系统将支持

347
00:13:19,389 --> 00:13:23,019
火山式查询处理

348
00:13:23,019 --> 00:13:24,759
系统的不同部分有一种

349
00:13:24,759 --> 00:13:26,800
可插拔的 API，以便我们可以插入

350
00:13:26,800 --> 00:13:29,379
不同的你知道替换

351
00:13:29,379 --> 00:13:31,149
算法被赋予不同的索引

352
00:13:31,149 --> 00:13:32,860
数据结构 或不同的日志记录

353
00:13:32,860 --> 00:13:34,689
方案或控制方案，所以它被

354
00:13:34,689 --> 00:13:36,549
设计成这样，这样

355
00:13:36,549 --> 00:13:38,410
每年都会完全切换项目，

356
00:13:38,410 --> 00:13:40,499


357
00:13:40,499 --> 00:13:42,119
并在一年与下一年之间保持不同的形式

358
00:13:42,119 --> 00:13:43,439
，并且会慢慢地

359
00:13:43,439 --> 00:13:45,269
进一步构建系统，并具有新的

360
00:13:45,269 --> 00:13:47,789
特性和功能 所以你

361
00:13:47,789 --> 00:13:49,229
知道几年后我们将拥有一个

362
00:13:49,229 --> 00:13:51,509
成熟的数据库分钟系统所以

363
00:13:51,509 --> 00:13:52,589
你们是第一个

364
00:13:52,589 --> 00:13:55,139
开始这些第一组

365
00:13:55,139 --> 00:13:57,269
项目的人 然后明年会

366
00:13:57,269 --> 00:13:59,579
修改它们的内容会有所不同，

367
00:13:59,579 --> 00:14:01,199
所以出于这个原因，我们可以

368
00:14:01,199 --> 00:14:04,439
将其开源，因为我不

369
00:14:04,439 --> 00:14:06,209
担心您认识的人

370
00:14:06,209 --> 00:14:07,619
明年会发现您的蹩脚

371
00:14:07,619 --> 00:14:09,719
项目实现并复制

372
00:14:09,719 --> 00:14:10,769
他们的代码 因为这

373
00:14:10,769 --> 00:14:12,629
是完全不同的所有项目，所以这

374
00:14:12,629 --> 00:14:14,549
就是我在上一张幻灯片之前所说的

375
00:14:14,549 --> 00:14:15,929
，您基本上擅长于存储

376
00:14:15,929 --> 00:14:17,909
管理器数据库系统此时不

377
00:14:17,909 --> 00:14:19,439
支持 Seco，本学期也不会支持，

378
00:14:19,439 --> 00:14:22,289
但您” 将

379
00:14:22,289 --> 00:14:23,819
能够编写查询，但您将以

380
00:14:23,819 --> 00:14:26,819
物理运算符的形式编写它们，而

381
00:14:26,819 --> 00:14:28,769
不是您在续集中知道然后

382
00:14:28,769 --> 00:14:29,969
翻译它们，因为这

383
00:14:29,969 --> 00:14:31,829
不是我们正在做的事情，所以

384
00:14:31,829 --> 00:14:34,199
系统的名称是 bus tub 我会

385
00:14:34,199 --> 00:14:37,709
离线解释这意味着什么，但我们制作

386
00:14:37,709 --> 00:14:40,799
了一个漂亮的徽标徽标，并且再次

387
00:14:40,799 --> 00:14:43,169
在 github 上宣布了我们将

388
00:14:43,169 --> 00:14:45,959
在一两周内在 Piazza 上发布链接 Wellmy 现在

389
00:14:45,959 --> 00:14:47,609
这是第一个项目所以我很

390
00:14:47,609 --> 00:14:49,499
高兴有这个 e

391
00:14:49,499 --> 00:14:52,349
这个学期有一个人在这个学期

392
00:14:52,349 --> 00:14:53,879
做作业和项目的延迟政策，

393
00:14:53,879 --> 00:14:56,699
每个学生都有

394
00:14:56,699 --> 00:14:59,970
休息日，所以基本上对于

395
00:14:59,970 --> 00:15:02,549
你说的任何家庭作业或项目，我你知道我找到了我的

396
00:15:02,549 --> 00:15:04,470
日常，你可以从

397
00:15:04,470 --> 00:15:04,949
你的

398
00:15:04,949 --> 00:15:08,369
帐户中减少 在每个家庭作业和

399
00:15:08,369 --> 00:15:10,259
项目提交上，您只需说明

400
00:15:10,259 --> 00:15:11,879
您使用了多少个迟到的天数，您离开了多少个女士，

401
00:15:11,879 --> 00:15:14,129
这样就可以让自己

402
00:15:14,129 --> 00:15:16,589
跟踪您所知道的有多少个

403
00:15:16,589 --> 00:15:19,470
迟到天数，以便在您

404
00:15:19,470 --> 00:15:22,019
用完滑动天数后 那么你会

405
00:15:22,019 --> 00:15:24,299
因为每一次和西蒙的

406
00:15:24,299 --> 00:15:26,729
总分损失 25% 每次它是

407
00:15:26,729 --> 00:15:29,879
每 24 小时就晚了所以

408
00:15:29,879 --> 00:15:31,169
这不会继续吸引我们，因为

409
00:15:31,169 --> 00:15:32,970
我们在学期中

410
00:15:32,970 --> 00:15:34,769
很明显如果有医疗 弹药

411
00:15:34,769 --> 00:15:36,299
或其他出现的问题请

412
00:15:36,299 --> 00:15:40,139
与我联系，我们可以再次为您提供服务，

413
00:15:40,139 --> 00:15:42,719
正如我之前所说的，所有这些

414
00:15:42,719 --> 00:15:44,459
项目和家庭作业都应该单独完成，

415
00:15:44,459 --> 00:15:46,169
它们不是小组

416
00:15:46,169 --> 00:15:48,449
作业，您不能工作

417
00:15:48,449 --> 00:15:49,919
一起出来并一起提交一个

418
00:15:49,919 --> 00:15:50,459
提交

419
00:15:50,459 --> 00:15:51,570


420
00:15:51,570 --> 00:15:52,500
你应该单独做所有的事情

421
00:15:52,500 --> 00:15:56,820
现在一些

422
00:15:56,820 --> 00:15:59,190
项目的一些代码可能仍然在线 来自

423
00:15:59,190 --> 00:16:01,680
愿望或前几年

424
00:16:01,680 --> 00:16:03,720
不要认为我们会

425
00:16:03,720 --> 00:16:05,820
通过老大球员抄袭

426
00:16:05,820 --> 00:16:08,160
检查器来运行它，如果 不幸的是，我们发现你在运行他们

427
00:16:08,160 --> 00:16:10,380
糟糕的代码，你知道我们

428
00:16:10,380 --> 00:16:11,910
必须向华纳音乐厅报告我，所以不

429
00:16:11,910 --> 00:16:13,459
要这样做，因为你知道你知道

430
00:16:13,459 --> 00:16:15,899
这很愚蠢，它会毁了你的生活，

431
00:16:15,899 --> 00:16:19,050
它让一切变得更难，只是

432
00:16:19,050 --> 00:16:21,540
不要不要 不要剽窃好吧，是的，如果

433
00:16:21,540 --> 00:16:24,600
你不确定检查学术

434
00:16:24,600 --> 00:16:26,370
政策或学术诚信政策，或者

435
00:16:26,370 --> 00:16:28,050
如果你不确定该

436
00:16:28,050 --> 00:16:29,819
怎么做，请联系我，这也包括

437
00:16:29,819 --> 00:16:33,389
额外的学分，只是因为它是额外的

438
00:16:33,389 --> 00:16:35,009
学分，它是可选的

439
00:16:35,009 --> 00:16:37,079
这并不意味着你也不能因为抄袭而被抓，

440
00:16:37,079 --> 00:16:38,639
所以不要这样做，

441
00:16:38,639 --> 00:16:40,170
每次我们推出一个新项目时，我都会提醒你

442
00:16:40,170 --> 00:16:41,850
每次你

443
00:16:41,850 --> 00:16:43,649
知道我们会告诉你为什么额外的功劳

444
00:16:43,649 --> 00:16:46,949
没问题 对 所以如果你想

445
00:16:46,949 --> 00:16:48,209
超越我们在

446
00:16:48,209 --> 00:16:50,490
这门课程中谈论的事情 如果你真的

447
00:16:50,490 --> 00:16:53,069
喜欢我做的数据库 你不

448
00:16:53,069 --> 00:16:56,790
知道我有多喜欢数据库 如果

449
00:16:56,790 --> 00:16:58,500
你想超越课程

450
00:16:58,500 --> 00:17:00,300
材料有两种

451
00:17:00,300 --> 00:17:02,579
参与卡内基梅隆大学正在进行的数据库研究或其他

452
00:17:02,579 --> 00:17:03,899
数据库主题的方法，

453
00:17:03,899 --> 00:17:07,409
因此 CMU 数据库小组

454
00:17:07,409 --> 00:17:10,439
每周一会在 4:30

455
00:17:10,439 --> 00:17:12,809
在 Gates gates 大楼有一个楼层，

456
00:17:12,809 --> 00:17:15,900
这是来自

457
00:17:15,900 --> 00:17:17,790
公司和个人的其他学生访客 在匹兹堡，来自

458
00:17:17,790 --> 00:17:20,130
国外的人来谈论

459
00:17:20,130 --> 00:17:21,839
你所知道的研究人员

460
00:17:21,839 --> 00:17:24,240
的工作类型 如果你

461
00:17:24,240 --> 00:17:25,470
想参与

462
00:17:25,470 --> 00:17:30,360
一种先进系统的开发 我们

463
00:17:30,360 --> 00:17:33,110
在周二 12 点召开团队会议

464
00:17:33,110 --> 00:17:35,669
也在大门大楼里，所以我们正在

465
00:17:35,669 --> 00:17:37,620
建设除了破坏

466
00:17:37,620 --> 00:17:39,480
学术系统之外，我们还有

467
00:17:39,480 --> 00:17:42,030
一种新的全功能数据库

468
00:17:42,030 --> 00:17:43,230
支付系统，我们已经做

469
00:17:43,230 --> 00:17:47,850
了好几年了 再说一次，如果你

470
00:17:47,850 --> 00:17:48,929
想参与这种

471
00:17:48,929 --> 00:17:50,880
事情，你应该过来看看，

472
00:17:50,880 --> 00:17:52,380
我会在这个广场上发一个提醒，

473
00:17:52,380 --> 00:17:54,210
它也会告诉你是否想在春天

474
00:17:54,210 --> 00:17:56,549
参加高级班

475
00:17:56,549 --> 00:17:59,669
15721 这些项目是

476
00:17:59,669 --> 00:18:01,650
基于这个我们正在构建的这个新的这个另一个

477
00:18:01,650 --> 00:18:04,740
系统所以如果你想得到

478
00:18:04,740 --> 00:18:04,920


479
00:18:04,920 --> 00:18:07,080
那个并且有点学习学习这个

480
00:18:07,080 --> 00:18:08,430
系统是如何工作的并参与到

481
00:18:08,430 --> 00:18:10,080
这个事情的早期阶段不要

482
00:18:10,080 --> 00:18:15,240
总是来这个好的

483
00:18:15,240 --> 00:18:17,160
所以这就是课程的内容 我的意思是

484
00:18:17,160 --> 00:18:18,360
如果你有任何

485
00:18:18,360 --> 00:18:20,610
关于在 Piazza 上发布的内容的问题，请在 Piazza 上指导他们

486
00:18:20,610 --> 00:18:24,450
，我会回答你的问题，所以现在让我们

487
00:18:24,450 --> 00:18:30,660
谈谈数据库，数据库

488
00:18:30,660 --> 00:18:34,460
在现实生活中非常重要，因为

489
00:18:34,460 --> 00:18:37,590
它们” 到处都在使用，但

490
00:18:37,590 --> 00:18:39,690
每一个复杂的都是能源和任何

491
00:18:39,690 --> 00:18:41,340
计算机应用程序，你可以

492
00:18:41,340 --> 00:18:43,050
在一天结束

493
00:18:43,050 --> 00:18:44,760
时在它的深处

494
00:18:44,760 --> 00:18:47,070
想到一个数据库，如果它是一个移动

495
00:18:47,070 --> 00:18:49,260
电话应用程序，如果它正在运行你的

496
00:18:49,260 --> 00:18:51,480
数据 esktop 如果它是一个网站 对 如果它是

497
00:18:51,480 --> 00:18:53,010
某种复杂的计算机

498
00:18:53,010 --> 00:18:55,020
模拟 一天结束时总会有一个

499
00:18:55,020 --> 00:18:56,850
数据库 每个人都有数据库问题

500
00:18:56,850 --> 00:18:58,830
很多事情都可以

501
00:18:58,830 --> 00:19:03,240
简化为数据库问题 所以

502
00:19:03,240 --> 00:19:05,280
我喜欢使用的数据库定义

503
00:19:05,280 --> 00:19:08,160
是 a 它是一组与以某种方式收集的数据相关的数据集合，它

504
00:19:08,160 --> 00:19:10,290


505
00:19:10,290 --> 00:19:12,300
试图对现实世界的某些方面进行建模，

506
00:19:12,300 --> 00:19:14,370
这不仅仅是

507
00:19:14,370 --> 00:19:16,560
您随机放在笔记本电脑上的一堆松散文件

508
00:19:16,560 --> 00:19:18,840
，而且在某些

509
00:19:18,840 --> 00:19:20,070
方面数据库但它是 不是真正

510
00:19:20,070 --> 00:19:21,240
有用的，因为你不能提出

511
00:19:21,240 --> 00:19:22,950
问题，所以这些数据

512
00:19:22,950 --> 00:19:25,260
通常是相关的，或者有一些

513
00:19:25,260 --> 00:19:27,660
共同的主题，它试图让

514
00:19:27,660 --> 00:19:29,400
你知道

515
00:19:29,400 --> 00:19:33,150
现实中发生的事情的某些方面，所以这个

516
00:19:33,150 --> 00:19:34,500
例子我总是喜欢 这个

517
00:19:34,500 --> 00:19:36,480
类的用途是说我们想要一个

518
00:19:36,480 --> 00:19:38,880
像

519
00:19:38,880 --> 00:19:42,420
Spotify 或 iTunes Store 这样的数字音乐商店，所以

520
00:19:42,420 --> 00:19:44,970
我们非常支持这个应用程序将

521
00:19:44,970 --> 00:19:47,790
是一个数据库，“ 将跟踪

522
00:19:47,790 --> 00:19:50,490
我们拥有的各种艺术家和他们的

523
00:19:50,490 --> 00:19:53,730
专辑，因此我们将放入

524
00:19:53,730 --> 00:19:55,770
此数据库的内容将是

525
00:19:55,770 --> 00:19:58,140
有关他们艺术家的基本信息，然后是

526
00:19:58,140 --> 00:19:59,910
有关这些艺术家发行的专辑的信息，

527
00:19:59,910 --> 00:20:02,460
这样就

528
00:20:02,460 --> 00:20:04,740
很酷了 那就是那个

529
00:20:04,740 --> 00:20:09,570
数据库 所以让我们看看我们

530
00:20:09,570 --> 00:20:12,150
现在如何实际构建一个

531
00:20:12,150 --> 00:20:14,940
可以存储这些信息的应用程序 所以

532
00:20:14,940 --> 00:20:16,680
假设你知道我们不知道我的任何

533
00:20:16,680 --> 00:20:18,090
数据库管理系统我们

534
00:20:18,090 --> 00:20:18,630
不知道

535
00:20:18,630 --> 00:20:20,220
我的续集我们不让 Oracle 我们

536
00:20:20,220 --> 00:20:21,240
不让邮递员我们不买任何东西

537
00:20:21,240 --> 00:20:23,010
所以我们在我们自己的应用程序中我们将

538
00:20:23,010 --> 00:20:25,350
自己编写这些代码 所以

539
00:20:25,350 --> 00:20:28,560
我们可以

540
00:20:28,560 --> 00:20:30,240
在我们的应用程序中实现和管理的最简单的数据库将

541
00:20:30,240 --> 00:20:33,480
只是我们存储我们的 数据和

542
00:20:33,480 --> 00:20:35,880
一堆逗号分隔值文件或 CSV

543
00:20:35,880 --> 00:20:38,820
文件，然后在我们的应用程序代码中，

544
00:20:38,820 --> 00:20:42,660
我们将编写

545
00:20:42,660 --> 00:20:45,480
读取这些数据和提取

546
00:20:45,480 --> 00:20:46,920
信息的方法的程序，我们需要回答四个

547
00:20:46,920 --> 00:20:49,230
问题 或正确查询它们，

548
00:20:49,230 --> 00:20:50,430
以便思考

549
00:20:50,430 --> 00:20:53,310
我们在我们的

550
00:20:53,310 --> 00:20:55,500
应用程序或数据库中的每个实体（如

551
00:20:55,500 --> 00:20:57,960
艺术家和专辑）的情况，将它们存储

552
00:20:57,960 --> 00:21:00,300
在一个单独的文件中，如艺术家 CSV

553
00:21:00,300 --> 00:21:03,360
专辑 CSV 然后我们 将有一些代码

554
00:21:03,360 --> 00:21:05,910
知道如何打开该文件 你

555
00:21:05,910 --> 00:21:07,680
知道每个部分来提取

556
00:21:07,680 --> 00:21:10,770
关于你的不同属性 你

557
00:21:10,770 --> 00:21:12,800
知道这些文件存储

558
00:21:12,800 --> 00:21:16,380
正确 所以假设

559
00:21:16,380 --> 00:21:19,320
我们在我们的

560
00:21:19,320 --> 00:21:21,510
数据库中有两到两个实体 艺术家和

561
00:21:21,510 --> 00:21:23,250
艺术家的权利在该国有一个年份

562
00:21:23,250 --> 00:21:25,410
然后我们有他们的专辑 我们有

563
00:21:25,410 --> 00:21:26,760
专辑的名称 艺术家们

564
00:21:26,760 --> 00:21:28,020
在这一年推出了正确的元素

565
00:21:28,020 --> 00:21:30,120
如果我们刚刚加入

566
00:21:30,120 --> 00:21:32,070
这个 作为 CSV 文件，我们

567
00:21:32,070 --> 00:21:35,160
将为每个属性

568
00:21:35,160 --> 00:21:40,070
加上引号，然后用逗号将它们分开，

569
00:21:40,070 --> 00:21:42,120
所以假设现在我们想编写一个

570
00:21:42,120 --> 00:21:47,190
查询，该查询可以查看您

571
00:21:47,190 --> 00:21:50,100
认识的艺术家文件并尝试

572
00:21:50,100 --> 00:21:52,380
找出我所在的年份 ce Cube 单独行动，所以

573
00:21:52,380 --> 00:21:54,960
Ice Cube 是洛杉矶 NWA 的创始成员

574
00:21:54,960 --> 00:21:59,670
，然后他离开了他们，

575
00:21:59,670 --> 00:22:01,400
因为金钱与他单独行动的任何事情都存在争议，

576
00:22:01,400 --> 00:22:04,320
所以如果我们可以的话，我们有 CSV 文件包含

577
00:22:04,320 --> 00:22:06,270
这些艺术家信息，你知道我们

578
00:22:06,270 --> 00:22:08,160
可以编写一些简单的 Python 代码

579
00:22:08,160 --> 00:22:10,110
只会遍历

580
00:22:10,110 --> 00:22:13,590
文件的每一行，我们将有一个

581
00:22:13,590 --> 00:22:14,880
函数来解析它，只是

582
00:22:14,880 --> 00:22:17,220
基本上将行拆分

583
00:22:17,220 --> 00:22:20,430
，用逗号将每一行拆分并返回一个

584
00:22:20,430 --> 00:22:22,800
属性数组，然后我们只需

585
00:22:22,800 --> 00:22:24,120
检查是否 第一个属性

586
00:22:24,120 --> 00:22:26,760
等于冰块，然后我们

587
00:22:26,760 --> 00:22:28,110
将第二个属性转换为

588
00:22:28,110 --> 00:22:29,880
整数 whoo 那是我们只

589
00:22:29,880 --> 00:22:30,370
打印

590
00:22:30,370 --> 00:22:33,520
正确的年份 非常简单的

591
00:22:33,520 --> 00:22:39,330
编码回答这个特定的查询 所以

592
00:22:39,330 --> 00:22:43,659
这种方法的一些问题 所以

593
00:22:43,659 --> 00:22:45,880
这将解决这些问题

594
00:22:45,880 --> 00:22:48,279
为什么你不想

595
00:22:48,279 --> 00:22:50,289
在你的应用程序中管理这样的数据然后

596
00:22:50,289 --> 00:22:52,360
有一个动机为什么我们想要

597
00:22:52,360 --> 00:22:55,230
构建它的通用目的或

598
00:22:55,230 --> 00:22:57,309
可以处理所有这些的数据库最小系统

599
00:22:57,309 --> 00:23:00,549
所以第一个问题

600
00:23:00,549 --> 00:23:01,779
是说您知道我们如何确保

601
00:23:01,779 --> 00:23:05,529
在我们的应用程序中，对于

602
00:23:05,529 --> 00:23:08,980
艺术家

603
00:23:08,980 --> 00:23:11,799
在该专辑专辑文件中列出的艺术家字段的每张专辑都

604
00:23:11,799 --> 00:23:13,330
保证相同，但我们如何

605
00:23:13,330 --> 00:23:14,320
知道我们不 'IceCube 没有拼写

606
00:23:14,320 --> 00:23:17,950
错误，然后如果我们

607
00:23:17,950 --> 00:23:19,419
最终这样做，你怎么知道如果

608
00:23:19,419 --> 00:23:21,039
说 Ice Cube 改变了他的名字，我们如何

609
00:23:21,039 --> 00:23:23,440
确保我们正确解决所有这些问题

610
00:23:23,440 --> 00:23:26,110
，下一个问题是我们如何

611
00:23:26,110 --> 00:23:28,779
确保 我们存储的数据是

612
00:23:28,779 --> 00:23:31,390
有效的 对不同类型的权利有效

613
00:23:31,390 --> 00:23:33,580
所以专辑年份应该是一个四位数，

614
00:23:33,580 --> 00:23:35,830
但是如果有人

615
00:23:35,830 --> 00:23:37,539
在那个地方放入一个随机字符串会发生什么，

616
00:23:37,539 --> 00:23:39,940
也许任何人都可以打开一个文件并

617
00:23:39,940 --> 00:23:41,919
修改它 因为它只是

618
00:23:41,919 --> 00:23:45,039
磁盘上的一个普通文件，但现在我们的应用程序进行

619
00:23:45,039 --> 00:23:47,380
了解析，它看到一个随机字符串，

620
00:23:47,380 --> 00:23:49,270
人们希望看到一个整数，它

621
00:23:49,270 --> 00:23:50,320
会抛出一个错误，因为这

622
00:23:50,320 --> 00:23:52,029
就像有人以一种我知道不期望的方式修改了这些数据

623
00:23:52,029 --> 00:23:55,929
然后

624
00:23:55,929 --> 00:23:58,510
下一个 问题是，如果我们现在有

625
00:23:58,510 --> 00:24:00,669
一张有多个艺术家的专辑，

626
00:24:00,669 --> 00:24:02,980
那会出现问题，因为

627
00:24:02,980 --> 00:24:06,970
我设置文件的方式只有一个艺术家

628
00:24:06,970 --> 00:24:10,029
期望字段正确，所以我可以尝试将其

629
00:24:10,029 --> 00:24:12,220
存储在

630
00:24:12,220 --> 00:24:14,620
引号中

631
00:24:14,620 --> 00:24:15,880
在那个东西里面分开，

632
00:24:15,880 --> 00:24:18,580
但现在我需要去看看

633
00:24:18,580 --> 00:24:19,990
每次我查看属性并

634
00:24:19,990 --> 00:24:22,600
说这是你知道这是

635
00:24:22,600 --> 00:24:24,789
艺术家的名字是一个数组本身还是

636
00:24:24,789 --> 00:24:28,419
只是你知道一个字符串所以 同样，您

637
00:24:28,419 --> 00:24:29,830
拥有处理应用程序中这些特定问题的所有专用逻辑的方法，

638
00:24:29,830 --> 00:24:31,360


639
00:24:31,360 --> 00:24:35,549


640
00:24:35,610 --> 00:24:38,250
因此实现这一点并不容易，

641
00:24:38,250 --> 00:24:41,010
所以我们如何实际找到记录，所以我

642
00:24:41,010 --> 00:24:42,600
展示了我的简单示例是一个

643
00:24:42,600 --> 00:24:45,030
用于迭代和解析的 for 循环 每一行都

644
00:24:45,030 --> 00:24:46,290
可以找到我正在寻找的记录

645
00:24:46,290 --> 00:24:49,680
，所以你知道我的示例文件

646
00:24:49,680 --> 00:24:51,960
有三行，所以这没什么大不了的，

647
00:24:51,960 --> 00:24:53,940
所以这可以很快完成，

648
00:24:53,940 --> 00:24:55,410
你知道如果

649
00:24:55,410 --> 00:24:58,980
我有十亿美元会怎样 在 Allen 上，我

650
00:24:58,980 --> 00:25:00,510
真的希望每次都打开文件

651
00:25:00,510 --> 00:25:02,160
扫描和解析

652
00:25:02,160 --> 00:25:03,570
每个文件以回答每个查询

653
00:25:03,570 --> 00:25:05,640
不对，因为这

654
00:25:05,640 --> 00:25:07,310
真的很慢

655
00:25:07,310 --> 00:25:10,410
现在下一个问题会说你

656
00:25:10,410 --> 00:25:11,910
知道我们在那个节目中的应用程序

657
00:25:11,910 --> 00:25:13,200
是写的 顺利地它看起来像

658
00:25:13,200 --> 00:25:15,780
Python 代码，但现在我

659
00:25:15,780 --> 00:25:17,610
想写另一个

660
00:25:17,610 --> 00:25:20,100
用另一种语言编写的应用程序，然后我

661
00:25:20,100 --> 00:25:22,170
想使用相同的数据库，

662
00:25:22,170 --> 00:25:24,300
所以假设我

663
00:25:24,300 --> 00:25:25,590
向您展示的示例代码正在运行在 Web 服务器上

664
00:25:25,590 --> 00:25:28,050
打开 一个文件解析它产生

665
00:25:28,050 --> 00:25:30,060
答案，但现在我有一个

666
00:25:30,060 --> 00:25:31,620
手机应用程序，它希望

667
00:25:31,620 --> 00:25:32,630
对同一个数据库的大多数访问

668
00:25:32,630 --> 00:25:35,160
以及我的 Bowl 手机应用程序可能不是

669
00:25:35,160 --> 00:25:36,330
用 Python 编写的，可能是用

670
00:25:36,330 --> 00:25:37,560
另一种语言编写的，因此既不

671
00:25:37,560 --> 00:25:40,320
重复我解析的所有逻辑

672
00:25:40,320 --> 00:25:44,670
文件在我的网络应用程序或任何

673
00:25:44,670 --> 00:25:46,710
其他应用程序中，当然现在

674
00:25:46,710 --> 00:25:47,940
我如何开始正确共享

675
00:25:47,940 --> 00:25:50,010
可能不会有问题的东西

676
00:25:50,010 --> 00:25:53,340
好吧，同样的

677
00:25:53,340 --> 00:25:55,470
事情如果我有两个线程或两个

678
00:25:55,470 --> 00:25:58,140
程序同时运行几个进程

679
00:25:58,140 --> 00:26:00,120
想要同时写入文件

680
00:26:00,120 --> 00:26:02,520
会发生什么

681
00:26:02,520 --> 00:26:04,740
如果我不做任何特别的事情会发生什么

682
00:26:04,740 --> 00:26:06,840
然后第一个人会写一些东西

683
00:26:06,840 --> 00:26:08,940
然后第二个人可能会覆盖

684
00:26:08,940 --> 00:26:10,680
它并且我不会丢失第一

685
00:26:10,680 --> 00:26:12,990
个人的任何更改所以现在我开始丢失数据

686
00:26:12,990 --> 00:26:15,360
或者我的数据最终变得

687
00:26:15,360 --> 00:26:17,790
无效因为它变得乱码所以

688
00:26:17,790 --> 00:26:23,810
这是有问题的所有

689
00:26:23,810 --> 00:26:29,160
最后一个问题是我如何确保

690
00:26:29,160 --> 00:26:33,300
我的数据是安全的，所以假设我正在

691
00:26:33,300 --> 00:26:36,090
更新记录 我打开一个文件我开始

692
00:26:36,090 --> 00:26:37,770
写入它但是在我完成

693
00:26:37,770 --> 00:26:41,430
我的更新之前机器崩溃了我的

694
00:26:41,430 --> 00:26:43,590
程序崩溃了会发生什么

695
00:26:43,590 --> 00:26:45,060
该更新应该在那里

696
00:26:45,060 --> 00:26:47,130
应该只更新一半我想我如何

697
00:26:47,130 --> 00:26:48,720
推理正确状态

698
00:26:48,720 --> 00:26:50,110
应该是

699
00:26:50,110 --> 00:26:52,760
什么如果我再次想说我

700
00:26:52,760 --> 00:26:54,350
不信任我正在运行的机器

701
00:26:54,350 --> 00:26:56,240
所以所以我 想要复制 我的

702
00:26:56,240 --> 00:26:57,980
数据库将我的文件存储到两台不同的

703
00:26:57,980 --> 00:27:00,529
机器上，这样如果一台机器崩溃

704
00:27:00,529 --> 00:27:02,600
了，另一台机器就可以继续运行，我可以

705
00:27:02,600 --> 00:27:03,919
继续运行，而没有人

706
00:27:03,919 --> 00:27:04,669
注意到

707
00:27:04,669 --> 00:27:06,470
我说所有美国人都使用分布式

708
00:27:06,470 --> 00:27:08,779
文件系统，但你知道这些事情

709
00:27:08,779 --> 00:27:11,210
并不普遍 - 目的通常并且对于

710
00:27:11,210 --> 00:27:17,059


711
00:27:17,059 --> 00:27:20,419
各种这些问题以及其他问题可能很难这样做，这

712
00:27:20,419 --> 00:27:22,669
就是为什么您不想编写

713
00:27:22,669 --> 00:27:24,260
我们讨论的那种

714
00:27:24,260 --> 00:27:26,720
解析文件并在您的

715
00:27:26,720 --> 00:27:29,980
应用程序中读取它的东西 想要卸载这个或者

716
00:27:29,980 --> 00:27:32,450
你想要所有那种复杂的逻辑

717
00:27:32,450 --> 00:27:34,880
或者如何管理数据库中的

718
00:27:34,880 --> 00:27:36,649
数据你想要一个日常

719
00:27:36,649 --> 00:27:39,919
管理系统来为你管理所以

720
00:27:39,919 --> 00:27:41,210
数据库管理系统是

721
00:27:41,210 --> 00:27:44,539
专门的软件，它允许

722
00:27:44,539 --> 00:27:46,250
应用程序在其中存储和分析

723
00:27:46,250 --> 00:27:48,169
信息 数据库，而

724
00:27:48,169 --> 00:27:49,760


725
00:27:49,760 --> 00:27:52,399
不必担心如何正确执行此操作的底层细节，

726
00:27:52,399 --> 00:27:54,440
而且它的软件可以

727
00:27:54,440 --> 00:27:56,419
从一个应用程序重复使用到下一个应用程序，这样

728
00:27:56,419 --> 00:27:57,610
您就不会重新发明

729
00:27:57,610 --> 00:28:03,649
重新开始，所以

730
00:28:03,649 --> 00:28:04,970


731
00:28:04,970 --> 00:28:07,149
我们将在本学期讨论的一般用途

732
00:28:07,149 --> 00:28:10,340
旨在允许应用程序定义

733
00:28:10,340 --> 00:28:13,130
针对更新和

734
00:28:13,130 --> 00:28:16,309
数据库部长的写入查询，并且出于我们的

735
00:28:16,309 --> 00:28:17,870
目的，我们将假设我们的 数据库

736
00:28:17,870 --> 00:28:20,000
存储在磁盘中 他们不一定

737
00:28:20,000 --> 00:28:21,919
必须像内存数据库

738
00:28:21,919 --> 00:28:23,690
或 GPU 数据库或其他

739
00:28:23,690 --> 00:28:27,200
类似的东西 我们讨论这些

740
00:28:27,200 --> 00:28:30,740
事情是的 但只要知道

741
00:28:30,740 --> 00:28:32,779
那里有各种不同的

742
00:28:32,779 --> 00:28:34,610
数据库 可以做

743
00:28:34,610 --> 00:28:35,750
很多不同的事情，让搜索

744
00:28:35,750 --> 00:28:37,399
以不同的方式针对

745
00:28:37,399 --> 00:28:40,909
各种应用程序进行专业化，所以

746
00:28:40,909 --> 00:28:44,450
我再次喜欢数据库，我希望我一直认为

747
00:28:44,450 --> 00:28:45,830
我喜欢写我的

748
00:28:45,830 --> 00:28:48,049
戴维斯或阅读我的数据库，嗯

749
00:28:48,049 --> 00:28:50,149
，你可能认为这是 疯狂

750
00:28:50,149 --> 00:28:51,620
为什么有人会如此喜欢数据

751
00:28:51,620 --> 00:28:53,299
系统的数据库，所以你必须

752
00:28:53,299 --> 00:28:54,980
在 CMU 理解和思考这个问题，

753
00:28:54,980 --> 00:28:56,990
我们是一所大学校，我们有

754
00:28:56,990 --> 00:29:01,130
课程，而且每 在这门操作系统课程中你知道的事情是对的

755
00:29:01,130 --> 00:29:02,059


756
00:29:02,059 --> 00:29:03,049
，fernette

757
00:29:03,049 --> 00:29:05,450
带来了类似的东西，但数据库

758
00:29:05,450 --> 00:29:07,279
系统是一类特殊

759
00:29:07,279 --> 00:29:09,619
的软件，它们非常重要

760
00:29:09,619 --> 00:29:11,659
，就像我这样的全职人员一样

761
00:29:11,659 --> 00:29:13,309
，当然就在这方面进行教学

762
00:29:13,309 --> 00:29:15,830
就像一个网络浏览器很重要，

763
00:29:15,830 --> 00:29:17,360
但没有任何课程我喜欢如何

764
00:29:17,360 --> 00:29:18,830
构建一个网络浏览器，至少

765
00:29:18,830 --> 00:29:22,190
就我所知，就像

766
00:29:22,190 --> 00:29:25,460
数据库一样普遍，并且

767
00:29:25,460 --> 00:29:29,059
在任何地方都如此广泛使用，而且它们

768
00:29:29,059 --> 00:29:30,590
真的很难 你知道让我工作并

769
00:29:30,590 --> 00:29:32,239
正确地让他们

770
00:29:32,239 --> 00:29:33,980
知道我们在这门课程中有一个完整的

771
00:29:33,980 --> 00:29:35,330
课程并讨论如何

772
00:29:35,330 --> 00:29:38,659
构建它所以我认为它们是一个

773
00:29:38,659 --> 00:29:40,850
独特的软件，我们

774
00:29:40,850 --> 00:29:43,970
的软件类绝对是一个

775
00:29:43,970 --> 00:29:46,249
现在的热门领域 你知道

776
00:29:46,249 --> 00:29:47,720
一天结束 机器学习你将这些数据

777
00:29:47,720 --> 00:29:51,889
存储在数据库中，你

778
00:29:51,889 --> 00:29:53,720
知道在每个应用程序中都是如此，正如我

779
00:29:53,720 --> 00:29:55,009
在一天结束时所说的那样，下面有一个

780
00:29:55,009 --> 00:29:57,109
数据库 它运行几乎

781
00:29:57,109 --> 00:29:59,690
所有东西，所以这就是为什么当然像

782
00:29:59,690 --> 00:30:01,929
这样，我的意见非常重要，

783
00:30:01,929 --> 00:30:04,580
所以数据库显然

784
00:30:04,580 --> 00:30:09,379
不是新系统，你知道第

785
00:30:09,379 --> 00:30:12,320
一个上线我想像 1965 年在

786
00:30:12,320 --> 00:30:17,179
通用电气，你知道

787
00:30:17,179 --> 00:30:18,350
人们有点 在计算的早期

788
00:30:18,350 --> 00:30:19,609
，然后人们很快

789
00:30:19,609 --> 00:30:20,989
意识到嘿，拥有

790
00:30:20,989 --> 00:30:22,369
专门的软件会很好，好吧，有一个

791
00:30:22,369 --> 00:30:25,340
可以为我们管理大型数据集的系统，

792
00:30:25,340 --> 00:30:27,919
所以您必须

793
00:30:27,919 --> 00:30:31,039
了解当时情况与现在不同

794
00:30:31,039 --> 00:30:33,409
在早期，

795
00:30:33,409 --> 00:30:34,249
我们将谈论这门课程的一些事情，我们

796
00:30:34,249 --> 00:30:35,600
现在认为这是理所当然的，因为哦

797
00:30:35,600 --> 00:30:37,159
，当然这就是你想要做

798
00:30:37,159 --> 00:30:39,169
的事情，就像在 1960

799
00:30:39,169 --> 00:30:41,090
年代 1970 年代，这并不明显

800
00:30:41,090 --> 00:30:45,049
做事的方式，所以特别是

801
00:30:45,049 --> 00:30:48,769
我喜欢谈论的故事回到了

802
00:30:48,769 --> 00:30:52,759
1960 年代中期，

803
00:30:52,759 --> 00:30:55,759
有一个人 Ted Cod 在 IBM

804
00:30:55,759 --> 00:30:58,220
研究部工作，当他被聘用在 IBM 研究部工作时，他是一名数学家

805
00:30:58,220 --> 00:30:59,989


806
00:30:59,989 --> 00:31:03,950
New York 和他注意到

807
00:31:03,950 --> 00:31:06,799
，从事数据库工作的人们花费

808
00:31:06,799 --> 00:31:10,009
大量时间一遍又一遍地重写他们的数据库

809
00:31:10,009 --> 00:31:12,159
应用程序，因为

810
00:31:12,159 --> 00:31:14,310


811
00:31:14,310 --> 00:31:16,950


812
00:31:16,950 --> 00:31:19,140
数据库中内容的逻辑层

813
00:31:19,140 --> 00:31:20,880
与数据的物理层之间存在紧密耦合。

814
00:31:20,880 --> 00:31:23,160
系统实际上是要存储它，所以

815
00:31:23,160 --> 00:31:25,590
我的意思是说你有

816
00:31:25,590 --> 00:31:27,960
一个数据库你想存储在这个数据

817
00:31:27,960 --> 00:31:29,490
系统中，你必须告诉你 David

818
00:31:29,490 --> 00:31:31,470
Bennett 系统哦，我希望你把它

819
00:31:31,470 --> 00:31:32,910
存储为一个哈希表，我想要你 将它

820
00:31:32,910 --> 00:31:34,860
存储为一棵树，然后当你这样做

821
00:31:34,860 --> 00:31:37,830
时，然后根据你选择的数据结构为你公开一个不同的 API

822
00:31:37,830 --> 00:31:40,050


823
00:31:40,050 --> 00:31:42,840
但现在说你改变

824
00:31:42,840 --> 00:31:44,700
主意了哦，是的，我告诉过你我是一个哈希

825
00:31:44,700 --> 00:31:46,020
表，但我真的想要 运行范围

826
00:31:46,020 --> 00:31:48,060
查询，所以现在我想做一个我

827
00:31:48,060 --> 00:31:50,790
想你知道存储为树所以

828
00:31:50,790 --> 00:31:51,930
你必须做的是转储你的所有

829
00:31:51,930 --> 00:31:55,170
数据改变你的应用程序代码

830
00:31:55,170 --> 00:31:57,870
现在调用树它是它的API

831
00:31:57,870 --> 00:32:00,570
在哈希表 API，然后你

832
00:32:00,570 --> 00:32:01,860
必须重新加载你的所有数据，然后

833
00:32:01,860 --> 00:32:05,310
再写一遍，不管你

834
00:32:05,310 --> 00:32:07,560
告诉数据供应商系统你希望它如何

835
00:32:07,560 --> 00:32:12,030
破坏数据，所以技术人员

836
00:32:12,030 --> 00:32:13,980
意识到这有点愚蠢，

837
00:32:13,980 --> 00:32:16,710
这是有问题的，因为它

838
00:32:16,710 --> 00:32:18,930
是人 基本上

839
00:32:18,930 --> 00:32:20,610
每次有这样的变化时都会一遍又一遍地重构代码，

840
00:32:20,610 --> 00:32:22,110


841
00:32:22,110 --> 00:32:25,440
所以现在人类

842
00:32:25,440 --> 00:32:27,930
比计算机便宜，所以

843
00:32:27,930 --> 00:32:29,190
你可以很容易地看到这是不可

844
00:32:29,190 --> 00:32:31,350
扩展的，现在

845
00:32:31,350 --> 00:32:35,250
亚马逊和微软的计算成本很低 和谷歌

846
00:32:35,250 --> 00:32:37,320
、云计算和人类是

847
00:32:37,320 --> 00:32:38,130
昂贵的东西

848
00:32:38,130 --> 00:32:39,690
所以这个问题是吃更多的

849
00:32:39,690 --> 00:32:41,070
问题 你知道这个

850
00:32:41,070 --> 00:32:42,360
问题今天更成问题 然后

851
00:32:42,360 --> 00:32:44,820
回到 1970 年代 但是你

852
00:32:44,820 --> 00:32:45,900
知道的 Tedcott 很快意识到人们正在

853
00:32:45,900 --> 00:32:48,780
浪费时间 修复

854
00:32:48,780 --> 00:32:50,210
他们不需要的硫，

855
00:32:50,210 --> 00:32:54,030
所以特德科克特提出的是这个

856
00:32:54,030 --> 00:32:56,490
叫做关系模型的东西，所以他

857
00:32:56,490 --> 00:32:59,180
在 1969 年发表了第一篇关于这个的论文

858
00:32:59,180 --> 00:33:01,890
但是每个人都引用

859
00:33:01,890 --> 00:33:04,020
的是 1970 年 ACM 的通讯中

860
00:33:04,020 --> 00:33:07,380
的

861
00:33:07,380 --> 00:33:08,550
一篇，所以大多数人都阅读

862
00:33:08,550 --> 00:33:11,010
了大型共享数据库的数据关系模型，

863
00:33:11,010 --> 00:33:12,690
但这

864
00:33:12,690 --> 00:33:14,660
是开创整个关系的开创性论文

865
00:33:14,660 --> 00:33:17,040
数据模型革命

866
00:33:17,040 --> 00:33:18,840
说这是你想要

867
00:33:18,840 --> 00:33:21,390
存储错误系统的方式，所以这是非常

868
00:33:21,390 --> 00:33:24,960
有影响力的，这是

869
00:33:24,960 --> 00:33:26,730
本课程的主干，

870
00:33:26,730 --> 00:33:30,090
所以 Ted Cobb 介绍

871
00:33:30,090 --> 00:33:32,700
了关系模型的三个关键租户

872
00:33:32,700 --> 00:33:36,510
建议首先

873
00:33:36,510 --> 00:33:38,010
我们将数据库

874
00:33:38,010 --> 00:33:41,100
作为关系存储在简单的数据结构中，因此

875
00:33:41,100 --> 00:33:43,620
关系并不意味着就像你知道我是

876
00:33:43,620 --> 00:33:45,990
你知道我与我的父母或

877
00:33:45,990 --> 00:33:48,630
任何葡萄干本质上是

878
00:33:48,630 --> 00:33:52,530
异常的 表，它是

879
00:33:52,530 --> 00:33:54,360
关系可以实际存储在

880
00:33:54,360 --> 00:33:58,679
给定表的元组中，所以

881
00:33:58,679 --> 00:34:01,590
我们将再次定义在高级别

882
00:34:01,590 --> 00:34:04,440
，将我们的所有表存储在我们的

883
00:34:04,440 --> 00:34:07,110
数据库中作为这些关系和 然后我们

884
00:34:07,110 --> 00:34:08,609
将通过高级语言访问它们，这

885
00:34:08,609 --> 00:34:11,250
意味着我们将

886
00:34:11,250 --> 00:34:14,340
编写我们希望

887
00:34:14,340 --> 00:34:16,350
数据集执行的确切代码，以便检索

888
00:34:16,350 --> 00:34:18,300
我们想要的数据我们只会说

889
00:34:18,300 --> 00:34:20,369
嘿，我们希望您计算这个答案

890
00:34:20,369 --> 00:34:22,530
请这样做 对我来说，我们不会 xxa

891
00:34:22,530 --> 00:34:24,989
实际上没有这样做 所以这个想法

892
00:34:24,989 --> 00:34:26,129
实际上很漂亮 真的是革命性的

893
00:34:26,129 --> 00:34:28,199
因为那时每个人都在编写

894
00:34:28,199 --> 00:34:30,359
明确的程序代码 你知道这里

895
00:34:30,359 --> 00:34:31,469
是 for 循环来遍历

896
00:34:31,469 --> 00:34:32,940
表并找到我想要的数据

897
00:34:32,940 --> 00:34:34,168
我在最开始展示的

898
00:34:34,168 --> 00:34:35,340
例子是人们如何

899
00:34:35,340 --> 00:34:37,710
在关系模型之前编写数据库应用程序

900
00:34:37,710 --> 00:34:41,520
，你知道这

901
00:34:41,520 --> 00:34:42,750
在当时实际上是非常有争议的，

902
00:34:42,750 --> 00:34:45,060
因为每个人

903
00:34:45,060 --> 00:34:48,330
都说软件无法生成与查询

904
00:34:48,330 --> 00:34:50,429
计划一样有效的查询计划 人类

905
00:34:50,429 --> 00:34:52,320
可以做到这一点与

906
00:34:52,320 --> 00:34:53,369
人们在 19 世纪

907
00:34:53,369 --> 00:34:55,590
70 年代提出的关于编译器的论点相同，他们说

908
00:34:55,590 --> 00:34:57,540
哦，你知道没有编译器可以写

909
00:34:57,540 --> 00:34:59,609
你知道 现在生成机器代码和

910
00:34:59,609 --> 00:35:02,250
手写汇编一样有效，

911
00:35:02,250 --> 00:35:04,500
当然现在没有人写或者

912
00:35:04,500 --> 00:35:06,119
你们中很少有人写低级

913
00:35:06,119 --> 00:35:08,730
汇编每个人都用你知道

914
00:35:08,730 --> 00:35:10,320
的高级语言编写，编译

915
00:35:10,320 --> 00:35:12,500
器做得很好，产生了

916
00:35:12,500 --> 00:35:14,880
更多执行的机器代码

917
00:35:14,880 --> 00:35:16,710
比做同样事情的治疗方法更有效

918
00:35:16,710 --> 00:35:18,420
对他们来说，编译器

919
00:35:18,420 --> 00:35:20,580
或数据库系统可以产生一个

920
00:35:20,580 --> 00:35:21,840
查询星球，无论人类是否

921
00:35:21,840 --> 00:35:23,670
可以这样做，而且现在我们有非常

922
00:35:23,670 --> 00:35:25,980
复杂的查询计划，现在肥料

923
00:35:25,980 --> 00:35:27,960
并不完美，但它们可以 可能

924
00:35:27,960 --> 00:35:29,640
做得更好，大多数人可以

925
00:35:29,640 --> 00:35:33,000
做的事情，然后最后一个关键想法是

926
00:35:33,000 --> 00:35:37,440
，大型数据库的物理存储或物理

927
00:35:37,440 --> 00:35:39,650
存储策略

928
00:35:39,650 --> 00:35:41,210


929
00:35:41,210 --> 00:35:42,769
由数据库分钟系统的实现决定，

930
00:35:42,769 --> 00:35:46,849
因此我们再次

931
00:35:46,849 --> 00:35:48,349
通过以下方式定义我们的数据库 这些高级结构作为

932
00:35:48,349 --> 00:35:50,690
关系，但这些关系如何

933
00:35:50,690 --> 00:35:53,150
实际存储实际上

934
00:35:53,150 --> 00:35:56,089
取决于数据系统的实现，因此

935
00:35:56,089 --> 00:35:57,710
关系模型没有说明它是否

936
00:35:57,710 --> 00:35:59,059
应该在内存中应该在磁盘上

937
00:35:59,059 --> 00:36:00,799
她如何在磁盘上布局或如何

938
00:36:00,799 --> 00:36:03,289
组织内存所有

939
00:36:03,289 --> 00:36:05,660
对应用程序透明的东西，所以现在这样做

940
00:36:05,660 --> 00:36:09,109
的好处是如果你

941
00:36:09,109 --> 00:36:10,970
知道某些应用程序

942
00:36:10,970 --> 00:36:13,490
你知道他们的数据库可能 1 以一种方式存储

943
00:36:13,490 --> 00:36:16,130
，然后随着时间的推移，

944
00:36:16,130 --> 00:36:19,039
如果应用程序涉及

945
00:36:19,039 --> 00:36:21,890
到以另一种方式存储它可能会更好，

946
00:36:21,890 --> 00:36:22,999
然后我们不想重写我们的

947
00:36:22,999 --> 00:36:24,950
应用程序，因为我们仍在

948
00:36:24,950 --> 00:36:28,400
编写 像续集这样的高级语言，

949
00:36:28,400 --> 00:36:30,319
我们仍在访问这些关系，

950
00:36:30,319 --> 00:36:31,849
但在幕后，这个新

951
00:36:31,849 --> 00:36:33,049
系统可以开始

952
00:36:33,049 --> 00:36:35,950
为我们移动事物或更改其布局或

953
00:36:35,950 --> 00:36:39,019
重新编译某些更改数据

954
00:36:39,019 --> 00:36:40,759
结构的事物，我们必须更改

955
00:36:40,759 --> 00:36:42,410
它们的应用程序代码，因此我们

956
00:36:42,410 --> 00:36:44,029
现在

957
00:36:44,029 --> 00:36:45,529
在逻辑层和物理层之间有一个干净的分离干净的分离，

958
00:36:45,529 --> 00:36:49,430
这绝对是我们想要的，

959
00:36:49,430 --> 00:36:52,849
所以关系数据模型

960
00:36:52,849 --> 00:36:56,210
不是唯一的数据模型，尽管它是

961
00:36:56,210 --> 00:36:57,980
证书 仅是使用最广泛的数据

962
00:36:57,980 --> 00:37:00,470
模型，在我看来，我认为它是

963
00:37:00,470 --> 00:37:03,319
最好的数据模型，但是您知道

964
00:37:03,319 --> 00:37:04,339


965
00:37:04,339 --> 00:37:07,069
不同类型的工作有不同的数据模型，听听这是

966
00:37:07,069 --> 00:37:08,269
关系数据模型，它是一种

967
00:37:08,269 --> 00:37:10,009
包罗万象的数据模型，可以附带很多

968
00:37:10,009 --> 00:37:11,420
事情并不是说其他

969
00:37:11,420 --> 00:37:15,980
的不好或错误它只是一个

970
00:37:15,980 --> 00:37:17,930
关系模型十有八九

971
00:37:17,930 --> 00:37:20,890
这可能是你需要的所以

972
00:37:20,890 --> 00:37:23,150
数据模型再次是

973
00:37:23,150 --> 00:37:24,680
我们将如何描述

974
00:37:24,680 --> 00:37:27,309
的高级概念 我们的数据库中的数据，然后为

975
00:37:27,309 --> 00:37:29,599
数据库中给定数据集合提供的模式

976
00:37:29,599 --> 00:37:32,989


977
00:37:32,989 --> 00:37:34,759
是我们实际存储它的内容的定义，

978
00:37:34,759 --> 00:37:37,789
因此我将在几张幻灯片中展示我的意思，

979
00:37:37,789 --> 00:37:39,859
但数据模型

980
00:37:39,859 --> 00:37:41,359
本质上是

981
00:37:41,359 --> 00:37:43,670
我们如何组织数据然后

982
00:37:43,670 --> 00:37:45,529
模式的高级概念是说好的，

983
00:37:45,529 --> 00:37:46,730


984
00:37:46,730 --> 00:37:48,319
对于今天的给定数据模型，数据实际上用这个应用程序存储了什么，

985
00:37:48,319 --> 00:37:51,829
所以再次正如我所说的，关系

986
00:37:51,829 --> 00:37:53,180
数据模型只是其中

987
00:37:53,180 --> 00:37:55,099
之一 所有其他数据模型 我在

988
00:37:55,099 --> 00:37:58,970
这里分享一个小样本 然后

989
00:37:58,970 --> 00:38:00,470
是您今天知道的大多数 DBMS 系统以及

990
00:38:00,470 --> 00:38:02,299
我们将在本课程中介绍的系统 我的

991
00:38:02,299 --> 00:38:04,819
Siegel Postgres Oracle db2 sequel server

992
00:38:04,819 --> 00:38:07,400
sequel byte 所有这些都是关系

993
00:38:07,400 --> 00:38:09,799
数据数据数据库系统所做的

994
00:38:09,799 --> 00:38:12,559
如果

995
00:38:12,559 --> 00:38:14,059
您熟悉续集这个术语，请使用种族数据模型，没有

996
00:38:14,059 --> 00:38:15,770
续集系统通常是这些

997
00:38:15,770 --> 00:38:19,130
键值图文档或 JSON 或列

998
00:38:19,130 --> 00:38:21,020
族数据模型，我也不

999
00:38:21,020 --> 00:38:23,480
一定说关系

1000
00:38:23,480 --> 00:38:25,520
数据模型比 其他

1001
00:38:25,520 --> 00:38:27,380
一些在某些应用程序域中

1002
00:38:27,380 --> 00:38:29,240
，其中一些像它可以

1003
00:38:29,240 --> 00:38:33,170
比关系数据模型更好地描述数据，

1004
00:38:33,170 --> 00:38:34,789
并且关系数据

1005
00:38:34,789 --> 00:38:37,279
模型肯定采用了其中一些

1006
00:38:37,279 --> 00:38:39,380
概念或想法，这些概念或想法来自这些其他数据

1007
00:38:39,380 --> 00:38:42,770
模型的较新版本它只是

1008
00:38:42,770 --> 00:38:44,480
你知道关系数据模型可以对

1009
00:38:44,480 --> 00:38:48,230
所有这些东西进行建模，它只是很好地

1010
00:38:48,230 --> 00:38:55,789
承载

1011
00:38:55,789 --> 00:38:58,369
了那里的好处，是的，基本数据

1012
00:38:58,369 --> 00:39:00,859
模型也有 您还可以存储以

1013
00:39:00,859 --> 00:39:02,510
提高被认为是数据

1014
00:39:02,510 --> 00:39:05,180
模型的矩阵 这主要是这

1015
00:39:05,180 --> 00:39:06,770
是人们使用机器学习的内容 或者

1016
00:39:06,770 --> 00:39:08,930
有一些数据库可以将

1017
00:39:08,930 --> 00:39:11,180
矩阵存储在数组中，它们不是

1018
00:39:11,180 --> 00:39:15,260
普通人通常使用的数据

1019
00:39:15,260 --> 00:39:16,789
框或您 知道一些

1020
00:39:16,789 --> 00:39:19,460
将成为矩阵数据模型示例的东西 多值数据

1021
00:39:19,460 --> 00:39:22,640
模型中的分层数据模型和从不数据

1022
00:39:22,640 --> 00:39:24,349
模型

1023
00:39:24,349 --> 00:39:25,250
还有很多其他

1024
00:39:25,250 --> 00:39:30,380
这些更深奥的 这些是

1025
00:39:30,380 --> 00:39:31,849


1026
00:39:31,849 --> 00:39:33,410
1960 年代使用的原始数据模型 和 1970 年代

1027
00:39:33,410 --> 00:39:34,910
你知道，大约在同一

1028
00:39:34,910 --> 00:39:37,779
时间，关系数据模型问世，你

1029
00:39:37,779 --> 00:39:40,910
几乎从不希望他们几乎永远不会

1030
00:39:40,910 --> 00:39:43,339
看到这些东西，如果你像一个

1031
00:39:43,339 --> 00:39:44,809
新的初创公司或第一次构建一个应用

1032
00:39:44,809 --> 00:39:47,180
程序，你肯定

1033
00:39:47,180 --> 00:39:49,760
想使用任何 在这些东西中，它们

1034
00:39:49,760 --> 00:39:52,640
主要是遗留应用程序，它

1035
00:39:52,640 --> 00:39:57,170
只是旧软件的残余物 II

1036
00:39:57,170 --> 00:39:58,910
会说甚至没有必要

1037
00:39:58,910 --> 00:40:01,760
再次考虑它们，因此出于我们的目的，

1038
00:40:01,760 --> 00:40:03,049
我们专注于 关系数据

1039
00:40:03,049 --> 00:40:04,130
模型是我们在本

1040
00:40:04,130 --> 00:40:05,299
课程中关心的，这是最好的，我们将再次

1041
00:40:05,299 --> 00:40:06,150
关注因为

1042
00:40:06,150 --> 00:40:07,770
关系数据模型

1043
00:40:07,770 --> 00:40:11,250
今晚可以用来建模任何东西，所以

1044
00:40:11,250 --> 00:40:13,430
关系数据模型由

1045
00:40:13,430 --> 00:40:16,799
三部分组成，所以第一部分是

1046
00:40:16,799 --> 00:40:19,410
关系的结构就像

1047
00:40:19,410 --> 00:40:20,779
这个模式 我们将如何定义

1048
00:40:20,779 --> 00:40:23,220
我们关系中的内容 是他们的活动是什么 类型是什么

1049
00:40:23,220 --> 00:40:24,900


1050
00:40:24,900 --> 00:40:27,510
等等 然后我们将有完整性

1051
00:40:27,510 --> 00:40:30,140
约束来定义

1052
00:40:30,140 --> 00:40:33,480
什么是有效的 给定结构的数据库实例，

1053
00:40:33,480 --> 00:40:35,579
而不是给

1054
00:40:35,579 --> 00:40:38,640
定您提供的架构，然后

1055
00:40:38,640 --> 00:40:40,920
我们将有一种方法来操作和

1056
00:40:40,920 --> 00:40:44,609
访问我们数据库中的数据，

1057
00:40:44,609 --> 00:40:46,770
我们如何实际运行

1058
00:40:46,770 --> 00:40:49,289
可以提取信息或

1059
00:40:49,289 --> 00:40:53,130
修改内容的查询 让我们看看让

1060
00:40:53,130 --> 00:40:56,490
我们回到我们的音乐商店示例 看看

1061
00:40:56,490 --> 00:40:58,079
一些

1062
00:40:58,079 --> 00:40:59,789
你知道的关系模型的具体

1063
00:40:59,789 --> 00:41:02,190


1064
00:41:02,190 --> 00:41:07,589
示例 元素或

1065
00:41:07,589 --> 00:41:10,380
记录具有表示关系中

1066
00:41:10,380 --> 00:41:12,359
实体实例的属性，

1067
00:41:12,359 --> 00:41:15,599
因此艺术家有一个名字

1068
00:41:15,599 --> 00:41:17,700
在一个国家有一个年份，我们可以

1069
00:41:17,700 --> 00:41:19,049
在我们的关系示例中看到这里等等，

1070
00:41:19,049 --> 00:41:22,890
我们让你知道每条记录都是

1071
00:41:22,890 --> 00:41:25,049
一种 在此图中的此行中，

1072
00:41:25,049 --> 00:41:28,440
我们拥有所有这些属性，因此我们

1073
00:41:28,440 --> 00:41:30,839
将

1074
00:41:30,839 --> 00:41:33,539
关系数据模型中的记录称为元组，

1075
00:41:33,539 --> 00:41:35,730
这将是我们关系中实体实例的属性集，

1076
00:41:35,730 --> 00:41:40,170


1077
00:41:40,170 --> 00:41:43,170
因此在 原始

1078
00:41:43,170 --> 00:41:45,029
数据模型抱歉，原始关系

1079
00:41:45,029 --> 00:41:48,089
模型在 1970 年代像 Ted Cod 一样编写，

1080
00:41:48,089 --> 00:41:51,420
所有这些值都必须是

1081
00:41:51,420 --> 00:41:54,150
原子值或标量值我的意思是如果它

1082
00:41:54,150 --> 00:41:55,589
不能是数组，它们就不能是

1083
00:41:55,589 --> 00:41:58,500
嵌套对象等等总是

1084
00:41:58,500 --> 00:41:59,760
必须排序 你知道一个字符串

1085
00:41:59,760 --> 00:42:03,270
一个整数一个浮点数

1086
00:42:03,270 --> 00:42:04,440
，这也是原始数据模型的

1087
00:42:04,440 --> 00:42:07,619
关系数据模型，但你知道

1088
00:42:07,619 --> 00:42:11,099
最近你知道你现在可以存储

1089
00:42:11,099 --> 00:42:13,529
我们的加薪你现在可以将 JSON 对象存储

1090
00:42:13,529 --> 00:42:16,319
在 re 那些

1091
00:42:16,319 --> 00:42:18,819
特定限制的关系数据库

1092
00:42:18,819 --> 00:42:20,720
现在

1093
00:42:20,720 --> 00:42:23,119
在每个 Ashford 不同商店的域中也会有一个特殊值，

1094
00:42:23,119 --> 00:42:24,680
他们将称之为空

1095
00:42:24,680 --> 00:42:26,990
值，这意味着您知道该值

1096
00:42:26,990 --> 00:42:29,540
是未知的，因此

1097
00:42:29,540 --> 00:42:31,220
当我们 开始运行续集查询，但

1098
00:42:31,220 --> 00:42:32,839
几乎每个日常管理

1099
00:42:32,839 --> 00:42:34,609
系统都支持报告 关系

1100
00:42:34,609 --> 00:42:35,900
数据库系统支持所有值，

1101
00:42:35,900 --> 00:42:38,000
但如何实际存储它们

1102
00:42:38,000 --> 00:42:39,859
在实现中留下来了，

1103
00:42:39,859 --> 00:42:40,849
有很多不同的方法可以做到

1104
00:42:40,849 --> 00:42:43,240
这一点，我认为这很有趣。

1105
00:42:43,240 --> 00:42:46,190
对，所以你必须

1106
00:42:46,190 --> 00:42:48,680
理解我们会说

1107
00:42:48,680 --> 00:42:52,430
面积关系是一个有 n 列的表格的说法，

1108
00:42:52,430 --> 00:42:56,089
所以我将使用术语

1109
00:42:56,089 --> 00:42:59,599
关系和表格，并且不可改变地它们

1110
00:42:59,599 --> 00:43:01,280
对我们的意义相同 讨论

1111
00:43:01,280 --> 00:43:03,500
我有时会说两个池作为记录，

1112
00:43:03,500 --> 00:43:05,900
或者尽量不说行，因为

1113
00:43:05,900 --> 00:43:07,190
当我们真正开始谈论存储模型时，这是非常具体的事情

1114
00:43:07,190 --> 00:43:09,349
，

1115
00:43:09,349 --> 00:43:11,390
但所有 这些作品中的一部分也可以

1116
00:43:11,390 --> 00:43:16,040
互换使用，所以

1117
00:43:16,040 --> 00:43:18,079
我们在关系模型中还有一件事

1118
00:43:18,079 --> 00:43:21,230
是主键，所以主键

1119
00:43:21,230 --> 00:43:24,319
将是一个唯一的属性或一组

1120
00:43:24,319 --> 00:43:26,960
可以唯一标识

1121
00:43:26,960 --> 00:43:31,809
单个元组的属性，所以在这个例子中这里

1122
00:43:31,809 --> 00:43:34,220
有一个 我们实际上没有

1123
00:43:34,220 --> 00:43:35,630
关于朋友的主键有

1124
00:43:35,630 --> 00:43:37,730
属性，因为可能有其他

1125
00:43:37,730 --> 00:43:40,160
艺术家称为武当氏族

1126
00:43:40,160 --> 00:43:41,630
，但可能是正确的

1127
00:43:41,630 --> 00:43:44,960
，我们在我们的世界中没有任何东西

1128
00:43:44,960 --> 00:43:46,520
可以阻止某人

1129
00:43:46,520 --> 00:43:48,339
调用他们自己调用它们

1130
00:43:48,339 --> 00:43:51,140
，这样我们就可以引入一个

1131
00:43:51,140 --> 00:43:52,309
新的 ID 字段

1132
00:43:52,309 --> 00:43:54,559
作为唯一的主键，这样您就知道

1133
00:43:54,559 --> 00:43:56,329
是否正在查看

1134
00:43:56,329 --> 00:43:58,940
ID 为 1 2 3 的元组，您明确地查看

1135
00:43:58,940 --> 00:44:02,809
您知道原始的 wu-  tang 氏族 所以在

1136
00:44:02,809 --> 00:44:04,760
这个例子中，这就像一个

1137
00:44:04,760 --> 00:44:07,630
合成键，我将它引入到

1138
00:44:07,630 --> 00:44:11,059
我的我的关系中 我的模式就在

1139
00:44:11,059 --> 00:44:12,799
那里 在一个真正的艺术家中 他们

1140
00:44:12,799 --> 00:44:14,450
没有 ID 1 2 3 这是我们正在

1141
00:44:14,450 --> 00:44:15,799
使用的东西 在我们日常的地下室里

1142
00:44:15,799 --> 00:44:17,660
这个特定比率关系的系统来

1143
00:44:17,660 --> 00:44:21,079
唯一地识别元组，所以有

1144
00:44:21,079 --> 00:44:23,470
不同的方法来生成这些东西，

1145
00:44:23,470 --> 00:44:26,660
所以至少在

1146
00:44:26,660 --> 00:44:27,950
镰刀 Siegel 标准中有一些系统，你可以

1147
00:44:27,950 --> 00:44:29,359
自动生成这些自动

1148
00:44:29,359 --> 00:44:31,400
递增的键，所以在每次

1149
00:44:31,400 --> 00:44:31,730


1150
00:44:31,730 --> 00:44:33,530
确定的时候，在 tubal 中都有一些

1151
00:44:33,530 --> 00:44:35,839
计数器 递增 1 以便新

1152
00:44:35,839 --> 00:44:37,990
管将获得唯一标识符

1153
00:44:37,990 --> 00:44:40,460
其他系统如果您没有在

1154
00:44:40,460 --> 00:44:42,650
内部指定有关 crate one 的主键，

1155
00:44:42,650 --> 00:44:44,630
他们不会真正向您公开它，但

1156
00:44:44,630 --> 00:44:46,460
就像他们会使用它来跟踪

1157
00:44:46,460 --> 00:44:47,660
和这个

1158
00:44:47,660 --> 00:44:48,920
是您正在查看的特定物理记录或船的物理记录，

1159
00:44:48,920 --> 00:44:51,140
在此示例中

1160
00:44:51,140 --> 00:44:53,119
它是通过逻辑层公开的合成记录，

1161
00:44:53,119 --> 00:44:55,730
因此它们可能

1162
00:44:55,730 --> 00:44:57,589
是善良的，无法通过它自动

1163
00:44:57,589 --> 00:45:00,890
增量键还有外

1164
00:45:00,890 --> 00:45:02,869
键 关系数据模型，因此外

1165
00:45:02,869 --> 00:45:05,000
键是一种指定

1166
00:45:05,000 --> 00:45:07,820
来自一个关系的属性必须存在

1167
00:45:07,820 --> 00:45:10,910
于另一个关系中的至少一个元组中的方法，

1168
00:45:10,910 --> 00:45:12,589
因此 这就是你将如何

1169
00:45:12,589 --> 00:45:15,170
在不同的关系中保持完整性，

1170
00:45:15,170 --> 00:45:17,030
这样你就不会在另一个表中插入

1171
00:45:17,030 --> 00:45:19,880
映射到未知或不

1172
00:45:19,880 --> 00:45:23,089
存在的实体的东西，所以

1173
00:45:23,089 --> 00:45:26,359
回到我们这里的例子，所以

1174
00:45:26,359 --> 00:45:28,820
我们有艺术家，我们有专辑和

1175
00:45:28,820 --> 00:45:34,700
所以对于专辑关系，我们可能想要

1176
00:45:34,700 --> 00:45:38,079
存储多位艺术家，这些艺术家可以一起

1177
00:45:38,079 --> 00:45:41,810
在专辑上

1178
00:45:41,810 --> 00:45:44,450
合作，所以我们现在有这个艺术家字段

1179
00:45:44,450 --> 00:45:46,329
，但在这个特定的

1180
00:45:46,329 --> 00:45:49,490
例子中，这个混音带有多个

1181
00:45:49,490 --> 00:45:51,589
艺术家，所以我不能编码

1182
00:45:51,589 --> 00:45:53,690
艺术家字段中的多个值，因为我

1183
00:45:53,690 --> 00:45:56,030
说它们必须是标量，所以

1184
00:45:56,030 --> 00:45:58,130
我将在这里制作这个单独的交叉引用

1185
00:45:58,130 --> 00:46:01,099
表，在那里我将获得

1186
00:46:01,099 --> 00:46:04,640
来自该专辑一部分的艺术家 ID 的外键引用

1187
00:46:04,640 --> 00:46:06,319
，然后是专辑 ID

1188
00:46:06,319 --> 00:46:07,970
他们参与了所以现在我可以

1189
00:46:07,970 --> 00:46:11,630
在一张专辑中存储多个艺术家

1190
00:46:11,630 --> 00:46:13,940
，David minimis 系统将

1191
00:46:13,940 --> 00:46:16,760
跟踪这些专辑和

1192
00:46:16,760 --> 00:46:18,589
艺术家 ID 是否确实存在于真实的

1193
00:46:18,589 --> 00:46:21,530
关系中，从而防止 m

1194
00:46:21,530 --> 00:46:23,630
插入一张专辑，其中包含

1195
00:46:23,630 --> 00:46:25,910
实际上并不存在的艺术家，戴维森

1196
00:46:25,910 --> 00:46:28,400
可以保护我免于

1197
00:46:28,400 --> 00:46:31,010
再次插入错误数据 我购买的我没有

1198
00:46:31,010 --> 00:46:32,599


1199
00:46:32,599 --> 00:46:35,180
在我的应用程序中实现所有额外的代码和我自己，我们再次

1200
00:46:35,180 --> 00:46:38,020
离开运行 真的很难编码，

1201
00:46:38,020 --> 00:46:40,190
所以现在我们想谈谈

1202
00:46:40,190 --> 00:46:41,780
我们实际上希望如何

1203
00:46:41,780 --> 00:46:43,819
再次从数据库中获取数据 我展示了

1204
00:46:43,819 --> 00:46:45,480
我在循环之前编写的那个简单示例，

1205
00:46:45,480 --> 00:46:46,980
但我说这是一个坏主意，

1206
00:46:46,980 --> 00:46:48,000
我们不会 我不想

1207
00:46:48,000 --> 00:46:50,450
为应用程序继续这样做，所以我们想要做什么，

1208
00:46:50,450 --> 00:46:53,700
所以 DML 是一种操作数据的方法

1209
00:46:53,700 --> 00:46:57,060
，并且您正在访问它或

1210
00:46:57,060 --> 00:46:58,800
修改一种方法来生成它

1211
00:46:58,800 --> 00:47:01,260
我正在寻找的结果 我们有两种

1212
00:47:01,260 --> 00:47:04,109
方法可以做到这一点，所以第一个是

1213
00:47:04,109 --> 00:47:06,990
程序的意思，我们将在

1214
00:47:06,990 --> 00:47:10,560
高级策略中指定数据

1215
00:47:10,560 --> 00:47:12,450
系统应该如何找到

1216
00:47:12,450 --> 00:47:14,940
我们正在寻找的特定结果，所以我的意思并不是

1217
00:47:14,940 --> 00:47:16,590
完全像程序代码一样

1218
00:47:16,590 --> 00:47:18,630
我之前展示过的 Python 示例

1219
00:47:18,630 --> 00:47:20,220
高层说，嘿，

1220
00:47:20,220 --> 00:47:22,130
这是我们不需要执行

1221
00:47:22,130 --> 00:47:24,390
的另一种方法称为非

1222
00:47:24,390 --> 00:47:27,270
程序性或声明性，这

1223
00:47:27,270 --> 00:47:29,190
就是我们要说的，这是我们

1224
00:47:29,190 --> 00:47:31,170
想要的，这是我们想要的数据系统的答案

1225
00:47:31,170 --> 00:47:33,119
为我们生成，但我们

1226
00:47:33,119 --> 00:47:34,800
不会具体说明如何实际生产它

1227
00:47:34,800 --> 00:47:35,910
或实际如何进行并获取

1228
00:47:35,910 --> 00:47:37,590
它，所以我们会在高

1229
00:47:37,590 --> 00:47:39,090
层次上说嘿做这个，我们希望数据

1230
00:47:39,090 --> 00:47:40,830
系统可以为我做 找出一种

1231
00:47:40,830 --> 00:47:43,730
有效的方法来为我们做这件事 所以

1232
00:47:43,730 --> 00:47:45,750
现在谈论的工作是关系

1233
00:47:45,750 --> 00:47:47,460
代数 这将是

1234
00:47:47,460 --> 00:47:50,160
过程语言和关系

1235
00:47:50,160 --> 00:47:52,790
代数的一个例子 不难理解

1236
00:47:52,790 --> 00:47:54,720
它稍后会在我们

1237
00:47:54,720 --> 00:47:59,430
谈论查询执行时出现 但你知道，

1238
00:47:59,430 --> 00:48:01,260
这就是 - Ted

1239
00:48:01,260 --> 00:48:04,020
在 1970 年代有争议地提出的一个关于程序的

1240
00:48:04,020 --> 00:48:04,890
例子将是

1241
00:48:04,890 --> 00:48:07,830
关系微积分之类的东西，所以我们根本

1242
00:48:07,830 --> 00:48:10,920
不需要讨论这个，不是因为我

1243
00:48:10,920 --> 00:48:13,230
不知道我不认为这是

1244
00:48:13,230 --> 00:48:15,330
至少对于我们的目的来说实际上是必要的

1245
00:48:15,330 --> 00:48:17,670
在本课程中，但

1246
00:48:17,670 --> 00:48:19,710
如果您对查询优化的细节有把握，就会出现普通出租车，

1247
00:48:19,710 --> 00:48:21,450


1248
00:48:21,450 --> 00:48:24,000
因为您必须使用微积分来

1249
00:48:24,000 --> 00:48:26,340
推导出有效的查询计划并进行

1250
00:48:26,340 --> 00:48:28,140
修剪等类似的工作，因此

1251
00:48:28,140 --> 00:48:30,090
对于本课程我们都需要

1252
00:48:30,090 --> 00:48:31,950
关注关系代数 我只是

1253
00:48:31,950 --> 00:48:33,510
提出关系微积分

1254
00:48:33,510 --> 00:48:35,550
，说它存在，它

1255
00:48:35,550 --> 00:48:37,530
是非过程语言的一个例子，

1256
00:48:37,530 --> 00:48:39,990
但为了我们的目的，我们不需要

1257
00:48:39,990 --> 00:48:45,900
它，所以 Ted Cobb 提出了七个

1258
00:48:45,900 --> 00:48:48,180
基本运算符 关系

1259
00:48:48,180 --> 00:48:50,220
代数所以这些是

1260
00:48:50,220 --> 00:48:51,480
我们必须

1261
00:48:51,480 --> 00:48:53,700
检索关系中的操作元组

1262
00:48:53,700 --> 00:48:55,470
以产生我们正在寻找的答案的基本操作

1263
00:48:55,470 --> 00:48:55,880


1264
00:48:55,880 --> 00:48:58,859
所以要提到的一件重要的事情是

1265
00:48:58,859 --> 00:48:59,250


1266
00:48:59,250 --> 00:49:03,330
这个代数基于集合所以

1267
00:49:03,330 --> 00:49:05,430
集合是一个无序列表 或无序

1268
00:49:05,430 --> 00:49:09,180
的数据集合，

1269
00:49:09,180 --> 00:49:11,609
当我们谈论续集时，

1270
00:49:11,609 --> 00:49:13,470


1271
00:49:13,470 --> 00:49:15,320
即使它使用关系代数，也不会基于所述代数，现在你不能拥有唯一值

1272
00:49:15,320 --> 00:49:17,220


1273
00:49:17,220 --> 00:49:19,770
用于执行查询的底层运算符，

1274
00:49:19,770 --> 00:49:21,150
当我们下次讨论续集时，我将再次

1275
00:49:21,150 --> 00:49:24,390
解释这意味着什么，因此它的

1276
00:49:24,390 --> 00:49:25,859
工作方式是我们的每个

1277
00:49:25,859 --> 00:49:27,660
关系运算符都将

1278
00:49:27,660 --> 00:49:29,220
接受一个或多个关系作为此

1279
00:49:29,220 --> 00:49:30,869
输入 然后它总是会

1280
00:49:30,869 --> 00:49:33,060
输出一个新的关系，所以我们的想法

1281
00:49:33,060 --> 00:49:35,310
是我们将

1282
00:49:35,310 --> 00:49:37,950
通过将这些关系运算符链接在一起来组合复杂的查询，以

1283
00:49:37,950 --> 00:49:41,250


1284
00:49:41,250 --> 00:49:42,840
产生我们正在寻找的答案，所以这些就像

1285
00:49:42,840 --> 00:49:45,420
你会使用的原语

1286
00:49:45,420 --> 00:49:48,780
对元组上的数据做一些操作，

1287
00:49:48,780 --> 00:49:50,820
然后生成一个更复杂的查询，

1288
00:49:50,820 --> 00:49:54,450
我们把它们放在一起，所以只需选择

1289
00:49:54,450 --> 00:49:56,250
投影联合交集差异

1290
00:49:56,250 --> 00:49:58,560
乘积，然后再加入这些是

1291
00:49:58,560 --> 00:49:59,609
基本的，我们将

1292
00:49:59,609 --> 00:50:03,270
逐一介绍，所以 第一个是 select

1293
00:50:03,270 --> 00:50:05,430
select 基本上采用

1294
00:50:05,430 --> 00:50:08,790
满足某些选择谓词的元组的子集，

1295
00:50:08,790 --> 00:50:10,170
因此您可以认为

1296
00:50:10,170 --> 00:50:12,780
这就像一个过滤器，您在这里说的是

1297
00:50:12,780 --> 00:50:15,660
给定的输入 re 这

1298
00:50:15,660 --> 00:50:17,790
是我想为

1299
00:50:17,790 --> 00:50:19,950
每个元组计算的谓词，如果它的计算结果

1300
00:50:19,950 --> 00:50:21,720
为真，则表示满足谓词，

1301
00:50:21,720 --> 00:50:24,570
特定的元组会将它添加

1302
00:50:24,570 --> 00:50:28,050
到我们的输出输出关系中，

1303
00:50:28,050 --> 00:50:30,720
以便 Select 操作符，因此可以

1304
00:50:30,720 --> 00:50:33,210
轻松记住这个词 select

1305
00:50:33,210 --> 00:50:35,550
以 s 开头，所以关系运算符是一个

1306
00:50:35,550 --> 00:50:37,560
sigma，它也以 s 开头，所以你

1307
00:50:37,560 --> 00:50:40,560
会说这是我想要

1308
00:50:40,560 --> 00:50:42,270


1309
00:50:42,270 --> 00:50:43,740


1310
00:50:43,740 --> 00:50:46,560


1311
00:50:46,560 --> 00:50:48,300
的 假设我们有一个简单的关系，它有

1312
00:50:48,300 --> 00:50:51,630
两个属性，一个 ID 和 B ID，所以我们

1313
00:50:51,630 --> 00:50:52,890
可以做一个像这样的选择运算符

1314
00:50:52,890 --> 00:50:55,589
，它说找到所有

1315
00:50:55,589 --> 00:50:58,020
ID 等于 2 的元组，然后我们的输出

1316
00:50:58,020 --> 00:51:00,450
将是这两个表的新关系

1317
00:51:00,450 --> 00:51:03,750
和与

1318
00:51:03,750 --> 00:51:06,660
输入关系相同的模式或相同的属性

1319
00:51:06,660 --> 00:51:10,980
我也可以使用

1320
00:51:10,980 --> 00:51:12,610
布尔逻辑

1321
00:51:12,610 --> 00:51:15,250
将更复杂的谓词组合在一起，所以现在

1322
00:51:15,250 --> 00:51:18,610
你说 AI D 等于和 B ID

1323
00:51:18,610 --> 00:51:22,030
大于 1 或 2 再一次，我们没有

1324
00:51:22,030 --> 00:51:23,830
指定

1325
00:51:23,830 --> 00:51:25,780
正确应用这些谓词的顺序，因为

1326
00:51:25,780 --> 00:51:27,250
做一个比另一个更昂贵，

1327
00:51:27,250 --> 00:51:27,610


1328
00:51:27,610 --> 00:51:29,770
这一切都留在代托纳系统中，

1329
00:51:29,770 --> 00:51:32,010
只是为了自己决定现在要做什么，

1330
00:51:32,010 --> 00:51:34,720
如果 你知道续集，

1331
00:51:34,720 --> 00:51:36,400
这将在续集中重写它的方式，

1332
00:51:36,400 --> 00:51:38,530
对于第二个例子，如果你想到

1333
00:51:38,530 --> 00:51:40,300
Select 运算符，我希望 where

1334
00:51:40,300 --> 00:51:42,850
子句正确，因为你说我们是 AI D

1335
00:51:42,850 --> 00:51:44,770
等于 2 并且 B ID 大于 1 或 2

1336
00:51:44,770 --> 00:51:46,840
对，那是将

1337
00:51:46,840 --> 00:51:49,060
这个选择

1338
00:51:49,060 --> 00:51:53,350
运算符的翻译转换为续集，

1339
00:51:53,350 --> 00:51:55,200
所以下一个运算符是投影

1340
00:51:55,200 --> 00:51:58,780
，这里我们要做的是

1341
00:51:58,780 --> 00:52:01,300
生成一个仅包含子集的新输出关系

1342
00:52:01,300 --> 00:52:04,600


1343
00:52:04,600 --> 00:52:07,840
从我们的输入关系中指定的属性，

1344
00:52:07,840 --> 00:52:09,370
所以你会说这是我的人口

1345
00:52:09,370 --> 00:52:12,040
，然后我的投影是这里的

1346
00:52:12,040 --> 00:52:13,690
小行星，我只希望你

1347
00:52:13,690 --> 00:52:15,490
在输出中承认警察，再次

1348
00:52:15,490 --> 00:52:17,770
投影从 P 开始它使用

1349
00:52:17,770 --> 00:52:19,990
小写的 PI 符号 秒 o 很容易

1350
00:52:19,990 --> 00:52:22,390
记住，没有哪个是它，

1351
00:52:22,390 --> 00:52:24,880
所以这里是我们的简单示例，

1352
00:52:24,880 --> 00:52:28,750
关系 R 与 IDBI D 所以在这种情况下

1353
00:52:28,750 --> 00:52:32,530
，我可以先做一个选择，

1354
00:52:32,530 --> 00:52:36,700
以生成我们的所有元组，其中

1355
00:52:36,700 --> 00:52:39,400
a  ID 等于 2，然后现在在我的

1356
00:52:39,400 --> 00:52:42,130
投影子句中，我可以说我希望 B

1357
00:52:42,130 --> 00:52:45,310
ID 值减去 100，

1358
00:52:45,310 --> 00:52:47,380
然后减去 a ID 值，这样我就可以以

1359
00:52:47,380 --> 00:52:49,360
任何我想要的方式重新排序我的属性

1360
00:52:49,360 --> 00:52:51,340
，然后我可以操纵那个

1361
00:52:51,340 --> 00:52:52,780
能量 想要使用任何类型的

1362
00:52:52,780 --> 00:52:54,550
算术或类型的字符串函数

1363
00:52:54,550 --> 00:52:57,340
运算符的方式，所以在续集中，它

1364
00:52:57,340 --> 00:52:58,840
看起来像这样，所以你在输出

1365
00:52:58,840 --> 00:53:00,550
子句中有你的 Select 语句，你

1366
00:53:00,550 --> 00:53:03,100
说 ID 在一个 ID 中听一百，

1367
00:53:03,100 --> 00:53:04,780
然后是 where 子句 只是

1368
00:53:04,780 --> 00:53:08,860
在 Select 运算符中得到它我们的 Union

1369
00:53:08,860 --> 00:53:10,690
运算符是我们将要采用

1370
00:53:10,690 --> 00:53:13,540
两个关系的地方，我们将产生

1371
00:53:13,540 --> 00:53:15,790
一个新的输出关系，其中包含

1372
00:53:15,790 --> 00:53:18,310
第一个关系

1373
00:53:18,310 --> 00:53:20,700
或第二个关系或两者中的所有元组 他们是

1374
00:53:20,700 --> 00:53:22,780
对的，你只是哟 你只要结合这

1375
00:53:22,780 --> 00:53:24,579
两个关系想象

1376
00:53:24,579 --> 00:53:27,369
一下，如果你在 R 和 s 上做联合，

1377
00:53:27,369 --> 00:53:31,269
你会得到一个巨人，你知道你

1378
00:53:31,269 --> 00:53:33,939
在这里得到一个公司，基本上将 S 连接

1379
00:53:33,939 --> 00:53:36,400
到自己的 are 作为输出，所以对于这个

1380
00:53:36,400 --> 00:53:38,259
特定的运营商，你必须拥有

1381
00:53:38,259 --> 00:53:40,179
在您尝试联合的两个关系中具有相同类型的相同属性，

1382
00:53:40,179 --> 00:53:42,189


1383
00:53:42,189 --> 00:53:43,989
而在这种情况下，

1384
00:53:43,989 --> 00:53:47,709
如果您知道有第三个属性，您

1385
00:53:47,709 --> 00:53:49,150
将无法成为联合，因为它

1386
00:53:49,150 --> 00:53:53,249
在续集中不匹配 是

1387
00:53:53,249 --> 00:53:56,679
Union all 运算符，因此 Union one

1388
00:53:56,679 --> 00:53:59,019
is 与

1389
00:53:59,019 --> 00:54:02,289
关系代数中的 Union 运算符不完全相同，您

1390
00:54:02,289 --> 00:54:04,239
必须添加此 all 限定符才能使其

1391
00:54:04,239 --> 00:54:05,619
完全执行您想要执行的操作

1392
00:54:05,619 --> 00:54:07,809
，我们将再次讨论什么

1393
00:54:07,809 --> 00:54:09,099
这两者的不同之处在于在下一

1394
00:54:09,099 --> 00:54:10,619
堂课

1395
00:54:10,619 --> 00:54:13,479
中也有相同的交集，所以

1396
00:54:13,479 --> 00:54:16,799
现在你正在做的是把你正在做的所有

1397
00:54:16,799 --> 00:54:19,749
事情都用于 2 个输入关系的好处，

1398
00:54:19,749 --> 00:54:21,549
你只是要

1399
00:54:21,549 --> 00:54:23,140
产生输出关系

1400
00:54:23,140 --> 00:54:24,880
出现在两者中的元组 两个

1401
00:54:24,880 --> 00:54:27,400
含义 所以再次采用 Union R

1402
00:54:27,400 --> 00:54:29,739
和 s 在这里我们将只产生一个

1403
00:54:29,739 --> 00:54:32,650
没有抱歉的单个

1404
00:54:32,650 --> 00:54:35,499
关系的单个元组具有一个元组 aa 3 和

1405
00:54:35,499 --> 00:54:38,650
103 所以你必须再次具有相同的

1406
00:54:38,650 --> 00:54:40,449
数字 atrás - 相同的类型

1407
00:54:40,449 --> 00:54:42,819
在关系代数中使用相同的名称，以便

1408
00:54:42,819 --> 00:54:44,650
今晚工作，然后

1409
00:54:44,650 --> 00:54:48,279
是 intersect 关键字，在续集中

1410
00:54:48,279 --> 00:54:51,640
可以做同样的事情，不同之处在于

1411
00:54:51,640 --> 00:54:53,469
您采用

1412
00:54:53,469 --> 00:54:55,179
第一个关系中出现的所有元组，而不是

1413
00:54:55,179 --> 00:54:57,819
第二个关系，所以我再次 可以认为

1414
00:54:57,819 --> 00:55:00,880
RS 的区别

1415
00:55:00,880 --> 00:55:03,459
只是没有出现在 S 中出现在 R 中的所有元组，

1416
00:55:03,459 --> 00:55:05,859
所以在这种情况下 8 a 3 1 或 3

1417
00:55:05,859 --> 00:55:09,189
出现在 R 和 s 中，因此它被

1418
00:55:09,189 --> 00:55:12,699
排除在输出中，但是 1 a 2 没有

1419
00:55:12,699 --> 00:55:15,009
出现在 s 中，所以它们在输出中，

1420
00:55:15,009 --> 00:55:17,410
在续集中，您使用 accept 关键字，

1421
00:55:17,410 --> 00:55:19,959
除了操作符之外，可以执行

1422
00:55:19,959 --> 00:55:23,859
相同类型的操作，然后

1423
00:55:23,859 --> 00:55:27,099
倒数第二个 new 是产品

1424
00:55:27,099 --> 00:55:30,009
操作符，所以这也是 有时

1425
00:55:30,009 --> 00:55:32,109
称为笛卡尔积，或者如果您

1426
00:55:32,109 --> 00:55:33,369
知道续集，我认为这被称为

1427
00:55:33,369 --> 00:55:35,859
交叉连接，所以基本上你只想

1428
00:55:35,859 --> 00:55:37,840


1429
00:55:37,840 --> 00:55:40,360
从两百万人口中生成所有元组的所有组合，

1430
00:55:40,360 --> 00:55:42,490
所以你基本上只是

1431
00:55:42,490 --> 00:55:43,930
采用交叉乘积手段，并且

1432
00:55:43,930 --> 00:55:46,450
只是产生每个独特组合的巨大输出

1433
00:55:46,450 --> 00:55:47,860
在所有

1434
00:55:47,860 --> 00:55:51,070
这些中，在续集中再次使用交叉连接，或者

1435
00:55:51,070 --> 00:55:52,810
如果您实际上根本没有指定

1436
00:55:52,810 --> 00:55:54,940
关节是什么，您会在此处获得此输出

1437
00:55:54,940 --> 00:55:57,520
，因此您可能会认为这

1438
00:55:57,520 --> 00:55:59,290
有点愚蠢，这就像你不是

1439
00:55:59,290 --> 00:56:01,570
我 不想做，你永远不想这样做，

1440
00:56:01,570 --> 00:56:03,250
但这实际上有时会出现

1441
00:56:03,250 --> 00:56:06,430
在测试一些测试应用程序

1442
00:56:06,430 --> 00:56:07,450
时，当你想说给我

1443
00:56:07,450 --> 00:56:10,000
不同配置的所有独特组合时，

1444
00:56:10,000 --> 00:56:11,200
我想我

1445
00:56:11,200 --> 00:56:12,910
实际上会尝试测试和这个 是一种

1446
00:56:12,910 --> 00:56:16,170
非常简单的方法，可以真正做到这一点，

1447
00:56:16,530 --> 00:56:18,970
最后一次谈论的

1448
00:56:18,970 --> 00:56:22,810
是进行连接，因此这种特殊的

1449
00:56:22,810 --> 00:56:25,210
连接称为自然连接，这不是

1450
00:56:25,210 --> 00:56:27,040
我们将来要讨论的那种连接，

1451
00:56:27,040 --> 00:56:30,910
但不是 ne 将来肯定是

1452
00:56:30,910 --> 00:56:31,870
珠宝类型的类型，但这是

1453
00:56:31,870 --> 00:56:33,310
非常明确地谈论自然

1454
00:56:33,310 --> 00:56:35,650
连接，因此自然连接的工作方式是

1455
00:56:35,650 --> 00:56:38,500
，对于输出中的每个元组，

1456
00:56:38,500 --> 00:56:41,230
您会看到一个关系，您会看到

1457
00:56:41,230 --> 00:56:44,590
它是否与另一个关系中的所有属性匹配

1458
00:56:44,590 --> 00:56:46,930
具有相同的

1459
00:56:46,930 --> 00:56:49,290
名称相同的类型所以他们的普通人是

1460
00:56:49,290 --> 00:56:51,730
正确的所以在这种情况下，如果我想

1461
00:56:51,730 --> 00:56:55,360
对 R 和 s 进行自然连接，我会查看

1462
00:56:55,360 --> 00:56:58,300
ID 并查看是否找到匹配项 我

1463
00:56:58,300 --> 00:57:00,190
查看 ID 和 看看我在哪里

1464
00:57:00,190 --> 00:57:02,680
有一个 ID 匹配和 s，然后如果我这样做了，

1465
00:57:02,680 --> 00:57:04,630
那么我检查我是否也是

1466
00:57:04,630 --> 00:57:08,050
来自 R 和 s 的 ID 匹配，然后如果我这样做了，

1467
00:57:08,050 --> 00:57:10,210
那么这里会产生输出，所以

1468
00:57:10,210 --> 00:57:11,470
又是一个 3  :103

1469
00:57:11,470 --> 00:57:14,860
存在 R 和 s 都 S 并且它

1470
00:57:14,860 --> 00:57:17,740
与输出进行比较所以在续集中

1471
00:57:17,740 --> 00:57:19,270
有一个像这样的自然连接运算符

1472
00:57:19,270 --> 00:57:21,520
再次注意我没有指定

1473
00:57:21,520 --> 00:57:24,670
我想要如何进行连接它知道我正在

1474
00:57:24,670 --> 00:57:26,230
寻找 ID 是否

1475
00:57:26,230 --> 00:57:30,010
仅基于名称匹配，所以

1476
00:57:30,010 --> 00:57:31,390
这与差异的原因不同

1477
00:57:31,390 --> 00:57:33,190
因为我们可能有额外的

1478
00:57:33,190 --> 00:57:36,760
属性，并询问

1479
00:57:36,760 --> 00:57:39,100
它们是否没有相同的名称，因为你

1480
00:57:39,100 --> 00:57:40,660
知道在两个关系之间共享

1481
00:57:40,660 --> 00:57:42,430
它们，所以它们实际上不会

1482
00:57:42,430 --> 00:57:44,770
在输出中产生，所以该方案是允许的

1483
00:57:44,770 --> 00:57:45,910
只要有一些

1484
00:57:45,910 --> 00:57:48,160
共同的共同属性，

1485
00:57:48,160 --> 00:57:49,810
你就会有所不同，然后在联合之后我们就

1486
00:57:49,810 --> 00:57:51,040
不同了，你有它的差异运算符

1487
00:57:51,040 --> 00:57:51,650
，

1488
00:57:51,650 --> 00:57:52,810
你必须拥有完全相同

1489
00:57:52,810 --> 00:57:57,530
的相同类型的女演员，所以

1490
00:57:57,530 --> 00:57:59,540
这些再次 这些只是最初的

1491
00:57:59,540 --> 00:58:01,790
七个主要关系

1492
00:58:01,790 --> 00:58:03,680
运算符 Ted Kapur 提出的关系代数运算符

1493
00:58:03,680 --> 00:58:04,610


1494
00:58:04,610 --> 00:58:06,410
从那时起，人们进行了大量

1495
00:58:06,410 --> 00:58:08,680
研究和许多其他内容

1496
00:58:08,680 --> 00:58:11,270
，人们添加了权限，例如

1497
00:58:11,270 --> 00:58:12,890


1498
00:58:12,890 --> 00:58:14,480
在我们知道我们想要的地方做排序馅饼之类的事情 做那个

1499
00:58:14,480 --> 00:58:16,520
续集 原始的关系模型

1500
00:58:16,520 --> 00:58:17,750
谜题没有谈论这些事情

1501
00:58:17,750 --> 00:58:19,490
关系代数提案没有

1502
00:58:19,490 --> 00:58:21,230
谈论这些事情但是花生因为

1503
00:58:21,230 --> 00:58:22,250
扩展了关系

1504
00:58:22,250 --> 00:58:24,470
代数包括 ed 线索这些其他的所以做

1505
00:58:24,470 --> 00:58:26,260
重命名分配重复消除

1506
00:58:26,260 --> 00:58:29,180
聚合分组按排序

1507
00:58:29,180 --> 00:58:31,970
除法所以我们可能会再次看到其中

1508
00:58:31,970 --> 00:58:33,710
一些会看到某些看到聚合

1509
00:58:33,710 --> 00:58:39,020
和排序稍后你知道这

1510
00:58:39,020 --> 00:58:40,910
只是说我们可能有占位符代数

1511
00:58:40,910 --> 00:58:42,620
代数运算符

1512
00:58:42,620 --> 00:58:44,390
必须考虑我们什么时候开始做查询

1513
00:58:44,390 --> 00:58:48,410
播放我们做的查询执行，

1514
00:58:48,410 --> 00:58:50,390
所以最后我只想

1515
00:58:50,390 --> 00:58:52,550
指出一件特别的事情，

1516
00:58:52,550 --> 00:58:58,610
所以关系代数

1517
00:58:58,610 --> 00:59:01,520
与之前的 for 循环相比仍然是相当高的水平

1518
00:59:01,520 --> 00:59:03,560
，因为我们' 我们

1519
00:59:03,560 --> 00:59:05,240
没有指定任何

1520
00:59:05,240 --> 00:59:07,250
关于数据存储的好处，比如

1521
00:59:07,250 --> 00:59:08,930
它的数据结构等等，我们

1522
00:59:08,930 --> 00:59:10,460
只是在高层次上说，嘿你

1523
00:59:10,460 --> 00:59:12,500
知道扫描这个表并做一个过滤器，

1524
00:59:12,500 --> 00:59:16,970
但它仍然在 一天结束时，

1525
00:59:16,970 --> 00:59:19,460
它仍然会告诉

1526
00:59:19,460 --> 00:59:21,830
您应该按顺序

1527
00:59:21,830 --> 00:59:24,140
执行哪些步骤，所以再次假设我

1528
00:59:24,140 --> 00:59:26,780
想做一个加入机器 RNs 然后我

1529
00:59:26,780 --> 00:59:29,990
想过滤 过滤掉任何你

1530
00:59:29,990 --> 00:59:31,370
知道的元组过滤器只

1531
00:59:31,370 --> 00:59:34,490
产生 B ID 等于一或二的元组，所以我

1532
00:59:34,490 --> 00:59:36,680
有两个关系

1533
00:59:36,680 --> 00:59:38,540
代数表达式的两个例子来执行这个

1534
00:59:38,540 --> 00:59:40,490
查询，所以这里的第一个我

1535
00:59:40,490 --> 00:59:43,400
先做 R 和 s 的自然连接，然后

1536
00:59:43,400 --> 00:59:45,950
我对 B ID 进行过滤，它是 102

1537
00:59:45,950 --> 00:59:49,700
，然后在此处的第二个示例中，我

1538
00:59:49,700 --> 00:59:52,190
首先对 B ID 等于 102 的 s 进行过滤

1539
00:59:52,190 --> 00:59:54,830
，然后我认为

1540
00:59:54,830 --> 00:59:56,450
该关系的输出，然后我进行了

1541
00:59:56,450 --> 01:00:00,020
自然连接，因此您可能会再次认为 在

1542
01:00:00,020 --> 01:00:01,790
高层次上这些是在高层次上

1543
01:00:01,790 --> 01:00:02,960
这些是相同的东西它们

1544
01:00:02,960 --> 01:00:05,440
产生相同的结果但是

1545
01:00:05,440 --> 01:00:08,140


1546
01:00:08,140 --> 01:00:09,790
它们执行这

1547
01:00:09,790 --> 01:00:11,640
两个查询计划的效率的形式特征有很大不同，

1548
01:00:11,640 --> 01:00:15,160
就像说我有十亿个元组

1549
01:00:15,160 --> 01:00:19,329
在 r 和 s 中，s 中只有一个元组，

1550
01:00:19,329 --> 01:00:23,890
其中 B ID 等于 102，所以如果我

1551
01:00:23,890 --> 01:00:25,810
先进行连接，我将连接

1552
01:00:25,810 --> 01:00:27,670
十亿个元组中的十亿个元组，

1553
01:00:27,670 --> 01:00:29,650
然后我将扫描并

1554
01:00:29,650 --> 01:00:31,990
找到那个 B ID 等于 102 的元组，

1555
01:00:31,990 --> 01:00:35,140
而在 第二个计划我可以

1556
01:00:35,140 --> 01:00:38,920
在 s 上进行扫描，首先

1557
01:00:38,920 --> 01:00:42,790
找到 ID 为 102 的一个元组，然后现在

1558
01:00:42,790 --> 01:00:45,400
我加入了，你知道那个

1559
01:00:45,400 --> 01:00:48,220
有十亿个元组的元组，然后我们再次这样做

1560
01:00:48,220 --> 01:00:51,190
，即使我们不打算

1561
01:00:51,190 --> 01:00:52,839
像你运行这个 for 循环并

1562
01:00:52,839 --> 01:00:55,329
这样做的低级别仍然

1563
01:00:55,329 --> 01:00:56,710
在我们实际想要的步骤之外指定关系

1564
01:00:56,710 --> 01:00:59,770
到第 7 天用于我们的

1565
01:00:59,770 --> 01:01:03,790
查询计划执行所以我们真正想做的

1566
01:01:03,790 --> 01:01:07,440
是能够只是说 高层

1567
01:01:07,440 --> 01:01:09,880
告诉数据库系统嘿，这是

1568
01:01:09,880 --> 01:01:12,190
我希望您计算的答案，而不是

1569
01:01:12,190 --> 01:01:14,079
实际指定您希望它如何

1570
01:01:14,079 --> 01:01:17,140
计算它，所以我想说嘿去吧，

1571
01:01:17,140 --> 01:01:20,290
让我从 rns 或 B ID 转到赞助人，

1572
01:01:20,290 --> 01:01:22,990
他去了 102 没有” 不是说你

1573
01:01:22,990 --> 01:01:24,910
应该先扫描还是加入

1574
01:01:24,910 --> 01:01:26,890
我们的第一个我说这是我想要的答案，

1575
01:01:26,890 --> 01:01:29,440
我们想要这样做的原因

1576
01:01:29,440 --> 01:01:31,510
再次是因为现在在我们的

1577
01:01:31,510 --> 01:01:34,060
应用程序中我们只是指定了

1578
01:01:34,060 --> 01:01:35,650
我们想要系统的这个高级答案

1579
01:01:35,650 --> 01:01:39,910
计算并让您知道我们的表

1580
01:01:39,910 --> 01:01:42,130
或我们的数据库是否真实 今天很小

1581
01:01:42,130 --> 01:01:45,190
，然后一年后它变得非常大

1582
01:01:45,190 --> 01:01:47,290
我不必更改我的

1583
01:01:47,290 --> 01:01:49,270
代码数据库可以弄清楚哦，

1584
01:01:49,270 --> 01:01:51,400


1585
01:01:51,400 --> 01:01:53,890
在我想以一种方式执行它之前你有一个小团队小数据库但

1586
01:01:53,890 --> 01:01:55,780
现在你有 s 中有 10 亿个元组，

1587
01:01:55,780 --> 01:01:57,730
也许我想先进行过滤，

1588
01:01:57,730 --> 01:01:59,410
但我不必更改我的

1589
01:01:59,410 --> 01:02:01,300
应用程序代码就可以做到这一点，

1590
01:02:01,300 --> 01:02:02,470
因为那天说我们可以为我做这件事，

1591
01:02:02,470 --> 01:02:05,430
所以这就是我们要尝试的

1592
01:02:05,430 --> 01:02:09,160
通过运行查询并特别

1593
01:02:09,160 --> 01:02:13,329
愿意运行续集，所以

1594
01:02:13,329 --> 01:02:14,920
要理解的关键是，虽然

1595
01:02:14,920 --> 01:02:18,250
续集是人们

1596
01:02:18,250 --> 01:02:19,260
表达酷儿

1597
01:02:19,260 --> 01:02:21,930
四人运行关系模型的标准方式，但它并不是

1598
01:02:21,930 --> 01:02:23,820
你可以做到的唯一方法，它只是

1599
01:02:23,820 --> 01:02:24,869
碰巧 每个人都

1600
01:02:24,869 --> 01:02:26,910
使用的，你知道标准化的，

1601
01:02:26,910 --> 01:02:29,070
实际上当 Ted Codd

1602
01:02:29,070 --> 01:02:31,380
在 1970 年第一次写关系模型论文时，他的

1603
01:02:31,380 --> 01:02:32,850
意思是提出续集，他

1604
01:02:32,850 --> 01:02:34,260
让我提出任何高级语言，

1605
01:02:34,260 --> 01:02:35,490
他只是说嘿，这是一个关系

1606
01:02:35,490 --> 01:02:39,359
代数，然后他后来 提议的h 是自己的

1607
01:02:39,359 --> 01:02:42,420
语言，称为 alpha 你知道它

1608
01:02:42,420 --> 01:02:44,369
是在 1970 年代的竞争对手续集

1609
01:02:44,369 --> 01:02:45,840
课程网络中你从未听说过它，

1610
01:02:45,840 --> 01:02:48,540
因为没有人使用过它

1611
01:02:48,540 --> 01:02:50,640
实际上 1970 有另外两个竞争

1612
01:02:50,640 --> 01:02:51,869
还有另一种竞争语言

1613
01:02:51,869 --> 01:02:52,830
让我们看看还有其他 克拉克（Clark）

1614
01:02:52,830 --> 01:02:55,050
在伯克利（Berkeley）的这个

1615
01:02:55,050 --> 01:02:57,330
名为 ingress 的系统中看起来很

1616
01:02:57,330 --> 01:02:58,200
相似，

1617
01:02:58,200 --> 01:03:01,470
quele 和 alpha 和续集

1618
01:03:01,470 --> 01:03:02,490
看起来彼此相似，但

1619
01:03:02,490 --> 01:03:06,240
因为语法非常不同，

1620
01:03:06,240 --> 01:03:08,369
所以它又发生了续集只是

1621
01:03:08,369 --> 01:03:09,510
有点像 今天每个人都在使用什么

1622
01:03:09,510 --> 01:03:13,020
因为 IBM 发明了它 所以你的

1623
01:03:13,020 --> 01:03:14,940
想法是这又是

1624
01:03:14,940 --> 01:03:16,230
我展示的 非常重要 这

1625
01:03:16,230 --> 01:03:17,790
就像你

1626
01:03:17,790 --> 01:03:19,230
实际上可以找到

1627
01:03:19,230 --> 01:03:21,540
所有你知道的查询的最低级别的方式 找到一个

1628
01:03:21,540 --> 01:03:24,359
冰块 独自去，但相反，我可以

1629
01:03:24,359 --> 01:03:26,220
像这样写一个非常简单的续集查询，

1630
01:03:26,220 --> 01:03:27,600
并说这是我

1631
01:03:27,600 --> 01:03:29,820
希望你产生的答案，然后数据

1632
01:03:29,820 --> 01:03:32,760
中心可以弄清楚哦 我想

1633
01:03:32,760 --> 01:03:34,080
在这个特定的 for 循环中编写它，

1634
01:03:34,080 --> 01:03:36,869
你知道这是最好的方法

1635
01:03:36,869 --> 01:03:39,660
，然后如果我添加索引，

1636
01:03:39,660 --> 01:03:41,520
那么查询计划可能会改变，所以

1637
01:03:41,520 --> 01:03:42,930
关系模型和续集的美妙之

1638
01:03:42,930 --> 01:03:44,730
处在于我们可以编写这些

1639
01:03:44,730 --> 01:03:46,590
高 我们想要的级别查询，然后

1640
01:03:46,590 --> 01:03:48,960
随着时间的推移，随着

1641
01:03:48,960 --> 01:03:51,330
数据库系统自身的变化或我们的

1642
01:03:51,330 --> 01:03:53,340
工作负载的变化而变化，它可以适应和

1643
01:03:53,340 --> 01:03:55,260
改进自己，因为这个原因，我们每个人都

1644
01:03:55,260 --> 01:03:56,580
必须返回或更改我们的

1645
01:03:56,580 --> 01:03:59,070
应用程序，这就是为什么我

1646
01:03:59,070 --> 01:04:00,780
对关系模型感到非常兴奋，我

1647
01:04:00,780 --> 01:04:02,359
认为这总是正确的方式，

1648
01:04:02,359 --> 01:04:05,880
所以只是在这里完成

1649
01:04:05,880 --> 01:04:07,260
一次又一次我意识到这一切都是为了我

1650
01:04:07,260 --> 01:04:08,850
坐在浴缸里给我

1651
01:04:08,850 --> 01:04:12,240
讲课所以我耐心等待你们坐下

1652
01:04:12,240 --> 01:04:14,400
来所以 数据库无处不在

1653
01:04:14,400 --> 01:04:16,380
数据库是愚蠢的 重要的

1654
01:04:16,380 --> 01:04:17,790
数据库无处不在 所以无论

1655
01:04:17,790 --> 01:04:20,190
你一生做

1656
01:04:20,190 --> 01:04:22,200
什么，即使你不去你也知道你知道即使你知道

1657
01:04:22,200 --> 01:04:23,820
去剧院 你知道的数据库

1658
01:04:23,820 --> 01:04:25,020
古巴编程的计算机科学领域

1659
01:04:25,020 --> 01:04:27,000
我向你保证，在

1660
01:04:27,000 --> 01:04:28,710
你的余生中，你会

1661
01:04:28,710 --> 01:04:31,060
遇到数据库，

1662
01:04:31,060 --> 01:04:32,110


1663
01:04:32,110 --> 01:04:33,670
了解它们如何在内部实际工作

1664
01:04:33,670 --> 01:04:35,380
对你来说很重要，因为当你不

1665
01:04:35,380 --> 01:04:36,640
知道事情 没有按照

1666
01:04:36,640 --> 01:04:37,870
他们应该认为的方式工作，

1667
01:04:37,870 --> 01:04:39,010
你需要知道

1668
01:04:39,010 --> 01:04:40,570
哦，它是这样写的，这就是

1669
01:04:40,570 --> 01:04:42,190
实际在做的事情，这样你就可以

1670
01:04:42,190 --> 01:04:44,410
弄清楚如何实际改进事情，

1671
01:04:44,410 --> 01:04:46,420
所以我们讨论了关系模型，我们

1672
01:04:46,420 --> 01:04:48,940
讨论了关系 代数，我们

1673
01:04:48,940 --> 01:04:50,290
展示了我们如何将这些原语

1674
01:04:50,290 --> 01:04:52,450
用于本质上将它们

1675
01:04:52,450 --> 01:04:55,060
用作构建块来生成查询

1676
01:04:55,060 --> 01:04:56,530
，我们可以在关系数据库上执行这些查询

1677
01:04:56,530 --> 01:04:58,360
以更新它并驱动答案，

1678
01:04:58,360 --> 01:05:01,270
因此我们稍后会在代数上再次见到您

1679
01:05:01,270 --> 01:05:03,280
当我们谈论

1680
01:05:03,280 --> 01:05:05,620
查询优化查询执行的学期，但

1681
01:05:05,620 --> 01:05:06,910
只是在您

1682
01:05:06,910 --> 01:05:08,200
为第一个作业编写续集查询时的脑海中，

1683
01:05:08,200 --> 01:05:09,520
您应该考虑哦，

1684
01:05:09,520 --> 01:05:12,100
呵呵 你知道数据库 ISM

1685
01:05:12,100 --> 01:05:13,630
正在将这些转换成关系

1686
01:05:13,630 --> 01:05:15,160
代数，所以关于

1687
01:05:15,160 --> 01:05:16,330
实际如何做的一切如何实际

1688
01:05:16,330 --> 01:05:21,070
执行这些事情好吧我几乎

1689
01:05:21,070 --> 01:05:23,800
忘记了最后一

1690
01:05:23,800 --> 01:05:24,760
件事你需要在

1691
01:05:24,760 --> 01:05:26,170
整个过程中了解数据库的最重要的事情到

1692
01:05:26,170 --> 01:05:27,970
其余你的 当你

1693
01:05:27,970 --> 01:05:30,280
回顾 36 个房间时，你会明白

1694
01:05:30,280 --> 01:05:32,200
谁是最初的九个房间

1695
01:05:32,200 --> 01:05:36,070
，你有 RZA，GZA 检查员

1696
01:05:36,070 --> 01:05:39,430
甲板 Ghostface Killah masta killa 你

1697
01:05:39,430 --> 01:05:42,990
得到了 meth man ol Dirty Bastard Raekwon

1698
01:05:42,990 --> 01:05:45,070
但另一个重要的事情也是

1699
01:05:45,070 --> 01:05:47,050
Cappadonna 当时在监狱里 所以

1700
01:05:47,050 --> 01:05:49,510
他实际上是氏族的原始成员

1701
01:05:49,510 --> 01:05:51,580
但因为他在监狱里 他不能

1702
01:05:51,580 --> 01:05:54,010
他不能在 36 个房间 所以

1703
01:05:54,010 --> 01:05:55,240
这是整个学期你需要了解的最重要的事情

1704
01:05:55,240 --> 01:05:56,440


1705
01:05:56,440 --> 01:05:59,470
好吧好吧 伙计们，

1706
01:05:59,470 --> 01:06:06,400
下次在墨西哥巴里奥斯见到你们，带着

1707
01:06:06,400 --> 01:06:08,030
被压垮的孩子，

1708
01:06:08,030 --> 01:06:11,840
我会开车，他在我的系统里有雾蒙蒙的夜晚，

1709
01:06:11,840 --> 01:06:13,670
我很幸运，

1710
01:06:13,670 --> 01:06:17,200
让我们去下一个 一个然后

1711
01:06:20,110 --> 01:06:23,030
越过网将儿子弹跳果冻击中

1712
01:06:23,030 --> 01:06:24,800
船上的熟食店自然

1713
01:06:24,800 --> 01:06:26,660
祝福你什么说唱就像一束激光束

1714
01:06:26,660 --> 01:06:28,700
在灌木丛中的电话甚至

1715
01:06:28,700 --> 01:06:30,740
不像链条一样包裹着我们的瓶子一个漂亮

1716
01:06:30,740 --> 01:06:33,170
漂亮的金色不要 感觉就像喝

1717
01:06:33,170 --> 01:06:35,030
一匹小马 - 你说你不能说

1718
01:06:35,030 --> 01:06:37,040
他还活着，如果为了不知道

1719
01:06:37,040 --> 01:06:40,000
你他妈的不能爆炸

