1
00:00:01,290 --> 00:00:13,119
[音乐]

2
00:00:14,469 --> 00:00:17,990
所以这是星期三晚上的战斗，因为麦克

3
00:00:17,990 --> 00:00:20,390
撞到了奥克兰，另一个人也是

4
00:00:20,390 --> 00:00:23,960
我决定，与其

5
00:00:23,960 --> 00:00:25,730
在汽车旅馆房间里重新拍摄第二堂课，

6
00:00:25,730 --> 00:00:27,710
我只是

7
00:00:27,710 --> 00:00:30,019
向你们展示我所做的会更好 2018 年，

8
00:00:30,019 --> 00:00:31,609
因为那是在现场

9
00:00:31,609 --> 00:00:34,300
观众面前，我觉得我做到了，我

10
00:00:34,300 --> 00:00:36,770
可以做得更好，无论

11
00:00:36,770 --> 00:00:37,250
我自己

12
00:00:37,250 --> 00:00:39,320
做什么，这就是为什么我只是

13
00:00:39,320 --> 00:00:42,230
在这里真正展示 2018 年的演讲作为

14
00:00:42,230 --> 00:00:44,120
第二次演讲，然后什么时候 我们

15
00:00:44,120 --> 00:00:45,920
将返回 CMU，然后从下周三开始，

16
00:00:45,920 --> 00:00:46,910
我们将再次进行现场

17
00:00:46,910 --> 00:00:52,040
讲座，所以请注意今天的

18
00:00:52,040 --> 00:00:55,790
讲座是关于提前续集的，

19
00:00:55,790 --> 00:00:59,600
提前我的意思是超越您可能

20
00:00:59,600 --> 00:01:00,860
已经或可能不知道的基本

21
00:01:00,860 --> 00:01:04,489
续集，对吧 2018 年的续集是

22
00:01:04,489 --> 00:01:08,150
在 1973 年发明的，我想

23
00:01:08,150 --> 00:01:10,490
你一生中大多数人都看过续集，所以

24
00:01:10,490 --> 00:01:11,750
我觉得没有必要教你

25
00:01:11,750 --> 00:01:13,640
它的基础知识，所以我会花时间

26
00:01:13,640 --> 00:01:14,630
真正谈论更

27
00:01:14,630 --> 00:01:16,070
复杂或更有趣的事情 你

28
00:01:16,070 --> 00:01:20,360
可以用续集 嘿 所以只是

29
00:01:20,360 --> 00:01:22,160
拿起我们离开上节课的地方 我们正在

30
00:01:22,160 --> 00:01:23,630
讨论关系模型和

31
00:01:23,630 --> 00:01:26,270
关系代数 我们有点

32
00:01:26,270 --> 00:01:28,400
提到关系

33
00:01:28,400 --> 00:01:29,710
代数

34
00:01:29,710 --> 00:01:32,240
Cerreta 的目标是在高

35
00:01:32,240 --> 00:01:35,900
层次上描述答案 我们

36
00:01:35,900 --> 00:01:37,280
希望剧院系统会

37
00:01:37,280 --> 00:01:39,710
计算而不是

38
00:01:39,710 --> 00:01:41,990
实际如何正确执行的确切步骤，因此

39
00:01:41,990 --> 00:01:43,490
思考这个问题的方式就像说

40
00:01:43,490 --> 00:01:47,090
如果我们必须告诉日间系统确切地做什么我们想要对我们的数据进行排序

41
00:01:47,090 --> 00:01:48,710


42
00:01:48,710 --> 00:01:50,450
必须提供你知道的

43
00:01:50,450 --> 00:01:52,940
快速冒泡排序算法但是

44
00:01:52,940 --> 00:01:54,650
使用高级语言或

45
00:01:54,650 --> 00:01:55,970
声明性语言你会说嘿

46
00:01:55,970 --> 00:01:57,860
我们希望你对此进行排序我们不关心

47
00:01:57,860 --> 00:02:00,440
你实际上是如何做的但这

48
00:02:00,440 --> 00:02:02,750
是我们的答案 想要，我们将

49
00:02:02,750 --> 00:02:04,400
在今天的讲座中看到这一点，

50
00:02:04,400 --> 00:02:05,630
然后在本学期晚些时候继续进行，

51
00:02:05,630 --> 00:02:07,700
这是

52
00:02:07,700 --> 00:02:09,258
使用诸如 Secord 或

53
00:02:09,258 --> 00:02:11,000
声明性语言之类的东西的优势之一，我们不必

54
00:02:11,000 --> 00:02:12,530
告诉今天的系统 exac  tly 如何做

55
00:02:12,530 --> 00:02:12,870


56
00:02:12,870 --> 00:02:15,150
它可以自己弄清楚的事情，并

57
00:02:15,150 --> 00:02:17,099
释放它来找出根据您拥有的数据

58
00:02:17,099 --> 00:02:19,019
实际执行

59
00:02:19,019 --> 00:02:21,150
您想要执行的查询的最佳方式

60
00:02:21,150 --> 00:02:23,550
，并且它是一个

61
00:02:23,550 --> 00:02:26,640
港口 这是你可以使用的，所以我们稍后会

62
00:02:26,640 --> 00:02:27,870
在讨论查询优化器时看到这一点，

63
00:02:27,870 --> 00:02:29,190
但查询优化器

64
00:02:29,190 --> 00:02:32,160
是

65
00:02:32,160 --> 00:02:34,019
数据库系统内部的一个复杂机器，它将

66
00:02:34,019 --> 00:02:36,150
采用我们的后续查询并将其转换

67
00:02:36,150 --> 00:02:38,280
为最有效的计划，我们 稍后将

68
00:02:38,280 --> 00:02:40,860
介绍他们实际上是如何做到这一点的，但

69
00:02:40,860 --> 00:02:43,890
我要说的是，如果您知道自己

70
00:02:43,890 --> 00:02:45,599
是否参与了

71
00:02:45,599 --> 00:02:47,250
查询优化的研究，或者只是帮助您了解

72
00:02:47,250 --> 00:02:49,349
使用 Cori 优化器的工作，那么您昨天就可以找到

73
00:02:49,349 --> 00:02:51,569
工作，因为这是

74
00:02:51,569 --> 00:02:53,099
我在戴维斯公司公司的所有朋友都给

75
00:02:53,099 --> 00:02:54,959
我发电子邮件关于再次开放的一

76
00:02:54,959 --> 00:02:57,000
件事我有没有学生进行新的

77
00:02:57,000 --> 00:02:59,220
查询优化但有一些他们

78
00:02:59,220 --> 00:03:01,730
都下车去做很棒的工作

79
00:03:01,730 --> 00:03:03,629
这是每个人都喜欢的一

80
00:03:03,629 --> 00:03:05,459
件事 nts 因为它真的很难做到所以

81
00:03:05,459 --> 00:03:07,500
这不是这里的重点就

82
00:03:07,500 --> 00:03:08,940
在后面你会看到一些例子，当

83
00:03:08,940 --> 00:03:10,739
我们继续时，查询优化器

84
00:03:10,739 --> 00:03:12,360
可以尝试不同的东西来尝试

85
00:03:12,360 --> 00:03:13,950
提出不同的计划，我们将

86
00:03:13,950 --> 00:03:15,180
讨论如何 您实际上稍后会进行查询

87
00:03:15,180 --> 00:03:21,030
优化，所以

88
00:03:21,030 --> 00:03:22,920
正如我所说的 sequel 的历史可以追溯到

89
00:03:22,920 --> 00:03:27,389
1970 年代初期，所以您可能会注意到我说

90
00:03:27,389 --> 00:03:28,079
sequel

91
00:03:28,079 --> 00:03:30,450
有些人说 SQL 写

92
00:03:30,450 --> 00:03:32,340
我说 sequel 的部分原因是

93
00:03:32,340 --> 00:03:34,920
因为我不是 在 1970 年代还活着，但

94
00:03:34,920 --> 00:03:36,720
该语言的原始名称

95
00:03:36,720 --> 00:03:39,569
实际上拼写为 EQ UAL 续集

96
00:03:39,569 --> 00:03:42,419
，这是由 IBM 发明的，作为

97
00:03:42,419 --> 00:03:44,700
我们项目的系统的一部分，因此它

98
00:03:44,700 --> 00:03:46,200
代表结构化英语查询

99
00:03:46,200 --> 00:03:49,019
语言，所以如果您还记得 TED

100
00:03:49,019 --> 00:03:51,269
Cod 论文 我说过，tena Ted Cobb 是

101
00:03:51,269 --> 00:03:53,340
一位数学家，他设计了

102
00:03:53,340 --> 00:03:55,440
关系代数和关系模型，

103
00:03:55,440 --> 00:03:56,579
但他实际上并没有定义

104
00:03:56,579 --> 00:03:58,709


105
00:03:58,709 --> 00:04:00,450
用于在其上编写查询的编程语言，你不能

106
00:04:00,450 --> 00:04:01,769
写 quer  ie 使用关系

107
00:04:01,769 --> 00:04:03,480
代数是正确的，你知道

108
00:04:03,480 --> 00:04:05,220
没有，在键盘上写它是非常困难的

109
00:04:05,220 --> 00:04:07,620
，他

110
00:04:07,620 --> 00:04:09,209
后来定义或提出了他自己的

111
00:04:09,209 --> 00:04:11,790
称为 alpha 的查询语言，但那

112
00:04:11,790 --> 00:04:14,040
是在 1970 年代后期，所以当时

113
00:04:14,040 --> 00:04:15,660
人们说，嘿，有一个关系

114
00:04:15,660 --> 00:04:16,798
模型的想法，我们实际上应该尝试

115
00:04:16,798 --> 00:04:18,899
构建一个系统来做到这一点，人们必须

116
00:04:18,899 --> 00:04:20,279
想出自己的语言

117
00:04:20,279 --> 00:04:22,320
来实现关系微积分或

118
00:04:22,320 --> 00:04:25,169
关系代数，所以在 IBM，他们

119
00:04:25,169 --> 00:04:26,610
推出了续集，

120
00:04:26,610 --> 00:04:28,500
这是系统的一部分 我们的

121
00:04:28,500 --> 00:04:30,300
项目是人们在 1970 年代尝试构建的第一个

122
00:04:30,300 --> 00:04:31,440
关系数据库系统之一，

123
00:04:31,440 --> 00:04:34,110


124
00:04:34,110 --> 00:04:36,870
另一个主要的项目是

125
00:04:36,870 --> 00:04:38,550
来自伯克利的 Ingress，所以你听说过

126
00:04:38,550 --> 00:04:40,080
Postgres 对

127
00:04:40,080 --> 00:04:41,460
Postgres 是由同一个人发明的

128
00:04:41,460 --> 00:04:43,860
这样做了 ingress，所以它被称为 Postgres，

129
00:04:43,860 --> 00:04:45,990
因为在 post ingress 中，ingress 之后的东西，

130
00:04:45,990 --> 00:04:48,360
所以 ingress 的人有

131
00:04:48,360 --> 00:04:51,030
他们自己的语言，叫做 quell，这

132
00:04:51,030 --> 00:04:53,039
是由我的一个人开发的 顾问 Mike

133
00:04:53,039 --> 00:04:53,580
Stormbreaker

134
00:04:53,580 --> 00:04:55,949
他声称它比续集好得多

135
00:04:55,949 --> 00:04:57,090
，IBM 的人不知道他们

136
00:04:57,090 --> 00:04:58,919
在做什么当然大多数人

137
00:04:58,919 --> 00:05:01,020
从未听说过平息对我说它

138
00:05:01,020 --> 00:05:04,919
实际上并没有赢得 IBM 赢了，所以当时

139
00:05:04,919 --> 00:05:08,639
它又被拼写了 作为 eqtl IBM

140
00:05:08,639 --> 00:05:10,530
后来被起诉 我想你知道

141
00:05:10,530 --> 00:05:11,970
侵犯版权商标

142
00:05:11,970 --> 00:05:13,440
侵权 英格兰有一个人在他的编程语言

143
00:05:13,440 --> 00:05:15,960


144
00:05:15,960 --> 00:05:18,270
中用完整的英文单词拼写了 sequel 这个词，

145
00:05:18,270 --> 00:05:19,830
所以

146
00:05:19,830 --> 00:05:25,110
它被缩短为 sq SQL 那么什么

147
00:05:25,110 --> 00:05:26,310
发生的事情是我们今天使用续集的原因

148
00:05:26,310 --> 00:05:29,639
，因为 IBM 不是

149
00:05:29,639 --> 00:05:31,229
那个时候的 IBM 现在它是正确的

150
00:05:31,229 --> 00:05:32,610
每个人都认为

151
00:05:32,610 --> 00:05:34,289
像微软亚马逊和

152
00:05:34,289 --> 00:05:37,560
谷歌这样的大型科技公司在 1970 年代 1980 年代 IBM

153
00:05:37,560 --> 00:05:39,389
是主宰所以基本上

154
00:05:39,389 --> 00:05:41,159
不管 IBM 做过或说过这是

155
00:05:41,159 --> 00:05:42,539
我们要做的方式，最终

156
00:05:42,539 --> 00:05:46,500
成为标准，所以当 IBM 首次发布

157
00:05:46,500 --> 00:05:48,030
他们的第一个商业关系

158
00:05:48,030 --> 00:05:50,250
数据库系统 db2 时，他们从未

159
00:05:50,250 --> 00:05:51,960
真正发布过 sy 词干或只是

160
00:05:51,960 --> 00:05:54,150
一种研究原型，但

161
00:05:54,150 --> 00:05:56,490
后来最终制作了 db2 或至少

162
00:05:56,490 --> 00:05:59,009
db2 支持续集，因此这基本上

163
00:05:59,009 --> 00:06:02,789
成为标准，也是

164
00:06:02,789 --> 00:06:04,560
甲骨文起飞并变得像今天一样大

165
00:06:04,560 --> 00:06:06,150
的原因是它们有点

166
00:06:06,150 --> 00:06:08,870


167
00:06:08,870 --> 00:06:11,130
以多种方式复制 IBM 在 1970 年代所做的事情，我们可以

168
00:06:11,130 --> 00:06:15,060
在以后与她交谈，他们做到了，他们有

169
00:06:15,060 --> 00:06:17,039
续集，所以当 IBM 推出 db2 并

170
00:06:17,039 --> 00:06:18,750
有续集时，甲骨文就

171
00:06:18,750 --> 00:06:19,919
在正确的时间正确的地点说我们现在

172
00:06:19,919 --> 00:06:22,949
支持我们知道我们支持续集 - 所以

173
00:06:22,949 --> 00:06:25,979
它在 1986 年成为 ANSI 标准，并

174
00:06:25,979 --> 00:06:27,780
在 1987 年成为国际标准

175
00:06:27,780 --> 00:06:29,820
，现在简短的负担只是意味着

176
00:06:29,820 --> 00:06:33,750
结构化查询语言所以续集，

177
00:06:33,750 --> 00:06:36,810
即使它是 1970 年代的它不是死

178
00:06:36,810 --> 00:06:38,669
语言，它肯定不是静态的

179
00:06:38,669 --> 00:06:40,139
有点像你知道史蒂夫的掌声 -

180
00:06:40,139 --> 00:06:40,380


181
00:06:40,380 --> 00:06:42,810
经常保持新的规范

182
00:06:42,810 --> 00:06:44,220
在续集中也是一样的 每隔一段时间

183
00:06:44,220 --> 00:06:46,020
就有一个新规范，他们

184
00:06:46,020 --> 00:06:47,100
添加新特性和新

185
00:06:47,100 --> 00:06:49,020
功能 到基本语言，

186
00:06:49,020 --> 00:06:52,020
所以最新的标准是在 2016 年的

187
00:06:52,020 --> 00:06:54,990
续集中定义的，你可以看到

188
00:06:54,990 --> 00:06:57,000
多年来在添加新版本中他们添加了

189
00:06:57,000 --> 00:06:59,190
新功能，所以 2016 年他们添加了

190
00:06:59,190 --> 00:07:02,130
JSON 多态表，他们添加了 XML

191
00:07:02,130 --> 00:07:05,370
内容，然后 2003 1999 添加了正则表达式和

192
00:07:05,370 --> 00:07:07,710
触发器 通常发生的情况是

193
00:07:07,710 --> 00:07:10,560
有一个标准机构，其

194
00:07:10,560 --> 00:07:12,660
成员都来自主要数据库

195
00:07:12,660 --> 00:07:14,340
公司，主要数据库

196
00:07:14,340 --> 00:07:15,090
公司提出自己的

197
00:07:15,090 --> 00:07:17,070
专有功能和扩展，

198
00:07:17,070 --> 00:07:18,390
然后他们进入标准机构并

199
00:07:18,390 --> 00:07:20,070
推动尝试获得他们的

200
00:07:20,070 --> 00:07:21,960
某些版本 功能作为

201
00:07:21,960 --> 00:07:25,110
标准的一部分，所以这是虽然

202
00:07:25,110 --> 00:07:27,390
有一个续集标准，但没有人真正

203
00:07:27,390 --> 00:07:29,280
遵循它，因为

204
00:07:29,280 --> 00:07:30,210
每个人都有自己的

205
00:07:30,210 --> 00:07:31,890
专有东西，这些东西

206
00:07:31,890 --> 00:07:33,210
在标准出来之前就被发明了，说这

207
00:07:33,210 --> 00:07:36,930
就是你应该做的事情 如果你

208
00:07:36,930 --> 00:07:38,190
要声称你的数据库系统

209
00:07:38,190 --> 00:07:40,440
支持续集，你需要的最低限度

210
00:07:40,440 --> 00:07:42,000
实际上是

211
00:07:42,000 --> 00:07:44,580
续集 92 中定义的 标准 所以这

212
00:07:44,580 --> 00:07:46,110
就是我们今天所知道的基本续集

213
00:07:46,110 --> 00:07:48,000
选择插入更新删除创建

214
00:07:48,000 --> 00:07:50,370
表事务之类的所有内容

215
00:07:50,370 --> 00:07:53,160
在续集 92 中定义 所以如果

216
00:07:53,160 --> 00:07:54,450
有人说他们的数据系统

217
00:07:54,450 --> 00:07:56,310
支持平等机会他们

218
00:07:56,310 --> 00:07:57,990
真的是这个意思，然后 更

219
00:07:57,990 --> 00:08:00,540
高级的数据库，包括开源数据库

220
00:08:00,540 --> 00:08:02,640
和他们添加的商业数据库，

221
00:08:02,640 --> 00:08:04,590
它们具有

222
00:08:04,590 --> 00:08:08,940
来自较新标准的更多功能，然后

223
00:08:08,940 --> 00:08:10,230
这里有一个很棒的网站，它

224
00:08:10,230 --> 00:08:13,560
现在有点过时了，但它正在使用一些

225
00:08:13,560 --> 00:08:15,840
随机的家伙，基本上看起来 在

226
00:08:15,840 --> 00:08:17,520
排名前四的前五名数据库

227
00:08:17,520 --> 00:08:19,920
系统中，看看

228
00:08:19,920 --> 00:08:22,680
它们在各种续集功能上有何不同，它

229
00:08:22,680 --> 00:08:24,390
比较了续集功能，

230
00:08:24,390 --> 00:08:26,400
我们将在今天经历的过程中看到这一点，

231
00:08:26,400 --> 00:08:28,440
将有一些示例，其中

232
00:08:28,440 --> 00:08:30,300
标准说明了不同的事情

233
00:08:30,300 --> 00:08:32,039
数据库系统做其他事情

234
00:08:32,039 --> 00:08:36,570
通常是我的续集，这只是一个

235
00:08:36,570 --> 00:08:38,460
即使有一个标准没有人

236
00:08:38,460 --> 00:08:40,740
真正完全正确地遵循它

237
00:08:40,740 --> 00:08:41,969
没有我所

238
00:08:41,969 --> 00:08:43,289
知道的数据库系统会声称他们是

239
00:08:43,289 --> 00:08:46,020
你知道 2016 年续集的证明

240
00:08:46,020 --> 00:08:48,740
他们有一些零碎的东西

241
00:08:48,740 --> 00:08:52,220
所以续集本身在技术上不是

242
00:08:52,220 --> 00:08:54,080
一种语言，它是

243
00:08:54,080 --> 00:08:56,630
某种特定事物的集合

244
00:08:56,630 --> 00:08:59,290
它是 DML DDL 和 DCL 命令的集合，

245
00:08:59,290 --> 00:09:02,630
因此 DML 将成为

246
00:09:02,630 --> 00:09:04,790
数据创新语言将成为

247
00:09:04,790 --> 00:09:06,560
诸如插入更新删除

248
00:09:06,560 --> 00:09:08,150
选择之类的命令，就像实际

249
00:09:08,150 --> 00:09:09,890
操作您可以存储

250
00:09:09,890 --> 00:09:12,680
在数据库中的数据的东西 DDL 是您的方式

251
00:09:12,680 --> 00:09:15,980
创建表实际上定义了模式来

252
00:09:15,980 --> 00:09:18,410
实际存储内容，然后 DCL

253
00:09:18,410 --> 00:09:20,660
是您进行安全

254
00:09:20,660 --> 00:09:22,580
授权的方式，以授予您知道谁

255
00:09:22,580 --> 00:09:24,790
可以读取您放置的数据的方式

256
00:09:24,790 --> 00:09:27,590
还有很多其他事情，例如

257
00:09:27,590 --> 00:09:29,390
如何定义视图如何定义完整性

258
00:09:29,390 --> 00:09:32,090
奇怪的引用约束

259
00:09:32,090 --> 00:09:34,400
和事务，这些都是

260
00:09:34,400 --> 00:09:37,040
续集权利保护伞的一部分

261
00:09:37,040 --> 00:09:38,180
，其中有这些不同

262
00:09:38,180 --> 00:09:41,450
类别的命令，所以

263
00:09:41,450 --> 00:09:43,370
我想在这里指出的一件重要的事情

264
00:09:43,370 --> 00:09:44,510
，我们将在

265
00:09:44,510 --> 00:09:47,960
今天的讲座中看到这一点，

266
00:09:47,960 --> 00:09:50,000
这与基于集合论或

267
00:09:50,000 --> 00:09:53,390
集合续集的关系代数不同，实际上基于包

268
00:09:53,390 --> 00:09:56,120
代数，所以它有点像

269
00:09:56,120 --> 00:09:57,680
你 可以有像列表

270
00:09:57,680 --> 00:10:00,770
集或包这样的列表可以有

271
00:10:00,770 --> 00:10:03,590
重复但有一个定义的

272
00:10:03,590 --> 00:10:05,270
顺序如果我将某些东西推送到我的列表

273
00:10:05,270 --> 00:10:08,210
中它是它在该列表中的位置集合

274
00:10:08,210 --> 00:10:10,220
是无序的意味着元素

275
00:10:10,220 --> 00:10:12,890
没有位置但你不能 有

276
00:10:12,890 --> 00:10:14,510
重复，如果我尝试将相同的

277
00:10:14,510 --> 00:10:16,460
东西插入到一个集合中，它只会通过

278
00:10:16,460 --> 00:10:19,520
旧的运行被覆盖一个包

279
00:10:19,520 --> 00:10:23,360
没有设置位置或排序，但

280
00:10:23,360 --> 00:10:26,840
它也允许正确的重复，

281
00:10:26,840 --> 00:10:29,120
我们将看到为什么我们必须这样做 这是

282
00:10:29,120 --> 00:10:31,130
因为如果我们想

283
00:10:31,130 --> 00:10:34,220
在我们的元素上实际定义顺序，或者如果你

284
00:10:34,220 --> 00:10:35,150
想确保我们基本上没有

285
00:10:35,150 --> 00:10:37,040
重复，数据库

286
00:10:37,040 --> 00:10:38,750
系统必须做额外的工作

287
00:10:38,750 --> 00:10:42,020
来为你提供这些，所以这个想法是

288
00:10:42,020 --> 00:10:44,270
只有当你 明确要求

289
00:10:44,270 --> 00:10:46,130
数据库系统为您提供排序

290
00:10:46,130 --> 00:10:48,800
并为您提供删除重复项它

291
00:10:48,800 --> 00:10:50,480
实际上不会这样做，这实际上

292
00:10:50,480 --> 00:10:54,320
使事情变得更有效率，

293
00:10:54,320 --> 00:10:55,850
所以今天的大纲是我们

294
00:10:55,850 --> 00:10:57,890
将涵盖聚合组

295
00:10:57,890 --> 00:11:00,080
字符串日期和时间上的一堆操作

296
00:11:00,080 --> 00:11:02,410
然后我们不得不做输出控制

297
00:11:02,410 --> 00:11:04,810
然后更复杂的

298
00:11:04,810 --> 00:11:06,400
事情是嵌套查询公共表

299
00:11:06,400 --> 00:11:08,860
表达式和窗口函数所以对于

300
00:11:08,860 --> 00:11:11,830
家庭作业你需要使用所有

301
00:11:11,830 --> 00:11:13,600
这些除了窗口函数

302
00:11:13,600 --> 00:11:15,520
像 它会做一个关于

303
00:11:15,520 --> 00:11:17,380
续集灯的作业，实际上

304
00:11:17,380 --> 00:11:18,790


305
00:11:18,790 --> 00:11:21,490
只有上周最新版本的续集灯才增加了对窗口

306
00:11:21,490 --> 00:11:23,650
函数的支持，但其他所有续集

307
00:11:23,650 --> 00:11:30,010
灯都应该能够支持，好吧，

308
00:11:30,010 --> 00:11:31,990
所以为此我们需要一个样本

309
00:11:31,990 --> 00:11:34,930
数据库由三个表组成，

310
00:11:34,930 --> 00:11:37,240
所以它是一个模拟大学，所以我们

311
00:11:37,240 --> 00:11:38,380
将有一个学生表，其中

312
00:11:38,380 --> 00:11:40,420
学生有学生 ID 姓名日志和

313
00:11:40,420 --> 00:11:42,850
GPS 将有一个课程 ta  ble 带有课程

314
00:11:42,850 --> 00:11:45,340
ID 的名称，然后我们将有一个注册表

315
00:11:45,340 --> 00:11:48,250
，其中我们有

316
00:11:48,250 --> 00:11:49,900
来自学生表和课程表的特定外键引用，以及

317
00:11:49,900 --> 00:11:52,450


318
00:11:52,450 --> 00:11:54,250
学生在课堂上获得的成绩，

319
00:11:54,250 --> 00:11:56,920
我们将使用它 作为我们的运行

320
00:11:56,920 --> 00:12:00,880
示例，我们继续前进，所以

321
00:12:00,880 --> 00:12:02,020
我们谈论聚合的第一件事

322
00:12:02,020 --> 00:12:04,270
是正确的，这些很

323
00:12:04,270 --> 00:12:05,740
容易理解它基本上是

324
00:12:05,740 --> 00:12:08,560
您在选择语句的输出列表中定义的一个函数，它将

325
00:12:08,560 --> 00:12:10,480


326
00:12:10,480 --> 00:12:14,140
作为输入多个元组 一

327
00:12:14,140 --> 00:12:16,960
组元组，它会在其

328
00:12:16,960 --> 00:12:18,880
上计算某种聚合

329
00:12:18,880 --> 00:12:21,700
并产生一个单一的结果，

330
00:12:21,700 --> 00:12:24,250
所以续集 92 标准定义了平均

331
00:12:24,250 --> 00:12:26,380
最小最大总和和计数，并再次考虑

332
00:12:26,380 --> 00:12:28,570
这就像你要计算的情况

333
00:12:28,570 --> 00:12:30,520
一袋元组作为输入

334
00:12:30,520 --> 00:12:32,320
，您将计算其中的

335
00:12:32,320 --> 00:12:33,310
元组数量，并且您将

336
00:12:33,310 --> 00:12:35,530
生成一个输出，该输出具有

337
00:12:35,530 --> 00:12:38,710
该计数正确，所以这

338
00:12:38,710 --> 00:12:41,650
就是基本标准中的内容

339
00:12:41,650 --> 00:12:43,870
标准的更高版本和

340
00:12:43,870 --> 00:12:45,100
其他数据库系统中，他们将在 github 不同聚合

341
00:12:45,100 --> 00:12:47,220
中具有其他内容，例如中值模式标准

342
00:12:47,220 --> 00:12:51,220
偏差

343
00:12:51,220 --> 00:12:52,240
，其中一些实际上还

344
00:12:52,240 --> 00:12:53,380
允许您找到自己的

345
00:12:53,380 --> 00:12:55,990
聚合，因此让我们看看这样的

346
00:12:55,990 --> 00:12:58,660
示例吧 所以说我们

347
00:12:58,660 --> 00:13:00,640
想要打折

348
00:13:00,640 --> 00:13:04,000
这个学生表中的学生数量，其中登录

349
00:13:04,000 --> 00:13:07,210
以 CS 结束，我稍后会介绍 like 是什么意思

350
00:13:07,210 --> 00:13:08,170
，但本质上它只是

351
00:13:08,170 --> 00:13:11,410
在这里寻找一个通配符，

352
00:13:11,410 --> 00:13:12,790
所以第一件事是最重要的

353
00:13:12,790 --> 00:13:14,380
要记住聚合

354
00:13:14,380 --> 00:13:16,360
是聚合只能出现在

355
00:13:16,360 --> 00:13:17,290
select 语句的输出列表

356
00:13:17,290 --> 00:13:20,260


357
00:13:20,260 --> 00:13:21,670


358
00:13:21,670 --> 00:13:23,410


359
00:13:23,410 --> 00:13:25,209
中 这里的其他部分是对的，因为它

360
00:13:25,209 --> 00:13:26,170
实际上没有意义，因为

361
00:13:26,170 --> 00:13:28,269
您在

362
00:13:28,269 --> 00:13:29,589
应用过滤器来

363
00:13:29,589 --> 00:13:31,300
确定哪些元组实际上与

364
00:13:31,300 --> 00:13:34,959
您的 where 子句匹配之后计算聚合，但是 这里同样要指出的

365
00:13:34,959 --> 00:13:37,959
是，在再次计数的情况下，我们

366
00:13:37,959 --> 00:13:39,149
只想计算元组的数量，

367
00:13:39,149 --> 00:13:41,890
此处的登录字段实际上并不

368
00:13:41,890 --> 00:13:45,370
意味着什么，因为我们只是在

369
00:13:45,370 --> 00:13:46,990
计算元组的数量，

370
00:13:46,990 --> 00:13:48,820
您是否知道什么并不重要 登录

371
00:13:48,820 --> 00:13:50,470
实际上是在我们进行过滤之后的那个点，

372
00:13:50,470 --> 00:13:53,829
所以我们可以重写它只是为了

373
00:13:53,829 --> 00:13:57,040
有一个明星 明星是一个特殊的

374
00:13:57,040 --> 00:13:59,860
你知道续集中的特殊关键字

375
00:13:59,860 --> 00:14:01,930
基本上说

376
00:14:01,930 --> 00:14:04,959
元组的所有属性开始更进一步说我们

377
00:14:04,959 --> 00:14:07,410
可以 实际上用一个

378
00:14:07,410 --> 00:14:10,660
正确地替换星号通过每次只添加一个来计算元组的数量，

379
00:14:10,660 --> 00:14:14,560


380
00:14:14,560 --> 00:14:16,149
这是一个很好的例子，其中我们有

381
00:14:16,149 --> 00:14:18,089
三个不同的查询，它们都产生

382
00:14:18,089 --> 00:14:20,320
或语义相同以产生

383
00:14:20,320 --> 00:14:22,839
相同的结果，但数据可能

384
00:14:22,839 --> 00:14:24,430
可以选择不同的口味或

385
00:14:24,430 --> 00:14:26,980
不同的变体来

386
00:14:26,980 --> 00:14:28,269
得出这个答案，其中一些可能

387
00:14:28,269 --> 00:14:29,589
有不同的性能差异

388
00:14:29,589 --> 00:14:33,220
这个非常简单，所以最大的

389
00:14:33,220 --> 00:14:34,420
差异会 聪明地意识到我

390
00:14:34,420 --> 00:14:36,220
不需要在这里登录的副本

391
00:14:36,220 --> 00:14:38,380
我可以用一个正确的替换它

392
00:14:38,380 --> 00:14:40,779
，他们中的大多数人会这样做但是从

393
00:14:40,779 --> 00:14:42,190
复杂的事情它可能并不

394
00:14:42,190 --> 00:14:45,220
总是有效我们实际上可以将

395
00:14:45,220 --> 00:14:46,510
聚合多个a grits组合在一起 在

396
00:14:46,510 --> 00:14:48,579
单个查询中，比如说对于这个查询，我们

397
00:14:48,579 --> 00:14:50,350
想要获得学生人数和他们的

398
00:14:50,350 --> 00:14:53,500
平均 GPA，他们的登录以 CS 结束，

399
00:14:53,500 --> 00:14:55,899
所以现在你看到我已经将

400
00:14:55,899 --> 00:14:59,769
它合并了平均 GPA 并在我的

401
00:14:59,769 --> 00:15:01,750
输出列表中为我的选择计数 语句，

402
00:15:01,750 --> 00:15:03,790
然后它会产生我的结果，就像

403
00:15:03,790 --> 00:15:07,779
这样非常简单我

404
00:15:07,779 --> 00:15:10,810
也可以添加 distinct 关键字来告诉它只

405
00:15:10,810 --> 00:15:13,209


406
00:15:13,209 --> 00:15:15,850
计算我的元组的不同元素或属性值，

407
00:15:15,850 --> 00:15:18,130
所以这就是说计算

408
00:15:18,130 --> 00:15:22,180
唯一学生的数量 来自学生表的唯一登录名，登录名

409
00:15:22,180 --> 00:15:23,680


410
00:15:23,680 --> 00:15:26,350
以 CS 结束，所以我现在拥有

411
00:15:26,350 --> 00:15:28,600
帐户的独特一面，这

412
00:15:28,600 --> 00:15:30,190
在某种程度上有点荒谬，

413
00:15:30,190 --> 00:15:33,460
因为大概没有两个学生可以

414
00:15:33,460 --> 00:15:36,340
拥有相同的登录名哟 你知道登录

415
00:15:36,340 --> 00:15:38,820
帐户，否则你会遇到问题，

416
00:15:38,820 --> 00:15:42,790
但在其他情况下，你知道你可以

417
00:15:42,790 --> 00:15:43,900
将同样的事情应用于其他

418
00:15:43,900 --> 00:15:45,340
场景，它会按照你想要的方式

419
00:15:45,340 --> 00:15:48,580
在这种情况下工作，在这里我们

420
00:15:48,580 --> 00:15:52,540
产生相同的结果，所以一件事

421
00:15:52,540 --> 00:15:54,070
现在你想要尝试

422
00:15:54,070 --> 00:15:55,660
开始做的是现在我开始做

423
00:15:55,660 --> 00:15:57,130
聚合我想获得

424
00:15:57,130 --> 00:16:01,060
关于我的数据的额外信息

425
00:16:01,060 --> 00:16:02,730
，而不是我在聚合中计算的内容，

426
00:16:02,730 --> 00:16:07,390
所以说我想要我想要 为了

427
00:16:07,390 --> 00:16:09,880
获得在课程中滚动的学生的平均 GPA

428
00:16:09,880 --> 00:16:11,380
，我想

429
00:16:11,380 --> 00:16:14,800
知道该课程 ID 是正确的，所以在

430
00:16:14,800 --> 00:16:16,900
这种情况下，我现在已将课程

431
00:16:16,900 --> 00:16:18,730
ID 添加到我的聚合之外的输出列表中

432
00:16:18,730 --> 00:16:22,300
猜猜

433
00:16:22,300 --> 00:16:28,030
这里会发生什么 这会起作用

434
00:16:28,030 --> 00:16:32,770
还是不起作用 你认为会

435
00:16:32,770 --> 00:16:35,890
起作用的举手 如果你认为

436
00:16:35,890 --> 00:16:52,570
它不起作用 看看你为什么正确 是的

437
00:16:52,570 --> 00:16:54,640
所以朱迪说

438
00:16:54,640 --> 00:16:58,210
我所有的元组都没有一个单一的课程 ID 正在

439
00:16:58,210 --> 00:17:00,280
竞争我的平均对齐我 是

440
00:17:00,280 --> 00:17:01,870
所有的学生都在参加所有

441
00:17:01,870 --> 00:17:03,910
不同的课程

442
00:17:03,910 --> 00:17:08,109
实际放置的课程 ID 是正确的输出 这

443
00:17:08,109 --> 00:17:10,240
是续集的标准 说这实际上是

444
00:17:10,240 --> 00:17:12,250
未定义的，在大多数系统中你

445
00:17:12,250 --> 00:17:15,189
实际上会得到一个错误 我们

446
00:17:15,189 --> 00:17:20,130
可以实际测试这一点 所以在这个

447
00:17:20,130 --> 00:17:24,280
好了，我有三个三终端

448
00:17:24,280 --> 00:17:25,480
设置，所以这是

449
00:17:25,480 --> 00:17:27,189
在我的办公室里运行一台机器我有三个

450
00:17:27,189 --> 00:17:29,440
面板，顶部一个是 Postgres，

451
00:17:29,440 --> 00:17:30,850
底部一个或中间一个是我的

452
00:17:30,850 --> 00:17:32,110
海鸥，底部一个是海鸥

453
00:17:32,110 --> 00:17:34,260
灯，

454
00:17:35,190 --> 00:17:37,230
它一样多 在这里您可以更轻松地从这台机器上输入，

455
00:17:37,230 --> 00:17:40,640
这样我就可以登录

456
00:17:41,600 --> 00:17:45,300
正确的，所以查询是我们想要

457
00:17:45,300 --> 00:17:49,700
选择它在哪里

458
00:17:49,700 --> 00:17:52,050
只是让

459
00:17:52,050 --> 00:17:52,950
每门课程注册的学生的平均 GPA

460
00:17:52,950 --> 00:18:01,550
正确，所以从注册中选择平均 sgpa 电子课程 ID

461
00:18:01,550 --> 00:18:09,120
作为 student as s 其中

462
00:18:09,120 --> 00:18:14,790
eise 拒绝 d 等于学生 ID 对，

463
00:18:14,790 --> 00:18:16,260
所以 Postgres 说你不能这样做，

464
00:18:16,260 --> 00:18:21,960
因为正如他所说的课程 ID，我在

465
00:18:21,960 --> 00:18:23,010
这里突出显示所以你看不到它

466
00:18:23,010 --> 00:18:26,280
所以课程 ID 没有定义它是  不是

467
00:18:26,280 --> 00:18:28,470
聚合权利的一部分，所以它

468
00:18:28,470 --> 00:18:29,640
不知道你真正想要哪个课程 ID，

469
00:18:29,640 --> 00:18:32,430
所以现在如果我们

470
00:18:32,430 --> 00:18:40,290
在我的续集中尝试这个，我的海鸥给了我们

471
00:18:40,290 --> 00:18:48,630
一个正确的答案，但这是正确的，没有

472
00:18:48,630 --> 00:18:50,430
权利，因为什么课程 ID

473
00:18:50,430 --> 00:18:52,710
做 我随机选择了一个正确的

474
00:18:52,710 --> 00:18:55,470
然后现在我们可以在 sequel Lite 中尝试同样的

475
00:18:55,470 --> 00:18:59,370
事情 sequel Lite 给了我们一个不同的

476
00:18:59,370 --> 00:19:00,930
课程 ID 所以你看到他们都参加

477
00:19:00,930 --> 00:19:03,390
了正确的平均但他们选择了

478
00:19:03,390 --> 00:19:06,300
不同的课程 ID 没问题只是

479
00:19:06,300 --> 00:19:07,640
因为我知道我的 海鸥家伙

480
00:19:07,640 --> 00:19:12,810
观看这些视频并抱怨我会

481
00:19:12,810 --> 00:19:15,420
说这是运行我的

482
00:19:15,420 --> 00:19:17,610
续集所以我的续集传统上允许

483
00:19:17,610 --> 00:19:18,960
你做这样松散的鹅绒事情

484
00:19:18,960 --> 00:19:20,880
所以这将运行

485
00:19:20,880 --> 00:19:23,190
他们称之为传统模式但

486
00:19:23,190 --> 00:19:25,260
你可以设置 续集模式更

487
00:19:25,260 --> 00:19:27,900
严格，所以现在如果我运行相同的查询，

488
00:19:27,900 --> 00:19:30,420
它会抛出与 Postgres 相同的空气，

489
00:19:30,420 --> 00:19:33,900
默认情况下我的续集

490
00:19:33,900 --> 00:19:36,180
5.7 现在在旧版本中抛出错误时，

491
00:19:36,180 --> 00:19:41,869
他们没有这样做，好吧，

492
00:19:41,869 --> 00:19:45,860
所以 aw 解决这个问题就是告别，

493
00:19:45,860 --> 00:19:48,210
所以对于组 I 将要发生的事情是

494
00:19:48,210 --> 00:19:50,700
现在我们要定义我们想要如何

495
00:19:50,700 --> 00:19:54,840


496
00:19:54,840 --> 00:19:58,080
根据一个属性将输出中的元组基本上组合在一起，

497
00:19:58,080 --> 00:19:59,669
然后现在我们可以计算

498
00:19:59,669 --> 00:20:00,419


499
00:20:00,419 --> 00:20:03,659
聚合 每个桶中的元组，

500
00:20:03,659 --> 00:20:05,220
所以我想要做的是获得

501
00:20:05,220 --> 00:20:08,460
每门课程的平均 GPA 如果我现在在

502
00:20:08,460 --> 00:20:10,499
group by 子句中添加我添加课程

503
00:20:10,499 --> 00:20:13,409
ID 当我第一次执行查询时会发生什么

504
00:20:13,409 --> 00:20:16,529
，这基本上

505
00:20:16,529 --> 00:20:18,869
是我想要的 在加入之后查看，但现在

506
00:20:18,869 --> 00:20:20,879
使用 group by 子句我将

507
00:20:20,879 --> 00:20:24,389
根据课程 ID 将两个帖子组合在一起

508
00:20:24,389 --> 00:20:27,119
，然后对于每个帖子，现在

509
00:20:27,119 --> 00:20:30,749
我将计算我的聚合，现在

510
00:20:30,749 --> 00:20:32,340
我可以按课程 ID 对它们进行分组，然后

511
00:20:32,340 --> 00:20:33,960
对应于从之前生成的桶，

512
00:20:33,960 --> 00:20:38,190
所以我们必须使用

513
00:20:38,190 --> 00:20:39,480
组 I，如果我们想提取

514
00:20:39,480 --> 00:20:41,820
有关我们正在计算的聚合的信息

515
00:20:41,820 --> 00:20:44,970
，就像

516
00:20:44,970 --> 00:20:48,179
之前我们有一个

517
00:20:48,179 --> 00:20:49,710
不会出现在我们的输出中的属性一样

518
00:20:49,710 --> 00:20:51,690
它有选择子句 出现在组 ID 中，

519
00:20:51,690 --> 00:20:53,759
所以在这里我们试图将学生

520
00:20:53,759 --> 00:20:55,799
姓名放入我们的输出 子句中

521
00:20:55,799 --> 00:20:58,559
它不起作用，因为它必须在我们的

522
00:20:58,559 --> 00:20:59,879
组中

523
00:20:59,879 --> 00:21:01,350


524
00:21:01,350 --> 00:21:03,509
正确的

525
00:21:03,509 --> 00:21:05,129
续集它产生了结果，但从

526
00:21:05,129 --> 00:21:06,360
人类的角度来看，我们知道这并不意味着

527
00:21:06,360 --> 00:21:07,529


528
00:21:07,529 --> 00:21:09,749


529
00:21:09,749 --> 00:21:12,149


530
00:21:12,149 --> 00:21:14,129


531
00:21:14,129 --> 00:21:18,779
什么好 所以现在你可能会觉得

532
00:21:18,779 --> 00:21:20,129
很好，也许我想对我所有

533
00:21:20,129 --> 00:21:22,590
的聚合进行更多一些额外的过滤，

534
00:21:22,590 --> 00:21:25,740
这样我就不会

535
00:21:25,740 --> 00:21:27,509
看着你知道我不会将每个

536
00:21:27,509 --> 00:21:30,960
结果都作为输出的一部分产生，所以你可能会

537
00:21:30,960 --> 00:21:33,200
认为 你想把它

538
00:21:33,200 --> 00:21:35,249
放在你的 where

539
00:21:35,249 --> 00:21:37,320
子句中使用聚合所以现在我现在正在计算

540
00:21:37,320 --> 00:21:39,690
每个 GPA 但我在我的 where

541
00:21:39,690 --> 00:21:42,360
子句中添加了一些东西说过滤掉

542
00:21:42,360 --> 00:21:45,779
GPA 不是你

543
00:21:45,779 --> 00:21:48,090
知道的更多 比 3.9 这看起来只是

544
00:21:48,090 --> 00:21:48,990
想看看 t 他的课程

545
00:21:48,990 --> 00:21:51,600
平均 GPA 大于 3.9，所以

546
00:21:51,600 --> 00:21:54,480
这行不通，因为在我们

547
00:21:54,480 --> 00:21:55,770


548
00:21:55,770 --> 00:21:58,110
的 where 子句中无法访问聚合中的任何内容，因为我们的 where 子句

549
00:21:58,110 --> 00:21:59,730
中还没有它们，

550
00:21:59,730 --> 00:22:02,880
所以再次思考的方式

551
00:22:02,880 --> 00:22:04,530
关于这是 where 子句在

552
00:22:04,530 --> 00:22:06,150
我们进行时过滤元组，

553
00:22:06,150 --> 00:22:08,220
在我们进行过滤之后，我们

554
00:22:08,220 --> 00:22:10,440
实际上可以然后计算机聚合，所以我们

555
00:22:10,440 --> 00:22:12,150
无法计算我们不能使用

556
00:22:12,150 --> 00:22:15,600
聚合来过滤元组，因为我们

557
00:22:15,600 --> 00:22:17,900
还没有计算聚合 然而

558
00:22:17,900 --> 00:22:20,220
，解决这个问题的方法

559
00:22:20,220 --> 00:22:22,559
是使用 have 子句，它

560
00:22:22,559 --> 00:22:24,419
本质上就像一个 where 子句，但现在

561
00:22:24,419 --> 00:22:26,220
您可以引用

562
00:22:26,220 --> 00:22:29,070
输出列表中的任何内容，所以我采用了我的平均 GPA

563
00:22:29,070 --> 00:22:32,309
并将其别名为 AVG GPA 并且我 可以

564
00:22:32,309 --> 00:22:35,010
在此处发布它，这将

565
00:22:35,010 --> 00:22:36,620
产生我想要的答案，正确

566
00:22:36,620 --> 00:22:38,640
计算聚合就像

567
00:22:38,640 --> 00:22:40,080
以前一样，然后对其应用额外的

568
00:22:40,080 --> 00:22:43,650
过滤，所以现在不是在这个

569
00:22:43,650 --> 00:22:45,900
例子中，但还有其他例子，

570
00:22:45,900 --> 00:22:47,160
你可以做某种特定的 o 再次

571
00:22:47,160 --> 00:22:50,460
根据您所知道的内容在系统

572
00:22:50,460 --> 00:22:52,799
中进行优化，这是

573
00:22:52,799 --> 00:22:54,150
声明式语言的一大优点，

574
00:22:54,150 --> 00:22:55,890
您可以提前了解所有

575
00:22:55,890 --> 00:22:58,140
内容，您知道程序员

576
00:22:58,140 --> 00:23:00,630
在他们的答案中想要什么，因此您

577
00:23:00,630 --> 00:23:03,419
可以使用有关什么的提示 你知道可以

578
00:23:03,419 --> 00:23:05,820
在查询计划的后面来帮助你

579
00:23:05,820 --> 00:23:07,799
做某些改进或减少

580
00:23:07,799 --> 00:23:09,090
你在运行查询时必须做的工作量

581
00:23:09,090 --> 00:23:12,240
，而不是使用平均

582
00:23:12,240 --> 00:23:15,960
GPA 说我想要做的帐户，其中

583
00:23:15,960 --> 00:23:18,600
元组的数量少于 有些你

584
00:23:18,600 --> 00:23:19,950
首先知道每个组小于某个

585
00:23:19,950 --> 00:23:22,650
值，所以当我继续

586
00:23:22,650 --> 00:23:24,750
计算我的聚合时，如果我

587
00:23:24,750 --> 00:23:27,510
意识到哦，我的条款说

588
00:23:27,510 --> 00:23:29,250
过滤任何少于十两个池的东西，

589
00:23:29,250 --> 00:23:31,590
如果我现在点击元组编号十一

590
00:23:31,590 --> 00:23:33,660
对于一个组，我知道我永远不需要

591
00:23:33,660 --> 00:23:36,210
为稍后出现的元组计算任何其他东西，

592
00:23:36,210 --> 00:23:38,429
因为它永远

593
00:23:38,429 --> 00:23:40,740
不会通过跌倒所以

594
00:23:40,740 --> 00:23:42,150
我可以在进行时扔掉这些元组，

595
00:23:42,150 --> 00:23:45,750
因为它浪费了工作 ri 如果

596
00:23:45,750 --> 00:23:47,070
你

597
00:23:47,070 --> 00:23:49,260
用 Python 之类的程序语言编写它，那么你

598
00:23:49,260 --> 00:23:51,059
必须编写这些步骤，但你

599
00:23:51,059 --> 00:23:53,790
自己知道你知道

600
00:23:53,790 --> 00:23:54,870
戴维森不会知道

601
00:23:54,870 --> 00:23:56,040
以后会发生什么，因为它不能

602
00:23:56,040 --> 00:23:58,230
偷看 在前面，但是在

603
00:23:58,230 --> 00:24:02,730
像 C 代码这样的声明性语言中，我们可以这样做，

604
00:24:02,730 --> 00:24:03,720
所以我们接下来要讨论的是

605
00:24:03,720 --> 00:24:06,259
如何处理字符串，

606
00:24:06,259 --> 00:24:08,269
所以这是一个表格，它

607
00:24:08,269 --> 00:24:12,440
总结了不同数据库系统中处理字符串的不同变体

608
00:24:12,440 --> 00:24:14,210


609
00:24:14,210 --> 00:24:17,600
所以续集

610
00:24:17,600 --> 00:24:20,210
标准指定的所有字符串，

611
00:24:20,210 --> 00:24:23,149
如一些 varchars 字符文本字段，

612
00:24:23,149 --> 00:24:26,059
它们必须区分大小写，

613
00:24:26,059 --> 00:24:27,979
你声明它们的方式是用单

614
00:24:27,979 --> 00:24:31,009
引号，大多数系统都遵循这

615
00:24:31,009 --> 00:24:33,019
一点，奇怪的红鲱

616
00:24:33,019 --> 00:24:35,779
鱼既是我的续集又是续集 light 所以

617
00:24:35,779 --> 00:24:38,749
在 sigil light 中，字符串是敏感的，

618
00:24:38,749 --> 00:24:40,899
但你可以同时使用单

619
00:24:40,899 --> 00:24:45,409
引号和双双引号 - 在我的续集中标记它们

620
00:24:45,409 --> 00:24:48,619
不区分大小写，你可以

621
00:24:48,619 --> 00:24:50,899
使用单引号或双引号 现在

622
00:24:50,899 --> 00:24:53,570
我的问题是，当我

623
00:24:53,570 --> 00:24:55,940
在 2000 年开始使用数据库系统时，我

624
00:24:55,940 --> 00:25:00,109
使用的是我的单三，

625
00:25:00,109 --> 00:25:01,669
就像你在我的记忆中根深蒂固一样

626
00:25:01,669 --> 00:25:03,019
只使用双引号，因为那

627
00:25:03,019 --> 00:25:04,789
是我们当时使用的，所以我总是有

628
00:25:04,789 --> 00:25:05,899
每次我切换

629
00:25:05,899 --> 00:25:08,179
到另一个本机系统时都要纠正自己，总是

630
00:25:08,179 --> 00:25:11,330
回去并使用单引号，我的 Seco

631
00:25:11,330 --> 00:25:13,249
再次拥有您可以说跟随立场的模式，

632
00:25:13,249 --> 00:25:14,749
它会变得更好，然后他们会

633
00:25:14,749 --> 00:25:17,690
强制执行单引号要求，但

634
00:25:17,690 --> 00:25:19,450
我认为 默认情况下你没有做

635
00:25:19,450 --> 00:25:22,159
对，所以在 siegel 标准中说你

636
00:25:22,159 --> 00:25:24,889
想取你想取

637
00:25:24,889 --> 00:25:27,769
的名字 kanye 并将它

638
00:25:27,769 --> 00:25:31,629
与 kanye 匹配，你知道

639
00:25:31,629 --> 00:25:34,519
在单一标准中混合大小写你有

640
00:25:34,519 --> 00:25:36,349
大写 使用 upper 你知道

641
00:25:36,349 --> 00:25:38,269
upper 函数来使这个匹配工作，

642
00:25:38,269 --> 00:25:40,129
而我的续集你不必这样做

643
00:25:40,129 --> 00:25:41,989
，因为所有的字符串都是

644
00:25:41,989 --> 00:25:45,470
匹配的或不区分大小写的，现在我

645
00:25:45,470 --> 00:25:47,059
在如何做 light 子句之前展示了这个，

646
00:25:47,059 --> 00:25:48,769
但我认为这是一个 谎言 你做

647
00:25:48,769 --> 00:25:52,309
了第一个字符串匹配，

648
00:25:52,309 --> 00:25:54,440
所以基本上是你知道尝试

649
00:25:54,440 --> 00:25:56,960
将字符串中的一些通配符

650
00:25:56,960 --> 00:26:00,919
与另一个字符串匹配，所以

651
00:26:00,919 --> 00:26:02,299
无论出于何种原因，而不是

652
00:26:02,299 --> 00:26:03,950
像大多数其他东西一样使用星号，他们使用

653
00:26:03,950 --> 00:26:08,869
打印 a % 所以 % 意味着任何 一个或多个

654
00:26:08,869 --> 00:26:11,029
字符串，然后下划线表示

655
00:26:11,029 --> 00:26:13,519
完全匹配一个字符，所以

656
00:26:13,519 --> 00:26:14,960
说我想从以tene 215 445 721 开头的角色表中获取所有课程或

657
00:26:14,960 --> 00:26:16,999
所有课程ID

658
00:26:16,999 --> 00:26:19,260


659
00:26:19,260 --> 00:26:23,610
我会使用

660
00:26:23,610 --> 00:26:26,190
安培％ 并说如果我

661
00:26:26,190 --> 00:26:28,110
想让所有学生都

662
00:26:28,110 --> 00:26:31,230
登录以 C 结尾，然后是一些

663
00:26:31,230 --> 00:26:33,300
通配符，我将使用一个

664
00:26:33,300 --> 00:26:38,040
下划线，因此海鸥标准还

665
00:26:38,040 --> 00:26:40,520
定义了一堆字符串函数

666
00:26:40,520 --> 00:26:43,110
，这又是一个标准的东西，你

667
00:26:43,110 --> 00:26:46,010
会 期望像 substring upper lower

668
00:26:46,010 --> 00:26:48,570
trim 或者这些都是续集

669
00:26:48,570 --> 00:26:50,220
9q 标准的一部分，移动系统会有

670
00:26:50,220 --> 00:26:51,840
这个，但当然会有

671
00:26:51,840 --> 00:26:54,450
一堆其他东西在

672
00:26:54,450 --> 00:26:57,300
每个不同的数据库中都是专有的 系统因此

673
00:26:57,300 --> 00:26:59,280
要指出与

674
00:26:59,280 --> 00:27:01,800
带有字符串函数的聚合函数不同，并且您

675
00:27:01,800 --> 00:27:03,210
知道数学函数和日期

676
00:27:03,210 --> 00:27:05,280
函数它们可以出现在您查询中的任何位置，

677
00:27:05,280 --> 00:27:07,950
因此它们可以

678
00:27:07,950 --> 00:27:09,240
出现在选择输出列表中，也可以出现

679
00:27:09,240 --> 00:27:10,950
在您的谓词中-- 好吧，它们并不

680
00:27:10,950 --> 00:27:13,650
总是必须在选择

681
00:27:13,650 --> 00:27:14,790
部分中，它们可能意味着您有

682
00:27:14,790 --> 00:27:18,240
子句，所以在这里我们让您

683
00:27:18,240 --> 00:27:20,460
知道第一个查询将采用

684
00:27:20,460 --> 00:27:22,110
名称并采用子字符串，然后

685
00:27:22,110 --> 00:27:23,940
只需获取第一个 五个字符，

686
00:27:23,940 --> 00:27:25,650
然后我们做的第二个

687
00:27:25,650 --> 00:27:29,250
是在进行匹配之前显示

688
00:27:29,250 --> 00:27:33,140
学生姓名的大写版本

689
00:27:33,140 --> 00:27:37,410
以 Kay kan 开头，因此字符串

690
00:27:37,410 --> 00:27:38,490
函数在大多数情况下都是

691
00:27:38,490 --> 00:27:39,870
基本的，将

692
00:27:39,870 --> 00:27:41,850
在所有系统中标准化

693
00:27:41,850 --> 00:27:43,290
当你想要开始连接时事情变得很奇怪，

694
00:27:43,290 --> 00:27:45,780
所以 Seco

695
00:27:45,780 --> 00:27:47,580
标准说你使用两个

696
00:27:47,580 --> 00:27:50,450
双杠将两个字符串连接在一起

697
00:27:50,450 --> 00:27:54,420
，大多数系统在我的

698
00:27:54,420 --> 00:27:55,890
意见中遵循这一点 我会说 Oracle 中的 Postgres

699
00:27:55,890 --> 00:27:57,150
可能遵循

700
00:27:57,150 --> 00:28:00,360
了所有系统中最好的续集

701
00:28:00,360 --> 00:28:03,660
服务器和 db2 的续集标准

702
00:28:03,660 --> 00:28:05,130
然后可能我的续集是

703
00:28:05,130 --> 00:28:09,060
最糟糕的所以你想说

704
00:28:09,060 --> 00:28:12,690
连接学生姓名并添加 es

705
00:28:12,690 --> 00:28:15,060
在 Microsoft 的续集服务器的续集标准中使用双条

706
00:28:15,060 --> 00:28:17,190
你

707
00:28:17,190 --> 00:28:20,010
在我的续集中使用加号 他们没有

708
00:28:20,010 --> 00:28:21,990
加号 他们没有双条

709
00:28:21,990 --> 00:28:26,160
他们只有这个 concat 函数

710
00:28:26,160 --> 00:28:27,630
你基本上定义为输入

711
00:28:27,630 --> 00:28:28,950
参数 你想要

712
00:28:28,950 --> 00:28:30,990
连接在一起的东西 他们还有一些

713
00:28:30,990 --> 00:28:32,490
其他的东西，

714
00:28:32,490 --> 00:28:33,750


715
00:28:33,750 --> 00:28:36,000
如果你不在两个字符串文字之间放置任何东西

716
00:28:36,000 --> 00:28:37,620
将它们连接在一起

717
00:28:37,620 --> 00:28:39,750


718
00:28:39,750 --> 00:28:42,900
，那么你实际上可以在哪里 有我的 Siegel 这样我就可以

719
00:28:42,900 --> 00:28:51,210
做这样的事情 一个 dy space PA

720
00:28:51,210 --> 00:28:57,360
VLO 对，据我所知，没有其他人这样做过

721
00:28:57,360 --> 00:28:58,470
，

722
00:28:58,470 --> 00:29:01,010
在我对你撒谎之前让我仔细检查一下，

723
00:29:01,010 --> 00:29:05,370
让我们尝试一下吧，是的，首先，

724
00:29:05,370 --> 00:29:07,640
toka Chris 不知道 ke it

725
00:29:07,640 --> 00:29:09,480
续集服务器也不喜欢它，

726
00:29:09,480 --> 00:29:13,560
只有我的续集才可以，

727
00:29:13,560 --> 00:29:15,510
所以现在我们的情况变得非常

728
00:29:15,510 --> 00:29:18,120
糟糕，当您拥有正确的日期和时间

729
00:29:18,120 --> 00:29:21,240
功能时，日期基本上

730
00:29:21,240 --> 00:29:22,860
可以只记录时间戳而

731
00:29:22,860 --> 00:29:25,650
没有时间 时间戳是现在

732
00:29:25,650 --> 00:29:28,080
他们根据他们可能跟踪的时间粒度而变化的时间

733
00:29:28,080 --> 00:29:29,940
有时以

734
00:29:29,940 --> 00:29:31,500
秒为单位有时以毫秒

735
00:29:31,500 --> 00:29:33,120
或比这更细粒度的

736
00:29:33,120 --> 00:29:34,110


737
00:29:34,110 --> 00:29:37,410
东西但是事情变得不稳定的地方是

738
00:29:37,410 --> 00:29:39,330
你如何实际开始操纵它们并

739
00:29:39,330 --> 00:29:40,860
提取它们

740
00:29:40,860 --> 00:29:44,700
正确地从它们中提取信息，因此

741
00:29:44,700 --> 00:29:46,590
所有这些不同系统的语法可能

742
00:29:46,590 --> 00:29:49,080
会有很大差异，因此对于这个示例，我们

743
00:29:49,080 --> 00:29:51,540
想要做的是我想向您展示如何

744
00:29:51,540 --> 00:29:53,280
做我认为看似简单的

745
00:29:53,280 --> 00:29:56,310
功能或简单的

746
00:29:56,310 --> 00:30:00,000
操作 从今天到年初以来的几天

747
00:30:00,000 --> 00:30:02,130
，我们将看到如何

748
00:30:02,130 --> 00:30:03,420
尝试在这三个

749
00:30:03,420 --> 00:30:06,600
不同的系统上做到

750
00:30:06,600 --> 00:30:08,640


751
00:30:08,640 --> 00:30:13,790
这一点 现在是租用时间

752
00:30:18,830 --> 00:30:33,020
我只是杀了我的妻子 我还好 回来

753
00:30:33,020 --> 00:30:37,400
好吧 所以 seco 标准定义了一个 now

754
00:30:37,400 --> 00:30:39,650
函数可以让每个人都看到 或者现在

755
00:30:39,650 --> 00:30:41,810
在后面 伙计们你能看到它 很酷

756
00:30:41,810 --> 00:30:45,710
所以你现在打电话 它会给你

757
00:30:45,710 --> 00:30:48,730
当前的时间戳 所以我们可以

758
00:30:48,730 --> 00:30:54,650
在我的续集中做到这一点，我们可以在续集中做到这一点，

759
00:30:54,650 --> 00:30:59,930
你不能在

760
00:30:59,930 --> 00:31:03,080
单一的氛围

761
00:31:03,080 --> 00:31:04,760
中做到这一点好吧，所以有另一种方法可以做到这一点，

762
00:31:04,760 --> 00:31:07,280
他们有另一个称为

763
00:31:07,280 --> 00:31:11,720
当前时间戳的函数，除了

764
00:31:11,720 --> 00:31:13,610
Postgres 没有 没有，但他们有关键字

765
00:31:13,610 --> 00:31:17,240
current time Stan 我的续集有这个

766
00:31:17,240 --> 00:31:23,540
功能，它有关键字 all

767
00:31:23,540 --> 00:31:24,920
right single Lane 谁说它有这个

768
00:31:24,920 --> 00:31:29,690
功能举手所以

769
00:31:29,690 --> 00:31:32,750
谁说它有关键字 all right 它

770
00:31:32,750 --> 00:31:34,760
混合了 all right 他们没有这个

771
00:31:34,760 --> 00:31:37,550
功能 他们有一个

772
00:31:37,550 --> 00:31:39,440
关键字还好 简单的事情，比如当前时间是多少

773
00:31:39,440 --> 00:31:40,280


774
00:31:40,280 --> 00:31:43,700
一切都在变化 所以现在我们

775
00:31:43,700 --> 00:31:45,020
想要做的是我们想要计算

776
00:31:45,020 --> 00:31:48,500
自

777
00:31:48,500 --> 00:31:53,960
年初以来的天数 好吧，就像

778
00:31:53,960 --> 00:31:56,110
ab  uilding 块我们可以尝试做的

779
00:31:56,110 --> 00:31:58,310
可能只是获取

780
00:31:58,310 --> 00:32:01,190
从今天算起的天数所以在这个查询中

781
00:32:01,190 --> 00:32:04,490
我正在做的是我正在这里列出的日期

782
00:32:04,490 --> 00:32:06,950
是一个字符串，所以我将

783
00:32:06,950 --> 00:32:08,870
字符串用于 今天的日期并将

784
00:32:08,870 --> 00:32:10,700
其转换为日期，然后我有

785
00:32:10,700 --> 00:32:13,310
提取功能，该功能将

786
00:32:13,310 --> 00:32:17,330
正确提取日期的日期字段，因此

787
00:32:17,330 --> 00:32:19,840
正如预期的那样，您会得到 29，

788
00:32:19,840 --> 00:32:22,040
我们可以在

789
00:32:22,040 --> 00:32:27,020
它给您的和其他人中尝试 29 他们不太

790
00:32:27,020 --> 00:32:28,430


791
00:32:28,430 --> 00:32:32,880
好所以但现在我们可以看到，

792
00:32:32,880 --> 00:32:36,840
如果我可以的话，如果我可以将日期的字符串

793
00:32:36,840 --> 00:32:39,630
转换为日期会发生什么如果我

794
00:32:39,630 --> 00:32:43,170
只是减去它们会发生什么我说我

795
00:32:43,170 --> 00:32:45,540
会选择今天的日期 并

796
00:32:45,540 --> 00:32:47,880
从年初的日期中减去它

797
00:32:47,880 --> 00:32:51,630
，在 Postgres 中我们得到了 240 天，

798
00:32:51,630 --> 00:33:00,210
我的续集 728 我不

799
00:33:00,210 --> 00:33:02,400
知道这意味着什么，就像它不像

800
00:33:02,400 --> 00:33:04,530
240 乘以 2 或某些你知道一些

801
00:33:04,530 --> 00:33:06,600
倍数是对的 这是一个正确的数字

802
00:33:06,600 --> 00:33:09,270
，但它不是我们想要的，

803
00:33:09,270 --> 00:33:13,860
所以现在让我们尝试一下 sequel

804
00:33:13,860 --> 00:33:19,590
light sequel like 给我们 0 好吧，所以

805
00:33:19,590 --> 00:33:20,730
它在 Postgres 中工作，现在我们必须

806
00:33:20,730 --> 00:33:24,210
弄清楚如何在我的续集中做到这一点，

807
00:33:24,210 --> 00:33:29,460
所以我们可以做的是我们尝试从中

808
00:33:29,460 --> 00:33:33,120
提取这一天，所以也许我们

809
00:33:33,120 --> 00:33:34,910
采取我们打赌的 我们之前有 728 是

810
00:33:34,910 --> 00:33:37,890
对的，我们从中提取了一天，

811
00:33:37,890 --> 00:33:39,660
看看这意味着什么，它

812
00:33:39,660 --> 00:33:41,430
以 28 返回，所以这不是

813
00:33:41,430 --> 00:33:44,940
我们真正想要的，所以实际上这样做的方法

814
00:33:44,940 --> 00:33:48,960
有点复杂，我们要做的是

815
00:33:48,960 --> 00:33:51,600
我们' 重新将日期转换为

816
00:33:51,600 --> 00:33:53,460
UNIX 时间戳，这是

817
00:33:53,460 --> 00:33:55,110
自单位到纪元以来的秒数，

818
00:33:55,110 --> 00:33:58,320
就像某些 Jan 指的是 1970 年一样，

819
00:33:58,320 --> 00:33:59,640
现在我们将

820
00:33:59,640 --> 00:34:01,350
获得从当前

821
00:34:01,350 --> 00:34:02,850
日期开始的秒数秒数

822
00:34:02,850 --> 00:34:05,910
我们正确地减去它们，这给了我们

823
00:34:05,910 --> 00:34:07,560
从现在到年初之间的秒数

824
00:34:07,560 --> 00:34:09,989
，然后我们

825
00:34:09,989 --> 00:34:12,840
将把它除以 60 秒乘以 60

826
00:34:12,840 --> 00:34:17,520
分钟乘以 24 天，我们得到了 240 次

827
00:34:17,520 --> 00:34:18,590


828
00:34:18,590 --> 00:34:20,730
结果，但在我这样做之后

829
00:34:20,730 --> 00:34:22,139
第一次实际上甚至 eas

830
00:34:22,139 --> 00:34:26,159
在我的续集中，他们有一个简单的

831
00:34:26,159 --> 00:34:28,710
函数，叫做 date div，它

832
00:34:28,710 --> 00:34:30,690
产生你知道相同的答案，好吧

833
00:34:30,690 --> 00:34:32,260


834
00:34:32,260 --> 00:34:40,940
sico light uh-huh for Brianna 我

835
00:34:40,940 --> 00:34:41,929
想让我试着把它弄大一点

836
00:34:41,929 --> 00:34:45,889
，在他们没有的单光下

837
00:34:45,889 --> 00:34:48,080
日期，如果你不能互相减去年龄，

838
00:34:48,080 --> 00:34:51,050
我想出来的方法

839
00:34:51,050 --> 00:34:53,540
是将当前时间戳

840
00:34:53,540 --> 00:34:56,540
转换为儒略历，这是

841
00:34:56,540 --> 00:35:01,600
自公元前 4370 年以来的天数

842
00:35:01,600 --> 00:35:06,620
4370 年疼痛，所以你减去更多

843
00:35:06,620 --> 00:35:08,510
从那以后的

844
00:35:08,510 --> 00:35:11,210
天数是一年开始的天数，你可以得到

845
00:35:11,210 --> 00:35:15,860
大约 240 天，我们可以

846
00:35:15,860 --> 00:35:20,290
将它转换为 int，我们得到 240 天，

847
00:35:20,290 --> 00:35:24,440
所以这是三个超级广泛

848
00:35:24,440 --> 00:35:26,990
使用的数据库系统，它们在

849
00:35:26,990 --> 00:35:28,730
一些基本功能上都不同

850
00:35:28,730 --> 00:35:31,460
正确的日期和时间实际上是快速

851
00:35:31,460 --> 00:35:33,590
举手谁想到

852
00:35:33,590 --> 00:35:34,850
这三个你认为最流行的

853
00:35:34,850 --> 00:35:36,410
错过广泛部署的数据库系统

854
00:35:36,410 --> 00:35:38,270
举手你认为我的续集

855
00:35:38,270 --> 00:35:42,380
大约四分之一举你的手认为

856
00:35:42,380 --> 00:35:45,620
Postgres 更不用说 Radian 认为海鸥

857
00:35:45,620 --> 00:35:51,970
灯更不用说续集灯

858
00:35:51,970 --> 00:35:54,980
所以几年前我们让理查德嬉皮士

859
00:35:54,980 --> 00:35:56,420
发明了我们的续集灯 所以看到

860
00:35:56,420 --> 00:35:58,940
光是惊人的 它是由三个

861
00:35:58,940 --> 00:36:04,760
家伙在那里写的 他们是他近似

862
00:36:04,760 --> 00:36:07,090
它已部署在 100 亿台设备上

863
00:36:07,090 --> 00:36:09,650
这里的每个拥有手机的人

864
00:36:09,650 --> 00:36:11,480
，不是翻盖手机或老人

865
00:36:11,480 --> 00:36:13,610
手机，现在都在上面运行续集灯

866
00:36:13,610 --> 00:36:16,070
很多桌面

867
00:36:16,070 --> 00:36:18,500
应用程序，如 Photoshop 和

868
00:36:18,500 --> 00:36:20,180
illustrator 他们在内部运行续集灯

869
00:36:20,180 --> 00:36:22,250
右续集灯无处不在

870
00:36:22,250 --> 00:36:25,160
他说，

871
00:36:25,160 --> 00:36:26,690
如果你知道

872
00:36:26,690 --> 00:36:28,400
在 2000 年代初期互联网在美国

873
00:36:28,400 --> 00:36:30,890
还算是新鲜事物，那对每一张 AOL CD 来说都是正确的 有

874
00:36:30,890 --> 00:36:32,660
一家名为美国在线的公司，他们

875
00:36:32,660 --> 00:36:35,330
会

876
00:36:35,330 --> 00:36:37,220
在互联网上免费向每个人邮寄 10 小时的

877
00:36:37,220 --> 00:36:38,900
CD 就他们寄出的每张 CD，你知道

878
00:36:38,900 --> 00:36:41,120
数以亿计的人都有续集

879
00:36:41,120 --> 00:36:43,580
灯在上面运行 续集 a

880
00:36:43,580 --> 00:36:45,290
部署最广泛 大卫

881
00:36:45,290 --> 00:36:46,490
无处不在， 这是最疯狂的

882
00:36:46,490 --> 00:36:48,860
部分，它是公共领域，他

883
00:36:48,860 --> 00:36:51,920
免费赠送，我的意思是 Postgres 和我的

884
00:36:51,920 --> 00:36:53,870
Segal 是开源的，但就像 Haytham

885
00:36:53,870 --> 00:36:56,000
哦，我的续集 Oracle 拥有它所有 Co

886
00:36:56,000 --> 00:36:58,220
拥有版权，续集 Lite 没有版权，

887
00:36:58,220 --> 00:37:01,040
这是一件了不起的作品

888
00:37:01,040 --> 00:37:05,180
软件还可以，所以

889
00:37:05,180 --> 00:37:07,370
这里的主要内容是，简单的

890
00:37:07,370 --> 00:37:09,530
事情很难做，因为没有

891
00:37:09,530 --> 00:37:10,880
印章，你知道没有标准的做事方式

892
00:37:10,880 --> 00:37:12,110
，即使有一个

893
00:37:12,110 --> 00:37:15,980
标准的 Tessa fication 好吧，所以现在

894
00:37:15,980 --> 00:37:17,540
也许你想要做的是 而不是

895
00:37:17,540 --> 00:37:20,600
让你知道在我的例子中，

896
00:37:20,600 --> 00:37:22,790
我每次运行查询时都打开终端

897
00:37:22,790 --> 00:37:24,890
，输出被打印

898
00:37:24,890 --> 00:37:27,110
回我和我的终端，但也许你

899
00:37:27,110 --> 00:37:29,000
想要什么 o 是保留

900
00:37:29,000 --> 00:37:31,100
您从查询中生成的所有数据 将其保留

901
00:37:31,100 --> 00:37:32,990
在数据库系统中，以便您可以

902
00:37:32,990 --> 00:37:34,970
在后续查询中使用它，

903
00:37:34,970 --> 00:37:36,890
如果

904
00:37:36,890 --> 00:37:38,320
您的查询生成大量输出

905
00:37:38,320 --> 00:37:40,280
，则效率更高 所有东西都

906
00:37:40,280 --> 00:37:41,930
坐在你的笔记本电脑上，然后把它推

907
00:37:41,930 --> 00:37:44,210
回去做更多的查询，这样你就可以进行

908
00:37:44,210 --> 00:37:45,830
输出重定向，告诉它说嘿，

909
00:37:45,830 --> 00:37:47,840
不要把它打印出来给我写到

910
00:37:47,840 --> 00:37:48,670
这个位置，

911
00:37:48,670 --> 00:37:51,020
所以你要做的一件事是 您可以获取

912
00:37:51,020 --> 00:37:52,280
输出或查询，并且可以将其

913
00:37:52,280 --> 00:37:57,020
正确写入另一个表中，因此

914
00:37:57,020 --> 00:37:58,820
您可以在续集标准中使用，

915
00:37:58,820 --> 00:38:01,310
这实际上

916
00:38:01,310 --> 00:38:03,500
将为您即时创建表，因此无论生成什么都会

917
00:38:03,500 --> 00:38:06,890
产生查询的输出

918
00:38:06,890 --> 00:38:08,900
这又是声明性的，数据

919
00:38:08,900 --> 00:38:10,280
系统已经知道表的模式是什么，

920
00:38:10,280 --> 00:38:11,870
所以在这种情况下它

921
00:38:11,870 --> 00:38:13,610
知道这个输出的类型

922
00:38:13,610 --> 00:38:15,170
是什么，所以他知道如何定义

923
00:38:15,170 --> 00:38:17,870
一个可以处理

924
00:38:17,870 --> 00:38:20,240
这些类型的表 对所以基本上

925
00:38:20,240 --> 00:38:21,560
将输出进行选择并将其

926
00:38:21,560 --> 00:38:24,020
写入表中，在我的续集中，您

927
00:38:24,020 --> 00:38:25,460
必须使用创建表，然后

928
00:38:25,460 --> 00:38:29,290
在其中定义您的 Select 语句，

929
00:38:29,290 --> 00:38:32,420
您还可以将其输出数据到

930
00:38:32,420 --> 00:38:35,870
现有表中，为此您使用

931
00:38:35,870 --> 00:38:38,180
insert into 这看起来很像我们

932
00:38:38,180 --> 00:38:39,860
从之前创建的创建表

933
00:38:39,860 --> 00:38:41,780
，然后

934
00:38:41,780 --> 00:38:43,520
你实际上只有一个

935
00:38:43,520 --> 00:38:45,680
select 语句，只是为了告诉它嘿，获取

936
00:38:45,680 --> 00:38:47,810
这些数据不是正确的，所以

937
00:38:47,810 --> 00:38:49,700
关于这个例子的重要事情是

938
00:38:49,700 --> 00:38:51,650
与上一张幻灯片相比，这是关于

939
00:38:51,650 --> 00:38:53,660
在两个已经存在的表中的两个元组中写入表，

940
00:38:53,660 --> 00:38:56,000
这意味着

941
00:38:56,000 --> 00:38:58,920


942
00:38:58,920 --> 00:39:00,720
无论键入数字属性和它们的

943
00:39:00,720 --> 00:39:02,490
类型，

944
00:39:02,490 --> 00:39:04,380
无论你将它写入哪个表，

945
00:39:04,380 --> 00:39:07,829
都必须由 Select 语句生成

946
00:39:07,829 --> 00:39:10,380
如果 Select 语句有 44 列，并且

947
00:39:10,380 --> 00:39:12,089
您每天要写入的表为

948
00:39:12,089 --> 00:39:13,829
3 列，则匹配正确，并且我们将抛出空气，它说

949
00:39:13,829 --> 00:39:15,390
我无法写入，因为它是

950
00:39:15,390 --> 00:39:18,329
Astros d 现在不匹配 事情

951
00:39:18,329 --> 00:39:19,920
变得奇怪的地方是当你开始

952
00:39:19,920 --> 00:39:23,130
在你试图写入的表上有约束

953
00:39:23,130 --> 00:39:25,710
并且 Select

954
00:39:25,710 --> 00:39:27,540
语句实际上违反了这些

955
00:39:27,540 --> 00:39:30,030
约束所以假设

956
00:39:30,030 --> 00:39:31,890
我的表上有一个主键它说 我不能

957
00:39:31,890 --> 00:39:34,440
有任何重复的学生 ID，然后

958
00:39:34,440 --> 00:39:37,049
我的插入查询尝试开始并

959
00:39:37,049 --> 00:39:39,990
开始插入重复项 某些数据库

960
00:39:39,990 --> 00:39:41,510
系统会

961
00:39:41,510 --> 00:39:44,309
在看到重复项时立即抛出错误并且

962
00:39:44,309 --> 00:39:46,049
没有写入元组，其中一些

963
00:39:46,049 --> 00:39:47,670
将继续执行和 忽略

964
00:39:47,670 --> 00:39:50,819
那些失败的其他人将插入

965
00:39:50,819 --> 00:39:52,650
成功的那些并

966
00:39:52,650 --> 00:39:54,630
忽略那些失败的或者可能只是立即

967
00:39:54,630 --> 00:39:57,480
崩溃所以seco

968
00:39:57,480 --> 00:39:59,069
标准再次说明这是它使用的语法

969
00:39:59,069 --> 00:40:01,170
但是所有系统如何实际

970
00:40:01,170 --> 00:40:05,089
实现它

971
00:40:05,660 --> 00:40:07,980
除了输出重定向之外我们

972
00:40:07,980 --> 00:40:10,170
还可以进行输出控制 记住我

973
00:40:10,170 --> 00:40:12,359
说开始 Seco 是基于包

974
00:40:12,359 --> 00:40:14,579
代数 我的意思是它是无序的 但

975
00:40:14,579 --> 00:40:15,960
有很多时候你想要 t

976
00:40:15,960 --> 00:40:19,049
在你的输出子句中的排序，所以要

977
00:40:19,049 --> 00:40:21,119
做到这一点，你添加 order by 子句

978
00:40:21,119 --> 00:40:24,000
我看到基本上是指定如何对这个查询生成

979
00:40:24,000 --> 00:40:25,829
的结果进行排序，

980
00:40:25,829 --> 00:40:29,940
所以在这个

981
00:40:29,940 --> 00:40:31,770
例子中，我将开始对元组

982
00:40:31,770 --> 00:40:33,390
进行排序 排序元组主要角色

983
00:40:33,390 --> 00:40:37,799
表基于他们的等级和

984
00:40:37,799 --> 00:40:40,680
默认情况下即使我没有指定

985
00:40:40,680 --> 00:40:42,660
我是否想要升序和或

986
00:40:42,660 --> 00:40:44,760
降序默认值和续集是

987
00:40:44,760 --> 00:40:46,799
你现在升序你得到这样的

988
00:40:46,799 --> 00:40:49,020
输出但我也可以添加

989
00:40:49,020 --> 00:40:51,869
额外的属性 对我的 order by

990
00:40:51,869 --> 00:40:54,240
子句做更复杂的事情，所以在

991
00:40:54,240 --> 00:40:55,950
这种情况下，我想

992
00:40:55,950 --> 00:40:58,619
按等级按降序排序，然后

993
00:40:58,619 --> 00:41:01,170
根据

994
00:41:01,170 --> 00:41:04,290
学生 ID 按升序对它们进行排序，

995
00:41:04,290 --> 00:41:06,750
我现在会得到这样的输出

996
00:41:06,750 --> 00:41:08,369
这里还需要指出的重要

997
00:41:08,369 --> 00:41:11,160
一点是，与 group by

998
00:41:11,160 --> 00:41:12,380
子句

999
00:41:12,380 --> 00:41:14,509
中的不同，我希望我的

1000
00:41:14,509 --> 00:41:16,729
输出列表的任何属性都必须出现在 group

1001
00:41:16,729 --> 00:41:18,559
by 子句中，以便您没有

1002
00:41:18,559 --> 00:41:20,900
该限制权

1003
00:41:20,900 --> 00:41:23,210
在这种情况下，它实际上是双向的，在这里我

1004
00:41:23,210 --> 00:41:25,549
按成绩排序，但成绩不是

1005
00:41:25,549 --> 00:41:28,880
输出的一部分，它并不重要

1006
00:41:28,880 --> 00:41:31,069
，它知道如何

1007
00:41:31,069 --> 00:41:33,109
找到它需要的数据作为它的

1008
00:41:33,109 --> 00:41:35,390
处理查询并执行

1009
00:41:35,390 --> 00:41:36,769
您想做的任何排序操作我

1010
00:41:36,769 --> 00:41:38,779
也可以做更复杂的事情我

1011
00:41:38,779 --> 00:41:41,180
也可以按条款在我的订单中放置任何任意表达式，

1012
00:41:41,180 --> 00:41:42,799
因此我可以

1013
00:41:42,799 --> 00:41:45,890
按 1 加 1 正确进行排序，这仍然

1014
00:41:45,890 --> 00:41:49,059
有效 知道如何处理

1015
00:41:49,479 --> 00:41:51,529
你想做的另一件事

1016
00:41:51,529 --> 00:41:53,690
是限制在你的输出中产生的元组的数量，

1017
00:41:53,690 --> 00:41:55,369


1018
00:41:55,369 --> 00:41:56,660
当然有一个限制子句

1019
00:41:56,660 --> 00:41:58,940
，他基本上指定说我

1020
00:41:58,940 --> 00:42:01,910
对你所有的结果迈克 我的

1021
00:42:01,910 --> 00:42:04,670
查询只为我提供了一些数量

1022
00:42:04,670 --> 00:42:07,789
，比如 10 个，这

1023
00:42:07,789 --> 00:42:09,650
对于你知道的事情很常见，比如

1024
00:42:09,650 --> 00:42:11,900
搜索结果，你会看到它只显示

1025
00:42:11,900 --> 00:42:13,519
10，然后你点击下一步按钮

1026
00:42:13,519 --> 00:42:15,079
去查看接下来的 10 这是

1027
00:42:15,079 --> 00:42:16,999
由它控制的 限制和

1028
00:42:16,999 --> 00:42:19,219
实际上都设置了所以限制只是说

1029
00:42:19,219 --> 00:42:21,769
限制所有设置的元组数量

1030
00:42:21,769 --> 00:42:26,539
会告诉你，

1031
00:42:26,539 --> 00:42:27,979


1032
00:42:27,979 --> 00:42:30,650


1033
00:42:30,650 --> 00:42:32,329
在你开始计算你有多少之前你应该跳过你作为输出产生的元组数量的所有集合

1034
00:42:32,329 --> 00:42:34,640
如果您

1035
00:42:34,640 --> 00:42:35,869
想到一个网页向您显示 10 个

1036
00:42:35,869 --> 00:42:37,219
结果，则应该再次限制正确，您单击 Next 查看接下来的

1037
00:42:37,219 --> 00:42:39,380
10 个他们正在使用一个带有所有设置的限制

1038
00:42:39,380 --> 00:42:42,680
来使其现在起作用，因为它

1039
00:42:42,680 --> 00:42:45,859
再次未排序并不能保证当

1040
00:42:45,859 --> 00:42:48,200
您单击 Next 时 如果你使用偏移量，

1041
00:42:48,200 --> 00:42:51,170
你会看到你肯定会

1042
00:42:51,170 --> 00:42:52,670
看到不同的元组，因为这

1043
00:42:52,670 --> 00:42:54,559
是查询的另一个调用，

1044
00:42:54,559 --> 00:42:55,940


1045
00:42:55,940 --> 00:42:57,950
第二次结果可能会以不同的顺序不同，所以在这种情况下

1046
00:42:57,950 --> 00:42:59,390
，你可以将它与一个

1047
00:42:59,390 --> 00:43:01,099
order by 条款，这样你就可以

1048
00:43:01,099 --> 00:43:03,200
保证去你知道看到前

1049
00:43:03,200 --> 00:43:04,640
10 个，然后是第二个 10

1050
00:43:04,640 --> 00:43:05,930
等等，

1051
00:43:05,930 --> 00:43:09,039
并且有优化你可以应用

1052
00:43:09,039 --> 00:43:10,940
无论你是否有订单

1053
00:43:10,940 --> 00:43:13,099
如果你有限制条款所以如果

1054
00:43:13,099 --> 00:43:14,509
我 没有 order by 条款，我

1055
00:43:14,509 --> 00:43:17,029
有一个限制，我知道，一旦我

1056
00:43:17,029 --> 00:43:19,099
看到发送了 10 个投票，我就完成了

1057
00:43:19,099 --> 00:43:21,170
，如果

1058
00:43:21,170 --> 00:43:22,400
到那时你有订单，我不需要去查看其他任何东西 排序

1059
00:43:22,400 --> 00:43:23,420
你必须提前查看所有内容

1060
00:43:23,420 --> 00:43:25,579
以进行排序然后你可以再次应用你的限制

1061
00:43:25,579 --> 00:43:25,940
和你

1062
00:43:25,940 --> 00:43:31,280
的冰块我认为

1063
00:43:31,280 --> 00:43:33,950
前几年有点基本的续集我

1064
00:43:33,950 --> 00:43:36,200
实际上跳过了所有这些但我认为

1065
00:43:36,200 --> 00:43:37,609
这是一个预兆，也许可以回顾一下它

1066
00:43:37,609 --> 00:43:38,720
有点因为你必须

1067
00:43:38,720 --> 00:43:40,280
在作业中理解这一点，但现在我们想

1068
00:43:40,280 --> 00:43:42,020
讨论更复杂的事情，这

1069
00:43:42,020 --> 00:43:44,230
就是我认为的高级续集，

1070
00:43:44,230 --> 00:43:46,609
所以我想讨论的第一件事

1071
00:43:46,609 --> 00:43:49,520
是嵌套查询，所以任何

1072
00:43:49,520 --> 00:43:50,480
关于嵌套查询的方式都是 基本上

1073
00:43:50,480 --> 00:43:53,180
允许您在

1074
00:43:53,180 --> 00:43:56,180
正确的查询中指定查询，并且您可以获取

1075
00:43:56,180 --> 00:43:58,010
一个查询的输出并将其用作

1076
00:43:58,010 --> 00:44:01,430
另一个查询的输入，所以一个

1077
00:44:01,430 --> 00:44:05,390
简单的例子像这样我正在做一个

1078
00:44:05,390 --> 00:44:07,010
选择我想获取所有名称

1079
00:44:07,010 --> 00:44:08,210
被录取的学生 至少有

1080
00:44:08,210 --> 00:44:11,240
一门课程，所以我的外部查询是

1081
00:44:11,240 --> 00:44:13,040
基于学生表定义的，

1082
00:44:13,040 --> 00:44:15,200
然后我有内部查询

1083
00:44:15,200 --> 00:44:16,460
，它会

1084
00:44:16,460 --> 00:44:19,970
从角色表中正确获取学生 ID，因此我们

1085
00:44:19,970 --> 00:44:21,710
可以将其编写为连接，这是排序

1086
00:44:21,710 --> 00:44:23,000
突然的另一种实际执行

1087
00:44:23,000 --> 00:44:25,040
此操作的方法，实际上当

1088
00:44:25,040 --> 00:44:26,720
需要在系统内部实际实现此操作时，

1089
00:44:26,720 --> 00:44:29,030
大多数查询优化器将尝试将其

1090
00:44:29,030 --> 00:44:31,670
重写为连接权限，因为

1091
00:44:31,670 --> 00:44:33,650
实际执行此操作的最糟糕方法

1092
00:44:33,650 --> 00:44:35,750
是本质上有两个 for 循环

1093
00:44:35,750 --> 00:44:37,460
你循环遍历

1094
00:44:37,460 --> 00:44:39,920
学生表中的每一个元组和每

1095
00:44:39,920 --> 00:44:41,119
两个元组，

1096
00:44:41,119 --> 00:44:42,710
然后一遍又一遍地重新施加相同的查询，

1097
00:44:42,710 --> 00:44:45,980
我的续集曾经这样做过更

1098
00:44:45,980 --> 00:44:47,089
原始的 Davian 系统，你应该这样做，

1099
00:44:47,089 --> 00:44:48,740
但是正确的方法 do

1100
00:44:48,740 --> 00:44:50,150
实际上只是将其重写为连接，

1101
00:44:50,150 --> 00:44:52,640
这样您就可以将这个

1102
00:44:52,640 --> 00:44:54,589
内部查询视为一个函数，该函数

1103
00:44:54,589 --> 00:44:56,569
可以生成一些元组作为您的

1104
00:44:56,569 --> 00:44:58,339
输出，然后您可以应用任何

1105
00:44:58,339 --> 00:44:59,839
谓词 你想在外部

1106
00:44:59,839 --> 00:45:02,150
查询中使用它，所以我们将通过一堆

1107
00:45:02,150 --> 00:45:05,109
例子来看看它是如何工作的

1108
00:45:05,109 --> 00:45:08,359


1109
00:45:08,359 --> 00:45:09,530


1110
00:45:09,530 --> 00:45:11,690


1111
00:45:11,690 --> 00:45:14,990
注册了 15 对 45 所以

1112
00:45:14,990 --> 00:45:17,089
构建嵌套查询的方法是我认为

1113
00:45:17,089 --> 00:45:18,020
从

1114
00:45:18,020 --> 00:45:20,300
外部查询开始并考虑

1115
00:45:20,300 --> 00:45:21,829
您想要产生的实际答案总是很重要，例如您想要

1116
00:45:21,829 --> 00:45:23,329
看到的实际属性是什么

1117
00:45:23,329 --> 00:45:25,460
然后你担心

1118
00:45:25,460 --> 00:45:26,540
你实际上将如何过滤它们

1119
00:45:26,540 --> 00:45:29,240
并获得你想要的所以外部查询

1120
00:45:29,240 --> 00:45:30,920
我们知道我们想要来自

1121
00:45:30,920 --> 00:45:33,020
学生表的名称然后我们从哪里获得

1122
00:45:33,020 --> 00:45:35,180
这些值我们将

1123
00:45:35,180 --> 00:45:38,240
在 内部查询我们可以

1124
00:45:38,240 --> 00:45:40,579
像学生 ID 一样用英语编写它，

1125
00:45:40,579 --> 00:45:43,040
而这组人大约需要 4:15

1126
00:45:43,040 --> 00:45:47,390
4:45 所以对于那部分我们知道如何

1127
00:45:47,390 --> 00:45:49,780
很容易地编写该查询对

1128
00:45:49,780 --> 00:45:52,010
我们只是觉得把所有的元组都扔掉

1129
00:45:52,010 --> 00:45:53,930
了 注册表或课程 IDE 是

1130
00:45:53,930 --> 00:45:56,720
15 比 45 所以现在 问题是

1131
00:45:56,720 --> 00:46:00,140
我们如何将它们与外部查询

1132
00:46:00,140 --> 00:46:02,030
和内部查询再次结合起来，我们可以

1133
00:46:02,030 --> 00:46:03,380
很容易地使用连接重写它，

1134
00:46:03,380 --> 00:46:06,319
但出于我们的目的，我们

1135
00:46:06,319 --> 00:46:08,140
想看看如何将其作为嵌套函数来执行，

1136
00:46:08,140 --> 00:46:11,650
因此我们可以 使用 in 运算符

1137
00:46:11,650 --> 00:46:14,420
，我们对学生学生 ID 进行匹配，

1138
00:46:14,420 --> 00:46:17,180
因此现在阅读此内容的一种方法是

1139
00:46:17,180 --> 00:46:20,450
，对于学生表中的每个学生，

1140
00:46:20,450 --> 00:46:21,109


1141
00:46:21,109 --> 00:46:23,059
因此第一个学生 ID

1142
00:46:23,059 --> 00:46:25,730
与学生表匹配 我想看看

1143
00:46:25,730 --> 00:46:28,220
是否有 该学生

1144
00:46:28,220 --> 00:46:31,160
ID 在角色表中所有学生 ID 的集合中匹配，该集合中

1145
00:46:31,160 --> 00:46:34,010
的

1146
00:46:34,010 --> 00:46:37,010
课程 15 为 45，因此我们退出内部

1147
00:46:37,010 --> 00:46:39,260
查询，我们生成所有学生 ID 的集合

1148
00:46:39,260 --> 00:46:41,540
，然后为外部查询中的每个元组生成

1149
00:46:41,540 --> 00:46:43,520
我们检查

1150
00:46:43,520 --> 00:46:47,599
它现在是否存在于该集合中 这次

1151
00:46:47,599 --> 00:46:49,849
访问向您展示了为什么我之前说

1152
00:46:49,849 --> 00:46:51,290
执行此操作的愚蠢方法是针对

1153
00:46:51,290 --> 00:46:53,059
外部查询中的每个元组我们

1154
00:46:53,059 --> 00:46:55,460
一遍又一遍地执行内部查询

1155
00:46:55,460 --> 00:46:58,220
就像那很愚蠢因为我们 只

1156
00:46:58,220 --> 00:46:59,960
需要pr 产生一次内部查询，

1157
00:46:59,960 --> 00:47:01,400
然后我们可以在每个

1158
00:47:01,400 --> 00:47:06,079
元组和外部查询中重用它，所以我向

1159
00:47:06,079 --> 00:47:07,910
它展示了如何在 Attic 中查看我是否在

1160
00:47:07,910 --> 00:47:11,299
您可以使用的那些其他运算符中使用，所以

1161
00:47:11,299 --> 00:47:13,520
基本上所有的元组

1162
00:47:13,520 --> 00:47:15,530
都在 我的内部查询必须

1163
00:47:15,530 --> 00:47:17,960
满足我的谓词任何手段至少

1164
00:47:17,960 --> 00:47:20,869
其中一个需要好所以在

1165
00:47:20,869 --> 00:47:22,579
本质上与等于相同的事情

1166
00:47:22,579 --> 00:47:26,089
有任何元组等于

1167
00:47:26,089 --> 00:47:28,190
我的谓词或关于我的元组属性

1168
00:47:28,190 --> 00:47:30,770
正在检查然后存在

1169
00:47:30,770 --> 00:47:32,359
至少返回了一行，实际上我

1170
00:47:32,359 --> 00:47:33,530
不在乎匹配的位置我只

1171
00:47:33,530 --> 00:47:35,329
关心看球是否

1172
00:47:35,329 --> 00:47:41,690
会产生结果，因此我们可以重写

1173
00:47:41,690 --> 00:47:43,400
我们的示例，让所有学生

1174
00:47:43,400 --> 00:47:46,160
像这样正确地在 15 人中 45 人中，而不是

1175
00:47:46,160 --> 00:47:48,559
使用 in 我们说等于结束，所以现在您将其

1176
00:47:48,559 --> 00:47:50,960
读作来自学生表的学生 ID

1177
00:47:50,960 --> 00:47:53,180
检查

1178
00:47:53,180 --> 00:47:55,640
它是否等于现在从注册表中生成的学生 ID 集中存在的任何元组，

1179
00:47:55,640 --> 00:47:57,530


1180
00:47:57,530 --> 00:48:00,670


1181
00:48:00,670 --> 00:48:04,520
内部键 t 嵌套

1182
00:48:04,520 --> 00:48:06,200
查询不必只出现在

1183
00:48:06,200 --> 00:48:07,520
where 子句中，它们实际上可以出现

1184
00:48:07,520 --> 00:48:10,400
在任何正确的位置，因此我可以像这样重写相同的

1185
00:48:10,400 --> 00:48:13,520
查询，现在我

1186
00:48:13,520 --> 00:48:15,079
在 Select 语句的输出中有我的嵌套查询，

1187
00:48:15,079 --> 00:48:17,390
所以这是一个很好的例子

1188
00:48:17,390 --> 00:48:18,950
本质上是颠倒我

1189
00:48:18,950 --> 00:48:21,680
之前在哪些表将

1190
00:48:21,680 --> 00:48:23,839
要访问的方面所做的工作，所以现在读取这个的方式是

1191
00:48:23,839 --> 00:48:26,150
，

1192
00:48:26,150 --> 00:48:29,089
对于课程 ID 等于

1193
00:48:29,089 --> 00:48:32,480
15 45 15 4 45 的注册表中的每个元组，然后我要做一个

1194
00:48:32,480 --> 00:48:36,500
这个学生表中的匹配，其中

1195
00:48:36,500 --> 00:48:39,109
学生 ID 是相同的，

1196
00:48:39,109 --> 00:48:42,230
本质上是在

1197
00:48:42,230 --> 00:48:43,700
我的 select 语句的输出中进行连接，

1198
00:48:43,700 --> 00:48:45,710
因为现在

1199
00:48:45,710 --> 00:48:47,270
这里从学生表中引用了这个 d'un ID

1200
00:48:47,270 --> 00:48:49,069
，并且在那里引用了该学生 ID

1201
00:48:49,069 --> 00:48:52,069
好的，还有另一个很好的

1202
00:48:52,069 --> 00:48:53,960
例子，我基本上颠倒

1203
00:48:53,960 --> 00:48:55,960
了我处理表格的顺序

1204
00:48:55,960 --> 00:48:58,760
，它们产生了完全相同的

1205
00:48:58,760 --> 00:48:59,990
结果，但根据我的数据行为，它们可能具有不同的

1206
00:48:59,990 --> 00:49:01,910
性能特征

1207
00:49:01,910 --> 00:49:03,980
通常看起来可能

1208
00:49:03,980 --> 00:49:05,390
是这样的情况，

1209
00:49:05,390 --> 00:49:06,589
首先通过注册表

1210
00:49:06,589 --> 00:49:09,520
而不是学生表实际上更快，

1211
00:49:09,520 --> 00:49:11,480
因此如果我们

1212
00:49:11,480 --> 00:49:14,240
想选择一个而不是另一个

1213
00:49:14,240 --> 00:49:16,609
，我们可以重写它，并且一个好的优化器可以为您做到这一点

1214
00:49:16,609 --> 00:49:20,960
好吧好吧让我们看看

1215
00:49:20,960 --> 00:49:22,390
更复杂的东西现在

1216
00:49:22,390 --> 00:49:24,740
好吧说我们想

1217
00:49:24,740 --> 00:49:27,200
找到注册

1218
00:49:27,200 --> 00:49:30,440
了至少一门课程的具有最高ID的学生记录看起来很

1219
00:49:30,440 --> 00:49:32,480
简单但让我们认为我们实际上这样做

1220
00:49:32,480 --> 00:49:37,069
了所以第一个近似值是

1221
00:49:37,069 --> 00:49:39,940
这样的

1222
00:49:39,940 --> 00:49:42,410


1223
00:49:42,410 --> 00:49:44,809
从 join 和 roll 和

1224
00:49:44,809 --> 00:49:47,630
student 表中选择最大学生 ID 以及学生姓名，其中

1225
00:49:47,630 --> 00:49:49,160
角色表中的学生 ID 等于

1226
00:49:49,160 --> 00:49:54,109
学生表中的学生 ID 这会起作用为什么为什么

1227
00:49:54,109 --> 00:49:56,260
不

1228
00:50:00,230 --> 00:50:05,610
呢，是的，聚合

1229
00:50:05,610 --> 00:50:08,040
函数没有 第 I 组，我们正在

1230
00:50:08,040 --> 00:50:09,900
引用不在聚合中的列，

1231
00:50:09,900 --> 00:50:12,800


1232
00:50:12,800 --> 00:50:16,470
因此续集标准再次说明这

1233
00:50:16,470 --> 00:50:30,300
不应该起作用，让我们再次找出来

1234
00:50:30,300 --> 00:50:37,530
我必须先断开

1235
00:50:37,530 --> 00:50:41,280
顶部的第一个 cuss 所以我们在这里再次运行我们的查询

1236
00:50:41,280 --> 00:50:46,350
Postgres 这是

1237
00:50:46,350 --> 00:50:48,180
标准它说得到正如他

1238
00:50:48,180 --> 00:50:50,700
所说的那样你有学生 ID 学生姓名

1239
00:50:50,700 --> 00:50:52,470
出现但它不是一个组的一部分我

1240
00:50:52,470 --> 00:50:57,860
所以你 不能在我的续集中正确使用它，

1241
00:51:00,260 --> 00:51:04,080
它会产生那个错误，但是如果

1242
00:51:04,080 --> 00:51:06,090
我们现在以他们所谓的传统模式运行它，那么

1243
00:51:06,090 --> 00:51:08,130


1244
00:51:08,130 --> 00:51:10,140
我的续集的旧版本会这样做，现在我们运行

1245
00:51:10,140 --> 00:51:13,590
这个查询，我们得到了一个正确的答案

1246
00:51:13,590 --> 00:51:15,810
Mac 学生 ID 然后我们

1247
00:51:15,810 --> 00:51:17,790
说最好的学生的名字是 Tupac

1248
00:51:17,790 --> 00:51:23,330
好吧让我们在续集中试试它 Lite

1249
00:51:23,330 --> 00:51:30,870
run one 它产生了一个答案 它也

1250
00:51:30,870 --> 00:51:33,810
产生了 53 688 作为 90 的下一个但它

1251
00:51:33,810 --> 00:51:36,120
说那个学生属于 Justin

1252
00:51:36,120 --> 00:51:39,270
Bieber 对 实际上我不

1253
00:51:39,270 --> 00:51:42,560
知道正确的答案是什么让我们在这里看看

1254
00:51:45,680 --> 00:51:48,150
是的 所以贾斯汀比伯是

1255
00:51:48,150 --> 00:51:50,880
正确的 而我的续集确保我

1256
00:51:50,880 --> 00:51:58,530
给你相同的数据 正确的图帕克

1257
00:51:58,530 --> 00:52:00,510
实际上是最低的，所以它

1258
00:52:00,510 --> 00:52:06,270
完全错误 好吧，对，所以

1259
00:52:06,270 --> 00:52:08,119
这样做 在续集标准中不起作用，

1260
00:52:08,119 --> 00:52:11,339
它运行单个字节和和我的

1261
00:52:11,339 --> 00:52:12,720
SIBO，如果我们关闭严格模式，

1262
00:52:12,720 --> 00:52:16,109
那么我们可以这样做的方式是一个嵌套

1263
00:52:16,109 --> 00:52:17,520
函数，再次让我们建设性地构建它，

1264
00:52:17,520 --> 00:52:19,440
这样我们就知道你

1265
00:52:19,440 --> 00:52:20,730
想要学生 ID 和名称作为

1266
00:52:20,730 --> 00:52:22,349
输出，但它是

1267
00:52:22,349 --> 00:52:24,660
认为我们必须弄清楚的 where 子句，这个

1268
00:52:24,660 --> 00:52:26,339
基本上是说我们想要一个

1269
00:52:26,339 --> 00:52:29,190
匹配的元组，它比

1270
00:52:29,190 --> 00:52:31,200


1271
00:52:31,200 --> 00:52:34,799
我们表中的每个其他学生 ID 都大，所以我们知道

1272
00:52:34,799 --> 00:52:36,480
内部查询应该基本上

1273
00:52:36,480 --> 00:52:38,849
是来自注册表的学生 ID 我们

1274
00:52:38,849 --> 00:52:40,829
可以更复杂，也许

1275
00:52:40,829 --> 00:52:42,270
在那里放一个不同的但都是一样的，

1276
00:52:42,270 --> 00:52:43,980
但现在我们需要弄清楚如何

1277
00:52:43,980 --> 00:52:46,049
匹配来自学生的学生 ID

1278
00:52:46,049 --> 00:52:48,059
和外部查询 来自内部查询的学生 ID

1279
00:52:48,059 --> 00:52:51,539
，为此我们可以

1280
00:52:51,539 --> 00:52:54,089
使用大于等于好吧，它

1281
00:52:54,089 --> 00:52:55,380
必须大于等于，因为

1282
00:52:55,380 --> 00:52:57,569
我们确保我们匹配自己

1283
00:52:57,569 --> 00:52:58,890
实际是的学生，实际上

1284
00:52:58,890 --> 00:53:01,760
确实具有高 最正确的一点是，

1285
00:53:01,760 --> 00:53:04,140
我们可以按预期以其他方式

1286
00:53:04,140 --> 00:53:05,819
重写它，我们可以使用

1287
00:53:05,819 --> 00:53:07,589
类似的 in 子句重写它，并且现在实际

1288
00:53:07,589 --> 00:53:09,390
计算最大学生 ID 和内部

1289
00:53:09,390 --> 00:53:11,369
查询，基本上这是说

1290
00:53:11,369 --> 00:53:13,980
匹配学生 ID 即最大

1291
00:53:13,980 --> 00:53:15,750
学生 ID 从注册表

1292
00:53:15,750 --> 00:53:18,869
中产生我们可以走得更远 我们

1293
00:53:18,869 --> 00:53:19,950
可以将内部人员改写成

1294
00:53:19,950 --> 00:53:21,690
这样 我们按顺序和

1295
00:53:21,690 --> 00:53:24,779
学生 ID

1296
00:53:24,779 --> 00:53:26,359
按降序排列然后做一个限制

1297
00:53:26,359 --> 00:53:29,359


1298
00:53:29,359 --> 00:53:31,589
只需将这个重写为最大值 无论如何只需

1299
00:53:31,589 --> 00:53:33,270
扫描所有内容 跟踪哪个

1300
00:53:33,270 --> 00:53:34,890
是最大值 并产生最终

1301
00:53:34,890 --> 00:53:36,240
输出 甚至不用费心将它们

1302
00:53:36,240 --> 00:53:39,930
重新排序 以不同方式重写相同的查询

1303
00:53:39,930 --> 00:53:44,970
我们

1304
00:53:44,970 --> 00:53:46,859
将找到另一个例子 所有没有

1305
00:53:46,859 --> 00:53:49,140
学生注册的课程，所以我们将

1306
00:53:49,140 --> 00:53:51,329
外部查询作为课程的选择

1307
00:53:51,329 --> 00:53:53,069
，然后我们知道我们的内部查询

1308
00:53:53,069 --> 00:53:54,450
基本上是说当一个查找注释

1309
00:53:54,450 --> 00:53:57,100
在注册表中没有元组时

1310
00:53:57,100 --> 00:53:58,840
我们想要使用的这个不

1311
00:53:58,840 --> 00:54:00,670
存在基本上是说我们不想

1312
00:54:00,670 --> 00:54:04,000
匹配我们内部查询中的任何东西

1313
00:54:04,000 --> 00:54:05,770
，我们需要为内部

1314
00:54:05,770 --> 00:54:08,890
查询做的只是获取每个

1315
00:54:08,890 --> 00:54:10,210
元组，现在我们实际上正在

1316
00:54:10,210 --> 00:54:13,300
匹配

1317
00:54:13,300 --> 00:54:15,400
内部查询中的课程 ID 与外部查询中的课程 ID，

1318
00:54:15,400 --> 00:54:17,710
因此您只能在一个方向上执行此操作，

1319
00:54:17,710 --> 00:54:19,000
因此如果您是内部

1320
00:54:19,000 --> 00:54:20,320
查询，则可以表示外部查询，

1321
00:54:20,320 --> 00:54:22,240
如果您在外部查询中则不能

1322
00:54:22,240 --> 00:54:25,090
正确引用内部查询，除非

1323
00:54:25,090 --> 00:54:27,130
您将其通过管道输出或将其重定向到

1324
00:54:27,130 --> 00:54:30,370
表，因此有关嵌套

1325
00:54:30,370 --> 00:54:34,510
查询的任何问题再次它们非常强大，

1326
00:54:34,510 --> 00:54:36,580
您无法

1327
00:54:36,580 --> 00:54:40,930
在不使用嵌套查询的情况下在单个查询中写入您想要写入的内容

1328
00:54:40,930 --> 00:54:50,560
是的她 问题是

1329
00:54:50,560 --> 00:54:52,090
你能不能把一个内部查询看作一个

1330
00:54:52,090 --> 00:54:58,710
嵌套的 for 循环是的但不是所以我们会看到

1331
00:55:00,060 --> 00:55:02,440
for 循环它有一个像

1332
00:55:02,440 --> 00:55:06,460
排序的概念它真的是一个集合所以

1333
00:55:06,460 --> 00:55:09,700
所有像 X 中的运算符都存在任何

1334
00:55:09,700 --> 00:55:11,650
那些只是在尝试 表示

1335
00:55:11,650 --> 00:55:13,510
整个元组集 e 在

1336
00:55:13,510 --> 00:55:15,460
内部查询中检查是否有任何

1337
00:55:15,460 --> 00:55:17,200
em 与您匹配，

1338
00:55:17,200 --> 00:55:19,840
如果您

1339
00:55:19,840 --> 00:55:21,190
将外部查询视为

1340
00:55:21,190 --> 00:55:22,300
四，因为您正在迭代

1341
00:55:22,300 --> 00:55:24,610
每个元组，因此您并没有真正迭代每一个 设置

1342
00:55:24,610 --> 00:55:27,010
部分内部查询的评估

1343
00:55:27,010 --> 00:55:28,960
总是在服务器上，一个包或设置集

1344
00:55:28,960 --> 00:55:36,070
级别是有意义的窗口函数

1345
00:55:36,070 --> 00:55:39,010
所以窗口函数我会说

1346
00:55:39,010 --> 00:55:41,410
它们是新的，但它们现在已经有十五

1347
00:55:41,410 --> 00:55:42,970
年了，所以它们不是 就像不是

1348
00:55:42,970 --> 00:55:45,400
全新的一样，很多系统不支持

1349
00:55:45,400 --> 00:55:49,210
它们，但主要系统都支持它们，窗口

1350
00:55:49,210 --> 00:55:51,720
函数有点像一个聚合

1351
00:55:51,720 --> 00:55:55,030
，你将

1352
00:55:55,030 --> 00:55:57,730
在元组上计算一些函数，而

1353
00:55:57,730 --> 00:56:00,970
不是在你知道的

1354
00:56:00,970 --> 00:56:03,040
元组的子集并将它们折叠成

1355
00:56:03,040 --> 00:56:05,560
一个结果，您可以以

1356
00:56:05,560 --> 00:56:07,540
增量方式或移动

1357
00:56:07,540 --> 00:56:10,660
方式执行此操作，然后您仍然将这

1358
00:56:10,660 --> 00:56:10,930
两个

1359
00:56:10,930 --> 00:56:13,180
作为输出生成，但连同

1360
00:56:13,180 --> 00:56:14,890
它从窗口

1361
00:56:14,890 --> 00:56:18,940
函数生成的值 基本语法是

1362
00:56:18,940 --> 00:56:20,920
li 对此，您有函数名，

1363
00:56:20,920 --> 00:56:22,150
然后有一个 over 子句，

1364
00:56:22,150 --> 00:56:23,380
因此函数名将是我们的

1365
00:56:23,380 --> 00:56:24,849
聚合函数和

1366
00:56:24,849 --> 00:56:26,109
我们拥有的其他特殊窗口函数，我

1367
00:56:26,109 --> 00:56:28,690
将在下一张幻灯片中展示，然后 over

1368
00:56:28,690 --> 00:56:30,910
over 子句定义了我们实际想要的方式

1369
00:56:30,910 --> 00:56:33,040
对数据进行正确切片，这

1370
00:56:33,040 --> 00:56:34,510
有点像将

1371
00:56:34,510 --> 00:56:37,240
聚合和 group by 组合在一起，但是在

1372
00:56:37,240 --> 00:56:39,280
一个子句中，因此函数

1373
00:56:39,280 --> 00:56:41,170
就像聚合函数一样，over

1374
00:56:41,170 --> 00:56:44,980
就像组 I，因此聚合

1375
00:56:44,980 --> 00:56:46,809
函数应该是

1376
00:56:46,809 --> 00:56:47,800
我们之前讨论过的续集标准

1377
00:56:47,800 --> 00:56:51,430
min max average 计算一些特殊的

1378
00:56:51,430 --> 00:56:52,839
风函数来做一些事情，比如

1379
00:56:52,839 --> 00:56:55,180
向当前行引入一个行号，

1380
00:56:55,180 --> 00:56:57,339
以便跟踪正在输出的元组

1381
00:56:57,339 --> 00:56:58,930
，并

1382
00:56:58,930 --> 00:57:00,670
用它们的顺序标记它们

1383
00:57:00,670 --> 00:57:03,550
出来然后排名将

1384
00:57:03,550 --> 00:57:05,440
是元组的位置顺序，如果我们正在做

1385
00:57:05,440 --> 00:57:08,470
排序，那么说我想做的

1386
00:57:08,470 --> 00:57:10,150
是我想在登记表上做一个选择

1387
00:57:10,150 --> 00:57:12,309
，我想产生 al

1388
00:57:12,309 --> 00:57:15,040
l 元组作为我的输出，但我

1389
00:57:15,040 --> 00:57:17,049
只想用输出的行号标记它们，

1390
00:57:17,049 --> 00:57:19,150
所以我有我的行

1391
00:57:19,150 --> 00:57:21,670
号行号函数，然后对于

1392
00:57:21,670 --> 00:57:23,140
我的 over 条款，我只是把那个留空

1393
00:57:23,140 --> 00:57:25,990
，然后我最终得到的是一个 结果

1394
00:57:25,990 --> 00:57:26,829
看起来像

1395
00:57:26,829 --> 00:57:28,180
这样我有我以前所有的数据，

1396
00:57:28,180 --> 00:57:30,369
但现在我在这里有这个特殊的列

1397
00:57:30,369 --> 00:57:33,309
行号，这又

1398
00:57:33,309 --> 00:57:36,040
是它在输出中产生的元组的顺序，

1399
00:57:36,040 --> 00:57:39,490
有点像我

1400
00:57:39,490 --> 00:57:41,410
计算我的 整个查询，然后我做我的

1401
00:57:41,410 --> 00:57:42,940
窗口函数来检查结果

1402
00:57:42,940 --> 00:57:45,309
，然后我添加

1403
00:57:45,309 --> 00:57:49,540
我想要生成的任何计算，所以

1404
00:57:49,540 --> 00:57:52,210
就像组聚合一样，我们

1405
00:57:52,210 --> 00:57:53,799
可以将事物组合在一起或将

1406
00:57:53,799 --> 00:57:55,359
它们组合在一起，这就是 over

1407
00:57:55,359 --> 00:57:58,089
关键字对我们有用，因此为此我们将

1408
00:57:58,089 --> 00:58:00,700
使用 partition by 来指定我们希望

1409
00:58:00,700 --> 00:58:02,440
如何对事物进行分组，因此在

1410
00:58:02,440 --> 00:58:03,819
此查询中，我正在做与以前相同的事情

1411
00:58:03,819 --> 00:58:06,130
，我想

1412
00:58:06,130 --> 00:58:09,609
根据生成行将它们组合在一起

1413
00:58:09,609 --> 00:58:11,290
数量和方式 他们在

1414
00:58:11,290 --> 00:58:12,910
他们的输出中生成，但随后我将

1415
00:58:12,910 --> 00:58:15,299
根据课程 ID 将它们组合在一起，

1416
00:58:15,299 --> 00:58:17,829
所以我的输出看起来像

1417
00:58:17,829 --> 00:58:21,250
这样，所以现在它看起来

1418
00:58:21,250 --> 00:58:22,809
就像现在我

1419
00:58:22,809 --> 00:58:24,760


1420
00:58:24,760 --> 00:58:29,820
根据正确的顺序组合在一起的航空 非常简单，

1421
00:58:29,820 --> 00:58:32,050
所以让我们看看更

1422
00:58:32,050 --> 00:58:35,140
复杂的东西，所以我也可以按这些排序

1423
00:58:35,140 --> 00:58:38,710
我可以对它们进行排序而不是对它们进行分区

1424
00:58:38,710 --> 00:58:40,420
这本质上定义

1425
00:58:40,420 --> 00:58:42,820
了我们希望如何进行排序生产

1426
00:58:42,820 --> 00:58:44,020
以产生我们的输出 如果我们进行

1427
00:58:44,020 --> 00:58:46,450
排序然后我们计算任何东西

1428
00:58:46,450 --> 00:58:47,800
这个窗口函数是我们想要

1429
00:58:47,800 --> 00:58:50,140
计算的，所以在这种情况下，

1430
00:58:50,140 --> 00:58:51,370
这是一种感觉，你可以做

1431
00:58:51,370 --> 00:58:54,430
我在上一张幻灯片中做的同样的

1432
00:58:54,430 --> 00:58:55,090
事情，我们更多的

1433
00:58:55,090 --> 00:58:57,520
人会根据课程 ID 对它们进行分组，

1434
00:58:57,520 --> 00:58:59,560
但这是在做 这是通过使用排序

1435
00:58:59,560 --> 00:59:05,710
而不是分区来实现的，所以

1436
00:59:05,710 --> 00:59:07,360
假设我们要计算希望

1437
00:59:07,360 --> 00:59:08,680
找到每门课程成绩最高的学生，

1438
00:59:08,680 --> 00:59:11,560
所以

1439
00:59:11,560 --> 00:59:14,710
我们现在拥有的是嵌套查询，因此在外部

1440
00:59:14,710 --> 00:59:18,790
查询中 我们只是要很好地处理

1441
00:59:18,790 --> 00:59:21,370
外部查询是内部查询中的服务器

1442
00:59:21,370 --> 00:59:23,160
我们将产生一些表结果

1443
00:59:23,160 --> 00:59:25,390
但现在这是一个很好的例子我们在

1444
00:59:25,390 --> 00:59:26,830
from 子句中有一个嵌套查询

1445
00:59:26,830 --> 00:59:30,010
所以我从这里开始 然后我

1446
00:59:30,010 --> 00:59:31,900
将获取这个内部查询的输出，

1447
00:59:31,900 --> 00:59:35,560
并将其映射到一种

1448
00:59:35,560 --> 00:59:37,510
称为排名的临时虚拟表中，

1449
00:59:37,510 --> 00:59:41,050
该表仅存在于该元组中，因此我们

1450
00:59:41,050 --> 00:59:42,280
不是将其写入存在的表中

1451
00:59:42,280 --> 00:59:43,950
写入临时

1452
00:59:43,950 --> 00:59:46,060
表我不会留在内存中，因为它

1453
00:59:46,060 --> 00:59:47,470
实际上可能会从磁盘中消失，但是

1454
00:59:47,470 --> 00:59:49,630
此查询的临时元组表

1455
00:59:49,630 --> 00:59:52,900
会在查询结束时被丢弃

1456
00:59:52,900 --> 00:59:55,810
，因此在内部查询中

1457
00:59:55,810 --> 00:59:58,330
我们要做的是 我们将

1458
00:59:58,330 --> 01:00:01,570
查看已注册的表，对于每个

1459
01:00:01,570 --> 01:00:04,870
元组，我们将根据

1460
01:00:04,870 --> 01:00:06,400
作为分区子句的课程 ID 将它们拆分

1461
01:00:06,400 --> 01:00:09,250
，然后我们将按等级升序对它们进行

1462
01:00:09,250 --> 01:00:12,310
排序，然后

1463
01:00:12,310 --> 01:00:16,030
是我们生成的 我们调用的窗口函数

1464
01:00:16,030 --> 01:00:17,980
是 rank，它是 tha 的顺序

1465
01:00:17,980 --> 01:00:21,420
它们存在于排序中

1466
01:00:21,420 --> 01:00:25,660
，然后我们将该

1467
01:00:25,660 --> 01:00:28,240
输出写到排序表中，然后在

1468
01:00:28,240 --> 01:00:30,730
外部查询中，我们可以

1469
01:00:30,730 --> 01:00:33,790
根据它们的排序进行额外的过滤，

1470
01:00:33,790 --> 01:00:35,590
这样只会产生这样的元组

1471
01:00:35,590 --> 01:00:36,339


1472
01:00:36,339 --> 01:00:39,219
排名第一，所以这是

1473
01:00:39,219 --> 01:00:40,299
为学生找到每门课程的最高分，

1474
01:00:40,299 --> 01:00:42,789
所以这里要指出的

1475
01:00:42,789 --> 01:00:45,460
是我在我的

1476
01:00:45,460 --> 01:00:48,099
外部查询中引用了这个排名属性，

1477
01:00:48,099 --> 01:00:49,690
它实际上并不真正存在

1478
01:00:49,690 --> 01:00:51,640
于数据库中 只存在于

1479
01:00:51,640 --> 01:00:56,950
这个查询中 我看到很多空白的

1480
01:00:56,950 --> 01:00:59,979
面孔 所以让我们可能会在

1481
01:00:59,979 --> 01:01:01,150
数据库中弹出，看看我们可以做的很好 所以

1482
01:01:01,150 --> 01:01:09,519
为此 Postgres 是唯一

1483
01:01:09,519 --> 01:01:12,729
一个真正支持这个我的续集

1484
01:01:12,729 --> 01:01:17,349
8 支持窗口函数和

1485
01:01:17,349 --> 01:01:18,609
较新版本的 sequel Lite 支持窗口

1486
01:01:18,609 --> 01:01:22,239
函数，但为了简单起见，

1487
01:01:22,239 --> 01:01:25,210
我和 Postgres 有什么用，所以这是

1488
01:01:25,210 --> 01:01:31,779
我们之前的查询，让我们

1489
01:01:31,779 --> 01:01:33,880
把它分解并制作它，然后

1490
01:01:33,880 --> 01:01:36,009
先做内部查询，这样我 这会

1491
01:01:36,009 --> 01:01:39,219
很容易理解，所以

1492
01:01:39,219 --> 01:01:47,499
我们将返回并运行它，所以

1493
01:01:47,499 --> 01:01:50,529
这将再次

1494
01:01:50,529 --> 01:01:54,819
检查注册表，它将根据课程 ID

1495
01:01:54,819 --> 01:01:57,969
对每条记录进行分区，

1496
01:01:57,969 --> 01:02:01,539
因此您会看到 在这里，

1497
01:02:01,539 --> 01:02:04,390
首先出现 15 和 45，然后是 7 21 然后是 8

1498
01:02:04,390 --> 01:02:08,559
26，然后现在在这些

1499
01:02:08,559 --> 01:02:09,460
分区

1500
01:02:09,460 --> 01:02:11,849
中的每一个中，N 将根据元组的等级按降序对元组进行排序，或者按升序对元组进行排序，

1501
01:02:11,849 --> 01:02:15,700


1502
01:02:15,700 --> 01:02:18,999
所以

1503
01:02:18,999 --> 01:02:21,700
泵来看看 Abe 你将来自

1504
01:02:21,700 --> 01:02:24,130
C，然后没有其他人取

1505
01:02:24,130 --> 01:02:27,759
26，所以 B 本身就是正确的，这

1506
01:02:27,759 --> 01:02:31,450
就是我们以重新定义的形式获得输出的方式，

1507
01:02:31,450 --> 01:02:35,289
所以现在排名函数

1508
01:02:35,289 --> 01:02:38,170
将根据每个

1509
01:02:38,170 --> 01:02:42,569
元组出现在 排序的输出列表，

1510
01:02:42,569 --> 01:02:45,160
所以在这种情况下，这里是第一个元组

1511
01:02:45,160 --> 01:02:48,160
，在这个分区中，这个人

1512
01:02:48,160 --> 01:02:50,109
首先出现，所以他获得了排名 1，

1513
01:02:50,109 --> 01:02:52,769
我排在第二位，所以

1514
01:02:52,769 --> 01:02:57,609
如果我现在将其更改为降序，他的排名就太正确了，

1515
01:02:57,609 --> 01:03:00,329


1516
01:03:00,599 --> 01:03:03,460
它仍然没有 同样的事情，但

1517
01:03:03,460 --> 01:03:09,910
我可以下订单 再一次，现在我

1518
01:03:09,910 --> 01:03:14,619
想按降序排列，

1519
01:03:14,619 --> 01:03:16,029
这是这样的，这是按此顺序执行的

1520
01:03:16,029 --> 01:03:19,089
，这是在我执行窗口函数后按此顺序执行的，

1521
01:03:19,089 --> 01:03:20,589
因此

1522
01:03:20,589 --> 01:03:23,049
没有意义，但排名中的主要内容

1523
01:03:23,049 --> 01:03:24,789
是不同的 rotoma 因为

1524
01:03:24,789 --> 01:03:25,749
第二行说你

1525
01:03:25,749 --> 01:03:27,549
在输出中出现的位置排名是

1526
01:03:27,549 --> 01:03:31,950
你在排序顺序中出现的位置好吧

1527
01:03:31,950 --> 01:03:46,569
是再说一遍对不起他说如果你

1528
01:03:46,569 --> 01:03:47,920
有一个没有顺序的排名

1529
01:03:47,920 --> 01:03:50,140
只会返回一个随机顺序 好吧，您

1530
01:03:50,140 --> 01:03:53,559
仍然会按照您拥有的内容对其进行排序，

1531
01:03:53,559 --> 01:03:55,239
直到让它们可能按

1532
01:03:55,239 --> 01:03:57,339
分区拆分它不一定是因为

1533
01:03:57,339 --> 01:04:01,859
它是未排序的但这就是您将得到的

1534
01:04:01,859 --> 01:04:04,779
但是现在在这里是的所以在这种情况下

1535
01:04:04,779 --> 01:04:07,720
这里没有排序 再排序，

1536
01:04:07,720 --> 01:04:11,099
所以每个人都有一个权利，

1537
01:04:11,099 --> 01:04:13,390
但它仍然

1538
01:04:13,390 --> 01:04:14,920
根据我认为它作为我的

1539
01:04:14,920 --> 01:04:16,930
分区将它们组合在一起，这更多的是

1540
01:04:16,930 --> 01:04:19,480
数据库系统如何实际

1541
01:04:19,480 --> 01:04:21,309
执行查询而不是查询的

1542
01:04:21,309 --> 01:04:27,579
语义的工件 他的

1543
01:04:27,579 --> 01:04:28,900
问题是 什么是等级

1544
01:04:28,900 --> 01:04:31,299
函数 等级是等级函数的等级

1545
01:04:31,299 --> 01:04:32,950
会产生排序

1546
01:04:32,950 --> 01:04:36,069
顺序的等级 所以如果我将窗口

1547
01:04:36,069 --> 01:04:42,849
函数更改为行号 好的我有我的

1548
01:04:42,849 --> 01:04:46,900
分区 但它是一二一二

1549
01:04:46,900 --> 01:04:48,670
一 正确因为在 每个分区

1550
01:04:48,670 --> 01:04:50,410
都是我读到的，所以我实际上已经删除

1551
01:04:50,410 --> 01:04:53,079
了分区，到那时它

1552
01:04:53,079 --> 01:04:55,480
应该通过一到五个正确的方式

1553
01:04:55,480 --> 01:04:58,019
，如果我现在改变它来对

1554
01:04:58,019 --> 01:05:01,210
所有内容进行排名应该是一一正确的，

1555
01:05:01,210 --> 01:05:02,589
因为没有土壤顺序

1556
01:05:02,589 --> 01:05:05,249
每个人的第一个

1557
01:05:05,580 --> 01:05:13,570
是 我们的问题是没有顺序的排名的毫无意义的观点

1558
01:05:13,570 --> 01:05:15,430
是因为

1559
01:05:15,430 --> 01:05:17,200
没有排序顺序所以

1560
01:05:17,200 --> 01:05:26,830
没有排名很好

1561
01:05:26,830 --> 01:05:27,850
很酷所以我们最不想谈论的最后一件事

1562
01:05:27,850 --> 01:05:30,130
是复杂的表

1563
01:05:30,130 --> 01:05:32,410
表达式所以这又是 Polly Mike

1564
01:05:32,410 --> 01:05:34,660
这是我觉得这很有趣

1565
01:05:34,660 --> 01:05:36,130
这可能

1566
01:05:36,130 --> 01:05:38,800
是您可以在续集中做的更复杂的事情

1567
01:05:38,800 --> 01:05:40,510
它看起来很像嵌套

1568
01:05:40,510 --> 01:05:42,430
查询 因为您将

1569
01:05:42,430 --> 01:05:44,110
我正在使用的查询的输出作为 输入

1570
01:05:44,110 --> 01:05:45,850
另一个查询，但我们将在稍后

1571
01:05:45,850 --> 01:05:47,350
看到您可以使用 CT 轻松完成哪些

1572
01:05:47,350 --> 01:06:00,100
在 Annessa 查询中无法完成

1573
01:06:00,100 --> 01:06:03,100


1574
01:06:03,100 --> 01:06:04,780


1575
01:06:04,780 --> 01:06:11,290
的工作 问题是

1576
01:06:11,290 --> 01:06:14,770
使用

1577
01:06:14,770 --> 01:06:17,760
带有窗口函数的 rank 比使用 group

1578
01:06:17,760 --> 01:06:21,040
by 有什么特别的优势，如果您再次使用 group by

1579
01:06:21,040 --> 01:06:23,020
不会产生相同的结果，那么您将

1580
01:06:23,020 --> 01:06:24,550
不再将元组

1581
01:06:24,550 --> 01:06:29,250
作为输出的一部分 所以如果我回去

1582
01:06:29,580 --> 01:06:33,970
那么说我在这里按分区做这个正确的行

1583
01:06:33,970 --> 01:06:35,950
号所以如果我

1584
01:06:35,950 --> 01:06:39,340
回去我说我现在

1585
01:06:39,340 --> 01:06:51,730
想像最高等级一样计算一些按课程ID注册的小组

1586
01:06:51,730 --> 01:06:56,980
就像我不再看到

1587
01:06:56,980 --> 01:06:58,510
原来的一样 元组是否可以

1588
01:06:58,510 --> 01:06:59,860
在聚合函数中折叠在一起，

1589
01:06:59,860 --> 01:07:01,630
窗口函数仍然

1590
01:07:01,630 --> 01:07:03,250
会在您的输出中生成该单词的所有元组，

1591
01:07:03,250 --> 01:07:06,900
但我现在可以看到它们，因为我

1592
01:07:06,900 --> 01:07:10,300
仍然可以将它们视为输出，所以如果我

1593
01:07:10,300 --> 01:07:12,820
回到这里，如果我这可能 或者可能

1594
01:07:12,820 --> 01:07:16,540
不起作用但让我们看看所以也许我尝试

1595
01:07:16,540 --> 01:07:21,430
max grad 请申请我的课程 ID 是的，所以

1596
01:07:21,430 --> 01:07:25,980
在这里我不是不太工作，

1597
01:07:30,780 --> 01:07:38,530
那是什么坚持的哦，你知道为什么它

1598
01:07:38,530 --> 01:07:48,000
可能是燕麦，现在他们不喜欢它

1599
01:07:50,010 --> 01:07:54,880
有等级哦，是的，因为我是个

1600
01:07:54,880 --> 01:07:58,030
白痴，对不起，是的 做了工作我是

1601
01:07:58,030 --> 01:08:01,240
我想要的 min 是的 所以

1602
01:08:01,240 --> 01:08:05,980
45 岁的 15 岁的最高分是 B 对所以我

1603
01:08:05,980 --> 01:08:07,600
仍然看到我原来的两个弓 我仍然

1604
01:08:07,600 --> 01:08:10,060
看到一个学生得了 C 一个学生

1605
01:08:10,060 --> 01:08:12,960
得了 B 但该组的最大值 是 B 所以

1606
01:08:12,960 --> 01:08:16,420
我没有丢失原始元组现在

1607
01:08:16,420 --> 01:08:17,920
你和你的应用程序代码必须

1608
01:08:17,920 --> 01:08:19,930
从这个输出中获得含义你

1609
01:08:19,930 --> 01:08:22,359
知道得到你赢得的一个字段

1610
01:08:22,359 --> 01:08:23,470
但这允许你

1611
01:08:23,470 --> 01:08:26,140
以一种你可以的方式获得并仍然保留元组 不是

1612
01:08:26,140 --> 01:08:32,069
一个组我这是一个很好的问题是的

1613
01:08:33,839 --> 01:08:36,279
这个问题是你可以

1614
01:08:36,279 --> 01:08:39,729
在使用订单后使用

1615
01:08:39,729 --> 01:08:48,119


1616
01:08:48,359 --> 01:08:51,009


1617
01:08:51,009 --> 01:08:54,930
行号吗 num 哦，

1618
01:08:54,930 --> 01:08:57,540
我是个白痴对不起没人能看到这个

1619
01:08:57,540 --> 01:09:01,750
你怎么能是对不起我的屏幕显示

1620
01:09:01,750 --> 01:09:03,069
一件事 这显示了另一个显示

1621
01:09:03,069 --> 01:09:07,380
这个好的我们现在很好，

1622
01:09:10,328 --> 01:09:13,618
如果我们删除分区

1623
01:09:13,618 --> 01:09:17,319
，现在我们可以将降序放置，

1624
01:09:17,319 --> 01:09:22,500
所以现在我们将得到 5 4 3 2 1 正确

1625
01:09:27,540 --> 01:09:30,339
的板用行替换等级

1626
01:09:30,339 --> 01:09:43,000
数字你是什么意思让我们在网上做这个

1627
01:09:43,000 --> 01:09:44,559
因为我想看到两个

1628
01:09:44,559 --> 01:09:45,698
E 因为他知道在我们继续之前他知道它是为了家庭作业

1629
01:09:45,698 --> 01:09:48,069
好吧我们之后可以试试

1630
01:09:48,069 --> 01:09:52,420
好吧好吧所以她看到

1631
01:09:52,420 --> 01:09:54,699
的方式基本上是要工作的是

1632
01:09:54,699 --> 01:09:56,349
你 已经引入了这个 whiffed

1633
01:09:56,349 --> 01:09:59,139
子句，有一个 whiffed 子句它就像

1634
01:09:59,139 --> 01:10:00,369
一个查询，实际上会在

1635
01:10:00,369 --> 01:10:03,760
您的常规查询之前，所以我们有宽度

1636
01:10:03,760 --> 01:10:06,099
，我们正在定义名称或 CTE，

1637
01:10:06,099 --> 01:10:07,869
然后我们有我们的 ask 子句以及

1638
01:10:07,869 --> 01:10:10,030
括号内的任何内容

1639
01:10:10,030 --> 01:10:13,210
因为该查询的输出然后

1640
01:10:13,210 --> 01:10:15,790
会得到某种映射到这

1641
01:10:15,790 --> 01:10:18,250
是我们的 CTE 的名称，然后在

1642
01:10:18,250 --> 01:10:20,380
它下面的 Select 查询中它可以引用

1643
01:10:20,380 --> 01:10:23,829
它就像它是一个

1644
01:10:23,829 --> 01:10:28,000
现有的表一样，所以在这个

1645
01:10:28,000 --> 01:10:31,659
在这里会发生什么我 s 我看到 te

1646
01:10:31,659 --> 01:10:33,790
调用查询 select one

1647
01:10:33,790 --> 01:10:35,020
没问题，所以我们不必有 from

1648
01:10:35,020 --> 01:10:36,670
子句这只是污染这

1649
01:10:36,670 --> 01:10:39,280
会产生一个具有单个属性的单个元组，

1650
01:10:39,280 --> 01:10:41,500
值为1，

1651
01:10:41,500 --> 01:10:43,599
然后另一个我们在底部

1652
01:10:43,599 --> 01:10:45,190
在它上面选择星号，然后输出那个

1653
01:10:45,190 --> 01:10:48,969
单元组，这样我就可以开始做更

1654
01:10:48,969 --> 01:10:50,619
复杂的事情了，我现在可以将 CTE 内部查询中

1655
01:10:50,619 --> 01:10:53,739
的名称或输出列绑定

1656
01:10:53,739 --> 01:10:56,590
到给定的名称

1657
01:10:56,590 --> 01:10:58,329
，然后我可以通过该

1658
01:10:58,329 --> 01:11:02,469
名称向下引用它们 下面在我底部的语句中

1659
01:11:02,469 --> 01:11:05,530
，所以这个 CTE 生成一个

1660
01:11:05,530 --> 01:11:08,110
具有两个属性的单个元组，

1661
01:11:08,110 --> 01:11:10,300
值为 1 和 2，然后

1662
01:11:10,300 --> 01:11:12,639
这些属性映射到名称列 1 列 2

1663
01:11:12,639 --> 01:11:14,860
，然后在下面的 Select 语句中我

1664
01:11:14,860 --> 01:11:18,219
可以添加它们 在一起非常

1665
01:11:18,219 --> 01:11:20,199
简单，

1666
01:11:20,199 --> 01:11:21,310
所以让我们回过头来尝试做

1667
01:11:21,310 --> 01:11:23,050
我们之前做过的那个例子，我们想要

1668
01:11:23,050 --> 01:11:25,420


1669
01:11:25,420 --> 01:11:27,160
找到注册了

1670
01:11:27,160 --> 01:11:30,969
至少一门课程的 I 学生 ID 最高的学生的姓名，所以为此我有我的

1671
01:11:30,969 --> 01:11:33,580
CTE 和 si 对此，我将再次

1672
01:11:33,580 --> 01:11:35,170
对注册表上的学生 ID 进行最大操作，以

1673
01:11:35,170 --> 01:11:38,620
生成具有该

1674
01:11:38,620 --> 01:11:41,500
最大学生 ID 的一个元组，然后在下方

1675
01:11:41,500 --> 01:11:43,830
进行连接，我将在其中引用在

1676
01:11:43,830 --> 01:11:47,679
我上方生成的 CTE

1677
01:11:47,679 --> 01:11:49,900
我只是将由此产生的最大 ID

1678
01:11:49,900 --> 01:11:52,179


1679
01:11:52,179 --> 01:11:54,370
与我的学生 ID 结合在一起，然后产生

1680
01:11:54,370 --> 01:11:56,020


1681
01:11:56,020 --> 01:11:59,140
一个我想要的元组，这

1682
01:11:59,140 --> 01:12:01,300
是如何在同一时间执行相同查询

1683
01:12:01,300 --> 01:12:02,679
的另一个示例 高级语义上

1684
01:12:02,679 --> 01:12:04,060
相同的查询只是以不同的方式编写，

1685
01:12:04,060 --> 01:12:06,489
所以现在您可能会

1686
01:12:06,489 --> 01:12:07,690
说这与嵌套

1687
01:12:07,690 --> 01:12:11,440
查询有什么不同，答案是您可以

1688
01:12:11,440 --> 01:12:13,900
在公共表表达式中进行递归，

1689
01:12:13,900 --> 01:12:17,500
而在嵌套查询中无法进行 所以请

1690
01:12:17,500 --> 01:12:20,230
耐心等待，但是这个查询

1691
01:12:20,230 --> 01:12:22,000
将产生一个

1692
01:12:22,000 --> 01:12:25,020
从 1 到 10 的数字序列，就像 for 循环一样，

1693
01:12:25,020 --> 01:12:27,820
所以现在我们有了递归，我们

1694
01:12:27,820 --> 01:12:30,760
有了关键字，然后在我们的 CTE

1695
01:12:30,760 --> 01:12:33,219
定义中，我们要做一个联合

1696
01:12:33,219 --> 01:12:36,429
在 p 的单个查询之间 将

1697
01:12:36,429 --> 01:12:38,890
值 1 正确地转化为具有单个属性 1 的单个元组

1698
01:12:38,890 --> 01:12:41,530
，然后我们将

1699
01:12:41,530 --> 01:12:44,380
它与另一个

1700
01:12:44,380 --> 01:12:46,449
实际引用我们自己的查询联合起来，以便

1701
01:12:46,449 --> 01:12:48,429
看到这里我们将对我们自己的

1702
01:12:48,429 --> 01:12:50,890
CTE 进行投票，然后我们将采取 无论

1703
01:12:50,890 --> 01:12:52,210
由此产生的计数器是什么，

1704
01:12:52,210 --> 01:12:55,120
然后将其加 1 并将其作为

1705
01:12:55,120 --> 01:13:00,310
输出，我们一直运行

1706
01:13:00,310 --> 01:13:03,270
它，直到我们的 where 子句实际上

1707
01:13:03,270 --> 01:13:05,620
被绊倒，我们试图超过

1708
01:13:05,620 --> 01:13:07,929
10，然后现在我们停止产生 2 个

1709
01:13:07,929 --> 01:13:09,340
池，所以 现在我们有了我们想要的答案，

1710
01:13:09,340 --> 01:13:11,050
然后我们可以在下面

1711
01:13:11,050 --> 01:13:16,330
的 CTE 中参考是的，您知道它基本上是

1712
01:13:16,330 --> 01:13:21,190


1713
01:13:21,190 --> 01:13:23,670


1714
01:13:23,830 --> 01:13:26,540


1715
01:13:26,540 --> 01:13:28,370


1716
01:13:28,370 --> 01:13:33,080
Union  strips

1717
01:13:33,080 --> 01:13:35,480
保留重复的 Union 并

1718
01:13:35,480 --> 01:13:39,110
删除它们可能是这样我们可以

1719
01:13:39,110 --> 01:13:42,440
测试，虽然没关系，所以让我们

1720
01:13:42,440 --> 01:13:50,870
在 Postgres 中执行此操作，所以好吧，

1721
01:13:50,870 --> 01:13:52,970
这是一个查询，这

1722
01:13:52,970 --> 01:13:55,340
是查询 在我向你展示了正确的时候，我们

1723
01:13:55,340 --> 01:13:58,310
用一个单一的值生成了正确的元组列表

1724
01:13:58,310 --> 01:14:03,010
一个不正确的

1725
01:14:03,489 --> 01:14:09,739
让我试着杀死这个好吧

1726
01:14:09,739 --> 01:14:15,250
，好吧，但它要小心

1727
01:14:15,250 --> 01:14:20,120
CTE 的递归，因为再次网络，

1728
01:14:20,120 --> 01:14:21,290
因为你可以 本质上有

1729
01:14:21,290 --> 01:14:23,810
无限松散所以在这里的这个查询中我

1730
01:14:23,810 --> 01:14:26,690
不再有那个

1731
01:14:26,690 --> 01:14:29,300
大于十的计数器或检查任何

1732
01:14:29,300 --> 01:14:30,920
小于十的元组这

1733
01:14:30,920 --> 01:14:32,930
实际上将永远运行但我首先做的

1734
01:14:32,930 --> 01:14:36,730
是我再次定义了一个收费 Postgres

1735
01:14:36,730 --> 01:14:38,510
我在这里强调，

1736
01:14:38,510 --> 01:14:40,850
你根本看不到

1737
01:14:40,850 --> 01:14:42,290
任何运行超过 10 秒的查询会

1738
01:14:42,290 --> 01:14:44,930
自动终止它，所以当我现在运行这个

1739
01:14:44,930 --> 01:14:47,570
查询时，它不再有 where

1740
01:14:47,570 --> 01:14:49,520
子句来防止它去你知道

1741
01:14:49,520 --> 01:14:52,250
看 在超过 10 的元组中，因此

1742
01:14:52,250 --> 01:14:53,480
基本上永远运行

1743
01:14:53,480 --> 01:14:55,610
Postgres 认识到我们被卡住了，

1744
01:14:55,610 --> 01:14:57,260
并且一个查询花费了太长时间

1745
01:14:57,260 --> 01:14:58,850
，然后自动

1746
01:14:58,850 --> 01:15:06,739
终止它是的所以

1747
01:15:06,739 --> 01:15:11,420
适合所以选择一个现在就这样做

1748
01:15:11,420 --> 01:15:17,290
如果我确实选择了一个 Union all select one

1749
01:15:17,290 --> 01:15:20,890
right 我会这样，

1750
01:15:21,010 --> 01:15:24,100
所以如果我认为我删除了 all

1751
01:15:24,100 --> 01:15:26,580


1752
01:15:26,580 --> 01:15:29,950


1753
01:15:29,950 --> 01:15:32,560


1754
01:15:32,560 --> 01:15:37,600
CTE 说

1755
01:15:37,600 --> 01:15:39,070
无论您在当前值中拥有的任何工具

1756
01:15:39,070 --> 01:15:42,520
都获取输出

1757
01:15:42,520 --> 01:15:49,300
，然后在此处将

1758
01:15:49,300 --> 01:15:52,120
其加一，在那里加一，因此这是

1759
01:15:52,120 --> 01:15:58,630
在我们的源 CTE 上调用

1760
01:15:58,630 --> 01:16:00,700
source 为他们

1761
01:16:00,700 --> 01:16:03,400
获取的每个提示 输出添加一个到它所以

1762
01:16:03,400 --> 01:16:04,630
为了得到那个元组它必须去

1763
01:16:04,630 --> 01:16:06,250
然后调用那个 CTE 然后它

1764
01:16:06,250 --> 01:16:19,870
产生一个是的它不会让你进入柏忌

1765
01:16:19,870 --> 01:16:20,710
因为它知道你试图

1766
01:16:20,710 --> 01:16:23,080
引用自己这些问题

1767
01:16:23,080 --> 01:16:25,450
如果你会发生什么 如果您尝试再次删除

1768
01:16:25,450 --> 01:16:28,360
递归调用，它的续集是

1769
01:16:28,360 --> 01:16:29,739
声明性的，我们知道您要

1770
01:16:29,739 --> 01:16:30,790
尝试执行的所有操作，因此您正在尝试访问

1771
01:16:30,790 --> 01:16:34,810
由您自己定义的 CTE 表

1772
01:16:34,810 --> 01:16:36,880
，但它不允许您这样做，因为

1773
01:16:36,880 --> 01:16:40,870
草书让您这样做 那让我们试试吧

1774
01:16:40,870 --> 01:16:48,040
现在也让我们通过

1775
01:16:48,040 --> 01:16:51,820
删除所有联盟来尝试它，看看呼叫公寓会发生什么

1776
01:16:51,820 --> 01:16:54,610
并且仍然产生

1777
01:16:54,610 --> 01:16:57,430
正确的答案是的，你

1778
01:16:57,430 --> 01:16:59,980
不需要联盟，所以在这个

1779
01:16:59,980 --> 01:17:01,690
例子中我再次合成

1780
01:17:01,690 --> 01:17:04,720
生成一个 两个表的单个

1781
01:17:04,720 --> 01:17:07,870
值为 1，然后我调用一个查询

1782
01:17:07,870 --> 01:17:11,620
来获取该元组并向其添加一个，

1783
01:17:11,620 --> 01:17:13,120
然后生成一个新的元组，

1784
01:17:13,120 --> 01:17:14,530
然后可以再次调用该元组并添加

1785
01:17:14,530 --> 01:17:16,480
一个，我一直这样做直到我

1786
01:17:16,480 --> 01:17:18,340
不这样做 不会产生更多的匹配，

1787
01:17:18,340 --> 01:17:20,739
因为任何当前都结束了，因为

1788
01:17:20,739 --> 01:17:25,560
我已经达到了十个的限制是的

1789
01:17:41,070 --> 01:17:43,630
这个问题是为什么没有

1790
01:17:43,630 --> 01:17:45,790
重复，因为你第一次

1791
01:17:45,790 --> 01:17:48,190
投入你有一个六秒钟你

1792
01:17:48,190 --> 01:17:54,849
调用你会有一个和 两个让我们

1793
01:17:54,849 --> 01:17:57,329
离线做这个让

1794
01:17:57,329 --> 01:17:59,469
我们来看看它因为我们又是布拉多克我们没

1795
01:17:59,469 --> 01:18:01,650
时间

1796
01:18:01,650 --> 01:18:09,070
了是的很快这个问题是

1797
01:18:09,070 --> 01:18:10,780
人们用来礼貌的茶是

1798
01:18:10,780 --> 01:18:14,710
很常见的是的绝对是的所以

1799
01:18:14,710 --> 01:18:16,059
这实际上完成得非常好

1800
01:18:16,059 --> 01:18:19,780
所以 日 我想在

1801
01:18:19,780 --> 01:18:22,869
这里说明的第二点是，在理想情况下，您

1802
01:18:22,869 --> 01:18:26,829
总是希望能够

1803
01:18:26,829 --> 01:18:30,219
计算整个查询，

1804
01:18:30,219 --> 01:18:32,829
而不必将任何数据带到本地，也不必

1805
01:18:32,829 --> 01:18:36,250
在其中来回走动

1806
01:18:36,250 --> 01:18:37,929
还通过作为单个查询运行来提供，

1807
01:18:37,929 --> 01:18:38,199


1808
01:18:38,199 --> 01:18:40,059
尽管复杂性

1809
01:18:40,059 --> 01:18:42,099
使新查询优化变得更加困难，但是如果

1810
01:18:42,099 --> 01:18:44,170
您告诉游戏系统

1811
01:18:44,170 --> 01:18:45,940
您想要对此类数据执行的所有操作，

1812
01:18:45,940 --> 01:18:48,520
那么他们可以对其进行全局

1813
01:18:48,520 --> 01:18:50,889
优化 CTE

1814
01:18:50,889 --> 01:18:52,809
你不必有额外的

1815
01:18:52,809 --> 01:18:54,579
逻辑在大卫系统之外的某个地方水杨苷

1816
01:18:54,579 --> 01:18:55,570
它会来回

1817
01:18:55,570 --> 01:18:57,340
你说这就是我想做的一切

1818
01:18:57,340 --> 01:19:00,040
所以 CTE 实际上很常见，

1819
01:19:00,040 --> 01:19:02,489
尤其是在较新的应用程序中

1820
01:19:02,489 --> 01:19:06,130
递归 CD 可能不那么

1821
01:19:06,130 --> 01:19:07,960
绝对是 cetys 但它是编写嵌套查询的另一种方式

1822
01:19:07,960 --> 01:19:11,320
好吧

1823
01:19:11,320 --> 01:19:12,940
我想指出的另一件主要事情是

1824
01:19:12,940 --> 01:19:16,179
该语言再次来自 1973 年或

1825
01:19:16,179 --> 01:19:19,570
1974 年，但它仍然很普遍，您

1826
01:19:19,570 --> 01:19:22,059
经常使用它 一直在

1827
01:19:22,059 --> 01:19:25,179
更新，学习续集很重要，

1828
01:19:25,179 --> 01:19:26,170
因为你会

1829
01:19:26,170 --> 01:19:27,909
在你的一生中再次看到这一点几乎

1830
01:19:27,909 --> 01:19:30,030


1831
01:19:30,030 --> 01:19:32,619
你知道的每一个系统数据库系统

1832
01:19:32,619 --> 01:19:34,420
都会支持续集的一些变体

1833
01:19:34,420 --> 01:19:36,960
哦，

1834
01:19:37,149 --> 01:19:40,329
我大声说要解决 如果一台机器

1835
01:19:40,329 --> 01:19:42,489
在一点点破碎的酒吧里

1836
01:19:42,489 --> 01:19:43,360
被压碎了孩子们

1837
01:19:43,360 --> 01:19:46,809
让演示中的奶牛我会

1838
01:19:46,809 --> 01:19:49,479
在我的系统中尝试他的机智九我很幸运

1839
01:19:49,479 --> 01:19:57,489
让我们去买下一个好永远不要被

1840
01:19:57,489 --> 01:19:59,619
儿子跳弹果冻击中熟食店 食物

1841
01:19:59,619 --> 01:20:01,570
报告自然祝福你什么

1842
01:20:01,570 --> 01:20:03,189
说唱歌手喜欢激光束

1843
01:20:03,189 --> 01:20:05,530
灌木丛中的球什么都不说就像国王包裹

1844
01:20:05,530 --> 01:20:07,329
我们的瓶子一个很好的同情去

1845
01:20:07,329 --> 01:20:09,699
不要想喝那种质量

1846
01:20:09,699 --> 01:20:11,289
你喝醉了你不能放弃他还

1847
01:20:11,289 --> 01:20:13,179
活着 并且在赌注中不知道您的

1848
01:20:13,179 --> 01:20:15,929
手机可以点击

