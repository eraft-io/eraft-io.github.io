1
00:00:03,640 --> 00:00:13,140
[Music]

2
00:00:17,350 --> 00:00:19,850
hi my name is Dana

3
00:00:19,850 --> 00:00:22,880
so I'm another one if Andy's PhD

4
00:00:22,880 --> 00:00:25,189
students and probably going to be the

5
00:00:25,189 --> 00:00:27,140
last of his PhD students to present to

6
00:00:27,140 --> 00:00:30,829
you before he gets back so today I'm

7
00:00:30,829 --> 00:00:33,079
going to be presenting the light your

8
00:00:33,079 --> 00:00:36,340
very last lecture on concurrency control

9
00:00:36,340 --> 00:00:39,170
so before we start a couple of reminders

10
00:00:39,170 --> 00:00:42,620
the first is the project three is is due

11
00:00:42,620 --> 00:00:45,430
on Sunday November 17th before midnight

12
00:00:45,430 --> 00:00:48,440
we also released homework for last week

13
00:00:48,440 --> 00:00:51,050
and then will be due on November 13th

14
00:00:51,050 --> 00:00:55,730
before midnight any questions before we

15
00:00:55,730 --> 00:01:05,239
begin all right so um today we are going

16
00:01:05,239 --> 00:01:06,790
to talk about multi-version concurrency

17
00:01:06,790 --> 00:01:10,760
control just make sure I just this here

18
00:01:10,760 --> 00:01:12,829
so the first thing I want to point out

19
00:01:12,829 --> 00:01:15,710
about multi-version concurrency controls

20
00:01:15,710 --> 00:01:19,250
that it's name is a misnomer and this

21
00:01:19,250 --> 00:01:21,860
may cause some confusion because it's

22
00:01:21,860 --> 00:01:23,350
not actually a concurrency control

23
00:01:23,350 --> 00:01:25,280
protocol like the ones that you've been

24
00:01:25,280 --> 00:01:26,869
learning about in the past two lectures

25
00:01:26,869 --> 00:01:30,170
which are timestamp or during OCC and

26
00:01:30,170 --> 00:01:32,720
two-phase locking

27
00:01:32,720 --> 00:01:34,880
rather it's a way to architect the

28
00:01:34,880 --> 00:01:36,920
system when you have concurrent

29
00:01:36,920 --> 00:01:39,829
transactions running by maintaining

30
00:01:39,829 --> 00:01:43,009
multiple versions so recall from last

31
00:01:43,009 --> 00:01:44,930
week your discussion of optimistic

32
00:01:44,930 --> 00:01:47,560
currency control where transactions

33
00:01:47,560 --> 00:01:50,509
maintain a private workspace and anytime

34
00:01:50,509 --> 00:01:53,119
they read or wrote to an object it will

35
00:01:53,119 --> 00:01:55,280
copy that object into that private

36
00:01:55,280 --> 00:01:58,850
workspace well in the multi-version

37
00:01:58,850 --> 00:02:00,619
concurrency control is similar to that

38
00:02:00,619 --> 00:02:03,140
idea except here instead of having a

39
00:02:03,140 --> 00:02:06,140
private workspace for each transactions

40
00:02:06,140 --> 00:02:07,820
where we maintain these different

41
00:02:07,820 --> 00:02:10,250
versions we're now going to have the

42
00:02:10,250 --> 00:02:12,430
version to be part of a global database

43
00:02:12,430 --> 00:02:14,630
and we're going to determine whether

44
00:02:14,630 --> 00:02:17,540
some version of it is vision is visible

45
00:02:17,540 --> 00:02:21,040
to a particular transaction

46
00:02:22,770 --> 00:02:28,620
so MVCC is used by almost every new

47
00:02:28,620 --> 00:02:30,720
database system that's been built in the

48
00:02:30,720 --> 00:02:34,200
past ten years or some variant of it but

49
00:02:34,200 --> 00:02:35,130
it's not a new idea

50
00:02:35,130 --> 00:02:39,210
so it actually it's actually decades old

51
00:02:39,210 --> 00:02:41,640
and the first reference to the idea was

52
00:02:41,640 --> 00:02:45,470
in a dissertation by PhD student MIT in

53
00:02:45,470 --> 00:02:52,110
1978 so it wasn't until the early 80s at

54
00:02:52,110 --> 00:02:54,710
the first that the first implicate

55
00:02:54,710 --> 00:02:57,090
implementations of it actually came out

56
00:02:57,090 --> 00:02:59,460
and those came out of a company called

57
00:02:59,460 --> 00:03:03,030
Dec and they were called our DB VMs

58
00:03:03,030 --> 00:03:06,060
which stood for relational database for

59
00:03:06,060 --> 00:03:08,910
VMs or VAX which was an old operating

60
00:03:08,910 --> 00:03:12,300
system and the other product was called

61
00:03:12,300 --> 00:03:15,540
inter base so Dec used to be a major

62
00:03:15,540 --> 00:03:18,450
computer company it was bought out by a

63
00:03:18,450 --> 00:03:21,810
Compaq in the late 90s and then a few

64
00:03:21,810 --> 00:03:23,970
years later bought out by HP so it's no

65
00:03:23,970 --> 00:03:26,430
longer around but it did some major

66
00:03:26,430 --> 00:03:31,400
pioneering work and database systems so

67
00:03:31,400 --> 00:03:34,230
both our DB VMs and their base were

68
00:03:34,230 --> 00:03:36,900
built by a guy named Jim Starkey who was

69
00:03:36,900 --> 00:03:39,540
also credited as being the inventor of

70
00:03:39,540 --> 00:03:43,530
blobs and triggers so he's a big deal he

71
00:03:43,530 --> 00:03:46,650
later went on to co-found nuodb which is

72
00:03:46,650 --> 00:03:48,420
a new database startup and it also

73
00:03:48,420 --> 00:03:54,720
happens to use in BCC so Dec our DB VMs

74
00:03:54,720 --> 00:03:56,850
was bought up by Oracle and is now known

75
00:03:56,850 --> 00:04:07,100
as oracle rdb and it was an inner base

76
00:04:07,100 --> 00:04:11,040
was eventually sold by Dec it went

77
00:04:11,040 --> 00:04:11,910
through a few different holding

78
00:04:11,910 --> 00:04:14,970
companies and finally was open sourced

79
00:04:14,970 --> 00:04:17,279
and so now it's known under a different

80
00:04:17,279 --> 00:04:20,488
name now it's called Firebird so it may

81
00:04:20,488 --> 00:04:22,560
not be as well-known as my sequel or

82
00:04:22,560 --> 00:04:24,810
Postgres but there's one of the earliest

83
00:04:24,810 --> 00:04:29,280
open-source databases out there and Andy

84
00:04:29,280 --> 00:04:30,900
had this little fun fact in there from

85
00:04:30,900 --> 00:04:33,210
last year or so I'll go ahead and

86
00:04:33,210 --> 00:04:35,430
say it so if you if you've ever wonder

87
00:04:35,430 --> 00:04:39,030
why the fire for Firefox web-browser is

88
00:04:39,030 --> 00:04:41,729
named Firefox it's because they were

89
00:04:41,729 --> 00:04:44,340
originally called Phoenix but then they

90
00:04:44,340 --> 00:04:45,930
had to change that name because it

91
00:04:45,930 --> 00:04:47,639
conflicted you know with another system

92
00:04:47,639 --> 00:04:50,639
or another product so they changed it to

93
00:04:50,639 --> 00:04:52,319
Firebird but then they had to change it

94
00:04:52,319 --> 00:04:53,759
again because it conflicted with this

95
00:04:53,759 --> 00:04:56,460
database system so finally it was called

96
00:04:56,460 --> 00:05:06,870
Firefox so the main benefit again like

97
00:05:06,870 --> 00:05:08,970
what you have to understand about MVCC

98
00:05:08,970 --> 00:05:11,699
is that writers don't block the readers

99
00:05:11,699 --> 00:05:14,060
and the readers don't block the writers

100
00:05:14,060 --> 00:05:16,050
so it's only when you have two

101
00:05:16,050 --> 00:05:18,300
transactions trying to write it till the

102
00:05:18,300 --> 00:05:20,699
object at the same time they have to

103
00:05:20,699 --> 00:05:23,240
fall back and rely on one of the

104
00:05:23,240 --> 00:05:25,259
concurrency control protocols like

105
00:05:25,259 --> 00:05:28,830
two-phase locking so again you only need

106
00:05:28,830 --> 00:05:30,120
to do this when you have a write write

107
00:05:30,120 --> 00:05:33,750
conflict so with a high level the way

108
00:05:33,750 --> 00:05:36,870
this works is we're going to assign time

109
00:05:36,870 --> 00:05:39,449
stamps to transactions when they arrive

110
00:05:39,449 --> 00:05:41,759
in the system and then we're going to

111
00:05:41,759 --> 00:05:44,669
provide it with a consistent snapshot of

112
00:05:44,669 --> 00:05:47,039
the database as it existed at the time

113
00:05:47,039 --> 00:05:53,039
that that transaction arrived so this

114
00:05:53,039 --> 00:05:55,830
means that they won't see changes from

115
00:05:55,830 --> 00:05:58,139
transactions that have not been that

116
00:05:58,139 --> 00:06:00,030
have not yet been committed in their

117
00:06:00,030 --> 00:06:04,949
snapshot and just to clarify this is a

118
00:06:04,949 --> 00:06:06,599
virtual snapshot so it shouldn't be

119
00:06:06,599 --> 00:06:09,330
confused with you know if a physical

120
00:06:09,330 --> 00:06:11,490
snapshot or copying the the full

121
00:06:11,490 --> 00:06:14,009
database to another location and then

122
00:06:14,009 --> 00:06:16,020
running that transaction on it so again

123
00:06:16,020 --> 00:06:21,810
this is um this is just virtual so MVCC

124
00:06:21,810 --> 00:06:23,430
is really useful for read-only

125
00:06:23,430 --> 00:06:26,880
transactions because the sequel dialect

126
00:06:26,880 --> 00:06:29,639
allows you to declare when a transaction

127
00:06:29,639 --> 00:06:32,909
is read-only and if you do this then the

128
00:06:32,909 --> 00:06:35,940
database system does not require you to

129
00:06:35,940 --> 00:06:37,770
get any locks or maintain the readwrite

130
00:06:37,770 --> 00:06:41,310
sets and this works again because it has

131
00:06:41,310 --> 00:06:43,680
a consistent snapshot and will only see

132
00:06:43,680 --> 00:06:45,750
the changes that existed at the moment

133
00:06:45,750 --> 00:06:47,059
it started

134
00:06:47,059 --> 00:06:48,439
and this makes these read-only

135
00:06:48,439 --> 00:06:51,289
transactions really efficient and also

136
00:06:51,289 --> 00:06:56,199
really fast to do yes

137
00:06:57,039 --> 00:07:01,159
I'm even just like I mentioned a minute

138
00:07:01,159 --> 00:07:04,029
ago like it's it's essentially just

139
00:07:04,029 --> 00:07:06,249
maintaining like a version table our

140
00:07:06,249 --> 00:07:08,779
version made it data information and

141
00:07:08,779 --> 00:07:10,399
it's very similar the OCC where you

142
00:07:10,399 --> 00:07:12,049
understand the read and write sets and

143
00:07:12,049 --> 00:07:14,599
we're going to clearly go over this in a

144
00:07:14,599 --> 00:07:15,859
lot of detail in the following slides

145
00:07:15,859 --> 00:07:18,289
this is gonna be the the topic of this

146
00:07:18,289 --> 00:07:35,599
lecture yeah so it's the we're talking

147
00:07:35,599 --> 00:07:37,849
about two reads here they will read the

148
00:07:37,849 --> 00:07:41,179
the same snapshot the same version so

149
00:07:41,179 --> 00:07:43,639
snapshot you know it's more commonly I

150
00:07:43,639 --> 00:07:46,129
think referred to as the version you

151
00:07:46,129 --> 00:07:55,099
know the tuple or database object well

152
00:07:55,099 --> 00:07:58,699
can so if you so bear with me for just

153
00:07:58,699 --> 00:08:01,639
like you know three minutes probably

154
00:08:01,639 --> 00:08:03,709
less and we'll actually that is the

155
00:08:03,709 --> 00:08:07,039
first thing we're gonna cover and I'll

156
00:08:07,039 --> 00:08:08,989
I'll answer any other questions you have

157
00:08:08,989 --> 00:08:23,389
afterward all right so just to finish up

158
00:08:23,389 --> 00:08:25,789
on the slide another advantage of MVCC

159
00:08:25,789 --> 00:08:28,969
is that you're able to support something

160
00:08:28,969 --> 00:08:33,500
called time travel queries so these are

161
00:08:33,500 --> 00:08:35,929
queries to actually let you ask the

162
00:08:35,929 --> 00:08:38,539
database system for example what was the

163
00:08:38,539 --> 00:08:40,188
state of the database you know three

164
00:08:40,188 --> 00:08:41,029
days ago

165
00:08:41,029 --> 00:08:44,720
three years ago and using these and

166
00:08:44,720 --> 00:08:46,610
using this versioning they can actually

167
00:08:46,610 --> 00:08:51,579
answer these these sort of queries

168
00:08:55,570 --> 00:08:58,269
all right so the idea of time travel

169
00:08:58,269 --> 00:09:02,410
queries was first was an idea of

170
00:09:02,410 --> 00:09:04,779
Postgres and it originated from Postgres

171
00:09:04,779 --> 00:09:07,839
in the 1980s but postcards actually

172
00:09:07,839 --> 00:09:12,149
removed these time travel queries from

173
00:09:12,149 --> 00:09:15,759
from their from their current product

174
00:09:15,759 --> 00:09:18,370
like as soon as you know people outside

175
00:09:18,370 --> 00:09:20,259
of academia I started using Postgres

176
00:09:20,259 --> 00:09:26,529
more heavily can anybody guess why well

177
00:09:26,529 --> 00:09:29,139
so the reason why is because essentially

178
00:09:29,139 --> 00:09:32,410
what you have to do to actually support

179
00:09:32,410 --> 00:09:35,230
time travel queries is you never throw

180
00:09:35,230 --> 00:09:37,959
away old versions so you never garbage

181
00:09:37,959 --> 00:09:41,350
collect right so over time you're you

182
00:09:41,350 --> 00:09:42,940
know the more and more transactions that

183
00:09:42,940 --> 00:09:45,699
commit your your disk base will be

184
00:09:45,699 --> 00:09:48,880
filling up very quickly and eventually

185
00:09:48,880 --> 00:09:51,610
it will be full and probably very

186
00:09:51,610 --> 00:09:53,310
quickly depending on the speed of your

187
00:09:53,310 --> 00:09:57,819
transactions and the the other thing is

188
00:09:57,819 --> 00:10:00,430
that time travel queries are not really

189
00:10:00,430 --> 00:10:02,709
needed by a lot of applications like you

190
00:10:02,709 --> 00:10:05,350
can't you never really look at you never

191
00:10:05,350 --> 00:10:07,089
go to a website and say like ok I want

192
00:10:07,089 --> 00:10:08,740
to know what this webpage looked like

193
00:10:08,740 --> 00:10:10,810
three days ago well I'm not the most use

194
00:10:10,810 --> 00:10:15,029
cases but Andy mentions that like one

195
00:10:15,029 --> 00:10:17,199
common use case for these time

196
00:10:17,199 --> 00:10:19,899
travelling queries is in the financial

197
00:10:19,899 --> 00:10:24,370
industry so the reason is because you

198
00:10:24,370 --> 00:10:27,310
know do - I know pursuit you know

199
00:10:27,310 --> 00:10:29,230
whatever whatever rules and regulations

200
00:10:29,230 --> 00:10:30,670
they have to follow they have to

201
00:10:30,670 --> 00:10:32,199
actually maintain in the past seven

202
00:10:32,199 --> 00:10:36,430
years of transaction history so these

203
00:10:36,430 --> 00:10:38,350
time travel queries actually allow them

204
00:10:38,350 --> 00:10:42,370
to very easily query the database and

205
00:10:42,370 --> 00:10:45,220
figure out why you know some of money

206
00:10:45,220 --> 00:10:46,899
what their what their total revenue was

207
00:10:46,899 --> 00:10:49,510
or whatever they want to look up you

208
00:10:49,510 --> 00:10:52,920
know over the past seven years

209
00:10:55,680 --> 00:10:58,720
all right so um and the next few slides

210
00:10:58,720 --> 00:11:01,420
we're going to go over two examples and

211
00:11:01,420 --> 00:11:03,070
what I really want to emphasize here

212
00:11:03,070 --> 00:11:07,140
before we start is that MVCC is

213
00:11:07,140 --> 00:11:09,040
independent from concurrency control

214
00:11:09,040 --> 00:11:11,200
protocols so the purpose of these

215
00:11:11,200 --> 00:11:13,870
examples is just to basically show you

216
00:11:13,870 --> 00:11:18,040
how we you know update versions and

217
00:11:18,040 --> 00:11:21,810
timestamps in the table and also

218
00:11:21,810 --> 00:11:25,390
basically like how sorry how we figure

219
00:11:25,390 --> 00:11:30,940
out which version how we figure out

220
00:11:30,940 --> 00:11:34,900
which version is - is visible to the

221
00:11:34,900 --> 00:11:36,400
particular transaction right which

222
00:11:36,400 --> 00:11:37,960
version of the tuple is physical is

223
00:11:37,960 --> 00:11:42,280
visible so this first example we'll see

224
00:11:42,280 --> 00:11:46,270
how this is going to work so right now

225
00:11:46,270 --> 00:11:48,100
like the first thing to point out is

226
00:11:48,100 --> 00:11:51,100
that now we have this version field

227
00:11:51,100 --> 00:11:52,660
right so we can see in this version

228
00:11:52,660 --> 00:11:56,500
field but it's assigned to a zero so

229
00:11:56,500 --> 00:12:00,190
this means object day version zero right

230
00:12:00,190 --> 00:12:02,680
so we can assume that some other

231
00:12:02,680 --> 00:12:05,290
transaction has written the value one

232
00:12:05,290 --> 00:12:07,810
two three to the database and whatever

233
00:12:07,810 --> 00:12:10,630
attraction transaction wrote it how the

234
00:12:10,630 --> 00:12:12,790
time was assigned a timestamp of zero

235
00:12:12,790 --> 00:12:16,030
and we'll go over why in one second so

236
00:12:16,030 --> 00:12:19,690
we also have a begin and end fields and

237
00:12:19,690 --> 00:12:22,030
so these are just timestamps it doesn't

238
00:12:22,030 --> 00:12:23,230
matter if they're logical physical

239
00:12:23,230 --> 00:12:26,680
hybrid as long as they you know they're

240
00:12:26,680 --> 00:12:29,589
always increasing and follow the other

241
00:12:29,589 --> 00:12:32,830
you know and I guess our our ballad

242
00:12:32,830 --> 00:12:34,360
timestamps right like you learned in the

243
00:12:34,360 --> 00:12:44,240
past few lectures alright so

244
00:12:44,240 --> 00:12:47,360
let's begin so when a new transaction

245
00:12:47,360 --> 00:12:49,759
arrives to transact we're going to be

246
00:12:49,759 --> 00:12:52,459
looking at transactions t1 and t2 so

247
00:12:52,459 --> 00:12:55,999
here T t1 arrives and it's assigned a

248
00:12:55,999 --> 00:13:00,740
time stamp of 1 right so now we're going

249
00:13:00,740 --> 00:13:02,269
to begin okay so for the first thing we

250
00:13:02,269 --> 00:13:05,740
want to do is what I do a read on a so

251
00:13:05,740 --> 00:13:08,079
what we're going to do is we're going to

252
00:13:08,079 --> 00:13:11,569
consider you know time transaction once

253
00:13:11,569 --> 00:13:13,339
time stamp which is 1 and we're going to

254
00:13:13,339 --> 00:13:15,939
take a look at our table and figure out

255
00:13:15,939 --> 00:13:20,389
which tuple is visible to it by trying

256
00:13:20,389 --> 00:13:23,240
to find by finding you know where its

257
00:13:23,240 --> 00:13:25,009
current time stamp is between the end

258
00:13:25,009 --> 00:13:27,619
and between beginning and end so in this

259
00:13:27,619 --> 00:13:32,209
example the beginning is 0 and the time

260
00:13:32,209 --> 00:13:34,670
step of 1 is between 0 and the end which

261
00:13:34,670 --> 00:13:36,889
is infinity right so it's going to go

262
00:13:36,889 --> 00:13:41,259
ahead and breed version a 0 all right

263
00:13:41,259 --> 00:13:44,869
all right so now we have transaction t2

264
00:13:44,869 --> 00:13:46,910
and we're going to assign the time stamp

265
00:13:46,910 --> 00:13:50,119
to so the first thing we want to do here

266
00:13:50,119 --> 00:13:53,720
is we want to write a so at this point

267
00:13:53,720 --> 00:13:55,269
what we're going to do is we're going to

268
00:13:55,269 --> 00:14:00,199
create a completely new version of a

269
00:14:00,199 --> 00:14:02,389
which will be a 1 right because we're

270
00:14:02,389 --> 00:14:04,420
just incrementing the version counter

271
00:14:04,420 --> 00:14:09,949
and right and so what we're going to do

272
00:14:09,949 --> 00:14:11,569
here is the beginning time stamp is

273
00:14:11,569 --> 00:14:14,740
going to be set to the time stamp of t2

274
00:14:14,740 --> 00:14:17,600
the enzyme sample again be set to

275
00:14:17,600 --> 00:14:19,490
infinity and then the last thing we're

276
00:14:19,490 --> 00:14:21,199
going to do is we're going to update the

277
00:14:21,199 --> 00:14:26,029
end time stamp of version a 0 to also be

278
00:14:26,029 --> 00:14:29,959
a time stamp of to write for transaction

279
00:14:29,959 --> 00:14:35,660
2 all right so one thing you might have

280
00:14:35,660 --> 00:14:38,319
noticed that we're missing so far is

281
00:14:38,319 --> 00:14:41,029
like with with just either the

282
00:14:41,029 --> 00:14:42,829
information that we had so far before we

283
00:14:42,829 --> 00:14:44,809
before this transaction says table

284
00:14:44,809 --> 00:14:46,339
popped up the one thing that we're

285
00:14:46,339 --> 00:14:47,809
missing is that we don't really know the

286
00:14:47,809 --> 00:14:50,299
current state of the transactions in the

287
00:14:50,299 --> 00:14:53,919
database so for example you know the

288
00:14:53,919 --> 00:14:55,939
transactions here are currently active

289
00:14:55,939 --> 00:14:57,830
but what if they abort

290
00:14:57,830 --> 00:14:59,210
you know then you would have to go back

291
00:14:59,210 --> 00:15:03,530
and reverse the timestamps accordingly

292
00:15:03,530 --> 00:15:13,880
if it was aborted right so as you can

293
00:15:13,880 --> 00:15:16,790
see here we're just going to start

294
00:15:16,790 --> 00:15:19,010
filling out the transaction status table

295
00:15:19,010 --> 00:15:20,840
at this point both transactions are

296
00:15:20,840 --> 00:15:24,260
active then finally we're going to do

297
00:15:24,260 --> 00:15:27,350
this read on a so what version is it

298
00:15:27,350 --> 00:15:34,220
going to read anyone right hey sub-zero

299
00:15:34,220 --> 00:15:36,440
because again it's timestamp still lies

300
00:15:36,440 --> 00:15:39,710
between the beginning and end here so

301
00:15:39,710 --> 00:15:42,850
it's gonna go ahead and read version a0o

302
00:15:42,850 --> 00:15:46,880
and finally its gonna commit so at the

303
00:15:46,880 --> 00:15:48,890
very end after this commits then the

304
00:15:48,890 --> 00:15:50,990
then transaction t2 will come it will

305
00:15:50,990 --> 00:15:53,840
update the status table and we can blow

306
00:15:53,840 --> 00:15:59,960
it away eventually so for the second

307
00:15:59,960 --> 00:16:02,480
example we're gonna start with sort of

308
00:16:02,480 --> 00:16:04,070
the same setup right so we have

309
00:16:04,070 --> 00:16:08,260
transaction t1 with a timestamp of 1 and

310
00:16:08,260 --> 00:16:10,190
transaction t2 we're assigning a

311
00:16:10,190 --> 00:16:13,310
timestamp of 2 and it's the same stay in

312
00:16:13,310 --> 00:16:17,900
the in the database table and so far

313
00:16:17,900 --> 00:16:20,180
we're just starting transaction t1 we're

314
00:16:20,180 --> 00:16:22,130
saying it's timestamp to 1 and it's

315
00:16:22,130 --> 00:16:27,050
status is active so first we're going to

316
00:16:27,050 --> 00:16:29,290
do a read on a I think at this point

317
00:16:29,290 --> 00:16:32,020
it's pretty clear that we're going to

318
00:16:32,020 --> 00:16:36,200
read version a0 and next we're gonna do

319
00:16:36,200 --> 00:16:37,730
a write on a so again just like in the

320
00:16:37,730 --> 00:16:39,830
last slide we're going to create a

321
00:16:39,830 --> 00:16:42,050
completely new version I'm inserting in

322
00:16:42,050 --> 00:16:44,270
our database table where it's gonna be

323
00:16:44,270 --> 00:16:47,750
version a 1 with value 4 5 6 and the

324
00:16:47,750 --> 00:16:50,270
beginning timestamp will be a 1 right it

325
00:16:50,270 --> 00:16:51,950
will be whatever this timestamp is and

326
00:16:51,950 --> 00:16:53,690
the end we will assign to infinity again

327
00:16:53,690 --> 00:16:57,440
and the last thing to not forget is that

328
00:16:57,440 --> 00:17:00,890
we need to go up to a0 and assign the

329
00:17:00,890 --> 00:17:03,080
end timestamp to be the current

330
00:17:03,080 --> 00:17:07,240
timestamp of transaction t1 which is 1

331
00:17:07,240 --> 00:17:09,260
alright so now we're going to begin

332
00:17:09,260 --> 00:17:10,740
transaction 2

333
00:17:10,740 --> 00:17:12,089
so the first thing we're going to do is

334
00:17:12,089 --> 00:17:16,319
a read on a so in this case which

335
00:17:16,319 --> 00:17:22,829
transaction is it going to read or sorry

336
00:17:22,829 --> 00:17:24,420
which version is it gonna read excuse me

337
00:17:24,420 --> 00:17:32,790
a 1 and why is that right yeah somebody

338
00:17:32,790 --> 00:17:35,580
I guess yeah so in this case um it's

339
00:17:35,580 --> 00:17:38,730
gonna be oh sorry

340
00:17:38,730 --> 00:17:41,040
for a yes so one thing that we have to

341
00:17:41,040 --> 00:17:43,440
pay attention to and this is a little

342
00:17:43,440 --> 00:17:45,030
tricky right now one thing I forgot to

343
00:17:45,030 --> 00:17:46,860
mention that the start is I understand

344
00:17:46,860 --> 00:17:48,020
you guys didn't have time to go over

345
00:17:48,020 --> 00:17:52,260
isolation levels so and II wanted you

346
00:17:52,260 --> 00:17:54,000
guys to just review the slides and also

347
00:17:54,000 --> 00:17:56,880
the lecture from last year so I'm just

348
00:17:56,880 --> 00:17:58,290
gonna provide some high-level hints for

349
00:17:58,290 --> 00:18:01,260
isolation levels for when you go over

350
00:18:01,260 --> 00:18:03,210
those slides and the homeworks right but

351
00:18:03,210 --> 00:18:05,460
it might not make full sense at this

352
00:18:05,460 --> 00:18:07,560
point but basically like at a very high

353
00:18:07,560 --> 00:18:09,690
level depending on the isolation level

354
00:18:09,690 --> 00:18:14,490
you have it may choose either version a

355
00:18:14,490 --> 00:18:17,820
0 a 1 but let's assume it's sort of it's

356
00:18:17,820 --> 00:18:21,630
the strict serializable or excuse me

357
00:18:21,630 --> 00:18:23,610
serializable isolation which is sort of

358
00:18:23,610 --> 00:18:25,230
what you guys have been using up until

359
00:18:25,230 --> 00:18:28,650
this point and this point it will it has

360
00:18:28,650 --> 00:18:31,230
to read a 0 because a 1 has not yet

361
00:18:31,230 --> 00:18:35,610
committed alright so now we're gonna do

362
00:18:35,610 --> 00:18:38,880
a write on a and so in this case what's

363
00:18:38,880 --> 00:18:40,320
gonna happen next

364
00:18:40,320 --> 00:18:42,870
well again here we have a write write

365
00:18:42,870 --> 00:18:46,080
conflict right so assuming we're using a

366
00:18:46,080 --> 00:18:49,560
to be lt2 is gonna have to stall until

367
00:18:49,560 --> 00:18:53,670
t1 commits all right so let's keep this

368
00:18:53,670 --> 00:18:56,670
going so now we're back to t1 we're

369
00:18:56,670 --> 00:18:59,280
going to do a read on a and in this case

370
00:18:59,280 --> 00:19:00,690
it's gonna just read the same version

371
00:19:00,690 --> 00:19:03,050
that it wrote couple minutes ago right

372
00:19:03,050 --> 00:19:06,860
and it's gonna go ahead and commit

373
00:19:06,860 --> 00:19:10,470
alright so now we can go back here and

374
00:19:10,470 --> 00:19:12,570
we can go ahead and now we're going to

375
00:19:12,570 --> 00:19:15,210
create the new version a 2 with value 7

376
00:19:15,210 --> 00:19:17,010
8 9 we're going to assign it the time

377
00:19:17,010 --> 00:19:19,440
stamp of 2 with an end time step of

378
00:19:19,440 --> 00:19:21,540
infinity and we're going to update the

379
00:19:21,540 --> 00:19:24,540
end time stamp of a 1 to 2 as well

380
00:19:24,540 --> 00:19:28,200
right so at this point you know whether

381
00:19:28,200 --> 00:19:30,930
whether the weather t2 actually commits

382
00:19:30,930 --> 00:19:33,950
or not is really dependent on the

383
00:19:33,950 --> 00:19:36,120
concurrency control protocol as well as

384
00:19:36,120 --> 00:19:37,560
the isolation level so that's something

385
00:19:37,560 --> 00:19:39,750
to keep in mind but really this this

386
00:19:39,750 --> 00:19:41,760
example the purpose of this example is

387
00:19:41,760 --> 00:19:44,730
just to show you how we update the

388
00:19:44,730 --> 00:19:47,310
object versions maintain the transaction

389
00:19:47,310 --> 00:19:49,890
status table and also figure out which

390
00:19:49,890 --> 00:19:52,110
tuples are visible all right any

391
00:19:52,110 --> 00:20:04,290
questions on this all right so as I

392
00:20:04,290 --> 00:20:42,300
mentioned if you say oh yes oh well so

393
00:20:42,300 --> 00:20:44,130
this again this is a very high-level

394
00:20:44,130 --> 00:20:46,050
example right now and there's actually

395
00:20:46,050 --> 00:20:48,210
we're going to go into how you actually

396
00:20:48,210 --> 00:20:50,880
store this information later on in this

397
00:20:50,880 --> 00:20:54,030
lecture so that's with you like so that

398
00:20:54,030 --> 00:20:55,860
that will answer the question basically

399
00:20:55,860 --> 00:20:59,640
it's in some cases yes you do need to

400
00:20:59,640 --> 00:21:03,180
consider locks it really depends on how

401
00:21:03,180 --> 00:21:04,710
you're actually storing this version

402
00:21:04,710 --> 00:21:08,640
information so if if we don't cover it

403
00:21:08,640 --> 00:21:10,230
in a few slides because there's multiple

404
00:21:10,230 --> 00:21:12,480
ways to do this so I don't want to just

405
00:21:12,480 --> 00:21:14,070
list them all out now we don't cover it

406
00:21:14,070 --> 00:21:16,020
in few slides please ask your question

407
00:21:16,020 --> 00:21:18,230
again

408
00:21:21,620 --> 00:21:25,889
all right so um so again like MVCC or

409
00:21:25,889 --> 00:21:28,260
its variants are used in almost all new

410
00:21:28,260 --> 00:21:31,889
database systems and these are just you

411
00:21:31,889 --> 00:21:33,809
know some examples of the systems that

412
00:21:33,809 --> 00:21:37,230
use in VCC but what we really want to

413
00:21:37,230 --> 00:21:39,299
emphasize for the rest of this lecture

414
00:21:39,299 --> 00:21:43,320
is that MVCC is a lot more than just

415
00:21:43,320 --> 00:21:44,789
maintaining the time stamps that I

416
00:21:44,789 --> 00:21:46,580
showed you in the previous two examples

417
00:21:46,580 --> 00:21:48,570
there's a whole bunch of other design

418
00:21:48,570 --> 00:21:50,100
decisions that you have to make in order

419
00:21:50,100 --> 00:21:52,289
to actually implement a system that

420
00:21:52,289 --> 00:21:54,269
supports in VCC so we're gonna go over

421
00:21:54,269 --> 00:21:57,210
those next so what exactly are these

422
00:21:57,210 --> 00:22:00,570
design decisions specifically it's what

423
00:22:00,570 --> 00:22:02,929
concurrency protocol you're going to use

424
00:22:02,929 --> 00:22:05,159
how you're going to maintain and store

425
00:22:05,159 --> 00:22:07,019
the different versions which relates to

426
00:22:07,019 --> 00:22:09,320
the question that was previously asked

427
00:22:09,320 --> 00:22:11,490
how are you're going to clean up the old

428
00:22:11,490 --> 00:22:14,490
versions once they're not visible to any

429
00:22:14,490 --> 00:22:16,980
transactions anymore and how you're

430
00:22:16,980 --> 00:22:18,720
going to ensure that the indexes point

431
00:22:18,720 --> 00:22:24,779
to the correct version all right so the

432
00:22:24,779 --> 00:22:29,940
first thing we'll cover is a skip that

433
00:22:29,940 --> 00:22:32,220
one okay so that's what I thought okay

434
00:22:32,220 --> 00:22:33,419
so the first thing we're going to cover

435
00:22:33,419 --> 00:22:41,639
is concurrency control protocol right so

436
00:22:41,639 --> 00:22:45,149
this is basically I'm looking at the

437
00:22:45,149 --> 00:22:47,070
sorry I'm not used to this presenter

438
00:22:47,070 --> 00:22:50,299
view my bad okay

439
00:22:50,360 --> 00:22:52,590
concurrency control protocol this is

440
00:22:52,590 --> 00:22:55,019
this is our first consideration right

441
00:22:55,019 --> 00:22:58,919
for our design decisions so these are

442
00:22:58,919 --> 00:23:00,720
the concurrency control protocols that

443
00:23:00,720 --> 00:23:02,309
you guys have been studying for the past

444
00:23:02,309 --> 00:23:05,850
two weeks in the past two lectures and

445
00:23:05,850 --> 00:23:08,399
again when when you encounter a write

446
00:23:08,399 --> 00:23:10,230
write conflict you need to use one of

447
00:23:10,230 --> 00:23:12,389
these protocols whether it be two phase

448
00:23:12,389 --> 00:23:16,350
locking OCC or timestamp ordering to

449
00:23:16,350 --> 00:23:18,870
figure out which transaction should be

450
00:23:18,870 --> 00:23:21,360
allowed to write to that object and what

451
00:23:21,360 --> 00:23:23,730
isolation level you're running at so

452
00:23:23,730 --> 00:23:25,470
we're not going to go into much detail

453
00:23:25,470 --> 00:23:27,600
on this since you've just been covering

454
00:23:27,600 --> 00:23:31,080
it very recently so the next

455
00:23:31,080 --> 00:23:34,860
consideration is version storage so for

456
00:23:34,860 --> 00:23:35,370
virgin

457
00:23:35,370 --> 00:23:36,930
version storage what we need to do is

458
00:23:36,930 --> 00:23:39,690
figure out for two for a particular

459
00:23:39,690 --> 00:23:42,930
tuple version what should actually be

460
00:23:42,930 --> 00:23:45,360
visible to us right so let's assume for

461
00:23:45,360 --> 00:23:47,400
now that we're doing a sequential scan

462
00:23:47,400 --> 00:23:50,010
on the entire tainment bolt and we want

463
00:23:50,010 --> 00:23:52,650
to know where to find the version of a

464
00:23:52,650 --> 00:23:55,500
tuple that we want so the way we're

465
00:23:55,500 --> 00:23:57,090
going to implement this is we're going

466
00:23:57,090 --> 00:23:58,940
to maintain an internal pointer field

467
00:23:58,940 --> 00:24:02,370
that will allow us to find the previous

468
00:24:02,370 --> 00:24:04,730
or next version we'll go into that more

469
00:24:04,730 --> 00:24:08,100
for this particular logical tuple so you

470
00:24:08,100 --> 00:24:10,230
can think of this is sort of a linked

471
00:24:10,230 --> 00:24:14,070
list where you you know you can jump on

472
00:24:14,070 --> 00:24:16,740
into you jump on it and land on the head

473
00:24:16,740 --> 00:24:20,790
and then you can follow the the pointers

474
00:24:20,790 --> 00:24:22,590
in the linked list to find all of the

475
00:24:22,590 --> 00:24:24,510
different versions they're currently

476
00:24:24,510 --> 00:24:27,260
being maintained

477
00:24:28,790 --> 00:24:32,370
so indexes always point to the head of

478
00:24:32,370 --> 00:24:39,540
the chain and oh my I did it again I'm

479
00:24:39,540 --> 00:24:47,780
so sorry okay technical difficulties

480
00:24:51,920 --> 00:24:56,760
alright so um indexes like it says here

481
00:24:56,760 --> 00:24:57,809
will always point to the head of the

482
00:24:57,809 --> 00:24:59,610
chain whether the head is the oldest

483
00:24:59,610 --> 00:25:01,770
version that the newest version of that

484
00:25:01,770 --> 00:25:04,980
tuple depends on the implementation so

485
00:25:04,980 --> 00:25:07,380
there's different approaches determine

486
00:25:07,380 --> 00:25:08,820
how we're going to store these different

487
00:25:08,820 --> 00:25:13,429
versions so we'll go more into that next

488
00:25:18,830 --> 00:25:21,510
so the persons simplest approach is

489
00:25:21,510 --> 00:25:25,340
called append-only storage all right so

490
00:25:25,340 --> 00:25:28,380
this just means that every time we

491
00:25:28,380 --> 00:25:31,020
create a new version we just copy the

492
00:25:31,020 --> 00:25:34,470
old version as a new physical tuple in

493
00:25:34,470 --> 00:25:38,040
our tablespace and update it so then we

494
00:25:38,040 --> 00:25:40,260
update pointers to say here's the next

495
00:25:40,260 --> 00:25:41,550
version and we're going to go over

496
00:25:41,550 --> 00:25:43,440
examples of all three of these in the

497
00:25:43,440 --> 00:25:47,070
next few slides so the next approach is

498
00:25:47,070 --> 00:25:48,570
called

499
00:25:48,570 --> 00:25:50,460
time travel storage and this is where

500
00:25:50,460 --> 00:25:54,900
you have one master version table that

501
00:25:54,900 --> 00:25:56,970
there's always during the latest version

502
00:25:56,970 --> 00:26:01,020
of the object or tuple then you copy out

503
00:26:01,020 --> 00:26:03,570
older versions into a separate table

504
00:26:03,570 --> 00:26:05,370
that we're going to call the time travel

505
00:26:05,370 --> 00:26:07,770
table and then at that point you just

506
00:26:07,770 --> 00:26:09,780
maintain the pointers from the master

507
00:26:09,780 --> 00:26:11,190
version of the table with the latest

508
00:26:11,190 --> 00:26:14,130
tuples to the tribe to the time travel

509
00:26:14,130 --> 00:26:18,090
table and so the last approach which is

510
00:26:18,090 --> 00:26:20,820
the one andy prefers and things as best

511
00:26:20,820 --> 00:26:23,850
is called delta storage so you can think

512
00:26:23,850 --> 00:26:27,510
of this as a dips and get we're instead

513
00:26:27,510 --> 00:26:30,390
of just copying the old version every

514
00:26:30,390 --> 00:26:31,800
single time and updating it you're just

515
00:26:31,800 --> 00:26:34,140
going to maintain you know a small delta

516
00:26:34,140 --> 00:26:37,320
of the modifications from the previous

517
00:26:37,320 --> 00:26:40,950
version so well first go over in an

518
00:26:40,950 --> 00:26:44,160
example of the append-only storage so

519
00:26:44,160 --> 00:26:45,720
again this is the simplest approach and

520
00:26:45,720 --> 00:26:48,960
this is also what Postgres uses so each

521
00:26:48,960 --> 00:26:52,080
new physical version is just a tuple is

522
00:26:52,080 --> 00:26:55,860
just a new tuple in the main table so

523
00:26:55,860 --> 00:26:57,810
let's say we have a transaction here

524
00:26:57,810 --> 00:27:01,160
that wants to update object a right so

525
00:27:01,160 --> 00:27:03,120
the first thing that's going to do is

526
00:27:03,120 --> 00:27:06,540
it's going to find an empty slot in the

527
00:27:06,540 --> 00:27:09,540
tablespace and then copy the values from

528
00:27:09,540 --> 00:27:11,790
the current value of a which is a 1 all

529
00:27:11,790 --> 00:27:13,670
right that's the most recent value I

530
00:27:13,670 --> 00:27:19,410
into that table saw it and then next

531
00:27:19,410 --> 00:27:21,830
it's going to copy the modified value

532
00:27:21,830 --> 00:27:26,760
into that table saw it and are we done

533
00:27:26,760 --> 00:27:27,600
yet not quite

534
00:27:27,600 --> 00:27:29,400
the final thing we need to actually do

535
00:27:29,400 --> 00:27:33,200
is update the pointer to point from the

536
00:27:33,200 --> 00:27:36,630
older version to the newest version that

537
00:27:36,630 --> 00:27:39,590
we currently installed

538
00:27:44,180 --> 00:27:47,269
[Music]

539
00:27:50,110 --> 00:27:52,850
okay so another aspect we must consider

540
00:27:52,850 --> 00:27:55,730
your in order to store this version so

541
00:27:55,730 --> 00:28:01,610
Oh in this example we a is considered

542
00:28:01,610 --> 00:28:06,740
the head of the Virgin chain and in this

543
00:28:06,740 --> 00:28:08,810
example we're specifically ordering

544
00:28:08,810 --> 00:28:11,780
these oldest to youngest right so an

545
00:28:11,780 --> 00:28:14,150
alternative would be you can order them

546
00:28:14,150 --> 00:28:20,300
youngest to oldest so if you if you're

547
00:28:20,300 --> 00:28:21,710
looking for the newest tuple in this

548
00:28:21,710 --> 00:28:26,660
case you actually you you get to the

549
00:28:26,660 --> 00:28:28,400
point of where your get to version a

550
00:28:28,400 --> 00:28:30,080
zero and again you have to follow the

551
00:28:30,080 --> 00:28:31,820
pointers all the way down to the newest

552
00:28:31,820 --> 00:28:40,030
version a to some exams all right so um

553
00:28:40,030 --> 00:28:43,580
so like I just said the previous example

554
00:28:43,580 --> 00:28:46,160
used oldest to newest but you could also

555
00:28:46,160 --> 00:28:47,360
use newest to oldest

556
00:28:47,360 --> 00:28:49,880
and there's performance implications and

557
00:28:49,880 --> 00:28:51,980
trade offs for both of them right so

558
00:28:51,980 --> 00:28:56,290
with oldest to newest all you need to do

559
00:28:56,290 --> 00:28:59,840
when there's a new version is to just

560
00:28:59,840 --> 00:29:01,940
append to the end of the version chain

561
00:29:01,940 --> 00:29:04,370
right this is very simple append the new

562
00:29:04,370 --> 00:29:07,400
tuple and update the pointer to point to

563
00:29:07,400 --> 00:29:09,380
the the newer version from the older

564
00:29:09,380 --> 00:29:12,170
version to the newer version and this is

565
00:29:12,170 --> 00:29:17,060
a really easy operation to do but if you

566
00:29:17,060 --> 00:29:19,940
do newest to oldest then what this means

567
00:29:19,940 --> 00:29:22,690
is that you have to add the entry and

568
00:29:22,690 --> 00:29:25,220
update its pointer to point to the old

569
00:29:25,220 --> 00:29:27,530
head right but now you have to actually

570
00:29:27,530 --> 00:29:30,740
update all of the indexes to point to

571
00:29:30,740 --> 00:29:32,210
your new version so it's again like we

572
00:29:32,210 --> 00:29:36,200
said a few slides ago indexes always

573
00:29:36,200 --> 00:29:38,120
point to the head of the version chain

574
00:29:38,120 --> 00:29:40,040
right so this means a lot more updates

575
00:29:40,040 --> 00:29:45,890
in some cases alright so for

576
00:29:45,890 --> 00:29:48,530
time-travels storage this is the next

577
00:29:48,530 --> 00:29:50,600
approach we'll cover and here we're

578
00:29:50,600 --> 00:29:52,190
going to have a main table that always

579
00:29:52,190 --> 00:29:53,720
has to lay this version of each tuple

580
00:29:53,720 --> 00:29:57,410
and then we'll have another table called

581
00:29:57,410 --> 00:29:58,620
the time travel table

582
00:29:58,620 --> 00:30:01,080
and this is where we're going to

583
00:30:01,080 --> 00:30:03,720
maintain older versions and copy older

584
00:30:03,720 --> 00:30:05,790
versions as they get modified in the

585
00:30:05,790 --> 00:30:09,870
database right so for this example let's

586
00:30:09,870 --> 00:30:11,430
say the transaction wants to update

587
00:30:11,430 --> 00:30:15,330
object a again same as last example then

588
00:30:15,330 --> 00:30:18,180
we're going to copy a 2 into the free

589
00:30:18,180 --> 00:30:21,809
spot in the time travel table and then

590
00:30:21,809 --> 00:30:23,850
update the version pointer to point to

591
00:30:23,850 --> 00:30:28,140
the oldest version of tuple a then we're

592
00:30:28,140 --> 00:30:30,180
going to overwrite the master version in

593
00:30:30,180 --> 00:30:31,800
the main table to be the new version

594
00:30:31,800 --> 00:30:37,309
value and finally we need to update the

595
00:30:37,309 --> 00:30:40,350
air diversion by and then finally we

596
00:30:40,350 --> 00:30:42,510
need to update the pointer to point from

597
00:30:42,510 --> 00:30:46,290
the new version a3 to the version that

598
00:30:46,290 --> 00:30:47,730
we just installed in the time travel

599
00:30:47,730 --> 00:31:05,520
table which is a 2 yes it would be an

600
00:31:05,520 --> 00:31:13,950
append table all right so now we'll move

601
00:31:13,950 --> 00:31:18,390
on to the the last approach that we're

602
00:31:18,390 --> 00:31:20,280
going to consider which is Delta storage

603
00:31:20,280 --> 00:31:23,370
which again this is used by both my

604
00:31:23,370 --> 00:31:25,470
sequel and Oracle and like I mentioned

605
00:31:25,470 --> 00:31:27,960
it's the one Andy thinks is the best

606
00:31:27,960 --> 00:31:31,200
option so what's gonna happen here is

607
00:31:31,200 --> 00:31:32,610
every time you do an update you're just

608
00:31:32,610 --> 00:31:34,620
going to copy the values that were

609
00:31:34,620 --> 00:31:37,140
modified into this separate Delta

610
00:31:37,140 --> 00:31:39,679
storage segment that you see over here

611
00:31:39,679 --> 00:31:44,490
so to update a we're first going to

612
00:31:44,490 --> 00:31:50,160
update its version value into the Delta

613
00:31:50,160 --> 00:31:51,840
storage right so we're gonna copy over

614
00:31:51,840 --> 00:31:53,730
its value so instead of storing the

615
00:31:53,730 --> 00:31:55,410
entire tuple we're just going to call

616
00:31:55,410 --> 00:31:57,660
we're just going to create a delta the

617
00:31:57,660 --> 00:32:00,510
States you know which part which

618
00:32:00,510 --> 00:32:02,280
attributes and the tuple were actually

619
00:32:02,280 --> 00:32:05,220
modified so in this case there's one

620
00:32:05,220 --> 00:32:08,820
attribute so that that was now reflected

621
00:32:08,820 --> 00:32:12,000
in the Delta storage segment

622
00:32:12,000 --> 00:32:13,380
then we're going to update the actual

623
00:32:13,380 --> 00:32:16,980
value in the main table and also update

624
00:32:16,980 --> 00:32:20,220
the pointer from the new value into our

625
00:32:20,220 --> 00:32:24,600
Delta storage so similarly if we uh if

626
00:32:24,600 --> 00:32:28,830
we want to now install a new value and

627
00:32:28,830 --> 00:32:31,650
new version then we need to do something

628
00:32:31,650 --> 00:32:33,810
similar to the time travel table

629
00:32:33,810 --> 00:32:36,960
scenario which is specifically we append

630
00:32:36,960 --> 00:32:39,390
the new version update the value again

631
00:32:39,390 --> 00:32:41,370
and now we're seeing its version a3

632
00:32:41,370 --> 00:32:45,270
right but we have but we also need to

633
00:32:45,270 --> 00:32:48,720
update the pointer from a3 to now point

634
00:32:48,720 --> 00:32:50,550
to the most current value of a2 and

635
00:32:50,550 --> 00:32:52,290
additionally we need to update the

636
00:32:52,290 --> 00:32:55,080
pointer of a2 to the point to the older

637
00:32:55,080 --> 00:32:56,910
version now anyone Tim is the time

638
00:32:56,910 --> 00:33:07,140
travel example so when you want to read

639
00:33:07,140 --> 00:33:09,480
an old version well you really what you

640
00:33:09,480 --> 00:33:11,610
essentially have to do is you have to

641
00:33:11,610 --> 00:33:15,380
replay the deltas to put the tuple back

642
00:33:15,380 --> 00:33:18,990
into its original form so in this case

643
00:33:18,990 --> 00:33:22,350
if we wanted to if we wanted to read a 1

644
00:33:22,350 --> 00:33:25,470
we would start with the value of a3 and

645
00:33:25,470 --> 00:33:27,360
then we would follow the pointer that a

646
00:33:27,360 --> 00:33:31,200
to apply the delta and a2 and then apply

647
00:33:31,200 --> 00:33:32,970
the Delta 1 and that would get us back

648
00:33:32,970 --> 00:33:39,270
to the original value so this is another

649
00:33:39,270 --> 00:33:41,670
good example of the trade-offs between

650
00:33:41,670 --> 00:33:44,820
reads and writes so reading old versions

651
00:33:44,820 --> 00:33:47,550
and the append-only approach is really

652
00:33:47,550 --> 00:33:49,290
easy which is one nice thing about it

653
00:33:49,290 --> 00:33:52,590
it's easy to implement right because you

654
00:33:52,590 --> 00:33:56,160
just find the version and the tuple is

655
00:33:56,160 --> 00:33:57,870
already ready to be turn so in addition

656
00:33:57,870 --> 00:33:59,940
to being easy to implement you also

657
00:33:59,940 --> 00:34:01,560
don't have to put the tuple back

658
00:34:01,560 --> 00:34:03,870
together you don't have to apply Delta's

659
00:34:03,870 --> 00:34:06,930
to get it back to its correct state but

660
00:34:06,930 --> 00:34:08,760
with Delta storage rights are going to

661
00:34:08,760 --> 00:34:10,889
be much faster because we don't have to

662
00:34:10,889 --> 00:34:13,710
copy the entire tuple if we only make a

663
00:34:13,710 --> 00:34:16,440
change to a subset of the attributes so

664
00:34:16,440 --> 00:34:18,000
you know if you just have one attribute

665
00:34:18,000 --> 00:34:20,040
like we do here this is you know clearly

666
00:34:20,040 --> 00:34:22,770
a trivial optimization but in many

667
00:34:22,770 --> 00:34:24,030
tables you

668
00:34:24,030 --> 00:34:27,870
might have you know dozens of columns in

669
00:34:27,870 --> 00:34:35,580
which case this can matter a lot but

670
00:34:35,580 --> 00:34:38,360
again yes with the Delta storage the

671
00:34:38,360 --> 00:34:42,480
that is the benefit but the disadvantage

672
00:34:42,480 --> 00:34:44,520
is that you have to replay the deltas

673
00:34:44,520 --> 00:34:46,710
again to put the tubule back together

674
00:34:46,710 --> 00:34:50,520
into its correct value so one take away

675
00:34:50,520 --> 00:34:52,020
you can go from this is like we

676
00:34:52,020 --> 00:34:56,699
mentioned earlier Postgres Postgres will

677
00:34:56,699 --> 00:35:05,370
be faster for reads right because well

678
00:35:05,370 --> 00:35:07,440
post course will be faster for reads and

679
00:35:07,440 --> 00:35:10,350
the and my sequel B will be faster for

680
00:35:10,350 --> 00:35:18,030
writes for this exact reason alright so

681
00:35:18,030 --> 00:35:19,680
the third thing that we need to know

682
00:35:19,680 --> 00:35:22,760
about on our list is garbage collection

683
00:35:22,760 --> 00:35:24,960
so all of these old versions are

684
00:35:24,960 --> 00:35:27,180
accumulating as transactions are running

685
00:35:27,180 --> 00:35:29,820
and finishing and at some point we know

686
00:35:29,820 --> 00:35:32,430
that the particular version is not being

687
00:35:32,430 --> 00:35:35,070
is not visible to any other active

688
00:35:35,070 --> 00:35:37,880
transactions right so what this means is

689
00:35:37,880 --> 00:35:40,890
if you're thinking about the table with

690
00:35:40,890 --> 00:35:42,860
the begin and end time stamps and the

691
00:35:42,860 --> 00:35:45,120
time stamp version it means that there

692
00:35:45,120 --> 00:35:47,610
are no active transactions with a time

693
00:35:47,610 --> 00:35:49,560
stamps that fit between that begin and

694
00:35:49,560 --> 00:35:52,430
end range right of from older versions

695
00:35:52,430 --> 00:35:55,170
so at this point we want to go ahead and

696
00:35:55,170 --> 00:35:57,600
garbage collect these versions in order

697
00:35:57,600 --> 00:36:02,310
to reclaim space so two additional

698
00:36:02,310 --> 00:36:04,110
things that we have to worry about are

699
00:36:04,110 --> 00:36:05,460
how we're going to look for expired

700
00:36:05,460 --> 00:36:08,490
versions and when it's safe to reclaim

701
00:36:08,490 --> 00:36:11,940
them so these are topics that we're not

702
00:36:11,940 --> 00:36:13,500
going to cover in this class but they

703
00:36:13,500 --> 00:36:15,360
are covered in the advanced class if you

704
00:36:15,360 --> 00:36:19,890
do choose to take it so there's two

705
00:36:19,890 --> 00:36:25,770
approaches that so these two approaches

706
00:36:25,770 --> 00:36:28,770
that we're going to look at specifically

707
00:36:28,770 --> 00:36:31,110
the first one is tuple level garbage

708
00:36:31,110 --> 00:36:32,610
collection and the second one is

709
00:36:32,610 --> 00:36:35,760
transaction level so tuple level means

710
00:36:35,760 --> 00:36:37,590
that we're essentially going to do sick

711
00:36:37,590 --> 00:36:40,440
you'll see ants on our tables and use

712
00:36:40,440 --> 00:36:42,540
the version timestamps and set of active

713
00:36:42,540 --> 00:36:44,490
transactions to figure out whether the

714
00:36:44,490 --> 00:36:48,150
version is expired and if it is then we

715
00:36:48,150 --> 00:36:50,490
go ahead and prune it so the reason why

716
00:36:50,490 --> 00:36:52,580
this is actually complicated is because

717
00:36:52,580 --> 00:36:54,870
we not only do we have to actually look

718
00:36:54,870 --> 00:36:57,120
at the pages in memory but we also need

719
00:36:57,120 --> 00:36:59,610
to look at the pages that we've swapped

720
00:36:59,610 --> 00:37:02,670
out to disk because again we want to

721
00:37:02,670 --> 00:37:05,490
vacuum everything right so we'll go for

722
00:37:05,490 --> 00:37:08,030
a vacuum background vacuuming and

723
00:37:08,030 --> 00:37:10,050
cooperative cleaning in the next slide

724
00:37:10,050 --> 00:37:13,740
so the second approach is transaction

725
00:37:13,740 --> 00:37:15,330
level which we're really not going to go

726
00:37:15,330 --> 00:37:18,480
into much detail about but the general

727
00:37:18,480 --> 00:37:20,430
idea is that you have transactions that

728
00:37:20,430 --> 00:37:23,340
maintain their readwrite sets and you

729
00:37:23,340 --> 00:37:26,100
know when they commit so the versions

730
00:37:26,100 --> 00:37:29,760
are right so in this case you have the

731
00:37:29,760 --> 00:37:31,890
transactions again they're maintaining

732
00:37:31,890 --> 00:37:34,320
the rewrites that we read write set so

733
00:37:34,320 --> 00:37:35,940
you know exactly when they commit and

734
00:37:35,940 --> 00:37:37,980
thus you can figure out when they're no

735
00:37:37,980 --> 00:37:42,810
longer visible and can vacuum them so

736
00:37:42,810 --> 00:37:44,610
the first will first go over an example

737
00:37:44,610 --> 00:37:47,010
of how a tuple level garbage collection

738
00:37:47,010 --> 00:37:50,340
works so let's say we have two threads

739
00:37:50,340 --> 00:37:54,950
running in the system where so

740
00:37:54,950 --> 00:37:57,480
transaction t1 is assigned the time

741
00:37:57,480 --> 00:38:00,150
stamp of 12 and transaction t2 is

742
00:38:00,150 --> 00:38:02,880
assigned a tenth time stamp of 25 and

743
00:38:02,880 --> 00:38:04,680
then over in our version table you can

744
00:38:04,680 --> 00:38:07,440
see we have opposite object a which is

745
00:38:07,440 --> 00:38:10,620
assigned version 100 has a begin time

746
00:38:10,620 --> 00:38:12,660
stamp of 1 and an end time stamp of 9

747
00:38:12,660 --> 00:38:14,970
and then we have a few other versions in

748
00:38:14,970 --> 00:38:20,220
there for object B so with vacuum

749
00:38:20,220 --> 00:38:22,530
background vacuuming what we're going to

750
00:38:22,530 --> 00:38:26,280
do is we have sort of a set of threads

751
00:38:26,280 --> 00:38:27,900
that run in the backroom and they

752
00:38:27,900 --> 00:38:30,480
perform this vacuuming where they

753
00:38:30,480 --> 00:38:32,670
periodically just do a full table scan

754
00:38:32,670 --> 00:38:36,900
of the table and look for which versions

755
00:38:36,900 --> 00:38:41,250
our reclaim Abul and it works with any

756
00:38:41,250 --> 00:38:45,570
type of storage here so

757
00:38:45,570 --> 00:38:49,560
for background so here see HIPAA

758
00:38:49,560 --> 00:38:50,820
background thread

759
00:38:50,820 --> 00:38:54,030
there goes into the to goes to the

760
00:38:54,030 --> 00:38:57,330
transaction thread in and says what and

761
00:38:57,330 --> 00:38:59,390
it basically queries what the current

762
00:38:59,390 --> 00:39:01,560
transaction timestamps are so in this

763
00:39:01,560 --> 00:39:06,150
case it's gonna be 12 and 25 right then

764
00:39:06,150 --> 00:39:08,040
it's going to do a sequential scan on

765
00:39:08,040 --> 00:39:11,640
the table to figure out whether the

766
00:39:11,640 --> 00:39:14,910
tuples would ever be visible to them all

767
00:39:14,910 --> 00:39:19,640
right so with a 100 be visible to them

768
00:39:21,290 --> 00:39:23,400
hard to say because we don't know yet

769
00:39:23,400 --> 00:39:32,850
what they're reading or writing but oh I

770
00:39:32,850 --> 00:39:35,810
see okay sorry let me back up so again

771
00:39:35,810 --> 00:39:38,430
sorry in this example we're just looking

772
00:39:38,430 --> 00:39:40,320
at the time stay at the beginning and

773
00:39:40,320 --> 00:39:44,870
timestamps here so here we gather the

774
00:39:44,870 --> 00:39:48,150
timestamps of 12 and 25 from these two

775
00:39:48,150 --> 00:39:50,490
transactions and then we again look at

776
00:39:50,490 --> 00:39:53,040
the beginning and end timestamp so they

777
00:39:53,040 --> 00:39:55,860
will never be able to use a 100 or B 100

778
00:39:55,860 --> 00:39:57,420
because the timestamp does not fall

779
00:39:57,420 --> 00:40:01,260
between 1 and 9 whereas they do follow

780
00:40:01,260 --> 00:40:03,870
well the timestamp of transaction t1

781
00:40:03,870 --> 00:40:05,880
falls between 10 and 20 so I could

782
00:40:05,880 --> 00:40:11,700
potentially use that that value and at

783
00:40:11,700 --> 00:40:13,860
this point we know those two tuples are

784
00:40:13,860 --> 00:40:16,760
safe to reclaim so we go ahead and do so

785
00:40:16,760 --> 00:40:29,310
um so one optimization here well one

786
00:40:29,310 --> 00:40:30,990
obvious optimization here that we can do

787
00:40:30,990 --> 00:40:34,860
is we can actually maintain a bitmap for

788
00:40:34,860 --> 00:40:37,590
dirty pages and so anytime you modify it

789
00:40:37,590 --> 00:40:39,900
you can just flip the bit of the page

790
00:40:39,900 --> 00:40:42,090
that you modified so again we're meaning

791
00:40:42,090 --> 00:40:44,550
we're maintaining a bitmap for all of

792
00:40:44,550 --> 00:40:46,190
the pages in the database pages

793
00:40:46,190 --> 00:40:49,260
specifically if we modify a page we'll

794
00:40:49,260 --> 00:40:51,930
flip that particular bit which indicates

795
00:40:51,930 --> 00:40:56,310
that that page is dirty so this you know

796
00:40:56,310 --> 00:40:58,200
takes a little bit extra storage but

797
00:40:58,200 --> 00:40:59,099
it's just a single

798
00:40:59,099 --> 00:41:02,279
for all of the pages in the database and

799
00:41:02,279 --> 00:41:04,920
anytime you want it in so when the

800
00:41:04,920 --> 00:41:06,690
vacuumer comes around it immediately

801
00:41:06,690 --> 00:41:08,940
knows which pages it actually needs to

802
00:41:08,940 --> 00:41:10,950
vacuum right so it will go ahead and

803
00:41:10,950 --> 00:41:12,989
vacuum that page and then reset the bit

804
00:41:12,989 --> 00:41:19,829
to zero so vacuum vacuuming again is

805
00:41:19,829 --> 00:41:23,220
typically ran as sort of a cron job that

806
00:41:23,220 --> 00:41:26,519
runs periodically but in some database

807
00:41:26,519 --> 00:41:29,400
systems for example Postgres you can

808
00:41:29,400 --> 00:41:32,720
actually invoke vacuum manually from the

809
00:41:32,720 --> 00:41:36,720
from the sequel prompt for example and

810
00:41:36,720 --> 00:41:39,720
it also has configuration parameters

811
00:41:39,720 --> 00:41:42,989
that you can set such that it will the

812
00:41:42,989 --> 00:41:44,970
system will basically start up a vacuum

813
00:41:44,970 --> 00:41:50,130
thread if it if over you know 20% of the

814
00:41:50,130 --> 00:41:52,410
pages are dirty for example so there's

815
00:41:52,410 --> 00:41:54,119
different way to implement this there's

816
00:41:54,119 --> 00:41:55,739
different ways to optimize it for

817
00:41:55,739 --> 00:42:05,999
different workloads okay so the other

818
00:42:05,999 --> 00:42:11,910
approach we're going to look at is

819
00:42:11,910 --> 00:42:14,369
cooperative cleaning alright so and this

820
00:42:14,369 --> 00:42:17,190
is basically where the threads as

821
00:42:17,190 --> 00:42:18,839
they're executing queries when they come

822
00:42:18,839 --> 00:42:21,779
across old versions that they know are

823
00:42:21,779 --> 00:42:24,599
not visible to anybody else it's their

824
00:42:24,599 --> 00:42:26,940
job to actually clean them up as they go

825
00:42:26,940 --> 00:42:29,130
along so again these are these are

826
00:42:29,130 --> 00:42:30,859
threats are actually executing

827
00:42:30,859 --> 00:42:34,769
transactions they and they're going to

828
00:42:34,769 --> 00:42:37,650
actually check the versions that they

829
00:42:37,650 --> 00:42:40,079
that they Traverse across whether those

830
00:42:40,079 --> 00:42:42,779
should be whether those are be whether

831
00:42:42,779 --> 00:42:44,599
that space is ready to be reclaimed

832
00:42:44,599 --> 00:42:47,099
because they're not visible to any

833
00:42:47,099 --> 00:42:49,049
transactions anymore and if it is they

834
00:42:49,049 --> 00:42:52,049
will go ahead and reclaim that space so

835
00:42:52,049 --> 00:42:55,890
one thing to note is if you consider the

836
00:42:55,890 --> 00:42:58,609
two orderings that we discussed earlier

837
00:42:58,609 --> 00:43:01,049
oldest to newest and newest to oldest

838
00:43:01,049 --> 00:43:04,920
would would this approach work for both

839
00:43:04,920 --> 00:43:10,130
of those no right when why is that

840
00:43:15,479 --> 00:43:18,099
that's it that's exactly right yeah so

841
00:43:18,099 --> 00:43:21,759
in the case of newest to oldest you're

842
00:43:21,759 --> 00:43:23,410
not going to be looking at any of the

843
00:43:23,410 --> 00:43:25,779
old transactions so you will actually

844
00:43:25,779 --> 00:43:28,299
never end up reclaiming those so it's

845
00:43:28,299 --> 00:43:30,009
important to note that a cooperative

846
00:43:30,009 --> 00:43:32,229
cleaning only works with oldest to

847
00:43:32,229 --> 00:43:35,469
newest ordering all right so now we'll

848
00:43:35,469 --> 00:43:37,779
just go through a similar example here

849
00:43:37,779 --> 00:43:41,769
so let's say that the wave in index in

850
00:43:41,769 --> 00:43:44,349
transaction t1 wants to do a look-up on

851
00:43:44,349 --> 00:43:49,569
object a now so it's gonna again it's

852
00:43:49,569 --> 00:43:52,089
going to land on the head of the version

853
00:43:52,089 --> 00:43:54,880
chain which is the oldest value and then

854
00:43:54,880 --> 00:43:56,440
it's going to scan along until it

855
00:43:56,440 --> 00:43:59,739
figures out which versions are actually

856
00:43:59,739 --> 00:44:03,039
visible to it so if it recognizes a

857
00:44:03,039 --> 00:44:06,459
version that it's looking if it

858
00:44:06,459 --> 00:44:07,959
recognizes that one of the versions that

859
00:44:07,959 --> 00:44:10,180
it's currently traversing it's not

860
00:44:10,180 --> 00:44:13,239
visible to any other transactions then

861
00:44:13,239 --> 00:44:14,650
we'll go ahead and mark them as deleted

862
00:44:14,650 --> 00:44:19,209
and reclaim the space and then at the

863
00:44:19,209 --> 00:44:23,170
very end of us also update the index to

864
00:44:23,170 --> 00:44:24,489
point to the new head of the version

865
00:44:24,489 --> 00:44:28,059
chain so we'll just go through these

866
00:44:28,059 --> 00:44:33,789
steps so here we find the value right

867
00:44:33,789 --> 00:44:37,410
and so we can see the version a one is

868
00:44:37,410 --> 00:44:43,569
can be reclaimed and then we reattach

869
00:44:43,569 --> 00:44:46,029
and then we recreate the pointer from

870
00:44:46,029 --> 00:44:48,459
the index to the new version head right

871
00:44:48,459 --> 00:44:51,910
so ordering is is actually important

872
00:44:51,910 --> 00:44:53,289
here and the ordering that's actually

873
00:44:53,289 --> 00:44:55,479
done on the that's actually on this

874
00:44:55,479 --> 00:44:59,319
slide is not quite correct so when you

875
00:44:59,319 --> 00:45:02,619
actually perform these operations what

876
00:45:02,619 --> 00:45:06,519
you would do first is actually update so

877
00:45:06,519 --> 00:45:08,079
the first thing you would do is mark

878
00:45:08,079 --> 00:45:10,420
them as deleted right but you're not

879
00:45:10,420 --> 00:45:12,400
actually reclaiming the space yet the

880
00:45:12,400 --> 00:45:13,930
next important thing is that you

881
00:45:13,930 --> 00:45:16,660
actually update the index pointer to

882
00:45:16,660 --> 00:45:19,239
point to a two before physically

883
00:45:19,239 --> 00:45:20,530
deleting them right

884
00:45:20,530 --> 00:45:23,650
claiming that space because otherwise if

885
00:45:23,650 --> 00:45:25,270
you have other transactions running

886
00:45:25,270 --> 00:45:28,240
concurrently they might find an empty

887
00:45:28,240 --> 00:45:43,120
pointer that points to nothing yes yes

888
00:45:43,120 --> 00:45:45,160
yeah essentially yeah so it's going to

889
00:45:45,160 --> 00:45:46,480
maintain some information so they can

890
00:45:46,480 --> 00:45:48,130
figure out so it's going to know the set

891
00:45:48,130 --> 00:45:50,140
of active transactions and be able to

892
00:45:50,140 --> 00:45:52,390
compare those timestamps with the begin

893
00:45:52,390 --> 00:45:54,700
and end time stamps that in the version

894
00:45:54,700 --> 00:46:02,790
table correct alright so again

895
00:46:02,790 --> 00:46:05,850
transaction level a garbage collection

896
00:46:05,850 --> 00:46:09,100
we here we just maintain the readwrite

897
00:46:09,100 --> 00:46:11,410
sets of transactions and we use them to

898
00:46:11,410 --> 00:46:13,000
figure out what versions are not visible

899
00:46:13,000 --> 00:46:14,710
anymore and then we claim the space and

900
00:46:14,710 --> 00:46:17,020
that's really all we're going to say

901
00:46:17,020 --> 00:46:20,800
about about transaction level garbage

902
00:46:20,800 --> 00:46:23,770
collection so any questions on garbage

903
00:46:23,770 --> 00:46:25,420
collection or anything else up until

904
00:46:25,420 --> 00:46:31,600
this point all right so now we're going

905
00:46:31,600 --> 00:46:35,680
to move on to the to our final topic in

906
00:46:35,680 --> 00:46:37,300
design decision which is index

907
00:46:37,300 --> 00:46:41,980
management so as I mentioned before the

908
00:46:41,980 --> 00:46:43,840
primary key index is always going to

909
00:46:43,840 --> 00:46:45,490
point to the head of the version chain

910
00:46:45,490 --> 00:46:47,890
anytime we create a new version version

911
00:46:47,890 --> 00:46:50,860
we have to update the version chain or

912
00:46:50,860 --> 00:46:53,860
we have to update well we have to update

913
00:46:53,860 --> 00:46:55,630
the index to point to the new heads at

914
00:46:55,630 --> 00:46:57,850
the version chain right so this gets

915
00:46:57,850 --> 00:47:00,040
tricky when updating the primary key

916
00:47:00,040 --> 00:47:03,250
because now it's it's actually possible

917
00:47:03,250 --> 00:47:04,780
that you could have two version chains

918
00:47:04,780 --> 00:47:08,530
for the same logical tuple the way you

919
00:47:08,530 --> 00:47:12,130
implement this is when if you want to

920
00:47:12,130 --> 00:47:14,440
delete the primary when you want to

921
00:47:14,440 --> 00:47:17,170
update the primary key you did this as a

922
00:47:17,170 --> 00:47:19,840
delete followed by an insert of a new

923
00:47:19,840 --> 00:47:22,090
logical tuple and there's some

924
00:47:22,090 --> 00:47:25,560
bookkeeping you need to maintain and and

925
00:47:25,560 --> 00:47:29,110
you also need to understand like how and

926
00:47:29,110 --> 00:47:31,600
when to rollback when necessary but for

927
00:47:31,600 --> 00:47:34,000
secondary indexes this is actually more

928
00:47:34,000 --> 00:47:34,479
calm

929
00:47:34,479 --> 00:47:38,319
complicated and this will be what we'll

930
00:47:38,319 --> 00:47:43,630
talk a little bit more about so with

931
00:47:43,630 --> 00:47:48,939
secondary indexes the two approaches we

932
00:47:48,939 --> 00:47:52,929
use to make sure that our indexes

933
00:47:52,929 --> 00:47:55,779
reflect the the correct value in the

934
00:47:55,779 --> 00:47:58,630
version chain are to maintain a logical

935
00:47:58,630 --> 00:48:01,059
pointer and here so here you have some

936
00:48:01,059 --> 00:48:02,890
kind of false identifier for the tuple

937
00:48:02,890 --> 00:48:05,170
or some kind of unique identifier for

938
00:48:05,170 --> 00:48:08,229
the tuple that does not change and then

939
00:48:08,229 --> 00:48:11,199
you have some layer of indirection an

940
00:48:11,199 --> 00:48:13,509
indirection layer that map's the logical

941
00:48:13,509 --> 00:48:15,549
ID to the physical location in the

942
00:48:15,549 --> 00:48:17,439
database and anytime you update the

943
00:48:17,439 --> 00:48:19,989
version chain you just have to update

944
00:48:19,989 --> 00:48:22,749
the indirection layer rather than

945
00:48:22,749 --> 00:48:25,660
actually updating every single index all

946
00:48:25,660 --> 00:48:28,689
right so the actual approach is I think

947
00:48:28,689 --> 00:48:30,429
it was I used in some of the slides

948
00:48:30,429 --> 00:48:32,799
earlier I think which is to actually use

949
00:48:32,799 --> 00:48:37,390
physical pointers which is when you just

950
00:48:37,390 --> 00:48:38,739
point directly to the head of a new

951
00:48:38,739 --> 00:48:40,660
version chain so every time the version

952
00:48:40,660 --> 00:48:42,699
chain gets updated you have to update

953
00:48:42,699 --> 00:48:46,569
every single index right so the

954
00:48:46,569 --> 00:48:48,849
difference between the physical between

955
00:48:48,849 --> 00:48:50,949
using physical pointers and logical is

956
00:48:50,949 --> 00:48:52,869
you basically have this indirection

957
00:48:52,869 --> 00:48:55,239
table and the benefit of the indirection

958
00:48:55,239 --> 00:48:57,369
table is that you do not have to update

959
00:48:57,369 --> 00:49:00,999
every single index every time you update

960
00:49:00,999 --> 00:49:07,959
your version chain so all right so in

961
00:49:07,959 --> 00:49:11,109
this example we'll say we have a simple

962
00:49:11,109 --> 00:49:13,630
database and we're using a pendant

963
00:49:13,630 --> 00:49:15,880
version chain which is running newest to

964
00:49:15,880 --> 00:49:22,869
oldest right so for the primary key

965
00:49:22,869 --> 00:49:24,819
index if I'm going to do a lookup on

966
00:49:24,819 --> 00:49:30,130
object a then this will just be a

967
00:49:30,130 --> 00:49:32,739
physical address right for the for the

968
00:49:32,739 --> 00:49:35,469
primary key which will be just a page ID

969
00:49:35,469 --> 00:49:37,119
and offset so you know which page to go

970
00:49:37,119 --> 00:49:38,890
to and then you take the offset that's

971
00:49:38,890 --> 00:49:40,839
typically what this is it's going to

972
00:49:40,839 --> 00:49:42,670
point again to the head of the version

973
00:49:42,670 --> 00:49:45,309
chain right and anytime you create a new

974
00:49:45,309 --> 00:49:48,049
version you always update that

975
00:49:48,049 --> 00:49:55,880
the primary team right all right so for

976
00:49:55,880 --> 00:49:58,099
secondary indexes again you could use

977
00:49:58,099 --> 00:50:01,219
the physical address but there's the

978
00:50:01,219 --> 00:50:03,979
same issue anytime you update the tuple

979
00:50:03,979 --> 00:50:05,689
you have to update the secondary index

980
00:50:05,689 --> 00:50:11,239
to point to this and and you know this

981
00:50:11,239 --> 00:50:13,429
is again like this is similar to some of

982
00:50:13,429 --> 00:50:17,059
the two sort of the Delta storage idea

983
00:50:17,059 --> 00:50:20,539
that we saw a few slides ago yes if you

984
00:50:20,539 --> 00:50:22,069
have one attribute or if you have one

985
00:50:22,069 --> 00:50:24,380
index or one secondary index then this

986
00:50:24,380 --> 00:50:27,679
is not a big deal but it's very common

987
00:50:27,679 --> 00:50:30,559
for OLTP databases in particular to have

988
00:50:30,559 --> 00:50:35,449
many to have many some secondary indexes

989
00:50:35,449 --> 00:50:39,559
on a single table so every time you

990
00:50:39,559 --> 00:50:41,479
update the version chain you have to

991
00:50:41,479 --> 00:50:44,239
update all of those secondary indexes

992
00:50:44,239 --> 00:50:47,079
which for OLTP you can imagine might be

993
00:50:47,079 --> 00:50:51,979
12 or you know a few dozen mmm um and

994
00:50:51,979 --> 00:50:54,619
this of course is expensive because for

995
00:50:54,619 --> 00:50:57,739
example if it's a B+ tree then you you

996
00:50:57,739 --> 00:50:59,390
know are traversing the B+ tree you're

997
00:50:59,390 --> 00:51:01,249
taking watches as you go and then

998
00:51:01,249 --> 00:51:05,299
finally you have to apply the update so

999
00:51:05,299 --> 00:51:08,479
again like we send the previous slide

1000
00:51:08,479 --> 00:51:11,239
instead of storing the physical address

1001
00:51:11,239 --> 00:51:13,400
in the secondary end index we're going

1002
00:51:13,400 --> 00:51:15,890
to look at two alternatives so the first

1003
00:51:15,890 --> 00:51:18,920
is to just store the primary key which

1004
00:51:18,920 --> 00:51:20,869
is literally just a copy of the primary

1005
00:51:20,869 --> 00:51:25,390
key as the value and the secondary index

1006
00:51:25,390 --> 00:51:34,640
first of all the dress here we go right

1007
00:51:34,640 --> 00:51:37,640
so here we're going to have the actual

1008
00:51:37,640 --> 00:51:38,719
value that we're going to store in the

1009
00:51:38,719 --> 00:51:40,549
secondary index is going to be a pointer

1010
00:51:40,549 --> 00:51:45,079
to the primary key index so now when you

1011
00:51:45,079 --> 00:51:47,660
want to find a tuple um you just get you

1012
00:51:47,660 --> 00:51:49,489
first got the primary key index either

1013
00:51:49,489 --> 00:51:52,699
the secondary index and then you do a

1014
00:51:52,699 --> 00:51:55,219
lookup on the primary key index just as

1015
00:51:55,219 --> 00:51:58,069
you would to figure out what the

1016
00:51:58,069 --> 00:52:00,510
physical address is and then every

1017
00:52:00,510 --> 00:52:02,370
proceeds as in the first example with

1018
00:52:02,370 --> 00:52:08,220
the physical address so anytime I update

1019
00:52:08,220 --> 00:52:09,780
the tuple and the head of the version

1020
00:52:09,780 --> 00:52:12,240
chain you can just update the primary

1021
00:52:12,240 --> 00:52:14,910
index and automatically updates all of

1022
00:52:14,910 --> 00:52:17,100
the secondary indexes right so this is

1023
00:52:17,100 --> 00:52:23,970
one example of logical pointers and this

1024
00:52:23,970 --> 00:52:27,480
is what my sequel does and Postgres

1025
00:52:27,480 --> 00:52:34,670
actually stores the physical address yes

1026
00:52:35,720 --> 00:52:37,380
um

1027
00:52:37,380 --> 00:52:39,900
a secondary index see if your your

1028
00:52:39,900 --> 00:52:43,380
primary key index right which stores

1029
00:52:43,380 --> 00:52:45,810
like the key for your immediate table so

1030
00:52:45,810 --> 00:52:49,950
your secondary index is going to I guess

1031
00:52:49,950 --> 00:52:59,670
be a reference to that case so yeah so

1032
00:52:59,670 --> 00:53:02,250
in this case so like if you so if you

1033
00:53:02,250 --> 00:53:06,090
have a table a right and the ID is your

1034
00:53:06,090 --> 00:53:09,990
primary key then maybe in table B you

1035
00:53:09,990 --> 00:53:14,370
have a reference to table a2 to table a

1036
00:53:14,370 --> 00:53:16,770
dolt IV right a the attribute column in

1037
00:53:16,770 --> 00:53:19,140
that table right and so you might create

1038
00:53:19,140 --> 00:53:20,670
a second this is what's called a

1039
00:53:20,670 --> 00:53:22,920
secondary index on that particular item

1040
00:53:22,920 --> 00:53:25,230
so if you want to think about something

1041
00:53:25,230 --> 00:53:27,090
more concrete you have a table of users

1042
00:53:27,090 --> 00:53:30,960
your user has an ID your user has a list

1043
00:53:30,960 --> 00:53:35,010
of items that it has purchased so for

1044
00:53:35,010 --> 00:53:36,600
each of those items you might store the

1045
00:53:36,600 --> 00:53:40,380
user's ID in it or you know something

1046
00:53:40,380 --> 00:53:43,460
that it's just typically used for truck

1047
00:53:43,460 --> 00:53:47,720
okay any other questions

1048
00:53:52,870 --> 00:53:57,170
hmm think of my beginning of him I said

1049
00:53:57,170 --> 00:54:00,140
here okay so the last approach which is

1050
00:54:00,140 --> 00:54:02,060
also another example of using a logical

1051
00:54:02,060 --> 00:54:05,930
ID is basically you just have some

1052
00:54:05,930 --> 00:54:08,630
synthetic values it's like a tuple ID so

1053
00:54:08,630 --> 00:54:10,790
this would typically be a cow you know

1054
00:54:10,790 --> 00:54:14,870
an incrementing counter to serve as the

1055
00:54:14,870 --> 00:54:17,330
tuple ID and then you have a hash table

1056
00:54:17,330 --> 00:54:19,660
that says how to map from that tuple ID

1057
00:54:19,660 --> 00:54:21,410
to the address

1058
00:54:21,410 --> 00:54:24,740
so so basically you're going to get the

1059
00:54:24,740 --> 00:54:26,660
tuple ID out of the secondary index

1060
00:54:26,660 --> 00:54:32,630
right buying a dress yes so you're going

1061
00:54:32,630 --> 00:54:34,160
to get the tuple idea of the secondary

1062
00:54:34,160 --> 00:54:37,070
index and then you're gonna and then

1063
00:54:37,070 --> 00:54:38,390
you're going to figure out where the

1064
00:54:38,390 --> 00:54:41,300
physical address is and then the hash

1065
00:54:41,300 --> 00:54:43,130
table here will point you to the

1066
00:54:43,130 --> 00:54:44,900
location of the physical address so you

1067
00:54:44,900 --> 00:54:50,300
can read that value and again similar to

1068
00:54:50,300 --> 00:54:53,600
the approach we looked at where we were

1069
00:54:53,600 --> 00:54:56,870
just storing the primary the primary key

1070
00:54:56,870 --> 00:55:00,470
index this is another example of logical

1071
00:55:00,470 --> 00:55:03,650
pointers which means that if each time

1072
00:55:03,650 --> 00:55:05,810
we have a new version or each time we

1073
00:55:05,810 --> 00:55:07,760
update the version chain we can actually

1074
00:55:07,760 --> 00:55:11,150
avoid having to update all of the

1075
00:55:11,150 --> 00:55:13,280
secondary index right so we the only

1076
00:55:13,280 --> 00:55:14,870
thing we have to update in this case is

1077
00:55:14,870 --> 00:55:19,160
the hash table and the pointers that

1078
00:55:19,160 --> 00:55:29,390
make sense all right so this table is

1079
00:55:29,390 --> 00:55:31,250
actually really interesting um so this

1080
00:55:31,250 --> 00:55:34,910
is a this is a table from a paper that

1081
00:55:34,910 --> 00:55:37,190
was published by Andy and a few other

1082
00:55:37,190 --> 00:55:39,830
students I think a couple years ago so

1083
00:55:39,830 --> 00:55:43,610
what they actually did is they looked at

1084
00:55:43,610 --> 00:55:45,500
a number of systems so they looked at

1085
00:55:45,500 --> 00:55:47,330
some older systems you know like Oracle

1086
00:55:47,330 --> 00:55:49,700
Postgres on my sequel and they also

1087
00:55:49,700 --> 00:55:51,950
looked at some much newer systems within

1088
00:55:51,950 --> 00:55:54,650
the past ten years so for example like

1089
00:55:54,650 --> 00:55:57,290
hyper and nuodb hyper would be an

1090
00:55:57,290 --> 00:55:59,870
example of an academic system so they

1091
00:55:59,870 --> 00:56:01,520
tried to get a variety of systems here

1092
00:56:01,520 --> 00:56:02,850
and

1093
00:56:02,850 --> 00:56:05,640
and the table lists which of these

1094
00:56:05,640 --> 00:56:08,070
design decisions each of these database

1095
00:56:08,070 --> 00:56:15,030
system makes so let's see if Andy has

1096
00:56:15,030 --> 00:56:20,220
any exciting things so I guess he says

1097
00:56:20,220 --> 00:56:23,480
the spoiler if you guys want the spoiler

1098
00:56:23,480 --> 00:56:27,300
is the or the take away the spoiler is

1099
00:56:27,300 --> 00:56:30,930
that Oracle and my sequel the way they

1100
00:56:30,930 --> 00:56:33,630
do in PC they actually found like Andy

1101
00:56:33,630 --> 00:56:35,250
and some students actually found this

1102
00:56:35,250 --> 00:56:38,570
way to be the fastest for OLTP workloads

1103
00:56:38,570 --> 00:56:41,370
specifically and actually found Postgres

1104
00:56:41,370 --> 00:56:43,980
to be the slowest although personally as

1105
00:56:43,980 --> 00:56:45,810
both the user of my sequel and Postgres

1106
00:56:45,810 --> 00:56:50,190
I like Postgres quite a bit but I'm also

1107
00:56:50,190 --> 00:56:53,100
not running you know commercial database

1108
00:56:53,100 --> 00:56:56,340
systems with the production workload

1109
00:56:56,340 --> 00:56:58,830
traces so you know once you get at that

1110
00:56:58,830 --> 00:57:00,960
scale it probably matters all well it

1111
00:57:00,960 --> 00:57:04,800
definitely matters a lot so okay so this

1112
00:57:04,800 --> 00:57:07,050
brings us to the conclusion so today

1113
00:57:07,050 --> 00:57:08,400
again we talked about multi-version

1114
00:57:08,400 --> 00:57:11,550
concurrency control and again as you

1115
00:57:11,550 --> 00:57:13,680
just saw in the past few slides there's

1116
00:57:13,680 --> 00:57:16,710
a lot more to this than just figuring

1117
00:57:16,710 --> 00:57:19,190
out you know what time stamps to assign

1118
00:57:19,190 --> 00:57:22,350
and what versions are visible to the

1119
00:57:22,350 --> 00:57:26,430
different transactions so you know of

1120
00:57:26,430 --> 00:57:27,450
course you need to figure out how to

1121
00:57:27,450 --> 00:57:29,220
store the versions how to update them

1122
00:57:29,220 --> 00:57:32,190
how to update the indexes correctly and

1123
00:57:32,190 --> 00:57:36,230
the other items that we covered here so

1124
00:57:36,230 --> 00:57:39,630
right for next class just to just as a

1125
00:57:39,630 --> 00:57:41,220
reminder don't come don't come to class

1126
00:57:41,220 --> 00:57:43,920
on Wednesday because nobody will be here

1127
00:57:43,920 --> 00:57:45,990
so you guys have next ones day off and

1128
00:57:45,990 --> 00:57:48,630
then I think the following week Andy

1129
00:57:48,630 --> 00:57:50,340
will probably be back although that's

1130
00:57:50,340 --> 00:57:53,100
not certain but we will start logging in

1131
00:57:53,100 --> 00:57:55,700
recovery Oh

1132
00:58:05,730 --> 00:58:07,290
[Music]

1133
00:58:07,290 --> 00:58:16,870
the next one will be son ricochet jelly

1134
00:58:16,870 --> 00:58:18,850
hit the deli for a boat one naturally

1135
00:58:18,850 --> 00:58:20,710
bless ya what rap is like the laser beam

1136
00:58:20,710 --> 00:58:22,900
the pawns in the bush say nice delicate

1137
00:58:22,900 --> 00:58:25,690
chain wrap the bottle of us a nice gold

1138
00:58:25,690 --> 00:58:27,790
don't feel like drinking head boney to

1139
00:58:27,790 --> 00:58:30,040
you drunk you can't cross the line and

1140
00:58:30,040 --> 00:58:31,720
if the sake don't know your phone can

1141
00:58:31,720 --> 00:58:34,380
tap a thing

