1
00:00:01,300 --> 00:00:05,129
[音乐]

2
00:00:05,200 --> 00:00:05,930
[鼓掌]

3
00:00:05,930 --> 00:00:08,630
[音乐]

4
00:00:08,630 --> 00:00:10,020
[鼓掌]

5
00:00:10,020 --> 00:00:11,840
[音乐]

6
00:00:11,840 --> 00:00:13,950
所以今天的课我们

7
00:00:13,950 --> 00:00:16,500
又要讲服务器端的逻辑执行了

8
00:00:16,500 --> 00:00:18,990


9
00:00:18,990 --> 00:00:23,660


10
00:00:23,660 --> 00:00:26,039
'我不确定那是什么，

11
00:00:26,039 --> 00:00:30,359
所以对于今天的讲座，这是一个

12
00:00:30,359 --> 00:00:33,600
我觉得非常有趣的话题，

13
00:00:33,600 --> 00:00:37,010
我认为这不是

14
00:00:37,010 --> 00:00:39,930


15
00:00:39,930 --> 00:00:41,760


16
00:00:41,760 --> 00:00:42,570
我们一直在谈论的构建一种现代高性能囚犯数据库的关键 关于整个

17
00:00:42,570 --> 00:00:46,520
学期，现在这样做是为了让

18
00:00:46,520 --> 00:00:49,079
人们知道扩展您的数据库

19
00:00:49,079 --> 00:00:51,449
系统并将其与更多

20
00:00:51,449 --> 00:00:54,600
不同类型的应用程序集成，所以

21
00:00:54,600 --> 00:00:55,940
这不是我们将要

22
00:00:55,940 --> 00:00:59,280
尝试支持的事情，因为我们希望

23
00:00:59,280 --> 00:01:00,449
您完全了解您 需要获得最佳

24
00:01:00,449 --> 00:01:01,770
性能，尽管它

25
00:01:01,770 --> 00:01:03,300
会帮助我们排除 UDS

26
00:01:03,300 --> 00:01:05,339
会有所帮助 这更多是关于

27
00:01:05,339 --> 00:01:06,960
数据库系统的可扩展性，但

28
00:01:06,960 --> 00:01:08,490
我们希望以一种非常聪明的方式做到这一点，

29
00:01:08,490 --> 00:01:11,760
所以对于今天的讲座，我们 是克

30
00:01:11,760 --> 00:01:13,170
首先开始讨论

31
00:01:13,170 --> 00:01:15,150
我所说的服务器端逻辑

32
00:01:15,150 --> 00:01:18,900
执行的背景，然后我们将重点讨论如何

33
00:01:18,900 --> 00:01:21,240
优化用户数据

34
00:01:21,240 --> 00:01:23,640
用户定义函数的性能，一种方法

35
00:01:23,640 --> 00:01:26,549
是使用的内联方法

36
00:01:26,549 --> 00:01:29,040
微软和

37
00:01:29,040 --> 00:01:30,840
你被分配阅读的欺诈论文，

38
00:01:30,840 --> 00:01:32,640
然后另一种

39
00:01:32,640 --> 00:01:35,130
方法是德国的一种更新方法，将 UDF

40
00:01:35,130 --> 00:01:37,920
再次转换为公用表表达式，这

41
00:01:37,920 --> 00:01:40,250
两种方法都是为了让 UDS 运行得更快，

42
00:01:40,250 --> 00:01:43,619
所以正如我所说的服务器端逻辑执行

43
00:01:43,619 --> 00:01:45,840
我认为这是一个有趣的话题，我曾经

44
00:01:45,840 --> 00:01:47,189
在介绍课上教过它，

45
00:01:47,189 --> 00:01:49,100
昨晚的审计我想可能是

46
00:01:49,100 --> 00:01:52,409
2018 年，不幸的是最后一次。 我们

47
00:01:52,409 --> 00:01:53,759
不得不把它删掉，所以这

48
00:01:53,759 --> 00:01:55,770
不是你在 CMU 工作

49
00:01:55,770 --> 00:01:57,810
过的你可能熟悉的东西，所以我们花

50
00:01:57,810 --> 00:01:59,430
了一点时间讨论你

51
00:01:59,430 --> 00:02:00,990
知道它是什么你知道我们实际上

52
00:02:00,990 --> 00:02:03,930
正在尝试在我们的 数据库系统，因此

53
00:02:03,930 --> 00:02:05,820
您必须对

54
00:02:05,820 --> 00:02:08,160
服务器端逻辑

55
00:02:08,160 --> 00:02:10,169
执行将为我们做什么的关键观察是，

56
00:02:10,169 --> 00:02:13,120
到目前为止，我们一直假设

57
00:02:13,120 --> 00:02:16,300
在我们的应用程序堆栈中存在这种清晰的划分或二分法

58
00:02:16,300 --> 00:02:19,239


59
00:02:19,239 --> 00:02:20,530
应用程序服务器和

60
00:02:20,530 --> 00:02:22,090
我们在数据库

61
00:02:22,090 --> 00:02:23,650
系统和数据库系统中执行的逻辑

62
00:02:23,650 --> 00:02:27,040
只会看到

63
00:02:27,040 --> 00:02:29,230
从我称之为

64
00:02:29,230 --> 00:02:32,950
会话式 API（如 JDBC 或 ODBC）的查询发送过来，

65
00:02:32,950 --> 00:02:35,470
就像我们在学期早期讨论的那样

66
00:02:35,470 --> 00:02:38,890
虽然

67
00:02:38,890 --> 00:02:41,830
这种方法的缺点是

68
00:02:41,830 --> 00:02:44,049
你会知道它是一个像震源查询这样的健谈的 API

69
00:02:44,049 --> 00:02:45,640
得到解决然后

70
00:02:45,640 --> 00:02:47,860
处理它并将结果发送

71
00:02:47,860 --> 00:02:49,510
回来所以我们看到了这个像这样的图表

72
00:02:49,510 --> 00:02:51,880
之前 n 我们

73
00:02:51,880 --> 00:02:54,160
在应用程序方面谈论 JDBC 或 ODBC

74
00:02:54,160 --> 00:02:56,860
这就是我们的程序本质上

75
00:02:56,860 --> 00:02:58,269
正确存在的地方，无论它是

76
00:02:58,269 --> 00:03:01,930
用 nodejs 还是 PHP 或 Django 编写的 你知道

77
00:03:01,930 --> 00:03:04,060
Python 应用程序就在这里是所有的

78
00:03:04,060 --> 00:03:05,950
业务逻辑或我们的程序的所有业务逻辑

79
00:03:05,950 --> 00:03:08,620
等等 我们开始事务，我们

80
00:03:08,620 --> 00:03:11,349
将调用 begin 然后我们将

81
00:03:11,349 --> 00:03:13,510
执行一个礼物给 Segal 保存并

82
00:03:13,510 --> 00:03:14,890
执行一些然后

83
00:03:14,890 --> 00:03:18,400
再次通过线路通过 ABC 或 JDBC 抛出的东西

84
00:03:18,400 --> 00:03:20,709
，这将

85
00:03:20,709 --> 00:03:22,540
运行我们已经讨论过的完整堆栈

86
00:03:22,540 --> 00:03:24,340
续集解析器优化器的计划

87
00:03:24,340 --> 00:03:26,760
，最终由于查询执行器，

88
00:03:26,760 --> 00:03:28,870
现在您可以使用准备好的语句，

89
00:03:28,870 --> 00:03:30,819
可能会跳过前两个或三个

90
00:03:30,819 --> 00:03:32,530
步骤，但最后您仍然

91
00:03:32,530 --> 00:03:34,540
要执行查询，那么现在

92
00:03:34,540 --> 00:03:36,670
数据系统 X 使用查询

93
00:03:36,670 --> 00:03:38,349
并将结果发回，然后现在

94
00:03:38,349 --> 00:03:40,750
应用程序服务器可以继续执行

95
00:03:40,750 --> 00:03:42,519
程序编写此续集调用是

96
00:03:42,519 --> 00:03:45,160
应用程序端的阻塞调用所以

97
00:03:45,160 --> 00:03:46,989
现在同时关闭并执行 e 一些或

98
00:03:46,989 --> 00:03:48,790
程序逻辑来处理

99
00:03:48,790 --> 00:03:50,620
它从后续查询中获得的任何结果，

100
00:03:50,620 --> 00:03:53,919
我们的数据库系统现在对于这个特定的连接是空闲的，

101
00:03:53,919 --> 00:03:55,540


102
00:03:55,540 --> 00:03:57,310
它是一个多线程系统或多

103
00:03:57,310 --> 00:03:59,650
进程系统，因此我们可以

104
00:03:59,650 --> 00:04:02,459
处理来自其他

105
00:04:02,459 --> 00:04:04,660
事务或其他事务的查询 您同时从

106
00:04:04,660 --> 00:04:06,579
其他连接中知道，但是

107
00:04:06,579 --> 00:04:09,310
对于我们

108
00:04:09,310 --> 00:04:10,359
将为这个特定

109
00:04:10,359 --> 00:04:13,239
连接维护的上下文句柄，它本质上是空闲的，这

110
00:04:13,239 --> 00:04:15,010
意味着

111
00:04:15,010 --> 00:04:17,320
如果我们使用

112
00:04:17,320 --> 00:04:19,450
两阶段锁定之类的东西，它运行在事务中 作为一个协议的并发

113
00:04:19,450 --> 00:04:22,060
你我们

114
00:04:22,060 --> 00:04:23,890
为这个 sequel 语句获得的锁

115
00:04:23,890 --> 00:04:26,320
现在是否只是被保存在服务器

116
00:04:26,320 --> 00:04:28,780
端，因为它正在等待下一个

117
00:04:28,780 --> 00:04:30,430
命令被告知这个特定事务会发生

118
00:04:30,430 --> 00:04:32,440
什么，而这个

119
00:04:32,440 --> 00:04:35,290
网络往返不是 便宜但你

120
00:04:35,290 --> 00:04:36,910
知道我们在同一台机器上运行的最佳情况，

121
00:04:36,910 --> 00:04:38,140
但这并不

122
00:04:38,140 --> 00:04:41,290
常见，通常你有一个服务

123
00:04:41,290 --> 00:04:42,790
重新应用程序 为数据库系统评估服务器，

124
00:04:42,790 --> 00:04:44,620
因为您可以对它们进行某种程度的

125
00:04:44,620 --> 00:04:47,350
独立扩展，所以也许您

126
00:04:47,350 --> 00:04:49,270
在机架单元的正

127
00:04:49,270 --> 00:04:52,090
上方，您知道应用程序服务器位于

128
00:04:52,090 --> 00:04:54,160
数据库服务器下方的一个单元

129
00:04:54,160 --> 00:04:55,840
和同一个机架上，但同样很漂亮

130
00:04:55,840 --> 00:04:58,870
不常见太高了所以这可能需要

131
00:04:58,870 --> 00:05:01,420
几毫秒来发送这个你

132
00:05:01,420 --> 00:05:03,220
知道这些来回并且谁知道

133
00:05:03,220 --> 00:05:04,480
这个程序日志需要多

134
00:05:04,480 --> 00:05:07,420
长时间来执行所以现在我们

135
00:05:07,420 --> 00:05:08,950
在这里完成程序逻辑之后也许我们

136
00:05:08,950 --> 00:05:10,450
做同样的事情我们退出 另一个后续

137
00:05:10,450 --> 00:05:12,310
查询发送它得到结果将它发送

138
00:05:12,310 --> 00:05:13,840
回来我们做一些更多的处理然后

139
00:05:13,840 --> 00:05:16,720
我们等待然后最终我们的

140
00:05:16,720 --> 00:05:19,120
应用程序说好的我们完成了我们发送

141
00:05:19,120 --> 00:05:21,910
一个提交消息然后我们可以释放

142
00:05:21,910 --> 00:05:24,220
任何锁或我们已经拥有的任何内存

143
00:05:24,220 --> 00:05:26,020
为这个交易分配

144
00:05:26,020 --> 00:05:28,450
我们所做的任何事情来维持我们打开这个连接的状态，

145
00:05:28,450 --> 00:05:29,500


146
00:05:29,500 --> 00:05:31,690
当我们得到承诺时，他们正在退出交易，

147
00:05:31,690 --> 00:05:34,300
我们终于可以

148
00:05:34,300 --> 00:05:37,300
开始清理事情了 我们

149
00:05:37,300 --> 00:05:38,320
今天要讨论的事情

150
00:05:38,320 --> 00:05:40,630
本质上是如何在这一侧采用该应用程序

151
00:05:40,630 --> 00:05:43,540
逻辑，现在将其移动

152
00:05:43,540 --> 00:05:45,640
到数据库系统中以避免

153
00:05:45,640 --> 00:05:48,610
这些往返，并让您

154
00:05:48,610 --> 00:05:50,770
知道事务需要更长的时间或

155
00:05:50,770 --> 00:05:52,630
我们正在执行的任何查询

156
00:05:52,630 --> 00:05:54,310
花更长的时间尝试将所有内容组合

157
00:05:54,310 --> 00:05:56,710
到一个假期调用中，

158
00:05:56,710 --> 00:05:58,900
我们可以只向数据库服务器发送一个请求，

159
00:05:58,900 --> 00:05:59,980
而不是

160
00:05:59,980 --> 00:06:02,740
来回发送到应用程序我们还将

161
00:06:02,740 --> 00:06:04,480
使用允许我们

162
00:06:04,480 --> 00:06:07,480
扩展数据库功能的逻辑

163
00:06:07,480 --> 00:06:10,420
系统因此在某些情况下，我们将能够

164
00:06:10,420 --> 00:06:15,090
执行某些类型的操作或

165
00:06:15,090 --> 00:06:18,760
过滤或我们在处理查询时执行的其他类型的步骤

166
00:06:18,760 --> 00:06:21,580
我们能够以

167
00:06:21,580 --> 00:06:22,990


168
00:06:22,990 --> 00:06:25,630
数据库系统的原始开发人员可能

169
00:06:25,630 --> 00:06:27,970
没有的方式执行此操作 您可能知道或可能不知道您

170
00:06:27,970 --> 00:06:31,300
再次提供支持，因此

171
00:06:31,300 --> 00:06:32,460
从中获得的好处是，

172
00:06:32,460 --> 00:06:35,590
因为我们要过去，我们可以

173
00:06:35,590 --> 00:06:37,390
减少往返次数，这将提高

174
00:06:37,390 --> 00:06:39,980
效率和我们的系统

175
00:06:39,980 --> 00:06:43,220
因为现在事务可以花费我们

176
00:06:43,220 --> 00:06:45,590
将在更短的时间内执行我们

177
00:06:45,590 --> 00:06:48,680
还将获得一些重用因为现在如果我

178
00:06:48,680 --> 00:06:51,170
在床上的床上有一些功能

179
00:06:51,170 --> 00:06:55,100
它在我的数据库系统上

180
00:06:55,100 --> 00:06:57,710
现在我有了我的网络应用程序

181
00:06:57,710 --> 00:07:00,050
将被移植到手机

182
00:07:00,050 --> 00:07:03,080
应用程序，而不是重写 PHP

183
00:07:03,080 --> 00:07:05,090
代码，我的 Web 应用程序现在变得很快，

184
00:07:05,090 --> 00:07:06,260
或者我在手机上使用的

185
00:07:06,260 --> 00:07:07,910
任何东西，就像我

186
00:07:07,910 --> 00:07:09,170
必须用来交互数据库

187
00:07:09,170 --> 00:07:12,380
系统和网站的应用程序逻辑一样 我必须将

188
00:07:12,380 --> 00:07:14,000
网络移植到手机

189
00:07:14,000 --> 00:07:16,280
应用程序，但是如果我可以将它嵌入

190
00:07:16,280 --> 00:07:19,160
到数据库系统中，那么现在可能

191
00:07:19,160 --> 00:07:21,710
在网站上执行的相同逻辑可以

192
00:07:21,710 --> 00:07:25,310


193
00:07:25,310 --> 00:07:26,750
再次在手机上执行取决于您

194
00:07:26,750 --> 00:07:28,400
应用程序堆栈一个设置 我做了它

195
00:07:28,400 --> 00:07:30,320
假设有一个逻辑运行它

196
00:07:30,320 --> 00:07:34,100
并在它们两个中都按下按钮

197
00:07:34,100 --> 00:07:36,200
那么这看起来像什么 所以一个例子

198
00:07:36,200 --> 00:07:37,700
我刚刚在这里展示的一个简单的表格

199
00:07:37,700 --> 00:07:39,800
我们可以采取整个

200
00:07:39,800 --> 00:07:43,130
tr  ansaction 逻辑，并以某种方式将其

201
00:07:43,130 --> 00:07:45,980
发送到数据库系统，它将被

202
00:07:45,980 --> 00:07:49,130
安装，然后调用它的能力

203
00:07:49,130 --> 00:07:52,520
将通过

204
00:07:52,520 --> 00:07:53,690
某种函数句柄公开，例如

205
00:07:53,690 --> 00:07:55,370
所谓的 proc，然后它接受

206
00:07:55,370 --> 00:07:57,830
任何你想要的输入参数 所以

207
00:07:57,830 --> 00:08:00,020
现在如果我想

208
00:08:00,020 --> 00:08:02,960
在我的应用程序中调用这个事务，我不会像

209
00:08:02,960 --> 00:08:04,880
以前那样来回执行，我只是

210
00:08:04,880 --> 00:08:06,710
使用这个调用或这个

211
00:08:06,710 --> 00:08:08,960
名为 call 的命令，所以我调用函数并

212
00:08:08,960 --> 00:08:10,850
传入我想要的任何参数

213
00:08:10,850 --> 00:08:13,370
函数我像 RPC 一样发送一个请求，

214
00:08:13,370 --> 00:08:14,030


215
00:08:14,030 --> 00:08:16,730
它执行提交，然后我

216
00:08:16,730 --> 00:08:20,120
得到结果，所以这样做的好处

217
00:08:20,120 --> 00:08:22,490
是它是一个往返并

218
00:08:22,490 --> 00:08:24,170
执行所有这些复杂的逻辑，

219
00:08:24,170 --> 00:08:26,630


220
00:08:26,630 --> 00:08:29,440
在这种情况下，它之前是多次往返 在这里，我用 call

221
00:08:29,440 --> 00:08:33,530
other 调用这可能是在 seagull

222
00:08:33,530 --> 00:08:35,360
stander 和其他数据库系统

223
00:08:35,360 --> 00:08:38,090
可能支持精确或执行 I 但

224
00:08:38,090 --> 00:08:41,690
基本思想是相同的所以这

225
00:08:41,690 --> 00:08:43,130
就是所谓的 strop a 癫痫发作与 t 他的

226
00:08:43,130 --> 00:08:45,590
想法是我们可以采用一大块

227
00:08:45,590 --> 00:08:50,000
逻辑并将其包装到

228
00:08:50,000 --> 00:08:52,160
过程调用中，然后我们可以

229
00:08:52,160 --> 00:08:53,720
独立

230
00:08:53,720 --> 00:08:57,980
于查询调用其他类型的嵌入式

231
00:08:57,980 --> 00:09:00,139
逻辑你能做我们今天关注的那些

232
00:09:00,139 --> 00:09:02,329
是用户定义的函数

233
00:09:02,329 --> 00:09:06,500
它的 UDF 附加到查询，因此您

234
00:09:06,500 --> 00:09:09,079
不能独立于查询调用 UDF

235
00:09:09,079 --> 00:09:10,160
它必须是选择

236
00:09:10,160 --> 00:09:12,350
插入更新或删除的一部分，其中存储

237
00:09:12,350 --> 00:09:15,410
过程可以是单独的触发器是

238
00:09:15,410 --> 00:09:18,939
一种在特定情况下调用函数的方法

239
00:09:18,939 --> 00:09:22,430
事件发生就像我

240
00:09:22,430 --> 00:09:25,100
更新表中的元组我可以

241
00:09:25,100 --> 00:09:27,529


242
00:09:27,529 --> 00:09:29,389
在更新之前或更新更新之后触发触发器

243
00:09:29,389 --> 00:09:31,579
，然后调用一些函数来

244
00:09:31,579 --> 00:09:34,160
做某事，所以假设我

245
00:09:34,160 --> 00:09:36,500
每次都想要 我

246
00:09:36,500 --> 00:09:38,360
想在另一个表中插入一个审计记录，

247
00:09:38,360 --> 00:09:40,069
这样我就可以

248
00:09:40,069 --> 00:09:41,329
在该表上放置一个触发器，以便在它

249
00:09:41,329 --> 00:09:44,060
更新时说随时跟踪

250
00:09:44,060 --> 00:09:46,579
另一个表中的更改 用户定义

251
00:09:46,579 --> 00:09:49,790
类型是扩展

252
00:09:49,790 --> 00:09:51,680
内部的一种方式 数据库系统的类型系统，

253
00:09:51,680 --> 00:09:53,750
并允许您再次支持

254
00:09:53,750 --> 00:09:57,500
一些更复杂的对象类型，这些对象类型

255
00:09:57,500 --> 00:09:59,720
可能超出数据支持用户定义聚合的原始值的基本标量值范围内

256
00:09:59,720 --> 00:10:01,339
，

257
00:10:01,339 --> 00:10:03,559


258
00:10:03,559 --> 00:10:05,930
是一种拥有更复杂

259
00:10:05,930 --> 00:10:07,759
聚合函数的方法，而不是 你

260
00:10:07,759 --> 00:10:09,889
知道极大极小数和一些类似的东西

261
00:10:09,889 --> 00:10:14,079
，所以我不能证明这一点，但这是我的

262
00:10:14,079 --> 00:10:16,730
直觉，当我玩的时候，

263
00:10:16,730 --> 00:10:18,290
我在程序中看到了什么，

264
00:10:18,290 --> 00:10:21,110
与人们交谈，

265
00:10:21,110 --> 00:10:24,290
这些不同应用程序的流行程度

266
00:10:24,290 --> 00:10:27,620
使用这些这些类型的嵌入式

267
00:10:27,620 --> 00:10:30,019
逻辑是，顶部将是最

268
00:10:30,019 --> 00:10:31,579
常见的到最不常见的，因此

269
00:10:31,579 --> 00:10:33,170
用户定义的函数非常非常

270
00:10:33,170 --> 00:10:35,120
非常常见，您在所有地方都可以看到这些

271
00:10:35,120 --> 00:10:36,829
，然后是

272
00:10:36,829 --> 00:10:38,389
用户定义的聚合

273
00:10:38,389 --> 00:10:40,430
不太常见的触发器和存储

274
00:10:40,430 --> 00:10:42,519
过程，它们可能

275
00:10:42,519 --> 00:10:45,319
可以互换，但同样就像

276
00:10:45,319 --> 00:10:46,730
您实现触发器的方式是通过

277
00:10:46,730 --> 00:10:50,269
用户定义的函数的另一

278
00:10:50,269 --> 00:10:52,220
件事 我认为在 Microsoft

279
00:10:52,220 --> 00:10:53,870
论文中，他们谈到了

280
00:10:53,870 --> 00:10:56,319
用户定义的函数如何无法更新

281
00:10:56,319 --> 00:10:59,240
更新元组或更新表，他们可以

282
00:10:59,240 --> 00:11:01,189
在那里它们是只读的存储

283
00:11:01,189 --> 00:11:03,230
过程，您可以在其中更新我认为

284
00:11:03,230 --> 00:11:05,970


285
00:11:05,970 --> 00:11:09,389
特定于的内容 续集服务器 我不

286
00:11:09,389 --> 00:11:10,980
认为续集标准指定了

287
00:11:10,980 --> 00:11:11,720
一种或另一种方式，

288
00:11:11,720 --> 00:11:13,860
因此您可以拥有

289
00:11:13,860 --> 00:11:15,769
实际更新更新表的用户定义

290
00:11:15,769 --> 00:11:20,579
函数，所以我们今天要关注的

291
00:11:20,579 --> 00:11:21,959
是用户定义函数，

292
00:11:21,959 --> 00:11:24,389
因为再次 这是

293
00:11:24,389 --> 00:11:28,079
最常见的一个，你知道它

294
00:11:28,079 --> 00:11:31,410


295
00:11:31,410 --> 00:11:32,790
至少可以与存储过程和

296
00:11:32,790 --> 00:11:35,639


297
00:11:35,639 --> 00:11:41,519
触发器组合使用

298
00:11:41,519 --> 00:11:44,490


299
00:11:44,490 --> 00:11:46,819
由应用程序开发人员编写的函数

300
00:11:46,819 --> 00:11:49,290
，允许他们扩展系统

301
00:11:49,290 --> 00:11:52,019
功能，超出其内置

302
00:11:52,019 --> 00:11:54,329
操作提供的功能 我说过，续集

303
00:11:54,329 --> 00:11:56,040
标准定义了一些基本的续集

304
00:11:56,040 --> 00:11:59,160
函数字符串长度 s 你

305
00:11:59,160 --> 00:12:00,920
知道转换函数之类的东西，

306
00:12:00,920 --> 00:12:04,680
但现在还有超越

307
00:12:04,680 --> 00:12:06,209
续集标准所说的，甚至

308
00:12:06,209 --> 00:12:07,560


309
00:12:07,560 --> 00:12:09,839
数据库系统支持的专有函数，你可以编写

310
00:12:09,839 --> 00:12:12,329
用户盲函数，你可以像

311
00:12:12,329 --> 00:12:13,829
调用它们一样调用它们 内置

312
00:12:13,829 --> 00:12:16,829
函数，所以设置是你

313
00:12:16,829 --> 00:12:19,170
总是会被作为标量输入参数给出，

314
00:12:19,170 --> 00:12:21,329
比如单个原始

315
00:12:21,329 --> 00:12:23,790
值甚至标量数组，

316
00:12:23,790 --> 00:12:25,800
但不像你知道表集或行

317
00:12:25,800 --> 00:12:28,079
集，然后你执行某种

318
00:12:28,079 --> 00:12:31,319
在它们中进行计算，并且此

319
00:12:31,319 --> 00:12:33,029
计算将成为您熟悉的标准

320
00:12:33,029 --> 00:12:34,470
命令式语言结构，

321
00:12:34,470 --> 00:12:36,329
您熟悉 for 循环 while

322
00:12:36,329 --> 00:12:39,180
循环 if 子句之类的东西，

323
00:12:39,180 --> 00:12:41,339
也可以调用此 UDF 中的其他后续

324
00:12:41,339 --> 00:12:43,860
语句或其他

325
00:12:43,860 --> 00:12:47,370
UDF，然后您 返回一个

326
00:12:47,370 --> 00:12:50,309
结果，该结果要么是更多的

327
00:12:50,309 --> 00:12:54,569
标量值，要么是一个关系或一组

328
00:12:54,569 --> 00:12:58,500
行，这就是

329
00:12:58,500 --> 00:13:00,180
我们在这里尝试的基本思想，所以让我们看看 k 一个

330
00:13:00,180 --> 00:13:02,970
例子 所以这将被写

331
00:13:02,970 --> 00:13:06,029
在弗洛伊德第一部分的所有例子中

332
00:13:06,029 --> 00:13:08,040
我们将

333
00:13:08,040 --> 00:13:09,899
用一种称为 T

334
00:13:09,899 --> 00:13:12,329
sequel 或 transact sequel 的编程语言展示例子 所以这

335
00:13:12,329 --> 00:13:14,100
是微软续集

336
00:13:14,100 --> 00:13:16,550
服务器支持的 UDF 语言和欺诈 正在

337
00:13:16,550 --> 00:13:19,259
改进续集服务器

338
00:13:19,259 --> 00:13:19,640
中的 UDF 所以这就是为什么我们

339
00:13:19,640 --> 00:13:23,110
使用这个来自 Sybase 的 TC

340
00:13:23,110 --> 00:13:25,610
因为 Seco 服务器最初是

341
00:13:25,610 --> 00:13:29,420
作为 1990 年代获得许可的

342
00:13:29,420 --> 00:13:32,140


343
00:13:32,140 --> 00:13:36,590


344
00:13:36,590 --> 00:13:38,810


345
00:13:38,810 --> 00:13:42,350
由 SAP 购买，

346
00:13:42,350 --> 00:13:43,970
在这一点上或多或少处于维护模式我们是

347
00:13:43,970 --> 00:13:45,140
续集服务器仍然非常

348
00:13:45,140 --> 00:13:46,430
先进并且仍在

349
00:13:46,430 --> 00:13:49,010
积极开发另一种方式

350
00:13:49,010 --> 00:13:50,210
想想这就像有很多

351
00:13:50,210 --> 00:13:52,580
主要的大公司和

352
00:13:52,580 --> 00:13:55,550
在 Sybase 上运行它们的主要应用程序，但

353
00:13:55,550 --> 00:13:58,400
你知道没有初创公司有

354
00:13:58,400 --> 00:13:59,840
一群 20 岁 20 岁的孩子

355
00:13:59,840 --> 00:14:01,160
会说你知道我要建立我的

356
00:14:01,160 --> 00:14:03,710
初创公司 s PI 不再

357
00:14:03,710 --> 00:14:04,610
发生了

358
00:14:04,610 --> 00:14:06,170
我们是 siegel 服务器实际上仍然

359
00:14:06,170 --> 00:14:11,090
是一个仍然是

360
00:14:11,090 --> 00:14:14,870
许多应用程序的不错选择所以我也会说到

361
00:14:14,870 --> 00:14:16,400
续集标准 Divine

362
00:14:16,400 --> 00:14:19,580
定义了一种称为续集 PGM 的语言

363
00:14:19,580 --> 00:14:21,860
据我所知，没有人真正

364
00:14:21,860 --> 00:14:25,130
支持

365
00:14:25,130 --> 00:14:27,680
续集标准中的确切规范，他们

366
00:14:27,680 --> 00:14:29,060
所有看起来足够接近续集

367
00:14:29,060 --> 00:14:31,880
PGM 的东西仍然偏离它所以 Oracle 有

368
00:14:31,880 --> 00:14:35,210
PL 续集 Postgres 有 PL PG 续集

369
00:14:35,210 --> 00:14:37,370
，它是一个轻微的变体或者

370
00:14:37,370 --> 00:14:40,340
是 本地人通常又是 PL

371
00:14:40,340 --> 00:14:41,990
续集 PL 续集看起来

372
00:14:41,990 --> 00:14:43,190
足够接近 PGM 的续集，但它并不

373
00:14:43,190 --> 00:14:46,400
完全相同，但在高层次上，

374
00:14:46,400 --> 00:14:47,810
它看起来像 Pascal，它看起来

375
00:14:47,810 --> 00:14:50,930
有点像 ADA 所以除了正在发生的更

376
00:14:50,930 --> 00:14:54,410
复杂的事情 从

377
00:14:54,410 --> 00:14:56,240
你知道记录新闻这是一个重大的

378
00:14:56,240 --> 00:14:58,310
变化交易续集它有点

379
00:14:58,310 --> 00:14:59,510
不同但它仍然在高水平

380
00:14:59,510 --> 00:15:00,290
看起来是一样的

381
00:15:00,290 --> 00:15:02,360
所以这里我们有一个

382
00:15:02,360 --> 00:15:04,460
我们真的很好的功能将获得

383
00:15:04,460 --> 00:15:06,770
所有自定义 来自客户表的 ID

384
00:15:06,770 --> 00:15:08,990
和来自订单表的偏移量，

385
00:15:08,990 --> 00:15:11,420
它会

386
00:15:11,420 --> 00:15:12,380


387
00:15:12,380 --> 00:15:14,480
根据他们花费的金额

388
00:15:14,480 --> 00:15:15,950
和他们提交的订单总数来计算他们应该拥有的客户服务级别，

389
00:15:15,950 --> 00:15:19,880
所以我们的

390
00:15:19,880 --> 00:15:21,770
函数将接收一个整数

391
00:15:21,770 --> 00:15:24,320
，即客户密钥，它会

392
00:15:24,320 --> 00:15:27,560
返回一个 10 个字符或字符串，因此

393
00:15:27,560 --> 00:15:29,000
在开始时我们将不得不再次声明

394
00:15:29,000 --> 00:15:31,700
我们所有的变量

395
00:15:31,700 --> 00:15:33,209


396
00:15:33,209 --> 00:15:36,959
所以

397
00:15:36,959 --> 00:15:40,199
在 Pasco 中，你

398
00:15:40,199 --> 00:15:42,179
在开始时定义了所有变量，然后

399
00:15:42,179 --> 00:15:44,189
我们现在有一个 select 语句，它

400
00:15:44,189 --> 00:15:45,209
看起来就像一个普通的棒

401
00:15:45,209 --> 00:15:46,559
select am ，除了我们

402
00:15:46,559 --> 00:15:48,839
在符号 total equals 中添加了这个小东西，我们正在

403
00:15:48,839 --> 00:15:52,139
获取输出 这个总和存储

404
00:15:52,139 --> 00:15:53,639
它和我们

405
00:15:53,639 --> 00:15:56,670
上面定义的这个变量，现在我们有一些

406
00:15:56,670 --> 00:15:59,100
if 子句来说明如果总订单

407
00:15:59,100 --> 00:16:01,050
大于一百万，那么在

408
00:16:01,050 --> 00:16:03,149
白金级别，否则在

409
00:16:03,149 --> 00:16:05,759
第 常规级别，然后我们只

410
00:16:05,759 --> 00:16:08,279
返回级别值，它是一个 10 个

411
00:16:08,279 --> 00:16:10,079
字符的字符串，因此我们

412
00:16:10,079 --> 00:16:14,189
在查询中调用它的方式将是

413
00:16:14,189 --> 00:16:16,399
像这样在客户表上的骗局

414
00:16:16,399 --> 00:16:19,499
，我们开始为每个客户

415
00:16:19,499 --> 00:16:21,929
键调用此函数以 获得

416
00:16:21,929 --> 00:16:27,779
计算机服务水平没问题，所以正如我

417
00:16:27,779 --> 00:16:30,420
之前所说的

418
00:16:30,420 --> 00:16:34,920
，UDF 有一些重要的优点，这解释了

419
00:16:34,920 --> 00:16:37,519
为什么它们实际上非常

420
00:16:37,519 --> 00:16:39,720
普遍，第一个是它们

421
00:16:39,720 --> 00:16:41,339
支持模块化和重用，

422
00:16:41,339 --> 00:16:43,529
因为如果我有一个复杂的功能 或者

423
00:16:43,529 --> 00:16:46,199
我需要

424
00:16:46,199 --> 00:16:49,529
在同一个数据库中的多个应用程序之间重用的复杂逻辑

425
00:16:49,529 --> 00:16:50,009


426
00:16:50,009 --> 00:16:51,779
我不想

427
00:16:51,779 --> 00:16:53,220
一遍又一遍地重新实现该逻辑

428
00:16:53,220 --> 00:16:56,249
我可以改为将它放在

429
00:16:56,249 --> 00:16:59,759
数据库系统中并拥有

430
00:16:59,759 --> 00:17:01,019
应用程序的所有实例 我有多少

431
00:17:01,019 --> 00:17:03,179
次重构或更改它都依赖

432
00:17:03,179 --> 00:17:05,669
于使用

433
00:17:05,669 --> 00:17:09,869
我们讨论过的逻辑的相同集中位置，

434
00:17:09,869 --> 00:17:11,189
然后再次减少网络

435
00:17:11,189 --> 00:17:14,099
往返次数，这使得问题 ries

436
00:17:14,099 --> 00:17:15,898
运行得更快，因为数据库

437
00:17:15,898 --> 00:17:16,949
不必返回，永远

438
00:17:16,949 --> 00:17:18,599
不要说你应该知道什么来找出

439
00:17:18,599 --> 00:17:20,609
下一步要做什么所有逻辑都可以

440
00:17:20,609 --> 00:17:23,880
在数据系统内运行，这个

441
00:17:23,880 --> 00:17:25,289
有点主观，但有一些

442
00:17:25,289 --> 00:17:28,740
论点说对于某些

443
00:17:28,740 --> 00:17:32,070
应用程序域，

444
00:17:32,070 --> 00:17:33,210
您需要在应用程序中编写的那种逻辑

445
00:17:33,210 --> 00:17:35,159
更容易

446
00:17:35,159 --> 00:17:38,220
在续集中的 UDF 中表达我更喜欢所以那么对于

447
00:17:38,220 --> 00:17:39,750
某些事情是的，它对于

448
00:17:39,750 --> 00:17:42,120
您通过 CT 轻松了解的其他事情仍然有意义

449
00:17:42,120 --> 00:17:45,410
情况有所好转，

450
00:17:45,410 --> 00:17:47,300
但确实有些事情我

451
00:17:47,300 --> 00:17:48,800
希望你只是不想在续集中做，

452
00:17:48,800 --> 00:17:51,170
而 UDF 是通过简单的步态分析来做到这一点的更好方法，

453
00:17:51,170 --> 00:17:54,590
有时

454
00:17:54,590 --> 00:17:56,150
事情会更好，看起来像

455
00:17:56,150 --> 00:17:58,370
UDF 好吧，这听起来很棒

456
00:17:58,370 --> 00:18:00,140
对，这听起来像是 UDS 或大赢

457
00:18:00,140 --> 00:18:02,660
我们完全想使用这个 有什么

458
00:18:02,660 --> 00:18:03,860
问题 为什么我们今天真的花

459
00:18:03,860 --> 00:18:05,060
时间来讨论如何使

460
00:18:05,060 --> 00:18:08,150
这些运行得更快 第一个问题

461
00:18:08,150 --> 00:18:10,520
是 当我们的查询

462
00:18:10,520 --> 00:18:13,250
优化器遇到 UDF 时，它对

463
00:18:13,250 --> 00:18:15,440
它们一无所知，本质

464
00:18:15,440 --> 00:18:17,860
上必须将它们视为黑匣子，

465
00:18:17,860 --> 00:18:20,270
因为它不知道

466
00:18:20,270 --> 00:18:22,070
它将是正确的功能，

467
00:18:22,070 --> 00:18:24,770
这是因为 UDF 被写入

468
00:18:24,770 --> 00:18:27,320
像你知道 PL sequel 或 single PL 一样的命令式语言

469
00:18:27,320 --> 00:18:32,810
，我们是一个 sequel

470
00:18:32,810 --> 00:18:34,850
是一种声明性语言，这意味着

471
00:18:34,850 --> 00:18:37,520
如果有查询实际上想要做什么，上传可以推断它是什么，

472
00:18:37,520 --> 00:18:39,380
并且

473
00:18:39,380 --> 00:18:40,970
它也知道一些关于数据的信息，

474
00:18:40,970 --> 00:18:44,030
尽管正如我们所看到的 估计很

475
00:18:44,030 --> 00:18:45,920
容易非常不准确，但 Headley

476
00:18:45,920 --> 00:18:47,630
说对正在发生的事情有一些了解

477
00:18:47,630 --> 00:18:51,200
，所以当你遇到

478
00:18:51,200 --> 00:18:53,060
UTF 时，你基本上说我不知道

479
00:18:53,060 --> 00:18:55,220
这会对我做什么，所以如果现在

480
00:18:55,220 --> 00:18:57,320
你像 UDF 一样使用

481
00:18:57,320 --> 00:18:59,150
where 子句我们就像你知道一些

482
00:18:59,150 --> 00:19:01,310
值你知道只有一些列

483
00:19:01,310 --> 00:19:03,500
在它被搅动

484
00:19:03,500 --> 00:19:06,230
或运行通过 UDF 之后等于另一列你不

485
00:19:06,230 --> 00:19:07,910
知道 UDF 会这样做所以他们的转换

486
00:19:07,910 --> 00:19:10,310
你不知道

487
00:19:10,310 --> 00:19:12,110
那个谓词的选择性的基数

488
00:19:12,110 --> 00:19:13,940
是什么，所以你

489
00:19:13,940 --> 00:19:17,540
基本上举起手来，你

490
00:19:17,540 --> 00:19:21,590
知道你使用了一些我知道我不

491
00:19:21,590 --> 00:19:22,970
知道你在做什么，

492
00:19:22,970 --> 00:19:23,870
有时你只是说最后的时间 在最坏的

493
00:19:23,870 --> 00:19:24,770
情况下，你说这是最糟糕的

494
00:19:24,770 --> 00:19:25,940
选择，你可能有

495
00:19:25,940 --> 00:19:27,740
选择地发送 300 的所有内容，

496
00:19:27,740 --> 00:19:29,450
或者另一端可能是 0% 的选择性，或者

497
00:19:29,450 --> 00:19:33,170
只是取平均值，你可以做

498
00:19:33,170 --> 00:19:35,300
一些像

499
00:19:35,300 --> 00:19:36,560
我们谈到的自适应查询优化的东西

500
00:19:36,560 --> 00:19:37,610
你可以运行一下，看看

501
00:19:37,610 --> 00:19:40,700
会发生什么并做出决定，但正如我

502
00:19:40,700 --> 00:19:42,710
所说的，直到最近，大多数系统

503
00:19:42,710 --> 00:19:44,300
实际上并不支持那些最不

504
00:19:44,300 --> 00:19:45,980
商业化的系统，也没有任何

505
00:19:45,980 --> 00:19:47,120
开源系统支持这一点，当

506
00:19:47,120 --> 00:19:49,820
它们确实支持 UDF 的全部时 是的，所以

507
00:19:49,820 --> 00:19:51,380
下一个有点微妙，但它

508
00:19:51,380 --> 00:19:53,750
基本上是说下一个问题

509
00:19:53,750 --> 00:19:59,000
是因为这

510
00:19:59,000 --> 00:20:01,730
是一个命令式代码，我们基本上

511
00:20:01,730 --> 00:20:04,460
必须逐行依次退出它们

512
00:20:04,460 --> 00:20:07,100
等等 at 意味着

513
00:20:07,100 --> 00:20:09,289
我们将无法瘫痪内部的任何

514
00:20:09,289 --> 00:20:12,650
操作，因为

515
00:20:12,650 --> 00:20:15,080
一行的输出可以

516
00:20:15,080 --> 00:20:16,460
用作下一行的输入，所以我们不能

517
00:20:16,460 --> 00:20:18,230
执行它来吃所以我们XQ

518
00:20:18,230 --> 00:20:20,690
在它之前，所以现在有点

519
00:20:20,690 --> 00:20:23,840
适合 Sara 执行，这并不

520
00:20:23,840 --> 00:20:25,700
意味着如果我们

521
00:20:25,700 --> 00:20:26,960
在多个线程中并行和并行地进行扫描，

522
00:20:26,960 --> 00:20:28,940
那么这些东西中的每一个都可以

523
00:20:28,940 --> 00:20:32,210
顺序调用 UDF，但我们没有

524
00:20:32,210 --> 00:20:33,850
得到任何

525
00:20:33,850 --> 00:20:36,230
认识到您知道 UDF 中可能有

526
00:20:36,230 --> 00:20:38,000
一堆续集查询的好处

527
00:20:38,000 --> 00:20:40,640
，我们可以将

528
00:20:40,640 --> 00:20:42,260
它们组合在一起运行，也许可以同时播放它们

529
00:20:42,260 --> 00:20:43,909
或同时进行优化，而

530
00:20:43,909 --> 00:20:46,039
不是逐个调用所有单个

531
00:20:46,039 --> 00:20:48,049
查询 我们可以将它们组合

532
00:20:48,049 --> 00:20:50,840
成一个带有连接的巨大查询并

533
00:20:50,840 --> 00:20:52,400
使其快速运行我们对

534
00:20:52,400 --> 00:20:54,350
内部发生的事情一无所知所以我们

535
00:20:54,350 --> 00:20:56,090
无法进行

536
00:20:56,090 --> 00:20:58,760
那些我们通常可以做的优化，如果我们有

537
00:20:58,760 --> 00:21:01,280
常规查询，另一个 真的 tric 很重要的

538
00:21:01,280 --> 00:21:04,820
一点是，某些

539
00:21:04,820 --> 00:21:05,510
UDF

540
00:21:05,510 --> 00:21:09,700
实际上可以扭曲 UDS 可以创建

541
00:21:09,700 --> 00:21:12,289
动态续集语句，因此基本上

542
00:21:12,289 --> 00:21:16,010
您可以声明一个字符串变量，并且它会

543
00:21:16,010 --> 00:21:18,380
像将字符串连接在一起那样递增地构造字符串

544
00:21:18,380 --> 00:21:20,539
说

545
00:21:20,539 --> 00:21:22,120
从表中选择星之类的事情

546
00:21:22,120 --> 00:21:25,880
，因此像您一样 不

547
00:21:25,880 --> 00:21:27,409
知道查询将是什么以及实际

548
00:21:27,409 --> 00:21:29,210
执行该代码，然后一旦您拥有

549
00:21:29,210 --> 00:21:31,159
该字符串，您就将该字符串

550
00:21:31,159 --> 00:21:33,140
作为续集语句调用，然后

551
00:21:33,140 --> 00:21:35,690
按照您所知道的查询方式运行，所以您甚至不

552
00:21:35,690 --> 00:21:37,190
知道如何准备 为此，

553
00:21:37,190 --> 00:21:38,330
因为您不知道查询

554
00:21:38,330 --> 00:21:41,720
会提前是什么，还有一些

555
00:21:41,720 --> 00:21:45,710
问题，您遇到的更多问题是

556
00:21:45,710 --> 00:21:48,500
复杂的 UDF，当您在

557
00:21:48,500 --> 00:21:49,850
那里时选择表或

558
00:21:49,850 --> 00:21:51,740
数据库系统将不得不

559
00:21:51,740 --> 00:21:54,909
执行这些事情的 where 子句 对

560
00:21:54,909 --> 00:21:57,890
每一行或每个元组

561
00:21:57,890 --> 00:22:01,490
逐个执行 UDF 因为我不

562
00:22:01,490 --> 00:22:03,289
知道 UDF 会做什么所以我

563
00:22:03,289 --> 00:22:05,390
不知道里面的逻辑

564
00:22:05,390 --> 00:22:07,399
它可以从一个元组更改为下一个元组，

565
00:22:07,399 --> 00:22:09,440
因为您知道我不

566
00:22:09,440 --> 00:22:10,850
知道您是要访问您

567
00:22:10,850 --> 00:22:12,470
知道属性 foo 还是实际

568
00:22:12,470 --> 00:22:16,120
您知道 bar 在 my in my in my topole

569
00:22:16,120 --> 00:22:19,400
所以我不知道如何访问 然后

570
00:22:19,400 --> 00:22:21,500
可能会在假期中组合多个或

571
00:22:21,500 --> 00:22:22,730


572
00:22:22,730 --> 00:22:26,570
在一批中对 UDF 的多个指标调用进行矢量化，

573
00:22:26,570 --> 00:22:28,760
你举起双手，基本上

574
00:22:28,760 --> 00:22:31,730
必须一个一个地做，所以微软的

575
00:22:31,730 --> 00:22:34,250
世界他们创造了

576
00:22:34,250 --> 00:22:37,190
这种术语 Rho 通过痛苦

577
00:22:37,190 --> 00:22:39,560
兄弟更多 表示你

578
00:22:39,560 --> 00:22:40,910
必须执行多么糟糕的事情为什么我们

579
00:22:40,910 --> 00:22:46,240
执行 UDS 所以最后一个是

580
00:22:46,240 --> 00:22:49,460
你知道所有这些都是如此相关 因为

581
00:22:49,460 --> 00:22:51,860
你正在执行

582
00:22:51,860 --> 00:22:54,830
UDF 中的命令或指令 一开始

583
00:22:54,830 --> 00:22:56,090
很难做交叉

584
00:22:56,090 --> 00:22:59,060


585
00:22:59,060 --> 00:23:02,890
对同一 UDF 中的 for 调用进行语句优化，

586
00:23:02,890 --> 00:23:07,490
那么我们如何很好地解决这个问题，一种

587
00:23:07,490 --> 00:23:10,400
方法是让人们

588
00:23:10,400 --> 00:23:12,370
尝试 Microsoft 实际上试图以

589
00:23:12,370 --> 00:23:14,690


590
00:23:14,690 --> 00:23:16,820
相同的方式将 UDF 转换为机器代码 我们

591
00:23:16,820 --> 00:23:20,270
谈到我们为查询做了 Co gen 我们

592
00:23:20,270 --> 00:23:22,910
可以为我们的 for annuity 做同样的事情，

593
00:23:22,910 --> 00:23:25,550
是的，但这可能会加快

594
00:23:25,550 --> 00:23:28,970
指令或 UDF 中的调用，

595
00:23:28,970 --> 00:23:31,490
但它仍然

596
00:23:31,490 --> 00:23:33,350
不能解决我们的瘫痪或成本

597
00:23:33,350 --> 00:23:34,490
估算 问题或交叉

598
00:23:34,490 --> 00:23:37,250
优化问题，

599
00:23:37,250 --> 00:23:39,380
它只会让你的鼓掌跑得

600
00:23:39,380 --> 00:23:43,670
更快 频谱的另一端

601
00:23:43,670 --> 00:23:45,350
绑定了最糟糕

602
00:23:45,350 --> 00:23:47,420
的 UDF 调用类型 它不是更糟，

603
00:23:47,420 --> 00:23:50,510
但它可能

604
00:23:50,510 --> 00:23:52,160
是调用类型中最慢的 将是

605
00:23:52,160 --> 00:23:53,510
Postgres 所做的，它实际上将

606
00:23:53,510 --> 00:23:55,340
每一行转换为单独的查询本身，

607
00:23:55,340 --> 00:23:57,710
然后它调用这意味着

608
00:23:57,710 --> 00:23:59,150
从工程的角度来看很聪明，但从

609
00:23:59,150 --> 00:24:00,650
性能团队的角度来看，我认为这

610
00:24:00,650 --> 00:24:03,440
非常糟糕，所以让我们看看

611
00:24:03,440 --> 00:24:04,970
坏事实际上会变得多么糟糕，所以

612
00:24:04,970 --> 00:24:08,990
这个 是来自使用比例因子 1 的 TPC H 的咖喱 12

613
00:24:08,990 --> 00:24:11,630
，因此他们修改

614
00:24:11,630 --> 00:24:15,950
了查询以

615
00:24:15,950 --> 00:24:18,410
在此处引入此人工谓词，该谓词

616
00:24:18,410 --> 00:24:21,500
具有调用 我们之前看到的 UDF

617
00:24:21,500 --> 00:24:23,450
但我们要计算客户

618
00:24:23,450 --> 00:24:25,400
排名，所以我们只

619
00:24:25,400 --> 00:24:26,179


620
00:24:26,179 --> 00:24:29,179
需要为我们正在查看的每个客户获取客户名称

621
00:24:29,179 --> 00:24:30,769
，我们只是检查它

622
00:24:30,769 --> 00:24:32,450
是否不为空

623
00:24:32,450 --> 00:24:34,279
，所以这个 UDF 看起来就像

624
00:24:34,279 --> 00:24:35,990
这样，它所做的只是获取客户

625
00:24:35,990 --> 00:24:37,700
键，并执行单个选择

626
00:24:37,700 --> 00:24:39,590
语句来执行查找以获取

627
00:24:39,590 --> 00:24:42,499
客户名称，因此此谓词

628
00:24:42,499 --> 00:24:45,529
本质上是无用的，因为在

629
00:24:45,529 --> 00:24:48,679
此列的 TPCC 中，对

630
00:24:48,679 --> 00:24:50,929
客户名称感到抱歉 列它永远不会

631
00:24:50,929 --> 00:24:55,610
是空的，但优化

632
00:24:55,610 --> 00:24:57,440
器不知道这里在做什么，

633
00:24:57,440 --> 00:25:00,049
因为这只是一个黑匣子，现在您

634
00:25:00,049 --> 00:25:01,279
可以说好吧，为什么不能尝试

635
00:25:01,279 --> 00:25:02,779
解释这是什么，您知道这里的

636
00:25:02,779 --> 00:25:06,049
查询和 尝试将其内联，但它

637
00:25:06,049 --> 00:25:07,399
不会这样做，因为它不会

638
00:25:07,399 --> 00:25:09,080
知道并非所有查询 他们

639
00:25:09,080 --> 00:25:10,340
不会所有人都将如此简单

640
00:25:10,340 --> 00:25:13,490
所以优化器不知道这

641
00:25:13,490 --> 00:25:16,940
是没有客户名称永远不会评估

642
00:25:16,940 --> 00:25:20,299
的 null 或永远值八 to no

643
00:25:20,299 --> 00:25:22,970
因此这个谓词总是正确的

644
00:25:22,970 --> 00:25:25,460
所以这只是浪费的工作我们正在

645
00:25:25,460 --> 00:25:26,869
调用这个函数来

646
00:25:26,869 --> 00:25:30,129
检查一些永远不会为假的东西

647
00:25:30,129 --> 00:25:34,610
所以如果你只

648
00:25:34,610 --> 00:25:37,490
在续集服务器中执行这个原始查询你可以

649
00:25:37,490 --> 00:25:39,559
没有UDF你可以 在八百毫秒内调用它，

650
00:25:39,559 --> 00:25:42,529
但如果你只是添加

651
00:25:42,529 --> 00:25:45,830
这个这个简单的 UDF，那么同样的查询

652
00:25:45,830 --> 00:25:50,059
现在需要 13 个小时，因为它再次

653
00:25:50,059 --> 00:25:54,039


654
00:25:54,039 --> 00:25:57,909
对每个元组的每个单个元组调用

655
00:25:57,909 --> 00:26:00,679
这个函数，现在不再对我

656
00:26:00,679 --> 00:26:02,029
这个 看起来非常令人惊讶，因为

657
00:26:02,029 --> 00:26:04,519
如果我的比例

658
00:26:04,519 --> 00:26:06,259
因子为 1 以及有多少客户或

659
00:26:06,259 --> 00:26:07,730
行号实际上会变得多么

660
00:26:07,730 --> 00:26:10,519
糟糕，但

661
00:26:10,519 --> 00:26:13,070
无论出于何种原因再次秘密

662
00:26:13,070 --> 00:26:14,539
对此进行扼杀并获得 13 个

663
00:26:14,539 --> 00:26:18,200
小时那又如何呢？ 我们今天会看到

664
00:26:18,200 --> 00:26:20,809
一种叫做弗洛伊德的技术是如何

665
00:26:20,809 --> 00:26:22,669
在函数中内嵌它来避免这种情况

666
00:26:22,669 --> 00:26:25,070
你知道我们谈论的所有坏事

667
00:26:25,070 --> 00:26:27,889
和剧透 D 如果您编写

668
00:26:27,889 --> 00:26:29,840
具有相同代码的相同函数并运行该函数，

669
00:26:29,840 --> 00:26:31,460
并且弗洛伊德可以将其降低到

670
00:26:31,460 --> 00:26:33,919
900 毫秒，因此它

671
00:26:33,919 --> 00:26:37,190
比

672
00:26:37,190 --> 00:26:38,809
原始查询慢一百毫秒，但这肯定

673
00:26:38,809 --> 00:26:39,740
不是你知道

674
00:26:39,740 --> 00:26:41,510
它不会长达 13 小时 就像在

675
00:26:41,510 --> 00:26:45,020
数量级上一样，所以

676
00:26:45,020 --> 00:26:46,280
让我们看看拍摄历史中的这一点，

677
00:26:46,280 --> 00:26:49,460
从我们如何在单

678
00:26:49,460 --> 00:26:55,160
服务器中到弗洛伊德，因此在 2001 年，微软

679
00:26:55,160 --> 00:27:01,179
增加了对标量 UDF 的再次

680
00:27:01,179 --> 00:27:03,530
计算或接收标量值并

681
00:27:03,530 --> 00:27:06,200
产生标量结果的支持 在

682
00:27:06,200 --> 00:27:09,350
2008 年左右，人们开始意识到，

683
00:27:09,350 --> 00:27:13,070
哦，这些 UDF 实际上有点糟糕，

684
00:27:13,070 --> 00:27:14,600
它们使事情变得非常缓慢，

685
00:27:14,600 --> 00:27:16,340
就像它们非常适合可编程性

686
00:27:16,340 --> 00:27:18,470
和扩展

687
00:27:18,470 --> 00:27:20,600
数据库系统功能的范围，但

688
00:27:20,600 --> 00:27:23,090
它只是破坏了性能，

689
00:27:23,090 --> 00:27:24,980
所以就是这样 来自

690
00:27:24,980 --> 00:27:26,690
Microsoft 员工的博客文章，他基本上

691
00:27:26,690 --> 00:27:29,390
说，哦，这些 UDF 是邪恶的，

692
00:27:29,390 --> 00:27:30,590
他们编写的它们使一切变得

693
00:27:30,590 --> 00:27:34,670
非常慢，然后在 2  010 微软

694
00:27:34,670 --> 00:27:36,550
实际上公开承认

695
00:27:36,550 --> 00:27:39,110
UDF 是邪恶的，他们提出了

696
00:27:39,110 --> 00:27:41,090
这篇博客文章，说哦，是的，你

697
00:27:41,090 --> 00:27:43,580
做 DSR 是邪恶的，这就是原因

698
00:27:43,580 --> 00:27:45,110
，他们实际上积极鼓励

699
00:27:45,110 --> 00:27:49,040
他们的开发人员使用续集服务器

700
00:27:49,040 --> 00:27:51,590
不再使用 UTS，他们解释了原因

701
00:27:51,590 --> 00:27:52,700
，这是什么时候 他们还向 UTS 的

702
00:27:52,700 --> 00:27:54,230
机器代码引入了本地编译，

703
00:27:54,230 --> 00:27:56,450
但即便如此，它也没有

704
00:27:56,450 --> 00:27:59,000
解决

705
00:27:59,000 --> 00:28:02,510
为每个管或每一行一个一个地调用 UDF 的问题，所以

706
00:28:02,510 --> 00:28:08,000
现在在 2014 年的这一轮中

707
00:28:08,000 --> 00:28:12,610
，IIT Bombay 正在进行研究 这

708
00:28:12,610 --> 00:28:14,540
可能是你知道它是印度最好的

709
00:28:14,540 --> 00:28:18,920
数据库学校，他们

710
00:28:18,920 --> 00:28:22,190
正在研究 UDF 相关性，

711
00:28:22,190 --> 00:28:25,670
所以就像弗洛伊德之前的早期工作

712
00:28:25,670 --> 00:28:26,900
表明你实际上可以在

713
00:28:26,900 --> 00:28:29,120
UTS 内进行，而这项工作是

714
00:28:29,120 --> 00:28:32,720
由 Karthik 完成的 Rama Krotz Rama Rama

715
00:28:32,720 --> 00:28:36,110
Rama Chandra 是 IIT Bombay 的博士生，

716
00:28:36,110 --> 00:28:39,380
然后他从 kartha

717
00:28:39,380 --> 00:28:42,200
毕业，然后他加入了位于威斯康星州麦迪逊的 Jim

718
00:28:42,200 --> 00:28:43,570
Gray 实验室，

719
00:28:43,570 --> 00:28:45,820
她开始

720
00:28:45,820 --> 00:28:49,119
探索

721
00:28:49,119 --> 00:28:54,669
作为弗洛伊德的一部分，如何更进一步，所以到 2018 年

722
00:28:54,669 --> 00:28:58,320
微软宣布弗洛伊德将

723
00:28:58,320 --> 00:29:01,539
在

724
00:29:01,539 --> 00:29:04,809
2019 年的续集服务器中普遍可用，去年微软

725
00:29:04,809 --> 00:29:06,279
发布了实际上包含弗洛伊德的秘密服务器版本

726
00:29:06,279 --> 00:29:09,159
，如果你

727
00:29:09,159 --> 00:29:10,389
能看看 在文档中，Sherin

728
00:29:10,389 --> 00:29:12,879
办公室说这里是

729
00:29:12,879 --> 00:29:16,840
如何使用弗洛伊德票对 UDS 进行内衬，

730
00:29:16,840 --> 00:29:18,009
现在他们不称其为

731
00:29:18,009 --> 00:29:20,200
弗洛伊德，因为这就像

732
00:29:20,200 --> 00:29:22,929
产品名称中的研究名称，没有人会

733
00:29:22,929 --> 00:29:24,340
理解它只是被称为 规模

734
00:29:24,340 --> 00:29:26,049
你知道你肯定会命名，但它

735
00:29:26,049 --> 00:29:27,549
有点像 hackaton 微软没有

736
00:29:27,549 --> 00:29:29,559
调用续集服务器的内存引擎

737
00:29:29,559 --> 00:29:30,340


738
00:29:30,340 --> 00:29:32,320
Hecate 研究人员知道那

739
00:29:32,320 --> 00:29:33,639
是什么研究人员知道弗洛伊德是什么

740
00:29:33,639 --> 00:29:36,639
但也许如果你在

741
00:29:36,639 --> 00:29:38,019
他们的 文档它不会

742
00:29:38,019 --> 00:29:41,919
出现它在采矿中被调用所以这是

743
00:29:41,919 --> 00:29:44,080
说每年第二年的

744
00:29:44,080 --> 00:29:45,279
谈话迪克告诉我们这是非常

745
00:29:45,279 --> 00:29:47,679
令人印象深刻的，就像开始一个

746
00:29:47,679 --> 00:29:51,549
2015 年的项目，然后将它

747
00:29:51,549 --> 00:29:55,450
实际投入生产中，你知道

748
00:29:55,450 --> 00:29:57,489
一个主要的主要软件，它

749
00:29:57,489 --> 00:29:59,109
使市场价值数十亿美元

750
00:29:59,109 --> 00:30:01,479
，这将产生很大的影响，因为我的

751
00:30:01,479 --> 00:30:03,399
意思是很多人都会接触

752
00:30:03,399 --> 00:30:04,720
到这种 UDS 或者

753
00:30:04,720 --> 00:30:06,820
到处使用，但这是很短的时间

754
00:30:06,820 --> 00:30:08,019
来完成其中的一些工作 这是非常

755
00:30:08,019 --> 00:30:10,809
令人印象深刻的所以它向您展示了您如何

756
00:30:10,809 --> 00:30:12,669
知道弗洛伊德将要实现的收益有多么重要，

757
00:30:12,669 --> 00:30:13,989


758
00:30:13,989 --> 00:30:16,779
因为微软投入了大量的工程

759
00:30:16,779 --> 00:30:18,519
努力 要在生产中使用

760
00:30:18,519 --> 00:30:22,509
它，请在您知道续集服务器的真实版本中使用

761
00:30:22,509 --> 00:30:25,479
它，这很少见，因为

762
00:30:25,479 --> 00:30:27,549
大多数时候数据库公司最不重要

763
00:30:27,549 --> 00:30:31,989
的是 Oracle IBM 和

764
00:30:31,989 --> 00:30:34,840
Microsoft 中的主要公司 他们非常保守

765
00:30:34,840 --> 00:30:37,749
地很快推出新功能，

766
00:30:37,749 --> 00:30:39,849
因为人们 依赖这些

767
00:30:39,849 --> 00:30:42,039
东西，如果你知道你的产品

768
00:30:42,039 --> 00:30:43,479
是否看起来特别是一个数据库系统，

769
00:30:43,479 --> 00:30:45,429
它被认为不可靠或有点不稳定，或者

770
00:30:45,429 --> 00:30:47,139
你没有

771
00:30:47,139 --> 00:30:49,029
认真对待工程过程 严重

772
00:30:49,029 --> 00:30:52,029
伤害了你知道销售和你的声誉

773
00:30:52,029 --> 00:30:54,700
所以在这么短的时间

774
00:30:54,700 --> 00:30:56,200
内把它投入生产

775
00:30:56,200 --> 00:30:59,830
是一件大事

776
00:30:59,830 --> 00:31:04,929
所以弗洛伊德是什么所以正如我所说弗洛伊德是

777
00:31:04,929 --> 00:31:07,870
一种转换命令式 UDF

778
00:31:07,870 --> 00:31:10,750
代码的技术 表达式的关系输出，

779
00:31:10,750 --> 00:31:12,760
然后我们可以将其嵌入到查询

780
00:31:12,760 --> 00:31:17,049
计划中的查询计划中，我们正在

781
00:31:17,049 --> 00:31:22,360
调用该 UDF，

782
00:31:22,360 --> 00:31:24,100
我们之所以要这样做是因为

783
00:31:24,100 --> 00:31:27,130
这将启用查询优化器

784
00:31:27,130 --> 00:31:30,039
和其余的 系统来推理

785
00:31:30,039 --> 00:31:33,309
UDF 正在做什么并

786
00:31:33,309 --> 00:31:35,889
像常规查询一样对其进行优化，

787
00:31:35,889 --> 00:31:37,659
但基本上您将

788
00:31:37,659 --> 00:31:40,899
命令式代码转换为声明式或后续

789
00:31:40,899 --> 00:31:42,789
声明式关系代数

790
00:31:42,789 --> 00:31:45,700
表达式很好，并且

791
00:31:45,700 --> 00:31:46,929
您将从中获得优势 是

792
00:31:46,929 --> 00:31:48,330
从应用程序开发人员的角度来看，

793
00:31:48,330 --> 00:31:51,190
您不必做任何事情，您

794
00:31:51,190 --> 00:31:52,840
只需使用您已有的 UDS，

795
00:31:52,840 --> 00:31:55,990
然后拨动开关说我想

796
00:31:55,990 --> 00:31:58,450
使用弗洛伊德，它会为您进行内

797
00:31:58,450 --> 00:31:59,559
联 你这不是说你甚至不需要

798
00:31:59,559 --> 00:32:02,049
再次触摸你的应用程序这

799
00:32:02,049 --> 00:32:03,610
是非常罕见的每当

800
00:32:03,610 --> 00:32:05,350
你知道有一个新的秘密时想想这个说

801
00:32:05,350 --> 00:32:06,700
有一个新的神奇续集功能

802
00:32:06,700 --> 00:32:09,070
可以让你的

803
00:32:09,070 --> 00:32:12,010
应用程序更快他们通常

804
00:32:12,010 --> 00:32:13,480
会保留 旧的就位，

805
00:32:13,480 --> 00:32:14,740
然后你必须去改变你的

806
00:32:14,740 --> 00:32:16,809
应用程序以使用新的应用程序或改变

807
00:32:16,809 --> 00:32:18,370
你的方式而不是查询那里的

808
00:32:18,370 --> 00:32:19,750
事情你不必做

809
00:32:19,750 --> 00:32:22,630
任何弗洛伊德它只是它工作

810
00:32:22,630 --> 00:32:26,700
正常 这非常酷，

811
00:32:27,269 --> 00:32:30,490
所以接下来会发生的是，

812
00:32:30,490 --> 00:32:32,470
查询会出现，这将

813
00:32:32,470 --> 00:32:35,500
调用一个 EDF，然后弗洛伊德会

814
00:32:35,500 --> 00:32:39,130


815
00:32:39,130 --> 00:32:41,950
在你到达成本基础之前，在粘合剂重写器阶段进行转换，

816
00:32:41,950 --> 00:32:43,809
清除你的查询优化器，所以

817
00:32:43,809 --> 00:32:47,950
所有规则 我们要做

818
00:32:47,950 --> 00:32:51,399
的内联只是不需要

819
00:32:51,399 --> 00:32:53,380
成本模型，就像它们是静态

820
00:32:53,380 --> 00:32:55,179
启发式一样，可以说静态

821
00:32:55,179 --> 00:32:57,039
转换规则要说的

822
00:32:57,039 --> 00:32:58,149
时间在这里是如何操作

823
00:32:58,149 --> 00:33:00,370
UDF 来制作 要将其转换为

824
00:33:00,370 --> 00:33:03,880
我可以内联的内容

825
00:33:03,880 --> 00:33:07,860
，您需要考虑的唯一

826
00:33:07,860 --> 00:33:10,230
类型是参数或标志，它们将

827
00:33:10,230 --> 00:33:12,920
指定您想要的深度，

828
00:33:12,920 --> 00:33:15,330
而不是

829
00:33:15,330 --> 00:33:17,460
像您可以拥有的嵌套 UDF 调用那样进行内联

830
00:33:17,460 --> 00:33:19,320
称为 UDS 调用的 UDS 是的

831
00:33:19,320 --> 00:33:21,360
，如果您尝试内联所有这些，

832
00:33:21,360 --> 00:33:24,990
那么您就会知道

833
00:33:24,990 --> 00:33:27,680
优化器现在

834
00:33:27,680 --> 00:33:31,110
尝试计划和优化变得更加困难，因为现在

835
00:33:31,110 --> 00:33:33,570
您拥有这个巨大的查询，而

836
00:33:33,570 --> 00:33:35,010
之前它只是全部 一堆 UDF

837
00:33:35,010 --> 00:33:36,600
调用，所以

838
00:33:36,600 --> 00:33:37,410
就你所知，只有一个参数

839
00:33:37,410 --> 00:33:40,410
说明你想要走多深

840
00:33:40,410 --> 00:33:42,540
，所以基本上要做的是

841
00:33:42,540 --> 00:33:44,760
尝试通过创建子查询来进行内联

842
00:33:44,760 --> 00:33:47,760
以及原因

843
00:33:47,760 --> 00:33:49,590
我们想要这样做是因为所有

844
00:33:49,590 --> 00:33:52,080
主要的数据库系统，尤其是续集

845
00:33:52,080 --> 00:33:55,640
服务器都有非常复杂的

846
00:33:55,640 --> 00:33:58,340
构造或

847
00:33:58,340 --> 00:34:01,100
不必要的转换，并将它们转换

848
00:34:01,100 --> 00:34:04,410
为连接或临时表

849
00:34:04,410 --> 00:34:07,470
调用装备 所以我们要把

850
00:34:07,470 --> 00:34:09,570
所有的 UDS 都烧成子查询，然后

851
00:34:09,570 --> 00:34:11,400
让优化器将这些子

852
00:34:11,400 --> 00:34:16,980
查询重写成更优化的形式，所以

853
00:34:16,980 --> 00:34:18,239
我们没有过多地谈论子

854
00:34:18,239 --> 00:34:20,940
查询，但我没有” 我不想

855
00:34:20,940 --> 00:34:22,560
谈论它们和横向连接或

856
00:34:22,560 --> 00:34:23,880
应用运算符，因为这些

857
00:34:23,880 --> 00:34:25,350
设置是为了了解

858
00:34:25,350 --> 00:34:27,960
我们要对子查询

859
00:34:27,960 --> 00:34:30,300
执行的操作，基本上是当您

860
00:34:30,300 --> 00:34:34,280
在另一个查询中为我们提供选择查询时

861
00:34:34,280 --> 00:34:37,020
想法是，日常系统

862
00:34:37,020 --> 00:34:39,270
调节器将这些子

863
00:34:39,270 --> 00:34:41,639
查询和嵌套查询视为几乎

864
00:34:41,639 --> 00:34:44,370
可以返回

865
00:34:44,370 --> 00:34:47,340
单个或一组值的函数，因此从概念上讲

866
00:34:47,340 --> 00:34:49,620
，子查询

867
00:34:49,620 --> 00:34:51,179
与 UF 几乎相同，或者就像 我们内部的某些东西

868
00:34:51,179 --> 00:34:53,670
，您可以取回值，所以正如

869
00:34:53,670 --> 00:34:55,889
我所说的优化器将要

870
00:34:55,889 --> 00:34:58,860
处理的方式这是两种方法，您可以

871
00:34:58,860 --> 00:35:00,810
重写它们以将查询进行相关扁平化

872
00:35:00,810 --> 00:35:02,850
，以便它们进行连接，

873
00:35:02,850 --> 00:35:04,380
或者在某些情况下您可以重写 他们

874
00:35:04,380 --> 00:35:08,460
成为一个单一的 表查询或者您是否

875
00:35:08,460 --> 00:35:11,040
要打破嵌套查询将

876
00:35:11,040 --> 00:35:13,500
其结果存储在临时表中或

877
00:35:13,500 --> 00:35:15,900
首先单独运行为什么它们

878
00:35:15,900 --> 00:35:17,580
没有附加到相同的查询计划或者

879
00:35:17,580 --> 00:35:18,840
它打破了取决于实现的单独查询计划

880
00:35:18,840 --> 00:35:21,090


881
00:35:21,090 --> 00:35:23,310
我们运行内部查询的想法

882
00:35:23,310 --> 00:35:25,230
首先将它具体化到一个临时

883
00:35:25,230 --> 00:35:27,360
表，然后我们运行外部查询

884
00:35:27,360 --> 00:35:29,940
，然后他们可以做的是读取

885
00:35:29,940 --> 00:35:31,500
该临时表的连接，

886
00:35:31,500 --> 00:35:34,230
当查询完成时临时表被丢弃，

887
00:35:34,230 --> 00:35:37,170
让我们看看 一个简单

888
00:35:37,170 --> 00:35:39,930
的重写例子，所以说你

889
00:35:39,930 --> 00:35:42,960
在这里有一个查询，我想得到

890
00:35:42,960 --> 00:35:46,200


891
00:35:46,200 --> 00:35:50,220


892
00:35:50,220 --> 00:35:53,310
在这一天预订了一条船的水手的名字，所以我

893
00:35:53,310 --> 00:35:55,080
只给了我你知道的一切 我有一个

894
00:35:55,080 --> 00:35:57,000
where 子句，它存在一个元组，其中

895
00:35:57,000 --> 00:36:00,480
有一个来自外部表的水手 ID 的引用

896
00:36:00,480 --> 00:36:02,280
和一个内部表上的保留 ID，

897
00:36:02,280 --> 00:36:05,250
所以当数据库

898
00:36:05,250 --> 00:36:07,110
系统看到这个并且如果它可以

899
00:36:07,110 --> 00:36:08,940
重写它可以重写它 作为

900
00:36:08,940 --> 00:36:11,610
像这样的简单连接，因为

901
00:36:11,610 --> 00:36:13,740
另一种选择是

902
00:36:13,740 --> 00:36:15,780
我对水手表中的每个元组运行此查询，

903
00:36:15,780 --> 00:36:17,430
但这将

904
00:36:17,430 --> 00:36:19,740
非常慢，所以我可以将其重写

905
00:36:19,740 --> 00:36:22,740
为此，然后我做任何

906
00:36:22,740 --> 00:36:24,960
散列 加入我想做的其他加入，

907
00:36:24,960 --> 00:36:27,990
所以我们不会再

908
00:36:27,990 --> 00:36:30,150
讨论这么多

909
00:36:30,150 --> 00:36:32,340
了，课程中有一个小组正在

910
00:36:32,340 --> 00:36:34,110
为最终项目做这件事，正如

911
00:36:34,110 --> 00:36:35,280
他们在做提案时所说的那样，

912
00:36:35,280 --> 00:36:37,380
状态更新

913
00:36:37,380 --> 00:36:39,060
他们将尝试

914
00:36:39,060 --> 00:36:41,940
在我们的系统中支持的不同类型的子查询

915
00:36:41,940 --> 00:36:44,400
我们还没有谈到的另一件事是横向

916
00:36:44,400 --> 00:36:47,730
连接，我认为横向连接的方式

917
00:36:47,730 --> 00:36:53,490
是当我有嵌套查询时，我可以

918
00:36:53,490 --> 00:36:57,210
让内部查询引用

919
00:36:57,210 --> 00:37:00,060
外部查询，因此在我的内部

920
00:37:00,060 --> 00:37:02,610
查询中，我可以在

921
00:37:02,610 --> 00:37:06,630
此处引用外部表中的水手 ID，但是如果我

922
00:37:06,630 --> 00:37:10,170
的两个查询不是嵌套的，而是

923
00:37:10,170 --> 00:37:12,810
像我的 from 子句一样依次执行，

924
00:37:12,810 --> 00:37:14,100
我可以有 一堆

925
00:37:14,100 --> 00:37:16,500
横向关节内的 select 语句

926
00:37:16,500 --> 00:37:19,340
将允许我

927
00:37:19,340 --> 00:37:23,840
引用属性或来自查询的元组

928
00:37:23,840 --> 00:37:26,610


929
00:37:26,610 --> 00:37:29,730
按顺序执行或在同一

930
00:37:29,730 --> 00:37:33,740
嵌套级别执行，所以

931
00:37:33,740 --> 00:37:36,830
没有这个横向关键字你和你

932
00:37:36,830 --> 00:37:38,810
将执行每个子 -query

933
00:37:38,810 --> 00:37:40,880
独立，您将无法

934
00:37:40,880 --> 00:37:42,560


935
00:37:42,560 --> 00:37:44,510
在 from 子句中引用彼此属性的项目，

936
00:37:44,510 --> 00:37:47,030
但是当我们允许自己

937
00:37:47,030 --> 00:37:50,740
正确引用其他属性

938
00:37:50,740 --> 00:37:53,839
时，当我们看到示例时，这将更有意义

939
00:37:53,839 --> 00:37:55,820
一秒钟但只

940
00:37:55,820 --> 00:37:59,119
知道就像在弗洛伊德的论文中一样，他们

941
00:37:59,119 --> 00:38:00,890
正在使用所谓的应用运算符

942
00:38:00,890 --> 00:38:04,339
来执行这些横向连接，我认为这

943
00:38:04,339 --> 00:38:06,410
在续集标准范围内，但其他

944
00:38:06,410 --> 00:38:08,300
系统（如 postgis 和 Oracle）您

945
00:38:08,300 --> 00:38:11,560
明确将其称为横向连接，

946
00:38:11,560 --> 00:38:15,260
所以 让我们通过一个弗洛伊德学说，

947
00:38:15,260 --> 00:38:19,250
所以它会有五个步骤，所以在

948
00:38:19,250 --> 00:38:22,040
第一步中，我们想将

949
00:38:22,040 --> 00:38:25,160
UDF 中的 sortie seco 语句转换为

950
00:38:25,160 --> 00:38:28,160
后续查询，然后现在 我们

951
00:38:28,160 --> 00:38:32,240
要将 UDF 转换

952
00:38:32,240 --> 00:38:33,890
为允许我们推理

953
00:38:33,890 --> 00:38:36,170
该区域内的续集查询的区域

954
00:38:36,170 --> 00:38:38,720
，然后我们将组合

955
00:38:38,720 --> 00:38:40,820
来自每个区域的所有表达式，现在天气

956
00:38:40,820 --> 00:38:42,320
将区域内的各个续集语句

957
00:38:42,320 --> 00:38:44,570
转换为 单个 sequel

958
00:38:44,570 --> 00:38:48,130
语句，然后现在我们可以

959
00:38:48,130 --> 00:38:51,050
将来自

960
00:38:51,050 --> 00:38:55,730
组合的巨型查询的 UDF 表达式内联到

961
00:38:55,730 --> 00:38:58,400
调用我们的 UDF 的查询中，然后

962
00:38:58,400 --> 00:38:59,480
我们只需通过我们的查询

963
00:38:59,480 --> 00:39:02,810
优化器运行它来进行优化，

964
00:39:02,810 --> 00:39:06,050
并根据需要进行不必要的优化

965
00:39:06,050 --> 00:39:06,440


966
00:39:06,440 --> 00:39:09,140
所以我要说的是，

967
00:39:09,140 --> 00:39:11,690
对于弗洛伊德的这个例子，我将展示一个

968
00:39:11,690 --> 00:39:13,099
插图，我将

969
00:39:13,099 --> 00:39:17,030
使用续集查询向您展示这些步骤，但

970
00:39:17,030 --> 00:39:18,859
续集服务器中弗洛伊德的真正实现

971
00:39:18,859 --> 00:39:20,869
并不对续集查询进行操作，

972
00:39:20,869 --> 00:39:22,820
并且 相反，对关系

973
00:39:22,820 --> 00:39:25,970
代数运算符进行操作，但我正在使用续集，

974
00:39:25,970 --> 00:39:28,369
因为这样更容易阅读

975
00:39:28,369 --> 00:39:31,130
第二种技术将进行内联，

976
00:39:31,130 --> 00:39:33,740
我将向您展示实际上确实对 s 进行了操作

977
00:39:33,740 --> 00:39:35,930
equel 查询 ok 连接

978
00:39:35,930 --> 00:39:38,930
将它们转换成评论表达式

979
00:39:38,930 --> 00:39:41,000
viii 直接形式并不是

980
00:39:41,000 --> 00:39:42,500
完全的续集查询，但最终

981
00:39:42,500 --> 00:39:45,170
结果是它在行中的内容是续集

982
00:39:45,170 --> 00:39:47,030
查询，而内联的

983
00:39:47,030 --> 00:39:51,170
是关系代数表达式，

984
00:39:51,170 --> 00:39:54,380
所以我们的第一步 假设我们

985
00:39:54,380 --> 00:39:55,820
有之前的例子，我们

986
00:39:55,820 --> 00:39:57,770
得到一个客户密钥，我们会

987
00:39:57,770 --> 00:40:00,620
在第一步告诉你你的应用程序的服务级别

988
00:40:00,620 --> 00:40:02,650
我们将分解

989
00:40:02,650 --> 00:40:05,030


990
00:40:05,030 --> 00:40:07,820
我们查询中的所有命令式语句，但我们 如果您

991
00:40:07,820 --> 00:40:11,480
知道在此处设置 Select 语句的级别

992
00:40:11,480 --> 00:40:13,280
或在此处执行 if 子句

993
00:40:13,280 --> 00:40:16,270
，我们可以将所有这些转换

994
00:40:16,270 --> 00:40:18,200
为 sequel 语句 我们必须这样做，

995
00:40:18,200 --> 00:40:20,000
因为这是 t 续集命令

996
00:40:20,000 --> 00:40:21,800
这不是续集 这与

997
00:40:21,800 --> 00:40:23,300
您的代数事物不相关 所以我们必须

998
00:40:23,300 --> 00:40:24,380
将它们转换为续集语句，

999
00:40:24,380 --> 00:40:25,630
以便我们可以将它们组合在一起，

1000
00:40:25,630 --> 00:40:28,460
所以它几乎总是一个 1:1

1001
00:40:28,460 --> 00:40:30,230
映射，所以

1002
00:40:30,230 --> 00:40:33,140
从 UDF 中的一种语句将产生 一个

1003
00:40:33,140 --> 00:40:35,150
查询并不总是如此，但对于我们的

1004
00:40:35,150 --> 00:40:38,690
例子来说是正确的，所以为此

1005
00:40:38,690 --> 00:40:40,520
将变量级别设置为 Platinum

1006
00:40:40,520 --> 00:40:43,310
这与

1007
00:40:43,310 --> 00:40:45,380
当您采用常量字符串

1008
00:40:45,380 --> 00:40:48,350
白金并将其投影到

1009
00:40:48,350 --> 00:40:51,530
Apple 输出中的属性级别时进行选择是一样的

1010
00:40:51,530 --> 00:40:53,960
这个表的查询结果是

1011
00:40:53,960 --> 00:40:56,900
查询，它是有效的续集，然后对于

1012
00:40:56,900 --> 00:40:58,820
这个在这里计算总和

1013
00:40:58,820 --> 00:41:00,680
，这是同样的事情，只是使用

1014
00:41:00,680 --> 00:41:02,210
与计算总和之前相同的查询

1015
00:41:02,210 --> 00:41:06,500
，然后再次将其投影到

1016
00:41:06,500 --> 00:41:09,620
总属性和 这里的最后

1017
00:41:09,620 --> 00:41:11,090
一个如果总数大于 100

1018
00:41:11,090 --> 00:41:14,720
万，那只是一个案例恶魔，我

1019
00:41:14,720 --> 00:41:17,570
在估计 if 子句中

1020
00:41:17,570 --> 00:41:20,210
聚集在一起，然后生成最漂亮的小程序，然后由于

1021
00:41:20,210 --> 00:41:22,010
我们在这里没有 else 语句，我们

1022
00:41:22,010 --> 00:41:23,450
不知道还有什么可做的 我们是否最终

1023
00:41:23,450 --> 00:41:26,930
将一个空值放入了一个空值，所以现在

1024
00:41:26,930 --> 00:41:29,330
下一步又是我们说我们现在知道如何进行

1025
00:41:29,330 --> 00:41:32,210
这种转换，什么将

1026
00:41:32,210 --> 00:41:34,880
我们的 UDF 分解为区域，然后构造

1027
00:41:34,880 --> 00:41:36,500
一个关系代数表达式或

1028
00:41:36,500 --> 00:41:39,620
序列 el 查询每一个，所以

1029
00:41:39,620 --> 00:41:41,420
对于第一部分，我们将

1030
00:41:41,420 --> 00:41:42,350
引用我声明一些变量的地方

1031
00:41:42,350 --> 00:41:46,730
，然后我们

1032
00:41:46,730 --> 00:41:48,920
计算客户开始的总价格

1033
00:41:48,920 --> 00:41:52,040
和我们将为每个创建的总密钥

1034
00:41:52,040 --> 00:41:56,480
区域合成表，我们可以在其中

1035
00:41:56,480 --> 00:41:59,920
再次分配

1036
00:41:59,920 --> 00:42:02,950
需要存储在变量中的值要

1037
00:42:02,950 --> 00:42:05,680
投影的输出属性，所以

1038
00:42:05,680 --> 00:42:08,620
在这种情况下，我们初始化

1039
00:42:08,620 --> 00:42:10,510
级别属性对不起级别

1040
00:42:10,510 --> 00:42:13,240
属性 - - - 这里什么都没有，所以我们只会

1041
00:42:13,240 --> 00:42:15,340
让你知道发送 那是 Nome

1042
00:42:15,340 --> 00:42:17,560
然后在这里我们计算我们

1043
00:42:17,560 --> 00:42:19,600
之前的总和，我们将它签名到

1044
00:42:19,600 --> 00:42:21,940
total 变量，然后我们将它存储

1045
00:42:21,940 --> 00:42:25,570
在一个合成表中作为我们的临时

1046
00:42:25,570 --> 00:42:27,340
表，用于查询的这一部分

1047
00:42:27,340 --> 00:42:31,420
现在是下一个

1048
00:42:31,420 --> 00:42:33,400
我们的第二个区域将涵盖

1049
00:42:33,400 --> 00:42:35,590
if 子句的这一部分，

1050
00:42:35,590 --> 00:42:37,240
这也是我

1051
00:42:37,240 --> 00:42:39,520
在上一张幻灯片中看到的相同 case 语句，然后

1052
00:42:39,520 --> 00:42:41,830
我们将销毁它，让我们

1053
00:42:41,830 --> 00:42:43,450
将结果存储在 这在 到 level

1054
00:42:43,450 --> 00:42:45,070
属性，然后我们将它存储

1055
00:42:45,070 --> 00:42:51,430
在 ER PR - er - 表中，所以这里的第三

1056
00:42:51,430 --> 00:42:53,350
个将只是 if 语句的另一个端口

1057
00:42:53,350 --> 00:42:56,440
部分，这

1058
00:42:56,440 --> 00:42:58,090
将与存在的相反，

1059
00:42:58,090 --> 00:43:00,400
或者如果 总数小于等于 100

1060
00:43:00,400 --> 00:43:03,010
万，然后我们将其设置为常规值，但

1061
00:43:03,010 --> 00:43:05,280
实际上请注意

1062
00:43:05,280 --> 00:43:11,080
这里的这两种情况 在这种情况下 如果我

1063
00:43:11,080 --> 00:43:14,890
没有 if 如果我的 if

1064
00:43:14,890 --> 00:43:16,960
从这里显示的总数 这个家伙在

1065
00:43:16,960 --> 00:43:19,450
这里，如果这超过一百万

1066
00:43:19,450 --> 00:43:21,970
在白金上设置，否则使用

1067
00:43:21,970 --> 00:43:23,680


1068
00:43:23,680 --> 00:43:26,200
在这里注册的任何级别值，所以我引用这张

1069
00:43:26,200 --> 00:43:28,450
表我引用你

1070
00:43:28,450 --> 00:43:30,070
在这里，因为我是

1071
00:43:30,070 --> 00:43:32,440
如果我没有在此处设置级别，则再次从上到下进行排序

1072
00:43:32,440 --> 00:43:33,670
，我想确保

1073
00:43:33,670 --> 00:43:35,350


1074
00:43:35,350 --> 00:43:36,970
在我不知道

1075
00:43:36,970 --> 00:43:39,010
在我们的示例中是否设置在我上方之前我确实传播了级别是什么

1076
00:43:39,010 --> 00:43:40,690
但它可能是由其他一些计算设置的

1077
00:43:40,690 --> 00:43:42,580
，所以我只是

1078
00:43:42,580 --> 00:43:43,960
说我不 不知道它是什么所以

1079
00:43:43,960 --> 00:43:46,150
只是我不是我没有修改它所以

1080
00:43:46,150 --> 00:43:48,940
只需将它在我上方区域中的任何内容传递

1081
00:43:48,940 --> 00:43:51,400
给我另一件事

1082
00:43:51,400 --> 00:43:55,390
我也将指出此示例

1083
00:43:55,390 --> 00:43:57,010
虽然它被剪掉了 关闭这是一

1084
00:43:57,010 --> 00:44:00,220
二三我可以为

1085
00:44:00,220 --> 00:44:03,100
我的 if 语句创建一个区域，其中包括 F else

1086
00:44:03,100 --> 00:44:07,440
因为这样这里的 case 语句的 else 部分

1087
00:44:07,440 --> 00:44:10,090


1088
00:44:10,090 --> 00:44:11,710
可能只是常规的事情，

1089
00:44:11,710 --> 00:44:13,599
然后我不需要

1090
00:44:13,599 --> 00:44:17,009
你知道

1091
00:44:17,009 --> 00:44:20,769
这个例子的总课程 Eagle Million 你可以在

1092
00:44:20,769 --> 00:44:23,190
其他例子中这样做你不能因为

1093
00:44:23,190 --> 00:44:25,479
你可以

1094
00:44:25,479 --> 00:44:27,549
在我们内部再次像这样很容易返回语句很容易

1095
00:44:27,549 --> 00:44:28,930
因为这就像

1096
00:44:28,930 --> 00:44:30,940
我设置的内部调用 一个变量，

1097
00:44:30,940 --> 00:44:32,650
但我再次想我可以

1098
00:44:32,650 --> 00:44:35,289
在这里面做任何我想做的事情，如果调用

1099
00:44:35,289 --> 00:44:36,489
就像我陷入它我可以调用另一个

1100
00:44:36,489 --> 00:44:38,140
函数我可以返回语句实际上是

1101
00:44:38,140 --> 00:44:40,059
一个查询，如果是这种情况，

1102
00:44:40,059 --> 00:44:41,529
它可能很难 声明

1103
00:44:41,529 --> 00:44:44,529
在这个 I 里面有一个 else

1104
00:44:44,529 --> 00:44:46,420
st 因为这个原因，为了

1105
00:44:46,420 --> 00:44:48,309
简单起见，我们将它分成两个

1106
00:44:48,309 --> 00:44:51,489
独立的区域，最后一个

1107
00:44:51,489 --> 00:44:53,049
是 return 语句，这将很

1108
00:44:53,049 --> 00:44:54,420
容易处理，

1109
00:44:54,420 --> 00:44:57,369
我们将

1110
00:44:57,369 --> 00:44:58,029
在下一张幻灯片的下一张中看到

1111
00:44:58,029 --> 00:44:59,499
它只是生成 无论 level 的输出是什么，

1112
00:44:59,499 --> 00:45:02,380
当我将这些

1113
00:45:02,380 --> 00:45:03,849
对不同区域的查询

1114
00:45:03,849 --> 00:45:05,950
再次组合在一起时，这非常

1115
00:45:05,950 --> 00:45:07,960
简单，因为在我的函数中

1116
00:45:07,960 --> 00:45:09,970
只有一个 return 语句，该论文

1117
00:45:09,970 --> 00:45:12,789
讨论了如何

1118
00:45:12,789 --> 00:45:14,410
为某些 UDS 返回的语句，你可以

1119
00:45:14,410 --> 00:45:16,479


1120
00:45:16,479 --> 00:45:19,089
在一天结束时在程序的所有不同部分都有 return 语句，

1121
00:45:19,089 --> 00:45:20,380
你总是需要在底部有一个 return

1122
00:45:20,380 --> 00:45:22,569
语句，所以

1123
00:45:22,569 --> 00:45:24,190
他们处理的方式是他们看起来会

1124
00:45:24,190 --> 00:45:25,569
创建一个名为 return value 的合成变量

1125
00:45:25,569 --> 00:45:28,299
，而不是

1126
00:45:28,299 --> 00:45:29,650
调用 return 并尝试在

1127
00:45:29,650 --> 00:45:31,509
那里返回结果，您将

1128
00:45:31,509 --> 00:45:33,069
在它被

1129
00:45:33,069 --> 00:45:35,109
调用的地方设置返回值，然后将其作为

1130
00:45:35,109 --> 00:45:38,710
底部的输出返回 好吧

1131
00:45:38,710 --> 00:45:42,339
好吧，现在我们有了我们的区域，

1132
00:45:42,339 --> 00:45:44,410
我们定义了我们为区域定义的查询，我们将

1133
00:45:44,410 --> 00:45:46,029
UDF 分解

1134
00:45:46,029 --> 00:45:48,339
到下一步中，现在开始将

1135
00:45:48,339 --> 00:45:52,089
它们合并为二对一的选择

1136
00:45:52,089 --> 00:45:53,799
语句，这就是这里的内容

1137
00:45:53,799 --> 00:45:55,420
，这是 横向

1138
00:45:55,420 --> 00:45:56,920
连接或交叉应用

1139
00:45:56,920 --> 00:45:59,890
发挥作用的地方，所以首先要

1140
00:45:59,890 --> 00:46:01,119
指出的是，这里是我们的返回

1141
00:46:01,119 --> 00:46:02,469
函数，这里是我们之前的返回值，

1142
00:46:02,469 --> 00:46:03,400
右

1143
00:46:03,400 --> 00:46:06,039
ER 3 点级别右因为这是

1144
00:46:06,039 --> 00:46:07,630
我们最后的事情 将查看

1145
00:46:07,630 --> 00:46:09,400
UDF 的底部，然后我们想要

1146
00:46:09,400 --> 00:46:10,569
设置的任何级别，

1147
00:46:10,569 --> 00:46:12,579
因为这是输出，但现在您

1148
00:46:12,579 --> 00:46:13,930
可以看到为什么我们需要使用这些交叉

1149
00:46:13,930 --> 00:46:16,210
连接，因为我从顶部调用了 from

1150
00:46:16,210 --> 00:46:19,630
，然后我有三个

1151
00:46:19,630 --> 00:46:22,779
没有嵌套在彼此内部的子查询

1152
00:46:22,779 --> 00:46:24,579
在它们执行时有

1153
00:46:24,579 --> 00:46:25,580


1154
00:46:25,580 --> 00:46:27,830
你的服务兄弟姐妹，因为缺少

1155
00:46:27,830 --> 00:46:31,160
更好的术语，所以为了让这个子

1156
00:46:31,160 --> 00:46:35,060
查询在这里引用这个子查询中的属性，

1157
00:46:35,060 --> 00:46:37,220
我必须使用交叉

1158
00:46:37,220 --> 00:46:39,830
应用或我必须使用横向连接，

1159
00:46:39,830 --> 00:46:42,290
以便我可以在这里引用 er 一个因为

1160
00:46:42,290 --> 00:46:44,420
没有这个我不能我不能这样做

1161
00:46:44,420 --> 00:46:50,080
它会说未定义的属性好吧，所以

1162
00:46:50,080 --> 00:46:53,120
这也向您显示输出或

1163
00:46:53,120 --> 00:46:57,710
它们的计算每个

1164
00:46:57,710 --> 00:46:59,900
这些类型的区域中的每一种都

1165
00:46:59,900 --> 00:47:03,680
取决于前一个区域，然后我将

1166
00:47:03,680 --> 00:47:06,230
设置一个修改级别

1167
00:47:06,230 --> 00:47:08,150
，然后我将在这里设置的最后一个

1168
00:47:08,150 --> 00:47:10,160
是我制作

1169
00:47:10,160 --> 00:47:13,550
的 输出好吧，就是这样，

1170
00:47:13,550 --> 00:47:15,800
这是我们

1171
00:47:15,800 --> 00:47:18,200
将为原始 UDF 生成的海鸥清除

1172
00:47:18,200 --> 00:47:19,730
，我们在开头看到的用

1173
00:47:19,730 --> 00:47:21,440
T 续集编写的原始 UDF 像这样将

1174
00:47:21,440 --> 00:47:24,470
产生一个计算，该计算

1175
00:47:24,470 --> 00:47:26,450
是等效于 e 的任何结果

1176
00:47:26,450 --> 00:47:29,180
给定键，所以现在我们需要内联它，

1177
00:47:29,180 --> 00:47:30,560
我们需要把它放在我们的

1178
00:47:30,560 --> 00:47:33,440
原始查询中，所以如果我们回到

1179
00:47:33,440 --> 00:47:35,750
原始查询，我们正在

1180
00:47:35,750 --> 00:47:37,430
为 select 输出子句中的每个客户键调用客户级函数，

1181
00:47:37,430 --> 00:47:40,310


1182
00:47:40,310 --> 00:47:43,040
所以我们所有 现在需要做的只是

1183
00:47:43,040 --> 00:47:46,270
替换自定义 在这里与我们的级别以及我们

1184
00:47:46,270 --> 00:47:50,540


1185
00:47:50,540 --> 00:47:53,480
从上一张幻灯片中组合在一起的应用运算符查询

1186
00:47:53,480 --> 00:47:55,880
，然后这里再次

1187
00:47:55,880 --> 00:47:59,270
是我们之前拥有的所有相同区域，所以现在

1188
00:47:59,270 --> 00:48:01,700
有了这个巨大的续集声明，我们

1189
00:48:01,700 --> 00:48:03,820
现在希望我们希望将其内联到我们的

1190
00:48:03,820 --> 00:48:06,740
我们 已经将它内联到我们的查询中，现在

1191
00:48:06,740 --> 00:48:08,510
我们可以通过优化器运行它，

1192
00:48:08,510 --> 00:48:12,850
让它通过重写和分解我们的运行嵌套或子查询来做它自己的事情来产生

1193
00:48:12,850 --> 00:48:15,650
更有效的查询计划，

1194
00:48:15,650 --> 00:48:19,430


1195
00:48:19,430 --> 00:48:20,690


1196
00:48:20,690 --> 00:48:23,570
那么后续的服务器优化器会做什么

1197
00:48:23,570 --> 00:48:25,730
生成是这样的设备计划

1198
00:48:25,730 --> 00:48:28,700
，它不再执行所有

1199
00:48:28,700 --> 00:48:30,590
这些类型的子选择

1200
00:48:30,590 --> 00:48:32,510
我只是在此内部进行左外连接，

1201
00:48:32,510 --> 00:48:36,320
在那里我计算您知道

1202
00:48:36,320 --> 00:48:39,160
我得到总金额我计算总金额

1203
00:48:39,160 --> 00:48:42,130


1204
00:48:42,130 --> 00:48:43,930
为每个客户下的订单数量你正在

1205
00:48:43,930 --> 00:48:45,100
做的组我在客户键

1206
00:48:45,100 --> 00:48:47,230
然后我做的是加入反对，现在我

1207
00:48:47,230 --> 00:48:49,120
在 Select 输出中推了 Mike Mike 一个声明

1208
00:48:49,120 --> 00:48:50,770
只是为了看看

1209
00:48:50,770 --> 00:48:52,690
什么结果 put 来自这个聚合，

1210
00:48:52,690 --> 00:48:54,360
然后产生了正确的输出级别，

1211
00:48:54,360 --> 00:48:59,520
所以从这个计算的黑盒调用中得到了什么，

1212
00:48:59,520 --> 00:49:04,150
但是

1213
00:49:04,150 --> 00:49:06,070
为了获得一些客户级别的东西，我只是

1214
00:49:06,070 --> 00:49:09,490
将它完全重写为一个简单的

1215
00:49:09,490 --> 00:49:11,320
聚合，然后是一个左外

1216
00:49:11,320 --> 00:49:14,710
连接，这是惊人的 对，这是考虑

1217
00:49:14,710 --> 00:49:17,500
一下，这就像您为任何 UDF 执行此操作，

1218
00:49:17,500 --> 00:49:20,560
几乎所有 UDF 都可以执行此

1219
00:49:20,560 --> 00:49:22,450
操作，所以我不像您知道的那样，

1220
00:49:22,450 --> 00:49:23,950
我必须付给某人很多钱

1221
00:49:23,950 --> 00:49:25,510
才能坐下来查看我的 UDS 并

1222
00:49:25,510 --> 00:49:26,950
弄清楚哦，我怎样才能真正将其

1223
00:49:26,950 --> 00:49:30,280
重写为查询，因为并非您所

1224
00:49:30,280 --> 00:49:33,340
了解的每个人都会被调用它

1225
00:49:33,340 --> 00:49:34,750
会与您知道的不同，

1226
00:49:34,750 --> 00:49:36,220
有时它会出现在电话中，

1227
00:49:36,220 --> 00:49:37,870
即使我们很接近，就像它可能是

1228
00:49:37,870 --> 00:49:39,400
每次都以不同的方式调用

1229
00:49:39,400 --> 00:49:41,410
但是然后不必

1230
00:49:41,410 --> 00:49:42,610
重写每一个看到可乐在哪里

1231
00:49:42,610 --> 00:49:45,340
使用它通过将这个转换为

1232
00:49:45,340 --> 00:49:48,070
这个巨大的海鸥内联续集

1233
00:49:48,070 --> 00:49:51,160
语句我制作了一个他知道的更有效的

1234
00:49:51,160 --> 00:49:54,010
查询计划 更改

1235
00:49:54,010 --> 00:49:55,060
应用程序代码不必

1236
00:49:55,060 --> 00:49:56,350
雇人做 查询优化器没有任何变化

1237
00:49:56,350 --> 00:49:57,730
查询优化器

1238
00:49:57,730 --> 00:49:58,840
已经可以处理

1239
00:49:58,840 --> 00:50:00,910
这个 在这个查询中没有关于弗洛伊德的任何具体内容

1240
00:50:00,910 --> 00:50:04,210
这是你所知道的香草续集

1241
00:50:04,210 --> 00:50:07,810
服务器续集语法 所以这是惊人的

1242
00:50:07,810 --> 00:50:10,810
所以现在还有一个好处是，从成本模型的角度来看，

1243
00:50:10,810 --> 00:50:11,860
UDF 不再是我们的黑匣子和

1244
00:50:11,860 --> 00:50:14,650
优化器，

1245
00:50:14,650 --> 00:50:16,510
所以我们知道如何为这个续集声明

1246
00:50:16,510 --> 00:50:17,650
搜索最有效的

1247
00:50:17,650 --> 00:50:20,470
物理计划，

1248
00:50:20,470 --> 00:50:22,750
你知道逻辑 计划如果

1249
00:50:22,750 --> 00:50:24,730
我们现在也可以并行调用它

1250
00:50:24,730 --> 00:50:26,050
是我可以有一个并行线程

1251
00:50:26,050 --> 00:50:28,450
计算组 II 现在可以有一个

1252
00:50:28,450 --> 00:50:29,920
并行然后并行线程

1253
00:50:29,920 --> 00:50:32,950
做你知道的你知道

1254
00:50:32,950 --> 00:50:34,720
在你之后做的每个查询都会产生输出

1255
00:50:34,720 --> 00:50:37,780
不能再这样做了，我很

1256
00:50:37,780 --> 00:50:39,490
高兴，你知道这很兴奋，因为我

1257
00:50:39,490 --> 00:50:45,480
认为这是一个巨大的胜利，所以现在

1258
00:50:45,480 --> 00:50:47,800
让我们谈谈

1259
00:50:47,800 --> 00:50:49,450
查询

1260
00:50:49,450 --> 00:50:51,550
优化器可以做的一些额外的优化 我们可以得到，因为

1261
00:50:51,550 --> 00:50:52,530
我们考虑的是

1262
00:50:52,530 --> 00:50:55,770
单个语句，所以让我们看一下真正

1263
00:50:55,770 --> 00:50:57,720
简单的 UDF，例如所谓的 get 元音

1264
00:50:57,720 --> 00:51:00,300
，其中您向该函数输入一些值

1265
00:51:00,300 --> 00:51:01,530
，其中一些可能是某个整数

1266
00:51:01,530 --> 00:51:04,410
，然后它会告诉您，如果它

1267
00:51:04,410 --> 00:51:06,240
返回 一个字符串，表示该

1268
00:51:06,240 --> 00:51:07,800
值是否大于一千，

1269
00:51:07,800 --> 00:51:09,840
如果 gret 值

1270
00:51:09,840 --> 00:51:11,190
大于或小于小于

1271
00:51:11,190 --> 00:51:13,350
一千，则返回 hi 返回低值，然后

1272
00:51:13,350 --> 00:51:15,600
将该值连接

1273
00:51:15,600 --> 00:51:18,150
到字符串 死所以你

1274
00:51:18,150 --> 00:51:20,720
根据输入得到高值低值

1275
00:51:20,720 --> 00:51:23,190
好吧所以说我们有这个

1276
00:51:23,190 --> 00:51:24,810
调用所以我们知道这个数字的值是什么

1277
00:51:24,810 --> 00:51:27,660
我说过我们可以

1278
00:51:27,660 --> 00:51:32,160
在你需要的任何地方将 X 的 5000 替换为 5000

1279
00:51:32,160 --> 00:51:35,250
所以我们会怎么做 与弗洛伊德一起得到它

1280
00:51:35,250 --> 00:51:38,400
是一个选择语句，它

1281
00:51:38,400 --> 00:51:42,080
看起来像这样，我有一个

1282
00:51:42,080 --> 00:51:45,840
横向连接，在那里我

1283
00:51:45,840 --> 00:51:47,580
根据我的输入来获取这个 case 语句的输出

1284
00:51:47,580 --> 00:51:49,440
，我将获得高值和低值，

1285
00:51:49,440 --> 00:51:52,920
所以现在让我们 去看看

1286
00:51:52,920 --> 00:51:54,960
什么样的优化 zations 你

1287
00:51:54,960 --> 00:51:56,580
知道的，重写操作符

1288
00:51:56,580 --> 00:51:58,890
会减少这个程序的复杂性

1289
00:51:58,890 --> 00:52:00,840
，它看起来

1290
00:52:00,840 --> 00:52:04,980
很像传统的编译器

1291
00:52:04,980 --> 00:52:07,620
优化器会做的事情，但你知道

1292
00:52:07,620 --> 00:52:09,840
像 C 或 C++ 这样的一对语言是

1293
00:52:09,840 --> 00:52:11,100
这样的 优化器可以做

1294
00:52:11,100 --> 00:52:14,490
它的查询优化器视频所以第一

1295
00:52:14,490 --> 00:52:16,500
件事是我们可以正确地动态切片

1296
00:52:16,500 --> 00:52:19,500
我们可以认识到我们知道给我们的

1297
00:52:19,500 --> 00:52:21,480
确切值

1298
00:52:21,480 --> 00:52:25,130
所以我们可以

1299
00:52:25,130 --> 00:52:30,030
在我们的输入中抛出低条件低路径 我们在一个

1300
00:52:30,030 --> 00:52:32,310
程序中，因为我们知道 X 的内容

1301
00:52:32,310 --> 00:52:33,930
是什么，所以我们知道我们

1302
00:52:33,930 --> 00:52:35,880
甚至永远不会执行它，所以我们

1303
00:52:35,880 --> 00:52:38,640
只是完全删除它然后我们可以进行

1304
00:52:38,640 --> 00:52:41,130
传播常量传播和

1305
00:52:41,130 --> 00:52:44,070
折叠再次认识到这里我们

1306
00:52:44,070 --> 00:52:46,020
有一个 选择查询，它所做的一切都是

1307
00:52:46,020 --> 00:52:48,090
产生输出 hi 然后有

1308
00:52:48,090 --> 00:52:49,650
一个选择查询，它接受这个

1309
00:52:49,650 --> 00:52:51,180
东西产生的任何东西并将其作为

1310
00:52:51,180 --> 00:52:54,960
输出，然后你知道在这里做同样的

1311
00:52:54,960 --> 00:52:56,790
事情或 采取

1312
00:52:56,790 --> 00:52:57,540
将这两个东西附加

1313
00:52:57,540 --> 00:53:00,030
在一起，而不是调用所有这些

1314
00:53:00,030 --> 00:53:01,710
这些带有

1315
00:53:01,710 --> 00:53:04,720
横向连接特征的子查询，因为

1316
00:53:04,720 --> 00:53:06,370
它们将它们组合在一起成为

1317
00:53:06,370 --> 00:53:08,620
我正确生成的单个常量

1318
00:53:08,620 --> 00:53:10,900
，然后UDF中的等效项将

1319
00:53:10,900 --> 00:53:13,030
在这里，最后一步将

1320
00:53:13,030 --> 00:53:15,250
再次消除死代码，认识

1321
00:53:15,250 --> 00:53:18,700
到我什至不需要将值设置

1322
00:53:18,700 --> 00:53:20,350
为高或设置它并清除可用

1323
00:53:20,350 --> 00:53:21,910
产生输出我可以

1324
00:53:21,910 --> 00:53:24,250
直接返回值我

1325
00:53:24,250 --> 00:53:29,290
在 PDF 与

1326
00:53:29,290 --> 00:53:30,580
关系地址中

1327
00:53:30,580 --> 00:53:31,900
的相同，因此弗洛伊德实质上是通过

1328
00:53:31,900 --> 00:53:35,490
使用查询优化器来实现相同的功能

1329
00:53:35,490 --> 00:53:38,680
来执行这些重写步骤，

1330
00:53:38,680 --> 00:53:39,850
我们获得了与传统的 GCC 一样的好处

1331
00:53:39,850 --> 00:53:42,850
客户端

1332
00:53:42,850 --> 00:53:44,890
查询优化器再次如此，但他们

1333
00:53:44,890 --> 00:53:47,200
不必写，因为他们将

1334
00:53:47,200 --> 00:53:49,900
UDF 转换为关系代数形式 他们

1335
00:53:49,900 --> 00:53:52,540
从 Microsoft 那里免费获得了所有这些，

1336
00:53:52,540 --> 00:53:55,510
您知道非常昂贵且非常好

1337
00:53:55,510 --> 00:54:01,570
查询优化器所以可以流畅地

1338
00:54:01,570 --> 00:54:06,670
支持 2019 年的

1339
00:54:06,670 --> 00:54:08,110
续集服务器和你们阅读的论文

1340
00:54:08,110 --> 00:54:11,410
弗洛伊德可以支持

1341
00:54:11,410 --> 00:54:14,290
T 续集中的大部分结构 所以声明和

1342
00:54:14,290 --> 00:54:15,790
设置选择语句 if-then-else

1343
00:54:15,790 --> 00:54:19,110
返回存在和其他设置运算

1344
00:54:19,110 --> 00:54:22,810
符 可以处理

1345
00:54:22,810 --> 00:54:25,210
对其他 UTS 的递归调用或嵌套调用 他们可以

1346
00:54:25,210 --> 00:54:27,580
处理所有可能的续集

1347
00:54:27,580 --> 00:54:30,280
类型 到目前为止你知道这篇论文在这里

1348
00:54:30,280 --> 00:54:34,330
和在 2019 年的生产序列中

1349
00:54:34,330 --> 00:54:37,300
他们不支持循环 他们不对循环进行

1350
00:54:37,300 --> 00:54:38,800
排序 while 循环 他们不

1351
00:54:38,800 --> 00:54:40,840
支持动态查询，因为在运行之前

1352
00:54:40,840 --> 00:54:42,520
你不知道查询会

1353
00:54:42,520 --> 00:54:45,580
是什么，而且你不

1354
00:54:45,580 --> 00:54:46,960
支持异常，这

1355
00:54:46,960 --> 00:54:49,120
在 UDF 中非常普遍，

1356
00:54:49,120 --> 00:54:52,780
所以你说很好，有

1357
00:54:52,780 --> 00:54:55,480
一些限制，但有多普遍

1358
00:54:55,480 --> 00:55:00,220
这些东西是否在

1359
00:55:00,220 --> 00:55:01,930
现实世界的应用程序中，所以在论文

1360
00:55:01,930 --> 00:55:04,300
中他们所做的是他们将排名前

1361
00:55:04,300 --> 00:55:07,900
100 的续集视为您的数据库运行并

1362
00:55:07,900 --> 00:55:10,450
为他们运行云，他们只是

1363
00:55:10,450 --> 00:55:12,850
看起来 在人们使用的所有标量 UDS

1364
00:55:12,850 --> 00:55:15,880
中，有

1365
00:55:15,880 --> 00:55:17,590
超过 85,000 个，

1366
00:55:17,590 --> 00:55:20,560
在这 85,000 个 UDF 中，他们

1367
00:55:20,560 --> 00:55:22,870
发现大约 60% 的人可能

1368
00:55:22,870 --> 00:55:24,840
与使用弗洛伊德的技术一致

1369
00:55:24,840 --> 00:55:27,190
，然后在论文中他们评估了

1370
00:55:27,190 --> 00:55:28,840
三个不同的客户 工作负载，

1371
00:55:28,840 --> 00:55:31,000
他们再次在这里

1372
00:55:31,000 --> 00:55:32,920
显示他们使用

1373
00:55:32,920 --> 00:55:36,840
我们的弗洛伊德兼容的百分比是多少，

1374
00:55:36,840 --> 00:55:39,010
所以你知道他们再次争辩说，

1375
00:55:39,010 --> 00:55:40,330
在那里使用

1376
00:55:40,330 --> 00:55:43,320
欺诈无法支持的循环和动态重建，

1377
00:55:43,320 --> 00:55:46,000
但对于我们 他们中的很大一部分

1378
00:55:46,000 --> 00:55:49,000
这是非常重要的，因此

1379
00:55:49,000 --> 00:55:50,410
您将为其中一些客户获得的加速带来的好处

1380
00:55:50,410 --> 00:55:52,630
非常

1381
00:55:52,630 --> 00:55:56,140
令人印象深刻，因此在某些情况下，

1382
00:55:56,140 --> 00:55:58,710
弗洛伊德实际上使事情变得更糟，我

1383
00:55:58,710 --> 00:56:01,150
忘记了为什么报纸会这样说 是这种

1384
00:56:01,150 --> 00:56:04,930
情况我不记得只是因为

1385
00:56:04,930 --> 00:56:06,910
我不记得是因为他可能

1386
00:56:06,910 --> 00:56:08,230
被优化并且运行时间更长，或者可能

1387
00:56:08,230 --> 00:56:10,000
是因为它掀起了我不记得的浪潮，

1388
00:56:10,000 --> 00:56:13,150
但仍然有一个你

1389
00:56:13,150 --> 00:56:16,180
知道很大，所以这是很长

1390
00:56:16,180 --> 00:56:19,630
的 x 轴只是

1391
00:56:19,630 --> 00:56:22,210
一个特定 UDF 的唯一调用，然后

1392
00:56:22,210 --> 00:56:23,470
根据他们在这些情况下再次获得的速度对其进行排序，

1393
00:56:23,470 --> 00:56:26,320


1394
00:56:26,320 --> 00:56:29,500
他们让你知道

1395
00:56:29,500 --> 00:56:33,280
UDF 的性能提高了 800 倍，

1396
00:56:33,280 --> 00:56:34,750
而无需更改任何应用程序

1397
00:56:34,750 --> 00:56:38,340
代码，这是闻所未闻的，因为

1398
00:56:38,340 --> 00:56:40,810


1399
00:56:40,810 --> 00:56:42,730
如果您购买新的 Hager，所有这些都像您知道钱一样，除非您的拥抱者

1400
00:56:42,730 --> 00:56:43,660
像您一样运行，就像您了解

1401
00:56:43,660 --> 00:56:45,010
计算机一样 像十九十九

1402
00:56:45,010 --> 00:56:46,960
然后你购买全新的计算机也许

1403
00:56:46,960 --> 00:56:48,280
你知道你会看到加速

1404
00:56:48,280 --> 00:56:50,860
但你知道它在哪里

1405
00:56:50,860 --> 00:56:55,330
有这样的事情你可以

1406
00:56:55,330 --> 00:56:57,310
为这些查询获得这样的巨大加速

1407
00:56:57,310 --> 00:57:00,250
而无需修改你的

1408
00:57:00,250 --> 00:57:02,980
应用程序 我

1409
00:57:02,980 --> 00:57:04,420
认为这说明了为什么

1410
00:57:04,420 --> 00:57:06,190
Microsoft 很快将其投入生产，

1411
00:57:06,190 --> 00:57:07,960
因为

1412
00:57:07,960 --> 00:57:10,060
您可以从中获得的性能优势如此巨大，

1413
00:57:10,060 --> 00:57:11,830
教练和我们今天讨论的内容

1414
00:57:11,830 --> 00:57:13,750
就像某些 在这种情况下，如果

1415
00:57:13,750 --> 00:57:15,490
您从解释引擎转到

1416
00:57:15,490 --> 00:57:17,050
编译引擎，您将获得巨大的

1417
00:57:17,050 --> 00:57:19,720
加速，但是当您知道这样的情况时，

1418
00:57:19,720 --> 00:57:21,490
这就是

1419
00:57:21,490 --> 00:57:22,690
与此类似的示例，您可以在其中

1420
00:57:22,690 --> 00:57:23,950
运行 相同的续集查询并

1421
00:57:23,950 --> 00:57:26,170
获得相同的加速，嗯，但

1422
00:57:26,170 --> 00:57:27,430
就像我们

1423
00:57:27,430 --> 00:57:29,140
在哥伦比亚论文中讨论的矢量化内容一样，

1424
00:57:29,140 --> 00:57:31,120
针对个别算法，它们

1425
00:57:31,120 --> 00:57:31,390
获得了

1426
00:57:31,390 --> 00:57:34,180
很大的加速，但这仅在

1427
00:57:34,180 --> 00:57:37,480
所有内容都位于 CPU 缓存中时发生，但是 当

1428
00:57:37,480 --> 00:57:39,730
你真的把东西放进去并且东西

1429
00:57:39,730 --> 00:57:41,200
超过了缓存，你实际上得到了一个

1430
00:57:41,200 --> 00:57:44,260
你知道溢出和 DRAM 你知道也许

1431
00:57:44,260 --> 00:57:45,670
是你看到的最好的

1432
00:57:45,670 --> 00:57:47,530
25% 25% 15%

1433
00:57:47,530 --> 00:57:50,740
像这样的改进 这是 800 X

1434
00:57:50,740 --> 00:57:53,830
这是巨大的 所以这是 这也是

1435
00:57:53,830 --> 00:57:55,750
我教这篇论文的原因，因为我认为

1436
00:57:55,750 --> 00:57:58,830
这实际上是一笔巨大的交易，

1437
00:57:58,830 --> 00:58:02,020
所以你可以想象

1438
00:58:02,020 --> 00:58:05,650
微软在这方面拥有专利，所以

1439
00:58:05,650 --> 00:58:09,970
你知道在这一点上有一些限制我

1440
00:58:09,970 --> 00:58:14,290
不是专利律师，但我我 想象一下，您

1441
00:58:14,290 --> 00:58:15,700
知道使用弗洛伊德技术和其他

1442
00:58:15,700 --> 00:58:19,090
数据库系统会很好，您

1443
00:58:19,090 --> 00:58:22,570
知道可能会导致一些法律问题，

1444
00:58:22,570 --> 00:58:24,310
但好消息是还有其他方法可以

1445
00:58:24,310 --> 00:58:26,710
进行内联，而无需

1446
00:58:26,710 --> 00:58:28,210
经过与弗洛伊德相同的转换步骤

1447
00:58:28,210 --> 00:58:31,780
，所以这 来自

1448
00:58:31,780 --> 00:58:33,700
今年

1449
00:58:33,700 --> 00:58:38,080
1 月在 cider 上发表的一篇关于如何将 UDF

1450
00:58:38,080 --> 00:58:41,020
转换为公用表表达式的论文，而

1451
00:58:41,020 --> 00:58:44,710
不是将 UDS 重写为关系

1452
00:58:44,710 --> 00:58:46,540
对象会话，然后将其内联

1453
00:58:46,540 --> 00:58:48,730
到查询计划中，而不是使用递归

1454
00:58:48,730 --> 00:58:50,590
将它们重写为 siegel 查询

1455
00:58:50,590 --> 00:58:54,310
CTE 递归注释

1456
00:58:54,310 --> 00:58:56,500
表达式，这

1457
00:58:56,500 --> 00:58:58,480
也让我们知道，除了你没有

1458
00:58:58,480 --> 00:59:00,340
做完全加权的流体之外，

1459
00:59:00,340 --> 00:59:03,160
它还让你支持迭代和

1460
00:59:03,160 --> 00:59:05,250
循环以及其他控制流概念，

1461
00:59:05,250 --> 00:59:09,000
我们的构造在

1462
00:59:09,000 --> 00:59:11,830
那个版本中是不可能的 弗洛伊德现在我会说

1463
00:59:11,830 --> 00:59:14,800
有一个更新版本的弗洛伊德弗洛伊德

1464
00:59:14,800 --> 00:59:15,850
tupelo 知道你是否想称之为

1465
00:59:15,850 --> 00:59:18,750
正在出版 他在 sigmod 的那一年，几天前我

1466
00:59:18,750 --> 00:59:20,800
得到了这篇论文的早期预览，

1467
00:59:20,800 --> 00:59:23,590
所以有时间在

1468
00:59:23,590 --> 00:59:25,360
这里讨论，在那个版本中，他们确实

1469
00:59:25,360 --> 00:59:28,630
支持循环，但到目前为止，

1470
00:59:28,630 --> 00:59:29,770
我在这里向您展示的这个特殊购买

1471
00:59:29,770 --> 00:59:31,870
是唯一一个 可以这样做，所以

1472
00:59:31,870 --> 00:59:33,100


1473
00:59:33,100 --> 00:59:36,970
另一组德国人关于这种方法的另一件有趣的事情是

1474
00:59:36,970 --> 00:59:40,870
，他们提出的重写技术

1475
00:59:40,870 --> 00:59:42,990
实际上可以

1476
00:59:42,990 --> 00:59:45,510
并且作为中间件层，

1477
00:59:45,510 --> 00:59:47,340
不需要与后数据库系统内在联系或紧密

1478
00:59:47,340 --> 00:59:48,930
耦合

1479
00:59:48,930 --> 00:59:52,080
暗示所以在这篇论文中，

1480
00:59:52,080 --> 00:59:53,490
他们表明他们正在 Postgres 上执行此操作，

1481
00:59:53,490 --> 00:59:55,920
但是您可以为 Oracle 执行此操作，

1482
00:59:55,920 --> 00:59:59,580
您可以为

1483
00:59:59,580 --> 01:00:00,900
任何支持您的游戏系统执行此操作，是的，并且还

1484
01:00:00,900 --> 01:00:02,930
支持递归漫画表达式，

1485
01:00:02,930 --> 01:00:05,280
所以让我们看看如何 他们

1486
01:00:05,280 --> 01:00:06,480
会这样做，以及它必须如何

1487
01:00:06,480 --> 01:00:08,520
与流体不同，因此它也将有五个

1488
01:00:08,520 --> 01:00:09,840
步骤，其中最后一步再次

1489
01:00:09,840 --> 01:00:11,369
通过查询优化器运行它，

1490
01:00:11,369 --> 01:00:15,810
但他们将花费更多的时间 无法

1491
01:00:15,810 --> 01:00:17,220
评论这是否更重要

1492
01:00:17,220 --> 01:00:19,230
或总体原则我这不是我的

1493
01:00:19,230 --> 01:00:22,320
领域它只是似乎是一种不同的

1494
01:00:22,320 --> 01:00:24,440
方法来结束

1495
01:00:24,440 --> 01:00:26,610
类似的最终结果您可以排列

1496
01:00:26,610 --> 01:00:29,040
这些 UDS 所以我们要去 逐一完成

1497
01:00:29,040 --> 01:00:30,750
每一个，但基本上我们

1498
01:00:30,750 --> 01:00:34,740
从我们的 PL 续集或 PL PG

1499
01:00:34,740 --> 01:00:38,610
续集 UDS 开始，它们会有更多

1500
01:00:38,610 --> 01:00:40,680
的任意迭代控制流，

1501
01:00:40,680 --> 01:00:43,440
所以你知道超越

1502
01:00:43,440 --> 01:00:45,780
我能做的事情，然后在

1503
01:00:45,780 --> 01:00:48,060
我们要做的第一步是将它们转换

1504
01:00:48,060 --> 01:00:51,180
成 SSA，这将把它转换

1505
01:00:51,180 --> 01:00:55,609
成一个使用基于 go-to 的控制流的程序，

1506
01:00:55,609 --> 01:00:58,560
然后我们将把它移交

1507
01:00:58,560 --> 01:01:00,660
出去，现在将 SSA 形式转换为

1508
01:01:00,660 --> 01:01:03,600
管理规范形式 这

1509
01:01:03,600 --> 01:01:05,960
将为我们提供一个相互尾递归的

1510
01:01:05,960 --> 01:01:11,820
函数，然后我们将进行转换，将

1511
01:01:11,820 --> 01:01:13,440
我们在这里所做的类型递归

1512
01:01:13,440 --> 01:01:15,150
转换为尾递归，

1513
01:01:15,150 --> 01:01:17,220
实际上我们可以

1514
01:01:17,220 --> 01:01:19,740
使用 with recursive 命令将其重写到 CTE 中，

1515
01:01:19,740 --> 01:01:21,570
现在我们再次 有一个巨大的

1516
01:01:21,570 --> 01:01:22,950
续集 l 声明，就像我们对弗洛伊德所做的那样

1517
01:01:22,950 --> 01:01:24,750
，然后我们把它推给我们的

1518
01:01:24,750 --> 01:01:27,869
优化器，所以对于这个，我们

1519
01:01:27,869 --> 01:01:30,480
将在 NP OPG 续集中展示一个例子，

1520
01:01:30,480 --> 01:01:32,850
所以它再次与

1521
01:01:32,850 --> 01:01:34,740
T Seagle 不同，但正如你所看到的，它大致

1522
01:01:34,740 --> 01:01:36,810
看起来是 相同的区别是我

1523
01:01:36,810 --> 01:01:38,369


1524
01:01:38,369 --> 01:01:41,220
在开始之外单独声明我的变量，在 T 续集你给我们所有

1525
01:01:41,220 --> 01:01:43,500
你在开始之后声明它们，

1526
01:01:43,500 --> 01:01:44,850
所以它就像这样的细微差别，

1527
01:01:44,850 --> 01:01:45,960
但在高层次上仍然是同样的

1528
01:01:45,960 --> 01:01:48,869
事情，所以这将是 幂

1529
01:01:48,869 --> 01:01:50,840
函数，我们给出

1530
01:01:50,840 --> 01:01:52,790
了一个基值，然后我们给出了一个

1531
01:01:52,790 --> 01:01:54,260
指数，然后我们将把它取

1532
01:01:54,260 --> 01:01:55,880
到 n 次方，所以原谅斧头

1533
01:01:55,880 --> 01:01:58,520
在 n 次方上滴答作响，所以

1534
01:01:58,520 --> 01:02:00,980
我们这样做的方式只是做一个 while 循环

1535
01:02:00,980 --> 01:02:02,570
对于小于 n 次方的迭代次数

1536
01:02:02,570 --> 01:02:04,370
，我们将

1537
01:02:04,370 --> 01:02:06,980
乘以该值本身，

1538
01:02:06,980 --> 01:02:10,810
然后返回它，让我记录它

1539
01:02:10,810 --> 01:02:15,200
再次将其转换为 SSA 形式，这就是

1540
01:02:15,200 --> 01:02:17,630
现在所表达的函数的控制流

1541
01:02:17,630 --> 01:02:21,080
带有首选语句和

1542
01:02:21,080 --> 01:02:22,940
SSA 的另一个方面是

1543
01:02:22,940 --> 01:02:27,500
块内的每个变量而

1544
01:02:27,500 --> 01:02:29,510
不是程序只能分配

1545
01:02:29,510 --> 01:02:32,930
一次所以我不是编译器人但

1546
01:02:32,930 --> 01:02:34,490
我的理解但这

1547
01:02:34,490 --> 01:02:36,290
就是编译器在

1548
01:02:36,290 --> 01:02:39,500
内部所做的事情 他们转换了他们的

1549
01:02:39,500 --> 01:02:41,930
编程语言，所以在这种情况下，

1550
01:02:41,930 --> 01:02:43,400
在这里编写与幂函数相同的东西，

1551
01:02:43,400 --> 01:02:45,050
我分配我的变量，然后

1552
01:02:45,050 --> 01:02:47,390
我使用 go to is 跳转到

1553
01:02:47,390 --> 01:02:49,820
出口以返回值或循环

1554
01:02:49,820 --> 01:02:52,150
并使用循环体

1555
01:02:52,150 --> 01:02:56,300
好的，现在我们在 SSA 形式中有我们的 UDF，

1556
01:02:56,300 --> 01:02:58,730
我们想将它转换

1557
01:02:58,730 --> 01:03:01,730
为普通形式，对于这里的这个，这

1558
01:03:01,730 --> 01:03:03,590
是相互递归调用，

1559
01:03:03,590 --> 01:03:06,590
我们只是在执行递归

1560
01:03:06,590 --> 01:03:08,780
调用另一个函数总是

1561
01:03:08,780 --> 01:03:11,930
在尾部 在

1562
01:03:11,930 --> 01:03:14,930
任何功能块的底部，所以我们调用

1563
01:03:14,930 --> 01:03:16,700
power 我们设置一些变量然后调用

1564
01:03:16,700 --> 01:03:18,560
我们的 while 循环然后它

1565
01:03:18,560 --> 01:03:21,950
旋转，在这种情况下这是

1566
01:03:21,950 --> 01:03:24,500
我们的退出退出子句，

1567
01:03:24,500 --> 01:03:26,690
如果我们添加了 e  nough 大于

1568
01:03:26,690 --> 01:03:29,000
和大于等于 n 这是

1569
01:03:29,000 --> 01:03:31,210
您想要

1570
01:03:31,210 --> 01:03:34,340
将值乘以自身的次数，如果我们

1571
01:03:34,340 --> 01:03:36,050
满足这个约束，那么我们就中断

1572
01:03:36,050 --> 01:03:37,460
了，所以这本质上是这里的 return

1573
01:03:37,460 --> 01:03:39,650
语句，否则我们跳到这里

1574
01:03:39,650 --> 01:03:41,420
，实际上 做计算，然后

1575
01:03:41,420 --> 01:03:47,210
再循环回来，所以现在

1576
01:03:47,210 --> 01:03:50,510
在正常形式中，我们可以将它

1577
01:03:50,510 --> 01:03:53,840
转换为使用直接递归，所以我在

1578
01:03:53,840 --> 01:03:55,070
某种程度上简化了这里的步骤，但现在我

1579
01:03:55,070 --> 01:03:58,460
现在结合了 while 野块

1580
01:03:58,460 --> 01:04:00,500
和 拖曳稳定运行块中的主体块

1581
01:04:00,500 --> 01:04:02,630
，我在其中执行所有相同的

1582
01:04:02,630 --> 01:04:04,520
计算

1583
01:04:04,520 --> 01:04:06,570


1584
01:04:06,570 --> 01:04:10,020


1585
01:04:10,020 --> 01:04:11,190


1586
01:04:11,190 --> 01:04:13,230


1587
01:04:13,230 --> 01:04:17,970
可以

1588
01:04:17,970 --> 01:04:21,660
使用这个命令式代码并将其

1589
01:04:21,660 --> 01:04:24,870
转换为一个巨大的秘密单个

1590
01:04:24,870 --> 01:04:27,360
语句，CT 很容易看到，所以

1591
01:04:27,360 --> 01:04:31,020
这看起来有点粗糙，但

1592
01:04:31,020 --> 01:04:32,070
简要地思考一下这里是

1593
01:04:32,070 --> 01:04:34,530
第一部分 执行一些初始化的函数，

1594
01:04:34,530 --> 01:04:37,170
所以我正在设置

1595
01:04:37,170 --> 01:04:39,390
我的我发誓要跟踪枚举时间

1596
01:04:39,390 --> 01:04:42,120
我已经循环设置了 P bio 来

1597
01:04:42,120 --> 01:04:44,430
跟踪你知道运行总数，因为我

1598
01:04:44,430 --> 01:04:48,600
做我的我的理由我认为 强大的力量

1599
01:04:48,600 --> 01:04:50,430
，这只是这里的 Select 语句

1600
01:04:50,430 --> 01:04:52,560
，它只是将一些

1601
01:04:52,560 --> 01:04:54,090
变量设置为 CTE 的初始化子句

1602
01:04:54,090 --> 01:04:56,640
，但是然后联合所有它

1603
01:04:56,640 --> 01:04:59,640
允许我一遍又一遍地调用相同的查询

1604
01:04:59,640 --> 01:05:02,640
并获得

1605
01:05:02,640 --> 01:05:04,920
递归的礼物 我们

1606
01:05:04,920 --> 01:05:08,490
需要的调用，所以这里的所有这些都被合并

1607
01:05:08,490 --> 01:05:10,560
到这个续集语句中，

1608
01:05:10,560 --> 01:05:13,290
它执行我们需要的逻辑，

1609
01:05:13,290 --> 01:05:16,380
所以如果我已经超过了我的数字

1610
01:05:16,380 --> 01:05:19,850
迭代，那么我这个东西评估

1611
01:05:19,850 --> 01:05:22,200
这个东西会评估为假

1612
01:05:22,200 --> 01:05:25,050
，然后 我可以打破然后所有

1613
01:05:25,050 --> 01:05:27,180
这些都在这里像这样这有点

1614
01:05:27,180 --> 01:05:28,860
令人困惑但是这里的调用

1615
01:05:28,860 --> 01:05:31,230
是

1616
01:05:31,230 --> 01:05:33,240
我们定义的属性的名称但是

1617
01:05:33,240 --> 01:05:34,140
当你加上引号时名称是调用问号

1618
01:05:34,140 --> 01:05:36,120
双引号 ks 以

1619
01:05:36,120 --> 01:05:37,950
确保它是 sheena 处理此

1620
01:05:37,950 --> 01:05:41,130
选票等于语法，因此我们使用

1621
01:05:41,130 --> 01:05:43,080
该变量来决定是 false

1622
01:05:43,080 --> 01:05:44,760
还是 true 是否继续调用自己

1623
01:05:44,760 --> 01:05:46,800
，然后当这件事评估为

1624
01:05:46,800 --> 01:05:48,810
false 时，我的程序中断了换行

1625
01:05:48,810 --> 01:05:51,210
中断了我 从我所有的递归调用中解脱出来，

1626
01:05:51,210 --> 01:05:53,880
并在

1627
01:05:53,880 --> 01:05:57,090
此处生成 Select 语句的输出，因此

1628
01:05:57,090 --> 01:05:59,940
这与弗洛伊德所做的有很大不同，

1629
01:05:59,940 --> 01:06:01,320
但您最终会

1630
01:06:01,320 --> 01:06:02,820
得到相同的结果，您

1631
01:06:02,820 --> 01:06:05,820
现在可以在任意 UDF 中内

1632
01:06:05,820 --> 01:06:08,160
联实际上有四个 循环，您

1633
01:06:08,160 --> 01:06:09,390
使用递归

1634
01:06:09,390 --> 01:06:13,140
递归获得四个循环，并在查询中成为其中之一，

1635
01:06:13,140 --> 01:06:16,800
因此此时尚不清楚是否

1636
01:06:16,800 --> 01:06:17,670


1637
01:06:17,670 --> 01:06:22,609
产生了比弗洛伊德更优化的计划

1638
01:06:22,609 --> 01:06:25,680
，该评估

1639
01:06:25,680 --> 01:06:28,799
尚未完成，这也不

1640
01:06:28,799 --> 01:06:30,359
支持动态 结构续集查询

1641
01:06:30,359 --> 01:06:33,150
，不支持例外，

1642
01:06:33,150 --> 01:06:34,890
但这是回馈给你的，我们

1643
01:06:34,890 --> 01:06:36,869
现在正在与 Karthik 和

1644
01:06:36,869 --> 01:06:39,420
另一个友好的德国人 Torsten 交谈

1645
01:06:39,420 --> 01:06:41,910
这使得我写了这篇

1646
01:06:41,910 --> 01:06:43,770
文章我们正在研究

1647
01:06:43,770 --> 01:06:46,710
将所有这些与

1648
01:06:46,710 --> 01:06:50,010
UTS 效果的编译内容进行比较

1649
01:06:50,010 --> 01:06:52,079


1650
01:06:52,079 --> 01:06:54,270


1651
01:06:54,270 --> 01:06:56,400
发生了什么 所以这是

1652
01:06:56,400 --> 01:06:57,540
正在进行的研究 我们正在卡纳基探索什么

1653
01:06:57,540 --> 01:07:02,460


1654
01:07:02,460 --> 01:07:03,540


1655
01:07:03,540 --> 01:07:06,059


1656
01:07:06,059 --> 01:07:08,099


1657
01:07:08,099 --> 01:07:11,430
正在

1658
01:07:11,430 --> 01:07:12,900
缩放您想要

1659
01:07:12,900 --> 01:07:15,480
迭代调用的次数并继续生成您知道

1660
01:07:15,480 --> 01:07:19,260
提高基值，因此黑

1661
01:07:19,260 --> 01:07:21,299
线与原始 UDF 相同，

1662
01:07:21,299 --> 01:07:24,420
然后红线与 CTE 相同，因此

1663
01:07:24,420 --> 01:07:26,730
您大致了解 与 UDF 调用

1664
01:07:26,730 --> 01:07:28,859
相比，性能有 40% 到 50% 的

1665
01:07:28,859 --> 01:07:34,170
好处，并且再次从

1666
01:07:34,170 --> 01:07:36,480
这里的这种情况下，对于这个特定

1667
01:07:36,480 --> 01:07:40,950
示例，您不知道

1668
01:07:40,950 --> 01:07:42,690
优化器选择坏计划没有问题，

1669
01:07:42,690 --> 01:07:45,000
因为您不

1670
01:07:45,000 --> 01:07:46,829
知道基数 ity UDF 的这只是

1671
01:07:46,829 --> 01:07:49,500
向您展示了

1672
01:07:49,500 --> 01:07:51,450
使用

1673
01:07:51,450 --> 01:07:55,020
递归调用与使用 UDF 相比可以从纯粹的性能收益中

1674
01:07:55,020 --> 01:07:57,299
获得的收益，因此您获得收益的地方

1675
01:07:57,299 --> 01:07:58,859
是因为在后置休息的情况下，正如我

1676
01:07:58,859 --> 01:08:02,730
所说的所有个人 行

1677
01:08:02,730 --> 01:08:05,640
是 UDF 中的命令

1678
01:08:05,640 --> 01:08:06,990
转换为选择语句

1679
01:08:06,990 --> 01:08:08,940
，然后将其发送到解析器或

1680
01:08:08,940 --> 01:08:10,710
绑定器和优化器核心星球

1681
01:08:10,710 --> 01:08:13,049
并执行您知道的每一

1682
01:08:13,049 --> 01:08:14,490
行，因此基本上对于

1683
01:08:14,490 --> 01:08:16,049
每一行 UDF 都有投票 一个

1684
01:08:16,049 --> 01:08:18,179
查询，所以这表明

1685
01:08:18,179 --> 01:08:22,020
通过

1686
01:08:22,020 --> 01:08:26,359
能够作为递归 CTE 来避免所有开销是一个巨大的胜利，

1687
01:08:26,359 --> 01:08:27,559


1688
01:08:27,559 --> 01:08:32,389
所以我说这些结果是巨大

1689
01:08:32,389 --> 01:08:34,250
的，以防弗洛伊德和佛罗伦萨的收益

1690
01:08:34,250 --> 01:08:36,529
非常重要，CTE 方法

1691
01:08:36,529 --> 01:08:39,469
是 仍然很新，所以不清楚

1692
01:08:39,469 --> 01:08:40,670
你想

1693
01:08:40,670 --> 01:08:42,170
从污染中获得多少好处 早期结果

1694
01:08:42,170 --> 01:08:44,448
非常有希望，正如我所说，

1695
01:08:44,448 --> 01:08:49,009
给我看另一个例子，除非

1696
01:08:49,009 --> 01:08:50,599
有人在做 一些愚蠢的事情，

1697
01:08:50,599 --> 01:08:52,189
比如在

1698
01:08:52,189 --> 01:08:54,319
你的查询引擎的 XP 中间挖掘比特币，同时你

1699
01:08:54,319 --> 01:08:55,729
运行查询，比如向你展示

1700
01:08:55,729 --> 01:08:57,408
你可以做得很好的事情，你必须

1701
01:08:57,408 --> 01:08:58,698
改变你的应用程序的任何东西，你

1702
01:08:58,698 --> 01:09:00,920
得到了 500 倍的改进，这是

1703
01:09:00,920 --> 01:09:04,279
非常重要的 正如我所说

1704
01:09:04,279 --> 01:09:07,368
，我们正在探索的另一种方法是

1705
01:09:07,368 --> 01:09:10,069
如何以

1706
01:09:10,069 --> 01:09:11,899
与查询相同的方式将 UDF 编译为机器代码，

1707
01:09:11,899 --> 01:09:16,609
这并不能解决优化器

1708
01:09:16,609 --> 01:09:18,259
成本模型问题，就像您仍然

1709
01:09:18,259 --> 01:09:21,349
需要使用 CTE 或 弗洛伊德推动获得

1710
01:09:21,349 --> 01:09:25,328
这种好处，但对于某些

1711
01:09:25,328 --> 01:09:28,578
无法内联的计算，这实际上

1712
01:09:28,578 --> 01:09:30,349
可能是更好的方法，但我认为

1713
01:09:30,349 --> 01:09:33,529
真正的最终解决方案将是

1714
01:09:33,529 --> 01:09:35,299
一种混合方法，有时

1715
01:09:35,299 --> 01:09:37,099
有些保时捷我有一部分 你们中的人

1716
01:09:37,099 --> 01:09:38,359
是否必须排队，另一部分

1717
01:09:38,359 --> 01:09:40,670
可能是有说服力的，你如何平衡所有

1718
01:09:40,670 --> 01:09:41,988
这些以及你在哪里做出

1719
01:09:41,988 --> 01:09:44,630
切入点是

1720
01:09:44,630 --> 01:09:47,779
我想探索的有趣方向，好吧，

1721
01:09:47,779 --> 01:09:52,578
伙计们，所以下一个星期 k 将是

1722
01:09:52,578 --> 01:09:55,579
我们本学期的最后一堂课，

1723
01:09:55,579 --> 01:09:59,360
这将是数据库中反复出现的主题

1724
01:09:59,360 --> 01:10:02,929
，例如

1725
01:10:02,929 --> 01:10:04,789
新港出现时会发生什么，以及

1726
01:10:04,789 --> 01:10:06,170
如何让您的数据库系统

1727
01:10:06,170 --> 01:10:08,179
在新港出现时经常利用它

1728
01:10:08,179 --> 01:10:13,070
现在它是

1729
01:10:13,070 --> 01:10:14,690
机器学习可能是最热门的事情，

1730
01:10:14,690 --> 01:10:16,579
所以有很多是为机器学习量身定制的，

1731
01:10:16,579 --> 01:10:18,440
但传统上你

1732
01:10:18,440 --> 01:10:20,480
知道英特尔或磁盘制造商或

1733
01:10:20,480 --> 01:10:22,730
任何推出新硬件的人，其中

1734
01:10:22,730 --> 01:10:25,400
一个明显的目标是

1735
01:10:25,400 --> 01:10:27,829
数据库系统，因为没有人 曾经

1736
01:10:27,829 --> 01:10:29,119
抱怨你让你的数据变得如此

1737
01:10:29,119 --> 01:10:32,530
快所以下一堂课我们希望看到

1738
01:10:32,530 --> 01:10:36,469
你一些更新的这个或更新的

1739
01:10:36,469 --> 01:10:38,100
数据库硬件

1740
01:10:38,100 --> 01:10:44,970
对不起，

1741
01:10:44,970 --> 01:10:50,900
我们设计架构的方式过去了，伙计们

1742
01:10:52,520 --> 01:11:21,989
[音乐]

