1
00:00:01,300 --> 00:00:05,129
[音乐]

2
00:00:05,200 --> 00:00:05,930
[鼓掌]

3
00:00:05,930 --> 00:00:08,630
[音乐]

4
00:00:08,630 --> 00:00:10,020
[鼓掌]

5
00:00:10,020 --> 00:00:11,240
[音乐]

6
00:00:11,240 --> 00:00:13,500
今天我们要讨论的是查询

7
00:00:13,500 --> 00:00:15,929
优化，这是数据库系统中一个非常重要的

8
00:00:15,929 --> 00:00:17,970
话题，所以我又回到

9
00:00:17,970 --> 00:00:20,490
我家了

10
00:00:20,490 --> 00:00:22,350
在我们进行过程中提出问题，

11
00:00:22,350 --> 00:00:27,119
因此当我们说查询

12
00:00:27,119 --> 00:00:30,060
优化时，在高层次上的想法是

13
00:00:30,060 --> 00:00:33,750
，我们希望采用

14
00:00:33,750 --> 00:00:35,370
像 sequel 这样的声明式语言编写的查询，

15
00:00:35,370 --> 00:00:38,969
然后我们希望将其

16
00:00:38,969 --> 00:00:42,120
转换为数据库系统执行的执行计划

17
00:00:42,120 --> 00:00:45,420
可以执行等

18
00:00:45,420 --> 00:00:47,309
查询优化的想法是我们

19
00:00:47,309 --> 00:00:50,879
想要找到一个正确的执行计划

20
00:00:50,879 --> 00:00:53,399
，该计划可能具有最低的

21
00:00:53,399 --> 00:00:55,949
成本，所以我在这里强调的两个词

22
00:00:55,949 --> 00:00:58,859
是正确的，成本

23
00:00:58,859 --> 00:01:01,079
正确是很明显的，它没有

24
00:01:01,079 --> 00:01:03,600
帮助 如果我们找到一个非常快速的计划

25
00:01:03,600 --> 00:01:06,540
，最终计算出错误的答案

26
00:01:06,540 --> 00:01:08,040
，为我们的查询返回错误的结果，

27
00:01:08,040 --> 00:01:10,500
这样对我们根本没有帮助，

28
00:01:10,500 --> 00:01:13,130
并且术语成本是引号，

29
00:01:13,130 --> 00:01:17,369
因为成本将是这个相对

30
00:01:17,369 --> 00:01:20,460
指标，而不是 没有 essaryly 绑定到一个

31
00:01:20,460 --> 00:01:22,290
现实世界的指标它只是

32
00:01:22,290 --> 00:01:23,930
数据系统会说

33
00:01:23,930 --> 00:01:26,330
这是我执行的最佳查询

34
00:01:26,330 --> 00:01:30,320
所以成本可能是在

35
00:01:30,320 --> 00:01:33,750
执行时间方面的货币成本

36
00:01:33,750 --> 00:01:36,540
在你去的页面上运行之后

37
00:01:36,540 --> 00:01:38,790
云系统它可能在内存使用

38
00:01:38,790 --> 00:01:40,799
中可能是任何可能的

39
00:01:40,799 --> 00:01:43,259
事情，但在高层次上，你知道

40
00:01:43,259 --> 00:01:45,180


41
00:01:45,180 --> 00:01:46,890
数据库系统知道它想要

42
00:01:46,890 --> 00:01:50,490
优化的一些目标函数，所以查询优化器

43
00:01:50,490 --> 00:01:52,229
将是最难的部分 我们将

44
00:01:52,229 --> 00:01:54,299
不得不接触或我们将

45
00:01:54,299 --> 00:01:56,100
不得不在数据库系统中实现的一个组件，

46
00:01:56,100 --> 00:02:00,390
因为找到一个你知道的最优近

47
00:02:00,390 --> 00:02:03,750
最优查询将是非常

48
00:02:03,750 --> 00:02:05,070
具有挑战性的它会被

49
00:02:05,070 --> 00:02:08,699
证明是一个 np-complete 问题所以这

50
00:02:08,699 --> 00:02:10,348
意味着虽然

51
00:02:10,348 --> 00:02:12,750
我们将要构建的组件的名称是您

52
00:02:12,750 --> 00:02:15,450
调用的查询优化器几乎

53
00:02:15,450 --> 00:02:17,340
永远无法找到最佳

54
00:02:17,340 --> 00:02:19,980
计划，因为

55
00:02:19,980 --> 00:02:23,430
查看所有可能的溶胶需要太长时间 使用

56
00:02:23,430 --> 00:02:25,110
所有可能的查询计划并选择

57
00:02:25,110 --> 00:02:29,010
最好的，所以这些即将到来的

58
00:02:29,010 --> 00:02:31,080
讲座真正要讲的是

59
00:02:31,080 --> 00:02:35,310
我们将使用的技术来简化和减少

60
00:02:35,310 --> 00:02:36,870
搜索空间，因此它不是一个

61
00:02:36,870 --> 00:02:39,420
详尽的搜索和我们可以

62
00:02:39,420 --> 00:02:42,930
用来估计什么的技术 计划成本

63
00:02:42,930 --> 00:02:44,430
实际上不必真正

64
00:02:44,430 --> 00:02:46,680
执行它所以让我们更有意义，因为

65
00:02:46,680 --> 00:02:47,880
我们进一步讨论

66
00:02:47,880 --> 00:02:51,120
成本模型，但考虑

67
00:02:51,120 --> 00:02:54,060
这个的方法是，如果我们需要问我

68
00:02:54,060 --> 00:02:56,430
执行其中一个的成本是多少 一个

69
00:02:56,430 --> 00:02:58,200
获得真实成本的查询计划，我们可以只

70
00:02:58,200 --> 00:03:00,239
执行查询，但是现在如果你想

71
00:03:00,239 --> 00:03:01,560
查看成千上万个

72
00:03:01,560 --> 00:03:03,270
可能的不同查询计划，这

73
00:03:03,270 --> 00:03:05,489
对我们来说是不可行的，所以我们需要一种

74
00:03:05,489 --> 00:03:08,250
方法来估计它，这个成本

75
00:03:08,250 --> 00:03:11,010
是 也将成为

76
00:03:11,010 --> 00:03:13,440
数据系统用来

77
00:03:13,440 --> 00:03:15,239
确定一个计划是否优于另一个计划的内部指标

78
00:03:15,239 --> 00:03:17,880
，它可能

79
00:03:17,880 --> 00:03:21,360
不一定与您知道

80
00:03:21,360 --> 00:03:25,140
挂钟时间我们的实际成本有关，所以我

81
00:03:25,140 --> 00:03:26,519
只是设置了我们，但是

82
00:03:26,519 --> 00:03:27,630
当我们开始安装查询

83
00:03:27,630 --> 00:03:30,959
优化时，我们的意思是在接下来的三

84
00:03:30,959 --> 00:03:33,120
周内将

85
00:03:33,120 --> 00:03:37,049
在这四个查询优化中讨论很多不同的事情，

86
00:03:37,049 --> 00:03:38,940
所以我说正如我

87
00:03:38,940 --> 00:03:41,130
所说的 上节课结束 我将完全

88
00:03:41,130 --> 00:03:44,310
承认查询优化

89
00:03:44,310 --> 00:03:46,530
是我最不了解的数据库系统的一个方面

90
00:03:46,530 --> 00:03:48,090
，我一直在

91
00:03:48,090 --> 00:03:51,360
努力学习更多，所以今年

92
00:03:51,360 --> 00:03:53,430
我们扩大了讨论范围，包括

93
00:03:53,430 --> 00:03:57,390
一个额外的讲座

94
00:03:57,390 --> 00:03:59,579
除了

95
00:03:59,579 --> 00:04:01,860
传统的两种方法

96
00:04:01,860 --> 00:04:02,970
之外的一些额外的查询优化方法 我们将在下一课的本课中讨论的两种方法 所以我们在

97
00:04:02,970 --> 00:04:05,100
接下来的四节课中接下来的三周要去的地方

98
00:04:05,100 --> 00:04:06,750


99
00:04:06,750 --> 00:04:09,329
是我们将花

100
00:04:09,329 --> 00:04:10,980
时间 开始讨论如何

101
00:04:10,980 --> 00:04:13,560
实现查询优化器

102
00:04:13,560 --> 00:04:15,030
本质上搜索策略

103
00:04:15,030 --> 00:04:16,168
是这样的，所以它

104
00:04:16,168 --> 00:04:18,329
内部的搜索引擎看起来像这样然后我们将

105
00:04:18,329 --> 00:04:20,010
讨论如何进行计划重写

106
00:04:20,010 --> 00:04:22,260
查询 阅读计划枚举，

107
00:04:22,260 --> 00:04:25,100
然后我们将讨论在自适应查询优化方面

108
00:04:25,100 --> 00:04:28,100
更复杂的技术，

109
00:04:28,100 --> 00:04:31,220


110
00:04:31,220 --> 00:04:33,410
最后我们将讨论成本

111
00:04:33,410 --> 00:04:36,890
模型，因此我将简要介绍一下

112
00:04:36,890 --> 00:04:38,210
我认为的所有成本模型是什么 在

113
00:04:38,210 --> 00:04:39,770
本次讲座中有点，但在我们设计完所有这些之后，这将是

114
00:04:39,770 --> 00:04:41,750
最后要说

115
00:04:41,750 --> 00:04:44,060
的好话 我们在

116
00:04:44,060 --> 00:04:46,310
这里谈论的搜索内容 成本模型

117
00:04:46,310 --> 00:04:51,970
已经用于指导搜索

118
00:04:51,970 --> 00:04:54,440
所以今天我们主要是 谈论

119
00:04:54,440 --> 00:04:56,540
优化搜索策略，因为

120
00:04:56,540 --> 00:04:58,850
这是

121
00:04:58,850 --> 00:05:04,790
您需要拥有的两个主要部分之一，然后将

122
00:05:04,790 --> 00:05:07,160
继续讨论这些其他这些

123
00:05:07,160 --> 00:05:10,100
其他主题，所以今天再次正如我

124
00:05:10,100 --> 00:05:11,450
所说的那样开始谈论搜索

125
00:05:11,450 --> 00:05:12,800
策略，因为那是 最

126
00:05:12,800 --> 00:05:14,600
重要的是，这

127
00:05:14,600 --> 00:05:15,530
是您实际

128
00:05:15,530 --> 00:05:18,440
实现查询优化器所需的基础，然后

129
00:05:18,440 --> 00:05:20,420
我们将介绍人们

130
00:05:20,420 --> 00:05:22,310


131
00:05:22,310 --> 00:05:25,640
在过去 50 40 年中尝试构建查询优化器的不同方法 50

132
00:05:25,640 --> 00:05:29,990
年后，这将激发我们为什么

133
00:05:29,990 --> 00:05:32,180
要使用更复杂的动态

134
00:05:32,180 --> 00:05:34,250
编程技术或 Cascades

135
00:05:34,250 --> 00:05:36,070
技术，你们在下一堂课上会读到这些技术，

136
00:05:36,070 --> 00:05:38,900
所以今天有点像

137
00:05:38,900 --> 00:05:40,490
一堆背景信息，

138
00:05:40,490 --> 00:05:44,150
然后引导到 现代

139
00:05:44,150 --> 00:05:48,640
实现，所以在高层次上

140
00:05:48,640 --> 00:05:53,000
，

141
00:05:53,000 --> 00:05:54,800
我们正在谈论的系统堆栈以及我

142
00:05:54,800 --> 00:05:56,270
所提到的系统

143
00:05:56,270 --> 00:05:58,550
前端看起来像这样，这

144
00:05:58,550 --> 00:05:59,840
就是我们的部分“ 现在在我们的

145
00:05:59,840 --> 00:06:02,300
系统中谈论，所以我们从

146
00:06:02,300 --> 00:06:04,640
应用程序发送给我们的续集查询开始，我们可以

147
00:06:04,640 --> 00:06:07,000
首先将其传递给续集重写器

148
00:06:07,000 --> 00:06:09,650
，这意味着它将转换

149
00:06:09,650 --> 00:06:12,440
续集字符串本身以对其进行注释或

150
00:06:12,440 --> 00:06:15,590
以某种方式修改它，这是

151
00:06:15,590 --> 00:06:17,360
这是可选的 并非所有系统都有

152
00:06:17,360 --> 00:06:19,370
这个 你有时

153
00:06:19,370 --> 00:06:21,160
会在进行

154
00:06:21,160 --> 00:06:23,060
分片的中间件系统中看到这个 有时可以重写

155
00:06:23,060 --> 00:06:26,270
续集查询以添加你知道去

156
00:06:26,270 --> 00:06:27,890
这个表或者我很抱歉去这个这个

157
00:06:27,890 --> 00:06:30,650
节点 ve  rsus 那个节点，

158
00:06:30,650 --> 00:06:32,390
但这有点像续集查询中的续集

159
00:06:32,390 --> 00:06:33,680
查询，只是修改

160
00:06:33,680 --> 00:06:35,870
续集查询，然后

161
00:06:35,870 --> 00:06:37,490
我们通过续集解析器运行续集查询

162
00:06:37,490 --> 00:06:39,390
，然后将

163
00:06:39,390 --> 00:06:42,240
吐出一个抽象语法树，其中

164
00:06:42,240 --> 00:06:44,550
只有标记 查询的字符串标记

165
00:06:44,550 --> 00:06:46,530
我不会有

166
00:06:46,530 --> 00:06:47,970
列名的表名的标记

167
00:06:47,970 --> 00:06:51,150
等等，然后现在我们将我们传递给

168
00:06:51,150 --> 00:06:54,420
绑定器，它在

169
00:06:54,420 --> 00:06:56,220
数据库系统的系统目录中进行查找以

170
00:06:56,220 --> 00:07:00,570
映射表名

171
00:07:00,570 --> 00:07:01,650
在代表查询的列名的查询中的引用

172
00:07:01,650 --> 00:07:03,540
到永恒的

173
00:07:03,540 --> 00:07:06,000
内部标识符中，因此这允许

174
00:07:06,000 --> 00:07:08,760
您获得列的类型，

175
00:07:08,760 --> 00:07:10,680
无论您

176
00:07:10,680 --> 00:07:13,140
在这些列中具有什么约束等等，

177
00:07:13,140 --> 00:07:14,730
然后活页夹将 然后吐出

178
00:07:14,730 --> 00:07:17,940
现在称为逻辑计划的内容，所以这是

179
00:07:17,940 --> 00:07:21,150
查询想要做什么的高级描述，

180
00:07:21,150 --> 00:07:23,700
对不起，我有一个选择

181
00:07:23,700 --> 00:07:26,370
查询想要访问表 foo 我的

182
00:07:26,370 --> 00:07:29,910
逻辑计划将是说 sca  n table

183
00:07:29,910 --> 00:07:32,340
foo 没有说我想如何扫描它

184
00:07:32,340 --> 00:07:35,430
只是说我想访问它然后我们

185
00:07:35,430 --> 00:07:37,470
可以采取该逻辑计划并将其传递

186
00:07:37,470 --> 00:07:40,110
给另一个称为

187
00:07:40,110 --> 00:07:42,510
树重写器的可选步骤，这又是逻辑

188
00:07:42,510 --> 00:07:45,240
计划中的逻辑计划 out 这些被

189
00:07:45,240 --> 00:07:46,890
认为是我们可以应用的启发式方法

190
00:07:46,890 --> 00:07:50,840
来操纵树的结构以

191
00:07:50,840 --> 00:07:53,190
进行一些优化，

192
00:07:53,190 --> 00:07:56,700
如果我们不需要

193
00:07:56,700 --> 00:07:58,620
估计我们想要进行的更改的成本，

194
00:07:58,620 --> 00:08:00,690
我们总是想做一些优化 就像这里的谓词

195
00:08:00,690 --> 00:08:02,910
下推一样，或者有时您会看到

196
00:08:02,910 --> 00:08:06,480
重写视图查询或 CT 以

197
00:08:06,480 --> 00:08:09,720
这种方式再次简化为嵌套查询，这

198
00:08:09,720 --> 00:08:12,420
完全是可选的，然后我们现在将其

199
00:08:12,420 --> 00:08:14,250
输入到我们的优化器中，

200
00:08:14,250 --> 00:08:16,710
并且在较高级别上我们会打电话给您，

201
00:08:16,710 --> 00:08:18,570
知道我们会 专注于基于成本的

202
00:08:18,570 --> 00:08:20,970
查询优化器，我们有一些

203
00:08:20,970 --> 00:08:23,480
成本估算，这些估算基于

204
00:08:23,480 --> 00:08:26,010
我们从数据库本身收集的统计信息

205
00:08:26,010 --> 00:08:28,380
，使我们能够预测

206
00:08:28,380 --> 00:08:29,820
或估算您知道

207
00:08:29,820 --> 00:08:31,410
特定查询计划的执行时间

208
00:08:31,410 --> 00:08:33,179
和 再次，这是我们可以

209
00:08:33,179 --> 00:08:35,250
枚举一堆选项并选择

210
00:08:35,250 --> 00:08:36,900
我们认为成本最低的一个计划的地方

211
00:08:36,900 --> 00:08:40,380
，因此一旦

212
00:08:40,380 --> 00:08:42,390
优化器完成了这一步，它就会

213
00:08:42,390 --> 00:08:44,039
拟合出一个适合的物理计划

214
00:08:44,039 --> 00:08:46,560


215
00:08:46,560 --> 00:08:49,110
现在就在我们的系统中执行它 然后我们

216
00:08:49,110 --> 00:08:50,790
讨论查询编译 我们采用那个

217
00:08:50,790 --> 00:08:51,980
物理计划

218
00:08:51,980 --> 00:08:53,839
然后我们使用我们有热电联产

219
00:08:53,839 --> 00:08:56,240
将它转换成特定领域的

220
00:08:56,240 --> 00:08:57,800
语言 然后我们编译成

221
00:08:57,800 --> 00:08:59,810
机器代码 但其他系统 你可以

222
00:08:59,810 --> 00:09:00,920
采取这个物理计划并立即开始

223
00:09:00,920 --> 00:09:02,720
解释它的附件

224
00:09:02,720 --> 00:09:06,260
我说这是一个

225
00:09:06,260 --> 00:09:09,079
高水平的今天和即将到来的

226
00:09:09,079 --> 00:09:10,790
讲座所以我们将

227
00:09:10,790 --> 00:09:12,620
主要关注这两部分

228
00:09:12,620 --> 00:09:14,240
树树作者 和续集重写的优化器，

229
00:09:14,240 --> 00:09:17,269
正如我所说的那样，大多数

230
00:09:17,269 --> 00:09:20,089
情况下并没有真正为

231
00:09:20,089 --> 00:09:23,480
优化而做，因为您这样做是为了

232
00:09:23,480 --> 00:09:28,220
重定向查询，或者是的，

233
00:09:28,220 --> 00:09:29,660
它们中的大多数就像控制播放内容一样，不是

234
00:09:29,660 --> 00:09:32,720
必需的 rily 用于执行的东西

235
00:09:32,720 --> 00:09:35,269
活页夹 你在那里没有真正的魔法

236
00:09:35,269 --> 00:09:37,579
它正在查找 rickie 表格 你

237
00:09:37,579 --> 00:09:38,810
知道查找电缆名称和

238
00:09:38,810 --> 00:09:41,449
类似的东西 所以现在让我们讨论

239
00:09:41,449 --> 00:09:43,399
逻辑和物理计划之间的区别，

240
00:09:43,399 --> 00:09:44,420
因为这会

241
00:09:44,420 --> 00:09:46,310
出现 当我们多次

242
00:09:46,310 --> 00:09:50,420
谈论查询优化器时

243
00:09:50,420 --> 00:09:51,740
，优化器试图做的本质上是

244
00:09:51,740 --> 00:09:54,350
尝试将查询本身的逻辑代数

245
00:09:54,350 --> 00:09:58,160
表达式映射到

246
00:09:58,160 --> 00:10:01,540
等效的物理代数表达式中

247
00:10:01,540 --> 00:10:04,579
，就像我说的逻辑计划会

248
00:10:04,579 --> 00:10:07,370
说我想访问 table food

249
00:10:07,370 --> 00:10:09,800
物理计划会说

250
00:10:09,800 --> 00:10:13,100
通过使用索引访问 table 你知道 XYZ

251
00:10:13,100 --> 00:10:16,190
访问 table food 使用方形扫描或

252
00:10:16,190 --> 00:10:18,199
二分搜索对实际表本身

253
00:10:18,199 --> 00:10:20,600
我说的是它的高一点

254
00:10:20,600 --> 00:10:22,279
区别在于物理计划

255
00:10:22,279 --> 00:10:23,839
告诉你你如何 实际上想要

256
00:10:23,839 --> 00:10:27,769
执行一个你知道查询本身

257
00:10:27,769 --> 00:10:29,779
但逻辑计划说这就是

258
00:10:29,779 --> 00:10:33,940
我想要梁的查询结果

259
00:10:33,940 --> 00:10:36,850
所以物理工厂 操作员本身

260
00:10:36,850 --> 00:10:39,440
将

261
00:10:39,440 --> 00:10:42,230
具有特定于物理

262
00:10:42,230 --> 00:10:44,060
属性和

263
00:10:44,060 --> 00:10:46,190
他们正在访问的数据的物理格式的低级信息，因此在

264
00:10:46,190 --> 00:10:48,470
某些情况下，物理操作员会

265
00:10:48,470 --> 00:10:51,860
知道它正在生成

266
00:10:51,860 --> 00:10:54,260
按给定列排序的数据或没有

267
00:10:54,260 --> 00:10:55,730
将对

268
00:10:55,730 --> 00:10:57,170
以某种方式压缩的数据进行操作 它可能

269
00:10:57,170 --> 00:10:58,959
需要将其解压缩为另一种

270
00:10:58,959 --> 00:11:01,459
方式 逻辑计划没有这个概念

271
00:11:01,459 --> 00:11:03,380
它只知道关系

272
00:11:03,380 --> 00:11:05,640
所以我们会看到一件重要的事情

273
00:11:05,640 --> 00:11:06,510
，当我们谈论时会出现

274
00:11:06,510 --> 00:11:08,900
级联下一个类是

275
00:11:08,900 --> 00:11:11,040


276
00:11:11,040 --> 00:11:13,980
从逻辑

277
00:11:13,980 --> 00:11:16,170
运算符到物理运算符的一对一映射并不总是如此，所以我的

278
00:11:16,170 --> 00:11:17,460
意思是就像在像访问表 foo 一样的情况下，

279
00:11:17,460 --> 00:11:19,440
我可以

280
00:11:19,440 --> 00:11:21,900
很容易地想象这将如何映射

281
00:11:21,900 --> 00:11:23,610
访问表食物的逻辑运算符，

282
00:11:23,610 --> 00:11:25,530
您知道顺序扫描访问

283
00:11:25,530 --> 00:11:27,660
表 foo 将是一对一的，但

284
00:11:27,660 --> 00:11:29,610
有时我们会有逻辑运算

285
00:11:29,610 --> 00:11:32,940
符，然后可以扩展为乘法

286
00:11:32,940 --> 00:11:35,790
物理运算符，同样您可以

287
00:11:35,790 --> 00:11:38,640
采用多个逻辑运算符并将

288
00:11:38,640 --> 00:11:40,410
它们合并为单个物理

289
00:11:40,410 --> 00:11:41,880
运算符这

290
00:11:41,880 --> 00:11:43,230
取决于数据库系统的实现

291
00:11:43,230 --> 00:11:45,060
通常您会看到逻辑运算符

292
00:11:45,060 --> 00:11:46,680
被分解为更多运算

293
00:11:46,680 --> 00:11:48,300
符，这比我的其他方式更常见

294
00:11:48,300 --> 00:11:52,920
像我

295
00:11:52,920 --> 00:11:56,460
这样的意见实际上是正确的，因此

296
00:11:56,460 --> 00:11:59,270
可以将具有逻辑顺序的逻辑连接合并到

297
00:11:59,270 --> 00:12:01,020
物理排序合并连接中，

298
00:12:01,020 --> 00:12:03,270
因为您正在这样做，您知道

299
00:12:03,270 --> 00:12:09,090
将连接和顺序放在一起，

300
00:12:09,090 --> 00:12:11,490
所以这是另一个重要的方面 关于

301
00:12:11,490 --> 00:12:14,760
我们在这里所做的再次依赖于

302
00:12:14,760 --> 00:12:16,100
关系代数

303
00:12:16,100 --> 00:12:18,300
等价的概念 这

304
00:12:18,300 --> 00:12:19,260
是我们在

305
00:12:19,260 --> 00:12:21,390
上学期的介绍课中介绍的内容，但

306
00:12:21,390 --> 00:12:24,410
基本思想是，由于我们知道

307
00:12:24,410 --> 00:12:26,700
交换性和结合

308
00:12:26,700 --> 00:12:29,220
性，因此关系的机会传递性属性

309
00:12:29,220 --> 00:12:32,130
我们知道的代数表达式我们可以

310
00:12:32,130 --> 00:12:33,480
定义规则，允许以

311
00:12:33,480 --> 00:12:36,300


312
00:12:36,300 --> 00:12:38,100
我们知道的方式对查询计划进行转换 最终

313
00:12:38,100 --> 00:12:40,200
结果等同于原始

314
00:12:40,200 --> 00:12:42,810
计划，所以在这种情况下，如果我

315
00:12:42,810 --> 00:12:45,510
在表 a B 和 C 之间进行自然连接

316
00:12:45,510 --> 00:12:49,470
，如果我先连接 B 和 C，然后获取

317
00:12:49,470 --> 00:12:51,120
该连接的结果，然后将其

318
00:12:51,120 --> 00:12:53,640
与井连接 这相当于我

319
00:12:53,640 --> 00:12:56,070
先加入 a 和 C，然后取出它

320
00:12:56,070 --> 00:12:58,770
的输出并加入 B，我

321
00:12:58,770 --> 00:13:00,090
可以这样做，因为这是一个内部

322
00:13:00,090 --> 00:13:02,880
联接或自然联接，其中我具有

323
00:13:02,880 --> 00:13:04,260
交换性属性，我可以

324
00:13:04,260 --> 00:13:06,540
以任何我想要的方式重新排序它们 或加入

325
00:13:06,540 --> 00:13:07,920
你不能退出你不能这样做，因为

326
00:13:07,920 --> 00:13:10,110
它们是不对称的，而这些东西

327
00:13:10,110 --> 00:13:11,340
它们是对称的，所以我可以

328
00:13:11,340 --> 00:13:13,680
按照我想要的任何顺序翻转它们，所以现在你

329
00:13:13,680 --> 00:13:14,850
可以看到优化器

330
00:13:14,850 --> 00:13:15,780
实际上要做什么 尝试

331
00:13:15,780 --> 00:13:19,230
是如果它知道它需要将表 a

332
00:13:19,230 --> 00:13:21,780
B 和 C 连接在一起，它会尝试

333
00:13:21,780 --> 00:13:23,490
找出正确的正确

334
00:13:23,490 --> 00:13:26,010
顺序我应该做什么，因为你知道先

335
00:13:26,010 --> 00:13:28,080
加入 B 和 C 或先加入 a 和 C

336
00:13:28,080 --> 00:13:29,010
等等，

337
00:13:29,010 --> 00:13:30,660
嘿可以 使用成本模型来估计

338
00:13:30,660 --> 00:13:33,000
这些连接顺序中的哪一个是 go

339
00:13:33,000 --> 00:13:36,870
为了最有效，那么现在你也可以

340
00:13:36,870 --> 00:13:38,490
考虑物理运算符

341
00:13:38,490 --> 00:13:40,860
我现在可以决定

342
00:13:40,860 --> 00:13:42,420
当你使用什么算法来实际

343
00:13:42,420 --> 00:13:43,650
执行这个联合时我

344
00:13:43,650 --> 00:13:45,390
要做我们之前讨论过的排序合并我

345
00:13:45,390 --> 00:13:47,580
想要吗 做我的并行哈希连接

346
00:13:47,580 --> 00:13:52,770
等等，所以对于这些讲座，你们中的大多数人

347
00:13:52,770 --> 00:13:54,540
都专注于分析查询，

348
00:13:54,540 --> 00:14:00,780
因为在这个世界上

349
00:14:00,780 --> 00:14:02,760
，找到一个

350
00:14:02,760 --> 00:14:05,850
苹果查询计划的困难或挑战

351
00:14:05,850 --> 00:14:07,980
比在这方面做的要大得多，因为所有都是

352
00:14:07,980 --> 00:14:09,300
工作负载 或事务处理

353
00:14:09,300 --> 00:14:12,060
工作负载，这是因为大多数

354
00:14:12,060 --> 00:14:14,940
情况下，查询和最终

355
00:14:14,940 --> 00:14:16,500
工作负载被认为是

356
00:14:16,500 --> 00:14:19,050
所谓的酢浆草，而 Sarge will just shorts

357
00:14:19,050 --> 00:14:22,230
是搜索参数的首字母缩写词，

358
00:14:22,230 --> 00:14:25,070
它们可以在 80 年代组成一些术语，我

359
00:14:25,070 --> 00:14:28,740
不知道 知道为什么，对于这些

360
00:14:28,740 --> 00:14:30,660
Sargent 查询，为什么

361
00:14:30,660 --> 00:14:32,370
它们对我们来说很容易进行

362
00:14:32,370 --> 00:14:35,190
查询规划的原因是因为在

363
00:14:35,190 --> 00:14:36,420
老年人工作量中，您几乎总是

364
00:14:36,420 --> 00:14:39,660
在进行查找，您知道一个 sm 一次所有

365
00:14:39,660 --> 00:14:41,700
数量的表，并且您

366
00:14:41,700 --> 00:14:45,120
通常在

367
00:14:45,120 --> 00:14:46,410
您尝试

368
00:14:46,410 --> 00:14:49,950
在这些表中进行查找的属性上定义了索引，因此很多

369
00:14:49,950 --> 00:14:52,020
时候挑战只是

370
00:14:52,020 --> 00:14:53,880
试图选择最适合我

371
00:14:53,880 --> 00:14:57,900
使用的索引 这个特定的查询好吧，所以

372
00:14:57,900 --> 00:14:59,850
说我有一个简单的表 foo 有两

373
00:14:59,850 --> 00:15:03,660
列和一个名称，一个条目 ID 和名称

374
00:15:03,660 --> 00:15:05,880
ID 是主键，所以如果我有一个

375
00:15:05,880 --> 00:15:07,830
查询出现，你不

376
00:15:07,830 --> 00:15:10,050
知道有一个相等谓词，其中

377
00:15:10,050 --> 00:15:12,930
ID 等于 一二三

378
00:15:12,930 --> 00:15:14,760
我不需要做任何复杂的搜索

379
00:15:14,760 --> 00:15:16,290
来找出

380
00:15:16,290 --> 00:15:18,180
访问表 foo 的最佳访问方法我

381
00:15:18,180 --> 00:15:20,310
只是查看我的目录并说好我

382
00:15:20,310 --> 00:15:22,020
知道我正在对 ID 字段执行相等谓词

383
00:15:22,020 --> 00:15:25,320
我 在 ID 上有一个主键，

384
00:15:25,320 --> 00:15:27,000
因此它必须有一个索引，

385
00:15:27,000 --> 00:15:28,920
所以我知道在这种情况下，

386
00:15:28,920 --> 00:15:30,720
我只是使用该索引来

387
00:15:30,720 --> 00:15:32,790
进行查找，我不需要它，您知道

388
00:15:32,790 --> 00:15:34,410
甚至考虑我们所有可能的

389
00:15:34,410 --> 00:15:36,920
索引 我想

390
00:15:36,920 --> 00:15:40,170
同样选择 for for join 他们是

391
00:15:40,170 --> 00:15:42,240
几乎总是外键上的 OTP 设置

392
00:15:42,240 --> 00:15:46,170
一些应用程序

393
00:15:46,170 --> 00:15:48,750
设计得不好，所以你他们可能

394
00:15:48,750 --> 00:15:53,160
没有定义外键有时

395
00:15:53,160 --> 00:15:54,180
你看到人们编写的应用程序

396
00:15:54,180 --> 00:15:55,350
可能不知道他们在

397
00:15:55,350 --> 00:15:57,510
做什么 数据库如此清楚 它应该是

398
00:15:57,510 --> 00:15:59,310
一个外键，但他们只是没有

399
00:15:59,310 --> 00:16:02,880
将它限制在方案中，嗯，但

400
00:16:02,880 --> 00:16:05,310
即便如此，你仍然很容易弄清楚，

401
00:16:05,310 --> 00:16:07,019
但在这种情况下，

402
00:16:07,019 --> 00:16:08,790
如果你有外键关系

403
00:16:08,790 --> 00:16:10,290
，你知道我有 一个小的

404
00:16:10,290 --> 00:16:13,709
基数是的，它将是一个索引来强制执行

405
00:16:13,709 --> 00:16:15,810


406
00:16:15,810 --> 00:16:17,850
父表中的参照完整性，所以当

407
00:16:17,850 --> 00:16:19,920
您想要加入时，很

408
00:16:19,920 --> 00:16:22,019
容易选择父表

409
00:16:22,019 --> 00:16:24,329
应该在我们的表中，然后是

410
00:16:24,329 --> 00:16:26,639
内部表 是外键子项，

411
00:16:26,639 --> 00:16:28,380
我正在执行嵌套循环索引探测，

412
00:16:28,380 --> 00:16:30,839
并且此循环索引连接

413
00:16:30,839 --> 00:16:33,149
将这两个表连接在一起，因此再次在

414
00:16:33,149 --> 00:16:36,089
此环境中进行 ot 查询

415
00:16:36,089 --> 00:16:37,829
，执行查询通常非常简单

416
00:16:37,829 --> 00:16:40,980
计划，你可以通过做

417
00:16:40,980 --> 00:16:42,630
简单的基于启发式的简单优化器来获得

418
00:16:42,630 --> 00:16:45,000
，我们将在第二部分讨论

419
00:16:45,000 --> 00:16:47,160
MongoDB 可能是当今最著名的

420
00:16:47,160 --> 00:16:50,490
数据库系统，它

421
00:16:50,490 --> 00:16:52,980
仍然使用这种基本的启发式

422
00:16:52,980 --> 00:16:54,839
来做这样的事情，因为在

423
00:16:54,839 --> 00:16:56,279
类型 他们最初针对的工作负载

424
00:16:56,279 --> 00:16:58,260
没有进行

425
00:16:58,260 --> 00:16:59,370
复杂的联接，因为

426
00:16:59,370 --> 00:17:02,370
直到几年前他们才真正进行联接，所以

427
00:17:02,370 --> 00:17:04,709
在这个世界中，他们可以通过

428
00:17:04,709 --> 00:17:09,000
简单的启发式方法来解决问题，所以我还

429
00:17:09,000 --> 00:17:11,760
简要地谈到了成本估算

430
00:17:11,760 --> 00:17:14,959
再次开始这里的想法是，

431
00:17:14,959 --> 00:17:18,959
我们有一个查询进来，我们有一个

432
00:17:18,959 --> 00:17:21,240
逻辑计划，我们

433
00:17:21,240 --> 00:17:23,900
想找出代表该逻辑计划的最佳物理计划是什么

434
00:17:23,900 --> 00:17:26,660


435
00:17:26,660 --> 00:17:29,669
，因此我们必须使用成本估算

436
00:17:29,669 --> 00:17:33,210
器 预测您所知道的不会

437
00:17:33,210 --> 00:17:34,860
是执行

438
00:17:34,860 --> 00:17:36,059
该物理计划或其中一个

439
00:17:36,059 --> 00:17:37,799
物理计划的执行成本，然后我们可以使用它

440
00:17:37,799 --> 00:17:40,400
来确定哪个物理计划更

441
00:17:40,400 --> 00:17:41,490
可取

442
00:17:41,490 --> 00:17:45,090
到另一个，所以

443
00:17:45,090 --> 00:17:47,640
我们可以使用很多东西来弄清楚

444
00:17:47,640 --> 00:17:52,110
我们应该是什么或成本我们可以

445
00:17:52,110 --> 00:17:54,240
看看查询如何

446
00:17:54,240 --> 00:17:55,740
与同时运行的其他查询交互，

447
00:17:55,740 --> 00:17:57,990
这实际上非常棘手，实际上很少有

448
00:17:57,990 --> 00:18:00,179
系统这样做 这个真正常见的

449
00:18:00,179 --> 00:18:01,890
事情是说清楚敌人是什么

450
00:18:01,890 --> 00:18:04,140
它的大小我所有操作符的输出大小是什么

451
00:18:04,140 --> 00:18:06,450
，当然使用它作为

452
00:18:06,450 --> 00:18:09,960
我将使用哪些资源的代理它

453
00:18:09,960 --> 00:18:11,730
可能就像

454
00:18:11,730 --> 00:18:14,880
我们正在使用的算法的渐近分析

455
00:18:14,880 --> 00:18:16,710
对于我们的物理操作员，但我们知道

456
00:18:16,710 --> 00:18:19,050
散列连接会更有效，

457
00:18:19,050 --> 00:18:22,830
或者你对 iOS 的了解更少

458
00:18:22,830 --> 00:18:24,960
或开销更少，然后嵌套循环连接

459
00:18:24,960 --> 00:18:26,610
正确，所以我们可以将它融入我们的

460
00:18:26,610 --> 00:18:29,309
比赛模式，我需要多少 CPU 或内存”

461
00:18:29,309 --> 00:18:32,610
我将使用然后一些

462
00:18:32,610 --> 00:18:34,590
关于数据实际上是什么

463
00:18:34,590 --> 00:18:36,870
样子的信息 它的物理位置

464
00:18:36,870 --> 00:18:39,090
它是如何压缩的，就像所有

465
00:18:39,090 --> 00:18:40,530
这些我们可以合并到我们的成本

466
00:18:40,530 --> 00:18:42,450
模型中的东西，以估计将会是

467
00:18:42,450 --> 00:18:45,150
什么 e 现在执行物理计划的成本

468
00:18:45,150 --> 00:18:47,340
这是非常难以做到的，

469
00:18:47,340 --> 00:18:50,100
因为您是根据数据外观的摘要进行估算的，

470
00:18:50,100 --> 00:18:52,230


471
00:18:52,230 --> 00:18:54,390
因为我再次无法扫描

472
00:18:54,390 --> 00:18:55,890
表格并说明您拥有多少元组

473
00:18:55,890 --> 00:18:56,790
它是什么分布 这些

474
00:18:56,790 --> 00:18:58,679
值中的一个，因为您最好只

475
00:18:58,679 --> 00:19:00,480
执行查询，并且对于

476
00:19:00,480 --> 00:19:03,210
不可行的非常大的数据库，因此您

477
00:19:03,210 --> 00:19:04,679
试图尽快估计这一点，

478
00:19:04,679 --> 00:19:06,600
因为您希望尽可能快地

479
00:19:06,600 --> 00:19:09,600
评估尽可能多的物理计划

480
00:19:09,600 --> 00:19:11,880
所以你

481
00:19:11,880 --> 00:19:14,280
可能会找到最佳的，所以

482
00:19:14,280 --> 00:19:16,550
应该不是下周，但在两周内，

483
00:19:16,550 --> 00:19:18,690
我们将更多地讨论成本

484
00:19:18,690 --> 00:19:22,770
模型，我们将看到它们实际上有多大的错误

485
00:19:22,770 --> 00:19:24,660
，这可能

486
00:19:24,660 --> 00:19:29,400
会使优化者做出错误的决定

487
00:19:29,400 --> 00:19:31,500
是的，现在让我们来谈谈如何

488
00:19:31,500 --> 00:19:33,750
实际构建优化器，因此

489
00:19:33,750 --> 00:19:36,450


490
00:19:36,450 --> 00:19:37,740
在我们真正

491
00:19:37,740 --> 00:19:40,290
说出我们将用于枚举的搜索策略是什么之前，我们需要考虑一些第一个设计情况

492
00:19:40,290 --> 00:19:42,600
计划

493
00:19:42,600 --> 00:19:44,940
并

494
00:19:44,940 --> 00:19:48,010
寻找最佳计划，因此我们将

495
00:19:48,010 --> 00:19:50,140
逐一讨论这些主题中的每一个，但

496
00:19:50,140 --> 00:19:53,100
优化粒度将取决于您

497
00:19:53,100 --> 00:19:55,750
我们是什么

498
00:19:55,750 --> 00:19:56,679
我们在进行查询计划时我们正在查看的范围是什么

499
00:19:56,679 --> 00:19:58,840
五天假让一个

500
00:19:58,840 --> 00:19:59,950
手柄玩家准备模式计划

501
00:19:59,950 --> 00:20:01,570
稳定性然后什么时候完成

502
00:20:01,570 --> 00:20:03,159
搜索所以我们将再次访问每

503
00:20:03,159 --> 00:20:08,610
一个所以优化粒度

504
00:20:08,610 --> 00:20:12,370


505
00:20:12,370 --> 00:20:14,409
是优化器必须处理

506
00:20:14,409 --> 00:20:16,659
的搜索问题的范围 选择是

507
00:20:16,659 --> 00:20:18,429
在单个查询上执行还是通过多个

508
00:20:18,429 --> 00:20:21,370
查询执行，因此单个查询是最

509
00:20:21,370 --> 00:20:24,370
常见的方法，因为通常这

510
00:20:24,370 --> 00:20:26,289
就是您真正拥有的全部内容，就像

511
00:20:26,289 --> 00:20:28,870
连接错误的客户端发送了一个

512
00:20:28,870 --> 00:20:30,669
您不会等待的续集查询 四处

513
00:20:30,669 --> 00:20:32,019
看看从其他连接中显示了哪些其他查询，

514
00:20:32,019 --> 00:20:33,610
您使用该

515
00:20:33,610 --> 00:20:34,750
查询并

516
00:20:34,750 --> 00:20:37,029
在那个时间点通过优化器运行它

517
00:20:37,029 --> 00:20:38,889
，这样做的好处是

518
00:20:38,889 --> 00:20:40,419
您显然会有很多

519
00:20:40,419 --> 00:20:42,220
罐子 搜索空间实际上要小得多，

520
00:20:42,220 --> 00:20:43,299
因为您一次只处理一个

521
00:20:43,299 --> 00:20:47,139
查询，您通常也不会

522
00:20:47,139 --> 00:20:49,510
跨查询重用搜索结果，

523
00:20:49,510 --> 00:20:51,370
因此您基本上

524
00:20:51,370 --> 00:20:52,870
每次都从头开始搜索，

525
00:20:52,870 --> 00:20:55,600
现在我们可以讨论一些技术

526
00:20:55,600 --> 00:20:58,120
自适应查询优化有一个

527
00:20:58,120 --> 00:21:00,100
桥梁信息，你从

528
00:21:00,100 --> 00:21:03,039
一次搜索学到了下一次，但通常

529
00:21:03,039 --> 00:21:05,409
大多数数据库系统不会这样做，

530
00:21:05,409 --> 00:21:08,649
另一方面，如果你

531
00:21:08,649 --> 00:21:10,860
想开始弄清楚

532
00:21:10,860 --> 00:21:13,510
我有多少资源 实际使用我的

533
00:21:13,510 --> 00:21:15,909
查询时，您可能需要考虑

534
00:21:15,909 --> 00:21:17,080
同时运行的其他查询，

535
00:21:17,080 --> 00:21:19,510
例如您是否可以执行这些

536
00:21:19,510 --> 00:21:20,620
多个查询，但如果您正在执行单个查询，那么您可以

537
00:21:20,620 --> 00:21:22,929


538
00:21:22,929 --> 00:21:24,130
轻松地执行单个查询，就像使用多个查询一样

539
00:21:24,130 --> 00:21:26,190
因为您不必

540
00:21:26,190 --> 00:21:28,630
担心这些多个查询是如何

541
00:21:28,630 --> 00:21:29,769
同时相互干扰的，

542
00:21:29,769 --> 00:21:32,950
正如我所说的多个查询更

543
00:21:32,950 --> 00:21:35,409
罕见，这就像我知道我

544
00:21:35,409 --> 00:21:37,389
要执行 现在我的应用程序中有一千个查询，

545
00:21:37,389 --> 00:21:39,370
而不是我

546
00:21:39,370 --> 00:21:41,200
一个接一个地发出它们，

547
00:21:41,200 --> 00:21:43,389
就像一个执行的问题得到

548
00:21:43,389 --> 00:21:45,429
下一个发出的结果我理论上可以

549
00:21:45,429 --> 00:21:47,110
给数据库系统一批

550
00:21:47,110 --> 00:21:51,340
查询并让它找出一个单一的

551
00:21:51,340 --> 00:21:53,649
计划 进入

552
00:21:53,649 --> 00:21:55,760
它只执行的所有查询，并且

553
00:21:55,760 --> 00:21:58,940
知道如何路由请求

554
00:21:58,940 --> 00:22:00,860
，在共享或不共享的操作符之间路由数据，

555
00:22:00,860 --> 00:22:02,960
并为

556
00:22:02,960 --> 00:22:05,750
我说的那些单个查询生成输出，这

557
00:22:05,750 --> 00:22:09,140
可能是

558
00:22:09,140 --> 00:22:10,870
流处理系统的类型或继续

559
00:22:10,870 --> 00:22:13,490
继续查询系统，我没有

560
00:22:13,490 --> 00:22:14,480
查询它会永远运行，

561
00:22:14,480 --> 00:22:15,980
因为有一些你知道的

562
00:22:15,980 --> 00:22:17,240
数据管道一直在输入，

563
00:22:17,240 --> 00:22:19,880
我正在处理它们，它确实出现在

564
00:22:19,880 --> 00:22:21,950
学术系统中。

565
00:22:21,950 --> 00:22:23,680
执行类似物

566
00:22:23,680 --> 00:22:25,970
化视图的精确成本分摊数据库是另一种方式，

567
00:22:25,970 --> 00:22:31,460
但正如我所说，这对于

568
00:22:31,460 --> 00:22:33,020
大多数应用程序来说，这不是

569
00:22:33,020 --> 00:22:34,550
那里的界面，这不是他们将如何与他们将

570
00:22:34,550 --> 00:22:35,600
要与数据系统交互的方式

571
00:22:35,600 --> 00:22:37,130
这样做打开一个

572
00:22:37,130 --> 00:22:38,570
连接并发送我的查询

573
00:22:38,570 --> 00:22:43,460
优化器执行它计划并运行它

574
00:22:43,460 --> 00:22:45,950
下一个要处理的问题

575
00:22:45,950 --> 00:22:47,750
是我们什么时候真正要启动

576
00:22:47,750 --> 00:22:50,180
查询优化器所以这

577
00:22:50,180 --> 00:22:51,680
又是第一个这是最常见的 这

578
00:22:51,680 --> 00:22:53,720
是静态优化将

579
00:22:53,720 --> 00:22:56,330
查询显示在系统中我已经

580
00:22:56,330 --> 00:22:58,070
通过我的优化器运行它我为该查询生成一个计划

581
00:22:58,070 --> 00:23:01,100
然后一旦我离开

582
00:23:01,100 --> 00:23:02,960
优化器我再也不会回到

583
00:23:02,960 --> 00:23:06,230
优化器我只是去执行

584
00:23:06,230 --> 00:23:08,300
查询 所以没关系，就像我一样，

585
00:23:08,300 --> 00:23:09,920
所以当时在优化器中它正在

586
00:23:09,920 --> 00:23:11,680
选择它认为最好的计划，

587
00:23:11,680 --> 00:23:14,270
但结果可能是实际

588
00:23:14,270 --> 00:23:17,120
运行查询它并不像我

589
00:23:17,120 --> 00:23:19,370
想象的那么好我认为它 是，但我

590
00:23:19,370 --> 00:23:22,100
不能去 b  ack 就像它是一个

591
00:23:22,100 --> 00:23:24,080
静态计划，一旦优化器说这

592
00:23:24,080 --> 00:23:25,220
是你将要使用的，你就会

593
00:23:25,220 --> 00:23:29,750
坚持下去，所以现在正如我们多次谈到的那样

594
00:23:29,750 --> 00:23:31,310


595
00:23:31,310 --> 00:23:32,690
，这些计划的质量将产生

596
00:23:32,690 --> 00:23:33,770
高度依赖 关于成本模型的

597
00:23:33,770 --> 00:23:35,480
准确性，这对

598
00:23:35,480 --> 00:23:37,010
所有事情都是真实的，但在这种情况下必须

599
00:23:37,010 --> 00:23:38,360
是这样，你不能回去

600
00:23:38,360 --> 00:23:40,430
告诉优化器你错了然后你告诉

601
00:23:40,430 --> 00:23:41,570
我吃什么你告诉我

602
00:23:41,570 --> 00:23:43,760
错了你知道 选择更好的

603
00:23:43,760 --> 00:23:46,010
你你知道你更依赖也许

604
00:23:46,010 --> 00:23:48,440
然后这些其他的现在

605
00:23:48,440 --> 00:23:50,150
你也可以处理的另一件事是

606
00:23:50,150 --> 00:23:52,910
不必一遍又一遍地为每个查询运行这个优化器，

607
00:23:52,910 --> 00:23:54,560


608
00:23:54,560 --> 00:23:57,170
特别是如果它在同一个查询中 您

609
00:23:57,170 --> 00:23:59,690
可以使用准备好的语句来分摊此成本，

610
00:23:59,690 --> 00:24:02,870
并且您可能知道

611
00:24:02,870 --> 00:24:04,880
新查询计划的时间

612
00:24:04,880 --> 00:24:05,810
比通常

613
00:24:05,810 --> 00:24:08,360
情况下的时间更长，否则我们将讨论

614
00:24:08,360 --> 00:24:10,820


615
00:24:10,820 --> 00:24:12,950
在第二个 b 中搜索其他部分的截止阈值

616
00:24:12,950 --> 00:24:14,150
想想这就像你知道的，当

617
00:24:14,150 --> 00:24:15,230
我每次看到煤炭时打开 Postgres

618
00:24:15,230 --> 00:24:16,550
无论我用于数据系统的终端我在我的数据

619
00:24:16,550 --> 00:24:18,650
系统中输入一个查询

620
00:24:18,650 --> 00:24:20,840
，然后按回车键，然后我得到的结果

621
00:24:20,840 --> 00:24:23,240
就像那个时候 运行

622
00:24:23,240 --> 00:24:25,100
优化器并生成你知道的

623
00:24:25,100 --> 00:24:27,500
物理计划然后实际执行

624
00:24:27,500 --> 00:24:28,910
查询，在某些情况下，查询可以

625
00:24:28,910 --> 00:24:33,800
在几毫秒内运行，所以如果我有一个

626
00:24:33,800 --> 00:24:35,390
我不想拥有的公牛或彗星查询

627
00:24:35,390 --> 00:24:36,530
，你知道

628
00:24:36,530 --> 00:24:37,940
你知道我 我实际上一直都在这样做

629
00:24:37,940 --> 00:24:39,290
，因此我想花一些

630
00:24:39,290 --> 00:24:41,810
额外的时间来更好地

631
00:24:41,810 --> 00:24:44,630
寻找最佳计划 我可以

632
00:24:44,630 --> 00:24:47,150
通过准备好的声明来做到这一点 我们将

633
00:24:47,150 --> 00:24:50,060
在多几张幻灯片中讨论另一种

634
00:24:50,060 --> 00:24:52,640
方法 据我所知，这

635
00:24:52,640 --> 00:24:55,760
在今天的

636
00:24:55,760 --> 00:24:57,410
基于关系续集的数据库系统中并不真正存在，

637
00:24:57,410 --> 00:25:00,790
它主要出现

638
00:25:00,790 --> 00:25:03,380
在流处理系统中，但它

639
00:25:03,380 --> 00:25:05,630
可能是错误的，这里的想法是

640
00:25:05,630 --> 00:25:09,620
我的查询出现我生成逻辑

641
00:25:09,620 --> 00:25:13,700
计划 它没有 想重新启动我们

642
00:25:13,700 --> 00:25:16,490
为它生成一个逻辑计划，然后

643
00:25:16,490 --> 00:25:19,550
我将该计划分解为子计划的子

644
00:25:19,550 --> 00:25:23,420
组，在我

645
00:25:23,420 --> 00:25:25,580
执行销售计划之前，我通过

646
00:25:25,580 --> 00:25:27,650
优化器运行它以生成物理计划

647
00:25:27,650 --> 00:25:29,990
，然后执行它和 那么现在我

648
00:25:29,990 --> 00:25:31,940
将学习

649
00:25:31,940 --> 00:25:34,250
该子计划的输出内容的一些信息，

650
00:25:34,250 --> 00:25:38,240
然后我可以使用这些信息来指导优化器

651
00:25:38,240 --> 00:25:41,420
找到下一个单元计划我们的下一个

652
00:25:41,420 --> 00:25:43,700
管道我想要X老兄我可以让它

653
00:25:43,700 --> 00:25:45,110
然后生成物理 使用

654
00:25:45,110 --> 00:25:46,550
我收集的信息进行计划并

655
00:25:46,550 --> 00:25:48,470
运行第一个你

656
00:25:48,470 --> 00:25:51,500
通过

657
00:25:51,500 --> 00:25:53,360
在执行

658
00:25:53,360 --> 00:25:57,920
引擎和优化器之间来回来回迭代地构建物理计划，所以

659
00:25:57,920 --> 00:26:01,220
这是罕见的 Ike 我不认为

660
00:26:01,220 --> 00:26:03,380
任何商业系统实际上都采用这种

661
00:26:03,380 --> 00:26:06,890
方法，我们将在 SEC angrist

662
00:26:06,890 --> 00:26:08,810
中看到它实际上

663
00:26:08,810 --> 00:26:10,130
是这样做的，而且他们以前采用这种方法并不是

664
00:26:10,130 --> 00:26:12,590
因为它们很复杂，

665
00:26:12,590 --> 00:26:14,780
而是因为它们仅限于

666
00:26:14,780 --> 00:26:17,060
复杂性 他们

667
00:26:17,060 --> 00:26:18,080
当时在软件和

668
00:26:18,080 --> 00:26:20,660
查询规划器中实际做了什么，但我认为它

669
00:26:20,660 --> 00:26:21,380


670
00:26:21,380 --> 00:26:23,030
存在于学术系统中，但我再次

671
00:26:23,030 --> 00:26:24,260
认为它不存在于任何商业

672
00:26:24,260 --> 00:26:28,820
系统中，最后一个执行此操作的系统

673
00:26:28,820 --> 00:26:30,170
实际上是这样做的 在当今的商业

674
00:26:30,170 --> 00:26:32,420
系统中，这种想法被称为

675
00:26:32,420 --> 00:26:34,790
自适应查询优化，有时也

676
00:26:34,790 --> 00:26:36,800
称为混合优化，这个想法

677
00:26:36,800 --> 00:26:38,480
是，

678
00:26:38,480 --> 00:26:40,610
当您通过查询显示时，

679
00:26:40,610 --> 00:26:42,140


680
00:26:42,140 --> 00:26:44,660
您仍然会执行第一步 但是

681
00:26:44,660 --> 00:26:47,360
然后你的行星也会

682
00:26:47,360 --> 00:26:51,050
包括这些内置的

683
00:26:51,050 --> 00:26:53,660
水印或阈值，你可以用它来

684
00:26:53,660 --> 00:26:55,970
确定

685
00:26:55,970 --> 00:26:58,370
成本模型在第一步中使用的估计值，当我

686
00:26:58,370 --> 00:26:59,450
第一次生成该计划时

687
00:26:59,450 --> 00:27:01,460
，这些估计值是否真的

688
00:27:01,460 --> 00:27:03,440
匹配 当您和您访问数据时所看到的内容，

689
00:27:03,440 --> 00:27:06,080
例如，如果我

690
00:27:06,080 --> 00:27:08,150
认为我的查询非常有选择性，

691
00:27:08,150 --> 00:27:09,980
或者我的粒子非常有选择性，但

692
00:27:09,980 --> 00:27:12,680
随后我运行了查询 我看到

693
00:27:12,680 --> 00:27:15,110
谓词根本没有选择性，那么

694
00:27:15,110 --> 00:27:17,540
如果您发现

695
00:27:17,540 --> 00:27:20,090
您的估计错误率

696
00:27:20,090 --> 00:27:22,400
超过了某个阈值，那么您

697
00:27:22,400 --> 00:27:24,650
可以在那里即时调整和更改计划，

698
00:27:24,650 --> 00:27:27,710
或者您只是放弃并

699
00:27:27,710 --> 00:27:30,320
返回 对查询优化器说，

700
00:27:30,320 --> 00:27:32,330
嘿，你的计划错了，让我做一个新

701
00:27:32,330 --> 00:27:33,620
的，让我变得更好，

702
00:27:33,620 --> 00:27:37,160
所以好吧，我们将在

703
00:27:37,160 --> 00:27:39,770
两周内讨论这个，这个，这里是你

704
00:27:39,770 --> 00:27:41,450
培根查询计划本身，其他

705
00:27:41,450 --> 00:27:43,370
替代方案等等 您可以

706
00:27:43,370 --> 00:27:44,750
根据

707
00:27:44,750 --> 00:27:46,580
阈值进行调整或更改，这实际上

708
00:27:46,580 --> 00:27:48,260
就像说只是停止执行

709
00:27:48,260 --> 00:27:52,060
查询并返回优化器，因此

710
00:27:52,060 --> 00:27:54,860
最简单的方法就是

711
00:27:54,860 --> 00:27:56,840
扔掉所有东西并

712
00:27:56,840 --> 00:27:59,840
从头开始 这个想法是你

713
00:27:59,840 --> 00:28:01,730
你是你是你正在做的赌博

714
00:28:01,730 --> 00:28:03,260
，你第一次生成的物理计划

715
00:28:03,260 --> 00:28:05,450
是如此糟糕，你最好

716
00:28:05,450 --> 00:28:07,010
扔掉你

717
00:28:07,010 --> 00:28:08,870
已经完成的任何工作回到优化器

718
00:28:08,870 --> 00:28:10,310
得到 一个 新计划，因为新

719
00:28:10,310 --> 00:28:12,050
计划比

720
00:28:12,050 --> 00:28:15,730
让第一个运行去参加

721
00:28:15,730 --> 00:28:18,350
另一种方法更有效率，然后识别

722
00:28:18,350 --> 00:28:19,880
你已经完成了多少工作，

723
00:28:19,880 --> 00:28:21,770
然后你回到优化器并

724
00:28:21,770 --> 00:28:23,120
说我已经完成了 你知道我

725
00:28:23,120 --> 00:28:25,040
已经扫描或连接了这两个表，所以为

726
00:28:25,040 --> 00:28:27,590
我生成一个新计划，该计划

727
00:28:27,590 --> 00:28:29,390
不会改变那部分我认为那

728
00:28:29,390 --> 00:28:31,790
部分是固定的，我们已经计算了它

729
00:28:31,790 --> 00:28:35,180
我认为每个人几乎都会

730
00:28:35,180 --> 00:28:36,470
扔掉所有东西然后开始

731
00:28:36,470 --> 00:28:39,160
至少在今天的商业系统中

732
00:28:39,160 --> 00:28:42,440
，这就是准备好的

733
00:28:42,440 --> 00:28:44,960
语句，所以假设我在这里有一个查询

734
00:28:44,960 --> 00:28:48,080
想要对表 ABC 进行三向连接

735
00:28:48,080 --> 00:28:51,940


736
00:28:51,940 --> 00:28:54,260
，我在这里有一些参数可以用来过滤

737
00:28:54,260 --> 00:28:56,090
掉 摆出这两个

738
00:28:56,090 --> 00:28:58,370
表中的一些 那么这是一个简单的

739
00:28:58,370 --> 00:29:00,170
查询 对这三个联合

740
00:29:00,170 --> 00:29:01,760
它不会花时间执行 但

741
00:29:01,760 --> 00:29:04,310
假设它需要很长时间 对吧

742
00:29:04,310 --> 00:29:06,590
假设它可能需要 10

743
00:29:06,590 --> 00:29:08,510
运行通过 t 的秒数 他查询

744
00:29:08,510 --> 00:29:10,970
优化器，但查询只需要一

745
00:29:10,970 --> 00:29:13,490
秒钟运行，所以在这种情况下，

746
00:29:13,490 --> 00:29:15,290
每次我超过这个退出说

747
00:29:15,290 --> 00:29:16,580
我一遍又一遍地执行我

748
00:29:16,580 --> 00:29:18,500
不想为一个查询支付 10 秒的搜索

749
00:29:18,500 --> 00:29:20,300
成本 花

750
00:29:20,300 --> 00:29:23,360
一秒钟，所以我可以做的是，我

751
00:29:23,360 --> 00:29:25,390
可以将它声明为准备好的语句

752
00:29:25,390 --> 00:29:27,890
，本质上是我在

753
00:29:27,890 --> 00:29:30,020
这里给这个查询命名我的查询

754
00:29:30,020 --> 00:29:32,480
，现在我使用执行命令

755
00:29:32,480 --> 00:29:35,150
来调用它，所以现在 在这种

756
00:29:35,150 --> 00:29:38,560
情况下，首次亮相的系统

757
00:29:38,560 --> 00:29:40,790
可以提前告知查询

758
00:29:40,790 --> 00:29:42,620
将是什么作为准备好的语句它可以

759
00:29:42,620 --> 00:29:44,840
通过优化器运行它需要

760
00:29:44,840 --> 00:29:47,180
10 秒缓存计划，现在

761
00:29:47,180 --> 00:29:49,280
我每次调用它时都会收到

762
00:29:49,280 --> 00:29:51,830
我 刚刚再次获得该计划我说

763
00:29:51,830 --> 00:29:53,660
我现在它运行速度超快而无需

764
00:29:53,660 --> 00:29:55,300
支付去优化器的费用

765
00:29:55,300 --> 00:29:57,350
所以在这种情况下这是一个

766
00:29:57,350 --> 00:29:58,850
超级简单的示例它可以正常工作

767
00:29:58,850 --> 00:30:01,550
这里没有问题但是

768
00:30:01,550 --> 00:30:04,730
假设我想要 实际上这个查询结束了

769
00:30:04,730 --> 00:30:06,710
永远不会再但也许不会使用

770
00:30:06,710 --> 00:30:10,070
我在这里的这些值来做到

771
00:30:10,070 --> 00:30:11,450
这一点 where 子句中的谓词

772
00:30:11,450 --> 00:30:14,150
也许我想为每个查询更改这些值

773
00:30:14,150 --> 00:30:16,730
所以要做到这一点我可以

774
00:30:16,730 --> 00:30:19,220
用问号替换常量值

775
00:30:19,220 --> 00:30:22,040
有时是美元符号

776
00:30:22,040 --> 00:30:25,490
表示这些是输入参数，现在

777
00:30:25,490 --> 00:30:28,160
我在声明准备好的

778
00:30:28,160 --> 00:30:29,570
语句时声明我说这些是

779
00:30:29,570 --> 00:30:30,710
您可以传入的三个参数及其

780
00:30:30,710 --> 00:30:32,390
类型，现在当我调用查询时，

781
00:30:32,390 --> 00:30:33,860
它就像一个函数调用，我

782
00:30:33,860 --> 00:30:37,880
传入这些实际值 好吧，

783
00:30:37,880 --> 00:30:40,120
现在棘手的事情是，

784
00:30:40,120 --> 00:30:42,440


785
00:30:42,440 --> 00:30:45,320


786
00:30:45,320 --> 00:30:47,720
如果我不知道这些

787
00:30:47,720 --> 00:30:49,070
值是什么时，

788
00:30:49,070 --> 00:30:50,870
我被告知准备声明时，物理计划实际上应该是什么样的，在这个查询的联合排序方面

789
00:30:50,870 --> 00:30:55,820
我是对的，所以如果你知道它可能

790
00:30:55,820 --> 00:30:56,840
是第一次当我在这里有这些值时

791
00:30:56,840 --> 00:30:57,710


792
00:30:57,710 --> 00:31:00,080
我想先加入 aa 和 B

793
00:31:00,080 --> 00:31:02,899
然后加入 C 但也许对于另一组

794
00:31:02,899 --> 00:31:06,710
值我想先加入 B 和 C

795
00:31:06,710 --> 00:31:09,110
然后是 a 但我不知道，

796
00:31:09,110 --> 00:31:10,519
因为我只有这些，请

797
00:31:10,519 --> 00:31:12,710
在此处占位这些变量标记

798
00:31:12,710 --> 00:31:13,970


799
00:31:13,970 --> 00:31:16,309


800
00:31:16,309 --> 00:31:17,509


801
00:31:17,509 --> 00:31:18,470


802
00:31:18,470 --> 00:31:22,539
要做的事情

803
00:31:22,539 --> 00:31:26,419


804
00:31:26,419 --> 00:31:29,389
是，我们经常使用我们拥有的最后一个计划，所以

805
00:31:29,389 --> 00:31:31,700
假设我们称之为准备好的语句，我们

806
00:31:31,700 --> 00:31:33,230
实际上并没有在那里准备它

807
00:31:33,230 --> 00:31:34,700
，我们不想完全

808
00:31:34,700 --> 00:31:36,200
看到查询优化器，但是 当有人

809
00:31:36,200 --> 00:31:38,240
实际调用它并执行并

810
00:31:38,240 --> 00:31:40,460
使用准备好的语句时，现在我们得到了

811
00:31:40,460 --> 00:31:43,460
一些值，然后我们可以说好让

812
00:31:43,460 --> 00:31:45,049
我们假设这些值会发生，

813
00:31:45,049 --> 00:31:46,669
我们将代表我们

814
00:31:46,669 --> 00:31:48,409
总是会看到的，我只是缓存该

815
00:31:48,409 --> 00:31:50,210
计划所有 正确并始终使用我

816
00:31:50,210 --> 00:31:52,129
之前读过的内容，所以我认为这就是

817
00:31:52,129 --> 00:31:53,840
Postgres 做的对，这很

818
00:31:53,840 --> 00:31:58,820
简单，下一个选择是您

819
00:31:58,820 --> 00:32:01,009
实际上失去了

820
00:32:01,009 --> 00:32:02,870
在设置的位置获取准备好的语句的所有好处 您

821
00:32:02,870 --> 00:32:04,039
每次调用它时都通过优化器运行它

822
00:32:04,039 --> 00:32:05,929
，您可以

823
00:32:05,929 --> 00:32:08,600
聪明一点，并尝试使用

824
00:32:08,600 --> 00:32:10,460
您上次拥有的任何计划作为

825
00:32:10,460 --> 00:32:14,299
搜索的起点

826
00:32:14,299 --> 00:32:15,590
至少说明您知道这里是

827
00:32:15,590 --> 00:32:17,419
一个很好的起点 对于我的物理

828
00:32:17,419 --> 00:32:19,370
计划，并以此为基础寻找

829
00:32:19,370 --> 00:32:21,740
更好的计划，而不是

830
00:32:21,740 --> 00:32:23,090


831
00:32:23,090 --> 00:32:26,149
每次实际使用前一个

832
00:32:26,149 --> 00:32:30,320
计划作为上限时从头开始，这很棘手，

833
00:32:30,320 --> 00:32:31,399
因为这需要您设计

834
00:32:31,399 --> 00:32:33,049
优化器才能重新启动 它来自

835
00:32:33,049 --> 00:32:36,169
现有的物理计划，并且

836
00:32:36,169 --> 00:32:38,570
编写的大多数优化器都不是为了

837
00:32:38,570 --> 00:32:41,059
处理另一种方法是

838
00:32:41,059 --> 00:32:42,529
为您的准备好的语句生成多个计划，

839
00:32:42,529 --> 00:32:46,100
所以您可以说

840
00:32:46,100 --> 00:32:48,200
我知道我正在做一个准备工作，

841
00:32:48,200 --> 00:32:50,389
其中有一个输入参数

842
00:32:50,389 --> 00:32:52,759
在这一列中，我可以查看

843
00:32:52,759 --> 00:32:54,470


844
00:32:54,470 --> 00:32:56,000
通过分析关键字或分析命令收集的

845
00:32:56,000 --> 00:32:57,769


846
00:32:57,769 --> 00:32:59,000
有关值分布情况的直方图或统计数据 对于

847
00:32:59,000 --> 00:33:00,950
该列，也许我在直方图中将它们

848
00:33:00,950 --> 00:33:01,770
分成两个

849
00:33:01,770 --> 00:33:03,390
桶，每个

850
00:33:03,390 --> 00:33:06,240
桶我都会生成一个生成计划，

851
00:33:06,240 --> 00:33:07,920
所以现在当我调用准备好的

852
00:33:07,920 --> 00:33:09,330
语句时，我会查看传入的均值值

853
00:33:09,330 --> 00:33:11,400
，并找出

854
00:33:11,400 --> 00:33:12,770
它属于哪个桶 这就是我使用的计划，

855
00:33:12,770 --> 00:33:16,830
所以对于一个变量，如果

856
00:33:16,830 --> 00:33:18,510
现在我有多个变量并且现在

857
00:33:18,510 --> 00:33:20,520
变得指数级或计划的数量

858
00:33:20,520 --> 00:33:21,840
现在我可能

859
00:33:21,840 --> 00:33:24,210
不得不将其爆炸并且这样做会很

860
00:33:24,210 --> 00:33:29,940
昂贵，那么这很容易做到 我不认为甲骨文

861
00:33:29,940 --> 00:33:32,100
可能会做这样的事情，但它

862
00:33:32,100 --> 00:33:33,960
可能是错误的，但有一些更

863
00:33:33,960 --> 00:33:35,250
原始的版本试图查看

864
00:33:35,250 --> 00:33:37,470
所有可能的计划的速度，

865
00:33:37,470 --> 00:33:39,870
最后一个只是

866
00:33:39,870 --> 00:33:42,090
说好我知道我的 参数是我

867
00:33:42,090 --> 00:33:44,040
可以推断哪些列在

868
00:33:44,040 --> 00:33:45,810
做 查找某人或

869
00:33:45,810 --> 00:33:48,210
正在访问哪些参与者 我只会查看

870
00:33:48,210 --> 00:33:50,270
我的统计数据 取

871
00:33:50,270 --> 00:33:53,010
每个列可以

872
00:33:53,010 --> 00:33:55,170
表示的平均值并将其用作输入

873
00:33:55,170 --> 00:33:57,450
参数 当我通过采石场优化器调用准备好的语句时完美地准备好，

874
00:33:57,450 --> 00:33:58,650


875
00:33:58,650 --> 00:34:01,830
所以再次

876
00:34:01,830 --> 00:34:05,700
没有一种方法可以让所有

877
00:34:05,700 --> 00:34:07,650
系统实际使用这是

878
00:34:07,650 --> 00:34:10,679
最简单的方法，但我认为这实际上是

879
00:34:10,679 --> 00:34:11,820
一个很好的研究问题，我想

880
00:34:11,820 --> 00:34:15,418
在某些情况下进行调查

881
00:34:15,418 --> 00:34:16,469
好吧，接下来我们要处理

882
00:34:16,469 --> 00:34:19,980
的是稳定性，因此计划稳定性意味着

883
00:34:19,980 --> 00:34:23,699


884
00:34:23,699 --> 00:34:26,540
特定查询的查询性能

885
00:34:26,540 --> 00:34:29,940
从一天到下一天都是一致的，

886
00:34:29,940 --> 00:34:31,620
就像我今天运行查询一样

887
00:34:31,620 --> 00:34:33,690
如果我

888
00:34:33,690 --> 00:34:36,659
明天在相同类型的数据库上运行相同的查询需要 X 的时间

889
00:34:36,659 --> 00:34:39,659
你知道模一些小的

890
00:34:39,659 --> 00:34:41,969
更改我应该花费

891
00:34:41,969 --> 00:34:43,500
大约相同的时间

892
00:34:43,500 --> 00:34:45,179
我不希望发生的是我运行我的

893
00:34:45,179 --> 00:34:49,199
今天查询，它是你知道它

894
00:34:49,199 --> 00:34:51,330
需要这个时间它明天运行，如果

895
00:34:51,330 --> 00:34:53,010
你采取它的一半成本是

896
00:34:53,010 --> 00:34:54,510
交换时间减少一半但是然后

897
00:34:54,510 --> 00:34:56,250
在之后的一天现在它回到

898
00:34:56,250 --> 00:34:57,540
原来的时间，就像我一样 不希望出现这些

899
00:34:57,540 --> 00:34:59,880
振荡，

900
00:34:59,880 --> 00:35:01,850
因为这让我们很难识别

901
00:35:01,850 --> 00:35:03,600
性能瓶颈和性能

902
00:35:03,600 --> 00:35:06,390
问题 DBA 对于

903
00:35:06,390 --> 00:35:08,550
升级数据库系统非常保守 David 说

904
00:35:08,550 --> 00:35:11,490
一些软件，因为他们宁愿拥有

905
00:35:11,490 --> 00:35:13,530
稳定性，然后一直保持更好的

906
00:35:13,530 --> 00:35:15,920
性能

907
00:35:15,920 --> 00:35:18,839
那么我们如何才能实现稳定性并进行

908
00:35:18,839 --> 00:35:24,060
查询，所以这又是关于

909
00:35:24,060 --> 00:35:25,349
查询优化器的，所以我们要

910
00:35:25,349 --> 00:35:26,910
确保我们的查询优化器正在

911
00:35:26,910 --> 00:35:30,150
为查询生成计划，从一天

912
00:35:30,150 --> 00:35:34,440
到下一天将具有状态稳定的

913
00:35:34,440 --> 00:35:37,050
性能，所以一种方法是

914
00:35:37,050 --> 00:35:39,359
为查询计划提供提示，因此这

915
00:35:39,359 --> 00:35:40,470
基本上是您

916
00:35:40,470 --> 00:35:42,660
可以通过标题中的特殊注释来注释查询的地方，

917
00:35:42,660 --> 00:35:45,420
或者如果它是

918
00:35:45,420 --> 00:35:47,099
图形工具，有时您可以这样做

919
00:35:47,099 --> 00:35:49,349
，您可以在其中指定您希望

920
00:35:49,349 --> 00:35:51,510
查询优化器实际执行的操作

921
00:35:51,510 --> 00:35:53,670
对于某些选择，它必须做出这样的选择，

922
00:35:53,670 --> 00:35:54,950
所以你会一直看到这个，就像我一样，你

923
00:35:54,950 --> 00:35:57,390
甚至可以向优化器提供一个提示，

924
00:35:57,390 --> 00:35:59,490
然后说 s 查询场景你

925
00:35:59,490 --> 00:36:01,410
应该在这个表上使用这个索引我

926
00:36:01,410 --> 00:36:02,700
不关心其他索引或扫描

927
00:36:02,700 --> 00:36:04,560
所以你确保正确使用它的索引

928
00:36:04,560 --> 00:36:06,000
或者连接顺序将是另一个

929
00:36:06,000 --> 00:36:11,640
常见的另一个是你可以

930
00:36:11,640 --> 00:36:14,069
告诉一些数据库系统哪个

931
00:36:14,069 --> 00:36:14,940


932
00:36:14,940 --> 00:36:16,619
他们想要用于

933
00:36:16,619 --> 00:36:19,800
特定查询的优化器版本，所以很多时候当

934
00:36:19,800 --> 00:36:21,000
人们升级数据库系统

935
00:36:21,000 --> 00:36:24,390
软件时希望这特别

936
00:36:24,390 --> 00:36:28,109
适用于 Oracle，您可以指定

937
00:36:28,109 --> 00:36:30,210
您希望查询使用哪个版本的优化器，

938
00:36:30,210 --> 00:36:32,700
因为如果您已经审查过 说

939
00:36:32,700 --> 00:36:34,680
一个以前的版本和优化器

940
00:36:34,680 --> 00:36:36,450
生成的计划，你可以理解

941
00:36:36,450 --> 00:36:38,700
你在升级时有稳定的性能数字

942
00:36:38,700 --> 00:36:39,960
也许你

943
00:36:39,960 --> 00:36:41,040
不想更新优化器并让它

944
00:36:41,040 --> 00:36:42,990
为查询生成不同的计划，

945
00:36:42,990 --> 00:36:47,010
现在数字可能会再次发生变化

946
00:36:47,010 --> 00:36:49,710
DBA 非常保守，

947
00:36:49,710 --> 00:36:51,359
如果我们将数据升级到系统软件并没有帮助，现在我们

948
00:36:51,359 --> 00:36:54,930
99% 的查询

949
00:36:54,930 --> 00:36:56,849
运行得更快，但 1% 的

950
00:36:56,849 --> 00:36:58,230
查询运行得更慢，因为 因为优化器

951
00:36:58,230 --> 00:37:00,510
选择了与以前不同的计划

952
00:37:00,510 --> 00:37:01,220
，

953
00:37:01,220 --> 00:37:04,500
这对我来说很糟糕，因为

954
00:37:04,500 --> 00:37:06,180
现在查询运行速度较慢的人

955
00:37:06,180 --> 00:37:07,829
会打电话给您并抱怨并

956
00:37:07,829 --> 00:37:09,119
说为什么我的查询运行速度较慢请

957
00:37:09,119 --> 00:37:12,060
修复它其他 99  %

958
00:37:12,060 --> 00:37:13,290
那些人不会打电话说

959
00:37:13,290 --> 00:37:14,760
你知道感谢你让查询

960
00:37:14,760 --> 00:37:16,619
运行得更快的查询 人们不会这样做，

961
00:37:16,619 --> 00:37:18,150
这是当事情变糟的时候

962
00:37:18,150 --> 00:37:21,690
人们抱怨的时候所以在这种情况下

963
00:37:21,690 --> 00:37:23,640
再次在这里所以如果我升级我的升级

964
00:37:23,640 --> 00:37:25,890
Oracle 我可以说我想使用

965
00:37:25,890 --> 00:37:27,420
以前的优化器运行，因为这会

966
00:37:27,420 --> 00:37:28,320
生成

967
00:37:28,320 --> 00:37:31,860
我知道的计划，我知道最后一个选择是

968
00:37:31,860 --> 00:37:34,440
支持向后兼容的计划，所以

969
00:37:34,440 --> 00:37:36,450
这里的想法是，如果我说我升级了

970
00:37:36,450 --> 00:37:39,330
我的数据库系统软件，但是 在

971
00:37:39,330 --> 00:37:42,540
我在旧系统上执行此操作之前，我会转储或

972
00:37:42,540 --> 00:37:45,180
导出我准备好的

973
00:37:45,180 --> 00:37:46,680
Saber 或我一直在执行的查询的

974
00:37:46,680 --> 00:37:49,470
所有计划以及过多的文件，然后我

975
00:37:49,470 --> 00:37:50,970
升级了 Devi 系统软件，

976
00:37:50,970 --> 00:37:53,730
然后我重新加载了这些计划 来自  

977
00:37:53,730 --> 00:37:54,990
以前版本的软件，并

978
00:37:54,990 --> 00:37:57,480
覆盖优化器

979
00:37:57,480 --> 00:37:59,690
让你对这个查询说不的任何决定

980
00:37:59,690 --> 00:38:02,250
绝对使用这个计划，保证

981
00:38:02,250 --> 00:38:04,230
你有相同的计划，但你以前有过

982
00:38:04,230 --> 00:38:06,780
，所以续集服务器允许你做

983
00:38:06,780 --> 00:38:08,130
这个续集服务器，你可以 将

984
00:38:08,130 --> 00:38:11,160
查询计划作为 XML 转储出来，然后将它们加载

985
00:38:11,160 --> 00:38:16,860
回新版本 这是我们讨论的最后一

986
00:38:16,860 --> 00:38:18,690
件事是搜索词

987
00:38:18,690 --> 00:38:20,550
终止 所以当您在命令行上时，您再次

988
00:38:20,550 --> 00:38:22,380
输入查询类型，

989
00:38:22,380 --> 00:38:25,200
然后按 Enter 并运行 查询

990
00:38:25,200 --> 00:38:28,710
优化器，所以你需要一种方法让

991
00:38:28,710 --> 00:38:30,240
查询优化器确定我已经运行了

992
00:38:30,240 --> 00:38:34,140
足够长的时间，我需要停止，

993
00:38:34,140 --> 00:38:36,150
因为你

994
00:38:36,150 --> 00:38:38,940
从非常复杂的查询中知道这些问题中的一些你知道它

995
00:38:38,940 --> 00:38:41,100
是搜索空间并且是完整的所以

996
00:38:41,100 --> 00:38:42,240
你 可以只运行几天

997
00:38:42,240 --> 00:38:44,250
，几天又几天，人们

998
00:38:44,250 --> 00:38:44,910
不会喜欢那样，

999
00:38:44,910 --> 00:38:47,250
所以最明显的事情就是

1000
00:38:47,250 --> 00:38:48,990
设置一个挂钟时间障碍，

1001
00:38:48,990 --> 00:38:51,630
说如果我的优化器首先运行它

1002
00:38:51,630 --> 00:38:54,390
的时间量，我只是想 好吧，我停下来

1003
00:38:54,390 --> 00:38:57,120
另一种方法是有一个

1004
00:38:57,120 --> 00:39:00,120
成本门槛，你说如果我

1005
00:39:00,120 --> 00:39:01,790
找到一个计划，

1006
00:39:01,790 --> 00:39:04,500
如果我找到一个计划的成本

1007
00:39:04,500 --> 00:39:06,180
低于我想要的某个门槛，或者

1008
00:39:06,180 --> 00:39:08,370
另一个可能是，如果我已经

1009
00:39:08,370 --> 00:39:09,450
跑了一定的时间，我没有

1010
00:39:09,450 --> 00:39:11,490
找到一个你知道的计划

1011
00:39:11,490 --> 00:39:13,200
比

1012
00:39:13,200 --> 00:39:15,120
我目前看到的最好的计划好 20% 或 10% 然后我

1013
00:39:15,120 --> 00:39:16,380
继续前进并阻止

1014
00:39:16,380 --> 00:39:18,780
自己最后一个基本上是你说如果 你

1015
00:39:18,780 --> 00:39:20,070
可以确定没有更多

1016
00:39:20,070 --> 00:39:22,140
可能的排列或枚举你

1017
00:39:22,140 --> 00:39:25,260
可以为目标计划做然后你知道

1018
00:39:25,260 --> 00:39:27,630
你已经完成了搜索，

1019
00:39:27,630 --> 00:39:29,610
通常这是在每个蓝色的基础上完成的，

1020
00:39:29,610 --> 00:39:31,800
因为如果它

1021
00:39:31,800 --> 00:39:34,020
很多很多很多 表中有很多连接，

1022
00:39:34,020 --> 00:39:36,180
你实际上永远不会用完这一切，

1023
00:39:36,180 --> 00:39:40,200
所以给它一个例子来说明它

1024
00:39:40,200 --> 00:39:41,550
是如何使用的，

1025
00:39:41,550 --> 00:39:44,880
在我的续集中你可以

1026
00:39:44,880 --> 00:39:46,290
在搜索树中指定优化器搜索死亡，

1027
00:39:46,290 --> 00:39:49,260
这样这可能会阻止你去

1028
00:39:49,260 --> 00:39:52,950
很远的地方和分支，

1029
00:39:52,950 --> 00:39:54,630
你开始人为地c 在

1030
00:39:54,630 --> 00:39:56,910
搜索中，你知道这么多层次的深度

1031
00:39:56,910 --> 00:39:59,340
，所以你

1032
00:39:59,340 --> 00:40:03,930
可以更快地用尽可能的选择数量，因为一些

1033
00:40:03,930 --> 00:40:06,540
系统试图是动态的，而且通常

1034
00:40:06,540 --> 00:40:11,210
很难做到这一点，所以这是

1035
00:40:11,210 --> 00:40:14,220
一篇来自 percona 的半 Tina 博客文章，

1036
00:40:14,220 --> 00:40:17,150
他是 我的续集咨询公司的主要公司之一对我的续集

1037
00:40:17,150 --> 00:40:19,320
进行了大量

1038
00:40:19,320 --> 00:40:21,480
开发，所以早在 2012 年，

1039
00:40:21,480 --> 00:40:24,510
他们就谈到了他们是如何做到这一点的，他们

1040
00:40:24,510 --> 00:40:26,130
有一个客户正在

1041
00:40:26,130 --> 00:40:29,700
对 20 个表进行选择查询，

1042
00:40:29,700 --> 00:40:32,640
优化器花了 5 秒钟才

1043
00:40:32,640 --> 00:40:34,440
找到 查询计划和查询只运行

1044
00:40:34,440 --> 00:40:36,540
了 50 毫秒，因为它正在

1045
00:40:36,540 --> 00:40:38,880
读取一千个元组，因此通过

1046
00:40:38,880 --> 00:40:40,320
说像搜索死亡并

1047
00:40:40,320 --> 00:40:41,820
人为地将其全部从只

1048
00:40:41,820 --> 00:40:43,710
执行他的搜索中删除，他们

1049
00:40:43,710 --> 00:40:45,300
能够在优化器中将其降低到

1050
00:40:45,300 --> 00:40:48,750
在几毫秒内完成 所以所有

1051
00:40:48,750 --> 00:40:49,980
不同的数据系统都有不同的

1052
00:40:49,980 --> 00:40:52,740
工具来解决这些问题

1053
00:40:52,740 --> 00:40:55,550
所以现在我们想再次讨论

1054
00:40:55,550 --> 00:40:57,870
服务 这些就是我们只

1055
00:40:57,870 --> 00:40:59,100
讨论所有设计决策 s

1056
00:40:59,100 --> 00:41:00,720
我们必须考虑何时

1057
00:41:00,720 --> 00:41:01,890
构建优化器 如何处理准备好的

1058
00:41:01,890 --> 00:41:03,180
语句 如何决定何时完成

1059
00:41:03,180 --> 00:41:05,490


1060
00:41:05,490 --> 00:41:07,170
搜索 对一个查询实际执行什么搜索 多个查询

1061
00:41:07,170 --> 00:41:09,060
诸如此类的事情 现在我们想

1062
00:41:09,060 --> 00:41:11,490
谈谈搜索是什么 知道这是

1063
00:41:11,490 --> 00:41:13,860
什么服务 优化器

1064
00:41:13,860 --> 00:41:15,180
实际上是什么样子 它实际上

1065
00:41:15,180 --> 00:41:17,070
如何从

1066
00:41:17,070 --> 00:41:20,540
逻辑计划生成物理计划 所以

1067
00:41:20,540 --> 00:41:22,760
思考我们今天要讨论的内容的方式是

1068
00:41:22,760 --> 00:41:25,730
我们前进到时间和

1069
00:41:25,730 --> 00:41:28,740
复杂性 所以它从那时

1070
00:41:28,740 --> 00:41:30,570
起就像历史点，就像

1071
00:41:30,570 --> 00:41:32,580


1072
00:41:32,580 --> 00:41:35,160
他们在 1970 年代首次构建的基于启发式的优化器一样

1073
00:41:35,160 --> 00:41:36,930
，你知道我们

1074
00:41:36,930 --> 00:41:38,390
正在使用更新的新

1075
00:41:38,390 --> 00:41:40,290
实现，另一个我认为也考虑过

1076
00:41:40,290 --> 00:41:44,010
这些是

1077
00:41:44,010 --> 00:41:45,090
基于启发式的，是构建优化器的最简单方法，

1078
00:41:45,090 --> 00:41:45,810


1079
00:41:45,810 --> 00:41:47,670
尽管它的工程方面可能会

1080
00:41:47,670 --> 00:41:51,120
变得非常非常混乱，但

1081
00:41:51,120 --> 00:41:53,310
随着实现的深入 矿石很复杂

1082
00:41:53,310 --> 00:41:54,870
，因此

1083
00:41:54,870 --> 00:41:57,060
他们可以应用的查询优化和规则

1084
00:41:57,060 --> 00:41:59,340
变得

1085
00:41:59,340 --> 00:42:03,470
更加复杂，所以我们将讨论

1086
00:42:03,470 --> 00:42:05,370
这些这些值得讨论的，

1087
00:42:05,370 --> 00:42:06,810
因为这是

1088
00:42:06,810 --> 00:42:08,160
人们第一次构建系统时经常看到的，

1089
00:42:08,160 --> 00:42:09,240
因为它们是 没有调用

1090
00:42:09,240 --> 00:42:10,680
空间搜索模型 他们将使用

1091
00:42:10,680 --> 00:42:12,240
启发式 有时启发式

1092
00:42:12,240 --> 00:42:15,330
方法今天仍然被广泛使用

1093
00:42:15,330 --> 00:42:17,220
然后统一搜索和分层

1094
00:42:17,220 --> 00:42:18,840
搜索我们将

1095
00:42:18,840 --> 00:42:21,750
在今天得到很好的讨论 将起床到火山

1096
00:42:21,750 --> 00:42:23,900
优化器 然后，当我们更详细地讨论 Cascades 时，这将继续

1097
00:42:23,900 --> 00:42:25,740
到下一个讲座中，

1098
00:42:25,740 --> 00:42:32,190
所以

1099
00:42:32,190 --> 00:42:34,050
第一个查询优化器是针对

1100
00:42:34,050 --> 00:42:35,880
1970 年代的关系数据库系统，

1101
00:42:35,880 --> 00:42:37,590
用于我们使用基于启发式转换的三个第一个关系

1102
00:42:37,590 --> 00:42:41,190
数据库系统中的两个

1103
00:42:41,190 --> 00:42:44,550
这里的想法

1104
00:42:44,550 --> 00:42:47,370
是，在代码本身中，您

1105
00:42:47,370 --> 00:42:50,760
定义了这些规则，这些规则将

1106
00:42:50,760 --> 00:42:53,610
转换逻辑运算符和

1107
00:42:53,610 --> 00:42:57,330
物理运算符，以便 他最

1108
00:42:57,330 --> 00:42:58,530
常见的事情是，如果我正在

1109
00:42:58,530 --> 00:43:00,780
做扫描并且我知道我有一个索引

1110
00:43:00,780 --> 00:43:02,820
，它匹配

1111
00:43:02,820 --> 00:43:04,860
我的 where 子句中的所有谓词，那么这

1112
00:43:04,860 --> 00:43:06,480
就是我想要使用的索引，所以这

1113
00:43:06,480 --> 00:43:08,070
有点像 我们

1114
00:43:08,070 --> 00:43:11,280
之前在几张幻灯片中讨论

1115
00:43:11,280 --> 00:43:12,540
过的那些 stargell 东西，这就是

1116
00:43:12,540 --> 00:43:14,220
您可以进行从逻辑

1117
00:43:14,220 --> 00:43:15,390
到物理的标准转换，但是

1118
00:43:15,390 --> 00:43:16,650
您可以为提高

1119
00:43:16,650 --> 00:43:19,080
查询性能而进行的一些优化将应用

1120
00:43:19,080 --> 00:43:21,240
您想要的所有和基本规则

1121
00:43:21,240 --> 00:43:22,650
有一个像谓词下推这样的查询执行

1122
00:43:22,650 --> 00:43:25,140
让我下推

1123
00:43:25,140 --> 00:43:25,770
一些类似

1124
00:43:25,770 --> 00:43:27,660
我的谓词下推的东西而

1125
00:43:27,660 --> 00:43:29,490
不是让你知道它可能是

1126
00:43:29,490 --> 00:43:31,020
查询计划顶部的谓词我一直

1127
00:43:31,020 --> 00:43:33,060
把它推到我的访问

1128
00:43:33,060 --> 00:43:35,130
方法，以便我尽可能快地过滤掉元组

1129
00:43:35,130 --> 00:43:36,990
，我不是你

1130
00:43:36,990 --> 00:43:38,340
知道将一个漏斗传递到

1131
00:43:38,340 --> 00:43:39,530
下一个昂贵的商品，

1132
00:43:39,530 --> 00:43:41,640
另一件常见的事情也是

1133
00:43:41,640 --> 00:43:43,260
通过处理连接订购 只是

1134
00:43:43,260 --> 00:43:45,240
基数估计 他们可以

1135
00:43:45,240 --> 00:43:46,890
说你知道我们连接了两个表

1136
00:43:46,890 --> 00:43:50,010
你知道哪一个可能你可以估计

1137
00:43:50,010 --> 00:43:52,350
哪一个将有更多的

1138
00:43:52,350 --> 00:43:53,760
三元组输入联合运算符

1139
00:43:53,760 --> 00:43:55,770
所以你把一对一作为

1140
00:43:55,770 --> 00:43:57,960
外部对一个作为内部 这是简单的

1141
00:43:57,960 --> 00:44:00,450
规则 像这样，所以

1142
00:44:00,450 --> 00:44:01,980
我看到的重要事情是，没有

1143
00:44:01,980 --> 00:44:03,960
涉及成本模型，这一切都是

1144
00:44:03,960 --> 00:44:06,960
静态的，就像我看到一个查询，一个查询

1145
00:44:06,960 --> 00:44:07,990
规划器有这种

1146
00:44:07,990 --> 00:44:10,730
模式，我总是正确地应用这条规则，

1147
00:44:10,730 --> 00:44:13,910
我总是把

1148
00:44:13,910 --> 00:44:17,390
谓词之类的事情，所以正如我所说

1149
00:44:17,390 --> 00:44:20,119
的，来自 1970 年代伯克利的主要关系数据库系统的两个或三个第一个

1150
00:44:20,119 --> 00:44:22,460
关系数据库系统

1151
00:44:22,460 --> 00:44:23,869


1152
00:44:23,869 --> 00:44:27,200
，

1153
00:44:27,200 --> 00:44:28,970
例如 Stonebreaker 和来自

1154
00:44:28,970 --> 00:44:31,460
Larry Ellison 的 Oracle，这就是他们

1155
00:44:31,460 --> 00:44:36,529
使用的和在 从那时起，就像

1156
00:44:36,529 --> 00:44:40,190
他们为您提供的资源一样，

1157
00:44:40,190 --> 00:44:42,140
因为您知道竞争研究人员

1158
00:44:42,140 --> 00:44:43,069
实际运行 Devi 系统

1159
00:44:43,069 --> 00:44:47,019
软件本身是非常有限的 所以

1160
00:44:47,019 --> 00:44:50,000
他们在 1970 年代试图存储的数据库的大小

1161
00:44:50,000 --> 00:44:52,819


1162
00:44:52,819 --> 00:44:55,940
非常小，所以就像

1163
00:44:55,940 --> 00:44:56,869
在一秒钟内谈论这个我的意思是

1164
00:44:56,869 --> 00:45:00,109
这里的入口论文的情况就像他们在

1165
00:45:00,109 --> 00:45:01,369
谈论你知道扫描

1166
00:45:01,369 --> 00:45:02,930
表格一样 三百个元组

1167
00:45:02,930 --> 00:45:05,089
，就这么简单

1168
00:45:05,089 --> 00:45:06,589


1169
00:45:06,589 --> 00:45:08,869


1170
00:45:08,869 --> 00:45:09,650


1171
00:45:09,650 --> 00:45:13,099


1172
00:45:13,099 --> 00:45:13,700


1173
00:45:13,700 --> 00:45:18,619
像 Oracle，你

1174
00:45:18,619 --> 00:45:20,569
知道它们变得庞大，并且让你知道

1175
00:45:20,569 --> 00:45:23,750
很多钱骑在一个你知道

1176
00:45:23,750 --> 00:45:25,490
最简单的优化器类型

1177
00:45:25,490 --> 00:45:27,859
你可以再次拥有一个我没有

1178
00:45:27,859 --> 00:45:28,940
所有事情都讨论过的成本模型

1179
00:45:28,940 --> 00:45:31,099
并且继续前进，就像

1180
00:45:31,099 --> 00:45:33,589
他们仅仅基于此而变得巨大所以我

1181
00:45:33,589 --> 00:45:34,819
不想说我想发出声音

1182
00:45:34,819 --> 00:45:37,250
或听起来像我说你不能你

1183
00:45:37,250 --> 00:45:38,630
不能拥有一个复杂的数据系统

1184
00:45:38,630 --> 00:45:39,890
而没有基于成本的 优化器

1185
00:45:39,890 --> 00:45:43,730
显然 Oracle 走得很远 有了它，

1186
00:45:43,730 --> 00:45:45,380
但又回到了 1990 年代，

1187
00:45:45,380 --> 00:45:46,579
他们处理的查询类型就像

1188
00:45:46,579 --> 00:45:49,309
续集 92 标准一样，没有 CT es 没有人可以

1189
00:45:49,309 --> 00:45:51,049
运行，也没有使用定义聚合，

1190
00:45:51,049 --> 00:45:54,730
所有这些东西都不存在，所以

1191
00:45:54,730 --> 00:45:57,619
它实际上是可行的，但也是

1192
00:45:57,619 --> 00:45:59,390
Mongo 在

1193
00:45:59,390 --> 00:46:02,829
没有基于成本的优化器的情况下变得非常大，所以

1194
00:46:02,829 --> 00:46:04,789
我和一些在 Oracle 查询优化器上工作的人谈过，

1195
00:46:04,789 --> 00:46:06,589


1196
00:46:06,589 --> 00:46:09,170
就像在 1980 年代 1990 年代一样，

1197
00:46:09,170 --> 00:46:14,269
他们会说这是最大的

1198
00:46:14,269 --> 00:46:17,450
一段代码 在系统中，它

1199
00:46:17,450 --> 00:46:19,099
非常复杂，它可以做什么，

1200
00:46:19,099 --> 00:46:21,560
但这就像一个工程噩梦，

1201
00:46:21,560 --> 00:46:23,060
因为一切都是用 C 编写的，

1202
00:46:23,060 --> 00:46:25,310
没有任何债务，你知道规则的高级 DSL

1203
00:46:25,310 --> 00:46:27,470
订单声明对，他

1204
00:46:27,470 --> 00:46:28,790
是一堆 if  if then else

1205
00:46:28,790 --> 00:46:32,480
语句等等，他们有

1206
00:46:32,480 --> 00:46:34,190
很多钱，他们有一些非常聪明的

1207
00:46:34,190 --> 00:46:36,230
人，他们可以通过扩展这个来做你知道

1208
00:46:36,230 --> 00:46:38,510
了不起的事情，但它

1209
00:46:38,510 --> 00:46:40,820
只是站得住脚，我说

1210
00:46:40,820 --> 00:46:43,130
这就是他们转向t的原因 他是

1211
00:46:43,130 --> 00:46:45,290
基于成本的模型 基于成本的

1212
00:46:45,290 --> 00:46:46,130
搜索 我们将在

1213
00:46:46,130 --> 00:46:50,420
第二个权利中讨论 所以这也是

1214
00:46:50,420 --> 00:46:51,590
ingress 开始时所做的 这一切都会

1215
00:46:51,590 --> 00:46:53,090
在开始时发布 我不是

1216
00:46:53,090 --> 00:46:54,140
说这是正确的方法

1217
00:46:54,140 --> 00:46:56,900
有些情况是有些情况不是，

1218
00:46:56,900 --> 00:46:59,120
所以让我们再谈谈 ingress 做

1219
00:46:59,120 --> 00:47:01,520
了什么这主要只是为了她的中风

1220
00:47:01,520 --> 00:47:02,840
或好奇心

1221
00:47:02,840 --> 00:47:06,080
所以接下来我们将使用

1222
00:47:06,080 --> 00:47:07,760
以下三个表模式和

1223
00:47:07,760 --> 00:47:11,200
Spotify 或 Apple iTunes 数据库的示例查询

1224
00:47:11,200 --> 00:47:13,910
所以我们有艺术家，我们有

1225
00:47:13,910 --> 00:47:15,890
专辑，然后艺术家出现在

1226
00:47:15,890 --> 00:47:17,300
专辑中，所以我们只是跟踪

1227
00:47:17,300 --> 00:47:19,670
你知道什么会

1228
00:47:19,670 --> 00:47:21,260
记录什么专辑正在发行

1229
00:47:21,260 --> 00:47:24,740
什么艺术家在那里所以让我们

1230
00:47:24,740 --> 00:47:26,480
谈谈 ingress 这样做 这是

1231
00:47:26,480 --> 00:47:29,180
1970 年代使用的 ingress 所以

1232
00:47:29,180 --> 00:47:31,220
为此我们将在此处使用此查询，

1233
00:47:31,220 --> 00:47:32,690
其中艺术家之间的三向连接

1234
00:47:32,690 --> 00:47:35,030
显示为专辑，我们希望

1235
00:47:35,030 --> 00:47:37,700
让出现在我的

1236
00:47:37,700 --> 00:47:42,950
下一盘磁带中的所有艺术家都是正确的 angrist 没有

1237
00:47:42,950 --> 00:47:47,660
它的连接方式是 Hedda 说

1238
00:47:47,660 --> 00:47:53,270
ingress 不支持连接，所以他们不得不

1239
00:47:53,270 --> 00:47:57,200
将所有查询重写为单

1240
00:47:57,200 --> 00:47:58,460
表查询，因为再次因为

1241
00:47:58,460 --> 00:48:01,790
他们无法将表连接在一起，所以

1242
00:48:01,790 --> 00:48:04,640
他们要做的第一步是

1243
00:48:04,640 --> 00:48:06,410
他们会采取 像这样联合播放

1244
00:48:06,410 --> 00:48:09,020
然后他们会将它

1245
00:48:09,020 --> 00:48:12,890
分解为单值查询所以我有什么

1246
00:48:12,890 --> 00:48:15,860
不好所以说你在这里使用这个查询

1247
00:48:15,860 --> 00:48:17,660
我们将把它改写成两个查询

1248
00:48:17,660 --> 00:48:19,580
所以现在第一个查询

1249
00:48:19,580 --> 00:48:21,950
只是在专辑中 我们在

1250
00:48:21,950 --> 00:48:23,180
其中查找专辑名称的表，

1251
00:48:23,180 --> 00:48:24,470
因为那是我们在此处传递的内容

1252
00:48:24,470 --> 00:48:26,570
，因此这只是

1253
00:48:26,570 --> 00:48:28,520
此处单个表中的一个选择，但随后我们

1254
00:48:28,520 --> 00:48:31,700
会将其写入临时表中，

1255
00:48:31,700 --> 00:48:34,700
然后现在 对于这里的这个查询，我们

1256
00:48:34,700 --> 00:48:35,390


1257
00:48:35,390 --> 00:48:37,819
在这里和这里用我们的临时表引用替换专辑

1258
00:48:37,819 --> 00:48:39,799
所以现在我们要递归

1259
00:48:39,799 --> 00:48:43,069
地重写这个查询以删除

1260
00:48:43,069 --> 00:48:45,319
我们拥有的连接，所以现在我们

1261
00:48:45,319 --> 00:48:47,299
要在这里有这个新查询

1262
00:48:47,299 --> 00:48:48,859
只是在同龄人的智慧上进行查找 ha

1263
00:48:48,859 --> 00:48:51,650
在临时 1 上连接，它会将

1264
00:48:51,650 --> 00:48:54,920
输出写入 10 - 然后在艺术家表上的这个查询

1265
00:48:54,920 --> 00:48:57,380
将进行查找或

1266
00:48:57,380 --> 00:49:00,230
对 Tim 进行连接 - 所以现在一旦你这样做，

1267
00:49:00,230 --> 00:49:02,240
一旦你进行重写，你

1268
00:49:02,240 --> 00:49:04,640
就会替换 来自

1269
00:49:04,640 --> 00:49:07,430
这些临时表的值

1270
00:49:07,430 --> 00:49:11,599
与查询产生的实际值，所以说我们

1271
00:49:11,599 --> 00:49:12,799
在这里很好地执行第一个，

1272
00:49:12,799 --> 00:49:15,260
然后生成获取

1273
00:49:15,260 --> 00:49:19,160
专辑 ID 999 的输出，然后现在我们转到

1274
00:49:19,160 --> 00:49:21,740
下一个查询，我们替换

1275
00:49:21,740 --> 00:49:25,670
对 temp 的引用 1 现在是

1276
00:49:25,670 --> 00:49:27,619
由前一个查询生成的 9999 所以现在

1277
00:49:27,619 --> 00:49:29,299
这不再是一个联合这是一个

1278
00:49:29,299 --> 00:49:31,250
单语句或单表查询

1279
00:49:31,250 --> 00:49:33,710
，我只是替换

1280
00:49:33,710 --> 00:49:35,680
从前一个查询产生的那个值，

1281
00:49:35,680 --> 00:49:38,420
同样的事情在这里这个查询现在运行

1282
00:49:38,420 --> 00:49:40,309
产生两个输出，然后现在我可以

1283
00:49:40,309 --> 00:49:42,980
将此查询重写为两个查询，

1284
00:49:42,980 --> 00:49:44,480
一个采用艺术家 ID 一二三

1285
00:49:44,480 --> 00:49:46,130
，荷兰采用艺术家 ID 4 5 6

1286
00:49:46,130 --> 00:49:48,950
，我实际上可以

1287
00:49:48,950 --> 00:49:51,289
产生这些查询的结果，将它们组合

1288
00:49:51,289 --> 00:49:53,089
起来 以太，然后这

1289
00:49:53,089 --> 00:49:57,920
就是我的 join 的输出，好吧，所以这是非常

1290
00:49:57,920 --> 00:49:59,509
令人印象深刻的，这就像一种重写查询的方法，

1291
00:49:59,509 --> 00:50:02,329


1292
00:50:02,329 --> 00:50:05,180
我的意思是我在续集级别展示这一点，

1293
00:50:05,180 --> 00:50:07,210
他们将在

1294
00:50:07,210 --> 00:50:12,019
物理计划级别上这样做 知道这允许

1295
00:50:12,019 --> 00:50:13,430
它们实际连接而不实际

1296
00:50:13,430 --> 00:50:14,930
具有联合实现，就像

1297
00:50:14,930 --> 00:50:16,160
您只是在执行单个语句

1298
00:50:16,160 --> 00:50:20,359
选择，因此有人认为这

1299
00:50:20,359 --> 00:50:22,339
实际上是自适应查询优化的早期示例，

1300
00:50:22,339 --> 00:50:24,500
因为而不是

1301
00:50:24,500 --> 00:50:26,059


1302
00:50:26,059 --> 00:50:30,559
在我将生成的静态优化方法中执行

1303
00:50:30,559 --> 00:50:34,309
一次为我的整个查询制定计划 我可以

1304
00:50:34,309 --> 00:50:36,529
在这里进行续集查询 我认为

1305
00:50:36,529 --> 00:50:37,640
他们没有操作物理

1306
00:50:37,640 --> 00:50:39,079
计划 他们可能对逻辑

1307
00:50:39,079 --> 00:50:42,309
计划进行操作 但我可以在这里进行此查询，

1308
00:50:42,309 --> 00:50:46,309
并且只有当我得到值一两个时

1309
00:50:46,309 --> 00:50:47,150
三个我想用替代品

1310
00:50:47,150 --> 00:50:48,800
替代它

1311
00:50:48,800 --> 00:50:50,930
然后我解雇了我将它发送给

1312
00:50:50,930 --> 00:50:52,340
查询优化器然后

1313
00:50:52,340 --> 00:50:54,110
为它生成物理计划所以它有点

1314
00:50:54,110 --> 00:50:56,660
像迟到了 绑定优化

1315
00:50:56,660 --> 00:50:59,270
方法就像我可以

1316
00:50:59,270 --> 00:51:00,740
从这些查询中得到的信息中学习，

1317
00:51:00,740 --> 00:51:02,990
以

1318
00:51:02,990 --> 00:51:04,690
决定实际这个特定查询的最佳方法是

1319
00:51:04,690 --> 00:51:07,220
什么，它又

1320
00:51:07,220 --> 00:51:08,480
不是适配器查询优化，但

1321
00:51:08,480 --> 00:51:09,920
它们本质上是在运行

1322
00:51:09,920 --> 00:51:12,320
以每个学生为基础的优化器，

1323
00:51:12,320 --> 00:51:18,110
今天没有人这样做 好吧，好吧，基于 Harriston 的优化

1324
00:51:18,110 --> 00:51:19,370
的缺点有哪些优点，

1325
00:51:19,370 --> 00:51:20,900
因此

1326
00:51:20,900 --> 00:51:23,750
它很容易实现它很容易

1327
00:51:23,750 --> 00:51:25,820
调试，因为你只需使用

1328
00:51:25,820 --> 00:51:27,230
gdb 或任何你最喜欢的调试

1329
00:51:27,230 --> 00:51:29,210
器来完成 并逐步了解哪些

1330
00:51:29,210 --> 00:51:32,330
规则实际上会被触发，并

1331
00:51:32,330 --> 00:51:34,250
确定为什么我的意思是为什么我选择了一个

1332
00:51:34,250 --> 00:51:37,220
特定的计划而不是另一个权利，

1333
00:51:37,220 --> 00:51:40,910
正如我在今天构建一个新的

1334
00:51:40,910 --> 00:51:42,710
数据库系统只是为了启动

1335
00:51:42,710 --> 00:51:43,700
和运行时所说的那样 并请原谅一些第一次

1336
00:51:43,700 --> 00:51:46,160
查询，您可以使用基于

1337
00:51:46,160 --> 00:51:47,840
arista 烘焙启发式的

1338
00:51:47,840 --> 00:51:54,070
优化器走得很远，但缺点是，

1339
00:51:54,070 --> 00:51:57,710
如果您愿意 我必须

1340
00:51:57,710 --> 00:52:00,370


1341
00:52:00,370 --> 00:52:03,740
在源代码本身

1342
00:52:03,740 --> 00:52:06,050
或在配置文件中定义这些恒定的阈值或值，以

1343
00:52:06,050 --> 00:52:08,570
帮助我确定

1344
00:52:08,570 --> 00:52:11,450
您必须做出的某些决定，例如

1345
00:52:11,450 --> 00:52:13,160
我是否想确定是否

1346
00:52:13,160 --> 00:52:15,830
要加入一个群体 将逻辑执行计划或

1347
00:52:15,830 --> 00:52:17,570
运算符转换为物理连接运算符

1348
00:52:17,570 --> 00:52:19,220
，然后需要确定它的

1349
00:52:19,220 --> 00:52:20,840
排序合并连接是否比哈希连接快

1350
00:52:20,840 --> 00:52:24,650


1351
00:52:24,650 --> 00:52:28,490


1352
00:52:28,490 --> 00:52:30,680


1353
00:52:30,680 --> 00:52:32,870
实际上，数据看起来像什么

1354
00:52:32,870 --> 00:52:36,410
可能很棘手，关于此的另一个棘手

1355
00:52:36,410 --> 00:52:37,490
事情是，

1356
00:52:37,490 --> 00:52:39,260
现在基本上不可能生成

1357
00:52:39,260 --> 00:52:42,380
计划，当转换是

1358
00:52:42,380 --> 00:52:44,480
您要应用的优化

1359
00:52:44,480 --> 00:52:46,760
时，它们之间可能存在依赖关系，这

1360
00:52:46,760 --> 00:52:48,950
意味着我会 就像说你想要我

1361
00:52:48,950 --> 00:52:50,900
想转 我想应用

1362
00:52:50,900 --> 00:52:54,530
优化 a 并根据

1363
00:52:54,530 --> 00:52:57,290
我是否选择该优化 我可能

1364
00:52:57,290 --> 00:52:58,880
想要也可能不想选择

1365
00:52:58,880 --> 00:53:00,290
优化 n

1366
00:53:00,290 --> 00:53:04,130
B 所以现在如果我写这个并且

1367
00:53:04,130 --> 00:53:06,260
只是基于规则我必须写那个

1368
00:53:06,260 --> 00:53:07,940
明确的规则才能知道如果我做 a

1369
00:53:07,940 --> 00:53:10,430
那么不要做 B 或者我不做 a 那么

1370
00:53:10,430 --> 00:53:12,200
我可以做 BI 必须手动编写所有这些

1371
00:53:12,200 --> 00:53:14,510
和源代码

1372
00:53:14,510 --> 00:53:16,070
我们在基于成本的搜索中 我们将

1373
00:53:16,070 --> 00:53:18,110
在下一张幻灯片中讨论 如果您

1374
00:53:18,110 --> 00:53:20,390
以破解方式编写成本模型 您可以使用

1375
00:53:20,390 --> 00:53:22,930
这种搜索

1376
00:53:22,930 --> 00:53:25,130
引擎类型的搜索 发现这对你来说是

1377
00:53:25,130 --> 00:53:26,360
正确的，你不必再直接编码它

1378
00:53:26,360 --> 00:53:28,940
，因为我说过

1379
00:53:28,940 --> 00:53:31,280
基于启发式的方法是 1970 年代

1380
00:53:31,280 --> 00:53:33,280
出现的三个原始

1381
00:53:33,280 --> 00:53:35,120
关系数据库系统中的前两个主要

1382
00:53:35,120 --> 00:53:36,170
关系数据库系统

1383
00:53:36,170 --> 00:53:39,820
实际使用的

1384
00:53:39,820 --> 00:53:42,590
1970 年代使用的另一种著名方法

1385
00:53:42,590 --> 00:53:45,770
是将我们刚刚讨论的启发式方法与

1386
00:53:45,770 --> 00:53:48,530
调用空间

1387
00:53:48,530 --> 00:53:51,770
搜索相结合，这将成为我们将讨论

1388
00:53:51,770 --> 00:53:55,490
的所有现代优化器

1389
00:53:55,490 --> 00:53:56,870


1390
00:53:56,870 --> 00:53:59,120
基于它们的技术 他们可能不需要

1391
00:53:59,120 --> 00:54:01,340
完全使用 IBM 系统所采用的方法 e

1392
00:54:01,340 --> 00:54:03,980
正在使用，但使用

1393
00:54:03,980 --> 00:54:05,810
成本模型来估计计划的功效

1394
00:54:05,810 --> 00:54:10,400
或成本的概念是

1395
00:54:10,400 --> 00:54:12,590
每个人都使用的标准推动，因此

1396
00:54:12,590 --> 00:54:13,970
对于系统或它的工作方式

1397
00:54:13,970 --> 00:54:16,460
是他们将有静态规则首先

1398
00:54:16,460 --> 00:54:18,110
执行一些 初始优化，

1399
00:54:18,110 --> 00:54:20,090
然后他们将使用动态编程

1400
00:54:20,090 --> 00:54:22,730
方法来确定表的最佳联合

1401
00:54:22,730 --> 00:54:26,780
排序 所以我认为我们

1402
00:54:26,780 --> 00:54:28,370
谈到了 IBM 系统有点

1403
00:54:28,370 --> 00:54:31,520
但 Ted Khan 是纽约的数学家

1404
00:54:31,520 --> 00:54:35,360
他为 IBM 写了

1405
00:54:35,360 --> 00:54:39,260
这些 这是这是一篇关于关系模型的影响深远

1406
00:54:39,260 --> 00:54:41,600
且非常进步的论文

1407
00:54:41,600 --> 00:54:44,800
它完全是数学

1408
00:54:44,800 --> 00:54:47,390
入门，伯克利的护士伯顿

1409
00:54:47,390 --> 00:54:49,190
是一个团体呼吁，他们

1410
00:54:49,190 --> 00:54:50,510
接受了这篇论文并尝试构建系统

1411
00:54:50,510 --> 00:54:52,730
IBM 试图构建他们自己的版本

1412
00:54:52,730 --> 00:54:55,160
呼叫系统的系统在他

1413
00:54:55,160 --> 00:54:57,800
位于加利福尼亚州的圣何塞，他们让

1414
00:54:57,800 --> 00:55:00,200
一群人在您的

1415
00:55:00,200 --> 00:55:01,400
全新 PC 和计算机科学数学方面获得博士学位，

1416
00:55:01,400 --> 00:55:04,310
将他们放在 IBM Gabe 和 Ted ca 的一个房间里

1417
00:55:04,310 --> 00:55:05,840
用纸说好的，去做

1418
00:55:05,840 --> 00:55:08,030
这个，所以一群人

1419
00:55:08,030 --> 00:55:10,730
解决了问题的不同部分，你知道

1420
00:55:10,730 --> 00:55:12,470
一个有个人电脑的人去了，然后它的

1421
00:55:12,470 --> 00:55:14,589
续集另一个人发明了

1422
00:55:14,589 --> 00:55:18,829
存储模型或两相锁定

1423
00:55:18,829 --> 00:55:20,960
帕特塞林格是被分配的人

1424
00:55:20,960 --> 00:55:24,170
在查询优化器上

1425
00:55:24,170 --> 00:55:27,829
工作，这是一项非常非常开创性的工作，所以这

1426
00:55:27,829 --> 00:55:29,240
是调用空间查询

1427
00:55:29,240 --> 00:55:31,970
优化器的第一个示例，它也是使用

1428
00:55:31,970 --> 00:55:33,910
自下而上规划或前向链接的示例 再

1429
00:55:33,910 --> 00:55:35,900
解释几张幻灯片是否

1430
00:55:35,900 --> 00:55:37,730
真的意味着但基本上是 就像

1431
00:55:37,730 --> 00:55:38,930
我们要做一个分而治之的

1432
00:55:38,930 --> 00:55:41,390
方法，我们将从

1433
00:55:41,390 --> 00:55:44,060
查询计划中的任何内容开始，然后通过计算连接顺序来

1434
00:55:44,060 --> 00:55:46,460
尽早构建它以产生我们的

1435
00:55:46,460 --> 00:55:47,630
最终结果，

1436
00:55:47,630 --> 00:55:50,690
就像我一样 说

1437
00:55:50,690 --> 00:55:52,579
系统 R 是第一个使用这个

1438
00:55:52,579 --> 00:55:55,130
特殊邀请的系统

1439
00:55:55,130 --> 00:55:56,869
1980 年代出现的第一个 db2 版本

1440
00:55:56,869 --> 00:55:58,940
我认为借用了系统 R 的查询优化器

1441
00:55:58,940 --> 00:56:01,520
，然后是大多数开源

1442
00:56:01,520 --> 00:56:03,200
数据库 系统将使用系统的某些

1443
00:56:03,200 --> 00:56:05,990
风格，

1444
00:56:05,990 --> 00:56:07,790
就像我的续集

1445
00:56:07,790 --> 00:56:10,819
新闻媒体和续集一样使用

1446
00:56:10,819 --> 00:56:12,530
商业人员通常有

1447
00:56:12,530 --> 00:56:14,180
更复杂的东西或正在

1448
00:56:14,180 --> 00:56:16,790
使用 Cascades 好吧，让我们

1449
00:56:16,790 --> 00:56:17,720
通过一个例子来看看它实际上是什么

1450
00:56:17,720 --> 00:56:19,400
当一个系统可行时再次这样做，我们的

1451
00:56:19,400 --> 00:56:21,770
方法是您

1452
00:56:21,770 --> 00:56:23,930
将查询分解为块，然后您

1453
00:56:23,930 --> 00:56:25,760
将拥有

1454
00:56:25,760 --> 00:56:27,980
代表每个块的逻辑运算符，然后对于

1455
00:56:27,980 --> 00:56:29,150
这些运算符中的每一个，您

1456
00:56:29,150 --> 00:56:30,980
将弄清楚所有内容

1457
00:56:30,980 --> 00:56:33,170
我可以

1458
00:56:33,170 --> 00:56:35,960
用来实现该运算符的可能的物理运算符，然后

1459
00:56:35,960 --> 00:56:39,560
您将尽早构建一个

1460
00:56:39,560 --> 00:56:42,790
成本最低的查询计划，

1461
00:56:42,790 --> 00:56:44,510
本质上您将

1462
00:56:44,510 --> 00:56:46,099
要访问的所有表拼接在一起，

1463
00:56:46,099 --> 00:56:48,740
并连接以找出如何连接

1464
00:56:48,740 --> 00:56:51,470
所有这些并产生最终

1465
00:56:51,470 --> 00:56:53,329
结果是 IBM 当时做出的一项重要观察

1466
00:56:53,329 --> 00:56:55,010
是，他们

1467
00:56:55,010 --> 00:56:57,890
只会追求左深度连接树，这

1468
00:56:57,890 --> 00:56:59,480
意味着像 所有的连接

1469
00:56:59,480 --> 00:57:01,190
都只在

1470
00:57:01,190 --> 00:57:03,319
树的左侧向上，对比这就像

1471
00:57:03,319 --> 00:57:05,060
一棵浓密的树，你知道我可以连接 a

1472
00:57:05,060 --> 00:57:07,430
和 B 连接 C 和 D 并获取

1473
00:57:07,430 --> 00:57:08,510
这两个单独连接的输出并连接

1474
00:57:08,510 --> 00:57:10,670
它们 一起这将加入一棵左

1475
00:57:10,670 --> 00:57:12,800
树，但首先加入 B 然后获取它的

1476
00:57:12,800 --> 00:57:14,180
输出并加入 C 他们获取它

1477
00:57:14,180 --> 00:57:15,470
的输出并与 T 连接，

1478
00:57:15,470 --> 00:57:17,930
他们做出这个决定只看

1479
00:57:17,930 --> 00:57:21,859
左 D 树纯粹是为了最小化

1480
00:57:21,859 --> 00:57:24,319
减少搜索空间 问题

1481
00:57:24,319 --> 00:57:25,460
很好，所以如果你不得不考虑

1482
00:57:25,460 --> 00:57:27,550
茂密的树木，

1483
00:57:27,550 --> 00:57:29,720
那又会增加

1484
00:57:29,720 --> 00:57:32,360
你必须考虑的选择数量，而且

1485
00:57:32,360 --> 00:57:33,860
他们当时处理的硬件

1486
00:57:33,860 --> 00:57:36,050
被认为太贵了，

1487
00:57:36,050 --> 00:57:38,210
有时你会看到这个优化 或者

1488
00:57:38,210 --> 00:57:41,890
今天在优化器中做出的这个假设

1489
00:57:41,890 --> 00:57:44,720
即使有时一个繁琐的计划

1490
00:57:44,720 --> 00:57:50,390
会更好会更好它

1491
00:57:50,390 --> 00:57:51,860
取决于系统好吧但是

1492
00:57:51,860 --> 00:57:53,150
我

1493
00:57:53,150 --> 00:57:55,010
今天在这里谈论的方法没有任何要求

1494
00:57:55,010 --> 00:57:56,390
你是否拥有唯一的支持左撇子

1495
00:57:56,390 --> 00:57:58,820
树，你知道他们出现了，

1496
00:57:58,820 --> 00:58:01,520
他们在 70 年代回来了，所以

1497
00:58:01,520 --> 00:58:03,950
让我们回到我的问题，他们

1498
00:58:03,950 --> 00:58:07,070
在我要做出的一个不同之前提出的

1499
00:58:07,070 --> 00:58:11,000
是，现在我要 根据艺术家 ID 对这个结果的输出进行排序，

1500
00:58:11,000 --> 00:58:14,050


1501
00:58:14,050 --> 00:58:16,970
所以同样，第一步

1502
00:58:16,970 --> 00:58:17,960
是我们要

1503
00:58:17,960 --> 00:58:20,360
为每个表选择最佳访问路径 所以这

1504
00:58:20,360 --> 00:58:22,250
是我要访问的所有表 这是我的

1505
00:58:22,250 --> 00:58:23,570
所有谓词和 我将选择

1506
00:58:23,570 --> 00:58:26,450
一些并使用最佳访问方法

1507
00:58:26,450 --> 00:58:28,550
，因此对于工匠同行我

1508
00:58:28,550 --> 00:58:33,440
没有我没有我没有

1509
00:58:33,440 --> 00:58:35,780
可以使用的索引所以他们正在进行

1510
00:58:35,780 --> 00:58:38,030
特殊扫描 Alamance a 在名称上有一个索引

1511
00:58:38,030 --> 00:58:41,270
，我们现在将使用它，请

1512
00:58:41,270 --> 00:58:43,310
原谅我们将再次

1513
00:58:43,310 --> 00:58:46,040
计算这些表的所有可能的连接读数，

1514
00:58:46,040 --> 00:58:49,190
这就像您

1515
00:58:49,190 --> 00:58:51,860


1516
00:58:51,860 --> 00:58:55,280
知道我的表可能具有的所有可能的不同顺序的排列

1517
00:58:55,280 --> 00:58:57,710
，我 可以做连接 我可以做

1518
00:58:57,710 --> 00:58:59,810
笛卡尔积虽然我们可以

1519
00:58:59,810 --> 00:59:01,430
稍后把它们放出来 好吧

1520
00:59:01,430 --> 00:59:04,700
，现在对于所有这些可能的

1521
00:59:04,700 --> 00:59:07,760
订单，我想弄清楚什么是

1522
00:59:07,760 --> 00:59:09,560


1523
00:59:09,560 --> 00:59:11,780
成本最低的订单，我需要

1524
00:59:11,780 --> 00:59:14,990
根据我将使用的物理运营商来确定成本，

1525
00:59:14,990 --> 00:59:16,400
所以这只是 一个合乎逻辑的计划

1526
00:59:16,400 --> 00:59:18,620
我想加入 artisan 并以

1527
00:59:18,620 --> 00:59:19,070
专辑的形式出现

1528
00:59:19,070 --> 00:59:20,330
我不是说如何实际进行

1529
00:59:20,330 --> 00:59:22,370
加入 在这里的最后一步 这

1530
00:59:22,370 --> 00:59:23,390
实际上是我们想要弄清楚的地方

1531
00:59:23,390 --> 00:59:27,230
所以系统 R 是一种自下而上的方法

1532
00:59:27,230 --> 00:59:29,330
，我们 '将从查询计划的底部开始，在

1533
00:59:29,330 --> 00:59:31,790
那里我们没有

1534
00:59:31,790 --> 00:59:33,380
任何信息，我们还没有进行

1535
00:59:33,380 --> 00:59:34,880
任何连接，但我们只是说我们有这

1536
00:59:34,880 --> 00:59:37,760
三个表，艺术家专辑出现，

1537
00:59:37,760 --> 00:59:39,200
这就是我们想要的地方

1538
00:59:39,200 --> 00:59:39,630


1539
00:59:39,630 --> 00:59:41,670
所以我们想弄清楚

1540
00:59:41,670 --> 00:59:44,310
社区如何一起达到这个

1541
00:59:44,310 --> 00:59:46,860
最终结果就在我们加入的

1542
00:59:46,860 --> 00:59:49,770
艺术家出现的地方以及他们如何在一起所以

1543
00:59:49,770 --> 00:59:53,760
我们将看看所有

1544
00:59:53,760 --> 00:59:55,440
可能的加入我们第一

1545
00:59:55,440 --> 00:59:57,240
阶段的饮料 所以我想拿两张桌子

1546
00:59:57,240 --> 00:59:59,250
把它们连在一起所以我 可以加入工匠

1547
00:59:59,250 --> 01:00:01,260
出现 Alban 出现在专辑

1548
01:00:01,260 --> 01:00:02,700
中 然后我

1549
01:00:02,700 --> 01:00:04,980
在最后一张幻灯片中展示的所有其他人 我在

1550
01:00:04,980 --> 01:00:06,060
这里截断 因为我们

1551
01:00:06,060 --> 01:00:08,790
空间不足 然后我所拥有的会消失

1552
01:00:08,790 --> 01:00:10,620
我从一开始就散发出来 点我

1553
01:00:10,620 --> 01:00:13,770
有一条到达那里的路径，可以

1554
01:00:13,770 --> 01:00:16,500
使用特定的物理算法，

1555
01:00:16,500 --> 01:00:17,850
所以我可以做一个散列连接

1556
01:00:17,850 --> 01:00:20,310
来加入工匠出现，或者我可以做

1557
01:00:20,310 --> 01:00:22,200
某种或加入加入工匠同行

1558
01:00:22,200 --> 01:00:24,300
，同样加入专辑出现我 可以

1559
01:00:24,300 --> 01:00:26,070
做一个散列连接，服务器连接

1560
01:00:26,070 --> 01:00:29,280
等等，但是现在对于

1561
01:00:29,280 --> 01:00:31,620
这些不同的物理物理

1562
01:00:31,620 --> 01:00:33,870
操作符中的每一个，我可以估计

1563
01:00:33,870 --> 01:00:37,530
执行它的成本是多少，然后我对于每个

1564
01:00:37,530 --> 01:00:40,290
从一个节点到这个节点

1565
01:00:40,290 --> 01:00:44,160
我选择 到达该节点的哪条路径

1566
01:00:44,160 --> 01:00:46,950
成本最低 所以

1567
01:00:46,950 --> 01:00:48,510
假设在这种情况下从这个

1568
01:00:48,510 --> 01:00:50,280
节点到这个节点哈希连接的

1569
01:00:50,280 --> 01:00:52,200
成本较低

1570
01:00:52,200 --> 01:00:54,270


1571
01:00:54,270 --> 01:00:57,540
那么现在我想做同样的事情

1572
01:00:57,540 --> 01:01:00,540
从查询计划的下一个级别开始的事情

1573
01:01:00,540 --> 01:01:04,140
我想说

1574
01:01:04,140 --> 01:01:06,960
我可以使用什么物理运算符来执行最后一个连接，

1575
01:01:06,960 --> 01:01:09,630
所以我再次在这里显示一个子集

1576
01:01:09,630 --> 01:01:11,460
我可以

1577
01:01:11,460 --> 01:01:13,680
对这些不同

1578
01:01:13,680 --> 01:01:16,440
方法，然后是同样的事情，我

1579
01:01:16,440 --> 01:01:18,870
想选择

1580
01:01:18,870 --> 01:01:20,970
从一个

1581
01:01:20,970 --> 01:01:23,270
节点到下一个节点的物理操作员的哪个计划的成本最低，

1582
01:01:23,270 --> 01:01:26,130
然后现在一旦我有了这个，我就回溯

1583
01:01:26,130 --> 01:01:29,040
并说好让我从的路径是什么

1584
01:01:29,040 --> 01:01:30,780
我的起点到我的

1585
01:01:30,780 --> 01:01:32,400
终点通过这些

1586
01:01:32,400 --> 01:01:35,190
成本最低的物理运算

1587
01:01:35,190 --> 01:01:37,200
符，也就是说它正在执行一个

1588
01:01:37,200 --> 01:01:38,580
哈希连接，然后是一个哈希连接，

1589
01:01:38,580 --> 01:01:40,860
这

1590
01:01:40,860 --> 01:01:42,720
是所有连接中成本最低的一个，这

1591
01:01:42,720 --> 01:01:45,210
就是一个 我想再次使用

1592
01:01:45,210 --> 01:01:46,470
分而治之，因为与其

1593
01:01:46,470 --> 01:01:51,510
看着你知道完整的传球，你

1594
01:01:51,510 --> 01:01:53,610
知道你知道从这里到这里，

1595
01:01:53,610 --> 01:01:55,350
但为了估计成本，我

1596
01:01:55,350 --> 01:01:57,090
只从下一个阶段开始

1597
01:01:57,090 --> 01:01:58,800
，然后一次 如果我 确定然后我

1598
01:01:58,800 --> 01:02:00,120
进入下一阶段然后将它

1599
01:02:00,120 --> 01:02:04,230
组合在一起产生结果所以但是

1600
01:02:04,230 --> 01:02:06,510
这个特定的查询虽然

1601
01:02:06,510 --> 01:02:10,440
记住我已经添加了顺序所以现在我

1602
01:02:10,440 --> 01:02:13,170
关心我之后输出的排序顺序

1603
01:02:13,170 --> 01:02:16,290
是什么 加入他们，但

1604
01:02:16,290 --> 01:02:18,840
我在这里生成的这个计划中没有任何内容

1605
01:02:18,840 --> 01:02:22,560
告诉

1606
01:02:22,560 --> 01:02:24,990
我排序顺序可能是正确的，这

1607
01:02:24,990 --> 01:02:28,830
是因为至少系统是如何

1608
01:02:28,830 --> 01:02:33,480
设置的，没有

1609
01:02:33,480 --> 01:02:36,090
物理属性的概念或

1610
01:02:36,090 --> 01:02:39,300
我想要的数据的排序顺序，所以

1611
01:02:39,300 --> 01:02:42,030
在这种情况下，我在这里进行哈希连接

1612
01:02:42,030 --> 01:02:44,520
，这意味着数据

1613
01:02:44,520 --> 01:02:46,410
将以随机排序顺序随机，

1614
01:02:46,410 --> 01:02:49,230
然后我现在需要按某种顺序执行顺序

1615
01:02:49,230 --> 01:02:51,480
sort 运算符将数据

1616
01:02:51,480 --> 01:02:53,970
放入我想要的物理顺序，但

1617
01:02:53,970 --> 01:02:57,510
如果我知道我

1618
01:02:57,510 --> 01:02:59,040
需要这一天以某种

1619
01:02:59,040 --> 01:03:01,530
方式返回这里，那么也许我会选择一个排序

1620
01:03:01,530 --> 01:03:03,540
服务器连接，因为那

1621
01:03:03,540 --> 01:03:04,710
会给你两个 对于一个我

1622
01:03:04,710 --> 01:03:06,510
会给我 r 进行连接并

1623
01:03:06,510 --> 01:03:08,940
以我想要的方式对数据进行排序，

1624
01:03:08,940 --> 01:03:11,340
但由于这种设置方式

1625
01:03:11,340 --> 01:03:13,320
与物理

1626
01:03:13,320 --> 01:03:14,640
属性无关，它可以

1627
01:03:14,640 --> 01:03:17,100
帮助做出此决定的数据，因此

1628
01:03:17,100 --> 01:03:18,390
实际上希望成为限制

1629
01:03:18,390 --> 01:03:19,980
我们将看到系统是什么，我们将看到

1630
01:03:19,980 --> 01:03:23,040
如何在

1631
01:03:23,040 --> 01:03:25,640
稍后的分层或统一搜索中解决这个问题

1632
01:03:25,640 --> 01:03:31,830
，是的，所以系统

1633
01:03:31,830 --> 01:03:33,270
解决这个问题的方式是他们实际上

1634
01:03:33,270 --> 01:03:35,130
必须在 成本模型本身

1635
01:03:35,130 --> 01:03:37,560
有一些他们想要日期的排序顺序的概念，

1636
01:03:37,560 --> 01:03:39,660
这样他们

1637
01:03:39,660 --> 01:03:41,580
就可以确定 SIRT

1638
01:03:41,580 --> 01:03:44,190
合并比散列连接更可取

1639
01:03:44,190 --> 01:03:45,960
，对于这个特定的例子，但

1640
01:03:45,960 --> 01:03:47,400
你知道那是一半 是的，

1641
01:03:47,400 --> 01:03:49,140
因为现在成本模型

1642
01:03:49,140 --> 01:03:51,660
中的数据应该看起来是合乎逻辑的

1643
01:03:51,660 --> 01:03:53,850
，然后它

1644
01:03:53,850 --> 01:03:55,740
与搜索策略本身的实际情况有所不同，

1645
01:03:55,740 --> 01:03:58,530
所以这是一个问题，

1646
01:03:58,530 --> 01:04:00,810
所以我想简单地谈谈这

1647
01:04:00,810 --> 01:04:02,730
两者之间的区别 e 自下而上

1648
01:04:02,730 --> 01:04:05,130
和自上而下 所以黄油再次

1649
01:04:05,130 --> 01:04:06,600
向您展示的内容被认为是自下而上的

1650
01:04:06,600 --> 01:04:07,140
查询选项

1651
01:04:07,140 --> 01:04:09,450
策略 它是您从一无所有开始的地方

1652
01:04:09,450 --> 01:04:11,370
然后您建立一个计划以获得

1653
01:04:11,370 --> 01:04:13,680
您想要的输出，因此系统 R

1654
01:04:13,680 --> 01:04:17,070
和 IBM 星爆成为后来 这些

1655
01:04:17,070 --> 01:04:19,800
是自下而上方法的例子

1656
01:04:19,800 --> 01:04:21,570
动态方法会看到一个超级

1657
01:04:21,570 --> 01:04:23,580
这也被认为是一种自下而上的

1658
01:04:23,580 --> 01:04:28,950
方法 研究界目前的感觉

1659
01:04:28,950 --> 01:04:31,980
是这种

1660
01:04:31,980 --> 01:04:35,220
方法更适合找出

1661
01:04:35,220 --> 01:04:39,870
联合订购 替代方案是

1662
01:04:39,870 --> 01:04:41,550
自上而下的方法是我们在

1663
01:04:41,550 --> 01:04:43,710
基于 Cascades 的系统中使用的方法，这

1664
01:04:43,710 --> 01:04:44,940
是您从想要的结果开始

1665
01:04:44,940 --> 01:04:48,210
，然后深入

1666
01:04:48,210 --> 01:04:50,430
到 QWERTY 计划中，然后开始添加

1667
01:04:50,430 --> 01:04:52,500
物理操作符以从根本上

1668
01:04:52,500 --> 01:04:54,480
颠倒步骤以获得 back 让你

1669
01:04:54,480 --> 01:04:56,640
从你需要的目标那里回来

1670
01:04:56,640 --> 01:04:59,610
所以火山是迦南 Exodus

1671
01:04:59,610 --> 01:05:02,310
来自相同的数据到 Cascades

1672
01:05:02,310 --> 01:05:03,750
Cascades 被认为是现代的

1673
01:05:03,750 --> 01:05:07,710
含义，所以我们 将介绍这个

1674
01:05:07,710 --> 01:05:09,810
我将进一步介绍这个我想在

1675
01:05:09,810 --> 01:05:13,410
下一堂课我不会说太多但是

1676
01:05:13,410 --> 01:05:15,780
就像续集服务器和蟑螂

1677
01:05:15,780 --> 01:05:18,420
数据库使用的就是我们的系统使用

1678
01:05:18,420 --> 01:05:19,590
的其他系统使用这个所以这

1679
01:05:19,590 --> 01:05:22,260
有点像 再次，对于数据库的联合算法，哈希连接

1680
01:05:22,260 --> 01:05:24,570
与某些重新连接的争论是

1681
01:05:24,570 --> 01:05:26,610


1682
01:05:26,610 --> 01:05:27,630
一样的，如果你关心

1683
01:05:27,630 --> 01:05:29,010
查询优化器，这是同样的

1684
01:05:29,010 --> 01:05:33,240
争论，人们可以接受，所以让我们

1685
01:05:33,240 --> 01:05:34,800
谈谈 Postgres 做了什么，

1686
01:05:34,800 --> 01:05:36,990
所以 Postgres 实际上做的

1687
01:05:36,990 --> 01:05:40,710
是我们的方法所针对的系统，我们的方法

1688
01:05:40,710 --> 01:05:42,450
通常是这样的

1689
01:05:42,450 --> 01:05:44,130


1690
01:05:44,130 --> 01:05:46,080


1691
01:05:46,080 --> 01:05:47,760


1692
01:05:47,760 --> 01:05:51,000


1693
01:05:51,000 --> 01:05:53,400
如果你有 13 个或更多的表，

1694
01:05:53,400 --> 01:05:54,720
你就会得到这个遗传算法，

1695
01:05:54,720 --> 01:05:56,100
我们将再讨论几张幻灯片，但

1696
01:05:56,100 --> 01:05:58,860
它的工作方式是他们有这个

1697
01:05:58,860 --> 01:06:00,750
重写阶段，其中

1698
01:06:00,750 --> 01:06:02,520
包含我们讨论过的所有静态规则 hat 可以对查询计划器进行

1699
01:06:02,520 --> 01:06:04,440
一些初始重写或优化

1700
01:06:04,440 --> 01:06:06,990
，然后他们

1701
01:06:06,990 --> 01:06:10,770


1702
01:06:10,770 --> 01:06:12,360
使用自下而上的方法将其放入基于成本的搜索模型中，

1703
01:06:12,360 --> 01:06:14,580
就像系统要找出

1704
01:06:14,580 --> 01:06:17,070
联合所有者环一样，然后他们

1705
01:06:17,070 --> 01:06:20,160
返回并添加查询计划

1706
01:06:20,160 --> 01:06:21,660
中缺少的其余内容的想法，

1707
01:06:21,660 --> 01:06:24,089
因此这些内容将

1708
01:06:24,089 --> 01:06:26,160
是排序顺序或任何类型的

1709
01:06:26,160 --> 01:06:27,270
聚合，您必须拥有

1710
01:06:27,270 --> 01:06:32,549
正确的，然后您做

1711
01:06:32,549 --> 01:06:34,170
同样的事情，但您只是 递归地

1712
01:06:34,170 --> 01:06:38,960
对任何子查询执行相同的步骤，

1713
01:06:38,960 --> 01:06:41,760
因此 Postgres 非常出色我认为

1714
01:06:41,760 --> 01:06:43,130
邮政编码实际上是我见过的那些

1715
01:06:43,130 --> 01:06:45,539
漂亮的数据库系统源代码

1716
01:06:45,539 --> 01:06:49,440
之一，甚至至少有人

1717
01:06:49,440 --> 01:06:53,579
用 C 编写查询优化器有点

1718
01:06:53,579 --> 01:06:55,470
像我的 意见

1719
01:06:55,470 --> 01:06:57,000
至少几年前它看到的一个教训是

1720
01:06:57,000 --> 01:06:59,579
系统的黑暗角落之一，

1721
01:06:59,579 --> 01:07:04,260
所以它是我被告知这

1722
01:07:04,260 --> 01:07:06,869
非常脆弱，因为你

1723
01:07:06,869 --> 01:07:08,130
在源代码中隐含地有像重写

1724
01:07:08,130 --> 01:07:10,410
ph 像你一样的步骤基本上培根

1725
01:07:10,410 --> 01:07:12,059


1726
01:07:12,059 --> 01:07:13,859
关于该数据的输出需要是什么样子的源代码假设，

1727
01:07:13,859 --> 01:07:15,660
如果根据看起来像这样

1728
01:07:15,660 --> 01:07:18,599
它然后被送入

1729
01:07:18,599 --> 01:07:19,980
下一组你

1730
01:07:19,980 --> 01:07:21,030
知道你实际上是启发式转换

1731
01:07:21,030 --> 01:07:23,250
这样做，如果你改变某种

1732
01:07:23,250 --> 01:07:25,829
假设，你

1733
01:07:25,829 --> 01:07:28,109
对下一阶段期望的查询

1734
01:07:28,109 --> 01:07:29,760
计划看起来像什么，如果你以某种方式在那里

1735
01:07:29,760 --> 01:07:31,500
生成或产生的查询计划

1736
01:07:31,500 --> 01:07:34,140
现在不同，那么这可能会

1737
01:07:34,140 --> 01:07:36,660
破坏其他一切，并且

1738
01:07:36,660 --> 01:07:38,579
这就是为什么我喜欢 Cascades

1739
01:07:38,579 --> 01:07:39,839
或统一方法的原因，我们将在稍后讨论，

1740
01:07:39,839 --> 01:07:41,670
因为您声明所有

1741
01:07:41,670 --> 01:07:43,079
规则，您声明您的转换

1742
01:07:43,079 --> 01:07:44,640
以及您

1743
01:07:44,640 --> 01:07:47,579
希望查询计划维护的物理属性，然后

1744
01:07:47,579 --> 01:07:49,079
您只需将它们扔到引擎中

1745
01:07:49,079 --> 01:07:50,250
让它为您解决问题，因为

1746
01:07:50,250 --> 01:07:51,599
在力中为您准备了所有这些东西，

1747
01:07:51,599 --> 01:07:54,450
而这正是您碰巧

1748
01:07:54,450 --> 01:07:56,010
了解您所知道的

1749
01:07:56,010 --> 01:07:57,599
以修改任何东西的原因 g 你会明白你

1750
01:07:57,599 --> 01:07:58,799
知道所有步骤实际

1751
01:07:58,799 --> 01:08:05,039
发生的事情所以再次优点

1752
01:08:05,039 --> 01:08:06,539
系统的缺点是

1753
01:08:06,539 --> 01:08:09,059
方法所以优点是它

1754
01:08:09,059 --> 01:08:12,660
通常会找到一个合理的计划，至少

1755
01:08:12,660 --> 01:08:16,109
对于中等规模的人来说加入也不

1756
01:08:16,109 --> 01:08:18,899
加入我们的数字表 一个合理

1757
01:08:18,899 --> 01:08:20,729
的超时而不必这样做它

1758
01:08:20,729 --> 01:08:24,238
也是搜索的缺点是您将

1759
01:08:24,238 --> 01:08:25,469
遇到与仅启发式方法相同的所有问题

1760
01:08:25,469 --> 01:08:26,850
，因为

1761
01:08:26,850 --> 01:08:28,198
这是您在

1762
01:08:28,198 --> 01:08:30,198
进入它之前应用的第一步并执行 搜索

1763
01:08:30,198 --> 01:08:32,460
这只是对

1764
01:08:32,460 --> 01:08:33,899
系统的真正限制，因为它们是有限的

1765
01:08:33,899 --> 01:08:36,960
- 留下深树现代系统我

1766
01:08:36,960 --> 01:08:39,870
认为没有这个问题，然后在

1767
01:08:39,870 --> 01:08:41,460
我之前展示的示例中，您

1768
01:08:41,460 --> 01:08:44,040
需要让成本模型知道

1769
01:08:44,040 --> 01:08:46,589
您的 数据需要看起来像如果您对数据进行

1770
01:08:46,589 --> 01:08:49,198
排序或压缩和其他

1771
01:08:49,198 --> 01:08:51,149
属性，您必须将其

1772
01:08:51,149 --> 01:08:52,469
烘焙到成本模型中，因为

1773
01:08:52,469 --> 01:08:54,770
我自己去的搜索无法强制执行，

1774
01:08:54,770 --> 01:08:59,130
所以最后一个 这是最糟糕的部分 这

1775
01:08:59,130 --> 01:09:00,929
是这是这是

1776
01:09:00,929 --> 01:09:02,219
您明天将要使用的

1777
01:09:02,219 --> 01:09:05,370
系统的主要限制我们使用成本

1778
01:09:05,370 --> 01:09:06,630
模型来强制执行物理属性的方法

1779
01:09:06,630 --> 01:09:08,370
我再次认为我认为这

1780
01:09:08,370 --> 01:09:09,870
使它从工程的角度来看

1781
01:09:09,870 --> 01:09:14,698
这是有问题的 所以在我们

1782
01:09:14,698 --> 01:09:19,948
进入现代查询

1783
01:09:19,948 --> 01:09:21,839
优化器实现之前，我想

1784
01:09:21,839 --> 01:09:25,080
谈谈使用随机算法的另一个类优化器，

1785
01:09:25,080 --> 01:09:27,120
这是

1786
01:09:27,120 --> 01:09:28,920


1787
01:09:28,920 --> 01:09:30,359
思考我们试图在

1788
01:09:30,359 --> 01:09:32,609
采石场优化器中解决的问题的另一种方式，所以这个想法

1789
01:09:32,609 --> 01:09:34,679
随机混合的一个特点是，与其

1790
01:09:34,679 --> 01:09:37,620
进行这种

1791
01:09:37,620 --> 01:09:40,109
平衡搜索的分支寻找

1792
01:09:40,109 --> 01:09:42,750
更好的查询计划，不如采用

1793
01:09:42,750 --> 01:09:47,339
我们的查询计划并对其进行随机

1794
01:09:47,339 --> 01:09:49,770
排列，然后

1795
01:09:49,770 --> 01:09:53,219
对所有可能的有效查询进行随机游走 计划

1796
01:09:53,219 --> 01:09:54,810
，然后如果我们只是没有

1797
01:09:54,810 --> 01:09:56,190
一个实际上更好的 StumbleUpon，

1798
01:09:56,190 --> 01:09:58,610
那么这就是我们最终会正确使用的那个

1799
01:09:58,610 --> 01:10:01,320
，所以对于这个，这就是

1800
01:10:01,320 --> 01:10:03,000
你真正需要的地方 编辑那个阈值它

1801
01:10:03,000 --> 01:10:04,800
就像今天的时间阈值 它会说

1802
01:10:04,800 --> 01:10:06,750
我已经搜索了足够长的时间 我知道我知道什么

1803
01:10:06,750 --> 01:10:08,340
时候停止 因为否则这个

1804
01:10:08,340 --> 01:10:10,710
东西将永远运行 所以这个

1805
01:10:10,710 --> 01:10:12,330
例子将是 Postgres 到

1806
01:10:12,330 --> 01:10:14,250
遗传算法实际上是

1807
01:10:14,250 --> 01:10:16,080
今天的真实系统我们将

1808
01:10:16,080 --> 01:10:17,730
讨论下一次直播，但在此之前

1809
01:10:17,730 --> 01:10:19,890
有一个使用模拟退火的实现，

1810
01:10:19,890 --> 01:10:22,230
所以这可以

1811
01:10:22,230 --> 01:10:24,600
追溯到 1987 年，据我所知，

1812
01:10:24,600 --> 01:10:26,040
这个 F 从未真正将其变成

1813
01:10:26,040 --> 01:10:29,790
真正的系统 基本思想是您

1814
01:10:29,790 --> 01:10:30,810
在查询计划中显示您

1815
01:10:30,810 --> 01:10:33,540
使用 -

1816
01:10:33,540 --> 01:10:34,560
我们在开始时谈到的基于启发式的方法

1817
01:10:34,560 --> 01:10:37,199
，然后现在您只需

1818
01:10:37,199 --> 01:10:39,210
对查询计划中的运算符进行随机排列，

1819
01:10:39,210 --> 01:10:41,730
例如交换联合或

1820
01:10:41,730 --> 01:10:44,580
两个表，然后您 估计

1821
01:10:44,580 --> 01:10:46,610


1822
01:10:46,610 --> 01:10:49,670
更改新查询计划的成本，

1823
01:10:49,670 --> 01:10:51,949
如果它比接受更改要好，

1824
01:10:51,949 --> 01:10:54,650
如果更糟，那么你抛一枚

1825
01:10:54,650 --> 01:10:56,239
加权硬币来决定

1826
01:10:56,239 --> 01:10:59,630
是否要保留它，然后是想法

1827
01:10:59,630 --> 01:11:01,280
每隔一段时间，你就会起床，

1828
01:11:01,280 --> 01:11:04,840
你会通过接受改变而得到一个

1829
01:11:04,840 --> 01:11:06,710
实际上让事情变得更糟的新计划，

1830
01:11:06,710 --> 01:11:08,270


1831
01:11:08,270 --> 01:11:10,400
这让你有可能

1832
01:11:10,400 --> 01:11:12,320
突破局部最小值，然后发现

1833
01:11:12,320 --> 01:11:15,619
你知道的真相 最佳

1834
01:11:15,619 --> 01:11:17,719
所以棘手的事情

1835
01:11:17,719 --> 01:11:21,710
是你必须编写规则来

1836
01:11:21,710 --> 01:11:24,710
确保你强制执行

1837
01:11:24,710 --> 01:11:27,800
查询计划的任何正确性，这样你就不会

1838
01:11:27,800 --> 01:11:30,560
最终产生你知道不正确的

1839
01:11:30,560 --> 01:11:35,210
结果，比如如果我的数据需要 被

1840
01:11:35,210 --> 01:11:38,659
排序，我随机排列查询

1841
01:11:38,659 --> 01:11:41,119
计划，通过

1842
01:11:41,119 --> 01:11:44,810
在哈希连接之前按操作符排序，然后

1843
01:11:44,810 --> 01:11:46,639
现在我的输出不会被排序

1844
01:11:46,639 --> 01:11:48,260
我最终会得到不正确的结果，所以

1845
01:11:48,260 --> 01:11:49,820
你必须编写所有这些规则

1846
01:11:49,820 --> 01:11:51,920
来制作 确保这种情况正确发生，

1847
01:11:51,920 --> 01:11:54,320
这可能很棘手，因为有很多

1848
01:11:54,320 --> 01:11:59,270
极端情况

1849
01:11:59,270 --> 01:12:00,619
，实际在生产中使用的随机算法的一个例子

1850
01:12:00,619 --> 01:12:02,210
是 Postgres 遗传

1851
01:12:02,210 --> 01:12:04,550
优化器，所以同样的工作方式是

1852
01:12:04,550 --> 01:12:07,010
，如果您使用 s 系统

1853
01:12:07,010 --> 01:12:09,170
我们之前讨论过的方法 如果您的查询有

1854
01:12:09,170 --> 01:12:11,780
12 个表 如果您尝试加入 13 个或更多，

1855
01:12:11,780 --> 01:12:14,210
那么您会得到这个 您可以

1856
01:12:14,210 --> 01:12:15,560
打开和关闭它 有一个脱粒机 假设

1857
01:12:15,560 --> 01:12:16,699
实际启动时，但

1858
01:12:16,699 --> 01:12:18,170
默认情况下我认为是我 认为这是 13 个

1859
01:12:18,170 --> 01:12:20,960
表，所以他们将使用遗传

1860
01:12:20,960 --> 01:12:23,179
算法，在每一轮开始时，

1861
01:12:23,179 --> 01:12:24,679
他们将生成

1862
01:12:24,679 --> 01:12:27,100
一系列不同的排列或

1863
01:12:27,100 --> 01:12:31,010
查询计划的随机变化，然后

1864
01:12:31,010 --> 01:12:32,570
他们将烹饪生成

1865
01:12:32,570 --> 01:12:35,480
所有这些的成本 排列，然后

1866
01:12:35,480 --> 01:12:37,400
他们会选择一些

1867
01:12:37,400 --> 01:12:39,560
成本最低的一些作为

1868
01:12:39,560 --> 01:12:42,889
从你知道的脚传播到

1869
01:12:42,889 --> 01:12:45,199
下一代的那些，然后你有一些

1870
01:12:45,199 --> 01:12:46,820
mutator 函数来翻转或

1871
01:12:46,820 --> 01:12:49,760
随机排列最好的计划，比如

1872
01:12:49,760 --> 01:12:50,960
这个想法 就像你

1873
01:12:50,960 --> 01:12:53,239
从最好的计划中获取基因，并希望

1874
01:12:53,239 --> 01:12:55,130
产生能够产生

1875
01:12:55,130 --> 01:12:57,739
更好计划的后代 所以视觉上看起来像

1876
01:12:57,739 --> 01:13:00,199
这样 所以假设我们在我们的第一个

1877
01:13:00,199 --> 01:13:02,869
raishin 中作为一个符号说三张桌子

1878
01:13:02,869 --> 01:13:05,869
加入我们可以估计 EQ DS 的成本，

1879
01:13:05,869 --> 01:13:08,300
并说这个最终

1880
01:13:08,300 --> 01:13:10,729
成本最低，所以我们在这里更新我们的最低成本

1881
01:13:10,729 --> 01:13:13,639
标志，然后我们将

1882
01:13:13,639 --> 01:13:16,699
随机排列这个方面，我们将

1883
01:13:16,699 --> 01:13:17,959
其提供给这个方面，然后我们将其杀死

1884
01:13:17,959 --> 01:13:20,090
这个和现在同样的事情我们

1885
01:13:20,090 --> 01:13:21,349
估计成本找到

1886
01:13:21,349 --> 01:13:23,239
成本最低的一个在这种

1887
01:13:23,239 --> 01:13:24,650
情况下这个比这个低所以

1888
01:13:24,650 --> 01:13:25,849
这是我们见过的最好的新的

1889
01:13:25,849 --> 01:13:28,099
选择这些让这两个人保持

1890
01:13:28,099 --> 01:13:29,869
翻转 一些东西并生成一个新的

1891
01:13:29,869 --> 01:13:30,800
子句，我们

1892
01:13:30,800 --> 01:13:33,499
只是一遍又一遍地继续，直到我们找到，

1893
01:13:33,499 --> 01:13:36,999
直到我们用完和用完时间，

1894
01:13:37,719 --> 01:13:40,909
所以这个井跳跃和随机位置的优势是什么

1895
01:13:40,909 --> 01:13:42,440


1896
01:13:42,440 --> 01:13:43,880
让我们得到我们的本地 最低限度，并且

1897
01:13:43,880 --> 01:13:48,559
可能我们可以

1898
01:13:48,559 --> 01:13:50,179
根据我的知识找到更好的计划 我还没有看到任何

1899
01:13:50,179 --> 01:13:53,539
关于

1900
01:13:53,539 --> 01:13:55,760
Postgres 遗传优化器

1901
01:13:55,760 --> 01:13:58,159
实际上与您相比有多好的详细分析或实验，您知道

1902
01:13:58,159 --> 01:14:00,309
让常规优化器运行更长时间

1903
01:14:00,309 --> 01:14:02,869
我们也 进行搜索的内存开销很低，

1904
01:14:02,869 --> 01:14:05,300
因为如果我们

1905
01:14:05,300 --> 01:14:07,610
不需要将一代的历史保存

1906
01:14:07,610 --> 01:14:09,499
到我们随机游走的下一个源，

1907
01:14:09,499 --> 01:14:13,309
那么你

1908
01:14:13,309 --> 01:14:14,840
知道内存占用就是我们

1909
01:14:14,840 --> 01:14:15,800
使用的任何东西，你知道我们知道什么' 重新

1910
01:14:15,800 --> 01:14:19,070
使用该回合的舞蹈

1911
01:14:19,070 --> 01:14:21,380
优势是，除非我们

1912
01:14:21,380 --> 01:14:23,539
做额外的工作以确保

1913
01:14:23,539 --> 01:14:26,959
随机性是确定性的，否则我们最终可能会

1914
01:14:26,959 --> 01:14:29,869
得到一个难以调试的系统，

1915
01:14:29,869 --> 01:14:33,920
以确定为什么

1916
01:14:33,920 --> 01:14:36,559
你知道为什么戴维森是 为什么在 Postgres 的

1917
01:14:36,559 --> 01:14:38,150
情况下，某些平方的数据决定

1918
01:14:38,150 --> 01:14:40,369
使用一个计划而不是另一个计划

1919
01:14:40,369 --> 01:14:42,679
，他们总是

1920
01:14:42,679 --> 01:14:46,459
确保随机种子对于给定的查询是一致的，

1921
01:14:46,459 --> 01:14:47,959
所以如果我

1922
01:14:47,959 --> 01:14:49,429
今天通过遗传优化器运行查询并且

1923
01:14:49,429 --> 01:14:51,590
我运行 明天同样的查询

1924
01:14:51,590 --> 01:14:55,070
我将始终生成相同的计划，我们

1925
01:14:55,070 --> 01:14:56,570
仍然必须保持任何

1926
01:14:56,570 --> 01:14:58,249
正确性规则，以确保我们

1927
01:14:58,249 --> 01:15:01,309
不会做任何最终

1928
01:15:01,309 --> 01:15:04,849
导致无效查询的突变，所以我们

1929
01:15:04,849 --> 01:15:07,400
在这里有点长，但这是好东西，我喜欢

1930
01:15:07,400 --> 01:15:12,590
它，所以我们可以做的一个观察是

1931
01:15:12,590 --> 01:15:13,949
，到目前为止我们讨论的所有内容

1932
01:15:13,949 --> 01:15:18,330
都是你知道的，你可以想象

1933
01:15:18,330 --> 01:15:20,160
用像 C 这样的过程语言编写所有这些转换规则

1934
01:15:20,160 --> 01:15:23,280
和这些算法

1935
01:15:23,280 --> 01:15:27,540
或 C++，这

1936
01:15:27,540 --> 01:15:30,449
很难做到，因为没有办法

1937
01:15:30,449 --> 01:15:35,429
精确地或通过正式的

1938
01:15:35,429 --> 01:15:39,210
方法来验证所应用的转换

1939
01:15:39,210 --> 01:15:42,449
是正确的，

1940
01:15:42,449 --> 01:15:44,460
我们保证当我们

1941
01:15:44,460 --> 01:15:46,020
从一个查询计划转换到下一个查询计划时

1942
01:15:46,020 --> 01:15:49,980
，你知道 这两个

1943
01:15:49,980 --> 01:15:51,510
代数表达式实际上是

1944
01:15:51,510 --> 01:15:55,320
等价的，因此我们可以尝试

1945
01:15:55,320 --> 01:15:57,600
通过使用随机查询运行大量模糊测试来验证这一点，

1946
01:15:57,600 --> 01:15:58,949
并仅

1947
01:15:58,949 --> 01:16:00,179
检查输出是否正确，

1948
01:16:00,179 --> 01:16:02,310
但这当然就像

1949
01:16:02,310 --> 01:16:04,199
尝试证明否定

1950
01:16:04,199 --> 01:16:07,980
这样做并不容易，实际上让我让它

1951
01:16:07,980 --> 01:16:10,710
点亮一秒钟的眼泪，

1952
01:16:10,710 --> 01:16:13,170
所以

1953
01:16:13,170 --> 01:16:18,000
如果我们能有一种方法来声明

1954
01:16:18,000 --> 01:16:21,630
我们的转换规则是什么，那么更好地推动这样做

1955
01:16:21,630 --> 01:16:24,200
就像高级语言或 DSL 一样，

1956
01:16:24,200 --> 01:16:27,540
然后我们可以将其输入

1957
01:16:27,540 --> 01:16:29,880
到优化器引擎中，然后优化器引擎可以

1958
01:16:29,880 --> 01:16:32,040
生成代码或为我们应用这些规则

1959
01:16:32,040 --> 01:16:35,880
，这样现在通过这些

1960
01:16:35,880 --> 01:16:37,739
声明的是声明性规则规则

1961
01:16:37,739 --> 01:16:41,489
集，然后我们就可以

1962
01:16:41,489 --> 01:16:42,810
对这些规则进行验证或分析以

1963
01:16:42,810 --> 01:16:44,880
确定它们是正确的，只要

1964
01:16:44,880 --> 01:16:46,770
我们知道我们有理由确信我们的

1965
01:16:46,770 --> 01:16:48,600
规则引擎是正确的来执行它们，

1966
01:16:48,600 --> 01:16:50,130
我们就会知道我们总是在做

1967
01:16:50,130 --> 01:16:51,660
这样的转换

1968
01:16:51,660 --> 01:16:58,230
这是有效的所以这是

1969
01:16:58,230 --> 01:17:00,780


1970
01:17:00,780 --> 01:17:03,120
1990 年代末 1990 年代末开发所谓的

1971
01:17:03,120 --> 01:17:05,640
优化器生成器的运动，并将

1972
01:17:05,640 --> 01:17:08,040
它们视为一个框架，允许

1973
01:17:08,040 --> 01:17:10,710
数据系统开发人员声明

1974
01:17:10,710 --> 01:17:12,870
规则抛出转换查询以

1975
01:17:12,870 --> 01:17:16,860
生成最佳 计划然后这

1976
01:17:16,860 --> 01:17:18,660
一切都将与

1977
01:17:18,660 --> 01:17:19,980
我们之前讨论过的搜索策略分开，

1978
01:17:19,980 --> 01:17:22,560
这些就像你知道做

1979
01:17:22,560 --> 01:17:23,880
谓词下推你声明一个规则

1980
01:17:23,880 --> 01:17:25,380
来这样做 无论我们是

1981
01:17:25,380 --> 01:17:28,230
在进行启发式算法还是类似我们搜索的系统，

1982
01:17:28,230 --> 01:17:30,480
我们都可以保证

1983
01:17:30,480 --> 01:17:33,150
我们会

1984
01:17:33,150 --> 01:17:37,040
正确地生成该转换，因此

1985
01:17:37,040 --> 01:17:42,570
这种类型的优化器的第一个示例

1986
01:17:42,570 --> 01:17:45,469
是在星爆系统中，

1987
01:17:45,469 --> 01:17:47,880
Exodus 是另一个第一个 一个著名的，

1988
01:17:47,880 --> 01:17:50,370
这就是 IBM，这是一个

1989
01:17:50,370 --> 01:17:52,580
学术系统，然后有

1990
01:17:52,580 --> 01:17:56,040
一些变化改进

1991
01:17:56,040 --> 01:17:58,380
了火山的出埃及记

1992
01:17:58,380 --> 01:18:01,020
和 plaus 在威斯康星州哥伦比亚是

1993
01:18:01,020 --> 01:18:03,360
另一个在 1990 年代后期在波特兰的查询优化器中的改进，

1994
01:18:03,360 --> 01:18:05,820
从那时起

1995
01:18:05,820 --> 01:18:07,530


1996
01:18:07,530 --> 01:18:10,469
对这种优化

1997
01:18:10,469 --> 01:18:14,310
器生成器确实没有太多研究，今天人们主要

1998
01:18:14,310 --> 01:18:16,080
使用的是基于

1999
01:18:16,080 --> 01:18:20,010
1990 年代完成的这项工作，所以我们

2000
01:18:20,010 --> 01:18:23,300
将更详细地了解

2001
01:18:23,300 --> 01:18:24,949
项链中的草莓艾滋病，但我会

2002
01:18:24,949 --> 01:18:30,559
现在只是为他们简单地谈谈它，所以这些

2003
01:18:30,559 --> 01:18:32,989
优化器生成器再次拥有这个

2004
01:18:32,989 --> 01:18:34,760
羊毛引擎，允许您应用

2005
01:18:34,760 --> 01:18:37,249
这些转换，然后您可以

2006
01:18:37,249 --> 01:18:39,619
声明 在规则中，

2007
01:18:39,619 --> 01:18:41,749
您希望操作员

2008
01:18:41,749 --> 01:18:43,219
对更好处理的数据强制执行哪些物理属性，

2009
01:18:43,219 --> 01:18:45,019
例如我之前展示的排序顺序示例

2010
01:18:45,019 --> 01:18:47,959
，但现在的

2011
01:18:47,959 --> 01:18:49,610
问题是我们实际上将

2012
01:18:49,610 --> 01:18:52,519
如何应用这些转换

2013
01:18:52,519 --> 01:18:55,269
并执行 寻找最佳计划，

2014
01:18:55,269 --> 01:18:57,709
所以这两种方法

2015
01:18:57,709 --> 01:18:59,809
是统一搜索的分层搜索，所以

2016
01:18:59,809 --> 01:19:01,639
分层搜索本质上就是我

2017
01:19:01,639 --> 01:19:03,349
所说的 IBM，我们的

2018
01:19:03,349 --> 01:19:05,300
方法是在那里我可以应用我的

2019
01:19:05,300 --> 01:19:07,010
转换和使用启发式算法，

2020
01:19:07,010 --> 01:19:09,860
而不是首先使用成本模型 我

2021
01:19:09,860 --> 01:19:12,380
拿出那个查询计划并

2022
01:19:12,380 --> 01:19:13,579
通过搜索模型运行它，然后

2023
01:19:13,579 --> 01:19:16,090
可以找到我最好的绘图排序

2024
01:19:16,090 --> 01:19:18,679
统一搜索，我们同时进行

2025
01:19:18,679 --> 01:19:20,479
查询计划计划的所有方面，

2026
01:19:20,479 --> 01:19:22,010
以便进行

2027
01:19:22,010 --> 01:19:23,300
谓词下推和 所有

2028
01:19:23,300 --> 01:19:26,150
这些静态规则，如果你愿意的话，它们

2029
01:19:26,150 --> 01:19:29,269
是在同一个搜索空间中同时完成的，

2030
01:19:29,269 --> 01:19:32,269
因为你确实找出了最好的

2031
01:19:32,269 --> 01:19:35,749
关节气味，所以让我们从 th 开始 第

2032
01:19:35,749 --> 01:19:38,119
一个所以再次分层搜索是我们

2033
01:19:38,119 --> 01:19:41,539
首先使用所有转换规则重写逻辑计划

2034
01:19:41,539 --> 01:19:42,889
所以你从

2035
01:19:42,889 --> 01:19:44,809
一个逻辑计划再次进入一个逻辑计划

2036
01:19:44,809 --> 01:19:46,550
这与他们在here's to base方法中做的事情是一样的

2037
01:19:46,550 --> 01:19:48,920
，所以

2038
01:19:48,920 --> 01:19:50,300
这个规则 引擎会检查

2039
01:19:50,300 --> 01:19:52,519
你想要做的转换是否

2040
01:19:52,519 --> 01:19:54,590
在它实际应用之前被允许，

2041
01:19:54,590 --> 01:19:56,119
这确保你

2042
01:19:56,119 --> 01:19:58,369
最终不会得到一个无效的查询计划

2043
01:19:58,369 --> 01:20:00,709
，因此没有成本模型，

2044
01:20:00,709 --> 01:20:02,840
这些都是同样的事情 我们

2045
01:20:02,840 --> 01:20:03,889
讨论了为了让我一直

2046
01:20:03,889 --> 01:20:05,239
想要谓词下推或限制

2047
01:20:05,239 --> 01:20:06,889
下推我可以编写一个规则来进行这种

2048
01:20:06,889 --> 01:20:09,139
转换，然后一旦完成了

2049
01:20:09,139 --> 01:20:11,209
这一步，现在您就

2050
01:20:11,209 --> 01:20:13,789
可以进行基于成本的搜索以从

2051
01:20:13,789 --> 01:20:15,920
逻辑计划中找到映射 到物理计划，如果这

2052
01:20:15,920 --> 01:20:17,539
可能是联合排序，或者可能

2053
01:20:17,539 --> 01:20:20,630
是您知道要弄清楚您

2054
01:20:20,630 --> 01:20:22,249
想要的是嵌套循环连接还是某个

2055
01:20:22,249 --> 01:20:23,719
重新连接或散列一个找出

2056
01:20:23,719 --> 01:20:27,130
最有名的算法 这些

2057
01:20:27,130 --> 01:20:29,749
优化的生成器中的一个带有

2058
01:20:29,749 --> 01:20:33,320
由 Guy lumen 领导的 IBM 的星爆，让我们再来

2059
01:20:33,320 --> 01:20:34,939
一遍，这只是重复我

2060
01:20:34,939 --> 01:20:37,100
在您进行查询重写阶段之前所说的内容，该阶段

2061
01:20:37,100 --> 01:20:40,340
可以

2062
01:20:40,340 --> 01:20:43,010
根据这些块计算转换

2063
01:20:43,010 --> 01:20:45,170
并且没有 成本模型，

2064
01:20:45,170 --> 01:20:46,940
然后您进行系统自动样式搜索

2065
01:20:46,940 --> 01:20:50,840
以找到您知道联合订单之类的

2066
01:20:50,840 --> 01:20:53,480
事情，据您所知

2067
01:20:53,480 --> 01:20:55,880
，IBM db2 的最新版本就像

2068
01:20:55,880 --> 01:20:57,800
他们的企业关系数据库

2069
01:20:57,800 --> 01:21:04,070
系统正在使用这种方法我不

2070
01:21:04,070 --> 01:21:05,690
知道 我的意思是starburst

2071
01:21:05,690 --> 01:21:09,560
是一个你知道star bus 是

2072
01:21:09,560 --> 01:21:11,090
IBM 开发的系统所以我的意思是它

2073
01:21:11,090 --> 01:21:12,920
显然是有道理的并且进入db2 我

2074
01:21:12,920 --> 01:21:14,510
不知道任何其他戴维斯

2075
01:21:14,510 --> 01:21:18,530
系统遵循这种类似的方法所以有

2076
01:21:18,530 --> 01:21:20,330
什么优点 那么在

2077
01:21:20,330 --> 01:21:21,740
实践中它运作良好会认为它的

2078
01:21:21,740 --> 01:21:27,530
性能更快，但缺点

2079
01:21:27,530 --> 01:21:32,030
是您无法再次明确

2080
01:21:32,030 --> 01:21:34,160
定义您的转换优先级

2081
01:21:34,160 --> 01:21:35,870
这

2082
01:21:35,870 --> 01:21:36,920
将更有意义 当我们谈论

2083
01:21:36,920 --> 01:21:39,200
级联时，但基本上就像如果我知道我

2084
01:21:39,200 --> 01:21:40,820
不能彻底搜索和所有东西

2085
01:21:40,820 --> 01:21:42,530
所以也许我

2086
01:21:42,530 --> 01:21:44,090
想先看看一些转换因为我是的我

2087
01:21:44,090 --> 01:21:45,740
想我会从它们中获得更好的好处

2088
01:21:45,740 --> 01:21:49,670
然后哦，然后这有帮助 然后我可能

2089
01:21:49,670 --> 01:21:52,880
会降低我

2090
01:21:52,880 --> 01:21:55,070
查询的上限，然后我知道我可以

2091
01:21:55,070 --> 01:21:56,960
删掉那些可能不是我的意思

2092
01:21:56,960 --> 01:21:58,940
不太有用的东西，所以我不先应用这些

2093
01:21:58,940 --> 01:22:01,130
转换，所以在

2094
01:22:01,130 --> 01:22:02,330
原始版本中 星爆你

2095
01:22:02,330 --> 01:22:05,870
不能这样做

2096
01:22:05,870 --> 01:22:07,040
他们在论文中谈到的另一个方面是

2097
01:22:07,040 --> 01:22:09,350
一个很大的痛苦是因为这些

2098
01:22:09,350 --> 01:22:10,400
转换规则基于

2099
01:22:10,400 --> 01:22:13,850
关系演算它变得

2100
01:22:13,850 --> 01:22:15,710
难以维护并且很难找到程序员来

2101
01:22:15,710 --> 01:22:18,590
编写因为编写关系

2102
01:22:18,590 --> 01:22:23,450
演算代码是排序的 不是 嗯

2103
01:22:23,450 --> 01:22:25,100
对作家助理

2104
01:22:25,100 --> 01:22:26,990
程序员来说又不自然了 我不知道是否

2105
01:22:26,990 --> 01:22:31,250
在 1990 年的郊区论文中 88 我

2106
01:22:31,250 --> 01:22:33,350
不知道从那以后它是否被

2107
01:22:33,350 --> 01:22:35,260
纠正

2108
01:22:35,260 --> 01:22:38,060
得这么快统一 d 搜索是

2109
01:22:38,060 --> 01:22:39,440
您将

2110
01:22:39,440 --> 01:22:40,970
逻辑逻辑和逻辑物理

2111
01:22:40,970 --> 01:22:44,390
转换的概念一起完成的地方，因此

2112
01:22:44,390 --> 01:22:45,320
您没有这些单独的阶段，

2113
01:22:45,320 --> 01:22:46,280
因为一切都只是一个

2114
01:22:46,280 --> 01:22:47,810
转换，您将其放入

2115
01:22:47,810 --> 01:22:49,640
规则引擎中，它进行搜索并

2116
01:22:49,640 --> 01:22:50,699
应用这些东西

2117
01:22:50,699 --> 01:22:54,030
对你来说，最大的缺点是

2118
01:22:54,030 --> 01:22:55,110
你必须处理

2119
01:22:55,110 --> 01:22:57,239
统一搜索的主要棘手问题是我有

2120
01:22:57,239 --> 01:23:00,269
太多的转换，你必须

2121
01:23:00,269 --> 01:23:02,969
使用记忆表来

2122
01:23:02,969 --> 01:23:04,860
确保你缓存这些

2123
01:23:04,860 --> 01:23:06,539
转换中的一些，这样你就不会

2124
01:23:06,539 --> 01:23:08,010
回复 你知道

2125
01:23:08,010 --> 01:23:10,440
一遍又一遍地应用相同的更改，所以现在这

2126
01:23:10,440 --> 01:23:12,209
使得这里的内存占用量

2127
01:23:12,209 --> 01:23:13,979
更大一点，因为我必须

2128
01:23:13,979 --> 01:23:15,360
维护一些

2129
01:23:15,360 --> 01:23:17,010
过去应用的转换历史，以

2130
01:23:17,010 --> 01:23:18,209
了解我是否想在未来应用一个新

2131
01:23:18,209 --> 01:23:23,280
的 所以 Gertz 图 II 就是

2132
01:23:23,280 --> 01:23:26,999
那个做火山的人，

2133
01:23:26,999 --> 01:23:28,769
你知道的火山迭代器模型我们

2134
01:23:28,769 --> 01:23:29,909
讨论过的查询处理

2135
01:23:29,909 --> 01:23:31,889
模型有一个火山 o  ptimizer

2136
01:23:31,889 --> 01:23:33,719
是同一个项目的一部分，他是

2137
01:23:33,719 --> 01:23:35,639
同一个人，他做了

2138
01:23:35,639 --> 01:23:38,099
我们讨论过的一些工作，你知道闩锁

2139
01:23:38,099 --> 01:23:42,420
和锁定以及 B 加树，所以当他

2140
01:23:42,420 --> 01:23:44,489
还是一名学者时，他构建了一系列

2141
01:23:44,489 --> 01:23:48,590
这些新系统，每个系统都有一个

2142
01:23:48,590 --> 01:23:53,280
优化器 优化器生成器 所以

2143
01:23:53,280 --> 01:23:55,559
这里的第二个是一座火山，

2144
01:23:55,559 --> 01:23:57,719
这又是一个通用的

2145
01:23:57,719 --> 01:24:00,059
基于成本的优化器，将这些

2146
01:24:00,059 --> 01:24:01,760
等价规则融入其中以用于

2147
01:24:01,760 --> 01:24:04,229
关系代数 它使得

2148
01:24:04,229 --> 01:24:07,889
添加新规则变得非常容易 它处理第一个

2149
01:24:07,889 --> 01:24:10,199
物理属性 数据，

2150
01:24:10,199 --> 01:24:12,389
更好地作为

2151
01:24:12,389 --> 01:24:15,059
系统本身中的一流实体或组件，这样您

2152
01:24:15,059 --> 01:24:16,769
就可以了解

2153
01:24:16,769 --> 01:24:18,090
您正在进行的转换是否

2154
01:24:18,090 --> 01:24:20,550
有效，

2155
01:24:20,550 --> 01:24:21,809
而不是在事后试图清理事情

2156
01:24:21,809 --> 01:24:24,690
所以这是

2157
01:24:24,690 --> 01:24:26,190
一个自上而下的方法的例子，这与

2158
01:24:26,190 --> 01:24:28,590
Cascades 将

2159
01:24:28,590 --> 01:24:31,469
在下一堂课中使用双重谈话是

2160
01:24:31,469 --> 01:24:33,179
一样的，但这有点像这就像一个早期的原型，

2161
01:24:33,179 --> 01:24:36,900
这是 ap 两个 Cascades 的继承者

2162
01:24:36,900 --> 01:24:44,190
，据他们所知火山我的

2163
01:24:44,190 --> 01:24:45,959
意思是火山本身正在使用

2164
01:24:45,959 --> 01:24:48,449
优化器

2165
01:24:48,449 --> 01:24:50,459
，当时我们正在使用其他学术原型，但据

2166
01:24:50,459 --> 01:24:53,269
我所知，这种方法没有用于

2167
01:24:53,269 --> 01:24:58,530
任何专业 系统所以让我们

2168
01:24:58,530 --> 01:24:59,449
看一个例子，

2169
01:24:59,449 --> 01:25:02,219
该死的不要重新启动，

2170
01:25:02,219 --> 01:25:04,590
所以我们要做的第一件事是

2171
01:25:04,590 --> 01:25:05,699
从我们希望查询的逻辑计划开始，

2172
01:25:05,699 --> 01:25:07,440
这就是我们

2173
01:25:07,440 --> 01:25:08,880
希望我们的输出是我们想要做的

2174
01:25:08,880 --> 01:25:10,770
三向连接放置这些表，

2175
01:25:10,770 --> 01:25:12,330
我们希望它按艺术家

2176
01:25:12,330 --> 01:25:14,940
ID 排序 所以这与

2177
01:25:14,940 --> 01:25:16,260
我们在系统

2178
01:25:16,260 --> 01:25:18,150


2179
01:25:18,150 --> 01:25:20,310
中看到的相反 我们在这里

2180
01:25:20,310 --> 01:25:22,140
所以我们这是我们开始的地方我们

2181
01:25:22,140 --> 01:25:23,460
想要然后想要下去并

2182
01:25:23,460 --> 01:25:25,380
应用转换规则使

2183
01:25:25,380 --> 01:25:28,560
我们正确，这样我们就可以调用规则，

2184
01:25:28,560 --> 01:25:31,020
当我们继续进行逻辑

2185
01:25:31,020 --> 01:25:33,660
逻辑转换时，例如检查

2186
01:25:33,660 --> 01:25:35,550
您是否加入 在 a 和 B 上反转，你

2187
01:25:35,550 --> 01:25:37,860
会 加入他们 BN a 或者我们给你一个

2188
01:25:37,860 --> 01:25:39,510
逻辑物理，你知道在 a

2189
01:25:39,510 --> 01:25:42,449
和 B 上加入，现在将它作为

2190
01:25:42,449 --> 01:25:46,880
a 和 B 上的散列连接执行，然后我们

2191
01:25:46,880 --> 01:25:49,140
在这里添加这些节点以应用它应用

2192
01:25:49,140 --> 01:25:51,449
这些转换，然后我们 用于

2193
01:25:51,449 --> 01:25:52,650
连接它们并说明我们如何实际

2194
01:25:52,650 --> 01:25:54,660
到达那里，我们可以继续

2195
01:25:54,660 --> 01:25:57,300
这样做，您继续这样做，

2196
01:25:57,300 --> 01:25:59,460
直到我们到达底部，在这种

2197
01:25:59,460 --> 01:26:01,469
情况下，我们可以在这里计算

2198
01:26:01,469 --> 01:26:04,590
查询计划的成本 并且我们

2199
01:26:04,590 --> 01:26:07,100
将检查保持为最低成本，

2200
01:26:07,100 --> 01:26:09,060
所以现在我们只是继续查看所有

2201
01:26:09,060 --> 01:26:11,610
可能的其他排列等等，

2202
01:26:11,610 --> 01:26:15,330
直到我们在这里发现在这种情况下，如果我们

2203
01:26:15,330 --> 01:26:17,430
尝试进行散列连接，我们知道

2204
01:26:17,430 --> 01:26:19,199
进行散列连接会 违反了我们的

2205
01:26:19,199 --> 01:26:20,880
物理顺序，所以我们

2206
01:26:20,880 --> 01:26:22,680
知道我们不能这样做，所以我们可以

2207
01:26:22,680 --> 01:26:26,130
像快速排序一样引入你

2208
01:26:26,130 --> 01:26:28,080
知道的排序方式，然后现在我们可以

2209
01:26:28,080 --> 01:26:29,820
在这种情况下进行哈希连接等等，在

2210
01:26:29,820 --> 01:26:31,590
这里说做 快速排序

2211
01:26:31,590 --> 01:26:33,540
加上散列连接比新

2212
01:26:33,540 --> 01:26:35,460
的 sor 更昂贵 t merge join 后跟

2213
01:26:35,460 --> 01:26:37,199
单独的 hash 插入 merge join 所以我们

2214
01:26:37,199 --> 01:26:38,489
在那里切断它所以你正在做分支

2215
01:26:38,489 --> 01:26:40,290
并且必须在我

2216
01:26:40,290 --> 01:26:42,989
遍历树上的分支时识别它，如果我

2217
01:26:42,989 --> 01:26:45,800
在我的查询计划的某个点

2218
01:26:45,800 --> 01:26:48,090
已经比我之前见过的最好的计划贵了

2219
01:26:48,090 --> 01:26:49,739
我不需要

2220
01:26:49,739 --> 01:26:50,969
看树下的任何东西

2221
01:26:50,969 --> 01:26:52,350
因为我知道我永远不会

2222
01:26:52,350 --> 01:26:56,760
比这更好 所以

2223
01:26:56,760 --> 01:26:59,790
火山的优势 优化器，我们

2224
01:26:59,790 --> 01:27:01,290
已经声明了一个规则来进行我们的

2225
01:27:01,290 --> 01:27:03,390
转换，但草莓也

2226
01:27:03,390 --> 01:27:05,219
有同样的事情，但是它会

2227
01:27:05,219 --> 01:27:07,110
通过有效的搜索算法具有更好的可扩展性，

2228
01:27:07,110 --> 01:27:08,460
因为我们可以通过缓存我们的转换来减少

2229
01:27:08,460 --> 01:27:10,620
我们必须做的冗余估计的数量

2230
01:27:10,620 --> 01:27:12,870


2231
01:27:12,870 --> 01:27:14,119


2232
01:27:14,119 --> 01:27:18,229
问题虽然是

2233
01:27:18,229 --> 01:27:20,649
至少波火山的实施是，

2234
01:27:20,649 --> 01:27:24,229
对于每一个可能的修剪，就像

2235
01:27:24,229 --> 01:27:25,550
我正在看的每一个操作一样，我

2236
01:27:25,550 --> 01:27:28,309
会扩展所有可能的

2237
01:27:28,309 --> 01:27:29,719
组合，比如厄尔，你的

2238
01:27:29,719 --> 01:27:31,999
转换就像我曾经有过的那样，然后

2239
01:27:31,999 --> 01:27:33,949
现在 开始进行搜索和所有

2240
01:27:33,949 --> 01:27:36,109
这些，而不是

2241
01:27:36,109 --> 01:27:38,899
首先遍历底部然后

2242
01:27:38,899 --> 01:27:41,599
修改谓词并不容易我不

2243
01:27:41,599 --> 01:27:43,760
完全知道这是关于它的

2244
01:27:43,760 --> 01:27:45,530
我认为本质上这意味着你

2245
01:27:45,530 --> 01:27:47,419
不能做 重写 like where

2246
01:27:47,419 --> 01:27:49,999
子句，因为优化器本身

2247
01:27:49,999 --> 01:27:51,739
只知道如何对

2248
01:27:51,739 --> 01:27:53,780
物理仲裁器进行转换，而不是

2249
01:27:53,780 --> 01:27:56,989
它们内部的表达式树，所以我

2250
01:27:56,989 --> 01:27:58,669
在最后匆匆忙忙只是为了向您

2251
01:27:58,669 --> 01:28:01,459
展示自上而下的优化器是什么样的

2252
01:28:01,459 --> 01:28:04,129
但是接下来的课程将学习 Cascades

2253
01:28:04,129 --> 01:28:04,760


2254
01:28:04,760 --> 01:28:07,339
所以希望所有这一切的主要收获

2255
01:28:07,339 --> 01:28:10,010
是查询优化非常

2256
01:28:10,010 --> 01:28:12,919
困难，这就是为什么

2257
01:28:12,919 --> 01:28:14,329
最新的生态系统

2258
01:28:14,329 --> 01:28:18,050
可能在十年前首次出现时他们

2259
01:28:18,050 --> 01:28:19,489
基本上没有实施的部分原因 查询

2260
01:28:19,489 --> 01:28:20,089
优化器，

2261
01:28:20,089 --> 01:28:21,559
因为它啊我们不需要做连接

2262
01:28:21,559 --> 01:28:23,359
你不需要像续集这样的声明性语言

2263
01:28:23,359 --> 01:28:26,569


2264
01:28:26,569 --> 01:28:28,879
，不支持这些东西的部分优点

2265
01:28:28,879 --> 01:28:29,959
是你不必构建一个 查询

2266
01:28:29,959 --> 01:28:32,419
优化器，但现在对于那些

2267
01:28:32,419 --> 01:28:34,309
确实添加了一些看起来像 sequel

2268
01:28:34,309 --> 01:28:36,589
orderly 的声明性语言的系统，

2269
01:28:36,589 --> 01:28:38,119
他们必须去实现 Cori 优化器

2270
01:28:38,119 --> 01:28:40,699
，然后它们的质量可能

2271
01:28:40,699 --> 01:28:42,589
会有很大差异，它们通常会

2272
01:28:42,589 --> 01:28:45,739
是基于启发式的系统，好吧

2273
01:28:45,739 --> 01:28:48,859
下一堂课将开始讨论更多的

2274
01:28:48,859 --> 01:28:50,869
优化器，然后真正的辩论

2275
01:28:50,869 --> 01:28:52,819
将再次是动态编程

2276
01:28:52,819 --> 01:28:54,739
与 Cascades 拉刀自底向上的

2277
01:28:54,739 --> 01:28:56,629
方法我们看到的所有系统首先是自

2278
01:28:56,629 --> 01:28:58,729
顶向下的方法，其中火山是一个

2279
01:28:58,729 --> 01:29:00,559
例子，但是一个 Cascades Cascades 将

2280
01:29:00,559 --> 01:29:02,089
是更复杂的实施

2281
01:29:02,089 --> 01:29:04,999
，这就是我们今天在我们的系统中使用的内容

2282
01:29:04,999 --> 01:29:10,489
好的，所以我

2283
01:29:10,489 --> 01:29:12,349
本周再次与每个项目的所有人会面，

2284
01:29:12,349 --> 01:29:15,439
然后在下周的星期三

2285
01:29:15,439 --> 01:29:17,689
我们将进行课堂演示

2286
01:29:17,689 --> 01:29:18,469
或 放大

2287
01:29:18,469 --> 01:29:21,079
好的 洗手 把它沉在旁边的

2288
01:29:21,079 --> 01:29:23,110
公园里 这是什么意思

2289
01:29:23,110 --> 01:29:25,510
说明你在这里 我喝了口

2290
01:29:25,510 --> 01:29:28,090
酒 今天不得不吐口水 死鹿被

2291
01:29:28,090 --> 01:29:30,790
称为洞，因为我是麻糬 ce cube down

2292
01:29:30,790 --> 01:29:33,489
with the test team I look and it was

2293
01:29:33,489 --> 01:29:36,489
going to take me a 40 just to get my boss song

2294
01:29:36,489 --> 01:29:40,190
因为我需要多一点踢

2295
01:29:40,190 --> 01:29:43,170
[音乐]

2296
01:29:43,170 --> 01:29:47,500
这很好，我的引擎盖想让我

2297
01:29:47,500 --> 01:29:49,780
说我很可爱 说我

2298
01:29:49,780 --> 01:29:52,590
庆祝

