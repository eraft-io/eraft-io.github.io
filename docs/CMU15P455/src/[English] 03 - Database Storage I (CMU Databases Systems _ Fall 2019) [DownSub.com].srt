1
00:00:00,080 --> 00:00:16,550
Oh guys is restarting

2
00:00:16,550 --> 00:00:20,900
welcome again sorry for being away last

3
00:00:20,900 --> 00:00:23,180
week but I mean in town now so real

4
00:00:23,180 --> 00:00:24,680
quick we'll pause around for my our DJ

5
00:00:24,680 --> 00:00:29,539
DJ drop tables so I don't think people

6
00:00:29,539 --> 00:00:31,460
know how bad you are right so once you

7
00:00:31,460 --> 00:00:32,270
show the people a little bit someone

8
00:00:32,270 --> 00:00:35,430
what you what you can do write letter it

9
00:00:35,430 --> 00:00:41,650
[Laughter]

10
00:00:45,380 --> 00:00:47,910
this is real yes we do have a course DJ

11
00:00:47,910 --> 00:00:49,410
right I've always won one now I have one

12
00:00:49,410 --> 00:00:50,640
how was your summer

13
00:00:50,640 --> 00:00:56,970
good would you out there doing your

14
00:00:56,970 --> 00:01:00,120
thing okay awesome yeah all right what

15
00:01:00,120 --> 00:01:09,560
else is new yeah yeah there's that yeah

16
00:01:09,680 --> 00:01:12,420
I mean so we're still been a database

17
00:01:12,420 --> 00:01:13,500
system here at Carnegie Mellon so we're

18
00:01:13,500 --> 00:01:14,550
still grinding on that that's just

19
00:01:14,550 --> 00:01:18,259
taking all my time right you know it is

20
00:01:18,350 --> 00:01:20,369
yes that is true

21
00:01:20,369 --> 00:01:24,030
I did get somebody pregnant okay so

22
00:01:24,030 --> 00:01:25,140
let's let's go through this real quickly

23
00:01:25,140 --> 00:01:27,270
all right so I only care about two

24
00:01:27,270 --> 00:01:28,800
things in my life I say this every

25
00:01:28,800 --> 00:01:32,640
semester number one is my wife number

26
00:01:32,640 --> 00:01:34,500
two is databases I don't give up

27
00:01:34,500 --> 00:01:36,869
anything else right my family vote for

28
00:01:36,869 --> 00:01:38,970
Trump I don't talk to them I you know I

29
00:01:38,970 --> 00:01:40,380
have the dog that's fine but like I

30
00:01:40,380 --> 00:01:41,789
don't have any other hobbies

31
00:01:41,789 --> 00:01:44,670
it's just databases right and again so

32
00:01:44,670 --> 00:01:47,729
people think I say crazy stuff and

33
00:01:47,729 --> 00:01:50,640
so if I start talking fast I want you to

34
00:01:50,640 --> 00:01:52,590
please interrupt me to slow down right

35
00:01:52,590 --> 00:01:54,479
and just tell me repeat myself

36
00:01:54,479 --> 00:01:56,159
I say you're sounding stupid you're

37
00:01:56,159 --> 00:01:57,630
going too fast slow down

38
00:01:57,630 --> 00:01:59,399
you can also interrupt me when you don't

39
00:01:59,399 --> 00:02:01,259
understand what I'm talking about

40
00:02:01,259 --> 00:02:02,880
and I actually encourage you and I want

41
00:02:02,880 --> 00:02:04,590
you to do this because I know this like

42
00:02:04,590 --> 00:02:06,119
I don't know if you guys knew it so

43
00:02:06,119 --> 00:02:08,068
please stop me if you don't understand

44
00:02:08,068 --> 00:02:08,940
what I'm talk about already have a

45
00:02:08,940 --> 00:02:10,769
server database related question what

46
00:02:10,769 --> 00:02:13,050
you can't stop me about or stupid things

47
00:02:13,050 --> 00:02:14,760
like you have a question up blockchain

48
00:02:14,760 --> 00:02:16,260
like in previous years I don't care

49
00:02:16,260 --> 00:02:17,430
about ball chains okay

50
00:02:17,430 --> 00:02:19,049
this course is not about block planes

51
00:02:19,049 --> 00:02:20,880
that's not we're talked about here if

52
00:02:20,880 --> 00:02:23,220
you also have a weird rash on your body

53
00:02:23,220 --> 00:02:24,840
don't share it with the class in front

54
00:02:24,840 --> 00:02:26,220
of the middle of lecture this happened

55
00:02:26,220 --> 00:02:28,230
the first year it's weird don't do that

56
00:02:28,230 --> 00:02:31,980
okay so all right what does this mean so

57
00:02:31,980 --> 00:02:34,440
this means that I want you to interrupt

58
00:02:34,440 --> 00:02:36,060
me as much as possible right don't be

59
00:02:36,060 --> 00:02:37,290
embarrassed there's no stupid questions

60
00:02:37,290 --> 00:02:39,480
so if you have a question though about

61
00:02:39,480 --> 00:02:41,940
the lecture don't calm up in front of me

62
00:02:41,940 --> 00:02:43,530
at the end end of the class be like Oh

63
00:02:43,530 --> 00:02:45,060
what about slide three what did you mean

64
00:02:45,060 --> 00:02:46,530
all this I will not answer these

65
00:02:46,530 --> 00:02:48,090
questions because if you have a question

66
00:02:48,090 --> 00:02:49,500
while I'm talking then somebody else

67
00:02:49,500 --> 00:02:51,450
probably is a question and I rather just

68
00:02:51,450 --> 00:02:53,010
discuss in front of everyone rather than

69
00:02:53,010 --> 00:02:54,389
a line of people saying what about slide

70
00:02:54,389 --> 00:02:55,859
forward what about slide six over never

71
00:02:55,859 --> 00:02:58,109
again okay so again I will not be

72
00:02:58,109 --> 00:02:59,819
offended I don't care just interrupt me

73
00:02:59,819 --> 00:03:02,190
if you have questions okay so with that

74
00:03:02,190 --> 00:03:06,870
any questions okay so I also post on

75
00:03:06,870 --> 00:03:09,450
Piazza that homework one is out it'll be

76
00:03:09,450 --> 00:03:12,269
due on the on the 11th next week and

77
00:03:12,269 --> 00:03:14,130
then we'll also be releasing project one

78
00:03:14,130 --> 00:03:17,370
on github next week as well just sort of

79
00:03:17,370 --> 00:03:18,569
keep in mind of this this is this is

80
00:03:18,569 --> 00:03:20,609
only your schedule with coming up who

81
00:03:20,609 --> 00:03:21,870
here has finished the first homework I

82
00:03:21,870 --> 00:03:23,040
think somebody already did and got a

83
00:03:23,040 --> 00:03:23,900
perfect score

84
00:03:23,900 --> 00:03:26,250
and they're not here awesome even better

85
00:03:26,250 --> 00:03:29,760
okay so again it's we're giving you a

86
00:03:29,760 --> 00:03:31,560
sequel byte file we're making you write

87
00:03:31,560 --> 00:03:32,670
some simple queries it's sort of to

88
00:03:32,670 --> 00:03:33,959
force you to do some of the things we

89
00:03:33,959 --> 00:03:35,459
talked about in the second lecture and

90
00:03:35,459 --> 00:03:37,049
this will actually be the only time you

91
00:03:37,049 --> 00:03:38,340
were right sequel query for the rest of

92
00:03:38,340 --> 00:03:40,349
the semester all the projects you will

93
00:03:40,349 --> 00:03:42,750
be doing and it will be in C++ and all

94
00:03:42,750 --> 00:03:44,150
the homeworks will be pencil and paper

95
00:03:44,150 --> 00:03:46,590
okay so this I want at least have you

96
00:03:46,590 --> 00:03:48,030
take a database course at least you know

97
00:03:48,030 --> 00:03:51,079
write some sequel once in your life okay

98
00:03:51,079 --> 00:03:53,930
all right so let's jump right into this

99
00:03:53,930 --> 00:03:57,390
so last class at least the last two

100
00:03:57,390 --> 00:04:00,420
classes we spent time talking about what

101
00:04:00,420 --> 00:04:01,560
a database looks like at a

102
00:04:01,560 --> 00:04:03,840
the logical level what is the

103
00:04:03,840 --> 00:04:05,640
application programmers see they see

104
00:04:05,640 --> 00:04:08,550
relational tables they see sequel and so

105
00:04:08,550 --> 00:04:10,980
now what we want to talk about is how

106
00:04:10,980 --> 00:04:12,620
are we actually gonna build the software

107
00:04:12,620 --> 00:04:15,060
that's gonna manage this database system

108
00:04:15,060 --> 00:04:16,200
alright this is essentially what the

109
00:04:16,200 --> 00:04:18,060
course is about right how do we actually

110
00:04:18,060 --> 00:04:20,250
going to store database and and and

111
00:04:20,250 --> 00:04:22,530
allow queries to execute and you've

112
00:04:22,530 --> 00:04:23,760
dried new data from it

113
00:04:23,760 --> 00:04:27,300
so the overall outline for the course

114
00:04:27,300 --> 00:04:29,040
again we've already covered the logical

115
00:04:29,040 --> 00:04:30,600
part at the top it'll age from databases

116
00:04:30,600 --> 00:04:32,520
and now we're starting to be going

117
00:04:32,520 --> 00:04:35,010
through different parts of a database

118
00:04:35,010 --> 00:04:36,840
and some one-by-one as if they're like

119
00:04:36,840 --> 00:04:39,060
as if different layers so we'll start

120
00:04:39,060 --> 00:04:40,410
talking about storage query execution

121
00:04:40,410 --> 00:04:41,820
Kurchatov recovery and then we'll get to

122
00:04:41,820 --> 00:04:43,050
like distributed databases and other

123
00:04:43,050 --> 00:04:45,720
topics at the at the end and the way to

124
00:04:45,720 --> 00:04:47,220
think about this this is a gross

125
00:04:47,220 --> 00:04:48,930
approximation of what a database is

126
00:04:48,930 --> 00:04:50,880
looks like it's just a bunch of layers

127
00:04:50,880 --> 00:04:53,190
built on top of each other right so

128
00:04:53,190 --> 00:04:55,410
we're gonna focus on this lecture and

129
00:04:55,410 --> 00:04:57,240
the next lecture on the on the disk

130
00:04:57,240 --> 00:04:58,979
manager how do we actually store data

131
00:04:58,979 --> 00:05:01,290
you know on files on disk and then above

132
00:05:01,290 --> 00:05:03,180
that once we know what API we're gonna

133
00:05:03,180 --> 00:05:04,530
expose to the upper levels in the system

134
00:05:04,530 --> 00:05:06,539
we start adding those extra levels to it

135
00:05:06,539 --> 00:05:07,890
till at the end we have a full-featured

136
00:05:07,890 --> 00:05:10,470
database management system so that's the

137
00:05:10,470 --> 00:05:11,550
way to think about we're talking at this

138
00:05:11,550 --> 00:05:13,080
point so we're no more sequel stuff no

139
00:05:13,080 --> 00:05:16,410
more relational model stuff aspects of

140
00:05:16,410 --> 00:05:17,669
it are gonna be important for how we

141
00:05:17,669 --> 00:05:19,440
make different design decisions in our

142
00:05:19,440 --> 00:05:22,500
system but can we you know we have to

143
00:05:22,500 --> 00:05:23,310
figure out how do we actually gonna run

144
00:05:23,310 --> 00:05:26,370
sequel queries but it's not like we're

145
00:05:26,370 --> 00:05:27,750
gonna worry about how to write you know

146
00:05:27,750 --> 00:05:29,250
you know complex sequel queries because

147
00:05:29,250 --> 00:05:31,110
we've already done that ok it's again

148
00:05:31,110 --> 00:05:33,360
we're focusing on different levels in

149
00:05:33,360 --> 00:05:35,280
the system different layers one by one

150
00:05:35,280 --> 00:05:36,810
and then you know sort of going up the

151
00:05:36,810 --> 00:05:40,289
stack so as I said the first lecture as

152
00:05:40,289 --> 00:05:42,510
well this course is about building disk

153
00:05:42,510 --> 00:05:44,550
oriented database management systems so

154
00:05:44,550 --> 00:05:46,350
just just to reiterate what I mean by

155
00:05:46,350 --> 00:05:48,090
that if Discordian database system is

156
00:05:48,090 --> 00:05:50,760
one where the software makes the

157
00:05:50,760 --> 00:05:52,169
assumption that the primary search

158
00:05:52,169 --> 00:05:54,590
location of the database is on disk and

159
00:05:54,590 --> 00:05:57,360
so that means that any single time we

160
00:05:57,360 --> 00:05:59,700
have to execute a query it may actually

161
00:05:59,700 --> 00:06:01,620
want to run you know to want to access

162
00:06:01,620 --> 00:06:03,450
data that's not in memory and we got to

163
00:06:03,450 --> 00:06:04,620
go out in the disk and get it and

164
00:06:04,620 --> 00:06:06,780
there's a bunch of components in sand

165
00:06:06,780 --> 00:06:08,639
how we design our software that are

166
00:06:08,639 --> 00:06:10,289
going to be based on this assumption to

167
00:06:10,289 --> 00:06:12,000
protect ourselves from losing data

168
00:06:12,000 --> 00:06:14,220
having you know invalid or incorrect

169
00:06:14,220 --> 00:06:14,560
data

170
00:06:14,560 --> 00:06:16,240
right so this is something's gonna

171
00:06:16,240 --> 00:06:17,290
permeate all throughout the entire

172
00:06:17,290 --> 00:06:18,790
system and we need to be aware of at any

173
00:06:18,790 --> 00:06:20,139
given time something we're trying to

174
00:06:20,139 --> 00:06:23,320
read is not in memory so to understand

175
00:06:23,320 --> 00:06:25,510
this a bit further we want to make the

176
00:06:25,510 --> 00:06:27,700
distinction between volatile and

177
00:06:27,700 --> 00:06:30,160
non-volatile storage so essentially what

178
00:06:30,160 --> 00:06:31,240
we're trying to do is we're trying to

179
00:06:31,240 --> 00:06:32,620
have the data system manage the movement

180
00:06:32,620 --> 00:06:35,410
of data from non-volatile storage into

181
00:06:35,410 --> 00:06:37,990
volatile storage so what I mean by that

182
00:06:37,990 --> 00:06:40,000
the way you think about the storage

183
00:06:40,000 --> 00:06:44,080
hierarchy of computers is as such right

184
00:06:44,080 --> 00:06:45,970
you sort of start at the very bottom or

185
00:06:45,970 --> 00:06:47,740
start at the very top you're gonna have

186
00:06:47,740 --> 00:06:49,690
things that are be very fast very

187
00:06:49,690 --> 00:06:51,400
expensive they're very small so the way

188
00:06:51,400 --> 00:06:53,200
to think of this is like a spectrum at

189
00:06:53,200 --> 00:06:55,450
the top you have things that like CPU

190
00:06:55,450 --> 00:06:58,900
registers or CPU caches l1 l2 l3 these

191
00:06:58,900 --> 00:07:01,000
things are very fast right but they're

192
00:07:01,000 --> 00:07:02,020
doing very small capacity because

193
00:07:02,020 --> 00:07:03,370
they're like literally sitting on the

194
00:07:03,370 --> 00:07:05,979
CPU itself then we're gonna have DRAM

195
00:07:05,979 --> 00:07:07,960
and then below that we'll have SSDs

196
00:07:07,960 --> 00:07:09,220
spinning these hard drives in network

197
00:07:09,220 --> 00:07:11,740
storage again at the bottom they're very

198
00:07:11,740 --> 00:07:13,240
large but they're much slower and

199
00:07:13,240 --> 00:07:16,210
they're cheaper so again the dichotomy

200
00:07:16,210 --> 00:07:17,740
that we care about is this division line

201
00:07:17,740 --> 00:07:20,289
here so anything above this line is

202
00:07:20,289 --> 00:07:27,850
volatile what does that mean yes yeah

203
00:07:27,850 --> 00:07:29,560
she says it's not it's not persisted

204
00:07:29,560 --> 00:07:30,970
when you lose power absolutely so all

205
00:07:30,970 --> 00:07:33,970
these storage devices require constant

206
00:07:33,970 --> 00:07:37,180
energy right like electricity to

207
00:07:37,180 --> 00:07:38,890
maintain whatever they're storing right

208
00:07:38,890 --> 00:07:40,350
you pull the power from your computer

209
00:07:40,350 --> 00:07:42,610
everything in DRAM gets wiped everything

210
00:07:42,610 --> 00:07:44,710
on your CPU caches get wiped everything

211
00:07:44,710 --> 00:07:46,180
below this is non-volatile meaning it

212
00:07:46,180 --> 00:07:48,100
doesn't require constant power in order

213
00:07:48,100 --> 00:07:50,919
to persist whatever was stored in it so

214
00:07:50,919 --> 00:07:52,300
that's the minute at a high level that's

215
00:07:52,300 --> 00:07:53,650
the major thing that we care about do we

216
00:07:53,650 --> 00:07:56,100
have to move data from here up into here

217
00:07:56,100 --> 00:07:58,450
there's other aspect events though that

218
00:07:58,450 --> 00:08:00,430
are going to put that are going to

219
00:08:00,430 --> 00:08:02,080
affect how we design our software and

220
00:08:02,080 --> 00:08:03,639
that has to do how're actually can

221
00:08:03,639 --> 00:08:06,160
access this data so if it's in volatile

222
00:08:06,160 --> 00:08:08,350
storage it's gonna support fast random

223
00:08:08,350 --> 00:08:10,479
access maybe we can jump to any sort of

224
00:08:10,479 --> 00:08:12,220
address location in the storage device

225
00:08:12,220 --> 00:08:16,030
very quickly and we're gonna get roughly

226
00:08:16,030 --> 00:08:18,729
the same performance no matter what

227
00:08:18,729 --> 00:08:21,070
order we access the access things I mean

228
00:08:21,070 --> 00:08:22,419
if I jump to this location this location

229
00:08:22,419 --> 00:08:24,310
and maybe back to another location I'm

230
00:08:24,310 --> 00:08:26,440
gonna get approximately the same latency

231
00:08:26,440 --> 00:08:28,570
the same speed

232
00:08:28,570 --> 00:08:31,120
sorry non-volatile storage they're gonna

233
00:08:31,120 --> 00:08:32,650
have instead of having byte addressable

234
00:08:32,650 --> 00:08:34,030
access to and how block addressable

235
00:08:34,030 --> 00:08:36,940
access so in byte addressable access

236
00:08:36,940 --> 00:08:38,740
that means I want to read 64 bits at

237
00:08:38,740 --> 00:08:40,419
this stores location I can just go read

238
00:08:40,419 --> 00:08:42,250
just that 64 bits and get exactly what I

239
00:08:42,250 --> 00:08:44,290
want I'm oversimplifying but that's

240
00:08:44,290 --> 00:08:46,090
essentially how from the programmers

241
00:08:46,090 --> 00:08:48,220
perspective of us as the database system

242
00:08:48,220 --> 00:08:51,970
developer that's what we we see in a

243
00:08:51,970 --> 00:08:53,920
non-volatile storage we can't go get

244
00:08:53,920 --> 00:08:56,530
exactly just a 64 bits that we want we

245
00:08:56,530 --> 00:08:58,060
have to go get the block or the page

246
00:08:58,060 --> 00:09:00,400
that has that data that we want and we

247
00:09:00,400 --> 00:09:01,450
have to get everything that's along with

248
00:09:01,450 --> 00:09:03,430
that page so I only want to read 64 bits

249
00:09:03,430 --> 00:09:05,980
and that that you know and it's a

250
00:09:05,980 --> 00:09:07,300
non-volatile storage I have to go get

251
00:09:07,300 --> 00:09:08,830
the four kilobyte page that it's stored

252
00:09:08,830 --> 00:09:10,210
in and then go pick out the just the

253
00:09:10,210 --> 00:09:13,210
piece that I want another aspect that is

254
00:09:13,210 --> 00:09:15,730
that the these systems also particularly

255
00:09:15,730 --> 00:09:17,760
usually have faster sequential access

256
00:09:17,760 --> 00:09:20,980
meaning 5v a bunch of contiguous blocks

257
00:09:20,980 --> 00:09:23,260
in the storage device I can do that very

258
00:09:23,260 --> 00:09:24,820
more efficiently than just reading

259
00:09:24,820 --> 00:09:27,280
random locations the easiest way to

260
00:09:27,280 --> 00:09:28,960
visualize this is just think about like

261
00:09:28,960 --> 00:09:30,670
spinning this hard drive right most

262
00:09:30,670 --> 00:09:32,680
laptops or every laptop pretty much

263
00:09:32,680 --> 00:09:33,730
doesn't come with a spinning disk hard

264
00:09:33,730 --> 00:09:36,370
drive but at a hot you know basically

265
00:09:36,370 --> 00:09:38,020
the way it works is that you have this

266
00:09:38,020 --> 00:09:39,460
arm that's physically moving on the

267
00:09:39,460 --> 00:09:41,050
platter like like a turntable and

268
00:09:41,050 --> 00:09:43,810
combined already single time you got to

269
00:09:43,810 --> 00:09:44,980
jump to new location you have to pick

270
00:09:44,980 --> 00:09:46,030
the arm up and move it to another

271
00:09:46,030 --> 00:09:47,560
location and that's a physical movement

272
00:09:47,560 --> 00:09:49,900
and it's very expensive and slow SSDs

273
00:09:49,900 --> 00:09:50,980
don't have this problem because it's

274
00:09:50,980 --> 00:09:54,160
solid-state but there's other issues so

275
00:09:54,160 --> 00:09:56,020
in these storage devices we want to try

276
00:09:56,020 --> 00:09:57,430
to maximize the amount of data that we

277
00:09:57,430 --> 00:09:59,500
can read that's sequential right and

278
00:09:59,500 --> 00:10:01,180
these ones we in the volatile storage we

279
00:10:01,180 --> 00:10:04,240
don't care as much so for the purposes

280
00:10:04,240 --> 00:10:06,310
of this course we're just going to say

281
00:10:06,310 --> 00:10:08,140
that anything that's in DRAM we're just

282
00:10:08,140 --> 00:10:10,330
gonna call this memory like that that's

283
00:10:10,330 --> 00:10:11,860
what we mostly care about how we

284
00:10:11,860 --> 00:10:14,110
actually put things into memory and then

285
00:10:14,110 --> 00:10:16,210
anything below this this line here we're

286
00:10:16,210 --> 00:10:18,250
just gonna say this is disk and for all

287
00:10:18,250 --> 00:10:19,600
most of the algorithms and most of the

288
00:10:19,600 --> 00:10:20,560
methods were going to talk about in this

289
00:10:20,560 --> 00:10:23,140
course we don't care whether it's it's

290
00:10:23,140 --> 00:10:26,350
you know which one of these it is it's

291
00:10:26,350 --> 00:10:27,220
not entirely true when we talk about

292
00:10:27,220 --> 00:10:29,430
joins sequential access matters a lot

293
00:10:29,430 --> 00:10:32,080
but we'll come to that later and so I

294
00:10:32,080 --> 00:10:33,310
don't think the textbook talks about

295
00:10:33,310 --> 00:10:34,750
network storage they usually they always

296
00:10:34,750 --> 00:10:36,220
when you see these kind of hierarchies

297
00:10:36,220 --> 00:10:38,260
always have tape drives at the bottom

298
00:10:38,260 --> 00:10:40,150
but nobody runs databases on those

299
00:10:40,150 --> 00:10:41,230
anymore there's a relief like disaster

300
00:10:41,230 --> 00:10:42,130
recovery

301
00:10:42,130 --> 00:10:44,110
network storage would be like EBS or s3

302
00:10:44,110 --> 00:10:47,590
on on Amazon so the reason why we're not

303
00:10:47,590 --> 00:10:48,760
gonna talk about these things at the top

304
00:10:48,760 --> 00:10:50,710
is that where you focus on these things

305
00:10:50,710 --> 00:10:52,270
in the Advanced Course in the spring and

306
00:10:52,270 --> 00:10:54,910
for our purposes in this class this this

307
00:10:54,910 --> 00:10:57,370
course in the semester this is so slow

308
00:10:57,370 --> 00:10:59,640
anyway that who cares how fast we can be

309
00:10:59,640 --> 00:11:02,500
putting things in CP registers in the

310
00:11:02,500 --> 00:11:04,000
advanced class we assume the database is

311
00:11:04,000 --> 00:11:05,500
always here in DRAM and therefore these

312
00:11:05,500 --> 00:11:07,000
things actually matter but for this

313
00:11:07,000 --> 00:11:08,410
entire semester we won't really talk

314
00:11:08,410 --> 00:11:10,450
about worrying about things sitting in

315
00:11:10,450 --> 00:11:12,370
CPU caches because it doesn't matter cuz

316
00:11:12,370 --> 00:11:15,970
going to disk so slow now I always talk

317
00:11:15,970 --> 00:11:18,240
about this every year this is actually a

318
00:11:18,240 --> 00:11:20,620
new class of storage devices that sort

319
00:11:20,620 --> 00:11:22,390
of straddles the line called

320
00:11:22,390 --> 00:11:24,430
non-volatile memory who here has heard

321
00:11:24,430 --> 00:11:27,610
of this before who here has heard Intel

322
00:11:27,610 --> 00:11:30,790
obtained memory one two three all right

323
00:11:30,790 --> 00:11:32,290
yeah so that's so Intel is actually the

324
00:11:32,290 --> 00:11:33,700
first manufacturer the hash tag put

325
00:11:33,700 --> 00:11:35,470
released this everybody's been working

326
00:11:35,470 --> 00:11:37,810
on this for like 15 20 years Intel

327
00:11:37,810 --> 00:11:39,820
actually put the first one is put out

328
00:11:39,820 --> 00:11:42,460
the first devices so it's like DRAM

329
00:11:42,460 --> 00:11:43,930
where it sits in the dim slot and yet

330
00:11:43,930 --> 00:11:45,850
it's byte addressable but it's like an

331
00:11:45,850 --> 00:11:47,650
SSD meaning if you pull the power on the

332
00:11:47,650 --> 00:11:49,770
machine it persists all your data

333
00:11:49,770 --> 00:11:51,940
alright so this is super cool this is

334
00:11:51,940 --> 00:11:53,320
like the future of what computer is

335
00:11:53,320 --> 00:11:55,240
gonna be look like and eventually we'll

336
00:11:55,240 --> 00:11:57,940
have to rewrite this class to take this

337
00:11:57,940 --> 00:11:59,830
an account but we're not there yet it's

338
00:11:59,830 --> 00:12:02,890
not widely available now again this is

339
00:12:02,890 --> 00:12:03,850
something I've been working on it for a

340
00:12:03,850 --> 00:12:05,560
while so this is a book that I wrote

341
00:12:05,560 --> 00:12:08,110
with my first PC student we it was

342
00:12:08,110 --> 00:12:09,460
basically his dissertation they put into

343
00:12:09,460 --> 00:12:11,980
book form but I think this is the future

344
00:12:11,980 --> 00:12:13,480
we're just not there yet it's not widely

345
00:12:13,480 --> 00:12:14,950
available but you can't get on Amazon

346
00:12:14,950 --> 00:12:17,620
yet but eventually a lot of talk about

347
00:12:17,620 --> 00:12:19,330
what could go away if you have

348
00:12:19,330 --> 00:12:22,570
non-volatile memory all right so let's

349
00:12:22,570 --> 00:12:24,630
talk about how slow these things are so

350
00:12:24,630 --> 00:12:26,890
there's again there's different tables

351
00:12:26,890 --> 00:12:27,940
on the internet that have different

352
00:12:27,940 --> 00:12:29,530
numbers but these approximately the same

353
00:12:29,530 --> 00:12:31,030
you know roughly in the same ballpark

354
00:12:31,030 --> 00:12:32,740
the thing that matters most is the

355
00:12:32,740 --> 00:12:33,850
orders of magnitude that that's

356
00:12:33,850 --> 00:12:34,830
different between these storage devices

357
00:12:34,830 --> 00:12:37,620
so let's say I need to read a 64 bits

358
00:12:37,620 --> 00:12:39,880
from from different storage device if

359
00:12:39,880 --> 00:12:43,420
I'm in l1 cache then it's like half a

360
00:12:43,420 --> 00:12:46,780
nanosecond if it's in l2 l2 it's seven

361
00:12:46,780 --> 00:12:49,150
and a seconds and so forth to get to

362
00:12:49,150 --> 00:12:52,900
really long just long delays so again

363
00:12:52,900 --> 00:12:54,820
this is why we spent all this time in

364
00:12:54,820 --> 00:12:55,939
this class worrying

365
00:12:55,939 --> 00:12:58,549
how how we can try to minimize the

366
00:12:58,549 --> 00:13:00,739
impact of reading data from disk right

367
00:13:00,739 --> 00:13:01,669
because there's a pretty big difference

368
00:13:01,669 --> 00:13:04,939
between 100 nanoseconds and 150,000

369
00:13:04,939 --> 00:13:07,069
nanoseconds and so for every single

370
00:13:07,069 --> 00:13:08,269
query if we always have to go out the

371
00:13:08,269 --> 00:13:10,279
disk then we're screwed right the thing

372
00:13:10,279 --> 00:13:11,779
is gonna be essentially grind to a halt

373
00:13:11,779 --> 00:13:12,829
and we're not gonna get any work done

374
00:13:12,829 --> 00:13:14,869
and I realized putting this in terms of

375
00:13:14,869 --> 00:13:16,729
nanoseconds is hard for us to as humans

376
00:13:16,729 --> 00:13:18,769
to wrap our heads around so if you just

377
00:13:18,769 --> 00:13:21,769
replace nanosecond with seconds then you

378
00:13:21,769 --> 00:13:23,389
start to realize how long these numbers

379
00:13:23,389 --> 00:13:26,329
actually are right so the way to think

380
00:13:26,329 --> 00:13:28,099
about this is like in another metaphor

381
00:13:28,099 --> 00:13:29,629
you like to use from Jim Jim Gray a

382
00:13:29,629 --> 00:13:32,899
famous database researcher is that say

383
00:13:32,899 --> 00:13:35,359
that I want to read a book I want to

384
00:13:35,359 --> 00:13:38,089
read a page in a book so if it's in l1

385
00:13:38,089 --> 00:13:39,439
then it's just like reading the book

386
00:13:39,439 --> 00:13:40,819
right in front of me on this table if

387
00:13:40,819 --> 00:13:43,549
it's in l2 then maybe it's going across

388
00:13:43,549 --> 00:13:45,799
the room to read it if it's an F it's in

389
00:13:45,799 --> 00:13:47,179
DRAM that I got to walk to the library

390
00:13:47,179 --> 00:13:49,579
and then now you start to these you know

391
00:13:49,579 --> 00:13:50,959
larger and larger orders of magnitude

392
00:13:50,959 --> 00:13:52,669
and if you have to read from a tape

393
00:13:52,669 --> 00:13:54,979
drive it's like flying the Pluto to read

394
00:13:54,979 --> 00:13:56,619
a page in a book it just takes forever

395
00:13:56,619 --> 00:13:59,059
so again this is why people don't want

396
00:13:59,059 --> 00:14:00,439
to store data on this but note is that

397
00:14:00,439 --> 00:14:04,129
they had to all right so the goal of

398
00:14:04,129 --> 00:14:05,989
what we're trying to do in our DNA

399
00:14:05,989 --> 00:14:08,539
system is that we want to provide the

400
00:14:08,539 --> 00:14:12,319
illusion to the application that we have

401
00:14:12,319 --> 00:14:13,909
enough memory to store their entire data

402
00:14:13,909 --> 00:14:15,919
base in memory essentially like you know

403
00:14:15,919 --> 00:14:17,299
there's a fine amount of memory on our

404
00:14:17,299 --> 00:14:20,269
machine and we want to say we want to

405
00:14:20,269 --> 00:14:21,589
store a database that exceeds the amount

406
00:14:21,589 --> 00:14:23,929
of memory that's available to us but

407
00:14:23,929 --> 00:14:25,309
without having to you know grind to a

408
00:14:25,309 --> 00:14:27,559
halt every single time we read something

409
00:14:27,559 --> 00:14:29,899
or write something right so again that's

410
00:14:29,899 --> 00:14:31,849
what focus in this course is and and the

411
00:14:31,849 --> 00:14:33,739
next three lectures is really about how

412
00:14:33,739 --> 00:14:36,409
can we be careful on any single time

413
00:14:36,409 --> 00:14:37,669
we've got to read something from disk or

414
00:14:37,669 --> 00:14:39,639
run a query that we minimize that impact

415
00:14:39,639 --> 00:14:41,509
and we're gonna do a bunch of different

416
00:14:41,509 --> 00:14:43,669
tricks to to mitigate this problem by

417
00:14:43,669 --> 00:14:45,649
allowing different threads or different

418
00:14:45,649 --> 00:14:47,059
queries are run at the same time by

419
00:14:47,059 --> 00:14:49,189
caching things by pre computing some

420
00:14:49,189 --> 00:14:50,629
data there's a whole bunch of slew of

421
00:14:50,629 --> 00:14:51,709
tricks that we're gonna have in our

422
00:14:51,709 --> 00:14:53,389
database system that we have in

423
00:14:53,389 --> 00:14:57,379
essentially around avoiding this long

424
00:14:57,379 --> 00:15:00,649
long long problem so let's look at a

425
00:15:00,649 --> 00:15:03,470
high level diagram of what a disscourn a

426
00:15:03,470 --> 00:15:04,639
database system looks like from the

427
00:15:04,639 --> 00:15:05,989
perspective that we carry out care about

428
00:15:05,989 --> 00:15:08,509
at this point in the semester and then

429
00:15:08,509 --> 00:15:09,740
we'll see how

430
00:15:09,740 --> 00:15:10,940
the rest of lecture how actually to fill

431
00:15:10,940 --> 00:15:14,060
in and and and design these things so

432
00:15:14,060 --> 00:15:15,680
again at the lowest layer we have the

433
00:15:15,680 --> 00:15:18,710
disk and we have our database file or

434
00:15:18,710 --> 00:15:21,830
files it doesn't matter and then we're

435
00:15:21,830 --> 00:15:22,940
going to represent these through

436
00:15:22,940 --> 00:15:25,910
different blocks or pages right a page

437
00:15:25,910 --> 00:15:27,290
is the canonical term you use to

438
00:15:27,290 --> 00:15:29,780
describe this sometimes slip and say

439
00:15:29,780 --> 00:15:31,490
block but at a high little bit mean the

440
00:15:31,490 --> 00:15:34,700
same thing so now a memory we're gonna

441
00:15:34,700 --> 00:15:36,740
have what was called a buffer pool and

442
00:15:36,740 --> 00:15:38,030
this will focus on this and the lecture

443
00:15:38,030 --> 00:15:39,170
next week and this is what you'll be

444
00:15:39,170 --> 00:15:40,370
implementing in the in the first

445
00:15:40,370 --> 00:15:43,580
assignment the first project so there's

446
00:15:43,580 --> 00:15:45,230
some higher-level layer in the system

447
00:15:45,230 --> 00:15:46,910
and execution engine a query engine we

448
00:15:46,910 --> 00:15:48,440
don't care what it is but it's gonna

449
00:15:48,440 --> 00:15:50,240
make requests to our buffer pool and say

450
00:15:50,240 --> 00:15:52,970
hey I want to read page 2 page 2 is not

451
00:15:52,970 --> 00:15:54,230
in memory so we got to go look in the

452
00:15:54,230 --> 00:15:56,270
page directory on disk and say here's

453
00:15:56,270 --> 00:15:57,650
the list of the pages that I have here's

454
00:15:57,650 --> 00:15:59,450
where to find them so I'd now I can go

455
00:15:59,450 --> 00:16:01,160
find where page 2 is I bring it into

456
00:16:01,160 --> 00:16:04,670
memory and now I hand off to my to my

457
00:16:04,670 --> 00:16:06,320
excuse me engine here's the pointer to

458
00:16:06,320 --> 00:16:08,480
page 2 in memory and then it can

459
00:16:08,480 --> 00:16:10,070
interpret it do whatever at once we

460
00:16:10,070 --> 00:16:12,320
don't care alright so this is what we're

461
00:16:12,320 --> 00:16:13,730
focusing on here as for the next three

462
00:16:13,730 --> 00:16:15,320
lectures that was how we actually build

463
00:16:15,320 --> 00:16:19,910
this part here all right so today and

464
00:16:19,910 --> 00:16:21,440
next week we'll we'll do discuss what

465
00:16:21,440 --> 00:16:23,930
the data is files on disk next week will

466
00:16:23,930 --> 00:16:25,670
be the buffer pool and then later and so

467
00:16:25,670 --> 00:16:26,660
forth we'll talk about how we actually

468
00:16:26,660 --> 00:16:31,580
represent the directory ok so what does

469
00:16:31,580 --> 00:16:33,970
this look like

470
00:16:35,230 --> 00:16:37,089
you take an operating system course what

471
00:16:37,089 --> 00:16:38,829
does it sound like I'm trying to make it

472
00:16:38,829 --> 00:16:40,360
appear that I have more memory than I

473
00:16:40,360 --> 00:16:43,839
actually do virtual memory exactly so

474
00:16:43,839 --> 00:16:44,800
now I may be thinking all right I've

475
00:16:44,800 --> 00:16:47,680
taken OS course here why why do I want

476
00:16:47,680 --> 00:16:49,180
to have my databases manage memory like

477
00:16:49,180 --> 00:16:50,350
this it seems like a big waste of time

478
00:16:50,350 --> 00:16:52,829
and they OS can already do this right

479
00:16:52,829 --> 00:16:56,589
well it it's not a good idea here's what

480
00:16:56,589 --> 00:16:59,860
so in an operating system parlance we

481
00:16:59,860 --> 00:17:01,209
would call this memory map files or

482
00:17:01,209 --> 00:17:04,780
there's a syscall called em map in POSIX

483
00:17:04,780 --> 00:17:06,400
and essentially what this does is it

484
00:17:06,400 --> 00:17:08,470
takes a file on disk and you tell the

485
00:17:08,470 --> 00:17:10,329
operating system map the files pages

486
00:17:10,329 --> 00:17:12,669
into the address space for my process

487
00:17:12,669 --> 00:17:15,640
and now I can read and write to those

488
00:17:15,640 --> 00:17:18,609
there's those memory locations and it's

489
00:17:18,609 --> 00:17:20,500
not memory the OS brings it in I can I

490
00:17:20,500 --> 00:17:22,599
can write to it and then eventually if I

491
00:17:22,599 --> 00:17:23,949
can tell it'll Esther to write it out

492
00:17:23,949 --> 00:17:25,540
for me I can do an N Sync and write it

493
00:17:25,540 --> 00:17:27,849
up back out the disk so we're

494
00:17:27,849 --> 00:17:29,320
essentially giving up control of the

495
00:17:29,320 --> 00:17:30,880
movement of memory back and forth of

496
00:17:30,880 --> 00:17:32,200
data back and forth we disk of memory

497
00:17:32,200 --> 00:17:33,820
and letting the operating system manage

498
00:17:33,820 --> 00:17:39,250
this for us right so again at a high

499
00:17:39,250 --> 00:17:40,600
level it looks like this we have we have

500
00:17:40,600 --> 00:17:43,000
a bunch of pages on disk file and then

501
00:17:43,000 --> 00:17:44,710
in memory the OS has its virtual memory

502
00:17:44,710 --> 00:17:46,750
page table and we have physical memory

503
00:17:46,750 --> 00:17:48,400
so what happens is the application says

504
00:17:48,400 --> 00:17:50,710
hey I want to read page 1 it looks in

505
00:17:50,710 --> 00:17:52,150
the virtual memory we get it we get a

506
00:17:52,150 --> 00:17:53,590
page vault and say this thing's not

507
00:17:53,590 --> 00:17:55,480
backed by physical memory it's not it's

508
00:17:55,480 --> 00:17:58,179
still out on disk we go fetch it back it

509
00:17:58,179 --> 00:17:59,860
into a physical memory page and then

510
00:17:59,860 --> 00:18:01,390
update our page table to now point to

511
00:18:01,390 --> 00:18:04,480
that memory location so if I come along

512
00:18:04,480 --> 00:18:06,070
and I want to read page 3 I go through

513
00:18:06,070 --> 00:18:08,020
the same process I fetch it into memory

514
00:18:08,020 --> 00:18:10,179
and then the application can do whatever

515
00:18:10,179 --> 00:18:13,330
once but now let's say that I read page

516
00:18:13,330 --> 00:18:17,190
2 what's the problem

517
00:18:17,690 --> 00:18:19,309
there's no there's no free physical

518
00:18:19,309 --> 00:18:21,769
memory page to put the particulars put

519
00:18:21,769 --> 00:18:24,230
this page in so I need to make a

520
00:18:24,230 --> 00:18:25,759
decision of which of these pages to

521
00:18:25,759 --> 00:18:28,340
remove and while I'm doing this

522
00:18:28,340 --> 00:18:30,230
eventually have to stall the database

523
00:18:30,230 --> 00:18:32,090
system install my thread that requested

524
00:18:32,090 --> 00:18:34,850
this page because now the the the disk

525
00:18:34,850 --> 00:18:36,710
the you know the the disk scheduler for

526
00:18:36,710 --> 00:18:37,759
the operating system is gonna go out to

527
00:18:37,759 --> 00:18:39,230
pay the disk fetch it and bring into

528
00:18:39,230 --> 00:18:43,159
memory so you there's tricks there's

529
00:18:43,159 --> 00:18:44,870
ways to figure out from the application

530
00:18:44,870 --> 00:18:46,370
perspective and might have to read

531
00:18:46,370 --> 00:18:48,019
something that's not in memory so maybe

532
00:18:48,019 --> 00:18:49,519
I could hand it off to another thread so

533
00:18:49,519 --> 00:18:51,049
it stalls and not me because I always

534
00:18:51,049 --> 00:18:52,250
want to try to keep doing useful work

535
00:18:52,250 --> 00:18:55,100
because I want to mitigate the stalls

536
00:18:55,100 --> 00:18:57,860
when I have to go out the disk right but

537
00:18:57,860 --> 00:18:59,600
essentially the operation doesn't know

538
00:18:59,600 --> 00:19:01,009
exactly what what the hell we're doing

539
00:19:01,009 --> 00:19:02,149
doesn't know anything about what the

540
00:19:02,149 --> 00:19:03,230
data system is doing it just sees a

541
00:19:03,230 --> 00:19:04,850
bunch of reads and writes two pages it

542
00:19:04,850 --> 00:19:06,710
doesn't understand any of the high-level

543
00:19:06,710 --> 00:19:08,690
semantics or what a query is what deta

544
00:19:08,690 --> 00:19:12,230
wants to read right so we wanted we want

545
00:19:12,230 --> 00:19:14,600
to by going with virtual memory by going

546
00:19:14,600 --> 00:19:16,370
with memory mapped files we're giving up

547
00:19:16,370 --> 00:19:18,679
controls or giving up knowledge that we

548
00:19:18,679 --> 00:19:20,600
have inside our database system over to

549
00:19:20,600 --> 00:19:22,279
the u.s. that that's blind and doesn't

550
00:19:22,279 --> 00:19:25,549
know anything right so if we're only

551
00:19:25,549 --> 00:19:28,279
reading data there's a bunch of syscalls

552
00:19:28,279 --> 00:19:30,529
we can to mitigate some of these

553
00:19:30,529 --> 00:19:33,230
problems but if we start writing things

554
00:19:33,230 --> 00:19:35,840
then it becomes problematic because now

555
00:19:35,840 --> 00:19:37,490
the OS doesn't know that certain pages

556
00:19:37,490 --> 00:19:38,870
have to be flushed out the disk before

557
00:19:38,870 --> 00:19:40,850
other pages do again what we'll cover

558
00:19:40,850 --> 00:19:42,019
this later when we talk about logging

559
00:19:42,019 --> 00:19:45,710
and concurrency control but the OSS sees

560
00:19:45,710 --> 00:19:47,149
yeah I need to I need to write some data

561
00:19:47,149 --> 00:19:48,620
out means go ahead and write it out it

562
00:19:48,620 --> 00:19:49,759
doesn't know whether that was an okay

563
00:19:49,759 --> 00:19:52,580
thing to do or not so you get around

564
00:19:52,580 --> 00:19:55,340
this by by giving it hints like using em

565
00:19:55,340 --> 00:19:56,419
advised to tell it how you're gonna

566
00:19:56,419 --> 00:19:57,769
access certain pages whether it's read

567
00:19:57,769 --> 00:19:59,509
sequential and random how to prevent

568
00:19:59,509 --> 00:20:02,090
pages from beginning paged out although

569
00:20:02,090 --> 00:20:03,440
you can lock doesn't prevent it from

570
00:20:03,440 --> 00:20:05,720
getting written out which again could to

571
00:20:05,720 --> 00:20:07,429
still be a problem and this is when you

572
00:20:07,429 --> 00:20:11,149
tell it to flush so I would say that

573
00:20:11,149 --> 00:20:12,769
memory map files of virtual memory

574
00:20:12,769 --> 00:20:14,870
sounds like a seductive thing we want to

575
00:20:14,870 --> 00:20:16,730
use in our database system and every

576
00:20:16,730 --> 00:20:17,990
year some student says why why are we

577
00:20:17,990 --> 00:20:19,129
doing all this buffer pool thing why

578
00:20:19,129 --> 00:20:20,480
can't we just let the oh let's do this

579
00:20:20,480 --> 00:20:23,240
for us and trust me you don't want to do

580
00:20:23,240 --> 00:20:25,039
this because it can be you have

581
00:20:25,039 --> 00:20:26,240
performance bottlenecks and you'll have

582
00:20:26,240 --> 00:20:29,269
correctness problems so there's not very

583
00:20:29,269 --> 00:20:31,100
many systems out there that actually use

584
00:20:31,100 --> 00:20:32,190
em

585
00:20:32,190 --> 00:20:33,930
the most famous two are probably Monet

586
00:20:33,930 --> 00:20:36,570
DB and LM DB level DB you ever heard of

587
00:20:36,570 --> 00:20:39,210
that from Google is another one elastic

588
00:20:39,210 --> 00:20:41,730
search is a search engine or the

589
00:20:41,730 --> 00:20:45,150
document store then Raving BB is a JSON

590
00:20:45,150 --> 00:20:49,080
database at Israel so all these guys use

591
00:20:49,080 --> 00:20:51,030
and map but there's a bunch of extra

592
00:20:51,030 --> 00:20:53,520
stuff you have to do to prevent the OS

593
00:20:53,520 --> 00:20:55,140
from doing things that are incorrect or

594
00:20:55,140 --> 00:20:56,250
there's certain limitations or

595
00:20:56,250 --> 00:20:58,290
assumptions you have to make about what

596
00:20:58,290 --> 00:21:01,230
the u.s. is allowed to do there's not

597
00:21:01,230 --> 00:21:03,120
right so this is like I mean there's a

598
00:21:03,120 --> 00:21:05,030
few more but there's not very many so

599
00:21:05,030 --> 00:21:06,930
what's missing here we're missing all

600
00:21:06,930 --> 00:21:08,760
the major database systems perhaps my

601
00:21:08,760 --> 00:21:11,520
sequel Oracle db2 sequel server none of

602
00:21:11,520 --> 00:21:12,960
those guys use em map cuz it's a bad

603
00:21:12,960 --> 00:21:14,100
idea because you're giving up control

604
00:21:14,100 --> 00:21:15,810
and the data student can always do

605
00:21:15,810 --> 00:21:17,790
better then what the operating system

606
00:21:17,790 --> 00:21:20,370
could try to figure out so there's some

607
00:21:20,370 --> 00:21:22,380
systems that still use MF in very

608
00:21:22,380 --> 00:21:24,120
limited cases this is actually out of

609
00:21:24,120 --> 00:21:25,530
date MIT I mean I talked to the guys

610
00:21:25,530 --> 00:21:27,450
last week mem Siegel got rid of MF

611
00:21:27,450 --> 00:21:30,300
entirely sequel Dwight has a special

612
00:21:30,300 --> 00:21:31,560
engine you have to tell I want to use M

613
00:21:31,560 --> 00:21:33,090
map for some you know embedded devices

614
00:21:33,090 --> 00:21:34,500
that's that's what actually what you

615
00:21:34,500 --> 00:21:36,000
want to use but default you don't get

616
00:21:36,000 --> 00:21:38,490
this influx DB only uses this for like

617
00:21:38,490 --> 00:21:40,560
read-only caches but the example I

618
00:21:40,560 --> 00:21:41,760
always like to give it talk about is

619
00:21:41,760 --> 00:21:44,610
MongoDB everyone here has heard of

620
00:21:44,610 --> 00:21:46,260
MongoDB for right that's a famous JSON

621
00:21:46,260 --> 00:21:49,440
database system so when they first

622
00:21:49,440 --> 00:21:51,210
started their their default storage

623
00:21:51,210 --> 00:21:52,830
engine or storage manager was using M

624
00:21:52,830 --> 00:21:54,840
map and there's a bunch of crap they had

625
00:21:54,840 --> 00:21:56,310
to do to make that thing actually work

626
00:21:56,310 --> 00:21:58,440
but it was a it was a super button pimp

627
00:21:58,440 --> 00:22:01,050
was a big bottleneck for them and then

628
00:22:01,050 --> 00:22:03,300
they raised put of money and then the

629
00:22:03,300 --> 00:22:04,800
first thing they did was got rid of em

630
00:22:04,800 --> 00:22:06,330
map and got it you know bought this

631
00:22:06,330 --> 00:22:07,680
thing called wire tire which was a non

632
00:22:07,680 --> 00:22:10,170
mm storage engine so if a map was a good

633
00:22:10,170 --> 00:22:11,640
idea these guys had all the money in the

634
00:22:11,640 --> 00:22:13,020
world had some top engineers they could

635
00:22:13,020 --> 00:22:14,730
have figured it out but it was just it

636
00:22:14,730 --> 00:22:18,540
became untenable so if I die in this

637
00:22:18,540 --> 00:22:20,340
class and you want to have a memorial

638
00:22:20,340 --> 00:22:22,560
something just say Andy hated M map you

639
00:22:22,560 --> 00:22:23,820
can you can even publicly say these

640
00:22:23,820 --> 00:22:25,100
things okay

641
00:22:25,100 --> 00:22:27,210
we're actually working a paper at paper

642
00:22:27,210 --> 00:22:29,520
and they let this year and actually

643
00:22:29,520 --> 00:22:30,840
proving that is a bad idea

644
00:22:30,840 --> 00:22:33,780
all right so the main takeaway I want

645
00:22:33,780 --> 00:22:34,560
you to get from this is that the

646
00:22:34,560 --> 00:22:36,420
database system is oh it can always do

647
00:22:36,420 --> 00:22:38,640
better it always knows exactly what's

648
00:22:38,640 --> 00:22:40,050
what the queries are trying to do it

649
00:22:40,050 --> 00:22:41,700
knows what the workload looks like and

650
00:22:41,700 --> 00:22:43,440
therefore it can make the best decision

651
00:22:43,440 --> 00:22:45,090
the operating system doesn't know any

652
00:22:45,090 --> 00:22:46,590
it just sees a bunch of again reads and

653
00:22:46,590 --> 00:22:49,170
writes read and write calls so some of

654
00:22:49,170 --> 00:22:50,400
the things that we'll talk about maybe

655
00:22:50,400 --> 00:22:52,170
late in the semester that we can do if

656
00:22:52,170 --> 00:22:54,480
we're not using a map is like

657
00:22:54,480 --> 00:22:56,340
prefetching better replacement policies

658
00:22:56,340 --> 00:22:58,590
better scheduling again the OS is sort

659
00:22:58,590 --> 00:23:00,240
of general purpose pickup truck whereas

660
00:23:00,240 --> 00:23:01,650
we can tune our system look like a

661
00:23:01,650 --> 00:23:04,050
Porsche or Ferrari to be exactly what we

662
00:23:04,050 --> 00:23:07,020
want to do for application so another

663
00:23:07,020 --> 00:23:08,130
main takeaway is that the operating

664
00:23:08,130 --> 00:23:09,450
system is not your friend we don't want

665
00:23:09,450 --> 00:23:10,830
to rely on up we want try to avoid it as

666
00:23:10,830 --> 00:23:12,300
much as possible because it's gonna make

667
00:23:12,300 --> 00:23:14,010
decisions that could be hurtful to our

668
00:23:14,010 --> 00:23:15,960
Davis system so it's like a frenemy you

669
00:23:15,960 --> 00:23:17,880
need it to survive but ideally you don't

670
00:23:17,880 --> 00:23:21,030
want to talk to it all right all right

671
00:23:21,030 --> 00:23:22,440
so for database storage this is we're

672
00:23:22,440 --> 00:23:24,390
gonna focus on today so there's two main

673
00:23:24,390 --> 00:23:27,210
problems we have to take care of the

674
00:23:27,210 --> 00:23:28,650
first is hat how we're gonna represent

675
00:23:28,650 --> 00:23:31,560
the data on files on disk and the second

676
00:23:31,560 --> 00:23:34,410
is that how we actually manage the Muta

677
00:23:34,410 --> 00:23:35,940
memory back and forth right between the

678
00:23:35,940 --> 00:23:38,130
disk files and the buffer pool so for

679
00:23:38,130 --> 00:23:39,570
this lecture today we're gonna focus on

680
00:23:39,570 --> 00:23:41,430
this problem next class well stuff up in

681
00:23:41,430 --> 00:23:42,990
this problem and then starting when we

682
00:23:42,990 --> 00:23:44,010
talk about buffer pools on Wednesday

683
00:23:44,010 --> 00:23:45,540
next week we'll focus on the second

684
00:23:45,540 --> 00:23:48,540
problem okay all right so today's

685
00:23:48,540 --> 00:23:49,860
lecture again we're gonna go to that

686
00:23:49,860 --> 00:23:51,570
first question how are we actually gonna

687
00:23:51,570 --> 00:23:54,000
represent the the database on files on

688
00:23:54,000 --> 00:23:56,220
disk so we're first talk about how would

689
00:23:56,220 --> 00:23:59,520
organize the database across a sequence

690
00:23:59,520 --> 00:24:01,470
of pages now let's talk about how we're

691
00:24:01,470 --> 00:24:03,420
actually gonna store the pages inside

692
00:24:03,420 --> 00:24:05,400
those files and then let's talk about

693
00:24:05,400 --> 00:24:06,930
what's actually the what are the tuples

694
00:24:06,930 --> 00:24:09,660
look like inside those pages alright so

695
00:24:09,660 --> 00:24:11,100
we're gonna go sort of at a macro level

696
00:24:11,100 --> 00:24:14,070
and deep you know step down to you know

697
00:24:14,070 --> 00:24:15,810
inside the data that we're actually

698
00:24:15,810 --> 00:24:19,590
storing all right so at the end of the

699
00:24:19,590 --> 00:24:21,540
day the database is just a bunch of

700
00:24:21,540 --> 00:24:24,240
files on disk some system stored the

701
00:24:24,240 --> 00:24:25,680
database has one file like sequel light

702
00:24:25,680 --> 00:24:26,850
does that for the first homework you

703
00:24:26,850 --> 00:24:29,040
download that DB file that's the entire

704
00:24:29,040 --> 00:24:30,180
database and capsulated it in that

705
00:24:30,180 --> 00:24:32,700
single file most other systems however

706
00:24:32,700 --> 00:24:36,030
store things in across multiple files so

707
00:24:36,030 --> 00:24:37,710
here a look at like the the data

708
00:24:37,710 --> 00:24:38,910
directory from I see bone Postgres

709
00:24:38,910 --> 00:24:39,510
you'll see a bunch of different

710
00:24:39,510 --> 00:24:41,580
directories mature files right you do

711
00:24:41,580 --> 00:24:43,500
this because you know databases could be

712
00:24:43,500 --> 00:24:45,360
very large like petabytes and you don't

713
00:24:45,360 --> 00:24:47,160
want to you know you don't want to hit

714
00:24:47,160 --> 00:24:48,870
up the faucet and limitation of a file

715
00:24:48,870 --> 00:24:52,170
into the size of a file so again the OS

716
00:24:52,170 --> 00:24:53,250
doesn't know anything about what's in

717
00:24:53,250 --> 00:24:54,930
these files it's just there's a bunch of

718
00:24:54,930 --> 00:24:56,700
binary data to the operating system

719
00:24:56,700 --> 00:24:58,740
they're not special but

720
00:24:58,740 --> 00:25:00,990
the format for these data files are

721
00:25:00,990 --> 00:25:03,540
typically proprietary or specific to the

722
00:25:03,540 --> 00:25:04,530
database measurement system

723
00:25:04,530 --> 00:25:06,390
so meaning you can't take a sequel Lite

724
00:25:06,390 --> 00:25:08,400
file plop it down inside a directory for

725
00:25:08,400 --> 00:25:10,050
my sequel and I think my sequel is gonna

726
00:25:10,050 --> 00:25:12,210
be able to read it right they're always

727
00:25:12,210 --> 00:25:13,500
they're always specialized to whatever

728
00:25:13,500 --> 00:25:16,620
the software is so these files were

729
00:25:16,620 --> 00:25:17,940
these follows it pretty davis we're

730
00:25:17,940 --> 00:25:19,890
typically just gonna store them on top

731
00:25:19,890 --> 00:25:21,300
of the regular file system that the OS

732
00:25:21,300 --> 00:25:24,990
provides us ext3 ext4 whatever windows

733
00:25:24,990 --> 00:25:27,900
net has now I forget right these are

734
00:25:27,900 --> 00:25:29,370
just and the OS who sees a bunch of

735
00:25:29,370 --> 00:25:31,230
files and we rely on the file system to

736
00:25:31,230 --> 00:25:34,500
provide us with basic readwrite api's in

737
00:25:34,500 --> 00:25:36,750
the 1980's people did try to build

738
00:25:36,750 --> 00:25:38,640
database systems that use custom file

739
00:25:38,640 --> 00:25:41,460
systems on raw storage devices

740
00:25:41,460 --> 00:25:43,320
so like say you plop down a new hard

741
00:25:43,320 --> 00:25:45,630
drive instead of formatting it and you

742
00:25:45,630 --> 00:25:47,730
know setting it up for NTFS or when FS

743
00:25:47,730 --> 00:25:50,309
or xtxt for you say screw all that is

744
00:25:50,309 --> 00:25:51,809
give me the roll storage device and I'll

745
00:25:51,809 --> 00:25:54,240
grant I'll manage what's actually being

746
00:25:54,240 --> 00:25:57,630
stored in it myself some of the

747
00:25:57,630 --> 00:25:58,920
enterprise systems like that like

748
00:25:58,920 --> 00:26:00,330
enterprise meaning like high-end ones

749
00:26:00,330 --> 00:26:02,580
like Oracle db2 and sequel server will

750
00:26:02,580 --> 00:26:04,830
still do this but most of the new

751
00:26:04,830 --> 00:26:06,059
database startups are anything you gave

752
00:26:06,059 --> 00:26:07,530
him that's come out in the last ten

753
00:26:07,530 --> 00:26:10,170
years or 15 years doesn't do this right

754
00:26:10,170 --> 00:26:11,730
because it's the engineering effort to

755
00:26:11,730 --> 00:26:13,559
make your own custom file system for

756
00:26:13,559 --> 00:26:15,360
your database system is not worth it

757
00:26:15,360 --> 00:26:17,670
you get maybe like a 10% improvement but

758
00:26:17,670 --> 00:26:19,080
now you you know you're managing your

759
00:26:19,080 --> 00:26:21,450
own faucet which is a big chaos and it

760
00:26:21,450 --> 00:26:22,530
makes your thing less portable cuz now

761
00:26:22,530 --> 00:26:24,570
you can't easily run it on when Amazon

762
00:26:24,570 --> 00:26:28,830
and other other Harvard vendors so what

763
00:26:28,830 --> 00:26:30,929
we're building essentially is now again

764
00:26:30,929 --> 00:26:32,040
what is called a Storage Manager

765
00:26:32,040 --> 00:26:33,720
sometimes also called the storage engine

766
00:26:33,720 --> 00:26:35,700
and then this is the piece of the

767
00:26:35,700 --> 00:26:36,840
software at the component in our

768
00:26:36,840 --> 00:26:39,770
database system that is responsible for

769
00:26:39,770 --> 00:26:42,630
maintaining our database files on on

770
00:26:42,630 --> 00:26:47,340
disk now we could do reads and writes

771
00:26:47,340 --> 00:26:49,710
and let the OS schedule things some of

772
00:26:49,710 --> 00:26:51,179
the more high-end database systems will

773
00:26:51,179 --> 00:26:54,059
actually have a shim layer right right

774
00:26:54,059 --> 00:26:55,710
above the file system that does allows

775
00:26:55,710 --> 00:26:57,210
the the davison to do some disk

776
00:26:57,210 --> 00:27:00,090
scheduling you do this set like I know I

777
00:27:00,090 --> 00:27:01,410
have a bunch of threads writing to

778
00:27:01,410 --> 00:27:03,360
blocks that are close to each other

779
00:27:03,360 --> 00:27:05,100
I can maybe combine them together and do

780
00:27:05,100 --> 00:27:07,290
a single write request write the OS can

781
00:27:07,290 --> 00:27:08,610
kind of do these things but again it

782
00:27:08,610 --> 00:27:10,740
doesn't know exactly what's above this

783
00:27:10,740 --> 00:27:12,270
doesn't know what the semantics of the

784
00:27:12,270 --> 00:27:15,150
above it motor systems don't do this and

785
00:27:15,150 --> 00:27:16,710
then for the project we'll be working on

786
00:27:16,710 --> 00:27:18,990
here we don't do this it's typically for

787
00:27:18,990 --> 00:27:32,610
the higher ones yes yes a question is I

788
00:27:32,610 --> 00:27:35,280
said that most databases and split up

789
00:27:35,280 --> 00:27:38,220
the file the database files into

790
00:27:38,220 --> 00:27:39,540
multiple files because you don't hit the

791
00:27:39,540 --> 00:27:41,280
the file size limit of the operating

792
00:27:41,280 --> 00:27:43,140
system is there any optimization for

793
00:27:43,140 --> 00:27:50,970
putting things in memory yes just a file

794
00:27:50,970 --> 00:27:53,190
Oh Russians just the file have a limit

795
00:27:53,190 --> 00:27:54,690
for the amount of the size it can be in

796
00:27:54,690 --> 00:27:59,460
memory with virtual memory no when we

797
00:27:59,460 --> 00:28:01,950
talk to us to whatever the the swap size

798
00:28:01,950 --> 00:28:04,350
is what the OS could let you store but

799
00:28:04,350 --> 00:28:06,390
if it's it's essentially limited the

800
00:28:06,390 --> 00:28:09,800
physical memory that's available to you

801
00:28:15,170 --> 00:28:17,640
her question is would be better to have

802
00:28:17,640 --> 00:28:19,590
a single file because then you get the

803
00:28:19,590 --> 00:28:21,330
over you get rid of the overhead of

804
00:28:21,330 --> 00:28:24,630
having multiple files wouldn't you like

805
00:28:24,630 --> 00:28:26,850
the overhead like the inode that you're

806
00:28:26,850 --> 00:28:29,070
that you have to find it go open a file

807
00:28:29,070 --> 00:28:40,980
or what okay so you're talking like the

808
00:28:40,980 --> 00:28:44,460
metadata there save it is if I have one

809
00:28:44,460 --> 00:28:46,050
file then I have one file name and I

810
00:28:46,050 --> 00:28:48,000
have one inode in my file system that

811
00:28:48,000 --> 00:28:50,130
points to it if I have multiple files

812
00:28:50,130 --> 00:28:51,750
that I have multiple inode entries or

813
00:28:51,750 --> 00:28:53,160
and each one has their own file name

814
00:28:53,160 --> 00:28:54,030
much a meditator

815
00:28:54,030 --> 00:28:56,250
you know referencing it but like that's

816
00:28:56,250 --> 00:28:59,190
what maybe a kilobyte of metadata it's

817
00:28:59,190 --> 00:29:00,630
nothing right if your database is one

818
00:29:00,630 --> 00:29:02,430
petabyte who cares that you have a bunch

819
00:29:02,430 --> 00:29:06,660
of file names right I think really large

820
00:29:06,660 --> 00:29:07,800
scales it doesn't make a difference

821
00:29:07,800 --> 00:29:12,990
right I I think now for like for modern

822
00:29:12,990 --> 00:29:14,190
file systems it's not really an issue

823
00:29:14,190 --> 00:29:16,080
anymore like you can have like exabyte

824
00:29:16,080 --> 00:29:19,110
you know single files are exabytes but

825
00:29:19,110 --> 00:29:20,910
thinking like in the 90s or early 2000s

826
00:29:20,910 --> 00:29:22,380
when like you were running like fat32

827
00:29:22,380 --> 00:29:23,900
you can only have a 4 gigabyte file

828
00:29:23,900 --> 00:29:25,020
right

829
00:29:25,020 --> 00:29:27,540
that's back in the days it mattered more

830
00:29:27,540 --> 00:29:29,340
not so much now but even then the

831
00:29:29,340 --> 00:29:30,480
metadata doesn't matter

832
00:29:30,480 --> 00:29:39,000
yes his statement is doesn't this limit

833
00:29:39,000 --> 00:29:40,410
the number of files that you can have

834
00:29:40,410 --> 00:29:42,120
open is usually open file handles on

835
00:29:42,120 --> 00:29:43,890
them are things you can create and

836
00:29:43,890 --> 00:29:45,240
therefore you have to have permissions

837
00:29:45,240 --> 00:29:46,860
to do this that's really yes and so if

838
00:29:46,860 --> 00:29:48,270
you go look at like the tuning guides or

839
00:29:48,270 --> 00:29:50,100
setup guides for a bunch of different

840
00:29:50,100 --> 00:29:51,810
data systems they'll talk about like

841
00:29:51,810 --> 00:29:53,640
tune this kernel parameter delight you

842
00:29:53,640 --> 00:29:54,870
have a bunch of you know this number I

843
00:29:54,870 --> 00:29:56,430
notes or file handles over absolutely

844
00:29:56,430 --> 00:30:02,490
yes okay awesome all right again so

845
00:30:02,490 --> 00:30:03,480
we're trying to build a storage manager

846
00:30:03,480 --> 00:30:05,010
and the storage manager is responsible

847
00:30:05,010 --> 00:30:07,440
for maintaining these files on disk and

848
00:30:07,440 --> 00:30:09,120
whether it's one file or multiple files

849
00:30:09,120 --> 00:30:12,120
it doesn't matter so now within these

850
00:30:12,120 --> 00:30:15,180
files we're going to organize them as a

851
00:30:15,180 --> 00:30:18,600
collection of pages and so our Storage

852
00:30:18,600 --> 00:30:19,770
Manager is going to keep track of all

853
00:30:19,770 --> 00:30:20,970
the reads and writes we're gonna do to

854
00:30:20,970 --> 00:30:23,160
these pages as if you track a wood

855
00:30:23,160 --> 00:30:24,720
available space what space is available

856
00:30:24,720 --> 00:30:28,110
to us to store new data in our pages so

857
00:30:28,110 --> 00:30:30,330
a page is essentially just a fixed size

858
00:30:30,330 --> 00:30:33,510
chunk or block of data that were just

859
00:30:33,510 --> 00:30:35,580
we're going to organize our file and you

860
00:30:35,580 --> 00:30:38,640
know into these chunks so a page can

861
00:30:38,640 --> 00:30:41,190
contain anything right it contained the

862
00:30:41,190 --> 00:30:43,020
actual tuples the data database itself

863
00:30:43,020 --> 00:30:45,660
contain metadata indexes log records

864
00:30:45,660 --> 00:30:47,190
from the storage management perspective

865
00:30:47,190 --> 00:30:49,170
it doesn't really matter right but we

866
00:30:49,170 --> 00:30:50,610
always have to store things within a

867
00:30:50,610 --> 00:30:54,000
single page so now some database systems

868
00:30:54,000 --> 00:30:58,560
will require you that to have the the

869
00:30:58,560 --> 00:31:00,720
page be self-contained and what I mean

870
00:31:00,720 --> 00:31:02,370
by that is all the information you need

871
00:31:02,370 --> 00:31:04,530
to know how to interpret and comprehend

872
00:31:04,530 --> 00:31:07,170
the contents of a page have to be stored

873
00:31:07,170 --> 00:31:09,750
within the page itself so let me give an

874
00:31:09,750 --> 00:31:11,580
example let's say that I have a table

875
00:31:11,580 --> 00:31:14,340
and I have the table has 10 columns they

876
00:31:14,340 --> 00:31:15,630
have different types but I call create

877
00:31:15,630 --> 00:31:16,830
table and I create the table of

878
00:31:16,830 --> 00:31:19,290
different attributes so I could have the

879
00:31:19,290 --> 00:31:21,240
metadata about what's in that table

880
00:31:21,240 --> 00:31:23,820
stored in one page and then all the

881
00:31:23,820 --> 00:31:25,770
tuples or that pay for that that table

882
00:31:25,770 --> 00:31:28,260
stored in another page so the problem is

883
00:31:28,260 --> 00:31:30,930
now if I have a disk failure like my my

884
00:31:30,930 --> 00:31:32,670
data center catches on fire my disks

885
00:31:32,670 --> 00:31:34,710
melt and I lose that one page that tells

886
00:31:34,710 --> 00:31:37,170
me what what the layout of the the

887
00:31:37,170 --> 00:31:38,429
schema is

888
00:31:38,429 --> 00:31:40,110
now I don't know how to easily interpret

889
00:31:40,110 --> 00:31:41,940
what the contents are of my of my tubule

890
00:31:41,940 --> 00:31:44,519
pages and so some systems like Oracle

891
00:31:44,519 --> 00:31:46,320
for example require all the metadata

892
00:31:46,320 --> 00:31:47,759
about how to say here's what's in that

893
00:31:47,759 --> 00:31:49,950
page has to be within the page itself so

894
00:31:49,950 --> 00:31:52,019
that way if you lose any other page it

895
00:31:52,019 --> 00:31:53,519
doesn't affect you know you lose one

896
00:31:53,519 --> 00:31:54,799
page it doesn't affect any other pages

897
00:31:54,799 --> 00:31:57,269
you think it's a bit overhead to this

898
00:31:57,269 --> 00:31:59,399
that seems crazy well they do it for

899
00:31:59,399 --> 00:32:02,009
disaster recovery again so now again the

900
00:32:02,009 --> 00:32:03,509
machine catches on fire and you lose a

901
00:32:03,509 --> 00:32:06,450
bunch of pages you can you you literally

902
00:32:06,450 --> 00:32:07,559
open up a hex editor and try to

903
00:32:07,559 --> 00:32:09,269
reconstruct what the database was by

904
00:32:09,269 --> 00:32:11,129
looking at pat one page at a time and

905
00:32:11,129 --> 00:32:12,509
all the metadata you need about what's

906
00:32:12,509 --> 00:32:15,470
in that page is stored within itself

907
00:32:15,470 --> 00:32:19,019
alright so all the things that's

908
00:32:19,019 --> 00:32:20,190
important understand is that we're not

909
00:32:20,190 --> 00:32:21,749
going to mix different types types of

910
00:32:21,749 --> 00:32:24,720
data within a page there's some research

911
00:32:24,720 --> 00:32:26,309
systems that do this we could have you

912
00:32:26,309 --> 00:32:27,809
know one page have tuple data and log

913
00:32:27,809 --> 00:32:29,789
record data for our purposes here and

914
00:32:29,789 --> 00:32:31,379
most systems they don't do this it's

915
00:32:31,379 --> 00:32:32,610
like here's a page and only source

916
00:32:32,610 --> 00:32:34,320
tuples here's a page that only stores

917
00:32:34,320 --> 00:32:37,799
index information so now each page is

918
00:32:37,799 --> 00:32:39,840
going to be given a unique internal

919
00:32:39,840 --> 00:32:41,610
identifier that the database system is

920
00:32:41,610 --> 00:32:44,129
gonna generate for us a page ID right

921
00:32:44,129 --> 00:32:46,379
and we're gonna have then now have an

922
00:32:46,379 --> 00:32:47,820
indirection layer and this is would be a

923
00:32:47,820 --> 00:32:48,899
reoccurring theme when we talk about

924
00:32:48,899 --> 00:32:50,730
storage we have an indirection layer

925
00:32:50,730 --> 00:32:52,980
that's gonna allow us to map a page ID

926
00:32:52,980 --> 00:32:55,889
to some location in a file at some all

927
00:32:55,889 --> 00:32:59,220
set right and we want to do this because

928
00:32:59,220 --> 00:33:00,809
now underneath the covers we can start

929
00:33:00,809 --> 00:33:02,820
moving pages around you know if we start

930
00:33:02,820 --> 00:33:04,919
compacting the disk or or set it but

931
00:33:04,919 --> 00:33:06,659
another disk and it doesn't change our

932
00:33:06,659 --> 00:33:08,700
page ID cuz we have this this page

933
00:33:08,700 --> 00:33:10,710
directory say you want page 1 2 3 here's

934
00:33:10,710 --> 00:33:13,860
where to go find it so there's a bunch

935
00:33:13,860 --> 00:33:15,720
of page page concepts we need to talk

936
00:33:15,720 --> 00:33:18,570
about to put it in the context of how

937
00:33:18,570 --> 00:33:21,419
real computers work so at the lowest

938
00:33:21,419 --> 00:33:22,710
level we have what's called a hardware

939
00:33:22,710 --> 00:33:25,830
page this is this is the page API or

940
00:33:25,830 --> 00:33:27,960
page access level you get from the

941
00:33:27,960 --> 00:33:30,059
actual storage device itself I just know

942
00:33:30,059 --> 00:33:31,799
what the SSD or spinning disk hard drive

943
00:33:31,799 --> 00:33:34,320
exposes this is typically four kilobytes

944
00:33:34,320 --> 00:33:36,570
then above that you have an operating

945
00:33:36,570 --> 00:33:39,299
system page and again that's as you as

946
00:33:39,299 --> 00:33:40,440
you take things out of the storage

947
00:33:40,440 --> 00:33:42,330
device and put it into memory right they

948
00:33:42,330 --> 00:33:44,009
represent that as an internal page as

949
00:33:44,009 --> 00:33:45,990
well and that's typically usually four

950
00:33:45,990 --> 00:33:48,149
kilobytes by default in Linux and

951
00:33:48,149 --> 00:33:50,279
Windows there's things like huge pages

952
00:33:50,279 --> 00:33:52,889
where you turn it you can take a one Gil

953
00:33:52,889 --> 00:33:54,570
one gigabyte page to be broken up to

954
00:33:54,570 --> 00:33:57,480
maunsell four kilobyte horror pages but

955
00:33:57,480 --> 00:33:59,820
for our purposes we don't care about the

956
00:33:59,820 --> 00:34:01,019
thing we care about at the database page

957
00:34:01,019 --> 00:34:03,690
here right and this is gonna bury

958
00:34:03,690 --> 00:34:06,720
between different systems so at the low

959
00:34:06,720 --> 00:34:09,270
end at 512 bytes that's like something

960
00:34:09,270 --> 00:34:10,440
like Seigle light like an embedded

961
00:34:10,440 --> 00:34:12,359
system but then at the high end you'll

962
00:34:12,359 --> 00:34:13,949
have like 16 ele bytes that could be

963
00:34:13,949 --> 00:34:16,469
like my sequel so different database

964
00:34:16,469 --> 00:34:17,790
systems do different things and there's

965
00:34:17,790 --> 00:34:19,369
different trade-offs for all of these

966
00:34:19,369 --> 00:34:22,589
all right the main thing we're going to

967
00:34:22,589 --> 00:34:24,899
care about though is that the harbor

968
00:34:24,899 --> 00:34:28,230
page is is the sort of the lowest level

969
00:34:28,230 --> 00:34:30,060
that we do atomic writes to the storage

970
00:34:30,060 --> 00:34:33,060
device and typically 4 kilobytes so what

971
00:34:33,060 --> 00:34:34,649
I mean my bad is say I need to modify a

972
00:34:34,649 --> 00:34:37,020
bunch of data the harbor can only

973
00:34:37,020 --> 00:34:39,418
guarantee that if I do a write and flush

974
00:34:39,418 --> 00:34:41,730
to the disk if it can only guarantee

975
00:34:41,730 --> 00:34:45,149
that at 4 kilobyte of time it's gonna be

976
00:34:45,149 --> 00:34:48,869
atomic so I'm excited I mean my bad so

977
00:34:48,869 --> 00:34:50,668
like if I say I need to write 16

978
00:34:50,668 --> 00:34:53,668
kilobytes I could try to write the I say

979
00:34:53,668 --> 00:34:55,469
I tell the disk hey write 16 kilobytes

980
00:34:55,469 --> 00:34:58,980
for me it might crash before you know it

981
00:34:58,980 --> 00:35:01,140
writes the first 8 kilobytes then it

982
00:35:01,140 --> 00:35:02,670
crashes before writing the next 8

983
00:35:02,670 --> 00:35:04,470
kilobytes and then you come back and now

984
00:35:04,470 --> 00:35:05,819
you have a torn right you only see the

985
00:35:05,819 --> 00:35:06,900
first half and up the second half

986
00:35:06,900 --> 00:35:09,690
because the harbor can only guarantee 4

987
00:35:09,690 --> 00:35:14,099
kilobytes at a time all right this will

988
00:35:14,099 --> 00:35:15,540
come up this we'll talk about this more

989
00:35:15,540 --> 00:35:16,829
later when we talk about logging and

990
00:35:16,829 --> 00:35:18,660
commercial but this is something we need

991
00:35:18,660 --> 00:35:21,119
we need need to be mindful of and again

992
00:35:21,119 --> 00:35:22,260
there's different systems do different

993
00:35:22,260 --> 00:35:24,480
things the high end systems like an

994
00:35:24,480 --> 00:35:27,240
Oracle sequel server and db2 you can

995
00:35:27,240 --> 00:35:28,500
actually tune it so you say I want to

996
00:35:28,500 --> 00:35:29,579
start things there's 4 kilobytes 8

997
00:35:29,579 --> 00:35:31,440
kilobytes or 16 kilobytes II you can

998
00:35:31,440 --> 00:35:33,660
even vary say 4 index pages store much

999
00:35:33,660 --> 00:35:35,280
larger page sizes and then data page is

1000
00:35:35,280 --> 00:35:37,740
sort of smaller you can go crazy and do

1001
00:35:37,740 --> 00:35:40,410
much different things all right so now

1002
00:35:40,410 --> 00:35:41,849
we want to talk about how we're gonna

1003
00:35:41,849 --> 00:35:44,160
represent the the page storage

1004
00:35:44,160 --> 00:35:46,619
architecture so again there's different

1005
00:35:46,619 --> 00:35:48,060
ways to do this there's different

1006
00:35:48,060 --> 00:35:50,670
trade-offs for this the most common one

1007
00:35:50,670 --> 00:35:52,500
it's going to be the heap file

1008
00:35:52,500 --> 00:35:54,810
organization so we'll focus on that but

1009
00:35:54,810 --> 00:35:57,000
the thing to understand is that at this

1010
00:35:57,000 --> 00:35:59,040
point at this lowest level in the

1011
00:35:59,040 --> 00:36:00,359
storage manager we don't care about

1012
00:36:00,359 --> 00:36:01,619
what's actually in our pages we don't

1013
00:36:01,619 --> 00:36:03,240
care whether this indexes data or tuple

1014
00:36:03,240 --> 00:36:05,790
data we don't care USS for a page we'll

1015
00:36:05,790 --> 00:36:06,010
get

1016
00:36:06,010 --> 00:36:08,560
that page right or yes delete a page

1017
00:36:08,560 --> 00:36:12,490
will delete it so database heap file is

1018
00:36:12,490 --> 00:36:16,120
a unordered collection of pages where

1019
00:36:16,120 --> 00:36:18,430
the tuples of the data can be stored in

1020
00:36:18,430 --> 00:36:22,690
random order so again the relational

1021
00:36:22,690 --> 00:36:25,120
model doesn't have any orderings if I

1022
00:36:25,120 --> 00:36:27,640
insert tuples one by one

1023
00:36:27,640 --> 00:36:30,040
I'm not guaranteed that they're gonna be

1024
00:36:30,040 --> 00:36:33,370
stored that way on disk because it

1025
00:36:33,370 --> 00:36:34,660
doesn't matter because I write sequel

1026
00:36:34,660 --> 00:36:36,160
queries and that have no notion of

1027
00:36:36,160 --> 00:36:39,580
ordering so the API we need to have

1028
00:36:39,580 --> 00:36:41,680
again is be able to read and write and

1029
00:36:41,680 --> 00:36:44,170
access pages at a time as well as being

1030
00:36:44,170 --> 00:36:45,790
able to iterate over every single page

1031
00:36:45,790 --> 00:36:47,620
that we have in case we need to do a

1032
00:36:47,620 --> 00:36:49,950
sequential scan across the entire table

1033
00:36:49,950 --> 00:36:51,940
we'll have some additional metadata to

1034
00:36:51,940 --> 00:36:54,040
keep track of what pages we have which

1035
00:36:54,040 --> 00:36:55,330
ones have free space so that if we need

1036
00:36:55,330 --> 00:36:57,190
to insert new data we know where to find

1037
00:36:57,190 --> 00:36:59,490
a page to go ahead and do that right and

1038
00:36:59,490 --> 00:37:01,330
internally we can represent this heat

1039
00:37:01,330 --> 00:37:03,760
ball in a bunch of different ways again

1040
00:37:03,760 --> 00:37:06,880
at the lowest lowest level we can

1041
00:37:06,880 --> 00:37:08,560
organize these and pages and then within

1042
00:37:08,560 --> 00:37:10,360
these pages we can represent them with

1043
00:37:10,360 --> 00:37:12,700
different data structures so let's first

1044
00:37:12,700 --> 00:37:14,140
talk about doing linked lists because

1045
00:37:14,140 --> 00:37:15,340
that's sort of the dumb way to do this

1046
00:37:15,340 --> 00:37:16,540
or nobody actually does this but it

1047
00:37:16,540 --> 00:37:18,430
exists and then we'll see the page

1048
00:37:18,430 --> 00:37:20,940
directory way which is a better approach

1049
00:37:20,940 --> 00:37:23,590
so the way we're gonna do this again the

1050
00:37:23,590 --> 00:37:25,300
goal is we what we're trying to do here

1051
00:37:25,300 --> 00:37:27,280
is we're trying to figure out within my

1052
00:37:27,280 --> 00:37:29,920
file I have a bunch of pages what pages

1053
00:37:29,920 --> 00:37:32,020
you know what where those pages exist

1054
00:37:32,020 --> 00:37:33,430
and what kind of you know whether they

1055
00:37:33,430 --> 00:37:34,960
have data or not all the way they have

1056
00:37:34,960 --> 00:37:37,480
free space for me to store stuff so in

1057
00:37:37,480 --> 00:37:40,750
the header of this this heap father said

1058
00:37:40,750 --> 00:37:42,610
that for this linked list we're just

1059
00:37:42,610 --> 00:37:44,380
gonna have two pointers we have one

1060
00:37:44,380 --> 00:37:45,790
pointer that says here's the list of the

1061
00:37:45,790 --> 00:37:47,380
free pages that I have in my file and

1062
00:37:47,380 --> 00:37:49,330
here's a list of the the pages that

1063
00:37:49,330 --> 00:37:51,540
actually have completely for occupied

1064
00:37:51,540 --> 00:37:53,710
right and then again this is just a

1065
00:37:53,710 --> 00:37:55,720
linked list so it doesn't matter where

1066
00:37:55,720 --> 00:37:57,010
these pages are stored doesn't matter

1067
00:37:57,010 --> 00:37:58,930
whether contiguous or not I just

1068
00:37:58,930 --> 00:38:00,430
I now have just pointers and say hey

1069
00:38:00,430 --> 00:38:02,290
here's you know here's the data that you

1070
00:38:02,290 --> 00:38:04,120
know here's here's the first page my

1071
00:38:04,120 --> 00:38:05,590
linked list that where they're occupied

1072
00:38:05,590 --> 00:38:07,690
and here's a pointer to the next one so

1073
00:38:07,690 --> 00:38:09,490
vanayya if I want to say find me a page

1074
00:38:09,490 --> 00:38:11,440
a free page like a store stuff I can

1075
00:38:11,440 --> 00:38:13,360
follow the free page list look in here

1076
00:38:13,360 --> 00:38:14,980
and you know in traverse long until I

1077
00:38:14,980 --> 00:38:16,360
find something that has enough space for

1078
00:38:16,360 --> 00:38:18,109
what I want to store

1079
00:38:18,109 --> 00:38:20,150
and because we need to go possibly an

1080
00:38:20,150 --> 00:38:21,529
iterate in reverse order we need

1081
00:38:21,529 --> 00:38:26,539
pointers on the way back as well yes the

1082
00:38:26,539 --> 00:38:27,619
question is why is the heap file

1083
00:38:27,619 --> 00:38:30,109
unordered thinking at a high level like

1084
00:38:30,109 --> 00:38:34,940
the the the data we're storing does not

1085
00:38:34,940 --> 00:38:37,299
need to be ordered as we insert it right

1086
00:38:37,299 --> 00:38:40,730
so if I insert like three tuples I could

1087
00:38:40,730 --> 00:38:43,099
insert I could in my page layout the

1088
00:38:43,099 --> 00:38:44,809
actual inside the pages I could have

1089
00:38:44,809 --> 00:38:47,119
tuple three tuple two two and one I'm

1090
00:38:47,119 --> 00:38:48,710
not required to put them in order that

1091
00:38:48,710 --> 00:38:56,390
are given right so this question if you

1092
00:38:56,390 --> 00:38:58,430
had to look for a particular page with

1093
00:38:58,430 --> 00:39:00,400
these link list things I have to reverse

1094
00:39:00,400 --> 00:39:02,299
potentially entire link list if I might

1095
00:39:02,299 --> 00:39:05,900
one absolutely yes this sucks this is a

1096
00:39:05,900 --> 00:39:11,450
bad idea and saintly yes his question is

1097
00:39:11,450 --> 00:39:12,680
if it's ordered you can always search

1098
00:39:12,680 --> 00:39:14,989
faster right so there's different rate

1099
00:39:14,989 --> 00:39:18,829
offs so I have no metadata to say where

1100
00:39:18,829 --> 00:39:21,499
I have free pages so I need to insert

1101
00:39:21,499 --> 00:39:23,779
something now where am I going to insert

1102
00:39:23,779 --> 00:39:25,099
it now I've been since you have to do a

1103
00:39:25,099 --> 00:39:26,900
sequential scan and look at every single

1104
00:39:26,900 --> 00:39:28,190
page until I find one that has free

1105
00:39:28,190 --> 00:39:31,339
space or in this approach here I'm not

1106
00:39:31,339 --> 00:39:32,630
saying this I'm not saying this right

1107
00:39:32,630 --> 00:39:34,099
I'm not saying at a hile this is the

1108
00:39:34,099 --> 00:39:34,940
right way to do it I'm saying this is

1109
00:39:34,940 --> 00:39:37,190
how this works if I need if I have this

1110
00:39:37,190 --> 00:39:38,989
one here then I get this go follow this

1111
00:39:38,989 --> 00:39:40,910
pointer to find the first free page and

1112
00:39:40,910 --> 00:39:42,049
see whether it has enough space for what

1113
00:39:42,049 --> 00:39:44,779
I want to store it's a trade-off right I

1114
00:39:44,779 --> 00:39:47,329
can either go do you know almost binary

1115
00:39:47,329 --> 00:39:48,589
search to find exactly the page that I

1116
00:39:48,589 --> 00:39:51,980
want or I can just do I can do this

1117
00:39:51,980 --> 00:39:57,559
linked list statements you can maintain

1118
00:39:57,559 --> 00:39:59,890
ordered sets of it free pages and and

1119
00:39:59,890 --> 00:40:12,950
and fill pages look he's ever usually

1120
00:40:12,950 --> 00:40:14,930
linked lists use a treat a linked list

1121
00:40:14,930 --> 00:40:17,509
can still be ordered right so you could

1122
00:40:17,509 --> 00:40:18,680
say all right say I delete all the

1123
00:40:18,680 --> 00:40:20,029
tuples from this page and it's been its

1124
00:40:20,029 --> 00:40:22,279
page two and this is page one this is

1125
00:40:22,279 --> 00:40:24,230
page three so I could insert it in

1126
00:40:24,230 --> 00:40:27,369
between these two guys sure

1127
00:40:28,140 --> 00:40:36,570
order like we make two different or one

1128
00:40:36,570 --> 00:40:42,630
on the page ideally but again I think

1129
00:40:42,630 --> 00:40:45,660
your your the page ID is just like it

1130
00:40:45,660 --> 00:40:48,840
all set in it right it's not there's no

1131
00:40:48,840 --> 00:40:50,310
sort of a logical thing built in top of

1132
00:40:50,310 --> 00:40:53,820
the heap file look let's link to wheat

1133
00:40:53,820 --> 00:40:56,850
acres offline if you understand it this

1134
00:40:56,850 --> 00:40:59,910
question over here or okay let's keep

1135
00:40:59,910 --> 00:41:01,260
going if you have questions we talked

1136
00:41:01,260 --> 00:41:04,020
about it further I mean the main Taylor

1137
00:41:04,020 --> 00:41:04,860
this is a bad idea

1138
00:41:04,860 --> 00:41:07,110
nobody does this this is so I don't want

1139
00:41:07,110 --> 00:41:09,090
to dwell on it too much what people

1140
00:41:09,090 --> 00:41:11,400
typically do is having a page directory

1141
00:41:11,400 --> 00:41:14,250
and for this one it's a we have a page

1142
00:41:14,250 --> 00:41:15,990
now again in the header of our file

1143
00:41:15,990 --> 00:41:19,860
that's gonna maintain the a mapping from

1144
00:41:19,860 --> 00:41:24,840
page IDs to they're all set and then we

1145
00:41:24,840 --> 00:41:25,950
can also maintain some additional

1146
00:41:25,950 --> 00:41:27,960
metadata in this directory to say hey

1147
00:41:27,960 --> 00:41:29,190
here's the amount of free space that's

1148
00:41:29,190 --> 00:41:31,380
available to me in a particular page so

1149
00:41:31,380 --> 00:41:33,510
now when I want to go say I want to

1150
00:41:33,510 --> 00:41:35,550
insert some data I don't have to go you

1151
00:41:35,550 --> 00:41:37,260
know scan the that list I can just look

1152
00:41:37,260 --> 00:41:38,670
my page directory and find everything

1153
00:41:38,670 --> 00:41:41,820
that I need right so if my pages are

1154
00:41:41,820 --> 00:41:43,440
just ordered sequentially like this and

1155
00:41:43,440 --> 00:41:45,540
then this is just a mapping to Widow

1156
00:41:45,540 --> 00:41:49,470
they're located right so the important

1157
00:41:49,470 --> 00:41:50,850
thing about this going back to what we

1158
00:41:50,850 --> 00:41:52,680
talked about about the the atomic rights

1159
00:41:52,680 --> 00:41:55,650
for the for Hardware so now I have much

1160
00:41:55,650 --> 00:41:57,840
a metadata that's that's a summarization

1161
00:41:57,840 --> 00:41:59,790
of what's in my actual pages themselves

1162
00:41:59,790 --> 00:42:02,070
and I have to keep it in sync but I

1163
00:42:02,070 --> 00:42:04,020
actually can't guarantee that because

1164
00:42:04,020 --> 00:42:07,230
the the the harbor can't guarantee that

1165
00:42:07,230 --> 00:42:08,670
I can write two pages of exactly the

1166
00:42:08,670 --> 00:42:11,310
same time so let's say that I delete a

1167
00:42:11,310 --> 00:42:14,130
bunch of data here and my page and then

1168
00:42:14,130 --> 00:42:15,600
I update I want to update my page

1169
00:42:15,600 --> 00:42:17,010
rectory and say oh I have this amount of

1170
00:42:17,010 --> 00:42:19,860
free space I made a bunch of data write

1171
00:42:19,860 --> 00:42:22,530
that out and then before I can update my

1172
00:42:22,530 --> 00:42:23,850
page directory and write that out I

1173
00:42:23,850 --> 00:42:26,310
crash so now I come back online and say

1174
00:42:26,310 --> 00:42:28,530
oh this I think this page is full and

1175
00:42:28,530 --> 00:42:30,030
therefore I can't read any data to it

1176
00:42:30,030 --> 00:42:32,160
but I know it's actually not right in

1177
00:42:32,160 --> 00:42:34,500
reality it's not so you could say all

1178
00:42:34,500 --> 00:42:35,970
right well when I boot back up I'll just

1179
00:42:35,970 --> 00:42:37,740
scan through all my pages and figure out

1180
00:42:37,740 --> 00:42:39,240
what's actually really there but now

1181
00:42:39,240 --> 00:42:41,220
again think think think in the extreme

1182
00:42:41,220 --> 00:42:41,999
if I have one gig

1183
00:42:41,999 --> 00:42:43,769
by the data then that's gonna take

1184
00:42:43,769 --> 00:42:44,969
forever or aside one petabyte of data

1185
00:42:44,969 --> 00:42:46,289
that's gonna take forever to actually do

1186
00:42:46,289 --> 00:42:48,509
this so the bunch of mechanisms will

1187
00:42:48,509 --> 00:42:49,979
talk about later on or how we can

1188
00:42:49,979 --> 00:42:52,339
maintain a log and initial metadata in

1189
00:42:52,339 --> 00:42:55,709
in sort of special special files so that

1190
00:42:55,709 --> 00:42:57,209
if we crash to come back we know how to

1191
00:42:57,209 --> 00:42:58,739
reconstruct what's inside all these

1192
00:42:58,739 --> 00:43:01,349
things I think it is just a hash table

1193
00:43:01,349 --> 00:43:03,899
to say I want page 1 2 3 here's where to

1194
00:43:03,899 --> 00:43:08,759
go find it and I just can get it yes yes

1195
00:43:08,759 --> 00:43:14,939
each page has the same size yes what do

1196
00:43:14,939 --> 00:43:17,059
you mean sorry

1197
00:43:17,059 --> 00:43:19,079
these questions what is the size of a

1198
00:43:19,079 --> 00:43:21,059
page in this world right so this goes

1199
00:43:21,059 --> 00:43:25,379
back through this diagram here they do

1200
00:43:25,379 --> 00:43:26,789
different different systems do different

1201
00:43:26,789 --> 00:43:29,659
things right

1202
00:43:29,659 --> 00:43:32,669
if failsafe is like you know we can

1203
00:43:32,669 --> 00:43:33,899
write four kilobytes and because the

1204
00:43:33,899 --> 00:43:35,789
hardware guarantee that's atomic but now

1205
00:43:35,789 --> 00:43:37,589
I need to write you know say say my

1206
00:43:37,589 --> 00:43:39,239
pages themselves are four kilobytes but

1207
00:43:39,239 --> 00:43:41,789
I need to update one page they clean up

1208
00:43:41,789 --> 00:43:43,469
clear out a bunch of data update the

1209
00:43:43,469 --> 00:43:45,029
page directory and say all right that

1210
00:43:45,029 --> 00:43:46,289
that page you've been cleared out I

1211
00:43:46,289 --> 00:43:48,149
can't guarantee the right both of those

1212
00:43:48,149 --> 00:43:50,279
pages atomically I can write one crash

1213
00:43:50,279 --> 00:43:53,809
before before I write the second one

1214
00:43:57,199 --> 00:44:02,609
okay all right so again this is what the

1215
00:44:02,609 --> 00:44:04,019
pages are gonna look like inside the yet

1216
00:44:04,019 --> 00:44:11,639
certain files so he says why do some

1217
00:44:11,639 --> 00:44:13,559
pages you why do some data systems used

1218
00:44:13,559 --> 00:44:18,139
larger pages there's trade-offs so

1219
00:44:18,139 --> 00:44:20,339
internally inside my database system I

1220
00:44:20,339 --> 00:44:22,109
have to have this page directory in

1221
00:44:22,109 --> 00:44:25,139
memory mapping pages to some some

1222
00:44:25,139 --> 00:44:27,569
location either memory or on disk but

1223
00:44:27,569 --> 00:44:29,459
now if I can represent a larger amount

1224
00:44:29,459 --> 00:44:32,999
of data with one page ID then that size

1225
00:44:32,999 --> 00:44:35,999
of that table goes down think of this is

1226
00:44:35,999 --> 00:44:38,159
like in the the TLB the translation

1227
00:44:38,159 --> 00:44:40,919
lookaside buffer inside on the CPU if I

1228
00:44:40,919 --> 00:44:42,839
am trying to match all a bunch of pages

1229
00:44:42,839 --> 00:44:44,699
but it's my page tables get really large

1230
00:44:44,699 --> 00:44:47,639
and now I'm gonna have cache misses so

1231
00:44:47,639 --> 00:44:50,669
by you can represent more data in you

1232
00:44:50,669 --> 00:44:51,949
know with with few number of page IDs

1233
00:44:51,949 --> 00:44:53,879
furthermore going back to talk about the

1234
00:44:53,879 --> 00:44:54,989
difference being random and central

1235
00:44:54,989 --> 00:44:55,710
access

1236
00:44:55,710 --> 00:44:58,069
so now if I can write out contiguously

1237
00:44:58,069 --> 00:45:01,140
you say say four four kilobyte pages to

1238
00:45:01,140 --> 00:45:02,930
represent a 16 kilobyte database page

1239
00:45:02,930 --> 00:45:05,760
when I do a read I just read all that

1240
00:45:05,760 --> 00:45:07,380
sequentially and bring it in now I'm

1241
00:45:07,380 --> 00:45:08,670
getting potentially more useful data

1242
00:45:08,670 --> 00:45:11,550
that I need but again it makes more it

1243
00:45:11,550 --> 00:45:12,990
makes doing writes more expensive look

1244
00:45:12,990 --> 00:45:14,040
at that now at this stage a bunch of

1245
00:45:14,040 --> 00:45:15,990
crap ahead of time to prevent myself

1246
00:45:15,990 --> 00:45:17,910
from getting torn writes so there's

1247
00:45:17,910 --> 00:45:19,109
there's pros and cons for both of them

1248
00:45:19,109 --> 00:45:21,000
and this is why again the commercial

1249
00:45:21,000 --> 00:45:22,050
systems allow you to tune them in

1250
00:45:22,050 --> 00:45:22,410
different ways

1251
00:45:22,410 --> 00:45:24,119
based on what your application wants to

1252
00:45:24,119 --> 00:45:32,010
do let's go question yes so so his

1253
00:45:32,010 --> 00:45:36,869
question is for for self-contained pages

1254
00:45:36,869 --> 00:45:38,369
would that solve this particular issue

1255
00:45:38,369 --> 00:45:41,339
here no you still meet so self-contained

1256
00:45:41,339 --> 00:45:44,280
pages would mean like the contents of

1257
00:45:44,280 --> 00:45:46,260
that side the page I have all the

1258
00:45:46,260 --> 00:45:48,390
metadata that I need for it I still have

1259
00:45:48,390 --> 00:45:49,710
to have a page director to tell me where

1260
00:45:49,710 --> 00:45:51,630
to find that page if I want page 1 2 3

1261
00:45:51,630 --> 00:45:54,030
or 4 5 6 so it's not entirely

1262
00:45:54,030 --> 00:45:57,750
self-contained at the higher levels in

1263
00:45:57,750 --> 00:45:59,760
the system it's unavoidable at the

1264
00:45:59,760 --> 00:46:02,640
bottom level so what we're at here might

1265
00:46:02,640 --> 00:46:04,140
weaken we have any talk about what's

1266
00:46:04,140 --> 00:46:07,410
actually inside this the page but within

1267
00:46:07,410 --> 00:46:09,180
the page directory we can't guarantee

1268
00:46:09,180 --> 00:46:11,160
that self-contained okay it doesn't make

1269
00:46:11,160 --> 00:46:26,520
sense right yes yeah so this question is

1270
00:46:26,520 --> 00:46:29,809
is there any way to guarantee that the

1271
00:46:29,809 --> 00:46:32,670
if a crash happens when you come back

1272
00:46:32,670 --> 00:46:34,230
you can identify that the crash happened

1273
00:46:34,230 --> 00:46:34,920
yes

1274
00:46:34,920 --> 00:46:38,819
so you knew checksums right so say that

1275
00:46:38,819 --> 00:46:42,119
I my database page is d3 pages here in

1276
00:46:42,119 --> 00:46:44,069
the header of the first page I'll put a

1277
00:46:44,069 --> 00:46:46,740
checksum and say all right the next from

1278
00:46:46,740 --> 00:46:48,089
my starting point here the next three

1279
00:46:48,089 --> 00:46:51,270
pages the the checksum should be like a

1280
00:46:51,270 --> 00:46:54,390
CRC or md5 should be this this amount so

1281
00:46:54,390 --> 00:46:56,670
I come back online and I after a crash I

1282
00:46:56,670 --> 00:46:59,130
would look and say oh the last page when

1283
00:46:59,130 --> 00:47:00,299
I went to commute the checksum doesn't

1284
00:47:00,299 --> 00:47:01,470
match because this thing didn't get

1285
00:47:01,470 --> 00:47:02,880
written out so therefore I would do I

1286
00:47:02,880 --> 00:47:05,790
have an error right

1287
00:47:05,790 --> 00:47:08,970
and then we'll talk about logging and no

1288
00:47:08,970 --> 00:47:10,590
in a second but like you can log the

1289
00:47:10,590 --> 00:47:12,390
operations you do to modify the pages

1290
00:47:12,390 --> 00:47:13,860
and that's essentially what the database

1291
00:47:13,860 --> 00:47:19,230
hasn't worries about mostly alright cool

1292
00:47:19,230 --> 00:47:21,180
so that's all I'll talk about what that

1293
00:47:21,180 --> 00:47:22,520
actually looks like inside these pages

1294
00:47:22,520 --> 00:47:26,240
again every page is gonna have a header

1295
00:47:26,240 --> 00:47:28,500
and it's sort of what he asked about

1296
00:47:28,500 --> 00:47:30,180
we're gonna have information what's the

1297
00:47:30,180 --> 00:47:32,100
size of the page the checksum what

1298
00:47:32,100 --> 00:47:34,650
database version or the version of the

1299
00:47:34,650 --> 00:47:36,710
software wrote this data out right you

1300
00:47:36,710 --> 00:47:39,030
what could happen is people can you know

1301
00:47:39,030 --> 00:47:40,800
data is companies put out new releases

1302
00:47:40,800 --> 00:47:42,780
Postgres puts out new releases every

1303
00:47:42,780 --> 00:47:44,400
single time you know the page layout may

1304
00:47:44,400 --> 00:47:47,100
change so when you when you want to

1305
00:47:47,100 --> 00:47:48,870
upgrade you want to know am i looking at

1306
00:47:48,870 --> 00:47:50,100
pages that are created by the new

1307
00:47:50,100 --> 00:47:51,840
software the old software and I can have

1308
00:47:51,840 --> 00:47:53,130
different code paths to interpret them

1309
00:47:53,130 --> 00:47:55,170
if you're doing compression like the

1310
00:47:55,170 --> 00:47:57,750
dictionary compression or like lz4 gzip

1311
00:47:57,750 --> 00:48:00,000
you can store information about that we

1312
00:48:00,000 --> 00:48:01,710
all talked about this at this point in

1313
00:48:01,710 --> 00:48:02,790
the semester but it's also information

1314
00:48:02,790 --> 00:48:04,530
about you know what transactions or what

1315
00:48:04,530 --> 00:48:06,420
queries modify this data and whether

1316
00:48:06,420 --> 00:48:09,000
other queries allowed to see it again

1317
00:48:09,000 --> 00:48:11,280
and then we've already talked about the

1318
00:48:11,280 --> 00:48:15,180
issue of a maybe self-contained right so

1319
00:48:15,180 --> 00:48:17,280
now within a page we can represent data

1320
00:48:17,280 --> 00:48:20,190
in in two different ways so we can do

1321
00:48:20,190 --> 00:48:21,960
this as a sort of a tuple oriented

1322
00:48:21,960 --> 00:48:23,550
approach and I'll explain what that

1323
00:48:23,550 --> 00:48:27,180
means the next slide or we can do a log

1324
00:48:27,180 --> 00:48:31,110
structured approach so again it's within

1325
00:48:31,110 --> 00:48:32,850
a page now assuming of a page directory

1326
00:48:32,850 --> 00:48:34,200
to tell us how we need to get to that

1327
00:48:34,200 --> 00:48:35,280
page if we want you know a particular

1328
00:48:35,280 --> 00:48:37,410
page of one two three now we're talking

1329
00:48:37,410 --> 00:48:38,430
about what does it look like when you

1330
00:48:38,430 --> 00:48:39,690
look inside the page what do you

1331
00:48:39,690 --> 00:48:41,130
actually the data set I'm actually going

1332
00:48:41,130 --> 00:48:44,280
to see so for this one let's just assume

1333
00:48:44,280 --> 00:48:46,470
that we're storing tuples and let's say

1334
00:48:46,470 --> 00:48:48,240
a really simple case here a really

1335
00:48:48,240 --> 00:48:51,180
similar strong main idea is that in our

1336
00:48:51,180 --> 00:48:54,180
page all we're gonna do is just insert

1337
00:48:54,180 --> 00:48:56,430
tuples one after another right start

1338
00:48:56,430 --> 00:48:57,630
from the beginning we have a little

1339
00:48:57,630 --> 00:48:58,680
header space and say here's the number

1340
00:48:58,680 --> 00:49:00,210
of tuples that we have so we know what

1341
00:49:00,210 --> 00:49:02,310
else that we want to jump to if we want

1342
00:49:02,310 --> 00:49:05,430
to insert a new one but it's super

1343
00:49:05,430 --> 00:49:07,050
simple we just insert one at a time

1344
00:49:07,050 --> 00:49:10,200
right so say a third start three tuples

1345
00:49:10,200 --> 00:49:13,110
assuming they're all fixed length every

1346
00:49:13,110 --> 00:49:14,700
single time an insert one I just jump to

1347
00:49:14,700 --> 00:49:16,620
the next off free offset looking and

1348
00:49:16,620 --> 00:49:18,740
then update the counter

1349
00:49:18,740 --> 00:49:26,780
so this is a bad idea why perfect so he

1350
00:49:26,780 --> 00:49:28,730
says yeah if you delete a tuple you have

1351
00:49:28,730 --> 00:49:30,320
to move everything well not necessarily

1352
00:49:30,320 --> 00:49:33,349
right I could just do this all right

1353
00:49:33,349 --> 00:49:37,220
free the space table he says the

1354
00:49:37,220 --> 00:49:38,990
external fragmentation well why why

1355
00:49:38,990 --> 00:49:45,190
can't I just insert in there with that

1356
00:49:45,190 --> 00:49:47,330
right so I made the assumption that

1357
00:49:47,330 --> 00:49:48,410
their fixed length size but he's

1358
00:49:48,410 --> 00:49:50,480
absolutely right so this works great it

1359
00:49:50,480 --> 00:49:51,589
fixed if it everything's fixed Lane

1360
00:49:51,589 --> 00:49:53,630
could I just shove it the new one where

1361
00:49:53,630 --> 00:49:55,280
the old one was but it's not fixed

1362
00:49:55,280 --> 00:49:58,250
length then this slot may actually you

1363
00:49:58,250 --> 00:49:59,599
know this location may not be big enough

1364
00:49:59,599 --> 00:50:01,040
for what I would insert and now I got to

1365
00:50:01,040 --> 00:50:05,720
try to put it down in here right so so

1366
00:50:05,720 --> 00:50:07,790
that's one issue I mean the other issue

1367
00:50:07,790 --> 00:50:09,440
too is like every single time I need to

1368
00:50:09,440 --> 00:50:12,470
go say I delete this thing I either mean

1369
00:50:12,470 --> 00:50:14,599
to mean maintain metadata at the top and

1370
00:50:14,599 --> 00:50:16,400
tell me hey here's the here's a here's a

1371
00:50:16,400 --> 00:50:17,690
location in this page or you can write

1372
00:50:17,690 --> 00:50:19,820
some data or I got a sequentially scan

1373
00:50:19,820 --> 00:50:22,099
and look at every single tuple to figure

1374
00:50:22,099 --> 00:50:25,609
out where I can go right so this sucks

1375
00:50:25,609 --> 00:50:28,160
nobody does this instead what you do is

1376
00:50:28,160 --> 00:50:31,369
what it cause slotted pages so this is

1377
00:50:31,369 --> 00:50:33,410
the most common scheme that every disk

1378
00:50:33,410 --> 00:50:35,599
or in a data system will use the exact

1379
00:50:35,599 --> 00:50:37,190
details of how they're going to

1380
00:50:37,190 --> 00:50:38,660
represent these pages are we slightly

1381
00:50:38,660 --> 00:50:40,460
different but at a high level this is

1382
00:50:40,460 --> 00:50:42,680
this is what everyone does so the way

1383
00:50:42,680 --> 00:50:43,520
things could work we're always gonna

1384
00:50:43,520 --> 00:50:45,349
have our header the header it can store

1385
00:50:45,349 --> 00:50:47,240
that basic metadata about checksum or

1386
00:50:47,240 --> 00:50:48,859
you know access times and things like

1387
00:50:48,859 --> 00:50:51,859
that and then we're gonna have to sort

1388
00:50:51,859 --> 00:50:54,770
of regions of data we want to store at

1389
00:50:54,770 --> 00:50:56,119
the top would have what's called a slot

1390
00:50:56,119 --> 00:50:57,800
array and the bottom we're actually

1391
00:50:57,800 --> 00:51:00,050
going to have the actual the data we

1392
00:51:00,050 --> 00:51:01,880
want to store these in again we're

1393
00:51:01,880 --> 00:51:03,619
assuming we're doing tuples here so then

1394
00:51:03,619 --> 00:51:05,119
this one can be fixed length of variable

1395
00:51:05,119 --> 00:51:07,460
length tuples it doesn't matter so what

1396
00:51:07,460 --> 00:51:09,080
the slaughter rate basically is is a

1397
00:51:09,080 --> 00:51:12,349
mapping layer from a particular slot to

1398
00:51:12,349 --> 00:51:15,380
some offset in the page where that's the

1399
00:51:15,380 --> 00:51:17,480
starting location of the particular

1400
00:51:17,480 --> 00:51:21,770
tuple that you want right and the reason

1401
00:51:21,770 --> 00:51:23,240
why we want to have this indirection

1402
00:51:23,240 --> 00:51:25,339
layers because now we can start moving

1403
00:51:25,339 --> 00:51:27,020
these within a page we can move these

1404
00:51:27,020 --> 00:51:29,780
tuples around any way that we want again

1405
00:51:29,780 --> 00:51:31,369
the upper levels of the system don't

1406
00:51:31,369 --> 00:51:32,650
care

1407
00:51:32,650 --> 00:51:34,610
right they can always you know the

1408
00:51:34,610 --> 00:51:36,110
record i t's gonna the page ID and the

1409
00:51:36,110 --> 00:51:39,110
slot number and all i need to do is move

1410
00:51:39,110 --> 00:51:40,370
these things around and just update the

1411
00:51:40,370 --> 00:51:41,390
slaughter rate and say here's what

1412
00:51:41,390 --> 00:51:42,910
here's where you're actually pointing to

1413
00:51:42,910 --> 00:51:45,260
and the way we're gonna fill up the page

1414
00:51:45,260 --> 00:51:47,060
is that the slot array is gonna grow

1415
00:51:47,060 --> 00:51:49,340
from the beginning to the end and the

1416
00:51:49,340 --> 00:51:50,750
data is gonna grow from the end to the

1417
00:51:50,750 --> 00:51:52,850
beginning and at some point we'll reach

1418
00:51:52,850 --> 00:51:54,110
in the middle where we can't store any

1419
00:51:54,110 --> 00:51:55,730
any new information and then that's what

1420
00:51:55,730 --> 00:51:57,730
we say that our page is full

1421
00:51:57,730 --> 00:52:00,020
so yeah this means that there could be a

1422
00:52:00,020 --> 00:52:02,150
small little gap in the middle where we

1423
00:52:02,150 --> 00:52:04,880
can't store anything but that's you know

1424
00:52:04,880 --> 00:52:06,740
because we wanted to support very length

1425
00:52:06,740 --> 00:52:10,070
tuples we have to we have to do this all

1426
00:52:10,070 --> 00:52:11,720
right we could do what's called a vacuum

1427
00:52:11,720 --> 00:52:13,160
or compaction we could just scan through

1428
00:52:13,160 --> 00:52:16,310
and reorganize defragmentation and in

1429
00:52:16,310 --> 00:52:19,130
old file systems we could do that in the

1430
00:52:19,130 --> 00:52:20,390
background the days we can do it but for

1431
00:52:20,390 --> 00:52:22,910
our purposes right this is this what we

1432
00:52:22,910 --> 00:52:32,030
end up with yes good point so his

1433
00:52:32,030 --> 00:52:33,920
question is are we assuming here that

1434
00:52:33,920 --> 00:52:36,320
that the within a page we could have

1435
00:52:36,320 --> 00:52:39,320
tuples from different tables in practice

1436
00:52:39,320 --> 00:52:40,490
nobody does that

1437
00:52:40,490 --> 00:52:41,870
because you would have to maintain some

1438
00:52:41,870 --> 00:52:43,340
metadata say this is from tuple want a

1439
00:52:43,340 --> 00:52:45,860
table one this is from table two we'll

1440
00:52:45,860 --> 00:52:47,150
see at the end that there is a way to

1441
00:52:47,150 --> 00:52:49,760
there's some systems that do do this but

1442
00:52:49,760 --> 00:52:51,470
in general nobody does this like if you

1443
00:52:51,470 --> 00:52:52,640
open up sequel later postgrads or

1444
00:52:52,640 --> 00:52:54,560
whatever you call create table it'll

1445
00:52:54,560 --> 00:52:56,540
create pages and only tuples from those

1446
00:52:56,540 --> 00:53:00,380
tables will go in those pages it's good

1447
00:53:00,380 --> 00:53:01,280
question what will come to that in a

1448
00:53:01,280 --> 00:53:04,220
second so these are tuple oriented pages

1449
00:53:04,220 --> 00:53:06,290
and the other day we're trying to store

1450
00:53:06,290 --> 00:53:09,110
tuples inside these pages and so you

1451
00:53:09,110 --> 00:53:10,520
know when I do an insert I do an update

1452
00:53:10,520 --> 00:53:12,440
I want to find you know I take the

1453
00:53:12,440 --> 00:53:13,970
contents that tuple and just write it

1454
00:53:13,970 --> 00:53:17,350
out in its entirety in this page here

1455
00:53:17,350 --> 00:53:20,300
we'll see in next class we'll talk about

1456
00:53:20,300 --> 00:53:23,720
for really large data like if you have a

1457
00:53:23,720 --> 00:53:25,010
tree that's like you want a store like a

1458
00:53:25,010 --> 00:53:27,350
you know a video file in the database

1459
00:53:27,350 --> 00:53:29,660
don't do that what's fine why later but

1460
00:53:29,660 --> 00:53:31,700
like for that case here you couldn't

1461
00:53:31,700 --> 00:53:32,630
store this because it won't fit in a

1462
00:53:32,630 --> 00:53:34,400
single page so you some you have some

1463
00:53:34,400 --> 00:53:35,510
extra metadata some pointers to say

1464
00:53:35,510 --> 00:53:37,010
here's the pages that have the rest of

1465
00:53:37,010 --> 00:53:38,930
the data that you're looking for but in

1466
00:53:38,930 --> 00:53:40,580
general we want us pack in the entire

1467
00:53:40,580 --> 00:53:42,380
tuple in a single page because now when

1468
00:53:42,380 --> 00:53:43,910
we go access that you need to access to

1469
00:53:43,910 --> 00:53:45,650
the tuple it's one page read to go get

1470
00:53:45,650 --> 00:53:46,100
it

1471
00:53:46,100 --> 00:53:49,640
and not a bunch of different ones again

1472
00:53:49,640 --> 00:53:51,230
we'll break that assumption next class

1473
00:53:51,230 --> 00:53:55,520
but for our purposes here it's fine so

1474
00:53:55,520 --> 00:53:57,560
another way to store data and pages is

1475
00:53:57,560 --> 00:54:07,730
it's our question so his question is say

1476
00:54:07,730 --> 00:54:09,800
I remember the third tuple here right

1477
00:54:09,800 --> 00:54:13,340
what happens well it depends

1478
00:54:13,340 --> 00:54:15,320
I'll give it a minute in the class some

1479
00:54:15,320 --> 00:54:16,730
systems will actually compact it before

1480
00:54:16,730 --> 00:54:18,380
it writes out the disk some systems will

1481
00:54:18,380 --> 00:54:20,960
just leave a gap here and then if it

1482
00:54:20,960 --> 00:54:22,160
gets full and you say oh I have some

1483
00:54:22,160 --> 00:54:24,010
free space maybe I try to do compaction

1484
00:54:24,010 --> 00:54:33,770
yes yes this question is the the slot is

1485
00:54:33,770 --> 00:54:35,030
pointing to the starting position of the

1486
00:54:35,030 --> 00:54:39,310
tuple the question is what does a point

1487
00:54:42,370 --> 00:54:44,690
since question is what is the what is

1488
00:54:44,690 --> 00:54:46,400
the ordering of the storage address

1489
00:54:46,400 --> 00:54:55,910
within the slots not sure what you mean

1490
00:54:55,910 --> 00:54:58,880
like I have say this is 4 kilobytes I I

1491
00:54:58,880 --> 00:55:01,250
want to store a 1 kilobyte tuple for

1492
00:55:01,250 --> 00:55:04,310
Cuba 1 so from starting from the offset

1493
00:55:04,310 --> 00:55:07,280
I jump to the 1 kilobyte and then my

1494
00:55:07,280 --> 00:55:19,640
slot right points of that right yes the

1495
00:55:19,640 --> 00:55:20,900
question is if I delete one tuple in the

1496
00:55:20,900 --> 00:55:23,300
middle again I see people 3 what do i

1497
00:55:23,300 --> 00:55:25,760
what do I do it up above nothing missile

1498
00:55:25,760 --> 00:55:31,130
on array yes so again the header could

1499
00:55:31,130 --> 00:55:33,260
dimmer systems do different things the

1500
00:55:33,260 --> 00:55:35,270
header could could have a bit mat and

1501
00:55:35,270 --> 00:55:37,160
say you know here's the here's the slots

1502
00:55:37,160 --> 00:55:38,570
that are empty that you could point

1503
00:55:38,570 --> 00:55:41,120
something in or I just switch the scan

1504
00:55:41,120 --> 00:55:44,030
and read it right it doesn't matter the

1505
00:55:44,030 --> 00:55:47,570
key thing though I think is that the the

1506
00:55:47,570 --> 00:55:51,140
other parts of the system don't know and

1507
00:55:51,140 --> 00:55:53,630
don't care that where I'm actually

1508
00:55:53,630 --> 00:55:55,700
physically stored like it first so for

1509
00:55:55,700 --> 00:55:58,940
tuple 1 right this comes out of the slot

1510
00:55:58,940 --> 00:55:59,970
here

1511
00:55:59,970 --> 00:56:01,650
right so in the upper part of the system

1512
00:56:01,650 --> 00:56:04,020
it would say Oh tuple one you can find

1513
00:56:04,020 --> 00:56:05,550
it if you have page one two three

1514
00:56:05,550 --> 00:56:09,869
at slot zero slot one depending on what

1515
00:56:09,869 --> 00:56:12,300
your starting offset is so now no matter

1516
00:56:12,300 --> 00:56:14,820
how I reorganize my page and move to but

1517
00:56:14,820 --> 00:56:16,980
one around I know that I always want to

1518
00:56:16,980 --> 00:56:18,450
go to the first slot to find where it's

1519
00:56:18,450 --> 00:56:20,730
actually located and now if I reorganize

1520
00:56:20,730 --> 00:56:22,320
I don't have to update my indexes on to

1521
00:56:22,320 --> 00:56:24,359
update anything and this is sort of what

1522
00:56:24,359 --> 00:56:25,890
the page directory is trying to do as

1523
00:56:25,890 --> 00:56:28,290
well so no matter where I move the pages

1524
00:56:28,290 --> 00:56:31,230
on on the file either on disk or

1525
00:56:31,230 --> 00:56:33,080
different look you know on the network

1526
00:56:33,080 --> 00:56:35,550
other parts of the system don't care

1527
00:56:35,550 --> 00:56:37,530
where it actually got moved to because I

1528
00:56:37,530 --> 00:56:39,030
have a page once you know I have the

1529
00:56:39,030 --> 00:56:40,560
page ID I can only use the page

1530
00:56:40,560 --> 00:56:41,460
directory to find where it's actually

1531
00:56:41,460 --> 00:56:44,400
main stored right these indirection

1532
00:56:44,400 --> 00:56:47,460
layers avoid having to have updates

1533
00:56:47,460 --> 00:56:48,930
propagate through all the parts of the

1534
00:56:48,930 --> 00:56:58,320
system yes those question is how do I

1535
00:56:58,320 --> 00:57:02,190
know that tuple one is stored in in slot

1536
00:57:02,190 --> 00:57:02,580
one

1537
00:57:02,580 --> 00:57:08,670
so if I had too much but we'll go ahead

1538
00:57:08,670 --> 00:57:16,650
and do that so this is always in the

1539
00:57:16,650 --> 00:57:17,820
last slide but let's talk about it now

1540
00:57:17,820 --> 00:57:22,470
so the way we identify tuples is through

1541
00:57:22,470 --> 00:57:26,609
these record IDs or tuple IDs and it's

1542
00:57:26,609 --> 00:57:29,070
essentially a unique identifier to say

1543
00:57:29,070 --> 00:57:32,190
here's the logical location or a logical

1544
00:57:32,190 --> 00:57:37,260
address of a of a tuple it's a blend of

1545
00:57:37,260 --> 00:57:38,550
logical and physical but usually the

1546
00:57:38,550 --> 00:57:41,000
page ID and like the offset or the slot

1547
00:57:41,000 --> 00:57:43,320
so all the parts of the system that we

1548
00:57:43,320 --> 00:57:45,720
want to address tuple one right they

1549
00:57:45,720 --> 00:57:47,010
don't know what - Bolin is they just

1550
00:57:47,010 --> 00:57:48,390
know I have a page ID and I'm a slot

1551
00:57:48,390 --> 00:57:50,550
number and so I go to the page directory

1552
00:57:50,550 --> 00:57:52,500
and say I want page 1 2 3 the page

1553
00:57:52,500 --> 00:57:54,450
directory says oh it's in this file and

1554
00:57:54,450 --> 00:57:56,910
this all set jump to that then I get get

1555
00:57:56,910 --> 00:57:59,490
to that page now I say oh I want slot 1

1556
00:57:59,490 --> 00:58:01,710
I look at my slot array and that tells

1557
00:58:01,710 --> 00:58:02,970
me where in that page you can find the

1558
00:58:02,970 --> 00:58:05,849
data that I want so other parts of the

1559
00:58:05,849 --> 00:58:08,970
system like the indexes log records and

1560
00:58:08,970 --> 00:58:09,930
other things they're going to address

1561
00:58:09,930 --> 00:58:12,390
tuples through these record IDs

1562
00:58:12,390 --> 00:58:17,089
a morning that's separate from the page

1563
00:58:22,250 --> 00:58:35,010
like as well yes me it like I'll give a

1564
00:58:35,010 --> 00:58:37,769
demo hope let's make myself like say I

1565
00:58:37,769 --> 00:58:40,500
want to find find that the salary find

1566
00:58:40,500 --> 00:58:42,809
the the student record or the professor

1567
00:58:42,809 --> 00:58:45,210
record the name Andy I look in the index

1568
00:58:45,210 --> 00:58:47,579
on the name and something to say oh

1569
00:58:47,579 --> 00:58:49,319
there's a professor named Andy and he's

1570
00:58:49,319 --> 00:58:51,930
he has a record ID of page one two three

1571
00:58:51,930 --> 00:58:52,920
all set

1572
00:58:52,920 --> 00:58:55,130
slot one that's what that UNIX gives me

1573
00:58:55,130 --> 00:58:57,119
so then I say it go to the page

1574
00:58:57,119 --> 00:58:58,140
directory okay

1575
00:58:58,140 --> 00:59:00,089
Gav where do I find page one two three

1576
00:59:00,089 --> 00:59:01,829
you go get it for me it goes and gets it

1577
00:59:01,829 --> 00:59:03,569
now I have the pointer to the page and

1578
00:59:03,569 --> 00:59:06,000
say oh I want slot one I look at my slot

1579
00:59:06,000 --> 00:59:07,529
array and that tells me what all set the

1580
00:59:07,529 --> 00:59:09,230
jump to that page to find that need

1581
00:59:09,230 --> 00:59:12,569
right and so different data systems do

1582
00:59:12,569 --> 00:59:14,369
different things the most common

1583
00:59:14,369 --> 00:59:16,109
approach is the page ID and the slot

1584
00:59:16,109 --> 00:59:18,630
number the offset and again they Vantage

1585
00:59:18,630 --> 00:59:20,819
of this is that if I start moving data

1586
00:59:20,819 --> 00:59:23,069
around either moving the page around or

1587
00:59:23,069 --> 00:59:25,680
moving did within the page itself the

1588
00:59:25,680 --> 00:59:27,119
index and all the other crap doesn't

1589
00:59:27,119 --> 00:59:27,930
have to get updated because they're

1590
00:59:27,930 --> 00:59:29,400
still looking at page one two three all

1591
00:59:29,400 --> 00:59:35,130
set one so okay now let me I'll give a

1592
00:59:35,130 --> 00:59:36,779
demo explain some more detail so in

1593
00:59:36,779 --> 00:59:38,339
different systems do different things

1594
00:59:38,339 --> 00:59:41,099
like in Postgres it'll be 4 bytes or

1595
00:59:41,099 --> 00:59:42,480
equals 10 bytes there's a bunch of extra

1596
00:59:42,480 --> 00:59:44,670
metadata that they store and sequel Lite

1597
00:59:44,670 --> 00:59:48,750
is 8 bytes so let's give a demo because

1598
00:59:48,750 --> 00:59:52,140
that's always fun because I hate typing

1599
00:59:52,140 --> 00:59:55,819
on the surface and use my other laptop

1600
00:59:55,819 --> 00:59:57,480
and I can see it better

1601
00:59:57,480 --> 00:59:58,980
alright so I'm gonna give an example

1602
00:59:58,980 --> 01:00:01,650
again a what of how we can actually see

1603
01:00:01,650 --> 01:00:04,170
what these pages look like because again

1604
01:00:04,170 --> 01:00:05,609
the data system that stores this

1605
01:00:05,609 --> 01:00:07,529
internally you're not supposed to see it

1606
01:00:07,529 --> 01:00:09,180
but there's different commands to do to

1607
01:00:09,180 --> 01:00:10,230
actually to get at it

1608
01:00:10,230 --> 01:00:14,250
I can't were in the back see that or is

1609
01:00:14,250 --> 01:00:17,910
it too dark or too light how's that

1610
01:00:17,910 --> 01:00:20,670
better ok alright so we're going to make

1611
01:00:20,670 --> 01:00:22,910
a

1612
01:00:23,390 --> 01:00:33,260
we're gonna make a simple table that has

1613
01:00:33,260 --> 01:00:36,359
two columns ID and value and we're gonna

1614
01:00:36,359 --> 01:00:38,369
insert some tables in it all right so

1615
01:00:38,369 --> 01:00:42,300
this is Postgres right so you see ID in

1616
01:00:42,300 --> 01:00:44,280
value so Postgres has this thing called

1617
01:00:44,280 --> 01:00:47,190
the CT ID that is represents the

1618
01:00:47,190 --> 01:00:49,020
physical location of the data of the

1619
01:00:49,020 --> 01:00:52,140
data so I can add this like virtual

1620
01:00:52,140 --> 01:00:54,960
column here a CT ID and I get it in my

1621
01:00:54,960 --> 01:00:58,260
output so this now is a tuple there

1622
01:00:58,260 --> 01:01:00,570
that's gonna have the page ID and the

1623
01:01:00,570 --> 01:01:02,310
offset so again here's the data I

1624
01:01:02,310 --> 01:01:04,410
started three tuples so now it's saying

1625
01:01:04,410 --> 01:01:07,230
that at page zero slot one is the first

1626
01:01:07,230 --> 01:01:09,150
tuple page zero slot 2 is the second

1627
01:01:09,150 --> 01:01:11,190
tuple pay zero slot 3 is the third tuple

1628
01:01:11,190 --> 01:01:14,070
right so this again so that's not

1629
01:01:14,070 --> 01:01:15,930
actually storing this data it's just it

1630
01:01:15,930 --> 01:01:17,849
can derive this when it runs the query

1631
01:01:17,849 --> 01:01:19,920
because it says oh I look at my page I

1632
01:01:19,920 --> 01:01:21,750
see the slots here's the tuple that

1633
01:01:21,750 --> 01:01:24,990
actually are actually found all right so

1634
01:01:24,990 --> 01:01:26,099
let's go ahead and delete one of these

1635
01:01:26,099 --> 01:01:29,280
tuples let's say say I delete the the

1636
01:01:29,280 --> 01:01:32,369
second one so I go back and look at my

1637
01:01:32,369 --> 01:01:34,859
tuple alright look at my data and you

1638
01:01:34,859 --> 01:01:36,690
can see that it deleted the the second

1639
01:01:36,690 --> 01:01:38,790
tuple but it didn't realize the page

1640
01:01:38,790 --> 01:01:41,670
right the the third tuple is still it

1641
01:01:41,670 --> 01:01:44,420
you know page 0 offset 3 or slot 3

1642
01:01:44,420 --> 01:01:48,750
alright so let's say now I go and start

1643
01:01:48,750 --> 01:01:52,530
a new tuple in what do you think is

1644
01:01:52,530 --> 01:01:54,800
gonna do

1645
01:01:55,720 --> 01:01:59,560
with that what so again I had a deleted

1646
01:01:59,560 --> 01:02:01,810
a second tuple now I have us a tublat

1647
01:02:01,810 --> 01:02:04,030
slot one it slot three I started a new

1648
01:02:04,030 --> 01:02:06,990
tuple is it gonna be slot two or slot 4

1649
01:02:06,990 --> 01:02:10,930
raise your hand it's a slot two half

1650
01:02:10,930 --> 01:02:15,490
flat three are starting slot 4 less flat

1651
01:02:15,490 --> 01:02:19,780
four right it's not wrong right because

1652
01:02:19,780 --> 01:02:21,400
for our purposes the relational models

1653
01:02:21,400 --> 01:02:22,329
that doesn't say anything about the

1654
01:02:22,329 --> 01:02:25,780
order of how we insert tuples Postgres

1655
01:02:25,780 --> 01:02:27,250
it's way to implement I decided to put

1656
01:02:27,250 --> 01:02:30,730
it at the end so Postgres has this thing

1657
01:02:30,730 --> 01:02:33,700
called the vacuum think of this again as

1658
01:02:33,700 --> 01:02:36,640
like the garbage collector for my for

1659
01:02:36,640 --> 01:02:38,859
the database so it's gonna go through

1660
01:02:38,859 --> 01:02:42,300
and reorganize all the pages and

1661
01:02:42,300 --> 01:02:44,230
actually may take a while so I'll come

1662
01:02:44,230 --> 01:02:46,750
back to that but when it does this it's

1663
01:02:46,750 --> 01:02:48,730
gonna then say oh well I know that I

1664
01:02:48,730 --> 01:02:52,300
have a I have a free space in - so I'm

1665
01:02:52,300 --> 01:02:54,400
gonna compact the pages and write them

1666
01:02:54,400 --> 01:02:56,740
out sequentially all right it's gonna

1667
01:02:56,740 --> 01:03:00,190
take a while let's look at other ones so

1668
01:03:00,190 --> 01:03:02,920
we can do sequel server same thing I

1669
01:03:02,920 --> 01:03:08,349
have I have three tuples let me drop the

1670
01:03:08,349 --> 01:03:10,890
table start over

1671
01:03:20,239 --> 01:03:22,890
so now I have three two bowls select

1672
01:03:22,890 --> 01:03:29,969
star from our right one two three so

1673
01:03:29,969 --> 01:03:31,439
Postgres does start sequel server

1674
01:03:31,439 --> 01:03:34,410
doesn't have the CT ID it has this like

1675
01:03:34,410 --> 01:03:38,189
other built-in function like this and it

1676
01:03:38,189 --> 01:03:40,140
tells you here's the file ID here's the

1677
01:03:40,140 --> 01:03:42,059
page number and here's the slot zero one

1678
01:03:42,059 --> 01:03:44,849
two okay so let's do the same thing

1679
01:03:44,849 --> 01:03:49,910
let's delete a tuple insert a new one oh

1680
01:03:49,910 --> 01:03:52,619
yeah we can look at the old one query

1681
01:03:52,619 --> 01:03:54,719
and it didn't it didn't come back it

1682
01:03:54,719 --> 01:03:57,359
still says you know uh zero one actually

1683
01:03:57,359 --> 01:03:58,709
no I didn't come back it sorry take that

1684
01:03:58,709 --> 01:04:01,289
back let's start this over again

1685
01:04:01,289 --> 01:04:04,680
I missed that sorry I always remember

1686
01:04:04,680 --> 01:04:06,390
which one doesn't correctly or not or

1687
01:04:06,390 --> 01:04:08,430
not not again it's not correct which one

1688
01:04:08,430 --> 01:04:11,969
does it that way so we insert three

1689
01:04:11,969 --> 01:04:19,680
tuples do a right 0 1 2 now I

1690
01:04:19,680 --> 01:04:24,839
delete the the second tuple do the same

1691
01:04:24,839 --> 01:04:29,369
select oh did 0 R 0 - I didn't come back

1692
01:04:29,369 --> 01:04:35,689
yet sorry let's insert another one again

1693
01:04:38,449 --> 01:04:46,650
0 1 2 so so so this so this was the the

1694
01:04:46,650 --> 01:04:50,819
the second tube this was 2 now it's 1 it

1695
01:04:50,819 --> 01:04:52,319
made this - because what it did it says

1696
01:04:52,319 --> 01:04:54,269
when it updated page says oh I have a

1697
01:04:54,269 --> 01:04:56,789
free space let me compact it and write

1698
01:04:56,789 --> 01:05:00,089
it out right again from the high-level

1699
01:05:00,089 --> 01:05:01,650
part of the system we don't know we

1700
01:05:01,650 --> 01:05:03,539
don't care internally can do whatever it

1701
01:05:03,539 --> 01:05:07,469
wanted so going back to Postgres was it

1702
01:05:07,469 --> 01:05:10,589
one Postgres when we inserted the new

1703
01:05:10,589 --> 01:05:12,509
tuple I put it at the end but then I run

1704
01:05:12,509 --> 01:05:14,609
the vacuum and that does basically

1705
01:05:14,609 --> 01:05:16,890
compaction right now if we organized a

1706
01:05:16,890 --> 01:05:19,380
zero one three one two one two three

1707
01:05:19,380 --> 01:05:23,670
where that was one three four right so

1708
01:05:23,670 --> 01:05:25,859
the last one I want to show is Oracle

1709
01:05:25,859 --> 01:05:28,589
and although Oracle sponsor in the class

1710
01:05:28,589 --> 01:05:32,719
I will just say this their terminals

1711
01:05:33,260 --> 01:05:35,670
you could like you can't hit up there's

1712
01:05:35,670 --> 01:05:42,890
no way to go back and drop table arm

1713
01:05:42,890 --> 01:05:47,250
let's create a table and you can't you

1714
01:05:47,250 --> 01:05:48,869
can't so this is the nice shortcut like

1715
01:05:48,869 --> 01:05:50,460
everyday to symbolize you do inserts

1716
01:05:50,460 --> 01:05:52,829
like one insert query and then once two

1717
01:05:52,829 --> 01:05:54,299
commas to separate it sort them all once

1718
01:05:54,299 --> 01:05:57,000
Oracle doesn't let you do that so I have

1719
01:05:57,000 --> 01:06:06,089
to go do one by one so Oracle has

1720
01:06:06,089 --> 01:06:08,880
something called a row ID again so this

1721
01:06:08,880 --> 01:06:10,859
is an internal thing that Oracle's

1722
01:06:10,859 --> 01:06:14,339
maintaining you normally run queries you

1723
01:06:14,339 --> 01:06:15,450
don't see this but if you just add the

1724
01:06:15,450 --> 01:06:18,180
row ID column is that like a you know

1725
01:06:18,180 --> 01:06:20,010
internal virtual column it exposes this

1726
01:06:20,010 --> 01:06:21,839
information so this is some ten byte

1727
01:06:21,839 --> 01:06:23,670
gibberish I mean we don't have interpret

1728
01:06:23,670 --> 01:06:26,279
this so there is a command there's a

1729
01:06:26,279 --> 01:06:27,960
bunch of functions you can run again I

1730
01:06:27,960 --> 01:06:29,789
found this in Internet I didn't write

1731
01:06:29,789 --> 01:06:30,569
this

1732
01:06:30,569 --> 01:06:32,609
the basically deciphered this and now

1733
01:06:32,609 --> 01:06:34,289
you get like here's the file number the

1734
01:06:34,289 --> 01:06:36,269
block number and the row slot the same

1735
01:06:36,269 --> 01:06:38,910
way we saw for before for sequel server

1736
01:06:38,910 --> 01:06:41,819
okay let's do that let's let's delete

1737
01:06:41,819 --> 01:06:48,440
the second guy and go back can't do that

1738
01:06:52,190 --> 01:06:57,509
so it was 0 1 2 for the slots and out

1739
01:06:57,509 --> 01:07:01,230
still at 0 2 let's go insert our new

1740
01:07:01,230 --> 01:07:05,480
tuple alright so who says it's gonna be

1741
01:07:05,480 --> 01:07:11,880
at slot 1 2 okay who says it's gonna be

1742
01:07:11,880 --> 01:07:17,160
slot 4 or slot 3 even less nobody knows

1743
01:07:17,160 --> 01:07:19,430
ok

1744
01:07:21,329 --> 01:07:25,960
slot three right so again the main to

1745
01:07:25,960 --> 01:07:27,789
seacoast over compacted the page with

1746
01:07:27,789 --> 01:07:29,829
weren't wrote it back out Oracle and

1747
01:07:29,829 --> 01:07:31,660
Postgres does elite leave the empty slot

1748
01:07:31,660 --> 01:07:36,609
there okay again it doesn't matter to

1749
01:07:36,609 --> 01:07:38,019
the other parts of the system this is

1750
01:07:38,019 --> 01:07:39,549
just something how the system is

1751
01:07:39,549 --> 01:07:42,220
internally organizing tuples or slots

1752
01:07:42,220 --> 01:07:49,140
within the pages okay so let's go back

1753
01:07:50,880 --> 01:07:52,089
alright

1754
01:07:52,089 --> 01:07:53,920
so did I answer your question I realize

1755
01:07:53,920 --> 01:07:59,829
that was a long okay yeah so let's talk

1756
01:07:59,829 --> 01:08:03,970
about now are we doing time yes this

1757
01:08:03,970 --> 01:08:05,470
question is why do exposed to safety API

1758
01:08:05,470 --> 01:08:17,319
to the user so database systems are very

1759
01:08:17,319 --> 01:08:19,600
complex pieces of software people get

1760
01:08:19,600 --> 01:08:23,080
paid as money to maintain them and so by

1761
01:08:23,080 --> 01:08:25,689
exposing all the metadata you can to the

1762
01:08:25,689 --> 01:08:28,380
end user like administrator it just

1763
01:08:28,380 --> 01:08:30,759
potentially hyper help them to cipher

1764
01:08:30,759 --> 01:08:32,710
why it's doing certain things that's

1765
01:08:32,710 --> 01:08:34,118
what I would say but it you don't want

1766
01:08:34,118 --> 01:08:36,969
to write your application using any of

1767
01:08:36,969 --> 01:08:40,359
this it's not reliable right um let's

1768
01:08:40,359 --> 01:08:41,350
use Postgres cuz i know how to do

1769
01:08:41,350 --> 01:08:46,359
Postgres so going back to this so

1770
01:08:46,359 --> 01:08:48,609
Postgres again we've already done the

1771
01:08:48,609 --> 01:08:50,649
compaction with the vacuum but Postgres

1772
01:08:50,649 --> 01:08:52,479
will actually let you do this you can

1773
01:08:52,479 --> 01:08:57,899
say where CT ID let me put it up sorry

1774
01:08:57,899 --> 01:09:05,218
where c tige equals and then 0 1 right

1775
01:09:05,969 --> 01:09:08,589
so I can access the tool exactly based

1776
01:09:08,589 --> 01:09:10,689
on its like stores location I don't want

1777
01:09:10,689 --> 01:09:12,250
to do this in my application because

1778
01:09:12,250 --> 01:09:15,009
again at any time the data systems

1779
01:09:15,009 --> 01:09:16,569
allowed to reorganize it I could end up

1780
01:09:16,569 --> 01:09:18,549
with a different CIT ID so it's unique

1781
01:09:18,549 --> 01:09:20,889
like you know I can uniquely identify a

1782
01:09:20,889 --> 01:09:23,020
tuple but I don't want to do that

1783
01:09:23,020 --> 01:09:26,109
because it'll I get it screwed up again

1784
01:09:26,109 --> 01:09:28,029
I think the answers in is just exposing

1785
01:09:28,029 --> 01:09:29,500
the internals of the system to allow

1786
01:09:29,500 --> 01:09:30,488
administrators to understand what's

1787
01:09:30,488 --> 01:09:32,729
going on

1788
01:09:32,729 --> 01:09:39,399
yes boom

1789
01:09:39,399 --> 01:09:40,660
his question is what happens if you have

1790
01:09:40,660 --> 01:09:44,560
a if you try to name a column with that

1791
01:09:44,560 --> 01:09:45,850
I might trying to name a table with that

1792
01:09:45,850 --> 01:09:50,170
let's see that so drop table xxx create

1793
01:09:50,170 --> 01:09:51,810
table

1794
01:09:51,810 --> 01:09:59,890
xxx ID and CT ID int look who says it'll

1795
01:09:59,890 --> 01:10:01,390
be allowed to do this yes or no

1796
01:10:01,390 --> 01:10:05,700
raise your hand yes where you hand no

1797
01:10:05,700 --> 01:10:09,420
yes you can't do that

1798
01:10:09,750 --> 01:10:14,230
let's try Oracle great table

1799
01:10:14,230 --> 01:10:22,960
xxx heidi and row ID int nope in like it

1800
01:10:22,960 --> 01:10:26,080
so yes it's a reserved name there's a

1801
01:10:26,080 --> 01:10:27,250
bunch of other things you can't like I

1802
01:10:27,250 --> 01:10:32,680
can't name actually like I can name a

1803
01:10:32,680 --> 01:10:37,740
column this is C code like sorry

1804
01:10:38,220 --> 01:10:41,920
sequel server press rest okay so let's

1805
01:10:41,920 --> 01:10:43,720
try a create table like you can't name a

1806
01:10:43,720 --> 01:10:48,180
column int I don't think no you can

1807
01:10:48,790 --> 01:10:51,899
[Music]

1808
01:10:52,210 --> 01:10:56,170
never systems do different things yeah

1809
01:10:56,170 --> 01:11:00,960
okay don't do that that's a bad idea

1810
01:11:00,960 --> 01:11:12,340
all right uh have you drawn time so so

1811
01:11:12,340 --> 01:11:14,110
we're short in time so let me quickly

1812
01:11:14,110 --> 01:11:15,690
talk about tuba layouts

1813
01:11:15,690 --> 01:11:18,909
and then that'll set up set it up what

1814
01:11:18,909 --> 01:11:22,650
we're talking about for for next class

1815
01:11:23,100 --> 01:11:26,469
so a tuple in our world it's just just a

1816
01:11:26,469 --> 01:11:29,530
sequence of bytes all right if we just

1817
01:11:29,530 --> 01:11:32,170
we get a slot all set we just write a

1818
01:11:32,170 --> 01:11:33,310
bunch of sequence of bytes and we're

1819
01:11:33,310 --> 01:11:35,170
done and so it's the job of the data to

1820
01:11:35,170 --> 01:11:37,060
be able to interpret what those bytes

1821
01:11:37,060 --> 01:11:38,710
actually mean again and that's where

1822
01:11:38,710 --> 01:11:40,000
this schema comes in so the scheme is

1823
01:11:40,000 --> 01:11:41,590
gonna say I have an int it's 32 bits

1824
01:11:41,590 --> 01:11:43,659
I've been to 64 bits so when I look at

1825
01:11:43,659 --> 01:11:45,429
my 60 might might might my sequence of

1826
01:11:45,429 --> 01:11:46,690
bytes I know how to jump to different

1827
01:11:46,690 --> 01:11:48,280
offsets to find the columns that I want

1828
01:11:48,280 --> 01:11:50,710
all right so again it just looks like

1829
01:11:50,710 --> 01:11:53,500
this and our tuple again this is like

1830
01:11:53,500 --> 01:11:55,420
the starting location within an all set

1831
01:11:55,420 --> 01:11:57,699
within our page we'll have a header keep

1832
01:11:57,699 --> 01:11:58,989
track of different things like what

1833
01:11:58,989 --> 01:12:00,670
whether you know what what transactional

1834
01:12:00,670 --> 01:12:02,920
query modify this and then we'll have

1835
01:12:02,920 --> 01:12:06,010
the actual you know the metadata about

1836
01:12:06,010 --> 01:12:07,810
things like when we have null values and

1837
01:12:07,810 --> 01:12:10,179
then are actually tuples so do we

1838
01:12:10,179 --> 01:12:12,219
typically don't need to store the

1839
01:12:12,219 --> 01:12:14,500
metadata about the tuple with in the

1840
01:12:14,500 --> 01:12:17,830
tuple itself right so when we store two

1841
01:12:17,830 --> 01:12:19,360
but we don't say hey I have four columns

1842
01:12:19,360 --> 01:12:21,190
and there are this type we store that

1843
01:12:21,190 --> 01:12:22,989
and a higher-level metadata information

1844
01:12:22,989 --> 01:12:24,969
either within the page or within the

1845
01:12:24,969 --> 01:12:27,699
catalog pages themselves you have to do

1846
01:12:27,699 --> 01:12:30,610
this in in like JSON databases or

1847
01:12:30,610 --> 01:12:33,040
schemas databases like MongoDB because

1848
01:12:33,040 --> 01:12:34,989
every single tuple every single record

1849
01:12:34,989 --> 01:12:36,489
could be different every document to be

1850
01:12:36,489 --> 01:12:38,170
different so you have to store what the

1851
01:12:38,170 --> 01:12:39,730
metadata about what it's actually inside

1852
01:12:39,730 --> 01:12:43,750
of it so the inside the tuple data

1853
01:12:43,750 --> 01:12:47,260
itself you typically store them in the

1854
01:12:47,260 --> 01:12:49,719
order that you created the table so if I

1855
01:12:49,719 --> 01:12:52,080
say you know create table ABCDE I'll

1856
01:12:52,080 --> 01:12:54,820
just usually most systems distort in the

1857
01:12:54,820 --> 01:12:56,770
order that they happened right then that

1858
01:12:56,770 --> 01:12:58,360
we got created you don't have to

1859
01:12:58,360 --> 01:12:59,830
national model says you don't have to do

1860
01:12:59,830 --> 01:13:02,080
this but typically most systems do this

1861
01:13:02,080 --> 01:13:04,120
if you get talked about sort of you know

1862
01:13:04,120 --> 01:13:05,230
in memory systems that are trying to be

1863
01:13:05,230 --> 01:13:06,070
cache efficient

1864
01:13:06,070 --> 01:13:08,290
or you can reorder this so that your

1865
01:13:08,290 --> 01:13:11,020
word aligned for cash lines but for our

1866
01:13:11,020 --> 01:13:13,800
purposes we don't care right

1867
01:13:13,800 --> 01:13:16,630
so the last thing we talked about was

1868
01:13:16,630 --> 01:13:18,850
his question before about storing data

1869
01:13:18,850 --> 01:13:21,730
from different tables inside the same

1870
01:13:21,730 --> 01:13:24,670
page and I said most systems don't do

1871
01:13:24,670 --> 01:13:29,410
this and the the reason it the reason

1872
01:13:29,410 --> 01:13:31,170
why you don't wanna do this is because

1873
01:13:31,170 --> 01:13:33,220
again if you want the things to be

1874
01:13:33,220 --> 01:13:35,020
self-contained you don't want a bunch of

1875
01:13:35,020 --> 01:13:36,070
extra metadata about these different

1876
01:13:36,070 --> 01:13:38,740
tables where it does show up is when you

1877
01:13:38,740 --> 01:13:41,850
de normalize tables or pre join tables

1878
01:13:41,850 --> 01:13:44,110
so we're not talking about normal forms

1879
01:13:44,110 --> 01:13:45,550
or functional dependencies in this class

1880
01:13:45,550 --> 01:13:47,620
you don't know yet but you'll thank me

1881
01:13:47,620 --> 01:13:49,030
when you're older because they're

1882
01:13:49,030 --> 01:13:49,690
terrible

1883
01:13:49,690 --> 01:13:51,190
people cry every single time you try to

1884
01:13:51,190 --> 01:13:52,630
teach them most database classes to

1885
01:13:52,630 --> 01:13:53,980
teach them I don't think they're

1886
01:13:53,980 --> 01:13:56,710
important I

1887
01:13:56,710 --> 01:13:58,240
nobody does this in reality in the

1888
01:13:58,240 --> 01:14:00,760
practice maybe some DBAs do but but

1889
01:14:00,760 --> 01:14:03,010
almost nobody does so for that reason

1890
01:14:03,010 --> 01:14:05,530
when I first taught this class we did

1891
01:14:05,530 --> 01:14:07,710
two whole lectures on normal forms

1892
01:14:07,710 --> 01:14:10,030
we don't need to do that you just need

1893
01:14:10,030 --> 01:14:11,560
to know what they exist that they that

1894
01:14:11,560 --> 01:14:13,600
it exists and what it means so that

1895
01:14:13,600 --> 01:14:15,250
that's what this one slide is so we're

1896
01:14:15,250 --> 01:14:16,630
gonna Katz like two lectures in one

1897
01:14:16,630 --> 01:14:17,050
slide

1898
01:14:17,050 --> 01:14:20,740
okay so normalization is basically how

1899
01:14:20,740 --> 01:14:22,540
would we split up our database across

1900
01:14:22,540 --> 01:14:24,340
different tables and this sort of

1901
01:14:24,340 --> 01:14:25,630
naturally happens when you have foreign

1902
01:14:25,630 --> 01:14:28,510
keys like I have artists and albums I

1903
01:14:28,510 --> 01:14:30,160
could have you know foreign keys sort of

1904
01:14:30,160 --> 01:14:33,790
break them up and so we do this sort of

1905
01:14:33,790 --> 01:14:35,410
ins naturally as we design our

1906
01:14:35,410 --> 01:14:37,720
application now there's some cases where

1907
01:14:37,720 --> 01:14:40,540
we actually want to embed one table

1908
01:14:40,540 --> 01:14:43,030
inside another right if we want to avoid

1909
01:14:43,030 --> 01:14:44,920
the overhead it may be doing a join we

1910
01:14:44,920 --> 01:14:46,480
can say here's all the albums that

1911
01:14:46,480 --> 01:14:48,190
artists put out which is inline them in

1912
01:14:48,190 --> 01:14:51,010
in its own tuple and in that case within

1913
01:14:51,010 --> 01:14:53,800
a single page we could have data from

1914
01:14:53,800 --> 01:14:55,150
two different tables packed in the sign

1915
01:14:55,150 --> 01:14:57,280
beside the same page so let's look

1916
01:14:57,280 --> 01:14:58,660
really simple example I have two tables

1917
01:14:58,660 --> 01:15:00,670
foo and bar bar has a foreign key

1918
01:15:00,670 --> 01:15:03,100
dependency reference to the food table

1919
01:15:03,100 --> 01:15:06,250
so normally I would store my tuples like

1920
01:15:06,250 --> 01:15:08,680
this I would store them it's completely

1921
01:15:08,680 --> 01:15:10,840
separate all the data for the bar tables

1922
01:15:10,840 --> 01:15:12,640
stored in its page and all the data for

1923
01:15:12,640 --> 01:15:14,040
the food table is stored in this page

1924
01:15:14,040 --> 01:15:16,720
but if most of the time I'm trying to

1925
01:15:16,720 --> 01:15:18,280
join these two tables together for every

1926
01:15:18,280 --> 01:15:19,780
query I want to join these two tables

1927
01:15:19,780 --> 01:15:22,360
right get me all the foods for give me

1928
01:15:22,360 --> 01:15:24,849
all the bars for a given foo then maybe

1929
01:15:24,849 --> 01:15:27,940
what I want to do is just embed the bar

1930
01:15:27,940 --> 01:15:30,780
tuples directly inside of the food table

1931
01:15:30,780 --> 01:15:33,900
so now if you go back here like I had I

1932
01:15:33,900 --> 01:15:38,170
was replicating the the the the a

1933
01:15:38,170 --> 01:15:40,630
attribute for every single bar tuple but

1934
01:15:40,630 --> 01:15:42,190
now if I pack it inside of it I don't

1935
01:15:42,190 --> 01:15:44,159
need to repeat it I just have the

1936
01:15:44,159 --> 01:15:46,030
columns that are unique for the other

1937
01:15:46,030 --> 01:15:48,639
table right so this is called

1938
01:15:48,639 --> 01:15:51,219
denormalization another I think about

1939
01:15:51,219 --> 01:15:52,989
it's like pre joining I'm packing two

1940
01:15:52,989 --> 01:15:54,460
bowls inside of each other I can either

1941
01:15:54,460 --> 01:15:56,499
do this logically by rewriting my

1942
01:15:56,499 --> 01:15:57,969
application and creating tables that way

1943
01:15:57,969 --> 01:15:59,199
or I can do this physically which is

1944
01:15:59,199 --> 01:16:00,940
what we care about here and underneath

1945
01:16:00,940 --> 01:16:02,800
the covers we're storing our pages like

1946
01:16:02,800 --> 01:16:04,900
this the application can still tell us

1947
01:16:04,900 --> 01:16:07,179
hey I have two separate tables but

1948
01:16:07,179 --> 01:16:08,739
underneath the covers and our pages will

1949
01:16:08,739 --> 01:16:09,969
actually combine them attacking them

1950
01:16:09,969 --> 01:16:14,380
together right so this is the only time

1951
01:16:14,380 --> 01:16:16,389
I think that systems actually try to

1952
01:16:16,389 --> 01:16:17,920
store data from two different tables

1953
01:16:17,920 --> 01:16:21,429
inside the same tuples okay this is not

1954
01:16:21,429 --> 01:16:23,590
a new idea it's super old goes back to

1955
01:16:23,590 --> 01:16:26,349
the 1970s IBM first invented this when

1956
01:16:26,349 --> 01:16:27,849
they invented the first database system

1957
01:16:27,849 --> 01:16:29,380
system or the first relational database

1958
01:16:29,380 --> 01:16:33,070
system at IBM but it turned out to be a

1959
01:16:33,070 --> 01:16:34,809
huge pick to maintain in the software

1960
01:16:34,809 --> 01:16:36,880
and then they abandon it when they went

1961
01:16:36,880 --> 01:16:39,340
off and made db2 so system R was the

1962
01:16:39,340 --> 01:16:40,269
first relation one of the first

1963
01:16:40,269 --> 01:16:41,289
relational databases that are out there

1964
01:16:41,289 --> 01:16:43,150
but they never commercialized it never

1965
01:16:43,150 --> 01:16:44,650
sold it but they took up some of the

1966
01:16:44,650 --> 01:16:46,840
code in the 1980s and created db2 which

1967
01:16:46,840 --> 01:16:49,570
is still around today and so it actually

1968
01:16:49,570 --> 01:16:51,639
is showing up in more modern systems

1969
01:16:51,639 --> 01:16:54,909
today so if you get cloud spanner from

1970
01:16:54,909 --> 01:16:56,889
Google right if you have it when you

1971
01:16:56,889 --> 01:16:58,150
defined a proto protobufs

1972
01:16:58,150 --> 01:17:00,610
API you can actually pack in it'll pack

1973
01:17:00,610 --> 01:17:02,650
in the two different tables together in

1974
01:17:02,650 --> 01:17:04,599
the same tuple there was a start up a

1975
01:17:04,599 --> 01:17:06,159
long time ago ten years ago called a

1976
01:17:06,159 --> 01:17:08,409
Caban that basically sold a storage

1977
01:17:08,409 --> 01:17:09,670
engine for my sequel that did this kind

1978
01:17:09,670 --> 01:17:11,499
of denormalization automatically they

1979
01:17:11,499 --> 01:17:13,030
got bought by foundation BB even a

1980
01:17:13,030 --> 01:17:15,579
foundation DB got bought by Apple

1981
01:17:15,579 --> 01:17:17,469
so a coupon doesn't exist anymore and

1982
01:17:17,469 --> 01:17:19,929
then a bunch of these document databases

1983
01:17:19,929 --> 01:17:21,789
or JSON databases are essentially doing

1984
01:17:21,789 --> 01:17:23,829
the same thing right when you define

1985
01:17:23,829 --> 01:17:25,510
your JSON document you can pre join a

1986
01:17:25,510 --> 01:17:28,389
PAC in related attributes within the

1987
01:17:28,389 --> 01:17:30,429
JSON document itself and that's

1988
01:17:30,429 --> 01:17:32,929
essentially doing the same thing

1989
01:17:32,929 --> 01:17:35,449
okay that again that's the only time

1990
01:17:35,449 --> 01:17:37,130
people actually store tuples from

1991
01:17:37,130 --> 01:17:39,130
different tables inside the same pages

1992
01:17:39,130 --> 01:17:42,560
okay so we covered this and we're done

1993
01:17:42,560 --> 01:17:45,739
all right so again what do we talk about

1994
01:17:45,739 --> 01:17:48,050
today databases are organized in pages

1995
01:17:48,050 --> 01:17:49,280
they're different ways to track the

1996
01:17:49,280 --> 01:17:51,320
pages that are in our files and then

1997
01:17:51,320 --> 01:17:52,640
within this pages we can store them

1998
01:17:52,640 --> 01:17:53,870
different ways and store our tuples

1999
01:17:53,870 --> 01:17:57,409
inside the pages differently so for the

2000
01:17:57,409 --> 01:17:59,690
first assignment first programming

2001
01:17:59,690 --> 01:18:01,489
project we will already take care of the

2002
01:18:01,489 --> 01:18:03,980
page layout for you all right so well

2003
01:18:03,980 --> 01:18:05,300
and we already written the disk manager

2004
01:18:05,300 --> 01:18:08,030
for you it's when we get into the second

2005
01:18:08,030 --> 01:18:09,320
project you're actually gonna have to

2006
01:18:09,320 --> 01:18:11,480
define what the page layout is for your

2007
01:18:11,480 --> 01:18:12,980
your for your index that you're gonna

2008
01:18:12,980 --> 01:18:17,120
build okay it's next class we'll talk

2009
01:18:17,120 --> 01:18:18,890
about how you actually represent values

2010
01:18:18,890 --> 01:18:20,239
inside the tuples so we'll go eat now

2011
01:18:20,239 --> 01:18:22,280
inside of the bike sequences for two

2012
01:18:22,280 --> 01:18:24,380
bowls you talk about what the axial

2013
01:18:24,380 --> 01:18:26,090
average look like and then we'll talk

2014
01:18:26,090 --> 01:18:27,620
about storage models how are we actually

2015
01:18:27,620 --> 01:18:31,730
gonna represent how we organize two

2016
01:18:31,730 --> 01:18:35,000
posts within a within a table itself all

2017
01:18:35,000 --> 01:18:39,909
right any questions yes

2018
01:18:40,740 --> 01:18:43,810
[Music]

2019
01:18:44,559 --> 01:18:47,210
her question is which is a awesome

2020
01:18:47,210 --> 01:18:49,190
question what is test-driven development

2021
01:18:49,190 --> 01:18:50,780
look like for databases how do I know

2022
01:18:50,780 --> 01:18:54,559
I'm running queries correctly huge topic

2023
01:18:54,559 --> 01:18:56,570
let's talk about afterwards that's I'm

2024
01:18:56,570 --> 01:18:57,980
extremely interested in that I'm

2025
01:18:57,980 --> 01:18:59,360
actually trying to hire someone to do

2026
01:18:59,360 --> 01:19:12,800
that for us yesterday okay guys see you

2027
01:19:12,800 --> 01:19:36,949
on Monday ricochet jelly hit the deli

2028
01:19:36,949 --> 01:19:46,639
food usually rap is like don't drink it

2029
01:19:46,639 --> 01:19:50,570
you can't and if the sake don't know

2030
01:19:50,570 --> 01:19:53,530
your phone can of paint

