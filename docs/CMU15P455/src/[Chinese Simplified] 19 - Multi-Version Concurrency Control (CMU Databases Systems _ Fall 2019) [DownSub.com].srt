1
00:00:03,640 --> 00:00:13,140
[音乐]

2
00:00:17,350 --> 00:00:19,850
嗨，我叫 Dana，

3
00:00:19,850 --> 00:00:22,880
所以如果安迪的博士生，我是另一个人，

4
00:00:22,880 --> 00:00:25,189
并且可能

5
00:00:25,189 --> 00:00:27,140
是他回来之前最后一个向您展示的博士生，

6
00:00:27,140 --> 00:00:30,829
所以今天我

7
00:00:30,829 --> 00:00:33,079
将展示您的光

8
00:00:33,079 --> 00:00:36,340
关于并发控制的最后一课

9
00:00:36,340 --> 00:00:39,170
所以在我们开始之前有几个

10
00:00:39,170 --> 00:00:42,620
提醒，第一个是项目三是

11
00:00:42,620 --> 00:00:45,430
在 11 月 17 日星期日午夜之前到期

12
00:00:45,430 --> 00:00:48,440
我们还发布了上周的作业

13
00:00:48,440 --> 00:00:51,050
，然后将在 11 月 13 日

14
00:00:51,050 --> 00:00:55,730
午夜之前到期在我们开始之前的任何问题

15
00:00:55,730 --> 00:01:05,239
好的，所以今天我们

16
00:01:05,239 --> 00:01:06,790
将讨论多版本并发

17
00:01:06,790 --> 00:01:10,760
控制，请确保我只是在这里，

18
00:01:10,760 --> 00:01:12,829
所以我想指出的

19
00:01:12,829 --> 00:01:15,710
关于多版本并发控制的第一件事

20
00:01:15,710 --> 00:01:19,250
是它的名称用词不当，这

21
00:01:19,250 --> 00:01:21,860
可能会引起一些混淆 因为它

22
00:01:21,860 --> 00:01:23,350
实际上

23
00:01:23,350 --> 00:01:25,280
不是像您

24
00:01:25,280 --> 00:01:26,869
在过去两堂课中学习的并发控制协议，

25
00:01:26,869 --> 00:01:30,170
即时间戳或 OCC 和

26
00:01:30,170 --> 00:01:32,720
两阶段锁定期间，

27
00:01:32,720 --> 00:01:34,880
而是一种构建

28
00:01:34,880 --> 00:01:36,920
当您通过维护多个版本运行并发事务时，请

29
00:01:36,920 --> 00:01:39,829


30
00:01:39,829 --> 00:01:43,009
回想一下

31
00:01:43,009 --> 00:01:44,930
上周您讨论的乐观

32
00:01:44,930 --> 00:01:47,560
货币控制，其中事务

33
00:01:47,560 --> 00:01:50,509
维护一个私有工作区，并且无论何时

34
00:01:50,509 --> 00:01:53,119
他们读取或写入对象，它都会

35
00:01:53,119 --> 00:01:55,280
将该对象复制到该私有

36
00:01:55,280 --> 00:01:58,850
工作区中 多版本

37
00:01:58,850 --> 00:02:00,619
并发控制类似于这个

38
00:02:00,619 --> 00:02:03,140
想法，除了这里不是

39
00:02:03,140 --> 00:02:06,140
每个事务都有一个私人工作区

40
00:02:06,140 --> 00:02:07,820
，我们在其中维护这些不同的

41
00:02:07,820 --> 00:02:10,250
版本，我们现在将拥有该

42
00:02:10,250 --> 00:02:12,430
版本作为全局数据库的一部分

43
00:02:12,430 --> 00:02:14,630
，我们将确定

44
00:02:14,630 --> 00:02:17,540
它的某些版本是否

45
00:02:17,540 --> 00:02:21,040
对特定事务可见，

46
00:02:22,770 --> 00:02:28,620
因此 MVCC 被几乎所有

47
00:02:28,620 --> 00:02:30,720
在过去十年中构建的新数据库系统或它的

48
00:02:30,720 --> 00:02:34,200
某些变体都使用，

49
00:02:34,200 --> 00:02:35,130
但这不是一个新想法，

50
00:02:35,130 --> 00:02:39,210
因此它实际上已经有几十年历史

51
00:02:39,210 --> 00:02:41,640
了 第一次提到这个想法是

52
00:02:41,640 --> 00:02:45,470
在 1978 年麻省理工学院博士生的一篇论文中，

53
00:02:45,470 --> 00:02:52,110
所以直到 80 年代初才出现

54
00:02:52,110 --> 00:02:54,710
它的第一个隐含

55
00:02:54,710 --> 00:02:57,090
实现实际上

56
00:02:57,090 --> 00:02:59,460
出来了，那些实现来自一家名为 Dec 的公司

57
00:02:59,460 --> 00:03:03,030
，它们被称为我们的 DB VM

58
00:03:03,030 --> 00:03:06,060
，它代表

59
00:03:06,060 --> 00:03:08,910
VM 或 VAX 的关系数据库，这是一个旧的

60
00:03:08,910 --> 00:03:12,300
操作系统，另一个产品被称为

61
00:03:12,300 --> 00:03:15,540
inter base，所以 Dec 曾经是一家大型

62
00:03:15,540 --> 00:03:18,450
计算机公司，

63
00:03:18,450 --> 00:03:21,810
在 90 年代后期被康柏

64
00:03:21,810 --> 00:03:23,970
收购，几年后又被惠普收购，因此它

65
00:03:23,970 --> 00:03:26,430
不再存在，但它做了一些重大的

66
00:03:26,430 --> 00:03:31,400
开创性工作和数据库系统，

67
00:03:31,400 --> 00:03:34,230
因此我们的 DB VM 和 他们的基础是

68
00:03:34,230 --> 00:03:36,900
由一个叫 Jim Starkey 的人建立的，他

69
00:03:36,900 --> 00:03:39,540
也被认为是

70
00:03:39,540 --> 00:03:43,530
blob 和触发器的发明者，所以他是一个大问题，

71
00:03:43,530 --> 00:03:46,650
后来他继续共同创立了 nuodb，这是

72
00:03:46,650 --> 00:03:48,420
一个新的数据库初创公司，它也

73
00:03:48,420 --> 00:03:54,720
恰好在 BCC 中使用 所以 12 月我们的数据库虚拟

74
00:03:54,720 --> 00:03:56,850
机被 Oracle 收购，现在被

75
00:03:56,850 --> 00:04:07,100
称为 oracle rdb，它是一个内部

76
00:04:07,100 --> 00:04:11,040
基础，最终在 12 月被出售，它

77
00:04:11,040 --> 00:04:11,910
经过了几家不同的控股

78
00:04:11,910 --> 00:04:14,970
公司，最后被开源

79
00:04:14,970 --> 00:04:17,279
，所以现在它被称为 一个不同的

80
00:04:17,279 --> 00:04:20,488
名字，现在它被称为 Firebird，所以它

81
00:04:20,488 --> 00:04:22,560
可能不像我的续集或 Postgres 那样出名，

82
00:04:22,560 --> 00:04:24,810
但那里有最早

83
00:04:24,810 --> 00:04:29,280
的开源数据库之一，安迪

84
00:04:29,280 --> 00:04:30,900
从去年开始就有这个有趣的事实

85
00:04:30,900 --> 00:04:33,210
，所以我会 继续

86
00:04:33,210 --> 00:04:35,430
说吧，如果您曾经想知道

87
00:04:35,430 --> 00:04:39,030
为什么 Firefox 网络浏览器的火

88
00:04:39,030 --> 00:04:41,729
名为 Firefox，那是因为它们

89
00:04:41,729 --> 00:04:44,340
最初被称为 Phoenix，但后来他们

90
00:04:44,340 --> 00:04:45,930
不得不更改该名称，因为它

91
00:04:45,930 --> 00:04:47,639
与您知道的其他系统或其他系统发生冲突

92
00:04:47,639 --> 00:04:50,639
产品，所以他们将其更改为

93
00:04:50,639 --> 00:04:52,319
Firebird 但随后他们不得不再次更改它

94
00:04:52,319 --> 00:04:53,759
，因为它与此

95
00:04:53,759 --> 00:04:56,460
数据库系统发生冲突 所以最终它被称为

96
00:04:56,460 --> 00:05:06,870
Firefox 所以主要的好处再次像

97
00:05:06,870 --> 00:05:08,970
你必须了解的关于 MVCC 的

98
00:05:08,970 --> 00:05:11,699
内容是作者不会阻止读者

99
00:05:11,699 --> 00:05:14,060
并且读取器不会阻止

100
00:05:14,060 --> 00:05:16,050


101
00:05:16,050 --> 00:05:18,300
写入器，因此只有当您有两个事务试图同时将它写入

102
00:05:18,300 --> 00:05:20,699
对象时，它们才必须

103
00:05:20,699 --> 00:05:23,240
回退并依赖于两个

104
00:05:23,240 --> 00:05:25,259
并发控制协议之一

105
00:05:25,259 --> 00:05:28,830
- 相位锁定，所以

106
00:05:28,830 --> 00:05:30,120
你只需要在写写冲突时才需要这样做，

107
00:05:30,120 --> 00:05:33,750
所以在高层次上，

108
00:05:33,750 --> 00:05:36,870
它的工作方式是我们将

109
00:05:36,870 --> 00:05:39,449
在事务到达系统时为事务分配时间戳

110
00:05:39,449 --> 00:05:41,759
，然后我们开始

111
00:05:41,759 --> 00:05:44,669
为它提供数据库的一致快照，

112
00:05:44,669 --> 00:05:47,039
因为它在该事务到达时就存在，

113
00:05:47,039 --> 00:05:53,039
因此这

114
00:05:53,039 --> 00:05:55,830
意味着他们不会看到

115
00:05:55,830 --> 00:05:58,139


116
00:05:58,139 --> 00:06:00,030
尚未在其快照中提交的尚未提交的事务的更改

117
00:06:00,030 --> 00:06:04,949
，只是为了澄清这一点 是一个

118
00:06:04,949 --> 00:06:06,599
虚拟快照，所以它不

119
00:06:06,599 --> 00:06:09,330
应该与您是否知道物理

120
00:06:09,330 --> 00:06:11,490
快照或将完整

121
00:06:11,490 --> 00:06:14,009
数据库复制到另一个位置然后

122
00:06:14,009 --> 00:06:16,020
在其上运行该事务相混淆，所以

123
00:06:16,020 --> 00:06:21,810
这又是一个 嗯，这只是虚拟的，因此 MVCC

124
00:06:21,810 --> 00:06:23,430
对读取非常有用 -only

125
00:06:23,430 --> 00:06:26,880
事务，因为后续方言

126
00:06:26,880 --> 00:06:29,639
允许您声明事务何时

127
00:06:29,639 --> 00:06:32,909
是只读的，如果您这样做，那么

128
00:06:32,909 --> 00:06:35,940
数据库系统不需要您

129
00:06:35,940 --> 00:06:37,770
获取任何锁或维护读写

130
00:06:37,770 --> 00:06:41,310
集，这 再次工作，因为它

131
00:06:41,310 --> 00:06:43,680
具有一致的快照，并且只会看到

132
00:06:43,680 --> 00:06:45,750


133
00:06:45,750 --> 00:06:47,059
它开始时存在的更改

134
00:06:47,059 --> 00:06:48,439
，这使得这些只读

135
00:06:48,439 --> 00:06:51,289
事务非常有效并且

136
00:06:51,289 --> 00:06:56,199
执行速度也非常快是的，

137
00:06:57,039 --> 00:07:01,159
我什至就像我一分钟

138
00:07:01,159 --> 00:07:04,029
前提到的那样 它本质上只是

139
00:07:04,029 --> 00:07:06,249
像版本表一样维护我们的

140
00:07:06,249 --> 00:07:08,779
版本使它成为数据信息，

141
00:07:08,779 --> 00:07:10,399
它与 OCC 非常相似，您

142
00:07:10,399 --> 00:07:12,049
可以在其中了解读取和写入集，

143
00:07:12,049 --> 00:07:14,599
我们将

144
00:07:14,599 --> 00:07:15,859
在以下幻灯片中详细介绍

145
00:07:15,859 --> 00:07:18,289
这一点，这是 将成为本次讲座的主题

146
00:07:18,289 --> 00:07:35,599
是的 所以这是我们在

147
00:07:35,599 --> 00:07:37,849
这里谈论的两次读取 他们将读取

148
00:07:37,849 --> 00:07:41,179
相同版本的相同快照 所以

149
00:07:41,179 --> 00:07:43,639
快照你知道它更常见我

150
00:07:43,639 --> 00:07:46,129
认为被称为你

151
00:07:46,129 --> 00:07:55,099
知道元组或数据库的版本 可以很好地反对，

152
00:07:55,099 --> 00:07:58,699
所以如果你能容忍我，

153
00:07:58,699 --> 00:08:01,639
就像你知道的三分钟可能

154
00:08:01,639 --> 00:08:03,709
更少，我们实际上这是

155
00:08:03,709 --> 00:08:07,039
我们要讨论的第一件事，

156
00:08:07,039 --> 00:08:08,989
我会回答你的任何其他问题

157
00:08:08,989 --> 00:08:23,389
好吧，所以只是

158
00:08:23,389 --> 00:08:25,789
在幻灯片上结束 MVCC 的另一个优点

159
00:08:25,789 --> 00:08:28,969
是您能够支持

160
00:08:28,969 --> 00:08:33,500
称为时间旅行查询的内容，因此这些

161
00:08:33,500 --> 00:08:35,929
查询实际上让您可以询问

162
00:08:35,929 --> 00:08:38,539
数据库系统，例如数据库的

163
00:08:38,539 --> 00:08:40,188
状态 你知道三

164
00:08:40,188 --> 00:08:41,029
年前的

165
00:08:41,029 --> 00:08:44,720
三天前，使用这些并

166
00:08:44,720 --> 00:08:46,610
使用这个版本，他们实际上可以

167
00:08:46,610 --> 00:08:51,579
回答这些类型的查询，

168
00:08:55,570 --> 00:08:58,269
所以时间旅行

169
00:08:58,269 --> 00:09:02,410
查询的想法首先是 Postgres 的想法

170
00:09:02,410 --> 00:09:04,779
，它起源

171
00:09:04,779 --> 00:09:07,839
于 1980 年代的 Postgres 但明信片 实际上

172
00:09:07,839 --> 00:09:12,149
从他们当前的产品中删除了这些时间旅行查询，

173
00:09:12,149 --> 00:09:15,759


174
00:09:15,759 --> 00:09:18,370
就像你认识

175
00:09:18,370 --> 00:09:20,259


176
00:09:20,259 --> 00:09:26,529
学术界以外的人

177
00:09:26,529 --> 00:09:29,139


178
00:09:29,139 --> 00:09:32,410


179
00:09:32,410 --> 00:09:35,230
一样 旅行查询是你永远不会

180
00:09:35,230 --> 00:09:37,959
扔掉旧版本，所以你永远不会垃圾

181
00:09:37,959 --> 00:09:41,350
收集，所以随着时间的推移，你会

182
00:09:41,350 --> 00:09:42,940
知道越来越多的交易

183
00:09:42,940 --> 00:09:45,699
提交您的磁盘库将

184
00:09:45,699 --> 00:09:48,880
很快被填满，最终

185
00:09:48,880 --> 00:09:51,610
它会被填满，并且可能

186
00:09:51,610 --> 00:09:53,310
很快取决于您的

187
00:09:53,310 --> 00:09:57,819
交易速度，另一件事是

188
00:09:57,819 --> 00:10:00,430


189
00:10:00,430 --> 00:10:02,709
像您这样的许多应用程序并不真正需要时间旅行查询

190
00:10:02,709 --> 00:10:05,350
难道你永远不会真的看你永远不会

191
00:10:05,350 --> 00:10:07,089
去一个网站说好的 我

192
00:10:07,089 --> 00:10:08,740
想知道这个网页三天前是什么样子

193
00:10:08,740 --> 00:10:10,810
我不是最常用的

194
00:10:10,810 --> 00:10:15,029
案例 但安迪提到这就像

195
00:10:15,029 --> 00:10:17,199
这些的一个常见用例 时间

196
00:10:17,199 --> 00:10:19,899
旅行查询是在金融

197
00:10:19,899 --> 00:10:24,370
行业，所以原因是因为你

198
00:10:24,370 --> 00:10:27,310
知道 - 我知道追求你知道

199
00:10:27,310 --> 00:10:29,230


200
00:10:29,230 --> 00:10:30,670
他们必须遵守的任何规则和规定，他们必须

201
00:10:30,670 --> 00:10:32,199
在过去

202
00:10:32,199 --> 00:10:36,430
七年的交易历史中实际维护，所以这些

203
00:10:36,430 --> 00:10:38,350
时间旅行查询实际上 允许

204
00:10:38,350 --> 00:10:42,370
他们很容易地查询数据库并

205
00:10:42,370 --> 00:10:45,220
弄清楚为什么你知道一些钱

206
00:10:45,220 --> 00:10:46,899
他们的总收入是

207
00:10:46,899 --> 00:10:49,510
多少或者他们想要查询的任何你

208
00:10:49,510 --> 00:10:52,920
在过去七年中知道的 好几年

209
00:10:55,680 --> 00:10:58,720
了所以嗯，接下来的几张幻灯片

210
00:10:58,720 --> 00:11:01,420
我们将讨论两个例子，

211
00:11:01,420 --> 00:11:03,070


212
00:11:03,070 --> 00:11:07,140
在我们开始之前我真正想强调的是 MVCC

213
00:11:07,140 --> 00:11:09,040
独立于并发控制

214
00:11:09,040 --> 00:11:11,200
协议，所以这些

215
00:11:11,200 --> 00:11:13,870
例子的目的只是为了基本上展示 你

216
00:11:13,870 --> 00:11:18,040
我们如何知道表中的更新版本

217
00:11:18,040 --> 00:11:21,810
和时间戳，并且

218
00:11:21,810 --> 00:11:25,390
基本上就像我们如何确定

219
00:11:25,390 --> 00:11:30,940
哪个版本我们如何确定

220
00:11:30,940 --> 00:11:34,900
哪个版本是多么抱歉 - 对

221
00:11:34,900 --> 00:11:36,400
特定事务可见正确哪个

222
00:11:36,400 --> 00:11:37,960
版本的元组是物理是

223
00:11:37,960 --> 00:11:42,280
可见的所以这个 第一个例子我们将

224
00:11:42,280 --> 00:11:46,270
看到这是如何工作的，所以

225
00:11:46,270 --> 00:11:48,100
现在首先要指出的是

226
00:11:48,100 --> 00:11:51,100
，现在我们有这个版本字段，

227
00:11:51,100 --> 00:11:52,660
所以我们可以在这个版本

228
00:11:52,660 --> 00:11:56,500
字段中看到，但它被分配为零所以

229
00:11:56,500 --> 00:12:00,190
这意味着对象日 版本零正确，

230
00:12:00,190 --> 00:12:02,680
因此我们可以假设其他一些

231
00:12:02,680 --> 00:12:05,290
事务已将值一

232
00:12:05,290 --> 00:12:07,810
二三写入数据库，并且

233
00:12:07,810 --> 00:12:10,630
无论吸引力事务如何将

234
00:12:10,630 --> 00:12:12,790
时间分配为零时间戳

235
00:12:12,790 --> 00:12:16,030
d 我们将在一秒钟内讨论为什么 所以

236
00:12:16,030 --> 00:12:19,690
我们还有开始和结束字段

237
00:12:19,690 --> 00:12:22,030
所以这些只是时间戳

238
00:12:22,030 --> 00:12:23,230
如果它们是逻辑物理

239
00:12:23,230 --> 00:12:26,680
混合并不重要 只要你知道它们

240
00:12:26,680 --> 00:12:29,589
总是增加和跟随 另一个

241
00:12:29,589 --> 00:12:32,830
你知道，我猜我们的民谣

242
00:12:32,830 --> 00:12:34,360
时间戳就像你在

243
00:12:34,360 --> 00:12:44,240
过去的几堂课中学到的一样，

244
00:12:44,240 --> 00:12:47,360
所以让我们开始吧，当一个新的交易

245
00:12:47,360 --> 00:12:49,759
到达进行交易时，我们将

246
00:12:49,759 --> 00:12:52,459
查看交易 t1 和 t2 所以

247
00:12:52,459 --> 00:12:55,999
这里 T t1 到达和 它被分配了一个

248
00:12:55,999 --> 00:13:00,740
时间戳 1 所以现在我们

249
00:13:00,740 --> 00:13:02,269
要开始了所以我们要做的第一件事

250
00:13:02,269 --> 00:13:05,740
就是我读了 a 所以

251
00:13:05,740 --> 00:13:08,079
我们要做的是我们要

252
00:13:08,079 --> 00:13:11,569
考虑你 知道时间事务一旦

253
00:13:11,569 --> 00:13:13,339
时间戳为 1，我们

254
00:13:13,339 --> 00:13:15,939
将查看我们的表并

255
00:13:15,939 --> 00:13:20,389
通过尝试查找来找出哪个元组对它可见

256
00:13:20,389 --> 00:13:23,240


257
00:13:23,240 --> 00:13:25,009


258
00:13:25,009 --> 00:13:27,619
并结束 所以在这个

259
00:13:27,619 --> 00:13:32,209
例子中开始是 0 时间

260
00:13:32,209 --> 00:13:34,670
步长是 1 介于 0 和结尾之间，这

261
00:13:34,670 --> 00:13:36,889
是无穷大，所以它会

262
00:13:36,889 --> 00:13:41,259
继续并繁殖版本 0

263
00:13:41,259 --> 00:13:44,869
好吧，所以现在我们有了事务 t2

264
00:13:44,869 --> 00:13:46,910
，我们将为其分配时间戳

265
00:13:46,910 --> 00:13:50,119
，所以我们要做的第一件事 这里

266
00:13:50,119 --> 00:13:53,720
是我们想要写一个所以此时

267
00:13:53,720 --> 00:13:55,269
我们要做的是我们将

268
00:13:55,269 --> 00:14:00,199
创建一个全新版本的 a

269
00:14:00,199 --> 00:14:02,389
它将是 1 对因为我们

270
00:14:02,389 --> 00:14:04,420
只是增加版本计数器

271
00:14:04,420 --> 00:14:09,949
和对等等 我们在

272
00:14:09,949 --> 00:14:11,569
这里

273
00:14:11,569 --> 00:14:14,740
要做的是将开始时间戳设置为 t2

274
00:14:14,740 --> 00:14:17,600
的时间戳 酶样本再次设置为

275
00:14:17,600 --> 00:14:19,490
无穷大 然后我们要做的最后一

276
00:14:19,490 --> 00:14:21,199
件事是我们要更新

277
00:14:21,199 --> 00:14:26,029
版本 0 的结束

278
00:14:26,029 --> 00:14:29,959
时间戳也是为事务 2 写入的时间戳，

279
00:14:29,959 --> 00:14:35,660
所以你可能已经

280
00:14:35,660 --> 00:14:38,319
注意到我们到目前为止缺少的一件事

281
00:14:38,319 --> 00:14:41,029
就像

282
00:14:41,029 --> 00:14:42,829
我们之前拥有的信息 我们

283
00:14:42,829 --> 00:14:44,809
在此交易之前说桌子

284
00:14:44,809 --> 00:14:46,339
弹出我们缺少的一件事

285
00:14:46,339 --> 00:14:47,809
是我们做 不知道数据库

286
00:14:47,809 --> 00:14:50,299
中事务的当前状态，

287
00:14:50,299 --> 00:14:53,919
例如，您知道

288
00:14:53,919 --> 00:14:55,939
此处的事务当前处于活动状态，

289
00:14:55,939 --> 00:14:57,830
但是如果它们中止，您知道该怎么办，那么如果中止正确

290
00:14:57,830 --> 00:14:59,210
，则必须返回

291
00:14:59,210 --> 00:15:03,530
并相应地反转时间戳

292
00:15:03,530 --> 00:15:13,880
正如您

293
00:15:13,880 --> 00:15:16,790
在此处看到的，此时我们将开始

294
00:15:16,790 --> 00:15:19,010
填写交易状态表

295
00:15:19,010 --> 00:15:20,840
，此时两个交易都

296
00:15:20,840 --> 00:15:24,260
处于活动状态，然后最后我们将

297
00:15:24,260 --> 00:15:27,350
在 a 上进行此读取，因此它将读取什么版本的

298
00:15:27,350 --> 00:15:34,220
任何人，嘿子- 零，

299
00:15:34,220 --> 00:15:36,440
因为它的时间戳仍然位于

300
00:15:36,440 --> 00:15:39,710
这里的开始和结束之间，所以

301
00:15:39,710 --> 00:15:42,850
它会继续读取版本 a0o

302
00:15:42,850 --> 00:15:46,880
，最后它会提交，所以在

303
00:15:46,880 --> 00:15:48,890
提交后的最后，

304
00:15:48,890 --> 00:15:50,990
然后事务 t2 将到来，它将

305
00:15:50,990 --> 00:15:53,840
更新状态表，我们 最终可以把

306
00:15:53,840 --> 00:15:59,960
它吹走，所以对于第二个

307
00:15:59,960 --> 00:16:02,480
例子，我们将从

308
00:16:02,480 --> 00:16:04,070
相同的设置开始，所以我们

309
00:16:04,070 --> 00:16:08,260
有时间戳为 1 的事务 t1 和

310
00:16:08,260 --> 00:16:10,190
事务 t2 我们分配的

311
00:16:10,190 --> 00:16:13,310
时间戳为 2 并且它

312
00:16:13,310 --> 00:16:17,900
在数据库表中保持相同，到目前为止

313
00:16:17,900 --> 00:16:20,180
我们只是开始事务 t1 我们

314
00:16:20,180 --> 00:16:22,130
说它的时间戳为 1 并且它的

315
00:16:22,130 --> 00:16:27,050
状态是活动的所以首先我们

316
00:16:27,050 --> 00:16:29,290
要读一下我认为在这个

317
00:16:29,290 --> 00:16:32,020
很明显，我们将

318
00:16:32,020 --> 00:16:36,200
读取版本 a0，接下来我们将

319
00:16:36,200 --> 00:16:37,730
再次写入 so，就像在上

320
00:16:37,730 --> 00:16:39,830
一张幻灯片中一样，我们将创建一个

321
00:16:39,830 --> 00:16:42,050
全新的版本，我将插入到

322
00:16:42,050 --> 00:16:44,270
我们的数据库表中 它将是

323
00:16:44,270 --> 00:16:47,750
版本 a 1，值为 4 5 6 并且

324
00:16:47,750 --> 00:16:50,270
开始时间戳将为 1

325
00:16:50,270 --> 00:16:51,950


326
00:16:51,950 --> 00:16:53,690


327
00:16:53,690 --> 00:16:57,440


328
00:16:57,440 --> 00:17:00,890
直到 a0 并将

329
00:17:00,890 --> 00:17:03,080
结束时间戳分配

330
00:17:03,080 --> 00:17:07,240
为事务 t1 的当前时间戳，它是 1，

331
00:17:07,240 --> 00:17:09,260
所以现在我们要开始

332
00:17:09,260 --> 00:17:10,740
事务 2

333
00:17:10,740 --> 00:17:12,089
所以我们要做的第一件事

334
00:17:12,089 --> 00:17:16,319
是读取 a so 在这种情况下

335
00:17:16,319 --> 00:17:22,829
交易是否会读取或抱歉

336
00:17:22,829 --> 00:17:24,420
它会读取哪个版本，请原谅

337
00:17:24,420 --> 00:17:32,790
我 1 以及为什么 是的，是的，有人，

338
00:17:32,790 --> 00:17:35,580
我猜是的，所以在这种情况下，嗯，

339
00:17:35,580 --> 00:17:38,730
对不起

340
00:17:38,730 --> 00:17:41,040
，是的，我们必须注意的一件事，现在

341
00:17:41,040 --> 00:17:43,440
这有点

342
00:17:43,440 --> 00:17:45,030
棘手，我忘了

343
00:17:45,030 --> 00:17:46,860
提到开始是我 理解

344
00:17:46,860 --> 00:17:48,020
你们没有时间去了解

345
00:17:48,020 --> 00:17:52,260
隔离级别，所以我希望

346
00:17:52,260 --> 00:17:54,000
你们只回顾去年的幻灯片

347
00:17:54,000 --> 00:17:56,880
和讲座，所以我只是

348
00:17:56,880 --> 00:17:58,290
要提供一些有关隔离级别的高级提示，以

349
00:17:58,290 --> 00:18:01,260
备不时之需 在

350
00:18:01,260 --> 00:18:03,210
这些幻灯片和作业上，

351
00:18:03,210 --> 00:18:05,460
但此时可能没有完全意义，

352
00:18:05,460 --> 00:18:07,560
但基本上就像在非常高的

353
00:18:07,560 --> 00:18:09,690
级别上一样，这取决于您拥有的隔离级别

354
00:18:09,690 --> 00:18:14,490
它可以选择任一版本 a

355
00:18:14,490 --> 00:18:17,820
0 a 1 但让我们假设它有点

356
00:18:17,820 --> 00:18:21,630
严格 可序列化或对不起，可

357
00:18:21,630 --> 00:18:23,610
序列化隔离，这是

358
00:18:23,610 --> 00:18:25,230
你们一直在使用的东西，

359
00:18:25,230 --> 00:18:28,650
直到现在，它

360
00:18:28,650 --> 00:18:31,230
必须读取 0，因为 1 还没有

361
00:18:31,230 --> 00:18:35,610
提交好，所以现在

362
00:18:35,610 --> 00:18:38,880
我们要写一个 所以在这种情况下

363
00:18:38,880 --> 00:18:40,320
接下来会发生什么

364
00:18:40,320 --> 00:18:42,870
，这里我们有一个写写

365
00:18:42,870 --> 00:18:46,080
冲突，所以假设我们使用

366
00:18:46,080 --> 00:18:49,560
a 成为 lt2 将不得不停止直到

367
00:18:49,560 --> 00:18:53,670
t1 提交一切正常，所以让我们

368
00:18:53,670 --> 00:18:56,670
继续这样做，现在我们回到 t1 我们是

369
00:18:56,670 --> 00:18:59,280
将读取 a，在这种情况下，

370
00:18:59,280 --> 00:19:00,690
它只会读取几分钟前写的相同版本

371
00:19:00,690 --> 00:19:03,050


372
00:19:03,050 --> 00:19:06,860
，它会继续并提交，

373
00:19:06,860 --> 00:19:10,470
所以现在我们可以回到这里，

374
00:19:10,470 --> 00:19:12,570
我们可以继续，现在我们是 将

375
00:19:12,570 --> 00:19:15,210
创建值为 7 8 9 的新版本 a 2

376
00:19:15,210 --> 00:19:17,010
我们将为其分配

377
00:19:17,010 --> 00:19:19,440
时间戳 2，结束时间步长为

378
00:19:19,440 --> 00:19:21,540
无穷大，我们还将将

379
00:19:21,540 --> 00:19:24,540
1 的结束时间戳更新为 2

380
00:19:24,540 --> 00:19:28,200
是的，此时您知道

381
00:19:28,200 --> 00:19:30,930
天气 t2 是否真的提交

382
00:19:30,930 --> 00:19:33,950
实际上取决于

383
00:19:33,950 --> 00:19:36,120
并发控制协议

384
00:19:36,120 --> 00:19:37,560
以及隔离级别，因此

385
00:19:37,560 --> 00:19:39,750
需要牢记这一点，但实际上这个

386
00:19:39,750 --> 00:19:41,760
例子这个例子的目的

387
00:19:41,760 --> 00:19:44,730
只是为了 向您展示我们如何更新

388
00:19:44,730 --> 00:19:47,310
对象版本维护 tr  ansaction

389
00:19:47,310 --> 00:19:49,890
状态表，并找出哪些

390
00:19:49,890 --> 00:19:52,110
元组可见

391
00:19:52,110 --> 00:20:04,290


392
00:20:04,290 --> 00:20:42,300


393
00:20:42,300 --> 00:20:44,130


394
00:20:44,130 --> 00:20:46,050


395
00:20:46,050 --> 00:20:48,210
稍后将在本讲座中讨论如何实际

396
00:20:48,210 --> 00:20:50,880
存储此信息，

397
00:20:50,880 --> 00:20:54,030
以便您喜欢这样

398
00:20:54,030 --> 00:20:55,860
基本上可以回答问题

399
00:20:55,860 --> 00:20:59,640
在某些情况下是的，您确实需要

400
00:20:59,640 --> 00:21:03,180
考虑锁 这实际上取决于

401
00:21:03,180 --> 00:21:04,710
您实际存储此版本的方式

402
00:21:04,710 --> 00:21:08,640
信息所以如果我们没有

403
00:21:08,640 --> 00:21:10,230
在几张幻灯片中介绍它，因为有多种

404
00:21:10,230 --> 00:21:12,480
方法可以做到这一点，所以我现在不想把

405
00:21:12,480 --> 00:21:14,070
它们全部列出来，我们没有

406
00:21:14,070 --> 00:21:16,020
在几张幻灯片中介绍它，请再次提出您

407
00:21:16,020 --> 00:21:18,230


408
00:21:21,620 --> 00:21:25,889
的问题 所以，嗯，再次像 MVCC

409
00:21:25,889 --> 00:21:28,260
或其变体被用于几乎所有新的

410
00:21:28,260 --> 00:21:31,889
数据库系统，这些只是你

411
00:21:31,889 --> 00:21:33,809
知道在 VCC 中使用的系统的一些例子，

412
00:21:33,809 --> 00:21:37,230
但我们

413
00:21:37,230 --> 00:21:39,299
在本讲座的其余部分真正想强调的

414
00:21:39,299 --> 00:21:43,320
是 MVCC 是一个 更多  除了

415
00:21:43,320 --> 00:21:44,789
维护我

416
00:21:44,789 --> 00:21:46,580
在前两个示例中向您展示的时间戳之外

417
00:21:46,580 --> 00:21:48,570


418
00:21:48,570 --> 00:21:50,100
，您还必须做出一大堆其他设计决策

419
00:21:50,100 --> 00:21:52,289
才能真正实现支持 VCC 的系统，

420
00:21:52,289 --> 00:21:54,269
所以我们接下来要讨论

421
00:21:54,269 --> 00:21:57,210
这些 确切地说，这些

422
00:21:57,210 --> 00:22:00,570
设计决策是

423
00:22:00,570 --> 00:22:02,929
您将使用什么并发协议，

424
00:22:02,929 --> 00:22:05,159
您将如何维护和

425
00:22:05,159 --> 00:22:07,019
存储不同版本，

426
00:22:07,019 --> 00:22:09,320
这与之前被问到的问题有关，

427
00:22:09,320 --> 00:22:11,490
您将如何清理旧

428
00:22:11,490 --> 00:22:14,490
版本一次 它们不再对任何

429
00:22:14,490 --> 00:22:16,980
事务可见，以及您

430
00:22:16,980 --> 00:22:18,720
将如何确保索引

431
00:22:18,720 --> 00:22:24,779
指向正确的版本

432
00:22:24,779 --> 00:22:29,940


433
00:22:29,940 --> 00:22:32,220


434
00:22:32,220 --> 00:22:33,419
我们将要介绍的

435
00:22:33,419 --> 00:22:41,639
是并发控制协议，所以

436
00:22:41,639 --> 00:22:45,149
这基本上是我在看

437
00:22:45,149 --> 00:22:47,070
抱歉我不习惯这个演示者

438
00:22:47,070 --> 00:22:50,299
查看我的糟糕好的

439
00:22:50,360 --> 00:22:52,590
并发控制协议

440
00:22:52,590 --> 00:22:55,019
这是我们的冷杉

441
00:22:55,019 --> 00:22:58,919
我们的设计决策考虑正确 所以这些是

442
00:22:58,919 --> 00:23:00,720


443
00:23:00,720 --> 00:23:02,309
你们过去

444
00:23:02,309 --> 00:23:05,850
两周在过去的两个讲座中一直在研究的并发控制协议

445
00:23:05,850 --> 00:23:08,399
，当你遇到

446
00:23:08,399 --> 00:23:10,230
写写冲突时，你需要使用

447
00:23:10,230 --> 00:23:12,389
这些协议之一 是两阶段

448
00:23:12,389 --> 00:23:16,350
锁定 OCC 或时间戳排序，以

449
00:23:16,350 --> 00:23:18,870
确定应该

450
00:23:18,870 --> 00:23:21,360
允许哪个事务写入该对象以及

451
00:23:21,360 --> 00:23:23,730
您正在运行的隔离级别，因此

452
00:23:23,730 --> 00:23:25,470
我们不会详细

453
00:23:25,470 --> 00:23:27,600
介绍这一点，因为您刚刚讨论过

454
00:23:27,600 --> 00:23:31,080
这是最近的所以下一个

455
00:23:31,080 --> 00:23:34,860
考虑是版本存储所以对于

456
00:23:34,860 --> 00:23:35,370
原始

457
00:23:35,370 --> 00:23:36,930
版本存储我们需要做的是

458
00:23:36,930 --> 00:23:39,690
为特定的

459
00:23:39,690 --> 00:23:42,930
元组版本找出两个我们实际上应该

460
00:23:42,930 --> 00:23:45,360
看到的东西所以让

461
00:23:45,360 --> 00:23:47,400
我们现在假设我们正在做一个顺序

462
00:23:47,400 --> 00:23:50,010
扫描整个娱乐螺栓，我们

463
00:23:50,010 --> 00:23:52,650
想知道在哪里可以找到

464
00:23:52,650 --> 00:23:55,500
我们想要的元组版本，所以我们

465
00:23:55,500 --> 00:23:57,090
要实现的方式是我们

466
00:23:57,090 --> 00:23:58,940
要维护一个内部 指针

467
00:23:58,940 --> 00:24:02,370
字段将使我们能够找到上一个

468
00:24:02,370 --> 00:24:04,730
或下一个版本 我们将

469
00:24:04,730 --> 00:24:08,100
针对这个特定的逻辑元组进行更多讨论，因此您

470
00:24:08,100 --> 00:24:10,230
可以认为这是一种链接

471
00:24:10,230 --> 00:24:14,070
列表，您知道可以在其中

472
00:24:14,070 --> 00:24:16,740
跳转 并落在头上

473
00:24:16,740 --> 00:24:20,790
，然后您可以

474
00:24:20,790 --> 00:24:22,590
按照链表中的指针找到

475
00:24:22,590 --> 00:24:24,510
它们当前维护的所有不同版本，

476
00:24:24,510 --> 00:24:27,260


477
00:24:28,790 --> 00:24:32,370
因此索引始终指向

478
00:24:32,370 --> 00:24:39,540
链的头部，哦，我又做了一次，我是

479
00:24:39,540 --> 00:24:47,780
所以对不起好吧技术困难

480
00:24:51,920 --> 00:24:56,760
好吧所以嗯像这里说的索引

481
00:24:56,760 --> 00:24:57,809
总是指向

482
00:24:57,809 --> 00:24:59,610
链的头部是否头部是最旧的

483
00:24:59,610 --> 00:25:01,770
版本那个元组的最新版本

484
00:25:01,770 --> 00:25:04,980
取决于实现所以

485
00:25:04,980 --> 00:25:07,380
有不同的方法决定

486
00:25:07,380 --> 00:25:08,820
我们如何进行 存储这些不同的

487
00:25:08,820 --> 00:25:13,429
版本，所以我们接下来会更深入，

488
00:25:18,830 --> 00:25:21,510
所以最简单的方法

489
00:25:21,510 --> 00:25:25,340
称为仅附加存储，所以

490
00:25:25,340 --> 00:25:28,380
这意味着每次我们

491
00:25:28,380 --> 00:25:31,020
创建新版本时，我们只复制

492
00:25:31,020 --> 00:25:34,470
旧版本 在我们的表空间中作为一个新的物理元组

493
00:25:34,470 --> 00:25:38,040
并更新它，然后我们

494
00:25:38,040 --> 00:25:40,260
更新指针说这是下一个

495
00:25:40,260 --> 00:25:41,550
版本，我们将

496
00:25:41,550 --> 00:25:43,440
在接下来的几张幻灯片中讨论所有这三个的示例，

497
00:25:43,440 --> 00:25:47,070
因此下一个方法

498
00:25:47,070 --> 00:25:48,570
称为

499
00:25:48,570 --> 00:25:50,460
时间旅行 存储，这是

500
00:25:50,460 --> 00:25:54,900
你有一个主版本表的地方，

501
00:25:54,900 --> 00:25:56,970
它总是在

502
00:25:56,970 --> 00:26:01,020
对象或元组的最新版本中，然后你将

503
00:26:01,020 --> 00:26:03,570
旧版本复制到一个单独的表

504
00:26:03,570 --> 00:26:05,370
中，我们将称之为时间旅行

505
00:26:05,370 --> 00:26:07,770
表，然后你 只需

506
00:26:07,770 --> 00:26:09,780
维护从

507
00:26:09,780 --> 00:26:11,190
具有最新元组的表的主版本

508
00:26:11,190 --> 00:26:14,130
到部落到时间旅行

509
00:26:14,130 --> 00:26:18,090
表的指针，所以最后一种方法

510
00:26:18,090 --> 00:26:20,820
是安迪喜欢的方法，最好

511
00:26:20,820 --> 00:26:23,850
的方法称为增量存储，因此您可以

512
00:26:23,850 --> 00:26:27,510
将其视为 下降并得到我们

513
00:26:27,510 --> 00:26:30,390
而不是每次都复制旧版本

514
00:26:30,390 --> 00:26:31,800
并更新它你只是

515
00:26:31,800 --> 00:26:34,140
要维护你知道

516
00:26:34,140 --> 00:26:37,320
以前版本的修改的小增量

517
00:26:37,320 --> 00:26:40,950
所以首先在

518
00:26:40,950 --> 00:26:44,160
e中回顾 仅追加存储的示例，

519
00:26:44,160 --> 00:26:45,720
因此这是最简单的方法，

520
00:26:45,720 --> 00:26:48,960
这也是 Postgres 使用的方法，因此每个

521
00:26:48,960 --> 00:26:52,080
新的物理版本只是一个元组，

522
00:26:52,080 --> 00:26:55,860
只是主表中的一个新元组，因此

523
00:26:55,860 --> 00:26:57,810
假设我们在这里有一个交易

524
00:26:57,810 --> 00:27:01,160
想要 更新对象 a 权限，所以

525
00:27:01,160 --> 00:27:03,120
要做的第一件事就是

526
00:27:03,120 --> 00:27:06,540
在表空间中找到一个空槽

527
00:27:06,540 --> 00:27:09,540
，然后从 a

528
00:27:09,540 --> 00:27:11,790
的当前值复制值，它是 1 好吧，这是

529
00:27:11,790 --> 00:27:13,670
我

530
00:27:13,670 --> 00:27:19,410
在该表中看到的最新值 然后接下来

531
00:27:19,410 --> 00:27:21,830
它将把修改后的值复制

532
00:27:21,830 --> 00:27:26,760
到那个表

533
00:27:26,760 --> 00:27:27,600


534
00:27:27,600 --> 00:27:29,400


535
00:27:29,400 --> 00:27:33,200


536
00:27:33,200 --> 00:27:36,630


537
00:27:36,630 --> 00:27:39,590


538
00:27:44,180 --> 00:27:47,269
中 音乐]

539
00:27:50,110 --> 00:27:52,850
好的，所以另一个方面我们必须考虑

540
00:27:52,850 --> 00:27:55,730
你的以便存储这个版本所以

541
00:27:55,730 --> 00:28:01,610
哦在这个例子中我们被认为

542
00:28:01,610 --> 00:28:06,740
是维珍链的头，在这个

543
00:28:06,740 --> 00:28:08,810
例子中我们专门对

544
00:28:08,810 --> 00:28:11,780
这些最老到最年轻的人进行排序，所以

545
00:28:11,780 --> 00:28:14,150
另一种选择是您可以将它们从

546
00:28:14,150 --> 00:28:20,300
最年轻到最老的顺序排列，因此如果您

547
00:28:20,300 --> 00:28:21,710
在这种情况下正在寻找最新的元组，

548
00:28:21,710 --> 00:28:26,660
实际上

549
00:28:26,660 --> 00:28:28,400
您会到达版本零的地步，

550
00:28:28,400 --> 00:28:30,080
并且您必须再次遵循

551
00:28:30,080 --> 00:28:31,820
指针 一直到最新

552
00:28:31,820 --> 00:28:40,030
版本到一些考试都可以，所以嗯

553
00:28:40,030 --> 00:28:43,580
，就像我刚才说的，前面的例子

554
00:28:43,580 --> 00:28:46,160
使用的是最旧的到最新的，但你也可以

555
00:28:46,160 --> 00:28:47,360
使用最新到最旧的

556
00:28:47,360 --> 00:28:49,880
，并且对它们都有性能影响和

557
00:28:49,880 --> 00:28:51,980
权衡，所以

558
00:28:51,980 --> 00:28:56,290
用

559
00:28:56,290 --> 00:28:59,840
当有新版本时，从最旧到最新所有你需要做的就是

560
00:28:59,840 --> 00:29:01,940
附加到版本链的末尾，

561
00:29:01,940 --> 00:29:04,370
这是非常简单的附加

562
00:29:04,370 --> 00:29:07,400
新元组并更新指针以

563
00:29:07,400 --> 00:29:09,380
指向新版本从旧

564
00:29:09,380 --> 00:29:12,170
版本到 较新的版本，这是

565
00:29:12,170 --> 00:29:17,060
一个非常简单的操作，但如果

566
00:29:17,060 --> 00:29:19,940
您从最新到最旧，那么这

567
00:29:19,940 --> 00:29:22,690
意味着您必须添加条目并

568
00:29:22,690 --> 00:29:25,220
更新其指针以指向旧

569
00:29:25,220 --> 00:29:27,530
头，但现在您必须实际

570
00:29:27,530 --> 00:29:30,740
更新 所有的索引都指向

571
00:29:30,740 --> 00:29:32,210
你的新版本，所以就像我们

572
00:29:32,210 --> 00:29:36,200
在几张幻灯片前所说的一样 索引总是

573
00:29:36,200 --> 00:29:38,120
指向版本链的头部，

574
00:29:38,120 --> 00:29:40,040
所以这意味着

575
00:29:40,040 --> 00:29:45,890
在某些情况下会有更多的更新，所以对于

576
00:29:45,890 --> 00:29:48,530
时间旅行存储来说 是

577
00:29:48,530 --> 00:29:50,600
我们将介绍的下一个方法，在这里我们

578
00:29:50,600 --> 00:29:52,190
将有一个主表，它总是

579
00:29:52,190 --> 00:29:53,720
必须放置每个元组的这个版本

580
00:29:53,720 --> 00:29:57,410
，然后我们将有另一个表

581
00:29:57,410 --> 00:29:58,620
称为时间旅行表

582
00:29:58,620 --> 00:30:01,080
，这就是我们要去的地方

583
00:30:01,080 --> 00:30:03,720
维护旧版本并复制旧

584
00:30:03,720 --> 00:30:05,790
版本，因为它们在数据库中被修改，

585
00:30:05,790 --> 00:30:09,870
所以对于这个例子，

586
00:30:09,870 --> 00:30:11,430
假设事务想要再次更新

587
00:30:11,430 --> 00:30:15,330
对象 a 与上一个例子相同，然后

588
00:30:15,330 --> 00:30:18,180
我们将在时间复制 2 到空闲

589
00:30:18,180 --> 00:30:21,809
位置 旅行表，然后

590
00:30:21,809 --> 00:30:23,850
更新版本指针指向

591
00:30:23,850 --> 00:30:28,140
元组 a 的最旧版本，然后我们

592
00:30:28,140 --> 00:30:30,180
将覆盖

593
00:30:30,180 --> 00:30:31,800
主表中的主版本作为新版本

594
00:30:31,800 --> 00:30:37,309
值，最后我们需要更新

595
00:30:37,309 --> 00:30:40,350
空气导流，然后最后

596
00:30:40,350 --> 00:30:42,510
我们需要  将指针

597
00:30:42,510 --> 00:30:46,290
从新版本 a3 更新到

598
00:30:46,290 --> 00:30:47,730
我们刚刚安装在时间旅行

599
00:30:47,730 --> 00:31:05,520
表中的版本，这是一个 2 是，这将是一个

600
00:31:05,520 --> 00:31:13,950
附加表，所以现在我们将继续我们

601
00:31:13,950 --> 00:31:18,390
的最后一个方法

602
00:31:18,390 --> 00:31:20,280
将考虑哪个是 Delta 存储

603
00:31:20,280 --> 00:31:23,370
，我的

604
00:31:23,370 --> 00:31:25,470
续集和 Oracle 都使用了它，就像我提到

605
00:31:25,470 --> 00:31:27,960
的那样，这是 Andy 认为最好的

606
00:31:27,960 --> 00:31:31,200
选择，所以

607
00:31:31,200 --> 00:31:32,610
每次更新时都会

608
00:31:32,610 --> 00:31:34,620
发生 将修改后的值复制

609
00:31:34,620 --> 00:31:37,140
到

610
00:31:37,140 --> 00:31:39,679
您在此处看到的这个单独的 Delta 存储段中，

611
00:31:39,679 --> 00:31:44,490
以便更新 a 我们首先将

612
00:31:44,490 --> 00:31:50,160
其版本值更新到 Delta

613
00:31:50,160 --> 00:31:51,840
存储中，因此我们将复制

614
00:31:51,840 --> 00:31:53,730
其值而不是存储

615
00:31:53,730 --> 00:31:55,410
我们将要调用的整个元组

616
00:31:55,410 --> 00:31:57,660
我们只是要创建一个

617
00:31:57,660 --> 00:32:00,510
delta 你知道哪个部分的哪些

618
00:32:00,510 --> 00:32:02,280
属性和元组实际上被

619
00:32:02,280 --> 00:32:05,220
修改了所以在这种情况下有一个

620
00:32:05,220 --> 00:32:08,820
属性所以现在反映

621
00:32:08,820 --> 00:32:12,000
在 Delta 存储中 部分

622
00:32:12,000 --> 00:32:13,380
然后我们

623
00:32:13,380 --> 00:32:16,980
将更新主表中的实际值，并将

624
00:32:16,980 --> 00:32:20,220
指针从新值更新到我们的

625
00:32:20,220 --> 00:32:24,600
Delta 存储中，所以类似的，如果

626
00:32:24,600 --> 00:32:28,830
我们现在想安装新值和

627
00:32:28,830 --> 00:32:31,650
新版本，那么我们需要做一些事情

628
00:32:31,650 --> 00:32:33,810
类似于时间旅行表

629
00:32:33,810 --> 00:32:36,960
场景，特别是我们

630
00:32:36,960 --> 00:32:39,390
附加新版本再次更新值

631
00:32:39,390 --> 00:32:41,370
，现在我们看到它的版本 a3 是

632
00:32:41,370 --> 00:32:45,270
正确的，但我们有但我们还需要

633
00:32:45,270 --> 00:32:48,720
将指针从 a3 更新为现在

634
00:32:48,720 --> 00:32:50,550
指向最新值 a2

635
00:32:50,550 --> 00:32:52,290
的指针，另外我们需要将

636
00:32:52,290 --> 00:32:55,080
a2 的指针更新为指向旧版本的指针，

637
00:32:55,080 --> 00:32:56,910
现在任何人 Tim 都是时间

638
00:32:56,910 --> 00:33:07,140
旅行的例子，所以当你想

639
00:33:07,140 --> 00:33:09,480
很好地阅读旧版本时，你真正

640
00:33:09,480 --> 00:33:11,610
要做的就是你必须

641
00:33:11,610 --> 00:33:15,380
重播 将元组放回其原始形式的增量，

642
00:33:15,380 --> 00:33:18,990
因此在这种情况下

643
00:33:18,990 --> 00:33:22,350
，如果我们想读取 1，

644
00:33:22,350 --> 00:33:25,470
我们将从 a3 的值开始，

645
00:33:25,470 --> 00:33:27,360
然后我们将跟随指针

646
00:33:27,360 --> 00:33:31,200
a 应用增量和 a2 和 然后

647
00:33:31,200 --> 00:33:32,970
应用 Delta 1，这将使我们

648
00:33:32,970 --> 00:33:39,270
回到原始值，因此这是读取和写入

649
00:33:39,270 --> 00:33:41,670
之间权衡的另一个很好的示例，

650
00:33:41,670 --> 00:33:44,820
因此读取旧版本

651
00:33:44,820 --> 00:33:47,550
和仅附加方法非常

652
00:33:47,550 --> 00:33:49,290
简单，这是一件好事，

653
00:33:49,290 --> 00:33:52,590
很容易 实施正确，因为您

654
00:33:52,590 --> 00:33:56,160
刚刚找到版本并且元组

655
00:33:56,160 --> 00:33:57,870
已经准备好进行转换，因此

656
00:33:57,870 --> 00:33:59,940
除了易于实现之外，

657
00:33:59,940 --> 00:34:01,560
您还不必将元组重新

658
00:34:01,560 --> 00:34:03,870
组合在一起，您不必应用

659
00:34:03,870 --> 00:34:06,930
Delta 将其恢复 它的正确状态，但

660
00:34:06,930 --> 00:34:08,760
使用 Delta 存储权限

661
00:34:08,760 --> 00:34:10,889
会快得多，因为

662
00:34:10,889 --> 00:34:13,710
如果我们只

663
00:34:13,710 --> 00:34:16,440
对属性的一个子集进行更改，我们就不必复制整个元组，所以

664
00:34:16,440 --> 00:34:18,000
你知道你是否只有一个属性，

665
00:34:18,000 --> 00:34:20,040
就像我们在这里做的那样 这是您清楚地知道

666
00:34:20,040 --> 00:34:22,770
一个微不足道的优化，但在许多

667
00:34:22,770 --> 00:34:24,030
表中，

668
00:34:24,030 --> 00:34:27,870
您可能知道数十列，在

669
00:34:27,870 --> 00:34:35,580
这种情况下，这可能很重要，但

670
00:34:35,580 --> 00:34:38,360
对于 Delta 存储再次是的

671
00:34:38,360 --> 00:34:42,480
，这是好处，但缺点

672
00:34:42,480 --> 00:34:44,520
是您必须重播 deltas

673
00:34:44,520 --> 00:34:46,710
再次将小管重新组合

674
00:34:46,710 --> 00:34:50,520
到其正确的值，这样

675
00:34:50,520 --> 00:34:52,020
你就可以从这里拿走，就像我们

676
00:34:52,020 --> 00:34:56,699
之前提到的 Postgres

677
00:34:56,699 --> 00:35:05,370
Postgres 读取速度更快，因为很好的

678
00:35:05,370 --> 00:35:07,440
后期课程读取速度更快

679
00:35:07,440 --> 00:35:10,350
，我的续集 B 将 由于这个确切原因，写入速度更快，

680
00:35:10,350 --> 00:35:18,030


681
00:35:18,030 --> 00:35:19,680
所以我们需要

682
00:35:19,680 --> 00:35:22,760
在列表中了解的第三件事是垃圾收集，

683
00:35:22,760 --> 00:35:24,960
因此所有这些旧版本都在

684
00:35:24,960 --> 00:35:27,180
随着事务的运行

685
00:35:27,180 --> 00:35:29,820
和完成而累积，并且在某些时候我们

686
00:35:29,820 --> 00:35:32,430
知道特定版本是 not being

687
00:35:32,430 --> 00:35:35,070
对任何其他活动事务都是不可见的，

688
00:35:35,070 --> 00:35:37,880
所以这意味着

689
00:35:37,880 --> 00:35:40,890
如果您正在考虑

690
00:35:40,890 --> 00:35:42,860
带有开始和结束时间戳以及

691
00:35:42,860 --> 00:35:45,120
时间戳版本的表，则意味着

692
00:35:45,120 --> 00:35:47,610
没有具有

693
00:35:47,610 --> 00:35:49,560
适合的时间戳的活动事务 在旧版本的开始和结束范围之间，

694
00:35:49,560 --> 00:35:52,430


695
00:35:52,430 --> 00:35:55,170
所以在这一点上我们想要继续

696
00:35:55,170 --> 00:35:57,600
垃圾收集这些版本

697
00:35:57,600 --> 00:36:02,310
以回收空间所以另外两个

698
00:36:02,310 --> 00:36:04,110
我们必须担心的事情是

699
00:36:04,110 --> 00:36:05,460
我们将如何查找过期

700
00:36:05,460 --> 00:36:08,490
版本以及何时可以安全地回收

701
00:36:08,490 --> 00:36:11,940
它们，因此这些主题我们

702
00:36:11,940 --> 00:36:13,500
不会在本课程

703
00:36:13,500 --> 00:36:15,360
中涵盖，但如果您愿意，它们会在高级课程中涵盖

704
00:36:15,360 --> 00:36:19,890
确实选择采用它，所以有

705
00:36:19,890 --> 00:36:25,770
两种方法

706
00:36:25,770 --> 00:36:28,770
所以我们将专门研究这两种方法

707
00:36:28,770 --> 00:36:31,110
第一个是元组级别的垃圾

708
00:36:31,110 --> 00:36:32,610
收集，第二个是

709
00:36:32,610 --> 00:36:35,760
事务级别，所以元组级别

710
00:36:35,760 --> 00:36:37,590
意味着我们基本上要做 生病了，

711
00:36:37,590 --> 00:36:40,440
你会在我们的桌子上看到蚂蚁，并

712
00:36:40,440 --> 00:36:42,540
使用版本时间戳和一组活动

713
00:36:42,540 --> 00:36:44,490
事务来确定

714
00:36:44,490 --> 00:36:48,150
版本是否过期，如果是，那么我们

715
00:36:48,150 --> 00:36:50,490
继续修剪它，所以

716
00:36:50,490 --> 00:36:52,580
这实际上很复杂的原因是因为

717
00:36:52,580 --> 00:36:54,870
我们没有 我们只需要实际查看

718
00:36:54,870 --> 00:36:57,120
内存中的页面，但我们还

719
00:36:57,120 --> 00:36:59,610
需要查看已换

720
00:36:59,610 --> 00:37:02,670
出到磁盘的页面，因为我们再次希望

721
00:37:02,670 --> 00:37:05,490
正确地吸尘，所以我们将

722
00:37:05,490 --> 00:37:08,030
进行真空背景吸尘和

723
00:37:08,030 --> 00:37:10,050
cope 下一张幻灯片中的相对清理

724
00:37:10,050 --> 00:37:13,740
所以第二种方法是事务

725
00:37:13,740 --> 00:37:15,330
级别，我们真的

726
00:37:15,330 --> 00:37:18,480
不会详细介绍，但总体

727
00:37:18,480 --> 00:37:20,430
思路是您有

728
00:37:20,430 --> 00:37:23,340
维护其读写集的事务，并且您

729
00:37:23,340 --> 00:37:26,100
知道它们何时提交，因此版本

730
00:37:26,100 --> 00:37:29,760
是 是的，所以在这种情况下，您

731
00:37:29,760 --> 00:37:31,890
再次拥有事务，他们正在维护

732
00:37:31,890 --> 00:37:34,320
我们读取写入集的重写，因此

733
00:37:34,320 --> 00:37:35,940
您确切地知道它们何时提交，

734
00:37:35,940 --> 00:37:37,980
因此您可以弄清楚它们何时

735
00:37:37,980 --> 00:37:42,810
不再可见并可以清空它们，

736
00:37:42,810 --> 00:37:44,610
因此第一个将首先

737
00:37:44,610 --> 00:37:47,010
看一个元组级垃圾收集如何工作的例子，

738
00:37:47,010 --> 00:37:50,340
假设我们有两个线程

739
00:37:50,340 --> 00:37:54,950
在系统中运行，因此

740
00:37:54,950 --> 00:37:57,480
事务 t1 被分配

741
00:37:57,480 --> 00:38:00,150
了 12 的时间戳，事务 t2 被

742
00:38:00,150 --> 00:38:02,880
分配了第十个时间戳 25，

743
00:38:02,880 --> 00:38:04,680
然后在我们的 版本表你可以

744
00:38:04,680 --> 00:38:07,440
看到我们有相反的对象 a，它被

745
00:38:07,440 --> 00:38:10,620
分配了版本 100 的开始

746
00:38:10,620 --> 00:38:12,660
时间戳为 1，结束时间戳为 9

747
00:38:12,660 --> 00:38:14,970
，然后我们有一些其他版本

748
00:38:14,970 --> 00:38:20,220
的对象 B 所以 使用真空

749
00:38:20,220 --> 00:38:22,530
背景吸尘 我们

750
00:38:22,530 --> 00:38:26,280
要做的是我们有一组

751
00:38:26,280 --> 00:38:27,900
线程在后台运行，他们

752
00:38:27,900 --> 00:38:30,480
执行这种吸尘，他们

753
00:38:30,480 --> 00:38:32,670
定期对桌子进行全表扫描

754
00:38:32,670 --> 00:38:36,900
，并寻找

755
00:38:36,900 --> 00:38:41,250
我们回收的版本 Abul 它适用于任何

756
00:38:41,250 --> 00:38:45,570
类型的存储，因此

757
00:38:45,570 --> 00:38:49,560
对于背景，所以在这里看到 HIPAA

758
00:38:49,560 --> 00:38:50,820
后台线程

759
00:38:50,820 --> 00:38:54,030
那里进入到

760
00:38:54,030 --> 00:38:57,330
交易线程中并说了什么，

761
00:38:57,330 --> 00:38:59,390
它基本上查询当前

762
00:38:59,390 --> 00:39:01,560
交易时间戳是什么，所以在这种

763
00:39:01,560 --> 00:39:06,150
情况下它会是 12 和 25 然后

764
00:39:06,150 --> 00:39:08,040
它将在表上进行顺序扫描

765
00:39:08,040 --> 00:39:11,640
以确定

766
00:39:11,640 --> 00:39:14,910
元组是否对他们可见

767
00:39:14,910 --> 00:39:19,640


768
00:39:21,290 --> 00:39:23,400


769
00:39:23,400 --> 00:39:32,850
阅读或写作，但哦，我

770
00:39:32,850 --> 00:39:35,810
明白了对不起，让我再次备份，

771
00:39:35,810 --> 00:39:38,430
对不起，在这个例子中，我们

772
00:39:38,430 --> 00:39:40,320
只看时间停留在开头和

773
00:39:40,320 --> 00:39:44,870
时间戳，所以在这里我们

774
00:39:44,870 --> 00:39:48,150
从这两个中收集 12 和 25 的时间戳

775
00:39:48,150 --> 00:39:50,490
交易，然后我们再次

776
00:39:50,490 --> 00:39:53,040
查看开始和结束时间戳，因此它们

777
00:39:53,040 --> 00:39:55,860
将永远无法使用 100 或 B 100，

778
00:39:55,860 --> 00:39:57,420
因为时间戳不在

779
00:39:57,420 --> 00:40:01,260
1 和 9 之间，而它们确实

780
00:40:01,260 --> 00:40:03,870
遵循事务 t1 的时间戳

781
00:40:03,870 --> 00:40:05,880
介于 10 和 20 之间 所以我可以

782
00:40:05,880 --> 00:40:11,700
潜在地使用那个值，在

783
00:40:11,700 --> 00:40:13,860
这一点上我们知道这两个元组是

784
00:40:13,860 --> 00:40:16,760
安全的回收所以我们继续这样做

785
00:40:16,760 --> 00:40:29,310
嗯所以这里的一个

786
00:40:29,310 --> 00:40:30,990
优化我们可以做的一个明显的优化

787
00:40:30,990 --> 00:40:34,860
是我们实际上可以维护一个位图

788
00:40:34,860 --> 00:40:37,590
脏页面，因此无论何时修改它，

789
00:40:37,590 --> 00:40:39,900
您都可以翻转您修改的页面的一部分

790
00:40:39,900 --> 00:40:42,090
，所以我们的意思是

791
00:40:42,090 --> 00:40:44,550
我们正在为数据库页面中的所有页面维护一个位图，

792
00:40:44,550 --> 00:40:46,190


793
00:40:46,190 --> 00:40:49,260
特别是如果我们修改一个页面，我们将

794
00:40:49,260 --> 00:40:51,930
翻转

795
00:40:51,930 --> 00:40:56,310
表示该页面已脏的特定位，因此您知道这

796
00:40:56,310 --> 00:40:58,200
需要一点额外的存储空间，但

797
00:40:58,200 --> 00:40:59,099
它只是

798
00:40:59,099 --> 00:41:02,279
数据库中所有页面的单个页面，并且

799
00:41:02,279 --> 00:41:04,920
只要您想要它，当

800
00:41:04,920 --> 00:41:06,690
吸尘器绕过它时 立即

801
00:41:06,690 --> 00:41:08,940
知道它实际需要对

802
00:41:08,940 --> 00:41:10,950
哪些页面进行清理，因此它将继续

803
00:41:10,950 --> 00:41:12,989
清理该页面，然后将该位

804
00:41:12,989 --> 00:41:19,829
重置为零，因此再次清理清理

805
00:41:19,829 --> 00:41:23,220
通常作为定期运行的 cron 作业

806
00:41:23,220 --> 00:41:26,519
运行，但在某些数据库

807
00:41:26,519 --> 00:41:29,400
系统中，例如 Postgres 例如，您

808
00:41:29,400 --> 00:41:32,720
实际上可以

809
00:41:32,720 --> 00:41:36,720
从续集提示中手动调用真空，并且

810
00:41:36,720 --> 00:41:39,720
它还具有

811
00:41:39,720 --> 00:41:42,989
您可以设置的配置参数，以便

812
00:41:42,989 --> 00:41:44,970
系统将基本上启动一个真空

813
00:41:44,970 --> 00:41:50,130
线程，如果它结束，如果您知道 20% 的

814
00:41:50,130 --> 00:41:52,410
页面是脏的 例如，因此有

815
00:41:52,410 --> 00:41:54,119
不同的方法来实现这一点 有

816
00:41:54,119 --> 00:41:55,739
不同的方法可以针对

817
00:41:55,739 --> 00:42:05,999
不同的工作负载对其进行优化 所以

818
00:42:05,999 --> 00:42:11,910
我们要研究的另一种方法是

819
00:42:11,910 --> 00:42:14,369
协作清理 好吧，这

820
00:42:14,369 --> 00:42:17,190
基本上是线程

821
00:42:17,190 --> 00:42:18,839
执行查询时的位置

822
00:42:18,839 --> 00:42:21,779
遇到他们知道

823
00:42:21,779 --> 00:42:24,599
其他人看不到的旧版本，他们的

824
00:42:24,599 --> 00:42:26,940
工作是在他们进行时实际清理它们，

825
00:42:26,940 --> 00:42:29,130
所以这些是这些

826
00:42:29,130 --> 00:42:30,859
威胁实际上是在执行

827
00:42:30,859 --> 00:42:34,769
事务，他们将

828
00:42:34,769 --> 00:42:37,650
实际检查他们遍历的版本

829
00:42:37,650 --> 00:42:40,079


830
00:42:40,079 --> 00:42:42,779
是否应该是这些版本

831
00:42:42,779 --> 00:42:44,599
是否准备好回收该空间，

832
00:42:44,599 --> 00:42:47,099
因为它们不再对任何

833
00:42:47,099 --> 00:42:49,049
事务可见，如果 他们

834
00:42:49,049 --> 00:42:52,049
会继续并回收那个空间，所以

835
00:42:52,049 --> 00:42:55,890
要注意的一件事是，如果你考虑

836
00:42:55,890 --> 00:42:58,609
我们之前讨论的两个排序，从

837
00:42:58,609 --> 00:43:01,049
最旧到最新和从最新到最旧

838
00:43:01,049 --> 00:43:04,920
，这种方法是否对这

839
00:43:04,920 --> 00:43:10,130
两个都有效，为什么是

840
00:43:15,479 --> 00:43:18,099
这样？ 这是完全正确的，所以

841
00:43:18,099 --> 00:43:21,759
在从最新到最旧的情况下，您

842
00:43:21,759 --> 00:43:23,410
不会查看任何

843
00:43:23,410 --> 00:43:25,779
旧交易，因此您实际上

844
00:43:25,779 --> 00:43:28,299
永远不会回收这些交易，因此

845
00:43:28,299 --> 00:43:30,009
重要的是要注意协作

846
00:43:30,009 --> 00:43:32,229
清洁仅适用于从最旧到

847
00:43:32,229 --> 00:43:35,469
最新的交易 排序没问题，所以现在我们将

848
00:43:35,469 --> 00:43:37,779
在这里通过一个类似的例子

849
00:43:37,779 --> 00:43:41,769
，假设事务 t1 中索引中的 wave

850
00:43:41,769 --> 00:43:44,349


851
00:43:44,349 --> 00:43:49,569
现在想要对对象 a 进行查找，所以它是 g 再次，

852
00:43:49,569 --> 00:43:52,089
它将落在版本链的头部，

853
00:43:52,089 --> 00:43:54,880
这是最旧的值，然后

854
00:43:54,880 --> 00:43:56,440
它会继续扫描，直到它

855
00:43:56,440 --> 00:43:59,739
找出哪些版本实际上

856
00:43:59,739 --> 00:44:03,039
对它可见，因此如果它识别

857
00:44:03,039 --> 00:44:06,459
出它正在寻找的版本，它是否

858
00:44:06,459 --> 00:44:07,959
识别出那个版本

859
00:44:07,959 --> 00:44:10,180
它当前遍历的版本

860
00:44:10,180 --> 00:44:13,239
对任何其他事务都不可见，然后

861
00:44:13,239 --> 00:44:14,650
我们将继续将它们标记为已删除

862
00:44:14,650 --> 00:44:19,209
并回收空间，然后

863
00:44:19,209 --> 00:44:23,170
在最后我们还更新索引以

864
00:44:23,170 --> 00:44:24,489
指向版本的新头

865
00:44:24,489 --> 00:44:28,059
链，所以我们只需要完成这些

866
00:44:28,059 --> 00:44:33,789
步骤，在这里我们找到正确的值

867
00:44:33,789 --> 00:44:37,410
，所以我们可以看到一个版本是

868
00:44:37,410 --> 00:44:43,569
可以回收的，然后我们重新附加

869
00:44:43,569 --> 00:44:46,029
，然后我们重新创建

870
00:44:46,029 --> 00:44:48,459
从索引到新版本头的指针，

871
00:44:48,459 --> 00:44:51,910
所以 排序在这里实际上很重要

872
00:44:51,910 --> 00:44:53,289


873
00:44:53,289 --> 00:44:55,479
，实际上在这张

874
00:44:55,479 --> 00:44:59,319
幻灯片上实际完成的排序并不完全正确，因此当您

875
00:44:59,319 --> 00:45:02,619
实际执行这些操作时，

876
00:45:02,619 --> 00:45:06,519
您首先要做的实际上是更新，

877
00:45:06,519 --> 00:45:08,079
因此 您要做的第一件事是将

878
00:45:08,079 --> 00:45:10,420
它们标记为已删除，但您

879
00:45:10,420 --> 00:45:12,400
实际上并没有回收空间，但

880
00:45:12,400 --> 00:45:13,930
下一件重要的事情是您

881
00:45:13,930 --> 00:45:16,660
实际上将索引指针更新为

882
00:45:16,660 --> 00:45:19,239
指向两个，然后再物理

883
00:45:19,239 --> 00:45:20,530
删除它们以

884
00:45:20,530 --> 00:45:23,650
声明该空间，否则如果

885
00:45:23,650 --> 00:45:25,270
您 让其他事务同时运行，

886
00:45:25,270 --> 00:45:28,240
他们可能会发现一个

887
00:45:28,240 --> 00:45:43,120
空指针指向任何东西

888
00:45:43,120 --> 00:45:45,160


889
00:45:45,160 --> 00:45:46,480


890
00:45:46,480 --> 00:45:48,130


891
00:45:48,130 --> 00:45:50,140


892
00:45:50,140 --> 00:45:52,390


893
00:45:52,390 --> 00:45:54,700
版本表中的开始和结束时间戳

894
00:45:54,700 --> 00:46:02,790
正确所以再次

895
00:46:02,790 --> 00:46:05,850
事务级别垃圾收集

896
00:46:05,850 --> 00:46:09,100
我们在这里我们只维护读写

897
00:46:09,100 --> 00:46:11,410
事务集，我们使用它们来

898
00:46:11,410 --> 00:46:13,000
确定哪些版本不再可见

899
00:46:13,000 --> 00:46:14,710
，然后我们声明空间和

900
00:46:14,710 --> 00:46:17,020
这就是我们要说的

901
00:46:17,020 --> 00:46:20,800
有关事务级垃圾

902
00:46:20,800 --> 00:46:23,770
收集的全部内容，因此有关垃圾

903
00:46:23,770 --> 00:46:25,420
收集的任何问题 n 或其他任何事情，直到

904
00:46:25,420 --> 00:46:31,600
这一点都可以，所以现在我们将

905
00:46:31,600 --> 00:46:35,680
继续讨论设计决策中的最后一个主题

906
00:46:35,680 --> 00:46:37,300
，即索引

907
00:46:37,300 --> 00:46:41,980
管理，所以正如我之前提到的，

908
00:46:41,980 --> 00:46:43,840
主键索引总是

909
00:46:43,840 --> 00:46:45,490
指向头部

910
00:46:45,490 --> 00:46:47,890
任何时候我们创建新版本

911
00:46:47,890 --> 00:46:50,860
的版本链我们必须更新版本链或者

912
00:46:50,860 --> 00:46:53,860
我们必须更新好我们必须

913
00:46:53,860 --> 00:46:55,630
更新索引以指向版本链中的新头，

914
00:46:55,630 --> 00:46:57,850
所以

915
00:46:57,850 --> 00:47:00,040
在更新主键时这会变得棘手，

916
00:47:00,040 --> 00:47:03,250
因为 现在实际上有

917
00:47:03,250 --> 00:47:04,780
可能你可以

918
00:47:04,780 --> 00:47:08,530
为同一个逻辑元组有两个版本链，你

919
00:47:08,530 --> 00:47:12,130
实现的方式是，如果

920
00:47:12,130 --> 00:47:14,440
你想在

921
00:47:14,440 --> 00:47:17,170
更新主键时删除主键，你这样做是作为一个

922
00:47:17,170 --> 00:47:19,840
删除，然后是插入 一个新的

923
00:47:19,840 --> 00:47:22,090
逻辑元组，

924
00:47:22,090 --> 00:47:25,560
您需要维护一些簿记，并且

925
00:47:25,560 --> 00:47:29,110
您还需要了解如何以及

926
00:47:29,110 --> 00:47:31,600
何时在必要时回滚，但对于

927
00:47:31,600 --> 00:47:34,000
二级索引，这实际上更加

928
00:47:34,000 --> 00:47:34,479
平静

929
00:47:34,479 --> 00:47:38,319
复杂和 t 他将是我们将要

930
00:47:38,319 --> 00:47:43,630
多谈的内容，因此对于

931
00:47:43,630 --> 00:47:48,939
二级索引，我们

932
00:47:48,939 --> 00:47:52,929
用来确保我们的索引

933
00:47:52,929 --> 00:47:55,779
反映

934
00:47:55,779 --> 00:47:58,630
版本链中正确值的两种方法是维护一个逻辑

935
00:47:58,630 --> 00:48:01,059
指针，因此在这里您有一些

936
00:48:01,059 --> 00:48:02,890
元组的某种错误标识符或元组的

937
00:48:02,890 --> 00:48:05,170
某种唯一

938
00:48:05,170 --> 00:48:08,229
标识符，不会改变，然后

939
00:48:08,229 --> 00:48:11,199
你有一些

940
00:48:11,199 --> 00:48:13,509
间接层 一个间接层，将逻辑

941
00:48:13,509 --> 00:48:15,549
ID 映射到数据库中的物理位置，

942
00:48:15,549 --> 00:48:17,439
并且随时更新

943
00:48:17,439 --> 00:48:19,989
版本链 你只需要

944
00:48:19,989 --> 00:48:22,749
更新间接层而不是

945
00:48:22,749 --> 00:48:25,660
实际更新每个索引，

946
00:48:25,660 --> 00:48:28,689
所以实际的方法是我认为

947
00:48:28,689 --> 00:48:30,429
它是我在之前的一些幻灯片中使用

948
00:48:30,429 --> 00:48:32,799
的我认为这是实际使用

949
00:48:32,799 --> 00:48:37,390
物理指针，当你

950
00:48:37,390 --> 00:48:38,739
直接指向时 到新版本链的头部，

951
00:48:38,739 --> 00:48:40,660
因此每次版本

952
00:48:40,660 --> 00:48:42,699
链更新时，您都必须正确更新

953
00:48:42,699 --> 00:48:46,569
每个索引，因此

954
00:48:46,569 --> 00:48:48,849
两者之间的物理差异

955
00:48:48,849 --> 00:48:50,949
使用物理指针和逻辑是

956
00:48:50,949 --> 00:48:52,869
你基本上有这个间接

957
00:48:52,869 --> 00:48:55,239
表，间接表的好处

958
00:48:55,239 --> 00:48:57,369
是你不必

959
00:48:57,369 --> 00:49:00,999
每次

960
00:49:00,999 --> 00:49:07,959
更新版本链时都更新每个索引，所以在

961
00:49:07,959 --> 00:49:11,109
这个例子中我们会说我们有 一个简单的

962
00:49:11,109 --> 00:49:13,630
数据库，我们正在使用一个从

963
00:49:13,630 --> 00:49:15,880
最新到最旧的挂件版本链，

964
00:49:15,880 --> 00:49:22,869
因此对于主键

965
00:49:22,869 --> 00:49:24,819
索引，如果我要对

966
00:49:24,819 --> 00:49:30,130
对象 a 进行查找，那么这将只是一个

967
00:49:30,130 --> 00:49:32,739
物理地址

968
00:49:32,739 --> 00:49:35,469
主键，它只是一个页面 ID

969
00:49:35,469 --> 00:49:37,119
和偏移量，所以你知道要转到哪个页面

970
00:49:37,119 --> 00:49:38,890
，然后你取偏移量，

971
00:49:38,890 --> 00:49:40,839
这通常是它会

972
00:49:40,839 --> 00:49:42,670
再次指向版本

973
00:49:42,670 --> 00:49:45,309
链的头部，无论何时创建新

974
00:49:45,309 --> 00:49:48,049
版本 你总是

975
00:49:48,049 --> 00:49:55,880
更新主团队没问题，所以对于

976
00:49:55,880 --> 00:49:58,099
二级索引，你可以再次

977
00:49:58,099 --> 00:50:01,219
使用物理地址，但是

978
00:50:01,219 --> 00:50:03,979
无论何时你更新元组都会有同样的问题，

979
00:50:03,979 --> 00:50:05,689
你必须更新二级索引

980
00:50:05,689 --> 00:50:11,239
以指向这个 而且你知道

981
00:50:11,239 --> 00:50:13,429
这又是这样

982
00:50:13,429 --> 00:50:17,059


983
00:50:17,059 --> 00:50:20,539
类似于我们在几张幻灯片前看到的两种 Delta 存储想法中的一些 是的，如果你

984
00:50:20,539 --> 00:50:22,069
有一个属性，或者如果你有一个

985
00:50:22,069 --> 00:50:24,380
索引或一个二级索引，那么这

986
00:50:24,380 --> 00:50:27,679
不是一个 这很重要，但是

987
00:50:27,679 --> 00:50:30,559
对于 OLTP 数据库来说，在一个表上有

988
00:50:30,559 --> 00:50:35,449
很多到很多二级索引是很常见的，

989
00:50:35,449 --> 00:50:39,559
所以每次

990
00:50:39,559 --> 00:50:41,479
更新版本链时，你必须

991
00:50:41,479 --> 00:50:44,239
更新所有那些二级索引

992
00:50:44,239 --> 00:50:47,079
，对于 OLTP，你可以想象可能是

993
00:50:47,079 --> 00:50:51,979
12 或者你知道几十个嗯嗯，

994
00:50:51,979 --> 00:50:54,619
这当然很昂贵，因为

995
00:50:54,619 --> 00:50:57,739
例如，如果它是一棵 B+ 树，那么你

996
00:50:57,739 --> 00:50:59,390
知道正在遍历 B+ 树，

997
00:50:59,390 --> 00:51:01,249
你边走边看，然后

998
00:51:01,249 --> 00:51:05,299
最后你必须再次应用更新

999
00:51:05,299 --> 00:51:08,479
就像我们发送上一张幻灯片

1000
00:51:08,479 --> 00:51:11,239
而不是将物理地址存储

1001
00:51:11,239 --> 00:51:13,400
在二级索引中一样，我们

1002
00:51:13,400 --> 00:51:15,890
将查看两种替代方法，因此第一种方法

1003
00:51:15,890 --> 00:51:18,920
是仅存储主键，

1004
00:51:18,920 --> 00:51:20,869
它实际上只是主键的副本

1005
00:51:20,869 --> 00:51:25,390
作为值 和二级索引

1006
00:51:25,390 --> 00:51:34,640
首先，我们在这里的衣服，

1007
00:51:34,640 --> 00:51:37,640
所以在这里我们将拥有

1008
00:51:37,640 --> 00:51:38,719
我们将要存储在

1009
00:51:38,719 --> 00:51:40,549
二级索引中的实际值将是一个

1010
00:51:40,549 --> 00:51:45,079
指向主键索引的指针，所以现在当你

1011
00:51:45,079 --> 00:51:47,660
想要找到一个元组，你只是得到你

1012
00:51:47,660 --> 00:51:49,489
首先得到主键索引

1013
00:51:49,489 --> 00:51:52,699
或者二级索引，然后你

1014
00:51:52,699 --> 00:51:55,219
在主键索引上进行查找，就像

1015
00:51:55,219 --> 00:51:58,069
你会弄清楚

1016
00:51:58,069 --> 00:52:00,510
物理地址是什么一样，然后每一个都

1017
00:52:00,510 --> 00:52:02,370
像在 第一个

1018
00:52:02,370 --> 00:52:08,220
带有物理地址的示例，因此无论何时我

1019
00:52:08,220 --> 00:52:09,780
更新元组和版本链的头部，

1020
00:52:09,780 --> 00:52:12,240
您都可以更新主

1021
00:52:12,240 --> 00:52:14,910
索引并自动更新

1022
00:52:14,910 --> 00:52:17,100
所有二级索引，因此这

1023
00:52:17,100 --> 00:52:23,970
是逻辑指针的一个示例，这

1024
00:52:23,970 --> 00:52:27,480
就是我的续集所做的 和 Postgres

1025
00:52:27,480 --> 00:52:34,670
实际上存储物理地址是的，

1026
00:52:35,720 --> 00:52:37,380


1027
00:52:37,380 --> 00:52:39,900
是二级索引，看看你的

1028
00:52:39,900 --> 00:52:43,380
主键索引是否正确，它存储

1029
00:52:43,380 --> 00:52:45,810
像你的直接表的键，所以

1030
00:52:45,810 --> 00:52:49,950
你的二级索引我想

1031
00:52:49,950 --> 00:52:59,670
是一个参考 在这种情况下，是的，

1032
00:52:59,670 --> 00:53:02,250
在这种情况下，如果您

1033
00:53:02,250 --> 00:53:06,090
有一个表，并且 ID 是您的

1034
00:53:06,090 --> 00:53:09,990
主键，那么也许在表 B 中，

1035
00:53:09,990 --> 00:53:14,370
您可以引用表 a2 以

1036
00:53:14,370 --> 00:53:16,770
在属性列中列出一个 dolt IV 在

1037
00:53:16,770 --> 00:53:19,140
那个表中，所以你可以

1038
00:53:19,140 --> 00:53:20,670
创建第二个，这就是

1039
00:53:20,670 --> 00:53:22,920
那个特定项目的二级索引，

1040
00:53:22,920 --> 00:53:25,230
所以如果你想考虑

1041
00:53:25,230 --> 00:53:27,090
更具体的事情，你有一个用户表，

1042
00:53:27,090 --> 00:53:30,960
你的用户有一个 ID，你的用户有一个

1043
00:53:30,960 --> 00:53:35,010
项目列表 它已经购买了所以对于

1044
00:53:35,010 --> 00:53:36,600
这些项目中的每一个，您可能会将

1045
00:53:36,600 --> 00:53:40,380
用户的 ID 存储在其中，或者您

1046
00:53:40,380 --> 00:53:43,460
知道它通常仅用于卡车的东西，

1047
00:53:43,460 --> 00:53:47,720
好吧，任何其他问题，

1048
00:53:52,870 --> 00:53:57,170
嗯，想想我对他的开头，我

1049
00:53:57,170 --> 00:54:00,140
在这里说的，所以最后一种方法是

1050
00:54:00,140 --> 00:54:02,060
另一个使用逻辑

1051
00:54:02,060 --> 00:54:05,930
ID 的例子基本上是你只有一些

1052
00:54:05,930 --> 00:54:08,630
合成值，它就像一个元组 ID，所以

1053
00:54:08,630 --> 00:54:10,790
这通常是一头牛，你知道

1054
00:54:10,790 --> 00:54:14,870
一个递增的计数器作为

1055
00:54:14,870 --> 00:54:17,330
元组 ID，然后你有一个哈希表

1056
00:54:17,330 --> 00:54:19,660
，说明如何 地图来回 将元组 ID

1057
00:54:19,660 --> 00:54:21,410
放到地址中

1058
00:54:21,410 --> 00:54:24,740
所以基本上你

1059
00:54:24,740 --> 00:54:26,660
将从二级索引中获取元组 ID

1060
00:54:26,660 --> 00:54:32,630
购买一件衣服是的 所以你

1061
00:54:32,630 --> 00:54:34,160
将获得二级索引的元组概念

1062
00:54:34,160 --> 00:54:37,070
然后

1063
00:54:37,070 --> 00:54:38,390
你要找出

1064
00:54:38,390 --> 00:54:41,300
物理地址在哪里，然后这里的哈希

1065
00:54:41,300 --> 00:54:43,130
表将指向

1066
00:54:43,130 --> 00:54:44,900
物理地址的位置，这样你

1067
00:54:44,900 --> 00:54:50,300
就可以读取该值，再次类似于

1068
00:54:50,300 --> 00:54:53,600
我们查看的方法，我们只是在那里

1069
00:54:53,600 --> 00:54:56,870
存储了 primary 主键

1070
00:54:56,870 --> 00:55:00,470
索引 这是逻辑指针的另一个例子，

1071
00:55:00,470 --> 00:55:03,650
这意味着如果每次

1072
00:55:03,650 --> 00:55:05,810
我们有一个新版本或每次我们

1073
00:55:05,810 --> 00:55:07,760
更新版本链，我们实际上

1074
00:55:07,760 --> 00:55:11,150
可以避免必须更新所有的

1075
00:55:11,150 --> 00:55:13,280
二级索引，所以

1076
00:55:13,280 --> 00:55:14,870
我们唯一要做的就是 在这种情况下必须更新的

1077
00:55:14,870 --> 00:55:19,160
是哈希表和

1078
00:55:19,160 --> 00:55:29,390
有意义的指针 所以这个表

1079
00:55:29,390 --> 00:55:31,250
实际上非常有趣 嗯 所以这

1080
00:55:31,250 --> 00:55:34,910
是一个这是

1081
00:55:34,910 --> 00:55:37,190
安迪和其他一些学生发表的论文中的表格

1082
00:55:37,190 --> 00:55:39,830
我认为  几年前，

1083
00:55:39,830 --> 00:55:43,610
他们实际上做的是查看

1084
00:55:43,610 --> 00:55:45,500
了许多系统，因此他们查看了

1085
00:55:45,500 --> 00:55:47,330
一些您知道的旧系统，例如

1086
00:55:47,330 --> 00:55:49,700
我的续集中的 Oracle Postgres，他们还

1087
00:55:49,700 --> 00:55:51,950
查看了过去十年中一些更新的系统

1088
00:55:51,950 --> 00:55:54,650
，例如

1089
00:55:54,650 --> 00:55:57,290
hyper  nuodb hyper 将是

1090
00:55:57,290 --> 00:55:59,870
学术系统的一个例子，所以他们

1091
00:55:59,870 --> 00:56:01,520
试图在这里获得各种系统

1092
00:56:01,520 --> 00:56:02,850
，

1093
00:56:02,850 --> 00:56:05,640
并且表格列出

1094
00:56:05,640 --> 00:56:08,070
了这些数据库系统中的每一个做出的这些设计决策中的哪些，

1095
00:56:08,070 --> 00:56:15,030
所以让我们看看安迪是否有

1096
00:56:15,030 --> 00:56:20,220
任何令人兴奋的事情，所以我猜他

1097
00:56:20,220 --> 00:56:23,480
说剧透，如果你们想要剧透

1098
00:56:23,480 --> 00:56:27,300
是或者带走剧透

1099
00:56:27,300 --> 00:56:30,930
是甲骨文和我的续集

1100
00:56:30,930 --> 00:56:33,630
他们在 PC 中的做法他们实际上发现像安迪

1101
00:56:33,630 --> 00:56:35,250
和一些学生实际上发现这种

1102
00:56:35,250 --> 00:56:38,570
方式对于 OLTP 工作负载来说是最快的，

1103
00:56:38,570 --> 00:56:41,370
并且 实际上发现

1104
00:56:41,370 --> 00:56:43,980
Postgres 是最慢的，尽管我个人

1105
00:56:43,980 --> 00:56:45,810
作为我的续集和 Postgres 的用户

1106
00:56:45,810 --> 00:56:50,190
我很喜欢 Postgres 但我也

1107
00:56:50,190 --> 00:56:53,100
没有运行你知道商业数据库

1108
00:56:53,100 --> 00:56:56,340
系统 h 生产工作负载

1109
00:56:56,340 --> 00:56:58,830
跟踪，所以你知道一旦你达到那个

1110
00:56:58,830 --> 00:57:00,960
规模它可能很重要它

1111
00:57:00,960 --> 00:57:04,800
肯定很重要所以没关系所以这

1112
00:57:04,800 --> 00:57:07,050
使我们得出结论所以今天

1113
00:57:07,050 --> 00:57:08,400
我们再次讨论了多版本

1114
00:57:08,400 --> 00:57:11,550
并发控制，正如你

1115
00:57:11,550 --> 00:57:13,680
刚刚看到的那样 在过去的几张幻灯片

1116
00:57:13,680 --> 00:57:16,710
中，这不仅仅是

1117
00:57:16,710 --> 00:57:19,190
弄清楚您知道要分配的时间戳

1118
00:57:19,190 --> 00:57:22,350
以及不同交易可见的版本，

1119
00:57:22,350 --> 00:57:26,430
因此您

1120
00:57:26,430 --> 00:57:27,450
当然知道您需要弄清楚如何

1121
00:57:27,450 --> 00:57:29,220
存储版本如何更新它们

1122
00:57:29,220 --> 00:57:32,190
如何正确更新索引以及

1123
00:57:32,190 --> 00:57:36,230
我们在此处介绍的其他项目非常

1124
00:57:36,230 --> 00:57:39,630
适合下一堂课，只是为了

1125
00:57:39,630 --> 00:57:41,220
提醒您不要来周三不要来

1126
00:57:41,220 --> 00:57:43,920
上课，因为没有人会在这里，

1127
00:57:43,920 --> 00:57:45,990
所以你们下一天请假

1128
00:57:45,990 --> 00:57:48,630
然后我认为接下来的一周安迪

1129
00:57:48,630 --> 00:57:50,340
可能会回来，尽管这

1130
00:57:50,340 --> 00:57:53,100
不确定但我们将开始登录

1131
00:57:53,100 --> 00:57:55,700
恢复哦

1132
00:58:05,730 --> 00:58:07,290
[音乐

1133
00:58:07,290 --> 00:58:16,870
]下一个将是儿子弹跳果冻

1134
00:58:16,870 --> 00:58:18,850
自然而然地去熟食店坐船

1135
00:58:18,850 --> 00:58:20,710
你保佑你说唱就像激光束

1136
00:58:20,710 --> 00:58:22,900
灌木丛中的小卒说漂亮精致的

1137
00:58:22,900 --> 00:58:25,690
链子包裹着我们的瓶子一个漂亮的金子

1138
00:58:25,690 --> 00:58:27,790
不要感觉像喝醉了的

1139
00:58:27,790 --> 00:58:30,040
你喝醉了你不能越界

1140
00:58:30,040 --> 00:58:31,720
如果清酒不 不知道你的手机可以

1141
00:58:31,720 --> 00:58:34,380
点击一个东西

