1
00:00:03,640 --> 00:00:13,140
[音乐]

2
00:00:15,279 --> 00:00:18,140
他们是我在校园里想念的活动

3
00:00:18,140 --> 00:00:24,320
或者今天有什么免费蛋糕

4
00:00:24,320 --> 00:00:25,820
很弱 好吧伙计 你放下

5
00:00:25,820 --> 00:00:30,529
桌子总是消极的

6
00:00:30,529 --> 00:00:32,450


7
00:00:32,450 --> 00:00:35,210


8
00:00:35,210 --> 00:00:37,550
这个学期你们的许多事情的大纲

9
00:00:37,550 --> 00:00:41,329
再次这些

10
00:00:41,329 --> 00:00:42,649
日期都可以在网站上找到

11
00:00:42,649 --> 00:00:46,789
然后额外的学分

12
00:00:46,789 --> 00:00:48,620
第一次反馈评论

13
00:00:48,620 --> 00:00:50,750
我们这个星期天做了什么然后我

14
00:00:50,750 --> 00:00:53,600
也在广场上发帖 昨晚如果你

15
00:00:53,600 --> 00:00:54,769
还没有这样做，请去

16
00:00:54,769 --> 00:00:56,750
投票给你希望

17
00:00:56,750 --> 00:01:10,070
我在最后一天覆盖的数据库系统是的结果

18
00:01:10,070 --> 00:01:14,320
是什么对不起结果是什么对不起

19
00:01:14,320 --> 00:01:15,439
结果

20
00:01:15,439 --> 00:01:18,170
哦是的对是的没有我还没有收到

21
00:01:18,170 --> 00:01:18,560
回复

22
00:01:18,560 --> 00:01:22,280
我 如果它进来我会尝试我会

23
00:01:22,280 --> 00:01:26,689
在课程的最后一天宣布我

24
00:01:26,689 --> 00:01:28,490
发送直到星期一我不需要

25
00:01:28,490 --> 00:01:30,500
任何一两个星期或其他什么所以

26
00:01:30,500 --> 00:01:34,040
很好再次查看与课程相关的任何其他问题

27
00:01:34,040 --> 00:01:38,479
我认为它看起来不像 像我一样

28
00:01:38,479 --> 00:01:40,540


29
00:01:40,630 --> 00:01:43,969
好吧，这是说我的 妻子过着

30
00:01:43,969 --> 00:01:45,530
某种生活方式，我会

31
00:01:45,530 --> 00:01:50,390
提出问题，所以上节课我们讨论

32
00:01:50,390 --> 00:01:51,909
的是分布式数据库的介绍，

33
00:01:51,909 --> 00:01:55,759


34
00:01:55,759 --> 00:01:59,360
我们关注的主要三件事是

35
00:01:59,360 --> 00:02:00,829
系统的系统架构是什么

36
00:02:00,829 --> 00:02:02,000
样的，我们讨论的是共享

37
00:02:02,000 --> 00:02:04,009
内存 共享磁盘什么都不显示，我

38
00:02:04,009 --> 00:02:06,859
说大多数分布式数据库

39
00:02:06,859 --> 00:02:08,060
实际上是每个分布式竞赛

40
00:02:08,060 --> 00:02:10,038
，要么是共享磁盘，

41
00:02:10,038 --> 00:02:12,560
要么确保没有任何内容不共享是

42
00:02:12,560 --> 00:02:14,480
传统上

43
00:02:14,480 --> 00:02:16,099
人们对分布式数据库采取的更流行的方法，

44
00:02:16,099 --> 00:02:18,019
但共享磁盘

45
00:02:18,019 --> 00:02:20,480
在云中变得越来越普遍 架构

46
00:02:20,480 --> 00:02:22,129
然后我们讨论的是您是否

47
00:02:22,129 --> 00:02:23,629
对分片进行分区 散列分区率

48
00:02:23,629 --> 00:02:25,819
分区循环 只是以某种

49
00:02:25,819 --> 00:02:29,440
方式将数据库分解为

50
00:02:29,440 --> 00:02:31,700
我们分配给不同不同节点的不相交的子集

51
00:02:31,700 --> 00:02:33,379


52
00:02:33,379 --> 00:02:35,180
然后我们讨论了一点

53
00:02:35,180 --> 00:02:36,260
结束 关于我们如何想要一个新的交易

54
00:02:36,260 --> 00:02:38,480
协调我们是否有一个

55
00:02:38,480 --> 00:02:41,060
集中的方法 h

56
00:02:41,060 --> 00:02:43,160


57
00:02:43,160 --> 00:02:44,720
在交易尝试进行的情况下或分散式方法的背景下，对整个新轮胎系统中正在发生的事情有一个全局视图，

58
00:02:44,720 --> 00:02:46,790


59
00:02:46,790 --> 00:02:49,340
其中

60
00:02:49,340 --> 00:02:50,810
节点本身负责

61
00:02:50,810 --> 00:02:53,030
确定您是否知道

62
00:02:53,030 --> 00:02:56,480
是否允许提交，因此 最后一

63
00:02:56,480 --> 00:03:00,319
节课，所有这些主题都

64
00:03:00,319 --> 00:03:01,640
接受了我进行事务协调，

65
00:03:01,640 --> 00:03:03,019
但在大多数情况下，我

66
00:03:03,019 --> 00:03:04,790
上节课谈到的所有内容都适用于

67
00:03:04,790 --> 00:03:07,519


68
00:03:07,519 --> 00:03:10,430
旨在运行事务的 trivedi 数据库或

69
00:03:10,430 --> 00:03:11,870
试图围绕分析运行的 de juvinity 竞赛

70
00:03:11,870 --> 00:03:14,120
所以对于这门课，然后是

71
00:03:14,120 --> 00:03:16,340
下周星期一的课，我们

72
00:03:16,340 --> 00:03:17,420
现在将购买它，讨论

73
00:03:17,420 --> 00:03:19,610
这两个课程或工作负载中的每一个的具体问题，

74
00:03:19,610 --> 00:03:21,410
因为

75
00:03:21,410 --> 00:03:22,430
他们会做出不同的权衡，

76
00:03:22,430 --> 00:03:24,440
这可能对交易有利

77
00:03:24,440 --> 00:03:25,609
但对分析

78
00:03:25,609 --> 00:03:27,470
不利，反之亦然，这再次

79
00:03:27,470 --> 00:03:29,569
提醒我，当我说

80
00:03:29,569 --> 00:03:31,069
交易处理时，我们只是一个

81
00:03:31,069 --> 00:03:32,810
肛门 最终加工油再次成为 OLAP

82
00:03:32,810 --> 00:03:34,160
我认为我们在

83
00:03:34,160 --> 00:03:35,030
整个学期中已经讨论过几次，

84
00:03:35,030 --> 00:03:38,780
只是为了重申这一二分法，

85
00:03:38,780 --> 00:03:41,030
以便每个人都在同一页面上，并且

86
00:03:41,030 --> 00:03:42,319
我们担心的所有三个工作负载都在

87
00:03:42,319 --> 00:03:44,600


88
00:03:44,600 --> 00:03:48,200
尝试更新或 读取

89
00:03:48,200 --> 00:03:51,440
数据库中的少量数据，因此再次以亚马逊

90
00:03:51,440 --> 00:03:52,970
为例，当您访问亚马逊

91
00:03:52,970 --> 00:03:55,130
网站时，将商品添加到购物车中，

92
00:03:55,130 --> 00:03:56,480
为您的帐户购买商品，

93
00:03:56,480 --> 00:03:58,400
更新您的付款信息，所有

94
00:03:58,400 --> 00:04:00,709
这些操作

95
00:04:00,709 --> 00:04:03,079
都是仅与您有关的交易 正如我们所知，

96
00:04:03,079 --> 00:04:04,400
当您调用这些更改时，它们

97
00:04:04,400 --> 00:04:07,160
只涉及您的数据，因此 Amazon

98
00:04:07,160 --> 00:04:09,380
数据库非常大，但是对于您的

99
00:04:09,380 --> 00:04:11,120
交易更新，您知道您的

100
00:04:11,120 --> 00:04:13,069
操作所涉及的数据

101
00:04:13,069 --> 00:04:15,650
量很小，并且本质上是

102
00:04:15,650 --> 00:04:17,238
数据库系统 一遍又一遍地执行相同的一

103
00:04:17,238 --> 00:04:18,649
组操作，

104
00:04:18,649 --> 00:04:21,019
因为您正在浏览

105
00:04:21,019 --> 00:04:23,479
网站应用程序代码，

106
00:04:23,479 --> 00:04:24,770
当您点击您时 知道添加到购物车

107
00:04:24,770 --> 00:04:26,479
，它调用

108
00:04:26,479 --> 00:04:27,919
应用程序代码上的一个函数，然后通过

109
00:04:27,919 --> 00:04:29,810
并执行查询以

110
00:04:29,810 --> 00:04:32,870
在 OLAP 工作负载中进行这些更改，这就是

111
00:04:32,870 --> 00:04:34,340
我们现在开始进行分析

112
00:04:34,340 --> 00:04:36,470
以尝试

113
00:04:36,470 --> 00:04:39,260
从我们拥有的所有数据中推断新信息的地方 在

114
00:04:39,260 --> 00:04:41,990
较旧的电视端摄取，因此再次使用亚马逊鸡蛋

115
00:04:41,990 --> 00:04:44,390
示例，分析工作量

116
00:04:44,390 --> 00:04:46,280
类似于试图找出

117
00:04:46,280 --> 00:04:49,100


118
00:04:49,100 --> 00:04:50,300


119
00:04:50,300 --> 00:04:52,820
11 月份卡内基梅隆大学学生最受欢迎的项目，

120
00:04:52,820 --> 00:04:55,670
当时温度高于 30 度 所以

121
00:04:55,670 --> 00:04:56,840
这不是你在 LTP 中做的事情，

122
00:04:56,840 --> 00:04:58,820
因为你知道这不是

123
00:04:58,820 --> 00:05:00,350
事务性的事情，这是

124
00:05:00,350 --> 00:05:01,640
你在 OLAP 端做的事情，

125
00:05:01,640 --> 00:05:03,830
所以这些工作负载是运行时间更长的查询，

126
00:05:03,830 --> 00:05:05,300
因为它们接触

127
00:05:05,300 --> 00:05:07,700
更多的数据，它们正在做连接和

128
00:05:07,700 --> 00:05:09,860
聚合 并且通常它们是

129
00:05:09,860 --> 00:05:12,950
一次性查询，因为有人

130
00:05:12,950 --> 00:05:14,270
试图说你知道回答这个问题哦

131
00:05:14,270 --> 00:05:16,370
，特定群体购买最多的商品是什么

132
00:05:16,370 --> 00:05:18,800
的人，你知道

133
00:05:18,800 --> 00:05:20,090
他们正在填写一些仪表板或

134
00:05:20,090 --> 00:05:22,700
使用分析工具来编写

135
00:05:22,700 --> 00:05:24,620
查询，然后将其关闭，也许

136
00:05:24,620 --> 00:05:26,060
这些数据可能永远不会再看到该查询

137
00:05:26,060 --> 00:05:28,790
，所以今天的课程

138
00:05:28,790 --> 00:05:30,650
我们将重点关注 第一部分

139
00:05:30,650 --> 00:05:32,360
哦，是 P 下节课我们将讨论

140
00:05:32,360 --> 00:05:37,520
重叠 所以再次只是为了达到

141
00:05:37,520 --> 00:05:39,440
高潮 o 讨论

142
00:05:39,440 --> 00:05:40,550
我们在分布式数据库中讨论的内容所以我们

143
00:05:40,550 --> 00:05:43,040
将专注于今天我们讨论的

144
00:05:43,040 --> 00:05:44,960
设置 在我们拥有一些分区

145
00:05:44,960 --> 00:05:47,450
数据库之前，无论是逻辑

146
00:05:47,450 --> 00:05:49,000
分区还是物理分区，

147
00:05:49,000 --> 00:05:51,020
这意味着它是不共享任何内容还是共享

148
00:05:51,020 --> 00:05:54,710
磁盘我们你知道我还没有解释今天

149
00:05:54,710 --> 00:05:56,210
我们在这里谈论的内容并不重要，但我们正在讨论

150
00:05:56,210 --> 00:05:58,790
的场景

151
00:05:58,790 --> 00:06:00,050
担心我们有一个

152
00:06:00,050 --> 00:06:01,520
应用程序服务器想要调用

153
00:06:01,520 --> 00:06:04,280
事务它选择一些分区

154
00:06:04,280 --> 00:06:06,380
节点作为主节点所以它告诉那

155
00:06:06,380 --> 00:06:08,150
个人嘿我想执行一个事务

156
00:06:08,150 --> 00:06:10,310
然后它继续执行一堆

157
00:06:10,310 --> 00:06:12,200
更新或读取一堆 ○  f 我们各个分区上的数据

158
00:06:12,200 --> 00:06:14,390
，然后现在当一个

159
00:06:14,390 --> 00:06:16,160
事务完成时，它会发送给

160
00:06:16,160 --> 00:06:17,810
它开始的大师并

161
00:06:17,810 --> 00:06:19,580
说嘿我想继续提交

162
00:06:19,580 --> 00:06:22,040
并假设这是一个分散的

163
00:06:22,040 --> 00:06:23,420
架构意味着我们没有那个

164
00:06:23,420 --> 00:06:24,890
中间件我们 现在没有

165
00:06:24,890 --> 00:06:26,750
协调我们所有事务的 TP 监视器，

166
00:06:26,750 --> 00:06:29,150
这些注释在

167
00:06:29,150 --> 00:06:30,920
自己之间确定

168
00:06:30,920 --> 00:06:32,360
是否允许提交此

169
00:06:32,360 --> 00:06:36,050
事务，所以最后一节课我

170
00:06:36,050 --> 00:06:38,450
对这里的这一步非常模糊，

171
00:06:38,450 --> 00:06:39,890
如何确定提交是否安全

172
00:06:39,890 --> 00:06:42,170
说嘿，我们

173
00:06:42,170 --> 00:06:43,310
都将继续并提交这笔

174
00:06:43,310 --> 00:06:45,230
交易是什么意思所以这是我们

175
00:06:45,230 --> 00:06:47,360
今天主要关注的

176
00:06:47,360 --> 00:06:50,330
最后一步，所以基本上

177
00:06:50,330 --> 00:06:51,199
我们要做的是我们 '

178
00:06:51,199 --> 00:06:53,300
试图在我们的数据库系统

179
00:06:53,300 --> 00:06:56,599
中让所有节点都同意

180
00:06:56,599 --> 00:06:58,939
我们应该提交一个事务，如果

181
00:06:58,939 --> 00:07:00,199
每个人都同意我们提交这个

182
00:07:00,199 --> 00:07:01,550
事务，我们继续提交

183
00:07:01,550 --> 00:07:03,800
它，我们不想要任何这样 奇怪的

184
00:07:03,800 --> 00:07:06,979
异常 rt 一个奇怪的逆转 你知道一个

185
00:07:06,979 --> 00:07:08,629
节点集将要提交，然后

186
00:07:08,629 --> 00:07:10,129
突然间，

187
00:07:10,129 --> 00:07:12,020
一旦每个人都同意

188
00:07:12,020 --> 00:07:13,939
我们将要提交，那么事务并没有回滚，然后我们

189
00:07:13,939 --> 00:07:16,129
继续提交，所以现在

190
00:07:16,129 --> 00:07:18,259


191
00:07:18,259 --> 00:07:20,000


192
00:07:20,000 --> 00:07:22,279
当我们在一个共享的一切系统上时，为了使这一切正确和安全地发生，我们必须处理很多问题，这

193
00:07:22,279 --> 00:07:23,479
意味着我们的

194
00:07:23,479 --> 00:07:24,830
数据库系统在一个机器上运行

195
00:07:24,830 --> 00:07:27,169
，我们想为 OCC 并发控制做我们你知道的

196
00:07:27,169 --> 00:07:29,629
验证协议

197
00:07:29,629 --> 00:07:30,939


198
00:07:30,939 --> 00:07:34,789
所有参与者都在

199
00:07:34,789 --> 00:07:36,139
决定这些事情是否

200
00:07:36,139 --> 00:07:38,389
在同一台机器上一起运行，所有提交都

201
00:07:38,389 --> 00:07:40,819
可能在同一个内存中，这

202
00:07:40,819 --> 00:07:42,800
真的很快，让我们弄清楚

203
00:07:42,800 --> 00:07:43,759
是否允许继续

204
00:07:43,759 --> 00:07:46,039
提交，然后如果 我们说提交，它

205
00:07:46,039 --> 00:07:47,569
真的被提交了，因为我们知道

206
00:07:47,569 --> 00:07:49,879
所有东西都在那个单一的盒子上，但是

207
00:07:49,879 --> 00:07:51,139
现在在分布式环境中，我们

208
00:07:51,139 --> 00:07:52,909
有一个问题，假设我们继续

209
00:07:52,909 --> 00:07:54,860
说提交每个人都回来

210
00:07:54,860 --> 00:07:56,839
了 是的，我们去提交，然后也许我

211
00:07:56,839 --> 00:07:58,719
在那段时间你知道一个 - 不会发生

212
00:07:58,719 --> 00:08:01,310
什么应该发生的我知道

213
00:08:01,310 --> 00:08:02,529
我们之前讨论过的所有相同的资产属性

214
00:08:02,529 --> 00:08:04,879
然后我们不需要部分更新，

215
00:08:04,879 --> 00:08:07,069
你坚持我们的数据库所有

216
00:08:07,069 --> 00:08:09,860
我们必须考虑这些事情，所以

217
00:08:09,860 --> 00:08:11,330
如果 O 出现故障，或者我必须

218
00:08:11,330 --> 00:08:13,159
处理那个，但是如果节点

219
00:08:13,159 --> 00:08:15,979
没有出现故障，而是我们的提交消息

220
00:08:15,979 --> 00:08:18,740
只是更短的显示延迟了，

221
00:08:18,740 --> 00:08:20,300
数据包以某种方式延迟了怎么办

222
00:08:20,300 --> 00:08:22,430
网络在路上，或者

223
00:08:22,430 --> 00:08:24,979
说我们的数据库系统可能更常见

224
00:08:24,979 --> 00:08:27,080
，但你知道

225
00:08:27,080 --> 00:08:28,339
JVM 是用 Java 编写的，

226
00:08:28,339 --> 00:08:30,439
它是用 Scala 编写的，它使用的是 JVM，突然之间

227
00:08:30,439 --> 00:08:32,208
JVM 决定进行一次真正昂贵的

228
00:08:32,208 --> 00:08:34,190
垃圾收集 现在我们的

229
00:08:34,190 --> 00:08:36,890
进程暂停，所以我们会看起来

230
00:08:36,890 --> 00:08:39,708
像我们不可用为什么在这个

231
00:08:39,708 --> 00:08:42,019
GC GC 传递期间然后突然我们

232
00:08:42,019 --> 00:08:43,219
在 GC 之后回来，现在我们的

233
00:08:43,219 --> 00:08:46,130
消息到达了，你知道一

234
00:08:46,130 --> 00:08:49,459
秒钟过去了然后

235
00:08:49,459 --> 00:08:53,060
如果我们决定会发生什么 即我们如何确定有

236
00:08:53,060 --> 00:08:54,320
多少节点必须同意我们

237
00:08:54,320 --> 00:08:55,699
将提交事务，以

238
00:08:55,699 --> 00:08:57,069
决定我们提交的事务

239
00:08:57,069 --> 00:09:00,740
应该是所有节点，如果其中一些是

240
00:09:00,740 --> 00:09:02,480
正确的，那么这些我们将要做的事情

241
00:09:02,480 --> 00:09:05,140
今天会担心所以

242
00:09:05,140 --> 00:09:07,280
我们要对整个讲座做出的一个重要假设

243
00:09:07,280 --> 00:09:10,190
是，我们

244
00:09:10,190 --> 00:09:12,110
将假设

245
00:09:12,110 --> 00:09:13,280
在分布式数据库中的 arm 节点上运行的软件

246
00:09:13,280 --> 00:09:15,710
或我们的朋友

247
00:09:15,710 --> 00:09:17,210
意味着他们不会尝试表现得很好

248
00:09:17,210 --> 00:09:18,200
把我们搞砸

249
00:09:18,200 --> 00:09:21,170
了，这是

250
00:09:21,170 --> 00:09:22,850
我们作为数据库系统开发人员

251
00:09:22,850 --> 00:09:25,550
编写的软件，我们已经

252
00:09:25,550 --> 00:09:26,780
部署在同一个管理

253
00:09:26,780 --> 00:09:29,510
域上，所以我们要求一个事务，我们

254
00:09:29,510 --> 00:09:31,250
要求 Endo 提交一个事务，

255
00:09:31,250 --> 00:09:32,630
他们回来了，所以是的，我们 '将要

256
00:09:32,630 --> 00:09:36,050
提交我们假设你知道一个模

257
00:09:36,050 --> 00:09:38,720
港口失败或者你知道软件错误

258
00:09:38,720 --> 00:09:40,490
我们假设如果一个节点告诉我们他们

259
00:09:40,490 --> 00:09:42,140
要提交一个事务他们会

260
00:09:42,140 --> 00:09:44,570
提交那个

261
00:09:44,570 --> 00:09:46,400
事务 以某种方式简化我们将

262
00:09:46,400 --> 00:09:49,010
如何执行我们的提交协议，如果您

263
00:09:49,010 --> 00:09:50,690
认为节点可能是坏人，

264
00:09:50,690 --> 00:09:53,120
如果他们说是的，我们

265
00:09:53,120 --> 00:09:54,470
用我们的螺丝钉承诺，我们

266
00:09:54,470 --> 00:09:56,900
实际上并没有这样做，那么您不需要

267
00:09:56,900 --> 00:09:57,620
一些 在我们今天要讨论的事情中

268
00:09:57,620 --> 00:09:58,790
，您实际上需要所谓

269
00:09:58,790 --> 00:10:01,060
的繁忙的团队容错协议，

270
00:10:01,060 --> 00:10:03,080
这本质上

271
00:10:03,080 --> 00:10:07,100
就是比特币下的区块链。

272
00:10:07,100 --> 00:10:08,770


273
00:10:08,770 --> 00:10:11,240


274
00:10:11,240 --> 00:10:13,580
在那种环境中你

275
00:10:13,580 --> 00:10:15,020
很快就会因为有比特币挖矿

276
00:10:15,020 --> 00:10:16,310
权或者你试图做的任何事情

277
00:10:16,310 --> 00:10:18,770
，

278
00:10:18,770 --> 00:10:20,480
分布式数据库中的参与者不是你的朋友

279
00:10:20,480 --> 00:10:22,280
，他们可以对你撒谎，所以你需要一种

280
00:10:22,280 --> 00:10:24,800
方法来处理我们不在那个

281
00:10:24,800 --> 00:10:27,410
世界 大多数数据库系统持久性

282
00:10:27,410 --> 00:10:28,730
系统不在这个世界上大多数

283
00:10:28,730 --> 00:10:30,680
冰箱可以假设每个

284
00:10:30,680 --> 00:10:32,210
人都会

285
00:10:32,210 --> 00:10:36,050
正确地玩大多数人不需要

286
00:10:36,050 --> 00:10:37,340
区块链很少有东西需要ab

287
00:10:37,340 --> 00:10:38,270
锁链所以如果你认为你正在

288
00:10:38,270 --> 00:10:39,140
构建一些东西并且你使用

289
00:10:39,140 --> 00:10:44,120
区块链你重新思考你的生活没

290
00:10:44,120 --> 00:10:45,830
问题所以今天谈论的事情

291
00:10:45,830 --> 00:10:47,870
列在这里所以是的我没有

292
00:10:47,870 --> 00:10:49,310
说最后一堂课我想

293
00:10:49,310 --> 00:10:51,470
再说一遍我 我试图在三个

294
00:10:51,470 --> 00:10:53,360
讲座中涵盖通常

295
00:10:53,360 --> 00:10:55,910
一整年研究分布式

296
00:10:55,910 --> 00:10:58,160
数据库的内容，因此我们显然无法

297
00:10:58,160 --> 00:11:00,770
详细涵盖所有内容，我认为我

298
00:11:00,770 --> 00:11:03,470
在这里的目标只是让您喜欢

299
00:11:03,470 --> 00:11:05,390
这些问题，问题和

300
00:11:05,390 --> 00:11:07,970
困难 甚至使用分布式数据库系统构建分布式数据库，

301
00:11:07,970 --> 00:11:09,710


302
00:11:09,710 --> 00:11:11,270
这样您就知道什么时候离开 CMU，

303
00:11:11,270 --> 00:11:13,040
如果您发现

304
00:11:13,040 --> 00:11:14,220
自己

305
00:11:14,220 --> 00:11:16,320
认为自己需要用户 Trivedi 数据库或您想构建的情况，那么您将在现实世界中

306
00:11:16,320 --> 00:11:18,480


307
00:11:18,480 --> 00:11:20,760
通常会下雪

308
00:11:20,760 --> 00:11:22,590
你应该考虑哪些问题，

309
00:11:22,590 --> 00:11:24,090
所以你可以推理你知道

310
00:11:24,090 --> 00:11:26,340
你是否在做正确的事情，并且

311
00:11:26,340 --> 00:11:28,260
预先说大多数人可能

312
00:11:28,260 --> 00:11:30,180
不需要糖数据 abase

313
00:11:30,180 --> 00:11:32,850
显然有一些有用的案例，但我的

314
00:11:32,850 --> 00:11:34,890
意思是我无法证明这一点，但

315
00:11:34,890 --> 00:11:36,630
世界上 90% 的数据库都在一个机器上运行，

316
00:11:36,630 --> 00:11:38,970
现在我应该进行复制

317
00:11:38,970 --> 00:11:40,440
，一旦你把它引入，它就变成

318
00:11:40,440 --> 00:11:42,180
了一个贡品数据库，但大多数 有时

319
00:11:42,180 --> 00:11:43,740
您不需要分区数据库 大多数

320
00:11:43,740 --> 00:11:45,150
工作负载都可以在

321
00:11:45,150 --> 00:11:49,950
单个机器上处理 好吧 所以让我们

322
00:11:49,950 --> 00:11:51,120
谈谈提交时间协议是

323
00:11:51,120 --> 00:11:51,960
如何让每个人都同意我们

324
00:11:51,960 --> 00:11:53,220
将提交 我们如何处理

325
00:11:53,220 --> 00:11:54,900
复制 确保我们有

326
00:11:54,900 --> 00:11:57,000
多个数据副本，这样我们就可以

327
00:11:57,000 --> 00:11:58,770
始终保持在线状态，然后我们就会

328
00:11:58,770 --> 00:11:59,760
陷入恐慌 我说的是

329
00:11:59,760 --> 00:12:01,590
一致性问题，我们如何知道

330
00:12:01,590 --> 00:12:03,420
我可以分发

331
00:12:03,420 --> 00:12:06,300
数据库并为

332
00:12:06,300 --> 00:12:08,850
我们提供什么样的保证？ 提交协议，然后我们

333
00:12:08,850 --> 00:12:09,660
有时间在最后很好地快速

334
00:12:09,660 --> 00:12:11,460
讨论联合数据库 将

335
00:12:11,460 --> 00:12:13,740
不同的数据库

336
00:12:13,740 --> 00:12:15,030
组合在一起并使单个数据库

337
00:12:15,030 --> 00:12:19,380
实例正常的想法 所以我

338
00:12:19,380 --> 00:12:21,570
在请求中展示的示例 当我们

339
00:12:21,570 --> 00:12:22,380
继续提交事务时

340
00:12:22,380 --> 00:12:25,260
，那个人知道如何

341
00:12:25,260 --> 00:12:26,790
与其他节点交谈并说嘿

342
00:12:26,790 --> 00:12:28,920
提交是否安全这就是所谓的

343
00:12:28,920 --> 00:12:32,070
原子提交协议，但这里的想法

344
00:12:32,070 --> 00:12:34,290
是我们想要 获取

345
00:12:34,290 --> 00:12:37,050
参与我们交易的每个人的反馈，以

346
00:12:37,050 --> 00:12:39,330
决定是否可以提交该

347
00:12:39,330 --> 00:12:43,920
交易，然后

348
00:12:43,920 --> 00:12:45,810


349
00:12:45,810 --> 00:12:50,010
如果一定数量的节点

350
00:12:50,010 --> 00:12:51,330
高于我们将在我们的协议中定义的阈值，则根据使用的协议是一个节点还是足够多的节点

351
00:12:51,330 --> 00:12:53,220
同意我们应该

352
00:12:53,220 --> 00:12:54,840
提交这个事务，然后我们告诉

353
00:12:54,840 --> 00:12:56,670
每个人我们将提交这个事务

354
00:12:56,670 --> 00:12:59,400
，然后它就会被提交，

355
00:12:59,400 --> 00:13:01,010
所以你可以使用许多不同的原子提交协议变体，

356
00:13:01,010 --> 00:13:03,210


357
00:13:03,210 --> 00:13:05,370
所以我们要关注的两个

358
00:13:05,370 --> 00:13:07,020
是 两阶段提交和 Paxos 两阶段

359
00:13:07,020 --> 00:13:08,310
提交可能是最流行的

360
00:13:08,310 --> 00:13:10,710
一种权利可以追溯到 1980 年代，

361
00:13:10,710 --> 00:13:12,540
paxos 有一定的保证，即

362
00:13:12,540 --> 00:13:15,330
两阶段提交不能提供某些

363
00:13:15,330 --> 00:13:17,670
系统可以 看到这个，但这

364
00:13:17,670 --> 00:13:19,020
是一个退化的例子

365
00:13:19,020 --> 00:13:21,330
还有一个三阶段提交

366
00:13:21,330 --> 00:13:22,680
，实际上是由 Mike Stonebraker 开发的，

367
00:13:22,680 --> 00:13:23,610
这个人

368
00:13:23,610 --> 00:13:26,310
在 1980 年代发明了 Postgres 没有人真正

369
00:13:26,310 --> 00:13:28,290
这样做过，

370
00:13:28,290 --> 00:13:29,880
你知道的网络太多了

371
00:13:29,880 --> 00:13:32,340
流量实际上还有来自微软的四

372
00:13:32,340 --> 00:13:34,350
阶段提交，

373
00:13:34,350 --> 00:13:36,360
他们在这只是为了作为一个称为表单的基础，

374
00:13:36,360 --> 00:13:38,250
他们必须这样做，因为

375
00:13:38,250 --> 00:13:39,870
他们再次使用我们的 DMA 类型的特殊

376
00:13:39,870 --> 00:13:41,910
远程内存访问，我们不

377
00:13:41,910 --> 00:13:43,980
打算涵盖这一点，好吧 Pat 所以我们将

378
00:13:43,980 --> 00:13:46,770
讨论 raft 是

379
00:13:46,770 --> 00:13:51,690
大约十年前由斯坦福开发的，作为一种更

380
00:13:51,690 --> 00:13:53,940
容易理解的 paxos 变体，但

381
00:13:53,940 --> 00:13:54,930
它基本上提供了相同的

382
00:13:54,930 --> 00:13:57,060
保证

383
00:13:57,060 --> 00:13:59,580


384
00:13:59,580 --> 00:14:01,890
现有的

385
00:14:01,890 --> 00:14:03,780
或者人们基本上像 Lib raft 一样编写，

386
00:14:03,780 --> 00:14:05,790
他们在

387
00:14:05,790 --> 00:14:06,960
实现 wrap 的库中，然后您可以

388
00:14:06,960 --> 00:14:09,600
将其合并到他们的数据库中，用于

389
00:14:09,600 --> 00:14:11,340
大量不同的语言，例如

390
00:14:11,340 --> 00:14:12,930
不是每个人都可以使用的 Lib Paxos

391
00:14:12,930 --> 00:14:16,350
Zab 是为 Apache zookeeper 开发的，

392
00:14:16,350 --> 00:14:18,750
视图标记复制

393
00:14:18,750 --> 00:14:20,250
并不常见，但这实际上

394
00:14:20,250 --> 00:14:22,920
是第一个完全正确的原子

395
00:14:22,920 --> 00:14:24,600
提交协议，它实际上

396
00:14:24,600 --> 00:14:26,520
在 Paxos 之前出现，但人们没有

397
00:14:26,520 --> 00:14:27,840
意识到 这个东西的属性

398
00:14:27,840 --> 00:14:30,990
直到 pax 出现很晚才出现，

399
00:14:30,990 --> 00:14:32,910
所以对于

400
00:14:32,910 --> 00:14:35,700
不在区块链中的分布式数据库，实际上

401
00:14:35,700 --> 00:14:36,960
你可能在现实

402
00:14:36,960 --> 00:14:39,960
世界中遇到过使用，你最有可能看到

403
00:14:39,960 --> 00:14:41,850
两阶段提交或paxos，然后从

404
00:14:41,850 --> 00:14:43,500
新助手应用 wrap 但在本次

405
00:14:43,500 --> 00:14:45,000
讲座中我将只介绍这两个

406
00:14:45,000 --> 00:14:46,950
它们是两个基本提交影响

407
00:14:46,950 --> 00:14:49,230
那些如此实际的快速举手之前在

408
00:14:49,230 --> 00:14:50,370
这里听说过两阶段提交的人还

409
00:14:50,370 --> 00:14:51,990


410
00:14:51,990 --> 00:14:54,900
好比那好所以两阶段提交

411
00:14:54,900 --> 00:14:56,760
听起来就像你所知道的

412
00:14:56,760 --> 00:14:58,410
听起来像是一个两阶段提交

413
00:14:58,410 --> 00:14:59,580
协议 有两个阶段

414
00:14:59,580 --> 00:15:01,710
所以让我们看一个例子，

415
00:15:01,710 --> 00:15:03,000
我们将让每个人都同意

416
00:15:03,000 --> 00:15:05,310
提交交易 因此假设

417
00:15:05,310 --> 00:15:07,410
此时应用程序服务器已经

418
00:15:07,410 --> 00:15:09,210
执行了它

419
00:15:09,210 --> 00:15:11,160
想要对数据库进行更改的任何查询，或者

420
00:15:11,160 --> 00:15:13,320
在我们的不同节点上读取了任何曾经做过的数据，

421
00:15:13,320 --> 00:15:15,690
并且它想

422
00:15:15,690 --> 00:15:17,220
继续提交，因此它将向此发送提交

423
00:15:17,220 --> 00:15:19,500
消息 这里的人假设这

424
00:15:19,500 --> 00:15:22,470
是主节点，所以在两阶段

425
00:15:22,470 --> 00:15:24,420
提交下，我们会说

426
00:15:24,420 --> 00:15:25,860
这个人将以协调器为中心，

427
00:15:25,860 --> 00:15:27,980
因此负责

428
00:15:27,980 --> 00:15:30,570
询问

429
00:15:30,570 --> 00:15:32,310
参与事务的朋友是否允许

430
00:15:32,310 --> 00:15:34,380
提交此事务 然后

431
00:15:34,380 --> 00:15:35,550
这里的另外两个节点我们

432
00:15:35,550 --> 00:15:37,470
现在称为参与者

433
00:15:37,470 --> 00:15:39,390
我不打算展示这个例子

434
00:15:39,390 --> 00:15:41,070
但是参与者节点本身

435
00:15:41,070 --> 00:15:41,490


436
00:15:41,490 --> 00:15:44,720
也可以是参与者的节点对这个

437
00:15:44,720 --> 00:15:46,890
这里的注释也可以

438
00:15:46,890 --> 00:15:48,390
被这个事务修改然后

439
00:15:48,390 --> 00:15:49,589
它是 参与这个两阶段提交

440
00:15:49,589 --> 00:15:52,500
过程或简单假设

441
00:15:52,500 --> 00:15:54,570
这里的这个事务只修改

442
00:15:54,570 --> 00:15:58,410
了其他两个节点上的数据，所以在

443
00:15:58,410 --> 00:16:00,720
第一阶段称为准备 阶段我们

444
00:16:00,720 --> 00:16:02,930


445
00:16:02,930 --> 00:16:04,740
从协调器向

446
00:16:04,740 --> 00:16:06,810
参与者发送网络消息给参与者询问他们嘿这是这个

447
00:16:06,810 --> 00:16:08,580
交易我们认为你

448
00:16:08,580 --> 00:16:12,060
知道可以提交他们会

449
00:16:12,060 --> 00:16:13,500
做任何验证或他们

450
00:16:13,500 --> 00:16:15,029
需要做的任何事情来确定是否 这个

451
00:16:15,029 --> 00:16:17,040
事务是实时提交的，如果他们

452
00:16:17,040 --> 00:16:19,200
确定没问题，那么他们会发

453
00:16:19,200 --> 00:16:22,890
回一个好的消息，然后现在一旦你

454
00:16:22,890 --> 00:16:24,750
从所有参与者那里得到好的消息

455
00:16:24,750 --> 00:16:26,580
，协调器就会

456
00:16:26,580 --> 00:16:28,970
进入第二阶段，称为提交阶段

457
00:16:28,970 --> 00:16:31,890
，在那里它告诉所有参与者

458
00:16:31,890 --> 00:16:33,930
嘿好 消息每个人都说我们可以

459
00:16:33,930 --> 00:16:35,550
提交这个事务继续

460
00:16:35,550 --> 00:16:38,190
提交这个然后同样这些人

461
00:16:38,190 --> 00:16:39,750
现在必须发送一个响应并说好的

462
00:16:39,750 --> 00:16:40,890
我们已经提交了这个事务

463
00:16:40,890 --> 00:16:43,350
然后在这里

464
00:16:43,350 --> 00:16:45,029
当我们回来时在第二

465
00:16:45,029 --> 00:16:47,370
阶段 好的，来自我们所有的参与者，

466
00:16:47,370 --> 00:16:49,410
然后我们可以去告诉外界

467
00:16:49,410 --> 00:16:50,550
我们的交易已成功

468
00:16:50,550 --> 00:16:55,740
提交，所以有一件事我没有

469
00:16:55,740 --> 00:16:56,880
向他展示 我认为

470
00:16:56,880 --> 00:16:59,250
教科书谈到了这一点，在

471
00:16:59,250 --> 00:17:02,100


472
00:17:02,100 --> 00:17:04,050
涉及其中的每个节点上的协议的每一步，我们都会

473
00:17:04,050 --> 00:17:06,780
写出日志消息以跟踪

474
00:17:06,780 --> 00:17:08,520
我们收到的消息以及

475
00:17:08,520 --> 00:17:11,730
我们发送的消息和响应 在这

476
00:17:11,730 --> 00:17:13,410
一点上，当我发送嘿我们会

477
00:17:13,410 --> 00:17:15,510
继续提交这个这些人

478
00:17:15,510 --> 00:17:16,829
会写一条日志消息并说

479
00:17:16,829 --> 00:17:19,770
嘿这个事务我看到我得到了一个

480
00:17:19,770 --> 00:17:21,030
提交阶段的inter，我说

481
00:17:21,030 --> 00:17:24,750
可以这样做 这样，如果我们崩溃

482
00:17:24,750 --> 00:17:26,520
并回来，我们会说哦，我们

483
00:17:26,520 --> 00:17:29,100
参与此事务的程度以及

484
00:17:29,100 --> 00:17:30,720
在两阶段提交过程中

485
00:17:30,720 --> 00:17:32,280
我们确定是否需要

486
00:17:32,280 --> 00:17:34,970
撤消或重做它

487
00:17:36,490 --> 00:17:37,870
，因此另一点对此模糊不清

488
00:17:37,870 --> 00:17:39,700
这将不同于税收，

489
00:17:39,700 --> 00:17:41,830
还有几张幻灯片是，所有

490
00:17:41,830 --> 00:17:44,110
节点都阻止

491
00:17:44,110 --> 00:17:46,270
了此事务提交协议中的所有参与者节点，

492
00:17:46,270 --> 00:17:49,000
他们都必须说我们必须提交

493
00:17:49,000 --> 00:17:49,800
此事务

494
00:17:49,800 --> 00:17:54,940
，要么是所有人，要么没有人，所以我们

495
00:17:54,940 --> 00:17:56,620
转到下一个 样品在这里 其中一个我们

496
00:17:56,620 --> 00:17:58,360
已经有一个中止它又是

497
00:17:58,360 --> 00:18:00,400
同样的事情 Mike 事务完成了我

498
00:18:00,400 --> 00:18:02,080
向我的协调器发送了一个提交请求

499
00:18:02,080 --> 00:18:04,030
协调器进入第一阶段

500
00:18:04,030 --> 00:18:06,490
将准备消息发送到 to-to-to

501
00:18:06,490 --> 00:18:08,950
参与者节点让我们说这个底层

502
00:18:08,950 --> 00:18:11,170
人在这里做任何事情 你

503
00:18:11,170 --> 00:18:12,730
知道它的并发性或协议的

504
00:18:12,730 --> 00:18:13,870
大小，我们不能提交这个

505
00:18:13,870 --> 00:18:16,570
事务，所以它发回一个中止

506
00:18:16,570 --> 00:18:18,970
消息，所以一旦协调器

507
00:18:18,970 --> 00:18:21,370
从任何参与者那里得到第一个中止消息，

508
00:18:21,370 --> 00:18:23,680
它就不再处于

509
00:18:23,680 --> 00:18:25,540
准备阶段，现在它 中间

510
00:18:25,540 --> 00:18:27,700
进入下一阶段，在这种情况下，我们

511
00:18:27,700 --> 00:18:30,340
支持中止，因此此时我们

512
00:18:30,340 --> 00:18:32,890
可以真正回到我们的客户端我们的

513
00:18:32,890 --> 00:18:34,090
应用程序并说嘿，此事务

514
00:18:34,090 --> 00:18:36,610
无法完成我们甚至

515
00:18:36,610 --> 00:18:38,440
在我们离开之前就将中止 到第二阶段，

516
00:18:38,440 --> 00:18:39,340
甚至在我们收到

517
00:18:39,340 --> 00:18:41,530
其他人的回复之前，一个中止消息将

518
00:18:41,530 --> 00:18:44,590
杀死整个事情，所以现在在中止

519
00:18:44,590 --> 00:18:46,480
阶段，我们说嘿，我们正在中止这件事，

520
00:18:46,480 --> 00:18:48,430
然后每个人都回来说好的，我们” 已经

521
00:18:48,430 --> 00:18:51,360
中止，此时

522
00:18:51,360 --> 00:18:55,420
交易已完成，因此这里的想法

523
00:18:55,420 --> 00:18:57,130
是我们需要网络往返行程以

524
00:18:57,130 --> 00:18:58,300
使每个人都同意

525
00:18:58,300 --> 00:19:00,070
提交此事务，

526
00:19:00,070 --> 00:19:01,720
然后我们继续提交或中止此

527
00:19:01,720 --> 00:19:02,980
事务，然后我们继续 然后

528
00:19:02,980 --> 00:19:11,470
应用该更改 yes 所以

529
00:19:11,470 --> 00:19:13,330
这个中止提交的问题是

530
00:19:13,330 --> 00:19:16,450
我是否需要在这里进行第二轮来

531
00:19:16,450 --> 00:19:18,790
告诉我是否需要去这里的节点

532
00:19:18,790 --> 00:19:20,860
并在

533
00:19:20,860 --> 00:19:24,360
我告诉应用程序运行之前说是你已经提交 我

534
00:19:33,750 --> 00:19:37,570
告诉他他的问题在这里是一样的 我在

535
00:19:37,570 --> 00:19:38,800
准备阶段这个规则行动应该

536
00:19:38,800 --> 00:19:41,560
提交一个半准备请求

537
00:19:41,560 --> 00:19:45,910
这些人发回好的是我真的

538
00:19:45,910 --> 00:19:48,250
需要等待下一次往返

539
00:19:48,250 --> 00:19:49,660
说好的继续并提交这个 并

540
00:19:49,660 --> 00:19:50,169


541
00:19:50,169 --> 00:19:51,730
在我告诉应用程序之前从他们那里回来，

542
00:19:51,730 --> 00:19:55,210
我需要在实践中承诺

543
00:19:55,210 --> 00:20:00,220
绝对正确性是的，因为

544
00:20:00,220 --> 00:20:04,629
如果我在这里崩溃，如果我可以战斗，

545
00:20:04,629 --> 00:20:11,529


546
00:20:11,529 --> 00:20:14,080
那么在恢复所需的时间之间需要权衡 d

547
00:20:14,080 --> 00:20:16,570
发送响应所需的时间，

548
00:20:16,570 --> 00:20:18,909
因此，如果我将所有内容都记录到磁盘，

549
00:20:18,909 --> 00:20:20,200
那么您

550
00:20:20,200 --> 00:20:23,409
一回到这里就

551
00:20:23,409 --> 00:20:25,450


552
00:20:25,450 --> 00:20:27,429
对了

553
00:20:27,429 --> 00:20:29,950
在协调器中，所以现在如果我崩溃了，

554
00:20:29,950 --> 00:20:32,409
我会回来，我会说

555
00:20:32,409 --> 00:20:34,509
保存协调器宕机了，它

556
00:20:34,509 --> 00:20:35,830
会在很长一段时间内回来说哦，我

557
00:20:35,830 --> 00:20:37,989
解决了这个问题，你知道我收到了这些

558
00:20:37,989 --> 00:20:39,359
消息，我是否提交了

559
00:20:39,359 --> 00:20:42,070
好吧，确保我正在申请任何

560
00:20:42,070 --> 00:20:44,590
交换，如果这些人中的一个人倒下，

561
00:20:44,590 --> 00:20:46,840
他们会回来，但他们

562
00:20:46,840 --> 00:20:48,700
仍然需要知道你

563
00:20:48,700 --> 00:20:50,169
是否知道它是否真的

564
00:20:50,169 --> 00:20:51,700
真正免费在他们得到之前你知道

565
00:20:51,700 --> 00:20:54,700
重做一切，所以在

566
00:20:54,700 --> 00:20:55,809
你要求的性能的正确性

567
00:20:55,809 --> 00:21:12,039
你不必这样做是的所以这个

568
00:21:12,039 --> 00:21:14,649
问题是如果我在这里然后我发

569
00:21:14,649 --> 00:21:16,119
回所以我得到了我到了这一点

570
00:21:16,119 --> 00:21:17,850
每个人都同意我们会承诺

571
00:21:17,850 --> 00:21:19,929
我们会写 在

572
00:21:19,929 --> 00:21:21,580
协调器的磁盘上，我们已经承诺

573
00:21:21,580 --> 00:21:23,080
每个人 贪婪地提交，因此

574
00:21:23,080 --> 00:21:24,789
我们可以进入第二阶段

575
00:21:24,789 --> 00:21:25,840
，然后继续进行

576
00:21:25,840 --> 00:21:30,129
提交，但是我之前崩溃了，然后

577
00:21:30,129 --> 00:21:31,690
我回来了，我可以重新应用更改

578
00:21:31,690 --> 00:21:33,279
，我没有告诉这个人他

579
00:21:33,279 --> 00:21:35,350
提交了 所以这实际上并不能

580
00:21:35,350 --> 00:21:37,090
保证我们可以在我们的

581
00:21:37,090 --> 00:21:39,669
数据库系统中提供，如果这是真的，

582
00:21:39,669 --> 00:21:41,950
无论是单节点还是分布式所以如果

583
00:21:41,950 --> 00:21:43,749
我们到了这样的地步，你

584
00:21:43,749 --> 00:21:45,309
知道我们将日志刷新到磁盘，我们

585
00:21:45,309 --> 00:21:46,389
每个人都同意我们要去

586
00:21:46,389 --> 00:21:49,029
提交但在我们告诉

587
00:21:49,029 --> 00:21:50,859
外部世界我们已经提交之前我们崩溃了

588
00:21:50,859 --> 00:21:52,149
而且永远不会 Versa 不会

589
00:21:52,149 --> 00:21:53,859
去 牵引实际上仍然被

590
00:21:53,859 --> 00:21:55,570
认为是提交的

591
00:21:55,570 --> 00:21:57,129
，然后由应用程序代码

592
00:21:57,129 --> 00:21:58,659
返回并弄清楚是否

593
00:21:58,659 --> 00:22:00,099
它询问是否实际提交的双重问题

594
00:22:00,099 --> 00:22:01,929
我们无法保证正确，

595
00:22:01,929 --> 00:22:03,620
因为

596
00:22:03,620 --> 00:22:05,630
在这种情况下我们如何知道此消息

597
00:22:05,630 --> 00:22:08,570
可能会丢失应用程序

598
00:22:08,570 --> 00:22:09,680
数据库服务器它不应该

599
00:22:09,680 --> 00:22:14,650
负责 弄清楚

600
00:22:17,200 --> 00:22:20,630
是哪个喜欢这个 那个喜欢

601
00:22:20,630 --> 00:22:23,540
这个 第二阶段 不，你

602
00:22:23,540 --> 00:22:24,980
可以就像

603
00:22:24,980 --> 00:22:27,620
妈妈在单个节点上的事务

604
00:22:27,620 --> 00:22:28,670
一样，我一注意到

605
00:22:28,670 --> 00:22:31,850
我就中止了 为什么要等待刷新任何 CLR

606
00:22:31,850 --> 00:22:33,620
任何东西 出磁盘我只是

607
00:22:33,620 --> 00:22:34,730
立即告诉外界你会登上

608
00:22:34,730 --> 00:22:36,559
它，谁在乎呢，因为

609
00:22:36,559 --> 00:22:38,179
这好像交易从未

610
00:22:38,179 --> 00:22:42,590
执行过所以我们马上告诉它你

611
00:22:42,590 --> 00:22:48,110
有问题还是没有好所以实际上

612
00:22:48,110 --> 00:22:50,300
与他之前的问题有关

613
00:22:50,300 --> 00:22:51,650
在

614
00:22:51,650 --> 00:22:53,840
我

615
00:22:53,840 --> 00:22:56,510
告诉外界我承诺

616
00:22:56,510 --> 00:22:57,890
这实际上是

617
00:22:57,890 --> 00:22:59,360
您实际上可以做的两个优化来

618
00:22:59,360 --> 00:23:01,640
加速协议并

619
00:23:01,640 --> 00:23:06,590
换取更长的恢复时间之前，我真的需要等待

620
00:23:06,590 --> 00:23:07,940
那是这里的第二个，这

621
00:23:07,940 --> 00:23:08,690
就是他提出的，

622
00:23:08,690 --> 00:23:10,160
所以你可以做的第一个优化是

623
00:23:10,160 --> 00:23:12,050
捕获早期准备好的加载

624
00:23:12,050 --> 00:23:14,660
，如果我知道我的

625
00:23:14,660 --> 00:23:18,320
应用程序正在发送最后一个查询

626
00:23:18,320 --> 00:23:20,600
，那就是 e  ver 将执行到其中

627
00:23:20,600 --> 00:23:23,990
一个参与者节点，然后除了

628
00:23:23,990 --> 00:23:26,150
向我发送查询之外，我还

629
00:23:26,150 --> 00:23:28,250
附带另一条消息，它说哦

630
00:23:28,250 --> 00:23:30,140
，顺便说一句，我永远不会回来，你要求

631
00:23:30,140 --> 00:23:32,120
你做任何其他事情，所以继续

632
00:23:32,120 --> 00:23:33,830
发送给我 您的响应就

633
00:23:33,830 --> 00:23:35,929
好像我们处于两阶段提交的准备阶段一样，

634
00:23:35,929 --> 00:23:38,059
所以现在

635
00:23:38,059 --> 00:23:40,910
退出查询并

636
00:23:40,910 --> 00:23:42,620
运行准备阶段是一个网络消息，然后我得到我的响应，

637
00:23:42,620 --> 00:23:44,960
我得到了该查询的结果

638
00:23:44,960 --> 00:23:48,440
加上 准备检查的结果，所以这

639
00:23:48,440 --> 00:23:50,000
显然要求您知道

640
00:23:50,000 --> 00:23:50,870
应用程序服务器，您永远

641
00:23:50,870 --> 00:23:53,000
不会返回并

642
00:23:53,000 --> 00:23:58,160
对该节点上的那个节点运行另一个查询，他

643
00:23:58,160 --> 00:24:01,610
提议的是它

644
00:24:01,610 --> 00:24:04,580
在准备后被称为早期确认，所以 一旦您

645
00:24:04,580 --> 00:24:05,960
知道

646
00:24:05,960 --> 00:24:07,460
每个人都同意提交此

647
00:24:07,460 --> 00:24:10,340
事务的已知协调器，那么您只需告诉

648
00:24:10,340 --> 00:24:11,570
外界您的连接

649
00:24:11,570 --> 00:24:13,340
事务已提交，然后您

650
00:24:13,340 --> 00:24:15,370
就可以处理

651
00:24:15,370 --> 00:24:17,650
提交阶段，因此再次直观地显示它'

652
00:24:17,650 --> 00:24:19,870
像这样我确实提交了准备阶段

653
00:24:19,870 --> 00:24:21,910
每个人都投票认为可以

654
00:24:21,910 --> 00:24:23,290


655
00:24:23,290 --> 00:24:25,360


656
00:24:25,360 --> 00:24:26,500


657
00:24:26,500 --> 00:24:30,940


658
00:24:30,940 --> 00:24:33,070
这次

659
00:24:33,070 --> 00:24:37,150
往返的撞车率很低，所以

660
00:24:37,150 --> 00:24:39,490
我可以继续执行此操作，

661
00:24:39,490 --> 00:24:42,600
如果我现在在此期间撞车了，您知道

662
00:24:42,600 --> 00:24:44,680
在我收到此消息之前说

663
00:24:44,680 --> 00:24:46,330
从 B 那里回来，然后我必须做

664
00:24:46,330 --> 00:24:47,679
额外的事情 努力弄清楚我是否真的

665
00:24:47,679 --> 00:24:49,210
真的提交并正确解决了这

666
00:24:49,210 --> 00:24:57,940
件事，但这没关系是的这个

667
00:24:57,940 --> 00:25:00,940
问题是如果我们处于

668
00:25:00,940 --> 00:25:03,370
这个阶段并准备交易我得到我的

669
00:25:03,370 --> 00:25:04,720
准备消息参与者说好的

670
00:25:04,720 --> 00:25:08,590
我要提交这个你的问题

671
00:25:08,590 --> 00:25:16,080
是的，是的，

672
00:25:16,080 --> 00:25:30,460


673
00:25:30,460 --> 00:25:35,860


674
00:25:35,860 --> 00:25:37,390


675
00:25:37,390 --> 00:25:39,670


676
00:25:39,670 --> 00:25:42,640
是的 它说我

677
00:25:42,640 --> 00:25:45,210
告诉了 correlator 我要提交

678
00:25:45,210 --> 00:25:48,100
我要做什么我想很好地回来

679
00:25:48,100 --> 00:25:49,390
，你认为协调员会很

680
00:25:49,390 --> 00:25:50,800
清楚这个人现在崩溃了，他

681
00:25:50,800 --> 00:25:54,100
回来了，我在我的日志中，

682
00:25:54,100 --> 00:25:55,510
我会然后我会说好的 好吧，

683
00:25:55,510 --> 00:25:58,330
我看到每个人都提交了这个

684
00:25:58,330 --> 00:26:00,550
事务应该提交的提交，所以

685
00:26:00,550 --> 00:26:01,870


686
00:26:01,870 --> 00:26:05,080


687
00:26:05,080 --> 00:26:14,770
当它恢复正确时

688
00:26:14,770 --> 00:26:17,170
，你会根据需要引用或填写参与者参与者的缺失信息，这样你就会在这里收到提交消息

689
00:26:17,170 --> 00:26:19,120
，然后永远不会

690
00:26:19,120 --> 00:26:21,040
出现 先生然后它死了所以这

691
00:26:21,040 --> 00:26:23,350
需要你有所以我们不会这样做

692
00:26:23,350 --> 00:26:25,650
这是更多分布式系统的

693
00:26:25,650 --> 00:26:28,300
东西但你关心的是我们

694
00:26:28,300 --> 00:26:29,230
需要听到

695
00:26:29,230 --> 00:26:30,250
这个你可以像心跳一样使用它

696
00:26:30,250 --> 00:26:31,990
只是为了跟踪就像是

697
00:26:31,990 --> 00:26:34,000
有这件事的注意事项确定我是否

698
00:26:34,000 --> 00:26:35,440
有一段时间没有收到他们的回复

699
00:26:35,440 --> 00:26:37,809
，进入某种恢复模式或

700
00:26:37,809 --> 00:26:41,040
失败模式来处理这种情况

701
00:26:41,040 --> 00:26:51,790
是的，先生，您的问题是我们

702
00:26:51,790 --> 00:26:59,620
为什么要发送，所以 当我  应该

703
00:26:59,620 --> 00:27:01,929
问的是为什么我们不在

704
00:27:01,929 --> 00:27:03,510
提交阶段之后发送成功消息

705
00:27:03,510 --> 00:27:06,190
是的，所以这就像原始的

706
00:27:06,190 --> 00:27:08,140
两阶段提交协议一样，它是

707
00:27:08,140 --> 00:27:09,760
如何正确工作的，

708
00:27:09,760 --> 00:27:12,160
但请考虑一下我并不是说

709
00:27:12,160 --> 00:27:13,990
这些注释所在的位置可能

710
00:27:13,990 --> 00:27:15,220
在 同一个机架和同一个数据

711
00:27:15,220 --> 00:27:17,169
中心，它可能遍布世界各地，

712
00:27:17,169 --> 00:27:19,840
而不是我等待下一次

713
00:27:19,840 --> 00:27:21,669
往返，这可能是 100

714
00:27:21,669 --> 00:27:25,299
毫秒，也许

715
00:27:25,299 --> 00:27:27,520


716
00:27:27,520 --> 00:27:30,370
更长 我

717
00:27:30,370 --> 00:27:31,750
不会在这段时间崩溃，我有一个

718
00:27:31,750 --> 00:27:33,880
复制磁铁机制，这是

719
00:27:33,880 --> 00:27:36,400
处理铁蛋白错误所必需的，

720
00:27:36,400 --> 00:27:38,500
如果我在崩溃后回来，他提到可以恢复自己

721
00:27:38,500 --> 00:27:56,110


722
00:27:56,110 --> 00:27:59,380
你已经告诉

723
00:27:59,380 --> 00:28:00,520
外部世界你已经告诉

724
00:28:00,520 --> 00:28:01,510
协调员你想要

725
00:28:01,510 --> 00:28:04,660
提交什么实际上是这个

726
00:28:04,660 --> 00:28:05,770
笔记实际上在做什么你能把

727
00:28:05,770 --> 00:28:19,150
所有的东西都保留在记忆问题中而

728
00:28:19,150 --> 00:28:21,669
不是我在这里含糊不清但就像在

729
00:28:21,669 --> 00:28:22,960
像 II 这样的原始两阶段提交协议

730
00:28:22,960 --> 00:28:25,510
记录了一个磁盘然后发送了我的响应，

731
00:28:25,510 --> 00:28:27,640
但没有人这样做，所以理论上

732
00:28:27,640 --> 00:28:29,160
你可以缓冲日志消息，

733
00:28:29,160 --> 00:28:31,600
如果它作为组提交的组部分被刷新

734
00:28:31,600 --> 00:28:34,179
谁在乎，但我

735
00:28:34,179 --> 00:28:36,580
知道如果我 崩溃回来，也许

736
00:28:36,580 --> 00:28:37,929
一些日志记录告诉

737
00:28:37,929 --> 00:28:40,450
我我是如何投票支持

738
00:28:40,450 --> 00:28:42,400
此事务的

739
00:28:42,400 --> 00:28:42,919
我会丢失我可以

740
00:28:42,919 --> 00:28:44,119
回来，协调员

741
00:28:44,119 --> 00:28:46,850
可以让我尽快让我加快速度

742
00:28:46,850 --> 00:28:48,259
让你知道 填写

743
00:28:48,259 --> 00:28:50,869
我丢失的缺失细节是的，你也可以

744
00:28:50,869 --> 00:28:52,399
这样做是的，我认为没有

745
00:28:52,399 --> 00:28:54,350
人会像刷新

746
00:28:54,350 --> 00:28:56,269
每个节点上的每条日志记录那样硬核

747
00:28:56,269 --> 00:28:58,190
每次没有人

748
00:28:58,190 --> 00:29:07,999
这样做，据我所知没有人这样做 所以

749
00:29:07,999 --> 00:29:09,169
只是重申我们今晚讨论的所有内容

750
00:29:09,169 --> 00:29:12,980
，正如我所说，节点

751
00:29:12,980 --> 00:29:16,100
可以记录发生的事情和每个阶段

752
00:29:16,100 --> 00:29:17,299
以及他们收到的

753
00:29:17,299 --> 00:29:19,239
消息他们发送给它的消息到日志中

754
00:29:19,239 --> 00:29:22,220
，这允许他们填写

755
00:29:22,220 --> 00:29:23,779
缺失的信息 崩溃后你回来时的详细信息，

756
00:29:23,779 --> 00:29:26,779
所以如果我们在

757
00:29:26,779 --> 00:29:28,609
运行我们的事务时

758
00:29:28,609 --> 00:29:31,190
协调器崩溃，然后我们告诉

759
00:29:31,190 --> 00:29:32,480
你在我们解决实际

760
00:29:32,480 --> 00:29:35,419
发生的事情之前你知道它是由参与者

761
00:29:35,419 --> 00:29:37,659
决定如何他们想要的 继续，

762
00:29:37,659 --> 00:29:39,799
所以最简单的事情是，

763
00:29:39,799 --> 00:29:41,509
如果协调器宕机，假设

764
00:29:41,509 --> 00:29:44,330
事务中止，我们只是你知道

765
00:29:44,330 --> 00:29:46,669
你回滚了任何更改，但你可以

766
00:29:46,669 --> 00:29:48,169
让参与者认识到我们的

767
00:29:48,169 --> 00:29:50,840
协调器宕机了，我们的事务

768
00:29:50,840 --> 00:29:53,539
仍然打开，所以有人可以成为

769
00:29:53,539 --> 00:29:55,279
新的 协调员，然后找出

770
00:29:55,279 --> 00:29:57,559
每个人如何投票，然后决定

771
00:29:57,559 --> 00:29:58,549
是否要提交该事务

772
00:29:58,549 --> 00:30:14,539
，是的，所以她的问题是，如果

773
00:30:14,539 --> 00:30:19,369
我们在这里说这个人

774
00:30:19,369 --> 00:30:21,529
发送到达第 2 号但

775
00:30:21,529 --> 00:30:22,669
在它可以之前的提交消息怎么办 将另一个发送到

776
00:30:22,669 --> 00:30:23,179
node3

777
00:30:23,179 --> 00:30:27,080
它会崩溃发生的事情所以

778
00:30:27,080 --> 00:30:30,889
再次第一个选项是我写如果我们可以

779
00:30:30,889 --> 00:30:32,869
识别协调器崩溃

780
00:30:32,869 --> 00:30:34,340
无论是心跳还是超时还是

781
00:30:34,340 --> 00:30:36,470
我们ju  st说这个我们有一个公开的交易

782
00:30:36,470 --> 00:30:38,899
我们要中止但是在这一点上

783
00:30:38,899 --> 00:30:41,619
我们已经告诉一旦我们验尸官说一个

784
00:30:41,619 --> 00:30:43,789
单条嘿这个交易被

785
00:30:43,789 --> 00:30:46,489
提交这是

786
00:30:46,489 --> 00:30:48,320
实际发生的事情的基本事实所以现在

787
00:30:48,320 --> 00:30:50,090
让我们为这个 节点然后

788
00:30:50,090 --> 00:30:51,529
与其他人一起吃饭或告诉其他人

789
00:30:51,529 --> 00:30:53,899
嘿这个交易我协调员

790
00:30:53,899 --> 00:30:55,070
说我提交了交易我们

791
00:30:55,070 --> 00:30:56,270
实际上应该再次提交这个

792
00:30:56,270 --> 00:30:58,760
正确的这就是我所说的

793
00:30:58,760 --> 00:31:01,610
就像我们一样如果我们的笔记

794
00:31:01,610 --> 00:31:03,650
是行不通的 恶意它只适用

795
00:31:03,650 --> 00:31:05,000
于你知道的每个人都在

796
00:31:05,000 --> 00:31:07,460
同一个团队中玩，所以我们听到我们

797
00:31:07,460 --> 00:31:10,160
听到这个人的一个提交信息，这应该

798
00:31:10,160 --> 00:31:12,020
足以验证其他所有人并

799
00:31:12,020 --> 00:31:18,350
告诉他们是的，我们应该提交这个好

800
00:31:18,350 --> 00:31:21,490
所以现在如果一个参与者 崩溃所以

801
00:31:21,490 --> 00:31:24,380
对于这个在两阶段提交下的我们

802
00:31:24,380 --> 00:31:26,360
只是假设参与者消失了

803
00:31:26,360 --> 00:31:29,240
，我们用一个中止替换他们丢失的响应

804
00:31:29,240 --> 00:31:31,190
，然后我们继续

805
00:31:31,190 --> 00:31:34,730
中止交易，这

806
00:31:34,730 --> 00:31:38,210
是最好的 这样做的关键是

807
00:31:38,210 --> 00:31:39,650
在这里指出正在发生的事情

808
00:31:39,650 --> 00:31:43,880
是节点有一个块，直到他们

809
00:31:43,880 --> 00:31:47,140
发现应该发生的事情

810
00:31:47,140 --> 00:31:49,700
并且等待你知道避免

811
00:31:49,700 --> 00:31:51,110
永远阻塞你只是有一种

812
00:31:51,110 --> 00:31:52,880
超时但是你设置了多长时间 您

813
00:31:52,880 --> 00:31:54,290
知道的可能因操作环境而异，

814
00:31:54,290 --> 00:31:56,720
您只是有一个超时，然后

815
00:31:56,720 --> 00:31:57,590
说好吧，我没有按时听到

816
00:31:57,590 --> 00:31:59,330
有关此人的任何消息，所以我们

817
00:31:59,330 --> 00:32:02,059
继续并中止此交易，这样

818
00:32:02,059 --> 00:32:04,190
您就可以有一个您知道的实时块

819
00:32:04,190 --> 00:32:05,540
问题 或者我们喜欢的问题只是没有

820
00:32:05,540 --> 00:32:06,920
取得任何进展，因为你的

821
00:32:06,920 --> 00:32:12,920
鼻子坐着等待所以

822
00:32:12,920 --> 00:32:15,320
替代两阶段提交

823
00:32:15,320 --> 00:32:17,470
选择 Dubey 方案它可能

824
00:32:17,470 --> 00:32:19,670
肯定

825
00:32:19,670 --> 00:32:21,679
是 1980 年代和 90 年代构建的任何分布式数据库都是有趣的

826
00:32:21,679 --> 00:32:25,160
两阶段 提交较新的可以使用

827
00:32:25,160 --> 00:32:27,290
变体进行两天提交，或者可以使用

828
00:32:27,290 --> 00:32:32,929
Paxos 筏子进行基础提交

829
00:32:32,929 --> 00:32:35,240
是一种 paxos 案例的子集或性别

830
00:32:35,240 --> 00:32:37,700
，希望当我们通过它时它是有意义的

831
00:32:37,700 --> 00:32:40,309
，所以使用 paxos i  t

832
00:32:40,309 --> 00:32:42,440
来自分布式计算世界，所以说

833
00:32:42,440 --> 00:32:43,429
我称其为原子提交

834
00:32:43,429 --> 00:32:44,690
协议，他们将称其为人口普查

835
00:32:44,690 --> 00:32:46,370
协议，但想法是相同的，您

836
00:32:46,370 --> 00:32:47,750
试图让一堆节点

837
00:32:47,750 --> 00:32:50,450
同意这是正确的行为 这

838
00:32:50,450 --> 00:32:51,980
是对我们状态机的正确更改，

839
00:32:51,980 --> 00:32:55,309
因此在 Patos 下会发生的事情是

840
00:32:55,309 --> 00:32:57,429
，您可以让协调器提议

841
00:32:57,429 --> 00:32:59,600
是否允许提交事务

842
00:32:59,600 --> 00:33:01,280
，然后一群参与者

843
00:33:01,280 --> 00:33:03,020
将投票是否会成功

844
00:33:03,020 --> 00:33:04,250
，是否允许该事务

845
00:33:04,250 --> 00:33:06,770
提交但在 paxos 下，我们

846
00:33:06,770 --> 00:33:08,570
只需要大多数节点

847
00:33:08,570 --> 00:33:10,040
同意承诺

848
00:33:10,040 --> 00:33:13,690
在两阶段提交中进行交易，我们现在需要所有节点，

849
00:33:13,690 --> 00:33:16,310
所以现在发生的情况是，

850
00:33:16,310 --> 00:33:18,050
只要您拥有大多数节点，但您没有

851
00:33:18,050 --> 00:33:19,850
绿色委员会的行动 '

852
00:33:19,850 --> 00:33:21,500
不必阻止整个系统或阻止

853
00:33:21,500 --> 00:33:23,930
整个协议，您仍然可以

854
00:33:23,930 --> 00:33:25,310
取得进展，再次两阶段

855
00:33:25,310 --> 00:33:29,450
提交，您将有一个

856
00:33:29,450 --> 00:33:31,250
参与者成为不可用的块

857
00:33:31,250 --> 00:33:33,920
整个故事所以paxos的故事

858
00:33:33,920 --> 00:33:37,490
很有趣所以

859
00:33:37,490 --> 00:33:39,230
paxos的第一个描述是在几年前

860
00:33:39,230 --> 00:33:40,730
获得图灵奖的Leslie Lamport撰写的论文中

861
00:33:40,730 --> 00:33:42,080


862
00:33:42,080 --> 00:33:45,080
称为兼职议会所以我认为这篇

863
00:33:45,080 --> 00:33:46,340
论文已经过时了

864
00:33:46,340 --> 00:33:49,160
它说 1998 年，但他实际上

865
00:33:49,160 --> 00:33:51,860
是在 1992 年发明的，而他试图

866
00:33:51,860 --> 00:33:54,620
做的是，他试图

867
00:33:54,620 --> 00:33:56,210
通过与一个例子的矛盾来

868
00:33:56,210 --> 00:33:58,850
证明你不可能有一个

869
00:33:58,850 --> 00:34:00,350
具有这种容错特性的共识协议，

870
00:34:00,350 --> 00:34:02,150
然后他们就结束了 在

871
00:34:02,150 --> 00:34:05,960
实际发明一个的过程中，所以如果你

872
00:34:05,960 --> 00:34:07,580
读过这篇论文，那是最疯狂的事情，

873
00:34:07,580 --> 00:34:10,070
因为它写得好像他

874
00:34:10,070 --> 00:34:11,870
像一个考古学家，他发现他

875
00:34:11,870 --> 00:34:13,880
去了这个希腊岛屿 Paxos，他

876
00:34:13,880 --> 00:34:16,550
发现了这块石碑，他得出

877
00:34:16,550 --> 00:34:18,590
了 实际上，算法来自

878
00:34:18,590 --> 00:34:20,360
这些古老的文明，就像它

879
00:34:20,360 --> 00:34:21,770
不是计算机科学论文一样，

880
00:34:21,770 --> 00:34:26,060
这就是这个说明性的故事，所以

881
00:34:26,060 --> 00:34:27,860
故事是他写了这篇论文

882
00:34:27,860 --> 00:34:30,290
92 就像这样

883
00:34:30,290 --> 00:34:30,739


884
00:34:30,739 --> 00:34:33,620
审稿人讨厌这个故事的希腊岛屿的东西想让他

885
00:34:33,620 --> 00:34:35,270
把你知道重写它，让他

886
00:34:35,270 --> 00:34:37,399
更多地了解计算机科学，他拒绝了

887
00:34:37,399 --> 00:34:39,409
，他没有做任何改变，所以他

888
00:34:39,409 --> 00:34:42,290
收回了论文，把它放在他的

889
00:34:42,290 --> 00:34:44,239
文件柜里，它没有 摸了大概

890
00:34:44,239 --> 00:34:45,860
六七年，直到人们

891
00:34:45,860 --> 00:34:47,690
开始发表看起来

892
00:34:47,690 --> 00:34:49,668
有点像 Paxos 的论文，然后他

893
00:34:49,668 --> 00:34:51,590
拔出说啊哈，你已经离我们很远了，

894
00:34:51,590 --> 00:34:53,239
或者已经很接近了，但我已经解决了

895
00:34:53,239 --> 00:34:55,760
这个问题，所以 这就是

896
00:34:55,760 --> 00:34:56,719
当你在

897
00:34:56,719 --> 00:34:58,970
Pleasant lamport 的网站上读到的故事，当我在读

898
00:34:58,970 --> 00:35:01,370
研究生时，我

899
00:35:01,370 --> 00:35:03,620
从 Maurice Herlihy 那里上了一堂课，然后

900
00:35:03,620 --> 00:35:06,110


901
00:35:06,110 --> 00:35:08,720
他在 CMU 担任教授，他

902
00:35:08,720 --> 00:35:09,890
说他是 实际上

903
00:35:09,890 --> 00:35:11,990
是这篇论文的审稿人之一，他说

904
00:35:11,990 --> 00:35:14,810
他们在 1992 年对

905
00:35:14,810 --> 00:35:16,610
所有希腊岛屿的故事都还好，他们只是

906
00:35:16,610 --> 00:35:18,440
想让他狂热地添加一个附录，其中

907
00:35:18,440 --> 00:35:20,630
仅包含一个算法来显示事情的

908
00:35:20,630 --> 00:35:22,190
实际情况，就像你知道的那样

909
00:35:22,190 --> 00:35:23,100
对它的简要描述

910
00:35:23,100 --> 00:35:25,320
，莱斯利·兰波特 (Leslie Lamport) 太固执了，

911
00:35:25,320 --> 00:35:26,220
他不认为这篇论文如此

912
00:35:26,220 --> 00:35:29,370
完美，他没有改变任何东西，

913
00:35:29,370 --> 00:35:30,600
但这是一篇有趣的论文，你

914
00:35:30,600 --> 00:35:32,670
绝对应该去读它，

915
00:35:32,670 --> 00:35:36,180
如果你读了，那可能是你读的理由

916
00:35:36,180 --> 00:35:37,770
这是为了娱乐，你不会

917
00:35:37,770 --> 00:35:39,300
从中学到任何东西，至少我没有，

918
00:35:39,300 --> 00:35:39,750
嗯

919
00:35:39,750 --> 00:35:41,820
，然后他有一篇名为

920
00:35:41,820 --> 00:35:43,170
Paks photos made simple

921
00:35:43,170 --> 00:35:46,440
的后续论文，这也无济于事

922
00:35:46,440 --> 00:35:48,660


923
00:35:48,660 --> 00:35:50,430
实际上忘记点击的那个现在

924
00:35:50,430 --> 00:35:51,510
我明白了协议实际上

925
00:35:51,510 --> 00:35:54,960
是什么所以让我们通过一个简短的例子

926
00:35:54,960 --> 00:35:56,850
所以为此我们现在要引入一个

927
00:35:56,850 --> 00:35:58,800
额外的节点，因为我们

928
00:35:58,800 --> 00:36:01,410
需要投票多数，然后

929
00:36:01,410 --> 00:36:02,640
区别是 现在，当我们

930
00:36:02,640 --> 00:36:04,260
在 paxos 的

931
00:36:04,260 --> 00:36:05,820
说法下而不是在我们的基础

932
00:36:05,820 --> 00:36:07,500
提交下获得承诺顶峰时，我们有一个协调员 Pat 这些

933
00:36:07,500 --> 00:36:08,460
电话作为提议者

934
00:36:08,460 --> 00:36:09,990
，然后一组参与者

935
00:36:09,990 --> 00:36:12,420
将其称为接受者，所以

936
00:36:12,420 --> 00:36:13,890
这个提议者我 我会说，嘿，我们

937
00:36:13,890 --> 00:36:15,660
要继续并提交这个事务

938
00:36:15,660 --> 00:36:19,080
是可以的，所以现在让

939
00:36:19,080 --> 00:36:20,850
我们在我们的例子中说，这里的中间节点

940
00:36:20,850 --> 00:36:25,350
崩溃了，所以现在

941
00:36:25,350 --> 00:36:26,910
前两个节点回来说是的，我们

942
00:36:26,910 --> 00:36:29,810
同意继续 并提交，所以

943
00:36:29,810 --> 00:36:32,640
在 Paxos 下，我们只需要多数，所以

944
00:36:32,640 --> 00:36:34,350
在这个例子中的三个节点中的两个

945
00:36:34,350 --> 00:36:36,810
同意提交这个事务，

946
00:36:36,810 --> 00:36:38,550
这样就足够我们

947
00:36:38,550 --> 00:36:40,650
继续并尝试在我们的两阶段提交中提交这个，

948
00:36:40,650 --> 00:36:43,800
如果这个人走了 我们

949
00:36:43,800 --> 00:36:46,890
必须放弃整个事情，所以现在我们

950
00:36:46,890 --> 00:36:49,170
得到大多数人的同意，我们继续

951
00:36:49,170 --> 00:36:50,490
并承诺，他们回来说

952
00:36:50,490 --> 00:36:52,080
是的，我们接受做出承诺，

953
00:36:52,080 --> 00:36:54,150
然后现在我们必须发回我们的

954
00:36:54,150 --> 00:36:57,000
成功信息，所以我们实际上是为了

955
00:36:57,000 --> 00:36:58,500
这个我们必须等到我们让 Beth

956
00:36:58,500 --> 00:37:00,630
回到第二阶段响应

957
00:37:00,630 --> 00:37:01,860
我们不能用

958
00:37:01,860 --> 00:37:03,990
两阶段提交的方式来缩短它因为我们实际上

959
00:37:03,990 --> 00:37:06,150
可能会回来并

960
00:37:06,150 --> 00:37:11,190
在第二阶段被拒绝所以让我们看看 一个

961
00:37:11,190 --> 00:37:12,270
不同的例子让我们

962
00:37:12,270 --> 00:37:15,720
从时间线的角度看这里，让我们说

963
00:37:15,720 --> 00:37:18,120
在同一时间

964
00:37:18,120 --> 00:37:19,620
，我们的分布式数据库中有两个不同的提议者

965
00:37:19,620 --> 00:37:22,440
，所以第一个人会

966
00:37:22,440 --> 00:37:23,370
说嘿，我想参加这个

967
00:37:23,370 --> 00:37:25,290
交易，然后想想

968
00:37:25,290 --> 00:37:26,370
他们是什么 真的在状态

969
00:37:26,370 --> 00:37:28,620
机中做他们只是附加一条日志

970
00:37:28,620 --> 00:37:30,630
消息并说这是我们

971
00:37:30,630 --> 00:37:32,120
对状态机所做的更改是数据库

972
00:37:32,120 --> 00:37:34,410
所以他们建议这个

973
00:37:34,410 --> 00:37:36,010
事务应该提交

974
00:37:36,010 --> 00:37:37,630
并且每个更改都应该

975
00:37:37,630 --> 00:37:39,550
应用于数据库所以我 我将状态

976
00:37:39,550 --> 00:37:42,970
向前推进，所以它说我想在

977
00:37:42,970 --> 00:37:46,270
时间戳 n 内提交更改，所以女孩们有

978
00:37:46,270 --> 00:37:48,430
很多接受者，然后他们

979
00:37:48,430 --> 00:37:50,500
回来说是的，我们同意继续

980
00:37:50,500 --> 00:37:53,170
并提交此更改，但现在还有

981
00:37:53,170 --> 00:37:54,550
其他提议提出说 我有

982
00:37:54,550 --> 00:37:56,290
其他交易进行了更改，

983
00:37:56,290 --> 00:37:59,560
它的时间戳是 M 加 1，所以这是一个

984
00:37:59,560 --> 00:38:02,260
合乎逻辑的时间戳，所以现在会

985
00:38:02,260 --> 00:38:04,030
发生的情况是，如果这个人回来

986
00:38:04,030 --> 00:38:05,890
说嘿，我想提交 n 因为你们

987
00:38:05,890 --> 00:38:07,030
都同意提交这个文件 继续

988
00:38:07,030 --> 00:38:09,580
并提交他们会拒绝它，

989
00:38:09,580 --> 00:38:13,600
因为他们偷了 n 加 1 所以

990
00:38:13,600 --> 00:38:14,680
即使他们不知道

991
00:38:14,680 --> 00:38:17,170
n 加 1 的结果将只是

992
00:38:17,170 --> 00:38:19,150
看到提交交易的新提案的事实

993
00:38:19,150 --> 00:38:21,130
或更改

994
00:38:21,130 --> 00:38:23,740
数据库的状态，要求

995
00:38:23,740 --> 00:38:26,980
他们全部中止拒绝他们

996
00:38:26,980 --> 00:38:30,790
之前都同意的那个，所以现在我们

997
00:38:30,790 --> 00:38:32,590
发送协议以提交并加一，

998
00:38:32,590 --> 00:38:34,690
然后他说我很好，

999
00:38:34,690 --> 00:38:36,640
让我们去提交 n 加一 然后一旦

1000
00:38:36,640 --> 00:38:40,150
我们都接受了这一点 那么

1001
00:38:40,150 --> 00:38:41,110
此时交易实际上已经

1002
00:38:41,110 --> 00:38:52,990
提交 是的 我们的问题是 是 所以

1003
00:38:52,990 --> 00:38:55,540
这是你的问题调查 这是

1004
00:38:55,540 --> 00:38:57,640
什么 n 所以如果我带着 n

1005
00:38:57,640 --> 00:38:59,290
减 1 会立即

1006
00:38:59,290 --> 00:39:00,280
被拒绝 是的

1007
00:39:00,280 --> 00:39:02,890
现在如何 你实际上在逻辑上有一个

1008
00:39:02,890 --> 00:39:09,430
全球有效的时间戳或计数器

1009
00:39:09,430 --> 00:39:11,590
，每个人都同意去你知道

1010
00:39:11,590 --> 00:39:13,240
按正确的顺序上升，这样我就

1011
00:39:13,240 --> 00:39:15,310
可以一次移动四次最简单的

1012
00:39:15,310 --> 00:39:16,810
方法是你假设你的时钟

1013
00:39:16,810 --> 00:39:21,190
是合理的 bly 同步，你可以

1014
00:39:21,190 --> 00:39:23,290
吗，你可以在它上面附加一个逻辑计数器，

1015
00:39:23,290 --> 00:39:25,300
或者在主机名前面加上前缀，这样你

1016
00:39:25,300 --> 00:39:27,760
就可以打破联系，有标准的

1017
00:39:27,760 --> 00:39:33,060
技巧来处理这个

1018
00:39:34,430 --> 00:39:36,570
问题是的，所以她的问题是这能

1019
00:39:36,570 --> 00:39:38,160
永远持续下去，我的意思是理论不能

1020
00:39:38,160 --> 00:39:40,470
对提议者来说，只是

1021
00:39:40,470 --> 00:39:43,710
来回互相破坏是的，我们会

1022
00:39:43,710 --> 00:39:54,570
处理下一张幻灯片是的，所以你的

1023
00:39:54,570 --> 00:39:55,950
问题是，如果有人

1024
00:39:55,950 --> 00:39:57,360
说它有大多数

1025
00:39:57,360 --> 00:40:09,540
接受者，或者是的，那这将

1026
00:40:09,540 --> 00:40:12,000
如何运作是的，如果有一个人 如果这些

1027
00:40:12,000 --> 00:40:14,430
接受者中的一个看到 n 加 1，他们必须

1028
00:40:14,430 --> 00:40:21,000
拒绝 n 是的，我认为他们

1029
00:40:21,000 --> 00:40:22,350
在分布式系统类中涵盖了我们，

1030
00:40:22,350 --> 00:40:23,430
X 中的人您必须

1031
00:40:23,430 --> 00:40:25,710
实现它，所以我正在我

1032
00:40:25,710 --> 00:40:27,090
将非常简短地介绍一下 只是为了显示

1033
00:40:27,090 --> 00:40:29,190
两阶段提交

1034
00:40:29,190 --> 00:40:33,870
和和 Pat 之间的区别，就像是的一样，

1035
00:40:33,870 --> 00:40:35,700
hilum 的想法是一样的，除了在

1036
00:40:35,700 --> 00:40:38,190
Pat 说是的，你仍然

1037
00:40:38,190 --> 00:40:39,840
在第二阶段被拒绝，你

1038
00:40:39,840 --> 00:40:44,190
必须同意大多数人的意见，所以现在她的问题是 或者

1039
00:40:44,190 --> 00:40:46,560
她的观察是，

1040
00:40:46,560 --> 00:40:48,240
如果我只有两个

1041
00:40:48,240 --> 00:40:50,040
提议者通过

1042
00:40:50,040 --> 00:40:52,110
摆出你知道的 n 加 1 和加 2 n

1043
00:40:52,110 --> 00:40:53,730
加 3 的姿势互相殴打，一切都只会

1044
00:40:53,730 --> 00:40:56,130
被绝对拒绝，所以你

1045
00:40:56,130 --> 00:40:58,950
处理这个问题的方式被称为多 Paxos 所以

1046
00:40:58,950 --> 00:41:01,320
multipacks 的想法是你

1047
00:41:01,320 --> 00:41:03,530
选择某个节点

1048
00:41:03,530 --> 00:41:07,260
成为你的 Paxos 组的领导者，然后它是

1049
00:41:07,260 --> 00:41:10,320
负责提出

1050
00:41:10,320 --> 00:41:13,020
更改以提交事务的

1051
00:41:13,020 --> 00:41:14,430
唯一节点，这是他们认为可以

1052
00:41:14,430 --> 00:41:15,990
委托或指定的节点

1053
00:41:15,990 --> 00:41:18,510
就像协调器或

1054
00:41:18,510 --> 00:41:20,280
中间件一样，

1055
00:41:20,280 --> 00:41:21,510
每个人都必须去决定

1056
00:41:21,510 --> 00:41:23,510
是否允许他们提交，

1057
00:41:23,510 --> 00:41:27,510
并且你有被指定

1058
00:41:27,510 --> 00:41:29,370
为领导者的租约，就像你知道大约 60

1059
00:41:29,370 --> 00:41:31,560
秒左右，然后 60 秒过后，

1060
00:41:31,560 --> 00:41:34,020
你进行一轮投票

1061
00:41:34,020 --> 00:41:36,480
，这是另一轮 Paxos

1062
00:41:36,480 --> 00:41:38,610
以确定下一个领导者是谁

1063
00:41:38,610 --> 00:41:43,110
，然后一旦

1064
00:41:43,110 --> 00:41:44,850
解决了，你就继续 并且您是否

1065
00:41:44,850 --> 00:41:46,560
知道新指定的领导者

1066
00:41:46,560 --> 00:41:48,180


1067
00:41:48,180 --> 00:41:50,170
负责应用所有更改，因此本

1068
00:41:50,170 --> 00:41:52,000
报告避免了

1069
00:41:52,000 --> 00:41:54,280
饥饿问题，因为领导者

1070
00:41:54,280 --> 00:42:00,810
是唯一提出更改的人是

1071
00:42:04,770 --> 00:42:06,820
正确的，所以她就像不只是

1072
00:42:06,820 --> 00:42:07,870
移动 问题，因为现在无法

1073
00:42:07,870 --> 00:42:10,140
开始领导选举，所以

1074
00:42:10,140 --> 00:42:13,030
是的，我们假设我们的节点是友好的，所以

1075
00:42:13,030 --> 00:42:14,230
我们在我们的和我们的

1076
00:42:14,230 --> 00:42:15,510
数据库系统中有权利，你说

1077
00:42:15,510 --> 00:42:18,940
好吧，在我的租约结束后，我会努力

1078
00:42:18,940 --> 00:42:22,660
成为 只有一个对你知道投票

1079
00:42:22,660 --> 00:42:24,520
或提议我可以成为新的

1080
00:42:24,520 --> 00:42:26,530
领导者你如何处理两个人

1081
00:42:26,530 --> 00:42:28,480
同时鼓掌是的但你

1082
00:42:28,480 --> 00:42:31,540
退后所以我尝试我被拒绝所以

1083
00:42:31,540 --> 00:42:33,400
麻省理工学院对我说Miele试图拒绝或

1084
00:42:33,400 --> 00:42:34,450
只是尝试 提出新的建议

1085
00:42:34,450 --> 00:42:37,120
如果我

1086
00:42:37,120 --> 00:42:38,350
再次提出建议，我可能会等 10 毫秒 我被拒绝也许我会

1087
00:42:38,350 --> 00:42:44,590
等 20 就这样做 是的

1088
00:42:44,590 --> 00:42:45,760
问题是您可以拥有多少建议

1089
00:42:45,760 --> 00:42:48,570
然后根据您的需要

1090
00:42:48,570 --> 00:42:50,410


1091
00:42:50,410 --> 00:42:52,360
关于实践中的限制，就像

1092
00:42:52,360 --> 00:42:53,830
得到它一样，他们会成群结队地打电话，所以如果我们在助理百花香的学期末覆盖扳手，那么

1093
00:42:53,830 --> 00:42:57,100
这个群体通常会有

1094
00:42:57,100 --> 00:42:59,260
一个多税，以避免这个开始

1095
00:42:59,260 --> 00:43:02,260
饥饿问题

1096
00:43:02,260 --> 00:43:04,150


1097
00:43:04,150 --> 00:43:05,910
，每个 一年我们总是这样做

1098
00:43:05,910 --> 00:43:08,440
我将向您展示如何

1099
00:43:08,440 --> 00:43:18,370
在这里解决这个问题，因此主要的

1100
00:43:18,370 --> 00:43:20,080
收获是，使用

1101
00:43:20,080 --> 00:43:21,910
两阶段提交和paxos，您都可以

1102
00:43:21,910 --> 00:43:23,800
使用它们来提交事务，以便

1103
00:43:23,800 --> 00:43:25,510
确定每个人是否 同意我们

1104
00:43:25,510 --> 00:43:26,790
希望继续并

1105
00:43:26,790 --> 00:43:31,600
在实践中提交事务，通常

1106
00:43:31,600 --> 00:43:34,240
用于彼此本地的分布式数据库，

1107
00:43:34,240 --> 00:43:35,320
就像这意味着它们在

1108
00:43:35,320 --> 00:43:36,490
同一个数据中心下运行，在那里它们不像

1109
00:43:36,490 --> 00:43:38,230
你知道的那样或广泛的地理

1110
00:43:38,230 --> 00:43:40,240
区域两阶段提交就是这样

1111
00:43:40,240 --> 00:43:42,430
人们主要使用，因为

1112
00:43:42,430 --> 00:43:46,450
往返次数可能会更少，并且您

1113
00:43:46,450 --> 00:43:47,530
假设节点可能

1114
00:43:47,530 --> 00:43:49,630
不会经常崩溃，

1115
00:43:49,630 --> 00:43:52,210
好吧，还有很多额外的故障场景

1116
00:43:52,210 --> 00:43:53,890
Cody 你必须处理 ferret 句柄

1117
00:43:53,890 --> 00:43:55,990
代码来处理，就像你知道

1118
00:43:55,990 --> 00:43:57,070
协调器宕机 参与者

1119
00:43:57,070 --> 00:43:59,380
宕机 所以你知道即使它

1120
00:43:59,380 --> 00:44:01,230
比 paxos 稍微快一点，

1121
00:44:01,230 --> 00:44:02,370
但你仍然需要做很多

1122
00:44:02,370 --> 00:44:03,450
事情来确保

1123
00:44:03,450 --> 00:44:05,130
整个系统不会宕机

1124
00:44:05,130 --> 00:44:06,530
，也不会丢失数据，

1125
00:44:06,530 --> 00:44:09,390
正如我在 Paxos 的发明者

1126
00:44:09,390 --> 00:44:11,730
Leslie Lamport 和 Jim Gray 之前所说的那样，

1127
00:44:11,730 --> 00:44:13,320
指南是两相锁定的，他们

1128
00:44:13,320 --> 00:44:16,110
在 2000 年代初在 Jim 之前发表了一篇论文

1129
00:44:16,110 --> 00:44:21,510
消失了，这表明两个基本

1130
00:44:21,510 --> 00:44:23,190
提交是两个

1131
00:44:23,190 --> 00:44:25,620
阶段锁定权的退化案例 - 有点像我在

1132
00:44:25,620 --> 00:44:27,930
和 Jennifer 的 paksas 案例交谈一样

1133
00:44:27,930 --> 00:44:30,840
，协调员这是同

1134
00:44:30,840 --> 00:44:34,140
一轮投票的税收，只是每个人都

1135
00:44:34,140 --> 00:44:40,050
同意而不是大多数人同意

1136
00:44:40,050 --> 00:44:40,380
好吧，

1137
00:44:40,380 --> 00:44:42,180
现在让我们来谈谈复制，正如我

1138
00:44:42,180 --> 00:44:44,970
在开始时所说的，大多数人不需要

1139
00:44:44,970 --> 00:44:47,730
某种分区属性

1140
00:44:47,730 --> 00:44:51,090
数据库来处理大多数

1141
00:44:51,090 --> 00:44:52,410
数据说你玩和计算现实

1142
00:44:52,410 --> 00:44:54,720
世界的工作负载 我可能使用你知道

1143
00:44:54,720 --> 00:44:55,980
某种复制，我会说它

1144
00:44:55,980 --> 00:44:57,680
仍然算作一个分布式数据库

1145
00:44:57,680 --> 00:45:00,080
所以这里的想法应该是一个

1146
00:45:00,080 --> 00:45:03,270
与应用程序一起复制的数据库是我们

1147
00:45:03,270 --> 00:45:05,580
想要制作每个对象的多个副本，

1148
00:45:05,580 --> 00:45:07,770
无论它是一个页面还是一个 - 糟糕的

1149
00:45:07,770 --> 00:45:10,080
表，无论你想要什么，并将它们存储

1150
00:45:10,080 --> 00:45:12,000
在多个节点上，这样如果其中

1151
00:45:12,000 --> 00:45:14,220
一个节点出现故障，我们就有一个

1152
00:45:14,220 --> 00:45:16,500
可用的备份，这样我们就不必

1153
00:45:16,500 --> 00:45:18,180
等待系统重新启动并

1154
00:45:18,180 --> 00:45:19,290
重播日志来让我们回到 正确的

1155
00:45:19,290 --> 00:45:21,960
状态，我们可以使用 paxos 进行故障转移

1156
00:45:21,960 --> 00:45:24,840
来决定故障转移到谁来

1157
00:45:24,840 --> 00:45:26,490
确定您知道

1158
00:45:26,490 --> 00:45:29,820
写入数据的新位置，因此

1159
00:45:29,820 --> 00:45:30,990


1160
00:45:30,990 --> 00:45:32,700
当我们想要构建复制方案时，我们必须考虑一系列设计决策，

1161
00:45:32,700 --> 00:45:34,680
所以我们

1162
00:45:34,680 --> 00:45:36,410
将逐个逐一介绍，

1163
00:45:36,410 --> 00:45:40,350
所以第一个问题是

1164
00:45:40,350 --> 00:45:42,590
在您可以配置系统之后

1165
00:45:42,590 --> 00:45:44,550
配置系统中的副本

1166
00:45:44,550 --> 00:45:46,550
以及读取和写入的位置，

1167
00:45:46,550 --> 00:45:49,710
因此最常见的方法 使用的

1168
00:45:49,710 --> 00:45:51,900
是所谓的主副本复制

1169
00:45:51,900 --> 00:45:54,020
有时称为领导跟随者

1170
00:45:54,020 --> 00:45:56,280
曾经被称为主从但

1171
00:45:56,280 --> 00:45:58,290
人们试图避免使用该术语，

1172
00:45:58,290 --> 00:46:00,090
这里的想法是

1173
00:46:00,090 --> 00:46:04,140


1174
00:46:04,140 --> 00:46:06,630
对于数据库中的给定对象，该表单有一些指定的主

1175
00:46:06,630 --> 00:46:08,130
权限将转到该主

1176
00:46:08,130 --> 00:46:11,040
主节点，然后主节点

1177
00:46:11,040 --> 00:46:13,380
负责将这些

1178
00:46:13,380 --> 00:46:14,950
更改

1179
00:46:14,950 --> 00:46:19,510
传播到其副本，所有

1180
00:46:19,510 --> 00:46:21,640
读取都可以转到主节点或

1181
00:46:21,640 --> 00:46:22,869
某些也可以转到

1182
00:46:22,869 --> 00:46:24,609
副本的系统，因此您可以 卸载你

1183
00:46:24,609 --> 00:46:25,660
在大屠杀中必须做的工作，权利

1184
00:46:25,660 --> 00:46:28,510
可能会非常昂贵，所以

1185
00:46:28,510 --> 00:46:30,460
正如我所说，如果现在主节点宕机，

1186
00:46:30,460 --> 00:46:32,619
那么我们会举起轴来进行

1187
00:46:32,619 --> 00:46:34,270
领导选举，以确定哪个

1188
00:46:34,270 --> 00:46:35,740
副本成为新的主节点，

1189
00:46:35,740 --> 00:46:36,670
那就是 所有权利都去

1190
00:46:36,670 --> 00:46:42,160
质疑这个问题很好 这是一个

1191
00:46:42,160 --> 00:46:45,570
风险持久性不我们会到达那里

1192
00:46:45,570 --> 00:46:51,099
但不一定不不不不正确

1193
00:46:51,099 --> 00:46:53,880


1194
00:46:53,880 --> 00:46:56,530
再放几张幻灯片 好的另一种方法 是做

1195
00:46:56,530 --> 00:47:00,040
多主，其中我们将副本

1196
00:47:00,040 --> 00:47:01,030
存储在不同的机器中，

1197
00:47:01,030 --> 00:47:03,250
并且允许事务写入

1198
00:47:03,250 --> 00:47:05,920
任何这些副本，

1199
00:47:05,920 --> 00:47:08,200
有时称为多主，然后现在

1200
00:47:08,200 --> 00:47:10,630
是副本

1201
00:47:10,630 --> 00:47:13,240
负责确定您是否有两个

1202
00:47:13,240 --> 00:47:14,770
尝试尝试的事务 要更新

1203
00:47:14,770 --> 00:47:16,480
运行两个不同副本的同一事物，

1204
00:47:16,480 --> 00:47:18,010
您实际上如何协调，

1205
00:47:18,010 --> 00:47:19,390
决定哪个应该实际提交

1206
00:47:19,390 --> 00:47:20,619
哪个应该中止您

1207
00:47:20,619 --> 00:47:24,010
实际上如何处理冲突，所以让我们

1208
00:47:24,010 --> 00:47:25,510
再次看看这些视觉上的轻松主主

1209
00:47:25,510 --> 00:47:28,119
副本是的，您有一个主节点

1210
00:47:28,119 --> 00:47:31,300
你的权利属于这个人，在

1211
00:47:31,300 --> 00:47:32,980
某些系统中，所有的读取也都在

1212
00:47:32,980 --> 00:47:35,349
这里，然后这才

1213
00:47:35,349 --> 00:47:36,849
通过网络

1214
00:47:36,849 --> 00:47:39,849
将更新信息传播到它的

1215
00:47:39,849 --> 00:47:43,089
副本，以便可以应用，对于

1216
00:47:43,089 --> 00:47:44,650
某些系统，你可以再次

1217
00:47:44,650 --> 00:47:47,170
读取 转到副本，以便您

1218
00:47:47,170 --> 00:47:48,460
产生在前端所做的工作量，

1219
00:47:48,460 --> 00:47:51,310
因此如果您的读取

1220
00:47:51,310 --> 00:47:53,290
不需要最新的后期 如果

1221
00:47:53,290 --> 00:47:56,109
我有快照隔离，那么你可以将它们

1222
00:47:56,109 --> 00:47:58,450
全部流向这些其他人，

1223
00:47:58,450 --> 00:48:01,119
这仍然可能是一致

1224
00:48:01,119 --> 00:48:03,520
的，这意味着如果我有快照

1225
00:48:03,520 --> 00:48:04,990
隔离，我可以保证我

1226
00:48:04,990 --> 00:48:07,030


1227
00:48:07,030 --> 00:48:08,560
仍然没有看到来自事务的撕裂更新或部分更新

1228
00:48:08,560 --> 00:48:10,030
在这里运行这个人，所以我仍然可以

1229
00:48:10,030 --> 00:48:11,800
保证一致性是

1230
00:48:11,800 --> 00:48:15,190
我在我的副本上读取的数据，只是

1231
00:48:15,190 --> 00:48:16,359
可能是我没有看到

1232
00:48:16,359 --> 00:48:18,280


1233
00:48:18,280 --> 00:48:22,660
主服务器上的最新信息，多主服务器方法

1234
00:48:22,660 --> 00:48:24,160
是我们 有交易，你可以读取

1235
00:48:24,160 --> 00:48:26,380
数据的任何副本的权利，

1236
00:48:26,380 --> 00:48:28,690
然后有一些程序

1237
00:48:28,690 --> 00:48:30,339
可以使用

1238
00:48:30,339 --> 00:48:32,010
Paxos 或两阶段委员会再次解决冲突，以确定

1239
00:48:32,010 --> 00:48:34,869
你知道这两个副本上有重叠的更改

1240
00:48:34,869 --> 00:48:36,339
什么应该是

1241
00:48:36,339 --> 00:48:40,690
最新版本，所以只是 作为一个简短的

1242
00:48:40,690 --> 00:48:43,060
轶事 Facebook 最初曾经使用

1243
00:48:43,060 --> 00:48:44,579
这个马耳他

1244
00:48:44,579 --> 00:48:46,720
主副本设置来建立他们的巨型

1245
00:48:46,720 --> 00:48:48,700
数据中心，主要数据

1246
00:48:48,700 --> 00:48:49,690
中心是我想你知道在

1247
00:48:49,690 --> 00:48:52,480
加利福尼亚然后交流

1248
00:48:52,480 --> 00:48:54,099
与世界各地的不同，他们将拥有

1249
00:48:54,099 --> 00:48:57,550
副本，这些副本将落在

1250
00:48:57,550 --> 00:48:59,859
您所知道的主节点上，并获取

1251
00:48:59,859 --> 00:49:01,329
更新以传播

1252
00:49:01,329 --> 00:49:02,530
更改，以便您可以看到事物

1253
00:49:02,530 --> 00:49:04,210
以及他们伪造它以

1254
00:49:04,210 --> 00:49:05,530
使其看起来的方式 就像您的更改在本地发生得非常

1255
00:49:05,530 --> 00:49:07,810
快一样，如果您更新了

1256
00:49:07,810 --> 00:49:11,079
时间线，他们会将其作为

1257
00:49:11,079 --> 00:49:12,760
cookie 信息存储在您的浏览器中，

1258
00:49:12,760 --> 00:49:13,960
这样如果您刷新页面，您就会

1259
00:49:13,960 --> 00:49:15,970
看到您的更新，即使可能

1260
00:49:15,970 --> 00:49:18,460
尚未传播到

1261
00:49:18,460 --> 00:49:19,660
您所在的副本 正在从正确的角度阅读您的时间表，

1262
00:49:19,660 --> 00:49:21,460


1263
00:49:21,460 --> 00:49:23,170
因为权利出现在这里需要一些时间，然后

1264
00:49:23,170 --> 00:49:25,540
被推到复制品，现在

1265
00:49:25,540 --> 00:49:27,700
可能是五年前，现在他们在五年前进行

1266
00:49:27,700 --> 00:49:32,859
了多主设置，所以这是一个

1267
00:49:32,859 --> 00:49:35,950
重要的概念 在我们的复制品中，

1268
00:49:35,950 --> 00:49:44,560
是的，你可以做出反应，

1269
00:49:44,560 --> 00:49:46,060
所以四年前有很多南瓜许可地图

1270
00:49:46,060 --> 00:49:47,680
，就像我

1271
00:49:47,680 --> 00:49:49,660
在我的时间线中写一篇你知道的帖子一样，

1272
00:49:49,660 --> 00:49:52,329
如果我刷新页面，如果

1273
00:49:52,329 --> 00:49:54,579
我在说 g 我在巴西，正在

1274
00:49:54,579 --> 00:49:56,980
阅读巴西，我的本地数据中心有

1275
00:49:56,980 --> 00:49:58,839
主服务器的副本，所以现在如果

1276
00:49:58,839 --> 00:50:00,730
我刷新页面并返回，我将

1277
00:50:00,730 --> 00:50:02,740
看不到我的帖子，因为它

1278
00:50:02,740 --> 00:50:03,880
已从主服务器传播到主服务器

1279
00:50:03,880 --> 00:50:05,530
复制品，因为总是有

1280
00:50:05,530 --> 00:50:07,750
延迟，所以人们会那么你

1281
00:50:07,750 --> 00:50:09,250
他们想要避免有人

1282
00:50:09,250 --> 00:50:11,230
在他们的时间线中发帖点击

1283
00:50:11,230 --> 00:50:12,940
刷新然后认为他们是他们的

1284
00:50:12,940 --> 00:50:14,260
帖子丢失了，因为现在你正在

1285
00:50:14,260 --> 00:50:16,690
阅读这篇文章所以他们的方式

1286
00:50:16,690 --> 00:50:17,680
会处理的是，他们实际上会将

1287
00:50:17,680 --> 00:50:20,050
她写的内容存储在您的浏览器

1288
00:50:20,050 --> 00:50:22,510
cookie 中，然后将其填充，就好像

1289
00:50:22,510 --> 00:50:28,530
它来自数据库一样，

1290
00:50:32,970 --> 00:50:36,609
如果他们退出浏览器并

1291
00:50:36,609 --> 00:50:38,079
假设 cookie 被吹走

1292
00:50:38,079 --> 00:50:41,990
，您就可以切掉，但

1293
00:50:41,990 --> 00:50:44,599
效果更好 场景我

1294
00:50:44,599 --> 00:50:46,220
在这台机器上更改

1295
00:50:46,220 --> 00:50:47,599
了我的时间，我旁边有另一台机器，我

1296
00:50:47,599 --> 00:50:49,220
在那台机器上刷新它会转到

1297
00:50:49,220 --> 00:50:50,900
巴西的副本数据库它

1298
00:50:50,900 --> 00:50:53,630
不会看到你的帖子你知道它会是

1299
00:50:53,630 --> 00:50:55,069
一对 百 在它们实际传播之前的 ed 毫秒，

1300
00:50:55,069 --> 00:50:57,770
但他们

1301
00:50:57,770 --> 00:50:58,730
会说你知道我们仍然喜欢

1302
00:50:58,730 --> 00:50:59,930
伤害某人可能会在

1303
00:50:59,930 --> 00:51:05,290
两台机器上刷新它们完全相同的时间是的

1304
00:51:12,130 --> 00:51:13,280
正确

1305
00:51:13,280 --> 00:51:15,470
问题是，在我的 Facebook 场景中，

1306
00:51:15,470 --> 00:51:17,960
如果复制品巴西这个

1307
00:51:17,960 --> 00:51:19,579
当我实际发帖时在加利福尼亚州

1308
00:51:19,579 --> 00:51:21,380
是否意味着应用程序

1309
00:51:21,380 --> 00:51:22,970
服务器需要与

1310
00:51:22,970 --> 00:51:24,530
数据进行通信从巴西返回加利福尼亚州

1311
00:51:24,530 --> 00:51:28,970
是的大卫，这绝对是一个巨大的瓶子

1312
00:51:28,970 --> 00:51:29,990
，这就是为什么他们做了

1313
00:51:29,990 --> 00:51:33,260
cookie的事情来隐藏它，因为这样

1314
00:51:33,260 --> 00:51:37,880
做 这很难吗？他们必须

1315
00:51:37,880 --> 00:51:40,130
建立那个，并且要做到这一点并不

1316
00:51:40,130 --> 00:51:46,220
容易，是的，如果有人对该帖子发表评论，他的问题将再次收到

1317
00:51:46,220 --> 00:51:48,290
使用 Facebook 的例子

1318
00:51:48,290 --> 00:51:49,640
，我永远不会看到

1319
00:51:49,640 --> 00:51:52,130
那不，因为这只是

1320
00:51:52,130 --> 00:51:54,290
在 写帖子的人，

1321
00:51:54,290 --> 00:51:58,220
如果你点击刷新，它会从 cookie 中提取它，

1322
00:51:58,220 --> 00:51:59,720
这样你会认为

1323
00:51:59,720 --> 00:52:01,069
你是从我那里从主人

1324
00:52:01,069 --> 00:52:02,569
那里得到的，但实际上你是从它填充的副本中得到的

1325
00:52:02,569 --> 00:52:03,920
知道它

1326
00:52:03,920 --> 00:52:07,099
应该为你存在的缺失信息最终它这个

1327
00:52:07,099 --> 00:52:08,660
混蛋会被传播到

1328
00:52:08,660 --> 00:52:11,299
副本，然后现在如果我刷新

1329
00:52:11,299 --> 00:52:12,619
而不是访问cookie，我

1330
00:52:12,619 --> 00:52:14,839
将来自我的副本所以Zimmer并发表

1331
00:52:14,839 --> 00:52:17,240
我的评论我它

1332
00:52:17,240 --> 00:52:23,119
在

1333
00:52:23,119 --> 00:52:24,530
旧系统中的旧系统中看到它正确之前会有延迟是的，新系统

1334
00:52:24,530 --> 00:52:27,859
是的，现在一切都是我们正在获得

1335
00:52:27,859 --> 00:52:29,690
GPD 我们的世界，我不想进入我不想

1336
00:52:29,690 --> 00:52:32,440
进入的世界就像数据实际存在的地方

1337
00:52:32,440 --> 00:52:35,480
但一般认为是的，就像

1338
00:52:35,480 --> 00:52:38,559
认为这就像巴西美国我们

1339
00:52:38,559 --> 00:52:40,490
每个人在整个数据库中都有一个完整的副本

1340
00:52:40,490 --> 00:52:43,010
Facebook 是否真的

1341
00:52:43,010 --> 00:52:44,470
再这样做了 我不知道

1342
00:52:44,470 --> 00:52:47,450
再这么想了，因为这是

1343
00:52:47,450 --> 00:52:49,940
一个很好的例子，它有点像 mp3

1344
00:52:49,940 --> 00:52:52,700
正确的 mp3 利用了 AUSA 的

1345
00:52:52,700 --> 00:52:55,400
人类我们可以继续进行的

1346
00:52:55,400 --> 00:52:58,400
工作 音频，他们可以压缩

1347
00:52:58,400 --> 00:52:59,930
你知道的波长，我们看不到

1348
00:52:59,930 --> 00:53:01,849
，扔掉我们人类

1349
00:53:01,849 --> 00:53:03,049
永远听不到的数据

1350
00:53:03,049 --> 00:53:04,760
压缩你知道的实际

1351
00:53:04,760 --> 00:53:06,650
文件，所以它有点像同样的事情

1352
00:53:06,650 --> 00:53:09,380
是的，他们知道如果我花了

1353
00:53:09,380 --> 00:53:11,210
一百毫秒才能

1354
00:53:11,210 --> 00:53:14,180
从对我帖子的评论中起床，请从主人那里得到

1355
00:53:14,180 --> 00:53:16,520
复制品，他们在乎

1356
00:53:16,520 --> 00:53:17,900
我是否需要一百毫秒才能

1357
00:53:17,900 --> 00:53:19,339
看到您对我的愚蠢

1358
00:53:19,339 --> 00:53:22,250
图片的评论。 试图

1359
00:53:22,250 --> 00:53:23,720
避免有人发布然后

1360
00:53:23,720 --> 00:53:26,690
立即没有看到他们发布的内容所以

1361
00:53:26,690 --> 00:53:27,680
这就是为什么他们正在做那个cookie

1362
00:53:27,680 --> 00:53:29,869
技巧但是对于其他所有事情你

1363
00:53:29,869 --> 00:53:30,980
必须等到被传播

1364
00:53:30,980 --> 00:53:32,450
，如果它是一个猎人毫秒 s

1365
00:53:32,450 --> 00:53:33,829
看到您的朋友的

1366
00:53:33,829 --> 00:53:52,700
评论，他关心评论用例中的评论

1367
00:53:52,700 --> 00:53:54,170
，加利福尼亚州的某人评论，例如

1368
00:53:54,170 --> 00:54:00,049
我是否发布了 Raziel 或其他内容

1369
00:54:00,049 --> 00:54:02,990


1370
00:54:02,990 --> 00:54:05,059


1371
00:54:05,059 --> 00:54:06,380
我假设每个人都有一个完整的

1372
00:54:06,380 --> 00:54:07,490
副本，但现在你可以

1373
00:54:07,490 --> 00:54:11,150
想到在一个非常大的琐事

1374
00:54:11,150 --> 00:54:14,150
数据库中有很多数据我

1375
00:54:14,150 --> 00:54:15,890
可能想要

1376
00:54:15,890 --> 00:54:18,640
多次复制 p1 所以有 p1 的多个副本

1377
00:54:18,640 --> 00:54:22,069
等等 也许如果我

1378
00:54:22,069 --> 00:54:23,839
在巴西的所有数据都丢失了，那么我会在巴西保留

1379
00:54:23,839 --> 00:54:25,609
更多我的数据的副本，

1380
00:54:25,609 --> 00:54:27,049
因为

1381
00:54:27,049 --> 00:54:28,549
如果有人发表我的评论，我可以更快地更新它们

1382
00:54:28,549 --> 00:54:30,349
现在巴西如果有人在加利福尼亚更新了某些

1383
00:54:30,349 --> 00:54:31,789
内容 然后必须

1384
00:54:31,789 --> 00:54:34,010
传播到巴西，以便当我

1385
00:54:34,010 --> 00:54:36,740
刷新时我可以看到它是的他们处理所有

1386
00:54:36,740 --> 00:54:40,640
这些是的 Facebook 架构

1387
00:54:40,640 --> 00:54:42,859
实际上意味着这一切都基于我最后的

1388
00:54:42,859 --> 00:54:45,559
续集，就像

1389
00:54:45,559 --> 00:54:48,079
他们巨型分布式的核心存储引擎

1390
00:54:48,079 --> 00:54:49,940
数据库系统是我的

1391
00:54:49,940 --> 00:54:52,400
续集，他们正在摆脱内部数据库

1392
00:54:52,400 --> 00:54:54,670
并最终替换为岩石数据库，

1393
00:54:54,670 --> 00:54:57,650
但上面的所有层都

1394
00:54:57,650 --> 00:54:58,549
与实际的

1395
00:54:58,549 --> 00:54:59,990
底层存储无关，但天蓝色的

1396
00:54:59,990 --> 00:55:01,039
存储看起来并不

1397
00:55:01,039 --> 00:55:03,049
协调 就像保持由 Facebook 编写的

1398
00:55:03,049 --> 00:55:05,359
多主设备同步一样，

1399
00:55:05,359 --> 00:55:08,109


1400
00:55:08,180 --> 00:55:11,010
所以我们

1401
00:55:11,010 --> 00:55:12,720
在复制环境中关心的一个重要属性

1402
00:55:12,720 --> 00:55:14,850
是 K 安全的概念，

1403
00:55:14,850 --> 00:55:16,980
这里的想法只是跟踪

1404
00:55:16,980 --> 00:55:19,020
您的对象的副本数量

1405
00:55:19,020 --> 00:55:21,350
为了让我们的系统保持在线状态

1406
00:55:21,350 --> 00:55:23,640
，我不知道 KP 是否是一个

1407
00:55:23,640 --> 00:55:25,500
标准化术语，这是

1408
00:55:25,500 --> 00:55:28,170
Mike Stonebreaker 在描述垂直 TB 时使用的东西

1409
00:55:28,170 --> 00:55:30,240
，基本上这是一个

1410
00:55:30,240 --> 00:55:31,800
人为定义的阈值，可以说我

1411
00:55:31,800 --> 00:55:34,050
至少需要拥有

1412
00:55:34,050 --> 00:55:36,510
在我的致敬数据库中始终有 K 个特定对象的副本

1413
00:55:36,510 --> 00:55:38,280
，如果我低于该 K，

1414
00:55:38,280 --> 00:55:41,070
那么我会停止系统并

1415
00:55:41,070 --> 00:55:42,840
停止，直到我可以提出一个新的

1416
00:55:42,840 --> 00:55:45,030
新副本 或者你知道休斯

1417
00:55:45,030 --> 00:55:47,010
或人类进来并进行

1418
00:55:47,010 --> 00:55:49,680
更正这里的想法是我们

1419
00:55:49,680 --> 00:55:51,480
想要避免丢失数据所以很明显我

1420
00:55:51,480 --> 00:55:54,180
希望我的 K 安全节拍至少是

1421
00:55:54,180 --> 00:55:56,370
1 因为如果我丢失了一个

1422
00:55:56,370 --> 00:55:58,620
你知道，如果我丢失了一个节点，该节点拥有

1423
00:55:58,620 --> 00:55:59,940
一段数据的唯一副本，

1424
00:55:59,940 --> 00:56:01,860
那么我现在就搞砸了我可能会有不同查询的

1425
00:56:01,860 --> 00:56:03,510
误报或误报，

1426
00:56:03,510 --> 00:56:04,530
而且我的数据库

1427
00:56:04,530 --> 00:56:07,020
不正确，所以这个阈值

1428
00:56:07,020 --> 00:56:08,580
实际上取决于你 知道

1429
00:56:08,580 --> 00:56:12,180
你对保持

1430
00:56:12,180 --> 00:56:14,010
在线状态有多偏执，然后你也可以知道

1431
00:56:14,010 --> 00:56:15,900
改变这一点，比如在我的例子

1432
00:56:15,900 --> 00:56:17,370
中我在巴西有更多的副本，

1433
00:56:17,370 --> 00:56:20,220
也许

1434
00:56:20,220 --> 00:56:22,230
在美国有一个副本，你知道在美国，因为我想

1435
00:56:22,230 --> 00:56:24,330
让你知道我关心

1436
00:56:24,330 --> 00:56:28,260
在巴西保留本地副本，所以现在

1437
00:56:28,260 --> 00:56:29,520
我们想知道我们

1438
00:56:29,520 --> 00:56:30,990
实际上在传播什么，或者我们如何

1439
00:56:30,990 --> 00:56:32,790
实际传播我们的更改以

1440
00:56:32,790 --> 00:56:35,040
获得复制品，他有点问

1441
00:56:35,040 --> 00:56:36,450
这个像这样做 意思是我们在做

1442
00:56:36,450 --> 00:56:38,190
夜 ntual 一致性，我提到

1443
00:56:38,190 --> 00:56:41,490
不是你会明白为什么所以传播

1444
00:56:41,490 --> 00:56:45,570
团队是我们什么

1445
00:56:45,570 --> 00:56:47,430
时候应该等待多长时间或者我们应该

1446
00:56:47,430 --> 00:56:48,480
在什么时候告诉外界我们的

1447
00:56:48,480 --> 00:56:51,570
事务已经提交，这在

1448
00:56:51,570 --> 00:56:52,620
某种程度上独立于 两阶段

1449
00:56:52,620 --> 00:56:54,090
提交的东西是对的，

1450
00:56:54,090 --> 00:56:56,520
就像我的副本一样，我应该等到

1451
00:56:56,520 --> 00:56:58,860
副本承认他们得到了我的

1452
00:56:58,860 --> 00:57:01,680
更改并将安全安全存储

1453
00:57:01,680 --> 00:57:03,900
在磁盘中，然后再告诉

1454
00:57:03,900 --> 00:57:06,360
外界我实际上已经提交了，并且

1455
00:57:06,360 --> 00:57:07,500
一般来说 使用

1456
00:57:07,500 --> 00:57:09,720
同步或异步同步的两种方法

1457
00:57:09,720 --> 00:57:10,950
将为您提供所谓的强

1458
00:57:10,950 --> 00:57:13,350
一致性，这意味着我可以保证

1459
00:57:13,350 --> 00:57:14,820
，如果我告诉外界我的

1460
00:57:14,820 --> 00:57:16,860
事务已提交，如果我

1461
00:57:16,860 --> 00:57:18,450
从任何副本读取数据，我

1462
00:57:18,450 --> 00:57:20,130
保证会看到

1463
00:57:20,130 --> 00:57:20,430


1464
00:57:20,430 --> 00:57:23,070
最终一致性的转向行动的

1465
00:57:23,070 --> 00:57:25,380
想法是，更改最终

1466
00:57:25,380 --> 00:57:27,240
将传播到我的副本，所以如果我去，

1467
00:57:27,240 --> 00:57:29,460
如果我听到我的事务已

1468
00:57:29,460 --> 00:57:31,050
提交并且我立即 ately 去尝试

1469
00:57:31,050 --> 00:57:32,910
在副本上读取它我可能实际上

1470
00:57:32,910 --> 00:57:37,080
看不到它所以再次直观地看这个所以

1471
00:57:37,080 --> 00:57:39,480
使用同步我们说两个节点

1472
00:57:39,480 --> 00:57:42,300
假设我们正在做一个主副本

1473
00:57:42,300 --> 00:57:45,360
设置我们说我们想要

1474
00:57:45,360 --> 00:57:47,460
在我们的 master 然后我们必须

1475
00:57:47,460 --> 00:57:51,660
转到副本并说嘿，是的，

1476
00:57:51,660 --> 00:57:53,660
我们向您发送了一堆有关此事务的日志消息或

1477
00:57:53,660 --> 00:57:56,160
更新

1478
00:57:56,160 --> 00:57:58,350
，然后刷新它，然后我们暂停并

1479
00:57:58,350 --> 00:57:59,880
等待我们收到

1480
00:57:59,880 --> 00:58:01,800
来自我们的回复 副本表示我们的

1481
00:58:01,800 --> 00:58:03,960
事务已成功

1482
00:58:03,960 --> 00:58:05,460
提交，然后它是持久的和磁盘

1483
00:58:05,460 --> 00:58:07,860
，然后一旦完成它完成刷新

1484
00:58:07,860 --> 00:58:09,180
我们发回

1485
00:58:09,180 --> 00:58:10,770
确认，此时我们可以告诉外部

1486
00:58:10,770 --> 00:58:13,350
世界我们已经在此时再次提交

1487
00:58:13,350 --> 00:58:14,880
在这里，当我们取回 Siq

1488
00:58:14,880 --> 00:58:16,290
知识时，这意味着如果我们尝试阅读

1489
00:58:16,290 --> 00:58:18,660
修改后的任何内容，我们

1490
00:58:18,660 --> 00:58:21,180
保证会看到该更改是正确的，

1491
00:58:21,180 --> 00:58:23,130
您知道我们希望

1492
00:58:23,130 --> 00:58:27,200
在主服务器和任何

1493
00:58:27,200 --> 00:58:29,610
具有异步功能的副本上进行的更改您都没有看到“ 吨 等待

1494
00:58:29,610 --> 00:58:32,610
那个响应所以我继续说我

1495
00:58:32,610 --> 00:58:35,010
想提交然后我说嘿去但是继续

1496
00:58:35,010 --> 00:58:37,470
并强制更改但是然后我可以

1497
00:58:37,470 --> 00:58:39,270
尼利回到应用程序说

1498
00:58:39,270 --> 00:58:43,080
我的事务已经提交然后

1499
00:58:43,080 --> 00:58:46,080
现在在稍后的某个时间你知道这一点

1500
00:58:46,080 --> 00:58:47,850
最终被刷新的事情，但我

1501
00:58:47,850 --> 00:58:48,960
真的不需要告诉

1502
00:58:48,960 --> 00:58:51,540
主人很高兴知道但我从技术上讲

1503
00:58:51,540 --> 00:58:54,990
我不必被告知所以这是分布式数据库

1504
00:58:54,990 --> 00:58:55,950
之间的良好区别之一

1505
00:58:55,950 --> 00:58:58,310
抱歉，

1506
00:58:58,310 --> 00:59:02,130
传统的事务关系

1507
00:59:02,130 --> 00:59:03,870
数据库管理系统和

1508
00:59:03,870 --> 00:59:06,780
事务数据库系统中没有续集的人

1509
00:59:06,780 --> 00:59:08,100
我们不想丢失任何

1510
00:59:08,100 --> 00:59:09,330
数据我们不想有任何

1511
00:59:09,330 --> 00:59:11,360
不一致的读取所以我们总是做

1512
00:59:11,360 --> 00:59:14,340
同步复制表示没有

1513
00:59:14,340 --> 00:59:16,490
续集的人会在这里做这个，

1514
00:59:16,490 --> 00:59:19,200
因为 想法是，最终这

1515
00:59:19,200 --> 00:59:20,670
件事我会传播到我的复制品

1516
00:59:20,670 --> 00:59:23,970
，所以也许在像 50 毫秒这样的小窗口中，

1517
00:59:23,970 --> 00:59:25,590
我可能会

1518
00:59:25,590 --> 00:59:29,210
在我的复制品上获得过时的读数，谁在乎

1519
00:59:29,210 --> 00:59:31,500
它可能是一个网站 像愚蠢的

1520
00:59:31,500 --> 00:59:33,849
猫食猫照片和评论

1521
00:59:33,849 --> 00:59:35,680
你知道我看不到猫猫评论的最后 50

1522
00:59:35,680 --> 00:59:38,170
毫秒它

1523
00:59:38,170 --> 00:59:39,279
可能足够好

1524
00:59:39,279 --> 00:59:41,140
我当然有钱我想使用

1525
00:59:41,140 --> 00:59:44,019
它因为这里可能发生的事情

1526
00:59:44,019 --> 00:59:47,349
我告诉我的交易提交我告诉

1527
00:59:47,349 --> 00:59:49,239
我承诺的外部世界，但后来这个

1528
00:59:49,239 --> 00:59:51,789
人崩溃了，这个人崩溃了，说

1529
00:59:51,789 --> 00:59:53,109
这个人没有将任何东西刷新到磁盘

1530
00:59:53,109 --> 00:59:55,869
，这个人还没有收到

1531
00:59:55,869 --> 00:59:58,029
消息或者现在没有应用它我

1532
00:59:58,029 --> 01:00:01,440
想回来我的 交易消失了

1533
01:00:02,579 --> 01:00:07,709
，我会说

1534
01:00:07,709 --> 01:00:10,599
很多 10 年前的无续集和无续集

1535
01:00:10,599 --> 01:00:12,670
系统都说

1536
01:00:12,670 --> 01:00:14,469
我们是鞋子的续集他们将

1537
01:00:14,469 --> 01:00:16,589
避免加入避免交易

1538
01:00:16,589 --> 01:00:18,519
大多数他们都添加了 交易

1539
01:00:18,519 --> 01:00:20,529
，他们中的大多数都添加了续集

1540
01:00:20,529 --> 01:00:25,569
和关节，所以我

1541
01:00:25,569 --> 01:00:26,859
并不是说我知道 Segoe 系统的某些方面

1542
01:00:26,859 --> 01:00:28,630
是无效的

1543
01:00:28,630 --> 01:00:30,130
，当然还有像

1544
01:00:30,130 --> 01:00:31,719
网站这样的用例，我们真的不需要有

1545
01:00:31,719 --> 01:00:35,049
很强的一致性，但在 一般我的意思是

1546
01:00:35,049 --> 01:00:36,400
有足够的应用程序在

1547
01:00:36,400 --> 01:00:38,499
那里这很重要因为

1548
01:00:38,499 --> 01:00:44,289
你不会丢失任何数据所以让我们

1549
01:00:44,289 --> 01:00:45,910
说如果我在这里收到这个提交消息

1550
01:00:45,910 --> 01:00:47,559
我立即回来说我

1551
01:00:47,559 --> 01:00:49,989
承认并且我没有得到

1552
01:00:49,989 --> 01:00:52,630
这里的任何东西实际上看到有人确实

1553
01:00:52,630 --> 01:00:54,549
记录了一些正确的东西说我醒来到

1554
01:00:54,549 --> 01:00:56,619
磁盘我们进入了这个交易但是

1555
01:00:56,619 --> 01:00:58,269
现在这台机器着火了

1556
01:00:58,269 --> 01:01:02,619
那些磁盘牛奶一样所以现在这个

1557
01:01:02,619 --> 01:01:05,079
人崩溃了但他只是崩溃了他

1558
01:01:05,079 --> 01:01:07,719
回来了他看起来 在这个日志中，他

1559
01:01:07,719 --> 01:01:08,829
没有收到流感消息，所以

1560
01:01:08,829 --> 01:01:11,589
没有及时显示，所以我告诉

1561
01:01:11,589 --> 01:01:13,719
外面的世界我犯了，但这个人

1562
01:01:13,719 --> 01:01:16,029
从来没有解决这个变化，我崩溃了，所以

1563
01:01:16,029 --> 01:01:21,969
我现在回来

1564
01:01:21,969 --> 01:01:22,640
，

1565
01:01:22,640 --> 01:01:24,049
如果那是的话，交易已经消失了 你的银行账户有那

1566
01:01:24,049 --> 01:01:28,509
笔汇款 你很生气

1567
01:01:28,630 --> 01:01:31,309
所以由应用程序来决定

1568
01:01:31,309 --> 01:01:32,450
他们想要做出什么样的权衡

1569
01:01:32,450 --> 01:01:33,289
他们关心

1570
01:01:33,289 --> 01:01:35,960
好吗你是不是超级保守并且

1571
01:01:35,960 --> 01:01:37,549
不会丢失任何数据然后同步

1572
01:01:37,549 --> 01:01:39,890
复制是 如果您

1573
01:01:39,890 --> 01:01:41,930
可以接受可能丢失最后 10 个 5

1574
01:01:41,930 --> 01:01:43,910
数据的方法，您知道 50 毫秒的数据，

1575
01:01:43,910 --> 01:01:49,599
这是正确的方法

1576
01:01:49,599 --> 01:01:52,099
下一个问题是我们

1577
01:01:52,099 --> 01:01:54,380
什么时候真正感觉到那里发送我们的

1578
01:01:54,380 --> 01:01:56,059
更改哦，还有什么 做这些更改

1579
01:01:56,059 --> 01:01:59,509
实际上看起来像所以一种方法是

1580
01:01:59,509 --> 01:02:03,259
让主服务器不断

1581
01:02:03,259 --> 01:02:05,210
发送事务发生时所做的所有更新

1582
01:02:05,210 --> 01:02:07,970
想想

1583
01:02:07,970 --> 01:02:10,009
这就像它附加到正确的

1584
01:02:10,009 --> 01:02:11,630
前面的日志所以每当我创建一个日志

1585
01:02:11,630 --> 01:02:12,950
记录我 我会让你知道我

1586
01:02:12,950 --> 01:02:14,480
想写出磁盘 我还把

1587
01:02:14,480 --> 01:02:17,359
它通过网络发送到我的副本到我的

1588
01:02:17,359 --> 01:02:19,430
副本，他们可以开始应用

1589
01:02:19,430 --> 01:02:21,769
更改，当然这

1590
01:02:21,769 --> 01:02:23,509
意味着现在我不仅不 需要

1591
01:02:23,509 --> 01:02:24,710
发送提交消息，但我还需要

1592
01:02:24,710 --> 01:02:26,569
发送中止消息，

1593
01:02:26,569 --> 01:02:28,130
就像我在重播红发日志时一样，

1594
01:02:28,130 --> 01:02:30,200
因为我需要知道

1595
01:02:30,200 --> 01:02:33,650
回滚所需的更改 另一种方法

1596
01:02:33,650 --> 01:02:37,609
是只发送日志

1597
01:02:37,609 --> 01:02:39,589
交易实际进入 int 时的消息 o commit 所以

1598
01:02:39,589 --> 01:02:42,559
我们只是在主节点的内存中缓冲我们所有的日志消息

1599
01:02:42,559 --> 01:02:45,109
然后开始

1600
01:02:45,109 --> 01:02:47,089
中止谁在乎我们只是删除它我们不

1601
01:02:47,089 --> 01:02:48,650
发送它

1602
01:02:48,650 --> 01:02:51,109
如果我们继续提交然后我们将

1603
01:02:51,109 --> 01:02:54,619
所有内容推送到我们的 主我开始

1604
01:02:54,619 --> 01:02:57,980
到我们的副本好了

1605
01:02:57,980 --> 01:02:59,029
，这个的好处是你不会

1606
01:02:59,029 --> 01:03:00,710
浪费时间发送日志消息，这些日志消息

1607
01:03:00,710 --> 01:03:02,569
将从他们将要登陆的事务中中止，

1608
01:03:02,569 --> 01:03:05,450
但当然这

1609
01:03:05,450 --> 01:03:07,369
意味着现在如果我需要它，如果我' 我在做

1610
01:03:07,369 --> 01:03:09,019
同步复制，我需要

1611
01:03:09,019 --> 01:03:11,329
等到这个人承认

1612
01:03:11,329 --> 01:03:12,710
副本知识是它应用了

1613
01:03:12,710 --> 01:03:14,329
所有这些更改然后如果我

1614
01:03:14,329 --> 01:03:16,190
一次发送大量更新我

1615
01:03:16,190 --> 01:03:17,329
必须等到它们都被刷新

1616
01:03:17,329 --> 01:03:19,009
而在这个 一个我可以

1617
01:03:19,009 --> 01:03:21,710
逐步完成，因为他们知道大多数

1618
01:03:21,710 --> 01:03:25,239
系统都会在这里做第一个

1619
01:03:25,239 --> 01:03:27,109
，最后一个更

1620
01:03:27,109 --> 01:03:33,140
微妙，但这就是它

1621
01:03:33,140 --> 01:03:34,759
决定我们如何实际

1622
01:03:34,759 --> 01:03:36,290
应用我们的一个

1623
01:03:36,290 --> 01:03:37,820
更改 是行为 通常会应用于

1624
01:03:37,820 --> 01:03:42,380
我们副本上的系统，因此在

1625
01:03:42,380 --> 01:03:44,090
新数据库中很多时候

1626
01:03:44,090 --> 01:03:46,040
术语含糊不清，或者人们使用

1627
01:03:46,040 --> 01:03:46,880
不同的东西或描述

1628
01:03:46,880 --> 01:03:49,910
不同的东西，但我认为主动

1629
01:03:49,910 --> 01:03:51,620
被动与主动主动已经

1630
01:03:51,620 --> 01:03:52,970
足够标准化，这

1631
01:03:52,970 --> 01:03:53,960
很有意义我不 不知道什么我不

1632
01:03:53,960 --> 01:03:56,960
知道教科书涵盖了这个所以

1633
01:03:56,960 --> 01:03:58,520
认为这就像 active active

1634
01:03:58,520 --> 01:04:01,250
想法是我们的事务将

1635
01:04:01,250 --> 01:04:07,100
在我们的每个副本上独立运行

1636
01:04:07,100 --> 01:04:09,800
所以说 Mia 但我们有一个

1637
01:04:09,800 --> 01:04:11,810
事务想要更新 四个元组，

1638
01:04:11,810 --> 01:04:14,060
我们将在

1639
01:04:14,060 --> 01:04:15,470
主服务器上运行该事务我在副本上运行该事务，

1640
01:04:15,470 --> 01:04:17,150
或者如果我们再次进行多主服务器

1641
01:04:17,150 --> 01:04:19,190
，它会在每个注释的每个副本上运行

1642
01:04:19,190 --> 01:04:23,120
，因此当他们

1643
01:04:23,120 --> 01:04:25,190
提交我们需要的所有内容时，他们会 要

1644
01:04:25,190 --> 01:04:26,630
确定我们是否已正确提交

1645
01:04:26,630 --> 01:04:27,950
，我们需要检查

1646
01:04:27,950 --> 01:04:31,300
它们是否都产生相同的结果

1647
01:04:31,300 --> 01:04:34,100
，如果您正在

1648
01:04:34,100 --> 01:04:35,930
执行

1649
01:04:35,930 --> 01:04:38,450
诸如两阶段之类的非确定性控制方案，这并不容易 锁定，并且

1650
01:04:38,450 --> 01:04:40,430
您知道可以节省时间，学习

1651
01:04:40,430 --> 01:04:41,630
我们之前讨论的所有内容，因为

1652
01:04:41,630 --> 01:04:43,100
现在您可以保证

1653
01:04:43,100 --> 01:04:44,720
事务

1654
01:04:44,720 --> 01:04:47,330
在我们的两个副本上以相同的顺序运行，而无需

1655
01:04:47,330 --> 01:04:50,270
检查每个查询，所以我们

1656
01:04:50,270 --> 01:04:51,560
讨论了一点，但分区

1657
01:04:51,560 --> 01:04:54,110
与 Prashant 讲话时相同的排序方案

1658
01:04:54,110 --> 01:04:55,820
告诉那个讲座，在这种

1659
01:04:55,820 --> 01:04:57,470
情况下，这是一个术语，您可以将其用于

1660
01:04:57,470 --> 01:04:59,990
确定性虚拟，并保证

1661
01:04:59,990 --> 01:05:01,970
您知道交易

1662
01:05:01,970 --> 01:05:03,500
在双方以完全相同的顺序运行它们的操作，

1663
01:05:03,500 --> 01:05:06,800
因此主动主动并不那么

1664
01:05:06,800 --> 01:05:09,190
常见，因为您 必须做一个更好的

1665
01:05:09,190 --> 01:05:12,920
练习，运行完全相同，

1666
01:05:12,920 --> 01:05:15,050
更常见的是主动被动，其中

1667
01:05:15,050 --> 01:05:16,780
事务可以

1668
01:05:16,780 --> 01:05:20,300
在一个主节点的一个位置上执行，然后

1669
01:05:20,300 --> 01:05:21,860
他们会将更改传播到

1670
01:05:21,860 --> 01:05:24,710
副本，而这些更改

1671
01:05:24,710 --> 01:05:27,890
可能类似于 没有正确的日志，我们

1672
01:05:27,890 --> 01:05:29,810
可以将物理

1673
01:05:29,810 --> 01:05:32,180
更新发送到实际的 2 加上它们本身，

1674
01:05:32,180 --> 01:05:33,380
或者发送我们更改的低低字节的字节

1675
01:05:33,380 --> 01:05:35,630
d 或者我们也可以流式传输

1676
01:05:35,630 --> 01:05:36,950
他们所做的后续查询，然后只

1677
01:05:36,950 --> 01:05:38,060
重放单个查询和我们的

1678
01:05:38,060 --> 01:05:41,030
副本

1679
01:05:41,030 --> 01:05:42,020
，正如我们之前讨论过的那样

1680
01:05:42,020 --> 01:05:44,380
，您知道恢复时间

1681
01:05:44,380 --> 01:05:46,490
物理复制通常是最

1682
01:05:46,490 --> 01:05:47,360
常见的，因为所有 你真正在做

1683
01:05:47,360 --> 01:05:49,170
的只是发送很多红发日志

1684
01:05:49,170 --> 01:05:51,150
然后复制品

1685
01:05:51,150 --> 01:05:54,140
重播所以这个明确的

1686
01:05:54,140 --> 01:06:07,559
问题是如果你发送是的他的

1687
01:06:07,559 --> 01:06:09,420
基督徒是是的我实际上

1688
01:06:09,420 --> 01:06:10,920
同意一个声明是如果你是

1689
01:06:10,920 --> 01:06:12,359
发送续集查询

1690
01:06:12,359 --> 01:06:17,849
与主动主动我

1691
01:06:17,849 --> 01:06:19,380
在思考主动被动方面不同

1692
01:06:19,380 --> 01:06:21,780
，我在主服务器上运行续集查询

1693
01:06:21,780 --> 01:06:24,599
，然后日志

1694
01:06:24,599 --> 01:06:27,299
消息作为续集查询主动

1695
01:06:27,299 --> 01:06:28,950
主动出现 在存储过程的上下文中，可以

1696
01:06:28,950 --> 01:06:30,839
认为两个事务

1697
01:06:30,839 --> 01:06:32,849
完全独立地在

1698
01:06:32,849 --> 01:06:35,339
两个副本上运行，但在您的示例中，是的

1699
01:06:35,339 --> 01:06:37,170
，这就是我所说的

1700
01:06:37,170 --> 01:06:39,210
条款模糊不清，我同意 ld

1701
01:06:39,210 --> 01:06:41,010
是主动主动的，即使它

1702
01:06:41,010 --> 01:06:44,640
是在主动被动之后完成的，因为

1703
01:06:44,640 --> 01:06:47,130


1704
01:06:47,130 --> 01:06:48,270
我在主服务器上运行它然后只有在我在主服务器上运行然后我发送

1705
01:06:48,270 --> 01:06:49,859
到副本之后，你可以说

1706
01:06:49,859 --> 01:06:51,510
好吧，我已经运行了这个查询和 然后

1707
01:06:51,510 --> 01:06:52,710
就在你在主服务器上运行它之前，

1708
01:06:52,710 --> 01:06:53,940
你将它发送到

1709
01:06:53,940 --> 01:06:56,849
副本是活跃的活动嗯嗯

1710
01:06:56,849 --> 01:07:04,170
我同意是的好吧，我们

1711
01:07:04,170 --> 01:07:07,530
还有八分钟，这就像

1712
01:07:07,530 --> 01:07:10,109
最困难的事情之一让我们滚动

1713
01:07:10,109 --> 01:07:12,619
骰子让我们看看我们可以做到这一点 所以

1714
01:07:12,619 --> 01:07:14,700
有一种叫做 cat 定理的东西

1715
01:07:14,700 --> 01:07:16,260
，人们将其应用于 trippity

1716
01:07:16,260 --> 01:07:19,040
数据库，这是一种

1717
01:07:19,040 --> 01:07:21,990
表征和理解分布式数据库可以为您提供的

1718
01:07:21,990 --> 01:07:25,010
属性或保证的方法，

1719
01:07:25,010 --> 01:07:28,220


1720
01:07:28,220 --> 01:07:31,020
并且它已被分解 三个部分

1721
01:07:31,020 --> 01:07:33,000
的一致性始终

1722
01:07:33,000 --> 01:07:34,290
可用并且从不分区 脚

1723
01:07:34,290 --> 01:07:37,140
容错 所以这最初

1724
01:07:37,140 --> 01:07:39,750
是由一位

1725
01:07:39,750 --> 01:07:41,460
名叫 Eric Brewer 的伯克利教授在

1726
01:07:41,460 --> 01:07:44,099
1990 年代后期提出的一个猜想，然后它是正式的 你在

1727
01:07:44,099 --> 01:07:45,990
麻省理工学院证明这实际上是正确的

1728
01:07:45,990 --> 01:07:49,559
这是 2002 年的一个真实定理

1729
01:07:49,559 --> 01:07:51,420
基本思想是

1730
01:07:51,420 --> 01:07:52,290
如果你要

1731
01:07:52,290 --> 01:07:55,140
断言所有这三件事 贝叶斯 你

1732
01:07:55,140 --> 01:07:56,460
必须选择其中两个你得到

1733
01:07:56,460 --> 01:07:59,430
三分之二是对的，这有点像如果你

1734
01:07:59,430 --> 01:08:02,230
想要，就像你知道

1735
01:08:02,230 --> 01:08:04,600
你正在寻找丈夫或妻子一样，

1736
01:08:04,600 --> 01:08:05,980
你可以选择一个人要么聪明

1737
01:08:05,980 --> 01:08:07,720
漂亮要么不疯狂，但你可以

1738
01:08:07,720 --> 01:08:08,950
从三个中给我两个

1739
01:08:08,950 --> 01:08:09,700


1740
01:08:09,700 --> 01:08:11,770
滴水数据库的事情是一样的，所以

1741
01:08:11,770 --> 01:08:12,910
让我们一次

1742
01:08:12,910 --> 01:08:16,450
又一次地走一遍，这个想法是这种

1743
01:08:16,450 --> 01:08:18,970
维恩图，你有 CA P，

1744
01:08:18,970 --> 01:08:20,319
你永远不会在中间，你

1745
01:08:20,319 --> 01:08:21,580
永远不会得到一个系统有保证

1746
01:08:21,580 --> 01:08:23,799
所有这些东西 所以一致性只是

1747
01:08:23,799 --> 01:08:25,810
意味着线性化能力，认为这是

1748
01:08:25,810 --> 01:08:28,170
一个更强的序列化

1749
01:08:28,170 --> 01:08:30,609
可用性版本意味着在任何给定的

1750
01:08:30,609 --> 01:08:32,529
时间我们可以访问任何节点并获取

1751
01:08:32,529 --> 01:08:36,339
我们系统中的任何数据，然后分区

1752
01:08:36,339 --> 01:08:38,380
容忍这意味着如果我们开始

1753
01:08:38,380 --> 01:08:39,819
丢失消息 es 因为网络

1754
01:08:39,819 --> 01:08:42,009
宕机 机器宕机 我们

1755
01:08:42,009 --> 01:08:44,410
仍然可以处理我们可能

1756
01:08:44,410 --> 01:08:45,479
想要的任何响应

1757
01:08:45,479 --> 01:08:49,270
所以没有续集的人他们将

1758
01:08:49,270 --> 01:08:53,049
成为 AP 他们将尝试

1759
01:08:53,049 --> 01:08:54,609
提供可用性和分区

1760
01:08:54,609 --> 01:08:56,710
容错性作为交换 放弃

1761
01:08:56,710 --> 01:08:58,450
这样的一致性是最终的

1762
01:08:58,450 --> 01:08:59,890
一致性 就像我不能

1763
01:08:59,890 --> 01:09:02,979
保证如果我告诉你我做了你我

1764
01:09:02,979 --> 01:09:04,540
告诉你你是对的

1765
01:09:04,540 --> 01:09:05,859
我保证每个人都会

1766
01:09:05,859 --> 01:09:08,738
在新的续集中看到这一点 或者

1767
01:09:08,738 --> 01:09:10,359


1768
01:09:10,359 --> 01:09:12,430
数据系统的传统事务区，他们会尝试做

1769
01:09:12,430 --> 01:09:16,779
CPU 或 CA 然后他们的奖励如果我

1770
01:09:16,779 --> 01:09:19,060
不能与节点交谈而不是继续

1771
01:09:19,060 --> 01:09:20,460
运行我只是关闭整个事情

1772
01:09:20,460 --> 01:09:23,439
，在这种情况下我给 up 我放弃了

1773
01:09:23,439 --> 01:09:25,839
铃 Doty 好吧，让我们

1774
01:09:25,839 --> 01:09:27,250
一个一个地浏览这些我想我们已经涵盖了

1775
01:09:27,250 --> 01:09:29,109
其中的大部分内容，但只是为了

1776
01:09:29,109 --> 01:09:31,060
直观地向它们展示它们以了解

1777
01:09:31,060 --> 01:09:32,920
它们的实际含义所以再次使用亲吻

1778
01:09:32,920 --> 01:09:34,988
辅助 II 的想法是 如果 w 我们

1779
01:09:34,988 --> 01:09:36,670
在一台机器上写一个写，每个人都

1780
01:09:36,670 --> 01:09:38,680
应该看到它，然后我们告诉

1781
01:09:38,680 --> 01:09:39,790
外部世界它

1782
01:09:39,790 --> 01:09:41,589
成功了，所以我们的事务

1783
01:09:41,589 --> 01:09:43,330
在这个应用程序服务器上运行，它想

1784
01:09:43,330 --> 01:09:45,880
将 a 设置为 2，然后我们将

1785
01:09:45,880 --> 01:09:47,770
传播它 更改此副本

1786
01:09:47,770 --> 01:09:50,080
，然后我们可以告诉外部

1787
01:09:50,080 --> 01:09:51,549
世界我们确实在那里确认了，

1788
01:09:51,549 --> 01:09:55,210
此时无论我们在

1789
01:09:55,210 --> 01:09:57,910
副本上还是在主服务器上读取 a 都会看到 ae

1790
01:09:57,910 --> 01:10:00,040
等于 2，因此另一个应用程序

1791
01:10:00,040 --> 01:10:02,380
服务器可以立即看到

1792
01:10:02,380 --> 01:10:04,090
no 成功了 我可以看到等于

1793
01:10:04,090 --> 01:10:08,160
2 并且我得到了正确的响应

1794
01:10:09,320 --> 01:10:11,219
分区容限

1795
01:10:11,219 --> 01:10:13,409


1796
01:10:13,409 --> 01:10:17,010


1797
01:10:17,010 --> 01:10:18,630


1798
01:10:18,630 --> 01:10:20,579


1799
01:10:20,579 --> 01:10:27,300
在这里好吧，然后最后

1800
01:10:27,300 --> 01:10:28,710
一个是分区容忍度这里的想法

1801
01:10:28,710 --> 01:10:30,929
是说网络关闭

1802
01:10:30,929 --> 01:10:32,039
了我用来

1803
01:10:32,039 --> 01:10:34,679
在这两台机器之间进行通信的网络去 关闭

1804
01:10:34,679 --> 01:10:35,999
机器不会关闭但它永远不会

1805
01:10:35,999 --> 01:10:38,489
关闭或者我的消息我的数据包

1806
01:10:38,489 --> 01:10:40,679
在网络中丢失所以现在

1807
01:10:40,679 --> 01:10:43,199


1808
01:10:43,199 --> 01:10:45,150
在我们设置主副本之前很快就会在这里发生的事情

1809
01:10:45,150 --> 01:10:47,130
我说像我设置的那样主控 up 你

1810
01:10:47,130 --> 01:10:48,749
运行 patos 来决定谁然后谁是

1811
01:10:48,749 --> 01:10:52,349
master 然后所有

1812
01:10:52,349 --> 01:10:54,619
更新都要去那里 所以此时

1813
01:10:54,619 --> 01:10:56,880
有一个网络分区

1814
01:10:56,880 --> 01:10:59,400
所以这些人无法通信 但他们

1815
01:10:59,400 --> 01:11:00,659
知道他们就像你知道的那样 你

1816
01:11:00,659 --> 01:11:04,469
还活着，所以现在你运行paxos，你

1817
01:11:04,469 --> 01:11:06,179
发现哦，我现在还活着，我是

1818
01:11:06,179 --> 01:11:09,510
新的主人，所以现在如果我的两个

1819
01:11:09,510 --> 01:11:11,369
应用服务器

1820
01:11:11,369 --> 01:11:13,650
同时向我的数据库发送更新，这

1821
01:11:13,650 --> 01:11:15,239
家伙设置了 等于这个人的说

1822
01:11:15,239 --> 01:11:17,280
八 所有三个这两个笔记

1823
01:11:17,280 --> 01:11:18,630
都认为他们的主人因为他们跑了

1824
01:11:18,630 --> 01:11:20,489
那些很好的你知道没有

1825
01:11:20,489 --> 01:11:22,050
其他人关于将我们加载到

1826
01:11:22,050 --> 01:11:23,999
主人所以我们说好的

1827
01:11:23,999 --> 01:11:25,739
我可以继续进行这个更改 我们

1828
01:11:25,739 --> 01:11:26,670
发送确认，我们 m

1829
01:11:26,670 --> 01:11:30,030
改变了，但现在网络在某个

1830
01:11:30,030 --> 01:11:32,489
时候回来了，我需要

1831
01:11:32,489 --> 01:11:34,469
在同步中协调这个变化，现在你

1832
01:11:34,469 --> 01:11:35,849
搞砸了，因为现在一个人说我

1833
01:11:35,849 --> 01:11:37,199
等于二，另一个人说等于

1834
01:11:37,199 --> 01:11:39,269
三，我们告诉外界

1835
01:11:39,269 --> 01:11:49,829
那些 权利成功了所以是的更正

1836
01:11:49,829 --> 01:11:52,889
是你什么时候可以拥有 CP 你 mM 你不能

1837
01:11:52,889 --> 01:11:57,289
真正收回

1838
01:11:57,289 --> 01:11:59,460
是的 所以这就是我所说的它

1839
01:11:59,460 --> 01:12:02,550
有点 所以 CP 看起来像 CV 是

1840
01:12:02,550 --> 01:12:05,639
说网络出现故障我不能

1841
01:12:05,639 --> 01:12:08,360
沟通 沟通这两个节点

1842
01:12:08,360 --> 01:12:09,989


1843
01:12:09,989 --> 01:12:13,920
如果我正在做一个 kay 安全的事情

1844
01:12:13,920 --> 01:12:17,010
，我应该怎么做，我说我需要始终拥有三个

1845
01:12:17,010 --> 01:12:19,860
数据副本，并说我有

1846
01:12:19,860 --> 01:12:22,050
另一个我在这里有另一个节点，

1847
01:12:22,050 --> 01:12:24,660
所以这两个家伙 你会说嘿

1848
01:12:24,660 --> 01:12:26,490
我们至少有两个副本我们很好我们

1849
01:12:26,490 --> 01:12:27,960
进行领导人选举这个人说他

1850
01:12:27,960 --> 01:12:28,590
是主人

1851
01:12:28,590 --> 01:12:31,110
所以现在任何人都可以在这里写

1852
01:12:31,110 --> 01:12:31,890
然后就可以了

1853
01:12:31,890 --> 01:12:33,510
这个人在这里说好迈克

1854
01:12:33,510 --> 01:12:37,410
安全是两个但我只有 有一个所以

1855
01:12:37,410 --> 01:12:39,090
我必须关闭我不能运行任何东西 ng

1856
01:12:39,090 --> 01:12:41,090
所以我放弃了可用性

1857
01:12:41,090 --> 01:12:43,080
所以在那种情况下我可以让我在

1858
01:12:43,080 --> 01:12:44,850
技术上处理

1859
01:12:44,850 --> 01:12:48,000
网络中的分区，因为

1860
01:12:48,000 --> 01:12:49,890
那一边不可用，但这边

1861
01:12:49,890 --> 01:12:52,170
没问题，所以这被称为

1862
01:12:52,170 --> 01:12:54,150
像我这样的裂脑主动系统

1863
01:12:54,150 --> 01:12:56,220
两个大脑大小 大脑无法

1864
01:12:56,220 --> 01:12:57,330
交流 他们都认为

1865
01:12:57,330 --> 01:13:02,310
自己是世界之王 所以

1866
01:13:02,310 --> 01:13:04,890
在传统的事务数据库

1867
01:13:04,890 --> 01:13:07,860
系统中，

1868
01:13:07,860 --> 01:13:09,180
当您意识到无法

1869
01:13:09,180 --> 01:13:12,630
与每个人正确交流时，他们基本上会停止系统 或者如果你

1870
01:13:12,630 --> 01:13:14,190
占多数，那么你说我是新主人

1871
01:13:14,190 --> 01:13:16,200
，所以在这个例子中，如果说这个

1872
01:13:16,200 --> 01:13:20,910
人回来了，假设

1873
01:13:20,910 --> 01:13:21,810


1874
01:13:21,810 --> 01:13:24,500
如果这个人被允许做出改变，看起来这个人，

1875
01:13:24,500 --> 01:13:27,180
因为它有一个因素是

1876
01:13:27,180 --> 01:13:29,970
足够了，当我回来时，我将

1877
01:13:29,970 --> 01:13:31,470
不得不让一个新人进来并

1878
01:13:31,470 --> 01:13:33,150
解决这个变化，我们不能神奇

1879
01:13:33,150 --> 01:13:37,230
地在我们的系统中做到这一点，在这种

1880
01:13:37,230 --> 01:13:38,910
情况下，我们再次停止了世界，

1881
01:13:38,910 --> 01:13:41,010
我们离线，直到有人进来 nd

1882
01:13:41,010 --> 01:13:59,070
修复我们是的正确所以他的冷静是

1883
01:13:59,070 --> 01:14:01,050
如果

1884
01:14:01,050 --> 01:14:03,240
你的安全系数是鼻子

1885
01:14:03,240 --> 01:14:05,550
加一的一半，我如何避免裂脑，这意味着至少你

1886
01:14:05,550 --> 01:14:08,640
总是保证有是的，只有

1887
01:14:08,640 --> 01:14:11,940
一侧可能是 成为大师

1888
01:14:11,940 --> 01:14:15,180
而另一个人失败了是的，就是这样

1889
01:14:15,180 --> 01:14:20,220
，没有什么神奇的权利，所以再次

1890
01:14:20,220 --> 01:14:23,610
回到他们世界中的反安慰剂家伙们，

1891
01:14:23,610 --> 01:14:25,500
他们正在

1892
01:14:25,500 --> 01:14:27,000
处理传统上处理

1893
01:14:27,000 --> 01:14:28,950
您想要在线的类似网站

1894
01:14:28,950 --> 01:14:32,280
24/7 所以在他们的世界中，他们

1895
01:14:32,280 --> 01:14:34,170
宁愿让系统可用并

1896
01:14:34,170 --> 01:14:35,870
仍然提供请求，

1897
01:14:35,870 --> 01:14:37,860
尽管他们可能在那里他们

1898
01:14:37,860 --> 01:14:39,449
在获得所有更改方面略有错误或延迟，

1899
01:14:39,449 --> 01:14:41,489
但这比完全在线要好，

1900
01:14:41,489 --> 01:14:43,980
如果你是

1901
01:14:43,980 --> 01:14:45,660
处理金钱，你不能你

1902
01:14:45,660 --> 01:14:47,010
不想要我的我不想给

1903
01:14:47,010 --> 01:14:49,380
你一百万美元给你，我

1904
01:14:49,380 --> 01:14:50,790
没有，再

1905
01:14:50,790 --> 01:14:51,900
一次听到你的一百万美元，因为我有

1906
01:14:51,900 --> 01:14:53,699
分裂 大脑在他们的角色中，他们不能

1907
01:14:53,699 --> 01:14:54,960
有那个 发生了所以他们宁愿

1908
01:14:54,960 --> 01:14:57,510
把整个事情都拿下来 所以我不是说

1909
01:14:57,510 --> 01:14:59,699
一个比另一个更好 我是说

1910
01:14:59,699 --> 01:15:01,020
对于某些应用场景，

1911
01:15:01,020 --> 01:15:06,510
一个更可取，但它只是

1912
01:15:06,510 --> 01:15:08,070
一种很好的理解，就像当你

1913
01:15:08,070 --> 01:15:09,390
开始设计时你应该 数据系统

1914
01:15:09,390 --> 01:15:12,830
你实际上做了什么权衡，

1915
01:15:14,449 --> 01:15:18,540
所以让我们快速完成

1916
01:15:18,540 --> 01:15:20,310
关于联合戴维斯的问题 所以上限

1917
01:15:20,310 --> 01:15:22,980
定理再次包括它在

1918
01:15:22,980 --> 01:15:26,510
2000 年代后期是正确的，

1919
01:15:26,510 --> 01:15:28,620
如果你去谷歌搜索像

1920
01:15:28,620 --> 01:15:30,090
被打败的猫这样的短语 定理 有很多

1921
01:15:30,090 --> 01:15:32,190
人疯狂地声称

1922
01:15:32,190 --> 01:15:33,449
他们的数据库是如何被打败的 上限

1923
01:15:33,449 --> 01:15:35,610
定理 他们现在被认为

1924
01:15:35,610 --> 01:15:38,699
是愚蠢的，第二次你不能拥有

1925
01:15:38,699 --> 01:15:39,570
它 你应该成为你可以

1926
01:15:39,570 --> 01:15:40,440
在你的视频中拥有的数据库，它可以做你所做的

1927
01:15:40,440 --> 01:15:43,920
一切 可以做一些额外的事情来尝试

1928
01:15:43,920 --> 01:15:46,380


1929
01:15:46,380 --> 01:15:48,210
通过让

1930
01:15:48,210 --> 01:15:50,489
这些你知道机器知道的各种这些你知道

1931
01:15:50,489 --> 01:15:52,199
的东西和类似的事情来减轻你会遇到的瓶颈问题，

1932
01:15:52,199 --> 01:15:55,949
这样你就可以了 你知道

1933
01:15:55,949 --> 01:15:57,810
减少网络分区

1934
01:15:57,810 --> 01:15:59,489
或类似问题的可能性，但

1935
01:15:59,489 --> 01:16:01,350
最终它们在某些时候是不可避免的，

1936
01:16:01,350 --> 01:16:02,250
你会用完钱，或者

1937
01:16:02,250 --> 01:16:03,719
它的主义会让你变慢，你

1938
01:16:03,719 --> 01:16:05,040
会 你会被

1939
01:16:05,040 --> 01:16:07,100
它所吸引，

1940
01:16:07,100 --> 01:16:08,880
所以让我们

1941
01:16:08,880 --> 01:16:12,840
快速完成所以我只想简单地

1942
01:16:12,840 --> 01:16:14,850
提一下联邦数据库是什么，

1943
01:16:14,850 --> 01:16:16,500
这样如果你看到或

1944
01:16:16,500 --> 01:16:18,960
考虑构建一个你就知道

1945
01:16:18,960 --> 01:16:22,500
它是什么 到目前为止，你所知道的所有这些

1946
01:16:22,500 --> 01:16:23,580
致敬戴维斯的事情

1947
01:16:23,580 --> 01:16:26,580
我们都假设所有节点都在

1948
01:16:26,580 --> 01:16:28,410
运行完全相同的数据库系统

1949
01:16:28,410 --> 01:16:30,870
软件就在这里，这是我的手机

1950
01:16:30,870 --> 01:16:32,280
只是翻录了我的 C 代码

1951
01:16:32,280 --> 01:16:33,660
版本的蟑螂电视版本 或者

1952
01:16:33,660 --> 01:16:36,660
别的什么，但有时在某些系统

1953
01:16:36,660 --> 01:16:39,000
和大型组织中，您有

1954
01:16:39,000 --> 01:16:40,949
这些一次性应用程序

1955
01:16:40,949 --> 01:16:43,410
正在使用您知道这种数据库

1956
01:16:43,410 --> 01:16:44,699
系统，然后是其他应用程序

1957
01:16:44,699 --> 01:16:46,290
使用这种其他类型的数据系统，

1958
01:16:46,290 --> 01:16:48,330
他们需要 一种处理所有事务的方法 对

1959
01:16:48,330 --> 01:16:49,440
所有事务

1960
01:16:49,440 --> 01:16:51,480
进行查询，因此它们

1961
01:16:51,480 --> 01:16:53,160
显示为单个数据库实例，

1962
01:16:53,160 --> 01:16:54,900
即使在幕后，

1963
01:16:54,900 --> 01:16:56,820
它们正在快速运行不同的

1964
01:16:56,820 --> 01:16:59,670
软件，因此这就是联邦

1965
01:16:59,670 --> 01:17:02,699
基础旨在

1966
01:17:02,699 --> 01:17:05,010
解决的问题 我们的想法是我们提供一个

1967
01:17:05,010 --> 01:17:07,590
单一的逻辑数据库实例，我们

1968
01:17:07,590 --> 01:17:10,110
知道如何获取拥有

1969
01:17:10,110 --> 01:17:11,850
该单个数据库实例的单个查询并将

1970
01:17:11,850 --> 01:17:14,640
其分解为计划片段，

1971
01:17:14,640 --> 01:17:16,380
然后我们可以在不同的机器上执行这些片段，

1972
01:17:16,380 --> 01:17:18,449
并且我们有一种排序方法

1973
01:17:18,449 --> 01:17:20,580
将它们全部重新组合在一起，所以这

1974
01:17:20,580 --> 01:17:23,330
在 1980 年代末 1990 年代初是一件大事，

1975
01:17:23,330 --> 01:17:25,830
因为公司和组织变得

1976
01:17:25,830 --> 01:17:26,969
更大，并且有更多的数据库

1977
01:17:26,969 --> 01:17:29,280
部署，您认为

1978
01:17:29,280 --> 01:17:30,630
我们为所有数据库提供一个单一的界面

1979
01:17:30,630 --> 01:17:33,719
会不会很棒 成功，因为您

1980
01:17:33,719 --> 01:17:35,550
最终要设计一个系统，该系统与

1981
01:17:35,550 --> 01:17:36,570


1982
01:17:36,570 --> 01:17:38,310
所有系统的最小公分母有关，

1983
01:17:38,310 --> 01:17:39,600
好吧，这个系统不执行

1984
01:17:39,600 --> 01:17:40,949
事务或执行此操作 esn不做这些

1985
01:17:40,949 --> 01:17:42,390
类型的查询，所以我们不能对

1986
01:17:42,390 --> 01:17:44,790
其他系统这样做，所以人们再次

1987
01:17:44,790 --> 01:17:50,430
尝试这个人仍然尝试这个

1988
01:17:50,430 --> 01:17:51,960
通常是一个坏主意它不会

1989
01:17:51,960 --> 01:17:54,330
结束你做简单的事情但你知道

1990
01:17:54,330 --> 01:17:56,820
拥有它是美丽的 所有在一个

1991
01:17:56,820 --> 01:17:58,140
联合数据库中它不会工作

1992
01:17:58,140 --> 01:18:00,390
所以再次像这样的基本想法你有

1993
01:18:00,390 --> 01:18:01,710
你的应用程序服务器你有你的

1994
01:18:01,710 --> 01:18:03,150
中间件系统和你的

1995
01:18:03,150 --> 01:18:05,370
独立数据库所以单个查询进入

1996
01:18:05,370 --> 01:18:07,230
中间件然后它识别

1997
01:18:07,230 --> 01:18:08,520
所有这些不同的系统实际上可以

1998
01:18:08,520 --> 01:18:10,890
支持，所以它重写

1999
01:18:10,890 --> 01:18:12,060
了你想在这些不同机器上运行的查询部分，

2000
01:18:12,060 --> 01:18:13,410
以获得不同的

2001
01:18:13,410 --> 01:18:16,430
api，所以我的续集做续集

2002
01:18:16,430 --> 01:18:20,850
MongoDB 做 JSON 查询 Redis

2003
01:18:20,850 --> 01:18:22,440
在地铁里做自己的事情，

2004
01:18:22,440 --> 01:18:24,420
所以它知道如何采取 所有

2005
01:18:24,420 --> 01:18:26,790
这些查询都将其分解并在

2006
01:18:26,790 --> 01:18:28,500
那些单独的机器上运行，然后您会

2007
01:18:28,500 --> 01:18:30,510
得到结果，因此这些东西

2008
01:18:30,510 --> 01:18:32,550
通常是调用连接器，就像它们

2009
01:18:32,550 --> 01:18:34,110
具有通信能力一样 使用这些

2010
01:18:34,110 --> 01:18:35,460
不同的数据库并将它们

2011
01:18:35,460 --> 01:18:39,150
拉到单个系统中

2012
01:18:39,150 --> 01:18:42,030
Pike 最适合做

2013
01:18:42,030 --> 01:18:43,620
联合数据库架构的一个数据库

2014
01:18:43,620 --> 01:18:47,010
实际上是 Postgres 所以 Postgres 有

2015
01:18:47,010 --> 01:18:48,239
一个叫做外部数据包装器的东西

2016
01:18:48,239 --> 01:18:51,120
认为这就像一个 api 哦 您

2017
01:18:51,120 --> 01:18:52,860
可以插入

2018
01:18:52,860 --> 01:18:55,370
普通 Postgres 存储之外的不同数据源，

2019
01:18:55,370 --> 01:18:57,510
因此

2020
01:18:57,510 --> 01:18:59,370
您知道 Mongo 和所有其他系统的外部数据包装器，

2021
01:18:59,370 --> 01:19:00,989


2022
01:19:00,989 --> 01:19:02,760
因此我将所有后续查询

2023
01:19:02,760 --> 01:19:03,300


2024
01:19:03,300 --> 01:19:05,310
写入 Postgres，然后是外部数据

2025
01:19:05,310 --> 01:19:06,630
包装器新闻如何 去这些

2026
01:19:06,630 --> 01:19:09,210
单独的系统并吸收

2027
01:19:09,210 --> 01:19:13,620
我认为非常酷的数据，所以

2028
01:19:13,620 --> 01:19:17,130
对我们任何人的任何问题，正如我所说

2029
01:19:17,130 --> 01:19:19,370
的那样，蝙蝠

2030
01:19:23,180 --> 01:19:24,870
好吧严肃的问题是我可以

2031
01:19:24,870 --> 01:19:27,150
推荐任何分布式 OLAP 或 OLTP

2032
01:19:27,150 --> 01:19:30,870
系统哦，让我们接受这个 离线，

2033
01:19:30,870 --> 01:19:31,920
因为这是一个复杂的问题，这

2034
01:19:31,920 --> 01:19:33,540
取决于您要尝试做

2035
01:19:33,540 --> 01:19:35,130
什么 您的数据是什么样的

2036
01:19:35,130 --> 01:19:38,070
您有多少数据 您是否想要续集

2037
01:19:38,070 --> 01:19:49,910
？  equel 为什么我的意思是

2038
01:19:49,910 --> 01:19:53,160
你看到 DVD 死了 哦有 680 到

2039
01:19:53,160 --> 01:19:55,620
大约 260 无论如何，不会

2040
01:19:55,620 --> 01:19:58,140
有这样一个神奇的东西，就像解决

2041
01:19:58,140 --> 01:19:59,940
世界上所有问题一样，你必须

2042
01:19:59,940 --> 01:20:01,200
查看你的应用程序要求

2043
01:20:01,200 --> 01:20:02,940
，最终对你的内容做出妥协

2044
01:20:02,940 --> 01:20:04,230
知道你需要什么功能你不需要什么

2045
01:20:04,230 --> 01:20:06,240
功能

2046
01:20:06,240 --> 01:20:14,550
你会花多少钱所以让我们介绍一下这个

2047
01:20:14,550 --> 01:20:16,740
网络类是一个流行的视频系统

2048
01:20:16,740 --> 01:20:18,720
将在x级出现一些流行的

2049
01:20:18,720 --> 01:20:22,860
分销商ltp系统所以所有

2050
01:20:22,860 --> 01:20:25,830
主要供应商都会续集 服务器 db2 和

2051
01:20:25,830 --> 01:20:26,760
Oracle

2052
01:20:26,760 --> 01:20:28,440
他们都有自己的分布式

2053
01:20:28,440 --> 01:20:30,420
系统，好吧，还有一些新的初创公司，

2054
01:20:30,420 --> 01:20:34,700
比如 cockroach Tidy be Yoga 购买 fauna

2055
01:20:34,700 --> 01:20:37,950
Mongo 的分布式权利 他们都让

2056
01:20:37,950 --> 01:20:38,880
你知道他们都有不同

2057
01:20:38,880 --> 01:20:43,470
的权衡，很好地涵盖了我会列出

2058
01:20:43,470 --> 01:20:45,770
一些重叠的 subsonex 类 实际上

2059
01:20:45,770 --> 01:20:47,820
让我们谈谈 让我们离线谈谈 也许

2060
01:20:47,820 --> 01:20:48,570


2061
01:20:48,570 --> 01:20:50,810
在最后一堂课的百花香中有你的一些

2062
01:20:50,810 --> 01:20:53,010
掩饰 所以我从一开始就看到的主要内容

2063
01:20:53,010 --> 01:20:54,770
是 我们假设

2064
01:20:54,770 --> 01:20:56,850
我们系统中的所有数据库节点都是

2065
01:20:56,850 --> 01:20:58,680
友好的，如果它们不友好，那么

2066
01:20:58,680 --> 01:21:00,090
我们如何进行提交、事务和

2067
01:21:00,090 --> 01:21:01,920
复制的生活就会变得更轻松，那么

2068
01:21:01,920 --> 01:21:04,140
这就是区块链，

2069
01:21:04,140 --> 01:21:05,520
如果他们这样做，则投影有效，以

2070
01:21:05,520 --> 01:21:07,800
证明当我们 说提交交易，我们

2071
01:21:07,800 --> 01:21:09,000
想创建一个

2072
01:21:09,000 --> 01:21:10,170
每个人都实际提交交易的交易

2073
01:21:10,170 --> 01:21:12,480
，如果比特币是

2074
01:21:12,480 --> 01:21:13,800
他们对默克尔树所做的所有散列操作，

2075
01:21:13,800 --> 01:21:16,649
好吧，

2076
01:21:16,649 --> 01:21:18,329
所以下周星期一的

2077
01:21:18,329 --> 01:21:20,159
课程将是关于糖数据库的最后一课，

2078
01:21:20,159 --> 01:21:21,539
将涵盖 撕掉所有的应用程序

2079
01:21:21,539 --> 01:21:23,579
系统 我认为这

2080
01:21:23,579 --> 01:21:26,809
将是本学期材料

2081
01:21:26,809 --> 01:21:30,090
的结尾，当

2082
01:21:30,090 --> 01:21:31,320
我们感恩节后回来时，这将

2083
01:21:31,320 --> 01:21:32,909
是 Oracle 的客座讲座，

2084
01:21:32,909 --> 01:21:34,349
然后是系统杂烩 在最后的

2085
01:21:34,349 --> 01:21:40,729
审查中 好的任何问题 好吧伙计们

2086
01:21:51,400 --> 01:21:54,479
[音乐]

2087
01:22:01,189 --> 01:22:03,499
跳弹果冻撞到熟食

2088
01:22:03,499 --> 01:22:13,169
自然不要填写只喝

2089
01:22:13,169 --> 01:22:16,739
两个你不能，如果水槽不知道

2090
01:22:16,739 --> 01:22:19,669
你的电话 可以点击一个

