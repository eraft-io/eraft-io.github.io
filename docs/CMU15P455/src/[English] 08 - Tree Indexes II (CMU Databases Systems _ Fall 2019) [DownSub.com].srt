1
00:00:03,640 --> 00:00:17,790
[Music]

2
00:00:17,790 --> 00:00:19,740
sloping I love it

3
00:00:19,740 --> 00:00:24,820
alright let's get started alright let's

4
00:00:24,820 --> 00:00:26,349
talk about let's let's get right into it

5
00:00:26,349 --> 00:00:26,860
again

6
00:00:26,860 --> 00:00:28,869
thanks for DG drop tables hold it down

7
00:00:28,869 --> 00:00:37,059
that was awesome Peggy how are you are

8
00:00:37,059 --> 00:00:38,110
you still having that police problems or

9
00:00:38,110 --> 00:00:42,040
everything okay do you need a good

10
00:00:42,040 --> 00:00:46,270
lawyer in town because I have one well

11
00:00:46,270 --> 00:00:47,710
my pc students got in trouble for legs

12
00:00:47,710 --> 00:00:50,290
leg whatever minor so we have somebody

13
00:00:50,290 --> 00:00:53,770
we can help you out okay no never

14
00:00:53,770 --> 00:00:56,590
okay good all right so let's let's how

15
00:00:56,590 --> 00:01:00,910
about David so real quickly the we have

16
00:01:00,910 --> 00:01:03,839
a talk today engaged May 4 at 4:30 p.m.

17
00:01:03,839 --> 00:01:06,820
so this is one of the head engineers

18
00:01:06,820 --> 00:01:08,950
from Vertica is come to give a talk so

19
00:01:08,950 --> 00:01:10,450
vertical I believe it not has a small

20
00:01:10,450 --> 00:01:12,579
development branch here in in Pittsburgh

21
00:01:12,579 --> 00:01:14,499
and so Steve is gonna come and talk

22
00:01:14,499 --> 00:01:15,340
about some of the things that they've

23
00:01:15,340 --> 00:01:18,340
been working on Vertica is a disk based

24
00:01:18,340 --> 00:01:20,530
distributed column store database you

25
00:01:20,530 --> 00:01:21,670
gots a bunch of words we've been thrown

26
00:01:21,670 --> 00:01:22,630
around throughout the entire semester

27
00:01:22,630 --> 00:01:24,999
but it means it runs multiple nodes it's

28
00:01:24,999 --> 00:01:27,219
a column store and it soon as the

29
00:01:27,219 --> 00:01:28,600
primary search location of the database

30
00:01:28,600 --> 00:01:30,759
is on disk so this is one of the it's

31
00:01:30,759 --> 00:01:32,889
not the it's one of the first column

32
00:01:32,889 --> 00:01:34,420
stores that came out in the mid-2000s

33
00:01:34,420 --> 00:01:38,020
that sort of that began the wave of

34
00:01:38,020 --> 00:01:40,240
column store dead business so comstor

35
00:01:40,240 --> 00:01:41,880
databases aren't really that rare now

36
00:01:41,880 --> 00:01:44,139
but back in it back when Berger came out

37
00:01:44,139 --> 00:01:47,770
in 2006 ish that was considered a that

38
00:01:47,770 --> 00:01:48,819
was a sort of a major tech not

39
00:01:48,819 --> 00:01:51,909
technological breakthrough so Stephens

40
00:01:51,909 --> 00:01:54,609
good guy if you want to talk about the

41
00:01:54,609 --> 00:01:55,420
kind of things that they're working on

42
00:01:55,420 --> 00:01:56,829
and for that one that'll be fruit

43
00:01:56,829 --> 00:01:58,029
they're not pizza

44
00:01:58,029 --> 00:02:01,179
so again plan accordingly all right so

45
00:02:01,179 --> 00:02:04,119
today we want to continue our discussion

46
00:02:04,119 --> 00:02:06,700
on talking about tree indexes so I want

47
00:02:06,700 --> 00:02:07,630
to spend a little bit time in the

48
00:02:07,630 --> 00:02:09,910
beginning doing some demos and

49
00:02:09,910 --> 00:02:11,830
discussing more about B plus trees to

50
00:02:11,830 --> 00:02:14,080
finish up the things that we we left out

51
00:02:14,080 --> 00:02:15,880
last class and then we'll talk about

52
00:02:15,880 --> 00:02:17,860
different ways we'll talk about more

53
00:02:17,860 --> 00:02:20,560
ways you can use indexes beyond the

54
00:02:20,560 --> 00:02:23,350
you know straight key mapped into a data

55
00:02:23,350 --> 00:02:24,310
structure that we've been talking about

56
00:02:24,310 --> 00:02:26,650
so far and then we'll talk about an

57
00:02:26,650 --> 00:02:30,040
alternative to B plus trees tries or

58
00:02:30,040 --> 00:02:32,350
radix trees and we're getting we'll go

59
00:02:32,350 --> 00:02:34,090
through what makes these unique what

60
00:02:34,090 --> 00:02:35,260
makes them different and how are they

61
00:02:35,260 --> 00:02:37,209
better or worse than B plus trees and

62
00:02:37,209 --> 00:02:39,010
then we'll finish up really quickly with

63
00:02:39,010 --> 00:02:42,130
a sort of a brain dump of inverted

64
00:02:42,130 --> 00:02:43,810
indexes I'm not going to teach you how

65
00:02:43,810 --> 00:02:46,000
they work we have courses here at CMU if

66
00:02:46,000 --> 00:02:47,620
I can do that this is just so you know

67
00:02:47,620 --> 00:02:49,480
that these things actually exist so when

68
00:02:49,480 --> 00:02:50,740
you go out in the real world and you

69
00:02:50,740 --> 00:02:52,000
realize that the thing you want to index

70
00:02:52,000 --> 00:02:54,340
can't be indexed in a B+ tree you want

71
00:02:54,340 --> 00:02:57,160
to use one of these inverted indexes all

72
00:02:57,160 --> 00:03:01,330
right so the the last class we had a

73
00:03:01,330 --> 00:03:02,709
couple questions about how do we

74
00:03:02,709 --> 00:03:04,870
actually going to handle duplicate keys

75
00:03:04,870 --> 00:03:07,270
in our B+ tree index so I showed you how

76
00:03:07,270 --> 00:03:09,190
we would handle duplicate keys inside of

77
00:03:09,190 --> 00:03:11,680
the node right we could have we could

78
00:03:11,680 --> 00:03:13,209
duplicate the values in the node and

79
00:03:13,209 --> 00:03:15,970
then or just have a mapping from a key

80
00:03:15,970 --> 00:03:18,430
to a valueless inside the node so now I

81
00:03:18,430 --> 00:03:20,110
want to talk about a data what I

82
00:03:20,110 --> 00:03:22,180
realized I missed out was discussing at

83
00:03:22,180 --> 00:03:24,580
a higher level actually within the tree

84
00:03:24,580 --> 00:03:27,040
itself how do we gonna actually maintain

85
00:03:27,040 --> 00:03:28,600
these duplicate indexes or duplicate

86
00:03:28,600 --> 00:03:30,850
keys so there's two approaches to do

87
00:03:30,850 --> 00:03:35,140
this so the first is that we're gonna

88
00:03:35,140 --> 00:03:38,410
make every key unique automatically by

89
00:03:38,410 --> 00:03:42,070
appending the the corresponding tuples

90
00:03:42,070 --> 00:03:44,200
record ID to the key that we're

91
00:03:44,200 --> 00:03:47,140
inserting into the index so instead of

92
00:03:47,140 --> 00:03:48,459
destroying the keeping of the copy of

93
00:03:48,459 --> 00:03:50,590
the attribute that's in the table I'm

94
00:03:50,590 --> 00:03:52,600
also gonna prefix or sorry put at the

95
00:03:52,600 --> 00:03:55,510
end as a suffix the record ID for that

96
00:03:55,510 --> 00:03:59,170
tuple so now that makes every single key

97
00:03:59,170 --> 00:04:02,739
automatically unique so the reason why

98
00:04:02,739 --> 00:04:04,180
we can do this in this still works is

99
00:04:04,180 --> 00:04:07,000
because we're using a B+ tree memorize

100
00:04:07,000 --> 00:04:08,440
said it would be plus tree we can do

101
00:04:08,440 --> 00:04:11,380
partial key lookups and and still find

102
00:04:11,380 --> 00:04:13,209
the things that we want so if I if I

103
00:04:13,209 --> 00:04:14,799
have an attribute an index one

104
00:04:14,799 --> 00:04:16,720
attributes a and B if I want to do a

105
00:04:16,720 --> 00:04:18,488
look upon a I can still do that without

106
00:04:18,488 --> 00:04:21,820
having B so in our case in the B plus

107
00:04:21,820 --> 00:04:22,960
tree because we're not gonna have the

108
00:04:22,960 --> 00:04:25,720
record ID we can just do the regular

109
00:04:25,720 --> 00:04:27,460
lookup we as we would with it with a key

110
00:04:27,460 --> 00:04:29,380
but we just scan along the leaf nodes do

111
00:04:29,380 --> 00:04:31,870
we find all the matches for that given

112
00:04:31,870 --> 00:04:33,340
key you can

113
00:04:33,340 --> 00:04:34,900
do this in a hash table right for the

114
00:04:34,900 --> 00:04:36,190
hash table you have to have the entire

115
00:04:36,190 --> 00:04:39,940
key so in order to do this approach you

116
00:04:39,940 --> 00:04:42,250
have to have the when you do a lookup

117
00:04:42,250 --> 00:04:44,020
the key you want and then the record a

118
00:04:44,020 --> 00:04:46,840
is the record IDs they correspond to but

119
00:04:46,840 --> 00:04:48,130
that seems stupid because if you had the

120
00:04:48,130 --> 00:04:49,540
record IDs why would use an index a

121
00:04:49,540 --> 00:04:58,060
lookup the record IDs yes so these

122
00:04:58,060 --> 00:04:59,979
questions what is what is this record ID

123
00:04:59,979 --> 00:05:02,530
it's the page ID and all set we talked

124
00:05:02,530 --> 00:05:04,870
about in the very beginning right that's

125
00:05:04,870 --> 00:05:06,520
the unique identifier for every physical

126
00:05:06,520 --> 00:05:08,740
location of a tuple now it may change

127
00:05:08,740 --> 00:05:10,479
and therefore that we have to deal with

128
00:05:10,479 --> 00:05:14,290
that and Postgres is most famously the

129
00:05:14,290 --> 00:05:15,700
one that what this won't work because

130
00:05:15,700 --> 00:05:18,160
they can move things around but when we

131
00:05:18,160 --> 00:05:20,139
tell about multi versioning we'll see

132
00:05:20,139 --> 00:05:21,490
different examples of why this works

133
00:05:21,490 --> 00:05:22,720
from post but it doesn't work replace

134
00:05:22,720 --> 00:05:24,400
graphs with arcs or other systems but

135
00:05:24,400 --> 00:05:25,960
this assume it's a page 18 offset or

136
00:05:25,960 --> 00:05:27,520
indicates a sequel server an Oracle it

137
00:05:27,520 --> 00:05:29,320
was like file number object number of

138
00:05:29,320 --> 00:05:30,820
page ID and all set like a more complex

139
00:05:30,820 --> 00:05:35,320
thing the other approach is to somewhat

140
00:05:35,320 --> 00:05:39,280
violate the sanctity if you will of the

141
00:05:39,280 --> 00:05:42,780
design of the B+ tree and actually store

142
00:05:42,780 --> 00:05:45,550
the duplicate keys as overflow leaf

143
00:05:45,550 --> 00:05:48,280
nodes so instead of expanding the leaf

144
00:05:48,280 --> 00:05:50,380
nodes horizontally to accommodate new

145
00:05:50,380 --> 00:05:52,360
entries we're actually gonna ban them

146
00:05:52,360 --> 00:05:54,310
vertically or then what for then a given

147
00:05:54,310 --> 00:05:56,050
leaf node will add these overflow pages

148
00:05:56,050 --> 00:05:57,789
almost like the chain hash table we

149
00:05:57,789 --> 00:05:59,380
talked about before and is add all the

150
00:05:59,380 --> 00:06:02,349
trippity he's down there so as well see

151
00:06:02,349 --> 00:06:04,000
in a second I'll again provide over use

152
00:06:04,000 --> 00:06:04,780
what this looks like

153
00:06:04,780 --> 00:06:07,090
this approach is gonna be more complex

154
00:06:07,090 --> 00:06:09,970
because now we have to handle the case

155
00:06:09,970 --> 00:06:11,080
of where I'm skinning along my leaf

156
00:06:11,080 --> 00:06:12,570
nodes I have to know how to follow those

157
00:06:12,570 --> 00:06:15,190
you know follow down the overflow pages

158
00:06:15,190 --> 00:06:17,139
if I'm skinning reverse direction you

159
00:06:17,139 --> 00:06:19,419
know what where do I start my scan when

160
00:06:19,419 --> 00:06:20,620
I jump back in the other direction

161
00:06:20,620 --> 00:06:25,270
so most people implement this one this

162
00:06:25,270 --> 00:06:26,500
has the advantage that again we don't

163
00:06:26,500 --> 00:06:28,030
want to make any major changes to our

164
00:06:28,030 --> 00:06:29,440
data structure whether it's a unique

165
00:06:29,440 --> 00:06:31,450
versus not unique index everything just

166
00:06:31,450 --> 00:06:32,410
still works the same

167
00:06:32,410 --> 00:06:34,210
the downside is now we're actually

168
00:06:34,210 --> 00:06:35,590
storing there's record ID as an

169
00:06:35,590 --> 00:06:37,570
additional key element of our key and

170
00:06:37,570 --> 00:06:40,270
that increases the size of our of our

171
00:06:40,270 --> 00:06:42,310
index you know the amount of data it

172
00:06:42,310 --> 00:06:43,870
takes to actually store the index with

173
00:06:43,870 --> 00:06:45,640
this case here we're not storing any

174
00:06:45,640 --> 00:06:47,110
redundant information unnecessary

175
00:06:47,110 --> 00:06:49,960
early to make things unique but now we

176
00:06:49,960 --> 00:06:52,480
have this management issue so let's go

177
00:06:52,480 --> 00:06:54,870
through both them so this is our simple

178
00:06:54,870 --> 00:06:56,950
B+ tree that we talked about before and

179
00:06:56,950 --> 00:06:59,410
so the first approach is again depend

180
00:06:59,410 --> 00:07:01,330
the record ID so either I'm showing just

181
00:07:01,330 --> 00:07:02,800
like the key value assume there's an

182
00:07:02,800 --> 00:07:04,540
adjuvant a and here's all the values for

183
00:07:04,540 --> 00:07:04,870
them

184
00:07:04,870 --> 00:07:06,910
in actuality what the database system is

185
00:07:06,910 --> 00:07:09,610
actually storing is a combination of the

186
00:07:09,610 --> 00:07:14,290
key and then that record ID so now when

187
00:07:14,290 --> 00:07:15,880
I do a lookup and say I want to cert key

188
00:07:15,880 --> 00:07:18,820
key six I would in this point here I can

189
00:07:18,820 --> 00:07:22,060
do a prefix search in my in my B+ tree

190
00:07:22,060 --> 00:07:24,160
because I don't have a record ID as I'm

191
00:07:24,160 --> 00:07:25,600
inserting this why should I take it back

192
00:07:25,600 --> 00:07:27,220
you do have a record ID but I'm not

193
00:07:27,220 --> 00:07:29,290
gonna find an exact match for that so I

194
00:07:29,290 --> 00:07:30,790
would Traverse down here and I would

195
00:07:30,790 --> 00:07:33,760
land at this page the real I mean the

196
00:07:33,760 --> 00:07:35,830
real thing I'm starting is the page 18

197
00:07:35,830 --> 00:07:36,940
upset but I land here

198
00:07:36,940 --> 00:07:39,430
and now I know I want to go into this

199
00:07:39,430 --> 00:07:43,360
page so because now I don't have

200
00:07:43,360 --> 00:07:45,460
overflow pages I have to go exactly in

201
00:07:45,460 --> 00:07:46,780
sorted order so assume whatever this

202
00:07:46,780 --> 00:07:49,510
original six is its record ID is less

203
00:07:49,510 --> 00:07:51,400
than the one I'm inserting so it needs

204
00:07:51,400 --> 00:07:53,140
to go between the six and seven so I

205
00:07:53,140 --> 00:07:54,880
just do the normal split process that we

206
00:07:54,880 --> 00:07:56,590
talked about before I slide everybody

207
00:07:56,590 --> 00:07:58,870
over seven and eight move here and now I

208
00:07:58,870 --> 00:08:01,450
can I can update pointers and house six

209
00:08:01,450 --> 00:08:04,150
goes in here right it's just works

210
00:08:04,150 --> 00:08:05,500
exactly the same that we talked about

211
00:08:05,500 --> 00:08:07,690
before so I'm gonna do a lookup alone

212
00:08:07,690 --> 00:08:09,690
six again I just do the prefix search I

213
00:08:09,690 --> 00:08:12,310
do the just look at the first element of

214
00:08:12,310 --> 00:08:14,290
the key just the six and I can find down

215
00:08:14,290 --> 00:08:15,970
here now I scan along my leaf-nosed to I

216
00:08:15,970 --> 00:08:20,590
find them what I want the other approach

217
00:08:20,590 --> 00:08:23,350
is the overflow pages so now again I

218
00:08:23,350 --> 00:08:25,330
want to start six again I know I want to

219
00:08:25,330 --> 00:08:27,310
go into this guy I can't I don't want to

220
00:08:27,310 --> 00:08:29,800
split across right I want to I don't do

221
00:08:29,800 --> 00:08:30,880
what I did before I have seven eight

222
00:08:30,880 --> 00:08:32,950
move over I want to go in this page here

223
00:08:32,950 --> 00:08:35,830
but I can't because it's full so I just

224
00:08:35,830 --> 00:08:38,320
add now an overflow page where I insert

225
00:08:38,320 --> 00:08:41,020
my new six and now I have my pointer

226
00:08:41,020 --> 00:08:43,809
down to it now remember I said before

227
00:08:43,809 --> 00:08:46,030
that that in in most textbook

228
00:08:46,030 --> 00:08:49,600
definitions of a B+ tree you assume that

229
00:08:49,600 --> 00:08:51,190
the keys are always gonna be in sorted

230
00:08:51,190 --> 00:08:53,350
within the node in this case here we

231
00:08:53,350 --> 00:08:56,280
could do that we could sort them but

232
00:08:56,280 --> 00:08:58,780
it's not actually wrong just to leave it

233
00:08:58,780 --> 00:09:01,000
unsorted we just need to know when word

234
00:09:01,000 --> 00:09:01,840
looking for the element we're looking

235
00:09:01,840 --> 00:09:03,250
for we can't use binary search to jump

236
00:09:03,250 --> 00:09:04,960
around we have to do the linear search

237
00:09:04,960 --> 00:09:07,870
to find that we want so now let's say I

238
00:09:07,870 --> 00:09:09,760
want to search seven same things seven

239
00:09:09,760 --> 00:09:10,540
goes down there

240
00:09:10,540 --> 00:09:12,670
I insert six same thing six goes here

241
00:09:12,670 --> 00:09:14,310
it's it's on order and that's okay

242
00:09:14,310 --> 00:09:16,540
so now here's what needs to happen so

243
00:09:16,540 --> 00:09:18,220
physically this is stored across

244
00:09:18,220 --> 00:09:20,590
multiple pages logically from the index

245
00:09:20,590 --> 00:09:22,690
perspective this just looks like one

246
00:09:22,690 --> 00:09:24,510
giant leaf note that has the month in it

247
00:09:24,510 --> 00:09:27,370
so now if I'm scanning across I do the

248
00:09:27,370 --> 00:09:28,840
same thing I follow this pointer I land

249
00:09:28,840 --> 00:09:30,370
here and now if I'm scanning across

250
00:09:30,370 --> 00:09:32,050
instead of jumping over to this node I

251
00:09:32,050 --> 00:09:33,760
no need to follow my overflow page you

252
00:09:33,760 --> 00:09:35,770
keep looking there and eventually if I

253
00:09:35,770 --> 00:09:37,090
find what I'm looking for I'm done if

254
00:09:37,090 --> 00:09:38,800
not I need to go to the next page then I

255
00:09:38,800 --> 00:09:41,560
just follow that pointer over there so

256
00:09:41,560 --> 00:09:42,790
now I may be thinking why not just have

257
00:09:42,790 --> 00:09:44,560
this guy should' this guy really be

258
00:09:44,560 --> 00:09:46,750
pointing to that one right because that

259
00:09:46,750 --> 00:09:48,700
would actually be correct but now the

260
00:09:48,700 --> 00:09:50,140
problem is every single time I add a new

261
00:09:50,140 --> 00:09:52,060
overflow page now only do I need to

262
00:09:52,060 --> 00:09:54,310
update you know my pointers internally

263
00:09:54,310 --> 00:09:56,290
for these two note these nodes over here

264
00:09:56,290 --> 00:09:58,350
I now need to go update this one as well

265
00:09:58,350 --> 00:10:00,670
but if I just leave that pointer alone

266
00:10:00,670 --> 00:10:02,500
and let it point to the beginning of my

267
00:10:02,500 --> 00:10:04,930
page the topmost leaf node in this

268
00:10:04,930 --> 00:10:07,450
vertical tower then I would just land

269
00:10:07,450 --> 00:10:08,860
there and say oh well I'm going over

270
00:10:08,860 --> 00:10:10,300
search I really need to jump to the end

271
00:10:10,300 --> 00:10:12,750
of my overflow page and work backwards

272
00:10:12,750 --> 00:10:15,460
there's much extra logic we have to do

273
00:10:15,460 --> 00:10:17,790
to accommodate this yes

274
00:10:17,790 --> 00:10:21,370
so I said sorry you haven't reviewed

275
00:10:21,370 --> 00:10:41,470
what sorry oh every doubt okay so this

276
00:10:41,470 --> 00:10:44,380
question is if someone if the data

277
00:10:44,380 --> 00:10:46,870
systems using the index and we're trying

278
00:10:46,870 --> 00:10:48,850
to find the tuples that have the value

279
00:10:48,850 --> 00:10:51,970
six for this particular key so what is

280
00:10:51,970 --> 00:10:54,520
the index returning well if we turn the

281
00:10:54,520 --> 00:10:57,670
record id's so you would say you

282
00:10:57,670 --> 00:10:59,530
basically have an iterator I traverse

283
00:10:59,530 --> 00:11:01,000
down and get to my leaf node and now I'm

284
00:11:01,000 --> 00:11:02,140
looking calling next next next on this

285
00:11:02,140 --> 00:11:03,580
iterator and I'm looking at every single

286
00:11:03,580 --> 00:11:05,140
element until I find the ones that I

287
00:11:05,140 --> 00:11:06,850
want and I new iterator knows to stop

288
00:11:06,850 --> 00:11:08,440
what says I'm looking for everything

289
00:11:08,440 --> 00:11:11,320
that where key equals six so soon as I

290
00:11:11,320 --> 00:11:12,850
see maybe a nine over here I need to

291
00:11:12,850 --> 00:11:14,010
stop

292
00:11:14,010 --> 00:11:15,870
but this what I'm saying if you know if

293
00:11:15,870 --> 00:11:17,910
this is unsorted then I know I need to

294
00:11:17,910 --> 00:11:19,680
scan to the end of all my overflow pages

295
00:11:19,680 --> 00:11:21,570
because I if this the last six might be

296
00:11:21,570 --> 00:11:24,810
here if I want to keep them sorted then

297
00:11:24,810 --> 00:11:26,760
you know now I'm certain this six here

298
00:11:26,760 --> 00:11:28,890
now I got to go update this guy and this

299
00:11:28,890 --> 00:11:30,900
guy whereas before if I disappear only

300
00:11:30,900 --> 00:11:35,550
its updating one page so this is a

301
00:11:35,550 --> 00:11:39,570
really good example of why you know why

302
00:11:39,570 --> 00:11:40,830
trying to understand these data

303
00:11:40,830 --> 00:11:42,480
structures in the context of a real full

304
00:11:42,480 --> 00:11:44,160
system is important you take an

305
00:11:44,160 --> 00:11:45,360
algorithms class an algorithms class

306
00:11:45,360 --> 00:11:46,650
will teach you yes this is the way to

307
00:11:46,650 --> 00:11:49,170
start a B+ tree but now because we're

308
00:11:49,170 --> 00:11:50,940
inside of a database system we know we

309
00:11:50,940 --> 00:11:52,410
have these things called record IDs and

310
00:11:52,410 --> 00:11:54,780
we can exploit them to make to

311
00:11:54,780 --> 00:11:56,190
facilitate different aspects or

312
00:11:56,190 --> 00:11:57,450
different operations that would not be

313
00:11:57,450 --> 00:12:03,860
otherwise easy to do yes correct

314
00:12:03,860 --> 00:12:05,910
if this thing overflows we just keep

315
00:12:05,910 --> 00:12:10,860
continuing yes correct I think it says

316
00:12:10,860 --> 00:12:12,090
to a certain point you actually want

317
00:12:12,090 --> 00:12:15,330
rebalance so yes so that could be a

318
00:12:15,330 --> 00:12:16,890
criteria it says all right well if I go

319
00:12:16,890 --> 00:12:18,360
beyond this number of overflow pages

320
00:12:18,360 --> 00:12:20,610
then do a split but if these are all

321
00:12:20,610 --> 00:12:23,280
sixes right in a single page then you

322
00:12:23,280 --> 00:12:24,720
can't you can't quite you know easily do

323
00:12:24,720 --> 00:12:31,140
that without depending the record ID all

324
00:12:31,140 --> 00:12:33,840
right cool so let's do a demo because we

325
00:12:33,840 --> 00:12:35,610
didn't get to do this last time so we're

326
00:12:35,610 --> 00:12:38,250
gonna do Postgres and these want to show

327
00:12:38,250 --> 00:12:41,640
the difference between a B+ tree and a

328
00:12:41,640 --> 00:12:51,480
hash index all right turn this off all

329
00:12:51,480 --> 00:12:53,180
right cool and you're logging over here

330
00:12:53,180 --> 00:12:57,810
so I'm gonna have a table this live yeah

331
00:12:57,810 --> 00:12:59,910
okay so this is post rest I'm gonna have

332
00:12:59,910 --> 00:13:03,540
a table of email addresses so it's gonna

333
00:13:03,540 --> 00:13:07,110
be a simple a simple table with an ID

334
00:13:07,110 --> 00:13:08,880
with an auto increment key and then a

335
00:13:08,880 --> 00:13:10,740
bunch of email addresses so this is a

336
00:13:10,740 --> 00:13:14,070
file that you can find on the Internet

337
00:13:14,070 --> 00:13:16,680
this is a list of 27 million email

338
00:13:16,680 --> 00:13:19,290
addresses from if you don't know what

339
00:13:19,290 --> 00:13:23,610
that is it was a a think of like tinder

340
00:13:23,610 --> 00:13:25,410
before tinder that it was an adult

341
00:13:25,410 --> 00:13:27,360
hook-up site in Canada they got hacked

342
00:13:27,360 --> 00:13:29,360
and then eventually people release the

343
00:13:29,360 --> 00:13:33,180
email addresses so this is real it

344
00:13:33,180 --> 00:13:35,250
shouldn't take that long to load but I

345
00:13:35,250 --> 00:13:36,630
should do this before now but that's

346
00:13:36,630 --> 00:13:39,209
okay so what we're gonna do is we're

347
00:13:39,209 --> 00:13:40,589
gonna create two indexes we're gonna

348
00:13:40,589 --> 00:13:42,839
create a hash index so in Postgres you

349
00:13:42,839 --> 00:13:44,100
can actually just say well I want to

350
00:13:44,100 --> 00:13:45,839
create index I want it to be a hash

351
00:13:45,839 --> 00:13:49,320
index and then you can then say I want

352
00:13:49,320 --> 00:13:50,850
to create index and I want to be a B+

353
00:13:50,850 --> 00:13:52,890
tree index of course yeah

354
00:13:52,890 --> 00:13:55,250
well this is that a good demo right okay

355
00:13:55,250 --> 00:13:58,140
so maybe we'll come back to this let's

356
00:13:58,140 --> 00:14:03,149
go to my sequel sir about that okay it's

357
00:14:03,149 --> 00:14:04,760
the same thing this is my sequel

358
00:14:04,760 --> 00:14:10,760
secretary select count star from emails

359
00:14:14,930 --> 00:14:18,360
alright Postgres finished actually let's

360
00:14:18,360 --> 00:14:19,649
go back to post press because it's done

361
00:14:19,649 --> 00:14:22,290
I took a minute so I told you I inserted

362
00:14:22,290 --> 00:14:25,680
27 email addresses so I first I'm gonna

363
00:14:25,680 --> 00:14:28,170
do is I'm gonna create a hash index so

364
00:14:28,170 --> 00:14:30,630
in in deep by default in sequel and most

365
00:14:30,630 --> 00:14:32,970
systems if you just create an index

366
00:14:32,970 --> 00:14:35,279
you're gonna get a B+ tree you know or

367
00:14:35,279 --> 00:14:37,230
some tree data structure in Postgres I

368
00:14:37,230 --> 00:14:39,149
can say using hash I'm forcing it to use

369
00:14:39,149 --> 00:14:42,120
a hash index and so now we can see

370
00:14:42,120 --> 00:14:43,709
things like of course not gonna load

371
00:14:43,709 --> 00:14:45,360
this I should have warned it sorry

372
00:14:45,360 --> 00:14:50,329
this shouldn't take too long but the the

373
00:14:50,329 --> 00:14:53,850
we can see how if we try to do certain

374
00:14:53,850 --> 00:14:56,850
queries we won't be able to find the

375
00:14:56,850 --> 00:14:59,279
things that we want let me look at all

376
00:14:59,279 --> 00:15:02,930
this in sorry

377
00:15:03,110 --> 00:15:08,100
PG warm so this is that same function I

378
00:15:08,100 --> 00:15:10,019
used last time just to warm the cache

379
00:15:10,019 --> 00:15:12,839
and then now when I call create index in

380
00:15:12,839 --> 00:15:14,339
theory this should be faster because

381
00:15:14,339 --> 00:15:16,800
everything is just loaded then but we're

382
00:15:16,800 --> 00:15:18,240
gonna run queries and we're going to see

383
00:15:18,240 --> 00:15:20,190
how the query planner is not gonna be

384
00:15:20,190 --> 00:15:21,930
able to pick the index for some queries

385
00:15:21,930 --> 00:15:23,820
but it be able to pick indexes for other

386
00:15:23,820 --> 00:15:25,860
queries right because the hash index

387
00:15:25,860 --> 00:15:28,769
again you have to have the entire the

388
00:15:28,769 --> 00:15:30,630
entire key or the tower elements of the

389
00:15:30,630 --> 00:15:32,550
key you can't do partial lookups and you

390
00:15:32,550 --> 00:15:38,930
can't do range scans mmm sorry

391
00:15:40,640 --> 00:15:43,709
well this sucks all right why this is

392
00:15:43,709 --> 00:15:46,019
going on - I'll then create the the

393
00:15:46,019 --> 00:15:49,250
Depot Street index in the background I

394
00:15:59,420 --> 00:16:01,170
had everything working and then I

395
00:16:01,170 --> 00:16:02,730
dropped to the table before class start

396
00:16:02,730 --> 00:16:04,589
and I forgot to rebuild it all right

397
00:16:04,589 --> 00:16:06,420
we're back okay so it took 50 seconds

398
00:16:06,420 --> 00:16:08,459
all right so now I can do say queries

399
00:16:08,459 --> 00:16:10,620
like select star let's find a user first

400
00:16:10,620 --> 00:16:13,740
select star from let's find the minimum

401
00:16:13,740 --> 00:16:23,910
use email address from emails yeah there

402
00:16:23,910 --> 00:16:24,980
we go

403
00:16:24,980 --> 00:16:27,390
whatever that is someone correctly used

404
00:16:27,390 --> 00:16:29,100
a fake email address so if I want to do

405
00:16:29,100 --> 00:16:33,630
select star from emails where email

406
00:16:33,630 --> 00:16:38,070
equals this thing again if I add that

407
00:16:38,070 --> 00:16:40,200
explained keyword purse will tell me

408
00:16:40,200 --> 00:16:42,029
what it's gonna do so Postgres is gonna

409
00:16:42,029 --> 00:16:44,250
tell me that hey I had this hat thing

410
00:16:44,250 --> 00:16:47,370
called a hash index and I can do and do

411
00:16:47,370 --> 00:16:48,750
a lookup because I know I can do exactly

412
00:16:48,750 --> 00:16:50,579
the thing I'm looking forward evil that

413
00:16:50,579 --> 00:16:52,860
text right well ignore what a bit bitmap

414
00:16:52,860 --> 00:16:54,600
scanner heaps can is that'll come later

415
00:16:54,600 --> 00:16:56,310
on but in but we know this is gonna be

416
00:16:56,310 --> 00:16:58,890
fast is it's gonna go find exactly the

417
00:16:58,890 --> 00:17:00,990
the one that we're looking for right but

418
00:17:00,990 --> 00:17:03,230
now say if I want to do something like

419
00:17:03,230 --> 00:17:07,679
where email like and then this thing and

420
00:17:07,679 --> 00:17:10,199
put a put a wild-card at the end can you

421
00:17:10,199 --> 00:17:13,770
use this hash index no right because you

422
00:17:13,770 --> 00:17:15,480
have to have the entire key I'm not

423
00:17:15,480 --> 00:17:16,740
gonna run it cuz I probably take the

424
00:17:16,740 --> 00:17:20,040
whole time but but you can tell you when

425
00:17:20,040 --> 00:17:22,049
you asking explain its tells you it's in

426
00:17:22,049 --> 00:17:23,579
default to the sequential scan matter

427
00:17:23,579 --> 00:17:24,660
the sequential scan is always the

428
00:17:24,660 --> 00:17:26,459
default operation or access method for

429
00:17:26,459 --> 00:17:28,260
the database system they can't find what

430
00:17:28,260 --> 00:17:30,270
it wants using index it always defaults

431
00:17:30,270 --> 00:17:33,270
to a central scan so while this is going

432
00:17:33,270 --> 00:17:39,360
on let's let's build the tree index but

433
00:17:39,360 --> 00:17:40,440
we can see some other things to it right

434
00:17:40,440 --> 00:17:42,270
so let's say we want to find we want to

435
00:17:42,270 --> 00:17:45,960
count all the email addresses where the

436
00:17:45,960 --> 00:17:49,710
better greater than this right

437
00:17:49,710 --> 00:17:52,770
can I do that no again right because we

438
00:17:52,770 --> 00:17:54,150
have to have the partial key we can't do

439
00:17:54,150 --> 00:17:55,410
anything that's not in the quality

440
00:17:55,410 --> 00:17:57,570
predicate it always has to be an exact

441
00:17:57,570 --> 00:18:01,650
match all right it can do some things

442
00:18:01,650 --> 00:18:04,280
though right so let's say we find the

443
00:18:04,280 --> 00:18:06,960
there's say somebody else also did this

444
00:18:06,960 --> 00:18:08,730
one too is it quite of that because I

445
00:18:08,730 --> 00:18:10,500
didn't find that actual that was pretty

446
00:18:10,500 --> 00:18:12,630
fast for a special scan no wait sorry

447
00:18:12,630 --> 00:18:14,730
that that's an index in let's find

448
00:18:14,730 --> 00:18:16,200
another one let's find another one let's

449
00:18:16,200 --> 00:18:18,840
find the something who somebody who

450
00:18:18,840 --> 00:18:24,300
starts with an a so like a star and then

451
00:18:24,300 --> 00:18:25,770
we'll limit one and this basically says

452
00:18:25,770 --> 00:18:28,260
just keep find me the first one that you

453
00:18:28,260 --> 00:18:33,930
get that matches that right so there's

454
00:18:33,930 --> 00:18:35,760
somebody's email address let that books

455
00:18:35,760 --> 00:18:38,820
but that's okay but if we can do other

456
00:18:38,820 --> 00:18:44,610
things like this or email equals like

457
00:18:44,610 --> 00:18:46,460
that

458
00:18:46,460 --> 00:18:50,310
and it was able to actually to do two

459
00:18:50,310 --> 00:18:52,890
index scans so notice has an or clause

460
00:18:52,890 --> 00:18:55,380
and you can see I'll do one probe in the

461
00:18:55,380 --> 00:18:57,390
index try to find what I want do another

462
00:18:57,390 --> 00:18:58,770
program index and try to find what I

463
00:18:58,770 --> 00:19:00,300
want and then it combines them together

464
00:19:00,300 --> 00:19:01,890
and that's that's what the bitmap or

465
00:19:01,890 --> 00:19:03,690
means they think it was happening here

466
00:19:03,690 --> 00:19:05,700
is the bitmap index means that it's

467
00:19:05,700 --> 00:19:07,950
trying finding all matches and then the

468
00:19:07,950 --> 00:19:09,900
set of storing a record ID maintains a

469
00:19:09,900 --> 00:19:12,740
giant bitmap and the mender stores the

470
00:19:12,740 --> 00:19:15,330
the up you know it sets that bit of that

471
00:19:15,330 --> 00:19:17,070
offset to say that that record matched

472
00:19:17,070 --> 00:19:18,810
and then it combines them together and

473
00:19:18,810 --> 00:19:21,210
then it produces the output so that's

474
00:19:21,210 --> 00:19:22,950
why it has to do this and then another

475
00:19:22,950 --> 00:19:25,350
lookup over here all right so now our B+

476
00:19:25,350 --> 00:19:27,750
tree is done so now we come back to our

477
00:19:27,750 --> 00:19:38,610
original query here yes your statement

478
00:19:38,610 --> 00:19:40,470
is didn't I say last class that it would

479
00:19:40,470 --> 00:19:43,910
do the search once and then organize

480
00:19:43,910 --> 00:19:46,020
this is a hash index this is a beat

481
00:19:46,020 --> 00:19:47,520
that's not that this is the B+ right

482
00:19:47,520 --> 00:19:49,140
there's the hash table this is not a B+

483
00:19:49,140 --> 00:19:55,410
tree okay like going back to well now I

484
00:19:55,410 --> 00:19:58,320
just added the B+ tree but yeah right

485
00:19:58,320 --> 00:19:58,740
there

486
00:19:58,740 --> 00:20:00,720
so this is explain explain is telling

487
00:20:00,720 --> 00:20:01,980
you what the query plan is going to be

488
00:20:01,980 --> 00:20:03,510
so it tells you I'm going to

489
00:20:03,510 --> 00:20:05,820
scan using idx emails hash that's the

490
00:20:05,820 --> 00:20:08,270
name the hash table index I created okay

491
00:20:08,270 --> 00:20:13,800
so now my hat my my I have my I have my

492
00:20:13,800 --> 00:20:18,960
my B+ tree index so if I do something

493
00:20:18,960 --> 00:20:21,930
like this just do this lookup we had

494
00:20:21,930 --> 00:20:24,510
before this fake email it tells me it

495
00:20:24,510 --> 00:20:26,190
once you the hash hashed using hash

496
00:20:26,190 --> 00:20:28,440
index but as soon as I add this I add

497
00:20:28,440 --> 00:20:33,750
the range predicates down here is gonna

498
00:20:33,750 --> 00:20:37,400
use the hash table no it's gonna use the

499
00:20:37,400 --> 00:20:39,750
an actually do sequential scan all right

500
00:20:39,750 --> 00:20:43,170
good example so this guy is the smallest

501
00:20:43,170 --> 00:20:46,710
key that we have in our index so it

502
00:20:46,710 --> 00:20:48,180
knows that if I want to use the index

503
00:20:48,180 --> 00:20:49,860
and all I'm really doing is jumping to

504
00:20:49,860 --> 00:20:52,020
the far left point and the scanning

505
00:20:52,020 --> 00:20:53,580
along the leaf nodes and so therefore

506
00:20:53,580 --> 00:20:55,290
the traversal of the index was a waste

507
00:20:55,290 --> 00:20:56,940
of time the air force is better for me

508
00:20:56,940 --> 00:20:59,040
to just do a scrunching scan but let's

509
00:20:59,040 --> 00:21:06,090
say if I change that to Z a bunch of Z's

510
00:21:06,090 --> 00:21:09,900
and now it says that alright well I know

511
00:21:09,900 --> 00:21:11,700
that if I use my index I'm going to

512
00:21:11,700 --> 00:21:13,740
throw away a lot of data so now I can

513
00:21:13,740 --> 00:21:15,480
use that they treated jump down to the

514
00:21:15,480 --> 00:21:17,100
right side of the tree get a starting

515
00:21:17,100 --> 00:21:18,120
point and then a scan along the leaf

516
00:21:18,120 --> 00:21:20,730
nodes right so this is an eternal cost

517
00:21:20,730 --> 00:21:22,020
model thing that's going on in Postgres

518
00:21:22,020 --> 00:21:24,450
so we'll talk about later that allows it

519
00:21:24,450 --> 00:21:26,010
to decide when's the right time to do

520
00:21:26,010 --> 00:21:28,800
these things so is this clear

521
00:21:28,800 --> 00:21:30,690
so for a quality predicates the hash

522
00:21:30,690 --> 00:21:33,630
index is me pretty good but for the for

523
00:21:33,630 --> 00:21:36,330
these range predicates if it's the right

524
00:21:36,330 --> 00:21:37,710
location again we know something about

525
00:21:37,710 --> 00:21:39,720
the division of values then it will

526
00:21:39,720 --> 00:21:43,650
choose to do a index leaf scan so now go

527
00:21:43,650 --> 00:21:45,210
back here again this guy was doing the

528
00:21:45,210 --> 00:21:47,910
index scan doing exact point great

529
00:21:47,910 --> 00:21:52,740
lookup if I drop that index drop index

530
00:21:52,740 --> 00:21:56,370
emails hash comes back right away and

531
00:21:56,370 --> 00:21:58,530
now I do that predicate now it's smart

532
00:21:58,530 --> 00:22:00,030
enough to know oh I no longer have that

533
00:22:00,030 --> 00:22:02,310
hash index I have but I do have this

534
00:22:02,310 --> 00:22:03,960
tree index so I can use that for this

535
00:22:03,960 --> 00:22:09,450
quality predicate so is this clear all

536
00:22:09,450 --> 00:22:10,560
right the other thing we talked about

537
00:22:10,560 --> 00:22:12,390
last class briefly was was table

538
00:22:12,390 --> 00:22:16,650
clustering so table clustering is the

539
00:22:16,650 --> 00:22:17,549
where we're going to

540
00:22:17,549 --> 00:22:20,249
use the index to enforce the sort

541
00:22:20,249 --> 00:22:24,509
ordering of the of the of the table

542
00:22:24,509 --> 00:22:26,399
themselves the to pose themselves Samara

543
00:22:26,399 --> 00:22:28,889
post grass is unsorted or started

544
00:22:28,889 --> 00:22:30,869
relational models unsorted so as we

545
00:22:30,869 --> 00:22:33,149
insert things into post grass it's just

546
00:22:33,149 --> 00:22:34,739
putting them and the essentially the

547
00:22:34,739 --> 00:22:36,330
order that that it was told to put him

548
00:22:36,330 --> 00:22:38,850
in as we do the inserts and we saw

549
00:22:38,850 --> 00:22:39,929
examples where I could update things

550
00:22:39,929 --> 00:22:41,309
delete things and can reshuffle some

551
00:22:41,309 --> 00:22:43,679
depending on how I you know what you

552
00:22:43,679 --> 00:22:45,059
know what free slots are available in a

553
00:22:45,059 --> 00:22:48,389
page so if I go say do a select query

554
00:22:48,389 --> 00:22:51,029
here a select star from emails and I

555
00:22:51,029 --> 00:22:53,820
just say give me the first one alright

556
00:22:53,820 --> 00:22:56,879
we get some random Gmail account but now

557
00:22:56,879 --> 00:23:01,259
if I say if I called this clustering

558
00:23:01,259 --> 00:23:04,320
command this will take about a minute

559
00:23:04,320 --> 00:23:06,029
but what this is doing this is this

560
00:23:06,029 --> 00:23:08,419
command is forcing Postgres to

561
00:23:08,419 --> 00:23:12,539
potentially re sort the entire table

562
00:23:12,539 --> 00:23:15,989
based on the the sort ordering defined

563
00:23:15,989 --> 00:23:18,509
by this index but this is a one-time

564
00:23:18,509 --> 00:23:21,809
operation so as I as I modify the table

565
00:23:21,809 --> 00:23:23,519
and maybe things get out of order it's

566
00:23:23,519 --> 00:23:25,289
not you know it's not gonna match what

567
00:23:25,289 --> 00:23:27,299
it was when I first set it up here some

568
00:23:27,299 --> 00:23:29,519
systems like in my sequel and sequel

569
00:23:29,519 --> 00:23:31,320
server and oracle you can say i want an

570
00:23:31,320 --> 00:23:32,879
index clustered table or an indictable

571
00:23:32,879 --> 00:23:35,340
clustering on the index and therefore it

572
00:23:35,340 --> 00:23:37,440
ensures that no matter how you insert

573
00:23:37,440 --> 00:23:39,929
values into your table in what order you

574
00:23:39,929 --> 00:23:42,299
insert them the underlying physical

575
00:23:42,299 --> 00:23:45,450
storage will be sorted so in some cases

576
00:23:45,450 --> 00:23:47,389
this allows us to do binary search

577
00:23:47,389 --> 00:23:49,769
directly on the table themselves which

578
00:23:49,769 --> 00:23:51,600
is still login without having to go

579
00:23:51,600 --> 00:23:54,179
through the index itself so this is if

580
00:23:54,179 --> 00:23:55,590
you take a long time so what does let

581
00:23:55,590 --> 00:23:58,889
this go but I quickly want to jump back

582
00:23:58,889 --> 00:24:01,320
over to my sequel so again same email

583
00:24:01,320 --> 00:24:03,269
address load it into my sequel I can do

584
00:24:03,269 --> 00:24:04,859
the same kind of queries select star

585
00:24:04,859 --> 00:24:11,850
from emails where where that fake one

586
00:24:11,850 --> 00:24:18,210
was email equals that so the the my

587
00:24:18,210 --> 00:24:22,049
sequel explained is not as good but

588
00:24:22,049 --> 00:24:23,999
basically it's not a tree structure be a

589
00:24:23,999 --> 00:24:25,259
bit is reading here it says this is

590
00:24:25,259 --> 00:24:27,450
here's the index I could possibly use so

591
00:24:27,450 --> 00:24:29,399
notice I have a hash index and I can use

592
00:24:29,399 --> 00:24:30,410
that

593
00:24:30,410 --> 00:24:32,390
and then if I do change that to be

594
00:24:32,390 --> 00:24:40,310
greater than this still uses it no but

595
00:24:40,310 --> 00:24:43,340
it it says here the kind of hard to see

596
00:24:43,340 --> 00:24:47,240
it's small its rolled over here but see

597
00:24:47,240 --> 00:24:50,090
the there's a column here called Rose

598
00:24:50,090 --> 00:24:51,770
this is my sequel telling you how many

599
00:24:51,770 --> 00:24:53,210
rows is gonna I think I'm at the reading

600
00:24:53,210 --> 00:24:54,860
so that's twenty seven million wrapped

601
00:24:54,860 --> 00:24:57,350
around around here so it could use this

602
00:24:57,350 --> 00:24:59,240
hash index but it's gonna fall back and

603
00:24:59,240 --> 00:25:02,270
do a simple salento scan whereas the one

604
00:25:02,270 --> 00:25:04,520
up above it could do it in X and X probe

605
00:25:04,520 --> 00:25:07,060
to find exactly what it wanted alright

606
00:25:07,060 --> 00:25:10,520
alright so Postgres is now done we're

607
00:25:10,520 --> 00:25:12,170
coming back here so now if I do limit

608
00:25:12,170 --> 00:25:14,780
one right I get that first guy that I

609
00:25:14,780 --> 00:25:16,610
had before right so this is saying it

610
00:25:16,610 --> 00:25:17,960
give me the very first tuple you find

611
00:25:17,960 --> 00:25:20,480
for this for this and this is the min

612
00:25:20,480 --> 00:25:21,770
one that we found before because this

613
00:25:21,770 --> 00:25:23,480
guarantee that this was inserted order

614
00:25:23,480 --> 00:25:25,880
so if I if I do this now if I say I

615
00:25:25,880 --> 00:25:31,700
delete that email address delete emails

616
00:25:31,700 --> 00:25:38,750
where email equals this thing there you

617
00:25:38,750 --> 00:25:40,220
go ask for the first one now I get a

618
00:25:40,220 --> 00:25:42,320
different fake email address but now let

619
00:25:42,320 --> 00:25:44,270
me start another one back in insert into

620
00:25:44,270 --> 00:25:48,350
emails values default because it's a

621
00:25:48,350 --> 00:25:50,900
auto incrementing key insert my guy back

622
00:25:50,900 --> 00:25:56,440
in right it's still not in sorted order

623
00:25:56,440 --> 00:26:00,310
because it only did that operation once

624
00:26:00,310 --> 00:26:08,120
any questions this question is it to

625
00:26:08,120 --> 00:26:10,640
enforce sort order I'd have to run

626
00:26:10,640 --> 00:26:12,710
cluster over and over again for Postgres

627
00:26:12,710 --> 00:26:14,450
yes for other systems you do not have to

628
00:26:14,450 --> 00:26:15,860
do that you can say I wanted to be all

629
00:26:15,860 --> 00:26:19,120
to automatically cluster by the index

630
00:26:20,320 --> 00:26:22,370
this question is does the comm need to

631
00:26:22,370 --> 00:26:24,590
be indexed before we cluster no so my

632
00:26:24,590 --> 00:26:30,340
sequel it's sorted by the primary key so

633
00:26:30,340 --> 00:26:32,690
in my sequel the leaf nodes are actually

634
00:26:32,690 --> 00:26:35,840
the tuples themselves so as I'm moving

635
00:26:35,840 --> 00:26:37,550
things around splitting and merging the

636
00:26:37,550 --> 00:26:39,080
leaf nodes always be in that sort of

637
00:26:39,080 --> 00:26:40,490
order so if I want to do a sequential

638
00:26:40,490 --> 00:26:42,080
scan on the table I'm basically always

639
00:26:42,080 --> 00:26:43,640
following leaf nodes and so in other

640
00:26:43,640 --> 00:26:44,210
systems like

641
00:26:44,210 --> 00:26:47,180
and sequel server db2 you can say create

642
00:26:47,180 --> 00:26:49,010
this table and sorted by these columns

643
00:26:49,010 --> 00:26:53,200
and I'll do it for you nope sorry

644
00:26:53,470 --> 00:27:07,820
yes yes this question is I said that we

645
00:27:07,820 --> 00:27:09,980
could use the physical ID sorry the

646
00:27:09,980 --> 00:27:12,020
physical location the page ID and the

647
00:27:12,020 --> 00:27:13,970
slot number as the record ID to

648
00:27:13,970 --> 00:27:16,660
determine to make the tuples unique

649
00:27:16,660 --> 00:27:19,160
instead why not use the timestamp of

650
00:27:19,160 --> 00:27:25,340
when the tuple was inserted because so

651
00:27:25,340 --> 00:27:27,200
in Postgres this is an issue from my

652
00:27:27,200 --> 00:27:29,240
sequel this won't be an issue what's the

653
00:27:29,240 --> 00:27:35,690
problem a timestamp he said in tribute

654
00:27:35,690 --> 00:27:37,010
of setting the times aren't going to be

655
00:27:37,010 --> 00:27:40,790
synchronized yes even more simple that

656
00:27:40,790 --> 00:27:45,250
is an issue leap second leap years right

657
00:27:45,250 --> 00:27:48,350
so now again they repeat the second now

658
00:27:48,350 --> 00:27:48,980
what happens

659
00:27:48,980 --> 00:27:50,570
I insert something now they have the

660
00:27:50,570 --> 00:27:53,030
same timestamp or clocks can drift by

661
00:27:53,030 --> 00:27:56,450
clocks are horribly inaccurate so you

662
00:27:56,450 --> 00:27:59,060
know I run NTP every so often and now it

663
00:27:59,060 --> 00:28:00,920
slowly just the clock but occasionally

664
00:28:00,920 --> 00:28:03,020
has to do big big steps you might repeat

665
00:28:03,020 --> 00:28:12,380
a second yes this question what's there

666
00:28:12,380 --> 00:28:13,850
between doing the record a versus

667
00:28:13,850 --> 00:28:27,710
milliseconds versus the unity yeah so

668
00:28:27,710 --> 00:28:30,140
he's right milliseconds since the unity

669
00:28:30,140 --> 00:28:32,270
file particularly beer it won't help

670
00:28:32,270 --> 00:28:34,850
drift right if the clock has to get

671
00:28:34,850 --> 00:28:38,210
stepped back you repeat seconds nobody

672
00:28:38,210 --> 00:28:39,650
uses a time stamps in that way you can

673
00:28:39,650 --> 00:28:41,750
use logical time stamps which we'll talk

674
00:28:41,750 --> 00:28:44,750
about later on you always want almost

675
00:28:44,750 --> 00:28:47,060
never want to use hard physical clocks

676
00:28:47,060 --> 00:28:49,190
you used in conjunction with other

677
00:28:49,190 --> 00:28:52,549
things yes

678
00:28:52,549 --> 00:28:57,169
a question is when would you want to use

679
00:28:57,169 --> 00:28:59,299
a clustering index when if you already

680
00:28:59,299 --> 00:29:03,109
have an index so again like in the case

681
00:29:03,109 --> 00:29:04,700
of my sequel I should show an example in

682
00:29:04,700 --> 00:29:06,979
my sequel it's always a cluster Munich's

683
00:29:06,979 --> 00:29:08,539
when I call create table it's always

684
00:29:08,539 --> 00:29:11,869
clustered on that there are some cases

685
00:29:11,869 --> 00:29:18,559
where for certain queries it for certain

686
00:29:18,559 --> 00:29:20,149
queries you can be smart about like

687
00:29:20,149 --> 00:29:21,950
alright well if I'm clustering on the

688
00:29:21,950 --> 00:29:23,809
only logical time stamp one of us

689
00:29:23,809 --> 00:29:24,979
inserted like the application told me

690
00:29:24,979 --> 00:29:29,450
the time stamp then now maybe I can say

691
00:29:29,450 --> 00:29:31,249
well take the last days worth of data

692
00:29:31,249 --> 00:29:33,769
and put it on the fast disk and the

693
00:29:33,769 --> 00:29:36,079
older stuff puts on slower disk there's

694
00:29:36,079 --> 00:29:37,339
ways to do like disk partitioning that

695
00:29:37,339 --> 00:29:39,889
way and data says we can enforce that

696
00:29:39,889 --> 00:30:06,529
all for me underneath the covers so you

697
00:30:06,529 --> 00:30:09,499
say this if if I have if I'm if I'm

698
00:30:09,499 --> 00:30:11,479
clustered on email next on email and

699
00:30:11,479 --> 00:30:15,619
that's my primary key and then primary

700
00:30:15,619 --> 00:30:17,359
keys ID so if you have a primary key

701
00:30:17,359 --> 00:30:18,649
we'll see this in a second you always

702
00:30:18,649 --> 00:30:22,149
have an index on that on that on that on

703
00:30:22,149 --> 00:30:27,349
that ID or all the attributes to cut

704
00:30:27,349 --> 00:30:30,039
yeah so they hit update the index guess

705
00:30:30,039 --> 00:30:32,179
depends how you store your indexes we'll

706
00:30:32,179 --> 00:30:32,839
get to that later

707
00:30:32,839 --> 00:30:34,609
like in if we'll get that one called

708
00:30:34,609 --> 00:30:38,089
version so you the the pointer could be

709
00:30:38,089 --> 00:30:40,190
the primary key or it could be the

710
00:30:40,190 --> 00:30:42,799
record locations record ID you can do

711
00:30:42,799 --> 00:30:43,509
different things

712
00:30:43,509 --> 00:30:46,549
Postgres does record ID so we have to

713
00:30:46,549 --> 00:30:47,749
update all the time my sequel does

714
00:30:47,749 --> 00:30:52,219
primary key all right so we actually can

715
00:30:52,219 --> 00:30:53,599
poke around and Postgres real quickly

716
00:30:53,599 --> 00:30:58,159
and see what the see what the you know

717
00:30:58,159 --> 00:30:59,799
what's roughly what the tree looks like

718
00:30:59,799 --> 00:31:02,419
right so this is just an extension

719
00:31:02,419 --> 00:31:03,710
Postgres that allows you to get

720
00:31:03,710 --> 00:31:06,410
information about what's in the tree

721
00:31:06,410 --> 00:31:08,000
right so I can say I had this index

722
00:31:08,000 --> 00:31:09,830
called you know on the unbe plus tree

723
00:31:09,830 --> 00:31:11,300
and I can say you know give me

724
00:31:11,300 --> 00:31:12,530
information about it tells me how many

725
00:31:12,530 --> 00:31:14,480
levels it has tells me how many elements

726
00:31:14,480 --> 00:31:17,300
it is storing and the root block size so

727
00:31:17,300 --> 00:31:18,710
then we can go even further and we can

728
00:31:18,710 --> 00:31:21,140
actually get inspect the contents of the

729
00:31:21,140 --> 00:31:25,460
treating with this command here and you

730
00:31:25,460 --> 00:31:27,290
know the actual details doesn't matter

731
00:31:27,290 --> 00:31:29,000
but there's a bunch of hex stuff right

732
00:31:29,000 --> 00:31:32,600
so this is the root node so we can go go

733
00:31:32,600 --> 00:31:35,030
a bit deeper now and show you you know

734
00:31:35,030 --> 00:31:36,050
for a single node here's some

735
00:31:36,050 --> 00:31:38,330
information about it but then we that's

736
00:31:38,330 --> 00:31:41,660
all hex but we can decode it and then

737
00:31:41,660 --> 00:31:43,190
here's a know here's this proving that

738
00:31:43,190 --> 00:31:44,990
it's actually storing these emails so

739
00:31:44,990 --> 00:31:46,730
this is saying that here's a record at

740
00:31:46,730 --> 00:31:49,400
offset 3 in my root node or in this

741
00:31:49,400 --> 00:31:51,200
particular node in the tree here's the

742
00:31:51,200 --> 00:31:53,270
you know page number and all set where

743
00:31:53,270 --> 00:31:55,670
it's located here's the hex form form of

744
00:31:55,670 --> 00:31:57,350
what's being stored and then there's the

745
00:31:57,350 --> 00:32:01,160
actual email address right so again the

746
00:32:01,160 --> 00:32:02,930
the Davises gonna store tired copies of

747
00:32:02,930 --> 00:32:05,450
these keys on the inside all right we're

748
00:32:05,450 --> 00:32:08,060
gonna stop now and keep going to bunch

749
00:32:08,060 --> 00:32:10,670
other stuff we want to get through but

750
00:32:10,670 --> 00:32:11,690
that's just getting to show you that you

751
00:32:11,690 --> 00:32:13,820
can by default you're always going to

752
00:32:13,820 --> 00:32:18,380
get a big cluster e but you can for some

753
00:32:18,380 --> 00:32:19,820
systems to tell you I want a hash index

754
00:32:19,820 --> 00:32:20,600
and there's different trade-offs for

755
00:32:20,600 --> 00:32:22,090
doing this

756
00:32:22,090 --> 00:32:24,230
alright so now related to the point he

757
00:32:24,230 --> 00:32:28,220
said about the the primary key you know

758
00:32:28,220 --> 00:32:30,470
and the vs. the clustering index so if

759
00:32:30,470 --> 00:32:32,690
you create a primary key the database

760
00:32:32,690 --> 00:32:34,670
system will automatically create an

761
00:32:34,670 --> 00:32:37,400
index for you actually for any time you

762
00:32:37,400 --> 00:32:39,920
you declare a an integrity constraint it

763
00:32:39,920 --> 00:32:41,690
will automatically create an index for

764
00:32:41,690 --> 00:32:43,010
you and you think about it has to

765
00:32:43,010 --> 00:32:44,930
because otherwise the only way to

766
00:32:44,930 --> 00:32:48,320
enforce that is do a sequential scan so

767
00:32:48,320 --> 00:32:50,510
in my one my auto increment key if I had

768
00:32:50,510 --> 00:32:53,030
it to enforce the primary key uniqueness

769
00:32:53,030 --> 00:32:55,070
of it every single time I inserted that

770
00:32:55,070 --> 00:32:57,230
you know you need to blow up I didn't

771
00:32:57,230 --> 00:32:59,300
have an index I had to scan every single

772
00:32:59,300 --> 00:33:00,800
tuple all over just make sure there's

773
00:33:00,800 --> 00:33:04,790
nobody has the same same key so again

774
00:33:04,790 --> 00:33:05,870
every day.you system will do this

775
00:33:05,870 --> 00:33:07,490
automatically for primary key and unique

776
00:33:07,490 --> 00:33:09,740
constraints it and it so basically again

777
00:33:09,740 --> 00:33:11,660
when i create the table if i have

778
00:33:11,660 --> 00:33:13,730
primary key unique it's the same thing

779
00:33:13,730 --> 00:33:15,290
as running these commands i'll create

780
00:33:15,290 --> 00:33:17,060
the table then it goes heads and creates

781
00:33:17,060 --> 00:33:17,930
these indexes

782
00:33:17,930 --> 00:33:21,080
for foreign keys it doesn't actually do

783
00:33:21,080 --> 00:33:23,440
this so if I create a new table here

784
00:33:23,440 --> 00:33:26,210
called bar and has a foreign key

785
00:33:26,210 --> 00:33:28,940
reference to this value here every

786
00:33:28,940 --> 00:33:30,350
database system that I ever try this on

787
00:33:30,350 --> 00:33:32,660
will always throw an error because it's

788
00:33:32,660 --> 00:33:36,350
saying I doesn't have a way to enforce

789
00:33:36,350 --> 00:33:38,420
this referential integrity constraint

790
00:33:38,420 --> 00:33:42,590
without an index right you think it

791
00:33:42,590 --> 00:33:43,910
could make all matically create one but

792
00:33:43,910 --> 00:33:44,900
it doesn't do that because it doesn't

793
00:33:44,900 --> 00:33:47,600
know because this has to be unique right

794
00:33:47,600 --> 00:33:50,180
so it won't actually do this instead you

795
00:33:50,180 --> 00:33:52,310
just replace that with it as adding

796
00:33:52,310 --> 00:33:54,650
unique calls here and that that that's

797
00:33:54,650 --> 00:33:56,180
builds an index automatically for you

798
00:33:56,180 --> 00:33:58,010
that it can then use to enforce this

799
00:33:58,010 --> 00:33:59,690
right because think about basically the

800
00:33:59,690 --> 00:34:00,860
way foreign keys work is that every

801
00:34:00,860 --> 00:34:03,290
single time I started a tuple into bar I

802
00:34:03,290 --> 00:34:06,110
have to have his ID thing so then to

803
00:34:06,110 --> 00:34:07,820
make sure that it matches to a tuple in

804
00:34:07,820 --> 00:34:09,980
my biz table I can do a lookup in that

805
00:34:09,980 --> 00:34:13,040
index and see whether there is a you

806
00:34:13,040 --> 00:34:17,300
know parent referential match so now

807
00:34:17,300 --> 00:34:18,530
let's talk about different ways to

808
00:34:18,530 --> 00:34:20,480
actually use indexes beyond the you know

809
00:34:20,480 --> 00:34:22,489
copy the whole key that we talked about

810
00:34:22,489 --> 00:34:26,300
here today so the first thing that we

811
00:34:26,300 --> 00:34:29,960
can do is called a partial index so when

812
00:34:29,960 --> 00:34:31,699
you normally call create index on a

813
00:34:31,699 --> 00:34:33,530
table it does a sequential scan across

814
00:34:33,530 --> 00:34:35,239
the entire table and looks at every

815
00:34:35,239 --> 00:34:39,440
single tuple but in many cases for a lot

816
00:34:39,440 --> 00:34:40,760
of applications maybe you don't need to

817
00:34:40,760 --> 00:34:43,120
have an index when the entire table and

818
00:34:43,120 --> 00:34:45,139
instead you always want to maybe almost

819
00:34:45,139 --> 00:34:47,870
you know some subset of the data so this

820
00:34:47,870 --> 00:34:50,270
is what a partial index is you basically

821
00:34:50,270 --> 00:34:53,030
modify the create index command and you

822
00:34:53,030 --> 00:34:55,580
add this where clause at the end that

823
00:34:55,580 --> 00:34:58,190
tells you what - match b2b in

824
00:34:58,190 --> 00:35:01,250
order to be put into this index so now

825
00:35:01,250 --> 00:35:02,510
if I want to do a lookup like this

826
00:35:02,510 --> 00:35:04,700
select be from foo where a equals 1 2 3

827
00:35:04,700 --> 00:35:08,360
and C equals whoo tang so I've built the

828
00:35:08,360 --> 00:35:11,170
index on a and B my where Clause has

829
00:35:11,170 --> 00:35:14,060
references a so I can still use this

830
00:35:14,060 --> 00:35:16,100
index but I can also look at this thing

831
00:35:16,100 --> 00:35:18,320
and say oh we're see it was wu-tang but

832
00:35:18,320 --> 00:35:20,360
I know this is exactly the index I want

833
00:35:20,360 --> 00:35:23,330
to use so then this allows me to do a

834
00:35:23,330 --> 00:35:26,060
more the index is leaner because I'm not

835
00:35:26,060 --> 00:35:27,260
storing all the information for all

836
00:35:27,260 --> 00:35:29,330
possible tuples i'm only storing exactly

837
00:35:29,330 --> 00:35:30,400
whatever it matches

838
00:35:30,400 --> 00:35:33,069
we're closed so but somehow the query

839
00:35:33,069 --> 00:35:34,480
doesn't have this e equals mu tang I

840
00:35:34,480 --> 00:35:39,039
can't use that index so this is very

841
00:35:39,039 --> 00:35:40,569
common when people do things like they

842
00:35:40,569 --> 00:35:42,010
want to separate I have different

843
00:35:42,010 --> 00:35:44,619
indexes for different date ranges like

844
00:35:44,619 --> 00:35:46,390
you know per month I'll have it index so

845
00:35:46,390 --> 00:35:47,950
I do look up quickly on all the orders I

846
00:35:47,950 --> 00:35:49,440
want for that you know for that month

847
00:35:49,440 --> 00:35:51,849
and again I'm trying to not have to

848
00:35:51,849 --> 00:35:53,619
pollute my buffer pool cache with a

849
00:35:53,619 --> 00:35:55,390
bunch of data that I don't need by

850
00:35:55,390 --> 00:35:57,069
having a partial index now the heights

851
00:35:57,069 --> 00:35:58,960
gonna be lower and I quickly find the

852
00:35:58,960 --> 00:36:01,680
data that I'm looking for

853
00:36:01,680 --> 00:36:05,380
so in this particular example here for

854
00:36:05,380 --> 00:36:07,990
this query we were doing a look-up on a

855
00:36:07,990 --> 00:36:11,770
using C and we want to turn B it turns

856
00:36:11,770 --> 00:36:13,089
out actually for this particular query

857
00:36:13,089 --> 00:36:16,869
all the data we need is in the index

858
00:36:16,869 --> 00:36:19,150
itself so member I said normally the

859
00:36:19,150 --> 00:36:20,950
index would for a given key would

860
00:36:20,950 --> 00:36:23,200
produce a record ID that you could then

861
00:36:23,200 --> 00:36:25,450
follow that to in the table heap and get

862
00:36:25,450 --> 00:36:27,069
the tuple that you were looking for but

863
00:36:27,069 --> 00:36:28,930
for this particular query here we don't

864
00:36:28,930 --> 00:36:30,309
actually even need to even look at the

865
00:36:30,309 --> 00:36:33,190
tuple because we need a to do the lookup

866
00:36:33,190 --> 00:36:34,900
that's in there we need B that's in

867
00:36:34,900 --> 00:36:36,339
there and C's already handled by the

868
00:36:36,339 --> 00:36:39,279
partial index where clause so to answer

869
00:36:39,279 --> 00:36:41,440
this query we only need to actually look

870
00:36:41,440 --> 00:36:42,760
at the index we never actually need to

871
00:36:42,760 --> 00:36:44,950
look at the underlying tuple in the

872
00:36:44,950 --> 00:36:47,589
table so this is what is called a

873
00:36:47,589 --> 00:36:49,869
covering index a covering index means

874
00:36:49,869 --> 00:36:51,730
that the all the fields that are

875
00:36:51,730 --> 00:36:54,339
necessary to answer the the require

876
00:36:54,339 --> 00:36:57,160
result for the query are produced you

877
00:36:57,160 --> 00:36:59,230
know art can be found in the index

878
00:36:59,230 --> 00:37:02,380
itself I so you don't declare an index

879
00:37:02,380 --> 00:37:04,390
as a covering index this is something

880
00:37:04,390 --> 00:37:05,650
the database system figures out for you

881
00:37:05,650 --> 00:37:07,270
automatically I knows of your query as

882
00:37:07,270 --> 00:37:08,349
it notes a new index that says

883
00:37:08,349 --> 00:37:09,630
everything I need is in here

884
00:37:09,630 --> 00:37:11,859
so again just using this example simple

885
00:37:11,859 --> 00:37:14,650
example I can get the B field from that

886
00:37:14,650 --> 00:37:17,200
from that the a and B field can be found

887
00:37:17,200 --> 00:37:19,510
exactly from this the index and I never

888
00:37:19,510 --> 00:37:21,849
need to look at the actual tuple I can

889
00:37:21,849 --> 00:37:22,869
do this work for a bunch of different

890
00:37:22,869 --> 00:37:24,789
queries I can do this for aggregations I

891
00:37:24,789 --> 00:37:27,520
can do this for joins and the advantage

892
00:37:27,520 --> 00:37:29,740
here it's one less you know page ID

893
00:37:29,740 --> 00:37:31,329
lookup and the page table and maybe one

894
00:37:31,329 --> 00:37:34,779
glass disk IO to not have to go look at

895
00:37:34,779 --> 00:37:38,799
the underlying tuple for this so the a

896
00:37:38,799 --> 00:37:40,480
bunch of different data systems support

897
00:37:40,480 --> 00:37:43,839
this all the commercial guys do

898
00:37:43,839 --> 00:37:44,260
does

899
00:37:44,260 --> 00:37:47,320
I don't think my secon Postgres to I may

900
00:37:47,320 --> 00:37:49,810
be wrong about that but this is a big

901
00:37:49,810 --> 00:37:51,700
win right if you can do this this is a

902
00:37:51,700 --> 00:37:53,650
huge deal okay

903
00:37:53,650 --> 00:37:55,540
I don't think Postgres can do this for

904
00:37:55,540 --> 00:37:58,119
reasons we'll talk about later so for

905
00:37:58,119 --> 00:38:01,089
this simple example this is great right

906
00:38:01,089 --> 00:38:03,750
I need a and B a B confounding the index

907
00:38:03,750 --> 00:38:07,930
but what if I have now another I have

908
00:38:07,930 --> 00:38:09,430
another attribute that I want to be able

909
00:38:09,430 --> 00:38:12,280
to do a look-up on or get for my query

910
00:38:12,280 --> 00:38:13,900
but I don't actually want to build the

911
00:38:13,900 --> 00:38:17,079
index on that attribute all right so my

912
00:38:17,079 --> 00:38:19,150
table has column a B and C maybe I don't

913
00:38:19,150 --> 00:38:21,460
want to index on the seat but it'd still

914
00:38:21,460 --> 00:38:23,349
be nice to have a covering index not not

915
00:38:23,349 --> 00:38:26,050
have to go look at the tuple so this is

916
00:38:26,050 --> 00:38:27,430
what the include columns allows you to

917
00:38:27,430 --> 00:38:30,130
do basically include column allows you

918
00:38:30,130 --> 00:38:32,710
to say for all the keys that I'm storing

919
00:38:32,710 --> 00:38:35,530
in my for my my leaf pages my leaf nodes

920
00:38:35,530 --> 00:38:38,190
also include these additional attributes

921
00:38:38,190 --> 00:38:40,630
so this case I'm building NX on a and B

922
00:38:40,630 --> 00:38:43,210
all the inner nodes only have keys a and

923
00:38:43,210 --> 00:38:45,849
B and when I do lookups I only examine a

924
00:38:45,849 --> 00:38:47,740
and B but when I land into the leaf

925
00:38:47,740 --> 00:38:50,859
nodes I can also get the C attribute

926
00:38:50,859 --> 00:38:53,160
value for every single entry in there

927
00:38:53,160 --> 00:38:56,319
right so now again if I go back to my

928
00:38:56,319 --> 00:38:58,270
other query here select B from food

929
00:38:58,270 --> 00:38:59,740
where a equals 1 2 3 and C equals whoo

930
00:38:59,740 --> 00:39:00,160
tang

931
00:39:00,160 --> 00:39:02,710
I do might look up on a follow that down

932
00:39:02,710 --> 00:39:04,599
then as I'm scanning along the leaf

933
00:39:04,599 --> 00:39:08,020
nodes I can look at the values at C

934
00:39:08,020 --> 00:39:10,599
that's packed in the leaf nodes and also

935
00:39:10,599 --> 00:39:13,140
value my predicate it produced my output

936
00:39:13,140 --> 00:39:17,680
so this one is also this one's more rare

937
00:39:17,680 --> 00:39:20,410
than the covering index support so a lot

938
00:39:20,410 --> 00:39:22,650
of systems support the partial indexes

939
00:39:22,650 --> 00:39:24,609
slightly fewer systems support the

940
00:39:24,609 --> 00:39:26,619
covering indexes this one is even more

941
00:39:26,619 --> 00:39:28,990
rare I think this is Postgres 11 has

942
00:39:28,990 --> 00:39:30,670
yeah post press Elevens gonna add this

943
00:39:30,670 --> 00:39:33,550
or has it now sequel server has it but

944
00:39:33,550 --> 00:39:35,190
my C code doesn't support this and

945
00:39:35,190 --> 00:39:38,440
Oracle does not support this so again

946
00:39:38,440 --> 00:39:39,339
the key thing about this is that

947
00:39:39,339 --> 00:39:42,300
although we can do a look up and see in

948
00:39:42,300 --> 00:39:44,920
you've got where clause it's not in the

949
00:39:44,920 --> 00:39:46,510
internet sort the we're not you know

950
00:39:46,510 --> 00:39:47,980
greatly increasing the size of the

951
00:39:47,980 --> 00:39:52,630
overall index the last kind of and next

952
00:39:52,630 --> 00:39:53,920
one talk about our functional expression

953
00:39:53,920 --> 00:39:56,050
indexes so again everything we've shown

954
00:39:56,050 --> 00:39:57,490
so far anytime

955
00:39:57,490 --> 00:39:59,020
we declare index we're always creating

956
00:39:59,020 --> 00:40:00,790
an exact copy of the key that's in the

957
00:40:00,790 --> 00:40:03,790
tuple and putting that in our index but

958
00:40:03,790 --> 00:40:05,290
there may be some kind of quick some

959
00:40:05,290 --> 00:40:07,270
queries out there where we don't

960
00:40:07,270 --> 00:40:09,100
actually want to do a look-up on the

961
00:40:09,100 --> 00:40:11,380
exact value of a key we want to do a

962
00:40:11,380 --> 00:40:13,000
look up on some value that we derived

963
00:40:13,000 --> 00:40:15,940
from the key so let's say I have a

964
00:40:15,940 --> 00:40:17,740
simple example here I have this users

965
00:40:17,740 --> 00:40:19,840
table and I want to do a lookup and find

966
00:40:19,840 --> 00:40:22,600
all the users that logged in on the

967
00:40:22,600 --> 00:40:25,480
Tuesday so this extract function takes a

968
00:40:25,480 --> 00:40:28,060
timestamp and you pass in what element

969
00:40:28,060 --> 00:40:30,190
of the the date or timestamp you want so

970
00:40:30,190 --> 00:40:32,950
do W means a day a week and so this is

971
00:40:32,950 --> 00:40:34,330
saying extract the day a week from the

972
00:40:34,330 --> 00:40:36,400
login timestamp field and find the ones

973
00:40:36,400 --> 00:40:38,590
where it equals to its Tuesdays to

974
00:40:38,590 --> 00:40:42,850
Sunday zero Monday one Tuesday two so if

975
00:40:42,850 --> 00:40:45,369
I create an index like this as we've

976
00:40:45,369 --> 00:40:51,180
shown so far right this won't work why

977
00:40:51,690 --> 00:41:02,230
yes so this one who says he says you

978
00:41:02,230 --> 00:41:04,630
have to know how to extract our pull out

979
00:41:04,630 --> 00:41:08,890
exactly what ranges will correspond to

980
00:41:08,890 --> 00:41:11,140
Tuesday and so you can kind of be smart

981
00:41:11,140 --> 00:41:12,760
say oh well my crave looks like this I

982
00:41:12,760 --> 00:41:14,380
could say well here's the here's the

983
00:41:14,380 --> 00:41:17,140
ranges of timestamps where Tuesday can

984
00:41:17,140 --> 00:41:19,390
be found but as far as I know no system

985
00:41:19,390 --> 00:41:22,060
actually does this so instead we which

986
00:41:22,060 --> 00:41:23,500
you can just do is not use this and

987
00:41:23,500 --> 00:41:25,570
create a functional index or expression

988
00:41:25,570 --> 00:41:28,619
index where the actual the the

989
00:41:28,619 --> 00:41:31,570
attributes your your indexing on can be

990
00:41:31,570 --> 00:41:34,240
any arbitrary expression anything you

991
00:41:34,240 --> 00:41:35,710
can have in a where clause you can you

992
00:41:35,710 --> 00:41:40,570
can build a index on all right so now

993
00:41:40,570 --> 00:41:43,150
what I'm gonna do a lookup and for this

994
00:41:43,150 --> 00:41:44,920
for this predicate I know how to exactly

995
00:41:44,920 --> 00:41:49,480
satisfy it by did you know you know do

996
00:41:49,480 --> 00:41:51,490
look at every feed that just getting

997
00:41:51,490 --> 00:41:53,590
along here finding all the the the twos

998
00:41:53,590 --> 00:41:56,790
that match what we want

999
00:41:57,790 --> 00:41:59,290
what's another way we could we could

1000
00:41:59,290 --> 00:42:01,060
speed this query up to then we've

1001
00:42:01,060 --> 00:42:05,740
already shown before the partial index

1002
00:42:05,740 --> 00:42:08,080
way right so instead of creating an

1003
00:42:08,080 --> 00:42:10,570
index for exactly in this way for

1004
00:42:10,570 --> 00:42:12,550
exactly for the extracted day a week I

1005
00:42:12,550 --> 00:42:16,330
instead just use that as my my where

1006
00:42:16,330 --> 00:42:18,280
clause to say put only the elements

1007
00:42:18,280 --> 00:42:21,490
where where the extract value produces

1008
00:42:21,490 --> 00:42:27,340
two right so let's do a demo this in

1009
00:42:27,340 --> 00:42:30,190
Postgres so Postgres has the partial

1010
00:42:30,190 --> 00:42:34,180
indexes it has the doesn't have covering

1011
00:42:34,180 --> 00:42:36,100
indexes and then the version I have here

1012
00:42:36,100 --> 00:42:37,810
is 10 so it doesn't have the include

1013
00:42:37,810 --> 00:42:39,910
clauses but we can play around partial

1014
00:42:39,910 --> 00:42:43,320
indexes verses the functional indexes

1015
00:42:43,650 --> 00:42:45,550
alright so for this we're going to

1016
00:42:45,550 --> 00:42:48,130
create a table make sure we turn off

1017
00:42:48,130 --> 00:42:53,680
parallel workers and timings on alright

1018
00:42:53,680 --> 00:42:57,570
so we're gonna create a table that has

1019
00:42:57,570 --> 00:43:00,280
an ID field and a login timestamp and

1020
00:43:00,280 --> 00:43:03,820
then this is going to be a simple this

1021
00:43:03,820 --> 00:43:05,680
insert query it's just going to insert a

1022
00:43:05,680 --> 00:43:09,600
bunch of records a bunch of unique

1023
00:43:09,600 --> 00:43:13,560
timestamps since 2015 - now at

1024
00:43:13,560 --> 00:43:16,720
one-minute intervals right and this is

1025
00:43:16,720 --> 00:43:19,870
gonna generate looks like to two million

1026
00:43:19,870 --> 00:43:23,920
records so in sake of time makes us go

1027
00:43:23,920 --> 00:43:25,720
fast so we'll PG warm everything now

1028
00:43:25,720 --> 00:43:27,940
everything's in our buffer pool so say

1029
00:43:27,940 --> 00:43:30,430
this is the query we want to run we want

1030
00:43:30,430 --> 00:43:32,940
to get the average ID of users where the

1031
00:43:32,940 --> 00:43:36,130
the day week is they logged in on the

1032
00:43:36,130 --> 00:43:39,370
Tuesday right so in this case here when

1033
00:43:39,370 --> 00:43:42,010
we run explain it has to do a sequential

1034
00:43:42,010 --> 00:43:46,270
scan there's no index so the first index

1035
00:43:46,270 --> 00:43:51,610
we can build is the expression index and

1036
00:43:51,610 --> 00:43:54,070
this shouldn't take long so now when we

1037
00:43:54,070 --> 00:43:56,530
run explain we can see that it's able to

1038
00:43:56,530 --> 00:43:58,960
pick out and use that expression index

1039
00:43:58,960 --> 00:44:02,200
we just built all right and again the

1040
00:44:02,200 --> 00:44:03,700
weight the way it did that it said oh I

1041
00:44:03,700 --> 00:44:05,520
know you're trying to do a look-up on

1042
00:44:05,520 --> 00:44:09,610
this you know extract function where and

1043
00:44:09,610 --> 00:44:11,380
where the output is - so

1044
00:44:11,380 --> 00:44:12,910
I just need to do a look up and say find

1045
00:44:12,910 --> 00:44:18,100
me all the values where it equals to so

1046
00:44:18,100 --> 00:44:22,960
then we can add the partial index again

1047
00:44:22,960 --> 00:44:24,880
this is now creating a smaller index

1048
00:44:24,880 --> 00:44:29,410
that only contains the ordered a it only

1049
00:44:29,410 --> 00:44:32,020
contains the the records where that

1050
00:44:32,020 --> 00:44:34,120
extract function equals to so now if I

1051
00:44:34,120 --> 00:44:36,460
go back to my function here and I see

1052
00:44:36,460 --> 00:44:38,140
now it actually wants to pick that index

1053
00:44:38,140 --> 00:44:40,960
because that's gonna be a commute

1054
00:44:40,960 --> 00:44:44,500
smaller less it's a the trees is is has

1055
00:44:44,500 --> 00:44:46,600
a lower height and I just find exactly

1056
00:44:46,600 --> 00:44:50,050
what I want immediately so again the

1057
00:44:50,050 --> 00:44:51,520
database system can figure out on its

1058
00:44:51,520 --> 00:44:53,530
own which is the best access method to

1059
00:44:53,530 --> 00:44:57,970
use for all these different choices all

1060
00:44:57,970 --> 00:45:02,220
right so any questions about this yes

1061
00:45:09,420 --> 00:45:13,480
okay so he said so let's try it out

1062
00:45:13,480 --> 00:45:18,160
right so drop index so save it is what

1063
00:45:18,160 --> 00:45:23,410
happens if my expression is a it's based

1064
00:45:23,410 --> 00:45:27,100
on some some difference or using the

1065
00:45:27,100 --> 00:45:29,560
current timestamp isn't that gonna

1066
00:45:29,560 --> 00:45:33,660
change every single time I run it so

1067
00:45:33,660 --> 00:45:36,600
look I think what post rest is gonna do

1068
00:45:36,600 --> 00:45:42,490
so let's let's do the let's do the

1069
00:45:42,490 --> 00:45:44,680
expression index where is that yeah so

1070
00:45:44,680 --> 00:45:48,670
he's saying do this take a login and

1071
00:45:48,670 --> 00:45:50,440
again I can put anything I want here

1072
00:45:50,440 --> 00:45:52,630
long as long as a valid expression so I

1073
00:45:52,630 --> 00:45:55,150
can say take my login and subtract out

1074
00:45:55,150 --> 00:46:02,350
now the current timestamp doesn't let

1075
00:46:02,350 --> 00:46:07,260
you do that okay how to do this in

1076
00:46:14,530 --> 00:46:16,940
yeah forget this forget Henry

1077
00:46:16,940 --> 00:46:20,560
subtraction in Postgres

1078
00:46:20,920 --> 00:46:27,370
can you do that that works okay

1079
00:46:27,370 --> 00:46:31,960
okay could you do this okay

1080
00:46:31,960 --> 00:46:39,470
nope now let's just do it let's do some

1081
00:46:39,470 --> 00:46:41,810
more so let's take a login subtract 100

1082
00:46:41,810 --> 00:46:48,110
from it didn't like that either yeah all

1083
00:46:48,110 --> 00:46:51,200
right so basically what happens when we

1084
00:46:51,200 --> 00:46:52,700
call create index it'll run the

1085
00:46:52,700 --> 00:46:53,990
malfunction once and whatever that

1086
00:46:53,990 --> 00:46:57,740
timestamp is now that now now later on

1087
00:46:57,740 --> 00:46:59,840
it doesn't change it's not dynamic it's

1088
00:46:59,840 --> 00:47:02,300
- as it builds the index so now if I

1089
00:47:02,300 --> 00:47:05,990
insert something again in theory it

1090
00:47:05,990 --> 00:47:10,160
should now use that the correct current

1091
00:47:10,160 --> 00:47:12,770
now if it's smart it could say well

1092
00:47:12,770 --> 00:47:14,450
wasn't now at the time when I built the

1093
00:47:14,450 --> 00:47:15,830
index I don't know whether it does that

1094
00:47:15,830 --> 00:47:18,230
or not but again so you can't do certain

1095
00:47:18,230 --> 00:47:22,610
stupid things like you can't do like one

1096
00:47:22,610 --> 00:47:24,620
build an index on one but I should be

1097
00:47:24,620 --> 00:47:28,790
able to do ID plus one now wait what am

1098
00:47:28,790 --> 00:47:36,340
i what am I missing here oh he's this

1099
00:47:36,340 --> 00:47:38,950
yeah that's what it was write them

1100
00:47:38,950 --> 00:47:42,260
double parenthesis so yeah so now I

1101
00:47:42,260 --> 00:47:45,560
can't and won't let me do this I don't

1102
00:47:45,560 --> 00:47:53,480
know I already user

1103
00:47:53,480 --> 00:47:56,900
log in expr let's try has a other

1104
00:47:56,900 --> 00:48:06,349
example functions an expression must be

1105
00:48:06,349 --> 00:48:09,500
mark immutable there go yeah but I

1106
00:48:09,500 --> 00:48:20,150
should be able to do this right like no

1107
00:48:20,150 --> 00:48:22,550
times that right anyway let's get my

1108
00:48:22,550 --> 00:48:22,940
point

1109
00:48:22,940 --> 00:48:26,780
yeah there's this thing called well cut

1110
00:48:26,780 --> 00:48:28,460
snapshots later on but like there's like

1111
00:48:28,460 --> 00:48:30,349
the now at the time the query runs and

1112
00:48:30,349 --> 00:48:33,700
it has to be guarantee that's consistent

1113
00:48:33,700 --> 00:48:38,680
for the snapshot would be index SL yes

1114
00:48:44,890 --> 00:48:48,140
so this question is when we create an

1115
00:48:48,140 --> 00:48:49,550
index what kind of index is going to

1116
00:48:49,550 --> 00:48:52,880
create so I so by default it's going to

1117
00:48:52,880 --> 00:48:56,480
create a B+ tree if I add that using

1118
00:48:56,480 --> 00:48:59,869
clause from before so this this is a

1119
00:48:59,869 --> 00:49:01,400
Postgres idiom this is not in the sequel

1120
00:49:01,400 --> 00:49:01,960
standard

1121
00:49:01,960 --> 00:49:05,930
so like if I add this using hash this

1122
00:49:05,930 --> 00:49:08,150
tells postgrads make me a hash index by

1123
00:49:08,150 --> 00:49:09,710
default everyone use you're gonna get a

1124
00:49:09,710 --> 00:49:24,829
B+ tree your question is when you add an

1125
00:49:24,829 --> 00:49:46,400
index you can make me put yes so when

1126
00:49:46,400 --> 00:49:47,329
you say you don't you don't need to look

1127
00:49:47,329 --> 00:49:54,020
at the leaf nodes of what they index all

1128
00:49:54,020 --> 00:49:55,819
right so I think your question is if I

1129
00:49:55,819 --> 00:49:58,640
have an index and if I do a lookup for

1130
00:49:58,640 --> 00:49:59,960
some queries I don't have to look at the

1131
00:49:59,960 --> 00:50:01,190
actual tuples I get to look at the

1132
00:50:01,190 --> 00:50:03,680
indexes yeah you were calling like the

1133
00:50:03,680 --> 00:50:05,750
tuples are you know in the table heap

1134
00:50:05,750 --> 00:50:07,070
don't they're not leaving

1135
00:50:07,070 --> 00:50:09,320
leaf-nosed are in the index right so I

1136
00:50:09,320 --> 00:50:10,790
always I always have to look at the

1137
00:50:10,790 --> 00:50:12,650
index because I in a B+ tree I always

1138
00:50:12,650 --> 00:50:15,320
have to go to the bottom okay so you for

1139
00:50:15,320 --> 00:50:16,940
some queries if you can do a covering

1140
00:50:16,940 --> 00:50:19,370
index lookup I never have to look at the

1141
00:50:19,370 --> 00:50:21,860
table the tuple I can get all the

1142
00:50:21,860 --> 00:50:24,080
information I need to compute the answer

1143
00:50:24,080 --> 00:50:27,350
from the index itself not all database

1144
00:50:27,350 --> 00:50:30,590
systems support that though for so for

1145
00:50:30,590 --> 00:50:31,970
what we talked about so far other than

1146
00:50:31,970 --> 00:50:34,460
covering indexes the idea is that we can

1147
00:50:34,460 --> 00:50:37,700
quickly find the the tuples that have

1148
00:50:37,700 --> 00:50:39,260
the keys that we want to look up one

1149
00:50:39,260 --> 00:50:41,210
without having to do is sequential scan

1150
00:50:41,210 --> 00:50:44,960
so so switch the scan is n if it's a if

1151
00:50:44,960 --> 00:50:47,570
it's a hash index I can do a 1 if it's a

1152
00:50:47,570 --> 00:50:51,680
B+ tree it's log n right so if the idea

1153
00:50:51,680 --> 00:50:53,510
is cutting down as much data as you can

1154
00:50:53,510 --> 00:50:57,760
to not look at not too wasted work

1155
00:51:02,800 --> 00:51:05,420
correct saving is if we create a table

1156
00:51:05,420 --> 00:51:07,070
and there's no index we always have to

1157
00:51:07,070 --> 00:51:08,570
do a special scan yes we told that in a

1158
00:51:08,570 --> 00:51:18,620
very beginning yes question is if I

1159
00:51:18,620 --> 00:51:21,410
create an index where does it live well

1160
00:51:21,410 --> 00:51:24,800
again if it's backed by disk it goes you

1161
00:51:24,800 --> 00:51:26,000
know it gets written out that you know

1162
00:51:26,000 --> 00:51:27,500
if it's backed by the buffer pool it

1163
00:51:27,500 --> 00:51:28,820
goes out to disk and I want to do that

1164
00:51:28,820 --> 00:51:30,230
because it's made my index might be

1165
00:51:30,230 --> 00:51:31,460
larger than the amount of memory that's

1166
00:51:31,460 --> 00:51:33,890
available to me so again I could have I

1167
00:51:33,890 --> 00:51:35,420
could have an ephemeral data structure

1168
00:51:35,420 --> 00:51:37,220
that's in memory and I have to blow that

1169
00:51:37,220 --> 00:51:39,080
away my sequel does that for for their

1170
00:51:39,080 --> 00:51:40,640
hash table because it has to be in a

1171
00:51:40,640 --> 00:51:42,440
memory but the B post tree is backed by

1172
00:51:42,440 --> 00:51:44,660
disk so as it gets too large I patient

1173
00:51:44,660 --> 00:51:58,580
things out we might separate hey they

1174
00:51:58,580 --> 00:51:59,870
could be the same buffer pool it could

1175
00:51:59,870 --> 00:52:01,520
be different of a pool instances it

1176
00:52:01,520 --> 00:52:04,190
depends on implementation again the

1177
00:52:04,190 --> 00:52:05,780
buffer pool manager doesn't know what's

1178
00:52:05,780 --> 00:52:07,700
inside the pages it says you want page 1

1179
00:52:07,700 --> 00:52:10,760
2 3 here it is and then whoever is is is

1180
00:52:10,760 --> 00:52:13,190
accessing it is responsible to know how

1181
00:52:13,190 --> 00:52:15,470
to interpret those bytes buffle minute

1182
00:52:15,470 --> 00:52:17,360
doesn't know doesn't care in the

1183
00:52:17,360 --> 00:52:18,920
high-end systems you can say here's the

1184
00:52:18,920 --> 00:52:20,570
buffer pool manage for indexes

1185
00:52:20,570 --> 00:52:22,340
has certain replacement policies and

1186
00:52:22,340 --> 00:52:23,450
here's one for tables they have another

1187
00:52:23,450 --> 00:52:26,360
replacement policy proposal SMI sequel

1188
00:52:26,360 --> 00:52:33,920
it's all the same okay so um let's now

1189
00:52:33,920 --> 00:52:40,720
jump back and finish up with tries okay

1190
00:52:41,860 --> 00:52:45,740
so in all the examples that show for the

1191
00:52:45,740 --> 00:52:49,760
people's tree so far the the inner nodes

1192
00:52:49,760 --> 00:52:53,390
and the leaf nodes always had an exact

1193
00:52:53,390 --> 00:52:55,820
copy of the keys yes you can do prefix

1194
00:52:55,820 --> 00:52:57,230
compression or suffix truncation as we

1195
00:52:57,230 --> 00:52:59,300
talked about last time but in general we

1196
00:52:59,300 --> 00:53:00,970
have the entire copy of the key

1197
00:53:00,970 --> 00:53:02,990
replicated multiple times throughout

1198
00:53:02,990 --> 00:53:06,460
throughout the the tree structure and so

1199
00:53:06,460 --> 00:53:08,840
the other issues gonna be also into

1200
00:53:08,840 --> 00:53:11,360
people's tree is that in order for me to

1201
00:53:11,360 --> 00:53:14,690
determine whether key exists in my table

1202
00:53:14,690 --> 00:53:17,900
I always have to get to the leaf node I

1203
00:53:17,900 --> 00:53:19,070
always have to traverse all the way to

1204
00:53:19,070 --> 00:53:23,330
the bottom right because again the inner

1205
00:53:23,330 --> 00:53:25,580
nodes may have copies of keys that don't

1206
00:53:25,580 --> 00:53:27,140
no longer exist because when I delete

1207
00:53:27,140 --> 00:53:29,030
them from the leaf node depending on how

1208
00:53:29,030 --> 00:53:30,920
I split merge I may have left my

1209
00:53:30,920 --> 00:53:33,020
guidepost up above so in order to

1210
00:53:33,020 --> 00:53:34,370
determine whether I know exactly this

1211
00:53:34,370 --> 00:53:35,750
key exists I always have to go to the

1212
00:53:35,750 --> 00:53:39,830
leaf node so this you know again it's

1213
00:53:39,830 --> 00:53:42,230
login instead of set of Oh n you have to

1214
00:53:42,230 --> 00:53:43,460
do to central scam but it's still not

1215
00:53:43,460 --> 00:53:45,290
great and I may have you know depending

1216
00:53:45,290 --> 00:53:47,210
on how much memory I have and how I'm

1217
00:53:47,210 --> 00:53:49,550
using my buffer pool manager I may have

1218
00:53:49,550 --> 00:53:51,230
a page miss right they do a lookup on

1219
00:53:51,230 --> 00:53:53,390
disk for every single node as I'd

1220
00:53:53,390 --> 00:53:56,780
reversed down so for some applications

1221
00:53:56,780 --> 00:53:58,220
it might be nice if we can actually

1222
00:53:58,220 --> 00:54:00,640
figure out at the top of the tree

1223
00:54:00,640 --> 00:54:03,140
whether our key exists without having to

1224
00:54:03,140 --> 00:54:06,080
go all the way to the bottom so this is

1225
00:54:06,080 --> 00:54:08,090
what a tribe does for us so quick show

1226
00:54:08,090 --> 00:54:09,520
of hands who here is her to try before

1227
00:54:09,520 --> 00:54:11,120
okay perfect

1228
00:54:11,120 --> 00:54:14,810
who here has heard of radix tree fuer

1229
00:54:14,810 --> 00:54:17,600
excellent okay so so radix tree is just

1230
00:54:17,600 --> 00:54:20,450
a specialization of a try and nobody

1231
00:54:20,450 --> 00:54:21,950
uses chives everyone uses radix treats

1232
00:54:21,950 --> 00:54:23,180
and databases so what we'll go through

1233
00:54:23,180 --> 00:54:26,570
this so a try is a tree data structure

1234
00:54:26,570 --> 00:54:28,490
where instead of storing the entire

1235
00:54:28,490 --> 00:54:31,700
copies of keys in our nodes in the tree

1236
00:54:31,700 --> 00:54:34,370
we're instead going to store digits of

1237
00:54:34,370 --> 00:54:36,410
key and by digits I don't necessarily

1238
00:54:36,410 --> 00:54:39,800
mean Arabic numerals I mean some some

1239
00:54:39,800 --> 00:54:42,920
subset atomic subset of our key like a

1240
00:54:42,920 --> 00:54:46,610
bite some or some a single bit and so

1241
00:54:46,610 --> 00:54:48,050
what happens is that we're basically

1242
00:54:48,050 --> 00:54:50,990
gonna decompose all our keys and store

1243
00:54:50,990 --> 00:54:53,620
them down the digits down you know

1244
00:54:53,620 --> 00:54:56,810
different levels one by one and then now

1245
00:54:56,810 --> 00:54:59,060
because we could have duplicated keys or

1246
00:54:59,060 --> 00:55:01,100
duplicated digits we only need to store

1247
00:55:01,100 --> 00:55:04,400
that once at each level so a really

1248
00:55:04,400 --> 00:55:06,200
simple example here would be a try like

1249
00:55:06,200 --> 00:55:08,390
this where I have three keys hello hat

1250
00:55:08,390 --> 00:55:10,730
and have so in the first level in the

1251
00:55:10,730 --> 00:55:12,980
root node all three keys begin with the

1252
00:55:12,980 --> 00:55:15,260
letter H so I sort each once and there's

1253
00:55:15,260 --> 00:55:17,450
a path down to the second level where

1254
00:55:17,450 --> 00:55:20,150
now I see I distinguish between hello

1255
00:55:20,150 --> 00:55:23,090
and hadn't have hello has an e hat and

1256
00:55:23,090 --> 00:55:25,700
have have an A for the second digit so I

1257
00:55:25,700 --> 00:55:27,470
have separate entries for that and then

1258
00:55:27,470 --> 00:55:29,600
now I have separate paths down to handle

1259
00:55:29,600 --> 00:55:31,640
for you know each each unique path in

1260
00:55:31,640 --> 00:55:34,460
the key so now if I want to look up say

1261
00:55:34,460 --> 00:55:35,660
I want to look up hello

1262
00:55:35,660 --> 00:55:37,670
I guess decompose it the key into its

1263
00:55:37,670 --> 00:55:39,890
digits and I look at the H I have a

1264
00:55:39,890 --> 00:55:42,020
match here I find the E and then I

1265
00:55:42,020 --> 00:55:44,930
tourist down ello oh and the bottom is

1266
00:55:44,930 --> 00:55:47,810
just like our and our B plus tree this

1267
00:55:47,810 --> 00:55:49,790
could be a record ID that points to the

1268
00:55:49,790 --> 00:55:52,060
actual tuple that we're looking for so

1269
00:55:52,060 --> 00:55:54,350
tries are old tries are older than B

1270
00:55:54,350 --> 00:55:56,450
plus trees or D plus trees were embedded

1271
00:55:56,450 --> 00:56:00,050
or in like 1973 at IBM tries are

1272
00:56:00,050 --> 00:56:02,840
actually from invented in like 1959 by

1273
00:56:02,840 --> 00:56:05,150
this French dude and he didn't have a

1274
00:56:05,150 --> 00:56:06,740
name for it and then there was another

1275
00:56:06,740 --> 00:56:09,440
CS researcher the famous guy ever defend

1276
00:56:09,440 --> 00:56:11,570
Caen and then a year or two later he

1277
00:56:11,570 --> 00:56:14,810
proposed the name try which is short for

1278
00:56:14,810 --> 00:56:17,210
retrieval tree and he was using that to

1279
00:56:17,210 --> 00:56:18,680
distinguish from from a regular tree

1280
00:56:18,680 --> 00:56:20,840
data structure so this is why they're

1281
00:56:20,840 --> 00:56:22,910
called tries and apparently this F M can

1282
00:56:22,910 --> 00:56:25,040
guy is actually seeing you faculty to

1283
00:56:25,040 --> 00:56:26,570
get a look at the you know the the CS

1284
00:56:26,570 --> 00:56:28,370
website the directory he's listed there

1285
00:56:28,370 --> 00:56:31,070
he's like super old I've never seen many

1286
00:56:31,070 --> 00:56:32,420
faculty mean I don't know who he is I

1287
00:56:32,420 --> 00:56:33,830
don't he's actually still here but

1288
00:56:33,830 --> 00:56:34,910
that's the guy that invented the term

1289
00:56:34,910 --> 00:56:36,710
try he's actually here at CMU supposedly

1290
00:56:36,710 --> 00:56:39,110
so sometimes you also see these things

1291
00:56:39,110 --> 00:56:40,850
listed as digital search trees or prefix

1292
00:56:40,850 --> 00:56:42,560
trees as far as I know these are all

1293
00:56:42,560 --> 00:56:45,620
these are all the same thing so tries

1294
00:56:45,620 --> 00:56:47,180
are really interesting right in the

1295
00:56:47,180 --> 00:56:48,350
concept of databases

1296
00:56:48,350 --> 00:56:50,150
all right you know now that we

1297
00:56:50,150 --> 00:56:52,340
understand people streets so the first

1298
00:56:52,340 --> 00:56:53,210
thing that's super interesting about

1299
00:56:53,210 --> 00:56:56,510
them is that their shape only depends on

1300
00:56:56,510 --> 00:56:59,060
the the key distribution of the key

1301
00:56:59,060 --> 00:57:01,670
spaces and their length so what I mean

1302
00:57:01,670 --> 00:57:03,320
by that is it's a deterministic data

1303
00:57:03,320 --> 00:57:04,940
structure so no matter what order we

1304
00:57:04,940 --> 00:57:06,770
insert the keys we're always going to

1305
00:57:06,770 --> 00:57:08,780
end up with the same shape of the

1306
00:57:08,780 --> 00:57:10,730
physical data structure all right that's

1307
00:57:10,730 --> 00:57:12,380
not the same thing as in a B plus tree

1308
00:57:12,380 --> 00:57:13,610
because in B plus tree if I insert a

1309
00:57:13,610 --> 00:57:15,650
keys one way and then I shuffle them

1310
00:57:15,650 --> 00:57:17,150
around and then and I sort them to

1311
00:57:17,150 --> 00:57:18,950
another tree depending on how I do is

1312
00:57:18,950 --> 00:57:20,930
split the merges I may end up with

1313
00:57:20,930 --> 00:57:22,160
different layouts of the note the keys

1314
00:57:22,160 --> 00:57:23,600
might be in one node versus another note

1315
00:57:23,600 --> 00:57:26,240
in a try it's always it's always the

1316
00:57:26,240 --> 00:57:29,150
same thing all right the other thing

1317
00:57:29,150 --> 00:57:30,170
about them is that they don't actually

1318
00:57:30,170 --> 00:57:32,090
require any any rebalancing like we had

1319
00:57:32,090 --> 00:57:35,810
in the P plus tree so we'll see you know

1320
00:57:35,810 --> 00:57:37,880
there is some rebalancing we could do

1321
00:57:37,880 --> 00:57:39,680
that at the vertical level but

1322
00:57:39,680 --> 00:57:41,240
horizontally we're never actually gonna

1323
00:57:41,240 --> 00:57:45,470
potentially rebalance so an unlike in a

1324
00:57:45,470 --> 00:57:47,450
B plus tree where all the operations

1325
00:57:47,450 --> 00:57:50,600
were login in a try the operation

1326
00:57:50,600 --> 00:57:53,330
complexity is K where K is the length of

1327
00:57:53,330 --> 00:57:56,060
the key all right this is totally

1328
00:57:56,060 --> 00:57:57,170
different than gonna be plus tree so

1329
00:57:57,170 --> 00:57:59,630
going back here so if I want to look up

1330
00:57:59,630 --> 00:58:02,840
hello I by the time I get here I know

1331
00:58:02,840 --> 00:58:04,340
that there's no you know I keep going

1332
00:58:04,340 --> 00:58:06,500
down the bottom but so the number of

1333
00:58:06,500 --> 00:58:07,640
steps I have to do is dependent on the

1334
00:58:07,640 --> 00:58:09,110
key that I'm looking up but say I'm

1335
00:58:09,110 --> 00:58:11,870
gonna look up and II am dy the first

1336
00:58:11,870 --> 00:58:14,090
letter is a I look up in the root node I

1337
00:58:14,090 --> 00:58:16,100
see it only has an H I immediately stop

1338
00:58:16,100 --> 00:58:17,630
and I know the thing I'm looking for it

1339
00:58:17,630 --> 00:58:19,370
can't be anywhere else in the tree and I

1340
00:58:19,370 --> 00:58:20,480
don't have to always Traverse in the

1341
00:58:20,480 --> 00:58:27,290
bottom yes your question is for the e

1342
00:58:27,290 --> 00:58:28,940
here do I have to iterate across the

1343
00:58:28,940 --> 00:58:40,310
entire block so this game is if this

1344
00:58:40,310 --> 00:58:43,610
thing is super wide does that does that

1345
00:58:43,610 --> 00:58:45,470
mean I have to switch the scan across

1346
00:58:45,470 --> 00:58:48,890
the entire thing you presort them as you

1347
00:58:48,890 --> 00:58:50,390
do binary search to find what you're

1348
00:58:50,390 --> 00:58:51,830
looking for well when we see actually

1349
00:58:51,830 --> 00:58:53,510
how we actually do this in like for like

1350
00:58:53,510 --> 00:58:56,570
bites you you can just jump exactly to

1351
00:58:56,570 --> 00:58:58,250
the position you want it's either there

1352
00:58:58,250 --> 00:58:59,309
or not there

1353
00:58:59,309 --> 00:59:01,079
yeah this is not really you know

1354
00:59:01,079 --> 00:59:02,339
physical diagram I thought I was

1355
00:59:02,339 --> 00:59:03,390
actually stored this is just a high

1356
00:59:03,390 --> 00:59:07,259
level overview okay

1357
00:59:07,259 --> 00:59:08,969
so again this is super interesting

1358
00:59:08,969 --> 00:59:11,459
because that the fact that like the the

1359
00:59:11,459 --> 00:59:12,809
complexity is based on the key that

1360
00:59:12,809 --> 00:59:14,630
we're trying to look up on the length

1361
00:59:14,630 --> 00:59:17,059
it's also interesting because now the

1362
00:59:17,059 --> 00:59:20,429
the we're not storing the exact copy of

1363
00:59:20,429 --> 00:59:22,589
the key you know directly in any single

1364
00:59:22,589 --> 00:59:24,289
node it's implicitly stored by the path

1365
00:59:24,289 --> 00:59:26,880
so if we if we want to reconstruct hello

1366
00:59:26,880 --> 00:59:29,400
we would Traverse down keep track of our

1367
00:59:29,400 --> 00:59:30,900
path on the stack and that that's how we

1368
00:59:30,900 --> 00:59:32,539
can put the key back together

1369
00:59:32,539 --> 00:59:34,529
whereas now this makes sequential scans

1370
00:59:34,529 --> 00:59:36,869
more difficult because although I can be

1371
00:59:36,869 --> 00:59:37,589
in sorted order

1372
00:59:37,589 --> 00:59:40,499
I got a backtrack and you know go back

1373
00:59:40,499 --> 00:59:42,989
up and go back down unlike in the B plus

1374
00:59:42,989 --> 00:59:44,130
tree where I can scan along the leaf

1375
00:59:44,130 --> 00:59:46,169
nodes so tries are gonna be faster for

1376
00:59:46,169 --> 00:59:48,539
point queries then a B plus tree but

1377
00:59:48,539 --> 00:59:49,949
they're gonna be slower than first of

1378
00:59:49,949 --> 00:59:54,359
her scans all right so now we get bit

1379
00:59:54,359 --> 00:59:56,189
more formal talk about the definition of

1380
00:59:56,189 --> 00:59:59,029
a try so but we would use the term

1381
00:59:59,029 --> 01:00:01,999
spanned to the same way in a B plus tree

1382
01:00:01,999 --> 01:00:04,709
for of a node just to say the span is

1383
01:00:04,709 --> 01:00:07,679
the number of outgoing branches is

1384
01:00:07,679 --> 01:00:09,029
essentially the number of digits we're

1385
01:00:09,029 --> 01:00:13,169
going to represent in in you know each

1386
01:00:13,169 --> 01:00:16,559
node in each level so if a digit is

1387
01:00:16,559 --> 01:00:19,349
gonna exist in the corpus then at the

1388
01:00:19,349 --> 01:00:20,969
level at each digit we do have to have a

1389
01:00:20,969 --> 01:00:22,709
pointer now to another branch if it

1390
01:00:22,709 --> 01:00:24,390
doesn't exist in our corpus at a level

1391
01:00:24,390 --> 01:00:27,029
then we just or null like a little bit

1392
01:00:27,029 --> 01:00:29,669
or something so now this this span is

1393
01:00:29,669 --> 01:00:31,229
gonna use B to determine the fan-out

1394
01:00:31,229 --> 01:00:34,229
just like again in a B+ tree and that's

1395
01:00:34,229 --> 01:00:35,849
can then correspond to the physical

1396
01:00:35,849 --> 01:00:38,849
height of the try so the parlance you

1397
01:00:38,849 --> 01:00:40,709
would say I have an N way try you would

1398
01:00:40,709 --> 01:00:42,809
say you have a fan out of order N and

1399
01:00:42,809 --> 01:00:44,489
it's the number pass coming out and

1400
01:00:44,489 --> 01:00:46,619
that's going to Turman the size of the

1401
01:00:46,619 --> 01:00:50,179
the digit you're storing at each level

1402
01:00:50,179 --> 01:00:53,339
so the most simple try you can store is

1403
01:00:53,339 --> 01:00:56,519
a one bit try right so they eat each

1404
01:00:56,519 --> 01:00:59,939
level I'm gonna discriminate the a digit

1405
01:00:59,939 --> 01:01:03,239
for of a single bit so let's say I want

1406
01:01:03,239 --> 01:01:06,659
to start these three keys 1025 and 31 so

1407
01:01:06,659 --> 01:01:08,759
it's a 1 bit tries I mean at each each

1408
01:01:08,759 --> 01:01:10,140
level we're gonna we're gonna look at

1409
01:01:10,140 --> 01:01:12,900
one bit so I'm showing them in you know

1410
01:01:12,900 --> 01:01:14,790
the binary form of these two numbers or

1411
01:01:14,790 --> 01:01:16,590
the three numbers again normally these

1412
01:01:16,590 --> 01:01:19,170
would be 32-bit or 64-bit but for

1413
01:01:19,170 --> 01:01:20,670
simplicity reasons I'm showing them in

1414
01:01:20,670 --> 01:01:25,020
in 16 bits so at the try would look like

1415
01:01:25,020 --> 01:01:27,600
this and I'll go through it each level

1416
01:01:27,600 --> 01:01:29,910
so at the root node we're gonna examine

1417
01:01:29,910 --> 01:01:32,280
the first digit position the first bit

1418
01:01:32,280 --> 01:01:35,460
and again it's a it's one way it's one

1419
01:01:35,460 --> 01:01:40,170
bit so it's either 0 or 1 so in this

1420
01:01:40,170 --> 01:01:43,290
first position all three keys have have

1421
01:01:43,290 --> 01:01:47,310
bit set to 0 so at bit 0 I have a path

1422
01:01:47,310 --> 01:01:49,410
going down at bit 1 is null because

1423
01:01:49,410 --> 01:01:52,170
there's no key that matches that then I

1424
01:01:52,170 --> 01:01:54,750
go now down to the second level and for

1425
01:01:54,750 --> 01:01:57,000
simplicity reasons we're just gonna

1426
01:01:57,000 --> 01:01:58,470
repeat this think of this repeating

1427
01:01:58,470 --> 01:02:00,540
across 10 times right but it's gonna be

1428
01:02:00,540 --> 01:02:02,880
the same thing I have a 0 all my all my

1429
01:02:02,880 --> 01:02:05,880
tuples are keys have a 0 at every single

1430
01:02:05,880 --> 01:02:07,410
position and have a path going down and

1431
01:02:07,410 --> 01:02:10,290
one doesn't have anything but now when I

1432
01:02:10,290 --> 01:02:12,390
get to this position here now I see that

1433
01:02:12,390 --> 01:02:15,840
there's a difference so for key 10 it's

1434
01:02:15,840 --> 01:02:18,870
bit this dish at this position is 0 so

1435
01:02:18,870 --> 01:02:20,100
there's a path going down to this side

1436
01:02:20,100 --> 01:02:22,740
for the other two it's a it's one so as

1437
01:02:22,740 --> 01:02:25,950
the path going down here so now if I

1438
01:02:25,950 --> 01:02:27,840
look at say the remaining part of this

1439
01:02:27,840 --> 01:02:29,940
key again it's a single path going down

1440
01:02:29,940 --> 01:02:32,760
and it's you know it's 1 0 1 0 and same

1441
01:02:32,760 --> 01:02:34,410
thing if it's null I have there's

1442
01:02:34,410 --> 01:02:36,180
there's no the bit if not said at that

1443
01:02:36,180 --> 01:02:38,850
position it's null otherwise it's a path

1444
01:02:38,850 --> 01:02:40,890
going down and then the leaf node again

1445
01:02:40,890 --> 01:02:42,830
this is just a record IDE that points to

1446
01:02:42,830 --> 01:02:46,350
the corresponding tuple same thing for

1447
01:02:46,350 --> 01:02:48,090
the other side right at this point here

1448
01:02:48,090 --> 01:02:49,680
they're the same but then they split

1449
01:02:49,680 --> 01:02:51,390
here and then now I have separate paths

1450
01:02:51,390 --> 01:02:53,640
for the other parts right is this

1451
01:02:53,640 --> 01:02:55,230
covered you know you know so we can do

1452
01:02:55,230 --> 01:02:57,420
this in 1 bit 2 bits 8-bits 16-bits we

1453
01:02:57,420 --> 01:02:58,530
can do this at different levels

1454
01:02:58,530 --> 01:03:02,730
different granularities so what's one

1455
01:03:02,730 --> 01:03:06,080
simple optimization we can do for this

1456
01:03:06,080 --> 01:03:09,390
there's actually two optimizations how

1457
01:03:09,390 --> 01:03:14,330
can we reduce the size of this tribe yes

1458
01:03:14,360 --> 01:03:17,400
exactly so he says we don't need spaces

1459
01:03:17,400 --> 01:03:19,530
marked zeros and ones because what is

1460
01:03:19,530 --> 01:03:21,090
this saying right so again this is this

1461
01:03:21,090 --> 01:03:22,740
is the value at this digit in this

1462
01:03:22,740 --> 01:03:24,360
position and then here's the pointer for

1463
01:03:24,360 --> 01:03:26,610
it so this is redundant

1464
01:03:26,610 --> 01:03:29,010
so all I really need to do is just store

1465
01:03:29,010 --> 01:03:31,710
the pointers right because if it's if it

1466
01:03:31,710 --> 01:03:33,300
at if the bid is set to zero and one

1467
01:03:33,300 --> 01:03:34,890
offset zero the better set the one I go

1468
01:03:34,890 --> 01:03:37,260
to offset one so this is horizontal

1469
01:03:37,260 --> 01:03:39,930
compression this is reducing the size of

1470
01:03:39,930 --> 01:03:42,930
of the tribe each try node what's

1471
01:03:42,930 --> 01:03:44,430
another compression weight where I could

1472
01:03:44,430 --> 01:03:47,450
compress us in the back

1473
01:03:47,870 --> 01:03:49,860
he says repeating the numbers there are

1474
01:03:49,860 --> 01:03:51,720
ten times for this one you actually have

1475
01:03:51,720 --> 01:03:58,470
to have so once I get down here these

1476
01:03:58,470 --> 01:04:00,570
parts here there's no other key that

1477
01:04:00,570 --> 01:04:03,510
matches this and sort of what he was

1478
01:04:03,510 --> 01:04:05,640
saying but but but up here breather

1479
01:04:05,640 --> 01:04:06,690
right we had to keep this is because

1480
01:04:06,690 --> 01:04:07,950
we're gonna split here so we need to

1481
01:04:07,950 --> 01:04:10,740
know how we got down to here so but

1482
01:04:10,740 --> 01:04:12,030
after this we don't need to store

1483
01:04:12,030 --> 01:04:14,100
anything mean stack into store well if

1484
01:04:14,100 --> 01:04:16,200
you go down here at this position at

1485
01:04:16,200 --> 01:04:18,480
this level if the bid is zero I only

1486
01:04:18,480 --> 01:04:20,040
have one key that matches so let me

1487
01:04:20,040 --> 01:04:21,810
destroy the tuple pointer to to that key

1488
01:04:21,810 --> 01:04:25,350
and then same thing over here so this is

1489
01:04:25,350 --> 01:04:38,340
vertical compression yes your question

1490
01:04:38,340 --> 01:04:40,680
is incentive story city instead of

1491
01:04:40,680 --> 01:05:01,050
storing the website yes this is like a

1492
01:05:01,050 --> 01:05:02,850
low mark opposition there's like CPU

1493
01:05:02,850 --> 01:05:05,340
instructions to get you can run in a

1494
01:05:05,340 --> 01:05:07,320
single structure in for like a for a bit

1495
01:05:07,320 --> 01:05:10,050
bit map a bit sequence find either

1496
01:05:10,050 --> 01:05:12,360
finding the the value at this offset in

1497
01:05:12,360 --> 01:05:13,740
some instruction you don't have to

1498
01:05:13,740 --> 01:05:16,320
iterate or like you find me you count me

1499
01:05:16,320 --> 01:05:19,020
the number of ones in my in this bit bit

1500
01:05:19,020 --> 01:05:21,030
field right there's a CPU instructions

1501
01:05:21,030 --> 01:05:23,130
to make this go really fast so it's not

1502
01:05:23,130 --> 01:05:24,690
like you're just doing like an in a for

1503
01:05:24,690 --> 01:05:25,920
loops quench like scanning over this

1504
01:05:25,920 --> 01:05:30,300
it's not as bad as you think it is okay

1505
01:05:30,300 --> 01:05:32,010
so again this is like low-level bit

1506
01:05:32,010 --> 01:05:33,900
information but it's showing you at the

1507
01:05:33,900 --> 01:05:36,960
extreme case you wouldn't actual

1508
01:05:36,960 --> 01:05:39,150
try usually you want to store them as

1509
01:05:39,150 --> 01:05:40,420
eight bits or

1510
01:05:40,420 --> 01:05:43,060
and a bite but for me this is the

1511
01:05:43,060 --> 01:05:44,650
easiest way to understand this and so

1512
01:05:44,650 --> 01:05:46,630
even now if it's eight bits same thing

1513
01:05:46,630 --> 01:05:48,370
for every single position I just have a

1514
01:05:48,370 --> 01:05:50,620
pointer or not and then quickly jump to

1515
01:05:50,620 --> 01:05:54,640
the one you also that I want so this is

1516
01:05:54,640 --> 01:05:56,320
fine and dandy if everything's static

1517
01:05:56,320 --> 01:05:59,800
but actually how do we how do we modify

1518
01:05:59,800 --> 01:06:01,060
this thing every do inserts and updates

1519
01:06:01,060 --> 01:06:04,510
and deletes so there is no standard way

1520
01:06:04,510 --> 01:06:07,630
to maintain a try in the way that there

1521
01:06:07,630 --> 01:06:09,460
was for a B+ tree different

1522
01:06:09,460 --> 01:06:12,010
implementations do different things so

1523
01:06:12,010 --> 01:06:13,750
I'm going to show you sir one brief

1524
01:06:13,750 --> 01:06:15,310
example I'm not saying this is the only

1525
01:06:15,310 --> 01:06:16,810
way to do this but just some of the

1526
01:06:16,810 --> 01:06:18,250
things you have to be mindful if you're

1527
01:06:18,250 --> 01:06:20,230
actually trying to build one let's say

1528
01:06:20,230 --> 01:06:22,180
again this is the hello hat and have key

1529
01:06:22,180 --> 01:06:25,000
set we had before so I insert hair again

1530
01:06:25,000 --> 01:06:26,530
I just reverse down I would find this

1531
01:06:26,530 --> 01:06:28,300
slot here and now I can serve this into

1532
01:06:28,300 --> 01:06:31,570
this alright so now let's say I want to

1533
01:06:31,570 --> 01:06:33,970
delete hat well that's here I go ahead

1534
01:06:33,970 --> 01:06:36,010
and delete that and rather than

1535
01:06:36,010 --> 01:06:37,510
reshuffling everything maybe it's okay

1536
01:06:37,510 --> 01:06:39,580
for me to leave an empty space here

1537
01:06:39,580 --> 01:06:41,770
right because then I don't throw the cap

1538
01:06:41,770 --> 01:06:43,540
action but now let's say I do lead have

1539
01:06:43,540 --> 01:06:46,420
and now I remove this and I say well now

1540
01:06:46,420 --> 01:06:49,570
I have this this note here by itself and

1541
01:06:49,570 --> 01:06:51,640
so if I want to you know actually find

1542
01:06:51,640 --> 01:06:53,710
hair I'd have to you know do an extra

1543
01:06:53,710 --> 01:06:55,300
hop to go down I are but I know I'm not

1544
01:06:55,300 --> 01:06:57,280
gonna have any other match so you could

1545
01:06:57,280 --> 01:06:59,200
decide just to roll everything up and

1546
01:06:59,200 --> 01:07:02,590
put it up here different again different

1547
01:07:02,590 --> 01:07:04,930
implementations use different things if

1548
01:07:04,930 --> 01:07:06,280
you take the advanced class will cover a

1549
01:07:06,280 --> 01:07:15,670
bunch of these things yes yes yeah you

1550
01:07:15,670 --> 01:07:18,010
mean real clear the radix tree is one

1551
01:07:18,010 --> 01:07:21,430
that's vertically compressed uh yeah I

1552
01:07:21,430 --> 01:07:22,360
should I should align without more

1553
01:07:22,360 --> 01:07:29,830
carefully yeah I don't on the slide yeah

1554
01:07:29,830 --> 01:07:31,480
radix tree is is a is one where you

1555
01:07:31,480 --> 01:07:34,840
remove all the path yeah positive I

1556
01:07:34,840 --> 01:07:36,490
don't know what I don't use to be a

1557
01:07:36,490 --> 01:07:37,660
slide here is defined what a radix

1558
01:07:37,660 --> 01:07:42,700
treaty I don't happen to it sorry okay

1559
01:07:42,700 --> 01:07:44,020
no this is it sorry this is the radius

1560
01:07:44,020 --> 01:07:44,260
tree

1561
01:07:44,260 --> 01:07:46,450
sorry it's when you do the vertical

1562
01:07:46,450 --> 01:07:50,110
compression to remove any any nodes

1563
01:07:50,110 --> 01:07:51,300
where there's no other distinct

1564
01:07:51,300 --> 01:07:53,710
differentiating path below it

1565
01:07:53,710 --> 01:07:55,030
sometimes called Patricia tree but

1566
01:07:55,030 --> 01:07:57,880
usually the call radix trees and again

1567
01:07:57,880 --> 01:08:02,290
it's a subset of a try okay so he

1568
01:08:02,290 --> 01:08:03,579
covered markets and the last thing I

1569
01:08:03,579 --> 01:08:07,720
wanna PP talk about is actually how we

1570
01:08:07,720 --> 01:08:09,490
do comparison actually the sake of time

1571
01:08:09,490 --> 01:08:11,319
I'm gonna skip that let's the last one

1572
01:08:11,319 --> 01:08:14,680
sideways inverted indexes again tries

1573
01:08:14,680 --> 01:08:17,799
are super interesting no commercial data

1574
01:08:17,799 --> 01:08:21,009
system as far as I know supports them

1575
01:08:21,009 --> 01:08:26,250
out of the box hyper is a system out of

1576
01:08:26,250 --> 01:08:29,710
of from Germany that tableau bought that

1577
01:08:29,710 --> 01:08:31,750
runs in you know tableaus its post was

1578
01:08:31,750 --> 01:08:34,420
compatible there they're all in on try

1579
01:08:34,420 --> 01:08:36,040
we do some research here on tries

1580
01:08:36,040 --> 01:08:37,420
they're super interesting but right now

1581
01:08:37,420 --> 01:08:39,100
the B+ tree is still the dominant data

1582
01:08:39,100 --> 01:08:41,020
structure everyone uses but there's a

1583
01:08:41,020 --> 01:08:44,710
lot of interest in them alright so so

1584
01:08:44,710 --> 01:08:46,719
real quickly everything that we talked

1585
01:08:46,719 --> 01:08:49,479
about so far have for these indexes have

1586
01:08:49,479 --> 01:08:52,179
been satisfying or handling index or

1587
01:08:52,179 --> 01:08:54,339
point queries and range queries so I

1588
01:08:54,339 --> 01:08:55,660
want to find out you know record where

1589
01:08:55,660 --> 01:08:57,850
it's people that live in zip code one

1590
01:08:57,850 --> 01:08:58,870
one five two one seven

1591
01:08:58,870 --> 01:09:00,880
all right that's an equality predicate

1592
01:09:00,880 --> 01:09:01,988
to find exactly the thing I'm looking

1593
01:09:01,988 --> 01:09:04,089
for or if I'm trying to find things

1594
01:09:04,089 --> 01:09:06,219
within date ranges right that's a range

1595
01:09:06,219 --> 01:09:08,350
scan okay again I can use user people a

1596
01:09:08,350 --> 01:09:11,020
street for that where the Bevo's tree

1597
01:09:11,020 --> 01:09:12,969
and the hash index hash tables are not

1598
01:09:12,969 --> 01:09:15,250
good for us when we want to do keyword

1599
01:09:15,250 --> 01:09:18,160
searches so for example say I have the

1600
01:09:18,160 --> 01:09:20,710
entire corpus of Wikipedia I'm gonna

1601
01:09:20,710 --> 01:09:22,390
find all the blue key bead Wikipedia

1602
01:09:22,390 --> 01:09:24,399
articles that that contain the keyword

1603
01:09:24,399 --> 01:09:27,460
Pablo I can't use a hash table index for

1604
01:09:27,460 --> 01:09:29,649
that and I can't use a B+ tree index for

1605
01:09:29,649 --> 01:09:31,810
that because I'm trying to find a sub

1606
01:09:31,810 --> 01:09:35,850
element of above value for an attribute

1607
01:09:35,850 --> 01:09:38,080
right and the candidate for the B+ tree

1608
01:09:38,080 --> 01:09:41,259
and I had to have the exact key I can't

1609
01:09:41,259 --> 01:09:43,270
do a partial key you know I can do a

1610
01:09:43,270 --> 01:09:45,310
partial key lookup but the if the key is

1611
01:09:45,310 --> 01:09:47,080
comprised of multiple attributes but

1612
01:09:47,080 --> 01:09:48,759
within single attribute I have to have

1613
01:09:48,759 --> 01:09:50,770
the entire value of it I can't have like

1614
01:09:50,770 --> 01:09:55,300
the first 16 bits so this is the problem

1615
01:09:55,300 --> 01:09:56,530
we're trying to solve here so quickly

1616
01:09:56,530 --> 01:09:58,210
just again just remind everyone what

1617
01:09:58,210 --> 01:10:00,130
wikipedia looks like the main thing we

1618
01:10:00,130 --> 01:10:01,030
care about is that there's this

1619
01:10:01,030 --> 01:10:03,760
revisions table that has a has a tech

1620
01:10:03,760 --> 01:10:06,310
that's my bookie sorry that has big text

1621
01:10:06,310 --> 01:10:07,269
field

1622
01:10:07,269 --> 01:10:08,650
all right and we want it we want to be

1623
01:10:08,650 --> 01:10:09,999
able to find all the matches for Pablo

1624
01:10:09,999 --> 01:10:14,800
for this so if I try to create an index

1625
01:10:14,800 --> 01:10:17,980
on the content field this is me a really

1626
01:10:17,980 --> 01:10:21,010
bad idea because again it's gonna take

1627
01:10:21,010 --> 01:10:24,190
the entire key an entire contents of

1628
01:10:24,190 --> 01:10:26,590
this this attribute in our table and try

1629
01:10:26,590 --> 01:10:28,090
to build a because people Street on that

1630
01:10:28,090 --> 01:10:29,980
all right and in case if we keep Peeta

1631
01:10:29,980 --> 01:10:31,269
this would be really stupid because some

1632
01:10:31,269 --> 01:10:33,789
articles can be kilobytes and now I'm

1633
01:10:33,789 --> 01:10:36,429
storing the entire key in might and my

1634
01:10:36,429 --> 01:10:38,889
index and yeah the only thing I could do

1635
01:10:38,889 --> 01:10:40,389
to look up someone is you know if

1636
01:10:40,389 --> 01:10:41,679
someone gives me the entire article back

1637
01:10:41,679 --> 01:10:44,440
which is stupid all right and so in

1638
01:10:44,440 --> 01:10:45,579
order to do this kind of look up like

1639
01:10:45,579 --> 01:10:49,539
this I I want to do a set of you know

1640
01:10:49,539 --> 01:10:51,219
something equals something I want to do

1641
01:10:51,219 --> 01:10:53,349
a keyword search like when the like

1642
01:10:53,349 --> 01:10:55,659
clause with wild cards and say find me

1643
01:10:55,659 --> 01:10:56,829
all the matches where the you know the

1644
01:10:56,829 --> 01:10:58,840
keyword Pablo's inside of it actually

1645
01:10:58,840 --> 01:11:00,309
and this is actually knotting the rights

1646
01:11:00,309 --> 01:11:01,900
equal going either way because this is

1647
01:11:01,900 --> 01:11:04,389
gonna match for things that have Pablo

1648
01:11:04,389 --> 01:11:06,400
as a prefix like Pavlov ugh them for the

1649
01:11:06,400 --> 01:11:08,590
famous Russian scientist and I'm gonna

1650
01:11:08,590 --> 01:11:10,659
find exactly where my name is being used

1651
01:11:10,659 --> 01:11:13,059
so this predicate itself is not gonna be

1652
01:11:13,059 --> 01:11:15,849
useful for us so this is what an

1653
01:11:15,849 --> 01:11:18,190
inverted index tells for us so an

1654
01:11:18,190 --> 01:11:21,460
inverted index is gonna map words and he

1655
01:11:21,460 --> 01:11:23,079
works as we describe them in the you

1656
01:11:23,079 --> 01:11:25,030
know English language or in natural

1657
01:11:25,030 --> 01:11:27,849
languages not like byte sequences in the

1658
01:11:27,849 --> 01:11:30,249
processor there's gonna map words to the

1659
01:11:30,249 --> 01:11:33,400
records that contain them and then it's

1660
01:11:33,400 --> 01:11:35,110
gonna louse it then do lookups on this

1661
01:11:35,110 --> 01:11:36,880
index and say find me all the records

1662
01:11:36,880 --> 01:11:38,559
that contain this keyword or have this

1663
01:11:38,559 --> 01:11:39,730
you know key word of this certain

1664
01:11:39,730 --> 01:11:42,099
property so these are sometimes called

1665
01:11:42,099 --> 01:11:44,170
full-text search indexes and just like

1666
01:11:44,170 --> 01:11:47,469
with when I created index and I told

1667
01:11:47,469 --> 01:11:48,730
Postgres I wanted this thing to be a

1668
01:11:48,730 --> 01:11:50,619
hash table index you can do the same

1669
01:11:50,619 --> 01:11:51,880
thing as some databases you can say I

1670
01:11:51,880 --> 01:11:53,199
want to create an index and I wanted to

1671
01:11:53,199 --> 01:11:55,360
be I wanted to be an inverted index well

1672
01:11:55,360 --> 01:11:59,710
full-text search index so sometimes in

1673
01:11:59,710 --> 01:12:01,269
in the theoretical literature these are

1674
01:12:01,269 --> 01:12:03,369
called core dances and this is because

1675
01:12:03,369 --> 01:12:05,139
there was this old lady in the 1800's

1676
01:12:05,139 --> 01:12:07,420
who sat down for 16 years and built an

1677
01:12:07,420 --> 01:12:10,659
inverted index that mapped every single

1678
01:12:10,659 --> 01:12:12,849
word used by Shakespeare and his entire

1679
01:12:12,849 --> 01:12:14,800
body of work alright but if this is

1680
01:12:14,800 --> 01:12:16,030
nobody calls him does everyone instead

1681
01:12:16,030 --> 01:12:18,249
calls him first full-text search indexes

1682
01:12:18,249 --> 01:12:20,380
are verted in texas so all the major

1683
01:12:20,380 --> 01:12:20,950
database

1684
01:12:20,950 --> 01:12:23,430
will support some variant of this

1685
01:12:23,430 --> 01:12:25,480
internally as I said when you call

1686
01:12:25,480 --> 01:12:26,860
creating index you can say I want to

1687
01:12:26,860 --> 01:12:28,840
have a full-text search and search index

1688
01:12:28,840 --> 01:12:32,050
and they all vary in the sophistication

1689
01:12:32,050 --> 01:12:34,960
of the of the indexes and what kind of

1690
01:12:34,960 --> 01:12:35,950
queries you can run on them

1691
01:12:35,950 --> 01:12:38,290
there's also a bunch of specialized

1692
01:12:38,290 --> 01:12:40,150
database systems that are that are sold

1693
01:12:40,150 --> 01:12:41,770
or marketed as full-text search

1694
01:12:41,770 --> 01:12:44,740
databases so the most famous one is poly

1695
01:12:44,740 --> 01:12:46,870
elastic search and this is built on top

1696
01:12:46,870 --> 01:12:48,880
of leucine leucine is like a library

1697
01:12:48,880 --> 01:12:50,950
written by the guy that invented Hadoop

1698
01:12:50,950 --> 01:12:53,110
that does like a you know does the

1699
01:12:53,110 --> 01:12:55,180
search it says it does indexing and then

1700
01:12:55,180 --> 01:12:58,240
elastic search provides like a server

1701
01:12:58,240 --> 01:13:01,420
interface to to that index so there also

1702
01:13:01,420 --> 01:13:02,830
uses the scene I think Sphinx does as

1703
01:13:02,830 --> 01:13:06,700
well I use these HP in which is like a

1704
01:13:06,700 --> 01:13:08,380
standalone C library that does full-text

1705
01:13:08,380 --> 01:13:09,610
and search indexing because this is

1706
01:13:09,610 --> 01:13:11,290
better than the my sequel full-text

1707
01:13:11,290 --> 01:13:13,690
search indexing but ideally you know

1708
01:13:13,690 --> 01:13:15,580
these are all these would be internal or

1709
01:13:15,580 --> 01:13:17,980
sorry external to like post customize

1710
01:13:17,980 --> 01:13:20,170
sequel whereas these other guys are sort

1711
01:13:20,170 --> 01:13:21,370
of like it's built inside of it the

1712
01:13:21,370 --> 01:13:25,840
system itself so the we're not got time

1713
01:13:25,840 --> 01:13:27,850
to discuss implementations but basically

1714
01:13:27,850 --> 01:13:30,340
all the hash table index stuff we talked

1715
01:13:30,340 --> 01:13:32,140
about so far in the B plus trees that's

1716
01:13:32,140 --> 01:13:33,340
what you're going to use to build one

1717
01:13:33,340 --> 01:13:35,590
these full-text search indexes so the

1718
01:13:35,590 --> 01:13:36,850
thing that there's a lookup and find me

1719
01:13:36,850 --> 01:13:38,590
all the you know the records that have

1720
01:13:38,590 --> 01:13:40,510
containers word I could build that as a

1721
01:13:40,510 --> 01:13:45,130
hash table I can build that as a as a B+

1722
01:13:45,130 --> 01:13:46,870
tree but I'm gonna augment it with

1723
01:13:46,870 --> 01:13:48,700
additional metadata that provide the

1724
01:13:48,700 --> 01:13:50,380
context about how that word was being

1725
01:13:50,380 --> 01:13:54,460
used in the in the tuple so the kind of

1726
01:13:54,460 --> 01:13:55,930
queries you can do that you can't do

1727
01:13:55,930 --> 01:13:57,940
want to be plus tree at a full-text full

1728
01:13:57,940 --> 01:14:01,030
or inverted index you can do phrase

1729
01:14:01,030 --> 01:14:03,100
searches so I can do again find all the

1730
01:14:03,100 --> 01:14:05,410
records that contain the word Pablo I

1731
01:14:05,410 --> 01:14:08,050
can do proximity searches so find me all

1732
01:14:08,050 --> 01:14:10,930
the records where the word Pablo is in

1733
01:14:10,930 --> 01:14:13,000
you know within five words or three

1734
01:14:13,000 --> 01:14:15,100
words from you know criminal or

1735
01:14:15,100 --> 01:14:17,020
alcoholic or something like that right

1736
01:14:17,020 --> 01:14:18,820
because I'm maintaining the context

1737
01:14:18,820 --> 01:14:20,080
information about how that word was

1738
01:14:20,080 --> 01:14:22,450
being used then I can also do a wildcard

1739
01:14:22,450 --> 01:14:24,310
searches that's more complicated than

1740
01:14:24,310 --> 01:14:26,080
the like stuff I can do regular

1741
01:14:26,080 --> 01:14:27,820
expressions or complex pattern matching

1742
01:14:27,820 --> 01:14:30,249
to find things I'm looking for

1743
01:14:30,249 --> 01:14:32,769
so the things we do care about slightly

1744
01:14:32,769 --> 01:14:34,090
is that how we're actually gonna build

1745
01:14:34,090 --> 01:14:35,650
this thing and again the different

1746
01:14:35,650 --> 01:14:37,659
systems will all do different things the

1747
01:14:37,659 --> 01:14:38,979
thing they're gonna bury the most own is

1748
01:14:38,979 --> 01:14:40,179
what they're actually storing again this

1749
01:14:40,179 --> 01:14:42,610
is the context information about how the

1750
01:14:42,610 --> 01:14:45,190
word was found in the attribute so at

1751
01:14:45,190 --> 01:14:46,929
the very simplest form you just have you

1752
01:14:46,929 --> 01:14:48,999
know the word itself and then map to a

1753
01:14:48,999 --> 01:14:50,829
record IDE but I can also include you

1754
01:14:50,829 --> 01:14:52,179
know what other words are around it how

1755
01:14:52,179 --> 01:14:53,559
many steps away from other words and

1756
01:14:53,559 --> 01:14:56,469
that will determine how how complex

1757
01:14:56,469 --> 01:14:59,170
queries I can support on this the other

1758
01:14:59,170 --> 01:15:00,460
tricky thing is actually when you update

1759
01:15:00,460 --> 01:15:02,800
these things so if it's built inside of

1760
01:15:02,800 --> 01:15:05,530
the system you could in theory on every

1761
01:15:05,530 --> 01:15:07,329
update make sure you update your your

1762
01:15:07,329 --> 01:15:09,820
search index or inverted index if is a

1763
01:15:09,820 --> 01:15:11,349
fist external and you can run this as a

1764
01:15:11,349 --> 01:15:14,949
cron job or push updates to it a lot of

1765
01:15:14,949 --> 01:15:17,050
times people will stage updates in

1766
01:15:17,050 --> 01:15:18,760
batches and then apply them every so

1767
01:15:18,760 --> 01:15:20,530
often because because potentially

1768
01:15:20,530 --> 01:15:22,059
updating the inverted index is super

1769
01:15:22,059 --> 01:15:24,729
expensive and again I realize I'm going

1770
01:15:24,729 --> 01:15:26,320
to over the super fast I just want you

1771
01:15:26,320 --> 01:15:28,570
to be aware that beyond B plus trees and

1772
01:15:28,570 --> 01:15:29,559
hash tables that we talked about here

1773
01:15:29,559 --> 01:15:31,119
it's a whole bunch of other database

1774
01:15:31,119 --> 01:15:33,309
indexes that are available that can do

1775
01:15:33,309 --> 01:15:34,929
things beyond point queries and range

1776
01:15:34,929 --> 01:15:37,809
queries that we've looked at and

1777
01:15:37,809 --> 01:15:39,699
actually the the other class of indexes

1778
01:15:39,699 --> 01:15:40,809
that we didn't talk about are the

1779
01:15:40,809 --> 01:15:42,940
geospatial between indexes so things

1780
01:15:42,940 --> 01:15:46,329
like our trees quadtrees KT trees these

1781
01:15:46,329 --> 01:15:47,619
allows you to do multiple dimensional

1782
01:15:47,619 --> 01:15:49,659
mock-ups like in your geometric spaces

1783
01:15:49,659 --> 01:15:51,579
and things like that these are very

1784
01:15:51,579 --> 01:15:54,550
common now in like video databases and

1785
01:15:54,550 --> 01:15:57,239
image databases so there's a whole class

1786
01:15:57,239 --> 01:15:59,650
that Christos falooda is the other Davis

1787
01:15:59,650 --> 01:16:02,320
professor teaches 15 a 26 he teaches it

1788
01:16:02,320 --> 01:16:03,519
in the fall and spring now so if you're

1789
01:16:03,519 --> 01:16:04,539
interested this kind of stuff I'll be

1790
01:16:04,539 --> 01:16:07,479
teaching it in the spring so the main

1791
01:16:07,479 --> 01:16:10,030
takeaway for all of this is that the for

1792
01:16:10,030 --> 01:16:12,159
our most of the time the B+ tree is gone

1793
01:16:12,159 --> 01:16:14,019
what we want that's the go-to index

1794
01:16:14,019 --> 01:16:16,179
that's that's very that's resilient and

1795
01:16:16,179 --> 01:16:17,889
solve many of the problems that people

1796
01:16:17,889 --> 01:16:21,099
have in databases inverted indexes we

1797
01:16:21,099 --> 01:16:22,210
can go you want to go more detail

1798
01:16:22,210 --> 01:16:24,039
there's a whole nother class and I think

1799
01:16:24,039 --> 01:16:28,659
an LTI 442 or 642 I think it's called

1800
01:16:28,659 --> 01:16:31,599
search engines right but in a search

1801
01:16:31,599 --> 01:16:33,369
engine only for covers is basically an

1802
01:16:33,369 --> 01:16:35,409
inverted index so it's the same the same

1803
01:16:35,409 --> 01:16:39,570
technology the same methods okay

1804
01:16:40,369 --> 01:16:43,739
so next Wednesday we're now gonna go

1805
01:16:43,739 --> 01:16:45,360
looking at how we actually make our B

1806
01:16:45,360 --> 01:16:47,280
plus tree thread-safe so we've sort of

1807
01:16:47,280 --> 01:16:49,469
washed all over this or we've not talked

1808
01:16:49,469 --> 01:16:50,760
about avoid the problem that actually

1809
01:16:50,760 --> 01:16:52,409
how do we allow multiple threads update

1810
01:16:52,409 --> 01:16:54,389
the index at the same time so now we're

1811
01:16:54,389 --> 01:16:55,590
spend more time talking talking about

1812
01:16:55,590 --> 01:17:24,409
that okay any questions ricochet jelly

1813
01:17:28,699 --> 01:17:37,019
bottle I can't say don't know your phone

1814
01:17:37,019 --> 01:17:39,590
can tap a

