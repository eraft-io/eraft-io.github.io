<!DOCTYPE html>
<html lang='en'>

<head>
  <meta name="generator" content="Hexo 6.3.0">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.19.0">
  <meta charset="utf-8">
  

  <meta http-equiv='x-dns-prefetch-control' content='on' />
  <link rel='dns-prefetch' href='https://gcore.jsdelivr.net'>
  <link rel="preconnect" href="https://gcore.jsdelivr.net" crossorigin>
  <link rel='dns-prefetch' href='//unpkg.com'>

  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>动手学习分布式-构建Raft库 (Golang eraftkv 版) - ERaftBooks</title>

  
    <meta name="description" content="核心数据结构设计我们上一章节讲了Raft算法的主要内容，现在我们要代码实现它们了。首先我们需要抽象出我们需要的数据结构。先来梳理一下可能用到的数据结构，首先节点之间需要互相访问，那我们需要定义访问其他节点的网络客户端，这里面要包含节点的id,地址，还有rpc的客户端，整个结构我们抽象为RaftClientEnd，主要数据内容如下： 123456type RaftClientEnd struct &amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="动手学习分布式-构建Raft库 (Golang eraftkv 版)">
<meta property="og:url" content="https://eraft.cn/2023/08/19/build-raft-lib/index.html">
<meta property="og:site_name" content="ERaftBooks">
<meta property="og:description" content="核心数据结构设计我们上一章节讲了Raft算法的主要内容，现在我们要代码实现它们了。首先我们需要抽象出我们需要的数据结构。先来梳理一下可能用到的数据结构，首先节点之间需要互相访问，那我们需要定义访问其他节点的网络客户端，这里面要包含节点的id,地址，还有rpc的客户端，整个结构我们抽象为RaftClientEnd，主要数据内容如下： 123456type RaftClientEnd struct &amp;">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://eraft.cn/images/goruntine_model.svg">
<meta property="og:image" content="https://eraft.cn/images/raft_elec001.png">
<meta property="og:image" content="https://eraft.cn/images/raft_elec002.png">
<meta property="og:image" content="https://eraft.cn/images/raft_elec003.png">
<meta property="og:image" content="https://eraft.cn/images/raft_elec004.png">
<meta property="og:image" content="https://eraft.cn/images/raft_elec005.png">
<meta property="og:image" content="https://eraft.cn/images/log_repl001.png">
<meta property="og:image" content="https://eraft.cn/images/log_repl002.png">
<meta property="og:image" content="https://eraft.cn/images/log_repl003.png">
<meta property="og:image" content="https://eraft.cn/images/split_net001.png">
<meta property="og:image" content="https://eraft.cn/images/split_net002.png">
<meta property="og:image" content="https://eraft.cn/images/split_net003.png">
<meta property="article:published_time" content="2023-08-19T03:42:36.000Z">
<meta property="article:modified_time" content="2023-08-19T05:21:53.264Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://eraft.cn/images/goruntine_model.svg">
  
  
  
  

  <!-- feed -->
  

  
    
<link rel="stylesheet" href="/css/main.css">

  

  

  

  


  
</head>

<body>
  




  <div class='l_body' id='start'>
    <aside class='l_left' layout='post'>
    

  

<header class="header"><div class="logo-wrap"><a class="title" href="/"><div class="main" ff="title">ERaftBooks</div></a></div>

<nav class="menu dis-select"></nav>
</header>


<div class="widgets">
<widget class="widget-wrapper search"><div class="widget-body"><div class="search-wrapper" id="search"><form class="search-form"><input type="text" class="search-input" id="search-input" data-filter="/blog/" placeholder="文章搜索"><svg t="1670596976048" class="icon search-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2676" width="200" height="200"><path d="M938.2 832.6L723.8 618.1c-2.5-2.5-5.3-4.4-7.9-6.4 36.2-55.6 57.3-121.8 57.3-193.1C773.3 222.8 614.6 64 418.7 64S64 222.8 64 418.6c0 195.9 158.8 354.6 354.6 354.6 71.3 0 137.5-21.2 193.2-57.4 2 2.7 3.9 5.4 6.3 7.8L832.5 938c14.6 14.6 33.7 21.9 52.8 21.9 19.1 0 38.2-7.3 52.8-21.8 29.2-29.1 29.2-76.4 0.1-105.5M418.7 661.3C284.9 661.3 176 552.4 176 418.6 176 284.9 284.9 176 418.7 176c133.8 0 242.6 108.9 242.6 242.7 0 133.7-108.9 242.6-242.6 242.6" p-id="2677"></path></svg></form><div id="search-result"></div><div class="search-no-result">No Results!</div></div></div></widget>


<widget class="widget-wrapper toc single" id="data-toc"><div class="widget-header cap dis-select"><span class="name">动手学习分布式-构建Raft库 (Golang eraftkv 版)</span></div><div class="widget-body fs14"><div class="doc-tree active"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-text">核心数据结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">协程模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rpc%E5%AE%9A%E4%B9%89"><span class="toc-text">Rpc定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RequestVote%E7%9B%B8%E5%85%B3"><span class="toc-text">RequestVote相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AppendEntries%E7%9B%B8%E5%85%B3"><span class="toc-text">AppendEntries相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Leader%E9%80%89%E4%B8%BE%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90"><span class="toc-text">Leader选举实现分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90"><span class="toc-text">日志复制实现分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Raft%E5%BF%AB%E7%85%A7%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90"><span class="toc-text">Raft快照实现分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Raft%E5%A6%82%E4%BD%95%E5%BA%94%E5%AF%B9%E8%84%91%E8%A3%82"><span class="toc-text">Raft如何应对脑裂</span></a></li></ol></div></div></widget>




</div>


    </aside>
    <div class='l_main'>
      

      



<div class="bread-nav fs12"><div id="breadcrumb"><a class="cap breadcrumb" href="/">Home</a><span class="sep"></span><a class="cap breadcrumb" href="/">Blog</a></div><div id="post-meta">Posted on&nbsp;<time datetime="2023-08-19T03:42:36.000Z">2023-08-19</time></div></div>

<article class='md-text content post'>
<h1 class="article-title"><span>动手学习分布式-构建Raft库 (Golang eraftkv 版)</span></h1>
<h3 id="核心数据结构设计"><a href="#核心数据结构设计" class="headerlink" title="核心数据结构设计"></a>核心数据结构设计</h3><p>我们上一章节讲了Raft算法的主要内容，现在我们要代码实现它们了。首先我们需要抽象出我们需要的数据结构。先来梳理一下可能用到的数据结构，首先节点之间需要互相访问，那我们需要定义访问其他节点的网络客户端，这里面要包含节点的id,地址，还有rpc的客户端，整个结构我们抽象为RaftClientEnd，主要数据内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type RaftClientEnd struct &#123; </span><br><span class="line">    id             uint64</span><br><span class="line">    addr           string</span><br><span class="line">    raftServiceCli *raftpb.RaftServiceClient  // grpc 客户端</span><br><span class="line">&#125;        </span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>节点状态我们之前描述的有三种，定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    const (</span><br><span class="line"></span><br><span class="line">NodeRoleFollower NodeRole = iota</span><br><span class="line"></span><br><span class="line">NodeRoleCandidate</span><br><span class="line"></span><br><span class="line">NodeRoleLeader</span><br><span class="line"></span><br><span class="line">   )</span><br></pre></td></tr></table></figure>
<p>我们要完成选举操作的话需要两个超时时间，这里我们使用Golang time库里面的Timer实现，它可以定时的给一个通道发送消息，我们可以用它来实现选举超时和心跳超时。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">electionTimer *time.Timer</span><br><span class="line">heartbeatTimer *time.Timer</span><br></pre></td></tr></table></figure>

<p>除此之外我们还需要记录当前节点的id,当前的任期号，为谁投票，获得票数的统计，已经提交的日志索引号，最后apply到状态机的日志号，以及节点如果是Leader的话需要记录到其他节点复制最新匹配的日志号，这写数据结构定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">type Raft struct &#123;</span><br><span class="line"></span><br><span class="line">    mu             sync.RWMutex</span><br><span class="line"></span><br><span class="line">    peers          []*RaftClientEnd // rpc 客户端</span><br><span class="line"></span><br><span class="line">    me_            int  // 自己的 id</span><br><span class="line"></span><br><span class="line">    dead           int32 // 节点的状态</span><br><span class="line"></span><br><span class="line">    applyCh        chan *pb.ApplyMsg // apply 协程通道，协程模型中会讲到</span><br><span class="line"></span><br><span class="line">    applyCond      *sync.Cond // apply 流程控制的信号量</span><br><span class="line"></span><br><span class="line">    replicatorCond []*sync.Cond // 复制操作控制的信号量</span><br><span class="line"></span><br><span class="line">    role           NodeRole  // 节点当前的状态</span><br><span class="line"></span><br><span class="line">    curTerm        int64  // 当前的任期</span><br><span class="line"></span><br><span class="line">    votedFor       int64  // 为谁投票</span><br><span class="line"></span><br><span class="line">    grantedVotes   int    // 已经获得的票数 </span><br><span class="line"></span><br><span class="line">    logs           *RaftLog  // 日志信息</span><br><span class="line"></span><br><span class="line">    commitIdx      int64     // 已经提交的最大的日志 id</span><br><span class="line"></span><br><span class="line">    lastApplied    int64     // 已经 apply 的最大日志的 id</span><br><span class="line"></span><br><span class="line">    nextIdx        []int     // 到其他节点下一个匹配的日志 id 信息</span><br><span class="line"></span><br><span class="line">    matchIdx       []int     // 到其他节点当前匹配的日志 id 信息</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    leaderId         int64   // 集群中当前 Leader 节点的 id</span><br><span class="line"></span><br><span class="line">    electionTimer    *time.Timer  // 选举超时定时器</span><br><span class="line"></span><br><span class="line">    heartbeatTimer   *time.Timer  // 心跳超时定时器</span><br><span class="line"></span><br><span class="line">    heartBeatTimeout uint64       // 心跳超时时间</span><br><span class="line"></span><br><span class="line">    baseElecTimeout  uint64       // 选举超时时间</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>首先系统启动的时候需要构造Raft这个结构体，这个流程是在MakeRaft里面实现的，它主要是初始化与一些变量，两个定时器，并启动相关的协程，我们这里对每个对端节点复制有Replicator协程，触发两个超时时间有Tick协程，应用已经提交的日志有Applier协程。</p>
<h3 id="协程模型"><a href="#协程模型" class="headerlink" title="协程模型"></a>协程模型</h3><div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/images/goruntine_model.svg"/></div></div>

<p>上图展示了我们raftcore里面的协程模型，当应用层提案(propose)到来之后主协程会在本地追加日志，然后发送BroadcastAppend，然后到其他节点复制日志的协程的等待就会被唤醒，开始进行一轮的的复制，replicateOneRound成功复制半数节点日志之后会触发commit, rf.applyCond.Signal()会唤醒等待做Apply操作的Applier协程。</p>
<p>另外Tick协程会监听Timer两个超时的C通道信号，一旦心跳超时并且当前节点的状态是Leader，就会调用BroadcastHeartbeat发送心跳，发心跳的时候也会replicateOneRound就和上述一样，如果成功复制半数节点日志之后会触发commit, rf.applyCond.Signal()就会唤醒等待做Apply操作的Applier协程。</p>
<p>Applier协程apply完消息之后会把ApplyMsg消息写入rf.applyCh通知应用层，应用层的协程和以监听这个通道，如果有ApplyMsg到来就把它应用到状态机。</p>
<h3 id="Rpc定义"><a href="#Rpc定义" class="headerlink" title="Rpc定义"></a>Rpc定义</h3><p>eraft的rpc定义文件在pbs目录下的raftbasic.proto文件中，主要的消息如下： </p>
<ul>
<li>Entry</li>
</ul>
<p>这个是一个日志条目信息表示，和我们之前描述的一样，它有任期号term，索引号index,以及操作的序列化数据data我们用一个字节流来存储，日志条目有两种类型一种是Normal正常日志，另一种是ConfChange配置变更的日志：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">enum EntryType &#123;</span><br><span class="line"></span><br><span class="line">    EntryNormal = 0;</span><br><span class="line"></span><br><span class="line">    EntryConfChange = 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">message Entry &#123;</span><br><span class="line"></span><br><span class="line">    EntryType entry_type = 1;</span><br><span class="line"></span><br><span class="line">    uint64    term = 2;</span><br><span class="line"></span><br><span class="line">    int64     index = 3;</span><br><span class="line"></span><br><span class="line">    bytes     data = 4;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<h3 id="RequestVote相关"><a href="#RequestVote相关" class="headerlink" title="RequestVote相关"></a>RequestVote相关</h3><p>下面是请求投票RPC的定义，基本和论文里面保持一致：<br>请求投票里面有候选人的任期号，它的id以及它最后一条日志的索引以及任期号信息。<br>响应里面有个任期号，这个用来给候选人在选举失败的时候更新自己的任期，还有一个vote_granted表示这个请求投票操作是否被对端节点接受。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">message RequestVoteRequest &#123;</span><br><span class="line"></span><br><span class="line">    int64 term = 1;</span><br><span class="line"></span><br><span class="line">    int64 candidate_id = 2;</span><br><span class="line"></span><br><span class="line">    int64 last_log_index = 3;</span><br><span class="line"></span><br><span class="line">    int64 last_log_term = 4;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">message RequestVoteResponse &#123;</span><br><span class="line"></span><br><span class="line">    int64 term = 1;</span><br><span class="line"></span><br><span class="line">    bool  vote_granted = 2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">service RaftService &#123;</span><br><span class="line"></span><br><span class="line">    //...</span><br><span class="line"></span><br><span class="line">    rpc RequestVote (RequestVoteRequest) returns (RequestVoteResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="AppendEntries相关"><a href="#AppendEntries相关" class="headerlink" title="AppendEntries相关"></a>AppendEntries相关</h3><p>日志追加操作的定义如下，基本也和论文里面一致：</p>
<p>请求里面有Leader的任期，id （用来告诉follower,这样client访问了follower之后可以被告知leader节点是哪个）， prev_log_index表示消息里面将要同步的第一条日志前一条日志的的索引信息，prev_log_term是它的任期信息，leader_commit则是leader的commit号(可以用来周知follower节点当前的commit进度)，entries表示日志条目信息。</p>
<p>响应里面term用来告诉leader是否出新的任期的消息，可以用来更新leader的任期号，success表示日志追加操作是否成功，conflict_index用来记录冲突日志的索引号，conflict_term用来记录冲突日志的任期号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">message AppendEntriesRequest &#123;</span><br><span class="line"></span><br><span class="line">    int64    term = 1;</span><br><span class="line"></span><br><span class="line">    int64    leader_id = 2;</span><br><span class="line"></span><br><span class="line">    int64    prev_log_index = 3;</span><br><span class="line"></span><br><span class="line">    int64    prev_log_term = 4;</span><br><span class="line"></span><br><span class="line">    int64    leader_commit = 5;</span><br><span class="line"></span><br><span class="line">    repeated Entry entries = 6;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">message AppendEntriesResponse &#123;</span><br><span class="line"></span><br><span class="line">    int64  term = 1;</span><br><span class="line"></span><br><span class="line">    bool  success = 2;</span><br><span class="line"></span><br><span class="line">    int64 conflict_index = 3;</span><br><span class="line"></span><br><span class="line">    int64 conflict_term = 4;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">service RaftService &#123;</span><br><span class="line"></span><br><span class="line">    //...</span><br><span class="line"></span><br><span class="line">    rpc AppendEntries (AppendEntriesRequest) returns (AppendEntriesResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Leader选举实现分析"><a href="#Leader选举实现分析" class="headerlink" title="Leader选举实现分析"></a>Leader选举实现分析</h3><p>Raft官网提供了一个算法的动态演示动画，我们先来直观感受下Leader选举的流程，然后结合代码介绍这个流程。 待续。。</p>
<p>首先Raft算法中有两个超时时间用来控制着Leader选举的流程，首先是选举超时，这个是Candidate等待变成Leader的时间跨度，如果在这个时间内还没被选成Leader,这个超时定时器会被重置。我们前面也介绍过，这个超时时间设置一般在150ms到300ms之间。</p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/images/raft_elec001.png"/></div></div>

<p>启动的时候，所有节点的选举超市时间都被设置到150～300ms之间的随机值，那么大概率有一个节点会率先达到超市时间，如图A,B,C节点的C先达到超时时间，它从Follower变成Candidate,随后开始新任期的选举，它会给自己投一票，然后向集群中的其他节点发送RequestVoteRequest rpc请求它们的投票。</p>
<p>1.eraft代码中在启动，也就是应用层调用MakeRaft函数的时候会传入baseElectionTimeOutMs和heartbeatTimeOutMs， 这里心跳超市时间是固定的，选举超时时间我们使用MakeAnRandomElectionTimeout构造生成了一个随机超市时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func MakeRaft(peers []*RaftClientEnd, me int, newdbEng storage_eng.KvStore, applyCh chan *pb.ApplyMsg, heartbeatTimeOutMs uint64, baseElectionTimeOutMs uint64) *Raft &#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">heartbeatTimer:   time.NewTimer(time.Millisecond * time.Duration(heartbeatTimeOutMs)),</span><br><span class="line">electionTimer:    time.NewTimer(time.Millisecond * time.Duration(MakeAnRandomElectionTimeout(int(baseElectionTimeOutMs)))),</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.达到选举超时后,节点C首先把自己状态改成Candidate，然后增加自己的任期号，开始选举。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// Tick raft heart, this ticket trigger raft main flow running</span><br><span class="line">//</span><br><span class="line">func (rf *Raft) Tick() &#123;</span><br><span class="line">    for !rf.IsKilled() &#123;</span><br><span class="line">        select &#123;</span><br><span class="line">        case &lt;-rf.electionTimer.C:</span><br><span class="line">            &#123;</span><br><span class="line">                rf.SwitchRaftNodeRole(NodeRoleCandidate)</span><br><span class="line">                rf.IncrCurrentTerm()</span><br><span class="line">                rf.Election()</span><br><span class="line">                rf.electionTimer.Reset(time.Millisecond * time.Duration(MakeAnRandomElectionTimeout(int(rf.baseElecTimeout))))</span><br><span class="line">            &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.下面这段代码就是发起选举的核心逻辑了，首先节点IncrGrantedVotes给自己投一票，然后把votedFor设置成自己，之后构造RequestVoteRequest rpc请求，带上自己的任期号，CandidateId也就是自己的id,最后一个日志条目的索引还有任期号，然后把当前Raft状态持久化，向集群中的其他节点并行的发送，RequestVote请求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// Election  make a new election</span><br><span class="line">//</span><br><span class="line">func (rf *Raft) Election() &#123;</span><br><span class="line">	fmt.Printf(&quot;%d start election \n&quot;, rf.me_)</span><br><span class="line">	rf.IncrGrantedVotes()</span><br><span class="line">	rf.votedFor = int64(rf.me_)</span><br><span class="line">	voteReq := &amp;pb.RequestVoteRequest&#123;</span><br><span class="line">		Term:         rf.curTerm,</span><br><span class="line">		CandidateId:  int64(rf.me_),</span><br><span class="line">		LastLogIndex: int64(rf.logs.GetLast().Index),</span><br><span class="line">		LastLogTerm:  int64(rf.logs.GetLast().Term),</span><br><span class="line">	&#125;</span><br><span class="line">	rf.PersistRaftState()</span><br><span class="line">	for _, peer := range rf.peers &#123;</span><br><span class="line">		if int(peer.id) == rf.me_ &#123;</span><br><span class="line">			continue</span><br><span class="line">		&#125;</span><br><span class="line">		go func(peer *RaftClientEnd) &#123;</span><br><span class="line">			PrintDebugLog(fmt.Sprintf(&quot;send request vote to %s %s\n&quot;, peer.addr, voteReq.String()))</span><br><span class="line"></span><br><span class="line">			requestVoteResp, err := (*peer.raftServiceCli).RequestVote(context.Background(), voteReq)</span><br><span class="line">			if err != nil &#123;</span><br><span class="line">				PrintDebugLog(fmt.Sprintf(&quot;send request vote to %s failed %v\n&quot;, peer.addr, err.Error()))</span><br><span class="line">			&#125;</span><br><span class="line">			...</span><br><span class="line">		&#125;(peer)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>


<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/images/raft_elec002.png"/></div></div>

<p>如果A,B收到请求的时候还没有发出投票（因为它们还没达到选举超时时间），它们就会给候选人节点C投票,同时重设自己的选举超时定时器。</p>
<p>4.eraft处理投票请求的细节如下,我们结合图中的例子分析下面的逻辑，假设A节点正在处理来自C的投票请求，那么首先C的 任期号大于A的,代码中1的if分支不会执行,在2这里， A节点发现来自C的请求投票消息的任期号大于自己的，它会调用SwitchRaftNodeRole变成Follower节点,在回C消息之前，代码中3号位置A调用electionTimer.Reset重设了自己的选举超时定时器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// HandleRequestVote  handle request vote from other node</span><br><span class="line">//</span><br><span class="line">func (rf *Raft) HandleRequestVote(req *pb.RequestVoteRequest, resp *pb.RequestVoteResponse) &#123;</span><br><span class="line">	rf.mu.Lock()</span><br><span class="line">	defer rf.mu.Unlock()</span><br><span class="line">	defer rf.PersistRaftState()</span><br><span class="line"></span><br><span class="line">    // 1</span><br><span class="line">	if req.Term &lt; rf.curTerm || (req.Term == rf.curTerm &amp;&amp; rf.votedFor != -1 &amp;&amp; rf.votedFor != req.CandidateId) &#123;</span><br><span class="line">		resp.Term, resp.VoteGranted = rf.curTerm, false</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    // 2 </span><br><span class="line">	if req.Term &gt; rf.curTerm &#123;</span><br><span class="line">		rf.SwitchRaftNodeRole(NodeRoleFollower)</span><br><span class="line">		rf.curTerm, rf.votedFor = req.Term, -1</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	rf.votedFor = req.CandidateId</span><br><span class="line">	</span><br><span class="line">	// 3</span><br><span class="line">	rf.electionTimer.Reset(time.Millisecond * time.Duration(MakeAnRandomElectionTimeout(int(rf.baseElecTimeout))))</span><br><span class="line">	resp.Term, resp.VoteGranted = rf.curTerm, true</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/images/raft_elec003.png"/></div></div>

<p>C收到半数票以上，也就是A, B节点的任意一个的投票加上自己那一张选票，它就变成了Leader，然后停止自己的选举超时定时器。</p>
<p>5.C统计票数处理请求投票的响应如下，注意：这段代码加了锁，应为这里涉及到多个Goruntine去修改rf中的非原子变量，如果不加锁可能会导致逻辑错误。代码中1处，如果收到投票的响应VoteGranted是true。C就会调用IncrGrantedVotes递增自己拥有的票书，然后if rf.grantedVotes &gt; len(rf.peers)&#x2F;2判断是否拿到了半数以上票，如果是的调用SwitchRaftNodeRole切换自己的状态为Leader，之后BroadcastHeartbeat广播心跳消息，并重新设置自己的得票数grantedVotes为0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">if requestVoteResp != nil &#123;</span><br><span class="line">           rf.mu.Lock()</span><br><span class="line">           defer rf.mu.Unlock()</span><br><span class="line">           PrintDebugLog(fmt.Sprintf(&quot;send request vote to %s recive -&gt; %s, curterm %d, req term %d&quot;, peer.addr, requestVoteResp.String(), rf.curTerm, voteReq.Term))</span><br><span class="line">           if rf.curTerm == voteReq.Term &amp;&amp; rf.role == NodeRoleCandidate &#123;</span><br><span class="line">               // 1</span><br><span class="line">               if requestVoteResp.VoteGranted &#123;</span><br><span class="line">                   // success granted the votes</span><br><span class="line">                   PrintDebugLog(&quot;I grant vote&quot;)</span><br><span class="line">                   rf.IncrGrantedVotes()</span><br><span class="line">                   if rf.grantedVotes &gt; len(rf.peers)/2 &#123;</span><br><span class="line">                       PrintDebugLog(fmt.Sprintf(&quot;node %d get majority votes int term %d &quot;, rf.me_, rf.curTerm))</span><br><span class="line">                       rf.SwitchRaftNodeRole(NodeRoleLeader)</span><br><span class="line">                       rf.BroadcastHeartbeat()</span><br><span class="line">                       rf.grantedVotes = 0</span><br><span class="line">                   &#125;</span><br><span class="line">               // 2</span><br><span class="line">               &#125; else if requestVoteResp.Term &gt; rf.curTerm &#123;</span><br><span class="line">                   // request vote reject</span><br><span class="line">                   rf.SwitchRaftNodeRole(NodeRoleFollower)</span><br><span class="line">                   rf.curTerm, rf.votedFor = requestVoteResp.Term, -1</span><br><span class="line">                   rf.PersistRaftState()</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/images/raft_elec004.png"/></div></div>

<p>我们知道A,B在前面处理投票请求的时候只是重设的超时定时器，那么万一再一次超时定时器到达，会不会重新出发选举，然后陷入选举循环呢？<br>答案是不会的，我们前面只介绍了选举超时时间，还有一个心跳超时时间，这个超时时间比选举超市时间短，一般是选举超时时间的1&#x2F;3。也就是说在A, B还没到达选举超时时间之前，这个心跳超市时间会先出发，如果是Leader节点的话，它会给集群中其他节点发送心跳包，其他节点(A, B)接受到心跳包之后,又会重设自己的选举超时定时器。也就是说，只要Leader C一直正常运心发送心跳包，那么A,B节点不可能触发选举，只有当Leader C挂了。A,B节点才会开始下一轮选举。</p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/images/raft_elec005.png"/></div></div>

<h3 id="日志复制实现分析"><a href="#日志复制实现分析" class="headerlink" title="日志复制实现分析"></a>日志复制实现分析</h3><p>经过上述的选举流程，我们现在就有一个拥有主节点和多个从节点的系统了，主节点会不断的给从节点发送心跳消息。现在我们要开始考虑处理客户端请求了，如果客户端发送一个操作过来，我们这个系统是如何处理的呢？</p>
<p>首先，Raft规定只有Leader节点能处理请求写入，客户端发送请求首先会到达Leader节点。</p>
<p>在eraft库中用户请求到来和raft交互的入口函数是Propose，这个函数首先会查询当前节点状态，只有Leader节点才能处理提案（propose），之后会把用户操作的序列化之后的[]byte调用Append追加到自己的日志中，之后BroadcastAppend将日志内容发送给集群中的Follower节点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// Propose the interface to the appplication propose a operation</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">func (rf *Raft) Propose(payload []byte) (int, int, bool) &#123;</span><br><span class="line">	rf.mu.Lock()</span><br><span class="line">	defer rf.mu.Unlock()</span><br><span class="line">	if rf.role != NodeRoleLeader &#123;</span><br><span class="line">		return -1, -1, false</span><br><span class="line">	&#125;</span><br><span class="line">	newLog := rf.Append(payload)</span><br><span class="line">	rf.BroadcastAppend()</span><br><span class="line">	return int(newLog.Index), int(newLog.Term), true</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>


<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/images/log_repl001.png"/></div></div>

<p>如上图中，绿色的表示客户端节点，它发送SET 5的请求过来，A作为当前集群中的Leader节点首先会把这个SET 5操作封装成一个日志条目写入到自己的日志存储结构中，然后在下一次给从节点发送心跳消息的时候带上这个日志发送给Follower节点。</p>
<p>在eraft实现中，我们专门有一组Goruntine做日志复制相关的事情，用户提案到达Leader之后调用BroadcastAppend会唤醒做日志复制操作的Goruntine, replicatorCond这个信号量用来完成Goruntine之间的同步操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func (rf *Raft) BroadcastAppend() &#123;</span><br><span class="line">	for _, peer := range rf.peers &#123;</span><br><span class="line">		if peer.id == uint64(rf.me_) &#123;</span><br><span class="line">			continue</span><br><span class="line">		&#125;</span><br><span class="line">		rf.replicatorCond[peer.id].Signal()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复制操作的Goruntine执行的任务函数是Replicator，当BroadcastAppend中通过Signal函数唤醒信号量，rf.replicatorCond[].Wait()就会停止阻塞，继续往下执行，调用replicateOneRound进行数据复制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// Replicator manager duplicate run</span><br><span class="line">//</span><br><span class="line">func (rf *Raft) Replicator(peer *RaftClientEnd) &#123;</span><br><span class="line">	rf.replicatorCond[peer.id].L.Lock()</span><br><span class="line">	defer rf.replicatorCond[peer.id].L.Unlock()</span><br><span class="line">	for !rf.IsKilled() &#123;</span><br><span class="line">		PrintDebugLog(&quot;peer id wait for replicating...&quot;)</span><br><span class="line">		for !(rf.role == NodeRoleLeader &amp;&amp; rf.matchIdx[peer.id] &lt; int(rf.logs.GetLast().Index)) &#123;</span><br><span class="line">			rf.replicatorCond[peer.id].Wait()</span><br><span class="line">		&#125;</span><br><span class="line">		rf.replicateOneRound(peer)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>replicateOneRound就会把日志打包到一个AppendEntriesRequest中发送到Follower节点了。</p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/images/log_repl002.png"/></div></div>

<p>Follower收到追加请求后会把日志条目追加到自己的日志存储结构中，然后给Leader发送成功追加的响应。Leader统计到集群半数节点（包括自己）日志追加成功之后，它会把这条日志状态设置为已经提交(committed)，然后将操作结果发送给客户端,如下图所示，A设置SET 5</p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/images/log_repl003.png"/></div></div>

<p>之后这个日志提交的信息会在下一次给Follower发送的心跳包中带过去，Follower收到日志也会更新自己的日志提交状态。</p>
<p>日志提交之后，Apply协程会收到通知，开始将已经提交的日志apply到状态机中，日志的成功Apply之后给客户端发送成功写入的响应包。</p>
<p>对应eraft实现中，日志提交之后Leader节点会调用advanceCommitIndexForLeader函数。它会计算当前日志提交的索引号，然后和之前已经提交的commitIdx进行对比，如果更大，就会更新commitIdx，同时调用rf.applyCond.Signal()唤醒做Apply操作的Goruntine。Applier函数是Apply Goruntine运行的任务函数，它会Wait applyCond这个信号量，如果被唤醒，它会拷贝初节点中已经提交的日志，打包成ApplyMsg发送到applyCh通道通知应用层，应用层拿到apply消息之后会更新状态机并回包给客户端。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">func (rf *Raft) advanceCommitIndexForLeader() &#123;</span><br><span class="line">	sort.Ints(rf.matchIdx)</span><br><span class="line">	n := len(rf.matchIdx)</span><br><span class="line">	newCommitIndex := rf.matchIdx[n-(n/2+1)]</span><br><span class="line">	if newCommitIndex &gt; int(rf.commitIdx) &#123;</span><br><span class="line">		if rf.MatchLog(rf.curTerm, int64(newCommitIndex)) &#123;</span><br><span class="line">			PrintDebugLog(fmt.Sprintf(&quot;peer %d advance commit index %d at term %d&quot;, rf.me_, rf.commitIdx, rf.curTerm))</span><br><span class="line">			rf.commitIdx = int64(newCommitIndex)</span><br><span class="line">			rf.applyCond.Signal()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">// Applier() Write the commited message to the applyCh channel</span><br><span class="line">// and update lastApplied</span><br><span class="line">//</span><br><span class="line">func (rf *Raft) Applier() &#123;</span><br><span class="line">	for !rf.IsKilled() &#123;</span><br><span class="line">		rf.mu.Lock()</span><br><span class="line">		for rf.lastApplied &gt;= rf.commitIdx &#123;</span><br><span class="line">			PrintDebugLog(&quot;applier ...&quot;)</span><br><span class="line">			rf.applyCond.Wait()</span><br><span class="line">		&#125;</span><br><span class="line">		firstIndex, commitIndex, lastApplied := rf.logs.GetFirst().Index, rf.commitIdx, rf.lastApplied</span><br><span class="line">		entries := make([]*pb.Entry, commitIndex-lastApplied)</span><br><span class="line">		copy(entries, rf.logs.GetRange(lastApplied+1-int64(firstIndex), commitIndex+1-int64(firstIndex)))</span><br><span class="line">		rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">		PrintDebugLog(fmt.Sprintf(&quot;%d, applies entries %d-%d in term %d&quot;, rf.me_, rf.lastApplied, commitIndex, rf.curTerm))</span><br><span class="line"></span><br><span class="line">		for _, entry := range entries &#123;</span><br><span class="line">			rf.applyCh &lt;- &amp;pb.ApplyMsg&#123;</span><br><span class="line">				CommandValid: true,</span><br><span class="line">				Command:      entry.Data,</span><br><span class="line">				CommandTerm:  int64(entry.Term),</span><br><span class="line">				CommandIndex: int64(entry.Index),</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		rf.mu.Lock()</span><br><span class="line">		rf.lastApplied = int64(Max(int(rf.lastApplied), int(commitIndex)))</span><br><span class="line">		rf.mu.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Raft快照实现分析"><a href="#Raft快照实现分析" class="headerlink" title="Raft快照实现分析"></a>Raft快照实现分析</h3><p>下面是日志快照的RPC定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">message InstallSnapshotRequest &#123;</span><br><span class="line">    int64 term =                1;</span><br><span class="line">    int64 leader_id =           2;</span><br><span class="line">    int64 last_included_index = 3;</span><br><span class="line">    int64 last_included_term  = 4;</span><br><span class="line">    bytes data                = 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message InstallSnapshotResponse &#123;</span><br><span class="line">    int64 term = 1; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rpc Snapshot (InstallSnapshotRequest) returns (InstallSnapshotResponse) &#123;&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>InstallSnapshotRequest中term代表当前发送快照的Leader的任期，Follower将它与自己的任期号来决定是否要接收这个快照。leader_id是当前leader的id,这样客户端访问到Follower节点之后也能快速知道Leader信息。last_included_index和last_included_term还有data可以参见我们第三章图中的介绍，它们记录了打完快照之后第一条日志的索引号和任期号，以及状态机序列化之后的数据。</p>
<p>什么时间点Raft会打快照呢?</p>
<p>我们知道日志条目过多了，我们就需要打快照。在eraft中就是计算当前level中的日志条目s.Rf.GetLogCount()来打快照的，打快照的入口函数是takeSnapshot(index int),传入了当前applied日志的id,然后将状态机的数据序列化，调用Raft层的Snapshot函数。 这个函数通过EraseBeforeWithDel做了删除日志的操作，然后PersisSnapshot将快照中状态数据缓存到了存储引擎中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//</span><br><span class="line">// take a snapshot</span><br><span class="line">//</span><br><span class="line">func (rf *Raft) Snapshot(index int, snapshot []byte) &#123;</span><br><span class="line">	rf.mu.Lock()</span><br><span class="line">	defer rf.mu.Unlock()</span><br><span class="line">	rf.isSnapshoting = true</span><br><span class="line">	snapshotIndex := rf.logs.GetFirstLogId()</span><br><span class="line">	if index &lt;= int(snapshotIndex) &#123;</span><br><span class="line">		rf.isSnapshoting = false</span><br><span class="line">		PrintDebugLog(&quot;reject snapshot, current snapshotIndex is larger in cur term&quot;)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	rf.logs.EraseBeforeWithDel(int64(index) - int64(snapshotIndex))</span><br><span class="line">	rf.logs.SetEntFirstData([]byte&#123;&#125;) // 第一个操作日志号设为空</span><br><span class="line">	PrintDebugLog(fmt.Sprintf(&quot;del log entry before idx %d&quot;, index))</span><br><span class="line">	rf.isSnapshoting = false</span><br><span class="line">	rf.logs.PersisSnapshot(snapshot)</span><br><span class="line">&#125;</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<p>什么时间点Leader会发送快照呢？</p>
<p>在复制的时候我们会判断到peer的prevLogIndex,如果比当前日志的第一条索引号还小，就说明Leader已经把这条日志打到快照中了，这里我们就要构造InstallSnapshotRequest调用Snapshot RPC将快照数据发送给Followr节点，在收到成功响应之后，我们会更新rf.matchIdx，rf.nextId为LastIncludedIndex和LastIncludedIndex + 1，更新到Follower节点复制进度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">if prevLogIndex &lt; uint64(rf.logs.GetFirst().Index) &#123;</span><br><span class="line">	firstLog := rf.logs.GetFirst()</span><br><span class="line">	snapShotReq := &amp;pb.InstallSnapshotRequest&#123;</span><br><span class="line">		Term:              rf.curTerm,</span><br><span class="line">		LeaderId:          int64(rf.me_),</span><br><span class="line">		LastIncludedIndex: firstLog.Index,</span><br><span class="line">		LastIncludedTerm:  int64(firstLog.Term),</span><br><span class="line">		Data:              rf.ReadSnapshot(),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rf.mu.RUnlock()</span><br><span class="line"></span><br><span class="line">	PrintDebugLog(fmt.Sprintf(&quot;send snapshot to %s with %s\n&quot;, peer.addr, snapShotReq.String()))</span><br><span class="line"></span><br><span class="line">	snapShotResp, err := (*peer.raftServiceCli).Snapshot(context.Background(), snapShotReq)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		PrintDebugLog(fmt.Sprintf(&quot;send snapshot to %s failed %v\n&quot;, peer.addr, err.Error()))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rf.mu.Lock()</span><br><span class="line">	PrintDebugLog(fmt.Sprintf(&quot;send snapshot to %s with resp %s\n&quot;, peer.addr, snapShotResp.String()))</span><br><span class="line"></span><br><span class="line">	if snapShotResp != nil &#123;</span><br><span class="line">		if rf.role == NodeRoleLeader &amp;&amp; rf.curTerm == snapShotReq.Term &#123;</span><br><span class="line">			if snapShotResp.Term &gt; rf.curTerm &#123;</span><br><span class="line">				rf.SwitchRaftNodeRole(NodeRoleFollower)</span><br><span class="line">				rf.curTerm = snapShotResp.Term</span><br><span class="line">				rf.votedFor = -1</span><br><span class="line">				rf.PersistRaftState()</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				PrintDebugLog(fmt.Sprintf(&quot;set peer %d matchIdx %d\n&quot;, peer.id, snapShotReq.LastIncludedIndex))</span><br><span class="line">				rf.matchIdx[peer.id] = int(snapShotReq.LastIncludedIndex)</span><br><span class="line">				rf.nextIdx[peer.id] = int(snapShotReq.LastIncludedIndex) + 1</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	rf.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">       </span><br></pre></td></tr></table></figure>

<p>Follower这边操作就比较简单了，它会调用HandleInstallSnapshot处理快照数据，并把快照数据构造pb.ApplyMsg写到rf.applyCh，最后负责日志Apply的Goruntine会调用CondInstallSnapshot安装快照，最后在restoreSnapshot会将快照的data数据解析，让后写入自己的状态机。</p>
<h3 id="Raft如何应对脑裂"><a href="#Raft如何应对脑裂" class="headerlink" title="Raft如何应对脑裂"></a>Raft如何应对脑裂</h3><p>在第三章中我们，介绍了脑裂的场景，并且分过多数派选举协议可以避免脑裂的场景，使得分布式系统在网络分区的情况下也能保持正确性。</p>
<p>Raft是一种多数派选举的协议，现在我们就来看看它是如何应对脑裂的。</p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/images/split_net001.png"/></div></div>

<p>我们看到上图中的场景，一个五节点的系统被分成了两个区，C,D,E为一个区，A,B为一个区。这时候两个分区中都选出了各自的Leader，但是注意B是任期1的Leader，C是任期2 Leader。大家可能会有疑问为什么一定有一个任期更高的Leader，这其实也是多数派选举决定的，分区后，肯定会出现一个多数节点所在的分区，如果这个分区还没有Leader,那么肯定会触发选举。</p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/images/split_net002.png"/></div></div>

<p>之后如下图所示，C,D,E所在分区被写入了SET 8的操作，由于C,D,E有三个节点，超过5个节点的半数以上，所以SET 8这个操作被提交了。然后A,B分区被写入SET 3操作，但是由于它们是少数派，只有两个节点，所以SET 3这个操作写入它们的日志之后并不能被提交。</p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/images/split_net003.png"/></div></div>

<p>最后网络恢复了，B,A收到来自C的更高任期的心跳会秒变Follower并且会将之前没有提交的日志擦除，将Leader C发过来的新日志（带有SET 8操作）写到自己的日志中，这样整个系统仍然是一致的。</p>



<div class="article-footer reveal fs14"><section id="license"><div class="header"><span>License</span></div><div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div></section></div>

</article>

<div class="related-wrap reveal" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">Newer</div><a href="/2023/08/19/kv-distributed-systems/">动手学习分布式-基于Raft库，实现简单的分布式KV系统 (Golang eraftkv 版)</a></div><div class="item" id="next"><div class="note">Older</div><a href="/2023/08/19/raftbasic/">动手学习分布式-Raft论文解读 (Golang eraftkv 版)</a></div></section></div>








      
<footer class="page-footer reveal fs12"><hr><div class="text"><p>本站由 <a href="/">@anonymity</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar">Stellar</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>

      <div class='float-panel mobile-only blur' style='display:none'>
  <button type='button' class='sidebar-toggle mobile' onclick='sidebar.toggle()'>
    <svg class="icon" style="width: 1em; height: 1em;vertical-align: middle;fill: currentColor;overflow: hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="15301"><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 2.3 26.8 24.6 47.5 51.6 47.6h416.5v4z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15302"></path><path d="M566.407 808.3c26.9-0.1 49.3-20.8 51.6-47.6-1.9-27.7-23.9-49.7-51.6-51.6h-412.6c-28.2-1.4-52.6 19.5-55.5 47.6 1.9 27.7 23.9 49.7 51.6 51.6h416.5z m309.3-249.9c26.9-0.1 49.3-20.8 51.6-47.6-2.2-26.8-24.6-47.5-51.6-47.6h-721.9c-27.7-2.8-52.5 17.4-55.3 45.1-0.1 0.8-0.1 1.7-0.2 2.5 0.9 27.2 23.6 48.5 50.7 47.6H875.707z m-103.1-245.9c26.9-0.1 49.3-20.8 51.6-47.6-0.4-28.3-23.2-51.1-51.5-51.6h-618.9c-29.5-1.1-54.3 21.9-55.5 51.4v0.2c1.4 27.8 25.2 49.2 53 47.8 0.8 0 1.7-0.1 2.5-0.2h618.8z" p-id="15303"></path></svg>
  </button>
</div>

    </div>
  </div>
  <div class='scripts'>
    <script type="text/javascript">
  const stellar = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    loadCSS: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    // 从 butterfly 和 volantis 获得灵感
    loadScript: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = stellar.config.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    // https://github.com/jerryc127/hexo-theme-butterfly
    jQuery: (fn) => {
      if (typeof jQuery === 'undefined') {
        stellar.loadScript(stellar.plugins.jQuery).then(fn)
      } else {
        fn()
      }
    }
  };
  stellar.version = '1.19.0';
  stellar.github = 'https://github.com/xaoxuu/hexo-theme-stellar/tree/1.19.0';
  stellar.config = {
    date_suffix: {
      just: 'Just',
      min: 'minutes ago',
      hour: 'hours ago',
      day: 'days ago',
      month: 'months ago',
    },
    root : '/',
  };

  // required plugins (only load if needs)
  stellar.plugins = {
    jQuery: 'https://gcore.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js'
  };

  if ('local_search') {
    stellar.search = {};
    stellar.search.service = 'local_search';
    if (stellar.search.service == 'local_search') {
      let service_obj = Object.assign({}, {"field":"all","path":"/search.json","content":true,"sort":"-date"});
      stellar.search[stellar.search.service] = service_obj;
    }
  }

  // stellar js
  stellar.plugins.stellar = Object.assign({"sites":"/js/plugins/sites.js","friends":"/js/plugins/friends.js","ghinfo":"/js/plugins/ghinfo.js","timeline":"/js/plugins/timeline.js","linkcard":"/js/plugins/linkcard.js","fcircle":"/js/plugins/fcircle.js","weibo":"/js/plugins/weibo.js"});

  stellar.plugins.marked = Object.assign("https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js");
  // optional plugins
  if ('true' == 'true') {
    stellar.plugins.lazyload = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js","transition":"blur"});
  }
  if ('true' == 'true') {
    stellar.plugins.swiper = Object.assign({"enable":true,"css":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.css","js":"https://unpkg.com/swiper@8.4.5/swiper-bundle.min.js"});
  }
  if ('' == 'true') {
    stellar.plugins.scrollreveal = Object.assign({"enable":null,"js":"https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js","distance":"8px","duration":500,"interval":100,"scale":1});
  }
  if ('true' == 'true') {
    stellar.plugins.preload = Object.assign({"enable":true,"service":"flying_pages","instant_page":"https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js","flying_pages":"https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.fancybox = Object.assign({"enable":true,"js":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js","css":"https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css","selector":".swiper-slide img"});
  }
  if ('false' == 'true') {
    stellar.plugins.heti = Object.assign({"enable":false,"css":"https://unpkg.com/heti@0.9.2/umd/heti.min.css","js":"https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js"});
  }
  if ('true' == 'true') {
    stellar.plugins.copycode = Object.assign({"enable":true,"js":"/js/plugins/copycode.js","default_text":"Copy","success_text":"Copied"});
  }
</script>

<!-- required -->

  
<script src="/js/main.js" async></script>



<!-- optional -->



<!-- inject -->


  </div>
</body>
</html>
