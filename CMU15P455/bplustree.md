### 数据库索引介绍
数据库中数据在磁盘是按块存储的，当我们从一个数据量特别大的数据集中去查询修改数据的时候，如果没有任何辅助操作，这些操作的耗时是特别长的，甚至会导致数据库系统的不可用。

那么如何解决这个问题呢？

我们可以从平常查英文字典的方式来获得经验，我们先查单词的首字母，跳到指定的范围再查，这样就加速了我们的查询过程。

同理，B+ 树在数据库系统里面就是这种结构，它保存了数据的索引数据，用来加速我们对数据的检索。
### B+ 树
#### B+ 树的结构以及插入删除节点的算法
**B+树结构**

B+Tree 是一种自平衡树的数据结构，进行搜索、顺序访问、插入和删除的复杂度为 O(log n) 。它主要用来优化基于磁盘的数据库管理系统读写大数据块操作。

几乎每个现代数据库管理系统都支持 B+ 树索引， 在形式上，B+ 树是具有下面属性的 M 路搜索树：

- 它是完美平衡的（每个叶节点都在相同的深度）。
- 除了根之外的每个内部节点至少是半满的（M/2 - 1 <= num of keys <= M-1）。
- 每个具有 k 个键的内部节点都有 k + 1 个非空子节点。
![B+树](https://images.gitbook.cn/2d049d20-6e32-11ec-be56-61b24cad23e5)

上图就是一颗 B+ 树的结构图，我们可以看到树的节点分为叶子节点和内部节点，叶子节点是按顺序存储的。

**B+树的插入操作**

1.找到正确的叶子节点 L

2.将数据条目按排序顺序放入 L
 - 如果 L 有足够的空间，完成操作
 - 否则，将 L 拆分为 L 和一个新节点 L2 ，平均重新分配条目，复制中间键。 将指向 L2 的索引条目插入到 L 的父节点中。

3.若要拆分内部节点: 平均拆分键，中间的键加入到父节点作为索引。

**B+树删除操作**

1.从根开始，找到条目所属的叶子 L

2.删除条目
  - 如果 L 至少是半满的，完成
  - 如果 L 只有 M/2-1 个条目，尝试补满，借用兄弟节点数据（与 L 具有相同父节点的相邻节点）
  - 如果重新分配失败，则合并 L 和兄弟节点。

3.如果发生合并，必须从 L 的父项中删除索引key条目。

**直观的体验B+树操作**

[https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html](https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html)

#### B+ 树的设计决策
1.节点的大小

- B+ 树最佳的节点大小取决于磁盘的访问速度。
- 磁盘速度越慢，节点的大小越大。
- 一些工作负载可能更多的需要扫描（叶子结点数据多对范围扫描有利），而不是单 key 的查询。

一般 HDD (机械硬盘) 1MB; SSD (固态硬盘) 10KB；In-Memory (内存) 512B

2.合并阈值
- 并不是所有的数据库都在节点半满的时候进行合并操作。
- 推迟合并操作可能可以减少节点重组的次数（降低维护 B+ 的开销）。

3.可变长度的 key

- 指针：将 key 存储为指向元组属性的指针（目前很少使用了）。 
- 节点长度可变：B+ 树中的每个节点大小可以不同，但是这需要我们仔细的管理内存，这种方法也很少使用。
- Key Map：在节点中嵌入指向 key - value 对的指针数组。
![Key Map](https://images.gitbook.cn/ce2b5040-7120-11ec-821b-cb3d4a3f26d7)

4.非唯一索引
- 重复的 key：使用相同的叶节点布局，但是多次存重复 key。
![重复的 key](https://images.gitbook.cn/3db982b0-7121-11ec-8c49-0df4e852f5b4)
- 值列表：每个 key 只存储一次，并维护唯一 value 的链表。
![值列表](https://images.gitbook.cn/4a84cf40-7121-11ec-acfe-a7b828d27554)
5.节点内搜索
- 线性：从头到尾的去扫描节点中的 key-value 对，找到要找的 key 时停下来，这种情况下不需要对 key/value 对进行预排序。
- 二分法：调到中间的 key，然后比较中间 key 与我们要搜索的 key 的大小，来判断继续搜索那一边，加快搜索过程，这个操作需要我们对节点内的 key/value 对进行预排序。
- 插值法：根据节点中已知 key 的分布，近似的找到起始位置进行扫描，这个需要对  key/value 对进行预排序。

#### B+ 树的优化
- 前缀压缩

同一个叶子结点中排序好的 key 可能具有相同的前缀，可以利用这个特性在存储的时候存储公共的前缀部分并置存储每个 key 的唯一后缀。
![前缀压缩](https://images.gitbook.cn/b28828d0-7121-11ec-8f13-f1102a7c66dd)
- 后缀截断

![后缀截断](https://images.gitbook.cn/d3329610-7121-11ec-b4dd-df2337c0afc2)
截断后缀之后只存储，adc，lmn 两个关键 key
![后缀截断](https://images.gitbook.cn/22243260-712c-11ec-8f13-f1102a7c66dd)

内部节点 (Inner node) 中的 key 只是用于 "引导搜索"，其实是可以不需要存储整个 key 的内容的，存储可以正确 "引导搜索" 的最小前缀。

- 批量插入

从头开始构建 B+ 树最快的方法是首先对 key 进行排序，然后自下而上构建索引

### B+树并发控制-更高的性能
**没有并发控制下的 B+ 树操作存在的问题**

如果一个线程在搜索，同时另一个线程在分裂或者合并 B+ 树的节点，这个时候会发生什么，我们来看一个例子。

![01](https://images.gitbook.cn/87fb4e40-7049-11ec-8f13-f1102a7c66dd)
T1 线程正在操作删除 B+ 树中 key 为 44 的节点

![02](https://images.gitbook.cn/a13ff6d0-7049-11ec-8c49-0df4e852f5b4)
这个删除操作将会出发 B+ 树的重平衡

![03](https://images.gitbook.cn/be6953a0-7049-11ec-be56-61b24cad23e5)
这时候 T2 线程来查找 key 为 41 的节点

![04](https://images.gitbook.cn/eb1de050-7049-11ec-8f13-f1102a7c66dd)
重平衡让 41 的 key 从 H 转移到新的节点 I ，而 T2 线程并不知道这个事，而是继续按索引往下找到 H 节点

![05](https://images.gitbook.cn/31b8d3d0-704a-11ec-821b-cb3d4a3f26d7)
这样 T2 就错误的以为树中没有 key 为 41 的节点，所以在并发的情况下，B+ 树的操作并不是安全的，那么就需要我们下面的 B+ 树并发控制协议来解决了。

#### 如何做 B+ 树并发控制
基本的 Latch Crabbing 协议

- 搜索(Search)

从根开始向下，反复获取子节点的（Latch）闩锁，然后解锁父节点

- 插入/删除 (Insert/Delete)

从根开始向下走，根据需要获取锁。一旦子节点被上闩锁，检查它是否安全。如果是的，释放它的父节点上的闩锁。

我们来看一个例子，插入值导致 B+ 树重新平衡，我们看上述协议是怎么保证 B+ 数据并发操作的安全的

我们向 B+ 树里面插入 25 
![001](https://images.gitbook.cn/28d0f660-7123-11ec-be56-61b24cad23e5)
插入 25，B 节点是安全的，我们可以释放 A 上的写锁
![002](https://images.gitbook.cn/4f845770-7123-11ec-8f13-f1102a7c66dd)
![003](https://images.gitbook.cn/5ac24d40-7123-11ec-9401-b1de92ea6df8)
C 节点是安全的，我们可以释放 B 上的写锁
![004](https://images.gitbook.cn/651fce20-7123-11ec-aac2-7b60b213f4e0)
插入 25，我们需要分裂 F 节点，所以 C 节点上的锁我们不会释放，需要等到我们这个分裂操作完全完成，这样就可以避免其他线程访问节点返回非预期的结果
![005](https://images.gitbook.cn/6b34f6f0-7123-11ec-8c49-0df4e852f5b4)

![006](https://images.gitbook.cn/72d8fd20-7123-11ec-8c49-0df4e852f5b4)

![007](https://images.gitbook.cn/7e898ae0-7123-11ec-b4dd-df2337c0afc2)

#### 如何优化 B+ 树的并发控制
每个事务都会假设到达目标叶子节点的路径是安全的（乐观，操作不会导致 B+ 树的重平衡），并使用 READ latch 和 crabbing 到达它，并进行验证。如果路径中的任何节点不安全，则执行先前的算法（即，获取 WRITE latch）

- 搜索(Search)

从根开始向下，反复获取子节点的（Latch）闩锁，然后解锁父节点（同之前的算法）。

- 插入/删除 (Insert/Delete)

设置 READ latch ，走到叶子结点并设置 WRITE Latch 在叶子上。如果叶子节点不安全，释放之前所有的 latch ，并重启事务使用之前的 Insert/Delete 协议。

### 参考
- https://15445.courses.cs.cmu.edu/fall2019/schedule.html
- https://eraft.cn
