[{"title":"动手学习分布式-Go语言基础知识 (Golang eraftkv 版)","path":"/2023/08/19/1-2-gobasic/","content":"Go语言优点首先Go是一门开源的语言，他出生名门Google，社区有强有力的顶级技术人员支撑。它最开始的设计者是Rob Pike，Robert Griesemer，Ken Thompson。 你可以在这个页面找到他们的资料 https://golang.design/history/ 其中Ken Thompson是UNIX系统的发明者。 Go语言对于初学者很友好，很容易在短时间内快速上手，你可以通过这个网站上提供的代码示例快速的入门Go语言：https://gobyexample.com。 作为多核时代的语言，Go语言在设计之初就对并发编程有很多内置的支持，提供的及其健壮的相关标准库。利用它，我们可以快速的编写出高并发的应用程序。 最后，国内外很多大厂都在使用Go语言，它有一个强大的社区，全世界优秀的技术人员开发了丰富的工具生态，有很多脚手架帮你快速的构建应用程序。 切片切片是一个数组的一段，它基于数组构建，并提供了更多丰富的数据操作功能，提供开发者灵活和便利的操作数组结构。 在Go语言内部，切片只是对底层数组数据结构的引用。接下来我们将熟悉如何创建和使用切片，并了解它底层是怎么工作的。 使用字面量列表创建切片这种方式类似c++里面的初始化列表 12var s = []int&#123;3, 5, 7, 9, 11, 13, 17&#125; 这种方式创建切片的时候，它首先会创建一个数组，然后返回对该数组切片的引用。 从已有数组创建切片 12// Obtaining a slice from an array `a` a[low:high] 这里我们对a数组进行切割得到切片，这个操作得到的结果是索引[low, high)的元素，生成的切片包括索引低，但是不包括索引高之间的所有数组元素。你可以运行下面的示例，理解这个切片操作 12345678910111213141516171819202122package mainimport &quot;fmt&quot;func main() &#123; var a = [5]string&#123;&quot;Alpha&quot;, &quot;Beta&quot;, &quot;Gamma&quot;, &quot;Delta&quot;, &quot;Epsilon&quot;&#125; // Creating a slice from the array var s []string = a[1:4] fmt.Println(&quot;Array a = &quot;, a) fmt.Println(&quot;Slice s = &quot;, s) &#125; // output Array a = [Alpha Beta Gamma Delta Epsilon] Slice s = [Beta Gamma Delta] 修改切片中的元素由于切片是引用类型，它指向了底层的数组。所以当我们使用切片引用去修改数组中对应的元素的时候，引用相同数组的其他切片对象也会看到这个修改结果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package mainimport &quot;fmt&quot;func main() &#123;\ta := [7]string&#123;&quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, &quot;Sun&quot;&#125;\tslice1 := a[1:]\tslice2 := a[3:]\tfmt.Println(&quot;------- Before Modifications -------&quot;)\tfmt.Println(&quot;a = &quot;, a)\tfmt.Println(&quot;slice1 = &quot;, slice1)\tfmt.Println(&quot;slice2 = &quot;, slice2)\tslice1[0] = &quot;TUE&quot;\tslice1[1] = &quot;WED&quot;\tslice1[2] = &quot;THU&quot;\tslice2[1] = &quot;FRIDAY&quot;\tfmt.Println(&quot; -------- After Modifications --------&quot;)\tfmt.Println(&quot;a = &quot;, a)\tfmt.Println(&quot;slice1 = &quot;, slice1)\tfmt.Println(&quot;slice2 = &quot;, slice2)&#125;// Output------- Before Modifications -------a = [Mon Tue Wed Thu Fri Sat Sun]slice1 = [Tue Wed Thu Fri Sat Sun]slice2 = [Thu Fri Sat Sun]type: post-------- After Modifications --------a = [Mon TUE WED THU FRIDAY Sat Sun]slice1 = [TUE WED THU FRIDAY Sat Sun]slice2 = [THU FRIDAY Sat Sun] 例如上面这个示例，slice2的修改操作在slice1中是能被看到的, slice1的修改在slice2也能被看到。 切片底层结构一个切片由三个部分组成，如图 1.一个指向底层数组的指针Ptr2.切片所包含数组段的长度Len3.切片的容量Cap 我们看一个具体的切片结构的底层示例： 12var a = [6]int&#123;10, 20, 30, 40, 50, 60&#125; var s = [1:4] s在Go内部是这样表示的： 一个切片的长度和容量我们是可以通过len(), cap()函数获取的，例如我们可以通过下面的方式获取s的长度和容量。 1234567891011121314package mainimport &quot;fmt&quot;func main() &#123;\ta := [6]int&#123;10, 20, 30, 40, 50, 60&#125;\ts := a[1:4]\tfmt.Printf(&quot;s = %v, len = %d, cap = %d &quot;, s, len(s), cap(s))&#125;// outputs = [20 30 40], len = 3, cap = 5 GoruntineGoruntine是由Go运行时所管理的一个轻量级的线程，一个Go程序中的Goroutines在相同的地址空间中运行，因此对共享内存的访问必须同步。我们运行一个简单地示例来看看： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package main import (\t&quot;fmt&quot;\t&quot;time&quot;)func say(s string) &#123;\tfor i := 0; i &lt; 5; i++ &#123; time.Sleep(100 * time.Millisecond) fmt.Println(s)\t&#125;&#125;func main() &#123;\tgo say(&quot;world&quot;)\tsay(&quot;hello&quot;)&#125;// outputhelloworldhelloworldhelloworldworldhellohello 我们可以看到主线程中say(“hello”)和goruntine的say(“world”)在交替的输出，它们在同时的运行，在其他语言做这个事情先要创建线程，然后绑定相关的执行函数，而Go语言直接把并发设计到了编译器语言支持层面，用go关键字就可以轻松地创建轻量级的线程。 捐赠整理这本书耗费了我们大量的时间和精力。如果你觉得有帮助，一瓶矿泉水的价格支持我们继续输出优质的分布式存储知识体系，2.99¥，感谢大家的支持。 下载 PDF 版本 本站总访问量次"},{"title":"动手学习分布式-体验分布式系统 (Golang eraftkv 版)","path":"/2023/08/19/hello-world/","content":"体验分布式KV存储系统 eraftkv作为系列的开篇，我们将带着大家从顶层体验下分布式系统，我们将忽略系统实现的细节点，直观感受一个分布式系统所具备的能力。本书还是第一个版本，我们还在不断的校对完善中，评论区是放开的，欢迎大家讨论参与本书的优化。 安装go编译环境首先我们需要在电脑上安装好go语言编译器，你可以在 https://go.dev/dl/官网下载对应你系统版本的安装包。 按指示https://go.dev/doc/install安装golang编译环境。 编译构建 eraftkv执行以下命令(确保你的机器上安装了Go语言编译器以及git, make等基础工具)编译很简单，下载代码之后，进入根目录直接 make 123git clone https://github.com/eraftorg/eraft.git -b mit6824_lab cd eraft make 架构概览在我们运行eraftkv之前我们先概览以下它的架构，以便于我们对于接下来运行的程序功能有清晰的认识。 eraftkv作为一个分布式kv存储系统，其中包含的服务角色以及一些概念需要提前给大家介绍一下。 系统中的一些概念 bucket -它是集群做数据管理的逻辑单元，一个分组的ShardServer服务可以负责多个bucket的数据。 config table -集群配置表，它主要维护了集群服务分组与bucket的映射关系，客户端访问集群数据之前需要先到这个表查询要访问bucket所在的服务分组列表。 系统中有三种角色 Client -客户端，它是用户使用我们这个分布式的接入端。 ConfigServer -配置服务器，它是系统的配置管理中心，它存储了集群的路由配置信息。 ShardServer -数据服务器，它是系统中实际存储用户数据的服务器。 请求处理流程看了架构概览，大家可能有觉得概念有些模糊，我们接下来就分析一个具体的请求示例，看看这个分布式系统是如何工作起来的。例如现在客户端来了一个put testkey testvalue的请求： 1.客户端程序启动运行的时候会从ConfigServer获取到最新的路由信息表。 2.put testkey testvalue操作首先会计算testkey的CRC32哈希值对集群中的bucket数取模算到这个key命中了哪个bucket。 3.之后客户端将put请求内容打包成一个rpc请求包，发送到集群配置表中负责这个bucket的ShardServer服务分组。 4.Leader ShardServer服务收到这个rpc请求后并不是直接写入存储引擎，而是构造一个raft提案，提交到raft状态机，当分组中半数节点以上的ShardServer都同意这个操作后(如果你没有接触过分布式一致性算法，这里可以先不用理解细节，我们会在Raft论文解读一章详细解读为什么要这样做)，作为Leader的ShardServer服务器才能返回给客户端写入成功。 让系统跑起来，体验它！前面我们构建完eraftkv之后，在eraft目录有一个output文件夹，里面有我们需要运行的bin文件。 12345678 colin@B-M1-0045 eraft % ls -l output total 124120-rwxr-xr-x 1 colin staff 12119296 5 25 20:40 bench_cli-rwxr-xr-x 1 colin staff 12114784 5 25 20:40 cfgcli-rwxr-xr-x 1 colin staff 13578848 5 25 20:40 cfgserver-rwxr-xr-x 1 colin staff 12127328 5 25 20:40 shardcli-rwxr-xr-x 1 colin staff 13600368 5 25 20:40 shardserver 可执行文件介绍1.cfgserverConfigServer的可执行文件，系统的配置管理中心，需要首先启动 2.cfgcliConfigServer的客户端工具，它和ConfigServer交互用来管理集群的配置 3.shardserverShardServer的可执行文件，它负责存储用户的数据 4.shardcliShardServer的客户端工具，用户可以使用它向集群中写入数据 5.bench_cli系统的性能测试工具 启动服务1.启动配置服务器分组 123./cfgserver 0 127.0.0.1:8088,127.0.0.1:8089,127.0.0.1:8090./cfgserver 1 127.0.0.1:8088,127.0.0.1:8089,127.0.0.1:8090./cfgserver 2 127.0.0.1:8088,127.0.0.1:8089,127.0.0.1:8090 2.初始化集群配置 1234./cfgcli 127.0.0.1:8088,127.0.0.1:8089,127.0.0.1:8090 join 1 127.0.0.1:6088,127.0.0.1:6089,127.0.0.1:6090./cfgcli 127.0.0.1:8088,127.0.0.1:8089,127.0.0.1:8090 join 2 127.0.0.1:7088,127.0.0.1:7089,127.0.0.1:7090./cfgcli 127.0.0.1:8088,127.0.0.1:8089,127.0.0.1:8090 move 0-4 1./cfgcli 127.0.0.1:8088,127.0.0.1:8089,127.0.0.1:8090 move 5-9 2 3.启动数据服务器分组 1234567./shardserver 0 1 127.0.0.1:8088,127.0.0.1:8089,127.0.0.1:8090 127.0.0.1:6088,127.0.0.1:6089,127.0.0.1:6090./shardserver 1 1 127.0.0.1:8088,127.0.0.1:8089,127.0.0.1:8090 127.0.0.1:6088,127.0.0.1:6089,127.0.0.1:6090./shardserver 2 1 127.0.0.1:8088,127.0.0.1:8089,127.0.0.1:8090 127.0.0.1:6088,127.0.0.1:6089,127.0.0.1:6090./shardserver 0 2 127.0.0.1:8088,127.0.0.1:8089,127.0.0.1:8090 127.0.0.1:7088,127.0.0.1:7089,127.0.0.1:7090./shardserver 1 2 127.0.0.1:8088,127.0.0.1:8089,127.0.0.1:8090 127.0.0.1:7088,127.0.0.1:7089,127.0.0.1:7090./shardserver 2 2 127.0.0.1:8088,127.0.0.1:8089,127.0.0.1:8090127.0.0.1:7088,127.0.0.1:7089,127.0.0.1:7090 4.读写数据 12./shardcli 127.0.0.1:8088,127.0.0.1:8089,127.0.0.1:8090 put testkey testvalue ./shardcli 127.0.0.1:8088,127.0.0.1:8089,127.0.0.1:8090 get testkey 5.运行基准测试 1./bench_cli 127.0.0.1:8088,127.0.0.1:8089,127.0.0.1:8090 100 put 捐赠整理这本书耗费了我们大量的时间和精力。如果你觉得有帮助，一瓶矿泉水的价格支持我们继续输出优质的分布式存储知识体系，2.99¥，感谢大家的支持。 下载 PDF 版本 本站总访问量次"}]