1
00:00:01,300 --> 00:00:05,129
[音乐]
[Music]

2
00:00:05,200 --> 00:00:05,930
[掌声]
[Applause]

3
00:00:05,930 --> 00:00:08,630
[音乐]
[Music]

4
00:00:08,630 --> 00:00:10,020
[掌声]
[Applause]

5
00:00:10,020 --> 00:00:12,650
[音乐]
[Music]

6
00:00:12,650 --> 00:00:16,550
正如我所说的，这周我不能在校园里
as I said I can't be on campus this week

7
00:00:16,550 --> 00:00:19,770
我现在还在欧洲我
I'm still here in Europe right now I am

8
00:00:19,770 --> 00:00:22,650
实际上在慕尼黑在 Tum 拜访
actually in Munich visiting Thomas

9
00:00:22,650 --> 00:00:25,439
托马斯诺曼，那就是 他们在那里
Norman at at T um and that's where they

10
00:00:25,439 --> 00:00:27,570
发明了 hyper 和新数据库 并
invented hyper and the new database and

11
00:00:27,570 --> 00:00:30,449
放了一把雨伞 所以我
putting an umbrella so part of me going

12
00:00:30,449 --> 00:00:32,610
去拜访 Thomas 的一部分
down to visit Thomas is sort of to sort

13
00:00:32,610 --> 00:00:34,290
是为了更好地理解为什么
of get a better understanding why the

14
00:00:34,290 --> 00:00:36,780
德国人如此擅长数据库，因此
Germans are so good at databases and so

15
00:00:36,780 --> 00:00:39,989
作为其中的一部分，他们把我带到了这里
as part of this they took me up here in

16
00:00:39,989 --> 00:00:41,670
在阿尔卑斯山的某个山上，我
the Alps somewhere in the mountains I

17
00:00:41,670 --> 00:00:43,140
不知道我们到底在哪里，
don't know exactly where we are it's

18
00:00:43,140 --> 00:00:45,570
天气很冷，就像这样，
freezing and the idea it's like this you

19
00:00:45,570 --> 00:00:47,969
你在树林里，思考你的想法大约
go in the woods and you think about your

20
00:00:47,969 --> 00:00:49,530
一个小时，或者
thoughts for like an hour or something

21
00:00:49,530 --> 00:00:51,750
以某种方式会神奇地让你
somehow that's gonna magically make you

22
00:00:51,750 --> 00:00:54,930
更好地理解数据库 所以无论
better understand databases so whatever

23
00:00:54,930 --> 00:00:56,399
我现在坐在这里，
I'm just sitting here now it's freezing

24
00:00:56,399 --> 00:00:58,020
天气都非常寒冷，有一些猎犬在
cold there's some hunting dog running

25
00:00:58,020 --> 00:01:00,180
四处乱跑，你可能会
around fighting things you may see that

26
00:01:00,180 --> 00:01:02,789
在背景中看到这些东西，我认为现在是
in the background and I thought it'd be

27
00:01:02,789 --> 00:01:04,049
通过并开始
a good time to get through and start

28
00:01:04,049 --> 00:01:07,619
讨论下一个讲座的好时机，所以让我们看看
discussing the next lecture so let's see

29
00:01:07,619 --> 00:01:09,330
如何 我们可以得到 b 在它变得太冷之前，
how far we can get before it gets too

30
00:01:09,330 --> 00:01:14,189
最后一节课我们讨论
cold so the last class we discussed the

31
00:01:14,189 --> 00:01:16,530
了数据库系统的高级历史
sort of a high-level history of database

32
00:01:16,530 --> 00:01:19,670
，我主要关注
systems and primarily what I focused on

33
00:01:19,670 --> 00:01:24,020
was sort of thinking about the problem

34
00:01:24,020 --> 00:01:29,700
的是在高级别的方面思考问题，主要
in terms of like at a high level mostly

35
00:01:29,700 --> 00:01:31,680
基于你知道的数据模型 无论
based on data models you know whether it

36
00:01:31,680 --> 00:01:33,479
是 codasyl 的东西还是
was the codasyl stuff or the the

37
00:01:33,479 --> 00:01:35,490
层次数据模型、关系
hierarchal data model the relational

38
00:01:35,490 --> 00:01:38,610
数据模型等等，这都是
data model and so that was the sort of

39
00:01:38,610 --> 00:01:41,970
上一堂课的主要讨论，另
main discussion of last class another

40
00:01:41,970 --> 00:01:43,200
一种思考方式是
way to sort of think about it was an

41
00:01:43,200 --> 00:01:45,240
贯穿整个
overarching theme throughout the entire

42
00:01:45,240 --> 00:01:48,869
数据库历史的一个总体主题，就是这种不断的
history of databases is this constant

43
00:01:48,869 --> 00:01:51,329
斗争 构建
struggle of building database systems

44
00:01:51,329 --> 00:01:53,369
必须处理
that have to deal with the limitations

45
00:01:53,369 --> 00:01:56,189
当时港口限制的数据库系统
of the harbor at the time right it's the

46
00:01:56,189 --> 00:01:58,409
1970 年代和 1960 年代一样，现在
same in the 1970s 1960s as it is now

47
00:01:58,409 --> 00:01:59,880
我们知道我们一直在尝试
we're you know we're always trying to

48
00:01:59,880 --> 00:02:03,000
在新硬件上运行数据库并
run databases on new hardware and get

49
00:02:03,000 --> 00:02:05,790
获得最佳性能 我们可以
the best performance we can out of it so

50
00:02:05,790 --> 00:02:08,068
在 1970 年代摆脱它，尽管当他们
back in the 1970s though when they built

51
00:02:08,068 --> 00:02:09,538
构建第一个关系数据库系统
the first relational database systems

52
00:02:09,538 --> 00:02:11,819
数据库系统时，硬件与我们今天的有
database systems the hardware it was a

53
00:02:11,819 --> 00:02:13,470
很大不同
lot different than what we

54
00:02:13,470 --> 00:02:16,890
，但在高层次上 ic的
today but at a high level the the basic

55
00:02:16,890 --> 00:02:20,010
想法仍然相同，所以
idea is still the same and so the

56
00:02:20,010 --> 00:02:21,270
问题就像我们开始
problem though is like when we start to

57
00:02:21,270 --> 00:02:24,870
谈论现代系统时一样，
talk about modern systems the although

58
00:02:24,870 --> 00:02:27,660
尽管基本思想仍然相同
the basic idea is still the same the

59
00:02:27,660 --> 00:02:29,460
，但港湾的限制并不
limitations that harbour is not exactly

60
00:02:29,460 --> 00:02:34,110
完全相同，所以在1970年代，
the same so back then in the 1970s all

61
00:02:34,110 --> 00:02:35,670
好吧，您没有“ 没有有
right you didn't have machines with a

62
00:02:35,670 --> 00:02:37,320
很多插槽的机器 有很多关于一个核心的
lot of sockets a lot of about a cores

63
00:02:37,320 --> 00:02:39,210
权利 你有一个单元处理器 你有一个
right you had a unit processor you had a

64
00:02:39,210 --> 00:02:42,090
单核 CPU
single single core CPU that could really

65
00:02:42,090 --> 00:02:45,270
一次只能执行一个线程
only execute one thread at a time the

66
00:02:45,270 --> 00:02:47,490
内存也受到严重限制 它非常
rams also severely limited it was very

67
00:02:47,490 --> 00:02:50,280
昂贵 所以你是你 很幸运
expensive so you were you were lucky to

68
00:02:50,280 --> 00:02:51,810
让你知道一台机器有 diarrea 但
get you know a machine had diarrea but

69
00:02:51,810 --> 00:02:54,780
也许就像一个兆字节抱歉现在
maybe like of like a megabyte sorry now

70
00:02:54,780 --> 00:02:56,430
我们可以在
we can go into the terabyte so in a

71
00:02:56,430 --> 00:02:59,190
一个盒子里进入 TB 因为麸皮有限
single box and because bran was limited

72
00:02:59,190 --> 00:03:00,750
我们将整个数据库存储在
we had a store the entire database on

73
00:03:00,750 --> 00:03:02,910
磁盘上所以整个架构
disk and so the the whole architecture

74
00:03:02,910 --> 00:03:04,770
数据库系统基于
the database system was predicated on

75
00:03:04,770 --> 00:03:07,500
您知道从磁盘检索数据
you know retrieving data from disk and

76
00:03:07,500 --> 00:03:09,810
，当然当时
of course back then this were way slower

77
00:03:09,810 --> 00:03:12,660
这比现在慢得多，当然
than they were now and certainly the

78
00:03:12,660 --> 00:03:15,780
顺序访问
sequential access was was much faster

79
00:03:15,780 --> 00:03:18,269
比随机访问快得多，因此您尝试
than random access so you try to design

80
00:03:18,269 --> 00:03:20,550
设计 算法和数据结构
algorithms and data structures that

81
00:03:20,550 --> 00:03:24,570
可以最大限度地访问，所以现在
could maximize going to access so now in

82
00:03:24,570 --> 00:03:29,160
在现代时代，你知道 20 20 年代，现在
the modern era in you know 20 20 s now

83
00:03:29,160 --> 00:03:31,650
我们拥有拥有足够 DRAM 的机器，
we have machines that have enough DRAM

84
00:03:31,650 --> 00:03:34,709
这样大多数数据库可能
such that most databases can probably

85
00:03:34,709 --> 00:03:36,780
完全适合主内存，并且
fit entirely in main memory and there's

86
00:03:36,780 --> 00:03:38,250
总是会有异常值
always going to be the outliers there's

87
00:03:38,250 --> 00:03:39,930
永远是你知道世界上的谷歌
always going to be you know the googles

88
00:03:39,930 --> 00:03:41,250
、Facebook 和亚马逊
and the Facebook's and Amazon's of the

89
00:03:41,250 --> 00:03:43,170
，他们的数据但他们的
world where their data but their

90
00:03:43,170 --> 00:03:45,180
数据库可能是 PB 的大小，
databases can be in the size of

91
00:03:45,180 --> 00:03:48,510
但对于大约 99% 的
petabytes but for probably 99% of the

92
00:03:48,510 --> 00:03:50,310
应用程序，他们的数据库可能
applications their database maybe

93
00:03:50,310 --> 00:03:53,190
以 GB 或几
measures in in gigabytes or a few

94
00:03:53,190 --> 00:03:56,160
TB 为单位，所以 再次使用
terabytes and so again with that with

95
00:03:56,160 --> 00:03:57,390
这种大小，您当然可以拥有一个
that size you can certainly have a

96
00:03:57,390 --> 00:03:59,209
完全适合主内存的数据库，
database fit entirely in main memory

97
00:03:59,209 --> 00:04:01,380
无论它是分布式系统还是
whether it's a distributed system or a

98
00:04:01,380 --> 00:04:05,150
单节点系统，以便了解为什么
single node system so to understand why

99
00:04:05,150 --> 00:04:07,739
您知道的数据库
databases you know aren't as maybe as

100
00:04:07,739 --> 00:04:09,810
没有您认为的那么大，您
large as you think they actually are you

101
00:04:09,810 --> 00:04:11,519
必须了解
gotta understand that there's a sort of

102
00:04:11,519 --> 00:04:12,900
结构化和
difference between structured and

103
00:04:12,900 --> 00:04:14,340
非结构化数据或半结构化
unstructured data or semi structured

104
00:04:14,340 --> 00:04:17,070
数据之间存在某种差异，因此结构化数据集或成为
data so structured data sets or be

105
00:04:17,070 --> 00:04:18,510
我们通常谈论的事物
things that we mean normal talked about

106
00:04:18,510 --> 00:04:19,978
与您有关数据库，因此您有一个
with you about databases so you have a

107
00:04:19,978 --> 00:04:23,310
明确定义的模式，它们具有
well-defined schema they have attributes

108
00:04:23,310 --> 00:04:25,080
正确的属性，并且每个记录都必须具有这些
right and every record has to have those

109
00:04:25,080 --> 00:04:27,669
属性，因此在这些数据中，
attributes and so in those data

110
00:04:27,669 --> 00:04:29,169
它们通常又是
they're usually again these are

111
00:04:29,169 --> 00:04:31,930
通常较小的非结构化数据
typically smaller unstructured data sets

112
00:04:31,930 --> 00:04:35,409
集，例如视频文件声音
would be things like video files sound

113
00:04:35,409 --> 00:04:37,509
文件或 正确的图像在这些情况
files or images right these are things

114
00:04:37,509 --> 00:04:39,759
下
where the contents of every single

115
00:04:39,759 --> 00:04:41,860
，该数据集中每条记录的内容都会
record in in that data set are is going

116
00:04:41,860 --> 00:04:43,659
有所不同，或者根本没有任何
to be different or there's not even any

117
00:04:43,659 --> 00:04:45,219
结构，而且您知道您不能
structure at all and you know you can't

118
00:04:45,219 --> 00:04:49,469
直接对半结构化的视频数据运行查询
run queries directly on on a video data

119
00:04:49,469 --> 00:04:52,120
semi-structured would be things like log

120
00:04:52,120 --> 00:04:54,249
是诸如生成的日志文件之类的东西，
files that are generated such that

121
00:04:54,249 --> 00:04:55,300
它们本来是人类
they're they're meant to be human

122
00:04:55,300 --> 00:04:58,449
可读的，但是您知道它们
readable but they're you know they're

123
00:04:58,449 --> 00:05:00,759
不会为每条日志记录提供完全相同的字段，
not gonna have the exact same fields for

124
00:05:00,759 --> 00:05:03,159
您可以解析
every single log record you can parse

125
00:05:03,159 --> 00:05:05,409
它们并提取这些字段 但你
them and extract those fields but you

126
00:05:05,409 --> 00:05:06,699
知道一些爱情记录可能有其他
know some love records might have other

127
00:05:06,699 --> 00:05:09,909
领域 其他可能有其他领域 所以
fields other ones might have others so

128
00:05:09,909 --> 00:05:11,680
再次非结构化和半结构化
again unstructured and semi-structured

129
00:05:11,680 --> 00:05:13,689
数据集 这些通常更大，你
data sets these are typically larger you

130
00:05:13,689 --> 00:05:16,689
认为像 YouTube YouTube 是的
think of like YouTube YouTube yeah the

131
00:05:16,689 --> 00:05:19,300
，我的续集 l 他们
the my sequel database that that they

132
00:05:19,300 --> 00:05:21,939
在 YouTube 中使用的数据库，你知道这将
use in YouTube you know that's gonna be

133
00:05:21,939 --> 00:05:23,800
a fraction of the size of the total

134
00:05:23,800 --> 00:05:25,150
是他们存储的视频总量的一小部分
amount of video that they're storing and

135
00:05:25,150 --> 00:05:26,379
，视频所有非结构化的
the videos all the unstructured stuff

136
00:05:26,379 --> 00:05:29,370
东西，我的续集四十年代数据库是
the my sequel forties database is the

137
00:05:29,370 --> 00:05:32,469
结构化数据库，所以为了我们的目的，
structured database so for our purposes

138
00:05:32,469 --> 00:05:34,419
这里 在本课程中，我们将
here in this class we're primarily going

139
00:05:34,419 --> 00:05:36,960
主要关注结构化数据，因为
to focus on the structured data because

140
00:05:36,960 --> 00:05:39,490
只有您知道您
that's really only you know you can kind

141
00:05:39,490 --> 00:05:40,360
可以做我们在这里谈论的事情，
of do the things that we're talking

142
00:05:40,360 --> 00:05:42,159
但是没有神奇的方法可以
about here but there's no magic way to

143
00:05:42,159 --> 00:05:44,560
对视频数据进行矢量化查询执行，
do vectorize query execution on video

144
00:05:44,560 --> 00:05:46,539
您会怎么做？ 必须做的是，您必须
data what do you have to do you have to

145
00:05:46,539 --> 00:05:48,550
将该视频数据转换为结构化
convert that video data into structured

146
00:05:48,550 --> 00:05:49,599
数据，然后您可以在其上运行您的查询
data and then you can run your queries

147
00:05:49,599 --> 00:05:53,409
，因此它们将
on it so right so they so that's gonna

148
00:05:53,409 --> 00:05:55,060
成为我们今天在这里的扑克服务器我们
be the poker server for ourselves here

149
00:05:55,060 --> 00:05:58,449
today the other thing we need to

150
00:05:58,449 --> 00:06:01,680
现在还需要了解的另一件事是 我们
understand also now is that how are we

151
00:06:01,680 --> 00:06:03,430
以及我们将如何
and how we're gonna get the best

152
00:06:03,430 --> 00:06:05,409
在 davis 主义中获得最佳性能以在
performance in a davis ism to run on the

153
00:06:05,409 --> 00:06:08,589
结构化数据上运行，因此您可能认为没问题，
structured data so you may think all

154
00:06:08,589 --> 00:06:10,449
如果我的数据库
right well if my database can mostly

155
00:06:10,449 --> 00:06:12,849
可以主要用于主内存，我可以
this is to fit on main memory can I take

156
00:06:12,849 --> 00:06:15,339
采用您知道的传统 磁盘或
a you know traditional disk or a

157
00:06:15,339 --> 00:06:18,580
数据库系统就像我
database system as as one as I described

158
00:06:18,580 --> 00:06:20,229
上学期在介绍课上描述的那样，
last semester in the introduction class

159
00:06:20,229 --> 00:06:22,479
我们可以让你知道
can we just give that you know run that

160
00:06:22,479 --> 00:06:25,029
在一台机器上运行它，
on a machine with a large enough large

161
00:06:25,029 --> 00:06:26,409
通过 Ram 运行它，并通过 Ram 将缓冲池
nut via Ram and set the buffer pool

162
00:06:26,409 --> 00:06:29,500
缓存大小设置为足够大，以便
cache size to be big enough such that

163
00:06:29,500 --> 00:06:30,759
一切都会在记忆
everything's gonna fit in a memory is

164
00:06:30,759 --> 00:06:32,050
中 足以让我们
that going to be enough for us to get

165
00:06:32,050 --> 00:06:34,060
获得最佳表现 剧透
the best performance and the spoiler is

166
00:06:34,060 --> 00:06:35,680
是不对的 我们需要
gonna be no right and we need to

167
00:06:35,680 --> 00:06:38,589
了解为什么 所以今天的讲座
understand why so for today's lecture

168
00:06:38,589 --> 00:06:40,569
看看我们能走多远 在我们变得太冷之前
see how far we can get before we get too

169
00:06:40,569 --> 00:06:41,560
cold

170
00:06:41,560 --> 00:06:43,630
是 我们将首先讨论什么是
is that we're gonna first discuss what a

171
00:06:43,630 --> 00:06:45,700
角膜数据库系统，这样我们就可以
dis cornea database system is so we can

172
00:06:45,700 --> 00:06:47,200
理解你知道，当我们开始
understand you know when we started

173
00:06:47,200 --> 00:06:49,180
谈论模仿系统时，它们如何
talking on imitative systems how do they

174
00:06:49,180 --> 00:06:52,210
避免
avoid all the bottlenecks of the

175
00:06:52,210 --> 00:06:54,580
扭曲系统的减速问题的所有瓶颈，
slowdown issues of distorting system

176
00:06:54,580 --> 00:06:57,130
然后我们将从这里开始讨论
then we're to talk about from this we

177
00:06:57,130 --> 00:06:58,510
可以更深入地了解当前的
can go a little deeper into the current

178
00:06:58,510 --> 00:06:59,740
角色，看看
role and see what are the bottlenecks

179
00:06:59,740 --> 00:07:01,690
我们必须克服哪些瓶颈才能让这些
that we have to overcome to get these

180
00:07:01,690 --> 00:07:04,150
控制协议在内存系统中运行，
control protocols to run in in memory

181
00:07:04,150 --> 00:07:08,800
所以我
systems so the the definition that I

182
00:07:08,800 --> 00:07:10,510
总是喜欢使用磁盘或任何数据的
always like to use for a disc or any

183
00:07:10,510 --> 00:07:13,690
定义 Tabase 系统是这样一种
database system is one where the the

184
00:07:13,690 --> 00:07:15,700
系统，其中系统的架构系统
architecture system of the system is

185
00:07:15,700 --> 00:07:18,490
基于这样的假设：
predicated on the assumption that the

186
00:07:18,490 --> 00:07:20,169
主要搜索位置数据库
primary search location the database

187
00:07:20,169 --> 00:07:22,090
就像数据库的所有内容一样，
like all the contents of the database

188
00:07:22,090 --> 00:07:23,740
那里有记录和索引以及使用过的材料
there's records and indexes and material

189
00:07:23,740 --> 00:07:25,290
，商店中的所有东西
that's used everything with the store is

190
00:07:25,290 --> 00:07:27,700
都将处于某种状态 非易失性
going to be on some kind of non-volatile

191
00:07:27,700 --> 00:07:29,380
存储，但这是一个旋转的磁盘硬盘
storage but that's a spinning disk hard

192
00:07:29,380 --> 00:07:32,650
驱动器或 SSD，因此这意味着将
drive or an SSD so that means that the

193
00:07:32,650 --> 00:07:34,750
database is going to be designed based

194
00:07:34,750 --> 00:07:35,680
基于此假设设计数据库，因此所有
on this assumption and therefore all the

195
00:07:35,680 --> 00:07:37,479
算法，数据结构以及其中的
algorithms the data structures and

196
00:07:37,479 --> 00:07:39,340
所有内容都
everything that's on inside of it has to

197
00:07:39,340 --> 00:07:40,870
必须意识到 你知道在任何时候我们
be aware that you know at any time we

198
00:07:40,870 --> 00:07:42,419
都可能不得不从磁盘中获取一些东西，
could have to go get something from disk

199
00:07:42,419 --> 00:07:44,860
现在数据库本身将被
now the database itself will be

200
00:07:44,860 --> 00:07:47,320
组织成一组固定长度的
organized into a set of fixed length

201
00:07:47,320 --> 00:07:48,789
页面或有时会变成
pages or stuff that sometimes goes

202
00:07:48,789 --> 00:07:51,700
块的东西，然后我们将使用 Emery
blocks and then we're gonna use a Emery

203
00:07:51,700 --> 00:07:54,430
缓冲管理器来存储或缓存
buffering manager to store or cache the

204
00:07:54,430 --> 00:07:56,950
当我们再次从磁盘接收内存页面时，
pages in memory as we receive them from

205
00:07:56,950 --> 00:07:59,320
我们假设是冯诺依曼
disk again we're assuming a von Neumann

206
00:07:59,320 --> 00:08:01,990
架构，这意味着我们不能
architecture and that means we can't you

207
00:08:01,990 --> 00:08:04,630
知道不能直接对数据进行操作，
know can't operate directly on on data

208
00:08:04,630 --> 00:08:07,270
因为它退出 您知道磁盘上的 sts 可以
as it exists on disk you know that can

209
00:08:07,270 --> 00:08:09,039
在某些现代硬件中更改，但出于
change in some modern hardware but for

210
00:08:09,039 --> 00:08:10,570
我们的目的，这里假设
our purposes here assume that's not the

211
00:08:10,570 --> 00:08:13,240
情况并非如此，因此更可取的
case and therefore the preferable

212
00:08:13,240 --> 00:08:15,490
管理器实际上是关于如何根据需要决定
manager is really all about how deciding

213
00:08:15,490 --> 00:08:16,900
如何
how to move this data back and forth

214
00:08:16,900 --> 00:08:19,750
在磁盘和内存之间来回移动这些数据，我们
between disk and memory as needed and we

215
00:08:19,750 --> 00:08:20,800
想要 以这样一种方式做到这一点，我们可以
want to do this in such a way that we

216
00:08:20,800 --> 00:08:23,770
最大限度地减少停顿量或
minimize the amount of stalling or the

217
00:08:23,770 --> 00:08:25,240
我们必须退出
amount of times we have to go out the

218
00:08:25,240 --> 00:08:28,930
磁盘的次数，因此该缓冲池
disk so this buffer pool is sort of the

219
00:08:28,930 --> 00:08:32,589
是区分磁盘或
key thing that differentiates a disk or

220
00:08:32,589 --> 00:08:33,969
内存数据库
nativism with the in-memory database

221
00:08:33,969 --> 00:08:35,409
系统与本地化的关键 就像架构一样，
system from terms of like the

222
00:08:35,409 --> 00:08:38,830
所以将会发生的是
architecture so what's gonna happen is

223
00:08:38,830 --> 00:08:39,700
我们将有一个将
we'll have a query that's going to

224
00:08:39,700 --> 00:08:41,919
在我们的系统中执行的查询，并且在任何时候
execute in our system and anytime that

225
00:08:41,919 --> 00:08:43,809
要求访问元组我们必须
asks to access a tuple we have to go

226
00:08:43,809 --> 00:08:46,029
找到我们的元组所在的页面，
find the page that our tuple is located

227
00:08:46,029 --> 00:08:49,000
所以数据说去检查
in so the data says go check to see

228
00:08:49,000 --> 00:08:50,680
查看该查询所需的页面
whether that page that it needs for that

229
00:08:50,680 --> 00:08:53,470
是否已经在内存中，如果是，那么
query is already in memory if it is then

230
00:08:53,470 --> 00:08:54,850
我们只需将指针返回
we just hand back the pointer to where

231
00:08:54,850 --> 00:08:55,810
slow

232
00:08:55,810 --> 00:08:57,310
到正确轮询的慢速位置，
from our proper poll and the query can

233
00:08:57,310 --> 00:09:00,160
如果不是，则查询可以执行，然后我们开始
execute if it's not then we start need

234
00:09:00,160 --> 00:09:02,529
需要做一些额外的 stu  ff 所以我们必须做的第一件事
to do some extra stuff so first thing we

235
00:09:02,529 --> 00:09:05,380
是我们必须决定我们要将
have to go we have to go do is well we

236
00:09:05,380 --> 00:09:07,450
got to decide what frame we want to copy

237
00:09:07,450 --> 00:09:10,389
页面复制到缓冲池中的帧，因此帧
our page into our buffer pool so a frame

238
00:09:10,389 --> 00:09:12,820
只是
is just a location in the allocated

239
00:09:12,820 --> 00:09:14,680
我们盈利管理器分配的内存中的一个位置，我们
memory of our profitable manager and we

240
00:09:14,680 --> 00:09:15,940
使用它 用于
use this term to differentiate it

241
00:09:15,940 --> 00:09:19,060
区分页面或块的术语，因为对于不同
between a page or a block because that's

242
00:09:19,060 --> 00:09:20,680
的页面会反复使用相同的框架
the same frames gonna be used over and

243
00:09:20,680 --> 00:09:23,410
，所以如果
over again for different pages so if

244
00:09:23,410 --> 00:09:25,990
有一个空闲的框架，那么我们的工作很
there's a free frame then our job is

245
00:09:25,990 --> 00:09:27,699
简单，我们只是说这是
easy we just say this is that frame that

246
00:09:27,699 --> 00:09:29,529
我们要放置的框架 我们
we're gonna put our page in we go fetch

247
00:09:29,529 --> 00:09:30,790
从磁盘中获取它并复制进来，然后我们就
it from disk and copied in and we're

248
00:09:30,790 --> 00:09:33,550
完成了，但是现在没有可用的框架，然后
done but now there's no free frames then

249
00:09:33,550 --> 00:09:35,170
我们必须从现有框架中找到一个存在的页面
we gotta find a page to exists from an

250
00:09:35,170 --> 00:09:37,209
，这就是事情变得复杂的时候，
existing frame and that's when things

251
00:09:37,209 --> 00:09:40,480
所以如果我们想要的页面
get complicated so if the page we want

252
00:09:40,480 --> 00:09:42,190
我们想要 evict 如果它从未
to we want to evict if it's never

253
00:09:42,190 --> 00:09:43,990
被事务修改过我的意思是它
modified by a transaction I mean it's

254
00:09:43,990 --> 00:09:46,180
不脏那么我们的工作很容易我们只需
not dirty then our job is easy we just

255
00:09:46,180 --> 00:09:48,790
将它写出来你知道我们只是删除
go write it out you know we just go drop

256
00:09:48,790 --> 00:09:51,610
它然后重新使用框架但是如果它是
it and then reuse the frame but if it is

257
00:09:51,610 --> 00:09:53,860
脏的那么我们现在必须被驱逐所以
dirty then we got to go now evicted so

258
00:09:53,860 --> 00:09:55,149
我们 必须写下磁盘并
we've got to write about the disk and

259
00:09:55,149 --> 00:09:57,760
刷新它，一旦完成 现在我们可以
flush it and once that's done now we can

260
00:09:57,760 --> 00:10:00,970
使用我们的框架了，所以你可以再次看到
use our frame so again you can see sort

261
00:10:00,970 --> 00:10:02,320
为什么这很复杂，因为你
of why this is complicated because you

262
00:10:02,320 --> 00:10:03,880
知道我们基本上在运行你知道
know we're running essentially you know

263
00:10:03,880 --> 00:10:06,279
LRU 或时钟或任何
LRU or clock or whatever exhibition

264
00:10:06,279 --> 00:10:07,720
你想用来决定如何
policy you want to use to decide how to

265
00:10:07,720 --> 00:10:09,760
驱逐框架的展览政策，我们必须平衡
evict frames and we got to balance that

266
00:10:09,760 --> 00:10:11,500
有了你知道哪些其他查询或
with you know what other queries or

267
00:10:11,500 --> 00:10:12,550
事务同时运行
transactions are running at the same

268
00:10:12,550 --> 00:10:15,250
哪些页面是脏的，这一切都
time what pages are dirty right this all

269
00:10:15,250 --> 00:10:18,279
变得非常复杂，所以现在一旦
gets very complicated so now once the

270
00:10:18,279 --> 00:10:20,560
页面在内存中，那么你知道我们可以
page is in memory then you know we can

271
00:10:20,560 --> 00:10:21,850
尝试变得聪明并尝试快速翻译
try to be smart and trying to translate

272
00:10:21,850 --> 00:10:25,420
磁盘上的任何内容 or 对
quickly any on disk or references to to

273
00:10:25,420 --> 00:10:27,550
我们页面的引用现在是一个 或 内存地址，
our page to now an or memory address so

274
00:10:27,550 --> 00:10:28,600
这样我们就不必
that maybe we don't have to go through

275
00:10:28,600 --> 00:10:30,310
this whole process of checking the

276
00:10:30,310 --> 00:10:31,510
每次都检查缓冲池管理器的整个过程，
buffer pool manager every single time

277
00:10:31,510 --> 00:10:33,310
但并不是每个系统中的每个现在都
but not every now in every system

278
00:10:33,310 --> 00:10:35,769
在高层次上这样做
actually does that so at a high level

279
00:10:35,769 --> 00:10:37,000
我刚刚谈到的看起来像这样，
what I just talked that looks like this

280
00:10:37,000 --> 00:10:39,430
所以为了我们的目的，这里
so for our purposes here say we're doing

281
00:10:39,430 --> 00:10:40,779
说我们正在做一个查询，它将查找一个索引
a query that's going to look up an index

282
00:10:40,779 --> 00:10:42,550
索引 它想要找到
index it wants to find a record the

283
00:10:42,550 --> 00:10:43,990
一个记录 页面内的记录 我们
records inside a page and we got a go

284
00:10:43,990 --> 00:10:46,630
可以从磁盘中获取它以便 简化 在我们的
fetch it from disk so to simplify our

285
00:10:46,630 --> 00:10:49,329
讨论中，我们会说索引不是
discussion we'll say the index is not

286
00:10:49,329 --> 00:10:52,000
不受缓冲池页面支持的，它
not backed by buffer pool pages it's

287
00:10:52,000 --> 00:10:54,220
实际上只是位于大多数
just actually sitting in memory in most

288
00:10:54,220 --> 00:10:55,990
系统中的内存中，这实际上是不对
systems that's actually not true right

289
00:10:55,990 --> 00:10:57,490
的，索引页面本身
the index pages themselves would be

290
00:10:57,490 --> 00:10:58,690
将由强大的管理器支持，因此我们
backed by the powerful manager so we

291
00:10:58,690 --> 00:10:59,829
必须去检查以查看 这些
have to go check to see whether those

292
00:10:59,829 --> 00:11:01,060
页面是否也在内存中
pages are in memory as well

293
00:11:01,060 --> 00:11:03,100
并完成整个过程，但我们
and do this entire process but we'll

294
00:11:03,100 --> 00:11:04,089
会保持简单并说它
just keep it simple and say it's

295
00:11:04,089 --> 00:11:06,430
完全是内存所以首先
entirely memory so the first things to

296
00:11:06,430 --> 00:11:08,050
要做的是您查找我们的索引以
be do is you look up on our index to

297
00:11:08,050 --> 00:11:08,570
找到我们
find our

298
00:11:08,570 --> 00:11:11,270
的索引以及索引会给我们什么 返回
and what the index will give us is back

299
00:11:11,270 --> 00:11:13,100
给我们作为付费 ID 和槽
give us back as a paid ID and a slot

300
00:11:13,100 --> 00:11:15,260
号，然后我们可以使用该页面 ID
number and then we can use that page ID

301
00:11:15,260 --> 00:11:17,060
来查看页表并
to look do a look of an a page table and

302
00:11:17,060 --> 00:11:19,430
找到我们正在寻找的页面的位置，
find the location of the page that we're

303
00:11:19,430 --> 00:11:21,200
所以假设我们' 重新
looking for so let's say that we're

304
00:11:21,200 --> 00:11:24,080
查找第 1 页，然后我们不会
looking for page 1 and then we would not

305
00:11:24,080 --> 00:11:25,910
在我们的页表中找到该条目，或者我们会
find the entry in our page table or we'd

306
00:11:25,910 --> 00:11:27,290
看到一个条目，上面写着哦，它不在
see an entry that says oh it's not in

307
00:11:27,290 --> 00:11:28,580
磁盘上的内存中，
memories on disk and here's where to go

308
00:11:28,580 --> 00:11:31,910
这是在磁盘上找到它的位置，以便将其
find it on disk so in order to bring it

309
00:11:31,910 --> 00:11:34,490
带入内存 我们必须去选择一个现有的
to memory we have to go pick a existing

310
00:11:34,490 --> 00:11:37,700
页面来攻击，所以我们必须锁定这个
page to vicked so we have to latch this

311
00:11:37,700 --> 00:11:39,200
页面 表以确保没有其他
page table to make sure that nobody else

312
00:11:39,200 --> 00:11:40,550
人试图在我们同时带来它
is trying to bring it in the same time

313
00:11:40,550 --> 00:11:42,410
然后我们必须拿起
we are and then we got to pick up one of

314
00:11:42,410 --> 00:11:44,090
这些页面中的一页来驱逐所以假设我们
these pages to evict so let's say we

315
00:11:44,090 --> 00:11:47,060
选择了第二页但第二页很脏所以
pick page two but page two is dirty so

316
00:11:47,060 --> 00:11:48,860
现在我们必须写出来 到磁盘并
now we gotta write it out to disk and

317
00:11:48,860 --> 00:11:51,680
刷新它，然后一旦完成，
flush it and then once that's done then

318
00:11:51,680 --> 00:11:53,900
我们现在可以使用空闲框架复制第一
we can now use the free frame to copy in

319
00:11:53,900 --> 00:11:56,840
页，此时我们更新
page one and at this point now we update

320
00:11:56,840 --> 00:11:58,370
我们的页表说嘿，如果您查找第一
our page table to say hey if you look in

321
00:11:58,370 --> 00:12:00,140
页，这是
for page one here's the frame in the

322
00:12:00,140 --> 00:12:01,880
之前管理中的框架 去找到它，然后
before manage to go find it and then

323
00:12:01,880 --> 00:12:03,020
一旦完成，我们就可以释放我们的
once that done we can release our

324
00:12:03,020 --> 00:12:05,720
闩锁，任何人都可以访问它，所以
latches and anybody can access it so

325
00:12:05,720 --> 00:12:06,950
这是对
this is a sort of a gross simplification

326
00:12:06,950 --> 00:12:10,130
这个驱逐过程如何正确进行的一种粗略的简化，
of how this eviction process works right

327
00:12:10,130 --> 00:12:11,780
因为如果有页面条目，我就不能很好地展示它
because I'm not showing it well if there

328
00:12:11,780 --> 00:12:13,190
两个然后你
was an entry for page two and then you

329
00:12:13,190 --> 00:12:15,410
现在可以在页表中更新它，
can update that now in the page table to

330
00:12:15,410 --> 00:12:17,300
说它不在内存中，现在它在
say it's not on not memory now it's on

331
00:12:17,300 --> 00:12:20,510
磁盘上，但你知道在高层次上
disk but you know at a high level every

332
00:12:20,510 --> 00:12:21,620
，你知道
single database system that's you know

333
00:12:21,620 --> 00:12:23,930
使用缓冲池的每个数据库系统都在做
using a buffer pool is doing something

334
00:12:23,930 --> 00:12:27,380
类似的事情，所以这是什么问题 好吧，
similar so what's the problem this well

335
00:12:27,380 --> 00:12:30,860
如果现在我们得到我们回到我们的考试
if now we get we go back to our example

336
00:12:30,860 --> 00:12:33,050
我说让我们给我们的数据库系统
say let's give our database system a lot

337
00:12:33,050 --> 00:12:35,270
很多内存 现在一切都会
of memory and now everything's gonna fit

338
00:12:35,270 --> 00:12:37,400
很好地适应内存 我们仍在经历
memory well we still going through this

339
00:12:37,400 --> 00:12:39,020
整个过程 去查找页
entire process to go look up the page

340
00:12:39,020 --> 00:12:40,430
表 尝试每次
table on try to do a translation of like

341
00:12:40,430 --> 00:12:42,080
将记录 ID 翻译成其内存位置
the record ID to its memory location

342
00:12:42,080 --> 00:12:44,590
我们访问一个元组，
every single time we access a tuple and

343
00:12:44,590 --> 00:12:46,730
我们必须采取闩锁并保护
we have to take latches and protect

344
00:12:46,730 --> 00:12:48,650
事物，因为我们不希望我们
things because we don't want us to be

345
00:12:48,650 --> 00:12:51,170
在页面墙中被访问，然后有
accessed in the page wall and then have

346
00:12:51,170 --> 00:12:52,340
另一个威胁试图驱逐该页面，
another threat try to evict that page

347
00:12:52,340 --> 00:12:54,530
但就像我说的，如果我们有足够的
but like I said if if we have enough

348
00:12:54,530 --> 00:12:56,090
内存，那么我们' 永远不会真正
memory then we're never gonna actually

349
00:12:56,090 --> 00:12:58,370
将任何内容写出磁盘，因此固定
write anything out the disk so pinning

350
00:12:58,370 --> 00:13:00,020
这些页面并锁定它们
these pages are and latching them is

351
00:13:00,020 --> 00:13:01,520
实际上根本没有必要，因此只是
actually not necessary at all so just

352
00:13:01,520 --> 00:13:04,160
浪费了一些工作，然后运行
sort of wasted work and then running

353
00:13:04,160 --> 00:13:05,540
该驱逐策略以更新
that an eviction policy to updating all

354
00:13:05,540 --> 00:13:07,040
有关如何访问页面的所有内部指标
internal metrics about how pages are

355
00:13:07,040 --> 00:13:08,480
，这也是一个 也浪费了
being accessed that's also a waste of

356
00:13:08,480 --> 00:13:10,370
工作，因为再没有
work too because again nothing's ever

357
00:13:10,370 --> 00:13:12,890
什么会成为受害者，所以这种
going to be a victim so this sort of

358
00:13:12,890 --> 00:13:14,540
回答我一开始的稻草人问题，
answers my strawman question at the

359
00:13:14,540 --> 00:13:16,970
我们不能只是给
beginning that well can't we just give

360
00:13:16,970 --> 00:13:20,090
它一些大量的记忆，你知道
it some a lot of memory and you know

361
00:13:20,090 --> 00:13:21,890
传统 你消耗了大量
traditionally dissipated in a lot of

362
00:13:21,890 --> 00:13:22,400
内存，这
memory and what

363
00:13:22,400 --> 00:13:24,080
足以让你知道
that'd be enough for you know getting

364
00:13:24,080 --> 00:13:25,580
获得与我们获得内存系统相同的性能
the same performance as we would get an

365
00:13:25,580 --> 00:13:27,800
，答案是否定的，
in-memory system and the answer is no

366
00:13:27,800 --> 00:13:29,240
因为你正在做这些你知道的所有应用程序
because you're doing this all apps you

367
00:13:29,240 --> 00:13:30,380
都在做这些额外的工作
know doing these extra work just go

368
00:13:30,380 --> 00:13:34,910
现在去访问单个页面，这
access the single page now this is gonna

369
00:13:34,910 --> 00:13:36,589
也会导致其他问题，
have cascading to other issues as well

370
00:13:36,589 --> 00:13:40,070
比如在并发仪式中，所以
so like in concurrent rituals so the the

371
00:13:40,070 --> 00:13:41,260
传统的基于磁盘的系统
traditional disk based systems

372
00:13:41,260 --> 00:13:43,910
破坏了系统的设计
destroying the system's their designs

373
00:13:43,910 --> 00:13:45,470
，使得事务在任何时候
such that at any time a transaction

374
00:13:45,470 --> 00:13:47,089
都可以触及内存，而不是在磁盘中
could touch memory and it's not in disk

375
00:13:47,089 --> 00:13:48,680
，因此 该事务
and therefore that transaction has get

376
00:13:48,680 --> 00:13:51,350
在磁盘管理器
stalled while the the disk manager go

377
00:13:51,350 --> 00:13:54,230
获取它时已停止，因此当它停止时，其他
fetches it and so while it stalled other

378
00:13:54,230 --> 00:13:56,210
事务将能够在
transactions are gonna be able to run on

379
00:13:56,210 --> 00:13:58,630
其他线程或同一线程上运行，以便
other threads or the same thread so that

380
00:13:58,630 --> 00:14:01,100
该系统可以继续前进，
this system can keep making forward

381
00:14:01,100 --> 00:14:02,600
即使您知道一个
progress even though you know one

382
00:14:02,600 --> 00:14:03,680
事务已停止 因为它必须
transaction got stalled because it has

383
00:14:03,680 --> 00:14:05,300
从磁盘中获取一些东西，
to get something from disk all right we

384
00:14:05,300 --> 00:14:07,430
否则我们会这样做，否则如果我们一次只能执行
do this otherwise if we can only execute

385
00:14:07,430 --> 00:14:08,900
一个事务并且我们在
one transaction at a time and we stall

386
00:14:08,900 --> 00:14:10,070
任何时候都需要从
anytime we have to get from something

387
00:14:10,070 --> 00:14:11,990
我的磁盘中获取东西时就会停止 那么系统会看起来
I'm disk then the system's gonna look

388
00:14:11,990 --> 00:14:13,370
没有响应，因为它会一直
unresponsive because it's gonna keep

389
00:14:13,370 --> 00:14:15,260
停滞不前，你知道每次
stalling and you know every single time

390
00:14:15,260 --> 00:14:18,200
你知道我们有一个页面未命中，所以因为
you know we have a page miss so because

391
00:14:18,200 --> 00:14:19,400
现在我们允许其他事务
now we're allowing other transactions

392
00:14:19,400 --> 00:14:21,350
同时运行，我们必须
are run at the same time we have to use

393
00:14:21,350 --> 00:14:22,700
使用可能正在设置的并发协议
a concurrent protocol that could be

394
00:14:22,700 --> 00:14:25,610
锁定我们自己的记录或
setting locks in our own records or

395
00:14:25,610 --> 00:14:27,620
数据库中的对象，以
objects in the database to make sure we

396
00:14:27,620 --> 00:14:29,150
确保我们为事务提供所需的资产保证
provide the asset guarantees that you

397
00:14:29,150 --> 00:14:31,790
want for transactions right because if

398
00:14:31,790 --> 00:14:35,950
now a transaction modifies a page and

399
00:14:35,950 --> 00:14:39,050
then that page gets written on the disk

400
00:14:39,050 --> 00:14:40,880
before that transaction commits can

401
00:14:40,880 --> 00:14:42,800
事务
commit because some other transaction

402
00:14:42,800 --> 00:14:44,900
驱逐那个页面，然后我们必须
evict that page then we got to make sure

403
00:14:44,900 --> 00:14:46,010
确保我们跟踪所有的部分
that we keep track all the section

404
00:14:46,010 --> 00:14:47,690
信息，如果我们崩溃并
information and that if we crash and

405
00:14:47,690 --> 00:14:49,700
回来，未提交的
come back that the uncommitted

406
00:14:49,700 --> 00:14:53,540
事务更改不会
transactions changes don't persist so in

407
00:14:53,540 --> 00:14:55,940
在磁盘或任何系统中持续存在，如果它使用
a disk or any system if it's using

408
00:14:55,940 --> 00:14:57,170
锁定，它将保持 这个
locking it's going to maintain this

409
00:14:57,170 --> 00:14:58,790
锁定信息在单独的数据
locking information in separate data

410
00:14:58,790 --> 00:15:00,740
结构中，它是
structures right it's an in-memory hash

411
00:15:00,740 --> 00:15:03,980
锁定管理器中的一个内存哈希表，以
table in the lock manager to avoid those

412
00:15:03,980 --> 00:15:05,390
避免锁定信息被交换
the lock information getting swapped out

413
00:15:05,390 --> 00:15:07,220
以这种方式输出到磁盘我不必
to disks that way I don't have to

414
00:15:07,220 --> 00:15:08,870
确定我是否甚至可以
determine whether I can even hold the

415
00:15:08,870 --> 00:15:11,330
在元组上保持锁定来获取磁盘并
lock on a tuple to go got the disk and

416
00:15:11,330 --> 00:15:12,709
弄清楚你知道去获取锁定
figure out you know go fetch that lock

417
00:15:12,709 --> 00:15:14,480
信息所有东西总是
information everything is always going

418
00:15:14,480 --> 00:15:18,110
会在内存中其他问题
to be in memory other problems would

419
00:15:18,110 --> 00:15:20,029
会有 内存系统具有日志
have an in memory system is with logging

420
00:15:20,029 --> 00:15:23,779
恢复功能，因此大多数
recovery so most database systems that

421
00:15:23,779 --> 00:15:25,100
使用缓冲区文件管理器的数据库系统
use a buffer file manager are going to

422
00:15:25,100 --> 00:15:26,779
将使用不强制窃取但足球
be using the steal no force but football

423
00:15:26,779 --> 00:15:30,740
管理器策略，这基本上
manager policies and this just basically

424
00:15:30,740 --> 00:15:32,600
意味着
means that all the transactions that a

425
00:15:32,600 --> 00:15:34,400
事务的所有事务都与
transaction mates all the modifications

426
00:15:34,400 --> 00:15:36,000
事务所做的所有修改相匹配
that a transaction makes

427
00:15:36,000 --> 00:15:37,379
必须添加到前面的日志中
have to get added to a right ahead log

428
00:15:37,379 --> 00:15:39,120
，并且这些条目必须
and that those entries have to get

429
00:15:39,120 --> 00:15:40,980
在允许提交事务之前刷新到磁盘
flushed to disk before transactions

430
00:15:40,980 --> 00:15:43,560
，然后
allowed to commit and then any updates

431
00:15:43,560 --> 00:15:46,139
对脏页的任何更新
to a dirty page the law of records

432
00:15:46,139 --> 00:15:47,129
与这些更新相对应的记录定律
correspond to those updates has

433
00:15:47,129 --> 00:15:48,480
在脏页可以之前重写了磁盘
rewritten a disk before the dirty page

434
00:15:48,480 --> 00:15:50,759
写了一个磁盘这些
can be written a disk these are things

435
00:15:50,759 --> 00:15:52,019
是我们在上学期的介绍
that we covered in the introduction

436
00:15:52,019 --> 00:15:55,319
课上讲过的所以现在内存
class last semester so now an in-memory

437
00:15:55,319 --> 00:15:57,899
系统我们不再有脏页
system we don't have dirty pages anymore

438
00:15:57,899 --> 00:16:00,389
所以也许我们不需要你 使用完全相同的
so maybe we don't need to use the exact

439
00:16:00,389 --> 00:16:03,420
协议，然后也许我们的日志
same protocol and then maybe our log

440
00:16:03,420 --> 00:16:04,709
条目不需要存储与
entries don't need to store the exact

441
00:16:04,709 --> 00:16:06,180
我们在面向 dis 的系统中完全相同的信息，
same information as we had in dis

442
00:16:06,180 --> 00:16:08,399
如果没有脏页
oriented system right if no dirty pages

443
00:16:08,399 --> 00:16:10,769
必须摆脱磁盘，那么
have to ever get rid of disk then it

444
00:16:10,769 --> 00:16:12,509
存储可能没有意义
maybe doesn't make sense to store the

445
00:16:12,509 --> 00:16:15,509
之前的图像或重做信息
before image or the redo information I'm

446
00:16:15,509 --> 00:16:19,199
对不起交易修改的撤消信息，
sorry the undo information of the

447
00:16:19,199 --> 00:16:21,120
因为该
transactions modification because that

448
00:16:21,120 --> 00:16:22,500
页面永远不会脏页面永远不会
page will never the dirty page never

449
00:16:22,500 --> 00:16:25,529
被写入所以
gets written so there's a lot extra

450
00:16:25,529 --> 00:16:27,629
我们必须在暴政系统中做很多额外的事情，这些
stuff we had to do in a tyranny system

451
00:16:27,629 --> 00:16:29,519
事情可能没有意义 不再
that maybe doesn't make sense anymore in

452
00:16:29,519 --> 00:16:32,339
在金刚砂系统中，例如
an emery system like keeping track of

453
00:16:32,339 --> 00:16:35,759
再次跟踪日志序列号再次
the logs sequence numbers again again

454
00:16:35,759 --> 00:16:38,100
维护撤消信息，
maintaining the the undo information

455
00:16:38,100 --> 00:16:40,379
因为再次脏页不会
because again dirty pages don't get rid

456
00:16:40,379 --> 00:16:41,370
删除磁盘，因为一切
of discs because everything fits in

457
00:16:41,370 --> 00:16:44,430
都适合内存，以便让其他人
memory all right so to get others a

458
00:16:44,430 --> 00:16:45,509
更好地了解这种
better understanding of what this

459
00:16:45,509 --> 00:16:47,519
开销是什么 实际上会有
overhead is actually gonna be there's a

460
00:16:47,519 --> 00:16:51,509
一项在麻省理工学院完成的研究，实际上是在
study that was done at MIT it's actually

461
00:16:51,509 --> 00:16:53,819
2008 年 10 多年前，他们
2008 over 10 years ago now where they

462
00:16:53,819 --> 00:16:56,120
采用了一个旧的电视数据库系统，并进行了
took a old TV database system and

463
00:16:56,120 --> 00:16:58,709
检测，以便他们可以
they've instrumented so that they can

464
00:16:58,709 --> 00:17:00,930
测量我的数字 当您运行 TPCC 时，
measure the number instructions that the

465
00:17:00,930 --> 00:17:02,670
数据系统
data system was spending in different

466
00:17:02,670 --> 00:17:04,980
在当前查询执行的不同部分花费的
parts of the current query execution

467
00:17:04,980 --> 00:17:07,559
指令，这里的想法
while you're running TPCC and the idea

468
00:17:07,559 --> 00:17:09,720
是将系统分解为
here is to break down the system into

469
00:17:09,720 --> 00:17:11,520
不同的组件，就像我所说
different components as I talked about

470
00:17:11,520 --> 00:17:13,349
的那样，再次测量
and just measure again how much time

471
00:17:13,349 --> 00:17:15,869
我们花费了多少时间 他们每个人都可以，
we're spending in each of them it's okay

472
00:17:15,869 --> 00:17:17,669
这是针对所有内容都
this is for a database where everything

473
00:17:17,669 --> 00:17:19,740
适合内存的数据库，没有任何理由
fits in memory there's no any no reason

474
00:17:19,740 --> 00:17:20,939
在内存中写入任何内容都不会刷新到
writes in memory nothing gets flushed to

475
00:17:20,939 --> 00:17:22,140
磁盘，并且前面的日志这就是
disk and that right ahead log this is

476
00:17:22,140 --> 00:17:23,760
just what is the cost of going access

477
00:17:23,760 --> 00:17:25,740
使用磁盘访问内存中的数据的成本
data that's in memory using the disk

478
00:17:25,740 --> 00:17:28,140
面向架构，所以第一个
oriented architecture so the first

479
00:17:28,140 --> 00:17:30,480
开销是在可感知的管理器
overhead is in the palpable manager this

480
00:17:30,480 --> 00:17:31,679
中，大约 34% 的 CPU
is about 34 percent of the CPU

481
00:17:31,679 --> 00:17:33,659
指令用于更新或
instructions are spent doing updates or

482
00:17:33,659 --> 00:17:34,950
查找页表进行
lookups into the page table doing

483
00:17:34,950 --> 00:17:37,770
更新 您跟踪
updates you keep track of all the

484
00:17:37,770 --> 00:17:39,570
所有用于驱逐策略的元数据
metadata you have for the eviction

485
00:17:39,570 --> 00:17:43,230
14% 的时间 花在
policy 14% of the time spent doing

486
00:17:43,230 --> 00:17:44,970
锁存上的时间可能是用于
latching by this could be for the

487
00:17:44,970 --> 00:17:46,380
内部数据结构，例如
internal data structures such as the

488
00:17:46,380 --> 00:17:49,049
带有锁管理器的页表，
page table with the lock manager ran

489
00:17:49,049 --> 00:17:50,040
只要你知道
anytime that's you know

490
00:17:50,040 --> 00:17:51,510
我们需要的低级构造函数
the low-level constructor we need

491
00:17:51,510 --> 00:17:54,990
保护 16% 的指令
protect 16 percent of instructions were

492
00:17:54,990 --> 00:17:57,990
用在锁定上，所以这个特定的
spent on locking so this particular

493
00:17:57,990 --> 00:18:00,600
系统被称为肯定并使用
system it was called sure and uses

494
00:18:00,600 --> 00:18:02,070
两阶段锁定，所以这是在
two-phase locking so this is the

495
00:18:02,070 --> 00:18:03,600
overhead of updating the lock

496
00:18:03,600 --> 00:18:04,980
事务运行时更新锁定信息的开销
information for transactions while they

497
00:18:04,980 --> 00:18:08,700
12% 的
run for 12 percent of the instructions

498
00:18:08,700 --> 00:18:10,590
指令用在日志管理器中 所以这
were spent in the log manager so this is

499
00:18:10,590 --> 00:18:11,760
不是耗尽磁盘
not the cost of running out the disk

500
00:18:11,760 --> 00:18:13,350
的成本，这是准备
this is the cost of preparing the law of

501
00:18:13,350 --> 00:18:15,560
我们将要写出的记录法则的成本，
records that we're going to write out

502
00:18:15,560 --> 00:18:18,660
然后 16% 的时间用于
then 16 percent of the time is spent

503
00:18:18,660 --> 00:18:22,290
比较
doing a comparison of keys doing

504
00:18:22,290 --> 00:18:24,330
在 B+ 树中进行遍历的键，但是这个
traversals in the B+ tree but this is

505
00:18:24,330 --> 00:18:25,890
这是不可避免的，这只是说
sort of unavoidable this is just saying

506
00:18:25,890 --> 00:18:27,090
你知道如果我试图
you know if I'm trying to find the

507
00:18:27,090 --> 00:18:28,230
通过 D 加树找到我想要的记录，
record that I want through the D plus

508
00:18:28,230 --> 00:18:30,260
这是比较密钥的成本，
tree this is the cost of comparing keys

509
00:18:30,260 --> 00:18:32,610
所以现在这将给我们留下
so this is now going to leave us with a

510
00:18:32,610 --> 00:18:35,160
微不足道的 7% 的 CP 指令我们
paltry 7% of the CP instructions we're

511
00:18:35,160 --> 00:18:37,290
实际上正在做他们所谓的
actually doing what what they would call

512
00:18:37,290 --> 00:18:40,860
实际工作，例如执行
real work like executing the the logic

513
00:18:40,860 --> 00:18:43,730
获取数据的事务逻辑
for transactions getting back the data

514
00:18:43,730 --> 00:18:46,410
，然后执行您知道的执行
and then performing you know perform the

515
00:18:46,410 --> 00:18:47,550
提交操作之类的事情，
commit operations and things like that

516
00:18:47,550 --> 00:18:49,710
所以这又是 向您展示
so this is again this is showing you

517
00:18:49,710 --> 00:18:50,970
，如果您使用磁盘学习系统
that if you take a disk learning system

518
00:18:50,970 --> 00:18:52,860
并为其提供所需的所有内存，
and you give it all the memory that it

519
00:18:52,860 --> 00:18:54,270
以便所有内容都
wants so that everything everything fits

520
00:18:54,270 --> 00:18:56,040
适合内存，您将无法获得
in memory you're not going to get

521
00:18:56,040 --> 00:18:57,540
最佳性能，因为
potentially the best performance because

522
00:18:57,540 --> 00:18:59,640
您仍然知道所有内容
everything could still you know you

523
00:18:59,640 --> 00:19:01,320
仍然会受到惩罚 对于所有
still have pain the penalty for all this

524
00:19:01,320 --> 00:19:03,840
假设
internal architecture that assumes the

525
00:19:03,840 --> 00:19:05,190
数据不在磁盘上的内部架构，并且存在
data is not on disk and there's all the

526
00:19:05,190 --> 00:19:07,020
针对该假设的所有保护机制
protection mechanisms for that

527
00:19:07,020 --> 00:19:08,760
，而实际上并不是
assumption and that are actually not

528
00:19:08,760 --> 00:19:11,330
必需的，
necessary

529
00:19:11,500 --> 00:19:15,429
因此今天早些时候我平板电脑上的电池
so my battery on my tablet shut down

530
00:19:15,429 --> 00:19:17,559
在我在外面录制时关闭了
earlier today when I was recording this

531
00:19:17,559 --> 00:19:20,710
它变得太冷了，一切
outside it got too cold and everything

532
00:19:20,710 --> 00:19:23,110
只是整个关闭的事情我
just the whole thing to shut down I was

533
00:19:23,110 --> 00:19:25,480
就像华氏 20 度，这就像
like 20 degrees Fahrenheit which is like

534
00:19:25,480 --> 00:19:28,929
负 7 摄氏度左右，
negative 7 or so degrees Celsius so that

535
00:19:28,929 --> 00:19:31,149
所以这有点奇怪，所以回到这个
was kind of weird so back inside in this

536
00:19:31,149 --> 00:19:35,950
奇怪的德国黄金剥夺室里
weird German gold deprivation chamber

537
00:19:35,950 --> 00:19:38,440
，他们又来了，
thing that they have here again and

538
00:19:38,440 --> 00:19:39,789
后来又进来了 并
since to come in here and think about

539
00:19:39,789 --> 00:19:41,799
深入思考数据库并
deep thoughts about databases and

540
00:19:41,799 --> 00:19:43,029
以某种方式成为像德国人一样更好的程序员
somehow become a better programmer like

541
00:19:43,029 --> 00:19:45,070
我不知道这是否
a German I don't know if that's gonna

542
00:19:45,070 --> 00:19:46,990
行得通所以让我们继续w 在
work so let's just continue with the

543
00:19:46,990 --> 00:19:51,009
讲座中，我们刚才停下来的地方
lecture so where we left off just now

544
00:19:51,009 --> 00:19:53,080
是我们在谈论
was we were talking about how the

545
00:19:53,080 --> 00:19:56,769
Discordian 系统的情况，因为
Discordian systems have because they

546
00:19:56,769 --> 00:19:58,480
他们假设
make that assumption that the

547
00:19:58,480 --> 00:19:59,799
首相教育戴维斯
prime-minister education the davis could

548
00:19:59,799 --> 00:20:01,000
可以在磁盘上有所有这些
be on disk there's all this architecture

549
00:20:01,000 --> 00:20:05,620
架构，以便您随时知道 当
set up so that at any time you know when

550
00:20:05,620 --> 00:20:07,629
你读到一些东西时，你必须去
you read something you you have to go

551
00:20:07,629 --> 00:20:08,799
检查它是否在磁盘上，如果
check to see whether it's on disk and if

552
00:20:08,799 --> 00:20:10,509
不是，你可以安装那个线程并做
not you can install that thread and do

553
00:20:10,509 --> 00:20:12,610
其他事情，所以现在我们要
other stuff so now we're gonna switch

554
00:20:12,610 --> 00:20:13,809
切换并讨论内存
over and talk about an in-memory

555
00:20:13,809 --> 00:20:16,779
数据库系统，所以这是一个
database system so this is one where

556
00:20:16,779 --> 00:20:19,929
系统将
that where the system's gonna zoom that

557
00:20:19,929 --> 00:20:21,460
放大主要搜索位置
the primary search location is going to

558
00:20:21,460 --> 00:20:23,980
将高于所有数据库的位置
be above all the data base is always

559
00:20:23,980 --> 00:20:25,779
将始终永久保存在内存中，因此
going to be permanently in memory so

560
00:20:25,779 --> 00:20:27,340
这意味着任何时候
that means that any single time a

561
00:20:27,340 --> 00:20:29,769
事务或查询读取
transaction or a query goes and reads a

562
00:20:29,769 --> 00:20:31,929
元组时都可以假设 东西
tuple it can assume that that thing is

563
00:20:31,929 --> 00:20:33,730
将在内存中，因此它
going to be in memory and therefore it

564
00:20:33,730 --> 00:20:35,980
不必遍历所有页
doesn't have to go through all that page

565
00:20:35,980 --> 00:20:38,289
表和水牛并检查
table and in the buffalo and check

566
00:20:38,289 --> 00:20:39,669
任何东西都会去读取它
anything goes goes and reads whatever it

567
00:20:39,669 --> 00:20:42,929
想要的任何东西或写入它想要的任何东西所以
wants or writes whatever it wants so

568
00:20:42,929 --> 00:20:45,250
它不是说
it's not to say that everything we're

569
00:20:45,250 --> 00:20:46,840
本学期我们要讨论的所有内容都
gonna talk about this semester is going

570
00:20:46,840 --> 00:20:48,429
将仅针对内存数据库，
to be only targeting in-memory databases

571
00:20:48,429 --> 00:20:50,200
但我们将看到我们将如何做出某些
but we'll see how there's be certain

572
00:20:50,200 --> 00:20:51,639
设计决策，
design decisions that we're gonna make

573
00:20:51,639 --> 00:20:54,129
如果我们做出这个假设，这将使我们的生活更轻松
that'll make our life easier if we make

574
00:20:54,129 --> 00:20:57,730
this assumption so this idea of an

575
00:20:57,730 --> 00:20:59,950
内存数据库的这种想法并不
in-memory database is not new

576
00:20:59,950 --> 00:21:02,379
新鲜，第一个提议的系统可以
the first proposed systems go back and

577
00:21:02,379 --> 00:21:05,799
追溯到 1980 年代，但
into the 1980s but they're not really

578
00:21:05,799 --> 00:21:08,740
现在也许在过去 10 年里它们并不是你真正知道的可行选择，
you know viable option now maybe in the

579
00:21:08,740 --> 00:21:10,870
因为它已经到了
last 10 years because it's gotten to the

580
00:21:10,870 --> 00:21:11,980
价格和容量都很贵的地步
point where dear on prices and

581
00:21:11,980 --> 00:21:15,159
是这样的，你知道我们可以
capacities are such that you know we can

582
00:21:15,159 --> 00:21:18,299
在内存中存储非常大的数据库，
store really large databases in memory

583
00:21:18,299 --> 00:21:21,220
所以你知道
so the you know that there was initial

584
00:21:21,220 --> 00:21:22,899
在 1980 年代提出了最初的想法，我们将在进行时讨论
ideas proposed in 1980s we'll talk a

585
00:21:22,899 --> 00:21:24,390
一下，
little bit about that as we go

586
00:21:24,390 --> 00:21:27,070
但第一个商业美国
but the first commercial America

587
00:21:27,070 --> 00:21:28,420
数据库确实没有出现
databases diddly didn't come out until

588
00:21:28,420 --> 00:21:31,540
像 1990 年代，最著名的三个
like the 1990s the most famous three are

589
00:21:31,540 --> 00:21:34,090
可能是 10 倍，这实际上
probably times ten which is really

590
00:21:34,090 --> 00:21:36,160
最初称为小基地，然后
originally called small base and then

591
00:21:36,160 --> 00:21:38,650
它们从 HP 分叉出来，变成了
they forked off from HP and became times

592
00:21:38,650 --> 00:21:42,810
10 倍，然后甲骨文购买了它们，
10 and then Oracle bought them probably

593
00:21:42,810 --> 00:21:46,300
大概在 2006 年左右，数据闪电战
about 2006 or so data blitz was the

594
00:21:46,300 --> 00:21:49,150
是 B 级系统 1990 年代的 ell Labs 1880
system at a Bell Labs 1880 in the 1990s

595
00:21:49,150 --> 00:21:52,360
它被紧急称为 dolly 它被出售
it was urgent called dolly it was sold

596
00:21:52,360 --> 00:21:53,560
用于像电信交换机之类的东西
for like telecom switches and things

597
00:21:53,560 --> 00:21:55,300
我认为它今天仍然
like that I don't think it's still

598
00:21:55,300 --> 00:21:56,860
存在，或者如果它是
around today or if it is it's sort of

599
00:21:56,860 --> 00:21:58,750
它显然处于传统模式并且
it's obviously in legacy mode and the

600
00:21:58,750 --> 00:22:01,480
Alta 基地是一个 韩国 这
Alta base is that a South Korea it's one

601
00:22:01,480 --> 00:22:03,040
是这些早期的初学者之一 他
of these early beginners he's early game

602
00:22:03,040 --> 00:22:04,450
每天都在做生意的早期游戏 这实际上
every day to business which actually is

603
00:22:04,450 --> 00:22:05,890
今天仍然存在而且实际上
still around today and actually within

604
00:22:05,890 --> 00:22:07,270
在过去的两三年内他们是
the last two or three years they're open

605
00:22:07,270 --> 00:22:09,130
开源的 它是你可以去 github 中检查它
sourced it is you can go and check that

606
00:22:09,130 --> 00:22:13,750
所以即使和
out of github so even though and now

607
00:22:13,750 --> 00:22:15,220
既然 Davis 将完全
that the Davis is gonna be entirely

608
00:22:15,220 --> 00:22:18,370
命名为内存，我们仍然会将
named memory we're still gonna organize

609
00:22:18,370 --> 00:22:22,150
数据组织成块，并且页面不会
data into blocks and pages does not slot

610
00:22:22,150 --> 00:22:23,890
在页面上插入，因为我们不知道
at pages because we don't you know what

611
00:22:23,890 --> 00:22:25,300
页面本身内部的间接性是什么意思
the word about indirection within a page

612
00:22:25,300 --> 00:22:29,050
，因此系统架构
itself and so the system architecture

613
00:22:29,050 --> 00:22:30,250
会稍微有点 现在不同了，因为
would be slightly different now because

614
00:22:30,250 --> 00:22:32,470
现在我们
now instead of doing these record IDs we

615
00:22:32,470 --> 00:22:36,070
可以处理直接内存
can deal with direct memory pointers the

616
00:22:36,070 --> 00:22:37,600
指针而不是处理这些记录 ID，如果我们与基于磁盘的系统略有不同，我们将处理固定长度
way we're gonna handle fixed length

617
00:22:37,600 --> 00:22:39,040
与可变长度数据
versus variable length data if we

618
00:22:39,040 --> 00:22:41,080
slightly different than a than a disk

619
00:22:41,080 --> 00:22:42,550
的方式 bec 再次使用我们没有
based system because again we don't have

620
00:22:42,550 --> 00:22:45,100
带槽的页面，虽然没有多少
slotted pages and although not many

621
00:22:45,100 --> 00:22:48,970
系统有这个，因为有些系统有这样
systems have this because some do there

622
00:22:48,970 --> 00:22:50,350
的问题，因为现在
is a concern that now because

623
00:22:50,350 --> 00:22:52,810
所有的东西都在内存中，任何线程都可以
everything's in memory any thread can

624
00:22:52,810 --> 00:22:55,180
读取，或者你可以在进程的地址空间中写入任何内容，
read or so you can write anything in the

625
00:22:55,180 --> 00:22:57,730
以
address space of the process so to make

626
00:22:57,730 --> 00:23:00,300
确保 我们没有让您知道
sure that we don't have you know

627
00:23:00,300 --> 00:23:02,920
容易出错的软件协作我们的
error-prone software collaborating our

628
00:23:02,920 --> 00:23:05,800
数据并造成许可损坏我们可以
data and causing permit damage we can

629
00:23:05,800 --> 00:23:07,300
在这些块的整个系统中使用校验和
use check sums throughout the system of

630
00:23:07,300 --> 00:23:09,670
来跟踪您了解
these blocks to keep track of you know

631
00:23:09,670 --> 00:23:13,750
页面的状态并且您知道检测
the status of a page and you know detect

632
00:23:13,750 --> 00:23:15,820
这些问题的错误 现在
errors with these ever problems now

633
00:23:15,820 --> 00:23:17,500
在幕后，
underneath the covers the operating

634
00:23:17,500 --> 00:23:19,540
操作系统和硬件也
system and the hardware is also going to

635
00:23:19,540 --> 00:23:22,150
将把内存组织成页面，
be organizing memory into pages as well

636
00:23:22,150 --> 00:23:23,800
这
that's not really going to be our

637
00:23:23,800 --> 00:23:25,990
在本学期的大部分时间里并不是我们真正关心的问题，
concern for most most of this semester

638
00:23:25,990 --> 00:23:28,000
我们稍后会讨论，还有
we'll talk a little bit later on and a

639
00:23:28,000 --> 00:23:29,560
一些讲座，因为 我们需要
few more lectures because we need to

640
00:23:29,560 --> 00:23:30,790
了解它实际上是如何
understand how it's actually going to

641
00:23:30,790 --> 00:23:32,260
布局数据的，这样当我们开始布局数据时
layout data so that when we start laying

642
00:23:32,260 --> 00:23:34,990
，我们可以
that data we can align to what the

643
00:23:34,990 --> 00:23:35,590
underlying

644
00:23:35,590 --> 00:23:37,780
与操作系统中的底层页面表示或现在的
page representation in the OS is or the

645
00:23:37,780 --> 00:23:38,090
硬件
hardware

646
00:23:38,090 --> 00:23:42,320
是罗伯茨的对齐 我们可以忽略它，所以
is Roberts's now we can ignore that so

647
00:23:42,320 --> 00:23:43,460
让我们再次回到我们
again let's return back to our

648
00:23:43,460 --> 00:23:44,690
的高级示例，在这里我们
high-level example here where we were

649
00:23:44,690 --> 00:23:47,240
有一个查询，其中一个访问元组
had a query one of that accesses a tuple

650
00:23:47,240 --> 00:23:49,159
让人们通过一个索引来查找
lets people go through an index to look

651
00:23:49,159 --> 00:23:52,130
它，所以现在在我们的索引中而不是
it up so now in our index instead of

652
00:23:52,130 --> 00:23:54,470
返回一个记录 ID 或
returning back a record ID or page page

653
00:23:54,470 --> 00:23:56,570
偏移量中的页页 ID 我们现在将在偏移量中获得
ID in an offset we're now gonna get a

654
00:23:56,570 --> 00:23:59,840
块 ID，该块 ID
block ID in an offset and this block ID

655
00:23:59,840 --> 00:24:02,120
可以
could either be the direct memory

656
00:24:02,120 --> 00:24:04,880
是固定长度块的直接内存地址，也
address of a fixed length block or there

657
00:24:04,880 --> 00:24:06,169
可以有其他机制
could be an additional mechanism that

658
00:24:06,169 --> 00:24:08,330
允许我们查找和 看到您已
allows us to look it up and see you've

659
00:24:08,330 --> 00:24:10,490
将该块 ID 转换为内存
convert that block ID to a memory

660
00:24:10,490 --> 00:24:14,659
位置，因此主要搜索位置
location so the primary search locations

661
00:24:14,659 --> 00:24:16,039
数据库再次在内存中或每个
database again is in memory or every

662
00:24:16,039 --> 00:24:18,200
元组都在内存中，但我们将通过记录
tuple is in memory but we're gonna

663
00:24:18,200 --> 00:24:20,240
以这些固定长度组织它们
organize them in these fixed length

664
00:24:20,240 --> 00:24:22,610
，因此对此
through records and so for this it

665
00:24:22,610 --> 00:24:23,600
无关紧要 我们假设一个
doesn't matter what we're assuming a

666
00:24:23,600 --> 00:24:24,890
烤肉或一个列存储，但基本
roast or a column store but the basic

667
00:24:24,890 --> 00:24:26,720
思想是相同的，那就是我们将
idea is the same and that is we're gonna

668
00:24:26,720 --> 00:24:30,520
有一组块或恢复
have a set of blocks or restore the

669
00:24:30,520 --> 00:24:33,409
元组的固定长度数据，所以
fixed length data for a tuple so

670
00:24:33,409 --> 00:24:37,070
任何像 int 日期浮动实数这样的
anything like an int dates floats reals

671
00:24:37,070 --> 00:24:38,750
东西 所有可以存储的
things like that all that can be stored

672
00:24:38,750 --> 00:24:42,169
都是固定长度 gth 和固定长度块
is fixed length and fixed length block

673
00:24:42,169 --> 00:24:44,240
，这意味着
and that means that the size of every

674
00:24:44,240 --> 00:24:47,539
这里每个元组的大小都将相同，
tuple here is going to be the same and

675
00:24:47,539 --> 00:24:49,820
所以现在说如果我们有块 ID
so that says now if we have as block ID

676
00:24:49,820 --> 00:24:51,049
并且当我们想要查找时将其转换回内存
and we convert that back to a memory

677
00:24:51,049 --> 00:24:52,940
地址
address when we want to do a lookup to

678
00:24:52,940 --> 00:24:54,919
该块偏移量内的元组
find the tuple within the offset of that

679
00:24:54,919 --> 00:24:57,890
我们只是做一些简单的内存
block we just do some simple memory

680
00:24:57,890 --> 00:25:00,500
算术，将元组的
arithmetic to take the size of the tuple

681
00:25:00,500 --> 00:25:01,850
大小乘以我们的偏移量，然后
multiplied by our offset and then as

682
00:25:01,850 --> 00:25:03,320
告诉我们在内存中跳转到
tell us where to be jump in memory that

683
00:25:03,320 --> 00:25:06,440
阻塞的位置并后悔现在处理很
blocked and regret it now to handle very

684
00:25:06,440 --> 00:25:07,880
长的数据，这是
length data this is gonna be much

685
00:25:07,880 --> 00:25:10,580
将与我们在基于
different than what we would do in a

686
00:25:10,580 --> 00:25:13,159
磁盘的系统中所做的有很大不同，因此可变长度
disk based system so variable length

687
00:25:13,159 --> 00:25:14,750
数据而不是实际
data were instead instead of actually

688
00:25:14,750 --> 00:25:16,100
将数据存储在固定
storing the data in line the fixed

689
00:25:16,100 --> 00:25:18,529
长度数据块中，大部分时间
length data block for the most the time

690
00:25:18,529 --> 00:25:21,500
恢复点错误
restore point err to some other memory

691
00:25:21,500 --> 00:25:23,299
到一个非常链接的其他内存位置 数据池
location in a very linked data pool

692
00:25:23,299 --> 00:25:27,169
，其中直接访问与此元组中
where that's a direct access to the data

693
00:25:27,169 --> 00:25:29,419
的 this 属性相对应的数据
that corresponds to the this attribute

694
00:25:29,419 --> 00:25:31,490
，这里的想法
within this tuple and again the idea

695
00:25:31,490 --> 00:25:33,679
是我们可以保证
here is that we can guarantee that all

696
00:25:33,679 --> 00:25:35,059
所有元组和固定长度的数据
the tuples and the fixed length data

697
00:25:35,059 --> 00:25:36,620
块都是固定长度的 对于
blocks are fixed length and then for

698
00:25:36,620 --> 00:25:38,750
任何长度可变的内容，我们再次
anything that's variable length we shove

699
00:25:38,750 --> 00:25:40,250
将其推入非常长的数据块中
that into the very length data block

700
00:25:40,250 --> 00:25:42,169
，这与
again this is different than the slotted

701
00:25:42,169 --> 00:25:44,270
您在磁盘坐标系中看到的开槽页面设计不同，
page design you would see in a disk

702
00:25:44,270 --> 00:25:46,220
因为在那里我们
coordinate system because in there we're

703
00:25:46,220 --> 00:25:48,049
试图减少磁盘读取的数量，
trying to reduce the number of disk

704
00:25:48,049 --> 00:25:50,330
因此我们尝试 将您知道的元组的
reads so therefore we try to pack in all

705
00:25:50,330 --> 00:25:51,240
所有可变长度
the variable length data

706
00:25:51,240 --> 00:25:53,250
数据与
for a tuple within you know with the

707
00:25:53,250 --> 00:25:55,430
元组本身打包在一起，所有固定长度的
tuple itself all the fixed length data

708
00:25:55,430 --> 00:25:57,840
数据并不总是发生，如果它
that doesn't always happen and if it the

709
00:25:57,840 --> 00:25:59,160
溢出到另一个页面，我们可以这样做，
spillover to another page we can do that

710
00:25:59,160 --> 00:26:00,900
但大多数时候我们尝试这样做
but most the time we try to make that

711
00:26:00,900 --> 00:26:01,230
happen

712
00:26:01,230 --> 00:26:03,210
发生在这个世界中，内存系统
and in this world in memory system were

713
00:26:03,210 --> 00:26:04,200
实际上想要单独存储可变
actually want to store the variable

714
00:26:04,200 --> 00:26:05,910
长度数据，这样我们
length data separately so that way we

715
00:26:05,910 --> 00:26:08,460
就可以进行确定性查找来
can do that deterministic lookups to

716
00:26:08,460 --> 00:26:11,820
找到元组的内存地址，
find memory addresses for tuples all

717
00:26:11,820 --> 00:26:12,810
其他一些更好的事情
right some other things that better

718
00:26:12,810 --> 00:26:14,310
可能会有所不同，然后我们
could be different then we kind of

719
00:26:14,310 --> 00:26:15,270
很快就讨论了 在内存
talked about quickly within memory

720
00:26:15,270 --> 00:26:17,130
数据库中，这些是
databases right and again these are the

721
00:26:17,130 --> 00:26:18,450
我们整个学期都在谈论的事情
things we're talk about their entire

722
00:26:18,450 --> 00:26:20,640
，第一个是
semester the first one is gonna be how

723
00:26:20,640 --> 00:26:21,930
我们将如何实际存储索引
we're actually going to store indexes

724
00:26:21,930 --> 00:26:23,250
我们
sort of how with data structures we're

725
00:26:23,250 --> 00:26:25,560
将用于索引的数据结构，所以当 1980
gonna use for indexes so when this first

726
00:26:25,560 --> 00:26:27,510
年代提出第一个内存数据库系统时，
in memory database systems were proposed

727
00:26:27,510 --> 00:26:29,850
海港
in the 1980s the harbor it was a lot

728
00:26:29,850 --> 00:26:31,020
与我们
different than the hardware we know

729
00:26:31,020 --> 00:26:32,730
今天所了解的硬件或今天海港的
about today or how the harbor is laid

730
00:26:32,730 --> 00:26:34,950
布局有很大不同，特别是当时
out today so in particular back then the

731
00:26:34,950 --> 00:26:37,350
缓存和内存访问节拍
cache and memory access beats were about

732
00:26:37,350 --> 00:26:40,140
大致相同，但现在情况并非如此
the same but now this is not the case at

733
00:26:40,140 --> 00:26:42,900
，CPU 缓存比
all right CPU caches are way faster than

734
00:26:42,900 --> 00:26:45,720
主内存访问快得多，所以当时人们
main memory access so back then people

735
00:26:45,720 --> 00:26:48,180
正在设计数据结构，您是否
were designing data structures were you

736
00:26:48,180 --> 00:26:50,220
知道从缓存中读取与
know reading from cache was the same as

737
00:26:50,220 --> 00:26:52,440
读取内存相同 所以他们会
reading memory to be so they would

738
00:26:52,440 --> 00:26:55,140
以某种方式组织，但现在在
organize a certain way but now in the

739
00:26:55,140 --> 00:26:56,640
现代我们不想这样做，
modern era we don't want to do that

740
00:26:56,640 --> 00:26:59,010
所以我们想要使用
so therefore we want to use indexes that

741
00:26:59,010 --> 00:27:00,480
知道他们正在处理内存
know that they're dealing with memory

742
00:27:00,480 --> 00:27:01,710
并且他们有缓存的索引并
and they're and they have caches and try

743
00:27:01,710 --> 00:27:03,750
尝试最小化 当他访问事物时缓存未命中，
to minimize the cache misses when when

744
00:27:03,750 --> 00:27:06,180
因此剧透
he access things so the spoiler is gonna

745
00:27:06,180 --> 00:27:08,760
将是 B+ 树
be that a B+ tree is gonna turn out to

746
00:27:08,760 --> 00:27:13,680
将成为每天用于名称的最佳数据结构，
be a the best data structure to use for

747
00:27:13,680 --> 00:27:15,060
但即使
a name every day but it's even though

748
00:27:15,060 --> 00:27:16,770
d-plus 树最初是
d-plus trees were originally designed

749
00:27:16,770 --> 00:27:19,740
为磁盘库设计的 d 数据库它们
for disk based databases they're

750
00:27:19,740 --> 00:27:20,910
实际上仍然非常适合内存
actually still really good for in-memory

751
00:27:20,910 --> 00:27:24,300
数据，因此
data as well so the other major think

752
00:27:24,300 --> 00:27:25,650
我们
difference between the difference we're

753
00:27:25,650 --> 00:27:28,410
将拥有索引的差异之间的另一个主要想法是，在基于磁盘
gonna have indexes is that in a disk

754
00:27:28,410 --> 00:27:30,750
的系统中，您还将
based system you would also write log

755
00:27:30,750 --> 00:27:33,060
写入日志记录并为
records and write out pages for the

756
00:27:33,060 --> 00:27:34,740
索引磁盘，以便您可以
index disk so that you can recover them

757
00:27:34,740 --> 00:27:37,650
在系统重新启动内存
after the system restarts an in-memory

758
00:27:37,650 --> 00:27:39,480
系统后恢复它们我们实际上不会
system we're actually not going to

759
00:27:39,480 --> 00:27:41,040
记录任何低记录，
record any low of record to not write

760
00:27:41,040 --> 00:27:43,010
因为大多数系统不会将索引写入磁盘，
indexes out to disk for most systems

761
00:27:43,010 --> 00:27:45,840
因为重新启动系统后重建索引的成本
because the cost of rebuilding the index

762
00:27:45,840 --> 00:27:48,570
after restart the system is is gonna be

763
00:27:48,570 --> 00:27:51,450
super low rise to think about this when

764
00:27:51,450 --> 00:27:53,460
当系统和速率是当我
the system and the rate is when I

765
00:27:53,460 --> 00:27:55,800
重新启动时我必须将数据库
restarted I gotta bring the database

766
00:27:55,800 --> 00:27:57,660
完全带回主内存，因此
entirely back in the main memory and so

767
00:27:57,660 --> 00:27:59,730
the cost of reading that there's the

768
00:27:59,730 --> 00:28:01,590
从磁盘读取数据的成本非常昂贵，
data from from disk is super expensive

769
00:28:01,590 --> 00:28:03,820
而
whereas the cost of building

770
00:28:03,820 --> 00:28:05,560
一旦数据已经在
index at once the data is already in

771
00:28:05,560 --> 00:28:09,070
内存中，构建索引的成本是否便宜，因为它
memory is is it's cheap because it's

772
00:28:09,070 --> 00:28:12,220
只是 CPU 计算，因此
just CPU computations so for this reason

773
00:28:12,220 --> 00:28:14,470
，并避免必须将记录
and and gain avoiding the having to log

774
00:28:14,470 --> 00:28:18,430
记录到日志更新到记录到
records to the log updates to records to

775
00:28:18,430 --> 00:28:20,590
th  e 在运行时更新索引
the in debt updates to the index at

776
00:28:20,590 --> 00:28:22,330
或只是减慢我们的速度
runtime or just slow us down

777
00:28:22,330 --> 00:28:25,030
我们只是在重新启动后重建索引
we just rebuild the index after after we

778
00:28:25,030 --> 00:28:27,160
我们将涵盖这一点并清理
restart again we'll cover this and clean

779
00:28:27,160 --> 00:28:28,120
它的更多细节 现在当我们
it's more detail when we talk about

780
00:28:28,120 --> 00:28:32,800
再次讨论用于查询处理的索引时
indexes for query processing again now

781
00:28:32,800 --> 00:28:35,290
在令人失望的系统磁盘中 i/
in the dissapointing system the disk i/o

782
00:28:35,290 --> 00:28:37,690
o 总是最昂贵的东西，它
was always the most expensive thing who

783
00:28:37,690 --> 00:28:39,880
在乎你
cares what kind of for the most part how

784
00:28:39,880 --> 00:28:41,800
如何计算数据，或者你知道
you computed the data or you know the

785
00:28:41,800 --> 00:28:43,450
一旦数据
organize the access of data once it was

786
00:28:43,450 --> 00:28:47,020
在内存中的组织访问，那么在磁盘婚礼系统或
in memory so in a disk wedding system or

787
00:28:47,020 --> 00:28:48,760
内存系统中 我们现在会
so an in-memory system we are gonna care

788
00:28:48,760 --> 00:28:51,040
关心执行函数
about now the overhead of doing function

789
00:28:51,040 --> 00:28:52,420
调用和诸如此类的分支的开销
calls and branches of the things like

790
00:28:52,420 --> 00:28:54,130
，因此您需要更加关心我们如何
that so you need more care for how we

791
00:28:54,130 --> 00:28:56,170
组织系统和执行查询
organize the system and do query

792
00:28:56,170 --> 00:28:59,410
处理顺序扫描在内存系统中也没有
processing sequential scans are also not

793
00:28:59,410 --> 00:29:02,140
明显更快，
significantly faster in a in memory

794
00:29:02,140 --> 00:29:03,820
所以也许有一定的
system so maybe there's certain

795
00:29:03,820 --> 00:29:06,670
算法并且您知道
algorithms and you know join join

796
00:29:06,670 --> 00:29:08,560
用于执行连接和其他操作的连接连接方法
methods for doing joins and other things

797
00:29:08,560 --> 00:29:11,980
，我们不必
that we don't have to worry about making

798
00:29:11,980 --> 00:29:14,800
担心优化或最大化
your optimizing or maximizing that of

799
00:29:14,800 --> 00:29:16,660
计划访问，因为随机访问
schedule access because random access it

800
00:29:16,660 --> 00:29:18,700
就足够了 再次，
will be good enough again we'll cover

801
00:29:18,700 --> 00:29:20,790
我们将在继续进行日志记录和恢复时更详细地介绍这一点
this in more detail as we go along for

802
00:29:20,790 --> 00:29:23,320
我之前已经提到过
logging and recovery I sort of mentioned

803
00:29:23,320 --> 00:29:25,450
这一点，但是现在
this already before but now that

804
00:29:25,450 --> 00:29:27,520
所有内容都在内存中，没有
everything is in memory there are no

805
00:29:27,520 --> 00:29:30,250
脏页可以清除磁盘，我们
dirty pages you to flush out the disk we

806
00:29:30,250 --> 00:29:34,120
可以更加保守，或者我们可以
can be more conservative or we can end

807
00:29:34,120 --> 00:29:36,760
最终记录的数据少于我们需要的数据，
up recording less data than we need then

808
00:29:36,760 --> 00:29:37,840
we normally would need a disk or new

809
00:29:37,840 --> 00:29:39,730
如果我们知道所有东西都
system if we know that everything is in

810
00:29:39,730 --> 00:29:42,760
在内存中，那么我们通常需要一个磁盘或新系统，所以像 root Camp 这样的标准技术
the memory so standard techniques like

811
00:29:42,760 --> 00:29:44,080
我们将使用一批日志
root camp we'll use the batch of logs

812
00:29:44,080 --> 00:29:47,470
摊销 FSN 原因这
amortize FSN cause that's that's

813
00:29:47,470 --> 00:29:48,880
适用于磁盘 警告系统也是如此，
applicable for a disk warning system too

814
00:29:48,880 --> 00:29:51,820
但能够使用更轻量级的
but being able to use a more lightweight

815
00:29:51,820 --> 00:29:54,610
日志记录方案对于内存系统来说是一个明确的优势
logging scheme is a definite advantage

816
00:29:54,610 --> 00:29:56,920
，因为
for a in memory system right because

817
00:29:56,920 --> 00:29:58,750
同样没有脏页，我们
again there's no dirty pages we don't

818
00:29:58,750 --> 00:30:00,610
不需要做任何我们写到
need to do undo anything we write to

819
00:30:00,610 --> 00:30:02,770
磁盘的操作作为检查点的一部分将要撤销
disk as part of a checkpoint is going to

820
00:30:02,770 --> 00:30:03,940
be a party from a committed transaction

821
00:30:03,940 --> 00:30:08,560
在大多数情况下成为提交事务的一方，所以现在
for the most part all right so now if

822
00:30:08,560 --> 00:30:12,310
如果磁盘 I/O 不是最慢的资源，
the disk i/o is not the slowest resource

823
00:30:12,310 --> 00:30:15,310
那么我们可以改变
then we can change

824
00:30:15,310 --> 00:30:17,680
，我们改变使用该过程的协议、
and we change what sort of protocols and

825
00:30:17,680 --> 00:30:19,600
方法和算法的类型
methods and algorithms are using the

826
00:30:19,600 --> 00:30:21,160
process queries and transaction in a

827
00:30:21,160 --> 00:30:23,650
数据库系统中的查询和事务现在我们可以
database system now we can be mindful

828
00:30:23,650 --> 00:30:24,970
注意现在
with the other bottlenecks that are now

829
00:30:24,970 --> 00:30:26,140
将成为最前沿的其他瓶颈，因为
going to come to the forefront because

830
00:30:26,140 --> 00:30:28,390
磁盘 i/o 不再处于关键
disk i/o is no longer in the critical

831
00:30:28,390 --> 00:30:30,550
路径，所以这基本上是
path so this is essentially what the

832
00:30:30,550 --> 00:30:32,530
整个学期关于如何处理的
entire semester is about how to deal

833
00:30:32,530 --> 00:30:34,060
当我们设计数据库系统时，还有这些其他问题，
with these other issues when we design

834
00:30:34,060 --> 00:30:36,670
因此锁定闩锁和
database systems so locking latch and

835
00:30:36,670 --> 00:30:38,200
Sorkin 内核方法以及
Sorkin kernel methods and the lone

836
00:30:38,200 --> 00:30:39,880
保护这些数据结构的单独低级原语
low-level primitives to protect those

837
00:30:39,880 --> 00:30:43,690
缓存母狮是大
data structures cache lionesses are big

838
00:30:43,690 --> 00:30:46,030
问题 因为内存访问与缓存
deal cos can memory access versus cache

839
00:30:46,030 --> 00:30:48,300
访问相比是更昂贵的
access is is much more expensive

840
00:30:48,300 --> 00:30:50,770
追逐指针跳转到
chasing pointers doing jumps to random

841
00:30:50,770 --> 00:30:52,900
内存中的随机位置，它会导致
locations in memory and it will cause

842
00:30:52,900 --> 00:30:54,780
更多的缓存未命中，这是有问题的
more cache misses that's problematic

843
00:30:54,780 --> 00:30:57,430
评估谓词你知道吗？
evaluating predicates do you know taking

844
00:30:57,430 --> 00:30:58,930
为每一个十亿元组采用 where 子句
the where clause for every for a billion

845
00:30:58,930 --> 00:31:00,850
并评估它，这将是
tuples and evaluating it that's gonna be

846
00:31:00,850 --> 00:31:05,020
昂贵的移动数据或复制数据，因此
expensive moving data or copying data so

847
00:31:05,020 --> 00:31:06,670
如果我必须移动数据移动将是
data movement would be if I have to move

848
00:31:06,670 --> 00:31:08,980
数据从一个 sock CPU 插槽到
data from one sock CPU socket to another

849
00:31:08,980 --> 00:31:11,280
另一个昂贵的复制数据将
that's expensive copying data would be

850
00:31:11,280 --> 00:31:13,750
实现中间结果
materializing the intermediate results

851
00:31:13,750 --> 00:31:15,550
或复制数据 之间传递
or copy data between sockets to pass

852
00:31:15,550 --> 00:31:17,350
的东西的套接字是我们
things around those are things we want

853
00:31:17,350 --> 00:31:19,360
想要避免的事情，当然网络
to avoid and of course networking is

854
00:31:19,360 --> 00:31:22,630
始终是一个大问题，现在
always a big issue now there be

855
00:31:22,630 --> 00:31:24,580
主要存在于应用程序
primarily between the application and

856
00:31:24,580 --> 00:31:26,250
和数据库系统之间，而不是在
the database system and not between

857
00:31:26,250 --> 00:31:30,000
同一数据库的不同节点之间，这
different nodes of the same database

858
00:31:30,000 --> 00:31:32,050
是一个不一致的系统 - 但
matters were a discordant system - but

859
00:31:32,050 --> 00:31:35,650
再次 现在磁盘不见了，这
again now the disk is gone this is this

860
00:31:35,650 --> 00:31:37,150
是一个更成问题
is even more problematic and an

861
00:31:37,150 --> 00:31:39,580
的内存系统，所以在本讲座的其余部分，
in-memory system so for the rest of this

862
00:31:39,580 --> 00:31:41,230
我想讨论锁定和
lecture I want to discuss locking and

863
00:31:41,230 --> 00:31:43,240
闩锁，所以我们将重点关注
latching um so we're gonna focus on the

864
00:31:43,240 --> 00:31:44,500
这里的墨盒孔，这
cartridge hole here and this is just

865
00:31:44,500 --> 00:31:47,140
主要是为了 让我们了解前进的
mostly to set us up to understand going

866
00:31:47,140 --> 00:31:50,410
方向，你知道
forward how you know to think about and

867
00:31:50,410 --> 00:31:53,200
如何思考，就是这样，你知道
that's it to think about you know what

868
00:31:53,200 --> 00:31:55,680
是什么让游戏系统变慢，
is it that makes a game system slow and

869
00:31:55,680 --> 00:31:58,210
当我们开始扩展更多的 CPU
when we started scaling up more CPU

870
00:31:58,210 --> 00:31:58,570
内核时
cores

871
00:31:58,570 --> 00:31:59,860
，这些其他瓶颈
what does mean these other bottlenecks

872
00:31:59,860 --> 00:32:03,160
和问题意味着什么
and problems that were going to have so

873
00:32:03,160 --> 00:32:04,360
再次像我们在
again as we covered it in the

874
00:32:04,360 --> 00:32:05,920
介绍类并发中介绍的那样，您的目标
introduction class concurrent your goal

875
00:32:05,920 --> 00:32:08,560
本质上是
is essentially the protocol that the

876
00:32:08,560 --> 00:32:10,570
神使用的协议，允许它
deities have used that allows it to

877
00:32:10,570 --> 00:32:12,130
同时执行多个事务
execute multiple transactions at the

878
00:32:12,130 --> 00:32:14,650
时间和每个这些事务
same time and each these transactions

879
00:32:14,650 --> 00:32:16,690
都会有一种错觉
are going to sort of have this illusion

880
00:32:16,690 --> 00:32:19,600
，认为它们是由它们自己在系统上执行
that they're executing on the system by

881
00:32:19,600 --> 00:32:21,640
的，因此它们不必
it's by their self so they don't don't

882
00:32:21,640 --> 00:32:23,710
担心同时读取或读取
worry about reading or reading the

883
00:32:23,710 --> 00:32:25,030
其他事务的影响
effects of other transactions from at

884
00:32:25,030 --> 00:32:27,820
这基本上是
the same time I this is essentially what

885
00:32:27,820 --> 00:32:29,049
您希望在您的系统中实现的目标，
you would want to achieve in your system

886
00:32:29,049 --> 00:32:31,299
因为这是对
because that's it's the easiest way to

887
00:32:31,299 --> 00:32:34,629
您的应用程序进行编程的最简单方法，当然现在
program your application of course now

888
00:32:34,629 --> 00:32:35,769
这并不容易，如果开始
this is not easy to do if start

889
00:32:35,769 --> 00:32:37,629
interleaving interleaving operations

890
00:32:37,629 --> 00:32:39,220
在不同事务之间进行交织操作，您可能会
between different transactions you could

891
00:32:39,220 --> 00:32:43,299
违反此顺序，因此
violate this ordering so the kikuchiyo

892
00:32:43,299 --> 00:32:44,919
任何 kikuchiyo 协议 数据库系统将
protocol of any database system is going

893
00:32:44,919 --> 00:32:46,720
to provide the atomicity and isolation

894
00:32:46,720 --> 00:32:52,259
在此 SSN 首字母缩略词中提供原子性和隔离性保证，因此
guarantees within this SSN acronym so

895
00:32:52,259 --> 00:32:55,330
对于 mme 数据库系统，
for an mme database system there's this

896
00:32:55,330 --> 00:32:56,860
我们必须对
key observation we have to make about

897
00:32:56,860 --> 00:32:59,409
如何获取锁以
how we're going to acquire locks to

898
00:32:59,409 --> 00:33:03,519
访问极点进行关键观察，这就是
access to poles and that is the cost of

899
00:33:03,519 --> 00:33:04,989
事务的成本 获取锁
a transaction acquiring a lock is

900
00:33:04,989 --> 00:33:06,399
与访问数据本质上是一样的，
essentially the same thing as just

901
00:33:06,399 --> 00:33:09,369
所以我的意思
accessing the data so what I mean by

902
00:33:09,369 --> 00:33:12,369
是在磁盘加载系统中我们
that is in a disk loading system we said

903
00:33:12,369 --> 00:33:14,019
说所有的锁都可以 ld以
that all the locks would be stored in

904
00:33:14,019 --> 00:33:15,309
某种数据结构存储在内存中，
memory in some kind of data structure

905
00:33:15,309 --> 00:33:18,070
并且它们将与
and they would be and they were separate

906
00:33:18,070 --> 00:33:19,149
实际元组分开，但现在
from the actual tuples but now

907
00:33:19,149 --> 00:33:21,549
所有内容都在内存中，那么理想情况下
everything's in memory then the cost of

908
00:33:21,549 --> 00:33:24,009
访问和访问锁表的成本将与访问
going and accessing the lock table is

909
00:33:24,009 --> 00:33:26,320
going to be the same as accessing the

910
00:33:26,320 --> 00:33:29,139
元组相同 我希望能够同时执行
tuple so ideally I want to be able to do

911
00:33:29,139 --> 00:33:31,929
这些操作，这样我就不会
those at the same time so that I'm not

912
00:33:31,929 --> 00:33:34,090
因为执行两次内存读取而付出代价，
paying the penalty of doing two memory

913
00:33:34,090 --> 00:33:36,700
这是
reads and this is the core idea that

914
00:33:36,700 --> 00:33:39,700
家具尝试安装的核心思想，当我们
furniture try to install and when we do

915
00:33:39,700 --> 00:33:42,419
在内存中进行数据系统并发控制时
in memory data system concurrent control

916
00:33:42,419 --> 00:33:44,409
，其他重要的 还要
the other important thing to understand

917
00:33:44,409 --> 00:33:47,679
理解的是，在磁盘运行系统中，
too is is in a disk running system the

918
00:33:47,679 --> 00:33:50,649
停顿是由于事务试图
stalls are due to transactions trying to

919
00:33:50,649 --> 00:33:52,059
访问不是内存的数据，您必须
access data that wasn't memory you have

920
00:33:52,059 --> 00:33:54,190
转到磁盘并获取它们，但
to go get out to disk and get them but

921
00:33:54,190 --> 00:33:55,359
现在我们不会再有这种
now we're not gonna have those kind of

922
00:33:55,359 --> 00:33:57,549
停顿了 是的，是的，我会是内存
stalls anymore yeah yes I'll be memory

923
00:33:57,549 --> 00:34:00,549
停滞，但这些会
stalls but those are gonna be much much

924
00:34:00,549 --> 00:34:03,759
比你所知道的要少得多，只是偷来的，但
less than you know just stole but what

925
00:34:03,759 --> 00:34:05,919
你认为我们会有的或者
you think we are gonna have or that the

926
00:34:05,919 --> 00:34:08,109
早期的助手没有的是
earlier assistants don't have is a way

927
00:34:08,109 --> 00:34:11,440
更多的核心，所以现在争论
more cores and so now the contention is

928
00:34:11,440 --> 00:34:14,530
正在进行中 在 sy 许多
going to be in the system of many

929
00:34:14,530 --> 00:34:16,030
事务试图同时读取和
transactions trying to read and write to

930
00:34:16,030 --> 00:34:17,980
写入相同的对象，并且
the same objects at the same time and

931
00:34:17,980 --> 00:34:20,649
它们没有停止，因为那里有一个
they're not stalling because there's a

932
00:34:20,649 --> 00:34:22,449
磁盘被盗，因为它们没有我们
disk there stolen because they don't we

933
00:34:22,449 --> 00:34:23,589
无法获得某些东西的锁，
can't acquire the locks on certain

934
00:34:23,589 --> 00:34:28,750
所以你又明白了
things so do you understand again how

935
00:34:28,750 --> 00:34:29,980
我们实际上将能够
we're actually going to be able to

936
00:34:29,980 --> 00:34:31,299
维护锁定信息以及
maintain locking information along with

937
00:34:31,299 --> 00:34:35,799
我们理解的这种
the tuple we understand of this sort of

938
00:34:35,799 --> 00:34:37,389
基本比较和交换原语的元组，我们
basic compare-and-swap primitive we're

939
00:34:37,389 --> 00:34:40,119
将使用它来修改事物，因此我们
going to use to modify things so we're

940
00:34:40,119 --> 00:34:42,880
不会使用互斥锁保护元组，
not going to use mutexes protect tuples

941
00:34:42,880 --> 00:34:44,949
因为 相反，
because there would be too slow instead

942
00:34:44,949 --> 00:34:46,449
我们将使用这些
we're gonna use these atomic operations

943
00:34:46,449 --> 00:34:47,320
称为比较和交换的原子操作会太慢，
called compare-and-swap

944
00:34:47,320 --> 00:34:50,080
所以我认为这主要
so I think this is primarily covered it

945
00:34:50,080 --> 00:34:52,210
在其他类中涵盖，所以我
in other classes and so I just want to

946
00:34:52,210 --> 00:34:54,310
只想快速概述它是什么，
give you a quick overview what it is and

947
00:34:54,310 --> 00:34:55,810
因为这将
because this is gonna come up multiple

948
00:34:55,810 --> 00:34:58,570
在整个学期
times throughout the semester and it's

949
00:34:58,570 --> 00:35:01,150
中多次出现，一次看到我们并没有
good to sort of see at once we're not

950
00:35:01,150 --> 00:35:02,410
真正详细说明这是如何
really details of actually how this is

951
00:35:02,410 --> 00:35:04,300
实现的硬件只是知道
implemented Hardware just know that this

952
00:35:04,300 --> 00:35:07,810
这个概念但实际上存在所以
this concept but actually exists so

953
00:35:07,810 --> 00:35:10,360
比较交换是一个原子
compare swap is an atomic instruction

954
00:35:10,360 --> 00:35:13,630
指令 几乎每个现代 CPU 都会
that pretty much every modern CPU will

955
00:35:13,630 --> 00:35:16,390
为您提供这不是一个新概念我
provide you it's not a new concept I

956
00:35:16,390 --> 00:35:18,880
认为它可以追溯到 1970 年代可能
think it goes back to the 1970s probably

957
00:35:18,880 --> 00:35:20,800
几乎每个 Zeon arm 架构
pretty much every Zeon arm architecture

958
00:35:20,800 --> 00:35:23,770
或 PowerPC 现在都会给我
or a PowerPC will give me this now and

959
00:35:23,770 --> 00:35:25,180
这个想法是它是
the idea is that it's a single

960
00:35:25,180 --> 00:35:26,740
一条指令
instruction that's gonna do a lookup in

961
00:35:26,740 --> 00:35:29,320
在内存位置中查找，它会检查
a memory location and it's gonna check

962
00:35:29,320 --> 00:35:31,240
该内存位置在哪里具有提供的
to see where that memory location has a

963
00:35:31,240 --> 00:35:34,180
特定值，然后如果
certain value that provided and then if

964
00:35:34,180 --> 00:35:36,760
该值相等，那么元是一个
that value is equal so the meta is a

965
00:35:36,760 --> 00:35:38,200
值，该内存位置
value that memory location is the equal

966
00:35:38,200 --> 00:35:40,270
等于您正在检查的值，那么
to the value you're checking with then

967
00:35:40,270 --> 00:35:42,850
您 ' 允许安装一个新值来
you're allowed to install a new value to

968
00:35:42,850 --> 00:35:46,000
更新它，否则操作会失败
update it otherwise the operation fails

969
00:35:46,000 --> 00:35:48,280
，所以在这个例子中这个
and so in this example here this

970
00:35:48,280 --> 00:35:50,110
下划线下划线接收池比较
underscore underscore sink pool compared

971
00:35:50,110 --> 00:35:54,640
交换这是一个 C++ 或 Linux
swap this is a this is a C++ or Linux

972
00:35:54,640 --> 00:35:59,530
Lib C 或 Lennox 你看到两个缺陷
Lib C or Lennox did you see both flaws

973
00:35:59,530 --> 00:36:02,050
操作或内在不同
operation or intrinsic different

974
00:36:02,050 --> 00:36:03,340
平台有不同的东西，我
platforms have different things and I

975
00:36:03,340 --> 00:36:05,920
认为在现代系统中的大多数情况下，
think for the most part in modern

976
00:36:05,920 --> 00:36:08,440
要么是
systems there's there's either

977
00:36:08,440 --> 00:36:12,220
理解，要么是内在
understand or the intrinsic functions

978
00:36:12,220 --> 00:36:14,980
函数可以做同样的事情，爸爸
that can do the same thing Daddy here is

979
00:36:14,980 --> 00:36:16,360
是我们放弃了我 na 内存
that we're giving up giving in a memory

980
00:36:16,360 --> 00:36:16,600
地址
address

981
00:36:16,600 --> 00:36:18,370
我们给它一个比较值和一个
we're giving it a compare value and a

982
00:36:18,370 --> 00:36:20,730
新值，所以 M 指向的当前内存地址
new value so the current memory address

983
00:36:20,730 --> 00:36:23,620
包含值 20
that M points to contains the value 20

984
00:36:23,620 --> 00:36:25,990
所以在一条指令中，现在我们
so in a single instruction now we're

985
00:36:25,990 --> 00:36:28,660
要看看 20 是否等于 20 在
gonna see whether 20 equals 20 in the

986
00:36:28,660 --> 00:36:31,450
内存位置，如果是 一个摊位
memory location and if yes one stall

987
00:36:31,450 --> 00:36:33,310
安装新值 30 所以在这种情况下
install the new value 30 so in this case

988
00:36:33,310 --> 00:36:35,080
在这里在一条指令
here in a single instruction and we look

989
00:36:35,080 --> 00:36:38,650
中我们查找 M 等于 20 并且它这样
up to see that M equals 20 and it does

990
00:36:38,650 --> 00:36:41,110
做然后我们可以暂停 30 否则
so then we can stall 30 right otherwise

991
00:36:41,110 --> 00:36:44,740
这会失败所以在这个
that this would have failed so in this

992
00:36:44,740 --> 00:36:47,980
例子中这里的函数 这里
example here the the function here

993
00:36:47,980 --> 00:36:50,740
返回 true false 并说明
returns true false and saying whether is

994
00:36:50,740 --> 00:36:52,840
是否成功有所有不同
succeeded or not there's all different

995
00:36:52,840 --> 00:36:55,300
类型的比较和交换指令
types of compare and swap instruction

996
00:36:55,300 --> 00:36:56,380
，有时它们会由
and sometimes they'll return by

997
00:36:56,380 --> 00:36:58,479
我安装的新人
the the new guy that I got installed or

998
00:36:58,479 --> 00:36:59,829
或旧人返回，如果它没有得到
the old one if it didn't get updated

999
00:36:59,829 --> 00:37:01,839
更新，然后你 可以改变你
some and then you can change the you

1000
00:37:01,839 --> 00:37:05,079
知道的内存大小，
know the size of the memory dress that

1001
00:37:05,079 --> 00:37:07,299
你正在用 32 位或 64 位查看，
you're looking at with 32 bits or 64

1002
00:37:07,299 --> 00:37:09,880
但同样的，基本思想
bits but again the basic idea is always

1003
00:37:09,880 --> 00:37:10,839
在单个指令中始终是相同的，
the same thing within a single

1004
00:37:10,839 --> 00:37:12,940
我们可以执行此检查，
instruction we can do this check and

1005
00:37:12,940 --> 00:37:14,859
这是我们合并了它们 给
this is we incorporate them that were to

1006
00:37:14,859 --> 00:37:17,289
你 整个学期都允许
use all throughout the semester allows

1007
00:37:17,289 --> 00:37:20,829
do these kind of lock free or latch free

1008
00:37:20,829 --> 00:37:25,299
非常有效地进行此类无锁或无锁操作，因此我们想
operations very efficiently so we want

1009
00:37:25,299 --> 00:37:28,960
快速讨论一下我们将在本学期使用
to talk about quickly sort of the tutor

1010
00:37:28,960 --> 00:37:30,999
的类似协议的类别或类的导师
of categories or classes of comparable

1011
00:37:30,999 --> 00:37:32,799
protocols that we're gonna be working

1012
00:37:32,799 --> 00:37:35,079
，这
with this semester and this again

1013
00:37:35,079 --> 00:37:37,359
又是 对我们
there's sort of a refresher from what we

1014
00:37:37,359 --> 00:37:39,489
在介绍类课程
covered in the introduction class lesson

1015
00:37:39,489 --> 00:37:42,460
Osterman 中介绍的内容进行了复习，因此第一次使用两
Osterman and so the first time you two

1016
00:37:42,460 --> 00:37:44,109
阶段锁定，因此这些是悲观的
phase locking so these are pessimistic

1017
00:37:44,109 --> 00:37:45,759
方案，其中数据系统将
schemes where the data systems going to

1018
00:37:45,759 --> 00:37:47,680
假设事务将
assume that transactions are going to

1019
00:37:47,680 --> 00:37:49,960
发生冲突，因此它们
conflict and therefore they have

1020
00:37:49,960 --> 00:37:51,460
需要对任何对象进行锁定
required locks on any objects before

1021
00:37:51,460 --> 00:37:53,160
在允许访问它们之前，
that allowed to access them

1022
00:37:53,160 --> 00:37:55,450
时间戳排序是一种乐观
timestamp ordering is an optimistic

1023
00:37:55,450 --> 00:37:57,430
方案，您假设冲突
scheme where you assume conflicts are

1024
00:37:57,430 --> 00:37:59,710
很少见，因此您不需要事务来
rare so you don't require transaction to

1025
00:37:59,710 --> 00:38:01,119
获取数据库对象上的锁，
acquire locks on database objects and

1026
00:38:01,119 --> 00:38:02,829
而您所做的只是在
all you do instead is that when the

1027
00:38:02,829 --> 00:38:04,869
事务提交时查看
transaction goes to commit you see

1028
00:38:04,869 --> 00:38:06,729
是否存在 一个冲突，
whether there there was a conflict and

1029
00:38:06,729 --> 00:38:09,579
然后你根据需要更正它们，所以让
then you correct them as needed so let's

1030
00:38:09,579 --> 00:38:10,769
我们逐个逐一检查，
go through each of these one by one

1031
00:38:10,769 --> 00:38:13,089
展示真正高水平的考试 ples
showing really high-level examples and

1032
00:38:13,089 --> 00:38:15,039
然后我们将进入论文讨论
then we'll get into the paper discusses

1033
00:38:15,039 --> 00:38:16,210
你如何在现代系统上实际实现它，
how do you actually implement this on

1034
00:38:16,210 --> 00:38:19,630
所以如果有一个简单
modern systems so if there's a simple

1035
00:38:19,630 --> 00:38:21,640
的两阶段锁定示例，我们有一个
example for two phase locking we have a

1036
00:38:21,640 --> 00:38:24,400
事务 t1 并且它想要在 a 上进行读取
transaction t1 and it wants to do a read

1037
00:38:24,400 --> 00:38:27,460
，然后在 P 上进行一次读取 所以再次
on a followed by a right on P so again

1038
00:38:27,460 --> 00:38:29,229
一两个阶段锁定我们必须
one or two phase locking we have to

1039
00:38:29,229 --> 00:38:31,960
获取我们
acquire the locks for any object that we

1040
00:38:31,960 --> 00:38:33,789
想要读取和写入的任何对象的锁 所以在这种情况下
want to read and write so in this case

1041
00:38:33,789 --> 00:38:35,019
，我们必须
here we've got to get the read on the

1042
00:38:35,019 --> 00:38:37,839
在 B 上的后续锁上获取对锁的读取 所以这
lock on a follow up a lock on B so this

1043
00:38:37,839 --> 00:38:39,999
是 一个非常简单的例子或简化的
is a really simple example or simplified

1044
00:38:39,999 --> 00:38:42,729
例子，因为我知道
example because I'm you know there's

1045
00:38:42,729 --> 00:38:44,920
只有一种简单的锁定
only this a simple one type of lock on

1046
00:38:44,920 --> 00:38:47,979
在 a 和 B 上，但在我们上学期介绍的真实系统中，
on a and B but in a real system as we

1047
00:38:47,979 --> 00:38:51,249
你知道你
covered last semester you know you would

1048
00:38:51,249 --> 00:38:52,660
会有不同的锁定模式，你可以有一个
have different lock modes you can have a

1049
00:38:52,660 --> 00:38:54,789
共享 模式多个事务
shared mode the multiple transactions

1050
00:38:54,789 --> 00:38:56,349
读取同一个对象，独占
read the same object and exclusive mode

1051
00:38:56,349 --> 00:38:58,450
模式表示只有一个事务可以
to say that only one transaction can

1052
00:38:58,450 --> 00:39:01,450
锁定它可以连接可以在
lock it could connect can write it at a

1053
00:39:01,450 --> 00:39:04,269
给定时间写入所以在这种情况下因为
given time so in this case here because

1054
00:39:04,269 --> 00:39:06,969
两阶段锁定事务的第一部分
two-phase locking the first part of the

1055
00:39:06,969 --> 00:39:08,140
称为增长阶段
transaction is called the growing phase

1056
00:39:08,140 --> 00:39:09,940
这就是我们所在的地方
and this is where we're

1057
00:39:09,940 --> 00:39:14,530
获取我们需要的锁很
acquiring locks that we need okay sorry

1058
00:39:14,530 --> 00:39:16,180
抱歉我们在事务执行期间需要
that we're need during during the

1059
00:39:16,180 --> 00:39:18,520
，然后
exertion in the transaction and then

1060
00:39:18,520 --> 00:39:20,710
一旦我们释放一个块，现在我们
soon as we release one block now we're

1061
00:39:20,710 --> 00:39:23,770
处于收缩阶段，我们
in the shrinking phase and we're not

1062
00:39:23,770 --> 00:39:26,950
不允许获取任何新锁，但我们
allowed to acquire any new locks but we

1063
00:39:26,950 --> 00:39:29,800
可以这样做 对唯一对象的操作我们
can do operations on the only objects we

1064
00:39:29,800 --> 00:39:32,170
仍然拥有所有锁定，因此
still have all the locks for so in a

1065
00:39:32,170 --> 00:39:34,630
在像基于续集的真实系统中，
real system like in it's based on sequel

1066
00:39:34,630 --> 00:39:38,290
您实际上不会有明确的锁定
you wouldn't actually have explicit lock

1067
00:39:38,290 --> 00:39:40,240
和解锁命令这些是
and unlock commands these are something

1068
00:39:40,240 --> 00:39:41,410
我们已经过时的一些灰尘，您会
we've dated some dust where you

1069
00:39:41,410 --> 00:39:43,200
自动在封面下
automatically underneath the covers so

1070
00:39:43,200 --> 00:39:46,750
通常，您
typically you you don't release the

1071
00:39:46,750 --> 00:39:48,100
在事务实际提交之前不会释放锁，
locks until the transaction actually

1072
00:39:48,100 --> 00:39:50,710
这称为严格的新
commits which is called rigorous new

1073
00:39:50,710 --> 00:39:52,510
阶段锁定，但对于
phase locking but for a preferences here

1074
00:39:52,510 --> 00:39:53,950
本示例中的首选项，我们不会这样做，我们
in this example we're not doing that we

1075
00:39:53,950 --> 00:39:56,350
可以解锁 a 然后文件，然后
can unlock a and then file and then do

1076
00:39:56,350 --> 00:39:58,630
在 B 和 仍然
the write on B and that still follows

1077
00:39:58,630 --> 00:40:01,170
遵循原始的两阶段锁定协议，
the original two phase locking protocol

1078
00:40:01,170 --> 00:40:03,280
所以假设现在我们有
all right so let's say now we have

1079
00:40:03,280 --> 00:40:05,280
另一个事务 t2 出现并且
another transaction t2 comes along and

1080
00:40:05,280 --> 00:40:07,750
它想要对我不命名的父亲进行写
it wants to do a write on the father I

1081
00:40:07,750 --> 00:40:11,590
操作，所以说这些事务
don't name and so say these transactions

1082
00:40:11,590 --> 00:40:13,030
正在运行 在
are running at the same time on

1083
00:40:13,030 --> 00:40:14,590
不同的线程上同时进行，因此
different threads and therefore they can

1084
00:40:14,590 --> 00:40:17,170
他们可以彼此并行执行这些操作，
they can do these things in parallel

1085
00:40:17,170 --> 00:40:19,870
因此在 t1 中，我们首先
with each other so in t1 we first get

1086
00:40:19,870 --> 00:40:22,240
在 t2 上获得 a 上的锁并在 B 上获得锁，
the lock on a on t2 and get a lock on B

1087
00:40:22,240 --> 00:40:24,460
假设没有其他
this is fine assuming there's no other

1088
00:40:24,460 --> 00:40:26,110
事务同时写入，这很好 时间，所以
transaction written at the same time so

1089
00:40:26,110 --> 00:40:27,640
这两个事务都可以
both these transactions can acquire

1090
00:40:27,640 --> 00:40:30,160
在下一步中获取这些锁 他们的
those locks in the next step their

1091
00:40:30,160 --> 00:40:31,900
事务 t1 在 a 上执行读取，这
transaction t1 does the read on a which

1092
00:40:31,900 --> 00:40:33,190
是允许的，因为它持有
is allowed to do because it holds the

1093
00:40:33,190 --> 00:40:35,440
事务上的锁
lock on a transaction t2 does the right

1094
00:40:35,440 --> 00:40:36,700
t2 在 B 上执行正确的操作，因为它
on B which is a lot of do because it

1095
00:40:36,700 --> 00:40:39,370
持有一个 将锁排在梁上，但现在我们
holds a row the lock on beam but now we

1096
00:40:39,370 --> 00:40:41,770
在这里遇到了麻烦，因为 t1
get into trouble here because t1 wants

1097
00:40:41,770 --> 00:40:44,320
想要在 b 上锁定 t2 一个人会在
to do a lock on b t2 one's gonna lock on

1098
00:40:44,320 --> 00:40:46,810
a 上锁定，但是这些中的每一个都由
a but each of these are held by the

1099
00:40:46,810 --> 00:40:48,450
另一个事务持有，所以它们必须正确地停止
other transaction so they have to stall

1100
00:40:48,450 --> 00:40:50,590
并且它们本质上已经在那里
right and they've been there essentially

1101
00:40:50,590 --> 00:40:51,700
等待另一个事务
waiting for the other transaction to

1102
00:40:51,700 --> 00:40:53,830
放弃锁定，所以我继续前进，可以
give up the lock so I'm go ahead and can

1103
00:40:53,830 --> 00:40:55,570
取得进展，但当然我们
make forward progress but of course we

1104
00:40:55,570 --> 00:40:57,190
这里有一个僵局，所以现在我们
have a deadlock here and so now we have

1105
00:40:57,190 --> 00:40:58,480
必须做一些事情来打破这个，
to do something to break this because

1106
00:40:58,480 --> 00:40:59,800
否则系统将永远被锁定，
otherwise the system would be locked

1107
00:40:59,800 --> 00:41:02,700
所以有 两种方式 做
forever so there's two ways to do

1108
00:41:02,700 --> 00:41:05,320
死锁或处理死锁，如果他
deadlock or handle deadlocks and if he's

1109
00:41:05,320 --> 00:41:07,180
锁定第一个进行死锁
locking the first to do deadlock

1110
00:41:07,180 --> 00:41:08,830
检测，这就是你有一个
detection this is where you have a

1111
00:41:08,830 --> 00:41:10,210
单独的后台线程的地方，它只是
separate background thread that's just

1112
00:41:10,210 --> 00:41:12,730
偶尔或定期
gonna occasionally or periodically wake

1113
00:41:12,730 --> 00:41:14,560
唤醒检查事务是否
up check to see whether the transactions

1114
00:41:14,560 --> 00:41:16,600
正在运行，如果它发现一个死锁
are running and if it finds a deadlock

1115
00:41:16,600 --> 00:41:18,070
然后使用一些
then uses some kind of heuristics to

1116
00:41:18,070 --> 00:41:20,740
决定如何杀死它们的启发式方法 我可以说你
decide how to kill them I could say you

1117
00:41:20,740 --> 00:41:22,600
知道杀死
know kill the transaction has

1118
00:41:22,600 --> 00:41:24,250
完成最少工作
that has done the least amount of work

1119
00:41:24,250 --> 00:41:26,170
或最老或持有最多锁
or is the oldest or holds the most locks

1120
00:41:26,170 --> 00:41:29,100
的事务 各种系统做各种不同的事情
the various systems do various things

1121
00:41:29,100 --> 00:41:31,630
不同的系统都有不同
different systems do all have different

1122
00:41:31,630 --> 00:41:34,320
类型的死锁 检测算法
types of deadlock detection algorithms

1123
00:41:34,320 --> 00:41:36,670
死锁预防不是有
deadlock prevention is instead of having

1124
00:41:36,670 --> 00:41:39,390
一个单独的线程，你只是有一种方法来
a separate thread you just have a way to

1125
00:41:39,390 --> 00:41:41,830
确保当事务尝试
make sure that when transaction tries

1126
00:41:41,830 --> 00:41:43,840
获取锁时他们不能持有它然后
acquire a lock they can't hold it then

1127
00:41:43,840 --> 00:41:45,700
它决定它应
it makes a decision about what it should

1128
00:41:45,700 --> 00:41:48,880
该做什么而不只是等待，
do other than just waiting so for

1129
00:41:48,880 --> 00:41:50,350
例如 如果一个事务试图
example if I if a transaction tries to

1130
00:41:50,350 --> 00:41:52,480
持有一个锁，则获取一个锁，但该锁
hold a lock acquire a lock but that lock

1131
00:41:52,480 --> 00:41:54,610
被其他人持有，您
is being held by somebody else and you

1132
00:41:54,610 --> 00:41:56,620
可以杀死自己或杀死另一个
can either kill itself or kill the other

1133
00:41:56,620 --> 00:41:59,070
t 交易并再次窃取锁
transaction and steals locks right again

1134
00:41:59,070 --> 00:42:01,660
我们必须确保我们
we do have to make sure we do the

1135
00:42:01,660 --> 00:42:03,460
以正确的顺序执行操作
operations in the right order so that

1136
00:42:03,460 --> 00:42:06,280
，这样你就知道
there's so that way there's you know

1137
00:42:06,280 --> 00:42:09,790
没有依赖循环，
there's no cycle of dependencies all

1138
00:42:09,790 --> 00:42:12,490
所以另一种类型的协议
right so the other type of protocol is

1139
00:42:12,490 --> 00:42:16,330
再次称为时间戳排序，这是
called timestamp ordering again this is

1140
00:42:16,330 --> 00:42:17,710
排序 使用
sort of category systems that are in use

1141
00:42:17,710 --> 00:42:19,210
时间戳而不是锁来确定
time stamps than a lock to figure out

1142
00:42:19,210 --> 00:42:21,160
应该允许事务完成的正确顺序的类别系统
the right order that transactions should

1143
00:42:21,160 --> 00:42:25,030
的种类，因此
be allowed to complete so the sort of

1144
00:42:25,030 --> 00:42:27,220
两种基本协议是基本时间戳
two basic protocols are basic time stamp

1145
00:42:27,220 --> 00:42:28,990
排序，这有点令人困惑，
ordering which is sort of confusing

1146
00:42:28,990 --> 00:42:31,810
因为它通常被称为
because it's usually referred to as the

1147
00:42:31,810 --> 00:42:33,490
时间 邮票登机协议
time stamp boarding protocol which is in

1148
00:42:33,490 --> 00:42:35,050
属于时间戳订购协议的类别，
the category of time stamp ordering

1149
00:42:35,050 --> 00:42:38,590
但都称其为基本的 tio
protocols but it's all call it basic tio

1150
00:42:38,590 --> 00:42:40,810
dis 以区分它，因此这里的想法
dis to differentiate it so the idea here

1151
00:42:40,810 --> 00:42:42,490
是我们将检查
is that we're gonna check for conflicts

1152
00:42:42,490 --> 00:42:44,440
每次读取和写入时是否存在冲突，我们只是
on every read and write and we're just

1153
00:42:44,440 --> 00:42:46,090
要使用 时间戳确定
gonna and use time stamps determine

1154
00:42:46,090 --> 00:42:47,800
是否存在冲突，然后
whether there is a conflict and then

1155
00:42:47,800 --> 00:42:50,770
我们将在每个事务读取元组时将元组复制到私有
we're gonna copy tuples into a private

1156
00:42:50,770 --> 00:42:52,150
工作区中，
workspace for each transaction as they

1157
00:42:52,150 --> 00:42:54,160
以确保它们是否返回并
read them to ensure if they go back and

1158
00:42:54,160 --> 00:42:55,660
读取 t 使用相同的电缆，它们获得相同的
read the same cable they get the same

1159
00:42:55,660 --> 00:42:57,730
值，否则您可能会
value because otherwise you could be

1160
00:42:57,730 --> 00:42:58,720
阅读将来编写的内容，
reading something that was written in

1161
00:42:58,720 --> 00:42:59,590
而这不应该
the future and that shouldn't have

1162
00:42:59,590 --> 00:43:00,480
发生
happened

1163
00:43:00,480 --> 00:43:03,280
乐观的墨盒角色
optimistic cartridge role is where in

1164
00:43:03,280 --> 00:43:05,860
除了将您阅读的内容复制
addition to copying the things you read

1165
00:43:05,860 --> 00:43:09,850
到以前的工作空间之外，还可以
into your prior work space okay you're

1166
00:43:09,850 --> 00:43:11,440
还会复制
also gonna come make copies of any

1167
00:43:11,440 --> 00:43:13,180
您修改的任何元组，并且您的所有
tuples you modify and and all your

1168
00:43:13,180 --> 00:43:14,530
权限都进入私有工作区，
rights go into private workspace and

1169
00:43:14,530 --> 00:43:17,170
然后当您提交时，您会
then when you go to commit then you do

1170
00:43:17,170 --> 00:43:18,520
进行验证，以检查是否
the validation as checked as whether

1171
00:43:18,520 --> 00:43:20,290
存在撞击冲突，如果
there were the ramming conflicts and if

1172
00:43:20,290 --> 00:43:22,210
没有，则可以合并所有私有
not then you can merge all your private

1173
00:43:22,210 --> 00:43:23,920
工作区更改回全局
workspace changes back into the global

1174
00:43:23,920 --> 00:43:26,230
数据库，因此我们将再次
database so again we'll go through each

1175
00:43:26,230 --> 00:43:30,640
逐个逐一检查，例如对于基本
of these one by one so say for the basic

1176
00:43:30,640 --> 00:43:31,870
时间戳警告协议，我们有一个
time stamp warning protocol we have a

1177
00:43:31,870 --> 00:43:34,060
事务 t1 想要对 B 上的 a 进行读取，
transaction t1 wants to do a read on a

1178
00:43:34,060 --> 00:43:35,980
并且有某种
of write on B and there's been some kind

1179
00:43:35,980 --> 00:43:36,430
窃取
of stole

1180
00:43:36,430 --> 00:43:39,640
并希望在交易开始时正确执行，因此当
and wants to do it right on a so when a

1181
00:43:39,640 --> 00:43:41,170
交易开始时，我们必须分配
transaction starts we have to assign the

1182
00:43:41,170 --> 00:43:42,400
时间戳，因为我们将使用它
timestamp because we're gonna use that

1183
00:43:42,400 --> 00:43:43,900
来确定交易的序列顺序，
to determine the serial ordering of

1184
00:43:43,900 --> 00:43:46,359
因此有不同的
transactions so there's different

1185
00:43:46,359 --> 00:43:48,190
方案 你可以使用我可以使用
schemes you could use I can use the

1186
00:43:48,190 --> 00:43:49,930
硬件时钟我可以使用逻辑
hardware clock I can use a logical

1187
00:43:49,930 --> 00:43:52,329
计数器我使用一个hypo来调整但为了
counter I use a hypo to the tune but for

1188
00:43:52,329 --> 00:43:53,440
简单起见我们假设我们使用一个
simplicity let's just say we use a

1189
00:43:53,440 --> 00:43:56,230
逻辑计数器并且
logical counter and we just update that

1190
00:43:56,230 --> 00:43:57,309
我们每次开始交易时都更新该计数器
counter every single time we start

1191
00:43:57,309 --> 00:43:58,539
并签署
transaction and we sign that new

1192
00:43:58,539 --> 00:44:02,680
timestamp to get to the to the to the to

1193
00:44:02,680 --> 00:44:04,960
到达事务的新时间戳，所以这个事务
the transaction so this transaction

1194
00:44:04,960 --> 00:44:07,660
开始，它
starts and it's gonna give the timestamp

1195
00:44:07,660 --> 00:44:10,480
现在将在数据库中为
10000 1 now inside the database for

1196
00:44:10,480 --> 00:44:11,920
我们存储的每条记录提供时间戳 10000 1 我们
every single record we're storing we're

1197
00:44:11,920 --> 00:44:14,529
将维护两个额外的字段，以便
gonna maintain two additional fields so

1198
00:44:14,529 --> 00:44:15,940
我们维护重新计时 飞行时间中的时间戳
we maintain the retime stamp in the

1199
00:44:15,940 --> 00:44:18,190
2 3 次相同将是成功读取此元组
flight times 2 3 times same would be the

1200
00:44:18,190 --> 00:44:19,390
的最后一个事务的最高时间戳，
highest time stamp of the last

1201
00:44:19,390 --> 00:44:20,799
transaction that successfully read this

1202
00:44:20,799 --> 00:44:22,779
而写入时间戳将是
tuple and the write time stamp will be

1203
00:44:22,779 --> 00:44:24,490
the last times the time stamp of the

1204
00:44:24,490 --> 00:44:26,680
最后一次通向此元组的道路的时间戳的最后一次 ii
last time ii that road to this tuple the

1205
00:44:26,680 --> 00:44:27,970
这些时间戳
idea is that these time stamps are

1206
00:44:27,970 --> 00:44:29,740
总是在时间上向前推进，它们
always going forward in time they can

1207
00:44:29,740 --> 00:44:30,910
永远不会倒退，因为这将
never go backward because that would be

1208
00:44:30,910 --> 00:44:32,710
违反交易的时间戳顺序，
violating the time stamp ordering of

1209
00:44:32,710 --> 00:44:34,839
所以我们的
transactions all right so our

1210
00:44:34,839 --> 00:44:36,400
交易开始读取鸡蛋，
transaction starts does a read on egg so

1211
00:44:36,400 --> 00:44:38,289
所以 需要做的第一件事是检查
the first thing needs to do is check the

1212
00:44:38,289 --> 00:44:40,599
写入时间戳，看看它的
write time stamp and see whether it's

1213
00:44:40,599 --> 00:44:43,690
时间戳是否大于小时，这意味着
time stamp is greater than hours meaning

1214
00:44:43,690 --> 00:44:45,489
我们将来会尝试读取
we'd be trying to read something in the

1215
00:44:45,489 --> 00:44:46,839
我们不会读的
future that we wouldn't read me allowed

1216
00:44:46,839 --> 00:44:49,599
内容，在这种情况下，我允许在正确的时间阅读
to read in this case here the right time

1217
00:44:49,599 --> 00:44:53,019
记录 a 的时间戳是 10,000 小时
stamp for record a is 10,000 hour time

1218
00:44:53,019 --> 00:44:55,390
时间戳是 10,000 韩元，所以我们
stamp is 10,000 won so were we allowed

1219
00:44:55,390 --> 00:44:57,670
允许阅读这个，所以我们现在需要更新
to read this so we need to update now

1220
00:44:57,670 --> 00:44:59,680
重新时间戳以检查
the re time stamp to check to see

1221
00:44:59,680 --> 00:45:03,309
它的时间戳是否
whether it's time stamp is is less than

1222
00:45:03,309 --> 00:45:05,170
小于小时，如果是，那么我们想要
than hours and if it is then we want to

1223
00:45:05,170 --> 00:45:07,029
继续更新它，所以在这种情况下
go ahead and update it so in this case

1224
00:45:07,029 --> 00:45:09,309
，我们现在将用 10,000 韩元更新它，
here we'll update it with 10,000 won now

1225
00:45:09,309 --> 00:45:11,019
这告诉其他
this is telling other transactions that

1226
00:45:11,019 --> 00:45:13,630
可能想要更新此元
may want to update this this tuple that

1227
00:45:13,630 --> 00:45:15,940
组的事务，在时间戳 10000 韩元处有一个事务
there's was a transaction at timestamp

1228
00:45:15,940 --> 00:45:18,130
已读取它，因此请
10000 won that has read it so make sure

1229
00:45:18,130 --> 00:45:19,569
确保 我们过去不写东西，
that we don't write something in the

1230
00:45:19,569 --> 00:45:22,630
实际上错过了这些术语，
past and this terms actually missed so

1231
00:45:22,630 --> 00:45:24,519
所以现在我们在节拍上做正确的
then now we do the right on beat same

1232
00:45:24,519 --> 00:45:25,839
事情，首先检查以查看正确的
thing we first check to see the right

1233
00:45:25,839 --> 00:45:26,470
时间戳，
time stamp

1234
00:45:26,470 --> 00:45:27,730
看看我们是否必须查看它是否
see if we have to see whether it's in

1235
00:45:27,730 --> 00:45:29,769
在将来 在，
the future from when we're at and

1236
00:45:29,769 --> 00:45:31,269
因此我们将覆盖
therefore we would be overriding

1237
00:45:31,269 --> 00:45:34,450
带有过去数据的未来数据是
future data with past data which is not

1238
00:45:34,450 --> 00:45:36,249
不允许的，然后我们检查读取
allowed and then we check the read time

1239
00:45:36,249 --> 00:45:38,019
时间戳并确保将来有人没有读取
stamp and make sure someone didn't read

1240
00:45:38,019 --> 00:45:40,359
此记录，如果我们确实
this record in the future and if we did

1241
00:45:40,359 --> 00:45:41,859
写入了它，他们最终会丢失它，
write to it they would end up missing it

1242
00:45:41,859 --> 00:45:45,039
因此在这种情况下，我们的时间 戳
so in this case here our time stamp

1243
00:45:45,039 --> 00:45:46,720
检查
checks out for both of these both the

1244
00:45:46,720 --> 00:45:48,489
读取和权限，所以我们继续
reads and the rights so we go ahead and

1245
00:45:48,489 --> 00:45:51,220
更新我的时间戳字段，
update my time stamp field

1246
00:45:51,220 --> 00:45:53,990
然后我会说我们的交易有
then I'll say that our transaction has

1247
00:45:53,990 --> 00:45:56,060
某种停顿，就像它正在
some kind of stall like it's computing

1248
00:45:56,060 --> 00:45:58,160
计算你知道 pi 的第 10 亿
the you know the 1 billion billionth

1249
00:45:58,160 --> 00:46:01,339
位数字或
digit of pi or its accesses remote some

1250
00:46:01,339 --> 00:46:03,260
无论出于何种原因，它都会远程访问某个根系统，因此
root system for whatever reason there's

1251
00:46:03,260 --> 00:46:05,540
出现停顿，在此期间，另一个
a stall and during this time another

1252
00:46:05,540 --> 00:46:07,609
事务出现并修改了
transaction comes along and modifies

1253
00:46:07,609 --> 00:46:10,520
记录 a，现在
record a and now updates at the right

1254
00:46:10,520 --> 00:46:13,490
以一万五的正确时间戳更新，所以现在
time stamp with ten thousand five so now

1255
00:46:13,490 --> 00:46:15,140
我们将看到我们有一个真正的问题，
we'll see that we have a real issue

1256
00:46:15,140 --> 00:46:17,089
因为现在 当我们的事务
because now when our transaction wakes

1257
00:46:17,089 --> 00:46:20,410
唤醒并尝试写入记录时
up and tries to then write to record a

1258
00:46:20,410 --> 00:46:23,630
，时间戳 10000 5
that timestamp 10000 five is greater

1259
00:46:23,630 --> 00:46:26,390
大于我们的时间戳 10000 一所以我们
than our timestamp 10000 one so we

1260
00:46:26,390 --> 00:46:27,910
不应该被允许这样做，因为
shouldn't be allowed to do this because

1261
00:46:27,910 --> 00:46:30,790
这会试图覆盖一个
this would be trying to overwrite a

1262
00:46:30,790 --> 00:46:33,320
逻辑记录
logical record that was updated in the

1263
00:46:33,320 --> 00:46:36,170
将来用过去的物理记录更新，
future with a physical record of in the

1264
00:46:36,170 --> 00:46:38,300
所以在这种情况下，这
past so in this case here this be

1265
00:46:38,300 --> 00:46:40,280
违反了时间符号环，我们的
violating the time symbol ring and our

1266
00:46:40,280 --> 00:46:41,690
事务必须被终止并加入
transaction has to get killed and aboard

1267
00:46:41,690 --> 00:46:46,310
它，我们回滚任何更改，因此
it and we roll back any changes so most

1268
00:46:46,310 --> 00:46:48,800
那里的大多数系统都不会 做
systems that are out there don't do the

1269
00:46:48,800 --> 00:46:50,720
基本的时间戳学习协议
basic time stamp learning protocol the

1270
00:46:50,720 --> 00:46:53,500
更常见的方法是
more common approach is to do OCC

1271
00:46:53,500 --> 00:46:56,060
再次对整个盒式磁带进行 OCC 乐观 这
optimistic a cartridge whole again this

1272
00:46:56,060 --> 00:47:00,380
很令人困惑，因为时间戳排序
is confusing because time stamp ordering

1273
00:47:00,380 --> 00:47:02,540
协议是自己的或
protocols are by themselves or

1274
00:47:02,540 --> 00:47:04,460
乐观的方案 但是
optimistic schemes but there is a

1275
00:47:04,460 --> 00:47:05,540
这个数字有一个协议称为
protocol to this figure called the

1276
00:47:05,540 --> 00:47:09,349
Optima 安全协议方案 好吧
Optima secure protocol scheme alright so

1277
00:47:09,349 --> 00:47:12,140
这里的基本想法是，就像
the basic idea here is that like touch

1278
00:47:12,140 --> 00:47:16,790
触摸边界一样，就像时间
the border all right just late like time

1279
00:47:16,790 --> 00:47:19,520
看到我在那里订购一样，我们将
see I'm ordering there we're gonna

1280
00:47:19,520 --> 00:47:21,530
维护一个私人工作区，我们
maintain a private workspace we're gonna

1281
00:47:21,530 --> 00:47:23,660
将所有读取的数据复制到其中，以便
copy all the read data into it so that

1282
00:47:23,660 --> 00:47:25,730
我们返回并读取相同的记录 您
we go back and read same record you get

1283
00:47:25,730 --> 00:47:27,680
获得相同的值，我们还将
the same value we're also going to write

1284
00:47:27,680 --> 00:47:29,359
所有更改写入该私有
all our changes into that private

1285
00:47:29,359 --> 00:47:31,250
工作区，因此现在当
workspace as well so now when a

1286
00:47:31,250 --> 00:47:32,900
事务提交时，我们会
transaction commits we get the verify

1287
00:47:32,900 --> 00:47:34,880
验证没有冲突，如果没有，
that there's no conflicts and if not

1288
00:47:34,880 --> 00:47:36,740
我们可以 继续将它们安装
then we can go ahead and install them to

1289
00:47:36,740 --> 00:47:40,430
到全局数据库中，因此 OCC 是一个旧的旧
the global database so OCC is an old old

1290
00:47:40,430 --> 00:47:43,099
协议，因为您最常得出的结论
protocol as you most most conclude your

1291
00:47:43,099 --> 00:47:46,430
是基本的协议是旧的，这个
protocols the basic ones are old this

1292
00:47:46,430 --> 00:47:48,290
可以追溯到 1981 年，实际上是
one goes back to 1981 and actually was

1293
00:47:48,290 --> 00:47:49,730
由 HT Cohn 教授在卡内基梅隆发明的
invented here at Carnegie Mellon by

1294
00:47:49,730 --> 00:47:52,760
HT Kong 不是 更久
Professor HT Cohn HT Kong is no longer

1295
00:47:52,760 --> 00:47:56,089
了，他现在在哈佛，他
here he's now at Harvard and he's not

1296
00:47:56,089 --> 00:47:57,470
甚至不是 Dana 的教授，他不懂
even a Dana's professor he didn't know

1297
00:47:57,470 --> 00:47:59,450
网络，但这有点像他
networking but this is sort of like his

1298
00:47:59,450 --> 00:48:01,250
最著名的工作实际上是一篇数据库
most famous work is actually a databases

1299
00:48:01,250 --> 00:48:03,020
论文，所以这有点酷，这是
paper so that's kind of cool this came

1300
00:48:03,020 --> 00:48:03,620
从 CMU 的计算机系出来的，
out of the computer

1301
00:48:03,620 --> 00:48:07,250
所以 这是一个
department here at CMU so here's the

1302
00:48:07,250 --> 00:48:08,960
简单的事务是在
simple transaction was to read on a on

1303
00:48:08,960 --> 00:48:11,240
写入时读取，在写入时读取，然后
write on read on a write on a and write

1304
00:48:11,240 --> 00:48:14,810
在 B 上写入，因此在我们的数据库中，现在我们
on B so in our database now we don't

1305
00:48:14,810 --> 00:48:16,070
不需要记录的读取时间戳字段，
need the read time stamp field for

1306
00:48:16,070 --> 00:48:17,330
我们只需要写入
records we only have to have the write

1307
00:48:17,330 --> 00:48:19,880
时间戳字段和 所以现在当我们的
time stamp field and so now when our

1308
00:48:19,880 --> 00:48:21,890
交易开始时与基本的
transaction starts unlike in basic time

1309
00:48:21,890 --> 00:48:23,600
时间戳登机协议不同，我们
stamp boarding protocol we're not gonna

1310
00:48:23,600 --> 00:48:25,610
实际上不会为它分配一个时间戳，
actually gonna assign it a time stamp

1311
00:48:25,610 --> 00:48:27,260
我们稍后会这样做，
we're gonna do that later

1312
00:48:27,260 --> 00:48:29,120
所以每当我们要读写
so any time we're gonna read and write

1313
00:48:29,120 --> 00:48:31,160
东西时，我们都会制作一个副本 将其
stuff we're gonna make a copy of it in

1314
00:48:31,160 --> 00:48:33,920
放入公关 ivate 工作区并将其设置
into a private workspace and set it with

1315
00:48:33,920 --> 00:48:38,000
为无穷大的类型，因此 OCC 有三个
the types of infinity so OCC has three

1316
00:48:38,000 --> 00:48:41,300
阶段，因此不幸的是，第一个阶段
phases so the first one unfortunately is

1317
00:48:41,300 --> 00:48:42,560
称为读取阶段，因此即使
called the read phase so even though

1318
00:48:42,560 --> 00:48:45,350
我们要执行权限，这
we're gonna do rights and this this for

1319
00:48:45,350 --> 00:48:46,670
无论出于何种原因，他们
whatever reason the this they call this

1320
00:48:46,670 --> 00:48:50,150
称之为读取阶段 如果我有
the read phase of a transaction if I had

1321
00:48:50,150 --> 00:48:51,620
我选择的应用程序，我会将其称为
my choice app I would call this like the

1322
00:48:51,620 --> 00:48:53,330
运行阶段或执行阶段，我
run phase or in the execute phase I

1323
00:48:53,330 --> 00:48:55,610
认为无论出于何种
think that makes more sense for whatever

1324
00:48:55,610 --> 00:48:57,680
原因将其称为读取阶段都更有意义，因此
reason it's called the read phase so

1325
00:48:57,680 --> 00:48:59,390
我们将再次在 B 阶段对此处进行读取
again we're gonna do a read on a here in

1326
00:48:59,390 --> 00:49:02,200
所以我们将不得不
the B phase so we're gonna have to copy

1327
00:49:02,200 --> 00:49:05,630
将该记录和全局数据库复制到
that record and the global database into

1328
00:49:05,630 --> 00:49:08,810
我们的私人工作空间中，这样我们
our private work space so that again we

1329
00:49:08,810 --> 00:49:10,010
就可以总是以相同的值一遍又一遍地读取这个东西，
can always read this thing over and over

1330
00:49:10,010 --> 00:49:12,770
所以现在当
again at the same value so now when we

1331
00:49:12,770 --> 00:49:15,170
我们在写上写时，我们不是 将
do on write on a write we're not gonna

1332
00:49:15,170 --> 00:49:16,610
修改全局数据库我们将
modify the global database we're gonna

1333
00:49:16,610 --> 00:49:19,550
修改私有工作区中的数据库，因此
modify the one in a private workspace so

1334
00:49:19,550 --> 00:49:21,380
我们还没有写入时间戳，
we don't have a write time stamp yet

1335
00:49:21,380 --> 00:49:23,390
因为我们还没有被分配一个，所以
because we haven't been assigned one so

1336
00:49:23,390 --> 00:49:25,160
我们将在我们的工作区中将其设置为无穷大
we're just gonna set that to an infinity

1337
00:49:25,160 --> 00:49:26,840
然后
in our workspace and then update the

1338
00:49:26,840 --> 00:49:29,960
在这里更新 B 上的相同值 nna
value same thing on B here we're gonna

1339
00:49:29,960 --> 00:49:32,000
首先将它从全局数据库复制
first copy it from the global database

1340
00:49:32,000 --> 00:49:34,100
到我们的私有工作区，然后
into our private workspace and then

1341
00:49:34,100 --> 00:49:35,990
使用我们的无限时间戳
update it with our infinity timestamp

1342
00:49:35,990 --> 00:49:40,400
和我们的新值更新它，所以现在当我们的
and the in our new value so now when our

1343
00:49:40,400 --> 00:49:42,140
事务提交时，它
transaction goes to commit it's not

1344
00:49:42,140 --> 00:49:44,390
实际上不会立即提交，
actually gonna commit right away there's

1345
00:49:44,390 --> 00:49:46,250
不会有两个额外的
not gonna be two additional phases the

1346
00:49:46,250 --> 00:49:49,310
验证阶段 写入阶段的阶段，
validate phase in the write phase and so

1347
00:49:49,310 --> 00:49:50,810
因此验证阶段基本上是
the validate phase is basically where

1348
00:49:50,810 --> 00:49:51,910
我们要查看私有工作区的
we're gonna look at a private workspace

1349
00:49:51,910 --> 00:49:54,920
地方，看看我们修改了哪些记录
see what see what what records we

1350
00:49:54,920 --> 00:49:57,800
，然后查看是否
modified and go to see whether that

1351
00:49:57,800 --> 00:50:01,520
would by whether there's any there's

1352
00:50:01,520 --> 00:50:04,130
有任何交易
there's either transactions that are

1353
00:50:04,130 --> 00:50:05,810
仍在运行，但是 已经阅读了这些数据
still running but have read this data

1354
00:50:05,810 --> 00:50:06,830
，因此他们没有看到我们的
and therefore they didn't see our

1355
00:50:06,830 --> 00:50:07,940
更新，因为有一个私人
updates because there was in a private

1356
00:50:07,940 --> 00:50:11,240
工作区或
workspace or there's transactions in the

1357
00:50:11,240 --> 00:50:13,070
过去我已经提交的事务
past that I've already committed that

1358
00:50:13,070 --> 00:50:15,860
已经修改了这些，因此我们
have modified this and therefore we

1359
00:50:15,860 --> 00:50:17,930
实际上并没有很好地看到他们的
didn't actually see their changes

1360
00:50:17,930 --> 00:50:19,460
更改，因此我们 会有
well and therefore we would have a

1361
00:50:19,460 --> 00:50:21,170
冲突，所以要么你在做向后验证，要么
conflict so that's either you're doing

1362
00:50:21,170 --> 00:50:22,339
backwards validation a forward

1363
00:50:22,339 --> 00:50:24,770
再次向前验证，我们在介绍类中
validation again we covered that in the

1364
00:50:24,770 --> 00:50:26,089
介绍了它不是真实的
introduction class it's not really

1365
00:50:26,089 --> 00:50:27,859
现在很重要，但基本的想法
important right now but basic idea is

1366
00:50:27,859 --> 00:50:29,180
就像你一样，你要确保
like you and you're making sure that

1367
00:50:29,180 --> 00:50:31,190
事务总是
transactions are always committing sort

1368
00:50:31,190 --> 00:50:34,700
以正确的顺序提交，所以如果我们通过
of in the right order so if we pass the

1369
00:50:34,700 --> 00:50:36,740
验证阶段没有冲突，那么
validate phase there's no conflicts then

1370
00:50:36,740 --> 00:50:39,550
我们现在进入正确的阶段，我们
we now enter the right phase where we

1371
00:50:39,550 --> 00:50:41,780
现在最终被分配 一个时间戳
now are finally assigned a time stamp

1372
00:50:41,780 --> 00:50:43,910
，然后我们
and then we update the global database

1373
00:50:43,910 --> 00:50:45,800
使用我们从私有工作区所做的更改更新全局数据库，
with our changes that we've made from

1374
00:50:45,800 --> 00:50:47,510
而不使用我们的
our private workspace with out with our

1375
00:50:47,510 --> 00:50:49,880
新时间戳，然后在这
new time stamp and then and then at this

1376
00:50:49,880 --> 00:50:51,200
一点上，事务被认为已经
point that transactions considered be

1377
00:50:51,200 --> 00:51:00,950
完成，它会进行并提交，所以一个
done and it goes and commits so the one

1378
00:51:00,950 --> 00:51:02,119
重要的 需要理解的
important thing to understand about this

1379
00:51:02,119 --> 00:51:05,990
是，当真正没有任何
is that when there's not really any

1380
00:51:05,990 --> 00:51:09,050
争用时，像 OCC 这样的乐观
contention then the optimistic schemes

1381
00:51:09,050 --> 00:51:11,030
方案实际上
like OCC are actually performing better

1382
00:51:11,030 --> 00:51:14,990
比两阶段锁定执行得更好，因为因为我们
than two-phase locking because since we

1383
00:51:14,990 --> 00:51:16,880
假设冲突很少，所以我们
assume that the conflicts are rare we're

1384
00:51:16,880 --> 00:51:17,960
将花更少的时间检查
gonna spend less time checking for

1385
00:51:17,960 --> 00:51:20,240
复杂的权利。
complex right we spend less time looking

1386
00:51:20,240 --> 00:51:23,089
寻找实际不存在的冲突的时间更少，
for for for conflicts that don't

1387
00:51:23,089 --> 00:51:24,920
这有点像在
actually exist it's sort of like in the

1388
00:51:24,920 --> 00:51:26,720
不和谐系统中，如果一切都
discordian system where if everything

1389
00:51:26,720 --> 00:51:28,400
适合内存，那么我们就会浪费
fits in memory then we're gonna waste

1390
00:51:28,400 --> 00:51:31,579
时间 我正在寻找您知道我们
time looking you know to see whether we

1391
00:51:31,579 --> 00:51:33,400
是否必须驱逐某些东西以在
have to evict something to make space in

1392
00:51:33,400 --> 00:51:36,349
我们的缓冲池管理器中腾出空间，
our buffer pool manager all right so

1393
00:51:36,349 --> 00:51:37,730
所以最好乐观地
it's better off just to optimistically

1394
00:51:37,730 --> 00:51:39,260
假设一切都适合和内存并
assume everything fits and memory and

1395
00:51:39,260 --> 00:51:41,950
正确跳转以获取并获得我们需要的东西，
jump right to get and get what we need

1396
00:51:41,950 --> 00:51:44,150
但问题可能是现在 高
but the issues can be now with high

1397
00:51:44,150 --> 00:51:45,619
争用我的意思是我们有很多
contention I mean we have a lot of

1398
00:51:45,619 --> 00:51:47,390
事务试图读取和
transactions trying to tend to read and

1399
00:51:47,390 --> 00:51:50,780
写入相同的记录然后
write to the same records then all the

1400
00:51:50,780 --> 00:51:52,220
我刚刚谈到的所有协议
protocols that I've just talked about

1401
00:51:52,220 --> 00:51:54,020
本质上都将退化
are essentially going to degenerate down

1402
00:51:54,020 --> 00:51:56,780
为只是事务的串行执行
to just being the serial execution of

1403
00:51:56,780 --> 00:51:58,700
意味着只有一个
transactions meaning only one

1404
00:51:58,700 --> 00:52:00,770
事务可以同时运行，我们
transaction can run at a time we're

1405
00:52:00,770 --> 00:52:03,260
将浪费所有这些额外的额外这些
gonna waste all this extra extra these

1406
00:52:03,260 --> 00:52:05,359
额外花费大量时间在我们的
extra spend a lot of time in our

1407
00:52:05,359 --> 00:52:07,760
协议上做基本上
protocols doing work that's essentially

1408
00:52:07,760 --> 00:52:09,079
无用的工作，因为我们
useless because we're transactions are

1409
00:52:09,079 --> 00:52:12,470
永远无法提交事务，因此为了
never gonna be able to commit so to

1410
00:52:12,470 --> 00:52:14,839
更好地理解这个问题，这是
better understand this issue this is

1411
00:52:14,839 --> 00:52:16,760
你们读的这篇论文是
what this the paper had you guys read is

1412
00:52:16,760 --> 00:52:18,680
关于什么的所以这是
about so this is a start the idea with a

1413
00:52:18,680 --> 00:52:22,400
我以前的学生的一个想法，他现在是
former student of mine who is now a new

1414
00:52:22,400 --> 00:52:23,690
威斯康星大学的新数据，
data to fester at the university

1415
00:52:23,690 --> 00:52:26,780
我们做了几年 去
Wisconsin we did a few years ago where

1416
00:52:26,780 --> 00:52:29,359
我们实现了一个允许评估不同的测试平台系统的地方，
we implemented a testbed system that

1417
00:52:29,359 --> 00:52:31,610
allows to evaluate different

1418
00:52:31,610 --> 00:52:33,260
你的协议不是具有丰富的绿色
aren't your protocols that rich green

1419
00:52:33,260 --> 00:52:36,530
并行性水平，所以
levels of parallelism and so it's kind

1420
00:52:36,530 --> 00:52:37,790
这个项目可能是一种阴谋，而
of intrigue might this project is rather

1421
00:52:37,790 --> 00:52:39,590
不是像我的续集
than taking like post grass on my sequel

1422
00:52:39,590 --> 00:52:40,250
或任何
or whatever

1423
00:52:40,250 --> 00:52:41,900
你想要并尝试的戴维森一样
Davison you want and trying to do a

1424
00:52:41,900 --> 00:52:44,330
在他们两个之间做一个烘焙我们
bake-off between the two of them we

1425
00:52:44,330 --> 00:52:45,620
实现了一个单一的系统，它有
implemented a single system that had a

1426
00:52:45,620 --> 00:52:47,510
一个可插拔的 API，允许在
pluggable API that allows a plop in

1427
00:52:47,510 --> 00:52:50,240
不同的文化协议中扑通一声，而不
different cultural protocols without

1428
00:52:50,240 --> 00:52:52,430
会对系统的其余部分进行重大更改，
making major changes to the rest of the

1429
00:52:52,430 --> 00:52:54,770
这里的想法是我们想要
system and the idea here is that we want

1430
00:52:54,770 --> 00:52:57,440
将其剥离 只是作为在数据库系统
to strip it down to just being the bare

1431
00:52:57,440 --> 00:52:59,480
中执行事务所需的最低限度，
minimum you need to execute transactions

1432
00:52:59,480 --> 00:53:01,430
而没有所有
in a database system without all the

1433
00:53:01,430 --> 00:53:02,540
额外的花里胡哨和
additional bells and whistles and

1434
00:53:02,540 --> 00:53:04,210
功能，这些功能还没有像普雷斯科特这样的
features that are yet that a

1435
00:53:04,210 --> 00:53:06,200
全功能系统可能
full-featured system like might see what

1436
00:53:06,200 --> 00:53:08,120
会看到的我们只关注
Prescott's would have we just focus on

1437
00:53:08,120 --> 00:53:09,230
这些开销是什么
what the overhead is of these

1438
00:53:09,230 --> 00:53:10,600
协议的并发性，
concurrency of protocols

1439
00:53:10,600 --> 00:53:13,730
所以我们的想法是我们想要
so the idea also to was that we want to

1440
00:53:13,730 --> 00:53:16,730
run this you know this these systems in

1441
00:53:16,730 --> 00:53:21,980
在高度并行的环境中运行这些系统，以便
a highly parallel environment so that it

1442
00:53:21,980 --> 00:53:24,260
它真正展示 作为系统中
would sort of really exposed as the in

1443
00:53:24,260 --> 00:53:25,910
不同协议实现的主要瓶颈
what the main bottlenecks are in the

1444
00:53:25,910 --> 00:53:27,110
implementations of the different

1445
00:53:27,110 --> 00:53:29,690
，
protocols in the system in a way that

1446
00:53:29,690 --> 00:53:30,860
您可能无法在
you couldn't get maybe running on a

1447
00:53:30,860 --> 00:53:33,290
32 核或 64 核之类的机器上运行，这
machine like 32 cores or 64 cores which

1448
00:53:33,290 --> 00:53:35,330
是您这次最多可以解决的问题
is so the most you can get around this

1449
00:53:35,330 --> 00:53:39,680
在 2014 年我们写这篇论文的
time in 2014 when we wrote this paper so

1450
00:53:39,680 --> 00:53:41,330
时候，我们将用于这次
the system we're gonna use for this

1451
00:53:41,330 --> 00:53:44,780
评估的系统称为 DB X 1000 所以这
evaluation is called DB X 1000 so this

1452
00:53:44,780 --> 00:53:46,820
又是学生
was again the system that the student

1453
00:53:46,820 --> 00:53:49,370
为这篇论文编写的系统，然后它是
wrote for this paper and then it was

1454
00:53:49,370 --> 00:53:51,380
从头开始编写的，只是为了让这个
written from scratch just to have this

1455
00:53:51,380 --> 00:53:53,720
可插入的 API 允许 您可以
pluggable API allows you to plop that

1456
00:53:53,720 --> 00:53:55,910
在这些并发协议的不同实现中添加该下降，
drop in different implementations of

1457
00:53:55,910 --> 00:53:58,220
因此它是
these concurrent your protocols so it's

1458
00:53:58,220 --> 00:53:59,690
一个精简的系统，没有
a stripped-down system there's no

1459
00:53:59,690 --> 00:54:01,790
网络访问，
network access there's no logging at

1460
00:54:01,790 --> 00:54:02,960
至少在我们撰写本文时没有日志记录，
least at the time that we were at this

1461
00:54:02,960 --> 00:54:04,790
并且过时的支持并发
paper and a dated support concurrent

1462
00:54:04,790 --> 00:54:06,740
索引它确实只是关注
indexes it really was just focusing on

1463
00:54:06,740 --> 00:54:08,540
您转换协议的速度有多快？
how fast can you do convert your

1464
00:54:08,540 --> 00:54:11,570
所有事务都将
protocols all the transactions are going

1465
00:54:11,570 --> 00:54:13,100
通过存储过程执行，
to execute with store procedures and so

1466
00:54:13,100 --> 00:54:15,230
这意味着
that means all the server-side logic in

1467
00:54:15,230 --> 00:54:17,120
执行事务的所有服务器端逻辑都
order to execute a transaction is

1468
00:54:17,120 --> 00:54:19,130
包含在 th 上 数据系统本身，
contained on on the data system itself

1469
00:54:19,130 --> 00:54:21,080
所以你永远不会通过网络谈论它们，
so you never talk about them over the

1470
00:54:21,080 --> 00:54:22,970
并询问客户的应用程序，
network and ask the application of the

1471
00:54:22,970 --> 00:54:24,470
你知道我接下来应该做什么
client you know what should I do next

1472
00:54:24,470 --> 00:54:27,440
，所以我们现在也将在
and so we're gonna run this now also in

1473
00:54:27,440 --> 00:54:32,690
由麻省理工学院开发的芯片模拟器中运行它，
a chip simulator developed by who at MIT

1474
00:54:32,690 --> 00:54:36,950
我的团队称为 石墨，这
added my team called graphite and this

1475
00:54:36,950 --> 00:54:39,410
是使用 Nuka 架构对基于单套接字表的 CPU 进行建模
was modeling a single socket table based

1476
00:54:39,410 --> 00:54:42,620
，因此 Nuka
CPU with a Nuka architecture so Nuka

1477
00:54:42,620 --> 00:54:44,890
代表非统一缓存行为
stands for non-uniform cache acts

1478
00:54:44,890 --> 00:54:47,290
，我们将其与 Neumann
and we contrast that with the Neumann

1479
00:54:47,290 --> 00:54:48,640
架构的非统一内存访问进行对比
architecture non-uniform memory access

1480
00:54:48,640 --> 00:54:50,590
，或者大部分将
that or mostly gonna be talking about

1481
00:54:50,590 --> 00:54:52,060
在学期中讨论，就像你一样 知道
during the semester in like you know

1482
00:54:52,060 --> 00:54:55,540
英特尔至强出货，所以 Nuka 基本上
Intel Xeon ships so Nuka basically means

1483
00:54:55,540 --> 00:55:00,670
意味着一个内核访问
that the cost of one core accessing the

1484
00:55:00,670 --> 00:55:03,700
另一个内核的缓存的成本并不
cache of another core is not always

1485
00:55:03,700 --> 00:55:05,590
总是相同的，因为它
going to be the same because it's gonna

1486
00:55:05,590 --> 00:55:07,090
会有这种基于 tile 的架构，
have this tile based architecture where

1487
00:55:07,090 --> 00:55:08,560
你必须通过这个网状网络进行通信，
you have to communicate over this mesh

1488
00:55:08,560 --> 00:55:11,740
你知道吗？ 缓存
network in order do you know cache

1489
00:55:11,740 --> 00:55:13,090
失效并
invalidation and do reason writes

1490
00:55:13,090 --> 00:55:14,860
在不同核心之间进行合理的写入，因此某些
between different cores and so some

1491
00:55:14,860 --> 00:55:16,570
核心在网络上离您更近
cores are closer to you on the network

1492
00:55:16,570 --> 00:55:18,760
，因此您的读取写入它们的
and therefore your reading writing their

1493
00:55:18,760 --> 00:55:22,120
内存位置或它们的缓存我
memory locations or their caches is much

1494
00:55:22,120 --> 00:55:23,710
比大陆清理网络另一端的速度要快得多，
faster than one that's mainland to clean

1495
00:55:23,710 --> 00:55:26,890
所以我
the other side of this network so I'm

1496
00:55:26,890 --> 00:55:30,130
并不是真正的架构师，
not really an architecture person the

1497
00:55:30,130 --> 00:55:31,540
我们之所以想要这种或基于图块
reason why we want with this or a tile

1498
00:55:31,540 --> 00:55:34,450
的方法是因为当您与
based approach is that when you talk to

1499
00:55:34,450 --> 00:55:36,550
架构专家交谈时，
people that are architecture experts

1500
00:55:36,550 --> 00:55:38,620
他们说 当你开始让
they said that when you start getting

1501
00:55:38,620 --> 00:55:42,160
他们喜欢一千个核心数
them to like a thousand core count sort

1502
00:55:42,160 --> 00:55:43,720
时，传统智慧是你
of the conventional wisdom is that you'd

1503
00:55:43,720 --> 00:55:45,220
想再次使用这样的基于表的架构，
want to use a table based architecture

1504
00:55:45,220 --> 00:55:47,950
我们
like this again the main takeaways we're

1505
00:55:47,950 --> 00:55:49,600
将从研究中获得的主要收获
gonna get from the study are not gonna

1506
00:55:49,600 --> 00:55:50,920
不会依赖于使用 基于 tile 的
be dependent on using a tile based

1507
00:55:50,920 --> 00:55:52,120
架构，它们仍然
architecture and they're still

1508
00:55:52,120 --> 00:55:54,340
适用于我们在本学期所讨论的 xeon 类型系统，
applicable to the xeon type system as we

1509
00:55:54,340 --> 00:55:56,140
这
talked about for the semester it's just

1510
00:55:56,140 --> 00:55:58,630
正是我们
is what the harbor was that we had at

1511
00:55:58,630 --> 00:56:00,790
当时用来建模的港口，所以另一个
the time to model this so another

1512
00:56:00,790 --> 00:56:01,960
需要理解的重要事情是
important thing to understand too is

1513
00:56:01,960 --> 00:56:04,060
这个 cpu 刺激器运行 真的
that this cpu stimulator runs really

1514
00:56:04,060 --> 00:56:06,550
真的很慢，好吧，它
really slow all right it's it's ten

1515
00:56:06,550 --> 00:56:08,320
比
thousand X slower than the wall clock

1516
00:56:08,320 --> 00:56:11,290
你知道的裸机系统的挂钟时间慢
time of a you know system running bare

1517
00:56:11,290 --> 00:56:13,720
一万倍，所以这意味着
metal so that means that there's a bunch

1518
00:56:13,720 --> 00:56:15,280
学生确实必须进行大量优化
of optimizations the student had to do

1519
00:56:15,280 --> 00:56:17,680
X 1  000 可以在模拟器中的
indeed X 1000 that get to run at a

1520
00:56:17,680 --> 00:56:19,870
合理时间运行，因此如果
reasonable time in the simulator so if

1521
00:56:19,870 --> 00:56:21,400
您查看 github 上的代码，您会
you go look at the code on github you'll

1522
00:56:21,400 --> 00:56:24,400
发现它们中有
find that there's a lot of them there's

1523
00:56:24,400 --> 00:56:25,780
很多在系统的不同部分中有很多程序集，
a lot of assembly in the different parts

1524
00:56:25,780 --> 00:56:27,430
因为他必须这样做
of the system because he had to do that

1525
00:56:27,430 --> 00:56:28,960
为了让它运行得快，她你
to get it to run run fast and her you

1526
00:56:28,960 --> 00:56:30,550
知道让经验
know get the experience to finish in

1527
00:56:30,550 --> 00:56:34,030
及时完成所以
time all right so the target workload

1528
00:56:34,030 --> 00:56:35,440
我们将用于本文的目标工作负载
we're gonna be using for this paper is

1529
00:56:35,440 --> 00:56:38,920
将是 y CS 是 W Yahoo Cloud
going to be y CS be W Yahoo Cloud

1530
00:56:38,920 --> 00:56:41,440
一些基准，所以它
something benchmark so the it's

1531
00:56:41,440 --> 00:56:43,420
基本上是一个 键值存储工作负载
basically a key value store workload

1532
00:56:43,420 --> 00:56:46,270
，这有点意味着模型
that's sort of meant the model the sort

1533
00:56:46,270 --> 00:56:51,190
是一种网络服务或基于网络的应用程序的 ESS 模式，
of ESS patterns of a web services or web

1534
00:56:51,190 --> 00:56:54,070
因此在数据库中将
based applications so in the database

1535
00:56:54,070 --> 00:56:55,360
有 200 万个元组，每个
there'd be two million tuples and each

1536
00:56:55,360 --> 00:56:58,779
元组是 1 KB，
tuple is is one kilobyte so every

1537
00:56:58,779 --> 00:57:00,959
因此我们要建模的每个事务
transaction that we're gonna model our

1538
00:57:00,959 --> 00:57:04,859
我们系统中的伊朗将执行
Iran in our system is gonna execute

1539
00:57:04,859 --> 00:57:06,640
查询，他们将一次读取和写入
queries they're gonna read and write

1540
00:57:06,640 --> 00:57:09,069
16 个不同的元组，
sixteen different tuples at a time and

1541
00:57:09,069 --> 00:57:11,109
我们将在访问模式中改变他们
we're gonna vary their access patterns

1542
00:57:11,109 --> 00:57:12,609
的访问模式，因此有时
excu in the access pattern so sometimes

1543
00:57:12,609 --> 00:57:13,839
它们会是热点，有时
they'll be hotspots and sometimes

1544
00:57:13,839 --> 00:57:16,209
它们会是统一的 访问和所有
they'll be uniform access and all the

1545
00:57:16,209 --> 00:57:17,559
事务将运行存储
transactions are so going to run a store

1546
00:57:17,559 --> 00:57:18,099
过程
procedure

1547
00:57:18,099 --> 00:57:19,449
存储过程运行可
store procedure is running the

1548
00:57:19,449 --> 00:57:23,529
序列化隔离级别，因此六种
serializable isolation level so the six

1549
00:57:23,529 --> 00:57:24,640
不同的方案将比较
different schemes are going to compare

1550
00:57:24,640 --> 00:57:27,459
或基于我之前谈到的不同类型的
or based on the the different type of

1551
00:57:27,459 --> 00:57:29,859
协议，因此
protocols that I talked about before so

1552
00:57:29,859 --> 00:57:31,569
对于两阶段锁定，将会有
for two phase locking there's gonna be

1553
00:57:31,569 --> 00:57:33,309
死锁检测 然后
deadlock detection and then deadlock

1554
00:57:33,309 --> 00:57:34,989
防止死锁，无需等待，等待和死亡
prevention with no wait and wait and die

1555
00:57:34,989 --> 00:57:37,659
，这是当今
and this is emblematic of sort of the

1556
00:57:37,659 --> 00:57:39,609
一些最大的数据库系统的象征，
some of the biggest database systems

1557
00:57:39,609 --> 00:57:42,640
现在在
that are out there today now in the time

1558
00:57:42,640 --> 00:57:44,319
时间戳订购方面有一个时间戳
stamp ordering side there's a time stamp

1559
00:57:44,319 --> 00:57:46,659
订购，有 FCC，有一个
ordering and there's FCC and there's a

1560
00:57:46,659 --> 00:57:49,630
多版本 在 1979 年的论文中存在或描述了原始的多
multi version there's the original multi

1561
00:57:49,630 --> 00:57:53,229
版本协议，
version protocol present or described in

1562
00:57:53,229 --> 00:57:55,659
该版本描述
the 1979 paper that version described

1563
00:57:55,659 --> 00:57:58,689
了使用时间戳的 MVCC 下一
MVCC that uses time stamp whirring next

1564
00:57:58,689 --> 00:57:59,979
课我们将看到您可以拥有
class we'll see that you can have

1565
00:57:59,979 --> 00:58:01,900
different variants of multi versioning

1566
00:58:01,900 --> 00:58:04,900
使用 OCC 或两相锁定的多版本控制的不同变体，但
that uses OCC or two phase locking but

1567
00:58:04,900 --> 00:58:06,819
对于这个，我们只是
for this one we just went with this sort

1568
00:58:06,819 --> 00:58:08,199
在 1970 年代的原始协议中采用了这种方式
of in the original protocol for posed in

1569
00:58:08,199 --> 00:58:10,809
，这是
the 1970s and this is emblematic about

1570
00:58:10,809 --> 00:58:13,719
大多数较新系统的象征 是的，
most of the newer systems today as well

1571
00:58:13,719 --> 00:58:15,519
还有一些
as some sort of classic database systems

1572
00:58:15,519 --> 00:58:19,299
使用多版本控制的经典数据库系统，所以对于
that use multi versioning alright so for

1573
00:58:19,299 --> 00:58:21,459
这里的第一个实验，这
the first experiment here this is sort

1574
00:58:21,459 --> 00:58:24,549
of the sort of the baseline performance

1575
00:58:24,549 --> 00:58:25,779
是这些不同协议和
of these different protocols and a

1576
00:58:25,779 --> 00:58:28,329
只读工作负载的基线性能，所以你看到
read-only workload so what you're seeing

1577
00:58:28,329 --> 00:58:30,789
的是 x 轴随着我们扩展
is that along the x-axis as we scale the

1578
00:58:30,789 --> 00:58:34,299
我们添加的内核数量，
number of cores we're adding work the

1579
00:58:34,299 --> 00:58:35,829
同时运行的并发事务越多，
more concurrent transactions running at

1580
00:58:35,829 --> 00:58:38,169
所以每次我们
the same time so every single time we

1581
00:58:38,169 --> 00:58:40,269
添加一个内核时，都会运行一个
added a core that's going to have an

1582
00:58:40,269 --> 00:58:42,069
额外的事务，
additional transaction running that's

1583
00:58:42,069 --> 00:58:44,019
你知道运行重要的执行
you know run important executing part of

1584
00:58:44,019 --> 00:58:47,890
部分 工作负载，因此 200 个内核同时有 200 个
the workload so 200 cores there's 200

1585
00:58:47,890 --> 00:58:50,739
当前事务，因此
current transactions at the same time so

1586
00:58:50,739 --> 00:58:52,119
这是具有
this is a read-only workload with

1587
00:58:52,119 --> 00:58:55,569
统一内存访问或元组访问的只读工作负载
uniform memory access or tuple access so

1588
00:58:55,569 --> 00:58:57,099
，这是这些
and this is the best that these

1589
00:58:57,099 --> 00:58:58,959
不同协议可以做的最好的事情，因为
different protocols can do because

1590
00:58:58,959 --> 00:59:01,749
存在零争用，所以
there's there's zero contention so the

1591
00:59:01,749 --> 00:59:03,819
我们看到的第一件事 死锁
first thing we see is that the deadlock

1592
00:59:03,819 --> 00:59:05,880
检测和无等待协议
detection and the no wait protocols

1593
00:59:05,880 --> 00:59:09,039
实际上几乎可以线性扩展并
actually can almost scale linearly and

1594
00:59:09,039 --> 00:59:11,229
表现最佳，因为这些协议
perform the best because these protocols

1595
00:59:11,229 --> 00:59:12,610
非常简单，没有
are so simple there's no

1596
00:59:12,610 --> 00:59:14,740
锁和 因此，
locks and therefore the overhead of

1597
00:59:14,740 --> 00:59:17,430
事务和执行的开销是心理上的，
transactions and executing is mental

1598
00:59:17,430 --> 00:59:19,480
接下来你看到的是
next thing you see is that there's me

1599
00:59:19,480 --> 00:59:23,500
我在八百辆车旁等待
here at eight hundred cars where wait

1600
00:59:23,500 --> 00:59:25,780
和死亡，MVCC 开始下降
and die and MVCC start start to dip down

1601
00:59:25,780 --> 00:59:28,180
，这是由于为事务分配唯一时间戳的开销，
and this is due to the overhead of

1602
00:59:28,180 --> 00:59:29,830
allocating unique time stamps for

1603
00:59:29,830 --> 00:59:31,600
因为它们“
transactions as they're running right

1604
00:59:31,600 --> 00:59:33,100
当您同时运行 100 万个
when you're running with a million

1605
00:59:33,100 --> 00:59:34,120
事务时，
transactions at the running the same

1606
00:59:34,120 --> 00:59:36,160
或者当您每秒运行 800
time or when you're running eight

1607
00:59:36,160 --> 00:59:38,110
万个事务时，这个
million transactions a second for this

1608
00:59:38,110 --> 00:59:39,460
基于表的架构在
table based architecture at the time

1609
00:59:39,460 --> 00:59:40,810
时间戳分配和跨
stamp allocation and coordinating across

1610
00:59:40,810 --> 00:59:41,980
所有不同线程的协调成为
all the different threads becomes a

1611
00:59:41,980 --> 00:59:45,670
瓶颈时重新运行 最后你看到
bottleneck and lastly you see that OCC

1612
00:59:45,670 --> 00:59:47,590
这里的 OCC 实际上是最糟糕的，所以这
here actually does the worst and so this

1613
00:59:47,590 --> 00:59:50,410
是必须
is a combination of of having to copy

1614
00:59:50,410 --> 00:59:52,690
为每个事务复制私有工作区
the private workspace for every single

1615
00:59:52,690 --> 00:59:54,130
并将其复制回
transaction and copy that back into the

1616
00:59:54,130 --> 00:59:56,170
系统的组合，这实际上是一个很大的
system that actually comes a big

1617
00:59:56,170 --> 01:00:00,130
瓶颈，所以接下来我们看到这里是
bottleneck so next we see here is a

1618
01:00:00,130 --> 01:00:01,420
写入密集型 您知道
write intensive workload where you know

1619
01:00:01,420 --> 01:00:02,950
我有事务实际
I have transactions actually updating

1620
01:00:02,950 --> 01:00:04,840
更新数据库的工作负载，这是在中等
the database and this is on a medium

1621
01:00:04,840 --> 01:00:06,820
或有工作负载的情况下，其中 60% 的
contingent workload where 60% of

1622
01:00:06,820 --> 01:00:08,260
事务是 将尝试访问
transactions are going to try to access

1623
01:00:08,260 --> 01:00:11,920
数据库的 20% 的热点，因此
a hot spot of 20% of the database so the

1624
01:00:11,920 --> 01:00:12,730
您需要看到的第一件事是，
first thing you need to see is that

1625
01:00:12,730 --> 01:00:14,770
死锁检测实际上现在是
deadlock detection is actually now the

1626
01:00:14,770 --> 01:00:17,380
用于这种未命中环境的最差协议，
worst protocol used for this miss

1627
01:00:17,380 --> 01:00:19,120
您在上一张幻灯片中知道我
environment you know in the last slide I

1628
01:00:19,120 --> 01:00:20,920
向您展示的实际上是 最好但是
showed you to was actually the best but

1629
01:00:20,920 --> 01:00:22,570
现在当你对更高的山争用有很高的内容时，就会
now when you have high content to higher

1630
01:00:22,570 --> 01:00:26,190
出现死锁，系统中会有更多的死锁
mountain contention there's deadlocks

1631
01:00:26,190 --> 01:00:28,210
there's more dead locks in the system

1632
01:00:28,210 --> 01:00:29,770
，因此
and therefore it takes longer for the

1633
01:00:29,770 --> 01:00:31,270
死锁检测线程需要更长
deadlock detection thread to come around

1634
01:00:31,270 --> 01:00:33,370
的时间来解决这些死锁，所以你发送给
and break these dead locks so you sent

1635
01:00:33,370 --> 01:00:34,960
你的线程被盗并等待
you have threads stolen and waiting for

1636
01:00:34,960 --> 01:00:36,670
它 死锁检测威胁来解决
that deadlock detection threat to come

1637
01:00:36,670 --> 01:00:38,500
并清理事情，
through and clean things up and that

1638
01:00:38,500 --> 01:00:43,260
接下来会损害性能你看到
hurts performance next you see that the

1639
01:00:43,260 --> 01:00:45,880
没有等待和等待我实际上做得
no wait and wait I actually do the best

1640
01:00:45,880 --> 01:00:47,530
最好，这是因为这些
all right and this is because these

1641
01:00:47,530 --> 01:00:50,620
协议非常简单所以正在发生的
protocols are so simple so what's

1642
01:00:50,620 --> 01:00:53,410
事情是你知道
happening is that the you know yes

1643
01:00:53,410 --> 01:00:56,350
是的，随时都有 存在冲突，
there's anytime there's a conflict and

1644
01:00:56,350 --> 01:00:58,240
这些
there would be a deadlock these

1645
01:00:58,240 --> 01:00:59,920
协议会立即陷入僵局，只需终止
protocols immediately just kill the

1646
01:00:59,920 --> 01:01:01,810
事务以重新启动它们，这样您就
transaction to restart them so you don't

1647
01:01:01,810 --> 01:01:03,760
不会浪费时间尝试进行处理
spend any wasted time trying to figure

1648
01:01:03,760 --> 01:01:06,300
你知道我应该等待还是你知道
out you know should I wait or you know

1649
01:01:06,300 --> 01:01:08,200
希望另一笔交易可以
hoping the other transaction could give

1650
01:01:08,200 --> 01:01:10,150
放弃一个槽你立即采取一些行动
up a slot you make some action right

1651
01:01:10,150 --> 01:01:10,420
away

1652
01:01:10,420 --> 01:01:12,100
不等待最简单的写
no waits the simplest one writes

1653
01:01:12,100 --> 01:01:13,720
基本上说我试图获得我的交易
basically says I try to acquire my trans

1654
01:01:13,720 --> 01:01:15,730
块我无法立即杀死
block I couldn't get it immediately kill

1655
01:01:15,730 --> 01:01:17,680
我自己 再次因为我们通过癫痫存储，
myself and again because we're store by

1656
01:01:17,680 --> 01:01:19,540
没有
seizures there's no overhead of

1657
01:01:19,540 --> 01:01:21,280
重新启动事务的开销，并且在内存
restarting transaction and in a memory

1658
01:01:21,280 --> 01:01:23,680
环境中它
environment it's super fast

1659
01:01:23,680 --> 01:01:25,810
在中间非常快，在这里您可以看到
all right in the middle here you see the

1660
01:01:25,810 --> 01:01:28,750
三个时间戳警告协议基本
three timestamp warning protocols basic

1661
01:01:28,750 --> 01:01:31,420
tio MVCC 和 OCC 它们大致都
tio MVCC and OCC they're roughly all

1662
01:01:31,420 --> 01:01:33,640
在做相同的 CCS 的运行速度
doing about the same of CCS doing slower

1663
01:01:33,640 --> 01:01:35,320
再次变慢，因为将东西一遍又一遍地
again because there's extra overhead of

1664
01:01:35,320 --> 01:01:37,540
复制到您所知道的工作空间内外的工作中会产生额外的开销，
copying things into the work you know in

1665
01:01:37,540 --> 01:01:38,980
and out of the work space over and over

1666
01:01:38,980 --> 01:01:42,040
但您知道它们
again but you know they're roughly about

1667
01:01:42,040 --> 01:01:46,690
大致相同，所以现在我们在这里得到最后一张
the same so now we get to this final

1668
01:01:46,690 --> 01:01:47,890
图，这是最多的 重要
graph here which is the most important

1669
01:01:47,890 --> 01:01:49,870
的一篇论文，这是我们
one of the paper and this is where we're

1670
01:01:49,870 --> 01:01:51,370
运行写入系统工作负载的地方，其中
running a writing system workload where

1671
01:01:51,370 --> 01:01:54,130
90% 的事务正在更新 10%
90% of the transactions are updating 10%

1672
01:01:54,130 --> 01:01:56,440
的数据库，所以现在您看到
of the database so now you see that all

1673
01:01:56,440 --> 01:01:58,210
所有协议基本上都崩溃了
the protocol is basically crashed down

1674
01:01:58,210 --> 01:02:00,790
当我们达到一千个内核时，n 为零
to zero when we get up to a thousand

1675
01:02:00,790 --> 01:02:03,100
好吧，这些
cores okay there's none of these

1676
01:02:03,100 --> 01:02:06,190
协议实际上都没有扩展缝纫
protocols were actually scaling sewing

1677
01:02:06,190 --> 01:02:07,570
，原因是这是所有这些
and the reason is that this is all this

1678
01:02:07,570 --> 01:02:09,910
事务必须
overhead of transactions having to check

1679
01:02:09,910 --> 01:02:12,010
检查冲突或复制东西的开销，而且
for conflicts or copy things around and

1680
01:02:12,010 --> 01:02:13,720
冲突太多了，你只是
there's so many conflicts that you just

1681
01:02:13,720 --> 01:02:15,280
不能让你知道进展
can't make any for you know for progress

1682
01:02:15,280 --> 01:02:18,040
和完成事情，所以一件
and get things completed so one

1683
01:02:18,040 --> 01:02:20,290
有趣的事情是，你看到没有
interesting thing is that you see no

1684
01:02:20,290 --> 01:02:23,430
等待相对于其他协议进行得很好
wait is kind of going along doing okay

1685
01:02:23,430 --> 01:02:26,260
，直到
relative to the other protocols until

1686
01:02:26,260 --> 01:02:28,360
800 个线程，然后它崩溃到
800 threads and then it crashes down to

1687
01:02:28,360 --> 01:02:31,630
零，所以它没有做
zero so it's not doing that great

1688
01:02:31,630 --> 01:02:33,400
与以前的生活相比，这很棒，我认为它
compared to the previous life think it's

1689
01:02:33,400 --> 01:02:35,110
only executing 200,000 transactions a

1690
01:02:35,110 --> 01:02:37,480
每秒只执行 200,000 个事务，而我正在分享的另一个切片是
second where's the other slice I was

1691
01:02:37,480 --> 01:02:38,500
你每秒可以执行数百万个
sharing you can do millions of

1692
01:02:38,500 --> 01:02:41,350
事务，但它再次运行良好，
transactions a second but again it's

1693
01:02:41,350 --> 01:02:43,090
因为它的
it's doing okay because it's it's

1694
01:02:43,090 --> 01:02:45,880
协议非常简单，是的，
protocol is so simple that yes there's

1695
01:02:45,880 --> 01:02:47,950
当 系统识别出
no way when the system identifies that

1696
01:02:47,950 --> 01:02:49,840
将会出现死锁，它会
there's going to be a deadlock it kills

1697
01:02:49,840 --> 01:02:51,780
立即终止交易，然后重新
the transaction immediately restarts it

1698
01:02:51,780 --> 01:02:54,970
启动其他交易，并且
where's the other ones and they cost of

1699
01:02:54,970 --> 01:02:56,320
这样做的成本非常低 相对于
doing that is super cheap relative the

1700
01:02:56,320 --> 01:02:58,270
其他的，当然现在有一千个
other ones of course now at a thousand

1701
01:02:58,270 --> 01:03:02,710
核心，这样做只是你只是进行
cores doing that just you just go

1702
01:03:02,710 --> 01:03:04,240
大量的交易，以至于你
boarding transactions so much that you

1703
01:03:04,240 --> 01:03:06,540
无法完成任何
can't get any work done

1704
01:03:06,540 --> 01:03:08,800
工作 另一件有趣的
the other interesting thing to point out

1705
01:03:08,800 --> 01:03:11,950
事情要指出的是，
is that OCC is actually the worst over

1706
01:03:11,950 --> 01:03:13,270
当你有一个 核心数量很少，
here when you have a small number of

1707
01:03:13,270 --> 01:03:15,580
但另一方面实际上
cores but on the other side is actually

1708
01:03:15,580 --> 01:03:18,250
做得最好，这又是
doing the best and again this is what

1709
01:03:18,250 --> 01:03:19,810
因为它基本上是向下生成
because it's basically des generating

1710
01:03:19,810 --> 01:03:21,490
以进行用户执行
down to do user execution of

1711
01:03:21,490 --> 01:03:25,450
交易，因此协议的
transactions so the way the protocol

1712
01:03:25,450 --> 01:03:26,950
工作方式是，当您进入
works is that when you enter the

1713
01:03:26,950 --> 01:03:28,510
验证阶段时，您可以
validation phase you can guarantee that

1714
01:03:28,510 --> 01:03:30,730
保证 事务处于那个验证
one transaction is in that validation

1715
01:03:30,730 --> 01:03:32,470
阶段，因此总是
phase and therefore one always always be

1716
01:03:32,470 --> 01:03:34,450
允许实际提交，所以当
allowed to actually commit so when

1717
01:03:34,450 --> 01:03:36,250
你基本上在这里运行
you're essentially running here at a

1718
01:03:36,250 --> 01:03:37,630
一千个线程时
thousand thread

1719
01:03:37,630 --> 01:03:40,570
，一千个内核是通过运行同样的
a thousand cores is through running same

1720
01:03:40,570 --> 01:03:42,190
事情你在一个课程上运行
thing is you're running on one course at

1721
01:03:42,190 --> 01:03:43,960
至少一个事务会 总是
least one transaction is gonna always be

1722
01:03:43,960 --> 01:03:46,180
保证承诺，这就是为什么如果
guaranteed to commit and that's why if

1723
01:03:46,180 --> 01:03:47,620
它在相同的性能下变得粗糙，它
it gets rough at the same performance it

1724
01:03:47,620 --> 01:03:49,530
会在图表的另一侧出现，
gets on the other side of the graph

1725
01:03:49,530 --> 01:03:51,670
但主要的收获还是
right but the main takeaway again is

1726
01:03:51,670 --> 01:03:53,470
那个 ove  r 这里有一千个内核，
that over here at a thousand cores

1727
01:03:53,470 --> 01:03:57,640
一切都在做坏事，
everything's is doing bad and roughly

1728
01:03:57,640 --> 01:03:59,980
而且自 2014 年以来，情况有所好转，
it's got a little bit better since 2014

1729
01:03:59,980 --> 01:04:01,810
我们在这篇论文中，但这
we were at this paper but this is

1730
01:04:01,810 --> 01:04:04,000
大致是我们今天在
roughly where we are actually today in

1731
01:04:04,000 --> 01:04:06,340
现代系统中的实际情况，就在单个盒子中运行我而言，
modern systems in terms of running me in

1732
01:04:06,340 --> 01:04:10,480
有 64 32 或 64 核，所以
a single box there 64 32 or 64 cores so

1733
01:04:10,480 --> 01:04:11,830
我们真的没有在
we really haven't hit in the danger zone

1734
01:04:11,830 --> 01:04:14,440
高竞争的现代系统中进入危险区域
in a modern system of of having high

1735
01:04:14,440 --> 01:04:18,820
，你知道
contention and you know without really

1736
01:04:18,820 --> 01:04:20,920
在一个盒子上没有真正大量的核心数，
large number core counts on a single box

1737
01:04:20,920 --> 01:04:22,390
我们只是还没有到达那里，
we're just sort of not there yet but

1738
01:04:22,390 --> 01:04:24,610
但这张图基本上显示了 您
just this graph basically shows you that

1739
01:04:24,610 --> 01:04:25,930
认为我们今天使用的现有
the existing methods that we use out

1740
01:04:25,930 --> 01:04:31,030
方法不是我将具有可扩展性并且
today aren't I'm gonna be scalable and

1741
01:04:31,030 --> 01:04:32,560
如此快速 我们实际上
so real quickly where are we actually

1742
01:04:32,560 --> 01:04:34,510
将时间花在哪里 所以这是
spending our time so this is a breakdown

1743
01:04:34,510 --> 01:04:37,780
在 xu 交易时不同协议的细分
of the different protocols while the xu

1744
01:04:37,780 --> 01:04:40,000
，您会在这种
transactions and you see that in the

1745
01:04:40,000 --> 01:04:41,920
情况下看到 不用等待，它
case of no wait it's spending a large

1746
01:04:41,920 --> 01:04:43,360
花费了大部分时间来
percent of its time boarding

1747
01:04:43,360 --> 01:04:44,980
处理事务，因为一旦
transactions because can soon as it

1748
01:04:44,980 --> 01:04:47,440
发现冲突，它就会说这是
finds a conflict it says this this is

1749
01:04:47,440 --> 01:04:51,010
不好的，只是重新启动它，或者其他
bad and just restarts it or is the other

1750
01:04:51,010 --> 01:04:53,710
协议正在花时间等待
protocols are spending time waiting to

1751
01:04:53,710 --> 01:04:55,360
尝试获取锁或尝试 获取
try to acquire locks or try to acquire

1752
01:04:55,360 --> 01:04:56,380
时间点再次等待一个
time stands are waiting with a

1753
01:04:56,380 --> 01:04:58,450
愉快的线程，这只是
delectation thread again that's all just

1754
01:04:58,450 --> 01:05:02,350
浪费工作，所以让我们
sort of wasted work all right so let's

1755
01:05:02,350 --> 01:05:03,400
快速讨论一下
quickly talk about some of the

1756
01:05:03,400 --> 01:05:05,550
我们在本文中确定的
bottlenecks we identified in this paper

1757
01:05:05,550 --> 01:05:10,090
一些瓶颈以及我们可以绕过它们的一些潜在解决方案
and sort of some potential solutions we

1758
01:05:10,090 --> 01:05:12,130
以及这里的想法
can to get around them and the idea here

1759
01:05:12,130 --> 01:05:14,080
有点理解这些问题的
is sort of understand these issues at

1760
01:05:14,080 --> 01:05:16,210
高层次，所以当我们
high level so that again when we start

1761
01:05:16,210 --> 01:05:19,540
talking about FVCC more detail in the

1762
01:05:19,540 --> 01:05:22,210
在后面的下一堂课中再次开始谈论 FVCC 时，你的头脑
next class in the back your mind should

1763
01:05:22,210 --> 01:05:23,440
应该考虑更多细节哦，好吧，
be thinking about oh well this is how

1764
01:05:23,440 --> 01:05:25,660
这就是他们将如何处理这个
they would handle this this is how this

1765
01:05:25,660 --> 01:05:26,710
问题，这可能是一个问题 当我们看到
could be a problem when we see hit

1766
01:05:26,710 --> 01:05:27,790
比我们今天实际拥有的更大的核心帐户时
larger core accounts than what we

1767
01:05:27,790 --> 01:05:30,490
，因此锁定抖动
actually have today so lock thrashing

1768
01:05:30,490 --> 01:05:31,840
时间一些分配内存分配
time some allocation memory allocations

1769
01:05:31,840 --> 01:05:34,300
将导致每一个一个一个，因此
will cause each of these one by one so

1770
01:05:34,300 --> 01:05:36,340
锁定抖动是一种现象，您
lock thrashing is a phenomenon that you

1771
01:05:36,340 --> 01:05:38,320
将在两阶段锁定系统
would have in a two phase locking system

1772
01:05:38,320 --> 01:05:41,650
中遇到如果事务 最终
where the if a transaction ends up

1773
01:05:41,650 --> 01:05:44,230
等待更长时间所需的锁，然后这
waiting longer required locks then this

1774
01:05:44,230 --> 01:05:45,910
会导致其他等待
causes other transactions waiting behind

1775
01:05:45,910 --> 01:05:47,500
它的事务最终等待更长的时间来
it end up waiting longer to acquire the

1776
01:05:47,500 --> 01:05:49,000
获取第一个持有的事务的锁，
locks at the first transactions holding

1777
01:05:49,000 --> 01:05:51,069
并且 因此，这会导致
and therefore that causes other

1778
01:05:51,069 --> 01:05:53,799
该服务背后的其他事务的第二条路径
behind that service second path of

1779
01:05:53,799 --> 01:05:56,049
等待更长时间，因此
transactions to wait even longer so is

1780
01:05:56,049 --> 01:05:58,119
这种护卫效应是我们导致一个
this convoy effect we're cause one

1781
01:05:58,119 --> 01:05:59,589
事务等待更长时间导致
transaction wait longer cause everybody

1782
01:05:59,589 --> 01:06:01,690
其他所有人等待更长时间然后
else wait longer and then that gets

1783
01:06:01,690 --> 01:06:03,779
随着您添加更多事务而加剧，
exacerbated as you add more transactions

1784
01:06:03,779 --> 01:06:06,219
因此我们可以实际衡量的一种方式
so one way we can actually measure this

1785
01:06:06,219 --> 01:06:09,849
在我们的系统中，这是通过消除
in our system is by removing all the

1786
01:06:09,849 --> 01:06:11,349
进行任何死锁检查
overhead of doing any deadlock check

1787
01:06:11,349 --> 01:06:12,880
预防或死锁检测的所有开销，并且
prevention or deadlock detection and

1788
01:06:12,880 --> 01:06:15,940
让事务只做
just having transactions just do nothing

1789
01:06:15,940 --> 01:06:18,999
获取锁并等待，因此
but acquire locks and just wait and so

1790
01:06:18,999 --> 01:06:20,259
在这种情况下，我们可以这样做的
in this case here the way we can do this

1791
01:06:20,259 --> 01:06:21,999
方式是我们要 强制事务
is that we're gonna force transactions

1792
01:06:21,999 --> 01:06:23,499
需要的锁总是以某种
required locks always in some kind of

1793
01:06:23,499 --> 01:06:25,329
主键顺序 想想就像
primary key order just think of like

1794
01:06:25,329 --> 01:06:26,890
我们持有你知道我们有一个锁
we're holding you know we have a lock

1795
01:06:26,890 --> 01:06:28,509
一二三四五六我们必须
one two three four five six and we have

1796
01:06:28,509 --> 01:06:30,279
以那种
to acquire them in that sort of

1797
01:06:30,279 --> 01:06:32,140
字典顺序获取它们所以在这种
lexicographical order so in this

1798
01:06:32,140 --> 01:06:33,880
环境中死锁是 可能所以
environment deadlocks are possible so

1799
01:06:33,880 --> 01:06:36,819
我们永远不会因为死锁而出现任何停顿，
we'll never have any stalls due to dead

1800
01:06:36,819 --> 01:06:39,249
它只是
locks it's just just the stalls waiting

1801
01:06:39,249 --> 01:06:43,089
等待获取这些锁的停顿，所以如果你
to acquire these locks and so if you run

1802
01:06:43,089 --> 01:06:45,309
在系统上运行那个实验哟 你得到一个
that experiment on the system you get a

1803
01:06:45,309 --> 01:06:47,829
这样的图表，所以这里的推子变量
graph like this so the fader variable

1804
01:06:47,829 --> 01:06:50,079
代表
here is representing the amount of skew

1805
01:06:50,079 --> 01:06:52,239
工作负载的偏差量或
in the workload or more transactions

1806
01:06:52,239 --> 01:06:53,769
试图访问少量元组的更多事务，
trying to access a small number tuples

1807
01:06:53,769 --> 01:06:56,949
所以最极端的情况是 0.8
so the most extreme case is stated 0.8

1808
01:06:56,949 --> 01:06:59,019
并且 theta 零意味着没有
and theta zero means there's there's no

1809
01:06:59,019 --> 01:07:01,449
争用，所以你看到了什么 是这些
contention so what you see is are these

1810
01:07:01,449 --> 01:07:05,799
漂亮的曲线 这些膝盖弯曲处
nice curves these knee bends where the

1811
01:07:05,799 --> 01:07:07,900
锁定新生开始发挥作用 现在
lock freshman comes into play and now

1812
01:07:07,900 --> 01:07:09,249
交易最终等待
transactions are end up waiting the

1813
01:07:09,249 --> 01:07:11,829
越来越长的时间来获取锁定 当
longer and longer to acquire locks when

1814
01:07:11,829 --> 01:07:15,009
有更多的争用权时
there's more contention right and at

1815
01:07:15,009 --> 01:07:16,569
，您知道这种争夺一直在
some you know this grabs keeps going

1816
01:07:16,569 --> 01:07:18,009
下降 这些线一直在下降
down these lines keep going down you

1817
01:07:18,009 --> 01:07:19,690
don't recover from this thrashing effect

1818
01:07:19,690 --> 01:07:21,789
当我真的很喜欢这个实验的时候，不要从这种颠簸效应中恢复过来，
when I really like what this experiment

1819
01:07:21,789 --> 01:07:25,569
因为它显示这个图
is because is that it shows this graph

1820
01:07:25,569 --> 01:07:28,180
实际上看起来就像任何一种
actually looks exactly like any sort of

1821
01:07:28,180 --> 01:07:29,890
教科书，表明你描述了
textbook that shows you were describes

1822
01:07:29,890 --> 01:07:33,130
锁定颠簸，像这样
lock thrashing right like this is sort

1823
01:07:33,130 --> 01:07:35,049
是一本教科书的例子，但是 他们
of one example of a textbook but they

1824
01:07:35,049 --> 01:07:36,430
总是有这样的理论
always had this sort of theoretical

1825
01:07:36,430 --> 01:07:39,279
图，比如哦，这是锁颠簸的效果，
diagram of like oh here's the effect of

1826
01:07:39,279 --> 01:07:41,529
但你知道在这种情况下
lock thrashing but you know in this case

1827
01:07:41,529 --> 01:07:43,809
，我们的图与 y 完全匹配 您
here our graph matches exactly what you

1828
01:07:43,809 --> 01:07:45,039
希望根据定理看到，
would expect to see according according

1829
01:07:45,039 --> 01:07:48,279
这
to according to the theorem which is

1830
01:07:48,279 --> 01:07:51,999
很好我有一个时间戳
kind of nice I have a time stamp

1831
01:07:51,999 --> 01:07:54,069
分配，这
allocation is it not necessarily gonna

1832
01:07:54,069 --> 01:07:56,769
对我们的系统来说不一定是一个大问题，我们
be a big issue for us in our system

1833
01:07:56,769 --> 01:07:59,890
将通过
we're gonna get by with doing either

1834
01:07:59,890 --> 01:08:03,039
批量添加或原子操作来解决 另外，这
batch addition or atomic addition which

1835
01:08:03,039 --> 01:08:04,450
是另一种变体
is another variant

1836
01:08:04,450 --> 01:08:06,790
交换，但它基本上是说在
swap but it's basically saying that in a

1837
01:08:06,790 --> 01:08:09,790
非常多的核心计数中，有一个
really large number core counts having a

1838
01:08:09,790 --> 01:08:11,320
事务到 opto 获得了唯一的
transaction to opto acquired unique

1839
01:08:11,320 --> 01:08:12,460
时间戳，因此它们实际上可能是一个
timestamp so they actually could be a

1840
01:08:12,460 --> 01:08:15,220
很大的瓶颈，因此互斥锁总是
big bottleneck so the mutex is always is

1841
01:08:15,220 --> 01:08:16,330
会很糟糕，我们不觉得
gonna be bad we don't boy that

1842
01:08:16,330 --> 01:08:19,060
不可能 atomic add bash 这些
impossible atomic add bash these are

1843
01:08:19,060 --> 01:08:21,310
只是比较交换方法，然后对于
just compare swap methods and then for

1844
01:08:21,310 --> 01:08:24,399
这些特定的 cpu，像 intel 这样的
these particular cpus some cpus like

1845
01:08:24,399 --> 01:08:27,220
cpu 可以有硬件时钟，或者
intel they can have a hardware clock or

1846
01:08:27,220 --> 01:08:29,319
您可以通过一些指令，
you can get through some instruction but

1847
01:08:29,319 --> 01:08:32,470
但这尚不清楚 intel 是否
this is not clear whether intel's

1848
01:08:32,470 --> 01:08:35,319
迫切需要保留它，
exigent going to keep this around and

1849
01:08:35,319 --> 01:08:37,000
这不是我们的东西 可能
that's not something we potentially

1850
01:08:37,000 --> 01:08:39,040
会希望她躺在上面，然后哈佛
would want her lie on and then a harvard

1851
01:08:39,040 --> 01:08:41,340
历法
calendar approach was something that was

1852
01:08:41,340 --> 01:08:43,660
是学生
something that the the student came up

1853
01:08:43,660 --> 01:08:45,460
想出的添加到石墨
with an added to the the graphite

1854
01:08:45,460 --> 01:08:47,500
模拟中的东西 这不是
simulation system this is not something

1855
01:08:47,500 --> 01:08:49,149
我们想要的东西，你知道它
that we would have it you know that

1856
01:08:49,149 --> 01:08:51,399
今天存在，所以这张图只是
exists today and so this graph is just

1857
01:08:51,399 --> 01:08:53,950
向你展示了这些瓶颈之一在
showing you that the one of these

1858
01:08:53,950 --> 01:08:55,540
运行
bottlenecks come into play for running

1859
01:08:55,540 --> 01:08:58,029
这些不同的时间方案分配
these different time scheme allocation

1860
01:08:58,029 --> 01:09:00,279
方案时发挥作用，而且批处理原子的
schemes and again the batch atomic one

1861
01:09:00,279 --> 01:09:01,660
一个可能会 对
is probably gonna be good enough for

1862
01:09:01,660 --> 01:09:04,630
我们需要的东西足够好，我们正在谈论你
what we need right we're talking you

1863
01:09:04,630 --> 01:09:05,890
知道尝试分配一
know trying to allocate a hundred

1864
01:09:05,890 --> 01:09:07,779
亿个时间戳一秒钟，这
million time stamps for a second that's

1865
01:09:07,779 --> 01:09:12,520
比我们永远需要的还要多
more than we'll ever need all right the

1866
01:09:12,520 --> 01:09:14,080
memory allocation stuff

1867
01:09:14,080 --> 01:09:18,310
the main issue here is that since we

1868
01:09:18,310 --> 01:09:22,180
将
have to now copy things into private

1869
01:09:22,180 --> 01:09:24,130
某些协议的内容复制到私有工作区中，或者
workspaces for some some protocols or

1870
01:09:24,130 --> 01:09:26,890
您知道复制元组并确保
you know copy tuples and make sure penal

1871
01:09:26,890 --> 01:09:30,279
在公共空间中进行惩罚读取，复制可能
reads in public spaces that copying can

1872
01:09:30,279 --> 01:09:32,950
很昂贵，因此如果我们使用
be expensive and so if we use the

1873
01:09:32,950 --> 01:09:35,350
默认的 Lipsy malloc，它总是
default Lipsy malloc that's gonna always

1874
01:09:35,350 --> 01:09:37,090
会超级慢，我们永远不想使用
be super slow and we never want to use

1875
01:09:37,090 --> 01:09:39,609
它所以 本学期我们不会过多讨论不同的
it so we're not gonna discuss different

1876
01:09:39,609 --> 01:09:41,290
内存分配器，
memory allocators too much this semester

1877
01:09:41,290 --> 01:09:43,120
除了说
other than say we don't want to use the

1878
01:09:43,120 --> 01:09:45,220
当我们最终使用 GE
default malloc when we end up using GE

1879
01:09:45,220 --> 01:09:48,100
malloc 或 TC malloc 或其他时我们不想使用默认的 malloc
malloc or TC malloc or these other

1880
01:09:48,100 --> 01:09:50,050
malloc 协议他们的库
malloc protocols their libraries that

1881
01:09:50,050 --> 01:09:55,150
都在那里，所以我再次
are out there all right so again I

1882
01:09:55,150 --> 01:09:56,530
意识到让
realized it's kind of weird for having

1883
01:09:56,530 --> 01:09:58,120
我在这个镀金的房间里讲这个讲座的其余部分有点奇怪，
me give the rest of this lecture in this

1884
01:09:58,120 --> 01:10:02,440
但我
this gold-plated chamber thing but I

1885
01:10:02,440 --> 01:10:03,820
只是想把它放在那里，以便
just want to get this out there so that

1886
01:10:03,820 --> 01:10:05,500
我们可以开始交谈 关于 MVC 星期三看到更多
we can start talking about MVC see more

1887
01:10:05,500 --> 01:10:07,060
细节我
detail on on Wednesday I want to come

1888
01:10:07,060 --> 01:10:09,970
想回来回到校园 所以
back to come back to campus so the main

1889
01:10:09,970 --> 01:10:11,410
你在这个讲座
takeaway what you give in this lecture

1890
01:10:11,410 --> 01:10:13,540
中的主要内容是内存数据
is that the design of an in-memory data

1891
01:10:13,540 --> 01:10:15,220
系统的设计在概念上与磁盘写入系统有很大不同，
system has be much different than a disk

1892
01:10:15,220 --> 01:10:16,930
它是
writing system conceptually it's the

1893
01:10:16,930 --> 01:10:17,620
同样的权利，你们
same right you

1894
01:10:17,620 --> 01:10:19,150
两个查询他们的索引不会
two queries their indexes will not

1895
01:10:19,150 --> 01:10:21,730
交易，但
transactions but the implementation of

1896
01:10:21,730 --> 01:10:24,130
这些系统的协议的实现
the protocol of these systems are gonna

1897
01:10:24,130 --> 01:10:26,650
会有很大不同，好消息
be much different and the good news also

1898
01:10:26,650 --> 01:10:29,110
也是，当我刚开始读研究生时，内存数据库
too is that a memory databases are not

1899
01:10:29,110 --> 01:10:33,060
不再被认为是超级奇怪的
considered to be super bizarre anymore

1900
01:10:33,060 --> 01:10:35,850
也许
when I first started grad school maybe

1901
01:10:35,850 --> 01:10:38,620
十多年前的现在，但像 2007
over ten years ago now but like 2007

1902
01:10:38,620 --> 01:10:42,160
年和 2006 年一样，它们被认为是一种
2006 they're considered sort of an

1903
01:10:42,160 --> 01:10:45,040
异国情调的系统，但现在尤其是
exotic system but nowadays especially

1904
01:10:45,040 --> 01:10:48,220
像 Redis 这样的系统，
with systems like Redis they become more

1905
01:10:48,220 --> 01:10:49,690
如果人们变得更加 C，它们就会变得更加普遍
common if people become more comfortable

1906
01:10:49,690 --> 01:10:51,640
对内存系统的想法感到满意
with the idea of having in memory

1907
01:10:51,640 --> 01:10:54,820
，我要说的一件事是
systems the one thing that I will say is

1908
01:10:54,820 --> 01:10:57,370
，与我们在 SSD 中看到的游戏相比，近年来
that in recent years it seems like the

1909
01:10:57,370 --> 01:10:59,650
DRAM 的价格和容量似乎停滞不前
DRAM prices and capacities have stalled

1910
01:10:59,650 --> 01:11:01,620
，
compared to the games we've seen in SSDs

1911
01:11:01,620 --> 01:11:04,960
所以在此之前我非常
so whereas before I was pretty bullish

1912
01:11:04,960 --> 01:11:07,810
看好哦 内存数据库
about oh well in memory databases are

1913
01:11:07,810 --> 01:11:08,950
将接管法庭世界
gonna take over the world of court why

1914
01:11:08,950 --> 01:11:10,360
为什么你会想要使用令人失望的
would you ever want to use dissapointing

1915
01:11:10,360 --> 01:11:13,720
系统 II 认为这实际上
system I I don't think that's actually

1916
01:11:13,720 --> 01:11:18,160
不是真的，我认为值得
true and I think that it's worth looking

1917
01:11:18,160 --> 01:11:21,010
看看我们可以做些什么来恢复
to see what we can do to bring back SSDs

1918
01:11:21,010 --> 01:11:23,020
数据库系统中的 SSD 实际上
in a database system without actually

1919
01:11:23,020 --> 01:11:24,490
不必放慢速度并带来
having to slow it down and bringing all

1920
01:11:24,490 --> 01:11:25,960
面向磁盘的架构的所有开销，
the overhead of a disk oriented

1921
01:11:25,960 --> 01:11:27,760
所以我们会
architecture so we'll talk about little

1922
01:11:27,760 --> 01:11:29,050
在学期结束时讨论一点，但这
bit at the end of the semester but

1923
01:11:29,050 --> 01:11:30,490
是我脑海中的一些东西，
that's something in the back of my mind

1924
01:11:30,490 --> 01:11:33,100
我认为它会出现几个
I think it'll come up a couple of times

1925
01:11:33,100 --> 01:11:34,950
学期中的时间
during the semester okay

1926
01:11:34,950 --> 01:11:38,860
好的 所以只是为了完成
all right so just to finish up this is

1927
01:11:38,860 --> 01:11:41,320
今天的工作 我将在本周五飞回来
it for today I'll be flying back this

1928
01:11:41,320 --> 01:11:43,630
，下周周二我将在校园里
Friday and I'll be on campus on Tuesday

1929
01:11:43,630 --> 01:11:45,430
，我们将进行背诵
next week and we'll have the recitation

1930
01:11:45,430 --> 01:11:48,160
以讨论
for discussing that the architecture of

1931
01:11:48,160 --> 01:11:49,870
系统，然后在下周的周三课程中，
the system and then on Wednesdays class

1932
01:11:49,870 --> 01:11:51,340
我们将开始讨论
next week well we will start discussing

1933
01:11:51,340 --> 01:11:53,380
多版本商业，因为
multi version commercial because again

1934
01:11:53,380 --> 01:11:55,860
这是
this is the the dominant method or

1935
01:11:55,860 --> 01:11:58,330
每个人都使用的主要方法或协议，但它
protocol that everyone uses but it's

1936
01:11:58,330 --> 01:11:59,680
不仅仅是与协议相比，它
more than just compared to protocol it's

1937
01:11:59,680 --> 01:12:01,960
会让你完成
gonna sort of you accomplish all

1938
01:12:01,960 --> 01:12:03,400
数据系统的所有不同方面 所以
different aspects of the data system so

1939
01:12:03,400 --> 01:12:04,900
我们会开始了解
we'll start understanding that a bit

1940
01:12:04,900 --> 01:12:07,210
更多的细节，好的，
more detail okay so that's it for today

1941
01:12:07,210 --> 01:12:08,680
I'm gonna go hang out with the Germans a

1942
01:12:08,680 --> 01:12:10,990
bit more and then I'll see everyone next

1943
01:12:10,990 --> 01:12:14,130
week in class all right take care see ya

1944
01:12:14,130 --> 01:12:16,470
今天就到这里了
what is this

1945
01:12:16,470 --> 01:12:19,320
说你来了 我喝了一口，
say you're here I took a sip in hand to

1946
01:12:19,320 --> 01:12:21,510
和 Ned 一起度过今晚，这里叫做
spend tonight with Ned here called the

1947
01:12:21,510 --> 01:12:24,510
Hokey 因为我很喜欢 Ice Cube，因为
Hokey cuz I'm og Ice Cube down with the

1948
01:12:24,510 --> 01:12:27,990
你看起来很暴躁，去给我拿一
testy you look and it was go grab me a

1949
01:12:27,990 --> 01:12:31,620
首 40 首歌，因为我需要
40 song cuz I needed just a little more

1950
01:12:31,620 --> 01:12:42,330
再踢一点 和我的帅哥说我很
kick and my hunky to say I'm nice to

1951
01:12:42,330 --> 01:12:45,950
高兴说我祈祷
take a say I pray
