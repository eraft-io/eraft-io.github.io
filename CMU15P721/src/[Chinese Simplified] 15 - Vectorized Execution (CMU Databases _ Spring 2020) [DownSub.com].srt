1
00:00:01,300 --> 00:00:05,129
[音乐]

2
00:00:05,200 --> 00:00:05,930
[鼓掌]

3
00:00:05,930 --> 00:00:08,630
[音乐]

4
00:00:08,630 --> 00:00:10,020
[鼓掌]

5
00:00:10,020 --> 00:00:11,480
[音乐]

6
00:00:11,480 --> 00:00:13,889
今天我们认为宪法

7
00:00:13,889 --> 00:00:16,379
和我所说的编译和

8
00:00:16,379 --> 00:00:18,600
玻璃类的 QWERTY 编译和向量

9
00:00:18,600 --> 00:00:20,850
矢量化是

10
00:00:20,850 --> 00:00:22,890
我们可以在现代

11
00:00:22,890 --> 00:00:25,170
数据库系统中应用的两种主要方法 提高查询

12
00:00:25,170 --> 00:00:27,359
性能所以我将首先开始

13
00:00:27,359 --> 00:00:29,310
谈论向量化

14
00:00:29,310 --> 00:00:31,230
是什么向量，但实际上将使用 Sim D

15
00:00:31,230 --> 00:00:33,090
然后你们

16
00:00:33,090 --> 00:00:36,210
签署阅读的论文是这种食谱书或

17
00:00:36,210 --> 00:00:38,790
哥伦比亚大学的这些人的指南

18
00:00:38,790 --> 00:00:42,059
如何利用经典的数据库

19
00:00:42,059 --> 00:00:43,620
算法来做我们周六需要的各种事情

20
00:00:43,620 --> 00:00:45,629


21
00:00:45,629 --> 00:00:47,520
来系统化并使用 Cindy 实现它们，我喜欢它，因为

22
00:00:47,520 --> 00:00:49,440
它再次涵盖了你知道

23
00:00:49,440 --> 00:00:51,030
在

24
00:00:51,030 --> 00:00:52,710
数据库系统中运行分析

25
00:00:52,710 --> 00:00:54,899
查询实际需要的所有各种事情 剧透是，

26
00:00:54,899 --> 00:00:56,940
我只是提前说，

27
00:00:56,940 --> 00:00:59,340
除了某些例外

28
00:00:59,340 --> 00:01:00,510
，它们实际上都不起作用，因为他们将对他们的操作环境做出如此重大的

29
00:01:00,510 --> 00:01:02,640
假设

30
00:01:02,640 --> 00:01:03,840
，我将 当我们讨论

31
00:01:03,840 --> 00:01:05,339
到这个问题时，我们将

32
00:01:05,339 --> 00:01:09,210
讨论项目三个主题，好吧，

33
00:01:09,210 --> 00:01:12,240
所以矢量化是

34
00:01:12,240 --> 00:01:13,830
我们将在

35
00:01:13,830 --> 00:01:16,350
我们的数据库系统中应用的过程或方法，以采用

36
00:01:16,350 --> 00:01:17,970
最初实现的算法假设

37
00:01:17,970 --> 00:01:21,240
规模或操作，我们

38
00:01:21,240 --> 00:01:22,409
要让你知道一个数据，

39
00:01:22,409 --> 00:01:25,860
并对它应用一个更改、修改或

40
00:01:25,860 --> 00:01:28,380
操作，然后我们

41
00:01:28,380 --> 00:01:30,869


42
00:01:30,869 --> 00:01:33,479
将把它转换为现在能够获取数据项的向量

43
00:01:33,479 --> 00:01:35,729
它们是否是元组值元组指针

44
00:01:35,729 --> 00:01:39,119
这取决于算法然后现在

45
00:01:39,119 --> 00:01:41,850
我们可以调用一个简单的指令

46
00:01:41,850 --> 00:01:44,790
它允许我们应用相同的

47
00:01:44,790 --> 00:01:46,860
修改对

48
00:01:46,860 --> 00:01:49,770
单个指令中的那些项向量应用相同的操作

49
00:01:49,770 --> 00:01:52,590
，所以我们“ 我会看到这一点，

50
00:01:52,590 --> 00:01:55,649
虽然它并不

51
00:01:55,649 --> 00:01:57,570
总是会有一些准备工作，我们

52
00:01:57,570 --> 00:01:59,009
必须将东西放入这些特殊

53
00:01:59,009 --> 00:02:00,600
寄存器，然后应用到向量化

54
00:02:00,600 --> 00:02:01,920
指令，所以这不像我们

55
00:02:01,920 --> 00:02:04,049
神奇地可以 使

56
00:02:04,049 --> 00:02:06,479
我们代码中的任何内容都变成矢量化 所以

57
00:02:06,479 --> 00:02:07,530
你们我们正在阅读的论文是

58
00:02:07,530 --> 00:02:09,239
关于如何采用非常专业

59
00:02:09,239 --> 00:02:10,889
或非常具体的算法或

60
00:02:10,889 --> 00:02:12,330
约会系统的组件

61
00:02:12,330 --> 00:02:14,460
并能够并行运行它们

62
00:02:14,460 --> 00:02:16,800
所以这很明显 为什么

63
00:02:16,800 --> 00:02:19,470
我们想这样做是因为现在

64
00:02:19,470 --> 00:02:21,810
我们可以根据您的指示做更多的工作，

65
00:02:21,810 --> 00:02:23,550
但

66
00:02:23,550 --> 00:02:24,600
我们还将从中获得的一大优势

67
00:02:24,600 --> 00:02:26,160
是这将

68
00:02:26,160 --> 00:02:28,440
独立于我们

69
00:02:28,440 --> 00:02:29,430
之前讨论过的所有事情 当我们谈论

70
00:02:29,430 --> 00:02:32,130
并行查询处理时，因为

71
00:02:32,130 --> 00:02:34,050
那完全是关于如何在我们的数据库系统中进行查询或

72
00:02:34,050 --> 00:02:35,310
您想要的任何东西

73
00:02:35,310 --> 00:02:37,380
并将世界杯划分为

74
00:02:37,380 --> 00:02:39,330


75
00:02:39,330 --> 00:02:40,560


76
00:02:40,560 --> 00:02:43,200
多个线程 使它正在做的事情

77
00:02:43,200 --> 00:02:46,470
实际上并行运行，

78
00:02:46,470 --> 00:02:47,970
并且您可以获得的

79
00:02:47,970 --> 00:02:49,470
潜在加速是巨大的，因为它的

80
00:02:49,470 --> 00:02:52,020
乘法权所以说我有一个

81
00:02:52,020 --> 00:02:55,500
Algrim，我可以在 32 个线程的 32 个内核上运行，

82
00:02:55,500 --> 00:02:58,530
所以我 如果

83
00:02:58,530 --> 00:03:00,330
我打架，你知道我是否会瘫痪，得到 32 倍的加速，

84
00:03:00,330 --> 00:03:02,580
但现在如果我从

85
00:03:02,580 --> 00:03:03,750
每个线程实际所做的工作中进行矢量化，

86
00:03:03,750 --> 00:03:07,290
并说我有一个四通道的 Cindy

87
00:03:07,290 --> 00:03:10,530
寄存器，意思是一块

88
00:03:10,530 --> 00:03:13,080
我可以运行的工作 我可以在四个数据项

89
00:03:13,080 --> 00:03:15,030
上并行操作，一个看到

90
00:03:15,030 --> 00:03:17,880
指令所以现在我也将在那里获得 4 倍的

91
00:03:17,880 --> 00:03:20,880
加速，所以 32 乘以 4 是 128 所以

92
00:03:20,880 --> 00:03:22,560
我可能可以从算法的

93
00:03:22,560 --> 00:03:24,300
单线程标量实现

94
00:03:24,300 --> 00:03:26,040
现在我可以

95
00:03:26,040 --> 00:03:29,540
用 128 2128 X 加速运行

96
00:03:29,540 --> 00:03:33,030
的问题就像我

97
00:03:33,030 --> 00:03:35,130
在上课前早些时候告诉他的那样，

98
00:03:35,130 --> 00:03:37,320
我们永远不会欺骗你，

99
00:03:37,320 --> 00:03:38,880
像这样的最大加速是我们的

100
00:03:38,880 --> 00:03:40,830
上限，我们' 会明白为什么当

101
00:03:40,830 --> 00:03:42,450
我们再次进行时，因为我们有一对东西

102
00:03:42,450 --> 00:03:43,800
进出寄存器，

103
00:03:43,800 --> 00:03:45,660
为什么我们实际上永远不会去

104
00:03:45,660 --> 00:03:47,700
最便宜的，但就像这是一个很好的目标，

105
00:03:47,700 --> 00:03:49,019
这是我们绝对

106
00:03:49,019 --> 00:03:51,300
想要实现的目标或 尝试治疗以

107
00:03:51,300 --> 00:03:55,590
实现因此这里的人被纳入 1  6 for

108
00:03:55,590 --> 00:03:59,310
18 好吧 有点超过 1/2

109
00:03:59,310 --> 00:04:01,440
好吧 谁以前从未见过 Cindy

110
00:04:01,440 --> 00:04:04,500
好吧 好吧

111
00:04:04,500 --> 00:04:07,890
所以 Cindy 是一个类堆

112
00:04:07,890 --> 00:04:10,890
指令，处理器

113
00:04:10,890 --> 00:04:13,110
将为我们提供它允许我们

114
00:04:13,110 --> 00:04:15,390
来做 这些向量化操作，如果

115
00:04:15,390 --> 00:04:18,029
我们用 ssty 做垃圾处理，它是单一

116
00:04:18,029 --> 00:04:19,620
结构和单一数据，一个数据项

117
00:04:19,620 --> 00:04:21,680
Cindy 将是单个指令

118
00:04:21,680 --> 00:04:25,710
多个数据项在一起，这

119
00:04:25,710 --> 00:04:26,160
有点像

120
00:04:26,160 --> 00:04:28,740
Cindy 与 sisty 的概念

121
00:04:28,740 --> 00:04:30,570
来自弗林的并行数据库分类法

122
00:04:30,570 --> 00:04:32,160
或

123
00:04:32,160 --> 00:04:36,030
从 1960 年代开始并行系统，所以

124
00:04:36,030 --> 00:04:38,220
现在每个 CPU 的每个指令集都

125
00:04:38,220 --> 00:04:41,100
将拥有并支持 Cindy

126
00:04:41,100 --> 00:04:42,960
操作只是他们

127
00:04:42,960 --> 00:04:44,850
将称之为这些扩展

128
00:04:44,850 --> 00:04:47,690
或指令的类的名称将是不同的

129
00:04:47,690 --> 00:04:49,890
论文你们读我们 所有关于英特尔的

130
00:04:49,890 --> 00:04:52,850
东西，在他们的世界里是 SSE 或 ADX

131
00:04:52,850 --> 00:04:54,930
和纸，你们被认为

132
00:04:54,930 --> 00:04:57,120
是 2015 年我认为所以他们正在处理

133
00:04:57,120 --> 00:04:57,990


134
00:04:57,990 --> 00:05:02,460
avx2，它是 250 256 位寄存器 rs

135
00:05:02,460 --> 00:05:06,450
现在最先进的技术是 200 抱歉

136
00:05:06,450 --> 00:05:09,570
来自 IBM 的 512 12 位电源有一个

137
00:05:09,570 --> 00:05:11,610
叫做 altivec arm 的东西有他们的东西

138
00:05:11,610 --> 00:05:13,590
叫做霓虹灯 然后几年前这个

139
00:05:13,590 --> 00:05:15,510
行动提出了一个叫做 SPE 的

140
00:05:15,510 --> 00:05:16,830
可扩展向量指令

141
00:05:16,830 --> 00:05:18,120
所以什么人应该是真的

142
00:05:18,120 --> 00:05:19,980
对此很酷，我不知道是否有人

143
00:05:19,980 --> 00:05:21,810
真正实现了这一点，但

144
00:05:21,810 --> 00:05:23,190
他们设置

145
00:05:23,190 --> 00:05:24,900
指令的方式是它们

146
00:05:24,900 --> 00:05:28,320
不会特定于任何寄存器大小，这意味着

147
00:05:28,320 --> 00:05:30,780
它们将具有某种 通用

148
00:05:30,780 --> 00:05:33,180
类矢量化指令，

149
00:05:33,180 --> 00:05:34,500
然后根据它

150
00:05:34,500 --> 00:05:37,050
在实际 CPU 中的实现方式，您

151
00:05:37,050 --> 00:05:39,270
可以像您一次了解 1024 位或 512 位一样操作，而

152
00:05:39,270 --> 00:05:42,240
此时所有这些

153
00:05:42,240 --> 00:05:45,090
英特尔的东西，如 avx2 或

154
00:05:45,090 --> 00:05:48,540
执行 256 位指令的指令，然后 512

155
00:05:48,540 --> 00:05:50,010
在 12a 中飙升 5，你不能像

156
00:05:50,010 --> 00:05:52,890
你一样，你不能把这些

157
00:05:52,890 --> 00:05:54,240
在更新的 CPU 上运行，并认为你会在这些 CPU 上运行

158
00:05:54,240 --> 00:05:55,500
，你必须重写

159
00:05:55,500 --> 00:05:57,510
你的代码才能真正意识到我' 我

160
00:05:57,510 --> 00:05:59,310
继续 更大的

161
00:05:59,310 --> 00:06:02,130
寄存器所以让我们看一个非常

162
00:06:02,130 --> 00:06:05,700
简单的简单操作示例，

163
00:06:05,700 --> 00:06:08,550
假设我们有两个向量 x 和 y，我们

164
00:06:08,550 --> 00:06:10,560
只想将

165
00:06:10,560 --> 00:06:12,870
X 的元素与 Y 的元素相加，每个元素

166
00:06:12,870 --> 00:06:14,940
都设置为 我们将

167
00:06:14,940 --> 00:06:18,180
在 CS 类范围或数据库类的介绍中实现这一点，

168
00:06:18,180 --> 00:06:19,830
它只是我们有一个

169
00:06:19,830 --> 00:06:21,330
for 循环，我们知道向量的大小

170
00:06:21,330 --> 00:06:23,460
假设相同的大小，然后

171
00:06:23,460 --> 00:06:25,470
对于每个元素 X 和

172
00:06:25,470 --> 00:06:27,270
Y 的相应元素，我们将它们加

173
00:06:27,270 --> 00:06:30,000
在一起 我们将它们写入到

174
00:06:30,000 --> 00:06:32,280
输出向量 Z 中，因此我们

175
00:06:32,280 --> 00:06:34,140
将使用 sisty 指令实现或执行的

176
00:06:34,140 --> 00:06:36,210
方式只是

177
00:06:36,210 --> 00:06:38,310
再次使用 for 循环，

178
00:06:38,310 --> 00:06:40,260
让您了解 x one 中的一个元素，

179
00:06:40,260 --> 00:06:42,840
从为什么要调用一条指令来做

180
00:06:42,840 --> 00:06:44,970
做加法然后

181
00:06:44,970 --> 00:06:48,750
现在用 Cindy 把它写到一个上缓冲区我们

182
00:06:48,750 --> 00:06:51,570
可以做的是我们

183
00:06:51,570 --> 00:06:53,550
将从这两个数组中获取一个元素向量，然后

184
00:06:53,550 --> 00:06:55,080
将它们组合在一个

185
00:06:55,080 --> 00:06:57,420
寄存器中，然后调用 o  ne cindy

186
00:06:57,420 --> 00:06:59,130
指令将它们相加并

187
00:06:59,130 --> 00:07:00,900
打印并生成我们的输出缓冲区

188
00:07:00,900 --> 00:07:02,130


189
00:07:02,130 --> 00:07:03,780


190
00:07:03,780 --> 00:07:06,120


191
00:07:06,120 --> 00:07:08,310
一个 128 位

192
00:07:08,310 --> 00:07:11,580
Simbi 寄存器，所以一旦我们填充了这个

193
00:07:11,580 --> 00:07:14,280
寄存器，我们就会

194
00:07:14,280 --> 00:07:15,660
在这两个寄存器上调用 simpie 指令，

195
00:07:15,660 --> 00:07:18,090
然后它会将一些输出

196
00:07:18,090 --> 00:07:20,070
结果写出到另一个大小相同的 cindy 寄存器，接下来的四个寄存器

197
00:07:20,070 --> 00:07:22,560
做同样的

198
00:07:22,560 --> 00:07:24,330
事情 元素唤起

199
00:07:24,330 --> 00:07:26,460
了 sim D，现在我们产生了我们的输出

200
00:07:26,460 --> 00:07:34,230
是的这个问题是这个问题正在

201
00:07:34,230 --> 00:07:37,980
加载到一个 cindy 寄存器

202
00:07:37,980 --> 00:07:40,320
就像加载到一个普通的一样快

203
00:07:40,320 --> 00:07:44,820
你知道单个数据项肯定它

204
00:07:44,820 --> 00:07:47,490
取决于数据的位置，

205
00:07:47,490 --> 00:07:48,600
就像如果 你正在做

206
00:07:48,600 --> 00:07:50,700
我们谈到的选择性存储的事情，Stefan

207
00:07:50,700 --> 00:07:53,220
可能会更慢是 Miss pans 多个

208
00:07:53,220 --> 00:07:56,130
缓存行它更多的工作我

209
00:07:56,130 --> 00:07:59,220
认为我认为 x86 的工作方式是你

210
00:07:59,220 --> 00:08:02,070
每个 cy 只能做一两次加载和存储

211
00:08:02,070 --> 00:08:05,910
cle 所以如果这个东西真的很宽，你

212
00:08:05,910 --> 00:08:08,670
可能需要在多个周期内进行多次加载，而像

213
00:08:08,670 --> 00:08:10,230


214
00:08:10,230 --> 00:08:13,860
将一件事写入单个

215
00:08:13,860 --> 00:08:16,050
数据寄存器是超快的，这

216
00:08:16,050 --> 00:08:17,250
就是我说的你永远不会

217
00:08:17,250 --> 00:08:20,190
达到理论上的 最大的加速

218
00:08:20,190 --> 00:08:22,140
只是因为

219
00:08:22,140 --> 00:08:24,960
把东西放在这里会有开销，但

220
00:08:24,960 --> 00:08:26,190
当然在这种情况下，你知道

221
00:08:26,190 --> 00:08:28,200
这将是一个非常好的权衡，

222
00:08:28,200 --> 00:08:31,280
因为我们从八个指令

223
00:08:31,280 --> 00:08:34,500
开始做它来做两个两个的加法

224
00:08:34,500 --> 00:08:37,169
可能让我为我们赢得胜利的指令

225
00:08:37,169 --> 00:08:39,560
是的

226
00:08:47,680 --> 00:08:51,260
所以这个问题是如果我们去

227
00:08:51,260 --> 00:08:53,930
avx-512 中的 512 位寄存器这将达到

228
00:08:53,930 --> 00:08:56,050
我们的缓存行限制是否意味着

229
00:08:56,050 --> 00:08:58,370
现在加载到它的成本会

230
00:08:58,370 --> 00:09:00,290
更高，他们开始 商店

231
00:09:00,290 --> 00:09:01,490
用它来获取数据，它

232
00:09:01,490 --> 00:09:03,110
会比这更昂贵，因为

233
00:09:03,110 --> 00:09:12,470
如果

234
00:09:12,470 --> 00:09:13,550
你不是如果你说你是否还

235
00:09:13,550 --> 00:09:15,830
没有缓存一行，我就无法击败可垃圾邮件的缓存行，就像取决于这些

236
00:09:15,830 --> 00:09:18,020
数据的位置 也喜欢想想 就像

237
00:09:18,020 --> 00:09:21,110
这是在 l1 中挂出，所以 l1 在

238
00:09:21,110 --> 00:09:24,470
Exodus 中 32 KB 所以我们可以把

239
00:09:24,470 --> 00:09:25,520
你想要存储的所有数据保存

240
00:09:25,520 --> 00:09:27,560
在 l1 中，然后我们不会

241
00:09:27,560 --> 00:09:29,029
出去，然后当你去得到所有的时候

242
00:09:29,029 --> 00:09:32,660
好吧，那么我们可以用 Cindy 做什么呢？

243
00:09:32,660 --> 00:09:34,790
我展示了一些基本的

244
00:09:34,790 --> 00:09:38,380
算术运算符，并再次

245
00:09:38,380 --> 00:09:42,709
在至少对于 x86 的 sve 下我认为

246
00:09:42,709 --> 00:09:45,290
他们开始了同样的问题，就像

247
00:09:45,290 --> 00:09:47,120
寄存器端一样，寄存器的大小

248
00:09:47,120 --> 00:09:48,740
将是固定的 但这

249
00:09:48,740 --> 00:09:52,550
并不一定意味着

250
00:09:52,550 --> 00:09:55,490
必须固定 Lane 的大小，所以我

251
00:09:55,490 --> 00:09:57,470
这里的示例是 128 位，

252
00:09:57,470 --> 00:09:59,360
因此我有一个明喻

253
00:09:59,360 --> 00:10:01,399
指令可以取 4 个整数并将它们加

254
00:10:01,399 --> 00:10:03,790
在一起，但如果我有 16- 位整数

255
00:10:03,790 --> 00:10:06,260
他们可能会提供另一条指令

256
00:10:06,260 --> 00:10:08,089
来了解如何取八个 16 位

257
00:10:08,089 --> 00:10:10,730
整数并将它们加在一起，这

258
00:10:10,730 --> 00:10:12,230
通常是您在

259
00:10:12,230 --> 00:10:14,029
编写 Sindhi 代码时指定的方式，就像我

260
00:10:14,029 --> 00:10:16,520
知道数据类型大小

261
00:10:16,520 --> 00:10:18,589
是什么一样 正在手术中，我们谈到了

262
00:10:18,589 --> 00:10:20,720
h 现在将数据移入移出，然后

263
00:10:20,720 --> 00:10:21,709
有所有这些逻辑指令

264
00:10:21,709 --> 00:10:23,930
来进行比较 你知道一些

265
00:10:23,930 --> 00:10:27,290
操作 我们可以做比较

266
00:10:27,290 --> 00:10:29,029
指令，这将需要

267
00:10:29,029 --> 00:10:30,170
做谓词来说明我们知道

268
00:10:30,170 --> 00:10:31,220
某些东西是否等于我们的 where

269
00:10:31,220 --> 00:10:34,070
子句中的某些东西 shuffle 指令 是否

270
00:10:34,070 --> 00:10:36,110
能够获取或获取

271
00:10:36,110 --> 00:10:37,910
您注册的一个 sim 卡的输出并将其写入

272
00:10:37,910 --> 00:10:39,920
另一个 simony 寄存器，

273
00:10:39,920 --> 00:10:41,630
这对我们来说是一个巨大的胜利，因为现在

274
00:10:41,630 --> 00:10:43,790
我们不必将输出

275
00:10:43,790 --> 00:10:45,560
放入 l1 然后 将它写回到

276
00:10:45,560 --> 00:10:47,089
另一个寄存器中，我们直接从

277
00:10:47,089 --> 00:10:49,670
一个寄存器到下一个寄存器，然后是

278
00:10:49,670 --> 00:10:52,550
其他随机的东西，比如我们将在一秒钟内看到的，

279
00:10:52,550 --> 00:10:54,980
比如获取

280
00:10:54,980 --> 00:10:56,510
位于 l1 中的数据，然后

281
00:10:56,510 --> 00:10:58,640
将其恢复为相同的形式

282
00:10:58,640 --> 00:11:01,790
取消注册，或者如果现在

283
00:11:01,790 --> 00:11:03,020
我们的简单寄存器中有一些东西，也许

284
00:11:03,020 --> 00:11:04,820
我们想把它写到内存中，但我们

285
00:11:04,820 --> 00:11:06,620
不想污染我们的 CPU 缓存，所以

286
00:11:06,620 --> 00:11:08,270
这些这些流指令

287
00:11:08,270 --> 00:11:09,890
允许我们获取输出目录 直接

288
00:11:09,890 --> 00:11:11,990
从这个 Indy 寄存器中把

289
00:11:11,990 --> 00:11:13,280
它放到内存中，而不用

290
00:11:13,280 --> 00:11:15,230
通过正常的层次结构，

291
00:11:15,230 --> 00:11:18,800
所以 Bay 我的主要想法是我们在

292
00:11:18,800 --> 00:11:20,930
这里尝试实现的是通过所有

293
00:11:20,930 --> 00:11:24,500
这些不同的指令，你知道我们

294
00:11:24,500 --> 00:11:28,340
可以尝试 这样做是为了将我们想要的尽可能多的有用

295
00:11:28,340 --> 00:11:30,140
数据打包到我们的半指令中

296
00:11:30,140 --> 00:11:32,480
，并在这些数据中进行尽可能多的处理

297
00:11:32,480 --> 00:11:34,310
，同时它们在我们的

298
00:11:34,310 --> 00:11:36,680
半寄存器中，然后我们才必须将

299
00:11:36,680 --> 00:11:39,230
其推送到内存中，

300
00:11:39,230 --> 00:11:41,470
尤其是这些 这些这些

301
00:11:41,470 --> 00:11:43,400
转换或这样的改组

302
00:11:43,400 --> 00:11:45,470
操作符这将允许我们这样

303
00:11:45,470 --> 00:11:46,730
做将一起改变一些操作

304
00:11:46,730 --> 00:11:48,470
你永远不必接触CPU

305
00:11:48,470 --> 00:11:50,570
缓存然后我们可以

306
00:11:50,570 --> 00:11:53,600
产生我们想要的结果因为

307
00:11:53,600 --> 00:11:54,980
这里的最后一个也非常重要

308
00:11:54,980 --> 00:11:58,340
因为特别是对于连接，例如如果我

309
00:11:58,340 --> 00:12:01,640
知道我正在执行连接元组

310
00:12:01,640 --> 00:12:03,050
匹配，但是在我上方有一个管道断路器

311
00:12:03,050 --> 00:12:05,270
，我不能

312
00:12:05,270 --> 00:12:07,850
对连接的输出做任何事情，然后我可以

313
00:12:07,850 --> 00:12:09,230
推 因为我知道

314
00:12:09,230 --> 00:12:11,120
在我回来并进入下一个管道之前我不会再次需要它

315
00:12:11,120 --> 00:12:13,550
所以

316
00:12:13,550 --> 00:12:16,070
这些流功能允许我

317
00:12:16,070 --> 00:12:17,270
你的流指令允许我

318
00:12:17,270 --> 00:12:19,070
喜欢使用在密封

319
00:12:19,070 --> 00:12:21,500
红色衬衫中的数据然后 你知道

320
00:12:21,500 --> 00:12:22,760
在回到它之前把它放在内存中

321
00:12:22,760 --> 00:12:26,540
好所以我们会

322
00:12:26,540 --> 00:12:28,070
在春假之后和

323
00:12:28,070 --> 00:12:31,160
在下节课的项目建议之后看到我们如何

324
00:12:31,160 --> 00:12:34,040
使用其中的一些技术以及我们的

325
00:12:34,040 --> 00:12:40,340
联合行动是的问题

326
00:12:40,340 --> 00:12:41,690
这些看似结构的

327
00:12:41,690 --> 00:12:43,130
流结构听起来很不错

328
00:12:43,130 --> 00:12:45,860
它们可用于非非半

329
00:12:45,860 --> 00:12:49,820
操作 是的 我想所以我是的 我想

330
00:12:49,820 --> 00:12:52,580
如果你流式写入 我认为这

331
00:12:52,580 --> 00:12:59,630
就是它们在 x86 中被调用的内容 是的，所以

332
00:12:59,630 --> 00:13:01,340
我们再次 专注于 x86，

333
00:13:01,340 --> 00:13:02,780
因为这是占主导地位的 CPU

334
00:13:02,780 --> 00:13:04,370
架构，这只是向

335
00:13:04,370 --> 00:13:08,300
您展示英特尔如何随着时间的推移进行扩展的历史，

336
00:13:08,300 --> 00:13:10,279
这当然很

337
00:13:10,279 --> 00:13:16,639
糟糕，因为您知道 Cindy 一

338
00:13:16,639 --> 00:13:18,829
开始它被称为 MMX 和

339
00:13:18,829 --> 00:13:20,810
就像是超级原始，

340
00:13:20,810 --> 00:13:22,790
但这就像我得到了奔腾 3 天或

341
00:13:22,790 --> 00:13:24,680
等待两天，直到我们对老公的进行如此大的

342
00:13:24,680 --> 00:13:26,809
营销宣传我认为

343
00:13:26,809 --> 00:13:28,430
MMX 实际上并不代表

344
00:13:28,430 --> 00:13:30,499
英特尔害怕被起诉的任何事情，就像

345
00:13:30,499 --> 00:13:31,670
他们刚刚拿走的一样 三个字母组合

346
00:13:31,670 --> 00:13:33,649
在一起 我认为现在人们认为

347
00:13:33,649 --> 00:13:35,300
这些就像多媒体扩展，但

348
00:13:35,300 --> 00:13:37,579
当时我认为有一场诉讼

349
00:13:37,579 --> 00:13:40,879
，有人声称英特尔

350
00:13:40,879 --> 00:13:42,709
从其他公司窃取了他们的 MMX 名称，

351
00:13:42,709 --> 00:13:44,089
但后来他们发现了所有这些

352
00:13:44,089 --> 00:13:45,379
内部文件，这些文件显示 就像

353
00:13:45,379 --> 00:13:47,629
哦，它是三个随机的字母，

354
00:13:47,629 --> 00:13:48,620
今天什么都没有

355
00:13:48,620 --> 00:13:50,449
，我输掉了那场诉讼，但它一

356
00:13:50,449 --> 00:13:52,129
开始是超级永久的，它

357
00:13:52,129 --> 00:13:55,930
只能对

358
00:13:55,930 --> 00:13:58,879
32 位或 16 位整数进行一些基本操作，而这个早期

359
00:13:58,879 --> 00:14:00,339
版本也是如此，它将是

360
00:14:00,339 --> 00:14:03,379
这 CPU 不会正常

361
00:14:03,379 --> 00:14:04,939
执行系统指令，但是

362
00:14:04,939 --> 00:14:06,439
当你执行汇编指令时，

363
00:14:06,439 --> 00:14:09,079
你必须暂停系统的东西做

364
00:14:09,079 --> 00:14:11,180
sim D 然后重新开始你

365
00:14:11,180 --> 00:14:14,420
在 MMX 之后，当 SSE

366
00:14:14,420 --> 00:14:15,980
出现时，您实际上可以并行执行这些操作

367
00:14:15,980 --> 00:14:17,449
，这就是我之前所说的

368
00:14:17,449 --> 00:14:20,720
，关于如何使用原子或

369
00:14:20,720 --> 00:14:23,839
高阶 CPU 架构，我们可以让

370
00:14:23,839 --> 00:14:25,160
CPU 的不同部分做

371
00:14:25,160 --> 00:14:26,930
不同的事情 同时，

372
00:14:26,930 --> 00:14:28,490
您可以

373
00:14:28,490 --> 00:14:30,410
在城市登记簿上执行一些类似的指令，

374
00:14:30,410 --> 00:14:32,750
而我们知道

375
00:14:32,750 --> 00:14:35,600
常规 CP 登记簿上的内容 什么是 MMX，您

376
00:14:35,600 --> 00:14:37,639
不能这样做，而在现代，

377
00:14:37,639 --> 00:14:41,059
它开始于 AVX 出现时我不知道

378
00:14:41,059 --> 00:14:43,579
认为有任何我认为这

379
00:14:43,579 --> 00:14:45,050
只是命名更改，因为它们从

380
00:14:45,050 --> 00:14:48,439
120 位变为 256 位，然后

381
00:14:48,439 --> 00:14:50,689
将其称为 vx5，这

382
00:14:50,689 --> 00:14:52,220
在他们称为 bx 2 或 VX 时会有意义，

383
00:14:52,220 --> 00:14:54,319
就像他们称之为 512 和 i' 我

384
00:14:54,319 --> 00:14:55,939
在网上看过，据我所知，

385
00:14:55,939 --> 00:14:58,639
他们没有推出 1024 位的计划，

386
00:14:58,639 --> 00:15:00,620
所以这就是我们现在所处的位置

387
00:15:00,620 --> 00:15:01,399


388
00:15:01,399 --> 00:15:02,990
，这里的链接将带您

389
00:15:02,990 --> 00:15:04,759
观看来自天空的精彩视频 Jamesrandhir

390
00:15:04,759 --> 00:15:07,490
谁 就像信德语

391
00:15:07,490 --> 00:15:09,259
英特尔的设计者或布道者，他基本上

392
00:15:09,259 --> 00:15:10,999
展示了你可以做的所有很棒的事情

393
00:15:10,999 --> 00:15:12,829
是 Cindy 不是它不是一个数据库人员

394
00:15:12,829 --> 00:15:13,939
它就像它向你展示如何

395
00:15:13,939 --> 00:15:15,620
实际弯曲心形戒指 得到

396
00:15:15,620 --> 00:15:18,860
你所知道的最好的

397
00:15:18,860 --> 00:15:20,329
物超所值 和 我强烈推荐这个视频，

398
00:15:20,329 --> 00:15:22,309
就像我认为它就像一个小时那么

399
00:15:22,309 --> 00:15:23,350
长，

400
00:15:23,350 --> 00:15:26,890
所以嗯，所以我

401
00:15:26,890 --> 00:15:28,570
显然在使用 Cindy 进行权衡，这似乎是

402
00:15:28,570 --> 00:15:29,950
一件神奇的事情，或者我们并不总是

403
00:15:29,950 --> 00:15:32,560
想使用，当然在某些情况下是的 如果

404
00:15:32,560 --> 00:15:34,120
我们使用它们，我们将看到的情况将获得显着的

405
00:15:34,120 --> 00:15:36,790
性能提升，但

406
00:15:36,790 --> 00:15:38,500
棘手的事情是实际上

407
00:15:38,500 --> 00:15:40,300
实现一种使用

408
00:15:40,300 --> 00:15:42,850
矢量化指令的算法

409
00:15:42,850 --> 00:15:46,420
并不是微不足道的，正如我在某些情况下所说的那样，

410
00:15:46,420 --> 00:15:49,420
它实际上是因为在

411
00:15:49,420 --> 00:15:50,260
哥伦比亚

412
00:15:50,260 --> 00:15:52,300
对真实数据库系统中的环境做出某些假设的论文，

413
00:15:52,300 --> 00:15:54,670
他们的假设

414
00:15:54,670 --> 00:15:56,410
不成立，实际上 Cindy 会伤害

415
00:15:56,410 --> 00:15:58,480
你，所以我们将介绍什么是

416
00:15:58,480 --> 00:16:01,600
好的，这就是现在 起诉

417
00:16:01,600 --> 00:16:02,860
我们将不得不将

418
00:16:02,860 --> 00:16:04,060
东西进出寄存器是

419
00:16:04,060 --> 00:16:05,620
我们可能无法始终获得

420
00:16:05,620 --> 00:16:11,470
我们想要实现的加速的原因所以现在

421
00:16:11,470 --> 00:16:12,820
它会变得棘手的部分原因

422
00:16:12,820 --> 00:16:16,600
是没有魔法 标志和

423
00:16:16,600 --> 00:16:18,790
将匹配的编译器

424
00:16:18,790 --> 00:16:20,560
从你知道数据库

425
00:16:20,560 --> 00:16:22,660
系统的所有源代码中获取我们所有的数据库，并且能够

426
00:16:22,660 --> 00:16:26,290
为

427
00:16:26,290 --> 00:16:28,360
简单的事情瘫痪一切，但对于

428
00:16:28,360 --> 00:16:29,410
我们正在用流程查询做的更复杂的事情，

429
00:16:29,410 --> 00:16:31,120
它只是不是

430
00:16:31,120 --> 00:16:33,760
如果我们想

431
00:16:33,760 --> 00:16:35,700
在我们的数据库系统中进行矢量化，会再次发生这种情况

432
00:16:35,700 --> 00:16:37,960
人们付钱给你知道人们付钱

433
00:16:37,960 --> 00:16:40,440
给你去做这件事因为很难

434
00:16:40,440 --> 00:16:42,220
让我们看看我们如何才能真正做到

435
00:16:42,220 --> 00:16:45,490
这一点所以三种方法是

436
00:16:45,490 --> 00:16:47,320
来自编译器的自动矢量化和

437
00:16:47,320 --> 00:16:49,030
然后我们可以将提示传递给编译器

438
00:16:49,030 --> 00:16:50,890
并告诉我们我们真正想要什么

439
00:16:50,890 --> 00:16:53,320
，然后还

440
00:16:53,320 --> 00:16:55,420
使用 cpu 内在函数编写带有显式矢量化的源代码

441
00:16:55,420 --> 00:16:59,920


442
00:16:59,920 --> 00:17:02,200
他就像最容易

443
00:17:02,200 --> 00:17:03,550
使用的一样是顶部的那个，因为那

444
00:17:03,550 --> 00:17:04,959
只是希望编译器计算出来

445
00:17:04,959 --> 00:17:06,849
，底部的越多是最难

446
00:17:06,849 --> 00:17:08,680
使用的，但我们将完全控制

447
00:17:08,680 --> 00:17:10,119
进入寄存器的内容什么

448
00:17:10,119 --> 00:17:11,800
命令什么指令 再次执行

449
00:17:11,800 --> 00:17:15,220
如此易于使用，更好的

450
00:17:15,220 --> 00:17:19,240
控制，但更难写，好吧，

451
00:17:19,240 --> 00:17:22,150
所以自动向量化只是

452
00:17:22,150 --> 00:17:24,220
说编译器可以

453
00:17:24,220 --> 00:17:27,280
识别何时我们有源

454
00:17:27,280 --> 00:17:29,920
代码块在循环内部，其中

455
00:17:29,920 --> 00:17:32,740
主操作的内核在

456
00:17:32,740 --> 00:17:34,480
然后可以将该循环转换为

457
00:17:34,480 --> 00:17:37,410
向量化指令，因此对于自由

458
00:17:37,410 --> 00:17:41,610
循环来说，这很容易做到，

459
00:17:41,610 --> 00:17:43,050
但问题是简单的循环

460
00:17:43,050 --> 00:17:45,480
在我们想要加速的主要事情中不会很常见

461
00:17:45,480 --> 00:17:46,650
，即查询

462
00:17:46,650 --> 00:17:48,390
执行所有

463
00:17:48,390 --> 00:17:50,790
是的，很明显，这需要你的

464
00:17:50,790 --> 00:17:51,990
哈佛在说明中拥有支持经验

465
00:17:51,990 --> 00:17:53,580
，但

466
00:17:53,580 --> 00:17:56,550
几乎你所知道的每一个现代智能

467
00:17:56,550 --> 00:17:58,380
网络，无论你有 256 o  r 512

468
00:17:58,380 --> 00:18:00,540
实际上我不知道笔记本电脑

469
00:18:00,540 --> 00:18:04,380
可能有 avx2 但

470
00:18:04,380 --> 00:18:07,350
你知道你今天购买的任何现代至强都会有

471
00:18:07,350 --> 00:18:09,050
512 所以让我们在这里看一个例子所以

472
00:18:09,050 --> 00:18:11,850
这里我们有一个 for 循环这里

473
00:18:11,850 --> 00:18:13,110
有点像

474
00:18:13,110 --> 00:18:14,880
我们之前讨论过的向量明智原语，

475
00:18:14,880 --> 00:18:16,980
他们将拥有预定义的

476
00:18:16,980 --> 00:18:20,880
源代码来执行基本

477
00:18:20,880 --> 00:18:22,140
操作，您需要执行

478
00:18:22,140 --> 00:18:23,760
查询来处理您知道的处理数据，

479
00:18:23,760 --> 00:18:25,620
所以这样做是为了使用

480
00:18:25,620 --> 00:18:27,840
三个指针 x y&z 相同 我们

481
00:18:27,840 --> 00:18:29,340
在最开始展示的东西然后

482
00:18:29,340 --> 00:18:30,750
我们将迭代

483
00:18:30,750 --> 00:18:32,940
每个元素 X 和 Y 的每个元素并将

484
00:18:32,940 --> 00:18:36,480
它们写入一个 alpha 但缓冲区 Z 所以

485
00:18:36,480 --> 00:18:38,640
我对你们的问题

486
00:18:38,640 --> 00:18:40,650
是编译器可以自动

487
00:18:40,650 --> 00:18:43,280
矢量化你的 摇头是的，为什么

488
00:18:43,280 --> 00:18:45,840
他说的是哔哔自己

489
00:18:45,840 --> 00:18:49,530
滚动，但不是那不是，

490
00:18:49,530 --> 00:18:51,030
但那不是使用信德语的

491
00:18:51,030 --> 00:18:55,080
说明不对，所以他说在你

492
00:18:55,080 --> 00:18:57,630
循环之后是的，是的，你会认出我

493
00:18:57,630 --> 00:18:58,950
有四个车道 在指令中或

494
00:18:58,950 --> 00:19:00,780
发送给我寄存器所以我展开它

495
00:19:00,780 --> 00:19:04,500
四次然后我然后你知道然后

496
00:19:04,500 --> 00:19:07,200
我可以矢量化谁同意或

497
00:19:07,200 --> 00:19:16,740
不同意宾果游戏是的所以

498
00:19:16,740 --> 00:19:18,450
自动矢量化这是不合法的

499
00:19:18,450 --> 00:19:20,610
因为他完全正确而你

500
00:19:20,610 --> 00:19:22,620
不 在编译时知道这些是

501
00:19:22,620 --> 00:19:25,080
什么，可能是

502
00:19:25,080 --> 00:19:26,430
这些实际上指向相同

503
00:19:26,430 --> 00:19:28,680
的内存块，所以现在

504
00:19:28,680 --> 00:19:30,930
您在实际开始计算时有不可预测的副作用

505
00:19:30,930 --> 00:19:32,240


506
00:19:32,240 --> 00:19:39,120
是的，他说他可以进行全局分析

507
00:19:39,120 --> 00:19:41,690
来证明 它们是不同的

508
00:19:44,130 --> 00:19:45,570
这不是静态的 你不能

509
00:19:45,570 --> 00:19:49,920
在编译时静态地做静态 你

510
00:19:49,920 --> 00:19:51,450
知道这个词 确定你可以运行它然后

511
00:19:51,450 --> 00:19:54,300
你可以运行你的数据库系统 用

512
00:19:54,300 --> 00:19:59,660
这个函数检查它是否正确，就像

513
00:19:59,660 --> 00:20:02,550
你可能永远看不到一样

514
00:20:02,550 --> 00:20:03,840
这些实际上指向同一件事

515
00:20:03,840 --> 00:20:06,060
但你不知道的情况，因为你

516
00:20:06,060 --> 00:20:07,410
不知道你有你认识的人

517
00:20:07,410 --> 00:20:08,970
你见过数据库系统的所有可能的输入

518
00:20:08,970 --> 00:20:09,710


519
00:20:09,710 --> 00:20:23,070
是的你基本上是c 你能不能做

520
00:20:23,070 --> 00:20:25,800
乐观矢量化，

521
00:20:25,800 --> 00:20:27,480
编译器可以在这里插入某种魔法

522
00:20:27,480 --> 00:20:28,430


523
00:20:28,430 --> 00:20:31,500
做矢量化版本，或者以某种方式

524
00:20:31,500 --> 00:20:33,060
对这些人是什么进行一些分析

525
00:20:33,060 --> 00:20:35,280
，看看这是否会

526
00:20:35,280 --> 00:20:37,500
在矢量化版本中被踩踏

527
00:20:37,500 --> 00:20:40,410
，然后如果没有 继续并保留

528
00:20:40,410 --> 00:20:42,210
我的结果如果是的话回到标量

529
00:20:42,210 --> 00:20:57,780
版本我认为汤姆很好，如果你

530
00:20:57,780 --> 00:21:00,480
像你所说的那样通过所以我只是

531
00:21:00,480 --> 00:21:02,130
显示这个全局变量但是你

532
00:21:02,130 --> 00:21:04,740
必须将它传递给这个

533
00:21:04,740 --> 00:21:06,900
到这个函数，这样你

534
00:21:06,900 --> 00:21:09,060
就会知道，然后你必须知道，

535
00:21:09,060 --> 00:21:12,060
好吧，我将从

536
00:21:12,060 --> 00:21:14,130
零循环到两个最大值，

537
00:21:14,130 --> 00:21:19,770
然后检查是的，我听起来

538
00:21:19,770 --> 00:21:22,610
像很多工作，是的，

539
00:21:27,470 --> 00:21:30,919
如果 如果他宣布

540
00:21:30,919 --> 00:21:33,379
你知道所有可能的输入，你会做什么对不起 Haley 的

541
00:21:33,379 --> 00:21:38,000
分析 我让我们谈谈那个

542
00:21:38,000 --> 00:21:39,740
努力 III 实际上并不是你的

543
00:21:39,740 --> 00:21:41,179
计划，但我的意思是真正简单的

544
00:21:41,179 --> 00:21:44,149
问题是，如果我的 if Z 只是

545
00:21:44,149 --> 00:21:46,850
关闭 的内存位置 X 加 1

546
00:21:46,850 --> 00:21:51,110
现在这里会发生什么我把 X x

547
00:21:51,110 --> 00:21:55,100
和 y 写进 Z 但是现在

548
00:21:55,100 --> 00:21:58,039
当我回来时我正在为

549
00:21:58,039 --> 00:22:00,019
第二个循环而努力现在我正在努力

550
00:22:00,019 --> 00:22:02,659
X 的第二个元素这将

551
00:22:02,659 --> 00:22:04,100
完全产生 正确的结果不

552
00:22:04,100 --> 00:22:05,809
正确我们希望能够将其矢量

553
00:22:05,809 --> 00:22:07,639
化，以便

554
00:22:07,639 --> 00:22:08,990
矢量化版本的输出

555
00:22:08,990 --> 00:22:12,159
与标量版本的输出完全相同

556
00:22:12,159 --> 00:22:14,750
所以这对编译器来说很难做到这一点的原因

557
00:22:14,750 --> 00:22:18,350
句柄是它

558
00:22:18,350 --> 00:22:20,570
的性质 我们如何正确地编写 c c++

559
00:22:20,570 --> 00:22:22,009
我们正在编写此代码，以一种

560
00:22:22,009 --> 00:22:23,600
描述此算法的方式进行此

561
00:22:23,600 --> 00:22:25,820
计算，我们希望

562
00:22:25,820 --> 00:22:28,159
按顺序进行并一次写入一个

563
00:22:28,159 --> 00:22:30,230
元素将两个数字加

564
00:22:30,230 --> 00:22:32,110
在一起直接添加到此

565
00:22:32,110 --> 00:22:36,019
缓冲区中 再次，这是

566
00:22:36,019 --> 00:22:38,179
种子没有设置为

567
00:22:38,179 --> 00:22:40,100
向编译器提供正确的提示以

568
00:22:40,100 --> 00:22:41,570
认识到他们可以做到这一点你

569
00:22:41,570 --> 00:22:42,620
必须做他建议我做的任何

570
00:22:42,620 --> 00:22:44,299
事情或我描述的下一件事情

571
00:22:44,299 --> 00:22:46,639
编译器赢了

572
00:22:46,639 --> 00:22:49,700
再次，主要的收获是 GCC

573
00:22:49,700 --> 00:22:51,139
和 clang 无法

574
00:22:51,139 --> 00:22:55,399
从英特尔矢量化那么多 ICC，

575
00:22:55,399 --> 00:22:57,409
他们的专有编译器

576
00:22:57,409 --> 00:22:59,120
在这方面要好得多，但即使如此，在许多

577
00:22:59,120 --> 00:23:00,559
情况下也不会这样做，因为

578
00:23:00,559 --> 00:23:03,009
它不是 会知道这里发生

579
00:23:03,009 --> 00:23:05,149
了什么所以我们可以做什么 我们

580
00:23:05,149 --> 00:23:07,299
可以提供编译器提示告诉

581
00:23:07,299 --> 00:23:11,149
编译器我们知道有

582
00:23:11,149 --> 00:23:13,610
这段代码可以安全

583
00:23:13,610 --> 00:23:16,070
地以矢量化方式进行操作

584
00:23:16,070 --> 00:23:19,820
，所以有两种基本方式 我们可以这样

585
00:23:19,820 --> 00:23:22,490
做，要么告诉编译器

586
00:23:22,490 --> 00:23:25,100
一些我们知道的关于

587
00:23:25,100 --> 00:23:26,330
我们可以传递

588
00:23:26,330 --> 00:23:29,149
给这个函数的内存位置的信息，或者我们只是告诉

589
00:23:29,149 --> 00:23:31,190
编译器嘿你知道带你知道

590
00:23:31,190 --> 00:23:33,500
解开你的安全带取下安全带

591
00:23:33,500 --> 00:23:35,509
你的枪就像去狂野

592
00:23:35,509 --> 00:23:36,619
，做任何你想做的事我

593
00:23:36,619 --> 00:23:40,519
不在乎所以第一个是restrict

594
00:23:40,519 --> 00:23:41,389
关键字，

595
00:23:41,389 --> 00:23:44,179
这是一个我们可以添加到我们的C代码中的标志，

596
00:23:44,179 --> 00:23:45,529
或者睡眠一个

597
00:23:45,529 --> 00:23:48,019
基本上说我们知道的脉冲代码 这些

598
00:23:48,019 --> 00:23:49,519
是不同的内存位置，

599
00:23:49,519 --> 00:23:51,349
因此它可以安全地进行矢量化

600
00:23:51,349 --> 00:23:53,779
以及低于此值的任何内容，因此

601
00:23:53,779 --> 00:23:55,879
这是在 C 标准中我不知道

602
00:23:55,879 --> 00:23:56,989
是否我认为它不在

603
00:23:56,989 --> 00:23:58,999
C++ 标准中，但据您所知 正如

604
00:23:58,999 --> 00:24:01,369
我之前测试过的，它就像 GCC 和

605
00:24:01,369 --> 00:24:02,239
clang whoa

606
00:24:02,239 --> 00:24:05,839
我们会处理这个问题所以

607
00:24:05,839 --> 00:24:07,459
基本上是说我们允许

608
00:24:07,459 --> 00:24:08,479
程序员声明这些

609
00:24:08,479 --> 00:24:11,269
指针永远不会共享

610
00:24:11,269 --> 00:24:12,799
相同的数据或者你知道相同的内存

611
00:24:12,799 --> 00:24:15,200
位置 因此，

612
00:24:15,200 --> 00:24:17,479
我们在这里所做的任何事情都不会

613
00:24:17,479 --> 00:24:20,329
产生出乎意料的奇怪副作用，但

614
00:24:20,329 --> 00:24:21,440
当然这取决于我们作为

615
00:24:21,440 --> 00:24:22,549
程序员，以确保

616
00:24:22,549 --> 00:24:24,079
当我们告诉它时，我们知道我们在做什么，

617
00:24:24,079 --> 00:24:27,829
嘿 不要检查这些东西，因为你

618
00:24:27,829 --> 00:24:29,419
知道在它已经编译之后我们

619
00:24:29,419 --> 00:24:30,739
没有办法保护你知道强制

620
00:24:30,739 --> 00:24:33,769
执行另一种方法是这些 -

621
00:24:33,769 --> 00:24:35,719
这些 pragma 提示，这只是

622
00:24:35,719 --> 00:24:37,909
基本上说在这个

623
00:24:37,909 --> 00:24:41,169
函数中你不做任何事情 se

624
00:24:41,169 --> 00:24:43,639
内存检查这有点像

625
00:24:43,639 --> 00:24:48,049
一种更粗暴的力量，但更

626
00:24:48,049 --> 00:24:51,049
粗粒度的定义

627
00:24:51,049 --> 00:24:52,549
在这里进行矢量化是可以的，而在

628
00:24:52,549 --> 00:24:53,929
限制性的情况下，或者你知道

629
00:24:53,929 --> 00:24:55,729
它对单个元素的粒度更细，

630
00:24:55,729 --> 00:24:59,119
所以这个人说的是 IV 深度 说

631
00:24:59,119 --> 00:25:01,009
忽略向量矢量化依赖

632
00:25:01,009 --> 00:25:03,349
还有其他的我认为其他

633
00:25:03,349 --> 00:25:05,059
语言，比如 Cindy 上的共生体，

634
00:25:05,059 --> 00:25:06,169
好吧

635
00:25:06,169 --> 00:25:08,659
我不知道我不知道

636
00:25:08,659 --> 00:25:09,979
这个语言有多便携我认为这

637
00:25:09,979 --> 00:25:11,839
可能适用于 GCC 我不知道什么是

638
00:25:11,839 --> 00:25:13,519
叮当声 或 ICC 做一些不同的事情，

639
00:25:13,519 --> 00:25:16,190
或者就像我们使用其他

640
00:25:16,190 --> 00:25:18,649
像 OpenMP 这样的库一样，它们有

641
00:25:18,649 --> 00:25:20,989
自己的标志，它们就是

642
00:25:20,989 --> 00:25:22,039
它们的全部，我测试做同样的

643
00:25:22,039 --> 00:25:24,409
事情，没问题，

644
00:25:24,409 --> 00:25:26,179
所以再说一次主要的收获

645
00:25:26,179 --> 00:25:27,859
是我们可以告诉编译器我们

646
00:25:27,859 --> 00:25:30,679
可以做什么我们可以做什么它可以做什么

647
00:25:30,679 --> 00:25:31,999
但戴维斯的开发人员仍然对此感到困惑

648
00:25:31,999 --> 00:25:34,359
-为了保护

649
00:25:34,359 --> 00:25:36,979
自己，最后一个是通过显式

650
00:25:36,979 --> 00:25:38,619
矢量化我们将编写

651
00:25:38,619 --> 00:25:40,879
完全相同的 我们

652
00:25:40,879 --> 00:25:42,859
要执行的指令再次我们必须

653
00:25:42,859 --> 00:25:44,389
知道寄存器大小是多少我们必须

654
00:25:44,389 --> 00:25:46,059
知道数据类型正在操作

655
00:25:46,059 --> 00:25:48,979
然后现在没有

656
00:25:48,979 --> 00:25:50,569
关于实际做什么的问题，因为这些

657
00:25:50,569 --> 00:25:51,919
内在函数本质上

658
00:25:51,919 --> 00:25:54,469
是编译器替换的语法糖

659
00:25:54,469 --> 00:25:55,100
使用确切的

660
00:25:55,100 --> 00:25:57,770
指令来做任何要求

661
00:25:57,770 --> 00:26:00,410
我做的事情，内在的缺点是

662
00:26:00,410 --> 00:26:03,290
它们不可移植，这意味着如果我编译我的

663
00:26:03,290 --> 00:26:05,480
代码我写了所有的 x86

664
00:26:05,480 --> 00:26:06,980
内在函数但我现在没有运行我正在

665
00:26:06,980 --> 00:26:09,890
编译我的数据 系统来武装他们可能

666
00:26:09,890 --> 00:26:11,630
不支持，或者如果我正在编译我的

667
00:26:11,630 --> 00:26:15,200
代码并且它在 avx-512 上运行，

668
00:26:15,200 --> 00:26:16,400
然后我尝试在没有这些寄存器的机器上编译它

669
00:26:16,400 --> 00:26:18,260
它

670
00:26:18,260 --> 00:26:21,080
会失败或者它实际上可能会替换

671
00:26:21,080 --> 00:26:23,060
它们 使用操作的标量版本，

672
00:26:23,060 --> 00:26:26,300
如果它很好，我可能无法

673
00:26:26,300 --> 00:26:28,490
进入我期望的矢量化，

674
00:26:28,490 --> 00:26:32,630
所以这里

675
00:26:32,630 --> 00:26:36,530
是实际上这个 MMX 的 SSE 实现，

676
00:26:36,530 --> 00:26:39,560
EPI 这是同一个 sa 的 Symbian tation

677
00:26:39,560 --> 00:26:43,040
我在同一个文件夹中，然后

678
00:26:43,040 --> 00:26:45,500
将两个向量加在一起，现在您

679
00:26:45,500 --> 00:26:46,910
看到我必须做的是在那里我必须

680
00:26:46,910 --> 00:26:51,170
采用我的 C C++ 数字向量

681
00:26:51,170 --> 00:26:54,650
，然后将它们转换为预期的

682
00:26:54,650 --> 00:26:58,220
sim 注销向量，然后

683
00:26:58,220 --> 00:27:00,650
这里的操作是 现在做

684
00:27:00,650 --> 00:27:02,270
加法或加载东西，你

685
00:27:02,270 --> 00:27:04,880
只是在 32 位整数上做加法

686
00:27:04,880 --> 00:27:07,220
，然后把它加载到

687
00:27:07,220 --> 00:27:09,890
这个简单的向量中，

688
00:27:09,890 --> 00:27:12,110
这里很丑，双下划线

689
00:27:12,110 --> 00:27:15,380
是我们如何做这些 GCC

690
00:27:15,380 --> 00:27:17,240
定义内在函数的方式 我认为 clang

691
00:27:17,240 --> 00:27:20,570
做同样的事情，所以你可以

692
00:27:20,570 --> 00:27:22,250
像一个图书馆一样隐藏它，它有

693
00:27:22,250 --> 00:27:23,780
一堆宏技巧让你这样做，

694
00:27:23,780 --> 00:27:25,040
但没有一种振动

695
00:27:25,040 --> 00:27:26,870
每个人都用你来寻求帮助，

696
00:27:26,870 --> 00:27:28,040
你看到很多次 你看到这样的明确

697
00:27:28,040 --> 00:27:32,300
指令没问题，所以为了我们的

698
00:27:32,300 --> 00:27:35,120
目的，在我们自己的系统中，在

699
00:27:35,120 --> 00:27:36,560
你们的公司里，他们会

700
00:27:36,560 --> 00:27:37,820
做这个明确的向量矢量化，

701
00:27:37,820 --> 00:27:38,810
因为他们不会再次

702
00:27:38,810 --> 00:27:40,490
精确控制

703
00:27:40,490 --> 00:27:44,300
CPU 一切正常，现在我们知道

704
00:27:44,300 --> 00:27:47,480
如何编写 Cindy 指令，

705
00:27:47,480 --> 00:27:49,190
我们可以执行哪些 Cindy 操作，

706
00:27:49,190 --> 00:27:50,840
因此我们需要讨论的第一

707
00:27:50,840 --> 00:27:52,340
件事是

708
00:27:52,340 --> 00:27:54,260
我们应用矢量化的方向，因此

709
00:27:54,260 --> 00:27:55,570
差异是水平与垂直，

710
00:27:55,570 --> 00:27:57,890
所以 水平方向的想法是，

711
00:27:57,890 --> 00:28:01,100
我们将对单个向量内的所有元素一起应用一些操作

712
00:28:01,100 --> 00:28:03,230


713
00:28:03,230 --> 00:28:06,140
，然后产生一些

714
00:28:06,140 --> 00:28:08,570
单个输出或标量

715
00:28:08,570 --> 00:28:11,840
输出，比如说我想要我的寄存器

716
00:28:11,840 --> 00:28:13,160
有数字零一二三

717
00:28:13,160 --> 00:28:15,500
然后我可以唤起一个 Sindhi 水平

718
00:28:15,500 --> 00:28:17,360
指令，它只获取

719
00:28:17,360 --> 00:28:19,460
我向量中的所有元素，然后产生一个

720
00:28:19,460 --> 00:28:20,960
单一的标量输出，它是所有元素的总和，

721
00:28:20,960 --> 00:28:25,310
所以这个只能在

722
00:28:25,310 --> 00:28:26,750
支持作为他的

723
00:28:26,750 --> 00:28:31,390
SSE for 和 avx2 的新指令中找到 所以那大约是

724
00:28:31,390 --> 00:28:34,160
2015-2016 年 任何或任何比这更新的东西都

725
00:28:34,160 --> 00:28:36,170
应该有它下一个

726
00:28:36,170 --> 00:28:38,210
是垂直的，这里的想法

727
00:28:38,210 --> 00:28:41,120
是我们将采用两个向量应用

728
00:28:41,120 --> 00:28:43,640
一些蒸汽 关于它们的指令，

729
00:28:43,640 --> 00:28:45,260
我们将根据

730
00:28:45,260 --> 00:28:47,270
每个向量中的偏移量进行匹配，因此这

731
00:28:47,270 --> 00:28:49,430
是偏移量 0 这也是 0，然后

732
00:28:49,430 --> 00:28:50,570
我们将它们加在一起，然后我们将其

733
00:28:50,570 --> 00:28:52,340
写出到偏移量 0 在我们的 输出

734
00:28:52,340 --> 00:28:55,990
向量 所以哥伦比亚的论文

735
00:28:55,990 --> 00:29:00,100
会在此基础上做所有的事情 我

736
00:29:00,100 --> 00:29:02,840
忘记了他们为什么说他们没有这样做

737
00:29:02,840 --> 00:29:04,250
我想当时我认为他们

738
00:29:04,250 --> 00:29:05,960
实际上是他们看到的 CP 我们

739
00:29:05,960 --> 00:29:08,380


740
00:29:08,380 --> 00:29:10,580
这一次没有一切 再一次，这是更

741
00:29:10,580 --> 00:29:14,240
常见的方法，所以现在

742
00:29:14,240 --> 00:29:16,520
我们将假设我们

743
00:29:16,520 --> 00:29:18,080
有这些内在函数，然后我们

744
00:29:18,080 --> 00:29:19,720
要做这些转移垂直

745
00:29:19,720 --> 00:29:22,520
矢量化，现在我们想做

746
00:29:22,520 --> 00:29:24,740
一堆不同的事情，我们的 我们

747
00:29:24,740 --> 00:29:29,600
在我们的数据库系统中构建

748
00:29:29,600 --> 00:29:31,550
矢量化的原始操作

749
00:29:31,550 --> 00:29:33,500
，然后我们将根据这些原始操作进行构建，

750
00:29:33,500 --> 00:29:34,940
并执行更复杂的

751
00:29:34,940 --> 00:29:36,890
操作，例如连接和扫描以及

752
00:29:36,890 --> 00:29:39,880
您想要的其他内容，我

753
00:29:39,880 --> 00:29:42,290
知道您知道我有什么 处理查询时要做的事情

754
00:29:42,290 --> 00:29:44,330
o 再次我喜欢这篇

755
00:29:44,330 --> 00:29:45,770
论文，因为它

756
00:29:45,770 --> 00:29:47,240
就像所有这些

757
00:29:47,240 --> 00:29:49,040
不同的技术一样，我们

758
00:29:49,040 --> 00:29:51,080
实际上拥有源代码实现

759
00:29:51,080 --> 00:29:52,520
我有你有你如何设计所有

760
00:29:52,520 --> 00:29:53,630
这些算法和数据结构以

761
00:29:53,630 --> 00:29:55,820
利用我们所有的矢量化

762
00:29:55,820 --> 00:29:58,340
不需要，但我

763
00:29:58,340 --> 00:29:59,570
想涵盖主要的主要

764
00:29:59,570 --> 00:30:05,030
原语，好的，所以我已经

765
00:30:05,030 --> 00:30:07,280
说过了，所以这就是我们如何

766
00:30:07,280 --> 00:30:09,500
才能进行矢量化的原语操作，

767
00:30:09,500 --> 00:30:10,940
然后在其中执行更多事件

768
00:30:10,940 --> 00:30:12,140
算法和功能 我们的

769
00:30:12,140 --> 00:30:15,470
数据库系统 他们将要

770
00:30:15,470 --> 00:30:17,060
运行的系统实际上不是一个成熟的

771
00:30:17,060 --> 00:30:18,620
数据库系统 它就像一个小的

772
00:30:18,620 --> 00:30:20,570
测试平台原型 你知道

773
00:30:20,570 --> 00:30:21,470
它是

774
00:30:21,470 --> 00:30:23,510
手工编码的，无法完成

775
00:30:23,510 --> 00:30:25,100
他们试图测量的一个操作 所说的手段

776
00:30:25,100 --> 00:30:26,360
没有续集解析器有新的

777
00:30:26,360 --> 00:30:29,330
交易 VOC 查询处理，这

778
00:30:29,330 --> 00:30:30,830
也意味着他们不会

779
00:30:30,830 --> 00:30:33,320
在这些情况下实现输出，

780
00:30:33,320 --> 00:30:36,080
这通常是一个很大的负担

781
00:30:36,080 --> 00:30:39,590
在实现中加入另一件大事

782
00:30:39,590 --> 00:30:40,880
，这是我之前所说的一个重要假设，

783
00:30:40,880 --> 00:30:42,890
即在他们的

784
00:30:42,890 --> 00:30:43,850
操作环境中，他们会

785
00:30:43,850 --> 00:30:45,650
假设数据库完全适合

786
00:30:45,650 --> 00:30:48,280
CPU 缓存，这是不现实的，

787
00:30:48,280 --> 00:30:51,080
因为 l1 就像 32

788
00:30:51,080 --> 00:30:54,320
千字节 l3 可能是 64 兆，

789
00:30:54,320 --> 00:30:56,720
如果你有很多钱，就像

790
00:30:56,720 --> 00:30:57,860
没有适合的数据库一样 你知道

791
00:30:57,860 --> 00:31:01,550
你的 CPU 缓存，你会在

792
00:31:01,550 --> 00:31:02,870
春假后阅读的下一篇论文中看到的

793
00:31:02,870 --> 00:31:05,630
是，如果现在一切都不

794
00:31:05,630 --> 00:31:07,880
适合 在 CPU 缓存中，这个 Cindy 的东西

795
00:31:07,880 --> 00:31:09,340
实际上并不重要

796
00:31:09,340 --> 00:31:13,760
，除非你开始做

797
00:31:13,760 --> 00:31:15,620
轻松的操作符融合的东西，

798
00:31:15,620 --> 00:31:17,210
接下来会读到，比如如何

799
00:31:17,210 --> 00:31:20,300
真正了解你的

800
00:31:20,300 --> 00:31:22,100
操作，以便你可以 对

801
00:31:22,100 --> 00:31:24,740
CPU 缓存中的向量进行操作，然后

802
00:31:24,740 --> 00:31:26,930
您可以预取

803
00:31:26,930 --> 00:31:28,010
要操作的下一个向量的下一部分，

804
00:31:28,010 --> 00:31:30,200
以隐藏内存停顿的延迟，

805
00:31:30,200 --> 00:31:32,270
而这些都是他们不做的任何

806
00:31:32,270 --> 00:31:33,440
事情' 就像一切都可能

807
00:31:33,440 --> 00:31:35,000
CPU 缓存让我很快地翻阅它

808
00:31:35,000 --> 00:31:35,540


809
00:31:35,540 --> 00:31:39,020
好吧，他们在算法设计决策中要做的另一件大事

810
00:31:39,020 --> 00:31:40,940


811
00:31:40,940 --> 00:31:42,590
是，他们希望

812
00:31:42,590 --> 00:31:45,200
最大限度地利用 Lane，

813
00:31:45,200 --> 00:31:46,940
以便您每次调用

814
00:31:46,940 --> 00:31:49,040
指令你总是

815
00:31:49,040 --> 00:31:50,690
对你的向量中的所有数据项做有用的工作，

816
00:31:50,690 --> 00:31:52,700


817
00:31:52,700 --> 00:31:54,530
当我们谈论他们如何进行

818
00:31:54,530 --> 00:31:56,090
哈希表探测时这会更有意义，但这个想法是

819
00:31:56,090 --> 00:31:58,640
我不想说我可以放四个

820
00:31:58,640 --> 00:32:00,860
元素进入我的向量，但只有

821
00:32:00,860 --> 00:32:02,270
两个我是其中之一我实际上

822
00:32:02,270 --> 00:32:03,500
需要你拥有其余的实际上是

823
00:32:03,500 --> 00:32:05,360
垃圾我可以扔掉他们想要

824
00:32:05,360 --> 00:32:07,880
打包所有你知道的所有独特数据或

825
00:32:07,880 --> 00:32:09,260
有用数据以及每个寄存器

826
00:32:09,260 --> 00:32:10,730
的每个 指令，以便

827
00:32:10,730 --> 00:32:15,140
他们最大限度地提高利用率，

828
00:32:15,140 --> 00:32:16,310
所以让我们

829
00:32:16,310 --> 00:32:18,290
从他们将定义的基本原理开始，

830
00:32:18,290 --> 00:32:20,060
选择一个低睡眠的商店，然后

831
00:32:20,060 --> 00:32:21,710
是聚集和分散，然后我们将

832
00:32:21,710 --> 00:32:23,660
看看我们如何使用 t 进行

833
00:32:23,660 --> 00:32:25,400
扫描和哈希表以及

834
00:32:25,400 --> 00:32:30,410
直方图可以，所以选择加载

835
00:32:30,410 --> 00:32:33,500
这里的想法是我们想要获取

836
00:32:33,500 --> 00:32:35,210
一些

837
00:32:35,210 --> 00:32:38,150
我们

838
00:32:38,150 --> 00:32:40,880
在我们的 l1 缓存中的一些内存块，然后我们想要

839
00:32:40,880 --> 00:32:42,470
将它们写到一个 注册但我们

840
00:32:42,470 --> 00:32:44,810
想提供这个掩码来告诉我们

841
00:32:44,810 --> 00:32:46,190
我们实际想要存储哪些元素，

842
00:32:46,190 --> 00:32:48,620
因为如果没有这个，我们必须把

843
00:32:48,620 --> 00:32:51,410
所有东西都像 all 一样连续写出来

844
00:32:51,410 --> 00:32:54,410
，这意味着如果我们只

845
00:32:54,410 --> 00:32:55,670
想要某些项目，

846
00:32:55,670 --> 00:32:58,540
我们就必须复制它 然后你知道，

847
00:32:58,540 --> 00:33:02,150
在我们的 CPU 缓存中，然后

848
00:33:02,150 --> 00:33:03,710
按照我们想要的方式对齐，然后直接

849
00:33:03,710 --> 00:33:05,180
进入我们的寄存器，所以这个想法就像我们

850
00:33:05,180 --> 00:33:07,340
可以拿一块内存，里面有

851
00:33:07,340 --> 00:33:08,330
一些我们不想要和不想

852
00:33:08,330 --> 00:33:10,340
提供的东西 这个掩码和这告诉我们如何

853
00:33:10,340 --> 00:33:12,380
正确地填充寄存器，

854
00:33:12,380 --> 00:33:13,970
所以通道是这样的，这里的掩码

855
00:33:13,970 --> 00:33:16,250
偏移量对应于一个偏移量

856
00:33:16,250 --> 00:33:18,530
和向量，所以我们做的第一件事是

857
00:33:18,530 --> 00:33:20,750
查看该位设置为掩码的第一个元素

858
00:33:20,750 --> 00:33:23,140
零所以我们要跳过

859
00:33:23,140 --> 00:33:25,190
什么是什么' 就在这里，

860
00:33:25,190 --> 00:33:26,570
我们没有别的东西想写到

861
00:33:26,570 --> 00:33:29,330
这条巷子里，然后我们进入这里

862
00:33:29,330 --> 00:33:31,160
的那个，这会在第一个偏移处告诉我们，

863
00:33:31,160 --> 00:33:34,460


864
00:33:34,460 --> 00:33:35,720
每次我们有一个这样的想法时，我们一直在写这样的想法

865
00:33:35,720 --> 00:33:37,460
这里有一些光标

866
00:33:37,460 --> 00:33:38,990
会复制出

867
00:33:38,990 --> 00:33:40,370
内存位置的内存地址中的内容

868
00:33:40,370 --> 00:33:42,950
，然后当我们移动到下一位时，如果

869
00:33:42,950 --> 00:33:44,300
还有另一个，我们会将

870
00:33:44,300 --> 00:33:46,400
光标移动一个，即使这

871
00:33:46,400 --> 00:33:48,950
也是偏移量，否则我会偏移 在我们的

872
00:33:48,950 --> 00:33:50,450
向量中，我们从内存的偏移量零开始，

873
00:33:50,450 --> 00:33:52,160
因为我们不知道我们

874
00:33:52,160 --> 00:33:54,170
没有为所有设置为零写任何东西，

875
00:33:54,170 --> 00:33:56,090
所以现在这将被映射到那个

876
00:33:56,090 --> 00:33:58,220
，我们在这里写下

877
00:33:58,220 --> 00:33:59,390
同样的事情 下一个有一个

878
00:33:59,390 --> 00:34:01,520
0 所以我们跳过现在我们有一个 1

879
00:34:01,520 --> 00:34:03,860
然后光标移到这里这个

880
00:34:03,860 --> 00:34:06,470
V 我们把它写到向量中向上和向上偏移 3

881
00:34:06,470 --> 00:34:11,570
选择性存储

882
00:34:11,570 --> 00:34:13,909
与我们相反 有

883
00:34:13,909 --> 00:34:16,130
我们的向量，我们想获取

884
00:34:16,130 --> 00:34:18,020
它的 e 的内容 元素并将其

885
00:34:18,020 --> 00:34:21,139
写出到 2 到内存中，所以车道再次

886
00:34:21,139 --> 00:34:23,480
匹配，就像以前一样，所以我们可以

887
00:34:23,480 --> 00:34:25,340
从零开始，这是说我们

888
00:34:25,340 --> 00:34:27,139
不想复制任何东西，然后

889
00:34:27,139 --> 00:34:29,000
我们到达 1，然后它会

890
00:34:29,000 --> 00:34:30,620
偏移

891
00:34:30,620 --> 00:34:32,090
量和向量的质量偏移量相同，然后我们将

892
00:34:32,090 --> 00:34:33,530
它写入内存中的第一个位置

893
00:34:33,530 --> 00:34:36,830
，然后从 0 1 跳过相同的内容，

894
00:34:36,830 --> 00:34:41,449
然后在那里读取它，

895
00:34:41,449 --> 00:34:44,230
这是另一个扰流板

896
00:34:44,230 --> 00:34:47,909
本文的这一点

897
00:34:47,909 --> 00:34:50,760
是没有 Cindy 指令没有 Zeon

898
00:34:50,760 --> 00:34:52,649
目前不支持这样做，

899
00:34:52,649 --> 00:34:55,349
就像使用单个指令一样，它

900
00:34:55,349 --> 00:34:57,240
必须模拟执行其他半

901
00:34:57,240 --> 00:34:59,460
操作，每年我总是

902
00:34:59,460 --> 00:35:01,589
谷歌看看是否检查谷歌

903
00:35:01,589 --> 00:35:02,670
以查看是否选择 像

904
00:35:02,670 --> 00:35:06,839
这种负载的存储已在

905
00:35:06,839 --> 00:35:09,359
x86 中实现，唯一出现或

906
00:35:09,359 --> 00:35:11,099
释放的东西是哥伦比亚论文

907
00:35:11,099 --> 00:35:13,559
，描述了我

908
00:35:13,559 --> 00:35:16,140
从这门课上幻灯片的技术，或者

909
00:35:16,140 --> 00:35:18,829
韩国或威斯康星州的人偷了我的幻灯片和

910
00:35:18,829 --> 00:35:21,420
tal 关于同样的事情，我将再次

911
00:35:21,420 --> 00:35:23,369
看到它们的样子，所以

912
00:35:23,369 --> 00:35:27,119
再次这意味着你也知道

913
00:35:27,119 --> 00:35:28,380
你不能以原子方式执行此

914
00:35:28,380 --> 00:35:30,420
操作，这是使这项工作

915
00:35:30,420 --> 00:35:32,760
以及他们正在做什么的想法的多个指令 是

916
00:35:32,760 --> 00:35:34,230
您实际上再次想要这个的原因

917
00:35:34,230 --> 00:35:37,130
是我不想让

918
00:35:37,130 --> 00:35:39,839
您知道在加载和写入之前将内存块取出

919
00:35:39,839 --> 00:35:43,140
并复制过来，永远不要再

920
00:35:43,140 --> 00:35:44,789
按照我想要的方式排列

921
00:35:44,789 --> 00:35:46,880
并加载它并理想地取出它，

922
00:35:46,880 --> 00:35:49,109
如果我能在单个结构中做到这一点，

923
00:35:49,109 --> 00:35:50,430
那会很棒，但它并不

924
00:35:50,430 --> 00:35:53,160
存在，下一个将是

925
00:35:53,160 --> 00:35:56,760
这个分散和聚集，所以

926
00:35:56,760 --> 00:35:59,069
与聚集的想法是一样的 我们

927
00:35:59,069 --> 00:36:00,510
有我们的索引向量，它与

928
00:36:00,510 --> 00:36:04,260
我们的值向量对齐，我们想要获取我们

929
00:36:04,260 --> 00:36:05,700
想要获取内存中的元素

930
00:36:05,700 --> 00:36:08,520
，然后将它们写在我们向量中的两个不同

931
00:36:08,520 --> 00:36:11,609
位置，因此

932
00:36:11,609 --> 00:36:13,230
将它们视为从零到

933
00:36:13,230 --> 00:36:15,599
五 所以当我在这里看这个东西时

934
00:36:15,599 --> 00:36:18,049
，索引向量完全说明了 t to

935
00:36:18,049 --> 00:36:20,730
right which is here right it into

936
00:36:20,730 --> 00:36:23,819
my register of the first lane 然后我到

937
00:36:23,819 --> 00:36:26,640
这里偏移一个拿你知道拿

938
00:36:26,640 --> 00:36:29,069
内存中的偏移一个写出

939
00:36:29,069 --> 00:36:31,650
来到第二个车道或第一个

940
00:36:31,650 --> 00:36:33,119
车道任何人我会说你 ' 正在考虑

941
00:36:33,119 --> 00:36:34,829
这样做，到目前为止，对于所有其他

942
00:36:34,829 --> 00:36:38,579
人，我不认为

943
00:36:38,579 --> 00:36:41,039
实际上我认为至强现在支持这

944
00:36:41,039 --> 00:36:42,779
两个选择性收集

945
00:36:42,779 --> 00:36:44,069
和选择性收集有

946
00:36:44,069 --> 00:36:45,690
选择性收集和分散所以你

947
00:36:45,690 --> 00:36:47,640
可以这样做 这将是一条

948
00:36:47,640 --> 00:36:49,770
指令，但不会在

949
00:36:49,770 --> 00:36:52,289
一个周期内完成，因为 l1

950
00:36:52,289 --> 00:36:55,319
每个周期只能执行一两次加载和存储，

951
00:36:55,319 --> 00:36:57,359
所以如果我有一堆东西，

952
00:36:57,359 --> 00:36:59,549
如果我要填充一个大寄存器

953
00:36:59,549 --> 00:37:01,800


954
00:37:01,800 --> 00:37:06,530
使用这种技术可能需要很多周期 是的 我

955
00:37:12,260 --> 00:37:14,580
知道我不认为艾米丽我认为

956
00:37:14,580 --> 00:37:17,080
它实际上支持这个是的

957
00:37:17,080 --> 00:37:20,270
[音乐]

958
00:37:21,330 --> 00:37:23,400
你能用你能用选择性

959
00:37:23,400 --> 00:37:25,080
收集来模拟上次的选择性

960
00:37:25,080 --> 00:37:27,390
加载存储吗 是的，

961
00:37:27,390 --> 00:37:28,680
我不认为酮糖喜欢纸

962
00:37:28,680 --> 00:37:30,780
描述它，但它又是

963
00:37:30,780 --> 00:37:31,920
主要内容，所以它不是一个

964
00:37:31,920 --> 00:37:35,730
像这样的指令可以

965
00:37:35,730 --> 00:37:38,220
再次分散是相反的，我们将

966
00:37:38,220 --> 00:37:41,820
在寄存器中获取元素，然后

967
00:37:41,820 --> 00:37:42,960
将它们写到

968
00:37:42,960 --> 00:37:44,730
此处的不同位置，因此对于此处的第一个元素

969
00:37:44,730 --> 00:37:46,500
索引向量，我

970
00:37:46,500 --> 00:37:48,960
也在写入内存位置，我

971
00:37:48,960 --> 00:37:52,650
对其他所有内容都做同样的事情，所以我

972
00:37:52,650 --> 00:37:54,930
已经在

973
00:37:54,930 --> 00:37:56,340
收集散布没有真正

974
00:37:56,340 --> 00:37:59,370
并行执行之前说过这个定律，因为我们只能

975
00:37:59,370 --> 00:38:02,880
在一个中加载这么多东西 单周期

976
00:38:02,880 --> 00:38:04,920
收集仅在

977
00:38:04,920 --> 00:38:09,090
较新的词中受支持，因为 2014 年

978
00:38:09,090 --> 00:38:11,220
avx2 在房子里出现之前

979
00:38:11,220 --> 00:38:13,650
它不支持，然后再次

980
00:38:13,650 --> 00:38:16,140
这些是你必须实现这些或

981
00:38:16,140 --> 00:38:19,080
使用多个 CPU 指令来模拟它们

982
00:38:19,080 --> 00:38:22,140
好吗 好吧，

983
00:38:22,140 --> 00:38:23,670
忘记东西很好，所以我们

984
00:38:23,670 --> 00:38:25,230
现在有了这些打印机，让我们谈谈

985
00:38:25,230 --> 00:38:27,840
我们如何扫描哈希表和

986
00:38:27,840 --> 00:38:29,940
直方图的分区，这篇论文

987
00:38:29,940 --> 00:38:31,890
还谈到了如何 o 你加入了排序

988
00:38:31,890 --> 00:38:34,050
和布隆过滤器 我不这么认为我

989
00:38:34,050 --> 00:38:35,360
不知道他们是否谈论如何做

990
00:38:35,360 --> 00:38:37,260
cindy 哈希函数 但我们

991
00:38:37,260 --> 00:38:40,020
也会在稍后介绍但我们将

992
00:38:40,020 --> 00:38:41,580
在春假后介绍这些我们会

993
00:38:41,580 --> 00:38:44,400
在

994
00:38:44,400 --> 00:38:46,770
基数分区散列连接或

995
00:38:46,770 --> 00:38:49,560
光子排序技术的部分讨论如何做到这一点让我

996
00:38:49,560 --> 00:38:50,880
谈谈排序合并连接，所以我们会

997
00:38:50,880 --> 00:38:52,410
在春假之后更详细地介绍这些

998
00:38:52,410 --> 00:38:53,760
，我想我们也会讨论

999
00:38:53,760 --> 00:38:55,320
这个 但是这个很容易

1000
00:38:55,320 --> 00:38:57,510
弄清楚，好吧，所以再一次

1001
00:38:57,510 --> 00:38:59,640
没有任何效果，因为它们

1002
00:38:59,640 --> 00:39:01,500
很快就会好起来，因为假设

1003
00:39:01,500 --> 00:39:02,520
一切都适合 CPU 缓存，

1004
00:39:02,520 --> 00:39:04,200
他们还会做出另一个重大

1005
00:39:04,200 --> 00:39:05,610
假设，我之前应该提到

1006
00:39:05,610 --> 00:39:08,310
的是他们 '将在那里操作以

1007
00:39:08,310 --> 00:39:10,950
假设它们的所有键或 32 位以及

1008
00:39:10,950 --> 00:39:13,110
所有指向元组的指针都是 32 位，

1009
00:39:13,110 --> 00:39:15,599
因为它们再次在 201

1010
00:39:15,599 --> 00:39:19,259
个 6 位寄存器上操作

1011
00:39:19,259 --> 00:39:23,789
，因此对于必须为 64 位的键和值对在

1012
00:39:23,789 --> 00:39:25,559
实数中 内存数据库系统中的数据

1013
00:39:25,559 --> 00:39:27,059
值很抱歉 电池

1014
00:39:27,059 --> 00:39:28,140
将成为发布元组

1015
00:39:28,140 --> 00:39:30,380
指针定律 那些将是 64 位

1016
00:39:30,380 --> 00:39:33,390
然后键通常不仅仅是

1017
00:39:33,390 --> 00:39:35,430
你知道 32 或 64 位

1018
00:39:35,430 --> 00:39:36,690
有时你可以有一个复合键

1019
00:39:36,690 --> 00:39:39,660
，如果你有那些然后 那么

1020
00:39:39,660 --> 00:39:41,549
这些技术中的许多都不起作用，因为现在

1021
00:39:41,549 --> 00:39:43,019
你不能很好地对齐

1022
00:39:43,019 --> 00:39:46,829
半寄存器中的两个通道，

1023
00:39:46,829 --> 00:39:49,529
好吧，让我们看看你如何矢量我

1024
00:39:49,529 --> 00:39:51,539
选择了扫描，所以我们在谈论查询处理之前解决了这两个

1025
00:39:51,539 --> 00:39:53,309
例子

1026
00:39:53,309 --> 00:39:56,069
这就是我们如何做一个

1027
00:39:56,069 --> 00:39:58,109
分支版本和一个无分支版本，

1028
00:39:58,109 --> 00:40:00,180
为分支版本做正确的扫描

1029
00:40:00,180 --> 00:40:01,859
你有一个 if 子句

1030
00:40:01,859 --> 00:40:03,900
你会先检查谓词，

1031
00:40:03,900 --> 00:40:05,819
然后如果它匹配，那么你

1032
00:40:05,819 --> 00:40:07,229
复制元组并在输出缓冲区中

1033
00:40:07,229 --> 00:40:09,239
然后分支离开版本 你

1034
00:40:09,239 --> 00:40:12,150
总是复制它 然后你检查

1035
00:40:12,150 --> 00:40:15,019
这个 你通过使用这个检查它 你知道

1036
00:40:15,019 --> 00:40:17,339
按位计算你知道的所有比较

1037
00:40:17,339 --> 00:40:18,630
操作 所以它不是一个真正的分支

1038
00:40:18,630 --> 00:40:21,469
然后基于

1039
00:40:21,469 --> 00:40:24,119
这个比较的输出告诉

1040
00:40:24,119 --> 00:40:25,859
你你是将输出向量的偏移量

1041
00:40:25,859 --> 00:40:28,529
增加 1 还是 0，然后

1042
00:40:28,529 --> 00:40:29,670
确定你是否

1043
00:40:29,670 --> 00:40:31,109
回来覆盖

1044
00:40:31,109 --> 00:40:33,029
你你复制它的最后一个，因为你不

1045
00:40:33,029 --> 00:40:36,509
想要它所有 是的，我们解决了

1046
00:40:36,509 --> 00:40:38,700
这个问题 向量中的这个图购买了

1047
00:40:38,700 --> 00:40:41,640
人们，其中算法的无分支

1048
00:40:41,640 --> 00:40:43,140
版本几乎总是具有

1049
00:40:43,140 --> 00:40:44,519
固定成本，因为无论谓词的选择性如何，您都在做相同

1050
00:40:44,519 --> 00:40:45,569
数量的工作。

1051
00:40:45,569 --> 00:40:48,599


1052
00:40:48,599 --> 00:40:50,519
分支情况下，当您具有

1053
00:40:50,519 --> 00:40:53,039
低选择性或非常高的选择性时，

1054
00:40:53,039 --> 00:40:56,489
它会比无分支情况做得更好，

1055
00:40:56,489 --> 00:40:58,559
但在此中间部分，您

1056
00:40:58,559 --> 00:41:00,989
知道

1057
00:41:00,989 --> 00:41:02,819
我们在 CPU 中支付的分支预测错误会变得

1058
00:41:02,819 --> 00:41:05,180
越来越高，因此您知道

1059
00:41:05,180 --> 00:41:07,349
有 现金娃娃或管道

1060
00:41:07,349 --> 00:41:11,269
冲洗必须知道撤消我们

1061
00:41:11,269 --> 00:41:14,039
错误预测的分支开始你知道这

1062
00:41:14,039 --> 00:41:17,880
是一个很大的瓶颈好吧所以在

1063
00:41:17,880 --> 00:41:20,759
矢量化选择扫描操作中我们

1064
00:41:20,759 --> 00:41:23,099
不能做br 锚定版本，因为

1065
00:41:23,099 --> 00:41:25,440


1066
00:41:25,440 --> 00:41:28,570
在我们的发送

1067
00:41:28,570 --> 00:41:30,490
结构中没有 if 子句的概念或概念，所以他们将做一个

1068
00:41:30,490 --> 00:41:33,220
矢量化的无分支版本，所以

1069
00:41:33,220 --> 00:41:35,170
这是算法的大致近似，

1070
00:41:35,170 --> 00:41:37,600
但现在我们要

1071
00:41:37,600 --> 00:41:40,180
扫描我们的 表，而在我

1072
00:41:40,180 --> 00:41:41,890
一次得到一个元组之前，

1073
00:41:41,890 --> 00:41:43,900
现在我要得到一个向量元组，

1074
00:41:43,900 --> 00:41:46,270
而不是说与寄存器

1075
00:41:46,270 --> 00:41:47,920
大小有关的是它是四个四个元素

1076
00:41:47,920 --> 00:41:49,630
还是十六个元素或八个，

1077
00:41:49,630 --> 00:41:51,760
不管我们 获得一个向量，然后

1078
00:41:51,760 --> 00:41:53,680
我们将加载我们想要

1079
00:41:53,680 --> 00:41:55,630
再次进行比较的键，假设我们只

1080
00:41:55,630 --> 00:41:57,580
需要查看一个键

1081
00:41:57,580 --> 00:42:01,570
并将其加载到一个键向量中，并且在 Tsim

1082
00:42:01,570 --> 00:42:03,640
中认为这又是语法

1083
00:42:03,640 --> 00:42:05,320
糖 实际上并不是真正的

1084
00:42:05,320 --> 00:42:06,580
如何编写此代码，没有

1085
00:42:06,580 --> 00:42:10,330
cindy-lou 函数，然后我们进行

1086
00:42:10,330 --> 00:42:11,380
相同的比较和

1087
00:42:11,380 --> 00:42:13,270
无分支扫描，我们正在执行

1088
00:42:13,270 --> 00:42:14,770
位操作以查看是否匹配

1089
00:42:14,770 --> 00:42:16,660
，但随后我们 写我们的 m

1090
00:42:16,660 --> 00:42:21,640
在这里询问我们的寄存器然后

1091
00:42:21,640 --> 00:42:23,650
这是说如果

1092
00:42:23,650 --> 00:42:26,530
我们从表中获得的偏移量处的元

1093
00:42:26,530 --> 00:42:28,270
组满足我们的

1094
00:42:28,270 --> 00:42:30,250
谓词，我们设置一个如果它

1095
00:42:30,250 --> 00:42:31,540
不满足谓词它被设置为

1096
00:42:31,540 --> 00:42:34,420
零，然后现在我们采用该掩码，现在

1097
00:42:34,420 --> 00:42:36,790
对存储进行选择以复制

1098
00:42:36,790 --> 00:42:39,310
我们想要匹配

1099
00:42:39,310 --> 00:42:41,080
我们的谓词的元组在我们的掩码中输入到我们的

1100
00:42:41,080 --> 00:42:43,770
输出缓冲区，然后我们只需要

1101
00:42:43,770 --> 00:42:47,220
我们采用数字的基数

1102
00:42:47,220 --> 00:42:51,010
我们在掩码向量中的那些

1103
00:42:51,010 --> 00:42:52,690
告诉我们我们的偏移量应该是多少，

1104
00:42:52,690 --> 00:42:54,340


1105
00:42:54,340 --> 00:42:55,660
如果你在 for 外观之外做更多的工作，

1106
00:42:55,660 --> 00:42:56,740
以确保我们不会保留

1107
00:42:56,740 --> 00:42:57,970
不匹配的东西，那么还有更多的循环 最后

1108
00:42:57,970 --> 00:43:00,280
一次迭代，但我现在忽略了，

1109
00:43:00,280 --> 00:43:04,090
所以这将是一个信德语负载

1110
00:43:04,090 --> 00:43:06,310
这将是一个信德语比较

1111
00:43:06,310 --> 00:43:08,020
有两条指令，因为

1112
00:43:08,020 --> 00:43:09,970
你必须向量大于

1113
00:43:09,970 --> 00:43:11,260
等于，向量小于

1114
00:43:11,260 --> 00:43:12,910
等于但 再一次，那只是

1115
00:43:12,910 --> 00:43:14,740
在 ou 闲逛 r Sidney 注册这

1116
00:43:14,740 --> 00:43:17,140
没什么大不了的，然后这是一个 sim D 存储

1117
00:43:17,140 --> 00:43:20,080
，现在从 Deb 中获取选择性存储掩码

1118
00:43:20,080 --> 00:43:22,720
，从这里复制我们的

1119
00:43:22,720 --> 00:43:23,920
两个螺栓，我准备好我们的输出缓冲区

1120
00:43:23,920 --> 00:43:28,080
，这将位于内存中，是的，

1121
00:43:28,260 --> 00:43:31,330
全部 设置在输出缓冲区中，所以

1122
00:43:31,330 --> 00:43:34,390
这里再次出售这是说明问题，

1123
00:43:34,390 --> 00:43:36,400
但是我们在这里有这个输出缓冲区

1124
00:43:36,400 --> 00:43:39,220
，我们在眼睛中跟踪

1125
00:43:39,220 --> 00:43:41,140
我应该在哪里

1126
00:43:41,140 --> 00:43:42,520
写入匹配的元组的起始位置

1127
00:43:42,520 --> 00:43:44,500
实际上更容易理解

1128
00:43:44,500 --> 00:43:47,160
如果 你回到标量版本

1129
00:43:47,160 --> 00:43:51,400
对吧，我们去吧，

1130
00:43:51,400 --> 00:43:54,670
所以我等于零我总是复制

1131
00:43:54,670 --> 00:43:58,330
到当前的偏移量 I 如果元组

1132
00:43:58,330 --> 00:44:00,970
匹配那么这个 M 标志将被设置为

1133
00:44:00,970 --> 00:44:03,430
1 所以我想保留我

1134
00:44:03,430 --> 00:44:06,670
在这里复制的任何内容 所以我在 I 中添加了

1135
00:44:06,670 --> 00:44:08,140
加 1，这样当我现在回来

1136
00:44:08,140 --> 00:44:10,720
时，我正在下一个

1137
00:44:10,720 --> 00:44:12,520
偏移量处写入并且我不会用

1138
00:44:12,520 --> 00:44:14,410
我复制的最后一件事进行破坏，如果这不

1139
00:44:14,410 --> 00:44:17,650
匹配那么 0 那么我 下次来时覆盖，

1140
00:44:17,650 --> 00:44:18,670
因为我

1141
00:44:18,670 --> 00:44:20,800
不想保留我写的最后一件事，所以

1142
00:44:20,800 --> 00:44:23,350
在矢量化的情况下，这个操作在这里

1143
00:44:23,350 --> 00:44:24,970
你想计算你拥有的数量，

1144
00:44:24,970 --> 00:44:26,830
它会告诉我们如何

1145
00:44:26,830 --> 00:44:28,450
向前移动偏移量，你实际上可以

1146
00:44:28,450 --> 00:44:30,400
做到这一点，它被称为等级

1147
00:44:30,400 --> 00:44:32,619
指令你可以在 CPU 中非常有效地执行此操作，

1148
00:44:32,619 --> 00:44:33,700
如果你取一个

1149
00:44:33,700 --> 00:44:35,860
向量并说计算其中

1150
00:44:35,860 --> 00:44:37,660
的数字，这是一种

1151
00:44:37,660 --> 00:44:40,290
水平向量化的例子，

1152
00:44:40,290 --> 00:44:42,280
好吧，让我们看一个

1153
00:44:42,280 --> 00:44:43,270
真实的例子，

1154
00:44:43,270 --> 00:44:45,910
好吧，让我们说 现在我们将查询替换

1155
00:44:45,910 --> 00:44:48,369
为实际值，我们希望

1156
00:44:48,369 --> 00:44:49,869
找到键

1157
00:44:49,869 --> 00:44:51,970
大于等于 0 且键

1158
00:44:51,970 --> 00:44:54,460
小于字母 U 的所有匹配元组，所以假设现在

1159
00:44:54,460 --> 00:44:57,880
我们的表看起来像这样，我们

1160
00:44:57,880 --> 00:45:01,510
有键 Jo  y su X 所以为了

1161
00:45:01,510 --> 00:45:02,859
使用比较，我们首先将其

1162
00:45:02,859 --> 00:45:05,260
复制到我们的关键向量中

1163
00:45:05,260 --> 00:45:08,530
，这就是这一步，然后现在

1164
00:45:08,530 --> 00:45:10,330
我们做我们的模拟来比较正确，

1165
00:45:10,330 --> 00:45:11,470
这就是这里的部分，我们会

1166
00:45:11,470 --> 00:45:14,140
变坏 我们遇到了但得到 出我们的掩码，

1167
00:45:14,140 --> 00:45:15,760
这将告诉我们这些

1168
00:45:15,760 --> 00:45:18,910
键中的哪些实际匹配，然后现在我们

1169
00:45:18,910 --> 00:45:21,910
已经预先计算了所有设置的映射，

1170
00:45:21,910 --> 00:45:23,109
这只是我们可以预定义的内容

1171
00:45:23,109 --> 00:45:24,850
和我们的源代码一次，这

1172
00:45:24,850 --> 00:45:27,790
只是说在处的偏移量 你知道

1173
00:45:27,790 --> 00:45:30,430
这里的隐式偏移量对应

1174
00:45:30,430 --> 00:45:33,850
于内存中的偏移量 0，直到

1175
00:45:33,850 --> 00:45:36,220
你知道 1 2 3 4 5 所以现在我们用

1176
00:45:36,220 --> 00:45:38,500
它来做我们的 sim D 选择性存储，

1177
00:45:38,500 --> 00:45:41,109
如果我有一个皮肤就是这里所说

1178
00:45:41,109 --> 00:45:44,650
的 1 在这里，我会知道

1179
00:45:44,650 --> 00:45:46,570
我在这里匹配的偏移量应该

1180
00:45:46,570 --> 00:45:48,520
进入这里的第一个位置，所以现在

1181
00:45:48,520 --> 00:45:50,890
这些只是这里的偏移量，所以我正在

1182
00:45:50,890 --> 00:45:52,869
匹配这样的元组

1183
00:45:52,869 --> 00:45:55,990
，小头鼠海豚匹配我的 cindy 比较

1184
00:45:55,990 --> 00:45:59,140
在这个偏移量可以是 发现你知道我正在

1185
00:45:59,140 --> 00:46:01,599
写那个偏移量是什么

1186
00:46:01,599 --> 00:46:03,760
然后我现在要回去说哇我

1187
00:46:03,760 --> 00:46:06,220
有偏移量 134 如果我需要

1188
00:46:06,220 --> 00:46:08,560
在我的

1189
00:46:08,560 --> 00:46:10,570
微型计划树中实现上面的键我会回到这里并

1190
00:46:10,570 --> 00:46:12,700
跳转 到那个偏移量复制出

1191
00:46:12,700 --> 00:46:16,470
实际的关键权利是这样清楚的

1192
00:46:16,470 --> 00:46:19,570
在我看来，这就像

1193
00:46:19,570 --> 00:46:21,339
你可能会

1194
00:46:21,339 --> 00:46:22,900
从本次讲座中得到的最有用

1195
00:46:22,900 --> 00:46:25,210
的东西，就像这里有一些你实际上可以

1196
00:46:25,210 --> 00:46:26,470
做的事情，我们

1197
00:46:26,470 --> 00:46:29,440
现在可以在我们自己的系统中真正做到这一点吗，神奇的

1198
00:46:29,440 --> 00:46:31,270
是这个抵消

1199
00:46:31,270 --> 00:46:35,349
就像我说的那样，如果你去

1200
00:46:35,349 --> 00:46:37,930
谷歌有选择地存储，你会发现

1201
00:46:37,930 --> 00:46:39,190
我的幻灯片的哥伦比亚论文和

1202
00:46:39,190 --> 00:46:40,599
我复制幻灯片的人以及我知道复制我的幻灯片的

1203
00:46:40,599 --> 00:46:41,920
原因

1204
00:46:41,920 --> 00:46:43,930
是他们没有 不知道这是什么，他们

1205
00:46:43,930 --> 00:46:47,109
总是包括这个 ju y su x joy 是我的

1206
00:46:47,109 --> 00:46:49,480
第一个 PG 学生，对，这就是为什么他的

1207
00:46:49,480 --> 00:46:51,010
名字在这里，所以你去看

1208
00:46:51,010 --> 00:46:53,050
一堆其他幻灯片，果然就像快乐很糟糕一样，

1209
00:46:53,050 --> 00:46:54,460


1210
00:46:54,460 --> 00:46:56,640
他们复制了一个极客 整个

1211
00:46:56,640 --> 00:46:59,680
是的，好的，好的，我不在乎

1212
00:46:59,680 --> 00:47:02,950
这很好，所以让我们看看

1213
00:47:02,950 --> 00:47:04,630
你的表演者能从中得到什么好处

1214
00:47:04,630 --> 00:47:06,430
，所以对于这个，他们会对

1215
00:47:06,430 --> 00:47:08,140
我做四个车道登记，

1216
00:47:08,140 --> 00:47:10,030
他们实际上会比较 针对

1217
00:47:10,030 --> 00:47:13,030
两种 CPU 架构，所以这个是她的

1218
00:47:13,030 --> 00:47:14,980
在这里听说过

1219
00:47:14,980 --> 00:47:17,589
至强 phi 的至强 phi 你父亲在英特尔工作的

1220
00:47:17,589 --> 00:47:20,800
朋友很少有人

1221
00:47:20,800 --> 00:47:22,810
用协处理器编写至强 Phi 英特尔

1222
00:47:22,810 --> 00:47:25,599
曾经出售这种外观有

1223
00:47:25,599 --> 00:47:27,220
许多不同的外形因素

1224
00:47:27,220 --> 00:47:28,480
最简单的方法 想想

1225
00:47:28,480 --> 00:47:31,540
这就像他们的 GPU 版本

1226
00:47:31,540 --> 00:47:33,040
是用于高度并行

1227
00:47:33,040 --> 00:47:35,140
计算的，所以你不会像

1228
00:47:35,140 --> 00:47:36,640


1229
00:47:36,640 --> 00:47:39,400


1230
00:47:39,400 --> 00:47:41,080
从 Nvidia 和 他们的

1231
00:47:41,080 --> 00:47:45,520
GPU 可能有 60 或 70 个内核，

1232
00:47:45,520 --> 00:47:47,230
但这些内核实际上

1233
00:47:47,230 --> 00:47:50,020
比 GPU 内核更复杂，它们

1234
00:47:50,020 --> 00:47:52,119
基本上类似于 Intel Pentium 4

1235
00:47:52,119 --> 00:47:53,619
架构或

1236
00:47:53,619 --> 00:47:55,060
稍后的 atom 架构，因此像低

1237
00:47:55,060 --> 00:47:57,910
功耗非常简单，但您会得到

1238
00:47:57,910 --> 00:47:59,530
当然比你知道的更多，然后

1239
00:47:59,530 --> 00:48:01,599
你变得懒散，所以你可以

1240
00:48:01,599 --> 00:48:03,609
坐下来，这样你

1241
00:48:03,609 --> 00:48:05,530
就可以一个人坐下来，

1242
00:48:05,530 --> 00:48:07,630
就像看看GPU一样坐在PCI Express总线上，但他们

1243
00:48:07,630 --> 00:48:09,349
确实有 那些可以

1244
00:48:09,349 --> 00:48:11,239
坐在妈妈身上的 oard 和一个像这样的插座

1245
00:48:11,239 --> 00:48:12,289
，你实际上可以

1246
00:48:12,289 --> 00:48:14,299
运行基于

1247
00:48:14,299 --> 00:48:15,710
你自己的操作系统，Zeon 5 不需要像

1248
00:48:15,710 --> 00:48:17,839
忙碌一样驱动一切，

1249
00:48:17,839 --> 00:48:19,249
这里的这个只有这个小的 Omni 路径

1250
00:48:19,249 --> 00:48:21,440
连接器，这样你就可以 确实喜欢远程

1251
00:48:21,440 --> 00:48:24,319
远程内存访问

1252
00:48:24,319 --> 00:48:27,140
另一台机器的权利，英特尔将其杀死

1253
00:48:27,140 --> 00:48:31,930
了我认为去年或两年前

1254
00:48:32,710 --> 00:48:34,729
它们大约在

1255
00:48:34,729 --> 00:48:36,859
五千美元左右左右，这是一个

1256
00:48:36,859 --> 00:48:40,970
有趣的实验，但对于机器

1257
00:48:40,970 --> 00:48:42,680
学习而言，GPU已经 更好，

1258
00:48:42,680 --> 00:48:45,380
所以主要的事情虽然我

1259
00:48:45,380 --> 00:48:46,549
想指出的是

1260
00:48:46,549 --> 00:48:48,109
他们将在这里运行的至强 Phi 将是

1261
00:48:48,109 --> 00:48:50,450
一个旧版本的至强 phi

1262
00:48:50,450 --> 00:48:52,759
所以它将按顺序

1263
00:48:52,759 --> 00:48:54,349
执行所以你可以' 不要做

1264
00:48:54,349 --> 00:48:56,089
Xeon可以做的乱序的事情，

1265
00:48:56,089 --> 00:48:58,160
它不能做正确的执行规范，

1266
00:48:58,160 --> 00:48:59,839
所以它会占用你的

1267
00:48:59,839 --> 00:49:01,579
管道并一个

1268
00:49:01,579 --> 00:49:02,150
接

1269
00:49:02,150 --> 00:49:07,099
一个地执行指令，它不能做只是一个

1270
00:49:07,099 --> 00:49:09,019
对我来说是的，这不行 它不做

1271
00:49:09,019 --> 00:49:11,210
分支预测和你的执行规范，

1272
00:49:11,210 --> 00:49:13,249
所以如果你有一个跳转，如果

1273
00:49:13,249 --> 00:49:15,890
你的 des 管道刷新，那么你

1274
00:49:15,890 --> 00:49:18,229
知道这会变得很昂贵，所以我们

1275
00:49:18,229 --> 00:49:19,249
将有四个

1276
00:49:19,249 --> 00:49:21,410
选择扫描的变体，所以要做标量

1277
00:49:21,410 --> 00:49:23,329
版本 有 60 条指令，

1278
00:49:23,329 --> 00:49:25,160
分支与无分支，然后

1279
00:49:25,160 --> 00:49:26,210
他们将拥有矢量化版本

1280
00:49:26,210 --> 00:49:27,469
，该版本始终是无分支的，

1281
00:49:27,469 --> 00:49:28,819
但他们将使用早期

1282
00:49:28,819 --> 00:49:30,559
破坏和后期实现，这

1283
00:49:30,559 --> 00:49:32,960
只是意味着我是否需要复制

1284
00:49:32,960 --> 00:49:35,390
元组工作我 我需要将偏移量

1285
00:49:35,390 --> 00:49:36,859
复制到

1286
00:49:36,859 --> 00:49:39,739
缓冲区中，以将其传递给

1287
00:49:39,739 --> 00:49:41,059
查询计划中的下一个运算符，但

1288
00:49:41,059 --> 00:49:42,349
同样它不是一个成熟的数据库

1289
00:49:42,349 --> 00:49:44,509
系统，因此

1290
00:49:44,509 --> 00:49:48,019
在他们进行扫描后没有其他任何东西 好吧，所以

1291
00:49:48,019 --> 00:49:49,930
你在这里看到的第一件事是

1292
00:49:49,930 --> 00:49:52,849
，Xeon Phi 将

1293
00:49:52,849 --> 00:49:57,920
在分支

1294
00:49:57,920 --> 00:49:59,599
和分支列表案例中胜过 Xeon 因为这

1295
00:49:59,599 --> 00:50:01,729
是扫描实际上它是一个

1296
00:50:01,729 --> 00:50:03,200
非常简单的我

1297
00:50:03,200 --> 00:50:05,269
我们在 for 循环中执行的指令，这东西只是

1298
00:50:05,269 --> 00:50:07,339
有更多的内核，但我一直认为这

1299
00:50:07,339 --> 00:50:10,369
是一个错字，就像这东西有

1300
00:50:10,369 --> 00:50:12,440
61 个课程我不知道为什么我说那个

1301
00:50:12,440 --> 00:50:14,599
奇怪的数字它不是 60 或 62 或 64

1302
00:50:14,599 --> 00:50:17,749
对，它是 61 不管对，然后

1303
00:50:17,749 --> 00:50:19,849
这个 Z 在这里我认为它有四个

1304
00:50:19,849 --> 00:50:21,650
带有超线程的内核，所以它

1305
00:50:21,650 --> 00:50:23,069
有更多的内核，

1306
00:50:23,069 --> 00:50:24,690
因为这非常简单，因此它

1307
00:50:24,690 --> 00:50:26,180
可以更快地完成思考，

1308
00:50:26,180 --> 00:50:29,039
但这现在向您展示了一个明显的

1309
00:50:29,039 --> 00:50:30,359
差异 与

1310
00:50:30,359 --> 00:50:32,699
从无分支和分支中获得的好处之间，当

1311
00:50:32,699 --> 00:50:34,440
您可以按顺序执行与按顺序

1312
00:50:34,440 --> 00:50:40,130
执行时，Xeon CPU

1313
00:50:40,130 --> 00:50:43,890
具有外部板执行，它具有

1314
00:50:43,890 --> 00:50:45,359
执行规范和分支

1315
00:50:45,359 --> 00:50:48,989
预测，因此在这种情况

1316
00:50:48,989 --> 00:50:51,479
下，分支 列表一是它会

1317
00:50:51,479 --> 00:50:53,999
做得更好，因为你扩大

1318
00:50:53,999 --> 00:50:56,699
了选择性，对不起，

1319
00:50:56,699 --> 00:50:59,430
作为第二大的低我不知道

1320
00:50:59,430 --> 00:51:00,959
为什么这不像另一个

1321
00:51:00,959 --> 00:51:03,089
哦，是的，因为在这种情况下，

1322
00:51:03,089 --> 00:51:05,279
你 跑 没有 CPU 缓存好吧，所以

1323
00:51:05,279 --> 00:51:07,440
想想这就像零一二五

1324
00:51:07,440 --> 00:51:09,660
10 这就像

1325
00:51:09,660 --> 00:51:11,699
我从向量中显示的图表的第一部分 然后

1326
00:51:11,699 --> 00:51:13,769
当你超过 20 或 50 时

1327
00:51:13,769 --> 00:51:16,049
它就会交叉 所以这就是为什么这就是为什么你

1328
00:51:16,049 --> 00:51:18,900
知道 在这种情况下

1329
00:51:18,900 --> 00:51:20,579
，他们再次汇聚到 Xeon Phi 他们没有那种

1330
00:51:20,579 --> 00:51:23,729
分支错误预测尊重执行，

1331
00:51:23,729 --> 00:51:26,039
所以就像每次复制所有东西一样

1332
00:51:26,039 --> 00:51:28,619
在他们的世界中很糟糕，因为

1333
00:51:28,619 --> 00:51:29,729
当你的选择性非常低时，它有很多工作方式，

1334
00:51:29,729 --> 00:51:32,609
所以

1335
00:51:32,609 --> 00:51:33,959
再次在这里时 您有

1336
00:51:33,959 --> 00:51:36,269
100% 的选择性，这两个内存带宽

1337
00:51:36,269 --> 00:51:38,099
是您

1338
00:51:38,099 --> 00:51:40,339
尝试将数据输入和输出

1339
00:51:40,339 --> 00:51:43,619
CPU 缓存而付出的代价，因此

1340
00:51:43,619 --> 00:51:45,959
对于矢量化算法，这两种算法都没有影响

1341
00:51:45,959 --> 00:51:48,690
你看到的是，

1342
00:51:48,690 --> 00:51:50,729
在这两个延迟实现的情况下，

1343
00:51:50,729 --> 00:51:52,890
它

1344
00:51:52,890 --> 00:51:54,779
会表现得最好，这并不奇怪，

1345
00:51:54,779 --> 00:51:56,640
因为我没有复制匹配的元组，

1346
00:51:56,640 --> 00:51:59,729
就像我只是做了更少的工作，但

1347
00:51:59,729 --> 00:52:00,900
你有更多

1348
00:52:00,900 --> 00:52:02,369
早实现和晚冬之间的显着差异，以及

1349
00:52:02,369 --> 00:52:04,709


1350
00:52:04,709 --> 00:52:06,359
在这两种架构上

1351
00:52:06,359 --> 00:52:08,930
再次实现与晚实现之间的显着差异，因为在这个世界中

1352
00:52:08,930 --> 00:52:12,779
，因为 CPU 非常简单，

1353
00:52:12,779 --> 00:52:15,630
所以复制指令变得昂贵

1354
00:52:15,630 --> 00:52:19,920
，就像你知道你只是做了

1355
00:52:19,920 --> 00:52:21,390
很多一样 做无用工作的成本

1356
00:52:21,390 --> 00:52:23,219
变得更加昂贵，然后

1357
00:52:23,219 --> 00:52:24,930


1358
00:52:24,930 --> 00:52:27,869
当您开始最大化内存带宽时，一切都会收敛到相同的性能，

1359
00:52:27,869 --> 00:52:30,930
所以这里也是一个

1360
00:52:30,930 --> 00:52:32,519
很好的例子，就像我

1361
00:52:32,519 --> 00:52:33,719
说的一样，不管

1362
00:52:33,719 --> 00:52:35,729
你是不是最喜欢 独立与否，如果

1363
00:52:35,729 --> 00:52:36,750
数据中的查询

1364
00:52:36,750 --> 00:52:38,910
不适合进行 vectra 的

1365
00:52:38,910 --> 00:52:43,400
操作，它对您没有帮助，

1366
00:52:43,400 --> 00:52:45,900
这也是我开头所说的另一个很好的例子，

1367
00:52:45,900 --> 00:52:47,400
即

1368
00:52:47,400 --> 00:52:48,930
您从未实现过您可以实现的

1369
00:52:48,930 --> 00:52:50,400
理论和性能改进

1370
00:52:50,400 --> 00:52:52,080
可能使用矢量化

1371
00:52:52,080 --> 00:52:56,640
指令，所以在这种情况下

1372
00:52:56,640 --> 00:53:02,240
，Z 上的 Z 上的处理速度约为每秒 2.5 26

1373
00:53:02,240 --> 00:53:05,430
亿个元组 b  ut 半

1374
00:53:05,430 --> 00:53:08,420
版本正在做你知道四舍五入 6

1375
00:53:08,420 --> 00:53:10,830
所以它的改进不到 3 倍，

1376
00:53:10,830 --> 00:53:15,650
但我们说我们有 4 倍

1377
00:53:15,650 --> 00:53:18,510
Sidney 寄存器所以这真的

1378
00:53:18,510 --> 00:53:20,640
应该是如果我们真的实现完全

1379
00:53:20,640 --> 00:53:23,250
完全瘫痪，我们应该

1380
00:53:23,250 --> 00:53:25,080
快 4 倍， 我们不是因为再次

1381
00:53:25,080 --> 00:53:27,570
将东西移入和

1382
00:53:27,570 --> 00:53:29,960
移出寄存器的成本我们支付了罚款

1383
00:53:29,960 --> 00:53:32,280
仅仅因为我们矢量化了其中

1384
00:53:32,280 --> 00:53:33,780
一部分可能没有而其余部分

1385
00:53:33,780 --> 00:53:36,540
没有矢量化这将成为

1386
00:53:36,540 --> 00:53:41,490
瓶颈 对我们来说好吧，所以让我们

1387
00:53:41,490 --> 00:53:43,140
看看我们做的其他一些事情哈希

1388
00:53:43,140 --> 00:53:44,220
表是另一个我

1389
00:53:44,220 --> 00:53:45,330
认为他们谈论这个真的很有趣

1390
00:53:45,330 --> 00:53:47,070
，他们再次提出了一些有趣的

1391
00:53:47,070 --> 00:53:50,300
技术，我们肯定评估过这个技术，

1392
00:53:50,300 --> 00:53:51,960


1393
00:53:51,960 --> 00:53:53,970
一旦你确定它肯定不起作用 位于 CPU 缓存中，

1394
00:53:53,970 --> 00:53:57,330
所以说我们想在我们的哈希表中做一个探测

1395
00:53:57,330 --> 00:53:58,260
，我们在做线性

1396
00:53:58,260 --> 00:54:00,810
探测，所以我们有一个规模版本，

1397
00:54:00,810 --> 00:54:03,000
我们有一个单一的输入键很好地

1398
00:54:03,000 --> 00:54:06,060
哈希它产生了一些偏移量

1399
00:54:06,060 --> 00:54:08,280
我们哈希表中的槽号

1400
00:54:08,280 --> 00:54:09,870
跳到所有集合可以使用其中的任何键

1401
00:54:09,870 --> 00:54:11,550
将它与我们的键进行比较

1402
00:54:11,550 --> 00:54:14,580
看看我们是否匹配 如果我们找到匹配 我们就

1403
00:54:14,580 --> 00:54:16,170
完成 如果没有那么我们就继续

1404
00:54:16,170 --> 00:54:18,000
向下扫描直到我们保持直到我们 找到一个

1405
00:54:18,000 --> 00:54:19,950
空位意味着我们知道

1406
00:54:19,950 --> 00:54:21,330
我们的钥匙不在那里，或者我们找到

1407
00:54:21,330 --> 00:54:25,770
了我们正在寻找的那个，所以

1408
00:54:25,770 --> 00:54:27,210
在这个特定的例子中你唯一可以真正矢量化的东西你可以矢量化它就在

1409
00:54:27,210 --> 00:54:28,710


1410
00:54:28,710 --> 00:54:32,070
那里是超级家伙

1411
00:54:32,070 --> 00:54:33,360
有一个向量化的散列函数，

1412
00:54:33,360 --> 00:54:35,340
当我们谈论连接时我会讨论它，

1413
00:54:35,340 --> 00:54:38,040
但就像这不是昂贵的

1414
00:54:38,040 --> 00:54:39,540
部分，昂贵的部分是做这个

1415
00:54:39,540 --> 00:54:41,640
比较并跳过

1416
00:54:41,640 --> 00:54:44,310
哈希表中的内存，所以让我们看看我们如何

1417
00:54:44,310 --> 00:54:46,800
使用垂直或 开始

1418
00:54:46,800 --> 00:54:48,630
水平向量化 所以我们

1419
00:54:48,630 --> 00:54:50,130
现在要在哈希表中做的事情

1420
00:54:50,130 --> 00:54:52,380
我们要展开数字

1421
00:54:52,380 --> 00:54:56,309
Ellen 的恢复钱包定律 所以在

1422
00:54:56,309 --> 00:54:58,710
每个插槽中我们将有四个键 然后

1423
00:54:58,710 --> 00:55:00,920
他们将有我们将有四个值

1424
00:55:00,920 --> 00:55:03,509
儿子 现在我们会见面，当我们拿一个

1425
00:55:03,509 --> 00:55:06,450
键时我们会散列它我们得到我们的哈希索引我们

1426
00:55:06,450 --> 00:55:08,039
跳到那个位置我们会

1427
00:55:08,039 --> 00:55:11,490
得到四个键然后我们可以做我们的sim D

1428
00:55:11,490 --> 00:55:14,160
比较得到我们的匹配掩码

1429
00:55:14,160 --> 00:55:15,420
然后我们检查 看看它们中是否有任何一个

1430
00:55:15,420 --> 00:55:18,869
是 1 那么我们知道我们知道我们有一个

1431
00:55:18,869 --> 00:55:20,190
匹配 我们知道如何找到

1432
00:55:20,190 --> 00:55:22,589
我们匹配键的偏移量 如果全是 0

1433
00:55:22,589 --> 00:55:23,880
那么我们知道这个

1434
00:55:23,880 --> 00:55:25,920
插槽中没有我们拥有的任何东西，我们只是跳转

1435
00:55:25,920 --> 00:55:27,210
到下一个位置，然后进行

1436
00:55:27,210 --> 00:55:30,900
相同的矢量化比较，所以

1437
00:55:30,900 --> 00:55:33,059
对于

1438
00:55:33,059 --> 00:55:35,460
这个对我来说，这似乎是

1439
00:55:35,460 --> 00:55:37,349
一个非常好的主意，结果证明它

1440
00:55:37,349 --> 00:55:41,339
不会不起作用，因为它们只是有

1441
00:55:41,339 --> 00:55:44,940
太多额外的开销

1442
00:55:44,940 --> 00:55:46,200
获取这些东西并扫描

1443
00:55:46,200 --> 00:55:49,559
和翻录它们的成本 你知道

1444
00:55:49,559 --> 00:55:51,180
将它复制到 Sidney Bechet 错误

1445
00:55:51,180 --> 00:55:53,130
就像那是你

1446
00:55:53,130 --> 00:56:08,640
付出的代价是的所以我们似乎是我们

1447
00:56:08,640 --> 00:56:11,250
在我在这里的地方尝试过软件预取

1448
00:56:11,250 --> 00:56:15,630
然后我 我会假设我

1449
00:56:15,630 --> 00:56:17,039
不会匹配，因此我 我要

1450
00:56:17,039 --> 00:56:20,069
预取下一件事，但如果我

1451
00:56:20,069 --> 00:56:21,630
匹配然后我预取了一些废话，然后

1452
00:56:21,630 --> 00:56:23,549
我飞到了我的 CPU 缓存，然后它就

1453
00:56:23,549 --> 00:56:25,710
不起作用了，因为缓存

1454
00:56:25,710 --> 00:56:26,970
服务器太随机了，以至于

1455
00:56:26,970 --> 00:56:28,589
很难说出你的意思 实际上

1456
00:56:28,589 --> 00:56:31,380
应该这样做 在我们的经验中

1457
00:56:31,380 --> 00:56:34,980
它不起作用 坦白没有帮助

1458
00:56:34,980 --> 00:56:38,910


1459
00:56:38,910 --> 00:56:41,220


1460
00:56:41,220 --> 00:56:43,470


1461
00:56:43,470 --> 00:56:45,089
你

1462
00:56:45,089 --> 00:56:46,740
知道在我们的大海捞针中的单针

1463
00:56:46,740 --> 00:56:48,599
现在使用垂直

1464
00:56:48,599 --> 00:56:50,059
向量化我们将同时获取

1465
00:56:50,059 --> 00:56:52,769
多个键并

1466
00:56:52,769 --> 00:56:56,309
并行搜索它们所以我们将

1467
00:56:56,309 --> 00:56:57,299
在这里获取四个键

1468
00:56:57,299 --> 00:57:00,269
我们将运行四个散列函数 所以

1469
00:57:00,269 --> 00:57:01,859
这你必须做 scaler 并且

1470
00:57:01,859 --> 00:57:03,759
没有 Cindy 指令可以

1471
00:57:03,759 --> 00:57:06,189
做四通道散列 我们可以

1472
00:57:06,189 --> 00:57:09,729
对散列函数本身进行矢量化 操作

1473
00:57:09,729 --> 00:57:10,929
女性有类似的东西 没有

1474
00:57:10,929 --> 00:57:12,809
像幽默散列或

1475
00:57:12,809 --> 00:57:16,589
xxx 散列可以完全在 Sim

1476
00:57:16,589 --> 00:57:19,659
d4 多个中运行 元素所以 w

1477
00:57:19,659 --> 00:57:21,880


1478
00:57:21,880 --> 00:57:23,949
如果我们愿意，我们可以展开循环，

1479
00:57:23,949 --> 00:57:25,989
我们将在哈希

1480
00:57:25,989 --> 00:57:28,299
函数或哈希表中获得四个位置，我们将跳转到

1481
00:57:28,299 --> 00:57:31,209
这些位置，然后执行此操作 Cindy

1482
00:57:31,209 --> 00:57:33,099
聚集将它们放入一个向量中

1483
00:57:33,099 --> 00:57:35,469
，然后现在我们可以进行 Cindy 比较

1484
00:57:35,469 --> 00:57:37,509
并检查我们是否有匹配项

1485
00:57:37,509 --> 00:57:40,569
，这会产生一个偏移量 抱歉

1486
00:57:40,569 --> 00:57:43,509
，如果它们的键匹配，则会产生一点质量，如果

1487
00:57:43,509 --> 00:57:45,519
它们匹配，则为 0，如果 我们的键

1488
00:57:45,519 --> 00:57:48,249
不匹配，但现在这里有什么问题

1489
00:57:48,249 --> 00:57:50,459
，

1490
00:57:52,259 --> 00:57:54,969
所以在我的最后一种情况下，当我一次

1491
00:57:54,969 --> 00:57:57,339
查看一个键时，如果一个

1492
00:57:57,339 --> 00:57:59,319
键匹配我完成了那个键不

1493
00:57:59,319 --> 00:58:01,029
匹配然后我跳了下来 到下一个，

1494
00:58:01,029 --> 00:58:03,729
但现在我有两个与他们匹配

1495
00:58:03,729 --> 00:58:12,669
不匹配 是的 所以他说

1496
00:58:12,669 --> 00:58:15,279
喜欢 这就是

1497
00:58:15,279 --> 00:58:19,059
他们的概念 他们一直希望充分

1498
00:58:19,059 --> 00:58:21,669
利用所有车道 所以这些

1499
00:58:21,669 --> 00:58:23,859
家伙 匹配所以我不需要再去寻找

1500
00:58:23,859 --> 00:58:26,079
其他座位和座位的哈希值

1501
00:58:26,079 --> 00:58:28,449
来为他们找到匹配的这些

1502
00:58:28,449 --> 00:58:30,669
家伙 不匹配 所以我必须去找

1503
00:58:30,669 --> 00:58:33,749
他们 所以我能做的一件事就是

1504
00:58:33,749 --> 00:58:36,519
让这些人或让你知道 把

1505
00:58:36,519 --> 00:58:38,469
这些钥匙保存在我的寄存器中 每个人都

1506
00:58:38,469 --> 00:58:40,899
跳到一个偏移处 他们

1507
00:58:40,899 --> 00:58:42,069
在相应的位置 哈希

1508
00:58:42,069 --> 00:58:43,989
表将这些新键引入并进行

1509
00:58:43,989 --> 00:58:45,519
比较，无论第一个

1510
00:58:45,519 --> 00:58:47,499
键和最后一个键产生什么作为

1511
00:58:47,499 --> 00:58:49,059
比较，我都忽略了这一点，因为我

1512
00:58:49,059 --> 00:58:51,819
知道我已经找到了它们，但

1513
00:58:51,819 --> 00:58:53,859
现在我得到了 50% 的利用率，

1514
00:58:53,859 --> 00:58:56,289
因为我 正在对这些键进行无用的计算，

1515
00:58:56,289 --> 00:58:57,249
因为我已经知道我

1516
00:58:57,249 --> 00:58:59,619
找到了匹配项，所以我只是

1517
00:58:59,619 --> 00:59:04,899
再次做不必要的工作，所以

1518
00:59:04,899 --> 00:59:07,089
另一件事可能是说 4 个

1519
00:59:07,089 --> 00:59:09,009
匹配项中有 3 个匹配项，所以我继续扫描是的，我循环

1520
00:59:09,009 --> 00:59:10,449
遍历

1521
00:59:10,449 --> 00:59:12,609
发现最后一个键永远不会

1522
00:59:12,609 --> 00:59:14,739
匹配的整个事情现在我只是浪费了所有这些

1523
00:59:14,739 --> 00:59:16,869
工作所以他们要做的是他们

1524
00:59:16,869 --> 00:59:17,620
将保持

1525
00:59:17,620 --> 00:59:19,450
内部簿记以跟踪

1526
00:59:19,450 --> 00:59:21,940
所有匹配的人

1527
00:59:21,940 --> 00:59:24,100
因此现在我需要去拿两把新

1528
00:59:24,100 --> 00:59:26,050
钥匙 s 要替换它们，他们将

1529
00:59:26,050 --> 00:59:27,970
返回此处将输入键

1530
00:59:27,970 --> 00:59:30,160
向量替换

1531
00:59:30,160 --> 00:59:33,100
为我们列中靠近我们的哈希

1532
00:59:33,100 --> 00:59:35,950
函数的下两个元素，对于这个，第二个和

1533
00:59:35,950 --> 00:59:38,350
第三个键 I 哈希函数实际上

1534
00:59:38,350 --> 00:59:40,300
只是在说 take 最后一个位置添加

1535
00:59:40,300 --> 00:59:41,590
一个，因为我正在向下移动到

1536
00:59:41,590 --> 00:59:43,570
插槽阵列中的下一个位置，但是我

1537
00:59:43,570 --> 00:59:46,090
为最后一个键中的第一个位置获得了一个新的起始位置

1538
00:59:46,090 --> 00:59:48,490
，然后再次执行此操作

1539
00:59:48,490 --> 00:59:49,780
跳转到这些位置

1540
00:59:49,780 --> 00:59:51,940
填充我的 向量，然后做我的 Cindy

1541
00:59:51,940 --> 00:59:58,510
比较 哦，对，是的，你可以去

1542
00:59:58,510 --> 01:00:02,340
吗，你能不能同时在多个键上用 Cindy 进行乘法散列

1543
01:00:03,870 --> 01:00:08,580
我

1544
01:00:08,850 --> 01:00:14,200
不知道答案呃我们必须

1545
01:00:14,200 --> 01:00:17,740
像是的一样检查我不知道，因为我

1546
01:00:17,740 --> 01:00:19,030
认为 你知道有一个

1547
01:00:19,030 --> 01:00:24,280
类似碰撞与速度之间的权衡 II

1548
01:00:24,280 --> 01:00:25,210
认为碰撞率可能有点

1549
01:00:25,210 --> 01:00:32,890
高，我们可以尝试好吧，所以

1550
01:00:32,890 --> 01:00:34,600
当你我们

1551
01:00:34,600 --> 01:00:36,070
知道你不适合你的座位缓存时，这也行不通

1552
01:00:36,070 --> 01:00:37,330
因为把所有这些簿记都

1553
01:00:37,330 --> 01:00:38,650
弄得一团糟 准备回去拿你的钥匙并

1554
01:00:38,650 --> 01:00:40,290
填写它会很昂贵

1555
01:00:40,290 --> 01:00:43,450
这个实现还有另一个问题，它

1556
01:00:43,450 --> 01:00:45,400


1557
01:00:45,400 --> 01:00:47,680
在工程方面有点微妙，如果

1558
01:00:47,680 --> 01:00:49,030
有人在阅读论文时发现了这一点，

1559
01:00:49,030 --> 01:00:51,580
比如你会遇到什么问题

1560
01:00:51,580 --> 01:00:52,780
如果您像构建数据库系统的人一样，那么

1561
01:00:52,780 --> 01:00:54,790
当您

1562
01:00:54,790 --> 01:00:59,680
使用此算法时，是

1563
01:00:59,680 --> 01:01:03,120
的，现在的烹饪节目将忽略

1564
01:01:03,120 --> 01:01:08,280
所有问题，即

1565
01:01:08,280 --> 01:01:10,750
probic 算法

1566
01:01:10,750 --> 01:01:13,570
对于相同的数据集不会是稳定的含义 和

1567
01:01:13,570 --> 01:01:16,510
相同的查询，我们每次运行该查询时我们都可以获得不同的

1568
01:01:16,510 --> 01:01:19,300
有序结果

1569
01:01:19,300 --> 01:01:22,270
现在好吧

1570
01:01:22,270 --> 01:01:24,190
关系模型是无序的

1571
01:01:24,190 --> 01:01:26,170
所以这是我们不应该真正

1572
01:01:26,170 --> 01:01:28,900
关心订单但就像我

1573
01:01:28,900 --> 01:01:30,370
试图实际 调试东西并尝试

1574
01:01:30,370 --> 01:01:32,080
以某种方式很好地理解它

1575
01:01:32,080 --> 01:01:34,090
我写到一个寄存器的数据让

1576
01:01:34,090 --> 01:01:35,710
你知道一个位置变得混乱但

1577
01:01:35,710 --> 01:01:37,060
另一个不喜欢如果

1578
01:01:37,060 --> 01:01:38,530
我每次都得到完全不同的

1579
01:01:38,530 --> 01:01:40,360
随机 r 结果取决于

1580
01:01:40,360 --> 01:01:42,450
这些东西与我的哈希表匹配的顺序

1581
01:01:42,450 --> 01:01:45,690
然后可能很难调试东西

1582
01:01:45,690 --> 01:01:52,780
II 有点同意 iii 不

1583
01:01:52,780 --> 01:01:54,130
知道这实际上有多少

1584
01:01:54,130 --> 01:01:55,300
问题，但这是他们

1585
01:01:55,300 --> 01:01:57,220
在论文中所说的所有内容 算法

1586
01:01:57,220 --> 01:01:58,420
这是他们唯一有这个

1587
01:01:58,420 --> 01:02:00,040
特殊问题的算法，比如我们谈到的选择性扫描的

1588
01:02:00,040 --> 01:02:01,420
东西没有这个

1589
01:02:01,420 --> 01:02:05,410
问题是的，好吧，让我们看看

1590
01:02:05,410 --> 01:02:07,570
一些性能结果，所以我们将

1591
01:02:07,570 --> 01:02:09,430
再次推出 Phi 和至强，所以

1592
01:02:09,430 --> 01:02:10,900
他们将拥有标量哈希探针

1593
01:02:10,900 --> 01:02:12,880
，然后向量 ax 是垂直和

1594
01:02:12,880 --> 01:02:16,450
水平的，沿着 x 轴，他们

1595
01:02:16,450 --> 01:02:18,430
将增加哈希表的大小，因此

1596
01:02:18,430 --> 01:02:20,350
对于标量版本，性能

1597
01:02:20,350 --> 01:02:22,210
看起来像这样，并注意 y

1598
01:02:22,210 --> 01:02:23,890
轴缩放 是不同的，

1599
01:02:23,890 --> 01:02:25,450
因为至强 phi 的核心比

1600
01:02:25,450 --> 01:02:26,760
另一个

1601
01:02:26,760 --> 01:02:31,720


1602
01:02:31,720 --> 01:02:33,400


1603
01:02:33,400 --> 01:02:34,750
多

1604
01:02:34,750 --> 01:02:37,480
因为

1605
01:02:37,480 --> 01:02:41,440
它没有它

1606
01:02:41,440 --> 01:02:45,490
没有分支预测错误，就像它

1607
01:02:45,490 --> 01:02:47,290
总是会以编程方式

1608
01:02:47,290 --> 01:02:50,740
通过并按照正确的顺序执行您知道的检查

1609
01:02:50,740 --> 01:02:53,200
，而

1610
01:02:53,200 --> 01:02:56,530
在水平情况下，您知道您

1611
01:02:56,530 --> 01:02:58,060
可能有 检查你是否知道方向

1612
01:02:58,060 --> 01:03:01,780
或不同的不确定性，在你如何

1613
01:03:01,780 --> 01:03:05,170
评估和至强的情况下，

1614
01:03:05,170 --> 01:03:07,630
我忘记了为什么这里有

1615
01:03:07,630 --> 01:03:09,640
交叉点，垂直

1616
01:03:09,640 --> 01:03:12,250
子回到比水平更好

1617
01:03:12,250 --> 01:03:13,329


1618
01:03:13,329 --> 01:03:15,309
的地方指出 这是相同的，

1619
01:03:15,309 --> 01:03:16,930
一旦所有东西都不在你的 CPU 缓存中，

1620
01:03:16,930 --> 01:03:21,209
所有这一切都无关紧要，所以

1621
01:03:21,209 --> 01:03:23,890
至强融核的缓存

1622
01:03:23,890 --> 01:03:26,349
比普通至强的小，所以你

1623
01:03:26,349 --> 01:03:28,690
更快地达到这种收敛点，

1624
01:03:28,690 --> 01:03:32,380
所以 再次这就是

1625
01:03:32,380 --> 01:03:33,969
我所说的 II

1626
01:03:33,969 --> 01:03:35,979
在这种情况下会发生对 P 获取的怀疑，至强 Phi

1627
01:03:35,979 --> 01:03:37,569
至少是旧版本的东西，他们

1628
01:03:37,569 --> 01:03:38,799
绝对没有前缀或

1629
01:03:38,799 --> 01:03:40,479
预取，这只是

1630
01:03:40,479 --> 01:03:41,140
现代 Zeon 的

1631
01:03:41,140 --> 01:03:45,670
现代 las  10 年是的，

1632
01:03:45,670 --> 01:03:48,400
我要谈论的最后一件事是让

1633
01:03:48,400 --> 01:03:49,630
你用直方图进行分区，

1634
01:03:49,630 --> 01:03:51,339
基本上这里的想法是我们可以使用

1635
01:03:51,339 --> 01:03:55,089
分散和收集

1636
01:03:55,089 --> 01:03:57,729
并行进行直方图计算，所以他们说这

1637
01:03:57,729 --> 01:04:00,219
是我们的输入关键向量 重新

1638
01:04:00,219 --> 01:04:02,799
使用 sim 最新的指令想想

1639
01:04:02,799 --> 01:04:03,819
这个或像

1640
01:04:03,819 --> 01:04:06,039
基数树一样，我只是去抓取

1641
01:04:06,039 --> 01:04:08,469
每个键的一个数字或一个字节，我

1642
01:04:08,469 --> 01:04:09,609
基本上使用它作为散列

1643
01:04:09,609 --> 01:04:10,809
函数来告诉我我的 偏移量

1644
01:04:10,809 --> 01:04:12,729
应该像它是一个廉价的

1645
01:04:12,729 --> 01:04:14,950
穷人的散列函数，然后

1646
01:04:14,950 --> 01:04:16,569
现在我要做的是获取这些

1647
01:04:16,569 --> 01:04:18,729
位置，然后将它们映射到

1648
01:04:18,729 --> 01:04:20,859
某个直方图，然后我将在其中执行

1649
01:04:20,859 --> 01:04:23,440
Symbian 取

1650
01:04:23,440 --> 01:04:25,630
我正在写入的向量中的任何值，然后

1651
01:04:25,630 --> 01:04:28,359
我为所有内容添加一个

1652
01:04:28,359 --> 01:04:30,640


1653
01:04:30,640 --> 01:04:32,650


1654
01:04:32,650 --> 01:04:34,630


1655
01:04:34,630 --> 01:04:37,029


1656
01:04:37,029 --> 01:04:39,880
与 Cindy 再次映射到相同位置的键 这

1657
01:04:39,880 --> 01:04:42,849
将是原子的，所以

1658
01:04:42,849 --> 01:04:45,249
指令是根据先前的值向这个位置添加一个

1659
01:04:45,249 --> 01:04:47,170
是我不能我

1660
01:04:47,170 --> 01:04:48,039
不能

1661
01:04:48,039 --> 01:04:49,959
它不是没有箔可以说

1662
01:04:49,959 --> 01:04:51,940
第一次添加一个然后再次添加它就像

1663
01:04:51,940 --> 01:04:54,130
添加一个基于 旧值是这样

1664
01:04:54,130 --> 01:04:55,779
我们正在失去这些

1665
01:04:55,779 --> 01:04:57,390
更新之一所以我们的计数会出错

1666
01:04:57,390 --> 01:04:59,799
所以他们可以处理的方式是你

1667
01:04:59,799 --> 01:05:02,559
现在做一个 Cindy 分散让

1668
01:05:02,559 --> 01:05:04,559
这些人中的每个人都正确地写出两个不同的

1669
01:05:04,559 --> 01:05:06,819
向量 所以这个 是第

1670
01:05:06,819 --> 01:05:08,109
一个元素的第一个保留的第

1671
01:05:08,109 --> 01:05:09,819
一个向量 这是下一个元素的下一个向量

1672
01:05:09,819 --> 01:05:11,440
现在他们正在做与

1673
01:05:11,440 --> 01:05:12,640
我们之前相同的事情，

1674
01:05:12,640 --> 01:05:14,499
写入向量的偏移量但

1675
01:05:14,499 --> 01:05:15,640
现在他们没有破坏

1676
01:05:15,640 --> 01:05:18,489
因为它们只是你知道

1677
01:05:18,489 --> 01:05:20,759
的一个通道一次可以写入一个向量

1678
01:05:20,759 --> 01:05:23,319
所以现在我唯一需要做

1679
01:05:23,319 --> 01:05:26,830
的就是最终的直方图是什么

1680
01:05:26,830 --> 01:05:30,520
我只是做一个 Simba 必须

1681
01:05:30,520 --> 01:05:33,220
跨过计算 以这种方式

1682
01:05:33,220 --> 01:05:36,570
水平地产生最终

1683
01:05:36,570 --> 01:05:38,470
结果 所以我认为我认为这

1684
01:05:38,470 --> 01:05:42,250
有点酷 好吧 有一个

1685
01:05:42,250 --> 01:05:44,170
快速完成 矢量化

1686
01:05:44,170 --> 01:05:46,540
对于 OLAP 查询非常重要 我们已经

1687
01:05:46,540 --> 01:05:47,830
涵盖了当你的 CPU

1688
01:05:47,830 --> 01:05:49,990
缓存然后所有内部查询

1689
01:05:49,990 --> 01:05:51,370
面板和我们讨论过的东西时，这一切都不起作用

1690
01:05:51,370 --> 01:05:52,810
到目前为止，当

1691
01:05:52,810 --> 01:05:54,850
我们开始转向我的连接向量化

1692
01:05:54,850 --> 01:05:57,010
时，我们将讨论的内容只是我们可以添加以加快速度的另一个工具

1693
01:05:57,010 --> 01:05:59,890
，因此在理想情况下，一个理想的

1694
01:05:59,890 --> 01:06:02,410
系统可以使用向量化进行查询编译

1695
01:06:02,410 --> 01:06:04,540
，它还支持

1696
01:06:04,540 --> 01:06:07,570
并行查询和 在我们的系统中，我们

1697
01:06:07,570 --> 01:06:09,970
几乎在那里超级实际上无法进行

1698
01:06:09,970 --> 01:06:11,290
矢量化，他们只能进行

1699
01:06:11,290 --> 01:06:13,780
编译和并行

1700
01:06:13,780 --> 01:06:17,320
查询。 明智的只能做一些预

1701
01:06:17,320 --> 01:06:19,900
编译是的在某些情况下它有帮助

1702
01:06:19,900 --> 01:06:22,330
有时它没有帮助但

1703
01:06:22,330 --> 01:06:28,240
他们可以做更好的化是的这是

1704
01:06:28,240 --> 01:06:30,730
为了他们仅在单个线程上拥有的权利

1705
01:06:30,730 --> 01:06:33,010
但对于 OLAP 查询或

1706
01:06:33,010 --> 01:06:34,150
只读查询 他们可以

1707
01:06:34,150 --> 01:06:35,950
并行运行那些我们

1708
01:06:35,950 --> 01:06:38,550
讨论过的对调度程序来说不重要的东西

1709
01:06:38,550 --> 01:06:42,010
好吧任何问题向量化

1710
01:06:42,010 --> 01:06:44,650
好吧让我们完成帕特里克3好吧

1711
01:06:44,650 --> 01:06:48,040
所以项目3锅目标是让

1712
01:06:48,040 --> 01:06:50,130
你在你的团队中实现一些

1713
01:06:50,130 --> 01:06:52,960


1714
01:06:52,960 --> 01:06:55,480


1715
01:06:55,480 --> 01:06:56,560
我们一直在为前两个

1716
01:06:56,560 --> 01:06:58,960
项目工作的数据系统中的实质性或大型软件组件或功能，我们的想法是这些

1717
01:06:58,960 --> 01:07:00,430
产品应该包含我们迄今为止讨论过的各种

1718
01:07:00,430 --> 01:07:01,930
主题和技术以及方法和

1719
01:07:01,930 --> 01:07:03,880
优化

1720
01:07:03,880 --> 01:07:06,760
在课程中以及

1721
01:07:06,760 --> 01:07:09,010
任何你对自己

1722
01:07:09,010 --> 01:07:11,590
的工作或研究或你的爱好感兴趣的东西，如果你也

1723
01:07:11,590 --> 01:07:13,240
想把它带进来，那么我

1724
01:07:13,240 --> 01:07:15,280
完全没问题，因为

1725
01:07:15,280 --> 01:07:16,360
我 当然，我不知道你知道的一切，

1726
01:07:16,360 --> 01:07:18,340
并且在数据库之外思考我的

1727
01:07:18,340 --> 01:07:19,780
知识非常有限，所以如果你

1728
01:07:19,780 --> 01:07:21,490
提出一些我不知道的东西，那

1729
01:07:21,490 --> 01:07:22,420
玩起来会很酷，

1730
01:07:22,420 --> 01:07:24,970
我完全不同意

1731
01:07:24,970 --> 01:07:26,260
但重要的是，无论

1732
01:07:26,260 --> 01:07:27,430
您为项目选择什么，都必须

1733
01:07:27,430 --> 01:07:29,800
与其他每个组不同，所以我不能

1734
01:07:29,800 --> 01:07:31,690
让两个人两个组也

1735
01:07:31,690 --> 01:07:33,430
实施约束，因为

1736
01:07:33,430 --> 01:07:35,710
目标是我们希望您的软件

1737
01:07:35,710 --> 01:07:37,390
能够重新合并到 完整的

1738
01:07:37,390 --> 01:07:39,850
系统，这样你就知道你知道

1739
01:07:39,850 --> 01:07:40,750
你

1740
01:07:40,750 --> 01:07:42,070
在现实世界中离开了，在

1741
01:07:42,070 --> 01:07:43,060
我无法说出来的工作中，你

1742
01:07:43,060 --> 01:07:44,800
知道

1743
01:07:44,800 --> 01:07:48,730
这是我们帮助实现的数据库系统的一部分，所以

1744
01:07:48,730 --> 01:07:50,500
什么 你必须做得很好吗？我的

1745
01:07:50,500 --> 01:07:51,190


1746
01:07:51,190 --> 01:07:53,230
提案将在春假之后到期，

1747
01:07:53,230 --> 01:07:54,970
然后在学期末之前

1748
01:07:54,970 --> 01:07:56,980
通过设计文档的 satis 更新

1749
01:07:56,980 --> 01:07:58,480
也将相互进行代码审查，

1750
01:07:58,480 --> 01:08:00,640
好吧，所以你稍后再谈这个

1751
01:08:00,640 --> 01:08:01,900
，但你 意味着你有

1752
01:08:01,900 --> 01:08:02,890
查看其他人的代码，看看

1753
01:08:02,890 --> 01:08:04,030
他们是否在做愚蠢的事情，

1754
01:08:04,030 --> 01:08:04,990
看看你的代码，看看

1755
01:08:04,990 --> 01:08:06,100
你是否在做愚蠢的事情

1756
01:08:06,100 --> 01:08:07,960
，会有一个最终的演示，

1757
01:08:07,960 --> 01:08:09,580
然后提交 PR 的代码下降

1758
01:08:09,580 --> 01:08:11,950
在我们的 github 上，它干净地

1759
01:08:11,950 --> 01:08:14,140
合并到了我们的主分支中，所以让

1760
01:08:14,140 --> 01:08:16,210
我们逐一完成这些，因此

1761
01:08:16,210 --> 01:08:18,339
在春假后的第一个星期一，每个

1762
01:08:18,339 --> 01:08:19,630
小组都会来到这里，他们将

1763
01:08:19,630 --> 01:08:21,339
花五分钟时间谈论

1764
01:08:21,339 --> 01:08:24,009
你是什么 您提议进行构建，因此

1765
01:08:24,009 --> 01:08:25,720
这不仅仅是在高层次上，

1766
01:08:25,720 --> 01:08:27,580
这就是我想要做的 您实际上

1767
01:08:27,580 --> 01:08:29,020
应该花时间查看源

1768
01:08:29,020 --> 01:08:31,299
代码并尝试提出一个很好的

1769
01:08:31,299 --> 01:08:33,100
近似值，您实际上

1770
01:08:33,100 --> 01:08:35,229
需要实现什么 那个特定的

1771
01:08:35,229 --> 01:08:37,060
功能或组件，所以你应该知道

1772
01:08:37,060 --> 01:08:38,490
你需要修改什么文件或添加

1773
01:08:38,490 --> 01:08:40,810
Hydra 行为你要测试

1774
01:08:40,810 --> 01:08:41,979
你的实现是否正常工作

1775
01:08:41,979 --> 01:08:44,020
，然后这就是为什么我让你们

1776
01:08:44,020 --> 01:08:45,759
列出和你阅读的每一篇论文都

1777
01:08:45,759 --> 01:08:47,589
有效 他们用来评估

1778
01:08:47,589 --> 01:08:49,870
他们的研究的

1779
01:08:49,870 --> 01:08:51,460
负载 你应该知道你想为你的项目使用什么工作负载

1780
01:08:51,460 --> 01:08:53,890
，所以现在我们可以

1781
01:08:53,890 --> 01:08:56,200
支持一些基本的工作负载 TATP

1782
01:08:56,200 --> 01:08:59,380
小银行，为什么说是，我们可以

1783
01:08:59,380 --> 01:09:02,859
支持 TP CH 中的一些查询，但它

1784
01:09:02,859 --> 01:09:05,080
你还有什么想评估的，让

1785
01:09:05,080 --> 01:09:07,839
我知道我们可以想出一些办法，然后

1786
01:09:07,839 --> 01:09:09,850
我们将在四月设立一个检查站，

1787
01:09:09,850 --> 01:09:11,020
你再次回来花五

1788
01:09:11,020 --> 01:09:12,220
分钟告诉大家

1789
01:09:12,220 --> 01:09:13,330
你做了什么你在当前所做的工作

1790
01:09:13,330 --> 01:09:15,790
如果

1791
01:09:15,790 --> 01:09:19,299
你的计划有任何变化，状态是你的项目，因为

1792
01:09:19,299 --> 01:09:20,439
系统中有一些

1793
01:09:20,439 --> 01:09:22,149
东西被破坏或没有实施，或者

1794
01:09:22,149 --> 01:09:23,410
你发现了其他非常

1795
01:09:23,410 --> 01:09:24,819
有趣的东西，然后你谈论

1796
01:09:24,819 --> 01:09:27,790
这些差异是什么，这

1797
01:09:27,790 --> 01:09:29,560
对你们来说总是很有趣 他们讨论

1798
01:09:29,560 --> 01:09:30,910
当

1799
01:09:30,910 --> 01:09:32,109
他们开始

1800
01:09:32,109 --> 01:09:33,520
研究系统的内部时发现了哪些

1801
01:09:33,520 --> 01:09:35,229


1802
01:09:35,229 --> 01:09:36,399
奖品 她有内存

1803
01:09:36,399 --> 01:09:38,080
泄漏，这在这一点上并不奇怪，

1804
01:09:38,080 --> 01:09:40,240
但就像这样的事情一样

1805
01:09:40,240 --> 01:09:42,850
，它也非常有用，

1806
01:09:42,850 --> 01:09:45,520
但这是你会看到

1807
01:09:45,520 --> 01:09:46,839
前学期确实发生的事情

1808
01:09:46,839 --> 01:09:49,210
是有时一组需要

1809
01:09:49,210 --> 01:09:53,890
你 了解某种功能，例如

1810
01:09:53,890 --> 01:09:56,800
我们需要设置管理器或

1811
01:09:56,800 --> 01:09:58,830
锁定以某种方式锁定表，而

1812
01:09:58,830 --> 01:10:01,030
另一组可能需要相同的功能，

1813
01:10:01,030 --> 01:10:02,860
因此您不知道这两个

1814
01:10:02,860 --> 01:10:04,090
组都实现了相同的

1815
01:10:04,090 --> 01:10:06,640
冗余软件，你们

1816
01:10:06,640 --> 01:10:07,870
可能会一起工作，或者可能

1817
01:10:07,870 --> 01:10:09,100
一组完成，或者另一组

1818
01:10:09,100 --> 01:10:10,090
和另一组可以

1819
01:10:10,090 --> 01:10:12,040
拿走他们的代码，所以这

1820
01:10:12,040 --> 01:10:13,330
就像一个协作过程，而不是

1821
01:10:13,330 --> 01:10:14,620
像一个项目或项目你或

1822
01:10:14,620 --> 01:10:15,580
你在相互竞争

1823
01:10:15,580 --> 01:10:18,100
它的意思是说我应该

1824
01:10:18,100 --> 01:10:19,240
一起工作并努力

1825
01:10:19,240 --> 01:10:21,640
使设计文档变得更好 我

1826
01:10:21,640 --> 01:10:22,840
将为你们提供模板，

1827
01:10:22,840 --> 01:10:24,310
它只是用 Markdown 编写的

1828
01:10:24,310 --> 01:10:26,650
基本上，它描述

1829
01:10:26,650 --> 01:10:28,420
了您的功能是什么或您的

1830
01:10:28,420 --> 01:10:30,040
组件实际上是什么，为什么您

1831
01:10:30,040 --> 01:10:31,540
以某种方式设计它，您

1832
01:10:31,540 --> 01:10:32,710
知道您必须为此实现考虑哪些不同的权衡，

1833
01:10:32,710 --> 01:10:34,120


1834
01:10:34,120 --> 01:10:37,180
然后如果有人想要的话，未来的工作

1835
01:10:37,180 --> 01:10:38,980
继续你的

1836
01:10:38,980 --> 01:10:40,990
项目，你知道

1837
01:10:40,990 --> 01:10:42,700
如果你有更多的时间，你

1838
01:10:42,700 --> 01:10:44,740
实际上会做什么，对于那些

1839
01:10:44,740 --> 01:10:46,930
正在考虑

1840
01:10:46,930 --> 01:10:48,250
在秋季学期做一个顶点和笔研究的人来说，

1841
01:10:48,250 --> 01:10:50,170
这也是一个有用的 指出你

1842
01:10:50,170 --> 01:10:52,030
在学期结束时写下你的心态

1843
01:10:52,030 --> 01:10:53,200
，因为你

1844
01:10:53,200 --> 01:10:55,360
会在夏天离开，

1845
01:10:55,360 --> 01:10:56,320
秋天回来，你就像在四月五月时到底在想什么一样

1846
01:10:56,320 --> 01:10:57,550


1847
01:10:57,550 --> 01:10:59,580
这是一个很好的你知道一个很好的

1848
01:10:59,580 --> 01:11:03,070
提醒你自己再次进行代码

1849
01:11:03,070 --> 01:11:05,110
审查 你将再次进行两轮

1850
01:11:05,110 --> 01:11:06,850
代码审查 我将配对

1851
01:11:06,850 --> 01:11:08,680
不同的组以便查看

1852
01:11:08,680 --> 01:11:10,840
彼此的代码，我们将只使用

1853
01:11:10,840 --> 01:11:12,580
拉取请求 审查 

1854
01:11:12,580 --> 01:11:14,860
通过 github 进行处理，我将在

1855
01:11:14,860 --> 01:11:15,940
课堂上花时间讨论

1856
01:11:15,940 --> 01:11:17,530
实际执行代码视图意味着什么，您知道这

1857
01:11:17,530 --> 01:11:19,180
不像您知道您

1858
01:11:19,180 --> 01:11:20,710
拼错了这个词，就像实际上

1859
01:11:20,710 --> 01:11:22,600
花时间查看代码一样，并且

1860
01:11:22,600 --> 01:11:23,830
试着弄清楚你知道他们是在

1861
01:11:23,830 --> 01:11:25,300
做出合理的假设还是在

1862
01:11:25,300 --> 01:11:28,240
他们的实施中，我还要说的

1863
01:11:28,240 --> 01:11:30,460
是，这意味着

1864
01:11:30,460 --> 01:11:32,800
每个人的导师都可以做出贡献，所以我

1865
01:11:32,800 --> 01:11:34,420
不希望第一次

1866
01:11:34,420 --> 01:11:35,800
重复审查是一个人做的

1867
01:11:35,800 --> 01:11:36,850
和第二次代码审查下一个人

1868
01:11:36,850 --> 01:11:38,470
做这件事每个人都应该平等地做出贡献

1869
01:11:38,470 --> 01:11:40,750
，以及我们如何将源

1870
01:11:40,750 --> 01:11:42,430
代码划分为您想要查看的正确内容

1871
01:11:42,430 --> 01:11:45,340
，这将根据项目而有所不同，

1872
01:11:45,340 --> 01:11:46,960
当然有时如果您正在

1873
01:11:46,960 --> 01:11:50,170
做我 '''''''''''''''''''m''m going to file based on some of you are

1874
01:11:50,170 --> 01:11:52,660
on War关于他们的

1875
01:11:52,660 --> 01:11:54,190
文件比其他文件修改得更多，这可能

1876
01:11:54,190 --> 01:11:55,870
不是一个很好的划分方式，

1877
01:11:55,870 --> 01:11:58,300
但我们将讨论处理

1878
01:11:58,300 --> 01:12:00,760
这个最终演示的方法，

1879
01:12:00,760 --> 01:12:02,680
无论何时 我们计划在

1880
01:12:02,680 --> 01:12:05,740
周一晚上 8:30 或

1881
01:12:05,740 --> 01:12:07,329
5:30 进行期末考试。 我们不是

1882
01:12:07,329 --> 01:12:08,829
我们不是在晚上我们不是

1883
01:12:08,829 --> 01:12:10,089
在早上和晚上所以我们会

1884
01:12:10,089 --> 01:12:11,530
得到皮特所以我们会得到食物但他们

1885
01:12:11,530 --> 01:12:12,639
认为你只是出现花10

1886
01:12:12,639 --> 01:12:14,169
分钟说这就是我们 我实际上已经完成了，

1887
01:12:14,169 --> 01:12:15,820
并且在前几年我得到了

1888
01:12:15,820 --> 01:12:17,589
演示，如果你可以为状态更新做一个演示，

1889
01:12:17,589 --> 01:12:19,300
那很棒 - 就像

1890
01:12:19,300 --> 01:12:20,530
展示它一样，嘿，这

1891
01:12:20,530 --> 01:12:22,479
东西确实做到了我们所说的，现在我们

1892
01:12:22,479 --> 01:12:23,889
实际上支持续集 我们的系统因此

1893
01:12:23,889 --> 01:12:25,510
做演示对于

1894
01:12:25,510 --> 01:12:30,999
没有项目 3 的人来说应该更容易，所以

1895
01:12:30,999 --> 01:12:33,070
它的工作方式

1896
01:12:33,070 --> 01:12:34,149
与其他类不同，在那里您可以编写

1897
01:12:34,149 --> 01:12:36,639
一些代码，这些代码位于您的私人

1898
01:12:36,639 --> 01:12:39,760
github 存储库或您的笔记本电脑中，然后没有

1899
01:12:39,760 --> 01:12:42,489
人 看到没有人关心您

1900
01:12:42,489 --> 01:12:43,959
必须确保您的代码实际上可以正确

1901
01:12:43,959 --> 01:12:45,939
合并到主分支以

1902
01:12:45,939 --> 01:12:47,859
获得最终成绩我们这样做的

1903
01:12:47,859 --> 01:12:50,019
原因只是因为您知道它可以

1904
01:12:50,019 --> 01:12:51,760
让您了解自己在

1905
01:12:51,760 --> 01:12:53,559
做什么，因为如果您 想去

1906
01:12:53,559 --> 01:12:54,789
一家数据库公司找工作，这个 一个

1907
01:12:54,789 --> 01:12:55,059
诚实的

1908
01:12:55,059 --> 01:12:56,530
给我发电子邮件说，嘿，你知道学生

1909
01:12:56,530 --> 01:12:57,999
他们在做什么吗，我可以指出你的

1910
01:12:57,999 --> 01:12:59,229
项目，这是实际的源

1911
01:12:59,229 --> 01:13:02,109
代码，所以我们想要一些案例，

1912
01:13:02,109 --> 01:13:03,699
有时我们想合并一些代码，但

1913
01:13:03,699 --> 01:13:05,379
至少有一个 PR 可以干净地

1914
01:13:05,379 --> 01:13:07,539
合并 通过所有测试 然后我们

1915
01:13:07,539 --> 01:13:08,889
可以指出 就像最终的

1916
01:13:08,889 --> 01:13:11,530
工作体 好吧 我们不是一家公司 我们不是

1917
01:13:11,530 --> 01:13:13,359
你知道我们不是试图出售这个

1918
01:13:13,359 --> 01:13:15,070
软件 但我们仍在努力 在学术界尽我们所能做

1919
01:13:15,070 --> 01:13:17,019
高质量的软件工程

1920
01:13:17,019 --> 01:13:19,359
，我

1921
01:13:19,359 --> 01:13:22,929
想这是你知道的，实际上我有一个

1922
01:13:22,929 --> 01:13:25,689
学生回来了，他

1923
01:13:25,689 --> 01:13:26,979
现在在一家危险的公司实习，他对

1924
01:13:26,979 --> 01:13:30,909


1925
01:13:30,909 --> 01:13:32,260
他们正在看的商业源代码有多么混乱感到惊讶

1926
01:13:32,260 --> 01:13:35,109
与我们的源代码相比，所以

1927
01:13:35,109 --> 01:13:36,849
我想，就像你知道

1928
01:13:36,849 --> 01:13:38,260
经历这个过程一样，你至少

1929
01:13:38,260 --> 01:13:39,909
你知道明白

1930
01:13:39,909 --> 01:13:41,800
实际编写需要什么你知道

1931
01:13:41,800 --> 01:13:43,239
干净合理的源代码所以它已经

1932
01:13:43,239 --> 01:13:44,530
紧急了，它是一团糟 分支

1933
01:13:44,530 --> 01:13:45,999
他们知道你知道我们做了所有的 clang

1934
01:13:45,999 --> 01:13:47,739
tidy clang 格式和 doxygen 检查

1935
01:13:47,739 --> 01:13:49,989
，现在

1936
01:13:49,989 --> 01:13:51,219
如果不同组之间存在冲突，那么棘手的事情当然会是，

1937
01:13:51,219 --> 01:13:52,599
所以他们修改同一个

1938
01:13:52,599 --> 01:13:55,839
文件我们如何确定我们是否要

1939
01:13:55,839 --> 01:13:57,309
合并谁先合并

1940
01:13:57,309 --> 01:13:59,679
这个人想随机做或者

1941
01:13:59,679 --> 01:14:01,599
我们正在逐案处理我们的

1942
01:14:01,599 --> 01:14:03,339
成功率约为50％所以前几年50％

1943
01:14:03,339 --> 01:14:04,989
的学生项目

1944
01:14:04,989 --> 01:14:06,719
已合并到主分支

1945
01:14:06,719 --> 01:14:11,199
好吧，再次就资源而言，

1946
01:14:11,199 --> 01:14:14,019
如果

1947
01:14:14,019 --> 01:14:16,659
您向我们的主要回购

1948
01:14:16,659 --> 01:14:18,339
战火构建和 Travis 和 Jenkins 提交 PR，我们将为您获得更多的亚马逊积分，

1949
01:14:18,339 --> 01:14:19,809
我们可能会放弃 Travis，因为

1950
01:14:19,809 --> 01:14:20,719
我们运行

1951
01:14:20,719 --> 01:14:23,060
时间太长，但是 Jenkins 会

1952
01:14:23,060 --> 01:14:26,540
像你知道 OSX 和 Ubuntu 一样覆盖，如果

1953
01:14:26,540 --> 01:14:27,860
你认为你需要特殊的硬件

1954
01:14:27,860 --> 01:14:29,600
，我认为今年不

1955
01:14:29,600 --> 01:14:32,000
应该有任何东西让我知道，我们可以

1956
01:14:32,000 --> 01:14:34,940
看看我们可以做什么，好吧，是的，

1957
01:14:34,940 --> 01:14:36,440
你已经 伙计们都知道这个故事太棒了

1958
01:14:36,440 --> 01:14:37,850
ork 进行中 一堆

1959
01:14:37,850 --> 01:14:39,410
东西行不通 有些东西让

1960
01:14:39,410 --> 01:14:41,180
我崩溃了 但我们会在我们继续的过程中修复它

1961
01:14:41,180 --> 01:14:43,070
好吧 让我们看看有哪些潜在的

1962
01:14:43,070 --> 01:14:46,400
主题 所以让我们走 有一堆

1963
01:14:46,400 --> 01:14:47,840
这些让我们走 但想要一个我一个 所以

1964
01:14:47,840 --> 01:14:49,610
第一个是查询

1965
01:14:49,610 --> 01:14:51,739
优化器，所以我们有一个完整的 Cascades

1966
01:14:51,739 --> 01:14:54,020
查询优化器，您将学习

1967
01:14:54,020 --> 01:14:55,580
Cascades 的实际含义和更多

1968
01:14:55,580 --> 01:14:57,830
讲座，因此该项目实际上

1969
01:14:57,830 --> 01:14:58,850
将研究优化器的内部结构，

1970
01:14:58,850 --> 01:15:02,390
以增加对更

1971
01:15:02,390 --> 01:15:04,100
复杂的支持 查询更复杂的

1972
01:15:04,100 --> 01:15:06,170
转换，比如外连接

1973
01:15:06,170 --> 01:15:08,630
，我认为我们这可能是固定的，但

1974
01:15:08,630 --> 01:15:10,160
嵌套查询我们需要潜在地

1975
01:15:10,160 --> 01:15:12,530
改进我们的成本模型实际上是定义

1976
01:15:12,530 --> 01:15:13,699
我们知道我们需要改进我们的成本

1977
01:15:13,699 --> 01:15:15,890
模型来确定我们如何确定

1978
01:15:15,890 --> 01:15:18,350
一个计划是否优于 另一个但我

1979
01:15:18,350 --> 01:15:19,730
想说我可以稍后详细说明

1980
01:15:19,730 --> 01:15:21,140
你

1981
01:15:21,140 --> 01:15:24,080
可以用它做什么，但如果你

1982
01:15:24,080 --> 01:15:26,390
在查询优化器上工作，那么

1983
01:15:26,390 --> 01:15:28,160
你必须做的第一件事是我 还把

1984
01:15:28,160 --> 01:15:30,880
你的简历寄给我，因为

1985
01:15:30,880 --> 01:15:33,469
这是所有数据库

1986
01:15:33,469 --> 01:15:35,180
公司想要雇用的一件事，如果你

1987
01:15:35,180 --> 01:15:36,590
是去年或上学期的介绍班

1988
01:15:36,590 --> 01:15:38,810
，来自甲骨文的家伙来了，

1989
01:15:38,810 --> 01:15:39,920
他就像是的，我们不是 JavaScript

1990
01:15:39,920 --> 01:15:41,150
程序员 我们来自一个查询

1991
01:15:41,150 --> 01:15:43,040
优化器，我也收到了这样的

1992
01:15:43,040 --> 01:15:44,660
电子邮件，就像这样来自一个

1993
01:15:44,660 --> 01:15:46,550
非常有名的数据库人员在一天

1994
01:15:46,550 --> 01:15:48,890
启动时他就像给一群人发电子邮件

1995
01:15:48,890 --> 01:15:50,120
，虽然

1996
01:15:50,120 --> 01:15:51,260
我不是高级数据库，但我在名单上 任何人，

1997
01:15:51,260 --> 01:15:52,699
但他就像嘿，有人

1998
01:15:52,699 --> 01:15:54,199
知道我们可以雇用任何松散的查询

1999
01:15:54,199 --> 01:15:56,390
优化人员，

2000
01:15:56,390 --> 01:15:57,350
因为他们非常努力，因为

2001
01:15:57,350 --> 01:15:58,610
查询优化

2002
01:15:58,610 --> 01:16:00,710
在 80 年代和 90 年代是一件

2003
01:16:00,710 --> 01:16:02,270
大事，就像你知道的这些老白人 就像

2004
01:16:02,270 --> 01:16:04,940
你知道的那样不太可能离开

2005
01:16:04,940 --> 01:16:08,060
公司并加入初创公司，所以人们

2006
01:16:08,060 --> 01:16:09,890
不能足够快地雇用这些地方

2007
01:16:09,890 --> 01:16:11,690
，就像所有 nocebo 数据库

2008
01:16:11,690 --> 01:16:12,620
公司一样，哦，我们

2009
01:16:12,620 --> 01:16:13,790
不需要查询 优化器，我们只是要

2010
01:16:13,790 --> 01:16:15,830
你知道让他们像他们一样设置和 JSON

2011
01:16:15,830 --> 01:16:17,930
然后很快意识到哦，我们确实需要一个

2012
01:16:17,930 --> 01:16:18,890
查询优化

2013
01:16:18,890 --> 01:16:20,469
查询优化器，所以人们

2014
01:16:20,469 --> 01:16:23,150
很难找到它们，所以这个

2015
01:16:23,150 --> 01:16:25,160
家伙对他的请求有点粗俗，

2016
01:16:25,160 --> 01:16:26,960
但还是一样 他想

2017
01:16:26,960 --> 01:16:30,670
雇人做的事情来寻找查询优化器

2018
01:16:30,670 --> 01:16:32,540
查询啊人们可以在采石场

2019
01:16:32,540 --> 01:16:34,400
优化器工作 与此相关的成本

2020
01:16:34,400 --> 01:16:35,900
我们没有任何好的方法来维护

2021
01:16:35,900 --> 01:16:39,680
有关

2022
01:16:39,680 --> 01:16:41,150
数据外观的统计信息，因此我们可以提供该信息

2023
01:16:41,150 --> 01:16:42,560
进入我们的成本模型以估计

2024
01:16:42,560 --> 01:16:45,050
查询的质量，因此我们

2025
01:16:45,050 --> 01:16:47,420
需要一种方法来收集

2026
01:16:47,420 --> 01:16:49,550
有关我们没有提供给系统的统计信息我们

2027
01:16:49,550 --> 01:16:51,110
也可以进行抽样，这是

2028
01:16:51,110 --> 01:16:53,060
Microsoft 使用的另一种技术，您

2029
01:16:53,060 --> 01:16:54,890
只需制作一个小的 小迷你表并

2030
01:16:54,890 --> 01:16:56,570
复制一些数据，然后

2031
01:16:56,570 --> 01:16:59,330
根据它进行估计，如果是这样，

2032
01:16:59,330 --> 01:17:01,850
那么也用于新的成本模型

2033
01:17:01,850 --> 01:17:02,630
，我们可以将其连接到采石场

2034
01:17:02,630 --> 01:17:04,810
优化器，这也很棒

2035
01:17:04,810 --> 01:17:06,860
如果您对

2036
01:17:06,860 --> 01:17:09,740
诸如您实际上如何查询我们

2037
01:17:09,740 --> 01:17:11,330
想要支持公用表表达式更感兴趣，

2038
01:17:11,330 --> 01:17:14,360
那么现在我们再次支持 TPC HT PCH

2039
01:17:14,360 --> 01:17:16,430
是从 90 年代开始的，它没有 CT es

2040
01:17:16,430 --> 01:17:19,940
非常简单 CPC des 是一个 更

2041
01:17:19,940 --> 01:17:25,370
复杂的 DSN 排序决策

2042
01:17:25,370 --> 01:17:27,530
支持说更复杂的 OLAP 工作负载

2043
01:17:27,530 --> 01:17:29,390
分析工作在 NT PCH 上，这

2044
01:17:29,390 --> 01:17:30,830
有很多 CT 方便，但我们不

2045
01:17:30,830 --> 01:17:32,480
支持任何一个，所以这将

2046
01:17:32,480 --> 01:17:34,340
修改我们的解析器扩展

2047
01:17:34,340 --> 01:17:35,690
解析器以支持 width 和 union

2048
01:17:35,690 --> 01:17:39,110
子句修改优化器以

2049
01:17:39,110 --> 01:17:43,730
推断您知道 wif 子句并

2050
01:17:43,730 --> 01:17:45,590
可能在某些情况下重写它以连接

2051
01:17:45,590 --> 01:17:48,290
，然后我不知道

2052
01:17:48,290 --> 01:17:49,490
它是否正确但您可能还必须

2053
01:17:49,490 --> 01:17:51,650
修改执行引擎以

2054
01:17:51,650 --> 01:17:53,090
实际支持 CTS

2055
01:17:53,090 --> 01:17:54,260
取决于查询的实际情况

2056
01:17:54,260 --> 01:17:56,960
，我将完全承认我不完全了解

2057
01:17:56,960 --> 01:17:59,420
我不知道您可以展开

2058
01:17:59,420 --> 01:18:03,080
或 D 关联或重写 CT 的所有方式

2059
01:18:03,080 --> 01:18:05,390
实际上有一个非常好的

2060
01:18:05,390 --> 01:18:08,360
textboo  k 不是来自德国的超级指南，

2061
01:18:08,360 --> 01:18:10,610
而是来自他的另一位德国顾问，所以

2062
01:18:10,610 --> 01:18:11,900
另一个德国人写了一本关于查询优化器的书，

2063
01:18:11,900 --> 01:18:13,520
然后我们可以访问

2064
01:18:13,520 --> 01:18:14,600
描述所有相关技术的书，

2065
01:18:14,600 --> 01:18:16,010
所以这是我们也可以做的事情，

2066
01:18:16,010 --> 01:18:19,010
我们还使用了一个端口 添加/删除

2067
01:18:19,010 --> 01:18:21,710
索引，所以现在我们可以

2068
01:18:21,710 --> 01:18:23,390
在创建表时调用 create index ，然后

2069
01:18:23,390 --> 01:18:24,890
当您将元组插入表中时，我们

2070
01:18:24,890 --> 01:18:26,750
将填充它，但是如果表中

2071
01:18:26,750 --> 01:18:28,130
已经存在一堆

2072
01:18:28,130 --> 01:18:30,020
数据并且您调用创建索引 当您暂停所有事务的执行时，无法

2073
01:18:30,020 --> 01:18:32,060
返回并填充最简单的方法来

2074
01:18:32,060 --> 01:18:34,190
做到这

2075
01:18:34,190 --> 01:18:36,710


2076
01:18:36,710 --> 01:18:38,330
一点，然后他们填充它然后重新打开事务，

2077
01:18:38,330 --> 01:18:40,310
但显然这很糟糕，因为

2078
01:18:40,310 --> 01:18:42,230
您正在阻止一切，因此

2079
01:18:42,230 --> 01:18:46,850
能够构建 当你还在

2080
01:18:46,850 --> 01:18:47,989


2081
01:18:47,989 --> 01:18:51,019
整理表格时，索引非常有趣，

2082
01:18:51,019 --> 01:18:52,789
一堆系统刚刚添加，比如 PostGIS

2083
01:18:52,789 --> 01:18:54,639
只是在过去几年中添加了这个，

2084
01:18:54,639 --> 01:18:58,010
所以这真的

2085
01:18:58,010 --> 01:18:59,449
很棒，做这件事也很棒 使用并行

2086
01:18:59,449 --> 01:19:00,679
线程将此视为

2087
01:19:00,679 --> 01:19:02,659
使用多个线程进行顺序扫描，

2088
01:19:02,659 --> 01:19:05,320
并且它们都插入到相关的索引中

2089
01:19:05,320 --> 01:19:07,429
这将是多个 T

2090
01:19:07,429 --> 01:19:10,999
线程查询当前

2091
01:19:10,999 --> 01:19:12,260
我们拥有的当前版本，你们正在使用

2092
01:19:12,260 --> 01:19:15,860
并且系统仅支持

2093
01:19:15,860 --> 01:19:18,530
单线程 查询，但

2094
01:19:18,530 --> 01:19:19,699
每次拍摄都有我的博士生有一个

2095
01:19:19,699 --> 01:19:22,039
支持并行查询的分支，但嘿

2096
01:19:22,039 --> 01:19:23,570


2097
01:19:23,570 --> 01:19:25,340
，如果这个

2098
01:19:25,340 --> 01:19:27,260
想法将移植到他的并行

2099
01:19:27,260 --> 01:19:29,449
查询实现上，然后

2100
01:19:29,449 --> 01:19:31,070
修改其余部分，那么他只有执行引擎方面的唯一负责人

2101
01:19:31,070 --> 01:19:32,989
系统的基础设施来识别哦，我可以

2102
01:19:32,989 --> 01:19:34,820
并行运行查询 确保你

2103
01:19:34,820 --> 01:19:36,769
知道计划你的计划以正确的

2104
01:19:36,769 --> 01:19:38,809
方式出现，这样他们就可以瘫痪 我们

2105
01:19:38,809 --> 01:19:40,369
也可以开始添加对像

2106
01:19:40,369 --> 01:19:41,300
pneuma where 数据放置

2107
01:19:41,300 --> 01:19:43,909
技术的支持，超级家伙

2108
01:19:43,909 --> 01:19:46,929
一旦我们掌握了基本

2109
01:19:46,929 --> 01:19:49,639
的基本知识，在并行引擎中

2110
01:19:49,639 --> 01:19:52,699
工作准备好的语句也

2111
01:19:52,699 --> 01:19:55,039
非常重要，我们正在做一些事情 rrently不

2112
01:19:55,039 --> 01:19:56,749
支持这个所以准备好的语句

2113
01:19:56,749 --> 01:19:58,400
是一对语句它说我将

2114
01:19:58,400 --> 01:20:00,380
不再提示这个查询这里

2115
01:20:00,380 --> 01:20:02,360
有一些参数的占位符所以

2116
01:20:02,360 --> 01:20:03,949
你需要喜欢缓存然后你

2117
01:20:03,949 --> 01:20:06,139
可以调用它和 我们

2118
01:20:06,139 --> 01:20:07,639
一遍又一遍地使用该计划，因此当您想要执行准备好的

2119
01:20:07,639 --> 01:20:09,139
语句时，您必须考虑许多不同的设计决策，

2120
01:20:09,139 --> 01:20:12,380


2121
01:20:12,380 --> 01:20:13,999
例如当您

2122
01:20:13,999 --> 01:20:15,079
实际通过优化器运行它

2123
01:20:15,079 --> 01:20:16,429
时，当您真正决定重新规划

2124
01:20:16,429 --> 01:20:18,349
所有各种数据系统所做的事情时

2125
01:20:18,349 --> 01:20:20,210
不同的事情，这将是

2126
01:20:20,210 --> 01:20:21,679
对不同技术的一种评估，

2127
01:20:21,679 --> 01:20:23,360
因此您必须

2128
01:20:23,360 --> 01:20:26,780
修改有线协议来处理这个问题，

2129
01:20:26,780 --> 01:20:28,670
然后确保我们实际上会

2130
01:20:28,670 --> 01:20:31,070
非常棒，如果不是有

2131
01:20:31,070 --> 01:20:32,869
一个准备好的语句缓存和 然后

2132
01:20:32,869 --> 01:20:34,670
编译查询缓存，如果我们可以将

2133
01:20:34,670 --> 01:20:35,989
它们统一在一起，那将是一个巨大的

2134
01:20:35,989 --> 01:20:37,849
胜利，所以我的博士生马特

2135
01:20:37,849 --> 01:20:38,989
现在正在研究这个，所以如果我们有

2136
01:20:38,989 --> 01:20:41,599
兴趣追求这个，你知道的

2137
01:20:41,599 --> 01:20:43,699
我知道我们可以在下周

2138
01:20:43,699 --> 01:20:46,579
或本周开始讨论这些

2139
01:20:46,579 --> 01:20:47,780
支持写出日志我认为我们可以

2140
01:20:47,780 --> 01:20:51,050
在重新启动时重播日志这不是

2141
01:20:51,050 --> 01:20:52,219
真的我认为我们可以重用所有

2142
01:20:52,219 --> 01:20:54,139
目录但是正如我所说的那样 也

2143
01:20:54,139 --> 01:20:55,369
能够采取检查点，我们不会

2144
01:20:55,369 --> 01:20:57,320
重播整个日志，所以这将

2145
01:20:57,320 --> 01:21:01,730
增加对检查点的支持，所以

2146
01:21:01,730 --> 01:21:03,350
我认为最简单的

2147
01:21:03,350 --> 01:21:04,340
方法是快照隔离

2148
01:21:04,340 --> 01:21:07,160
拥有检查点，你只需

2149
01:21:07,160 --> 01:21:08,270
用这个来接你 Winchell 扫描

2150
01:21:08,270 --> 01:21:09,440
实现在

2151
01:21:09,440 --> 01:21:11,480
日常系统中时不时可用，这个 nagra 在

2152
01:21:11,480 --> 01:21:13,850
这里查看一个示例，如果

2153
01:21:13,850 --> 01:21:15,380


2154
01:21:15,380 --> 01:21:16,820
另一个团队正在执行并行查询

2155
01:21:16,820 --> 01:21:18,620
并且他们支持并行 scruncho

2156
01:21:18,620 --> 01:21:21,050
扫描，那么您可以与另一个团队协同工作，然后您可以在

2157
01:21:21,050 --> 01:21:23,270
您的 检查点算法，现在做

2158
01:21:23,270 --> 01:21:25,700
特殊扫描和并行

2159
01:21:25,700 --> 01:21:27,890
写出检查点，然后我们希望

2160
01:21:27,890 --> 01:21:29,780
能够在我们开始后加载检查点

2161
01:21:29,780 --> 01:21:31,460
然后重播日志，

2162
01:21:31,460 --> 01:21:32,750
所以听起来我接受 一个检查点我已经完成了

2163
01:21:32,750 --> 01:21:34,489
整合完整的情感这很

2164
01:21:34,489 --> 01:21:37,150
棘手我们想要支持

2165
01:21:37,150 --> 01:21:41,300
像捷克唯一性外键

2166
01:21:41,300 --> 01:21:44,270
这样的约束所以这是修改

2167
01:21:44,270 --> 01:21:48,380
目录修改修改

2168
01:21:48,380 --> 01:21:49,580
就像系统前端大卫

2169
01:21:49,580 --> 01:21:51,320
递这个信息修改

2170
01:21:51,320 --> 01:21:53,090
商店是强制执行这些约束的借口，

2171
01:21:53,090 --> 01:21:55,760
所以如果我有一个检查

2172
01:21:55,760 --> 01:21:57,530
子句，比如 where value is

2173
01:21:57,530 --> 01:21:59,840
not you know notnegative

2174
01:21:59,840 --> 01:22:00,980


2175
01:22:00,980 --> 01:22:02,300


2176
01:22:02,300 --> 01:22:04,150


2177
01:22:04,150 --> 01:22:07,460
与外键相同的事情，

2178
01:22:07,460 --> 01:22:09,080
您可以做的其他事情是

2179
01:22:09,080 --> 01:22:10,930
使用alter mean 进行在线约束更改，

2180
01:22:10,930 --> 01:22:12,860
如果我添加一个约束，说明

2181
01:22:12,860 --> 01:22:14,630
此键不能为空，我必须

2182
01:22:14,630 --> 01:22:15,770
扫描并确保没有任何内容为空，

2183
01:22:15,770 --> 01:22:17,180
因为因此我会你 知道如果我

2184
01:22:17,180 --> 01:22:17,989
尝试插入您的共享，这

2185
01:22:17,989 --> 01:22:19,160
在开始时已经被违反，

2186
01:22:19,160 --> 01:22:21,950
这很糟糕，实际上能够做的另一件很酷的事情

2187
01:22:21,950 --> 01:22:24,020
是扩展

2188
01:22:24,020 --> 01:22:26,570
查询优化器以了解 其中

2189
01:22:26,570 --> 01:22:28,610
一些限制，比如我知道

2190
01:22:28,610 --> 01:22:29,989
有些事情不能是负面的，所以

2191
01:22:29,989 --> 01:22:31,610
我可能想改变我做我的加入或

2192
01:22:31,610 --> 01:22:34,400
做扫描的

2193
01:22:34,400 --> 01:22:35,960
方式，这是可以做到这一点的高端系统，

2194
01:22:35,960 --> 01:22:38,540
实际上是超级酷的序列是

2195
01:22:38,540 --> 01:22:40,400
自动 增量键，因此这将

2196
01:22:40,400 --> 01:22:41,960
增加支持，我们可以

2197
01:22:41,960 --> 01:22:44,870
在目录中存储序列并提供

2198
01:22:44,870 --> 01:22:46,700
支持下一个阀门功能或

2199
01:22:46,700 --> 01:22:48,500
串行类型，以便我们可以轻松地执行

2200
01:22:48,500 --> 01:22:51,080
自动增量键，这个

2201
01:22:51,080 --> 01:22:53,840
有点棘手，因为当您

2202
01:22:53,840 --> 01:22:55,970
缓存 目录，以便

2203
01:22:55,970 --> 01:22:57,230
每个调用下一个阀门的每个人都不会

2204
01:22:57,230 --> 01:22:58,820
总是更新目录，您可以

2205
01:22:58,820 --> 01:22:59,840
在内存中放置一些东西

2206
01:22:59,840 --> 01:23:01,940


2207
01:23:01,940 --> 01:23:03,560
，然后分批分发 棘手的事情是，您必须

2208
01:23:03,560 --> 01:23:05,360
然后在正确的前面

2209
01:23:05,360 --> 01:23:07,820
记录该值的值 增加了所以

2210
01:23:07,820 --> 01:23:09,290
如果我崩溃回来计数器不会

2211
01:23:09,290 --> 01:23:11,450
再次从零开始我没有我没有

2212
01:23:11,450 --> 01:23:14,390
重复值不同类型也很

2213
01:23:14,390 --> 01:23:15,649
有趣

2214
01:23:15,649 --> 01:23:17,329
所以我们讨论了如何

2215
01:23:17,329 --> 01:23:18,889
他们声称来自德国人的数字类型

2216
01:23:18,889 --> 01:23:21,619
比浮点数更快，然后

2217
01:23:21,619 --> 01:23:22,760
他们声称有一本书叫做

2218
01:23:22,760 --> 01:23:25,039
黑客喜悦，这是谷歌你可以

2219
01:23:25,039 --> 01:23:29,510
找到它描述了在固定的

2220
01:23:29,510 --> 01:23:32,389
基础上进行低位运算的底层方法

2221
01:23:32,389 --> 01:23:34,369
小数点

2222
01:23:34,369 --> 01:23:36,050
它并没有准确地描述如何在

2223
01:23:36,050 --> 01:23:37,340
数据库的概念中做，就像

2224
01:23:37,340 --> 01:23:39,169
我们必须做的很多其他事情一样，但是

2225
01:23:39,169 --> 01:23:41,929
可以在本书中找到位操作技术

2226
01:23:41,929 --> 01:23:42,439
，

2227
01:23:42,439 --> 01:23:44,149
所以我实际上对此也非常感兴趣，

2228
01:23:44,149 --> 01:23:45,860
我不知道” 不知道怎么做，但

2229
01:23:45,860 --> 01:23:48,169
如果

2230
01:23:48,169 --> 01:23:49,909
你在类型上受伤，我们可以坐下来一起学习我想做

2231
01:23:49,909 --> 01:23:51,829
一些更简单的枚举类型将是

2232
01:23:51,829 --> 01:23:53,570
另一个你可以做的，这

2233
01:23:53,570 --> 01:23:55,489
就像你在 C++ 或 Java 中的枚举

2234
01:23:55,489 --> 01:23:58,639
在你必须做的想法中，同样的事情

2235
01:23:58,639 --> 01:24:00,289
是你会支持在

2236
01:24:00,289 --> 01:24:01,879
牛将跟踪所有枚举

2237
01:24:01,879 --> 01:24:03,829
作为数组修改绑定器以

2238
01:24:03,829 --> 01:24:05,300
能够强制执行这些枚举约束

2239
01:24:05,300 --> 01:24:06,590
所以有人给我们一个不

2240
01:24:06,590 --> 01:24:08,570
存在你知道我们抛出一个错误，

2241
01:24:08,570 --> 01:24:10,189
然后我们必须能够

2242
01:24:10,189 --> 01:24:13,159
在执行引擎中支持这一点，以知道我

2243
01:24:13,159 --> 01:24:14,689
正在对一个枚举进行操作，

2244
01:24:14,689 --> 01:24:15,949
然后将它产生结果的正确值具体化

2245
01:24:15,949 --> 01:24:17,449
到

2246
01:24:17,449 --> 01:24:21,079
我正在使用的应用程序中 我会很快做这件事，

2247
01:24:21,079 --> 01:24:22,789
但你知道所有的幻灯片都在线我

2248
01:24:22,789 --> 01:24:23,989
不必在之后谈论这个

2249
01:24:23,989 --> 01:24:26,929
，所以我们没有谈论

2250
01:24:26,929 --> 01:24:28,070
视图，但我认为它们

2251
01:24:28,070 --> 01:24:29,929
就像一个虚拟表，就像在选择上定义视图一样

2252
01:24:29,929 --> 01:24:32,059
查询，我给它一个名字，它

2253
01:24:32,059 --> 01:24:33,709
看起来像一个表，然后现在我可以

2254
01:24:33,709 --> 01:24:36,469
在那个视图上运行一个查询，把它当作

2255
01:24:36,469 --> 01:24:38,629
一个表来对待，通常它

2256
01:24:38,629 --> 01:24:40,789
是一些处理数据的方式，它会

2257
01:24:40,789 --> 01:24:44,749
重写你的 查询到要

2258
01:24:44,749 --> 01:24:47,059
在实际基础上进行查找的

2259
01:24:47,059 --> 01:24:51,110
您知道的视图查询，因此我们

2260
01:24:51,110 --> 01:24:52,489
必须支持扩展目录

2261
01:24:52,489 --> 01:24:54,349
以放置这些东西，我们必须

2262
01:24:54,349 --> 01:24:56,510
修改绑定器以将视图转换

2263
01:24:56,510 --> 01:24:58,879
为原始查询和 据你

2264
01:24:58,879 --> 01:24:59,989
所知，我认为我们不必修改

2265
01:24:59,989 --> 01:25:01,369
这个你流 e  ngine 你可以

2266
01:25:01,369 --> 01:25:02,869
将视图重写为嵌套查询，我认为它

2267
01:25:02,869 --> 01:25:05,179
可以工作，然后优化器可以

2268
01:25:05,179 --> 01:25:07,039
让你知道 D 关联或根据

2269
01:25:07,039 --> 01:25:08,169
需要

2270
01:25:08,169 --> 01:25:10,669
优化最后两个并发模式

2271
01:25:10,669 --> 01:25:13,489
更改，如果我添加一个

2272
01:25:13,489 --> 01:25:15,439
列，我可以在没有的情况下做到这一点

2273
01:25:15,439 --> 01:25:17,059
锁定一切 这实际上非常

2274
01:25:17,059 --> 01:25:18,709
棘手 这是我们尝试的第二年

2275
01:25:18,709 --> 01:25:20,239
我们认为现在我们拥有

2276
01:25:20,239 --> 01:25:21,949
能够以一种非常有趣的方式做到这一点的基础设施

2277
01:25:21,949 --> 01:25:24,530
因为现在我们

2278
01:25:24,530 --> 01:25:26,629
可以像这种懒惰的方法那样做

2279
01:25:26,629 --> 01:25:29,150
说在一列我们告诉你我们添加了

2280
01:25:29,150 --> 01:25:30,949
但我们实际上并没有通过它

2281
01:25:30,949 --> 01:25:34,370
并且你知道在周围随机添加

2282
01:25:34,370 --> 01:25:36,590
那个内存位置它只有当

2283
01:25:36,590 --> 01:25:38,060
你插入新东西或者你试图读

2284
01:25:38,060 --> 01:25:39,590
回旧东西然后我们可以实现

2285
01:25:39,590 --> 01:25:40,600


2286
01:25:40,600 --> 01:25:44,150
最后一个是数据压缩，所以我们

2287
01:25:44,150 --> 01:25:46,820
支持 Apache arrow 并且我们

2288
01:25:46,820 --> 01:25:48,050
支持他们的字典压缩

2289
01:25:48,050 --> 01:25:49,730
方案，这是非常简单的，但

2290
01:25:49,730 --> 01:25:52,520
它没有打开意味着我们不能接受

2291
01:25:52,520 --> 01:25:53,929
热数据并转换它 进入

2292
01:25:53,929 --> 01:25:56,600
压缩的冷数据块，我们曾经

2293
01:25:56,600 --> 01:25:57,860
拥有该基础架构，但我们不再拥有，

2294
01:25:57,860 --> 01:26:00,080
因此这将增加

2295
01:26:00,080 --> 01:26:03,110
对转换的支持，

2296
01:26:03,110 --> 01:26:04,040
因为我们没有它，因为我们

2297
01:26:04,040 --> 01:26:05,570
因为您还必须更新索引

2298
01:26:05,570 --> 01:26:06,650
将元组从一个位置重新移动

2299
01:26:06,650 --> 01:26:07,429
到另一个位置，

2300
01:26:07,429 --> 01:26:09,110
但是现在棘手的事情

2301
01:26:09,110 --> 01:26:11,480
是以某种方式修改执行引擎，

2302
01:26:11,480 --> 01:26:13,400
以便能够直接处理

2303
01:26:13,400 --> 01:26:15,710
压缩数据，因为

2304
01:26:15,710 --> 01:26:18,230
现在我们不能这样做，我们必须

2305
01:26:18,230 --> 01:26:20,239
拥有 数据表在

2306
01:26:20,239 --> 01:26:21,860
我们可以对其进行扫描之前对其进行解压缩，这违背

2307
01:26:21,860 --> 01:26:23,600
了压缩的全部目的，

2308
01:26:23,600 --> 01:26:24,440
所以我如何开始

2309
01:26:24,440 --> 01:26:26,000
组建一个已经

2310
01:26:26,000 --> 01:26:29,060
完成项目二的团队您应该与您的

2311
01:26:29,060 --> 01:26:30,460
团队会面讨论您的潜在主题

2312
01:26:30,460 --> 01:26:32,390
可能会查看 源代码或

2313
01:26:32,390 --> 01:26:34,640
与我联系以向您指出

2314
01:26:34,640 --> 01:26:35,600
您想要查看的源代码的哪些部分

2315
01:26:35,600 --> 01:26:37,940
我下周都在附近或给

2316
01:26:37,940 --> 01:26:39,860
我发送电子邮件并进行讨论您

2317
01:26:39,860 --> 01:26:41,120
知道有哪些潜在的停止 rs 你可以查

2318
01:26:41,120 --> 01:26:43,460
一下 好吧 抱歉

2319
01:26:43,460 --> 01:26:46,219
下节课要加班 我会在

2320
01:26:46,219 --> 01:26:47,870
Piazza 上发布更多细节 但你有

2321
01:26:47,870 --> 01:26:49,790
你的散文或演讲五

2322
01:26:49,790 --> 01:26:50,989
分钟 这是一个硬限制

2323
01:26:50,989 --> 01:26:52,880


2324
01:26:52,880 --> 01:26:55,400
在边上的公园里，

2325
01:26:55,400 --> 01:26:57,540
有些傻瓜说你在这里是什么

2326
01:26:57,540 --> 01:26:58,810
[音乐]

2327
01:26:58,810 --> 01:27:01,360
婊子们还没有死在这里叫鹰

2328
01:27:01,360 --> 01:27:04,150
它因为我把冰块放在

2329
01:27:04,150 --> 01:27:04,840
暴躁的

2330
01:27:04,840 --> 01:27:08,110
你看，它是去给我拿一个 40

2331
01:27:08,110 --> 01:27:10,450
只是为了得到 我的流行歌曲因为我需要

2332
01:27:10,450 --> 01:27:13,120
它多一点像鱼一样踢到

2333
01:27:13,120 --> 01:27:18,480
一个简单的只是放下它们说

2334
01:27:18,480 --> 01:27:21,610
好我的兜帽要我说我很

2335
01:27:21,610 --> 01:27:25,590
可爱说我庆祝

