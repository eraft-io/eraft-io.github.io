1
00:00:01,300 --> 00:00:05,129
[音乐]

2
00:00:05,200 --> 00:00:05,930
[掌声]

3
00:00:05,930 --> 00:00:08,630
[音乐]

4
00:00:08,630 --> 00:00:10,020
[掌声]

5
00:00:10,020 --> 00:00:11,540
[音乐]

6
00:00:11,540 --> 00:00:15,599
我们今天开始一切正常，我们

7
00:00:15,599 --> 00:00:17,609
从网络协议开始，所以

8
00:00:17,609 --> 00:00:20,250
我们正处于学期的时候，

9
00:00:20,250 --> 00:00:21,720
我现在想像一个高级别的

10
00:00:21,720 --> 00:00:25,230
概述我们已经讨论过的内容以及

11
00:00:25,230 --> 00:00:27,090
我们计划讨论的内容 一开始

12
00:00:27,090 --> 00:00:28,080
就很难展示这一点，

13
00:00:28,080 --> 00:00:30,869
因为我们讨论的主题

14
00:00:30,869 --> 00:00:32,399
有点分散，让我们谈谈

15
00:00:32,399 --> 00:00:35,130
索引的 Kearney 高，它是一些

16
00:00:35,130 --> 00:00:37,739
存储的东西，但是这个 是我们脑海

17
00:00:37,739 --> 00:00:40,980


18
00:00:40,980 --> 00:00:42,930
中设想的系统的概念性

19
00:00:42,930 --> 00:00:43,920
说明 我们正在讨论

20
00:00:43,920 --> 00:00:45,149


21
00:00:45,149 --> 00:00:47,610
如何构建它的外观的各种主题 所以这是

22
00:00:47,610 --> 00:00:50,070
我们的应用程序 他们发送了一个续集查询

23
00:00:50,070 --> 00:00:51,989
这将登陆 我们的网络

24
00:00:51,989 --> 00:00:53,100
层，这就是我们今天要讨论的

25
00:00:53,100 --> 00:00:55,620
内容，然后我们点击查询

26
00:00:55,620 --> 00:00:57,780
优化器或计划器，因此

27
00:00:57,780 --> 00:00:59,699
续集绑定到目录对象的报告

28
00:00:59,699 --> 00:01:01,710
做我们想做的任何重写，然后

29
00:01:01,710 --> 00:01:03,030
通过我们的查询优化器运行它以

30
00:01:03,030 --> 00:01:05,459
生成 一种  物理计划然后我们

31
00:01:05,459 --> 00:01:06,840
现在将通过一个现在没有意义的编译器传递

32
00:01:06,840 --> 00:01:08,340
它但我们将

33
00:01:08,340 --> 00:01:09,900
在几周内讨论这个基本上

34
00:01:09,900 --> 00:01:11,369
我们将采用该物理计划

35
00:01:11,369 --> 00:01:13,710
并将其转换为机器代码而

36
00:01:13,710 --> 00:01:15,810
不是实际 解释它然后我们有

37
00:01:15,810 --> 00:01:16,860
我们的执行引擎，实际上

38
00:01:16,860 --> 00:01:18,780
我们将在线程中执行查询，

39
00:01:18,780 --> 00:01:20,070
然后我们在下面有一个存储曲线

40
00:01:20,070 --> 00:01:22,830
所以这个我们已经

41
00:01:22,830 --> 00:01:24,570
讨论了一堆东西已经这个

42
00:01:24,570 --> 00:01:25,409
我们已经讨论了一堆东西

43
00:01:25,409 --> 00:01:26,939
这些是

44
00:01:26,939 --> 00:01:28,110
我们已经介绍过的部分 我们已经

45
00:01:28,110 --> 00:01:29,070
介绍了如何进行收敛角色

46
00:01:29,070 --> 00:01:31,530
索引 Gorge 模型和记录

47
00:01:31,530 --> 00:01:34,170
检查点 所以现在

48
00:01:34,170 --> 00:01:36,329
我们再次回到顶部，然后继续

49
00:01:36,329 --> 00:01:37,950
前进 跳来跳去，

50
00:01:37,950 --> 00:01:40,670
从这里开始，然后按照我们的方式回到

51
00:01:40,670 --> 00:01:42,960
这一部分，虽然就像歌剧执行一样，

52
00:01:42,960 --> 00:01:44,729
我们将

53
00:01:44,729 --> 00:01:46,049
在本学期的剩余时间里基本上涵盖这一切，就像

54
00:01:46,049 --> 00:01:47,579
我们将讨论如何进行并行或

55
00:01:47,579 --> 00:01:50,540
向量化散列连接向量化排序

56
00:01:50,540 --> 00:01:54,299
和 nvcc 的东西几乎涵盖了所有

57
00:01:54,299 --> 00:01:56,100
这些，至少

58
00:01:56,100 --> 00:01:57,780
像在你脑海中的规划者一样

59
00:01:57,780 --> 00:01:59,130
思考哦，我正在多版本数据库上研究多 Verte

60
00:01:59,130 --> 00:02:00,990


61
00:02:00,990 --> 00:02:02,880
，当我设计我的系统时，这意味着什么

62
00:02:02,880 --> 00:02:05,549
所以这

63
00:02:05,549 --> 00:02:07,590
在本学期剩下的时间里就差不多

64
00:02:07,590 --> 00:02:09,030
结束了，然后在最后两

65
00:02:09,030 --> 00:02:10,860
节课就像杂烩一样，我们有一个

66
00:02:10,860 --> 00:02:12,720
新的硬件或将机器

67
00:02:12,720 --> 00:02:13,300
学习方法应用

68
00:02:13,300 --> 00:02:18,100
到堆栈中，所以正如我今天所说的那样，

69
00:02:18,100 --> 00:02:19,150
我们” 将要讨论网络

70
00:02:19,150 --> 00:02:21,970
协议，这要么是

71
00:02:21,970 --> 00:02:23,650
从客户端进入数据库的数据，

72
00:02:23,650 --> 00:02:26,410
要么是我们如何将数据发送到我们的副本

73
00:02:26,410 --> 00:02:28,900
以实现高可用性，但是

74
00:02:28,900 --> 00:02:30,880
你们如何阅读的论文都是关于摄取

75
00:02:30,880 --> 00:02:32,980
Gator 并接受查询和 获取

76
00:02:32,980 --> 00:02:35,950
数据，所以让我们基本上

77
00:02:35,950 --> 00:02:37,330
讨论如何在应用程序中

78
00:02:37,330 --> 00:02:40,330
编写访问

79
00:02:40,330 --> 00:02:41,950
数据库和运行查询的不同方法，然后我们将

80
00:02:41,950 --> 00:02:44,080
讨论实际从未更广泛的协议是什么

81
00:02:44,080 --> 00:02:45,340
样的 您

82
00:02:45,340 --> 00:02:46,870
通过网络发回响应，

83
00:02:46,870 --> 00:02:48,580
然后我们将简要讨论现有的

84
00:02:48,580 --> 00:02:49,900
不同复制协议，您

85
00:02:49,900 --> 00:02:51,220


86
00:02:51,220 --> 00:02:53,140
可以进行哪些设置，然后我们将

87
00:02:53,140 --> 00:02:56,470
使用两种不同的技术来

88
00:02:56,470 --> 00:02:58,120
绕过 操作系统尽可能多

89
00:02:58,120 --> 00:03:00,460
地称为内核旁路方法，因此

90
00:03:00,460 --> 00:03:02,410
对于所有这些消费者通过 TC

91
00:03:02,410 --> 00:03:05,020
IP 堆栈，为了简单起见，我们

92
00:03:05,020 --> 00:03:06,580
假设我们正在通过操作系统，这

93
00:03:06,580 --> 00:03:09,130
是一种解决该问题的方法，然后

94
00:03:09,130 --> 00:03:10,270
我们将完成 简要谈谈

95
00:03:10,270 --> 00:03:14,440
对项目的期望 - 好吧

96
00:03:14,440 --> 00:03:14,680


97
00:03:14,680 --> 00:03:19,600
，到目前为止，

98
00:03:19,600 --> 00:03:22,450
我在课堂上提供的所有演示都使用

99
00:03:22,450 --> 00:03:25,060
Postgres 或中断课程 我们展示了

100
00:03:25,060 --> 00:03:27,160
我的续集 我们向 Oracle 展示了所有这些

101
00:03:27,160 --> 00:03:29,920
都在打开终端 通过 SSH

102
00:03:29,920 --> 00:03:31,840
我输入一些查询

103
00:03:31,840 --> 00:03:34,840
，然后按 Enter 然后返回文本响应，因此

104
00:03:34,840 --> 00:03:37,150
在实际应用程序中这不是它

105
00:03:37,150 --> 00:03:39,730
实际工作的方式，因为我

106
00:03:39,730 --> 00:03:41,920
返回的是显示终端就像

107
00:03:41,920 --> 00:03:46,870
是文本，它是我 t 的字符，所以如果我

108
00:03:46,870 --> 00:03:48,489
正在编写一个应用程序，我将

109
00:03:48,489 --> 00:03:50,590
像这样通过终端，我

110
00:03:50,590 --> 00:03:52,209
现在基本上必须解析文本

111
00:03:52,209 --> 00:03:54,220
字段，提取出我正在寻找的值

112
00:03:54,220 --> 00:03:55,360
并将它们转换

113
00:03:55,360 --> 00:03:56,890
为我的爱好的正确类型，然后

114
00:03:56,890 --> 00:03:59,410
会超级慢，而且没有人会

115
00:03:59,410 --> 00:04:02,800
真正做到这一点，所以

116
00:04:02,800 --> 00:04:04,480
我们在真正的程序中真正要做的

117
00:04:04,480 --> 00:04:08,260
是，我们将拥有一个 API，它是一个

118
00:04:08,260 --> 00:04:09,880
编程接口，然后我们可以

119
00:04:09,880 --> 00:04:11,620
在我们的数据库上编写查询

120
00:04:11,620 --> 00:04:14,380
，然后 我们在我们的

121
00:04:14,380 --> 00:04:17,829
应用程序中暴露的大部分是二进制值，

122
00:04:17,829 --> 00:04:19,630
如果是你要取回

123
00:04:19,630 --> 00:04:23,110
JSON，那么并不总是像在实际

124
00:04:23,110 --> 00:04:25,000
应用程序中那样，或者如果你真的降低了

125
00:04:25,000 --> 00:04:26,080
性能，那么你希望二进制

126
00:04:26,080 --> 00:04:27,080
可以追溯到应用程序

127
00:04:27,080 --> 00:04:28,460
然后 您不必

128
00:04:28,460 --> 00:04:30,379
在您的应用程序中自己进行任何转换，

129
00:04:30,379 --> 00:04:31,849
例如哦，我知道我正在查看一个整数，

130
00:04:31,849 --> 00:04:33,259
但我有该整数的字符串表示形式

131
00:04:33,259 --> 00:04:36,500
，现在让我将其转换

132
00:04:36,500 --> 00:04:36,889
为结尾，

133
00:04:36,889 --> 00:04:39,560
因此所有这些 API 都是 这 

134
00:04:39,560 --> 00:04:41,629
通过某些

135
00:04:41,629 --> 00:04:44,990
标准编程接口获得最佳性能的方法

136
00:04:44,990 --> 00:04:46,939
首先讨论直接访问，这些

137
00:04:46,939 --> 00:04:50,180
将是每个数据库供应商可以提供的木瓜类型的 api 或

138
00:04:50,180 --> 00:04:51,830
库

139
00:04:51,830 --> 00:04:53,810
，然后我们将

140
00:04:53,810 --> 00:04:56,810
讨论实际上现在拥有更多 通用

141
00:04:56,810 --> 00:04:59,659
或通用的访问方法或 api

142
00:04:59,659 --> 00:05:02,599
可能

143
00:05:02,599 --> 00:05:04,190
不需要重写我们的应用程序以

144
00:05:04,190 --> 00:05:06,050
使用如果我们有一天将女人切换到这个

145
00:05:06,050 --> 00:05:07,430
供应商到另一个我们可能不得不

146
00:05:07,430 --> 00:05:10,159
更改续集查询方言但是如果

147
00:05:10,159 --> 00:05:11,330
我们针对这些东西进行编程那么这

148
00:05:11,330 --> 00:05:18,169
将 标准化好吧，我

149
00:05:18,169 --> 00:05:21,680
又是从哪里开始的，这些人的想法

150
00:05:21,680 --> 00:05:23,900
是，如果我使用 ODBC 或 JDBC 阅读我的应用程序，

151
00:05:23,900 --> 00:05:27,590
那么如果我

152
00:05:27,590 --> 00:05:29,449
今天使用我的续集，

153
00:05:29,449 --> 00:05:31,310
我会向 IBM 提供资金，然后切换到我的

154
00:05:31,310 --> 00:05:33,560
应用程序 在 db2 上，我不必

155
00:05:33,560 --> 00:05:35,419
重写任何我的应用程序代码，因为

156
00:05:35,419 --> 00:05:38,539
这些东西是您

157
00:05:38,539 --> 00:05:41,389
将用于我的续集的 API，并且 db2

158
00:05:41,389 --> 00:05:43,129
将在这些东西上标准化我

159
00:05:43,129 --> 00:05:45,620
可以续写我的头部变化，但就像

160
00:05:45,620 --> 00:05:50,979
实际代码本身不会改变所以

161
00:05:50,979 --> 00:05:52,969
实际上只是快速返回

162
00:05:52,969 --> 00:05:53,900
这个我们不会谈论太多

163
00:05:53,900 --> 00:05:54,770
关于这个没有什么可说的，

164
00:05:54,770 --> 00:05:58,490
除了像每个人

165
00:05:58,490 --> 00:06:00,560
都有他们的 自己的东西，理想情况下不应该

166
00:06:00,560 --> 00:06:02,900
给我们编程这些 api 的权利，你

167
00:06:02,900 --> 00:06:04,759
应该总是

168
00:06:04,759 --> 00:06:06,319
在它前面有一些这样的东西

169
00:06:06,319 --> 00:06:07,789
，这样你就可以让你的东西

170
00:06:07,789 --> 00:06:09,349
更便携，以及一些应用程序，比如

171
00:06:09,349 --> 00:06:10,550
如果你知道你会 在手机上运行

172
00:06:10,550 --> 00:06:12,259
你只会知道

173
00:06:12,259 --> 00:06:15,500
执行续集灯 你可以用

174
00:06:15,500 --> 00:06:16,759
这种方式编程 但即使那样像

175
00:06:16,759 --> 00:06:19,039
Apple 或 Android 或为你提供一个

176
00:06:19,039 --> 00:06:21,289
数据库包装器或 API 来隐藏

177
00:06:21,289 --> 00:06:23,080
你实际使用续集精简版的

178
00:06:23,080 --> 00:06:26,330
事实 对，所以第一种

179
00:06:26,330 --> 00:06:27,949
用于 dat sesemann 的标准化 API 被

180
00:06:27,949 --> 00:06:31,099
称为 ODBC，这实际上

181
00:06:31,099 --> 00:06:33,319
并不是它不是第一个实现的出口 II，

182
00:06:33,319 --> 00:06:35,209
就像 Sybase

183
00:06:35,209 --> 00:06:37,880
在 1980 年代后期实际上尝试过的那样，他们

184
00:06:37,880 --> 00:06:39,219
得到了 与其他一些数据库

185
00:06:39,219 --> 00:06:40,909
供应商和一些

186
00:06:40,909 --> 00:06:43,099
应用程序编程框架一起，

187
00:06:43,099 --> 00:06:45,619
他们把这个 Sybase api 剥离了

188
00:06:45,619 --> 00:06:47,959
所有的侧面基础，如果其中包含 ik 逻辑，并

189
00:06:47,959 --> 00:06:49,729
试图将其作为一个称为 DB 库的标准 API 提出

190
00:06:49,729 --> 00:06:52,189
来，无论出于什么原因都可以使用

191
00:06:52,189 --> 00:06:53,679
它从未采用过 关闭

192
00:06:53,679 --> 00:06:56,240
Microsoft 然后与另一

193
00:06:56,240 --> 00:06:57,800
家名为 Simo 技术的公司联系在一起，

194
00:06:57,800 --> 00:07:00,379
然后他们在 1990 年代初期提出了

195
00:07:00,379 --> 00:07:02,869
这个称为 ODBC 的东西，

196
00:07:02,869 --> 00:07:03,349
如今

197
00:07:03,349 --> 00:07:06,020
几乎每个主要的数据库供应商实际上，

198
00:07:06,020 --> 00:07:07,639
无论您的关系还是非关系

199
00:07:07,639 --> 00:07:09,770
是有机会的，他们都会有

200
00:07:09,770 --> 00:07:11,899
一个 尽管 Hmong 敌人不支持续集，但像 MongoDB 这样的 BC 库已经赢了

201
00:07:11,899 --> 00:07:13,189


202
00:07:13,189 --> 00:07:16,099
，只是你给他们更长的时间

203
00:07:16,099 --> 00:07:18,409
来了解查询，并且你写

204
00:07:18,409 --> 00:07:20,389
妈妈是他们语法中的查询，但它

205
00:07:20,389 --> 00:07:25,789
仍然支持他们的 API，所以它的

206
00:07:25,789 --> 00:07:27,529
基本工作方式是 OTP 他们将

207
00:07:27,529 --> 00:07:28,819
遵循所谓的设备驱动程序

208
00:07:28,819 --> 00:07:32,569
模型，这个想法是在

209
00:07:32,569 --> 00:07:35,809
客户端的 ODBC 驱动程序

210
00:07:35,809 --> 00:07:37,789
是 供应商提供并且

211
00:07:37,789 --> 00:07:39,589
在幕后，他们将拥有

212
00:07:39,589 --> 00:07:41,719
您需要通过专有协议与数据库服务器进行通信的所有逻辑，

213
00:07:41,719 --> 00:07:43,219


214
00:07:43,219 --> 00:07:45,019
如果我

215
00:07:45,019 --> 00:07:46,699
在这里发送查询请求，这个请求

216
00:07:46,699 --> 00:07:49,129
将特定于我的数据库系统，

217
00:07:49,129 --> 00:07:51,469
然后当我得到 回到结果，

218
00:07:51,469 --> 00:07:53,899
现在取决于这个驱动程序，然后将它

219
00:07:53,899 --> 00:07:56,089
转换为 ODBC API 指定的格式，

220
00:07:56,089 --> 00:08:00,199
所以我们

221
00:08:00,199 --> 00:08:01,579
将在这个类中使用的说法是，我

222
00:08:01,579 --> 00:08:03,949
将在这里引用这部分，这

223
00:08:03,949 --> 00:08:05,300
是部分 我们关心的是

224
00:08:05,300 --> 00:08:07,819
有线协议，而且每个数据库

225
00:08:07,819 --> 00:08:08,749
系统都会做一些不同的事情，

226
00:08:08,749 --> 00:08:09,969


227
00:08:09,969 --> 00:08:12,259
除非你遵循你所知道的

228
00:08:12,259 --> 00:08:13,490
使用我的 Segel 和 Postgres 层复制的内容，

229
00:08:13,490 --> 00:08:15,349
这很常见，但这

230
00:08:15,349 --> 00:08:16,999
不会有这样的事情

231
00:08:16,999 --> 00:08:18,319
对 ODBC 一无所知，它只知道

232
00:08:18,319 --> 00:08:18,529


233
00:08:18,529 --> 00:08:20,269
这里有一些 Seco 查询，这是一个

234
00:08:20,269 --> 00:08:23,990
结果，现在 ODBC API 确实有

235
00:08:23,990 --> 00:08:26,179
额外的东西，或者它具有某些

236
00:08:26,179 --> 00:08:28,459
功能，并不是每个数据库系统

237
00:08:28,459 --> 00:08:30,079
都将成为一个 li 很少支持，但您

238
00:08:30,079 --> 00:08:31,849
基本上可以

239
00:08:31,849 --> 00:08:34,068
在驱动程序的客户端模拟它，

240
00:08:34,068 --> 00:08:35,539
例如，如果您的数据库系统不

241
00:08:35,539 --> 00:08:38,328
支持游标，那么游标就像我

242
00:08:38,328 --> 00:08:39,679
运行续集查询而不是

243
00:08:39,679 --> 00:08:41,299
在我可以得到时取回所有结果 一个

244
00:08:41,299 --> 00:08:43,159
句柄像迭代器一样指向该结果的游标句柄

245
00:08:43,159 --> 00:08:45,290
，我被称为 get next

246
00:08:45,290 --> 00:08:47,120
get next get next 它将

247
00:08:47,120 --> 00:08:48,529
通过网络发送一条消息以返回

248
00:08:48,529 --> 00:08:50,149
下一个查询，您会这样做，

249
00:08:50,149 --> 00:08:51,980
就像您的结果一样 巨大，您

250
00:08:51,980 --> 00:08:52,939
不想一次发送所有内容，

251
00:08:52,939 --> 00:08:53,930


252
00:08:53,930 --> 00:08:56,270
因此并非每个数据库系统都支持

253
00:08:56,270 --> 00:08:59,390
游标，因此您可以通过 DC 库伪造它，

254
00:08:59,390 --> 00:09:01,220
这样您仍然可以调用以

255
00:09:01,220 --> 00:09:02,450
查看您的应用程序，嘿

256
00:09:02,450 --> 00:09:04,460
，在他们的封面下给我一个游标” 将

257
00:09:04,460 --> 00:09:06,020
发送续集查询以取回

258
00:09:06,020 --> 00:09:08,300
所有结果，然后像迭代器 API 一样向您展示

259
00:09:08,300 --> 00:09:10,370
以遍历

260
00:09:10,370 --> 00:09:12,649
游标，这很好，如果您不支持 ODBC i 所需的

261
00:09:12,649 --> 00:09:14,290
一切，您可以隐藏所有复杂性

262
00:09:14,290 --> 00:09:16,640


263
00:09:16,640 --> 00:09:20,260
驱动程序本身没问题，

264
00:09:20,260 --> 00:09:23,209
所以另一件需要

265
00:09:23,209 --> 00:09:26,120
理解的重要事情是 ODBC

266
00:09:26,120 --> 00:09:29,240
标准指定了您知道的

267
00:09:29,240 --> 00:09:32,600
固定内容指定了

268
00:09:32,600 --> 00:09:34,790
您将要获得的数据类型，当您说

269
00:09:34,790 --> 00:09:35,930
给我一个整数时

270
00:09:35,930 --> 00:09:38,120
从此结果集中知道这一点，

271
00:09:38,120 --> 00:09:39,830
因此驱动程序需要确保

272
00:09:39,830 --> 00:09:42,470
无论 ODBC 驱动程序 API

273
00:09:42,470 --> 00:09:44,810
指定为一种数据类型，它都必须

274
00:09:44,810 --> 00:09:46,760
在您的应用程序中将其提供给您

275
00:09:46,760 --> 00:09:48,290
，这样您就不会出现意外

276
00:09:48,290 --> 00:09:50,060
结果，它使它更便携

277
00:09:50,060 --> 00:09:52,490
，例如，如果我们出于任何原因将每个整数存储为

278
00:09:52,490 --> 00:09:54,920
64 位，然后

279
00:09:54,920 --> 00:09:57,020
ODBC API 说

280
00:09:57,020 --> 00:09:59,450
当我再次从服务器返回 64 能量时给我一个 32 位整数

281
00:09:59,450 --> 00:10:01,730
，以便将其转换为 32

282
00:10:01,730 --> 00:10:03,740
位，因为这就是 API 指定的内容，

283
00:10:03,740 --> 00:10:04,610


284
00:10:04,610 --> 00:10:07,630
所以这一切都试图通过这个客户端或驱动程序模型来隐藏

285
00:10:07,630 --> 00:10:10,610
每个数据库系统的细节或细微差别，

286
00:10:10,610 --> 00:10:12,920


287
00:10:12,920 --> 00:10:17,050


288
00:10:17,470 --> 00:10:20,510
所以另一个更常见的

289
00:10:20,510 --> 00:10:23,240
也是 JDBC 和 考虑

290
00:10:23,240 --> 00:10:25,279
这个的方式就像 ODBC 它不再特定于

291
00:10:25,279 --> 00:10:27,200
Windows 但

292
00:10:27,200 --> 00:10:28,820
它有点来自环境，所以它

293
00:10:28,820 --> 00:10:31,580
是为 C 或 C++ 应用程序

294
00:10:31,580 --> 00:10:33,709
设计的 JDBC 是为基于 Java 的

295
00:10:33,709 --> 00:10:35,000
应用程序设计的，用于设计

296
00:10:35,000 --> 00:10:38,720
运行的应用程序 JVM 所以这是由

297
00:10:38,720 --> 00:10:42,740
sun 在 1997 年开发的，当时他们

298
00:10:42,740 --> 00:10:45,620
发布了 Java 语言的 Java Runtime 几年

299
00:10:45,620 --> 00:10:47,600
后

300
00:10:47,600 --> 00:10:49,010
，他们再次认识到他们希望

301
00:10:49,010 --> 00:10:51,079
Java 应用程序在企业中运行，

302
00:10:51,079 --> 00:10:53,329
企业

303
00:10:53,329 --> 00:10:54,980
应用程序需要谈论这些事情 到关系

304
00:10:54,980 --> 00:10:57,310
数据库或续集数据库，所以你

305
00:10:57,310 --> 00:10:59,570
JDBC 是他们试图标准化

306
00:10:59,570 --> 00:11:02,450
API 的尝试，就像我说的，

307
00:11:02,450 --> 00:11:04,880
就像你认为 C 是 C 的，而 JDBC

308
00:11:04,880 --> 00:11:08,000
显然是 Java 的，所以

309
00:11:08,000 --> 00:11:09,920
我们略有不同，尽管在

310
00:11:09,920 --> 00:11:13,280
JDBC 是因为他们运行的是

311
00:11:13,280 --> 00:11:17,660
Java 运行时，所以他们并不总是

312
00:11:17,660 --> 00:11:21,770
会有用 Java 编写的驱动程序，它

313
00:11:21,770 --> 00:11:23,720
现在更常见，但在当时

314
00:11:23,720 --> 00:11:26,360
不太适合 ODBC 是的 如果你

315
00:11:26,360 --> 00:11:27,380
发布了你的驱动程序，

316
00:11:27,380 --> 00:11:29,390
如果你发现它是

317
00:11:29,390 --> 00:11:31,490
用 C 语言编写的，这将是通用的，

318
00:11:31,490 --> 00:11:33,640
而不是一种

319
00:11:33,640 --> 00:11:37,520
在有

320
00:11:37,520 --> 00:11:39,770
足够多的 Java 驱动程序之前桥接人们能够使用 JDBC 的方式，那么他们

321
00:11:39,770 --> 00:11:41,060
有一个 您可以使用多种不同级别或

322
00:11:41,060 --> 00:11:43,340
连接方法

323
00:11:43,340 --> 00:11:45,410
与数据库系统进行通信，

324
00:11:45,410 --> 00:11:47,180
因此第一个与我所说的完全一样

325
00:11:47,180 --> 00:11:49,880


326
00:11:49,880 --> 00:11:51,290


327
00:11:51,290 --> 00:11:53,890


328
00:11:53,890 --> 00:11:55,910


329
00:11:55,910 --> 00:11:58,490
它将 JDBC 命令转换为 ODBC

330
00:11:58,490 --> 00:12:01,040
命令，然后 ODBC 然后

331
00:12:01,040 --> 00:12:02,390
通过其

332
00:12:02,390 --> 00:12:04,640
专有的有线协议与数据库系统进行通信，因此

333
00:12:04,640 --> 00:12:06,500
实际上不再支持它，

334
00:12:06,500 --> 00:12:09,500
就像我认为 JDK 1.8 一样，但这

335
00:12:09,500 --> 00:12:10,640
实际上是设置的麻烦

336
00:12:10,640 --> 00:12:12,020
当我们在这里进行一些测试时，我不得不这样做四次十次

337
00:12:12,020 --> 00:12:14,720
这是一场噩梦

338
00:12:14,720 --> 00:12:16,730
它真的很挑剔但同样

339
00:12:16,730 --> 00:12:19,970
这是一个权宜之计的解决方案，以防 GBC

340
00:12:19,970 --> 00:12:21,650
没有你想要的 对于

341
00:12:21,650 --> 00:12:24,380
您的特定数据库系统，下一个

342
00:12:24,380 --> 00:12:27,140
方法是让 JDBC 调用

343
00:12:27,140 --> 00:12:31,730


344
00:12:31,730 --> 00:12:34,040
再次调用数据库系统的专有本机 API，因此 Sequel

345
00:12:34,040 --> 00:12:34,970
Lite 将是考虑这一点的最佳方式，

346
00:12:34,970 --> 00:12:35,960
因为 Seco 点亮了

347
00:12:35,960 --> 00:12:37,430
更好的数据库系统，所以它会

348
00:12:37,430 --> 00:12:40,010
在与应用程序相同的进程中运行，

349
00:12:40,010 --> 00:12:43,430
这样您就可以让 JDBC

350
00:12:43,430 --> 00:12:46,700
驱动程序通过 J 和 I 调用 C

351
00:12:46,700 --> 00:12:48,680
命令来执行查询或

352
00:12:48,680 --> 00:12:51,710
打开数据库系统上的游标或表，

353
00:12:51,710 --> 00:12:53,930
但我认为这行不通，如果

354
00:12:53,930 --> 00:12:55,339
你 重新通过网络这

355
00:12:55,339 --> 00:12:57,920
仅适用

356
00:12:57,920 --> 00:13:00,190
于在同一进程中运行的位嵌入式嵌入式数据库

357
00:13:00,190 --> 00:13:03,860
下一个方法是让 JDBC

358
00:13:03,860 --> 00:13:05,600
驱动程序与其他一些

359
00:13:05,600 --> 00:13:08,420
中间件系统进行通信，然后该系统知道如何

360
00:13:08,420 --> 00:13:11,030
说出

361
00:13:11,030 --> 00:13:12,680
数据库系统，所以它有点

362
00:13:12,680 --> 00:13:14,300
像第一个，但这里的想法是

363
00:13:14,300 --> 00:13:17,959
来自 JDBC 的命令

364
00:13:17,959 --> 00:13:21,800
不应该

365
00:13:21,800 --> 00:13:24,199
对 JDBC 通用，但是当它们登陆时

366
00:13:24,199 --> 00:13:25,339
过时的

367
00:13:25,339 --> 00:13:27,259
助手必须提供的中间件然后

368
00:13:27,259 --> 00:13:28,369
知道如何将其转换并转换

369
00:13:28,369 --> 00:13:30,439
为您期望的有线协议，

370
00:13:30,439 --> 00:13:32,899
而这

371
00:13:32,899 --> 00:13:37,610
有点像 JDBC 正在调用 ODBC 命令，

372
00:13:37,610 --> 00:13:39,290
最后一个我认为是最好的

373
00:13:39,290 --> 00:13:43,040
一个是数据库所在的位置，

374
00:13:43,040 --> 00:13:45,559
以便 JDBC 实现本身可以

375
00:13:45,559 --> 00:13:48,170
调用或发送

376
00:13:48,170 --> 00:13:49,369
有线协议或数据库系统所需的数据包，

377
00:13:49,369 --> 00:13:52,660
所以这在早期并不是那么常见

378
00:13:52,660 --> 00:13:55,069
，但现在更

379
00:13:55,069 --> 00:13:57,739
常见了 您可以下载纯粹用 Java 编写的

380
00:13:57,739 --> 00:14:00,529
Postgres 实现或 Postgres JDBC

381
00:14:00,529 --> 00:14:02,720
驱动程序，您

382
00:14:02,720 --> 00:14:04,879
无需担心任何

383
00:14:04,879 --> 00:14:06,920
C 内容，这将再次运行最快，

384
00:14:06,920 --> 00:14:08,660
因为您只需通过网络本地使用 Java

385
00:14:08,660 --> 00:14:10,220
即可获取数据包 并

386
00:14:10,220 --> 00:14:14,679
让一切恢复正常 所以这个

387
00:14:14,679 --> 00:14:18,439
这个我认为实际上并不是

388
00:14:18,439 --> 00:14:22,519
你在其他语言中看到的这个，

389
00:14:22,519 --> 00:14:25,489
比如如果你想

390
00:14:25,489 --> 00:14:27,499
拥有一些像 rust 或 go 这样的晦涩编程

391
00:14:27,499 --> 00:14:30,740
安全或晦涩，但就像

392
00:14:30,740 --> 00:14:32,420
在早期一样，没有很多

393
00:14:32,420 --> 00:14:35,629
驱动程序是为不同的数据库编写的，

394
00:14:35,629 --> 00:14:37,639
并且会生锈，无论

395
00:14:37,639 --> 00:14:39,439
您想使用什么语言，因此您可以采取

396
00:14:39,439 --> 00:14:41,540
权宜之计的解决方案是，这东西

397
00:14:41,540 --> 00:14:43,279
会像 ODBC 一样环绕您

398
00:14:43,279 --> 00:14:46,699
拥有 一个围绕 ODBC 驱动程序的 go 包装器

399
00:14:46,699 --> 00:14:48,949
，它是用 C 编写的，但这

400
00:14:48,949 --> 00:14:51,290
又意味着你必须退出

401
00:14:51,290 --> 00:14:53,929
可能的运行时进入 C 程序来

402
00:14:53,929 --> 00:14:55,670
发送这些命令，而如果你有

403
00:14:55,670 --> 00:14:58,129
一个本地 go 实现是的，那是

404
00:14:58,129 --> 00:14:59,600
我的方式更快，因为 它更少

405
00:14:59,600 --> 00:15:01,129
复制数据包或更少复制我的缓冲区，所以

406
00:15:01,129 --> 00:15:03,290
这总是更好的

407
00:15:03,290 --> 00:15:07,819
方法，因为我说过所有

408
00:15:07,819 --> 00:15:08,949
数据库系统都将实现

409
00:15:08,949 --> 00:15:11,720
他们自己的专有线路协议，

410
00:15:11,720 --> 00:15:14,240
据我所知，这些是我不知道的 '不

411
00:15:14,240 --> 00:15:15,199
知道任何其他系统不这样做

412
00:15:15,199 --> 00:15:18,019
一切都将通过 tcp/ip 我

413
00:15:18,019 --> 00:15:19,730
不知道任何

414
00:15:19,730 --> 00:15:22,999
通过 UDP 的数据库系统，如果你想支持事务，我们很难做到，

415
00:15:22,999 --> 00:15:24,139
因为你

416
00:15:24,139 --> 00:15:25,009
不这样做' 不知道是谁 那么你的包装工

417
00:15:25,009 --> 00:15:26,480
实际上会出现，你需要

418
00:15:26,480 --> 00:15:28,759
发回 aknowledge mints 所以出于这个

419
00:15:28,759 --> 00:15:30,769
原因，每个人现在都在通过 tcp/ip

420
00:15:30,769 --> 00:15:33,069
上面，他们可以在后面有额外的

421
00:15:33,069 --> 00:15:35,070
确认消息，

422
00:15:35,070 --> 00:15:36,389
但你知道说看看你收到

423
00:15:36,389 --> 00:15:38,040
这个数据包了吗是的我 像在应用程序级别一样得到这个数据包

424
00:15:38,040 --> 00:15:39,660
，但当然

425
00:15:39,660 --> 00:15:41,339
TCP 也会在封面上为你做，

426
00:15:41,339 --> 00:15:44,519
所以

427
00:15:44,519 --> 00:15:46,290
客户端与我们的

428
00:15:46,290 --> 00:15:48,180
数据库服务器交互的典型方式是他们将

429
00:15:48,180 --> 00:15:49,740
连接到他们的数据库系统 将

430
00:15:49,740 --> 00:15:51,509
经历某种身份验证

431
00:15:51,509 --> 00:15:53,459
过程，例如用户名密码

432
00:15:53,459 --> 00:15:56,519
如果大多数

433
00:15:56,519 --> 00:15:58,589
系统现在默认情况下也支持 SSL，那么 Kerberos 可以使用类似的方法，因此

434
00:15:58,589 --> 00:16:00,300
您通过该过程对通道进行加密，

435
00:16:00,300 --> 00:16:03,660
然后发送

436
00:16:03,660 --> 00:16:05,730
数据库已执行的查询

437
00:16:05,730 --> 00:16:08,639
查询对它

438
00:16:08,639 --> 00:16:09,959
通过有线协议将其发送回

439
00:16:09,959 --> 00:16:11,190
客户端的结果进行消毒，然后客户端可以将

440
00:16:11,190 --> 00:16:15,779
其交给应用程序代码，因此

441
00:16:15,779 --> 00:16:17,040
我们将专注于toda  y 和

442
00:16:17,040 --> 00:16:18,720
你们阅读的论文关注的是

443
00:16:18,720 --> 00:16:20,430
这里的这个问题，你如何真正地

444
00:16:20,430 --> 00:16:22,170
对数据进行消毒并摆脱它，

445
00:16:22,170 --> 00:16:23,399
因为这实际上

446
00:16:23,399 --> 00:16:25,680
是优化的机会

447
00:16:25,680 --> 00:16:27,420
实际上可用的地方，或者我们

448
00:16:27,420 --> 00:16:29,610
可以改进的地方没有 我们

449
00:16:29,610 --> 00:16:31,920
可以为此做很多事情

450
00:16:31,920 --> 00:16:33,810
没有太多我们可以为此做很多优化

451
00:16:33,810 --> 00:16:35,910
，因为大多数续集查询

452
00:16:35,910 --> 00:16:37,560
都会很短，而不是我们

453
00:16:37,560 --> 00:16:39,779
通过您发送的字符串然后可以说我将

454
00:16:39,779 --> 00:16:41,339
这些作为准备好的语句或存储

455
00:16:41,339 --> 00:16:42,750
过程运行，但这只是 真正

456
00:16:42,750 --> 00:16:44,670
减少消息的大小 大多数

457
00:16:44,670 --> 00:16:46,860
查询都没有那么大

458
00:16:46,860 --> 00:16:49,350
我在野外见过或从人们那里听到一些应用程序

459
00:16:49,350 --> 00:16:51,779
，其中像续集

460
00:16:51,779 --> 00:16:54,540
查询可能像 10 兆字节，你看到

461
00:16:54,540 --> 00:16:57,660
的就像大公司一样，

462
00:16:57,660 --> 00:16:58,860
他们有这样的 吃掉内部

463
00:16:58,860 --> 00:17:01,170
仪表板来做报告，然后你

464
00:17:01,170 --> 00:17:02,970
点击一堆选项，就像你

465
00:17:02,970 --> 00:17:04,679
知道的一样，只需从邮政编码中获取所有人

466
00:17:04,679 --> 00:17:06,480
或一些你知道某个地理区域的人 al

467
00:17:06,480 --> 00:17:09,390
region 然后你你可以

468
00:17:09,390 --> 00:17:10,679
点击所有你想要的

469
00:17:10,679 --> 00:17:12,720
查询选项，然后点击 go 然后

470
00:17:12,720 --> 00:17:14,220
将你在仪表板上点击的任何内容

471
00:17:14,220 --> 00:17:15,659
转换为后续查询，

472
00:17:15,659 --> 00:17:17,189
有时你可以在子句中使用这些非常长

473
00:17:17,189 --> 00:17:20,309
的子句，例如 where zip code in

474
00:17:20,309 --> 00:17:21,569
然后你知道每个邮政编码的列表

475
00:17:21,569 --> 00:17:23,490
，在这种情况下，

476
00:17:23,490 --> 00:17:25,740
它可以变得非常大的续集，但

477
00:17:25,740 --> 00:17:27,119
你真正可以做的唯一优化

478
00:17:27,119 --> 00:17:29,760
就是你用

479
00:17:29,760 --> 00:17:31,320
snappy或gzip之类的任何你想使用的东西来压缩它，

480
00:17:31,320 --> 00:17:32,940
所以

481
00:17:32,940 --> 00:17:34,650
我们在数据库

482
00:17:34,650 --> 00:17:37,650
系统中实际上没有任何技术可以使这个过程更快，所以我们

483
00:17:37,650 --> 00:17:41,850
将在这里专注于这个，所以

484
00:17:41,850 --> 00:17:45,150
我说所有主要的 Davis 系统都实现了

485
00:17:45,150 --> 00:17:48,670
他们自己的专有瀑布协议

486
00:17:48,670 --> 00:18:02,620
，这并不是一个完全正确的问题，好

487
00:18:02,620 --> 00:18:05,730
问题所以 问题是是否

488
00:18:05,730 --> 00:18:07,780
有任何数据库系统

489
00:18:07,780 --> 00:18:09,160
可以让客户端实际上有点

490
00:18:09,160 --> 00:18:13,150
智能，也许我的意思是

491
00:18:13,150 --> 00:18:15,100


492
00:18:15,100 --> 00:18:17,250
在将其发送给您之前进行压缩或进行一些查询重写我

493
00:18:17,250 --> 00:18:19,210
还以为你知道她让

494
00:18:19,210 --> 00:18:23,160
我做客户端查询缓存

495
00:18:24,390 --> 00:18:28,200
也不是出于几个

496
00:18:28,200 --> 00:18:30,670
原因所以你给出的例子就像

497
00:18:30,670 --> 00:18:32,770
我可以做查询重写我不知道是否

498
00:18:32,770 --> 00:18:34,390
有人在客户端驱动程序中这样做，

499
00:18:34,390 --> 00:18:37,450
因为 就像转换你知道一个等于

500
00:18:37,450 --> 00:18:39,850
想要你知道两个等于一加一

501
00:18:39,850 --> 00:18:41,760
我可以把它转换成真的

502
00:18:41,760 --> 00:18:44,020
因为你基本上需要

503
00:18:44,020 --> 00:18:45,700
实现那个逻辑来解析续集

504
00:18:45,700 --> 00:18:47,740
语句理解

505
00:18:47,740 --> 00:18:49,390
where 子句在客户端上实际做什么的语义

506
00:18:49,390 --> 00:18:52,720
一边那么现在你还

507
00:18:52,720 --> 00:18:54,280
需要如果你支持一堆

508
00:18:54,280 --> 00:18:56,260
不同的编程语言并且

509
00:18:56,260 --> 00:18:58,030
你正在使用这些东西的本地驱动程序

510
00:18:58,030 --> 00:18:59,230
现在你必须

511
00:18:59,230 --> 00:19:01,510
用每种语言重写所有这些，因为这个

512
00:19:01,510 --> 00:19:03,040
原因没有人我不认为 任何人都

513
00:19:03,040 --> 00:19:06,370
这样做 我那里有一个

514
00:19:06,370 --> 00:19:09,040
名为 Foundation DB 的系统，它是一个

515
00:19:09,040 --> 00:19:10,660
分布式键值存储，Apple

516
00:19:10,660 --> 00:19:12,970
购买了它现在是开源的雪花

517
00:19:12,970 --> 00:19:15,250
在内部使用它作为元数据，但

518
00:19:15,250 --> 00:19:17,220
他们只将它用作 关键价值存储

519
00:19:17,220 --> 00:19:19,570
在 Apple 购买 Foundation BB BB 之前以 8 英镑的价格

520
00:19:19,570 --> 00:19:21,370
出售时，他们会

521
00:19:21,370 --> 00:19:23,680
做的是他们添加了续集眩光，

522
00:19:23,680 --> 00:19:25,390
所有要做的就是在客户端中他们

523
00:19:25,390 --> 00:19:27,160
会将您的续集声明转换为

524
00:19:27,160 --> 00:19:29,980
单独的 get get 查询 get

525
00:19:29,980 --> 00:19:32,170
命令发送 键值存储，所以

526
00:19:32,170 --> 00:19:33,700
这是我能

527
00:19:33,700 --> 00:19:35,200
想到的唯一提示 他们做这种

528
00:19:35,200 --> 00:19:37,990
事情 其他事情，例如缓存查询

529
00:19:37,990 --> 00:19:41,350
结果 如果您不知道

530
00:19:41,350 --> 00:19:42,490
客户端数据库服务器中的内容，

531
00:19:42,490 --> 00:19:44,200
您怎么知道 你有

532
00:19:44,200 --> 00:19:46,450
最新版本所以你所以对于这条路线

533
00:19:46,450 --> 00:19:47,770
，每个人总是去

534
00:19:47,770 --> 00:19:52,780
那里的网络我已经考虑过

535
00:19:52,780 --> 00:19:53,290
这个

536
00:19:53,290 --> 00:19:55,450
我们还没有追求它但就像

537
00:19:55,450 --> 00:19:57,370
我在滑铁卢做了一些研究

538
00:19:57,370 --> 00:20:02,740
一样你可以提供

539
00:20:02,740 --> 00:20:04,810
提示 就像嘿，我正在向您发送

540
00:20:04,810 --> 00:20:06,730
此查询，但顺便说一下，我

541
00:20:06,730 --> 00:20:08,080
实际上很快也会向您发送这些其他查询

542
00:20:08,080 --> 00:20:10,810
，但我认为不会

543
00:20:10,810 --> 00:20:12,490
有任何商业化，客户端驱动

544
00:20:12,490 --> 00:20:14,050
程序通常很漂亮 ain-dead

545
00:20:14,050 --> 00:20:15,430
就像给我这个查询这里的结果

546
00:20:15,430 --> 00:20:26,580
是什么是现有的协议

547
00:20:27,210 --> 00:20:29,860
然后我使用

548
00:20:29,860 --> 00:20:31,450
现有的协议是什么意思

549
00:20:31,450 --> 00:20:49,750
就像我想要像 tcp/ip 所以我想我们是

550
00:20:49,750 --> 00:20:52,270
你说的 当您说现有

551
00:20:52,270 --> 00:20:54,460
协议时，您是说它像在堆栈中的

552
00:20:54,460 --> 00:20:57,370
较低级别，例如在 tcp/ip

553
00:20:57,370 --> 00:20:59,290
级别，还是像在

554
00:20:59,290 --> 00:21:03,670
应用程序级别那样 - 使用

555
00:21:03,670 --> 00:21:11,530
现有的 tcpip 协议

556
00:21:11,530 --> 00:21:13,210
但那是下面的一层 我们在上面

557
00:21:13,210 --> 00:21:17,320
，我们在数据服务器中 所以

558
00:21:17,320 --> 00:21:20,410
现有协议中有 221 个 所以大约有 8 个

559
00:21:20,410 --> 00:21:23,160
我的问题是什么是现有协议

560
00:21:23,160 --> 00:21:25,210
这是一个主要问题 因为它是

561
00:21:25,210 --> 00:21:31,300
下一张幻灯片 好吧 所以正如我

562
00:21:31,300 --> 00:21:33,400
所说的 就像所有主要数据库一样

563
00:21:33,400 --> 00:21:35,440
像 Postgres 这样的供应商我的续集

564
00:21:35,440 --> 00:21:37,690
其他三大 Oracle db2 续集服务器

565
00:21:37,690 --> 00:21:39,670
几乎每个人都

566
00:21:39,670 --> 00:21:42,940
从头开始实现他们自己的连线协议，但

567
00:21:42,940 --> 00:21:46,270
我认为你要去的是

568
00:21:46,270 --> 00:21:48,250
大多数较新的系统但是不这样做

569
00:21:48,250 --> 00:21:49,540
，他们需要 小鬼 在我的续集中

570
00:21:49,540 --> 00:21:52,030
对现有的一个特别是 Postgres 感到满意

571
00:21:52,030 --> 00:21:55,240
，

572
00:21:55,240 --> 00:21:57,130
这样做的好处是，

573
00:21:57,130 --> 00:21:58,630
我们在这里构建的系统中做同样的事情

574
00:21:58,630 --> 00:22:00,520
是现在我不必担心

575
00:22:00,520 --> 00:22:01,900
支持一堆不同的

576
00:22:01,900 --> 00:22:03,340
编程语言 对于适用

577
00:22:03,340 --> 00:22:05,600
于 JDBC 和 ODBC 的驱动程序，

578
00:22:05,600 --> 00:22:07,880
我想如果我说的是 post s wire

579
00:22:07,880 --> 00:22:10,160
协议，那么任何

580
00:22:10,160 --> 00:22:12,799
伴随着你知道生锈的 Postgres 驱动程序

581
00:22:12,799 --> 00:22:15,289
的人都可以使用第一个

582
00:22:15,289 --> 00:22:16,309
幽灵驱动程序并在我的

583
00:22:16,309 --> 00:22:18,830
数据库系统中进行通信，现在这些是

584
00:22:18,830 --> 00:22:20,360
不会是最好的协议，我们可以

585
00:22:20,360 --> 00:22:21,590
离线讨论我们

586
00:22:21,590 --> 00:22:24,710
在使用 Postgres 时遇到的麻烦，但是如果您

587
00:22:24,710 --> 00:22:26,090
考虑一下，如果您的数据库启动

588
00:22:26,090 --> 00:22:27,440
或您的类似 AWS 之类的研究项目

589
00:22:27,440 --> 00:22:30,350
，您是否愿意花钱 您花

590
00:22:30,350 --> 00:22:33,679
时间为每一种编程语言编写客户端驱动

591
00:22:33,679 --> 00:22:34,580
程序，以便

592
00:22:34,580 --> 00:22:36,679
人们使用您的数据库，或者可以使用

593
00:22:36,679 --> 00:22:37,760
已经完成的工作

594
00:22:37,760 --> 00:22:39,710
和大型生态系统，并且很高兴

595
00:22:39,710 --> 00:22:41,419
您知道使用什么 已经存在

596
00:22:41,419 --> 00:22:43,909
所以这就是为什么这实际上非常非常

597
00:22:43,909 --> 00:22:46,460
普遍所以但我会说虽然

598
00:22:46,460 --> 00:22:47,690
有时你会在

599
00:22:47,690 --> 00:22:50,210
文档中看到哦我们是 Postgres

600
00:22:50,210 --> 00:22:52,309
兼容你在

601
00:22:52,309 --> 00:22:53,870
这些不同的数据库系统或

602
00:22:53,870 --> 00:22:55,130
Postgres 兼容或我的续集

603
00:22:55,130 --> 00:22:57,530
兼容的应用程序中看到 但仅仅因为它们使用

604
00:22:57,530 --> 00:22:58,730
有线协议，并不意味着

605
00:22:58,730 --> 00:23:00,799
实际上真正兼容，但它们

606
00:23:00,799 --> 00:23:02,360
并不总是完全可以

607
00:23:02,360 --> 00:23:04,159
替代，因为还有很多

608
00:23:04,159 --> 00:23:07,460
其他特定的东西，

609
00:23:07,460 --> 00:23:09,590
你知道我的续集的 Postgres，你

610
00:23:09,590 --> 00:23:11,179
可能实际上并没有在您的

611
00:23:11,179 --> 00:23:13,480
服务器或新系统中进行模拟，

612
00:23:13,480 --> 00:23:15,590
因此它不会工作您

613
00:23:15,590 --> 00:23:18,350
知道您使用 GBC ODBC 的应用程序代码

614
00:23:18,350 --> 00:23:20,600
可能会开始

615
00:23:20,600 --> 00:23:22,010
以您的服务器不支持的方言发送续集查询

616
00:23:22,010 --> 00:23:24,039
，因此它不会正常

617
00:23:24,039 --> 00:23:26,330
工作 这将通过遵循他们的协议为您提供这种方式，

618
00:23:26,330 --> 00:23:28,760
您将

619
00:23:28,760 --> 00:23:30,200
获得从客户

620
00:23:30,200 --> 00:23:31,730
端到服务器的正确传输，但随后出现此

621
00:23:31,730 --> 00:23:34,039
查询，现在您要做什么 做

622
00:23:34,039 --> 00:23:35,720
对了，其他时候不会完全一样

623
00:23:35,720 --> 00:23:37,820
——

624
00:23:37,820 --> 00:23:39,409
如果你不支持与

625
00:23:39,409 --> 00:23:40,970
后期定制续集相同的目录结构，它们将是查询，

626
00:23:40,970 --> 00:23:43,309
其中很多像可视化

627
00:23:43,309 --> 00:23:44,450
工具，当它们打开时你做的第一件事

628
00:23:44,450 --> 00:23:46,159
是 去看看

629
00:23:46,159 --> 00:23:47,480
目录坐下来弄清楚

630
00:23:47,480 --> 00:23:48,890
你有什么表你有什么共享但你

631
00:23:48,890 --> 00:23:51,530
不会说如果你没有

632
00:23:51,530 --> 00:23:54,049
像帖子那样格式化我的

633
00:23:54,049 --> 00:23:56,120
续集然后那会崩溃然后

634
00:23:56,120 --> 00:23:57,710
还有其他事情 就像这些

635
00:23:57,710 --> 00:24:00,049
工具可以在

636
00:24:00,049 --> 00:24:03,289
物理层面上进入数据库服务器，就像查看

637
00:24:03,289 --> 00:24:04,820
磁盘上的文件一样，看起来有很多

638
00:24:04,820 --> 00:24:06,919
扩展和工具或 Postgres

639
00:24:06,919 --> 00:24:09,320
可以操作数据库的实际文件，

640
00:24:09,320 --> 00:24:10,580
而实际上不必

641
00:24:10,580 --> 00:24:12,890
通过 数据库系统本身

642
00:24:12,890 --> 00:24:14,000
不 不 这会起作用，因为

643
00:24:14,000 --> 00:24:15,200
在覆盖范围内，您的系统

644
00:24:15,200 --> 00:24:16,680
将完全不同

645
00:24:16,680 --> 00:24:22,740
是的 驱动程序，尤其是这

646
00:24:22,740 --> 00:24:26,430
就像将一串续集写入某些

647
00:24:26,430 --> 00:24:28,200
功能一样 就像我看到的那样，

648
00:24:28,200 --> 00:24:30,570
通过网络将其写入，

649
00:24:30,570 --> 00:24:31,980
然后以某种形式返回一些结果

650
00:24:31,980 --> 00:24:34,710
，所以这个问题是

651
00:24:34,710 --> 00:24:36,030
这些驱动程序实际上

652
00:24:36,030 --> 00:24:37,500


653
00:24:37,500 --> 00:24:39,750
是什么样的

654
00:24:39,750 --> 00:24:41,430
为我运行这个然后它被

655
00:24:41,430 --> 00:24:43,230
转换成数据包发送

656
00:24:43,230 --> 00:24:44,940
到戴维斯系统你得到一个结果，

657
00:24:44,940 --> 00:24:46,740
你以最简单的形式返回一些二进制形式的数据

658
00:24:46,740 --> 00:24:48,990
是的，但他开始

659
00:24:48,990 --> 00:24:51,420
像准备好的语句或

660
00:24:51,420 --> 00:24:54,420
游标一样 就像你可以指定像这里是

661
00:24:54,420 --> 00:24:55,920
我想使用的查询模板，

662
00:24:55,920 --> 00:24:57,840
然后第二个中的第一个值是

663
00:24:57,840 --> 00:25:00,000
一个双倍，就像 API

664
00:25:00,000 --> 00:25:04,110
实际上有点大，所有这些

665
00:25:04,110 --> 00:25:06,180
你都不知道只

666
00:25:06,180 --> 00:25:07,590
通过一个续集字符串传递一切 是通过 API

667
00:25:07,590 --> 00:25:09,630
以编程方式构造查询的方法，

668
00:25:09,630 --> 00:25:11,220
这不仅仅是嘿

669
00:25:11,220 --> 00:25:13,280
这里是续集字符串，然后

670
00:25:13,280 --> 00:25:16,170
API 指定的再次说明

671
00:25:16,170 --> 00:25:17,250
您知道何时返回结果并且您调用

672
00:25:17,250 --> 00:25:21,900
下一行您知道何时您知道 你

673
00:25:21,900 --> 00:25:23,670
知道这个当前行给

674
00:25:23,670 --> 00:25:25,860
我第三个元组或给我第三个

675
00:25:25,860 --> 00:25:28,500
字段作为整数它需要

676
00:25:28,500 --> 00:25:29,790
知道我会拿回三分之一

677
00:25:29,790 --> 00:25:31,410
你 Pittenger 而不是你

678
00:25:31,410 --> 00:25:33,060
的你的戴维斯在内部管理的其他

679
00:25:33,060 --> 00:25:35,550
东西 Sequel Light 存储

680
00:25:35,550 --> 00:25:37,050
所有 varchars 以满足封面，

681
00:25:37,050 --> 00:25:38,790
并且只有当它暴露

682
00:25:38,790 --> 00:25:39,780
在数据库系统之外时，它才会被

683
00:25:39,780 --> 00:25:41,940
转换为正确的二进制形式，

684
00:25:41,940 --> 00:25:46,500
因此驱动程序必须处理是的

685
00:25:46,500 --> 00:25:57,630
前排是的续集或续集服务器肯定没问题，

686
00:25:57,630 --> 00:25:58,290
就是这样 这就是

687
00:25:58,290 --> 00:26:00,950
实现是

688
00:26:03,830 --> 00:26:05,330
什么不同的客户端

689
00:26:05,330 --> 00:26:19,640
缓存和服务器端缓存问题

690
00:26:19,640 --> 00:26:21,700
是我对

691
00:26:21,700 --> 00:26:23,720
客户端缓存与服务器端

692
00:26:23,720 --> 00:26:26,269
缓存服务器端查询结果缓存做了评论

693
00:26:26,269 --> 00:26:30,470
将是 II 发送了一个续集查询它做了

694
00:26:30,470 --> 00:26:33,110
一些 一些复杂的计算，我将

695
00:26:33,110 --> 00:26:34,760
结果发回给客户，但后来我

696
00:26:34,760 --> 00:26:36,500
也记得我实际上是

697
00:26:36,500 --> 00:26:37,730
用结果查询增值税续集，

698
00:26:37,730 --> 00:26:39,289
所以现在有人来执行

699
00:26:39,289 --> 00:26:40,639
sam 续集查询我不必

700
00:26:40,639 --> 00:26:41,870
重新计算它我只是得到相同的

701
00:26:41,870 --> 00:26:44,929
结果所以另一种选择可能是

702
00:26:44,929 --> 00:26:47,029
客户端可以这样做所以客户端

703
00:26:47,029 --> 00:26:49,760
说我退出了几秒钟前你知道的相同的续集查询

704
00:26:49,760 --> 00:26:51,620
这里的结果

705
00:26:51,620 --> 00:26:54,380
只是重用 pom 是，如果您

706
00:26:54,380 --> 00:26:56,750
关心在客户端使数据保持新鲜和

707
00:26:56,750 --> 00:26:59,029
最新，我不

708
00:26:59,029 --> 00:27:00,230
知道是否有其他人进来并

709
00:27:00,230 --> 00:27:02,299
修改了表并因此

710
00:27:02,299 --> 00:27:05,510
使我的缓存结果无效，所以您会

711
00:27:05,510 --> 00:27:07,070
必须考虑你如何实际

712
00:27:07,070 --> 00:27:08,750
实现这个你可以说

713
00:27:08,750 --> 00:27:11,389
就像客户端可以去数据库

714
00:27:11,389 --> 00:27:14,419
服务器说嘿有这个状态

715
00:27:14,419 --> 00:27:16,490
这个缓存结果是否

716
00:27:16,490 --> 00:27:17,750
无效是或否

717
00:27:17,750 --> 00:27:20,210
然后如果是那么你反应安全如果

718
00:27:20,210 --> 00:27:21,769
不是 那么你只需重复使用你所做的

719
00:27:21,769 --> 00:27:23,299
我认为实际上没有人这样做，

720
00:27:23,299 --> 00:27:25,370
因为它是一种 1 倍的

721
00:27:25,370 --> 00:27:32,330
往返行程哦，

722
00:27:32,330 --> 00:27:33,860
如果我的查询

723
00:27:33,860 --> 00:27:35,710
需要一个 albacore 运行并且我可以缓存它，那么它是一个巨大的季度绝对可以产生不同

724
00:27:35,710 --> 00:27:38,600
太棒了，所以我们不会

725
00:27:38,600 --> 00:27:41,330
本学期我很了解它，这也是

726
00:27:41,330 --> 00:27:44,480
我自己完全了解的另一个领域，您

727
00:27:44,480 --> 00:27:46,460
可以在数据库服务方面获得此信息，

728
00:27:46,460 --> 00:27:49,159
因此查询 alt 缓存

729
00:27:49,159 --> 00:27:50,600
并不总是好的，因为它就像核心

730
00:27:50,600 --> 00:27:52,700
spring，就像您拥有

731
00:27:52,700 --> 00:27:54,710
整个续集的缓存结果一样 查询

732
00:27:54,710 --> 00:27:58,100
就像如果我说你知道巨大的

733
00:27:58,100 --> 00:27:59,809
选择查询是否有一个谓词或者

734
00:27:59,809 --> 00:28:02,360
说名字等于安迪我的缓存

735
00:28:02,360 --> 00:28:04,159
然后你的查询显示你的名字

736
00:28:04,159 --> 00:28:06,559
我不能重用我计算的任何东西

737
00:28:06,559 --> 00:28:07,789
即使可能有一个 改变

738
00:28:07,789 --> 00:28:10,639
所以一个非常常见的事情是

739
00:28:10,639 --> 00:28:12,440
所谓的物化视图，你可以在其中

740
00:28:12,440 --> 00:28:13,940
实际物化该

741
00:28:13,940 --> 00:28:17,270
查询的部分，所以就像你 Prima

742
00:28:17,270 --> 00:28:19,070
消毒一些昂贵的连接，

743
00:28:19,070 --> 00:28:20,360
然后谓词这个进来，是如何

744
00:28:20,360 --> 00:28:21,770
对物化查询做过滤器

745
00:28:21,770 --> 00:28:23,510
和高端服务器

746
00:28:23,510 --> 00:28:25,550
，特别是续集服务器，可以知道

747
00:28:25,550 --> 00:28:27,500
如何在不同的查询中重用物化视图，

748
00:28:27,500 --> 00:28:30,650
但同样对于

749
00:28:30,650 --> 00:28:32,570
你的表，你需要一个显式的

750
00:28:32,570 --> 00:28:35,210
缓存 inval  idation 消息，我认为没有

751
00:28:35,210 --> 00:28:39,100
人真正做到这一点，

752
00:28:39,430 --> 00:29:06,620
所以是的，所以问题是为什么

753
00:29:06,620 --> 00:29:08,930
我想要一个游标，

754
00:29:08,930 --> 00:29:11,420
我一次返回一个元组而不是像

755
00:29:11,420 --> 00:29:13,010
降序所有的那样，所以我

756
00:29:13,010 --> 00:29:15,620
认为我认为是游标 我不知道

757
00:29:15,620 --> 00:29:16,940
确切的细节，就像我认为它们因系统而异，

758
00:29:16,940 --> 00:29:18,410
这并不意味着它不仅仅是一个

759
00:29:18,410 --> 00:29:21,380
快速的，而是一个包一个

760
00:29:21,380 --> 00:29:23,120
消息以获得一个结果他们发送了

761
00:29:23,120 --> 00:29:25,700
一批问题是我发送 你

762
00:29:25,700 --> 00:29:27,410
知道 500 万个结果 我发送了所有 100

763
00:29:27,410 --> 00:29:31,600
万个还是我一次发送 10,000 个

764
00:29:33,880 --> 00:29:36,470
正确的 如果你的 davis ism

765
00:29:36,470 --> 00:29:39,260
不支持支持游标 你

766
00:29:39,260 --> 00:29:41,840
必须发送一个我的结果是的 然后

767
00:29:41,840 --> 00:29:47,170


768
00:29:47,170 --> 00:29:49,550
想想 数据库服务器

769
00:29:49,550 --> 00:29:50,810
与应用服务器的外观相比

770
00:29:50,810 --> 00:29:52,700


771
00:29:52,700 --> 00:29:54,190


772
00:29:54,190 --> 00:29:57,560


773
00:29:57,560 --> 00:29:59,630


774
00:29:59,630 --> 00:30:01,580


775
00:30:01,580 --> 00:30:03,560
很多内存最快的

776
00:30:03,560 --> 00:30:04,790
应用程序服务器可以是这些你

777
00:30:04,790 --> 00:30:08,240
知道的非品牌 ec2 实例他们

778
00:30:08,240 --> 00:30:09,740
不会有那么多内存所以也许我

779
00:30:09,740 --> 00:30:11,360
不想用所有 100

780
00:30:11,360 --> 00:30:13,580
万个元组爆炸它有点像

781
00:30:13,580 --> 00:30:19,400
它 对，我不知道我不知道

782
00:30:19,400 --> 00:30:20,630
它有什么区别我实际上不知道有

783
00:30:20,630 --> 00:30:22,100
什么区别

784
00:30:22,100 --> 00:30:24,200
做两件不同的事情有什么不同因为

785
00:30:24,200 --> 00:30:27,230
你也可以想象

786
00:30:27,230 --> 00:30:28,370
你实现游标的方式也可能不同

787
00:30:28,370 --> 00:30:30,620
因为 就像我执行

788
00:30:30,620 --> 00:30:30,980
查询

789
00:30:30,980 --> 00:30:32,899
我现在缓冲结果然后你

790
00:30:32,899 --> 00:30:34,190
在游标上调用 get next 我错过

791
00:30:34,190 --> 00:30:37,070
了它，或者我可以

792
00:30:37,070 --> 00:30:39,799
在我有管道断路器的地方设置它，

793
00:30:39,799 --> 00:30:41,779
我说这是最终结果 执行引擎

794
00:30:41,779 --> 00:30:45,320
中调用 get next get next 的查询会

795
00:30:45,320 --> 00:30:46,970
得到一堆元组，

796
00:30:46,970 --> 00:30:48,080
但是有一次您达到了我的光标

797
00:30:48,080 --> 00:30:50,299
限制，然后我将其交还给

798
00:30:50,299 --> 00:30:51,470
客户端，因为如果他们可能不会

799
00:30:51,470 --> 00:30:53,269
回来并要求更多

800
00:30:53,269 --> 00:30:54,980
来要求更多然后我现在

801
00:30:54,980 --> 00:30:56,630
很可爱 查询的其余部分可以以

802
00:30:56,630 --> 00:30:57,529
这种方式暂存，

803
00:30:57,529 --> 00:31:00,019
我认为每个人都会缓冲它，然后

804
00:31:00,019 --> 00:31:01,429
为您提供缓冲区光标的句柄，

805
00:31:01,429 --> 00:31:03,860
但您可以以

806
00:31:03,860 --> 00:31:05,419
另一种方式实现它，我认为这就是

807
00:31:05,419 --> 00:31:06,830
最初设想的方式，但这

808
00:31:06,830 --> 00:31:09,860
就像 1980 年代 管道不是

809
00:31:09,860 --> 00:31:11,450
管道模型，但就像火山模型一样，

810
00:31:11,450 --> 00:31:14,210
等待是管道，它是关于

811
00:31:14,210 --> 00:31:16,480
你的火山迭代器管道模型是的，

812
00:31:16,480 --> 00:31:22,700
同样的事情好吧，所以这只是一个表格，

813
00:31:22,700 --> 00:31:25,580
显示你知道什么其他

814
00:31:25,580 --> 00:31:27,559
系统实际上使用墨西哥的有线

815
00:31:27,559 --> 00:31:29,570
协议，我认为他们 “实际上更多

816
00:31:29,570 --> 00:31:31,970
系统使用 hive，但我

817
00:31:31,970 --> 00:31:33,080
能找到的唯一一个讲高线

818
00:31:33,080 --> 00:31:36,710
协议的是 spark，所以我的续集很

819
00:31:36,710 --> 00:31:38,269
常见，尽管一开始

820
00:31:38,269 --> 00:31:41,330
是我的续集的黑客版本，比如 mem

821
00:31:41,330 --> 00:31:43,039
续集实际上

822
00:31:43,039 --> 00:31:46,070
不是” 它不是一个成熟的

823
00:31:46,070 --> 00:31:47,690
数据库系统，它是一个

824
00:31:47,690 --> 00:31:50,120
像 ODB 或 Rocks DB 中的存储引擎，

825
00:31:50,120 --> 00:31:51,860
位于我的续集之下，所以他们进入了我的

826
00:31:51,860 --> 00:31:53,630
续集，你知道兼容性和有线

827
00:31:53,630 --> 00:31:55,549
协议 r 最终免费

828
00:31:55,549 --> 00:31:56,419
，他们自己写了所有东西

829
00:31:56,419 --> 00:31:58,340
，因为否则你会

830
00:31:58,340 --> 00:31:59,990
违反 GPL 和他们的专有

831
00:31:59,990 --> 00:32:02,120
但所以他们现在基本上讲我的

832
00:32:02,120 --> 00:32:03,470
续集协议所以他们是我的

833
00:32:03,470 --> 00:32:07,429
秘密兜售集群基于我的

834
00:32:07,429 --> 00:32:09,889
续集但它有排序 上面

835
00:32:09,889 --> 00:32:11,600
那一层是分布式的，所以

836
00:32:11,600 --> 00:32:13,190
有一个叫做我的续集代理的框架

837
00:32:13,190 --> 00:32:15,919
，它给你像一个给你

838
00:32:15,919 --> 00:32:16,820
像

839
00:32:16,820 --> 00:32:18,380
我的续集线协议的中间件前端实现，

840
00:32:18,380 --> 00:32:20,240
还有一堆其他

841
00:32:20,240 --> 00:32:21,919
的又在说 有线

842
00:32:21,919 --> 00:32:24,049
协议 Amazon Aurora 略有

843
00:32:24,049 --> 00:32:24,649
不同

844
00:32:24,649 --> 00:32:26,720
我稍后会谈到这里有

845
00:32:26,720 --> 00:32:27,980
一堆这些是地下室

846
00:32:27,980 --> 00:32:30,289
Postgres 所以其中一些是

847
00:32:30,289 --> 00:32:33,110
从头开始编写的像超级复制 HDD

848
00:32:33,110 --> 00:32:35,929
我们的旧系统 Umbra 这些是

849
00:32:35,929 --> 00:32:37,940
我们看起来像的系统

850
00:32:37,940 --> 00:32:39,830
目的线路协议的规范和阅读

851
00:32:39,830 --> 00:32:42,440
仅在我们的系统中实现了它，

852
00:32:42,440 --> 00:32:44,380
例如 redshift greenplum Vertica

853
00:32:44,380 --> 00:32:45,670
，我想也许你可以咬一下这些

854
00:32:45,670 --> 00:32:48,160
是他们 他们从 Postgres 开始的原始代码

855
00:32:48,160 --> 00:32:50,200
，他们撕掉了

856
00:32:50,200 --> 00:32:51,940
他们不想要的部分，然后重写

857
00:32:51,940 --> 00:32:54,010
它来做他们想做的任何事情，

858
00:32:54,010 --> 00:32:56,050
所以他们保留

859
00:32:56,050 --> 00:32:58,450
了 Postgres 的网络层的前端代码，

860
00:32:58,450 --> 00:33:02,020
这就是 Aurora 的原因

861
00:33:02,020 --> 00:33:06,580
不同的是因为亚马逊

862
00:33:06,580 --> 00:33:08,350
控制整个堆栈，如果

863
00:33:08,350 --> 00:33:10,330
你在他们的云中心运行，

864
00:33:10,330 --> 00:33:12,280
他们串通控制

865
00:33:12,280 --> 00:33:13,570
网络层，借口你层

866
00:33:13,570 --> 00:33:15,400
和存储层，所以他们所做的

867
00:33:15,400 --> 00:33:16,570
实际上非常有趣，至少从

868
00:33:16,570 --> 00:33:17,560
我看来 续集我不知道他们是否

869
00:33:17,560 --> 00:33:19,660
为 Postgres 这样做了他们实际上为我的续集删除了一些

870
00:33:19,660 --> 00:33:21,400
有线协议的网络逻辑，然后将

871
00:33:21,400 --> 00:33:24,160
它

872
00:33:24,160 --> 00:33:26,200
像负载平衡网络层一样推入亚马逊，

873
00:33:26,200 --> 00:33:28,240
所以现在

874
00:33:28,240 --> 00:33:30,730
当你像你的应用程序一样时 与

875
00:33:30,730 --> 00:33:33,910
您的数据库实例对话并运行

876
00:33:33,910 --> 00:33:35,770
Aurora 您可能实际上

877
00:33:35,770 --> 00:33:37,720


878
00:33:37,720 --> 00:33:39,790
并没有访问您正在运行的实际 Aurora 系统本身，并且有网络

879
00:33:39,790 --> 00:33:42,100
从来没有一个很酷的

880
00:33:42,100 --> 00:33:43,570
上面的粉红色层不会

881
00:33:43,570 --> 00:33:44,560
对你进行负载平衡，这真的很

882
00:33:44,560 --> 00:33:47,050
吸引人，他们可以做的是他们

883
00:33:47,050 --> 00:33:51,520
可以

884
00:33:51,520 --> 00:33:53,770
从一个实例透明地切换到另一个实例，就像

885
00:33:53,770 --> 00:33:55,630
我在一台小型机器上运行一样

886
00:33:55,630 --> 00:33:57,550
将 Amazon 升级到我的 Aurora 实例

887
00:33:57,550 --> 00:33:59,620
或网络层中更大的机器，

888
00:33:59,620 --> 00:34:01,150
因为它现在

889
00:34:01,150 --> 00:34:04,480
与实际的数据库服务器分离，他们可以

890
00:34:04,480 --> 00:34:07,270
从

891
00:34:07,270 --> 00:34:09,250
您知道的所有客户端复制会话变量，从一台

892
00:34:09,250 --> 00:34:10,780
服务器到另一台，然后它就有了

893
00:34:10,780 --> 00:34:13,239
网络 层切换到

894
00:34:13,239 --> 00:34:14,500
新实例，看起来您

895
00:34:14,500 --> 00:34:16,810
神奇地获得了更多更多您

896
00:34:16,810 --> 00:34:19,060
知道更多 RAM 更多CPU 而实际上

897
00:34:19,060 --> 00:34:20,500
您不知道关闭任何

898
00:34:20,500 --> 00:34:21,790
连接，这太疯狂了

899
00:34:21,790 --> 00:34:23,520
我认为只有亚马逊才能做到这一点，因为

900
00:34:23,520 --> 00:34:27,909
它是亚马逊，所以我们 把这个

901
00:34:27,909 --> 00:34:29,469
离线实现这是一个

902
00:34:29,469 --> 00:34:31,629
巨大的痛苦税你和

903
00:34:31,629 --> 00:34:34,300
马特谈论它是可怕的这是我们第三次

904
00:34:34,300 --> 00:34:35,710
尝试阅读他们的帖子是有线

905
00:34:35,710 --> 00:34:38,370
协议，它是r 真的很难看，

906
00:34:38,370 --> 00:34:40,120
因为他们有两种不同的模式

907
00:34:40,120 --> 00:34:44,020
，这很混乱，好吧，所以让我们

908
00:34:44,020 --> 00:34:45,159
谈谈你们今天

909
00:34:45,159 --> 00:34:50,500
为这门课阅读的论文，正如我所说，我们

910
00:34:50,500 --> 00:34:52,210
可以有机会在其中获得更好的

911
00:34:52,210 --> 00:34:54,550
性能并改进有线

912
00:34:54,550 --> 00:34:56,860
协议是 当我们将数据序列化

913
00:34:56,860 --> 00:34:57,880
回

914
00:34:57,880 --> 00:34:59,530
客户端时，我们可以忽略填充的游标，

915
00:34:59,530 --> 00:35:01,300
假设他们运行了一个查询并且

916
00:35:01,300 --> 00:35:02,560
他们想要一堆

917
00:35:02,560 --> 00:35:04,720
结果，而你们如何阅读的纸质文件

918
00:35:04,720 --> 00:35:07,420
来自正在

919
00:35:07,420 --> 00:35:09,910
构建配音数据库的同一作者 或桥梁的人

920
00:35:09,910 --> 00:35:12,070
也在 CWI 上研究 Monet DB，

921
00:35:12,070 --> 00:35:14,410
他们专注于做

922
00:35:14,410 --> 00:35:16,780
这些大数据导出，所以没有那么多

923
00:35:16,780 --> 00:35:18,280
运行复杂的查询和备份

924
00:35:18,280 --> 00:35:18,460


925
00:35:18,460 --> 00:35:21,040
你知道聚合结果但我有

926
00:35:21,040 --> 00:35:23,470
我的 Python 或数据科学应用程序

927
00:35:23,470 --> 00:35:25,180
运行 一些结果，我有我所有的

928
00:35:25,180 --> 00:35:27,130
数据库 我的数据在我的续集数据库中

929
00:35:27,130 --> 00:35:29,140
我能多快把这些数据拿出来并

930
00:35:29,140 --> 00:35:32,310
把它放到我的机器学习管道中

931
00:35:32,310 --> 00:35:34,780
所以今天讨论了很多事情

932
00:35:34,780 --> 00:35:37,270
看起来 li  ke 我们之前讨论过的所有存储的东西都是

933
00:35:37,270 --> 00:35:39,160
正确的 如何进行

934
00:35:39,160 --> 00:35:40,840
压缩 如何进行行与

935
00:35:40,840 --> 00:35:42,730
平静的事情 因为这基本上

936
00:35:42,730 --> 00:35:44,920
是正确的 我们有一些巨大的

937
00:35:44,920 --> 00:35:47,320
块和数据

938
00:35:47,320 --> 00:35:50,500
我们应该组织它以通过什么最佳方式将其

939
00:35:50,500 --> 00:35:53,140
发送 线，它基本上

940
00:35:53,140 --> 00:35:55,090
与我们想

941
00:35:55,090 --> 00:35:57,250
在磁盘或内存中存储

942
00:35:57,250 --> 00:36:01,720
一堆数据相同

943
00:36:01,720 --> 00:36:02,860


944
00:36:02,860 --> 00:36:05,490


945
00:36:05,490 --> 00:36:08,500
但是，我们

946
00:36:08,500 --> 00:36:11,260
在服务器端组织数据，然后将其发送

947
00:36:11,260 --> 00:36:13,300
给客户端，客户端必须能够

948
00:36:13,300 --> 00:36:15,670
解释并反转它，因此这

949
00:36:15,670 --> 00:36:18,640
会在一定程度上限制我们

950
00:36:18,640 --> 00:36:19,990
实际可以做的事情，因为我们不想给

951
00:36:19,990 --> 00:36:21,670
客户端带来负担 实际上

952
00:36:21,670 --> 00:36:24,970
现在又做了大量的工作，他们专注

953
00:36:24,970 --> 00:36:27,750
于进行这些数据的批量导出，

954
00:36:27,750 --> 00:36:30,370
但是很多时候

955
00:36:30,370 --> 00:36:32,050
您将在其他系统中使用

956
00:36:32,050 --> 00:36:33,610
的相同客户端驱动程序，例如您将用于 Android 应用程序的相同客户端驱动

957
00:36:33,610 --> 00:36:36,040
程序 d

958
00:36:36,040 --> 00:36:37,450
是相同的客户端驱动程序

959
00:36:37,450 --> 00:36:39,850
，无论您的应用程序

960
00:36:39,850 --> 00:36:42,550
在您知道的巨型 Xeon 盒子上运行什么，您都会使用它，所以

961
00:36:42,550 --> 00:36:44,470
现在没有人将 TB 的

962
00:36:44,470 --> 00:36:45,940
数据下载到他们的手机，这很愚蠢，

963
00:36:45,940 --> 00:36:48,010
但就像它只是意味着我们

964
00:36:48,010 --> 00:36:49,390
需要一点支持

965
00:36:49,390 --> 00:36:51,250
我们在这里对数据应用的优化

966
00:36:51,250 --> 00:36:52,630
我们必须能够逆转

967
00:36:52,630 --> 00:36:54,310
它们并解释它们，这

968
00:36:54,310 --> 00:36:58,140
意味着我们不能太重

969
00:36:58,140 --> 00:37:00,100
，因为我们不想

970
00:37:00,100 --> 00:37:01,900
复制那个逻辑

971
00:37:01,900 --> 00:37:05,440
如果我

972
00:37:05,440 --> 00:37:07,300
想支持所有不同的

973
00:37:07,300 --> 00:37:08,710
编程语言，并且我有

974
00:37:08,710 --> 00:37:09,850
这些程序语言中的每一种的本机驱动程序，

975
00:37:09,850 --> 00:37:11,740
无论我需要做什么来

976
00:37:11,740 --> 00:37:13,570
用一种语言解压缩数据，我都必须

977
00:37:13,570 --> 00:37:15,970
为另一种语言做正确的事情

978
00:37:15,970 --> 00:37:17,800
就像最低公分母，

979
00:37:17,800 --> 00:37:19,119
它有些限制，但

980
00:37:19,119 --> 00:37:22,960
它是好的，所以

981
00:37:22,960 --> 00:37:24,310
首先要讨论的是行

982
00:37:24,310 --> 00:37:28,089
与列，所以 odbc jdbc

983
00:37:28,089 --> 00:37:32,260
本质上是面向行的 api 是我们我们

984
00:37:32,260 --> 00:37:33,609
要去服务器总是会

985
00:37:33,609 --> 00:37:36,820
打包元组并

986
00:37:36,820 --> 00:37:38,500
一次一个元组和某种包

987
00:37:38,500 --> 00:37:40,000
作为发送它的单个消息现在

988
00:37:40,000 --> 00:37:40,660
通过网络发送

989
00:37:40,660 --> 00:37:41,890
这些流一堆

990
00:37:41,890 --> 00:37:43,900
消息 但是

991
00:37:43,900 --> 00:37:45,640
这些服务器的主要编写方式

992
00:37:45,640 --> 00:37:47,290
是它假设我将

993
00:37:47,290 --> 00:37:49,359
在服务器端一次迭代一个元

994
00:37:49,359 --> 00:37:51,130


995
00:37:51,130 --> 00:37:53,020


996
00:37:53,020 --> 00:37:54,970
组 我

997
00:37:54,970 --> 00:37:56,920
想我可以将这些消息发送到我的数据包中

998
00:37:56,920 --> 00:37:58,240
，然后客户端必须反转它，

999
00:37:58,240 --> 00:38:01,750
所以回到 1990 年代，当他们第

1000
00:38:01,750 --> 00:38:04,240
一次开始构建以供查看时 JDBC 这

1001
00:38:04,240 --> 00:38:07,420
是有道理的，因为是您，您

1002
00:38:07,420 --> 00:38:09,190
要么在其中运行所有三个应用程序

1003
00:38:09,190 --> 00:38:12,040
结果集很小，比如 go

1004
00:38:12,040 --> 00:38:13,720
get Andes account record go get all of

1005
00:38:13,720 --> 00:38:15,400
annie 从 Amazon 购买的订单

1006
00:38:15,400 --> 00:38:18,099
，这些订单不是很多数据，

1007
00:38:18,099 --> 00:38:20,619
也不是很多元组，如果你在做

1008
00:38:20,619 --> 00:38:24,250
分析，通常只是你

1009
00:38:24,250 --> 00:38:27,640
知道 com 把你知道的销售

1010
00:38:27,640 --> 00:38:29,050
总额按季度计算，

1011
00:38:29,050 --> 00:38:30,790
然后你做一些聚合

1012
00:38:30,790 --> 00:38:32,859
，所以像查询一样，查询

1013
00:38:32,859 --> 00:38:34,000
有点复杂，需要

1014
00:38:34,000 --> 00:38:34,869
决定，但你得到的最终金额

1015
00:38:34,869 --> 00:38:37,180
是 不是很多，

1016
00:38:37,180 --> 00:38:39,010
但正如我所说，鸭子 TB 人员

1017
00:38:39,010 --> 00:38:41,230
专注于将数据库

1018
00:38:41,230 --> 00:38:43,570
内容暴露给这些现代机器

1019
00:38:43,570 --> 00:38:47,619
学习软件，在这个世界上，我们

1020
00:38:47,619 --> 00:38:50,740
希望将事物作为列或矩阵，所以

1021
00:38:50,740 --> 00:38:53,080
这种面向行的方法是

1022
00:38:53,080 --> 00:38:56,440
有限的，所以什么 他们建议做的是

1023
00:38:56,440 --> 00:38:59,470
，不是以行或

1024
00:38:59,470 --> 00:39:01,119
引擎格式发送，我们实际上可以将

1025
00:39:01,119 --> 00:39:04,420
其作为向量发送，特别是

1026
00:39:04,420 --> 00:39:05,770
他们要做的方式是他们

1027
00:39:05,770 --> 00:39:07,119


1028
00:39:07,119 --> 00:39:10,359
将在一个块内组织一堆元组 然后

1029
00:39:10,359 --> 00:39:11,859
在该块中，它们将被组织

1030
00:39:11,859 --> 00:39:13,900
为列，这样我就不会

1031
00:39:13,900 --> 00:39:17,260
在一堆消息中一次流过一个列

1032
00:39:17,260 --> 00:39:18,609
，然后当我

1033
00:39:18,609 --> 00:39:19,780
完成该列时切换到

1034
00:39:19,780 --> 00:39:21,790
下一列 这样做他们 我会

1035
00:39:21,790 --> 00:39:23,740
说这里有一堆元组将它转换

1036
00:39:23,740 --> 00:39:25,029
为一个

1037
00:39:25,029 --> 00:39:26,469
我存储在

1038
00:39:26,469 --> 00:39:28,630
那个块中然后传送那个块然后

1039
00:39:28,630 --> 00:39:30,279
对于服务器端的下一批元组

1040
00:39:30,279 --> 00:39:32,829
你做同样的事情所以我们没有说话

1041
00:39:32,829 --> 00:39:34,919
正是当我们谈论

1042
00:39:34,919 --> 00:39:37,959
商店布局时，这就是所谓的

1043
00:39:37,959 --> 00:39:38,709
包装模型

1044
00:39:38,709 --> 00:39:42,459
我实际上不是在 CMU

1045
00:39:42,459 --> 00:39:45,219
而是由一位曾经

1046
00:39:45,219 --> 00:39:48,009
在 CMU 现在她在 EPFL 的教授发明的，这

1047
00:39:48,009 --> 00:39:49,029
实际上是我们在我们的工作中所做的 成为系统的那一天，

1048
00:39:49,029 --> 00:39:51,549
我们将数据组织为 1

1049
00:39:51,549 --> 00:39:53,109
兆字节的块，然后在该

1050
00:39:53,109 --> 00:39:55,059
块中，我们

1051
00:39:55,059 --> 00:39:56,949
拥有单个元组的所有属性或字段，但

1052
00:39:56,949 --> 00:39:58,449
这些字段中的每一个都将组织为

1053
00:39:58,449 --> 00:40:00,699
列存储，因为我们

1054
00:40:00,699 --> 00:40:02,409
遵循箭头所做的操作 这是

1055
00:40:02,409 --> 00:40:11,099
在公园代理中使用的，或者是的，问题

1056
00:40:11,099 --> 00:40:15,159
是很抱歉，这种方法是否

1057
00:40:15,159 --> 00:40:18,489
有效或 ODBC 所以他再次

1058
00:40:18,489 --> 00:40:21,519
不了解我们中的任何人，他不

1059
00:40:21,519 --> 00:40:23,130
知道我得到了一批两次打击，

1060
00:40:23,130 --> 00:40:26,739
他们自己作为专栏它只是因为

1061
00:40:26,739 --> 00:40:28,630
他们现在的程序 mming 接口

1062
00:40:28,630 --> 00:40:30,609
绝对是面向行的，我

1063
00:40:30,609 --> 00:40:33,130
得到一个光标，一个调用 get next 然后我

1064
00:40:33,130 --> 00:40:34,749
对该单列或那个单元组做任何需要做的事情

1065
00:40:34,749 --> 00:40:37,119
我

1066
00:40:37,119 --> 00:40:39,279
不知道我们是否会看到给了我一个

1067
00:40:39,279 --> 00:40:42,819
向量 为我提供跨所有元组

1068
00:40:42,819 --> 00:40:44,979
的单个列的列向量值的向量，

1069
00:40:44,979 --> 00:40:49,089
所以我认为

1070
00:40:49,089 --> 00:40:50,799
这里的建议是，

1071
00:40:50,799 --> 00:40:53,079
您可能必须

1072
00:40:53,079 --> 00:40:56,369
在应用程序服务器级

1073
00:40:56,369 --> 00:41:00,069
应用程序端 API 上重写或拥有自己的 API 以支持获取

1074
00:41:00,069 --> 00:41:02,919
这些向量我实际上不知道

1075
00:41:02,919 --> 00:41:05,049
我是否不知道它是否会是

1076
00:41:05,049 --> 00:41:07,929
C 作为一种方式来告诉我我的

1077
00:41:07,929 --> 00:41:10,679
结果并立即将它全部转储出来

1078
00:41:10,679 --> 00:41:12,999
我使用 G a BC 编写的所有代码

1079
00:41:12,999 --> 00:41:14,679
或 DC 一直就像你知道的那样，有一段

1080
00:41:14,679 --> 00:41:20,289
时间不能得到下一个好所以

1081
00:41:20,289 --> 00:41:21,459
我们将从中获得的好处是，如果我们

1082
00:41:21,459 --> 00:41:23,769
将所有东西都作为列存储，

1083
00:41:23,769 --> 00:41:25,630
那么我们将应用我们

1084
00:41:25,630 --> 00:41:26,919
上周谈到的所有压缩技术

1085
00:41:26,919 --> 00:41:28,269
我们的数据，因为我们知道所有值

1086
00:41:28,269 --> 00:41:29,409
都将在 t 内 在相同的域中

1087
00:41:29,409 --> 00:41:31,239
，我们将获得更好的压缩

1088
00:41:31,239 --> 00:41:34,179
率，所以这与我们

1089
00:41:34,179 --> 00:41:36,130
之前讨论

1090
00:41:36,130 --> 00:41:37,599


1091
00:41:37,599 --> 00:41:38,440


1092
00:41:38,440 --> 00:41:40,089


1093
00:41:40,089 --> 00:41:42,040
过的相同 我们只是

1094
00:41:42,040 --> 00:41:44,109
在它上面运行 gzip 或者快速地将它发送到

1095
00:41:44,109 --> 00:41:45,819
为什么电线和爬升不

1096
00:41:45,819 --> 00:41:48,849
只是调用你所知道的使用

1097
00:41:48,849 --> 00:41:51,280
相同的校正算法来解压缩

1098
00:41:51,280 --> 00:41:53,950
它的另一种方法来执行列

1099
00:41:53,950 --> 00:41:56,770
而不是像我们的特定编码 le 或

1100
00:41:56,770 --> 00:41:58,839
字典编码或 Delta

1101
00:41:58,839 --> 00:42:02,440
编码，据我所知，没有系统

1102
00:42:02,440 --> 00:42:05,200
真正做到这一点，这确实出现

1103
00:42:05,200 --> 00:42:07,150
在一些系统中，比如我的秘密武器

1104
00:42:07,150 --> 00:42:09,220
使用 gzip 的所有东西都采用了新闻数据，

1105
00:42:09,220 --> 00:42:12,550
所以正如他们在论文中所说，

1106
00:42:12,550 --> 00:42:13,690
这是 显然，如果您拥有更多数据，您将获得

1107
00:42:13,690 --> 00:42:17,470
更好的压缩率，

1108
00:42:17,470 --> 00:42:20,950
并且

1109
00:42:20,950 --> 00:42:24,040
对于更大的块也有什么

1110
00:42:24,040 --> 00:42:25,690
好处，这实际上会更好地工作

1111
00:42:25,690 --> 00:42:28,810
，他们说这是做到这一点的更好方法

1112
00:42:28,810 --> 00:42:32,260
，因为 该方法

1113
00:42:32,260 --> 00:42:34,089
与实际数据无关，因此

1114
00:42:34,089 --> 00:42:35,680
客户端服务器端没有逻辑

1115
00:42:35,680 --> 00:42:37,750
可以说哦，我正在查看本

1116
00:42:37,750 --> 00:42:39,040
专栏，它涉及编码，因此我

1117
00:42:39,040 --> 00:42:41,230
现在需要基本上重播 Delta

1118
00:42:41,230 --> 00:42:44,020
以将原始数据还给我 如果

1119
00:42:44,020 --> 00:42:45,339
我只是使用 snappy，我只是使用我的

1120
00:42:45,339 --> 00:42:47,290
字节流或字节数组，然后运行

1121
00:42:47,290 --> 00:42:48,670
它，然后我把所有东西都拿出来，

1122
00:42:48,670 --> 00:42:51,130
但我希望他们告诉我们

1123
00:42:51,130 --> 00:42:52,540
在论文中谈论的另一件事是，

1124
00:42:52,540 --> 00:42:54,880
如果网络很慢 那么

1125
00:42:54,880 --> 00:42:57,790
像 gzip 这样更重量级的算法会比 snappy 之类的算法更

1126
00:42:57,790 --> 00:42:59,530
可取，

1127
00:42:59,530 --> 00:43:02,380
因为你付出了代价，你知道你

1128
00:43:02,380 --> 00:43:04,270
付出了更高的 CPU 开销

1129
00:43:04,270 --> 00:43:06,369
来获得更好的压缩率，

1130
00:43:06,369 --> 00:43:08,140
这通常又是一个很好的

1131
00:43:08,140 --> 00:43:10,630
权衡 这听起来

1132
00:43:10,630 --> 00:43:12,609
像什么 听起来像一个光盘 是的

1133
00:43:12,609 --> 00:43:14,950
，它本质上是一个缓慢

1134
00:43:14,950 --> 00:43:16,240
的硬件，我们需要

1135
00:43:16,240 --> 00:43:18,579
像一根稻草一样将数据从一侧

1136
00:43:18,579 --> 00:43:21,339
传输到另一侧，所以如果我们知道它

1137
00:43:21,339 --> 00:43:23,260
会很慢我们' 将有低

1138
00:43:23,260 --> 00:43:25,089
带宽 然后我们想

1139
00:43:25,089 --> 00:43:27,400


1140
00:43:27,400 --> 00:43:31,740
在数据的摄取和读取上做尽可能多的工作，以

1141
00:43:31,740 --> 00:43:35,020
最大限度地减少开销，

1142
00:43:35,020 --> 00:43:36,250
因此他们声称这更好

1143
00:43:36,250 --> 00:43:38,020
，就像我说的没有人我不知道

1144
00:43:38,020 --> 00:43:41,890
任何系统 这样做了，现在我们面临

1145
00:43:41,890 --> 00:43:43,060
的问题是我们实际上将

1146
00:43:43,060 --> 00:43:44,410
如何表示数据或者您

1147
00:43:44,410 --> 00:43:47,890
将如何序列化它，所以第一种

1148
00:43:47,890 --> 00:43:50,069
方法是进行二进制编码

1149
00:43:50,069 --> 00:43:52,369
，这就像我们讨论的

1150
00:43:52,369 --> 00:43:54,259
那样 对齐和

1151
00:43:54,259 --> 00:43:56,990
布局我们

1152
00:43:56,990 --> 00:43:59,990
将以二进制形式表示数据，这通常

1153
00:43:59,990 --> 00:44:01,849
是 C 或超级球之类的任何东西的原生形式，

1154
00:44:01,849 --> 00:44:03,259
所以如果我们

1155
00:44:03,259 --> 00:44:05,299
遵循 I Triple E 754

1156
00:44:05,299 --> 00:44:08,269
标准，它会给我们带来什么困难，所以会发生什么是

1157
00:44:08,269 --> 00:44:09,619
客户端 -side 我将负责

1158
00:44:09,619 --> 00:44:11,269
处理任何 ns 因为服务器

1159
00:44:11,269 --> 00:44:12,829
不知道你真正想要什么

1160
00:44:12,829 --> 00:44:15,049
所以服务器会在你知道的 DNS 中发送它，

1161
00:44:15,049 --> 00:44:16,640
客户端说哦，

1162
00:44:16,640 --> 00:44:19,339
我被告知我你知道服务器

1163
00:44:19,339 --> 00:44:20,809
运行 x86 因此他给了我

1164
00:44:20,809 --> 00:44:22,519
很少 endian 但在我的手机上运行时，

1165
00:44:22,519 --> 00:44:24,230
我需要对

1166
00:44:24,230 --> 00:44:26,420
负责反转它的客户使用 big-endian，

1167
00:44:26,420 --> 00:44:27,769
但这并不太昂贵，

1168
00:44:27,769 --> 00:44:28,999
除了不得不复制

1169
00:44:28,999 --> 00:44:32,119
数据之外，另一件同样重要的

1170
00:44:32,119 --> 00:44:34,670
事情是，如果我们可以拥有任何

1171
00:44:34,670 --> 00:44:37,069
格式 是数据系统用于

1172
00:44:37,069 --> 00:44:39,650
将数据直接存储在实际

1173
00:44:39,650 --> 00:44:42,259
的列本身中，如果我们的

1174
00:44:42,259 --> 00:44:44,690
有线协议可以匹配我们

1175
00:44:44,690 --> 00:44:46,249
实际存储的行本身，那么它会

1176
00:44:46,249 --> 00:44:49,009
非常便宜或开销很低，

1177
00:44:49,009 --> 00:44:50,960
我们可以从中取出数据 查询的结果

1178
00:44:50,960 --> 00:44:53,150
，然后将其放入一个数据包中，然后通过网络

1179
00:44:53,150 --> 00:44:55,700
发送，所以我的意思是

1180
00:44:55,700 --> 00:44:58,579
，如果使用我们的旧系统作为

1181
00:44:58,579 --> 00:45:01,999
示例，我们的旧系统分别构建了我们的

1182
00:45:01,999 --> 00:45:03,380
执行引擎和存储管理器

1183
00:45:03,380 --> 00:45:04,940
，然后我们进行排序 将

1184
00:45:04,940 --> 00:45:06,829
它移植到 Postgres 上，然后当我们

1185
00:45:06,829 --> 00:45:09,109
真正想要将

1186
00:45:09,109 --> 00:45:11,779
查询结果放入一个数据包中并

1187
00:45:11,779 --> 00:45:13,819
通过进程线协议发送它时，它

1188
00:45:13,819 --> 00:45:15,349
表示字符串的方式与

1189
00:45:15,349 --> 00:45:17,569
我们表示 stri 的方式不同 ngs，所以我们

1190
00:45:17,569 --> 00:45:19,400
必须正确转换它，

1191
00:45:19,400 --> 00:45:21,410
基本上这意味着将您知道的数据复制

1192
00:45:21,410 --> 00:45:23,180
到我们的原始格式并将其

1193
00:45:23,180 --> 00:45:25,099
复制到并转换为发布

1194
00:45:25,099 --> 00:45:26,960
业务格式，以便额外的复制

1195
00:45:26,960 --> 00:45:28,369
开始增加，因为如果您这样做是

1196
00:45:28,369 --> 00:45:29,690
为了 每一个查询和每

1197
00:45:29,690 --> 00:45:31,130
一个元组以及每一个

1198
00:45:31,130 --> 00:45:32,989
结果，然后你花所有

1199
00:45:32,989 --> 00:45:34,160
的时间来复制和

1200
00:45:34,160 --> 00:45:35,420
序列化反序列化很

1201
00:45:35,420 --> 00:45:38,809
糟糕，我的意思是在 peloton 我们有

1202
00:45:38,809 --> 00:45:40,489
另一个错误，就像我们

1203
00:45:40,489 --> 00:45:42,440
更新了三个副本只是为了得到 通过

1204
00:45:42,440 --> 00:45:44,809
有线协议其中两个你需要其中一个

1205
00:45:44,809 --> 00:45:47,119
是多余的

1206
00:45:47,119 --> 00:45:49,190
但这可能是我们杀死该

1207
00:45:49,190 --> 00:45:52,839
系统的原因你也可以做的另一件事是

1208
00:45:52,839 --> 00:45:56,299
而不是实现你自己的

1209
00:45:56,299 --> 00:45:58,519
二进制格式来

1210
00:45:58,519 --> 00:46:00,589
发送你的消息 表示在获取

1211
00:46:00,589 --> 00:46:02,359
消息时，您实际上可以依赖这些

1212
00:46:02,359 --> 00:46:04,099
串行序列化开源

1213
00:46:04,099 --> 00:46:05,480
稳定格式，其中

1214
00:46:05,480 --> 00:46:07,430
两个最著名的格式是 Google 的

1215
00:46:07,430 --> 00:46:09,170
协议缓冲区 或 Facebook thrift

1216
00:46:09,170 --> 00:46:12,109
正确考虑这一点，因为您

1217
00:46:12,109 --> 00:46:16,760
在 DSL 中定义了数据包的外观和

1218
00:46:16,760 --> 00:46:19,099
类型等等，然后他们

1219
00:46:19,099 --> 00:46:22,250
有一种方法可以编译和

1220
00:46:22,250 --> 00:46:24,619
生成您的代码，然后您可以使用这些代码

1221
00:46:24,619 --> 00:46:26,240
来构建打击沙填充

1222
00:46:26,240 --> 00:46:28,550
这些缓冲区然后他们

1223
00:46:28,550 --> 00:46:29,900
会为你消毒，这样你就可以通过

1224
00:46:29,900 --> 00:46:32,960
网络发送我不知道任何

1225
00:46:32,960 --> 00:46:35,530
实际使用协议缓冲区或平面缓冲区的系统是协议缓冲区

1226
00:46:35,530 --> 00:46:37,400
的新版本

1227
00:46:37,400 --> 00:46:38,540
我认为它是零

1228
00:46:38,540 --> 00:46:42,020
复制所以它是 他会更快地使用 thrift

1229
00:46:42,020 --> 00:46:43,520
thrift 给你带来了一堆其他的东西，

1230
00:46:43,520 --> 00:46:45,849
比如你知道的 RPC 和其他

1231
00:46:45,849 --> 00:46:48,170
网络通信协议的东西

1232
00:46:48,170 --> 00:46:50,480
，这可能比你真正

1233
00:46:50,480 --> 00:46:52,490
想要的要多，但信仰蜂巢是唯一一个

1234
00:46:52,490 --> 00:46:56,180
知道使用它的人，所以我不会

1235
00:46:56,180 --> 00:46:59,390
推荐这些东西 因为这些

1236
00:46:59,390 --> 00:47:02,750
实际上会有点冗长，

1237
00:47:02,750 --> 00:47:05,630
就像他们必须记录所有这些

1238
00:47:05,630 --> 00:47:07,130
额外的元数据以告诉您

1239
00:47:07,130 --> 00:47:08,960
实际存储在我们的网络协议中的数据的实际类型，

1240
00:47:08,960 --> 00:47:12,290
如果我们 如果

1241
00:47:12,290 --> 00:47:13,490
我们自己做，

1242
00:47:13,490 --> 00:47:15,710
也许只是在我们发送的数据包的标题

1243
00:47:15,710 --> 00:47:17,030
中说嘿，我们

1244
00:47:17,030 --> 00:47:17,869
将向您发送一堆具有这些类型的元组，

1245
00:47:17,869 --> 00:47:19,490
而不是

1246
00:47:19,490 --> 00:47:20,750
我认为他们必须

1247
00:47:20,750 --> 00:47:22,220
制作的这些东西 该元数据的多个副本

1248
00:47:22,220 --> 00:47:24,980
适用于每条消息，因此出于

1249
00:47:24,980 --> 00:47:27,079
这个原因，我不建议您这样做，

1250
00:47:27,079 --> 00:47:28,790
您想要

1251
00:47:28,790 --> 00:47:33,020
自己滚动图像，因此除了

1252
00:47:33,020 --> 00:47:34,700
您关于我的类型的元数据之外

1253
00:47:34,700 --> 00:47:36,410
，我们还必须跟踪 就像

1254
00:47:36,410 --> 00:47:40,430
我们如何实际表示空值一样，大小

1255
00:47:40,430 --> 00:47:42,980
是我们的数据，所有这些都会变得

1256
00:47:42,980 --> 00:47:44,420
昂贵，并且某些系统

1257
00:47:44,420 --> 00:47:48,319
比其他系统做得更好，替代方案是

1258
00:47:48,319 --> 00:47:51,109
服务器只是将您的所有数据作为

1259
00:47:51,109 --> 00:47:55,730
纯文本正确发送，因此这样做的

1260
00:47:55,730 --> 00:47:56,839
优点是

1261
00:47:56,839 --> 00:47:58,670
在这些印度助手中你不必担心，

1262
00:47:58,670 --> 00:48:00,290
到目前为止，客户有责任

1263
00:48:00,290 --> 00:48:01,579
弄清楚如何实际解释

1264
00:48:01,579 --> 00:48:02,770
你实际看到的内容，

1265
00:48:02,770 --> 00:48:06,680
所以是的，这样想，所以

1266
00:48:06,680 --> 00:48:09,890
说我有 我的服务 呃，我的查询

1267
00:48:09,890 --> 00:48:11,930
结果有一个是因为一二男孩有

1268
00:48:11,930 --> 00:48:13,369
一个属性一二

1269
00:48:13,369 --> 00:48:15,319
三四五六所以有一个32位

1270
00:48:15,319 --> 00:48:17,599
整数我可以用四个字节表示所以

1271
00:48:17,599 --> 00:48:19,340
如果我以二进制形式发送它

1272
00:48:19,340 --> 00:48:20,990
只是说 嘿，我有一个四字节的

1273
00:48:20,990 --> 00:48:23,390
整数可供选择，我可以将

1274
00:48:23,390 --> 00:48:25,010
一二三四五六转换为一二三四五六的

1275
00:48:25,010 --> 00:48:26,990
字符串

1276
00:48:26,990 --> 00:48:29,960
，然后现在发送，在这种

1277
00:48:29,960 --> 00:48:32,330
情况下，假设我在编码中询问我需要

1278
00:48:32,330 --> 00:48:34,100
一个字节 对于每个字符，我

1279
00:48:34,100 --> 00:48:36,530
有六个数字，所以我需要六个

1280
00:48:36,530 --> 00:48:38,900
字节，然后取决于我如何

1281
00:48:38,900 --> 00:48:42,140
表示长度或说

1282
00:48:42,140 --> 00:48:43,190
帮助您了解

1283
00:48:43,190 --> 00:48:45,260
实际长度我需要一个额外的字节

1284
00:48:45,260 --> 00:48:47,060
可能会说这是一个空值

1285
00:48:47,060 --> 00:48:48,440
终止符或这里是字符串的长度

1286
00:48:48,440 --> 00:48:51,350
，然后现在在客户

1287
00:48:51,350 --> 00:48:53,690
端称为 2 I 如果您使用 C

1288
00:48:53,690 --> 00:48:56,210
将此字符串转换为正确的

1289
00:48:56,210 --> 00:48:58,640
形式，然后我们可以将其交给 ODBC

1290
00:48:58,640 --> 00:49:02,570
或 JDBC 所以这看起来有点疯狂

1291
00:49:02,570 --> 00:49:04,600
为什么实际上有人想要做 t

1292
00:49:04,600 --> 00:49:07,150
你认为它在本质上支持

1293
00:49:07,150 --> 00:49:09,890
JSON 类型或 JSON 结果

1294
00:49:09,890 --> 00:49:14,360
集的系统中就像查询 Monay DB 的输出

1295
00:49:14,360 --> 00:49:15,470
我们看到的第二个实际上也

1296
00:49:15,470 --> 00:49:18,860
支持这一点我忘记了为什么我

1297
00:49:18,860 --> 00:49:20,210
认为这只是出于历史原因

1298
00:49:20,210 --> 00:49:22,970
他们这样做但是 正如我们将在结果中看到的，

1299
00:49:22,970 --> 00:49:24,770
您知道以二进制

1300
00:49:24,770 --> 00:49:26,150
格式存储是更好的方式来做到这一点

1301
00:49:26,150 --> 00:49:31,940
总是好的 好的

1302
00:49:31,940 --> 00:49:32,720
上次您谈到我们

1303
00:49:32,720 --> 00:49:34,040
实际处理字符串的方式 我

1304
00:49:34,040 --> 00:49:37,310
刚才提到了这一点 这三种

1305
00:49:37,310 --> 00:49:38,600
方法又是同样的事情，但

1306
00:49:38,600 --> 00:49:39,650
实际上我们想在我们的数据库

1307
00:49:39,650 --> 00:49:42,380
系统中做我们只是做标准的 C 方式，

1308
00:49:42,380 --> 00:49:44,240
并在字符串的末尾有一个空字节

1309
00:49:44,240 --> 00:49:45,620
来表示字符串的结尾，

1310
00:49:45,620 --> 00:49:47,060
所以现在如果我正在解析

1311
00:49:47,060 --> 00:49:48,200


1312
00:49:48,200 --> 00:49:50,660
我一看到就通过网络传送的数据包不是终结

1313
00:49:50,660 --> 00:49:52,430
符字符我知道这

1314
00:49:52,430 --> 00:49:56,570
是字符串的结尾然后管理

1315
00:49:56,570 --> 00:49:58,580
这个是我使用我的所有客户端我可以使用

1316
00:49:58,580 --> 00:50:00,590
所有sturby标准 C API

1317
00:50:00,590 --> 00:50:02,390
字符串字符串函数因为 他们

1318
00:50:02,390 --> 00:50:03,530
知道如何使用万用表操作字符串

1319
00:50:03,530 --> 00:50:06,380
另一种方法是我们如何

1320
00:50:06,380 --> 00:50:06,980


1321
00:50:06,980 --> 00:50:08,450
在我们的数据库系统中本地执行此操作，我们

1322
00:50:08,450 --> 00:50:09,890
只需将字符串的长度添加到

1323
00:50:09,890 --> 00:50:11,120
字符串管道的开头，以便

1324
00:50:11,120 --> 00:50:12,860
我们知道客户端知道多远

1325
00:50:12,860 --> 00:50:13,880
需要提前找到你

1326
00:50:13,880 --> 00:50:16,640
需要的一切，最后一个就像一个 char

1327
00:50:16,640 --> 00:50:18,830
字段而不是一个 varchar'，你

1328
00:50:18,830 --> 00:50:24,620
只使用你有一个固定的大小

1329
00:50:24,620 --> 00:50:27,260
你使用的字节只是代表

1330
00:50:27,260 --> 00:50:29,870
每个元组的每个字符串的每个

1331
00:50:29,870 --> 00:50:32,870
属性 一个元组，你有一个固定的

1332
00:50:32,870 --> 00:50:33,380
大小

1333
00:50:33,380 --> 00:50:35,450
，然后你只需找出

1334
00:50:35,450 --> 00:50:37,220
每个人池的任何值，以

1335
00:50:37,220 --> 00:50:40,160
填充其余部分，其余部分

1336
00:50:40,160 --> 00:50:41,720
，其余部分

1337
00:50:41,720 --> 00:50:44,480
分配空间，所以这似乎

1338
00:50:44,480 --> 00:50:47,150
也有点浪费 好吧，但是如果

1339
00:50:47,150 --> 00:50:50,360
我的大多数字符串都说你知道

1340
00:50:50,360 --> 00:50:52,490
我的图表字段评估为 16 16 个字符，

1341
00:50:52,490 --> 00:50:54,350
而我的大多数字符串是 8 个字符

1342
00:50:54,350 --> 00:50:56,480
或 9 个字符，我是一堆零

1343
00:50:56,480 --> 00:50:58,940
，如果我使用的是 gzip 或 snappy

1344
00:50:58,940 --> 00:50:59,930
好操作 获得良好

1345
00:50:59,930 --> 00:51:01,190
压缩的机会，因为您可以一遍又一遍地看到重复的

1346
00:51:01,190 --> 00:51:02,510
字节序列，我

1347
00:51:02,510 --> 00:51:04,700
认为尽管在他们讨论的论文中

1348
00:51:04,700 --> 00:51:06,140
，这才真正

1349
00:51:06,140 --> 00:51:07,490
有意义，如果

1350
00:51:07,490 --> 00:51:09,230
您的所有流都像一个

1351
00:51:09,230 --> 00:51:12,710
字符，那么这才是最好的性能，然后 论文还

1352
00:51:12,710 --> 00:51:15,200
谈到有时这更快

1353
00:51:15,200 --> 00:51:17,870
，有时这更快，

1354
00:51:17,870 --> 00:51:19,730
这取决于你的

1355
00:51:19,730 --> 00:51:22,880
长处，据他们所知，没有

1356
00:51:22,880 --> 00:51:24,020
系统实际上会实现你

1357
00:51:24,020 --> 00:51:25,460
只是选择一个并坚持下去，

1358
00:51:25,460 --> 00:51:27,290
因为它会

1359
00:51:27,290 --> 00:51:29,450
服务器端和

1360
00:51:29,450 --> 00:51:31,880
客户端都有太多的工程开销，以至于错过了对这两个方面

1361
00:51:31,880 --> 00:51:35,410
的支持，另一件事要

1362
00:51:35,410 --> 00:51:37,820
指出的是，

1363
00:51:37,820 --> 00:51:39,410
性能将

1364
00:51:39,410 --> 00:51:41,180
取决于您表示字符串的方式而

1365
00:51:41,180 --> 00:51:43,730
不是它 不是在你知道的独立

1366
00:51:43,730 --> 00:51:45,470
于你使用的方法的情况下，

1367
00:51:45,470 --> 00:51:47,450
如果我在做压缩，那么有时

1368
00:51:47,450 --> 00:51:48,590
这会非常好，而其他

1369
00:51:48,590 --> 00:51:51,080
的可能会很糟糕，所以再次

1370
00:51:51,080 --> 00:51:52,730
n 根据

1371
00:51:52,730 --> 00:51:55,040
我们如何设计所有内容，

1372
00:51:55,040 --> 00:51:56,030
我们将使用什么压缩方案以及

1373
00:51:56,030 --> 00:51:57,620
我们正在做的事情，道路服务

1374
00:51:57,620 --> 00:52:00,580
顾问将所有这些事情结合起来，

1375
00:52:00,580 --> 00:52:02,990
你会知道会影响性能吗？

1376
00:52:02,990 --> 00:52:06,500
好吧，让我们只展示

1377
00:52:06,500 --> 00:52:10,250
两个快速图表，所以他们在纸上做了两个

1378
00:52:10,250 --> 00:52:11,450
实验，第一个

1379
00:52:11,450 --> 00:52:13,640
是我们要测量

1380
00:52:13,640 --> 00:52:15,650
发送一个元组

1381
00:52:15,650 --> 00:52:17,870
所需的时间和发送一百万个元组所需的时间，所以

1382
00:52:17,870 --> 00:52:19,760
他们是 将

1383
00:52:19,760 --> 00:52:23,030
在没有 gzip 的情况下与我的续集进行比较，并启用了自己

1384
00:52:23,030 --> 00:52:25,670
的 DVD Oracle MongoDB db2 和 hive，

1385
00:52:25,670 --> 00:52:27,740
尽管 MongoDB 不支持

1386
00:52:27,740 --> 00:52:28,790
续集，

1387
00:52:28,790 --> 00:52:31,970
但它们仍然支持 OTP ODBC 驱动程序，所以

1388
00:52:31,970 --> 00:52:35,540
这有效，所以你

1389
00:52:35,540 --> 00:52:39,260
看到的是 hive 实际上是 可以

1390
00:52:39,260 --> 00:52:41,630
在这里做最糟糕的事情，然后是 db2，但是

1391
00:52:41,630 --> 00:52:43,640
这里的其他人大致

1392
00:52:43,640 --> 00:52:45,070


1393
00:52:45,070 --> 00:52:46,730
相同，

1394
00:52:46,730 --> 00:52:48,530
尽管 Moni 是这些人中

1395
00:52:48,530 --> 00:52:49,850
唯一一个进行文本编码的人

1396
00:52:49,850 --> 00:52:51,710
，而其他一切都在进行二进制

1397
00:52:51,710 --> 00:52:53,930
编码并且它仍然优于

1398
00:52:53,930 --> 00:52:55,490
其他编码，因为进行二进制编码

1399
00:52:55,490 --> 00:52:59,150
有一个 dB 的情况 - 我不知道为什么

1400
00:52:59,150 --> 00:53:02,270
这很慢，我们将在下一张幻灯片中看到

1401
00:53:02,270 --> 00:53:03,920
它更明显，但至少他的

1402
00:53:03,920 --> 00:53:05,390
oracle 和 db2 他们有自己的

1403
00:53:05,390 --> 00:53:07,760
客户端

1404
00:53:07,760 --> 00:53:09,140
发送到服务器并说嘿我得到

1405
00:53:09,140 --> 00:53:10,910
了你刚刚发送给我的确认消息给我发送更多并

1406
00:53:10,910 --> 00:53:12,320
认为这

1407
00:53:12,320 --> 00:53:15,140
在 TCP tcp 之上有点多余但你知道也许有

1408
00:53:15,140 --> 00:53:16,520
一天你在那种

1409
00:53:16,520 --> 00:53:20,840
额外的额外 安全权额外安全

1410
00:53:20,840 --> 00:53:23,720
teenis然后hive我说只是

1411
00:53:23,720 --> 00:53:28,700
发送更多的数据所以对于这个再次

1412
00:53:28,700 --> 00:53:30,440
这一次只有一个元组

1413
00:53:30,440 --> 00:53:32,510
所以避免所有开销的方法就像

1414
00:53:32,510 --> 00:53:34,850
解析sequel语句和

1415
00:53:34,850 --> 00:53:36,410
运行优化器并运行他

1416
00:53:36,410 --> 00:53:37,820
查询他们将多次运行查询

1417
00:53:37,820 --> 00:53:39,619
，然后让

1418
00:53:39,619 --> 00:53:42,380
保姆缓存至少查询计划

1419
00:53:42,380 --> 00:53:43,580
并不是全部相信查询计划

1420
00:53:43,580 --> 00:53:44,990
所以这只是说明

1421
00:53:44,990 --> 00:53:47,450
构建我们通过线路发送的数据包的开销是

1422
00:53:47,450 --> 00:53:49,850
多少 rotocol

1423
00:53:49,850 --> 00:53:51,170
在下一个实验中，他们会发

1424
00:53:51,170 --> 00:53:54,020
回一百万个元组，所以前

1425
00:53:54,020 --> 00:53:56,480
两个结果要指出的是

1426
00:53:56,480 --> 00:53:58,940
我的续集 所以这是我的 所以这是

1427
00:53:58,940 --> 00:54:01,160
当我们沿着 x 轴

1428
00:54:01,160 --> 00:54:03,020
改变时 这些网络

1429
00:54:03,020 --> 00:54:04,850
消息的延迟，所以当你的网络真的

1430
00:54:04,850 --> 00:54:07,940
很快到这一点时，

1431
00:54:07,940 --> 00:54:09,890
没有任何压缩的常规我的续集协议

1432
00:54:09,890 --> 00:54:13,220
会更好，但

1433
00:54:13,220 --> 00:54:14,720
一旦网络明显变慢，

1434
00:54:14,720 --> 00:54:18,260
你就会知道做额外的 CPU 工作

1435
00:54:18,260 --> 00:54:20,900
来实际压缩数据

1436
00:54:20,900 --> 00:54:23,240
在这种情况下，我的

1437
00:54:23,240 --> 00:54:25,490
压缩秘诀得到了回报，它总是获得相同的

1438
00:54:25,490 --> 00:54:27,109
性能，因为这里的主要成本

1439
00:54:27,109 --> 00:54:30,619
是它为

1440
00:54:30,619 --> 00:54:32,600
曲线中的所有其他曲线调用 gzip

1441
00:54:32,600 --> 00:54:34,550
显然当

1442
00:54:34,550 --> 00:54:36,140
它们更快时

1443
00:54:36,140 --> 00:54:37,550
更快他们做得更好但它并没有

1444
00:54:37,550 --> 00:54:40,220
网络变慢他们做得更糟

1445
00:54:40,220 --> 00:54:41,869
你指出哪个引擎虽然在这里

1446
00:54:41,869 --> 00:54:44,630
是Oracle是我的续集之后第二快的引擎，

1447
00:54:44,630 --> 00:54:46,369
当网络

1448
00:54:46,369 --> 00:54:48,980
很快但是 然后在这里它实际上

1449
00:54:48,980 --> 00:54:52,070
最终成为最慢的一个我不

1450
00:54:52,070 --> 00:54:53,990
记得论文是怎么说的，为什么会

1451
00:54:53,990 --> 00:54:56,390
这样我的意思是 db2 这里是一个

1452
00:54:56,390 --> 00:54:58,100
数量级的类似建议

1453
00:54:58,100 --> 00:55:00,020
图 db2 就像做

1454
00:55:00,020 --> 00:55:01,490
五个

1455
00:55:01,490 --> 00:55:04,460
一样 那里的 500 和 Oracle 左右的

1456
00:55:04,460 --> 00:55:07,640
明信片就在它下面大约 1050

1457
00:55:07,640 --> 00:55:10,339
秒，所以这只是一个例子，

1458
00:55:10,339 --> 00:55:11,750
比如他们发送的确认消息是如何

1459
00:55:11,750 --> 00:55:13,280


1460
00:55:13,280 --> 00:55:15,079
在网络缓慢的情况下超级低效的，他们

1461
00:55:15,079 --> 00:55:17,030
无法发送下一批 元组

1462
00:55:17,030 --> 00:55:18,589
给客户端，直到你得到第二

1463
00:55:18,589 --> 00:55:21,220
次往返并说嘿给我发温暖

1464
00:55:21,220 --> 00:55:26,589
好吧所以任何关于这个的问题是的

1465
00:55:29,170 --> 00:55:32,569
对不起这个像这里为什么

1466
00:55:32,569 --> 00:55:34,760
这比这快因为我

1467
00:55:34,760 --> 00:55:37,099
站在一百万两颗子弹中，

1468
00:55:37,099 --> 00:55:38,359
我是 会考虑它的确切大小，

1469
00:55:38,359 --> 00:55:40,130
但是当网络非常快时，我

1470
00:55:40,130 --> 00:55:41,180
不想付出代价来

1471
00:55:41,180 --> 00:55:42,680
压缩它，我只想尽快将它推

1472
00:55:42,680 --> 00:55:44,960
到电线上，而

1473
00:55:44,960 --> 00:55:47,569
这里的主要成本是 CPU

1474
00:55:47,569 --> 00:55:48,680
开销 压缩和

1475
00:55:48,680 --> 00:55:50,690
解压，所以这就是为什么它

1476
00:55:50,690 --> 00:55:52,849
基本上是扁平的，所以无论它们有多慢

1477
00:55:52,849 --> 00:55:55,220
，你都

1478
00:55:55,220 --> 00:55:57,859
不会从通过较慢的网络发送较少数据中获得的好处

1479
00:55:57,859 --> 00:55:59,510
被计算成本所抵消，

1480
00:55:59,510 --> 00:56:02,150
现在他们

1481
00:56:02,150 --> 00:56:03,859
可以使用 snappy，这

1482
00:56:03,859 --> 00:56:05,660
可能会改变 曲线有点，但

1483
00:56:05,660 --> 00:56:07,880
基本上这基本上是在说，

1484
00:56:07,880 --> 00:56:09,230
为什么我首先强调这一点是

1485
00:56:09,230 --> 00:56:11,089
当网络速度很快时，您

1486
00:56:11,089 --> 00:56:12,260
不想进行任何压缩，这些曲线会

1487
00:56:12,260 --> 00:56:14,270
尽可能快地推出数据，但因为它们

1488
00:56:14,270 --> 00:56:16,640
永远不会变慢，您会这样做 想尽快做到这

1489
00:56:16,640 --> 00:56:18,290
一点 说好的 在什么情况

1490
00:56:18,290 --> 00:56:19,579
下网络会成为猎人

1491
00:56:19,579 --> 00:56:20,900
毫秒 如果我在

1492
00:56:20,900 --> 00:56:22,339
不同的数据中心运行 应用程序

1493
00:56:22,339 --> 00:56:24,079
服务器运行一个数据中心 数据

1494
00:56:24,079 --> 00:56:25,730
服务器运行另一个然后你

1495
00:56:25,730 --> 00:56:27,050
知道我可以起床 到一百毫秒的

1496
00:56:27,050 --> 00:56:31,000
延迟是的，

1497
00:56:45,099 --> 00:56:47,599
你的陈述是

1498
00:56:47,599 --> 00:56:49,190
他们不应该改变带宽

1499
00:56:49,190 --> 00:56:51,650
而不是延迟，因为我

1500
00:56:51,650 --> 00:56:53,030
会将它相互关联，但

1501
00:56:53,030 --> 00:56:57,530
我认为 比如像db2

1502
00:56:57,530 --> 00:56:59,589
一样发送

1503
00:56:59,589 --> 00:57:01,670
那些不是带宽问题的确认消息是

1504
00:57:01,670 --> 00:57:32,569
一周是的你声明让

1505
00:57:32,569 --> 00:57:35,480
我们离线但很好因为我不完全

1506
00:57:35,480 --> 00:57:38,660
知道我记得确切的

1507
00:57:38,660 --> 00:57:40,940
设置是在像 我

1508
00:57:40,940 --> 00:57:42,230
认为客户必须得到结果并

1509
00:57:42,230 --> 00:57:43,400
立即将其扔掉，但在这种

1510
00:57:43,400 --> 00:57:46,630
情况下，客户在这里也可以衡量在客户端解压的成本，

1511
00:57:46,630 --> 00:57:48,680


1512
00:57:48,680 --> 00:57:50,060


1513
00:57:50,060 --> 00:57:54,500
所以我认为这就是为什么离开你

1514
00:57:54,500 --> 00:57:55,490
可以' 不隐藏它 我认为这就是为什么

1515
00:57:55,490 --> 00:58:00,069
延迟很重要 等待最小带宽

1516
00:58:00,069 --> 00:58:05,599
但离线 好的我们有 20 分钟

1517
00:58:05,599 --> 00:58:10,940
嗯我实际上要跳过复制

1518
00:58:10,940 --> 00:58:12,730
协议 我想我们已经在

1519
00:58:12,730 --> 00:58:15,290
介绍类中介绍了这一点 我们基本上已经在介绍类中介绍

1520
00:58:15,290 --> 00:58:17,540
了这一点 不得不说的

1521
00:58:17,540 --> 00:58:23,119
是，这与

1522
00:58:23,119 --> 00:58:24,109
我们上一堂课讨论的内容有关，例如

1523
00:58:24,109 --> 00:58:26,390
日志记录和恢复，有时您进行

1524
00:58:26,390 --> 00:58:27,980
逻辑日志记录，有时您进行

1525
00:58:27,980 --> 00:58:30,380
正确的物理日志记录，这是一个

1526
00:58:30,380 --> 00:58:32,930
内部协议 数据系统

1527
00:58:32,930 --> 00:58:34,579
使用的可以与

1528
00:58:34,579 --> 00:58:35,990
您用来与之通信的客户端协议分开

1529
00:58:35,990 --> 00:58:37,839
，以被视为 JDBC

1530
00:58:37,839 --> 00:58:40,730
以及您可以

1531
00:58:40,730 --> 00:58:42,530
再次执行的一些优化以进行压缩和其他

1532
00:58:42,530 --> 00:58:44,750
事情，或者您如何批量处理日志

1533
00:58:44,750 --> 00:58:46,790
记录取决于 一致性

1534
00:58:46,790 --> 00:58:48,319
保证了你对

1535
00:58:48,319 --> 00:58:51,500
你的系统的需求，这样你就

1536
00:58:51,500 --> 00:58:52,580
没有什么可说

1537
00:58:52,580 --> 00:58:55,130
的了，但是当你告诉

1538
00:58:55,130 --> 00:58:57,590
我离线时，如果你也想要，

1539
00:58:57,590 --> 00:58:59,720
那么就可以快速完成，

1540
00:58:59,720 --> 00:59:01,250
因为这 是我认为我

1541
00:59:01,250 --> 00:59:03,160
不会让

1542
00:59:03,160 --> 00:59:07,180
你们在实验中接触到

1543
00:59:07,180 --> 00:59:10,369
来自鸭子电视人的论文，

1544
00:59:10,369 --> 00:59:11,990
就像他们的优点一样，他们

1545
00:59:11,990 --> 00:59:14,180
改变了网络延迟，但这

1546
00:59:14,180 --> 00:59:15,619
并不是你们唯一的瓶颈

1547
00:59:15,619 --> 00:59:17,660
他们的网络层本身

1548
00:59:17,660 --> 00:59:18,710
并不是唯一的底层，就像你

1549
00:59:18,710 --> 00:59:20,240
在你的应用程序和数据库

1550
00:59:20,240 --> 00:59:22,150
服务器中与客户端通信的唯一底层，

1551
00:59:22,150 --> 00:59:25,010
通常操作系统会导致

1552
00:59:25,010 --> 00:59:27,680
问题，特别是如果 你正在做

1553
00:59:27,680 --> 00:59:28,849
橡树应用程序，你正在发送

1554
00:59:28,849 --> 00:59:31,010
大量小数据包而不是你知道

1555
00:59:31,010 --> 00:59:33,470
巨大的东西的巨大缓冲区 之所以昂贵的原因

1556
00:59:33,470 --> 00:59:34,520
是因为

1557
00:59:34,520 --> 00:59:36,080
与操作系统通信

1558
00:59:36,080 --> 00:59:37,369
对我们来说总是一场噩梦，因为数据

1559
00:59:37,369 --> 00:59:39,109
系统对，它是我们的敌人，我们需要它

1560
00:59:39,109 --> 00:59:40,900
来生存，但它总是妨碍

1561
00:59:40,900 --> 00:59:44,530
我们，所以如果我们要躺在 OS TCP 上，请

1562
00:59:44,530 --> 00:59:47,420
原谅我的 tcp/ip 堆栈，那么我们必须

1563
00:59:47,420 --> 00:59:48,920


1564
00:59:48,920 --> 00:59:50,359
通过中断处理内部区域的上下文切换

1565
00:59:50,359 --> 00:59:52,040
才能获得 你知道

1566
00:59:52,040 --> 00:59:53,240
我们现在有一个数据包，我们想要

1567
00:59:53,240 --> 00:59:55,760
将数据从缓冲区

1568
00:59:55,760 --> 00:59:58,160
和数据库服务器复制到我们发送到内核的 tcp/ip

1569
00:59:58,160 --> 00:59:59,960
缓冲区中，

1570
00:59:59,960 --> 01:00:02,270
这对我来说很昂贵，当然

1571
01:00:02,270 --> 01:00:03,890
操作系统会 维护自己的锁存器以

1572
01:00:03,890 --> 01:00:05,570
保护其内部数据结构，

1573
01:00:05,570 --> 01:00:07,310
如果我们

1574
01:00:07,310 --> 01:00:08,390
有很多线程试图同时写入

1575
01:00:08,390 --> 01:00:11,690
最新数据，这些锁存器会妨碍我们，所以

1576
01:00:11,690 --> 01:00:13,280
避免这一切的一种方法是所谓的

1577
01:00:13,280 --> 01:00:15,440
内核绕过方法 ds 这里的想法

1578
01:00:15,440 --> 01:00:16,730
是我们将拥有

1579
01:00:16,730 --> 01:00:18,170
我们将要实施的数据库系统，以便

1580
01:00:18,170 --> 01:00:20,599
我们能够通过绕过操作系统将数据

1581
01:00:20,599 --> 01:00:22,970
直接写入 NIC 到您

1582
01:00:22,970 --> 01:00:26,869
知道的网络设备的实际港口

1583
01:00:26,869 --> 01:00:30,410
对，所以

1584
01:00:30,410 --> 01:00:31,790
我们的想法是我们现在可以有一个

1585
01:00:31,790 --> 01:00:35,089
数据缓冲区，我们可以

1586
01:00:35,089 --> 01:00:36,470
用查询的结果或我们

1587
01:00:36,470 --> 01:00:37,700
想要使用我们的有线协议发送的数据包填充数据，

1588
01:00:37,700 --> 01:00:39,680
但该缓冲区现在

1589
01:00:39,680 --> 01:00:41,960
实际上位于 NIC 中，因此 我们

1590
01:00:41,960 --> 01:00:43,820
不需要做任何复制来将它晒黑到

1591
01:00:43,820 --> 01:00:46,010
硬件上，港口可以填满一个

1592
01:00:46,010 --> 01:00:47,119
缓冲区，我们说好了，我们已经完成

1593
01:00:47,119 --> 01:00:48,770
了，然后现在我们可以见到李

1594
01:00:48,770 --> 01:00:50,750
了，通过电线发送我们的 消息，

1595
01:00:50,750 --> 01:00:52,460
所以操作系统根本不会妨碍，

1596
01:00:52,460 --> 01:00:55,700
所以有两种方法可以做到这一点

1597
01:00:55,700 --> 01:00:57,230
，数据平面开发工具包

1598
01:00:57,230 --> 01:00:58,880
和 DP DK，然后

1599
01:00:58,880 --> 01:01:01,070
通过我们的 DMA 或远程直接内存

1600
01:01:01,070 --> 01:01:03,920
访问，所以它们不完全是 哈里森不是

1601
01:01:03,920 --> 01:01:05,210
真正的苹果对苹果，

1602
01:01:05,210 --> 01:01:07,610
因为就像 DB DK 是一个

1603
01:01:07,610 --> 01:01:10,760
库，你可以 最初从英特尔下载

1604
01:01:10,760 --> 01:01:13,760
，提供这种内核绕过

1605
01:01:13,760 --> 01:01:17,030
方法，我们的 DMA 是一类

1606
01:01:17,030 --> 01:01:19,130
硬件和软件库，您

1607
01:01:19,130 --> 01:01:21,650
可以为您的系统获取，因此有很多

1608
01:01:21,650 --> 01:01:23,360
，因为

1609
01:01:23,360 --> 01:01:25,040
您可以下载一种称为 DB DK 的特定内容，

1610
01:01:25,040 --> 01:01:27,830
但那是 一个库，没有像

1611
01:01:27,830 --> 01:01:29,450
已经调用的单个库，你

1612
01:01:29,450 --> 01:01:32,620
可以下载它是一个更广泛的联系，

1613
01:01:32,620 --> 01:01:36,520
所以对于 DVD K，这里的想法是

1614
01:01:36,520 --> 01:01:38,660
它只是英特尔

1615
01:01:38,660 --> 01:01:40,400
最初开发的地方，以帮助

1616
01:01:40,400 --> 01:01:42,020
他们销售英特尔的硬件，但

1617
01:01:42,020 --> 01:01:43,970
他们最终捐赠了

1618
01:01:43,970 --> 01:01:46,550
Linux 基金会的软件和这里的想法

1619
01:01:46,550 --> 01:01:47,960
是，它是一堆

1620
01:01:47,960 --> 01:01:51,440
API 调用库，允许我们

1621
01:01:51,440 --> 01:01:53,300
直接访问 NIC 我们可以说给我们一个

1622
01:01:53,300 --> 01:01:54,770
位于 NIC 上的缓冲区，

1623
01:01:54,770 --> 01:01:57,560
然后我们可以填充它，然后我们可以 然后

1624
01:01:57,560 --> 01:01:59,090
告诉 NIC 继续将我们的

1625
01:01:59,090 --> 01:02:00,800
数据写入这个位置，所以 ron

1626
01:02:00,800 --> 01:02:02,540
把这个 nick 当作一个

1627
01:02:02,540 --> 01:02:07,700
裸机设备是的这个问题

1628
01:02:07,700 --> 01:02:09,490
实际上缓冲区在哪里 l 我

1629
01:02:09,490 --> 01:02:12,530
实际上不知道我的意思是 NIC 有

1630
01:02:12,530 --> 01:02:16,130
自己的内存缓冲区 II 我认为你可以

1631
01:02:16,130 --> 01:02:18,290
我想当你说给我一个 2d PK

1632
01:02:18,290 --> 01:02:20,690
当你得到一个缓冲区时我的意思是当

1633
01:02:20,690 --> 01:02:22,100
你乔希 - 你是对的，我认为 存在

1634
01:02:22,100 --> 01:02:24,140
于 CPU 缓存中，因为它必须这样做，

1635
01:02:24,140 --> 01:02:25,070
因为那是您写入所有内容的时候，

1636
01:02:25,070 --> 01:02:26,810
但是当它被刷新时，它确实

1637
01:02:26,810 --> 01:02:28,310
会被刷新 2d Ram 它会被刷新

1638
01:02:28,310 --> 01:02:32,140
到颈部 我认为这就是它的工作方式，

1639
01:02:32,950 --> 01:02:40,010
就像 NIC 好问题哦，是的

1640
01:02:40,010 --> 01:02:42,230
，如果我 如果我的进程正在

1641
01:02:42,230 --> 01:02:45,260
写入由 NIC 支持的缓存行，

1642
01:02:45,260 --> 01:02:47,540
如果我得到一个上下文

1643
01:02:47,540 --> 01:02:49,130
，然后被刷新，我认为是的，

1644
01:02:49,130 --> 01:02:52,970
就像操作系统一样，操作系统不控制

1645
01:02:52,970 --> 01:02:54,620
任何这些数据移动，它是 这是

1646
01:02:54,620 --> 01:02:55,970
港口实际上

1647
01:02:55,970 --> 01:02:58,940
为我们和英特尔提供了这个功能，

1648
01:02:58,940 --> 01:02:59,990
他们在他们的世界里，他们试图

1649
01:02:59,990 --> 01:03:02,150
销售硬件，以便他们

1650
01:03:02,150 --> 01:03:03,110
让你更容易地向他们的

1651
01:03:03,110 --> 01:03:06,650
硬件写入我对于 DVD KI 并不意味着

1652
01:03:06,650 --> 01:03:09,710
直到你知道它来自英特尔，但

1653
01:03:09,710 --> 01:03:11,210
现在它反对这个有这个

1654
01:03:11,210 --> 01:03:13,430
b 其他供应商可以

1655
01:03:13,430 --> 01:03:15,260
实现的roader 东西我不知道你是否

1656
01:03:15,260 --> 01:03:16,400
可以用其他任何

1657
01:03:16,400 --> 01:03:18,950
不是我们的 Intel Nick 的东西来实现这个，

1658
01:03:18,950 --> 01:03:21,589
所以再次没有数据复制，因为

1659
01:03:21,589 --> 01:03:22,970
我们可以将它们写入

1660
01:03:22,970 --> 01:03:25,819
脖子上的缓冲区并且没有系统

1661
01:03:25,819 --> 01:03:27,260
调用 发送任何消息，我们

1662
01:03:27,260 --> 01:03:28,819
基本上是直接从我们的

1663
01:03:28,819 --> 01:03:30,470
数据库到港口，并说

1664
01:03:30,470 --> 01:03:32,630
将我们的消息发送到这个位置 OS

1665
01:03:32,630 --> 01:03:34,309
根本不涉及它

1666
01:03:34,309 --> 01:03:38,029
太棒了，尽管听起来很神奇，但

1667
01:03:38,029 --> 01:03:39,740
我只有一个数据库系统” 我

1668
01:03:39,740 --> 01:03:41,960
知道实际上使用了这个，它

1669
01:03:41,960 --> 01:03:44,420
被称为 Scalia D 梁，所以他们实现了

1670
01:03:44,420 --> 01:03:47,029
这个称为 C 星的框架，这是一个

1671
01:03:47,029 --> 01:03:49,160
使用 DB DK 的网络框架

1672
01:03:49,160 --> 01:03:51,529
，然后 Scalia DB 建立在它之上

1673
01:03:51,529 --> 01:03:51,799


1674
01:03:51,799 --> 01:03:54,230
Scalia DB 是一个热烈的掌声免费

1675
01:03:54,230 --> 01:03:56,180
实现 Cassandra

1676
01:03:56,180 --> 01:03:59,450
Cassandra 真的是用 Java 编写的，

1677
01:03:59,450 --> 01:04:02,240
现在真的是用 C++ 编写的，并使用 DB

1678
01:04:02,240 --> 01:04:07,420
DK 来获得更快

1679
01:04:07,420 --> 01:04:09,769


1680
01:04:09,769 --> 01:04:11,869
的消息 你可以

1681
01:04:11,869 --> 01:04:14,390
在 ec2 上获得支持 DB

1682
01:04:14,390 --> 01:04:16,309
DK 的实例，但你并不

1683
01:04:16,309 --> 01:04:17,720
知道我们在这个类上运行的那些便宜的实例，

1684
01:04:17,720 --> 01:04:20,809
他们不支持这个，另一个

1685
01:04:20,809 --> 01:04:23,180
棘手的事情也是这听起来

1686
01:04:23,180 --> 01:04:25,400
很棒，它是构成性的，但

1687
01:04:25,400 --> 01:04:28,700
有人 曾经在我的推特上发

1688
01:04:28,700 --> 01:04:31,460
了一条关于使用 SPD k 是存储的 这

1689
01:04:31,460 --> 01:04:34,069
是数据 就像这条评论 我认为

1690
01:04:34,069 --> 01:04:35,839
这太棒了 好像这

1691
01:04:35,839 --> 01:04:38,119
将是一个非常好的主意 但是然后

1692
01:04:38,119 --> 01:04:39,680
当你真正开始推动它时，

1693
01:04:39,680 --> 01:04:42,140
它就是所有这些细微差别 它让

1694
01:04:42,140 --> 01:04:43,849
你失望了，它不是你

1695
01:04:43,849 --> 01:04:45,049
可以像在库中弹出链接一样的东西

1696
01:04:45,049 --> 01:04:46,880
，你会自动得到它，你

1697
01:04:46,880 --> 01:04:48,140
必须重写你的数据库服务器

1698
01:04:48,140 --> 01:04:50,059
应用程序或数据库服务器才能使用

1699
01:04:50,059 --> 01:04:52,039
这个权利，这可能是一个重大的

1700
01:04:52,039 --> 01:04:54,230
变化 在 Scalia TB 的情况下，

1701
01:04:54,230 --> 01:04:56,390
它们建立在 C 星之上，因此所有

1702
01:04:56,390 --> 01:04:59,210
员工都将 DVD K 的复杂性

1703
01:04:59,210 --> 01:05:01,250
隐藏在封面下，

1704
01:05:01,250 --> 01:05:04,279
因此正如我所说，因为您的

1705
01:05:04,279 --> 01:05:04,730
服务器

1706
01:05:04,730 --> 01:05:07,009
我没有多少大卫小节使用

1707
01:05:07,009 --> 01:05:11,930
这个 另一个是 RDMA，

1708
01:05:11,930 --> 01:05:15,680
这里的想法是，如果我有多台

1709
01:05:15,680 --> 01:05:20,839
机器，我可以让

1710
01:05:20,839 --> 01:05:24,109
客户端或服务器写入和

1711
01:05:24,109 --> 01:05:25,549
读写该远程机器的内存位置，

1712
01:05:25,549 --> 01:05:28,490
所以你的想法

1713
01:05:28,490 --> 01:05:30,710
是 就像我的应用程序服务器，如果我的

1714
01:05:30,710 --> 01:05:32,240
数据库服务器房间的客户端驱动程序是

1715
01:05:32,240 --> 01:05:32,760


1716
01:05:32,760 --> 01:05:35,370
新的

1717
01:05:35,370 --> 01:05:38,160
数据和数据库服务器上的内存布局，那么

1718
01:05:38,160 --> 01:05:40,890
现在不是发送 siegel 查询，而是

1719
01:05:40,890 --> 01:05:43,380
执行解析，

1720
01:05:43,380 --> 01:05:46,410
然后呈现我的结果 如果我

1721
01:05:46,410 --> 01:05:48,540
知道数据是如何布局的，我

1722
01:05:48,540 --> 01:05:51,090
可以直接读入内存并

1723
01:05:51,090 --> 01:05:53,030
获取日期得到我想要的结果

1724
01:05:53,030 --> 01:05:55,170
，这实际上非常困难，因为

1725
01:05:55,170 --> 01:05:56,910
现在如果我开始移动它们，

1726
01:05:56,910 --> 01:05:57,810
一切都会变得

1727
01:05:57,810 --> 01:06:03,030
一团糟，所以唯一的

1728
01:06:03,030 --> 01:06:04,380
我所知道的两个系统实际上使用了我们的

1729
01:06:04,380 --> 01:06:06,870
DMA 最著名的一个是 Oracle RAC

1730
01:06:06,870 --> 01:06:08,430


1731
01:06:08,430 --> 01:06:12,900


1732
01:06:12,900 --> 01:06:15,660


1733
01:06:15,660 --> 01:06:17,400


1734
01:06:17,400 --> 01:06:19,920
在这种情况下，所有 okhla 都专门设计了这个

1735
01:06:19,920 --> 01:06:22,170
系统来

1736
01:06:22,170 --> 01:06:25,350
使用我们的 DMA 场来处理共享内存缓冲区

1737
01:06:25,350 --> 01:06:26,850
，这是 Microsoft Research 的分布式事务系统，

1738
01:06:26,850 --> 01:06:28,290
我认为它

1739
01:06:28,290 --> 01:06:30,480
实际上不是在运行生产，但

1740
01:06:30,480 --> 01:06:32,280
我们的问题很棘手 DMA 就像您

1741
01:06:32,280 --> 01:06:34,440
不知道是否有人正在访问

1742
01:06:34,440 --> 01:06:36,870
您的内存，或者您知道或正确写入您的

1743
01:06:36,870 --> 01:06:39,330
内存，因为这一切都是

1744
01:06:39,330 --> 01:06:40,350
通过硬件处理的，它对

1745
01:06:40,350 --> 01:06:41,940
您来说都是从操作系统中隐藏起来的，所以

1746
01:06:41,940 --> 01:06:44,700
我不会被打扰说哦有人写信

1747
01:06:44,700 --> 01:06:47,820
给 我不知道这个位置的内存，

1748
01:06:47,820 --> 01:06:50,280
所以为了正确地进行事务

1749
01:06:50,280 --> 01:06:52,590
并在您知道一台

1750
01:06:52,590 --> 01:06:53,730
服务器运行到内存或另一台

1751
01:06:53,730 --> 01:06:55,200
服务器时进行农场，他们基本上必须

1752
01:06:55,200 --> 01:06:57,240
通过我们的 DMA 进行四阶段提交，这

1753
01:06:57,240 --> 01:06:58,830
更快，但它是四阶段 承诺

1754
01:06:58,830 --> 01:07:00,120
它会说好的 我已经做了这些

1755
01:07:00,120 --> 01:07:04,880
更改 你同意吗 所以

1756
01:07:04,880 --> 01:07:07,830
再次出于这个原因你不会认为

1757
01:07:07,830 --> 01:07:09,290
你会只在内部使用我们的 DMA

1758
01:07:09,290 --> 01:07:11,610
进行通信

1759
01:07:11,610 --> 01:07:13,530
同一个数据库实例的服务器之间我

1760
01:07:13,530 --> 01:07:15,210
不知道不

1761
01:07:15,210 --> 01:07:17,460
，据我所知，

1762
01:07:17,460 --> 01:07:20,760
从客户端到服务器的 DMA 没有任何工作，

1763
01:07:20,760 --> 01:07:23,070
因为如果内存

1764
01:07:23,070 --> 01:07:25,290
在它周围移动，那么你就

1765
01:07:25,290 --> 01:07:28,860
搞砸了 我想让你快速抽奖，

1766
01:07:28,860 --> 01:07:31,110
所以这

1767
01:07:31,110 --> 01:07:34,020
是我以前的一个学生在荣誉系统上做的一个实验，

1768
01:07:34,020 --> 01:07:37,200
我们只是想

1769
01:07:37,200 --> 01:07:40,230
看看我们能多快从 TPC 的 TPC 中获取 7 GB 的元组，

1770
01:07:40,230 --> 01:07:46,170


1771
01:07:46,170 --> 01:07:47,789
看看协议是 客户端

1772
01:07:47,789 --> 01:07:50,069
实际上正在读入内存 它

1773
01:07:50,069 --> 01:07:52,559
知道布局开始的位置以及开始

1774
01:07:52,559 --> 01:07:53,730
和停止

1775
01:07:53,730 --> 01:07:55,260
它想要读取的所有数据块的正义 这有点像

1776
01:07:55,260 --> 01:07:57,140
我们能多快地把所有东西都拿出来所以

1777
01:07:57,140 --> 01:07:59,369
这是一个低端，如果你有的话

1778
01:07:59,369 --> 01:08:00,720
发布图表，您实际上在其中迭代

1779
01:08:00,720 --> 01:08:01,799
并浏览了帖子以及相当多的

1780
01:08:01,799 --> 01:08:05,190
协议，如果您然后按照鸭子 DB

1781
01:08:05,190 --> 01:08:06,869
人员在您阅读的关于矢量化您发回的 Polacks 的论文中的假设进行操作，

1782
01:08:06,869 --> 01:08:08,549


1783
01:08:08,549 --> 01:08:11,010
您可以做得更好一点，航空

1784
01:08:11,010 --> 01:08:14,760
飞行是 G RP  C 实现或 RPC

1785
01:08:14,760 --> 01:08:16,319


1786
01:08:16,319 --> 01:08:19,770
实现从 Aero 人员那里获取数据的滚动图，但

1787
01:08:19,770 --> 01:08:21,600
RTA 就像准系统一样，如果我

1788
01:08:21,600 --> 01:08:23,149
确切地知道我想要的内存地址

1789
01:08:23,149 --> 01:08:25,469
并且我可以跳到行机器上的那个位置

1790
01:08:25,469 --> 01:08:26,880
并获得所有 返回我需要的数据，

1791
01:08:26,880 --> 01:08:29,100
所以这再次向您展示了您的

1792
01:08:29,100 --> 01:08:30,238


1793
01:08:30,238 --> 01:08:32,399
性能，如果您不

1794
01:08:32,399 --> 01:08:33,988
担心通过

1795
01:08:33,988 --> 01:08:36,738
任何其他任何其他 davis 服务器软件，您可以获得一个数量级的性能改进，

1796
01:08:36,738 --> 01:08:39,049


1797
01:08:39,049 --> 01:08:40,948
好吧，所以这有点匆忙

1798
01:08:40,948 --> 01:08:43,529
结束，但我已经涵盖了大部分内容，

1799
01:08:43,529 --> 01:08:45,149
因此网络

1800
01:08:45,149 --> 01:08:47,488
协议是我们

1801
01:08:47,488 --> 01:08:49,109
可以利用的东西，但我认为有

1802
01:08:49,109 --> 01:08:50,759
很多改进性能的机会

1803
01:08:50,759 --> 01:08:52,799
，这就是鸭子

1804
01:08:52,799 --> 01:08:54,810
TB 人员展示的问题所在 尽管您

1805
01:08:54,810 --> 01:08:56,810
在野外拥有所有这些驱动程序，

1806
01:08:56,810 --> 01:08:59,880
并且在某些方面现在协议

1807
01:08:59,880 --> 01:09:02,069
是一成不变的，这可能是一个重大

1808
01:09:02,069 --> 01:09:05,189
变化，可以回去让每个人都

1809
01:09:05,189 --> 01:09:06,479
链接永远不会发生的新库，

1810
01:09:06,479 --> 01:09:08,219
但现在如果您 你想要

1811
01:09:08,219 --> 01:09:10,649
更新你的协议并支持更多

1812
01:09:10,649 --> 01:09:12,569
这些优化中的一些你

1813
01:09:12,569 --> 01:09:14,670
本质上需要同时支持这两个因为

1814
01:09:14,670 --> 01:09:15,630
你永远不知道客户端什么时候会

1815
01:09:15,630 --> 01:09:17,009
出现并与旧

1816
01:09:17,009 --> 01:09:21,179
协议连接一些外部断路器告诉

1817
01:09:21,179 --> 01:09:22,529
我他们在构建时

1818
01:09:22,529 --> 01:09:24,060
他们

1819
01:09:24,060 --> 01:09:25,198
花了很多时间单独做一件大事，因为他们

1820
01:09:25,198 --> 01:09:27,210
想要与 Postgres 兼容，其中一个重要的事情是

1821
01:09:27,210 --> 01:09:28,799
他们基本上找到了

1822
01:09:28,799 --> 01:09:30,149
他们可以找到的 Postgres 有线

1823
01:09:30,149 --> 01:09:32,370
协议的每个 jar 文件，并且只运行

1824
01:09:32,370 --> 01:09:33,540
每一个测试 一遍又一遍

1825
01:09:33,540 --> 01:09:35,130
，因为有很多只是

1826
01:09:35,130 --> 01:09:36,929
一次性的差异，尽管他们

1827
01:09:36,929 --> 01:09:38,429
花了很多时间使它只是

1828
01:09:38,429 --> 01:09:40,229
后切 JDBC 兼容，因为它

1829
01:09:40,229 --> 01:09:42,060
非常难，而且

1830
01:09:42,060 --> 01:09:43,139
我们再次看到的内核绕过方法这些是

1831
01:09:43,139 --> 01:09:45,210
避免操作系统的优化

1832
01:09:45,210 --> 01:09:46,229
避免通过前端层，

1833
01:09:46,229 --> 01:09:50,399
但通常

1834
01:09:50,399 --> 01:09:53,790
比实际价值更多

1835
01:09:53,790 --> 01:09:57,600
的工作

1836
01:09:57,600 --> 01:09:58,770
更多 第二个是每个人都将

1837
01:09:58,770 --> 01:09:59,780


1838
01:09:59,780 --> 01:10:02,690
在内存 B+ 树中实现自己的 B+ 树，并且团队

1839
01:10:02,690 --> 01:10:04,700
必须是线程安全的，这意味着您

1840
01:10:04,700 --> 01:10:06,050
必须支持拆分和合并并让

1841
01:10:06,050 --> 01:10:08,780
多个线程同时访问索引，

1842
01:10:08,780 --> 01:10:11,210
因此您需要使用基本的 API

1843
01:10:11,210 --> 01:10:13,220
在实现中插入获取删除环

1844
01:10:13,220 --> 01:10:15,020
和范围扫描您还有两个

1845
01:10:15,020 --> 01:10:18,050
条件插入，其工作方式

1846
01:10:18,050 --> 01:10:20,570
是我使用键调用插入但我也

1847
01:10:20,570 --> 01:10:22,040
向您传递了一个 lambda 函数，该函数

1848
01:10:22,040 --> 01:10:24,170
表示您需要对键进行评估和

1849
01:10:24,170 --> 01:10:26,060
如果该着陆函数的计算结果为

1850
01:10:26,060 --> 01:10:27,230
真，那么您可以插入，

1851
01:10:27,230 --> 01:10:29,240
否则您无法编写这

1852
01:10:29,240 --> 01:10:31,310
基本上就是您所做的，我不

1853
01:10:31,310 --> 01:10:33,560
认为父交换我想在替换

1854
01:10:33,560 --> 01:10:36,500
键值时替换一个值 配对

1855
01:10:36,500 --> 01:10:38,390
而不必进行多次遍历

1856
01:10:38,390 --> 01:10:40,430
或锁定

1857
01:10:40,430 --> 01:10:42,740
支持前向反向范围扫描所需的全部内容，这

1858
01:10:42,740 --> 01:10:44,600
意味着您需要兄弟指针，并且

1859
01:10:44,600 --> 01:10:46,990
你们支持唯一和非唯一

1860
01:10:46,990 --> 01:10:49,610
键，这就是我们要告诉您的全部内容，

1861
01:10:49,610 --> 01:10:51,770
您必须删除 会不会 一些

1862
01:10:51,770 --> 01:10:53,930
一些东西 api 或子文件类

1863
01:10:53,930 --> 01:10:55,940
文件会给你你实际上

1864
01:10:55,940 --> 01:10:57,620
想要如何实现这是爱到

1865
01:10:57,620 --> 01:11:00,170
左到完全取决于你你不能

1866
01:11:00,170 --> 01:11:02,270
做一些愚蠢的事情，比如去拿 STL 地图

1867
01:11:02,270 --> 01:11:04,550
在它前面放一个闩锁 并且只要

1868
01:11:04,550 --> 01:11:06,620
你知道是你的树它必须是

1869
01:11:06,620 --> 01:11:08,930
一个真正的 B+ 树但是

1870
01:11:08,930 --> 01:11:10,310
你想要做的所有优化，比如

1871
01:11:10,310 --> 01:11:13,610
压缩，如果你想做一个

1872
01:11:13,610 --> 01:11:17,210
无锁存器或不锁存器，或者你如何

1873
01:11:17,210 --> 01:11:18,950
实际实现遍历本身

1874
01:11:18,950 --> 01:11:21,590
和 并在

1875
01:11:21,590 --> 01:11:26,810
完全由您决定的节点内进行搜索是的，密钥

1876
01:11:26,810 --> 01:11:28,970
类型将是我们已经为您提供的专业人士，

1877
01:11:28,970 --> 01:11:29,510


1878
01:11:29,510 --> 01:11:32,060
因此它已被模板化，因此

1879
01:11:32,060 --> 01:11:34,130
将有两种类型是压缩滑雪

1880
01:11:34,130 --> 01:11:35,990
和通用密钥只是说 一个

1881
01:11:35,990 --> 01:11:37,460
字节数组，因此您无需编写

1882
01:11:37,460 --> 01:11:39,140
代码来评估我们

1883
01:11:39,140 --> 01:11:40,880
为您处理的所有密钥，并且密钥

1884
01:11:40,880 --> 01:11:44,450
类型是您将知道它的大小，因此

1885
01:11:44,450 --> 01:11:46,190
您只需将其打包成

1886
01:11:46,190 --> 01:11:48,860
您想要的方式 对每个节点进行排序我想

1887
01:11:48,860 --> 01:11:49,880
是什么意思 ng car 并且您

1888
01:11:49,880 --> 01:11:51,200
基本上只是在构建数据

1889
01:11:51,200 --> 01:11:55,310
结构 好吧，这已经是我所说的，

1890
01:11:55,310 --> 01:11:56,450
所以我们将为您提供头

1891
01:11:56,450 --> 01:11:57,980
文件和您必须构建的 API，

1892
01:11:57,980 --> 01:11:59,870
然后所有这些其他废话都会为您做，

1893
01:11:59,870 --> 01:12:00,800
所以您不必' 不用担心如何

1894
01:12:00,800 --> 01:12:01,910
对钥匙进行消毒或进行

1895
01:12:01,910 --> 01:12:04,040
实际比较所有处理的

1896
01:12:04,040 --> 01:12:06,320
事情，所以正如我所说，

1897
01:12:06,320 --> 01:12:07,430
您将要做出一堆设计决策，并且

1898
01:12:07,430 --> 01:12:09,920
没有正确的答案，有时

1899
01:12:09,920 --> 01:12:11,540
它们会是错误的答案，就像我知道的那样

1900
01:12:11,540 --> 01:12:13,469
我应该写开发人员知道的所有内容

1901
01:12:13,469 --> 01:12:16,290
吗，那是错误的，但就像你不需要

1902
01:12:16,290 --> 01:12:17,670
来问我们一样，我

1903
01:12:17,670 --> 01:12:19,620
可以这样做吗？我可以在每一步都这样做，这

1904
01:12:19,620 --> 01:12:21,090
取决于你们决定如何

1905
01:12:21,090 --> 01:12:22,980
真正实现这一点，我 可以

1906
01:12:22,980 --> 01:12:25,290
指出你知道一对夫妇 有一

1907
01:12:25,290 --> 01:12:28,230
本关于 B 加树的书，它不是专门

1908
01:12:28,230 --> 01:12:30,270
针对玛丽 P 加树的，但是有一

1909
01:12:30,270 --> 01:12:31,350
本书和一些论文我可以告诉

1910
01:12:31,350 --> 01:12:32,610
你，这里有一些其他的事情你可以做，

1911
01:12:32,610 --> 01:12:35,780
以可能使这件事更快

1912
01:12:35,780 --> 01:12:39,120
所以我们会为你提供一个基本的 C 加

1913
01:12:39,120 --> 01:12:40,650
用于实现的单元测试它

1914
01:12:40,650 --> 01:12:42,510
基本上与我们对 BW 树进行的单元测试相同

1915
01:12:42,510 --> 01:12:44,520
，我们只是在替换中进行了搜索

1916
01:12:44,520 --> 01:12:46,130
并将其替换为 P 加树，

1917
01:12:46,130 --> 01:12:48,210
对，但它不会那么

1918
01:12:48,210 --> 01:12:49,830
详尽，它当然不会

1919
01:12:49,830 --> 01:12:52,590
测试内部数据结构的

1920
01:12:52,590 --> 01:12:55,469
正确性 或您

1921
01:12:55,469 --> 01:12:56,760
想要正确的完整性它是在逻辑级别完成的，

1922
01:12:56,760 --> 01:12:59,310
例如如果我插入此密钥

1923
01:12:59,310 --> 01:13:01,380
，我是否可以取回该密钥，但我怎么

1924
01:13:01,380 --> 01:13:04,350
知道我的您知道我没有任何

1925
01:13:04,350 --> 01:13:06,420
空鼻子闲逛

1926
01:13:06,420 --> 01:13:07,620
麻烦检查内存泄漏和

1927
01:13:07,620 --> 01:13:09,989
类似的事情，但就像我一样，你会

1928
01:13:09,989 --> 01:13:11,310
想要编写自己的测试来

1929
01:13:11,310 --> 01:13:13,110
实际测试低级数据

1930
01:13:13,110 --> 01:13:14,610
结构，因为我们不

1931
01:13:14,610 --> 01:13:15,630
知道你的事情是如何实现的，所以我们

1932
01:13:15,630 --> 01:13:17,610
无法为你提供 对于一些事情，我们

1933
01:13:17,610 --> 01:13:20,850
还将做一个排行榜，看看

1934
01:13:20,850 --> 01:13:22,469
谁的速度最快，它会

1935
01:13:22,469 --> 01:13:23,850
在灰度范围内运行，这并不理想，因为

1936
01:13:23,850 --> 01:13:25,860
它是单线程的，但至少我们可以看到

1937
01:13:25,860 --> 01:13:27,480
您与它相比有多快

1938
01:13:27,480 --> 01:13:29,250
，然后我们” 会给

1939
01:13:29,250 --> 01:13:32,430
前三个实现的额外加分

1940
01:13:32,430 --> 01:13:33,449
你必须做的另一件事是

1941
01:13:33,449 --> 01:13:35,040
编写关于你的代码实际在做什么的文档，

1942
01:13:35,040 --> 01:13:36,719
并解释你

1943
01:13:36,719 --> 01:13:37,949
在系统的所有不同部分

1944
01:13:37,949 --> 01:13:40,590
做了什么，因此我们需要对 doxygen 进行基本检查

1945
01:13:40,590 --> 01:13:42,510
借此机会

1946
01:13:42,510 --> 01:13:43,680
确保您确实

1947
01:13:43,680 --> 01:13:45,840
对每个功能都有类似的评论，但

1948
01:13:45,840 --> 01:13:47,160
显然 doxygen 您无法阅读

1949
01:13:47,160 --> 01:13:48,510
评论并查看您所说

1950
01:13:48,510 --> 01:13:50,010
的实际上是正确的，所以马特和我

1951
01:13:50,010 --> 01:13:51,239
会手动检查所有这些

1952
01:13:51,239 --> 01:13:55,260
所以我们再次计划是为你的实现运行

1953
01:13:55,260 --> 01:13:58,530
一些额外的压力测试，

1954
01:13:58,530 --> 01:14:00,960


1955
01:14:00,960 --> 01:14:02,730
超出我们已经给你的内容，

1956
01:14:02,730 --> 01:14:04,760
然后它会给你加分，

1957
01:14:04,760 --> 01:14:08,219
谁是最快的并且没有

1958
01:14:08,219 --> 01:14:09,540
再次确定你的所有代码 必须

1959
01:14:09,540 --> 01:14:11,730
遵循格式化程序和 linter 的东西

1960
01:14:11,730 --> 01:14:14,430
，这是我们实际做的事情之一，

1961
01:14:14,430 --> 01:14:15,690
另一个学生实际上使 linter 运行

1962
01:14:15,690 --> 01:14:17,489
得更快，所以现在你不认为你

1963
01:14:17,489 --> 01:14:19,050
知道你的所有课程 r 机器

1964
01:14:19,050 --> 01:14:20,580
并查看每个文件，Lynch

1965
01:14:20,580 --> 01:14:21,989
只查看您更改的文件的放置位置，

1966
01:14:21,989 --> 01:14:24,270
以便运行得更快，

1967
01:14:24,270 --> 01:14:26,340
好吧，

1968
01:14:26,340 --> 01:14:28,460
我昨晚在 Piazza 上发布了这个，

1969
01:14:28,460 --> 01:14:31,619
每个人都是一个小组项目，所以与

1970
01:14:31,619 --> 01:14:33,480
35 名学生一起分成三组 或者

1971
01:14:33,480 --> 01:14:35,310
有 12 个小组或三个人

1972
01:14:35,310 --> 01:14:37,679
然后一个两人小组项目

1973
01:14:37,679 --> 01:14:40,199
不要假设你会是那个两人

1974
01:14:40,199 --> 01:14:42,840
项目但我们只有一个所以

1975
01:14:42,840 --> 01:14:45,449
请开始找一个小组

1976
01:14:45,449 --> 01:14:47,550
然后在注册

1977
01:14:47,550 --> 01:14:49,020
如果你没有一个

1978
01:14:49,020 --> 01:14:51,030
团队可以加入，那么就有自由球员的名单，

1979
01:14:51,030 --> 01:14:53,130
然后你知道球队可以联系你

1980
01:14:53,130 --> 01:14:57,650
并试图让你加入他们，

1981
01:14:57,650 --> 01:14:59,909
所以网站还没有建立，我们会照顾好

1982
01:14:59,909 --> 01:15:00,360
今天

1983
01:15:00,360 --> 01:15:03,000
我认为马特将存根文件推送到

1984
01:15:03,000 --> 01:15:04,409
github，这样你就可以拉下

1985
01:15:04,409 --> 01:15:06,510
我们新项目分支的最新版本，

1986
01:15:06,510 --> 01:15:09,570
然后这将在 3 月 15 日到期，

1987
01:15:09,570 --> 01:15:11,400
目标显然是尽快获得很好的信息

1988
01:15:11,400 --> 01:15:13,739
，所以你 知道这

1989
01:15:13,739 --> 01:15:14,820
不像截止日期前的一两个星期

1990
01:15:14,820 --> 01:15:20,369
好的 有任何关于这个的问题

1991
01:15:20,369 --> 01:15:24,270
好吧 这可能很有趣 对

1992
01:15:24,270 --> 01:15:26,489
你们来说是一个有创造力的人 做任何

1993
01:15:26,489 --> 01:15:28,500
你想做的事 看看谁

1994
01:15:28,500 --> 01:15:32,820
看谁最快

1995
01:15:32,820 --> 01:15:34,920


1996
01:15:34,920 --> 01:15:36,750
执行查询，这

1997
01:15:36,750 --> 01:15:37,980
是我

1998
01:15:37,980 --> 01:15:40,710
在本学期剩下的时间里实际花费大量时间的地方，我们将讨论我们将

1999
01:15:40,710 --> 01:15:41,610
如何

2000
01:15:41,610 --> 01:15:43,949
组织和调度线程，然后是

2001
01:15:43,949 --> 01:15:46,080
我们的查询处理模型，然后

2002
01:15:46,080 --> 01:15:48,449
我们将讨论编码 编译但

2003
01:15:48,449 --> 01:15:49,590
在这一点上我们真正关注

2004
01:15:49,590 --> 01:15:52,080
的是现在我们知道如何索引事物

2005
01:15:52,080 --> 01:15:53,880
和存储事物并通过网络发送事物

2006
01:15:53,880 --> 01:15:55,349
我们如何实际执行

2007
01:15:55,349 --> 01:15:56,310
查询所以这是

2008
01:15:56,310 --> 01:15:57,810
您想要获得续集查询的数据库系统的重点

2009
01:15:57,810 --> 01:15:58,800
也许我会运行它们

2010
01:15:58,800 --> 01:16:01,830
产生答案好吧，伙计们

2011
01:16:01,830 --> 01:16:03,690
享受你的周末见你银行它在

2012
01:16:03,690 --> 01:16:04,469
旁边的公园

2013
01:16:04,469 --> 01:16:07,420
这是什么一些傻瓜

2014
01:16:07,420 --> 01:16:08,700
[音乐]

2015
01:16:08,700 --> 01:16:11,250
特别是这里被称为哦

2016
01:16:11,250 --> 01:16:14,040
它因为我麻糬冰你与

2017
01:16:14,040 --> 01:16:17,460
暴躁 我的你 你看，它是去给

2018
01:16:17,460 --> 01:16:20,010
我拿四十，只是为了让我的嗡嗡声哦因为我

2019
01:16:20,010 --> 01:16:24,810
需要多踢我的

2020
01:16:24,810 --> 01:16:28,560
嘴唇，把卡车吹得像热一样

2021
01:16:28,560 --> 01:16:31,500
，我的心要我说我很高兴

2022
01:16:31,500 --> 01:16:35,450
你接受一个圣人 我说祈祷

