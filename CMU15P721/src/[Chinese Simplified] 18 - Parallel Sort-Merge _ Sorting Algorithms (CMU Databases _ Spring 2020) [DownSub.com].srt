1
00:00:01,300 --> 00:00:05,129
[音乐]

2
00:00:05,200 --> 00:00:05,930
[掌声]

3
00:00:05,930 --> 00:00:08,630
[音乐]

4
00:00:08,630 --> 00:00:10,020
[掌声]

5
00:00:10,020 --> 00:00:11,210
[音乐]

6
00:00:11,210 --> 00:00:13,799
今天我们将再次讨论并行

7
00:00:13,799 --> 00:00:17,010
排序合并连接算法

8
00:00:17,010 --> 00:00:19,050
我在我的家庭办公室虽然我做了我的

9
00:00:19,050 --> 00:00:21,029
我做了很多我的照明游戏

10
00:00:21,029 --> 00:00:24,240
并且 我在这里有一个 terior

11
00:00:24,240 --> 00:00:25,949
谁会在我们进行的过程中提出问题

12
00:00:25,949 --> 00:00:28,890
所以让我们直接进入这个所以在

13
00:00:28,890 --> 00:00:31,140
我们进入今天的材料之前我们

14
00:00:31,140 --> 00:00:32,969
想谈谈一些

15
00:00:32,969 --> 00:00:35,280
关于你对下周开始的未来的期望的后勤

16
00:00:35,280 --> 00:00:37,950
下周

17
00:00:37,950 --> 00:00:40,829
我们将进行项目 3

18
00:00:40,829 --> 00:00:43,649
状态更新，所以我们进行了与上次相同的设置，

19
00:00:43,649 --> 00:00:45,360
我们将通过缩放进行操作，

20
00:00:45,360 --> 00:00:47,340
然后每个人都会花 5

21
00:00:47,340 --> 00:00:48,870
分钟时间将其更新到

22
00:00:48,870 --> 00:00:50,700
他们所在的班级 在那之前参与他们的

23
00:00:50,700 --> 00:00:53,760
项目，尽管我希望

24
00:00:53,760 --> 00:00:55,550
每个小组都与我联系并

25
00:00:55,550 --> 00:00:58,770
安排本周晚些时候的时间进行

26
00:00:58,770 --> 00:01:00,449
一对一会面，讨论

27
00:01:00,449 --> 00:01:02,910
您项目的当前进度，看看

28
00:01:02,910 --> 00:01:04,019
您在哪里遇到了问题 是当您

29
00:01:04,019 --> 00:01:06,299
需要帮助并让您

30
00:01:06,299 --> 00:01:07,590
感到 了解下周您将在课堂上展示的内容，

31
00:01:07,590 --> 00:01:10,770
因此那些

32
00:01:10,770 --> 00:01:13,020
在课堂上进行项目演示的人将

33
00:01:13,020 --> 00:01:16,710
在 4 月 8 日星期三进行，因此除了

34
00:01:16,710 --> 00:01:18,240
进行演示之外，他们

35
00:01:18,240 --> 00:01:21,540
还将提供一份设计文档，

36
00:01:21,540 --> 00:01:23,670
讨论您了解的一些知识 有关

37
00:01:23,670 --> 00:01:25,170
您的实现将是什么样子的更多详细信息，

38
00:01:25,170 --> 00:01:27,570
您还需要提交

39
00:01:27,570 --> 00:01:30,960
到目前为止为

40
00:01:30,960 --> 00:01:33,450
您的项目编写的内容，我会将其作为拉取

41
00:01:33,450 --> 00:01:36,150
请求提交给我们在 github 上，以便我们可以

42
00:01:36,150 --> 00:01:38,310
执行 第一轮代码审查

43
00:01:38,310 --> 00:01:39,900
我如何解释下周代码审查的预期内容，

44
00:01:39,900 --> 00:01:41,850
但我们的想法是，

45
00:01:41,850 --> 00:01:45,299
您将被分配另一个小组来

46
00:01:45,299 --> 00:01:46,530
查看他们的项目，他们将

47
00:01:46,530 --> 00:01:48,960
查看您的项目，然后您将完成

48
00:01:48,960 --> 00:01:51,210
并且您知道 尝试

49
00:01:51,210 --> 00:01:52,500
了解他们的实施是否正在尝试

50
00:01:52,500 --> 00:01:54,360
做，然后向他们提供有关他们正在追求的

51
00:01:54,360 --> 00:01:56,790
质量和想法的反馈，

52
00:01:56,790 --> 00:01:59,219
这将

53
00:01:59,219 --> 00:02:00,509
再次成为该项目参与等级的一部分

54
00:02:00,509 --> 00:02:02,310
每个团队成员都被

55
00:02:02,310 --> 00:02:05,850
期望 吨 o 参与，当我们

56
00:02:05,850 --> 00:02:07,290
进行第二轮代码审查时，您

57
00:02:07,290 --> 00:02:09,840
将再次查看相同组的代码

58
00:02:09,840 --> 00:02:10,800
，这样您就不会

59
00:02:10,800 --> 00:02:12,450
像查看代码一样从头开始

60
00:02:12,450 --> 00:02:13,480


61
00:02:13,480 --> 00:02:14,920
，现在您正在查看 这是第二

62
00:02:14,920 --> 00:02:16,180
次，因为他们准备

63
00:02:16,180 --> 00:02:18,790
提交最终的最终实施以

64
00:02:18,790 --> 00:02:21,370
获得成绩，因此您将再次向

65
00:02:21,370 --> 00:02:23,680
他们提供有关

66
00:02:23,680 --> 00:02:25,180
他们可以做些什么来修复它们的额外反馈

67
00:02:25,180 --> 00:02:26,319
他们可以做些什么 修复他们的

68
00:02:26,319 --> 00:02:28,840
代码，好的，所以我会在 Piazza 上发布

69
00:02:28,840 --> 00:02:31,150
关于联系和设置

70
00:02:31,150 --> 00:02:34,540
会议时间的内容 我将

71
00:02:34,540 --> 00:02:37,180
在管理移动

72
00:02:37,180 --> 00:02:39,730
电子表格上拉出或注册课程的插槽，然后我们

73
00:02:39,730 --> 00:02:41,769
将在下周三或下周以相反的顺序进行

74
00:02:41,769 --> 00:02:43,450
这周我们将按照

75
00:02:43,450 --> 00:02:45,850
我们第一次

76
00:02:45,850 --> 00:02:47,950
做项目提案时的相反顺序进行 所以如果

77
00:02:47,950 --> 00:02:49,180
你上次先去 下次你可以去

78
00:02:49,180 --> 00:02:53,380
最后一次 好的 所以这堂课和

79
00:02:53,380 --> 00:02:55,350
上一堂课都是关于

80
00:02:55,350 --> 00:02:57,880
有效载荷的 联合算法等最后一

81
00:02:57,880 --> 00:02:59,830
类 我们专注于散列连接，

82
00:02:59,830 --> 00:03:01,510
因为我说过这

83
00:03:01,510 --> 00:03:04,150
是 OLAP 系统中最常用的联合算法，

84
00:03:04,150 --> 00:03:06,069
这是我们将

85
00:03:06,069 --> 00:03:07,510
尝试

86
00:03:07,510 --> 00:03:10,030
通过瘫痪或矢量化来获得最佳性能优势的算法，

87
00:03:10,030 --> 00:03:12,220
因为同样在大多数开发的系统中，

88
00:03:12,220 --> 00:03:15,730
那些 执行散列连接

89
00:03:15,730 --> 00:03:18,310
的另一种主要方法

90
00:03:18,310 --> 00:03:20,769
是排序合并连接，

91
00:03:20,769 --> 00:03:23,530
这种重点将放在今天，所以

92
00:03:23,530 --> 00:03:24,670
我们将首先从一些

93
00:03:24,670 --> 00:03:27,489
关于排序合并看起来是什么样子的背景信息

94
00:03:27,489 --> 00:03:29,260
开始 这

95
00:03:29,260 --> 00:03:30,760
只是我们

96
00:03:30,760 --> 00:03:33,160
在介绍课程中讨论的内容的复习，然后

97
00:03:33,160 --> 00:03:34,510
我们将讨论

98
00:03:34,510 --> 00:03:36,370
您可以使用的不同排序算法，或者 - 英特尔

99
00:03:36,370 --> 00:03:38,470
将重点关注的特定方法

100
00:03:38,470 --> 00:03:40,810
将是如何矢量化

101
00:03:40,810 --> 00:03:43,810
和瘫痪排序算法

102
00:03:43,810 --> 00:03:45,549
是可能的，然后我们将讨论如何

103
00:03:45,549 --> 00:03:47,739
将它组合在一起以执行并行

104
00:03:47,739 --> 00:03:49,780
排序版本，然后我们将完成

105
00:03:49,780 --> 00:03:52,269


106
00:03:52,269 --> 00:03:53,980
分配的 re 中提供的评估 从

107
00:03:53,980 --> 00:04:01,540
ETH 开始，所以冰糕加入

108
00:04:01,540 --> 00:04:03,430
基本上有两个阶段，这

109
00:04:03,430 --> 00:04:05,859
与哈希绘图相同，

110
00:04:05,859 --> 00:04:08,230
您在第一阶段准备数据

111
00:04:08,230 --> 00:04:11,049
的方式是，在第二

112
00:04:11,049 --> 00:04:12,130
阶段，当您想要去尝试查找时

113
00:04:12,130 --> 00:04:15,010


114
00:04:15,010 --> 00:04:17,289
在散列连接的情况下，对数据进行布局或索引，并

115
00:04:17,289 --> 00:04:18,310
以这样的方式布局，即您可以轻松

116
00:04:18,310 --> 00:04:20,320
找到匹配项，

117
00:04:20,320 --> 00:04:22,840


118
00:04:22,840 --> 00:04:25,909
而无需执行在嵌套循环连接中必须

119
00:04:25,909 --> 00:04:29,400
再次执行的强力顺序扫描 在第一阶段，我们将

120
00:04:29,400 --> 00:04:31,770


121
00:04:31,770 --> 00:04:35,219
根据连接键或连接键（

122
00:04:35,219 --> 00:04:37,860
如果它是多个键）对 r NS 上的元组进行排序，然后在

123
00:04:37,860 --> 00:04:39,900
合并阶段，我们

124
00:04:39,900 --> 00:04:43,169
将按排序顺序扫描两个表

125
00:04:43,169 --> 00:04:44,340
这两个迭代器是

126
00:04:44,340 --> 00:04:47,009
同步进行的，并

127
00:04:47,009 --> 00:04:49,439
在它们之间进行比较，这里的想法是

128
00:04:49,439 --> 00:04:51,539
因为我们在迭代器遍历时提前进行了排序，

129
00:04:51,539 --> 00:04:54,360


130
00:04:54,360 --> 00:04:56,310
我们知道我们不必

131
00:04:56,310 --> 00:04:59,569
回溯查看 对于匹配的元组

132
00:04:59,569 --> 00:05:02,279
或 抱歉

133
00:05:02,279 --> 00:05:04,139
，如果我们

134
00:05:04,139 --> 00:05:06,719
遇到一个元组或一个

135
00:05:06,719 --> 00:05:08,610
与我们看到的最后一个键不同的键，它比我们实际需要的扫描得更远，那么

136
00:05:08,610 --> 00:05:10,500
我们知道您知道该键

137
00:05:10,500 --> 00:05:12,629
不能存在任何结果，这又是一个

138
00:05:12,629 --> 00:05:15,599
想法 我们通过排序它

139
00:05:15,599 --> 00:05:17,969
只是避免了启动

140
00:05:17,969 --> 00:05:19,620
搜索以找到我们知道的匹配键 我们

141
00:05:19,620 --> 00:05:22,409
知道随着迭代提升，我们拥有

142
00:05:22,409 --> 00:05:23,569
我们需要的一切，

143
00:05:23,569 --> 00:05:27,479
因此在概念上从概念上讲，

144
00:05:27,479 --> 00:05:32,009
再次看起来像这样，我们的

145
00:05:32,009 --> 00:05:34,979
表 第一阶段是我将

146
00:05:34,979 --> 00:05:37,319
通过连接键对它们进行排序我现在不会

147
00:05:37,319 --> 00:05:38,610
描述排序算法是什么，

148
00:05:38,610 --> 00:05:40,050
但这就是我们今天将要介绍的内容

149
00:05:40,050 --> 00:05:43,110
，然后现在一旦我们对事情进行了

150
00:05:43,110 --> 00:05:45,810
排序，现在将进行合并阶段 好吧，

151
00:05:45,810 --> 00:05:47,279
我们将再次让这两个迭代

152
00:05:47,279 --> 00:05:50,699
器向下扫描并

153
00:05:50,699 --> 00:05:53,039
通常一次扫描表格，但取决于

154
00:05:53,039 --> 00:05:54,539
是否存在等值联接

155
00:05:54,539 --> 00:05:55,529
，您正在执行哪种关节，您可能会

156
00:05:55,529 --> 00:05:57,150
多次认为这是癌症，我们

157
00:05:57,150 --> 00:05:58,800
现在可以忽略它 每一次 

158
00:05:58,800 --> 00:06:00,000
当我完成它时，它会出现一个元组

159
00:06:00,000 --> 00:06:02,729
我会成为下一个元组的一个，然后

160
00:06:02,729 --> 00:06:06,360
如果我

161
00:06:06,360 --> 00:06:08,039
在内部表和外部表上有匹配的元组，我就离开了散列连接

162
00:06:08,039 --> 00:06:10,050
将它们

163
00:06:10,050 --> 00:06:11,789
组合在一起 属性放在一起并将

164
00:06:11,789 --> 00:06:14,339
其写入我的输出缓冲区现在

165
00:06:14,339 --> 00:06:16,259
我们今天要遇到的令人困惑的事情是我们将进行

166
00:06:16,259 --> 00:06:19,020


167
00:06:19,020 --> 00:06:21,389
排序合并连接并且

168
00:06:21,389 --> 00:06:24,000
我们将进行排序的算法将是合并

169
00:06:24,000 --> 00:06:27,539
排序 所以当我使用“婚姻”这个词时，我会尽量小心，

170
00:06:27,539 --> 00:06:29,819
以确保

171
00:06:29,819 --> 00:06:32,410
我告诉你

172
00:06:32,410 --> 00:06:35,380
是合并排序的

173
00:06:35,380 --> 00:06:37,450
合并阶段还是排序合并的合并阶段

174
00:06:37,450 --> 00:06:39,550
它被删除了很多 当我们继续

175
00:06:39,550 --> 00:06:41,350
试图弄清楚

176
00:06:41,350 --> 00:06:42,910
我们在谈论什么样的合并但

177
00:06:42,910 --> 00:06:44,170
本质上做同样的

178
00:06:44,170 --> 00:06:47,890
事情的高水平所以这会让你在

179
00:06:47,890 --> 00:06:49,510
介绍课上知道我们讨论

180
00:06:49,510 --> 00:06:52,200
如何在你 知道某种基本

181
00:06:52,200 --> 00:06:54,580
的高级方法，我们不

182
00:06:54,580 --> 00:06:55,600
担心工人，我们不担心

183
00:06:55,600 --> 00:06:59,530
thr  eads 或 newman's 但现在在

184
00:06:59,530 --> 00:07:01,090
现代系统中，我们需要意识到

185
00:07:01,090 --> 00:07:02,620
这些事情，所以我们需要讨论

186
00:07:02,620 --> 00:07:03,820
我们实际上如何

187
00:07:03,820 --> 00:07:06,850
通过瘫痪一切来加快速度，所以

188
00:07:06,850 --> 00:07:08,710
我们当然想要瘫痪排序，

189
00:07:08,710 --> 00:07:09,790
因为那是 将是最

190
00:07:09,790 --> 00:07:12,130
昂贵的部分，就像

191
00:07:12,130 --> 00:07:14,380
我们在讨论因式分解时看到的那样，

192
00:07:14,380 --> 00:07:18,580
我们可以使算法的这一步瘫痪

193
00:07:18,580 --> 00:07:20,860
，因为它

194
00:07:20,860 --> 00:07:22,570
同时在多个线程上执行，

195
00:07:22,570 --> 00:07:25,330
然后在每个线程上尝试使用

196
00:07:25,330 --> 00:07:27,940
向量化操作，以便您知道

197
00:07:27,940 --> 00:07:29,980
我们正在使用单个指令或单个指令集并行操作多个键或

198
00:07:29,980 --> 00:07:32,800
多个数据元素，

199
00:07:32,800 --> 00:07:34,570


200
00:07:34,570 --> 00:07:38,650


201
00:07:38,650 --> 00:07:39,880
因此我们将尝试将一些基本规则

202
00:07:39,880 --> 00:07:41,980
应用于我们的算法中以尝试获得 尽可能获得

203
00:07:41,980 --> 00:07:44,170
最佳性能

204
00:07:44,170 --> 00:07:46,180
，这也与散列连接有关，

205
00:07:46,180 --> 00:07:47,590
但我只想再次提出

206
00:07:47,590 --> 00:07:50,920
这一点，因此我们显然希望使用

207
00:07:50,920 --> 00:07:53,860
尽可能多的 CPU 内核，而我们的

208
00:07:53,860 --> 00:07:55,840
数据库系统 分配给我们用于

209
00:07:55,840 --> 00:07:59,470
此执行 有些系统一次只执行

210
00:07:59,470 --> 00:08:01,330
一个查询，因此您将在进行连接时

211
00:08:01,330 --> 00:08:03,580
获得机器上可用的所有内核，

212
00:08:03,580 --> 00:08:05,200


213
00:08:05,200 --> 00:08:06,610
然后在查询完成后

214
00:08:06,610 --> 00:08:09,610
切换到下一个 在其他

215
00:08:09,610 --> 00:08:11,880
系统中进行查询时，他们会尝试同时运行

216
00:08:11,880 --> 00:08:14,920
多个查询，因此您

217
00:08:14,920 --> 00:08:17,350
只想成为系统的调度

218
00:08:17,350 --> 00:08:18,580
程序，就必须了解

219
00:08:18,580 --> 00:08:21,210
允许进行大量排序的线程数量，并

220
00:08:21,210 --> 00:08:23,290
确保它 显然只在这些核心上运行，

221
00:08:23,290 --> 00:08:25,780
我们也需要

222
00:08:25,780 --> 00:08:28,210
注意 Numa 边界，因为

223
00:08:28,210 --> 00:08:31,300
我们不想再支付这么大的

224
00:08:31,300 --> 00:08:33,159
代价，

225
00:08:33,159 --> 00:08:34,539
因为这

226
00:08:34,539 --> 00:08:36,610
比读取本地数据的成本要高得多。

227
00:08:36,610 --> 00:08:39,880
线程，所以我们将看到

228
00:08:39,880 --> 00:08:43,150
在 hyper 的情况下，他们实际上

229
00:08:43,150 --> 00:08:45,590
会在这里违背第二个目标

230
00:08:45,590 --> 00:08:47,660
，他们会争辩说，因为

231
00:08:47,660 --> 00:08:49,100
当

232
00:08:49,100 --> 00:08:51,410
您在执行连接的合并

233
00:08:51,410 --> 00:08:54,110
阶段时，他们正在执行顺序需求 硬件实际上是gon  na

234
00:08:54,110 --> 00:08:56,960
有助于隐藏

235
00:08:56,960 --> 00:08:59,120
穿越 Neiman 的这些延迟，但是当我们查看

236
00:08:59,120 --> 00:09:00,770
边缘论文的结果时，我们会

237
00:09:00,770 --> 00:09:03,590
发现实际上并非如此，然后

238
00:09:03,590 --> 00:09:05,660
我们再次说在我

239
00:09:05,660 --> 00:09:07,610
想成为之前我们正在尝试使用的最后一个 simian

240
00:09:07,610 --> 00:09:09,470
结构尽可能多，

241
00:09:09,470 --> 00:09:12,230
以便每个周期每条指令处理的数据

242
00:09:12,230 --> 00:09:14,900
量最大化，

243
00:09:14,900 --> 00:09:16,820
好吧，我将尝试这样做，

244
00:09:16,820 --> 00:09:18,200
您将将此与辅助指令进行比较，

245
00:09:18,200 --> 00:09:19,640
因为您知道只能

246
00:09:19,640 --> 00:09:24,800
对一个指令进行操作 一次一个键，所以

247
00:09:24,800 --> 00:09:26,150
并行排序合并

248
00:09:26,150 --> 00:09:27,860
连接就像并行哈希联合

249
00:09:27,860 --> 00:09:29,630
，你现在有三个阶段，因为

250
00:09:29,630 --> 00:09:31,940
现在第一阶段是这个分区

251
00:09:31,940 --> 00:09:34,040
步骤，你将

252
00:09:34,040 --> 00:09:38,320
在工作人员或核心之间划分数据

253
00:09:38,320 --> 00:09:42,830
但与在散列中的一种情况不同，在这种情况

254
00:09:42,830 --> 00:09:44,450
下，您将

255
00:09:44,450 --> 00:09:45,950
在这种情况下对两侧进行分区，我们可以只对

256
00:09:45,950 --> 00:09:48,650
一侧进行分区，并且某些算法

257
00:09:48,650 --> 00:09:50,110
会将某些项目很好地

258
00:09:50,110 --> 00:09:53,540
分区，然后将其划分为一个，然后对于这

259
00:09:53,540 --> 00:09:54,680
一点，我们将保持不变 第二，但您可以

260
00:09:54,680 --> 00:09:56,060
进行与上次相同的分区

261
00:09:56,060 --> 00:10:00,170
，下一个将是

262
00:10:00,170 --> 00:10:02,990
排序排序阶段，

263
00:10:02,990 --> 00:10:04,640
现在我们再次获取内部表

264
00:10:04,640 --> 00:10:05,780
和外部表，然后我们只需

265
00:10:05,780 --> 00:10:08,060
根据连接键对它们进行排序 在最后一个

266
00:10:08,060 --> 00:10:09,710
阶段，我们进行合并，我们只是扫描

267
00:10:09,710 --> 00:10:11,650
关系的种类并

268
00:10:11,650 --> 00:10:13,430
比较元组，如果我们有

269
00:10:13,430 --> 00:10:15,050
匹配，让我将它们写入我们的输出

270
00:10:15,050 --> 00:10:17,030
缓冲区，所以今天我们将把

271
00:10:17,030 --> 00:10:19,250
大部分时间花在这两个上 好吧

272
00:10:19,250 --> 00:10:21,350
，关于这个我们不能再多说

273
00:10:21,350 --> 00:10:22,700
，但我们会看看

274
00:10:22,700 --> 00:10:24,470
我们可以在这里用笔做出什么样的选择，决定

275
00:10:24,470 --> 00:10:26,390
我们稍后想要做什么样的合并

276
00:10:26,390 --> 00:10:30,580
，所以我没有谈论

277
00:10:30,580 --> 00:10:34,910
分区 概念级别上一

278
00:10:34,910 --> 00:10:36,860
堂课，但我在这里要说的

279
00:10:36,860 --> 00:10:40,310
仍然与散列连接相关，因此当我们想要进行连接时，存在

280
00:10:40,310 --> 00:10:42,770
排序隐式和

281
00:10:42,770 --> 00:10:44,420
显式分区的概念，

282
00:10:44,420 --> 00:10:47,800
因此隐式分区将

283
00:10:47,800 --> 00:10:51,230
是数据在加载时已经分区的方式

284
00:10:51,230 --> 00:10:53,750
进入数据库 d 那么

285
00:10:53,750 --> 00:10:57,350
如果我们知道数据是

286
00:10:57,350 --> 00:10:58,980
在

287
00:10:58,980 --> 00:11:01,050
我们现在尝试运行的查询的连接键上分区的，那么

288
00:11:01,050 --> 00:11:02,639
我们实际上不需要执行额外

289
00:11:02,639 --> 00:11:03,959
的分区步骤，因为数据

290
00:11:03,959 --> 00:11:05,490
已经在我们的连接团队中进行了分区，并且

291
00:11:05,490 --> 00:11:08,310
我们很高兴去所以这就像

292
00:11:08,310 --> 00:11:11,250
如果我加载表并且我在

293
00:11:11,250 --> 00:11:12,269
加载表或创建表时执行我可以

294
00:11:12,269 --> 00:11:16,079
在 DDL 中声明我想要一个

295
00:11:16,079 --> 00:11:18,660
像我的表一样的分区，或者通过某些

296
00:11:18,660 --> 00:11:20,910
属性集或 某种连接键

297
00:11:20,910 --> 00:11:23,070
可能就像在 PCC 的情况下

298
00:11:23,070 --> 00:11:27,570
一样，例如 where else ID 或 in in in TP CH

299
00:11:27,570 --> 00:11:29,310
可能像国家或任何

300
00:11:29,310 --> 00:11:30,829
您对马铃薯有兴趣的时间，

301
00:11:30,829 --> 00:11:34,230
所以这

302
00:11:34,230 --> 00:11:36,029
是 应用程序或数据库

303
00:11:36,029 --> 00:11:37,440
管理员必须为我们做的事情他们

304
00:11:37,440 --> 00:11:39,089
必须被告知数据库

305
00:11:39,089 --> 00:11:40,410
不必被告知这是我想要

306
00:11:40,410 --> 00:11:42,630
如何分区的东西，在我们的目录中，

307
00:11:42,630 --> 00:11:44,339
我们可以跟踪

308
00:11:44,339 --> 00:11:46,139
分区键是什么，因为自从 因为

309
00:11:46,139 --> 00:11:47,339
我们不得不通过

310
00:11:47,339 --> 00:11:49,410
不同的新雇佣兵写出数据 hants 等现在

311
00:11:49,410 --> 00:11:51,600
查询优化器可以说哦，我

312
00:11:51,600 --> 00:11:53,790
看到您正在尝试对

313
00:11:53,790 --> 00:11:56,100
我已经对我的表进行分区的键进行连接，

314
00:11:56,100 --> 00:11:58,019
因此我不需要

315
00:11:58,019 --> 00:12:00,420
执行额外的分区步骤 事情，

316
00:12:00,420 --> 00:12:03,990
因为它已经是分区，但这

317
00:12:03,990 --> 00:12:06,959
在 OLAP 环境中并不总是对我们

318
00:12:06,959 --> 00:12:09,600
有用，因为人们希望我

319
00:12:09,600 --> 00:12:12,060
将要加入他们可能不知道的

320
00:12:12,060 --> 00:12:14,160
各种列和属性的

321
00:12:14,160 --> 00:12:16,529


322
00:12:16,529 --> 00:12:17,670
表 一段时间后，您实际上

323
00:12:17,670 --> 00:12:19,829
可能无法为特定查询声明正确的

324
00:12:19,829 --> 00:12:21,149
分区键，

325
00:12:21,149 --> 00:12:23,220
因为它可能会从一个箱子更改为下一个箱子，

326
00:12:23,220 --> 00:12:25,649
您在 OLAP 查询中看不到这么多，

327
00:12:25,649 --> 00:12:28,019
因为我们很抱歉 OTP 和

328
00:12:28,019 --> 00:12:32,339
工作负载，因为 通常，

329
00:12:32,339 --> 00:12:35,100
分区键

330
00:12:35,100 --> 00:12:37,110
是表的分区方案，遵循

331
00:12:37,110 --> 00:12:40,470
某种层次结构，您说您知道

332
00:12:40,470 --> 00:12:41,910
这里是客户，对于给定的

333
00:12:41,910 --> 00:12:43,380
客户 ID，这里是所有订单，以便

334
00:12:43,380 --> 00:12:44,970
客户 ID 和该订单的

335
00:12:44,970 --> 00:12:47,310
该客户的订单项目 ID 这样你就有了

336
00:12:47,310 --> 00:12:48,510
这个很好的层次结构，你可以在其中

337
00:12:48,510 --> 00:12:49,949
获取跨表的数据切片

338
00:12:49,949 --> 00:12:50,880
并将它们放在一个

339
00:12:50,880 --> 00:12:52,920
分区上，并且大多数时候你会

340
00:12:52,920 --> 00:12:55,050
加入那些你知道外

341
00:12:55,050 --> 00:12:57,480
键依赖关系的人，哦，

342
00:12:57,480 --> 00:12:59,370
像我说的那样的查询 人们加入各种

343
00:12:59,370 --> 00:13:00,959
疯狂的事情，所以很难真正

344
00:13:00,959 --> 00:13:02,519
做到这一点，你知道覆盖所有

345
00:13:02,519 --> 00:13:04,230
可能的查询实际上是

346
00:13:04,230 --> 00:13:06,959
不可能的，所以

347
00:13:06,959 --> 00:13:08,730
当我们说

348
00:13:08,730 --> 00:13:10,470
连接算法的分区阶段将是

349
00:13:10,470 --> 00:13:12,050
显式分区时

350
00:13:12,050 --> 00:13:15,769
，我们正在谈论的是我们 将

351
00:13:15,769 --> 00:13:18,679
根据连接键划分关系，然后

352
00:13:18,679 --> 00:13:20,600
在公开课后重新分配它们，

353
00:13:20,600 --> 00:13:24,499
这样您就可以在实践中使用

354
00:13:24,499 --> 00:13:25,790
我们在上节课中讨论过的基数分区，

355
00:13:25,790 --> 00:13:28,459
但

356
00:13:28,459 --> 00:13:32,569
用于合并排序的排序合并排序合并

357
00:13:32,569 --> 00:13:35,629
连接算法这不是一个

358
00:13:35,629 --> 00:13:36,980
好主意，因为通常您想要

359
00:13:36,980 --> 00:13:38,239
进行范围分区，因为

360
00:13:38,239 --> 00:13:40,069
您知道如何划分数据并且

361
00:13:40,069 --> 00:13:41,689
知道边界是什么

362
00:13:41,689 --> 00:13:43,399
从一个分区到下一个分区的数据，然后

363
00:13:43,399 --> 00:13:46,489
小心地知道没有

364
00:13:46,489 --> 00:13:50,179
具有相同分区

365
00:13:50,179 --> 00:13:52,549
的键抱歉，没有具有相同值的相同键

366
00:13:52,549 --> 00:13:53,929
可能位于不同的

367
00:13:53,929 --> 00:13:55,040
分区中，而不是你没有

368
00:13:55,040 --> 00:13:58,610
期待一切顺利，这又是

369
00:13:58,610 --> 00:13:59,720
我们可以对分区范围进行评分的分区阶段

370
00:13:59,720 --> 00:14:01,639
分区这

371
00:14:01,639 --> 00:14:02,779
并不重要 这与

372
00:14:02,779 --> 00:14:05,019
我们上次讨论的内容

373
00:14:05,019 --> 00:14:07,040
相同 那时我们将做的事情没有什么不同，

374
00:14:07,040 --> 00:14:09,290
因为我们正在做

375
00:14:09,290 --> 00:14:11,959
一个你 知道排序合并加入与散列合并，

376
00:14:11,959 --> 00:14:15,019
所以现在我们

377
00:14:15,019 --> 00:14:16,999
再次进入排序阶段，这

378
00:14:16,999 --> 00:14:18,230
对我们来说将是最昂贵的部分，

379
00:14:18,230 --> 00:14:20,809
所以在这里了解排序的关键

380
00:14:20,809 --> 00:14:23,360
是

381
00:14:23,360 --> 00:14:27,759
在我们谈论的介绍课中

382
00:14:27,759 --> 00:14:30,470
对主要瓶颈进行排序 我们

383
00:14:30,470 --> 00:14:33,619
必须处理的主要事情是

384
00:14:33,619 --> 00:14:35,689
从磁盘写入页面和从磁盘写入页面，因此我们

385
00:14:35,689 --> 00:14:39,259
希望使用像外部归并排序这样的算法，该算法

386
00:14:39,259 --> 00:14:43,069
旨在完成尽可能

387
00:14:43,069 --> 00:14:44,779
多的操作

388
00:14:44,779 --> 00:14:48,079
对磁盘的特殊读取和写入尽可能等价访问，

389
00:14:48,079 --> 00:14:51,259
并确保当它将页面或

390
00:14:51,259 --> 00:14:54,919
数据块从磁盘带入内存时，

391
00:14:54,919 --> 00:14:57,709


392
00:14:57,709 --> 00:15:00,499
我们在继续之前对该数据块执行了所有需要执行的操作

393
00:15:00,499 --> 00:15:01,850
下一个块，所以我们不必

394
00:15:01,850 --> 00:15:03,290
多次读取或写回它

395
00:15:03,290 --> 00:15:06,589
，但关键

396
00:15:06,589 --> 00:15:09,470
是当我们将

397
00:15:09,470 --> 00:15:11,959
内存块带入内存时，你知道它从磁盘

398
00:15:11,959 --> 00:15:14,629
到内存，然后他可能需要对它进行

399
00:15:14,629 --> 00:15:17,389
排序 那些在内存中的数据

400
00:15:17,389 --> 00:15:20,480
我们说你知道

401
00:15:20,480 --> 00:15:21,799
像快速排序这样的东西足以

402
00:15:21,799 --> 00:15:23,689
满足我们需要做的事情开始

403
00:15:23,689 --> 00:15:25,670
我们不会详细

404
00:15:25,670 --> 00:15:27,820
了解归纳类

405
00:15:27,820 --> 00:15:30,590
中那些算法的缓存缓存局部性和并行化

406
00:15:30,590 --> 00:15:32,510
这就是全部 关于

407
00:15:32,510 --> 00:15:36,590
最小化磁盘 i/o 但现在在本

408
00:15:36,590 --> 00:15:37,820
学期当我们谈论

409
00:15:37,820 --> 00:15:40,100
内存数据库 现在我们的数据库

410
00:15:40,100 --> 00:15:43,190
已经在内存中 现在我们需要一个排序

411
00:15:43,190 --> 00:15:46,340
算法来知道一天

412
00:15:46,340 --> 00:15:48,770
的位置和我们的 硬件

413
00:15:48,770 --> 00:15:50,870
看起来意味着它不需要任何地方你

414
00:15:50,870 --> 00:15:52,940
知道它是否正在读取写入某个

415
00:15:52,940 --> 00:15:54,980
内存位置

416
00:15:54,980 --> 00:15:57,080
是与我的线程正在运行的同一Numa区域中的内存位置

417
00:15:57,080 --> 00:16:01,010
所以这也意味着

418
00:16:01,010 --> 00:16:03,200
我们需要知道

419
00:16:03,200 --> 00:16:05,090
数据的大小 我们正在处理以及

420
00:16:05,090 --> 00:16:06,500
我们的 Karma 在缓存大小方面的外观，

421
00:16:06,500 --> 00:16:09,710
因此我们最终可能会

422
00:16:09,710 --> 00:16:13,760
为特定大小的数据块选择不同的算法，

423
00:16:13,760 --> 00:16:16,820
如果事情可以

424
00:16:16,820 --> 00:16:19,340
适合我的 l1 缓存我可能想做

425
00:16:19,340 --> 00:16:20,630
一件事 与如果我

426
00:16:20,630 --> 00:16:23,060
溢出 2d Ram 不同，因为

427
00:16:23,060 --> 00:16:24,500
从缓存到出轨的速度再慢一个数量级

428
00:16:24,500 --> 00:16:28,520
，所以我很清楚

429
00:16:28,520 --> 00:16:31,010
，就像我们今天谈论的

430
00:16:31,010 --> 00:16:36,320
那样，在某些情况下，做排序是更好的方法

431
00:16:36,320 --> 00:16:39,080
对于连接，如果您的数据看起来

432
00:16:39,080 --> 00:16:40,910
像某种方式，特别是如果您的

433
00:16:40,910 --> 00:16:45,800
数据适合 64 位 64 位值

434
00:16:45,800 --> 00:16:50,270
或快速排序仍然非常非常好

435
00:16:50,270 --> 00:16:52,970
可以瘫痪 可以实施它

436
00:16:52,970 --> 00:16:55,010
以避免分支预测错误，这是

437
00:16:55,010 --> 00:16:55,850
其中之一 今天我要尝试

438
00:16:55,850 --> 00:16:59,600
克服它，就像我说的它

439
00:16:59,600 --> 00:17:01,070
几乎就像排序算法的皮卡车

440
00:17:01,070 --> 00:17:03,020
它几乎可以

441
00:17:03,020 --> 00:17:05,660
很好地处理所有事情，当然你

442
00:17:05,660 --> 00:17:07,849
可以做得更好，所以我们今天要讨论的

443
00:17:07,849 --> 00:17:09,589
是一种实际做的方法

444
00:17:09,589 --> 00:17:16,250
比快速排序更好所以

445
00:17:16,250 --> 00:17:17,930
我们需要理解的

446
00:17:17,930 --> 00:17:20,540
事情是这个概念本质上是

447
00:17:20,540 --> 00:17:21,770
做分而治

448
00:17:21,770 --> 00:17:23,900


449
00:17:23,900 --> 00:17:26,180


450
00:17:26,180 --> 00:17:28,910
之的

451
00:17:28,910 --> 00:17:31,430
总表的不相交部分，其中

452
00:17:31,430 --> 00:17:32,780
有一些元素现在将

453
00:17:32,780 --> 00:17:36,260
进行排序，然后随着时间的推移

454
00:17:36,260 --> 00:17:39,510
会发生什么是随着我们积累

455
00:17:39,510 --> 00:17:41,760
或更多这些类型的运行将开始

456
00:17:41,760 --> 00:17:43,200
将它们组合成更大的

457
00:17:43,200 --> 00:17:46,170
更短的运行然后组合其他你

458
00:17:46,170 --> 00:17:47,190
知道更大的 与其他人一起运行

459
00:17:47,190 --> 00:17:48,480
更大的更短的运行，直到我们

460
00:17:48,480 --> 00:17:50,520
逐渐变大，并且在某些时候，

461
00:17:50,520 --> 00:17:52,830
我们已经完全排序了整个表或退休

462
00:17:52,830 --> 00:17:55,290
的连接键空间，

463
00:17:55,290 --> 00:17:57,960
所以这是

464
00:17:57,960 --> 00:17:58,980
当这些运行的概念时我们正在处理的原子单元

465
00:17:58,980 --> 00:18:00,660
，但是这些运行的

466
00:18:00,660 --> 00:18:03,450
大小会随着我们在排序

467
00:18:03,450 --> 00:18:05,190
执行中的进一步进展而变得越来越大，

468
00:18:05,190 --> 00:18:09,030
所以我们将

469
00:18:09,030 --> 00:18:12,000
关注的方法 这是英特尔的缓存谨慎排序

470
00:18:12,000 --> 00:18:15,330
吗所以记得上一堂课我

471
00:18:15,330 --> 00:18:17,700
谈到有这六篇论文

472
00:18:17,700 --> 00:18:21,990
可以追溯到 2009 年，讨论了

473
00:18:21,990 --> 00:18:23,490


474
00:18:23,490 --> 00:18:25,980
在今天的硬件上进行现代排序的各种进展，

475
00:18:25,980 --> 00:18:27,390
第一篇论文是

476
00:18:27,390 --> 00:18:30,120
英特尔和甲骨文之间在进行哈希方面的合作

477
00:18:30,120 --> 00:18:34,050
加入或游泳者加入 Cyndi 所以

478
00:18:34,050 --> 00:18:35,550
这就是这种技术的

479
00:18:35,550 --> 00:18:37,830
来源，所以它被称为

480
00:18:37,830 --> 00:18:40,050
缓存意识的原因是因为该

481
00:18:40,050 --> 00:18:43,920
算法知道运行的规模有多大

482
00:18:43,920 --> 00:18:45,780
，然后它将使用

483
00:18:45,780 --> 00:18:49,400
不同的算法进行排序

484
00:18:49,400 --> 00:18:51,990
那些已成为目标的运行 可用的最快

485
00:18:51,990 --> 00:18:53,640
存储级别，可以

486
00:18:53,640 --> 00:18:58,710
完整存储运行，

487
00:18:58,710 --> 00:19:00,900
因此当运行变得太大时，

488
00:19:00,900 --> 00:19:02,910
我们将移至下一个文件

489
00:19:02,910 --> 00:19:05,010
通过从寄存器到

490
00:19:05,010 --> 00:19:08,430
缓存再到内存，您可以深入了解我们的存储层次结构，并且您很清楚

491
00:19:08,430 --> 00:19:09,330
如何

492
00:19:09,330 --> 00:19:12,290
为该方法设计或优化不同的算法

493
00:19:12,290 --> 00:19:18,840
，因此我们将

494
00:19:18,840 --> 00:19:20,880
在第一级进行

495
00:19:20,880 --> 00:19:22,680
寄存器排序，因为再次 CPU

496
00:19:22,680 --> 00:19:24,060
寄存器是您可以拥有的最快的内存，

497
00:19:24,060 --> 00:19:26,130
但当然它的大小非常有限

498
00:19:26,130 --> 00:19:28,800
，因此我们将处理

499
00:19:28,800 --> 00:19:30,960
适合我们 CB 寄存器的运行

500
00:19:30,960 --> 00:19:33,120
将整个表空间分类为这些

501
00:19:33,120 --> 00:19:35,190
小块，然后现在我们将溢出

502
00:19:35,190 --> 00:19:38,700
到 在下一级的缓存排序中

503
00:19:38,700 --> 00:19:40,410
，我们

504
00:19:40,410 --> 00:19:42,150
将从第一个运行中生成的所有

505
00:19:42,150 --> 00:19:44,610
运行放入并将它们分类为

506
00:19:44,610 --> 00:19:46,590
适合我们 CPU 缓存的运行，在这种情况下

507
00:19:46,590 --> 00:19:47,760
，我们将针对最后一个

508
00:19:47,760 --> 00:19:50,400
级别 像 l3 这样的缓存，因此我们

509
00:19:50,400 --> 00:19:53,100
需要

510
00:19:53,100 --> 00:19:55,830
确保我们将继续使用这种方法

511
00:19:55,830 --> 00:19:58,559
级别 2，直到我们的梯级是

512
00:19:58,559 --> 00:20:01,500
l3 缓存大小的一半，因为你再次

513
00:20:01,500 --> 00:20:02,910
为此特定算法

514
00:20:02,910 --> 00:20:06,000
存储你知道 输入数据

515
00:20:06,000 --> 00:20:07,830
，然后是一个包含排序运行的相同大小的输出缓冲区，

516
00:20:07,830 --> 00:20:10,799
所以对于这个

517
00:20:10,799 --> 00:20:12,750
也是如此，正如我所说，我们的目标是

518
00:20:12,750 --> 00:20:15,960
l3 缓存，这是你大致知道的

519
00:20:15,960 --> 00:20:17,010
单声道 Zeon

520
00:20:17,010 --> 00:20:20,850
可能高达 40 兆字节，我们

521
00:20:20,850 --> 00:20:24,179
不会 担心中国的目标 l1

522
00:20:24,179 --> 00:20:26,730
与 l2 l3 我们会让港口

523
00:20:26,730 --> 00:20:28,559
为我们处理这个我们只会说

524
00:20:28,559 --> 00:20:30,870
只要我们不泄漏到 DRAM 并且我们

525
00:20:30,870 --> 00:20:32,250
仍然在 l3 闲逛然后我们很高兴

526
00:20:32,250 --> 00:20:35,850
去 一旦我们走了，我们就会超越 l3 然后

527
00:20:35,850 --> 00:20:39,299
我们将在缓存排序中使用，现在

528
00:20:39,299 --> 00:20:44,390
我们将完全并行

529
00:20:44,390 --> 00:20:49,169
执行排序，我们

530
00:20:49,169 --> 00:20:51,630
将知道缓存中的

531
00:20:51,630 --> 00:20:53,700
内容哪些不在缓存中，并且 我们将

532
00:20:53,700 --> 00:20:54,809
让我们的线程实际上能够

533
00:20:54,809 --> 00:20:56,370
跳转并

534
00:20:56,370 --> 00:20:59,220
在运行或表空间的不同部分进行操作，

535
00:20:59,220 --> 00:21:01,530
这取决于您知道

536
00:21:01,530 --> 00:21:03,870
什么是缓存垄断中的内容我的意思是我们

537
00:21:03,870 --> 00:21:05,270
将逐一介绍这些内容

538
00:21:05,270 --> 00:21:08,580
我们也说有一个

539
00:21:08,580 --> 00:21:10,740
级别 1 级别 2 级别 3 这

540
00:21:10,740 --> 00:21:12,990
不是 ac 实际上，在最初的英特尔论文中，

541
00:21:12,990 --> 00:21:15,990
我认为英特尔将它们称为阶段或

542
00:21:15,990 --> 00:21:18,570
阶段，这显然与

543
00:21:18,570 --> 00:21:20,490
我用来描述或

544
00:21:20,490 --> 00:21:23,130
加入相关阶段的术语相冲突，因此我在这里使用了这个

545
00:21:23,130 --> 00:21:26,909
术语级别，所以让我们再看看

546
00:21:26,909 --> 00:21:28,440
更高的级别 它看起来

547
00:21:28,440 --> 00:21:30,510
会发生什么 所以这里是我们未排序的键空间

548
00:21:30,510 --> 00:21:33,770
然后在第一级我们要做的

549
00:21:33,770 --> 00:21:37,260
我们现在将它们分为四个

550
00:21:37,260 --> 00:21:40,620
元素运行 然后一旦超过我们的

551
00:21:40,620 --> 00:21:42,870
CP 寄存器大小 然后我们切换到 l2

552
00:21:42,870 --> 00:21:44,929
我们现在 将

553
00:21:44,929 --> 00:21:47,669
多种类型的运行或一次至少两种

554
00:21:47,669 --> 00:21:48,780
类型的运行组合在一起，然后将它们组合

555
00:21:48,780 --> 00:21:50,429
成更大的运行类型，直到我们

556
00:21:50,429 --> 00:21:51,809
有不适合我们的 CPU

557
00:21:51,809 --> 00:21:52,260
缓存的运行

558
00:21:52,260 --> 00:21:54,809
，然后我们在现在想要的位置输入 l3

559
00:21:54,809 --> 00:21:57,120
要开始使用不同的排序

560
00:21:57,120 --> 00:21:58,980
方法，你是否将它们组合在一起，

561
00:21:58,980 --> 00:22:01,320
直到我们得到

562
00:22:01,320 --> 00:22:04,130
按排序顺序排列的完整键空间的某个点

563
00:22:04,130 --> 00:22:06,330
再次好 高级英雄会去

564
00:22:06,330 --> 00:22:09,149
我们将专注于这两个第三

565
00:22:09,149 --> 00:22:13,640
级是它 有点像

566
00:22:13,640 --> 00:22:16,169
ar 跨多个内核进行排序的架构方法，

567
00:22:16,169 --> 00:22:18,090
而不是

568
00:22:18,090 --> 00:22:21,419
实际的排序算法本身，

569
00:22:21,419 --> 00:22:22,620
所以就像我说的那样，我们将

570
00:22:22,620 --> 00:22:28,080
一个一个地完成这些，所以在

571
00:22:28,080 --> 00:22:29,700
第一级，我们将在这里做的

572
00:22:29,700 --> 00:22:31,500
是我们” 重新组合在一起，或者

573
00:22:31,500 --> 00:22:32,730
我们将在这里对

574
00:22:32,730 --> 00:22:35,700
包含四个元素的运行进行排序，我们

575
00:22:35,700 --> 00:22:36,990
将使用所谓的排序网络，

576
00:22:36,990 --> 00:22:40,620
因此排序网络是一个古老的想法，它

577
00:22:40,620 --> 00:22:44,159
可以追溯到 1940 年代，但一些

578
00:22:44,159 --> 00:22:46,740
第一台计算机 但那时当他们

579
00:22:46,740 --> 00:22:48,960
描述排序网络时，他们

580
00:22:48,960 --> 00:22:51,360
使用带有值的术语“电线”，它们的

581
00:22:51,360 --> 00:22:55,110
字面意思是物理电线，就像

582
00:22:55,110 --> 00:22:56,880
您在硬件中的铜线中所知道的那样，

583
00:22:56,880 --> 00:22:58,950
在我们的案例中，我们显然没有

584
00:22:58,950 --> 00:23:00,630
做到一切都是晶体管，

585
00:23:00,630 --> 00:23:03,240
所以这就是这样 是一个概念

586
00:23:03,240 --> 00:23:05,100
模型并描述了这种方法，

587
00:23:05,100 --> 00:23:06,659
但是 hilum 的想法是一样的，只是

588
00:23:06,659 --> 00:23:09,720
我们现在只是在软件中这样做，所以

589
00:23:09,720 --> 00:23:11,159
会发生的是我们有

590
00:23:11,159 --> 00:23:15,049
四个键的输入序列，然后是输出

591
00:23:15,049 --> 00:23:17,669
ut buffer for sorry they for each

592
00:23:17,669 --> 00:23:19,440
key element there are a they will be this

593
00:23:19,440 --> 00:23:21,690
wire come from it

594
00:23:21,690 --> 00:23:25,100


595
00:23:25,100 --> 00:23:28,169


596
00:23:28,169 --> 00:23:29,220


597
00:23:29,220 --> 00:23:31,740
在这里，我们有

598
00:23:31,740 --> 00:23:34,769
九五三六，所以在

599
00:23:34,769 --> 00:23:36,690
第一步中，我们都会

600
00:23:36,690 --> 00:23:38,309
继续前进，所以在

601
00:23:38,309 --> 00:23:40,230
第一次比较 Raider 中，我们

602
00:23:40,230 --> 00:23:43,320
将看到哪个值是

603
00:23:43,320 --> 00:23:44,850
最小值 值最大值它将

604
00:23:44,850 --> 00:23:47,279
在顶线上写入最小值

605
00:23:47,279 --> 00:23:49,529
然后最大值将在底线上

606
00:23:49,529 --> 00:23:52,440
所以在这种情况下这里 5 小于 9

607
00:23:52,440 --> 00:23:55,080
所以我们要交换位置所以

608
00:23:55,080 --> 00:23:56,580
现在将进行 5 这条线

609
00:23:56,580 --> 00:23:58,620
和 9 是在它下面的线上进行的，

610
00:23:58,620 --> 00:24:00,750
从这里开始，

611
00:24:00,750 --> 00:24:03,510
三和六三小于六，所以

612
00:24:03,510 --> 00:24:04,889
这三个将从这条

613
00:24:04,889 --> 00:24:06,600
线上进行，六个将在这条线上进行，

614
00:24:06,600 --> 00:24:09,179
所以现在我们重复 这个下来，

615
00:24:09,179 --> 00:24:10,860
但现在我们要做

616
00:24:10,860 --> 00:24:13,320
跨d的比较 不同的电线组，所以现在

617
00:24:13,320 --> 00:24:14,820
我们要在 5 和 3 之间进行比较

618
00:24:14,820 --> 00:24:17,370
3 小于 5，所以 3

619
00:24:17,370 --> 00:24:17,940
在这里出现

620
00:24:17,940 --> 00:24:20,250
5 个出现在这里，现在在

621
00:24:20,250 --> 00:24:22,710
这里的这条线的情况下，没有其他

622
00:24:22,710 --> 00:24:24,419
比较器我们必须这样做，所以我们

623
00:24:24,419 --> 00:24:27,240


624
00:24:27,240 --> 00:24:30,269
如果下一个竞争对手是 9 和

625
00:24:30,269 --> 00:24:33,149
6 相同的东西 6 和 9 9 没有

626
00:24:33,149 --> 00:24:34,980
其他比较我们需要做的通用比较器

627
00:24:34,980 --> 00:24:36,600
，因此我们可以将其读取到输出

628
00:24:36,600 --> 00:24:39,600
缓冲区，然后我们将其与 5 进行比较，则可以将三个写入我们的输出缓冲区 六

629
00:24:39,600 --> 00:24:41,669
，我们在这里产生我们的输出，所以

630
00:24:41,669 --> 00:24:43,139
我们能够通过

631
00:24:43,139 --> 00:24:44,610
排序网络再次挂载我们能够获取一组

632
00:24:44,610 --> 00:24:48,179
任意排序的键，然后

633
00:24:48,179 --> 00:24:52,860
产生一个排序的输出缓冲区，

634
00:24:52,860 --> 00:24:54,629
所以真正有趣和酷

635
00:24:54,629 --> 00:24:57,750
的是，不管 我们的输入

636
00:24:57,750 --> 00:25:00,029
序列看起来像什么键 有什么键 他们

637
00:25:00,029 --> 00:25:01,919
开始的顺序是什么

638
00:25:01,919 --> 00:25:04,049
我们总是

639
00:25:04,049 --> 00:25:06,350
会每次都以相同的顺序进行相同的比较比较集

640
00:25:06,350 --> 00:25:09,269


641
00:25:09,269 --> 00:25:13,409
因为再次是这种

642
00:25:13,409 --> 00:25:15,059
排序 网络设置以这种方式工作，

643
00:25:15,059 --> 00:25:17,370
所以如果你现在采用这种

644
00:25:17,370 --> 00:25:18,629
概念模型并实际编写

645
00:25:18,629 --> 00:25:20,519
代码，我有一个非常简单的

646
00:25:20,519 --> 00:25:23,070
实现，就像我说的一样，

647
00:25:23,070 --> 00:25:25,379


648
00:25:25,379 --> 00:25:27,110
无论我们的输入是什么，你都会执行完全相同的步骤 序列实际上是

649
00:25:27,110 --> 00:25:30,210
正确的，所以你知道这里是第一

650
00:25:30,210 --> 00:25:32,580
组比较正确，第二组

651
00:25:32,580 --> 00:25:35,789
和第三组也是这样

652
00:25:35,789 --> 00:25:37,889


653
00:25:37,889 --> 00:25:39,659


654
00:25:39,659 --> 00:25:42,360


655
00:25:42,360 --> 00:25:43,860
我们有条件来决定

656
00:25:43,860 --> 00:25:45,750
轴心点在哪里你只是

657
00:25:45,750 --> 00:25:48,330
你每次都以完全相同的顺序执行它，

658
00:25:48,330 --> 00:25:50,610


659
00:25:50,610 --> 00:25:52,889
所以你有点认为这

660
00:25:52,889 --> 00:25:54,990
就像循环正确展开而不是

661
00:25:54,990 --> 00:25:58,590
让你知道而不是看

662
00:25:58,590 --> 00:26:00,149
从一个级别到下一个级别的一次迭代

663
00:26:00,149 --> 00:26:01,769
我只是展开它他有

664
00:26:01,769 --> 00:26:04,529
我想要执行的确切指令所以

665
00:26:04,529 --> 00:26:06,690
为什么现在这很重要这

666
00:26:06,690 --> 00:26:08,190
意味着我们实际上可以将其矢量化

667
00:26:08,190 --> 00:26:10,799
因为正如我在 ve 之前所说 构造

668
00:26:10,799 --> 00:26:13,230
指令汇编指令不

669
00:26:13,230 --> 00:26:15,960
支持条件分支，所以

670
00:26:15,960 --> 00:26:17,370
这里有一个简单的这里有一些你知道

671
00:26:17,370 --> 00:26:19,549
我们可以执行的代码

672
00:26:19,549 --> 00:26:21,419
序列不需要条件

673
00:26:21,419 --> 00:26:23,100
分支它总是需要

674
00:26:23,100 --> 00:26:24,629
以完全相同的顺序执行相同的指令

675
00:26:24,629 --> 00:26:26,190
每次

676
00:26:26,190 --> 00:26:28,379
只是为了删除周围的值，所以我们

677
00:26:28,379 --> 00:26:30,090
可以轻松地对其进行矢量化

678
00:26:30,090 --> 00:26:32,920
，这就是我们这样做的方式，所以现在

679
00:26:32,920 --> 00:26:35,880
要发生的不是对一个进行排序，而是对

680
00:26:35,880 --> 00:26:38,620
一个包含四个键的 Cindy 寄存器

681
00:26:38,620 --> 00:26:41,560
进行排序，我们将对包含四个键的四个寄存器进行排序

682
00:26:41,560 --> 00:26:46,030
密钥并行，所以

683
00:26:46,030 --> 00:26:47,230
对于这个，我们将假设

684
00:26:47,230 --> 00:26:52,300
我们在 d 寄存器中有 512 位，我们

685
00:26:52,300 --> 00:26:54,520
将有 128 位通道，

686
00:26:54,520 --> 00:26:56,470
所以每个通道都是 108 位，所以

687
00:26:56,470 --> 00:26:59,350
如果你在一个 512 位寄存器中存储四个密钥

688
00:26:59,350 --> 00:27:01,870
所以在这个例子中，

689
00:27:01,870 --> 00:27:04,660
我只显示键 hi，

690
00:27:04,660 --> 00:27:05,710
这是我们的键

691
00:27:05,710 --> 00:27:08,440
属性，但隐含地也会有

692
00:27:08,440 --> 00:27:11,620
一个 64 64 位指针返回

693
00:27:11,620 --> 00:27:13,960
到这个键对应的元组 响应

694
00:27:13,960 --> 00:27:16,420
，因此

695
00:27:16,420 --> 00:27:18,100
当您在 Cindy 中执行此排序时，您必须存储连接键，

696
00:27:18,100 --> 00:27:20,080
因为如果我现在存储这些键并

697
00:27:20,080 --> 00:27:22,210
提出不同的顺序，我将

698
00:27:22,210 --> 00:27:25,240
无法将键映射回

699
00:27:25,240 --> 00:27:28,120
它所属的元组 出于

700
00:27:28,120 --> 00:27:29,470
说明目的，我没有

701
00:27:29,470 --> 00:27:31,930
在这里显示元组指针，而是假设

702
00:27:31,930 --> 00:27:34,210
它实际上是两者，然后连接键

703
00:27:34,210 --> 00:27:36,640
位于更高级别的位中，因为现在

704
00:27:36,640 --> 00:27:38,710
当新比较 5

705
00:27:38,710 --> 00:27:40,660
是否小于或等于 1 时，有

706
00:27:40,660 --> 00:27:42,940
更大的木材 在 501 之间，最小值

707
00:27:42,940 --> 00:27:45,430
是最大值我基本上忽略

708
00:27:45,430 --> 00:27:47,260
了关键的这一部分，我全部都

709
00:27:47,260 --> 00:27:50,410
在这里看另一部分，所以这

710
00:27:50,410 --> 00:27:52,900
也是另一个原因，正如我上一

711
00:27:52,900 --> 00:27:57,300
堂课所说，英特尔论文谈到了

712
00:27:57,300 --> 00:28:01,300
你如何知道你可以 实现我在这里谈论的 Cindy 或

713
00:28:01,300 --> 00:28:02,890
矢量化排序合并联合算法

714
00:28:02,890 --> 00:28:04,930
，但

715
00:28:04,930 --> 00:28:06,670
当时他们无法真正做到这一点，

716
00:28:06,670 --> 00:28:09,610
因为您需要 512 位寄存器或

717
00:28:09,610 --> 00:28:11,200
Cindy red chairs，

718
00:28:11,200 --> 00:28:13,720
自 2017 年以来，我们实际上已经拥有了

719
00:28:13,720 --> 00:28:15,850
哥伦布 ia 2015 年

720
00:28:15,850 --> 00:28:16,890
2016 年

721
00:28:16,890 --> 00:28:20,170
AVX 512 发表的论文当时还没有出现，所以

722
00:28:20,170 --> 00:28:23,740
它们只对 32 位密钥和

723
00:28:23,740 --> 00:28:25,660
32 位指针进行操作，这在真实系统中

724
00:28:25,660 --> 00:28:27,190
实际上是行不通的，但现在在

725
00:28:27,190 --> 00:28:30,120
今天的硬件中我们实际上可以做到

726
00:28:30,120 --> 00:28:32,350
这很好，所以现在我们要做

727
00:28:32,350 --> 00:28:32,800
这种

728
00:28:32,800 --> 00:28:34,810
排序的方式只是我们想要再次

729
00:28:34,810 --> 00:28:38,620
想出我们想要为

730
00:28:38,620 --> 00:28:41,620
元素或关键排序运行生成 4 所以我们

731
00:28:41,620 --> 00:28:43,059
的运行包含 4 个大纲

732
00:28:43,059 --> 00:28:44,919
，我们不会但是 我们希望

733
00:28:44,919 --> 00:28:48,299
同时对同时运行进行排序，

734
00:28:48,299 --> 00:28:50,679
所以现在我们需要做的第一件事是

735
00:28:50,679 --> 00:28:54,519
将数据加载到我们的半寄存器中

736
00:28:54,519 --> 00:28:56,679
，假设这些数据在内存中是连续的，

737
00:28:56,679 --> 00:28:58,779
我们可以使用四个

738
00:28:58,779 --> 00:29:01,139
加载指令到寄存器中执行它，

739
00:29:01,139 --> 00:29:03,309
但是 现在我们要排序的

740
00:29:03,309 --> 00:29:05,259
方式是我们将以柱状方式对它进行排序，这

741
00:29:05,259 --> 00:29:09,519


742
00:29:09,519 --> 00:29:11,740
意味着我无法在单个寄存器中排序，

743
00:29:11,740 --> 00:29:13,720


744
00:29:13,720 --> 00:29:14,830
因为我们可用的 symbian 结构没有 那样工作

745
00:29:14,830 --> 00:29:18,039
，但我可以对寄存器

746
00:29:18,039 --> 00:29:20,289
进行排序 同一时间好吧，所以我要

747
00:29:20,289 --> 00:29:22,149
以柱状方式排序 所以在这种

748
00:29:22,149 --> 00:29:24,820
情况下，这里是九八六七

749
00:29:24,820 --> 00:29:26,559


750
00:29:26,559 --> 00:29:31,179


751
00:29:31,179 --> 00:29:33,999


752
00:29:33,999 --> 00:29:36,279
我们做的和我在最后一张

753
00:29:36,279 --> 00:29:38,559
幻灯片中展示的相同的极小值，但现在我只是用 Cindy 来做这个，

754
00:29:38,559 --> 00:29:41,769
所以在这种情况下，我需要做

755
00:29:41,769 --> 00:29:43,629
10 分钟和最大指令，这些指令被

756
00:29:43,629 --> 00:29:46,809
矢量化以产生输出，

757
00:29:46,809 --> 00:29:50,919
现在给我一个 柱状方式

758
00:29:50,919 --> 00:29:53,080
排序再次将寄存器中的这些

759
00:29:53,080 --> 00:29:55,899
元素或通道中的每一个视为

760
00:29:55,899 --> 00:29:58,210
进入我的排序网络的那些电线之一

761
00:29:58,210 --> 00:30:00,490
，我只是调用 min Max

762
00:30:00,490 --> 00:30:02,590
指令比较这两个和这

763
00:30:02,590 --> 00:30:03,970
两个然后这两个

764
00:30:03,970 --> 00:30:06,369
等等 取决于他们在最后一个插槽中所做的相同方式，

765
00:30:06,369 --> 00:30:08,259
因此再次只

766
00:30:08,259 --> 00:30:11,230
需要十个 minimax 指令，但

767
00:30:11,230 --> 00:30:12,789
现在问题又来了

768
00:30:12,789 --> 00:30:16,330


769
00:30:16,330 --> 00:30:19,149


770
00:30:19,149 --> 00:30:23,230
现在连续

771
00:30:23,230 --> 00:30:25,899
流行，因为如果 我把

772
00:30:25,899 --> 00:30:27,730
它写到内存中，这不是一种正确的运行

773
00:30:27,730 --> 00:30:31,149
5 4 小于 11

774
00:30:31,149 --> 00:30:33,100
但柠檬是第一位的，所以我现在想做一个

775
00:30:33,100 --> 00:30:35,169
转置以获取这一列

776
00:30:35,169 --> 00:30:37,080
并将其转换为行，

777
00:30:37,080 --> 00:30:39,460
所以有转置操作

778
00:30:39,460 --> 00:30:41,980
在 Cindy 中执行此操作然后现在我最终

779
00:30:41,980 --> 00:30:44,830
得到了我的四排序它运行正常

780
00:30:44,830 --> 00:30:47,019
所以现在再次交叉一个

781
00:30:47,019 --> 00:30:51,279
寄存器它已排序所以我现在需要

782
00:30:51,279 --> 00:30:53,169
八个随机指令来执行该

783
00:30:53,169 --> 00:30:55,269
转置然后现在

784
00:30:55,269 --> 00:30:56,809
要写出存储指令 寄存器

785
00:30:56,809 --> 00:31:01,580
健康的方式，所以在快速排序中

786
00:31:01,580 --> 00:31:02,990
，我们必须执行的指令数量

787
00:31:02,990 --> 00:31:05,840


788
00:31:05,840 --> 00:31:07,970
比我们在这里做的要多得多，所以

789
00:31:07,970 --> 00:31:10,610
假设

790
00:31:10,610 --> 00:31:13,340
加载操作只需要四四四条

791
00:31:13,340 --> 00:31:16,309
指令，这只有 26 条指令 我们需要 26 条指令来

792
00:31:16,309 --> 00:31:19,789
最终对 16 个键进行正确排序，或者有

793
00:31:19,789 --> 00:31:23,240
四个用于元素排序的运行，我们可以

794
00:31:23,240 --> 00:31:24,649
这样做，因为它是确定性的，所以

795
00:31:24,649 --> 00:31:25,999
这实际上是非常

796
00:31:25,999 --> 00:31:27,980
惊人的，这是

797
00:31:27,980 --> 00:31:30,619
对 d 的重大胜利 一定要做到这一点，但是现在

798
00:31:30,619 --> 00:31:31,999
我们现在有什么我们有

799
00:31:31,999 --> 00:31:34,279
一堆跨安大略钥匙的运行，

800
00:31:34,279 --> 00:31:35,600
这可能是十亿个

801
00:31:35,600 --> 00:31:37,850
钥匙，现在我们需要开始

802
00:31:37,850 --> 00:31:40,009
把这些东西放在一起，

803
00:31:40,009 --> 00:31:43,190
所以现在一旦我们一次 我们对表中的每

804
00:31:43,190 --> 00:31:46,340
一个键进行排序，然后我们

805
00:31:46,340 --> 00:31:47,779
现在进入第二级，我们想

806
00:31:47,779 --> 00:31:49,419
开始将它们组合成

807
00:31:49,419 --> 00:31:53,779
更大的排序运行，因此为了在第二级做到这一点，

808
00:31:53,779 --> 00:31:55,460
我们将使用

809
00:31:55,460 --> 00:31:58,789
所谓的唯特利合并网络和

810
00:31:58,789 --> 00:32:00,440
从高层次上看，它看起来像一个

811
00:32:00,440 --> 00:32:02,509
排序网络，但现在我们只能将

812
00:32:02,509 --> 00:32:05,509
较大的运行一起

813
00:32:05,509 --> 00:32:08,269
排序为本地

814
00:32:08,269 --> 00:32:09,830
排序的运行，然后再将全局排序的运行排序

815
00:32:09,830 --> 00:32:12,619
更大一点，然后我们继续这样做并

816
00:32:12,619 --> 00:32:14,179
扩展 网络，这只是意味着

817
00:32:14,179 --> 00:32:16,909
更多的空间更多更多的

818
00:32:16,909 --> 00:32:18,470
步骤和最小/最大指令的混洗，

819
00:32:18,470 --> 00:32:21,559
直到我们达到

820
00:32:21,559 --> 00:32:23,360
最后一级缓存大小的一半，因为

821
00:32:23,360 --> 00:32:27,019
然后我们

822
00:32:27,019 --> 00:32:30,799
在 2020 年的 l3 上再次跌入第三级  缓存

823
00:32:30,799 --> 00:32:33,679
大小大约是 36 到 40 兆字节 我

824
00:32:33,679 --> 00:32:36,559
认为我认为 AMD 会小于

825
00:32:36,559 --> 00:32:40,070
这个，所以这里不会谈论这项技术

826
00:32:40,070 --> 00:32:44,960
也是来自 Intel 它

827
00:32:44,960 --> 00:32:47,499
于 2008 年问世 它是

828
00:32:47,499 --> 00:32:49,789
Intel 的 hash join 论文的一年前

829
00:32:49,789 --> 00:32:52,909
我之所以喜欢这篇论文

830
00:32:52,909 --> 00:32:53,960
，我喜欢这种技术，是因为

831
00:32:53,960 --> 00:32:57,230
这实际上很重要，因为

832
00:32:57,230 --> 00:33:00,110
他们能够证明，通过

833
00:33:00,110 --> 00:33:01,730
在某些指挥棒沉浸网络的指挥棒中使用 Cindy 指令，

834
00:33:01,730 --> 00:33:04,789
您几乎

835
00:33:04,789 --> 00:33:08,809
可以达到 比

836
00:33:08,809 --> 00:33:09,440


837
00:33:09,440 --> 00:33:12,440
sty 左右的非矢量化实现提高了 3.5 倍

838
00:33:12,440 --> 00:33:17,049
，因此 3.5 x 是

839
00:33:17,049 --> 00:33:19,460
针对旧算法的算法，因为您

840
00:33:19,460 --> 00:33:22,429
现在真正要做的就是获得常数

841
00:33:22,429 --> 00:33:23,870
因子加速，因为我们正确地使用了

842
00:33:23,870 --> 00:33:25,669
哈佛 实际上很重要，

843
00:33:25,669 --> 00:33:27,440
我的意思是你认为

844
00:33:27,440 --> 00:33:29,169
像 1970 年代的快速搜索一样，

845
00:33:29,169 --> 00:33:31,940
我们没有魔杖可以制作

846
00:33:31,940 --> 00:33:33,409


847
00:33:33,409 --> 00:33:34,879
我们在计算机科学

848
00:33:34,879 --> 00:33:38,120
中一直使用的那种基本核心算法来更快地通过理论它' 只是通过

849
00:33:38,120 --> 00:33:40,299
确保我们正确使用港口，

850
00:33:40,299 --> 00:33:42,620
我们会变得更好并证明

851
00:33:42,620 --> 00:33:44,409
我们正在寻找

852
00:33:44,409 --> 00:33:48,440
所以我还要告诉你，这篇

853
00:33:48,440 --> 00:33:50,240
论文发表在 vldb 一个主要的

854
00:33:50,240 --> 00:33:52,490
戴维斯会议上英特尔显然不是

855
00:33:52,490 --> 00:33:53,870
一个数据库 公司，所以他们不在

856
00:33:53,870 --> 00:33:55,429
商业标志数据库中

857
00:33:55,429 --> 00:33:57,139
销售硬件，因此

858
00:33:57,139 --> 00:33:59,870
英特尔保持竞争力的方式不，我不想

859
00:33:59,870 --> 00:34:05,080
重新启动，感谢

860
00:34:05,080 --> 00:34:07,940
您想要的任何 Windows 嗯，所以英特尔不从事

861
00:34:07,940 --> 00:34:09,260
销售数据库的业务。

862
00:34:09,260 --> 00:34:10,460
转售港湾，因此他们保持

863
00:34:10,460 --> 00:34:12,050
竞争力的方式是他们添加新功能，

864
00:34:12,050 --> 00:34:14,530
如 Cindy 指令或

865
00:34:14,530 --> 00:34:16,250
非易失性存储器，我将

866
00:34:16,250 --> 00:34:17,540
在本学期稍后讨论

867
00:34:17,540 --> 00:34:19,719
，在硬件中添加额外的东西，

868
00:34:19,719 --> 00:34:22,159
你作为应用程序员或

869
00:34:22,159 --> 00:34:24,199
戴维斯系统 开发人员可以

870
00:34:24,199 --> 00:34:26,418
利用并真正了解

871
00:34:26,418 --> 00:34:30,530
购买新英特尔硬件的合理性

872
00:34:30,530 --> 00:34:32,810
，所以问题是如果

873
00:34:32,810 --> 00:34:33,889
这些东西超级复杂，那么

874
00:34:33,889 --> 00:34:36,290
没有人知道如何使用它们

875
00:34:36,290 --> 00:34:37,730
英特尔不会销售更多芯片，所以他们

876
00:34:37,730 --> 00:34:40,280
实际上已经推出了很

877
00:34:40,280 --> 00:34:41,810
长一段时间，并且实际上做了很好的研究，发布

878
00:34:41,810 --> 00:34:43,760
了

879
00:34:43,760 --> 00:34:46,040
易于理解的论文，易于阅读，向您展示

880
00:34:46,040 --> 00:34:49,280
如何应用您了解最新的

881
00:34:49,280 --> 00:34:51,050
增强功能和英特尔的硬件或 到

882
00:34:51,050 --> 00:34:52,849
两个数据库，所以这些论文

883
00:34:52,849 --> 00:34:54,500
总是很好读，并

884
00:34:54,500 --> 00:34:58,520
期待他们再次在高层次上大

885
00:34:58,520 --> 00:35:00,290
补剂合并网络看起来

886
00:35:00,290 --> 00:35:02,990
就像排序合并对它刚刚审查的排序网络感到抱歉

887
00:35:02,990 --> 00:35:04,730


888
00:35:04,730 --> 00:35:06,710
多个步骤，

889
00:35:06,710 --> 00:35:07,849
因为我们正在处理

890
00:35:07,849 --> 00:35:10,760
它运行的大型恢复所以说这现在在我们的输入

891
00:35:10,760 --> 00:35:12,500
大小方面，我们

892
00:35:12,500 --> 00:35:14,810
将从第一级开始采取两个元素排序运行

893
00:35:14,810 --> 00:35:16,160
，我们将把它们组合

894
00:35:16,160 --> 00:35:20,480
成一个八 元素输出缓冲区，因此

895
00:35:20,480 --> 00:35:22,520
需要两个来排序运行，因此第一个

896
00:35:22,520 --> 00:35:23,030
将

897
00:35:23,030 --> 00:35:26,260
与在级别 1 ii 中生成的顺序相同，

898
00:35:26,260 --> 00:35:28,220
尽管我们将按相反的顺序放置，

899
00:35:28,220 --> 00:35:31,010
因此在这种情况下，这里

900
00:35:31,010 --> 00:35:32,960
是此类运行的最小元素 是最后一个

901
00:35:32,960 --> 00:35:35,630
元素，对于这个元素，最大的

902
00:35:35,630 --> 00:35:37,490
元素是最后一个元素，

903
00:35:37,490 --> 00:35:38,870
原因是这样做，就在您

904
00:35:38,870 --> 00:35:42,890
开始进行评估时，

905
00:35:42,890 --> 00:35:46,280
它的效果会更好

906
00:35:46,280 --> 00:35:48,860


907
00:35:48,860 --> 00:35:50,030
将有一堆这些 min 和

908
00:35:50,030 --> 00:35:52,190
Max 与我们在矢量化之前拥有的相同

909
00:35:52,190 --> 00:35:53,960
，然后现在我们只是做

910
00:35:53,960 --> 00:35:55,730
更多的洗牌以在它们之间进行比较，

911
00:35:55,730 --> 00:35:58,340
直到我们产生最终输出

912
00:35:58,340 --> 00:36:02,000
和完全排序的运行

913
00:36:02,000 --> 00:36:03,830
以及关键的事情 关于这一点，特别是这种

914
00:36:03,830 --> 00:36:05,180
洗牌可以

915
00:36:05,180 --> 00:36:08,120
尽可能长时间地将所有内容保留在 CB 寄存器中，

916
00:36:08,120 --> 00:36:09,380
而不必将其

917
00:36:09,380 --> 00:36:14,810
带回 CPU 缓存中，因为

918
00:36:14,810 --> 00:36:15,980
这会

919
00:36:15,980 --> 00:36:20,960
减慢抢劫速度，然后现在一旦我们

920
00:36:20,960 --> 00:36:24,200
用完 现金基础我们将

921
00:36:24,200 --> 00:36:26,240
回到地球 下降到

922
00:36:26,240 --> 00:36:28,820
第三级 但是这将使用

923
00:36:28,820 --> 00:36:31,970
相同的步骤 与我们之前所做的程序相同

924
00:36:31,970 --> 00:36:32,360


925
00:36:32,360 --> 00:36:34,060


926
00:36:34,060 --> 00:36:36,410


927
00:36:36,410 --> 00:36:38,300
了解我们的 CPU 缓存上有哪些数据可用，

928
00:36:38,300 --> 00:36:41,030
并

929
00:36:41,030 --> 00:36:43,190
在我们跳转到另一个内存区域之前先对这些数据进行操作

930
00:36:43,190 --> 00:36:46,310
，所以我们让它

931
00:36:46,310 --> 00:36:48,050
在 torcida 缓存中获取，然后

932
00:36:48,050 --> 00:36:49,940
再继续执行，

933
00:36:49,940 --> 00:36:51,650
这里的想法是 我们将

934
00:36:51,650 --> 00:36:53,240
做一些额外的簿记以

935
00:36:53,240 --> 00:36:55,850
跟踪内存中的内容

936
00:36:55,850 --> 00:36:57,050
或说明 CPU

937
00:36:57,050 --> 00:36:59,060
缓存中的内容以及我们在管道中中断的内容

938
00:36:59,060 --> 00:37:00,980
，所有这些额外的

939
00:37:00,980 --> 00:37:02,360
指令可能会减慢我们

940
00:37:02,360 --> 00:37:05,270
的执行成本 额外的工作

941
00:37:05,270 --> 00:37:10,220
要少得多它会做这对我来说

942
00:37:10,220 --> 00:37:12,590
比在我们等待从内存中获取东西时必须在我们的线程中停顿要少得多

943
00:37:12,590 --> 00:37:14,750


944
00:37:14,750 --> 00:37:17,240
所以我们不会在

945
00:37:17,240 --> 00:37:20,000
每个线程运行时烧毁它总是

946
00:37:20,000 --> 00:37:21,530
有东西进入 CPU 缓存 它

947
00:37:21,530 --> 00:37:23,000
实际上可以非常有效，所以我们

948
00:37:23,000 --> 00:37:25,370
不会在我们的线程中

949
00:37:25,370 --> 00:37:27,290
从 CPU 绑定到内存

950
00:37:27,290 --> 00:37:29,660
带宽绑定，这总是

951
00:37:29,660 --> 00:37:31,070
说每次线程

952
00:37:31,070 --> 00:37:31,430
运行

953
00:37:31,430 --> 00:37:33,110
时总是有数据 在 CPU 缓存中，

954
00:37:33,110 --> 00:37:35,060
它通过每个周期的指令尽可能快地运行

955
00:37:35,060 --> 00:37:36,869


956
00:37:36,869 --> 00:37:39,299
在这种情况下会很高，所以我们将再次

957
00:37:39,299 --> 00:37:41,400
并行运行它，同时在多个

958
00:37:41,400 --> 00:37:42,479
内核中跟踪所有不同的

959
00:37:42,479 --> 00:37:43,759
内核正在做的线程正在做的事情

960
00:37:43,759 --> 00:37:48,269
并且在管道内，随着数据

961
00:37:48,269 --> 00:37:50,670
的到来，它来自第二级，或者

962
00:37:50,670 --> 00:37:53,309
通过

963
00:37:53,309 --> 00:37:56,039
我们的排序网络前进，在这里我们可以在

964
00:37:56,039 --> 00:37:57,180
外部跳转并在

965
00:37:57,180 --> 00:37:58,289
不同的部分工作，只需跟踪

966
00:37:58,289 --> 00:38:00,210
停止的位置，因此

967
00:38:00,210 --> 00:38:02,910
每个线程之间都没有同步

968
00:38:02,910 --> 00:38:04,079
线程知道需要操作什么

969
00:38:04,079 --> 00:38:05,880
，我们不需要做任何类型的

970
00:38:05,880 --> 00:38:07,410
全局操作，没有全局协调，

971
00:38:07,410 --> 00:38:08,609
每个线程都可以自己

972
00:38:08,609 --> 00:38:12,390
弄清楚它需要做什么，所以这实际上

973
00:38:12,390 --> 00:38:14,999
非常困难，非常

974
00:38:14,999 --> 00:38:17,130
复杂和最好 据我

975
00:38:17,130 --> 00:38:19,079
所知，没有数据库系统实际

976
00:38:19,079 --> 00:38:23,430
实现这一点，因为它做出了一个

977
00:38:23,430 --> 00:38:25,859
很大的假设，即

978
00:38:25,859 --> 00:38:28,589
所有你知道的所有线程

979
00:38:28,589 --> 00:38:33,029
都只是在 g 用于排序

980
00:38:33,029 --> 00:38:34,829
意味着没有其他查询在运行

981
00:38:34,829 --> 00:38:36,150
，没有其他类型的后台

982
00:38:36,150 --> 00:38:38,999
任务在运行，例如网络垃圾

983
00:38:38,999 --> 00:38:40,739
收集或索引它们就是这样的

984
00:38:40,739 --> 00:38:43,950
事情，所以我认为原因

985
00:38:43,950 --> 00:38:46,739
是因为如果你现在可以让不同的

986
00:38:46,739 --> 00:38:49,259
内核做不同的事情 不

987
00:38:49,259 --> 00:38:51,210
参与排序很难有

988
00:38:51,210 --> 00:38:52,769
那种精度，你

989
00:38:52,769 --> 00:38:54,630
需要识别我需要的数据

990
00:38:54,630 --> 00:38:56,759
是否在我的 CPU 缓存中或不在我的 CPU

991
00:38:56,759 --> 00:38:59,160
缓存中我认为所有这些都变得像

992
00:38:59,160 --> 00:39:01,049
我说的更复杂

993
00:39:01,049 --> 00:39:02,460
在排序过程之外，

994
00:39:02,460 --> 00:39:05,940
所以概念上看起来像

995
00:39:05,940 --> 00:39:07,289
这样，这些都是

996
00:39:07,289 --> 00:39:09,390
我们从第二级产生的所有类型的运行，然后

997
00:39:09,390 --> 00:39:12,150
我们想开始合并它们，

998
00:39:12,150 --> 00:39:14,849


999
00:39:14,849 --> 00:39:17,700
在这种情况下，当线程开始执行时会发生什么 在这里

1000
00:39:17,700 --> 00:39:19,200
，合并开始将数据耗尽到

1001
00:39:19,200 --> 00:39:21,869
这个队列中，在我们现在可以开始

1002
00:39:21,869 --> 00:39:25,319
进行下一次合并之前，我们

1003
00:39:25,319 --> 00:39:27,869
必须等待所有这些数据完成，而不是

1004
00:39:27,869 --> 00:39:29,069
在这里有一个线程 只是一种

1005
00:39:29,069 --> 00:39:30,869
自旋线程可以拾取并跳转到

1006
00:39:30,869 --> 00:39:33,539
这个多等待

1007
00:39:33,539 --> 00:39:35,969
网络的另一部分并处理那里的数据

1008
00:39:35,969 --> 00:39:37,739
，然后当这些数据最终

1009
00:39:37,739 --> 00:39:39,569
在我们的缓存中全部可用时，

1010
00:39:39,569 --> 00:39:41,099
线程可以返回并

1011
00:39:41,099 --> 00:39:44,670
从左到右拾取 基本上

1012
00:39:44,670 --> 00:39:46,950
每个阶段都有这个标志，我们

1013
00:39:46,950 --> 00:39:49,349
设置说没有什么可做的

1014
00:39:49,349 --> 00:39:49,990
，线程

1015
00:39:49,990 --> 00:39:51,880
检查它是否工作，然后当

1016
00:39:51,880 --> 00:39:54,400
线程实际可用时，

1017
00:39:54,400 --> 00:39:57,100
它有点像发布/订阅通知

1018
00:39:57,100 --> 00:39:59,100
，告诉某人嘿来了 并

1019
00:39:59,100 --> 00:40:01,360
开始处理我

1020
00:40:01,360 --> 00:40:03,670
队列中可用的数据，

1021
00:40:03,670 --> 00:40:05,200
这似乎对 CPU 缓存不利，

1022
00:40:05,200 --> 00:40:06,550
因为现在我们的线程

1023
00:40:06,550 --> 00:40:08,350
在程序的不同部分跳来跳去

1024
00:40:08,350 --> 00:40:10,060
，可以说是通过网络

1025
00:40:10,060 --> 00:40:12,100
来处理不同的事情

1026
00:40:12,100 --> 00:40:15,400
但同样，在我开始运行它们之前必须

1027
00:40:15,400 --> 00:40:17,110
等待缓存中的东西或

1028
00:40:17,110 --> 00:40:18,490
在 CPU 缓存中可用的代价

1029
00:40:18,490 --> 00:40:22,300


1030
00:40:22,300 --> 00:40:25,300
对你来说会少得多 知道

1031
00:40:25,300 --> 00:40:26,920
工作量 您必须再次花费的周期数

1032
00:40:26,920 --> 00:40:29,890
这是假设我

1033
00:40:29,890 --> 00:40:31,480
认为这是一个很大的假设，即您

1034
00:40:31,480 --> 00:40:32,740
可以完全控制所有

1035
00:40:32,740 --> 00:40:34,450
套接字和每个套接字上的所有线程

1036
00:40:34,450 --> 00:40:36,790
，我认为在真实系统中

1037
00:40:36,790 --> 00:40:42,790
事实并非如此，所以我

1038
00:40:42,790 --> 00:40:45,040
说不，据我所知，据我所知没有人

1039
00:40:45,040 --> 00:40:50,110
这样做 我还认为那里的

1040
00:40:50,110 --> 00:40:51,910
各种内存数据库供应商

1041
00:40:51,910 --> 00:40:53,770
每个人都在

1042
00:40:53,770 --> 00:40:55,570
为

1043
00:40:55,570 --> 00:40:57,510
基于磁盘的供应商做一些略有不同的事情 通常，如果所有内容都在内存中，您会看到

1044
00:40:57,510 --> 00:41:01,210
一个花哨的快速排序版本，

1045
00:41:01,210 --> 00:41:03,310
否则

1046
00:41:03,310 --> 00:41:05,170
当您必须溢出磁盘时，它们会进行额外的合并排序，

1047
00:41:05,170 --> 00:41:07,300
但我想简单谈谈

1048
00:41:07,300 --> 00:41:12,250
我们在系统中所做的事情，有些

1049
00:41:12,250 --> 00:41:13,240
时候我们应该去看看 内存中

1050
00:41:13,240 --> 00:41:14,710
的其他供应商 Ben Davis 供应

1051
00:41:14,710 --> 00:41:17,710
商实际上在做什么，所以我们使用了一种

1052
00:41:17,710 --> 00:41:19,180
称为就地超标量样本

1053
00:41:19,180 --> 00:41:22,000
支持的东西，这是一篇

1054
00:41:22,000 --> 00:41:26,140
由卡尔斯鲁厄的其他德国人于 2017 年发表的论文，也是

1055
00:41:26,140 --> 00:41:29,619
我想要的主要内容 要

1056
00:41:29,619 --> 00:41:33,070
讨论的是，它是一个开源的

1057
00:41:33,070 --> 00:41:35,170
好库，我们刚刚将其链接

1058
00:41:35,170 --> 00:41:36,609
到我们的系统中，因此我们不是

1059
00:41:36,609 --> 00:41:38,680
空的并且使用他们的实现免费实现了这一点，

1060
00:41:38,680 --> 00:41:41,380
但

1061
00:41:41,380 --> 00:41:43,200
考虑这一点的基本方法是它

1062
00:41:43,200 --> 00:41:45,630
使用样本排序 这是

1063
00:41:45,630 --> 00:41:47,500
快速排序的一般化快速

1064
00:41:47,500 --> 00:41:50,470
排序只有你知道有

1065
00:41:50,470 --> 00:41:52,030
一个枢轴点

1066
00:41:52,030 --> 00:41:55,540
在样本排序的每个步骤中将它分成两部分你

1067
00:41:55,540 --> 00:41:57,190
采样一些键并决定

1068
00:41:57,190 --> 00:41:59,770


1069
00:41:59,770 --> 00:42:00,609
你想要

1070
00:42:00,609 --> 00:42:03,309
生成多少分区或任何桶 并且你服务发生了 Sulli 这样做了，

1071
00:42:03,309 --> 00:42:06,239
但是关于这个

1072
00:42:06,239 --> 00:42:09,549
让它工作得很好的关键是它正在

1073
00:42:09,549 --> 00:42:12,669
做这一切，这意味着它没有

1074
00:42:12,669 --> 00:42:14,559
真正到位，但这只是

1075
00:42:14,559 --> 00:42:17,499
意味着你需要的额外存储空间量

1076
00:42:17,499 --> 00:42:20,709
当您开始移动它时，它

1077
00:42:20,709 --> 00:42:23,859
会被捕获

1078
00:42:23,859 --> 00:42:26,559
到婴儿总大小的常数因子，因此

1079
00:42:26,559 --> 00:42:28,209
当您开始将数据拆分时会发生什么

1080
00:42:28,209 --> 00:42:31,059


1081
00:42:31,059 --> 00:42:32,380


1082
00:42:32,380 --> 00:42:34,059
当上层

1083
00:42:34,059 --> 00:42:36,579
输出缓冲区已满时写入输出缓冲区，而不是

1084
00:42:36,579 --> 00:42:38,799
分配新的上层缓冲区，然后

1085
00:42:38,799 --> 00:42:41,159
尝试将其写回密钥

1086
00:42:41,159 --> 00:42:44,469
空间 - 覆盖

1087
00:42:44,469 --> 00:42:45,459
已分区的密钥空间的另一部分，

1088
00:42:45,459 --> 00:42:47,259
以便您 不

1089
00:42:47,259 --> 00:42:49,059
浪费空间是不是你没有分配

1090
00:42:49,059 --> 00:42:50,409
更多的内存，然后

1091
00:42:50,409 --> 00:42:53,469
你实际上需要它也会

1092
00:42:53,469 --> 00:42:56,289
针对超标量架构进行优化，

1093
00:42:56,289 --> 00:42:57,369
这意味着它们是一种避免

1094
00:42:57,369 --> 00:42:59,259
条件分支的方式

1095
00:42:59,259 --> 00:43:01,299
，与我们之前讨论的方式和方式

1096
00:43:01,299 --> 00:43:03,339
相同 这是通过比较通常

1097
00:43:03,339 --> 00:43:04,569
有条件地执行

1098
00:43:04,569 --> 00:43:07,209
Christa copilot 可以为我们生成的指令的键，所以我们

1099
00:43:07,209 --> 00:43:09,929
再次在我们的实现中使用它

1100
00:43:09,929 --> 00:43:14,259
，至少从本文中得到的研究结果

1101
00:43:14,259 --> 00:43:15,939
表明它

1102
00:43:15,939 --> 00:43:18,729
明显优于

1103
00:43:18,729 --> 00:43:23,289
quick 的一些更优化的版本，所以好吧

1104
00:43:23,289 --> 00:43:25,890
所以这又是排序阶段，

1105
00:43:25,890 --> 00:43:29,259
我们已经取得了我们的关系，并

1106
00:43:29,259 --> 00:43:31,419
在连接键上对它们进行了排序，但现在我们

1107
00:43:31,419 --> 00:43:33,039
想让我们的迭代器走

1108
00:43:33,039 --> 00:43:36,880
通过两个表并比较

1109
00:43:36,880 --> 00:43:38,999
来自外部和内部的两个极点，

1110
00:43:38,999 --> 00:43:41,529
如果匹配，则我们制作一个副本

1111
00:43:41,529 --> 00:43:44,769
并将其放入输出缓冲区中，因此在我们的

1112
00:43:44,769 --> 00:43:47,289
井中，我们今天将在这里讨论

1113
00:43:47,289 --> 00:43:48,579
我们不会很快 必须回溯

1114
00:43:48,579 --> 00:43:51,999
但如果你必须认识到如果

1115
00:43:51,999 --> 00:43:53,709
我有它 如果我有多个键 我们将

1116
00:43:53,709 --> 00:43:55,329
多个元组排序到同一个键 我

1117
00:43:55,329 --> 00:43:58,019
可能需要在内表上回溯

1118
00:43:58,019 --> 00:44:00,429
但我们现在可以在高级别忽略它

1119
00:44:00,429 --> 00:44:02,289
我们

1120
00:44:02,289 --> 00:44:04,140
今天将在这里讨论的算法 我的工作方式

1121
00:44:04,140 --> 00:44:06,789
都是一样的，所以就像在排序阶段，当

1122
00:44:06,789 --> 00:44:07,959
我们想要拆分它并运行那些

1123
00:44:07,959 --> 00:44:09,939
多个线程时，我们想要在这里做同样的

1124
00:44:09,939 --> 00:44:11,769
事情，我们想让多个

1125
00:44:11,769 --> 00:44:14,289
线程扫描 外部内部

1126
00:44:14,289 --> 00:44:16,450
表并行，以便我们

1127
00:44:16,450 --> 00:44:18,280
更快地执行此操作，当然这

1128
00:44:18,280 --> 00:44:21,400
也意味着现在我们希望我们希望

1129
00:44:21,400 --> 00:44:23,079
它们

1130
00:44:23,079 --> 00:44:26,109
在此过程中不需要任何同步，

1131
00:44:26,109 --> 00:44:28,540
以便它们基本上可以以几乎

1132
00:44:28,540 --> 00:44:29,950
裸机速度运行，因此没有任何排序

1133
00:44:29,950 --> 00:44:32,920
全球创意 决定您知道谁在正确

1134
00:44:32,920 --> 00:44:34,440
读取那条数据的桃子，

1135
00:44:34,440 --> 00:44:39,220
因此我们可以这样做，如果我们

1136
00:44:39,220 --> 00:44:40,960
拥有分离

1137
00:44:40,960 --> 00:44:42,609
输出缓冲区的所有权利，如果您必须

1138
00:44:42,609 --> 00:44:43,990
写入相同的输出缓冲区，然后您

1139
00:44:43,990 --> 00:44:46,329
必须执行比较 并交换

1140
00:44:46,329 --> 00:44:47,680
取出您知道要写入的插槽

1141
00:44:47,680 --> 00:44:49,660
，据我所知，每个人

1142
00:44:49,660 --> 00:44:53,050
总是并行执行此操作，因此

1143
00:44:53,050 --> 00:44:55,329
如果您只想

1144
00:44:55,329 --> 00:44:57,070
在查询中执行 order by 而不是

1145
00:44:57,070 --> 00:45:01,810
join 只是对

1146
00:45:01,810 --> 00:45:04,570
聚合或不同的排序或排序 但您

1147
00:45:04,570 --> 00:45:06,310
在我们刚刚谈到的排序阶段停止

1148
00:45:06,310 --> 00:45:07,359
了 您不必执行此合并

1149
00:45:07,359 --> 00:45:09,220
步骤 合并步骤仅用于

1150
00:45:09,220 --> 00:45:14,290
执行 soltner join 所以我现在想谈谈

1151
00:45:14,290 --> 00:45:18,160
三种不同的方法来做

1152
00:45:18,160 --> 00:45:19,930
断言合并，所以做了这个

1153
00:45:19,930 --> 00:45:21,400
合并阶段并将它们放在一起，

1154
00:45:21,400 --> 00:45:24,940
所以前两个来自 ETH 论文

1155
00:45:24,940 --> 00:45:27,130
，你们从瑞士的家伙那里读到的

1156
00:45:27,130 --> 00:45:29,050
，然后

1157
00:45:29,050 --> 00:45:31,869
这里的最后一个来自 超级家伙这

1158
00:45:31,869 --> 00:45:33,970
是纸 他们在 2012 年写道，

1159
00:45:33,970 --> 00:45:36,040
这是进行连接的最佳方式，

1160
00:45:36,040 --> 00:45:38,380
这甚至比散列

1161
00:45:38,380 --> 00:45:40,510
连接更好，然后第二年他们

1162
00:45:40,510 --> 00:45:42,130
放弃了这一点，转而

1163
00:45:42,130 --> 00:45:45,369
完全进行散列连接，所以你们阅读的论文

1164
00:45:45,369 --> 00:45:46,690
基本上表明 这种

1165
00:45:46,690 --> 00:45:48,880
方法与

1166
00:45:48,880 --> 00:45:50,710
超级德国人吹捧的一样多，真是

1167
00:45:50,710 --> 00:45:54,400
太神奇了，它会被

1168
00:45:54,400 --> 00:45:56,200
马耳他波排序合并的第一个压垮，

1169
00:45:56,200 --> 00:45:57,640
所以当你

1170
00:45:57,640 --> 00:45:58,599
逐一浏览这些方法时，

1171
00:45:58,599 --> 00:46:00,400
看看他们是如何设置的 起来

1172
00:46:00,400 --> 00:46:01,869
看看它们有什么不同，然后我们将

1173
00:46:01,869 --> 00:46:03,099
进行评估并查看

1174
00:46:03,099 --> 00:46:08,970
性能数据

1175
00:46:10,900 --> 00:46:13,700
，梗犬询问跳跃超级

1176
00:46:13,700 --> 00:46:15,790
德国人是否与

1177
00:46:15,790 --> 00:46:19,220
就地超标量合并相同，整理出

1178
00:46:19,220 --> 00:46:21,230
这些是不同的德国人

1179
00:46:21,230 --> 00:46:24,349
超级德国人和慕尼黑 排序

1180
00:46:24,349 --> 00:46:27,050
算法 德国人在 arrancars

1181
00:46:27,050 --> 00:46:31,569
不同的人 不同的德国人 好的

1182
00:46:31,569 --> 00:46:34,160
所以第一个将是这种

1183
00:46:34,160 --> 00:46:35,990
多向搜索 所以多维

1184
00:46:35,990 --> 00:46:38,960
排序合并 所以这里的想法是

1185
00:46:38,960 --> 00:46:41,150
对于外部表，我们将让

1186
00:46:41,150 --> 00:46:44,740
所有课程使用我们之前讨论过的一级二级方法并行对数据进行排序，

1187
00:46:44,740 --> 00:46:47,119


1188
00:46:47,119 --> 00:46:48,559


1189
00:46:48,559 --> 00:46:51,020
然后他们将

1190
00:46:51,020 --> 00:46:55,339
在他们的业务核心之间重新分配数据，

1191
00:46:55,339 --> 00:46:56,660
再做一轮我喜欢一个范围

1192
00:46:56,660 --> 00:46:59,059
分区并进行多工资

1193
00:46:59,059 --> 00:47:00,980
合并排序，否则他们最终会

1194
00:47:00,980 --> 00:47:02,059
从我们之前谈到的第三级合并，

1195
00:47:02,059 --> 00:47:05,300
我们现在将

1196
00:47:05,300 --> 00:47:07,210
在我们的表中做同样的事情，这意味着现在

1197
00:47:07,210 --> 00:47:11,109
我们在排序阶段结束时有

1198
00:47:11,109 --> 00:47:15,380
在每个核心，我们都有

1199
00:47:15,380 --> 00:47:17,809
一个数据分区，我们知道

1200
00:47:17,809 --> 00:47:21,290
对于外表中的任何元组，它

1201
00:47:21,290 --> 00:47:24,160
必须存在或不存在

1202
00:47:24,160 --> 00:47:26,270
于内表的相应分区中，

1203
00:47:26,270 --> 00:47:28,730
并且该元组不能存在于任何

1204
00:47:28,730 --> 00:47:31,160
其他分区中 好吧，这

1205
00:47:31,160 --> 00:47:32,720
就像通过分解

1206
00:47:32,720 --> 00:47:35,000
成桶或分区的宽限期哈希联合我知道

1207
00:47:35,000 --> 00:47:36,470
我正在寻找的数据必须

1208
00:47:36,470 --> 00:47:37,640
在另一个分区中，它不存在

1209
00:47:37,640 --> 00:47:39,500
，然后不存在，我知道我知道

1210
00:47:39,500 --> 00:47:42,079
我 不要 需要检查其他任何东西，所以

1211
00:47:42,079 --> 00:47:43,569
这实际上会

1212
00:47:43,569 --> 00:47:48,260
成为最好的方法 我

1213
00:47:48,260 --> 00:47:50,059
还要说的重要一点是，在这种情况下

1214
00:47:50,059 --> 00:47:51,980
，您知道我说过多路

1215
00:47:51,980 --> 00:47:54,140
合并很复杂，并且没有真正的系统

1216
00:47:54,140 --> 00:47:55,849
实际实现这一点，所以 对于这篇

1217
00:47:55,849 --> 00:47:58,270
论文，这是一个

1218
00:47:58,270 --> 00:48:02,660
类似于哥伦比亚论文的测试平台系统，据

1219
00:48:02,660 --> 00:48:04,640
我所知它只进行连接，所以他们

1220
00:48:04,640 --> 00:48:05,900
不担心来自

1221
00:48:05,900 --> 00:48:07,099
系统中同时运行的其他线程的干扰，

1222
00:48:07,099 --> 00:48:08,690
它只是进行

1223
00:48:08,690 --> 00:48:11,630
连接所以 让我们看看它

1224
00:48:11,630 --> 00:48:13,730
在高层次上的样子 所以说这是我们的外部

1225
00:48:13,730 --> 00:48:15,650
表 所以一开始

1226
00:48:15,650 --> 00:48:17,119
我们只是要让本地 Numa

1227
00:48:17,119 --> 00:48:19,579
分区就像我们

1228
00:48:19,579 --> 00:48:21,680
在 hyper for morsels 中谈到的一样 我

1229
00:48:21,680 --> 00:48:23,900
只是数据块

1230
00:48:23,900 --> 00:48:26,150
未排序的表是我们每个人的本地表，它

1231
00:48:26,150 --> 00:48:27,950
倒入我们的每个

1232
00:48:27,950 --> 00:48:30,590
线程，所以现在每个线程将

1233
00:48:30,590 --> 00:48:33,620
采用其本地本地分区，

1234
00:48:33,620 --> 00:48:35,660
并且将进行本地排序，因此这

1235
00:48:35,660 --> 00:48:38,030
将是级别 1 级别 2 排序

1236
00:48:38,030 --> 00:48:40,330
我们之前讨论的那种方式

1237
00:48:40,330 --> 00:48:42,680
现在在下一步中我们想要

1238
00:48:42,680 --> 00:48:44,960
进行多路合并，我们将在每个核心

1239
00:48:44,960 --> 00:48:48,440
的给定范围内将值组合在一起，

1240
00:48:48,440 --> 00:48:52,070
并将它们移动

1241
00:48:52,070 --> 00:48:54,740
到单个核心上，因此为此

1242
00:48:54,740 --> 00:48:56,270
这里的第一种块说

1243
00:48:56,270 --> 00:48:57,650
我们知道范围的第一种范围是

1244
00:48:57,650 --> 00:48:59,120
因为我们已经扫描到数据，

1245
00:48:59,120 --> 00:49:01,460
一旦在同一范围内对应的所有数据

1246
00:49:01,460 --> 00:49:03,110
都将被

1247
00:49:03,110 --> 00:49:06,890
写入这里的核心，

1248
00:49:06,890 --> 00:49:10,910
然后现在 我们讨论过的多路或

1249
00:49:10,910 --> 00:49:12,350
三级合并

1250
00:49:12,350 --> 00:49:14,420
，我们正在

1251
00:49:14,420 --> 00:49:16,160


1252
00:49:16,160 --> 00:49:19,610
根据

1253
00:49:19,610 --> 00:49:22,100
我们的 CPU 缓存中的内容跳转到执行流程的不同部分，

1254
00:49:22,100 --> 00:49:23,560


1255
00:49:23,560 --> 00:49:26,270
所以我们这样做 现在对于所有

1256
00:49:26,270 --> 00:49:28,760
其他数据，对于所有其他数据，同样的事情这将

1257
00:49:28,760 --> 00:49:30,110
并行发生，这不是我们一次做

1258
00:49:30,110 --> 00:49:31,580
这些，而是每个核心

1259
00:49:31,580 --> 00:49:32,900
都会从其他其他核心获取他们需要的所有数据

1260
00:49:32,900 --> 00:49:35,210
，并以多种方式执行，

1261
00:49:35,210 --> 00:49:38,930
先生 多聚体在这里然后现在wha

1262
00:49:38,930 --> 00:49:42,230
我们现在有我们的外表吗

1263
00:49:42,230 --> 00:49:46,640
我们有一个全局排序的全局排序

1264
00:49:46,640 --> 00:49:51,800
表 所以现在在内

1265
00:49:51,800 --> 00:49:53,570


1266
00:49:53,570 --> 00:49:55,430
表上，为了空间，我们正在做与外表完全相同的事情，

1267
00:49:55,430 --> 00:49:57,410
因为屏幕看起来都是这样 大

1268
00:49:57,410 --> 00:49:58,670
我只想说有这个小

1269
00:49:58,670 --> 00:50:00,470
排序框，但它正在执行与我们在这里看到的相同的

1270
00:50:00,470 --> 00:50:02,390
多波合并排序和多合并

1271
00:50:02,390 --> 00:50:04,760
，所以现在我们有什么

1272
00:50:04,760 --> 00:50:07,490
我们拥有每个

1273
00:50:07,490 --> 00:50:10,550
内核再次我们有一个分区范围

1274
00:50:10,550 --> 00:50:12,920
分区块 我们

1275
00:50:12,920 --> 00:50:16,010
知道某个键存在于该

1276
00:50:16,010 --> 00:50:17,870
分区中或根本不存在的数据，

1277
00:50:17,870 --> 00:50:19,760
因为您知道应该将键 5

1278
00:50:19,760 --> 00:50:21,530
映射到此处

1279
00:50:21,530 --> 00:50:23,360
，当我们尝试进行连接时，我们不会在任何其他位置找到它

1280
00:50:23,360 --> 00:50:25,940
所以现在我们做这个本地

1281
00:50:25,940 --> 00:50:27,830
合并点，我们让每个线程

1282
00:50:27,830 --> 00:50:30,440
只读取它本地的数据，

1283
00:50:30,440 --> 00:50:32,060
同时运行两个迭代器

1284
00:50:32,060 --> 00:50:34,350
进行比较，

1285
00:50:34,350 --> 00:50:36,330
每个线程将一个匹配的元组写出

1286
00:50:36,330 --> 00:50:39,710
到它自己的输出

1287
00:50:39,710 --> 00:50:42,900
缓冲区 思考方式 关于这个算法

1288
00:50:42,900 --> 00:50:45,030
在这里发生的是，当我们这样做时，我们

1289
00:50:45,030 --> 00:50:47,490
在开始时要付出代价来进行远程

1290
00:50:47,490 --> 00:50:51,060
写入，因此

1291
00:50:51,060 --> 00:50:52,860
在不同的过程中进行合并，

1292
00:50:52,860 --> 00:50:56,790
但这意味着现在当我们

1293
00:50:56,790 --> 00:50:59,310
进行排序合并阶段或合并的合并时

1294
00:50:59,310 --> 00:51:01,680
排序合并阶段的阶段

1295
00:51:01,680 --> 00:51:03,570
实际上是某个合并连接的合并阶段，

1296
00:51:03,570 --> 00:51:06,750
我们不必

1297
00:51:06,750 --> 00:51:08,870
从新的 Marie Jeanette

1298
00:51:08,870 --> 00:51:11,400
对我们进行任何远程读取，我们就在本地睡觉，这将

1299
00:51:11,400 --> 00:51:16,230
非常快 来自 ETH 的下一个是

1300
00:51:16,230 --> 00:51:20,340
多通道排序合并连接，因此外部

1301
00:51:20,340 --> 00:51:21,960
表将执行与我们

1302
00:51:21,960 --> 00:51:24,840
在第一级的最后一个级别中所做的相同的事情，

1303
00:51:24,840 --> 00:51:26,760
第二级将在本地对我们的数据进行排序，

1304
00:51:26,760 --> 00:51:29,490
但现在不是

1305
00:51:29,490 --> 00:51:32,370
通过这种多路合并将数据重新分配到不同的核心

1306
00:51:32,370 --> 00:51:36,800
我们只是要在内侧

1307
00:51:36,800 --> 00:51:39,660
的整个桌子上进行比较

1308
00:51:39,660 --> 00:51:42,060
，看看我们是否有

1309
00:51:42,060 --> 00:51:45,330
匹配，这可能需要我们进行

1310
00:51:45,330 --> 00:51:46,920
多次传递，因此名称 multi

1311
00:51:46,920 --> 00:51:49,620
pass over the table 为每个单独

1312
00:51:49,620 --> 00:51:50,790
去找到 我们正在

1313
00:51:50,790 --> 00:51:52,920
寻找正确的数据，因此在这种情况

1314
00:51:52,920 --> 00:51:54,270
下，合并阶段只是在内部表中寻找

1315
00:51:54,270 --> 00:51:55,380
与外部表匹配的块对，

1316
00:51:55,380 --> 00:51:57,720
并且

1317
00:51:57,720 --> 00:52:00,200
可能跨越不同的 Numa 区域，

1318
00:52:00,200 --> 00:52:03,180
因此从概念上讲，它看起来像

1319
00:52:03,180 --> 00:52:04,800
以前一样 我们有相同的本地

1320
00:52:04,800 --> 00:52:08,060
Numa 分区我们使用相同的本地

1321
00:52:08,060 --> 00:52:11,010
本地排序和每个分区使用

1322
00:52:11,010 --> 00:52:14,220
l1 l1 l2 方法然后现在我们将进行

1323
00:52:14,220 --> 00:52:16,740
全局合并连接，其中对于我们得到的外部表

1324
00:52:16,740 --> 00:52:19,410
上的每个线程或每个单个数据块

1325
00:52:19,410 --> 00:52:22,170
扫描内部表

1326
00:52:22,170 --> 00:52:25,260
上的每一个数据块

1327
00:52:25,260 --> 00:52:27,810
，所有

1328
00:52:27,810 --> 00:52:28,950
线程将同时并行执行此操作，

1329
00:52:28,950 --> 00:52:30,930
因此您

1330
00:52:30,930 --> 00:52:32,940
无论如何都有连接

1331
00:52:32,940 --> 00:52:34,110
，每个人都在从其他人那里读取数据，

1332
00:52:34,110 --> 00:52:37,860
所以我们 现在看看，

1333
00:52:37,860 --> 00:52:39,810
如果你下一张幻灯片，超级家伙

1334
00:52:39,810 --> 00:52:41,250
会声称这不会有

1335
00:52:41,250 --> 00:52:44,040
什么大不了的，因为鹰身女妖

1336
00:52:44,040 --> 00:52:47,040
会帮助我们，但事实并非

1337
00:52:47,040 --> 00:52:48,670


1338
00:52:48,670 --> 00:52:50,630
如此 最后一个再次来自

1339
00:52:50,630 --> 00:52:52,609
超级家伙，所以这是大规模并行

1340
00:52:52,609 --> 00:52:54,619
排序合并，因此我们

1341
00:52:54,619 --> 00:52:56,959
将对外部表进行范围分区，将

1342
00:52:56,959 --> 00:52:58,910
其重新分配到内核中，然后现在每个

1343
00:52:58,910 --> 00:53:00,769
内核

1344
00:53:00,769 --> 00:53:02,569
将对分区中的本地本地数据进行

1345
00:53:02,569 --> 00:53:05,059
并行排序 我们根本不会重新分配内部表，我们只是

1346
00:53:05,059 --> 00:53:06,499
在

1347
00:53:06,499 --> 00:53:08,479
本地对其进行排序，以获取

1348
00:53:08,479 --> 00:53:11,299
他们拥有的任何数据，然后当我们进行合并

1349
00:53:11,299 --> 00:53:14,930
阶段时，跨不同线程的扫描

1350
00:53:14,930 --> 00:53:17,180
我们停止跨

1351
00:53:17,180 --> 00:53:18,319
不同线程的每个单独的立场

1352
00:53:18,319 --> 00:53:19,819
线程在外表上的每个

1353
00:53:19,819 --> 00:53:22,069
分区上，但由于

1354
00:53:22,069 --> 00:53:27,349
我们知道我们的数据是排序的，所以我们

1355
00:53:27,349 --> 00:53:29,569
知道内表的边界，我们

1356
00:53:29,569 --> 00:53:30,739
实际上需要处理它们，我们

1357
00:53:30,739 --> 00:53:34,190
不必扫描内表的整个

1358
00:53:34,190 --> 00:53:36,440
分区 每次我们

1359
00:53:36,440 --> 00:53:39,979
想要进行查找时，表看起来都一样

1360
00:53:39,979 --> 00:53:42,859


1361
00:53:42,859 --> 00:53:45,369


1362
00:53:45,369 --> 00:53:48,319


1363
00:53:48,319 --> 00:53:51,079


1364
00:53:51,079 --> 00:53:52,999
转到不同的分区，因此您

1365
00:53:52,999 --> 00:53:55,339
在开始时进行了远程写入，然后

1366
00:53:55,339 --> 00:53:57,979
在本地进行了大量排序

1367
00:53:57,979 --> 00:54:00,489
，这些将进行全局

1368
00:54:00,489 --> 00:54:03,529
排序，外部表会很抱歉，

1369
00:54:03,529 --> 00:54:05,089
内部表将仅在本地进行排序，

1370
00:54:05,089 --> 00:54:08,180
然后现在当我 做我的加入我必须

1371
00:54:08,180 --> 00:54:10,219
跨分区所以我要在这里

1372
00:54:10,219 --> 00:54:12,650
扫描现在扫描内部表中的每个元组

1373
00:54:12,650 --> 00:54:14,749
但只扫描一部分

1374
00:54:14,749 --> 00:54:16,249
抱歉每次扫描

1375
00:54:16,249 --> 00:54:18,559
外部表上的整个分区但

1376
00:54:18,559 --> 00:54:20,660
现在只扫描一部分

1377
00:54:20,660 --> 00:54:22,910
在内表上进行分区，但我必须为

1378
00:54:22,910 --> 00:54:24,680
每个分区都这样做才能找到

1379
00:54:24,680 --> 00:54:26,509
我正在寻找的所有数据，当然

1380
00:54:26,509 --> 00:54:28,999
我可以同时在所有线程中并行执行此操作，

1381
00:54:28,999 --> 00:54:30,619
但

1382
00:54:30,619 --> 00:54:32,119
每个人都必须这样做 完全相同的

1383
00:54:32,119 --> 00:54:33,910
事情

1384
00:54:33,910 --> 00:54:37,309
所以超级超级家伙会

1385
00:54:37,309 --> 00:54:42,019
争辩说，在所有这些情况下，您都

1386
00:54:42,019 --> 00:54:46,039
在进行顺序读取，所以我们还没有

1387
00:54:46,039 --> 00:54:47,299
真正谈论过集线器预取，

1388
00:54:47,299 --> 00:54:48,799
但我们在谈论 ab 时谈到了软件预取

1389
00:54:48,799 --> 00:54:51,319
在轻松的

1390
00:54:51,319 --> 00:54:52,910
操作符融合中，我们

1391
00:54:52,910 --> 00:54:54,289
有特殊指令告诉

1392
00:54:54,289 --> 00:54:56,150
CPU 嘿，我很快就会需要这些数据，

1393
00:54:56,150 --> 00:54:58,489
并

1394
00:54:58,489 --> 00:55:00,680
在港口本身

1395
00:55:00,680 --> 00:55:01,730
试图

1396
00:55:01,730 --> 00:55:02,869
找出您的访问模式的同时引入我的 CPU 缓存 比如

1397
00:55:02,869 --> 00:55:04,670
，如果它识别出你正在

1398
00:55:04,670 --> 00:55:06,500
对某个

1399
00:55:06,500 --> 00:55:08,990
内存或内存区域进行顺序扫描，它就会

1400
00:55:08,990 --> 00:55:11,090
开始尝试为你预取该数据，

1401
00:55:11,090 --> 00:55:11,990
因为它认为你会继续

1402
00:55:11,990 --> 00:55:14,720
扫描它，所以超级

1403
00:55:14,720 --> 00:55:18,140
家伙争辩说 在这一步中

1404
00:55:18,140 --> 00:55:20,300
，当您开始远程读取

1405
00:55:20,300 --> 00:55:23,570
不同的新 Murray jhin 时，港口

1406
00:55:23,570 --> 00:55:24,859
正在意识到我正在

1407
00:55:24,859 --> 00:55:26,690
对这些远程区域进行特殊扫描，

1408
00:55:26,690 --> 00:55:28,640
并开始通过互连预取它

1409
00:55:28,640 --> 00:55:29,990
并将其带到您的

1410
00:55:29,990 --> 00:55:32,630
本地本地 CPU 缓存和 你的 Numa

1411
00:55:32,630 --> 00:55:34,730
区域，这样这会隐藏

1412
00:55:34,730 --> 00:55:37,310
对你的任何惩罚，你会因为

1413
00:55:37,310 --> 00:55:40,400
阅读真相而做这些事情，虽然

1414
00:55:40,400 --> 00:55:41,600
这实际上并不是

1415
00:55:41,600 --> 00:55:44,210
这样，而且 e 和瑞士人

1416
00:55:44,210 --> 00:55:47,540
将在结果中显示这

1417
00:55:47,540 --> 00:55:48,980
一点 我认为

1418
00:55:48,980 --> 00:55:49,970
从超级论文中得出的另外一件事我认为很

1419
00:55:49,970 --> 00:55:53,210
有趣是他们制定

1420
00:55:53,210 --> 00:55:54,890
了一些规则，如果您愿意，您应该尝试遵循这些规则

1421
00:55:54,890 --> 00:55:57,530
实现

1422
00:55:57,530 --> 00:56:00,260
一个有效的排序合并算法

1423
00:56:00,260 --> 00:56:01,730
联合算法知道

1424
00:56:01,730 --> 00:56:03,619
硬件然后可以

1425
00:56:03,619 --> 00:56:05,450
很好地瘫痪所以他们要争论的第一件事

1426
00:56:05,450 --> 00:56:07,730
是你没有

1427
00:56:07,730 --> 00:56:09,740
对非本地内存的任何随机写入正确

1428
00:56:09,740 --> 00:56:11,840
对比这个

1429
00:56:11,840 --> 00:56:14,359
当您进行这些随机写入时进行多次合并

1430
00:56:14,359 --> 00:56:17,930
，然后您想要

1431
00:56:17,930 --> 00:56:19,190
做的是将事情分解，然后

1432
00:56:19,190 --> 00:56:20,570
触发它们并使每个核心

1433
00:56:20,570 --> 00:56:23,420
对本地数据进行操作，第二条

1434
00:56:23,420 --> 00:56:24,800
规则是您要尝试 要执行

1435
00:56:24,800 --> 00:56:26,240
它，然后你必须读取

1436
00:56:26,240 --> 00:56:28,310
不是你的线程本地的数据总是做

1437
00:56:28,310 --> 00:56:30,320
中央扫描，这样港口提取器可以

1438
00:56:30,320 --> 00:56:32,359
将东西带入 CPU 缓存我有

1439
00:56:32,359 --> 00:56:34,310
惩罚不起作用我总是

1440
00:56:34,310 --> 00:56:36,170
打破这种情况，对于这些 se 加入

1441
00:56:36,170 --> 00:56:39,940
，然后最后一个与费用有关，

1442
00:56:39,940 --> 00:56:44,240
就像在第三级中的多路合并

1443
00:56:44,240 --> 00:56:46,310
一样，总的来说，这

1444
00:56:46,310 --> 00:56:47,990
对于并行系统总是很好的建议，

1445
00:56:47,990 --> 00:56:50,090
无论如何你不想让任何核心

1446
00:56:50,090 --> 00:56:51,440
不得不等待另一个线程

1447
00:56:51,440 --> 00:56:53,330
做正确的事情，这意味着您要

1448
00:56:53,330 --> 00:56:54,770
避免细雨锁存或

1449
00:56:54,770 --> 00:56:58,070
同步障碍，并且让

1450
00:56:58,070 --> 00:57:00,470
每个线程都能够立即对数据进行操作，

1451
00:57:00,470 --> 00:57:02,810
而尽可能多

1452
00:57:02,810 --> 00:57:03,740
地不符合

1453
00:57:03,740 --> 00:57:08,030
其他任何人的要求，以便

1454
00:57:08,030 --> 00:57:10,250
完成 关于结果，我们将

1455
00:57:10,250 --> 00:57:12,350
讨论你们

1456
00:57:12,350 --> 00:57:14,540
签署的论文，他们从 ETH 阅读，他们

1457
00:57:14,540 --> 00:57:16,370
实际上将

1458
00:57:16,370 --> 00:57:17,840
比较三种不同类型的完整

1459
00:57:17,840 --> 00:57:18,830
联合算法，我

1460
00:57:18,830 --> 00:57:22,130
刚刚在一台非常强大的机器上讨论过这些算法

1461
00:57:22,130 --> 00:57:24,500
那个时候有四个插槽和

1462
00:57:24,500 --> 00:57:26,930
半 TB 的 DRAM 所以

1463
00:57:26,930 --> 00:57:31,160
所有东西都可以放入内存中 所以

1464
00:57:31,160 --> 00:57:32,780
他们将与

1465
00:57:32,780 --> 00:57:35,270
三种合并连接的三款游戏进行比较

1466
00:57:35,270 --> 00:57:36,740
所以他们开发的两个 然后

1467
00:57:36,740 --> 00:57:38,420
是来自 hyper 的那个，然后他们还将

1468
00:57:38,420 --> 00:57:40,910
与

1469
00:57:40,910 --> 00:57:43,130
我们上一堂课讨论的基数分区散列连接进行比较

1470
00:57:43,130 --> 00:57:44,690
我认为在本文中他们

1471
00:57:44,690 --> 00:57:46,640
将其称为基数连接只是

1472
00:57:46,640 --> 00:57:48,800
意味着它是一个基数分区散列

1473
00:57:48,800 --> 00:57:53,360
运行所以 他们想要比较或评估的第一件事

1474
00:57:53,360 --> 00:57:56,090


1475
00:57:56,090 --> 00:57:58,100
是我们

1476
00:57:58,100 --> 00:58:01,250
之前从英特尔讨论过的 sim D

1477
00:58:01,250 --> 00:58:03,680
排序算法如何与在单线程上运行时的某种非

1478
00:58:03,680 --> 00:58:05,900
矢量化或非 Cindy 实现进行比较，

1479
00:58:05,900 --> 00:58:07,540


1480
00:58:07,540 --> 00:58:11,720
所以 他们将与 SCBA

1481
00:58:11,720 --> 00:58:14,240
和 STL 的标准剑配对，这是一种

1482
00:58:14,240 --> 00:58:16,010
混合剑，在开始时使用快速排序

1483
00:58:16,010 --> 00:58:17,510
，然后

1484
00:58:17,510 --> 00:58:19,040
随着您的深入而切换到堆排序

1485
00:58:19,040 --> 00:58:22,220
，他们这只是向您展示了

1486
00:58:22,220 --> 00:58:24,020
沿 x 轴的方向 增加

1487
00:58:24,020 --> 00:58:26,300
你想要排序的元组的数量，你可以

1488
00:58:26,300 --> 00:58:29,330
显示你可以获得的吞吐量以及

1489
00:58:29,330 --> 00:58:32,240
它是如何变化的，所以这实际上是一个

1490
00:58:32,240 --> 00:58:33,820
很好的结果，因为这实际上

1491
00:58:33,820 --> 00:58:37,370
证实了 2009 年的英特尔

1492
00:58:37,370 --> 00:58:38,930
论文 d 相同的比较，所以这

1493
00:58:38,930 --> 00:58:41,150
有点像你知道进一步的理由

1494
00:58:41,150 --> 00:58:43,670
或证据表明 cindy 排序

1495
00:58:43,670 --> 00:58:46,190
比你知道的 sisty

1496
00:58:46,190 --> 00:58:48,260
排序实现更可取，这

1497
00:58:48,260 --> 00:58:50,030
与英特尔报告的加速完全匹配

1498
00:58:50,030 --> 00:58:52,520
，大约是你

1499
00:58:52,520 --> 00:58:55,220
知道的 3 倍 更快，所以你知道这是一门

1500
00:58:55,220 --> 00:58:56,780
很好的科学，这真的很酷

1501
00:58:56,780 --> 00:59:00,140
，他们能够做到这一点，所以

1502
00:59:00,140 --> 00:59:01,400
现在你想这样做，你可以比较

1503
00:59:01,400 --> 00:59:03,530
这个和排序，如果

1504
00:59:03,530 --> 00:59:04,850
他们想要外面的桌子

1505
00:59:04,850 --> 00:59:06,470
16 亿两颗子弹，内

1506
00:59:06,470 --> 00:59:09,170
表是 1.28 亿元组，它们

1507
00:59:09,170 --> 00:59:12,250
将只是按元组对 8 8 进行排序，

1508
00:59:12,250 --> 00:59:16,820
所以划分的方式是我们

1509
00:59:16,820 --> 00:59:18,380
有多路多通和

1510
00:59:18,380 --> 00:59:20,450
来自 hyper 的讨厌的并行，然后

1511
00:59:20,450 --> 00:59:22,730
它被分解为不同阶段的元组花费的时间

1512
00:59:22,730 --> 00:59:24,320
或周期量，

1513
00:59:24,320 --> 00:59:27,170
因此

1514
00:59:27,170 --> 00:59:29,039
所有这些阶段的分区阶段

1515
00:59:29,039 --> 00:59:31,169
大致相同，但

1516
00:59:31,169 --> 00:59:33,119
您现在看到的最大区别在于排序和

1517
00:59:33,119 --> 00:59:36,329
合并 所以这是

1518
00:59:36,329 --> 00:59:38,039
实际排序算法的排序阶段，然后这

1519
00:59:38,039 --> 00:59:40,650
是合并

1520
00:59:40,650 --> 00:59:42,449
算法的合并

1521
00:59:42,449 --> 00:59:44,189
阶段，然后这是联合算法的合并阶段，但这是一个

1522
00:59:44,189 --> 00:59:45,749
你知道这显然令人困惑

1523
00:59:45,749 --> 00:59:47,039
我们正在合并两次但是 这

1524
00:59:47,039 --> 00:59:48,660
是排序的地方，这是用于

1525
00:59:48,660 --> 00:59:52,289
连接的，所以这里的主要内容

1526
00:59:52,289 --> 00:59:54,390
是多路实际上执行最好的

1527
00:59:54,390 --> 00:59:57,029
分区是相同的排序

1528
00:59:57,029 --> 00:59:59,189
比多路慢一点，

1529
00:59:59,189 --> 01:00:03,630
但然后合并路是你

1530
01:00:03,630 --> 01:00:05,939
知道什么都没有，然后

1531
01:00:05,939 --> 01:00:08,369
合并本身或连接非常快，

1532
01:00:08,369 --> 01:00:12,569
因为那总是

1533
01:00:12,569 --> 01:00:14,910
对您本地的数据进行操作，

1534
01:00:14,910 --> 01:00:16,469
我的数字区域swaggin 所以

1535
01:00:16,469 --> 01:00:17,640
我花费的周期数进行

1536
01:00:17,640 --> 01:00:20,819
比较是超短的 在

1537
01:00:20,819 --> 01:00:22,709
hyper 的情况下，他们花费

1538
01:00:22,709 --> 01:00:25,679
更多的时间更多的周期访问远程

1539
01:00:25,679 --> 01:00:27,630
内存，他们支付了巨额罚款，所以

1540
01:00:27,630 --> 01:00:29,910
这表明 hyper 声称的港口

1541
01:00:29,910 --> 01:00:31,890
预取器将在

1542
01:00:31,890 --> 01:00:34,979
这里和doe 帮助他们 不是另一种

1543
01:00:34,979 --> 01:00:36,869
可以绘制它的方法是包括

1544
01:00:36,869 --> 01:00:38,669
吞吐量图，因此在这种情况下，

1545
01:00:38,669 --> 01:00:39,809
当您为输出执行周期时，

1546
01:00:39,809 --> 01:00:41,669
每两个池

1547
01:00:41,669 --> 01:00:44,429
输出的周期明显较低，

1548
01:00:44,429 --> 01:00:46,199
在吞吐量线的情况下，输出越低越好，

1549
01:00:46,199 --> 01:00:48,089
因为您” 快速返回更多数据

1550
01:00:48,089 --> 01:00:50,609
，所以正如预期的那样，如果你们看到更少的

1551
01:00:50,609 --> 01:00:53,159
指令来计算连接，

1552
01:00:53,159 --> 01:00:57,059
吞吐量会更高，所以

1553
01:00:57,059 --> 01:00:59,279
这又是一个很好的结果，它

1554
01:00:59,279 --> 01:01:01,109
只是向您展示了您知道

1555
01:01:01,109 --> 01:01:03,839
在哪个阶段发生故障 关节

1556
01:01:03,839 --> 01:01:06,119
本身是你花所有的时间

1557
01:01:06,119 --> 01:01:08,759
，如果你知道你是否

1558
01:01:08,759 --> 01:01:09,989
正在设计你的专辑，你会

1559
01:01:09,989 --> 01:01:12,299
意识到并意识到缓存大小

1560
01:01:12,299 --> 01:01:14,429
和我的新 Murray jhin's 我能够

1561
01:01:14,429 --> 01:01:16,199
获得更好的性能 将

1562
01:01:16,199 --> 01:01:19,650
它们从远程读取中最小化我必须

1563
01:01:19,650 --> 01:01:21,749
做我应该将婴儿惩罚

1564
01:01:21,749 --> 01:01:23,159
移到开头但是然后

1565
01:01:23,159 --> 01:01:25,469
远程读取是你最后没有

1566
01:01:25,469 --> 01:01:28,650
任何东西所以下一个将

1567
01:01:28,650 --> 01:01:31,799
限制错误现在只是一个 更多

1568
01:01:31,799 --> 01:01:33,119
细节 现在缩放

1569
01:01:33,119 --> 01:01:36,900
多路和超级连接的脚的线程数，

1570
01:01:36,900 --> 01:01:39,449
所以在这种情况下，

1571
01:01:39,449 --> 01:01:42,390
我认为

1572
01:01:42,390 --> 01:01:45,220
这是一台机器上的所有线程，

1573
01:01:45,220 --> 01:01:47,320
但现在正在扩展，我

1574
01:01:47,320 --> 01:01:49,360
是线程数 因此，当您在

1575
01:01:49,360 --> 01:01:51,160
一个线程上失败时，并不是说

1576
01:01:51,160 --> 01:01:53,080
它们中的两个之间没有太大区别，

1577
01:01:53,080 --> 01:01:54,220
尽管多路仍然

1578
01:01:54,220 --> 01:01:56,320
更快，但是当您现在按

1579
01:01:56,320 --> 01:01:58,360
顺序扩展线程时，您会看到更大

1580
01:01:58,360 --> 01:02:01,210
的性能差距等等 这现在向您展示了

1581
01:02:01,210 --> 01:02:05,140
如何按比例

1582
01:02:05,140 --> 01:02:06,850
缩放日志，就像

1583
01:02:06,850 --> 01:02:08,590
当我们沿 x 轴移动时将线程数加倍一样，

1584
01:02:08,590 --> 01:02:10,750
因此如果您能够实现线性

1585
01:02:10,750 --> 01:02:12,640
可扩展性，这是

1586
01:02:12,640 --> 01:02:14,770
您想要的黄金标准 一个并行系统，

1587
01:02:14,770 --> 01:02:16,240
如果我将线程数和

1588
01:02:16,240 --> 01:02:18,220
内部绳索的

1589
01:02:18,220 --> 01:02:19,600
数量加倍，我的吞吐量或

1590
01:02:19,600 --> 01:02:22,180
工作量就会加倍，因此如果

1591
01:02:22,180 --> 01:02:25,150
多路合并排序在 16 个线程时一切正常，

1592
01:02:25,150 --> 01:02:27,460
我将执行 1.3 亿个元组

1593
01:02:27,460 --> 01:02:29,410
每秒然后如果我加倍 e

1594
01:02:29,410 --> 01:02:32,590
线程数为 32 我正在做 259 所以它

1595
01:02:32,590 --> 01:02:35,380
略小于 260 但它

1596
01:02:35,380 --> 01:02:37,780
几乎是两倍，当然一旦你

1597
01:02:37,780 --> 01:02:40,090
有超线程，你不

1598
01:02:40,090 --> 01:02:42,490
知道它们不是真正的真正的核心，你

1599
01:02:42,490 --> 01:02:43,990
必须编程你的计数器 '

1600
01:02:43,990 --> 01:02:45,940
你是不是

1601
01:02:45,940 --> 01:02:49,510
在内核之间切换，所以如果你的 CPU

1602
01:02:49,510 --> 01:02:51,760
限制在这种情况下没有真正的帮助，

1603
01:02:51,760 --> 01:02:55,750
我们可能是内存限制，所以你

1604
01:02:55,750 --> 01:02:56,920
仍然可以得到一点

1605
01:02:56,920 --> 01:02:58,180
改进，但它不会

1606
01:02:58,180 --> 01:03:00,190
在超方法的情况下线

1607
01:03:00,190 --> 01:03:02,320
性缩放他们不能缩放

1608
01:03:02,320 --> 01:03:06,670
线性定律所以从 54 到 290 像

1609
01:03:06,670 --> 01:03:09,640
这样应该是 108 但

1610
01:03:09,640 --> 01:03:11,320
我们只有 90 所以即使我们

1611
01:03:11,320 --> 01:03:13,030
添加更多线程 我们的性能变得越来越

1612
01:03:13,030 --> 01:03:14,140
差，然后当我们

1613
01:03:14,140 --> 01:03:15,910
进入超线程时，它

1614
01:03:15,910 --> 01:03:19,210
就会分崩离析

1615
01:03:19,210 --> 01:03:21,040


1616
01:03:21,040 --> 01:03:22,540


1617
01:03:22,540 --> 01:03:25,270


1618
01:03:25,270 --> 01:03:28,780
为我们付出，因为我们

1619
01:03:28,780 --> 01:03:32,680
不必让你知道我们

1620
01:03:32,680 --> 01:03:34,960
当我们进行联合专辑的合并阶段时，我们没有进行远程读取

1621
01:03:34,960 --> 01:03:37,840
，如果

1622
01:03:37,840 --> 01:03:39,460
跨新海军陆战队的阅读开销

1623
01:03:39,460 --> 01:03:41,260
是什么损害了

1624
01:03:41,260 --> 01:03:44,050
高性能，在这种情况下

1625
01:03:44,050 --> 01:03:46,780
，Hyper 正在发生的事情是

1626
01:03:46,780 --> 01:03:48,430
它掉下来的原因， 获得

1627
01:03:48,430 --> 01:03:51,700
最差的性能，因为如果我现在将

1628
01:03:51,700 --> 01:03:54,430
数据拆分到多个线程中，

1629
01:03:54,430 --> 01:03:55,599
越来越多的线程

1630
01:03:55,599 --> 01:03:58,239
那么当一个线程运行

1631
01:03:58,239 --> 01:04:00,039
并尝试访问一个元组时

1632
01:04:00,039 --> 01:04:05,829
，该线程的可能性

1633
01:04:05,829 --> 01:04:08,200
不是 - 他们喜欢拥抱 当我添加更多线程时，我的喉咙

1634
01:04:08,200 --> 01:04:09,519
正在尝试访问不在我的

1635
01:04:09,519 --> 01:04:11,319
数字中增加，

1636
01:04:11,319 --> 01:04:12,609
因为现在数据被拆

1637
01:04:12,609 --> 01:04:14,829
分到多个线程中，因此我正在

1638
01:04:14,829 --> 01:04:18,700
执行一个或多个远程远程读取，因此

1639
01:04:18,700 --> 01:04:22,210
对于此图表，此图表正在

1640
01:04:22,210 --> 01:04:25,720
比较 多路合并排序

1641
01:04:25,720 --> 01:04:28,019
排序合并连接与基数散列连接

1642
01:04:28,019 --> 01:04:30,999
，我在这里向您展示的是，

1643
01:04:30,999 --> 01:04:33,039
您正在改变

1644
01:04:33,039 --> 01:04:35,380
外表中内表的不同大小，

1645
01:04:35,380 --> 01:04:37,630
这里显示的是 对于较小的

1646
01:04:37,630 --> 01:04:40,269
表大小

1647
01:04:40,269 --> 01:04:42,249
，它们两者之间的性能差距相当大，

1648
01:04:42,249 --> 01:04:44,410
然后随着您增加越来越

1649
01:04:44,410 --> 01:04:46,720
大和越来越大的表，

1650
01:04:46,720 --> 01:04:47,920
分区的散列成本越来越高

1651
01:04:47,920 --> 01:04:50,769
，这会抵消

1652
01:04:50,769 --> 01:04:51,910
一些差异 得到

1653
01:04:51,910 --> 01:04:53,229
之前，如果你克服

1654
01:04:53,229 --> 01:04:54,910
了与他们合并的那种合并会更好，但

1655
01:04:54,910 --> 01:04:57,279
它仍然会在这里击败它

1656
01:04:57,279 --> 01:05:00,849
，所以为此，我

1657
01:05:00,849 --> 01:05:03,329
将构建探测阶段组合在一起

1658
01:05:03,329 --> 01:05:05,799
，只做一个数字，但它

1659
01:05:05,799 --> 01:05:08,499
显示 您认为构建

1660
01:05:08,499 --> 01:05:10,569
哈希表然后

1661
01:05:10,569 --> 01:05:12,789
在某些情况下探测它以找到匹配项的成本可能低于对内表

1662
01:05:12,789 --> 01:05:14,979
中的外部表进行排序

1663
01:05:14,979 --> 01:05:17,319
和合并绘图的成本，

1664
01:05:17,319 --> 01:05:19,749
因为那时我仍然需要

1665
01:05:19,749 --> 01:05:22,359
进行连接 我尝试在排序后进行合并

1666
01:05:22,359 --> 01:05:24,190
，然后进行合并以加入，

1667
01:05:24,190 --> 01:05:26,710
就像进行排序阶段的成本一样

1668
01:05:26,710 --> 01:05:29,920
，有时它不仅仅是

1669
01:05:29,920 --> 01:05:32,140
构建哈希表，所以这有点

1670
01:05:32,140 --> 01:05:35,410
向您展示为什么您知道使用

1671
01:05:35,410 --> 01:05:36,960
eff 即使我们不能

1672
01:05:36,960 --> 01:05:38,650
在多个线程之间并行化的

1673
01:05:38,650 --> 01:05:41,349
强大哈希表实现，即使我们不能

1674
01:05:41,349 --> 01:05:44,469


1675
01:05:44,469 --> 01:05:46,779
在哈希连接中完成所有这些过程，但它仍然可能

1676
01:05:46,779 --> 01:05:51,309
比排序要快得多，

1677
01:05:51,309 --> 01:05:52,539
我们实际上会击败哈希

1678
01:05:52,539 --> 01:05:57,489
连接的排序合并是 如果我的查询输出将我的

1679
01:05:57,489 --> 01:06:00,430
查询作为 Clause 的订单，

1680
01:06:00,430 --> 01:06:03,460
这与需要

1681
01:06:03,460 --> 01:06:06,670
在我加入的同一个键上对数据进行排序是一样的，

1682
01:06:06,670 --> 01:06:08,810
那么如果我进行排序合并，

1683
01:06:08,810 --> 01:06:11,810
我可以只使用输出

1684
01:06:11,810 --> 01:06:14,150
连接已经

1685
01:06:14,150 --> 01:06:15,800
与我的订单所需的方式相同，我

1686
01:06:15,800 --> 01:06:17,480
不必进行额外的排序，所以在

1687
01:06:17,480 --> 01:06:19,280
这种情况下，在这里说我必须

1688
01:06:19,280 --> 01:06:23,390
为此进行排序我使用这个透明

1689
01:06:23,390 --> 01:06:25,250
球 说我已经为这个查询做了一个 order by

1690
01:06:25,250 --> 01:06:27,230
如果 order by 与

1691
01:06:27,230 --> 01:06:28,880
我使用的服务器的联合密钥相同，

1692
01:06:28,880 --> 01:06:31,610
我没有，那么我

1693
01:06:31,610 --> 01:06:32,840
不需要做任何额外的努力

1694
01:06:32,840 --> 01:06:35,120
在这种情况下，如果我需要对

1695
01:06:35,120 --> 01:06:37,280
我的哈希表进行排序，请在此处进行联合，然后我必须

1696
01:06:37,280 --> 01:06:39,620
添加相同的 t 块 我在这里

1697
01:06:39,620 --> 01:06:41,660
它会少一点

1698
01:06:41,660 --> 01:06:44,450
取决于连接的输出，但它仍然是

1699
01:06:44,450 --> 01:06:46,130
我必须做的额外步骤，这

1700
01:06:46,130 --> 01:06:47,780
是我需要在我的查询

1701
01:06:47,780 --> 01:06:50,950
优化器中计数的东西所以这个图只是

1702
01:06:50,950 --> 01:06:54,020
解释最后一个图

1703
01:06:54,020 --> 01:06:58,610


1704
01:06:58,610 --> 01:07:00,140
当您尝试连接时

1705
01:07:00,140 --> 01:07:01,910
如何改变表的大小的幻灯片，如果两种方法之间的性能差距如何

1706
01:07:01,910 --> 01:07:05,090
缩小，这

1707
01:07:05,090 --> 01:07:07,100
只是向您展示了

1708
01:07:07,100 --> 01:07:10,100
当您有更大的表时使用基数哈希连接

1709
01:07:10,100 --> 01:07:13,670
必须做更多的传递才能

1710
01:07:13,670 --> 01:07:15,410
进行分区，并且

1711
01:07:15,410 --> 01:07:18,050
您获得的性能优势会降低，但

1712
01:07:18,050 --> 01:07:20,660
最终还是会这样，它

1713
01:07:20,660 --> 01:07:22,310
会比排序合并连接更可取

1714
01:07:22,310 --> 01:07:24,770
，我不会忘记为什么会出现这种情况 +

1715
01:07:24,770 --> 01:07:28,520
高原 嗯，我认为在某些时候，您

1716
01:07:28,520 --> 01:07:29,810
只是

1717
01:07:29,810 --> 01:07:32,480
在以与在基于磁盘的系统中所做的相同的方式支付内存中和内存外的每个人

1718
01:07:32,480 --> 01:07:38,720


1719
01:07:38,720 --> 01:07:41,110


1720
01:07:41,110 --> 01:07:46,310
的代价 商业或

1721
01:07:46,310 --> 01:07:47,690
企业或高端

1722
01:07:47,690 --> 01:07:49,280
哦，想要具有

1723
01:07:49,280 --> 01:07:50,960
竞争力的数据库系统，您将同时

1724
01:07:50,960 --> 01:07:52,640
需要哈希连接和证书合并连接

1725
01:07:52,640 --> 01:07:53,390
算法，

1726
01:07:53,390 --> 01:07:55,280
我认为它们都实现了，

1727
01:07:55,280 --> 01:07:56,660
优化器将找出您

1728
01:07:56,660 --> 01:08:01,190
真正想要使用的那个，所以如果

1729
01:08:01,190 --> 01:08:04,010
你是 构建一个新系统从头开始，

1730
01:08:04,010 --> 01:08:05,570
除非您针对旧的 GP 工作负载，

1731
01:08:05,570 --> 01:08:07,100
如果您尝试针对 OLAP 或提出

1732
01:08:07,100 --> 01:08:08,780
您想要构建的第一个连接实现

1733
01:08:08,780 --> 01:08:09,950
是哈希连接，

1734
01:08:09,950 --> 01:08:11,990
因为它只是研究，因此

1735
01:08:11,990 --> 01:08:14,330
理想情况下它是您 清楚

1736
01:08:14,330 --> 01:08:16,760
地知道比合并的那种更好和更快

1737
01:08:16,760 --> 01:08:19,460
，正如我在最后所说的那样，

1738
01:08:19,460 --> 01:08:20,930
我们也不考虑

1739
01:08:20,930 --> 01:08:24,500
已经

1740
01:08:24,500 --> 01:08:27,590
在连接键上对数据进行排序的影响，因为您可能

1741
01:08:27,590 --> 01:08:29,899
需要通过 order by 子句和 在这种

1742
01:08:29,899 --> 01:08:31,880
情况下，他们就像您知道您

1743
01:08:31,880 --> 01:08:33,380
不必支付额外的排序费用一样，

1744
01:08:33,380 --> 01:08:34,910
并且排序 MERS 联合实际上

1745
01:08:34,910 --> 01:08:38,090
最终可能比 B 更好，然后是散列

1746
01:08:38,090 --> 01:08:39,529
连接，但这也是

1747
01:08:39,529 --> 01:08:41,620
查询优化器可以解决的问题 你是

1748
01:08:41,620 --> 01:08:46,279
这样的 今天星期三的

1749
01:08:46,279 --> 01:08:48,830
课程就到这里了，现在我们将进入

1750
01:08:48,830 --> 01:08:50,979
数据库系统的一部分，我

1751
01:08:50,979 --> 01:08:55,970
承认我知道的最少，

1752
01:08:55,970 --> 01:08:56,930
但这是我觉得最

1753
01:08:56,930 --> 01:08:59,990
有趣的部分，所以我们将做一个我们已经

1754
01:08:59,990 --> 01:09:03,200
扩展的系列讲座

1755
01:09:03,200 --> 01:09:04,069
学期我们将有

1756
01:09:04,069 --> 01:09:07,160
关于 Cori 优化器的额外讲座，

1757
01:09:07,160 --> 01:09:08,779
这里的想法是尝试了解

1758
01:09:08,779 --> 01:09:12,140
我们如何进行后续查询并将

1759
01:09:12,140 --> 01:09:13,640
其转换为我们

1760
01:09:13,640 --> 01:09:15,020
希望在我们的系统上执行的最佳查询计划，以便我们可以

1761
01:09:15,020 --> 01:09:16,460
使用所有

1762
01:09:16,460 --> 01:09:18,140
到目前为止我们讨论过的各种技术联合

1763
01:09:18,140 --> 01:09:20,569
岛向量化执行

1764
01:09:20,569 --> 01:09:22,880
调度方法所有索引所有

1765
01:09:22,880 --> 01:09:24,170
这些不同的事情现在我们认为我们

1766
01:09:24,170 --> 01:09:28,010
可以在我们做我们的和

1767
01:09:28,010 --> 01:09:30,260
尝试构建我们的查询计划

1768
01:09:30,260 --> 01:09:31,609
时考虑 这是星期三

1769
01:09:31,609 --> 01:09:33,410
阅读的标志只是

1770
01:09:33,410 --> 01:09:34,340
您必须

1771
01:09:34,340 --> 01:09:38,300
在查询优化器中处理的各种问题的概述，然后在下周

1772
01:09:38,300 --> 01:09:39,950
讨论实际

1773
01:09:39,950 --> 01:09:41,390
实现和主要差异 erence

1774
01:09:41,390 --> 01:09:43,189
将是

1775
01:09:43,189 --> 01:09:46,040
来自 IDM 的这种动态编程方法与

1776
01:09:46,040 --> 01:09:49,700
来自火山家伙的 Cascade 方法 好的

1777
01:09:49,700 --> 01:09:52,850
，现在就是这样，在

1778
01:09:52,850 --> 01:09:54,650
Piazza 上发表了

1779
01:09:54,650 --> 01:09:56,480
一篇关于为下周的项目

1780
01:09:56,480 --> 01:09:58,790
演示做好准备的

1781
01:09:58,790 --> 01:10:01,850
帖子 这个傻瓜嘿嘿

1782
01:10:01,850 --> 01:10:03,119
[音乐]

1783
01:10:03,119 --> 01:10:05,400
这个婊子的设计在这里

1784
01:10:05,400 --> 01:10:08,099
叫做整个工具包 因为我很喜欢你

1785
01:10:08,099 --> 01:10:10,800
的暴躁 嗨你看起来 去

1786
01:10:10,800 --> 01:10:13,800
给我拿一个 40 只是为了得到我的嗡嗡声

1787
01:10:13,800 --> 01:10:16,670
因为我只需要一个 多

1788
01:10:16,670 --> 01:10:22,469
踢我的嘴唇，只是说

1789
01:10:22,469 --> 01:10:25,590
好，我的兜帽不会一样了 我

1790
01:10:25,590 --> 01:10:29,869
很高兴坐下来 我祈祷

